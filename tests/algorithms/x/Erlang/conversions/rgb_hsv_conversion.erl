#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, absf/1, fmod/2, roundf/1, maxf/3, minf/3, hsv_to_rgb/3, rgb_to_hsv/3, approximately_equal_hsv/2]).

% Generated by Mochi transpiler v0.10.59 (52a2f6fb79) on 2025-08-07 00:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

absf(X) ->
    try
        (case (X < 0) of
    true -> -X;
    _ -> X
end)
    catch {return, Ret} -> Ret end.

fmod(A, B) ->
    try
        (A - mochi_safe_mul(B, mochi_to_int(mochi_safe_div(A, B))))
    catch {return, Ret} -> Ret end.

roundf(X_2) ->
    try
        (case (X_2 >= 0) of
    true -> mochi_to_int((X_2 + 0.5));
    _ -> mochi_to_int((X_2 - 0.5))
end)
    catch {return, Ret} -> Ret end.

maxf(A_2, B_2, C) ->
    try
        M = A_2,
        case (B_2 > M) of
        true -> M_2 = B_2,
            M_3 = M_2;
        _ -> M_3 = M
    end,
        case (C > M_3) of
        true -> M_4 = C,
            M_5 = M_4;
        _ -> M_5 = M_3
    end,
        M_5
    catch {return, Ret} -> Ret end.

minf(A_3, B_3, C_2) ->
    try
        M_6 = A_3,
        case (B_3 < M_6) of
        true -> M_7 = B_3,
            M_8 = M_7;
        _ -> M_8 = M_6
    end,
        case (C_2 < M_8) of
        true -> M_9 = C_2,
            M_10 = M_9;
        _ -> M_10 = M_8
    end,
        M_10
    catch {return, Ret} -> Ret end.

hsv_to_rgb(Hue, Saturation, Value) ->
    try
        case ((Hue < 0) orelse (Hue > 360)) of
        true -> io:format("~ts~n", [mochi_repr("hue should be between 0 and 360")]),
            throw({return, []});
        _ -> ok
    end,
        case ((Saturation < 0) orelse (Saturation > 1)) of
        true -> io:format("~ts~n", [mochi_repr("saturation should be between 0 and 1")]),
            throw({return, []});
        _ -> ok
    end,
        case ((Value < 0) orelse (Value > 1)) of
        true -> io:format("~ts~n", [mochi_repr("value should be between 0 and 1")]),
            throw({return, []});
        _ -> ok
    end,
        Chroma = mochi_safe_mul(Value, Saturation),
        Hue_section = mochi_safe_div(Hue, 60),
        Second_largest_component = mochi_safe_mul(Chroma, (1 - absf((fmod(Hue_section, 2) - 1)))),
        Match_value = (Value - Chroma),
        Red = nil,
        Green = nil,
        Blue = nil,
        case ((Hue_section >= 0) andalso (Hue_section =< 1)) of
        true -> Red_2 = roundf(mochi_safe_mul(255, (Chroma + Match_value))),
            Green_2 = roundf(mochi_safe_mul(255, (Second_largest_component + Match_value))),
            Blue_2 = roundf(mochi_safe_mul(255, Match_value)),
            Blue_12 = Blue_2,
            Green_12 = Green_2,
            Red_12 = Red_2;
        _ -> case ((Hue_section > 1) andalso (Hue_section =< 2)) of
        true -> Red_3 = roundf(mochi_safe_mul(255, (Second_largest_component + Match_value))),
            Green_3 = roundf(mochi_safe_mul(255, (Chroma + Match_value))),
            Blue_3 = roundf(mochi_safe_mul(255, Match_value)),
            Blue_11 = Blue_3,
            Green_11 = Green_3,
            Red_11 = Red_3;
        _ -> case ((Hue_section > 2) andalso (Hue_section =< 3)) of
        true -> Red_4 = roundf(mochi_safe_mul(255, Match_value)),
            Green_4 = roundf(mochi_safe_mul(255, (Chroma + Match_value))),
            Blue_4 = roundf(mochi_safe_mul(255, (Second_largest_component + Match_value))),
            Blue_10 = Blue_4,
            Green_10 = Green_4,
            Red_10 = Red_4;
        _ -> case ((Hue_section > 3) andalso (Hue_section =< 4)) of
        true -> Red_5 = roundf(mochi_safe_mul(255, Match_value)),
            Green_5 = roundf(mochi_safe_mul(255, (Second_largest_component + Match_value))),
            Blue_5 = roundf(mochi_safe_mul(255, (Chroma + Match_value))),
            Blue_9 = Blue_5,
            Green_9 = Green_5,
            Red_9 = Red_5;
        _ -> case ((Hue_section > 4) andalso (Hue_section =< 5)) of
        true -> Red_6 = roundf(mochi_safe_mul(255, (Second_largest_component + Match_value))),
            Green_6 = roundf(mochi_safe_mul(255, Match_value)),
            Blue_6 = roundf(mochi_safe_mul(255, (Chroma + Match_value))),
            Blue_8 = Blue_6,
            Green_8 = Green_6,
            Red_8 = Red_6;
        _ -> Red_7 = roundf(mochi_safe_mul(255, (Chroma + Match_value))),
            Green_7 = roundf(mochi_safe_mul(255, Match_value)),
            Blue_7 = roundf(mochi_safe_mul(255, (Second_largest_component + Match_value))),
            Blue_8 = Blue_7,
            Green_8 = Green_7,
            Red_8 = Red_7
    end,
            Blue_9 = Blue_8,
            Green_9 = Green_8,
            Red_9 = Red_8
    end,
            Blue_10 = Blue_9,
            Green_10 = Green_9,
            Red_10 = Red_9
    end,
            Blue_11 = Blue_10,
            Green_11 = Green_10,
            Red_11 = Red_10
    end,
            Blue_12 = Blue_11,
            Green_12 = Green_11,
            Red_12 = Red_11
    end,
        [Red_12, Green_12, Blue_12]
    catch {return, Ret} -> Ret end.

rgb_to_hsv(Red_13, Green_13, Blue_13) ->
    try
        case ((Red_13 < 0) orelse (Red_13 > 255)) of
        true -> io:format("~ts~n", [mochi_repr("red should be between 0 and 255")]),
            throw({return, []});
        _ -> ok
    end,
        case ((Green_13 < 0) orelse (Green_13 > 255)) of
        true -> io:format("~ts~n", [mochi_repr("green should be between 0 and 255")]),
            throw({return, []});
        _ -> ok
    end,
        case ((Blue_13 < 0) orelse (Blue_13 > 255)) of
        true -> io:format("~ts~n", [mochi_repr("blue should be between 0 and 255")]),
            throw({return, []});
        _ -> ok
    end,
        Float_red = mochi_safe_div(Red_13, 255),
        Float_green = mochi_safe_div(Green_13, 255),
        Float_blue = mochi_safe_div(Blue_13, 255),
        Value_2 = maxf(Float_red, Float_green, Float_blue),
        Min_val = minf(Float_red, Float_green, Float_blue),
        Chroma_2 = (Value_2 - Min_val),
        Saturation_2 = (case (Value_2 == 0) of
    true -> 0;
    _ -> mochi_safe_div(Chroma_2, Value_2)
end),
        Hue_2 = nil,
        case (Chroma_2 == 0) of
        true -> Hue_3 = 0,
            Hue_9 = Hue_3;
        _ -> case (Value_2 == Float_red) of
        true -> Hue_4 = mochi_safe_mul(60, (0 + mochi_safe_div((Float_green - Float_blue), Chroma_2))),
            Hue_8 = Hue_4;
        _ -> case (Value_2 == Float_green) of
        true -> Hue_5 = mochi_safe_mul(60, (2 + mochi_safe_div((Float_blue - Float_red), Chroma_2))),
            Hue_7 = Hue_5;
        _ -> Hue_6 = mochi_safe_mul(60, (4 + mochi_safe_div((Float_red - Float_green), Chroma_2))),
            Hue_7 = Hue_6
    end,
            Hue_8 = Hue_7
    end,
            Hue_9 = Hue_8
    end,
        Hue_10 = fmod((Hue_9 + 360), 360),
        [Hue_10, Saturation_2, Value_2]
    catch {return, Ret} -> Ret end.

approximately_equal_hsv(Hsv1, Hsv2) ->
    try
        Check_hue = (absf(((case erlang:is_map(Hsv1) of true -> maps:get(0, Hsv1, nil); _ -> lists:nth(0 + 1, Hsv1) end) - (case erlang:is_map(Hsv2) of true -> maps:get(0, Hsv2, nil); _ -> lists:nth(0 + 1, Hsv2) end))) < 0.2),
        Check_saturation = (absf(((case erlang:is_map(Hsv1) of true -> maps:get(1, Hsv1, nil); _ -> lists:nth(1 + 1, Hsv1) end) - (case erlang:is_map(Hsv2) of true -> maps:get(1, Hsv2, nil); _ -> lists:nth(1 + 1, Hsv2) end))) < 0.002),
        Check_value = (absf(((case erlang:is_map(Hsv1) of true -> maps:get(2, Hsv1, nil); _ -> lists:nth(2 + 1, Hsv1) end) - (case erlang:is_map(Hsv2) of true -> maps:get(2, Hsv2, nil); _ -> lists:nth(2 + 1, Hsv2) end))) < 0.002),
        ((Check_hue andalso Check_saturation) andalso Check_value)
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('rgb', hsv_to_rgb(180, 0.5, 0.5)),
    io:format("~ts~n", [mochi_str(erlang:get('rgb'))]),
    erlang:put('hsv', rgb_to_hsv(64, 128, 128)),
    io:format("~ts~n", [mochi_str(erlang:get('hsv'))]),
    io:format("~ts~n", [mochi_str(approximately_equal_hsv(erlang:get('hsv'), [180, 0.5, 0.5]))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
