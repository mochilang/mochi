#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, to_upper/1, char_index/1, rotate_right/2, table_for/1, generate_table/1, str_index/2, get_position/2, get_opponent/2, encrypt/2, decrypt/2, main/0]).

% Generated by Mochi transpiler v0.10.59 (98c5e0dd92) on 2025-08-06 22:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

to_upper(S) ->
    try
        Res = "",
        I = 0,
        Fun_2 = fun Fun_2_loop(I, Res, S) ->
    case (I < length(S)) of
        true ->
            try
                Ch = string:substr(S, I + 1, ((I + 1) - I)),
                J = 0,
                Replaced = false,
                Fun = fun Fun_loop(Ch, I, J, Replaced, Res, S) ->
    case (J < length("abcdefghijklmnopqrstuvwxyz")) of
        true ->
            try
                case (string:substr("abcdefghijklmnopqrstuvwxyz", J + 1, ((J + 1) - J)) == Ch) of
        true -> Res_2 = (Res ++ string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", J + 1, ((J + 1) - J))),
            Replaced_2 = true,
            throw({break, Ch, I, J, Replaced_2, Res_2, S}),
            Replaced_3 = Replaced_2,
            Res_3 = Res_2;
        _ -> Replaced_3 = Replaced,
            Res_3 = Res
    end,
                J_2 = (J + 1),
                Fun_loop(Ch, I, J_2, Replaced_3, Res_3, S)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_loop(C0, C1, C2, C3, C4, C5);
                {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5}
            end;
        _ -> {Ch, I, J, Replaced, Res, S}
    end
end,
{Ch, I, J_2, Replaced_3, Res_3, S} = Fun(Ch, I, J, Replaced, Res, S),
                case mochi_not(Replaced_3) of
        true -> Res_4 = (Res_3 ++ Ch),
            Res_5 = Res_4;
        _ -> Res_5 = Res_3
    end,
                I_2 = (I + 1),
                Fun_2_loop(I_2, Res_5, S)
            catch
                {continue, C0, C1, C2} -> Fun_2_loop(C0, C1, C2);
                {break, B0, B1, B2} -> {B0, B1, B2}
            end;
        _ -> {I, Res, S}
    end
end,
{I_2, Res_5, S} = Fun_2(I, Res, S),
        Res_5
    catch {return, Ret} -> Ret end.

char_index(C) ->
    try
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(C, I_3) ->
    case (I_3 < length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) of
        true ->
            case (string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", I_3 + 1, ((I_3 + 1) - I_3)) == C) of
        true -> throw({return, I_3});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_3_loop(C, I_4);
        _ -> {C, I_3}
    end
end,
{C, I_4} = Fun_3(C, I_3),
        -1
    catch {return, Ret} -> Ret end.

rotate_right(S_2, K) ->
    try
        N = length(S_2),
        Shift = (K rem N),
        (string:substr(S_2, (N - Shift) + 1, (N - (N - Shift))) ++ string:substr(S_2, 0 + 1, ((N - Shift) - 0)))
    catch {return, Ret} -> Ret end.

table_for(C_2) ->
    try
        Idx = char_index(C_2),
        Shift_2 = (Idx div 2),
        Row1 = rotate_right("NOPQRSTUVWXYZ", Shift_2),
        Pair = ["ABCDEFGHIJKLM", Row1],
        Pair
    catch {return, Ret} -> Ret end.

generate_table(Key) ->
    try
        Up = to_upper(Key),
        I_5 = 0,
        Result = [],
        Fun_4 = fun Fun_4_loop(I_5, Key, Result, Up) ->
    case (I_5 < length(Up)) of
        true ->
            Ch_2 = string:substr(Up, I_5 + 1, ((I_5 + 1) - I_5)),
            Pair_2 = table_for(Ch_2),
            Result_2 = lists:append(Result, [Pair_2]),
            I_6 = (I_5 + 1),
            Fun_4_loop(I_6, Key, Result_2, Up);
        _ -> {I_5, Key, Result, Up}
    end
end,
{I_6, Key, Result_2, Up} = Fun_4(I_5, Key, Result, Up),
        Result_2
    catch {return, Ret} -> Ret end.

str_index(S_3, Ch_3) ->
    try
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(Ch_3, I_7, S_3) ->
    case (I_7 < length(S_3)) of
        true ->
            case (string:substr(S_3, I_7 + 1, ((I_7 + 1) - I_7)) == Ch_3) of
        true -> throw({return, I_7});
        _ -> ok
    end,
            I_8 = (I_7 + 1),
            Fun_5_loop(Ch_3, I_8, S_3);
        _ -> {Ch_3, I_7, S_3}
    end
end,
{Ch_3, I_8, S_3} = Fun_5(Ch_3, I_7, S_3),
        (0 - 1)
    catch {return, Ret} -> Ret end.

get_position(Table, Ch_4) ->
    try
        Row = 0,
        case (str_index((case erlang:is_map(Table) of true -> maps:get(0, Table, nil); _ -> lists:nth(0 + 1, Table) end), Ch_4) == (0 - 1)) of
        true -> Row_2 = 1,
            Row_3 = Row_2;
        _ -> Row_3 = Row
    end,
        Col = str_index((case erlang:is_map(Table) of true -> maps:get(Row_3, Table, nil); _ -> lists:nth(Row_3 + 1, Table) end), Ch_4),
        [Row_3, Col]
    catch {return, Ret} -> Ret end.

get_opponent(Table_2, Ch_5) ->
    try
        Pos = get_position(Table_2, Ch_5),
        Row_4 = (case erlang:is_map(Pos) of true -> maps:get(0, Pos, nil); _ -> lists:nth(0 + 1, Pos) end),
        Col_2 = (case erlang:is_map(Pos) of true -> maps:get(1, Pos, nil); _ -> lists:nth(1 + 1, Pos) end),
        case (Col_2 == (0 - 1)) of
        true -> throw({return, Ch_5});
        _ -> ok
    end,
        case (Row_4 == 1) of
        true -> throw({return, string:substr((case erlang:is_map(Table_2) of true -> maps:get(0, Table_2, nil); _ -> lists:nth(0 + 1, Table_2) end), Col_2 + 1, ((Col_2 + 1) - Col_2))});
        _ -> ok
    end,
        string:substr((case erlang:is_map(Table_2) of true -> maps:get(1, Table_2, nil); _ -> lists:nth(1 + 1, Table_2) end), Col_2 + 1, ((Col_2 + 1) - Col_2))
    catch {return, Ret} -> Ret end.

encrypt(Key_2, Words) ->
    try
        Table_3 = generate_table(Key_2),
        Up_words = to_upper(Words),
        Cipher = "",
        Count = 0,
        I_9 = 0,
        Fun_6 = fun Fun_6_loop(Cipher, Count, I_9, Key_2, Table_3, Up_words, Words) ->
    case (I_9 < length(Up_words)) of
        true ->
            Ch_6 = string:substr(Up_words, I_9 + 1, ((I_9 + 1) - I_9)),
            Cipher_2 = (Cipher ++ get_opponent((case erlang:is_map(Table_3) of true -> maps:get(Count, Table_3, nil); _ -> lists:nth(Count + 1, Table_3) end), Ch_6)),
            Count_2 = ((Count + 1) rem length(Table_3)),
            I_10 = (I_9 + 1),
            Fun_6_loop(Cipher_2, Count_2, I_10, Key_2, Table_3, Up_words, Words);
        _ -> {Cipher, Count, I_9, Key_2, Table_3, Up_words, Words}
    end
end,
{Cipher_2, Count_2, I_10, Key_2, Table_3, Up_words, Words} = Fun_6(Cipher, Count, I_9, Key_2, Table_3, Up_words, Words),
        Cipher_2
    catch {return, Ret} -> Ret end.

decrypt(Key_3, Words_2) ->
    try
        Res_6 = encrypt(Key_3, Words_2),
        Res_6
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", [mochi_repr(encrypt("marvin", "jessica"))]),
        io:format("~ts~n", [mochi_repr(decrypt("marvin", "QRACRWU"))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('UPPER', "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    erlang:put('LOWER', "abcdefghijklmnopqrstuvwxyz"),
    erlang:put('BASE_TOP', "ABCDEFGHIJKLM"),
    erlang:put('BASE_BOTTOM', "NOPQRSTUVWXYZ"),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
