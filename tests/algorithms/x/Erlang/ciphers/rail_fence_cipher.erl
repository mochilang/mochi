#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, encrypt/2, decrypt/2, bruteforce/1]).

% Generated by Mochi transpiler v0.10.59 (98c5e0dd92) on 2025-08-06 22:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

encrypt(Input_string, Key) ->
    try
        case (Key =< 0) of
        true -> erlang:error("Height of grid can't be 0 or negative");
        _ -> ok
    end,
        case ((Key == 1) orelse (length(Input_string) =< Key)) of
        true -> throw({return, Input_string});
        _ -> ok
    end,
        Lowest = (Key - 1),
        Temp_grid = [],
        I = 0,
        Fun = fun Fun_loop(I, Input_string, Key, Lowest, Temp_grid) ->
    case (I < Key) of
        true ->
            Temp_grid_2 = lists:append(Temp_grid, [[]]),
            I_2 = (I + 1),
            Fun_loop(I_2, Input_string, Key, Lowest, Temp_grid_2);
        _ -> {I, Input_string, Key, Lowest, Temp_grid}
    end
end,
{I_2, Input_string, Key, Lowest, Temp_grid_2} = Fun(I, Input_string, Key, Lowest, Temp_grid),
        Position = 0,
        Fun_2 = fun Fun_2_loop(I_2, Input_string, Key, Lowest, Position, Temp_grid_2) ->
    case (Position < length(Input_string)) of
        true ->
            Num = (Position rem (Lowest * 2)),
            Alt = ((Lowest * 2) - Num),
            case (Num > Alt) of
        true -> Num_2 = Alt,
            Num_3 = Num_2;
        _ -> Num_3 = Num
    end,
            Row = (case erlang:is_map(Temp_grid_2) of true -> maps:get(Num_3, Temp_grid_2, nil); _ -> lists:nth(Num_3 + 1, Temp_grid_2) end),
            Row_2 = lists:append(Row, [string:substr(Input_string, Position + 1, ((Position + 1) - Position))]),
            Temp_grid_3 = lists:sublist(Temp_grid_2, Num_3) ++ [Row_2] ++ lists:nthtail(Num_3 + 1, Temp_grid_2),
            Position_2 = (Position + 1),
            Fun_2_loop(I_2, Input_string, Key, Lowest, Position_2, Temp_grid_3);
        _ -> {I_2, Input_string, Key, Lowest, Position, Temp_grid_2}
    end
end,
{I_2, Input_string, Key, Lowest, Position_2, Temp_grid_3} = Fun_2(I_2, Input_string, Key, Lowest, Position, Temp_grid_2),
        Output = "",
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(I_3, Input_string, Key, Lowest, Output, Position_2, Temp_grid_3) ->
    case (I_3 < Key) of
        true ->
            Row_3 = (case erlang:is_map(Temp_grid_3) of true -> maps:get(I_3, Temp_grid_3, nil); _ -> lists:nth(I_3 + 1, Temp_grid_3) end),
            J = 0,
            Fun_3 = fun Fun_3_loop(I_3, Input_string, J, Key, Lowest, Output, Position_2, Row_3, Temp_grid_3) ->
    case (J < length(Row_3)) of
        true ->
            Output_2 = (Output ++ (case erlang:is_map(Row_3) of true -> maps:get(J, Row_3, nil); _ -> lists:nth(J + 1, Row_3) end)),
            J_2 = (J + 1),
            Fun_3_loop(I_3, Input_string, J_2, Key, Lowest, Output_2, Position_2, Row_3, Temp_grid_3);
        _ -> {I_3, Input_string, J, Key, Lowest, Output, Position_2, Row_3, Temp_grid_3}
    end
end,
{I_3, Input_string, J_2, Key, Lowest, Output_2, Position_2, Row_3, Temp_grid_3} = Fun_3(I_3, Input_string, J, Key, Lowest, Output, Position_2, Row_3, Temp_grid_3),
            I_4 = (I_3 + 1),
            Fun_4_loop(I_4, Input_string, Key, Lowest, Output_2, Position_2, Temp_grid_3);
        _ -> {I_3, Input_string, Key, Lowest, Output, Position_2, Temp_grid_3}
    end
end,
{I_4, Input_string, Key, Lowest, Output_2, Position_2, Temp_grid_3} = Fun_4(I_3, Input_string, Key, Lowest, Output, Position_2, Temp_grid_3),
        Output_2
    catch {return, Ret} -> Ret end.

decrypt(Input_string_2, Key_2) ->
    try
        case (Key_2 =< 0) of
        true -> erlang:error("Height of grid can't be 0 or negative");
        _ -> ok
    end,
        case (Key_2 == 1) of
        true -> throw({return, Input_string_2});
        _ -> ok
    end,
        Lowest_2 = (Key_2 - 1),
        Counts = [],
        I_5 = 0,
        Fun_5 = fun Fun_5_loop(Counts, I_5, Input_string_2, Key_2, Lowest_2) ->
    case (I_5 < Key_2) of
        true ->
            Counts_2 = lists:append(Counts, [0]),
            I_6 = (I_5 + 1),
            Fun_5_loop(Counts_2, I_6, Input_string_2, Key_2, Lowest_2);
        _ -> {Counts, I_5, Input_string_2, Key_2, Lowest_2}
    end
end,
{Counts_2, I_6, Input_string_2, Key_2, Lowest_2} = Fun_5(Counts, I_5, Input_string_2, Key_2, Lowest_2),
        Pos = 0,
        Fun_6 = fun Fun_6_loop(Counts_2, I_6, Input_string_2, Key_2, Lowest_2, Pos) ->
    case (Pos < length(Input_string_2)) of
        true ->
            Num_4 = (Pos rem (Lowest_2 * 2)),
            Alt_2 = ((Lowest_2 * 2) - Num_4),
            case (Num_4 > Alt_2) of
        true -> Num_5 = Alt_2,
            Num_6 = Num_5;
        _ -> Num_6 = Num_4
    end,
            Counts_3 = lists:sublist(Counts_2, Num_6) ++ [((case erlang:is_map(Counts_2) of true -> maps:get(Num_6, Counts_2, nil); _ -> lists:nth(Num_6 + 1, Counts_2) end) + 1)] ++ lists:nthtail(Num_6 + 1, Counts_2),
            Pos_2 = (Pos + 1),
            Fun_6_loop(Counts_3, I_6, Input_string_2, Key_2, Lowest_2, Pos_2);
        _ -> {Counts_2, I_6, Input_string_2, Key_2, Lowest_2, Pos}
    end
end,
{Counts_3, I_6, Input_string_2, Key_2, Lowest_2, Pos_2} = Fun_6(Counts_2, I_6, Input_string_2, Key_2, Lowest_2, Pos),
        Grid = [],
        Counter = 0,
        I_7 = 0,
        Fun_8 = fun Fun_8_loop(Counter, Counts_3, Grid, I_7, Input_string_2, Key_2, Lowest_2, Pos_2) ->
    case (I_7 < Key_2) of
        true ->
            Length = (case erlang:is_map(Counts_3) of true -> maps:get(I_7, Counts_3, nil); _ -> lists:nth(I_7 + 1, Counts_3) end),
            Slice = string:substr(Input_string_2, Counter + 1, ((Counter + Length) - Counter)),
            Row_4 = [],
            J_3 = 0,
            Fun_7 = fun Fun_7_loop(Counter, Counts_3, Grid, I_7, Input_string_2, J_3, Key_2, Length, Lowest_2, Pos_2, Row_4, Slice) ->
    case (J_3 < length(Slice)) of
        true ->
            Row_5 = lists:append(Row_4, [string:substr(Slice, J_3 + 1, 1)]),
            J_4 = (J_3 + 1),
            Fun_7_loop(Counter, Counts_3, Grid, I_7, Input_string_2, J_4, Key_2, Length, Lowest_2, Pos_2, Row_5, Slice);
        _ -> {Counter, Counts_3, Grid, I_7, Input_string_2, J_3, Key_2, Length, Lowest_2, Pos_2, Row_4, Slice}
    end
end,
{Counter, Counts_3, Grid, I_7, Input_string_2, J_4, Key_2, Length, Lowest_2, Pos_2, Row_5, Slice} = Fun_7(Counter, Counts_3, Grid, I_7, Input_string_2, J_3, Key_2, Length, Lowest_2, Pos_2, Row_4, Slice),
            Grid_2 = lists:append(Grid, [Row_5]),
            Counter_2 = (Counter + Length),
            I_8 = (I_7 + 1),
            Fun_8_loop(Counter_2, Counts_3, Grid_2, I_8, Input_string_2, Key_2, Lowest_2, Pos_2);
        _ -> {Counter, Counts_3, Grid, I_7, Input_string_2, Key_2, Lowest_2, Pos_2}
    end
end,
{Counter_2, Counts_3, Grid_2, I_8, Input_string_2, Key_2, Lowest_2, Pos_2} = Fun_8(Counter, Counts_3, Grid, I_7, Input_string_2, Key_2, Lowest_2, Pos_2),
        Indices = [],
        I_9 = 0,
        Fun_9 = fun Fun_9_loop(Counter_2, Counts_3, Grid_2, I_9, Indices, Input_string_2, Key_2, Lowest_2, Pos_2) ->
    case (I_9 < Key_2) of
        true ->
            Indices_2 = lists:append(Indices, [0]),
            I_10 = (I_9 + 1),
            Fun_9_loop(Counter_2, Counts_3, Grid_2, I_10, Indices_2, Input_string_2, Key_2, Lowest_2, Pos_2);
        _ -> {Counter_2, Counts_3, Grid_2, I_9, Indices, Input_string_2, Key_2, Lowest_2, Pos_2}
    end
end,
{Counter_2, Counts_3, Grid_2, I_10, Indices_2, Input_string_2, Key_2, Lowest_2, Pos_2} = Fun_9(Counter_2, Counts_3, Grid_2, I_9, Indices, Input_string_2, Key_2, Lowest_2, Pos_2),
        Output_3 = "",
        Pos_3 = 0,
        Fun_10 = fun Fun_10_loop(Counter_2, Counts_3, Grid_2, I_10, Indices_2, Input_string_2, Key_2, Lowest_2, Output_3, Pos_3) ->
    case (Pos_3 < length(Input_string_2)) of
        true ->
            Num_7 = (Pos_3 rem (Lowest_2 * 2)),
            Alt_3 = ((Lowest_2 * 2) - Num_7),
            case (Num_7 > Alt_3) of
        true -> Num_8 = Alt_3,
            Num_9 = Num_8;
        _ -> Num_9 = Num_7
    end,
            Output_4 = (Output_3 ++ (case erlang:is_map((case erlang:is_map(Grid_2) of true -> maps:get(Num_9, Grid_2, nil); _ -> lists:nth(Num_9 + 1, Grid_2) end)) of true -> maps:get((case erlang:is_map(Indices_2) of true -> maps:get(Num_9, Indices_2, nil); _ -> lists:nth(Num_9 + 1, Indices_2) end), (case erlang:is_map(Grid_2) of true -> maps:get(Num_9, Grid_2, nil); _ -> lists:nth(Num_9 + 1, Grid_2) end), nil); _ -> lists:nth((case erlang:is_map(Indices_2) of true -> maps:get(Num_9, Indices_2, nil); _ -> lists:nth(Num_9 + 1, Indices_2) end) + 1, (case erlang:is_map(Grid_2) of true -> maps:get(Num_9, Grid_2, nil); _ -> lists:nth(Num_9 + 1, Grid_2) end)) end)),
            Indices_3 = lists:sublist(Indices_2, Num_9) ++ [((case erlang:is_map(Indices_2) of true -> maps:get(Num_9, Indices_2, nil); _ -> lists:nth(Num_9 + 1, Indices_2) end) + 1)] ++ lists:nthtail(Num_9 + 1, Indices_2),
            Pos_4 = (Pos_3 + 1),
            Fun_10_loop(Counter_2, Counts_3, Grid_2, I_10, Indices_3, Input_string_2, Key_2, Lowest_2, Output_4, Pos_4);
        _ -> {Counter_2, Counts_3, Grid_2, I_10, Indices_2, Input_string_2, Key_2, Lowest_2, Output_3, Pos_3}
    end
end,
{Counter_2, Counts_3, Grid_2, I_10, Indices_3, Input_string_2, Key_2, Lowest_2, Output_4, Pos_4} = Fun_10(Counter_2, Counts_3, Grid_2, I_10, Indices_2, Input_string_2, Key_2, Lowest_2, Output_3, Pos_3),
        Output_4
    catch {return, Ret} -> Ret end.

bruteforce(Input_string_3) ->
    try
        Results = #{},
        Key_guess = 1,
        Fun_11 = fun Fun_11_loop(Input_string_3, Key_guess, Results) ->
    case (Key_guess < length(Input_string_3)) of
        true ->
            Results_2 = maps:put(Key_guess, decrypt(Input_string_3, Key_guess), Results),
            Key_guess_2 = (Key_guess + 1),
            Fun_11_loop(Input_string_3, Key_guess_2, Results_2);
        _ -> {Input_string_3, Key_guess, Results}
    end
end,
{Input_string_3, Key_guess_2, Results_2} = Fun_11(Input_string_3, Key_guess, Results),
        Results_2
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    io:format("~ts~n", [mochi_repr(encrypt("Hello World", 4))]),
    io:format("~ts~n", [mochi_repr(decrypt("HWe olordll", 4))]),
    erlang:put('bf', bruteforce("HWe olordll")),
    io:format("~ts~n", [mochi_repr(maps:get(4, erlang:get('bf'), nil))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
