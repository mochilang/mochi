#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, contains/2, index_of/2, prepare_input/1, generate_table/1, encode/2, decode/2, main/0]).

% Generated by Mochi transpiler v0.10.59 (98c5e0dd92) on 2025-08-06 22:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

contains(Xs, X) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, X, Xs) ->
    case (I < length(Xs)) of
        true ->
            case ((case erlang:is_map(Xs) of true -> maps:get(I, Xs, nil); _ -> lists:nth(I + 1, Xs) end) == X) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, X, Xs);
        _ -> {I, X, Xs}
    end
end,
{I_2, X, Xs} = Fun(I, X, Xs),
        false
    catch {return, Ret} -> Ret end.

index_of(Xs_2, X_2) ->
    try
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, X_2, Xs_2) ->
    case (I_3 < length(Xs_2)) of
        true ->
            case ((case erlang:is_map(Xs_2) of true -> maps:get(I_3, Xs_2, nil); _ -> lists:nth(I_3 + 1, Xs_2) end) == X_2) of
        true -> throw({return, I_3});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, X_2, Xs_2);
        _ -> {I_3, X_2, Xs_2}
    end
end,
{I_4, X_2, Xs_2} = Fun_2(I_3, X_2, Xs_2),
        -1
    catch {return, Ret} -> Ret end.

prepare_input(Dirty) ->
    try
        Letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Upper_dirty = string:to_upper(Dirty),
        Filtered = "",
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Dirty, Filtered, I_5, Letters, Upper_dirty) ->
    case (I_5 < length(Upper_dirty)) of
        true ->
            C = string:substr(Upper_dirty, I_5 + 1, ((I_5 + 1) - I_5)),
            case (string:str(Letters, C) /= 0) of
        true -> Filtered_2 = (Filtered ++ C),
            Filtered_3 = Filtered_2;
        _ -> Filtered_3 = Filtered
    end,
            I_6 = (I_5 + 1),
            Fun_3_loop(Dirty, Filtered_3, I_6, Letters, Upper_dirty);
        _ -> {Dirty, Filtered, I_5, Letters, Upper_dirty}
    end
end,
{Dirty, Filtered_3, I_6, Letters, Upper_dirty} = Fun_3(Dirty, Filtered, I_5, Letters, Upper_dirty),
        case (length(Filtered_3) < 2) of
        true -> throw({return, Filtered_3});
        _ -> ok
    end,
        Clean = "",
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(Clean, Dirty, Filtered_3, I_7, Letters, Upper_dirty) ->
    case (I_7 < (length(Filtered_3) - 1)) of
        true ->
            C1 = string:substr(Filtered_3, I_7 + 1, ((I_7 + 1) - I_7)),
            C2 = string:substr(Filtered_3, (I_7 + 1) + 1, ((I_7 + 2) - (I_7 + 1))),
            Clean_2 = (Clean ++ C1),
            case (C1 == C2) of
        true -> Clean_3 = (Clean_2 ++ "X"),
            Clean_4 = Clean_3;
        _ -> Clean_4 = Clean_2
    end,
            I_8 = (I_7 + 1),
            Fun_4_loop(Clean_4, Dirty, Filtered_3, I_8, Letters, Upper_dirty);
        _ -> {Clean, Dirty, Filtered_3, I_7, Letters, Upper_dirty}
    end
end,
{Clean_4, Dirty, Filtered_3, I_8, Letters, Upper_dirty} = Fun_4(Clean, Dirty, Filtered_3, I_7, Letters, Upper_dirty),
        Clean_5 = (Clean_4 ++ string:substr(Filtered_3, (length(Filtered_3) - 1) + 1, (length(Filtered_3) - (length(Filtered_3) - 1)))),
        case ((length(Clean_5) rem 2) == 1) of
        true -> Clean_6 = (Clean_5 ++ "X"),
            Clean_7 = Clean_6;
        _ -> Clean_7 = Clean_5
    end,
        Clean_7
    catch {return, Ret} -> Ret end.

generate_table(Key) ->
    try
        Alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ",
        Table = [],
        Upper_key = string:to_upper(Key),
        I_9 = 0,
        Fun_5 = fun Fun_5_loop(Alphabet, I_9, Key, Table, Upper_key) ->
    case (I_9 < length(Upper_key)) of
        true ->
            C_2 = string:substr(Upper_key, I_9 + 1, ((I_9 + 1) - I_9)),
            case (string:str(Alphabet, C_2) /= 0) of
        true -> case mochi_not(mochi_member(C_2, Table)) of
        true -> Table_2 = lists:append(Table, [C_2]),
            Table_3 = Table_2;
        _ -> Table_3 = Table
    end,
            Table_4 = Table_3;
        _ -> Table_4 = Table
    end,
            I_10 = (I_9 + 1),
            Fun_5_loop(Alphabet, I_10, Key, Table_4, Upper_key);
        _ -> {Alphabet, I_9, Key, Table, Upper_key}
    end
end,
{Alphabet, I_10, Key, Table_4, Upper_key} = Fun_5(Alphabet, I_9, Key, Table, Upper_key),
        I_11 = 0,
        Fun_6 = fun Fun_6_loop(Alphabet, I_11, Key, Table_4, Upper_key) ->
    case (I_11 < length(Alphabet)) of
        true ->
            C_3 = string:substr(Alphabet, I_11 + 1, ((I_11 + 1) - I_11)),
            case mochi_not(mochi_member(C_3, Table_4)) of
        true -> Table_5 = lists:append(Table_4, [C_3]),
            Table_6 = Table_5;
        _ -> Table_6 = Table_4
    end,
            I_12 = (I_11 + 1),
            Fun_6_loop(Alphabet, I_12, Key, Table_6, Upper_key);
        _ -> {Alphabet, I_11, Key, Table_4, Upper_key}
    end
end,
{Alphabet, I_12, Key, Table_6, Upper_key} = Fun_6(Alphabet, I_11, Key, Table_4, Upper_key),
        Table_6
    catch {return, Ret} -> Ret end.

encode(Plaintext, Key_2) ->
    try
        Table_7 = generate_table(Key_2),
        Text = prepare_input(Plaintext),
        Cipher = "",
        I_13 = 0,
        Fun_7 = fun Fun_7_loop(Cipher, I_13, Key_2, Plaintext, Table_7, Text) ->
    case (I_13 < length(Text)) of
        true ->
            C1_2 = string:substr(Text, I_13 + 1, ((I_13 + 1) - I_13)),
            C2_2 = string:substr(Text, (I_13 + 1) + 1, ((I_13 + 2) - (I_13 + 1))),
            Idx1 = index_of(Table_7, C1_2),
            Idx2 = index_of(Table_7, C2_2),
            Row1 = (Idx1 div 5),
            Col1 = (Idx1 rem 5),
            Row2 = (Idx2 div 5),
            Col2 = (Idx2 rem 5),
            case (Row1 == Row2) of
        true -> Cipher_2 = (Cipher ++ (case erlang:is_map(Table_7) of true -> maps:get(((Row1 * 5) + ((Col1 + 1) rem 5)), Table_7, nil); _ -> lists:nth(((Row1 * 5) + ((Col1 + 1) rem 5)) + 1, Table_7) end)),
            Cipher_3 = (Cipher_2 ++ (case erlang:is_map(Table_7) of true -> maps:get(((Row2 * 5) + ((Col2 + 1) rem 5)), Table_7, nil); _ -> lists:nth(((Row2 * 5) + ((Col2 + 1) rem 5)) + 1, Table_7) end)),
            Cipher_9 = Cipher_3;
        _ -> case (Col1 == Col2) of
        true -> Cipher_4 = (Cipher ++ (case erlang:is_map(Table_7) of true -> maps:get(((((Row1 + 1) rem 5) * 5) + Col1), Table_7, nil); _ -> lists:nth(((((Row1 + 1) rem 5) * 5) + Col1) + 1, Table_7) end)),
            Cipher_5 = (Cipher_4 ++ (case erlang:is_map(Table_7) of true -> maps:get(((((Row2 + 1) rem 5) * 5) + Col2), Table_7, nil); _ -> lists:nth(((((Row2 + 1) rem 5) * 5) + Col2) + 1, Table_7) end)),
            Cipher_8 = Cipher_5;
        _ -> Cipher_6 = (Cipher ++ (case erlang:is_map(Table_7) of true -> maps:get(((Row1 * 5) + Col2), Table_7, nil); _ -> lists:nth(((Row1 * 5) + Col2) + 1, Table_7) end)),
            Cipher_7 = (Cipher_6 ++ (case erlang:is_map(Table_7) of true -> maps:get(((Row2 * 5) + Col1), Table_7, nil); _ -> lists:nth(((Row2 * 5) + Col1) + 1, Table_7) end)),
            Cipher_8 = Cipher_7
    end,
            Cipher_9 = Cipher_8
    end,
            I_14 = (I_13 + 2),
            Fun_7_loop(Cipher_9, I_14, Key_2, Plaintext, Table_7, Text);
        _ -> {Cipher, I_13, Key_2, Plaintext, Table_7, Text}
    end
end,
{Cipher_9, I_14, Key_2, Plaintext, Table_7, Text} = Fun_7(Cipher, I_13, Key_2, Plaintext, Table_7, Text),
        Cipher_9
    catch {return, Ret} -> Ret end.

decode(Cipher_10, Key_3) ->
    try
        Table_8 = generate_table(Key_3),
        Plain = "",
        I_15 = 0,
        Fun_8 = fun Fun_8_loop(Cipher_10, I_15, Key_3, Plain, Table_8) ->
    case (I_15 < length(Cipher_10)) of
        true ->
            C1_3 = string:substr(Cipher_10, I_15 + 1, ((I_15 + 1) - I_15)),
            C2_3 = string:substr(Cipher_10, (I_15 + 1) + 1, ((I_15 + 2) - (I_15 + 1))),
            Idx1_2 = index_of(Table_8, C1_3),
            Idx2_2 = index_of(Table_8, C2_3),
            Row1_2 = (Idx1_2 div 5),
            Col1_2 = (Idx1_2 rem 5),
            Row2_2 = (Idx2_2 div 5),
            Col2_2 = (Idx2_2 rem 5),
            case (Row1_2 == Row2_2) of
        true -> Plain_2 = (Plain ++ (case erlang:is_map(Table_8) of true -> maps:get(((Row1_2 * 5) + ((Col1_2 + 4) rem 5)), Table_8, nil); _ -> lists:nth(((Row1_2 * 5) + ((Col1_2 + 4) rem 5)) + 1, Table_8) end)),
            Plain_3 = (Plain_2 ++ (case erlang:is_map(Table_8) of true -> maps:get(((Row2_2 * 5) + ((Col2_2 + 4) rem 5)), Table_8, nil); _ -> lists:nth(((Row2_2 * 5) + ((Col2_2 + 4) rem 5)) + 1, Table_8) end)),
            Plain_9 = Plain_3;
        _ -> case (Col1_2 == Col2_2) of
        true -> Plain_4 = (Plain ++ (case erlang:is_map(Table_8) of true -> maps:get(((((Row1_2 + 4) rem 5) * 5) + Col1_2), Table_8, nil); _ -> lists:nth(((((Row1_2 + 4) rem 5) * 5) + Col1_2) + 1, Table_8) end)),
            Plain_5 = (Plain_4 ++ (case erlang:is_map(Table_8) of true -> maps:get(((((Row2_2 + 4) rem 5) * 5) + Col2_2), Table_8, nil); _ -> lists:nth(((((Row2_2 + 4) rem 5) * 5) + Col2_2) + 1, Table_8) end)),
            Plain_8 = Plain_5;
        _ -> Plain_6 = (Plain ++ (case erlang:is_map(Table_8) of true -> maps:get(((Row1_2 * 5) + Col2_2), Table_8, nil); _ -> lists:nth(((Row1_2 * 5) + Col2_2) + 1, Table_8) end)),
            Plain_7 = (Plain_6 ++ (case erlang:is_map(Table_8) of true -> maps:get(((Row2_2 * 5) + Col1_2), Table_8, nil); _ -> lists:nth(((Row2_2 * 5) + Col1_2) + 1, Table_8) end)),
            Plain_8 = Plain_7
    end,
            Plain_9 = Plain_8
    end,
            I_16 = (I_15 + 2),
            Fun_8_loop(Cipher_10, I_16, Key_3, Plain_9, Table_8);
        _ -> {Cipher_10, I_15, Key_3, Plain, Table_8}
    end
end,
{Cipher_10, I_16, Key_3, Plain_9, Table_8} = Fun_8(Cipher_10, I_15, Key_3, Plain, Table_8),
        Plain_9
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts ~ts~n", [mochi_repr("Encoded:"), mochi_repr(encode("BYE AND THANKS", "GREETING"))]),
        io:format("~ts ~ts~n", [mochi_repr("Decoded:"), mochi_repr(decode("CXRBANRLBALQ", "GREETING"))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
