#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, rand/1, get_random_key/0, check_valid_key/1, index_in/2, char_to_upper/1, char_to_lower/1, is_upper/1, translate_message/3, encrypt_message/2, decrypt_message/2]).

% Generated by Mochi transpiler v0.10.59 (98c5e0dd92) on 2025-08-06 22:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

rand(N) ->
    try
        erlang:put('seed', (((erlang:get('seed') * 1664525) + 1013904223) rem 2147483647)),
        (erlang:get('seed') rem N)
    catch {return, Ret} -> Ret end.

get_random_key() ->
    try
        Chars = nil,
        I = 0,
        Fun = fun Fun_loop(Chars, I) ->
    case (I < length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) of
        true ->
            Chars_2 = lists:append(Chars, [string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", I + 1, 1)]),
            I_2 = (I + 1),
            Fun_loop(Chars_2, I_2);
        _ -> {Chars, I}
    end
end,
{Chars_2, I_2} = Fun(Chars, I),
        J = (length(Chars_2) - 1),
        Fun_2 = fun Fun_2_loop(Chars_2, I_2, J) ->
    case (J > 0) of
        true ->
            K = rand((J + 1)),
            Tmp = (case erlang:is_map(Chars_2) of true -> maps:get(J, Chars_2, nil); _ -> lists:nth(J + 1, Chars_2) end),
            Chars_3 = lists:sublist(Chars_2, J) ++ [(case erlang:is_map(Chars_2) of true -> maps:get(K, Chars_2, nil); _ -> lists:nth(K + 1, Chars_2) end)] ++ lists:nthtail(J + 1, Chars_2),
            Chars_4 = lists:sublist(Chars_3, K) ++ [Tmp] ++ lists:nthtail(K + 1, Chars_3),
            J_2 = (J - 1),
            Fun_2_loop(Chars_4, I_2, J_2);
        _ -> {Chars_2, I_2, J}
    end
end,
{Chars_4, I_2, J_2} = Fun_2(Chars_2, I_2, J),
        Res = "",
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Chars_4, I_3, J_2, Res) ->
    case (I_3 < length(Chars_4)) of
        true ->
            Res_2 = (Res ++ (case erlang:is_map(Chars_4) of true -> maps:get(I_3, Chars_4, nil); _ -> lists:nth(I_3 + 1, Chars_4) end)),
            I_4 = (I_3 + 1),
            Fun_3_loop(Chars_4, I_4, J_2, Res_2);
        _ -> {Chars_4, I_3, J_2, Res}
    end
end,
{Chars_4, I_4, J_2, Res_2} = Fun_3(Chars_4, I_3, J_2, Res),
        Res_2
    catch {return, Ret} -> Ret end.

check_valid_key(Key) ->
    try
        case (length(Key) /= length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) of
        true -> throw({return, false});
        _ -> ok
    end,
        Used = #{},
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(I_5, Key, Used) ->
    case (I_5 < length(Key)) of
        true ->
            Ch = string:substr(Key, I_5 + 1, 1),
            case maps:get(Ch, Used, nil) of
        true -> throw({return, false});
        _ -> ok
    end,
            Used_2 = maps:put(Ch, true, Used),
            I_6 = (I_5 + 1),
            Fun_4_loop(I_6, Key, Used_2);
        _ -> {I_5, Key, Used}
    end
end,
{I_6, Key, Used_2} = Fun_4(I_5, Key, Used),
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(I_7, Key, Used_2) ->
    case (I_7 < length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) of
        true ->
            Ch_2 = string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", I_7 + 1, 1),
            case mochi_not(maps:get(Ch_2, Used_2, nil)) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_8 = (I_7 + 1),
            Fun_5_loop(I_8, Key, Used_2);
        _ -> {I_7, Key, Used_2}
    end
end,
{I_8, Key, Used_2} = Fun_5(I_7, Key, Used_2),
        true
    catch {return, Ret} -> Ret end.

index_in(S, Ch_3) ->
    try
        I_9 = 0,
        Fun_6 = fun Fun_6_loop(Ch_3, I_9, S) ->
    case (I_9 < length(S)) of
        true ->
            case (string:substr(S, I_9 + 1, 1) == Ch_3) of
        true -> throw({return, I_9});
        _ -> ok
    end,
            I_10 = (I_9 + 1),
            Fun_6_loop(Ch_3, I_10, S);
        _ -> {Ch_3, I_9, S}
    end
end,
{Ch_3, I_10, S} = Fun_6(Ch_3, I_9, S),
        -1
    catch {return, Ret} -> Ret end.

char_to_upper(C) ->
    try
        I_11 = 0,
        Fun_7 = fun Fun_7_loop(C, I_11) ->
    case (I_11 < length("abcdefghijklmnopqrstuvwxyz")) of
        true ->
            case (C == string:substr("abcdefghijklmnopqrstuvwxyz", I_11 + 1, 1)) of
        true -> throw({return, string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", I_11 + 1, 1)});
        _ -> ok
    end,
            I_12 = (I_11 + 1),
            Fun_7_loop(C, I_12);
        _ -> {C, I_11}
    end
end,
{C, I_12} = Fun_7(C, I_11),
        C
    catch {return, Ret} -> Ret end.

char_to_lower(C_2) ->
    try
        I_13 = 0,
        Fun_8 = fun Fun_8_loop(C_2, I_13) ->
    case (I_13 < length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) of
        true ->
            case (C_2 == string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", I_13 + 1, 1)) of
        true -> throw({return, string:substr("abcdefghijklmnopqrstuvwxyz", I_13 + 1, 1)});
        _ -> ok
    end,
            I_14 = (I_13 + 1),
            Fun_8_loop(C_2, I_14);
        _ -> {C_2, I_13}
    end
end,
{C_2, I_14} = Fun_8(C_2, I_13),
        C_2
    catch {return, Ret} -> Ret end.

is_upper(C_3) ->
    try
        I_15 = 0,
        Fun_9 = fun Fun_9_loop(C_3, I_15) ->
    case (I_15 < length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) of
        true ->
            case (C_3 == string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", I_15 + 1, 1)) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_16 = (I_15 + 1),
            Fun_9_loop(C_3, I_16);
        _ -> {C_3, I_15}
    end
end,
{C_3, I_16} = Fun_9(C_3, I_15),
        false
    catch {return, Ret} -> Ret end.

translate_message(Key_2, Message, Mode) ->
    try
        Chars_a = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Chars_b = Key_2,
        case (Mode == "decrypt") of
        true -> Tmp_2 = Chars_a,
            Chars_a_2 = Chars_b,
            Chars_b_2 = Tmp_2,
            Chars_a_3 = Chars_a_2,
            Chars_b_3 = Chars_b_2,
            Tmp_3 = Tmp_2;
        _ -> Chars_a_3 = Chars_a,
            Chars_b_3 = Chars_b,
            Tmp_3 = nil
    end,
        Translated = "",
        I_17 = 0,
        Fun_10 = fun Fun_10_loop(Chars_a_3, Chars_b_3, I_17, Key_2, Message, Mode, Tmp_3, Translated) ->
    case (I_17 < length(Message)) of
        true ->
            Symbol = string:substr(Message, I_17 + 1, 1),
            Upper_symbol = char_to_upper(Symbol),
            Idx = index_in(Chars_a_3, Upper_symbol),
            case (Idx >= 0) of
        true -> Mapped = string:substr(Chars_b_3, Idx + 1, 1),
            case is_upper(Symbol) of
        true -> Translated_2 = (Translated ++ Mapped),
            Translated_4 = Translated_2;
        _ -> Translated_3 = (Translated ++ char_to_lower(Mapped)),
            Translated_4 = Translated_3
    end,
            Mapped_2 = Mapped,
            Translated_6 = Translated_4;
        _ -> Translated_5 = (Translated ++ Symbol),
            Mapped_2 = nil,
            Translated_6 = Translated_5
    end,
            I_18 = (I_17 + 1),
            Fun_10_loop(Chars_a_3, Chars_b_3, I_18, Key_2, Message, Mode, Tmp_3, Translated_6);
        _ -> {Chars_a_3, Chars_b_3, I_17, Key_2, Message, Mode, Tmp_3, Translated}
    end
end,
{Chars_a_3, Chars_b_3, I_18, Key_2, Message, Mode, Tmp_3, Translated_6} = Fun_10(Chars_a_3, Chars_b_3, I_17, Key_2, Message, Mode, Tmp_3, Translated),
        Translated_6
    catch {return, Ret} -> Ret end.

encrypt_message(Key_3, Message_2) ->
    try
        Res_3 = translate_message(Key_3, Message_2, "encrypt"),
        Res_3
    catch {return, Ret} -> Ret end.

decrypt_message(Key_4, Message_3) ->
    try
        Res_4 = translate_message(Key_4, Message_3, "decrypt"),
        Res_4
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('LETTERS', "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    erlang:put('LOWERCASE', "abcdefghijklmnopqrstuvwxyz"),
    erlang:put('seed', 1),
    erlang:put('key', "LFWOAYUISVKMNXPBDCRJTQEGHZ"),
    io:format("~ts~n", [mochi_repr(encrypt_message("LFWOAYUISVKMNXPBDCRJTQEGHZ", "Harshil Darji"))]),
    io:format("~ts~n", [mochi_repr(decrypt_message("LFWOAYUISVKMNXPBDCRJTQEGHZ", "Ilcrism Olcvs"))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
