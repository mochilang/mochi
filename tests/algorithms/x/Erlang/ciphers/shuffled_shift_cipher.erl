#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, ord/1, neg_pos/1, passcode_creator/0, unique_sorted/1, make_key_list/1, make_shift_key/1, new_cipher/1, index_of/2, encrypt/2, decrypt/2, test_end_to_end/0]).

% Generated by Mochi transpiler v0.10.63 (26477f70ed) on 2025-08-09 23:14 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


-compile({nowarn_unused_function, mochi_nth/2}).
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

ord(Ch) ->
    try
        Digits = "0123456789",
        I = 0,
        Fun = fun Fun_loop(Ch, Digits, I) ->
    case (I < erlang:length(Digits)) of
        true ->
            case (string:substr(Digits, I + 1, ((I + 1) - I)) == Ch) of
        true -> throw({return, (48 + I)});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, Digits, I_2);
        _ -> {Ch, Digits, I}
    end
end,
{Ch, Digits, I_2} = Fun(Ch, Digits, I),
        Upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Ch, Digits, I_3, Upper) ->
    case (I_3 < erlang:length(Upper)) of
        true ->
            case (string:substr(Upper, I_3 + 1, ((I_3 + 1) - I_3)) == Ch) of
        true -> throw({return, (65 + I_3)});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Ch, Digits, I_4, Upper);
        _ -> {Ch, Digits, I_3, Upper}
    end
end,
{Ch, Digits, I_4, Upper} = Fun_2(Ch, Digits, I_3, Upper),
        Lower = "abcdefghijklmnopqrstuvwxyz",
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Ch, Digits, I_5, Lower, Upper) ->
    case (I_5 < erlang:length(Lower)) of
        true ->
            case (string:substr(Lower, I_5 + 1, ((I_5 + 1) - I_5)) == Ch) of
        true -> throw({return, (97 + I_5)});
        _ -> ok
    end,
            I_6 = (I_5 + 1),
            Fun_3_loop(Ch, Digits, I_6, Lower, Upper);
        _ -> {Ch, Digits, I_5, Lower, Upper}
    end
end,
{Ch, Digits, I_6, Lower, Upper} = Fun_3(Ch, Digits, I_5, Lower, Upper),
        0
    catch {return, RetCatch} -> RetCatch end.

neg_pos(Iterlist) ->
    try
        I_7 = 1,
        Fun_4 = fun Fun_4_loop(I_7, Iterlist) ->
    case (I_7 < erlang:length(Iterlist)) of
        true ->
            Iterlist_2 = lists:sublist(Iterlist, I_7) ++ [-(case erlang:is_map(Iterlist) of true -> maps:get(I_7, Iterlist, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Iterlist) + I_7 + 1, Iterlist); _ -> mochi_nth(I_7 + 1, Iterlist) end end)] ++ lists:nthtail(I_7 + 1, Iterlist),
            I_8 = (I_7 + 2),
            Fun_4_loop(I_8, Iterlist_2);
        _ -> {I_7, Iterlist}
    end
end,
{I_8, Iterlist_2} = Fun_4(I_7, Iterlist),
        Iterlist_2
    catch {return, RetCatch} -> RetCatch end.

passcode_creator() ->
    try
        Choices = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
        Seed = mochi_now(),
        Length = (10 + mochi_mod(Seed, 11)),
        Password = [],
        I_9 = 0,
        Fun_5 = fun Fun_5_loop(Choices, I_9, Length, Password, Seed) ->
    case (I_9 < Length) of
        true ->
            Seed_2 = mochi_mod(((Seed * 1103515245) + 12345), 2147483647),
            Idx = mochi_mod(Seed_2, erlang:length(Choices)),
            Password_2 = lists:append((case Password of nil -> []; _ -> Password end), [string:substr(Choices, Idx + 1, ((Idx + 1) - Idx))]),
            I_10 = (I_9 + 1),
            Fun_5_loop(Choices, I_10, Length, Password_2, Seed_2);
        _ -> {Choices, I_9, Length, Password, Seed}
    end
end,
{Choices, I_10, Length, Password_2, Seed_2} = Fun_5(Choices, I_9, Length, Password, Seed),
        Password_2
    catch {return, RetCatch} -> RetCatch end.

unique_sorted(Chars) ->
    try
        Uniq = [],
        I_11 = 0,
        Fun_6 = fun Fun_6_loop(Chars, I_11, Uniq) ->
    case (I_11 < erlang:length(Chars)) of
        true ->
            Ch_2 = (case erlang:is_map(Chars) of true -> maps:get(I_11, Chars, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Chars) + I_11 + 1, Chars); _ -> mochi_nth(I_11 + 1, Chars) end end),
            case mochi_not(mochi_member(Ch_2, Uniq)) of
        true -> Uniq_2 = lists:append((case Uniq of nil -> []; _ -> Uniq end), [Ch_2]),
            Uniq_3 = Uniq_2;
        _ -> Uniq_3 = Uniq
    end,
            I_12 = (I_11 + 1),
            Fun_6_loop(Chars, I_12, Uniq_3);
        _ -> {Chars, I_11, Uniq}
    end
end,
{Chars, I_12, Uniq_3} = Fun_6(Chars, I_11, Uniq),
        J = 0,
        Fun_8 = fun Fun_8_loop(Chars, I_12, J, Uniq_3) ->
    case (J < erlang:length(Uniq_3)) of
        true ->
            K = (J + 1),
            Min_idx = J,
            Fun_7 = fun Fun_7_loop(Chars, I_12, J, K, Min_idx, Uniq_3) ->
    case (K < erlang:length(Uniq_3)) of
        true ->
            case ((case erlang:is_map(Uniq_3) of true -> maps:get(K, Uniq_3, nil); _ -> case K < 0 of true -> mochi_nth(erlang:length(Uniq_3) + K + 1, Uniq_3); _ -> mochi_nth(K + 1, Uniq_3) end end) < (case erlang:is_map(Uniq_3) of true -> maps:get(Min_idx, Uniq_3, nil); _ -> case Min_idx < 0 of true -> mochi_nth(erlang:length(Uniq_3) + Min_idx + 1, Uniq_3); _ -> mochi_nth(Min_idx + 1, Uniq_3) end end)) of
        true -> Min_idx_2 = K,
            Min_idx_3 = Min_idx_2;
        _ -> Min_idx_3 = Min_idx
    end,
            K_2 = (K + 1),
            Fun_7_loop(Chars, I_12, J, K_2, Min_idx_3, Uniq_3);
        _ -> {Chars, I_12, J, K, Min_idx, Uniq_3}
    end
end,
{Chars, I_12, J, K_2, Min_idx_3, Uniq_3} = Fun_7(Chars, I_12, J, K, Min_idx, Uniq_3),
            case (Min_idx_3 /= J) of
        true -> Tmp = (case erlang:is_map(Uniq_3) of true -> maps:get(J, Uniq_3, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Uniq_3) + J + 1, Uniq_3); _ -> mochi_nth(J + 1, Uniq_3) end end),
            Uniq_4 = lists:sublist(Uniq_3, J) ++ [(case erlang:is_map(Uniq_3) of true -> maps:get(Min_idx_3, Uniq_3, nil); _ -> case Min_idx_3 < 0 of true -> mochi_nth(erlang:length(Uniq_3) + Min_idx_3 + 1, Uniq_3); _ -> mochi_nth(Min_idx_3 + 1, Uniq_3) end end)] ++ lists:nthtail(J + 1, Uniq_3),
            Uniq_5 = lists:sublist(Uniq_4, Min_idx_3) ++ [Tmp] ++ lists:nthtail(Min_idx_3 + 1, Uniq_4),
            Tmp_2 = Tmp,
            Uniq_6 = Uniq_5;
        _ -> Tmp_2 = nil,
            Uniq_6 = Uniq_3
    end,
            J_2 = (J + 1),
            Fun_8_loop(Chars, I_12, J_2, Uniq_6);
        _ -> {Chars, I_12, J, Uniq_3}
    end
end,
{Chars, I_12, J_2, Uniq_6} = Fun_8(Chars, I_12, J, Uniq_3),
        Uniq_6
    catch {return, RetCatch} -> RetCatch end.

make_key_list(Passcode) ->
    try
        Key_list_options = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n",
        Breakpoints = unique_sorted(Passcode),
        Keys_l = [],
        Temp_list = [],
        I_13 = 0,
        Fun_11 = fun Fun_11_loop(Breakpoints, I_13, Key_list_options, Keys_l, Passcode, Temp_list) ->
    case (I_13 < erlang:length(Key_list_options)) of
        true ->
            Ch_3 = string:substr(Key_list_options, I_13 + 1, ((I_13 + 1) - I_13)),
            Temp_list_2 = lists:append((case Temp_list of nil -> []; _ -> Temp_list end), [Ch_3]),
            case (mochi_member(Ch_3, Breakpoints) orelse (I_13 == (erlang:length(Key_list_options) - 1))) of
        true -> K_3 = (erlang:length(Temp_list_2) - 1),
            Fun_9 = fun Fun_9_loop(Breakpoints, Ch_3, I_13, K_3, Key_list_options, Keys_l, Passcode, Temp_list_2) ->
    case (K_3 >= 0) of
        true ->
            Keys_l_2 = lists:append((case Keys_l of nil -> []; _ -> Keys_l end), [(case erlang:is_map(Temp_list_2) of true -> maps:get(K_3, Temp_list_2, nil); _ -> case K_3 < 0 of true -> mochi_nth(erlang:length(Temp_list_2) + K_3 + 1, Temp_list_2); _ -> mochi_nth(K_3 + 1, Temp_list_2) end end)]),
            K_4 = (K_3 - 1),
            Fun_9_loop(Breakpoints, Ch_3, I_13, K_4, Key_list_options, Keys_l_2, Passcode, Temp_list_2);
        _ -> {Breakpoints, Ch_3, I_13, K_3, Key_list_options, Keys_l, Passcode, Temp_list_2}
    end
end,
{Breakpoints, Ch_3, I_13, K_4, Key_list_options, Keys_l_2, Passcode, Temp_list_2} = Fun_9(Breakpoints, Ch_3, I_13, K_3, Key_list_options, Keys_l, Passcode, Temp_list_2),
            Temp_list_3 = [],
            Fun_10 = Fun_9,
            K_5 = K_4,
            Keys_l_3 = Keys_l_2,
            Temp_list_4 = Temp_list_3;
        _ -> Fun_10 = nil,
            K_5 = nil,
            Keys_l_3 = Keys_l,
            Temp_list_4 = Temp_list_2
    end,
            I_14 = (I_13 + 1),
            Fun_11_loop(Breakpoints, I_14, Key_list_options, Keys_l_3, Passcode, Temp_list_4);
        _ -> {Breakpoints, I_13, Key_list_options, Keys_l, Passcode, Temp_list}
    end
end,
{Breakpoints, I_14, Key_list_options, Keys_l_3, Passcode, Temp_list_4} = Fun_11(Breakpoints, I_13, Key_list_options, Keys_l, Passcode, Temp_list),
        Keys_l_3
    catch {return, RetCatch} -> RetCatch end.

make_shift_key(Passcode_2) ->
    try
        Codes = [],
        I_15 = 0,
        Fun_12 = fun Fun_12_loop(Codes, I_15, Passcode_2) ->
    case (I_15 < erlang:length(Passcode_2)) of
        true ->
            Codes_2 = lists:append((case Codes of nil -> []; _ -> Codes end), [ord((case erlang:is_map(Passcode_2) of true -> maps:get(I_15, Passcode_2, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(Passcode_2) + I_15 + 1, Passcode_2); _ -> mochi_nth(I_15 + 1, Passcode_2) end end))]),
            I_16 = (I_15 + 1),
            Fun_12_loop(Codes_2, I_16, Passcode_2);
        _ -> {Codes, I_15, Passcode_2}
    end
end,
{Codes_2, I_16, Passcode_2} = Fun_12(Codes, I_15, Passcode_2),
        Codes_3 = neg_pos(Codes_2),
        Total = 0,
        I_17 = 0,
        Fun_13 = fun Fun_13_loop(Codes_3, I_17, Passcode_2, Total) ->
    case (I_17 < erlang:length(Codes_3)) of
        true ->
            Total_2 = (Total + (case erlang:is_map(Codes_3) of true -> maps:get(I_17, Codes_3, nil); _ -> case I_17 < 0 of true -> mochi_nth(erlang:length(Codes_3) + I_17 + 1, Codes_3); _ -> mochi_nth(I_17 + 1, Codes_3) end end)),
            I_18 = (I_17 + 1),
            Fun_13_loop(Codes_3, I_18, Passcode_2, Total_2);
        _ -> {Codes_3, I_17, Passcode_2, Total}
    end
end,
{Codes_3, I_18, Passcode_2, Total_2} = Fun_13(Codes_3, I_17, Passcode_2, Total),
        case (Total_2 > 0) of
        true -> throw({return, Total_2});
        _ -> ok
    end,
        erlang:length(Passcode_2)
    catch {return, RetCatch} -> RetCatch end.

new_cipher(Passcode_str) ->
    try
        Passcode_3 = [],
        case (erlang:length(Passcode_str) == 0) of
        true -> Passcode_4 = passcode_creator(),
            Fun_15 = nil,
            I_21 = nil,
            Passcode_6 = Passcode_4;
        _ -> I_19 = 0,
            Fun_14 = fun Fun_14_loop(I_19, Passcode_3, Passcode_str) ->
    case (I_19 < erlang:length(Passcode_str)) of
        true ->
            Passcode_5 = lists:append((case Passcode_3 of nil -> []; _ -> Passcode_3 end), [string:substr(Passcode_str, I_19 + 1, ((I_19 + 1) - I_19))]),
            I_20 = (I_19 + 1),
            Fun_14_loop(I_20, Passcode_5, Passcode_str);
        _ -> {I_19, Passcode_3, Passcode_str}
    end
end,
{I_20, Passcode_5, Passcode_str} = Fun_14(I_19, Passcode_3, Passcode_str),
            Fun_15 = Fun_14,
            I_21 = I_20,
            Passcode_6 = Passcode_5
    end,
        Key_list = make_key_list(Passcode_6),
        Shift_key = make_shift_key(Passcode_6),
        #{"passcode" => Passcode_6, "key_list" => Key_list, "shift_key" => Shift_key}
    catch {return, RetCatch} -> RetCatch end.

index_of(Lst, Ch_4) ->
    try
        I_22 = 0,
        Fun_16 = fun Fun_16_loop(Ch_4, I_22, Lst) ->
    case (I_22 < erlang:length(Lst)) of
        true ->
            case ((case erlang:is_map(Lst) of true -> maps:get(I_22, Lst, nil); _ -> case I_22 < 0 of true -> mochi_nth(erlang:length(Lst) + I_22 + 1, Lst); _ -> mochi_nth(I_22 + 1, Lst) end end) == Ch_4) of
        true -> throw({return, I_22});
        _ -> ok
    end,
            I_23 = (I_22 + 1),
            Fun_16_loop(Ch_4, I_23, Lst);
        _ -> {Ch_4, I_22, Lst}
    end
end,
{Ch_4, I_23, Lst} = Fun_16(Ch_4, I_22, Lst),
        -1
    catch {return, RetCatch} -> RetCatch end.

encrypt(C, Plaintext) ->
    try
        Encoded = "",
        I_24 = 0,
        N = erlang:length(maps:get("key_list", C, nil)),
        Fun_17 = fun Fun_17_loop(C, Encoded, I_24, N, Plaintext) ->
    case (I_24 < erlang:length(Plaintext)) of
        true ->
            Ch_5 = string:substr(Plaintext, I_24 + 1, ((I_24 + 1) - I_24)),
            Position = index_of(maps:get("key_list", C, nil), Ch_5),
            New_pos = mochi_mod((Position + maps:get("shift_key", C, nil)), N),
            Encoded_2 = (Encoded ++ (case erlang:is_map(maps:get("key_list", C, nil)) of true -> maps:get(New_pos, maps:get("key_list", C, nil), nil); _ -> case New_pos < 0 of true -> mochi_nth(erlang:length(maps:get("key_list", C, nil)) + New_pos + 1, maps:get("key_list", C, nil)); _ -> mochi_nth(New_pos + 1, maps:get("key_list", C, nil)) end end)),
            I_25 = (I_24 + 1),
            Fun_17_loop(C, Encoded_2, I_25, N, Plaintext);
        _ -> {C, Encoded, I_24, N, Plaintext}
    end
end,
{C, Encoded_2, I_25, N, Plaintext} = Fun_17(C, Encoded, I_24, N, Plaintext),
        Encoded_2
    catch {return, RetCatch} -> RetCatch end.

decrypt(C_2, Encoded_message) ->
    try
        Decoded = "",
        I_26 = 0,
        N_2 = erlang:length(maps:get("key_list", C_2, nil)),
        Fun_18 = fun Fun_18_loop(C_2, Decoded, Encoded_message, I_26, N_2) ->
    case (I_26 < erlang:length(Encoded_message)) of
        true ->
            Ch_6 = string:substr(Encoded_message, I_26 + 1, ((I_26 + 1) - I_26)),
            Position_2 = index_of(maps:get("key_list", C_2, nil), Ch_6),
            New_pos_2 = mochi_mod((Position_2 - maps:get("shift_key", C_2, nil)), N_2),
            case (New_pos_2 < 0) of
        true -> New_pos_3 = (New_pos_2 + N_2),
            New_pos_4 = New_pos_3;
        _ -> New_pos_4 = New_pos_2
    end,
            Decoded_2 = (Decoded ++ (case erlang:is_map(maps:get("key_list", C_2, nil)) of true -> maps:get(New_pos_4, maps:get("key_list", C_2, nil), nil); _ -> case New_pos_4 < 0 of true -> mochi_nth(erlang:length(maps:get("key_list", C_2, nil)) + New_pos_4 + 1, maps:get("key_list", C_2, nil)); _ -> mochi_nth(New_pos_4 + 1, maps:get("key_list", C_2, nil)) end end)),
            I_27 = (I_26 + 1),
            Fun_18_loop(C_2, Decoded_2, Encoded_message, I_27, N_2);
        _ -> {C_2, Decoded, Encoded_message, I_26, N_2}
    end
end,
{C_2, Decoded_2, Encoded_message, I_27, N_2} = Fun_18(C_2, Decoded, Encoded_message, I_26, N_2),
        Decoded_2
    catch {return, RetCatch} -> RetCatch end.

test_end_to_end() ->
    try
        Msg = "Hello, this is a modified Caesar cipher",
        Cip = new_cipher(""),
        decrypt(Cip, encrypt(Cip, "Hello, this is a modified Caesar cipher"))
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('ssc', new_cipher("4PYIXyqeQZr44")),
    erlang:put('encoded', encrypt(erlang:get('ssc'), "Hello, this is a modified Caesar cipher")),
    io:format("~ts~n", [mochi_repr(erlang:get('encoded'))]),
    io:format("~ts~n", [mochi_repr(decrypt(erlang:get('ssc'), erlang:get('encoded')))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
