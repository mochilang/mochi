#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, to_upper/1, contains/2, contains_char/2, get_value/3, print_mapping/2, mixed_keyword/3]).

% Generated by Mochi transpiler v0.10.59 (2399182da0) on 2025-08-06 22:20 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

to_upper(S) ->
    try
        Res = "",
        I = 0,
        Fun_2 = fun Fun_2_loop(I, Res, S) ->
    case (I < length(S)) of
        true ->
            try
                Ch = string:substr(S, I + 1, 1),
                J = 0,
                Found = false,
                Fun = fun Fun_loop(Ch, Found, I, J, Res, S) ->
    case (J < 26) of
        true ->
            try
                case (Ch == string:substr("abcdefghijklmnopqrstuvwxyz", J + 1, 1)) of
        true -> Res_2 = (Res ++ string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", J + 1, 1)),
            Found_2 = true,
            throw({break, Ch, Found_2, I, J, Res_2, S}),
            Found_3 = Found_2,
            Res_3 = Res_2;
        _ -> Found_3 = Found,
            Res_3 = Res
    end,
                J_2 = (J + 1),
                Fun_loop(Ch, Found_3, I, J_2, Res_3, S)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_loop(C0, C1, C2, C3, C4, C5);
                {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5}
            end;
        _ -> {Ch, Found, I, J, Res, S}
    end
end,
{Ch, Found_3, I, J_2, Res_3, S} = Fun(Ch, Found, I, J, Res, S),
                case (Found_3 == false) of
        true -> Res_4 = (Res_3 ++ Ch),
            Res_5 = Res_4;
        _ -> Res_5 = Res_3
    end,
                I_2 = (I + 1),
                Fun_2_loop(I_2, Res_5, S)
            catch
                {continue, C0, C1, C2} -> Fun_2_loop(C0, C1, C2);
                {break, B0, B1, B2} -> {B0, B1, B2}
            end;
        _ -> {I, Res, S}
    end
end,
{I_2, Res_5, S} = Fun_2(I, Res, S),
        Res_5
    catch {return, Ret} -> Ret end.

contains(Xs, X) ->
    try
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(I_3, X, Xs) ->
    case (I_3 < length(Xs)) of
        true ->
            case ((case erlang:is_map(Xs) of true -> maps:get(I_3, Xs, nil); _ -> lists:nth(I_3 + 1, Xs) end) == X) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_3_loop(I_4, X, Xs);
        _ -> {I_3, X, Xs}
    end
end,
{I_4, X, Xs} = Fun_3(I_3, X, Xs),
        false
    catch {return, Ret} -> Ret end.

contains_char(S_2, Ch_2) ->
    try
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(Ch_2, I_5, S_2) ->
    case (I_5 < length(S_2)) of
        true ->
            case (string:substr(S_2, I_5 + 1, 1) == Ch_2) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_6 = (I_5 + 1),
            Fun_4_loop(Ch_2, I_6, S_2);
        _ -> {Ch_2, I_5, S_2}
    end
end,
{Ch_2, I_6, S_2} = Fun_4(Ch_2, I_5, S_2),
        false
    catch {return, Ret} -> Ret end.

get_value(Keys, Values, Key) ->
    try
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(I_7, Key, Keys, Values) ->
    case (I_7 < length(Keys)) of
        true ->
            case ((case erlang:is_map(Keys) of true -> maps:get(I_7, Keys, nil); _ -> lists:nth(I_7 + 1, Keys) end) == Key) of
        true -> throw({return, (case erlang:is_map(Values) of true -> maps:get(I_7, Values, nil); _ -> lists:nth(I_7 + 1, Values) end)});
        _ -> ok
    end,
            I_8 = (I_7 + 1),
            Fun_5_loop(I_8, Key, Keys, Values);
        _ -> {I_7, Key, Keys, Values}
    end
end,
{I_8, Key, Keys, Values} = Fun_5(I_7, Key, Keys, Values),
        nil
    catch {return, Ret} -> Ret end.

print_mapping(Keys_2, Values_2) ->
    try
        S_3 = "{",
        I_9 = 0,
        Fun_6 = fun Fun_6_loop(I_9, Keys_2, S_3, Values_2) ->
    case (I_9 < length(Keys_2)) of
        true ->
            S_4 = (((((S_3 ++ "'") ++ (case erlang:is_map(Keys_2) of true -> maps:get(I_9, Keys_2, nil); _ -> lists:nth(I_9 + 1, Keys_2) end)) ++ "': '") ++ (case erlang:is_map(Values_2) of true -> maps:get(I_9, Values_2, nil); _ -> lists:nth(I_9 + 1, Values_2) end)) ++ "'"),
            case ((I_9 + 1) < length(Keys_2)) of
        true -> S_5 = (S_4 ++ ", "),
            S_6 = S_5;
        _ -> S_6 = S_4
    end,
            I_10 = (I_9 + 1),
            Fun_6_loop(I_10, Keys_2, S_6, Values_2);
        _ -> {I_9, Keys_2, S_3, Values_2}
    end
end,
{I_10, Keys_2, S_6, Values_2} = Fun_6(I_9, Keys_2, S_3, Values_2),
        S_7 = (S_6 ++ "}"),
        io:format("~ts~n", [mochi_repr(S_7)]),
        nil
    catch {return, Ret} -> Ret end.

mixed_keyword(Keyword, Plaintext, Verbose) ->
    try
        Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Keyword_u = to_upper(Keyword),
        Plaintext_u = to_upper(Plaintext),
        Unique = [],
        I_11 = 0,
        Fun_7 = fun Fun_7_loop(Alphabet, I_11, Keyword, Keyword_u, Plaintext, Plaintext_u, Unique, Verbose) ->
    case (I_11 < length(Keyword_u)) of
        true ->
            Ch_3 = string:substr(Keyword_u, I_11 + 1, 1),
            case (contains_char(Alphabet, Ch_3) andalso (mochi_member(Ch_3, Unique) == false)) of
        true -> Unique_2 = lists:append(Unique, [Ch_3]),
            Unique_3 = Unique_2;
        _ -> Unique_3 = Unique
    end,
            I_12 = (I_11 + 1),
            Fun_7_loop(Alphabet, I_12, Keyword, Keyword_u, Plaintext, Plaintext_u, Unique_3, Verbose);
        _ -> {Alphabet, I_11, Keyword, Keyword_u, Plaintext, Plaintext_u, Unique, Verbose}
    end
end,
{Alphabet, I_12, Keyword, Keyword_u, Plaintext, Plaintext_u, Unique_3, Verbose} = Fun_7(Alphabet, I_11, Keyword, Keyword_u, Plaintext, Plaintext_u, Unique, Verbose),
        Num_unique = length(Unique_3),
        Shifted = [],
        I_13 = 0,
        Fun_8 = fun Fun_8_loop(Alphabet, I_13, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted, Unique_3, Verbose) ->
    case (I_13 < length(Unique_3)) of
        true ->
            Shifted_2 = lists:append(Shifted, [(case erlang:is_map(Unique_3) of true -> maps:get(I_13, Unique_3, nil); _ -> lists:nth(I_13 + 1, Unique_3) end)]),
            I_14 = (I_13 + 1),
            Fun_8_loop(Alphabet, I_14, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted_2, Unique_3, Verbose);
        _ -> {Alphabet, I_13, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted, Unique_3, Verbose}
    end
end,
{Alphabet, I_14, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted_2, Unique_3, Verbose} = Fun_8(Alphabet, I_13, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted, Unique_3, Verbose),
        I_15 = 0,
        Fun_9 = fun Fun_9_loop(Alphabet, I_15, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted_2, Unique_3, Verbose) ->
    case (I_15 < length(Alphabet)) of
        true ->
            Ch_4 = string:substr(Alphabet, I_15 + 1, 1),
            case (mochi_member(Ch_4, Unique_3) == false) of
        true -> Shifted_3 = lists:append(Shifted_2, [Ch_4]),
            Shifted_4 = Shifted_3;
        _ -> Shifted_4 = Shifted_2
    end,
            I_16 = (I_15 + 1),
            Fun_9_loop(Alphabet, I_16, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Verbose);
        _ -> {Alphabet, I_15, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted_2, Unique_3, Verbose}
    end
end,
{Alphabet, I_16, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Verbose} = Fun_9(Alphabet, I_15, Keyword, Keyword_u, Num_unique, Plaintext, Plaintext_u, Shifted_2, Unique_3, Verbose),
        Modified = [],
        K = 0,
        Fun_11 = fun Fun_11_loop(Alphabet, I_16, K, Keyword, Keyword_u, Modified, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Verbose) ->
    case (K < length(Shifted_4)) of
        true ->
            Row = [],
            R = 0,
            Fun_10 = fun Fun_10_loop(Alphabet, I_16, K, Keyword, Keyword_u, Modified, Num_unique, Plaintext, Plaintext_u, R, Row, Shifted_4, Unique_3, Verbose) ->
    case ((R < Num_unique) andalso ((K + R) < length(Shifted_4))) of
        true ->
            Row_2 = lists:append(Row, [(case erlang:is_map(Shifted_4) of true -> maps:get((K + R), Shifted_4, nil); _ -> lists:nth((K + R) + 1, Shifted_4) end)]),
            R_2 = (R + 1),
            Fun_10_loop(Alphabet, I_16, K, Keyword, Keyword_u, Modified, Num_unique, Plaintext, Plaintext_u, R_2, Row_2, Shifted_4, Unique_3, Verbose);
        _ -> {Alphabet, I_16, K, Keyword, Keyword_u, Modified, Num_unique, Plaintext, Plaintext_u, R, Row, Shifted_4, Unique_3, Verbose}
    end
end,
{Alphabet, I_16, K, Keyword, Keyword_u, Modified, Num_unique, Plaintext, Plaintext_u, R_2, Row_2, Shifted_4, Unique_3, Verbose} = Fun_10(Alphabet, I_16, K, Keyword, Keyword_u, Modified, Num_unique, Plaintext, Plaintext_u, R, Row, Shifted_4, Unique_3, Verbose),
            Modified_2 = lists:append(Modified, [Row_2]),
            K_2 = (K + Num_unique),
            Fun_11_loop(Alphabet, I_16, K_2, Keyword, Keyword_u, Modified_2, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Verbose);
        _ -> {Alphabet, I_16, K, Keyword, Keyword_u, Modified, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Verbose}
    end
end,
{Alphabet, I_16, K_2, Keyword, Keyword_u, Modified_2, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Verbose} = Fun_11(Alphabet, I_16, K, Keyword, Keyword_u, Modified, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Verbose),
        Keys_3 = [],
        Values_3 = [],
        Column = 0,
        Letter_index = 0,
        Fun_13 = fun Fun_13_loop(Alphabet, Column, I_16, K_2, Keys_3, Keyword, Keyword_u, Letter_index, Modified_2, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Values_3, Verbose) ->
    case (Column < Num_unique) of
        true ->
            try
                Row_idx = 0,
                Fun_12 = fun Fun_12_loop(Alphabet, Column, I_16, K_2, Keys_3, Keyword, Keyword_u, Letter_index, Modified_2, Num_unique, Plaintext, Plaintext_u, Row_idx, Shifted_4, Unique_3, Values_3, Verbose) ->
    case (Row_idx < length(Modified_2)) of
        true ->
            try
                Row_3 = (case erlang:is_map(Modified_2) of true -> maps:get(Row_idx, Modified_2, nil); _ -> lists:nth(Row_idx + 1, Modified_2) end),
                case (length(Row_3) =< Column) of
        true -> throw({break, Alphabet, Column, I_16, K_2, Keys_3, Keyword, Keyword_u, Letter_index, Modified_2, Num_unique, Plaintext, Plaintext_u, Row_idx, Shifted_4, Unique_3, Values_3, Verbose});
        _ -> ok
    end,
                Keys_4 = lists:append(Keys_3, [string:substr(Alphabet, Letter_index + 1, 1)]),
                Values_4 = lists:append(Values_3, [(case erlang:is_map(Row_3) of true -> maps:get(Column, Row_3, nil); _ -> lists:nth(Column + 1, Row_3) end)]),
                Letter_index_2 = (Letter_index + 1),
                Row_idx_2 = (Row_idx + 1),
                Fun_12_loop(Alphabet, Column, I_16, K_2, Keys_4, Keyword, Keyword_u, Letter_index_2, Modified_2, Num_unique, Plaintext, Plaintext_u, Row_idx_2, Shifted_4, Unique_3, Values_4, Verbose)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16} -> Fun_12_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15, C16);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15, B16}
            end;
        _ -> {Alphabet, Column, I_16, K_2, Keys_3, Keyword, Keyword_u, Letter_index, Modified_2, Num_unique, Plaintext, Plaintext_u, Row_idx, Shifted_4, Unique_3, Values_3, Verbose}
    end
end,
{Alphabet, Column, I_16, K_2, Keys_4, Keyword, Keyword_u, Letter_index_2, Modified_2, Num_unique, Plaintext, Plaintext_u, Row_idx_2, Shifted_4, Unique_3, Values_4, Verbose} = Fun_12(Alphabet, Column, I_16, K_2, Keys_3, Keyword, Keyword_u, Letter_index, Modified_2, Num_unique, Plaintext, Plaintext_u, Row_idx, Shifted_4, Unique_3, Values_3, Verbose),
                Column_2 = (Column + 1),
                Fun_13_loop(Alphabet, Column_2, I_16, K_2, Keys_4, Keyword, Keyword_u, Letter_index_2, Modified_2, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Values_4, Verbose)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15} -> Fun_13_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15}
            end;
        _ -> {Alphabet, Column, I_16, K_2, Keys_3, Keyword, Keyword_u, Letter_index, Modified_2, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Values_3, Verbose}
    end
end,
{Alphabet, Column_2, I_16, K_2, Keys_4, Keyword, Keyword_u, Letter_index_2, Modified_2, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Values_4, Verbose} = Fun_13(Alphabet, Column, I_16, K_2, Keys_3, Keyword, Keyword_u, Letter_index, Modified_2, Num_unique, Plaintext, Plaintext_u, Shifted_4, Unique_3, Values_3, Verbose),
        case Verbose of
        true -> print_mapping(Keys_4, Values_4);
        _ -> ok
    end,
        Result = "",
        I_17 = 0,
        Fun_14 = fun Fun_14_loop(Alphabet, Column_2, I_17, K_2, Keys_4, Keyword, Keyword_u, Letter_index_2, Modified_2, Num_unique, Plaintext, Plaintext_u, Result, Shifted_4, Unique_3, Values_4, Verbose) ->
    case (I_17 < length(Plaintext_u)) of
        true ->
            Ch_5 = string:substr(Plaintext_u, I_17 + 1, 1),
            Mapped = get_value(Keys_4, Values_4, Ch_5),
            case (Mapped == nil) of
        true -> Result_2 = (Result ++ Ch_5),
            Result_4 = Result_2;
        _ -> Result_3 = (Result ++ Mapped),
            Result_4 = Result_3
    end,
            I_18 = (I_17 + 1),
            Fun_14_loop(Alphabet, Column_2, I_18, K_2, Keys_4, Keyword, Keyword_u, Letter_index_2, Modified_2, Num_unique, Plaintext, Plaintext_u, Result_4, Shifted_4, Unique_3, Values_4, Verbose);
        _ -> {Alphabet, Column_2, I_17, K_2, Keys_4, Keyword, Keyword_u, Letter_index_2, Modified_2, Num_unique, Plaintext, Plaintext_u, Result, Shifted_4, Unique_3, Values_4, Verbose}
    end
end,
{Alphabet, Column_2, I_18, K_2, Keys_4, Keyword, Keyword_u, Letter_index_2, Modified_2, Num_unique, Plaintext, Plaintext_u, Result_4, Shifted_4, Unique_3, Values_4, Verbose} = Fun_14(Alphabet, Column_2, I_17, K_2, Keys_4, Keyword, Keyword_u, Letter_index_2, Modified_2, Num_unique, Plaintext, Plaintext_u, Result, Shifted_4, Unique_3, Values_4, Verbose),
        Result_4
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('UPPER', "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    erlang:put('LOWER', "abcdefghijklmnopqrstuvwxyz"),
    io:format("~ts~n", [mochi_repr(mixed_keyword("college", "UNIVERSITY", true))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
