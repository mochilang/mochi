#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, int_pow/2, pow_mod/3, rand_range/2, rabin_miller/1, is_prime_low_num/1, generate_large_prime/1]).

% Generated by Mochi transpiler v0.10.59 (98c5e0dd92) on 2025-08-06 22:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

int_pow(Base, Exp) ->
    try
        Result = 1,
        I = 0,
        Fun = fun Fun_loop(Base, Exp, I, Result) ->
    case (I < Exp) of
        true ->
            Result_2 = (Result * Base),
            I_2 = (I + 1),
            Fun_loop(Base, Exp, I_2, Result_2);
        _ -> {Base, Exp, I, Result}
    end
end,
{Base, Exp, I_2, Result_2} = Fun(Base, Exp, I, Result),
        Result_2
    catch {return, Ret} -> Ret end.

pow_mod(Base_2, Exp_2, Mod) ->
    try
        Result_3 = 1,
        B = (Base_2 rem Mod),
        E = Exp_2,
        Fun_2 = fun Fun_2_loop(B, Base_2, E, Exp_2, Mod, Result_3) ->
    case (E > 0) of
        true ->
            case ((E rem 2) == 1) of
        true -> Result_4 = ((Result_3 * B) rem Mod),
            Result_5 = Result_4;
        _ -> Result_5 = Result_3
    end,
            E_2 = (E div 2),
            B_2 = ((B * B) rem Mod),
            Fun_2_loop(B_2, Base_2, E_2, Exp_2, Mod, Result_5);
        _ -> {B, Base_2, E, Exp_2, Mod, Result_3}
    end
end,
{B_2, Base_2, E_2, Exp_2, Mod, Result_5} = Fun_2(B, Base_2, E, Exp_2, Mod, Result_3),
        Result_5
    catch {return, Ret} -> Ret end.

rand_range(Low, High) ->
    try
        ((mochi_now() rem (High - Low)) + Low)
    catch {return, Ret} -> Ret end.

rabin_miller(Num) ->
    try
        S = (Num - 1),
        T = 0,
        Fun_3 = fun Fun_3_loop(Num, S, T) ->
    case ((S rem 2) == 0) of
        true ->
            S_2 = (S div 2),
            T_2 = (T + 1),
            Fun_3_loop(Num, S_2, T_2);
        _ -> {Num, S, T}
    end
end,
{Num, S_2, T_2} = Fun_3(Num, S, T),
        K = 0,
        Fun_6 = fun Fun_6_loop(K, Num, S_2, T_2) ->
    case (K < 5) of
        true ->
            A = rand_range(2, (Num - 1)),
            V = pow_mod(A, S_2, Num),
            case (V /= 1) of
        true -> I_3 = 0,
            Fun_4 = fun Fun_4_loop(A, I_3, K, Num, S_2, T_2, V) ->
    case (V /= (Num - 1)) of
        true ->
            case (I_3 == (T_2 - 1)) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            V_2 = ((V * V) rem Num),
            Fun_4_loop(A, I_4, K, Num, S_2, T_2, V_2);
        _ -> {A, I_3, K, Num, S_2, T_2, V}
    end
end,
{A, I_4, K, Num, S_2, T_2, V_2} = Fun_4(A, I_3, K, Num, S_2, T_2, V),
            Fun_5 = Fun_4,
            I_5 = I_4,
            V_3 = V_2;
        _ -> Fun_5 = Fun_3,
            I_5 = nil,
            V_3 = V
    end,
            K_2 = (K + 1),
            Fun_6_loop(K_2, Num, S_2, T_2);
        _ -> {K, Num, S_2, T_2}
    end
end,
{K_2, Num, S_2, T_2} = Fun_6(K, Num, S_2, T_2),
        true
    catch {return, Ret} -> Ret end.

is_prime_low_num(Num_2) ->
    try
        case (Num_2 < 2) of
        true -> throw({return, false});
        _ -> ok
    end,
        Low_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],
        case mochi_member(Num_2, Low_primes) of
        true -> throw({return, true});
        _ -> ok
    end,
        I_6 = 0,
        Fun_7 = fun Fun_7_loop(I_6, Low_primes, Num_2) ->
    case (I_6 < length(Low_primes)) of
        true ->
            P = (case erlang:is_map(Low_primes) of true -> maps:get(I_6, Low_primes, nil); _ -> lists:nth(I_6 + 1, Low_primes) end),
            case ((Num_2 rem P) == 0) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_7 = (I_6 + 1),
            Fun_7_loop(I_7, Low_primes, Num_2);
        _ -> {I_6, Low_primes, Num_2}
    end
end,
{I_7, Low_primes, Num_2} = Fun_7(I_6, Low_primes, Num_2),
        rabin_miller(Num_2)
    catch {return, Ret} -> Ret end.

generate_large_prime(Keysize) ->
    try
        Start = int_pow(2, (Keysize - 1)),
        End = int_pow(2, Keysize),
        Fun_8 = fun Fun_8_loop(End, Keysize, Start) ->
    case true of
        true ->
            Num_3 = rand_range(Start, End),
            case is_prime_low_num(Num_3) of
        true -> throw({return, Num_3});
        _ -> ok
    end,
            Fun_8_loop(End, Keysize, Start);
        _ -> {End, Keysize, Start}
    end
end,
{End, Keysize, Start} = Fun_8(End, Keysize, Start),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('p', generate_large_prime(16)),
    io:format("~ts~n", [mochi_repr(("Prime number: " ++ mochi_str(erlang:get('p'))))]),
    io:format("~ts~n", [mochi_repr(("is_prime_low_num: " ++ mochi_str(is_prime_low_num(erlang:get('p')))))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
