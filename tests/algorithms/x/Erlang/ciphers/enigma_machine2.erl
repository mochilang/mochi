#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, list_contains/2, index_in_string/2, contains_char/2, to_uppercase/1, plugboard_map/2, reflector_map/1, count_unique/1, build_plugboard/1, validator/3, enigma/4, main/0]).

% Generated by Mochi transpiler v0.10.63 (26477f70ed) on 2025-08-09 23:14 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_nth/2}).
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

list_contains(Xs, X) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, X, Xs) ->
    case (I < erlang:length(Xs)) of
        true ->
            case ((case erlang:is_map(Xs) of true -> maps:get(I, Xs, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Xs) + I + 1, Xs); _ -> mochi_nth(I + 1, Xs) end end) == X) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, X, Xs);
        _ -> {I, X, Xs}
    end
end,
{I_2, X, Xs} = Fun(I, X, Xs),
        false
    catch {return, RetCatch} -> RetCatch end.

index_in_string(S, Ch) ->
    try
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Ch, I_3, S) ->
    case (I_3 < erlang:length(S)) of
        true ->
            case (string:substr(S, I_3 + 1, ((I_3 + 1) - I_3)) == Ch) of
        true -> throw({return, I_3});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Ch, I_4, S);
        _ -> {Ch, I_3, S}
    end
end,
{Ch, I_4, S} = Fun_2(Ch, I_3, S),
        -1
    catch {return, RetCatch} -> RetCatch end.

contains_char(S_2, Ch_2) ->
    try
        (index_in_string(S_2, Ch_2) >= 0)
    catch {return, RetCatch} -> RetCatch end.

to_uppercase(S_3) ->
    try
        Res = "",
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(I_5, Res, S_3) ->
    case (I_5 < erlang:length(S_3)) of
        true ->
            Ch_3 = string:substr(S_3, I_5 + 1, ((I_5 + 1) - I_5)),
            Idx = index_in_string("abcdefghijklmnopqrstuvwxyz", Ch_3),
            case (Idx >= 0) of
        true -> Res_2 = (Res ++ string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Idx + 1, ((Idx + 1) - Idx))),
            Res_4 = Res_2;
        _ -> Res_3 = (Res ++ Ch_3),
            Res_4 = Res_3
    end,
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, Res_4, S_3);
        _ -> {I_5, Res, S_3}
    end
end,
{I_6, Res_4, S_3} = Fun_3(I_5, Res, S_3),
        Res_4
    catch {return, RetCatch} -> RetCatch end.

plugboard_map(Pb, Ch_4) ->
    try
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(Ch_4, I_7, Pb) ->
    case (I_7 < erlang:length(Pb)) of
        true ->
            Pair = (case erlang:is_map(Pb) of true -> maps:get(I_7, Pb, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Pb) + I_7 + 1, Pb); _ -> mochi_nth(I_7 + 1, Pb) end end),
            A = string:substr(Pair, 0 + 1, (1 - 0)),
            B = string:substr(Pair, 1 + 1, (2 - 1)),
            case (Ch_4 == A) of
        true -> throw({return, B});
        _ -> ok
    end,
            case (Ch_4 == B) of
        true -> throw({return, A});
        _ -> ok
    end,
            I_8 = (I_7 + 1),
            Fun_4_loop(Ch_4, I_8, Pb);
        _ -> {Ch_4, I_7, Pb}
    end
end,
{Ch_4, I_8, Pb} = Fun_4(Ch_4, I_7, Pb),
        Ch_4
    catch {return, RetCatch} -> RetCatch end.

reflector_map(Ch_5) ->
    try
        I_9 = 0,
        Fun_5 = fun Fun_5_loop(Ch_5, I_9) ->
    case (I_9 < erlang:length(erlang:get('reflector_pairs'))) of
        true ->
            Pair_2 = (case erlang:is_map(erlang:get('reflector_pairs')) of true -> maps:get(I_9, erlang:get('reflector_pairs'), nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(erlang:get('reflector_pairs')) + I_9 + 1, erlang:get('reflector_pairs')); _ -> mochi_nth(I_9 + 1, erlang:get('reflector_pairs')) end end),
            A_2 = string:substr(Pair_2, 0 + 1, (1 - 0)),
            B_2 = string:substr(Pair_2, 1 + 1, (2 - 1)),
            case (Ch_5 == A_2) of
        true -> throw({return, B_2});
        _ -> ok
    end,
            case (Ch_5 == B_2) of
        true -> throw({return, A_2});
        _ -> ok
    end,
            I_10 = (I_9 + 1),
            Fun_5_loop(Ch_5, I_10);
        _ -> {Ch_5, I_9}
    end
end,
{Ch_5, I_10} = Fun_5(Ch_5, I_9),
        Ch_5
    catch {return, RetCatch} -> RetCatch end.

count_unique(Xs_2) ->
    try
        Unique = [],
        I_11 = 0,
        Fun_6 = fun Fun_6_loop(I_11, Unique, Xs_2) ->
    case (I_11 < erlang:length(Xs_2)) of
        true ->
            case mochi_not(list_contains(Unique, (case erlang:is_map(Xs_2) of true -> maps:get(I_11, Xs_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Xs_2) + I_11 + 1, Xs_2); _ -> mochi_nth(I_11 + 1, Xs_2) end end))) of
        true -> Unique_2 = lists:append((case Unique of nil -> []; _ -> Unique end), [(case erlang:is_map(Xs_2) of true -> maps:get(I_11, Xs_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Xs_2) + I_11 + 1, Xs_2); _ -> mochi_nth(I_11 + 1, Xs_2) end end)]),
            Unique_3 = Unique_2;
        _ -> Unique_3 = Unique
    end,
            I_12 = (I_11 + 1),
            Fun_6_loop(I_12, Unique_3, Xs_2);
        _ -> {I_11, Unique, Xs_2}
    end
end,
{I_12, Unique_3, Xs_2} = Fun_6(I_11, Unique, Xs_2),
        erlang:length(Unique_3)
    catch {return, RetCatch} -> RetCatch end.

build_plugboard(Pbstring) ->
    try
        case (erlang:length(Pbstring) == 0) of
        true -> throw({return, []});
        _ -> ok
    end,
        case (mochi_mod(erlang:length(Pbstring), 2) /= 0) of
        true -> erlang:error({panic, (("Odd number of symbols(" ++ mochi_str(erlang:length(Pbstring))) ++ ")")});
        _ -> ok
    end,
        Pbstring_nospace = "",
        I_13 = 0,
        Fun_7 = fun Fun_7_loop(I_13, Pbstring, Pbstring_nospace) ->
    case (I_13 < erlang:length(Pbstring)) of
        true ->
            Ch_6 = string:substr(Pbstring, I_13 + 1, ((I_13 + 1) - I_13)),
            case (Ch_6 /= " ") of
        true -> Pbstring_nospace_2 = (Pbstring_nospace ++ Ch_6),
            Pbstring_nospace_3 = Pbstring_nospace_2;
        _ -> Pbstring_nospace_3 = Pbstring_nospace
    end,
            I_14 = (I_13 + 1),
            Fun_7_loop(I_14, Pbstring, Pbstring_nospace_3);
        _ -> {I_13, Pbstring, Pbstring_nospace}
    end
end,
{I_14, Pbstring, Pbstring_nospace_3} = Fun_7(I_13, Pbstring, Pbstring_nospace),
        Seen = [],
        I_15 = 0,
        Fun_8 = fun Fun_8_loop(I_15, Pbstring, Pbstring_nospace_3, Seen) ->
    case (I_15 < erlang:length(Pbstring_nospace_3)) of
        true ->
            Ch_7 = string:substr(Pbstring_nospace_3, I_15 + 1, ((I_15 + 1) - I_15)),
            case mochi_not(contains_char("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Ch_7)) of
        true -> erlang:error({panic, (("'" ++ Ch_7) ++ "' not in list of symbols")});
        _ -> ok
    end,
            case list_contains(Seen, Ch_7) of
        true -> erlang:error({panic, (("Duplicate symbol(" ++ Ch_7) ++ ")")});
        _ -> ok
    end,
            Seen_2 = lists:append((case Seen of nil -> []; _ -> Seen end), [Ch_7]),
            I_16 = (I_15 + 1),
            Fun_8_loop(I_16, Pbstring, Pbstring_nospace_3, Seen_2);
        _ -> {I_15, Pbstring, Pbstring_nospace_3, Seen}
    end
end,
{I_16, Pbstring, Pbstring_nospace_3, Seen_2} = Fun_8(I_15, Pbstring, Pbstring_nospace_3, Seen),
        Pb_2 = [],
        I_17 = 0,
        Fun_9 = fun Fun_9_loop(I_17, Pb_2, Pbstring, Pbstring_nospace_3, Seen_2) ->
    case (I_17 < (erlang:length(Pbstring_nospace_3) - 1)) of
        true ->
            A_3 = string:substr(Pbstring_nospace_3, I_17 + 1, ((I_17 + 1) - I_17)),
            B_3 = string:substr(Pbstring_nospace_3, (I_17 + 1) + 1, ((I_17 + 2) - (I_17 + 1))),
            Pb_3 = lists:append((case Pb_2 of nil -> []; _ -> Pb_2 end), [(A_3 ++ B_3)]),
            I_18 = (I_17 + 2),
            Fun_9_loop(I_18, Pb_3, Pbstring, Pbstring_nospace_3, Seen_2);
        _ -> {I_17, Pb_2, Pbstring, Pbstring_nospace_3, Seen_2}
    end
end,
{I_18, Pb_3, Pbstring, Pbstring_nospace_3, Seen_2} = Fun_9(I_17, Pb_2, Pbstring, Pbstring_nospace_3, Seen_2),
        Pb_3
    catch {return, RetCatch} -> RetCatch end.

validator(Rotpos, Rotsel, Pb_4) ->
    try
        case (count_unique(Rotsel) < 3) of
        true -> erlang:error({panic, (("Please use 3 unique rotors (not " ++ mochi_str(count_unique(Rotsel))) ++ ")")});
        _ -> ok
    end,
        case (erlang:length(Rotpos) /= 3) of
        true -> erlang:error({panic, "Rotor position must have 3 values"});
        _ -> ok
    end,
        R1 = (case erlang:is_map(Rotpos) of true -> maps:get(0, Rotpos, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Rotpos) + 0 + 1, Rotpos); _ -> mochi_nth(0 + 1, Rotpos) end end),
        R2 = (case erlang:is_map(Rotpos) of true -> maps:get(1, Rotpos, nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length(Rotpos) + 1 + 1, Rotpos); _ -> mochi_nth(1 + 1, Rotpos) end end),
        R3 = (case erlang:is_map(Rotpos) of true -> maps:get(2, Rotpos, nil); _ -> case 2 < 0 of true -> mochi_nth(erlang:length(Rotpos) + 2 + 1, Rotpos); _ -> mochi_nth(2 + 1, Rotpos) end end),
        case mochi_not(((0 < R1) andalso (R1 =< erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")))) of
        true -> erlang:error({panic, (("First rotor position is not within range of 1..26 (" ++ mochi_str(R1)) ++ ")")});
        _ -> ok
    end,
        case mochi_not(((0 < R2) andalso (R2 =< erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")))) of
        true -> erlang:error({panic, (("Second rotor position is not within range of 1..26 (" ++ mochi_str(R2)) ++ ")")});
        _ -> ok
    end,
        case mochi_not(((0 < R3) andalso (R3 =< erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")))) of
        true -> erlang:error({panic, (("Third rotor position is not within range of 1..26 (" ++ mochi_str(R3)) ++ ")")});
        _ -> ok
    end,
        nil
    catch {return, RetCatch} -> RetCatch end.

enigma(Text, Rotor_position, Rotor_selection, Plugb) ->
    try
        Up_text = to_uppercase(Text),
        Up_pb = to_uppercase(Plugb),
        validator(Rotor_position, Rotor_selection, Up_pb),
        Plugboard = build_plugboard(Up_pb),
        Rotorpos1 = ((case erlang:is_map(Rotor_position) of true -> maps:get(0, Rotor_position, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Rotor_position) + 0 + 1, Rotor_position); _ -> mochi_nth(0 + 1, Rotor_position) end end) - 1),
        Rotorpos2 = ((case erlang:is_map(Rotor_position) of true -> maps:get(1, Rotor_position, nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length(Rotor_position) + 1 + 1, Rotor_position); _ -> mochi_nth(1 + 1, Rotor_position) end end) - 1),
        Rotorpos3 = ((case erlang:is_map(Rotor_position) of true -> maps:get(2, Rotor_position, nil); _ -> case 2 < 0 of true -> mochi_nth(erlang:length(Rotor_position) + 2 + 1, Rotor_position); _ -> mochi_nth(2 + 1, Rotor_position) end end) - 1),
        Rotor_a = (case erlang:is_map(Rotor_selection) of true -> maps:get(0, Rotor_selection, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Rotor_selection) + 0 + 1, Rotor_selection); _ -> mochi_nth(0 + 1, Rotor_selection) end end),
        Rotor_b = (case erlang:is_map(Rotor_selection) of true -> maps:get(1, Rotor_selection, nil); _ -> case 1 < 0 of true -> mochi_nth(erlang:length(Rotor_selection) + 1 + 1, Rotor_selection); _ -> mochi_nth(1 + 1, Rotor_selection) end end),
        Rotor_c = (case erlang:is_map(Rotor_selection) of true -> maps:get(2, Rotor_selection, nil); _ -> case 2 < 0 of true -> mochi_nth(erlang:length(Rotor_selection) + 2 + 1, Rotor_selection); _ -> mochi_nth(2 + 1, Rotor_selection) end end),
        Result = "",
        I_19 = 0,
        Fun_10 = fun Fun_10_loop(I_19, Plugb, Plugboard, Result, Rotor_a, Rotor_b, Rotor_c, Rotor_position, Rotor_selection, Rotorpos1, Rotorpos2, Rotorpos3, Text, Up_pb, Up_text) ->
    case (I_19 < erlang:length(Up_text)) of
        true ->
            Symbol = string:substr(Up_text, I_19 + 1, ((I_19 + 1) - I_19)),
            case contains_char("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Symbol) of
        true -> Symbol_2 = plugboard_map(Plugboard, Symbol),
            Index = (index_in_string("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Symbol_2) + Rotorpos1),
            Symbol_3 = string:substr(Rotor_a, mochi_mod(Index, erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) + 1, ((mochi_mod(Index, erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) + 1) - mochi_mod(Index, erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")))),
            Index_2 = (index_in_string("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Symbol_3) + Rotorpos2),
            Symbol_4 = string:substr(Rotor_b, mochi_mod(Index_2, erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) + 1, ((mochi_mod(Index_2, erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) + 1) - mochi_mod(Index_2, erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")))),
            Index_3 = (index_in_string("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Symbol_4) + Rotorpos3),
            Symbol_5 = string:substr(Rotor_c, mochi_mod(Index_3, erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) + 1, ((mochi_mod(Index_3, erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) + 1) - mochi_mod(Index_3, erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")))),
            Symbol_6 = reflector_map(Symbol_5),
            Index_4 = (index_in_string(Rotor_c, Symbol_6) - Rotorpos3),
            case (Index_4 < 0) of
        true -> Index_5 = (Index_4 + erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")),
            Index_6 = Index_5;
        _ -> Index_6 = Index_4
    end,
            Symbol_7 = string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Index_6 + 1, ((Index_6 + 1) - Index_6)),
            Index_7 = (index_in_string(Rotor_b, Symbol_7) - Rotorpos2),
            case (Index_7 < 0) of
        true -> Index_8 = (Index_7 + erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")),
            Index_9 = Index_8;
        _ -> Index_9 = Index_7
    end,
            Symbol_8 = string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Index_9 + 1, ((Index_9 + 1) - Index_9)),
            Index_10 = (index_in_string(Rotor_a, Symbol_8) - Rotorpos1),
            case (Index_10 < 0) of
        true -> Index_11 = (Index_10 + erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")),
            Index_12 = Index_11;
        _ -> Index_12 = Index_10
    end,
            Symbol_9 = string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Index_12 + 1, ((Index_12 + 1) - Index_12)),
            Symbol_10 = plugboard_map(Plugboard, Symbol_9),
            Rotorpos1_2 = (Rotorpos1 + 1),
            case (Rotorpos1_2 >= erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) of
        true -> Rotorpos1_3 = 0,
            Rotorpos2_2 = (Rotorpos2 + 1),
            Rotorpos1_4 = Rotorpos1_3,
            Rotorpos2_3 = Rotorpos2_2;
        _ -> Rotorpos1_4 = Rotorpos1_2,
            Rotorpos2_3 = Rotorpos2
    end,
            case (Rotorpos2_3 >= erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) of
        true -> Rotorpos2_4 = 0,
            Rotorpos3_2 = (Rotorpos3 + 1),
            Rotorpos2_5 = Rotorpos2_4,
            Rotorpos3_3 = Rotorpos3_2;
        _ -> Rotorpos2_5 = Rotorpos2_3,
            Rotorpos3_3 = Rotorpos3
    end,
            case (Rotorpos3_3 >= erlang:length("ABCDEFGHIJKLMNOPQRSTUVWXYZ")) of
        true -> Rotorpos3_4 = 0,
            Rotorpos3_5 = Rotorpos3_4;
        _ -> Rotorpos3_5 = Rotorpos3_3
    end,
            Index_13 = Index_12,
            Rotorpos1_5 = Rotorpos1_4,
            Rotorpos2_6 = Rotorpos2_5,
            Rotorpos3_6 = Rotorpos3_5,
            Symbol_11 = Symbol_10;
        _ -> Index_13 = nil,
            Rotorpos1_5 = Rotorpos1,
            Rotorpos2_6 = Rotorpos2,
            Rotorpos3_6 = Rotorpos3,
            Symbol_11 = Symbol
    end,
            Result_2 = (Result ++ Symbol_11),
            I_20 = (I_19 + 1),
            Fun_10_loop(I_20, Plugb, Plugboard, Result_2, Rotor_a, Rotor_b, Rotor_c, Rotor_position, Rotor_selection, Rotorpos1_5, Rotorpos2_6, Rotorpos3_6, Text, Up_pb, Up_text);
        _ -> {I_19, Plugb, Plugboard, Result, Rotor_a, Rotor_b, Rotor_c, Rotor_position, Rotor_selection, Rotorpos1, Rotorpos2, Rotorpos3, Text, Up_pb, Up_text}
    end
end,
{I_20, Plugb, Plugboard, Result_2, Rotor_a, Rotor_b, Rotor_c, Rotor_position, Rotor_selection, Rotorpos1_5, Rotorpos2_6, Rotorpos3_6, Text, Up_pb, Up_text} = Fun_10(I_19, Plugb, Plugboard, Result, Rotor_a, Rotor_b, Rotor_c, Rotor_position, Rotor_selection, Rotorpos1, Rotorpos2, Rotorpos3, Text, Up_pb, Up_text),
        Result_2
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        Message = "This is my Python script that emulates the Enigma machine from WWII.",
        Rotor_pos = [1, 1, 1],
        Pb_5 = "pictures",
        Rotor_sel = ["FOBHMDKEXQNRAULPGSJVTYICZW", "RMDJXFUWGISLHVTCQNKYPBEZOA", "LFKIJODBEGAMQPXVUHYSTCZRWN"],
        En = enigma("This is my Python script that emulates the Enigma machine from WWII.", Rotor_pos, Rotor_sel, "pictures"),
        io:format("~ts~n", [mochi_repr(("Encrypted message: " ++ En))]),
        io:format("~ts~n", [mochi_repr(("Decrypted message: " ++ enigma(En, Rotor_pos, Rotor_sel, "pictures")))]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('abc', "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    erlang:put('low_abc', "abcdefghijklmnopqrstuvwxyz"),
    erlang:put('rotor1', "EGZWVONAHDCLFQMSIPJBYUKXTR"),
    erlang:put('rotor2', "FOBHMDKEXQNRAULPGSJVTYICZW"),
    erlang:put('rotor3', "ZJXESIUQLHAVRMDOYGTNFWPBKC"),
    erlang:put('rotor4', "RMDJXFUWGISLHVTCQNKYPBEZOA"),
    erlang:put('rotor5', "SGLCPQWZHKXAREONTFBVIYJUDM"),
    erlang:put('rotor6', "HVSICLTYKQUBXDWAJZOMFGPREN"),
    erlang:put('rotor7', "RZWQHFMVDBKICJLNTUXAGYPSOE"),
    erlang:put('rotor8', "LFKIJODBEGAMQPXVUHYSTCZRWN"),
    erlang:put('rotor9', "KOAEGVDHXPQZMLFTYWJNBRCIUS"),
    erlang:put('reflector_pairs', ["AN", "BO", "CP", "DQ", "ER", "FS", "GT", "HU", "IV", "JW", "KX", "LY", "MZ"]),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
