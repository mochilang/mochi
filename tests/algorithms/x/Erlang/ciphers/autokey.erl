#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, to_lowercase/1, char_index/1, index_char/1, encrypt/2, decrypt/2]).

% Generated by Mochi transpiler v0.10.63 (26477f70ed) on 2025-08-09 23:14 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_nth/2}).
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

to_lowercase(S) ->
    try
        Res = "",
        I = 0,
        Fun_2 = fun Fun_2_loop(I, Res, S) ->
    case (I < erlang:length(S)) of
        true ->
            try
                C = string:substr(S, I + 1, 1),
                J = 0,
                Found = false,
                Fun = fun Fun_loop(C, Found, I, J, Res, S) ->
    case (J < 26) of
        true ->
            try
                case (C == string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", J + 1, 1)) of
        true -> Res_2 = (Res ++ string:substr("abcdefghijklmnopqrstuvwxyz", J + 1, 1)),
            Found_2 = true,
            throw({break, C, Found_2, I, J, Res_2, S}),
            Found_3 = Found_2,
            Res_3 = Res_2;
        _ -> Found_3 = Found,
            Res_3 = Res
    end,
                J_2 = (J + 1),
                Fun_loop(C, Found_3, I, J_2, Res_3, S)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_loop(C0, C1, C2, C3, C4, C5);
                {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5}
            end;
        _ -> {C, Found, I, J, Res, S}
    end
end,
{C, Found_3, I, J_2, Res_3, S} = Fun(C, Found, I, J, Res, S),
                case mochi_not(Found_3) of
        true -> Res_4 = (Res_3 ++ C),
            Res_5 = Res_4;
        _ -> Res_5 = Res_3
    end,
                I_2 = (I + 1),
                Fun_2_loop(I_2, Res_5, S)
            catch
                {continue, C0, C1, C2} -> Fun_2_loop(C0, C1, C2);
                {break, B0, B1, B2} -> {B0, B1, B2}
            end;
        _ -> {I, Res, S}
    end
end,
{I_2, Res_5, S} = Fun_2(I, Res, S),
        Res_5
    catch {return, RetCatch} -> RetCatch end.

char_index(C_2) ->
    try
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(C_2, I_3) ->
    case (I_3 < 26) of
        true ->
            case (C_2 == string:substr("abcdefghijklmnopqrstuvwxyz", I_3 + 1, 1)) of
        true -> throw({return, I_3});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_3_loop(C_2, I_4);
        _ -> {C_2, I_3}
    end
end,
{C_2, I_4} = Fun_3(C_2, I_3),
        -1
    catch {return, RetCatch} -> RetCatch end.

index_char(I_5) ->
    try
        string:substr("abcdefghijklmnopqrstuvwxyz", I_5 + 1, 1)
    catch {return, RetCatch} -> RetCatch end.

encrypt(Plaintext, Key) ->
    try
        case (erlang:length(Plaintext) == 0) of
        true -> erlang:error({panic, "plaintext is empty"});
        _ -> ok
    end,
        case (erlang:length(Key) == 0) of
        true -> erlang:error({panic, "key is empty"});
        _ -> ok
    end,
        Full_key = (Key ++ Plaintext),
        Plaintext_2 = to_lowercase(Plaintext),
        Full_key_2 = to_lowercase(Full_key),
        P_i = 0,
        K_i = 0,
        Ciphertext = "",
        Fun_4 = fun Fun_4_loop(Ciphertext, Full_key_2, K_i, Key, P_i, Plaintext_2) ->
    case (P_i < erlang:length(Plaintext_2)) of
        true ->
            P_char = string:substr(Plaintext_2, P_i + 1, 1),
            P_idx = char_index(P_char),
            case (P_idx < 0) of
        true -> Ciphertext_2 = (Ciphertext ++ P_char),
            P_i_2 = (P_i + 1),
            C_idx_3 = nil,
            Ciphertext_5 = Ciphertext_2,
            K_char_2 = nil,
            K_i_5 = K_i,
            K_idx_2 = nil,
            P_i_5 = P_i_2;
        _ -> K_char = string:substr(Full_key_2, K_i + 1, 1),
            K_idx = char_index(K_char),
            case (K_idx < 0) of
        true -> K_i_2 = (K_i + 1),
            C_idx_2 = nil,
            Ciphertext_4 = Ciphertext,
            K_i_4 = K_i_2,
            P_i_4 = P_i;
        _ -> C_idx = mochi_mod((P_idx + K_idx), 26),
            Ciphertext_3 = (Ciphertext ++ index_char(C_idx)),
            K_i_3 = (K_i + 1),
            P_i_3 = (P_i + 1),
            C_idx_2 = C_idx,
            Ciphertext_4 = Ciphertext_3,
            K_i_4 = K_i_3,
            P_i_4 = P_i_3
    end,
            C_idx_3 = C_idx_2,
            Ciphertext_5 = Ciphertext_4,
            K_char_2 = K_char,
            K_i_5 = K_i_4,
            K_idx_2 = K_idx,
            P_i_5 = P_i_4
    end,
            Fun_4_loop(Ciphertext_5, Full_key_2, K_i_5, Key, P_i_5, Plaintext_2);
        _ -> {Ciphertext, Full_key_2, K_i, Key, P_i, Plaintext_2}
    end
end,
{Ciphertext_5, Full_key_2, K_i_5, Key, P_i_5, Plaintext_2} = Fun_4(Ciphertext, Full_key_2, K_i, Key, P_i, Plaintext_2),
        Ciphertext_5
    catch {return, RetCatch} -> RetCatch end.

decrypt(Ciphertext_6, Key_2) ->
    try
        case (erlang:length(Ciphertext_6) == 0) of
        true -> erlang:error({panic, "ciphertext is empty"});
        _ -> ok
    end,
        case (erlang:length(Key_2) == 0) of
        true -> erlang:error({panic, "key is empty"});
        _ -> ok
    end,
        Current_key = to_lowercase(Key_2),
        C_i = 0,
        K_i_6 = 0,
        Plaintext_3 = "",
        Fun_5 = fun Fun_5_loop(C_i, Ciphertext_6, Current_key, K_i_6, Key_2, Plaintext_3) ->
    case (C_i < erlang:length(Ciphertext_6)) of
        true ->
            C_char = string:substr(Ciphertext_6, C_i + 1, 1),
            C_idx_4 = char_index(C_char),
            case (C_idx_4 < 0) of
        true -> Plaintext_4 = (Plaintext_3 ++ C_char),
            Current_key_3 = Current_key,
            K_char_4 = nil,
            K_i_8 = K_i_6,
            K_idx_4 = nil,
            P_char_3 = nil,
            P_idx_3 = nil,
            Plaintext_6 = Plaintext_4;
        _ -> K_char_3 = string:substr(Current_key, K_i_6 + 1, 1),
            K_idx_3 = char_index(K_char_3),
            P_idx_2 = mochi_mod(((C_idx_4 - K_idx_3) + 26), 26),
            P_char_2 = index_char(P_idx_2),
            Plaintext_5 = (Plaintext_3 ++ P_char_2),
            Current_key_2 = (Current_key ++ P_char_2),
            K_i_7 = (K_i_6 + 1),
            Current_key_3 = Current_key_2,
            K_char_4 = K_char_3,
            K_i_8 = K_i_7,
            K_idx_4 = K_idx_3,
            P_char_3 = P_char_2,
            P_idx_3 = P_idx_2,
            Plaintext_6 = Plaintext_5
    end,
            C_i_2 = (C_i + 1),
            Fun_5_loop(C_i_2, Ciphertext_6, Current_key_3, K_i_8, Key_2, Plaintext_6);
        _ -> {C_i, Ciphertext_6, Current_key, K_i_6, Key_2, Plaintext_3}
    end
end,
{C_i_2, Ciphertext_6, Current_key_3, K_i_8, Key_2, Plaintext_6} = Fun_5(C_i, Ciphertext_6, Current_key, K_i_6, Key_2, Plaintext_3),
        Plaintext_6
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('LOWER', "abcdefghijklmnopqrstuvwxyz"),
    erlang:put('UPPER', "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    io:format("~ts~n", [mochi_repr(encrypt("hello world", "coffee"))]),
    io:format("~ts~n", [mochi_repr(decrypt("jsqqs avvwo", "coffee"))]),
    io:format("~ts~n", [mochi_repr(encrypt("coffee is good as python", "TheAlgorithms"))]),
    io:format("~ts~n", [mochi_repr(decrypt("vvjfpk wj ohvp su ddylsv", "TheAlgorithms"))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
