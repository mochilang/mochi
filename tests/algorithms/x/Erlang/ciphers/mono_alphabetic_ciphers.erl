#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, find_char/2, encrypt_message/2, decrypt_message/2, main/0]).

% Generated by Mochi transpiler v0.10.59 (2399182da0) on 2025-08-06 22:20 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

find_char(S, Ch) ->
    try
        I = 0,
        Fun = fun Fun_loop(Ch, I, S) ->
    case (I < length(S)) of
        true ->
            case (string:substr(S, I + 1, 1) == Ch) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, I_2, S);
        _ -> {Ch, I, S}
    end
end,
{Ch, I_2, S} = Fun(Ch, I, S),
        -1
    catch {return, Ret} -> Ret end.

encrypt_message(Key, Message) ->
    try
        Chars_a = Key,
        Chars_b = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Translated = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Chars_a, Chars_b, I_3, Key, Message, Translated) ->
    case (I_3 < length(Message)) of
        true ->
            Symbol = string:substr(Message, I_3 + 1, 1),
            Upper_sym = string:to_upper(Symbol),
            Sym_index = find_char(Chars_a, Upper_sym),
            case (Sym_index >= 0) of
        true -> Sub_char = string:substr(Chars_b, Sym_index + 1, 1),
            case (Symbol == Upper_sym) of
        true -> Translated_2 = (Translated ++ string:to_upper(Sub_char)),
            Translated_4 = Translated_2;
        _ -> Translated_3 = (Translated ++ string:to_lower(Sub_char)),
            Translated_4 = Translated_3
    end,
            Sub_char_2 = Sub_char,
            Translated_6 = Translated_4;
        _ -> Translated_5 = (Translated ++ Symbol),
            Sub_char_2 = nil,
            Translated_6 = Translated_5
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Chars_a, Chars_b, I_4, Key, Message, Translated_6);
        _ -> {Chars_a, Chars_b, I_3, Key, Message, Translated}
    end
end,
{Chars_a, Chars_b, I_4, Key, Message, Translated_6} = Fun_2(Chars_a, Chars_b, I_3, Key, Message, Translated),
        Translated_6
    catch {return, Ret} -> Ret end.

decrypt_message(Key_2, Message_2) ->
    try
        Chars_a_2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Chars_b_2 = Key_2,
        Translated_7 = "",
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Chars_a_2, Chars_b_2, I_5, Key_2, Message_2, Translated_7) ->
    case (I_5 < length(Message_2)) of
        true ->
            Symbol_2 = string:substr(Message_2, I_5 + 1, 1),
            Upper_sym_2 = string:to_upper(Symbol_2),
            Sym_index_2 = find_char(Chars_a_2, Upper_sym_2),
            case (Sym_index_2 >= 0) of
        true -> Sub_char_3 = string:substr(Chars_b_2, Sym_index_2 + 1, 1),
            case (Symbol_2 == Upper_sym_2) of
        true -> Translated_8 = (Translated_7 ++ string:to_upper(Sub_char_3)),
            Translated_10 = Translated_8;
        _ -> Translated_9 = (Translated_7 ++ string:to_lower(Sub_char_3)),
            Translated_10 = Translated_9
    end,
            Sub_char_4 = Sub_char_3,
            Translated_12 = Translated_10;
        _ -> Translated_11 = (Translated_7 ++ Symbol_2),
            Sub_char_4 = nil,
            Translated_12 = Translated_11
    end,
            I_6 = (I_5 + 1),
            Fun_3_loop(Chars_a_2, Chars_b_2, I_6, Key_2, Message_2, Translated_12);
        _ -> {Chars_a_2, Chars_b_2, I_5, Key_2, Message_2, Translated_7}
    end
end,
{Chars_a_2, Chars_b_2, I_6, Key_2, Message_2, Translated_12} = Fun_3(Chars_a_2, Chars_b_2, I_5, Key_2, Message_2, Translated_7),
        Translated_12
    catch {return, Ret} -> Ret end.

main() ->
    try
        Message_3 = "Hello World",
        Key_3 = "QWERTYUIOPASDFGHJKLZXCVBNM",
        Mode = "decrypt",
        Translated_13 = "",
        case ("decrypt" == "encrypt") of
        true -> Translated_14 = encrypt_message("QWERTYUIOPASDFGHJKLZXCVBNM", "Hello World"),
            Translated_17 = Translated_14;
        _ -> case ("decrypt" == "decrypt") of
        true -> Translated_15 = decrypt_message("QWERTYUIOPASDFGHJKLZXCVBNM", "Hello World"),
            Translated_16 = Translated_15;
        _ -> Translated_16 = Translated_13
    end,
            Translated_17 = Translated_16
    end,
        io:format("~ts~n", [mochi_repr(((((("Using the key " ++ "QWERTYUIOPASDFGHJKLZXCVBNM") ++ ", the ") ++ "decrypt") ++ "ed message is: ") ++ Translated_17))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('LETTERS', "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
