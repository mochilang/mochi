#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, encodetomorse/1, encryptfractionatedmorse/2, decryptfractionatedmorse/2]).

% Generated by Mochi transpiler v0.10.63 (26477f70ed) on 2025-08-09 23:14 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


-compile({nowarn_unused_function, mochi_nth/2}).
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

encodetomorse(Plaintext) ->
    try
        Morse = "",
        I = 0,
        Fun = fun Fun_loop(I, Morse, Plaintext) ->
    case (I < erlang:length(Plaintext)) of
        true ->
            Ch = string:to_upper(string:substr(Plaintext, I + 1, ((I + 1) - I))),
            Code = "",
            case maps:is_key(Ch, erlang:get('MORSE_CODE_DICT')) of
        true -> Code_2 = maps:get(Ch, erlang:get('MORSE_CODE_DICT'), nil),
            Code_3 = Code_2;
        _ -> Code_3 = Code
    end,
            case (I > 0) of
        true -> Morse_2 = (Morse ++ "x"),
            Morse_3 = Morse_2;
        _ -> Morse_3 = Morse
    end,
            Morse_4 = (Morse_3 ++ Code_3),
            I_2 = (I + 1),
            Fun_loop(I_2, Morse_4, Plaintext);
        _ -> {I, Morse, Plaintext}
    end
end,
{I_2, Morse_4, Plaintext} = Fun(I, Morse, Plaintext),
        Morse_4
    catch {return, RetCatch} -> RetCatch end.

encryptfractionatedmorse(Plaintext_2, Key) ->
    try
        MorseCode = encodetomorse(Plaintext_2),
        CombinedKey = (string:to_upper(Key) ++ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
        DedupKey = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(CombinedKey, DedupKey, I_3, Key, MorseCode, Plaintext_2) ->
    case (I_3 < erlang:length(CombinedKey)) of
        true ->
            Ch_2 = string:substr(CombinedKey, I_3 + 1, ((I_3 + 1) - I_3)),
            case mochi_not((string:str(DedupKey, Ch_2) /= 0)) of
        true -> DedupKey_2 = (DedupKey ++ Ch_2),
            DedupKey_3 = DedupKey_2;
        _ -> DedupKey_3 = DedupKey
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(CombinedKey, DedupKey_3, I_4, Key, MorseCode, Plaintext_2);
        _ -> {CombinedKey, DedupKey, I_3, Key, MorseCode, Plaintext_2}
    end
end,
{CombinedKey, DedupKey_3, I_4, Key, MorseCode, Plaintext_2} = Fun_2(CombinedKey, DedupKey, I_3, Key, MorseCode, Plaintext_2),
        PaddingLength = (3 - mochi_mod(erlang:length(MorseCode), 3)),
        P = 0,
        Fun_3 = fun Fun_3_loop(CombinedKey, DedupKey_3, I_4, Key, MorseCode, P, PaddingLength, Plaintext_2) ->
    case (P < PaddingLength) of
        true ->
            MorseCode_2 = (MorseCode ++ "x"),
            P_2 = (P + 1),
            Fun_3_loop(CombinedKey, DedupKey_3, I_4, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2);
        _ -> {CombinedKey, DedupKey_3, I_4, Key, MorseCode, P, PaddingLength, Plaintext_2}
    end
end,
{CombinedKey, DedupKey_3, I_4, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2} = Fun_3(CombinedKey, DedupKey_3, I_4, Key, MorseCode, P, PaddingLength, Plaintext_2),
        Dict = #{},
        J = 0,
        Fun_4 = fun Fun_4_loop(CombinedKey, DedupKey_3, Dict, I_4, J, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2) ->
    case (J < 26) of
        true ->
            Combo = (case erlang:is_map(erlang:get('MORSE_COMBINATIONS')) of true -> maps:get(J, erlang:get('MORSE_COMBINATIONS'), nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(erlang:get('MORSE_COMBINATIONS')) + J + 1, erlang:get('MORSE_COMBINATIONS')); _ -> mochi_nth(J + 1, erlang:get('MORSE_COMBINATIONS')) end end),
            Letter = string:substr(DedupKey_3, J + 1, ((J + 1) - J)),
            Dict_2 = maps:put(Combo, Letter, Dict),
            J_2 = (J + 1),
            Fun_4_loop(CombinedKey, DedupKey_3, Dict_2, I_4, J_2, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2);
        _ -> {CombinedKey, DedupKey_3, Dict, I_4, J, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2}
    end
end,
{CombinedKey, DedupKey_3, Dict_2, I_4, J_2, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2} = Fun_4(CombinedKey, DedupKey_3, Dict, I_4, J, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2),
        Dict_3 = maps:put("xxx", "", Dict_2),
        Encrypted = "",
        K = 0,
        Fun_5 = fun Fun_5_loop(CombinedKey, DedupKey_3, Dict_3, Encrypted, I_4, J_2, K, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2) ->
    case (K < erlang:length(MorseCode_2)) of
        true ->
            Group = string:substr(MorseCode_2, K + 1, ((K + 3) - K)),
            Encrypted_2 = (Encrypted ++ maps:get(Group, Dict_3, nil)),
            K_2 = (K + 3),
            Fun_5_loop(CombinedKey, DedupKey_3, Dict_3, Encrypted_2, I_4, J_2, K_2, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2);
        _ -> {CombinedKey, DedupKey_3, Dict_3, Encrypted, I_4, J_2, K, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2}
    end
end,
{CombinedKey, DedupKey_3, Dict_3, Encrypted_2, I_4, J_2, K_2, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2} = Fun_5(CombinedKey, DedupKey_3, Dict_3, Encrypted, I_4, J_2, K, Key, MorseCode_2, P_2, PaddingLength, Plaintext_2),
        Encrypted_2
    catch {return, RetCatch} -> RetCatch end.

decryptfractionatedmorse(Ciphertext, Key_2) ->
    try
        CombinedKey_2 = (string:to_upper(Key_2) ++ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
        DedupKey_4 = "",
        I_5 = 0,
        Fun_6 = fun Fun_6_loop(Ciphertext, CombinedKey_2, DedupKey_4, I_5, Key_2) ->
    case (I_5 < erlang:length(CombinedKey_2)) of
        true ->
            Ch_3 = string:substr(CombinedKey_2, I_5 + 1, ((I_5 + 1) - I_5)),
            case mochi_not((string:str(DedupKey_4, Ch_3) /= 0)) of
        true -> DedupKey_5 = (DedupKey_4 ++ Ch_3),
            DedupKey_6 = DedupKey_5;
        _ -> DedupKey_6 = DedupKey_4
    end,
            I_6 = (I_5 + 1),
            Fun_6_loop(Ciphertext, CombinedKey_2, DedupKey_6, I_6, Key_2);
        _ -> {Ciphertext, CombinedKey_2, DedupKey_4, I_5, Key_2}
    end
end,
{Ciphertext, CombinedKey_2, DedupKey_6, I_6, Key_2} = Fun_6(Ciphertext, CombinedKey_2, DedupKey_4, I_5, Key_2),
        Inv = #{},
        J_3 = 0,
        Fun_7 = fun Fun_7_loop(Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv, J_3, Key_2) ->
    case (J_3 < 26) of
        true ->
            Letter_2 = string:substr(DedupKey_6, J_3 + 1, ((J_3 + 1) - J_3)),
            Inv_2 = maps:put(Letter_2, (case erlang:is_map(erlang:get('MORSE_COMBINATIONS')) of true -> maps:get(J_3, erlang:get('MORSE_COMBINATIONS'), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length(erlang:get('MORSE_COMBINATIONS')) + J_3 + 1, erlang:get('MORSE_COMBINATIONS')); _ -> mochi_nth(J_3 + 1, erlang:get('MORSE_COMBINATIONS')) end end), Inv),
            J_4 = (J_3 + 1),
            Fun_7_loop(Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv_2, J_4, Key_2);
        _ -> {Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv, J_3, Key_2}
    end
end,
{Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv_2, J_4, Key_2} = Fun_7(Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv, J_3, Key_2),
        Morse_5 = "",
        K_3 = 0,
        Fun_8 = fun Fun_8_loop(Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv_2, J_4, K_3, Key_2, Morse_5) ->
    case (K_3 < erlang:length(Ciphertext)) of
        true ->
            Ch_4 = string:substr(Ciphertext, K_3 + 1, ((K_3 + 1) - K_3)),
            case mochi_member(Ch_4, Inv_2) of
        true -> Morse_6 = (Morse_5 ++ maps:get(Ch_4, Inv_2, nil)),
            Morse_7 = Morse_6;
        _ -> Morse_7 = Morse_5
    end,
            K_4 = (K_3 + 1),
            Fun_8_loop(Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv_2, J_4, K_4, Key_2, Morse_7);
        _ -> {Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv_2, J_4, K_3, Key_2, Morse_5}
    end
end,
{Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv_2, J_4, K_4, Key_2, Morse_7} = Fun_8(Ciphertext, CombinedKey_2, DedupKey_6, I_6, Inv_2, J_4, K_3, Key_2, Morse_5),
        Codes = [],
        Current = "",
        M = 0,
        Fun_9 = fun Fun_9_loop(Ciphertext, Codes, CombinedKey_2, Current, DedupKey_6, I_6, Inv_2, J_4, K_4, Key_2, M, Morse_7) ->
    case (M < erlang:length(Morse_7)) of
        true ->
            Ch_5 = string:substr(Morse_7, M + 1, ((M + 1) - M)),
            case (Ch_5 == "x") of
        true -> Codes_2 = lists:append((case Codes of nil -> []; _ -> Codes end), [Current]),
            Current_2 = "",
            Codes_3 = Codes_2,
            Current_4 = Current_2;
        _ -> Current_3 = (Current ++ Ch_5),
            Codes_3 = Codes,
            Current_4 = Current_3
    end,
            M_2 = (M + 1),
            Fun_9_loop(Ciphertext, Codes_3, CombinedKey_2, Current_4, DedupKey_6, I_6, Inv_2, J_4, K_4, Key_2, M_2, Morse_7);
        _ -> {Ciphertext, Codes, CombinedKey_2, Current, DedupKey_6, I_6, Inv_2, J_4, K_4, Key_2, M, Morse_7}
    end
end,
{Ciphertext, Codes_3, CombinedKey_2, Current_4, DedupKey_6, I_6, Inv_2, J_4, K_4, Key_2, M_2, Morse_7} = Fun_9(Ciphertext, Codes, CombinedKey_2, Current, DedupKey_6, I_6, Inv_2, J_4, K_4, Key_2, M, Morse_7),
        Codes_4 = lists:append((case Codes_3 of nil -> []; _ -> Codes_3 end), [Current_4]),
        Decrypted = "",
        Idx = 0,
        Fun_10 = fun Fun_10_loop(Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted, DedupKey_6, I_6, Idx, Inv_2, J_4, K_4, Key_2, M_2, Morse_7) ->
    case (Idx < erlang:length(Codes_4)) of
        true ->
            Code_4 = (case erlang:is_map(Codes_4) of true -> maps:get(Idx, Codes_4, nil); _ -> case Idx < 0 of true -> mochi_nth(erlang:length(Codes_4) + Idx + 1, Codes_4); _ -> mochi_nth(Idx + 1, Codes_4) end end),
            Decrypted_2 = (Decrypted ++ maps:get(Code_4, erlang:get('REVERSE_DICT'), nil)),
            Idx_2 = (Idx + 1),
            Fun_10_loop(Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7);
        _ -> {Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted, DedupKey_6, I_6, Idx, Inv_2, J_4, K_4, Key_2, M_2, Morse_7}
    end
end,
{Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7} = Fun_10(Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted, DedupKey_6, I_6, Idx, Inv_2, J_4, K_4, Key_2, M_2, Morse_7),
        Start = 0,
        Fun_11 = fun Fun_11_loop(Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start) ->
    case true of
        true ->
            try
                case (Start < erlang:length(Decrypted_2)) of
        true -> case (string:substr(Decrypted_2, Start + 1, ((Start + 1) - Start)) == " ") of
        true -> Start_2 = (Start + 1),
            throw({continue, Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_2}),
            Start_3 = Start_2;
        _ -> Start_3 = Start
    end,
            Start_4 = Start_3;
        _ -> Start_4 = Start
    end,
                throw({break, Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4}),
                Fun_11_loop(Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14} -> Fun_11_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14}
            end;
        _ -> {Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start}
    end
end,
{Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4} = Fun_11(Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start),
        End = erlang:length(Decrypted_2),
        Fun_12 = fun Fun_12_loop(Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, End, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4) ->
    case true of
        true ->
            try
                case (End > Start_4) of
        true -> case (string:substr(Decrypted_2, (End - 1) + 1, (End - (End - 1))) == " ") of
        true -> End_2 = (End - 1),
            throw({continue, Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, End_2, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4}),
            End_3 = End_2;
        _ -> End_3 = End
    end,
            End_4 = End_3;
        _ -> End_4 = End
    end,
                throw({break, Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, End_4, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4}),
                Fun_12_loop(Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, End_4, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15} -> Fun_12_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12, C13, C14, C15);
                {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15}
            end;
        _ -> {Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, End, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4}
    end
end,
{Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, End_4, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4} = Fun_12(Ciphertext, Codes_4, CombinedKey_2, Current_4, Decrypted_2, DedupKey_6, End, I_6, Idx_2, Inv_2, J_4, K_4, Key_2, M_2, Morse_7, Start_4),
        string:substr(Decrypted_2, Start_4 + 1, (End_4 - Start_4))
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('MORSE_CODE_DICT', #{"A" => ".-", "B" => "-...", "C" => "-.-.", "D" => "-..", "E" => ".", "F" => "..-.", "G" => "--.", "H" => "....", "I" => "..", "J" => ".---", "K" => "-.-", "L" => ".-..", "M" => "--", "N" => "-.", "O" => "---", "P" => ".--.", "Q" => "--.-", "R" => ".-.", "S" => "...", "T" => "-", "U" => "..-", "V" => "...-", "W" => ".--", "X" => "-..-", "Y" => "-.--", "Z" => "--..", " " => ""}),
    erlang:put('MORSE_COMBINATIONS', ["...", "..-", "..x", ".-.", ".--", ".-x", ".x.", ".x-", ".xx", "-..", "-.-", "-.x", "--.", "---", "--x", "-x.", "-x-", "-xx", "x..", "x.-", "x.x", "x-.", "x--", "x-x", "xx.", "xx-", "xxx"]),
    erlang:put('REVERSE_DICT', #{".-" => "A", "-..." => "B", "-.-." => "C", "-.." => "D", "." => "E", "..-." => "F", "--." => "G", "...." => "H", ".." => "I", ".---" => "J", "-.-" => "K", ".-.." => "L", "--" => "M", "-." => "N", "---" => "O", ".--." => "P", "--.-" => "Q", ".-." => "R", "..." => "S", "-" => "T", "..-" => "U", "...-" => "V", ".--" => "W", "-..-" => "X", "-.--" => "Y", "--.." => "Z", "" => " "}),
    erlang:put('plaintext', "defend the east"),
    io:format("~ts ~ts~n", [mochi_repr("Plain Text:"), mochi_repr("defend the east")]),
    erlang:put('key', "ROUNDTABLE"),
    erlang:put('ciphertext', encryptfractionatedmorse("defend the east", "ROUNDTABLE")),
    io:format("~ts ~ts~n", [mochi_repr("Encrypted:"), mochi_repr(erlang:get('ciphertext'))]),
    erlang:put('decrypted', decryptfractionatedmorse(erlang:get('ciphertext'), "ROUNDTABLE")),
    io:format("~ts ~ts~n", [mochi_repr("Decrypted:"), mochi_repr(erlang:get('decrypted'))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
