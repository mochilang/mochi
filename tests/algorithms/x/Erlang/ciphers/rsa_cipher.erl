#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pow_int/2, mod_pow/3, ord/1, chr/1, get_blocks_from_text/2, get_text_from_blocks/3, encrypt_message/4, decrypt_message/5, main/0]).

% Generated by Mochi transpiler v0.10.63 (26477f70ed) on 2025-08-09 23:14 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false ->
                    case os:getenv("MOCHI_BENCHMARK") of
                        false -> erlang:system_time(nanosecond);
                        _ ->
                            erlang:put(now_seed, 1),
                            mochi_now()
                    end;
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_nth/2}).
mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

pow_int(Base, Exp) ->
    try
        Result = 1,
        I = 0,
        Fun = fun Fun_loop(Base, Exp, I, Result) ->
    case (I < Exp) of
        true ->
            Result_2 = (Result * Base),
            I_2 = (I + 1),
            Fun_loop(Base, Exp, I_2, Result_2);
        _ -> {Base, Exp, I, Result}
    end
end,
{Base, Exp, I_2, Result_2} = Fun(Base, Exp, I, Result),
        Result_2
    catch {return, RetCatch} -> RetCatch end.

mod_pow(Base_2, Exponent, Modulus) ->
    try
        Result_3 = 1,
        B = mochi_mod(Base_2, Modulus),
        E = Exponent,
        Fun_2 = fun Fun_2_loop(B, Base_2, E, Exponent, Modulus, Result_3) ->
    case (E > 0) of
        true ->
            case (mochi_mod(E, 2) == 1) of
        true -> Result_4 = mochi_mod((Result_3 * B), Modulus),
            Result_5 = Result_4;
        _ -> Result_5 = Result_3
    end,
            E_2 = (E div 2),
            B_2 = mochi_mod((B * B), Modulus),
            Fun_2_loop(B_2, Base_2, E_2, Exponent, Modulus, Result_5);
        _ -> {B, Base_2, E, Exponent, Modulus, Result_3}
    end
end,
{B_2, Base_2, E_2, Exponent, Modulus, Result_5} = Fun_2(B, Base_2, E, Exponent, Modulus, Result_3),
        Result_5
    catch {return, RetCatch} -> RetCatch end.

ord(Ch) ->
    try
        case (Ch == " ") of
        true -> throw({return, 32});
        _ -> ok
    end,
        case (Ch == "a") of
        true -> throw({return, 97});
        _ -> ok
    end,
        case (Ch == "b") of
        true -> throw({return, 98});
        _ -> ok
    end,
        case (Ch == "c") of
        true -> throw({return, 99});
        _ -> ok
    end,
        case (Ch == "d") of
        true -> throw({return, 100});
        _ -> ok
    end,
        case (Ch == "e") of
        true -> throw({return, 101});
        _ -> ok
    end,
        case (Ch == "f") of
        true -> throw({return, 102});
        _ -> ok
    end,
        case (Ch == "g") of
        true -> throw({return, 103});
        _ -> ok
    end,
        case (Ch == "h") of
        true -> throw({return, 104});
        _ -> ok
    end,
        case (Ch == "i") of
        true -> throw({return, 105});
        _ -> ok
    end,
        case (Ch == "j") of
        true -> throw({return, 106});
        _ -> ok
    end,
        case (Ch == "k") of
        true -> throw({return, 107});
        _ -> ok
    end,
        case (Ch == "l") of
        true -> throw({return, 108});
        _ -> ok
    end,
        case (Ch == "m") of
        true -> throw({return, 109});
        _ -> ok
    end,
        case (Ch == "n") of
        true -> throw({return, 110});
        _ -> ok
    end,
        case (Ch == "o") of
        true -> throw({return, 111});
        _ -> ok
    end,
        case (Ch == "p") of
        true -> throw({return, 112});
        _ -> ok
    end,
        case (Ch == "q") of
        true -> throw({return, 113});
        _ -> ok
    end,
        case (Ch == "r") of
        true -> throw({return, 114});
        _ -> ok
    end,
        case (Ch == "s") of
        true -> throw({return, 115});
        _ -> ok
    end,
        case (Ch == "t") of
        true -> throw({return, 116});
        _ -> ok
    end,
        case (Ch == "u") of
        true -> throw({return, 117});
        _ -> ok
    end,
        case (Ch == "v") of
        true -> throw({return, 118});
        _ -> ok
    end,
        case (Ch == "w") of
        true -> throw({return, 119});
        _ -> ok
    end,
        case (Ch == "x") of
        true -> throw({return, 120});
        _ -> ok
    end,
        case (Ch == "y") of
        true -> throw({return, 121});
        _ -> ok
    end,
        case (Ch == "z") of
        true -> throw({return, 122});
        _ -> ok
    end,
        0
    catch {return, RetCatch} -> RetCatch end.

chr(Code) ->
    try
        case (Code == 32) of
        true -> throw({return, " "});
        _ -> ok
    end,
        case (Code == 97) of
        true -> throw({return, "a"});
        _ -> ok
    end,
        case (Code == 98) of
        true -> throw({return, "b"});
        _ -> ok
    end,
        case (Code == 99) of
        true -> throw({return, "c"});
        _ -> ok
    end,
        case (Code == 100) of
        true -> throw({return, "d"});
        _ -> ok
    end,
        case (Code == 101) of
        true -> throw({return, "e"});
        _ -> ok
    end,
        case (Code == 102) of
        true -> throw({return, "f"});
        _ -> ok
    end,
        case (Code == 103) of
        true -> throw({return, "g"});
        _ -> ok
    end,
        case (Code == 104) of
        true -> throw({return, "h"});
        _ -> ok
    end,
        case (Code == 105) of
        true -> throw({return, "i"});
        _ -> ok
    end,
        case (Code == 106) of
        true -> throw({return, "j"});
        _ -> ok
    end,
        case (Code == 107) of
        true -> throw({return, "k"});
        _ -> ok
    end,
        case (Code == 108) of
        true -> throw({return, "l"});
        _ -> ok
    end,
        case (Code == 109) of
        true -> throw({return, "m"});
        _ -> ok
    end,
        case (Code == 110) of
        true -> throw({return, "n"});
        _ -> ok
    end,
        case (Code == 111) of
        true -> throw({return, "o"});
        _ -> ok
    end,
        case (Code == 112) of
        true -> throw({return, "p"});
        _ -> ok
    end,
        case (Code == 113) of
        true -> throw({return, "q"});
        _ -> ok
    end,
        case (Code == 114) of
        true -> throw({return, "r"});
        _ -> ok
    end,
        case (Code == 115) of
        true -> throw({return, "s"});
        _ -> ok
    end,
        case (Code == 116) of
        true -> throw({return, "t"});
        _ -> ok
    end,
        case (Code == 117) of
        true -> throw({return, "u"});
        _ -> ok
    end,
        case (Code == 118) of
        true -> throw({return, "v"});
        _ -> ok
    end,
        case (Code == 119) of
        true -> throw({return, "w"});
        _ -> ok
    end,
        case (Code == 120) of
        true -> throw({return, "x"});
        _ -> ok
    end,
        case (Code == 121) of
        true -> throw({return, "y"});
        _ -> ok
    end,
        case (Code == 122) of
        true -> throw({return, "z"});
        _ -> ok
    end,
        ""
    catch {return, RetCatch} -> RetCatch end.

get_blocks_from_text(Message, Block_size) ->
    try
        Block_ints = [],
        Block_start = 0,
        Fun_4 = fun Fun_4_loop(Block_ints, Block_size, Block_start, Message) ->
    case (Block_start < erlang:length(Message)) of
        true ->
            Block_int = 0,
            I_3 = Block_start,
            Fun_3 = fun Fun_3_loop(Block_int, Block_ints, Block_size, Block_start, I_3, Message) ->
    case ((I_3 < (Block_start + Block_size)) andalso (I_3 < erlang:length(Message))) of
        true ->
            Block_int_2 = (Block_int + (ord(string:substr(Message, I_3 + 1, 1)) * pow_int(256, (I_3 - Block_start)))),
            I_4 = (I_3 + 1),
            Fun_3_loop(Block_int_2, Block_ints, Block_size, Block_start, I_4, Message);
        _ -> {Block_int, Block_ints, Block_size, Block_start, I_3, Message}
    end
end,
{Block_int_2, Block_ints, Block_size, Block_start, I_4, Message} = Fun_3(Block_int, Block_ints, Block_size, Block_start, I_3, Message),
            Block_ints_2 = lists:append((case Block_ints of nil -> []; _ -> Block_ints end), [Block_int_2]),
            Block_start_2 = (Block_start + Block_size),
            Fun_4_loop(Block_ints_2, Block_size, Block_start_2, Message);
        _ -> {Block_ints, Block_size, Block_start, Message}
    end
end,
{Block_ints_2, Block_size, Block_start_2, Message} = Fun_4(Block_ints, Block_size, Block_start, Message),
        Block_ints_2
    catch {return, RetCatch} -> RetCatch end.

get_text_from_blocks(Block_ints_3, Message_length, Block_size_2) ->
    try
        Message_2 = "",
        Fun_5 = fun Fun_5_loop(List, Block_ints_3, Block_size_2, Message_2, Message_length) ->
    case List of
        [] -> {Block_ints_3, Block_size_2, Message_2, Message_length};
        [Block_int_3|Block_int_3_rest] ->
            Block = Block_int_3,
            I_5 = (Block_size_2 - 1),
            Block_message = "",
            Fun_6 = fun Fun_6_loop(Block, Block_int_3, Block_ints_3, Block_message, Block_size_2, I_5, Message_2, Message_length) ->
    case (I_5 >= 0) of
        true ->
            case ((erlang:length(Message_2) + I_5) < Message_length) of
        true -> Ascii_number = (Block div pow_int(256, I_5)),
            Block_2 = mochi_mod(Block, pow_int(256, I_5)),
            Block_message_2 = (chr(Ascii_number) ++ Block_message),
            Ascii_number_2 = Ascii_number,
            Block_3 = Block_2,
            Block_message_3 = Block_message_2;
        _ -> Ascii_number_2 = nil,
            Block_3 = Block,
            Block_message_3 = Block_message
    end,
            I_6 = (I_5 - 1),
            Fun_6_loop(Block_3, Block_int_3, Block_ints_3, Block_message_3, Block_size_2, I_6, Message_2, Message_length);
        _ -> {Block, Block_int_3, Block_ints_3, Block_message, Block_size_2, I_5, Message_2, Message_length}
    end
end,
{Block_3, Block_int_3, Block_ints_3, Block_message_3, Block_size_2, I_6, Message_2, Message_length} = Fun_6(Block, Block_int_3, Block_ints_3, Block_message, Block_size_2, I_5, Message_2, Message_length),
            Message_3 = (Message_2 ++ Block_message_3),
            Fun_5_loop(Block_int_3_rest, Block_ints_3, Block_size_2, Message_3, Message_length);
        _ -> {Block_ints_3, Block_size_2, Message_2, Message_length}
    end
end,
{Block_ints_3, Block_size_2, Message_3, Message_length} = Fun_5(Block_ints_3, Block_ints_3, Block_size_2, Message_2, Message_length),
        Message_3
    catch {return, RetCatch} -> RetCatch end.

encrypt_message(Message_4, N, E_3, Block_size_3) ->
    try
        Encrypted = [],
        Blocks = get_blocks_from_text(Message_4, Block_size_3),
        Fun_7 = fun Fun_7_loop(List, Block_size_3, Blocks, E_3, Encrypted, Message_4, N) ->
    case List of
        [] -> {Block_size_3, Blocks, E_3, Encrypted, Message_4, N};
        [Block_4|Block_4_rest] ->
            Encrypted_2 = lists:append((case Encrypted of nil -> []; _ -> Encrypted end), [mod_pow(Block_4, E_3, N)]),
            Fun_7_loop(Block_4_rest, Block_size_3, Blocks, E_3, Encrypted_2, Message_4, N);
        _ -> {Block_size_3, Blocks, E_3, Encrypted, Message_4, N}
    end
end,
{Block_size_3, Blocks, E_3, Encrypted_2, Message_4, N} = Fun_7(Blocks, Block_size_3, Blocks, E_3, Encrypted, Message_4, N),
        Encrypted_2
    catch {return, RetCatch} -> RetCatch end.

decrypt_message(Blocks_2, Message_length_2, N_2, D, Block_size_4) ->
    try
        Decrypted_blocks = [],
        Fun_8 = fun Fun_8_loop(List, Block_size_4, Blocks_2, D, Decrypted_blocks, Message_length_2, N_2) ->
    case List of
        [] -> {Block_size_4, Blocks_2, D, Decrypted_blocks, Message_length_2, N_2};
        [Block_5|Block_5_rest] ->
            Decrypted_blocks_2 = lists:append((case Decrypted_blocks of nil -> []; _ -> Decrypted_blocks end), [mod_pow(Block_5, D, N_2)]),
            Fun_8_loop(Block_5_rest, Block_size_4, Blocks_2, D, Decrypted_blocks_2, Message_length_2, N_2);
        _ -> {Block_size_4, Blocks_2, D, Decrypted_blocks, Message_length_2, N_2}
    end
end,
{Block_size_4, Blocks_2, D, Decrypted_blocks_2, Message_length_2, N_2} = Fun_8(Blocks_2, Block_size_4, Blocks_2, D, Decrypted_blocks, Message_length_2, N_2),
        Message_5 = "",
        Fun_9 = fun Fun_9_loop(List, Block_size_4, Blocks_2, D, Decrypted_blocks_2, Message_5, Message_length_2, N_2) ->
    case List of
        [] -> {Block_size_4, Blocks_2, D, Decrypted_blocks_2, Message_5, Message_length_2, N_2};
        [Num|Num_rest] ->
            Message_6 = (Message_5 ++ chr(Num)),
            Fun_9_loop(Num_rest, Block_size_4, Blocks_2, D, Decrypted_blocks_2, Message_6, Message_length_2, N_2);
        _ -> {Block_size_4, Blocks_2, D, Decrypted_blocks_2, Message_5, Message_length_2, N_2}
    end
end,
{Block_size_4, Blocks_2, D, Decrypted_blocks_2, Message_6, Message_length_2, N_2} = Fun_9(Decrypted_blocks_2, Block_size_4, Blocks_2, D, Decrypted_blocks_2, Message_5, Message_length_2, N_2),
        Message_6
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        Message_7 = "hello world",
        N_3 = 3233,
        E_4 = 17,
        D_2 = 2753,
        Block_size_5 = 1,
        Encrypted_3 = encrypt_message("hello world", 3233, 17, 1),
        io:format("~ts~n", [mochi_str(Encrypted_3)]),
        Decrypted = decrypt_message(Encrypted_3, erlang:length("hello world"), 3233, 2753, 1),
        io:format("~ts~n", [mochi_repr(Decrypted)]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('BYTE_SIZE', 256),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
