#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, make_matrix_bool/3, match_pattern/2, main/0]).

% Generated by Mochi transpiler v0.10.61 (0609bdaff6) on 2025-08-08 20:45 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

make_matrix_bool(Rows, Cols, Init) ->
    try
        Matrix = [],
        Fun = fun Fun_loop(List, Cols, Init, Matrix, Rows) ->
    case List of
        [] -> {Cols, Init, Matrix, Rows};
        [_|__rest] ->
            Row = [],
            Fun_2 = fun Fun_2_loop(List, Cols, Init, Matrix, Row, Rows) ->
    case List of
        [] -> {Cols, Init, Matrix, Row, Rows};
        [_2|_2_rest] ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [Init]),
            Fun_2_loop(_2_rest, Cols, Init, Matrix, Row_2, Rows);
        _ -> {Cols, Init, Matrix, Row, Rows}
    end
end,
{Cols, Init, Matrix, Row_2, Rows} = Fun_2(lists:seq(0, (Cols) - 1), Cols, Init, Matrix, Row, Rows),
            Matrix_2 = lists:append((case Matrix of nil -> []; _ -> Matrix end), [Row_2]),
            Fun_loop(__rest, Cols, Init, Matrix_2, Rows);
        _ -> {Cols, Init, Matrix, Rows}
    end
end,
{Cols, Init, Matrix_2, Rows} = Fun(lists:seq(0, (Rows) - 1), Cols, Init, Matrix, Rows),
        Matrix_2
    catch {return, RetCatch} -> RetCatch end.

match_pattern(Input_string, Pattern) ->
    try
        Len_string = (erlang:length(Input_string) + 1),
        Len_pattern = (erlang:length(Pattern) + 1),
        Dp = make_matrix_bool(Len_string, Len_pattern, false),
        Row0 = (case erlang:is_map(Dp) of true -> maps:get(0, Dp, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Dp) + 0 + 1, Dp); _ -> mochi_nth(0 + 1, Dp) end end),
        Row0_2 = lists:sublist(Row0, 0) ++ [true] ++ lists:nthtail(0 + 1, Row0),
        Dp_2 = lists:sublist(Dp, 0) ++ [Row0_2] ++ lists:nthtail(0 + 1, Dp),
        J = 1,
        Fun_3 = fun Fun_3_loop(Dp_2, Input_string, J, Len_pattern, Len_string, Pattern, Row0_2) ->
    case (J < Len_pattern) of
        true ->
            Row0_3 = (case erlang:is_map(Dp_2) of true -> maps:get(0, Dp_2, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Dp_2) + 0 + 1, Dp_2); _ -> mochi_nth(0 + 1, Dp_2) end end),
            case (string:substr(Pattern, (J - 1) + 1, (J - (J - 1))) == "*") of
        true -> Row0_4 = lists:sublist(Row0_3, J) ++ [(case erlang:is_map(Row0_3) of true -> maps:get((J - 2), Row0_3, nil); _ -> case (J - 2) < 0 of true -> mochi_nth(erlang:length(Row0_3) + (J - 2) + 1, Row0_3); _ -> mochi_nth((J - 2) + 1, Row0_3) end end)] ++ lists:nthtail(J + 1, Row0_3),
            Row0_6 = Row0_4;
        _ -> Row0_5 = lists:sublist(Row0_3, J) ++ [false] ++ lists:nthtail(J + 1, Row0_3),
            Row0_6 = Row0_5
    end,
            Dp_3 = lists:sublist(Dp_2, 0) ++ [Row0_6] ++ lists:nthtail(0 + 1, Dp_2),
            J_2 = (J + 1),
            Fun_3_loop(Dp_3, Input_string, J_2, Len_pattern, Len_string, Pattern, Row0_6);
        _ -> {Dp_2, Input_string, J, Len_pattern, Len_string, Pattern, Row0_2}
    end
end,
{Dp_3, Input_string, J_2, Len_pattern, Len_string, Pattern, Row0_6} = Fun_3(Dp_2, Input_string, J, Len_pattern, Len_string, Pattern, Row0_2),
        I = 1,
        Fun_5 = fun Fun_5_loop(Dp_3, I, Input_string, J_2, Len_pattern, Len_string, Pattern, Row0_6) ->
    case (I < Len_string) of
        true ->
            Row_3 = (case erlang:is_map(Dp_3) of true -> maps:get(I, Dp_3, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Dp_3) + I + 1, Dp_3); _ -> mochi_nth(I + 1, Dp_3) end end),
            J2 = 1,
            Fun_4 = fun Fun_4_loop(Dp_3, I, Input_string, J_2, J2, Len_pattern, Len_string, Pattern, Row_3, Row0_6) ->
    case (J2 < Len_pattern) of
        true ->
            S_char = string:substr(Input_string, (I - 1) + 1, (I - (I - 1))),
            P_char = string:substr(Pattern, (J2 - 1) + 1, (J2 - (J2 - 1))),
            case ((S_char == P_char) orelse (P_char == ".")) of
        true -> Row_4 = lists:sublist(Row_3, J2) ++ [(case erlang:is_map((case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end)) of true -> maps:get((J2 - 1), (case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end), nil); _ -> case (J2 - 1) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end)) + (J2 - 1) + 1, (case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end)); _ -> mochi_nth((J2 - 1) + 1, (case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end)) end end)] ++ lists:nthtail(J2 + 1, Row_3),
            Prev_p_3 = nil,
            Row_8 = Row_4,
            Val_5 = nil;
        _ -> case (P_char == "*") of
        true -> Val = (case erlang:is_map((case erlang:is_map(Dp_3) of true -> maps:get(I, Dp_3, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Dp_3) + I + 1, Dp_3); _ -> mochi_nth(I + 1, Dp_3) end end)) of true -> maps:get((J2 - 2), (case erlang:is_map(Dp_3) of true -> maps:get(I, Dp_3, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Dp_3) + I + 1, Dp_3); _ -> mochi_nth(I + 1, Dp_3) end end), nil); _ -> case (J2 - 2) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Dp_3) of true -> maps:get(I, Dp_3, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Dp_3) + I + 1, Dp_3); _ -> mochi_nth(I + 1, Dp_3) end end)) + (J2 - 2) + 1, (case erlang:is_map(Dp_3) of true -> maps:get(I, Dp_3, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Dp_3) + I + 1, Dp_3); _ -> mochi_nth(I + 1, Dp_3) end end)); _ -> mochi_nth((J2 - 2) + 1, (case erlang:is_map(Dp_3) of true -> maps:get(I, Dp_3, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Dp_3) + I + 1, Dp_3); _ -> mochi_nth(I + 1, Dp_3) end end)) end end),
            Prev_p = string:substr(Pattern, (J2 - 2) + 1, ((J2 - 1) - (J2 - 2))),
            case (mochi_not(Val) andalso ((Prev_p == S_char) orelse (Prev_p == "."))) of
        true -> Val_2 = (case erlang:is_map((case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end)) of true -> maps:get(J2, (case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end), nil); _ -> case J2 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end)) + J2 + 1, (case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end)); _ -> mochi_nth(J2 + 1, (case erlang:is_map(Dp_3) of true -> maps:get((I - 1), Dp_3, nil); _ -> case (I - 1) < 0 of true -> mochi_nth(erlang:length(Dp_3) + (I - 1) + 1, Dp_3); _ -> mochi_nth((I - 1) + 1, Dp_3) end end)) end end),
            Val_3 = Val_2;
        _ -> Val_3 = Val
    end,
            Row_5 = lists:sublist(Row_3, J2) ++ [Val_3] ++ lists:nthtail(J2 + 1, Row_3),
            Prev_p_2 = Prev_p,
            Row_7 = Row_5,
            Val_4 = Val_3;
        _ -> Row_6 = lists:sublist(Row_3, J2) ++ [false] ++ lists:nthtail(J2 + 1, Row_3),
            Prev_p_2 = nil,
            Row_7 = Row_6,
            Val_4 = nil
    end,
            Prev_p_3 = Prev_p_2,
            Row_8 = Row_7,
            Val_5 = Val_4
    end,
            J2_2 = (J2 + 1),
            Fun_4_loop(Dp_3, I, Input_string, J_2, J2_2, Len_pattern, Len_string, Pattern, Row_8, Row0_6);
        _ -> {Dp_3, I, Input_string, J_2, J2, Len_pattern, Len_string, Pattern, Row_3, Row0_6}
    end
end,
{Dp_3, I, Input_string, J_2, J2_2, Len_pattern, Len_string, Pattern, Row_8, Row0_6} = Fun_4(Dp_3, I, Input_string, J_2, J2, Len_pattern, Len_string, Pattern, Row_3, Row0_6),
            Dp_4 = lists:sublist(Dp_3, I) ++ [Row_8] ++ lists:nthtail(I + 1, Dp_3),
            I_2 = (I + 1),
            Fun_5_loop(Dp_4, I_2, Input_string, J_2, Len_pattern, Len_string, Pattern, Row0_6);
        _ -> {Dp_3, I, Input_string, J_2, Len_pattern, Len_string, Pattern, Row0_6}
    end
end,
{Dp_4, I_2, Input_string, J_2, Len_pattern, Len_string, Pattern, Row0_6} = Fun_5(Dp_3, I, Input_string, J_2, Len_pattern, Len_string, Pattern, Row0_6),
        (case erlang:is_map((case erlang:is_map(Dp_4) of true -> maps:get((Len_string - 1), Dp_4, nil); _ -> case (Len_string - 1) < 0 of true -> mochi_nth(erlang:length(Dp_4) + (Len_string - 1) + 1, Dp_4); _ -> mochi_nth((Len_string - 1) + 1, Dp_4) end end)) of true -> maps:get((Len_pattern - 1), (case erlang:is_map(Dp_4) of true -> maps:get((Len_string - 1), Dp_4, nil); _ -> case (Len_string - 1) < 0 of true -> mochi_nth(erlang:length(Dp_4) + (Len_string - 1) + 1, Dp_4); _ -> mochi_nth((Len_string - 1) + 1, Dp_4) end end), nil); _ -> case (Len_pattern - 1) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Dp_4) of true -> maps:get((Len_string - 1), Dp_4, nil); _ -> case (Len_string - 1) < 0 of true -> mochi_nth(erlang:length(Dp_4) + (Len_string - 1) + 1, Dp_4); _ -> mochi_nth((Len_string - 1) + 1, Dp_4) end end)) + (Len_pattern - 1) + 1, (case erlang:is_map(Dp_4) of true -> maps:get((Len_string - 1), Dp_4, nil); _ -> case (Len_string - 1) < 0 of true -> mochi_nth(erlang:length(Dp_4) + (Len_string - 1) + 1, Dp_4); _ -> mochi_nth((Len_string - 1) + 1, Dp_4) end end)); _ -> mochi_nth((Len_pattern - 1) + 1, (case erlang:is_map(Dp_4) of true -> maps:get((Len_string - 1), Dp_4, nil); _ -> case (Len_string - 1) < 0 of true -> mochi_nth(erlang:length(Dp_4) + (Len_string - 1) + 1, Dp_4); _ -> mochi_nth((Len_string - 1) + 1, Dp_4) end end)) end end)
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        case mochi_not(match_pattern("aab", "c*a*b")) of
        true -> erlang:error({panic, "case1 failed"});
        _ -> ok
    end,
        case match_pattern("dabc", "*abc") of
        true -> erlang:error({panic, "case2 failed"});
        _ -> ok
    end,
        case match_pattern("aaa", "aa") of
        true -> erlang:error({panic, "case3 failed"});
        _ -> ok
    end,
        case mochi_not(match_pattern("aaa", "a.a")) of
        true -> erlang:error({panic, "case4 failed"});
        _ -> ok
    end,
        case match_pattern("aaab", "aa*") of
        true -> erlang:error({panic, "case5 failed"});
        _ -> ok
    end,
        case mochi_not(match_pattern("aaab", ".*")) of
        true -> erlang:error({panic, "case6 failed"});
        _ -> ok
    end,
        case match_pattern("a", "bbbb") of
        true -> erlang:error({panic, "case7 failed"});
        _ -> ok
    end,
        case match_pattern("", "bbbb") of
        true -> erlang:error({panic, "case8 failed"});
        _ -> ok
    end,
        case match_pattern("a", "") of
        true -> erlang:error({panic, "case9 failed"});
        _ -> ok
    end,
        case mochi_not(match_pattern("", "")) of
        true -> erlang:error({panic, "case10 failed"});
        _ -> ok
    end,
        io:format("~ts~n", [mochi_str(match_pattern("aab", "c*a*b"))]),
        io:format("~ts~n", [mochi_str(match_pattern("dabc", "*abc"))]),
        io:format("~ts~n", [mochi_str(match_pattern("aaa", "aa"))]),
        io:format("~ts~n", [mochi_str(match_pattern("aaa", "a.a"))]),
        io:format("~ts~n", [mochi_str(match_pattern("aaab", "aa*"))]),
        io:format("~ts~n", [mochi_str(match_pattern("aaab", ".*"))]),
        io:format("~ts~n", [mochi_str(match_pattern("a", "bbbb"))]),
        io:format("~ts~n", [mochi_str(match_pattern("", "bbbb"))]),
        io:format("~ts~n", [mochi_str(match_pattern("a", ""))]),
        io:format("~ts~n", [mochi_str(match_pattern("", ""))]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
