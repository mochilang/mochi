#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, repeat_str/2, split_words/1, justify_line/3, text_justification/2]).

% Generated by Mochi transpiler v0.10.61 (0609bdaff6) on 2025-08-08 20:45 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

repeat_str(S, Count) ->
    try
        Res = "",
        I = 0,
        Fun = fun Fun_loop(Count, I, Res, S) ->
    case (I < Count) of
        true ->
            Res_2 = (Res ++ S),
            I_2 = (I + 1),
            Fun_loop(Count, I_2, Res_2, S);
        _ -> {Count, I, Res, S}
    end
end,
{Count, I_2, Res_2, S} = Fun(Count, I, Res, S),
        Res_2
    catch {return, RetCatch} -> RetCatch end.

split_words(S_2) ->
    try
        Res_3 = [],
        Current = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Current, I_3, Res_3, S_2) ->
    case (I_3 < erlang:length(S_2)) of
        true ->
            Ch = string:substr(S_2, I_3 + 1, ((I_3 + 1) - I_3)),
            case (Ch == " ") of
        true -> case (Current /= "") of
        true -> Res_4 = lists:append((case Res_3 of nil -> []; _ -> Res_3 end), [Current]),
            Current_2 = "",
            Current_3 = Current_2,
            Res_5 = Res_4;
        _ -> Current_3 = Current,
            Res_5 = Res_3
    end,
            Current_5 = Current_3,
            Res_6 = Res_5;
        _ -> Current_4 = (Current ++ Ch),
            Current_5 = Current_4,
            Res_6 = Res_3
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Current_5, I_4, Res_6, S_2);
        _ -> {Current, I_3, Res_3, S_2}
    end
end,
{Current_5, I_4, Res_6, S_2} = Fun_2(Current, I_3, Res_3, S_2),
        case (Current_5 /= "") of
        true -> Res_7 = lists:append((case Res_6 of nil -> []; _ -> Res_6 end), [Current_5]),
            Res_8 = Res_7;
        _ -> Res_8 = Res_6
    end,
        Res_8
    catch {return, RetCatch} -> RetCatch end.

justify_line(Line, Width, Max_width) ->
    try
        Overall_spaces_count = (Max_width - Width),
        Words_count = erlang:length(Line),
        case (Words_count == 1) of
        true -> throw({return, ((case erlang:is_map(Line) of true -> maps:get(0, Line, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Line) + 0 + 1, Line); _ -> mochi_nth(0 + 1, Line) end end) ++ repeat_str(" ", Overall_spaces_count))});
        _ -> ok
    end,
        Spaces_to_insert_between_words = (Words_count - 1),
        Num_spaces_between_words_list = [],
        Base = (Overall_spaces_count div Spaces_to_insert_between_words),
        Extra = mochi_mod(Overall_spaces_count, Spaces_to_insert_between_words),
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Base, Extra, I_5, Line, Max_width, Num_spaces_between_words_list, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count) ->
    case (I_5 < Spaces_to_insert_between_words) of
        true ->
            Spaces = Base,
            case (I_5 < Extra) of
        true -> Spaces_2 = (Spaces + 1),
            Spaces_3 = Spaces_2;
        _ -> Spaces_3 = Spaces
    end,
            Num_spaces_between_words_list_2 = lists:append((case Num_spaces_between_words_list of nil -> []; _ -> Num_spaces_between_words_list end), [Spaces_3]),
            I_6 = (I_5 + 1),
            Fun_3_loop(Base, Extra, I_6, Line, Max_width, Num_spaces_between_words_list_2, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count);
        _ -> {Base, Extra, I_5, Line, Max_width, Num_spaces_between_words_list, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count}
    end
end,
{Base, Extra, I_6, Line, Max_width, Num_spaces_between_words_list_2, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count} = Fun_3(Base, Extra, I_5, Line, Max_width, Num_spaces_between_words_list, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count),
        Aligned = "",
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(Aligned, Base, Extra, I_7, Line, Max_width, Num_spaces_between_words_list_2, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count) ->
    case (I_7 < Spaces_to_insert_between_words) of
        true ->
            Aligned_2 = ((Aligned ++ (case erlang:is_map(Line) of true -> maps:get(I_7, Line, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Line) + I_7 + 1, Line); _ -> mochi_nth(I_7 + 1, Line) end end)) ++ repeat_str(" ", (case erlang:is_map(Num_spaces_between_words_list_2) of true -> maps:get(I_7, Num_spaces_between_words_list_2, nil); _ -> case I_7 < 0 of true -> mochi_nth(erlang:length(Num_spaces_between_words_list_2) + I_7 + 1, Num_spaces_between_words_list_2); _ -> mochi_nth(I_7 + 1, Num_spaces_between_words_list_2) end end))),
            I_8 = (I_7 + 1),
            Fun_4_loop(Aligned_2, Base, Extra, I_8, Line, Max_width, Num_spaces_between_words_list_2, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count);
        _ -> {Aligned, Base, Extra, I_7, Line, Max_width, Num_spaces_between_words_list_2, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count}
    end
end,
{Aligned_2, Base, Extra, I_8, Line, Max_width, Num_spaces_between_words_list_2, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count} = Fun_4(Aligned, Base, Extra, I_7, Line, Max_width, Num_spaces_between_words_list_2, Overall_spaces_count, Spaces_to_insert_between_words, Width, Words_count),
        Aligned_3 = (Aligned_2 ++ (case erlang:is_map(Line) of true -> maps:get(Spaces_to_insert_between_words, Line, nil); _ -> case Spaces_to_insert_between_words < 0 of true -> mochi_nth(erlang:length(Line) + Spaces_to_insert_between_words + 1, Line); _ -> mochi_nth(Spaces_to_insert_between_words + 1, Line) end end)),
        Aligned_3
    catch {return, RetCatch} -> RetCatch end.

text_justification(Word, Max_width_2) ->
    try
        Words = split_words(Word),
        Answer = [],
        Line_2 = [],
        Width_2 = 0,
        Idx = 0,
        Fun_5 = fun Fun_5_loop(Answer, Idx, Line_2, Max_width_2, Width_2, Word, Words) ->
    case (Idx < erlang:length(Words)) of
        true ->
            W = (case erlang:is_map(Words) of true -> maps:get(Idx, Words, nil); _ -> case Idx < 0 of true -> mochi_nth(erlang:length(Words) + Idx + 1, Words); _ -> mochi_nth(Idx + 1, Words) end end),
            case (((Width_2 + erlang:length(W)) + erlang:length(Line_2)) =< Max_width_2) of
        true -> Line_3 = lists:append((case Line_2 of nil -> []; _ -> Line_2 end), [W]),
            Width_3 = (Width_2 + erlang:length(W)),
            Answer_3 = Answer,
            Line_5 = Line_3,
            Width_5 = Width_3;
        _ -> Answer_2 = lists:append((case Answer of nil -> []; _ -> Answer end), [justify_line(Line_2, Width_2, Max_width_2)]),
            Line_4 = [W],
            Width_4 = erlang:length(W),
            Answer_3 = Answer_2,
            Line_5 = Line_4,
            Width_5 = Width_4
    end,
            Idx_2 = (Idx + 1),
            Fun_5_loop(Answer_3, Idx_2, Line_5, Max_width_2, Width_5, Word, Words);
        _ -> {Answer, Idx, Line_2, Max_width_2, Width_2, Word, Words}
    end
end,
{Answer_3, Idx_2, Line_5, Max_width_2, Width_5, Word, Words} = Fun_5(Answer, Idx, Line_2, Max_width_2, Width_2, Word, Words),
        Remaining_spaces = ((Max_width_2 - Width_5) - erlang:length(Line_5)),
        Last_line = "",
        J = 0,
        Fun_6 = fun Fun_6_loop(Answer_3, Idx_2, J, Last_line, Line_5, Max_width_2, Remaining_spaces, Width_5, Word, Words) ->
    case (J < erlang:length(Line_5)) of
        true ->
            case (J > 0) of
        true -> Last_line_2 = (Last_line ++ " "),
            Last_line_3 = Last_line_2;
        _ -> Last_line_3 = Last_line
    end,
            Last_line_4 = (Last_line_3 ++ (case erlang:is_map(Line_5) of true -> maps:get(J, Line_5, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Line_5) + J + 1, Line_5); _ -> mochi_nth(J + 1, Line_5) end end)),
            J_2 = (J + 1),
            Fun_6_loop(Answer_3, Idx_2, J_2, Last_line_4, Line_5, Max_width_2, Remaining_spaces, Width_5, Word, Words);
        _ -> {Answer_3, Idx_2, J, Last_line, Line_5, Max_width_2, Remaining_spaces, Width_5, Word, Words}
    end
end,
{Answer_3, Idx_2, J_2, Last_line_4, Line_5, Max_width_2, Remaining_spaces, Width_5, Word, Words} = Fun_6(Answer_3, Idx_2, J, Last_line, Line_5, Max_width_2, Remaining_spaces, Width_5, Word, Words),
        Last_line_5 = (Last_line_4 ++ repeat_str(" ", (Remaining_spaces + 1))),
        Answer_4 = lists:append((case Answer_3 of nil -> []; _ -> Answer_3 end), [Last_line_5]),
        Answer_4
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    io:format("~ts~n", [mochi_str(text_justification("This is an example of text justification.", 16))]),
    io:format("~ts~n", [mochi_str(text_justification("Two roads diverged in a yellow wood", 16))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
