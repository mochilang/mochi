#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, string_to_chars/1, join_chars/1, insert_at/3, remove_at/2, make_matrix_int/3, make_matrix_string/3, compute_transform_tables/6, assemble_transformation/3, main/0]).

% Generated by Mochi transpiler v0.10.61 (0609bdaff6) on 2025-08-08 20:45 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

string_to_chars(S) ->
    try
        Chars = [],
        I = 0,
        Fun = fun Fun_loop(Chars, I, S) ->
    case (I < erlang:length(S)) of
        true ->
            Chars_2 = lists:append((case Chars of nil -> []; _ -> Chars end), [string:substr(S, I + 1, ((I + 1) - I))]),
            I_2 = (I + 1),
            Fun_loop(Chars_2, I_2, S);
        _ -> {Chars, I, S}
    end
end,
{Chars_2, I_2, S} = Fun(Chars, I, S),
        Chars_2
    catch {return, RetCatch} -> RetCatch end.

join_chars(Chars_3) ->
    try
        Res = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Chars_3, I_3, Res) ->
    case (I_3 < erlang:length(Chars_3)) of
        true ->
            Res_2 = (Res ++ (case erlang:is_map(Chars_3) of true -> maps:get(I_3, Chars_3, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Chars_3) + I_3 + 1, Chars_3); _ -> mochi_nth(I_3 + 1, Chars_3) end end)),
            I_4 = (I_3 + 1),
            Fun_2_loop(Chars_3, I_4, Res_2);
        _ -> {Chars_3, I_3, Res}
    end
end,
{Chars_3, I_4, Res_2} = Fun_2(Chars_3, I_3, Res),
        Res_2
    catch {return, RetCatch} -> RetCatch end.

insert_at(Chars_4, Index, Ch) ->
    try
        Res_3 = [],
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Ch, Chars_4, I_5, Index, Res_3) ->
    case (I_5 < Index) of
        true ->
            Res_4 = lists:append((case Res_3 of nil -> []; _ -> Res_3 end), [(case erlang:is_map(Chars_4) of true -> maps:get(I_5, Chars_4, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Chars_4) + I_5 + 1, Chars_4); _ -> mochi_nth(I_5 + 1, Chars_4) end end)]),
            I_6 = (I_5 + 1),
            Fun_3_loop(Ch, Chars_4, I_6, Index, Res_4);
        _ -> {Ch, Chars_4, I_5, Index, Res_3}
    end
end,
{Ch, Chars_4, I_6, Index, Res_4} = Fun_3(Ch, Chars_4, I_5, Index, Res_3),
        Res_5 = lists:append((case Res_4 of nil -> []; _ -> Res_4 end), [Ch]),
        Fun_4 = fun Fun_4_loop(Ch, Chars_4, I_6, Index, Res_5) ->
    case (I_6 < erlang:length(Chars_4)) of
        true ->
            Res_6 = lists:append((case Res_5 of nil -> []; _ -> Res_5 end), [(case erlang:is_map(Chars_4) of true -> maps:get(I_6, Chars_4, nil); _ -> case I_6 < 0 of true -> mochi_nth(erlang:length(Chars_4) + I_6 + 1, Chars_4); _ -> mochi_nth(I_6 + 1, Chars_4) end end)]),
            I_7 = (I_6 + 1),
            Fun_4_loop(Ch, Chars_4, I_7, Index, Res_6);
        _ -> {Ch, Chars_4, I_6, Index, Res_5}
    end
end,
{Ch, Chars_4, I_7, Index, Res_6} = Fun_4(Ch, Chars_4, I_6, Index, Res_5),
        Res_6
    catch {return, RetCatch} -> RetCatch end.

remove_at(Chars_5, Index_2) ->
    try
        Res_7 = [],
        I_8 = 0,
        Fun_5 = fun Fun_5_loop(Chars_5, I_8, Index_2, Res_7) ->
    case (I_8 < erlang:length(Chars_5)) of
        true ->
            case (I_8 /= Index_2) of
        true -> Res_8 = lists:append((case Res_7 of nil -> []; _ -> Res_7 end), [(case erlang:is_map(Chars_5) of true -> maps:get(I_8, Chars_5, nil); _ -> case I_8 < 0 of true -> mochi_nth(erlang:length(Chars_5) + I_8 + 1, Chars_5); _ -> mochi_nth(I_8 + 1, Chars_5) end end)]),
            Res_9 = Res_8;
        _ -> Res_9 = Res_7
    end,
            I_9 = (I_8 + 1),
            Fun_5_loop(Chars_5, I_9, Index_2, Res_9);
        _ -> {Chars_5, I_8, Index_2, Res_7}
    end
end,
{Chars_5, I_9, Index_2, Res_9} = Fun_5(Chars_5, I_8, Index_2, Res_7),
        Res_9
    catch {return, RetCatch} -> RetCatch end.

make_matrix_int(Rows, Cols, Init) ->
    try
        Matrix = [],
        Fun_6 = fun Fun_6_loop(List, Cols, Init, Matrix, Rows) ->
    case List of
        [] -> {Cols, Init, Matrix, Rows};
        [_|__rest] ->
            Row = [],
            Fun_7 = fun Fun_7_loop(List, Cols, Init, Matrix, Row, Rows) ->
    case List of
        [] -> {Cols, Init, Matrix, Row, Rows};
        [_2|_2_rest] ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [Init]),
            Fun_7_loop(_2_rest, Cols, Init, Matrix, Row_2, Rows);
        _ -> {Cols, Init, Matrix, Row, Rows}
    end
end,
{Cols, Init, Matrix, Row_2, Rows} = Fun_7(lists:seq(0, (Cols) - 1), Cols, Init, Matrix, Row, Rows),
            Matrix_2 = lists:append((case Matrix of nil -> []; _ -> Matrix end), [Row_2]),
            Fun_6_loop(__rest, Cols, Init, Matrix_2, Rows);
        _ -> {Cols, Init, Matrix, Rows}
    end
end,
{Cols, Init, Matrix_2, Rows} = Fun_6(lists:seq(0, (Rows) - 1), Cols, Init, Matrix, Rows),
        Matrix_2
    catch {return, RetCatch} -> RetCatch end.

make_matrix_string(Rows_2, Cols_2, Init_2) ->
    try
        Matrix_3 = [],
        Fun_8 = fun Fun_8_loop(List, Cols_2, Init_2, Matrix_3, Rows_2) ->
    case List of
        [] -> {Cols_2, Init_2, Matrix_3, Rows_2};
        [_|__rest] ->
            Row_3 = [],
            Fun_9 = fun Fun_9_loop(List, Cols_2, Init_2, Matrix_3, Row_3, Rows_2) ->
    case List of
        [] -> {Cols_2, Init_2, Matrix_3, Row_3, Rows_2};
        [_2_2|_2_2_rest] ->
            Row_4 = lists:append((case Row_3 of nil -> []; _ -> Row_3 end), [Init_2]),
            Fun_9_loop(_2_2_rest, Cols_2, Init_2, Matrix_3, Row_4, Rows_2);
        _ -> {Cols_2, Init_2, Matrix_3, Row_3, Rows_2}
    end
end,
{Cols_2, Init_2, Matrix_3, Row_4, Rows_2} = Fun_9(lists:seq(0, (Cols_2) - 1), Cols_2, Init_2, Matrix_3, Row_3, Rows_2),
            Matrix_4 = lists:append((case Matrix_3 of nil -> []; _ -> Matrix_3 end), [Row_4]),
            Fun_8_loop(__rest, Cols_2, Init_2, Matrix_4, Rows_2);
        _ -> {Cols_2, Init_2, Matrix_3, Rows_2}
    end
end,
{Cols_2, Init_2, Matrix_4, Rows_2} = Fun_8(lists:seq(0, (Rows_2) - 1), Cols_2, Init_2, Matrix_3, Rows_2),
        Matrix_4
    catch {return, RetCatch} -> RetCatch end.

compute_transform_tables(Source_string, Destination_string, Copy_cost, Replace_cost, Delete_cost, Insert_cost) ->
    try
        Source_seq = string_to_chars(Source_string),
        Dest_seq = string_to_chars(Destination_string),
        M = erlang:length(Source_seq),
        N = erlang:length(Dest_seq),
        Costs = make_matrix_int((M + 1), (N + 1), 0),
        Ops = make_matrix_string((M + 1), (N + 1), "0"),
        I_10 = 1,
        Fun_10 = fun Fun_10_loop(Copy_cost, Costs, Delete_cost, Dest_seq, Destination_string, I_10, Insert_cost, M, N, Ops, Replace_cost, Source_seq, Source_string) ->
    case (I_10 =< M) of
        true ->
            Costs_2 = lists:sublist(Costs, I_10) ++ [lists:sublist(lists:nth(I_10 + 1, Costs), 0) ++ [(I_10 * Delete_cost)] ++ lists:nthtail(0 + 1, lists:nth(I_10 + 1, Costs))] ++ lists:nthtail(I_10 + 1, Costs),
            Ops_2 = lists:sublist(Ops, I_10) ++ [lists:sublist(lists:nth(I_10 + 1, Ops), 0) ++ [("D" ++ (case erlang:is_map(Source_seq) of true -> maps:get((I_10 - 1), Source_seq, nil); _ -> case (I_10 - 1) < 0 of true -> mochi_nth(erlang:length(Source_seq) + (I_10 - 1) + 1, Source_seq); _ -> mochi_nth((I_10 - 1) + 1, Source_seq) end end))] ++ lists:nthtail(0 + 1, lists:nth(I_10 + 1, Ops))] ++ lists:nthtail(I_10 + 1, Ops),
            I_11 = (I_10 + 1),
            Fun_10_loop(Copy_cost, Costs_2, Delete_cost, Dest_seq, Destination_string, I_11, Insert_cost, M, N, Ops_2, Replace_cost, Source_seq, Source_string);
        _ -> {Copy_cost, Costs, Delete_cost, Dest_seq, Destination_string, I_10, Insert_cost, M, N, Ops, Replace_cost, Source_seq, Source_string}
    end
end,
{Copy_cost, Costs_2, Delete_cost, Dest_seq, Destination_string, I_11, Insert_cost, M, N, Ops_2, Replace_cost, Source_seq, Source_string} = Fun_10(Copy_cost, Costs, Delete_cost, Dest_seq, Destination_string, I_10, Insert_cost, M, N, Ops, Replace_cost, Source_seq, Source_string),
        J = 1,
        Fun_11 = fun Fun_11_loop(Copy_cost, Costs_2, Delete_cost, Dest_seq, Destination_string, I_11, Insert_cost, J, M, N, Ops_2, Replace_cost, Source_seq, Source_string) ->
    case (J =< N) of
        true ->
            Costs_3 = lists:sublist(Costs_2, 0) ++ [lists:sublist(lists:nth(0 + 1, Costs_2), J) ++ [(J * Insert_cost)] ++ lists:nthtail(J + 1, lists:nth(0 + 1, Costs_2))] ++ lists:nthtail(0 + 1, Costs_2),
            Ops_3 = lists:sublist(Ops_2, 0) ++ [lists:sublist(lists:nth(0 + 1, Ops_2), J) ++ [("I" ++ (case erlang:is_map(Dest_seq) of true -> maps:get((J - 1), Dest_seq, nil); _ -> case (J - 1) < 0 of true -> mochi_nth(erlang:length(Dest_seq) + (J - 1) + 1, Dest_seq); _ -> mochi_nth((J - 1) + 1, Dest_seq) end end))] ++ lists:nthtail(J + 1, lists:nth(0 + 1, Ops_2))] ++ lists:nthtail(0 + 1, Ops_2),
            J_2 = (J + 1),
            Fun_11_loop(Copy_cost, Costs_3, Delete_cost, Dest_seq, Destination_string, I_11, Insert_cost, J_2, M, N, Ops_3, Replace_cost, Source_seq, Source_string);
        _ -> {Copy_cost, Costs_2, Delete_cost, Dest_seq, Destination_string, I_11, Insert_cost, J, M, N, Ops_2, Replace_cost, Source_seq, Source_string}
    end
end,
{Copy_cost, Costs_3, Delete_cost, Dest_seq, Destination_string, I_11, Insert_cost, J_2, M, N, Ops_3, Replace_cost, Source_seq, Source_string} = Fun_11(Copy_cost, Costs_2, Delete_cost, Dest_seq, Destination_string, I_11, Insert_cost, J, M, N, Ops_2, Replace_cost, Source_seq, Source_string),
        I_12 = 1,
        Fun_13 = fun Fun_13_loop(Copy_cost, Costs_3, Delete_cost, Dest_seq, Destination_string, I_12, Insert_cost, J_2, M, N, Ops_3, Replace_cost, Source_seq, Source_string) ->
    case (I_12 =< M) of
        true ->
            J_3 = 1,
            Fun_12 = fun Fun_12_loop(Copy_cost, Costs_3, Delete_cost, Dest_seq, Destination_string, I_12, Insert_cost, J_3, M, N, Ops_3, Replace_cost, Source_seq, Source_string) ->
    case (J_3 =< N) of
        true ->
            case ((case erlang:is_map(Source_seq) of true -> maps:get((I_12 - 1), Source_seq, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Source_seq) + (I_12 - 1) + 1, Source_seq); _ -> mochi_nth((I_12 - 1) + 1, Source_seq) end end) == (case erlang:is_map(Dest_seq) of true -> maps:get((J_3 - 1), Dest_seq, nil); _ -> case (J_3 - 1) < 0 of true -> mochi_nth(erlang:length(Dest_seq) + (J_3 - 1) + 1, Dest_seq); _ -> mochi_nth((J_3 - 1) + 1, Dest_seq) end end)) of
        true -> Costs_4 = lists:sublist(Costs_3, I_12) ++ [lists:sublist(lists:nth(I_12 + 1, Costs_3), J_3) ++ [((case erlang:is_map((case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end)) of true -> maps:get((J_3 - 1), (case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end), nil); _ -> case (J_3 - 1) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end)) + (J_3 - 1) + 1, (case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end)); _ -> mochi_nth((J_3 - 1) + 1, (case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end)) end end) + Copy_cost)] ++ lists:nthtail(J_3 + 1, lists:nth(I_12 + 1, Costs_3))] ++ lists:nthtail(I_12 + 1, Costs_3),
            Ops_4 = lists:sublist(Ops_3, I_12) ++ [lists:sublist(lists:nth(I_12 + 1, Ops_3), J_3) ++ [("C" ++ (case erlang:is_map(Source_seq) of true -> maps:get((I_12 - 1), Source_seq, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Source_seq) + (I_12 - 1) + 1, Source_seq); _ -> mochi_nth((I_12 - 1) + 1, Source_seq) end end))] ++ lists:nthtail(J_3 + 1, lists:nth(I_12 + 1, Ops_3))] ++ lists:nthtail(I_12 + 1, Ops_3),
            Costs_6 = Costs_4,
            Ops_6 = Ops_4;
        _ -> Costs_5 = lists:sublist(Costs_3, I_12) ++ [lists:sublist(lists:nth(I_12 + 1, Costs_3), J_3) ++ [((case erlang:is_map((case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end)) of true -> maps:get((J_3 - 1), (case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end), nil); _ -> case (J_3 - 1) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end)) + (J_3 - 1) + 1, (case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end)); _ -> mochi_nth((J_3 - 1) + 1, (case erlang:is_map(Costs_3) of true -> maps:get((I_12 - 1), Costs_3, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_3) + (I_12 - 1) + 1, Costs_3); _ -> mochi_nth((I_12 - 1) + 1, Costs_3) end end)) end end) + Replace_cost)] ++ lists:nthtail(J_3 + 1, lists:nth(I_12 + 1, Costs_3))] ++ lists:nthtail(I_12 + 1, Costs_3),
            Ops_5 = lists:sublist(Ops_3, I_12) ++ [lists:sublist(lists:nth(I_12 + 1, Ops_3), J_3) ++ [(("R" ++ (case erlang:is_map(Source_seq) of true -> maps:get((I_12 - 1), Source_seq, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Source_seq) + (I_12 - 1) + 1, Source_seq); _ -> mochi_nth((I_12 - 1) + 1, Source_seq) end end)) ++ (case erlang:is_map(Dest_seq) of true -> maps:get((J_3 - 1), Dest_seq, nil); _ -> case (J_3 - 1) < 0 of true -> mochi_nth(erlang:length(Dest_seq) + (J_3 - 1) + 1, Dest_seq); _ -> mochi_nth((J_3 - 1) + 1, Dest_seq) end end))] ++ lists:nthtail(J_3 + 1, lists:nth(I_12 + 1, Ops_3))] ++ lists:nthtail(I_12 + 1, Ops_3),
            Costs_6 = Costs_5,
            Ops_6 = Ops_5
    end,
            case (((case erlang:is_map((case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end)) of true -> maps:get(J_3, (case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end)) + J_3 + 1, (case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end)) end end) + Delete_cost) < (case erlang:is_map((case erlang:is_map(Costs_6) of true -> maps:get(I_12, Costs_6, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_6) + I_12 + 1, Costs_6); _ -> mochi_nth(I_12 + 1, Costs_6) end end)) of true -> maps:get(J_3, (case erlang:is_map(Costs_6) of true -> maps:get(I_12, Costs_6, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_6) + I_12 + 1, Costs_6); _ -> mochi_nth(I_12 + 1, Costs_6) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Costs_6) of true -> maps:get(I_12, Costs_6, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_6) + I_12 + 1, Costs_6); _ -> mochi_nth(I_12 + 1, Costs_6) end end)) + J_3 + 1, (case erlang:is_map(Costs_6) of true -> maps:get(I_12, Costs_6, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_6) + I_12 + 1, Costs_6); _ -> mochi_nth(I_12 + 1, Costs_6) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(Costs_6) of true -> maps:get(I_12, Costs_6, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_6) + I_12 + 1, Costs_6); _ -> mochi_nth(I_12 + 1, Costs_6) end end)) end end)) of
        true -> Costs_7 = lists:sublist(Costs_6, I_12) ++ [lists:sublist(lists:nth(I_12 + 1, Costs_6), J_3) ++ [((case erlang:is_map((case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end)) of true -> maps:get(J_3, (case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end)) + J_3 + 1, (case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(Costs_6) of true -> maps:get((I_12 - 1), Costs_6, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Costs_6) + (I_12 - 1) + 1, Costs_6); _ -> mochi_nth((I_12 - 1) + 1, Costs_6) end end)) end end) + Delete_cost)] ++ lists:nthtail(J_3 + 1, lists:nth(I_12 + 1, Costs_6))] ++ lists:nthtail(I_12 + 1, Costs_6),
            Ops_7 = lists:sublist(Ops_6, I_12) ++ [lists:sublist(lists:nth(I_12 + 1, Ops_6), J_3) ++ [("D" ++ (case erlang:is_map(Source_seq) of true -> maps:get((I_12 - 1), Source_seq, nil); _ -> case (I_12 - 1) < 0 of true -> mochi_nth(erlang:length(Source_seq) + (I_12 - 1) + 1, Source_seq); _ -> mochi_nth((I_12 - 1) + 1, Source_seq) end end))] ++ lists:nthtail(J_3 + 1, lists:nth(I_12 + 1, Ops_6))] ++ lists:nthtail(I_12 + 1, Ops_6),
            Costs_8 = Costs_7,
            Ops_8 = Ops_7;
        _ -> Costs_8 = Costs_6,
            Ops_8 = Ops_6
    end,
            case (((case erlang:is_map((case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)) of true -> maps:get((J_3 - 1), (case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end), nil); _ -> case (J_3 - 1) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)) + (J_3 - 1) + 1, (case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)); _ -> mochi_nth((J_3 - 1) + 1, (case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)) end end) + Insert_cost) < (case erlang:is_map((case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)) of true -> maps:get(J_3, (case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)) + J_3 + 1, (case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)) end end)) of
        true -> Costs_9 = lists:sublist(Costs_8, I_12) ++ [lists:sublist(lists:nth(I_12 + 1, Costs_8), J_3) ++ [((case erlang:is_map((case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)) of true -> maps:get((J_3 - 1), (case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end), nil); _ -> case (J_3 - 1) < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)) + (J_3 - 1) + 1, (case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)); _ -> mochi_nth((J_3 - 1) + 1, (case erlang:is_map(Costs_8) of true -> maps:get(I_12, Costs_8, nil); _ -> case I_12 < 0 of true -> mochi_nth(erlang:length(Costs_8) + I_12 + 1, Costs_8); _ -> mochi_nth(I_12 + 1, Costs_8) end end)) end end) + Insert_cost)] ++ lists:nthtail(J_3 + 1, lists:nth(I_12 + 1, Costs_8))] ++ lists:nthtail(I_12 + 1, Costs_8),
            Ops_9 = lists:sublist(Ops_8, I_12) ++ [lists:sublist(lists:nth(I_12 + 1, Ops_8), J_3) ++ [("I" ++ (case erlang:is_map(Dest_seq) of true -> maps:get((J_3 - 1), Dest_seq, nil); _ -> case (J_3 - 1) < 0 of true -> mochi_nth(erlang:length(Dest_seq) + (J_3 - 1) + 1, Dest_seq); _ -> mochi_nth((J_3 - 1) + 1, Dest_seq) end end))] ++ lists:nthtail(J_3 + 1, lists:nth(I_12 + 1, Ops_8))] ++ lists:nthtail(I_12 + 1, Ops_8),
            Costs_10 = Costs_9,
            Ops_10 = Ops_9;
        _ -> Costs_10 = Costs_8,
            Ops_10 = Ops_8
    end,
            J_4 = (J_3 + 1),
            Fun_12_loop(Copy_cost, Costs_10, Delete_cost, Dest_seq, Destination_string, I_12, Insert_cost, J_4, M, N, Ops_10, Replace_cost, Source_seq, Source_string);
        _ -> {Copy_cost, Costs_3, Delete_cost, Dest_seq, Destination_string, I_12, Insert_cost, J_3, M, N, Ops_3, Replace_cost, Source_seq, Source_string}
    end
end,
{Copy_cost, Costs_10, Delete_cost, Dest_seq, Destination_string, I_12, Insert_cost, J_4, M, N, Ops_10, Replace_cost, Source_seq, Source_string} = Fun_12(Copy_cost, Costs_3, Delete_cost, Dest_seq, Destination_string, I_12, Insert_cost, J_3, M, N, Ops_3, Replace_cost, Source_seq, Source_string),
            I_13 = (I_12 + 1),
            Fun_13_loop(Copy_cost, Costs_10, Delete_cost, Dest_seq, Destination_string, I_13, Insert_cost, J_4, M, N, Ops_10, Replace_cost, Source_seq, Source_string);
        _ -> {Copy_cost, Costs_3, Delete_cost, Dest_seq, Destination_string, I_12, Insert_cost, J_2, M, N, Ops_3, Replace_cost, Source_seq, Source_string}
    end
end,
{Copy_cost, Costs_10, Delete_cost, Dest_seq, Destination_string, I_13, Insert_cost, J_4, M, N, Ops_10, Replace_cost, Source_seq, Source_string} = Fun_13(Copy_cost, Costs_3, Delete_cost, Dest_seq, Destination_string, I_12, Insert_cost, J_2, M, N, Ops_3, Replace_cost, Source_seq, Source_string),
        #{"costs" => Costs_10, "ops" => Ops_10}
    catch {return, RetCatch} -> RetCatch end.

assemble_transformation(Ops_11, I_14, J_5) ->
    try
        case ((I_14 == 0) andalso (J_5 == 0)) of
        true -> throw({return, []});
        _ -> ok
    end,
        Op = (case erlang:is_map((case erlang:is_map(Ops_11) of true -> maps:get(I_14, Ops_11, nil); _ -> case I_14 < 0 of true -> mochi_nth(erlang:length(Ops_11) + I_14 + 1, Ops_11); _ -> mochi_nth(I_14 + 1, Ops_11) end end)) of true -> maps:get(J_5, (case erlang:is_map(Ops_11) of true -> maps:get(I_14, Ops_11, nil); _ -> case I_14 < 0 of true -> mochi_nth(erlang:length(Ops_11) + I_14 + 1, Ops_11); _ -> mochi_nth(I_14 + 1, Ops_11) end end), nil); _ -> case J_5 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Ops_11) of true -> maps:get(I_14, Ops_11, nil); _ -> case I_14 < 0 of true -> mochi_nth(erlang:length(Ops_11) + I_14 + 1, Ops_11); _ -> mochi_nth(I_14 + 1, Ops_11) end end)) + J_5 + 1, (case erlang:is_map(Ops_11) of true -> maps:get(I_14, Ops_11, nil); _ -> case I_14 < 0 of true -> mochi_nth(erlang:length(Ops_11) + I_14 + 1, Ops_11); _ -> mochi_nth(I_14 + 1, Ops_11) end end)); _ -> mochi_nth(J_5 + 1, (case erlang:is_map(Ops_11) of true -> maps:get(I_14, Ops_11, nil); _ -> case I_14 < 0 of true -> mochi_nth(erlang:length(Ops_11) + I_14 + 1, Ops_11); _ -> mochi_nth(I_14 + 1, Ops_11) end end)) end end),
        Kind = string:substr(Op, 0 + 1, (1 - 0)),
        case ((Kind == "C") orelse (Kind == "R")) of
        true -> Seq = assemble_transformation(Ops_11, (I_14 - 1), (J_5 - 1)),
            Seq_2 = lists:append((case Seq of nil -> []; _ -> Seq end), [Op]),
            throw({return, Seq_2}),
            Seq_8 = Seq_2;
        _ -> case (Kind == "D") of
        true -> Seq_3 = assemble_transformation(Ops_11, (I_14 - 1), J_5),
            Seq_4 = lists:append((case Seq_3 of nil -> []; _ -> Seq_3 end), [Op]),
            throw({return, Seq_4}),
            Seq_7 = Seq_4;
        _ -> Seq_5 = assemble_transformation(Ops_11, I_14, (J_5 - 1)),
            Seq_6 = lists:append((case Seq_5 of nil -> []; _ -> Seq_5 end), [Op]),
            throw({return, Seq_6}),
            Seq_7 = Seq_6
    end,
            Seq_8 = Seq_7
    end,
        nil
    catch {return, RetCatch} -> RetCatch end.

main() ->
    try
        Copy_cost_2 = -1,
        Replace_cost_2 = 1,
        Delete_cost_2 = 2,
        Insert_cost_2 = 2,
        Src = "Python",
        Dst = "Algorithms",
        Tables = compute_transform_tables("Python", "Algorithms", Copy_cost_2, 1, 2, 2),
        Operations = maps:get("ops", Tables, nil),
        M_2 = erlang:length(Operations),
        N_2 = erlang:length((case erlang:is_map(Operations) of true -> maps:get(0, Operations, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Operations) + 0 + 1, Operations); _ -> mochi_nth(0 + 1, Operations) end end)),
        Sequence = assemble_transformation(Operations, (M_2 - 1), (N_2 - 1)),
        String_list = string_to_chars("Python"),
        Idx = 0,
        Cost = 0,
        K = 0,
        Fun_14 = fun Fun_14_loop(Copy_cost_2, Cost, Delete_cost_2, Dst, Idx, Insert_cost_2, K, M_2, N_2, Operations, Replace_cost_2, Sequence, Src, String_list, Tables) ->
    case (K < erlang:length(Sequence)) of
        true ->
            io:format("~ts~n", [mochi_repr(join_chars(String_list))]),
            Op_2 = (case erlang:is_map(Sequence) of true -> maps:get(K, Sequence, nil); _ -> case K < 0 of true -> mochi_nth(erlang:length(Sequence) + K + 1, Sequence); _ -> mochi_nth(K + 1, Sequence) end end),
            Kind_2 = string:substr(Op_2, 0 + 1, (1 - 0)),
            case (Kind_2 == "C") of
        true -> Cost_2 = (Cost + Copy_cost_2),
            Cost_8 = Cost_2,
            String_list_7 = String_list;
        _ -> case (Kind_2 == "R") of
        true -> String_list_2 = lists:sublist(String_list, Idx) ++ [string:substr(Op_2, 2 + 1, (3 - 2))] ++ lists:nthtail(Idx + 1, String_list),
            Cost_3 = (Cost + Replace_cost_2),
            Cost_7 = Cost_3,
            String_list_6 = String_list_2;
        _ -> case (Kind_2 == "D") of
        true -> String_list_3 = remove_at(String_list, Idx),
            Cost_4 = (Cost + Delete_cost_2),
            Cost_6 = Cost_4,
            String_list_5 = String_list_3;
        _ -> String_list_4 = insert_at(String_list, Idx, string:substr(Op_2, 1 + 1, (2 - 1))),
            Cost_5 = (Cost + Insert_cost_2),
            Cost_6 = Cost_5,
            String_list_5 = String_list_4
    end,
            Cost_7 = Cost_6,
            String_list_6 = String_list_5
    end,
            Cost_8 = Cost_7,
            String_list_7 = String_list_6
    end,
            Idx_2 = (Idx + 1),
            K_2 = (K + 1),
            Fun_14_loop(Copy_cost_2, Cost_8, Delete_cost_2, Dst, Idx_2, Insert_cost_2, K_2, M_2, N_2, Operations, Replace_cost_2, Sequence, Src, String_list_7, Tables);
        _ -> {Copy_cost_2, Cost, Delete_cost_2, Dst, Idx, Insert_cost_2, K, M_2, N_2, Operations, Replace_cost_2, Sequence, Src, String_list, Tables}
    end
end,
{Copy_cost_2, Cost_8, Delete_cost_2, Dst, Idx_2, Insert_cost_2, K_2, M_2, N_2, Operations, Replace_cost_2, Sequence, Src, String_list_7, Tables} = Fun_14(Copy_cost_2, Cost, Delete_cost_2, Dst, Idx, Insert_cost_2, K, M_2, N_2, Operations, Replace_cost_2, Sequence, Src, String_list, Tables),
        io:format("~ts~n", [mochi_repr(join_chars(String_list_7))]),
        io:format("~ts~n", [mochi_repr(("Cost: " ++ mochi_str(Cost_8)))]),
        nil
    catch {return, RetCatch} -> RetCatch end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
