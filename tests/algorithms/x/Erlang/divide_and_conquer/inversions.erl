#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, slice_list/3, count_inversions_bf/1, count_cross_inversions/2, count_inversions_recursive/1]).

% Generated by Mochi transpiler v0.10.59 (cf9c8584f7) on 2025-08-07 09:56 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

slice_list(Arr, Start, End) ->
    try
        Res = [],
        K = Start,
        Fun = fun Fun_loop(Arr, End, K, Res, Start) ->
    case (K < End) of
        true ->
            Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [(case erlang:is_map(Arr) of true -> maps:get(K, Arr, nil); _ -> case K < 0 of true -> lists:nth(erlang:length(Arr) + K + 1, Arr); _ -> lists:nth(K + 1, Arr) end end)]),
            K_2 = (K + 1),
            Fun_loop(Arr, End, K_2, Res_2, Start);
        _ -> {Arr, End, K, Res, Start}
    end
end,
{Arr, End, K_2, Res_2, Start} = Fun(Arr, End, K, Res, Start),
        Res_2
    catch {return, Ret} -> Ret end.

count_inversions_bf(Arr_2) ->
    try
        N = erlang:length(Arr_2),
        Inv = 0,
        I = 0,
        Fun_3 = fun Fun_3_loop(Arr_2, I, Inv, N) ->
    case (I < (N - 1)) of
        true ->
            J = (I + 1),
            Fun_2 = fun Fun_2_loop(Arr_2, I, Inv, J, N) ->
    case (J < N) of
        true ->
            case ((case erlang:is_map(Arr_2) of true -> maps:get(I, Arr_2, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Arr_2) + I + 1, Arr_2); _ -> lists:nth(I + 1, Arr_2) end end) > (case erlang:is_map(Arr_2) of true -> maps:get(J, Arr_2, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Arr_2) + J + 1, Arr_2); _ -> lists:nth(J + 1, Arr_2) end end)) of
        true -> Inv_2 = (Inv + 1),
            Inv_3 = Inv_2;
        _ -> Inv_3 = Inv
    end,
            J_2 = (J + 1),
            Fun_2_loop(Arr_2, I, Inv_3, J_2, N);
        _ -> {Arr_2, I, Inv, J, N}
    end
end,
{Arr_2, I, Inv_3, J_2, N} = Fun_2(Arr_2, I, Inv, J, N),
            I_2 = (I + 1),
            Fun_3_loop(Arr_2, I_2, Inv_3, N);
        _ -> {Arr_2, I, Inv, N}
    end
end,
{Arr_2, I_2, Inv_3, N} = Fun_3(Arr_2, I, Inv, N),
        Inv_3
    catch {return, Ret} -> Ret end.

count_cross_inversions(P, Q) ->
    try
        R = [],
        I_3 = 0,
        J_3 = 0,
        Inv_4 = 0,
        Fun_4 = fun Fun_4_loop(I_3, Inv_4, J_3, P, Q, R) ->
    case ((I_3 < erlang:length(P)) andalso (J_3 < erlang:length(Q))) of
        true ->
            case ((case erlang:is_map(P) of true -> maps:get(I_3, P, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(P) + I_3 + 1, P); _ -> lists:nth(I_3 + 1, P) end end) > (case erlang:is_map(Q) of true -> maps:get(J_3, Q, nil); _ -> case J_3 < 0 of true -> lists:nth(erlang:length(Q) + J_3 + 1, Q); _ -> lists:nth(J_3 + 1, Q) end end)) of
        true -> Inv_5 = (Inv_4 + (erlang:length(P) - I_3)),
            R_2 = lists:append((case R of nil -> []; _ -> R end), [(case erlang:is_map(Q) of true -> maps:get(J_3, Q, nil); _ -> case J_3 < 0 of true -> lists:nth(erlang:length(Q) + J_3 + 1, Q); _ -> lists:nth(J_3 + 1, Q) end end)]),
            J_4 = (J_3 + 1),
            I_5 = I_3,
            Inv_6 = Inv_5,
            J_5 = J_4,
            R_4 = R_2;
        _ -> R_3 = lists:append((case R of nil -> []; _ -> R end), [(case erlang:is_map(P) of true -> maps:get(I_3, P, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(P) + I_3 + 1, P); _ -> lists:nth(I_3 + 1, P) end end)]),
            I_4 = (I_3 + 1),
            I_5 = I_4,
            Inv_6 = Inv_4,
            J_5 = J_3,
            R_4 = R_3
    end,
            Fun_4_loop(I_5, Inv_6, J_5, P, Q, R_4);
        _ -> {I_3, Inv_4, J_3, P, Q, R}
    end
end,
{I_5, Inv_6, J_5, P, Q, R_4} = Fun_4(I_3, Inv_4, J_3, P, Q, R),
        case (I_5 < erlang:length(P)) of
        true -> R_5 = lists:append(R_4, slice_list(P, I_5, erlang:length(P))),
            R_7 = R_5;
        _ -> R_6 = lists:append(R_4, slice_list(Q, J_5, erlang:length(Q))),
            R_7 = R_6
    end,
        #{"arr" => R_7, "inv" => Inv_6}
    catch {return, Ret} -> Ret end.

count_inversions_recursive(Arr_3) ->
    try
        case (erlang:length(Arr_3) =< 1) of
        true -> throw({return, #{"arr" => Arr_3, "inv" => 0}});
        _ -> ok
    end,
        Mid = (erlang:length(Arr_3) div 2),
        P_2 = slice_list(Arr_3, 0, Mid),
        Q_2 = slice_list(Arr_3, Mid, erlang:length(Arr_3)),
        Res_p = count_inversions_recursive(P_2),
        Res_q = count_inversions_recursive(Q_2),
        Res_cross = count_cross_inversions(maps:get("arr", Res_p, nil), maps:get("arr", Res_q, nil)),
        Total = ((maps:get("inv", Res_p, nil) + maps:get("inv", Res_q, nil)) + maps:get("inv", Res_cross, nil)),
        #{"arr" => maps:get("arr", Res_cross, nil), "inv" => Total}
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('arr_1', [10, 2, 1, 5, 5, 2, 11]),
    erlang:put('nbf', count_inversions_bf(erlang:get('arr_1'))),
    erlang:put('nrec', maps:get("inv", count_inversions_recursive(erlang:get('arr_1')), nil)),
    io:format("~ts ~ts~n", [mochi_repr("number of inversions = "), mochi_repr(erlang:get('nbf'))]),
    erlang:put('arr_1', [1, 2, 2, 5, 5, 10, 11]),
    erlang:put('nbf2', count_inversions_bf(erlang:get('arr_1'))),
    erlang:put('nrec2', maps:get("inv", count_inversions_recursive(erlang:get('arr_1')), nil)),
    io:format("~ts ~ts~n", [mochi_repr("number of inversions = "), mochi_repr(erlang:get('nbf2'))]),
    erlang:put('arr_1', []),
    erlang:put('nbf3', count_inversions_bf(erlang:get('arr_1'))),
    erlang:put('nrec3', maps:get("inv", count_inversions_recursive(erlang:get('arr_1')), nil)),
    io:format("~ts ~ts~n", [mochi_repr("number of inversions = "), mochi_repr(erlang:get('nbf3'))]),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
