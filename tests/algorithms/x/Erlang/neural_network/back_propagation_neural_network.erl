#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, rand/0, random/0, expapprox/1, sigmoid/1, sigmoid_vec/1, sigmoid_derivative/1, random_vector/1, random_matrix/2, matvec/2, mattvec/2, vec_sub/2, vec_mul/2, vec_scalar_mul/2, outer/2, mat_scalar_mul/2, mat_sub/2, init_layer/3, forward/2, backward/2, calc_loss/2, calc_gradient/2, train/5, create_data/0, main/0]).

% Generated by Mochi transpiler v0.10.61 (c45765bf43) on 2025-08-08 15:36 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try
        case erlang:is_integer(A) andalso erlang:is_integer(B) of
            true ->
                case B of
                    0 -> 0;
                    _ -> A div B
                end;
            false -> A / B
        end
    catch _:_ -> 0.0 end.


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

rand() ->
    try
        erlang:put('seed', mochi_mod(((erlang:get('seed') * 1103515245) + 12345), 2147483648)),
        erlang:get('seed')
    catch {return, Ret} -> Ret end.

random() ->
    try
        mochi_safe_div(mochi_safe_mul(1.0, rand()), 2147483648.0)
    catch {return, Ret} -> Ret end.

expapprox(X) ->
    try
        Y = X,
        Is_neg = false,
        case (X < 0.0) of
        true -> Is_neg_2 = true,
            Y_2 = -X,
            Is_neg_3 = Is_neg_2,
            Y_3 = Y_2;
        _ -> Is_neg_3 = Is_neg,
            Y_3 = Y
    end,
        Term = 1.0,
        Sum = 1.0,
        N = 1,
        Fun = fun Fun_loop(Is_neg_3, N, Sum, Term, X, Y_3) ->
    case (N < 30) of
        true ->
            Term_2 = mochi_safe_div(mochi_safe_mul(Term, Y_3), float(N)),
            Sum_2 = (Sum + Term_2),
            N_2 = (N + 1),
            Fun_loop(Is_neg_3, N_2, Sum_2, Term_2, X, Y_3);
        _ -> {Is_neg_3, N, Sum, Term, X, Y_3}
    end
end,
{Is_neg_3, N_2, Sum_2, Term_2, X, Y_3} = Fun(Is_neg_3, N, Sum, Term, X, Y_3),
        case Is_neg_3 of
        true -> throw({return, mochi_safe_div(1.0, Sum_2)});
        _ -> ok
    end,
        Sum_2
    catch {return, Ret} -> Ret end.

sigmoid(Z) ->
    try
        mochi_safe_div(1.0, (1.0 + expapprox(-Z)))
    catch {return, Ret} -> Ret end.

sigmoid_vec(V) ->
    try
        Res = [],
        I = 0,
        Fun_2 = fun Fun_2_loop(I, Res, V) ->
    case (I < erlang:length(V)) of
        true ->
            Res_2 = lists:append((case Res of nil -> []; _ -> Res end), [sigmoid((case erlang:is_map(V) of true -> maps:get(I, V, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(V) + I + 1, V); _ -> mochi_nth(I + 1, V) end end))]),
            I_2 = (I + 1),
            Fun_2_loop(I_2, Res_2, V);
        _ -> {I, Res, V}
    end
end,
{I_2, Res_2, V} = Fun_2(I, Res, V),
        Res_2
    catch {return, Ret} -> Ret end.

sigmoid_derivative(Out) ->
    try
        Res_3 = [],
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(I_3, Out, Res_3) ->
    case (I_3 < erlang:length(Out)) of
        true ->
            Val = (case erlang:is_map(Out) of true -> maps:get(I_3, Out, nil); _ -> case I_3 < 0 of true -> mochi_nth(erlang:length(Out) + I_3 + 1, Out); _ -> mochi_nth(I_3 + 1, Out) end end),
            Res_4 = lists:append((case Res_3 of nil -> []; _ -> Res_3 end), [mochi_safe_mul(Val, (1.0 - Val))]),
            I_4 = (I_3 + 1),
            Fun_3_loop(I_4, Out, Res_4);
        _ -> {I_3, Out, Res_3}
    end
end,
{I_4, Out, Res_4} = Fun_3(I_3, Out, Res_3),
        Res_4
    catch {return, Ret} -> Ret end.

random_vector(N_3) ->
    try
        V_2 = [],
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(I_5, N_3, V_2) ->
    case (I_5 < N_3) of
        true ->
            V_3 = lists:append((case V_2 of nil -> []; _ -> V_2 end), [(random() - 0.5)]),
            I_6 = (I_5 + 1),
            Fun_4_loop(I_6, N_3, V_3);
        _ -> {I_5, N_3, V_2}
    end
end,
{I_6, N_3, V_3} = Fun_4(I_5, N_3, V_2),
        V_3
    catch {return, Ret} -> Ret end.

random_matrix(R, C) ->
    try
        M = [],
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(C, I_7, M, R) ->
    case (I_7 < R) of
        true ->
            M_2 = lists:append((case M of nil -> []; _ -> M end), [random_vector(C)]),
            I_8 = (I_7 + 1),
            Fun_5_loop(C, I_8, M_2, R);
        _ -> {C, I_7, M, R}
    end
end,
{C, I_8, M_2, R} = Fun_5(C, I_7, M, R),
        M_2
    catch {return, Ret} -> Ret end.

matvec(Mat, Vec) ->
    try
        Res_5 = [],
        I_9 = 0,
        Fun_7 = fun Fun_7_loop(I_9, Mat, Res_5, Vec) ->
    case (I_9 < erlang:length(Mat)) of
        true ->
            S = 0.0,
            J = 0,
            Fun_6 = fun Fun_6_loop(I_9, J, Mat, Res_5, S, Vec) ->
    case (J < erlang:length(Vec)) of
        true ->
            S_2 = (S + mochi_safe_mul((case erlang:is_map((case erlang:is_map(Mat) of true -> maps:get(I_9, Mat, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Mat) + I_9 + 1, Mat); _ -> mochi_nth(I_9 + 1, Mat) end end)) of true -> maps:get(J, (case erlang:is_map(Mat) of true -> maps:get(I_9, Mat, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Mat) + I_9 + 1, Mat); _ -> mochi_nth(I_9 + 1, Mat) end end), nil); _ -> case J < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Mat) of true -> maps:get(I_9, Mat, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Mat) + I_9 + 1, Mat); _ -> mochi_nth(I_9 + 1, Mat) end end)) + J + 1, (case erlang:is_map(Mat) of true -> maps:get(I_9, Mat, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Mat) + I_9 + 1, Mat); _ -> mochi_nth(I_9 + 1, Mat) end end)); _ -> mochi_nth(J + 1, (case erlang:is_map(Mat) of true -> maps:get(I_9, Mat, nil); _ -> case I_9 < 0 of true -> mochi_nth(erlang:length(Mat) + I_9 + 1, Mat); _ -> mochi_nth(I_9 + 1, Mat) end end)) end end), (case erlang:is_map(Vec) of true -> maps:get(J, Vec, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Vec) + J + 1, Vec); _ -> mochi_nth(J + 1, Vec) end end))),
            J_2 = (J + 1),
            Fun_6_loop(I_9, J_2, Mat, Res_5, S_2, Vec);
        _ -> {I_9, J, Mat, Res_5, S, Vec}
    end
end,
{I_9, J_2, Mat, Res_5, S_2, Vec} = Fun_6(I_9, J, Mat, Res_5, S, Vec),
            Res_6 = lists:append((case Res_5 of nil -> []; _ -> Res_5 end), [S_2]),
            I_10 = (I_9 + 1),
            Fun_7_loop(I_10, Mat, Res_6, Vec);
        _ -> {I_9, Mat, Res_5, Vec}
    end
end,
{I_10, Mat, Res_6, Vec} = Fun_7(I_9, Mat, Res_5, Vec),
        Res_6
    catch {return, Ret} -> Ret end.

mattvec(Mat_2, Vec_2) ->
    try
        Cols = erlang:length((case erlang:is_map(Mat_2) of true -> maps:get(0, Mat_2, nil); _ -> case 0 < 0 of true -> mochi_nth(erlang:length(Mat_2) + 0 + 1, Mat_2); _ -> mochi_nth(0 + 1, Mat_2) end end)),
        Res_7 = [],
        J_3 = 0,
        Fun_9 = fun Fun_9_loop(Cols, J_3, Mat_2, Res_7, Vec_2) ->
    case (J_3 < Cols) of
        true ->
            S_3 = 0.0,
            I_11 = 0,
            Fun_8 = fun Fun_8_loop(Cols, I_11, J_3, Mat_2, Res_7, S_3, Vec_2) ->
    case (I_11 < erlang:length(Mat_2)) of
        true ->
            S_4 = (S_3 + mochi_safe_mul((case erlang:is_map((case erlang:is_map(Mat_2) of true -> maps:get(I_11, Mat_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Mat_2) + I_11 + 1, Mat_2); _ -> mochi_nth(I_11 + 1, Mat_2) end end)) of true -> maps:get(J_3, (case erlang:is_map(Mat_2) of true -> maps:get(I_11, Mat_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Mat_2) + I_11 + 1, Mat_2); _ -> mochi_nth(I_11 + 1, Mat_2) end end), nil); _ -> case J_3 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Mat_2) of true -> maps:get(I_11, Mat_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Mat_2) + I_11 + 1, Mat_2); _ -> mochi_nth(I_11 + 1, Mat_2) end end)) + J_3 + 1, (case erlang:is_map(Mat_2) of true -> maps:get(I_11, Mat_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Mat_2) + I_11 + 1, Mat_2); _ -> mochi_nth(I_11 + 1, Mat_2) end end)); _ -> mochi_nth(J_3 + 1, (case erlang:is_map(Mat_2) of true -> maps:get(I_11, Mat_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Mat_2) + I_11 + 1, Mat_2); _ -> mochi_nth(I_11 + 1, Mat_2) end end)) end end), (case erlang:is_map(Vec_2) of true -> maps:get(I_11, Vec_2, nil); _ -> case I_11 < 0 of true -> mochi_nth(erlang:length(Vec_2) + I_11 + 1, Vec_2); _ -> mochi_nth(I_11 + 1, Vec_2) end end))),
            I_12 = (I_11 + 1),
            Fun_8_loop(Cols, I_12, J_3, Mat_2, Res_7, S_4, Vec_2);
        _ -> {Cols, I_11, J_3, Mat_2, Res_7, S_3, Vec_2}
    end
end,
{Cols, I_12, J_3, Mat_2, Res_7, S_4, Vec_2} = Fun_8(Cols, I_11, J_3, Mat_2, Res_7, S_3, Vec_2),
            Res_8 = lists:append((case Res_7 of nil -> []; _ -> Res_7 end), [S_4]),
            J_4 = (J_3 + 1),
            Fun_9_loop(Cols, J_4, Mat_2, Res_8, Vec_2);
        _ -> {Cols, J_3, Mat_2, Res_7, Vec_2}
    end
end,
{Cols, J_4, Mat_2, Res_8, Vec_2} = Fun_9(Cols, J_3, Mat_2, Res_7, Vec_2),
        Res_8
    catch {return, Ret} -> Ret end.

vec_sub(A, B) ->
    try
        Res_9 = [],
        I_13 = 0,
        Fun_10 = fun Fun_10_loop(A, B, I_13, Res_9) ->
    case (I_13 < erlang:length(A)) of
        true ->
            Res_10 = lists:append((case Res_9 of nil -> []; _ -> Res_9 end), [((case erlang:is_map(A) of true -> maps:get(I_13, A, nil); _ -> case I_13 < 0 of true -> mochi_nth(erlang:length(A) + I_13 + 1, A); _ -> mochi_nth(I_13 + 1, A) end end) - (case erlang:is_map(B) of true -> maps:get(I_13, B, nil); _ -> case I_13 < 0 of true -> mochi_nth(erlang:length(B) + I_13 + 1, B); _ -> mochi_nth(I_13 + 1, B) end end))]),
            I_14 = (I_13 + 1),
            Fun_10_loop(A, B, I_14, Res_10);
        _ -> {A, B, I_13, Res_9}
    end
end,
{A, B, I_14, Res_10} = Fun_10(A, B, I_13, Res_9),
        Res_10
    catch {return, Ret} -> Ret end.

vec_mul(A_2, B_2) ->
    try
        Res_11 = [],
        I_15 = 0,
        Fun_11 = fun Fun_11_loop(A_2, B_2, I_15, Res_11) ->
    case (I_15 < erlang:length(A_2)) of
        true ->
            Res_12 = lists:append((case Res_11 of nil -> []; _ -> Res_11 end), [mochi_safe_mul((case erlang:is_map(A_2) of true -> maps:get(I_15, A_2, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(A_2) + I_15 + 1, A_2); _ -> mochi_nth(I_15 + 1, A_2) end end), (case erlang:is_map(B_2) of true -> maps:get(I_15, B_2, nil); _ -> case I_15 < 0 of true -> mochi_nth(erlang:length(B_2) + I_15 + 1, B_2); _ -> mochi_nth(I_15 + 1, B_2) end end))]),
            I_16 = (I_15 + 1),
            Fun_11_loop(A_2, B_2, I_16, Res_12);
        _ -> {A_2, B_2, I_15, Res_11}
    end
end,
{A_2, B_2, I_16, Res_12} = Fun_11(A_2, B_2, I_15, Res_11),
        Res_12
    catch {return, Ret} -> Ret end.

vec_scalar_mul(V_4, S_5) ->
    try
        Res_13 = [],
        I_17 = 0,
        Fun_12 = fun Fun_12_loop(I_17, Res_13, S_5, V_4) ->
    case (I_17 < erlang:length(V_4)) of
        true ->
            Res_14 = lists:append((case Res_13 of nil -> []; _ -> Res_13 end), [mochi_safe_mul((case erlang:is_map(V_4) of true -> maps:get(I_17, V_4, nil); _ -> case I_17 < 0 of true -> mochi_nth(erlang:length(V_4) + I_17 + 1, V_4); _ -> mochi_nth(I_17 + 1, V_4) end end), S_5)]),
            I_18 = (I_17 + 1),
            Fun_12_loop(I_18, Res_14, S_5, V_4);
        _ -> {I_17, Res_13, S_5, V_4}
    end
end,
{I_18, Res_14, S_5, V_4} = Fun_12(I_17, Res_13, S_5, V_4),
        Res_14
    catch {return, Ret} -> Ret end.

outer(A_3, B_3) ->
    try
        Res_15 = [],
        I_19 = 0,
        Fun_14 = fun Fun_14_loop(A_3, B_3, I_19, Res_15) ->
    case (I_19 < erlang:length(A_3)) of
        true ->
            Row = [],
            J_5 = 0,
            Fun_13 = fun Fun_13_loop(A_3, B_3, I_19, J_5, Res_15, Row) ->
    case (J_5 < erlang:length(B_3)) of
        true ->
            Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [mochi_safe_mul((case erlang:is_map(A_3) of true -> maps:get(I_19, A_3, nil); _ -> case I_19 < 0 of true -> mochi_nth(erlang:length(A_3) + I_19 + 1, A_3); _ -> mochi_nth(I_19 + 1, A_3) end end), (case erlang:is_map(B_3) of true -> maps:get(J_5, B_3, nil); _ -> case J_5 < 0 of true -> mochi_nth(erlang:length(B_3) + J_5 + 1, B_3); _ -> mochi_nth(J_5 + 1, B_3) end end))]),
            J_6 = (J_5 + 1),
            Fun_13_loop(A_3, B_3, I_19, J_6, Res_15, Row_2);
        _ -> {A_3, B_3, I_19, J_5, Res_15, Row}
    end
end,
{A_3, B_3, I_19, J_6, Res_15, Row_2} = Fun_13(A_3, B_3, I_19, J_5, Res_15, Row),
            Res_16 = lists:append((case Res_15 of nil -> []; _ -> Res_15 end), [Row_2]),
            I_20 = (I_19 + 1),
            Fun_14_loop(A_3, B_3, I_20, Res_16);
        _ -> {A_3, B_3, I_19, Res_15}
    end
end,
{A_3, B_3, I_20, Res_16} = Fun_14(A_3, B_3, I_19, Res_15),
        Res_16
    catch {return, Ret} -> Ret end.

mat_scalar_mul(Mat_3, S_6) ->
    try
        Res_17 = [],
        I_21 = 0,
        Fun_16 = fun Fun_16_loop(I_21, Mat_3, Res_17, S_6) ->
    case (I_21 < erlang:length(Mat_3)) of
        true ->
            Row_3 = [],
            J_7 = 0,
            Fun_15 = fun Fun_15_loop(I_21, J_7, Mat_3, Res_17, Row_3, S_6) ->
    case (J_7 < erlang:length((case erlang:is_map(Mat_3) of true -> maps:get(I_21, Mat_3, nil); _ -> case I_21 < 0 of true -> mochi_nth(erlang:length(Mat_3) + I_21 + 1, Mat_3); _ -> mochi_nth(I_21 + 1, Mat_3) end end))) of
        true ->
            Row_4 = lists:append((case Row_3 of nil -> []; _ -> Row_3 end), [mochi_safe_mul((case erlang:is_map((case erlang:is_map(Mat_3) of true -> maps:get(I_21, Mat_3, nil); _ -> case I_21 < 0 of true -> mochi_nth(erlang:length(Mat_3) + I_21 + 1, Mat_3); _ -> mochi_nth(I_21 + 1, Mat_3) end end)) of true -> maps:get(J_7, (case erlang:is_map(Mat_3) of true -> maps:get(I_21, Mat_3, nil); _ -> case I_21 < 0 of true -> mochi_nth(erlang:length(Mat_3) + I_21 + 1, Mat_3); _ -> mochi_nth(I_21 + 1, Mat_3) end end), nil); _ -> case J_7 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(Mat_3) of true -> maps:get(I_21, Mat_3, nil); _ -> case I_21 < 0 of true -> mochi_nth(erlang:length(Mat_3) + I_21 + 1, Mat_3); _ -> mochi_nth(I_21 + 1, Mat_3) end end)) + J_7 + 1, (case erlang:is_map(Mat_3) of true -> maps:get(I_21, Mat_3, nil); _ -> case I_21 < 0 of true -> mochi_nth(erlang:length(Mat_3) + I_21 + 1, Mat_3); _ -> mochi_nth(I_21 + 1, Mat_3) end end)); _ -> mochi_nth(J_7 + 1, (case erlang:is_map(Mat_3) of true -> maps:get(I_21, Mat_3, nil); _ -> case I_21 < 0 of true -> mochi_nth(erlang:length(Mat_3) + I_21 + 1, Mat_3); _ -> mochi_nth(I_21 + 1, Mat_3) end end)) end end), S_6)]),
            J_8 = (J_7 + 1),
            Fun_15_loop(I_21, J_8, Mat_3, Res_17, Row_4, S_6);
        _ -> {I_21, J_7, Mat_3, Res_17, Row_3, S_6}
    end
end,
{I_21, J_8, Mat_3, Res_17, Row_4, S_6} = Fun_15(I_21, J_7, Mat_3, Res_17, Row_3, S_6),
            Res_18 = lists:append((case Res_17 of nil -> []; _ -> Res_17 end), [Row_4]),
            I_22 = (I_21 + 1),
            Fun_16_loop(I_22, Mat_3, Res_18, S_6);
        _ -> {I_21, Mat_3, Res_17, S_6}
    end
end,
{I_22, Mat_3, Res_18, S_6} = Fun_16(I_21, Mat_3, Res_17, S_6),
        Res_18
    catch {return, Ret} -> Ret end.

mat_sub(A_4, B_4) ->
    try
        Res_19 = [],
        I_23 = 0,
        Fun_18 = fun Fun_18_loop(A_4, B_4, I_23, Res_19) ->
    case (I_23 < erlang:length(A_4)) of
        true ->
            Row_5 = [],
            J_9 = 0,
            Fun_17 = fun Fun_17_loop(A_4, B_4, I_23, J_9, Res_19, Row_5) ->
    case (J_9 < erlang:length((case erlang:is_map(A_4) of true -> maps:get(I_23, A_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(A_4) + I_23 + 1, A_4); _ -> mochi_nth(I_23 + 1, A_4) end end))) of
        true ->
            Row_6 = lists:append((case Row_5 of nil -> []; _ -> Row_5 end), [((case erlang:is_map((case erlang:is_map(A_4) of true -> maps:get(I_23, A_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(A_4) + I_23 + 1, A_4); _ -> mochi_nth(I_23 + 1, A_4) end end)) of true -> maps:get(J_9, (case erlang:is_map(A_4) of true -> maps:get(I_23, A_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(A_4) + I_23 + 1, A_4); _ -> mochi_nth(I_23 + 1, A_4) end end), nil); _ -> case J_9 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(A_4) of true -> maps:get(I_23, A_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(A_4) + I_23 + 1, A_4); _ -> mochi_nth(I_23 + 1, A_4) end end)) + J_9 + 1, (case erlang:is_map(A_4) of true -> maps:get(I_23, A_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(A_4) + I_23 + 1, A_4); _ -> mochi_nth(I_23 + 1, A_4) end end)); _ -> mochi_nth(J_9 + 1, (case erlang:is_map(A_4) of true -> maps:get(I_23, A_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(A_4) + I_23 + 1, A_4); _ -> mochi_nth(I_23 + 1, A_4) end end)) end end) - (case erlang:is_map((case erlang:is_map(B_4) of true -> maps:get(I_23, B_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(B_4) + I_23 + 1, B_4); _ -> mochi_nth(I_23 + 1, B_4) end end)) of true -> maps:get(J_9, (case erlang:is_map(B_4) of true -> maps:get(I_23, B_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(B_4) + I_23 + 1, B_4); _ -> mochi_nth(I_23 + 1, B_4) end end), nil); _ -> case J_9 < 0 of true -> mochi_nth(erlang:length((case erlang:is_map(B_4) of true -> maps:get(I_23, B_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(B_4) + I_23 + 1, B_4); _ -> mochi_nth(I_23 + 1, B_4) end end)) + J_9 + 1, (case erlang:is_map(B_4) of true -> maps:get(I_23, B_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(B_4) + I_23 + 1, B_4); _ -> mochi_nth(I_23 + 1, B_4) end end)); _ -> mochi_nth(J_9 + 1, (case erlang:is_map(B_4) of true -> maps:get(I_23, B_4, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(B_4) + I_23 + 1, B_4); _ -> mochi_nth(I_23 + 1, B_4) end end)) end end))]),
            J_10 = (J_9 + 1),
            Fun_17_loop(A_4, B_4, I_23, J_10, Res_19, Row_6);
        _ -> {A_4, B_4, I_23, J_9, Res_19, Row_5}
    end
end,
{A_4, B_4, I_23, J_10, Res_19, Row_6} = Fun_17(A_4, B_4, I_23, J_9, Res_19, Row_5),
            Res_20 = lists:append((case Res_19 of nil -> []; _ -> Res_19 end), [Row_6]),
            I_24 = (I_23 + 1),
            Fun_18_loop(A_4, B_4, I_24, Res_20);
        _ -> {A_4, B_4, I_23, Res_19}
    end
end,
{A_4, B_4, I_24, Res_20} = Fun_18(A_4, B_4, I_23, Res_19),
        Res_20
    catch {return, Ret} -> Ret end.

init_layer(Units, Back_units, Lr) ->
    try
        #{"units" => Units, "weight" => random_matrix(Units, Back_units), "bias" => random_vector(Units), "output" => [], "xdata" => [], "learn_rate" => Lr}
    catch {return, Ret} -> Ret end.

forward(Layers, X_2) ->
    try
        Data = X_2,
        I_25 = 0,
        Fun_19 = fun Fun_19_loop(Data, I_25, Layers, X_2) ->
    case (I_25 < erlang:length(Layers)) of
        true ->
            Layer = (case erlang:is_map(Layers) of true -> maps:get(I_25, Layers, nil); _ -> case I_25 < 0 of true -> mochi_nth(erlang:length(Layers) + I_25 + 1, Layers); _ -> mochi_nth(I_25 + 1, Layers) end end),
            Layer_2 = maps:put("xdata", Data, Layer),
            case (I_25 == 0) of
        true -> Layer_3 = maps:put("output", Data, Layer_2),
            Data_3 = Data,
            Layer_5 = Layer_3,
            Z_3 = nil;
        _ -> Z_2 = vec_sub(matvec(maps:get("weight", Layer_2, nil), Data), maps:get("bias", Layer_2, nil)),
            Layer_4 = maps:put("output", sigmoid_vec(Z_2), Layer_2),
            Data_2 = maps:get("output", Layer_4, nil),
            Data_3 = Data_2,
            Layer_5 = Layer_4,
            Z_3 = Z_2
    end,
            Layers_2 = lists:sublist(Layers, I_25) ++ [Layer_5] ++ lists:nthtail(I_25 + 1, Layers),
            I_26 = (I_25 + 1),
            Fun_19_loop(Data_3, I_26, Layers_2, X_2);
        _ -> {Data, I_25, Layers, X_2}
    end
end,
{Data_3, I_26, Layers_2, X_2} = Fun_19(Data, I_25, Layers, X_2),
        Layers_2
    catch {return, Ret} -> Ret end.

backward(Layers_3, Grad) ->
    try
        G = Grad,
        I_27 = (erlang:length(Layers_3) - 1),
        Fun_20 = fun Fun_20_loop(G, Grad, I_27, Layers_3) ->
    case (I_27 > 0) of
        true ->
            Layer_6 = (case erlang:is_map(Layers_3) of true -> maps:get(I_27, Layers_3, nil); _ -> case I_27 < 0 of true -> mochi_nth(erlang:length(Layers_3) + I_27 + 1, Layers_3); _ -> mochi_nth(I_27 + 1, Layers_3) end end),
            Deriv = sigmoid_derivative(maps:get("output", Layer_6, nil)),
            Delta = vec_mul(G, Deriv),
            Grad_w = outer(Delta, maps:get("xdata", Layer_6, nil)),
            Layer_7 = maps:put("weight", mat_sub(maps:get("weight", Layer_6, nil), mat_scalar_mul(Grad_w, maps:get("learn_rate", Layer_6, nil))), Layer_6),
            Layer_8 = maps:put("bias", vec_sub(maps:get("bias", Layer_7, nil), vec_scalar_mul(Delta, maps:get("learn_rate", Layer_7, nil))), Layer_7),
            G_2 = mattvec(maps:get("weight", Layer_8, nil), Delta),
            Layers_4 = lists:sublist(Layers_3, I_27) ++ [Layer_8] ++ lists:nthtail(I_27 + 1, Layers_3),
            I_28 = (I_27 - 1),
            Fun_20_loop(G_2, Grad, I_28, Layers_4);
        _ -> {G, Grad, I_27, Layers_3}
    end
end,
{G_2, Grad, I_28, Layers_4} = Fun_20(G, Grad, I_27, Layers_3),
        Layers_4
    catch {return, Ret} -> Ret end.

calc_loss(Y_4, Yhat) ->
    try
        S_7 = 0.0,
        I_29 = 0,
        Fun_21 = fun Fun_21_loop(I_29, S_7, Y_4, Yhat) ->
    case (I_29 < erlang:length(Y_4)) of
        true ->
            D = ((case erlang:is_map(Y_4) of true -> maps:get(I_29, Y_4, nil); _ -> case I_29 < 0 of true -> mochi_nth(erlang:length(Y_4) + I_29 + 1, Y_4); _ -> mochi_nth(I_29 + 1, Y_4) end end) - (case erlang:is_map(Yhat) of true -> maps:get(I_29, Yhat, nil); _ -> case I_29 < 0 of true -> mochi_nth(erlang:length(Yhat) + I_29 + 1, Yhat); _ -> mochi_nth(I_29 + 1, Yhat) end end)),
            S_8 = (S_7 + mochi_safe_mul(D, D)),
            I_30 = (I_29 + 1),
            Fun_21_loop(I_30, S_8, Y_4, Yhat);
        _ -> {I_29, S_7, Y_4, Yhat}
    end
end,
{I_30, S_8, Y_4, Yhat} = Fun_21(I_29, S_7, Y_4, Yhat),
        S_8
    catch {return, Ret} -> Ret end.

calc_gradient(Y_5, Yhat_2) ->
    try
        G_3 = [],
        I_31 = 0,
        Fun_22 = fun Fun_22_loop(G_3, I_31, Y_5, Yhat_2) ->
    case (I_31 < erlang:length(Y_5)) of
        true ->
            G_4 = lists:append((case G_3 of nil -> []; _ -> G_3 end), [mochi_safe_mul(2.0, ((case erlang:is_map(Yhat_2) of true -> maps:get(I_31, Yhat_2, nil); _ -> case I_31 < 0 of true -> mochi_nth(erlang:length(Yhat_2) + I_31 + 1, Yhat_2); _ -> mochi_nth(I_31 + 1, Yhat_2) end end) - (case erlang:is_map(Y_5) of true -> maps:get(I_31, Y_5, nil); _ -> case I_31 < 0 of true -> mochi_nth(erlang:length(Y_5) + I_31 + 1, Y_5); _ -> mochi_nth(I_31 + 1, Y_5) end end)))]),
            I_32 = (I_31 + 1),
            Fun_22_loop(G_4, I_32, Y_5, Yhat_2);
        _ -> {G_3, I_31, Y_5, Yhat_2}
    end
end,
{G_4, I_32, Y_5, Yhat_2} = Fun_22(G_3, I_31, Y_5, Yhat_2),
        G_4
    catch {return, Ret} -> Ret end.

train(Layers_5, Xdata, Ydata, Rounds, Acc) ->
    try
        R_2 = 0,
        Fun_24 = fun Fun_24_loop(Acc, Layers_5, R_2, Rounds, Xdata, Ydata) ->
    case (R_2 < Rounds) of
        true ->
            I_33 = 0,
            Fun_23 = fun Fun_23_loop(Acc, I_33, Layers_5, R_2, Rounds, Xdata, Ydata) ->
    case (I_33 < erlang:length(Xdata)) of
        true ->
            Layers_6 = forward(Layers_5, (case erlang:is_map(Xdata) of true -> maps:get(I_33, Xdata, nil); _ -> case I_33 < 0 of true -> mochi_nth(erlang:length(Xdata) + I_33 + 1, Xdata); _ -> mochi_nth(I_33 + 1, Xdata) end end)),
            Out_2 = maps:get("output", (case erlang:is_map(Layers_6) of true -> maps:get((erlang:length(Layers_6) - 1), Layers_6, nil); _ -> case (erlang:length(Layers_6) - 1) < 0 of true -> mochi_nth(erlang:length(Layers_6) + (erlang:length(Layers_6) - 1) + 1, Layers_6); _ -> mochi_nth((erlang:length(Layers_6) - 1) + 1, Layers_6) end end), nil),
            Grad_2 = calc_gradient((case erlang:is_map(Ydata) of true -> maps:get(I_33, Ydata, nil); _ -> case I_33 < 0 of true -> mochi_nth(erlang:length(Ydata) + I_33 + 1, Ydata); _ -> mochi_nth(I_33 + 1, Ydata) end end), Out_2),
            Layers_7 = backward(Layers_6, Grad_2),
            I_34 = (I_33 + 1),
            Fun_23_loop(Acc, I_34, Layers_7, R_2, Rounds, Xdata, Ydata);
        _ -> {Acc, I_33, Layers_5, R_2, Rounds, Xdata, Ydata}
    end
end,
{Acc, I_34, Layers_7, R_2, Rounds, Xdata, Ydata} = Fun_23(Acc, I_33, Layers_5, R_2, Rounds, Xdata, Ydata),
            R_3 = (R_2 + 1),
            Fun_24_loop(Acc, Layers_7, R_3, Rounds, Xdata, Ydata);
        _ -> {Acc, Layers_5, R_2, Rounds, Xdata, Ydata}
    end
end,
{Acc, Layers_7, R_3, Rounds, Xdata, Ydata} = Fun_24(Acc, Layers_5, R_2, Rounds, Xdata, Ydata),
        0.0
    catch {return, Ret} -> Ret end.

create_data() ->
    try
        X_3 = [],
        I_35 = 0,
        Fun_25 = fun Fun_25_loop(I_35, X_3) ->
    case (I_35 < 10) of
        true ->
            X_4 = lists:append((case X_3 of nil -> []; _ -> X_3 end), [random_vector(10)]),
            I_36 = (I_35 + 1),
            Fun_25_loop(I_36, X_4);
        _ -> {I_35, X_3}
    end
end,
{I_36, X_4} = Fun_25(I_35, X_3),
        Y_6 = [[0.8, 0.4], [0.4, 0.3], [0.34, 0.45], [0.67, 0.32], [0.88, 0.67], [0.78, 0.77], [0.55, 0.66], [0.55, 0.43], [0.54, 0.1], [0.1, 0.5]],
        #{"x" => X_4, "y" => Y_6}
    catch {return, Ret} -> Ret end.

main() ->
    try
        Data_4 = create_data(),
        X_5 = maps:get("x", Data_4, nil),
        Y_7 = maps:get("y", Data_4, nil),
        Layers_8 = [],
        Layers_9 = lists:append((case Layers_8 of nil -> []; _ -> Layers_8 end), [init_layer(10, 0, 0.3)]),
        Layers_10 = lists:append((case Layers_9 of nil -> []; _ -> Layers_9 end), [init_layer(20, 10, 0.3)]),
        Layers_11 = lists:append((case Layers_10 of nil -> []; _ -> Layers_10 end), [init_layer(30, 20, 0.3)]),
        Layers_12 = lists:append((case Layers_11 of nil -> []; _ -> Layers_11 end), [init_layer(2, 30, 0.3)]),
        Final_mse = train(Layers_12, X_5, Y_7, 100, 0.01),
        io:format("~ts~n", [mochi_repr(Final_mse)]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('seed', 1),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
