#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, dense_to_one_hot/2, new_dataset/2, next_batch/2, read_data_sets/6, main/0]).

% Generated by Mochi transpiler v0.10.61 (c45765bf43) on 2025-08-08 15:36 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

dense_to_one_hot(Labels, Num_classes) ->
    try
        Result = [],
        I = 0,
        Fun_2 = fun Fun_2_loop(I, Labels, Num_classes, Result) ->
    case (I < erlang:length(Labels)) of
        true ->
            Row = [],
            J = 0,
            Fun = fun Fun_loop(I, J, Labels, Num_classes, Result, Row) ->
    case (J < Num_classes) of
        true ->
            case (J == (case erlang:is_map(Labels) of true -> maps:get(I, Labels, nil); _ -> case I < 0 of true -> mochi_nth(erlang:length(Labels) + I + 1, Labels); _ -> mochi_nth(I + 1, Labels) end end)) of
        true -> Row_2 = lists:append((case Row of nil -> []; _ -> Row end), [1]),
            Row_4 = Row_2;
        _ -> Row_3 = lists:append((case Row of nil -> []; _ -> Row end), [0]),
            Row_4 = Row_3
    end,
            J_2 = (J + 1),
            Fun_loop(I, J_2, Labels, Num_classes, Result, Row_4);
        _ -> {I, J, Labels, Num_classes, Result, Row}
    end
end,
{I, J_2, Labels, Num_classes, Result, Row_4} = Fun(I, J, Labels, Num_classes, Result, Row),
            Result_2 = lists:append((case Result of nil -> []; _ -> Result end), [Row_4]),
            I_2 = (I + 1),
            Fun_2_loop(I_2, Labels, Num_classes, Result_2);
        _ -> {I, Labels, Num_classes, Result}
    end
end,
{I_2, Labels, Num_classes, Result_2} = Fun_2(I, Labels, Num_classes, Result),
        Result_2
    catch {return, Ret} -> Ret end.

new_dataset(Images, Labels_2) ->
    try
        #{"images" => Images, "labels" => Labels_2, "num_examples" => erlang:length(Images), "index_in_epoch" => 0, "epochs_completed" => 0}
    catch {return, Ret} -> Ret end.

next_batch(Ds, Batch_size) ->
    try
        Start = maps:get("index_in_epoch", Ds, nil),
        case ((Start + Batch_size) > maps:get("num_examples", Ds, nil)) of
        true -> Rest = (maps:get("num_examples", Ds, nil) - Start),
            Images_rest = lists:sublist(maps:get("images", Ds, nil), Start + 1, (maps:get("num_examples", Ds, nil) - Start)),
            Labels_rest = lists:sublist(maps:get("labels", Ds, nil), Start + 1, (maps:get("num_examples", Ds, nil) - Start)),
            New_index = (Batch_size - Rest),
            Images_new = lists:sublist(maps:get("images", Ds, nil), 0 + 1, (New_index - 0)),
            Labels_new = lists:sublist(maps:get("labels", Ds, nil), 0 + 1, (New_index - 0)),
            Batch_images = lists:append(Images_rest, Images_new),
            Batch_labels = lists:append(Labels_rest, Labels_new),
            New_ds = #{"images" => maps:get("images", Ds, nil), "labels" => maps:get("labels", Ds, nil), "num_examples" => maps:get("num_examples", Ds, nil), "index_in_epoch" => New_index, "epochs_completed" => (maps:get("epochs_completed", Ds, nil) + 1)},
            throw({return, #{"dataset" => New_ds, "images" => Batch_images, "labels" => Batch_labels}}),
            Batch_images_3 = Batch_images,
            Batch_labels_3 = Batch_labels,
            End_2 = nil,
            Images_new_2 = Images_new,
            Images_rest_2 = Images_rest,
            Labels_new_2 = Labels_new,
            Labels_rest_2 = Labels_rest,
            New_ds_3 = New_ds,
            New_index_2 = New_index,
            Rest_2 = Rest;
        _ -> End = (Start + Batch_size),
            Batch_images_2 = lists:sublist(maps:get("images", Ds, nil), Start + 1, (End - Start)),
            Batch_labels_2 = lists:sublist(maps:get("labels", Ds, nil), Start + 1, (End - Start)),
            New_ds_2 = #{"images" => maps:get("images", Ds, nil), "labels" => maps:get("labels", Ds, nil), "num_examples" => maps:get("num_examples", Ds, nil), "index_in_epoch" => End, "epochs_completed" => maps:get("epochs_completed", Ds, nil)},
            throw({return, #{"dataset" => New_ds_2, "images" => Batch_images_2, "labels" => Batch_labels_2}}),
            Batch_images_3 = Batch_images_2,
            Batch_labels_3 = Batch_labels_2,
            End_2 = End,
            Images_new_2 = nil,
            Images_rest_2 = nil,
            Labels_new_2 = nil,
            Labels_rest_2 = nil,
            New_ds_3 = New_ds_2,
            New_index_2 = nil,
            Rest_2 = nil
    end,
        nil
    catch {return, Ret} -> Ret end.

read_data_sets(Train_images, Train_labels_raw, Test_images, Test_labels_raw, Validation_size, Num_classes_2) ->
    try
        Train_labels = dense_to_one_hot(Train_labels_raw, Num_classes_2),
        Test_labels = dense_to_one_hot(Test_labels_raw, Num_classes_2),
        Validation_images = lists:sublist(Train_images, 0 + 1, (Validation_size - 0)),
        Validation_labels = lists:sublist(Train_labels, 0 + 1, (Validation_size - 0)),
        Train_images_rest = lists:sublist(Train_images, Validation_size + 1, (erlang:length(Train_images) - Validation_size)),
        Train_labels_rest = lists:sublist(Train_labels, Validation_size + 1, (erlang:length(Train_labels) - Validation_size)),
        Train = new_dataset(Train_images_rest, Train_labels_rest),
        Validation = new_dataset(Validation_images, Validation_labels),
        Testset = new_dataset(Test_images, Test_labels),
        #{"train" => Train, "validation" => Validation, "test_ds" => Testset}
    catch {return, Ret} -> Ret end.

main() ->
    try
        Train_images_2 = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]],
        Train_labels_raw_2 = [0, 1, 2, 3, 4],
        Test_images_2 = [[5, 6], [6, 7]],
        Test_labels_raw_2 = [5, 6],
        Data = read_data_sets(Train_images_2, Train_labels_raw_2, Test_images_2, Test_labels_raw_2, 2, 10),
        Ds_2 = maps:get("train", Data, nil),
        Res = next_batch(Ds_2, 2),
        Ds_3 = maps:get("dataset", Res, nil),
        io:format("~ts~n", [mochi_str(maps:get("images", Res, nil))]),
        io:format("~ts~n", [mochi_str(maps:get("labels", Res, nil))]),
        Res_2 = next_batch(Ds_3, 2),
        Ds_4 = maps:get("dataset", Res_2, nil),
        io:format("~ts~n", [mochi_str(maps:get("images", Res_2, nil))]),
        io:format("~ts~n", [mochi_str(maps:get("labels", Res_2, nil))]),
        Res_3 = next_batch(Ds_4, 2),
        Ds_5 = maps:get("dataset", Res_3, nil),
        io:format("~ts~n", [mochi_str(maps:get("images", Res_3, nil))]),
        io:format("~ts~n", [mochi_str(maps:get("labels", Res_3, nil))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
