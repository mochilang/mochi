#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, smallest_range/1, list_to_string/1, main/0]).

% Generated by Mochi transpiler v0.10.59 (3d41f87239) on 2025-08-07 10:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

smallest_range(Nums) ->
    try
        Heap = [],
        Current_max = -1000000000,
        I = 0,
        Fun = fun Fun_loop(Current_max, Heap, I, Nums) ->
    case (I < erlang:length(Nums)) of
        true ->
            First_val = (case erlang:is_map((case erlang:is_map(Nums) of true -> maps:get(I, Nums, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Nums) + I + 1, Nums); _ -> lists:nth(I + 1, Nums) end end)) of true -> maps:get(0, (case erlang:is_map(Nums) of true -> maps:get(I, Nums, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Nums) + I + 1, Nums); _ -> lists:nth(I + 1, Nums) end end), nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Nums) of true -> maps:get(I, Nums, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Nums) + I + 1, Nums); _ -> lists:nth(I + 1, Nums) end end)) + 0 + 1, (case erlang:is_map(Nums) of true -> maps:get(I, Nums, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Nums) + I + 1, Nums); _ -> lists:nth(I + 1, Nums) end end)); _ -> lists:nth(0 + 1, (case erlang:is_map(Nums) of true -> maps:get(I, Nums, nil); _ -> case I < 0 of true -> lists:nth(erlang:length(Nums) + I + 1, Nums); _ -> lists:nth(I + 1, Nums) end end)) end end),
            Heap_2 = lists:append((case Heap of nil -> []; _ -> Heap end), [#{"value" => First_val, "list_idx" => I, "elem_idx" => 0}]),
            case (First_val > Current_max) of
        true -> Current_max_2 = First_val,
            Current_max_3 = Current_max_2;
        _ -> Current_max_3 = Current_max
    end,
            I_2 = (I + 1),
            Fun_loop(Current_max_3, Heap_2, I_2, Nums);
        _ -> {Current_max, Heap, I, Nums}
    end
end,
{Current_max_3, Heap_2, I_2, Nums} = Fun(Current_max, Heap, I, Nums),
        Best = [-1000000000, 1000000000],
        Fun_4 = fun Fun_4_loop(Best, Current_max_3, Heap_2, I_2, Nums) ->
    case (erlang:length(Heap_2) > 0) of
        true ->
            try
                Min_idx = 0,
                J = 1,
                Fun_2 = fun Fun_2_loop(Best, Current_max_3, Heap_2, I_2, J, Min_idx, Nums) ->
    case (J < erlang:length(Heap_2)) of
        true ->
            Hj = (case erlang:is_map(Heap_2) of true -> maps:get(J, Heap_2, nil); _ -> case J < 0 of true -> lists:nth(erlang:length(Heap_2) + J + 1, Heap_2); _ -> lists:nth(J + 1, Heap_2) end end),
            Hmin = (case erlang:is_map(Heap_2) of true -> maps:get(Min_idx, Heap_2, nil); _ -> case Min_idx < 0 of true -> lists:nth(erlang:length(Heap_2) + Min_idx + 1, Heap_2); _ -> lists:nth(Min_idx + 1, Heap_2) end end),
            case (maps:get("value", Hj, nil) < maps:get("value", Hmin, nil)) of
        true -> Min_idx_2 = J,
            Min_idx_3 = Min_idx_2;
        _ -> Min_idx_3 = Min_idx
    end,
            J_2 = (J + 1),
            Fun_2_loop(Best, Current_max_3, Heap_2, I_2, J_2, Min_idx_3, Nums);
        _ -> {Best, Current_max_3, Heap_2, I_2, J, Min_idx, Nums}
    end
end,
{Best, Current_max_3, Heap_2, I_2, J_2, Min_idx_3, Nums} = Fun_2(Best, Current_max_3, Heap_2, I_2, J, Min_idx, Nums),
                Item = (case erlang:is_map(Heap_2) of true -> maps:get(Min_idx_3, Heap_2, nil); _ -> case Min_idx_3 < 0 of true -> lists:nth(erlang:length(Heap_2) + Min_idx_3 + 1, Heap_2); _ -> lists:nth(Min_idx_3 + 1, Heap_2) end end),
                New_heap = [],
                K = 0,
                Fun_3 = fun Fun_3_loop(Best, Current_max_3, Heap_2, I_2, Item, J_2, K, Min_idx_3, New_heap, Nums) ->
    case (K < erlang:length(Heap_2)) of
        true ->
            case (K /= Min_idx_3) of
        true -> New_heap_2 = lists:append((case New_heap of nil -> []; _ -> New_heap end), [(case erlang:is_map(Heap_2) of true -> maps:get(K, Heap_2, nil); _ -> case K < 0 of true -> lists:nth(erlang:length(Heap_2) + K + 1, Heap_2); _ -> lists:nth(K + 1, Heap_2) end end)]),
            New_heap_3 = New_heap_2;
        _ -> New_heap_3 = New_heap
    end,
            K_2 = (K + 1),
            Fun_3_loop(Best, Current_max_3, Heap_2, I_2, Item, J_2, K_2, Min_idx_3, New_heap_3, Nums);
        _ -> {Best, Current_max_3, Heap_2, I_2, Item, J_2, K, Min_idx_3, New_heap, Nums}
    end
end,
{Best, Current_max_3, Heap_2, I_2, Item, J_2, K_2, Min_idx_3, New_heap_3, Nums} = Fun_3(Best, Current_max_3, Heap_2, I_2, Item, J_2, K, Min_idx_3, New_heap, Nums),
                Heap_3 = New_heap_3,
                Current_min = maps:get("value", Item, nil),
                case ((Current_max_3 - Current_min) < ((case erlang:is_map(Best) of true -> maps:get(1, Best, nil); _ -> case 1 < 0 of true -> lists:nth(erlang:length(Best) + 1 + 1, Best); _ -> lists:nth(1 + 1, Best) end end) - (case erlang:is_map(Best) of true -> maps:get(0, Best, nil); _ -> case 0 < 0 of true -> lists:nth(erlang:length(Best) + 0 + 1, Best); _ -> lists:nth(0 + 1, Best) end end))) of
        true -> Best_2 = [Current_min, Current_max_3],
            Best_3 = Best_2;
        _ -> Best_3 = Best
    end,
                case (maps:get("elem_idx", Item, nil) == (erlang:length((case erlang:is_map(Nums) of true -> maps:get(maps:get("list_idx", Item, nil), Nums, nil); _ -> case maps:get("list_idx", Item, nil) < 0 of true -> lists:nth(erlang:length(Nums) + maps:get("list_idx", Item, nil) + 1, Nums); _ -> lists:nth(maps:get("list_idx", Item, nil) + 1, Nums) end end)) - 1)) of
        true -> throw({break, Best_3, Current_max_3, Heap_3, I_2, Nums});
        _ -> ok
    end,
                Next_val = (case erlang:is_map((case erlang:is_map(Nums) of true -> maps:get(maps:get("list_idx", Item, nil), Nums, nil); _ -> case maps:get("list_idx", Item, nil) < 0 of true -> lists:nth(erlang:length(Nums) + maps:get("list_idx", Item, nil) + 1, Nums); _ -> lists:nth(maps:get("list_idx", Item, nil) + 1, Nums) end end)) of true -> maps:get((maps:get("elem_idx", Item, nil) + 1), (case erlang:is_map(Nums) of true -> maps:get(maps:get("list_idx", Item, nil), Nums, nil); _ -> case maps:get("list_idx", Item, nil) < 0 of true -> lists:nth(erlang:length(Nums) + maps:get("list_idx", Item, nil) + 1, Nums); _ -> lists:nth(maps:get("list_idx", Item, nil) + 1, Nums) end end), nil); _ -> case (maps:get("elem_idx", Item, nil) + 1) < 0 of true -> lists:nth(erlang:length((case erlang:is_map(Nums) of true -> maps:get(maps:get("list_idx", Item, nil), Nums, nil); _ -> case maps:get("list_idx", Item, nil) < 0 of true -> lists:nth(erlang:length(Nums) + maps:get("list_idx", Item, nil) + 1, Nums); _ -> lists:nth(maps:get("list_idx", Item, nil) + 1, Nums) end end)) + (maps:get("elem_idx", Item, nil) + 1) + 1, (case erlang:is_map(Nums) of true -> maps:get(maps:get("list_idx", Item, nil), Nums, nil); _ -> case maps:get("list_idx", Item, nil) < 0 of true -> lists:nth(erlang:length(Nums) + maps:get("list_idx", Item, nil) + 1, Nums); _ -> lists:nth(maps:get("list_idx", Item, nil) + 1, Nums) end end)); _ -> lists:nth((maps:get("elem_idx", Item, nil) + 1) + 1, (case erlang:is_map(Nums) of true -> maps:get(maps:get("list_idx", Item, nil), Nums, nil); _ -> case maps:get("list_idx", Item, nil) < 0 of true -> lists:nth(erlang:length(Nums) + maps:get("list_idx", Item, nil) + 1, Nums); _ -> lists:nth(maps:get("list_idx", Item, nil) + 1, Nums) end end)) end end),
                Heap_4 = lists:append((case Heap_3 of nil -> []; _ -> Heap_3 end), [#{"value" => Next_val, "list_idx" => maps:get("list_idx", Item, nil), "elem_idx" => (maps:get("elem_idx", Item, nil) + 1)}]),
                case (Next_val > Current_max_3) of
        true -> Current_max_4 = Next_val,
            Current_max_5 = Current_max_4;
        _ -> Current_max_5 = Current_max_3
    end,
                Fun_4_loop(Best_3, Current_max_5, Heap_4, I_2, Nums)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_4_loop(C0, C1, C2, C3, C4);
                {break, B0, B1, B2, B3, B4} -> {B0, B1, B2, B3, B4}
            end;
        _ -> {Best, Current_max_3, Heap_2, I_2, Nums}
    end
end,
{Best_3, Current_max_5, Heap_4, I_2, Nums} = Fun_4(Best, Current_max_3, Heap_2, I_2, Nums),
        Best_3
    catch {return, Ret} -> Ret end.

list_to_string(Arr) ->
    try
        S = "[",
        I_3 = 0,
        Fun_5 = fun Fun_5_loop(Arr, I_3, S) ->
    case (I_3 < erlang:length(Arr)) of
        true ->
            S_2 = (S ++ mochi_str((case erlang:is_map(Arr) of true -> maps:get(I_3, Arr, nil); _ -> case I_3 < 0 of true -> lists:nth(erlang:length(Arr) + I_3 + 1, Arr); _ -> lists:nth(I_3 + 1, Arr) end end))),
            case (I_3 < (erlang:length(Arr) - 1)) of
        true -> S_3 = (S_2 ++ ", "),
            S_4 = S_3;
        _ -> S_4 = S_2
    end,
            I_4 = (I_3 + 1),
            Fun_5_loop(Arr, I_4, S_4);
        _ -> {Arr, I_3, S}
    end
end,
{Arr, I_4, S_4} = Fun_5(Arr, I_3, S),
        (S_4 ++ "]")
    catch {return, Ret} -> Ret end.

main() ->
    try
        Result1 = smallest_range([[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]),
        io:format("~ts~n", [mochi_repr(list_to_string(Result1))]),
        Result2 = smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]]),
        io:format("~ts~n", [mochi_repr(list_to_string(Result2))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('INF', 1000000000),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
