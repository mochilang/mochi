#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, split/2, join/2, repeat/2, replace_char/3, contains/2, file_extension/1, remove_extension/1, title_case/1, count_char/2, md_prefix/1, print_path/2, sort_strings/1, good_file_paths/1, print_directory_md/1]).

% Generated by Mochi transpiler v0.10.61 (8a444192ed) on 2025-08-08 18:58 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


mochi_repeat(S, N) when is_binary(S) ->
    binary:copy(S, mochi_to_int(N));
mochi_repeat(S, N) when is_list(S) ->
    string:copies(S, mochi_to_int(N));
mochi_repeat(_, _) -> [].


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S0 = erlang:float_to_list(V, [short]),
    S1 = re:replace(S0, "\.?0+$", "", [{return, list}]),
    case S1 of
        "" -> "0";
        _ -> S1
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).

split(S, Sep) ->
    try
        Parts = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, Parts, S, Sep) ->
    case (I < erlang:length(S)) of
        true ->
            case (((erlang:length(Sep) > 0) andalso ((I + erlang:length(Sep)) =< erlang:length(S))) andalso (string:substr(S, I + 1, ((I + erlang:length(Sep)) - I)) == Sep)) of
        true -> Parts_2 = lists:append((case Parts of nil -> []; _ -> Parts end), [Cur]),
            Cur_2 = "",
            I_2 = (I + erlang:length(Sep)),
            Cur_4 = Cur_2,
            I_4 = I_2,
            Parts_3 = Parts_2;
        _ -> Cur_3 = (Cur ++ string:substr(S, I + 1, ((I + 1) - I))),
            I_3 = (I + 1),
            Cur_4 = Cur_3,
            I_4 = I_3,
            Parts_3 = Parts
    end,
            Fun_loop(Cur_4, I_4, Parts_3, S, Sep);
        _ -> {Cur, I, Parts, S, Sep}
    end
end,
{Cur_4, I_4, Parts_3, S, Sep} = Fun(Cur, I, Parts, S, Sep),
        Parts_4 = lists:append((case Parts_3 of nil -> []; _ -> Parts_3 end), [Cur_4]),
        Parts_4
    catch {return, Ret} -> Ret end.

join(Xs, Sep_2) ->
    try
        Res = "",
        I_5 = 0,
        Fun_2 = fun Fun_2_loop(I_5, Res, Sep_2, Xs) ->
    case (I_5 < erlang:length(Xs)) of
        true ->
            case (I_5 > 0) of
        true -> Res_2 = (Res ++ Sep_2),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Res_4 = (Res_3 ++ (case erlang:is_map(Xs) of true -> maps:get(I_5, Xs, nil); _ -> case I_5 < 0 of true -> mochi_nth(erlang:length(Xs) + I_5 + 1, Xs); _ -> mochi_nth(I_5 + 1, Xs) end end)),
            I_6 = (I_5 + 1),
            Fun_2_loop(I_6, Res_4, Sep_2, Xs);
        _ -> {I_5, Res, Sep_2, Xs}
    end
end,
{I_6, Res_4, Sep_2, Xs} = Fun_2(I_5, Res, Sep_2, Xs),
        Res_4
    catch {return, Ret} -> Ret end.

repeat(S_2, N) ->
    try
        Out = "",
        I_7 = 0,
        Fun_3 = fun Fun_3_loop(I_7, N, Out, S_2) ->
    case (I_7 < N) of
        true ->
            Out_2 = (Out ++ S_2),
            I_8 = (I_7 + 1),
            Fun_3_loop(I_8, N, Out_2, S_2);
        _ -> {I_7, N, Out, S_2}
    end
end,
{I_8, N, Out_2, S_2} = Fun_3(I_7, N, Out, S_2),
        Out_2
    catch {return, Ret} -> Ret end.

replace_char(S_3, Old, New) ->
    try
        Out_3 = "",
        I_9 = 0,
        Fun_4 = fun Fun_4_loop(I_9, New, Old, Out_3, S_3) ->
    case (I_9 < erlang:length(S_3)) of
        true ->
            C = string:substr(S_3, I_9 + 1, ((I_9 + 1) - I_9)),
            case (C == Old) of
        true -> Out_4 = (Out_3 ++ New),
            Out_6 = Out_4;
        _ -> Out_5 = (Out_3 ++ C),
            Out_6 = Out_5
    end,
            I_10 = (I_9 + 1),
            Fun_4_loop(I_10, New, Old, Out_6, S_3);
        _ -> {I_9, New, Old, Out_3, S_3}
    end
end,
{I_10, New, Old, Out_6, S_3} = Fun_4(I_9, New, Old, Out_3, S_3),
        Out_6
    catch {return, Ret} -> Ret end.

contains(S_4, Sub) ->
    try
        case (erlang:length(Sub) == 0) of
        true -> throw({return, true});
        _ -> ok
    end,
        I_11 = 0,
        Fun_5 = fun Fun_5_loop(I_11, S_4, Sub) ->
    case ((I_11 + erlang:length(Sub)) =< erlang:length(S_4)) of
        true ->
            case (string:substr(S_4, I_11 + 1, ((I_11 + erlang:length(Sub)) - I_11)) == Sub) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_12 = (I_11 + 1),
            Fun_5_loop(I_12, S_4, Sub);
        _ -> {I_11, S_4, Sub}
    end
end,
{I_12, S_4, Sub} = Fun_5(I_11, S_4, Sub),
        false
    catch {return, Ret} -> Ret end.

file_extension(Name) ->
    try
        I_13 = (erlang:length(Name) - 1),
        Fun_6 = fun Fun_6_loop(I_13, Name) ->
    case (I_13 >= 0) of
        true ->
            case (string:substr(Name, I_13 + 1, ((I_13 + 1) - I_13)) == ".") of
        true -> throw({return, string:substr(Name, I_13 + 1, length(Name) - I_13)});
        _ -> ok
    end,
            I_14 = (I_13 - 1),
            Fun_6_loop(I_14, Name);
        _ -> {I_13, Name}
    end
end,
{I_14, Name} = Fun_6(I_13, Name),
        ""
    catch {return, Ret} -> Ret end.

remove_extension(Name_2) ->
    try
        I_15 = (erlang:length(Name_2) - 1),
        Fun_7 = fun Fun_7_loop(I_15, Name_2) ->
    case (I_15 >= 0) of
        true ->
            case (string:substr(Name_2, I_15 + 1, ((I_15 + 1) - I_15)) == ".") of
        true -> throw({return, string:substr(Name_2, 1, (I_15 - 0))});
        _ -> ok
    end,
            I_16 = (I_15 - 1),
            Fun_7_loop(I_16, Name_2);
        _ -> {I_15, Name_2}
    end
end,
{I_16, Name_2} = Fun_7(I_15, Name_2),
        Name_2
    catch {return, Ret} -> Ret end.

title_case(S_5) ->
    try
        Out_7 = "",
        Cap = true,
        I_17 = 0,
        Fun_8 = fun Fun_8_loop(Cap, I_17, Out_7, S_5) ->
    case (I_17 < erlang:length(S_5)) of
        true ->
            C_2 = string:substr(S_5, I_17 + 1, ((I_17 + 1) - I_17)),
            case (C_2 == " ") of
        true -> Out_8 = (Out_7 ++ C_2),
            Cap_2 = true,
            Cap_5 = Cap_2,
            Out_12 = Out_8;
        _ -> case Cap of
        true -> Out_9 = (Out_7 ++ string:to_upper(C_2)),
            Cap_3 = false,
            Cap_4 = Cap_3,
            Out_11 = Out_9;
        _ -> Out_10 = (Out_7 ++ string:to_lower(C_2)),
            Cap_4 = Cap,
            Out_11 = Out_10
    end,
            Cap_5 = Cap_4,
            Out_12 = Out_11
    end,
            I_18 = (I_17 + 1),
            Fun_8_loop(Cap_5, I_18, Out_12, S_5);
        _ -> {Cap, I_17, Out_7, S_5}
    end
end,
{Cap_5, I_18, Out_12, S_5} = Fun_8(Cap, I_17, Out_7, S_5),
        Out_12
    catch {return, Ret} -> Ret end.

count_char(S_6, Ch) ->
    try
        Cnt = 0,
        I_19 = 0,
        Fun_9 = fun Fun_9_loop(Ch, Cnt, I_19, S_6) ->
    case (I_19 < erlang:length(S_6)) of
        true ->
            case (string:substr(S_6, I_19 + 1, ((I_19 + 1) - I_19)) == Ch) of
        true -> Cnt_2 = (Cnt + 1),
            Cnt_3 = Cnt_2;
        _ -> Cnt_3 = Cnt
    end,
            I_20 = (I_19 + 1),
            Fun_9_loop(Ch, Cnt_3, I_20, S_6);
        _ -> {Ch, Cnt, I_19, S_6}
    end
end,
{Ch, Cnt_3, I_20, S_6} = Fun_9(Ch, Cnt, I_19, S_6),
        Cnt_3
    catch {return, Ret} -> Ret end.

md_prefix(Level) ->
    try
        (case (Level == 0) of
    true -> "\n##";
    _ -> (mochi_repeat("  ", Level) ++ "*")
end)
    catch {return, Ret} -> Ret end.

print_path(Old_path, New_path) ->
    try
        Old_parts = string:tokens(Old_path, "/"),
        New_parts = string:tokens(New_path, "/"),
        I_21 = 0,
        Fun_10 = fun Fun_10_loop(I_21, New_parts, New_path, Old_parts, Old_path) ->
    case (I_21 < erlang:length(New_parts)) of
        true ->
            case (((I_21 >= erlang:length(Old_parts)) orelse (string:substr(Old_parts, I_21 + 1, 1) /= string:substr(New_parts, I_21 + 1, 1))) andalso (string:substr(New_parts, I_21 + 1, 1) /= "")) of
        true -> Title = title_case(replace_char(string:substr(New_parts, I_21 + 1, 1), "_", " ")),
            io:format("~ts~n", [mochi_repr(((md_prefix(I_21) ++ " ") ++ Title))]),
            Title_2 = Title;
        _ -> Title_2 = nil
    end,
            I_22 = (I_21 + 1),
            Fun_10_loop(I_22, New_parts, New_path, Old_parts, Old_path);
        _ -> {I_21, New_parts, New_path, Old_parts, Old_path}
    end
end,
{I_22, New_parts, New_path, Old_parts, Old_path} = Fun_10(I_21, New_parts, New_path, Old_parts, Old_path),
        New_path
    catch {return, Ret} -> Ret end.

sort_strings(Xs_2) ->
    try
        Arr = Xs_2,
        I_23 = 0,
        Fun_12 = fun Fun_12_loop(Arr, I_23, Xs_2) ->
    case (I_23 < erlang:length(Arr)) of
        true ->
            Min_idx = I_23,
            J = (I_23 + 1),
            Fun_11 = fun Fun_11_loop(Arr, I_23, J, Min_idx, Xs_2) ->
    case (J < erlang:length(Arr)) of
        true ->
            case ((case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> case J < 0 of true -> mochi_nth(erlang:length(Arr) + J + 1, Arr); _ -> mochi_nth(J + 1, Arr) end end) < (case erlang:is_map(Arr) of true -> maps:get(Min_idx, Arr, nil); _ -> case Min_idx < 0 of true -> mochi_nth(erlang:length(Arr) + Min_idx + 1, Arr); _ -> mochi_nth(Min_idx + 1, Arr) end end)) of
        true -> Min_idx_2 = J,
            Min_idx_3 = Min_idx_2;
        _ -> Min_idx_3 = Min_idx
    end,
            J_2 = (J + 1),
            Fun_11_loop(Arr, I_23, J_2, Min_idx_3, Xs_2);
        _ -> {Arr, I_23, J, Min_idx, Xs_2}
    end
end,
{Arr, I_23, J_2, Min_idx_3, Xs_2} = Fun_11(Arr, I_23, J, Min_idx, Xs_2),
            Tmp = (case erlang:is_map(Arr) of true -> maps:get(I_23, Arr, nil); _ -> case I_23 < 0 of true -> mochi_nth(erlang:length(Arr) + I_23 + 1, Arr); _ -> mochi_nth(I_23 + 1, Arr) end end),
            Arr_2 = lists:sublist(Arr, I_23) ++ [(case erlang:is_map(Arr) of true -> maps:get(Min_idx_3, Arr, nil); _ -> case Min_idx_3 < 0 of true -> mochi_nth(erlang:length(Arr) + Min_idx_3 + 1, Arr); _ -> mochi_nth(Min_idx_3 + 1, Arr) end end)] ++ lists:nthtail(I_23 + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, Min_idx_3) ++ [Tmp] ++ lists:nthtail(Min_idx_3 + 1, Arr_2),
            I_24 = (I_23 + 1),
            Fun_12_loop(Arr_3, I_24, Xs_2);
        _ -> {Arr, I_23, Xs_2}
    end
end,
{Arr_3, I_24, Xs_2} = Fun_12(Arr, I_23, Xs_2),
        Arr_3
    catch {return, Ret} -> Ret end.

good_file_paths(Paths) ->
    try
        Res_5 = [],
        Fun_13 = fun Fun_13_loop(List, Paths, Res_5) ->
    case List of
        [] -> {Paths, Res_5};
        [P|P_rest] ->
        try
            Parts_5 = string:tokens(P, "/"),
            Skip = false,
            K = 0,
            Fun_14 = fun Fun_14_loop(K, P, Parts_5, Paths, Res_5, Skip) ->
    case (K < (erlang:length(Parts_5) - 1)) of
        true ->
            Part = string:substr(Parts_5, K + 1, 1),
            case ((((Part == "scripts") orelse (string:substr(Part, 0 + 1, (1 - 0)) == ".")) orelse (string:substr(Part, 0 + 1, (1 - 0)) == "_")) orelse (string:str(Part, "venv") =/= 0)) of
        true -> Skip_2 = true,
            Skip_3 = Skip_2;
        _ -> Skip_3 = Skip
    end,
            K_2 = (K + 1),
            Fun_14_loop(K_2, P, Parts_5, Paths, Res_5, Skip_3);
        _ -> {K, P, Parts_5, Paths, Res_5, Skip}
    end
end,
{K_2, P, Parts_5, Paths, Res_5, Skip_3} = Fun_14(K, P, Parts_5, Paths, Res_5, Skip),
            case (Skip_3 /= nil) of
        true -> throw({continue, Paths, Res_5});
        _ -> ok
    end,
            Filename = string:substr(Parts_5, (erlang:length(Parts_5) - 1) + 1, 1),
            case (Filename == "__init__.py") of
        true -> throw({continue, Paths, Res_5});
        _ -> ok
    end,
            Ext = file_extension(Filename),
            case ((Ext == ".py") orelse (Ext == ".ipynb")) of
        true -> Res_6 = lists:append((case Res_5 of nil -> []; _ -> Res_5 end), [P]),
            Res_7 = Res_6;
        _ -> Res_7 = Res_5
    end,
            Fun_13_loop(P_rest, Paths, Res_7)
        catch
            {continue, C0, C1} -> Fun_13_loop(P_rest, C0, C1);
            {break, B0, B1} -> {B0, B1};
            break -> {Paths, Res_5}
        end;
        _ -> {Paths, Res_5}
    end
end,
{Paths, Res_7} = Fun_13(Paths, Paths, Res_5),
        Res_7
    catch {return, Ret} -> Ret end.

print_directory_md(Paths_2) ->
    try
        Files = sort_strings(good_file_paths(Paths_2)),
        Old_path_2 = "",
        I_25 = 0,
        Fun_15 = fun Fun_15_loop(Files, I_25, Old_path_2, Paths_2) ->
    case (I_25 < erlang:length(Files)) of
        true ->
            Fp = (case erlang:is_map(Files) of true -> maps:get(I_25, Files, nil); _ -> case I_25 < 0 of true -> mochi_nth(erlang:length(Files) + I_25 + 1, Files); _ -> mochi_nth(I_25 + 1, Files) end end),
            Parts_6 = string:tokens(Fp, "/"),
            Filename_2 = string:substr(Parts_6, (erlang:length(Parts_6) - 1) + 1, 1),
            Filepath = "",
            case (erlang:length(Parts_6) > 1) of
        true -> Filepath_2 = join(string:substr(Parts_6, 1, ((erlang:length(Parts_6) - 1) - 0)), "/"),
            Filepath_3 = Filepath_2;
        _ -> Filepath_3 = Filepath
    end,
            case (Filepath_3 /= Old_path_2) of
        true -> Old_path_3 = print_path(Old_path_2, Filepath_3),
            Old_path_4 = Old_path_3;
        _ -> Old_path_4 = Old_path_2
    end,
            Indent = 0,
            case (erlang:length(Filepath_3) > 0) of
        true -> Indent_2 = (count_char(Filepath_3, "/") + 1),
            Indent_3 = Indent_2;
        _ -> Indent_3 = Indent
    end,
            Url = replace_char(Fp, " ", "%20"),
            Name_3 = title_case(replace_char(remove_extension(Filename_2), "_", " ")),
            io:format("~ts~n", [mochi_repr((((((md_prefix(Indent_3) ++ " [") ++ Name_3) ++ "](") ++ Url) ++ ")"))]),
            I_26 = (I_25 + 1),
            Fun_15_loop(Files, I_26, Old_path_4, Paths_2);
        _ -> {Files, I_25, Old_path_2, Paths_2}
    end
end,
{Files, I_26, Old_path_4, Paths_2} = Fun_15(Files, I_25, Old_path_2, Paths_2),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    try
        __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('sample', ["data_structures/linked_list.py", "data_structures/binary_tree.py", "math/number_theory/prime_check.py", "math/number_theory/greatest_common_divisor.ipynb"]),
    print_directory_md(erlang:get('sample')),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes])
    catch
        _:Err -> io:format("~s~n", [mochi_str(Err)])
    end.
