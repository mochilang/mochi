#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, create_board/2, move_ant/4, langtons_ant/3]).

% Generated by Mochi transpiler v0.10.59 (f521f86a07) on 2025-08-06 21:30 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

create_board(Width, Height) ->
    try
        Board = [],
        I = 0,
        Fun_2 = fun Fun_2_loop(Board, Height, I, Width) ->
    case (I < Height) of
        true ->
            Row = [],
            J = 0,
            Fun = fun Fun_loop(Board, Height, I, J, Row, Width) ->
    case (J < Width) of
        true ->
            Row_2 = lists:append(Row, [true]),
            J_2 = (J + 1),
            Fun_loop(Board, Height, I, J_2, Row_2, Width);
        _ -> {Board, Height, I, J, Row, Width}
    end
end,
{Board, Height, I, J_2, Row_2, Width} = Fun(Board, Height, I, J, Row, Width),
            Board_2 = lists:append(Board, [Row_2]),
            I_2 = (I + 1),
            Fun_2_loop(Board_2, Height, I_2, Width);
        _ -> {Board, Height, I, Width}
    end
end,
{Board_2, Height, I_2, Width} = Fun_2(Board, Height, I, Width),
        Board_2
    catch {return, Ret} -> Ret end.

move_ant(Board_3, X, Y, Direction) ->
    try
        case (case erlang:is_map((case erlang:is_map(Board_3) of true -> maps:get(X, Board_3, nil); _ -> lists:nth(X + 1, Board_3) end)) of true -> maps:get(Y, (case erlang:is_map(Board_3) of true -> maps:get(X, Board_3, nil); _ -> lists:nth(X + 1, Board_3) end), nil); _ -> lists:nth(Y + 1, (case erlang:is_map(Board_3) of true -> maps:get(X, Board_3, nil); _ -> lists:nth(X + 1, Board_3) end)) end) of
        true -> Direction_2 = ((Direction + 1) rem 4),
            Direction_4 = Direction_2;
        _ -> Direction_3 = ((Direction + 3) rem 4),
            Direction_4 = Direction_3
    end,
        Old_x = X,
        Old_y = Y,
        case (Direction_4 == 0) of
        true -> X_2 = (X - 1),
            X_6 = X_2,
            Y_6 = Y;
        _ -> case (Direction_4 == 1) of
        true -> Y_2 = (Y + 1),
            X_5 = X,
            Y_5 = Y_2;
        _ -> case (Direction_4 == 2) of
        true -> X_3 = (X + 1),
            X_4 = X_3,
            Y_4 = Y;
        _ -> Y_3 = (Y - 1),
            X_4 = X,
            Y_4 = Y_3
    end,
            X_5 = X_4,
            Y_5 = Y_4
    end,
            X_6 = X_5,
            Y_6 = Y_5
    end,
        Tmp = (case erlang:is_map(Board_3) of true -> maps:get(Old_x, Board_3, nil); _ -> lists:nth(Old_x + 1, Board_3) end),
        Tmp_2 = lists:sublist(Tmp, Old_y) ++ [mochi_not((case erlang:is_map((case erlang:is_map(Board_3) of true -> maps:get(Old_x, Board_3, nil); _ -> lists:nth(Old_x + 1, Board_3) end)) of true -> maps:get(Old_y, (case erlang:is_map(Board_3) of true -> maps:get(Old_x, Board_3, nil); _ -> lists:nth(Old_x + 1, Board_3) end), nil); _ -> lists:nth(Old_y + 1, (case erlang:is_map(Board_3) of true -> maps:get(Old_x, Board_3, nil); _ -> lists:nth(Old_x + 1, Board_3) end)) end))] ++ lists:nthtail(Old_y + 1, Tmp),
        Board_4 = lists:sublist(Board_3, Old_x) ++ [Tmp_2] ++ lists:nthtail(Old_x + 1, Board_3),
        [X_6, Y_6, Direction_4]
    catch {return, Ret} -> Ret end.

langtons_ant(Width_2, Height_2, Steps) ->
    try
        Board_5 = create_board(Width_2, Height_2),
        X_7 = (Width_2 div 2),
        Y_7 = (Height_2 div 2),
        Dir = 3,
        S = 0,
        Fun_3 = fun Fun_3_loop(Board_5, Dir, Height_2, S, Steps, Width_2, X_7, Y_7) ->
    case (S < Steps) of
        true ->
            State = move_ant(Board_5, X_7, Y_7, Dir),
            X_8 = (case erlang:is_map(State) of true -> maps:get(0, State, nil); _ -> lists:nth(0 + 1, State) end),
            Y_8 = (case erlang:is_map(State) of true -> maps:get(1, State, nil); _ -> lists:nth(1 + 1, State) end),
            Dir_2 = (case erlang:is_map(State) of true -> maps:get(2, State, nil); _ -> lists:nth(2 + 1, State) end),
            S_2 = (S + 1),
            Fun_3_loop(Board_5, Dir_2, Height_2, S_2, Steps, Width_2, X_8, Y_8);
        _ -> {Board_5, Dir, Height_2, S, Steps, Width_2, X_7, Y_7}
    end
end,
{Board_5, Dir_2, Height_2, S_2, Steps, Width_2, X_8, Y_8} = Fun_3(Board_5, Dir, Height_2, S, Steps, Width_2, X_7, Y_7),
        Board_5
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
