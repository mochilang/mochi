#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, log2/1, analyze_text/1, round_to_int/1, calculate_entropy/1]).

% Generated by Mochi transpiler v0.10.59 (ec7cf2f058) on 2025-08-07 14:07 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

log2(X) ->
    try
        K = 0.0,
        V = X,
        Fun = fun Fun_loop(K, V, X) ->
    case (V >= 2.0) of
        true ->
            V_2 = mochi_safe_div(V, 2.0),
            K_2 = (K + 1.0),
            Fun_loop(K_2, V_2, X);
        _ -> {K, V, X}
    end
end,
{K_2, V_2, X} = Fun(K, V, X),
        Fun_2 = fun Fun_2_loop(K_2, V_2, X) ->
    case (V_2 < 1.0) of
        true ->
            V_3 = mochi_safe_mul(V_2, 2.0),
            K_3 = (K_2 - 1.0),
            Fun_2_loop(K_3, V_3, X);
        _ -> {K_2, V_2, X}
    end
end,
{K_3, V_3, X} = Fun_2(K_2, V_2, X),
        Z = mochi_safe_div((V_3 - 1.0), (V_3 + 1.0)),
        Zpow = Z,
        Sum = Z,
        I = 3,
        Fun_3 = fun Fun_3_loop(I, K_3, Sum, V_3, X, Z, Zpow) ->
    case (I =< 9) of
        true ->
            Zpow_2 = mochi_safe_mul(mochi_safe_mul(Zpow, Z), Z),
            Sum_2 = (Sum + mochi_safe_div(Zpow_2, float(I))),
            I_2 = (I + 2),
            Fun_3_loop(I_2, K_3, Sum_2, V_3, X, Z, Zpow_2);
        _ -> {I, K_3, Sum, V_3, X, Z, Zpow}
    end
end,
{I_2, K_3, Sum_2, V_3, X, Z, Zpow_2} = Fun_3(I, K_3, Sum, V_3, X, Z, Zpow),
        Ln2 = 0.6931471805599453,
        (K_3 + mochi_safe_div(mochi_safe_mul(2.0, Sum_2), 0.6931471805599453))
    catch {return, Ret} -> Ret end.

analyze_text(Text) ->
    try
        Single = #{},
        Double = #{},
        N = erlang:length(Text),
        case (N == 0) of
        true -> throw({return, #{"single" => Single, "double" => Double}});
        _ -> ok
    end,
        Last = string:substr(Text, (N - 1) + 1, (N - (N - 1))),
        case maps:is_key(Last, Single) of
        true -> Single_2 = maps:put(Last, (maps:get(Last, Single, nil) + 1), Single),
            Single_4 = Single_2;
        _ -> Single_3 = maps:put(Last, 1, Single),
            Single_4 = Single_3
    end,
        First = string:substr(Text, 0 + 1, (1 - 0)),
        Pair0 = (" " ++ First),
        Double_2 = maps:put(Pair0, 1, Double),
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(Double_2, First, I_3, Last, N, Pair0, Single_4, Text) ->
    case (I_3 < (N - 1)) of
        true ->
            Ch = string:substr(Text, I_3 + 1, ((I_3 + 1) - I_3)),
            case maps:is_key(Ch, Single_4) of
        true -> Single_5 = maps:put(Ch, (maps:get(Ch, Single_4, nil) + 1), Single_4),
            Single_7 = Single_5;
        _ -> Single_6 = maps:put(Ch, 1, Single_4),
            Single_7 = Single_6
    end,
            Seq = string:substr(Text, I_3 + 1, ((I_3 + 2) - I_3)),
            case maps:is_key(Seq, Double_2) of
        true -> Double_3 = maps:put(Seq, (maps:get(Seq, Double_2, nil) + 1), Double_2),
            Double_5 = Double_3;
        _ -> Double_4 = maps:put(Seq, 1, Double_2),
            Double_5 = Double_4
    end,
            I_4 = (I_3 + 1),
            Fun_4_loop(Double_5, First, I_4, Last, N, Pair0, Single_7, Text);
        _ -> {Double_2, First, I_3, Last, N, Pair0, Single_4, Text}
    end
end,
{Double_5, First, I_4, Last, N, Pair0, Single_7, Text} = Fun_4(Double_2, First, I_3, Last, N, Pair0, Single_4, Text),
        #{"single" => Single_7, "double" => Double_5}
    catch {return, Ret} -> Ret end.

round_to_int(X_2) ->
    try
        (case (X_2 < 0.0) of
    true -> mochi_to_int((X_2 - 0.5));
    _ -> mochi_to_int((X_2 + 0.5))
end)
    catch {return, Ret} -> Ret end.

calculate_entropy(Text_2) ->
    try
        Counts = analyze_text(Text_2),
        Alphas = " abcdefghijklmnopqrstuvwxyz",
        Total1 = 0,
        Fun_5 = fun Fun_5_loop(List, Alphas, Counts, Text_2, Total1) ->
    case List of
        [] -> {Alphas, Counts, Text_2, Total1};
        [Ch_2|Ch_2_rest] ->
            Total1_2 = (Total1 + maps:get(Ch_2, maps:get("single", Counts, nil), nil)),
            Fun_5_loop(Ch_2_rest, Alphas, Counts, Text_2, Total1_2);
        _ -> {Alphas, Counts, Text_2, Total1}
    end
end,
{Alphas, Counts, Text_2, Total1_2} = Fun_5(maps:keys(maps:get("single", Counts, nil)), Alphas, Counts, Text_2, Total1),
        H1 = 0.0,
        I_5 = 0,
        Fun_6 = fun Fun_6_loop(Alphas, Counts, H1, I_5, Text_2, Total1_2) ->
    case (I_5 < erlang:length(Alphas)) of
        true ->
            Ch_3 = string:substr(Alphas, I_5 + 1, ((I_5 + 1) - I_5)),
            case maps:is_key(Ch_3, maps:get("single", Counts, nil)) of
        true -> Prob = mochi_safe_div(float(maps:get(Ch_3, maps:get("single", Counts, nil), nil)), float(Total1_2)),
            H1_2 = (H1 + mochi_safe_mul(Prob, log2(Prob))),
            H1_3 = H1_2,
            Prob_2 = Prob;
        _ -> H1_3 = H1,
            Prob_2 = nil
    end,
            I_6 = (I_5 + 1),
            Fun_6_loop(Alphas, Counts, H1_3, I_6, Text_2, Total1_2);
        _ -> {Alphas, Counts, H1, I_5, Text_2, Total1_2}
    end
end,
{Alphas, Counts, H1_3, I_6, Text_2, Total1_2} = Fun_6(Alphas, Counts, H1, I_5, Text_2, Total1_2),
        First_entropy = -H1_3,
        io:format("~ts~n", [mochi_repr((mochi_str(round_to_int(First_entropy)) ++ ".0"))]),
        Total2 = 0,
        Fun_7 = fun Fun_7_loop(List, Alphas, Counts, First_entropy, H1_3, I_6, Text_2, Total1_2, Total2) ->
    case List of
        [] -> {Alphas, Counts, First_entropy, H1_3, I_6, Text_2, Total1_2, Total2};
        [Seq_2|Seq_2_rest] ->
            Total2_2 = (Total2 + maps:get(Seq_2, maps:get("double", Counts, nil), nil)),
            Fun_7_loop(Seq_2_rest, Alphas, Counts, First_entropy, H1_3, I_6, Text_2, Total1_2, Total2_2);
        _ -> {Alphas, Counts, First_entropy, H1_3, I_6, Text_2, Total1_2, Total2}
    end
end,
{Alphas, Counts, First_entropy, H1_3, I_6, Text_2, Total1_2, Total2_2} = Fun_7(maps:keys(maps:get("double", Counts, nil)), Alphas, Counts, First_entropy, H1_3, I_6, Text_2, Total1_2, Total2),
        H2 = 0.0,
        A0 = 0,
        Fun_9 = fun Fun_9_loop(A0, Alphas, Counts, First_entropy, H1_3, H2, I_6, Text_2, Total1_2, Total2_2) ->
    case (A0 < erlang:length(Alphas)) of
        true ->
            Ch0 = string:substr(Alphas, A0 + 1, ((A0 + 1) - A0)),
            A1 = 0,
            Fun_8 = fun Fun_8_loop(A0, A1, Alphas, Ch0, Counts, First_entropy, H1_3, H2, I_6, Text_2, Total1_2, Total2_2) ->
    case (A1 < erlang:length(Alphas)) of
        true ->
            Ch1 = string:substr(Alphas, A1 + 1, ((A1 + 1) - A1)),
            Seq_3 = (Ch0 ++ Ch1),
            case maps:is_key(Seq_3, maps:get("double", Counts, nil)) of
        true -> Prob_3 = mochi_safe_div(float(maps:get(Seq_3, maps:get("double", Counts, nil), nil)), float(Total2_2)),
            H2_2 = (H2 + mochi_safe_mul(Prob_3, log2(Prob_3))),
            H2_3 = H2_2,
            Prob_4 = Prob_3;
        _ -> H2_3 = H2,
            Prob_4 = nil
    end,
            A1_2 = (A1 + 1),
            Fun_8_loop(A0, A1_2, Alphas, Ch0, Counts, First_entropy, H1_3, H2_3, I_6, Text_2, Total1_2, Total2_2);
        _ -> {A0, A1, Alphas, Ch0, Counts, First_entropy, H1_3, H2, I_6, Text_2, Total1_2, Total2_2}
    end
end,
{A0, A1_2, Alphas, Ch0, Counts, First_entropy, H1_3, H2_3, I_6, Text_2, Total1_2, Total2_2} = Fun_8(A0, A1, Alphas, Ch0, Counts, First_entropy, H1_3, H2, I_6, Text_2, Total1_2, Total2_2),
            A0_2 = (A0 + 1),
            Fun_9_loop(A0_2, Alphas, Counts, First_entropy, H1_3, H2_3, I_6, Text_2, Total1_2, Total2_2);
        _ -> {A0, Alphas, Counts, First_entropy, H1_3, H2, I_6, Text_2, Total1_2, Total2_2}
    end
end,
{A0_2, Alphas, Counts, First_entropy, H1_3, H2_3, I_6, Text_2, Total1_2, Total2_2} = Fun_9(A0, Alphas, Counts, First_entropy, H1_3, H2, I_6, Text_2, Total1_2, Total2_2),
        Second_entropy = -H2_3,
        io:format("~ts~n", [mochi_repr((mochi_str(round_to_int(Second_entropy)) ++ ".0"))]),
        Diff = (Second_entropy - First_entropy),
        io:format("~ts~n", [mochi_repr((mochi_str(round_to_int(Diff)) ++ ".0"))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('text1', (("Behind Winston's back the voice " ++ "from the telescreen was still ") ++ "babbling and the overfulfilment")),
    calculate_entropy(erlang:get('text1')),
    erlang:put('text3', (((((((((("Had repulsive dashwoods suspicion sincerity but advantage now him. " ++ "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. ") ++ "You greatest jointure saw horrible. He private he on be imagine ") ++ "suppose. Fertile beloved evident through no service elderly is. Blind ") ++ "there if every no so at. Own neglected you preferred way sincerity ") ++ "delivered his attempted. To of message cottage windows do besides ") ++ "against uncivil.  Delightful unreserved impossible few estimating ") ++ "men favourable see entreaties. She propriety immediate was improving. ") ++ "He or entrance humoured likewise moderate. Much nor game son say ") ++ "feel. Fat make met can must form into gate. Me we offending prevailed ") ++ "discovery.")),
    calculate_entropy(erlang:get('text3')),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
