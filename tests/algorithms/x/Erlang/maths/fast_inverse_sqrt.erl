#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pow2_int/1, pow2_float/1, lshift/2, rshift/2, log2_floor/1, float_to_bits/1, bits_to_float/1, absf/1, sqrtapprox/1, is_close/3, fast_inverse_sqrt/1, test_fast_inverse_sqrt/0, main/0]).

% Generated by Mochi transpiler v0.10.59 (589dcb03e5) on 2025-08-07 12:04 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.


mochi_mod(A, B) ->
    A1 = case erlang:is_float(A) of
        true -> trunc(A);
        _ -> A
    end,
    B1 = case erlang:is_float(B) of
        true -> trunc(B);
        _ -> B
    end,
    case B1 of
        0 -> 0;
        _ -> ((A1 rem B1) + B1) rem B1
    end.

pow2_int(N) ->
    try
        Result = 1,
        I = 0,
        Fun = fun Fun_loop(I, N, Result) ->
    case (I < N) of
        true ->
            Result_2 = (Result * 2),
            I_2 = (I + 1),
            Fun_loop(I_2, N, Result_2);
        _ -> {I, N, Result}
    end
end,
{I_2, N, Result_2} = Fun(I, N, Result),
        Result_2
    catch {return, Ret} -> Ret end.

pow2_float(N_2) ->
    try
        Result_3 = 1.0,
        case (N_2 >= 0) of
        true -> I_3 = 0,
            Fun_2 = fun Fun_2_loop(I_3, N_2, Result_3) ->
    case (I_3 < N_2) of
        true ->
            Result_4 = mochi_safe_mul(Result_3, 2.0),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, N_2, Result_4);
        _ -> {I_3, N_2, Result_3}
    end
end,
{I_4, N_2, Result_4} = Fun_2(I_3, N_2, Result_3),
            Fun_4 = Fun_2,
            I_7 = I_4,
            M_2 = nil,
            Result_6 = Result_4;
        _ -> I_5 = 0,
            M = (0 - N_2),
            Fun_3 = fun Fun_3_loop(I_5, M, N_2, Result_3) ->
    case (I_5 < M) of
        true ->
            Result_5 = mochi_safe_div(Result_3, 2.0),
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, M, N_2, Result_5);
        _ -> {I_5, M, N_2, Result_3}
    end
end,
{I_6, M, N_2, Result_5} = Fun_3(I_5, M, N_2, Result_3),
            Fun_4 = Fun_3,
            I_7 = I_6,
            M_2 = M,
            Result_6 = Result_5
    end,
        Result_6
    catch {return, Ret} -> Ret end.

lshift(Num, K) ->
    try
        Result_7 = Num,
        I_8 = 0,
        Fun_5 = fun Fun_5_loop(I_8, K, Num, Result_7) ->
    case (I_8 < K) of
        true ->
            Result_8 = (Result_7 * 2),
            I_9 = (I_8 + 1),
            Fun_5_loop(I_9, K, Num, Result_8);
        _ -> {I_8, K, Num, Result_7}
    end
end,
{I_9, K, Num, Result_8} = Fun_5(I_8, K, Num, Result_7),
        Result_8
    catch {return, Ret} -> Ret end.

rshift(Num_2, K_2) ->
    try
        Result_9 = Num_2,
        I_10 = 0,
        Fun_6 = fun Fun_6_loop(I_10, K_2, Num_2, Result_9) ->
    case (I_10 < K_2) of
        true ->
            Result_10 = mochi_safe_div((Result_9 - mochi_mod(Result_9, 2)), 2),
            I_11 = (I_10 + 1),
            Fun_6_loop(I_11, K_2, Num_2, Result_10);
        _ -> {I_10, K_2, Num_2, Result_9}
    end
end,
{I_11, K_2, Num_2, Result_10} = Fun_6(I_10, K_2, Num_2, Result_9),
        Result_10
    catch {return, Ret} -> Ret end.

log2_floor(X) ->
    try
        N_3 = X,
        E = 0,
        Fun_7 = fun Fun_7_loop(E, N_3, X) ->
    case (N_3 >= 2.0) of
        true ->
            N_4 = mochi_safe_div(N_3, 2.0),
            E_2 = (E + 1),
            Fun_7_loop(E_2, N_4, X);
        _ -> {E, N_3, X}
    end
end,
{E_2, N_4, X} = Fun_7(E, N_3, X),
        Fun_8 = fun Fun_8_loop(E_2, N_4, X) ->
    case (N_4 < 1.0) of
        true ->
            N_5 = mochi_safe_mul(N_4, 2.0),
            E_3 = (E_2 - 1),
            Fun_8_loop(E_3, N_5, X);
        _ -> {E_2, N_4, X}
    end
end,
{E_3, N_5, X} = Fun_8(E_2, N_4, X),
        E_3
    catch {return, Ret} -> Ret end.

float_to_bits(X_2) ->
    try
        Num_3 = X_2,
        Sign = 0,
        case (Num_3 < 0.0) of
        true -> Sign_2 = 1,
            Num_4 = -Num_3,
            Num_5 = Num_4,
            Sign_3 = Sign_2;
        _ -> Num_5 = Num_3,
            Sign_3 = Sign
    end,
        Exp = log2_floor(Num_5),
        Pow = pow2_float(Exp),
        Normalized = mochi_safe_div(Num_5, Pow),
        Frac = (Normalized - 1.0),
        Mantissa = mochi_to_int(mochi_safe_mul(Frac, pow2_float(23))),
        Exp_bits = (Exp + 127),
        ((lshift(Sign_3, 31) + lshift(Exp_bits, 23)) + Mantissa)
    catch {return, Ret} -> Ret end.

bits_to_float(Bits) ->
    try
        Sign_bit = mochi_mod(rshift(Bits, 31), 2),
        Sign_4 = 1.0,
        case (Sign_bit == 1) of
        true -> Sign_5 = -1.0,
            Sign_6 = Sign_5;
        _ -> Sign_6 = Sign_4
    end,
        Exp_bits_2 = mochi_mod(rshift(Bits, 23), 256),
        Exp_2 = (Exp_bits_2 - 127),
        Mantissa_bits = mochi_mod(Bits, pow2_int(23)),
        Mantissa_2 = (1.0 + mochi_safe_div(float(Mantissa_bits), pow2_float(23))),
        mochi_safe_mul(mochi_safe_mul(Sign_6, Mantissa_2), pow2_float(Exp_2))
    catch {return, Ret} -> Ret end.

absf(X_3) ->
    try
        (case (X_3 < 0.0) of
    true -> -X_3;
    _ -> X_3
end)
    catch {return, Ret} -> Ret end.

sqrtapprox(X_4) ->
    try
        case (X_4 =< 0.0) of
        true -> throw({return, 0.0});
        _ -> ok
    end,
        Guess = mochi_safe_div(X_4, 2.0),
        I_12 = 0,
        Fun_9 = fun Fun_9_loop(Guess, I_12, X_4) ->
    case (I_12 < 20) of
        true ->
            Guess_2 = mochi_safe_div((Guess + mochi_safe_div(X_4, Guess)), 2.0),
            I_13 = (I_12 + 1),
            Fun_9_loop(Guess_2, I_13, X_4);
        _ -> {Guess, I_12, X_4}
    end
end,
{Guess_2, I_13, X_4} = Fun_9(Guess, I_12, X_4),
        Guess_2
    catch {return, Ret} -> Ret end.

is_close(A, B, Rel_tol) ->
    try
        (absf((A - B)) =< mochi_safe_mul(Rel_tol, absf(B)))
    catch {return, Ret} -> Ret end.

fast_inverse_sqrt(Number) ->
    try
        case (Number =< 0.0) of
        true -> erlang:error("Input must be a positive number.");
        _ -> ok
    end,
        I_14 = float_to_bits(Number),
        Magic = 1597463007,
        Y_bits = (1597463007 - rshift(I_14, 1)),
        Y = bits_to_float(Y_bits),
        Y_2 = mochi_safe_mul(Y, (1.5 - mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(0.5, Number), Y), Y))),
        Y_2
    catch {return, Ret} -> Ret end.

test_fast_inverse_sqrt() ->
    try
        case (absf((fast_inverse_sqrt(10.0) - 0.3156857923527257)) > 0.0001) of
        true -> erlang:error("fast_inverse_sqrt(10) failed");
        _ -> ok
    end,
        case (absf((fast_inverse_sqrt(4.0) - 0.49915357479239103)) > 0.0001) of
        true -> erlang:error("fast_inverse_sqrt(4) failed");
        _ -> ok
    end,
        case (absf((fast_inverse_sqrt(4.1) - 0.4932849504615651)) > 0.0001) of
        true -> erlang:error("fast_inverse_sqrt(4.1) failed");
        _ -> ok
    end,
        I_15 = 50,
        Fun_10 = fun Fun_10_loop(I_15) ->
    case (I_15 < 60) of
        true ->
            Y_3 = fast_inverse_sqrt(float(I_15)),
            Actual = mochi_safe_div(1.0, sqrtapprox(float(I_15))),
            case mochi_not(is_close(Y_3, Actual, 0.00132)) of
        true -> erlang:error("relative error too high");
        _ -> ok
    end,
            I_16 = (I_15 + 1),
            Fun_10_loop(I_16);
        _ -> {I_15}
    end
end,
{I_16} = Fun_10(I_15),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        test_fast_inverse_sqrt(),
        I_17 = 5,
        Fun_11 = fun Fun_11_loop(I_17) ->
    case (I_17 =< 100) of
        true ->
            Diff = (mochi_safe_div(1.0, sqrtapprox(float(I_17))) - fast_inverse_sqrt(float(I_17))),
            io:format("~ts~n", [mochi_repr(((mochi_str(I_17) ++ ": ") ++ mochi_str(Diff)))]),
            I_18 = (I_17 + 5),
            Fun_11_loop(I_18);
        _ -> {I_17}
    end
end,
{I_18} = Fun_11(I_17),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
