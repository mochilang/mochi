#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, minf/2, maxf/2, vol_cube/1, vol_spherical_cap/2, vol_sphere/1, vol_spheres_intersect/3, vol_spheres_union/3, vol_cuboid/3, vol_cone/2, vol_right_circ_cone/2, vol_prism/2, vol_pyramid/2, vol_hemisphere/1, vol_circular_cylinder/2, vol_hollow_circular_cylinder/3, vol_conical_frustum/3, vol_torus/2, vol_icosahedron/1, main/0]).

% Generated by Mochi transpiler v0.10.60 (6899ff50f4) on 2025-08-07 16:25 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_nth(I, L) ->
    try lists:nth(I, L) catch _:_ -> nil end.


-compile({nowarn_unused_function, mochi_str/1}).
mochi_str(V) when is_float(V) ->
    S = erlang:float_to_list(V, [short]),
    case lists:suffix(".0", S) of
        true -> lists:sublist(S, length(S) - 2);
        false -> S
    end;
mochi_str(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    S1 = lists:flatten(string:replace(S, ",", " ", all)),
    lists:flatten(string:replace(S1, "\"", "", all)).


-compile({nowarn_unused_function, mochi_repr/1}).
mochi_repr(V) ->
    S = lists:flatten(io_lib:format("~p", [V])),
    lists:flatten(string:replace(S, ",", ", ", all)).


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try
        case erlang:is_integer(A) andalso erlang:is_integer(B) of
            true ->
                case B of
                    0 -> 0;
                    _ -> A div B
                end;
            false -> A / B
        end
    catch _:_ -> 0.0 end.

minf(A, B) ->
    try
        (case (A < B) of
    true -> A;
    _ -> B
end)
    catch {return, Ret} -> Ret end.

maxf(A_2, B_2) ->
    try
        (case (A_2 > B_2) of
    true -> A_2;
    _ -> B_2
end)
    catch {return, Ret} -> Ret end.

vol_cube(Side_length) ->
    try
        case (Side_length < 0.0) of
        true -> erlang:error("vol_cube() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_mul(mochi_safe_mul(Side_length, Side_length), Side_length)
    catch {return, Ret} -> Ret end.

vol_spherical_cap(Height, Radius) ->
    try
        case ((Height < 0.0) orelse (Radius < 0.0)) of
        true -> erlang:error("vol_spherical_cap() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(mochi_safe_div(1.0, 3.0), 3.141592653589793), Height), Height), (mochi_safe_mul(3.0, Radius) - Height))
    catch {return, Ret} -> Ret end.

vol_sphere(Radius_2) ->
    try
        case (Radius_2 < 0.0) of
        true -> erlang:error("vol_sphere() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(mochi_safe_div(4.0, 3.0), 3.141592653589793), Radius_2), Radius_2), Radius_2)
    catch {return, Ret} -> Ret end.

vol_spheres_intersect(Radius_1, Radius_2, Centers_distance) ->
    try
        case (((Radius_1 < 0.0) orelse (Radius_2 < 0.0)) orelse (Centers_distance < 0.0)) of
        true -> erlang:error("vol_spheres_intersect() only accepts non-negative values");
        _ -> ok
    end,
        case (Centers_distance == 0.0) of
        true -> throw({return, vol_sphere(minf(Radius_1, Radius_2))});
        _ -> ok
    end,
        H1 = mochi_safe_div(mochi_safe_mul(((Radius_1 - Radius_2) + Centers_distance), ((Radius_1 + Radius_2) - Centers_distance)), mochi_safe_mul(2.0, Centers_distance)),
        H2 = mochi_safe_div(mochi_safe_mul(((Radius_2 - Radius_1) + Centers_distance), ((Radius_2 + Radius_1) - Centers_distance)), mochi_safe_mul(2.0, Centers_distance)),
        (vol_spherical_cap(H1, Radius_2) + vol_spherical_cap(H2, Radius_1))
    catch {return, Ret} -> Ret end.

vol_spheres_union(Radius_1_2, Radius_2_2, Centers_distance_2) ->
    try
        case (((Radius_1_2 =< 0.0) orelse (Radius_2_2 =< 0.0)) orelse (Centers_distance_2 < 0.0)) of
        true -> erlang:error("vol_spheres_union() only accepts non-negative values, non-zero radius");
        _ -> ok
    end,
        case (Centers_distance_2 == 0.0) of
        true -> throw({return, vol_sphere(maxf(Radius_1_2, Radius_2_2))});
        _ -> ok
    end,
        ((vol_sphere(Radius_1_2) + vol_sphere(Radius_2_2)) - vol_spheres_intersect(Radius_1_2, Radius_2_2, Centers_distance_2))
    catch {return, Ret} -> Ret end.

vol_cuboid(Width, Height_2, Length) ->
    try
        case (((Width < 0.0) orelse (Height_2 < 0.0)) orelse (Length < 0.0)) of
        true -> erlang:error("vol_cuboid() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_mul(mochi_safe_mul(Width, Height_2), Length)
    catch {return, Ret} -> Ret end.

vol_cone(Area_of_base, Height_3) ->
    try
        case ((Height_3 < 0.0) orelse (Area_of_base < 0.0)) of
        true -> erlang:error("vol_cone() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_div(mochi_safe_mul(Area_of_base, Height_3), 3.0)
    catch {return, Ret} -> Ret end.

vol_right_circ_cone(Radius_3, Height_4) ->
    try
        case ((Height_4 < 0.0) orelse (Radius_3 < 0.0)) of
        true -> erlang:error("vol_right_circ_cone() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_div(mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(3.141592653589793, Radius_3), Radius_3), Height_4), 3.0)
    catch {return, Ret} -> Ret end.

vol_prism(Area_of_base_2, Height_5) ->
    try
        case ((Height_5 < 0.0) orelse (Area_of_base_2 < 0.0)) of
        true -> erlang:error("vol_prism() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_mul(Area_of_base_2, Height_5)
    catch {return, Ret} -> Ret end.

vol_pyramid(Area_of_base_3, Height_6) ->
    try
        case ((Height_6 < 0.0) orelse (Area_of_base_3 < 0.0)) of
        true -> erlang:error("vol_pyramid() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_div(mochi_safe_mul(Area_of_base_3, Height_6), 3.0)
    catch {return, Ret} -> Ret end.

vol_hemisphere(Radius_4) ->
    try
        case (Radius_4 < 0.0) of
        true -> erlang:error("vol_hemisphere() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_div(mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(Radius_4, Radius_4), Radius_4), 3.141592653589793), 2.0), 3.0)
    catch {return, Ret} -> Ret end.

vol_circular_cylinder(Radius_5, Height_7) ->
    try
        case ((Height_7 < 0.0) orelse (Radius_5 < 0.0)) of
        true -> erlang:error("vol_circular_cylinder() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(Radius_5, Radius_5), Height_7), 3.141592653589793)
    catch {return, Ret} -> Ret end.

vol_hollow_circular_cylinder(Inner_radius, Outer_radius, Height_8) ->
    try
        case (((Inner_radius < 0.0) orelse (Outer_radius < 0.0)) orelse (Height_8 < 0.0)) of
        true -> erlang:error("vol_hollow_circular_cylinder() only accepts non-negative values");
        _ -> ok
    end,
        case (Outer_radius =< Inner_radius) of
        true -> erlang:error("outer_radius must be greater than inner_radius");
        _ -> ok
    end,
        mochi_safe_mul(mochi_safe_mul(3.141592653589793, (mochi_safe_mul(Outer_radius, Outer_radius) - mochi_safe_mul(Inner_radius, Inner_radius))), Height_8)
    catch {return, Ret} -> Ret end.

vol_conical_frustum(Height_9, Radius_1_3, Radius_2_3) ->
    try
        case (((Radius_1_3 < 0.0) orelse (Radius_2_3 < 0.0)) orelse (Height_9 < 0.0)) of
        true -> erlang:error("vol_conical_frustum() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(mochi_safe_div(1.0, 3.0), 3.141592653589793), Height_9), ((mochi_safe_mul(Radius_1_3, Radius_1_3) + mochi_safe_mul(Radius_2_3, Radius_2_3)) + mochi_safe_mul(Radius_1_3, Radius_2_3)))
    catch {return, Ret} -> Ret end.

vol_torus(Torus_radius, Tube_radius) ->
    try
        case ((Torus_radius < 0.0) orelse (Tube_radius < 0.0)) of
        true -> erlang:error("vol_torus() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(2.0, 3.141592653589793), 3.141592653589793), Torus_radius), Tube_radius), Tube_radius)
    catch {return, Ret} -> Ret end.

vol_icosahedron(Tri_side) ->
    try
        case (Tri_side < 0.0) of
        true -> erlang:error("vol_icosahedron() only accepts non-negative values");
        _ -> ok
    end,
        mochi_safe_div(mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(mochi_safe_mul(Tri_side, Tri_side), Tri_side), (3.0 + 2.23606797749979)), 5.0), 12.0)
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", [mochi_repr("Volumes:")]),
        io:format("~ts~n", [mochi_repr(("Cube: " ++ mochi_str(vol_cube(2.0))))]),
        io:format("~ts~n", [mochi_repr(("Cuboid: " ++ mochi_str(vol_cuboid(2.0, 2.0, 2.0))))]),
        io:format("~ts~n", [mochi_repr(("Cone: " ++ mochi_str(vol_cone(2.0, 2.0))))]),
        io:format("~ts~n", [mochi_repr(("Right Circular Cone: " ++ mochi_str(vol_right_circ_cone(2.0, 2.0))))]),
        io:format("~ts~n", [mochi_repr(("Prism: " ++ mochi_str(vol_prism(2.0, 2.0))))]),
        io:format("~ts~n", [mochi_repr(("Pyramid: " ++ mochi_str(vol_pyramid(2.0, 2.0))))]),
        io:format("~ts~n", [mochi_repr(("Sphere: " ++ mochi_str(vol_sphere(2.0))))]),
        io:format("~ts~n", [mochi_repr(("Hemisphere: " ++ mochi_str(vol_hemisphere(2.0))))]),
        io:format("~ts~n", [mochi_repr(("Circular Cylinder: " ++ mochi_str(vol_circular_cylinder(2.0, 2.0))))]),
        io:format("~ts~n", [mochi_repr(("Torus: " ++ mochi_str(vol_torus(2.0, 2.0))))]),
        io:format("~ts~n", [mochi_repr(("Conical Frustum: " ++ mochi_str(vol_conical_frustum(2.0, 2.0, 4.0))))]),
        io:format("~ts~n", [mochi_repr(("Spherical cap: " ++ mochi_str(vol_spherical_cap(1.0, 2.0))))]),
        io:format("~ts~n", [mochi_repr(("Spheres intersection: " ++ mochi_str(vol_spheres_intersect(2.0, 2.0, 1.0))))]),
        io:format("~ts~n", [mochi_repr(("Spheres union: " ++ mochi_str(vol_spheres_union(2.0, 2.0, 1.0))))]),
        io:format("~ts~n", [mochi_repr(("Hollow Circular Cylinder: " ++ mochi_str(vol_hollow_circular_cylinder(1.0, 2.0, 3.0))))]),
        io:format("~ts~n", [mochi_repr(("Icosahedron: " ++ mochi_str(vol_icosahedron(2.5))))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('PI', 3.141592653589793),
    erlang:put('SQRT5', 2.23606797749979),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
