// Generated by Mochi v0.10.62 on 2025-08-09 10:36:03 GMT+7

export interface Significant_figures_color_values { Black: number; Brown: number; Red: number; Orange: number; Yellow: number; Green: number; Blue: number; Violet: number; Grey: number; White: number }
export interface Multiplier_color_values { Black: number; Brown: number; Red: number; Orange: number; Yellow: number; Green: number; Blue: number; Violet: number; Grey: number; White: number; Gold: number; Silver: number }
export interface Tolerance_color_values { Brown: number; Red: number; Orange: number; Yellow: number; Green: number; Blue: number; Violet: number; Grey: number; Gold: number; Silver: number }
export interface Temperature_coeffecient_color_values { Black: number; Brown: number; Red: number; Orange: number; Yellow: number; Green: number; Blue: number; Violet: number; Grey: number }
let valid_colors: string[] = ["Black", "Brown", "Red", "Orange", "Yellow", "Green", "Blue", "Violet", "Grey", "White", "Gold", "Silver"];
let significant_figures_color_values: Significant_figures_color_values = {"Black": 0, "Brown": 1, "Red": 2, "Orange": 3, "Yellow": 4, "Green": 5, "Blue": 6, "Violet": 7, "Grey": 8, "White": 9};
let multiplier_color_values: Multiplier_color_values = {"Black": 1.0, "Brown": 10.0, "Red": 100.0, "Orange": 1000.0, "Yellow": 10000.0, "Green": 100000.0, "Blue": 1000000.0, "Violet": 10000000.0, "Grey": 100000000.0, "White": 1000000000.0, "Gold": 0.1, "Silver": 0.01};
let tolerance_color_values: Tolerance_color_values = {"Brown": 1.0, "Red": 2.0, "Orange": 0.05, "Yellow": 0.02, "Green": 0.5, "Blue": 0.25, "Violet": 0.1, "Grey": 0.01, "Gold": 5.0, "Silver": 10.0};
let temperature_coeffecient_color_values: Temperature_coeffecient_color_values = {"Black": 250, "Brown": 100, "Red": 50, "Orange": 15, "Yellow": 25, "Green": 20, "Blue": 10, "Violet": 5, "Grey": 1};
function contains(list: string[], value: string): boolean {
  for (const c of list) {
    if ((c == value)) {
      return true;
    }
  }
  return false;
}
function get_significant_digits(colors: string[]): number {
  let digit: number = 0;
  for (const color of colors) {
    if (!(color in significant_figures_color_values)) {
      _panic((color + " is not a valid color for significant figure bands"));
    }
    digit = ((digit * 10) + significant_figures_color_values[color]);
  }
  return digit;
}
function get_multiplier(color: string): number {
  if (!(color in multiplier_color_values)) {
    _panic((color + " is not a valid color for multiplier band"));
  }
  return multiplier_color_values[color];
}
function get_tolerance(color: string): number {
  if (!(color in tolerance_color_values)) {
    _panic((color + " is not a valid color for tolerance band"));
  }
  return tolerance_color_values[color];
}
function get_temperature_coeffecient(color: string): number {
  if (!(color in temperature_coeffecient_color_values)) {
    _panic((color + " is not a valid color for temperature coeffecient band"));
  }
  return temperature_coeffecient_color_values[color];
}
function get_band_type_count(total: number, typ: string): number {
  if ((total == 3)) {
    if ((typ == "significant")) {
      return 2;
    }
    if ((typ == "multiplier")) {
      return 1;
    }
    _panic((typ + " is not valid for a 3 band resistor"));
  } else {
    if ((total == 4)) {
      if ((typ == "significant")) {
        return 2;
      }
      if ((typ == "multiplier")) {
        return 1;
      }
      if ((typ == "tolerance")) {
        return 1;
      }
      _panic((typ + " is not valid for a 4 band resistor"));
    } else {
      if ((total == 5)) {
        if ((typ == "significant")) {
          return 3;
        }
        if ((typ == "multiplier")) {
          return 1;
        }
        if ((typ == "tolerance")) {
          return 1;
        }
        _panic((typ + " is not valid for a 5 band resistor"));
      } else {
        if ((total == 6)) {
          if ((typ == "significant")) {
            return 3;
          }
          if ((typ == "multiplier")) {
            return 1;
          }
          if ((typ == "tolerance")) {
            return 1;
          }
          if ((typ == "temp_coeffecient")) {
            return 1;
          }
          _panic((typ + " is not valid for a 6 band resistor"));
        } else {
          _panic((_str(total) + " is not a valid number of bands"));
        }
      }
    }
  }
}
function check_validity(number_of_bands: number, colors: string[]): boolean {
  if (((number_of_bands < 3) || (number_of_bands > 6))) {
    _panic("Invalid number of bands. Resistor bands must be 3 to 6");
  }
  if ((number_of_bands != _len(colors))) {
    _panic((((("Expecting " + _str(number_of_bands)) + " colors, provided ") + _str(_len(colors))) + " colors"));
  }
  for (const color of colors) {
    if (!contains(valid_colors, color)) {
      _panic((color + " is not a valid color"));
    }
  }
  return true;
}
function calculate_resistance(number_of_bands: number, color_code_list: string[]): string {
  check_validity(number_of_bands, color_code_list);
  let sig_count: number = get_band_type_count(number_of_bands, "significant");
  let significant_colors: string[] = color_code_list.slice(0, sig_count);
  let significant_digits: number = get_significant_digits(significant_colors);
  let multiplier_color: string = color_code_list[(()=>{const _mochi_idx = sig_count; return _mochi_idx < 0 ? color_code_list.length + _mochi_idx : _mochi_idx;})()];
  let multiplier: number = get_multiplier(multiplier_color);
  let tolerance: number = 20.0;
  if ((number_of_bands >= 4)) {
    let tolerance_color: string = color_code_list[(()=>{const _mochi_idx = Math.trunc((sig_count + 1)); return _mochi_idx < 0 ? color_code_list.length + _mochi_idx : _mochi_idx;})()];
    tolerance = get_tolerance(tolerance_color);
  }
  let temp_coeff: number = 0;
  if ((number_of_bands == 6)) {
    let temp_color: string = color_code_list[(()=>{const _mochi_idx = Math.trunc((sig_count + 2)); return _mochi_idx < 0 ? color_code_list.length + _mochi_idx : _mochi_idx;})()];
    temp_coeff = get_temperature_coeffecient(temp_color);
  }
  let resistance_value: number = (multiplier * significant_digits);
  let resistance_str: string = _str(resistance_value);
  if ((resistance_value == Math.trunc(resistance_value))) {
    resistance_str = _str(Math.trunc(resistance_value));
  }
  let answer: string = (((resistance_str + "Ω ±") + _str(tolerance)) + "% ");
  if ((temp_coeff != 0)) {
    answer = ((answer + _str(temp_coeff)) + " ppm/K");
  }
  return answer;
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  if (typeof performance !== 'undefined' && (performance as any).memory) {
    return (performance as any).memory.usedJSHeapSize;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
function _panic(msg: any): never { throw new Error(String(msg)); }
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

