// Generated by Mochi v0.10.66 on 2025-08-15 10:29:08 GMT+7

let W1: number = 1.0;
let W2: number = 1.0;
let n: number = 20;
let n_heuristic: number = 3;
export interface Pos { x: number; y: number }
export interface PQNode { pos: Pos; pri: number }
export interface PQPopResult { pq: PQNode[]; node: PQNode }
let INF: number = 1000000000.0;
let t: number = 1;
function pos_equal(a: Pos, b: Pos): boolean {
  return ((a.x === b.x) && (a.y === b.y));
}
function pos_key(p: Pos): string {
  return ((_str(p.x) + ",") + _str(p.y));
}
function sqrtApprox(x: number): number {
  if ((x <= 0.0)) {
    return 0.0;
  }
  let guess: number = x;
  let i: number = 0;
  while ((i < 10)) {
    guess = ((guess + (x / guess)) / 2.0);
    i = (i + 1);
  }
  return guess;
}
function consistent_heuristic(p: Pos, goal: Pos): number {
  let dx: number = (p.x - goal.x);
  let dy: number = (p.y - goal.y);
  return sqrtApprox(((dx * dx) + (dy * dy)));
}
function iabs(x: number): number {
  if ((x < 0)) {
    return -x;
  }
  return x;
}
function heuristic_1(p: Pos, goal: Pos): number {
  return (iabs((p.x - goal.x)) + iabs((p.y - goal.y)));
}
function heuristic_2(p: Pos, goal: Pos): number {
  let h: number = consistent_heuristic(p, goal);
  return (h / t);
}
function heuristic(i: number, p: Pos, goal: Pos): number {
  if ((i === 0)) {
    return consistent_heuristic(p, goal);
  }
  if ((i === 1)) {
    return heuristic_1(p, goal);
  }
  return heuristic_2(p, goal);
}
function key_fn(start: Pos, i: number, goal: Pos, g_func: Record<string, number>): number {
  let g: number = g_func[pos_key(start)];
  return (g + (W1 * heuristic(i, start, goal)));
}
function valid(p: Pos): boolean {
  if (((p.x < 0) || (p.x > (n - 1)))) {
    return false;
  }
  if (((p.y < 0) || (p.y > (n - 1)))) {
    return false;
  }
  return true;
}
let blocks: Pos[] = [{x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1}, {x: 3, y: 1}, {x: 4, y: 1}, {x: 5, y: 1}, {x: 6, y: 1}, {x: 7, y: 1}, {x: 8, y: 1}, {x: 9, y: 1}, {x: 10, y: 1}, {x: 11, y: 1}, {x: 12, y: 1}, {x: 13, y: 1}, {x: 14, y: 1}, {x: 15, y: 1}, {x: 16, y: 1}, {x: 17, y: 1}, {x: 18, y: 1}, {x: 19, y: 1}];
function in_blocks(p: Pos): boolean {
  let i: number = 0;
  while ((i < _len(blocks))) {
    if (pos_equal(blocks[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? blocks.length + _mochi_idx : _mochi_idx;})()], p)) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function pq_put(pq: PQNode[], node: Pos, pri: number): PQNode[] {
  let updated: boolean = false;
  let i: number = 0;
  while ((i < _len(pq))) {
    if (pos_equal(pq[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()].pos, node)) {
      if ((pri < pq[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()].pri)) {
        pq[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()] = {pos: node, pri};
      }
      updated = true;
    }
    i = (i + 1);
  }
  if (!updated) {
    pq.push({pos: node, pri});
  }
  return pq;
}
function pq_minkey(pq: PQNode[]): number {
  if ((_len(pq) === 0)) {
    return INF;
  }
  let first: PQNode = pq[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()];
  let m = first.pri;
  let i: number = 1;
  while ((i < _len(pq))) {
    let item: PQNode = pq[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()];
    if ((item.pri < m)) {
      m = item.pri;
    }
    i = (i + 1);
  }
  return m;
}
function pq_pop_min(pq: PQNode[]): PQPopResult {
  let best: PQNode = pq[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()];
  let idx: number = 0;
  let i: number = 1;
  while ((i < _len(pq))) {
    if ((pq[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()].pri < best.pri)) {
      best = pq[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()];
      idx = i;
    }
    i = (i + 1);
  }
  let new_pq: PQNode[] = [];
  i = 0;
  while ((i < _len(pq))) {
    if ((i !== idx)) {
      new_pq.push(pq[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()]);
    }
    i = (i + 1);
  }
  return {pq: new_pq, node: best};
}
function pq_remove(pq: PQNode[], node: Pos): PQNode[] {
  let new_pq: PQNode[] = [];
  let i: number = 0;
  while ((i < _len(pq))) {
    if (!pos_equal(pq[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()].pos, node)) {
      new_pq.push(pq[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? pq.length + _mochi_idx : _mochi_idx;})()]);
    }
    i = (i + 1);
  }
  return new_pq;
}
function reconstruct(back_pointer: Record<string, Pos>, goal: Pos, start: Pos): Pos[] {
  let path: Pos[] = [];
  let current: Pos = goal;
  let key: string = pos_key(current);
  path.push(current);
  while (!pos_equal(current, start)) {
    current = back_pointer[key];
    key = pos_key(current);
    path.push(current);
  }
  let rev: Pos[] = [];
  let i: number = (_len(path) - 1);
  while ((i >= 0)) {
    rev.push(path[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? path.length + _mochi_idx : _mochi_idx;})()]);
    i = (i - 1);
  }
  return rev;
}
function neighbours(p: Pos): Pos[] {
  let left: Pos = {x: (p.x - 1), y: p.y};
  let right: Pos = {x: (p.x + 1), y: p.y};
  let up: Pos = {x: p.x, y: (p.y + 1)};
  let down: Pos = {x: p.x, y: (p.y - 1)};
  return [left, right, up, down];
}
function multi_a_star(start: Pos, goal: Pos, n_heuristic: number) {
  let g_function: Record<string, number> = {};
  let back_pointer: Record<string, Pos> = {};
  let visited: Record<string, boolean> = {};
  let open_list: PQNode[][] = [];
  g_function[(()=>{const _mochi_idx = pos_key(start); return _mochi_idx < 0 ? g_function.length + _mochi_idx : _mochi_idx;})()] = 0.0;
  g_function[(()=>{const _mochi_idx = pos_key(goal); return _mochi_idx < 0 ? g_function.length + _mochi_idx : _mochi_idx;})()] = INF;
  back_pointer[(()=>{const _mochi_idx = pos_key(start); return _mochi_idx < 0 ? back_pointer.length + _mochi_idx : _mochi_idx;})()] = {x: -1, y: -1};
  back_pointer[(()=>{const _mochi_idx = pos_key(goal); return _mochi_idx < 0 ? back_pointer.length + _mochi_idx : _mochi_idx;})()] = {x: -1, y: -1};
  visited[(()=>{const _mochi_idx = pos_key(start); return _mochi_idx < 0 ? visited.length + _mochi_idx : _mochi_idx;})()] = true;
  let i: number = 0;
  while ((i < n_heuristic)) {
    open_list.push([]);
    let pri: number = key_fn(start, i, goal, g_function);
    open_list[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()] = pq_put(open_list[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()], start, pri);
    i = (i + 1);
  }
  while ((pq_minkey(open_list[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()]) < INF)) {
    let chosen: number = 0;
    i = 1;
    while ((i < n_heuristic)) {
      if ((pq_minkey(open_list[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()]) <= (W2 * pq_minkey(open_list[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()])))) {
        chosen = i;
        break
      }
      i = (i + 1);
    }
    if ((chosen !== 0)) {
      t = (t + 1);
    }
    let pair: PQPopResult = pq_pop_min(open_list[(()=>{const _mochi_idx = chosen; return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()]);
    open_list[(()=>{const _mochi_idx = chosen; return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()] = pair.pq;
    let current: PQNode = pair.node;
    i = 0;
    while ((i < n_heuristic)) {
      if ((i !== chosen)) {
        open_list[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()] = pq_remove(open_list[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()], current.pos);
      }
      i = (i + 1);
    }
    let ckey: string = pos_key(current.pos);
    if ((ckey in visited)) {
      continue
    }
    visited[(()=>{const _mochi_idx = ckey; return _mochi_idx < 0 ? visited.length + _mochi_idx : _mochi_idx;})()] = true;
    if (pos_equal(current.pos, goal)) {
      let path: Pos[] = reconstruct(back_pointer, goal, start);
      let j: number = 0;
      while ((j < _len(path))) {
        let p: Pos = path[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? path.length + _mochi_idx : _mochi_idx;})()];
        console.log(_str((((("(" + _str(p.x)) + ",") + _str(p.y)) + ")")));
        j = (j + 1);
      }
      return;
    }
    let neighs: Pos[] = neighbours(current.pos);
    let k: number = 0;
    while ((k < _len(neighs))) {
      let nb: Pos = neighs[(()=>{const _mochi_idx = k; return _mochi_idx < 0 ? neighs.length + _mochi_idx : _mochi_idx;})()];
      if ((valid(nb) && (in_blocks(nb) === false))) {
        let nkey: string = pos_key(nb);
        let tentative: number = (g_function[ckey] + 1.0);
        if ((!(nkey in g_function) || (tentative < g_function[nkey]))) {
          g_function[(()=>{const _mochi_idx = nkey; return _mochi_idx < 0 ? g_function.length + _mochi_idx : _mochi_idx;})()] = tentative;
          back_pointer[(()=>{const _mochi_idx = nkey; return _mochi_idx < 0 ? back_pointer.length + _mochi_idx : _mochi_idx;})()] = current.pos;
          i = 0;
          while ((i < n_heuristic)) {
            let pri2: number = (tentative + (W1 * heuristic(i, nb, goal)));
            open_list[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()] = pq_put(open_list[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? open_list.length + _mochi_idx : _mochi_idx;})()], nb, pri2);
            i = (i + 1);
          }
        }
      }
      k = (k + 1);
    }
  }
  console.log(_str("No path found to goal"));
}
let start: Pos = {x: 0, y: 0};
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  if (typeof performance !== 'undefined' && (performance as any).memory) {
    return (performance as any).memory.usedJSHeapSize;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let goal: Pos
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
goal = {x: (n - 1), y: (n - 1)}
  multi_a_star(start, goal, n_heuristic);
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

