// Generated by Mochi v0.10.59 on 2025-08-06 23:28:49 GMT+7

let W1: number = 1.0;
let W2: number = 1.0;
let n: number = 20;
let n_heuristic: number = 3;
export interface Pos { x: number; y: number }
export interface PQNode { pos: Pos; pri: number }
export interface PQPopResult { pq: PQNode[]; node: PQNode }
let INF: number = 1000000000.0;
let t: number = 1;
function pos_equal(a: Pos, b: Pos): boolean {
  return ((a.x == b.x) && (a.y == b.y));
}
function pos_key(p: Pos): string {
  return ((_str(p.x) + ",") + _str(p.y));
}
function sqrtApprox(x: number): number {
  if ((x <= 0.0)) {
    return 0.0;
  }
  let guess: number = x;
  let i: number = 0;
  while ((i < 10)) {
    guess = ((guess + (x / guess)) / 2.0);
    i = (i + 1);
  }
  return guess;
}
function consistent_heuristic(p: Pos, goal: Pos): number {
  let dx: number = (p.x - goal.x);
  let dy: number = (p.y - goal.y);
  return sqrtApprox(((dx * dx) + (dy * dy)));
}
function iabs(x: number): number {
  if ((x < 0)) {
    return -x;
  }
  return x;
}
function heuristic_1(p: Pos, goal: Pos): number {
  return (iabs((p.x - goal.x)) + iabs((p.y - goal.y)));
}
function heuristic_2(p: Pos, goal: Pos): number {
  let h: number = consistent_heuristic(p, goal);
  return (h / t);
}
function heuristic(i: number, p: Pos, goal: Pos): number {
  if ((i == 0)) {
    return consistent_heuristic(p, goal);
  }
  if ((i == 1)) {
    return heuristic_1(p, goal);
  }
  return heuristic_2(p, goal);
}
function key_fn(start: Pos, i: number, goal: Pos, g_func: Record<string, number>): number {
  let g: number = g_func[pos_key(start)];
  return (g + (W1 * heuristic(i, start, goal)));
}
function valid(p: Pos): boolean {
  if (((p.x < 0) || (p.x > (n - 1)))) {
    return false;
  }
  if (((p.y < 0) || (p.y > (n - 1)))) {
    return false;
  }
  return true;
}
let blocks: Pos[] = [{"x": 0, "y": 1}, {"x": 1, "y": 1}, {"x": 2, "y": 1}, {"x": 3, "y": 1}, {"x": 4, "y": 1}, {"x": 5, "y": 1}, {"x": 6, "y": 1}, {"x": 7, "y": 1}, {"x": 8, "y": 1}, {"x": 9, "y": 1}, {"x": 10, "y": 1}, {"x": 11, "y": 1}, {"x": 12, "y": 1}, {"x": 13, "y": 1}, {"x": 14, "y": 1}, {"x": 15, "y": 1}, {"x": 16, "y": 1}, {"x": 17, "y": 1}, {"x": 18, "y": 1}, {"x": 19, "y": 1}];
function in_blocks(p: Pos): boolean {
  let i: number = 0;
  while ((i < _len(blocks))) {
    if (pos_equal(blocks[(i) < 0 ? blocks.length + (i) : i], p)) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function pq_put(pq: PQNode[], node: Pos, pri: number): PQNode[] {
  let updated: boolean = false;
  let i: number = 0;
  while ((i < _len(pq))) {
    if (pos_equal(pq[(i) < 0 ? pq.length + (i) : i].pos, node)) {
      if ((pri < pq[(i) < 0 ? pq.length + (i) : i].pri)) {
        pq[(i) < 0 ? pq.length + (i) : i] = {"pos": node, pri};
      }
      updated = true;
    }
    i = (i + 1);
  }
  if (!updated) {
    pq.push({"pos": node, pri});
  }
  return pq;
}
function pq_minkey(pq: PQNode[]): number {
  if ((_len(pq) == 0)) {
    return INF;
  }
  let first: PQNode = pq[(Math.trunc(0)) < 0 ? pq.length + (Math.trunc(0)) : Math.trunc(0)];
  let m = first.pri;
  let i: number = 1;
  while ((i < _len(pq))) {
    let item: PQNode = pq[(i) < 0 ? pq.length + (i) : i];
    if ((item.pri < m)) {
      m = item.pri;
    }
    i = (i + 1);
  }
  return m;
}
function pq_pop_min(pq: PQNode[]): PQPopResult {
  let best: PQNode = pq[(Math.trunc(0)) < 0 ? pq.length + (Math.trunc(0)) : Math.trunc(0)];
  let idx: number = 0;
  let i: number = 1;
  while ((i < _len(pq))) {
    if ((pq[(i) < 0 ? pq.length + (i) : i].pri < best.pri)) {
      best = pq[(i) < 0 ? pq.length + (i) : i];
      idx = i;
    }
    i = (i + 1);
  }
  let new_pq: PQNode[] = [];
  i = 0;
  while ((i < _len(pq))) {
    if ((i != idx)) {
      new_pq.push(pq[(i) < 0 ? pq.length + (i) : i]);
    }
    i = (i + 1);
  }
  return {"pq": new_pq, "node": best};
}
function pq_remove(pq: PQNode[], node: Pos): PQNode[] {
  let new_pq: PQNode[] = [];
  let i: number = 0;
  while ((i < _len(pq))) {
    if (!pos_equal(pq[(i) < 0 ? pq.length + (i) : i].pos, node)) {
      new_pq.push(pq[(i) < 0 ? pq.length + (i) : i]);
    }
    i = (i + 1);
  }
  return new_pq;
}
function reconstruct(back_pointer: Record<string, Pos>, goal: Pos, start: Pos): Pos[] {
  let path: Pos[] = [];
  let current: Pos = goal;
  let key: string = pos_key(current);
  path.push(current);
  while (!pos_equal(current, start)) {
    current = back_pointer[key];
    key = pos_key(current);
    path.push(current);
  }
  let rev: Pos[] = [];
  let i: number = (_len(path) - 1);
  while ((i >= 0)) {
    rev.push(path[(i) < 0 ? path.length + (i) : i]);
    i = (i - 1);
  }
  return rev;
}
function neighbours(p: Pos): Pos[] {
  let left: Pos = {"x": (p.x - 1), "y": p.y};
  let right: Pos = {"x": (p.x + 1), "y": p.y};
  let up: Pos = {"x": p.x, "y": (p.y + 1)};
  let down: Pos = {"x": p.x, "y": (p.y - 1)};
  return [left, right, up, down];
}
function multi_a_star(start: Pos, goal: Pos, n_heuristic: number) {
  let g_function: Record<string, number> = {};
  let back_pointer: Record<string, Pos> = {};
  let visited: Record<string, boolean> = {};
  let open_list: PQNode[][] = [];
  g_function[pos_key(start)] = 0.0;
  g_function[pos_key(goal)] = INF;
  back_pointer[pos_key(start)] = {"x": -1, "y": -1};
  back_pointer[pos_key(goal)] = {"x": -1, "y": -1};
  visited[pos_key(start)] = true;
  let i: number = 0;
  while ((i < n_heuristic)) {
    open_list.push([]);
    let pri: number = key_fn(start, i, goal, g_function);
    open_list[(i) < 0 ? open_list.length + (i) : i] = pq_put(open_list[(i) < 0 ? open_list.length + (i) : i], start, pri);
    i = (i + 1);
  }
  while ((pq_minkey(open_list[(Math.trunc(0)) < 0 ? open_list.length + (Math.trunc(0)) : Math.trunc(0)]) < INF)) {
    let chosen: number = 0;
    i = 1;
    while ((i < n_heuristic)) {
      if ((pq_minkey(open_list[(i) < 0 ? open_list.length + (i) : i]) <= (W2 * pq_minkey(open_list[(Math.trunc(0)) < 0 ? open_list.length + (Math.trunc(0)) : Math.trunc(0)])))) {
        chosen = i;
        break
      }
      i = (i + 1);
    }
    if ((chosen != 0)) {
      t = (t + 1);
    }
    let pair: PQPopResult = pq_pop_min(open_list[(chosen) < 0 ? open_list.length + (chosen) : chosen]);
    open_list[(chosen) < 0 ? open_list.length + (chosen) : chosen] = pair.pq;
    let current: PQNode = pair.node;
    i = 0;
    while ((i < n_heuristic)) {
      if ((i != chosen)) {
        open_list[(i) < 0 ? open_list.length + (i) : i] = pq_remove(open_list[(i) < 0 ? open_list.length + (i) : i], current.pos);
      }
      i = (i + 1);
    }
    let ckey: string = pos_key(current.pos);
    if ((ckey in visited)) {
      continue
    }
    visited[ckey] = true;
    if (pos_equal(current.pos, goal)) {
      let path: Pos[] = reconstruct(back_pointer, goal, start);
      let j: number = 0;
      while ((j < _len(path))) {
        let p: Pos = path[(j) < 0 ? path.length + (j) : j];
        console.log(_str((((("(" + _str(p.x)) + ",") + _str(p.y)) + ")")));
        j = (j + 1);
      }
      return;
    }
    let neighs: Pos[] = neighbours(current.pos);
    let k: number = 0;
    while ((k < _len(neighs))) {
      let nb: Pos = neighs[(k) < 0 ? neighs.length + (k) : k];
      if ((valid(nb) && (in_blocks(nb) == false))) {
        let nkey: string = pos_key(nb);
        let tentative: number = (g_function[ckey] + 1.0);
        if ((!(nkey in g_function) || (tentative < g_function[nkey]))) {
          g_function[nkey] = tentative;
          back_pointer[nkey] = current.pos;
          i = 0;
          while ((i < n_heuristic)) {
            let pri2: number = (tentative + (W1 * heuristic(i, nb, goal)));
            open_list[(i) < 0 ? open_list.length + (i) : i] = pq_put(open_list[(i) < 0 ? open_list.length + (i) : i], nb, pri2);
            i = (i + 1);
          }
        }
      }
      k = (k + 1);
    }
  }
  console.log(_str("No path found to goal"));
}
let start: Pos = {"x": 0, "y": 0};
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let goal: Pos
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
goal = {"x": (n - 1), "y": (n - 1)}
  multi_a_star(start, goal, n_heuristic);
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

