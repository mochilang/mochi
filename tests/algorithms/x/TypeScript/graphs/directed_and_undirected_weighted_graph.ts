// Generated by Mochi v0.10.59 on 2025-08-06 23:28:25 GMT+7

function list_contains_int(xs: number[], x: number): boolean {
  let i: number = 0;
  while ((i < _len(xs))) {
    if ((xs[(i) < 0 ? xs.length + (i) : i] == x)) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function edge_exists(edges: number[][], w: number, v: number): boolean {
  let i: number = 0;
  while ((i < _len(edges))) {
    if (((edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(0)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(0)) : Math.trunc(0)] == w) && (edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)] == v))) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function first_key(m: Record<number, number[][]>): number {
  for (const k in m) {
    return k;
  }
  return 0;
}
function rand_range(low: number, high: number): number {
  return ((_now() % (high - low)) + low);
}
export interface DirectedGraph { graph: Record<number, number[][]> }
function dg_make_graph(): DirectedGraph {
  return {"graph": {}};
}
function dg_add_pair(g: DirectedGraph, u: number, v: number, w: number) {
  if ((u in g.graph)) {
    let edges: number[][] = g.graph[u];
    if (!edge_exists(edges, w, v)) {
      edges.push([w, v]);
      let m: Record<number, number[][]> = g.graph;
      m[u] = edges;
      g.graph = m;
    }
  } else {
    let m0: Record<number, number[][]> = g.graph;
    m0[u] = [[w, v]];
    g.graph = m0;
  }
  if (!(v in g.graph)) {
    let m1: Record<number, number[][]> = g.graph;
    m1[v] = [];
    g.graph = m1;
  }
}
function dg_remove_pair(g: DirectedGraph, u: number, v: number) {
  if ((u in g.graph)) {
    let edges: number[][] = g.graph[u];
    let new_edges: number[][] = [];
    let i: number = 0;
    while ((i < _len(edges))) {
      if ((edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)] != v)) {
        new_edges.push(edges[(i) < 0 ? edges.length + (i) : i]);
      }
      i = (i + 1);
    }
    let m: Record<number, number[][]> = g.graph;
    m[u] = new_edges;
    g.graph = m;
  }
}
function dg_all_nodes(g: DirectedGraph): number[] {
  let res: number[] = [];
  for (const k in g.graph) {
    res.push(k);
  }
  return res;
}
function dg_dfs_util(g: DirectedGraph, node: number, visited: Record<number, boolean>, order: number[], d: number): number[] {
  visited[node] = true;
  order.push(node);
  if (((d != -1) && (node == d))) {
    return order;
  }
  let edges: number[][] = g.graph[node];
  let i: number = 0;
  while ((i < _len(edges))) {
    let neigh: number = edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)];
    if (!(neigh in visited)) {
      order = dg_dfs_util(g, neigh, visited, order, d);
      if (((d != -1) && (order[(Math.trunc((_len(order) - 1))) < 0 ? order.length + (Math.trunc((_len(order) - 1))) : Math.trunc((_len(order) - 1))] == d))) {
        return order;
      }
    }
    i = (i + 1);
  }
  return order;
}
function dg_dfs(g: DirectedGraph, s: number, d: number): number[] {
  if ((s == d)) {
    return [];
  }
  let start: number = ((s == -2) ? first_key(g.graph) : s);
  let visited: Record<number, boolean> = {};
  let order: number[] = [];
  order = dg_dfs_util(g, start, visited, order, d);
  return order;
}
function dg_bfs(g: DirectedGraph, s: number): number[] {
  let queue: number[] = [];
  let visited: Record<number, boolean> = {};
  let order: number[] = [];
  let start: number = ((s == -2) ? first_key(g.graph) : s);
  queue.push(start);
  visited[start] = true;
  while ((_len(queue) > 0)) {
    let node: number = queue[(Math.trunc(0)) < 0 ? queue.length + (Math.trunc(0)) : Math.trunc(0)];
    queue = queue.slice(1, _len(queue));
    order.push(node);
    let edges: number[][] = g.graph[node];
    let i: number = 0;
    while ((i < _len(edges))) {
      let neigh: number = edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)];
      if (!(neigh in visited)) {
        queue.push(neigh);
        visited[neigh] = true;
      }
      i = (i + 1);
    }
  }
  return order;
}
function dg_in_degree(g: DirectedGraph, u: number): number {
  let count: number = 0;
  for (const k in g.graph) {
    let edges: number[][] = g.graph[k];
    let i: number = 0;
    while ((i < _len(edges))) {
      if ((edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)] == u)) {
        count = (count + 1);
      }
      i = (i + 1);
    }
  }
  return count;
}
function dg_out_degree(g: DirectedGraph, u: number): number {
  if ((u in g.graph)) {
    return _len(g.graph[u]);
  }
  return 0;
}
function dg_topo_util(g: DirectedGraph, node: number, visited: Record<number, boolean>, stack: number[]): number[] {
  visited[node] = true;
  let edges: number[][] = g.graph[node];
  let i: number = 0;
  while ((i < _len(edges))) {
    let neigh: number = edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)];
    if (!(neigh in visited)) {
      stack = dg_topo_util(g, neigh, visited, stack);
    }
    i = (i + 1);
  }
  stack.push(node);
  return stack;
}
function dg_topological_sort(g: DirectedGraph): number[] {
  let visited: Record<number, boolean> = {};
  let stack: number[] = [];
  for (const k in g.graph) {
    if (!(k in visited)) {
      stack = dg_topo_util(g, k, visited, stack);
    }
  }
  let res: number[] = [];
  let i: number = (_len(stack) - 1);
  while ((i >= 0)) {
    res.push(stack[(i) < 0 ? stack.length + (i) : i]);
    i = (i - 1);
  }
  return res;
}
function dg_cycle_util(g: DirectedGraph, node: number, visited: Record<number, boolean>, rec: Record<number, boolean>, res: number[]): number[] {
  visited[node] = true;
  rec[node] = true;
  let edges: number[][] = g.graph[node];
  let i: number = 0;
  while ((i < _len(edges))) {
    let neigh: number = edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)];
    if (!(neigh in visited)) {
      res = dg_cycle_util(g, neigh, visited, rec, res);
    } else {
      if (rec[neigh]) {
        if (!list_contains_int(res, neigh)) {
          res.push(neigh);
        }
        if (!list_contains_int(res, node)) {
          res.push(node);
        }
      }
    }
    i = (i + 1);
  }
  rec[node] = false;
  return res;
}
function dg_cycle_nodes(g: DirectedGraph): number[] {
  let visited: Record<number, boolean> = {};
  let rec: Record<number, boolean> = {};
  let res: number[] = [];
  for (const k in g.graph) {
    if (!(k in visited)) {
      res = dg_cycle_util(g, k, visited, rec, res);
    }
  }
  return res;
}
function dg_has_cycle_util(g: DirectedGraph, node: number, visited: Record<number, boolean>, rec: Record<number, boolean>): boolean {
  visited[node] = true;
  rec[node] = true;
  let edges: number[][] = g.graph[node];
  let i: number = 0;
  while ((i < _len(edges))) {
    let neigh: number = edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)];
    if (!(neigh in visited)) {
      if (dg_has_cycle_util(g, neigh, visited, rec)) {
        return true;
      }
    } else {
      if (rec[neigh]) {
        return true;
      }
    }
    i = (i + 1);
  }
  rec[node] = false;
  return false;
}
function dg_has_cycle(g: DirectedGraph): boolean {
  let visited: Record<number, boolean> = {};
  let rec: Record<number, boolean> = {};
  for (const k in g.graph) {
    if (!(k in visited)) {
      if (dg_has_cycle_util(g, k, visited, rec)) {
        return true;
      }
    }
  }
  return false;
}
function dg_fill_graph_randomly(g: DirectedGraph, c: number) {
  let count: number = c;
  if ((count == -1)) {
    count = rand_range(10, 10010);
  }
  let i: number = 0;
  while ((i < count)) {
    let edge_count: number = rand_range(1, 103);
    let j: number = 0;
    while ((j < edge_count)) {
      let n = rand_range(0, count);
      if ((n != i)) {
        dg_add_pair(g, i, n, 1);
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
}
function dg_dfs_time(g: DirectedGraph, s: number, e: number): number {
  let begin: number = _now();
  dg_dfs(g, s, e);
  let end: number = _now();
  return (end - begin);
}
function dg_bfs_time(g: DirectedGraph, s: number): number {
  let begin: number = _now();
  dg_bfs(g, s);
  let end: number = _now();
  return (end - begin);
}
export interface Graph { graph: Record<number, number[][]> }
function g_make_graph(): Graph {
  return {"graph": {}};
}
function g_add_pair(g: Graph, u: number, v: number, w: number) {
  if ((u in g.graph)) {
    let edges: number[][] = g.graph[u];
    if (!edge_exists(edges, w, v)) {
      edges.push([w, v]);
      let m: Record<number, number[][]> = g.graph;
      m[u] = edges;
      g.graph = m;
    }
  } else {
    let m0: Record<number, number[][]> = g.graph;
    m0[u] = [[w, v]];
    g.graph = m0;
  }
  if ((v in g.graph)) {
    let edges2: number[][] = g.graph[v];
    if (!edge_exists(edges2, w, u)) {
      edges2.push([w, u]);
      let m2: Record<number, number[][]> = g.graph;
      m2[v] = edges2;
      g.graph = m2;
    }
  } else {
    let m3: Record<number, number[][]> = g.graph;
    m3[v] = [[w, u]];
    g.graph = m3;
  }
}
function g_remove_pair(g: Graph, u: number, v: number) {
  if ((u in g.graph)) {
    let edges: number[][] = g.graph[u];
    let new_edges: number[][] = [];
    let i: number = 0;
    while ((i < _len(edges))) {
      if ((edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)] != v)) {
        new_edges.push(edges[(i) < 0 ? edges.length + (i) : i]);
      }
      i = (i + 1);
    }
    let m: Record<number, number[][]> = g.graph;
    m[u] = new_edges;
    g.graph = m;
  }
  if ((v in g.graph)) {
    let edges2: number[][] = g.graph[v];
    let new_edges2: number[][] = [];
    let j: number = 0;
    while ((j < _len(edges2))) {
      if ((edges2[(j) < 0 ? edges2.length + (j) : j][(Math.trunc(1)) < 0 ? edges2[(j) < 0 ? edges2.length + (j) : j].length + (Math.trunc(1)) : Math.trunc(1)] != u)) {
        new_edges2.push(edges2[(j) < 0 ? edges2.length + (j) : j]);
      }
      j = (j + 1);
    }
    let m2: Record<number, number[][]> = g.graph;
    m2[v] = new_edges2;
    g.graph = m2;
  }
}
function g_all_nodes(g: Graph): number[] {
  let res: number[] = [];
  for (const k in g.graph) {
    res.push(k);
  }
  return res;
}
function g_dfs_util(g: Graph, node: number, visited: Record<number, boolean>, order: number[], d: number): number[] {
  visited[node] = true;
  order.push(node);
  if (((d != -1) && (node == d))) {
    return order;
  }
  let edges: number[][] = g.graph[node];
  let i: number = 0;
  while ((i < _len(edges))) {
    let neigh: number = edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)];
    if (!(neigh in visited)) {
      order = g_dfs_util(g, neigh, visited, order, d);
      if (((d != -1) && (order[(Math.trunc((_len(order) - 1))) < 0 ? order.length + (Math.trunc((_len(order) - 1))) : Math.trunc((_len(order) - 1))] == d))) {
        return order;
      }
    }
    i = (i + 1);
  }
  return order;
}
function g_dfs(g: Graph, s: number, d: number): number[] {
  if ((s == d)) {
    return [];
  }
  let start: number = ((s == -2) ? first_key(g.graph) : s);
  let visited: Record<number, boolean> = {};
  let order: number[] = [];
  order = g_dfs_util(g, start, visited, order, d);
  return order;
}
function g_bfs(g: Graph, s: number): number[] {
  let queue: number[] = [];
  let visited: Record<number, boolean> = {};
  let order: number[] = [];
  let start: number = ((s == -2) ? first_key(g.graph) : s);
  queue.push(start);
  visited[start] = true;
  while ((_len(queue) > 0)) {
    let node: number = queue[(Math.trunc(0)) < 0 ? queue.length + (Math.trunc(0)) : Math.trunc(0)];
    queue = queue.slice(1, _len(queue));
    order.push(node);
    let edges: number[][] = g.graph[node];
    let i: number = 0;
    while ((i < _len(edges))) {
      let neigh: number = edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)];
      if (!(neigh in visited)) {
        queue.push(neigh);
        visited[neigh] = true;
      }
      i = (i + 1);
    }
  }
  return order;
}
function g_degree(g: Graph, u: number): number {
  if ((u in g.graph)) {
    return _len(g.graph[u]);
  }
  return 0;
}
function g_cycle_util(g: Graph, node: number, visited: Record<number, boolean>, parent: number, res: number[]): number[] {
  visited[node] = true;
  let edges: number[][] = g.graph[node];
  let i: number = 0;
  while ((i < _len(edges))) {
    let neigh: number = edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)];
    if (!(neigh in visited)) {
      res = g_cycle_util(g, neigh, visited, node, res);
    } else {
      if ((neigh != parent)) {
        if (!list_contains_int(res, neigh)) {
          res.push(neigh);
        }
        if (!list_contains_int(res, node)) {
          res.push(node);
        }
      }
    }
    i = (i + 1);
  }
  return res;
}
function g_cycle_nodes(g: Graph): number[] {
  let visited: Record<number, boolean> = {};
  let res: number[] = [];
  for (const k in g.graph) {
    if (!(k in visited)) {
      res = g_cycle_util(g, k, visited, -1, res);
    }
  }
  return res;
}
function g_has_cycle_util(g: Graph, node: number, visited: Record<number, boolean>, parent: number): boolean {
  visited[node] = true;
  let edges: number[][] = g.graph[node];
  let i: number = 0;
  while ((i < _len(edges))) {
    let neigh: number = edges[(i) < 0 ? edges.length + (i) : i][(Math.trunc(1)) < 0 ? edges[(i) < 0 ? edges.length + (i) : i].length + (Math.trunc(1)) : Math.trunc(1)];
    if (!(neigh in visited)) {
      if (g_has_cycle_util(g, neigh, visited, node)) {
        return true;
      }
    } else {
      if ((neigh != parent)) {
        return true;
      }
    }
    i = (i + 1);
  }
  return false;
}
function g_has_cycle(g: Graph): boolean {
  let visited: Record<number, boolean> = {};
  for (const k in g.graph) {
    if (!(k in visited)) {
      if (g_has_cycle_util(g, k, visited, -1)) {
        return true;
      }
    }
  }
  return false;
}
function g_fill_graph_randomly(g: Graph, c: number) {
  let count: number = c;
  if ((count == -1)) {
    count = rand_range(10, 10010);
  }
  let i: number = 0;
  while ((i < count)) {
    let edge_count: number = rand_range(1, 103);
    let j: number = 0;
    while ((j < edge_count)) {
      let n = rand_range(0, count);
      if ((n != i)) {
        g_add_pair(g, i, n, 1);
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
}
function g_dfs_time(g: Graph, s: number, e: number): number {
  let begin: number = _now();
  g_dfs(g, s, e);
  let end: number = _now();
  return (end - begin);
}
function g_bfs_time(g: Graph, s: number): number {
  let begin: number = _now();
  g_bfs(g, s);
  let end: number = _now();
  return (end - begin);
}
function main() {
  let dg: DirectedGraph = dg_make_graph();
  dg_add_pair(dg, 0, 1, 5);
  dg_add_pair(dg, 0, 2, 3);
  dg_add_pair(dg, 1, 3, 2);
  dg_add_pair(dg, 2, 3, 4);
  console.log(_str(_str(dg_dfs(dg, -2, -1))));
  console.log(_str(_str(dg_bfs(dg, -2))));
  console.log(_str(_str(dg_in_degree(dg, 3))));
  console.log(_str(_str(dg_out_degree(dg, 0))));
  console.log(_str(_str(dg_topological_sort(dg))));
  console.log(_str(_str(dg_has_cycle(dg))));
  let ug: Graph = g_make_graph();
  g_add_pair(ug, 0, 1, 1);
  g_add_pair(ug, 1, 2, 1);
  g_add_pair(ug, 2, 0, 1);
  console.log(_str(_str(g_dfs(ug, -2, -1))));
  console.log(_str(_str(g_bfs(ug, -2))));
  console.log(_str(_str(g_degree(ug, 1))));
  console.log(_str(_str(g_has_cycle(ug))));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

