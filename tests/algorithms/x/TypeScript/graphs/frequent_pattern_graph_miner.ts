// Generated by Mochi v0.10.61 on 2025-08-08 17:36:57 GMT+7

export interface Entry { edge: any; count: string; bit: any }
let EDGE_ARRAY: string[][][] = [[["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["bh", "e12"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["dh", "e10"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"], ["gh", "e6"], ["hi", "e3"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["be", "e6"], ["cd", "e2"], ["de", "e1"], ["df", "e8"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["eh", "e12"], ["fg", "e6"], ["fh", "e10"], ["gh", "e6"]], [["ab", "e1"], ["ac", "e3"], ["bc", "e4"], ["bd", "e2"], ["bh", "e12"], ["cd", "e2"], ["df", "e8"], ["dh", "e10"]], [["ab", "e1"], ["ac", "e3"], ["ad", "e5"], ["bc", "e4"], ["bd", "e2"], ["cd", "e2"], ["ce", "e4"], ["de", "e1"], ["df", "e8"], ["dg", "e5"], ["ef", "e3"], ["eg", "e2"], ["fg", "e6"]]];
export interface NodesData { map: Record<string, string[]>; keys: string[] }
export interface ClusterData { clusters: Record<number, string[]>; weights: number[] }
export interface GraphData { edges: Record<string, string[]>; keys: string[] }
function contains(lst: string[], item: string): boolean {
  for (const v of lst) {
    if ((v == item)) {
      return true;
    }
  }
  return false;
}
function get_distinct_edge(edge_array: string[][][]): string[] {
  let distinct: string[] = [];
  for (const row of edge_array) {
    for (const item of row) {
      let e: string = item[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? item.length + _mochi_idx : _mochi_idx;})()];
      if (!contains(distinct, e)) {
        distinct.push(e);
      }
    }
  }
  return distinct;
}
function get_bitcode(edge_array: string[][][], de: string): string {
  let bitcode: string = "";
  let i: number = 0;
  while ((i < _len(edge_array))) {
    let found: boolean = false;
    for (const item of edge_array[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? edge_array.length + _mochi_idx : _mochi_idx;})()]) {
      if ((item[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? item.length + _mochi_idx : _mochi_idx;})()] == de)) {
        found = true;
        break
      }
    }
    if (found) {
      bitcode = (bitcode + "1");
    } else {
      bitcode = (bitcode + "0");
    }
    i = (i + 1);
  }
  return bitcode;
}
function count_ones(s: string): number {
  let c: number = 0;
  let i: number = 0;
  while ((i < _len(s))) {
    if (((s).substring(i, (i + 1)) == "1")) {
      c = (c + 1);
    }
    i = (i + 1);
  }
  return c;
}
function get_frequency_table(edge_array: string[][][]): Record<string, string>[] {
  let distinct = get_distinct_edge(edge_array);
  let table: Record<string, string>[] = [];
  for (const e of distinct) {
    let bit = get_bitcode(edge_array, e);
    let cnt: number = count_ones(bit);
    let entry: Entry = {"edge": e, "count": _str(cnt), bit};
    table.push(entry);
  }
  let i: number = 0;
  while ((i < _len(table))) {
    let max_i: number = i;
    let j: number = (i + 1);
    while ((j < _len(table))) {
      if ((parseInt(table[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? table.length + _mochi_idx : _mochi_idx;})()].count, 10) > parseInt(table[(()=>{const _mochi_idx = max_i; return _mochi_idx < 0 ? table.length + _mochi_idx : _mochi_idx;})()].count, 10))) {
        max_i = j;
      }
      j = (j + 1);
    }
    let tmp: Record<string, string> = table[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? table.length + _mochi_idx : _mochi_idx;})()];
    table[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? table.length + _mochi_idx : _mochi_idx;})()] = table[(()=>{const _mochi_idx = max_i; return _mochi_idx < 0 ? table.length + _mochi_idx : _mochi_idx;})()];
    table[(()=>{const _mochi_idx = max_i; return _mochi_idx < 0 ? table.length + _mochi_idx : _mochi_idx;})()] = tmp;
    i = (i + 1);
  }
  return table;
}
function get_nodes(freq_table: Record<string, string>[]): NodesData {
  let nodes: Record<string, string[]> = {};
  let keys: string[] = [];
  for (const f of freq_table) {
    let code: string = f.bit;
    let edge: string = f.edge;
    if ((code in nodes)) {
      nodes[(()=>{const _mochi_idx = code; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = [...nodes[code], edge];
    } else {
      nodes[(()=>{const _mochi_idx = code; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = [edge];
      keys.push(code);
    }
  }
  return {"map": nodes, keys};
}
function get_cluster(nodes: NodesData): ClusterData {
  let clusters: Record<number, string[]> = {};
  let weights: number[] = [];
  let i: number = 0;
  while ((i < _len(nodes.keys))) {
    let code: string = nodes.keys[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? nodes.keys.length + _mochi_idx : _mochi_idx;})()];
    let wt: number = count_ones(code);
    if ((wt in clusters)) {
      clusters[(()=>{const _mochi_idx = wt; return _mochi_idx < 0 ? clusters.length + _mochi_idx : _mochi_idx;})()] = [...clusters[wt], code];
    } else {
      clusters[(()=>{const _mochi_idx = wt; return _mochi_idx < 0 ? clusters.length + _mochi_idx : _mochi_idx;})()] = [code];
      weights.push(wt);
    }
    i = (i + 1);
  }
  return {clusters, weights};
}
function get_support(clusters: ClusterData): number[] {
  let sup: number[] = [];
  let i: number = 0;
  while ((i < _len(clusters.weights))) {
    let w: number = clusters.weights[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? clusters.weights.length + _mochi_idx : _mochi_idx;})()];
    sup.push(Math.trunc((w * 100) / _len(clusters.weights)));
    i = (i + 1);
  }
  return sup;
}
function contains_bits(a: string, b: string): boolean {
  let i: number = 0;
  while ((i < _len(a))) {
    let c1: string = (a).substring(i, (i + 1));
    let c2: string = (b).substring(i, (i + 1));
    if (((c1 == "1") && (c2 != "1"))) {
      return false;
    }
    i = (i + 1);
  }
  return true;
}
function max_cluster_key(clusters: ClusterData): number {
  let m: number = 0;
  let i: number = 0;
  while ((i < _len(clusters.weights))) {
    let w: number = clusters.weights[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? clusters.weights.length + _mochi_idx : _mochi_idx;})()];
    if ((w > m)) {
      m = w;
    }
    i = (i + 1);
  }
  return m;
}
function get_cluster_codes(clusters: ClusterData, wt: number): string[] {
  if ((wt in clusters.clusters)) {
    return clusters.clusters[wt];
  }
  return [];
}
function create_edge(nodes: NodesData, graph: Record<string, string[]>, gkeys: string[], clusters: ClusterData, c1: number, maxk: number): string[] {
  let keys: string[] = gkeys;
  let codes1: string[] = get_cluster_codes(clusters, c1);
  let idx1: number = 0;
  while ((idx1 < _len(codes1))) {
    let i_code: string = codes1[(()=>{const _mochi_idx = idx1; return _mochi_idx < 0 ? codes1.length + _mochi_idx : _mochi_idx;})()];
    let count: number = 0;
    let c2: number = (c1 + 1);
    while ((c2 <= maxk)) {
      let codes2: string[] = get_cluster_codes(clusters, c2);
      let j: number = 0;
      while ((j < _len(codes2))) {
        let j_code: string = codes2[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? codes2.length + _mochi_idx : _mochi_idx;})()];
        if (contains_bits(i_code, j_code)) {
          if ((i_code in graph)) {
            graph[(()=>{const _mochi_idx = i_code; return _mochi_idx < 0 ? graph.length + _mochi_idx : _mochi_idx;})()] = [...graph[i_code], j_code];
          } else {
            graph[(()=>{const _mochi_idx = i_code; return _mochi_idx < 0 ? graph.length + _mochi_idx : _mochi_idx;})()] = [j_code];
            if (!contains(keys, i_code)) {
              keys.push(i_code);
            }
          }
          if (!contains(keys, j_code)) {
            keys.push(j_code);
          }
          count = (count + 1);
        }
        j = (j + 1);
      }
      if ((count == 0)) {
        c2 = (c2 + 1);
      } else {
        break
      }
    }
    idx1 = (idx1 + 1);
  }
  return keys;
}
function construct_graph(clusters: ClusterData, nodes: NodesData): GraphData {
  let maxk: number = max_cluster_key(clusters);
  let top_codes: string[] = get_cluster_codes(clusters, maxk);
  let graph: Record<string, string[]> = {};
  let keys: string[] = ["Header"];
  graph.Header = [];
  let i: number = 0;
  while ((i < _len(top_codes))) {
    let code: string = top_codes[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? top_codes.length + _mochi_idx : _mochi_idx;})()];
    graph.Header.push(code);
    graph[(()=>{const _mochi_idx = code; return _mochi_idx < 0 ? graph.length + _mochi_idx : _mochi_idx;})()] = ["Header"];
    keys.push(code);
    i = (i + 1);
  }
  let c: number = 1;
  while ((c < maxk)) {
    keys = create_edge(nodes, graph, keys, clusters, c, maxk);
    c = (c + 1);
  }
  return {"edges": graph, keys};
}
let paths: string[][] = [];
function copy_list(lst: string[]): string[] {
  let n: string[] = [];
  for (const v of lst) {
    n.push(v);
  }
  return n;
}
function my_dfs(graph: Record<string, string[]>, start: string, end: string, path: string[]) {
  let new_path: string[] = copy_list(path);
  new_path.push(start);
  if ((start == end)) {
    paths.push(new_path);
    return;
  }
  for (const node in graph[start]) {
    let seen: boolean = false;
    for (const p of new_path) {
      if ((p == node)) {
        seen = true;
      }
    }
    if (!seen) {
      my_dfs(graph, node, end, new_path);
    }
  }
}
function find_freq_subgraph_given_support(s: number, clusters: ClusterData, graph: GraphData) {
  let k: number = Math.trunc((s * _len(clusters.weights)) / 100);
  let codes: string[] = get_cluster_codes(clusters, k);
  let i: number = 0;
  while ((i < _len(codes))) {
    my_dfs(graph.edges, codes[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? codes.length + _mochi_idx : _mochi_idx;})()], "Header", []);
    i = (i + 1);
  }
}
function node_edges(nodes: NodesData, code: string): string[] {
  return nodes.map[code];
}
function freq_subgraphs_edge_list(paths: string[][], nodes: NodesData): string[][][] {
  let freq_sub_el: string[][][] = [];
  for (const path of paths) {
    let el: string[][] = [];
    let j: number = 0;
    while ((j < (_len(path) - 1))) {
      let code: string = path[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? path.length + _mochi_idx : _mochi_idx;})()];
      let edge_list: string[] = node_edges(nodes, code);
      let e: number = 0;
      while ((e < _len(edge_list))) {
        let edge: string = edge_list[(()=>{const _mochi_idx = e; return _mochi_idx < 0 ? edge_list.length + _mochi_idx : _mochi_idx;})()];
        let a: string = (edge).substring(0, 1);
        let b: string = (edge).substring(1, 2);
        el.push([a, b]);
        e = (e + 1);
      }
      j = (j + 1);
    }
    freq_sub_el.push(el);
  }
  return freq_sub_el;
}
function print_all(nodes: NodesData, support: number[], clusters: ClusterData, graph: GraphData, freq_subgraph_edge_list: string[][][]) {
  console.log(_str("\nNodes\n"));
  let i: number = 0;
  while ((i < _len(nodes.keys))) {
    let code: string = nodes.keys[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? nodes.keys.length + _mochi_idx : _mochi_idx;})()];
    console.log(_str(code));
    console.log(_str("[" + (nodes.map[code]).join(' ') + "]"));
    i = (i + 1);
  }
  console.log(_str("\nSupport\n"));
  console.log(_str("[" + (support).join(' ') + "]"));
  console.log(_str("\nCluster\n"));
  let j: number = 0;
  while ((j < _len(clusters.weights))) {
    let w: number = clusters.weights[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? clusters.weights.length + _mochi_idx : _mochi_idx;})()];
    console.log(_str(((_str(w) + ":") + _str(clusters.clusters[w]))));
    j = (j + 1);
  }
  console.log(_str("\nGraph\n"));
  let k: number = 0;
  while ((k < _len(graph.keys))) {
    let key: string = graph.keys[(()=>{const _mochi_idx = k; return _mochi_idx < 0 ? graph.keys.length + _mochi_idx : _mochi_idx;})()];
    console.log(_str(key));
    console.log(_str("[" + (graph.edges[key]).join(' ') + "]"));
    k = (k + 1);
  }
  console.log(_str("\nEdge List of Frequent subgraphs\n"));
  for (const el of freq_subgraph_edge_list) {
    console.log(_str("[" + (el).join(' ') + "]"));
  }
}
function main() {
  let frequency_table: Record<string, string>[] = get_frequency_table(EDGE_ARRAY);
  let nodes: NodesData = get_nodes(frequency_table);
  let clusters: ClusterData = get_cluster(nodes);
  let support: number[] = get_support(clusters);
  let graph: GraphData = construct_graph(clusters, nodes);
  find_freq_subgraph_given_support(60, clusters, graph);
  let freq_subgraph_edge_list: string[][][] = freq_subgraphs_edge_list(paths, nodes);
  print_all(nodes, support, clusters, graph, freq_subgraph_edge_list);
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

