// Generated by Mochi v0.10.59 on 2025-08-06 22:53:33 GMT+7

export interface Edge { u: number; v: number; w: number }
export interface Graph { num_nodes: number; edges: Edge[]; component: Record<number, number> }
export interface UnionResult { graph: Graph; component_size: number[] }
function new_graph(num_nodes: number): Graph {
  return {num_nodes, "edges": [], "component": {}};
}
function add_edge(g: Graph, u: number, v: number, w: number): Graph {
  let es: Edge[] = g.edges;
  es.push({u, v, w});
  return {"num_nodes": g.num_nodes, "edges": es, "component": g.component};
}
function find_component(g: Graph, node: number): number {
  if ((g.component[(node) < 0 ? g.component.length + (node) : node] == node)) {
    return node;
  }
  return find_component(g, g.component[(node) < 0 ? g.component.length + (node) : node]);
}
function set_component(g: Graph, node: number): Graph {
  if ((g.component[(node) < 0 ? g.component.length + (node) : node] != node)) {
    let comp: Record<number, number> = g.component;
    for (const k of _keys(comp)) {
      comp[(k) < 0 ? comp.length + (k) : k] = find_component(g, k);
    }
    g = {"num_nodes": g.num_nodes, "edges": g.edges, "component": comp};
  }
  return g;
}
function union(g: Graph, component_size: number[], u: number, v: number): UnionResult {
  let comp_size: number[] = component_size;
  let comp: Record<number, number> = g.component;
  if ((comp_size[(u) < 0 ? comp_size.length + (u) : u] <= comp_size[(v) < 0 ? comp_size.length + (v) : v])) {
    comp[(u) < 0 ? comp.length + (u) : u] = v;
    comp_size[(v) < 0 ? comp_size.length + (v) : v] = (comp_size[(v) < 0 ? comp_size.length + (v) : v] + comp_size[(u) < 0 ? comp_size.length + (u) : u]);
    g = {"num_nodes": g.num_nodes, "edges": g.edges, "component": comp};
    g = set_component(g, u);
  } else {
    comp[(v) < 0 ? comp.length + (v) : v] = u;
    comp_size[(u) < 0 ? comp_size.length + (u) : u] = (comp_size[(u) < 0 ? comp_size.length + (u) : u] + comp_size[(v) < 0 ? comp_size.length + (v) : v]);
    g = {"num_nodes": g.num_nodes, "edges": g.edges, "component": comp};
    g = set_component(g, v);
  }
  return {"graph": g, "component_size": comp_size};
}
function create_empty_edges(n: number): Edge[] {
  let res: Edge[] = [];
  let i: number = 0;
  while ((i < n)) {
    res.push({"u": -1, "v": -1, "w": -1});
    i = (i + 1);
  }
  return res;
}
function boruvka(g: Graph): number {
  let component_size: number[] = [];
  let i: number = 0;
  while ((i < g.num_nodes)) {
    component_size.push(1);
    g.component[(i) < 0 ? g.component.length + (i) : i] = i;
    i = (i + 1);
  }
  let mst_weight: number = 0;
  let num_components: number = g.num_nodes;
  let minimum_weight_edge: Edge[] = create_empty_edges(g.num_nodes);
  while ((num_components > 1)) {
    for (const e of g.edges) {
      let u: number = e.u;
      let v: number = e.v;
      let w: number = e.w;
      let u_comp: number = g.component[(u) < 0 ? g.component.length + (u) : u];
      let v_comp: number = g.component[(v) < 0 ? g.component.length + (v) : v];
      if ((u_comp != v_comp)) {
        let current_u: Edge = minimum_weight_edge[(u_comp) < 0 ? minimum_weight_edge.length + (u_comp) : u_comp];
        if (((current_u.u == -1) || (current_u.w > w))) {
          minimum_weight_edge[(u_comp) < 0 ? minimum_weight_edge.length + (u_comp) : u_comp] = {u, v, w};
        }
        let current_v: Edge = minimum_weight_edge[(v_comp) < 0 ? minimum_weight_edge.length + (v_comp) : v_comp];
        if (((current_v.u == -1) || (current_v.w > w))) {
          minimum_weight_edge[(v_comp) < 0 ? minimum_weight_edge.length + (v_comp) : v_comp] = {u, v, w};
        }
      }
    }
    for (const e of minimum_weight_edge) {
      if ((e.u != -1)) {
        let u: number = e.u;
        let v: number = e.v;
        let w: number = e.w;
        let u_comp: number = g.component[(u) < 0 ? g.component.length + (u) : u];
        let v_comp: number = g.component[(v) < 0 ? g.component.length + (v) : v];
        if ((u_comp != v_comp)) {
          mst_weight = (mst_weight + w);
          let res: UnionResult = union(g, component_size, u_comp, v_comp);
          g = res.graph;
          component_size = res.component_size;
          console.log(_str((((("Added edge [" + _str(u)) + " - ") + _str(v)) + "]")));
          console.log(_str(("Added weight: " + _str(w))));
          console.log(_str(""));
          num_components = (num_components - 1);
        }
      }
    }
    minimum_weight_edge = create_empty_edges(g.num_nodes);
  }
  console.log(_str(("The total weight of the minimal spanning tree is: " + _str(mst_weight))));
  return mst_weight;
}
function main() {
  let g: Graph = new_graph(8);
  let edges: number[][] = [[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4], [3, 4, 8], [4, 5, 10], [4, 6, 6], [4, 7, 5], [5, 7, 15], [6, 7, 4]];
  for (const e of edges) {
    g = add_edge(g, e[(Math.trunc(0)) < 0 ? e.length + (Math.trunc(0)) : Math.trunc(0)], e[(Math.trunc(1)) < 0 ? e.length + (Math.trunc(1)) : Math.trunc(1)], e[(Math.trunc(2)) < 0 ? e.length + (Math.trunc(2)) : Math.trunc(2)]);
  }
  boruvka(g);
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _keys(obj: any): any[] {
  return Object.keys(obj);
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

