// Generated by Mochi v0.10.65 on 2025-08-14 15:57:42 GMT+7

export interface Edge { u: number; v: number; w: number }
export interface Graph { num_nodes: number; edges: Edge[]; component: Record<number, number> }
export interface UnionResult { graph: Graph; component_size: number[] }
function new_graph(num_nodes: number): Graph {
  return {num_nodes, edges: [], component: {}};
}
function add_edge(g: Graph, u: number, v: number, w: number): Graph {
  let es: Edge[] = g.edges;
  es.push({u, v, w});
  return {num_nodes: g.num_nodes, edges: es, component: g.component};
}
function find_component(g: Graph, node: number): number {
  if ((g.component[node] === node)) {
    return node;
  }
  return find_component(g, g.component[node]);
}
function set_component(g: Graph, node: number): Graph {
  if ((g.component[node] !== node)) {
    let comp: Record<number, number> = g.component;
    let k: number = 0;
    while ((k < g.num_nodes)) {
      comp[(()=>{const _mochi_idx = k; return _mochi_idx < 0 ? comp.length + _mochi_idx : _mochi_idx;})()] = find_component(g, k);
      k = (k + 1);
    }
    g = {num_nodes: g.num_nodes, edges: g.edges, component: comp};
  }
  return g;
}
function union(g: Graph, component_size: number[], u: number, v: number): UnionResult {
  let comp_size: number[] = component_size;
  let comp: Record<number, number> = g.component;
  if ((comp_size[(()=>{const _mochi_idx = u; return _mochi_idx < 0 ? comp_size.length + _mochi_idx : _mochi_idx;})()] <= comp_size[(()=>{const _mochi_idx = v; return _mochi_idx < 0 ? comp_size.length + _mochi_idx : _mochi_idx;})()])) {
    comp[(()=>{const _mochi_idx = u; return _mochi_idx < 0 ? comp.length + _mochi_idx : _mochi_idx;})()] = v;
    comp_size[(()=>{const _mochi_idx = v; return _mochi_idx < 0 ? comp_size.length + _mochi_idx : _mochi_idx;})()] = (comp_size[(()=>{const _mochi_idx = v; return _mochi_idx < 0 ? comp_size.length + _mochi_idx : _mochi_idx;})()] + comp_size[(()=>{const _mochi_idx = u; return _mochi_idx < 0 ? comp_size.length + _mochi_idx : _mochi_idx;})()]);
    g = {num_nodes: g.num_nodes, edges: g.edges, component: comp};
    g = set_component(g, u);
  } else {
    comp[(()=>{const _mochi_idx = v; return _mochi_idx < 0 ? comp.length + _mochi_idx : _mochi_idx;})()] = u;
    comp_size[(()=>{const _mochi_idx = u; return _mochi_idx < 0 ? comp_size.length + _mochi_idx : _mochi_idx;})()] = (comp_size[(()=>{const _mochi_idx = u; return _mochi_idx < 0 ? comp_size.length + _mochi_idx : _mochi_idx;})()] + comp_size[(()=>{const _mochi_idx = v; return _mochi_idx < 0 ? comp_size.length + _mochi_idx : _mochi_idx;})()]);
    g = {num_nodes: g.num_nodes, edges: g.edges, component: comp};
    g = set_component(g, v);
  }
  return {graph: g, component_size: comp_size};
}
function create_empty_edges(n: number): Edge[] {
  let res: Edge[] = [];
  let i: number = 0;
  while ((i < n)) {
    res.push({u: (0 - 1), v: (0 - 1), w: (0 - 1)});
    i = (i + 1);
  }
  return res;
}
function boruvka(g: Graph): number {
  let component_size: number[] = [];
  let i: number = 0;
  while ((i < g.num_nodes)) {
    component_size.push(1);
    let comp: Record<number, number> = g.component;
    comp[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? comp.length + _mochi_idx : _mochi_idx;})()] = i;
    g = {num_nodes: g.num_nodes, edges: g.edges, component: comp};
    i = (i + 1);
  }
  let mst_weight: number = 0;
  let num_components: number = g.num_nodes;
  let minimum_weight_edge: Edge[] = create_empty_edges(g.num_nodes);
  while ((num_components > 1)) {
    for (const e of g.edges) {
      let u: number = e.u;
      let v: number = e.v;
      let w: number = e.w;
      let u_comp: number = g.component[u];
      let v_comp: number = g.component[v];
      if ((u_comp !== v_comp)) {
        let current_u: Edge = minimum_weight_edge[(()=>{const _mochi_idx = u_comp; return _mochi_idx < 0 ? minimum_weight_edge.length + _mochi_idx : _mochi_idx;})()];
        if (((current_u.u === (0 - 1)) || (current_u.w > w))) {
          minimum_weight_edge[(()=>{const _mochi_idx = u_comp; return _mochi_idx < 0 ? minimum_weight_edge.length + _mochi_idx : _mochi_idx;})()] = {u, v, w};
        }
        let current_v: Edge = minimum_weight_edge[(()=>{const _mochi_idx = v_comp; return _mochi_idx < 0 ? minimum_weight_edge.length + _mochi_idx : _mochi_idx;})()];
        if (((current_v.u === (0 - 1)) || (current_v.w > w))) {
          minimum_weight_edge[(()=>{const _mochi_idx = v_comp; return _mochi_idx < 0 ? minimum_weight_edge.length + _mochi_idx : _mochi_idx;})()] = {u, v, w};
        }
      }
    }
    for (const e of minimum_weight_edge) {
      if ((e.u !== (0 - 1))) {
        let u: number = e.u;
        let v: number = e.v;
        let w: number = e.w;
        let u_comp: number = g.component[u];
        let v_comp: number = g.component[v];
        if ((u_comp !== v_comp)) {
          mst_weight = (mst_weight + w);
          let res: UnionResult = union(g, component_size, u_comp, v_comp);
          g = res.graph;
          component_size = res.component_size;
          console.log(_str((((("Added edge [" + _str(u)) + " - ") + _str(v)) + "]")));
          console.log(_str(("Added weight: " + _str(w))));
          console.log(_str(""));
          num_components = (num_components - 1);
        }
      }
    }
    minimum_weight_edge = create_empty_edges(g.num_nodes);
  }
  console.log(_str(("The total weight of the minimal spanning tree is: " + _str(mst_weight))));
  return mst_weight;
}
function main() {
  let g: Graph = new_graph(8);
  let edges: number[][] = [[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4], [3, 4, 8], [4, 5, 10], [4, 6, 6], [4, 7, 5], [5, 7, 15], [6, 7, 4]];
  for (const e of edges) {
    g = add_edge(g, e[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? e.length + _mochi_idx : _mochi_idx;})()], e[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? e.length + _mochi_idx : _mochi_idx;})()], e[(()=>{const _mochi_idx = Math.trunc(2); return _mochi_idx < 0 ? e.length + _mochi_idx : _mochi_idx;})()]);
  }
  boruvka(g);
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  if (typeof performance !== 'undefined' && (performance as any).memory) {
    return (performance as any).memory.usedJSHeapSize;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

