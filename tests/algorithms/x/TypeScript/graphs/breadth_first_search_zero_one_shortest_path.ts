// Generated by Mochi v0.10.59 on 2025-08-07 00:01:39 GMT+7

export interface Edge { destination_vertex: number; weight: number }
export interface AdjacencyList { graph: Edge[][]; size: number }
function new_adjacency_list(size: number): AdjacencyList {
  let g: Edge[][] = [];
  let i: number = 0;
  while ((i < size)) {
    g.push([]);
    i = (i + 1);
  }
  return {"graph": g, size};
}
function add_edge(al: AdjacencyList, from_vertex: number, to_vertex: number, weight: number) {
  if (!((weight == 0) || (weight == 1))) {
    _panic("Edge weight must be either 0 or 1.");
  }
  if (((to_vertex < 0) || (to_vertex >= al.size))) {
    _panic("Vertex indexes must be in [0; size).");
  }
  let g: Edge[][] = al.graph;
  let edges: Edge[] = g[(from_vertex) < 0 ? g.length + (from_vertex) : from_vertex];
  g[(from_vertex) < 0 ? g.length + (from_vertex) : from_vertex] = [...edges, {"destination_vertex": to_vertex, weight}];
  al.graph = g;
}
function push_front(q: number[], v: number): number[] {
  let res: number[] = [v];
  let i: number = 0;
  while ((i < _len(q))) {
    res.push(q[(i) < 0 ? q.length + (i) : i]);
    i = (i + 1);
  }
  return res;
}
function pop_front(q: number[]): number[] {
  let res: number[] = [];
  let i: number = 1;
  while ((i < _len(q))) {
    res.push(q[(i) < 0 ? q.length + (i) : i]);
    i = (i + 1);
  }
  return res;
}
function front(q: number[]): number {
  return q[(Math.trunc(0)) < 0 ? q.length + (Math.trunc(0)) : Math.trunc(0)];
}
function get_shortest_path(al: AdjacencyList, start_vertex: number, finish_vertex: number): number {
  let queue: number[] = [start_vertex];
  let distances: number[] = [];
  let i: number = 0;
  while ((i < al.size)) {
    distances.push(-1);
    i = (i + 1);
  }
  distances[(start_vertex) < 0 ? distances.length + (start_vertex) : start_vertex] = 0;
  while ((_len(queue) > 0)) {
    let current_vertex: number = front(queue);
    queue = pop_front(queue);
    let current_distance: number = distances[(current_vertex) < 0 ? distances.length + (current_vertex) : current_vertex];
    let edges: Edge[] = al.graph[(current_vertex) < 0 ? al.graph.length + (current_vertex) : current_vertex];
    let j: number = 0;
    while ((j < _len(edges))) {
      let edge: Edge = edges[(j) < 0 ? edges.length + (j) : j];
      let new_distance: number = (current_distance + edge.weight);
      let dest: number = edge.destination_vertex;
      let dest_distance: number = distances[(dest) < 0 ? distances.length + (dest) : dest];
      if (((dest_distance >= 0) && (new_distance >= dest_distance))) {
        j = (j + 1);
        continue
      }
      distances[(dest) < 0 ? distances.length + (dest) : dest] = new_distance;
      if ((edge.weight == 0)) {
        queue = push_front(queue, dest);
      } else {
        queue.push(dest);
      }
      j = (j + 1);
    }
  }
  let result: number = distances[(finish_vertex) < 0 ? distances.length + (finish_vertex) : finish_vertex];
  if ((result < 0)) {
    _panic("No path from start_vertex to finish_vertex.");
  }
  return result;
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
function _panic(msg: any): never { throw new Error(String(msg)); }
let g: AdjacencyList
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
g = new_adjacency_list(11)
  add_edge(g, 0, 1, 0);
  add_edge(g, 0, 3, 1);
  add_edge(g, 1, 2, 0);
  add_edge(g, 2, 3, 0);
  add_edge(g, 4, 2, 1);
  add_edge(g, 4, 5, 1);
  add_edge(g, 4, 6, 1);
  add_edge(g, 5, 9, 0);
  add_edge(g, 6, 7, 1);
  add_edge(g, 7, 8, 1);
  add_edge(g, 8, 10, 1);
  add_edge(g, 9, 7, 0);
  add_edge(g, 9, 10, 1);
  console.log(_str(_str(get_shortest_path(g, 0, 3))));
  console.log(_str(_str(get_shortest_path(g, 4, 10))));
  console.log(_str(_str(get_shortest_path(g, 4, 8))));
  console.log(_str(_str(get_shortest_path(g, 0, 1))));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

