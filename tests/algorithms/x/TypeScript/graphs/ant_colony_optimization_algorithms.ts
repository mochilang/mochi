// Generated by Mochi v0.10.59 on 2025-08-06 22:25:40 GMT+7

function sqrtApprox(x: number): number {
  let guess: number = (x / 2.0);
  let i: number = 0;
  while ((i < 20)) {
    guess = ((guess + (x / guess)) / 2.0);
    i = (i + 1);
  }
  return guess;
}
function rand_float(): number {
  return ((_now() % 1000000) / 1000000.0);
}
function pow_float(base: number, exp: number): number {
  let result: number = 1.0;
  let i: number = 0;
  let e: number = Math.trunc(exp);
  while ((i < e)) {
    result = (result * base);
    i = (i + 1);
  }
  return result;
}
function distance(city1: number[], city2: number[]): number {
  let dx: number = (city1[(Math.trunc(0)) < 0 ? city1.length + (Math.trunc(0)) : Math.trunc(0)] - city2[(Math.trunc(0)) < 0 ? city2.length + (Math.trunc(0)) : Math.trunc(0)]);
  let dy: number = (city1[(Math.trunc(1)) < 0 ? city1.length + (Math.trunc(1)) : Math.trunc(1)] - city2[(Math.trunc(1)) < 0 ? city2.length + (Math.trunc(1)) : Math.trunc(1)]);
  return sqrtApprox(((dx * dx) + (dy * dy)));
}
function choose_weighted(options: number[], weights: number[]): number {
  let total: number = 0.0;
  let i: number = 0;
  while ((i < _len(weights))) {
    total = (total + weights[(i) < 0 ? weights.length + (i) : i]);
    i = (i + 1);
  }
  let r: number = (rand_float() * total);
  let accum: number = 0.0;
  i = 0;
  while ((i < _len(weights))) {
    accum = (accum + weights[(i) < 0 ? weights.length + (i) : i]);
    if ((r <= accum)) {
      return options[(i) < 0 ? options.length + (i) : i];
    }
    i = (i + 1);
  }
  return options[(Math.trunc((_len(options) - 1))) < 0 ? options.length + (Math.trunc((_len(options) - 1))) : Math.trunc((_len(options) - 1))];
}
function city_select(pheromone: number[][], current: number, unvisited: number[], alpha: number, beta: number, cities: Record<number, number[]>): number {
  let probs: number[] = [];
  let i: number = 0;
  while ((i < _len(unvisited))) {
    let city: number = unvisited[(i) < 0 ? unvisited.length + (i) : i];
    let dist: number = distance(cities[(city) < 0 ? cities.length + (city) : city], cities[(current) < 0 ? cities.length + (current) : current]);
    let trail: number = pheromone[(city) < 0 ? pheromone.length + (city) : city][(current) < 0 ? pheromone[(city) < 0 ? pheromone.length + (city) : city].length + (current) : current];
    let prob: number = (pow_float(trail, alpha) * pow_float((1.0 / dist), beta));
    probs.push(prob);
    i = (i + 1);
  }
  return choose_weighted(unvisited, probs);
}
function pheromone_update(pheromone: number[][], cities: Record<number, number[]>, evaporation: number, ants_route: number[][], q: number): number[][] {
  let n: number = _len(pheromone);
  let i: number = 0;
  while ((i < n)) {
    let j: number = 0;
    while ((j < n)) {
      pheromone[(i) < 0 ? pheromone.length + (i) : i][(j) < 0 ? pheromone[(i) < 0 ? pheromone.length + (i) : i].length + (j) : j] = (pheromone[(i) < 0 ? pheromone.length + (i) : i][(j) < 0 ? pheromone[(i) < 0 ? pheromone.length + (i) : i].length + (j) : j] * evaporation);
      j = (j + 1);
    }
    i = (i + 1);
  }
  let a: number = 0;
  while ((a < _len(ants_route))) {
    let route: number[] = ants_route[(a) < 0 ? ants_route.length + (a) : a];
    let total: number = 0.0;
    let r: number = 0;
    while ((r < (_len(route) - 1))) {
      total = (total + distance(cities[(Math.trunc(route[(r) < 0 ? route.length + (r) : r])) < 0 ? cities.length + (Math.trunc(route[(r) < 0 ? route.length + (r) : r])) : Math.trunc(route[(r) < 0 ? route.length + (r) : r])], cities[(Math.trunc(route[(Math.trunc((r + 1))) < 0 ? route.length + (Math.trunc((r + 1))) : Math.trunc((r + 1))])) < 0 ? cities.length + (Math.trunc(route[(Math.trunc((r + 1))) < 0 ? route.length + (Math.trunc((r + 1))) : Math.trunc((r + 1))])) : Math.trunc(route[(Math.trunc((r + 1))) < 0 ? route.length + (Math.trunc((r + 1))) : Math.trunc((r + 1))])]));
      r = (r + 1);
    }
    let delta: number = (q / total);
    r = 0;
    while ((r < (_len(route) - 1))) {
      let u: number = route[(r) < 0 ? route.length + (r) : r];
      let v: number = route[(Math.trunc((r + 1))) < 0 ? route.length + (Math.trunc((r + 1))) : Math.trunc((r + 1))];
      pheromone[(u) < 0 ? pheromone.length + (u) : u][(v) < 0 ? pheromone[(u) < 0 ? pheromone.length + (u) : u].length + (v) : v] = (pheromone[(u) < 0 ? pheromone.length + (u) : u][(v) < 0 ? pheromone[(u) < 0 ? pheromone.length + (u) : u].length + (v) : v] + delta);
      pheromone[(v) < 0 ? pheromone.length + (v) : v][(u) < 0 ? pheromone[(v) < 0 ? pheromone.length + (v) : v].length + (u) : u] = pheromone[(u) < 0 ? pheromone.length + (u) : u][(v) < 0 ? pheromone[(u) < 0 ? pheromone.length + (u) : u].length + (v) : v];
      r = (r + 1);
    }
    a = (a + 1);
  }
  return pheromone;
}
function remove_value(lst: number[], val: number): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < _len(lst))) {
    if ((lst[(i) < 0 ? lst.length + (i) : i] != val)) {
      res.push(lst[(i) < 0 ? lst.length + (i) : i]);
    }
    i = (i + 1);
  }
  return res;
}
function ant_colony(cities: Record<number, number[]>, ants_num: number, iterations: number, evaporation: number, alpha: number, beta: number, q: number) {
  let n: number = _len(cities);
  let pheromone: number[][] = [];
  let i: number = 0;
  while ((i < n)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < n)) {
      row.push(1.0);
      j = (j + 1);
    }
    pheromone.push(row);
    i = (i + 1);
  }
  let best_path: number[] = [];
  let best_distance: number = 1000000000.0;
  let iter: number = 0;
  while ((iter < iterations)) {
    let ants_route: number[][] = [];
    let k: number = 0;
    while ((k < ants_num)) {
      let route: number[] = [0];
      let unvisited: number[] = [];
      for (const key in cities) {
        if ((key != 0)) {
          unvisited.push(key);
        }
      }
      let current: number = 0;
      while ((_len(unvisited) > 0)) {
        let next_city: number = city_select(pheromone, current, unvisited, alpha, beta, cities);
        route.push(next_city);
        unvisited = remove_value(unvisited, next_city);
        current = next_city;
      }
      route.push(0);
      ants_route.push(route);
      k = (k + 1);
    }
    pheromone = pheromone_update(pheromone, cities, evaporation, ants_route, q);
    let a: number = 0;
    while ((a < _len(ants_route))) {
      let route: number[] = ants_route[(a) < 0 ? ants_route.length + (a) : a];
      let dist: number = 0.0;
      let r: number = 0;
      while ((r < (_len(route) - 1))) {
        dist = (dist + distance(cities[(Math.trunc(route[(r) < 0 ? route.length + (r) : r])) < 0 ? cities.length + (Math.trunc(route[(r) < 0 ? route.length + (r) : r])) : Math.trunc(route[(r) < 0 ? route.length + (r) : r])], cities[(Math.trunc(route[(Math.trunc((r + 1))) < 0 ? route.length + (Math.trunc((r + 1))) : Math.trunc((r + 1))])) < 0 ? cities.length + (Math.trunc(route[(Math.trunc((r + 1))) < 0 ? route.length + (Math.trunc((r + 1))) : Math.trunc((r + 1))])) : Math.trunc(route[(Math.trunc((r + 1))) < 0 ? route.length + (Math.trunc((r + 1))) : Math.trunc((r + 1))])]));
        r = (r + 1);
      }
      if ((dist < best_distance)) {
        best_distance = dist;
        best_path = route;
      }
      a = (a + 1);
    }
    iter = (iter + 1);
  }
  console.log(_str(("best_path = " + _str(best_path))));
  console.log(_str(("best_distance = " + _str(best_distance))));
}
let cities: Record<number, number[]> = {[0]: [0, 0], [1]: [0, 5], [2]: [3, 8], [3]: [8, 10], [4]: [12, 8], [5]: [12, 4], [6]: [8, 0], [7]: [6, 2]};
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  ant_colony(cities, 10, 20, 0.7, 1.0, 5.0, 10.0);
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

