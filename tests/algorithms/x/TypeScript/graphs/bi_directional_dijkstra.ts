// Generated by Mochi v0.10.59 on 2025-08-06 22:25:46 GMT+7

export interface Graph_fwd { B: Edge[]; C: Edge[]; D: Edge[]; E: Edge[]; F: any[]; G: Edge[] }
export interface Graph_bwd { B: Edge[]; C: Edge[]; D: Edge[]; F: Edge[]; E: any[]; G: Edge[] }
export interface Edge { to: string; cost: number }
export interface QItem { node: string; cost: number }
export interface PassResult { queue: QItem[]; dist: number }
function get_min_index(q: QItem[]): number {
  let idx: number = 0;
  let i: number = 1;
  while ((i < _len(q))) {
    if ((q[(i) < 0 ? q.length + (i) : i].cost < q[(idx) < 0 ? q.length + (idx) : idx].cost)) {
      idx = i;
    }
    i = (i + 1);
  }
  return idx;
}
function remove_at(q: QItem[], idx: number): QItem[] {
  let res: QItem[] = [];
  let i: number = 0;
  while ((i < _len(q))) {
    if ((i != idx)) {
      res.push(q[(i) < 0 ? q.length + (i) : i]);
    }
    i = (i + 1);
  }
  return res;
}
function pass_and_relaxation(graph: Record<string, Edge[]>, v: string, visited_forward: Record<string, boolean>, visited_backward: Record<string, boolean>, cst_fwd: Record<string, number>, cst_bwd: Record<string, number>, queue: QItem[], parent: Record<string, string>, shortest_distance: number): PassResult {
  let q: QItem[] = queue;
  let sd: number = shortest_distance;
  for (const e of graph[(v) < 0 ? graph.length + (v) : v]) {
    let nxt: string = e.to;
    let d: number = e.cost;
    if ((nxt in visited_forward)) {
      continue
    }
    let old_cost: number = ((nxt in cst_fwd) ? cst_fwd[(nxt) < 0 ? cst_fwd.length + (nxt) : nxt] : 2147483647);
    let new_cost: number = (cst_fwd[(v) < 0 ? cst_fwd.length + (v) : v] + d);
    if ((new_cost < old_cost)) {
      q.push({"node": nxt, "cost": new_cost});
      cst_fwd[(nxt) < 0 ? cst_fwd.length + (nxt) : nxt] = new_cost;
      parent[(nxt) < 0 ? parent.length + (nxt) : nxt] = v;
    }
    if ((nxt in visited_backward)) {
      let alt: number = ((cst_fwd[(v) < 0 ? cst_fwd.length + (v) : v] + d) + cst_bwd[(nxt) < 0 ? cst_bwd.length + (nxt) : nxt]);
      if ((alt < sd)) {
        sd = alt;
      }
    }
  }
  return {"queue": q, "dist": sd};
}
function bidirectional_dij(source: string, destination: string, graph_forward: Record<string, Edge[]>, graph_backward: Record<string, Edge[]>): number {
  let shortest_path_distance: number = -1;
  let visited_forward: Record<string, boolean> = {};
  let visited_backward: Record<string, boolean> = {};
  let cst_fwd: Record<string, number> = {};
  cst_fwd[(source) < 0 ? cst_fwd.length + (source) : source] = 0;
  let cst_bwd: Record<string, number> = {};
  cst_bwd[(destination) < 0 ? cst_bwd.length + (destination) : destination] = 0;
  let parent_forward: Record<string, string> = {};
  parent_forward[(source) < 0 ? parent_forward.length + (source) : source] = "";
  let parent_backward: Record<string, string> = {};
  parent_backward[(destination) < 0 ? parent_backward.length + (destination) : destination] = "";
  let queue_forward: QItem[] = [];
  queue_forward.push({"node": source, "cost": 0});
  let queue_backward: QItem[] = [];
  queue_backward.push({"node": destination, "cost": 0});
  let shortest_distance: number = 2147483647;
  if ((source == destination)) {
    return 0;
  }
  while (((_len(queue_forward) > 0) && (_len(queue_backward) > 0))) {
    let idx_f: number = get_min_index(queue_forward);
    let item_f: QItem = queue_forward[(idx_f) < 0 ? queue_forward.length + (idx_f) : idx_f];
    queue_forward = remove_at(queue_forward, idx_f);
    let v_fwd: string = item_f.node;
    visited_forward[(v_fwd) < 0 ? visited_forward.length + (v_fwd) : v_fwd] = true;
    let idx_b: number = get_min_index(queue_backward);
    let item_b: QItem = queue_backward[(idx_b) < 0 ? queue_backward.length + (idx_b) : idx_b];
    queue_backward = remove_at(queue_backward, idx_b);
    let v_bwd: string = item_b.node;
    visited_backward[(v_bwd) < 0 ? visited_backward.length + (v_bwd) : v_bwd] = true;
    let res_f: PassResult = pass_and_relaxation(graph_forward, v_fwd, visited_forward, visited_backward, cst_fwd, cst_bwd, queue_forward, parent_forward, shortest_distance);
    queue_forward = res_f.queue;
    shortest_distance = res_f.dist;
    let res_b: PassResult = pass_and_relaxation(graph_backward, v_bwd, visited_backward, visited_forward, cst_bwd, cst_fwd, queue_backward, parent_backward, shortest_distance);
    queue_backward = res_b.queue;
    shortest_distance = res_b.dist;
    if (((cst_fwd[(v_fwd) < 0 ? cst_fwd.length + (v_fwd) : v_fwd] + cst_bwd[(v_bwd) < 0 ? cst_bwd.length + (v_bwd) : v_bwd]) >= shortest_distance)) {
      break
    }
  }
  if ((shortest_distance != 2147483647)) {
    shortest_path_distance = shortest_distance;
  }
  return shortest_path_distance;
}
let graph_fwd: Graph_fwd = {"B": [{"to": "C", "cost": 1}], "C": [{"to": "D", "cost": 1}], "D": [{"to": "F", "cost": 1}], "E": [{"to": "B", "cost": 1}, {"to": "G", "cost": 2}], "F": [], "G": [{"to": "F", "cost": 1}]};
let graph_bwd: Graph_bwd = {"B": [{"to": "E", "cost": 1}], "C": [{"to": "B", "cost": 1}], "D": [{"to": "C", "cost": 1}], "F": [{"to": "D", "cost": 1}, {"to": "G", "cost": 1}], "E": [], "G": [{"to": "E", "cost": 2}]};
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  console.log(_str(_str(bidirectional_dij("E", "F", graph_fwd, graph_bwd))));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

