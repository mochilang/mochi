// Generated by Mochi v0.10.59 on 2025-08-06 22:25:50 GMT+7

export interface ExpandResult { queue: number[]; head: number; parents: Record<number, number>; visited: Record<number, boolean>; intersection: number; found: boolean }
function expand_search(graph: Record<number, number[]>, queue: number[], head: number, parents: Record<number, number>, visited: Record<number, boolean>, opposite_visited: Record<number, boolean>): ExpandResult {
  if ((head >= _len(queue))) {
    return {queue, head, parents, visited, "intersection": (0 - 1), "found": false};
  }
  let current: number = queue[(head) < 0 ? queue.length + (head) : head];
  head = (head + 1);
  let neighbors: number[] = graph[(current) < 0 ? graph.length + (current) : current];
  let q: number[] = queue;
  let p: Record<number, number> = parents;
  let v: Record<number, boolean> = visited;
  let i: number = 0;
  while ((i < _len(neighbors))) {
    let neighbor: number = neighbors[(i) < 0 ? neighbors.length + (i) : i];
    if (v[(neighbor) < 0 ? v.length + (neighbor) : neighbor]) {
      i = (i + 1);
      continue
    }
    v[(neighbor) < 0 ? v.length + (neighbor) : neighbor] = true;
    p[(neighbor) < 0 ? p.length + (neighbor) : neighbor] = current;
    q.push(neighbor);
    if (opposite_visited[(neighbor) < 0 ? opposite_visited.length + (neighbor) : neighbor]) {
      return {"queue": q, head, "parents": p, "visited": v, "intersection": neighbor, "found": true};
    }
    i = (i + 1);
  }
  return {"queue": q, head, "parents": p, "visited": v, "intersection": (0 - 1), "found": false};
}
function construct_path(current: number, parents: Record<number, number>): number[] {
  let path: number[] = [];
  let node: number = current;
  while ((node != (0 - 1))) {
    path.push(node);
    node = parents[(node) < 0 ? parents.length + (node) : node];
  }
  return path;
}
function reverse_list(xs: number[]): number[] {
  let res: number[] = [];
  let i: number = _len(xs);
  while ((i > 0)) {
    i = (i - 1);
    res.push(xs[(i) < 0 ? xs.length + (i) : i]);
  }
  return res;
}
export interface SearchResult { path: number[]; ok: boolean }
function bidirectional_search(g: Record<number, number[]>, start: number, goal: number): SearchResult {
  if ((start == goal)) {
    return {"path": [start], "ok": true};
  }
  let forward_parents: Record<number, number> = {};
  forward_parents[(start) < 0 ? forward_parents.length + (start) : start] = (0 - 1);
  let backward_parents: Record<number, number> = {};
  backward_parents[(goal) < 0 ? backward_parents.length + (goal) : goal] = (0 - 1);
  let forward_visited: Record<number, boolean> = {};
  forward_visited[(start) < 0 ? forward_visited.length + (start) : start] = true;
  let backward_visited: Record<number, boolean> = {};
  backward_visited[(goal) < 0 ? backward_visited.length + (goal) : goal] = true;
  let forward_queue: number[] = [start];
  let backward_queue: number[] = [goal];
  let forward_head: number = 0;
  let backward_head: number = 0;
  let intersection: number = (0 - 1);
  while ((((forward_head < _len(forward_queue)) && (backward_head < _len(backward_queue))) && (intersection == (0 - 1)))) {
    let res: ExpandResult = expand_search(g, forward_queue, forward_head, forward_parents, forward_visited, backward_visited);
    forward_queue = res.queue;
    forward_head = res.head;
    forward_parents = res.parents;
    forward_visited = res.visited;
    if (res.found) {
      intersection = res.intersection;
      break
    }
    res = expand_search(g, backward_queue, backward_head, backward_parents, backward_visited, forward_visited);
    backward_queue = res.queue;
    backward_head = res.head;
    backward_parents = res.parents;
    backward_visited = res.visited;
    if (res.found) {
      intersection = res.intersection;
      break
    }
  }
  if ((intersection == (0 - 1))) {
    return {"path": [], "ok": false};
  }
  let forward_path: number[] = construct_path(intersection, forward_parents);
  forward_path = reverse_list(forward_path);
  let back_start: number = backward_parents[(intersection) < 0 ? backward_parents.length + (intersection) : intersection];
  let backward_path: number[] = construct_path(back_start, backward_parents);
  let result: number[] = forward_path;
  let j: number = 0;
  while ((j < _len(backward_path))) {
    result.push(backward_path[(j) < 0 ? backward_path.length + (j) : j]);
    j = (j + 1);
  }
  return {"path": result, "ok": true};
}
function is_edge(g: Record<number, number[]>, u: number, v: number): boolean {
  let neighbors: number[] = g[(u) < 0 ? g.length + (u) : u];
  let i: number = 0;
  while ((i < _len(neighbors))) {
    if ((neighbors[(i) < 0 ? neighbors.length + (i) : i] == v)) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function path_exists(g: Record<number, number[]>, path: number[]): boolean {
  if ((_len(path) == 0)) {
    return false;
  }
  let i: number = 0;
  while (((i + 1) < _len(path))) {
    if (!is_edge(g, path[(i) < 0 ? path.length + (i) : i], path[(Math.trunc((i + 1))) < 0 ? path.length + (Math.trunc((i + 1))) : Math.trunc((i + 1))])) {
      return false;
    }
    i = (i + 1);
  }
  return true;
}
function print_path(g: Record<number, number[]>, s: number, t: number) {
  let res: SearchResult = bidirectional_search(g, s, t);
  if ((res.ok && path_exists(g, res.path))) {
    console.log(_str(((((("Path from " + _str(s)) + " to ") + _str(t)) + ": ") + _str(res.path))));
  } else {
    console.log(_str((((("Path from " + _str(s)) + " to ") + _str(t)) + ": None")));
  }
}
function main() {
  let graph: Record<number, number[]> = {[0]: [1, 2], [1]: [0, 3, 4], [2]: [0, 5, 6], [3]: [1, 7], [4]: [1, 8], [5]: [2, 9], [6]: [2, 10], [7]: [3, 11], [8]: [4, 11], [9]: [5, 11], [10]: [6, 11], [11]: [7, 8, 9, 10]};
  print_path(graph, 0, 11);
  print_path(graph, 5, 5);
  let disconnected: Record<number, number[]> = {[0]: [1, 2], [1]: [0], [2]: [0], [3]: [4], [4]: [3]};
  print_path(disconnected, 0, 3);
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

