// Generated by Mochi v0.10.59 on 2025-08-06 20:42:49 GMT+7

export interface FenwickTree { size: number; tree: number[] }
function fenwick_from_list(arr: number[]): FenwickTree {
  let size: number = _len(arr);
  let tree: number[] = [];
  let i: number = 0;
  while ((i < size)) {
    tree.push(arr[i]);
    i = (i + 1);
  }
  i = 1;
  while ((i < size)) {
    let j: number = fenwick_next(i);
    if ((j < size)) {
      tree[j] = (tree[j] + tree[i]);
    }
    i = (i + 1);
  }
  return {size, tree};
}
function fenwick_empty(size: number): FenwickTree {
  let tree: number[] = [];
  let i: number = 0;
  while ((i < size)) {
    tree.push(0);
    i = (i + 1);
  }
  return {size, tree};
}
function fenwick_get_array(f: FenwickTree): number[] {
  let arr: number[] = [];
  let i: number = 0;
  while ((i < f.size)) {
    arr.push(f.tree[i]);
    i = (i + 1);
  }
  i = (f.size - 1);
  while ((i > 0)) {
    let j: number = fenwick_next(i);
    if ((j < f.size)) {
      arr[j] = (arr[j] - arr[i]);
    }
    i = (i - 1);
  }
  return arr;
}
function bit_and(a: number, b: number): number {
  let ua: number = a;
  let ub: number = b;
  let res: number = 0;
  let bit: number = 1;
  while (((ua != 0) || (ub != 0))) {
    if ((((ua % 2) == 1) && ((ub % 2) == 1))) {
      res = (res + bit);
    }
    ua = Math.trunc(Math.trunc(ua / 2));
    ub = Math.trunc(Math.trunc(ub / 2));
    bit = (bit * 2);
  }
  return res;
}
function low_bit(x: number): number {
  if ((x == 0)) {
    return 0;
  }
  return (x - bit_and(x, (x - 1)));
}
function fenwick_next(index: number): number {
  return (index + low_bit(index));
}
function fenwick_prev(index: number): number {
  return (index - low_bit(index));
}
function fenwick_add(f: FenwickTree, index: number, value: number): FenwickTree {
  let tree: number[] = f.tree;
  if ((index == 0)) {
    tree[0] = (tree[Math.trunc(0)] + value);
    return {"size": f.size, tree};
  }
  let i: number = index;
  while ((i < f.size)) {
    tree[i] = (tree[i] + value);
    i = fenwick_next(i);
  }
  return {"size": f.size, tree};
}
function fenwick_update(f: FenwickTree, index: number, value: number): FenwickTree {
  let current: number = fenwick_get(f, index);
  return fenwick_add(f, index, (value - current));
}
function fenwick_prefix(f: FenwickTree, right: number): number {
  if ((right == 0)) {
    return 0;
  }
  let result: number = f.tree[Math.trunc(0)];
  let r: number = (right - 1);
  while ((r > 0)) {
    result = (result + f.tree[r]);
    r = fenwick_prev(r);
  }
  return result;
}
function fenwick_query(f: FenwickTree, left: number, right: number): number {
  return (fenwick_prefix(f, right) - fenwick_prefix(f, left));
}
function fenwick_get(f: FenwickTree, index: number): number {
  return fenwick_query(f, index, (index + 1));
}
function fenwick_rank_query(f: FenwickTree, value: number): number {
  let v: number = (value - f.tree[Math.trunc(0)]);
  if ((v < 0)) {
    return -1;
  }
  let j: number = 1;
  while (((j * 2) < f.size)) {
    j = (j * 2);
  }
  let i: number = 0;
  let jj: number = j;
  while ((jj > 0)) {
    if ((((i + jj) < f.size) && (f.tree[Math.trunc((i + jj))] <= v))) {
      v = (v - f.tree[Math.trunc((i + jj))]);
      i = (i + jj);
    }
    jj = Math.trunc(jj / 2);
  }
  return i;
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let f_base: FenwickTree
let f: FenwickTree
let f2: FenwickTree
let f3: FenwickTree
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
f_base = fenwick_from_list([1, 2, 3, 4, 5])
  console.log(_str("[" + (fenwick_get_array(f_base)).join(' ') + "]"));
f = fenwick_from_list([1, 2, 3, 4, 5])
  f = fenwick_add(f, 0, 1);
  f = fenwick_add(f, 1, 2);
  f = fenwick_add(f, 2, 3);
  f = fenwick_add(f, 3, 4);
  f = fenwick_add(f, 4, 5);
  console.log(_str("[" + (fenwick_get_array(f)).join(' ') + "]"));
f2 = fenwick_from_list([1, 2, 3, 4, 5])
  console.log(_str(fenwick_prefix(f2, 3)));
  console.log(_str(fenwick_query(f2, 1, 4)));
f3 = fenwick_from_list([1, 2, 0, 3, 0, 5])
  console.log(_str(fenwick_rank_query(f3, 0)));
  console.log(_str(fenwick_rank_query(f3, 2)));
  console.log(_str(fenwick_rank_query(f3, 1)));
  console.log(_str(fenwick_rank_query(f3, 3)));
  console.log(_str(fenwick_rank_query(f3, 5)));
  console.log(_str(fenwick_rank_query(f3, 6)));
  console.log(_str(fenwick_rank_query(f3, 11)));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

