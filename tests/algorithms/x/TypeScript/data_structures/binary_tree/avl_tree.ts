// Generated by Mochi v0.10.59 on 2025-08-06 20:40:47 GMT+7

export interface Node { data: number; left: number; right: number; height: number }
let NIL: number = (0 - 1);
let nodes: Record<string, number>[] = [];
function new_node(value: number): number {
  let node: Node = {"data": value, "left": NIL, "right": NIL, "height": 1};
  nodes.push(node);
  return (_len(nodes) - 1);
}
function get_height(i: number): number {
  if ((i == NIL)) {
    return 0;
  }
  return nodes[i].height;
}
function my_max(a: number, b: number): number {
  if ((a > b)) {
    return a;
  }
  return b;
}
function update_height(i: number) {
  nodes[i].height = (my_max(get_height(nodes[i].left), get_height(nodes[i].right)) + 1);
}
function right_rotation(i: number): number {
  let left: number = nodes[i].left;
  nodes[i].left = nodes[left].right;
  nodes[left].right = i;
  update_height(i);
  update_height(left);
  return left;
}
function left_rotation(i: number): number {
  let right: number = nodes[i].right;
  nodes[i].right = nodes[right].left;
  nodes[right].left = i;
  update_height(i);
  update_height(right);
  return right;
}
function lr_rotation(i: number): number {
  nodes[i].left = left_rotation(nodes[i].left);
  return right_rotation(i);
}
function rl_rotation(i: number): number {
  nodes[i].right = right_rotation(nodes[i].right);
  return left_rotation(i);
}
function insert_node(i: number, value: number): number {
  if ((i == NIL)) {
    return new_node(value);
  }
  if ((value < nodes[i].data)) {
    nodes[i].left = insert_node(nodes[i].left, value);
    if (((get_height(nodes[i].left) - get_height(nodes[i].right)) == 2)) {
      if ((value < nodes[Math.trunc(nodes[i].left)].data)) {
        i = right_rotation(i);
      } else {
        i = lr_rotation(i);
      }
    }
  } else {
    nodes[i].right = insert_node(nodes[i].right, value);
    if (((get_height(nodes[i].right) - get_height(nodes[i].left)) == 2)) {
      if ((value < nodes[Math.trunc(nodes[i].right)].data)) {
        i = rl_rotation(i);
      } else {
        i = left_rotation(i);
      }
    }
  }
  update_height(i);
  return i;
}
function get_left_most(i: number): number {
  let cur: number = i;
  while ((nodes[cur].left != NIL)) {
    cur = nodes[cur].left;
  }
  return nodes[cur].data;
}
function del_node(i: number, value: number): number {
  if ((i == NIL)) {
    return NIL;
  }
  if ((value < nodes[i].data)) {
    nodes[i].left = del_node(nodes[i].left, value);
  } else {
    if ((value > nodes[i].data)) {
      nodes[i].right = del_node(nodes[i].right, value);
    } else {
      if (((nodes[i].left != NIL) && (nodes[i].right != NIL))) {
        let temp: number = get_left_most(nodes[i].right);
        nodes[i].data = temp;
        nodes[i].right = del_node(nodes[i].right, temp);
      } else {
        if ((nodes[i].left != NIL)) {
          i = nodes[i].left;
        } else {
          i = nodes[i].right;
        }
      }
    }
  }
  if ((i == NIL)) {
    return NIL;
  }
  let lh: number = get_height(nodes[i].left);
  let rh: number = get_height(nodes[i].right);
  if (((rh - lh) == 2)) {
    if ((get_height(nodes[Math.trunc(nodes[i].right)].right) > get_height(nodes[Math.trunc(nodes[i].right)].left))) {
      i = left_rotation(i);
    } else {
      i = rl_rotation(i);
    }
  } else {
    if (((lh - rh) == 2)) {
      if ((get_height(nodes[Math.trunc(nodes[i].left)].left) > get_height(nodes[Math.trunc(nodes[i].left)].right))) {
        i = right_rotation(i);
      } else {
        i = lr_rotation(i);
      }
    }
  }
  update_height(i);
  return i;
}
function inorder(i: number): string {
  if ((i == NIL)) {
    return "";
  }
  let left: string = inorder(nodes[i].left);
  let right: string = inorder(nodes[i].right);
  let res: string = _str(nodes[i].data);
  if ((left != "")) {
    res = ((left + " ") + res);
  }
  if ((right != "")) {
    res = ((res + " ") + right);
  }
  return res;
}
function main() {
  nodes = [];
  let root: number = NIL;
  root = insert_node(root, 4);
  root = insert_node(root, 2);
  root = insert_node(root, 3);
  console.log(_str(inorder(root)));
  console.log(_str(_str(get_height(root))));
  root = del_node(root, 3);
  console.log(_str(inorder(root)));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

