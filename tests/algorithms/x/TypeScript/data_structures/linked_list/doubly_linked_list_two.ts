// Generated by Mochi v0.10.59 on 2025-08-06 21:30:58 GMT+7

export interface Node { data: number; prev_index: number; next_index: number }
export interface LinkedList { nodes: Node[]; head_idx: number; tail_idx: number }
function empty_list(): LinkedList {
  return {"nodes": [], "head_idx": -1, "tail_idx": -1};
}
function get_head_data(ll: LinkedList): number {
  if ((ll.head_idx == -1)) {
    return -1;
  }
  let node: Node = ll.nodes[Math.trunc(ll.head_idx)];
  return node.data;
}
function get_tail_data(ll: LinkedList): number {
  if ((ll.tail_idx == -1)) {
    return -1;
  }
  let node: Node = ll.nodes[Math.trunc(ll.tail_idx)];
  return node.data;
}
function insert_before_node(ll: LinkedList, idx: number, new_idx: number) {
  let nodes: Node[] = ll.nodes;
  let new_node: Node = nodes[new_idx];
  new_node.next_index = idx;
  let node: Node = nodes[idx];
  let p: number = node.prev_index;
  new_node.prev_index = p;
  nodes[new_idx] = new_node;
  if ((p == -1)) {
    ll.head_idx = new_idx;
  } else {
    let prev_node: Node = nodes[p];
    prev_node.next_index = new_idx;
    nodes[p] = prev_node;
  }
  node.prev_index = new_idx;
  nodes[idx] = node;
  ll.nodes = nodes;
}
function insert_after_node(ll: LinkedList, idx: number, new_idx: number) {
  let nodes: Node[] = ll.nodes;
  let new_node: Node = nodes[new_idx];
  new_node.prev_index = idx;
  let node: Node = nodes[idx];
  let nxt: number = node.next_index;
  new_node.next_index = nxt;
  nodes[new_idx] = new_node;
  if ((nxt == -1)) {
    ll.tail_idx = new_idx;
  } else {
    let next_node: Node = nodes[nxt];
    next_node.prev_index = new_idx;
    nodes[nxt] = next_node;
  }
  node.next_index = new_idx;
  nodes[idx] = node;
  ll.nodes = nodes;
}
function set_head(ll: LinkedList, idx: number) {
  if ((ll.head_idx == -1)) {
    ll.head_idx = idx;
    ll.tail_idx = idx;
  } else {
    insert_before_node(ll, ll.head_idx, idx);
  }
}
function set_tail(ll: LinkedList, idx: number) {
  if ((ll.tail_idx == -1)) {
    ll.head_idx = idx;
    ll.tail_idx = idx;
  } else {
    insert_after_node(ll, ll.tail_idx, idx);
  }
}
function insert(ll: LinkedList, value: number) {
  let nodes: Node[] = ll.nodes;
  nodes.push({"data": value, "prev_index": -1, "next_index": -1});
  let idx: number = (_len(nodes) - 1);
  ll.nodes = nodes;
  if ((ll.head_idx == -1)) {
    ll.head_idx = idx;
    ll.tail_idx = idx;
  } else {
    insert_after_node(ll, ll.tail_idx, idx);
  }
}
function insert_at_position(ll: LinkedList, position: number, value: number) {
  let current: number = ll.head_idx;
  let current_pos: number = 1;
  while ((current != -1)) {
    if ((current_pos == position)) {
      let nodes: Node[] = ll.nodes;
      nodes.push({"data": value, "prev_index": -1, "next_index": -1});
      let new_idx: number = (_len(nodes) - 1);
      ll.nodes = nodes;
      insert_before_node(ll, current, new_idx);
      return;
    }
    let node: Node = ll.nodes[current];
    current = node.next_index;
    current_pos = (current_pos + 1);
  }
  insert(ll, value);
}
function get_node(ll: LinkedList, item: number): number {
  let current: number = ll.head_idx;
  while ((current != -1)) {
    let node: Node = ll.nodes[current];
    if ((node.data == item)) {
      return current;
    }
    current = node.next_index;
  }
  return -1;
}
function remove_node_pointers(ll: LinkedList, idx: number) {
  let nodes: Node[] = ll.nodes;
  let node: Node = nodes[idx];
  let nxt: number = node.next_index;
  let p: number = node.prev_index;
  if ((nxt != -1)) {
    let nxt_node: Node = nodes[nxt];
    nxt_node.prev_index = p;
    nodes[nxt] = nxt_node;
  }
  if ((p != -1)) {
    let prev_node: Node = nodes[p];
    prev_node.next_index = nxt;
    nodes[p] = prev_node;
  }
  node.next_index = -1;
  node.prev_index = -1;
  nodes[idx] = node;
  ll.nodes = nodes;
}
function delete_value(ll: LinkedList, value: number) {
  let idx: number = get_node(ll, value);
  if ((idx == -1)) {
    return;
  }
  if ((idx == ll.head_idx)) {
    let node: Node = ll.nodes[idx];
    ll.head_idx = node.next_index;
  }
  if ((idx == ll.tail_idx)) {
    let node: Node = ll.nodes[idx];
    ll.tail_idx = node.prev_index;
  }
  remove_node_pointers(ll, idx);
}
function contains(ll: LinkedList, value: number): boolean {
  return (get_node(ll, value) != -1);
}
function is_empty(ll: LinkedList): boolean {
  return (ll.head_idx == -1);
}
function to_string(ll: LinkedList): string {
  let res: string = "";
  let first: boolean = true;
  let current: number = ll.head_idx;
  while ((current != -1)) {
    let node: Node = ll.nodes[current];
    let val: string = _str(node.data);
    if (first) {
      res = val;
      first = false;
    } else {
      res = ((res + " ") + val);
    }
    current = node.next_index;
  }
  return res;
}
function print_list(ll: LinkedList) {
  let current: number = ll.head_idx;
  while ((current != -1)) {
    let node: Node = ll.nodes[current];
    console.log(_str(_str(node.data)));
    current = node.next_index;
  }
}
function main() {
  let ll: LinkedList = empty_list();
  console.log(_str(_str(get_head_data(ll))));
  console.log(_str(_str(get_tail_data(ll))));
  console.log(_str(_str(is_empty(ll))));
  insert(ll, 10);
  console.log(_str(_str(get_head_data(ll))));
  console.log(_str(_str(get_tail_data(ll))));
  insert_at_position(ll, 3, 20);
  console.log(_str(_str(get_head_data(ll))));
  console.log(_str(_str(get_tail_data(ll))));
  let nodes: Node[] = ll.nodes;
  nodes.push({"data": 1000, "prev_index": -1, "next_index": -1});
  let idx_head: number = (_len(nodes) - 1);
  ll.nodes = nodes;
  set_head(ll, idx_head);
  nodes = ll.nodes;
  nodes.push({"data": 2000, "prev_index": -1, "next_index": -1});
  let idx_tail: number = (_len(nodes) - 1);
  ll.nodes = nodes;
  set_tail(ll, idx_tail);
  print_list(ll);
  console.log(_str(_str(is_empty(ll))));
  print_list(ll);
  console.log(_str(_str(contains(ll, 10))));
  delete_value(ll, 10);
  console.log(_str(_str(contains(ll, 10))));
  delete_value(ll, 2000);
  console.log(_str(_str(get_tail_data(ll))));
  delete_value(ll, 1000);
  console.log(_str(_str(get_tail_data(ll))));
  console.log(_str(_str(get_head_data(ll))));
  print_list(ll);
  delete_value(ll, 20);
  print_list(ll);
  let i: number = 1;
  while ((i < 10)) {
    insert(ll, i);
    i = (i + 1);
  }
  print_list(ll);
  let ll2: LinkedList = empty_list();
  insert_at_position(ll2, 1, 10);
  console.log(_str(to_string(ll2)));
  insert_at_position(ll2, 2, 20);
  console.log(_str(to_string(ll2)));
  insert_at_position(ll2, 1, 30);
  console.log(_str(to_string(ll2)));
  insert_at_position(ll2, 3, 40);
  console.log(_str(to_string(ll2)));
  insert_at_position(ll2, 5, 50);
  console.log(_str(to_string(ll2)));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

