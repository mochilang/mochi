// Generated by Mochi v0.10.60 on 2025-08-08 10:44:57 GMT+7

export interface HashTable { size_table: number; values: number[]; filled: boolean[]; charge_factor: number; lim_charge: number }
function repeat_int(n: number, val: number): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < n)) {
    res.push(val);
    i = (i + 1);
  }
  return res;
}
function repeat_bool(n: number, val: boolean): boolean[] {
  let res: boolean[] = [];
  let i: number = 0;
  while ((i < n)) {
    res.push(val);
    i = (i + 1);
  }
  return res;
}
function set_int(xs: number[], idx: number, value: number): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < _len(xs))) {
    if ((i == idx)) {
      res.push(value);
    } else {
      res.push(xs[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? xs.length + _mochi_idx : _mochi_idx;})()]);
    }
    i = (i + 1);
  }
  return res;
}
function set_bool(xs: boolean[], idx: number, value: boolean): boolean[] {
  let res: boolean[] = [];
  let i: number = 0;
  while ((i < _len(xs))) {
    if ((i == idx)) {
      res.push(value);
    } else {
      res.push(xs[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? xs.length + _mochi_idx : _mochi_idx;})()]);
    }
    i = (i + 1);
  }
  return res;
}
function create_table(size_table: number, charge_factor: number, lim_charge: number): HashTable {
  return {size_table, "values": repeat_int(size_table, 0), "filled": repeat_bool(size_table, false), charge_factor, lim_charge};
}
function hash_function(ht: HashTable, key: number): number {
  let k: number = (key % ht.size_table);
  if ((k < 0)) {
    k = (k + ht.size_table);
  }
  return k;
}
function is_prime(n: number): boolean {
  if ((n < 2)) {
    return false;
  }
  if (((n % 2) == 0)) {
    return (n == 2);
  }
  let i: number = 3;
  while (((i * i) <= n)) {
    if (((n % i) == 0)) {
      return false;
    }
    i = (i + 2);
  }
  return true;
}
function next_prime(value: number, factor: number): number {
  let candidate: number = ((value * factor) + 1);
  while (!is_prime(candidate)) {
    candidate = (candidate + 1);
  }
  return candidate;
}
function set_value(ht: HashTable, key: number, data: number): HashTable {
  let new_values: number[] = set_int(ht.values, key, data);
  let new_filled: boolean[] = set_bool(ht.filled, key, true);
  return {"size_table": ht.size_table, "values": new_values, "filled": new_filled, "charge_factor": ht.charge_factor, "lim_charge": ht.lim_charge};
}
function collision_resolution(ht: HashTable, key: number): number {
  let new_key: number = hash_function(ht, (key + 1));
  let steps: number = 0;
  while (ht.filled[(()=>{const _mochi_idx = new_key; return _mochi_idx < 0 ? ht.filled.length + _mochi_idx : _mochi_idx;})()]) {
    new_key = hash_function(ht, (new_key + 1));
    steps = (steps + 1);
    if ((steps >= ht.size_table)) {
      return -1;
    }
  }
  return new_key;
}
function rehashing(ht: HashTable): HashTable {
  let survivors: number[] = [];
  let i: number = 0;
  while ((i < _len(ht.values))) {
    if (ht.filled[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? ht.filled.length + _mochi_idx : _mochi_idx;})()]) {
      survivors.push(ht.values[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? ht.values.length + _mochi_idx : _mochi_idx;})()]);
    }
    i = (i + 1);
  }
  let new_size: number = next_prime(ht.size_table, 2);
  let new_ht: HashTable = create_table(new_size, ht.charge_factor, ht.lim_charge);
  i = 0;
  while ((i < _len(survivors))) {
    new_ht = insert_data(new_ht, survivors[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? survivors.length + _mochi_idx : _mochi_idx;})()]);
    i = (i + 1);
  }
  return new_ht;
}
function insert_data(ht: HashTable, data: number): HashTable {
  let key: number = hash_function(ht, data);
  if (!ht.filled[(()=>{const _mochi_idx = key; return _mochi_idx < 0 ? ht.filled.length + _mochi_idx : _mochi_idx;})()]) {
    return set_value(ht, key, data);
  }
  if ((ht.values[(()=>{const _mochi_idx = key; return _mochi_idx < 0 ? ht.values.length + _mochi_idx : _mochi_idx;})()] == data)) {
    return ht;
  }
  let new_key: number = collision_resolution(ht, key);
  if ((new_key >= 0)) {
    return set_value(ht, new_key, data);
  }
  let resized: HashTable = rehashing(ht);
  return insert_data(resized, data);
}
function keys(ht: HashTable): number[][] {
  let res: number[][] = [];
  let i: number = 0;
  while ((i < _len(ht.values))) {
    if (ht.filled[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? ht.filled.length + _mochi_idx : _mochi_idx;})()]) {
      res.push([i, ht.values[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? ht.values.length + _mochi_idx : _mochi_idx;})()]]);
    }
    i = (i + 1);
  }
  return res;
}
function main() {
  let ht: HashTable = create_table(3, 1, 0.75);
  ht = insert_data(ht, 17);
  ht = insert_data(ht, 18);
  ht = insert_data(ht, 99);
  console.log(_str("[" + (_keys(ht)).join(' ') + "]"));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _keys(obj: any): any[] {
  return Object.keys(obj);
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

