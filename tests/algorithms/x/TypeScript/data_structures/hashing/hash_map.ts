// Generated by Mochi v0.10.60 on 2025-08-08 10:44:56 GMT+7

export interface Bucket { state: number; key: number; val: number }
export interface HashMap { buckets: Bucket[]; len: number; cap_num: number; cap_den: number; initial_size: number }
function make_buckets(n: number): Bucket[] {
  let buckets: Bucket[] = [];
  let i: number = 0;
  while ((i < n)) {
    buckets.push({"state": 0, "key": 0, "val": 0});
    i = (i + 1);
  }
  return buckets;
}
function hashmap_new(initial_size: number): HashMap {
  return {"buckets": make_buckets(initial_size), "len": 0, "cap_num": 3, "cap_den": 4, initial_size};
}
function bucket_index(hm: HashMap, key: number): number {
  let ind: number = (key % _len(hm.buckets));
  if ((ind < 0)) {
    ind = (ind + _len(hm.buckets));
  }
  return ind;
}
function next_index(hm: HashMap, ind: number): number {
  return ((ind + 1) % _len(hm.buckets));
}
function try_set(hm: HashMap, ind: number, key: number, val: number): boolean {
  let buckets: Bucket[] = hm.buckets;
  let b: Bucket = buckets[(()=>{const _mochi_idx = ind; return _mochi_idx < 0 ? buckets.length + _mochi_idx : _mochi_idx;})()];
  if (((b.state == 0) || (b.state == 2))) {
    buckets[(()=>{const _mochi_idx = ind; return _mochi_idx < 0 ? buckets.length + _mochi_idx : _mochi_idx;})()] = {"state": 1, key, val};
    hm.buckets = buckets;
    hm.len = (hm.len + 1);
    return true;
  }
  if ((b.key == key)) {
    buckets[(()=>{const _mochi_idx = ind; return _mochi_idx < 0 ? buckets.length + _mochi_idx : _mochi_idx;})()] = {"state": 1, key, val};
    hm.buckets = buckets;
    return true;
  }
  return false;
}
function is_full(hm: HashMap): boolean {
  let limit: number = Math.trunc((_len(hm.buckets) * hm.cap_num) / hm.cap_den);
  return (hm.len >= limit);
}
function is_sparse(hm: HashMap): boolean {
  if ((_len(hm.buckets) <= hm.initial_size)) {
    return false;
  }
  let limit: number = Math.trunc((_len(hm.buckets) * hm.cap_num) / (2 * hm.cap_den));
  return (hm.len < limit);
}
function resize(hm: HashMap, new_size: number) {
  let old: Bucket[] = hm.buckets;
  hm.buckets = make_buckets(new_size);
  hm.len = 0;
  let i: number = 0;
  while ((i < _len(old))) {
    let it: Bucket = old[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? old.length + _mochi_idx : _mochi_idx;})()];
    if ((it.state == 1)) {
      add_item(hm, it.key, it.val);
    }
    i = (i + 1);
  }
}
function size_up(hm: HashMap) {
  resize(hm, (_len(hm.buckets) * 2));
}
function size_down(hm: HashMap) {
  resize(hm, Math.trunc(_len(hm.buckets) / 2));
}
function add_item(hm: HashMap, key: number, val: number) {
  let ind: number = bucket_index(hm, key);
  let i: number = 0;
  while ((i < _len(hm.buckets))) {
    if (try_set(hm, ind, key, val)) {
      break
    }
    ind = next_index(hm, ind);
    i = (i + 1);
  }
}
function hashmap_set(hm: HashMap, key: number, val: number) {
  if (is_full(hm)) {
    size_up(hm);
  }
  add_item(hm, key, val);
}
function hashmap_get(hm: HashMap, key: number): number {
  let buckets: Bucket[] = hm.buckets;
  let ind: number = bucket_index(hm, key);
  let i: number = 0;
  while ((i < _len(buckets))) {
    let it: Bucket = buckets[(()=>{const _mochi_idx = ind; return _mochi_idx < 0 ? buckets.length + _mochi_idx : _mochi_idx;})()];
    if ((it.state == 0)) {
      break
    }
    if (((it.state == 1) && (it.key == key))) {
      return it.val;
    }
    ind = next_index(hm, ind);
    i = (i + 1);
  }
  return 0;
}
function hashmap_del(hm: HashMap, key: number) {
  let buckets: Bucket[] = hm.buckets;
  let ind: number = bucket_index(hm, key);
  let i: number = 0;
  while ((i < _len(buckets))) {
    let it: Bucket = buckets[(()=>{const _mochi_idx = ind; return _mochi_idx < 0 ? buckets.length + _mochi_idx : _mochi_idx;})()];
    if ((it.state == 0)) {
      console.log(_str(("KeyError: " + _str(key))));
      return;
    }
    if (((it.state == 1) && (it.key == key))) {
      buckets[(()=>{const _mochi_idx = ind; return _mochi_idx < 0 ? buckets.length + _mochi_idx : _mochi_idx;})()] = {"state": 2, "key": 0, "val": 0};
      hm.buckets = buckets;
      hm.len = (hm.len - 1);
      break
    }
    ind = next_index(hm, ind);
    i = (i + 1);
  }
  if (is_sparse(hm)) {
    size_down(hm);
  }
}
function hashmap_len(hm: HashMap): number {
  return hm.len;
}
function hashmap_repr(hm: HashMap): string {
  let out: string = "HashMap(";
  let first: boolean = true;
  let i: number = 0;
  while ((i < _len(hm.buckets))) {
    let b: Bucket = hm.buckets[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? hm.buckets.length + _mochi_idx : _mochi_idx;})()];
    if ((b.state == 1)) {
      if (!first) {
        out = (out + ", ");
      } else {
        first = false;
      }
      out = (((out + _str(b.key)) + ": ") + _str(b.val));
    }
    i = (i + 1);
  }
  out = (out + ")");
  return out;
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let hm: HashMap
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
hm = hashmap_new(5)
  hashmap_set(hm, 1, 10);
  hashmap_set(hm, 2, 20);
  hashmap_set(hm, 3, 30);
  console.log(_str(hashmap_repr(hm)));
  console.log(_str(_str(hashmap_get(hm, 2))));
  hashmap_del(hm, 1);
  console.log(_str(hashmap_repr(hm)));
  console.log(_str(_str(hashmap_len(hm))));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

