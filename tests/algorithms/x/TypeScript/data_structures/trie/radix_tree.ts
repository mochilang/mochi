// Generated by Mochi v0.10.61 on 2025-08-08 17:04:27 GMT+7

export interface RadixNode { prefix: string; is_leaf: boolean; children: Record<string, number> }
export interface RadixTree { nodes: RadixNode[] }
export interface MatchResult { common: string; rem_prefix: string; rem_word: string }
function new_node(prefix: string, is_leaf: boolean): RadixNode {
  return {prefix, is_leaf, "children": {}};
}
function new_tree(): RadixTree {
  let nodes: RadixNode[] = [new_node("", false)];
  return {nodes};
}
function match_prefix(node: RadixNode, word: string): MatchResult {
  let x: number = 0;
  let p: string = node.prefix;
  let w: string = word;
  let min_len: number = _len(p);
  if ((_len(w) < min_len)) {
    min_len = _len(w);
  }
  while ((x < min_len)) {
    if (((p).substring(x, (x + 1)) != (w).substring(x, (x + 1)))) {
      break
    }
    x = (x + 1);
  }
  let common: string = (p).substring(0, x);
  let rem_prefix: string = (p).substring(x, _len(p));
  let rem_word: string = (w).substring(x, _len(w));
  return {common, rem_prefix, rem_word};
}
function insert_many(tree: RadixTree, words: string[]) {
  for (const w of words) {
    insert(tree, 0, w);
  }
}
function insert(tree: RadixTree, idx: number, word: string) {
  let nodes: RadixNode[] = tree.nodes;
  let node: RadixNode = nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
  if (((node.prefix == word) && !node.is_leaf)) {
    node.is_leaf = true;
    nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = node;
    tree.nodes = nodes;
    return;
  }
  let first = (word).substring(0, 1);
  let children: Record<string, number> = node.children;
  if (!has_key(children, first)) {
    let new_idx: number = _len(nodes);
    nodes.push(new_node(word, true));
    children[(()=>{const _mochi_idx = first; return _mochi_idx < 0 ? children.length + _mochi_idx : _mochi_idx;})()] = new_idx;
    node.children = children;
    nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = node;
    tree.nodes = nodes;
    return;
  }
  let child_idx = children[(()=>{const _mochi_idx = first; return _mochi_idx < 0 ? children.length + _mochi_idx : _mochi_idx;})()];
  let child: RadixNode = nodes[(()=>{const _mochi_idx = child_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
  let res: MatchResult = match_prefix(child, word);
  if ((res.rem_prefix == "")) {
    insert(tree, child_idx, res.rem_word);
    return;
  }
  child.prefix = res.rem_prefix;
  nodes[(()=>{const _mochi_idx = child_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = child;
  let new_children: Record<string, number> = {};
  new_children[(()=>{const _mochi_idx = (res.rem_prefix).substring(0, 1); return _mochi_idx < 0 ? new_children.length + _mochi_idx : _mochi_idx;})()] = child_idx;
  let new_idx: number = _len(nodes);
  nodes.push(new_node(res.common, false));
  nodes[(()=>{const _mochi_idx = new_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()].children = new_children;
  if ((res.rem_word == "")) {
    nodes[(()=>{const _mochi_idx = new_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()].is_leaf = true;
  } else {
    insert(tree, new_idx, res.rem_word);
  }
  children[(()=>{const _mochi_idx = first; return _mochi_idx < 0 ? children.length + _mochi_idx : _mochi_idx;})()] = new_idx;
  node.children = children;
  nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = node;
  tree.nodes = nodes;
}
function find(tree: RadixTree, idx: number, word: string): boolean {
  let nodes: RadixNode[] = tree.nodes;
  let node: RadixNode = nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
  let first = (word).substring(0, 1);
  let children: Record<string, number> = node.children;
  if (!has_key(children, first)) {
    return false;
  }
  let child_idx = children[(()=>{const _mochi_idx = first; return _mochi_idx < 0 ? children.length + _mochi_idx : _mochi_idx;})()];
  let child: RadixNode = nodes[(()=>{const _mochi_idx = child_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
  let res: MatchResult = match_prefix(child, word);
  if ((res.rem_prefix != "")) {
    return false;
  }
  if ((res.rem_word == "")) {
    return child.is_leaf;
  }
  return find(tree, child_idx, res.rem_word);
}
function remove_key(m: Record<string, number>, k: string): Record<string, number> {
  let out: Record<string, number> = {};
  for (const key in m) {
    if ((key != k)) {
      out[(()=>{const _mochi_idx = key; return _mochi_idx < 0 ? out.length + _mochi_idx : _mochi_idx;})()] = m[(()=>{const _mochi_idx = key; return _mochi_idx < 0 ? m.length + _mochi_idx : _mochi_idx;})()];
    }
  }
  return out;
}
function has_key(m: Record<string, number>, k: string): boolean {
  for (const key in m) {
    if ((key == k)) {
      return true;
    }
  }
  return false;
}
function _delete(tree: RadixTree, idx: number, word: string): boolean {
  let nodes: RadixNode[] = tree.nodes;
  let node: RadixNode = nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
  let first = (word).substring(0, 1);
  let children: Record<string, number> = node.children;
  if (!has_key(children, first)) {
    return false;
  }
  let child_idx = children[(()=>{const _mochi_idx = first; return _mochi_idx < 0 ? children.length + _mochi_idx : _mochi_idx;})()];
  let child: RadixNode = nodes[(()=>{const _mochi_idx = child_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
  let res: MatchResult = match_prefix(child, word);
  if ((res.rem_prefix != "")) {
    return false;
  }
  if ((res.rem_word != "")) {
    let deleted: boolean = _delete(tree, child_idx, res.rem_word);
    if (deleted) {
      nodes = tree.nodes;
      node = nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
    }
    return deleted;
  }
  if (!child.is_leaf) {
    return false;
  }
  if ((_len(child.children) == 0)) {
    children = remove_key(children, first);
    node.children = children;
    nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = node;
    tree.nodes = nodes;
    if (((_len(children) == 1) && !node.is_leaf)) {
      let only_key: string = "";
      for (const k in children) {
        only_key = k;
      }
      let merge_idx: number = children[(()=>{const _mochi_idx = only_key; return _mochi_idx < 0 ? children.length + _mochi_idx : _mochi_idx;})()];
      let merge_node: RadixNode = nodes[(()=>{const _mochi_idx = merge_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
      node.is_leaf = merge_node.is_leaf;
      node.prefix = (node.prefix + merge_node.prefix);
      node.children = merge_node.children;
      nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = node;
      tree.nodes = nodes;
    }
  } else {
    if ((_len(child.children) > 1)) {
      child.is_leaf = false;
      nodes[(()=>{const _mochi_idx = child_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = child;
      tree.nodes = nodes;
    } else {
      let only_key: string = "";
      for (const k in child.children) {
        only_key = k;
      }
      let merge_idx: number = child.children[(()=>{const _mochi_idx = only_key; return _mochi_idx < 0 ? child.children.length + _mochi_idx : _mochi_idx;})()];
      let merge_node: RadixNode = nodes[(()=>{const _mochi_idx = merge_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
      child.is_leaf = merge_node.is_leaf;
      child.prefix = (child.prefix + merge_node.prefix);
      child.children = merge_node.children;
      nodes[(()=>{const _mochi_idx = child_idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()] = child;
      tree.nodes = nodes;
    }
  }
  return true;
}
function print_tree(tree: RadixTree, idx: number, height: number) {
  let nodes: RadixNode[] = tree.nodes;
  let node: RadixNode = nodes[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? nodes.length + _mochi_idx : _mochi_idx;})()];
  if ((node.prefix != "")) {
    let line: string = "";
    let i: number = 0;
    while ((i < height)) {
      line = (line + "-");
      i = (i + 1);
    }
    line = ((line + " ") + node.prefix);
    if (node.is_leaf) {
      line = (line + "  (leaf)");
    }
    console.log(_str(line));
  }
  let children: Record<string, number> = node.children;
  for (const k in children) {
    let child_idx: number = children[(()=>{const _mochi_idx = k; return _mochi_idx < 0 ? children.length + _mochi_idx : _mochi_idx;})()];
    print_tree(tree, child_idx, (height + 1));
  }
}
function test_trie(): boolean {
  let words: string[] = ["banana", "bananas", "bandana", "band", "apple", "all", "beast"];
  let tree: RadixTree = new_tree();
  insert_many(tree, words);
  let ok: boolean = true;
  for (const w of words) {
    if (!find(tree, 0, w)) {
      ok = false;
    }
  }
  if (find(tree, 0, "bandanas")) {
    ok = false;
  }
  if (find(tree, 0, "apps")) {
    ok = false;
  }
  _delete(tree, 0, "all");
  if (find(tree, 0, "all")) {
    ok = false;
  }
  _delete(tree, 0, "banana");
  if (find(tree, 0, "banana")) {
    ok = false;
  }
  if (!find(tree, 0, "bananas")) {
    ok = false;
  }
  return ok;
}
function pytests() {
  if (!test_trie()) {
    _panic("test failed");
  }
}
function main() {
  let tree: RadixTree = new_tree();
  let words: string[] = ["banana", "bananas", "bandanas", "bandana", "band", "apple", "all", "beast"];
  insert_many(tree, words);
  console.log(_str(("Words: " + _str(words))));
  console.log(_str("Tree:"));
  print_tree(tree, 0, 0);
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
function _panic(msg: any): never { throw new Error(String(msg)); }
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

