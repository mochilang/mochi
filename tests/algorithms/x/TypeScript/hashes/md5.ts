// Generated by Mochi v0.10.59 on 2025-08-06 23:29:13 GMT+7

let MOD: number = 4294967296;
let ASCII: string = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
function ord(ch: string): number {
  let i: number = 0;
  while ((i < _len(ASCII))) {
    if ((ASCII.slice(i, (i + 1)) == ch)) {
      return (32 + i);
    }
    i = (i + 1);
  }
  return 0;
}
function to_little_endian(s: string): string {
  if ((_len(s) != 32)) {
    _panic("Input must be of length 32");
  }
  return (((s.slice(24, 32) + s.slice(16, 24)) + s.slice(8, 16)) + s.slice(0, 8));
}
function int_to_bits(n: number, width: number): string {
  let bits: string = "";
  let num: number = n;
  while ((num > 0)) {
    bits = (_str((num % 2)) + bits);
    num = Math.trunc(num / 2);
  }
  while ((_len(bits) < width)) {
    bits = ("0" + bits);
  }
  if ((_len(bits) > width)) {
    bits = bits.slice((_len(bits) - width), _len(bits));
  }
  return bits;
}
function bits_to_int(bits: string): number {
  let num: number = 0;
  let i: number = 0;
  while ((i < _len(bits))) {
    if ((bits.slice(i, (i + 1)) == "1")) {
      num = ((num * 2) + 1);
    } else {
      num = (num * 2);
    }
    i = (i + 1);
  }
  return num;
}
function to_hex(n: number): string {
  let digits: string = "0123456789abcdef";
  if ((n == 0)) {
    return "0";
  }
  let num: number = n;
  let s: string = "";
  while ((num > 0)) {
    let d = (num % 16);
    s = (digits.slice(d, (d + 1)) + s);
    num = Math.trunc(num / 16);
  }
  return s;
}
function reformat_hex(i: number): string {
  if ((i < 0)) {
    _panic("Input must be non-negative");
  }
  let hex: string = to_hex(i);
  while ((_len(hex) < 8)) {
    hex = ("0" + hex);
  }
  if ((_len(hex) > 8)) {
    hex = hex.slice((_len(hex) - 8), _len(hex));
  }
  let le: string = "";
  let j: number = (_len(hex) - 2);
  while ((j >= 0)) {
    le = (le + hex.slice(j, (j + 2)));
    j = (j - 2);
  }
  return le;
}
function preprocess(message: string): string {
  let bit_string: string = "";
  let i: number = 0;
  while ((i < _len(message))) {
    let ch: string = message.slice(i, (i + 1));
    bit_string = (bit_string + int_to_bits(ord(ch), 8));
    i = (i + 1);
  }
  let start_len: string = int_to_bits(_len(bit_string), 64);
  bit_string = (bit_string + "1");
  while (((_len(bit_string) % 512) != 448)) {
    bit_string = (bit_string + "0");
  }
  bit_string = ((bit_string + to_little_endian(start_len.slice(32, 64))) + to_little_endian(start_len.slice(0, 32)));
  return bit_string;
}
function get_block_words(bit_string: string): number[][] {
  if (((_len(bit_string) % 512) != 0)) {
    _panic("Input must have length that's a multiple of 512");
  }
  let blocks: number[][] = [];
  let pos: number = 0;
  while ((pos < _len(bit_string))) {
    let block: number[] = [];
    let i: number = 0;
    while ((i < 512)) {
      let part: string = bit_string.slice((pos + i), ((pos + i) + 32));
      let word: number = bits_to_int(to_little_endian(part));
      block.push(word);
      i = (i + 32);
    }
    blocks.push(block);
    pos = (pos + 512);
  }
  return blocks;
}
function bit_and(a: number, b: number): number {
  let x: number = a;
  let y: number = b;
  let res: number = 0;
  let bit: number = 1;
  let i: number = 0;
  while ((i < 32)) {
    if ((((x % 2) == 1) && ((y % 2) == 1))) {
      res = (res + bit);
    }
    x = Math.trunc(x / 2);
    y = Math.trunc(y / 2);
    bit = (bit * 2);
    i = (i + 1);
  }
  return res;
}
function bit_or(a: number, b: number): number {
  let x: number = a;
  let y: number = b;
  let res: number = 0;
  let bit: number = 1;
  let i: number = 0;
  while ((i < 32)) {
    let abit: number = (x % 2);
    let bbit: number = (y % 2);
    if (((abit == 1) || (bbit == 1))) {
      res = (res + bit);
    }
    x = Math.trunc(x / 2);
    y = Math.trunc(y / 2);
    bit = (bit * 2);
    i = (i + 1);
  }
  return res;
}
function bit_xor(a: number, b: number): number {
  let x: number = a;
  let y: number = b;
  let res: number = 0;
  let bit: number = 1;
  let i: number = 0;
  while ((i < 32)) {
    let abit: number = (x % 2);
    let bbit: number = (y % 2);
    if ((((abit + bbit) % 2) == 1)) {
      res = (res + bit);
    }
    x = Math.trunc(x / 2);
    y = Math.trunc(y / 2);
    bit = (bit * 2);
    i = (i + 1);
  }
  return res;
}
function not_32(i: number): number {
  if ((i < 0)) {
    _panic("Input must be non-negative");
  }
  return (4294967295 - i);
}
function sum_32(a: number, b: number): number {
  return ((a + b) % MOD);
}
function lshift(num: number, k: number): number {
  let result = (num % MOD);
  let i: number = 0;
  while ((i < k)) {
    result = ((result * 2) % MOD);
    i = (i + 1);
  }
  return result;
}
function rshift(num: number, k: number): number {
  let result = num;
  let i: number = 0;
  while ((i < k)) {
    result = (result / 2);
    i = (i + 1);
  }
  return result;
}
function left_rotate_32(i: number, shift: number): number {
  if ((i < 0)) {
    _panic("Input must be non-negative");
  }
  if ((shift < 0)) {
    _panic("Shift must be non-negative");
  }
  let left: number = lshift(i, shift);
  let right: number = rshift(i, (32 - shift));
  return ((left + right) % MOD);
}
function md5_me(message: string): string {
  let bit_string: string = preprocess(message);
  let added_consts: number[] = [3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745];
  let shift_amounts: number[] = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21];
  let a0: number = 1732584193;
  let b0: number = 4023233417;
  let c0: number = 2562383102;
  let d0: number = 271733878;
  let blocks: number[][] = get_block_words(bit_string);
  let bi: number = 0;
  while ((bi < _len(blocks))) {
    let block: number[] = blocks[(bi) < 0 ? blocks.length + (bi) : bi];
    let a: number = a0;
    let b: number = b0;
    let c: number = c0;
    let d: number = d0;
    let i: number = 0;
    while ((i < 64)) {
      let f: number = 0;
      let g: number = 0;
      if ((i <= 15)) {
        f = bit_xor(d, bit_and(b, bit_xor(c, d)));
        g = i;
      } else {
        if ((i <= 31)) {
          f = bit_xor(c, bit_and(d, bit_xor(b, c)));
          g = (((5 * i) + 1) % 16);
        } else {
          if ((i <= 47)) {
            f = bit_xor(bit_xor(b, c), d);
            g = (((3 * i) + 5) % 16);
          } else {
            f = bit_xor(c, bit_or(b, not_32(d)));
            g = ((7 * i) % 16);
          }
        }
      }
      f = sum_32(f, a);
      f = sum_32(f, added_consts[(i) < 0 ? added_consts.length + (i) : i]);
      f = sum_32(f, block[(g) < 0 ? block.length + (g) : g]);
      let rotated: number = left_rotate_32(f, shift_amounts[(i) < 0 ? shift_amounts.length + (i) : i]);
      let new_b: number = sum_32(b, rotated);
      a = d;
      d = c;
      c = b;
      b = new_b;
      i = (i + 1);
    }
    a0 = sum_32(a0, a);
    b0 = sum_32(b0, b);
    c0 = sum_32(c0, c);
    d0 = sum_32(d0, d);
    bi = (bi + 1);
  }
  let digest: string = (((reformat_hex(a0) + reformat_hex(b0)) + reformat_hex(c0)) + reformat_hex(d0));
  return digest;
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
function _panic(msg: any): never { throw new Error(String(msg)); }
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

