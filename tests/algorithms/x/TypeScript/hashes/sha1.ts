// Generated by Mochi v0.10.59 on 2025-08-07 00:03:28 GMT+7

let MOD: number = 4294967296;
let ASCII: string = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
function ord(ch: string): number {
  let i: number = 0;
  while ((i < _len(ASCII))) {
    if ((ASCII.slice(i, (i + 1)) == ch)) {
      return (32 + i);
    }
    i = (i + 1);
  }
  return 0;
}
function pow2(n: number): number {
  let res: number = 1;
  let i: number = 0;
  while ((i < n)) {
    res = (res * 2);
    i = (i + 1);
  }
  return res;
}
function bit_and(a: number, b: number): number {
  let x: number = a;
  let y: number = b;
  let res: number = 0;
  let bit: number = 1;
  let i: number = 0;
  while ((i < 32)) {
    if ((((x % 2) == 1) && ((y % 2) == 1))) {
      res = (res + bit);
    }
    x = Math.trunc(x / 2);
    y = Math.trunc(y / 2);
    bit = (bit * 2);
    i = (i + 1);
  }
  return res;
}
function bit_or(a: number, b: number): number {
  let x: number = a;
  let y: number = b;
  let res: number = 0;
  let bit: number = 1;
  let i: number = 0;
  while ((i < 32)) {
    let abit: number = (x % 2);
    let bbit: number = (y % 2);
    if (((abit == 1) || (bbit == 1))) {
      res = (res + bit);
    }
    x = Math.trunc(x / 2);
    y = Math.trunc(y / 2);
    bit = (bit * 2);
    i = (i + 1);
  }
  return res;
}
function bit_xor(a: number, b: number): number {
  let x: number = a;
  let y: number = b;
  let res: number = 0;
  let bit: number = 1;
  let i: number = 0;
  while ((i < 32)) {
    let abit: number = (x % 2);
    let bbit: number = (y % 2);
    if ((((abit == 1) && (bbit == 0)) || ((abit == 0) && (bbit == 1)))) {
      res = (res + bit);
    }
    x = Math.trunc(x / 2);
    y = Math.trunc(y / 2);
    bit = (bit * 2);
    i = (i + 1);
  }
  return res;
}
function bit_not(a: number): number {
  return ((MOD - 1) - a);
}
function rotate_left(n: number, b: number): number {
  let left: number = ((n * pow2(b)) % MOD);
  let right: number = Math.trunc(n / pow2((32 - b)));
  return ((left + right) % MOD);
}
function to_hex32(n: number): string {
  let digits: string = "0123456789abcdef";
  let num: number = n;
  let s: string = "";
  if ((num == 0)) {
    s = "0";
  }
  while ((num > 0)) {
    let d = (num % 16);
    s = (digits.slice(d, (d + 1)) + s);
    num = Math.trunc(num / 16);
  }
  while ((_len(s) < 8)) {
    s = ("0" + s);
  }
  if ((_len(s) > 8)) {
    s = s.slice((_len(s) - 8), _len(s));
  }
  return s;
}
function sha1(message: string): string {
  let bytes: number[] = [];
  let i: number = 0;
  while ((i < _len(message))) {
    bytes.push(ord(message.slice(i, (i + 1))));
    i = (i + 1);
  }
  bytes.push(128);
  while ((((_len(bytes) + 8) % 64) != 0)) {
    bytes.push(0);
  }
  let bit_len: number = (_len(message) * 8);
  let len_bytes: number[] = [0, 0, 0, 0, 0, 0, 0, 0];
  let bl: number = bit_len;
  let k: number = 7;
  while ((k >= 0)) {
    len_bytes[(k) < 0 ? len_bytes.length + (k) : k] = (bl % 256);
    bl = Math.trunc(bl / 256);
    k = (k - 1);
  }
  let j: number = 0;
  while ((j < 8)) {
    bytes.push(len_bytes[(j) < 0 ? len_bytes.length + (j) : j]);
    j = (j + 1);
  }
  let blocks: number[][] = [];
  let pos: number = 0;
  while ((pos < _len(bytes))) {
    let block: number[] = [];
    let j2: number = 0;
    while ((j2 < 64)) {
      block.push(bytes[(Math.trunc((pos + j2))) < 0 ? bytes.length + (Math.trunc((pos + j2))) : Math.trunc((pos + j2))]);
      j2 = (j2 + 1);
    }
    blocks.push(block);
    pos = (pos + 64);
  }
  let h0: number = 1732584193;
  let h1: number = 4023233417;
  let h2: number = 2562383102;
  let h3: number = 271733878;
  let h4: number = 3285377520;
  let bindex: number = 0;
  while ((bindex < _len(blocks))) {
    let block: number[] = blocks[(bindex) < 0 ? blocks.length + (bindex) : bindex];
    let w: number[] = [];
    let t: number = 0;
    while ((t < 16)) {
      let j3: number = (t * 4);
      let word: number = ((((((block[(j3) < 0 ? block.length + (j3) : j3] * 256) + block[(Math.trunc((j3 + 1))) < 0 ? block.length + (Math.trunc((j3 + 1))) : Math.trunc((j3 + 1))]) * 256) + block[(Math.trunc((j3 + 2))) < 0 ? block.length + (Math.trunc((j3 + 2))) : Math.trunc((j3 + 2))]) * 256) + block[(Math.trunc((j3 + 3))) < 0 ? block.length + (Math.trunc((j3 + 3))) : Math.trunc((j3 + 3))]);
      w.push(word);
      t = (t + 1);
    }
    while ((t < 80)) {
      let tmp: number = bit_xor(bit_xor(bit_xor(w[(Math.trunc((t - 3))) < 0 ? w.length + (Math.trunc((t - 3))) : Math.trunc((t - 3))], w[(Math.trunc((t - 8))) < 0 ? w.length + (Math.trunc((t - 8))) : Math.trunc((t - 8))]), w[(Math.trunc((t - 14))) < 0 ? w.length + (Math.trunc((t - 14))) : Math.trunc((t - 14))]), w[(Math.trunc((t - 16))) < 0 ? w.length + (Math.trunc((t - 16))) : Math.trunc((t - 16))]);
      w.push(rotate_left(tmp, 1));
      t = (t + 1);
    }
    let a: number = h0;
    let b: number = h1;
    let c: number = h2;
    let d: number = h3;
    let e: number = h4;
    let i2: number = 0;
    while ((i2 < 80)) {
      let f: number = 0;
      let kconst: number = 0;
      if ((i2 < 20)) {
        f = bit_or(bit_and(b, c), bit_and(bit_not(b), d));
        kconst = 1518500249;
      } else {
        if ((i2 < 40)) {
          f = bit_xor(bit_xor(b, c), d);
          kconst = 1859775393;
        } else {
          if ((i2 < 60)) {
            f = bit_or(bit_or(bit_and(b, c), bit_and(b, d)), bit_and(c, d));
            kconst = 2400959708;
          } else {
            f = bit_xor(bit_xor(b, c), d);
            kconst = 3395469782;
          }
        }
      }
      let temp: number = (((((rotate_left(a, 5) + f) + e) + kconst) + w[(i2) < 0 ? w.length + (i2) : i2]) % MOD);
      e = d;
      d = c;
      c = rotate_left(b, 30);
      b = a;
      a = temp;
      i2 = (i2 + 1);
    }
    h0 = ((h0 + a) % MOD);
    h1 = ((h1 + b) % MOD);
    h2 = ((h2 + c) % MOD);
    h3 = ((h3 + d) % MOD);
    h4 = ((h4 + e) % MOD);
    bindex = (bindex + 1);
  }
  return ((((to_hex32(h0) + to_hex32(h1)) + to_hex32(h2)) + to_hex32(h3)) + to_hex32(h4));
}
function main() {
  console.log(_str(sha1("Test String")));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

