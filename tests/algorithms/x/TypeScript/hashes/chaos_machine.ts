// Generated by Mochi v0.10.63 on 2025-08-12 08:44:33 GMT+7

let K: number[] = [0.33, 0.44, 0.55, 0.44, 0.33];
let t: number = 3;
let size: number = 5;
export interface Machine { buffer: number[]; params: number[]; time: number }
export interface PullResult { value: number; machine: Machine }
function round_dec(x: number, n: number): number {
  let m10: number = 1.0;
  let i: number = 0;
  while ((i < n)) {
    m10 = (m10 * 10.0);
    i = (i + 1);
  }
  let y: number = ((x * m10) + 0.5);
  return ((1.0 * Math.trunc(y)) / m10);
}
function reset(): Machine {
  return {"buffer": K, "params": [0.0, 0.0, 0.0, 0.0, 0.0], "time": 0};
}
function push(m: Machine, seed: number): Machine {
  let buf: number[] = m.buffer;
  let par: number[] = m.params;
  let i: number = 0;
  while ((i < _len(buf))) {
    let value: number = buf[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? buf.length + _mochi_idx : _mochi_idx;})()];
    let e: number = ((1.0 * seed) / value);
    let next_value: number = (buf[(()=>{const _mochi_idx = Math.trunc(((i + 1) % size)); return _mochi_idx < 0 ? buf.length + _mochi_idx : _mochi_idx;})()] + e);
    next_value = (next_value - (1.0 * Math.trunc(next_value)));
    let r: number = (par[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? par.length + _mochi_idx : _mochi_idx;})()] + e);
    r = (r - (1.0 * Math.trunc(r)));
    r = (r + 3.0);
    buf[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? buf.length + _mochi_idx : _mochi_idx;})()] = round_dec(((r * next_value) * (1.0 - next_value)), 10);
    par[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? par.length + _mochi_idx : _mochi_idx;})()] = r;
    i = (i + 1);
  }
  return {"buffer": buf, "params": par, "time": (m.time + 1)};
}
function xor(a: number, b: number): number {
  let aa: number = a;
  let bb: number = b;
  let res: number = 0;
  let bit: number = 1;
  while (((aa > 0) || (bb > 0))) {
    let abit: number = (aa % 2);
    let bbit: number = (bb % 2);
    if ((abit != bbit)) {
      res = (res + bit);
    }
    aa = Math.trunc(aa / 2);
    bb = Math.trunc(bb / 2);
    bit = (bit * 2);
  }
  return res;
}
function xorshift(x: number, y: number): number {
  let xv: number = x;
  let yv: number = y;
  xv = xor(xv, Math.trunc(yv / 8192));
  yv = xor(yv, (xv * 131072));
  xv = xor(xv, Math.trunc(yv / 32));
  return xv;
}
function pull(m: Machine): PullResult {
  let buf: number[] = m.buffer;
  let par: number[] = m.params;
  let key: number = (m.time % size);
  let i: number = 0;
  while ((i < t)) {
    let r: number = par[(()=>{const _mochi_idx = key; return _mochi_idx < 0 ? par.length + _mochi_idx : _mochi_idx;})()];
    let value: number = buf[(()=>{const _mochi_idx = key; return _mochi_idx < 0 ? buf.length + _mochi_idx : _mochi_idx;})()];
    buf[(()=>{const _mochi_idx = key; return _mochi_idx < 0 ? buf.length + _mochi_idx : _mochi_idx;})()] = round_dec(((r * value) * (1.0 - value)), 10);
    let new_r: number = (((1.0 * m.time) * 0.01) + (r * 1.01));
    new_r = (new_r - (1.0 * Math.trunc(new_r)));
    par[(()=>{const _mochi_idx = key; return _mochi_idx < 0 ? par.length + _mochi_idx : _mochi_idx;})()] = (new_r + 3.0);
    i = (i + 1);
  }
  let x: number = Math.trunc((buf[(()=>{const _mochi_idx = Math.trunc(((key + 2) % size)); return _mochi_idx < 0 ? buf.length + _mochi_idx : _mochi_idx;})()] * 10000000000.0));
  let y: number = Math.trunc((buf[(()=>{const _mochi_idx = Math.trunc((((key + size) - 2) % size)); return _mochi_idx < 0 ? buf.length + _mochi_idx : _mochi_idx;})()] * 10000000000.0));
  let new_machine: Machine = {"buffer": buf, "params": par, "time": (m.time + 1)};
  let value: number = Number((BigInt(xorshift(x, y)) % 4294967295n));
  return {value, "machine": new_machine};
}
let i: number = 0;
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  if (typeof performance !== 'undefined' && (performance as any).memory) {
    return (performance as any).memory.usedJSHeapSize;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let machine: Machine
let res: PullResult
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
machine = reset()
  while ((i < 100)) {
    machine = push(machine, i);
    i = (i + 1);
  }
res = pull(machine)
  console.log(_str(res.value));
  console.log(_str(((v)=>v==null?"nil":"[" + v.join(' ') + "]")(res.machine.buffer)));
  console.log(_str(((v)=>v==null?"nil":"[" + v.join(' ') + "]")(res.machine.params)));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

