// Generated by Mochi v0.10.61 on 2025-08-08 15:57:24 GMT+7

function index_of(s: string, ch: string): number {
  let i: number = 0;
  while ((i < _len(s))) {
    if ((s[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? s.length + _mochi_idx : _mochi_idx;})()] == ch)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}
function ord(ch: string): number {
  let upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let lower = "abcdefghijklmnopqrstuvwxyz";
  let idx = index_of(upper, ch);
  if ((idx >= 0)) {
    return (65 + idx);
  }
  idx = index_of(lower, ch);
  if ((idx >= 0)) {
    return (97 + idx);
  }
  return 0;
}
function chr(n: number): string {
  let upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let lower = "abcdefghijklmnopqrstuvwxyz";
  if (((n >= 65) && (n < 91))) {
    return upper.slice((n - 65), (n - 64));
  }
  if (((n >= 97) && (n < 123))) {
    return lower.slice((n - 97), (n - 96));
  }
  return "?";
}
function text_to_bits(text: string): string {
  let bits: string = "";
  let i: number = 0;
  while ((i < _len(text))) {
    let code: number = ord(text[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? text.length + _mochi_idx : _mochi_idx;})()]);
    let j: number = 7;
    while ((j >= 0)) {
      let p: number = pow2(j);
      if (((Math.trunc(code / p) % 2) == 1)) {
        bits = (bits + "1");
      } else {
        bits = (bits + "0");
      }
      j = (j - 1);
    }
    i = (i + 1);
  }
  return bits;
}
function text_from_bits(bits: string): string {
  let text: string = "";
  let i: number = 0;
  while ((i < _len(bits))) {
    let code: number = 0;
    let j: number = 0;
    while (((j < 8) && ((i + j) < _len(bits)))) {
      code = (code * 2);
      if ((bits[(()=>{const _mochi_idx = Math.trunc((i + j)); return _mochi_idx < 0 ? bits.length + _mochi_idx : _mochi_idx;})()] == "1")) {
        code = (code + 1);
      }
      j = (j + 1);
    }
    text = (text + chr(code));
    i = (i + 8);
  }
  return text;
}
function bool_to_string(b: boolean): string {
  if (b) {
    return "True";
  }
  return "False";
}
function string_to_bitlist(s: string): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < _len(s))) {
    if ((s[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? s.length + _mochi_idx : _mochi_idx;})()] == "1")) {
      res.push(1);
    } else {
      res.push(0);
    }
    i = (i + 1);
  }
  return res;
}
function bitlist_to_string(bits: number[]): string {
  let s: string = "";
  let i: number = 0;
  while ((i < _len(bits))) {
    if ((bits[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? bits.length + _mochi_idx : _mochi_idx;})()] == 1)) {
      s = (s + "1");
    } else {
      s = (s + "0");
    }
    i = (i + 1);
  }
  return s;
}
function is_power_of_two(x: number): boolean {
  if ((x < 1)) {
    return false;
  }
  let p: number = 1;
  while ((p < x)) {
    p = (p * 2);
  }
  return (p == x);
}
function list_eq(a: number[], b: number[]): boolean {
  if ((_len(a) != _len(b))) {
    return false;
  }
  let i: number = 0;
  while ((i < _len(a))) {
    if ((a[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? a.length + _mochi_idx : _mochi_idx;})()] != b[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? b.length + _mochi_idx : _mochi_idx;})()])) {
      return false;
    }
    i = (i + 1);
  }
  return true;
}
function pow2(e: number): number {
  let res: number = 1;
  let i: number = 0;
  while ((i < e)) {
    res = (res * 2);
    i = (i + 1);
  }
  return res;
}
function has_bit(n: number, b: number): boolean {
  let p: number = pow2(b);
  if (((Math.trunc(n / p) % 2) == 1)) {
    return true;
  }
  return false;
}
export interface DecodeResult { data: number[]; ack: boolean }
function hamming_encode(r: number, data_bits: number[]): number[] {
  let total: number = (r + _len(data_bits));
  let data_ord: number[] = [];
  let cont_data: number = 0;
  let x: number = 1;
  while ((x <= total)) {
    if (is_power_of_two(x)) {
      data_ord.push(-1);
    } else {
      data_ord.push(data_bits[(()=>{const _mochi_idx = cont_data; return _mochi_idx < 0 ? data_bits.length + _mochi_idx : _mochi_idx;})()]);
      cont_data = (cont_data + 1);
    }
    x = (x + 1);
  }
  let parity: number[] = [];
  let bp: number = 0;
  while ((bp < r)) {
    let cont_bo: number = 0;
    let j: number = 0;
    while ((j < _len(data_ord))) {
      let bit: number = data_ord[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? data_ord.length + _mochi_idx : _mochi_idx;})()];
      if ((bit >= 0)) {
        let pos: number = (j + 1);
        if ((has_bit(pos, bp) && (bit == 1))) {
          cont_bo = (cont_bo + 1);
        }
      }
      j = (j + 1);
    }
    parity.push((cont_bo % 2));
    bp = (bp + 1);
  }
  let result: number[] = [];
  let cont_bp: number = 0;
  let i: number = 0;
  while ((i < _len(data_ord))) {
    if ((data_ord[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? data_ord.length + _mochi_idx : _mochi_idx;})()] < 0)) {
      result.push(parity[(()=>{const _mochi_idx = cont_bp; return _mochi_idx < 0 ? parity.length + _mochi_idx : _mochi_idx;})()]);
      cont_bp = (cont_bp + 1);
    } else {
      result.push(data_ord[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? data_ord.length + _mochi_idx : _mochi_idx;})()]);
    }
    i = (i + 1);
  }
  return result;
}
function hamming_decode(r: number, code: number[]): DecodeResult {
  let data_output: number[] = [];
  let parity_received: number[] = [];
  let i: number = 1;
  let idx: number = 0;
  while ((i <= _len(code))) {
    if (is_power_of_two(i)) {
      parity_received.push(code[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? code.length + _mochi_idx : _mochi_idx;})()]);
    } else {
      data_output.push(code[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? code.length + _mochi_idx : _mochi_idx;})()]);
    }
    idx = (idx + 1);
    i = (i + 1);
  }
  let recomputed: number[] = hamming_encode(r, data_output);
  let parity_calc: number[] = [];
  let j: number = 0;
  while ((j < _len(recomputed))) {
    if (is_power_of_two((j + 1))) {
      parity_calc.push(recomputed[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? recomputed.length + _mochi_idx : _mochi_idx;})()]);
    }
    j = (j + 1);
  }
  let ack: boolean = list_eq(parity_received, parity_calc);
  return {"data": data_output, ack};
}
function main() {
  let sizePari: number = 4;
  let be: number = 2;
  let text: string = "Message01";
  let binary: string = text_to_bits(text);
  console.log(_str((("Text input in binary is '" + binary) + "'")));
  let data_bits: number[] = string_to_bitlist(binary);
  let encoded: number[] = hamming_encode(sizePari, data_bits);
  console.log(_str(("Data converted ----------> " + bitlist_to_string(encoded))));
  let decoded: DecodeResult = hamming_decode(sizePari, encoded);
  console.log(_str(((("Data receive ------------> " + bitlist_to_string(decoded.data)) + " -- Data integrity: ") + bool_to_string(decoded.ack))));
  let corrupted: number[] = [];
  let i: number = 0;
  while ((i < _len(encoded))) {
    corrupted.push(encoded[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? encoded.length + _mochi_idx : _mochi_idx;})()]);
    i = (i + 1);
  }
  let pos: number = (be - 1);
  if ((corrupted[(()=>{const _mochi_idx = pos; return _mochi_idx < 0 ? corrupted.length + _mochi_idx : _mochi_idx;})()] == 0)) {
    corrupted[(()=>{const _mochi_idx = pos; return _mochi_idx < 0 ? corrupted.length + _mochi_idx : _mochi_idx;})()] = 1;
  } else {
    corrupted[(()=>{const _mochi_idx = pos; return _mochi_idx < 0 ? corrupted.length + _mochi_idx : _mochi_idx;})()] = 0;
  }
  let decoded_err: DecodeResult = hamming_decode(sizePari, corrupted);
  console.log(_str(((("Data receive (error) ----> " + bitlist_to_string(decoded_err.data)) + " -- Data integrity: ") + bool_to_string(decoded_err.ack))));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

