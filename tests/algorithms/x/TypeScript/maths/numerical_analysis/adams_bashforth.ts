// Generated by Mochi v0.10.67 on 2025-08-17 09:17:04 GMT+7

function abs_float(x: number): number {
  if ((x < 0.0)) {
    return -x;
  } else {
    return x;
  }
}
function validate_inputs(x_initials: number[], step_size: number, x_final: number) {
  if ((x_initials[(()=>{const _mochi_idx = Math.trunc((_len(x_initials) - 1)); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()] >= x_final)) {
    _panic("The final value of x must be greater than the initial values of x.");
  }
  if ((step_size <= 0.0)) {
    _panic("Step size must be positive.");
  }
  let i: number = 0;
  while ((i < (_len(x_initials) - 1))) {
    let diff: number = (x_initials[(()=>{const _mochi_idx = Math.trunc((i + 1)); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()] - x_initials[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()]);
    if ((abs_float((diff - step_size)) > 1e-10)) {
      _panic("x-values must be equally spaced according to step size.");
    }
    i = (i + 1);
  }
}
function list_to_string(xs: number[]): string {
  let s: string = "[";
  let i: number = 0;
  while ((i < _len(xs))) {
    s = (s + _str(xs[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? xs.length + _mochi_idx : _mochi_idx;})()]));
    if (((i + 1) < _len(xs))) {
      s = (s + ", ");
    }
    i = (i + 1);
  }
  s = (s + "]");
  return s;
}
function adams_bashforth_step2(f, x_initials: number[], y_initials: number[], step_size: number, x_final: number): number[] {
  validate_inputs(x_initials, step_size, x_final);
  if (((_len(x_initials) !== 2) || (_len(y_initials) !== 2))) {
    _panic("Insufficient initial points information.");
  }
  let x0: number = x_initials[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x1: number = x_initials[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let y: number[] = [];
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  let n: number = Math.trunc(((x_final - x1) / step_size));
  let i: number = 0;
  while ((i < n)) {
    let term: number = ((3.0 * f(x1, y[(()=>{const _mochi_idx = Math.trunc((i + 1)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()])) - f(x0, y[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()]));
    let y_next: number = (y[(()=>{const _mochi_idx = Math.trunc((i + 1)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()] + ((step_size / 2.0) * term));
    y.push(y_next);
    x0 = x1;
    x1 = (x1 + step_size);
    i = (i + 1);
  }
  return y;
}
function adams_bashforth_step3(f, x_initials: number[], y_initials: number[], step_size: number, x_final: number): number[] {
  validate_inputs(x_initials, step_size, x_final);
  if (((_len(x_initials) !== 3) || (_len(y_initials) !== 3))) {
    _panic("Insufficient initial points information.");
  }
  let x0: number = x_initials[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x1: number = x_initials[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x2: number = x_initials[(()=>{const _mochi_idx = Math.trunc(2); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let y: number[] = [];
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(2); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  let n: number = Math.trunc(((x_final - x2) / step_size));
  let i: number = 0;
  while ((i <= n)) {
    let term: number = (((23.0 * f(x2, y[(()=>{const _mochi_idx = Math.trunc((i + 2)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()])) - (16.0 * f(x1, y[(()=>{const _mochi_idx = Math.trunc((i + 1)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()]))) + (5.0 * f(x0, y[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()])));
    let y_next: number = (y[(()=>{const _mochi_idx = Math.trunc((i + 2)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()] + ((step_size / 12.0) * term));
    y.push(y_next);
    x0 = x1;
    x1 = x2;
    x2 = (x2 + step_size);
    i = (i + 1);
  }
  return y;
}
function adams_bashforth_step4(f, x_initials: number[], y_initials: number[], step_size: number, x_final: number): number[] {
  validate_inputs(x_initials, step_size, x_final);
  if (((_len(x_initials) !== 4) || (_len(y_initials) !== 4))) {
    _panic("Insufficient initial points information.");
  }
  let x0: number = x_initials[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x1: number = x_initials[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x2: number = x_initials[(()=>{const _mochi_idx = Math.trunc(2); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x3: number = x_initials[(()=>{const _mochi_idx = Math.trunc(3); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let y: number[] = [];
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(2); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(3); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  let n: number = Math.trunc(((x_final - x3) / step_size));
  let i: number = 0;
  while ((i < n)) {
    let term: number = ((((55.0 * f(x3, y[(()=>{const _mochi_idx = Math.trunc((i + 3)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()])) - (59.0 * f(x2, y[(()=>{const _mochi_idx = Math.trunc((i + 2)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()]))) + (37.0 * f(x1, y[(()=>{const _mochi_idx = Math.trunc((i + 1)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()]))) - (9.0 * f(x0, y[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()])));
    let y_next: number = (y[(()=>{const _mochi_idx = Math.trunc((i + 3)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()] + ((step_size / 24.0) * term));
    y.push(y_next);
    x0 = x1;
    x1 = x2;
    x2 = x3;
    x3 = (x3 + step_size);
    i = (i + 1);
  }
  return y;
}
function adams_bashforth_step5(f, x_initials: number[], y_initials: number[], step_size: number, x_final: number): number[] {
  validate_inputs(x_initials, step_size, x_final);
  if (((_len(x_initials) !== 5) || (_len(y_initials) !== 5))) {
    _panic("Insufficient initial points information.");
  }
  let x0: number = x_initials[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x1: number = x_initials[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x2: number = x_initials[(()=>{const _mochi_idx = Math.trunc(2); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x3: number = x_initials[(()=>{const _mochi_idx = Math.trunc(3); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let x4: number = x_initials[(()=>{const _mochi_idx = Math.trunc(4); return _mochi_idx < 0 ? x_initials.length + _mochi_idx : _mochi_idx;})()];
  let y: number[] = [];
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(2); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(3); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  y.push(y_initials[(()=>{const _mochi_idx = Math.trunc(4); return _mochi_idx < 0 ? y_initials.length + _mochi_idx : _mochi_idx;})()]);
  let n: number = Math.trunc(((x_final - x4) / step_size));
  let i: number = 0;
  while ((i <= n)) {
    let term: number = (((((1901.0 * f(x4, y[(()=>{const _mochi_idx = Math.trunc((i + 4)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()])) - (2774.0 * f(x3, y[(()=>{const _mochi_idx = Math.trunc((i + 3)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()]))) - (2616.0 * f(x2, y[(()=>{const _mochi_idx = Math.trunc((i + 2)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()]))) - (1274.0 * f(x1, y[(()=>{const _mochi_idx = Math.trunc((i + 1)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()]))) + (251.0 * f(x0, y[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()])));
    let y_next: number = (y[(()=>{const _mochi_idx = Math.trunc((i + 4)); return _mochi_idx < 0 ? y.length + _mochi_idx : _mochi_idx;})()] + ((step_size / 720.0) * term));
    y.push(y_next);
    x0 = x1;
    x1 = x2;
    x2 = x3;
    x3 = x4;
    x4 = (x4 + step_size);
    i = (i + 1);
  }
  return y;
}
function f_x(x: number, y: number): number {
  return x;
}
function f_xy(x: number, y: number): number {
  return (x + y);
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  if (typeof performance !== 'undefined' && (performance as any).memory) {
    return (performance as any).memory.usedJSHeapSize;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  if (Array.isArray(x)) {
    return '[' + x.map(_str).join(', ') + ']';
  }
  if (x && typeof x === 'object') {
    try { return JSON.stringify(x); } catch { return String(x); }
  }
  return String(x);
}
function _panic(msg: any): never { throw new Error(String(msg)); }
let y2: number[]
let y3: number[]
let y4: number[]
let y5: number[]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
y2 = adams_bashforth_step2(f_x, [0.0, 0.2], [0.0, 0.0], 0.2, 1.0)
  console.log(_str(list_to_string(y2)));
y3 = adams_bashforth_step3(f_xy, [0.0, 0.2, 0.4], [0.0, 0.0, 0.04], 0.2, 1.0)
  console.log(_str(y3[(()=>{const _mochi_idx = Math.trunc(3); return _mochi_idx < 0 ? y3.length + _mochi_idx : _mochi_idx;})()]));
y4 = adams_bashforth_step4(f_xy, [0.0, 0.2, 0.4, 0.6], [0.0, 0.0, 0.04, 0.128], 0.2, 1.0)
  console.log(_str(y4[(()=>{const _mochi_idx = Math.trunc(4); return _mochi_idx < 0 ? y4.length + _mochi_idx : _mochi_idx;})()]));
  console.log(_str(y4[(()=>{const _mochi_idx = Math.trunc(5); return _mochi_idx < 0 ? y4.length + _mochi_idx : _mochi_idx;})()]));
y5 = adams_bashforth_step5(f_xy, [0.0, 0.2, 0.4, 0.6, 0.8], [0.0, 0.0214, 0.0214, 0.22211, 0.42536], 0.2, 1.0)
  console.log(_str(y5[(()=>{const _mochi_idx = Math.trunc((_len(y5) - 1)); return _mochi_idx < 0 ? y5.length + _mochi_idx : _mochi_idx;})()]));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log('\n' + JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

