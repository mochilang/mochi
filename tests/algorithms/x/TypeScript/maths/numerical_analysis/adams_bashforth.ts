// Generated by Mochi v0.10.59 on 2025-08-07 00:17:53 GMT+7

function abs_float(x: number): number {
  if ((x < 0.0)) {
    return -x;
  } else {
    return x;
  }
}
function validate_inputs(x_initials: number[], step_size: number, x_final: number) {
  if ((x_initials[(Math.trunc((_len(x_initials) - 1))) < 0 ? x_initials.length + (Math.trunc((_len(x_initials) - 1))) : Math.trunc((_len(x_initials) - 1))] >= x_final)) {
    _panic("The final value of x must be greater than the initial values of x.");
  }
  if ((step_size <= 0.0)) {
    _panic("Step size must be positive.");
  }
  let i: number = 0;
  while ((i < (_len(x_initials) - 1))) {
    let diff: number = (x_initials[(Math.trunc((i + 1))) < 0 ? x_initials.length + (Math.trunc((i + 1))) : Math.trunc((i + 1))] - x_initials[(i) < 0 ? x_initials.length + (i) : i]);
    if ((abs_float((diff - step_size)) > 1e-10)) {
      _panic("x-values must be equally spaced according to step size.");
    }
    i = (i + 1);
  }
}
function list_to_string(xs: number[]): string {
  let s: string = "[";
  let i: number = 0;
  while ((i < _len(xs))) {
    s = (s + _str(xs[(i) < 0 ? xs.length + (i) : i]));
    if (((i + 1) < _len(xs))) {
      s = (s + ", ");
    }
    i = (i + 1);
  }
  s = (s + "]");
  return s;
}
function adams_bashforth_step2(f, x_initials: number[], y_initials: number[], step_size: number, x_final: number): number[] {
  validate_inputs(x_initials, step_size, x_final);
  if (((_len(x_initials) != 2) || (_len(y_initials) != 2))) {
    _panic("Insufficient initial points information.");
  }
  let x0: number = x_initials[(Math.trunc(0)) < 0 ? x_initials.length + (Math.trunc(0)) : Math.trunc(0)];
  let x1: number = x_initials[(Math.trunc(1)) < 0 ? x_initials.length + (Math.trunc(1)) : Math.trunc(1)];
  let y: number[] = [];
  y.push(y_initials[(Math.trunc(0)) < 0 ? y_initials.length + (Math.trunc(0)) : Math.trunc(0)]);
  y.push(y_initials[(Math.trunc(1)) < 0 ? y_initials.length + (Math.trunc(1)) : Math.trunc(1)]);
  let n: number = Math.trunc(((x_final - x1) / step_size));
  let i: number = 0;
  while ((i < n)) {
    let term: number = ((3.0 * f(x1, y[(Math.trunc((i + 1))) < 0 ? y.length + (Math.trunc((i + 1))) : Math.trunc((i + 1))])) - f(x0, y[(i) < 0 ? y.length + (i) : i]));
    let y_next: number = (y[(Math.trunc((i + 1))) < 0 ? y.length + (Math.trunc((i + 1))) : Math.trunc((i + 1))] + ((step_size / 2.0) * term));
    y.push(y_next);
    x0 = x1;
    x1 = (x1 + step_size);
    i = (i + 1);
  }
  return y;
}
function adams_bashforth_step3(f, x_initials: number[], y_initials: number[], step_size: number, x_final: number): number[] {
  validate_inputs(x_initials, step_size, x_final);
  if (((_len(x_initials) != 3) || (_len(y_initials) != 3))) {
    _panic("Insufficient initial points information.");
  }
  let x0: number = x_initials[(Math.trunc(0)) < 0 ? x_initials.length + (Math.trunc(0)) : Math.trunc(0)];
  let x1: number = x_initials[(Math.trunc(1)) < 0 ? x_initials.length + (Math.trunc(1)) : Math.trunc(1)];
  let x2: number = x_initials[(Math.trunc(2)) < 0 ? x_initials.length + (Math.trunc(2)) : Math.trunc(2)];
  let y: number[] = [];
  y.push(y_initials[(Math.trunc(0)) < 0 ? y_initials.length + (Math.trunc(0)) : Math.trunc(0)]);
  y.push(y_initials[(Math.trunc(1)) < 0 ? y_initials.length + (Math.trunc(1)) : Math.trunc(1)]);
  y.push(y_initials[(Math.trunc(2)) < 0 ? y_initials.length + (Math.trunc(2)) : Math.trunc(2)]);
  let n: number = Math.trunc(((x_final - x2) / step_size));
  let i: number = 0;
  while ((i <= n)) {
    let term: number = (((23.0 * f(x2, y[(Math.trunc((i + 2))) < 0 ? y.length + (Math.trunc((i + 2))) : Math.trunc((i + 2))])) - (16.0 * f(x1, y[(Math.trunc((i + 1))) < 0 ? y.length + (Math.trunc((i + 1))) : Math.trunc((i + 1))]))) + (5.0 * f(x0, y[(i) < 0 ? y.length + (i) : i])));
    let y_next: number = (y[(Math.trunc((i + 2))) < 0 ? y.length + (Math.trunc((i + 2))) : Math.trunc((i + 2))] + ((step_size / 12.0) * term));
    y.push(y_next);
    x0 = x1;
    x1 = x2;
    x2 = (x2 + step_size);
    i = (i + 1);
  }
  return y;
}
function adams_bashforth_step4(f, x_initials: number[], y_initials: number[], step_size: number, x_final: number): number[] {
  validate_inputs(x_initials, step_size, x_final);
  if (((_len(x_initials) != 4) || (_len(y_initials) != 4))) {
    _panic("Insufficient initial points information.");
  }
  let x0: number = x_initials[(Math.trunc(0)) < 0 ? x_initials.length + (Math.trunc(0)) : Math.trunc(0)];
  let x1: number = x_initials[(Math.trunc(1)) < 0 ? x_initials.length + (Math.trunc(1)) : Math.trunc(1)];
  let x2: number = x_initials[(Math.trunc(2)) < 0 ? x_initials.length + (Math.trunc(2)) : Math.trunc(2)];
  let x3: number = x_initials[(Math.trunc(3)) < 0 ? x_initials.length + (Math.trunc(3)) : Math.trunc(3)];
  let y: number[] = [];
  y.push(y_initials[(Math.trunc(0)) < 0 ? y_initials.length + (Math.trunc(0)) : Math.trunc(0)]);
  y.push(y_initials[(Math.trunc(1)) < 0 ? y_initials.length + (Math.trunc(1)) : Math.trunc(1)]);
  y.push(y_initials[(Math.trunc(2)) < 0 ? y_initials.length + (Math.trunc(2)) : Math.trunc(2)]);
  y.push(y_initials[(Math.trunc(3)) < 0 ? y_initials.length + (Math.trunc(3)) : Math.trunc(3)]);
  let n: number = Math.trunc(((x_final - x3) / step_size));
  let i: number = 0;
  while ((i < n)) {
    let term: number = ((((55.0 * f(x3, y[(Math.trunc((i + 3))) < 0 ? y.length + (Math.trunc((i + 3))) : Math.trunc((i + 3))])) - (59.0 * f(x2, y[(Math.trunc((i + 2))) < 0 ? y.length + (Math.trunc((i + 2))) : Math.trunc((i + 2))]))) + (37.0 * f(x1, y[(Math.trunc((i + 1))) < 0 ? y.length + (Math.trunc((i + 1))) : Math.trunc((i + 1))]))) - (9.0 * f(x0, y[(i) < 0 ? y.length + (i) : i])));
    let y_next: number = (y[(Math.trunc((i + 3))) < 0 ? y.length + (Math.trunc((i + 3))) : Math.trunc((i + 3))] + ((step_size / 24.0) * term));
    y.push(y_next);
    x0 = x1;
    x1 = x2;
    x2 = x3;
    x3 = (x3 + step_size);
    i = (i + 1);
  }
  return y;
}
function adams_bashforth_step5(f, x_initials: number[], y_initials: number[], step_size: number, x_final: number): number[] {
  validate_inputs(x_initials, step_size, x_final);
  if (((_len(x_initials) != 5) || (_len(y_initials) != 5))) {
    _panic("Insufficient initial points information.");
  }
  let x0: number = x_initials[(Math.trunc(0)) < 0 ? x_initials.length + (Math.trunc(0)) : Math.trunc(0)];
  let x1: number = x_initials[(Math.trunc(1)) < 0 ? x_initials.length + (Math.trunc(1)) : Math.trunc(1)];
  let x2: number = x_initials[(Math.trunc(2)) < 0 ? x_initials.length + (Math.trunc(2)) : Math.trunc(2)];
  let x3: number = x_initials[(Math.trunc(3)) < 0 ? x_initials.length + (Math.trunc(3)) : Math.trunc(3)];
  let x4: number = x_initials[(Math.trunc(4)) < 0 ? x_initials.length + (Math.trunc(4)) : Math.trunc(4)];
  let y: number[] = [];
  y.push(y_initials[(Math.trunc(0)) < 0 ? y_initials.length + (Math.trunc(0)) : Math.trunc(0)]);
  y.push(y_initials[(Math.trunc(1)) < 0 ? y_initials.length + (Math.trunc(1)) : Math.trunc(1)]);
  y.push(y_initials[(Math.trunc(2)) < 0 ? y_initials.length + (Math.trunc(2)) : Math.trunc(2)]);
  y.push(y_initials[(Math.trunc(3)) < 0 ? y_initials.length + (Math.trunc(3)) : Math.trunc(3)]);
  y.push(y_initials[(Math.trunc(4)) < 0 ? y_initials.length + (Math.trunc(4)) : Math.trunc(4)]);
  let n: number = Math.trunc(((x_final - x4) / step_size));
  let i: number = 0;
  while ((i <= n)) {
    let term: number = (((((1901.0 * f(x4, y[(Math.trunc((i + 4))) < 0 ? y.length + (Math.trunc((i + 4))) : Math.trunc((i + 4))])) - (2774.0 * f(x3, y[(Math.trunc((i + 3))) < 0 ? y.length + (Math.trunc((i + 3))) : Math.trunc((i + 3))]))) - (2616.0 * f(x2, y[(Math.trunc((i + 2))) < 0 ? y.length + (Math.trunc((i + 2))) : Math.trunc((i + 2))]))) - (1274.0 * f(x1, y[(Math.trunc((i + 1))) < 0 ? y.length + (Math.trunc((i + 1))) : Math.trunc((i + 1))]))) + (251.0 * f(x0, y[(i) < 0 ? y.length + (i) : i])));
    let y_next: number = (y[(Math.trunc((i + 4))) < 0 ? y.length + (Math.trunc((i + 4))) : Math.trunc((i + 4))] + ((step_size / 720.0) * term));
    y.push(y_next);
    x0 = x1;
    x1 = x2;
    x2 = x3;
    x3 = x4;
    x4 = (x4 + step_size);
    i = (i + 1);
  }
  return y;
}
function f_x(x: number, y: number): number {
  return x;
}
function f_xy(x: number, y: number): number {
  return (x + y);
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
function _panic(msg: any): never { throw new Error(String(msg)); }
let y2: number[]
let y3: number[]
let y4: number[]
let y5: number[]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
y2 = adams_bashforth_step2(f_x, [0.0, 0.2], [0.0, 0.0], 0.2, 1.0)
  console.log(_str(list_to_string(y2)));
y3 = adams_bashforth_step3(f_xy, [0.0, 0.2, 0.4], [0.0, 0.0, 0.04], 0.2, 1.0)
  console.log(_str(_str(y3[(Math.trunc(3)) < 0 ? y3.length + (Math.trunc(3)) : Math.trunc(3)])));
y4 = adams_bashforth_step4(f_xy, [0.0, 0.2, 0.4, 0.6], [0.0, 0.0, 0.04, 0.128], 0.2, 1.0)
  console.log(_str(_str(y4[(Math.trunc(4)) < 0 ? y4.length + (Math.trunc(4)) : Math.trunc(4)])));
  console.log(_str(_str(y4[(Math.trunc(5)) < 0 ? y4.length + (Math.trunc(5)) : Math.trunc(5)])));
y5 = adams_bashforth_step5(f_xy, [0.0, 0.2, 0.4, 0.6, 0.8], [0.0, 0.0214, 0.0214, 0.22211, 0.42536], 0.2, 1.0)
  console.log(_str(_str(y5[(Math.trunc((_len(y5) - 1))) < 0 ? y5.length + (Math.trunc((_len(y5) - 1))) : Math.trunc((_len(y5) - 1))])));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

