// Generated by Mochi v0.10.63 on 2025-08-12 07:58:56 GMT+7

function log2(x: number): number {
  let k: number = 0.0;
  let v: number = x;
  while ((v >= 2.0)) {
    v = (v / 2.0);
    k = (k + 1.0);
  }
  while ((v < 1.0)) {
    v = (v * 2.0);
    k = (k - 1.0);
  }
  let z: number = ((v - 1.0) / (v + 1.0));
  let zpow: number = z;
  let sum: number = z;
  let i: number = 3;
  while ((i <= 9)) {
    zpow = ((zpow * z) * z);
    sum = (sum + (zpow / i));
    i = (i + 2);
  }
  let ln2: number = 0.6931471805599453;
  return (k + ((2.0 * sum) / ln2));
}
export interface TextCounts { single: Record<string, number>; double: Record<string, number> }
function analyze_text(text: string): TextCounts {
  let single: Record<string, number> = {};
  let double: Record<string, number> = {};
  let n: number = _len(text);
  if ((n == 0)) {
    return {single, double};
  }
  let last: string = (text).substring((n - 1), n);
  if ((last in single)) {
    single[(()=>{const _mochi_idx = last; return _mochi_idx < 0 ? single.length + _mochi_idx : _mochi_idx;})()] = (single[last] + 1);
  } else {
    single[(()=>{const _mochi_idx = last; return _mochi_idx < 0 ? single.length + _mochi_idx : _mochi_idx;})()] = 1;
  }
  let first = (text).substring(0, 1);
  let pair0: string = (" " + first);
  double[(()=>{const _mochi_idx = pair0; return _mochi_idx < 0 ? double.length + _mochi_idx : _mochi_idx;})()] = 1;
  let i: number = 0;
  while ((i < (n - 1))) {
    let ch: string = (text).substring(i, (i + 1));
    if ((ch in single)) {
      single[(()=>{const _mochi_idx = ch; return _mochi_idx < 0 ? single.length + _mochi_idx : _mochi_idx;})()] = (single[ch] + 1);
    } else {
      single[(()=>{const _mochi_idx = ch; return _mochi_idx < 0 ? single.length + _mochi_idx : _mochi_idx;})()] = 1;
    }
    let seq: string = (text).substring(i, (i + 2));
    if ((seq in double)) {
      double[(()=>{const _mochi_idx = seq; return _mochi_idx < 0 ? double.length + _mochi_idx : _mochi_idx;})()] = (double[seq] + 1);
    } else {
      double[(()=>{const _mochi_idx = seq; return _mochi_idx < 0 ? double.length + _mochi_idx : _mochi_idx;})()] = 1;
    }
    i = (i + 1);
  }
  return {single, double};
}
function round_to_int(x: number): number {
  if ((x < 0.0)) {
    return Math.trunc((x - 0.5));
  }
  return Math.trunc((x + 0.5));
}
function calculate_entropy(text: string) {
  let counts: TextCounts = analyze_text(text);
  let alphas: string = " abcdefghijklmnopqrstuvwxyz";
  let total1: number = 0;
  for (const ch in counts.single) {
    total1 = (total1 + counts.single[ch]);
  }
  let h1: number = 0.0;
  let i: number = 0;
  while ((i < _len(alphas))) {
    let ch: string = (alphas).substring(i, (i + 1));
    if ((ch in counts.single)) {
      let prob: number = (counts.single[ch] / total1);
      h1 = (h1 + (prob * log2(prob)));
    }
    i = (i + 1);
  }
  let first_entropy: number = -h1;
  console.log(_str((_str(round_to_int(first_entropy)) + ".0")));
  let total2: number = 0;
  for (const seq in counts.double) {
    total2 = (total2 + counts.double[seq]);
  }
  let h2: number = 0.0;
  let a0: number = 0;
  while ((a0 < _len(alphas))) {
    let ch0: string = (alphas).substring(a0, (a0 + 1));
    let a1: number = 0;
    while ((a1 < _len(alphas))) {
      let ch1: string = (alphas).substring(a1, (a1 + 1));
      let seq: string = (ch0 + ch1);
      if ((seq in counts.double)) {
        let prob: number = (counts.double[seq] / total2);
        h2 = (h2 + (prob * log2(prob)));
      }
      a1 = (a1 + 1);
    }
    a0 = (a0 + 1);
  }
  let second_entropy: number = -h2;
  console.log(_str((_str(round_to_int(second_entropy)) + ".0")));
  let diff: number = (second_entropy - first_entropy);
  console.log(_str((_str(round_to_int(diff)) + ".0")));
}
let text1: string = (("Behind Winston's back the voice " + "from the telescreen was still ") + "babbling and the overfulfilment");
let text3: string = (((((((((("Had repulsive dashwoods suspicion sincerity but advantage now him. " + "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. ") + "You greatest jointure saw horrible. He private he on be imagine ") + "suppose. Fertile beloved evident through no service elderly is. Blind ") + "there if every no so at. Own neglected you preferred way sincerity ") + "delivered his attempted. To of message cottage windows do besides ") + "against uncivil.  Delightful unreserved impossible few estimating ") + "men favourable see entreaties. She propriety immediate was improving. ") + "He or entrance humoured likewise moderate. Much nor game son say ") + "feel. Fat make met can must form into gate. Me we offending prevailed ") + "discovery.");
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  if (typeof performance !== 'undefined' && (performance as any).memory) {
    return (performance as any).memory.usedJSHeapSize;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  calculate_entropy(text1);
  calculate_entropy(text3);
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

