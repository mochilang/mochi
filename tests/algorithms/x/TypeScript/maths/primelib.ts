// Generated by Mochi v0.10.59 on 2025-08-07 00:18:22 GMT+7

function abs_int(x: number): number {
  if ((x < 0)) {
    return -x;
  }
  return x;
}
function gcd_iter(a: number, b: number): number {
  let x: number = abs_int(a);
  let y: number = abs_int(b);
  while ((y != 0)) {
    let t: number = y;
    y = (x % y);
    x = t;
  }
  return x;
}
function is_prime(n: number): boolean {
  if ((n <= 1)) {
    return false;
  }
  let d: number = 2;
  while (((d * d) <= n)) {
    if (((n % d) == 0)) {
      return false;
    }
    d = (d + 1);
  }
  return true;
}
function sieve_er(n: number): number[] {
  let nums: number[] = [];
  let i: number = 2;
  while ((i <= n)) {
    nums.push(i);
    i = (i + 1);
  }
  let idx: number = 0;
  while ((idx < _len(nums))) {
    let j: number = (idx + 1);
    while ((j < _len(nums))) {
      if ((nums[(idx) < 0 ? nums.length + (idx) : idx] != 0)) {
        if (((nums[(j) < 0 ? nums.length + (j) : j] % nums[(idx) < 0 ? nums.length + (idx) : idx]) == 0)) {
          nums[(j) < 0 ? nums.length + (j) : j] = 0;
        }
      }
      j = (j + 1);
    }
    idx = (idx + 1);
  }
  let res: number[] = [];
  let k: number = 0;
  while ((k < _len(nums))) {
    let v: number = nums[(k) < 0 ? nums.length + (k) : k];
    if ((v != 0)) {
      res.push(v);
    }
    k = (k + 1);
  }
  return res;
}
function get_prime_numbers(n: number): number[] {
  let ans: number[] = [];
  let num: number = 2;
  while ((num <= n)) {
    if (is_prime(num)) {
      ans.push(num);
    }
    num = (num + 1);
  }
  return ans;
}
function prime_factorization(_number: number): number[] {
  if ((_number == 0)) {
    return [0];
  }
  if ((_number == 1)) {
    return [1];
  }
  let ans: number[] = [];
  if (is_prime(_number)) {
    ans.push(_number);
    return ans;
  }
  let quotient: number = _number;
  let factor: number = 2;
  while ((quotient != 1)) {
    if ((is_prime(factor) && ((quotient % factor) == 0))) {
      ans.push(factor);
      quotient = Math.trunc(quotient / factor);
    } else {
      factor = (factor + 1);
    }
  }
  return ans;
}
function greatest_prime_factor(_number: number): number {
  let factors: number[] = prime_factorization(_number);
  let m: number = factors[(Math.trunc(0)) < 0 ? factors.length + (Math.trunc(0)) : Math.trunc(0)];
  let i: number = 1;
  while ((i < _len(factors))) {
    if ((factors[(i) < 0 ? factors.length + (i) : i] > m)) {
      m = factors[(i) < 0 ? factors.length + (i) : i];
    }
    i = (i + 1);
  }
  return m;
}
function smallest_prime_factor(_number: number): number {
  let factors: number[] = prime_factorization(_number);
  let m: number = factors[(Math.trunc(0)) < 0 ? factors.length + (Math.trunc(0)) : Math.trunc(0)];
  let i: number = 1;
  while ((i < _len(factors))) {
    if ((factors[(i) < 0 ? factors.length + (i) : i] < m)) {
      m = factors[(i) < 0 ? factors.length + (i) : i];
    }
    i = (i + 1);
  }
  return m;
}
function kg_v(number1: number, number2: number): number {
  if (((number1 < 1) || (number2 < 1))) {
    _panic("numbers must be positive");
  }
  let g: number = gcd_iter(number1, number2);
  return (Math.trunc(number1 / g) * number2);
}
function is_even(_number: number): boolean {
  return ((_number % 2) == 0);
}
function is_odd(_number: number): boolean {
  return ((_number % 2) != 0);
}
function goldbach(_number: number): number[] {
  if ((!is_even(_number) || (_number <= 2))) {
    _panic("number must be even and > 2");
  }
  let primes: number[] = get_prime_numbers(_number);
  let i: number = 0;
  while ((i < _len(primes))) {
    let j: number = (i + 1);
    while ((j < _len(primes))) {
      if (((primes[(i) < 0 ? primes.length + (i) : i] + primes[(j) < 0 ? primes.length + (j) : j]) == _number)) {
        return [primes[(i) < 0 ? primes.length + (i) : i], primes[(j) < 0 ? primes.length + (j) : j]];
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
  return [];
}
function get_prime(n: number): number {
  if ((n < 0)) {
    _panic("n must be non-negative");
  }
  let index: number = 0;
  let ans: number = 2;
  while ((index < n)) {
    index = (index + 1);
    ans = (ans + 1);
    while (!is_prime(ans)) {
      ans = (ans + 1);
    }
  }
  return ans;
}
function get_primes_between(p1: number, p2: number): number[] {
  let bad1: boolean = !is_prime(p1);
  let bad2: boolean = !is_prime(p2);
  if (((bad1 || bad2) || (p1 >= p2))) {
    _panic("arguments must be prime and p1 < p2");
  }
  let num: number = (p1 + 1);
  while ((num < p2)) {
    if (is_prime(num)) {
      break
    }
    num = (num + 1);
  }
  let ans: number[] = [];
  while ((num < p2)) {
    ans.push(num);
    num = (num + 1);
    while ((num < p2)) {
      if (is_prime(num)) {
        break
      }
      num = (num + 1);
    }
  }
  return ans;
}
function get_divisors(n: number): number[] {
  if ((n < 1)) {
    _panic("n must be >= 1");
  }
  let ans: number[] = [];
  let d: number = 1;
  while ((d <= n)) {
    if (((n % d) == 0)) {
      ans.push(d);
    }
    d = (d + 1);
  }
  return ans;
}
function is_perfect_number(_number: number): boolean {
  if ((_number <= 1)) {
    _panic("number must be > 1");
  }
  let divisors: number[] = get_divisors(_number);
  let sum: number = 0;
  let i: number = 0;
  while ((i < (_len(divisors) - 1))) {
    sum = (sum + divisors[(i) < 0 ? divisors.length + (i) : i]);
    i = (i + 1);
  }
  return (sum == _number);
}
function simplify_fraction(numerator: number, denominator: number): number[] {
  if ((denominator == 0)) {
    _panic("denominator cannot be zero");
  }
  let g: number = gcd_iter(abs_int(numerator), abs_int(denominator));
  return [Math.trunc(numerator / g), Math.trunc(denominator / g)];
}
function factorial(n: number): number {
  if ((n < 0)) {
    _panic("n must be >= 0");
  }
  let ans: number = 1;
  let i: number = 1;
  while ((i <= n)) {
    ans = (ans * i);
    i = (i + 1);
  }
  return ans;
}
function fib(n: number): number {
  if ((n < 0)) {
    _panic("n must be >= 0");
  }
  if ((n <= 1)) {
    return 1;
  }
  let tmp: number = 0;
  let fib1: number = 1;
  let ans: number = 1;
  let i: number = 0;
  while ((i < (n - 1))) {
    tmp = ans;
    ans = (ans + fib1);
    fib1 = tmp;
    i = (i + 1);
  }
  return ans;
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
function _panic(msg: any): never { throw new Error(String(msg)); }
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  console.log(_str(_str(is_prime(97))));
  console.log(_str(_str(sieve_er(20))));
  console.log(_str(_str(get_prime_numbers(20))));
  console.log(_str(_str(prime_factorization(287))));
  console.log(_str(_str(greatest_prime_factor(287))));
  console.log(_str(_str(smallest_prime_factor(287))));
  console.log(_str(_str(kg_v(8, 10))));
  console.log(_str(_str(goldbach(28))));
  console.log(_str(_str(get_prime(8))));
  console.log(_str(_str(get_primes_between(3, 20))));
  console.log(_str(_str(get_divisors(28))));
  console.log(_str(_str(is_perfect_number(28))));
  console.log(_str(_str(simplify_fraction(10, 20))));
  console.log(_str(_str(factorial(5))));
  console.log(_str(_str(fib(10))));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

