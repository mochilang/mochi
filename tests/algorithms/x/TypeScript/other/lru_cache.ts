// Generated by Mochi v0.10.59 on 2025-08-07 08:17:48 GMT+7

export interface Node { key: number; value: number; prev: number; next: number }
export interface DoubleLinkedList { nodes: Node[]; head: number; tail: number }
function new_list(): DoubleLinkedList {
  let nodes: Node[] = [];
  let head: Node = {"key": 0, "value": 0, "prev": (0 - 1), "next": 1};
  let tail: Node = {"key": 0, "value": 0, "prev": 0, "next": (0 - 1)};
  nodes.push(head);
  nodes.push(tail);
  return {nodes, "head": 0, "tail": 1};
}
function dll_add(lst: DoubleLinkedList, idx: number): DoubleLinkedList {
  let nodes: Node[] = lst.nodes;
  let tail_idx: number = lst.tail;
  let tail_node: Node = nodes[(tail_idx) < 0 ? nodes.length + (tail_idx) : tail_idx];
  let prev_idx: number = tail_node.prev;
  let node: Node = nodes[(idx) < 0 ? nodes.length + (idx) : idx];
  node.prev = prev_idx;
  node.next = tail_idx;
  nodes[(idx) < 0 ? nodes.length + (idx) : idx] = node;
  let prev_node: Node = nodes[(prev_idx) < 0 ? nodes.length + (prev_idx) : prev_idx];
  prev_node.next = idx;
  nodes[(prev_idx) < 0 ? nodes.length + (prev_idx) : prev_idx] = prev_node;
  tail_node.prev = idx;
  nodes[(tail_idx) < 0 ? nodes.length + (tail_idx) : tail_idx] = tail_node;
  lst.nodes = nodes;
  return lst;
}
function dll_remove(lst: DoubleLinkedList, idx: number): DoubleLinkedList {
  let nodes: Node[] = lst.nodes;
  let node: Node = nodes[(idx) < 0 ? nodes.length + (idx) : idx];
  let prev_idx: number = node.prev;
  let next_idx: number = node.next;
  if (((prev_idx == (0 - 1)) || (next_idx == (0 - 1)))) {
    return lst;
  }
  let prev_node: Node = nodes[(prev_idx) < 0 ? nodes.length + (prev_idx) : prev_idx];
  prev_node.next = next_idx;
  nodes[(prev_idx) < 0 ? nodes.length + (prev_idx) : prev_idx] = prev_node;
  let next_node: Node = nodes[(next_idx) < 0 ? nodes.length + (next_idx) : next_idx];
  next_node.prev = prev_idx;
  nodes[(next_idx) < 0 ? nodes.length + (next_idx) : next_idx] = next_node;
  node.prev = (0 - 1);
  node.next = (0 - 1);
  nodes[(idx) < 0 ? nodes.length + (idx) : idx] = node;
  lst.nodes = nodes;
  return lst;
}
export interface LRUCache { list: DoubleLinkedList; capacity: number; num_keys: number; hits: number; misses: number; cache: Record<string, number> }
export interface GetResult { cache: LRUCache; value: number; ok: boolean }
function new_cache(cap: number): LRUCache {
  let empty_map: Record<string, number> = {};
  return {"list": new_list(), "capacity": cap, "num_keys": 0, "hits": 0, "misses": 0, "cache": empty_map};
}
function lru_get(c: LRUCache, key: number): GetResult {
  let cache: LRUCache = c;
  let key_str: string = _str(key);
  if ((key_str in cache.cache)) {
    let idx: number = cache.cache[(key_str) < 0 ? cache.cache.length + (key_str) : key_str];
    if ((idx != (0 - 1))) {
      cache.hits = (cache.hits + 1);
      let node: Node = cache.list.nodes[(idx) < 0 ? cache.list.nodes.length + (idx) : idx];
      let value: number = node.value;
      cache.list = dll_remove(cache.list, idx);
      cache.list = dll_add(cache.list, idx);
      return {cache, value, "ok": true};
    }
  }
  cache.misses = (cache.misses + 1);
  return {cache, "value": 0, "ok": false};
}
function lru_put(c: LRUCache, key: number, value: number): LRUCache {
  let cache: LRUCache = c;
  let key_str: string = _str(key);
  if (!(key_str in cache.cache)) {
    if ((cache.num_keys >= cache.capacity)) {
      let head_node: Node = cache.list.nodes[(Math.trunc(cache.list.head)) < 0 ? cache.list.nodes.length + (Math.trunc(cache.list.head)) : Math.trunc(cache.list.head)];
      let first_idx: number = head_node.next;
      let first_node: Node = cache.list.nodes[(first_idx) < 0 ? cache.list.nodes.length + (first_idx) : first_idx];
      let old_key: number = first_node.key;
      cache.list = dll_remove(cache.list, first_idx);
      let mdel: Record<string, number> = cache.cache;
      mdel[(_str(old_key)) < 0 ? mdel.length + (_str(old_key)) : _str(old_key)] = (0 - 1);
      cache.cache = mdel;
      cache.num_keys = (cache.num_keys - 1);
    }
    let nodes: Node[] = cache.list.nodes;
    let new_node: Node = {key, value, "prev": (0 - 1), "next": (0 - 1)};
    nodes.push(new_node);
    let idx: number = (_len(nodes) - 1);
    cache.list.nodes = nodes;
    cache.list = dll_add(cache.list, idx);
    let m: Record<string, number> = cache.cache;
    m[(key_str) < 0 ? m.length + (key_str) : key_str] = idx;
    cache.cache = m;
    cache.num_keys = (cache.num_keys + 1);
  } else {
    let m: Record<string, number> = cache.cache;
    let idx: number = m[(key_str) < 0 ? m.length + (key_str) : key_str];
    let nodes: Node[] = cache.list.nodes;
    let node: Node = nodes[(idx) < 0 ? nodes.length + (idx) : idx];
    node.value = value;
    nodes[(idx) < 0 ? nodes.length + (idx) : idx] = node;
    cache.list.nodes = nodes;
    cache.list = dll_remove(cache.list, idx);
    cache.list = dll_add(cache.list, idx);
    cache.cache = m;
  }
  return cache;
}
function cache_info(cache: LRUCache): string {
  return (((((((("CacheInfo(hits=" + _str(cache.hits)) + ", misses=") + _str(cache.misses)) + ", capacity=") + _str(cache.capacity)) + ", current size=") + _str(cache.num_keys)) + ")");
}
function print_result(res: GetResult) {
  if (res.ok) {
    console.log(_str(_str(res.value)));
  } else {
    console.log(_str("None"));
  }
}
function main() {
  let cache: LRUCache = new_cache(2);
  cache = lru_put(cache, 1, 1);
  cache = lru_put(cache, 2, 2);
  let r1: GetResult = lru_get(cache, 1);
  cache = r1.cache;
  print_result(r1);
  cache = lru_put(cache, 3, 3);
  let r2: GetResult = lru_get(cache, 2);
  cache = r2.cache;
  print_result(r2);
  cache = lru_put(cache, 4, 4);
  let r3: GetResult = lru_get(cache, 1);
  cache = r3.cache;
  print_result(r3);
  let r4: GetResult = lru_get(cache, 3);
  cache = r4.cache;
  print_result(r4);
  let r5: GetResult = lru_get(cache, 4);
  cache = r5.cache;
  print_result(r5);
  console.log(_str(cache_info(cache)));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

