// Generated by Mochi v0.10.59 on 2025-08-06 20:29:20 GMT+7

let abc: string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
let low_abc: string = "abcdefghijklmnopqrstuvwxyz";
let rotor1: string = "EGZWVONAHDCLFQMSIPJBYUKXTR";
let rotor2: string = "FOBHMDKEXQNRAULPGSJVTYICZW";
let rotor3: string = "ZJXESIUQLHAVRMDOYGTNFWPBKC";
let rotor4: string = "RMDJXFUWGISLHVTCQNKYPBEZOA";
let rotor5: string = "SGLCPQWZHKXAREONTFBVIYJUDM";
let rotor6: string = "HVSICLTYKQUBXDWAJZOMFGPREN";
let rotor7: string = "RZWQHFMVDBKICJLNTUXAGYPSOE";
let rotor8: string = "LFKIJODBEGAMQPXVUHYSTCZRWN";
let rotor9: string = "KOAEGVDHXPQZMLFTYWJNBRCIUS";
let reflector_pairs: string[] = ["AN", "BO", "CP", "DQ", "ER", "FS", "GT", "HU", "IV", "JW", "KX", "LY", "MZ"];
function list_contains(xs: string[], x: string): boolean {
  let i: number = 0;
  while ((i < _len(xs))) {
    if ((xs[i] == x)) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function index_in_string(s: string, ch: string): number {
  let i: number = 0;
  while ((i < _len(s))) {
    if (((s).substring(i, (i + 1)) == ch)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}
function contains_char(s: string, ch: string): boolean {
  return (index_in_string(s, ch) >= 0);
}
function to_uppercase(s: string): string {
  let res: string = "";
  let i: number = 0;
  while ((i < _len(s))) {
    let ch: string = (s).substring(i, (i + 1));
    let idx: number = index_in_string(low_abc, ch);
    if ((idx >= 0)) {
      res = (res + (abc).substring(idx, (idx + 1)));
    } else {
      res = (res + ch);
    }
    i = (i + 1);
  }
  return res;
}
function plugboard_map(pb: string[], ch: string): string {
  let i: number = 0;
  while ((i < _len(pb))) {
    let pair: string = pb[i];
    let a: string = (pair).substring(0, 1);
    let b: string = (pair).substring(1, 2);
    if ((ch == a)) {
      return b;
    }
    if ((ch == b)) {
      return a;
    }
    i = (i + 1);
  }
  return ch;
}
function reflector_map(ch: string): string {
  let i: number = 0;
  while ((i < _len(reflector_pairs))) {
    let pair: string = reflector_pairs[i];
    let a: string = (pair).substring(0, 1);
    let b: string = (pair).substring(1, 2);
    if ((ch == a)) {
      return b;
    }
    if ((ch == b)) {
      return a;
    }
    i = (i + 1);
  }
  return ch;
}
function count_unique(xs: string[]): number {
  let unique: string[] = [];
  let i: number = 0;
  while ((i < _len(xs))) {
    if (!list_contains(unique, xs[i])) {
      unique.push(xs[i]);
    }
    i = (i + 1);
  }
  return _len(unique);
}
function build_plugboard(pbstring: string): string[] {
  if ((_len(pbstring) == 0)) {
    return [];
  }
  if (((_len(pbstring) % 2) != 0)) {
    panic((("Odd number of symbols(" + _str(_len(pbstring))) + ")"));
  }
  let pbstring_nospace: string = "";
  let i: number = 0;
  while ((i < _len(pbstring))) {
    let ch: string = (pbstring).substring(i, (i + 1));
    if ((ch != " ")) {
      pbstring_nospace = (pbstring_nospace + ch);
    }
    i = (i + 1);
  }
  let seen: string[] = [];
  i = 0;
  while ((i < _len(pbstring_nospace))) {
    let ch: string = (pbstring_nospace).substring(i, (i + 1));
    if (!contains_char(abc, ch)) {
      panic((("'" + ch) + "' not in list of symbols"));
    }
    if (list_contains(seen, ch)) {
      panic((("Duplicate symbol(" + ch) + ")"));
    }
    seen.push(ch);
    i = (i + 1);
  }
  let pb: string[] = [];
  i = 0;
  while ((i < (_len(pbstring_nospace) - 1))) {
    let a: string = (pbstring_nospace).substring(i, (i + 1));
    let b: string = (pbstring_nospace).substring((i + 1), (i + 2));
    pb.push((a + b));
    i = (i + 2);
  }
  return pb;
}
function validator(rotpos: number[], rotsel: string[], pb: string) {
  if ((count_unique(rotsel) < 3)) {
    panic((("Please use 3 unique rotors (not " + _str(count_unique(rotsel))) + ")"));
  }
  if ((_len(rotpos) != 3)) {
    panic("Rotor position must have 3 values");
  }
  let r1: number = rotpos[Math.trunc(0)];
  let r2: number = rotpos[Math.trunc(1)];
  let r3: number = rotpos[Math.trunc(2)];
  if (!((0 < r1) && (r1 <= _len(abc)))) {
    panic((("First rotor position is not within range of 1..26 (" + _str(r1)) + ")"));
  }
  if (!((0 < r2) && (r2 <= _len(abc)))) {
    panic((("Second rotor position is not within range of 1..26 (" + _str(r2)) + ")"));
  }
  if (!((0 < r3) && (r3 <= _len(abc)))) {
    panic((("Third rotor position is not within range of 1..26 (" + _str(r3)) + ")"));
  }
}
function enigma(text: string, rotor_position: number[], rotor_selection: string[], plugb: string): string {
  let up_text: string = to_uppercase(text);
  let up_pb: string = to_uppercase(plugb);
  validator(rotor_position, rotor_selection, up_pb);
  let plugboard: string[] = build_plugboard(up_pb);
  let rotorpos1: number = (rotor_position[Math.trunc(0)] - 1);
  let rotorpos2: number = (rotor_position[Math.trunc(1)] - 1);
  let rotorpos3: number = (rotor_position[Math.trunc(2)] - 1);
  let rotor_a: string = rotor_selection[Math.trunc(0)];
  let rotor_b: string = rotor_selection[Math.trunc(1)];
  let rotor_c: string = rotor_selection[Math.trunc(2)];
  let result: string = "";
  let i: number = 0;
  while ((i < _len(up_text))) {
    let _symbol: string = (up_text).substring(i, (i + 1));
    if (contains_char(abc, _symbol)) {
      _symbol = plugboard_map(plugboard, _symbol);
      let index: number = (index_in_string(abc, _symbol) + rotorpos1);
      _symbol = (rotor_a).substring((index % _len(abc)), ((index % _len(abc)) + 1));
      index = (index_in_string(abc, _symbol) + rotorpos2);
      _symbol = (rotor_b).substring((index % _len(abc)), ((index % _len(abc)) + 1));
      index = (index_in_string(abc, _symbol) + rotorpos3);
      _symbol = (rotor_c).substring((index % _len(abc)), ((index % _len(abc)) + 1));
      _symbol = reflector_map(_symbol);
      index = (index_in_string(rotor_c, _symbol) - rotorpos3);
      if ((index < 0)) {
        index = (index + _len(abc));
      }
      _symbol = (abc).substring(index, (index + 1));
      index = (index_in_string(rotor_b, _symbol) - rotorpos2);
      if ((index < 0)) {
        index = (index + _len(abc));
      }
      _symbol = (abc).substring(index, (index + 1));
      index = (index_in_string(rotor_a, _symbol) - rotorpos1);
      if ((index < 0)) {
        index = (index + _len(abc));
      }
      _symbol = (abc).substring(index, (index + 1));
      _symbol = plugboard_map(plugboard, _symbol);
      rotorpos1 = (rotorpos1 + 1);
      if ((rotorpos1 >= _len(abc))) {
        rotorpos1 = 0;
        rotorpos2 = (rotorpos2 + 1);
      }
      if ((rotorpos2 >= _len(abc))) {
        rotorpos2 = 0;
        rotorpos3 = (rotorpos3 + 1);
      }
      if ((rotorpos3 >= _len(abc))) {
        rotorpos3 = 0;
      }
    }
    result = (result + _symbol);
    i = (i + 1);
  }
  return result;
}
function main() {
  let message: string = "This is my Python script that emulates the Enigma machine from WWII.";
  let rotor_pos: number[] = [1, 1, 1];
  let pb: string = "pictures";
  let rotor_sel: string[] = [rotor2, rotor4, rotor8];
  let en: string = enigma(message, rotor_pos, rotor_sel, pb);
  console.log(_str(("Encrypted message: " + en)));
  console.log(_str(("Decrypted message: " + enigma(en, rotor_pos, rotor_sel, pb))));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
function panic(msg: any): never { throw new Error(String(msg)); }
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

