// Generated by Mochi v0.10.59 on 2025-08-06 20:29:52 GMT+7

function ord(ch: string): number {
  let digits: string = "0123456789";
  let i: number = 0;
  while ((i < _len(digits))) {
    if (((digits).substring(i, (i + 1)) == ch)) {
      return (48 + i);
    }
    i = (i + 1);
  }
  let upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  i = 0;
  while ((i < _len(upper))) {
    if (((upper).substring(i, (i + 1)) == ch)) {
      return (65 + i);
    }
    i = (i + 1);
  }
  let lower = "abcdefghijklmnopqrstuvwxyz";
  i = 0;
  while ((i < _len(lower))) {
    if (((lower).substring(i, (i + 1)) == ch)) {
      return (97 + i);
    }
    i = (i + 1);
  }
  return 0;
}
function neg_pos(iterlist: number[]): number[] {
  let i: number = 1;
  while ((i < _len(iterlist))) {
    iterlist[i] = -iterlist[i];
    i = (i + 2);
  }
  return iterlist;
}
function passcode_creator(): string[] {
  let choices: string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let seed: number = _now();
  let length: number = (10 + (seed % 11));
  let password: string[] = [];
  let i: number = 0;
  while ((i < length)) {
    seed = (((seed * 1103515245) + 12345) % 2147483647);
    let idx: number = (seed % _len(choices));
    password.push((choices).substring(idx, (idx + 1)));
    i = (i + 1);
  }
  return password;
}
function unique_sorted(chars: string[]): string[] {
  let uniq: string[] = [];
  let i: number = 0;
  while ((i < _len(chars))) {
    let ch: string = chars[i];
    if (!uniq.includes(ch)) {
      uniq.push(ch);
    }
    i = (i + 1);
  }
  let j: number = 0;
  while ((j < _len(uniq))) {
    let k: number = (j + 1);
    let min_idx: number = j;
    while ((k < _len(uniq))) {
      if ((uniq[k] < uniq[min_idx])) {
        min_idx = k;
      }
      k = (k + 1);
    }
    if ((min_idx != j)) {
      let tmp: string = uniq[j];
      uniq[j] = uniq[min_idx];
      uniq[min_idx] = tmp;
    }
    j = (j + 1);
  }
  return uniq;
}
function make_key_list(passcode: string[]): string[] {
  let key_list_options: string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n";
  let breakpoints: string[] = unique_sorted(passcode);
  let keys_l: string[] = [];
  let temp_list: string[] = [];
  let i: number = 0;
  while ((i < _len(key_list_options))) {
    let ch: string = (key_list_options).substring(i, (i + 1));
    temp_list.push(ch);
    if ((breakpoints.includes(ch) || (i == (_len(key_list_options) - 1)))) {
      let k: number = (_len(temp_list) - 1);
      while ((k >= 0)) {
        keys_l.push(temp_list[k]);
        k = (k - 1);
      }
      temp_list = [];
    }
    i = (i + 1);
  }
  return keys_l;
}
function make_shift_key(passcode: string[]): number {
  let codes: number[] = [];
  let i: number = 0;
  while ((i < _len(passcode))) {
    codes.push(ord(passcode[i]));
    i = (i + 1);
  }
  codes = neg_pos(codes);
  let total: number = 0;
  i = 0;
  while ((i < _len(codes))) {
    total = (total + codes[i]);
    i = (i + 1);
  }
  if ((total > 0)) {
    return total;
  }
  return _len(passcode);
}
export interface Cipher { passcode: string[]; key_list: string[]; shift_key: number }
function new_cipher(passcode_str: string): Cipher {
  let passcode: string[] = [];
  if ((_len(passcode_str) == 0)) {
    passcode = passcode_creator();
  } else {
    let i: number = 0;
    while ((i < _len(passcode_str))) {
      passcode.push((passcode_str).substring(i, (i + 1)));
      i = (i + 1);
    }
  }
  let key_list: string[] = make_key_list(passcode);
  let shift_key: number = make_shift_key(passcode);
  return {passcode, key_list, shift_key};
}
function index_of(lst: string[], ch: string): number {
  let i: number = 0;
  while ((i < _len(lst))) {
    if ((lst[i] == ch)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}
function encrypt(c: Cipher, plaintext: string): string {
  let encoded: string = "";
  let i: number = 0;
  let n: number = _len(c.key_list);
  while ((i < _len(plaintext))) {
    let ch: string = (plaintext).substring(i, (i + 1));
    let position: number = index_of(c.key_list, ch);
    let new_pos: number = ((position + c.shift_key) % n);
    encoded = (encoded + c.key_list[new_pos]);
    i = (i + 1);
  }
  return encoded;
}
function decrypt(c: Cipher, encoded_message: string): string {
  let decoded: string = "";
  let i: number = 0;
  let n: number = _len(c.key_list);
  while ((i < _len(encoded_message))) {
    let ch: string = (encoded_message).substring(i, (i + 1));
    let position: number = index_of(c.key_list, ch);
    let new_pos: number = ((position - c.shift_key) % n);
    if ((new_pos < 0)) {
      new_pos = (new_pos + n);
    }
    decoded = (decoded + c.key_list[new_pos]);
    i = (i + 1);
  }
  return decoded;
}
function test_end_to_end(): string {
  let msg: string = "Hello, this is a modified Caesar cipher";
  let cip: Cipher = new_cipher("");
  return decrypt(cip, encrypt(cip, msg));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let ssc: Cipher
let encoded: string
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
ssc = new_cipher("4PYIXyqeQZr44")
encoded = encrypt(ssc, "Hello, this is a modified Caesar cipher")
  console.log(_str(encoded));
  console.log(_str(decrypt(ssc, encoded)));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

