// Generated by Mochi v0.10.59 on 2025-08-06 20:29:22 GMT+7

export interface MORSE_CODE_DICT { A: string; B: string; C: string; D: string; E: string; F: string; G: string; H: string; I: string; J: string; K: string; L: string; M: string; N: string; O: string; P: string; Q: string; R: string; S: string; T: string; U: string; V: string; W: string; X: string; Y: string; Z: string; " ": string }
export interface REVERSE_DICT { ".-": string; "-...": string; "-.-.": string; "-..": string; ".": string; "..-.": string; "--.": string; "....": string; "..": string; ".---": string; "-.-": string; ".-..": string; "--": string; "-.": string; "---": string; ".--.": string; "--.-": string; ".-.": string; "...": string; "-": string; "..-": string; "...-": string; ".--": string; "-..-": string; "-.--": string; "--..": string; "": string }
let MORSE_CODE_DICT: MORSE_CODE_DICT = {"A": ".-", "B": "-...", "C": "-.-.", "D": "-..", "E": ".", "F": "..-.", "G": "--.", "H": "....", "I": "..", "J": ".---", "K": "-.-", "L": ".-..", "M": "--", "N": "-.", "O": "---", "P": ".--.", "Q": "--.-", "R": ".-.", "S": "...", "T": "-", "U": "..-", "V": "...-", "W": ".--", "X": "-..-", "Y": "-.--", "Z": "--..", " ": ""};
let MORSE_COMBINATIONS: string[] = ["...", "..-", "..x", ".-.", ".--", ".-x", ".x.", ".x-", ".xx", "-..", "-.-", "-.x", "--.", "---", "--x", "-x.", "-x-", "-xx", "x..", "x.-", "x.x", "x-.", "x--", "x-x", "xx.", "xx-", "xxx"];
let REVERSE_DICT: REVERSE_DICT = {".-": "A", "-...": "B", "-.-.": "C", "-..": "D", ".": "E", "..-.": "F", "--.": "G", "....": "H", "..": "I", ".---": "J", "-.-": "K", ".-..": "L", "--": "M", "-.": "N", "---": "O", ".--.": "P", "--.-": "Q", ".-.": "R", "...": "S", "-": "T", "..-": "U", "...-": "V", ".--": "W", "-..-": "X", "-.--": "Y", "--..": "Z", "": " "};
function encodeToMorse(plaintext: string): string {
  let morse: string = "";
  let i: number = 0;
  while ((i < _len(plaintext))) {
    let ch: string = plaintext.slice(i, (i + 1)).toUpperCase();
    let code: string = "";
    if ((ch in MORSE_CODE_DICT)) {
      code = MORSE_CODE_DICT[ch];
    }
    if ((i > 0)) {
      morse = (morse + "x");
    }
    morse = (morse + code);
    i = (i + 1);
  }
  return morse;
}
function encryptFractionatedMorse(plaintext: string, key: string): string {
  let morseCode: string = encodeToMorse(plaintext);
  let combinedKey: string = (key.toUpperCase() + "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  let dedupKey: string = "";
  let i: number = 0;
  while ((i < _len(combinedKey))) {
    let ch: string = combinedKey.slice(i, (i + 1));
    if (!dedupKey.includes(ch)) {
      dedupKey = (dedupKey + ch);
    }
    i = (i + 1);
  }
  let paddingLength: number = (3 - (_len(morseCode) % 3));
  let p: number = 0;
  while ((p < paddingLength)) {
    morseCode = (morseCode + "x");
    p = (p + 1);
  }
  let dict: Record<string, string> = {};
  let j: number = 0;
  while ((j < 26)) {
    let combo: string = MORSE_COMBINATIONS[j];
    let letter: string = dedupKey.slice(j, (j + 1));
    dict[combo] = letter;
    j = (j + 1);
  }
  dict.xxx = "";
  let encrypted: string = "";
  let k: number = 0;
  while ((k < _len(morseCode))) {
    let group: string = morseCode.slice(k, (k + 3));
    encrypted = (encrypted + dict[group]);
    k = (k + 3);
  }
  return encrypted;
}
function decryptFractionatedMorse(ciphertext: string, key: string): string {
  let combinedKey: string = (key.toUpperCase() + "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  let dedupKey: string = "";
  let i: number = 0;
  while ((i < _len(combinedKey))) {
    let ch: string = combinedKey.slice(i, (i + 1));
    if (!dedupKey.includes(ch)) {
      dedupKey = (dedupKey + ch);
    }
    i = (i + 1);
  }
  let inv: Record<string, string> = {};
  let j: number = 0;
  while ((j < 26)) {
    let letter: string = dedupKey.slice(j, (j + 1));
    inv[letter] = MORSE_COMBINATIONS[j];
    j = (j + 1);
  }
  let morse: string = "";
  let k: number = 0;
  while ((k < _len(ciphertext))) {
    let ch: string = ciphertext.slice(k, (k + 1));
    if ((ch in inv)) {
      morse = (morse + inv[ch]);
    }
    k = (k + 1);
  }
  let codes: string[] = [];
  let current: string = "";
  let m: number = 0;
  while ((m < _len(morse))) {
    let ch: string = morse.slice(m, (m + 1));
    if ((ch == "x")) {
      codes.push(current);
      current = "";
    } else {
      current = (current + ch);
    }
    m = (m + 1);
  }
  codes.push(current);
  let decrypted: string = "";
  let idx: number = 0;
  while ((idx < _len(codes))) {
    let code: string = codes[idx];
    decrypted = (decrypted + REVERSE_DICT[code]);
    idx = (idx + 1);
  }
  let start: number = 0;
  while (true) {
    if ((start < _len(decrypted))) {
      if ((decrypted.slice(start, (start + 1)) == " ")) {
        start = (start + 1);
        continue
      }
    }
    break
  }
  let end: number = _len(decrypted);
  while (true) {
    if ((end > start)) {
      if ((decrypted.slice((end - 1), end) == " ")) {
        end = (end - 1);
        continue
      }
    }
    break
  }
  return decrypted.slice(start, end);
}
let plaintext: string = "defend the east";
let key: string = "ROUNDTABLE";
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let ciphertext: string
let decrypted: string
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  console.log(_str("Plain Text:") + " " + _str(plaintext));
ciphertext = encryptFractionatedMorse(plaintext, key)
  console.log(_str("Encrypted:") + " " + _str(ciphertext));
decrypted = decryptFractionatedMorse(ciphertext, key)
  console.log(_str("Decrypted:") + " " + _str(decrypted));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

