// Generated by Mochi v0.10.59 on 2025-08-06 20:29:18 GMT+7

let seed: number = 123456789;
function rand(): number {
  seed = (((seed * 1103515245) + 12345) % 2147483647);
  return seed;
}
function rand_range(min: number, max: number): number {
  return (min + (rand() % ((max - min) + 1)));
}
function mod_pow(base: number, exponent: number, modulus: number): number {
  let result: number = 1;
  let b: number = (base % modulus);
  let e: number = exponent;
  while ((e > 0)) {
    if (((e % 2) == 1)) {
      result = ((result * b) % modulus);
    }
    e = Math.trunc(e / 2);
    b = ((b * b) % modulus);
  }
  return result;
}
export interface GCD { g: number; x: number; y: number }
function extended_gcd(a: number, b: number): GCD {
  if ((b == 0)) {
    return {"g": a, "x": 1, "y": 0};
  }
  let res: GCD = extended_gcd(b, (a % b));
  return {"g": res.g, "x": res.y, "y": (res.x - (Math.trunc(a / b) * res.y))};
}
function mod_inverse(a: number, m: number): number {
  let res: GCD = extended_gcd(a, m);
  if ((res.g != 1)) {
    panic("inverse does not exist");
  }
  let r: number = (res.x % m);
  if ((r < 0)) {
    return (r + m);
  }
  return r;
}
function pow2(n: number): number {
  let r: number = 1;
  let i: number = 0;
  while ((i < n)) {
    r = (r * 2);
    i = (i + 1);
  }
  return r;
}
function is_probable_prime(n: number, k: number): boolean {
  if ((n <= 1)) {
    return false;
  }
  if ((n <= 3)) {
    return true;
  }
  if (((n % 2) == 0)) {
    return false;
  }
  let r: number = 0;
  let d: number = (n - 1);
  while (((d % 2) == 0)) {
    d = Math.trunc(d / 2);
    r = (r + 1);
  }
  let i: number = 0;
  while ((i < k)) {
    let a: number = rand_range(2, (n - 2));
    let x: number = mod_pow(a, d, n);
    if (((x == 1) || (x == (n - 1)))) {
      i = (i + 1);
      continue
    }
    let j: number = 1;
    let found: boolean = false;
    while ((j < r)) {
      x = mod_pow(x, 2, n);
      if ((x == (n - 1))) {
        found = true;
        break
      }
      j = (j + 1);
    }
    if (!found) {
      return false;
    }
    i = (i + 1);
  }
  return true;
}
function generate_large_prime(bits: number): number {
  let min = pow2((bits - 1));
  let max = (pow2(bits) - 1);
  let p = rand_range(min, max);
  if (((p % 2) == 0)) {
    p = (p + 1);
  }
  while (!is_probable_prime(p, 5)) {
    p = (p + 2);
    if ((p > max)) {
      p = (min + 1);
    }
  }
  return p;
}
function primitive_root(p: number): number {
  while (true) {
    let g: number = rand_range(3, (p - 1));
    if ((mod_pow(g, 2, p) == 1)) {
      continue
    }
    if ((mod_pow(g, p, p) == 1)) {
      continue
    }
    return g;
  }
}
export interface PublicKey { key_size: number; g: number; e2: number; p: number }
export interface PrivateKey { key_size: number; d: number }
export interface KeyPair { public_key: PublicKey; private_key: PrivateKey }
function generate_key(key_size: number): KeyPair {
  let p: number = generate_large_prime(key_size);
  let e1: number = primitive_root(p);
  let d: number = rand_range(3, (p - 1));
  let e2: number = mod_inverse(mod_pow(e1, d, p), p);
  let public_key: PublicKey = {key_size, "g": e1, e2, p};
  let private_key: PrivateKey = {key_size, d};
  return {public_key, private_key};
}
function main() {
  let key_size: number = 16;
  let kp: KeyPair = generate_key(key_size);
  let pub: PublicKey = kp.public_key;
  let priv: PrivateKey = kp.private_key;
  console.log(_str((((((((("public key: (" + _str(pub.key_size)) + ", ") + _str(pub.g)) + ", ") + _str(pub.e2)) + ", ") + _str(pub.p)) + ")")));
  console.log(_str((((("private key: (" + _str(priv.key_size)) + ", ") + _str(priv.d)) + ")")));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
function panic(msg: any): never { throw new Error(String(msg)); }
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

