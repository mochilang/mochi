// Generated by Mochi v0.10.59 on 2025-08-07 08:17:00 GMT+7

export interface Matrix { data: number[][]; rows: number; cols: number }
function make_matrix(values: number[][]): Matrix {
  let r = _len(values);
  if ((r == 0)) {
    return {"data": [], "rows": 0, "cols": 0};
  }
  let c = _len(values[(Math.trunc(0)) < 0 ? values.length + (Math.trunc(0)) : Math.trunc(0)]);
  let i: number = 0;
  while ((i < r)) {
    if ((_len(values[(i) < 0 ? values.length + (i) : i]) != c)) {
      return {"data": [], "rows": 0, "cols": 0};
    }
    i = (i + 1);
  }
  return {"data": values, "rows": r, "cols": c};
}
function matrix_columns(m: Matrix): number[][] {
  let cols: number[][] = [];
  let j: number = 0;
  while ((j < m.cols)) {
    let col: number[] = [];
    let i: number = 0;
    while ((i < m.rows)) {
      col.push(m.data[(i) < 0 ? m.data.length + (i) : i][(j) < 0 ? m.data[(i) < 0 ? m.data.length + (i) : i].length + (j) : j]);
      i = (i + 1);
    }
    cols.push(col);
    j = (j + 1);
  }
  return cols;
}
function matrix_identity(m: Matrix): Matrix {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      let v: number = ((i == j) ? 1.0 : 0.0);
      row.push(v);
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {"data": vals, "rows": m.rows, "cols": m.cols};
}
function matrix_minor(m: Matrix, r: number, c: number): number {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    if ((i != r)) {
      let row: number[] = [];
      let j: number = 0;
      while ((j < m.cols)) {
        if ((j != c)) {
          row.push(m.data[(i) < 0 ? m.data.length + (i) : i][(j) < 0 ? m.data[(i) < 0 ? m.data.length + (i) : i].length + (j) : j]);
        }
        j = (j + 1);
      }
      vals.push(row);
    }
    i = (i + 1);
  }
  let sub: Matrix = {"data": vals, "rows": (m.rows - 1), "cols": (m.cols - 1)};
  return matrix_determinant(sub);
}
function matrix_cofactor(m: Matrix, r: number, c: number): number {
  let minor: number = matrix_minor(m, r, c);
  if ((((r + c) % 2) == 0)) {
    return minor;
  }
  return (-1.0 * minor);
}
function matrix_minors(m: Matrix): Matrix {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      row.push(matrix_minor(m, i, j));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {"data": vals, "rows": m.rows, "cols": m.cols};
}
function matrix_cofactors(m: Matrix): Matrix {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      row.push(matrix_cofactor(m, i, j));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {"data": vals, "rows": m.rows, "cols": m.cols};
}
function matrix_determinant(m: Matrix): number {
  if ((m.rows != m.cols)) {
    return 0.0;
  }
  if ((m.rows == 0)) {
    return 0.0;
  }
  if ((m.rows == 1)) {
    return m.data[(Math.trunc(0)) < 0 ? m.data.length + (Math.trunc(0)) : Math.trunc(0)][(Math.trunc(0)) < 0 ? m.data[(Math.trunc(0)) < 0 ? m.data.length + (Math.trunc(0)) : Math.trunc(0)].length + (Math.trunc(0)) : Math.trunc(0)];
  }
  if ((m.rows == 2)) {
    return ((m.data[(Math.trunc(0)) < 0 ? m.data.length + (Math.trunc(0)) : Math.trunc(0)][(Math.trunc(0)) < 0 ? m.data[(Math.trunc(0)) < 0 ? m.data.length + (Math.trunc(0)) : Math.trunc(0)].length + (Math.trunc(0)) : Math.trunc(0)] * m.data[(Math.trunc(1)) < 0 ? m.data.length + (Math.trunc(1)) : Math.trunc(1)][(Math.trunc(1)) < 0 ? m.data[(Math.trunc(1)) < 0 ? m.data.length + (Math.trunc(1)) : Math.trunc(1)].length + (Math.trunc(1)) : Math.trunc(1)]) - (m.data[(Math.trunc(0)) < 0 ? m.data.length + (Math.trunc(0)) : Math.trunc(0)][(Math.trunc(1)) < 0 ? m.data[(Math.trunc(0)) < 0 ? m.data.length + (Math.trunc(0)) : Math.trunc(0)].length + (Math.trunc(1)) : Math.trunc(1)] * m.data[(Math.trunc(1)) < 0 ? m.data.length + (Math.trunc(1)) : Math.trunc(1)][(Math.trunc(0)) < 0 ? m.data[(Math.trunc(1)) < 0 ? m.data.length + (Math.trunc(1)) : Math.trunc(1)].length + (Math.trunc(0)) : Math.trunc(0)]));
  }
  let sum: number = 0.0;
  let j: number = 0;
  while ((j < m.cols)) {
    sum = (sum + (m.data[(Math.trunc(0)) < 0 ? m.data.length + (Math.trunc(0)) : Math.trunc(0)][(j) < 0 ? m.data[(Math.trunc(0)) < 0 ? m.data.length + (Math.trunc(0)) : Math.trunc(0)].length + (j) : j] * matrix_cofactor(m, 0, j)));
    j = (j + 1);
  }
  return sum;
}
function matrix_is_invertible(m: Matrix): boolean {
  return (matrix_determinant(m) != 0.0);
}
function matrix_adjugate(m: Matrix): Matrix {
  let cof: Matrix = matrix_cofactors(m);
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      row.push(cof.data[(j) < 0 ? cof.data.length + (j) : j][(i) < 0 ? cof.data[(j) < 0 ? cof.data.length + (j) : j].length + (i) : i]);
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {"data": vals, "rows": m.rows, "cols": m.cols};
}
function matrix_inverse(m: Matrix): Matrix {
  let det: number = matrix_determinant(m);
  if ((det == 0.0)) {
    return {"data": [], "rows": 0, "cols": 0};
  }
  let adj: Matrix = matrix_adjugate(m);
  return matrix_mul_scalar(adj, (1.0 / det));
}
function matrix_add_row(m: Matrix, row: number[]): Matrix {
  let newData: number[][] = m.data;
  newData.push(row);
  return {"data": newData, "rows": (m.rows + 1), "cols": m.cols};
}
function matrix_add_column(m: Matrix, col: number[]): Matrix {
  let newData: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    newData.push([...m.data[(i) < 0 ? m.data.length + (i) : i], col[(i) < 0 ? col.length + (i) : i]]);
    i = (i + 1);
  }
  return {"data": newData, "rows": m.rows, "cols": (m.cols + 1)};
}
function matrix_mul_scalar(m: Matrix, s: number): Matrix {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      row.push((m.data[(i) < 0 ? m.data.length + (i) : i][(j) < 0 ? m.data[(i) < 0 ? m.data.length + (i) : i].length + (j) : j] * s));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {"data": vals, "rows": m.rows, "cols": m.cols};
}
function matrix_neg(m: Matrix): Matrix {
  return matrix_mul_scalar(m, -1.0);
}
function matrix_add(a: Matrix, b: Matrix): Matrix {
  if (((a.rows != b.rows) || (a.cols != b.cols))) {
    return {"data": [], "rows": 0, "cols": 0};
  }
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < a.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < a.cols)) {
      row.push((a.data[(i) < 0 ? a.data.length + (i) : i][(j) < 0 ? a.data[(i) < 0 ? a.data.length + (i) : i].length + (j) : j] + b.data[(i) < 0 ? b.data.length + (i) : i][(j) < 0 ? b.data[(i) < 0 ? b.data.length + (i) : i].length + (j) : j]));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {"data": vals, "rows": a.rows, "cols": a.cols};
}
function matrix_sub(a: Matrix, b: Matrix): Matrix {
  if (((a.rows != b.rows) || (a.cols != b.cols))) {
    return {"data": [], "rows": 0, "cols": 0};
  }
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < a.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < a.cols)) {
      row.push((a.data[(i) < 0 ? a.data.length + (i) : i][(j) < 0 ? a.data[(i) < 0 ? a.data.length + (i) : i].length + (j) : j] - b.data[(i) < 0 ? b.data.length + (i) : i][(j) < 0 ? b.data[(i) < 0 ? b.data.length + (i) : i].length + (j) : j]));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {"data": vals, "rows": a.rows, "cols": a.cols};
}
function matrix_dot(row: number[], col: number[]): number {
  let sum: number = 0.0;
  let i: number = 0;
  while ((i < _len(row))) {
    sum = (sum + (row[(i) < 0 ? row.length + (i) : i] * col[(i) < 0 ? col.length + (i) : i]));
    i = (i + 1);
  }
  return sum;
}
function matrix_mul(a: Matrix, b: Matrix): Matrix {
  if ((a.cols != b.rows)) {
    return {"data": [], "rows": 0, "cols": 0};
  }
  let bcols: number[][] = matrix_columns(b);
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < a.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < b.cols)) {
      row.push(matrix_dot(a.data[(i) < 0 ? a.data.length + (i) : i], bcols[(j) < 0 ? bcols.length + (j) : j]));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {"data": vals, "rows": a.rows, "cols": b.cols};
}
function matrix_pow(m: Matrix, p: number): Matrix {
  if ((p == 0)) {
    return matrix_identity(m);
  }
  if ((p < 0)) {
    if (matrix_is_invertible(m)) {
      return matrix_pow(matrix_inverse(m), -p);
    }
    return {"data": [], "rows": 0, "cols": 0};
  }
  let result: Matrix = m;
  let i: number = 1;
  while ((i < p)) {
    result = matrix_mul(result, m);
    i = (i + 1);
  }
  return result;
}
function matrix_to_string(m: Matrix): string {
  if ((m.rows == 0)) {
    return "[]";
  }
  let s: string = "[";
  let i: number = 0;
  while ((i < m.rows)) {
    s = (s + "[");
    let j: number = 0;
    while ((j < m.cols)) {
      s = (s + _str(m.data[(i) < 0 ? m.data.length + (i) : i][(j) < 0 ? m.data[(i) < 0 ? m.data.length + (i) : i].length + (j) : j]));
      if ((j < (m.cols - 1))) {
        s = (s + " ");
      }
      j = (j + 1);
    }
    s = (s + "]");
    if ((i < (m.rows - 1))) {
      s = (s + "\n ");
    }
    i = (i + 1);
  }
  s = (s + "]");
  return s;
}
function main() {
  let m: Matrix = make_matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]);
  console.log(_str(matrix_to_string(m)));
  console.log(_str(_str(matrix_columns(m))));
  console.log(_str(((_str(m.rows) + ",") + _str(m.cols))));
  console.log(_str(_str(matrix_is_invertible(m))));
  console.log(_str(matrix_to_string(matrix_identity(m))));
  console.log(_str(_str(matrix_determinant(m))));
  console.log(_str(matrix_to_string(matrix_minors(m))));
  console.log(_str(matrix_to_string(matrix_cofactors(m))));
  console.log(_str(matrix_to_string(matrix_adjugate(m))));
  let m2: Matrix = matrix_mul_scalar(m, 3.0);
  console.log(_str(matrix_to_string(m2)));
  console.log(_str(matrix_to_string(matrix_add(m, m2))));
  console.log(_str(matrix_to_string(matrix_sub(m, m2))));
  console.log(_str(matrix_to_string(matrix_pow(m, 3))));
  let m3: Matrix = matrix_add_row(m, [10.0, 11.0, 12.0]);
  console.log(_str(matrix_to_string(m3)));
  let m4: Matrix = matrix_add_column(m2, [8.0, 16.0, 32.0]);
  console.log(_str(matrix_to_string(matrix_mul(m3, m4))));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

