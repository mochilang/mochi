// Generated by Mochi v0.10.67 on 2025-08-17 13:45:53 GMT+7

export interface Matrix { data: number[][]; rows: number; cols: number }
function make_matrix(values: number[][]): Matrix {
  let r = _len(values);
  if ((r === 0)) {
    return {data: [], rows: 0, cols: 0};
  }
  let c = _len(values[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? values.length + _mochi_idx : _mochi_idx;})()]);
  let i: number = 0;
  while ((i < r)) {
    if ((_len(values[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? values.length + _mochi_idx : _mochi_idx;})()]) !== c)) {
      return {data: [], rows: 0, cols: 0};
    }
    i = (i + 1);
  }
  return {data: values, rows: r, cols: c};
}
function matrix_columns(m: Matrix): number[][] {
  let cols: number[][] = [];
  let j: number = 0;
  while ((j < m.cols)) {
    let col: number[] = [];
    let i: number = 0;
    while ((i < m.rows)) {
      col.push(m.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()]);
      i = (i + 1);
    }
    cols.push(col);
    j = (j + 1);
  }
  return cols;
}
function matrix_identity(m: Matrix): Matrix {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      let v: number = ((i === j) ? 1.0 : 0.0);
      row.push(v);
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {data: vals, rows: m.rows, cols: m.cols};
}
function matrix_minor(m: Matrix, r: number, c: number): number {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    if ((i !== r)) {
      let row: number[] = [];
      let j: number = 0;
      while ((j < m.cols)) {
        if ((j !== c)) {
          row.push(m.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()]);
        }
        j = (j + 1);
      }
      vals.push(row);
    }
    i = (i + 1);
  }
  let sub: Matrix = {data: vals, rows: (m.rows - 1), cols: (m.cols - 1)};
  return matrix_determinant(sub);
}
function matrix_cofactor(m: Matrix, r: number, c: number): number {
  let minor: number = matrix_minor(m, r, c);
  if ((((r + c) % 2) === 0)) {
    return minor;
  }
  return (-1.0 * minor);
}
function matrix_minors(m: Matrix): Matrix {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      row.push(matrix_minor(m, i, j));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {data: vals, rows: m.rows, cols: m.cols};
}
function matrix_cofactors(m: Matrix): Matrix {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      row.push(matrix_cofactor(m, i, j));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {data: vals, rows: m.rows, cols: m.cols};
}
function matrix_determinant(m: Matrix): number {
  if ((m.rows !== m.cols)) {
    return 0.0;
  }
  if ((m.rows === 0)) {
    return 0.0;
  }
  if ((m.rows === 1)) {
    return m.data[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()];
  }
  if ((m.rows === 2)) {
    return ((m.data[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()] * m.data[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()]) - (m.data[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()] * m.data[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = Math.trunc(1); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()]));
  }
  let sum: number = 0.0;
  let j: number = 0;
  while ((j < m.cols)) {
    sum = (sum + (m.data[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()] * matrix_cofactor(m, 0, j)));
    j = (j + 1);
  }
  return sum;
}
function matrix_is_invertible(m: Matrix): boolean {
  return (matrix_determinant(m) !== 0.0);
}
function matrix_adjugate(m: Matrix): Matrix {
  let cof: Matrix = matrix_cofactors(m);
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      row.push(cof.data[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? cof.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? cof.data[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? cof.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()]);
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {data: vals, rows: m.rows, cols: m.cols};
}
function matrix_inverse(m: Matrix): Matrix {
  let det: number = matrix_determinant(m);
  if ((det === 0.0)) {
    return {data: [], rows: 0, cols: 0};
  }
  let adj: Matrix = matrix_adjugate(m);
  return matrix_mul_scalar(adj, (1.0 / det));
}
function matrix_add_row(m: Matrix, row: number[]): Matrix {
  let newData: number[][] = m.data;
  newData.push(row);
  return {data: newData, rows: (m.rows + 1), cols: m.cols};
}
function matrix_add_column(m: Matrix, col: number[]): Matrix {
  let newData: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    newData.push([...m.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()], col[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? col.length + _mochi_idx : _mochi_idx;})()]]);
    i = (i + 1);
  }
  return {data: newData, rows: m.rows, cols: (m.cols + 1)};
}
function matrix_mul_scalar(m: Matrix, s: number): Matrix {
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < m.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m.cols)) {
      row.push((m.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()] * s));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {data: vals, rows: m.rows, cols: m.cols};
}
function matrix_neg(m: Matrix): Matrix {
  return matrix_mul_scalar(m, -1.0);
}
function matrix_add(a: Matrix, b: Matrix): Matrix {
  if (((a.rows !== b.rows) || (a.cols !== b.cols))) {
    return {data: [], rows: 0, cols: 0};
  }
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < a.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < a.cols)) {
      row.push((a.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? a.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? a.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? a.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()] + b.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? b.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? b.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? b.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()]));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {data: vals, rows: a.rows, cols: a.cols};
}
function matrix_sub(a: Matrix, b: Matrix): Matrix {
  if (((a.rows !== b.rows) || (a.cols !== b.cols))) {
    return {data: [], rows: 0, cols: 0};
  }
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < a.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < a.cols)) {
      row.push((a.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? a.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? a.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? a.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()] - b.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? b.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? b.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? b.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()]));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {data: vals, rows: a.rows, cols: a.cols};
}
function matrix_dot(row: number[], col: number[]): number {
  let sum: number = 0.0;
  let i: number = 0;
  while ((i < _len(row))) {
    sum = (sum + (row[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? row.length + _mochi_idx : _mochi_idx;})()] * col[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? col.length + _mochi_idx : _mochi_idx;})()]));
    i = (i + 1);
  }
  return sum;
}
function matrix_mul(a: Matrix, b: Matrix): Matrix {
  if ((a.cols !== b.rows)) {
    return {data: [], rows: 0, cols: 0};
  }
  let bcols: number[][] = matrix_columns(b);
  let vals: number[][] = [];
  let i: number = 0;
  while ((i < a.rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < b.cols)) {
      row.push(matrix_dot(a.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? a.data.length + _mochi_idx : _mochi_idx;})()], bcols[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? bcols.length + _mochi_idx : _mochi_idx;})()]));
      j = (j + 1);
    }
    vals.push(row);
    i = (i + 1);
  }
  return {data: vals, rows: a.rows, cols: b.cols};
}
function matrix_pow(m: Matrix, p: number): Matrix {
  if ((p === 0)) {
    return matrix_identity(m);
  }
  if ((p < 0)) {
    if (matrix_is_invertible(m)) {
      return matrix_pow(matrix_inverse(m), -p);
    }
    return {data: [], rows: 0, cols: 0};
  }
  let result: Matrix = m;
  let i: number = 1;
  while ((i < p)) {
    result = matrix_mul(result, m);
    i = (i + 1);
  }
  return result;
}
function matrix_to_string(m: Matrix): string {
  if ((m.rows === 0)) {
    return "[]";
  }
  let s: string = "[";
  let i: number = 0;
  while ((i < m.rows)) {
    s = (s + "[");
    let j: number = 0;
    while ((j < m.cols)) {
      s = (s + _str(m.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? m.data[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? m.data.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()]));
      if ((j < (m.cols - 1))) {
        s = (s + " ");
      }
      j = (j + 1);
    }
    s = (s + "]");
    if ((i < (m.rows - 1))) {
      s = (s + "\n ");
    }
    i = (i + 1);
  }
  s = (s + "]");
  return s;
}
function main() {
  let m: Matrix = make_matrix([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]);
  console.log(_str(matrix_to_string(m)));
  console.log(_str(matrix_columns(m)));
  console.log(_str(((_str(m.rows) + ",") + _str(m.cols))));
  console.log(_str(matrix_is_invertible(m)));
  console.log(_str(matrix_to_string(matrix_identity(m))));
  console.log(_str(matrix_determinant(m)));
  console.log(_str(matrix_to_string(matrix_minors(m))));
  console.log(_str(matrix_to_string(matrix_cofactors(m))));
  console.log(_str(matrix_to_string(matrix_adjugate(m))));
  let m2: Matrix = matrix_mul_scalar(m, 3.0);
  console.log(_str(matrix_to_string(m2)));
  console.log(_str(matrix_to_string(matrix_add(m, m2))));
  console.log(_str(matrix_to_string(matrix_sub(m, m2))));
  console.log(_str(matrix_to_string(matrix_pow(m, 3))));
  let m3: Matrix = matrix_add_row(m, [10.0, 11.0, 12.0]);
  console.log(_str(matrix_to_string(m3)));
  let m4: Matrix = matrix_add_column(m2, [8.0, 16.0, 32.0]);
  console.log(_str(matrix_to_string(matrix_mul(m3, m4))));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  if (typeof performance !== 'undefined' && (performance as any).memory) {
    return (performance as any).memory.usedJSHeapSize;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  if (Array.isArray(x)) {
    return x.map(_str).join(',');
  }
  if (x && typeof x === 'object') {
    try { return JSON.stringify(x); } catch { return String(x); }
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log('\n' + JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

