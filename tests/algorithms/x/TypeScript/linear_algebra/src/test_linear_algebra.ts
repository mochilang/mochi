// Generated by Mochi v0.10.59 on 2025-08-07 00:03:57 GMT+7

function int_to_string(n: number): string {
  if ((n == 0)) {
    return "0";
  }
  let num: number = n;
  let neg: boolean = false;
  if ((num < 0)) {
    neg = true;
    num = -num;
  }
  let res: string = "";
  while ((num > 0)) {
    let digit = (num % 10);
    let ch = ("0123456789").substring(digit, (digit + 1));
    res = (ch + res);
    num = Math.trunc(num / 10);
  }
  if (neg) {
    res = ("-" + res);
  }
  return res;
}
function float_to_string(x: number, dec: number): string {
  let neg: boolean = false;
  let num: number = x;
  if ((num < 0.0)) {
    neg = true;
    num = -num;
  }
  let int_part: number = Math.trunc(num);
  let res: string = int_to_string(int_part);
  if ((dec > 0)) {
    res = (res + ".");
    let frac = (num - int_part);
    let i: number = 0;
    while ((i < dec)) {
      frac = (frac * 10.0);
      let digit: number = Math.trunc(frac);
      res = (res + ("0123456789").substring(digit, (digit + 1)));
      frac = (frac - digit);
      i = (i + 1);
    }
  }
  if (neg) {
    res = ("-" + res);
  }
  return res;
}
function vector_component(v: number[], i: number): number {
  return v[(i) < 0 ? v.length + (i) : i];
}
function vector_str_int(v: number[]): string {
  let s: string = "(";
  let i: number = 0;
  while ((i < _len(v))) {
    s = (s + int_to_string(v[(i) < 0 ? v.length + (i) : i]));
    if (((i + 1) < _len(v))) {
      s = (s + ",");
    }
    i = (i + 1);
  }
  s = (s + ")");
  return s;
}
function vector_str_float(v: number[], dec: number): string {
  let s: string = "(";
  let i: number = 0;
  while ((i < _len(v))) {
    s = (s + float_to_string(v[(i) < 0 ? v.length + (i) : i], dec));
    if (((i + 1) < _len(v))) {
      s = (s + ",");
    }
    i = (i + 1);
  }
  s = (s + ")");
  return s;
}
function vector_add(a: number[], b: number[]): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < _len(a))) {
    res.push((a[(i) < 0 ? a.length + (i) : i] + b[(i) < 0 ? b.length + (i) : i]));
    i = (i + 1);
  }
  return res;
}
function vector_sub(a: number[], b: number[]): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < _len(a))) {
    res.push((a[(i) < 0 ? a.length + (i) : i] - b[(i) < 0 ? b.length + (i) : i]));
    i = (i + 1);
  }
  return res;
}
function vector_scalar_mul(v: number[], s: number): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < _len(v))) {
    res.push((v[(i) < 0 ? v.length + (i) : i] * s));
    i = (i + 1);
  }
  return res;
}
function vector_dot(a: number[], b: number[]): number {
  let sum: number = 0;
  let i: number = 0;
  while ((i < _len(a))) {
    sum = (sum + (a[(i) < 0 ? a.length + (i) : i] * b[(i) < 0 ? b.length + (i) : i]));
    i = (i + 1);
  }
  return sum;
}
function sqrt_newton(x: number): number {
  if ((x == 0.0)) {
    return 0.0;
  }
  let low: number = 0.0;
  let high: number = x;
  if ((x < 1.0)) {
    high = 1.0;
  }
  let mid: number = 0.0;
  let i: number = 0;
  while ((i < 40)) {
    mid = ((low + high) / 2.0);
    if (((mid * mid) > x)) {
      high = mid;
    } else {
      low = mid;
    }
    i = (i + 1);
  }
  return mid;
}
function euclidean_length(v: number[]): number {
  let sum: number = 0.0;
  let i: number = 0;
  while ((i < _len(v))) {
    let val: number = v[(i) < 0 ? v.length + (i) : i];
    sum = (sum + (val * val));
    i = (i + 1);
  }
  return sqrt_newton(sum);
}
function zero_vector(n: number): number[] {
  let v: number[] = [];
  let i: number = 0;
  while ((i < n)) {
    v.push(0);
    i = (i + 1);
  }
  return v;
}
function unit_basis_vector(n: number, idx: number): number[] {
  let v: number[] = zero_vector(n);
  v[(idx) < 0 ? v.length + (idx) : idx] = 1;
  return v;
}
function axpy(a: number, x: number[], y: number[]): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < _len(x))) {
    res.push(((a * x[(i) < 0 ? x.length + (i) : i]) + y[(i) < 0 ? y.length + (i) : i]));
    i = (i + 1);
  }
  return res;
}
function copy_vector(x: number[]): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < _len(x))) {
    res.push(x[(i) < 0 ? x.length + (i) : i]);
    i = (i + 1);
  }
  return res;
}
function change_component(v: number[], idx: number, val: number) {
  v[(idx) < 0 ? v.length + (idx) : idx] = val;
}
function matrix_str(m: number[][]): string {
  let s: string = "";
  let i: number = 0;
  while ((i < _len(m))) {
    s = (s + "|");
    let j: number = 0;
    while ((j < _len(m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)]))) {
      s = (s + int_to_string(m[(i) < 0 ? m.length + (i) : i][(j) < 0 ? m[(i) < 0 ? m.length + (i) : i].length + (j) : j]));
      if (((j + 1) < _len(m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)]))) {
        s = (s + ",");
      }
      j = (j + 1);
    }
    s = (s + "|\n");
    i = (i + 1);
  }
  return s;
}
function submatrix(m: number[][], row: number, col: number): number[][] {
  let res: number[][] = [];
  let i: number = 0;
  while ((i < _len(m))) {
    if ((i != row)) {
      let r: number[] = [];
      let j: number = 0;
      while ((j < _len(m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)]))) {
        if ((j != col)) {
          r.push(m[(i) < 0 ? m.length + (i) : i][(j) < 0 ? m[(i) < 0 ? m.length + (i) : i].length + (j) : j]);
        }
        j = (j + 1);
      }
      res.push(r);
    }
    i = (i + 1);
  }
  return res;
}
function determinant(m: number[][]): number {
  let n: number = _len(m);
  if ((n == 1)) {
    return m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)][(Math.trunc(0)) < 0 ? m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)].length + (Math.trunc(0)) : Math.trunc(0)];
  }
  if ((n == 2)) {
    return ((m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)][(Math.trunc(0)) < 0 ? m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)].length + (Math.trunc(0)) : Math.trunc(0)] * m[(Math.trunc(1)) < 0 ? m.length + (Math.trunc(1)) : Math.trunc(1)][(Math.trunc(1)) < 0 ? m[(Math.trunc(1)) < 0 ? m.length + (Math.trunc(1)) : Math.trunc(1)].length + (Math.trunc(1)) : Math.trunc(1)]) - (m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)][(Math.trunc(1)) < 0 ? m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)].length + (Math.trunc(1)) : Math.trunc(1)] * m[(Math.trunc(1)) < 0 ? m.length + (Math.trunc(1)) : Math.trunc(1)][(Math.trunc(0)) < 0 ? m[(Math.trunc(1)) < 0 ? m.length + (Math.trunc(1)) : Math.trunc(1)].length + (Math.trunc(0)) : Math.trunc(0)]));
  }
  let det: number = 0;
  let c: number = 0;
  while ((c < n)) {
    let sub: number[][] = submatrix(m, 0, c);
    let sign: number = 1;
    if (((c % 2) == 1)) {
      sign = -1;
    }
    det = (det + ((sign * m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)][(c) < 0 ? m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)].length + (c) : c]) * determinant(sub)));
    c = (c + 1);
  }
  return det;
}
function matrix_minor(m: number[][], row: number, col: number): number {
  return determinant(submatrix(m, row, col));
}
function matrix_cofactor(m: number[][], row: number, col: number): number {
  let sign: number = 1;
  if ((((row + col) % 2) == 1)) {
    sign = -1;
  }
  return (sign * matrix_minor(m, row, col));
}
function matrix_mul_vector(m: number[][], v: number[]): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < _len(m))) {
    let sum: number = 0;
    let j: number = 0;
    while ((j < _len(m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)]))) {
      sum = (sum + (m[(i) < 0 ? m.length + (i) : i][(j) < 0 ? m[(i) < 0 ? m.length + (i) : i].length + (j) : j] * v[(j) < 0 ? v.length + (j) : j]));
      j = (j + 1);
    }
    res.push(sum);
    i = (i + 1);
  }
  return res;
}
function matrix_mul_scalar(m: number[][], s: number): number[][] {
  let res: number[][] = [];
  let i: number = 0;
  while ((i < _len(m))) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < _len(m[(Math.trunc(0)) < 0 ? m.length + (Math.trunc(0)) : Math.trunc(0)]))) {
      row.push((m[(i) < 0 ? m.length + (i) : i][(j) < 0 ? m[(i) < 0 ? m.length + (i) : i].length + (j) : j] * s));
      j = (j + 1);
    }
    res.push(row);
    i = (i + 1);
  }
  return res;
}
function matrix_change_component(m: number[][], i: number, j: number, val: number) {
  m[(i) < 0 ? m.length + (i) : i][(j) < 0 ? m[(i) < 0 ? m.length + (i) : i].length + (j) : j] = val;
}
function matrix_component(m: number[][], i: number, j: number): number {
  return m[(i) < 0 ? m.length + (i) : i][(j) < 0 ? m[(i) < 0 ? m.length + (i) : i].length + (j) : j];
}
function matrix_add(a: number[][], b: number[][]): number[][] {
  let res: number[][] = [];
  let i: number = 0;
  while ((i < _len(a))) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < _len(a[(Math.trunc(0)) < 0 ? a.length + (Math.trunc(0)) : Math.trunc(0)]))) {
      row.push((a[(i) < 0 ? a.length + (i) : i][(j) < 0 ? a[(i) < 0 ? a.length + (i) : i].length + (j) : j] + b[(i) < 0 ? b.length + (i) : i][(j) < 0 ? b[(i) < 0 ? b.length + (i) : i].length + (j) : j]));
      j = (j + 1);
    }
    res.push(row);
    i = (i + 1);
  }
  return res;
}
function matrix_sub(a: number[][], b: number[][]): number[][] {
  let res: number[][] = [];
  let i: number = 0;
  while ((i < _len(a))) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < _len(a[(Math.trunc(0)) < 0 ? a.length + (Math.trunc(0)) : Math.trunc(0)]))) {
      row.push((a[(i) < 0 ? a.length + (i) : i][(j) < 0 ? a[(i) < 0 ? a.length + (i) : i].length + (j) : j] - b[(i) < 0 ? b.length + (i) : i][(j) < 0 ? b[(i) < 0 ? b.length + (i) : i].length + (j) : j]));
      j = (j + 1);
    }
    res.push(row);
    i = (i + 1);
  }
  return res;
}
function square_zero_matrix(n: number): number[][] {
  let m: number[][] = [];
  let i: number = 0;
  while ((i < n)) {
    m.push(zero_vector(n));
    i = (i + 1);
  }
  return m;
}
function assert_int(name: string, actual: number, expected: number) {
  if ((actual == expected)) {
    console.log(_str((name + " ok")));
  } else {
    console.log(_str(((((name + " fail ") + int_to_string(actual)) + " != ") + int_to_string(expected))));
  }
}
function assert_str(name: string, actual: string, expected: string) {
  if ((actual == expected)) {
    console.log(_str((name + " ok")));
  } else {
    console.log(_str((name + " fail")));
    console.log(_str(actual));
    console.log(_str(expected));
  }
}
function assert_float(name: string, actual: number, expected: number, eps: number) {
  let diff: number = (actual - expected);
  if ((diff < 0.0)) {
    diff = -diff;
  }
  if ((diff <= eps)) {
    console.log(_str((name + " ok")));
  } else {
    console.log(_str((name + " fail")));
  }
}
let vx: number[] = [1, 2, 3];
let vs: number[] = [0, 0, 0, 0, 0, 1];
let vsize: number[] = [1, 2, 3, 4];
let va: number[] = [1, 2, 3];
let vb: number[] = [1, 1, 1];
let zcount: number = 0;
let zi: number = 0;
let vchange: number[] = [1, 0, 0];
let ma: number[][] = [[1, 2, 3], [2, 4, 5], [6, 7, 8]];
let mb: number[][] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
let mc: number[][] = [[1, 2, 3], [2, 4, 5], [6, 7, 8]];
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let vsum: number[]
let vsub: number[]
let vmul: number[]
let zvec: number[]
let zstr: string
let vcopy: number[]
let mv: number[]
let msc: number[][]
let madd: number[][]
let msub: number[][]
let mzero: number[][]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  assert_int("component0", vector_component(vx, 0), 1);
  assert_int("component2", vector_component(vx, 2), 3);
  assert_str("str_vector", vector_str_int(vs), "(0,0,0,0,0,1)");
  assert_int("size", _len(vsize), 4);
vsum = vector_add(va, vb)
  assert_int("add0", vector_component(vsum, 0), 2);
  assert_int("add1", vector_component(vsum, 1), 3);
  assert_int("add2", vector_component(vsum, 2), 4);
vsub = vector_sub(va, vb)
  assert_int("sub0", vector_component(vsub, 0), 0);
  assert_int("sub1", vector_component(vsub, 1), 1);
  assert_int("sub2", vector_component(vsub, 2), 2);
vmul = vector_scalar_mul(va, 3.0)
  assert_str("scalar_mul", vector_str_float(vmul, 1), "(3.0,6.0,9.0)");
  assert_int("dot_product", vector_dot([2, -1, 4], [1, -2, -1]), 0);
zvec = zero_vector(10)
zstr = vector_str_int(zvec)
  while ((zi < _len(zstr))) {
    if (((zstr).substring(zi, (zi + 1)) == "0")) {
      zcount = (zcount + 1);
    }
    zi = (zi + 1);
  }
  assert_int("zero_vector", zcount, 10);
  assert_str("unit_basis", vector_str_int(unit_basis_vector(3, 1)), "(0,1,0)");
  assert_str("axpy", vector_str_int(axpy(2, [1, 2, 3], [1, 0, 1])), "(3,4,7)");
vcopy = copy_vector([1, 0, 0, 0, 0, 0])
  assert_str("copy", vector_str_int(vcopy), "(1,0,0,0,0,0)");
  change_component(vchange, 0, 0);
  change_component(vchange, 1, 1);
  assert_str("change_component", vector_str_int(vchange), "(0,1,0)");
  assert_str("matrix_str", matrix_str(ma), "|1,2,3|\n|2,4,5|\n|6,7,8|\n");
  assert_int("determinant", determinant(ma), -5);
mv = matrix_mul_vector(mb, [1, 2, 3])
  assert_str("matrix_vec_mul", vector_str_int(mv), "(14,32,50)");
msc = matrix_mul_scalar(mb, 2)
  assert_str("matrix_scalar_mul", matrix_str(msc), "|2,4,6|\n|8,10,12|\n|14,16,18|\n");
  matrix_change_component(mc, 0, 2, 5);
  assert_str("change_component_matrix", matrix_str(mc), "|1,2,5|\n|2,4,5|\n|6,7,8|\n");
  assert_int("matrix_component", matrix_component(mc, 2, 1), 7);
madd = matrix_add([[1, 2, 3], [2, 4, 5], [6, 7, 8]], [[1, 2, 7], [2, 4, 5], [6, 7, 10]])
  assert_str("matrix_add", matrix_str(madd), "|2,4,10|\n|4,8,10|\n|12,14,18|\n");
msub = matrix_sub([[1, 2, 3], [2, 4, 5], [6, 7, 8]], [[1, 2, 7], [2, 4, 5], [6, 7, 10]])
  assert_str("matrix_sub", matrix_str(msub), "|0,0,-4|\n|0,0,0|\n|0,0,-2|\n");
mzero = square_zero_matrix(5)
  assert_str("square_zero_matrix", matrix_str(mzero), "|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n|0,0,0,0,0|\n");
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

