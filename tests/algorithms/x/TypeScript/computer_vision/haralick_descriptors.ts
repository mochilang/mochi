// Generated by Mochi v0.10.59 on 2025-08-06 20:30:11 GMT+7

function abs_int(n: number): number {
  if ((n < 0)) {
    return -n;
  }
  return n;
}
function sqrt(x: number): number {
  if ((x <= 0.0)) {
    return 0.0;
  }
  let guess: number = x;
  let i: number = 0;
  while ((i < 10)) {
    guess = ((guess + (x / guess)) / 2.0);
    i = (i + 1);
  }
  return guess;
}
function ln(x: number): number {
  if ((x <= 0.0)) {
    return 0.0;
  }
  let e: number = 2.718281828;
  let n: number = 0;
  let y: number = x;
  while ((y >= e)) {
    y = (y / e);
    n = (n + 1);
  }
  while ((y <= (1.0 / e))) {
    y = (y * e);
    n = (n - 1);
  }
  y = (y - 1.0);
  let term: number = y;
  let result: number = 0.0;
  let k: number = 1;
  while ((k <= 20)) {
    if (((k % 2) == 1)) {
      result = (result + (term / (1.0 * k)));
    } else {
      result = (result - (term / (1.0 * k)));
    }
    term = (term * y);
    k = (k + 1);
  }
  return (result + (1.0 * n));
}
function matrix_concurrency(image: number[][], coord: number[]): number[][] {
  let offset_x: number = coord[Math.trunc(0)];
  let offset_y: number = coord[Math.trunc(1)];
  let max_val: number = 0;
  for (let r = 0; r < _len(image); r++) {
    for (let c = 0; c < _len(image[r]); c++) {
      if ((image[r][c] > max_val)) {
        max_val = image[r][c];
      }
    }
  }
  let size: number = (max_val + 1);
  let matrix: number[][] = [];
  for (let i = 0; i < size; i++) {
    let row: number[] = [];
    for (let j = 0; j < size; j++) {
      row.push(0.0);
    }
    matrix.push(row);
  }
  for (let x = 1; x < (_len(image) - 1); x++) {
    for (let y = 1; y < (_len(image[x]) - 1); y++) {
      let base: number = image[x][y];
      let offset: number = image[Math.trunc((x + offset_x))][Math.trunc((y + offset_y))];
      matrix[base][offset] = (matrix[base][offset] + 1.0);
    }
  }
  let total: number = 0.0;
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      total = (total + matrix[i][j]);
    }
  }
  if ((total == 0.0)) {
    return matrix;
  }
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      matrix[i][j] = (matrix[i][j] / total);
    }
  }
  return matrix;
}
function haralick_descriptors(matrix: number[][]): number[] {
  let rows: number = _len(matrix);
  let cols: number = _len(matrix[Math.trunc(0)]);
  let maximum_prob: number = 0.0;
  let correlation: number = 0.0;
  let energy: number = 0.0;
  let contrast: number = 0.0;
  let dissimilarity: number = 0.0;
  let inverse_difference: number = 0.0;
  let homogeneity: number = 0.0;
  let entropy: number = 0.0;
  let i: number = 0;
  while ((i < rows)) {
    let j: number = 0;
    while ((j < cols)) {
      let val: number = matrix[i][j];
      if ((val > maximum_prob)) {
        maximum_prob = val;
      }
      correlation = (correlation + (((1.0 * i) * j) * val));
      energy = (energy + (val * val));
      let diff: number = (i - j);
      let adiff: number = abs_int(diff);
      contrast = (contrast + (val * ((1.0 * diff) * diff)));
      dissimilarity = (dissimilarity + (val * (1.0 * adiff)));
      inverse_difference = (inverse_difference + (val / (1.0 + (1.0 * adiff))));
      homogeneity = (homogeneity + (val / (1.0 + ((1.0 * diff) * diff))));
      if ((val > 0.0)) {
        entropy = (entropy - (val * ln(val)));
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
  return [maximum_prob, correlation, energy, contrast, dissimilarity, inverse_difference, homogeneity, entropy];
}
let image: number[][] = [[0, 1, 0], [1, 0, 1], [0, 1, 0]];
let idx: number = 0;
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let glcm: number[][]
let descriptors: number[]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
glcm = matrix_concurrency(image, [0, 1])
descriptors = haralick_descriptors(glcm)
  while ((idx < _len(descriptors))) {
    console.log(_str(_str(descriptors[idx])));
    idx = (idx + 1);
  }
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

