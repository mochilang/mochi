// Generated by Mochi v0.10.59 on 2025-08-06 20:40:03 GMT+7

function absf(x: number): number {
  if ((x < 0.0)) {
    return -x;
  }
  return x;
}
function fmod(a: number, b: number): number {
  return (a - (b * Math.trunc((a / b))));
}
function roundf(x: number): number {
  if ((x >= 0.0)) {
    return Math.trunc((x + 0.5));
  }
  return Math.trunc((x - 0.5));
}
function maxf(a: number, b: number, c: number): number {
  let m: number = a;
  if ((b > m)) {
    m = b;
  }
  if ((c > m)) {
    m = c;
  }
  return m;
}
function minf(a: number, b: number, c: number): number {
  let m: number = a;
  if ((b < m)) {
    m = b;
  }
  if ((c < m)) {
    m = c;
  }
  return m;
}
function hsv_to_rgb(hue: number, saturation: number, value: number): number[] {
  if (((hue < 0.0) || (hue > 360.0))) {
    console.log(_str("hue should be between 0 and 360"));
    return [];
  }
  if (((saturation < 0.0) || (saturation > 1.0))) {
    console.log(_str("saturation should be between 0 and 1"));
    return [];
  }
  if (((value < 0.0) || (value > 1.0))) {
    console.log(_str("value should be between 0 and 1"));
    return [];
  }
  let chroma: number = (value * saturation);
  let hue_section: number = (hue / 60.0);
  let second_largest_component: number = (chroma * (1.0 - absf((fmod(hue_section, 2.0) - 1.0))));
  let match_value: number = (value - chroma);
  let red: number = 0;
  let green: number = 0;
  let blue: number = 0;
  if (((hue_section >= 0.0) && (hue_section <= 1.0))) {
    red = roundf((255.0 * (chroma + match_value)));
    green = roundf((255.0 * (second_largest_component + match_value)));
    blue = roundf((255.0 * match_value));
  } else {
    if (((hue_section > 1.0) && (hue_section <= 2.0))) {
      red = roundf((255.0 * (second_largest_component + match_value)));
      green = roundf((255.0 * (chroma + match_value)));
      blue = roundf((255.0 * match_value));
    } else {
      if (((hue_section > 2.0) && (hue_section <= 3.0))) {
        red = roundf((255.0 * match_value));
        green = roundf((255.0 * (chroma + match_value)));
        blue = roundf((255.0 * (second_largest_component + match_value)));
      } else {
        if (((hue_section > 3.0) && (hue_section <= 4.0))) {
          red = roundf((255.0 * match_value));
          green = roundf((255.0 * (second_largest_component + match_value)));
          blue = roundf((255.0 * (chroma + match_value)));
        } else {
          if (((hue_section > 4.0) && (hue_section <= 5.0))) {
            red = roundf((255.0 * (second_largest_component + match_value)));
            green = roundf((255.0 * match_value));
            blue = roundf((255.0 * (chroma + match_value)));
          } else {
            red = roundf((255.0 * (chroma + match_value)));
            green = roundf((255.0 * match_value));
            blue = roundf((255.0 * (second_largest_component + match_value)));
          }
        }
      }
    }
  }
  return [red, green, blue];
}
function rgb_to_hsv(red: number, green: number, blue: number): number[] {
  if (((red < 0) || (red > 255))) {
    console.log(_str("red should be between 0 and 255"));
    return [];
  }
  if (((green < 0) || (green > 255))) {
    console.log(_str("green should be between 0 and 255"));
    return [];
  }
  if (((blue < 0) || (blue > 255))) {
    console.log(_str("blue should be between 0 and 255"));
    return [];
  }
  let float_red: number = (red / 255.0);
  let float_green: number = (green / 255.0);
  let float_blue: number = (blue / 255.0);
  let value: number = maxf(float_red, float_green, float_blue);
  let min_val: number = minf(float_red, float_green, float_blue);
  let chroma: number = (value - min_val);
  let saturation: number = ((value == 0.0) ? 0.0 : (chroma / value));
  let hue: number = 0;
  if ((chroma == 0.0)) {
    hue = 0.0;
  } else {
    if ((value == float_red)) {
      hue = (60.0 * (0.0 + ((float_green - float_blue) / chroma)));
    } else {
      if ((value == float_green)) {
        hue = (60.0 * (2.0 + ((float_blue - float_red) / chroma)));
      } else {
        hue = (60.0 * (4.0 + ((float_red - float_green) / chroma)));
      }
    }
  }
  hue = fmod((hue + 360.0), 360.0);
  return [hue, saturation, value];
}
function approximately_equal_hsv(hsv1: number[], hsv2: number[]): boolean {
  let check_hue: boolean = (absf((hsv1[Math.trunc(0)] - hsv2[Math.trunc(0)])) < 0.2);
  let check_saturation: boolean = (absf((hsv1[Math.trunc(1)] - hsv2[Math.trunc(1)])) < 0.002);
  let check_value: boolean = (absf((hsv1[Math.trunc(2)] - hsv2[Math.trunc(2)])) < 0.002);
  return ((check_hue && check_saturation) && check_value);
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let rgb: number[]
let hsv: number[]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
rgb = hsv_to_rgb(180.0, 0.5, 0.5)
  console.log(_str(_str(rgb)));
hsv = rgb_to_hsv(64, 128, 128)
  console.log(_str(_str(hsv)));
  console.log(_str(_str(approximately_equal_hsv(hsv, [180.0, 0.5, 0.5]))));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

