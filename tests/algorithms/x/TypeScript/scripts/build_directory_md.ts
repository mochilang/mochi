// Generated by Mochi v0.10.59 on 2025-08-07 08:54:47 GMT+7

function split(s: string, sep: string): string[] {
  let parts: string[] = [];
  let cur: string = "";
  let i: number = 0;
  while ((i < _len(s))) {
    if ((((_len(sep) > 0) && ((i + _len(sep)) <= _len(s))) && ((s).substring(i, (i + _len(sep))) == sep))) {
      parts.push(cur);
      cur = "";
      i = (i + _len(sep));
    } else {
      cur = (cur + (s).substring(i, (i + 1)));
      i = (i + 1);
    }
  }
  parts.push(cur);
  return parts;
}
function join(xs: string[], sep: string): string {
  let res: string = "";
  let i: number = 0;
  while ((i < _len(xs))) {
    if ((i > 0)) {
      res = (res + sep);
    }
    res = (res + xs[(i) < 0 ? xs.length + (i) : i]);
    i = (i + 1);
  }
  return res;
}
function repeat(s: string, n: number): string {
  let out: string = "";
  let i: number = 0;
  while ((i < n)) {
    out = (out + s);
    i = (i + 1);
  }
  return out;
}
function replace_char(s: string, old: string, _new: string): string {
  let out: string = "";
  let i: number = 0;
  while ((i < _len(s))) {
    let c: string = (s).substring(i, (i + 1));
    if ((c == old)) {
      out = (out + _new);
    } else {
      out = (out + c);
    }
    i = (i + 1);
  }
  return out;
}
function contains(s: string, sub: string): boolean {
  if ((_len(sub) == 0)) {
    return true;
  }
  let i: number = 0;
  while (((i + _len(sub)) <= _len(s))) {
    if (((s).substring(i, (i + _len(sub))) == sub)) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function file_extension(name: string): string {
  let i: number = (_len(name) - 1);
  while ((i >= 0)) {
    if (((name).substring(i, (i + 1)) == ".")) {
      return name.slice(i);
    }
    i = (i - 1);
  }
  return "";
}
function remove_extension(name: string): string {
  let i: number = (_len(name) - 1);
  while ((i >= 0)) {
    if (((name).substring(i, (i + 1)) == ".")) {
      return name.slice(0, i);
    }
    i = (i - 1);
  }
  return name;
}
function title_case(s: string): string {
  let out: string = "";
  let cap: boolean = true;
  let i: number = 0;
  while ((i < _len(s))) {
    let c: string = (s).substring(i, (i + 1));
    if ((c == " ")) {
      out = (out + c);
      cap = true;
    } else {
      if (cap) {
        out = (out + c.toUpperCase());
        cap = false;
      } else {
        out = (out + c.toLowerCase());
      }
    }
    i = (i + 1);
  }
  return out;
}
function count_char(s: string, ch: string): number {
  let cnt: number = 0;
  let i: number = 0;
  while ((i < _len(s))) {
    if (((s).substring(i, (i + 1)) == ch)) {
      cnt = (cnt + 1);
    }
    i = (i + 1);
  }
  return cnt;
}
function md_prefix(level: number): string {
  if ((level == 0)) {
    return "\n##";
  }
  return (repeat("  ", level) + "*");
}
function print_path(old_path: string, new_path: string): string {
  let old_parts: string[] = old_path.split("/");
  let new_parts: string[] = new_path.split("/");
  let i: number = 0;
  while ((i < _len(new_parts))) {
    if ((((i >= _len(old_parts)) || (old_parts[(i) < 0 ? old_parts.length + (i) : i] != new_parts[(i) < 0 ? new_parts.length + (i) : i])) && (new_parts[(i) < 0 ? new_parts.length + (i) : i] != ""))) {
      let title: string = title_case(replace_char(new_parts[(i) < 0 ? new_parts.length + (i) : i], "_", " "));
      console.log(_str(((md_prefix(i) + " ") + title)));
    }
    i = (i + 1);
  }
  return new_path;
}
function sort_strings(xs: string[]): string[] {
  let arr: string[] = xs;
  let i: number = 0;
  while ((i < _len(arr))) {
    let min_idx: number = i;
    let j: number = (i + 1);
    while ((j < _len(arr))) {
      if ((arr[(j) < 0 ? arr.length + (j) : j] < arr[(min_idx) < 0 ? arr.length + (min_idx) : min_idx])) {
        min_idx = j;
      }
      j = (j + 1);
    }
    let tmp: string = arr[(i) < 0 ? arr.length + (i) : i];
    arr[(i) < 0 ? arr.length + (i) : i] = arr[(min_idx) < 0 ? arr.length + (min_idx) : min_idx];
    arr[(min_idx) < 0 ? arr.length + (min_idx) : min_idx] = tmp;
    i = (i + 1);
  }
  return arr;
}
function good_file_paths(paths: string[]): string[] {
  let res: string[] = [];
  for (const p of paths) {
    let parts: string[] = p.split("/");
    let skip: boolean = false;
    let k: number = 0;
    while ((k < (_len(parts) - 1))) {
      let part: string = parts[(k) < 0 ? parts.length + (k) : k];
      if (((((part == "scripts") || (part.slice(0, 1) == ".")) || (part.slice(0, 1) == "_")) || contains(part, "venv"))) {
        skip = true;
      }
      k = (k + 1);
    }
    if (skip) {
      continue
    }
    let filename: string = parts[(Math.trunc((_len(parts) - 1))) < 0 ? parts.length + (Math.trunc((_len(parts) - 1))) : Math.trunc((_len(parts) - 1))];
    if ((filename == "__init__.py")) {
      continue
    }
    let ext: string = file_extension(filename);
    if (((ext == ".py") || (ext == ".ipynb"))) {
      res.push(p);
    }
  }
  return res;
}
function print_directory_md(paths: string[]) {
  let files: string[] = sort_strings(good_file_paths(paths));
  let old_path: string = "";
  let i: number = 0;
  while ((i < _len(files))) {
    let fp: string = files[(i) < 0 ? files.length + (i) : i];
    let parts: string[] = fp.split("/");
    let filename: string = parts[(Math.trunc((_len(parts) - 1))) < 0 ? parts.length + (Math.trunc((_len(parts) - 1))) : Math.trunc((_len(parts) - 1))];
    let filepath: string = "";
    if ((_len(parts) > 1)) {
      filepath = join(parts.slice(0, (_len(parts) - 1)), "/");
    }
    if ((filepath != old_path)) {
      old_path = print_path(old_path, filepath);
    }
    let indent: number = 0;
    if ((_len(filepath) > 0)) {
      indent = (count_char(filepath, "/") + 1);
    }
    let url: string = replace_char(fp, " ", "%20");
    let name: string = title_case(replace_char(remove_extension(filename), "_", " "));
    console.log(_str((((((md_prefix(indent) + " [") + name) + "](") + url) + ")")));
    i = (i + 1);
  }
}
let sample: string[] = ["data_structures/linked_list.py", "data_structures/binary_tree.py", "math/number_theory/prime_check.py", "math/number_theory/greatest_common_divisor.ipynb"];
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  print_directory_md(sample);
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

