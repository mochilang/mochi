// Generated by Mochi v0.10.59 on 2025-08-07 00:16:27 GMT+7

function expApprox(x: number): number {
  if ((x < 0.0)) {
    return (1.0 / expApprox(-x));
  }
  if ((x > 1.0)) {
    let half: number = expApprox((x / 2.0));
    return (half * half);
  }
  let sum: number = 1.0;
  let term: number = 1.0;
  let n: number = 1;
  while ((n < 20)) {
    term = ((term * x) / n);
    sum = (sum + term);
    n = (n + 1);
  }
  return sum;
}
function transpose(mat: number[][]): number[][] {
  let rows: number = _len(mat);
  let cols: number = _len(mat[(Math.trunc(0)) < 0 ? mat.length + (Math.trunc(0)) : Math.trunc(0)]);
  let res: number[][] = [];
  let i: number = 0;
  while ((i < cols)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < rows)) {
      row.push(mat[(j) < 0 ? mat.length + (j) : j][(i) < 0 ? mat[(j) < 0 ? mat.length + (j) : j].length + (i) : i]);
      j = (j + 1);
    }
    res.push(row);
    i = (i + 1);
  }
  return res;
}
function matMul(a: number[][], b: number[][]): number[][] {
  let a_rows: number = _len(a);
  let a_cols: number = _len(a[(Math.trunc(0)) < 0 ? a.length + (Math.trunc(0)) : Math.trunc(0)]);
  let b_cols: number = _len(b[(Math.trunc(0)) < 0 ? b.length + (Math.trunc(0)) : Math.trunc(0)]);
  let res: number[][] = [];
  let i: number = 0;
  while ((i < a_rows)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < b_cols)) {
      let sum: number = 0.0;
      let k: number = 0;
      while ((k < a_cols)) {
        sum = (sum + (a[(i) < 0 ? a.length + (i) : i][(k) < 0 ? a[(i) < 0 ? a.length + (i) : i].length + (k) : k] * b[(k) < 0 ? b.length + (k) : k][(j) < 0 ? b[(k) < 0 ? b.length + (k) : k].length + (j) : j]));
        k = (k + 1);
      }
      row.push(sum);
      j = (j + 1);
    }
    res.push(row);
    i = (i + 1);
  }
  return res;
}
function matInv(mat: number[][]): number[][] {
  let n: number = _len(mat);
  let aug: number[][] = [];
  let i: number = 0;
  while ((i < n)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < n)) {
      row.push(mat[(i) < 0 ? mat.length + (i) : i][(j) < 0 ? mat[(i) < 0 ? mat.length + (i) : i].length + (j) : j]);
      j = (j + 1);
    }
    j = 0;
    while ((j < n)) {
      if ((i == j)) {
        row.push(1.0);
      } else {
        row.push(0.0);
      }
      j = (j + 1);
    }
    aug.push(row);
    i = (i + 1);
  }
  let col: number = 0;
  while ((col < n)) {
    let pivot: number = aug[(col) < 0 ? aug.length + (col) : col][(col) < 0 ? aug[(col) < 0 ? aug.length + (col) : col].length + (col) : col];
    if ((pivot == 0.0)) {
      _panic("Matrix is singular");
    }
    let j: number = 0;
    while ((j < (2 * n))) {
      aug[(col) < 0 ? aug.length + (col) : col][(j) < 0 ? aug[(col) < 0 ? aug.length + (col) : col].length + (j) : j] = (aug[(col) < 0 ? aug.length + (col) : col][(j) < 0 ? aug[(col) < 0 ? aug.length + (col) : col].length + (j) : j] / pivot);
      j = (j + 1);
    }
    let r: number = 0;
    while ((r < n)) {
      if ((r != col)) {
        let factor: number = aug[(r) < 0 ? aug.length + (r) : r][(col) < 0 ? aug[(r) < 0 ? aug.length + (r) : r].length + (col) : col];
        j = 0;
        while ((j < (2 * n))) {
          aug[(r) < 0 ? aug.length + (r) : r][(j) < 0 ? aug[(r) < 0 ? aug.length + (r) : r].length + (j) : j] = (aug[(r) < 0 ? aug.length + (r) : r][(j) < 0 ? aug[(r) < 0 ? aug.length + (r) : r].length + (j) : j] - (factor * aug[(col) < 0 ? aug.length + (col) : col][(j) < 0 ? aug[(col) < 0 ? aug.length + (col) : col].length + (j) : j]));
          j = (j + 1);
        }
      }
      r = (r + 1);
    }
    col = (col + 1);
  }
  let inv: number[][] = [];
  i = 0;
  while ((i < n)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < n)) {
      row.push(aug[(i) < 0 ? aug.length + (i) : i][(Math.trunc((j + n))) < 0 ? aug[(i) < 0 ? aug.length + (i) : i].length + (Math.trunc((j + n))) : Math.trunc((j + n))]);
      j = (j + 1);
    }
    inv.push(row);
    i = (i + 1);
  }
  return inv;
}
function weight_matrix(point: number[], x_train: number[][], tau: number): number[][] {
  let m: number = _len(x_train);
  let weights: number[][] = [];
  let i: number = 0;
  while ((i < m)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < m)) {
      if ((i == j)) {
        row.push(1.0);
      } else {
        row.push(0.0);
      }
      j = (j + 1);
    }
    weights.push(row);
    i = (i + 1);
  }
  let j: number = 0;
  while ((j < m)) {
    let diff_sq: number = 0.0;
    let k: number = 0;
    while ((k < _len(point))) {
      let diff: number = (point[(k) < 0 ? point.length + (k) : k] - x_train[(j) < 0 ? x_train.length + (j) : j][(k) < 0 ? x_train[(j) < 0 ? x_train.length + (j) : j].length + (k) : k]);
      diff_sq = (diff_sq + (diff * diff));
      k = (k + 1);
    }
    weights[(j) < 0 ? weights.length + (j) : j][(j) < 0 ? weights[(j) < 0 ? weights.length + (j) : j].length + (j) : j] = expApprox((-diff_sq / ((2.0 * tau) * tau)));
    j = (j + 1);
  }
  return weights;
}
function local_weight(point: number[], x_train: number[][], y_train: number[], tau: number): number[][] {
  let w: number[][] = weight_matrix(point, x_train, tau);
  let x_t: number[][] = transpose(x_train);
  let x_t_w: number[][] = matMul(x_t, w);
  let x_t_w_x: number[][] = matMul(x_t_w, x_train);
  let inv_part: number[][] = matInv(x_t_w_x);
  let y_col: number[][] = [];
  let i: number = 0;
  while ((i < _len(y_train))) {
    y_col.push([y_train[(i) < 0 ? y_train.length + (i) : i]]);
    i = (i + 1);
  }
  let x_t_w_y: number[][] = matMul(x_t_w, y_col);
  return matMul(inv_part, x_t_w_y);
}
function local_weight_regression(x_train: number[][], y_train: number[], tau: number): number[] {
  let m: number = _len(x_train);
  let preds: number[] = [];
  let i: number = 0;
  while ((i < m)) {
    let theta: number[][] = local_weight(x_train[(i) < 0 ? x_train.length + (i) : i], x_train, y_train, tau);
    let weights_vec: number[] = [];
    let k: number = 0;
    while ((k < _len(theta))) {
      weights_vec.push(theta[(k) < 0 ? theta.length + (k) : k][(Math.trunc(0)) < 0 ? theta[(k) < 0 ? theta.length + (k) : k].length + (Math.trunc(0)) : Math.trunc(0)]);
      k = (k + 1);
    }
    let pred: number = 0.0;
    let j: number = 0;
    while ((j < _len(x_train[(i) < 0 ? x_train.length + (i) : i]))) {
      pred = (pred + (x_train[(i) < 0 ? x_train.length + (i) : i][(j) < 0 ? x_train[(i) < 0 ? x_train.length + (i) : i].length + (j) : j] * weights_vec[(j) < 0 ? weights_vec.length + (j) : j]));
      j = (j + 1);
    }
    preds.push(pred);
    i = (i + 1);
  }
  return preds;
}
let x_train: number[][] = [[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]];
let y_train: number[] = [1.01, 1.66, 3.5];
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _panic(msg: any): never { throw new Error(String(msg)); }
let preds: number[]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
preds = local_weight_regression(x_train, y_train, 0.6)
  console.log(JSON.stringify(preds, null, 2));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

