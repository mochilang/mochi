// Generated by Mochi v0.10.65 on 2025-08-14 17:21:21 GMT+7

function make_node(name, count, parent) {
  return {name, count, parent, children: {}, node_link: null};
}
function update_header(node_to_test, target_node) {
  let current = node_to_test;
  while ((current.node_link !== null)) {
    current = current.node_link;
  }
  current.node_link = target_node;
}
function update_tree(items, in_tree, header_table, count) {
  let first = items[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? items.length + _mochi_idx : _mochi_idx;})()];
  let children = in_tree.children;
  if ((Array.isArray(children) ? children.includes(first) : (first in children))) {
    let child = children[first];
    child.count = (child.count + count);
    children[(()=>{const _mochi_idx = first; return _mochi_idx < 0 ? children.length + _mochi_idx : _mochi_idx;})()] = child;
    in_tree.children = children;
  } else {
    let new_node = make_node(first, count, in_tree);
    children[(()=>{const _mochi_idx = first; return _mochi_idx < 0 ? children.length + _mochi_idx : _mochi_idx;})()] = new_node;
    in_tree.children = children;
    let entry = header_table[first];
    if ((entry.node === null)) {
      entry.node = new_node;
    } else {
      update_header(entry.node, new_node);
    }
    header_table[(()=>{const _mochi_idx = first; return _mochi_idx < 0 ? header_table.length + _mochi_idx : _mochi_idx;})()] = entry;
  }
  if ((_len(items) > 1)) {
    let rest = items.slice(1, _len(items));
    update_tree(rest, children[first], header_table, count);
  }
}
function sort_items(items, header_table) {
  let arr = items;
  let i: number = 0;
  while ((i < _len(arr))) {
    let j: number = (i + 1);
    while ((j < _len(arr))) {
      if ((header_table[arr[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()]].count < header_table[arr[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()]].count)) {
        let tmp = arr[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()];
        arr[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()] = arr[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()];
        arr[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()] = tmp;
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
  return arr;
}
function create_tree(data_set, min_sup) {
  let counts: Record<any, any> = {};
  let i: number = 0;
  while ((i < _len(data_set))) {
    let trans = data_set[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? data_set.length + _mochi_idx : _mochi_idx;})()];
    let j: number = 0;
    while ((j < _len(trans))) {
      let item = trans[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? trans.length + _mochi_idx : _mochi_idx;})()];
      if ((item in counts)) {
        counts[(()=>{const _mochi_idx = item; return _mochi_idx < 0 ? counts.length + _mochi_idx : _mochi_idx;})()] = (counts[item] + 1);
      } else {
        counts[(()=>{const _mochi_idx = item; return _mochi_idx < 0 ? counts.length + _mochi_idx : _mochi_idx;})()] = 1;
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
  let header_table: Record<any, any> = {};
  for (const k in counts) {
    let cnt = counts[k];
    if ((cnt >= min_sup)) {
      header_table[(()=>{const _mochi_idx = k; return _mochi_idx < 0 ? header_table.length + _mochi_idx : _mochi_idx;})()] = {count: cnt, node: null};
    }
  }
  let freq_items: any[] = [];
  for (const k in header_table) {
    freq_items.push(k);
  }
  if ((_len(freq_items) === 0)) {
    return {tree: make_node("Null Set", 1, null), header: {}};
  }
  let fp_tree = make_node("Null Set", 1, null);
  i = 0;
  while ((i < _len(data_set))) {
    let tran = data_set[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? data_set.length + _mochi_idx : _mochi_idx;})()];
    let local_items: any[] = [];
    let j: number = 0;
    while ((j < _len(tran))) {
      let item = tran[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? tran.length + _mochi_idx : _mochi_idx;})()];
      if ((item in header_table)) {
        local_items.push(item);
      }
      j = (j + 1);
    }
    if ((_len(local_items) > 0)) {
      local_items = sort_items(local_items, header_table);
      update_tree(local_items, fp_tree, header_table, 1);
    }
    i = (i + 1);
  }
  return {tree: fp_tree, header: header_table};
}
function ascend_tree(leaf_node, path) {
  let prefix = path;
  if ((leaf_node.parent !== null)) {
    prefix.push(leaf_node.name);
    prefix = ascend_tree(leaf_node.parent, prefix);
  } else {
    prefix.push(leaf_node.name);
  }
  return prefix;
}
function find_prefix_path(base_pat, tree_node) {
  let cond_pats: any[] = [];
  let node = tree_node;
  while ((node !== null)) {
    let prefix = ascend_tree(node, []);
    if ((_len(prefix) > 1)) {
      let items = prefix.slice(1, _len(prefix));
      cond_pats.push({items, count: node.count});
    }
    node = node.node_link;
  }
  return cond_pats;
}
function mine_tree(in_tree, header_table, min_sup, pre_fix, freq_item_list) {
  let freq_list = freq_item_list;
  let items: any[] = [];
  for (const k of header_table) {
    items.push(k);
  }
  let sorted_items: any[] = items;
  let i: number = 0;
  while ((i < _len(sorted_items))) {
    let j: number = (i + 1);
    while ((j < _len(sorted_items))) {
      if ((header_table[sorted_items[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? sorted_items.length + _mochi_idx : _mochi_idx;})()]].count > header_table[sorted_items[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? sorted_items.length + _mochi_idx : _mochi_idx;})()]].count)) {
        let tmp = sorted_items[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? sorted_items.length + _mochi_idx : _mochi_idx;})()];
        sorted_items[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? sorted_items.length + _mochi_idx : _mochi_idx;})()] = sorted_items[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? sorted_items.length + _mochi_idx : _mochi_idx;})()];
        sorted_items[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? sorted_items.length + _mochi_idx : _mochi_idx;})()] = tmp;
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
  let idx: number = 0;
  while ((idx < _len(sorted_items))) {
    let base_pat = sorted_items[(()=>{const _mochi_idx = idx; return _mochi_idx < 0 ? sorted_items.length + _mochi_idx : _mochi_idx;})()];
    let new_freq = pre_fix;
    new_freq.push(base_pat);
    freq_list.push(new_freq);
    let cond_pats = find_prefix_path(base_pat, header_table[base_pat].node);
    let cond_dataset: any[] = [];
    let p: number = 0;
    while ((p < _len(cond_pats))) {
      let pat = cond_pats[(()=>{const _mochi_idx = p; return _mochi_idx < 0 ? cond_pats.length + _mochi_idx : _mochi_idx;})()];
      let r: number = 0;
      while ((r < pat.count)) {
        cond_dataset.push(pat.items);
        r = (r + 1);
      }
      p = (p + 1);
    }
    let res2 = create_tree(cond_dataset, min_sup);
    let my_tree = res2.tree;
    let my_head = res2.header;
    if ((_len(my_head) > 0)) {
      freq_list = mine_tree(my_tree, my_head, min_sup, new_freq, freq_list);
    }
    idx = (idx + 1);
  }
  return freq_list;
}
function list_to_string(xs) {
  let s: string = "[";
  let i: number = 0;
  while ((i < _len(xs))) {
    s = (s + xs[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? xs.length + _mochi_idx : _mochi_idx;})()]);
    if ((i < (_len(xs) - 1))) {
      s = (s + ", ");
    }
    i = (i + 1);
  }
  return (s + "]");
}
function main() {
  let data_set: string[][] = [["bread", "milk", "cheese"], ["bread", "milk"], ["bread", "diapers"], ["bread", "milk", "diapers"], ["milk", "diapers"], ["milk", "cheese"], ["diapers", "cheese"], ["bread", "milk", "cheese", "diapers"]];
  let res = create_tree(data_set, 3);
  let fp_tree = res.tree;
  let header_table = res.header;
  let freq_items: any[] = [];
  freq_items = mine_tree(fp_tree, header_table, 3, [], freq_items);
  console.log(_str(_len(data_set)));
  console.log(_str(_len(header_table)));
  let i: number = 0;
  while ((i < _len(freq_items))) {
    console.log(_str(list_to_string(freq_items[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? freq_items.length + _mochi_idx : _mochi_idx;})()])));
    i = (i + 1);
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  if (typeof performance !== 'undefined' && (performance as any).memory) {
    return (performance as any).memory.usedJSHeapSize;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

