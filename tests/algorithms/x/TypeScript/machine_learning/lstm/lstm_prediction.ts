// Generated by Mochi v0.10.59 on 2025-08-07 00:16:30 GMT+7

export interface LSTMWeights { w_i: number; u_i: number; b_i: number; w_f: number; u_f: number; b_f: number; w_o: number; u_o: number; b_o: number; w_c: number; u_c: number; b_c: number; w_y: number; b_y: number }
export interface LSTMState { i: number[]; f: number[]; o: number[]; g: number[]; c: number[]; h: number[] }
export interface Samples { x: number[][]; y: number[] }
function exp_approx(x: number): number {
  let sum: number = 1.0;
  let term: number = 1.0;
  let n: number = 1;
  while ((n < 20)) {
    term = ((term * x) / n);
    sum = (sum + term);
    n = (n + 1);
  }
  return sum;
}
function sigmoid(x: number): number {
  return (1.0 / (1.0 + exp_approx(-x)));
}
function tanh_approx(x: number): number {
  let e: number = exp_approx((2.0 * x));
  return ((e - 1.0) / (e + 1.0));
}
function forward(seq: number[], w: LSTMWeights): LSTMState {
  let i_arr: number[] = [];
  let f_arr: number[] = [];
  let o_arr: number[] = [];
  let g_arr: number[] = [];
  let c_arr: number[] = [0.0];
  let h_arr: number[] = [0.0];
  let t: number = 0;
  while ((t < _len(seq))) {
    let x: number = seq[(t) < 0 ? seq.length + (t) : t];
    let h_prev: number = h_arr[(t) < 0 ? h_arr.length + (t) : t];
    let c_prev: number = c_arr[(t) < 0 ? c_arr.length + (t) : t];
    let i_t: number = sigmoid((((w.w_i * x) + (w.u_i * h_prev)) + w.b_i));
    let f_t: number = sigmoid((((w.w_f * x) + (w.u_f * h_prev)) + w.b_f));
    let o_t: number = sigmoid((((w.w_o * x) + (w.u_o * h_prev)) + w.b_o));
    let g_t: number = tanh_approx((((w.w_c * x) + (w.u_c * h_prev)) + w.b_c));
    let c_t: number = ((f_t * c_prev) + (i_t * g_t));
    let h_t: number = (o_t * tanh_approx(c_t));
    i_arr.push(i_t);
    f_arr.push(f_t);
    o_arr.push(o_t);
    g_arr.push(g_t);
    c_arr.push(c_t);
    h_arr.push(h_t);
    t = (t + 1);
  }
  return {"i": i_arr, "f": f_arr, "o": o_arr, "g": g_arr, "c": c_arr, "h": h_arr};
}
function backward(seq: number[], target: number, w: LSTMWeights, s: LSTMState, lr: number): LSTMWeights {
  let dw_i: number = 0.0;
  let du_i: number = 0.0;
  let db_i: number = 0.0;
  let dw_f: number = 0.0;
  let du_f: number = 0.0;
  let db_f: number = 0.0;
  let dw_o: number = 0.0;
  let du_o: number = 0.0;
  let db_o: number = 0.0;
  let dw_c: number = 0.0;
  let du_c: number = 0.0;
  let db_c: number = 0.0;
  let dw_y: number = 0.0;
  let db_y: number = 0.0;
  let T: number = _len(seq);
  let h_last: number = s.h[(T) < 0 ? s.h.length + (T) : T];
  let y: number = ((w.w_y * h_last) + w.b_y);
  let dy: number = (y - target);
  dw_y = (dy * h_last);
  db_y = dy;
  let dh_next: number = (dy * w.w_y);
  let dc_next: number = 0.0;
  let t: number = (T - 1);
  while ((t >= 0)) {
    let i_t: number = s.i[(t) < 0 ? s.i.length + (t) : t];
    let f_t: number = s.f[(t) < 0 ? s.f.length + (t) : t];
    let o_t: number = s.o[(t) < 0 ? s.o.length + (t) : t];
    let g_t: number = s.g[(t) < 0 ? s.g.length + (t) : t];
    let c_t: number = s.c[(Math.trunc((t + 1))) < 0 ? s.c.length + (Math.trunc((t + 1))) : Math.trunc((t + 1))];
    let c_prev: number = s.c[(t) < 0 ? s.c.length + (t) : t];
    let h_prev: number = s.h[(t) < 0 ? s.h.length + (t) : t];
    let tanh_c: number = tanh_approx(c_t);
    let do_t: number = (dh_next * tanh_c);
    let da_o: number = ((do_t * o_t) * (1.0 - o_t));
    let dc: number = (((dh_next * o_t) * (1.0 - (tanh_c * tanh_c))) + dc_next);
    let di_t: number = (dc * g_t);
    let da_i: number = ((di_t * i_t) * (1.0 - i_t));
    let dg_t: number = (dc * i_t);
    let da_g: number = (dg_t * (1.0 - (g_t * g_t)));
    let df_t: number = (dc * c_prev);
    let da_f: number = ((df_t * f_t) * (1.0 - f_t));
    dw_i = (dw_i + (da_i * seq[(t) < 0 ? seq.length + (t) : t]));
    du_i = (du_i + (da_i * h_prev));
    db_i = (db_i + da_i);
    dw_f = (dw_f + (da_f * seq[(t) < 0 ? seq.length + (t) : t]));
    du_f = (du_f + (da_f * h_prev));
    db_f = (db_f + da_f);
    dw_o = (dw_o + (da_o * seq[(t) < 0 ? seq.length + (t) : t]));
    du_o = (du_o + (da_o * h_prev));
    db_o = (db_o + da_o);
    dw_c = (dw_c + (da_g * seq[(t) < 0 ? seq.length + (t) : t]));
    du_c = (du_c + (da_g * h_prev));
    db_c = (db_c + da_g);
    dh_next = ((((da_i * w.u_i) + (da_f * w.u_f)) + (da_o * w.u_o)) + (da_g * w.u_c));
    dc_next = (dc * f_t);
    t = (t - 1);
  }
  w.w_y = (w.w_y - (lr * dw_y));
  w.b_y = (w.b_y - (lr * db_y));
  w.w_i = (w.w_i - (lr * dw_i));
  w.u_i = (w.u_i - (lr * du_i));
  w.b_i = (w.b_i - (lr * db_i));
  w.w_f = (w.w_f - (lr * dw_f));
  w.u_f = (w.u_f - (lr * du_f));
  w.b_f = (w.b_f - (lr * db_f));
  w.w_o = (w.w_o - (lr * dw_o));
  w.u_o = (w.u_o - (lr * du_o));
  w.b_o = (w.b_o - (lr * db_o));
  w.w_c = (w.w_c - (lr * dw_c));
  w.u_c = (w.u_c - (lr * du_c));
  w.b_c = (w.b_c - (lr * db_c));
  return w;
}
function make_samples(data: number[], look_back: number): Samples {
  let X: number[][] = [];
  let Y: number[] = [];
  let i: number = 0;
  while (((i + look_back) < _len(data))) {
    let seq = data.slice(i, (i + look_back));
    X.push(seq);
    Y.push(data[(Math.trunc((i + look_back))) < 0 ? data.length + (Math.trunc((i + look_back))) : Math.trunc((i + look_back))]);
    i = (i + 1);
  }
  return {"x": X, "y": Y};
}
function init_weights(): LSTMWeights {
  return {"w_i": 0.1, "u_i": 0.2, "b_i": 0.0, "w_f": 0.1, "u_f": 0.2, "b_f": 0.0, "w_o": 0.1, "u_o": 0.2, "b_o": 0.0, "w_c": 0.1, "u_c": 0.2, "b_c": 0.0, "w_y": 0.1, "b_y": 0.0};
}
function train(data: number[], look_back: number, epochs: number, lr: number): LSTMWeights {
  let samples: Samples = make_samples(data, look_back);
  let w: LSTMWeights = init_weights();
  let ep: number = 0;
  while ((ep < epochs)) {
    let j: number = 0;
    while ((j < _len(samples.x))) {
      let seq: number[] = samples.x[(j) < 0 ? samples.x.length + (j) : j];
      let target: number = samples.y[(j) < 0 ? samples.y.length + (j) : j];
      let state: LSTMState = forward(seq, w);
      w = backward(seq, target, w, state, lr);
      j = (j + 1);
    }
    ep = (ep + 1);
  }
  return w;
}
function predict(seq: number[], w: LSTMWeights): number {
  let state: LSTMState = forward(seq, w);
  let h_last: number = state.h[(Math.trunc((_len(state.h) - 1))) < 0 ? state.h.length + (Math.trunc((_len(state.h) - 1))) : Math.trunc((_len(state.h) - 1))];
  return ((w.w_y * h_last) + w.b_y);
}
let data: number[] = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8];
let look_back: number = 3;
let epochs: number = 200;
let lr: number = 0.1;
let test_seq: number[] = [0.6, 0.7, 0.8];
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let w: LSTMWeights
let pred: number
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
w = train(data, look_back, epochs, lr)
pred = predict(test_seq, w)
  console.log(_str(("Predicted value: " + _str(pred))));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

