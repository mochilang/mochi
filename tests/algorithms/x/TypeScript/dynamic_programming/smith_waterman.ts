// Generated by Mochi v0.10.59 on 2025-08-06 21:52:38 GMT+7

function score_function(source_char: string, target_char: string, match_score: number, mismatch_score: number, gap_score: number): number {
  if (((source_char == "-") || (target_char == "-"))) {
    return gap_score;
  }
  if ((source_char == target_char)) {
    return match_score;
  }
  return mismatch_score;
}
function smith_waterman(query: string, subject: string, match_score: number, mismatch_score: number, gap_score: number): number[][] {
  let q: string = query.toUpperCase();
  let s: string = subject.toUpperCase();
  let m: number = _len(q);
  let n: number = _len(s);
  let score: number[][] = [];
  for (let _ = 0; _ < (m + 1); _++) {
    let row: number[] = [];
    for (let _2 = 0; _2 < (n + 1); _2++) {
      row.push(0);
    }
    score.push(row);
  }
  for (let i = 1; i < (m + 1); i++) {
    for (let j = 1; j < (n + 1); j++) {
      let qc: string = (q).substring((i - 1), i);
      let sc: string = (s).substring((j - 1), j);
      let diag: number = (score[(Math.trunc((i - 1))) < 0 ? score.length + (Math.trunc((i - 1))) : Math.trunc((i - 1))][(Math.trunc((j - 1))) < 0 ? score[(Math.trunc((i - 1))) < 0 ? score.length + (Math.trunc((i - 1))) : Math.trunc((i - 1))].length + (Math.trunc((j - 1))) : Math.trunc((j - 1))] + score_function(qc, sc, match_score, mismatch_score, gap_score));
      let _delete: number = (score[(Math.trunc((i - 1))) < 0 ? score.length + (Math.trunc((i - 1))) : Math.trunc((i - 1))][(j) < 0 ? score[(Math.trunc((i - 1))) < 0 ? score.length + (Math.trunc((i - 1))) : Math.trunc((i - 1))].length + (j) : j] + gap_score);
      let insert: number = (score[(i) < 0 ? score.length + (i) : i][(Math.trunc((j - 1))) < 0 ? score[(i) < 0 ? score.length + (i) : i].length + (Math.trunc((j - 1))) : Math.trunc((j - 1))] + gap_score);
      let max_val: number = 0;
      if ((diag > max_val)) {
        max_val = diag;
      }
      if ((_delete > max_val)) {
        max_val = _delete;
      }
      if ((insert > max_val)) {
        max_val = insert;
      }
      score[(i) < 0 ? score.length + (i) : i][(j) < 0 ? score[(i) < 0 ? score.length + (i) : i].length + (j) : j] = max_val;
    }
  }
  return score;
}
function traceback(score: number[][], query: string, subject: string, match_score: number, mismatch_score: number, gap_score: number): string {
  let q: string = query.toUpperCase();
  let s: string = subject.toUpperCase();
  let max_value: number = 0;
  let i_max: number = 0;
  let j_max: number = 0;
  for (let i = 0; i < _len(score); i++) {
    for (let j = 0; j < _len(score[(i) < 0 ? score.length + (i) : i]); j++) {
      if ((score[(i) < 0 ? score.length + (i) : i][(j) < 0 ? score[(i) < 0 ? score.length + (i) : i].length + (j) : j] > max_value)) {
        max_value = score[(i) < 0 ? score.length + (i) : i][(j) < 0 ? score[(i) < 0 ? score.length + (i) : i].length + (j) : j];
        i_max = i;
        j_max = j;
      }
    }
  }
  let i: number = i_max;
  let j: number = j_max;
  let align1: string = "";
  let align2: string = "";
  let gap_penalty: number = score_function("-", "-", match_score, mismatch_score, gap_score);
  if (((i == 0) || (j == 0))) {
    return "";
  }
  while (((i > 0) && (j > 0))) {
    let qc: string = (q).substring((i - 1), i);
    let sc: string = (s).substring((j - 1), j);
    if ((score[(i) < 0 ? score.length + (i) : i][(j) < 0 ? score[(i) < 0 ? score.length + (i) : i].length + (j) : j] == (score[(Math.trunc((i - 1))) < 0 ? score.length + (Math.trunc((i - 1))) : Math.trunc((i - 1))][(Math.trunc((j - 1))) < 0 ? score[(Math.trunc((i - 1))) < 0 ? score.length + (Math.trunc((i - 1))) : Math.trunc((i - 1))].length + (Math.trunc((j - 1))) : Math.trunc((j - 1))] + score_function(qc, sc, match_score, mismatch_score, gap_score)))) {
      align1 = (qc + align1);
      align2 = (sc + align2);
      i = (i - 1);
      j = (j - 1);
    } else {
      if ((score[(i) < 0 ? score.length + (i) : i][(j) < 0 ? score[(i) < 0 ? score.length + (i) : i].length + (j) : j] == (score[(Math.trunc((i - 1))) < 0 ? score.length + (Math.trunc((i - 1))) : Math.trunc((i - 1))][(j) < 0 ? score[(Math.trunc((i - 1))) < 0 ? score.length + (Math.trunc((i - 1))) : Math.trunc((i - 1))].length + (j) : j] + gap_penalty))) {
        align1 = (qc + align1);
        align2 = ("-" + align2);
        i = (i - 1);
      } else {
        align1 = ("-" + align1);
        align2 = (sc + align2);
        j = (j - 1);
      }
    }
  }
  return ((align1 + "\n") + align2);
}
let query: string = "HEAGAWGHEE";
let subject: string = "PAWHEAE";
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let score: number[][]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
score = smith_waterman(query, subject, 1, -1, -2)
  console.log(_str(traceback(score, query, subject, 1, -1, -2)));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

