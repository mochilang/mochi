// Generated by Mochi v0.10.59 on 2025-08-06 21:32:18 GMT+7

let PI: number = 3.141592653589793;
function sqrtApprox(x: number): number {
  let guess: number = (x / 2.0);
  let i: number = 0;
  while ((i < 20)) {
    guess = ((guess + (x / guess)) / 2.0);
    i = (i + 1);
  }
  return guess;
}
function atanApprox(x: number): number {
  if ((x > 1.0)) {
    return ((PI / 2.0) - (x / ((x * x) + 0.28)));
  }
  if ((x < -1.0)) {
    return ((-PI / 2.0) - (x / ((x * x) + 0.28)));
  }
  return (x / (1.0 + ((0.28 * x) * x)));
}
function atan2Approx(y: number, x: number): number {
  if ((x > 0.0)) {
    let r: number = atanApprox((y / x));
    return r;
  }
  if ((x < 0.0)) {
    if ((y >= 0.0)) {
      return (atanApprox((y / x)) + PI);
    }
    return (atanApprox((y / x)) - PI);
  }
  if ((y > 0.0)) {
    return (PI / 2.0);
  }
  if ((y < 0.0)) {
    return (-PI / 2.0);
  }
  return 0.0;
}
function deg(rad: number): number {
  return ((rad * 180.0) / PI);
}
let GAUSSIAN_KERNEL: number[][] = [[0.0625, 0.125, 0.0625], [0.125, 0.25, 0.125], [0.0625, 0.125, 0.0625]];
function zero_matrix(h: number, w: number): number[][] {
  let out: number[][] = [];
  let i: number = 0;
  while ((i < h)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < w)) {
      row.push(0.0);
      j = (j + 1);
    }
    out.push(row);
    i = (i + 1);
  }
  return out;
}
function convolve(img: number[][], kernel: number[][]): number[][] {
  let h: number = _len(img);
  let w: number = _len(img[Math.trunc(0)]);
  let k: number = _len(kernel);
  let pad: number = Math.trunc(k / 2);
  let out: number[][] = zero_matrix(h, w);
  let y: number = pad;
  while ((y < (h - pad))) {
    let x: number = pad;
    while ((x < (w - pad))) {
      let sum: number = 0.0;
      let ky: number = 0;
      while ((ky < k)) {
        let kx: number = 0;
        while ((kx < k)) {
          let pixel: number = img[Math.trunc(((y - pad) + ky))][Math.trunc(((x - pad) + kx))];
          let weight: number = kernel[ky][kx];
          sum = (sum + (pixel * weight));
          kx = (kx + 1);
        }
        ky = (ky + 1);
      }
      out[y][x] = sum;
      x = (x + 1);
    }
    y = (y + 1);
  }
  return out;
}
function gaussian_blur(img: number[][]): number[][] {
  return convolve(img, GAUSSIAN_KERNEL);
}
function sobel_filter(img: number[][]): Record<string, number[][]> {
  let gx: number[][] = convolve(img, SOBEL_GX);
  let gy: number[][] = convolve(img, SOBEL_GY);
  let h: number = _len(img);
  let w: number = _len(img[Math.trunc(0)]);
  let grad: number[][] = zero_matrix(h, w);
  let dir: number[][] = zero_matrix(h, w);
  let i: number = 0;
  while ((i < h)) {
    let j: number = 0;
    while ((j < w)) {
      let gxx: number = gx[i][j];
      let gyy: number = gy[i][j];
      grad[i][j] = sqrtApprox(((gxx * gxx) + (gyy * gyy)));
      dir[i][j] = (deg(atan2Approx(gyy, gxx)) + 180.0);
      j = (j + 1);
    }
    i = (i + 1);
  }
  return {grad, dir};
}
function suppress_non_maximum(h: number, w: number, direction: number[][], grad: number[][]): number[][] {
  let dest: number[][] = zero_matrix(h, w);
  let r: number = 1;
  while ((r < (h - 1))) {
    let c: number = 1;
    while ((c < (w - 1))) {
      let angle: number = direction[r][c];
      let q: number = 0.0;
      let p: number = 0.0;
      if (((((angle >= 0.0) && (angle < 22.5)) || ((angle >= 157.5) && (angle <= 180.0))) || (angle >= 337.5))) {
        q = grad[r][Math.trunc((c + 1))];
        p = grad[r][Math.trunc((c - 1))];
      } else {
        if ((((angle >= 22.5) && (angle < 67.5)) || ((angle >= 202.5) && (angle < 247.5)))) {
          q = grad[Math.trunc((r + 1))][Math.trunc((c - 1))];
          p = grad[Math.trunc((r - 1))][Math.trunc((c + 1))];
        } else {
          if ((((angle >= 67.5) && (angle < 112.5)) || ((angle >= 247.5) && (angle < 292.5)))) {
            q = grad[Math.trunc((r + 1))][c];
            p = grad[Math.trunc((r - 1))][c];
          } else {
            q = grad[Math.trunc((r - 1))][Math.trunc((c - 1))];
            p = grad[Math.trunc((r + 1))][Math.trunc((c + 1))];
          }
        }
      }
      if (((grad[r][c] >= q) && (grad[r][c] >= p))) {
        dest[r][c] = grad[r][c];
      }
      c = (c + 1);
    }
    r = (r + 1);
  }
  return dest;
}
function double_threshold(h: number, w: number, img: number[][], low: number, high: number, weak: number, strong: number) {
  let r: number = 0;
  while ((r < h)) {
    let c: number = 0;
    while ((c < w)) {
      let v: number = img[r][c];
      if ((v >= high)) {
        img[r][c] = strong;
      } else {
        if ((v < low)) {
          img[r][c] = 0.0;
        } else {
          img[r][c] = weak;
        }
      }
      c = (c + 1);
    }
    r = (r + 1);
  }
}
function track_edge(h: number, w: number, img: number[][], weak: number, strong: number) {
  let r: number = 1;
  while ((r < (h - 1))) {
    let c: number = 1;
    while ((c < (w - 1))) {
      if ((img[r][c] == weak)) {
        if (((((((((img[Math.trunc((r + 1))][c] == strong) || (img[Math.trunc((r - 1))][c] == strong)) || (img[r][Math.trunc((c + 1))] == strong)) || (img[r][Math.trunc((c - 1))] == strong)) || (img[Math.trunc((r - 1))][Math.trunc((c - 1))] == strong)) || (img[Math.trunc((r - 1))][Math.trunc((c + 1))] == strong)) || (img[Math.trunc((r + 1))][Math.trunc((c - 1))] == strong)) || (img[Math.trunc((r + 1))][Math.trunc((c + 1))] == strong))) {
          img[r][c] = strong;
        } else {
          img[r][c] = 0.0;
        }
      }
      c = (c + 1);
    }
    r = (r + 1);
  }
}
function canny(image: number[][], low: number, high: number, weak: number, strong: number): number[][] {
  let blurred: number[][] = gaussian_blur(image);
  let sob: Record<string, number[][]> = sobel_filter(blurred);
  let grad: number[][] = sob.grad;
  let direction: number[][] = sob.dir;
  let h: number = _len(image);
  let w: number = _len(image[Math.trunc(0)]);
  let suppressed: number[][] = suppress_non_maximum(h, w, direction, grad);
  double_threshold(h, w, suppressed, low, high, weak, strong);
  track_edge(h, w, suppressed, weak, strong);
  return suppressed;
}
function print_image(img: number[][]) {
  let r: number = 0;
  while ((r < _len(img))) {
    let c: number = 0;
    let line: string = "";
    while ((c < _len(img[r]))) {
      line = ((line + _str(Math.trunc(img[r][c]))) + " ");
      c = (c + 1);
    }
    console.log(_str(line));
    r = (r + 1);
  }
}
let image: number[][] = [[0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 255.0, 255.0, 255.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]];
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let SOBEL_GX: number[][]
let SOBEL_GY: number[][]
let edges: number[][]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
SOBEL_GX = [[-1.0, 0.0, 1.0], [-2.0, 0.0, 2.0], [-1.0, 0.0, 1.0]]
SOBEL_GY = [[1.0, 2.0, 1.0], [0.0, 0.0, 0.0], [-1.0, -2.0, -1.0]]
edges = canny(image, 20.0, 40.0, 128.0, 255.0)
  print_image(edges);
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

