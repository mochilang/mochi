// Generated by Mochi v0.10.61 on 2025-08-08 17:05:51 GMT+7

function clamp_byte(x: number): number {
  if ((x < 0)) {
    return 0;
  }
  if ((x > 255)) {
    return 255;
  }
  return x;
}
function convert_to_negative(img: number[][]): number[][] {
  let h: number = _len(img);
  let w: number = _len(img[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()]);
  let out: number[][] = [];
  let y: number = 0;
  while ((y < h)) {
    let row: number[] = [];
    let x: number = 0;
    while ((x < w)) {
      row.push((255 - img[(()=>{const _mochi_idx = y; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = x; return _mochi_idx < 0 ? img[(()=>{const _mochi_idx = y; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()]));
      x = (x + 1);
    }
    out.push(row);
    y = (y + 1);
  }
  return out;
}
function change_contrast(img: number[][], factor: number): number[][] {
  let h: number = _len(img);
  let w: number = _len(img[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()]);
  let out: number[][] = [];
  let y: number = 0;
  while ((y < h)) {
    let row: number[] = [];
    let x: number = 0;
    while ((x < w)) {
      let p: number = img[(()=>{const _mochi_idx = y; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = x; return _mochi_idx < 0 ? img[(()=>{const _mochi_idx = y; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()];
      let v: number = (Math.trunc(((p - 128) * factor) / 100) + 128);
      v = clamp_byte(v);
      row.push(v);
      x = (x + 1);
    }
    out.push(row);
    y = (y + 1);
  }
  return out;
}
function gen_gaussian_kernel(n: number, sigma: number): number[][] {
  if ((n == 3)) {
    return [[(1.0 / 16.0), (2.0 / 16.0), (1.0 / 16.0)], [(2.0 / 16.0), (4.0 / 16.0), (2.0 / 16.0)], [(1.0 / 16.0), (2.0 / 16.0), (1.0 / 16.0)]];
  }
  let k: number[][] = [];
  let i: number = 0;
  while ((i < n)) {
    let row: number[] = [];
    let j: number = 0;
    while ((j < n)) {
      row.push(0.0);
      j = (j + 1);
    }
    k.push(row);
    i = (i + 1);
  }
  return k;
}
function img_convolve(img: number[][], kernel: number[][]): number[][] {
  let h: number = _len(img);
  let w: number = _len(img[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()]);
  let out: number[][] = [];
  let y: number = 0;
  while ((y < h)) {
    let row: number[] = [];
    let x: number = 0;
    while ((x < w)) {
      let acc: number = 0.0;
      let ky: number = 0;
      while ((ky < _len(kernel))) {
        let kx: number = 0;
        while ((kx < _len(kernel[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? kernel.length + _mochi_idx : _mochi_idx;})()]))) {
          let iy: number = ((y + ky) - 1);
          let ix: number = ((x + kx) - 1);
          let pixel: number = 0;
          if (((((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w))) {
            pixel = img[(()=>{const _mochi_idx = iy; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = ix; return _mochi_idx < 0 ? img[(()=>{const _mochi_idx = iy; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()];
          }
          acc = (acc + (kernel[(()=>{const _mochi_idx = ky; return _mochi_idx < 0 ? kernel.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = kx; return _mochi_idx < 0 ? kernel[(()=>{const _mochi_idx = ky; return _mochi_idx < 0 ? kernel.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()] * (1.0 * pixel)));
          kx = (kx + 1);
        }
        ky = (ky + 1);
      }
      row.push(Math.trunc(acc));
      x = (x + 1);
    }
    out.push(row);
    y = (y + 1);
  }
  return out;
}
function sort_ints(xs: number[]): number[] {
  let arr: number[] = xs;
  let i: number = 0;
  while ((i < _len(arr))) {
    let j: number = 0;
    while ((j < ((_len(arr) - 1) - i))) {
      if ((arr[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()] > arr[(()=>{const _mochi_idx = Math.trunc((j + 1)); return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()])) {
        let tmp: number = arr[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()];
        arr[(()=>{const _mochi_idx = j; return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()] = arr[(()=>{const _mochi_idx = Math.trunc((j + 1)); return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()];
        arr[(()=>{const _mochi_idx = (j + 1); return _mochi_idx < 0 ? arr.length + _mochi_idx : _mochi_idx;})()] = tmp;
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
  return arr;
}
function median_filter(img: number[][], k: number): number[][] {
  let h: number = _len(img);
  let w: number = _len(img[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()]);
  let offset: number = Math.trunc(k / 2);
  let out: number[][] = [];
  let y: number = 0;
  while ((y < h)) {
    let row: number[] = [];
    let x: number = 0;
    while ((x < w)) {
      let vals: number[] = [];
      let ky: number = 0;
      while ((ky < k)) {
        let kx: number = 0;
        while ((kx < k)) {
          let iy: number = ((y + ky) - offset);
          let ix: number = ((x + kx) - offset);
          let pixel: number = 0;
          if (((((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w))) {
            pixel = img[(()=>{const _mochi_idx = iy; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = ix; return _mochi_idx < 0 ? img[(()=>{const _mochi_idx = iy; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()];
          }
          vals.push(pixel);
          kx = (kx + 1);
        }
        ky = (ky + 1);
      }
      let sorted: number[] = sort_ints(vals);
      row.push(sorted[(()=>{const _mochi_idx = Math.trunc(Math.trunc(_len(sorted) / 2)); return _mochi_idx < 0 ? sorted.length + _mochi_idx : _mochi_idx;})()]);
      x = (x + 1);
    }
    out.push(row);
    y = (y + 1);
  }
  return out;
}
function iabs(x: number): number {
  if ((x < 0)) {
    return -x;
  }
  return x;
}
function sobel_filter(img: number[][]): number[][] {
  let gx: number[][] = [[1, 0, -1], [2, 0, -2], [1, 0, -1]];
  let gy: number[][] = [[1, 2, 1], [0, 0, 0], [-1, -2, -1]];
  let h: number = _len(img);
  let w: number = _len(img[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()]);
  let out: number[][] = [];
  let y: number = 0;
  while ((y < h)) {
    let row: number[] = [];
    let x: number = 0;
    while ((x < w)) {
      let sx: number = 0;
      let sy: number = 0;
      let ky: number = 0;
      while ((ky < 3)) {
        let kx: number = 0;
        while ((kx < 3)) {
          let iy: number = ((y + ky) - 1);
          let ix: number = ((x + kx) - 1);
          let pixel: number = 0;
          if (((((iy >= 0) && (iy < h)) && (ix >= 0)) && (ix < w))) {
            pixel = img[(()=>{const _mochi_idx = iy; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = ix; return _mochi_idx < 0 ? img[(()=>{const _mochi_idx = iy; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()];
          }
          sx = (sx + (gx[(()=>{const _mochi_idx = ky; return _mochi_idx < 0 ? gx.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = kx; return _mochi_idx < 0 ? gx[(()=>{const _mochi_idx = ky; return _mochi_idx < 0 ? gx.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()] * pixel));
          sy = (sy + (gy[(()=>{const _mochi_idx = ky; return _mochi_idx < 0 ? gy.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = kx; return _mochi_idx < 0 ? gy[(()=>{const _mochi_idx = ky; return _mochi_idx < 0 ? gy.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()] * pixel));
          kx = (kx + 1);
        }
        ky = (ky + 1);
      }
      row.push((iabs(sx) + iabs(sy)));
      x = (x + 1);
    }
    out.push(row);
    y = (y + 1);
  }
  return out;
}
function get_neighbors_pixel(img: number[][], x: number, y: number): number[] {
  let h: number = _len(img);
  let w: number = _len(img[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()]);
  let neighbors: number[] = [];
  let dy: number = -1;
  while ((dy <= 1)) {
    let dx: number = -1;
    while ((dx <= 1)) {
      if (!((dx == 0) && (dy == 0))) {
        let ny: number = (y + dy);
        let nx: number = (x + dx);
        let val: number = 0;
        if (((((ny >= 0) && (ny < h)) && (nx >= 0)) && (nx < w))) {
          val = img[(()=>{const _mochi_idx = ny; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = nx; return _mochi_idx < 0 ? img[(()=>{const _mochi_idx = ny; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()];
        }
        neighbors.push(val);
      }
      dx = (dx + 1);
    }
    dy = (dy + 1);
  }
  return neighbors;
}
function pow2(e: number): number {
  let r: number = 1;
  let i: number = 0;
  while ((i < e)) {
    r = (r * 2);
    i = (i + 1);
  }
  return r;
}
function local_binary_value(img: number[][], x: number, y: number): number {
  let center: number = img[(()=>{const _mochi_idx = y; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()][(()=>{const _mochi_idx = x; return _mochi_idx < 0 ? img[(()=>{const _mochi_idx = y; return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()].length + _mochi_idx : _mochi_idx;})()];
  let neighbors: number[] = get_neighbors_pixel(img, x, y);
  let v: number = 0;
  let i: number = 0;
  while ((i < _len(neighbors))) {
    if ((neighbors[(()=>{const _mochi_idx = i; return _mochi_idx < 0 ? neighbors.length + _mochi_idx : _mochi_idx;})()] >= center)) {
      v = (v + pow2(i));
    }
    i = (i + 1);
  }
  return v;
}
function local_binary_pattern(img: number[][]): number[][] {
  let h: number = _len(img);
  let w: number = _len(img[(()=>{const _mochi_idx = Math.trunc(0); return _mochi_idx < 0 ? img.length + _mochi_idx : _mochi_idx;})()]);
  let out: number[][] = [];
  let y: number = 0;
  while ((y < h)) {
    let row: number[] = [];
    let x: number = 0;
    while ((x < w)) {
      row.push(local_binary_value(img, x, y));
      x = (x + 1);
    }
    out.push(row);
    y = (y + 1);
  }
  return out;
}
let img: number[][] = [[52, 55, 61], [62, 59, 55], [63, 65, 66]];
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  } else {
    _nowSeed = 1;
    _nowSeeded = true;
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _len(x: any): number { return Array.isArray(x) || typeof x === 'string' ? x.length : Object.keys(x ?? {}).length; }
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let negative: number[][]
let contrast: number[][]
let kernel: number[][]
let laplace: number[][]
let convolved: number[][]
let medianed: number[][]
let sobel: number[][]
let lbp_img: number[][]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
negative = convert_to_negative(img)
contrast = change_contrast(img, 110)
kernel = gen_gaussian_kernel(3, 1.0)
laplace = [[0.25, 0.5, 0.25], [0.5, -3.0, 0.5], [0.25, 0.5, 0.25]]
convolved = img_convolve(img, laplace)
medianed = median_filter(img, 3)
sobel = sobel_filter(img)
lbp_img = local_binary_pattern(img)
  console.log(_str("[" + (negative).join(' ') + "]"));
  console.log(_str("[" + (contrast).join(' ') + "]"));
  console.log(_str("[" + (kernel).join(' ') + "]"));
  console.log(_str("[" + (convolved).join(' ') + "]"));
  console.log(_str("[" + (medianed).join(' ') + "]"));
  console.log(_str("[" + (sobel).join(' ') + "]"));
  console.log(_str("[" + (lbp_img).join(' ') + "]"));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

