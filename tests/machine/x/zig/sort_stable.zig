// Generated by Mochi compiler v0.10.27 on 2025-07-17T17:59:22Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _print_list(comptime T: type, v: []const T) void {
    for (v, 0..) |it, i| {
        if (i > 0) std.debug.print(" ", .{});
        std.debug.print("{any}", .{it});
    }
    std.debug.print("\n", .{});
}

const ItemsItem = struct {
    n: i32,
    v: []const u8,
};
const items = &[_]ItemsItem{
    ItemsItem{
    .n = 1,
    .v = "a",
},
    ItemsItem{
    .n = 1,
    .v = "b",
},
    ItemsItem{
    .n = 2,
    .v = "c",
},
}; // []const ItemsItem
var result: []const []const u8 = undefined; // []const []const u8

pub fn main() void {
    result = blk0: { var _tmp0 = std.ArrayList(struct { item: u8, key: i32 }).init(std.heap.page_allocator); for (items) |i| { _tmp0.append(.{ .item = i.v, .key = i.n }) catch |err| handleError(err); } for (0.._tmp0.items.len) |i| { for (i+1.._tmp0.items.len) |j| { if (_tmp0.items[j].key < _tmp0.items[i].key) { const t = _tmp0.items[i]; _tmp0.items[i] = _tmp0.items[j]; _tmp0.items[j] = t; } } } var _tmp1 = std.ArrayList(u8).init(std.heap.page_allocator);for (_tmp0.items) |p| { _tmp1.append(p.item) catch |err| handleError(err); } const _tmp2 = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk0 _tmp2; };
    _print_list([]const u8, result);
}
