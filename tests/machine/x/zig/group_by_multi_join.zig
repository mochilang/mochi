// Generated by Mochi compiler v0.10.27 on 2025-07-17T17:29:18Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _sum_int(v: []const i32) i32 {
    var sum: i32 = 0;
    for (v) |it| { sum += it; }
    return sum;
}

fn _print_list(comptime T: type, v: []const T) void {
    for (v, 0..) |it, i| {
        if (i > 0) std.debug.print(" ", .{});
        std.debug.print("{any}", .{it});
    }
    std.debug.print("\n", .{});
}

fn _equal(a: anytype, b: anytype) bool {
    if (@TypeOf(a) != @TypeOf(b)) return false;
    return std.meta.eql(a, b);
}

const NationsItem = struct {
    id: i32,
    name: []const u8,
};
const nations = &[_]NationsItem{
    NationsItem{
    .id = 1,
    .name = "A",
},
    NationsItem{
    .id = 2,
    .name = "B",
},
}; // []const NationsItem
const SuppliersItem = struct {
    id: i32,
    nation: i32,
};
const suppliers = &[_]SuppliersItem{
    SuppliersItem{
    .id = 1,
    .nation = 1,
},
    SuppliersItem{
    .id = 2,
    .nation = 2,
},
}; // []const SuppliersItem
const PartsuppItem = struct {
    part: i32,
    supplier: i32,
    cost: f64,
    qty: i32,
};
const partsupp = &[_]PartsuppItem{
    PartsuppItem{
    .part = 100,
    .supplier = 1,
    .cost = 10.0,
    .qty = 2,
},
    PartsuppItem{
    .part = 100,
    .supplier = 2,
    .cost = 20.0,
    .qty = 1,
},
    PartsuppItem{
    .part = 200,
    .supplier = 1,
    .cost = 5.0,
    .qty = 3,
},
}; // []const PartsuppItem
const FilteredItem = struct {
    part: i32,
    value: f64,
};
var filtered: []const FilteredItem = undefined; // []const FilteredItem
const GroupedItem = struct {
    part: i32,
    total: f64,
};
const ResultStruct8 = struct { key: i32, Items: std.ArrayList(FilteredItem) };
var grouped: []const GroupedItem = undefined; // []const GroupedItem

pub fn main() void {
    filtered = blk0: { var _tmp1 = std.ArrayList(FilteredItem).init(std.heap.page_allocator); for (partsupp) |ps| { for (suppliers) |s| { if (!((s.id == ps.supplier))) continue; for (nations) |n| { if (!((n.id == s.nation))) continue; if (!(std.mem.eql(u8, n.name, "A"))) continue; _tmp1.append(FilteredItem{
    .part = ps.part,
    .value = (ps.cost * ps.qty),
}) catch |err| handleError(err); } } } const _tmp2 = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk0 _tmp2; };
    grouped = blk3: { var _tmp9 = std.ArrayList(ResultStruct8).init(std.heap.page_allocator); for (filtered) |x| { const _tmp10 = x.part; var _found = false; var _idx: usize = 0; for (_tmp9.items, 0..) |it, i| { if (_equal(it.key, _tmp10)) { _found = true; _idx = i; break; } } if (_found) { _tmp9.items[_idx].Items.append(x) catch |err| handleError(err); } else { var g = ResultStruct8{ .key = _tmp10, .Items = std.ArrayList(FilteredItem).init(std.heap.page_allocator) }; g.Items.append(x) catch |err| handleError(err); _tmp9.append(g) catch |err| handleError(err); } } var _tmp11 = std.ArrayList(ResultStruct8).init(std.heap.page_allocator);for (_tmp9.items) |g| { _tmp11.append(g) catch |err| handleError(err); } var _tmp12 = std.ArrayList(GroupedItem).init(std.heap.page_allocator);for (_tmp11.items) |g| { _tmp12.append(GroupedItem{
    .part = g.key,
    .total = _sum_int(blk2: { var _tmp6 = std.ArrayList(i32).init(std.heap.page_allocator); for (g.Items.items) |r| { _tmp6.append(r.value) catch |err| handleError(err); } const _tmp7 = _tmp6.toOwnedSlice() catch |err| handleError(err); break :blk2 _tmp7; }),
}) catch |err| handleError(err); } const _tmp12Slice = _tmp12.toOwnedSlice() catch |err| handleError(err); break :blk3 _tmp12Slice; };
    _print_list(GroupedItem, grouped);
}
