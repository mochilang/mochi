// Generated by Mochi compiler v0.10.27 on 2025-07-17T18:26:20Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}


const ProductsItem = struct {
    name: []const u8,
    price: i32,
};
const products = &[_]ProductsItem{
    ProductsItem{
        .name = "Laptop",
        .price = 1500,
    },
    ProductsItem{
        .name = "Smartphone",
        .price = 900,
    },
    ProductsItem{
        .name = "Tablet",
        .price = 600,
    },
    ProductsItem{
        .name = "Monitor",
        .price = 300,
    },
    ProductsItem{
        .name = "Keyboard",
        .price = 100,
    },
    ProductsItem{
        .name = "Mouse",
        .price = 50,
    },
    ProductsItem{
        .name = "Headphones",
        .price = 200,
    },
}; // []const ProductsItem
var expensive: []const ProductsItem = undefined; // []const ProductsItem

pub fn main() void {
    expensive = blk0: {
        var _tmp0 = std.ArrayList(struct { item: ProductsItem, key: i32 }).init(std.heap.page_allocator);
        for (products) |p| {
            _tmp0.append(.{ .item = p, .key = -p.price }) catch |err| handleError(err);
        }
        for (0.._tmp0.items.len) |i| {
            for (i + 1.._tmp0.items.len) |j| {
                if (_tmp0.items[j].key < _tmp0.items[i].key) {
                    const t = _tmp0.items[i];
                    _tmp0.items[i] = _tmp0.items[j];
                    _tmp0.items[j] = t;
                }
            }
        }
        var _tmp1 = std.ArrayList(ProductsItem).init(std.heap.page_allocator);
        for (_tmp0.items) |p| {
            _tmp1.append(p.item) catch |err| handleError(err);
        }
        var _tmp2 = _tmp1.toOwnedSlice() catch |err| handleError(err);
        _tmp2 = _tmp2[1..(1 + 3)];
        break :blk0 _tmp2;
    };
    std.debug.print("--- Top products (excluding most expensive) ---\n", .{});
    for (expensive) |item| {
        std.debug.print("{s} {s} {d}\n", .{ item.name, "costs $", item.price });
    }
}
