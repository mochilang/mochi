// Generated by Mochi compiler v0.10.27 on 2025-07-17T17:59:22Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _read_input(path: ?[]const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    if (path == null or std.mem.eql(u8, path.?, "-")) {
        return std.io.getStdIn().readAllAlloc(alloc, 1 << 20) catch |err| handleError(err);
    } else {
        return std.fs.cwd().readFileAlloc(alloc, path.?, 1 << 20) catch |err| handleError(err);
    }
}

fn _write_output(path: ?[]const u8, data: []const u8) void {
    if (path == null or std.mem.eql(u8, path.?, "-")) {
        std.io.getStdOut().writeAll(data) catch |err| handleError(err);
    } else {
        std.fs.cwd().writeFile(path.?, data) catch |err| handleError(err);
    }
}

fn _load_json(comptime T: type, path: ?[]const u8) []T {
    const text = _read_input(path);
    return std.json.parseFromSlice(T, std.heap.page_allocator, text, .{}).value;
}

const Person = struct {
    name: []const u8,
    age: i32,
    email: []const u8,
};

const people = _load_json([]Person, "../interpreter/valid/people.yaml"); // []const Person
const AdultsItem = struct {
    name: []const u8,
    email: []const u8,
};
var adults: []const AdultsItem = undefined; // []const AdultsItem

pub fn main() void {
    adults = blk0: { var _tmp1 = std.ArrayList(AdultsItem).init(std.heap.page_allocator); for (people) |p| { if (!((p.age >= 18))) continue; _tmp1.append(AdultsItem{
    .name = p.name,
    .email = p.email,
}) catch |err| handleError(err); } const _tmp2 = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk0 _tmp2; };
    for (adults) |a| {
        std.debug.print("{any} {any}\n", .{a.name, a.email});
    }
}
