// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
import Foundation

func _sum<T: BinaryInteger>(_ arr: [T]) -> Double {
    var sum = 0.0
    for v in arr { sum += Double(v) }
    return sum
}
func _sum<T: BinaryFloatingPoint>(_ arr: [T]) -> Double {
    var sum = 0.0
    for v in arr { sum += Double(v) }
    return sum
}
struct Filtered: Equatable {
    var part: Int
    var value: Double
}

struct Nation: Equatable {
    var id: Int
    var name: String
}

struct Partsupp: Equatable {
    var cost: Double
    var part: Int
    var qty: Int
    var supplier: Int
}

struct Supplier: Equatable {
    var id: Int
    var nation: Int
}

var nations: [Nation] = [Nation(id: 1, name: "A"), Nation(id: 2, name: "B")]
var suppliers: [Supplier] = [Supplier(id: 1, nation: 1), Supplier(id: 2, nation: 2)]
var partsupp: [Partsupp] = [Partsupp(cost: 10.0, part: 100, qty: 2, supplier: 1), Partsupp(cost: 20.0, part: 100, qty: 1, supplier: 2), Partsupp(cost: 5.0, part: 200, qty: 3, supplier: 1)]
var filtered: [Filtered] = ({
	var _res: [(part: Int, value: Double)] = []
	for ps in partsupp {
		for s in suppliers {
			if !(s.id == ps.supplier) { continue }
			for n in nations {
				if !(n.id == s.nation) { continue }
				if !(n.name == "A") { continue }
				_res.append((part: ps.part, value: ps.cost * Double(ps.qty)))
			}
		}
	}
	return _res
}())
var grouped = { () -> [Any] in
    var _groups: [Int:[Filtered]] = [:]
    for x in filtered {
        let _k = x.part
        _groups[_k, default: []].append(x)
    }
    var _tmp: [(key: Int, items: [Filtered])] = []
    for (k, v) in _groups {
        _tmp.append((key: k, items: v))
    }
    return _tmp.map { g in ["part": g.key, "total": _sum(g.items.map { r in r.value })] }
}()
print(grouped)
