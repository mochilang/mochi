// Generated by Mochi TypeScript compiler

type Person = {
  name: string;
  age: number;
  email: string;
};

let adults: any[];
let people: Person[];

function main(): void {
  people = _load(
    "../interpreter/valid/people.yaml",
    _toAnyMap({ "format": "yaml" }),
  ) as Array<Person>;
  adults = people.filter((p) => (p.age >= 18)).map((p) => ({
    "name": p.name,
    "email": p.email,
  }));
  for (const a of adults) {
    console.log(a.name, a.email);
  }
}
import { readAllSync } from "https://deno.land/std@0.221.0/io/read_all.ts";
import {
  parse as _yamlParse,
  stringify as _yamlStringify,
} from "https://deno.land/std@0.221.0/yaml/mod.ts";
function _readInput(path: string | null): string {
  if (!path || path === "-") {
    const data = readAllSync(Deno.stdin);
    return new TextDecoder().decode(data);
  }
  return Deno.readTextFileSync(path);
}
function _writeOutput(path: string | null, text: string): void {
  const data = new TextEncoder().encode(text);
  if (!path || path === "-") {
    Deno.stdout.writeSync(data);
  } else {
    Deno.writeFileSync(path, data);
  }
}
function _parseCSV(text: string, header: boolean, delim: string): any[] {
  const lines = text.trim().split(/\r?\n/);
  if (lines.length === 0) return [];
  let headers: string[] = [];
  let start = 0;
  if (header) {
    headers = lines[0].split(delim);
    start = 1;
  } else headers = lines[0].split(delim).map((_, i) => `c${i}`);
  const out: any[] = [];
  for (let i = start; i < lines.length; i++) {
    if (!lines[i]) continue;
    const parts = lines[i].split(delim);
    const m: { [key: string]: any } = {};
    for (let j = 0; j < headers.length; j++) {
      const val = parts[j] ?? "";
      if (/^-?\d+$/.test(val)) m[headers[j]] = parseInt(val, 10);
      else if (/^-?\d*\.\d+(e[+-]?\d+)?$/i.test(val)) {
        m[headers[j]] = parseFloat(val);
      } else m[headers[j]] = val;
    }
    out.push(m);
  }
  return out;
}
function _load(path: string | null, opts: any): any[] {
  const format = opts?.format ?? "csv";
  const header = opts?.header ?? true;
  let delim = (opts?.delimiter ?? ",")[0];
  const text = _readInput(path);
  let items: any[];
  switch (format) {
    case "jsonl":
      items = text.trim().split(/\r?\n/).filter((l) => l).map((l) =>
        JSON.parse(l)
      );
      break;
    case "json":
      const d = JSON.parse(text);
      items = Array.isArray(d) ? d : [d];
      break;
    case "yaml":
      const y = _yamlParse(text);
      items = Array.isArray(y) ? y : [y];
      break;
    case "tsv":
      delim = "	";
      items = _parseCSV(text, header, delim);
      break;
    default:
      items = _parseCSV(text, header, delim);
  }
  if (opts?.filter) {
    const f = _toAnyMap(opts.filter);
    items = items.filter((r) => {
      for (const [k, v] of Object.entries(f)) {
        if (r[k] !== v) return false;
      }
      return true;
    });
  }
  if (opts?.page !== undefined && opts?.pageSize !== undefined) {
    const start = opts.page * opts.pageSize;
    items = start < items.length
      ? items.slice(start, start + opts.pageSize)
      : [];
  } else {
    if (opts?.skip !== undefined) {
      const n = opts.skip;
      items = n < items.length ? items.slice(n) : [];
    }
    if (opts?.take !== undefined) {
      const n = opts.take;
      if (n < items.length) items = items.slice(0, n);
    }
  }
  return items;
}
function _save(rows: any[], path: string | null, opts: any): void {
  const format = opts?.format ?? "csv";
  const header = opts?.header ?? false;
  let delim = (opts?.delimiter ?? ",")[0];
  switch (format) {
    case "jsonl":
      _writeOutput(path, rows.map((r) => JSON.stringify(r)).join("\n") + "\n");
      break;
    case "json":
      _writeOutput(
        path,
        rows.length === 1 ? JSON.stringify(rows[0]) : JSON.stringify(rows),
      );
      break;
    case "yaml":
      _writeOutput(
        path,
        rows.length === 1 ? _yamlStringify(rows[0]) : _yamlStringify(rows),
      );
      break;
    case "tsv":
      delim = "	";
    default:
      const headers = rows.length > 0 ? Object.keys(rows[0]).sort() : [];
      const lines: string[] = [];
      if (header) lines.push(headers.join(delim));
      for (const row of rows) {
        lines.push(
          headers.map((h) => row[h] !== undefined ? String(row[h]) : "").join(
            delim,
          ),
        );
      }
      _writeOutput(path, lines.join("\n") + "\n");
  }
}

function _toAnyMap(m: any): { [key: string]: any } {
  return m as { [key: string]: any };
}

main();
