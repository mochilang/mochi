
/workspace/mochi/tests/machine/x/hs/dataset_sort_take_limit.hs:181:13: error:
    • Couldn't match expected type: t3
                                    -> ((a3 -> b0) -> [a3] -> [b0])
                                    -> ((a4, b1) -> b1)
                                    -> [(AnyValue, Map.Map String AnyValue)]
                                    -> t
                  with actual type: [a6]
    • The function ‘take’ is applied to six value arguments,
        but its type ‘Int -> [a6] -> [a6]’ has only two
      In the expression:
        take
          3 drop 1 map snd
          (List.sortOn
             fst
             [((- fromMaybe (error "missing") (Map.lookup "price" (p))), p) |
                p <- products])
      In an equation for ‘expensive’:
          expensive
            = take
                3 drop 1 map snd
                (List.sortOn
                   fst
                   [((- fromMaybe (error "missing") (Map.lookup "price" (p))), p) |
                      p <- products])
    • Relevant bindings include
        expensive :: t
          (bound at /workspace/mochi/tests/machine/x/hs/dataset_sort_take_limit.hs:181:1)
    |
181 | expensive = take 3 drop 1 map snd (List.sortOn fst [((-fromMaybe (error "missing") (Map.lookup "price" (p))), p) | p <- products])
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/workspace/mochi/tests/machine/x/hs/dataset_sort_take_limit.hs:181:20: error:
    • Couldn't match expected type: [a6]
                  with actual type: Int -> [a5] -> [a5]
    • Probable cause: ‘drop’ is applied to too few arguments
      In the second argument of ‘take’, namely ‘drop’
      In the expression:
        take
          3 drop 1 map snd
          (List.sortOn
             fst
             [((- fromMaybe (error "missing") (Map.lookup "price" (p))), p) |
                p <- products])
      In an equation for ‘expensive’:
          expensive
            = take
                3 drop 1 map snd
                (List.sortOn
                   fst
                   [((- fromMaybe (error "missing") (Map.lookup "price" (p))), p) |
                      p <- products])
    |
181 | expensive = take 3 drop 1 map snd (List.sortOn fst [((-fromMaybe (error "missing") (Map.lookup "price" (p))), p) | p <- products])
    |                    ^^^^

/workspace/mochi/tests/machine/x/hs/dataset_sort_take_limit.hs:186:38: error:
    • Couldn't match expected type: t0 -> Maybe a0 -> String
                  with actual type: [Char]
    • The function ‘show’ is applied to three value arguments,
        but its type ‘(a1 -> Maybe a1 -> a1) -> [Char]’ has only one
      In the expression:
        show fromMaybe (error "missing") (Map.lookup "name" item)
      In the first argument of ‘unwords’, namely
        ‘[show fromMaybe (error "missing") (Map.lookup "name" item),
          "costs $",
          show fromMaybe (error "missing") (Map.lookup "price" item)]’
    • Relevant bindings include
        item :: Map.Map String a0
          (bound at /workspace/mochi/tests/machine/x/hs/dataset_sort_take_limit.hs:186:11)
    |
186 |   mapM_ (\item -> putStrLn (unwords [show fromMaybe (error "missing") (Map.lookup "name" item), "costs $", show fromMaybe (error "missing") (Map.lookup "price" item)])) expensive
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/workspace/mochi/tests/machine/x/hs/dataset_sort_take_limit.hs:186:108: error:
    • Couldn't match expected type: t1 -> Maybe a0 -> String
                  with actual type: [Char]
    • The function ‘show’ is applied to three value arguments,
        but its type ‘(a2 -> Maybe a2 -> a2) -> [Char]’ has only one
      In the expression:
        show fromMaybe (error "missing") (Map.lookup "price" item)
      In the first argument of ‘unwords’, namely
        ‘[show fromMaybe (error "missing") (Map.lookup "name" item),
          "costs $",
          show fromMaybe (error "missing") (Map.lookup "price" item)]’
    • Relevant bindings include
        item :: Map.Map String a0
          (bound at /workspace/mochi/tests/machine/x/hs/dataset_sort_take_limit.hs:186:11)
    |
186 |   mapM_ (\item -> putStrLn (unwords [show fromMaybe (error "missing") (Map.lookup "name" item), "costs $", show fromMaybe (error "missing") (Map.lookup "price" item)])) expensive
    |                                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Context around line 181:
  179| products = [Map.fromList [("name", VString ("Laptop")), ("price", VInt (1500))], Map.fromList [("name", VString ("Smartphone")), ("price", VInt (900))], Map.fromList [("name", VString ("Tablet")), ("price", VInt (600))], Map.fromList [("name", VString ("Monitor")), ("price", VInt (300))], Map.fromList [("name", VString ("Keyboard")), ("price", VInt (100))], Map.fromList [("name", VString ("Mouse")), ("price", VInt (50))], Map.fromList [("name", VString ("Headphones")), ("price", VInt (200))]]
  180| 
  181| expensive = take 3 drop 1 map snd (List.sortOn fst [((-fromMaybe (error "missing") (Map.lookup "price" (p))), p) | p <- products])
  182| 
  183| main :: IO ()
