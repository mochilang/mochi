// Generated by Mochi compiler v0.10.27 on 2025-07-17T18:08:55Z
program GroupItemsIteration;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;
generic _Group<K,T> = record
  Key: K;
  Items: specialize TArray<T>;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic procedure _printList<T>(arr: specialize TArray<T>);
var i: Integer;
begin
  for i := 0 to High(arr) do
  begin
    if i > 0 then Write(' ');
    Write(arr[i]);
  end;
  writeln();
end;

generic procedure _sortBy<T>(var arr: specialize TArray<T>; keys: specialize TArray<Variant>);
var i,j: integer; tmp: T; k: Variant;
begin
  for i := 0 to High(arr) - 1 do
  for j := i + 1 to High(arr) do
    if keys[i] > keys[j] then
    begin
      tmp := arr[i]; arr[i] := arr[j]; arr[j] := tmp;
      k := keys[i]; keys[i] := keys[j]; keys[j] := k;
    end;
end;


var
  _tmp0: specialize TFPGMap<string, Variant>;
  _tmp1: specialize TFPGMap<string, Variant>;
  _tmp10: specialize TArray<specialize _Group<Variant, specialize TFPGMap<string, Variant>>>;
  _tmp11: specialize TFPGMap<string, Variant>;
  _tmp12: specialize TArray<Variant>;
  _tmp13: specialize TArray<Variant>;
  _tmp2: specialize TFPGMap<string, Variant>;
  _tmp3: specialize TArray<specialize TFPGMap<string, Variant>>;
  _tmp4: specialize TArray<specialize _Group<Variant, specialize TFPGMap<string, Variant>>>;
  _tmp5: Variant;
  _tmp6: string;
  _tmp7: integer;
  _tmp8: integer;
  _tmp9: specialize _Group<Variant, specialize TFPGMap<string, Variant>>;
  d: specialize TFPGMap<string, Variant>;
  data: specialize TArray<specialize TFPGMap<string, Variant>>;
  g: Variant;
  groups: specialize TArray<Variant>;
  r: Variant;
  _result: specialize TArray<Variant>;
  tmp: specialize TArray<Variant>;
  total: integer;
  x: Variant;

begin
  _tmp0 := specialize TFPGMap<string, Variant>.Create;
  _tmp0.AddOrSetData('tag', 'a');
  _tmp0.AddOrSetData('val', 1);
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('tag', 'a');
  _tmp1.AddOrSetData('val', 2);
  _tmp2 := specialize TFPGMap<string, Variant>.Create;
  _tmp2.AddOrSetData('tag', 'b');
  _tmp2.AddOrSetData('val', 3);
  data := specialize TArray<specialize TFPGMap<string, Variant>>([_tmp0, _tmp1, _tmp2]);
  SetLength(_tmp3, 0);
  for d in data do
  begin
    _tmp3 := Concat(_tmp3, [d]);
  end;
  SetLength(_tmp4, 0);
  for d in _tmp3 do
  begin
    _tmp5 := d.KeyData['tag'];
    _tmp6 := VarToStr(_tmp5);
    _tmp7 := -1;
    for _tmp8 := 0 to High(_tmp4) do
      if VarToStr(_tmp4[_tmp8].Key) = _tmp6 then begin _tmp7 := _tmp8; Break; end;
    if _tmp7 = -1 then
    begin
      _tmp7 := Length(_tmp4);
      SetLength(_tmp4, _tmp7 + 1);
      _tmp4[_tmp7].Key := _tmp5;
      SetLength(_tmp4[_tmp7].Items, 0);
    end;
    SetLength(_tmp4[_tmp7].Items, Length(_tmp4[_tmp7].Items)+1);
    _tmp4[_tmp7].Items[High(_tmp4[_tmp7].Items)] := d;
  end;
  SetLength(_tmp10, 0);
  for _tmp9 in _tmp4 do
  begin
    _tmp10 := Concat(_tmp10, [_tmp9]);
  end;
  groups := _tmp10;
  tmp := specialize TArray<Variant>([]);
  for g in groups do
  begin
    total := 0;
    for x in g.items do
    begin
      total := total + x.KeyData['val'];
    end;
    _tmp11 := specialize TFPGMap<string, Variant>.Create;
    _tmp11.AddOrSetData('tag', g.key);
    _tmp11.AddOrSetData('total', total);
    tmp := specialize _appendList<Variant>(tmp, _tmp11);
  end;
  SetLength(_tmp12, 0);
  SetLength(_tmp13, 0);
  for r in tmp do
  begin
    _tmp12 := Concat(_tmp12, [r]);
    _tmp13 := Concat(_tmp13, [r.tag]);
  end;
  specialize _sortBy<Variant>(_tmp12, _tmp13);
  _result := _tmp12;
  specialize _printList<Variant>(_result);
end.
