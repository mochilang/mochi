// Generated by Mochi compiler v0.10.27 on 2025-07-17T18:08:53Z
program GroupByMultiJoin;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;
generic _Group<K,T> = record
  Key: K;
  Items: specialize TArray<T>;
end;

generic procedure _printList<T>(arr: specialize TArray<T>);
var i: Integer;
begin
  for i := 0 to High(arr) do
  begin
    if i > 0 then Write(' ');
    Write(arr[i]);
  end;
  writeln();
end;

generic function _sumList<T>(arr: specialize TArray<T>): double;
var i: integer; s: double;
begin
  s := 0;
  for i := 0 to High(arr) do
    s := s + arr[i];
  Result := s;
end;


var
  _tmp0: specialize TFPGMap<string, Variant>;
  _tmp1: specialize TFPGMap<string, Variant>;
  _tmp10: specialize TArray<specialize _Group<Variant, specialize TFPGMap<string, Variant>>>;
  _tmp11: Variant;
  _tmp12: string;
  _tmp13: integer;
  _tmp14: integer;
  _tmp15: specialize _Group<Variant, specialize TFPGMap<string, Variant>>;
  _tmp16: specialize TArray<specialize TFPGMap<string, Variant>>;
  _tmp17: specialize TFPGMap<string, Variant>;
  _tmp18: specialize TArray<Variant>;
  _tmp2: specialize TFPGMap<string, integer>;
  _tmp3: specialize TFPGMap<string, integer>;
  _tmp4: specialize TFPGMap<string, Variant>;
  _tmp5: specialize TFPGMap<string, Variant>;
  _tmp6: specialize TFPGMap<string, Variant>;
  _tmp7: specialize TArray<specialize TFPGMap<string, Variant>>;
  _tmp8: specialize TFPGMap<string, Variant>;
  _tmp9: specialize TArray<specialize TFPGMap<string, Variant>>;
  filtered: specialize TArray<specialize TFPGMap<string, Variant>>;
  grouped: specialize TArray<specialize TFPGMap<string, Variant>>;
  n: specialize TFPGMap<string, Variant>;
  nations: specialize TArray<specialize TFPGMap<string, Variant>>;
  partsupp: specialize TArray<specialize TFPGMap<string, Variant>>;
  ps: specialize TFPGMap<string, Variant>;
  r: integer;
  s: specialize TFPGMap<string, integer>;
  suppliers: specialize TArray<specialize TFPGMap<string, integer>>;
  x: specialize TFPGMap<string, Variant>;

begin
  _tmp0 := specialize TFPGMap<string, Variant>.Create;
  _tmp0.AddOrSetData('id', 1);
  _tmp0.AddOrSetData('name', 'A');
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('id', 2);
  _tmp1.AddOrSetData('name', 'B');
  nations := specialize TArray<specialize TFPGMap<string, Variant>>([_tmp0, _tmp1]);
  _tmp2 := specialize TFPGMap<string, integer>.Create;
  _tmp2.AddOrSetData('id', 1);
  _tmp2.AddOrSetData('nation', 1);
  _tmp3 := specialize TFPGMap<string, integer>.Create;
  _tmp3.AddOrSetData('id', 2);
  _tmp3.AddOrSetData('nation', 2);
  suppliers := specialize TArray<specialize TFPGMap<string, integer>>([_tmp2, _tmp3]);
  _tmp4 := specialize TFPGMap<string, Variant>.Create;
  _tmp4.AddOrSetData('part', 100);
  _tmp4.AddOrSetData('supplier', 1);
  _tmp4.AddOrSetData('cost', 10);
  _tmp4.AddOrSetData('qty', 2);
  _tmp5 := specialize TFPGMap<string, Variant>.Create;
  _tmp5.AddOrSetData('part', 100);
  _tmp5.AddOrSetData('supplier', 2);
  _tmp5.AddOrSetData('cost', 20);
  _tmp5.AddOrSetData('qty', 1);
  _tmp6 := specialize TFPGMap<string, Variant>.Create;
  _tmp6.AddOrSetData('part', 200);
  _tmp6.AddOrSetData('supplier', 1);
  _tmp6.AddOrSetData('cost', 5);
  _tmp6.AddOrSetData('qty', 3);
  partsupp := specialize TArray<specialize TFPGMap<string, Variant>>([_tmp4, _tmp5, _tmp6]);
  SetLength(_tmp7, 0);
  for ps in partsupp do
  begin
    for s in suppliers do
    begin
      if not ((s.id = ps.supplier)) then continue;
      for n in nations do
      begin
        if not ((n.id = s.nation)) then continue;
        if not ((n.KeyData['name'] = 'A')) then continue;
        _tmp8 := specialize TFPGMap<string, Variant>.Create;
        _tmp8.AddOrSetData('part', ps.KeyData['part']);
        _tmp8.AddOrSetData('value', ps.KeyData['cost'] * ps.KeyData['qty']);
        _tmp7 := Concat(_tmp7, [_tmp8]);
      end;
    end;
  end;
  filtered := _tmp7;
  SetLength(_tmp9, 0);
  for x in filtered do
  begin
    _tmp9 := Concat(_tmp9, [x]);
  end;
  SetLength(_tmp10, 0);
  for x in _tmp9 do
  begin
    _tmp11 := x.KeyData['part'];
    _tmp12 := VarToStr(_tmp11);
    _tmp13 := -1;
    for _tmp14 := 0 to High(_tmp10) do
      if VarToStr(_tmp10[_tmp14].Key) = _tmp12 then begin _tmp13 := _tmp14; Break; end;
    if _tmp13 = -1 then
    begin
      _tmp13 := Length(_tmp10);
      SetLength(_tmp10, _tmp13 + 1);
      _tmp10[_tmp13].Key := _tmp11;
      SetLength(_tmp10[_tmp13].Items, 0);
    end;
    SetLength(_tmp10[_tmp13].Items, Length(_tmp10[_tmp13].Items)+1);
    _tmp10[_tmp13].Items[High(_tmp10[_tmp13].Items)] := x;
  end;
  SetLength(_tmp16, 0);
  for _tmp15 in _tmp10 do
  begin
    _tmp17 := specialize TFPGMap<string, Variant>.Create;
    _tmp17.AddOrSetData('part', _tmp15.key);
    SetLength(_tmp18, 0);
    for r in _tmp15.Items do
    begin
      _tmp18 := Concat(_tmp18, [r.KeyData['value']]);
    end;
    _tmp17.AddOrSetData('total', specialize _sumList<Variant>(_tmp18));
    _tmp16 := Concat(_tmp16, [_tmp17]);
  end;
  grouped := _tmp16;
  specialize _printList<specialize TFPGMap<string, Variant>>(grouped);
end.
