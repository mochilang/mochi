(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (srfi 95) (chibi json) (chibi io) (chibi) (chibi string))

(define (_to_string v)
  (call-with-output-string (lambda (p) (write v p))))

(define (_yaml_value v)
  (let ((n (string->number v)))
    (if n n v)))

(define (_parse_yaml text)
  (let ((rows '()) (cur '()))
    (for-each (lambda (ln)
                (when (and (>= (string-length ln) 2) (string-prefix? "- " ln))
                  (when (not (null? cur))
                    (set! rows (append rows (list cur))))
                  (set! cur '())
                  (set! ln (substring ln 2 (string-length ln))))
                (when (string-contains ln ":")
                  (let* ((p (string-split ln #\:))
                         (k (string-trim (car p)))
                         (val (string-trim (string-join (cdr p) ":"))))
                    (set! cur (append cur (list (cons k (_yaml_value val))))))))
              (string-split text #\newline))
    (when (not (null? cur))
      (set! rows (append rows (list cur))))
    rows))

(define (_fetch url opts)
  (let* ((method (if (and opts (assq 'method opts)) (cdr (assq 'method opts)) "GET"))
         (args (list "curl" "-s" "-X" method)))
    (when (and opts (assq 'headers opts))
      (for-each (lambda (p)
                  (set! args (append args (list "-H" (format "~a: ~a" (car p) (cdr p))))))
                (cdr (assq 'headers opts))))
    (when (and opts (assq 'query opts))
      (let* ((q (cdr (assq 'query opts)))
             (qs (string-join (map (lambda (p) (format "~a=~a" (car p) (cdr p))) q) "&")))
        (set! url (string-append url (if (string-contains url "?") "&" "?") qs))))
    (when (and opts (assq 'body opts))
      (set! args (append args (list "-d" (json->string (cdr (assq 'body opts)))))))
    (when (and opts (assq 'timeout opts))
      (set! args (append args (list "--max-time" (format "~a" (cdr (assq 'timeout opts)))))))
    (set! args (append args (list url)))
    (let* ((p (open-input-pipe (string-join args " ")))
           (txt (port->string p)))
      (close-input-port p)
      (string->json txt))))

(define (_load path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (in (if (or (not path) (string=? path "") (string=? path "-"))
                 (current-input-port)
                 (open-input-file path)))
         (text (port->string in)))
    (when (not (eq? in (current-input-port)))
      (close-input-port in))
    (cond ((string=? fmt "jsonl")
           (map string->json
                (filter (lambda (l) (not (string=? l "")))
                        (string-split text #\newline))))
          ((string=? fmt "yaml")
           (_parse_yaml text))
          (else
           (let ((d (string->json text)))
             (if (list? d) d (list d)))))))

(define (_save rows path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (out (if (or (not path) (string=? path "") (string=? path "-"))
                  (current-output-port)
                  (open-output-file path))))
  (cond ((string=? fmt "jsonl")
           (for-each (lambda (r) (write-string (json->string r) out) (newline out)) rows))
          (else
           (write-string (json->string rows) out)))
    (when (not (eq? out (current-output-port)))
      (close-output-port out))))

(define (_date_number s)
  (let ((parts (string-split s #\-)))
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_lt a b)
  (cond
    ((and (number? a) (number? b)) (< a b))
    ((and (string? a) (string? b))
      (let ((da (_date_number a))
            (db (_date_number b)))
        (if (and da db)
            (< da db)
            (string<? a b))))
    ((and (pair? a) (pair? b))
      (cond
        ((null? a) (not (null? b)))
        ((null? b) #f)
        (else (let ((ka (car a)) (kb (car b)))
                (if (equal? ka kb)
                    (_lt (cdr a) (cdr b))
                    (_lt ka kb)))))
    )
    (else (string<? (_to_string a) (_to_string b)))))

(define (_sort pairs)
  (sort pairs (lambda (a b) (_lt (cdr a) (cdr b)))))
(define (_count v)
  (cond
    ((string? v) (string-length v))
    ((and (pair? v) (assq 'Items v)) (length (cdr (assq 'Items v))))
    ((list? v) (length v))
    (else 0)))

(define (_sum v)
  (let* ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
         (s (if (null? lst) 0 (apply + lst))))
    s))

(define (_avg v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (n 0))
    (set! n (length lst))
    (if (= n 0) 0 (/ (_sum lst) n)))
)

(define (_exists v)
  (cond
    ((and (pair? v) (assq 'Items v)) (not (null? (cdr (assq 'Items v)))))
    ((string? v) (> (string-length v) 0))
    ((list? v) (not (null? v)))
    (else #f)))

(define (_max v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (m 0))
    (when (not (null? lst))
      (set! m (car lst))
      (for-each (lambda (n)
                  (when (> n m) (set! m n)))
                (cdr lst)))
    m))

(define (_min v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (m 0))
    (when (not (null? lst))
      (set! m (car lst))
      (for-each (lambda (n)
                  (when (< n m) (set! m n)))
                (cdr lst)))
    m))
(define (_group_by src keyfn)
  (let ((groups '()) (order '()))
    (for-each (lambda (it)
                (let* ((key (keyfn it))
                       (ks (format "~a" key))
                       (pair (assoc ks groups)))
                  (if pair
                      (let* ((grp (cdr pair))
                             (items (cdr (assq 'Items grp))))
                        (set-cdr! (assq 'Items grp) (append items (list it))))
                      (begin
                        (set! groups (append groups (list (cons ks (list (cons 'key key) (cons 'Items (list it)))))))
                        (set! order (append order (list ks))))))
              src)
    (map (lambda (k) (cdr (assoc k groups))) order))))

(define nation (list (list (cons 'n_nationkey 1) (cons 'n_name "BRAZIL"))))
(define customer (list (list (cons 'c_custkey 1) (cons 'c_name "Alice") (cons 'c_acctbal 100.0) (cons 'c_nationkey 1) (cons 'c_address "123 St") (cons 'c_phone "123-456") (cons 'c_comment "Loyal"))))
(define orders (list (list (cons 'o_orderkey 1000) (cons 'o_custkey 1) (cons 'o_orderdate "1993-10-15")) (list (cons 'o_orderkey 2000) (cons 'o_custkey 1) (cons 'o_orderdate "1994-01-02"))))
(define lineitem (list (list (cons 'l_orderkey 1000) (cons 'l_returnflag "R") (cons 'l_extendedprice 1000.0) (cons 'l_discount 0.1)) (list (cons 'l_orderkey 2000) (cons 'l_returnflag "N") (cons 'l_extendedprice 500.0) (cons 'l_discount 0.0))))
(define start_date "1993-10-01")
(define end_date "1994-01-01")
(define result (let ((_tmp '()))
  (for-each (lambda (c)
    (for-each (lambda (o)
      (when (equal? (map-get o 'o_custkey) (map-get c 'c_custkey))
        (for-each (lambda (l)
          (when (equal? (map-get l 'l_orderkey) (map-get o 'o_orderkey))
            (for-each (lambda (n)
              (when (equal? (map-get n 'n_nationkey) (map-get c 'c_nationkey))
                (when (and (and (string>=? (map-get o 'o_orderdate) start_date) (string<? (map-get o 'o_orderdate) end_date)) (equal? (map-get l 'l_returnflag) "R"))
                  (set! _tmp (append _tmp (list c)))
                )
              )) (if (string? nation) (string->list nation) nation))
          )) (if (string? lineitem) (string->list lineitem) lineitem))
      )) (if (string? orders) (string->list orders) orders))
  ) (if (string? customer) (string->list customer) customer))
  (let ((_res '()))
    (for-each (lambda (g)
      (set! _res (append _res (list (list (cons 'c_custkey (map-get (map-get g 'key) 'c_custkey)) (cons 'c_name (map-get (map-get g 'key) 'c_name)) (cons 'revenue (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (* (map-get (map-get x 'l) 'l_extendedprice) (- 1 (map-get (map-get x 'l) 'l_discount))))))
  ) (if (string? g) (string->list g) g))
  _res))) (cons 'c_acctbal (map-get (map-get g 'key) 'c_acctbal)) (cons 'n_name (map-get (map-get g 'key) 'n_name)) (cons 'c_address (map-get (map-get g 'key) 'c_address)) (cons 'c_phone (map-get (map-get g 'key) 'c_phone)) (cons 'c_comment (map-get (map-get g 'key) 'c_comment))))))
    ) (_group_by _tmp (lambda (c) (list (cons 'c_custkey (map-get c 'c_custkey)) (cons 'c_name (map-get c 'c_name)) (cons 'c_acctbal (map-get c 'c_acctbal)) (cons 'c_address (map-get c 'c_address)) (cons 'c_phone (map-get c 'c_phone)) (cons 'c_comment (map-get c 'c_comment)) (cons 'n_name (map-get n 'n_name))))))
    (set! _res (_sort (map (lambda (x) (cons x (- (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (* (map-get (map-get x 'l) 'l_extendedprice) (- 1 (map-get (map-get x 'l) 'l_discount))))))
  ) (if (string? g) (string->list g) g))
  _res))))) _res)))
    (set! _res (map car _res))
    _res)))
(begin (display result) (newline))
