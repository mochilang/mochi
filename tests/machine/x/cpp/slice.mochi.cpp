// Generated by the Mochi experimental C++ compiler
#include <bits/stdc++.h>
using namespace std;

template<typename T, typename=void> struct has_size : false_type {};
template<typename T> struct has_size<T, void_t<decltype(declval<T>().size()), decltype(declval<T>()[0])>> : true_type {};

int main() {
	([&](const auto& __v){ if constexpr(has_size<decay_t<decltype(__v)>>::value){ for(size_t i=0;i<__v.size();++i){ if(i) cout<<' '; cout<<__v[i]; } cout<<endl; } else { cout<<__v<<endl; } })(([&](const auto& __v){ using V=decay_t<decltype(__v)>; if constexpr(is_same_v<V,string>) return __v.substr(1, 3-1); else return vector<typename V::value_type>(__v.begin()+1, __v.begin()+3); })(vector<int>{1, 2, 3}));
	([&](const auto& __v){ if constexpr(has_size<decay_t<decltype(__v)>>::value){ for(size_t i=0;i<__v.size();++i){ if(i) cout<<' '; cout<<__v[i]; } cout<<endl; } else { cout<<__v<<endl; } })(([&](const auto& __v){ using V=decay_t<decltype(__v)>; if constexpr(is_same_v<V,string>) return __v.substr(0, 2-0); else return vector<typename V::value_type>(__v.begin()+0, __v.begin()+2); })(vector<int>{1, 2, 3}));
	([&](const auto& __v){ if constexpr(has_size<decay_t<decltype(__v)>>::value){ for(size_t i=0;i<__v.size();++i){ if(i) cout<<' '; cout<<__v[i]; } cout<<endl; } else { cout<<__v<<endl; } })(([&](const auto& __v){ using V=decay_t<decltype(__v)>; if constexpr(is_same_v<V,string>) return __v.substr(1, 4-1); else return vector<typename V::value_type>(__v.begin()+1, __v.begin()+4); })(std::string("hello")));
	return 0;
}
