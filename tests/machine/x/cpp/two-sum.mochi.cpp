// Generated by the Mochi experimental C++ compiler
#include <bits/stdc++.h>
using namespace std;

template<typename T> vector<T> mochi_append(vector<T> v, T x) { v.push_back(x); return v; }
template<typename T> T mochi_sum(const vector<T>& v) { T s{}; for(const auto& x: v) s += x; return s; }
template<typename T> double mochi_avg(const vector<T>& v) { if(v.empty()) return 0; return static_cast<double>(mochi_sum(v)) / v.size(); }
template<typename T> void mochi_print(const T& v) { cout << v << endl; }
template<typename T> void mochi_print(const vector<T>& v) { for(size_t i=0;i<v.size();++i){ if(i) cout << ' '; cout << v[i]; } cout << endl; }
template<typename T> vector<T> mochi_slice(const vector<T>& v, int s, int e) { return vector<T>(v.begin()+s, v.begin()+e); }
inline string mochi_slice(const string& s, int st, int ed) { return s.substr(st, ed - st); }
template<typename T> bool mochi_contains(const vector<T>& v, const T& x) { return find(v.begin(), v.end(), x) != v.end(); }
inline bool mochi_contains(const string& s, const string& sub) { return s.find(sub) != string::npos; }

auto twoSum(auto nums, auto target) {
	auto n = ((int)nums.size());
	for(int i=0; i<n; ++i) {
		for(int j=(i + 1); j<n; ++j) {
			if(((nums[i] + nums[j]) == target)) {
				return vector<int>{i, j};
			}			
		}
	}
	return vector<int>{(-1), (-1)};
}

int main() {
	auto result = twoSum(vector<int>{2, 7, 11, 15}, 9);
	mochi_print(result[0]);
	mochi_print(result[1]);
	return 0;
}
