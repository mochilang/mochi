//go:build ignore

// Generated by Mochi compiler v0.10.27 on 1970-01-01T00:00:00Z

package main

import (
	"encoding/json"
	"fmt"
	"mochi/runtime/data"
	"os"
	"reflect"
	"strings"
)

type v = People

type People struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	people := []People{People{
		Name: "Alice",
		Age:  30,
	}, People{
		Name: "Bob",
		Age:  25,
	}}
	_save(people, "-", func() map[string]any {
		m := map[string]any{}
		_copyToMap(m, map[string]string{"format": "jsonl"})
		return m
	}())
}

func _convertMapAny(m map[any]any) map[string]any {
	out := make(map[string]any, len(m))
	for k, v := range m {
		key := fmt.Sprint(k)
		if sub, ok := v.(map[any]any); ok {
			out[key] = _convertMapAny(sub)
		} else {
			out[key] = v
		}
	}
	return out
}

func _copyToMap(dst map[string]any, src any) {
	switch m := src.(type) {
	case map[string]any:
		for k, v := range m {
			dst[k] = v
		}
	case map[string]string:
		for k, v := range m {
			dst[k] = v
		}
	case map[any]any:
		for k, v := range _convertMapAny(m) {
			dst[k] = v
		}
	default:
		rv := reflect.ValueOf(m)
		if rv.Kind() == reflect.Struct {
			rt := rv.Type()
			for i := 0; i < rv.NumField(); i++ {
				name := rt.Field(i).Name
				if tag := rt.Field(i).Tag.Get("json"); tag != "" {
					if c := strings.Index(tag, ","); c >= 0 {
						tag = tag[:c]
					}
					if tag != "-" {
						name = tag
					}
				}
				dst[name] = rv.Field(i).Interface()
			}
		}
	}
}

func _save(src any, path string, opts map[string]any) {
	rows, ok := _toMapSlice(src)
	if !ok {
		panic("save source must be list of maps")
	}
	format := "csv"
	header := false
	delim := ','
	if opts != nil {
		if f, ok := opts["format"].(string); ok {
			format = f
		}
		if h, ok := opts["header"].(bool); ok {
			header = h
		}
		if d, ok := opts["delimiter"].(string); ok && len(d) > 0 {
			delim = rune(d[0])
		}
	}
	var err error
	switch format {
	case "jsonl":
		if path == "" || path == "-" {
			err = data.SaveJSONLWriter(rows, os.Stdout)
		} else {
			err = data.SaveJSONL(rows, path)
		}
	case "json":
		if path == "" || path == "-" {
			err = data.SaveJSONWriter(rows, os.Stdout)
		} else {
			err = data.SaveJSON(rows, path)
		}
	case "yaml":
		if path == "" || path == "-" {
			err = data.SaveYAMLWriter(rows, os.Stdout)
		} else {
			err = data.SaveYAML(rows, path)
		}
	case "tsv":
		delim = '	'
		fallthrough
	default:
		if path == "" || path == "-" {
			err = data.SaveCSVWriter(rows, os.Stdout, header, delim)
		} else {
			err = data.SaveCSV(rows, path, header, delim)
		}
	}
	if err != nil {
		panic(err)
	}
}

func _toMapSlice(v any) ([]map[string]any, bool) {
	switch rows := v.(type) {
	case []map[string]any:
		return rows, true
	case []any:
		out := make([]map[string]any, len(rows))
		for i, item := range rows {
			m, ok := item.(map[string]any)
			if !ok {
				return nil, false
			}
			out[i] = m
		}
		return out, true
	}
	rv := reflect.ValueOf(v)
	if rv.Kind() == reflect.Slice {
		out := make([]map[string]any, rv.Len())
		for i := 0; i < rv.Len(); i++ {
			b, err := json.Marshal(rv.Index(i).Interface())
			if err != nil {
				return nil, false
			}
			var m map[string]any
			if err := json.Unmarshal(b, &m); err != nil {
				return nil, false
			}
			out[i] = m
		}
		return out, true
	}
	return nil, false
}
