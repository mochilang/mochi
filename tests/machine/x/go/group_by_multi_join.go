//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2025-07-16T15:34:01Z

package main

import (
	"fmt"
	"mochi/runtime/data"
	"strings"

	"golang.org/x/exp/constraints"
)

type Filtered struct {
	Part  int     `json:"part"`
	Value float64 `json:"value"`
}

type Grouped struct {
	Part  any     `json:"part"`
	Total float64 `json:"total"`
}

type Nation struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

type Partsupp struct {
	Part     int     `json:"part"`
	Supplier int     `json:"supplier"`
	Cost     float64 `json:"cost"`
	Qty      int     `json:"qty"`
}

type Supplier struct {
	ID     int `json:"id"`
	Nation int `json:"nation"`
}

type v map[string]any

func main() {
	nations := []Nation{Nation{
		ID:   1,
		Name: "A",
	}, Nation{
		ID:   2,
		Name: "B",
	}}
	suppliers := []Supplier{Supplier{
		ID:     1,
		Nation: 1,
	}, Supplier{
		ID:     2,
		Nation: 2,
	}}
	partsupp := []Partsupp{Partsupp{
		Part:     100,
		Supplier: 1,
		Cost:     10.0,
		Qty:      2,
	}, Partsupp{
		Part:     100,
		Supplier: 2,
		Cost:     20.0,
		Qty:      1,
	}, Partsupp{
		Part:     200,
		Supplier: 1,
		Cost:     5.0,
		Qty:      3,
	}}
	filtered := func() []Filtered {
		results := []Filtered{}
		for _, ps := range partsupp {
			for _, s := range suppliers {
				if !(s.ID == ps.Supplier) {
					continue
				}
				for _, n := range nations {
					if !(n.ID == s.Nation) {
						continue
					}
					if n.Name == "A" {
						if n.Name == "A" {
							results = append(results, Filtered{
								Part:  ps.Part,
								Value: (ps.Cost * float64(ps.Qty)),
							})
						}
					}
				}
			}
		}
		return results
	}()
	grouped := func() []Grouped {
		groups := map[string]*data.Group{}
		order := []string{}
		for _, x := range filtered {
			key := x.Part
			ks := fmt.Sprint(key)
			g, ok := groups[ks]
			if !ok {
				g = &data.Group{Key: key}
				groups[ks] = g
				order = append(order, ks)
			}
			g.Items = append(g.Items, x)
		}
		results := []Grouped{}
		for _, ks := range order {
			g := groups[ks]
			results = append(results, Grouped{
				Part: g.Key.(any),
				Total: _sumOrdered[float64](func() []float64 {
					results := []float64{}
					for _, rRaw := range g.Items {
						r := rRaw.(Filtered)
						results = append(results, r.Value)
					}
					return results
				}()),
			})
		}
		return results
	}()
	fmt.Println(strings.TrimSpace(strings.Join([]string{strings.Trim(strings.Trim(fmt.Sprint(grouped), "[]"), " ")}, " ")))
}

func _sumOrdered[T constraints.Integer | constraints.Float](s []T) float64 {
	var sum float64
	for _, v := range s {
		sum += float64(v)
	}
	return sum
}
