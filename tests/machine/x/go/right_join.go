//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2025-07-18T07:38:05Z

package main

import (
	"fmt"
	"strings"
)

type v = Result

type Customer struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

type Order struct {
	ID         int `json:"id"`
	CustomerID int `json:"customerId"`
	Total      int `json:"total"`
}

type Result struct {
	CustomerName string `json:"customerName"`
	Order        *Order `json:"order"`
}

func main() {
	customers := []Customer{
		Customer{
			ID:   1,
			Name: "Alice",
		},
		Customer{
			ID:   2,
			Name: "Bob",
		},
		Customer{
			ID:   3,
			Name: "Charlie",
		},
		Customer{
			ID:   4,
			Name: "Diana",
		},
	}
	orders := []Order{Order{
		ID:         100,
		CustomerID: 1,
		Total:      250,
	}, Order{
		ID:         101,
		CustomerID: 2,
		Total:      125,
	}, Order{
		ID:         102,
		CustomerID: 1,
		Total:      300,
	}}
	result := func() []Result {
		results := []Result{}
		for _, c := range customers {
			matched := false
			for _, o := range _addrSlice[Order](orders) {
				if !(o.CustomerID == c.ID) {
					continue
				}
				matched = true
				results = append(results, Result{
					CustomerName: c.Name,
					Order:        o,
				})
			}
			if !matched {
				var o *Order
				results = append(results, Result{
					CustomerName: c.Name,
					Order:        o,
				})
			}
		}
		return results
	}()
	fmt.Println(strings.TrimSpace(fmt.Sprintln(any("--- Right Join using syntax ---"))))
	for _, entry := range result {
		if entry.Order != nil {
			fmt.Println(strings.TrimSpace(fmt.Sprintln(any("Customer"), entry.CustomerName, "has order", entry.Order.ID, "- $", entry.Order.Total)))
		} else {
			fmt.Println(strings.TrimSpace(fmt.Sprintln(any("Customer"), entry.CustomerName, "has no orders")))
		}
	}
}

func _addrSlice[T any](s []T) []*T {
	out := make([]*T, len(s))
	for i := range s {
		out[i] = &s[i]
	}
	return out
}
