//go:build ignore

// Generated by Mochi compiler v0.10.27 on 1970-01-01T00:00:00Z

package main

import (
	"fmt"
	"reflect"
	"strings"
)

type v = Result

type Customer struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

type Order struct {
	ID         int `json:"id"`
	CustomerID int `json:"customerId"`
	Total      int `json:"total"`
}

type Result struct {
	OrderID  int      `json:"orderId"`
	Customer Customer `json:"customer"`
	Total    int      `json:"total"`
}

func main() {
	customers := []Customer{Customer{
		ID:   1,
		Name: "Alice",
	}, Customer{
		ID:   2,
		Name: "Bob",
	}}
	orders := []Order{Order{
		ID:         100,
		CustomerID: 1,
		Total:      250,
	}, Order{
		ID:         101,
		CustomerID: 3,
		Total:      80,
	}}
	result := func() []Result {
		customerMap := make(map[int]*Customer)
		for _, c := range customers {
			customerMap[_getField(c, "id")] = c
		}
		var result []Result
		for _, o := range orders {
			r := Result{OrderID: o.ID, Total: o.Total}
			if v, ok := customerMap[o.CustomerID]; ok {
				r.Customer = &v
			} else {
				r.Customer = nil
			}
			result = append(result, r)
		}
		return result
	}()
	fmt.Println(strings.TrimSpace(fmt.Sprintln("--- Left Join ---")))
	for _, entry := range result {
		if entry.Customer != nil {
			fmt.Printf("Order %d customer {id: %d, name: %q} total %d\n", entry.OrderID, entry.Customer.ID, entry.Customer.Name, entry.Total)
		} else {
			fmt.Printf("Order %d customer <nil> total %d\n", entry.OrderID, entry.Total)
		}
	}
}

func _convertMapAny(m map[any]any) map[string]any {
	out := make(map[string]any, len(m))
	for k, v := range m {
		key := fmt.Sprint(k)
		if sub, ok := v.(map[any]any); ok {
			out[key] = _convertMapAny(sub)
		} else {
			out[key] = v
		}
	}
	return out
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}

func _getField(v any, name string) any {
	switch m := v.(type) {
	case map[string]any:
		return m[name]
	case map[string]string:
		if s, ok := m[name]; ok {
			return s
		}
	case map[any]any:
		return _convertMapAny(m)[name]
	default:
		rv := reflect.ValueOf(m)
		if rv.Kind() == reflect.Struct {
			rt := rv.Type()
			for i := 0; i < rv.NumField(); i++ {
				fn := rt.Field(i)
				field := fn.Name
				if tag := fn.Tag.Get("json"); tag != "" {
					if c := strings.Index(tag, ","); c >= 0 {
						tag = tag[:c]
					}
					if tag != "-" {
						field = tag
					}
				}
				if field == name {
					return rv.Field(i).Interface()
				}
			}
		}
	}
	return nil
}
