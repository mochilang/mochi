// Generated by Mochi compiler v0.10.27 on 1970-01-01T00:00:00Z
fn _union<T: Eq + std::hash::Hash + Clone + Ord>(a: Vec<T>, b: Vec<T>) -> Vec<T> {
    use std::collections::HashSet;
    let mut set: HashSet<T> = a.into_iter().collect();
    set.extend(b.into_iter());
    let mut v: Vec<T> = set.into_iter().collect();
    v.sort();
    v
}

fn _union_all<T: Clone>(mut a: Vec<T>, b: Vec<T>) -> Vec<T> {
    a.extend(b);
    a
}

fn _except<T: Eq + std::hash::Hash + Clone>(a: Vec<T>, b: Vec<T>) -> Vec<T> {
    use std::collections::HashSet;
    let set: HashSet<T> = b.into_iter().collect();
    a.into_iter().filter(|x| !set.contains(x)).collect()
}

fn _intersect<T: Eq + std::hash::Hash + Clone>(a: Vec<T>, b: Vec<T>) -> Vec<T> {
    use std::collections::HashSet;
    let set: HashSet<T> = b.into_iter().collect();
    a.into_iter().filter(|x| set.contains(x)).collect()
}

fn main() {
    { for (i, it) in _union(vec![1, 2], vec![2, 3]).iter().enumerate() { if i > 0 { print!(" "); } print!("{}", it); } println!(); };
    { for (i, it) in _except(vec![1, 2, 3], vec![2]).iter().enumerate() { if i > 0 { print!(" "); } print!("{}", it); } println!(); };
    { for (i, it) in _intersect(vec![1, 2, 3], vec![2, 4]).iter().enumerate() { if i > 0 { print!(" "); } print!("{}", it); } println!(); };
    println!("{}", vec![format!("{}", _union_all(vec![1, 2], vec![2, 3]).len() as i32)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
}
