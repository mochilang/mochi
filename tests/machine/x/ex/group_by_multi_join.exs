# Generated by Mochi Elixir compiler
defmodule Main do
  @nations [%{id: 1, name: "A"}, %{id: 2, name: "B"}]
  @suppliers [%{id: 1, nation: 1}, %{id: 2, nation: 2}]
  @partsupp [
    %{part: 100, supplier: 1, cost: 10, qty: 2},
    %{part: 100, supplier: 2, cost: 20, qty: 1},
    %{part: 200, supplier: 1, cost: 5, qty: 3}
  ]
  def main do
    # filtered :: list(map())
    filtered =
      for ps <- @partsupp,
          s <- @suppliers,
          n <- @nations,
          s.id == ps.supplier && n.id == s.nation && n.name == "A",
          do: %{part: ps.part, value: ps.cost * ps.qty}

    # grouped :: list(map())
    grouped =
      Enum.map(_group_by(filtered, fn x -> x.part end), fn g ->
        %{part: g.key, total: _sum(for r <- g.items, do: r.value)}
      end)

    IO.inspect(grouped)
  end

  defmodule Group do
    defstruct key: nil, items: []

    def fetch(g, k) do
      case k do
        :key -> {:ok, g.key}
        :items -> {:ok, g.items}
        _ -> :error
      end
    end

    def get_and_update(g, k, f) do
      case k do
        :key ->
          {v, nv} = f.(g.key)
          {v, %{g | key: nv}}

        :items ->
          {v, nv} = f.(g.items)
          {v, %{g | items: nv}}

        _ ->
          {nil, g}
      end
    end
  end

  defp _group_by(src, keyfn) do
    {groups, order} =
      Enum.reduce(src, {%{}, []}, fn it, {groups, order} ->
        key =
          if is_list(it) do
            arity = :erlang.fun_info(keyfn, :arity) |> elem(1)
            if arity == 1, do: keyfn.(it), else: apply(keyfn, it)
          else
            keyfn.(it)
          end

        ks = :erlang.phash2(key)

        {groups, order} =
          if Map.has_key?(groups, ks) do
            {groups, order}
          else
            {Map.put(groups, ks, %Group{key: key}), order ++ [ks]}
          end

        val = if is_list(it) and length(it) == 1, do: hd(it), else: it
        groups = Map.update!(groups, ks, fn g -> %{g | items: g.items ++ [val]} end)
        {groups, order}
      end)

    Enum.map(order, fn k -> groups[k] end)
  end

  defp _sum(v) do
    list =
      cond do
        is_map(v) and Map.has_key?(v, :items) -> Map.get(v, :items)
        is_list(v) -> v
        true -> raise "sum() expects list or group"
      end

    Enum.sum(list)
  end
end

Main.main()
