# Generated by Mochi Elixir compiler
defmodule Main do
  def main do
    # data :: list(map())
    data = [%{tag: "a", val: 1}, %{tag: "a", val: 2}, %{tag: "b", val: 3}]
    # groups :: list(any())
    groups = Enum.map(_group_by(data, fn d -> d.tag end), fn g -> g end)
    # tmp :: list(any())
    tmp = []
    _ = tmp

    {tmp} =
      Enum.reduce(groups, {tmp}, fn g, {tmp} ->
        total = 0
        _ = total

        {total} =
          Enum.reduce(_iter(g.items), {total}, fn x, {total} ->
            total = total + x.val
            {:cont, {total}}
          end)

        _ = total
        tmp = tmp ++ [%{tag: g.key, total: total}]
        {:cont, {tmp}}
      end)

    _ = tmp
    # result :: list(any())
    result = for r <- Enum.sort_by(tmp, fn r -> r.tag end), do: r
    IO.puts(result)
  end

  defmodule Group do
    defstruct key: nil, items: []
  end

  defp _group_by(src, keyfn) do
    {groups, order} =
      Enum.reduce(src, {%{}, []}, fn it, {groups, order} ->
        key = keyfn.(it)
        ks = :erlang.phash2(key)

        {groups, order} =
          if Map.has_key?(groups, ks) do
            {groups, order}
          else
            {Map.put(groups, ks, %Group{key: key}), order ++ [ks]}
          end

        groups = Map.update!(groups, ks, fn g -> %{g | items: g.items ++ [it]} end)
        {groups, order}
      end)

    Enum.map(order, fn k -> groups[k] end)
  end

  defp _iter(v) do
    if is_map(v) do
      Map.keys(v)
    else
      v
    end
  end
end

Main.main()
