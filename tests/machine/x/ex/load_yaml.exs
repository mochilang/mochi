# Generated by Mochi compiler v0.10.26 on 2025-07-16T17:14:43Z
defmodule Main do
  def main do
    # people :: list(Person)
    people =
      Enum.map(
        _load("tests/interpreter/valid/people.yaml", %{format: "yaml"}),
        &_structify(Person, &1)
      )

    # adults :: list(map())
    adults = for p <- people, p.age >= 18, do: %{name: p.name, email: p.email}

    for a <- adults do
      IO.puts(Enum.join(Enum.map([a.name, a.email], &inspect(&1)), " "))
    end
  end

  defp _load(path, opts \\ nil) do
    format = if opts, do: Map.get(opts, "format", "csv"), else: "csv"
    header = if opts && Map.has_key?(opts, "header"), do: opts["header"], else: true

    delim =
      if opts && Map.has_key?(opts, "delimiter"),
        do: String.first(to_string(opts["delimiter"] || ",")),
        else: ","

    text =
      case path do
        nil -> IO.read(:stdio, :eof)
        "" -> IO.read(:stdio, :eof)
        "-" -> IO.read(:stdio, :eof)
        _ -> File.read!(path)
      end

    case format do
      "jsonl" ->
        String.trim(text) |> String.split(~r/\r?\n/, trim: true) |> Enum.map(&Jason.decode!/1)

      "json" ->
        case Jason.decode!(text) do
          list when is_list(list) -> list
          obj -> [obj]
        end

      "yaml" ->
        _parse_yaml(text)

      "tsv" ->
        _parse_csv(text, header, "	")

      _ ->
        _parse_csv(text, header, delim)
    end
  end

  defp _parse_csv(text, header, delim) do
    lines = text |> String.trim() |> String.split(~r/\r?\n/, trim: true)

    if lines == [] do
      []
    else
      {headers, start} =
        if header do
          {String.split(hd(lines), delim), 1}
        else
          cols = String.split(hd(lines), delim)
          {Enum.map(0..(length(cols) - 1), fn i -> "c" <> Integer.to_string(i) end), 0}
        end

      Enum.drop(lines, start)
      |> Enum.map(fn line ->
        parts = String.split(line, delim)

        Enum.with_index(headers)
        |> Enum.reduce(%{}, fn {h, i}, acc ->
          val = if i < length(parts), do: Enum.at(parts, i), else: ""

          value =
            case Integer.parse(val) do
              {int, ""} ->
                int

              _ ->
                case Float.parse(val) do
                  {f, ""} -> f
                  _ -> val
                end
            end

          Map.put(acc, h, value)
        end)
      end)
    end
  end

  defp _parse_yaml(text) do
    lines = String.split(String.trim(text), ~r/\r?\n/)

    {rows, cur} =
      Enum.reduce(lines, {[], %{}}, fn line, {rows, cur} ->
        line = String.trim(line)

        cond do
          String.starts_with?(line, "-") ->
            rows = if map_size(cur) > 0, do: rows ++ [cur], else: rows
            cur = %{}
            rest = String.trim_leading(line, "-") |> String.trim()

            cur =
              if rest != "" and String.contains?(rest, ":") do
                [k, v] = String.split(rest, ":", parts: 2)
                Map.put(cur, String.trim(k), _yaml_value(String.trim(v)))
              else
                cur
              end

            {rows, cur}

          String.contains?(line, ":") ->
            [k, v] = String.split(line, ":", parts: 2)
            {rows, Map.put(cur, String.trim(k), _yaml_value(String.trim(v)))}

          true ->
            {rows, cur}
        end
      end)

    rows = if map_size(cur) > 0, do: rows ++ [cur], else: rows
    rows
  end

  defp _structify(mod, v) do
    cond do
      is_struct(v) ->
        v

      is_map(v) ->
        m =
          Enum.reduce(v, %{}, fn {k, val}, acc ->
            Map.put(acc, String.to_atom(to_string(k)), _structify(nil, val))
          end)

        if mod, do: struct(mod, m), else: m

      is_list(v) ->
        Enum.map(v, &_structify(nil, &1))

      true ->
        v
    end
  end

  defp _yaml_value(v) do
    case Integer.parse(v) do
      {i, ""} ->
        i

      _ ->
        case Float.parse(v) do
          {f, ""} -> f
          _ -> v
        end
    end
  end
end

Main.main()
