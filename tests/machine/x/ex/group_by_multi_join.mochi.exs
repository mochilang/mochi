# Generated by Mochi Elixir compiler
defmodule Main do
  def main do
    # nations :: list(map())
    nations = [%{id: 1, name: "A"}, %{id: 2, name: "B"}]
    # suppliers :: list(map())
    suppliers = [%{id: 1, nation: 1}, %{id: 2, nation: 2}]
    # partsupp :: list(map())
    partsupp = [
      %{part: 100, supplier: 1, cost: 10, qty: 2},
      %{part: 100, supplier: 2, cost: 20, qty: 1},
      %{part: 200, supplier: 1, cost: 5, qty: 3}
    ]

    # filtered :: list(map())
    filtered =
      for ps <- partsupp,
          s <- suppliers,
          n <- nations,
          s.id == ps.supplier && n.id == s.nation && n.name == "A",
          do: %{part: ps.part, value: ps.cost * ps.qty}

    # grouped :: list(map())
    grouped =
      Enum.map(_group_by(filtered, fn x -> x.part end), fn g ->
        %{part: g.key, total: _sum(for r <- g.items, do: r.value)}
      end)

    IO.puts(grouped)
  end

  defmodule Group do
    defstruct key: nil, items: []
  end

  defp _group_by(src, keyfn) do
    {groups, order} =
      Enum.reduce(src, {%{}, []}, fn it, {groups, order} ->
        key = keyfn.(it)
        ks = :erlang.phash2(key)

        {groups, order} =
          if Map.has_key?(groups, ks) do
            {groups, order}
          else
            {Map.put(groups, ks, %Group{key: key}), order ++ [ks]}
          end

        groups = Map.update!(groups, ks, fn g -> %{g | items: g.items ++ [it]} end)
        {groups, order}
      end)

    Enum.map(order, fn k -> groups[k] end)
  end

  defp _sum(v) do
    list =
      cond do
        is_map(v) and Map.has_key?(v, :items) -> v[:items]
        is_list(v) -> v
        true -> raise "sum() expects list or group"
      end

    Enum.sum(list)
  end
end

Main.main()
