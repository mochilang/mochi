# Generated by Mochi Elixir compiler
defmodule Main do
  def main do
    # people :: list(map())
    people = [
      %{name: "Alice", age: 30, city: "Paris"},
      %{name: "Bob", age: 15, city: "Hanoi"},
      %{name: "Charlie", age: 65, city: "Paris"},
      %{name: "Diana", age: 45, city: "Hanoi"},
      %{name: "Eve", age: 70, city: "Paris"},
      %{name: "Frank", age: 22, city: "Hanoi"}
    ]

    # stats :: list(map())
    stats =
      Enum.map(_group_by(people, fn person -> person.city end), fn g ->
        %{city: g.key, count: _count(g), avg_age: _avg(for p <- g.items, do: p.age)}
      end)

    IO.inspect("--- People grouped by city ---")

    for s <- stats do
      IO.puts(
        Enum.join(
          Enum.map([s.city, ": count =", s.count, ", avg_age =", s.avg_age], &to_string(&1)),
          " "
        )
      )
    end
  end

  defp _avg(v) do
    list =
      cond do
        is_map(v) and Map.has_key?(v, :items) -> v[:items]
        is_list(v) -> v
        true -> raise "avg() expects list or group"
      end

    if Enum.count(list) == 0 do
      0
    else
      Enum.sum(list) / Enum.count(list)
    end
  end

  defp _count(v) do
    cond do
      is_list(v) -> length(v)
      is_map(v) and Map.has_key?(v, :items) -> length(v[:items])
      true -> raise "count() expects list or group"
    end
  end

  defmodule Group do
    defstruct key: nil, items: []
  end

  defp _group_by(src, keyfn) do
    {groups, order} =
      Enum.reduce(src, {%{}, []}, fn it, {groups, order} ->
        key = keyfn.(it)
        ks = :erlang.phash2(key)

        {groups, order} =
          if Map.has_key?(groups, ks) do
            {groups, order}
          else
            {Map.put(groups, ks, %Group{key: key}), order ++ [ks]}
          end

        groups = Map.update!(groups, ks, fn g -> %{g | items: g.items ++ [it]} end)
        {groups, order}
      end)

    Enum.map(order, fn k -> groups[k] end)
  end
end

Main.main()
