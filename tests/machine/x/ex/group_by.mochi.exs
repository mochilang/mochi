# Generated by Mochi Elixir compiler
defmodule Main do
  def main do
    # people :: list(map())
    people = [
      %{name: "Alice", age: 30, city: "Paris"},
      %{name: "Bob", age: 15, city: "Hanoi"},
      %{name: "Charlie", age: 65, city: "Paris"},
      %{name: "Diana", age: 45, city: "Hanoi"},
      %{name: "Eve", age: 70, city: "Paris"},
      %{name: "Frank", age: 22, city: "Hanoi"}
    ]

    # stats :: list(map())
    stats =
      Enum.map(_group_by(people, fn person -> person.city end), fn g ->
        %{city: g.key, count: _count(g), avg_age: _avg(for p <- g.items, do: p.age)}
      end)

    IO.inspect("--- People grouped by city ---")

    for s <- stats do
      IO.puts(
        Enum.join(
          Enum.map([s.city, ": count =", s.count, ", avg_age =", s.avg_age], &inspect(&1)),
          " "
        )
      )
    end
  end

  defp _avg(v) do
    list =
      cond do
        is_map(v) and Map.has_key?(v, :items) -> Map.get(v, :items)
        is_list(v) -> v
        true -> raise "avg() expects list or group"
      end

    if Enum.count(list) == 0 do
      0
    else
      Enum.sum(list) / Enum.count(list)
    end
  end

  defp _count(v) do
    cond do
      is_list(v) -> length(v)
      is_map(v) and Map.has_key?(v, :items) -> length(Map.get(v, :items))
      true -> raise "count() expects list or group"
    end
  end

  defmodule Group do
    defstruct key: nil, items: []

    def fetch(g, k) do
      case k do
        :key -> {:ok, g.key}
        :items -> {:ok, g.items}
        _ -> :error
      end
    end

    def get_and_update(g, k, f) do
      case k do
        :key ->
          {v, nv} = f.(g.key)
          {v, %{g | key: nv}}

        :items ->
          {v, nv} = f.(g.items)
          {v, %{g | items: nv}}

        _ ->
          {nil, g}
      end
    end
  end

  defp _group_by(src, keyfn) do
    {groups, order} =
      Enum.reduce(src, {%{}, []}, fn it, {groups, order} ->
        key =
          if is_list(it) do
            arity = :erlang.fun_info(keyfn, :arity) |> elem(1)
            if arity == 1, do: keyfn.(it), else: apply(keyfn, it)
          else
            keyfn.(it)
          end

        ks = :erlang.phash2(key)

        {groups, order} =
          if Map.has_key?(groups, ks) do
            {groups, order}
          else
            {Map.put(groups, ks, %Group{key: key}), order ++ [ks]}
          end

        val = if is_list(it) and length(it) == 1, do: hd(it), else: it
        groups = Map.update!(groups, ks, fn g -> %{g | items: g.items ++ [val]} end)
        {groups, order}
      end)

    Enum.map(order, fn k -> groups[k] end)
  end
end

Main.main()
