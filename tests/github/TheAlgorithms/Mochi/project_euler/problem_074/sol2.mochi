/*
Solve Project Euler Problem 74: digit factorial chains.

For any starting number, repeatedly replace the number with the sum of the
factorials of its digits. Every starting number eventually falls into a loop.
This program counts how many starting numbers below one million produce chains
with exactly sixty non-repeating terms.

Algorithm:
1. Precompute factorials for digits 0-9.
2. For each starting number from 1 to the limit (exclusive), build its chain by
   repeatedly applying the digit factorial sum until a number repeats or the
   chain exceeds the desired length.
3. Count chains whose length matches the target.
*/

let DIGIT_FACTORIAL: list<int> = [
  1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880,
]

fun digit_factorial_sum(number: int): int {
  if number < 0 {
    panic("Parameter number must be greater than or equal to 0")
  }
  if number == 0 {
    return DIGIT_FACTORIAL[0]
  }
  var n = number
  var total = 0
  while n > 0 {
    let digit = n % 10
    total = total + DIGIT_FACTORIAL[digit]
    n = n / 10
  }
  return total
}

fun chain_len(n: int, limit: int): int {
  var seen: map<int, bool> = {}
  var length = 0
  var cur = n
  while (cur in seen) == false && length <= limit {
    seen[cur] = true
    length = length + 1
    cur = digit_factorial_sum(cur)
  }
  return length
}

fun solution(chain_length: int, number_limit: int): int {
  if chain_length <= 0 || number_limit <= 0 {
    panic("Parameters chain_length and number_limit must be greater than 0")
  }
  var count = 0
  var start = 1
  while start < number_limit {
    if chain_len(start, chain_length) == chain_length {
      count = count + 1
    }
    start = start + 1
  }
  return count
}

print(str(solution(60, 1000000)))
