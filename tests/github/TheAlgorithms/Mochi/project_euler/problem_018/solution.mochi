/*
Project Euler Problem 18: Maximum Path Sum I

Given a triangle of positive integers, find the maximum total from top
to bottom. At each step you may move to adjacent numbers on the row
below. The algorithm processes the triangle row by row, adding to each
cell the maximum of the two possible parents from the previous row. The
maximum value in the final row is the answer.

Time complexity: O(n^2) for n rows.
Space complexity: O(n^2) to store the triangle.
*/

fun solution(): int {
  let triangle: list<list<int>> = [
    [75],
    [95, 64],
    [17, 47, 82],
    [18, 35, 87, 10],
    [20, 4, 82, 47, 65],
    [19, 1, 23, 75, 3, 34],
    [88, 2, 77, 73, 7, 63, 67],
    [99, 65, 4, 28, 6, 16, 70, 92],
    [41, 41, 26, 56, 83, 40, 80, 70, 33],
    [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
    [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
    [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
    [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
    [63, 66, 4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
    [4, 62, 98, 27, 23, 9, 70, 98, 73, 93, 38, 53, 60, 4, 23]
  ]

  var i = 1
  while i < len(triangle) {
    var j = 0
    while j < len(triangle[i]) {
      let prev_row = triangle[i - 1]
      let number1 = if j != len(prev_row) { prev_row[j] } else { 0 }
      let number2 = if j > 0 { prev_row[j - 1] } else { 0 }
      let max_val = if number1 > number2 { number1 } else { number2 }
      triangle[i][j] = triangle[i][j] + max_val
      j = j + 1
    }
    i = i + 1
  }

  let last = triangle[len(triangle) - 1]
  var k = 0
  var best = 0
  while k < len(last) {
    if last[k] > best {
      best = last[k]
    }
    k = k + 1
  }
  return best
}

print(str(solution()))
