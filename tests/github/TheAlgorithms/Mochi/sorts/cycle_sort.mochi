/*
Cycle sort implementation that minimizes memory writes.

For each position `cycle_start`, the algorithm counts how many elements are
smaller than the current `item` to determine its correct index `pos`.
If the item is already in place, it moves to the next cycle.
Otherwise it swaps the item into `pos` and continues rotating the remaining
cycle until returning to the starting index.

This in-place algorithm runs in O(n^2) time but performs as few writes as
possible.
*/

fun cycle_sort(array: list<float>): list<float> {
  let array_len = len(array)
  var cycle_start = 0
  while cycle_start < array_len - 1 {
    var item = array[cycle_start]
    var pos = cycle_start
    var i = cycle_start + 1
    while i < array_len {
      if array[i] < item {
        pos = pos + 1
      }
      i = i + 1
    }
    if pos == cycle_start {
      cycle_start = cycle_start + 1
      continue
    }
    while item == array[pos] {
      pos = pos + 1
    }
    let temp = array[pos]
    array[pos] = item
    item = temp
    while pos != cycle_start {
      pos = cycle_start
      i = cycle_start + 1
      while i < array_len {
        if array[i] < item {
          pos = pos + 1
        }
        i = i + 1
      }
      while item == array[pos] {
        pos = pos + 1
      }
      let temp2 = array[pos]
      array[pos] = item
      item = temp2
    }
    cycle_start = cycle_start + 1
  }
  return array
}

print(str(cycle_sort([4.0, 3.0, 2.0, 1.0])))
print(str(cycle_sort([-4.0, 20.0, 0.0, -50.0, 100.0, -1.0])))
print(str(cycle_sort([-0.1, -0.2, 1.3, -0.8])))
print(str(cycle_sort([])))
