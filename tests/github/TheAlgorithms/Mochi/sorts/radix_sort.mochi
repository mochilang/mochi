/*
Radix Sort (LSD) for Non-negative Integers

Given a list of non-negative integers, radix sort groups numbers by each digit
starting from the least significant digit and moving toward the most significant.
For each digit position, numbers are placed into 10 buckets (base 10) depending
on the current digit. After distributing all numbers, the buckets are
concatenated to form the list for the next pass. The process repeats until
the highest digit place of the maximum number has been processed.

Time Complexity: O(d * (n + RADIX)) where d is number of digits and n is list size.
Space Complexity: O(n + RADIX).
This implementation mirrors TheAlgorithms/Python version but uses Mochi lists
and loops without any external dependencies.
*/

let RADIX = 10

fun make_buckets(): list<list<int>> {
  var buckets: list<list<int>> = []
  var i = 0
  while i < RADIX {
    buckets = append(buckets, [])
    i = i + 1
  }
  return buckets
}

fun max_value(xs: list<int>): int {
  var max_val = xs[0]
  var i = 1
  while i < len(xs) {
    if xs[i] > max_val {
      max_val = xs[i]
    }
    i = i + 1
  }
  return max_val
}

fun radix_sort(list_of_ints: list<int>): list<int> {
  var placement = 1
  let max_digit = max_value(list_of_ints)
  while placement <= max_digit {
    var buckets = make_buckets()
    var i = 0
    while i < len(list_of_ints) {
      let value = list_of_ints[i]
      let tmp = (value / placement) % RADIX
      buckets[tmp] = append(buckets[tmp], value)
      i = i + 1
    }
    var a = 0
    var b = 0
    while b < RADIX {
      var bucket = buckets[b]
      var j = 0
      while j < len(bucket) {
        list_of_ints[a] = bucket[j]
        a = a + 1
        j = j + 1
      }
      b = b + 1
    }
    placement = placement * RADIX
  }
  return list_of_ints
}

print(str(radix_sort([0, 5, 3, 2, 2])))
print(str(radix_sort([1, 100, 10, 1000])))
print(str(radix_sort([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])))
