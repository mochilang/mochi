/*
Sort a list using a simplified form of TimSort.

The algorithm partitions the input into ascending runs, sorts each run using
insertion sort, and merges the sorted runs.

Steps:
1. Scan the input to split it into monotonically nondecreasing runs.
2. Sort each run with insertion sort.
3. Merge the sorted runs sequentially into the final sorted array.

This implementation works on lists of integers. Time complexity is
O(n log n) in the worst case with O(n) extra space for intermediate lists.
*/

fun copy_list(xs: list<int>): list<int> {
  var res: list<int> = []
  var k = 0
  while k < len(xs) {
    res = append(res, xs[k])
    k = k + 1
  }
  return res
}

fun insertion_sort(xs: list<int>): list<int> {
  var arr = copy_list(xs)
  var idx = 1
  while idx < len(arr) {
    let value = arr[idx]
    var jdx = idx - 1
    while jdx >= 0 && arr[jdx] > value {
      arr[jdx + 1] = arr[jdx]
      jdx = jdx - 1
    }
    arr[jdx + 1] = value
    idx = idx + 1
  }
  return arr
}

fun merge(left: list<int>, right: list<int>): list<int> {
  var result: list<int> = []
  var i = 0
  var j = 0
  while i < len(left) && j < len(right) {
    if left[i] < right[j] {
      result = append(result, left[i])
      i = i + 1
    } else {
      result = append(result, right[j])
      j = j + 1
    }
  }
  while i < len(left) {
    result = append(result, left[i])
    i = i + 1
  }
  while j < len(right) {
    result = append(result, right[j])
    j = j + 1
  }
  return result
}

fun tim_sort(xs: list<int>): list<int> {
  let n = len(xs)
  var runs: list<list<int>> = []
  var sorted_runs: list<list<int>> = []
  var current: list<int> = []
  current = append(current, xs[0])
  var i = 1
  while i < n {
    if xs[i] < xs[i - 1] {
      runs = append(runs, copy_list(current))
      current = []
      current = append(current, xs[i])
    } else {
      current = append(current, xs[i])
    }
    i = i + 1
  }
  runs = append(runs, copy_list(current))
  var r = 0
  while r < len(runs) {
    sorted_runs = append(sorted_runs, insertion_sort(runs[r]))
    r = r + 1
  }
  var result: list<int> = []
  r = 0
  while r < len(sorted_runs) {
    result = merge(result, sorted_runs[r])
    r = r + 1
  }
  return result
}

fun list_to_string(xs: list<int>): string {
  var s = "["
  var k = 0
  while k < len(xs) {
    s = s + str(xs[k])
    if k < len(xs) - 1 { s = s + ", " }
    k = k + 1
  }
  return s + "]"
}

let sample = [5, 9, 10, 3, -4, 5, 178, 92, 46, -18, 0, 7]
let sorted_sample = tim_sort(sample)
print(list_to_string(sorted_sample))

let sample2 = [3, 2, 1]
let sorted_sample2 = tim_sort(sample2)
print(list_to_string(sorted_sample2))
