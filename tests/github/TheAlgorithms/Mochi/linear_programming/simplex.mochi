/*
Simplex Algorithm Solver

Implements the simplex algorithm for linear programming in standard form:
maximize c^T x subject to Ax <= b and x >= 0. The input is a tableau matrix
where the first row encodes the negated objective function and each
subsequent row encodes a constraint with slack variables.
The algorithm iteratively chooses a pivot column with the most negative
coefficient in the objective row, selects a pivot row via the minimum
ratio test, and performs row operations until all objective coefficients
are non-negative. The final tableau gives the optimal solution.

Example: maximize x1 + x2 subject to
  x1 + 3x2 <= 4
  3x1 + x2 <= 4
The initial tableau is:
  [-1, -1, 0, 0, 0]
  [ 1,  3, 1, 0, 4]
  [ 3,  1, 0, 1, 4]
Running simplex prints the optimal value and variable assignments.
*/

fun pivot(t: list<list<float>>, row: int, col: int): list<list<float>> {
  var pivotRow: list<float> = []
  let pivotVal = t[row][col]
  for j in 0..len(t[row]) {
    pivotRow = append(pivotRow, t[row][j] / pivotVal)
  }
  t[row] = pivotRow
  for i in 0..len(t) {
    if i != row {
      let factor = t[i][col]
      var newRow: list<float> = []
      for j in 0..len(t[i]) {
        let value = t[i][j] - factor * pivotRow[j]
        newRow = append(newRow, value)
      }
      t[i] = newRow
    }
  }
  return t
}

fun findPivot(t: list<list<float>>): list<int> {
  var col = 0
  var minVal = 0.0
  for j in 0..len(t[0]) - 1 {
    let v = t[0][j]
    if v < minVal {
      minVal = v
      col = j
    }
  }
  if minVal >= 0.0 {
    return [-1, -1]
  }
  var row = -1
  var minRatio = 0.0
  var first = true
  for i in 1..len(t) {
    let coeff = t[i][col]
    if coeff > 0.0 {
      let rhs = t[i][len(t[i]) - 1]
      let ratio = rhs / coeff
      if first || ratio < minRatio {
        minRatio = ratio
        row = i
        first = false
      }
    }
  }
  return [row, col]
}

fun interpret(t: list<list<float>>, nVars: int): map<string, float> {
  let lastCol = len(t[0]) - 1
  var p = t[0][lastCol]
  if p < 0.0 { p = -p }
  var result: map<string, float> = {}
  result["P"] = p
  for i in 0..nVars {
    var nzRow = -1
    var nzCount = 0
    for r in 0..len(t) {
      let val = t[r][i]
      if val != 0.0 {
        nzCount = nzCount + 1
        nzRow = r
      }
    }
    if nzCount == 1 && t[nzRow][i] == 1.0 {
      result["x" + str(i + 1)] = t[nzRow][lastCol]
    }
  }
  return result
}

fun simplex(tab: list<list<float>>): list<list<float>> {
  var t = tab
  while true {
    let p = findPivot(t)
    let row = p[0]
    let col = p[1]
    if row < 0 { break }
    t = pivot(t, row, col)
  }
  return t
}

var tableau: list<list<float>> = [
  [-1.0, -1.0, 0.0, 0.0, 0.0],
  [1.0, 3.0, 1.0, 0.0, 4.0],
  [3.0, 1.0, 0.0, 1.0, 4.0]
]

var finalTab = simplex(tableau)
let res = interpret(finalTab, 2)
print("P: " + str(res["P"]))
for i in 0..2 {
  let key = "x" + str(i + 1)
  if key in res {
    print(key + ": " + str(res[key]))
  }
}
