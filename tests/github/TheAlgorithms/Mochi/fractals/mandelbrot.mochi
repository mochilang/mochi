/*
Mandelbrot Set Visualization

This program generates a small representation of the Mandelbrot set.
A complex number c = x + yi belongs to the set if the sequence
z_{n+1} = z_n^2 + c with z_0 = 0 never diverges. For each point
in the plane we iterate up to max_step times and compute the
relative step at which divergence occurs. Using this distance,
we color pixels either in black and white or using a simple HSV-
based gradient. The algorithm runs in O(width * height * max_step).

The code computes a tiny image and prints the color of the top-left
pixel in both color modes, replicating the doctest from the Python
version.
*/

type RGB {
  r: int,
  g: int,
  b: int
}

fun round_int(x: float): int {
  return (x + 0.5) as int
}

fun hsv_to_rgb(h: float, s: float, v: float): RGB {
  let i = (h * 6.0) as int
  let f = h * 6.0 - (i as float)
  let p = v * (1.0 - s)
  let q = v * (1.0 - f * s)
  let t = v * (1.0 - (1.0 - f) * s)
  let mod = i % 6
  var r = 0.0
  var g = 0.0
  var b = 0.0
  if mod == 0 {
    r = v; g = t; b = p
  } else if mod == 1 {
    r = q; g = v; b = p
  } else if mod == 2 {
    r = p; g = v; b = t
  } else if mod == 3 {
    r = p; g = q; b = v
  } else if mod == 4 {
    r = t; g = p; b = v
  } else {
    r = v; g = p; b = q
  }
  return RGB {
    r: round_int(r * 255.0),
    g: round_int(g * 255.0),
    b: round_int(b * 255.0)
  }
}

fun get_distance(x: float, y: float, max_step: int): float {
  var a = x
  var b = y
  var step = -1
  while step < max_step - 1 {
    step = step + 1
    let a_new = a * a - b * b + x
    b = 2.0 * a * b + y
    a = a_new
    if a * a + b * b > 4.0 {
      break
    }
  }
  return (step as float) / ((max_step - 1) as float)
}

fun get_black_and_white_rgb(distance: float): RGB {
  if distance == 1.0 {
    return RGB { r: 0, g: 0, b: 0 }
  } else {
    return RGB { r: 255, g: 255, b: 255 }
  }
}

fun get_color_coded_rgb(distance: float): RGB {
  if distance == 1.0 {
    return RGB { r: 0, g: 0, b: 0 }
  } else {
    return hsv_to_rgb(distance, 1.0, 1.0)
  }
}

fun get_image(image_width: int, image_height: int, figure_center_x: float,
              figure_center_y: float, figure_width: float, max_step: int,
              use_distance_color_coding: bool): list<list<RGB>> {
  var img: list<list<RGB>> = []
  let figure_height = figure_width / (image_width as float) * (image_height as float)
  var image_y = 0
  while image_y < image_height {
    var row: list<RGB> = []
    var image_x = 0
    while image_x < image_width {
      let fx = figure_center_x + ((image_x as float) / (image_width as float) - 0.5) * figure_width
      let fy = figure_center_y + ((image_y as float) / (image_height as float) - 0.5) * figure_height
      let distance = get_distance(fx, fy, max_step)
      var rgb: RGB
      if use_distance_color_coding {
        rgb = get_color_coded_rgb(distance)
      } else {
        rgb = get_black_and_white_rgb(distance)
      }
      row = append(row, rgb)
      image_x = image_x + 1
    }
    img = append(img, row)
    image_y = image_y + 1
  }
  return img
}

fun rgb_to_string(c: RGB): string {
  return "(" + str(c.r) + ", " + str(c.g) + ", " + str(c.b) + ")"
}

let img1 = get_image(10, 10, -0.6, 0.0, 3.2, 50, true)
print(rgb_to_string(img1[0][0]))

let img2 = get_image(10, 10, -0.6, 0.0, 3.2, 50, false)
print(rgb_to_string(img2[0][0]))
