/*
Simulate Wa-Tor, a predatorâ€“prey model on a two dimensional grid.  Each
cell may contain a prey (fish), a predator (shark) or be empty.  During
one time step every entity acts once in random order:

  1. Prey move to a random adjacent empty cell.  After surviving a fixed
     number of steps they reproduce, leaving a new prey in their previous
     position.
  2. Predators first try to move into a cell occupied by a prey to eat it
     and gain energy.  If no prey is adjacent they move like a prey.  Each
     step decreases their energy and a predator that reaches zero energy
     dies.  Predators also reproduce after a fixed number of steps when
they successfully move.

The world is a rectangular grid without wrap around.  This implementation
uses a simple deterministic pseudo random generator (linear congruential)
to avoid external dependencies.  The simulation prints the remaining
number of prey and predators after several time steps.
*/

let WIDTH = 10
let HEIGHT = 10

let PREY_INITIAL_COUNT = 20
let PREY_REPRODUCTION_TIME = 5

let PREDATOR_INITIAL_COUNT = 5
let PREDATOR_REPRODUCTION_TIME = 20
let PREDATOR_INITIAL_ENERGY = 15
let PREDATOR_FOOD_VALUE = 5

let TYPE_PREY = 0
let TYPE_PREDATOR = 1

var seed = 123456789

fun rand(): int {
  seed = (seed * 1103515245 + 12345) % 2147483648
  return seed
}

fun rand_range(max: int): int {
  return rand() % max
}

fun shuffle(list_int: list<int>): list<int> {
  var i = len(list_int) - 1
  while i > 0 {
    let j = rand_range(i + 1)
    let tmp = list_int[i]
    list_int[i] = list_int[j]
    list_int[j] = tmp
    i = i - 1
  }
  return list_int
}

fun create_board(): list<list<int>> {
  var board: list<list<int>> = []
  var r = 0
  while r < HEIGHT {
    var row: list<int> = []
    var c = 0
    while c < WIDTH {
      row = append(row, 0)
      c = c + 1
    }
    board = append(board, row)
    r = r + 1
  }
  return board
}

fun create_prey(r: int, c: int): list<int> {
  return [TYPE_PREY, r, c, PREY_REPRODUCTION_TIME, 0, 1]
}

fun create_predator(r: int, c: int): list<int> {
  return [TYPE_PREDATOR, r, c, PREDATOR_REPRODUCTION_TIME, PREDATOR_INITIAL_ENERGY, 1]
}

var board = create_board()
var entities: list<list<int>> = []

fun empty_cell(r: int, c: int): bool {
  return board[r][c] == 0
}

fun add_entity(typ: int) {
  while true {
    let r = rand_range(HEIGHT)
    let c = rand_range(WIDTH)
    if empty_cell(r, c) {
      if typ == TYPE_PREY {
        board[r][c] = 1
        entities = append(entities, create_prey(r, c))
      } else {
        board[r][c] = 2
        entities = append(entities, create_predator(r, c))
      }
      return
    }
  }
}

fun setup() {
  var i = 0
  while i < PREY_INITIAL_COUNT {
    add_entity(TYPE_PREY)
    i = i + 1
  }
  i = 0
  while i < PREDATOR_INITIAL_COUNT {
    add_entity(TYPE_PREDATOR)
    i = i + 1
  }
}

let dr = [-1, 0, 1, 0]
let dc = [0, 1, 0, -1]

fun inside(r: int, c: int): bool {
  return r >= 0 && r < HEIGHT && c >= 0 && c < WIDTH
}

fun find_prey(r: int, c: int): int {
  var i = 0
  while i < len(entities) {
    let e = entities[i]
    if e[5] == 1 && e[0] == TYPE_PREY && e[1] == r && e[2] == c {
      return i
    }
    i = i + 1
  }
  return -1
}

fun step_world() {
  var i = 0
  while i < len(entities) {
    var e = entities[i]
    if e[5] == 0 {
      i = i + 1
      continue
    }
    let typ = e[0]
    let row = e[1]
    let col = e[2]
    let repro = e[3]
    let energy = e[4]
    var dirs = [0,1,2,3]
    dirs = shuffle(dirs)
    var moved = false
    let old_r = row
    let old_c = col
    if typ == TYPE_PREDATOR {
      var j = 0
      var ate = false
      while j < 4 {
        let d = dirs[j]
        let nr = row + dr[d]
        let nc = col + dc[d]
        if inside(nr, nc) && board[nr][nc] == 1 {
          let prey_index = find_prey(nr, nc)
          if prey_index >= 0 {
            entities[prey_index][5] = 0
          }
          board[nr][nc] = 2
          board[row][col] = 0
          e[1] = nr
          e[2] = nc
          e[4] = energy + PREDATOR_FOOD_VALUE - 1
          moved = true
          ate = true
          break
        }
        j = j + 1
      }
      if !ate {
        j = 0
        while j < 4 {
          let d = dirs[j]
          let nr = row + dr[d]
          let nc = col + dc[d]
          if inside(nr, nc) && board[nr][nc] == 0 {
            board[nr][nc] = 2
            board[row][col] = 0
            e[1] = nr
            e[2] = nc
            moved = true
            break
          }
          j = j + 1
        }
        e[4] = energy - 1
      }
      if e[4] <= 0 {
        e[5] = 0
        board[e[1]][e[2]] = 0
      }
    } else {
      var j = 0
      while j < 4 {
        let d = dirs[j]
        let nr = row + dr[d]
        let nc = col + dc[d]
        if inside(nr, nc) && board[nr][nc] == 0 {
          board[nr][nc] = 1
          board[row][col] = 0
          e[1] = nr
          e[2] = nc
          moved = true
          break
        }
        j = j + 1
      }
    }
    if e[5] == 1 {
      if moved && repro <= 0 {
        if typ == TYPE_PREY {
          board[old_r][old_c] = 1
          entities = append(entities, create_prey(old_r, old_c))
          e[3] = PREY_REPRODUCTION_TIME
        } else {
          board[old_r][old_c] = 2
          entities = append(entities, create_predator(old_r, old_c))
          e[3] = PREDATOR_REPRODUCTION_TIME
        }
      } else {
        e[3] = repro - 1
      }
    }
    i = i + 1
  }
  var alive: list<list<int>> = []
  var k = 0
  while k < len(entities) {
    let e2 = entities[k]
    if e2[5] == 1 {
      alive = append(alive, e2)
    }
    k = k + 1
  }
  entities = alive
}

fun count_entities(typ: int): int {
  var cnt = 0
  var i = 0
  while i < len(entities) {
    if entities[i][0] == typ && entities[i][5] == 1 {
      cnt = cnt + 1
    }
    i = i + 1
  }
  return cnt
}

setup()

var t = 0
while t < 10 {
  step_world()
  t = t + 1
}

print("Prey: " + str(count_entities(TYPE_PREY)))
print("Predators: " + str(count_entities(TYPE_PREDATOR)))
