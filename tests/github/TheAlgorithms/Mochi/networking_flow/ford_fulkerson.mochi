/*
Ford–Fulkerson Algorithm for the Maximum Flow Problem

Given a directed graph with capacities on each edge, the goal is to determine
how much flow can be sent from a source vertex to a sink vertex.  The algorithm
starts with zero flow and repeatedly looks for an augmenting path in the
residual graph.  A breadth‑first search is used to find such a path.  The
minimal capacity along the path is added to the total flow and the residual
capacities are updated.  The process repeats until no augmenting path can be
found.

The graph is represented as an adjacency matrix of non‑negative integers where
entry [u][v] gives the remaining capacity from vertex u to vertex v.  The time
complexity depends on the number of augmenting iterations and is bounded by
O(E * max_flow) in the worst case, where E is the number of edges.
*/

let INF: int = 1000000000

fun breadth_first_search(graph: list<list<int>>, source: int, sink: int, parent: list<int>): bool {
  var visited: list<bool> = []
  var i = 0
  while i < len(graph) {
    visited = append(visited, false)
    i = i + 1
  }
  var queue: list<int> = []
  queue = append(queue, source)
  visited[source] = true
  var head = 0
  while head < len(queue) {
    let u = queue[head]
    head = head + 1
    let row = graph[u]
    var ind = 0
    while ind < len(row) {
      let capacity = row[ind]
      if visited[ind] == false && capacity > 0 {
        queue = append(queue, ind)
        visited[ind] = true
        parent[ind] = u
      }
      ind = ind + 1
    }
  }
  return visited[sink]
}

fun ford_fulkerson(graph: list<list<int>>, source: int, sink: int): int {
  var parent: list<int> = []
  var i = 0
  while i < len(graph) {
    parent = append(parent, -1)
    i = i + 1
  }
  var max_flow = 0
  while breadth_first_search(graph, source, sink, parent) {
    var path_flow = INF
    var s = sink
    while s != source {
      let prev = parent[s]
      let cap = graph[prev][s]
      if cap < path_flow {
        path_flow = cap
      }
      s = prev
    }
    max_flow = max_flow + path_flow
    var v = sink
    while v != source {
      let u = parent[v]
      graph[u][v] = graph[u][v] - path_flow
      graph[v][u] = graph[v][u] + path_flow
      v = u
    }
    var j = 0
    while j < len(parent) {
      parent[j] = -1
      j = j + 1
    }
  }
  return max_flow
}

let graph: list<list<int>> = [
  [0, 16, 13, 0, 0, 0],
  [0, 0, 10, 12, 0, 0],
  [0, 4, 0, 0, 14, 0],
  [0, 0, 9, 0, 0, 20],
  [0, 0, 0, 7, 0, 4],
  [0, 0, 0, 0, 0, 0]
]

print(str(ford_fulkerson(graph, 0, 5)))
