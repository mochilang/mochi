/*
Test for a simplified file transfer routine.

This program mimics a unit test for a function that sends the
contents of a file to a client over a network socket.  Mock
objects are used in place of real sockets and files to record the
sequence of operations:
  1. create a socket and wait for a connection
  2. read a single chunk from a file
  3. send the chunk to the client
  4. close the connection and the socket

Each mock tracks how many times its methods are called.  After
running the transfer, the test verifies that every method executed
exactly once, confirming the expected protocol without relying on
any external resources.
*/

type ConnMock {
  recv_called: int
  send_called: int
  close_called: int
}

fun make_conn_mock(): ConnMock {
  return ConnMock { recv_called: 0, send_called: 0, close_called: 0 }
}

fun conn_recv(conn: ConnMock, size: int): int {
  conn.recv_called = conn.recv_called + 1
  return 0
}

fun conn_send(conn: ConnMock, data: int): void {
  conn.send_called = conn.send_called + 1
}

fun conn_close(conn: ConnMock): void {
  conn.close_called = conn.close_called + 1
}

type SocketMock {
  bind_called: int
  listen_called: int
  accept_called: int
  shutdown_called: int
  close_called: int
  conn: ConnMock
}

fun make_socket_mock(conn: ConnMock): SocketMock {
  return SocketMock {
    bind_called: 0,
    listen_called: 0,
    accept_called: 0,
    shutdown_called: 0,
    close_called: 0,
    conn: conn
  }
}

fun socket_bind(sock: SocketMock): void {
  sock.bind_called = sock.bind_called + 1
}

fun socket_listen(sock: SocketMock): void {
  sock.listen_called = sock.listen_called + 1
}

fun socket_accept(sock: SocketMock): ConnMock {
  sock.accept_called = sock.accept_called + 1
  return sock.conn
}

fun socket_shutdown(sock: SocketMock): void {
  sock.shutdown_called = sock.shutdown_called + 1
}

fun socket_close(sock: SocketMock): void {
  sock.close_called = sock.close_called + 1
}

type FileMock {
  read_called: int
  data: list<int>
}

fun make_file_mock(values: list<int>): FileMock {
  return FileMock { read_called: 0, data: values }
}

fun file_read(f: FileMock, size: int): int {
  if f.read_called < len(f.data) {
    let value = f.data[f.read_called]
    f.read_called = f.read_called + 1
    return value
  }
  f.read_called = f.read_called + 1
  return 0
}

fun file_open(): FileMock {
  return make_file_mock([1, 0])
}

fun send_file(sock: SocketMock, f: FileMock): void {
  socket_bind(sock)
  socket_listen(sock)
  let conn = socket_accept(sock)
  let _ = conn_recv(conn, 1024)
  var data = file_read(f, 1024)
  while data != 0 {
    conn_send(conn, data)
    data = file_read(f, 1024)
  }
  conn_close(conn)
  socket_shutdown(sock)
  socket_close(sock)
}

fun test_send_file_running_as_expected(): string {
  let conn = make_conn_mock()
  let sock = make_socket_mock(conn)
  let f = file_open()
  send_file(sock, f)
  if sock.bind_called == 1 &&
     sock.listen_called == 1 &&
     sock.accept_called == 1 &&
     conn.recv_called == 1 &&
     f.read_called >= 1 &&
     conn.send_called == 1 &&
     conn.close_called == 1 &&
     sock.shutdown_called == 1 &&
     sock.close_called == 1 {
    return "pass"
  }
  return "fail"
}

print(test_send_file_running_as_expected())
