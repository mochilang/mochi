/*
Generalized Boyerâ€“Moore Majority Vote Algorithm

Given a list of votes, find all elements that appear more than n/k times.
The algorithm maintains at most k-1 candidate elements with counters.
For each vote:
- If it matches an existing candidate, increment its count.
- Else if fewer than k-1 candidates exist, add the new candidate.
- Otherwise, decrement all counts and remove candidates with zero.
After one pass, remaining candidates are potential majorities.
A second pass counts actual occurrences to filter those exceeding n/k.

Time complexity: O(n) where n is number of votes.
Space complexity: O(k) for candidate storage.
*/

fun index_of(xs: list<int>, x: int): int {
  var i = 0
  while i < len(xs) {
    if xs[i] == x {
      return i
    }
    i = i + 1
  }
  return 0 - 1
}

fun majority_vote(votes: list<int>, votes_needed_to_win: int): list<int> {
  if votes_needed_to_win < 2 {
    return []
  }
  var candidates: list<int> = []
  var counts: list<int> = []
  var i = 0
  while i < len(votes) {
    let v = votes[i]
    let idx = index_of(candidates, v)
    if idx != 0 - 1 {
      counts[idx] = counts[idx] + 1
    } else if len(candidates) < votes_needed_to_win - 1 {
      candidates = append(candidates, v)
      counts = append(counts, 1)
    } else {
      var j = 0
      while j < len(counts) {
        counts[j] = counts[j] - 1
        j = j + 1
      }
      var new_candidates: list<int> = []
      var new_counts: list<int> = []
      j = 0
      while j < len(candidates) {
      if counts[j] > 0 {
          new_candidates = append(new_candidates, candidates[j])
          new_counts = append(new_counts, counts[j])
        }
        j = j + 1
      }
      candidates = new_candidates
      counts = new_counts
    }
    i = i + 1
  }
  var final_counts: list<int> = []
  var j = 0
  while j < len(candidates) {
    final_counts = append(final_counts, 0)
    j = j + 1
  }
  i = 0
  while i < len(votes) {
    let v = votes[i]
    let idx = index_of(candidates, v)
    if idx != 0 - 1 {
      final_counts[idx] = final_counts[idx] + 1
    }
    i = i + 1
  }
  var result: list<int> = []
  j = 0
  while j < len(candidates) {
    if final_counts[j] * votes_needed_to_win > len(votes) {
      result = append(result, candidates[j])
    }
    j = j + 1
  }
  return result
}

fun main() {
  let votes: list<int> = [1,2,2,3,1,3,2]
  print(str(majority_vote(votes, 3)))
  print(str(majority_vote(votes, 2)))
  print(str(majority_vote(votes, 4)))
}

main()
