/*
Dijkstra's Algorithm with Adjacency Matrix
------------------------------------------
This implementation solves the single-source shortest path problem for a graph
represented as an adjacency matrix. Each cell `graph[u][v]` holds the weight of
the edge from vertex `u` to `v` (0 denotes no edge). The algorithm maintains two
arrays:

1. `distances` – distance estimates from the source to every vertex. They are
   initialized to a large sentinel value (1e7) except for the source which is 0.
2. `visited` – marks vertices whose final shortest distance has been determined.

Repeatedly, the unvisited vertex with the smallest tentative distance is
selected. For each neighbor `v` of this vertex `u`, if the path through `u`
produces a shorter distance than the current estimate for `v`, it is updated.
The algorithm runs in `O(V^2)` time for `V` vertices when using an adjacency
matrix.
*/

fun minimum_distance(distances: list<int>, visited: list<bool>): int {
  var minimum = 10000000
  var min_index = 0
  var vertex = 0
  while vertex < len(distances) {
    if distances[vertex] < minimum && visited[vertex] == false {
      minimum = distances[vertex]
      min_index = vertex
    }
    vertex = vertex + 1
  }
  return min_index
}

fun dijkstra(graph: list<list<int>>, source: int): list<int> {
  let vertices = len(graph)
  var distances: list<int>
  var i = 0
  while i < vertices {
    distances = append(distances, 10000000)
    i = i + 1
  }
  distances[source] = 0
  var visited: list<bool>
  i = 0
  while i < vertices {
    visited = append(visited, false)
    i = i + 1
  }
  var count = 0
  while count < vertices {
    let u = minimum_distance(distances, visited)
    visited[u] = true
    var v = 0
    while v < vertices {
      if graph[u][v] > 0 && visited[v] == false && distances[v] > distances[u] + graph[u][v] {
        distances[v] = distances[u] + graph[u][v]
      }
      v = v + 1
    }
    count = count + 1
  }
  return distances
}

fun print_solution(distances: list<int>) {
  print("Vertex \t Distance from Source")
  var v = 0
  while v < len(distances) {
    print(str(v) + "\t\t" + str(distances[v]))
    v = v + 1
  }
}

let graph = [
  [0, 4, 0, 0, 0, 0, 0, 8, 0],
  [4, 0, 8, 0, 0, 0, 0, 11, 0],
  [0, 8, 0, 7, 0, 4, 0, 0, 2],
  [0, 0, 7, 0, 9, 14, 0, 0, 0],
  [0, 0, 0, 9, 0, 10, 0, 0, 0],
  [0, 0, 4, 14, 10, 0, 2, 0, 0],
  [0, 0, 0, 0, 0, 2, 0, 1, 6],
  [8, 11, 0, 0, 0, 0, 1, 0, 7],
  [0, 0, 2, 0, 0, 0, 6, 7, 0],
]

let distances = dijkstra(graph, 0)
print_solution(distances)
