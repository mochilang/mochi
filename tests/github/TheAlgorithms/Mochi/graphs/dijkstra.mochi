/*
Dijkstra's Shortest Path Algorithm

This program demonstrates Dijkstra's algorithm for computing the cost of the shortest
path between two vertices in a weighted directed graph. The graph is stored as a map
from each vertex to a map of neighboring vertices and edge weights. A simple list is
used as a priority queue; at each step the entry with the lowest cost is selected.
If the destination is reached its total cost is printed, otherwise the search
continues until all reachable vertices are explored.

Three sample graphs are evaluated, matching the examples from the corresponding
Python implementation in TheAlgorithms repository.
*/

type NodeCost {
  node: string
  cost: int
}

// ----- Graph G -----
let G: map<string, map<string, int>> = {
  "A": {"B": 2, "C": 5},
  "B": {"A": 2, "D": 3, "E": 1, "F": 1},
  "C": {"A": 5, "F": 3},
  "D": {"B": 3},
  "E": {"B": 4, "F": 3},
  "F": {"C": 3, "E": 3}
}
var heap: list<NodeCost> = [NodeCost { node: "E", cost: 0 }]
var visited: map<string, bool> = {}
var result = -1
while len(heap) > 0 {
  var best_idx = 0
  var i = 1
  while i < len(heap) {
    if heap[i].cost < heap[best_idx].cost {
      best_idx = i
    }
    i = i + 1
  }
  let best = heap[best_idx]
  var new_heap: list<NodeCost> = []
  var j = 0
  while j < len(heap) {
    if j != best_idx {
      new_heap = append(new_heap, heap[j])
    }
    j = j + 1
  }
  heap = new_heap
  let u = best.node
  let cost = best.cost
  if u in visited {
    continue
  }
  visited[u] = true
  if u == "C" {
    result = cost
    break
  }
  for v in G[u] {
    if v in visited {
      continue
    }
    let next_cost = cost + G[u][v]
    heap = append(heap, NodeCost { node: v, cost: next_cost })
  }
}
print(result)

// ----- Graph G2 -----
let G2: map<string, map<string, int>> = {
  "B": {"C": 1},
  "C": {"D": 1},
  "D": {"F": 1},
  "E": {"B": 1, "F": 3},
  "F": {}
}
var heap2: list<NodeCost> = [NodeCost { node: "E", cost: 0 }]
var visited2: map<string, bool> = {}
var result2 = -1
while len(heap2) > 0 {
  var best2_idx = 0
  var i2 = 1
  while i2 < len(heap2) {
    if heap2[i2].cost < heap2[best2_idx].cost {
      best2_idx = i2
    }
    i2 = i2 + 1
  }
  let best2 = heap2[best2_idx]
  var new_heap2: list<NodeCost> = []
  var j2 = 0
  while j2 < len(heap2) {
    if j2 != best2_idx {
      new_heap2 = append(new_heap2, heap2[j2])
    }
    j2 = j2 + 1
  }
  heap2 = new_heap2
  let u2 = best2.node
  let cost2 = best2.cost
  if u2 in visited2 {
    continue
  }
  visited2[u2] = true
  if u2 == "F" {
    result2 = cost2
    break
  }
  for v2 in G2[u2] {
    if v2 in visited2 {
      continue
    }
    let next_cost2 = cost2 + G2[u2][v2]
    heap2 = append(heap2, NodeCost { node: v2, cost: next_cost2 })
  }
}
print(result2)

// ----- Graph G3 -----
let G3: map<string, map<string, int>> = {
  "B": {"C": 1},
  "C": {"D": 1},
  "D": {"F": 1},
  "E": {"B": 1, "G": 2},
  "F": {},
  "G": {"F": 1}
}
var heap3: list<NodeCost> = [NodeCost { node: "E", cost: 0 }]
var visited3: map<string, bool> = {}
var result3 = -1
while len(heap3) > 0 {
  var best3_idx = 0
  var i3 = 1
  while i3 < len(heap3) {
    if heap3[i3].cost < heap3[best3_idx].cost {
      best3_idx = i3
    }
    i3 = i3 + 1
  }
  let best3 = heap3[best3_idx]
  var new_heap3: list<NodeCost> = []
  var j3 = 0
  while j3 < len(heap3) {
    if j3 != best3_idx {
      new_heap3 = append(new_heap3, heap3[j3])
    }
    j3 = j3 + 1
  }
  heap3 = new_heap3
  let u3 = best3.node
  let cost3 = best3.cost
  if u3 in visited3 {
    continue
  }
  visited3[u3] = true
  if u3 == "F" {
    result3 = cost3
    break
  }
  for v3 in G3[u3] {
    if v3 in visited3 {
      continue
    }
    let next_cost3 = cost3 + G3[u3][v3]
    heap3 = append(heap3, NodeCost { node: v3, cost: next_cost3 })
  }
}
print(result3)
