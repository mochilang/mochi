/*
Approximation algorithm for the Minimum Vertex Cover problem using a matching based heuristic.

The input graph is represented as an adjacency list `map<int, list<int>>`.  We first
construct a list of all directed edges.  Then, while edges remain, we repeatedly pop an
arbitrary edge and add both of its endpoints to the cover.  Every edge incident to either
chosen vertex is removed.  The resulting set of chosen vertices is a 2-approximation of
a minimum vertex cover.

The implementation uses only pure Mochi constructs with explicit types.
*/

fun contains(xs: list<int>, v: int): bool {
  for x in xs { if x == v { return true } }
  return false
}

fun get_edges(graph: map<int, list<int>>): list<list<int>> {
  let n = len(graph)
  var edges: list<list<int>> = []
  for i in 0..n {
    for j in graph[i] {
      edges = append(edges, [i, j])
    }
  }
  return edges
}

fun matching_min_vertex_cover(graph: map<int, list<int>>): list<int> {
  var chosen: list<int> = []
  var edges = get_edges(graph)
  while len(edges) > 0 {
    let idx = len(edges) - 1
    let e = edges[idx]
    edges = slice(edges, 0, idx)
    let u = e[0]
    let v = e[1]
    if !contains(chosen, u) { chosen = append(chosen, u) }
    if !contains(chosen, v) { chosen = append(chosen, v) }
    var filtered: list<list<int>> = []
    for edge in edges {
      let a = edge[0]
      let b = edge[1]
      if a != u && b != u && a != v && b != v {
        filtered = append(filtered, edge)
      }
    }
    edges = filtered
  }
  return chosen
}

let graph: map<int, list<int>> = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}
let cover = matching_min_vertex_cover(graph)
print(str(cover))
