/*
Find articulation points (cut vertices) in an undirected graph using a brute-force depth-first search approach.

For each vertex `v` in the graph:
1. Temporarily remove `v` by skipping it during traversal.
2. Run a DFS from another vertex to count how many vertices are reachable.
3. If fewer than `n-1` vertices are reachable, removing `v` disconnects the graph, so `v` is an articulation point.

The graph is represented as a list of adjacency lists. This program prints all articulation point
indices for the provided example graph. Time complexity: O(V * (V + E)).
*/

fun dfs_skip(graph: list<list<int>>, visited: list<bool>, skip: int, at: int): int {
  visited[at] = true
  var count = 1
  for to in graph[at] {
    if to == skip { continue }
    if visited[to] == false {
      count = count + dfs_skip(graph, visited, skip, to)
    }
  }
  return count
}

fun articulation_points(graph: list<list<int>>): list<int> {
  let n = len(graph)
  var result: list<int> = []
  var v = 0
  while v < n {
    var visited: list<bool> = []
    var i = 0
    while i < n {
      visited = append(visited, false)
      i = i + 1
    }
    var start = 0
    while start == v && start < n { start = start + 1 }
    let reach = dfs_skip(graph, visited, v, start)
    if reach < n - 1 {
      result = append(result, v)
      print(v)
    }
    v = v + 1
  }
  return result
}

fun main() {
  let graph: list<list<int>> = [
    [1, 2],
    [0, 2],
    [0, 1, 3, 5],
    [2, 4],
    [3],
    [2, 6, 8],
    [5, 7],
    [6, 8],
    [5, 7]
  ]
  articulation_points(graph)
}

main()
