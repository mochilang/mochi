/*
Eulerian Path and Circuit for Undirected Graph

This module determines whether an undirected graph contains an Eulerian
path or an Eulerian circuit and produces the corresponding traversal.
An Eulerian path visits every edge exactly once, while an Eulerian
circuit is an Eulerian path that starts and ends on the same vertex.

For an undirected graph:
- A circuit exists iff every vertex has even degree.
- A path (but not a circuit) exists iff exactly two vertices have odd degree.

The algorithm proceeds as follows:
1. Count vertices with odd degree to classify the graph.
2. Use a matrix to mark edges as visited.
3. Perform depth-first search to build the Eulerian traversal.

Time Complexity: O(V + E)
Space Complexity: O(V^2)
*/

type CheckResult {
  status: int,
  odd_node: int,
}

fun make_matrix(n: int): list<list<bool>> {
  var matrix: list<list<bool>> = []
  var i = 0
  while i <= n {
    var row: list<bool> = []
    var j = 0
    while j <= n {
      row = append(row, false)
      j = j + 1
    }
    matrix = append(matrix, row)
    i = i + 1
  }
  return matrix
}

fun dfs(u: int, graph: map<int, list<int>>, visited_edge: list<list<bool>>, path: list<int>): list<int> {
  path = append(path, u)
  if u in graph {
    let neighbors = graph[u]
    var i = 0
    while i < len(neighbors) {
      let v = neighbors[i]
      if visited_edge[u][v] == false {
        visited_edge[u][v] = true
        visited_edge[v][u] = true
        path = dfs(v, graph, visited_edge, path)
      }
      i = i + 1
    }
  }
  return path
}

fun check_circuit_or_path(graph: map<int, list<int>>, max_node: int): CheckResult {
  var odd_degree_nodes = 0
  var odd_node = -1
  var i = 0
  while i < max_node {
    if i in graph {
      if len(graph[i]) % 2 == 1 {
        odd_degree_nodes = odd_degree_nodes + 1
        odd_node = i
      }
    }
    i = i + 1
  }
  if odd_degree_nodes == 0 {
    return CheckResult { status: 1, odd_node: odd_node }
  }
  if odd_degree_nodes == 2 {
    return CheckResult { status: 2, odd_node: odd_node }
  }
  return CheckResult { status: 3, odd_node: odd_node }
}

fun check_euler(graph: map<int, list<int>>, max_node: int) {
  var visited_edge = make_matrix(max_node)
  let res = check_circuit_or_path(graph, max_node)
  if res.status == 3 {
    print("graph is not Eulerian")
    print("no path")
    return
  }
  var start_node = 1
  if res.status == 2 {
    start_node = res.odd_node
    print("graph has a Euler path")
  }
  if res.status == 1 {
    print("graph has a Euler cycle")
  }
  let path = dfs(start_node, graph, visited_edge, [])
  print(str(path))
}

let g1: map<int, list<int>> = {1: [2, 3, 4], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [4]}
let g2: map<int, list<int>> = {1: [2, 3, 4, 5], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [1, 4]}
let g3: map<int, list<int>> = {1: [2, 3, 4], 2: [1, 3, 4], 3: [1, 2], 4: [1, 2, 5], 5: [4]}
let g4: map<int, list<int>> = {1: [2, 3], 2: [1, 3], 3: [1, 2]}
let g5: map<int, list<int>> = {1: [], 2: []}

let max_node = 10
check_euler(g1, max_node)
check_euler(g2, max_node)
check_euler(g3, max_node)
check_euler(g4, max_node)
check_euler(g5, max_node)
