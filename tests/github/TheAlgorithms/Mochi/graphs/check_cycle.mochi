/*
Detect cycles in a directed graph using depth-first search.
The graph is given as adjacency lists for vertices 0..n-1.
The algorithm tracks visited nodes and a recursion stack. When exploring
neighbors, hitting a node already on the stack reveals a cycle. The
search runs in O(V+E) time and O(V) space for a graph with V vertices
and E edges.
*/
fun depth_first_search(graph: list<list<int>>, vertex: int, visited: list<bool>, rec_stk: list<bool>): bool {
  visited[vertex] = true
  rec_stk[vertex] = true
  for node in graph[vertex] {
    if !visited[node] {
      if depth_first_search(graph, node, visited, rec_stk) {
        return true
      }
    } else if rec_stk[node] {
      return true
    }
  }
  rec_stk[vertex] = false
  return false
}

fun check_cycle(graph: list<list<int>>): bool {
  let n = len(graph)
  var visited: list<bool> = []
  var rec_stk: list<bool> = []
  var i = 0
  while i < n {
    visited = append(visited, false)
    rec_stk = append(rec_stk, false)
    i = i + 1
  }
  i = 0
  while i < n {
    if !visited[i] {
      if depth_first_search(graph, i, visited, rec_stk) {
        return true
      }
    }
    i = i + 1
  }
  return false
}

fun print_bool(b: bool) {
  if b { print("true") } else { print("false") }
}

let g1 = [[], [0,3], [0,4], [5], [5], []]
print_bool(check_cycle(g1))
let g2 = [[1,2], [2], [0,3], [3]]
print_bool(check_cycle(g2))
