/*
Karger's Randomized Min-Cut Algorithm
------------------------------------
Given an undirected multigraph represented as an adjacency list, Karger's
algorithm repeatedly contracts random edges until only two supernodes remain.
The set of edges crossing between these two groups forms a cut of the original
graph. Repeating the process many times yields the global minimum cut with high
probability. This implementation performs a single contraction pass.

Steps:
1. Copy the graph and track for each contracted node the set of original
   vertices it contains.
2. While more than two nodes remain, choose a random edge (u, v) and merge
them into a new node uv. Update adjacency lists and contracted sets.
3. Once two nodes remain, return the cutset: all edges connecting the two
groups.

Time complexity per run: O(V^2 log V) due to repeated edge contractions.
*/

var seed: int = 1

fun rand_int(n: int): int {
  seed = (seed * 1103515245 + 12345) % 2147483648
  return seed % n
}

fun contains(list: list<string>, value: string): bool {
  var i = 0
  while i < len(list) {
    if list[i] == value { return true }
    i = i + 1
  }
  return false
}

fun remove_all(list: list<string>, value: string): list<string> {
  var res: list<string> = []
  var i = 0
  while i < len(list) {
    if list[i] != value {
      res = append(res, list[i])
    }
    i = i + 1
  }
  return res
}

type Pair {
  a: string
  b: string
}

fun partition_graph(graph: map<string, list<string>>): list<Pair> {
  var contracted: map<string, list<string>> = {}
  for node in keys(graph) {
    contracted[node] = [node]
  }
  var graph_copy: map<string, list<string>> = {}
  for node in keys(graph) {
    var lst: list<string> = []
    var neigh = graph[node]
    var i = 0
    while i < len(neigh) {
      lst = append(lst, neigh[i])
      i = i + 1
    }
    graph_copy[node] = lst
  }
  var nodes = keys(graph_copy)
  while len(nodes) > 2 {
    let u = nodes[rand_int(len(nodes))]
    let u_neighbors = graph_copy[u]
    let v = u_neighbors[rand_int(len(u_neighbors))]
    let uv = u + v
    var uv_neighbors: list<string> = []
    var i = 0
    while i < len(graph_copy[u]) {
      let n = graph_copy[u][i]
      if n != u && n != v && contains(uv_neighbors, n) == false {
        uv_neighbors = append(uv_neighbors, n)
      }
      i = i + 1
    }
    i = 0
    while i < len(graph_copy[v]) {
      let n = graph_copy[v][i]
      if n != u && n != v && contains(uv_neighbors, n) == false {
        uv_neighbors = append(uv_neighbors, n)
      }
      i = i + 1
    }
    graph_copy[uv] = uv_neighbors
    var k = 0
    while k < len(uv_neighbors) {
      let nb = uv_neighbors[k]
      graph_copy[nb] = append(graph_copy[nb], uv)
      graph_copy[nb] = remove_all(graph_copy[nb], u)
      graph_copy[nb] = remove_all(graph_copy[nb], v)
      k = k + 1
    }
    var group: list<string> = []
    i = 0
    while i < len(contracted[u]) {
      group = append(group, contracted[u][i])
      i = i + 1
    }
    i = 0
    while i < len(contracted[v]) {
      let val = contracted[v][i]
      if contains(group, val) == false {
        group = append(group, val)
      }
      i = i + 1
    }
    contracted[uv] = group
    nodes = remove_all(nodes, u)
    nodes = remove_all(nodes, v)
    nodes = append(nodes, uv)
  }
  var groups: list<list<string>> = []
  var j = 0
  while j < len(nodes) {
    let n = nodes[j]
    groups = append(groups, contracted[n])
    j = j + 1
  }
  let groupA = groups[0]
  let groupB = groups[1]
  var cut: list<Pair> = []
  j = 0
  while j < len(groupA) {
    let node = groupA[j]
    var neigh = graph[node]
    var l = 0
    while l < len(neigh) {
      let nb = neigh[l]
      if contains(groupB, nb) {
        cut = append(cut, Pair { a: node, b: nb })
      }
      l = l + 1
    }
    j = j + 1
  }
  return cut
}

fun cut_to_string(cut: list<Pair>): string {
  var s = "{"
  var i = 0
  while i < len(cut) {
    let p = cut[i]
    s = s + "(" + p.a + ", " + p.b + ")"
    if i < len(cut) - 1 { s = s + ", " }
    i = i + 1
  }
  s = s + "}"
  return s
}

let TEST_GRAPH: map<string, list<string>> = {
  "1": ["2", "3", "4", "5"],
  "2": ["1", "3", "4", "5"],
  "3": ["1", "2", "4", "5", "10"],
  "4": ["1", "2", "3", "5", "6"],
  "5": ["1", "2", "3", "4", "7"],
  "6": ["7", "8", "9", "10", "4"],
  "7": ["6", "8", "9", "10", "5"],
  "8": ["6", "7", "9", "10"],
  "9": ["6", "7", "8", "10"],
  "10": ["6", "7", "8", "9", "3"],
}

let result = partition_graph(TEST_GRAPH)
print(cut_to_string(result))
