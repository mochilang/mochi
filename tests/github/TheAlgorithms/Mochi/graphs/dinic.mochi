/*
Dinic's Algorithm for Maximum Flow

This implementation computes the maximum possible flow from a source
vertex to a sink vertex in a directed graph with capacities.
It constructs a level graph using breadth-first search with capacity
scaling, then repeatedly performs depth-first searches to send blocking
flows while respecting edge capacities. The algorithm runs in O(E * V^2)
for general graphs and is faster with capacity scaling.

Example: Build a bipartite graph with four vertices on each side and
unit capacities. The maximum flow from source to sink is 4.
*/

let INF: int = 1000000000

type Dinic {
  n: int,
  lvl: list<int>,
  ptr: list<int>,
  q: list<int>,
  adj: list<list<list<int>>>
}

fun pow2(k: int): int {
  var res = 1
  var i = 0
  while i < k {
    res = res * 2
    i = i + 1
  }
  return res
}

fun min2(a: int, b: int): int {
  if a < b {
    return a
  }
  return b
}

fun new_dinic(n: int): Dinic {
  var lvl: list<int> = []
  var ptr: list<int> = []
  var q: list<int> = []
  var adj: list<list<list<int>>> = []
  var i = 0
  while i < n {
    lvl = append(lvl, 0)
    ptr = append(ptr, 0)
    q = append(q, 0)
    var edges: list<list<int>> = []
    adj = append(adj, edges)
    i = i + 1
  }
  return Dinic { n: n, lvl: lvl, ptr: ptr, q: q, adj: adj }
}

fun add_edge(g: Dinic, a: int, b: int, c: int, rcap: int): void {
  var adj: list<list<list<int>>> = g.adj
  var list_a: list<list<int>> = adj[a]
  var list_b: list<list<int>> = adj[b]
  let e1: list<int> = [b, len(list_b), c, 0]
  let e2: list<int> = [a, len(list_a), rcap, 0]
  list_a = append(list_a, e1)
  list_b = append(list_b, e2)
  adj[a] = list_a
  adj[b] = list_b
  g.adj = adj
}

fun dfs(g: Dinic, v: int, sink: int, flow: int): int {
  if v == sink || flow == 0 {
    return flow
  }
  var ptr: list<int> = g.ptr
  var i = ptr[v]
  var adj_all: list<list<list<int>>> = g.adj
  var adj_v: list<list<int>> = adj_all[v]
  while i < len(adj_v) {
    var e: list<int> = adj_v[i]
    let to = e[0]
    if g.lvl[to] == g.lvl[v] + 1 {
      let avail = e[2] - e[3]
      let pushed = dfs(g, to, sink, min2(flow, avail))
      if pushed > 0 {
        e[3] = e[3] + pushed
        adj_v[i] = e
        var adj_to: list<list<int>> = adj_all[to]
        var back: list<int> = adj_to[e[1]]
        back[3] = back[3] - pushed
        adj_to[e[1]] = back
        adj_all[to] = adj_to
        adj_all[v] = adj_v
        g.adj = adj_all
        return pushed
      }
    }
    i = i + 1
    ptr[v] = i
  }
  g.ptr = ptr
  adj_all[v] = adj_v
  g.adj = adj_all
  return 0
}

fun max_flow(g: Dinic, source: int, sink: int): int {
  var flow = 0
  var l = 0
  while l < 31 {
    let threshold = pow2(30 - l)
    while true {
      var lvl: list<int> = []
      var ptr: list<int> = []
      var i = 0
      while i < g.n {
        lvl = append(lvl, 0)
        ptr = append(ptr, 0)
        i = i + 1
      }
      g.lvl = lvl
      g.ptr = ptr
      var qi = 0
      var qe = 1
      lvl[source] = 1
      g.lvl = lvl
      var q: list<int> = g.q
      q[0] = source
      while qi < qe && g.lvl[sink] == 0 {
        let v = q[qi]
        qi = qi + 1
        var edges: list<list<int>> = g.adj[v]
        var j = 0
        while j < len(edges) {
          let e = edges[j]
          let to = e[0]
          let residual = e[2] - e[3]
          var lvl_inner: list<int> = g.lvl
          if lvl_inner[to] == 0 && residual >= threshold {
            q[qe] = to
            qe = qe + 1
            lvl_inner[to] = lvl_inner[v] + 1
            g.lvl = lvl_inner
          }
          j = j + 1
        }
      }
      var p = dfs(g, source, sink, INF)
      while p > 0 {
        flow = flow + p
        p = dfs(g, source, sink, INF)
      }
      if g.lvl[sink] == 0 {
        break
      }
    }
    l = l + 1
  }
  return flow
}

var graph = new_dinic(10)
let source = 0
let sink = 9
var v = 1
while v < 5 {
  add_edge(graph, source, v, 1, 0)
  v = v + 1
}
v = 5
while v < 9 {
  add_edge(graph, v, sink, 1, 0)
  v = v + 1
}
v = 1
while v < 5 {
  add_edge(graph, v, v + 4, 1, 0)
  v = v + 1
}
print(str(max_flow(graph, source, sink)))
