/*
A* Pathfinding on a Grid

This program searches for a lowest-cost path from a start cell to a goal cell
on a 2D grid while avoiding obstacles. Each cell in the grid is either free (0)
or blocked (1). The algorithm maintains an open list of frontier cells ordered
by estimated total cost f = g + h, where g is the distance from the start and h
is a heuristic estimate (Manhattan distance) to the goal. For each step, the
cell with the smallest f is expanded and its free neighbours are added to the
frontier. Once the goal is reached, the path is reconstructed by following the
actions stored during the search.
*/

let DIRECTIONS: list<list<int>> = [
  [-1, 0], // left
  [0, -1], // down
  [1, 0],  // right
  [0, 1]   // up
]

type SearchResult { path: list<list<int>>, action: list<list<int>> }

fun iabs(x: int): int {
  if x < 0 { return -x }
  return x
}

fun search(grid: list<list<int>>, init: list<int>, goal: list<int>, cost: int, heuristic: list<list<int>>): SearchResult {
  var closed: list<list<int>> = []
  var r = 0
  while r < len(grid) {
    var row: list<int> = []
    var c = 0
    while c < len(grid[0]) {
      row = append(row, 0)
      c = c + 1
    }
    closed = append(closed, row)
    r = r + 1
  }
  closed[init[0]][init[1]] = 1

  var action: list<list<int>> = []
  r = 0
  while r < len(grid) {
    var row: list<int> = []
    var c = 0
    while c < len(grid[0]) {
      row = append(row, 0)
      c = c + 1
    }
    action = append(action, row)
    r = r + 1
  }

  var x = init[0]
  var y = init[1]
  var g = 0
  var f = g + heuristic[x][y]
  var cell: list<list<int>> = [[f, g, x, y]]

  var found = false
  var resign = false
  while (!found) && (!resign) {
    if len(cell) == 0 {
      panic("Algorithm is unable to find solution")
    } else {
      var best_i = 0
      var best_f = cell[0][0]
      var i = 1
      while i < len(cell) {
        if cell[i][0] < best_f {
          best_f = cell[i][0]
          best_i = i
        }
        i = i + 1
      }
      let next_cell = cell[best_i]
      var new_cell: list<list<int>> = []
      i = 0
      while i < len(cell) {
        if i != best_i {
          new_cell = append(new_cell, cell[i])
        }
        i = i + 1
      }
      cell = new_cell
      x = next_cell[2]
      y = next_cell[3]
      g = next_cell[1]
      if x == goal[0] && y == goal[1] {
        found = true
      } else {
        var d = 0
        while d < len(DIRECTIONS) {
          let x2 = x + DIRECTIONS[d][0]
          let y2 = y + DIRECTIONS[d][1]
          if x2 >= 0 && x2 < len(grid) && y2 >= 0 && y2 < len(grid[0]) && closed[x2][y2] == 0 && grid[x2][y2] == 0 {
            let g2 = g + cost
            let f2 = g2 + heuristic[x2][y2]
            cell = append(cell, [f2, g2, x2, y2])
            closed[x2][y2] = 1
            action[x2][y2] = d
          }
          d = d + 1
        }
      }
    }
  }

  var invpath: list<list<int>> = []
  x = goal[0]
  y = goal[1]
  invpath = append(invpath, [x, y])
  while x != init[0] || y != init[1] {
    let dir = action[x][y]
    let x2 = x - DIRECTIONS[dir][0]
    let y2 = y - DIRECTIONS[dir][1]
    x = x2
    y = y2
    invpath = append(invpath, [x, y])
  }

  var path: list<list<int>> = []
  var idx = len(invpath) - 1
  while idx >= 0 {
    path = append(path, invpath[idx])
    idx = idx - 1
  }
  return SearchResult { path: path, action: action }
}

fun main() {
  let grid: list<list<int>> = [
    [0, 1, 0, 0, 0, 0],
    [0, 1, 0, 0, 0, 0],
    [0, 1, 0, 0, 0, 0],
    [0, 1, 0, 0, 1, 0],
    [0, 0, 0, 0, 1, 0]
  ]
  let init = [0, 0]
  let goal = [len(grid) - 1, len(grid[0]) - 1]
  let cost = 1

  var heuristic: list<list<int>> = []
  var i = 0
  while i < len(grid) {
    var row: list<int> = []
    var j = 0
    while j < len(grid[0]) {
      let h = iabs(i - goal[0]) + iabs(j - goal[1])
      if grid[i][j] == 1 {
        row = append(row, 99)
      } else {
        row = append(row, h)
      }
      j = j + 1
    }
    heuristic = append(heuristic, row)
    i = i + 1
  }

  let result = search(grid, init, goal, cost, heuristic)
  print("ACTION MAP")
  var rr = 0
  while rr < len(result.action) {
    print(result.action[rr])
    rr = rr + 1
  }
  var p = 0
  while p < len(result.path) {
    print(result.path[p])
    p = p + 1
  }
}

main()
