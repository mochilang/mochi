/*
Given a set of non‑negative integers and a target value M,
the sum of subsets problem asks for all subsets of the set
whose elements add up exactly to M. Each element may be used
at most once.

We build a state‑space tree where each level decides whether
to include the next element from the input list. The search
is depth‑first and branches are pruned when:
  * the accumulated sum already exceeds M, or
  * even if we add all remaining numbers the target cannot be
    reached.

Valid subsets are collected whenever the running sum equals
M.
*/

fun sum_list(nums: list<int>): int {
  var s = 0
  for n in nums {
    s = s + n
  }
  return s
}

fun create_state_space_tree(nums: list<int>, max_sum: int, num_index: int,
    path: list<int>, curr_sum: int, remaining_sum: int): list<list<int>> {
  var result: list<list<int>> = []
  if curr_sum > max_sum || curr_sum + remaining_sum < max_sum { return result }
  if curr_sum == max_sum {
    result = append(result, path)
    return result
  }
  var index = num_index
  while index < len(nums) {
    let value = nums[index]
    let subres = create_state_space_tree(
      nums, max_sum, index + 1, append(path, value),
      curr_sum + value, remaining_sum - value)
    var j = 0
    while j < len(subres) {
      result = append(result, subres[j])
      j = j + 1
    }
    index = index + 1
  }
  return result
}

fun generate_sum_of_subsets_solutions(nums: list<int>, max_sum: int): list<list<int>> {
  let total = sum_list(nums)
  return create_state_space_tree(nums, max_sum, 0, [], 0, total)
}

fun main() {
  json(generate_sum_of_subsets_solutions([3,34,4,12,5,2], 9))
}

main()
