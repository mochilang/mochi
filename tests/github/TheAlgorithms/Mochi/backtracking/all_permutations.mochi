/*
Generate all permutations of a sequence using recursive backtracking.

A state space tree is explored depth-first.  At depth `index`, choose an
unused element from the input, append it to the current permutation, and
recurse to build the next level.  A boolean list tracks which positions in
the original sequence have already been used so that each element appears
exactly once per permutation.  When `index` reaches the sequence length the
current permutation is complete and printed.

This explores n! leaves and each leaf prints a permutation of length n, for
an overall time complexity of O(n! * n).
*/

fun repeat_bool(times: int): list<bool> {
  var res: list<bool> = []
  var i = 0
  while i < times {
    res = append(res, false)
    i = i + 1
  }
  return res
}

fun set_bool(xs: list<bool>, idx: int, value: bool): list<bool> {
  var res: list<bool> = []
  var i = 0
  while i < len(xs) {
    if i == idx {
      res = append(res, value)
    } else {
      res = append(res, xs[i])
    }
    i = i + 1
  }
  return res
}

fun create_state_space_tree(
  sequence: list<any>,
  current: list<any>,
  index: int,
  used: list<bool>
) {
  if index == len(sequence) {
    print(str(current))
    return
  }
  var i = 0
  while i < len(sequence) {
    if !used[i] {
      let next_current = append(current, sequence[i])
      let next_used = set_bool(used, i, true)
      create_state_space_tree(sequence, next_current, index + 1, next_used)
    }
    i = i + 1
  }
}

fun generate_all_permutations(sequence: list<any>) {
  let used = repeat_bool(len(sequence))
  create_state_space_tree(sequence, [] as list<any>, 0, used)
}

let sequence: list<any> = [3, 1, 2, 4]
generate_all_permutations(sequence)

let sequence_2: list<any> = ["A", "B", "C"]
generate_all_permutations(sequence_2)
