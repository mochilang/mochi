/*
Power Sum - Backtracking

Given a target integer X and a power N, count the number of ways
X can be expressed as the sum of unique natural numbers each
raised to the power N.  For example, X = 13 and N = 2 has a single
solution: 2^2 + 3^2.  The algorithm explores numbers incrementally
and at each step chooses to include or exclude the current number's
N-th power provided the partial sum does not exceed the target.
This ensures all combinations use distinct numbers.
*/

fun int_pow(base: int, exp: int): int {
  var result = 1
  var i = 0
  while i < exp {
    result = result * base
    i = i + 1
  }
  return result
}

fun backtrack(target: int, exp: int, current: int, current_sum: int): int {
  if current_sum == target {
    return 1
  }
  let p = int_pow(current, exp)
  var count = 0
  if current_sum + p <= target {
    count = count + backtrack(target, exp, current + 1, current_sum + p)
  }
  if p < target {
    count = count + backtrack(target, exp, current + 1, current_sum)
  }
  return count
}

fun solve(target: int, exp: int): int {
  if !(1 <= target && target <= 1000 && 2 <= exp && exp <= 10) {
    print("Invalid input")
    return 0
  }
  return backtrack(target, exp, 1, 0)
}

print(solve(13, 2))
print(solve(10, 2))
print(solve(10, 3))
