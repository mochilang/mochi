/*
Minimum Coin Change
-------------------
Given an array of coin denominations `s` and a target amount `n`, compute
how many distinct ways there are to make change for `n` using any number of
coins from `s`. We use dynamic programming with a table `table` where
`table[i]` stores the number of ways to make amount `i`. Initialize the table
with `table[0] = 1` (one way to make zero). For each coin value, update the
table from that value up to `n`, adding the number of ways to make the
remaining amount `j - coin_val`. The final answer is `table[n]`.

Time Complexity: O(m * n) where m is the number of coin types
Space Complexity: O(n)
*/

fun dp_count(s: list<int>, n: int): int {
  if n < 0 { return 0 }
  var table: list<int> = []
  var i = 0
  while i <= n {
    table = append(table, 0)
    i = i + 1
  }
  table[0] = 1
  var idx = 0
  while idx < len(s) {
    let coin_val = s[idx]
    var j = coin_val
    while j <= n {
      table[j] = table[j] + table[j - coin_val]
      j = j + 1
    }
    idx = idx + 1
  }
  return table[n]
}

print(dp_count([1, 2, 3], 4))
print(dp_count([1, 2, 3], 7))
print(dp_count([2, 5, 3, 6], 10))
print(dp_count([10], 99))
print(dp_count([4, 5, 6], 0))
print(dp_count([1, 2, 3], -5))
