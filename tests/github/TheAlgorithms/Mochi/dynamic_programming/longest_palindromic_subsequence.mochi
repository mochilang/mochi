/*
Longest Palindromic Subsequence

Given a string, determine the length of the longest subsequence of
characters that forms a palindrome. A subsequence does not require the
characters to be contiguous. This implementation mirrors the classic
approach of computing the Longest Common Subsequence (LCS) between the
string and its reverse.

Algorithm:
1. Reverse the input string.
2. Allocate a (n+1) x (n+1) dynamic programming table initialised to 0.
   Here n is the length of the input string and its reverse.
3. For each pair of positions (i, j):
   - If the characters match, extend the previous subsequence length
     by one: dp[i][j] = 1 + dp[i-1][j-1].
   - Otherwise take the maximum of skipping a character from either
     string: dp[i][j] = max(dp[i-1][j], dp[i][j-1]).
4. The bottom-right cell contains the length of the longest palindromic
   subsequence.

The algorithm runs in O(n^2) time and uses O(n^2) space.
*/

fun reverse(s: string): string {
  var result = ""
  var i = len(s) - 1
  while i >= 0 {
    result = result + s[i:i+1]
    i = i - 1
  }
  return result
}

fun max_int(a: int, b: int): int {
  if a > b { return a }
  return b
}

fun longest_palindromic_subsequence(s: string): int {
  let rev = reverse(s)
  let n = len(s)
  let m = len(rev)
  var dp: list<list<int>> = []
  var i = 0
  while i <= n {
    var row: list<int> = []
    var j = 0
    while j <= m {
      row = append(row, 0)
      j = j + 1
    }
    dp = append(dp, row)
    i = i + 1
  }
  i = 1
  while i <= n {
    var j = 1
    while j <= m {
      let a_char = s[i-1:i]
      let b_char = rev[j-1:j]
      if a_char == b_char {
        dp[i][j] = 1 + dp[i - 1][j - 1]
      } else {
        dp[i][j] = max_int(dp[i - 1][j], dp[i][j - 1])
      }
      j = j + 1
    }
    i = i + 1
  }
  return dp[n][m]
}

print(str(longest_palindromic_subsequence("bbbab")))
print(str(longest_palindromic_subsequence("bbabcbcab")))
