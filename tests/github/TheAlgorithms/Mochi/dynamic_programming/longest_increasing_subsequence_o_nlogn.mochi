/*
Longest Increasing Subsequence Length (O(n log n))

Given a list of integers, compute the length of the longest strictly
increasing subsequence (LIS).  This implementation follows the classic
patience sorting approach where we maintain a ``tail`` array such that
``tail[i]`` holds the smallest possible tail value of an increasing
subsequence of length ``i + 1``.  For each number in the input list we
either extend the current LIS if it is larger than all tails, replace
an existing tail using binary search, or update the first tail if it is
smaller.  A helper function performs a binary search to find the lowest
index whose value is greater than or equal to the current element.
The algorithm runs in ``O(n log n)`` time and ``O(n)`` space.
*/

fun ceil_index(v: list<int>, left: int, right: int, key: int): int {
  var l = left
  var r = right
  while r - l > 1 {
    let middle = (l + r) / 2
    if v[middle] >= key {
      r = middle
    } else {
      l = middle
    }
  }
  return r
}

fun longest_increasing_subsequence_length(v: list<int>): int {
  if len(v) == 0 {
    return 0
  }
  var tail: list<int> = []
  var i = 0
  while i < len(v) {
    tail = append(tail, 0)
    i = i + 1
  }
  var length = 1
  tail[0] = v[0]
  var j = 1
  while j < len(v) {
    if v[j] < tail[0] {
      tail[0] = v[j]
    } else if v[j] > tail[length - 1] {
      tail[length] = v[j]
      length = length + 1
    } else {
      let idx = ceil_index(tail, -1, length - 1, v[j])
      tail[idx] = v[j]
    }
    j = j + 1
  }
  return length
}

fun main() {
  let example1: list<int> = [2, 5, 3, 7, 11, 8, 10, 13, 6]
  let example2: list<int> = []
  let example3: list<int> = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]
  let example4: list<int> = [5, 4, 3, 2, 1]
  print(longest_increasing_subsequence_length(example1))
  print(longest_increasing_subsequence_length(example2))
  print(longest_increasing_subsequence_length(example3))
  print(longest_increasing_subsequence_length(example4))
}

main()
