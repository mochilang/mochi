/*
Wildcard pattern matching using dynamic programming.

Given an input string `s` and pattern `p` containing `?` and `*`, determine
if the entire string matches the pattern. `?` matches any single character,
while `*` matches any sequence of characters (including empty).
We construct an (n+1) x (m+1) boolean table `dp` where `dp[i][j]` represents
whether the first `i` characters of `s` match the first `j` characters of `p`.
Transitions:
  - If `p[j-1]` equals `s[i-1]` or is `?`, then `dp[i][j] = dp[i-1][j-1]`.
  - If `p[j-1]` is `*`, then `dp[i][j] = dp[i-1][j] || dp[i][j-1]`
    (consume a character from `s` or treat `*` as empty).
The first row is initialized to handle leading `*` characters in the pattern.
The algorithm runs in `O(n*m)` time and uses `O(n*m)` space.
*/

fun make_bool_list(n: int): list<bool> {
  var row: list<bool> = []
  var i = 0
  while i < n {
    row = append(row, false)
    i = i + 1
  }
  return row
}

fun make_bool_matrix(rows: int, cols: int): list<list<bool>> {
  var matrix: list<list<bool>> = []
  var i = 0
  while i < rows {
    matrix = append(matrix, make_bool_list(cols))
    i = i + 1
  }
  return matrix
}

fun is_match(s: string, p: string): bool {
  let n = len(s)
  let m = len(p)
  var dp = make_bool_matrix(n + 1, m + 1)
  dp[0][0] = true

  var j = 1
  while j <= m {
    if p[j-1:j] == "*" {
      dp[0][j] = dp[0][j-1]
    }
    j = j + 1
  }

  var i = 1
  while i <= n {
    var j2 = 1
    while j2 <= m {
      let pc = p[j2-1:j2]
      let sc = s[i-1:i]
      if pc == sc || pc == "?" {
        dp[i][j2] = dp[i-1][j2-1]
      } else if pc == "*" {
        if dp[i-1][j2] || dp[i][j2-1] {
          dp[i][j2] = true
        }
      }
      j2 = j2 + 1
    }
    i = i + 1
  }
  return dp[n][m]
}

fun print_bool(b: bool) {
  if b {
    print("true")
  } else {
    print("false")
  }
}

print_bool(is_match("abc", "a*c"))
print_bool(is_match("abc", "a*d"))
print_bool(is_match("baaabab", "*****ba*****ab"))
