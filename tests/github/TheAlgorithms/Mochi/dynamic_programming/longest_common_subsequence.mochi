/*
Longest Common Subsequence
-------------------------
Given two strings, find the longest subsequence present in both.
This dynamic programming approach builds a (m+1) x (n+1) table where
`dp[i][j]` stores the length of the LCS of prefixes `x[:i]` and `y[:j]`.
After filling the table, we reconstruct the subsequence by tracing
back from `dp[m][n]`, moving diagonally when characters match and
otherwise moving toward the larger neighboring cell.
This runs in O(m * n) time and O(m * n) space.
*/

type LcsResult { length: int, sequence: string }

fun zeros_matrix(rows: int, cols: int): list<list<int>> {
  var matrix: list<list<int>> = []
  var i = 0
  while i <= rows {
    var row: list<int> = []
    var j = 0
    while j <= cols {
      row = append(row, 0)
      j = j + 1
    }
    matrix = append(matrix, row)
    i = i + 1
  }
  return matrix
}

fun longest_common_subsequence(x: string, y: string): LcsResult {
  let m = len(x)
  let n = len(y)
  var dp = zeros_matrix(m, n)

  var i = 1
  while i <= m {
    var j = 1
    while j <= n {
      if x[i - 1] == y[j - 1] {
        dp[i][j] = dp[i - 1][j - 1] + 1
      } else {
        if dp[i - 1][j] > dp[i][j - 1] {
          dp[i][j] = dp[i - 1][j]
        } else {
          dp[i][j] = dp[i][j - 1]
        }
      }
      j = j + 1
    }
    i = i + 1
  }

  var seq = ""
  var i2 = m
  var j2 = n
  while i2 > 0 && j2 > 0 {
    if x[i2 - 1] == y[j2 - 1] {
      seq = x[i2 - 1] + seq
      i2 = i2 - 1
      j2 = j2 - 1
    } else if dp[i2 - 1][j2] >= dp[i2][j2 - 1] {
      i2 = i2 - 1
    } else {
      j2 = j2 - 1
    }
  }

  return LcsResult { length: dp[m][n], sequence: seq }
}

let a = "AGGTAB"
let b = "GXTXAYB"
let res = longest_common_subsequence(a, b)
print("len = " + str(res.length) + ", sub-sequence = " + res.sequence)
