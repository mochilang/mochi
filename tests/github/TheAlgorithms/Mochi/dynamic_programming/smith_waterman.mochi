/*
Smith-Waterman Local Sequence Alignment
---------------------------------------
This algorithm finds the optimal local alignment between two sequences using
dynamic programming with a linear gap penalty. It first builds a score matrix
where each cell represents the best score for aligning prefixes ending at that
position. Scores are determined by matches, mismatches, and gaps. The maximum
cell value indicates the end of the best local alignment. A traceback from this
cell reconstructs the aligned subsequences by following the path that yielded
the optimal score.
*/

fun score_function(source_char: string, target_char: string, match_score: int, mismatch_score: int, gap_score: int): int {
  if source_char == "-" || target_char == "-" {
    return gap_score
  }
  if source_char == target_char {
    return match_score
  }
  return mismatch_score
}

fun smith_waterman(query: string, subject: string, match_score: int, mismatch_score: int, gap_score: int): list<list<int>> {
  let q = upper(query)
  let s = upper(subject)
  let m = len(q)
  let n = len(s)
  var score: list<list<int>> = []
  for _ in 0..(m + 1) {
    var row: list<int> = []
    for _2 in 0..(n + 1) {
      row = append(row, 0)
    }
    score = append(score, row)
  }
  for i in 1..(m + 1) {
    for j in 1..(n + 1) {
      let qc = substring(q, i - 1, i)
      let sc = substring(s, j - 1, j)
      let diag = score[i - 1][j - 1] + score_function(qc, sc, match_score, mismatch_score, gap_score)
      let delete = score[i - 1][j] + gap_score
      let insert = score[i][j - 1] + gap_score
      var max_val = 0
      if diag > max_val { max_val = diag }
      if delete > max_val { max_val = delete }
      if insert > max_val { max_val = insert }
      score[i][j] = max_val
    }
  }
  return score
}

fun traceback(score: list<list<int>>, query: string, subject: string, match_score: int, mismatch_score: int, gap_score: int): string {
  let q = upper(query)
  let s = upper(subject)
  var max_value = 0
  var i_max = 0
  var j_max = 0
  for i in 0..len(score) {
    for j in 0..len(score[i]) {
      if score[i][j] > max_value {
        max_value = score[i][j]
        i_max = i
        j_max = j
      }
    }
  }
  var i = i_max
  var j = j_max
  var align1 = ""
  var align2 = ""
  let gap_penalty = score_function("-", "-", match_score, mismatch_score, gap_score)
  if i == 0 || j == 0 {
    return ""
  }
  while i > 0 && j > 0 {
    let qc = substring(q, i - 1, i)
    let sc = substring(s, j - 1, j)
    if score[i][j] == score[i - 1][j - 1] + score_function(qc, sc, match_score, mismatch_score, gap_score) {
      align1 = qc + align1
      align2 = sc + align2
      i = i - 1
      j = j - 1
    } else if score[i][j] == score[i - 1][j] + gap_penalty {
      align1 = qc + align1
      align2 = "-" + align2
      i = i - 1
    } else {
      align1 = "-" + align1
      align2 = sc + align2
      j = j - 1
    }
  }
  return align1 + "\n" + align2
}

let query = "HEAGAWGHEE"
let subject = "PAWHEAE"
let score = smith_waterman(query, subject, 1, -1, -2)
print(traceback(score, query, subject, 1, -1, -2))
