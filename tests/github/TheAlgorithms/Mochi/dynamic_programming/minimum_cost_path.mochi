/*
Minimum Cost Path in a Grid

Given a matrix of non-negative integers where each cell represents the cost of
stepping on it, determine the minimum total cost to travel from the top-left
corner to the bottom-right corner. Movement is restricted to only right or down
at any step.

Algorithm
1. Accumulate costs along the first row so each cell stores the cost to reach it
   from the left.
2. Accumulate costs along the first column so each cell stores the cost to reach
   it from above.
3. For every remaining cell, add the smaller of the two possible previous costs:
   the cell above or the cell to the left.
4. The bottom-right cell then contains the minimal path cost.

The algorithm runs in O(rows * cols) time and updates the matrix in-place,
requiring only O(1) extra space.
*/

fun min_int(a: int, b: int): int {
  if a < b { return a }
  return b
}

fun minimum_cost_path(matrix: list<list<int>>): int {
  let rows = len(matrix)
  let cols = len(matrix[0])

  var j = 1
  while j < cols {
    var row0: list<int> = matrix[0]
    row0[j] = row0[j] + row0[j - 1]
    matrix[0] = row0
    j = j + 1
  }

  var i = 1
  while i < rows {
    var row: list<int> = matrix[i]
    row[0] = row[0] + matrix[i - 1][0]
    matrix[i] = row
    i = i + 1
  }

  i = 1
  while i < rows {
    var row: list<int> = matrix[i]
    j = 1
    while j < cols {
      let up = matrix[i - 1][j]
      let left = row[j - 1]
      let best = min_int(up, left)
      row[j] = row[j] + best
      j = j + 1
    }
    matrix[i] = row
    i = i + 1
  }

  return matrix[rows - 1][cols - 1]
}

var m1: list<list<int>> = [[2, 1], [3, 1], [4, 2]]
var m2: list<list<int>> = [[2, 1, 4], [2, 1, 3], [3, 2, 1]]
print(str(minimum_cost_path(m1)))
print(str(minimum_cost_path(m2)))
