/*
Z-Function for Pattern Matching
-------------------------------
The Z-function of a string computes for every position the length of the
longest substring starting at that position which matches a prefix of the
string.  It can be used to find pattern occurrences efficiently in linear time.

Algorithm:
1. Initialize an array `z` of zeros with the same length as the string.
2. Maintain a window `[l, r]` that represents the current segment which matches
a prefix of the string.
3. For each index `i` from 1 to n-1:
   a. If `i` lies within `[l, r]`, initialize `z[i]` with the minimum of
      `r - i + 1` and `z[i - l]`.
   b. Extend the match by comparing characters while they are equal.
   c. If the new segment extends beyond `r`, update `[l, r]`.

Using the Z-function, a pattern can be searched in a text by computing the
Z-values of the concatenated string `pattern + text` and counting indices where
`z[i]` is at least the pattern length.
*/

fun z_function(s: string): list<int> {
  var z: list<int> = []
  var i = 0
  while i < len(s) {
    z = append(z, 0)
    i = i + 1
  }
  var l = 0
  var r = 0
  i = 1
  while i < len(s) {
    if i <= r {
      var min_edge = r - i + 1
      let zi = z[i - l]
      if zi < min_edge { min_edge = zi }
      z[i] = min_edge
    }
    while go_next(i, z, s) {
      z[i] = z[i] + 1
    }
    if i + z[i] - 1 > r {
      l = i
      r = i + z[i] - 1
    }
    i = i + 1
  }
  return z
}

fun go_next(i: int, z: list<int>, s: string): bool {
  return i + z[i] < len(s) && s[z[i]] == s[i + z[i]]
}

fun find_pattern(pattern: string, input_str: string): int {
  var answer = 0
  let z_res = z_function(pattern + input_str)
  var i = 0
  while i < len(z_res) {
    if z_res[i] >= len(pattern) {
      answer = answer + 1
    }
    i = i + 1
  }
  return answer
}

fun list_eq_int(a: list<int>, b: list<int>): bool {
  if len(a) != len(b) { return false }
  var i = 0
  while i < len(a) {
    if a[i] != b[i] { return false }
    i = i + 1
  }
  return true
}

fun test_z_function() {
  let s1 = "abracadabra"
  let expected1: list<int> = [0, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1]
  let r1 = z_function(s1)
  if !list_eq_int(r1, expected1) { panic("z_function abracadabra failed") }

  let s2 = "aaaa"
  let expected2: list<int> = [0, 3, 2, 1]
  let r2 = z_function(s2)
  if !list_eq_int(r2, expected2) { panic("z_function aaaa failed") }

  let s3 = "zxxzxxz"
  let expected3: list<int> = [0, 0, 0, 4, 0, 0, 1]
  let r3 = z_function(s3)
  if !list_eq_int(r3, expected3) { panic("z_function zxxzxxz failed") }
}

fun test_find_pattern() {
  if find_pattern("abr", "abracadabra") != 2 { panic("find_pattern abr failed") }
  if find_pattern("a", "aaaa") != 4 { panic("find_pattern aaaa failed") }
  if find_pattern("xz", "zxxzxxz") != 2 { panic("find_pattern xz failed") }
}

fun main() {
  test_z_function()
  test_find_pattern()
  let r1 = z_function("abracadabra")
  let r2 = z_function("aaaa")
  let r3 = z_function("zxxzxxz")
  print(str(r1))
  print(str(r2))
  print(str(r3))
  print(str(find_pattern("abr", "abracadabra")))
  print(str(find_pattern("a", "aaaa")))
  print(str(find_pattern("xz", "zxxzxxz")))
}

main()
