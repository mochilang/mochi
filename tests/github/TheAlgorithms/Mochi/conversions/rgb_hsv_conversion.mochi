/*
Convert colors between RGB and HSV representations.

RGB expresses colors as intensities of red, green, and blue in the range 0-255.
HSV models colors by hue (0-360 degrees on the color wheel), saturation
(0-1 from gray to fully saturated), and value (0-1 from dark to bright).

Algorithms:
1. hsv_to_rgb
   - Validate ranges for hue, saturation, and value.
   - Compute chroma = value * saturation.
   - Determine the hue sector on the color wheel and the second largest
     component using the formula chroma * (1 - |(hue/60 mod 2) - 1|).
   - Adjust with match value = value - chroma and assign the three RGB
     channels based on the hue sector.
   - Scale to 0-255 and round to the nearest integer.
2. rgb_to_hsv
   - Validate RGB components.
   - Normalize to [0,1] and compute value (max), chroma (difference with min),
     and saturation.
   - Hue depends on which RGB component is maximal.
   - Normalize hue into [0,360) using modulo.
3. approximately_equal_hsv
   - Utility to check two HSV triples for near equality within small tolerances.

Both conversions run in constant time O(1) using arithmetic operations only.
*/

fun absf(x: float): float {
  if x < 0.0 { return -x }
  return x
}

fun roundi(x: float): int {
  if x >= 0.0 { return (x + 0.5) as int }
  return (x - 0.5) as int
}

fun floorf(x: float): float {
  return (x as int) as float
}

fun modf(a: float, b: float): float {
  return a - b * floorf(a / b)
}

fun max3(a: float, b: float, c: float): float {
  var m = if a > b { a } else { b }
  m = if m > c { m } else { c }
  return m
}

fun min3(a: float, b: float, c: float): float {
  var m = if a < b { a } else { b }
  m = if m < c { m } else { c }
  return m
}

fun hsv_to_rgb(hue: float, saturation: float, value: float): list<int> {
  if hue < 0.0 || hue > 360.0 { panic("hue should be between 0 and 360") }
  if saturation < 0.0 || saturation > 1.0 { panic("saturation should be between 0 and 1") }
  if value < 0.0 || value > 1.0 { panic("value should be between 0 and 1") }

  let chroma = value * saturation
  let hue_section = hue / 60.0
  let second_largest_component = chroma * (1.0 - absf(modf(hue_section, 2.0) - 1.0))
  let match_value = value - chroma

  var red = 0
  var green = 0
  var blue = 0

  if hue_section >= 0.0 && hue_section <= 1.0 {
    red = roundi(255.0 * (chroma + match_value))
    green = roundi(255.0 * (second_largest_component + match_value))
    blue = roundi(255.0 * match_value)
  } else {
    if hue_section > 1.0 && hue_section <= 2.0 {
      red = roundi(255.0 * (second_largest_component + match_value))
      green = roundi(255.0 * (chroma + match_value))
      blue = roundi(255.0 * match_value)
    } else {
      if hue_section > 2.0 && hue_section <= 3.0 {
        red = roundi(255.0 * match_value)
        green = roundi(255.0 * (chroma + match_value))
        blue = roundi(255.0 * (second_largest_component + match_value))
      } else {
        if hue_section > 3.0 && hue_section <= 4.0 {
          red = roundi(255.0 * match_value)
          green = roundi(255.0 * (second_largest_component + match_value))
          blue = roundi(255.0 * (chroma + match_value))
        } else {
          if hue_section > 4.0 && hue_section <= 5.0 {
            red = roundi(255.0 * (second_largest_component + match_value))
            green = roundi(255.0 * match_value)
            blue = roundi(255.0 * (chroma + match_value))
          } else {
            red = roundi(255.0 * (chroma + match_value))
            green = roundi(255.0 * match_value)
            blue = roundi(255.0 * (second_largest_component + match_value))
          }
        }
      }
    }
  }

  return [red, green, blue]
}

fun rgb_to_hsv(red: int, green: int, blue: int): list<float> {
  if red < 0 || red > 255 { panic("red should be between 0 and 255") }
  if green < 0 || green > 255 { panic("green should be between 0 and 255") }
  if blue < 0 || blue > 255 { panic("blue should be between 0 and 255") }

  let float_red = (red as float) / 255.0
  let float_green = (green as float) / 255.0
  let float_blue = (blue as float) / 255.0

  let value = max3(float_red, float_green, float_blue)
  let min_val = min3(float_red, float_green, float_blue)
  let chroma = value - min_val
  let saturation = if value == 0.0 { 0.0 } else { chroma / value }

  var hue = 0.0
  if chroma == 0.0 {
    hue = 0.0
  } else {
    if value == float_red {
      hue = 60.0 * (0.0 + (float_green - float_blue) / chroma)
    } else {
      if value == float_green {
        hue = 60.0 * (2.0 + (float_blue - float_red) / chroma)
      } else {
        hue = 60.0 * (4.0 + (float_red - float_green) / chroma)
      }
    }
  }
  hue = hue + 360.0
  hue = hue - 360.0 * floorf(hue / 360.0)

  return [hue, saturation, value]
}

fun approximately_equal_hsv(hsv1: list<float>, hsv2: list<float>): bool {
  let check_hue = absf(hsv1[0] - hsv2[0]) < 0.2
  let check_saturation = absf(hsv1[1] - hsv2[1]) < 0.002
  let check_value = absf(hsv1[2] - hsv2[2]) < 0.002
  return check_hue && check_saturation && check_value
}

fun list_int_to_string(xs: list<int>): string {
  var res = "["
  var i = 0
  while i < len(xs) {
    if i > 0 { res = res + ", " }
    res = res + str(xs[i])
    i = i + 1
  }
  res = res + "]"
  return res
}

fun list_float_to_string(xs: list<float>): string {
  var res = "["
  var i = 0
  while i < len(xs) {
    if i > 0 { res = res + ", " }
    res = res + str(xs[i])
    i = i + 1
  }
  res = res + "]"
  return res
}

let rgb1 = hsv_to_rgb(0.0, 0.0, 0.0)
let rgb2 = hsv_to_rgb(60.0, 1.0, 1.0)
let rgb3 = hsv_to_rgb(180.0, 0.5, 0.5)
print(list_int_to_string(rgb1))
print(list_int_to_string(rgb2))
print(list_int_to_string(rgb3))

let hsv1 = rgb_to_hsv(255, 0, 0)
let hsv2 = rgb_to_hsv(64, 128, 128)
print(list_float_to_string(hsv1))
print(list_float_to_string(hsv2))
print(str(approximately_equal_hsv(hsv1, [0.0, 1.0, 1.0])))
