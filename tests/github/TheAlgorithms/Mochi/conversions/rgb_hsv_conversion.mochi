/*
RGB-HSV Color Conversion

This module converts colors between the RGB (red, green, blue) and
HSV (hue, saturation, value) color models.  The HSV model represents
colors in terms of angle, intensity, and brightness while RGB uses
component intensities in [0, 255].

hsv_to_rgb computes RGB components from HSV by determining the hue
sector, constructing the chroma and secondary component, and then
adjusting with the match value.

rgb_to_hsv derives HSV values from RGB by measuring the chroma and
identifying which RGB component is dominant.  Hue is based on the
relative differences while saturation and value describe the color's
vividness and brightness.

approximately_equal_hsv compares two HSV triplets allowing small
numerical tolerances so round-trip conversions can be validated.
*/

fun absf(x: float): float {
  if x < 0.0 {
    return -x
  }
  return x
}

fun fmod(a: float, b: float): float {
  return a - b * int(a / b)
}

fun roundf(x: float): int {
  if x >= 0.0 {
    return int(x + 0.5)
  }
  return int(x - 0.5)
}
fun maxf(a: float, b: float, c: float): float {
  var m = a
  if b > m { m = b }
  if c > m { m = c }
  return m
}

fun minf(a: float, b: float, c: float): float {
  var m = a
  if b < m { m = b }
  if c < m { m = c }
  return m
}


fun hsv_to_rgb(hue: float, saturation: float, value: float): list<int> {
  if hue < 0.0 || hue > 360.0 {
    print("hue should be between 0 and 360")
    return []
  }
  if saturation < 0.0 || saturation > 1.0 {
    print("saturation should be between 0 and 1")
    return []
  }
  if value < 0.0 || value > 1.0 {
    print("value should be between 0 and 1")
    return []
  }
  let chroma = value * saturation
  let hue_section = hue / 60.0
  let second_largest_component = chroma * (1.0 - absf(fmod(hue_section, 2.0) - 1.0))
  let match_value = value - chroma
  var red: int
  var green: int
  var blue: int
  if hue_section >= 0.0 && hue_section <= 1.0 {
    red = roundf(255.0 * (chroma + match_value))
    green = roundf(255.0 * (second_largest_component + match_value))
    blue = roundf(255.0 * match_value)
  } else if hue_section > 1.0 && hue_section <= 2.0 {
    red = roundf(255.0 * (second_largest_component + match_value))
    green = roundf(255.0 * (chroma + match_value))
    blue = roundf(255.0 * match_value)
  } else if hue_section > 2.0 && hue_section <= 3.0 {
    red = roundf(255.0 * match_value)
    green = roundf(255.0 * (chroma + match_value))
    blue = roundf(255.0 * (second_largest_component + match_value))
  } else if hue_section > 3.0 && hue_section <= 4.0 {
    red = roundf(255.0 * match_value)
    green = roundf(255.0 * (second_largest_component + match_value))
    blue = roundf(255.0 * (chroma + match_value))
  } else if hue_section > 4.0 && hue_section <= 5.0 {
    red = roundf(255.0 * (second_largest_component + match_value))
    green = roundf(255.0 * match_value)
    blue = roundf(255.0 * (chroma + match_value))
  } else {
    red = roundf(255.0 * (chroma + match_value))
    green = roundf(255.0 * match_value)
    blue = roundf(255.0 * (second_largest_component + match_value))
  }
  return [red, green, blue]
}

fun rgb_to_hsv(red: int, green: int, blue: int): list<float> {
  if red < 0 || red > 255 {
    print("red should be between 0 and 255")
    return []
  }
  if green < 0 || green > 255 {
    print("green should be between 0 and 255")
    return []
  }
  if blue < 0 || blue > 255 {
    print("blue should be between 0 and 255")
    return []
  }
  let float_red: float = red / 255.0
  let float_green: float = green / 255.0
  let float_blue: float = blue / 255.0
  let value: float = maxf(float_red, float_green, float_blue)
  let min_val: float = minf(float_red, float_green, float_blue)
  let chroma = value - min_val
  let saturation = if value == 0.0 { 0.0 } else { chroma / value }
  var hue: float
  if chroma == 0.0 {
    hue = 0.0
  } else if value == float_red {
    hue = 60.0 * (0.0 + (float_green - float_blue) / chroma)
  } else if value == float_green {
    hue = 60.0 * (2.0 + (float_blue - float_red) / chroma)
  } else {
    hue = 60.0 * (4.0 + (float_red - float_green) / chroma)
  }
  hue = fmod(hue + 360.0, 360.0)
  return [hue, saturation, value]
}

fun approximately_equal_hsv(hsv1: list<float>, hsv2: list<float>): bool {
  let check_hue = absf(hsv1[0] - hsv2[0]) < 0.2
  let check_saturation = absf(hsv1[1] - hsv2[1]) < 0.002
  let check_value = absf(hsv1[2] - hsv2[2]) < 0.002
  return check_hue && check_saturation && check_value
}

let rgb = hsv_to_rgb(180.0, 0.5, 0.5)
print(str(rgb))
let hsv = rgb_to_hsv(64, 128, 128)
print(str(hsv))
print(str(approximately_equal_hsv(hsv, [180.0, 0.5, 0.5])))
