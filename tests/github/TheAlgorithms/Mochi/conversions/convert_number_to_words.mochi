/*
Convert a non-negative integer into its English words representation for
three numbering systems: short scale, long scale, and the Indian system.
Each system defines groups of digits (thousand, lakh, etc.). The algorithm
recursively extracts digit groups using powers of ten, converts each group
into words (handling irregular numbers below one hundred), and appends the
associated unit. Negative values are prefixed with "negative" and inputs are
validated against each system's maximum supported value. The complexity is
O(d) where d is the number of digit groups in the input, proportional to the
logarithm base 10 of the number.
*/

let ones: list<string> = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
let teens: list<string> = ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"]
let tens: list<string> = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"]

let short_powers: list<int> = [15, 12, 9, 6, 3, 2]
let short_units: list<string> = ["quadrillion", "trillion", "billion", "million", "thousand", "hundred"]
let long_powers: list<int> = [15, 9, 6, 3, 2]
let long_units: list<string> = ["billiard", "milliard", "million", "thousand", "hundred"]
let indian_powers: list<int> = [14, 12, 7, 5, 3, 2]
let indian_units: list<string> = ["crore crore", "lakh crore", "crore", "lakh", "thousand", "hundred"]

fun pow10(exp: int): int {
  var res = 1
  var i = 0
  while i < exp {
    res = res * 10
    i = i + 1
  }
  return res
}

fun max_value(system: string): int {
  if system == "short" { return pow10(18) - 1 }
  if system == "long" { return pow10(21) - 1 }
  if system == "indian" { return pow10(19) - 1 }
  return 0
}

fun join_words(words: list<string>): string {
  var res = ""
  var i = 0
  while i < len(words) {
    if i > 0 { res = res + " " }
    res = res + words[i]
    i = i + 1
  }
  return res
}

fun convert_small_number(num: int): string {
  if num < 0 { return "" }
  if num >= 100 { return "" }
  let tens_digit = num / 10
  let ones_digit = num % 10
  if tens_digit == 0 { return ones[ones_digit] }
  if tens_digit == 1 { return teens[ones_digit] }
  let hyphen = if ones_digit > 0 { "-" } else "" 
  let tail = if ones_digit > 0 { ones[ones_digit] } else ""
  return tens[tens_digit] + hyphen + tail
}

fun convert_number(num: int, system: string): string {
  var word_groups: list<string> = []
  var n = num
  if n < 0 {
    word_groups = append(word_groups, "negative")
    n = -n
  }
  if n > max_value(system) { return "" }

  var powers: list<int> = []
  var units: list<string> = []
  if system == "short" {
    powers = short_powers
    units = short_units
  } else {
    if system == "long" {
      powers = long_powers
      units = long_units
    } else {
      if system == "indian" {
        powers = indian_powers
        units = indian_units
      } else {
        return ""
      }
    }
  }

  var i = 0
  while i < len(powers) {
    let power = powers[i]
    let unit = units[i]
    let divisor = pow10(power)
    let digit_group = n / divisor
    n = n % divisor
    if digit_group > 0 {
      let word_group = if digit_group >= 100 { convert_number(digit_group, system) } else { convert_small_number(digit_group) }
      word_groups = append(word_groups, word_group + " " + unit)
    }
    i = i + 1
  }

  if n > 0 || len(word_groups) == 0 {
    word_groups = append(word_groups, convert_small_number(n))
  }
  let joined = join_words(word_groups)
  return joined
}

print(convert_number(123456789012345, "short"))
print(convert_number(123456789012345, "long"))
print(convert_number(123456789012345, "indian"))
