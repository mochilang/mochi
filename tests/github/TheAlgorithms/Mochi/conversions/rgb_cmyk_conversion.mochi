/*
Convert an RGB color value to CMYK percentages.

Each input is a red, green, or blue component in the range 0..255. After
normalizing these values to the range [0,1], the algorithm computes the key
(black) component as 1 minus the maximum of the normalized channels. If the
color is pure black, cyan, magenta and yellow are all zero while the key is 100.

Otherwise the remaining color is expressed as percentages of cyan, magenta and
yellow after removing the black component:
  c = round(100 * (1 - r - k) / (1 - k))
  m = round(100 * (1 - g - k) / (1 - k))
  y = round(100 * (1 - b - k) / (1 - k))
  k = round(100 * k)

Inputs outside the 0..255 range cause a panic. All operations run in constant
time.
*/

fun round_int(x: float): int {
  return (x + 0.5) as int
}

fun rgb_to_cmyk(r_input: int, g_input: int, b_input: int): list<int> {
  if r_input < 0 || r_input >= 256 || g_input < 0 || g_input >= 256 || b_input < 0 || b_input >= 256 {
    panic("Expected int of the range 0..255")
  }
  let r = (r_input as float) / 255.0
  let g = (g_input as float) / 255.0
  let b = (b_input as float) / 255.0

  var max_val = r
  if g > max_val { max_val = g }
  if b > max_val { max_val = b }

  let k_float = 1.0 - max_val
  if k_float == 1.0 {
    return [0, 0, 0, 100]
  }
  let c_float = 100.0 * (1.0 - r - k_float) / (1.0 - k_float)
  let m_float = 100.0 * (1.0 - g - k_float) / (1.0 - k_float)
  let y_float = 100.0 * (1.0 - b - k_float) / (1.0 - k_float)
  let k_percent = 100.0 * k_float

  let c = round_int(c_float)
  let m = round_int(m_float)
  let y = round_int(y_float)
  let k = round_int(k_percent)
  return [c, m, y, k]
}

print(rgb_to_cmyk(255, 255, 255))  // white
print(rgb_to_cmyk(128, 128, 128))  // gray
print(rgb_to_cmyk(0, 0, 0))        // black
print(rgb_to_cmyk(255, 0, 0))      // red
print(rgb_to_cmyk(0, 255, 0))      // green
print(rgb_to_cmyk(0, 0, 255))      // blue

