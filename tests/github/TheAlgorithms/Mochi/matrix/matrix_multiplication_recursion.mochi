/*
Recursive matrix multiplication for square matrices.
The algorithm multiplies two n√ón matrices by simulating three
nested loops via a recursive helper. At each step, it accumulates the
product a[i][k] * b[k][j] into result[i][j] and advances indices i
(rows), j (columns), and k (inner dimension). The recursion unfolds
like the standard triple-loop matrix multiplication:

for i in range(n):
  for j in range(n):
    for k in range(n):
      result[i][j] += a[i][k] * b[k][j]

Matrices must be square and have matching dimensions; otherwise the
function panics. Time complexity is O(n^3).
*/

fun is_square(matrix: list<list<int>>): bool {
  let n = len(matrix)
  var i = 0
  while i < n {
    if len(matrix[i]) != n { return false }
    i = i + 1
  }
  return true
}

fun matrix_multiply(a: list<list<int>>, b: list<list<int>>): list<list<int>> {
  let rows = len(a)
  let cols = len(b[0])
  let inner = len(b)
  var result: list<list<int>> = []
  var i = 0
  while i < rows {
    var row: list<int> = []
    var j = 0
    while j < cols {
      var sum = 0
      var k = 0
      while k < inner {
        sum = sum + a[i][k] * b[k][j]
        k = k + 1
      }
      row = append(row, sum)
      j = j + 1
    }
    result = append(result, row)
    i = i + 1
  }
  return result
}

fun multiply(i: int, j: int, k: int, a: list<list<int>>, b: list<list<int>>, result: list<list<int>>, n: int, m: int) {
  if i >= n { return }
  if j >= m { multiply(i + 1, 0, 0, a, b, result, n, m); return }
  if k >= len(b) { multiply(i, j + 1, 0, a, b, result, n, m); return }
  result[i][j] = result[i][j] + a[i][k] * b[k][j]
  multiply(i, j, k + 1, a, b, result, n, m)
}

fun matrix_multiply_recursive(a: list<list<int>>, b: list<list<int>>): list<list<int>> {
  if len(a) == 0 || len(b) == 0 { return [] }
  if len(a) != len(b) || (!is_square(a)) || (!is_square(b)) {
    panic("Invalid matrix dimensions")
  }
  let n = len(a)
  let m = len(b[0])
  var result: list<list<int>> = []
  var i = 0
  while i < n {
    var row: list<int> = []
    var j = 0
    while j < m {
      row = append(row, 0)
      j = j + 1
    }
    result = append(result, row)
    i = i + 1
  }
  multiply(0, 0, 0, a, b, result, n, m)
  return result
}

let matrix_1_to_4: list<list<int>> = [[1, 2], [3, 4]]
let matrix_5_to_8: list<list<int>> = [[5, 6], [7, 8]]
let matrix_count_up: list<list<int>> = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
let matrix_unordered: list<list<int>> = [[5, 8, 1, 2], [6, 7, 3, 0], [4, 5, 9, 1], [2, 6, 10, 14]]

print(matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_8))
print(matrix_multiply_recursive(matrix_count_up, matrix_unordered))
