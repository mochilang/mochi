/*
Count the number of distinct paths from the top-left to the bottom-right
cell of a grid when movement is allowed in four directions and some cells
are blocked.  The grid contains 0s for open cells and 1s for blocked cells.
A depth-first search with backtracking explores the grid.  A 2â€‘D boolean
matrix tracks visited cells to avoid cycles.  When the search reaches the
bottom-right cell it counts one path.  The algorithm explores all
possibilities and runs in O(rows * cols) time for each path explored.
*/

fun depth_first_search(grid: list<list<int>>, row: int, col: int, visit: list<list<bool>>): int {
  let row_length = len(grid)
  let col_length = len(grid[0])
  if row < 0 || col < 0 || row == row_length || col == col_length {
    return 0
  }
  if visit[row][col] {
    return 0
  }
  if grid[row][col] == 1 {
    return 0
  }
  if row == row_length - 1 && col == col_length - 1 {
    return 1
  }
  visit[row][col] = true
  var count = 0
  count = count + depth_first_search(grid, row + 1, col, visit)
  count = count + depth_first_search(grid, row - 1, col, visit)
  count = count + depth_first_search(grid, row, col + 1, visit)
  count = count + depth_first_search(grid, row, col - 1, visit)
  visit[row][col] = false
  return count
}

fun count_paths(grid: list<list<int>>): int {
  let rows = len(grid)
  let cols = len(grid[0])
  var visit: list<list<bool>> = []
  var i = 0
  while i < rows {
    var row_visit: list<bool> = []
    var j = 0
    while j < cols {
      row_visit = append(row_visit, false)
      j = j + 1
    }
    visit = append(visit, row_visit)
    i = i + 1
  }
  return depth_first_search(grid, 0, 0, visit)
}

fun main() {
  let grid1 = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]
  print(str(count_paths(grid1)))
  let grid2 = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]
  print(str(count_paths(grid2)))
}

main()
