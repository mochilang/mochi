/*
Compute the inverse of a 2x2 or 3x3 matrix.

Given a square matrix A, its inverse A⁻¹ satisfies A * A⁻¹ = I.
This implementation handles only 2×2 and 3×3 matrices:

1. For a 2×2 matrix [[a, b], [c, d]], the determinant det = ad - bc.
   The inverse is (1/det) * [[d, -b], [-c, a]].
2. For a 3×3 matrix we use cofactor expansion:
   - Compute the determinant via Sarrus' rule.
   - Build the matrix of cofactors.
   - Transpose the cofactor matrix and divide by the determinant
     to obtain the inverse.

If the determinant is zero or the matrix is not 2×2 or 3×3 the
function prints an error message and returns an empty matrix.
*/

fun inverse_of_matrix(matrix: list<list<float>>): list<list<float>> {
  if len(matrix) == 2 && len(matrix[0]) == 2 && len(matrix[1]) == 2 {
    let det = matrix[0][0] * matrix[1][1] - matrix[1][0] * matrix[0][1]
    if det == 0.0 {
      print("This matrix has no inverse.")
      return []
    }
    return [
      [matrix[1][1] / det, -matrix[0][1] / det],
      [-matrix[1][0] / det, matrix[0][0] / det]
    ]
  } else if len(matrix) == 3 && len(matrix[0]) == 3 && len(matrix[1]) == 3 && len(matrix[2]) == 3 {
    let det =
      matrix[0][0] * matrix[1][1] * matrix[2][2] +
      matrix[0][1] * matrix[1][2] * matrix[2][0] +
      matrix[0][2] * matrix[1][0] * matrix[2][1] -
      (matrix[0][2] * matrix[1][1] * matrix[2][0] +
       matrix[0][1] * matrix[1][0] * matrix[2][2] +
       matrix[0][0] * matrix[1][2] * matrix[2][1])
    if det == 0.0 {
      print("This matrix has no inverse.")
      return []
    }
    var cof: list<list<float>> = [
      [0.0, 0.0, 0.0],
      [0.0, 0.0, 0.0],
      [0.0, 0.0, 0.0]
    ]
    cof[0][0] = matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]
    cof[0][1] = -(matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
    cof[0][2] = matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]
    cof[1][0] = -(matrix[0][1] * matrix[2][2] - matrix[0][2] * matrix[2][1])
    cof[1][1] = matrix[0][0] * matrix[2][2] - matrix[0][2] * matrix[2][0]
    cof[1][2] = -(matrix[0][0] * matrix[2][1] - matrix[0][1] * matrix[2][0])
    cof[2][0] = matrix[0][1] * matrix[1][2] - matrix[0][2] * matrix[1][1]
    cof[2][1] = -(matrix[0][0] * matrix[1][2] - matrix[0][2] * matrix[1][0])
    cof[2][2] = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]
    var inv: list<list<float>> = [
      [0.0, 0.0, 0.0],
      [0.0, 0.0, 0.0],
      [0.0, 0.0, 0.0]
    ]
    var i = 0
    while i < 3 {
      var j = 0
      while j < 3 {
        inv[i][j] = cof[j][i] / det
        j = j + 1
      }
      i = i + 1
    }
    return inv
  }
  print("Please provide a matrix of size 2x2 or 3x3.")
  return []
}

var m2: list<list<float>> = [[2.0, 5.0], [2.0, 0.0]]
print(inverse_of_matrix(m2))
var m3: list<list<float>> = [[2.0, 5.0, 7.0], [2.0, 0.0, 1.0], [1.0, 2.0, 3.0]]
print(inverse_of_matrix(m3))
