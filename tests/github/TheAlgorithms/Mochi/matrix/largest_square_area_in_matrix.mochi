/*
Largest Square Area in a Binary Matrix
--------------------------------------
Given a binary matrix, the task is to find the side length of the largest
square sub-matrix consisting solely of ones. Four dynamic programming
approaches are provided:

1. Top-down recursion without memoization (exponential time).
2. Top-down recursion with memoization using a DP array (O(n * m)).
3. Bottom-up dynamic programming (O(n * m) time, O(n * m) space).
4. Bottom-up approach with space optimization keeping only two rows
   (O(n * m) time, O(m) space).
*/

fun update_area_of_max_square(row: int, col: int, rows: int, cols: int,
  mat: list<list<int>>, largest_square_area: list<int>): int {
  if row >= rows || col >= cols {
    return 0
  }
  let right = update_area_of_max_square(row, col + 1, rows, cols, mat, largest_square_area)
  let diagonal = update_area_of_max_square(row + 1, col + 1, rows, cols, mat, largest_square_area)
  let down = update_area_of_max_square(row + 1, col, rows, cols, mat, largest_square_area)
  if mat[row][col] == 1 {
    let sub = 1 + min([right, diagonal, down])
    if sub > largest_square_area[0] {
      largest_square_area[0] = sub
    }
    return sub
  } else {
    return 0
  }
}

fun largest_square_area_in_matrix_top_down(rows: int, cols: int, mat: list<list<int>>): int {
  var largest: list<int> = [0]
  update_area_of_max_square(0, 0, rows, cols, mat, largest)
  return largest[0]
}

fun update_area_of_max_square_with_dp(row: int, col: int, rows: int, cols: int,
  mat: list<list<int>>, dp_array: list<list<int>>, largest_square_area: list<int>): int {
  if row >= rows || col >= cols {
    return 0
  }
  if dp_array[row][col] != (-1) {
    return dp_array[row][col]
  }
  let right = update_area_of_max_square_with_dp(row, col + 1, rows, cols, mat, dp_array, largest_square_area)
  let diagonal = update_area_of_max_square_with_dp(row + 1, col + 1, rows, cols, mat, dp_array, largest_square_area)
  let down = update_area_of_max_square_with_dp(row + 1, col, rows, cols, mat, dp_array, largest_square_area)
  if mat[row][col] == 1 {
    let sub = 1 + min([right, diagonal, down])
    if sub > largest_square_area[0] {
      largest_square_area[0] = sub
    }
    dp_array[row][col] = sub
    return sub
  } else {
    dp_array[row][col] = 0
    return 0
  }
}

fun largest_square_area_in_matrix_top_down_with_dp(rows: int, cols: int, mat: list<list<int>>): int {
  var largest: list<int> = [0]
  var dp_array: list<list<int>> = []
  var r = 0
  while r < rows {
    var row_list: list<int> = []
    var c = 0
    while c < cols {
      row_list = append(row_list, -1)
      c = c + 1
    }
    dp_array = append(dp_array, row_list)
    r = r + 1
  }
  update_area_of_max_square_with_dp(0, 0, rows, cols, mat, dp_array, largest)
  return largest[0]
}

fun largest_square_area_in_matrix_bottom_up(rows: int, cols: int, mat: list<list<int>>): int {
  var dp_array: list<list<int>> = []
  var r = 0
  while r <= rows {
    var row_list: list<int> = []
    var c = 0
    while c <= cols {
      row_list = append(row_list, 0)
      c = c + 1
    }
    dp_array = append(dp_array, row_list)
    r = r + 1
  }
  var largest = 0
  var row = rows - 1
  while row >= 0 {
    var col = cols - 1
    while col >= 0 {
      let right = dp_array[row][col + 1]
      let diagonal = dp_array[row + 1][col + 1]
      let bottom = dp_array[row + 1][col]
      if mat[row][col] == 1 {
        let value = 1 + min([right, diagonal, bottom])
        dp_array[row][col] = value
        if value > largest {
          largest = value
        }
      } else {
        dp_array[row][col] = 0
      }
      col = col - 1
    }
    row = row - 1
  }
  return largest
}

fun largest_square_area_in_matrix_bottom_up_space_optimization(rows: int, cols: int, mat: list<list<int>>): int {
  var current_row: list<int> = []
  var i = 0
  while i <= cols {
    current_row = append(current_row, 0)
    i = i + 1
  }
  var next_row: list<int> = []
  var j = 0
  while j <= cols {
    next_row = append(next_row, 0)
    j = j + 1
  }
  var largest = 0
  var row = rows - 1
  while row >= 0 {
    var col = cols - 1
    while col >= 0 {
      let right = current_row[col + 1]
      let diagonal = next_row[col + 1]
      let bottom = next_row[col]
      if mat[row][col] == 1 {
        let value = 1 + min([right, diagonal, bottom])
        current_row[col] = value
        if value > largest {
          largest = value
        }
      } else {
        current_row[col] = 0
      }
      col = col - 1
    }
    next_row = current_row
    current_row = []
    var t = 0
    while t <= cols {
      current_row = append(current_row, 0)
      t = t + 1
    }
    row = row - 1
  }
  return largest
}

let sample: list<list<int>> = [[1, 1], [1, 1]]
print(largest_square_area_in_matrix_top_down(2, 2, sample))
print(largest_square_area_in_matrix_top_down_with_dp(2, 2, sample))
print(largest_square_area_in_matrix_bottom_up(2, 2, sample))
print(largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, sample))
