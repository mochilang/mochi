/*
Runge-Kutta-Fehlberg Method (RKF45)
----------------------------------
Solves first-order ordinary differential equations y' = f(x, y) using
Fehlberg's embedded Rungeâ€“Kutta method of order 5 with a fourth-order
estimate for adaptive error control. This version uses a fixed step size
and returns the estimated y-values at each x between the initial and
final values.

Given:
- func(x, y): derivative function.
- x_initial, y_initial: starting point of the solution.
- step_size: positive increment of x.
- x_final: final x where x_final > x_initial.

Algorithm:
1. Calculate the number of steps n = (x_final - x_initial) / step_size.
2. Start lists for y-values with y_initial.
3. For each step compute slopes k1..k6 with Fehlberg coefficients.
4. Combine the slopes to estimate the next y value (fifth-order).
5. Append the new y to the list and increment x.
6. Return the list of y estimates.

This implementation mirrors the Python version from TheAlgorithms and
runs on runtime/vm without any foreign function interfaces.
*/

fun runge_kutta_fehlberg_45(
  func: fun(float, float): float,
  x_initial: float,
  y_initial: float,
  step_size: float,
  x_final: float
): list<float> {
  if x_initial >= x_final {
    panic("The final value of x must be greater than initial value of x.")
  }
  if step_size <= 0.0 {
    panic("Step size must be positive.")
  }
  let n: int = ((x_final - x_initial) / step_size) as int
  var ys: list<float> = []
  var x: float = x_initial
  var y: float = y_initial
  ys = append(ys, y)
  var i: int = 0
  while i < n {
    let k1: float = step_size * func(x, y)
    let k2: float = step_size * func(x + step_size / 4.0, y + k1 / 4.0)
    let k3: float = step_size * func(
      x + (3.0 / 8.0) * step_size,
      y + (3.0 / 32.0) * k1 + (9.0 / 32.0) * k2
    )
    let k4: float = step_size * func(
      x + (12.0 / 13.0) * step_size,
      y + (1932.0 / 2197.0) * k1 - (7200.0 / 2197.0) * k2 + (7296.0 / 2197.0) * k3
    )
    let k5: float = step_size * func(
      x + step_size,
      y + (439.0 / 216.0) * k1 - 8.0 * k2 + (3680.0 / 513.0) * k3 - (845.0 / 4104.0) * k4
    )
    let k6: float = step_size * func(
      x + step_size / 2.0,
      y - (8.0 / 27.0) * k1 + 2.0 * k2 - (3544.0 / 2565.0) * k3 + (1859.0 / 4104.0) * k4 - (11.0 / 40.0) * k5
    )
    y = y + (16.0 / 135.0) * k1 + (6656.0 / 12825.0) * k3 + (28561.0 / 56430.0) * k4 - (9.0 / 50.0) * k5 + (2.0 / 55.0) * k6
    x = x + step_size
    ys = append(ys, y)
    i = i + 1
  }
  return ys
}

fun main() {
  fun f1(x: float, y: float): float { return 1.0 + y * y }
  let y1 = runge_kutta_fehlberg_45(f1, 0.0, 0.0, 0.2, 1.0)
  print(y1[1])

  fun f2(x: float, y: float): float { return x }
  let y2 = runge_kutta_fehlberg_45(f2, -1.0, 0.0, 0.2, 0.0)
  print(y2[1])
}

main()
