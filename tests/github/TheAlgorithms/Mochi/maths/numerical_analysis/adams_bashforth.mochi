/*
Adams-Bashforth Methods for Solving Ordinary Differential Equations

This implementation provides explicit multistep methods (orders 2-5)
for numerically solving first-order ODEs of the form y' = f(x, y).
Given a set of equally spaced starting points with known values,
these predictor formulas estimate y at subsequent x positions using
previous derivative evaluations.

The k-step Adams-Bashforth formulas used are:
- 2-step: y_{n+1} = y_n + h/2 * (3 f_n - f_{n-1})
- 3-step: y_{n+1} = y_n + h/12 * (23 f_n - 16 f_{n-1} + 5 f_{n-2})
- 4-step: y_{n+1} = y_n + h/24 * (55 f_n - 59 f_{n-1} + 37 f_{n-2} - 9 f_{n-3})
- 5-step: y_{n+1} = y_n + h/720 * (1901 f_n - 2774 f_{n-1} - 2616 f_{n-2} - 1274 f_{n-3} + 251 f_{n-4})

Each step function validates inputs:
* Final x must exceed the last initial x value.
* Step size must be positive.
* Initial x values must be equally spaced by the step size.
* Adequate numbers of initial points must be supplied.

The functions return the list of y values including the provided
initial values and the newly computed points.
*/

fun abs_float(x: float): float {
  if x < 0.0 { return -x } else { return x }
}

fun validate_inputs(x_initials: list<float>, step_size: float, x_final: float) {
  if x_initials[len(x_initials) - 1] >= x_final {
    panic("The final value of x must be greater than the initial values of x.")
  }
  if step_size <= 0.0 {
    panic("Step size must be positive.")
  }
  var i: int = 0
  while i < len(x_initials) - 1 {
    let diff: float = x_initials[i + 1] - x_initials[i]
    if abs_float(diff - step_size) > 0.0000000001 {
      panic("x-values must be equally spaced according to step size.")
    }
    i = i + 1
  }
}

fun list_to_string(xs: list<float>): string {
  var s: string = "["
  var i: int = 0
  while i < len(xs) {
    s = s + str(xs[i])
    if i + 1 < len(xs) {
      s = s + ", "
    }
    i = i + 1
  }
  s = s + "]"
  return s
}

fun adams_bashforth_step2(
  f: fun(float, float): float,
  x_initials: list<float>,
  y_initials: list<float>,
  step_size: float,
  x_final: float
): list<float> {
  validate_inputs(x_initials, step_size, x_final)
  if len(x_initials) != 2 || len(y_initials) != 2 {
    panic("Insufficient initial points information.")
  }
  var x0: float = x_initials[0]
  var x1: float = x_initials[1]
  var y: list<float> = []
  y = append(y, y_initials[0])
  y = append(y, y_initials[1])
  let n: int = ((x_final - x1) / step_size) as int
  var i: int = 0
  while i < n {
    let term: float = 3.0 * f(x1, y[i + 1]) - f(x0, y[i])
    let y_next: float = y[i + 1] + (step_size / 2.0) * term
    y = append(y, y_next)
    x0 = x1
    x1 = x1 + step_size
    i = i + 1
  }
  return y
}

fun adams_bashforth_step3(
  f: fun(float, float): float,
  x_initials: list<float>,
  y_initials: list<float>,
  step_size: float,
  x_final: float
): list<float> {
  validate_inputs(x_initials, step_size, x_final)
  if len(x_initials) != 3 || len(y_initials) != 3 {
    panic("Insufficient initial points information.")
  }
  var x0: float = x_initials[0]
  var x1: float = x_initials[1]
  var x2: float = x_initials[2]
  var y: list<float> = []
  y = append(y, y_initials[0])
  y = append(y, y_initials[1])
  y = append(y, y_initials[2])
  let n: int = ((x_final - x2) / step_size) as int
  var i: int = 0
  while i <= n {
    let term: float = 23.0 * f(x2, y[i + 2]) - 16.0 * f(x1, y[i + 1]) + 5.0 * f(x0, y[i])
    let y_next: float = y[i + 2] + (step_size / 12.0) * term
    y = append(y, y_next)
    x0 = x1
    x1 = x2
    x2 = x2 + step_size
    i = i + 1
  }
  return y
}

fun adams_bashforth_step4(
  f: fun(float, float): float,
  x_initials: list<float>,
  y_initials: list<float>,
  step_size: float,
  x_final: float
): list<float> {
  validate_inputs(x_initials, step_size, x_final)
  if len(x_initials) != 4 || len(y_initials) != 4 {
    panic("Insufficient initial points information.")
  }
  var x0: float = x_initials[0]
  var x1: float = x_initials[1]
  var x2: float = x_initials[2]
  var x3: float = x_initials[3]
  var y: list<float> = []
  y = append(y, y_initials[0])
  y = append(y, y_initials[1])
  y = append(y, y_initials[2])
  y = append(y, y_initials[3])
  let n: int = ((x_final - x3) / step_size) as int
  var i: int = 0
  while i < n {
    let term: float =
      55.0 * f(x3, y[i + 3]) -
      59.0 * f(x2, y[i + 2]) +
      37.0 * f(x1, y[i + 1]) -
      9.0 * f(x0, y[i])
    let y_next: float = y[i + 3] + (step_size / 24.0) * term
    y = append(y, y_next)
    x0 = x1
    x1 = x2
    x2 = x3
    x3 = x3 + step_size
    i = i + 1
  }
  return y
}

fun adams_bashforth_step5(
  f: fun(float, float): float,
  x_initials: list<float>,
  y_initials: list<float>,
  step_size: float,
  x_final: float
): list<float> {
  validate_inputs(x_initials, step_size, x_final)
  if len(x_initials) != 5 || len(y_initials) != 5 {
    panic("Insufficient initial points information.")
  }
  var x0: float = x_initials[0]
  var x1: float = x_initials[1]
  var x2: float = x_initials[2]
  var x3: float = x_initials[3]
  var x4: float = x_initials[4]
  var y: list<float> = []
  y = append(y, y_initials[0])
  y = append(y, y_initials[1])
  y = append(y, y_initials[2])
  y = append(y, y_initials[3])
  y = append(y, y_initials[4])
  let n: int = ((x_final - x4) / step_size) as int
  var i: int = 0
  while i <= n {
    let term: float =
      1901.0 * f(x4, y[i + 4]) -
      2774.0 * f(x3, y[i + 3]) -
      2616.0 * f(x2, y[i + 2]) -
      1274.0 * f(x1, y[i + 1]) +
      251.0 * f(x0, y[i])
    let y_next: float = y[i + 4] + (step_size / 720.0) * term
    y = append(y, y_next)
    x0 = x1
    x1 = x2
    x2 = x3
    x3 = x4
    x4 = x4 + step_size
    i = i + 1
  }
  return y
}

fun f_x(x: float, y: float): float { return x }
fun f_xy(x: float, y: float): float { return x + y }

let y2 = adams_bashforth_step2(f_x, [0.0, 0.2], [0.0, 0.0], 0.2, 1.0)
print(list_to_string(y2))
let y3 = adams_bashforth_step3(f_xy, [0.0, 0.2, 0.4], [0.0, 0.0, 0.04], 0.2, 1.0)
print(str(y3[3]))
let y4 = adams_bashforth_step4(f_xy, [0.0, 0.2, 0.4, 0.6], [0.0, 0.0, 0.04, 0.128], 0.2, 1.0)
print(str(y4[4]))
print(str(y4[5]))
let y5 = adams_bashforth_step5(f_xy, [0.0, 0.2, 0.4, 0.6, 0.8], [0.0, 0.02140, 0.02140, 0.22211, 0.42536], 0.2, 1.0)
print(str(y5[len(y5) - 1]))
