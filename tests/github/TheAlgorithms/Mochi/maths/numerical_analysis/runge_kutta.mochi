/*
Runge-Kutta 4th Order Method
----------------------------
This module numerically solves ordinary differential equations of the
form y' = f(x, y) using the classic fourth-order Runge-Kutta (RK4)
method. Given a derivative function f, an initial value y0 at position
x0, a step size h, and a final x value x_end, the algorithm advances the
solution by computing four intermediate slopes:

1. k1 = f(x, y)
2. k2 = f(x + h/2, y + h*k1/2)
3. k3 = f(x + h/2, y + h*k2/2)
4. k4 = f(x + h, y + h*k3)

The next value is y_{n+1} = y_n + (h/6)*(k1 + 2*k2 + 2*k3 + k4).
Repeating this process generates an array of approximate solutions for
successive x values. This implementation uses only Mochi primitives so
it can execute on runtime/vm.
*/

fun runge_kutta(f: fun(float, float): float, y0: float, x0: float, h: float, x_end: float): list<float> {
  let span = (x_end - x0) / h
  var n = int(span)
  if float(n) < span { n = n + 1 }
  var y: list<float> = []
  var i = 0
  while i < n + 1 {
    y = append(y, 0.0)
    i = i + 1
  }
  y[0] = y0
  var x = x0
  var k = 0
  while k < n {
    let k1 = f(x, y[k])
    let k2 = f(x + 0.5 * h, y[k] + 0.5 * h * k1)
    let k3 = f(x + 0.5 * h, y[k] + 0.5 * h * k2)
    let k4 = f(x + h, y[k] + h * k3)
    y[k + 1] = y[k] + (1.0 / 6.0) * h * (k1 + 2.0 * k2 + 2.0 * k3 + k4)
    x = x + h
    k = k + 1
  }
  return y
}

fun test_runge_kutta() {
  fun f(x: float, y: float): float { return y }
  let result = runge_kutta(f, 1.0, 0.0, 0.01, 5.0)
  let last = result[len(result) - 1]
  let expected = 148.41315904125113
  var diff = last - expected
  if diff < 0.0 { diff = -diff }
  if diff > 0.000001 {
    panic("runge_kutta failed")
  }
}

fun main() {
  test_runge_kutta()
  fun f(x: float, y: float): float { return y }
  let r = runge_kutta(f, 1.0, 0.0, 0.1, 1.0)
  print(str(r[len(r) - 1]))
}

main()
