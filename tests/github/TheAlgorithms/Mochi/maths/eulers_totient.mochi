/*
Euler's Totient Function
-----------------------
Euler's totient \u03c6(n) counts how many integers 1 \u2264 k < n are coprime with n.
This implementation computes totients for all numbers below a bound n using a
prime sieve:

1. Maintain a list of discovered primes.
2. For each integer i, multiply by each prime p.
   * If i * p \u2265 n we stop processing.
   * Mark i * p as composite.
   * If p divides i then \u03c6(i * p) = \u03c6(i) * p and no other primes are checked.
   * Otherwise \u03c6(i * p) = \u03c6(i) * (p - 1).
3. The array of totients is returned where index i holds \u03c6(i).

The complexity is O(n log log n) and uses no foreign function interface so it
runs on the runtime/vm.
*/

fun totient(n: int): list<int> {
  var is_prime: list<bool> = []
  var totients: list<int> = []
  var primes: list<int> = []
  var i = 0
  while i <= n {
    is_prime = append(is_prime, true)
    totients = append(totients, i - 1)
    i = i + 1
  }
  i = 2
  while i <= n {
    if is_prime[i] {
      primes = append(primes, i)
    }
    var j = 0
    while j < len(primes) {
      let p = primes[j]
      if i * p >= n {
        break
      }
      is_prime[i * p] = false
      if i % p == 0 {
        totients[i * p] = totients[i] * p
        break
      }
      totients[i * p] = totients[i] * (p - 1)
      j = j + 1
    }
    i = i + 1
  }
  return totients
}

fun test_totient() {
  let expected: list<int> = [-1, 0, 1, 2, 2, 4, 2, 6, 4, 6, 9]
  let res = totient(10)
  var idx = 0
  while idx < len(expected) {
    if res[idx] != expected[idx] {
      panic("totient mismatch at " + str(idx))
    }
    idx = idx + 1
  }
}

fun main() {
  test_totient()
  let n = 10
  let res = totient(n)
  var i = 1
  while i < n {
    print(str(i) + " has " + str(res[i]) + " relative primes.")
    i = i + 1
  }
}

main()
