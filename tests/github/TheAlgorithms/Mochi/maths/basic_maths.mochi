/*
Basic Number Theory Utilities

This module implements four classic arithmetic routines:

1. prime_factors(n) – factors a positive integer into its prime components
   by trial division. It repeatedly extracts the factor 2, then tests odd
   candidates up to the square root of the remaining number.

2. number_of_divisors(n) – counts the total number of positive divisors of n
   using the exponents from its prime factorization. For each prime factor p^e
   the divisor count multiplies by (e+1).

3. sum_of_divisors(n) – computes the sum of all positive divisors. For each
   prime p^e it uses the formula (p^(e+1)-1)/(p-1) and multiplies the results.
   The implementation stays in integers so it can run on the runtime/vm.

4. euler_phi(n) – evaluates Euler's totient function φ(n) which counts integers
   in [1,n] coprime with n. It multiplies n by (p-1)/p for each distinct prime
   factor p.

All routines validate that inputs are positive and panic otherwise. They
avoid any foreign interfaces and rely solely on integer arithmetic so they
execute on the Mochi runtime/vm.
*/

fun pow_int(base: int, exp: int): int {
  var result = 1
  var i = 0
  while i < exp {
    result = result * base
    i = i + 1
  }
  return result
}

fun prime_factors(n: int): list<int> {
  if n <= 0 { panic("Only positive integers have prime factors") }
  var num = n
  var pf: list<int> = []
  while num % 2 == 0 {
    pf = append(pf, 2)
    num = num / 2
  }
  var i = 3
  while i * i <= num {
    while num % i == 0 {
      pf = append(pf, i)
      num = num / i
    }
    i = i + 2
  }
  if num > 2 {
    pf = append(pf, num)
  }
  return pf
}

fun number_of_divisors(n: int): int {
  if n <= 0 { panic("Only positive numbers are accepted") }
  var num = n
  var div = 1
  var temp = 1
  while num % 2 == 0 {
    temp = temp + 1
    num = num / 2
  }
  div = div * temp
  var i = 3
  while i * i <= num {
    temp = 1
    while num % i == 0 {
      temp = temp + 1
      num = num / i
    }
    div = div * temp
    i = i + 2
  }
  if num > 1 {
    div = div * 2
  }
  return div
}

fun sum_of_divisors(n: int): int {
  if n <= 0 { panic("Only positive numbers are accepted") }
  var num = n
  var s = 1
  var temp = 1
  while num % 2 == 0 {
    temp = temp + 1
    num = num / 2
  }
  if temp > 1 {
    s = s * ((pow_int(2, temp) - 1) / (2 - 1))
  }
  var i = 3
  while i * i <= num {
    temp = 1
    while num % i == 0 {
      temp = temp + 1
      num = num / i
    }
    if temp > 1 {
      s = s * ((pow_int(i, temp) - 1) / (i - 1))
    }
    i = i + 2
  }
  return s
}

fun contains(arr: list<int>, x: int): bool {
  var idx = 0
  while idx < len(arr) {
    if arr[idx] == x { return true }
    idx = idx + 1
  }
  return false
}

fun unique(arr: list<int>): list<int> {
  var result: list<int> = []
  var idx = 0
  while idx < len(arr) {
    let v = arr[idx]
    if !contains(result, v) {
      result = append(result, v)
    }
    idx = idx + 1
  }
  return result
}

fun euler_phi(n: int): int {
  if n <= 0 { panic("Only positive numbers are accepted") }
  var s = n
  let factors = unique(prime_factors(n))
  var idx = 0
  while idx < len(factors) {
    let x = factors[idx]
    s = (s / x) * (x - 1)
    idx = idx + 1
  }
  return s
}

print(str(prime_factors(100)))
print(str(number_of_divisors(100)))
print(str(sum_of_divisors(100)))
print(str(euler_phi(100)))
