/*
Triplet Sum Problem
-------------------
Given a list of integers and a target value, find three numbers in the list
whose sum equals the target.  Two approaches are implemented:

1. triplet_sum1(arr, target): Brute force search over all unique index
   combinations using three nested loops.  The first matching triplet is
   returned in sorted order.  Time complexity is O(n^3).
2. triplet_sum2(arr, target): Optimised search that first sorts the array
   using a simple bubble sort and then fixes one element while applying the
   twoâ€‘pointer technique on the remaining portion.  This reduces time
   complexity to O(n^2).

Both functions return a list containing the triplet in ascending order or
[0, 0, 0] when no such combination exists.  The code avoids foreign function
interfaces so it can execute on runtime/vm.  Test cases mirror the Python
version from TheAlgorithms repository.
*/

fun bubble_sort(nums: list<int>): list<int> {
  var arr: list<int> = []
  var i = 0
  while i < len(nums) {
    arr = append(arr, nums[i])
    i = i + 1
  }
  var n = len(arr)
  var a = 0
  while a < n {
    var b = 0
    while b < n - a - 1 {
      if arr[b] > arr[b + 1] {
        let tmp = arr[b]
        arr[b] = arr[b + 1]
        arr[b + 1] = tmp
      }
      b = b + 1
    }
    a = a + 1
  }
  return arr
}

fun sort3(xs: list<int>): list<int> {
  var arr: list<int> = []
  var i = 0
  while i < len(xs) {
    arr = append(arr, xs[i])
    i = i + 1
  }
  var n = len(arr)
  var a = 0
  while a < n {
    var b = 0
    while b < n - a - 1 {
      if arr[b] > arr[b + 1] {
        let tmp = arr[b]
        arr[b] = arr[b + 1]
        arr[b + 1] = tmp
      }
      b = b + 1
    }
    a = a + 1
  }
  return arr
}

fun triplet_sum1(arr: list<int>, target: int): list<int> {
  var i = 0
  while i < len(arr) - 2 {
    var j = i + 1
    while j < len(arr) - 1 {
      var k = j + 1
      while k < len(arr) {
        if arr[i] + arr[j] + arr[k] == target {
          return sort3([arr[i], arr[j], arr[k]])
        }
        k = k + 1
      }
      j = j + 1
    }
    i = i + 1
  }
  return [0, 0, 0]
}

fun triplet_sum2(arr: list<int>, target: int): list<int> {
  let sorted = bubble_sort(arr)
  let n = len(sorted)
  var i = 0
  while i < n - 2 {
    var left = i + 1
    var right = n - 1
    while left < right {
      let s = sorted[i] + sorted[left] + sorted[right]
      if s == target {
        return [sorted[i], sorted[left], sorted[right]]
      }
      if s < target {
        left = left + 1
      } else {
        right = right - 1
      }
    }
    i = i + 1
  }
  return [0, 0, 0]
}

fun list_equal(a: list<int>, b: list<int>): bool {
  if len(a) != len(b) { return false }
  var i = 0
  while i < len(a) {
    if a[i] != b[i] { return false }
    i = i + 1
  }
  return true
}

fun test_triplet_sum() {
  let arr1: list<int> = [13, 29, 7, 23, 5]
  if !list_equal(triplet_sum1(arr1, 35), [5, 7, 23]) { panic("ts1 case1 failed") }
  if !list_equal(triplet_sum2(arr1, 35), [5, 7, 23]) { panic("ts2 case1 failed") }
  let arr2: list<int> = [37, 9, 19, 50, 44]
  if !list_equal(triplet_sum1(arr2, 65), [9, 19, 37]) { panic("ts1 case2 failed") }
  if !list_equal(triplet_sum2(arr2, 65), [9, 19, 37]) { panic("ts2 case2 failed") }
  let arr3: list<int> = [6, 47, 27, 1, 15]
  if !list_equal(triplet_sum1(arr3, 11), [0, 0, 0]) { panic("ts1 case3 failed") }
  if !list_equal(triplet_sum2(arr3, 11), [0, 0, 0]) { panic("ts2 case3 failed") }
}

fun main() {
  test_triplet_sum()
  let sample: list<int> = [13, 29, 7, 23, 5]
  let res = triplet_sum2(sample, 35)
  print(str(res[0]) + " " + str(res[1]) + " " + str(res[2]))
}

main()
