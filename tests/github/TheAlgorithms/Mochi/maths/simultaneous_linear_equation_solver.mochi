/*
Simultaneous Linear Equation Solver
----------------------------------
This module solves a system of linear equations represented as an augmented
matrix.  Given `n` equations with `n` unknowns, each equation is provided as a
list of `n` coefficients followed by the constant term.  The algorithm uses
Gaussâ€‘Jordan elimination:

1. Normalize each pivot row so that the pivot element becomes 1.
2. Eliminate the pivot column from all other rows.
3. After processing all rows, the last column contains the solution vector.

The implementation is written in pure Mochi and runs on the `runtime/vm` without
any foreign function interfaces.  Results are rounded to five decimal places.
*/

fun floor(x: float): float {
  var i = x as int
  if (i as float) > x { i = i - 1 }
  return i as float
}

fun pow10(n: int): float {
  var p = 1.0
  var i = 0
  while i < n {
    p = p * 10.0
    i = i + 1
  }
  return p
}

fun round(x: float, n: int): float {
  let m = pow10(n)
  return floor(x * m + 0.5) / m
}

fun clone_matrix(mat: list<list<float>>): list<list<float>> {
  var new_mat: list<list<float>> = []
  var i = 0
  while i < len(mat) {
    var row: list<float> = []
    var j = 0
    while j < len(mat[i]) {
      row = append(row, mat[i][j])
      j = j + 1
    }
    new_mat = append(new_mat, row)
    i = i + 1
  }
  return new_mat
}

fun solve_simultaneous(equations: list<list<float>>): list<float> {
  let n = len(equations)
  if n == 0 {
    panic("solve_simultaneous() requires n lists of length n+1")
  }
  let m = n + 1
  var i = 0
  while i < n {
    if len(equations[i]) != m {
      panic("solve_simultaneous() requires n lists of length n+1")
    }
    i = i + 1
  }
  var a = clone_matrix(equations)
  var row = 0
  while row < n {
    var pivot = row
    while pivot < n && a[pivot][row] == 0.0 {
      pivot = pivot + 1
    }
    if pivot == n {
      panic("solve_simultaneous() requires at least 1 full equation")
    }
    if pivot != row {
      let temp = a[row]
      a[row] = a[pivot]
      a[pivot] = temp
    }
    let pivot_val = a[row][row]
    var col = 0
    while col < m {
      a[row][col] = a[row][col] / pivot_val
      col = col + 1
    }
    var r = 0
    while r < n {
      if r != row {
        let factor = a[r][row]
        var c = 0
        while c < m {
          a[r][c] = a[r][c] - factor * a[row][c]
          c = c + 1
        }
      }
      r = r + 1
    }
    row = row + 1
  }
  var res: list<float> = []
  var k = 0
  while k < n {
    res = append(res, round(a[k][m - 1], 5))
    k = k + 1
  }
  return res
}

fun test_solver() {
  let a: list<list<float>> = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]
  let r1 = solve_simultaneous(a)
  if !(len(r1) == 2 && r1[0] == (0.0 - 1.0) && r1[1] == 2.0) {
    panic("test1 failed")
  }
  let b: list<list<float>> = [
    [0.0, (0.0 - 3.0), 1.0, 7.0],
    [3.0, 2.0, (0.0 - 1.0), 11.0],
    [5.0, 1.0, (0.0 - 2.0), 12.0],
  ]
  let r2 = solve_simultaneous(b)
  if !(len(r2) == 3 && r2[0] == 6.4 && r2[1] == 1.2 && r2[2] == 10.6) {
    panic("test2 failed")
  }
}

fun main() {
  test_solver()
  let eq: list<list<float>> = [
    [2.0, 1.0, 1.0, 1.0, 1.0, 4.0],
    [1.0, 2.0, 1.0, 1.0, 1.0, 5.0],
    [1.0, 1.0, 2.0, 1.0, 1.0, 6.0],
    [1.0, 1.0, 1.0, 2.0, 1.0, 7.0],
    [1.0, 1.0, 1.0, 1.0, 2.0, 8.0],
  ]
  print(str(solve_simultaneous(eq)))
  print(str(solve_simultaneous([[4.0, 2.0]])))
}

main()
