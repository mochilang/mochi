/*
Bell Numbers
------------
Bell numbers B(n) count the ways to partition a set of n elements into
non-empty, disjoint subsets. They satisfy the recurrence

  B(0) = 1
  B(n+1) = sum_{k=0}^{n} C(n, k) * B(k)

where C(n, k) is the binomial coefficient. This implementation builds the
sequence up to a requested size using dynamic programming. The helper
binomial_coefficient function computes C(n, k) without relying on external
libraries.

Time complexity: O(n^2) to compute numbers up to n.
Space complexity: O(n).
*/

fun binomial_coefficient(total_elements: int, elements_to_choose: int): int {
  if elements_to_choose == 0 || elements_to_choose == total_elements {
    return 1
  }
  var k = elements_to_choose
  if k > total_elements - k {
    k = total_elements - k
  }
  var coefficient = 1
  var i = 0
  while i < k {
    coefficient = coefficient * (total_elements - i)
    coefficient = coefficient / (i + 1)
    i = i + 1
  }
  return coefficient
}

fun bell_numbers(max_set_length: int): list<int> {
  if max_set_length < 0 {
    panic("max_set_length must be non-negative")
  }
  var bell: list<int> = []
  var i = 0
  while i <= max_set_length {
    bell = append(bell, 0)
    i = i + 1
  }
  bell[0] = 1
  i = 1
  while i <= max_set_length {
    var j = 0
    while j < i {
      bell[i] = bell[i] + binomial_coefficient(i - 1, j) * bell[j]
      j = j + 1
    }
    i = i + 1
  }
  return bell
}

fun main() {
  print(str(bell_numbers(5)))
}

main()
