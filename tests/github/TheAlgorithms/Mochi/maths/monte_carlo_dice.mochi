/*
Monte Carlo simulation of dice sums.

Given a number of throws `num_throws` and number of dice `num_dice`,
this algorithm estimates the probability distribution of all possible
sums when throwing six‑sided dice.

Algorithm steps:
1. A linear congruential generator (LCG) provides deterministic pseudo
   random integers so the VM runs without external libraries.
2. For each throw, roll each die (1‑6) and accumulate the sum.
3. Count frequencies for every possible sum.
4. Convert counts to percentages rounded to two decimals.

Time complexity: O(num_throws * num_dice)
Space complexity: O(num_dice * 6)
*/

var lcg_seed: int = 1
fun lcg_rand(): int {
  lcg_seed = (lcg_seed * 1103515245 + 12345) % 2147483648
  return lcg_seed
}

fun roll(): int {
  let rv = lcg_rand() as float
  let r = rv * 6.0 / 2147483648.0
  return 1 + (r as int)
}

fun round2(x: float): float {
  let y = x * 100.0 + 0.5
  let z = y as int
  return (z as float) / 100.0
}

fun throw_dice(num_throws: int, num_dice: int): list<float> {
  var count_of_sum: list<int> = []
  let max_sum = num_dice * 6 + 1
  var i = 0
  while i < max_sum {
    count_of_sum = append(count_of_sum, 0)
    i = i + 1
  }
  var t = 0
  while t < num_throws {
    var s: int = 0
    var d: int = 0
    while d < num_dice {
      s = s + roll()
      d = d + 1
    }
    count_of_sum[s] = count_of_sum[s] + 1
    t = t + 1
  }
  var probability: list<float> = []
  i = num_dice
  while i < max_sum {
    let p = (count_of_sum[i] as float) * 100.0 / (num_throws as float)
    probability = append(probability, round2(p))
    i = i + 1
  }
  return probability
}

fun main() {
  lcg_seed = 1
  let result = throw_dice(10000, 2)
  print(str(result))
}

main()
