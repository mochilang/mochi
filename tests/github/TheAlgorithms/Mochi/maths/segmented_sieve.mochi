/*
Segmented Sieve of Eratosthenes
-------------------------------
This program generates all prime numbers up to a limit n using a
segmented sieve. The algorithm proceeds in two phases:

1. A simple sieve collects the primes up to sqrt(n). These primes are
   stored and reused for marking composites in later segments.
2. The remaining range is processed in blocks of size sqrt(n). Each
   block is initialized as all prime and then every stored small prime
   marks its multiples inside the block as composite.

The segmented approach reduces memory usage compared to a classic sieve
because only one block is stored in memory at a time. All code is written
in pure Mochi and runs on the runtime/vm without any foreign interface.
*/

fun min_int(a: int, b: int): int {
  if a < b { return a }
  return b
}

fun int_sqrt(n: int): int {
  var r = 0
  while (r + 1) * (r + 1) <= n {
    r = r + 1
  }
  return r
}

fun sieve(n: int): list<int> {
  if n <= 0 { panic("Number must instead be a positive integer") }
  var in_prime: list<int> = []
  var start = 2
  let end = int_sqrt(n)
  var temp: list<int> = []
  var i = 0
  while i < end + 1 {
    temp = append(temp, 1)
    i = i + 1
  }
  var prime: list<int> = []
  while start <= end {
    if temp[start] == 1 {
      in_prime = append(in_prime, start)
      var j = start * start
      while j <= end {
        temp[j] = 0
        j = j + start
      }
    }
    start = start + 1
  }
  i = 0
  while i < len(in_prime) {
    prime = append(prime, in_prime[i])
    i = i + 1
  }
  var low = end + 1
  var high = min_int(2 * end, n)
  while low <= n {
    var tempSeg: list<int> = []
    var size = high - low + 1
    var k = 0
    while k < size {
      tempSeg = append(tempSeg, 1)
      k = k + 1
    }
    var idx = 0
    while idx < len(in_prime) {
      let each = in_prime[idx]
      var t = (low / each) * each
      if t < low {
        t = t + each
      }
      var j2 = t
      while j2 <= high {
        tempSeg[j2 - low] = 0
        j2 = j2 + each
      }
      idx = idx + 1
    }
    var j3 = 0
    while j3 < len(tempSeg) {
      if tempSeg[j3] == 1 {
        prime = append(prime, j3 + low)
      }
      j3 = j3 + 1
    }
    low = high + 1
    high = min_int(high + end, n)
  }
  return prime
}

fun lists_equal(a: list<int>, b: list<int>): bool {
  if len(a) != len(b) { return false }
  var m = 0
  while m < len(a) {
    if a[m] != b[m] { return false }
    m = m + 1
  }
  return true
}

fun test_sieve() {
  let e1 = sieve(8)
  if !lists_equal(e1, [2, 3, 5, 7]) { panic("sieve(8) failed") }
  let e2 = sieve(27)
  if !lists_equal(e2, [2, 3, 5, 7, 11, 13, 17, 19, 23]) { panic("sieve(27) failed") }
}

fun main() {
  test_sieve()
  print(str(sieve(30)))
}

main()
