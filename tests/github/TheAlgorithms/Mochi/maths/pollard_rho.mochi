/*
Pollard's Rho Integer Factorization
----------------------------------
This program implements Pollard's Rho algorithm to find a nontrivial factor
of a composite integer `num`. The algorithm is a randomized method that
uses Floyd's cycle-finding technique. A pseudorandom function `f(x) = x^2 + c mod num`
iteratively generates values for two sequences, the "tortoise" and the "hare".
At each step the tortoise advances once and the hare twice. The greatest common
divisor of their difference with `num` reveals a nontrivial factor when it is
neither 1 nor `num`. Different seeds and step values are tried for a fixed number
of attempts to increase the probability of finding a factor. If no factor is
found, the algorithm reports failure. The return value includes the discovered
factor and an `ok` flag indicating success.
*/

type PollardResult {
  factor: int,
  ok: bool,
}

fun gcd(a: int, b: int): int {
  var x = if a < 0 { -a } else { a }
  var y = if b < 0 { -b } else { b }
  while y != 0 {
    let t = x % y
    x = y
    y = t
  }
  return x
}

fun rand_fn(value: int, step: int, modulus: int): int {
  return (value * value + step) % modulus
}

fun pollard_rho(num: int, seed: int, step: int, attempts: int): PollardResult {
  if num < 2 {
    panic("The input value cannot be less than 2")
  }
  if num > 2 && num % 2 == 0 {
    return PollardResult { factor: 2, ok: true }
  }
  var s = seed
  var st = step
  var i = 0
  while i < attempts {
    var tortoise = s
    var hare = s
    while true {
      tortoise = rand_fn(tortoise, st, num)
      hare = rand_fn(hare, st, num)
      hare = rand_fn(hare, st, num)
      let divisor = gcd(hare - tortoise, num)
      if divisor == 1 {
        continue
      } else if divisor == num {
        break
      } else {
        return PollardResult { factor: divisor, ok: true }
      }
    }
    s = hare
    st = st + 1
    i = i + 1
  }
  return PollardResult { factor: 0, ok: false }
}

fun test_pollard_rho() {
  let r1 = pollard_rho(8051, 2, 1, 5)       // 8051 = 83 * 97
  if !r1.ok || (r1.factor != 83 && r1.factor != 97) { panic("test1 failed") }
  let r2 = pollard_rho(10403, 2, 1, 5)      // 10403 = 101 * 103
  if !r2.ok || (r2.factor != 101 && r2.factor != 103) { panic("test2 failed") }
  let r3 = pollard_rho(100, 2, 1, 3)
  if !r3.ok || r3.factor != 2 { panic("test3 failed") }
  let r4 = pollard_rho(17, 2, 1, 3)
  if r4.ok { panic("test4 failed") }
  let r5 = pollard_rho(17 * 17 * 17, 2, 1, 3)
  if !r5.ok || r5.factor != 17 { panic("test5 failed") }
  let r6 = pollard_rho(17 * 17 * 17, 2, 1, 1)
  if r6.ok { panic("test6 failed") }
  let r7 = pollard_rho(3 * 5 * 7, 2, 1, 3)
  if !r7.ok || r7.factor != 21 { panic("test7 failed") }
}

fun main() {
  test_pollard_rho()
  let a = pollard_rho(100, 2, 1, 3)
  if a.ok { print(str(a.factor)) } else { print("None") }
  let b = pollard_rho(17, 2, 1, 3)
  if b.ok { print(str(b.factor)) } else { print("None") }
}

main()
