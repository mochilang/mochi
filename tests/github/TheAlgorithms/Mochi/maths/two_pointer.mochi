/*
Two-Pointer Search for Target Sum
---------------------------------
Given a sorted list of integers and a target value, this algorithm finds
indices of the two numbers whose sum equals the target.  Because the
list is sorted, we can maintain two pointers: one starting at the
beginning (i) and one at the end (j).  At each step we compare the sum of
nums[i] and nums[j] with the target:

- If the sum equals the target, we return the pair of indices.
- If the sum is less than the target, we increment i to increase the sum.
- If the sum is greater than the target, we decrement j to reduce the sum.

This continues until the pointers meet.  The algorithm runs in O(n) time
and uses O(1) additional space.  It mirrors the Python implementation
from TheAlgorithms repository.
*/

fun two_pointer(nums: list<int>, target: int): list<int> {
  var i = 0
  var j = len(nums) - 1
  while i < j {
    let s = nums[i] + nums[j]
    if s == target {
      return [i, j]
    }
    if s < target {
      i = i + 1
    } else {
      j = j - 1
    }
  }
  return [] as list<int>
}

fun test_two_pointer() {
  if two_pointer([2, 7, 11, 15], 9) != [0, 1] { panic("case1") }
  if two_pointer([2, 7, 11, 15], 17) != [0, 3] { panic("case2") }
  if two_pointer([2, 7, 11, 15], 18) != [1, 2] { panic("case3") }
  if two_pointer([2, 7, 11, 15], 26) != [2, 3] { panic("case4") }
  if two_pointer([1, 3, 3], 6) != [1, 2] { panic("case5") }
  if len(two_pointer([2, 7, 11, 15], 8)) != 0 { panic("case6") }
  if len(two_pointer([0, 3, 6, 9, 12, 15, 18, 21, 24, 27], 19)) != 0 { panic("case7") }
  if len(two_pointer([1, 2, 3], 6)) != 0 { panic("case8") }
}

fun main() {
  test_two_pointer()
  print(two_pointer([2, 7, 11, 15], 9))
}

main()
