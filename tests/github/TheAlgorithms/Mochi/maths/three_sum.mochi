/*
3SUM Problem
------------
Given a list of integers, find all unique triplets whose sum is zero.

Algorithm:
1. Sort the numbers using bubble sort so it can run on the pure Mochi VM.
2. For each index i, if it's the first or differs from previous value, use two
   pointers (low and high) to find pairs that sum to -nums[i].
3. Skip duplicated values for low and high to ensure uniqueness of triplets.

Time complexity: O(n^2) due to the outer loop and two-pointer scan.
Space complexity: O(1) excluding the output list.
*/

fun bubble_sort(nums: list<int>): list<int> {
  var arr = nums
  var n = len(arr)
  var i = 0
  while i < n {
    var j = 0
    while j < n - 1 {
      if arr[j] > arr[j + 1] {
        let temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp
      }
      j = j + 1
    }
    i = i + 1
  }
  return arr
}

fun three_sum(nums: list<int>): list<list<int>> {
  let sorted = bubble_sort(nums)
  var res: list<list<int>> = []
  let n = len(sorted)
  var i = 0
  while i < n - 2 {
    if i == 0 || sorted[i] != sorted[i - 1] {
      var low = i + 1
      var high = n - 1
      let c = 0 - sorted[i]
      while low < high {
        let s = sorted[low] + sorted[high]
        if s == c {
          let triple: list<int> = [sorted[i], sorted[low], sorted[high]]
          res = append(res, triple)
          while low < high && sorted[low] == sorted[low + 1] {
            low = low + 1
          }
          while low < high && sorted[high] == sorted[high - 1] {
            high = high - 1
          }
          low = low + 1
          high = high - 1
        } else if s < c {
          low = low + 1
        } else {
          high = high - 1
        }
      }
    }
    i = i + 1
  }
  return res
}

print(str(three_sum([-1, 0, 1, 2, -1, -4])))
print(str(three_sum([1, 2, 3, 4])))
