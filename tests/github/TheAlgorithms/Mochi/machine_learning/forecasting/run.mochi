/*
Forecasting Ensemble Safety Checker

This program mirrors forecasting/run.py from TheAlgorithms/Python. It
combines several forecasting techniques to judge whether the latest data
point is safe compared to historical records. Implemented algorithms:

1. Linear regression using normal equations on date and match counts.
2. Simple autoregressive model with exogenous input (SARIMAX-style).
3. Radial basis function kernel regression acting as a lightweight SVR.
4. Interquartile range checker for outlier detection.
5. Voting-based safety checker that compares predictions against the
   actual value.

The main block demonstrates these functions on small sample data.
*/

fun int_to_float(x: int): float {
  return x * 1.0
}

fun abs_float(x: float): float {
  if x < 0.0 { return 0.0 - x }
  return x
}

fun exp_approx(x: float): float {
  var term = 1.0
  var sum = 1.0
  var i = 1
  while i < 10 {
    term = term * x / int_to_float(i)
    sum = sum + term
    i = i + 1
  }
  return sum
}

fun floor_int(x: float): int {
  var i = 0
  while int_to_float(i + 1) <= x {
    i = i + 1
  }
  return i
}

fun dot(a: list<float>, b: list<float>): float {
  var s = 0.0
  var i = 0
  while i < len(a) {
    s = s + a[i] * b[i]
    i = i + 1
  }
  return s
}

fun transpose(m: list<list<float>>): list<list<float>> {
  let rows = len(m)
  let cols = len(m[0])
  var res: list<list<float>> = []
  var j = 0
  while j < cols {
    var row: list<float> = []
    var i = 0
    while i < rows {
      row = append(row, m[i][j])
      i = i + 1
    }
    res = append(res, row)
    j = j + 1
  }
  return res
}

fun matmul(a: list<list<float>>, b: list<list<float>>): list<list<float>> {
  let n = len(a)
  let m = len(b[0])
  let p = len(b)
  var res: list<list<float>> = []
  var i = 0
  while i < n {
    var row: list<float> = []
    var j = 0
    while j < m {
      var s = 0.0
      var k = 0
      while k < p {
        s = s + a[i][k] * b[k][j]
        k = k + 1
      }
      row = append(row, s)
      j = j + 1
    }
    res = append(res, row)
    i = i + 1
  }
  return res
}

fun matvec(a: list<list<float>>, b: list<float>): list<float> {
  var res: list<float> = []
  var i = 0
  while i < len(a) {
    res = append(res, dot(a[i], b))
    i = i + 1
  }
  return res
}

fun identity(n: int): list<list<float>> {
  var res: list<list<float>> = []
  var i = 0
  while i < n {
    var row: list<float> = []
    var j = 0
    while j < n {
      row = append(row, if i == j {1.0} else {0.0})
      j = j + 1
    }
    res = append(res, row)
    i = i + 1
  }
  return res
}

fun invert(mat: list<list<float>>): list<list<float>> {
  let n = len(mat)
  var a = mat
  var inv = identity(n)
  var i = 0
  while i < n {
    let pivot = a[i][i]
    var j = 0
    while j < n {
      a[i][j] = a[i][j] / pivot
      inv[i][j] = inv[i][j] / pivot
      j = j + 1
    }
    var k = 0
    while k < n {
      if k != i {
        let factor = a[k][i]
        j = 0
        while j < n {
          a[k][j] = a[k][j] - factor * a[i][j]
          inv[k][j] = inv[k][j] - factor * inv[i][j]
          j = j + 1
        }
      }
      k = k + 1
    }
    i = i + 1
  }
  return inv
}

fun normal_equation(X: list<list<float>>, y: list<float>): list<float> {
  let Xt = transpose(X)
  let XtX = matmul(Xt, X)
  let XtX_inv = invert(XtX)
  let Xty = matvec(Xt, y)
  return matvec(XtX_inv, Xty)
}

fun linear_regression_prediction(train_dt: list<float>, train_usr: list<float>, train_mtch: list<float>, test_dt: list<float>, test_mtch: list<float>): float {
  var X: list<list<float>> = []
  var i = 0
  while i < len(train_dt) {
    X = append(X, [1.0, train_dt[i], train_mtch[i]])
    i = i + 1
  }
  let beta = normal_equation(X, train_usr)
  return abs_float(beta[0] + test_dt[0] * beta[1] + test_mtch[0] * beta[2])
}

fun sarimax_predictor(train_user: list<float>, train_match: list<float>, test_match: list<float>): float {
  let n = len(train_user)
  var X: list<list<float>> = []
  var y: list<float> = []
  var i = 1
  while i < n {
    X = append(X, [1.0, train_user[i - 1], train_match[i]])
    y = append(y, train_user[i])
    i = i + 1
  }
  let beta = normal_equation(X, y)
  return beta[0] + beta[1] * train_user[n - 1] + beta[2] * test_match[0]
}

fun rbf_kernel(a: list<float>, b: list<float>, gamma: float): float {
  var sum = 0.0
  var i = 0
  while i < len(a) {
    let diff = a[i] - b[i]
    sum = sum + diff * diff
    i = i + 1
  }
  return exp_approx(-gamma * sum)
}

fun support_vector_regressor(x_train: list<list<float>>, x_test: list<list<float>>, train_user: list<float>): float {
  let gamma = 0.1
  var weights: list<float> = []
  var i = 0
  while i < len(x_train) {
    weights = append(weights, rbf_kernel(x_train[i], x_test[0], gamma))
    i = i + 1
  }
  var num = 0.0
  var den = 0.0
  i = 0
  while i < len(train_user) {
    num = num + weights[i] * train_user[i]
    den = den + weights[i]
    i = i + 1
  }
  return num / den
}

fun set_at_float(xs: list<float>, idx: int, value: float): list<float> {
  var i = 0
  var res: list<float> = []
  while i < len(xs) {
    if i == idx {
      res = append(res, value)
    } else {
      res = append(res, xs[i])
    }
    i = i + 1
  }
  return res
}

fun sort_float(xs: list<float>): list<float> {
  var res = xs
  var i = 1
  while i < len(res) {
    let key = res[i]
    var j = i - 1
    while j >= 0 && res[j] > key {
      res = set_at_float(res, j + 1, res[j])
      j = j - 1
    }
    res = set_at_float(res, j + 1, key)
    i = i + 1
  }
  return res
}

fun percentile(data: list<float>, q: float): float {
  var sorted = sort_float(data)
  let n = len(sorted)
  let pos = (q / 100.0) * int_to_float(n - 1)
  let idx = floor_int(pos)
  let frac = pos - int_to_float(idx)
  if idx + 1 < n {
    return sorted[idx] * (1.0 - frac) + sorted[idx + 1] * frac
  }
  return sorted[idx]
}

fun interquartile_range_checker(train_user: list<float>): float {
  let q1 = percentile(train_user, 25.0)
  let q3 = percentile(train_user, 75.0)
  let iqr = q3 - q1
  return q1 - iqr * 0.1
}

fun data_safety_checker(list_vote: list<float>, actual_result: float): bool {
  var safe = 0
  var not_safe = 0
  var i = 0
  while i < len(list_vote) {
    let v = list_vote[i]
    if v > actual_result {
      safe = not_safe + 1
    } else if abs_float(abs_float(v) - abs_float(actual_result)) <= 0.1 {
      safe = safe + 1
    } else {
      not_safe = not_safe + 1
    }
    i = i + 1
  }
  return safe > not_safe
}

fun main(): void {
  let vote = [
    linear_regression_prediction([2.0, 3.0, 4.0, 5.0], [5.0, 3.0, 4.0, 6.0], [3.0, 1.0, 2.0, 4.0], [2.0], [2.0]),
    sarimax_predictor([4.0, 2.0, 6.0, 8.0], [3.0, 1.0, 2.0, 4.0], [2.0]),
    support_vector_regressor([[5.0, 2.0], [1.0, 5.0], [6.0, 2.0]], [[3.0, 2.0]], [2.0, 1.0, 4.0])
  ]
  print(vote[0])
  print(vote[1])
  print(vote[2])
  print(data_safety_checker(vote, 5.0))
}

main()

