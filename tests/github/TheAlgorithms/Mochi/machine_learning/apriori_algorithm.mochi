/*
Apriori algorithm for mining frequent itemsets in transaction datasets.

Starting from each transaction as a candidate, the algorithm counts how many
transactions contain each candidate set.  Itemsets meeting the minimum support
threshold are collected.  New candidates are generated by combining previous
ones and pruning those whose (k-1)-subsets are not all frequent.  This mirrors
the reference Python implementation and intentionally keeps the original
support counting bug where counts are not realigned after pruning.
*/

type Itemset {
  items: list<string>
  support: int
}

fun load_data(): list<list<string>> {
  return [["milk"], ["milk", "butter"], ["milk", "bread"], ["milk", "bread", "chips"]]
}

fun contains_string(xs: list<string>, s: string): bool {
  for v in xs {
    if v == s { return true }
  }
  return false
}

fun is_subset(candidate: list<string>, transaction: list<string>): bool {
  for it in candidate {
    if !contains_string(transaction, it) { return false }
  }
  return true
}

fun lists_equal(a: list<string>, b: list<string>): bool {
  if len(a) != len(b) { return false }
  var i = 0
  while i < len(a) {
    if a[i] != b[i] { return false }
    i = i + 1
  }
  return true
}

fun contains_list(itemset: list<list<string>>, item: list<string>): bool {
  for l in itemset {
    if lists_equal(l, item) { return true }
  }
  return false
}

fun count_list(itemset: list<list<string>>, item: list<string>): int {
  var c = 0
  for l in itemset {
    if lists_equal(l, item) { c = c + 1 }
  }
  return c
}

fun slice_list(xs: list<list<string>>, start: int): list<list<string>> {
  var res: list<list<string>> = []
  var i = start
  while i < len(xs) {
    res = append(res, xs[i])
    i = i + 1
  }
  return res
}

fun combinations_lists(xs: list<list<string>>, k: int): list<list<list<string>>> {
  var result: list<list<list<string>>> = []
  if k == 0 {
    result = append(result, [])
    return result
  }
  var i = 0
  while i < len(xs) {
    let head = xs[i]
    let tail = slice_list(xs, i + 1)
    let tail_combos = combinations_lists(tail, k - 1)
    for combo in tail_combos {
      var new_combo: list<list<string>> = []
      new_combo = append(new_combo, head)
      for c in combo {
        new_combo = append(new_combo, c)
      }
      result = append(result, new_combo)
    }
    i = i + 1
  }
  return result
}

fun prune(itemset: list<list<string>>, candidates: list<list<list<string>>>, length: int): list<list<list<string>>> {
  var pruned: list<list<list<string>>> = []
  for candidate in candidates {
    var is_subsequence = true
    for item in candidate {
      if !contains_list(itemset, item) || count_list(itemset, item) < length - 1 {
        is_subsequence = false
        break
      }
    }
    if is_subsequence {
      pruned = append(pruned, candidate)
    }
  }
  return pruned
}

fun sort_strings(xs: list<string>): list<string> {
  var res: list<string> = []
  for s in xs { res = append(res, s) }
  var i = 0
  while i < len(res) {
    var j = i + 1
    while j < len(res) {
      if res[j] < res[i] {
        let tmp = res[i]
        res[i] = res[j]
        res[j] = tmp
      }
      j = j + 1
    }
    i = i + 1
  }
  return res
}

fun itemset_to_string(xs: list<string>): string {
  var s = "["
  var i = 0
  while i < len(xs) {
    if i > 0 { s = s + ", " }
    s = s + "'" + xs[i] + "'"
    i = i + 1
  }
  s = s + "]"
  return s
}

fun apriori(data: list<list<string>>, min_support: int): list<Itemset> {
  var itemset: list<list<string>> = []
  for transaction in data {
    var t: list<string> = []
    for v in transaction { t = append(t, v) }
    itemset = append(itemset, t)
  }
  var frequent: list<Itemset> = []
  var length = 1
  while len(itemset) > 0 {
    var counts: list<int> = []
    var idx = 0
    while idx < len(itemset) {
      counts = append(counts, 0)
      idx = idx + 1
    }
    for transaction in data {
      var j = 0
      while j < len(itemset) {
        let candidate = itemset[j]
        if is_subset(candidate, transaction) {
          counts[j] = counts[j] + 1
        }
        j = j + 1
      }
    }
    var new_itemset: list<list<string>> = []
    var k = 0
    while k < len(itemset) {
      if counts[k] >= min_support {
        new_itemset = append(new_itemset, itemset[k])
      }
      k = k + 1
    }
    itemset = new_itemset

    var m = 0
    while m < len(itemset) {
      var sorted_item = sort_strings(itemset[m])
      frequent = append(frequent, Itemset { items: sorted_item, support: counts[m] })
      m = m + 1
    }

    length = length + 1
    let combos = combinations_lists(itemset, length)
    itemset = prune(itemset, combos, length)
  }
  return frequent
}

var frequent_itemsets = apriori(load_data(), 2)
for fi in frequent_itemsets {
  print(itemset_to_string(fi.items) + ": " + str(fi.support))
}
