/*
Principal Component Analysis (PCA)
---------------------------------
Given a dataset with numerical features, PCA reduces dimensionality by
transforming the data to a new orthogonal basis that captures the
maximum variance.

This implementation works for two-dimensional features and follows these steps:
1. Standardize each feature to have mean 0 and unit variance.
2. Compute the 2x2 covariance matrix of the standardized data.
3. Use the closed-form solution for eigenvalues and eigenvectors of a
   symmetric 2x2 matrix.
4. Order components by decreasing eigenvalue.
5. Project the standardized data onto the principal component vectors.
6. Compute the explained variance ratio of each component.

Time complexity is O(n) for standardization and projection on a dataset of
n samples with two features.
*/

// Result structure holding transformed data and variance ratios.
type PCAResult {
  transformed: list<list<float>>
  variance_ratio: list<float>
}

fun sqrt(x: float): float {
  var guess = if x > 1.0 { x / 2.0 } else { 1.0 }
  var i = 0
  while i < 20 {
    guess = 0.5 * (guess + x / guess)
    i = i + 1
  }
  return guess
}

fun mean(xs: list<float>): float {
  var sum = 0.0
  var i = 0
  while i < len(xs) {
    sum = sum + xs[i]
    i = i + 1
  }
  return sum / len(xs)
}

fun standardize(data: list<list<float>>): list<list<float>> {
  let n_samples = len(data)
  let n_features = len(data[0])

  // compute mean and std for each column
  var means: list<float> = []
  var stds: list<float> = []
  var j = 0
  while j < n_features {
    var column: list<float> = []
    var i = 0
    while i < n_samples {
      column = append(column, data[i][j])
      i = i + 1
    }
    let m = mean(column)
    means = append(means, m)
    var variance = 0.0
    var k = 0
    while k < n_samples {
      let diff = column[k] - m
      variance = variance + diff * diff
      k = k + 1
    }
    stds = append(stds, sqrt(variance / (n_samples - 1)))
    j = j + 1
  }

  // standardize
  var standardized: list<list<float>> = []
  var r = 0
  while r < n_samples {
    var row: list<float> = []
    var c = 0
    while c < n_features {
      row = append(row, (data[r][c] - means[c]) / stds[c])
      c = c + 1
    }
    standardized = append(standardized, row)
    r = r + 1
  }
  return standardized
}

fun covariance_matrix(data: list<list<float>>): list<list<float>> {
  let n_samples = len(data)
  let n_features = len(data[0])
  var cov: list<list<float>> = []
  var i = 0
  while i < n_features {
    var row: list<float> = []
    var j = 0
    while j < n_features {
      var sum = 0.0
      var k = 0
      while k < n_samples {
        sum = sum + data[k][i] * data[k][j]
        k = k + 1
      }
      row = append(row, sum / (n_samples - 1))
      j = j + 1
    }
    cov = append(cov, row)
    i = i + 1
  }
  return cov
}

fun normalize(vec: list<float>): list<float> {
  var sum = 0.0
  var i = 0
  while i < len(vec) {
    sum = sum + vec[i] * vec[i]
    i = i + 1
  }
  let n = sqrt(sum)
  var res: list<float> = []
  var j = 0
  while j < len(vec) {
    res = append(res, vec[j] / n)
    j = j + 1
  }
  return res
}

type Eigen {
  values: list<float>
  vectors: list<list<float>>
}

fun eigen_decomposition_2x2(matrix: list<list<float>>): Eigen {
  let a = matrix[0][0]
  let b = matrix[0][1]
  let c = matrix[1][1]
  let diff = a - c
  let discriminant = sqrt(diff * diff + 4.0 * b * b)
  let lambda1 = (a + c + discriminant) / 2.0
  let lambda2 = (a + c - discriminant) / 2.0

  var v1: list<float>
  var v2: list<float>
  if b != 0.0 {
    v1 = normalize([lambda1 - c, b])
    v2 = normalize([lambda2 - c, b])
  } else {
    v1 = [1.0, 0.0]
    v2 = [0.0, 1.0]
  }

  var eigenvalues: list<float> = [lambda1, lambda2]
  var eigenvectors: list<list<float>> = [v1, v2]

  // sort by descending eigenvalue
  if eigenvalues[0] < eigenvalues[1] {
    let tmp_val = eigenvalues[0]
    eigenvalues[0] = eigenvalues[1]
    eigenvalues[1] = tmp_val
    let tmp_vec = eigenvectors[0]
    eigenvectors[0] = eigenvectors[1]
    eigenvectors[1] = tmp_vec
  }

  return Eigen{values: eigenvalues, vectors: eigenvectors}
}

fun transpose(matrix: list<list<float>>): list<list<float>> {
  let rows = len(matrix)
  let cols = len(matrix[0])
  var trans: list<list<float>> = []
  var i = 0
  while i < cols {
    var row: list<float> = []
    var j = 0
    while j < rows {
      row = append(row, matrix[j][i])
      j = j + 1
    }
    trans = append(trans, row)
    i = i + 1
  }
  return trans
}

fun matrix_multiply(a: list<list<float>>, b: list<list<float>>): list<list<float>> {
  let rows_a = len(a)
  let cols_a = len(a[0])
  let rows_b = len(b)
  let cols_b = len(b[0])
  if cols_a != rows_b {
    panic("Incompatible matrices")
  }
  var result: list<list<float>> = []
  var i = 0
  while i < rows_a {
    var row: list<float> = []
    var j = 0
    while j < cols_b {
      var sum = 0.0
      var k = 0
      while k < cols_a {
        sum = sum + a[i][k] * b[k][j]
        k = k + 1
      }
      row = append(row, sum)
      j = j + 1
    }
    result = append(result, row)
    i = i + 1
  }
  return result
}

fun apply_pca(data: list<list<float>>, n_components: int): PCAResult {
  let standardized = standardize(data)
  let cov = covariance_matrix(standardized)
  let eig = eigen_decomposition_2x2(cov)
  let eigenvalues = eig.values
  let eigenvectors = eig.vectors
  let components = transpose(eigenvectors)
  let transformed = matrix_multiply(standardized, components)
  let total = eigenvalues[0] + eigenvalues[1]
  var ratios: list<float> = []
  var i = 0
  while i < n_components {
    ratios = append(ratios, eigenvalues[i] / total)
    i = i + 1
  }
  return PCAResult{transformed: transformed, variance_ratio: ratios}
}

let data: list<list<float>> = [
  [2.5, 2.4],
  [0.5, 0.7],
  [2.2, 2.9],
  [1.9, 2.2],
  [3.1, 3.0],
  [2.3, 2.7],
  [2.0, 1.6],
  [1.0, 1.1],
  [1.5, 1.6],
  [1.1, 0.9]
]

let result = apply_pca(data, 2)
print("Transformed Data (first 5 rows):")
var idx = 0
while idx < 5 {
  print(result.transformed[idx])
  idx = idx + 1
}
print("Explained Variance Ratio:")
print(result.variance_ratio)
