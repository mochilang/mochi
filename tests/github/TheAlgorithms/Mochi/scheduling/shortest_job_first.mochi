/*
Shortest Job First (Shortest Remaining Time First) Scheduling

Given lists of arrival times and burst times for a set of processes,
this algorithm schedules the CPU so that at any moment the process with
least remaining burst time among arrived processes runs. It computes for
each process its waiting time and turnaround time and also reports the
average waiting and turnaround times.

Algorithm:
1. Maintain arrays for remaining time and waiting time for all processes.
2. At each time increment, select the available process with minimum
   remaining time.
3. Run the selected process for one unit, updating remaining time.
4. When a process completes, record its waiting time.
5. After all processes finish, compute turnaround times and averages.

Time Complexity: O(n^2) in the worst case due to the inner loop checking
all processes at each time step.
*/

fun calculate_waitingtime(arrival_time: list<int>, burst_time: list<int>, no_of_processes: int): list<int> {
  var remaining_time: list<int> = []
  var i = 0
  while i < no_of_processes {
    remaining_time = append(remaining_time, burst_time[i])
    i = i + 1
  }
  var waiting_time: list<int> = []
  i = 0
  while i < no_of_processes {
    waiting_time = append(waiting_time, 0)
    i = i + 1
  }
  var complete = 0
  var increment_time = 0
  var minm = 1000000000
  var short = 0
  var check = false
  while complete != no_of_processes {
    var j = 0
    while j < no_of_processes {
      if arrival_time[j] <= increment_time && remaining_time[j] > 0 && remaining_time[j] < minm {
        minm = remaining_time[j]
        short = j
        check = true
      }
      j = j + 1
    }
    if !check {
      increment_time = increment_time + 1
      continue
    }
    remaining_time[short] = remaining_time[short] - 1
    minm = remaining_time[short]
    if minm == 0 {
      minm = 1000000000
    }
    if remaining_time[short] == 0 {
      complete = complete + 1
      check = false
      let finish_time = increment_time + 1
      let finar = finish_time - arrival_time[short]
      waiting_time[short] = finar - burst_time[short]
      if waiting_time[short] < 0 {
        waiting_time[short] = 0
      }
    }
    increment_time = increment_time + 1
  }
  return waiting_time
}

fun calculate_turnaroundtime(burst_time: list<int>, no_of_processes: int, waiting_time: list<int>): list<int> {
  var turn_around_time: list<int> = []
  var i = 0
  while i < no_of_processes {
    turn_around_time = append(turn_around_time, burst_time[i] + waiting_time[i])
    i = i + 1
  }
  return turn_around_time
}

fun to_float(x: int): float {
  return x * 1.0
}

fun calculate_average_times(waiting_time: list<int>, turn_around_time: list<int>, no_of_processes: int): void {
  var total_waiting_time = 0
  var total_turn_around_time = 0
  var i = 0
  while i < no_of_processes {
    total_waiting_time = total_waiting_time + waiting_time[i]
    total_turn_around_time = total_turn_around_time + turn_around_time[i]
    i = i + 1
  }
  let avg_wait = to_float(total_waiting_time) / to_float(no_of_processes)
  let avg_turn = to_float(total_turn_around_time) / to_float(no_of_processes)
  print("Average waiting time = " + str(avg_wait))
  print("Average turn around time = " + str(avg_turn))
}

print(calculate_waitingtime([1, 2, 3, 4], [3, 3, 5, 1], 4))
print(calculate_waitingtime([1, 2, 3], [2, 5, 1], 3))
print(calculate_waitingtime([2, 3], [5, 1], 2))

print(calculate_turnaroundtime([3, 3, 5, 1], 4, [0, 3, 5, 0]))
print(calculate_turnaroundtime([3, 3], 2, [0, 3]))
print(calculate_turnaroundtime([8, 10, 1], 3, [1, 0, 3]))

calculate_average_times([0, 3, 5, 0], [3, 6, 10, 1], 4)
calculate_average_times([2, 3], [3, 6], 2)
calculate_average_times([10, 4, 3], [2, 7, 6], 3)
