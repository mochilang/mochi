/*
Non-Preemptive Shortest Job First Scheduling

Given a set of processes with individual arrival times and CPU burst
lengths, the scheduler always selects the process with the shortest
remaining execution time among the processes that have already
arrived. Once a process starts running it executes to completion
(non-preemptive).  The waiting time of a process is the elapsed time
between its arrival and the start of its execution.  The turnaround
time is the total elapsed time from arrival to completion.

This program implements two helper functions:
1. calculate_waitingtime: simulate the dispatcher and compute waiting
   times for every process.
2. calculate_turnaroundtime: add each process's burst time to its
   waiting time.

The example in main reproduces the sample from TheAlgorithms/Python
repository and prints a table together with average waiting and
turnaround times.
*/

fun calculate_waitingtime(
  arrival_time: list<int>,
  burst_time: list<int>,
  no_of_processes: int
): list<int> {
  var waiting_time: list<int>
  var remaining_time: list<int>
  var i = 0
  while i < no_of_processes {
    waiting_time = append(waiting_time, 0)
    remaining_time = append(remaining_time, burst_time[i])
    i = i + 1
  }

  var completed = 0
  var total_time = 0

  while completed != no_of_processes {
    var ready_process: list<int> = []
    var target_process = -1

    var j = 0
    while j < no_of_processes {
      if arrival_time[j] <= total_time && remaining_time[j] > 0 {
        ready_process = append(ready_process, j)
      }
      j = j + 1
    }

    if len(ready_process) > 0 {
      target_process = ready_process[0]
      var k = 0
      while k < len(ready_process) {
        let idx = ready_process[k]
        if remaining_time[idx] < remaining_time[target_process] {
          target_process = idx
        }
        k = k + 1
      }
      total_time = total_time + burst_time[target_process]
      completed = completed + 1
      remaining_time[target_process] = 0
      waiting_time[target_process] = total_time - arrival_time[target_process] - burst_time[target_process]
    } else {
      total_time = total_time + 1
    }
  }
  return waiting_time
}

fun calculate_turnaroundtime(
  burst_time: list<int>,
  no_of_processes: int,
  waiting_time: list<int>
): list<int> {
  var turn_around_time: list<int>
  var i = 0
  while i < no_of_processes {
    turn_around_time = append(turn_around_time, burst_time[i] + waiting_time[i])
    i = i + 1
  }
  return turn_around_time
}

fun average(values: list<int>): float {
  var total = 0
  var i = 0
  while i < len(values) {
    total = total + values[i]
    i = i + 1
  }
  return (total as float) / (len(values) as float)
}

print("[TEST CASE 01]")

let no_of_processes = 4
let burst_time: list<int> = [2, 5, 3, 7]
let arrival_time: list<int> = [0, 0, 0, 0]
let waiting_time = calculate_waitingtime(arrival_time, burst_time, no_of_processes)
let turn_around_time = calculate_turnaroundtime(burst_time, no_of_processes, waiting_time)

print("PID\tBurst Time\tArrival Time\tWaiting Time\tTurnaround Time")
var i = 0
while i < no_of_processes {
  let pid = i + 1
  print(str(pid) + "\t" + str(burst_time[i]) + "\t\t\t" + str(arrival_time[i]) + "\t\t\t\t" + str(waiting_time[i]) + "\t\t\t\t" + str(turn_around_time[i]))
  i = i + 1
}

let avg_wait = average(waiting_time)
let avg_turn = average(turn_around_time)
print("\nAverage waiting time = " + str(avg_wait))
print("Average turnaround time = " + str(avg_turn))
