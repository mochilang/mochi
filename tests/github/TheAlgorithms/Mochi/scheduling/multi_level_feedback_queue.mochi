/*
Simulate the Multi-Level Feedback Queue (MLFQ) CPU scheduling algorithm.
MLFQ maintains several ready queues with decreasing priority. The first
queues use round-robin scheduling with progressively larger time slices
while the last queue uses first-come first-served. Processes start in the
highest-priority queue; if they exhaust their time slice before finishing
they are demoted to the next queue. Waiting time accumulates whenever a
process is not running, turnaround time measures from arrival to
completion and completion time is the final timestamp when the process
finishes. This implementation mirrors TheAlgorithms/Python version using
pure Mochi without FFI and avoids the `any` type so it can run on
`runtime/vm`.
*/

type Process {
  process_name: string,
  arrival_time: int,
  stop_time: int,
  burst_time: int,
  waiting_time: int,
  turnaround_time: int
}

fun make_process(name: string, arrival: int, burst: int): Process {
  return Process {
    process_name: name,
    arrival_time: arrival,
    stop_time: arrival,
    burst_time: burst,
    waiting_time: 0,
    turnaround_time: 0
  }
}

type MLFQ {
  number_of_queues: int,
  time_slices: list<int>,
  ready_queue: list<Process>,
  current_time: int,
  finish_queue: list<Process>
}

fun make_mlfq(nqueues: int, time_slices: list<int>, queue: list<Process>, current_time: int): MLFQ {
  return MLFQ {
    number_of_queues: nqueues,
    time_slices: time_slices,
    ready_queue: queue,
    current_time: current_time,
    finish_queue: []
  }
}

fun calculate_sequence_of_finish_queue(mlfq: MLFQ): list<string> {
  var seq: list<string> = []
  var i = 0
  while i < len(mlfq.finish_queue) {
    let p = mlfq.finish_queue[i]
    seq = append(seq, p.process_name)
    i = i + 1
  }
  return seq
}

fun calculate_waiting_time(queue: list<Process>): list<int> {
  var times: list<int> = []
  var i = 0
  while i < len(queue) {
    let p = queue[i]
    times = append(times, p.waiting_time)
    i = i + 1
  }
  return times
}

fun calculate_turnaround_time(queue: list<Process>): list<int> {
  var times: list<int> = []
  var i = 0
  while i < len(queue) {
    let p = queue[i]
    times = append(times, p.turnaround_time)
    i = i + 1
  }
  return times
}

fun calculate_completion_time(queue: list<Process>): list<int> {
  var times: list<int> = []
  var i = 0
  while i < len(queue) {
    let p = queue[i]
    times = append(times, p.stop_time)
    i = i + 1
  }
  return times
}

fun calculate_remaining_burst_time_of_processes(queue: list<Process>): list<int> {
  var times: list<int> = []
  var i = 0
  while i < len(queue) {
    let p = queue[i]
    times = append(times, p.burst_time)
    i = i + 1
  }
  return times
}

fun update_waiting_time(mlfq: MLFQ, process: Process): int {
  process.waiting_time = process.waiting_time + (mlfq.current_time - process.stop_time)
  return process.waiting_time
}

fun first_come_first_served(mlfq: MLFQ, ready_queue: list<Process>): list<Process> {
  var finished: list<Process> = []
  var rq = ready_queue
  while len(rq) != 0 {
    let cp = rq[0]
    rq = slice(rq, 1, len(rq))
    if mlfq.current_time < cp.arrival_time {
      mlfq.current_time = cp.arrival_time
    }
    update_waiting_time(mlfq, cp)
    mlfq.current_time = mlfq.current_time + cp.burst_time
    cp.burst_time = 0
    cp.turnaround_time = mlfq.current_time - cp.arrival_time
    cp.stop_time = mlfq.current_time
    finished = append(finished, cp)
  }
  mlfq.finish_queue = concat(mlfq.finish_queue, finished)
  return finished
}

type RRResult {
  finished: list<Process>,
  ready: list<Process>
}

fun round_robin(mlfq: MLFQ, ready_queue: list<Process>, time_slice: int): RRResult {
  var finished: list<Process> = []
  var rq = ready_queue
  var count = len(rq)
  var i = 0
  while i < count {
    let cp = rq[0]
    rq = slice(rq, 1, len(rq))
    if mlfq.current_time < cp.arrival_time {
      mlfq.current_time = cp.arrival_time
    }
    update_waiting_time(mlfq, cp)
    if cp.burst_time > time_slice {
      mlfq.current_time = mlfq.current_time + time_slice
      cp.burst_time = cp.burst_time - time_slice
      cp.stop_time = mlfq.current_time
      rq = append(rq, cp)
    } else {
      mlfq.current_time = mlfq.current_time + cp.burst_time
      cp.burst_time = 0
      cp.stop_time = mlfq.current_time
      cp.turnaround_time = mlfq.current_time - cp.arrival_time
      finished = append(finished, cp)
    }
    i = i + 1
  }
  mlfq.finish_queue = concat(mlfq.finish_queue, finished)
  return RRResult { finished: finished, ready: rq }
}

fun multi_level_feedback_queue(mlfq: MLFQ): list<Process> {
  var i = 0
  while i < mlfq.number_of_queues - 1 {
    let rr = round_robin(mlfq, mlfq.ready_queue, mlfq.time_slices[i])
    mlfq.ready_queue = rr.ready
    i = i + 1
  }
  first_come_first_served(mlfq, mlfq.ready_queue)
  return mlfq.finish_queue
}

let P1 = make_process("P1", 0, 53)
let P2 = make_process("P2", 0, 17)
let P3 = make_process("P3", 0, 68)
let P4 = make_process("P4", 0, 24)
let number_of_queues = 3
let time_slices = [17, 25]
let queue: list<Process> = [P1, P2, P3, P4]
let mlfq = make_mlfq(number_of_queues, time_slices, queue, 0)
let finish_queue = multi_level_feedback_queue(mlfq)
print("waiting time:\t\t\t" + str(calculate_waiting_time([P1, P2, P3, P4])))
print("completion time:\t\t" + str(calculate_completion_time([P1, P2, P3, P4])))
print("turnaround time:\t\t" + str(calculate_turnaround_time([P1, P2, P3, P4])))
print("sequence of finished processes:\t" + str(calculate_sequence_of_finish_queue(mlfq)))
