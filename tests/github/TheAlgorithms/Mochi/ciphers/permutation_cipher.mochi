/*
Permutation Cipher - Block-based transposition cipher.

The permutation (or transposition) cipher rearranges characters within fixed-size blocks
according to a secret permutation key. A message whose length is divisible by the block
size is split into consecutive blocks. Each block is reordered by the key and concatenated
to form the ciphertext. Decryption applies the inverse permutation to each block.

To demonstrate the algorithm we:
1. Choose a block size that divides the message length.
2. Generate a pseudo-random permutation key using a simple linear congruential generator.
3. Encrypt by permuting characters in each block using the key.
4. Decrypt using the same key to restore the original message.

Both operations run in O(n) time where n is the message length.
*/

var seed = 1
fun rand(max: int): int {
  seed = (seed * 1103515245 + 12345) % 2147483647
  return seed % max
}

fun generate_valid_block_size(message_length: int): int {
  var factors: list<int> = []
  var i = 2
  while i <= message_length {
    if message_length % i == 0 {
      factors = append(factors, i)
    }
    i = i + 1
  }
  let idx = rand(len(factors))
  return factors[idx]
}

fun generate_permutation_key(block_size: int): list<int> {
  var digits: list<int> = []
  var i = 0
  while i < block_size {
    digits = append(digits, i)
    i = i + 1
  }
  var j = block_size - 1
  while j > 0 {
    let k = rand(j + 1)
    let temp = digits[j]
    digits[j] = digits[k]
    digits[k] = temp
    j = j - 1
  }
  return digits
}

fun encrypt(message: string, key: list<int>, block_size: int): string {
  var encrypted = ""
  var i = 0
  while i < len(message) {
    let block = substring(message, i, i + block_size)
    var j = 0
    while j < block_size {
      encrypted = encrypted + substring(block, key[j], key[j] + 1)
      j = j + 1
    }
    i = i + block_size
  }
  return encrypted
}

fun repeat_string(times: int): list<string> {
  var res: list<string> = []
  var i = 0
  while i < times {
    res = append(res, "")
    i = i + 1
  }
  return res
}

fun decrypt(encrypted: string, key: list<int>): string {
  let klen = len(key)
  var decrypted = ""
  var i = 0
  while i < len(encrypted) {
    let block = substring(encrypted, i, i + klen)
    var original = repeat_string(klen)
    var j = 0
    while j < klen {
      original[key[j]] = substring(block, j, j + 1)
      j = j + 1
    }
    j = 0
    while j < klen {
      decrypted = decrypted + original[j]
      j = j + 1
    }
    i = i + klen
  }
  return decrypted
}

let message = "HELLO WORLD"
let block_size = generate_valid_block_size(len(message))
let key = generate_permutation_key(block_size)
let encrypted = encrypt(message, key, block_size)
let decrypted = decrypt(encrypted, key)
print("Block size: " + str(block_size))
print("Key: " + str(key))
print("Encrypted: " + encrypted)
print("Decrypted: " + decrypted)
