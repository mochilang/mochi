/*
Encode and decode messages using the Bifid cipher.

The Bifid cipher combines the Polybius square with transposition.  Each
letter is located in a 5x5 grid (I/J share a cell) producing a row and
column number.  For encoding, the message is first converted to lowercase,
spaces are removed, and the letter 'j' is replaced with 'i'.  The row and
column numbers of all letters are collected separately.  The two sequences
are concatenated and then read in pairs to look up the final encrypted
letters.  Decoding reverses this process by splitting the combined number
sequence back into row and column halves before looking up letters in the
grid again.

This implementation uses only pure Mochi code with explicit integer and
string types.
*/

let SQUARE: list<list<string>> = [
  ["a", "b", "c", "d", "e"],
  ["f", "g", "h", "i", "k"],
  ["l", "m", "n", "o", "p"],
  ["q", "r", "s", "t", "u"],
  ["v", "w", "x", "y", "z"]
]

fun index_of(s: string, ch: string): int {
  var i = 0
  while i < len(s) {
    if s[i] == ch {
      return i
    }
    i = i + 1
  }
  return -1
}

fun to_lower_without_spaces(message: string, replace_j: bool): string {
  let upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  let lower = "abcdefghijklmnopqrstuvwxyz"
  var res = ""
  var i = 0
  while i < len(message) {
    var ch = message[i]
    let pos = index_of(upper, ch)
    if pos >= 0 {
      ch = lower[pos]
    }
    if ch != " " {
      if replace_j && ch == "j" {
        ch = "i"
      }
      res = res + ch
    }
    i = i + 1
  }
  return res
}

fun letter_to_numbers(letter: string): list<int> {
  var r = 0
  while r < len(SQUARE) {
    var c = 0
    while c < len(SQUARE[r]) {
      if SQUARE[r][c] == letter {
        return [r + 1, c + 1] as list<int>
      }
      c = c + 1
    }
    r = r + 1
  }
  return [0, 0] as list<int>
}

fun numbers_to_letter(row: int, col: int): string {
  return SQUARE[row - 1][col - 1]
}

fun encode(message: string): string {
  let clean = to_lower_without_spaces(message, true)
  let l = len(clean)
  var rows: list<int> = [] as list<int>
  var cols: list<int> = [] as list<int>
  var i = 0
  while i < l {
    let nums = letter_to_numbers(clean[i])
    rows = append(rows, nums[0])
    cols = append(cols, nums[1])
    i = i + 1
  }
  var seq: list<int> = [] as list<int>
  i = 0
  while i < l {
    seq = append(seq, rows[i])
    i = i + 1
  }
  i = 0
  while i < l {
    seq = append(seq, cols[i])
    i = i + 1
  }
  var encoded = ""
  i = 0
  while i < l {
    let r = seq[2 * i]
    let c = seq[2 * i + 1]
    encoded = encoded + numbers_to_letter(r, c)
    i = i + 1
  }
  return encoded
}

fun decode(message: string): string {
  let clean = to_lower_without_spaces(message, false)
  let l = len(clean)
  var first: list<int> = [] as list<int>
  var i = 0
  while i < l {
    let nums = letter_to_numbers(clean[i])
    first = append(first, nums[0])
    first = append(first, nums[1])
    i = i + 1
  }
  var top: list<int> = [] as list<int>
  var bottom: list<int> = [] as list<int>
  i = 0
  while i < l {
    top = append(top, first[i])
    bottom = append(bottom, first[i + l])
    i = i + 1
  }
  var decoded = ""
  i = 0
  while i < l {
    let r = top[i]
    let c = bottom[i]
    decoded = decoded + numbers_to_letter(r, c)
    i = i + 1
  }
  return decoded
}

print(encode("testmessage"))
print(encode("Test Message"))
print(encode("test j"))
print(encode("test i"))
print(decode("qtltbdxrxlk"))
