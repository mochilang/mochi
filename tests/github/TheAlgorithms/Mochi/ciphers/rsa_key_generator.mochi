/*
  RSA Key Generator using simple deterministic randomness.

  The algorithm demonstrates how public and private keys are created.
  Steps:
  1. Generate two pseudo-random primes p and q with the requested bit size.
  2. Compute n = p * q and Euler's totient phi = (p - 1) * (q - 1).
  3. Choose e such that gcd(e, phi) = 1.
  4. Compute d, the modular multiplicative inverse of e mod phi.

  The returned keys are (n, e) for the public key and (n, d) for the private
  key.  This example uses an 8-bit key size so the primes are small and the
  program runs quickly.
*/

fun pow2(exp: int): int {
  var res = 1
  var i = 0
  while i < exp {
    res = res * 2
    i = i + 1
  }
  return res
}

var seed: int = 1
fun next_seed(x: int): int {
  return (x * 1103515245 + 12345) % 2147483648
}

fun rand_range(min: int, max: int): int {
  seed = next_seed(seed)
  return min + seed % (max - min)
}

fun gcd(a: int, b: int): int {
  var x = a
  var y = b
  while y != 0 {
    let temp = x % y
    x = y
    y = temp
  }
  return x
}

fun mod_inverse(e: int, phi: int): int {
  var t = 0
  var newt = 1
  var r = phi
  var newr = e
  while newr != 0 {
    let quotient = r / newr
    let tmp = newt
    newt = t - quotient * newt
    t = tmp
    let tmp_r = newr
    newr = r - quotient * newr
    r = tmp_r
  }
  if r > 1 { return 0 }
  if t < 0 { t = t + phi }
  return t
}

fun is_prime(n: int): bool {
  if n < 2 { return false }
  var i = 2
  while i * i <= n {
    if n % i == 0 { return false }
    i = i + 1
  }
  return true
}

fun generate_prime(bits: int): int {
  let min = pow2(bits - 1)
  let max = pow2(bits)
  var p = rand_range(min, max)
  if p % 2 == 0 { p = p + 1 }
  while !is_prime(p) {
    p = p + 2
    if p >= max {
      p = min + 1
    }
  }
  return p
}

type Keys {
  public_key: list<int>,
  private_key: list<int>
}

fun generate_key(bits: int): Keys {
  let p = generate_prime(bits)
  let q = generate_prime(bits)
  let n = p * q
  let phi = (p - 1) * (q - 1)
  var e = rand_range(2, phi)
  while gcd(e, phi) != 1 {
    e = e + 1
    if e >= phi { e = 2 }
  }
  let d = mod_inverse(e, phi)
  return Keys {
    public_key: [n, e],
    private_key: [n, d]
  }
}

let keys = generate_key(8)
let pub = keys.public_key
let priv = keys.private_key
print("Public key: (" + str(pub[0]) + ", " + str(pub[1]) + ")")
print("Private key: (" + str(priv[0]) + ", " + str(priv[1]) + ")")
