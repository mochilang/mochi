/*
Compute the modular inverse of an integer a modulo m using the extended Euclidean algorithm.

The algorithm first ensures that a and m are coprime by checking gcd(a, m) == 1. If they are not,
no modular inverse exists. The extended Euclidean algorithm maintains two sets of coefficients
(u1, u2, u3) and (v1, v2, v3) such that u1*a + u2*m = u3 and v1*a + v2*m = v3. Repeatedly
subtracting multiples of one row from the other (as in the Euclidean algorithm) reduces v3 until it
reaches 0, leaving u1 as the inverse of a modulo m. The time complexity is O(log m).
*/

fun gcd(a: int, b: int): int {
  var x = if a < 0 { -a } else { a }
  var y = if b < 0 { -b } else { b }
  while y != 0 {
    let t = x % y
    x = y
    y = t
  }
  return x
}

fun find_mod_inverse(a: int, m: int): int {
  if gcd(a, m) != 1 {
    error("mod inverse of " + str(a) + " and " + str(m) + " does not exist")
  }
  var u1 = 1
  var u2 = 0
  var u3 = a
  var v1 = 0
  var v2 = 1
  var v3 = m
  while v3 != 0 {
    let q = u3 / v3
    let t1 = u1 - q * v1
    let t2 = u2 - q * v2
    let t3 = u3 - q * v3
    u1 = v1
    u2 = v2
    u3 = v3
    v1 = t1
    v2 = t2
    v3 = t3
  }
  let res = u1 % m
  if res < 0 {
    res = res + m
  }
  return res
}

print(str(find_mod_inverse(3, 11)))
print(str(find_mod_inverse(7, 26)))
print(str(find_mod_inverse(11, 26)))
print(str(find_mod_inverse(17, 43)))
