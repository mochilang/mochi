/*
Polybius square cipher implementation.
A 5x5 grid of letters encodes each letter as a pair of numbers.
Letters 'a'..'z' (with 'j' merged into 'i') are mapped to their row and column.
Encoding replaces each letter with its coordinates, preserving spaces.
Decoding reverses the process, converting pairs of digits back to letters.
*/

let square: list<list<string>> = [
  ["a", "b", "c", "d", "e"],
  ["f", "g", "h", "i", "k"],
  ["l", "m", "n", "o", "p"],
  ["q", "r", "s", "t", "u"],
  ["v", "w", "x", "y", "z"],
]

fun letter_to_numbers(letter: string): list<int> {
  var i = 0
  while i < len(square) {
    var j = 0
    while j < len(square[i]) {
      if square[i][j] == letter {
        return [i + 1, j + 1]
      }
      j = j + 1
    }
    i = i + 1
  }
  return [0, 0]
}

fun numbers_to_letter(index1: int, index2: int): string {
  return square[index1 - 1][index2 - 1]
}

fun char_to_int(ch: string): int {
  if ch == "1" { return 1 }
  if ch == "2" { return 2 }
  if ch == "3" { return 3 }
  if ch == "4" { return 4 }
  if ch == "5" { return 5 }
  return 0
}

fun encode(message: string): string {
  message = lower(message)
  var encoded = ""
  var i = 0
  while i < len(message) {
    var ch = message[i]
    if ch == "j" { ch = "i" }
    if ch != " " {
      let nums = letter_to_numbers(ch)
      encoded = encoded + str(nums[0]) + str(nums[1])
    } else {
      encoded = encoded + " "
    }
    i = i + 1
  }
  return encoded
}

fun decode(message: string): string {
  var decoded = ""
  var i = 0
  while i < len(message) {
    if message[i] == " " {
      decoded = decoded + " "
      i = i + 1
    } else {
      let index1 = char_to_int(message[i])
      let index2 = char_to_int(message[i + 1])
      let letter = numbers_to_letter(index1, index2)
      decoded = decoded + letter
      i = i + 2
    }
  }
  return decoded
}

print(encode("test message"))
print(encode("Test Message"))
print(decode("44154344 32154343112215"))
print(decode("4415434432154343112215"))
