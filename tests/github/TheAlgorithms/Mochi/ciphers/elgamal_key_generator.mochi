/*
  Generate an ElGamal key pair.

  Steps:
    1. Generate a prime \(p\) of the requested bit size using the
       probabilistic Miller–Rabin primality test.
    2. Pick a primitive root \(g\) modulo \(p\).
    3. Choose a secret exponent \(d\) (the private key).
    4. Compute \(e_2 = g^{-d} mod\; p\) using the modular inverse.

  The public key is \((key\_size, g, e_2, p)\) and the private key is
  \((key\_size, d)\).

  A simple linear congruential generator provides pseudo‑random numbers so
  the code remains self‑contained and free from external dependencies.
*/

var seed = 123456789

fun rand(): int {
  seed = (seed * 1103515245 + 12345) % 2147483647
  return seed
}

fun rand_range(min: int, max: int): int {
  return min + rand() % (max - min + 1)
}

fun mod_pow(base: int, exponent: int, modulus: int): int {
  var result = 1
  var b = base % modulus
  var e = exponent
  while e > 0 {
    if e % 2 == 1 {
      result = (result * b) % modulus
    }
    e = e / 2
    b = (b * b) % modulus
  }
  return result
}

type GCD = { g: int, x: int, y: int }

fun extended_gcd(a: int, b: int): GCD {
  if b == 0 { return GCD{ g: a, x: 1, y: 0 } }
  let res = extended_gcd(b, a % b)
  return GCD{ g: res.g, x: res.y, y: res.x - (a / b) * res.y }
}

fun mod_inverse(a: int, m: int): int {
  let res = extended_gcd(a, m)
  if res.g != 1 { panic("inverse does not exist") }
  let r = res.x % m
  if r < 0 { return r + m }
  return r
}

fun pow2(n: int): int {
  var r = 1
  var i = 0
  while i < n {
    r = r * 2
    i = i + 1
  }
  return r
}

fun is_probable_prime(n: int, k: int): bool {
  if n <= 1 { return false }
  if n <= 3 { return true }
  if n % 2 == 0 { return false }
  var r = 0
  var d = n - 1
  while d % 2 == 0 {
    d = d / 2
    r = r + 1
  }
  var i = 0
  while i < k {
    let a = rand_range(2, n - 2)
    var x = mod_pow(a, d, n)
    if x == 1 || x == n - 1 {
      i = i + 1
      continue
    }
    var j = 1
    var found = false
    while j < r {
      x = mod_pow(x, 2, n)
      if x == n - 1 {
        found = true
        break
      }
      j = j + 1
    }
    if !found { return false }
    i = i + 1
  }
  return true
}

fun generate_large_prime(bits: int): int {
  let min = pow2(bits - 1)
  let max = pow2(bits) - 1
  var p = rand_range(min, max)
  if p % 2 == 0 { p = p + 1 }
  while !is_probable_prime(p, 5) {
    p = p + 2
    if p > max { p = min + 1 }
  }
  return p
}

fun primitive_root(p: int): int {
  while true {
    let g = rand_range(3, p - 1)
    if mod_pow(g, 2, p) == 1 { continue }
    if mod_pow(g, p, p) == 1 { continue }
    return g
  }
}

type PublicKey = { key_size: int, g: int, e2: int, p: int }
type PrivateKey = { key_size: int, d: int }
type KeyPair = { public_key: PublicKey, private_key: PrivateKey }

fun generate_key(key_size: int): KeyPair {
  let p = generate_large_prime(key_size)
  let e1 = primitive_root(p)
  let d = rand_range(3, p - 1)
  let e2 = mod_inverse(mod_pow(e1, d, p), p)
  let public_key = PublicKey{ key_size: key_size, g: e1, e2: e2, p: p }
  let private_key = PrivateKey{ key_size: key_size, d: d }
  return KeyPair{ public_key: public_key, private_key: private_key }
}

fun main() {
  let key_size = 16
  let kp = generate_key(key_size)
  let pub = kp.public_key
  let priv = kp.private_key
  print("public key: (" + str(pub.key_size) + ", " + str(pub.g) + ", " + str(pub.e2) + ", " + str(pub.p) + ")")
  print("private key: (" + str(priv.key_size) + ", " + str(priv.d) + ")")
}

main()
