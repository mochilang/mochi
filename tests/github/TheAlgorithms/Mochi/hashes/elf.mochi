/*
Elf Hash Algorithm

This is an implementation of the ElfHash algorithm, a variant of the PJW hash.
For each character in the input string:
1. Shift the current hash left by four bits and add the character's ASCII code.
2. Isolate the high 4 bits with a mask of 0xF0000000.
3. If any high bits are set, XOR the hash with those bits shifted right by 24.
4. Clear the high bits from the hash.

Time complexity is O(n) for n characters. All bitwise operations
(AND, XOR, NOT, shifts) are implemented using integer arithmetic.
*/

let ascii = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"

fun ord(ch: string): int {
  var i = 0
  while i < len(ascii) {
    if ascii[i:i+1] == ch { return 32 + i }
    i = i + 1
  }
  return 0
}

fun bit_and(a: int, b: int): int {
  var ua = a
  var ub = b
  var res = 0
  var bit = 1
  while ua > 0 || ub > 0 {
    if ua % 2 == 1 && ub % 2 == 1 { res = res + bit }
    ua = (ua / 2) as int
    ub = (ub / 2) as int
    bit = bit * 2
  }
  return res
}

fun bit_xor(a: int, b: int): int {
  var ua = a
  var ub = b
  var res = 0
  var bit = 1
  while ua > 0 || ub > 0 {
    let abit = ua % 2
    let bbit = ub % 2
    if abit != bbit { res = res + bit }
    ua = (ua / 2) as int
    ub = (ub / 2) as int
    bit = bit * 2
  }
  return res
}

fun bit_not32(x: int): int {
  var ux = x
  var res = 0
  var bit = 1
  var count = 0
  while count < 32 {
    if ux % 2 == 0 { res = res + bit }
    ux = (ux / 2) as int
    bit = bit * 2
    count = count + 1
  }
  return res
}

fun elf_hash(data: string): int {
  var hash_ = 0
  var i = 0
  while i < len(data) {
    let c = ord(data[i:i+1])
    hash_ = hash_ * 16 + c
    let x = bit_and(hash_, 4026531840)
    if x != 0 {
      hash_ = bit_xor(hash_, (x / 16777216) as int)
    }
    hash_ = bit_and(hash_, bit_not32(x))
    i = i + 1
  }
  return hash_
}

print(str(elf_hash("lorem ipsum")))
