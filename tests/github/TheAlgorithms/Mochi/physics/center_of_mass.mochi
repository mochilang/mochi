/*
Compute the three-dimensional center of mass of a set of particles.
Each particle is defined by its (x, y, z) position and a positive mass.
The center of mass is the weighted average of positions where weights
are the particle masses:
  R = Σ(m_i * r_i) / Σ(m_i)
If the particle list is empty or contains a non-positive mass the
function panics, mirroring the Python implementation that raises a
ValueError.  The algorithm traverses the particles twice leading to
O(n) time complexity and constant extra space.
*/

type Particle {
  x: float,
  y: float,
  z: float,
  mass: float
}

type Coord3D {
  x: float,
  y: float,
  z: float
}

fun round2(x: float): float {
  let scaled = x * 100.0
  let rounded = ((scaled + 0.5) as int) as float
  return rounded / 100.0
}

fun center_of_mass(ps: list<Particle>): Coord3D {
  if len(ps) == 0 {
    panic("No particles provided")
  }
  var i: int = 0
  var total_mass: float = 0.0
  while i < len(ps) {
    let p = ps[i]
    if p.mass <= 0.0 {
      panic("Mass of all particles must be greater than 0")
    }
    total_mass = total_mass + p.mass
    i = i + 1
  }
  var sum_x: float = 0.0
  var sum_y: float = 0.0
  var sum_z: float = 0.0
  i = 0
  while i < len(ps) {
    let p = ps[i]
    sum_x = sum_x + p.x * p.mass
    sum_y = sum_y + p.y * p.mass
    sum_z = sum_z + p.z * p.mass
    i = i + 1
  }
  let cm_x = round2(sum_x / total_mass)
  let cm_y = round2(sum_y / total_mass)
  let cm_z = round2(sum_z / total_mass)
  return Coord3D{x: cm_x, y: cm_y, z: cm_z}
}

fun coord_to_string(c: Coord3D): string {
  return "Coord3D(x=" + str(c.x) + ", y=" + str(c.y) + ", z=" + str(c.z) + ")"
}

let r1 = center_of_mass([
  Particle{x: 1.5, y: 4.0, z: 3.4, mass: 4.0},
  Particle{x: 5.0, y: 6.8, z: 7.0, mass: 8.1},
  Particle{x: 9.4, y: 10.1, z: 11.6, mass: 12.0}
])
print(coord_to_string(r1))

let r2 = center_of_mass([
  Particle{x: 1.0, y: 2.0, z: 3.0, mass: 4.0},
  Particle{x: 5.0, y: 6.0, z: 7.0, mass: 8.0},
  Particle{x: 9.0, y: 10.0, z: 11.0, mass: 12.0}
])
print(coord_to_string(r2))
