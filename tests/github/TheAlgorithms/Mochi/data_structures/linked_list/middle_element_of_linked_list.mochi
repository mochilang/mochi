/*
Find the middle element of a singly linked list. Values are stored in an
array where new elements are inserted at the head. The middle is found by
advancing two pointers: one moves two nodes at a time and the other moves
one. When the fast pointer reaches the end, the slow pointer is at the
middle. This runs in O(n) time and O(1) extra space.

The demonstration builds a list, printing each inserted value, then
prints the middle element. Calling the middle function on an empty list
reports that no element was found.
*/

type List { data: list<int> }

fun empty_list(): List {
  return List { data: [] }
}

fun push(lst: List, value: int): List {
  var res: list<int> = [value]
  var i = 0
  while i < len(lst.data) {
    res = append(res, lst.data[i])
    i = i + 1
  }
  return List { data: res }
}

fun middle_element(lst: List): int {
  let n = len(lst.data)
  if n == 0 {
    print("No element found.")
    return 0
  }
  var slow = 0
  var fast = 0
  while fast + 1 < n {
    fast = fast + 2
    slow = slow + 1
  }
  return lst.data[slow]
}

fun main() {
  var lst = empty_list()
  middle_element(lst)
  lst = push(lst, 5); print(5)
  lst = push(lst, 6); print(6)
  lst = push(lst, 8); print(8)
  lst = push(lst, 8); print(8)
  lst = push(lst, 10); print(10)
  lst = push(lst, 12); print(12)
  lst = push(lst, 17); print(17)
  lst = push(lst, 7); print(7)
  lst = push(lst, 3); print(3)
  lst = push(lst, 20); print(20)
  lst = push(lst, -20); print(-20)
  print(middle_element(lst))
}

main()
