/*
Implement a Trie (prefix tree) that stores words using a node array. Each node
keeps a map from characters to indexes of child nodes and a flag indicating
whether the path to that node forms a complete word.

Insertion creates child nodes as needed and marks the last node as a leaf.
Lookup walks the character map to verify a word exists. Deletion uses
recursion to unmark leaves and prune nodes that no longer lead to any word.
*/

type Node {
  children: map<string, int>,
  is_leaf: bool,
}

type Trie {
  nodes: list<Node>,
}

fun new_trie(): Trie {
  return Trie { nodes: [Node { children: {}, is_leaf: false }] }
}

fun remove_key(m: map<string, int>, k: string): map<string, int> {
  var out: map<string, int> = {}
  for key in m {
    if key != k {
      out[key] = m[key]
    }
  }
  return out
}

fun insert(trie: Trie, word: string) {
  var nodes = trie.nodes
  var curr = 0
  var i = 0
  while i < len(word) {
    let ch = word[i]
    var child_idx = -1
    let children = nodes[curr].children
    if ch in children {
      child_idx = children[ch]
    } else {
      let new_node = Node { children: {}, is_leaf: false }
      nodes = append(nodes, new_node)
      child_idx = len(nodes) - 1
      var new_children = children
      new_children[ch] = child_idx
      var node = nodes[curr]
      node.children = new_children
      nodes[curr] = node
    }
    curr = child_idx
    i = i + 1
  }
  var node = nodes[curr]
  node.is_leaf = true
  nodes[curr] = node
  trie.nodes = nodes
}

fun insert_many(trie: Trie, words: list<string>) {
  for w in words {
    insert(trie, w)
  }
}

fun find(trie: Trie, word: string): bool {
  let nodes = trie.nodes
  var curr = 0
  var i = 0
  while i < len(word) {
    let ch = word[i]
    let children = nodes[curr].children
    if !(ch in children) {
      return false
    }
    curr = children[ch]
    i = i + 1
  }
  let node = nodes[curr]
  return node.is_leaf
}

fun delete(trie: Trie, word: string) {
  var nodes = trie.nodes
  fun _delete(idx: int, pos: int): bool {
    if pos == len(word) {
      var node = nodes[idx]
      if node.is_leaf == false {
        return false
      }
      node.is_leaf = false
      nodes[idx] = node
      return len(node.children) == 0
    }
    var node = nodes[idx]
    let children = node.children
    let ch = word[pos]
    if !(ch in children) {
      return false
    }
    let child_idx = children[ch]
    let should_delete = _delete(child_idx, pos + 1)
    node = nodes[idx]
    if should_delete {
      var new_children = remove_key(node.children, ch)
      node.children = new_children
      nodes[idx] = node
      return len(new_children) == 0 && node.is_leaf == false
    }
    nodes[idx] = node
    return false
  }
  _delete(0, 0)
  trie.nodes = nodes
}


fun print_words(trie: Trie) {
  fun dfs(idx: int, word: string) {
    let node = trie.nodes[idx]
    if node.is_leaf {
      print(word)
    }
    for key in node.children {
      dfs(node.children[key], word + key)
    }
  }
  dfs(0, "")
}

fun test_trie(): bool {
  let words: list<string> = ["banana", "bananas", "bandana", "band", "apple", "all", "beast"]
  let trie = new_trie()
  insert_many(trie, words)
  var ok = true
  for w in words {
    ok = ok && find(trie, w)
  }
  ok = ok && find(trie, "banana")
  var t = find(trie, "bandanas")
  ok = ok && (t == false)
  var t2 = find(trie, "apps")
  ok = ok && (t2 == false)
  ok = ok && find(trie, "apple")
  ok = ok && find(trie, "all")
  delete(trie, "all")
  var t3 = find(trie, "all")
  ok = ok && (t3 == false)
  delete(trie, "banana")
  var t4 = find(trie, "banana")
  ok = ok && (t4 == false)
  ok = ok && find(trie, "bananas")
  return ok
}

fun print_results(msg: string, passes: bool) {
  if passes {
    print(msg + " works!")
  } else {
    print(msg + " doesn't work :(")
  }
}

let trie = new_trie()
// Demonstrate by running tests through print_results
print_results("Testing trie functionality", test_trie())
