/*
Disjoint Set (Union-Find) Data Structure

This program demonstrates the union-find data structure, which keeps track of
partitioned elements into disjoint sets. Each element initially forms its own
set. Two main operations are supported:

1. find_set(x): Returns the representative of the set containing x. It uses
   path compression, making future queries faster by pointing each visited node
   directly to the set representative.

2. union_set(x, y): Merges the sets containing x and y. Union by rank ensures
   the tree representing each set remains shallow by attaching the shorter tree
   under the taller one. When both trees have the same rank, one becomes the
   parent and its rank increases by one.

In this example, six nodes are grouped into two sets {0,1,2} and {3,4,5}. The
program verifies that elements from the same group share the same representative
while elements from different groups do not. After performing unions, it prints
the representative for each element.
*/

type DS = { parent: list<int>, rank: list<int> }
type FindResult = { ds: DS, root: int }

fun make_set(ds: DS, x: int): DS {
  var p = ds.parent
  var r = ds.rank
  p[x] = x
  r[x] = 0
  return DS{ parent: p, rank: r }
}

fun find_set(ds: DS, x: int): FindResult {
  if ds.parent[x] == x {
    return FindResult{ ds: ds, root: x }
  }
  let res = find_set(ds, ds.parent[x])
  var p = res.ds.parent
  p[x] = res.root
  return FindResult{ ds: DS{ parent: p, rank: res.ds.rank }, root: res.root }
}

fun union_set(ds: DS, x: int, y: int): DS {
  let fx = find_set(ds, x)
  let ds1 = fx.ds
  let x_root = fx.root
  let fy = find_set(ds1, y)
  let ds2 = fy.ds
  let y_root = fy.root
  if x_root == y_root { return ds2 }
  var p = ds2.parent
  var r = ds2.rank
  if r[x_root] > r[y_root] {
    p[y_root] = x_root
  } else {
    p[x_root] = y_root
    if r[x_root] == r[y_root] {
      r[y_root] = r[y_root] + 1
    }
  }
  return DS{ parent: p, rank: r }
}

fun same_python_set(a: int, b: int): bool {
  if a < 3 && b < 3 { return true }
  if a >= 3 && a < 6 && b >= 3 && b < 6 { return true }
  return false
}

var ds = DS{ parent: [], rank: [] }
var i = 0
while i < 6 {
  ds.parent = append(ds.parent, 0)
  ds.rank = append(ds.rank, 0)
  ds = make_set(ds, i)
  i = i + 1
}

ds = union_set(ds, 0, 1)
ds = union_set(ds, 1, 2)
ds = union_set(ds, 3, 4)
ds = union_set(ds, 3, 5)

i = 0
while i < 6 {
  var j = 0
  while j < 6 {
    let res_i = find_set(ds, i)
    ds = res_i.ds
    let root_i = res_i.root
    let res_j = find_set(ds, j)
    ds = res_j.ds
    let root_j = res_j.root
    let same = same_python_set(i, j)
    let root_same = root_i == root_j
    if same {
      if !root_same { panic("nodes should be in same set") }
    } else {
      if root_same { panic("nodes should be in different sets") }
    }
    j = j + 1
  }
  i = i + 1
}

i = 0
while i < 6 {
  let res = find_set(ds, i)
  ds = res.ds
  print(str(res.root))
  i = i + 1
}
