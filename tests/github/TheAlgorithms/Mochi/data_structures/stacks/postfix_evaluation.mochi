/*
Evaluate arithmetic expressions given in Reverse Polish (postfix) notation.

Tokens are processed from left to right.  Operands are pushed onto a stack.
When an operator is encountered, operands are popped from the stack and the
operation result is pushed back.  Unary plus or minus is handled when the
stack contains only one value.  Supported operators are +, -, *, / and ^.

The algorithm runs in O(n) time for n tokens and uses O(n) stack space.
*/

fun slice_without_last(xs: list<float>): list<float> {
  var res: list<float> = []
  var i = 0
  while i < len(xs) - 1 {
    res = append(res, xs[i])
    i = i + 1
  }
  return res
}

fun parse_float(token: string): float {
  var sign = 1.0
  var idx = 0
  if len(token) > 0 {
    let first = substring(token, 0, 1)
    if first == "-" {
      sign = -1.0
      idx = 1
    } else if first == "+" {
      idx = 1
    }
  }
  var int_part = 0
  while idx < len(token) && substring(token, idx, idx + 1) != "." {
    int_part = int_part * 10 + int(substring(token, idx, idx + 1))
    idx = idx + 1
  }
  var result = 1.0 * int_part
  if idx < len(token) && substring(token, idx, idx + 1) == "." {
    idx = idx + 1
    var place = 0.1
    while idx < len(token) {
      let digit = int(substring(token, idx, idx + 1))
      result = result + place * (1.0 * digit)
      place = place / 10.0
      idx = idx + 1
    }
  }
  return sign * result
}

fun pow_float(base: float, exp: float): float {
  var result = 1.0
  var i = 0
  let e = int(exp)
  while i < e {
    result = result * base
    i = i + 1
  }
  return result
}

fun apply_op(a: float, b: float, op: string): float {
  if op == "+" { return a + b }
  if op == "-" { return a - b }
  if op == "*" { return a * b }
  if op == "/" { return a / b }
  if op == "^" { return pow_float(a, b) }
  return 0.0
}

fun evaluate(tokens: list<string>): float {
  if len(tokens) == 0 { return 0.0 }
  var stack: list<float> = []
  for token in tokens {
    if token == "+" || token == "-" || token == "*" || token == "/" || token == "^" {
      if (token == "+" || token == "-") && len(stack) < 2 {
        let b = stack[len(stack) - 1]
        stack = slice_without_last(stack)
        if token == "-" {
          stack = append(stack, 0.0 - b)
        } else {
          stack = append(stack, b)
        }
      } else {
        let b = stack[len(stack) - 1]
        stack = slice_without_last(stack)
        let a = stack[len(stack) - 1]
        stack = slice_without_last(stack)
        let result = apply_op(a, b, token)
        stack = append(stack, result)
      }
    } else {
      stack = append(stack, parse_float(token))
    }
  }
  if len(stack) != 1 {
    panic("Invalid postfix expression")
  }
  return stack[0]
}

print(str(evaluate(["2", "1", "+", "3", "*"])))
print(str(evaluate(["4", "13", "5", "/", "+"])))
print(str(evaluate(["5", "6", "9", "*", "+"])))
print(str(evaluate(["2", "-", "3", "+"])))
print(str(evaluate([])))
