/*
Find the lowest common ancestor (LCA) of two nodes in a rooted tree using
binary lifting.  The algorithm first performs a breadth‑first search (BFS) from
the root to compute the depth of each node and record its immediate parent.
Using these parents a sparse table parent[j][i] is built where parent[j][i]
stores the 2^j‑th ancestor of node i.  To find the LCA of nodes u and v we:
  1. Swap nodes so that u is the deeper node.
  2. Lift u upwards until both nodes are at the same depth.
  3. Lift both nodes simultaneously from the highest power of two downwards
     until their ancestors diverge.
  4. Return the parent of the divergence point.
This method answers each LCA query in O(log N) time after O(N log N) preprocessing.
*/

fun pow2(exp: int): int {
  var res = 1
  var i = 0
  while i < exp {
    res = res * 2
    i = i + 1
  }
  return res
}

fun create_sparse(max_node: int, parent: list<list<int>>): list<list<int>> {
  var j = 1
  while pow2(j) < max_node {
    var i = 1
    while i <= max_node {
      parent[j][i] = parent[j - 1][parent[j - 1][i]]
      i = i + 1
    }
    j = j + 1
  }
  return parent
}

fun lowest_common_ancestor(u: int, v: int, level: list<int>, parent: list<list<int>>): int {
  if level[u] < level[v] {
    let temp = u
    u = v
    v = temp
  }
  var i = 18
  while i >= 0 {
    if level[u] - pow2(i) >= level[v] {
      u = parent[i][u]
    }
    i = i - 1
  }
  if u == v { return u }
  i = 18
  while i >= 0 {
    let pu = parent[i][u]
    let pv = parent[i][v]
    if pu != 0 && pu != pv {
      u = pu
      v = pv
    }
    i = i - 1
  }
  return parent[0][u]
}

fun breadth_first_search(level: list<int>, parent: list<list<int>>, max_node: int, graph: map<int, list<int>>, root: int) {
  level[root] = 0
  var q: list<int> = []
  q = append(q, root)
  var head = 0
  while head < len(q) {
    let u = q[head]
    head = head + 1
    let adj = graph[u]
    var j = 0
    while j < len(adj) {
      let v = adj[j]
      if level[v] == 0 - 1 {
        level[v] = level[u] + 1
        parent[0][v] = u
        q = append(q, v)
      }
      j = j + 1
    }
  }
}

fun main() {
  let max_node = 13
  var parent: list<list<int>> = []
  var i = 0
  while i < 20 {
    var row: list<int> = []
    var j = 0
    while j < max_node + 10 {
      row = append(row, 0)
      j = j + 1
    }
    parent = append(parent, row)
    i = i + 1
  }
  var level: list<int> = []
  i = 0
  while i < max_node + 10 {
    level = append(level, 0 - 1)
    i = i + 1
  }
  var graph: map<int, list<int>> = {}
  graph[1] = [2, 3, 4]
  graph[2] = [5]
  graph[3] = [6, 7]
  graph[4] = [8]
  graph[5] = [9, 10]
  graph[6] = [11]
  graph[7] = []
  graph[8] = [12, 13]
  graph[9] = []
  graph[10] = []
  graph[11] = []
  graph[12] = []
  graph[13] = []
  breadth_first_search(level, parent, max_node, graph, 1)
  parent = create_sparse(max_node, parent)
  print("LCA of node 1 and 3 is: " + str(lowest_common_ancestor(1, 3, level, parent)))
  print("LCA of node 5 and 6 is: " + str(lowest_common_ancestor(5, 6, level, parent)))
  print("LCA of node 7 and 11 is: " + str(lowest_common_ancestor(7, 11, level, parent)))
  print("LCA of node 6 and 7 is: " + str(lowest_common_ancestor(6, 7, level, parent)))
  print("LCA of node 4 and 12 is: " + str(lowest_common_ancestor(4, 12, level, parent)))
  print("LCA of node 8 and 8 is: " + str(lowest_common_ancestor(8, 8, level, parent)))
}

main()
