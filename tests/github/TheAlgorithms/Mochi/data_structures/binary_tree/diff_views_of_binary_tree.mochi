/*
Compute different views of a binary tree using breadth-first traversals.

The tree is stored as parallel arrays of node values and left/right child
indices (or -1 when absent).  Four views are derived:

1. Right Side View – breadth-first traversal taking the last node at each level.
2. Left Side View – similar traversal taking the first node at each level.
3. Top View – breadth-first traversal tracking horizontal distance from the
   root and recording the first node seen at each distance.
4. Bottom View – like the top view but keeps the most recently seen node for
   each distance.

All operations run in O(n) time for a tree of n nodes.
*/

type Tree {
  values: list<int>,
  lefts: list<int>,
  rights: list<int>,
  root: int
}

let NIL = 0 - 1

fun make_tree(): Tree {
  return Tree{
    values: [3,9,20,15,7],
    lefts:  [1,NIL,3,NIL,NIL],
    rights: [2,NIL,4,NIL,NIL],
    root: 0
  }
}

fun index_of(xs: list<int>, x: int): int {
  var i = 0
  while i < len(xs) {
    if xs[i] == x { return i }
    i = i + 1
  }
  return NIL
}

fun sort_pairs(hds: list<int>, vals: list<int>) {
  var i = 0
  while i < len(hds) {
    var j = i
    while j > 0 && hds[j - 1] > hds[j] {
      let hd_tmp = hds[j - 1]
      hds[j - 1] = hds[j]
      hds[j] = hd_tmp
      let val_tmp = vals[j - 1]
      vals[j - 1] = vals[j]
      vals[j] = val_tmp
      j = j - 1
    }
    i = i + 1
  }
}

fun right_view(t: Tree): list<int> {
  var res: list<int> = []
  var queue: list<int> = [t.root]
  while len(queue) > 0 {
    let size = len(queue)
    var i = 0
    while i < size {
      let idx = queue[i]
      if t.lefts[idx] != NIL { queue = append(queue, t.lefts[idx]) }
      if t.rights[idx] != NIL { queue = append(queue, t.rights[idx]) }
      i = i + 1
    }
    res = append(res, t.values[queue[size - 1]])
    queue = queue[size:len(queue)]
  }
  return res
}

fun left_view(t: Tree): list<int> {
  var res: list<int> = []
  var queue: list<int> = [t.root]
  while len(queue) > 0 {
    let size = len(queue)
    var i = 0
    while i < size {
      let idx = queue[i]
      if t.lefts[idx] != NIL { queue = append(queue, t.lefts[idx]) }
      if t.rights[idx] != NIL { queue = append(queue, t.rights[idx]) }
      i = i + 1
    }
    res = append(res, t.values[queue[0]])
    queue = queue[size:len(queue)]
  }
  return res
}

type Pair {
  idx: int,
  hd: int
}

fun top_view(t: Tree): list<int> {
  var hds: list<int> = []
  var vals: list<int> = []
  var queue_idx: list<int> = [t.root]
  var queue_hd: list<int> = [0]
  while len(queue_idx) > 0 {
    let idx = queue_idx[0]
    queue_idx = queue_idx[1:len(queue_idx)]
    let hd = queue_hd[0]
    queue_hd = queue_hd[1:len(queue_hd)]
    if index_of(hds, hd) == NIL {
      hds = append(hds, hd)
      vals = append(vals, t.values[idx])
    }
    if t.lefts[idx] != NIL {
      queue_idx = append(queue_idx, t.lefts[idx])
      queue_hd = append(queue_hd, hd - 1)
    }
    if t.rights[idx] != NIL {
      queue_idx = append(queue_idx, t.rights[idx])
      queue_hd = append(queue_hd, hd + 1)
    }
  }
  sort_pairs(hds, vals)
  return vals
}

fun bottom_view(t: Tree): list<int> {
  var hds: list<int> = []
  var vals: list<int> = []
  var queue_idx: list<int> = [t.root]
  var queue_hd: list<int> = [0]
  while len(queue_idx) > 0 {
    let idx = queue_idx[0]
    queue_idx = queue_idx[1:len(queue_idx)]
    let hd = queue_hd[0]
    queue_hd = queue_hd[1:len(queue_hd)]
    let pos = index_of(hds, hd)
    if pos == NIL {
      hds = append(hds, hd)
      vals = append(vals, t.values[idx])
    } else {
      vals[pos] = t.values[idx]
    }
    if t.lefts[idx] != NIL {
      queue_idx = append(queue_idx, t.lefts[idx])
      queue_hd = append(queue_hd, hd - 1)
    }
    if t.rights[idx] != NIL {
      queue_idx = append(queue_idx, t.rights[idx])
      queue_hd = append(queue_hd, hd + 1)
    }
  }
  sort_pairs(hds, vals)
  return vals
}

let tree = make_tree()
print(right_view(tree))
print(left_view(tree))
print(top_view(tree))
print(bottom_view(tree))
