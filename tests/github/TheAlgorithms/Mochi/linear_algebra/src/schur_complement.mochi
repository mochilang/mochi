/*
Compute the Schur complement of a block matrix.
Given matrices A (n x n), B (n x m), and C (m x m),
the Schur complement of A in the symmetric block matrix
[[A, B], [B^T, C]] is defined as S = C - B^T * A^{-1} * B.
Matrix A must be square and invertible.  If an inverse of A
is supplied via `pseudo_inv`, that matrix will be used instead
of computing the inverse.  The implementation works on lists
of floats and uses Gauss-Jordan elimination to obtain matrix
inverses.
*/

type OptionMatrix {
  value: list<list<float>>,
  ok: bool,
}

fun identity(n: int): list<list<float>> {
  var mat: list<list<float>> = []
  var i = 0
  while i < n {
    var row: list<float> = []
    var j = 0
    while j < n {
      if i == j {
        row = append(row, 1.0)
      } else {
        row = append(row, 0.0)
      }
      j = j + 1
    }
    mat = append(mat, row)
    i = i + 1
  }
  return mat
}

fun transpose(mat: list<list<float>>): list<list<float>> {
  let rows = len(mat)
  let cols = len(mat[0])
  var res: list<list<float>> = []
  var j = 0
  while j < cols {
    var row: list<float> = []
    var i = 0
    while i < rows {
      row = append(row, mat[i][j])
      i = i + 1
    }
    res = append(res, row)
    j = j + 1
  }
  return res
}

fun matmul(a: list<list<float>>, b: list<list<float>>): list<list<float>> {
  let rows = len(a)
  let cols = len(b[0])
  let inner = len(a[0])
  var res: list<list<float>> = []
  var i = 0
  while i < rows {
    var row: list<float> = []
    var j = 0
    while j < cols {
      var sum = 0.0
      var k = 0
      while k < inner {
        sum = sum + a[i][k] * b[k][j]
        k = k + 1
      }
      row = append(row, sum)
      j = j + 1
    }
    res = append(res, row)
    i = i + 1
  }
  return res
}

fun mat_sub(a: list<list<float>>, b: list<list<float>>): list<list<float>> {
  let rows = len(a)
  let cols = len(a[0])
  var res: list<list<float>> = []
  var i = 0
  while i < rows {
    var row: list<float> = []
    var j = 0
    while j < cols {
      row = append(row, a[i][j] - b[i][j])
      j = j + 1
    }
    res = append(res, row)
    i = i + 1
  }
  return res
}

fun inverse(mat: list<list<float>>): list<list<float>> {
  let n = len(mat)
  let id = identity(n)
  var aug: list<list<float>> = []
  var i = 0
  while i < n {
    let row = concat(mat[i], id[i])
    aug = append(aug, row)
    i = i + 1
  }
  var col = 0
  while col < n {
    var pivot_row = aug[col]
    let pivot = pivot_row[col]
    if pivot == 0.0 { panic("matrix is singular") }
    var j = 0
    while j < 2 * n {
      pivot_row[j] = pivot_row[j] / pivot
      j = j + 1
    }
    aug[col] = pivot_row
    var r = 0
    while r < n {
      if r != col {
        var row_r = aug[r]
        let factor = row_r[col]
        j = 0
        while j < 2 * n {
          row_r[j] = row_r[j] - factor * pivot_row[j]
          j = j + 1
        }
        aug[r] = row_r
      }
      r = r + 1
    }
    col = col + 1
  }
  var inv: list<list<float>> = []
  var r = 0
  while r < n {
    var row: list<float> = []
    var c = n
    while c < 2 * n {
      row = append(row, aug[r][c])
      c = c + 1
    }
    inv = append(inv, row)
    r = r + 1
  }
  return inv
}

fun schur_complement(mat_a: list<list<float>>, mat_b: list<list<float>>, mat_c: list<list<float>>, pseudo_inv: OptionMatrix): list<list<float>> {
  let a_rows = len(mat_a)
  let a_cols = len(mat_a[0])
  if a_rows != a_cols { panic("Matrix A must be square") }
  if a_rows != len(mat_b) { panic("Expected the same number of rows for A and B") }
  if len(mat_b[0]) != len(mat_c[0]) { panic("Expected the same number of columns for B and C") }
  var a_inv: list<list<float>>
  if pseudo_inv.ok {
    a_inv = pseudo_inv.value
  } else {
    a_inv = inverse(mat_a)
  }
  let bt = transpose(mat_b)
  let a_inv_b = matmul(a_inv, mat_b)
  let bt_a_inv_b = matmul(bt, a_inv_b)
  return mat_sub(mat_c, bt_a_inv_b)
}

fun print_matrix(mat: list<list<float>>) {
  var i = 0
  while i < len(mat) {
    var line = ""
    var j = 0
    let row = mat[i]
    while j < len(row) {
      line = line + str(row[j])
      if j + 1 < len(row) { line = line + " " }
      j = j + 1
    }
    print(line)
    i = i + 1
  }
}

fun main() {
  let a = [[1.0, 2.0], [2.0, 1.0]]
  let b = [[0.0, 3.0], [3.0, 0.0]]
  let c = [[2.0, 1.0], [6.0, 3.0]]
  let none = OptionMatrix { value: [], ok: false }
  let s = schur_complement(a, b, c, none)
  print_matrix(s)
}

main()
