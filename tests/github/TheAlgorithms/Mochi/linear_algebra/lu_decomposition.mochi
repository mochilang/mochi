/*
LU Decomposition

This program implements the Doolittle algorithm for LU decomposition of a
square matrix.  Given a matrix A, it factorizes it into a lower triangular
matrix L with unit diagonal and an upper triangular matrix U such that
A = L * U.

For each row i, the algorithm computes the entries below the diagonal of L by
subtracting the dot product of the previously computed rows and dividing by the
pivot element from U.  The diagonal of L is set to 1.0.  Then the entries of
U on and above the diagonal are obtained by subtracting the dot product of
corresponding elements from L and U.  If a zero pivot occurs, the matrix does
not admit an LU decomposition.
*/

type LU = { lower: list<list<float>>, upper: list<list<float>> }

fun lu_decomposition(mat: list<list<float>>): LU {
  let n = len(mat)
  if n == 0 { return LU { lower: [], upper: [] } }
  let m = len(mat[0])
  if n != m { panic("Matrix must be square") }
  var lower: list<list<float>> = []
  var upper: list<list<float>> = []
  var i: int = 0
  while i < n {
    var lrow: list<float> = []
    var urow: list<float> = []
    var j: int = 0
    while j < n {
      lrow = append(lrow, 0.0)
      urow = append(urow, 0.0)
      j = j + 1
    }
    lower = append(lower, lrow)
    upper = append(upper, urow)
    i = i + 1
  }
  i = 0
  while i < n {
    var j1: int = 0
    while j1 < i {
      var total: float = 0.0
      var k: int = 0
      while k < i {
        total = total + lower[i][k] * upper[k][j1]
        k = k + 1
      }
      if upper[j1][j1] == 0.0 { panic("No LU decomposition exists") }
      lower[i][j1] = (mat[i][j1] - total) / upper[j1][j1]
      j1 = j1 + 1
    }
    lower[i][i] = 1.0
    var j2: int = i
    while j2 < n {
      var total2: float = 0.0
      var k2: int = 0
      while k2 < i {
        total2 = total2 + lower[i][k2] * upper[k2][j2]
        k2 = k2 + 1
      }
      upper[i][j2] = mat[i][j2] - total2
      j2 = j2 + 1
    }
    i = i + 1
  }
  return LU { lower: lower, upper: upper }
}

fun print_matrix(mat: list<list<float>>) {
  var i: int = 0
  while i < len(mat) {
    var line: string = ""
    var j: int = 0
    while j < len(mat[i]) {
      line = line + str(mat[i][j])
      if j + 1 < len(mat[i]) { line = line + " " }
      j = j + 1
    }
    print(line)
    i = i + 1
  }
}

let matrix: list<list<float>> = [
  [2.0, -2.0, 1.0],
  [0.0, 1.0, 2.0],
  [5.0, 3.0, 1.0]
]
let result = lu_decomposition(matrix)
print_matrix(result.lower)
print_matrix(result.upper)
