// Generated by Mochi compiler v0.10.25 on 2025-07-13T13:13:22Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Char_name {
    id: i32,
    name: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Cast_info {
    movie_id: i32,
    person_role_id: i32,
    role_id: i32,
    note: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Company_name {
    id: i32,
    country_code: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Company_type {
    id: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Movie_companie {
    movie_id: i32,
    company_id: i32,
    company_type_id: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Role_type {
    id: i32,
    role: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Title {
    id: i32,
    title: &'static str,
    production_year: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result {
    character: &'static str,
    movie: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result1 {
    uncredited_voiced_character: &'static str,
    russian_movie: &'static str,
}

fn min<T: PartialOrd + Copy>(v: &[T]) -> T {
    *v.iter().min_by(|a,b| a.partial_cmp(b).unwrap()).unwrap()
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let char_name = vec![Char_name { id: 1, name: "Ivan" }, Char_name { id: 2, name: "Alex" }];
    let cast_info = vec![Cast_info { movie_id: 10, person_role_id: 1, role_id: 1, note: "Soldier (voice) (uncredited)" }, Cast_info { movie_id: 11, person_role_id: 2, role_id: 1, note: "(voice)" }];
    let company_name = vec![Company_name { id: 1, country_code: "[ru]" }, Company_name { id: 2, country_code: "[us]" }];
    let company_type = vec![Company_type { id: 1 }, Company_type { id: 2 }];
    let movie_companies = vec![Movie_companie { movie_id: 10, company_id: 1, company_type_id: 1 }, Movie_companie { movie_id: 11, company_id: 2, company_type_id: 1 }];
    let role_type = vec![Role_type { id: 1, role: "actor" }, Role_type { id: 2, role: "director" }];
    let title = vec![Title { id: 10, title: "Vodka Dreams", production_year: 2006 }, Title { id: 11, title: "Other Film", production_year: 2004 }];
    let matches = { let mut tmp1 = Vec::new();for chn in &char_name { for ci in &cast_info { if !(chn.id == ci.person_role_id) { continue; } for rt in &role_type { if !(rt.id == ci.role_id) { continue; } for t in &title { if !(t.id == ci.movie_id) { continue; } for mc in &movie_companies { if !(mc.movie_id == t.id) { continue; } for cn in &company_name { if !(cn.id == mc.company_id) { continue; } for ct in &company_type { if !(ct.id == mc.company_type_id) { continue; } if !(ci.note.contains("(voice)") && ci.note.contains("(uncredited)") && cn.country_code == "[ru]" && rt.role == "actor" && t.production_year > 2005) { continue; } tmp1.push(Result { character: chn.name, movie: t.title }); } } } } } } } tmp1 };
    let result = vec![Result1 { uncredited_voiced_character: min(&{ let mut tmp2 = Vec::new();for x in &matches { tmp2.push(x.character); } tmp2 }), russian_movie: min(&{ let mut tmp3 = Vec::new();for x in &matches { tmp3.push(x.movie); } tmp3 }) }];
    _json(&result);
    assert!(result == vec![Result1 { uncredited_voiced_character: "Ivan", russian_movie: "Vodka Dreams" }]);
}
