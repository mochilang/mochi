// Generated by Mochi compiler v0.10.25 on 2025-07-13T14:18:36Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Company_type {
    id: i32,
    kind: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Info_type {
    id: i32,
    info: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Title {
    id: i32,
    title: &'static str,
    production_year: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Movie_companie {
    movie_id: i32,
    company_type_id: i32,
    note: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Movie_info_idx {
    movie_id: i32,
    info_type_id: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result {
    note: &'static str,
    title: &'static str,
    year: i32,
}

fn min<T: PartialOrd + Copy>(v: &[T]) -> T {
    *v.iter().min_by(|a,b| a.partial_cmp(b).unwrap()).unwrap()
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let company_type = vec![Company_type { id: 1, kind: "production companies" }, Company_type { id: 2, kind: "distributors" }];
    let info_type = vec![Info_type { id: 10, info: "top 250 rank" }, Info_type { id: 20, info: "bottom 10 rank" }];
    let title = vec![Title { id: 100, title: "Good Movie", production_year: 1995 }, Title { id: 200, title: "Bad Movie", production_year: 2000 }];
    let movie_companies = vec![Movie_companie { movie_id: 100, company_type_id: 1, note: "ACME (co-production)" }, Movie_companie { movie_id: 200, company_type_id: 1, note: "MGM (as Metro-Goldwyn-Mayer Pictures)" }];
    let movie_info_idx = vec![Movie_info_idx { movie_id: 100, info_type_id: 10 }, Movie_info_idx { movie_id: 200, info_type_id: 20 }];
    let filtered = { let mut tmp1 = Vec::new();for ct in &company_type { for mc in &movie_companies { if !(ct.id == mc.company_type_id) { continue; } for t in &title { if !(t.id == mc.movie_id) { continue; } for mi in &movie_info_idx { if !(mi.movie_id == t.id) { continue; } for it in &info_type { if !(it.id == mi.info_type_id) { continue; } if !(ct.kind == "production companies" && it.info == "top 250 rank" && (!mc.note.contains("(as Metro-Goldwyn-Mayer Pictures)")) && (mc.note.contains("(co-production)") || mc.note.contains("(presents)"))) { continue; } tmp1.push(Result { note: mc.note, title: t.title, year: t.production_year }); } } } } } tmp1 };
    let result = { let mut m = std::collections::BTreeMap::new(); m.insert("production_note", min(&{ let mut tmp2 = Vec::new();for r in &filtered { tmp2.push(r.note); } tmp2 })); m.insert("movie_title", min(&{ let mut tmp3 = Vec::new();for r in &filtered { tmp3.push(r.title); } tmp3 })); m.insert("movie_year", min(&{ let mut tmp4 = Vec::new();for r in &filtered { tmp4.push(r.year); } tmp4 })); m };
    _json(&vec![result.clone()]);
    assert!(result.clone() == { let mut m = std::collections::BTreeMap::new(); m.insert("production_note", "ACME (co-production)"); m.insert("movie_title", "Good Movie"); m.insert("movie_year", 1995); m });
}
