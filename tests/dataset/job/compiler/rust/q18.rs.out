// Generated by Mochi compiler v0.10.25 on 2025-07-13T11:53:26Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Info_type {
    id: i32,
    info: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Name {
    id: i32,
    name: &'static str,
    gender: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Title {
    id: i32,
    title: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Cast_info {
    movie_id: i32,
    person_id: i32,
    note: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Movie_info {
    movie_id: i32,
    info_type_id: i32,
    info: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Movie_info_idx {
    movie_id: i32,
    info_type_id: i32,
    info: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result {
    budget: i32,
    votes: i32,
    title: &'static str,
}

fn min<T: PartialOrd + Copy>(v: &[T]) -> T {
    *v.iter().min_by(|a,b| a.partial_cmp(b).unwrap()).unwrap()
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let info_type = vec![Info_type { id: 1, info: "budget" }, Info_type { id: 2, info: "votes" }, Info_type { id: 3, info: "rating" }];
    let name = vec![Name { id: 1, name: "Big Tim", gender: "m" }, Name { id: 2, name: "Slim Tim", gender: "m" }, Name { id: 3, name: "Alice", gender: "f" }];
    let title = vec![Title { id: 10, title: "Alpha" }, Title { id: 20, title: "Beta" }, Title { id: 30, title: "Gamma" }];
    let cast_info = vec![Cast_info { movie_id: 10, person_id: 1, note: "(producer)" }, Cast_info { movie_id: 20, person_id: 2, note: "(executive producer)" }, Cast_info { movie_id: 30, person_id: 3, note: "(producer)" }];
    let movie_info = vec![Movie_info { movie_id: 10, info_type_id: 1, info: 90 }, Movie_info { movie_id: 20, info_type_id: 1, info: 120 }, Movie_info { movie_id: 30, info_type_id: 1, info: 110 }];
    let movie_info_idx = vec![Movie_info_idx { movie_id: 10, info_type_id: 2, info: 500 }, Movie_info_idx { movie_id: 20, info_type_id: 2, info: 400 }, Movie_info_idx { movie_id: 30, info_type_id: 2, info: 800 }];
    let rows = { let mut tmp1 = Vec::new();for ci in &cast_info { for n in &name { if !(n.id == ci.person_id) { continue; } for t in &title { if !(t.id == ci.movie_id) { continue; } for mi in &movie_info { if !(mi.movie_id == t.id) { continue; } for mi_idx in &movie_info_idx { if !(mi_idx.movie_id == t.id) { continue; } for it1 in &info_type { if !(it1.id == mi.info_type_id) { continue; } for it2 in &info_type { if !(it2.id == mi_idx.info_type_id) { continue; } if !((vec!["(producer)", "(executive producer)"].contains(&ci.note) && it1.info == "budget" && it2.info == "votes" && n.gender == "m" && n.name.contains("Tim") && t.id == ci.movie_id && ci.movie_id == mi.movie_id && ci.movie_id == mi_idx.movie_id && mi.movie_id == mi_idx.movie_id)) { continue; } tmp1.push(Result { budget: mi.info, votes: mi_idx.info, title: t.title }); } } } } } } } tmp1 };
    let result = { let mut m = std::collections::BTreeMap::new(); m.insert("movie_budget", min(&{ let mut tmp2 = Vec::new();for r in &rows { tmp2.push(r.budget); } tmp2 })); m.insert("movie_votes", min(&{ let mut tmp3 = Vec::new();for r in &rows { tmp3.push(r.votes); } tmp3 })); m.insert("movie_title", min(&{ let mut tmp4 = Vec::new();for r in &rows { tmp4.push(r.title); } tmp4 })); m };
    _json(&result.clone());
    assert!(result.clone() == { let mut m = std::collections::BTreeMap::new(); m.insert("movie_budget", 90); m.insert("movie_votes", 400); m.insert("movie_title", "Alpha"); m });
}
