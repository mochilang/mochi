// Generated by Mochi compiler v0.10.25 on 2025-07-13T14:18:40Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Info_type {
    id: i32,
    info: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Keyword {
    id: i32,
    keyword: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Kind_type {
    id: i32,
    kind: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Title {
    id: i32,
    kind_id: i32,
    production_year: i32,
    title: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Movie_info {
    movie_id: i32,
    info_type_id: i32,
    info: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Movie_info_idx {
    movie_id: i32,
    info_type_id: i32,
    info: f64,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Movie_keyword {
    movie_id: i32,
    keyword_id: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result {
    rating: f64,
    title: &'static str,
}

fn min<T: PartialOrd + Copy>(v: &[T]) -> T {
    *v.iter().min_by(|a,b| a.partial_cmp(b).unwrap()).unwrap()
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let info_type = vec![Info_type { id: 1, info: "countries" }, Info_type { id: 2, info: "rating" }];
    let keyword = vec![Keyword { id: 1, keyword: "murder" }, Keyword { id: 2, keyword: "blood" }, Keyword { id: 3, keyword: "romance" }];
    let kind_type = vec![Kind_type { id: 1, kind: "movie" }];
    let title = vec![Title { id: 1, kind_id: 1, production_year: 2012, title: "A Dark Movie" }, Title { id: 2, kind_id: 1, production_year: 2013, title: "Brutal Blood" }, Title { id: 3, kind_id: 1, production_year: 2008, title: "Old Film" }];
    let movie_info = vec![Movie_info { movie_id: 1, info_type_id: 1, info: "Sweden" }, Movie_info { movie_id: 2, info_type_id: 1, info: "USA" }, Movie_info { movie_id: 3, info_type_id: 1, info: "USA" }];
    let movie_info_idx = vec![Movie_info_idx { movie_id: 1, info_type_id: 2, info: 7.0 }, Movie_info_idx { movie_id: 2, info_type_id: 2, info: 7.5 }, Movie_info_idx { movie_id: 3, info_type_id: 2, info: 9.1 }];
    let movie_keyword = vec![Movie_keyword { movie_id: 1, keyword_id: 1 }, Movie_keyword { movie_id: 2, keyword_id: 2 }, Movie_keyword { movie_id: 3, keyword_id: 3 }];
    let allowed_keywords = vec!["murder", "murder-in-title", "blood", "violence"];
    let allowed_countries = vec!["Sweden", "Norway", "Germany", "Denmark", "Swedish", "Denish", "Norwegian", "German", "USA", "American"];
    let matches = { let mut tmp1 = Vec::new();for it1 in &info_type { for it2 in &info_type { for k in &keyword { for kt in &kind_type { for mi in &movie_info { for mi_idx in &movie_info_idx { for mk in &movie_keyword { for t in &title { if !((it1.info == "countries" && it2.info == "rating" && (allowed_keywords.contains(&k.keyword)) && kt.kind == "movie" && (allowed_countries.contains(&mi.info)) && mi_idx.info < 8.5 && t.production_year > 2010 && kt.id == t.kind_id && t.id == mi.movie_id && t.id == mk.movie_id && t.id == mi_idx.movie_id && mk.movie_id == mi.movie_id && mk.movie_id == mi_idx.movie_id && mi.movie_id == mi_idx.movie_id && k.id == mk.keyword_id && it1.id == mi.info_type_id && it2.id == mi_idx.info_type_id)) { continue; } tmp1.push(Result { rating: mi_idx.info, title: t.title }); } } } } } } } } tmp1 };
    let result = { let mut m = std::collections::BTreeMap::new(); m.insert("rating", min(&{ let mut tmp2 = Vec::new();for x in &matches { tmp2.push(x.rating); } tmp2 })); m.insert("northern_dark_movie", min(&{ let mut tmp3 = Vec::new();for x in &matches { tmp3.push(x.title); } tmp3 })); m };
    _json(&result.clone());
    assert!(result.clone() == { let mut m = std::collections::BTreeMap::new(); m.insert("rating", 7.0); m.insert("northern_dark_movie", "A Dark Movie"); m });
}
