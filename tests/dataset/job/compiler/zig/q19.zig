// Generated by Mochi compiler v0.10.25 on 2025-07-13T12:55:50Z
const std = @import("std");

fn expect(cond: bool) void {
    if (!cond) @panic("expect failed");
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _min_int(v: []const i32) i32 {
    if (v.len == 0) return 0;
    var m: i32 = v[0];
    for (v[1..]) |it| { if (it < m) m = it; }
    return m;
}

fn _contains_list_string(v: []const []const u8, item: []const u8) bool {
    for (v) |it| { if (std.mem.eql(u8, it, item)) return true; }
    return false;
}

fn _json(v: anytype) void {
    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    defer buf.deinit();
    std.json.stringify(v, .{}, buf.writer()) catch |err| handleError(err);
    std.debug.print("{s}\n", .{buf.items});
}

const AkaNameItem = struct {
    person_id: i32,
    name: []const u8,
};
const aka_name = &[_]AkaNameItem{
    AkaNameItem{
    .person_id = 1,
    .name = "A. Stone",
},
    AkaNameItem{
    .person_id = 2,
    .name = "J. Doe",
},
}; // []const AkaNameItem
const CharNameItem = struct {
    id: i32,
    name: []const u8,
};
const char_name = &[_]CharNameItem{
    CharNameItem{
    .id = 1,
    .name = "Protagonist",
},
    CharNameItem{
    .id = 2,
    .name = "Extra",
},
}; // []const CharNameItem
const CastInfoItem = struct {
    movie_id: i32,
    person_role_id: i32,
    person_id: i32,
    role_id: i32,
    note: []const u8,
};
const cast_info = &[_]CastInfoItem{
    CastInfoItem{
    .movie_id = 1,
    .person_role_id = 1,
    .person_id = 1,
    .role_id = 1,
    .note = "(voice)",
},
    CastInfoItem{
    .movie_id = 2,
    .person_role_id = 2,
    .person_id = 2,
    .role_id = 2,
    .note = "Cameo",
},
}; // []const CastInfoItem
const CompanyNameItem = struct {
    id: i32,
    country_code: []const u8,
};
const company_name = &[_]CompanyNameItem{
    CompanyNameItem{
    .id = 10,
    .country_code = "[us]",
},
    CompanyNameItem{
    .id = 20,
    .country_code = "[gb]",
},
}; // []const CompanyNameItem
const InfoTypeItem = struct {
    id: i32,
    info: []const u8,
};
const info_type = &[_]InfoTypeItem{InfoTypeItem{
    .id = 100,
    .info = "release dates",
}}; // []const InfoTypeItem
const MovieCompaniesItem = struct {
    movie_id: i32,
    company_id: i32,
    note: []const u8,
};
const movie_companies = &[_]MovieCompaniesItem{
    MovieCompaniesItem{
    .movie_id = 1,
    .company_id = 10,
    .note = "Studio (USA)",
},
    MovieCompaniesItem{
    .movie_id = 2,
    .company_id = 20,
    .note = "Other (worldwide)",
},
}; // []const MovieCompaniesItem
const MovieInfoItem = struct {
    movie_id: i32,
    info_type_id: i32,
    info: []const u8,
};
const movie_info = &[_]MovieInfoItem{
    MovieInfoItem{
    .movie_id = 1,
    .info_type_id = 100,
    .info = "USA: June 2006",
},
    MovieInfoItem{
    .movie_id = 2,
    .info_type_id = 100,
    .info = "UK: 1999",
},
}; // []const MovieInfoItem
const NameItem = struct {
    id: i32,
    name: []const u8,
    gender: []const u8,
};
const name = &[_]NameItem{
    NameItem{
    .id = 1,
    .name = "Angela Stone",
    .gender = "f",
},
    NameItem{
    .id = 2,
    .name = "Bob Angstrom",
    .gender = "m",
},
}; // []const NameItem
const RoleTypeItem = struct {
    id: i32,
    role: []const u8,
};
const role_type = &[_]RoleTypeItem{
    RoleTypeItem{
    .id = 1,
    .role = "actress",
},
    RoleTypeItem{
    .id = 2,
    .role = "actor",
},
}; // []const RoleTypeItem
const TitleItem = struct {
    id: i32,
    title: []const u8,
    production_year: i32,
};
const title = &[_]TitleItem{
    TitleItem{
    .id = 1,
    .title = "Voiced Movie",
    .production_year = 2006,
},
    TitleItem{
    .id = 2,
    .title = "Other Movie",
    .production_year = 2010,
},
}; // []const TitleItem
const ResultStruct0 = struct {
    actress: []const u8,
    movie: []const u8,
};
var matches: []const MatchesItem = undefined; // []const MatchesItem
const ResultItem = struct {
    voicing_actress: i32,
    voiced_movie: i32,
};
const result = &[_]ResultItem{ResultItem{
    .voicing_actress = _min_int(blk1: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); for (matches) |r| { _tmp3.append(r.actress) catch |err| handleError(err); } const _tmp4 = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk1 _tmp4; }),
    .voiced_movie = _min_int(blk2: { var _tmp5 = std.ArrayList(i32).init(std.heap.page_allocator); for (matches) |r| { _tmp5.append(r.movie) catch |err| handleError(err); } const _tmp6 = _tmp5.toOwnedSlice() catch |err| handleError(err); break :blk2 _tmp6; }),
}}; // []const ResultItem

fn test_Q19_finds_female_voice_actress_in_US_Japan_release_between_2005_and_2009() void {
    expect((result == &[_]ResultItem{ResultItem{
    .voicing_actress = "Angela Stone",
    .voiced_movie = "Voiced Movie",
}}));
}

pub fn main() void {
    matches = blk0: { var _tmp1 = std.ArrayList(ResultStruct0).init(std.heap.page_allocator); for (aka_name) |an| { for (name) |n| { if (!((n.id == an.person_id))) continue; for (cast_info) |ci| { if (!((ci.person_id == an.person_id))) continue; for (char_name) |chn| { if (!((chn.id == ci.person_role_id))) continue; for (role_type) |rt| { if (!((rt.id == ci.role_id))) continue; for (title) |t| { if (!((t.id == ci.movie_id))) continue; for (movie_companies) |mc| { if (!((mc.movie_id == t.id))) continue; for (company_name) |cn| { if (!((cn.id == mc.company_id))) continue; for (movie_info) |mi| { if (!((mi.movie_id == t.id))) continue; for (info_type) |it| { if (!((it.id == mi.info_type_id))) continue; if (!((((((((((((_contains_list_string(&[_][]const u8{
    "(voice)",
    "(voice: Japanese version)",
    "(voice) (uncredited)",
    "(voice: English version)",
}, ci.note) and std.mem.eql(u8, cn.country_code, "[us]")) and std.mem.eql(u8, it.info, "release dates")) and !std.mem.eql(u8, mc.note, 0)) and ((mc.note.contains("(USA)") or mc.note.contains("(worldwide)")))) and !std.mem.eql(u8, mi.info, 0)) and ((((mi.info.contains("Japan:") and mi.info.contains("200"))) or ((mi.info.contains("USA:") and mi.info.contains("200")))))) and std.mem.eql(u8, n.gender, "f")) and n.name.contains("Ang")) and std.mem.eql(u8, rt.role, "actress")) and (t.production_year >= 2005)) and (t.production_year <= 2009)))) continue; _tmp1.append(ResultStruct0{
    .actress = n.name,
    .movie = t.title,
}) catch |err| handleError(err); } } } } } } } } } } const _tmp2 = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk0 _tmp2; };
    _json(result);
    test_Q19_finds_female_voice_actress_in_US_Japan_release_between_2005_and_2009();
}
