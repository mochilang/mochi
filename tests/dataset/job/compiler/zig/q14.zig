// Generated by Mochi compiler v0.10.25 on 2025-07-13T12:55:49Z
const std = @import("std");

fn expect(cond: bool) void {
    if (!cond) @panic("expect failed");
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _min_int(v: []const i32) i32 {
    if (v.len == 0) return 0;
    var m: i32 = v[0];
    for (v[1..]) |it| { if (it < m) m = it; }
    return m;
}

fn _contains_list_string(v: []const []const u8, item: []const u8) bool {
    for (v) |it| { if (std.mem.eql(u8, it, item)) return true; }
    return false;
}

fn _json(v: anytype) void {
    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    defer buf.deinit();
    std.json.stringify(v, .{}, buf.writer()) catch |err| handleError(err);
    std.debug.print("{s}\n", .{buf.items});
}

const InfoTypeItem = struct {
    id: i32,
    info: []const u8,
};
const info_type = &[_]InfoTypeItem{
    InfoTypeItem{
    .id = 1,
    .info = "countries",
},
    InfoTypeItem{
    .id = 2,
    .info = "rating",
},
}; // []const InfoTypeItem
const KeywordItem = struct {
    id: i32,
    keyword: []const u8,
};
const keyword = &[_]KeywordItem{
    KeywordItem{
    .id = 1,
    .keyword = "murder",
},
    KeywordItem{
    .id = 2,
    .keyword = "blood",
},
    KeywordItem{
    .id = 3,
    .keyword = "romance",
},
}; // []const KeywordItem
const KindTypeItem = struct {
    id: i32,
    kind: []const u8,
};
const kind_type = &[_]KindTypeItem{KindTypeItem{
    .id = 1,
    .kind = "movie",
}}; // []const KindTypeItem
const TitleItem = struct {
    id: i32,
    kind_id: i32,
    production_year: i32,
    title: []const u8,
};
const title = &[_]TitleItem{
    TitleItem{
    .id = 1,
    .kind_id = 1,
    .production_year = 2012,
    .title = "A Dark Movie",
},
    TitleItem{
    .id = 2,
    .kind_id = 1,
    .production_year = 2013,
    .title = "Brutal Blood",
},
    TitleItem{
    .id = 3,
    .kind_id = 1,
    .production_year = 2008,
    .title = "Old Film",
},
}; // []const TitleItem
const MovieInfoItem = struct {
    movie_id: i32,
    info_type_id: i32,
    info: []const u8,
};
const movie_info = &[_]MovieInfoItem{
    MovieInfoItem{
    .movie_id = 1,
    .info_type_id = 1,
    .info = "Sweden",
},
    MovieInfoItem{
    .movie_id = 2,
    .info_type_id = 1,
    .info = "USA",
},
    MovieInfoItem{
    .movie_id = 3,
    .info_type_id = 1,
    .info = "USA",
},
}; // []const MovieInfoItem
const MovieInfoIdxItem = struct {
    movie_id: i32,
    info_type_id: i32,
    info: f64,
};
const movie_info_idx = &[_]MovieInfoIdxItem{
    MovieInfoIdxItem{
    .movie_id = 1,
    .info_type_id = 2,
    .info = 7.0,
},
    MovieInfoIdxItem{
    .movie_id = 2,
    .info_type_id = 2,
    .info = 7.5,
},
    MovieInfoIdxItem{
    .movie_id = 3,
    .info_type_id = 2,
    .info = 9.1,
},
}; // []const MovieInfoIdxItem
const MovieKeywordItem = struct {
    movie_id: i32,
    keyword_id: i32,
};
const movie_keyword = &[_]MovieKeywordItem{
    MovieKeywordItem{
    .movie_id = 1,
    .keyword_id = 1,
},
    MovieKeywordItem{
    .movie_id = 2,
    .keyword_id = 2,
},
    MovieKeywordItem{
    .movie_id = 3,
    .keyword_id = 3,
},
}; // []const MovieKeywordItem
const allowed_keywords = &[_][]const u8{
    "murder",
    "murder-in-title",
    "blood",
    "violence",
}; // []const []const u8
const allowed_countries = &[_][]const u8{
    "Sweden",
    "Norway",
    "Germany",
    "Denmark",
    "Swedish",
    "Denish",
    "Norwegian",
    "German",
    "USA",
    "American",
}; // []const []const u8
const ResultStruct0 = struct {
    rating: f64,
    title: []const u8,
};
var matches: []const MatchesItem = undefined; // []const MatchesItem
const Result = struct {
    rating: i32,
    northern_dark_movie: i32,
};
const result = Result{
    .rating = _min_int(blk1: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); for (matches) |x| { _tmp3.append(x.rating) catch |err| handleError(err); } const _tmp4 = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk1 _tmp4; }),
    .northern_dark_movie = _min_int(blk2: { var _tmp5 = std.ArrayList(i32).init(std.heap.page_allocator); for (matches) |x| { _tmp5.append(x.title) catch |err| handleError(err); } const _tmp6 = _tmp5.toOwnedSlice() catch |err| handleError(err); break :blk2 _tmp6; }),
}; // Result

fn test_Q14_selects_minimal_rating_and_title_for_dark_movies() void {
    expect((result == Result{
    .rating = 7.0,
    .northern_dark_movie = "A Dark Movie",
}));
}

pub fn main() void {
    matches = blk0: { var _tmp1 = std.ArrayList(ResultStruct0).init(std.heap.page_allocator); for (info_type) |it1| { for (info_type) |it2| { for (keyword) |k| { for (kind_type) |kt| { for (movie_info) |mi| { for (movie_info_idx) |mi_idx| { for (movie_keyword) |mk| { for (title) |t| { if (!((((((((((((((((((std.mem.eql(u8, it1.info, "countries") and std.mem.eql(u8, it2.info, "rating")) and (_contains_list_string(allowed_keywords, k.keyword))) and std.mem.eql(u8, kt.kind, "movie")) and (_contains_list_string(allowed_countries, mi.info))) and (mi_idx.info < 8.5)) and (t.production_year > 2010)) and (kt.id == t.kind_id)) and (t.id == mi.movie_id)) and (t.id == mk.movie_id)) and (t.id == mi_idx.movie_id)) and (mk.movie_id == mi.movie_id)) and (mk.movie_id == mi_idx.movie_id)) and (mi.movie_id == mi_idx.movie_id)) and (k.id == mk.keyword_id)) and (it1.id == mi.info_type_id)) and (it2.id == mi_idx.info_type_id))))) continue; _tmp1.append(ResultStruct0{
    .rating = mi_idx.info,
    .title = t.title,
}) catch |err| handleError(err); } } } } } } } } const _tmp2 = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk0 _tmp2; };
    _json(result);
    test_Q14_selects_minimal_rating_and_title_for_dark_movies();
}
