// Generated by Mochi compiler v0.10.25 on 2025-07-13T12:55:49Z
const std = @import("std");

fn expect(cond: bool) void {
    if (!cond) @panic("expect failed");
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _json(v: anytype) void {
    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    defer buf.deinit();
    std.json.stringify(v, .{}, buf.writer()) catch |err| handleError(err);
    std.debug.print("{s}\n", .{buf.items});
}

const CompanyNameItem = struct {
    id: i32,
    country_code: []const u8,
};
const company_name = &[_]CompanyNameItem{
    CompanyNameItem{
    .id = 1,
    .country_code = "[de]",
},
    CompanyNameItem{
    .id = 2,
    .country_code = "[us]",
},
}; // []const CompanyNameItem
const CompanyTypeItem = struct {
    id: i32,
    kind: []const u8,
};
const company_type = &[_]CompanyTypeItem{
    CompanyTypeItem{
    .id = 1,
    .kind = "production companies",
},
    CompanyTypeItem{
    .id = 2,
    .kind = "distributors",
},
}; // []const CompanyTypeItem
const InfoTypeItem = struct {
    id: i32,
    info: []const u8,
};
const info_type = &[_]InfoTypeItem{
    InfoTypeItem{
    .id = 1,
    .info = "rating",
},
    InfoTypeItem{
    .id = 2,
    .info = "release dates",
},
}; // []const InfoTypeItem
const KindTypeItem = struct {
    id: i32,
    kind: []const u8,
};
const kind_type = &[_]KindTypeItem{
    KindTypeItem{
    .id = 1,
    .kind = "movie",
},
    KindTypeItem{
    .id = 2,
    .kind = "video",
},
}; // []const CompanyTypeItem
const TitleItem = struct {
    id: i32,
    kind_id: i32,
    title: []const u8,
};
const title = &[_]TitleItem{
    TitleItem{
    .id = 10,
    .kind_id = 1,
    .title = "Alpha",
},
    TitleItem{
    .id = 20,
    .kind_id = 1,
    .title = "Beta",
},
    TitleItem{
    .id = 30,
    .kind_id = 2,
    .title = "Gamma",
},
}; // []const TitleItem
const MovieCompaniesItem = struct {
    movie_id: i32,
    company_id: i32,
    company_type_id: i32,
};
const movie_companies = &[_]MovieCompaniesItem{
    MovieCompaniesItem{
    .movie_id = 10,
    .company_id = 1,
    .company_type_id = 1,
},
    MovieCompaniesItem{
    .movie_id = 20,
    .company_id = 1,
    .company_type_id = 1,
},
    MovieCompaniesItem{
    .movie_id = 30,
    .company_id = 2,
    .company_type_id = 1,
},
}; // []const MovieCompaniesItem
const MovieInfoItem = struct {
    movie_id: i32,
    info_type_id: i32,
    info: []const u8,
};
const movie_info = &[_]MovieInfoItem{
    MovieInfoItem{
    .movie_id = 10,
    .info_type_id = 2,
    .info = "1997-05-10",
},
    MovieInfoItem{
    .movie_id = 20,
    .info_type_id = 2,
    .info = "1998-03-20",
},
    MovieInfoItem{
    .movie_id = 30,
    .info_type_id = 2,
    .info = "1999-07-30",
},
}; // []const MovieInfoItem
const MovieInfoIdxItem = struct {
    movie_id: i32,
    info_type_id: i32,
    info: []const u8,
};
const movie_info_idx = &[_]MovieInfoIdxItem{
    MovieInfoIdxItem{
    .movie_id = 10,
    .info_type_id = 1,
    .info = "6.0",
},
    MovieInfoIdxItem{
    .movie_id = 20,
    .info_type_id = 1,
    .info = "7.5",
},
    MovieInfoIdxItem{
    .movie_id = 30,
    .info_type_id = 1,
    .info = "5.5",
},
}; // []const MovieInfoItem
const ResultStruct0 = struct {
    release_date: []const u8,
    rating: []const u8,
    german_movie: []const u8,
};
var candidates: []const CandidatesItem = undefined; // []const CandidatesItem
const Result = struct {
    release_date: i32,
    rating: i32,
    german_movie: i32,
};
const result = Result{
    .release_date = (blk1: { var _tmp3 = std.ArrayList(struct { item: i32, key: i32 }).init(std.heap.page_allocator); for (candidates) |x| { _tmp3.append(.{ .item = x.release_date, .key = x.release_date }) catch |err| handleError(err); } for (0.._tmp3.items.len) |i| { for (i+1.._tmp3.items.len) |j| { if (_tmp3.items[j].key < _tmp3.items[i].key) { const t = _tmp3.items[i]; _tmp3.items[i] = _tmp3.items[j]; _tmp3.items[j] = t; } } } var _tmp4 = std.ArrayList(i32).init(std.heap.page_allocator);for (_tmp3.items) |p| { _tmp4.append(p.item) catch |err| handleError(err); } const _tmp5 = _tmp4.toOwnedSlice() catch |err| handleError(err); break :blk1 _tmp5; })[0],
    .rating = (blk2: { var _tmp6 = std.ArrayList(struct { item: i32, key: i32 }).init(std.heap.page_allocator); for (candidates) |x| { _tmp6.append(.{ .item = x.rating, .key = x.rating }) catch |err| handleError(err); } for (0.._tmp6.items.len) |i| { for (i+1.._tmp6.items.len) |j| { if (_tmp6.items[j].key < _tmp6.items[i].key) { const t = _tmp6.items[i]; _tmp6.items[i] = _tmp6.items[j]; _tmp6.items[j] = t; } } } var _tmp7 = std.ArrayList(i32).init(std.heap.page_allocator);for (_tmp6.items) |p| { _tmp7.append(p.item) catch |err| handleError(err); } const _tmp8 = _tmp7.toOwnedSlice() catch |err| handleError(err); break :blk2 _tmp8; })[0],
    .german_movie = (blk3: { var _tmp9 = std.ArrayList(struct { item: i32, key: i32 }).init(std.heap.page_allocator); for (candidates) |x| { _tmp9.append(.{ .item = x.german_movie, .key = x.german_movie }) catch |err| handleError(err); } for (0.._tmp9.items.len) |i| { for (i+1.._tmp9.items.len) |j| { if (_tmp9.items[j].key < _tmp9.items[i].key) { const t = _tmp9.items[i]; _tmp9.items[i] = _tmp9.items[j]; _tmp9.items[j] = t; } } } var _tmp10 = std.ArrayList(i32).init(std.heap.page_allocator);for (_tmp9.items) |p| { _tmp10.append(p.item) catch |err| handleError(err); } const _tmp11 = _tmp10.toOwnedSlice() catch |err| handleError(err); break :blk3 _tmp11; })[0],
}; // ResultStruct0

fn test_Q13_finds_earliest_German_movie_info() void {
    expect((result == CandidatesItem{
    .release_date = "1997-05-10",
    .rating = "6.0",
    .german_movie = "Alpha",
}));
}

pub fn main() void {
    candidates = blk0: { var _tmp1 = std.ArrayList(ResultStruct0).init(std.heap.page_allocator); for (company_name) |cn| { for (movie_companies) |mc| { if (!((mc.company_id == cn.id))) continue; for (company_type) |ct| { if (!((ct.id == mc.company_type_id))) continue; for (title) |t| { if (!((t.id == mc.movie_id))) continue; for (kind_type) |kt| { if (!((kt.id == t.kind_id))) continue; for (movie_info) |mi| { if (!((mi.movie_id == t.id))) continue; for (info_type) |it2| { if (!((it2.id == mi.info_type_id))) continue; for (movie_info_idx) |miidx| { if (!((miidx.movie_id == t.id))) continue; for (info_type) |it| { if (!((it.id == miidx.info_type_id))) continue; if (!(((((std.mem.eql(u8, cn.country_code, "[de]") and std.mem.eql(u8, ct.kind, "production companies")) and std.mem.eql(u8, it.info, "rating")) and std.mem.eql(u8, it2.info, "release dates")) and std.mem.eql(u8, kt.kind, "movie")))) continue; _tmp1.append(ResultStruct0{
    .release_date = mi.info,
    .rating = miidx.info,
    .german_movie = t.title,
}) catch |err| handleError(err); } } } } } } } } } const _tmp2 = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk0 _tmp2; };
    _json(result);
    test_Q13_finds_earliest_German_movie_info();
}
