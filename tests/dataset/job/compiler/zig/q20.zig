// Generated by Mochi compiler v0.10.25 on 2025-07-13T12:55:50Z
const std = @import("std");

fn expect(cond: bool) void {
    if (!cond) @panic("expect failed");
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _min_string(v: []const []const u8) []const u8 {
    if (v.len == 0) return "";
    var m: []const u8 = v[0];
    for (v[1..]) |it| { if (std.mem.lessThan(u8, it, m)) m = it; }
    return m;
}

fn _contains_list_string(v: []const []const u8, item: []const u8) bool {
    for (v) |it| { if (std.mem.eql(u8, it, item)) return true; }
    return false;
}

fn _json(v: anytype) void {
    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    defer buf.deinit();
    std.json.stringify(v, .{}, buf.writer()) catch |err| handleError(err);
    std.debug.print("{s}\n", .{buf.items});
}

const CompCastTypeItem = struct {
    id: i32,
    kind: []const u8,
};
const comp_cast_type = &[_]CompCastTypeItem{
    CompCastTypeItem{
    .id = 1,
    .kind = "cast",
},
    CompCastTypeItem{
    .id = 2,
    .kind = "complete cast",
},
}; // []const CompCastTypeItem
const CharNameItem = struct {
    id: i32,
    name: []const u8,
};
const char_name = &[_]CharNameItem{
    CharNameItem{
    .id = 1,
    .name = "Tony Stark",
},
    CharNameItem{
    .id = 2,
    .name = "Sherlock Holmes",
},
}; // []const CharNameItem
const CompleteCastItem = struct {
    movie_id: i32,
    subject_id: i32,
    status_id: i32,
};
const complete_cast = &[_]CompleteCastItem{
    CompleteCastItem{
    .movie_id = 1,
    .subject_id = 1,
    .status_id = 2,
},
    CompleteCastItem{
    .movie_id = 2,
    .subject_id = 1,
    .status_id = 2,
},
}; // []const CompleteCastItem
const NameItem = struct {
    id: i32,
    name: []const u8,
};
const name = &[_]NameItem{
    NameItem{
    .id = 1,
    .name = "Robert Downey Jr.",
},
    NameItem{
    .id = 2,
    .name = "Another Actor",
},
}; // []const CharNameItem
const CastInfoItem = struct {
    movie_id: i32,
    person_role_id: i32,
    person_id: i32,
};
const cast_info = &[_]CastInfoItem{
    CastInfoItem{
    .movie_id = 1,
    .person_role_id = 1,
    .person_id = 1,
},
    CastInfoItem{
    .movie_id = 2,
    .person_role_id = 2,
    .person_id = 2,
},
}; // []const CastInfoItem
const KeywordItem = struct {
    id: i32,
    keyword: []const u8,
};
const keyword = &[_]KeywordItem{
    KeywordItem{
    .id = 10,
    .keyword = "superhero",
},
    KeywordItem{
    .id = 20,
    .keyword = "romance",
},
}; // []const KeywordItem
const MovieKeywordItem = struct {
    movie_id: i32,
    keyword_id: i32,
};
const movie_keyword = &[_]MovieKeywordItem{
    MovieKeywordItem{
    .movie_id = 1,
    .keyword_id = 10,
},
    MovieKeywordItem{
    .movie_id = 2,
    .keyword_id = 20,
},
}; // []const MovieKeywordItem
const KindTypeItem = struct {
    id: i32,
    kind: []const u8,
};
const kind_type = &[_]KindTypeItem{KindTypeItem{
    .id = 1,
    .kind = "movie",
}}; // []const CompCastTypeItem
const TitleItem = struct {
    id: i32,
    kind_id: i32,
    production_year: i32,
    title: []const u8,
};
const title = &[_]TitleItem{
    TitleItem{
    .id = 1,
    .kind_id = 1,
    .production_year = 2008,
    .title = "Iron Man",
},
    TitleItem{
    .id = 2,
    .kind_id = 1,
    .production_year = 1940,
    .title = "Old Hero",
},
}; // []const TitleItem
var matches: []const []const u8 = undefined; // []const []const u8
const ResultItem = struct { complete_downey_ironman_movie: i32, };
const result = &[_]ResultItem{ResultItem{ .complete_downey_ironman_movie = _min_string(matches) }}; // []const ResultItem

fn test_Q20_finds_complete_cast_Iron_Man_movie() void {
    expect((result == &[_]ResultItem{ResultItem{ .complete_downey_ironman_movie = "Iron Man" }}));
}

pub fn main() void {
    matches = blk0: { var _tmp0 = std.ArrayList(u8).init(std.heap.page_allocator); for (complete_cast) |cc| { for (comp_cast_type) |cct1| { if (!((cct1.id == cc.subject_id))) continue; for (comp_cast_type) |cct2| { if (!((cct2.id == cc.status_id))) continue; for (cast_info) |ci| { if (!((ci.movie_id == cc.movie_id))) continue; for (char_name) |chn| { if (!((chn.id == ci.person_role_id))) continue; for (name) |n| { if (!((n.id == ci.person_id))) continue; for (movie_keyword) |mk| { if (!((mk.movie_id == cc.movie_id))) continue; for (keyword) |k| { if (!((k.id == mk.keyword_id))) continue; for (title) |t| { if (!((t.id == cc.movie_id))) continue; for (kind_type) |kt| { if (!((kt.id == t.kind_id))) continue; if (!(((((((std.mem.eql(u8, cct1.kind, "cast") and cct2.kind.contains("complete")) and (!chn.name.contains("Sherlock"))) and ((chn.name.contains("Tony Stark") or chn.name.contains("Iron Man")))) and _contains_list_string(&[_][]const u8{
    "superhero",
    "sequel",
    "second-part",
    "marvel-comics",
    "based-on-comic",
    "tv-special",
    "fight",
    "violence",
}, k.keyword)) and std.mem.eql(u8, kt.kind, "movie")) and (t.production_year > 1950)))) continue; _tmp0.append(t.title) catch |err| handleError(err); } } } } } } } } } } const _tmp1 = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 _tmp1; };
    _json(result);
    test_Q20_finds_complete_cast_Iron_Man_movie();
}
