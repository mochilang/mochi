// Generated by Mochi compiler v0.10.25 on 2025-07-13T12:55:49Z
const std = @import("std");

fn expect(cond: bool) void {
    if (!cond) @panic("expect failed");
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _min_int(v: []const i32) i32 {
    if (v.len == 0) return 0;
    var m: i32 = v[0];
    for (v[1..]) |it| { if (it < m) m = it; }
    return m;
}

fn _json(v: anytype) void {
    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    defer buf.deinit();
    std.json.stringify(v, .{}, buf.writer()) catch |err| handleError(err);
    std.debug.print("{s}\n", .{buf.items});
}

const CompanyNameItem = struct {
    id: i32,
    name: []const u8,
    country_code: []const u8,
};
const company_name = &[_]CompanyNameItem{
    CompanyNameItem{
    .id = 1,
    .name = "Best Film Co",
    .country_code = "[us]",
},
    CompanyNameItem{
    .id = 2,
    .name = "Warner Studios",
    .country_code = "[de]",
},
    CompanyNameItem{
    .id = 3,
    .name = "Polish Films",
    .country_code = "[pl]",
},
}; // []const CompanyNameItem
const CompanyTypeItem = struct {
    id: i32,
    kind: []const u8,
};
const company_type = &[_]CompanyTypeItem{
    CompanyTypeItem{
    .id = 1,
    .kind = "production companies",
},
    CompanyTypeItem{
    .id = 2,
    .kind = "distributors",
},
}; // []const CompanyTypeItem
const KeywordItem = struct {
    id: i32,
    keyword: []const u8,
};
const keyword = &[_]KeywordItem{
    KeywordItem{
    .id = 1,
    .keyword = "sequel",
},
    KeywordItem{
    .id = 2,
    .keyword = "thriller",
},
}; // []const KeywordItem
const LinkTypeItem = struct {
    id: i32,
    link: []const u8,
};
const link_type = &[_]LinkTypeItem{
    LinkTypeItem{
    .id = 1,
    .link = "follow-up",
},
    LinkTypeItem{
    .id = 2,
    .link = "follows from",
},
    LinkTypeItem{
    .id = 3,
    .link = "remake",
},
}; // []const LinkTypeItem
const MovieCompaniesItem = struct {
    movie_id: i32,
    company_id: i32,
    company_type_id: i32,
    note: i32,
};
const movie_companies = &[_]MovieCompaniesItem{
    MovieCompaniesItem{
    .movie_id = 10,
    .company_id = 1,
    .company_type_id = 1,
    .note = 0,
},
    MovieCompaniesItem{
    .movie_id = 20,
    .company_id = 2,
    .company_type_id = 1,
    .note = 0,
},
    MovieCompaniesItem{
    .movie_id = 30,
    .company_id = 3,
    .company_type_id = 1,
    .note = 0,
},
}; // []const MovieCompaniesItem
const MovieKeywordItem = struct {
    movie_id: i32,
    keyword_id: i32,
};
const movie_keyword = &[_]MovieKeywordItem{
    MovieKeywordItem{
    .movie_id = 10,
    .keyword_id = 1,
},
    MovieKeywordItem{
    .movie_id = 20,
    .keyword_id = 1,
},
    MovieKeywordItem{
    .movie_id = 20,
    .keyword_id = 2,
},
    MovieKeywordItem{
    .movie_id = 30,
    .keyword_id = 1,
},
}; // []const MovieKeywordItem
const MovieLinkItem = struct {
    movie_id: i32,
    link_type_id: i32,
};
const movie_link = &[_]MovieLinkItem{
    MovieLinkItem{
    .movie_id = 10,
    .link_type_id = 1,
},
    MovieLinkItem{
    .movie_id = 20,
    .link_type_id = 2,
},
    MovieLinkItem{
    .movie_id = 30,
    .link_type_id = 3,
},
}; // []const MovieLinkItem
const TitleItem = struct {
    id: i32,
    production_year: i32,
    title: []const u8,
};
const title = &[_]TitleItem{
    TitleItem{
    .id = 10,
    .production_year = 1960,
    .title = "Alpha",
},
    TitleItem{
    .id = 20,
    .production_year = 1970,
    .title = "Beta",
},
    TitleItem{
    .id = 30,
    .production_year = 1985,
    .title = "Polish Movie",
},
}; // []const TitleItem
const ResultStruct0 = struct {
    company: []const u8,
    link: []const u8,
    title: []const u8,
};
var matches: []const MatchesItem = undefined; // []const MatchesItem
const ResultItem = struct {
    from_company: i32,
    movie_link_type: i32,
    non_polish_sequel_movie: i32,
};
const result = &[_]ResultItem{ResultItem{
    .from_company = _min_int(blk1: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); for (matches) |x| { _tmp3.append(x.company) catch |err| handleError(err); } const _tmp4 = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk1 _tmp4; }),
    .movie_link_type = _min_int(blk2: { var _tmp5 = std.ArrayList(i32).init(std.heap.page_allocator); for (matches) |x| { _tmp5.append(x.link) catch |err| handleError(err); } const _tmp6 = _tmp5.toOwnedSlice() catch |err| handleError(err); break :blk2 _tmp6; }),
    .non_polish_sequel_movie = _min_int(blk3: { var _tmp7 = std.ArrayList(i32).init(std.heap.page_allocator); for (matches) |x| { _tmp7.append(x.title) catch |err| handleError(err); } const _tmp8 = _tmp7.toOwnedSlice() catch |err| handleError(err); break :blk3 _tmp8; }),
}}; // []const ResultItem

fn test_Q11_returns_min_company__link_type_and_title() void {
    expect((result == &[_]ResultItem{ResultItem{
    .from_company = "Best Film Co",
    .movie_link_type = "follow-up",
    .non_polish_sequel_movie = "Alpha",
}}));
}

pub fn main() void {
    matches = blk0: { var _tmp1 = std.ArrayList(ResultStruct0).init(std.heap.page_allocator); for (company_name) |cn| { for (movie_companies) |mc| { if (!((mc.company_id == cn.id))) continue; for (company_type) |ct| { if (!((ct.id == mc.company_type_id))) continue; for (title) |t| { if (!((t.id == mc.movie_id))) continue; for (movie_keyword) |mk| { if (!((mk.movie_id == t.id))) continue; for (keyword) |k| { if (!((k.id == mk.keyword_id))) continue; for (movie_link) |ml| { if (!((ml.movie_id == t.id))) continue; for (link_type) |lt| { if (!((lt.id == ml.link_type_id))) continue; if (!(((((((((((!std.mem.eql(u8, cn.country_code, "[pl]") and ((cn.name.contains("Film") or cn.name.contains("Warner")))) and std.mem.eql(u8, ct.kind, "production companies")) and std.mem.eql(u8, k.keyword, "sequel")) and lt.link.contains("follow")) and (mc.note == 0)) and (t.production_year >= 1950)) and (t.production_year <= 2000)) and (ml.movie_id == mk.movie_id)) and (ml.movie_id == mc.movie_id)) and (mk.movie_id == mc.movie_id)))) continue; _tmp1.append(ResultStruct0{
    .company = cn.name,
    .link = lt.link,
    .title = t.title,
}) catch |err| handleError(err); } } } } } } } } const _tmp2 = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk0 _tmp2; };
    _json(result);
    test_Q11_returns_min_company__link_type_and_title();
}
