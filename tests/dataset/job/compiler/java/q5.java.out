// Generated by Mochi compiler v0.10.25 on 2025-07-13T10:54:08Z
// q5.mochi
import java.util.*;

class CtIdKind {
    int ct_id;
    String kind;
    CtIdKind(int ct_id, String kind) {
        this.ct_id = ct_id;
        this.kind = kind;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof CtIdKind other)) return false;
        return Objects.equals(this.ct_id, other.ct_id) && Objects.equals(this.kind, other.kind);
    }
    @Override public int hashCode() {
        return Objects.hash(ct_id, kind);
    }
    int size() { return 2; }
}
class ItIdInfo {
    int it_id;
    String info;
    ItIdInfo(int it_id, String info) {
        this.it_id = it_id;
        this.info = info;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ItIdInfo other)) return false;
        return Objects.equals(this.it_id, other.it_id) && Objects.equals(this.info, other.info);
    }
    @Override public int hashCode() {
        return Objects.hash(it_id, info);
    }
    int size() { return 2; }
}
class TIdTitleProductionYear {
    int t_id;
    String title;
    int production_year;
    TIdTitleProductionYear(int t_id, String title, int production_year) {
        this.t_id = t_id;
        this.title = title;
        this.production_year = production_year;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof TIdTitleProductionYear other)) return false;
        return Objects.equals(this.t_id, other.t_id) && Objects.equals(this.title, other.title) && Objects.equals(this.production_year, other.production_year);
    }
    @Override public int hashCode() {
        return Objects.hash(t_id, title, production_year);
    }
    int size() { return 3; }
}
class MovieIdCompanyTypeIdNote {
    int movie_id;
    int company_type_id;
    String note;
    MovieIdCompanyTypeIdNote(int movie_id, int company_type_id, String note) {
        this.movie_id = movie_id;
        this.company_type_id = company_type_id;
        this.note = note;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof MovieIdCompanyTypeIdNote other)) return false;
        return Objects.equals(this.movie_id, other.movie_id) && Objects.equals(this.company_type_id, other.company_type_id) && Objects.equals(this.note, other.note);
    }
    @Override public int hashCode() {
        return Objects.hash(movie_id, company_type_id, note);
    }
    int size() { return 3; }
}
class MovieIdInfoInfoTypeId {
    int movie_id;
    String info;
    int info_type_id;
    MovieIdInfoInfoTypeId(int movie_id, String info, int info_type_id) {
        this.movie_id = movie_id;
        this.info = info;
        this.info_type_id = info_type_id;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof MovieIdInfoInfoTypeId other)) return false;
        return Objects.equals(this.movie_id, other.movie_id) && Objects.equals(this.info, other.info) && Objects.equals(this.info_type_id, other.info_type_id);
    }
    @Override public int hashCode() {
        return Objects.hash(movie_id, info, info_type_id);
    }
    int size() { return 3; }
}
class TypicalEuropeanMovie {
    int typical_european_movie;
    TypicalEuropeanMovie(int typical_european_movie) {
        this.typical_european_movie = typical_european_movie;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof TypicalEuropeanMovie other)) return false;
        return Objects.equals(this.typical_european_movie, other.typical_european_movie);
    }
    @Override public int hashCode() {
        return Objects.hash(typical_european_movie);
    }
    int size() { return 1; }
}
public class Q5 {
    static Map<String,Object> asMap(Object o) {
        if (o instanceof Map<?,?> mm) {
            LinkedHashMap<String,Object> m = new LinkedHashMap<>();
            for (Map.Entry<?,?> e : mm.entrySet()) m.put(String.valueOf(e.getKey()), e.getValue());
            return m;
        }
        LinkedHashMap<String,Object> m = new LinkedHashMap<>();
        for (var f : o.getClass().getDeclaredFields()) { try { f.setAccessible(true); m.put(f.getName(), f.get(o)); } catch (Exception e) { throw new RuntimeException(e); } }
        return m;
    }
    static void saveJsonl(List<?> list) {
        for (Object obj : list) {
            Map<String,Object> m = asMap(obj);
            List<String> parts = new ArrayList<>();
            for (Map.Entry<?,?> e : m.entrySet()) { parts.add("\"" + e.getKey() + "\":" + e.getValue()); }
            System.out.println("{" + String.join(",", parts) + "}");
        }
    }
    static String toJson(Object o) {
        if (o instanceof Map<?,?> m) {
            StringJoiner j = new StringJoiner(",", "{", "}");
            for (Map.Entry<?,?> e : m.entrySet()) j.add("\"" + e.getKey() + "\":" + toJson(e.getValue()));
            return j.toString();
        } else if (o instanceof Collection<?> c) {
            StringJoiner j = new StringJoiner(",", "[", "]");
            for (var x : c) j.add(toJson(x));
            return j.toString();
        } else if (o instanceof String s) {
            return "\"" + s + "\"";
        } else if (o instanceof Number || o instanceof Boolean || o instanceof Character) {
            return String.valueOf(o);
        } else {
            Map<String,Object> m = asMap(o);
            StringJoiner j = new StringJoiner(",", "{", "}");
            for (Map.Entry<String,Object> e : m.entrySet()) j.add("\"" + e.getKey() + "\":" + toJson(e.getValue()));
            return j.toString();
        }
    }
    static void json(Object o) { System.out.println(toJson(o)); }
    public static void main(String[] args) {
    List<CtIdKind> company_type = new ArrayList<>(Arrays.asList(new CtIdKind(1, "production companies"), new CtIdKind(2, "other")));
    List<ItIdInfo> info_type = new ArrayList<>(Arrays.asList(new ItIdInfo(10, "languages")));
    List<TIdTitleProductionYear> title = new ArrayList<>(Arrays.asList(new TIdTitleProductionYear(100, "B Movie", 2010), new TIdTitleProductionYear(200, "A Film", 2012), new TIdTitleProductionYear(300, "Old Movie", 2000)));
    List<MovieIdCompanyTypeIdNote> movie_companies = new ArrayList<>(Arrays.asList(new MovieIdCompanyTypeIdNote(100, 1, "ACME (France) (theatrical)"), new MovieIdCompanyTypeIdNote(200, 1, "ACME (France) (theatrical)"), new MovieIdCompanyTypeIdNote(300, 1, "ACME (France) (theatrical)")));
    List<MovieIdInfoInfoTypeId> movie_info = new ArrayList<>(Arrays.asList(new MovieIdInfoInfoTypeId(100, "German", 10), new MovieIdInfoInfoTypeId(200, "Swedish", 10), new MovieIdInfoInfoTypeId(300, "German", 10)));
    List<String> candidate_titles = (new java.util.function.Supplier<List<String>>(){public List<String> get(){
    List<String> res0 = new ArrayList<>();
    for (var ct : company_type) {
        for (var mc : movie_companies) {
            if (!(mc.company_type_id == ct.ct_id)) continue;
            for (var mi : movie_info) {
                if (!(mi.movie_id == mc.movie_id)) continue;
                for (var it : info_type) {
                    if (!(it.it_id == mi.info_type_id)) continue;
                    for (var t : title) {
                        if (!(t.t_id == mc.movie_id)) continue;
                        if (!(Objects.equals(ct.kind, "production companies") && mc.note.contains(String.valueOf("(theatrical)")) != null && mc.note.contains(String.valueOf("(France)")) != null && t.production_year > 2005 && (Arrays.asList("Sweden", "Norway", "Germany", "Denmark", "Swedish", "Denish", "Norwegian", "German").contains(mi.info)) != null)) continue;
                        res0.add(t.title);
                    }
                }
            }
        }
    }
    return res0;
}}).get();
    List<TypicalEuropeanMovie> result = new ArrayList<>(Arrays.asList(new TypicalEuropeanMovie(candidate_titles.stream().mapToInt(n -> ((Number)n).intValue()).min().orElse(Integer.MAX_VALUE))));
    json(result);
    if (!(Objects.equals(result, Arrays.asList(new TypicalEuropeanMovie("A Film"))))) throw new AssertionError("expect failed");
    }
}
