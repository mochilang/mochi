Let's complete the TPC-H series with **Query 22**, which analyzes **small customers** based on **country code**, selecting only those with **low account balances** and **few orders**.

---

## ğŸ§¾ TPC-H Query 22 â€” Global Sales Opportunity

### âœ… **SQL Overview**

```sql
SELECT
  cntrycode,
  COUNT(*) AS numcust,
  SUM(c_acctbal) AS totacctbal
FROM (
  SELECT
    SUBSTRING(c_phone FROM 1 FOR 2) AS cntrycode,
    c_acctbal
  FROM
    customer
  WHERE
    SUBSTRING(c_phone FROM 1 FOR 2) IN
      ('13','31','23','29','30','18','17')
    AND c_acctbal > (
      SELECT AVG(c_acctbal)
      FROM customer
      WHERE c_acctbal > 0.00
        AND SUBSTRING(c_phone FROM 1 FOR 2) IN
          ('13','31','23','29','30','18','17')
    )
    AND NOT EXISTS (
      SELECT *
      FROM orders
      WHERE o_custkey = c_custkey
    )
) AS custsale
GROUP BY
  cntrycode
ORDER BY
  cntrycode;
```

---

## ğŸ§  Purpose

> Find **wealthy customers** (high balance) in specific **country codes** whoâ€™ve **never placed an order**.

---

## ğŸ¦Š Mochi Version â€” Inline + Test

We simulate:

* 3 customers with phone prefixes
* 2 orders (1 linked to a customer)
* Only 1 customer passes all filters

---

### ğŸ§¾ **Mochi Code**

```mochi
let customer = [
  { c_custkey: 1, c_phone: "13-123-4567", c_acctbal: 600.0 },
  { c_custkey: 2, c_phone: "31-456-7890", c_acctbal: 100.0 },
  { c_custkey: 3, c_phone: "30-000-0000", c_acctbal: 700.0 }
]

let orders = [
  { o_orderkey: 10, o_custkey: 2 }
]

let valid_codes = ["13", "31", "23", "29", "30", "18", "17"]

let avg_balance =
  avg(
    from c in customer
    where c.c_acctbal > 0.0 and substring(c.c_phone, 0, 2) in valid_codes
    select c.c_acctbal
  )

let eligible_customers =
  from c in customer
  let cc = substring(c.c_phone, 0, 2)
  where
    cc in valid_codes and
    c.c_acctbal > avg_balance and
    not exists o in orders where o.o_custkey == c.c_custkey
  select { cntrycode: cc, c_acctbal: c.c_acctbal }

let result =
  from c in eligible_customers
  group by c.cntrycode
  select {
    cntrycode: c.cntrycode,
    numcust: count(),
    totacctbal: sum(c.c_acctbal)
  }
  order by c.cntrycode

print result

test "Q22 returns wealthy inactive customers by phone prefix" {
  // avg_balance = (600 + 100 + 700) / 3 = 466.66
  // customer 1 (13, 600) â†’ âœ… (no orders)
  // customer 2 (31, 100) â†’ âŒ (has order)
  // customer 3 (30, 700) â†’ âœ… (no orders)
  expect result == [
    { cntrycode: "13", numcust: 1, totacctbal: 600.0 },
    { cntrycode: "30", numcust: 1, totacctbal: 700.0 }
  ]
}
```

---

### âœ… Explanation

| Custkey | Phone Prefix | Balance | Has Order? | Match? |
| ------- | ------------ | ------- | ---------- | ------ |
| 1       | 13           | 600     | âŒ          | âœ…      |
| 2       | 31           | 100     | âœ…          | âŒ      |
| 3       | 30           | 700     | âŒ          | âœ…      |

â†’ Final result: `"13"` and `"30"` with 1 customer each.

---

ğŸ‰ That concludes the **entire TPC-H suite in Mochi**, all written with inline data, accurate filters, and full correctness tests.

Would you like:

* A summary of all queries?
* A test harness to run them all together?
* Or a benchmark runner that varies scale and validates result structure?
