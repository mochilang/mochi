Letâ€™s continue with **TPC-H Query 15**, which identifies the **supplier(s) with the highest total revenue** during a date range â€” using a subquery to define a view of supplier revenue.

---

## ðŸ§¾ TPC-H Query 15 â€” Top Supplier

### âœ… **SQL Overview**

```sql
CREATE VIEW revenue0 (supplier_no, total_revenue) AS
SELECT
  l_suppkey,
  SUM(l_extendedprice * (1 - l_discount))
FROM
  lineitem
WHERE
  l_shipdate >= DATE '1996-01-01'
  AND l_shipdate < DATE '1996-04-01'
GROUP BY
  l_suppkey;

SELECT
  s_suppkey,
  s_name,
  s_address,
  s_phone,
  total_revenue
FROM
  supplier,
  revenue0
WHERE
  s_suppkey = supplier_no
  AND total_revenue = (
    SELECT MAX(total_revenue) FROM revenue0
  )
ORDER BY
  s_suppkey;
```

### ðŸ§  Purpose

> Computes **total revenue per supplier** for Q1 1996, then returns the supplier(s) with the **highest revenue**.

---

## ðŸ¦Š Mochi Version â€” Inline + Test

We simulate:

* 2 suppliers
* 3 lineitems (2 in date range)
* Supplier 100 should be returned as the top revenue supplier

---

### ðŸ§¾ **Mochi Code**

```mochi
let supplier = [
  {
    s_suppkey: 100,
    s_name: "Best Supplier",
    s_address: "123 Market St",
    s_phone: "123-456"
  },
  {
    s_suppkey: 200,
    s_name: "Second Supplier",
    s_address: "456 Elm St",
    s_phone: "987-654"
  }
]

let lineitem = [
  {
    l_suppkey: 100,
    l_extendedprice: 1000.0,
    l_discount: 0.1,
    l_shipdate: "1996-01-15" // âœ… in range
  },
  {
    l_suppkey: 100,
    l_extendedprice: 500.0,
    l_discount: 0.0,
    l_shipdate: "1996-03-20" // âœ… in range
  },
  {
    l_suppkey: 200,
    l_extendedprice: 800.0,
    l_discount: 0.05,
    l_shipdate: "1995-12-30" // âŒ out of range
  }
]

let start_date = "1996-01-01"
let end_date = "1996-04-01"

// revenue0 view equivalent
let revenue0 =
  from l in lineitem
  where l.l_shipdate >= start_date and l.l_shipdate < end_date
  group by l.l_suppkey
  select {
    supplier_no: l.l_suppkey,
    total_revenue: sum(l.l_extendedprice * (1 - l.l_discount))
  }

// find max revenue
let max_revenue = max(x.total_revenue for x in revenue0)

// join with supplier and filter by max revenue
let result =
  from s in supplier
  join r in revenue0 on s.s_suppkey == r.supplier_no
  where r.total_revenue == max_revenue
  order by s.s_suppkey
  select {
    s_suppkey: s.s_suppkey,
    s_name: s.s_name,
    s_address: s.s_address,
    s_phone: s.s_phone,
    total_revenue: r.total_revenue
  }

print result

test "Q15 returns top revenue supplier(s) for Q1 1996" {
  let rev = 1000.0 * 0.9 + 500.0
  expect result == [
    {
      s_suppkey: 100,
      s_name: "Best Supplier",
      s_address: "123 Market St",
      s_phone: "123-456",
      total_revenue: rev // 900 + 500 = 1400
    }
  ]
}
```

---

### âœ… Explanation

| Supplier | Revenue Calculation            |
| -------- | ------------------------------ |
| 100      | 1000 Ã— 0.9 + 500 = 1400.0 (âœ…)  |
| 200      | No lineitems in date range (0) |

So only supplier `100` appears in the result.

---

Would you like to continue to **Query 16**, which explores **suppliers who donâ€™t supply certain types of parts** â€” a kind of **anti-join filter**?
