(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(define (_count v)
  (cond
    ((string? v) (string-length v))
    ((and (pair? v) (assq 'Items v)) (length (cdr (assq 'Items v))))
    ((list? v) (length v))
    (else 0)))

(define (_sum v)
  (let* ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
         (s (if (null? lst) 0 (apply + lst))))
    s))

(define (_avg v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (n 0))
    (set! n (length lst))
    (if (= n 0) 0 (/ (_sum lst) n))))

(define (_group_by src keyfn)
  (let ((groups '()) (order '()))
    (for-each (lambda (it)
                (let* ((key (keyfn it))
                       (ks (format "~a" key))
                       (pair (assoc ks groups)))
                  (if pair
                      (let* ((grp (cdr pair))
                             (items (cdr (assq 'Items grp))))
                        (set-cdr! (assq 'Items grp) (append items (list it))))
                      (begin
                        (set! groups (append groups (list (cons ks (list (cons 'key key) (cons 'Items (list it)))))))
                        (set! order (append order (list ks))))))
              src)
    (map (lambda (k) (cdr (assoc k groups))) order))))
(define (_json v)
  (write v)
  (newline))
(define failures 0)
(define (print-test-start name)
  (display "   test ") (display name) (display " ..."))
(define (print-test-pass) (display " ok") (newline))
(define (print-test-fail err) (display " fail ") (display err) (newline))
(define (run-test name thunk)
  (print-test-start name)
  (let ((ok #t))
    (with-exception-handler
      (lambda (e)
        (set! ok #f)
        (set! failures (+ failures 1))
        (print-test-fail e))
      (lambda () (thunk)))
    (when ok (print-test-pass))))

(define (test_Q1_aggregates_revenue_and_quantity_by_returnflag___linestatus)
  (when (not (equal? result (list (list (cons "returnflag" "N") (cons "linestatus" "O") (cons "sum_qty" 53) (cons "sum_base_price" 3000) (cons "sum_disc_price" (+ 950.0 1800.0)) (cons "sum_charge" (+ (* 950.0 1.07) (* 1800.0 1.05))) (cons "avg_qty" 26.5) (cons "avg_price" 1500) (cons "avg_disc" 0.07500000000000001) (cons "count_order" 2))))) (error "expect failed"))
)

(define lineitem (list (list (cons "l_quantity" 17) (cons "l_extendedprice" 1000.0) (cons "l_discount" 0.05) (cons "l_tax" 0.07) (cons "l_returnflag" "N") (cons "l_linestatus" "O") (cons "l_shipdate" "1998-08-01")) (list (cons "l_quantity" 36) (cons "l_extendedprice" 2000.0) (cons "l_discount" 0.1) (cons "l_tax" 0.05) (cons "l_returnflag" "N") (cons "l_linestatus" "O") (cons "l_shipdate" "1998-09-01")) (list (cons "l_quantity" 25) (cons "l_extendedprice" 1500.0) (cons "l_discount" 0.0) (cons "l_tax" 0.08) (cons "l_returnflag" "R") (cons "l_linestatus" "F") (cons "l_shipdate" "1998-09-03"))))
(define result (let ((_tmp '()))
  (for-each (lambda (row)
    (when (<= (map-get row "l_shipdate") "1998-09-02") (set! _tmp (append _tmp (list row))))
  ) (if (string? lineitem) (string->list lineitem) lineitem))
  (let ((_res '()))
    (for-each (lambda (g)
      (set! _res (append _res (list (list (cons "returnflag" (map-get (map-get g "key") "returnflag")) (cons "linestatus" (map-get (map-get g "key") "linestatus")) (cons "sum_qty" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "l_quantity"))))
  ) (if (string? g) (string->list g) g))
  _res))) (cons "sum_base_price" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "l_extendedprice"))))
  ) (if (string? g) (string->list g) g))
  _res))) (cons "sum_disc_price" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (* (map-get x "l_extendedprice") (- 1 (map-get x "l_discount"))))))
  ) (if (string? g) (string->list g) g))
  _res))) (cons "sum_charge" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (* (* (map-get x "l_extendedprice") (- 1 (map-get x "l_discount"))) (+ 1 (map-get x "l_tax"))))))
  ) (if (string? g) (string->list g) g))
  _res))) (cons "avg_qty" (_avg (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "l_quantity"))))
  ) (if (string? g) (string->list g) g))
  _res))) (cons "avg_price" (_avg (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "l_extendedprice"))))
  ) (if (string? g) (string->list g) g))
  _res))) (cons "avg_disc" (_avg (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "l_discount"))))
  ) (if (string? g) (string->list g) g))
  _res))) (cons "count_order" (_count g))))))
    ) (_group_by _tmp (lambda (row) (list (cons "returnflag" (map-get row "l_returnflag")) (cons "linestatus" (map-get row "l_linestatus"))))))
    _res)))
(_json result)
(run-test "Q1 aggregates revenue and quantity by returnflag + linestatus" test_Q1_aggregates_revenue_and_quantity_by_returnflag___linestatus)
(when (> failures 0) (display "\n[FAIL] ") (display failures) (display " test(s) failed.\n"))
