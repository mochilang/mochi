(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(define (_fetch url opts)
  (let* ((method (if (and opts (assq 'method opts)) (cdr (assq 'method opts)) "GET"))
         (args (list "curl" "-s" "-X" method)))
    (when (and opts (assq 'headers opts))
      (for-each (lambda (p)
                  (set! args (append args (list "-H" (format "~a: ~a" (car p) (cdr p))))))
                (cdr (assq 'headers opts))))
    (when (and opts (assq 'query opts))
      (let* ((q (cdr (assq 'query opts)))
             (qs (string-join (map (lambda (p) (format "~a=~a" (car p) (cdr p))) q) "&")))
        (set! url (string-append url (if (string-contains url "?") "&" "?") qs))))
    (when (and opts (assq 'body opts))
      (set! args (append args (list "-d" (json->string (cdr (assq 'body opts)))))))
    (when (and opts (assq 'timeout opts))
      (set! args (append args (list "--max-time" (format "~a" (cdr (assq 'timeout opts)))))))
    (set! args (append args (list url)))
    (let* ((p (open-input-pipe (string-join args " ")))
           (txt (port->string p)))
      (close-input-port p)
      (string->json txt))))

(define (_load path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (in (if (or (not path) (string=? path "") (string=? path "-"))
                 (current-input-port)
                 (open-input-file path)))
         (text (port->string in)))
    (when (not (eq? in (current-input-port)))
      (close-input-port in))
    (cond ((string=? fmt "jsonl")
           (map string->json
                (filter (lambda (l) (not (string=? l "")))
                        (string-split text #\newline))))
          (else
           (let ((d (string->json text)))
             (if (list? d) d (list d)))))))

(define (_save rows path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (out (if (or (not path) (string=? path "") (string=? path "-"))
                  (current-output-port)
                  (open-output-file path))))
    (cond ((string=? fmt "jsonl")
           (for-each (lambda (r) (write-string (json->string r) out) (newline out)) rows))
          (else
           (write-string (json->string rows) out)))
    (when (not (eq? out (current-output-port)))
      (close-output-port out))))

(define (_sort pairs)
  (sort pairs
        (lambda (a b)
          (let ((ka (cdr a)) (kb (cdr b)))
            (cond ((and (number? ka) (number? kb)) (< ka kb))
                  ((and (string? ka) (string? kb)) (string<? ka kb))
                  (else (string<? (format "~a" ka) (format "~a" kb))))))))
(define (_json v)
  (write v)
  (newline))
(define failures 0)
(define (print-test-start name)
  (display "   test ") (display name) (display " ..."))
(define (print-test-pass) (display " ok") (newline))
(define (print-test-fail err) (display " fail ") (display err) (newline))
(define (run-test name thunk)
  (print-test-start name)
  (let ((ok #t))
    (with-exception-handler
      (lambda (e)
        (set! ok #f)
        (set! failures (+ failures 1))
        (print-test-fail e))
      (lambda () (thunk)))
    (when ok (print-test-pass))))

(define (test_Q2_returns_only_supplier_with_min_cost_in_Europe_for_brass_part)
  (when (not (equal? result (list (list (cons "s_acctbal" 1000.0) (cons "s_name" "BestSupplier") (cons "n_name" "FRANCE") (cons "p_partkey" 1000) (cons "p_mfgr" "M1") (cons "s_address" "123 Rue") (cons "s_phone" "123") (cons "s_comment" "Fast and reliable") (cons "ps_supplycost" 10.0))))) (error "expect failed"))
)

(define region (list (list (cons "r_regionkey" 1) (cons "r_name" "EUROPE")) (list (cons "r_regionkey" 2) (cons "r_name" "ASIA"))))
(define nation (list (list (cons "n_nationkey" 10) (cons "n_regionkey" 1) (cons "n_name" "FRANCE")) (list (cons "n_nationkey" 20) (cons "n_regionkey" 2) (cons "n_name" "CHINA"))))
(define supplier (list (list (cons "s_suppkey" 100) (cons "s_name" "BestSupplier") (cons "s_address" "123 Rue") (cons "s_nationkey" 10) (cons "s_phone" "123") (cons "s_acctbal" 1000.0) (cons "s_comment" "Fast and reliable")) (list (cons "s_suppkey" 200) (cons "s_name" "AltSupplier") (cons "s_address" "456 Way") (cons "s_nationkey" 20) (cons "s_phone" "456") (cons "s_acctbal" 500.0) (cons "s_comment" "Slow"))))
(define part (list (list (cons "p_partkey" 1000) (cons "p_type" "LARGE BRASS") (cons "p_size" 15) (cons "p_mfgr" "M1")) (list (cons "p_partkey" 2000) (cons "p_type" "SMALL COPPER") (cons "p_size" 15) (cons "p_mfgr" "M2"))))
(define partsupp (list (list (cons "ps_partkey" 1000) (cons "ps_suppkey" 100) (cons "ps_supplycost" 10.0)) (list (cons "ps_partkey" 1000) (cons "ps_suppkey" 200) (cons "ps_supplycost" 15.0))))
(define europe_nations (let ((_res '()))
  (for-each (lambda (r)
    (for-each (lambda (n)
      (when (equal? (map-get n "n_regionkey") (map-get r "r_regionkey"))
        (when (equal? (map-get r "r_name") "EUROPE")
          (set! _res (append _res (list n)))
        )
      )) (if (string? nation) (string->list nation) nation))
  ) (if (string? region) (string->list region) region))
  _res))
(define europe_suppliers (let ((_res '()))
  (for-each (lambda (s)
    (for-each (lambda (n)
      (when (equal? (map-get s "s_nationkey") (map-get n "n_nationkey"))
        (set! _res (append _res (list (list (cons "s" s) (cons "n" n)))))
      )) (if (string? europe_nations) (string->list europe_nations) europe_nations))
  ) (if (string? supplier) (string->list supplier) supplier))
  _res))
(define target_parts (let ((_res '()))
  (for-each (lambda (p)
    (when (equal? (and (equal? (map-get p "p_size") 15) (map-get p "p_type")) "LARGE BRASS")
      (set! _res (append _res (list p)))
    )
  ) (if (string? part) (string->list part) part))
  _res))
(define target_partsupp (let ((_res '()))
  (for-each (lambda (ps)
    (for-each (lambda (p)
      (when (equal? (map-get ps "ps_partkey") (map-get p "p_partkey"))
        (for-each (lambda (s)
          (when (equal? (map-get ps "ps_suppkey") (map-get (map-get s "s") "s_suppkey"))
            (set! _res (append _res (list (list (cons "s_acctbal" (map-get (map-get s "s") "s_acctbal")) (cons "s_name" (map-get (map-get s "s") "s_name")) (cons "n_name" (map-get (map-get s "n") "n_name")) (cons "p_partkey" (map-get p "p_partkey")) (cons "p_mfgr" (map-get p "p_mfgr")) (cons "s_address" (map-get (map-get s "s") "s_address")) (cons "s_phone" (map-get (map-get s "s") "s_phone")) (cons "s_comment" (map-get (map-get s "s") "s_comment")) (cons "ps_supplycost" (map-get ps "ps_supplycost"))))))
          )) (if (string? europe_suppliers) (string->list europe_suppliers) europe_suppliers))
      )) (if (string? target_parts) (string->list target_parts) target_parts))
  ) (if (string? partsupp) (string->list partsupp) partsupp))
  _res))
(define costs (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "ps_supplycost"))))
  ) (if (string? target_partsupp) (string->list target_partsupp) target_partsupp))
  _res))
(define min_cost (min costs))
(define result (let ((_res '()) (_tmp '()))
  (for-each (lambda (x)
    (when (equal? (map-get x "ps_supplycost") min_cost)
      (set! _tmp (append _tmp (list (cons x (- (map-get x "s_acctbal"))))))
    )
  ) (if (string? target_partsupp) (string->list target_partsupp) target_partsupp))
  (set! _res (_sort _tmp))
  (set! _res (map car _res))
  _res))
(_json result)
(run-test "Q2 returns only supplier with min cost in Europe for brass part" test_Q2_returns_only_supplier_with_min_cost_in_Europe_for_brass_part)
(when (> failures 0) (display "\n[FAIL] ") (display failures) (display " test(s) failed.\n"))
