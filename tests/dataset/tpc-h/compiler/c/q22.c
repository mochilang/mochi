// Generated by Mochi compiler v0.10.26 on 2025-07-15T08:19:21Z
// Generated by Mochi compiler v0.10.26 on 2025-07-15T08:19:21Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  double *data;
} list_float;
static list_float list_float_create(int len) {
  list_float l;
  l.len = len;
  l.data = calloc(len, sizeof(double));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static int _count(list_int v) { return v.len; }
static double _sum_float(list_float v) {
  double sum = 0;
  for (int i = 0; i < v.len; i++)
    sum += v.data[i];
  return sum;
}
static double _avg_float(list_float v) {
  if (v.len == 0)
    return 0;
  double sum = 0;
  for (int i = 0; i < v.len; i++)
    sum += v.data[i];
  return sum / v.len;
}
static int contains_list_string(list_string v, char *item) {
  for (int i = 0; i < v.len; i++)
    if (strcmp(v.data[i], item) == 0)
      return 1;
  return 0;
}
static void _json_int(int v) { printf("%d", v); }
static void _json_float(double v) { printf("%g", v); }
static void _json_string(char *s) { printf("\"%s\"", s); }
static void _json_list_int(list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_int(v.data[i]);
  }
  printf("]");
}
static void _json_list_float(list_float v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_float(v.data[i]);
  }
  printf("]");
}
static void _json_list_string(list_string v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_string(v.data[i]);
  }
  printf("]");
}
static void _json_list_list_int(list_list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_list_int(v.data[i]);
  }
  printf("]");
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
typedef struct {
  char *key;
  list_int items;
} _GroupString;
typedef struct {
  int len;
  int cap;
  _GroupString *data;
} list_group_string;
static list_group_string _group_by_string(list_string src) {
  list_group_string res;
  res.len = 0;
  res.cap = 0;
  res.data = NULL;
  for (int i = 0; i < src.len; i++) {
    char *key = src.data[i];
    int idx = -1;
    for (int j = 0; j < res.len; j++)
      if (strcmp(res.data[j].key, key) == 0) {
        idx = j;
        break;
      }
    if (idx == -1) {
      if (res.len >= res.cap) {
        res.cap = res.cap ? res.cap * 2 : 4;
        res.data =
            (_GroupString *)realloc(res.data, sizeof(_GroupString) * res.cap);
      }
      res.data[res.len].key = key;
      res.data[res.len].items = list_int_create(0);
      idx = res.len++;
    }
    _GroupString *g = &res.data[idx];
    g->items.data =
        (int *)realloc(g->items.data, sizeof(int) * (g->items.len + 1));
    g->items.data[g->items.len++] = i;
  }
  return res;
}
typedef struct {
  const char *cntrycode;
  int numcust;
  double totacctbal;
} tmp1_t;
typedef struct {
  int len;
  tmp1_t *data;
} tmp1_list_t;
tmp1_list_t create_tmp1_list(int len) {
  tmp1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  const char *cntrycode;
  int numcust;
  double totacctbal;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_custkey;
  const char *c_phone;
  double c_acctbal;
} customer_t;
typedef struct {
  int len;
  customer_t *data;
} customer_list_t;
customer_list_t create_customer_list(int len) {
  customer_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(customer_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int o_orderkey;
  int o_custkey;
} order_t;
typedef struct {
  int len;
  order_t *data;
} order_list_t;
order_list_t create_order_list(int len) {
  order_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(order_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  const char *cntrycode;
  double c_acctbal;
} eligible_customers_item_t;
typedef struct {
  int len;
  eligible_customers_item_t *data;
} eligible_customers_item_list_t;
eligible_customers_item_list_t create_eligible_customers_item_list(int len) {
  eligible_customers_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(eligible_customers_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  const char *key;
  eligible_customers_item_list_t items;
} groupeligible_customers_item_t_t_t;
typedef struct {
  int len;
  groupeligible_customers_item_t_t_t *data;
} groupeligible_customers_item_t_t_list_t;
groupeligible_customers_item_t_t_list_t
create_groupeligible_customers_item_t_t_list(int len) {
  groupeligible_customers_item_t_t_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(groupeligible_customers_item_t_t_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  const char *cntrycode;
  int numcust;
  double totacctbal;
} row_item_t;
typedef struct {
  int len;
  row_item_t *data;
} row_item_list_t;
row_item_list_t create_row_item_list(int len) {
  row_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(row_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

static list_int
    test_Q22_returns_wealthy_inactive_customers_by_phone_prefix_result;
static void test_Q22_returns_wealthy_inactive_customers_by_phone_prefix() {
  tmp1_t tmp1[] = {
      (tmp1_t){.cntrycode = "13", .numcust = 1, .totacctbal = 600.0},
      (tmp_item_t){.cntrycode = "30", .numcust = 1, .totacctbal = 700.0}};
  int tmp1_len = sizeof(tmp1) / sizeof(tmp1[0]);
  int tmp2 = 1;
  if (test_Q22_returns_wealthy_inactive_customers_by_phone_prefix_result.len !=
      tmp1.len) {
    tmp2 = 0;
  } else {
    for (int i3 = 0;
         i3 <
         test_Q22_returns_wealthy_inactive_customers_by_phone_prefix_result.len;
         i3++) {
      if (test_Q22_returns_wealthy_inactive_customers_by_phone_prefix_result
              .data[i3] != tmp1.data[i3]) {
        tmp2 = 0;
        break;
      }
    }
  }
  if (!(tmp2)) {
    fprintf(stderr, "expect failed\n");
    exit(1);
  }
}

int main() {
  customer_t customer[] = {
      (customer_t){
          .c_custkey = 1, .c_phone = "13-123-4567", .c_acctbal = 600.0},
      (customer_t){
          .c_custkey = 2, .c_phone = "31-456-7890", .c_acctbal = 100.0},
      (customer_t){
          .c_custkey = 3, .c_phone = "30-000-0000", .c_acctbal = 700.0}};
  int customer_len = sizeof(customer) / sizeof(customer[0]);
  order_t orders[] = {(order_t){.o_orderkey = 10, .o_custkey = 2}};
  int orders_len = sizeof(orders) / sizeof(orders[0]);
  list_string valid_codes = list_string_create(7);
  valid_codes.data[0] = "13";
  valid_codes.data[1] = "31";
  valid_codes.data[2] = "23";
  valid_codes.data[3] = "29";
  valid_codes.data[4] = "30";
  valid_codes.data[5] = "18";
  valid_codes.data[6] = "17";
  int valid_codes = valid_codes;
  list_float tmp4 = list_float_create(customer_len);
  int tmp5 = 0;
  for (int tmp6 = 0; tmp6 < customer_len; tmp6++) {
    customer_t c = customer[tmp6];
    if (!(contains_list_string(
            valid_codes, c.c_acctbal > 0.0 && slice_string(c.c_phone, 0, 2)))) {
      continue;
    }
    tmp4.data[tmp5] = c.c_acctbal;
    tmp5++;
  }
  tmp4.len = tmp5;
  double avg_balance = _avg_float(tmp4);
  order_list_t tmp7 = order_list_t_create(orders_len);
  int tmp8 = 0;
  for (int tmp9 = 0; tmp9 < orders_len; tmp9++) {
    order_t o = orders[tmp9];
    if (!(o.o_custkey == c.c_custkey)) {
      continue;
    }
    tmp7.data[tmp8] = o;
    tmp8++;
  }
  tmp7.len = tmp8;
  eligible_customers_item_list_t tmp10 =
      create_eligible_customers_item_list(customer_len);
  int tmp11 = 0;
  for (int tmp12 = 0; tmp12 < customer_len; tmp12++) {
    customer_t c = customer[tmp12];
    if (!(contains_list_string(valid_codes, slice_string(c.c_phone, 0, 2)) &&
          c.c_acctbal > avg_balance && ((!tmp7.len > 0)))) {
      continue;
    }
    tmp10.data[tmp11] = (eligible_customers_item_t){
        .cntrycode = slice_string(c.c_phone, 0, 2), .c_acctbal = c.c_acctbal};
    tmp11++;
  }
  tmp10.len = tmp11;
  eligible_customers_item_list_t eligible_customers = tmp10;
  eligible_customers_item_list_t tmp13 =
      create_eligible_customers_item_list(eligible_customers.len);
  list_string tmp14 = list_string_create(eligible_customers.len);
  int tmp15 = 0;
  for (int i16 = 0; i16 < eligible_customers.len; i16++) {
    eligible_customers_item_t c = eligible_customers.data[i16];
    tmp13.data[tmp15] = c;
    tmp14.data[tmp15] = c.cntrycode;
    tmp15++;
  }
  tmp13.len = tmp15;
  tmp14.len = tmp15;
  list_group_string tmp17 = _group_by_string(tmp14);
  groupeligible_customers_item_t_t_list_t tmp18 =
      create_groupeligible_customers_item_t_t_list(tmp17.len);
  int tmp19 = 0;
  for (int gi = 0; gi < tmp17.len; gi++) {
    _GroupString _gp = tmp17.data[gi];
    eligible_customers_item_list_t tmp20 =
        eligible_customers_item_list_t_create(_gp.items.len);
    for (int i21 = 0; i21 < _gp.items.len; i21++) {
      tmp20.data[i21] = tmp13.data[_gp.items.data[i21]];
    }
    tmp20.len = _gp.items.len;
    groupeligible_customers_item_t_t_t g = {_gp.key, tmp20};
    tmp18.data[tmp19] = g;
    tmp19++;
  }
  tmp18.len = tmp19;
  groupeligible_customers_item_t_t_list_t groups = tmp18;
  list_int tmp = list_int_create(0);
  for (int tmp22 = 0; tmp22 < groups.len; tmp22++) {
    groupeligible_customers_item_t_t_t g = groups.data[tmp22];
    list_float tmp23 = list_float_create(g.items.len);
    int tmp24 = 0;
    for (int tmp25 = 0; tmp25 < g.items.len; tmp25++) {
      eligible_customers_item_t x = g.items.data[tmp25];
      tmp23.data[tmp24] = x.c_acctbal;
      tmp24++;
    }
    tmp23.len = tmp24;
    double total = _sum_float(tmp23);
    row_item_t row = (row_item_t){
        .cntrycode = g.key, .numcust = _count(g), .totacctbal = total};
    list_int tmp26 = list_int_create(0);
    int tmp27_data[1];
    list_int tmp27 = {1, tmp27_data};
    tmp27.data[0] = row;
    list_int tmp28 = concat_list_int(tmp26, tmp27);
    tmp = tmp28;
  }
  list_int tmp29 = list_int_create(0);
  list_int tmp30 = list_int_create(0);
  int *tmp33 = (int *)malloc(sizeof(int) * 0);
  int tmp31 = 0;
  for (int tmp32 = 0; tmp32 < 0; tmp32++) {
    int r = tmp29.data[tmp32];
    tmp30.data[tmp31] = r;
    tmp33[tmp31] = r.cntrycode;
    tmp31++;
  }
  tmp30.len = tmp31;
  for (int i36 = 0; i36 < tmp31 - 1; i36++) {
    for (int i37 = i36 + 1; i37 < tmp31; i37++) {
      if (tmp33[i36] > tmp33[i37]) {
        int tmp34 = tmp33[i36];
        tmp33[i36] = tmp33[i37];
        tmp33[i37] = tmp34;
        int tmp35 = tmp30.data[i36];
        tmp30.data[i36] = tmp30.data[i37];
        tmp30.data[i37] = tmp35;
      }
    }
  }
  list_int result = tmp30;
  _json_list_int(result);
  test_Q22_returns_wealthy_inactive_customers_by_phone_prefix_result = result;
  test_Q22_returns_wealthy_inactive_customers_by_phone_prefix();
  free(tmp4.data);
  free(tmp7.data);
  free(eligible_customers.data);
  free(tmp23.data);
  free(result.data);
  return 0;
}
