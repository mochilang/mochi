// Generated by Mochi compiler v0.10.26 on 2025-07-15T08:19:16Z
// Generated by Mochi compiler v0.10.26 on 2025-07-15T08:19:16Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  double *data;
} list_float;
static list_float list_float_create(int len) {
  list_float l;
  l.len = len;
  l.data = calloc(len, sizeof(double));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static void _json_int(int v) { printf("%d", v); }
static void _json_float(double v) { printf("%g", v); }
static void _json_string(char *s) { printf("\"%s\"", s); }
static void _json_list_int(list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_int(v.data[i]);
  }
  printf("]");
}
static void _json_list_float(list_float v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_float(v.data[i]);
  }
  printf("]");
}
static void _json_list_string(list_string v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_string(v.data[i]);
  }
  printf("]");
}
static void _json_list_list_int(list_list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_list_int(v.data[i]);
  }
  printf("]");
}
typedef struct {
  char *key;
  list_int items;
} _GroupString;
typedef struct {
  int len;
  int cap;
  _GroupString *data;
} list_group_string;
static list_group_string _group_by_string(list_string src) {
  list_group_string res;
  res.len = 0;
  res.cap = 0;
  res.data = NULL;
  for (int i = 0; i < src.len; i++) {
    char *key = src.data[i];
    int idx = -1;
    for (int j = 0; j < res.len; j++)
      if (strcmp(res.data[j].key, key) == 0) {
        idx = j;
        break;
      }
    if (idx == -1) {
      if (res.len >= res.cap) {
        res.cap = res.cap ? res.cap * 2 : 4;
        res.data =
            (_GroupString *)realloc(res.data, sizeof(_GroupString) * res.cap);
      }
      res.data[res.len].key = key;
      res.data[res.len].items = list_int_create(0);
      idx = res.len++;
    }
    _GroupString *g = &res.data[idx];
    g->items.data =
        (int *)realloc(g->items.data, sizeof(int) * (g->items.len + 1));
    g->items.data[g->items.len++] = i;
  }
  return res;
}
static char *start_date = "1993-07-01";
static char *end_date = "1993-08-01";

typedef struct {
  const char *o_orderpriority;
  int order_count;
} tmp1_t;
typedef struct {
  int len;
  tmp1_t *data;
} tmp1_list_t;
tmp1_list_t create_tmp1_list(int len) {
  tmp1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  const char *o_orderpriority;
  int order_count;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int o_orderkey;
  const char *o_orderdate;
  const char *o_orderpriority;
} order_t;
typedef struct {
  int len;
  order_t *data;
} order_list_t;
order_list_t create_order_list(int len) {
  order_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(order_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int l_orderkey;
  const char *l_commitdate;
  const char *l_receiptdate;
} lineitem_t;
typedef struct {
  int len;
  lineitem_t *data;
} lineitem_list_t;
lineitem_list_t create_lineitem_list(int len) {
  lineitem_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(lineitem_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  const char *o_orderpriority;
  int order_count;
} result_item_t;
typedef struct {
  int len;
  result_item_t *data;
} result_item_list_t;
result_item_list_t create_result_item_list(int len) {
  result_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(result_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

static list_int
    test_Q4_returns_count_of_orders_with_late_lineitems_in_range_result;
static void test_Q4_returns_count_of_orders_with_late_lineitems_in_range() {
  tmp1_t tmp1[] = {(tmp1_t){.o_orderpriority = "1-URGENT", .order_count = 1},
                   (tmp_item_t){.o_orderpriority = "2-HIGH", .order_count = 1}};
  int tmp1_len = sizeof(tmp1) / sizeof(tmp1[0]);
  int tmp2 = 1;
  if (test_Q4_returns_count_of_orders_with_late_lineitems_in_range_result.len !=
      tmp1.len) {
    tmp2 = 0;
  } else {
    for (int i3 = 0;
         i3 <
         test_Q4_returns_count_of_orders_with_late_lineitems_in_range_result
             .len;
         i3++) {
      if (test_Q4_returns_count_of_orders_with_late_lineitems_in_range_result
              .data[i3] != tmp1.data[i3]) {
        tmp2 = 0;
        break;
      }
    }
  }
  if (!(tmp2)) {
    fprintf(stderr, "expect failed\n");
    exit(1);
  }
}

int main() {
  order_t orders[] = {(order_t){.o_orderkey = 1,
                                .o_orderdate = "1993-07-01",
                                .o_orderpriority = "1-URGENT"},
                      (order_t){.o_orderkey = 2,
                                .o_orderdate = "1993-07-15",
                                .o_orderpriority = "2-HIGH"},
                      (order_t){.o_orderkey = 3,
                                .o_orderdate = "1993-08-01",
                                .o_orderpriority = "3-NORMAL"}};
  int orders_len = sizeof(orders) / sizeof(orders[0]);
  lineitem_t lineitem[] = {(lineitem_t){.l_orderkey = 1,
                                        .l_commitdate = "1993-07-10",
                                        .l_receiptdate = "1993-07-12"},
                           (lineitem_t){.l_orderkey = 1,
                                        .l_commitdate = "1993-07-12",
                                        .l_receiptdate = "1993-07-10"},
                           (lineitem_t){.l_orderkey = 2,
                                        .l_commitdate = "1993-07-20",
                                        .l_receiptdate = "1993-07-25"},
                           (lineitem_t){.l_orderkey = 3,
                                        .l_commitdate = "1993-08-02",
                                        .l_receiptdate = "1993-08-01"},
                           (lineitem_t){.l_orderkey = 3,
                                        .l_commitdate = "1993-08-05",
                                        .l_receiptdate = "1993-08-10"}};
  int lineitem_len = sizeof(lineitem) / sizeof(lineitem[0]);
  order_list_t tmp4 = order_list_t_create(orders_len);
  int tmp5 = 0;
  for (int tmp6 = 0; tmp6 < orders_len; tmp6++) {
    order_t o = orders[tmp6];
    if (!((strcmp(o.o_orderdate, start_date) >= 0) &&
          o.o_orderdate < end_date)) {
      continue;
    }
    tmp4.data[tmp5] = o;
    tmp5++;
  }
  tmp4.len = tmp5;
  order_list_t date_filtered_orders = tmp4;
  lineitem_list_t tmp7 = lineitem_list_t_create(lineitem_len);
  int tmp8 = 0;
  for (int tmp9 = 0; tmp9 < lineitem_len; tmp9++) {
    lineitem_t l = lineitem[tmp9];
    if (!(l.l_orderkey == o.o_orderkey && l.l_commitdate < l.l_receiptdate)) {
      continue;
    }
    tmp7.data[tmp8] = l;
    tmp8++;
  }
  tmp7.len = tmp8;
  order_list_t tmp10 = order_list_t_create(date_filtered_orders.len);
  int tmp11 = 0;
  for (int tmp12 = 0; tmp12 < date_filtered_orders.len; tmp12++) {
    order_t o = date_filtered_orders.data[tmp12];
    if (!(tmp7.len > 0)) {
      continue;
    }
    tmp10.data[tmp11] = o;
    tmp11++;
  }
  tmp10.len = tmp11;
  order_list_t late_orders = tmp10;
  order_list_t tmp13 = create_order_list(late_orders.len);
  list_string tmp14 = list_string_create(late_orders.len);
  int tmp15 = 0;
  for (int i16 = 0; i16 < late_orders.len; i16++) {
    order_t o = late_orders.data[i16];
    tmp13.data[tmp15] = o;
    tmp14.data[tmp15] = o.o_orderpriority;
    tmp15++;
  }
  tmp13.len = tmp15;
  tmp14.len = tmp15;
  list_group_string tmp17 = _group_by_string(tmp14);
  result_item_list_t tmp18 = create_result_item_list(tmp17.len);
  const char **tmp20 = (const char **)malloc(sizeof(const char *) * tmp17.len);
  int tmp19 = 0;
  for (int gi = 0; gi < tmp17.len; gi++) {
    _GroupString _gp = tmp17.data[gi];
    order_list_t tmp21 = order_list_t_create(_gp.items.len);
    for (int i22 = 0; i22 < _gp.items.len; i22++) {
      tmp21.data[i22] = tmp13.data[_gp.items.data[i22]];
    }
    tmp21.len = _gp.items.len;
    struct {
      char *key;
      order_list_t items;
    } g = {_gp.key, tmp21};
    tmp18.data[tmp19] =
        (result_item_t){.o_orderpriority = g.key, .order_count = g.items.len};
    tmp20[tmp19] = g.key;
    tmp19++;
  }
  tmp18.len = tmp19;
  for (int i25 = 0; i25 < tmp19 - 1; i25++) {
    for (int i26 = i25 + 1; i26 < tmp19; i26++) {
      if (tmp20[i25] > tmp20[i26]) {
        const char *tmp23 = tmp20[i25];
        tmp20[i25] = tmp20[i26];
        tmp20[i26] = tmp23;
        result_item_t tmp24 = tmp18.data[i25];
        tmp18.data[i25] = tmp18.data[i26];
        tmp18.data[i26] = tmp24;
      }
    }
  }
  result_item_list_t result = tmp18;
  printf("[");
  for (int i27 = 0; i27 < result.len; i27++) {
    if (i27 > 0)
      printf(",");
    result_item_t it = result.data[i27];
    printf("{");
    _json_string("o_orderpriority");
    printf(":");
    _json_string(it.o_orderpriority);
    printf(",");
    _json_string("order_count");
    printf(":");
    _json_int(it.order_count);
    printf("}");
  }
  printf("]");
  test_Q4_returns_count_of_orders_with_late_lineitems_in_range_result = result;
  test_Q4_returns_count_of_orders_with_late_lineitems_in_range();
  free(date_filtered_orders.data);
  free(tmp7.data);
  free(late_orders.data);
  return 0;
}
