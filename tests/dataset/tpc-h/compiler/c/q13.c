// Generated by Mochi compiler v0.10.27 on 2025-07-17T18:26:22Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  double *data;
} list_float;
static list_float list_float_create(int len) {
  list_float l;
  l.len = len;
  l.data = calloc(len, sizeof(double));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  char *key;
  int value;
} pair_string_int;
static pair_string_int pair_string_int_new(char *key, int value) {
  pair_string_int p;
  p.key = key;
  p.value = value;
  return p;
}
typedef struct {
  int len;
  int cap;
  pair_string_int *data;
} map_string_int;
static map_string_int map_string_int_create(int cap) {
  map_string_int m;
  m.len = 0;
  m.cap = cap;
  m.data = cap ? calloc(cap, sizeof(pair_string_int)) : NULL;
  if (cap && !m.data) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return m;
}
static void map_string_int_put(map_string_int *m, char *k, int v) {
  for (int i = 0; i < m->len; i++)
    if (strcmp(m->data[i].key, k) == 0) {
      m->data[i].value = v;
      return;
    }
  if (m->len >= m->cap) {
    m->cap = m->cap ? m->cap * 2 : 4;
    m->data =
        (pair_string_int *)realloc(m->data, sizeof(pair_string_int) * m->cap);
  }
  m->data[m->len++] = pair_string_int_new(k, v);
}
static int map_string_int_get(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return m.data[i].value;
  return 0;
}
static int map_string_int_contains(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return 1;
  return 0;
}
static int cmp_map_string_int(map_string_int a, map_string_int b) {
  int aa = map_string_int_get(a, "a");
  int ba = map_string_int_get(b, "a");
  if (aa != ba)
    return aa > ba ? 1 : -1;
  int ab = map_string_int_get(a, "b");
  int bb = map_string_int_get(b, "b");
  if (ab != bb)
    return ab > bb ? 1 : -1;
  return 0;
}
static int contains_string(char *s, char *sub) {
  return strstr(s, sub) != NULL;
}
static void _json_int(int v) { printf("%d", v); }
static void _json_float(double v) { printf("%g", v); }
static void _json_string(char *s) { printf("\"%s\"", s); }
static void _json_list_int(list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_int(v.data[i]);
  }
  printf("]");
}
static void _json_list_float(list_float v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_float(v.data[i]);
  }
  printf("]");
}
static void _json_list_string(list_string v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_string(v.data[i]);
  }
  printf("]");
}
static void _json_list_list_int(list_list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_list_int(v.data[i]);
  }
  printf("]");
}
typedef struct {
  int key;
  list_int items;
} _GroupInt;
typedef struct {
  int len;
  int cap;
  _GroupInt *data;
} list_group_int;
static list_group_int _group_by_int(list_int src) {
  list_group_int res;
  res.len = 0;
  res.cap = 0;
  res.data = NULL;
  for (int i = 0; i < src.len; i++) {
    int key = src.data[i];
    int idx = -1;
    for (int j = 0; j < res.len; j++)
      if (res.data[j].key == key) {
        idx = j;
        break;
      }
    if (idx == -1) {
      if (res.len >= res.cap) {
        res.cap = res.cap ? res.cap * 2 : 4;
        res.data = (_GroupInt *)realloc(res.data, sizeof(_GroupInt) * res.cap);
      }
      res.data[res.len].key = key;
      res.data[res.len].items = list_int_create(0);
      idx = res.len++;
    }
    _GroupInt *g = &res.data[idx];
    g->items.data =
        (int *)realloc(g->items.data, sizeof(int) * (g->items.len + 1));
    g->items.data[g->items.len++] = src.data[i];
  }
  return res;
}
typedef struct {
  int c_count;
  int custdist;
} tmp1_t;
typedef struct {
  int len;
  tmp1_t *data;
} tmp1_list_t;
tmp1_list_t create_tmp1_list(int len) {
  tmp1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_custkey;
} customer_t;
typedef struct {
  int len;
  customer_t *data;
} customer_list_t;
customer_list_t create_customer_list(int len) {
  customer_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(customer_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int o_orderkey;
  int o_custkey;
  char *o_comment;
} order_t;
typedef struct {
  int len;
  order_t *data;
} order_list_t;
order_list_t create_order_list(int len) {
  order_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(order_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_count;
} per_customer_item_t;
typedef struct {
  int len;
  per_customer_item_t *data;
} per_customer_item_list_t;
per_customer_item_list_t create_per_customer_item_list(int len) {
  per_customer_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(per_customer_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_count;
  int custdist;
} grouped_item_t;
typedef struct {
  int len;
  grouped_item_t *data;
} grouped_item_list_t;
grouped_item_list_t create_grouped_item_list(int len) {
  grouped_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(grouped_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

static int test_Q13_groups_customers_by_non_special_order_count_grouped;
static void test_Q13_groups_customers_by_non_special_order_count() {
  map_string_int tmp2 = map_string_int_create(2);
  map_string_int_put(&tmp2, "c_count", 0);
  map_string_int_put(&tmp2, "custdist", 2);
  tmp1_t tmp1[] = {(tmp1_t){.c_count = 2, .custdist = 1}, tmp2};
  int tmp1_len = sizeof(tmp1) / sizeof(tmp1[0]);
  int tmp3 = 1;
  if (test_Q13_groups_customers_by_non_special_order_count_grouped.len !=
      tmp1_len) {
    tmp3 = 0;
  } else {
    for (int i4 = 0;
         i4 < test_Q13_groups_customers_by_non_special_order_count_grouped.len;
         i4++) {
      if (test_Q13_groups_customers_by_non_special_order_count_grouped
              .data[i4] != tmp1[i4]) {
        tmp3 = 0;
        break;
      }
    }
  }
  if (!(tmp3)) {
    fprintf(stderr, "expect failed\n");
    exit(1);
  }
}

int _mochi_main() {
  customer_t customer[] = {(customer_t){.c_custkey = 1},
                           (customer_t){.c_custkey = 2},
                           (customer_t){.c_custkey = 3}};
  int customer_len = sizeof(customer) / sizeof(customer[0]);
  order_t orders[] = {
      (order_t){
          .o_orderkey = 100, .o_custkey = 1, .o_comment = "fast delivery"},
      (order_t){.o_orderkey = 101, .o_custkey = 1, .o_comment = "no comment"},
      (order_t){.o_orderkey = 102,
                .o_custkey = 2,
                .o_comment = "special requests only"}};
  int orders_len = sizeof(orders) / sizeof(orders[0]);
  order_list_t tmp5 = create_order_list(orders_len);
  int tmp6 = 0;
  for (int tmp7 = 0; tmp7 < orders_len; tmp7++) {
    order_t o = orders[tmp7];
    if (!((o.o_custkey == c.c_custkey &&
           ((!(contains_string(o.o_comment, "special")))) &&
           ((!(contains_string(o.o_comment, "requests"))))))) {
      continue;
    }
    tmp5.data[tmp6] = o;
    tmp6++;
  }
  tmp5.len = tmp6;
  per_customer_item_list_t tmp8 = create_per_customer_item_list(customer_len);
  int tmp9 = 0;
  for (int tmp10 = 0; tmp10 < customer_len; tmp10++) {
    customer_t c = customer[tmp10];
    tmp8.data[tmp9] = (per_customer_item_t){.c_count = tmp5.len};
    tmp9++;
  }
  tmp8.len = tmp9;
  per_customer_item_list_t per_customer = tmp8;
  per_customer_item_list_t tmp11 =
      create_per_customer_item_list(per_customer.len);
  int tmp12_data[per_customer.len];
  list_int tmp12 = {0, tmp12_data};
  int tmp13 = 0;
  for (int i14 = 0; i14 < per_customer.len; i14++) {
    per_customer_item_t x = per_customer.data[i14];
    tmp11.data[tmp13] = x;
    tmp12.data[tmp13] = x.c_count;
    tmp13++;
  }
  tmp11.len = tmp13;
  tmp12.len = tmp13;
  list_group_int tmp15 = _group_by_int(tmp12);
  grouped_item_list_t tmp16 = create_grouped_item_list(tmp15.len);
  int *tmp18 = (int *)malloc(sizeof(int) * tmp15.len);
  int tmp17 = 0;
  for (int gi = 0; gi < tmp15.len; gi++) {
    _GroupInt _gp = tmp15.data[gi];
    per_customer_item_list_t tmp19 =
        create_per_customer_item_list(_gp.items.len);
    for (int i20 = 0; i20 < _gp.items.len; i20++) {
      tmp19.data[i20] = tmp11.data[_gp.items.data[i20]];
    }
    tmp19.len = _gp.items.len;
    struct {
      int key;
      per_customer_item_list_t items;
    } g = {_gp.key, tmp19};
    tmp16.data[tmp17] =
        (grouped_item_t){.c_count = g.key, .custdist = g.items.len};
    tmp18[tmp17] = (-g.key);
    tmp17++;
  }
  tmp16.len = tmp17;
  for (int i23 = 0; i23 < tmp17 - 1; i23++) {
    for (int i24 = i23 + 1; i24 < tmp17; i24++) {
      if (tmp18[i23] > tmp18[i24]) {
        int tmp21 = tmp18[i23];
        tmp18[i23] = tmp18[i24];
        tmp18[i24] = tmp21;
        grouped_item_t tmp22 = tmp16.data[i23];
        tmp16.data[i23] = tmp16.data[i24];
        tmp16.data[i24] = tmp22;
      }
    }
  }
  grouped_item_list_t grouped = tmp16;
  printf("[");
  for (int i25 = 0; i25 < grouped.len; i25++) {
    if (i25 > 0)
      printf(",");
    grouped_item_t it = grouped.data[i25];
    printf("{");
    _json_string("c_count");
    printf(":");
    _json_int(it.c_count);
    printf(",");
    _json_string("custdist");
    printf(":");
    _json_int(it.custdist);
    printf("}");
  }
  printf("]");
  test_Q13_groups_customers_by_non_special_order_count_grouped = grouped;
  test_Q13_groups_customers_by_non_special_order_count();
  free(tmp5.data);
  free(per_customer.data);
  return 0;
}
int main() { return _mochi_main(); }
