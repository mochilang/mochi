// Generated by Mochi compiler v0.10.25 on 2006-01-02T15:04:05Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  double *data;
} list_float;
static list_float list_float_create(int len) {
  list_float l;
  l.len = len;
  l.data = calloc(len, sizeof(double));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static int contains_string(char *s, char *sub) {
  return strstr(s, sub) != NULL;
}
static void _json_int(int v) { printf("%d", v); }
static void _json_float(double v) { printf("%g", v); }
static void _json_string(char *s) { printf("\"%s\"", s); }
static void _json_list_int(list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_int(v.data[i]);
  }
  printf("]");
}
static void _json_list_float(list_float v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_float(v.data[i]);
  }
  printf("]");
}
static void _json_list_string(list_string v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_string(v.data[i]);
  }
  printf("]");
}
static void _json_list_list_int(list_list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_list_int(v.data[i]);
  }
  printf("]");
}
typedef struct {
  int key;
  list_int items;
} _GroupInt;
typedef struct {
  int len;
  int cap;
  _GroupInt *data;
} list_group_int;
static list_group_int _group_by_int(list_int src) {
  list_group_int res;
  res.len = 0;
  res.cap = 0;
  res.data = NULL;
  for (int i = 0; i < src.len; i++) {
    int key = src.data[i];
    int idx = -1;
    for (int j = 0; j < res.len; j++)
      if (res.data[j].key == key) {
        idx = j;
        break;
      }
    if (idx == -1) {
      if (res.len >= res.cap) {
        res.cap = res.cap ? res.cap * 2 : 4;
        res.data = (_GroupInt *)realloc(res.data, sizeof(_GroupInt) * res.cap);
      }
      res.data[res.len].key = key;
      res.data[res.len].items = list_int_create(0);
      idx = res.len++;
    }
    _GroupInt *g = &res.data[idx];
    g->items.data =
        (int *)realloc(g->items.data, sizeof(int) * (g->items.len + 1));
    g->items.data[g->items.len++] = src.data[i];
  }
  return res;
}
typedef struct {
  int c_count;
  int custdist;
} TmpItem;
typedef struct {
  int len;
  TmpItem *data;
} list_TmpItem;
static list_TmpItem list_TmpItem_create(int len) {
  list_TmpItem l;
  l.len = len;
  l.data = calloc(len, sizeof(TmpItem));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_count;
  int custdist;
} TmpItem1;
typedef struct {
  int len;
  TmpItem1 *data;
} list_TmpItem1;
static list_TmpItem1 list_TmpItem1_create(int len) {
  list_TmpItem1 l;
  l.len = len;
  l.data = calloc(len, sizeof(TmpItem1));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_custkey;
} CustomerItem;
typedef struct {
  int len;
  CustomerItem *data;
} list_CustomerItem;
static list_CustomerItem list_CustomerItem_create(int len) {
  list_CustomerItem l;
  l.len = len;
  l.data = calloc(len, sizeof(CustomerItem));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int o_orderkey;
  int o_custkey;
  char *o_comment;
} OrdersItem;
typedef struct {
  int len;
  OrdersItem *data;
} list_OrdersItem;
static list_OrdersItem list_OrdersItem_create(int len) {
  list_OrdersItem l;
  l.len = len;
  l.data = calloc(len, sizeof(OrdersItem));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_count;
} Per_customerItem;
typedef struct {
  int len;
  Per_customerItem *data;
} list_Per_customerItem;
static list_Per_customerItem list_Per_customerItem_create(int len) {
  list_Per_customerItem l;
  l.len = len;
  l.data = calloc(len, sizeof(Per_customerItem));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_count;
  int custdist;
} GroupedItem;
typedef struct {
  int len;
  GroupedItem *data;
} list_GroupedItem;
static list_GroupedItem list_GroupedItem_create(int len) {
  list_GroupedItem l;
  l.len = len;
  l.data = calloc(len, sizeof(GroupedItem));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

static int test_Q13_groups_customers_by_non_special_order_count_grouped;
static void test_Q13_groups_customers_by_non_special_order_count() {
  list_int tmp1 = list_int_create(2);
  tmp1.data[0] = (TmpItem){.c_count = 2, .custdist = 1};
  tmp1.data[1] = (TmpItem1){.c_count = 0, .custdist = 2};
  int tmp2 = 1;
  if (test_Q13_groups_customers_by_non_special_order_count_grouped.len !=
      tmp1.len) {
    tmp2 = 0;
  } else {
    for (int i3 = 0;
         i3 < test_Q13_groups_customers_by_non_special_order_count_grouped.len;
         i3++) {
      if (test_Q13_groups_customers_by_non_special_order_count_grouped
              .data[i3] != tmp1.data[i3]) {
        tmp2 = 0;
        break;
      }
    }
  }
  if (!(tmp2)) {
    fprintf(stderr, "expect failed\n");
    exit(1);
  }
}

int main() {
  CustomerItem tmp4_data[] = {(CustomerItem){.c_custkey = 1},
                              (CustomerItem){.c_custkey = 2},
                              (CustomerItem){.c_custkey = 3}};
  list_CustomerItem tmp4 = {3, tmp4_data};
  list_CustomerItem customer = tmp4;
  OrdersItem tmp5_data[] = {
      (OrdersItem){
          .o_orderkey = 100, .o_custkey = 1, .o_comment = "fast delivery"},
      (OrdersItem){
          .o_orderkey = 101, .o_custkey = 1, .o_comment = "no comment"},
      (OrdersItem){.o_orderkey = 102,
                   .o_custkey = 2,
                   .o_comment = "special requests only"}};
  list_OrdersItem tmp5 = {3, tmp5_data};
  list_OrdersItem orders = tmp5;
  list_OrdersItem tmp6 = list_OrdersItem_create(orders.len);
  int tmp7 = 0;
  for (int tmp8 = 0; tmp8 < orders.len; tmp8++) {
    OrdersItem o = orders.data[tmp8];
    if (!((o.o_custkey == c.c_custkey &&
           ((!(contains_string(o.o_comment, "special")))) &&
           ((!(contains_string(o.o_comment, "requests"))))))) {
      continue;
    }
    tmp6.data[tmp7] = o;
    tmp7++;
  }
  tmp6.len = tmp7;
  list_Per_customerItem tmp9 = list_Per_customerItem_create(customer.len);
  int tmp10 = 0;
  for (int tmp11 = 0; tmp11 < customer.len; tmp11++) {
    CustomerItem c = customer.data[tmp11];
    tmp9.data[tmp10] = (Per_customerItem){.c_count = tmp6.len};
    tmp10++;
  }
  tmp9.len = tmp10;
  list_Per_customerItem per_customer = tmp9;
  list_Per_customerItem tmp12 = list_Per_customerItem_create(per_customer.len);
  int tmp13_data[per_customer.len];
  list_int tmp13 = {0, tmp13_data};
  int tmp14 = 0;
  for (int i15 = 0; i15 < per_customer.len; i15++) {
    Per_customerItem x = per_customer.data[i15];
    tmp12.data[tmp14] = x;
    tmp13.data[tmp14] = x.c_count;
    tmp14++;
  }
  tmp12.len = tmp14;
  tmp13.len = tmp14;
  list_group_int tmp16 = _group_by_int(tmp13);
  list_GroupedItem tmp17 = list_GroupedItem_create(tmp16.len);
  int *tmp19 = (int *)malloc(sizeof(int) * tmp16.len);
  int tmp18 = 0;
  for (int gi = 0; gi < tmp16.len; gi++) {
    _GroupInt _gp = tmp16.data[gi];
    list_Per_customerItem tmp20 = list_Per_customerItem_create(_gp.items.len);
    for (int i21 = 0; i21 < _gp.items.len; i21++) {
      tmp20.data[i21] = tmp12.data[_gp.items.data[i21]];
    }
    tmp20.len = _gp.items.len;
    struct {
      int key;
      list_Per_customerItem items;
    } g = {_gp.key, tmp20};
    tmp17.data[tmp18] =
        (GroupedItem){.c_count = g.key, .custdist = g.items.len};
    tmp19[tmp18] = (-g.key);
    tmp18++;
  }
  tmp17.len = tmp18;
  for (int i24 = 0; i24 < tmp18 - 1; i24++) {
    for (int i25 = i24 + 1; i25 < tmp18; i25++) {
      if (tmp19[i24] > tmp19[i25]) {
        int tmp22 = tmp19[i24];
        tmp19[i24] = tmp19[i25];
        tmp19[i25] = tmp22;
        GroupedItem tmp23 = tmp17.data[i24];
        tmp17.data[i24] = tmp17.data[i25];
        tmp17.data[i25] = tmp23;
      }
    }
  }
  list_GroupedItem grouped = tmp17;
  printf("[");
  for (int i26 = 0; i26 < grouped.len; i26++) {
    if (i26 > 0)
      printf(",");
    GroupedItem it = grouped.data[i26];
    printf("{");
    _json_string("c_count");
    printf(":");
    _json_int(it.c_count);
    printf(",");
    _json_string("custdist");
    printf(":");
    _json_int(it.custdist);
    printf("}");
  }
  printf("]");
  test_Q13_groups_customers_by_non_special_order_count_grouped = grouped;
  test_Q13_groups_customers_by_non_special_order_count();
  return 0;
}
