// Generated by Mochi compiler v0.10.26 on 2025-07-15T08:19:19Z
// Generated by Mochi compiler v0.10.26 on 2025-07-15T08:19:19Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  double *data;
} list_float;
static list_float list_float_create(int len) {
  list_float l;
  l.len = len;
  l.data = calloc(len, sizeof(double));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static int contains_string(char *s, char *sub) {
  return strstr(s, sub) != NULL;
}
static void _json_int(int v) { printf("%d", v); }
static void _json_float(double v) { printf("%g", v); }
static void _json_string(char *s) { printf("\"%s\"", s); }
static void _json_list_int(list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_int(v.data[i]);
  }
  printf("]");
}
static void _json_list_float(list_float v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_float(v.data[i]);
  }
  printf("]");
}
static void _json_list_string(list_string v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_string(v.data[i]);
  }
  printf("]");
}
static void _json_list_list_int(list_list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_list_int(v.data[i]);
  }
  printf("]");
}
typedef struct {
  int key;
  list_int items;
} _GroupInt;
typedef struct {
  int len;
  int cap;
  _GroupInt *data;
} list_group_int;
static list_group_int _group_by_int(list_int src) {
  list_group_int res;
  res.len = 0;
  res.cap = 0;
  res.data = NULL;
  for (int i = 0; i < src.len; i++) {
    int key = src.data[i];
    int idx = -1;
    for (int j = 0; j < res.len; j++)
      if (res.data[j].key == key) {
        idx = j;
        break;
      }
    if (idx == -1) {
      if (res.len >= res.cap) {
        res.cap = res.cap ? res.cap * 2 : 4;
        res.data = (_GroupInt *)realloc(res.data, sizeof(_GroupInt) * res.cap);
      }
      res.data[res.len].key = key;
      res.data[res.len].items = list_int_create(0);
      idx = res.len++;
    }
    _GroupInt *g = &res.data[idx];
    g->items.data =
        (int *)realloc(g->items.data, sizeof(int) * (g->items.len + 1));
    g->items.data[g->items.len++] = src.data[i];
  }
  return res;
}
typedef struct {
  int c_count;
  int custdist;
} tmp1_t;
typedef struct {
  int len;
  tmp1_t *data;
} tmp1_list_t;
tmp1_list_t create_tmp1_list(int len) {
  tmp1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_count;
  int custdist;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_custkey;
} customer_t;
typedef struct {
  int len;
  customer_t *data;
} customer_list_t;
customer_list_t create_customer_list(int len) {
  customer_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(customer_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int o_orderkey;
  int o_custkey;
  const char *o_comment;
} order_t;
typedef struct {
  int len;
  order_t *data;
} order_list_t;
order_list_t create_order_list(int len) {
  order_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(order_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_count;
} per_customer_item_t;
typedef struct {
  int len;
  per_customer_item_t *data;
} per_customer_item_list_t;
per_customer_item_list_t create_per_customer_item_list(int len) {
  per_customer_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(per_customer_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_count;
  int custdist;
} grouped_item_t;
typedef struct {
  int len;
  grouped_item_t *data;
} grouped_item_list_t;
grouped_item_list_t create_grouped_item_list(int len) {
  grouped_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(grouped_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

static int test_Q13_groups_customers_by_non_special_order_count_grouped;
static void test_Q13_groups_customers_by_non_special_order_count() {
  tmp1_t tmp1[] = {(tmp1_t){.c_count = 2, .custdist = 1},
                   (tmp_item_t){.c_count = 0, .custdist = 2}};
  int tmp1_len = sizeof(tmp1) / sizeof(tmp1[0]);
  int tmp2 = 1;
  if (test_Q13_groups_customers_by_non_special_order_count_grouped.len !=
      tmp1.len) {
    tmp2 = 0;
  } else {
    for (int i3 = 0;
         i3 < test_Q13_groups_customers_by_non_special_order_count_grouped.len;
         i3++) {
      if (test_Q13_groups_customers_by_non_special_order_count_grouped
              .data[i3] != tmp1.data[i3]) {
        tmp2 = 0;
        break;
      }
    }
  }
  if (!(tmp2)) {
    fprintf(stderr, "expect failed\n");
    exit(1);
  }
}

int main() {
  customer_t customer[] = {(customer_t){.c_custkey = 1},
                           (customer_t){.c_custkey = 2},
                           (customer_t){.c_custkey = 3}};
  int customer_len = sizeof(customer) / sizeof(customer[0]);
  order_t orders[] = {
      (order_t){
          .o_orderkey = 100, .o_custkey = 1, .o_comment = "fast delivery"},
      (order_t){.o_orderkey = 101, .o_custkey = 1, .o_comment = "no comment"},
      (order_t){.o_orderkey = 102,
                .o_custkey = 2,
                .o_comment = "special requests only"}};
  int orders_len = sizeof(orders) / sizeof(orders[0]);
  order_list_t tmp4 = order_list_t_create(orders_len);
  int tmp5 = 0;
  for (int tmp6 = 0; tmp6 < orders_len; tmp6++) {
    order_t o = orders[tmp6];
    if (!((o.o_custkey == c.c_custkey &&
           ((!(contains_string(o.o_comment, "special")))) &&
           ((!(contains_string(o.o_comment, "requests"))))))) {
      continue;
    }
    tmp4.data[tmp5] = o;
    tmp5++;
  }
  tmp4.len = tmp5;
  per_customer_item_list_t tmp7 = create_per_customer_item_list(customer_len);
  int tmp8 = 0;
  for (int tmp9 = 0; tmp9 < customer_len; tmp9++) {
    customer_t c = customer[tmp9];
    tmp7.data[tmp8] = (per_customer_item_t){.c_count = tmp4.len};
    tmp8++;
  }
  tmp7.len = tmp8;
  per_customer_item_list_t per_customer = tmp7;
  per_customer_item_list_t tmp10 =
      create_per_customer_item_list(per_customer.len);
  int tmp11_data[per_customer.len];
  list_int tmp11 = {0, tmp11_data};
  int tmp12 = 0;
  for (int i13 = 0; i13 < per_customer.len; i13++) {
    per_customer_item_t x = per_customer.data[i13];
    tmp10.data[tmp12] = x;
    tmp11.data[tmp12] = x.c_count;
    tmp12++;
  }
  tmp10.len = tmp12;
  tmp11.len = tmp12;
  list_group_int tmp14 = _group_by_int(tmp11);
  grouped_item_list_t tmp15 = grouped_item_list_t_create(tmp14.len);
  int *tmp17 = (int *)malloc(sizeof(int) * tmp14.len);
  int tmp16 = 0;
  for (int gi = 0; gi < tmp14.len; gi++) {
    _GroupInt _gp = tmp14.data[gi];
    per_customer_item_list_t tmp18 =
        per_customer_item_list_t_create(_gp.items.len);
    for (int i19 = 0; i19 < _gp.items.len; i19++) {
      tmp18.data[i19] = tmp10.data[_gp.items.data[i19]];
    }
    tmp18.len = _gp.items.len;
    struct {
      int key;
      per_customer_item_list_t items;
    } g = {_gp.key, tmp18};
    tmp15.data[tmp16] =
        (grouped_item_t){.c_count = g.key, .custdist = g.items.len};
    tmp17[tmp16] = (-g.key);
    tmp16++;
  }
  tmp15.len = tmp16;
  for (int i22 = 0; i22 < tmp16 - 1; i22++) {
    for (int i23 = i22 + 1; i23 < tmp16; i23++) {
      if (tmp17[i22] > tmp17[i23]) {
        int tmp20 = tmp17[i22];
        tmp17[i22] = tmp17[i23];
        tmp17[i23] = tmp20;
        grouped_item_t tmp21 = tmp15.data[i22];
        tmp15.data[i22] = tmp15.data[i23];
        tmp15.data[i23] = tmp21;
      }
    }
  }
  grouped_item_list_t grouped = tmp15;
  printf("[");
  for (int i24 = 0; i24 < grouped.len; i24++) {
    if (i24 > 0)
      printf(",");
    grouped_item_t it = grouped.data[i24];
    printf("{");
    _json_string("c_count");
    printf(":");
    _json_int(it.c_count);
    printf(",");
    _json_string("custdist");
    printf(":");
    _json_int(it.custdist);
    printf("}");
  }
  printf("]");
  test_Q13_groups_customers_by_non_special_order_count_grouped = grouped;
  test_Q13_groups_customers_by_non_special_order_count();
  free(tmp4.data);
  free(per_customer.data);
  return 0;
}
