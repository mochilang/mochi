// Generated by Mochi compiler v0.10.25 on 2006-01-02T15:04:05Z
#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Lineitem {
    l_quantity: i32,
    l_extendedprice: f64,
    l_discount: f64,
    l_tax: f64,
    l_returnflag: &'static str,
    l_linestatus: &'static str,
    l_shipdate: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key {
    returnflag: &'static str,
    linestatus: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group {
    key: Key,
    items: Vec<Lineitem>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result {
    returnflag: &'static str,
    linestatus: &'static str,
    sum_qty: i32,
    sum_base_price: f64,
    sum_disc_price: f64,
    sum_charge: f64,
    avg_qty: f64,
    avg_price: f64,
    avg_disc: f64,
    count_order: i32,
}

fn avg<T>(v: &[T]) -> f64 where T: Into<f64> + Copy {
    let sum: f64 = v.iter().map(|&x| x.into()).sum();
    sum / v.len() as f64
}

fn sum<T>(v: &[T]) -> T where T: std::iter::Sum<T> + Copy {
    v.iter().copied().sum()
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let lineitem = vec![Lineitem { l_quantity: 17, l_extendedprice: 1000.0, l_discount: 0.05, l_tax: 0.07, l_returnflag: "N", l_linestatus: "O", l_shipdate: "1998-08-01" }, Lineitem { l_quantity: 36, l_extendedprice: 2000.0, l_discount: 0.1, l_tax: 0.05, l_returnflag: "N", l_linestatus: "O", l_shipdate: "1998-09-01" }, Lineitem { l_quantity: 25, l_extendedprice: 1500.0, l_discount: 0.0, l_tax: 0.08, l_returnflag: "R", l_linestatus: "F", l_shipdate: "1998-09-03" }];
    let result = { let mut tmp1 = std::collections::HashMap::new();for row in &lineitem { if !(row.l_shipdate <= "1998-09-02") { continue; } let key = Key { returnflag: row.l_returnflag, linestatus: row.l_linestatus }; tmp1.entry(key).or_insert_with(Vec::new).push(row.clone()); } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { returnflag: g.key.returnflag, linestatus: g.key.linestatus, sum_qty: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push(x.l_quantity); } tmp3 }), sum_base_price: sum(&{ let mut tmp4 = Vec::new();for x in &g.clone().items { tmp4.push(x.l_extendedprice); } tmp4 }), sum_disc_price: sum(&{ let mut tmp5 = Vec::new();for x in &g.clone().items { tmp5.push(x.l_extendedprice * ((1 as f64) - x.l_discount as f64)); } tmp5 }), sum_charge: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push(x.l_extendedprice * ((1 as f64) - x.l_discount as f64) * ((1 as f64) + x.l_tax)); } tmp6 }), avg_qty: avg(&{ let mut tmp7 = Vec::new();for x in &g.clone().items { tmp7.push(x.l_quantity); } tmp7 }), avg_price: avg(&{ let mut tmp8 = Vec::new();for x in &g.clone().items { tmp8.push(x.l_extendedprice); } tmp8 }), avg_disc: avg(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push(x.l_discount); } tmp9 }), count_order: g.clone().items.len() as i32 }); } result };
    _json(&result);
    assert!(result == vec![Result { returnflag: "N", linestatus: "O", sum_qty: 53, sum_base_price: 3000.0, sum_disc_price: 950.0 + 1800.0, sum_charge: (950.0 * 1.07) + (1800.0 * 1.05), avg_qty: 26.5, avg_price: 1500.0, avg_disc: 0.07500000000000001, count_order: 2 }]);
}
