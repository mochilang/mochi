// Generated by Mochi C++ compiler
#include <bits/stdc++.h>
using namespace std;

template <typename T> auto _min(const T &v) -> decltype(*std::begin(v)) {
  if (v.size() == 0)
    return {};
  auto it = std::begin(v);
  auto m = *it;
  ++it;
  for (; it != std::end(v); ++it)
    if (*it < m)
      m = *it;
  return m;
}
template <typename T>
auto _min(const T &v)
    -> decltype(v.Items, typename decltype(v.Items)::value_type{}) {
  return _min(v.Items);
}

static string _escape_json(const string &s) {
  string out;
  for (char c : s) {
    if (c == '"' || c == '\\')
      out += '\\';
    out += c;
  }
  return out;
}
template <typename T> string _to_json(const T &v);
inline string _to_json(const string &s) {
  string out = "\"";
  out += _escape_json(s);
  out += "\"";
  return out;
}
inline string _to_json(const char *s) { return _to_json(string(s)); }
inline string _to_json(int v) { return to_string(v); }
inline string _to_json(double v) {
  stringstream ss;
  ss << v;
  return ss.str();
}
inline string _to_json(bool v) { return v ? "true" : "false"; }
inline string _to_json(const any &v) {
  if (v.type() == typeid(int))
    return _to_json(any_cast<int>(v));
  if (v.type() == typeid(double))
    return _to_json(any_cast<double>(v));
  if (v.type() == typeid(bool))
    return _to_json(any_cast<bool>(v));
  if (v.type() == typeid(string))
    return _to_json(any_cast<string>(v));
  return "null";
}
template <typename T> string _to_json(const vector<T> &v) {
  string out = "[";
  for (size_t i = 0; i < v.size(); i++) {
    if (i > 0)
      out += ',';
    out += _to_json(v[i]);
  }
  out += ']';
  return out;
}
template <typename K, typename V>
string _to_json(const unordered_map<K, V> &m) {
  string out = "{";
  bool first = true;
  for (const auto &kv : m) {
    if (!first)
      out += ',';
    first = false;
    out += _to_json(kv.first);
    out += ':';
    out += _to_json(kv.second);
  }
  out += '}';
  return out;
}
template <typename T> string _to_json(const T &v) {
  stringstream ss;
  ss << v;
  return _to_json(ss.str());
}
template <typename T> void _json(const T &v) { cout << _to_json(v) << endl; }

int main() {
  vector<unordered_map<string, any>> region =
      vector<unordered_map<string, any>>{
          unordered_map<string, any>{{string("r_regionkey"), any(1)},
                                     {string("r_name"), any(string("EUROPE"))}},
          unordered_map<string, any>{{string("r_regionkey"), any(2)},
                                     {string("r_name"), any(string("ASIA"))}}};
  vector<unordered_map<string, any>> nation =
      vector<unordered_map<string, any>>{
          unordered_map<string, any>{{string("n_nationkey"), any(10)},
                                     {string("n_regionkey"), any(1)},
                                     {string("n_name"), any(string("FRANCE"))}},
          unordered_map<string, any>{{string("n_nationkey"), any(20)},
                                     {string("n_regionkey"), any(2)},
                                     {string("n_name"), any(string("CHINA"))}}};
  vector<unordered_map<string, any>> supplier =
      vector<unordered_map<string, any>>{
          unordered_map<string, any>{
              {string("s_suppkey"), any(100)},
              {string("s_name"), any(string("BestSupplier"))},
              {string("s_address"), any(string("123 Rue"))},
              {string("s_nationkey"), any(10)},
              {string("s_phone"), any(string("123"))},
              {string("s_acctbal"), any(1000.0)},
              {string("s_comment"), any(string("Fast and reliable"))}},
          unordered_map<string, any>{
              {string("s_suppkey"), any(200)},
              {string("s_name"), any(string("AltSupplier"))},
              {string("s_address"), any(string("456 Way"))},
              {string("s_nationkey"), any(20)},
              {string("s_phone"), any(string("456"))},
              {string("s_acctbal"), any(500.0)},
              {string("s_comment"), any(string("Slow"))}}};
  vector<unordered_map<string, any>> part = vector<unordered_map<string, any>>{
      unordered_map<string, any>{{string("p_partkey"), any(1000)},
                                 {string("p_type"), any(string("LARGE BRASS"))},
                                 {string("p_size"), any(15)},
                                 {string("p_mfgr"), any(string("M1"))}},
      unordered_map<string, any>{
          {string("p_partkey"), any(2000)},
          {string("p_type"), any(string("SMALL COPPER"))},
          {string("p_size"), any(15)},
          {string("p_mfgr"), any(string("M2"))}}};
  vector<unordered_map<string, any>> partsupp =
      vector<unordered_map<string, any>>{
          unordered_map<string, any>{{string("ps_partkey"), any(1000)},
                                     {string("ps_suppkey"), any(100)},
                                     {string("ps_supplycost"), any(10.0)}},
          unordered_map<string, any>{{string("ps_partkey"), any(1000)},
                                     {string("ps_suppkey"), any(200)},
                                     {string("ps_supplycost"), any(15.0)}}};
  auto europe_nations = ([&]() -> vector<any> {
    vector<any> _res;
    for (auto &r : region) {
      for (auto &n : nation) {
        if (!(n.n_regionkey == r.r_regionkey))
          continue;
        if (r.r_name == string("EUROPE")) {
          _res.push_back(any(n));
        }
      }
    }
    return _res;
  })();
  auto europe_suppliers = ([&]() -> vector<unordered_map<string, any>> {
    vector<unordered_map<string, any>> _res;
    for (auto &s : supplier) {
      for (auto &n : europe_nations) {
        if (!(s.s_nationkey == n.n_nationkey))
          continue;
        _res.push_back(unordered_map<string, any>{{string("s"), any(s)},
                                                  {string("n"), any(n)}});
      }
    }
    return _res;
  })();
  auto target_parts = ([&]() -> vector<any> {
    vector<any> _res;
    for (auto &p : part) {
      if (p.p_size == 15 && p.p_type == string("LARGE BRASS")) {
        _res.push_back(any(p));
      }
    }
    return _res;
  })();
  auto target_partsupp = ([&]() -> vector<unordered_map<string, any>> {
    vector<unordered_map<string, any>> _res;
    for (auto &ps : partsupp) {
      for (auto &p : target_parts) {
        if (!(ps.ps_partkey == p.p_partkey))
          continue;
        for (auto &s : europe_suppliers) {
          if (!(ps.ps_suppkey == s.s.s_suppkey))
            continue;
          _res.push_back(unordered_map<string, any>{
              {string("s_acctbal"), any(s.s.s_acctbal)},
              {string("s_name"), any(s.s.s_name)},
              {string("n_name"), any(s.n.n_name)},
              {string("p_partkey"), any(p.p_partkey)},
              {string("p_mfgr"), any(p.p_mfgr)},
              {string("s_address"), any(s.s.s_address)},
              {string("s_phone"), any(s.s.s_phone)},
              {string("s_comment"), any(s.s.s_comment)},
              {string("ps_supplycost"), any(ps.ps_supplycost)}});
        }
      }
    }
    return _res;
  })();
  auto costs = ([&]() -> vector<any> {
    vector<any> _res;
    for (auto &x : target_partsupp) {
      _res.push_back(any(x.ps_supplycost));
    }
    return _res;
  })();
  auto min_cost = _min(costs);
  auto result = ([&]() -> vector<any> {
    vector<pair<any, any>> _tmp;
    for (auto &x : target_partsupp) {
      if (x.ps_supplycost == min_cost) {
        _tmp.push_back({-x.s_acctbal, any(x)});
      }
    }
    std::sort(_tmp.begin(), _tmp.end(),
              [](const auto &a, const auto &b) { return a.first < b.first; });
    vector<any> _res;
    _res.reserve(_tmp.size());
    for (auto &_it : _tmp)
      _res.push_back(_it.second);
    return _res;
  })();
  _json(result);
  auto test_Q2_returns_only_supplier_with_min_cost_in_Europe_for_brass_part =
      [&]() {
        if (!(result ==
              vector<unordered_map<string, any>>{unordered_map<string, any>{
                  {string("s_acctbal"), any(1000.0)},
                  {string("s_name"), any(string("BestSupplier"))},
                  {string("n_name"), any(string("FRANCE"))},
                  {string("p_partkey"), any(1000)},
                  {string("p_mfgr"), any(string("M1"))},
                  {string("s_address"), any(string("123 Rue"))},
                  {string("s_phone"), any(string("123"))},
                  {string("s_comment"), any(string("Fast and reliable"))},
                  {string("ps_supplycost"), any(10.0)}}})) {
          std::cerr << "expect failed\n";
          exit(1);
        }
      };
  test_Q2_returns_only_supplier_with_min_cost_in_Europe_for_brass_part();
  return 0;
}
