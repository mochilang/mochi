/tmp/q7.scala:24: error: not found: value supp_nation
    val result = (((for { l: Lineitem <- lineitem; o: Order <- orders; if (o.o_orderkey).asInstanceOf[Int] == l.l_orderkey; c: Customer <- customer; if (c.c_custkey).asInstanceOf[Int] == o.o_custkey; s: Supplier <- supplier; if (s.s_suppkey).asInstanceOf[Int] == l.l_suppkey; n1: Nation <- nation; if (n1.n_nationkey).asInstanceOf[Int] == s.s_nationkey; n2: Nation <- nation; if (n2.n_nationkey).asInstanceOf[Int] == c.c_nationkey; if (l.l_shipdate >= start_date && l.l_shipdate <= end_date && (n1.n_name == nation1 && n2.n_name == nation2) || (n1.n_name == nation2 && n2.n_name == nation1)) } yield (G(supp_nation = n1.n_name, cust_nation = n2.n_name, l_year = l.l_shipdate.substring(0, 4)), Result(l = l, o = o, c = c, s = s, n1 = n1, n2 = n2))).groupBy(_._1).map{ case(k,list) => _Group(k, list.map(_._2)) }.toList).sortBy(g => List(supp_nation, cust_nation, l_year))).map{ g => Map("supp_nation" -> g.key("supp_nation"), "cust_nation" -> g.key("cust_nation"), "l_year" -> g.key("l_year"), "revenue" -> (for { x: Result <- g } yield x.l.l_extendedprice * (1 - x.l.l_discount)).sum) }.toList
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
/tmp/q7.scala:24: error: not found: value cust_nation
    val result = (((for { l: Lineitem <- lineitem; o: Order <- orders; if (o.o_orderkey).asInstanceOf[Int] == l.l_orderkey; c: Customer <- customer; if (c.c_custkey).asInstanceOf[Int] == o.o_custkey; s: Supplier <- supplier; if (s.s_suppkey).asInstanceOf[Int] == l.l_suppkey; n1: Nation <- nation; if (n1.n_nationkey).asInstanceOf[Int] == s.s_nationkey; n2: Nation <- nation; if (n2.n_nationkey).asInstanceOf[Int] == c.c_nationkey; if (l.l_shipdate >= start_date && l.l_shipdate <= end_date && (n1.n_name == nation1 && n2.n_name == nation2) || (n1.n_name == nation2 && n2.n_name == nation1)) } yield (G(supp_nation = n1.n_name, cust_nation = n2.n_name, l_year = l.l_shipdate.substring(0, 4)), Result(l = l, o = o, c = c, s = s, n1 = n1, n2 = n2))).groupBy(_._1).map{ case(k,list) => _Group(k, list.map(_._2)) }.toList).sortBy(g => List(supp_nation, cust_nation, l_year))).map{ g => Map("supp_nation" -> g.key("supp_nation"), "cust_nation" -> g.key("cust_nation"), "l_year" -> g.key("l_year"), "revenue" -> (for { x: Result <- g } yield x.l.l_extendedprice * (1 - x.l.l_discount)).sum) }.toList
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
/tmp/q7.scala:24: error: not found: value l_year
    val result = (((for { l: Lineitem <- lineitem; o: Order <- orders; if (o.o_orderkey).asInstanceOf[Int] == l.l_orderkey; c: Customer <- customer; if (c.c_custkey).asInstanceOf[Int] == o.o_custkey; s: Supplier <- supplier; if (s.s_suppkey).asInstanceOf[Int] == l.l_suppkey; n1: Nation <- nation; if (n1.n_nationkey).asInstanceOf[Int] == s.s_nationkey; n2: Nation <- nation; if (n2.n_nationkey).asInstanceOf[Int] == c.c_nationkey; if (l.l_shipdate >= start_date && l.l_shipdate <= end_date && (n1.n_name == nation1 && n2.n_name == nation2) || (n1.n_name == nation2 && n2.n_name == nation1)) } yield (G(supp_nation = n1.n_name, cust_nation = n2.n_name, l_year = l.l_shipdate.substring(0, 4)), Result(l = l, o = o, c = c, s = s, n1 = n1, n2 = n2))).groupBy(_._1).map{ case(k,list) => _Group(k, list.map(_._2)) }.toList).sortBy(g => List(supp_nation, cust_nation, l_year))).map{ g => Map("supp_nation" -> g.key("supp_nation"), "cust_nation" -> g.key("cust_nation"), "l_year" -> g.key("l_year"), "revenue" -> (for { x: Result <- g } yield x.l.l_extendedprice * (1 - x.l.l_discount)).sum) }.toList
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ^
three errors found
