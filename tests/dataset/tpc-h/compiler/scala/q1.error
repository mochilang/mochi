/tmp/q1.scala:12: error: q1.G does not take parameters
    val result = ((for { row: Lineitem <- lineitem; if row.l_shipdate <= "1998-09-02" } yield (G(returnflag = row.l_returnflag, linestatus = row.l_linestatus), row)).groupBy(_._1).map{ case(k,list) => _Group(k, list.map(_._2)) }.toList).map{ g => Map("returnflag" -> g.key("returnflag"), "linestatus" -> g.key("linestatus"), "sum_qty" -> (for { x: Lineitem <- g } yield x.l_quantity).sum, "sum_base_price" -> (for { x: Lineitem <- g } yield x.l_extendedprice).sum, "sum_disc_price" -> (for { x: Lineitem <- g } yield x.l_extendedprice * (1 - x.l_discount)).sum, "sum_charge" -> (for { x: Lineitem <- g } yield x.l_extendedprice * (1 - x.l_discount) * (1 + x.l_tax)).sum, "avg_qty" -> (for { x: Lineitem <- g } yield x.l_quantity).sum.toDouble / (for { x: Lineitem <- g } yield x.l_quantity).size, "avg_price" -> (for { x: Lineitem <- g } yield x.l_extendedprice).sum.toDouble / (for { x: Lineitem <- g } yield x.l_extendedprice).size, "avg_disc" -> (for { x: Lineitem <- g } yield x.l_discount).sum.toDouble / (for { x: Lineitem <- g } yield x.l_discount).size, "count_order" -> (g).size) }.toList
                                                                                                                                                                                                                                                                                ^
/tmp/q1.scala:12: error: q1.G does not take parameters
    val result = ((for { row: Lineitem <- lineitem; if row.l_shipdate <= "1998-09-02" } yield (G(returnflag = row.l_returnflag, linestatus = row.l_linestatus), row)).groupBy(_._1).map{ case(k,list) => _Group(k, list.map(_._2)) }.toList).map{ g => Map("returnflag" -> g.key("returnflag"), "linestatus" -> g.key("linestatus"), "sum_qty" -> (for { x: Lineitem <- g } yield x.l_quantity).sum, "sum_base_price" -> (for { x: Lineitem <- g } yield x.l_extendedprice).sum, "sum_disc_price" -> (for { x: Lineitem <- g } yield x.l_extendedprice * (1 - x.l_discount)).sum, "sum_charge" -> (for { x: Lineitem <- g } yield x.l_extendedprice * (1 - x.l_discount) * (1 + x.l_tax)).sum, "avg_qty" -> (for { x: Lineitem <- g } yield x.l_quantity).sum.toDouble / (for { x: Lineitem <- g } yield x.l_quantity).size, "avg_price" -> (for { x: Lineitem <- g } yield x.l_extendedprice).sum.toDouble / (for { x: Lineitem <- g } yield x.l_extendedprice).size, "avg_disc" -> (for { x: Lineitem <- g } yield x.l_discount).sum.toDouble / (for { x: Lineitem <- g } yield x.l_discount).size, "count_order" -> (g).size) }.toList
                                                                                                                                                                                                                                                                                                                     ^
two errors found
