//go:build ignore

// Generated by Mochi compiler v0.10.25 on 2025-07-13T18:09:25Z

package main

import (
	"encoding/json"
	"fmt"
	"slices"
	"time"

	"golang.org/x/exp/constraints"
)

func expect(cond bool) {
	if !cond {
		panic("expect failed")
	}
}

func formatDuration(d time.Duration) string {
	switch {
	case d < time.Microsecond:
		return fmt.Sprintf("%dns", d.Nanoseconds())
	case d < time.Millisecond:
		return fmt.Sprintf("%.1fÂµs", float64(d.Microseconds()))
	case d < time.Second:
		return fmt.Sprintf("%.1fms", float64(d.Milliseconds()))
	default:
		return fmt.Sprintf("%.2fs", d.Seconds())
	}
}

func printTestStart(name string) {
	fmt.Printf("   test %-30s ...", name)
}

func printTestPass(d time.Duration) {
	fmt.Printf(" ok (%s)\n", formatDuration(d))
}

func printTestFail(err error, d time.Duration) {
	fmt.Printf(" fail %v (%s)\n", err, formatDuration(d))
}

func test_Q19_returns_total_revenue_from_qualifying_branded_parts() {
	expect((result == 2800.0))
}

var part []PartItem
var lineitem []LineitemItem
var revenues []float64
var result float64

func main() {
	part = _convSlice[v, PartItem]([]PartItem{PartItem{
		1,
		"Brand#12",
		"SM BOX",
		3,
	}, PartItem{
		2,
		"Brand#23",
		"MED BOX",
		5,
	}, PartItem{
		3,
		"Brand#34",
		"LG BOX",
		15,
	}})
	lineitem = _convSlice[v, LineitemItem]([]LineitemItem{LineitemItem{
		1,
		5,
		1000.0,
		0.1,
		"AIR",
		"DELIVER IN PERSON",
	}, LineitemItem{
		2,
		15,
		2000.0,
		0.05,
		"AIR REG",
		"DELIVER IN PERSON",
	}, LineitemItem{
		3,
		35,
		1500.0,
		0.0,
		"AIR",
		"DELIVER IN PERSON",
	}})
	revenues = func() []float64 {
		results := []float64{}
		for _, l := range lineitem {
			for _, p := range part {
				if !(p.P_partkey == l.L_partkey) {
					continue
				}
				if (((((((p.P_brand == "Brand#12") && (slices.Contains([]string{
					"SM CASE",
					"SM BOX",
					"SM PACK",
					"SM PKG",
				}, p.P_container))) && ((l.L_quantity >= 1) && (l.L_quantity <= 11))) && ((p.P_size >= 1) && (p.P_size <= 5))) || ((((p.P_brand == "Brand#23") && (slices.Contains([]string{
					"MED BAG",
					"MED BOX",
					"MED PKG",
					"MED PACK",
				}, p.P_container))) && ((l.L_quantity >= 10) && (l.L_quantity <= 20))) && ((p.P_size >= 1) && (p.P_size <= 10)))) || ((((p.P_brand == "Brand#34") && (slices.Contains([]string{
					"LG CASE",
					"LG BOX",
					"LG PACK",
					"LG PKG",
				}, p.P_container))) && ((l.L_quantity >= 20) && (l.L_quantity <= 30))) && ((p.P_size >= 1) && (p.P_size <= 15)))) && slices.Contains([]string{"AIR", "AIR REG"}, l.L_shipmode)) && (l.L_shipinstruct == "DELIVER IN PERSON") {
					if (((((((p.P_brand == "Brand#12") && (slices.Contains([]string{
						"SM CASE",
						"SM BOX",
						"SM PACK",
						"SM PKG",
					}, p.P_container))) && ((l.L_quantity >= 1) && (l.L_quantity <= 11))) && ((p.P_size >= 1) && (p.P_size <= 5))) || ((((p.P_brand == "Brand#23") && (slices.Contains([]string{
						"MED BAG",
						"MED BOX",
						"MED PKG",
						"MED PACK",
					}, p.P_container))) && ((l.L_quantity >= 10) && (l.L_quantity <= 20))) && ((p.P_size >= 1) && (p.P_size <= 10)))) || ((((p.P_brand == "Brand#34") && (slices.Contains([]string{
						"LG CASE",
						"LG BOX",
						"LG PACK",
						"LG PKG",
					}, p.P_container))) && ((l.L_quantity >= 20) && (l.L_quantity <= 30))) && ((p.P_size >= 1) && (p.P_size <= 15)))) && slices.Contains([]string{"AIR", "AIR REG"}, l.L_shipmode)) && (l.L_shipinstruct == "DELIVER IN PERSON") {
						results = append(results, (l.L_extendedprice * (float64(1) - l.L_discount)))
					}
				}
			}
		}
		return results
	}()
	result = _sumOrdered[float64](revenues)
	func() { b, _ := json.Marshal(result); fmt.Println(string(b)) }()
	test_Q19_returns_total_revenue_from_qualifying_branded_parts()
}

func _convSlice[T any, U any](s []T) []U {
	out := make([]U, len(s))
	for i, v := range s {
		out[i] = any(v).(U)
	}
	return out
}

func _sumOrdered[T constraints.Integer | constraints.Float](s []T) float64 {
	var sum float64
	for _, v := range s {
		sum += float64(v)
	}
	return sum
}
