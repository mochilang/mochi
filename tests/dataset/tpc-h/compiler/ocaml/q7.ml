(* Generated by Mochi compiler v0.10.25 on 2025-07-13T17:51:26Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable n_nationkey : int; mutable n_name : string }
type record2 = { mutable s_suppkey : int; mutable s_nationkey : int }
type record3 = { mutable c_custkey : int; mutable c_nationkey : int }
type record4 = { mutable o_orderkey : int; mutable o_custkey : int }
type record5 = { mutable l_orderkey : int; mutable l_suppkey : int; mutable l_extendedprice : float; mutable l_discount : float; mutable l_shipdate : string }
type record6 = { mutable supp_nation : string; mutable cust_nation : string; mutable l_year : string }
type record7 = { mutable supp_nation : Obj.t; mutable cust_nation : Obj.t; mutable l_year : Obj.t; mutable revenue : float }
type record8 = { mutable supp_nation : string; mutable cust_nation : string; mutable l_year : string; mutable revenue : float }

let nation : record1 list = [{ n_nationkey = 1; n_name = "FRANCE" };{ n_nationkey = 2; n_name = "GERMANY" }]
let supplier : record2 list = [{ s_suppkey = 100; s_nationkey = 1 }]
let customer : record3 list = [{ c_custkey = 200; c_nationkey = 2 }]
let orders : record4 list = [{ o_orderkey = 1000; o_custkey = 200 }]
let lineitem : record5 list = [{ l_orderkey = 1000; l_suppkey = 100; l_extendedprice = 1000.; l_discount = 0.1; l_shipdate = "1995-06-15" };{ l_orderkey = 1000; l_suppkey = 100; l_extendedprice = 800.; l_discount = 0.05; l_shipdate = "1997-01-01" }]
let start_date : string = "1995-01-01"
let end_date : string = "1996-12-31"
let nation1 : string = "FRANCE"
let nation2 : string = "GERMANY"
let result : record8 list = (let (__groups0 : (record6 * record5 list) list ref) = ref [] in
  List.iter (fun (l : record5) ->
      List.iter (fun (o : record4) ->
            List.iter (fun (c : record3) ->
                    List.iter (fun (s : record2) ->
                              List.iter (fun (n1 : record1) ->
                                          List.iter (fun (n2 : record1) ->
                                                                  if (o.o_orderkey = l.l_orderkey) && (c.c_custkey = o.o_custkey) && (s.s_suppkey = l.l_suppkey) && (n1.n_nationkey = s.s_nationkey) && (n2.n_nationkey = c.c_nationkey) && (((((l.l_shipdate >= start_date) && (l.l_shipdate <= end_date)) && (((n1.n_name = nation1) && (n2.n_name = nation2)))) || (((n1.n_name = nation2) && (n2.n_name = nation1))))) then (
                let (key : record6) = { supp_nation = n1.n_name; cust_nation = n2.n_name; l_year = String.sub l.l_shipdate 0 (4 - 0) } in
                let cur = try List.assoc key !__groups0 with Not_found -> [] in
                __groups0 := (key, l :: cur) :: List.remove_assoc key !__groups0);
                                          ) nation;
                              ) nation;
                    ) supplier;
            ) customer;
      ) orders;
  ) lineitem;
  let __res0 = ref [] in
  List.iter (fun ((gKey : record6), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { supp_nation = g.key.supp_nation; cust_nation = g.key.cust_nation; l_year = g.key.l_year; revenue = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := (x.l.l_extendedprice * ((1 - x.l.l_discount))) :: !__res1;
  ) g.items;
List.rev !__res1)
) } :: !__res0
  ) !__groups0;
  List.rev !__res0)


let () =
  json result;
  assert ((result = [{ supp_nation = "FRANCE"; cust_nation = "GERMANY"; l_year = "1995"; revenue = 900. }]))
