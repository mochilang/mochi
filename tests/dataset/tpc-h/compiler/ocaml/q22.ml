(* Generated by Mochi compiler v0.10.25 on 2025-07-13T17:51:26Z *)
  exception Break
  exception Continue

  let sum lst = List.fold_left (+) 0 lst
  let sum_float lst = List.fold_left (+.) 0.0 lst
  type ('k,'v) group = { key : 'k; items : 'v list }

  type record1 = { mutable c_custkey : int; mutable c_phone : string; mutable c_acctbal : float }
  type record2 = { mutable o_orderkey : int; mutable o_custkey : int }
  type record3 = { mutable cntrycode : string; mutable c_acctbal : float }
  type record4 = { mutable cntrycode : string; mutable numcust : int; mutable totacctbal : Obj.t }
  type record5 = { mutable cntrycode : string; mutable numcust : int; mutable totacctbal : float }

let customer : record1 list = [{ c_custkey = 1; c_phone = "13-123-4567"; c_acctbal = 600. };{ c_custkey = 2; c_phone = "31-456-7890"; c_acctbal = 100. };{ c_custkey = 3; c_phone = "30-000-0000"; c_acctbal = 700. }]
let orders : record2 list = [{ o_orderkey = 10; o_custkey = 2 }]
let valid_codes : string list = ["13";"31";"23";"29";"30";"18";"17"]
let avg_balance : float = (float_of_int (List.fold_left (+) 0 (let __res0 = ref [] in
  List.iter (fun (c : record1) ->
      if (List.mem ((c.c_acctbal > 0.) && String.sub c.c_phone 0 (2 - 0)) valid_codes) then
    __res0 := c.c_acctbal :: !__res0;
  ) customer;
List.rev !__res0)
) /. float_of_int (List.length (let __res0 = ref [] in
  List.iter (fun (c : record1) ->
      if (List.mem ((c.c_acctbal > 0.) && String.sub c.c_phone 0 (2 - 0)) valid_codes) then
    __res0 := c.c_acctbal :: !__res0;
  ) customer;
List.rev !__res0)
))
let eligible_customers : record3 list = (let __res2 = ref [] in
  List.iter (fun (c : record1) ->
      if (((List.mem String.sub c.c_phone 0 (2 - 0) valid_codes) && (c.c_acctbal > avg_balance)) && (not (((let __res1 = ref [] in
  List.iter (fun (o : record2) ->
      if (o.o_custkey = c.c_custkey) then
    __res1 := o :: !__res1;
  ) orders;
List.rev !__res1)
 <> [])))) then
    __res2 := { cntrycode = String.sub c.c_phone 0 (2 - 0); c_acctbal = c.c_acctbal } :: !__res2;
  ) customer;
List.rev !__res2)

let groups : (string,(string * Obj.t) list) group list = (let (__groups3 : (string * record3 list) list ref) = ref [] in
  List.iter (fun (c : record3) ->
      let (key : string) = c.cntrycode in
      let cur = try List.assoc key !__groups3 with Not_found -> [] in
      __groups3 := (key, c :: cur) :: List.remove_assoc key !__groups3;
  ) eligible_customers;
  let __res3 = ref [] in
  List.iter (fun ((gKey : string), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res3 := g :: !__res3
  ) !__groups3;
  List.rev !__res3)

let tmp : Obj.t list ref = ref []
let result : Obj.t list = (let __res4 = ref [] in
  List.iter (fun r ->
      __res4 := r :: !__res4;
  ) (!tmp);
List.rev !__res4)


let () =
  let rec __loop5 lst =
    match lst with
      | [] -> ()
      | g::rest ->
        (try
          let total : float = (sum_float (let __res6 = ref [] in
  List.iter (fun x ->
      __res6 := Obj.obj (List.assoc "c_acctbal" x) :: !__res6;
  ) g.items;
List.rev !__res6)
) in
          let row : record4 = { cntrycode = g.key; numcust = List.length g.items; totacctbal = total } in
          tmp := ((!tmp) @ [row]);
        with Continue -> ())
        ; __loop5 rest
    in
    try __loop5 groups with Break -> ()
    json result;
    assert ((result = [{ cntrycode = "13"; numcust = 1; totacctbal = 600. };{ cntrycode = "30"; numcust = 1; totacctbal = 700. }]))
