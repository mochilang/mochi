(* Generated by Mochi compiler v0.10.25 on 2025-07-13T06:04:36Z *)
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable o_orderkey : int; mutable o_orderdate : string; mutable o_orderpriority : string }
type record2 = { mutable l_orderkey : int; mutable l_commitdate : string; mutable l_receiptdate : string }
type record3 = { mutable o_orderpriority : Obj.t; mutable order_count : int }
type record4 = { mutable o_orderpriority : string; mutable order_count : int }

let orders : record1 list = [{ o_orderkey = 1; o_orderdate = "1993-07-01"; o_orderpriority = "1-URGENT" };{ o_orderkey = 2; o_orderdate = "1993-07-15"; o_orderpriority = "2-HIGH" };{ o_orderkey = 3; o_orderdate = "1993-08-01"; o_orderpriority = "3-NORMAL" }]
let lineitem : record2 list = [{ l_orderkey = 1; l_commitdate = "1993-07-10"; l_receiptdate = "1993-07-12" };{ l_orderkey = 1; l_commitdate = "1993-07-12"; l_receiptdate = "1993-07-10" };{ l_orderkey = 2; l_commitdate = "1993-07-20"; l_receiptdate = "1993-07-25" };{ l_orderkey = 3; l_commitdate = "1993-08-02"; l_receiptdate = "1993-08-01" };{ l_orderkey = 3; l_commitdate = "1993-08-05"; l_receiptdate = "1993-08-10" }]
let start_date : string = "1993-07-01"
let end_date : string = "1993-08-01"
let date_filtered_orders : record1 list = (let __res0 = ref [] in
  List.iter (fun (o : record1) ->
      if (((o.o_orderdate >= start_date) && o.o_orderdate) < end_date) then
    __res0 := o :: !__res0;
  ) orders;
List.rev !__res0)

let late_orders : record1 list = (let __res2 = ref [] in
  List.iter (fun (o : record1) ->
      if ((let __res1 = ref [] in
  List.iter (fun (l : record2) ->
      if (((l.l_orderkey = o.o_orderkey) && l.l_commitdate) < l.l_receiptdate) then
    __res1 := l :: !__res1;
  ) lineitem;
List.rev !__res1)
 <> []) then
    __res2 := o :: !__res2;
  ) date_filtered_orders;
List.rev !__res2)

let result : record4 list = (let (__groups3 : (string * record1 list) list ref) = ref [] in
  List.iter (fun (o : record1) ->
      let (key : string) = o.o_orderpriority in
      let cur = try List.assoc key !__groups3 with Not_found -> [] in
      __groups3 := (key, o :: cur) :: List.remove_assoc key !__groups3;
  ) late_orders;
  let __res3 = ref [] in
  List.iter (fun ((gKey : string), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res3 := { o_orderpriority = g.key; order_count = List.length g.items } :: !__res3
  ) !__groups3;
  List.rev !__res3)


let () =
  json result;
  assert ((result = [{ o_orderpriority = "1-URGENT"; order_count = 1 };{ o_orderpriority = "2-HIGH"; order_count = 1 }]))
