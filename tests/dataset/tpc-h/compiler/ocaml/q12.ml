(* Generated by Mochi compiler v0.10.25 on 2025-07-13T17:51:26Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable o_orderkey : int; mutable o_orderpriority : string }
type record2 = { mutable l_orderkey : int; mutable l_shipmode : string; mutable l_commitdate : string; mutable l_receiptdate : string; mutable l_shipdate : string }
type record3 = { mutable l_shipmode : Obj.t; mutable high_line_count : float; mutable low_line_count : float }
type record4 = { mutable l_shipmode : string; mutable high_line_count : float; mutable low_line_count : float }
type record5 = { mutable l_shipmode : string; mutable high_line_count : int; mutable low_line_count : int }

let orders : record1 list = [{ o_orderkey = 1; o_orderpriority = "1-URGENT" };{ o_orderkey = 2; o_orderpriority = "3-MEDIUM" }]
let lineitem : record2 list = [{ l_orderkey = 1; l_shipmode = "MAIL"; l_commitdate = "1994-02-10"; l_receiptdate = "1994-02-15"; l_shipdate = "1994-02-05" };{ l_orderkey = 2; l_shipmode = "SHIP"; l_commitdate = "1994-03-01"; l_receiptdate = "1994-02-28"; l_shipdate = "1994-02-27" }]
let result : record4 list = (let (__groups0 : (string * record2 list) list ref) = ref [] in
  List.iter (fun (l : record2) ->
      List.iter (fun (o : record1) ->
              if (o.o_orderkey = l.l_orderkey) && ((((((List.mem l.l_shipmode ["MAIL";"SHIP"])) && ((l.l_commitdate < l.l_receiptdate))) && ((l.l_shipdate < l.l_commitdate))) && ((l.l_receiptdate >= "1994-01-01"))) && ((l.l_receiptdate < "1995-01-01"))) then (
        let (key : string) = l.l_shipmode in
        let cur = try List.assoc key !__groups0 with Not_found -> [] in
        __groups0 := (key, l :: cur) :: List.remove_assoc key !__groups0);
      ) orders;
  ) lineitem;
  let __res0 = ref [] in
  List.iter (fun ((gKey : string), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { l_shipmode = g.key; high_line_count = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := (if (List.mem x.o.o_orderpriority ["1-URGENT";"2-HIGH"]) then 1 else 0) :: !__res1;
  ) g.items;
List.rev !__res1)
); low_line_count = (sum_float (let __res2 = ref [] in
  List.iter (fun x ->
      __res2 := (if not (((List.mem x.o.o_orderpriority ["1-URGENT";"2-HIGH"]))) then 1 else 0) :: !__res2;
  ) g.items;
List.rev !__res2)
) } :: !__res0
  ) !__groups0;
  List.rev !__res0)


let () =
  json result;
  assert ((result = [{ l_shipmode = "MAIL"; high_line_count = 1; low_line_count = 0 }]))
