(* Generated by Mochi compiler v0.10.28 on 2025-07-18T03:21:55Z *)
type ('k,'v) group = { key : 'k; items : 'v list }
let rec __to_json v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
     let hd = field o 0 in
     let tl = field o 1 in
     let rest = list_aux tl in
     let cur = __to_json (obj hd) in
     if rest = "" then cur else cur ^ "," ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
    | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
    | 252 -> Printf.sprintf "%S" (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "null"

let _json v = print_endline (__to_json v)


type record1 = { mutable n_nationkey : int; mutable n_name : string }
type record2 = { mutable s_suppkey : int; mutable s_name : string; mutable s_nationkey : int }
type record3 = { mutable o_orderkey : int; mutable o_orderstatus : string }
type record4 = { mutable l_orderkey : int; mutable l_suppkey : int; mutable l_receiptdate : string; mutable l_commitdate : string }
type record5 = { mutable s_name : Obj.t; mutable numwait : int }
type record6 = { mutable s_name : string; mutable numwait : int }

let nation : record1 list = [{ n_nationkey = 1; n_name = "SAUDI ARABIA" };{ n_nationkey = 2; n_name = "FRANCE" }]
let supplier : record2 list = [{ s_suppkey = 100; s_name = "Desert Trade"; s_nationkey = 1 };{ s_suppkey = 200; s_name = "Euro Goods"; s_nationkey = 2 }]
let orders : record3 list = [{ o_orderkey = 500; o_orderstatus = "F" };{ o_orderkey = 600; o_orderstatus = "O" }]
let lineitem : record4 list = [{ l_orderkey = 500; l_suppkey = 100; l_receiptdate = "1995-04-15"; l_commitdate = "1995-04-10" };{ l_orderkey = 500; l_suppkey = 200; l_receiptdate = "1995-04-12"; l_commitdate = "1995-04-12" };{ l_orderkey = 600; l_suppkey = 100; l_receiptdate = "1995-05-01"; l_commitdate = "1995-04-25" }]
let result : record6 list = (let (__groups1 : (string * record2 list) list ref) = ref [] in
  List.iter (fun (s : record2) ->
      List.iter (fun (l1 : record4) ->
            List.iter (fun (o : record3) ->
                    List.iter (fun (n : record1) ->
                                    if (s.s_suppkey = l1.l_suppkey) && (o.o_orderkey = l1.l_orderkey) && (n.n_nationkey = s.s_nationkey) && ((((o.o_orderstatus = "F") && (l1.l_receiptdate > l1.l_commitdate)) && (n.n_name = "SAUDI ARABIA")) && (not (((let __res0 = ref [] in
  List.iter (fun (x : record4) ->
      if (((x.l_orderkey = l1.l_orderkey) && (x.l_suppkey <> l1.l_suppkey)) && (x.l_receiptdate > x.l_commitdate)) then
    __res0 := x :: !__res0;
  ) lineitem;
List.rev !__res0)
 <> [])))) then (
            let (key : string) = s.s_name in
            let cur = try List.assoc key !__groups1 with Not_found -> [] in
            __groups1 := (key, s :: cur) :: List.remove_assoc key !__groups1);
                    ) nation;
            ) orders;
      ) lineitem;
  ) supplier;
  let __res1 = ref [] in
  List.iter (fun ((gKey : string), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res1 := { s_name = g.key; numwait = List.length g.items } :: !__res1
  ) !__groups1;
  List.rev !__res1)


let () =
  _json result;
  assert ((result = [{ s_name = "Desert Trade"; numwait = 1 }]))
