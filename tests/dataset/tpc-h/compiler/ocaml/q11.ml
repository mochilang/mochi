(* Generated by Mochi compiler v0.10.25 on 2025-07-13T17:51:26Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable n_nationkey : int; mutable n_name : string }
type record2 = { mutable s_suppkey : int; mutable s_nationkey : int }
type record3 = { mutable ps_partkey : int; mutable ps_suppkey : int; mutable ps_supplycost : float; mutable ps_availqty : int }
type record4 = { mutable ps_partkey : int; mutable value : float }
type record5 = { mutable ps_partkey : Obj.t; mutable value : float }

let nation : record1 list = [{ n_nationkey = 1; n_name = "GERMANY" };{ n_nationkey = 2; n_name = "FRANCE" }]
let supplier : record2 list = [{ s_suppkey = 100; s_nationkey = 1 };{ s_suppkey = 200; s_nationkey = 1 };{ s_suppkey = 300; s_nationkey = 2 }]
let partsupp : record3 list = [{ ps_partkey = 1000; ps_suppkey = 100; ps_supplycost = 10.; ps_availqty = 100 };{ ps_partkey = 1000; ps_suppkey = 200; ps_supplycost = 20.; ps_availqty = 50 };{ ps_partkey = 2000; ps_suppkey = 100; ps_supplycost = 5.; ps_availqty = 10 };{ ps_partkey = 3000; ps_suppkey = 300; ps_supplycost = 8.; ps_availqty = 500 }]
let target_nation : string = "GERMANY"
let filtered : record4 list = (let __res0 = ref [] in
  List.iter (fun (ps : record3) ->
      List.iter (fun (s : record2) ->
            List.iter (fun (n : record1) ->
                        if (s.s_suppkey = ps.ps_suppkey) && (n.n_nationkey = s.s_nationkey) && (n.n_name = target_nation) then
        __res0 := { ps_partkey = ps.ps_partkey; value = (ps.ps_supplycost *. ps.ps_availqty) } :: !__res0;
            ) nation;
      ) supplier;
  ) partsupp;
List.rev !__res0)

let grouped : record4 list = (let (__groups1 : (int * record4 list) list ref) = ref [] in
  List.iter (fun (x : record4) ->
      let (key : int) = x.ps_partkey in
      let cur = try List.assoc key !__groups1 with Not_found -> [] in
      __groups1 := (key, x :: cur) :: List.remove_assoc key !__groups1;
  ) filtered;
  let __res1 = ref [] in
  List.iter (fun ((gKey : int), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res1 := { ps_partkey = g.key; value = (sum_float (let __res2 = ref [] in
  List.iter (fun r ->
      __res2 := r.value :: !__res2;
  ) g.items;
List.rev !__res2)
) } :: !__res1
  ) !__groups1;
  List.rev !__res1)

let total : float = (sum_float (let __res3 = ref [] in
  List.iter (fun (x : record4) ->
      __res3 := x.value :: !__res3;
  ) filtered;
List.rev !__res3)
)
let threshold : float = (total *. 0.0001)
let result : record4 list = (let __res4 = ref [] in
  List.iter (fun (x : record4) ->
      if (x.value > threshold) then
    __res4 := x :: !__res4;
  ) grouped;
List.rev !__res4)


let () =
  json result;
  assert ((result = [{ ps_partkey = 1000; value = 2000. };{ ps_partkey = 2000; value = 50. }]))
