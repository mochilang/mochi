// Generated by Mochi compiler v0.10.28 on 2025-07-18T03:37:52Z
open System
open System.Text.Json

type Anon1 = {
    o_orderkey: int
    o_orderpriority: string
}
type Anon2 = {
    l_orderkey: int
    l_shipmode: string
    l_commitdate: string
    l_receiptdate: string
    l_shipdate: string
}
type Anon3 = {
    l_shipmode: obj
    high_line_count: obj
    low_line_count: obj
}
type Anon4 = {
    l_shipmode: string
    high_line_count: int
    low_line_count: int
}
type _Group<'K,'T>(key: 'K) =
    member val key = key with get, set
    member val Items = System.Collections.Generic.List<'T>() with get
    member this.size = this.Items.Count
    interface System.Collections.Generic.IEnumerable<'T> with
        member this.GetEnumerator() = (this.Items :> seq<'T>).GetEnumerator()
    interface System.Collections.IEnumerable with
        member this.GetEnumerator() = (this.Items :> System.Collections.IEnumerable).GetEnumerator()

let _group_by (src: 'T list) (keyfn: 'T -> 'K) : _Group<'K,'T> list =
    let groups = System.Collections.Generic.Dictionary<string,_Group<'K,'T>>()
    let order = System.Collections.Generic.List<string>()
    for it in src do
        let key = keyfn it
        let ks = string key
        let mutable g = Unchecked.defaultof<_Group<'K,'T>>
        if groups.TryGetValue(ks, &g) then ()
        else
            g <- _Group<'K,'T>(key)
            groups.Add(ks, g)
            order.Add(ks)
        g.Items.Add(it)
    [ for ks in order -> groups.[ks] ]

let orders: Anon1 list = [{ o_orderkey = 1; o_orderpriority = "1-URGENT" }; { o_orderkey = 2; o_orderpriority = "3-MEDIUM" }]
let lineitem: Anon2 list = [{ l_orderkey = 1; l_shipmode = "MAIL"; l_commitdate = "1994-02-10"; l_receiptdate = "1994-02-15"; l_shipdate = "1994-02-05" }; { l_orderkey = 2; l_shipmode = "SHIP"; l_commitdate = "1994-03-01"; l_receiptdate = "1994-02-28"; l_shipdate = "1994-02-27" }]
let result: Anon3 list = [ for g in _group_by [ for l in lineitem do 
  for o in orders do if o.o_orderkey = l.l_orderkey && (List.contains l.l_shipmode ["MAIL"; "SHIP"]) && (l.l_commitdate < l.l_receiptdate) && (l.l_shipdate < l.l_commitdate) && (l.l_receiptdate >= "1994-01-01") && (l.l_receiptdate < "1995-01-01") then yield (l, o) ] (fun (l, o) -> l.l_shipmode) |> List.sortBy (fun gTmp -> let g = gTmp in g.key) do
    yield { l_shipmode = g.key; high_line_count = List.sum [ for x in g do yield (if List.contains (x |> fun (l, o) -> o).o_orderpriority ["1-URGENT"; "2-HIGH"] then 1 else 0) ]; low_line_count = List.sum [ for x in g do yield (if not (List.contains (x |> fun (l, o) -> o).o_orderpriority ["1-URGENT"; "2-HIGH"]) then 1 else 0) ] } ]
printfn "%A" (JsonSerializer.Serialize(result))
assert (result = [{ l_shipmode = "MAIL"; high_line_count = 1; low_line_count = 0 }])
