func main (regs=162)
  // let store_sales = [
  Const        r0, [{"ss_customer_sk": 1, "ss_item_sk": 1, "ss_quantity": 5, "ss_sales_price": 10.0, "ss_ticket_number": 1}, {"ss_customer_sk": 2, "ss_item_sk": 1, "ss_quantity": 3, "ss_sales_price": 20.0, "ss_ticket_number": 2}]
  // let store_returns = [
  Const        r1, [{"sr_item_sk": 1, "sr_reason_sk": 1, "sr_return_quantity": 1, "sr_ticket_number": 1}]
  // let reason = [{r_reason_sk: 1, r_reason_desc: "ReasonA"}]
  Const        r2, [{"r_reason_desc": "ReasonA", "r_reason_sk": 1}]
  // from ss in store_sales
  Const        r3, []
  // where r.r_reason_desc == "ReasonA"
  Const        r4, "r_reason_desc"
  // ss_customer_sk: ss.ss_customer_sk,
  Const        r5, "ss_customer_sk"
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Const        r6, "act_sales"
  Const        r7, "ss_quantity"
  Const        r8, "sr_return_quantity"
  Const        r9, "ss_sales_price"
  // from ss in store_sales
  IterPrep     r10, r0
  Len          r11, r10
  Const        r13, 0
  Move         r12, r13
L10:
  LessInt      r14, r12, r11
  JumpIfFalse  r14, L0
  Index        r15, r10, r12
  Move         r16, r15
  // left join sr in store_returns on ss.ss_item_sk == sr.sr_item_sk && ss.ss_ticket_number == sr.sr_ticket_number
  IterPrep     r17, r1
  Len          r18, r17
  Const        r19, "ss_item_sk"
  Const        r20, "sr_item_sk"
  Const        r21, "ss_ticket_number"
  Const        r22, "sr_ticket_number"
  Move         r23, r13
L6:
  LessInt      r24, r23, r18
  JumpIfFalse  r24, L1
  Index        r25, r17, r23
  Move         r26, r25
  Const        r27, false
  Index        r28, r16, r19
  Index        r29, r26, r20
  Equal        r30, r28, r29
  Index        r31, r16, r21
  Index        r32, r26, r22
  Equal        r33, r31, r32
  Move         r34, r30
  JumpIfFalse  r34, L2
  Move         r34, r33
L2:
  JumpIfFalse  r34, L3
  Const        r27, true
  // join r in reason on sr.sr_reason_sk == r.r_reason_sk
  IterPrep     r35, r2
  Len          r36, r35
  Const        r37, "sr_reason_sk"
  Const        r38, "r_reason_sk"
  Move         r39, r13
L5:
  LessInt      r40, r39, r36
  JumpIfFalse  r40, L3
  Index        r41, r35, r39
  Move         r42, r41
  Index        r43, r26, r37
  Index        r44, r42, r38
  Equal        r45, r43, r44
  JumpIfFalse  r45, L4
  // where r.r_reason_desc == "ReasonA"
  Index        r46, r42, r4
  Const        r47, "ReasonA"
  Equal        r48, r46, r47
  JumpIfFalse  r48, L4
  // ss_customer_sk: ss.ss_customer_sk,
  Const        r49, "ss_customer_sk"
  Index        r50, r16, r5
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Const        r51, "act_sales"
  Const        r52, nil
  NotEqual     r53, r26, r52
  Index        r54, r16, r7
  Index        r55, r26, r8
  Sub          r56, r54, r55
  Index        r57, r16, r9
  Mul          r58, r56, r57
  Index        r59, r16, r7
  Index        r60, r16, r9
  Mul          r61, r59, r60
  Select       62,53,58,61
  // ss_customer_sk: ss.ss_customer_sk,
  Move         r63, r49
  Move         r64, r50
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Move         r65, r51
  Move         r66, r62
  // select {
  MakeMap      r67, 2, r63
  // from ss in store_sales
  Append       r68, r3, r67
  Move         r3, r68
L4:
  // join r in reason on sr.sr_reason_sk == r.r_reason_sk
  Const        r69, 1
  Add          r39, r39, r69
  Jump         L5
L3:
  // left join sr in store_returns on ss.ss_item_sk == sr.sr_item_sk && ss.ss_ticket_number == sr.sr_ticket_number
  Add          r23, r23, r69
  Jump         L6
L1:
  Move         r70, r27
  JumpIfTrue   r70, L7
  Move         r26, r52
  // join r in reason on sr.sr_reason_sk == r.r_reason_sk
  IterPrep     r71, r2
  Len          r72, r71
  Move         r73, r13
L9:
  LessInt      r74, r73, r72
  JumpIfFalse  r74, L7
  Index        r75, r71, r73
  Move         r42, r75
  Index        r76, r26, r37
  Index        r77, r42, r38
  Equal        r78, r76, r77
  JumpIfFalse  r78, L8
  // where r.r_reason_desc == "ReasonA"
  Index        r79, r42, r4
  Equal        r80, r79, r47
  JumpIfFalse  r80, L8
  // ss_customer_sk: ss.ss_customer_sk,
  Const        r81, "ss_customer_sk"
  Index        r82, r16, r5
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Const        r83, "act_sales"
  NotEqual     r84, r26, r52
  Index        r85, r16, r7
  Index        r86, r26, r8
  Sub          r87, r85, r86
  Index        r88, r16, r9
  Mul          r89, r87, r88
  Index        r90, r16, r7
  Index        r91, r16, r9
  Mul          r92, r90, r91
  Select       93,84,89,92
  // ss_customer_sk: ss.ss_customer_sk,
  Move         r94, r81
  Move         r95, r82
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Move         r96, r83
  Move         r97, r93
  // select {
  MakeMap      r98, 2, r94
  // from ss in store_sales
  Append       r99, r3, r98
  Move         r3, r99
L8:
  // join r in reason on sr.sr_reason_sk == r.r_reason_sk
  Add          r73, r73, r69
  Jump         L9
L7:
  // from ss in store_sales
  AddInt       r12, r12, r69
  Jump         L10
L0:
  // from x in t
  Const        r100, []
  // select {ss_customer_sk: g.key, sumsales: sum(from y in g select y.act_sales)}
  Const        r101, "key"
  Const        r102, "sumsales"
  // from x in t
  IterPrep     r103, r3
  Len          r104, r103
  Const        r105, 0
  MakeMap      r106, 0, r0
  Const        r108, []
  Move         r107, r108
L13:
  LessInt      r109, r105, r104
  JumpIfFalse  r109, L11
  Index        r110, r103, r105
  Move         r111, r110
  // group by x.ss_customer_sk into g
  Index        r112, r111, r5
  Str          r113, r112
  In           r114, r113, r106
  JumpIfTrue   r114, L12
  // from x in t
  Const        r115, "__group__"
  Const        r116, true
  // group by x.ss_customer_sk into g
  Move         r117, r112
  // from x in t
  Const        r118, "items"
  Move         r119, r108
  Const        r120, "count"
  Move         r121, r115
  Move         r122, r116
  Move         r123, r101
  Move         r124, r117
  Move         r125, r118
  Move         r126, r119
  Move         r127, r120
  Move         r128, r13
  MakeMap      r129, 4, r121
  SetIndex     r106, r113, r129
  Append       r130, r107, r129
  Move         r107, r130
L12:
  Index        r131, r106, r113
  Index        r132, r131, r118
  Append       r133, r132, r110
  SetIndex     r131, r118, r133
  Index        r134, r131, r120
  AddInt       r135, r134, r69
  SetIndex     r131, r120, r135
  AddInt       r105, r105, r69
  Jump         L13
L11:
  Move         r136, r13
  Len          r137, r107
L17:
  LessInt      r138, r136, r137
  JumpIfFalse  r138, L14
  Index        r139, r107, r136
  Move         r140, r139
  // select {ss_customer_sk: g.key, sumsales: sum(from y in g select y.act_sales)}
  Const        r141, "ss_customer_sk"
  Index        r142, r140, r101
  Const        r143, "sumsales"
  Const        r144, []
  IterPrep     r145, r140
  Len          r146, r145
  Move         r147, r13
L16:
  LessInt      r148, r147, r146
  JumpIfFalse  r148, L15
  Index        r149, r145, r147
  Move         r150, r149
  Index        r151, r150, r6
  Append       r152, r144, r151
  Move         r144, r152
  AddInt       r147, r147, r69
  Jump         L16
L15:
  Sum          r153, r144
  Move         r154, r141
  Move         r155, r142
  Move         r156, r143
  Move         r157, r153
  MakeMap      r158, 2, r154
  // from x in t
  Append       r159, r100, r158
  Move         r100, r159
  AddInt       r136, r136, r69
  Jump         L17
L14:
  // json(result)
  JSON         r100
  // expect result == [
  Const        r160, [{"ss_customer_sk": 1, "sumsales": 40.0}]
  Equal        r161, r100, r160
  Expect       r161
  Return       r0
