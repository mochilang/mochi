func main (regs=166)
  // let store_sales = [
  Const        r0, [{"ss_customer_sk": 1, "ss_item_sk": 1, "ss_quantity": 5, "ss_sales_price": 10, "ss_ticket_number": 1}, {"ss_customer_sk": 2, "ss_item_sk": 1, "ss_quantity": 3, "ss_sales_price": 20, "ss_ticket_number": 2}]
  // let store_returns = [
  Const        r1, [{"sr_item_sk": 1, "sr_reason_sk": 1, "sr_return_quantity": 1, "sr_ticket_number": 1}]
  // let reason = [{r_reason_sk: 1, r_reason_desc: "ReasonA"}]
  Const        r2, [{"r_reason_desc": "ReasonA", "r_reason_sk": 1}]
  // from ss in store_sales
  Const        r3, []
  // where r.r_reason_desc == "ReasonA"
  Const        r4, "r_reason_desc"
  // ss_customer_sk: ss.ss_customer_sk,
  Const        r5, "ss_customer_sk"
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Const        r6, "act_sales"
  Const        r7, "ss_quantity"
  Const        r8, "sr_return_quantity"
  Const        r9, "ss_sales_price"
  // from ss in store_sales
  IterPrep     r10, r0
  Len          r11, r10
  Const        r13, 0
  Move         r12, r13
L10:
  LessInt      r14, r12, r11
  JumpIfFalse  r14, L0
  Index        r16, r10, r12
  // left join sr in store_returns on ss.ss_item_sk == sr.sr_item_sk && ss.ss_ticket_number == sr.sr_ticket_number
  IterPrep     r17, r1
  Len          r18, r17
  Const        r19, "ss_item_sk"
  Const        r20, "sr_item_sk"
  Const        r21, "ss_ticket_number"
  Const        r22, "sr_ticket_number"
  Move         r23, r13
L6:
  LessInt      r24, r23, r18
  JumpIfFalse  r24, L1
  Index        r26, r17, r23
  Const        r27, false
  Index        r28, r16, r19
  Index        r29, r26, r20
  Equal        r30, r28, r29
  Index        r31, r16, r21
  Index        r32, r26, r22
  Equal        r33, r31, r32
  JumpIfFalse  r30, L2
  Move         r30, r33
L2:
  JumpIfFalse  r30, L3
  Const        r27, true
  // join r in reason on sr.sr_reason_sk == r.r_reason_sk
  IterPrep     r34, r2
  Len          r35, r34
  Const        r36, "sr_reason_sk"
  Const        r37, "r_reason_sk"
  Move         r38, r13
L5:
  LessInt      r39, r38, r35
  JumpIfFalse  r39, L3
  Index        r41, r34, r38
  Index        r42, r26, r36
  Index        r43, r41, r37
  Equal        r44, r42, r43
  JumpIfFalse  r44, L4
  // where r.r_reason_desc == "ReasonA"
  Index        r45, r41, r4
  Const        r46, "ReasonA"
  Equal        r47, r45, r46
  JumpIfFalse  r47, L4
  // ss_customer_sk: ss.ss_customer_sk,
  Const        r48, "ss_customer_sk"
  Index        r49, r16, r5
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Const        r50, "act_sales"
  Const        r51, nil
  NotEqual     r52, r26, r51
  Index        r53, r16, r7
  Index        r54, r26, r8
  Sub          r55, r53, r54
  Index        r56, r16, r9
  Mul          r57, r55, r56
  Index        r58, r16, r7
  Index        r59, r16, r9
  Mul          r60, r58, r59
  Select       61,52,57,60
  // ss_customer_sk: ss.ss_customer_sk,
  Move         r62, r48
  Move         r63, r49
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Move         r64, r50
  Move         r65, r61
  // select {
  MakeMap      r66, 2, r62
  // from ss in store_sales
  Append       r3, r3, r66
L4:
  // join r in reason on sr.sr_reason_sk == r.r_reason_sk
  Const        r68, 1
  Add          r38, r38, r68
  Jump         L5
L3:
  // left join sr in store_returns on ss.ss_item_sk == sr.sr_item_sk && ss.ss_ticket_number == sr.sr_ticket_number
  Add          r23, r23, r68
  Jump         L6
L1:
  Move         r69, r27
  JumpIfTrue   r69, L7
  Move         r26, r51
  // join r in reason on sr.sr_reason_sk == r.r_reason_sk
  IterPrep     r70, r2
  Len          r71, r70
  Move         r72, r13
L9:
  LessInt      r73, r72, r71
  JumpIfFalse  r73, L7
  Index        r41, r70, r72
  Index        r75, r26, r36
  Index        r76, r41, r37
  Equal        r77, r75, r76
  JumpIfFalse  r77, L8
  // where r.r_reason_desc == "ReasonA"
  Index        r78, r41, r4
  Equal        r79, r78, r46
  JumpIfFalse  r79, L8
  // ss_customer_sk: ss.ss_customer_sk,
  Const        r80, "ss_customer_sk"
  Index        r81, r16, r5
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Const        r82, "act_sales"
  NotEqual     r83, r26, r51
  Index        r84, r16, r7
  Index        r85, r26, r8
  Sub          r86, r84, r85
  Index        r87, r16, r9
  Mul          r88, r86, r87
  Index        r89, r16, r7
  Index        r90, r16, r9
  Mul          r91, r89, r90
  Select       92,83,88,91
  // ss_customer_sk: ss.ss_customer_sk,
  Move         r93, r80
  Move         r94, r81
  // act_sales: if sr != null { (ss.ss_quantity - sr.sr_return_quantity) * ss.ss_sales_price } else { ss.ss_quantity * ss.ss_sales_price }
  Move         r95, r82
  Move         r96, r92
  // select {
  MakeMap      r97, 2, r93
  // from ss in store_sales
  Append       r3, r3, r97
L8:
  // join r in reason on sr.sr_reason_sk == r.r_reason_sk
  Add          r72, r72, r68
  Jump         L9
L7:
  // from ss in store_sales
  AddInt       r12, r12, r68
  Jump         L10
L0:
  // from x in t
  Const        r99, []
  // select {ss_customer_sk: g.key, sumsales: sum(from y in g select y.act_sales)}
  Const        r100, "key"
  Const        r101, "sumsales"
  // from x in t
  IterPrep     r102, r3
  Len          r103, r102
  Const        r104, 0
  MakeMap      r105, 0, r0
  Const        r106, []
L13:
  LessInt      r108, r104, r103
  JumpIfFalse  r108, L11
  Index        r109, r102, r104
  // group by x.ss_customer_sk into g
  Index        r111, r109, r5
  Str          r112, r111
  In           r113, r112, r105
  JumpIfTrue   r113, L12
  // from x in t
  Const        r114, []
  Const        r115, "__group__"
  Const        r116, true
  Const        r117, "key"
  // group by x.ss_customer_sk into g
  Move         r118, r111
  // from x in t
  Const        r119, "items"
  Move         r120, r114
  Const        r121, "count"
  Const        r122, 0
  Move         r123, r115
  Move         r124, r116
  Move         r125, r117
  Move         r126, r118
  Move         r127, r119
  Move         r128, r120
  Move         r129, r121
  Move         r130, r122
  MakeMap      r131, 4, r123
  SetIndex     r105, r112, r131
  Append       r106, r106, r131
L12:
  Const        r133, "items"
  Index        r134, r105, r112
  Index        r135, r134, r133
  Append       r136, r135, r109
  SetIndex     r134, r133, r136
  Const        r137, "count"
  Index        r138, r134, r137
  AddInt       r139, r138, r68
  SetIndex     r134, r137, r139
  AddInt       r104, r104, r68
  Jump         L13
L11:
  Move         r140, r13
  Len          r141, r106
L17:
  LessInt      r142, r140, r141
  JumpIfFalse  r142, L14
  Index        r144, r106, r140
  // select {ss_customer_sk: g.key, sumsales: sum(from y in g select y.act_sales)}
  Const        r145, "ss_customer_sk"
  Index        r146, r144, r100
  Const        r147, "sumsales"
  Const        r148, []
  IterPrep     r149, r144
  Len          r150, r149
  Move         r151, r13
L16:
  LessInt      r152, r151, r150
  JumpIfFalse  r152, L15
  Index        r154, r149, r151
  Index        r155, r154, r6
  Append       r148, r148, r155
  AddInt       r151, r151, r68
  Jump         L16
L15:
  Sum          r157, r148
  Move         r158, r145
  Move         r159, r146
  Move         r160, r147
  Move         r161, r157
  MakeMap      r162, 2, r158
  // from x in t
  Append       r99, r99, r162
  AddInt       r140, r140, r68
  Jump         L17
L14:
  // json(result)
  JSON         r99
  // expect result == [
  Const        r164, [{"ss_customer_sk": 1, "sumsales": 40}]
  Equal        r165, r99, r164
  Expect       r165
  Return       r0
