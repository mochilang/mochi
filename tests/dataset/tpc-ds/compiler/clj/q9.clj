; Generated by Mochi compiler v0.10.25 on 2025-07-15T04:45:18Z
(ns main)

(defn _equal [a b]
  (cond
    (and (sequential? a) (sequential? b))
      (and (= (count a) (count b)) (every? true? (map _equal a b)))
    (and (map? a) (map? b))
      (and (= (count a) (count b))
           (every? (fn [k] (_equal (get a k) (get b k))) (keys a)))
    (and (number? a) (number? b))
      (= (double a) (double b))
    :else
      (= a b)))

(defn _escape_json [s]
  (-> s
      (clojure.string/replace "\\" "\\\\")
      (clojure.string/replace "\"" "\\\"")))

(defn _to_json [v]
  (cond
    (nil? v) "null"
    (string? v) (str "\"" (_escape_json v) "\"")
    (number? v) (str v)
    (boolean? v) (str v)
    (sequential? v) (str "[" (clojure.string/join "," (map _to_json v)) "]")
    (map? v) (str "{" (clojure.string/join "," (map (fn [[k val]]
                                        (str "\"" (_escape_json (name k)) "\":" (_to_json val))) v)) "}")
    :else (str "\"" (_escape_json (str v)) "\"")))

(defn _json [v]
  (println (_to_json v)))

(declare store_sales reason bucket1 bucket2 bucket3 bucket4 bucket5 result)

(defn test_TPCDS_Q9_result []
  (assert (_equal result [{:bucket1 7.0 :bucket2 15.0 :bucket3 30.0 :bucket4 35.0 :bucket5 50.0}]) "expect failed")
)

(defn -main []
  (def store_sales [{:ss_quantity 5 :ss_ext_discount_amt 5.0 :ss_net_paid 7.0} {:ss_quantity 30 :ss_ext_discount_amt 10.0 :ss_net_paid 15.0} {:ss_quantity 50 :ss_ext_discount_amt 20.0 :ss_net_paid 30.0} {:ss_quantity 70 :ss_ext_discount_amt 25.0 :ss_net_paid 35.0} {:ss_quantity 90 :ss_ext_discount_amt 40.0 :ss_net_paid 50.0}]) ;; list of
  (def reason [{:r_reason_sk 1}]) ;; list of
  (def bucket1 (if (> (count (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 1) (<= (:ss_quantity s) 20))] s)))) 10) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 1) (<= (:ss_quantity s) 20))] (:ss_ext_discount_amt s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 1) (<= (:ss_quantity s) 20))] (:ss_net_paid s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))))) ;; float
  (def bucket2 (if (> (count (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 21) (<= (:ss_quantity s) 40))] s)))) 20) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 21) (<= (:ss_quantity s) 40))] (:ss_ext_discount_amt s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 21) (<= (:ss_quantity s) 40))] (:ss_net_paid s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))))) ;; float
  (def bucket3 (if (> (count (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 41) (<= (:ss_quantity s) 60))] s)))) 30) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 41) (<= (:ss_quantity s) 60))] (:ss_ext_discount_amt s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 41) (<= (:ss_quantity s) 60))] (:ss_net_paid s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))))) ;; float
  (def bucket4 (if (> (count (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 61) (<= (:ss_quantity s) 80))] s)))) 40) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 61) (<= (:ss_quantity s) 80))] (:ss_ext_discount_amt s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 61) (<= (:ss_quantity s) 80))] (:ss_net_paid s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))))) ;; float
  (def bucket5 (if (> (count (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 81) (<= (:ss_quantity s) 100))] s)))) 50) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 81) (<= (:ss_quantity s) 100))] (:ss_ext_discount_amt s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))) (let [xs (vec (->> (for [s store_sales :when (and (>= (:ss_quantity s) 81) (<= (:ss_quantity s) 100))] (:ss_net_paid s))))] (if (empty? xs) 0 (/ (reduce + xs) (double (count xs))))))) ;; float
  (def result (vec (->> (for [r reason :when (_equal (:r_reason_sk r) 1)] {:bucket1 bucket1 :bucket2 bucket2 :bucket3 bucket3 :bucket4 bucket4 :bucket5 bucket5})))) ;; list of
  (_json result)
  (test_TPCDS_Q9_result)
)

(-main)
