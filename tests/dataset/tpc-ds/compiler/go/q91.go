//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2025-07-15T12:01:03Z

package main

import (
	"encoding/json"
	"fmt"
	"mochi/runtime/data"
	"reflect"
	"time"

	"golang.org/x/exp/constraints"
)

type CallCenter struct {
	Cc_call_center_sk int    `json:"cc_call_center_sk"`
	Cc_call_center_id string `json:"cc_call_center_id"`
	Cc_name           string `json:"cc_name"`
	Cc_manager        string `json:"cc_manager"`
}

type Call_center struct {
	Cc_call_center_sk int    `json:"cc_call_center_sk"`
	Cc_call_center_id string `json:"cc_call_center_id"`
	Cc_name           string `json:"cc_name"`
	Cc_manager        string `json:"cc_manager"`
}

type CatalogReturn struct {
	Cr_call_center_sk        int     `json:"cr_call_center_sk"`
	Cr_returned_date_sk      int     `json:"cr_returned_date_sk"`
	Cr_returning_customer_sk int     `json:"cr_returning_customer_sk"`
	Cr_net_loss              float64 `json:"cr_net_loss"`
}

type Catalog_return struct {
	Cr_call_center_sk        int     `json:"cr_call_center_sk"`
	Cr_returned_date_sk      int     `json:"cr_returned_date_sk"`
	Cr_returning_customer_sk int     `json:"cr_returning_customer_sk"`
	Cr_net_loss              float64 `json:"cr_net_loss"`
}

type Customer struct {
	C_customer_sk      int `json:"c_customer_sk"`
	C_current_cdemo_sk int `json:"c_current_cdemo_sk"`
	C_current_hdemo_sk int `json:"c_current_hdemo_sk"`
	C_current_addr_sk  int `json:"c_current_addr_sk"`
}

type CustomerAddress struct {
	Ca_address_sk int `json:"ca_address_sk"`
	Ca_gmt_offset int `json:"ca_gmt_offset"`
}

type CustomerDemographics struct {
	Cd_demo_sk          int    `json:"cd_demo_sk"`
	Cd_marital_status   string `json:"cd_marital_status"`
	Cd_education_status string `json:"cd_education_status"`
}

type Customer_addres struct {
	Ca_address_sk int `json:"ca_address_sk"`
	Ca_gmt_offset int `json:"ca_gmt_offset"`
}

type Customer_demographic struct {
	Cd_demo_sk          int    `json:"cd_demo_sk"`
	Cd_marital_status   string `json:"cd_marital_status"`
	Cd_education_status string `json:"cd_education_status"`
}

type DateDim struct {
	D_date_sk int `json:"d_date_sk"`
	D_year    int `json:"d_year"`
	D_moy     int `json:"d_moy"`
}

type Date_dim struct {
	D_date_sk int `json:"d_date_sk"`
	D_year    int `json:"d_year"`
	D_moy     int `json:"d_moy"`
}

type GKey struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Mgr  string `json:"mgr"`
}

type HouseholdDemographics struct {
	Hd_demo_sk       int    `json:"hd_demo_sk"`
	Hd_buy_potential string `json:"hd_buy_potential"`
}

type Household_demographic struct {
	Hd_demo_sk       int    `json:"hd_demo_sk"`
	Hd_buy_potential string `json:"hd_buy_potential"`
}

type v map[string]any

func expect(cond bool) {
	if !cond {
		panic("expect failed")
	}
}

func formatDuration(d time.Duration) string {
	switch {
	case d < time.Microsecond:
		return fmt.Sprintf("%dns", d.Nanoseconds())
	case d < time.Millisecond:
		return fmt.Sprintf("%.1fÂµs", float64(d.Microseconds()))
	case d < time.Second:
		return fmt.Sprintf("%.1fms", float64(d.Milliseconds()))
	default:
		return fmt.Sprintf("%.2fs", d.Seconds())
	}
}

func printTestStart(name string) {
	fmt.Printf("   test %-30s ...", name)
}

func printTestPass(d time.Duration) {
	fmt.Printf(" ok (%s)\n", formatDuration(d))
}

func printTestFail(err error, d time.Duration) {
	fmt.Printf(" fail %v (%s)\n", err, formatDuration(d))
}

func test_TPCDS_Q91_returns() {
	expect(_equal(result, v{
		Call_Center:      "CC1",
		Call_Center_Name: "Main",
		Manager:          "Alice",
		Returns_Loss:     10.0,
	}))
}

var call_center []Call_center
var catalog_returns []Catalog_return
var date_dim []Date_dim
var customer []Customer
var customer_demographics []Customer_demographic
var household_demographics []Household_demographic
var customer_address []Customer_addres
var result v

func main() {
	call_center = []Call_center{Call_center{
		Cc_call_center_sk: 1,
		Cc_call_center_id: "CC1",
		Cc_name:           "Main",
		Cc_manager:        "Alice",
	}}
	catalog_returns = []Catalog_return{Catalog_return{
		Cr_call_center_sk:        1,
		Cr_returned_date_sk:      1,
		Cr_returning_customer_sk: 1,
		Cr_net_loss:              10.0,
	}}
	date_dim = []Date_dim{Date_dim{
		D_date_sk: 1,
		D_year:    2001,
		D_moy:     5,
	}}
	customer = []Customer{Customer{
		C_customer_sk:      1,
		C_current_cdemo_sk: 1,
		C_current_hdemo_sk: 1,
		C_current_addr_sk:  1,
	}}
	customer_demographics = []Customer_demographic{Customer_demographic{
		Cd_demo_sk:          1,
		Cd_marital_status:   "M",
		Cd_education_status: "Unknown",
	}}
	household_demographics = []Household_demographic{Household_demographic{
		Hd_demo_sk:       1,
		Hd_buy_potential: "1001-5000",
	}}
	customer_address = []Customer_addres{Customer_addres{
		Ca_address_sk: 1,
		Ca_gmt_offset: -6,
	}}
	result = _firstSlice[v](func() []any {
		groups := map[string]*data.Group{}
		order := []string{}
		for _, cc := range call_center {
			for _, cr := range catalog_returns {
				if !(cc.Cc_call_center_sk == cr.Cr_call_center_sk) {
					continue
				}
				for _, d := range date_dim {
					if !(cr.Cr_returned_date_sk == d.D_date_sk) {
						continue
					}
					for _, c := range customer {
						if !(cr.Cr_returning_customer_sk == c.C_customer_sk) {
							continue
						}
						for _, cd := range customer_demographics {
							if !(c.C_current_cdemo_sk == cd.Cd_demo_sk) {
								continue
							}
							for _, hd := range household_demographics {
								if !(c.C_current_hdemo_sk == hd.Hd_demo_sk) {
									continue
								}
								for _, ca := range customer_address {
									if !(c.C_current_addr_sk == ca.Ca_address_sk) {
										continue
									}
									if (((((d.D_year == 2001) && (d.D_moy == 5)) && (cd.Cd_marital_status == "M")) && (cd.Cd_education_status == "Unknown")) && (hd.Hd_buy_potential == "1001-5000")) && (ca.Ca_gmt_offset == (-6)) {
										key := GKey{
											ID:   cc.Cc_call_center_id,
											Name: cc.Cc_name,
											Mgr:  cc.Cc_manager,
										}
										ks := fmt.Sprint(key)
										g, ok := groups[ks]
										if !ok {
											g = &data.Group{Key: key}
											groups[ks] = g
											order = append(order, ks)
										}
										_item := map[string]any{}
										_item["cc_call_center_sk"] = cc.Cc_call_center_sk
										_item["cc_call_center_id"] = cc.Cc_call_center_id
										_item["cc_name"] = cc.Cc_name
										_item["cc_manager"] = cc.Cc_manager
										_item["cc"] = cc
										_item["cr_call_center_sk"] = cr.Cr_call_center_sk
										_item["cr_returned_date_sk"] = cr.Cr_returned_date_sk
										_item["cr_returning_customer_sk"] = cr.Cr_returning_customer_sk
										_item["cr_net_loss"] = cr.Cr_net_loss
										_item["cr"] = cr
										_item["d_date_sk"] = d.D_date_sk
										_item["d_year"] = d.D_year
										_item["d_moy"] = d.D_moy
										_item["d"] = d
										_item["c_customer_sk"] = c.C_customer_sk
										_item["c_current_cdemo_sk"] = c.C_current_cdemo_sk
										_item["c_current_hdemo_sk"] = c.C_current_hdemo_sk
										_item["c_current_addr_sk"] = c.C_current_addr_sk
										_item["c"] = c
										_item["cd_demo_sk"] = cd.Cd_demo_sk
										_item["cd_marital_status"] = cd.Cd_marital_status
										_item["cd_education_status"] = cd.Cd_education_status
										_item["cd"] = cd
										_item["hd_demo_sk"] = hd.Hd_demo_sk
										_item["hd_buy_potential"] = hd.Hd_buy_potential
										_item["hd"] = hd
										_item["ca_address_sk"] = ca.Ca_address_sk
										_item["ca_gmt_offset"] = ca.Ca_gmt_offset
										_item["ca"] = ca
										g.Items = append(g.Items, _item)
									}
								}
							}
						}
					}
				}
			}
		}
		items := []*data.Group{}
		for _, ks := range order {
			items = append(items, groups[ks])
		}
		results := []any{}
		for _, g := range items {
			results = append(results, v{
				Call_Center:      g.Key.(GKey).ID,
				Call_Center_Name: g.Key.(GKey).Name,
				Manager:          g.Key.(GKey).Mgr,
				Returns_Loss: _sum(func() []any {
					results := []any{}
					for _, x := range g.Items {
						results = append(results, x.Cr_net_loss)
					}
					return results
				}()),
			})
		}
		return results
	}())
	func() { b, _ := json.Marshal(result); fmt.Println(string(b)) }()
	test_TPCDS_Q91_returns()
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}

func _firstSlice[T any](s []T) T {
	if len(s) == 0 {
		var zero T
		return zero
	}
	return s[0]
}

func _sum[T constraints.Integer | constraints.Float](v []T) float64 {
	var sum float64
	for _, n := range v {
		sum += float64(n)
	}
	return sum
}
