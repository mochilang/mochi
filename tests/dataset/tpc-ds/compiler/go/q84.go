//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2025-07-16T01:06:14Z

package main

import (
	"encoding/json"
	"fmt"
	"time"

	"golang.org/x/exp/constraints"
)

type Customer struct {
	ID           int `json:"id"`
	Current_addr int `json:"current_addr"`
	Cdemo        int `json:"cdemo"`
	Hdemo        int `json:"hdemo"`
}

type Customer_addres struct {
	Ca_address_sk int    `json:"ca_address_sk"`
	Ca_city       string `json:"ca_city"`
}

type Customer_demographic struct {
	Cd_demo_sk int `json:"cd_demo_sk"`
}

type Household_demographic struct {
	Hd_demo_sk     int `json:"hd_demo_sk"`
	Income_band_sk int `json:"income_band_sk"`
}

type Income_band struct {
	Ib_income_band_sk int `json:"ib_income_band_sk"`
	Ib_lower_bound    int `json:"ib_lower_bound"`
	Ib_upper_bound    int `json:"ib_upper_bound"`
}

type Store_return struct {
	Sr_cdemo_sk int     `json:"sr_cdemo_sk"`
	Amt         float64 `json:"amt"`
}

type v map[string]any

func expect(cond bool) {
	if !cond {
		panic("expect failed")
	}
}

func formatDuration(d time.Duration) string {
	switch {
	case d < time.Microsecond:
		return fmt.Sprintf("%dns", d.Nanoseconds())
	case d < time.Millisecond:
		return fmt.Sprintf("%.1fÂµs", float64(d.Microseconds()))
	case d < time.Second:
		return fmt.Sprintf("%.1fms", float64(d.Milliseconds()))
	default:
		return fmt.Sprintf("%.2fs", d.Seconds())
	}
}

func printTestStart(name string) {
	fmt.Printf("   test %-30s ...", name)
}

func printTestPass(d time.Duration) {
	fmt.Printf(" ok (%s)\n", formatDuration(d))
}

func printTestFail(err error, d time.Duration) {
	fmt.Printf(" fail %v (%s)\n", err, formatDuration(d))
}

func test_TPCDS_Q84_sample() {
	expect((result == 84.0))
}

var customer []Customer
var customer_address []Customer_addres
var customer_demographics []Customer_demographic
var household_demographics []Household_demographic
var income_band []Income_band
var store_returns []Store_return
var result float64

func main() {
	customer = []Customer{
		Customer{
			ID:           1,
			Current_addr: 1,
			Cdemo:        1,
			Hdemo:        1,
		},
		Customer{
			ID:           2,
			Current_addr: 1,
			Cdemo:        2,
			Hdemo:        2,
		},
		Customer{
			ID:           3,
			Current_addr: 1,
			Cdemo:        3,
			Hdemo:        1,
		},
		Customer{
			ID:           4,
			Current_addr: 1,
			Cdemo:        4,
			Hdemo:        2,
		},
	}
	customer_address = []Customer_addres{Customer_addres{
		Ca_address_sk: 1,
		Ca_city:       "Springfield",
	}}
	customer_demographics = []Customer_demographic{
		Customer_demographic{Cd_demo_sk: 1},
		Customer_demographic{Cd_demo_sk: 2},
		Customer_demographic{Cd_demo_sk: 3},
		Customer_demographic{Cd_demo_sk: 4},
	}
	household_demographics = []Household_demographic{Household_demographic{
		Hd_demo_sk:     1,
		Income_band_sk: 1,
	}, Household_demographic{
		Hd_demo_sk:     2,
		Income_band_sk: 1,
	}}
	income_band = []Income_band{Income_band{
		Ib_income_band_sk: 1,
		Ib_lower_bound:    0,
		Ib_upper_bound:    50000,
	}}
	store_returns = []Store_return{
		Store_return{
			Sr_cdemo_sk: 1,
			Amt:         10.0,
		},
		Store_return{
			Sr_cdemo_sk: 2,
			Amt:         20.0,
		},
		Store_return{
			Sr_cdemo_sk: 3,
			Amt:         30.0,
		},
		Store_return{
			Sr_cdemo_sk: 4,
			Amt:         24.0,
		},
	}
	result = _sumOrdered[float64](func() []float64 {
		results := []float64{}
		for _, c := range customer {
			for _, ca := range customer_address {
				if !((c.Current_addr == ca.Ca_address_sk) && (ca.Ca_city == "Springfield")) {
					continue
				}
				for _, cd := range customer_demographics {
					if !(c.Cdemo == cd.Cd_demo_sk) {
						continue
					}
					for _, sr := range store_returns {
						if !(cd.Cd_demo_sk == sr.Sr_cdemo_sk) {
							continue
						}
						for _, hd := range household_demographics {
							if !(c.Hdemo == hd.Hd_demo_sk) {
								continue
							}
							for _, ib := range income_band {
								if !(hd.Income_band_sk == ib.Ib_income_band_sk) {
									continue
								}
								results = append(results, sr.Amt)
							}
						}
					}
				}
			}
		}
		return results
	}())
	func() { b, _ := json.Marshal(result); fmt.Println(string(b)) }()
	test_TPCDS_Q84_sample()
}

func _sumOrdered[T constraints.Integer | constraints.Float](s []T) float64 {
	var sum float64
	for _, v := range s {
		sum += float64(v)
	}
	return sum
}
