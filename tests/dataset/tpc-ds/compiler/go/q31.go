//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2025-07-16T01:05:19Z

package main

import (
	"encoding/json"
	"fmt"
	"reflect"
	"time"

	"golang.org/x/exp/constraints"
)

type Store_sale struct {
	Ca_county          string  `json:"ca_county"`
	D_qoy              int     `json:"d_qoy"`
	D_year             int     `json:"d_year"`
	Ss_ext_sales_price float64 `json:"ss_ext_sales_price"`
}

type Web_sale struct {
	Ca_county          string  `json:"ca_county"`
	D_qoy              int     `json:"d_qoy"`
	D_year             int     `json:"d_year"`
	Ws_ext_sales_price float64 `json:"ws_ext_sales_price"`
}

type v map[string]any

func expect(cond bool) {
	if !cond {
		panic("expect failed")
	}
}

func formatDuration(d time.Duration) string {
	switch {
	case d < time.Microsecond:
		return fmt.Sprintf("%dns", d.Nanoseconds())
	case d < time.Millisecond:
		return fmt.Sprintf("%.1fÂµs", float64(d.Microseconds()))
	case d < time.Second:
		return fmt.Sprintf("%.1fms", float64(d.Milliseconds()))
	default:
		return fmt.Sprintf("%.2fs", d.Seconds())
	}
}

func printTestStart(name string) {
	fmt.Printf("   test %-30s ...", name)
}

func printTestPass(d time.Duration) {
	fmt.Printf(" ok (%s)\n", formatDuration(d))
}

func printTestFail(err error, d time.Duration) {
	fmt.Printf(" fail %v (%s)\n", err, formatDuration(d))
}

func test_TPCDS_Q31_simplified() {
	expect(_equal(result, []v{v{
		Ca_county:            "A",
		D_year:               2000,
		Web_q1_q2_increase:   1.5,
		Store_q1_q2_increase: 1.2,
		Web_q2_q3_increase:   1.6666666666666667,
		Store_q2_q3_increase: 1.3333333333333333,
	}}))
}

var store_sales []Store_sale
var web_sales []Web_sale
var counties []string
var result []any

func main() {
	store_sales = []Store_sale{
		Store_sale{
			Ca_county:          "A",
			D_qoy:              1,
			D_year:             2000,
			Ss_ext_sales_price: 100.0,
		},
		Store_sale{
			Ca_county:          "A",
			D_qoy:              2,
			D_year:             2000,
			Ss_ext_sales_price: 120.0,
		},
		Store_sale{
			Ca_county:          "A",
			D_qoy:              3,
			D_year:             2000,
			Ss_ext_sales_price: 160.0,
		},
		Store_sale{
			Ca_county:          "B",
			D_qoy:              1,
			D_year:             2000,
			Ss_ext_sales_price: 80.0,
		},
		Store_sale{
			Ca_county:          "B",
			D_qoy:              2,
			D_year:             2000,
			Ss_ext_sales_price: 90.0,
		},
		Store_sale{
			Ca_county:          "B",
			D_qoy:              3,
			D_year:             2000,
			Ss_ext_sales_price: 100.0,
		},
	}
	web_sales = []Web_sale{
		Web_sale{
			Ca_county:          "A",
			D_qoy:              1,
			D_year:             2000,
			Ws_ext_sales_price: 100.0,
		},
		Web_sale{
			Ca_county:          "A",
			D_qoy:              2,
			D_year:             2000,
			Ws_ext_sales_price: 150.0,
		},
		Web_sale{
			Ca_county:          "A",
			D_qoy:              3,
			D_year:             2000,
			Ws_ext_sales_price: 250.0,
		},
		Web_sale{
			Ca_county:          "B",
			D_qoy:              1,
			D_year:             2000,
			Ws_ext_sales_price: 80.0,
		},
		Web_sale{
			Ca_county:          "B",
			D_qoy:              2,
			D_year:             2000,
			Ws_ext_sales_price: 90.0,
		},
		Web_sale{
			Ca_county:          "B",
			D_qoy:              3,
			D_year:             2000,
			Ws_ext_sales_price: 95.0,
		},
	}
	counties = []string{"A", "B"}
	result = []any{}
	for _, county := range counties {
		ss1 := _sumOrdered[float64](func() []float64 {
			results := []float64{}
			for _, s := range store_sales {
				if (s.Ca_county == county) && (s.D_qoy == 1) {
					if (s.Ca_county == county) && (s.D_qoy == 1) {
						results = append(results, s.Ss_ext_sales_price)
					}
				}
			}
			return results
		}())
		ss2 := _sumOrdered[float64](func() []float64 {
			results := []float64{}
			for _, s := range store_sales {
				if (s.Ca_county == county) && (s.D_qoy == 2) {
					if (s.Ca_county == county) && (s.D_qoy == 2) {
						results = append(results, s.Ss_ext_sales_price)
					}
				}
			}
			return results
		}())
		ss3 := _sumOrdered[float64](func() []float64 {
			results := []float64{}
			for _, s := range store_sales {
				if (s.Ca_county == county) && (s.D_qoy == 3) {
					if (s.Ca_county == county) && (s.D_qoy == 3) {
						results = append(results, s.Ss_ext_sales_price)
					}
				}
			}
			return results
		}())
		ws1 := _sumOrdered[float64](func() []float64 {
			results := []float64{}
			for _, w := range web_sales {
				if (w.Ca_county == county) && (w.D_qoy == 1) {
					if (w.Ca_county == county) && (w.D_qoy == 1) {
						results = append(results, w.Ws_ext_sales_price)
					}
				}
			}
			return results
		}())
		ws2 := _sumOrdered[float64](func() []float64 {
			results := []float64{}
			for _, w := range web_sales {
				if (w.Ca_county == county) && (w.D_qoy == 2) {
					if (w.Ca_county == county) && (w.D_qoy == 2) {
						results = append(results, w.Ws_ext_sales_price)
					}
				}
			}
			return results
		}())
		ws3 := _sumOrdered[float64](func() []float64 {
			results := []float64{}
			for _, w := range web_sales {
				if (w.Ca_county == county) && (w.D_qoy == 3) {
					if (w.Ca_county == county) && (w.D_qoy == 3) {
						results = append(results, w.Ws_ext_sales_price)
					}
				}
			}
			return results
		}())
		web_g1 := (ws2 / ws1)
		store_g1 := (ss2 / ss1)
		web_g2 := (ws3 / ws2)
		store_g2 := (ss3 / ss2)
		if (web_g1 > store_g1) && (web_g2 > store_g2) {
			result = append(result, v{
				Ca_county:            county,
				D_year:               2000,
				Web_q1_q2_increase:   web_g1,
				Store_q1_q2_increase: store_g1,
				Web_q2_q3_increase:   web_g2,
				Store_q2_q3_increase: store_g2,
			})
		}
	}
	func() { b, _ := json.Marshal(result); fmt.Println(string(b)) }()
	test_TPCDS_Q31_simplified()
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}

func _sumOrdered[T constraints.Integer | constraints.Float](s []T) float64 {
	var sum float64
	for _, v := range s {
		sum += float64(v)
	}
	return sum
}
