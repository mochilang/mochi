//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2025-07-15T12:00:45Z

package main

import (
	"encoding/json"
	"fmt"
	"mochi/runtime/data"
	"reflect"
	"time"

	"golang.org/x/exp/constraints"
)

type Catalog_sale struct {
	Cs_sold_date_sk    int     `json:"cs_sold_date_sk"`
	Cs_ext_sales_price float64 `json:"cs_ext_sales_price"`
	Cs_sold_date_name  string  `json:"cs_sold_date_name"`
}

type Date_dim struct {
	D_date_sk  int    `json:"d_date_sk"`
	D_week_seq int    `json:"d_week_seq"`
	D_day_name string `json:"d_day_name"`
	D_year     int    `json:"d_year"`
}

type GKey struct {
	Week_seq int `json:"week_seq"`
}

type Result struct {
	D_week_seq1 any     `json:"d_week_seq1"`
	Sun_ratio   float64 `json:"sun_ratio"`
	Mon_ratio   float64 `json:"mon_ratio"`
}

type Web_sale struct {
	Ws_sold_date_sk    int     `json:"ws_sold_date_sk"`
	Ws_ext_sales_price float64 `json:"ws_ext_sales_price"`
	Ws_sold_date_name  string  `json:"ws_sold_date_name"`
}

type Wswsc struct {
	D_week_seq any     `json:"d_week_seq"`
	Sun_sales  float64 `json:"sun_sales"`
	Mon_sales  float64 `json:"mon_sales"`
	Tue_sales  float64 `json:"tue_sales"`
	Wed_sales  float64 `json:"wed_sales"`
	Thu_sales  float64 `json:"thu_sales"`
	Fri_sales  float64 `json:"fri_sales"`
	Sat_sales  float64 `json:"sat_sales"`
}

type v = Result

func expect(cond bool) {
	if !cond {
		panic("expect failed")
	}
}

func formatDuration(d time.Duration) string {
	switch {
	case d < time.Microsecond:
		return fmt.Sprintf("%dns", d.Nanoseconds())
	case d < time.Millisecond:
		return fmt.Sprintf("%.1fÂµs", float64(d.Microseconds()))
	case d < time.Second:
		return fmt.Sprintf("%.1fms", float64(d.Milliseconds()))
	default:
		return fmt.Sprintf("%.2fs", d.Seconds())
	}
}

func printTestStart(name string) {
	fmt.Printf("   test %-30s ...", name)
}

func printTestPass(d time.Duration) {
	fmt.Printf(" ok (%s)\n", formatDuration(d))
}

func printTestFail(err error, d time.Duration) {
	fmt.Printf(" fail %v (%s)\n", err, formatDuration(d))
}

func test_TPCDS_Q2_result() {
	expect(_equal(result, []v{v{
		D_week_seq1: 1,
		Sun_ratio:   0.5,
		Mon_ratio:   0.5,
	}}))
}

var web_sales []Web_sale
var catalog_sales []Catalog_sale
var date_dim []Date_dim
var wscs []v
var wswscs []Wswsc
var year1 []Wswsc
var year2 []Wswsc
var result []Result

func main() {
	web_sales = []Web_sale{
		Web_sale{
			Ws_sold_date_sk:    1,
			Ws_ext_sales_price: 5.0,
			Ws_sold_date_name:  "Sunday",
		},
		Web_sale{
			Ws_sold_date_sk:    2,
			Ws_ext_sales_price: 5.0,
			Ws_sold_date_name:  "Monday",
		},
		Web_sale{
			Ws_sold_date_sk:    8,
			Ws_ext_sales_price: 10.0,
			Ws_sold_date_name:  "Sunday",
		},
		Web_sale{
			Ws_sold_date_sk:    9,
			Ws_ext_sales_price: 10.0,
			Ws_sold_date_name:  "Monday",
		},
	}
	catalog_sales = []Catalog_sale{
		Catalog_sale{
			Cs_sold_date_sk:    1,
			Cs_ext_sales_price: 5.0,
			Cs_sold_date_name:  "Sunday",
		},
		Catalog_sale{
			Cs_sold_date_sk:    2,
			Cs_ext_sales_price: 5.0,
			Cs_sold_date_name:  "Monday",
		},
		Catalog_sale{
			Cs_sold_date_sk:    8,
			Cs_ext_sales_price: 10.0,
			Cs_sold_date_name:  "Sunday",
		},
		Catalog_sale{
			Cs_sold_date_sk:    9,
			Cs_ext_sales_price: 10.0,
			Cs_sold_date_name:  "Monday",
		},
	}
	date_dim = []Date_dim{
		Date_dim{
			D_date_sk:  1,
			D_week_seq: 1,
			D_day_name: "Sunday",
			D_year:     1998,
		},
		Date_dim{
			D_date_sk:  2,
			D_week_seq: 1,
			D_day_name: "Monday",
			D_year:     1998,
		},
		Date_dim{
			D_date_sk:  8,
			D_week_seq: 54,
			D_day_name: "Sunday",
			D_year:     1999,
		},
		Date_dim{
			D_date_sk:  9,
			D_week_seq: 54,
			D_day_name: "Monday",
			D_year:     1999,
		},
	}
	wscs = append(append([]v{}, (func() []v {
		results := []v{}
		for _, ws := range web_sales {
			results = append(results, v{
				Sold_date_sk: ws.Ws_sold_date_sk,
				Sales_price:  ws.Ws_ext_sales_price,
				Day:          ws.Ws_sold_date_name,
			})
		}
		return results
	}())...), (func() []v {
		results := []v{}
		for _, cs := range catalog_sales {
			results = append(results, v{
				Sold_date_sk: cs.Cs_sold_date_sk,
				Sales_price:  cs.Cs_ext_sales_price,
				Day:          cs.Cs_sold_date_name,
			})
		}
		return results
	}())...)
	wswscs = func() []Wswsc {
		groups := map[string]*data.Group{}
		order := []string{}
		for _, w := range wscs {
			for _, d := range date_dim {
				if !(w.Sold_date_sk == d.D_date_sk) {
					continue
				}
				key := GKey{Week_seq: d.D_week_seq}
				ks := fmt.Sprint(key)
				g, ok := groups[ks]
				if !ok {
					g = &data.Group{Key: key}
					groups[ks] = g
					order = append(order, ks)
				}
				_item := map[string]any{}
				_item["sold_date_sk"] = w.Sold_date_sk
				_item["sales_price"] = w.Sales_price
				_item["day"] = w.Day
				_item["w"] = w
				_item["d_date_sk"] = d.D_date_sk
				_item["d_week_seq"] = d.D_week_seq
				_item["d_day_name"] = d.D_day_name
				_item["d_year"] = d.D_year
				_item["d"] = d
				g.Items = append(g.Items, _item)
			}
		}
		items := []*data.Group{}
		for _, ks := range order {
			items = append(items, groups[ks])
		}
		results := []Wswsc{}
		for _, g := range items {
			results = append(results, Wswsc{
				D_week_seq: g.Key.(GKey).Week_seq,
				Sun_sales: _sumOrdered[float64](func() []float64 {
					results := []float64{}
					for _, x := range g.Items {
						if x.Day == "Sunday" {
							if x.Day == "Sunday" {
								results = append(results, x.Sales_price)
							}
						}
					}
					return results
				}()),
				Mon_sales: _sumOrdered[float64](func() []float64 {
					results := []float64{}
					for _, x := range g.Items {
						if x.Day == "Monday" {
							if x.Day == "Monday" {
								results = append(results, x.Sales_price)
							}
						}
					}
					return results
				}()),
				Tue_sales: _sumOrdered[float64](func() []float64 {
					results := []float64{}
					for _, x := range g.Items {
						if x.Day == "Tuesday" {
							if x.Day == "Tuesday" {
								results = append(results, x.Sales_price)
							}
						}
					}
					return results
				}()),
				Wed_sales: _sumOrdered[float64](func() []float64 {
					results := []float64{}
					for _, x := range g.Items {
						if x.Day == "Wednesday" {
							if x.Day == "Wednesday" {
								results = append(results, x.Sales_price)
							}
						}
					}
					return results
				}()),
				Thu_sales: _sumOrdered[float64](func() []float64 {
					results := []float64{}
					for _, x := range g.Items {
						if x.Day == "Thursday" {
							if x.Day == "Thursday" {
								results = append(results, x.Sales_price)
							}
						}
					}
					return results
				}()),
				Fri_sales: _sumOrdered[float64](func() []float64 {
					results := []float64{}
					for _, x := range g.Items {
						if x.Day == "Friday" {
							if x.Day == "Friday" {
								results = append(results, x.Sales_price)
							}
						}
					}
					return results
				}()),
				Sat_sales: _sumOrdered[float64](func() []float64 {
					results := []float64{}
					for _, x := range g.Items {
						if x.Day == "Saturday" {
							if x.Day == "Saturday" {
								results = append(results, x.Sales_price)
							}
						}
					}
					return results
				}()),
			})
		}
		return results
	}()
	year1 = func() []Wswsc {
		results := []Wswsc{}
		for _, w := range wswscs {
			if _equal(w.D_week_seq, 1) {
				if _equal(w.D_week_seq, 1) {
					results = append(results, w)
				}
			}
		}
		return results
	}()
	year2 = func() []Wswsc {
		results := []Wswsc{}
		for _, w := range wswscs {
			if _equal(w.D_week_seq, 54) {
				if _equal(w.D_week_seq, 54) {
					results = append(results, w)
				}
			}
		}
		return results
	}()
	result = func() []Result {
		results := []Result{}
		for _, y := range year1 {
			for _, z := range year2 {
				if !(_equal(y.D_week_seq, ((z.D_week_seq).(float64) - float64(53)))) {
					continue
				}
				results = append(results, Result{
					D_week_seq1: y.D_week_seq,
					Sun_ratio:   (y.Sun_sales / z.Sun_sales),
					Mon_ratio:   (y.Mon_sales / z.Mon_sales),
				})
			}
		}
		return results
	}()
	func() { b, _ := json.Marshal(result); fmt.Println(string(b)) }()
	test_TPCDS_Q2_result()
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}

func _sumOrdered[T constraints.Integer | constraints.Float](s []T) float64 {
	var sum float64
	for _, v := range s {
		sum += float64(v)
	}
	return sum
}
