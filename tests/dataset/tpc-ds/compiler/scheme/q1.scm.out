(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (srfi 95) (chibi string))
(define (_fetch url opts)
  (let* ((method (if (and opts (assq 'method opts)) (cdr (assq 'method opts)) "GET"))
         (args (list "curl" "-s" "-X" method)))
    (when (and opts (assq 'headers opts))
      (for-each (lambda (p)
                  (set! args (append args (list "-H" (format "~a: ~a" (car p) (cdr p))))))
                (cdr (assq 'headers opts))))
    (when (and opts (assq 'query opts))
      (let* ((q (cdr (assq 'query opts)))
             (qs (string-join (map (lambda (p) (format "~a=~a" (car p) (cdr p))) q) "&")))
        (set! url (string-append url (if (string-contains url "?") "&" "?") qs))))
    (when (and opts (assq 'body opts))
      (set! args (append args (list "-d" (json->string (cdr (assq 'body opts)))))))
    (when (and opts (assq 'timeout opts))
      (set! args (append args (list "--max-time" (format "~a" (cdr (assq 'timeout opts)))))))
    (set! args (append args (list url)))
    (let* ((p (open-input-pipe (string-join args " ")))
           (txt (port->string p)))
      (close-input-port p)
      (string->json txt))))

(define (_load path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (in (if (or (not path) (string=? path "") (string=? path "-"))
                 (current-input-port)
                 (open-input-file path)))
         (text (port->string in)))
    (when (not (eq? in (current-input-port)))
      (close-input-port in))
    (cond ((string=? fmt "jsonl")
           (map string->json
                (filter (lambda (l) (not (string=? l "")))
                        (string-split text #\newline))))
          (else
           (let ((d (string->json text)))
             (if (list? d) d (list d)))))))

(define (_save rows path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (out (if (or (not path) (string=? path "") (string=? path "-"))
                  (current-output-port)
                  (open-output-file path))))
    (cond ((string=? fmt "jsonl")
           (for-each (lambda (r) (write-string (json->string r) out) (newline out)) rows))
          (else
           (write-string (json->string rows) out)))
    (when (not (eq? out (current-output-port)))
      (close-output-port out))))

(define (_sort pairs)
  (sort pairs
        (lambda (a b)
          (let ((ka (cdr a)) (kb (cdr b)))
            (cond ((and (number? ka) (number? kb)) (< ka kb))
                  ((and (string? ka) (string? kb)) (string<? ka kb))
                  (else (string<? (format "~a" ka) (format "~a" kb))))))))
(define (_count v)
  (cond
    ((string? v) (string-length v))
    ((and (pair? v) (assq 'Items v)) (length (cdr (assq 'Items v))))
    ((list? v) (length v))
    (else 0)))

(define (_sum v)
  (let* ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
         (s (if (null? lst) 0 (apply + lst))))
    s))

(define (_avg v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (n 0))
    (set! n (length lst))
    (if (= n 0) 0 (/ (_sum lst) n))))

(define (_group_by src keyfn)
  (let ((groups '()) (order '()))
    (for-each (lambda (it)
                (let* ((key (keyfn it))
                       (ks (format "~a" key))
                       (pair (assoc ks groups)))
                  (if pair
                      (let* ((grp (cdr pair))
                             (items (cdr (assq 'Items grp))))
                        (set-cdr! (assq 'Items grp) (append items (list it))))
                      (begin
                        (set! groups (append groups (list (cons ks (list (cons 'key key) (cons 'Items (list it)))))))
                        (set! order (append order (list ks))))))
              src)
    (map (lambda (k) (cdr (assoc k groups))) order))))
(define (_json v)
  (write v)
  (newline))
(define failures 0)
(define (print-test-start name)
  (display "   test ") (display name) (display " ..."))
(define (print-test-pass) (display " ok") (newline))
(define (print-test-fail err) (display " fail ") (display err) (newline))
(define (run-test name thunk)
  (print-test-start name)
  (let ((ok #t))
    (with-exception-handler
      (lambda (e)
        (set! ok #f)
        (set! failures (+ failures 1))
        (print-test-fail e))
      (lambda () (thunk)))
    (when ok (print-test-pass))))

(define (test_TPCDS_Q1_empty)
  (when (not (equal? (length result) 0)) (error "expect failed"))
)

(define store_returns (list ))
(define date_dim (list ))
(define store (list ))
(define customer (list ))
(define customer_total_return (let ((_tmp '()))
  (for-each (lambda (sr)
    (for-each (lambda (d)
      (when (equal? (map-get sr "sr_returned_date_sk") (map-get d "d_date_sk"))
        (when (equal? (map-get d "d_year") 1998)
          (set! _tmp (append _tmp (list sr)))
        )
      )) (if (string? date_dim) (string->list date_dim) date_dim))
  ) (if (string? store_returns) (string->list store_returns) store_returns))
  (let ((_res '()))
    (for-each (lambda (g)
      (set! _res (append _res (list (list (cons "ctr_customer_sk" (map-get (map-get g "key") "customer_sk")) (cons "ctr_store_sk" (map-get (map-get g "key") "store_sk")) (cons "ctr_total_return" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "sr_return_amt"))))
  ) (if (string? g) (string->list g) g))
  _res)))))))
    ) (_group_by _tmp (lambda (sr) (list (cons "customer_sk" (map-get sr "sr_customer_sk")) (cons "store_sk" (map-get sr "sr_store_sk"))))))
    _res)))
(define result (let ((_res '()) (_tmp '()))
  (for-each (lambda (ctr1)
    (for-each (lambda (s)
      (when (equal? (map-get ctr1 "ctr_store_sk") (map-get s "s_store_sk"))
        (for-each (lambda (c)
          (when (equal? (map-get ctr1 "ctr_customer_sk") (map-get c "c_customer_sk"))
            (when (equal? (and (* (> (map-get ctr1 "ctr_total_return") (_avg (let ((_res '()))
  (for-each (lambda (ctr2)
    (when (equal? (map-get ctr1 "ctr_store_sk") (map-get ctr2 "ctr_store_sk"))
      (set! _res (append _res (list (map-get ctr2 "ctr_total_return"))))
    )
  ) (if (string? customer_total_return) (string->list customer_total_return) customer_total_return))
  _res))) 1.2) (map-get s "s_state")) "TN")
              (set! _tmp (append _tmp (list (cons (list (cons "c_customer_id" (map-get c "c_customer_id"))) (map-get c "c_customer_id")))))
            )
          )) (if (string? customer) (string->list customer) customer))
      )) (if (string? store) (string->list store) store))
  ) (if (string? customer_total_return) (string->list customer_total_return) customer_total_return))
  (set! _res (_sort _tmp))
  (set! _res (map car _res))
  _res))
(_json result)
(run-test "TPCDS Q1 empty" test_TPCDS_Q1_empty)
(when (> failures 0) (display "\n[FAIL] ") (display failures) (display " test(s) failed.\n"))
