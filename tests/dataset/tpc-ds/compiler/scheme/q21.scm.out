(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (srfi 95))

(define (_fetch url opts)
  (let* ((method (if (and opts (assq 'method opts)) (cdr (assq 'method opts)) "GET"))
         (args (list "curl" "-s" "-X" method)))
    (when (and opts (assq 'headers opts))
      (for-each (lambda (p)
                  (set! args (append args (list "-H" (format "~a: ~a" (car p) (cdr p))))))
                (cdr (assq 'headers opts))))
    (when (and opts (assq 'query opts))
      (let* ((q (cdr (assq 'query opts)))
             (qs (string-join (map (lambda (p) (format "~a=~a" (car p) (cdr p))) q) "&")))
        (set! url (string-append url (if (string-contains url "?") "&" "?") qs))))
    (when (and opts (assq 'body opts))
      (set! args (append args (list "-d" (json->string (cdr (assq 'body opts)))))))
    (when (and opts (assq 'timeout opts))
      (set! args (append args (list "--max-time" (format "~a" (cdr (assq 'timeout opts)))))))
    (set! args (append args (list url)))
    (let* ((p (open-input-pipe (string-join args " ")))
           (txt (port->string p)))
      (close-input-port p)
      (string->json txt))))

(define (_load path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (in (if (or (not path) (string=? path "") (string=? path "-"))
                 (current-input-port)
                 (open-input-file path)))
         (text (port->string in)))
    (when (not (eq? in (current-input-port)))
      (close-input-port in))
    (cond ((string=? fmt "jsonl")
           (map string->json
                (filter (lambda (l) (not (string=? l "")))
                        (string-split text #\newline))))
          (else
           (let ((d (string->json text)))
             (if (list? d) d (list d)))))))

(define (_save rows path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (out (if (or (not path) (string=? path "") (string=? path "-"))
                  (current-output-port)
                  (open-output-file path))))
    (cond ((string=? fmt "jsonl")
           (for-each (lambda (r) (write-string (json->string r) out) (newline out)) rows))
          (else
           (write-string (json->string rows) out)))
    (when (not (eq? out (current-output-port)))
      (close-output-port out))))

(define (_lt a b)
  (cond
    ((and (number? a) (number? b)) (< a b))
    ((and (string? a) (string? b)) (string<? a b))
    ((and (pair? a) (pair? b))
      (cond
        ((null? a) (not (null? b)))
        ((null? b) #f)
        (else (let ((ka (car a)) (kb (car b)))
                (if (equal? ka kb)
                    (_lt (cdr a) (cdr b))
                    (_lt ka kb)))))
    )
    (else (string<? (format "~a" a) (format "~a" b)))))

(define (_sort pairs)
  (sort pairs (lambda (a b) (_lt (cdr a) (cdr b)))))
(define (_count v)
  (cond
    ((string? v) (string-length v))
    ((and (pair? v) (assq 'Items v)) (length (cdr (assq 'Items v))))
    ((list? v) (length v))
    (else 0)))

(define (_sum v)
  (let* ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
         (s (if (null? lst) 0 (apply + lst))))
    s))

(define (_avg v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (n 0))
    (set! n (length lst))
    (if (= n 0) 0 (/ (_sum lst) n)))

(define (_max v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (m 0))
    (when (not (null? lst))
      (set! m (car lst))
      (for-each (lambda (n)
                  (when (> n m) (set! m n)))
                (cdr lst)))
    m))

(define (_group_by src keyfn)

(define (_group_by src keyfn)
  (let ((groups '()) (order '()))
    (for-each (lambda (it)
                (let* ((key (keyfn it))
                       (ks (format "~a" key))
                       (pair (assoc ks groups)))
                  (if pair
                      (let* ((grp (cdr pair))
                             (items (cdr (assq 'Items grp))))
                        (set-cdr! (assq 'Items grp) (append items (list it))))
                      (begin
                        (set! groups (append groups (list (cons ks (list (cons 'key key) (cons 'Items (list it)))))))
                        (set! order (append order (list ks))))))
              src)
    (map (lambda (k) (cdr (assoc k groups))) order))))
(define (_json v)
  (write v)
  (newline))
(define failures 0)
(define (print-test-start name)
  (display "   test ") (display name) (display " ..."))
(define (print-test-pass) (display " ok") (newline))
(define (print-test-fail err) (display " fail ") (display err) (newline))
(define (run-test name thunk)
  (print-test-start name)
  (let ((ok #t))
    (with-exception-handler
      (lambda (e)
        (set! ok #f)
        (set! failures (+ failures 1))
        (print-test-fail e))
      (lambda () (thunk)))
    (when ok (print-test-pass))))

(define (new-Inventory inv_item_sk inv_warehouse_sk inv_date_sk inv_quantity_on_hand)
  (list (cons 'inv_item_sk inv_item_sk) (cons 'inv_warehouse_sk inv_warehouse_sk) (cons 'inv_date_sk inv_date_sk) (cons 'inv_quantity_on_hand inv_quantity_on_hand))
)

(define (new-Warehouse w_warehouse_sk w_warehouse_name)
  (list (cons 'w_warehouse_sk w_warehouse_sk) (cons 'w_warehouse_name w_warehouse_name))
)

(define (new-Item i_item_sk i_item_id)
  (list (cons 'i_item_sk i_item_sk) (cons 'i_item_id i_item_id))
)

(define (new-DateDim d_date_sk d_date)
  (list (cons 'd_date_sk d_date_sk) (cons 'd_date d_date))
)

(define (test_TPCDS_Q21_inventory_ratio)
  (when (not (equal? result (list (list (cons "w_warehouse_name" "Main") (cons "i_item_id" "ITEM1") (cons "inv_before" 30) (cons "inv_after" 40))))) (error "expect failed"))
)

(define inventory (list (list (cons "inv_item_sk" 1) (cons "inv_warehouse_sk" 1) (cons "inv_date_sk" 1) (cons "inv_quantity_on_hand" 30)) (list (cons "inv_item_sk" 1) (cons "inv_warehouse_sk" 1) (cons "inv_date_sk" 2) (cons "inv_quantity_on_hand" 40)) (list (cons "inv_item_sk" 2) (cons "inv_warehouse_sk" 2) (cons "inv_date_sk" 1) (cons "inv_quantity_on_hand" 20)) (list (cons "inv_item_sk" 2) (cons "inv_warehouse_sk" 2) (cons "inv_date_sk" 2) (cons "inv_quantity_on_hand" 20))))
(define warehouse (list (list (cons "w_warehouse_sk" 1) (cons "w_warehouse_name" "Main")) (list (cons "w_warehouse_sk" 2) (cons "w_warehouse_name" "Backup"))))
(define item (list (list (cons "i_item_sk" 1) (cons "i_item_id" "ITEM1")) (list (cons "i_item_sk" 2) (cons "i_item_id" "ITEM2"))))
(define date_dim (list (list (cons "d_date_sk" 1) (cons "d_date" "2000-03-01")) (list (cons "d_date_sk" 2) (cons "d_date" "2000-03-20"))))
(define before (let ((_tmp '()))
  (for-each (lambda (inv)
    (for-each (lambda (d)
      (when (equal? (map-get inv "inv_date_sk") (map-get d "d_date_sk"))
        (when (< (map-get d "d_date") "2000-03-15")
          (set! _tmp (append _tmp (list inv)))
        )
      )) (if (string? date_dim) (string->list date_dim) date_dim))
  ) (if (string? inventory) (string->list inventory) inventory))
  (let ((_res '()))
    (for-each (lambda (g)
      (set! _res (append _res (list (list (cons "w" (map-get (map-get g "key") "w")) (cons "i" (map-get (map-get g "key") "i")) (cons "qty" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "inv_quantity_on_hand"))))
  ) (if (string? g) (string->list g) g))
  _res)))))))
    ) (_group_by _tmp (lambda (inv) (list (cons "w" (map-get inv "inv_warehouse_sk")) (cons "i" (map-get inv "inv_item_sk"))))))
    _res)))
(define after (let ((_tmp '()))
  (for-each (lambda (inv)
    (for-each (lambda (d)
      (when (equal? (map-get inv "inv_date_sk") (map-get d "d_date_sk"))
        (when (>= (map-get d "d_date") "2000-03-15")
          (set! _tmp (append _tmp (list inv)))
        )
      )) (if (string? date_dim) (string->list date_dim) date_dim))
  ) (if (string? inventory) (string->list inventory) inventory))
  (let ((_res '()))
    (for-each (lambda (g)
      (set! _res (append _res (list (list (cons "w" (map-get (map-get g "key") "w")) (cons "i" (map-get (map-get g "key") "i")) (cons "qty" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "inv_quantity_on_hand"))))
  ) (if (string? g) (string->list g) g))
  _res)))))))
    ) (_group_by _tmp (lambda (inv) (list (cons "w" (map-get inv "inv_warehouse_sk")) (cons "i" (map-get inv "inv_item_sk"))))))
    _res)))
(define joined (let ((_res '()))
  (for-each (lambda (b)
    (for-each (lambda (a)
      (when (equal? (and (equal? (map-get b "w") (map-get a "w")) (map-get b "i")) (map-get a "i"))
        (for-each (lambda (w)
          (when (equal? (map-get w "w_warehouse_sk") (map-get b "w"))
            (for-each (lambda (it)
              (when (equal? (map-get it "i_item_sk") (map-get b "i"))
                (set! _res (append _res (list (list (cons "w_name" (map-get w "w_warehouse_name")) (cons "i_id" (map-get it "i_item_id")) (cons "before_qty" (map-get b "qty")) (cons "after_qty" (map-get a "qty")) (cons "ratio" (/ (map-get a "qty") (map-get b "qty")))))))
              )) (if (string? item) (string->list item) item))
          )) (if (string? warehouse) (string->list warehouse) warehouse))
      )) (if (string? after) (string->list after) after))
  ) (if (string? before) (string->list before) before))
  _res))
(define result (let ((_res '()) (_tmp '()))
  (for-each (lambda (r)
    (when (<= (and (>= (map-get r "ratio") (/ 2.0 3.0)) (map-get r "ratio")) (/ 3.0 2.0))
      (set! _tmp (append _tmp (list (cons (list (cons "w_warehouse_name" (map-get r "w_name")) (cons "i_item_id" (map-get r "i_id")) (cons "inv_before" (map-get r "before_qty")) (cons "inv_after" (map-get r "after_qty"))) (list (map-get r "w_name") (map-get r "i_id"))))))
    )
  ) (if (string? joined) (string->list joined) joined))
  (set! _res (_sort _tmp))
  (set! _res (map car _res))
  _res))
(_json result)
(run-test "TPCDS Q21 inventory ratio" test_TPCDS_Q21_inventory_ratio)
(when (> failures 0) (display "\n[FAIL] ") (display failures) (display " test(s) failed.\n"))
