(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (srfi 95))

(define (_fetch url opts)
  (let* ((method (if (and opts (assq 'method opts)) (cdr (assq 'method opts)) "GET"))
         (args (list "curl" "-s" "-X" method)))
    (when (and opts (assq 'headers opts))
      (for-each (lambda (p)
                  (set! args (append args (list "-H" (format "~a: ~a" (car p) (cdr p))))))
                (cdr (assq 'headers opts))))
    (when (and opts (assq 'query opts))
      (let* ((q (cdr (assq 'query opts)))
             (qs (string-join (map (lambda (p) (format "~a=~a" (car p) (cdr p))) q) "&")))
        (set! url (string-append url (if (string-contains url "?") "&" "?") qs))))
    (when (and opts (assq 'body opts))
      (set! args (append args (list "-d" (json->string (cdr (assq 'body opts)))))))
    (when (and opts (assq 'timeout opts))
      (set! args (append args (list "--max-time" (format "~a" (cdr (assq 'timeout opts)))))))
    (set! args (append args (list url)))
    (let* ((p (open-input-pipe (string-join args " ")))
           (txt (port->string p)))
      (close-input-port p)
      (string->json txt))))

(define (_load path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (in (if (or (not path) (string=? path "") (string=? path "-"))
                 (current-input-port)
                 (open-input-file path)))
         (text (port->string in)))
    (when (not (eq? in (current-input-port)))
      (close-input-port in))
    (cond ((string=? fmt "jsonl")
           (map string->json
                (filter (lambda (l) (not (string=? l "")))
                        (string-split text #\newline))))
          (else
           (let ((d (string->json text)))
             (if (list? d) d (list d)))))))

(define (_save rows path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (out (if (or (not path) (string=? path "") (string=? path "-"))
                  (current-output-port)
                  (open-output-file path))))
    (cond ((string=? fmt "jsonl")
           (for-each (lambda (r) (write-string (json->string r) out) (newline out)) rows))
          (else
           (write-string (json->string rows) out)))
    (when (not (eq? out (current-output-port)))
      (close-output-port out))))

(define (_sort pairs)
  (sort pairs
        (lambda (a b)
          (let ((ka (cdr a)) (kb (cdr b)))
            (cond ((and (number? ka) (number? kb)) (< ka kb))
                  ((and (string? ka) (string? kb)) (string<? ka kb))
                  (else (string<? (format "~a" ka) (format "~a" kb))))))))
(define (_count v)
  (cond
    ((string? v) (string-length v))
    ((and (pair? v) (assq 'Items v)) (length (cdr (assq 'Items v))))
    ((list? v) (length v))
    (else 0)))

(define (_sum v)
  (let* ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
         (s (if (null? lst) 0 (apply + lst))))
    s))

(define (_avg v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (n 0))
    (set! n (length lst))
    (if (= n 0) 0 (/ (_sum lst) n))))

(define (_group_by src keyfn)
  (let ((groups '()) (order '()))
    (for-each (lambda (it)
                (let* ((key (keyfn it))
                       (ks (format "~a" key))
                       (pair (assoc ks groups)))
                  (if pair
                      (let* ((grp (cdr pair))
                             (items (cdr (assq 'Items grp))))
                        (set-cdr! (assq 'Items grp) (append items (list it))))
                      (begin
                        (set! groups (append groups (list (cons ks (list (cons 'key key) (cons 'Items (list it)))))))
                        (set! order (append order (list ks))))))
              src)
    (map (lambda (k) (cdr (assoc k groups))) order))))
(define (_json v)
  (write v)
  (newline))
(define failures 0)
(define (print-test-start name)
  (display "   test ") (display name) (display " ..."))
(define (print-test-pass) (display " ok") (newline))
(define (print-test-fail err) (display " fail ") (display err) (newline))
(define (run-test name thunk)
  (print-test-start name)
  (let ((ok #t))
    (with-exception-handler
      (lambda (e)
        (set! ok #f)
        (set! failures (+ failures 1))
        (print-test-fail e))
      (lambda () (thunk)))
    (when ok (print-test-pass))))

(define (new-WebSale ws_item_sk ws_sold_date_sk ws_ext_sales_price)
  (list (cons 'ws_item_sk ws_item_sk) (cons 'ws_sold_date_sk ws_sold_date_sk) (cons 'ws_ext_sales_price ws_ext_sales_price))
)

(define (new-Item i_item_sk i_item_id i_item_desc i_category i_class i_current_price)
  (list (cons 'i_item_sk i_item_sk) (cons 'i_item_id i_item_id) (cons 'i_item_desc i_item_desc) (cons 'i_category i_category) (cons 'i_class i_class) (cons 'i_current_price i_current_price))
)

(define (new-DateDim d_date_sk d_date)
  (list (cons 'd_date_sk d_date_sk) (cons 'd_date d_date))
)

(define (test_TPCDS_Q12_revenue_ratio)
  (when (not (equal? result (list (list (cons "i_item_id" "ITEM1") (cons "i_item_desc" "Item One") (cons "i_category" "A") (cons "i_class" "C1") (cons "i_current_price" 10.0) (cons "itemrevenue" 200.0) (cons "revenueratio" 50.0)) (list (cons "i_item_id" "ITEM2") (cons "i_item_desc" "Item Two") (cons "i_category" "A") (cons "i_class" "C1") (cons "i_current_price" 20.0) (cons "itemrevenue" 200.0) (cons "revenueratio" 50.0))))) (error "expect failed"))
)

(define web_sales (list (list (cons "ws_item_sk" 1) (cons "ws_sold_date_sk" 1) (cons "ws_ext_sales_price" 100.0)) (list (cons "ws_item_sk" 1) (cons "ws_sold_date_sk" 2) (cons "ws_ext_sales_price" 100.0)) (list (cons "ws_item_sk" 2) (cons "ws_sold_date_sk" 2) (cons "ws_ext_sales_price" 200.0)) (list (cons "ws_item_sk" 3) (cons "ws_sold_date_sk" 3) (cons "ws_ext_sales_price" 50.0))))
(define item (list (list (cons "i_item_sk" 1) (cons "i_item_id" "ITEM1") (cons "i_item_desc" "Item One") (cons "i_category" "A") (cons "i_class" "C1") (cons "i_current_price" 10.0)) (list (cons "i_item_sk" 2) (cons "i_item_id" "ITEM2") (cons "i_item_desc" "Item Two") (cons "i_category" "A") (cons "i_class" "C1") (cons "i_current_price" 20.0)) (list (cons "i_item_sk" 3) (cons "i_item_id" "ITEM3") (cons "i_item_desc" "Item Three") (cons "i_category" "B") (cons "i_class" "C2") (cons "i_current_price" 30.0))))
(define date_dim (list (list (cons "d_date_sk" 1) (cons "d_date" "2001-01-20")) (list (cons "d_date_sk" 2) (cons "d_date" "2001-02-05")) (list (cons "d_date_sk" 3) (cons "d_date" "2001-03-05"))))
(define filtered (let ((_tmp '()))
  (for-each (lambda (ws)
    (for-each (lambda (i)
      (when (equal? (map-get ws "ws_item_sk") (map-get i "i_item_sk"))
        (for-each (lambda (d)
          (when (equal? (map-get ws "ws_sold_date_sk") (map-get d "d_date_sk"))
            (when (<= (and (>= (and (if (member (map-get i "i_category") (list "A" "B" "C")) #t #f) (map-get d "d_date")) "2001-01-15") (map-get d "d_date")) "2001-02-14")
              (set! _tmp (append _tmp (list ws)))
            )
          )) (if (string? date_dim) (string->list date_dim) date_dim))
      )) (if (string? item) (string->list item) item))
  ) (if (string? web_sales) (string->list web_sales) web_sales))
  (let ((_res '()))
    (for-each (lambda (g)
      (set! _res (append _res (list (list (cons "i_item_id" (map-get (map-get g "key") "id")) (cons "i_item_desc" (map-get (map-get g "key") "desc")) (cons "i_category" (map-get (map-get g "key") "cat")) (cons "i_class" (map-get (map-get g "key") "class")) (cons "i_current_price" (map-get (map-get g "key") "price")) (cons "itemrevenue" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "ws_ext_sales_price"))))
  ) (if (string? g) (string->list g) g))
  _res)))))))
    ) (_group_by _tmp (lambda (ws) (list (cons "id" (map-get i "i_item_id")) (cons "desc" (map-get i "i_item_desc")) (cons "cat" (map-get i "i_category")) (cons "class" (map-get i "i_class")) (cons "price" (map-get i "i_current_price"))))))
    _res)))
(define class_totals (let ((_tmp '()))
  (for-each (lambda (f)
    (set! _tmp (append _tmp (list f)))
  ) (if (string? filtered) (string->list filtered) filtered))
  (let ((_res '()))
    (for-each (lambda (g)
      (set! _res (append _res (list (list (cons "class" (map-get g "key")) (cons "total" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "itemrevenue"))))
  ) (if (string? g) (string->list g) g))
  _res)))))))
    ) (_group_by _tmp (lambda (f) (map-get f "i_class"))))
    _res)))
(define result (let ((_res '()) (_tmp '()))
  (for-each (lambda (f)
    (for-each (lambda (t)
      (when (equal? (map-get f "i_class") (map-get t "class"))
        (set! _tmp (append _tmp (list (cons (list (cons "i_item_id" (map-get f "i_item_id")) (cons "i_item_desc" (map-get f "i_item_desc")) (cons "i_category" (map-get f "i_category")) (cons "i_class" (map-get f "i_class")) (cons "i_current_price" (map-get f "i_current_price")) (cons "itemrevenue" (map-get f "itemrevenue")) (cons "revenueratio" (/ (* (map-get f "itemrevenue") 100.0) (map-get t "total")))) (list (map-get f "i_category") (map-get f "i_class") (map-get f "i_item_id") (map-get f "i_item_desc"))))))
      )) (if (string? class_totals) (string->list class_totals) class_totals))
  ) (if (string? filtered) (string->list filtered) filtered))
  (set! _res (_sort _tmp))
  (set! _res (map car _res))
  _res))
(_json result)
(run-test "TPCDS Q12 revenue ratio" test_TPCDS_Q12_revenue_ratio)
(when (> failures 0) (display "\n[FAIL] ") (display failures) (display " test(s) failed.\n"))
