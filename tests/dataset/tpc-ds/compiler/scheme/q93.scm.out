; Generated by Mochi compiler v0.10.26 on 2025-07-15T07:38:05Z
(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (srfi 1) (srfi 95) (chibi json) (chibi io) (chibi process) (chibi) (chibi string))

(define (_fmt . parts)
  (apply string-append (map _to_string parts)))

(define (_to_string v)
  (call-with-output-string (lambda (p) (write v p))))

(define (_yaml_value v)
  (let ((n (string->number v)))
    (if n n v)))

(define (_parse_yaml text)
  (let ((rows '()) (cur '()))
    (for-each (lambda (ln)
                (when (and (>= (string-length ln) 2) (string-prefix? "- " ln))
                  (when (not (null? cur))
                    (set! rows (append rows (list cur))))
                  (set! cur '())
                  (set! ln (substring ln 2 (string-length ln))))
                (when (string-contains ln ":")
                  (let* ((p (string-split ln #\:))
                         (k (string-trim (car p)))
                         (val (string-trim (string-join (cdr p) ":"))))
                    (set! cur (append cur (list (cons k (_yaml_value val))))))))
              (string-split text #\newline))
    (when (not (null? cur))
      (set! rows (append rows (list cur))))
    rows))

(define (_fetch url opts)
  (let* ((method (if (and opts (assq 'method opts)) (cdr (assq 'method opts)) "GET"))
         (args (list "curl" "-s" "-X" method)))
    (when (and opts (assq 'headers opts))
      (for-each (lambda (p)
                  (set! args (append args (list "-H" (_fmt (car p) ": " (cdr p))))))
                (cdr (assq 'headers opts))))
    (when (and opts (assq 'query opts))
      (let* ((q (cdr (assq 'query opts)))
             (qs (string-join (map (lambda (p) (_fmt (car p) "=" (cdr p))) q) "&")))
        (set! url (string-append url (if (string-contains url "?") "&" "?") qs))))
    (when (and opts (assq 'body opts))
      (set! args (append args (list "-d" (json->string (cdr (assq 'body opts)))))))
    (when (and opts (assq 'timeout opts))
      (set! args (append args (list "--max-time" (_to_string (cdr (assq 'timeout opts)))))))
    (set! args (append args (list url)))
    (let* ((p (open-input-pipe (string-join args " ")))
           (txt (port->string p)))
      (close-input-port p)
      (string->json txt))))

(define (_load path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (in (if (or (not path) (string=? path "") (string=? path "-"))
                 (current-input-port)
                 (open-input-file path)))
         (text (port->string in)))
    (when (not (eq? in (current-input-port)))
      (close-input-port in))
    (cond ((string=? fmt "jsonl")
           (map string->json
                (filter (lambda (l) (not (string=? l "")))
                        (string-split text #\newline))))
          ((string=? fmt "yaml")
           (_parse_yaml text))
          (else
           (let ((d (string->json text)))
             (if (list? d) d (list d)))))))

(define (_save rows path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (out (if (or (not path) (string=? path "") (string=? path "-"))
                  (current-output-port)
                  (open-output-file path))))
  (cond ((string=? fmt "jsonl")
           (for-each (lambda (r) (write-string (json->string r) out) (newline out)) rows))
          (else
           (write-string (json->string rows) out)))
    (when (not (eq? out (current-output-port)))
      (close-output-port out))))

(define (_date_number s)
  (let ((parts (string-split s #\-)))
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_lt a b)
  (cond
    ((and (number? a) (number? b)) (< a b))
    ((and (string? a) (string? b))
      (let ((da (_date_number a))
            (db (_date_number b)))
        (if (and da db)
            (< da db)
            (string<? a b))))
    ((and (pair? a) (pair? b))
      (cond
        ((null? a) (not (null? b)))
        ((null? b) #f)
        (else (let ((ka (car a)) (kb (car b)))
                (if (equal? ka kb)
                    (_lt (cdr a) (cdr b))
                    (_lt ka kb)))))
    )
    (else (string<? (_to_string a) (_to_string b)))))

(define (_le a b)
  (or (_lt a b) (equal? a b)))

(define (_gt a b)
  (_lt b a))

(define (_ge a b)
  (or (_gt a b) (equal? a b)))

(define (_sort pairs)
  (letrec ((cmp (lambda (a b) (_lt (cdr a) (cdr b))))
           (insert (lambda (x lst)
                     (cond ((null? lst) (list x))
                           ((cmp x (car lst)) (cons x lst))
                           (else (cons (car lst) (insert x (cdr lst)))))))
           (loop (lambda (xs out)
                   (if (null? xs)
                       out
                       (loop (cdr xs) (insert (car xs) out))))) )
    (loop pairs '())))
(import (scheme base))

(define (_count v)
  (cond
    ((string? v) (string-length v))
    ((and (pair? v) (assq 'Items v)) (length (cdr (assq 'Items v))))
    ((list? v) (length v))
    (else 0)))

(define (_sum v)
  (let* ((lst (cond
               ((number? v) (list v))
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
         (s (if (null? lst) 0 (apply + lst))))
    s))

(define (_avg v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (n 0))
    (set! n (length lst))
    (if (= n 0) 0 (/ (_sum lst) n)))
)

(define (_exists v)
  (cond
    ((and (pair? v) (assq 'Items v)) (not (null? (cdr (assq 'Items v)))))
    ((string? v) (> (string-length v) 0))
    ((list? v) (not (null? v)))
    (else #f)))

(define (_max v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (m 0))
    (when (not (null? lst))
      (set! m (car lst))
      (for-each (lambda (n)
                  (when (_gt n m) (set! m n)))
                (cdr lst)))
    m))

(define (_min v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (m 0))
    (when (not (null? lst))
      (set! m (car lst))
      (for-each (lambda (n)
                  (when (_lt n m) (set! m n)))
                (cdr lst)))
    m))
(define (_group_by src keyfn)
  (let ((groups '()) (order '()))
    (for-each (lambda (it)
                (let* ((key (keyfn it))
                       (ks (_to_string key))
                       (pair (assoc ks groups)))
                  (if pair
                      (let* ((grp (cdr pair))
                             (items (cdr (assq 'Items grp))))
                        (set-cdr! (assq 'Items grp) (append items (list it))))
                      (begin
                        (set! groups (append groups (list (cons ks (list (cons 'key key) (cons 'Items (list it)))))))
                        (set! order (append order (list ks))))))
              src)
    (map (lambda (k) (cdr (assoc k groups))) order))))
(import (chibi json))

(define (_json v)
  (cond
    ;; list of objects
    ((and (list? v) (pair? v) (pair? (car v)) (pair? (caar v)))
     (display "[")
     (let loop ((xs v) (first #t))
       (unless (null? xs)
         (unless first (display ","))
         (display (json->string (car xs)))
         (loop (cdr xs) #f)))
     (display "]"))
    ;; single object or other value
    (else
     (display (json->string v))))
  (newline))
(define failures 0)
(define (print-test-start name)
  (display "   test ") (display name) (display " ..."))
(define (print-test-pass) (display " ok") (newline))
(define (print-test-fail err) (display " fail ") (display err) (newline))
(define (run-test name thunk)
  (print-test-start name)
  (let ((ok #t))
    (with-exception-handler
      (lambda (e)
        (set! ok #f)
        (set! failures (+ failures 1))
        (print-test-fail e))
      (lambda () (thunk)))
    (when ok (print-test-pass))))

(define (new-StoreSale ss_item_sk ss_ticket_number ss_customer_sk ss_quantity ss_sales_price)
  (list (cons 'ss_item_sk ss_item_sk) (cons 'ss_ticket_number ss_ticket_number) (cons 'ss_customer_sk ss_customer_sk) (cons 'ss_quantity ss_quantity) (cons 'ss_sales_price ss_sales_price))
)

(define (new-StoreReturn sr_item_sk sr_ticket_number sr_reason_sk sr_return_quantity)
  (list (cons 'sr_item_sk sr_item_sk) (cons 'sr_ticket_number sr_ticket_number) (cons 'sr_reason_sk sr_reason_sk) (cons 'sr_return_quantity sr_return_quantity))
)

(define (new-Reason r_reason_sk r_reason_desc)
  (list (cons 'r_reason_sk r_reason_sk) (cons 'r_reason_desc r_reason_desc))
)

(define (test_TPCDS_Q93_active_sales)
  (when (not (equal? result (list (list (cons 'ss_customer_sk 1) (cons 'sumsales 40.0)) (list (cons 'ss_customer_sk 2) (cons 'sumsales 60.0))))) (error "expect failed"))
)

(define store_sales (list (list (cons 'ss_item_sk 1) (cons 'ss_ticket_number 1) (cons 'ss_customer_sk 1) (cons 'ss_quantity 5) (cons 'ss_sales_price 10.0)) (list (cons 'ss_item_sk 1) (cons 'ss_ticket_number 2) (cons 'ss_customer_sk 2) (cons 'ss_quantity 3) (cons 'ss_sales_price 20.0))))
(define store_returns (list (list (cons 'sr_item_sk 1) (cons 'sr_ticket_number 1) (cons 'sr_reason_sk 1) (cons 'sr_return_quantity 1))))
(define reason (list (list (cons 'r_reason_sk 1) (cons 'r_reason_desc "ReasonA"))))
(define t (let ((_res '()))
  (for-each (lambda (ss)
    (let ((_ms0 '()) (_m0 #f))
      (for-each (lambda (sr)
        (when (and (equal? (map-get ss 'ss_item_sk) (map-get sr 'sr_item_sk)) (equal? (map-get ss 'ss_ticket_number) (map-get sr 'sr_ticket_number)))
          (set! _ms0 (append _ms0 (list sr)))
          (set! _m0 #t))
) (if (string? store_returns) (string->list store_returns) store_returns))
      (if _m0
          (for-each (lambda (sr)
            (let ((_ms1 '()) (_m1 #f))
              (for-each (lambda (r)
                (when (and (not (equal? sr '())) (equal? (map-get sr 'sr_reason_sk) (map-get r 'r_reason_sk)))
                  (set! _ms1 (append _ms1 (list r)))
                  (set! _m1 #t))
) (if (string? reason) (string->list reason) reason))
              (if _m1
                  (for-each (lambda (r)
                    (when (or (equal? r '()) (equal? (map-get r 'r_reason_desc) "ReasonA"))
                      (set! _res (append _res (list (list (cons 'ss_customer_sk (map-get ss 'ss_customer_sk)) (cons 'act_sales (if (not (equal? sr '())) (* (- (map-get ss 'ss_quantity) (map-get sr 'sr_return_quantity)) (map-get ss 'ss_sales_price)) (* (map-get ss 'ss_quantity) (map-get ss 'ss_sales_price))))))))
                    )
                  ) _ms1)
                  (let ((r '()))
                    (when (or (equal? r '()) (equal? (map-get r 'r_reason_desc) "ReasonA"))
                      (set! _res (append _res (list (list (cons 'ss_customer_sk (map-get ss 'ss_customer_sk)) (cons 'act_sales (if (not (equal? sr '())) (* (- (map-get ss 'ss_quantity) (map-get sr 'sr_return_quantity)) (map-get ss 'ss_sales_price)) (* (map-get ss 'ss_quantity) (map-get ss 'ss_sales_price))))))))
                    )
                  ))
            )
          ) _ms0)
          (let ((sr '()))
            (let ((_ms2 '()) (_m2 #f))
              (for-each (lambda (r)
                (when (and (not (equal? sr '())) (equal? (map-get sr 'sr_reason_sk) (map-get r 'r_reason_sk)))
                  (set! _ms2 (append _ms2 (list r)))
                  (set! _m2 #t))
) (if (string? reason) (string->list reason) reason))
              (if _m2
                  (for-each (lambda (r)
                    (when (or (equal? r '()) (equal? (map-get r 'r_reason_desc) "ReasonA"))
                      (set! _res (append _res (list (list (cons 'ss_customer_sk (map-get ss 'ss_customer_sk)) (cons 'act_sales (if (not (equal? sr '())) (* (- (map-get ss 'ss_quantity) (map-get sr 'sr_return_quantity)) (map-get ss 'ss_sales_price)) (* (map-get ss 'ss_quantity) (map-get ss 'ss_sales_price))))))))
                    )
                  ) _ms2)
                  (let ((r '()))
                    (when (or (equal? r '()) (equal? (map-get r 'r_reason_desc) "ReasonA"))
                      (set! _res (append _res (list (list (cons 'ss_customer_sk (map-get ss 'ss_customer_sk)) (cons 'act_sales (if (not (equal? sr '())) (* (- (map-get ss 'ss_quantity) (map-get sr 'sr_return_quantity)) (map-get ss 'ss_sales_price)) (* (map-get ss 'ss_quantity) (map-get ss 'ss_sales_price))))))))
                    )
                  ))
            )
          ))
    )
  ) (if (string? store_sales) (string->list store_sales) store_sales))
  _res))
(define result (let ((_tmp '()))
  (for-each (lambda (x)
    (set! _tmp (append _tmp (list x)))
  ) (if (string? t) (string->list t) t))
  (let ((_res '()))
    (for-each (lambda (g)
      (set! _res (append _res (list (list (cons 'ss_customer_sk (map-get g 'key)) (cons 'sumsales (_sum (let ((_res '()))
  (for-each (lambda (y)
    (set! _res (append _res (list (map-get y 'act_sales))))
  ) (if (string? g) (string->list g) g))
  _res)))))))
    ) (_group_by _tmp (lambda (x) (map-get x 'ss_customer_sk))))
    (set! _res (_sort (map (lambda (x) (cons x (list (_sum (let ((_res '()))
  (for-each (lambda (y)
    (set! _res (append _res (list (map-get y 'act_sales))))
  ) (if (string? g) (string->list g) g))
  _res)) (map-get g 'key)))) _res)))
    (set! _res (map car _res))
    _res)))
(_json result)
(run-test "TPCDS Q93 active sales" test_TPCDS_Q93_active_sales)
(when (> failures 0) (display "\n[FAIL] ") (display failures) (display " test(s) failed.\n"))
