(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(define (_count v)
  (cond
    ((string? v) (string-length v))
    ((and (pair? v) (assq 'Items v)) (length (cdr (assq 'Items v))))
    ((list? v) (length v))
    (else 0)))

(define (_sum v)
  (let* ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
         (s (if (null? lst) 0 (apply + lst))))
    s))

(define (_avg v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (n 0))
    (set! n (length lst))
    (if (= n 0) 0 (/ (_sum lst) n)))

(define (_max v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (m 0))
    (when (not (null? lst))
      (set! m (car lst))
      (for-each (lambda (n)
                  (when (> n m) (set! m n)))
                (cdr lst)))
    m))

(define (_group_by src keyfn)

(define (_group_by src keyfn)
  (let ((groups '()) (order '()))
    (for-each (lambda (it)
                (let* ((key (keyfn it))
                       (ks (format "~a" key))
                       (pair (assoc ks groups)))
                  (if pair
                      (let* ((grp (cdr pair))
                             (items (cdr (assq 'Items grp))))
                        (set-cdr! (assq 'Items grp) (append items (list it))))
                      (begin
                        (set! groups (append groups (list (cons ks (list (cons 'key key) (cons 'Items (list it)))))))
                        (set! order (append order (list ks))))))
              src)
    (map (lambda (k) (cdr (assoc k groups))) order))))
(define (_json v)
  (write v)
  (newline))
(define failures 0)
(define (print-test-start name)
  (display "   test ") (display name) (display " ..."))
(define (print-test-pass) (display " ok") (newline))
(define (print-test-fail err) (display " fail ") (display err) (newline))
(define (run-test name thunk)
  (print-test-start name)
  (let ((ok #t))
    (with-exception-handler
      (lambda (e)
        (set! ok #f)
        (set! failures (+ failures 1))
        (print-test-fail e))
      (lambda () (thunk)))
    (when ok (print-test-pass))))

(define (test_TPCDS_Q48_simplified)
  (when (not (equal? result 35)) (error "expect failed"))
)

(define store_sales (list (list (cons "cdemo_sk" 1) (cons "addr_sk" 1) (cons "sold_date_sk" 1) (cons "sales_price" 120.0) (cons "net_profit" 1000.0) (cons "quantity" 5)) (list (cons "cdemo_sk" 2) (cons "addr_sk" 2) (cons "sold_date_sk" 1) (cons "sales_price" 60.0) (cons "net_profit" 2000.0) (cons "quantity" 10)) (list (cons "cdemo_sk" 3) (cons "addr_sk" 3) (cons "sold_date_sk" 1) (cons "sales_price" 170.0) (cons "net_profit" 10000.0) (cons "quantity" 20))))
(define store (list (list (cons "s_store_sk" 1))))
(define customer_demographics (list (list (cons "cd_demo_sk" 1) (cons "cd_marital_status" "S") (cons "cd_education_status" "E1")) (list (cons "cd_demo_sk" 2) (cons "cd_marital_status" "M") (cons "cd_education_status" "E2")) (list (cons "cd_demo_sk" 3) (cons "cd_marital_status" "W") (cons "cd_education_status" "E3"))))
(define customer_address (list (list (cons "ca_address_sk" 1) (cons "ca_country" "United States") (cons "ca_state" "TX")) (list (cons "ca_address_sk" 2) (cons "ca_country" "United States") (cons "ca_state" "CA")) (list (cons "ca_address_sk" 3) (cons "ca_country" "United States") (cons "ca_state" "NY"))))
(define date_dim (list (list (cons "d_date_sk" 1) (cons "d_year" 2000))))
(define year 2000)
(define states1 (list "TX"))
(define states2 (list "CA"))
(define states3 (list "NY"))
(define qty_base (let ((_res '()))
  (for-each (lambda (ss)
    (for-each (lambda (cd)
      (when (equal? (map-get ss "cdemo_sk") (map-get cd "cd_demo_sk"))
        (for-each (lambda (ca)
          (when (equal? (map-get ss "addr_sk") (map-get ca "ca_address_sk"))
            (for-each (lambda (d)
              (when (equal? (map-get ss "sold_date_sk") (map-get d "d_date_sk"))
                (when (and (and (equal? (map-get d "d_year") year) (or (or (<= (and (>= (and (equal? (and (equal? (map-get cd "cd_marital_status") "S") (map-get cd "cd_education_status")) "E1") (map-get ss "sales_price")) 100.0) (map-get ss "sales_price")) 150.0) (<= (and (>= (and (equal? (and (equal? (map-get cd "cd_marital_status") "M") (map-get cd "cd_education_status")) "E2") (map-get ss "sales_price")) 50.0) (map-get ss "sales_price")) 100.0)) (<= (and (>= (and (equal? (and (equal? (map-get cd "cd_marital_status") "W") (map-get cd "cd_education_status")) "E3") (map-get ss "sales_price")) 150.0) (map-get ss "sales_price")) 200.0))) (or (or (<= (and (>= (and (if (member (map-get ca "ca_state") states1) #t #f) (map-get ss "net_profit")) 0) (map-get ss "net_profit")) 2000) (<= (and (>= (and (if (member (map-get ca "ca_state") states2) #t #f) (map-get ss "net_profit")) 150) (map-get ss "net_profit")) 3000)) (<= (and (>= (and (if (member (map-get ca "ca_state") states3) #t #f) (map-get ss "net_profit")) 50) (map-get ss "net_profit")) 25000)))
                  (set! _res (append _res (list (map-get ss "quantity"))))
                )
              )) (if (string? date_dim) (string->list date_dim) date_dim))
          )) (if (string? customer_address) (string->list customer_address) customer_address))
      )) (if (string? customer_demographics) (string->list customer_demographics) customer_demographics))
  ) (if (string? store_sales) (string->list store_sales) store_sales))
  _res))
(define qty qty_base)
(define result (_sum qty))
(_json result)
(run-test "TPCDS Q48 simplified" test_TPCDS_Q48_simplified)
(when (> failures 0) (display "\n[FAIL] ") (display failures) (display " test(s) failed.\n"))
