(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (srfi 95))

(define (_fetch url opts)
  (let* ((method (if (and opts (assq 'method opts)) (cdr (assq 'method opts)) "GET"))
         (args (list "curl" "-s" "-X" method)))
    (when (and opts (assq 'headers opts))
      (for-each (lambda (p)
                  (set! args (append args (list "-H" (format "~a: ~a" (car p) (cdr p))))))
                (cdr (assq 'headers opts))))
    (when (and opts (assq 'query opts))
      (let* ((q (cdr (assq 'query opts)))
             (qs (string-join (map (lambda (p) (format "~a=~a" (car p) (cdr p))) q) "&")))
        (set! url (string-append url (if (string-contains url "?") "&" "?") qs))))
    (when (and opts (assq 'body opts))
      (set! args (append args (list "-d" (json->string (cdr (assq 'body opts)))))))
    (when (and opts (assq 'timeout opts))
      (set! args (append args (list "--max-time" (format "~a" (cdr (assq 'timeout opts)))))))
    (set! args (append args (list url)))
    (let* ((p (open-input-pipe (string-join args " ")))
           (txt (port->string p)))
      (close-input-port p)
      (string->json txt))))

(define (_load path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (in (if (or (not path) (string=? path "") (string=? path "-"))
                 (current-input-port)
                 (open-input-file path)))
         (text (port->string in)))
    (when (not (eq? in (current-input-port)))
      (close-input-port in))
    (cond ((string=? fmt "jsonl")
           (map string->json
                (filter (lambda (l) (not (string=? l "")))
                        (string-split text #\newline))))
          (else
           (let ((d (string->json text)))
             (if (list? d) d (list d)))))))

(define (_save rows path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (out (if (or (not path) (string=? path "") (string=? path "-"))
                  (current-output-port)
                  (open-output-file path))))
    (cond ((string=? fmt "jsonl")
           (for-each (lambda (r) (write-string (json->string r) out) (newline out)) rows))
          (else
           (write-string (json->string rows) out)))
    (when (not (eq? out (current-output-port)))
      (close-output-port out))))

(define (_lt a b)
  (cond
    ((and (number? a) (number? b)) (< a b))
    ((and (string? a) (string? b)) (string<? a b))
    ((and (pair? a) (pair? b))
      (cond
        ((null? a) (not (null? b)))
        ((null? b) #f)
        (else (let ((ka (car a)) (kb (car b)))
                (if (equal? ka kb)
                    (_lt (cdr a) (cdr b))
                    (_lt ka kb)))))
    )
    (else (string<? (format "~a" a) (format "~a" b)))))

(define (_sort pairs)
  (sort pairs (lambda (a b) (_lt (cdr a) (cdr b)))))
(define (_count v)
  (cond
    ((string? v) (string-length v))
    ((and (pair? v) (assq 'Items v)) (length (cdr (assq 'Items v))))
    ((list? v) (length v))
    (else 0)))

(define (_sum v)
  (let* ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
         (s (if (null? lst) 0 (apply + lst))))
    s))

(define (_avg v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (n 0))
    (set! n (length lst))
    (if (= n 0) 0 (/ (_sum lst) n)))

(define (_max v)
  (let ((lst (cond
               ((and (pair? v) (assq 'Items v)) (cdr (assq 'Items v)))
               ((list? v) v)
               (else '())))
        (m 0))
    (when (not (null? lst))
      (set! m (car lst))
      (for-each (lambda (n)
                  (when (> n m) (set! m n)))
                (cdr lst)))
    m))

(define (_group_by src keyfn)

(define (_group_by src keyfn)
  (let ((groups '()) (order '()))
    (for-each (lambda (it)
                (let* ((key (keyfn it))
                       (ks (format "~a" key))
                       (pair (assoc ks groups)))
                  (if pair
                      (let* ((grp (cdr pair))
                             (items (cdr (assq 'Items grp))))
                        (set-cdr! (assq 'Items grp) (append items (list it))))
                      (begin
                        (set! groups (append groups (list (cons ks (list (cons 'key key) (cons 'Items (list it)))))))
                        (set! order (append order (list ks))))))
              src)
    (map (lambda (k) (cdr (assoc k groups))) order))))
(define (_json v)
  (write v)
  (newline))
(define failures 0)
(define (print-test-start name)
  (display "   test ") (display name) (display " ..."))
(define (print-test-pass) (display " ok") (newline))
(define (print-test-fail err) (display " fail ") (display err) (newline))
(define (run-test name thunk)
  (print-test-start name)
  (let ((ok #t))
    (with-exception-handler
      (lambda (e)
        (set! ok #f)
        (set! failures (+ failures 1))
        (print-test-fail e))
      (lambda () (thunk)))
    (when ok (print-test-pass))))

(define (new-StoreSale ss_ticket_number ss_item_sk ss_customer_sk ss_store_sk ss_net_paid)
  (list (cons 'ss_ticket_number ss_ticket_number) (cons 'ss_item_sk ss_item_sk) (cons 'ss_customer_sk ss_customer_sk) (cons 'ss_store_sk ss_store_sk) (cons 'ss_net_paid ss_net_paid))
)

(define (new-StoreReturn sr_ticket_number sr_item_sk)
  (list (cons 'sr_ticket_number sr_ticket_number) (cons 'sr_item_sk sr_item_sk))
)

(define (new-Store s_store_sk s_store_name s_market_id s_state s_zip)
  (list (cons 's_store_sk s_store_sk) (cons 's_store_name s_store_name) (cons 's_market_id s_market_id) (cons 's_state s_state) (cons 's_zip s_zip))
)

(define (new-Item i_item_sk i_color i_current_price i_manager_id i_units i_size)
  (list (cons 'i_item_sk i_item_sk) (cons 'i_color i_color) (cons 'i_current_price i_current_price) (cons 'i_manager_id i_manager_id) (cons 'i_units i_units) (cons 'i_size i_size))
)

(define (new-Customer c_customer_sk c_first_name c_last_name c_current_addr_sk c_birth_country)
  (list (cons 'c_customer_sk c_customer_sk) (cons 'c_first_name c_first_name) (cons 'c_last_name c_last_name) (cons 'c_current_addr_sk c_current_addr_sk) (cons 'c_birth_country c_birth_country))
)

(define (new-CustomerAddress ca_address_sk ca_state ca_country ca_zip)
  (list (cons 'ca_address_sk ca_address_sk) (cons 'ca_state ca_state) (cons 'ca_country ca_country) (cons 'ca_zip ca_zip))
)

(define (test_TPCDS_Q24_customer_net_paid)
  (when (not (equal? result (list (list (cons "c_last_name" "Smith") (cons "c_first_name" "Ann") (cons "s_store_name" "Store1") (cons "paid" 100.0))))) (error "expect failed"))
)

(define store_sales (list (list (cons "ss_ticket_number" 1) (cons "ss_item_sk" 1) (cons "ss_customer_sk" 1) (cons "ss_store_sk" 1) (cons "ss_net_paid" 100.0)) (list (cons "ss_ticket_number" 2) (cons "ss_item_sk" 2) (cons "ss_customer_sk" 2) (cons "ss_store_sk" 1) (cons "ss_net_paid" 50.0))))
(define store_returns (list (list (cons "sr_ticket_number" 1) (cons "sr_item_sk" 1)) (list (cons "sr_ticket_number" 2) (cons "sr_item_sk" 2))))
(define store (list (list (cons "s_store_sk" 1) (cons "s_store_name" "Store1") (cons "s_market_id" 5) (cons "s_state" "CA") (cons "s_zip" "12345"))))
(define item (list (list (cons "i_item_sk" 1) (cons "i_color" "RED") (cons "i_current_price" 10.0) (cons "i_manager_id" 1) (cons "i_units" "EA") (cons "i_size" "M")) (list (cons "i_item_sk" 2) (cons "i_color" "BLUE") (cons "i_current_price" 20.0) (cons "i_manager_id" 2) (cons "i_units" "EA") (cons "i_size" "L"))))
(define customer (list (list (cons "c_customer_sk" 1) (cons "c_first_name" "Ann") (cons "c_last_name" "Smith") (cons "c_current_addr_sk" 1) (cons "c_birth_country" "Canada")) (list (cons "c_customer_sk" 2) (cons "c_first_name" "Bob") (cons "c_last_name" "Jones") (cons "c_current_addr_sk" 2) (cons "c_birth_country" "USA"))))
(define customer_address (list (list (cons "ca_address_sk" 1) (cons "ca_state" "CA") (cons "ca_country" "USA") (cons "ca_zip" "12345")) (list (cons "ca_address_sk" 2) (cons "ca_state" "CA") (cons "ca_country" "USA") (cons "ca_zip" "54321"))))
(define ssales (let ((_tmp '()))
  (for-each (lambda (ss)
    (for-each (lambda (sr)
      (when (equal? (and (equal? (map-get ss "ss_ticket_number") (map-get sr "sr_ticket_number")) (map-get ss "ss_item_sk")) (map-get sr "sr_item_sk"))
        (for-each (lambda (s)
          (when (equal? (map-get ss "ss_store_sk") (map-get s "s_store_sk"))
            (for-each (lambda (i)
              (when (equal? (map-get ss "ss_item_sk") (map-get i "i_item_sk"))
                (for-each (lambda (c)
                  (when (equal? (map-get ss "ss_customer_sk") (map-get c "c_customer_sk"))
                    (for-each (lambda (ca)
                      (when (equal? (map-get c "c_current_addr_sk") (map-get ca "ca_address_sk"))
                        (when (equal? (and (equal? (and (not (equal? (map-get c "c_birth_country") ((map-get strings "ToUpper") (map-get ca "ca_country")))) (map-get s "s_zip")) (map-get ca "ca_zip")) (map-get s "s_market_id")) 5)
                          (set! _tmp (append _tmp (list ss)))
                        )
                      )) (if (string? customer_address) (string->list customer_address) customer_address))
                  )) (if (string? customer) (string->list customer) customer))
              )) (if (string? item) (string->list item) item))
          )) (if (string? store) (string->list store) store))
      )) (if (string? store_returns) (string->list store_returns) store_returns))
  ) (if (string? store_sales) (string->list store_sales) store_sales))
  (let ((_res '()))
    (for-each (lambda (g)
      (set! _res (append _res (list (list (cons "c_last_name" (map-get (map-get g "key") "last")) (cons "c_first_name" (map-get (map-get g "key") "first")) (cons "s_store_name" (map-get (map-get g "key") "store_name")) (cons "color" (map-get (map-get g "key") "color")) (cons "netpaid" (_sum (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "ss_net_paid"))))
  ) (if (string? g) (string->list g) g))
  _res)))))))
    ) (_group_by _tmp (lambda (ss) (list (cons "last" (map-get c "c_last_name")) (cons "first" (map-get c "c_first_name")) (cons "store_name" (map-get s "s_store_name")) (cons "color" (map-get i "i_color"))))))
    _res)))
(define avg_paid (_avg (let ((_res '()))
  (for-each (lambda (x)
    (set! _res (append _res (list (map-get x "netpaid"))))
  ) (if (string? ssales) (string->list ssales) ssales))
  _res)))
(define result (let ((_res '()) (_tmp '()))
  (for-each (lambda (x)
    (when (* (> (and (equal? (map-get x "color") "RED") (map-get x "netpaid")) 0.05) avg_paid)
      (set! _tmp (append _tmp (list (cons (list (cons "c_last_name" (map-get x "c_last_name")) (cons "c_first_name" (map-get x "c_first_name")) (cons "s_store_name" (map-get x "s_store_name")) (cons "paid" (map-get x "netpaid"))) (list (map-get x "c_last_name") (map-get x "c_first_name") (map-get x "s_store_name"))))))
    )
  ) (if (string? ssales) (string->list ssales) ssales))
  (set! _res (_sort _tmp))
  (set! _res (map car _res))
  _res))
(_json result)
(run-test "TPCDS Q24 customer net paid" test_TPCDS_Q24_customer_net_paid)
(when (> failures 0) (display "\n[FAIL] ") (display failures) (display " test(s) failed.\n"))
