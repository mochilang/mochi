// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:09:20Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Inventory {
        inv_item_sk: i32,
        inv_warehouse_sk: i32,
        inv_date_sk: i32,
        inv_quantity_on_hand: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Warehouse {
        w_warehouse_sk: i32,
        w_warehouse_name: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Item {
        i_item_sk: i32,
        i_item_id: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct DateDim {
        d_date_sk: i32,
        d_date: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Inventory1 {
    inv_item_sk: i32,
    inv_warehouse_sk: i32,
    inv_date_sk: i32,
    inv_quantity_on_hand: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Warehouse2 {
    w_warehouse_sk: i32,
    w_warehouse_name: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item3 {
    i_item_sk: i32,
    i_item_id: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Date_dim {
    d_date_sk: i32,
    d_date: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key {
    w: i32,
    i: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item4 {
    inv: Inventory1,
    d: Date_dim,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Group {
    key: Key,
    items: Vec<Item4>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result {
    w: i32,
    i: i32,
    qty: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key5 {
    w: i32,
    i: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item6 {
    inv: Inventory1,
    d: Date_dim,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Group7 {
    key: Key5,
    items: Vec<Item6>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result8 {
    w: i32,
    i: i32,
    qty: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result9 {
    w_name: &'static str,
    i_id: &'static str,
    before_qty: i32,
    after_qty: i32,
    ratio: f64,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result10 {
    w_warehouse_name: &'static str,
    i_item_id: &'static str,
    inv_before: i32,
    inv_after: i32,
}

fn sum<T>(v: &[T]) -> T where T: std::iter::Sum<T> + Copy {
    v.iter().copied().sum()
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let inventory = vec![Inventory1 { inv_item_sk: 1, inv_warehouse_sk: 1, inv_date_sk: 1, inv_quantity_on_hand: 30 }, Inventory1 { inv_item_sk: 1, inv_warehouse_sk: 1, inv_date_sk: 2, inv_quantity_on_hand: 40 }, Inventory1 { inv_item_sk: 2, inv_warehouse_sk: 2, inv_date_sk: 1, inv_quantity_on_hand: 20 }, Inventory1 { inv_item_sk: 2, inv_warehouse_sk: 2, inv_date_sk: 2, inv_quantity_on_hand: 20 }];
    let warehouse = vec![Warehouse2 { w_warehouse_sk: 1, w_warehouse_name: "Main" }, Warehouse2 { w_warehouse_sk: 2, w_warehouse_name: "Backup" }];
    let item = vec![Item3 { i_item_sk: 1, i_item_id: "ITEM1" }, Item3 { i_item_sk: 2, i_item_id: "ITEM2" }];
    let date_dim = vec![Date_dim { d_date_sk: 1, d_date: "2000-03-01" }, Date_dim { d_date_sk: 2, d_date: "2000-03-20" }];
    let before = { let mut tmp1 = std::collections::HashMap::new();for inv in &inventory { for d in &date_dim { if !(inv.inv_date_sk == d.d_date_sk) { continue; } if !(d.d_date < "2000-03-15") { continue; } let key = Key { w: inv.inv_warehouse_sk, i: inv.inv_item_sk }; tmp1.entry(key).or_insert_with(Vec::new).push(Item4 {inv: inv.clone(), d: d.clone() }); } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { w: g.key.w, i: g.key.i, qty: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push(x.inv_quantity_on_hand); } tmp3 }) }); } result };
    let after = { let mut tmp4 = std::collections::HashMap::new();for inv in &inventory { for d in &date_dim { if !(inv.inv_date_sk == d.d_date_sk) { continue; } if !(d.d_date >= "2000-03-15") { continue; } let key = Key5 { w: inv.inv_warehouse_sk, i: inv.inv_item_sk }; tmp4.entry(key).or_insert_with(Vec::new).push(Item6 {inv: inv.clone(), d: d.clone() }); } } let mut tmp5 = Vec::<Group7>::new(); for (k,v) in tmp4 { tmp5.push(Group7 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result8 { w: g.key.w, i: g.key.i, qty: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push(x.inv_quantity_on_hand); } tmp6 }) }); } result };
    let joined = { let mut tmp7 = Vec::new();for b in &before { for a in &after { if !(b.w == a.w && b.i == a.i) { continue; } for w in &warehouse { if !(w.w_warehouse_sk == b.w) { continue; } for it in &item { if !(it.i_item_sk == b.i) { continue; } tmp7.push(Result9 { w_name: w.w_warehouse_name, i_id: it.i_item_id, before_qty: b.qty, after_qty: a.qty, ratio: (a.qty as f64) / (b.qty as f64) }); } } } } tmp7 };
    let result = { let mut tmp8 = Vec::new();for r in &joined { if !(r.ratio >= (2.0 / 3.0) && r.ratio <= (3.0 / 2.0)) { continue; } let tmp9 = Result10 { w_warehouse_name: r.w_name, i_item_id: r.i_id, inv_before: r.before_qty, inv_after: r.after_qty }; let tmp10 = (r.w_name, r.i_id); tmp8.push((tmp10, tmp9)); } tmp8.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); let mut tmp11 = Vec::new(); for p in tmp8 { tmp11.push(p.1); } tmp11 };
    _json(&result);
    assert!(result == vec![Result10 { w_warehouse_name: "Backup", i_item_id: "ITEM2", inv_before: 20, inv_after: 20 }, Result10 { w_warehouse_name: "Main", i_item_id: "ITEM1", inv_before: 30, inv_after: 40 }]);
}
