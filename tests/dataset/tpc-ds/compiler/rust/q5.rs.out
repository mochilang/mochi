fn test_TPCDS_Q5_empty() {
    expect(result.len() as i64 == 0);
}

fn main() {
    let mut store_sales = vec![];
    let mut store_returns = vec![];
    let mut store = vec![];
    let mut catalog_sales = vec![];
    let mut catalog_returns = vec![];
    let mut catalog_page = vec![];
    let mut web_sales = vec![];
    let mut web_returns = vec![];
    let mut web_site = vec![];
    let mut date_dim = vec![];
    let mut ss = {
    #[derive(Clone, Debug)]
    struct Group { key: std::boxed::Box<dyn std::any::Any>, items: Vec<std::boxed::Box<dyn std::any::Any>> }
    let mut groups: std::collections::HashMap<String, Group> = std::collections::HashMap::new();
    let mut order: Vec<String> = Vec::new();
    for ss in store_sales.clone() {
        for d in date_dim.clone() {
            if !(ss.ss_sold_date_sk == _map_get(&d, &"d_date_sk".to_string())) { continue; }
            for s in store.clone() {
                if !(ss.ss_store_sk == _map_get(&s, &"s_store_sk".to_string())) { continue; }
                if !(_map_get(&d, &"d_date".to_string()) >= "1998-12-01" && _map_get(&d, &"d_date".to_string()) <= "1998-12-15") { continue; }
                let key: std::boxed::Box<dyn std::any::Any> = _map_get(&s, &"s_store_id".to_string());
                let ks = format!("{:?}", key.clone());
                if !groups.contains_key(&ks) {
                    groups.insert(ks.clone(), Group{ key: key.clone(), items: Vec::new() });
                    order.push(ks.clone());
                }
                groups.get_mut(&ks).unwrap().items.push(ss.clone());
            }
        }
    }
    let mut _res: Vec<std::collections::HashMap<String, std::boxed::Box<dyn std::any::Any>>> = Vec::new();
    for ks in order {
        let g = groups.get(&ks).unwrap().clone();
        _res.push(std::collections::HashMap::from([("channel".to_string(), "store channel"), ("id".to_string(), format!("{}{}", "store", format!("{}", _map_get(&g, &"key".to_string())))), ("sales".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"ss".to_string()), &"ss_ext_sales_price".to_string()));
    }
    _res
})), ("returns".to_string(), 0.0), ("profit".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"ss".to_string()), &"ss_net_profit".to_string()));
    }
    _res
})), ("profit_loss".to_string(), 0.0)]));
    }
    _res
}
;
    let mut sr = {
    #[derive(Clone, Debug)]
    struct Group { key: std::boxed::Box<dyn std::any::Any>, items: Vec<std::boxed::Box<dyn std::any::Any>> }
    let mut groups: std::collections::HashMap<String, Group> = std::collections::HashMap::new();
    let mut order: Vec<String> = Vec::new();
    for sr in store_returns.clone() {
        for d in date_dim.clone() {
            if !(sr.sr_returned_date_sk == _map_get(&d, &"d_date_sk".to_string())) { continue; }
            for s in store.clone() {
                if !(sr.sr_store_sk == _map_get(&s, &"s_store_sk".to_string())) { continue; }
                if !(_map_get(&d, &"d_date".to_string()) >= "1998-12-01" && _map_get(&d, &"d_date".to_string()) <= "1998-12-15") { continue; }
                let key: std::boxed::Box<dyn std::any::Any> = _map_get(&s, &"s_store_id".to_string());
                let ks = format!("{:?}", key.clone());
                if !groups.contains_key(&ks) {
                    groups.insert(ks.clone(), Group{ key: key.clone(), items: Vec::new() });
                    order.push(ks.clone());
                }
                groups.get_mut(&ks).unwrap().items.push(sr.clone());
            }
        }
    }
    let mut _res: Vec<std::collections::HashMap<String, std::boxed::Box<dyn std::any::Any>>> = Vec::new();
    for ks in order {
        let g = groups.get(&ks).unwrap().clone();
        _res.push(std::collections::HashMap::from([("channel".to_string(), "store channel"), ("id".to_string(), format!("{}{}", "store", format!("{}", _map_get(&g, &"key".to_string())))), ("sales".to_string(), 0.0), ("returns".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"sr".to_string()), &"sr_return_amt".to_string()));
    }
    _res
})), ("profit".to_string(), 0.0), ("profit_loss".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"sr".to_string()), &"sr_net_loss".to_string()));
    }
    _res
}))]));
    }
    _res
}
;
    let mut cs = {
    #[derive(Clone, Debug)]
    struct Group { key: std::boxed::Box<dyn std::any::Any>, items: Vec<std::boxed::Box<dyn std::any::Any>> }
    let mut groups: std::collections::HashMap<String, Group> = std::collections::HashMap::new();
    let mut order: Vec<String> = Vec::new();
    for cs in catalog_sales.clone() {
        for d in date_dim.clone() {
            if !(cs.cs_sold_date_sk == _map_get(&d, &"d_date_sk".to_string())) { continue; }
            for cp in catalog_page.clone() {
                if !(cs.cs_catalog_page_sk == _map_get(&cp, &"cp_catalog_page_sk".to_string())) { continue; }
                if !(_map_get(&d, &"d_date".to_string()) >= "1998-12-01" && _map_get(&d, &"d_date".to_string()) <= "1998-12-15") { continue; }
                let key: std::boxed::Box<dyn std::any::Any> = _map_get(&cp, &"cp_catalog_page_id".to_string());
                let ks = format!("{:?}", key.clone());
                if !groups.contains_key(&ks) {
                    groups.insert(ks.clone(), Group{ key: key.clone(), items: Vec::new() });
                    order.push(ks.clone());
                }
                groups.get_mut(&ks).unwrap().items.push(cs.clone());
            }
        }
    }
    let mut _res: Vec<std::collections::HashMap<String, std::boxed::Box<dyn std::any::Any>>> = Vec::new();
    for ks in order {
        let g = groups.get(&ks).unwrap().clone();
        _res.push(std::collections::HashMap::from([("channel".to_string(), "catalog channel"), ("id".to_string(), format!("{}{}", "catalog_page", format!("{}", _map_get(&g, &"key".to_string())))), ("sales".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"cs".to_string()), &"cs_ext_sales_price".to_string()));
    }
    _res
})), ("returns".to_string(), 0.0), ("profit".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"cs".to_string()), &"cs_net_profit".to_string()));
    }
    _res
})), ("profit_loss".to_string(), 0.0)]));
    }
    _res
}
;
    let mut cr = {
    #[derive(Clone, Debug)]
    struct Group { key: std::boxed::Box<dyn std::any::Any>, items: Vec<std::boxed::Box<dyn std::any::Any>> }
    let mut groups: std::collections::HashMap<String, Group> = std::collections::HashMap::new();
    let mut order: Vec<String> = Vec::new();
    for cr in catalog_returns.clone() {
        for d in date_dim.clone() {
            if !(cr.cr_returned_date_sk == _map_get(&d, &"d_date_sk".to_string())) { continue; }
            for cp in catalog_page.clone() {
                if !(cr.cr_catalog_page_sk == _map_get(&cp, &"cp_catalog_page_sk".to_string())) { continue; }
                if !(_map_get(&d, &"d_date".to_string()) >= "1998-12-01" && _map_get(&d, &"d_date".to_string()) <= "1998-12-15") { continue; }
                let key: std::boxed::Box<dyn std::any::Any> = _map_get(&cp, &"cp_catalog_page_id".to_string());
                let ks = format!("{:?}", key.clone());
                if !groups.contains_key(&ks) {
                    groups.insert(ks.clone(), Group{ key: key.clone(), items: Vec::new() });
                    order.push(ks.clone());
                }
                groups.get_mut(&ks).unwrap().items.push(cr.clone());
            }
        }
    }
    let mut _res: Vec<std::collections::HashMap<String, std::boxed::Box<dyn std::any::Any>>> = Vec::new();
    for ks in order {
        let g = groups.get(&ks).unwrap().clone();
        _res.push(std::collections::HashMap::from([("channel".to_string(), "catalog channel"), ("id".to_string(), format!("{}{}", "catalog_page", format!("{}", _map_get(&g, &"key".to_string())))), ("sales".to_string(), 0.0), ("returns".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"cr".to_string()), &"cr_return_amount".to_string()));
    }
    _res
})), ("profit".to_string(), 0.0), ("profit_loss".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"cr".to_string()), &"cr_net_loss".to_string()));
    }
    _res
}))]));
    }
    _res
}
;
    let mut ws = {
    #[derive(Clone, Debug)]
    struct Group { key: std::boxed::Box<dyn std::any::Any>, items: Vec<std::boxed::Box<dyn std::any::Any>> }
    let mut groups: std::collections::HashMap<String, Group> = std::collections::HashMap::new();
    let mut order: Vec<String> = Vec::new();
    for ws in web_sales.clone() {
        for d in date_dim.clone() {
            if !(ws.ws_sold_date_sk == _map_get(&d, &"d_date_sk".to_string())) { continue; }
            for w in web_site.clone() {
                if !(ws.ws_web_site_sk == _map_get(&w, &"web_site_sk".to_string())) { continue; }
                if !(_map_get(&d, &"d_date".to_string()) >= "1998-12-01" && _map_get(&d, &"d_date".to_string()) <= "1998-12-15") { continue; }
                let key: std::boxed::Box<dyn std::any::Any> = _map_get(&w, &"web_site_id".to_string());
                let ks = format!("{:?}", key.clone());
                if !groups.contains_key(&ks) {
                    groups.insert(ks.clone(), Group{ key: key.clone(), items: Vec::new() });
                    order.push(ks.clone());
                }
                groups.get_mut(&ks).unwrap().items.push(ws.clone());
            }
        }
    }
    let mut _res: Vec<std::collections::HashMap<String, std::boxed::Box<dyn std::any::Any>>> = Vec::new();
    for ks in order {
        let g = groups.get(&ks).unwrap().clone();
        _res.push(std::collections::HashMap::from([("channel".to_string(), "web channel"), ("id".to_string(), format!("{}{}", "web_site", format!("{}", _map_get(&g, &"key".to_string())))), ("sales".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"ws".to_string()), &"ws_ext_sales_price".to_string()));
    }
    _res
})), ("returns".to_string(), 0.0), ("profit".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"ws".to_string()), &"ws_net_profit".to_string()));
    }
    _res
})), ("profit_loss".to_string(), 0.0)]));
    }
    _res
}
;
    let mut wr = {
    #[derive(Clone, Debug)]
    struct Group { key: std::boxed::Box<dyn std::any::Any>, items: Vec<std::boxed::Box<dyn std::any::Any>> }
    let mut groups: std::collections::HashMap<String, Group> = std::collections::HashMap::new();
    let mut order: Vec<String> = Vec::new();
    for wr in web_returns.clone() {
        for ws in web_sales.clone() {
            if !(wr.wr_item_sk == ws.ws_item_sk && wr.wr_order_number == ws.ws_order_number) { continue; }
            for d in date_dim.clone() {
                if !(wr.wr_returned_date_sk == _map_get(&d, &"d_date_sk".to_string())) { continue; }
                for w in web_site.clone() {
                    if !(ws.ws_web_site_sk == _map_get(&w, &"web_site_sk".to_string())) { continue; }
                    if !(_map_get(&d, &"d_date".to_string()) >= "1998-12-01" && _map_get(&d, &"d_date".to_string()) <= "1998-12-15") { continue; }
                    let key: std::boxed::Box<dyn std::any::Any> = _map_get(&w, &"web_site_id".to_string());
                    let ks = format!("{:?}", key.clone());
                    if !groups.contains_key(&ks) {
                        groups.insert(ks.clone(), Group{ key: key.clone(), items: Vec::new() });
                        order.push(ks.clone());
                    }
                    groups.get_mut(&ks).unwrap().items.push(wr.clone());
                }
            }
        }
    }
    let mut _res: Vec<std::collections::HashMap<String, std::boxed::Box<dyn std::any::Any>>> = Vec::new();
    for ks in order {
        let g = groups.get(&ks).unwrap().clone();
        _res.push(std::collections::HashMap::from([("channel".to_string(), "web channel"), ("id".to_string(), format!("{}{}", "web_site", format!("{}", _map_get(&g, &"key".to_string())))), ("sales".to_string(), 0.0), ("returns".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"wr".to_string()), &"wr_return_amt".to_string()));
    }
    _res
})), ("profit".to_string(), 0.0), ("profit_loss".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"wr".to_string()), &"wr_net_loss".to_string()));
    }
    _res
}))]));
    }
    _res
}
;
    let mut per_channel = concat(_union(&ss, &sr), _union(&cs, &cr), _union(&ws, &wr));
    let mut result = {
    let mut _pairs = Vec::new();
    for p in per_channel {
        _pairs.push((_map_get(&_map_get(&g, &"key".to_string()), &"channel".to_string()), std::collections::HashMap::from([("channel".to_string(), _map_get(&_map_get(&g, &"key".to_string()), &"channel".to_string())), ("id".to_string(), _map_get(&_map_get(&g, &"key".to_string()), &"id".to_string())), ("sales".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"p".to_string()), &"sales".to_string()));
    }
    _res
})), ("returns".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"p".to_string()), &"returns".to_string()));
    }
    _res
})), ("profit".to_string(), _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"p".to_string()), &"profit".to_string()));
    }
    _res
}) - _sum(&{
    let mut _res = Vec::new();
    for x in g {
        _res.push(_map_get(&_map_get(&x, &"p".to_string()), &"profit_loss".to_string()));
    }
    _res
}))])));
    }
    _pairs.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
    let mut _res = Vec::new();
    for p in _pairs { _res.push(p.1); }
    _res
};
    json(result);
    test_TPCDS_Q5_empty();
}

fn _map_get<K: std::cmp::Eq + std::hash::Hash, V: Clone>(m: &std::collections::HashMap<K, V>, k: &K) -> V {
    m.get(k).unwrap().clone()
}
fn _sum<T: Into<f64> + Copy>(v: &[T]) -> f64 {
    if v.is_empty() { return 0.0 }
    let mut sum = 0.0;
    for &it in v { sum += Into::<f64>::into(it); }
    sum
}
fn _union<T: PartialEq + Clone>(a: &[T], b: &[T]) -> Vec<T> {
    let mut res = a.to_vec();
    for it in b {
        if !res.contains(it) { res.push(it.clone()); }
    }
    res
}
fn expect(cond: bool) {
    if !cond { panic!("expect failed"); }
}
