// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:22:38Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Customer {
        c_customer_sk: i32,
        c_current_addr_sk: i32,
        c_current_cdemo_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct CustomerAddress {
        ca_address_sk: i32,
        ca_county: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct CustomerDemographics {
        cd_demo_sk: i32,
        cd_gender: &'static str,
        cd_marital_status: &'static str,
        cd_education_status: &'static str,
        cd_purchase_estimate: i32,
        cd_credit_rating: &'static str,
        cd_dep_count: i32,
        cd_dep_employed_count: i32,
        cd_dep_college_count: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct StoreSale {
        ss_customer_sk: i32,
        ss_sold_date_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct DateDim {
        d_date_sk: i32,
        d_year: i32,
        d_moy: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Customer1 {
    c_customer_sk: i32,
    c_current_addr_sk: i32,
    c_current_cdemo_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Customer_addres {
    ca_address_sk: i32,
    ca_county: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Customer_demographic {
    cd_demo_sk: i32,
    cd_gender: &'static str,
    cd_marital_status: &'static str,
    cd_education_status: &'static str,
    cd_purchase_estimate: i32,
    cd_credit_rating: &'static str,
    cd_dep_count: i32,
    cd_dep_employed_count: i32,
    cd_dep_college_count: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Store_sale {
    ss_customer_sk: i32,
    ss_sold_date_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Date_dim {
    d_date_sk: i32,
    d_year: i32,
    d_moy: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key {
    gender: &'static str,
    marital: &'static str,
    education: &'static str,
    purchase: i32,
    credit: &'static str,
    dep: i32,
    depemp: i32,
    depcol: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Group {
    key: Key,
    items: Vec<Customer_demographic>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result {
    cd_gender: &'static str,
    cd_marital_status: &'static str,
    cd_education_status: &'static str,
    cnt1: i32,
    cd_purchase_estimate: i32,
    cnt2: i32,
    cd_credit_rating: &'static str,
    cnt3: i32,
    cd_dep_count: i32,
    cnt4: i32,
    cd_dep_employed_count: i32,
    cnt5: i32,
    cd_dep_college_count: i32,
    cnt6: i32,
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let customer = vec![Customer1 { c_customer_sk: 1, c_current_addr_sk: 1, c_current_cdemo_sk: 1 }];
    let customer_address = vec![Customer_addres { ca_address_sk: 1, ca_county: "CountyA" }];
    let customer_demographics = vec![Customer_demographic { cd_demo_sk: 1, cd_gender: "F", cd_marital_status: "M", cd_education_status: "College", cd_purchase_estimate: 5000, cd_credit_rating: "Good", cd_dep_count: 1, cd_dep_employed_count: 1, cd_dep_college_count: 0 }];
    let store_sales = vec![Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1 }];
    let web_sales = vec![];
    let catalog_sales = vec![];
    let date_dim = vec![Date_dim { d_date_sk: 1, d_year: 2000, d_moy: 2 }];
    let active = { let mut tmp2 = Vec::new();for c in &customer { for ca in &customer_address { if !(c.c_current_addr_sk == ca.ca_address_sk && ca.ca_county == "CountyA") { continue; } for cd in &customer_demographics { if !(c.c_current_cdemo_sk == cd.cd_demo_sk) { continue; } if !(({ let mut tmp1 = Vec::new();for ss in &store_sales { for d in &date_dim { if !(ss.ss_sold_date_sk == d.d_date_sk) { continue; } if !(ss.ss_customer_sk == c.c_customer_sk && d.d_year == 2000 && d.d_moy >= 2 && d.d_moy <= 5) { continue; } tmp1.push(ss.clone()); } } tmp1 }.len() > 0)) { continue; } tmp2.push(cd.clone()); } } } tmp2 };
    let result = { let mut tmp3 = std::collections::HashMap::new();for a in &active { let key = Key { gender: a.cd_gender, marital: a.cd_marital_status, education: a.cd_education_status, purchase: a.cd_purchase_estimate, credit: a.cd_credit_rating, dep: a.cd_dep_count, depemp: a.cd_dep_employed_count, depcol: a.cd_dep_college_count }; tmp3.entry(key).or_insert_with(Vec::new).push(a.clone()); } let mut tmp4 = Vec::<Group>::new(); for (k,v) in tmp3 { tmp4.push(Group { key: k, items: v }); } tmp4.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp4 { result.push(Result { cd_gender: g.key.gender, cd_marital_status: g.key.marital, cd_education_status: g.key.education, cnt1: { let mut tmp5 = Vec::new();for _ in &g.clone().items { tmp5.push(_.clone()); } tmp5 }.len() as i32, cd_purchase_estimate: g.key.purchase, cnt2: { let mut tmp6 = Vec::new();for _ in &g.clone().items { tmp6.push(_.clone()); } tmp6 }.len() as i32, cd_credit_rating: g.key.credit, cnt3: { let mut tmp7 = Vec::new();for _ in &g.clone().items { tmp7.push(_.clone()); } tmp7 }.len() as i32, cd_dep_count: g.key.dep, cnt4: { let mut tmp8 = Vec::new();for _ in &g.clone().items { tmp8.push(_.clone()); } tmp8 }.len() as i32, cd_dep_employed_count: g.key.depemp, cnt5: { let mut tmp9 = Vec::new();for _ in &g.clone().items { tmp9.push(_.clone()); } tmp9 }.len() as i32, cd_dep_college_count: g.key.depcol, cnt6: { let mut tmp10 = Vec::new();for _ in &g.clone().items { tmp10.push(_.clone()); } tmp10 }.len() as i32 }); } result };
    _json(&result);
    assert!(result == vec![Result { cd_gender: "F", cd_marital_status: "M", cd_education_status: "College", cnt1: 1, cd_purchase_estimate: 5000, cnt2: 1, cd_credit_rating: "Good", cnt3: 1, cd_dep_count: 1, cnt4: 1, cd_dep_employed_count: 1, cnt5: 1, cd_dep_college_count: 0, cnt6: 1 }]);
}
