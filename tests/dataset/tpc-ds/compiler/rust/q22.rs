// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:22:42Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Inventory {
        inv_item_sk: i32,
        inv_date_sk: i32,
        inv_quantity_on_hand: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct DateDim {
        d_date_sk: i32,
        d_month_seq: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Item {
        i_item_sk: i32,
        i_product_name: &'static str,
        i_brand: &'static str,
        i_class: &'static str,
        i_category: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Inventory1 {
    inv_item_sk: i32,
    inv_date_sk: i32,
    inv_quantity_on_hand: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Date_dim {
    d_date_sk: i32,
    d_month_seq: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item2 {
    i_item_sk: i32,
    i_product_name: &'static str,
    i_brand: &'static str,
    i_class: &'static str,
    i_category: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key {
    product_name: &'static str,
    brand: &'static str,
    class: &'static str,
    category: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item3 {
    inv: Inventory1,
    d: Date_dim,
    i: Item2,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Group {
    key: Key,
    items: Vec<Item3>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result {
    i_product_name: &'static str,
    i_brand: &'static str,
    i_class: &'static str,
    i_category: &'static str,
    qoh: f64,
}

fn avg<T>(v: &[T]) -> f64 where T: Into<f64> + Copy {
    let sum: f64 = v.iter().map(|&x| x.into()).sum();
    sum / v.len() as f64
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let inventory = vec![Inventory1 { inv_item_sk: 1, inv_date_sk: 1, inv_quantity_on_hand: 10 }, Inventory1 { inv_item_sk: 1, inv_date_sk: 2, inv_quantity_on_hand: 20 }, Inventory1 { inv_item_sk: 1, inv_date_sk: 3, inv_quantity_on_hand: 10 }, Inventory1 { inv_item_sk: 1, inv_date_sk: 4, inv_quantity_on_hand: 20 }, Inventory1 { inv_item_sk: 2, inv_date_sk: 1, inv_quantity_on_hand: 50 }];
    let date_dim = vec![Date_dim { d_date_sk: 1, d_month_seq: 0 }, Date_dim { d_date_sk: 2, d_month_seq: 1 }, Date_dim { d_date_sk: 3, d_month_seq: 2 }, Date_dim { d_date_sk: 4, d_month_seq: 3 }];
    let item = vec![Item2 { i_item_sk: 1, i_product_name: "Prod1", i_brand: "Brand1", i_class: "Class1", i_category: "Cat1" }, Item2 { i_item_sk: 2, i_product_name: "Prod2", i_brand: "Brand2", i_class: "Class2", i_category: "Cat2" }];
    let qoh = { let mut tmp1 = std::collections::HashMap::new();for inv in &inventory { for d in &date_dim { if !(inv.inv_date_sk == d.d_date_sk) { continue; } for i in &item { if !(inv.inv_item_sk == i.i_item_sk) { continue; } if !(d.d_month_seq >= 0 && d.d_month_seq <= 11) { continue; } let key = Key { product_name: i.i_product_name, brand: i.i_brand, class: i.i_class, category: i.i_category }; tmp1.entry(key).or_insert_with(Vec::new).push(Item3 {inv: inv.clone(), d: d.clone(), i: i.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { i_product_name: g.key.product_name, i_brand: g.key.brand, i_class: g.key.class, i_category: g.key.category, qoh: avg(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push(x.inv_quantity_on_hand); } tmp3 }) }); } result };
    _json(&qoh);
    assert!(qoh == vec![Result { i_product_name: "Prod1", i_brand: "Brand1", i_class: "Class1", i_category: "Cat1", qoh: 15.0 }, Result { i_product_name: "Prod2", i_brand: "Brand2", i_class: "Class2", i_category: "Cat2", qoh: 50.0 }]);
}
