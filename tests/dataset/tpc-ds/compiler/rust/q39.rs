// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:09:25Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Inventory {
    inv_item_sk: i32,
    inv_warehouse_sk: i32,
    inv_date_sk: i32,
    inv_quantity_on_hand: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item {
    i_item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Warehouse {
    w_warehouse_sk: i32,
    w_warehouse_name: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Date_dim {
    d_date_sk: i32,
    d_year: i32,
    d_moy: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key {
    w: i32,
    i: i32,
    month: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item1 {
    inv: Inventory,
    d: Date_dim,
    i: Item,
    w: Warehouse,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Group {
    key: Key,
    items: Vec<Item1>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result {
    w: i32,
    i: i32,
    qty: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item2 {
    w_warehouse_sk: i32,
    i_item_sk: i32,
    cov: f64,
}

fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn avg<T>(v: &[T]) -> f64 where T: Into<f64> + Copy {
    let sum: f64 = v.iter().map(|&x| x.into()).sum();
    sum / v.len() as f64
}

fn sum<T>(v: &[T]) -> T where T: std::iter::Sum<T> + Copy {
    v.iter().copied().sum()
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    mod math {
        pub const pi: f64 = std::f64::consts::PI;
        pub const e: f64 = std::f64::consts::E;
        pub fn sqrt(x: f64) -> f64 { x.sqrt() }
        pub fn pow(x: f64, y: f64) -> f64 { x.powf(y) }
        pub fn sin(x: f64) -> f64 { x.sin() }
        pub fn log(x: f64) -> f64 { x.ln() }
    }
    let inventory = vec![Inventory { inv_item_sk: 1, inv_warehouse_sk: 1, inv_date_sk: 1, inv_quantity_on_hand: 10 }, Inventory { inv_item_sk: 1, inv_warehouse_sk: 1, inv_date_sk: 2, inv_quantity_on_hand: 10 }, Inventory { inv_item_sk: 1, inv_warehouse_sk: 1, inv_date_sk: 3, inv_quantity_on_hand: 250 }];
    let item = vec![Item { i_item_sk: 1 }];
    let warehouse = vec![Warehouse { w_warehouse_sk: 1, w_warehouse_name: "W1" }];
    let date_dim = vec![Date_dim { d_date_sk: 1, d_year: 2000, d_moy: 1 }, Date_dim { d_date_sk: 2, d_year: 2000, d_moy: 2 }, Date_dim { d_date_sk: 3, d_year: 2000, d_moy: 3 }];
    let monthly = { let mut tmp1 = std::collections::HashMap::new();for inv in &inventory { for d in &date_dim { if !(inv.inv_date_sk == d.d_date_sk) { continue; } for i in &item { if !(inv.inv_item_sk == i.i_item_sk) { continue; } for w in &warehouse { if !(inv.inv_warehouse_sk == w.w_warehouse_sk) { continue; } if !(d.d_year == 2000) { continue; } let key = Key { w: w.w_warehouse_sk, i: i.i_item_sk, month: d.d_moy }; tmp1.entry(key).or_insert_with(Vec::new).push(Item1 {inv: inv.clone(), d: d.clone(), i: i.clone(), w: w.clone() }); } } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { w: g.key.w, i: g.key.i, qty: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push(x.inv_quantity_on_hand); } tmp3 }) }); } result };
    let mut grouped: std::collections::HashMap<&'static str, std::collections::HashMap<&'static str, any>> = { let mut m = std::collections::BTreeMap::new(); m };
    for m in monthly {
        let key = { let mut m = std::collections::BTreeMap::new(); m.insert("w", m.w); m.insert("i", m.i); m }.to_string();
        if grouped.contains_key(&key) {
            let g = grouped[&key];
            grouped.insert(key, { let mut m = std::collections::BTreeMap::new(); m.insert("w", g.w); m.insert("i", g.i); m.insert("qtys", append(g.qtys, m.qty)); m });
        } else {
            grouped.insert(key, { let mut m = std::collections::BTreeMap::new(); m.insert("w", m.w); m.insert("i", m.i); m.insert("qtys", vec![m.qty]); m });
        }
    }
    let mut summary = vec![];
    for g in grouped.values().cloned().collect::<Vec<_>>() {
        let mean = avg(&g.qtys);
        let mut sumsq = 0.0;
        for q in g.qtys {
            sumsq = sumsq + (q - mean) * (q - mean);
        }
        let variance = sumsq / (g.qtys.len() as i32 - 1) as f64;
        let cov = math::sqrt(variance) / mean;
        if cov > 1.5 {
            summary = append(summary, Item2 { w_warehouse_sk: g.w, i_item_sk: g.i, cov: cov });
        }
    }
    _json(&summary);
    assert!(summary == vec![Item2 { w_warehouse_sk: 1, i_item_sk: 1, cov: 1.539600717839002 }]);
}
