// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:17:19Z
#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Catalog_return {
    cust: i32,
    state: &'static str,
    amt: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group {
    key: &'static str,
    items: Vec<Catalog_return>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result {
    state: &'static str,
    avg_amt: f64,
}

fn avg<T>(v: &[T]) -> f64 where T: Into<f64> + Copy {
    let sum: f64 = v.iter().map(|&x| x.into()).sum();
    sum / v.len() as f64
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let catalog_returns = vec![Catalog_return { cust: 1, state: "CA", amt: 40.0 }, Catalog_return { cust: 2, state: "CA", amt: 50.0 }, Catalog_return { cust: 3, state: "CA", amt: 81.0 }, Catalog_return { cust: 4, state: "TX", amt: 30.0 }, Catalog_return { cust: 5, state: "TX", amt: 20.0 }];
    let avg_list = { let mut tmp1 = std::collections::HashMap::new();for r in &catalog_returns { let key = r.state; tmp1.entry(key).or_insert_with(Vec::new).push(r.clone()); } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { state: g.key, avg_amt: avg(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push(x.amt); } tmp3 }) }); } result };
    let avg_state = first({ let mut tmp4 = Vec::new();for a in &avg_list { if !(a.state == "CA") { continue; } tmp4.push(a.clone()); } tmp4 });
    let result_list = { let mut tmp5 = Vec::new();for r in &catalog_returns { if !(r.state == "CA" && r.amt > avg_state.avg_amt * 1.2) { continue; } tmp5.push(r.amt); } tmp5 };
    let result = first(result_list);
    _json(&result);
    assert!(result == 81.0);
}
