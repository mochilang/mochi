// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:22:42Z
#[derive(Default, Debug, Clone, PartialEq)]
struct StoreSale {
        ss_quantity: i32,
        ss_list_price: f64,
        ss_coupon_amt: f64,
        ss_wholesale_cost: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Store_sale {
    ss_quantity: i32,
    ss_list_price: f64,
    ss_coupon_amt: f64,
    ss_wholesale_cost: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group {
    key: f64,
    items: Vec<Store_sale>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group1 {
    key: f64,
    items: Vec<Store_sale>,
}

fn avg<T>(v: &[T]) -> f64 where T: Into<f64> + Copy {
    let sum: f64 = v.iter().map(|&x| x.into()).sum();
    sum / v.len() as f64
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let store_sales = vec![Store_sale { ss_quantity: 3, ss_list_price: 100.0, ss_coupon_amt: 50.0, ss_wholesale_cost: 30.0 }, Store_sale { ss_quantity: 8, ss_list_price: 80.0, ss_coupon_amt: 10.0, ss_wholesale_cost: 20.0 }, Store_sale { ss_quantity: 12, ss_list_price: 60.0, ss_coupon_amt: 5.0, ss_wholesale_cost: 15.0 }];
    let bucket1 = { let mut tmp1 = Vec::new();for ss in &store_sales { if !(ss.ss_quantity >= 0 && ss.ss_quantity <= 5 && ((ss.ss_list_price >= 0 as f64 && ss.ss_list_price <= 110 as f64) || (ss.ss_coupon_amt >= 0 as f64 && ss.ss_coupon_amt <= 1000 as f64) || (ss.ss_wholesale_cost >= 0 as f64 && ss.ss_wholesale_cost <= 50 as f64))) { continue; } tmp1.push(ss.clone()); } tmp1 };
    let bucket2 = { let mut tmp2 = Vec::new();for ss in &store_sales { if !(ss.ss_quantity >= 6 && ss.ss_quantity <= 10 && ((ss.ss_list_price >= 0 as f64 && ss.ss_list_price <= 110 as f64) || (ss.ss_coupon_amt >= 0 as f64 && ss.ss_coupon_amt <= 1000 as f64) || (ss.ss_wholesale_cost >= 0 as f64 && ss.ss_wholesale_cost <= 50 as f64))) { continue; } tmp2.push(ss.clone()); } tmp2 };
    let result = { let mut m = std::collections::BTreeMap::new(); m.insert("B1_LP", avg(&{ let mut tmp3 = Vec::new();for x in &bucket1 { tmp3.push(x.ss_list_price); } tmp3 })); m.insert("B1_CNT", bucket1.len() as i32); m.insert("B1_CNTD", { let mut tmp5 = Vec::<Group>::new();for x in &bucket1 { let key = x.ss_list_price; if let Some(tmp6) = tmp5.iter_mut().find(|g| g.key == key) { tmp6.items.push(x.clone()); } else { tmp5.push(Group { key: key, items: vec![x.clone()] }); } } let mut result = Vec::new(); for g in tmp5 { result.push(g.key); } result }.len() as i32); m.insert("B2_LP", avg(&{ let mut tmp7 = Vec::new();for x in &bucket2 { tmp7.push(x.ss_list_price); } tmp7 })); m.insert("B2_CNT", bucket2.len() as i32); m.insert("B2_CNTD", { let mut tmp9 = Vec::<Group1>::new();for x in &bucket2 { let key = x.ss_list_price; if let Some(tmp10) = tmp9.iter_mut().find(|g| g.key == key) { tmp10.items.push(x.clone()); } else { tmp9.push(Group1 { key: key, items: vec![x.clone()] }); } } let mut result = Vec::new(); for g in tmp9 { result.push(g.key); } result }.len() as i32); m };
    _json(&result.clone());
    assert!(result.clone() == { let mut m = std::collections::BTreeMap::new(); m.insert("B1_LP", 100.0); m.insert("B1_CNT", 1); m.insert("B1_CNTD", 1); m.insert("B2_LP", 80.0); m.insert("B2_CNT", 1); m.insert("B2_CNTD", 1); m });
}
