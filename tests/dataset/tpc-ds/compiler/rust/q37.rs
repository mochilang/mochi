// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:10:55Z
#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item {
    i_item_sk: i32,
    i_item_id: &'static str,
    i_item_desc: &'static str,
    i_current_price: f64,
    i_manufact_id: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Inventory {
    inv_item_sk: i32,
    inv_warehouse_sk: i32,
    inv_date_sk: i32,
    inv_quantity_on_hand: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Date_dim {
    d_date_sk: i32,
    d_date: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Catalog_sale {
    cs_item_sk: i32,
    cs_sold_date_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Key {
    id: &'static str,
    desc: &'static str,
    price: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item1 {
    i: Item,
    inv: Inventory,
    d: Date_dim,
    cs: Catalog_sale,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group {
    key: Key,
    items: Vec<Item1>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result {
    i_item_id: &'static str,
    i_item_desc: &'static str,
    i_current_price: f64,
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let item = vec![Item { i_item_sk: 1, i_item_id: "I1", i_item_desc: "Item1", i_current_price: 30.0, i_manufact_id: 800 }, Item { i_item_sk: 2, i_item_id: "I2", i_item_desc: "Item2", i_current_price: 60.0, i_manufact_id: 801 }];
    let inventory = vec![Inventory { inv_item_sk: 1, inv_warehouse_sk: 1, inv_date_sk: 1, inv_quantity_on_hand: 200 }, Inventory { inv_item_sk: 2, inv_warehouse_sk: 1, inv_date_sk: 1, inv_quantity_on_hand: 300 }];
    let date_dim = vec![Date_dim { d_date_sk: 1, d_date: "2000-01-15" }];
    let catalog_sales = vec![Catalog_sale { cs_item_sk: 1, cs_sold_date_sk: 1 }];
    let result = { let mut tmp2 = Vec::<Group>::new();for i in &item { for inv in &inventory { if !(i.i_item_sk == inv.inv_item_sk) { continue; } for d in &date_dim { if !(inv.inv_date_sk == d.d_date_sk) { continue; } for cs in &catalog_sales { if !(cs.cs_item_sk == i.i_item_sk) { continue; } if !(i.i_current_price >= 20 as f64 && i.i_current_price <= 50 as f64 && i.i_manufact_id >= 800 && i.i_manufact_id <= 803 && inv.inv_quantity_on_hand >= 100 && inv.inv_quantity_on_hand <= 500) { continue; } let key = Key { id: i.i_item_id, desc: i.i_item_desc, price: i.i_current_price }; if let Some(tmp3) = tmp2.iter_mut().find(|g| g.key == key) { tmp3.items.push(Item1 {i: i.clone(), inv: inv.clone(), d: d.clone(), cs: cs.clone() }); } else { tmp2.push(Group { key: key, items: vec![Item1 {i: i.clone(), inv: inv.clone(), d: d.clone(), cs: cs.clone() }] }); } } } } } tmp2.sort_by(|a,b| (a.key.id).partial_cmp(&(b.key.id)).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { i_item_id: g.key.id, i_item_desc: g.key.desc, i_current_price: g.key.price }); } result };
    _json(&result);
    assert!(result == vec![Result { i_item_id: "I1", i_item_desc: "Item1", i_current_price: 30.0 }]);
}
