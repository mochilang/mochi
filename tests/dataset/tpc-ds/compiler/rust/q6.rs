// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:10:41Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Customer_addres {
    ca_address_sk: i32,
    ca_state: &'static str,
    ca_zip: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Customer {
    c_customer_sk: i32,
    c_current_addr_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Store_sale {
    ss_customer_sk: i32,
    ss_sold_date_sk: i32,
    ss_item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Date_dim {
    d_date_sk: i32,
    d_year: i32,
    d_moy: i32,
    d_month_seq: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item {
    i_item_sk: i32,
    i_category: &'static str,
    i_current_price: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item1 {
    a: Customer_addres,
    c: Customer,
    s: Store_sale,
    d: Date_dim,
    i: Item,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group {
    key: &'static str,
    items: Vec<Item1>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result {
    state: &'static str,
    cnt: i32,
}

fn avg<T>(v: &[T]) -> f64 where T: Into<f64> + Copy {
    let sum: f64 = v.iter().map(|&x| x.into()).sum();
    sum / v.len() as f64
}

fn max<T: PartialOrd + Copy>(v: &[T]) -> T {
    *v.iter().max_by(|a,b| a.partial_cmp(b).unwrap()).unwrap()
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let customer_address = vec![Customer_addres { ca_address_sk: 1, ca_state: "CA", ca_zip: "12345" }];
    let customer = vec![Customer { c_customer_sk: 1, c_current_addr_sk: 1 }];
    let store_sales = vec![Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 1, ss_sold_date_sk: 1, ss_item_sk: 1 }];
    let date_dim = vec![Date_dim { d_date_sk: 1, d_year: 1999, d_moy: 5, d_month_seq: 120 }];
    let item = vec![Item { i_item_sk: 1, i_category: "A", i_current_price: 100.0 }, Item { i_item_sk: 2, i_category: "A", i_current_price: 50.0 }];
    let target_month_seq = max(&{ let mut tmp1 = Vec::new();for d in &date_dim { if !(d.d_year == 1999 && d.d_moy == 5) { continue; } tmp1.push(d.d_month_seq); } tmp1 });
    let result = { let mut tmp3 = std::collections::HashMap::new();for a in &customer_address { for c in &customer { if !(a.ca_address_sk == c.c_current_addr_sk) { continue; } for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } for i in &item { if !(s.ss_item_sk == i.i_item_sk) { continue; } if !(d.d_month_seq == target_month_seq && i.i_current_price > 1.2 * avg(&{ let mut tmp2 = Vec::new();for j in &item { if !(j.i_category == i.i_category) { continue; } tmp2.push(j.i_current_price); } tmp2 })) { continue; } let key = a.ca_state; tmp3.entry(key).or_insert_with(Vec::new).push(Item1 {a: a.clone(), c: c.clone(), s: s.clone(), d: d.clone(), i: i.clone() }); } } } } } let mut tmp4 = Vec::<Group>::new(); for (k,v) in tmp3 { tmp4.push(Group { key: k, items: v }); } tmp4.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut tmp5 = Vec::new(); for g in tmp4.into_iter() { if g.clone().items.len() as i32 >= 10 { tmp5.push(g); } } tmp5.sort_by(|a,b| ((a.clone().items.len() as i32, a.key)).partial_cmp(&((b.clone().items.len() as i32, b.key))).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result { state: g.key, cnt: g.clone().items.len() as i32 }); } result = result[0usize..100 as usize].to_vec(); result };
    _json(&result);
    assert!(result == vec![Result { state: "CA", cnt: 10 }]);
}
