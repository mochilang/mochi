// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:09:28Z
#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Web {
    item: &'static str,
    return_ratio: f64,
    currency_ratio: f64,
    return_rank: i32,
    currency_rank: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Catalog {
    item: &'static str,
    return_ratio: f64,
    currency_ratio: f64,
    return_rank: i32,
    currency_rank: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Store {
    item: &'static str,
    return_ratio: f64,
    currency_ratio: f64,
    return_rank: i32,
    currency_rank: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result {
    channel: &'static str,
    item: &'static str,
    return_ratio: f64,
    return_rank: i32,
    currency_rank: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result1 {
    channel: &'static str,
    item: &'static str,
    return_ratio: f64,
    return_rank: i32,
    currency_rank: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result2 {
    channel: &'static str,
    item: &'static str,
    return_ratio: f64,
    return_rank: i32,
    currency_rank: i32,
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let web = vec![Web { item: "A", return_ratio: 0.2, currency_ratio: 0.3, return_rank: 1, currency_rank: 1 }, Web { item: "B", return_ratio: 0.5, currency_ratio: 0.6, return_rank: 2, currency_rank: 2 }];
    let catalog = vec![Catalog { item: "A", return_ratio: 0.3, currency_ratio: 0.4, return_rank: 1, currency_rank: 1 }];
    let store = vec![Store { item: "A", return_ratio: 0.25, currency_ratio: 0.35, return_rank: 1, currency_rank: 1 }];
    let tmp = (concat({ let mut tmp1 = Vec::new();for w in &web { if !(w.return_rank <= 10 || w.currency_rank <= 10) { continue; } tmp1.push(Result { channel: "web", item: w.item, return_ratio: w.return_ratio, return_rank: w.return_rank, currency_rank: w.currency_rank }); } tmp1 }, { let mut tmp2 = Vec::new();for c in &catalog { if !(c.return_rank <= 10 || c.currency_rank <= 10) { continue; } tmp2.push(Result1 { channel: "catalog", item: c.item, return_ratio: c.return_ratio, return_rank: c.return_rank, currency_rank: c.currency_rank }); } tmp2 }, { let mut tmp3 = Vec::new();for s in &store { if !(s.return_rank <= 10 || s.currency_rank <= 10) { continue; } tmp3.push(Result2 { channel: "store", item: s.item, return_ratio: s.return_ratio, return_rank: s.return_rank, currency_rank: s.currency_rank }); } tmp3 }));
    let result = { let mut tmp4 = Vec::new();for r in &tmp { let tmp5 = r.clone(); let tmp6 = (r.channel, r.return_rank, r.currency_rank, r.item); tmp4.push((tmp6, tmp5)); } tmp4.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); let mut tmp7 = Vec::new(); for p in tmp4 { tmp7.push(p.1); } tmp7 };
    _json(&result);
    assert!(result == vec![Result { channel: "catalog", item: "A", return_ratio: 0.3, return_rank: 1, currency_rank: 1 }, Result { channel: "store", item: "A", return_ratio: 0.25, return_rank: 1, currency_rank: 1 }, Result1 { channel: "web", item: "A", return_ratio: 0.2, return_rank: 1, currency_rank: 1 }, Result { channel: "web", item: "B", return_ratio: 0.5, return_rank: 2, currency_rank: 2 }]);
}
