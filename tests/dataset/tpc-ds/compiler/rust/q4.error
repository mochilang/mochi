rustc: exit status 1
warning: type `Store_sale` should have an upper camel case name
  --> /tmp/q4.rs:12:8
   |
12 | struct Store_sale {
   |        ^^^^^^^^^^ help: convert the identifier to upper camel case: `StoreSale`
   |
   = note: `#[warn(non_camel_case_types)]` on by default

warning: type `Catalog_sale` should have an upper camel case name
  --> /tmp/q4.rs:22:8
   |
22 | struct Catalog_sale {
   |        ^^^^^^^^^^^^ help: convert the identifier to upper camel case: `CatalogSale`

warning: type `Web_sale` should have an upper camel case name
  --> /tmp/q4.rs:32:8
   |
32 | struct Web_sale {
   |        ^^^^^^^^ help: convert the identifier to upper camel case: `WebSale`

warning: type `Date_dim` should have an upper camel case name
  --> /tmp/q4.rs:42:8
   |
42 | struct Date_dim {
   |        ^^^^^^^^ help: convert the identifier to upper camel case: `DateDim`

warning: unnecessary parentheses around function argument
   --> /tmp/q4.rs:173:2156
    |
173 | ...), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |       ^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
    |
    = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
    |
173 -     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
173 +     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), { let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result });
    |

warning: unnecessary parentheses around function argument
   --> /tmp/q4.rs:173:44
    |
173 | ...ll(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), (...
    |       ^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^
    |
help: remove these parentheses
    |
173 -     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
173 +     let year_total = _union_all(_union_all({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }, ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |

warning: unnecessary parentheses around function argument
   --> /tmp/q4.rs:173:1091
    |
173 | ...), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ...
    |       ^                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ^
    |
help: remove these parentheses
    |
173 -     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
173 +     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), { let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result }), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |

error[E0609]: no field `ss_ext_list_price` on type `&Item`
   --> /tmp/q4.rs:173:934
    |
173 | ...::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sal...
    |                                                       ^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.s.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++

error[E0609]: no field `ss_ext_wholesale_cost` on type `&Item`
   --> /tmp/q4.rs:173:956
    |
173 | ...e().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as...
    |                                                     ^^^^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.s.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ++

error[E0609]: no field `ss_ext_discount_amt` on type `&Item`
   --> /tmp/q4.rs:173:982
    |
173 | ...x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_ty...
    |                                                      ^^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.s.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ++

error[E0609]: no field `ss_ext_sales_price` on type `&Item`
   --> /tmp/q4.rs:173:1007
    |
173 | ...ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }),...
    |                                                       ^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.s.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ++

error[E0609]: no field `cs_ext_list_price` on type `&Item2`
   --> /tmp/q4.rs:173:1998
    |
173 | ...::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sal...
    |                                                       ^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              +++

error[E0609]: no field `cs_ext_wholesale_cost` on type `&Item2`
   --> /tmp/q4.rs:173:2020
    |
173 | ...e().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as...
    |                                                     ^^^^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    +++

error[E0609]: no field `cs_ext_discount_amt` on type `&Item2`
   --> /tmp/q4.rs:173:2046
    |
173 | ...x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_ty...
    |                                                      ^^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              +++

error[E0609]: no field `cs_ext_sales_price` on type `&Item2`
   --> /tmp/q4.rs:173:2071
    |
173 | ...cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result }))...
    |                                                       ^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       +++

error[E0308]: mismatched types
   --> /tmp/q4.rs:173:2144
    |
173 | ... { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })...
    |       ------      ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     ^^^^^^ expected `Vec<Result>`, found `Vec<Result4>`
    |       |           |
    |       |           this argument has type `Result4`...
    |       ... which causes `result` to have type `Vec<Result4>`
    |
    = note: expected struct `Vec<Result>`
               found struct `Vec<Result4>`

error[E0609]: no field `ws_ext_list_price` on type `&Item6`
   --> /tmp/q4.rs:173:3059
    |
173 | ...::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sal...
    |                                                       ^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +++

error[E0609]: no field `ws_ext_wholesale_cost` on type `&Item6`
   --> /tmp/q4.rs:173:3081
    |
173 | ...e().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as...
    |                                                     ^^^^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         +++

error[E0609]: no field `ws_ext_discount_amt` on type `&Item6`
   --> /tmp/q4.rs:173:3107
    |
173 | ...x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_ty...
    |                                                      ^^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   +++

error[E0609]: no field `ws_ext_sales_price` on type `&Item6`
   --> /tmp/q4.rs:173:3132
    |
173 | ...ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                       ^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
173 |     let year_total = _union_all(_union_all(({ let mut tmp1 = std::collections::HashMap::new();for c in &customer { for s in &store_sales { if !(c.c_customer_sk == s.ss_customer_sk) { continue; } for d in &date_dim { if !(s.ss_sold_date_sk == d.d_date_sk) { continue; } let key = Key { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp1.entry(key).or_insert_with(Vec::new).push(Item {c: c.clone(), s: s.clone(), d: d.clone() }); } } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push((((x.ss_ext_list_price - x.ss_ext_wholesale_cost - x.ss_ext_discount_amt) + x.ss_ext_sales_price) as f64) / 2 as f64); } tmp3 }), sale_type: "s" }); } result }), ({ let mut tmp4 = std::collections::HashMap::new();for c in &customer { for cs in &catalog_sales { if !(c.c_customer_sk == cs.cs_bill_customer_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk) { continue; } let key = Key1 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp4.entry(key).or_insert_with(Vec::new).push(Item2 {c: c.clone(), cs: cs.clone(), d: d.clone() }); } } } let mut tmp5 = Vec::<Group3>::new(); for (k,v) in tmp4 { tmp5.push(Group3 { key: k, items: v }); } tmp5.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp5 { result.push(Result4 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push((((x.cs_ext_list_price - x.cs_ext_wholesale_cost - x.cs_ext_discount_amt) + x.cs_ext_sales_price) as f64) / 2 as f64); } tmp6 }), sale_type: "c" }); } result })), ({ let mut tmp7 = std::collections::HashMap::new();for c in &customer { for ws in &web_sales { if !(c.c_customer_sk == ws.ws_bill_customer_sk) { continue; } for d in &date_dim { if !(ws.ws_sold_date_sk == d.d_date_sk) { continue; } let key = Key5 { id: c.c_customer_id, first: c.c_first_name, last: c.c_last_name, login: c.c_login, year: d.d_year }; tmp7.entry(key).or_insert_with(Vec::new).push(Item6 {c: c.clone(), ws: ws.clone(), d: d.clone() }); } } } let mut tmp8 = Vec::<Group7>::new(); for (k,v) in tmp7 { tmp8.push(Group7 { key: k, items: v }); } tmp8.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp8 { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            +++

error[E0308]: mismatched types
   --> /tmp/q4.rs:173:3205
    |
173 | ... { result.push(Result8 { customer_id: g.key.id, customer_first_name: g.key.first, customer_last_name: g.key.last, customer_login: g.key.login, dyear: g.key.year, year_total: sum(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push((((x.ws_ext_list_price - x.ws_ext_wholesale_cost - x.ws_ext_discount_amt) + x.ws_ext_sales_price) as f64) / 2 as f64); } tmp9 }), sale_type: "w" }); } result }));
    |       ------      ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     ^^^^^^ expected `Vec<Result>`, found `Vec<Result8>`
    |       |           |
    |       |           this argument has type `Result8`...
    |       ... which causes `result` to have type `Vec<Result8>`
    |
    = note: expected struct `Vec<Result>`
               found struct `Vec<Result8>`

error[E0308]: `if` and `else` have incompatible types
   --> /tmp/q4.rs:174:863
    |
174 | ...(if c1.year_total > 0 { (c2.year_total as f64) / (c1.year_total as f64) } else { () }) > (if s1.year_total > 0 { (s2.year_total as f64...
    |                            -----------------------------------------------          ^^ expected `f64`, found `()`
    |                            |
    |                            expected because of this

error[E0308]: `if` and `else` have incompatible types
   --> /tmp/q4.rs:174:952
    |
174 | ...(if s1.year_total > 0 { (s2.year_total as f64) / (s1.year_total as f64) } else { () }) && (if c1.year_total > 0 { (c2.year_total as f6...
    |                            -----------------------------------------------          ^^ expected `f64`, found `()`
    |                            |
    |                            expected because of this

error[E0308]: `if` and `else` have incompatible types
   --> /tmp/q4.rs:174:1042
    |
174 | ...(if c1.year_total > 0 { (c2.year_total as f64) / (c1.year_total as f64) } else { () }) > (if w1.year_total > 0 { (w2.year_total as f64...
    |                            -----------------------------------------------          ^^ expected `f64`, found `()`
    |                            |
    |                            expected because of this

error[E0308]: `if` and `else` have incompatible types
   --> /tmp/q4.rs:174:1131
    |
174 | ...(if w1.year_total > 0 { (w2.year_total as f64) / (w1.year_total as f64) } else { () })) { continue; } let tmp11 = Result9 { customer_i...
    |                            -----------------------------------------------          ^^ expected `f64`, found `()`
    |                            |
    |                            expected because of this

error: aborting due to 18 previous errors; 7 warnings emitted

Some errors have detailed explanations: E0308, E0609.
For more information about an error, try `rustc --explain E0308`.
