// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:09:38Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct StoreSale {
        ss_customer_sk: i32,
        ss_item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct CatalogSale {
        cs_bill_customer_sk: i32,
        cs_item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Store_sale {
    ss_customer_sk: i32,
    ss_item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Catalog_sale {
    cs_bill_customer_sk: i32,
    cs_item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key {
    customer_sk: i32,
    item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Group {
    key: Key,
    items: Vec<Store_sale>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result {
    customer_sk: i32,
    item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key1 {
    customer_sk: i32,
    item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Group2 {
    key: Key1,
    items: Vec<Catalog_sale>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result3 {
    customer_sk: i32,
    item_sk: i32,
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let store_sales = vec![Store_sale { ss_customer_sk: 1, ss_item_sk: 1 }, Store_sale { ss_customer_sk: 2, ss_item_sk: 1 }];
    let catalog_sales = vec![Catalog_sale { cs_bill_customer_sk: 1, cs_item_sk: 1 }, Catalog_sale { cs_bill_customer_sk: 3, cs_item_sk: 2 }];
    let ssci = { let mut tmp1 = std::collections::HashMap::new();for ss in &store_sales { let key = Key { customer_sk: ss.ss_customer_sk, item_sk: ss.ss_item_sk }; tmp1.entry(key).or_insert_with(Vec::new).push(ss.clone()); } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { customer_sk: g.key.customer_sk, item_sk: g.key.item_sk }); } result };
    let csci = { let mut tmp3 = std::collections::HashMap::new();for cs in &catalog_sales { let key = Key1 { customer_sk: cs.cs_bill_customer_sk, item_sk: cs.cs_item_sk }; tmp3.entry(key).or_insert_with(Vec::new).push(cs.clone()); } let mut tmp4 = Vec::<Group2>::new(); for (k,v) in tmp3 { tmp4.push(Group2 { key: k, items: v }); } tmp4.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp4 { result.push(Result3 { customer_sk: g.key.customer_sk, item_sk: g.key.item_sk }); } result };
    let both = { let mut tmp5 = Vec::new();for s in &ssci { for c in &csci { if !(s.customer_sk == c.customer_sk && s.item_sk == c.item_sk) { continue; } tmp5.push(1); } } tmp5 }.len() as i32;
    let store_only = { let mut tmp7 = Vec::new();for s in &ssci { if !(!(({ let mut tmp6 = Vec::new();for c in &csci { if !(s.customer_sk == c.customer_sk && s.item_sk == c.item_sk) { continue; } tmp6.push(c.clone()); } tmp6 }.len() > 0))) { continue; } tmp7.push(1); } tmp7 }.len() as i32;
    let catalog_only = { let mut tmp9 = Vec::new();for c in &csci { if !(!(({ let mut tmp8 = Vec::new();for s in &ssci { if !(s.customer_sk == c.customer_sk && s.item_sk == c.item_sk) { continue; } tmp8.push(s.clone()); } tmp8 }.len() > 0))) { continue; } tmp9.push(1); } tmp9 }.len() as i32;
    let result = { let mut m = std::collections::BTreeMap::new(); m.insert("store_only", store_only); m.insert("catalog_only", catalog_only); m.insert("store_and_catalog", both); m };
    _json(&result.clone());
    assert!(result.store_only == 1 && result.catalog_only == 1 && result.store_and_catalog == 1);
}
