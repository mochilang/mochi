// Generated by Mochi compiler v0.10.26 on 2025-07-15T07:22:40Z
#[derive(Default, Debug, Clone, PartialEq)]
struct CatalogSale {
        cs_quantity: i32,
        cs_list_price: f64,
        cs_coupon_amt: f64,
        cs_sales_price: f64,
        cs_net_profit: f64,
        cs_bill_cdemo_sk: i32,
        cs_bill_customer_sk: i32,
        cs_sold_date_sk: i32,
        cs_item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct CustomerDemographics {
        cd_demo_sk: i32,
        cd_gender: &'static str,
        cd_education_status: &'static str,
        cd_dep_count: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Customer {
        c_customer_sk: i32,
        c_current_cdemo_sk: i32,
        c_current_addr_sk: i32,
        c_birth_year: i32,
        c_birth_month: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct CustomerAddress {
        ca_address_sk: i32,
        ca_country: &'static str,
        ca_state: &'static str,
        ca_county: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct DateDim {
        d_date_sk: i32,
        d_year: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Item {
        i_item_sk: i32,
        i_item_id: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Catalog_sale {
    cs_quantity: i32,
    cs_list_price: f64,
    cs_coupon_amt: f64,
    cs_sales_price: f64,
    cs_net_profit: f64,
    cs_bill_cdemo_sk: i32,
    cs_bill_customer_sk: i32,
    cs_sold_date_sk: i32,
    cs_item_sk: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Customer_demographic {
    cd_demo_sk: i32,
    cd_gender: &'static str,
    cd_education_status: &'static str,
    cd_dep_count: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Customer1 {
    c_customer_sk: i32,
    c_current_cdemo_sk: i32,
    c_current_addr_sk: i32,
    c_birth_year: i32,
    c_birth_month: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Customer_addres {
    ca_address_sk: i32,
    ca_country: &'static str,
    ca_state: &'static str,
    ca_county: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Date_dim {
    d_date_sk: i32,
    d_year: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item2 {
    i_item_sk: i32,
    i_item_id: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result {
    i_item_id: &'static str,
    ca_country: &'static str,
    ca_state: &'static str,
    ca_county: &'static str,
    q: i32,
    lp: f64,
    cp: f64,
    sp: f64,
    np: f64,
    by: i32,
    dep: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key {
    i_item_id: &'static str,
    ca_country: &'static str,
    ca_state: &'static str,
    ca_county: &'static str,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group {
    key: Key,
    items: Vec<Result>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result3 {
    i_item_id: &'static str,
    ca_country: &'static str,
    ca_state: &'static str,
    ca_county: &'static str,
    agg1: f64,
    agg2: f64,
    agg3: f64,
    agg4: f64,
    agg5: f64,
    agg6: f64,
    agg7: f64,
}

fn avg<T>(v: &[T]) -> f64 where T: Into<f64> + Copy {
    let sum: f64 = v.iter().map(|&x| x.into()).sum();
    sum / v.len() as f64
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let catalog_sales = vec![Catalog_sale { cs_quantity: 1, cs_list_price: 10.0, cs_coupon_amt: 1.0, cs_sales_price: 9.0, cs_net_profit: 2.0, cs_bill_cdemo_sk: 1, cs_bill_customer_sk: 1, cs_sold_date_sk: 1, cs_item_sk: 1 }];
    let customer_demographics = vec![Customer_demographic { cd_demo_sk: 1, cd_gender: "M", cd_education_status: "College", cd_dep_count: 2 }, Customer_demographic { cd_demo_sk: 2, cd_gender: "F", cd_education_status: "College", cd_dep_count: 2 }];
    let customer = vec![Customer1 { c_customer_sk: 1, c_current_cdemo_sk: 2, c_current_addr_sk: 1, c_birth_year: 1980, c_birth_month: 1 }];
    let customer_address = vec![Customer_addres { ca_address_sk: 1, ca_country: "US", ca_state: "CA", ca_county: "County1" }];
    let date_dim = vec![Date_dim { d_date_sk: 1, d_year: 1999 }];
    let item = vec![Item2 { i_item_sk: 1, i_item_id: "I1" }];
    let joined = { let mut tmp1 = Vec::new();for cs in &catalog_sales { for cd1 in &customer_demographics { if !(cs.cs_bill_cdemo_sk == cd1.cd_demo_sk && cd1.cd_gender == "M" && cd1.cd_education_status == "College") { continue; } for c in &customer { if !(cs.cs_bill_customer_sk == c.c_customer_sk) { continue; } for cd2 in &customer_demographics { if !(c.c_current_cdemo_sk == cd2.cd_demo_sk) { continue; } for ca in &customer_address { if !(c.c_current_addr_sk == ca.ca_address_sk) { continue; } for d in &date_dim { if !(cs.cs_sold_date_sk == d.d_date_sk && d.d_year == 1999) { continue; } for i in &item { if !(cs.cs_item_sk == i.i_item_sk) { continue; } tmp1.push(Result { i_item_id: i.i_item_id, ca_country: ca.ca_country, ca_state: ca.ca_state, ca_county: ca.ca_county, q: cs.cs_quantity, lp: cs.cs_list_price, cp: cs.cs_coupon_amt, sp: cs.cs_sales_price, np: cs.cs_net_profit, by: c.c_birth_year, dep: cd1.cd_dep_count }); } } } } } } } tmp1 };
    let result = { let mut tmp2 = std::collections::HashMap::new();for j in &joined { let key = Key { i_item_id: j.i_item_id, ca_country: j.ca_country, ca_state: j.ca_state, ca_county: j.ca_county }; tmp2.entry(key).or_insert_with(Vec::new).push(j.clone()); } let mut tmp3 = Vec::<Group>::new(); for (k,v) in tmp2 { tmp3.push(Group { key: k, items: v }); } tmp3.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp3 { result.push(Result3 { i_item_id: g.key.i_item_id, ca_country: g.key.ca_country, ca_state: g.key.ca_state, ca_county: g.key.ca_county, agg1: avg(&{ let mut tmp4 = Vec::new();for x in &g.clone().items { tmp4.push(x.q); } tmp4 }), agg2: avg(&{ let mut tmp5 = Vec::new();for x in &g.clone().items { tmp5.push(x.lp); } tmp5 }), agg3: avg(&{ let mut tmp6 = Vec::new();for x in &g.clone().items { tmp6.push(x.cp); } tmp6 }), agg4: avg(&{ let mut tmp7 = Vec::new();for x in &g.clone().items { tmp7.push(x.sp); } tmp7 }), agg5: avg(&{ let mut tmp8 = Vec::new();for x in &g.clone().items { tmp8.push(x.np); } tmp8 }), agg6: avg(&{ let mut tmp9 = Vec::new();for x in &g.clone().items { tmp9.push(x.by); } tmp9 }), agg7: avg(&{ let mut tmp10 = Vec::new();for x in &g.clone().items { tmp10.push(x.dep); } tmp10 }) }); } result };
    _json(&result);
    assert!(result == vec![Result3 { i_item_id: "I1", ca_country: "US", ca_state: "CA", ca_county: "County1", agg1: 1.0, agg2: 10.0, agg3: 1.0, agg4: 9.0, agg5: 2.0, agg6: 1980.0, agg7: 2.0 }]);
}
