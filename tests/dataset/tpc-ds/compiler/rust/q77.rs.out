// Generated by Mochi compiler v0.10.26 on 2025-07-15T06:30:29Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Date_dim {
    d_date_sk: i32,
    d_date: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Store_sale {
    ss_sold_date_sk: i32,
    s_store_sk: i32,
    ss_ext_sales_price: f64,
    ss_net_profit: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Store_return {
    sr_returned_date_sk: i32,
    s_store_sk: i32,
    sr_return_amt: f64,
    sr_net_loss: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Catalog_sale {
    cs_sold_date_sk: i32,
    cs_call_center_sk: i32,
    cs_ext_sales_price: f64,
    cs_net_profit: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Catalog_return {
    cr_returned_date_sk: i32,
    cr_call_center_sk: i32,
    cr_return_amount: f64,
    cr_net_loss: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Web_sale {
    ws_sold_date_sk: i32,
    ws_web_page_sk: i32,
    ws_ext_sales_price: f64,
    ws_net_profit: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Web_return {
    wr_returned_date_sk: i32,
    wr_web_page_sk: i32,
    wr_return_amt: f64,
    wr_net_loss: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item {
    ss: Store_sale,
    d: Date_dim,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group {
    key: i32,
    items: Vec<Item>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result {
    s_store_sk: i32,
    sales: f64,
    profit: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item1 {
    sr: Store_return,
    d: Date_dim,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group2 {
    key: i32,
    items: Vec<Item1>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result3 {
    s_store_sk: i32,
    returns: f64,
    profit_loss: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item4 {
    cs: Catalog_sale,
    d: Date_dim,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group5 {
    key: i32,
    items: Vec<Item4>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result6 {
    cs_call_center_sk: i32,
    sales: f64,
    profit: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item7 {
    cr: Catalog_return,
    d: Date_dim,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group8 {
    key: i32,
    items: Vec<Item7>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result9 {
    cr_call_center_sk: i32,
    returns: f64,
    profit_loss: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item10 {
    ws: Web_sale,
    d: Date_dim,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group11 {
    key: i32,
    items: Vec<Item10>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result12 {
    wp_web_page_sk: i32,
    sales: f64,
    profit: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Item13 {
    wr: Web_return,
    d: Date_dim,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group14 {
    key: i32,
    items: Vec<Item13>,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result15 {
    wp_web_page_sk: i32,
    returns: f64,
    profit_loss: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result16 {
    channel: &'static str,
    id: i32,
    sales: f64,
    returns: i32,
    profit: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result17 {
    channel: &'static str,
    id: i32,
    sales: f64,
    returns: f64,
    profit: f64,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Result18 {
    channel: &'static str,
    id: i32,
    sales: f64,
    returns: i32,
    profit: f64,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Key {
    channel: &'static str,
    id: i32,
}

#[derive(Default, Debug, Clone, PartialEq, PartialOrd)]
struct Group19 {
    key: Key,
    items: Vec<Result18>,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Result20 {
    channel: &'static str,
    id: i32,
    sales: i32,
    returns: i32,
    profit: i32,
}

fn sum<T>(v: &[T]) -> T where T: std::iter::Sum<T> + Copy {
    v.iter().copied().sum()
}

fn _json<T: std::fmt::Debug>(value: &T) {
    println!("{:?}", value);
}

fn main() {
    let date_dim = vec![Date_dim { d_date_sk: 1, d_date: 1 }];
    let store_sales = vec![Store_sale { ss_sold_date_sk: 1, s_store_sk: 1, ss_ext_sales_price: 100.0, ss_net_profit: 10.0 }];
    let store_returns = vec![Store_return { sr_returned_date_sk: 1, s_store_sk: 1, sr_return_amt: 5.0, sr_net_loss: 1.0 }];
    let catalog_sales = vec![Catalog_sale { cs_sold_date_sk: 1, cs_call_center_sk: 1, cs_ext_sales_price: 150.0, cs_net_profit: 15.0 }];
    let catalog_returns = vec![Catalog_return { cr_returned_date_sk: 1, cr_call_center_sk: 1, cr_return_amount: 7.0, cr_net_loss: 3.0 }];
    let web_sales = vec![Web_sale { ws_sold_date_sk: 1, ws_web_page_sk: 1, ws_ext_sales_price: 200.0, ws_net_profit: 20.0 }];
    let web_returns = vec![Web_return { wr_returned_date_sk: 1, wr_web_page_sk: 1, wr_return_amt: 10.0, wr_net_loss: 2.0 }];
    let ss = { let mut tmp1 = std::collections::HashMap::new();for ss in &store_sales { for d in &date_dim { if !(d.d_date_sk == ss.ss_sold_date_sk) { continue; } let key = ss.s_store_sk; tmp1.entry(key).or_insert_with(Vec::new).push(Item {ss: ss.clone(), d: d.clone() }); } } let mut tmp2 = Vec::<Group>::new(); for (k,v) in tmp1 { tmp2.push(Group { key: k, items: v }); } tmp2.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp2 { result.push(Result { s_store_sk: g.key, sales: sum(&{ let mut tmp3 = Vec::new();for x in &g.clone().items { tmp3.push(x.ss.ss_ext_sales_price); } tmp3 }), profit: sum(&{ let mut tmp4 = Vec::new();for x in &g.clone().items { tmp4.push(x.ss.ss_net_profit); } tmp4 }) }); } result };
    let sr = { let mut tmp5 = std::collections::HashMap::new();for sr in &store_returns { for d in &date_dim { if !(d.d_date_sk == sr.sr_returned_date_sk) { continue; } let key = sr.s_store_sk; tmp5.entry(key).or_insert_with(Vec::new).push(Item1 {sr: sr.clone(), d: d.clone() }); } } let mut tmp6 = Vec::<Group2>::new(); for (k,v) in tmp5 { tmp6.push(Group2 { key: k, items: v }); } tmp6.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp6 { result.push(Result3 { s_store_sk: g.key, returns: sum(&{ let mut tmp7 = Vec::new();for x in &g.clone().items { tmp7.push(x.sr.sr_return_amt); } tmp7 }), profit_loss: sum(&{ let mut tmp8 = Vec::new();for x in &g.clone().items { tmp8.push(x.sr.sr_net_loss); } tmp8 }) }); } result };
    let cs = { let mut tmp9 = std::collections::HashMap::new();for cs in &catalog_sales { for d in &date_dim { if !(d.d_date_sk == cs.cs_sold_date_sk) { continue; } let key = cs.cs_call_center_sk; tmp9.entry(key).or_insert_with(Vec::new).push(Item4 {cs: cs.clone(), d: d.clone() }); } } let mut tmp10 = Vec::<Group5>::new(); for (k,v) in tmp9 { tmp10.push(Group5 { key: k, items: v }); } tmp10.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp10 { result.push(Result6 { cs_call_center_sk: g.key, sales: sum(&{ let mut tmp11 = Vec::new();for x in &g.clone().items { tmp11.push(x.cs.cs_ext_sales_price); } tmp11 }), profit: sum(&{ let mut tmp12 = Vec::new();for x in &g.clone().items { tmp12.push(x.cs.cs_net_profit); } tmp12 }) }); } result };
    let cr = { let mut tmp13 = std::collections::HashMap::new();for cr in &catalog_returns { for d in &date_dim { if !(d.d_date_sk == cr.cr_returned_date_sk) { continue; } let key = cr.cr_call_center_sk; tmp13.entry(key).or_insert_with(Vec::new).push(Item7 {cr: cr.clone(), d: d.clone() }); } } let mut tmp14 = Vec::<Group8>::new(); for (k,v) in tmp13 { tmp14.push(Group8 { key: k, items: v }); } tmp14.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp14 { result.push(Result9 { cr_call_center_sk: g.key, returns: sum(&{ let mut tmp15 = Vec::new();for x in &g.clone().items { tmp15.push(x.cr.cr_return_amount); } tmp15 }), profit_loss: sum(&{ let mut tmp16 = Vec::new();for x in &g.clone().items { tmp16.push(x.cr.cr_net_loss); } tmp16 }) }); } result };
    let ws = { let mut tmp17 = std::collections::HashMap::new();for ws in &web_sales { for d in &date_dim { if !(d.d_date_sk == ws.ws_sold_date_sk) { continue; } let key = ws.ws_web_page_sk; tmp17.entry(key).or_insert_with(Vec::new).push(Item10 {ws: ws.clone(), d: d.clone() }); } } let mut tmp18 = Vec::<Group11>::new(); for (k,v) in tmp17 { tmp18.push(Group11 { key: k, items: v }); } tmp18.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp18 { result.push(Result12 { wp_web_page_sk: g.key, sales: sum(&{ let mut tmp19 = Vec::new();for x in &g.clone().items { tmp19.push(x.ws.ws_ext_sales_price); } tmp19 }), profit: sum(&{ let mut tmp20 = Vec::new();for x in &g.clone().items { tmp20.push(x.ws.ws_net_profit); } tmp20 }) }); } result };
    let wr = { let mut tmp21 = std::collections::HashMap::new();for wr in &web_returns { for d in &date_dim { if !(d.d_date_sk == wr.wr_returned_date_sk) { continue; } let key = wr.wr_web_page_sk; tmp21.entry(key).or_insert_with(Vec::new).push(Item13 {wr: wr.clone(), d: d.clone() }); } } let mut tmp22 = Vec::<Group14>::new(); for (k,v) in tmp21 { tmp22.push(Group14 { key: k, items: v }); } tmp22.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); let mut result = Vec::new(); for g in tmp22 { result.push(Result15 { wp_web_page_sk: g.key, returns: sum(&{ let mut tmp23 = Vec::new();for x in &g.clone().items { tmp23.push(x.wr.wr_return_amt); } tmp23 }), profit_loss: sum(&{ let mut tmp24 = Vec::new();for x in &g.clone().items { tmp24.push(x.wr.wr_net_loss); } tmp24 }) }); } result };
    let per_channel = concat({ let mut tmp25 = Vec::new();for s in &ss { let mut _matched = false; for r in &sr { if !(s.s_store_sk == r.s_store_sk) { continue; } _matched = true; tmp25.push(Result16 { channel: "store channel", id: s.s_store_sk, sales: s.sales, returns: if r.clone() == () { 0.0 } else { r.returns }, profit: s.profit - (if r.clone() == () { 0.0 } else { r.profit_loss }) }); } if !_matched { let r: Result3 = Default::default(); tmp25.push(Result16 { channel: "store channel", id: s.s_store_sk, sales: s.sales, returns: if r.clone() == () { 0.0 } else { r.returns }, profit: s.profit - (if r.clone() == () { 0.0 } else { r.profit_loss }) }); } } tmp25 }, { let mut tmp26 = Vec::new();for c in &cs { for r in &cr { if !(c.cs_call_center_sk == r.cr_call_center_sk) { continue; } tmp26.push(Result17 { channel: "catalog channel", id: c.cs_call_center_sk, sales: c.sales, returns: r.returns, profit: c.profit - r.profit_loss }); } } tmp26 }, { let mut tmp27 = Vec::new();for w in &ws { let mut _matched = false; for r in &wr { if !(w.wp_web_page_sk == r.wp_web_page_sk) { continue; } _matched = true; tmp27.push(Result18 { channel: "web channel", id: w.wp_web_page_sk, sales: w.sales, returns: if r.clone() == () { 0.0 } else { r.returns }, profit: w.profit - (if r.clone() == () { 0.0 } else { r.profit_loss }) }); } if !_matched { let r: Result15 = Default::default(); tmp27.push(Result18 { channel: "web channel", id: w.wp_web_page_sk, sales: w.sales, returns: if r.clone() == () { 0.0 } else { r.returns }, profit: w.profit - (if r.clone() == () { 0.0 } else { r.profit_loss }) }); } } tmp27 });
    let result = { let mut tmp28 = std::collections::HashMap::new();for p in &per_channel { let key = Key { channel: p.channel, id: p.id }; tmp28.entry(key).or_insert_with(Vec::new).push(p.clone()); } let mut tmp29 = Vec::<Group19>::new(); for (k,v) in tmp28 { tmp29.push(Group19 { key: k, items: v }); } tmp29.sort_by(|a,b| a.key.partial_cmp(&b.key).unwrap()); tmp29.sort_by(|a,b| (a.key.channel).partial_cmp(&(b.key.channel)).unwrap()); let mut result = Vec::new(); for g in tmp29 { result.push(Result20 { channel: g.key.channel, id: g.key.id, sales: sum(&{ let mut tmp30 = Vec::new();for x in &g.clone().items { tmp30.push(x.p.sales); } tmp30 }), returns: sum(&{ let mut tmp31 = Vec::new();for x in &g.clone().items { tmp31.push(x.p.returns); } tmp31 }), profit: sum(&{ let mut tmp32 = Vec::new();for x in &g.clone().items { tmp32.push(x.p.profit); } tmp32 }) }); } result };
    _json(&result);
    assert!(result == vec![Result20 { channel: "catalog channel", id: 1, sales: 150.0, returns: 7.0, profit: 12.0 }, Result18 { channel: "store channel", id: 1, sales: 100.0, returns: 5.0, profit: 9.0 }, Result16 { channel: "web channel", id: 1, sales: 200.0, returns: 10.0, profit: 18.0 }]);
}
