-- Generated by Mochi compiler v0.10.26 on 2025-07-15T07:18:52Z
-- Code generated by Mochi compiler; DO NOT EDIT.
{-# LANGUAGE DeriveGeneric #-}

module Main where

import qualified Data.Aeson as Aeson
import qualified Data.ByteString.Lazy.Char8 as BSL
import Data.List (intercalate, isInfixOf, isPrefixOf)
import qualified Data.List as List
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
import GHC.Generics (Generic)

forLoop :: Int -> Int -> (Int -> Maybe a) -> Maybe a
forLoop start end f = go start
  where
    go i
      | i < end =
          case f i of
            Just v -> Just v
            Nothing -> go (i + 1)
      | otherwise = Nothing

whileLoop :: (() -> Bool) -> (() -> Maybe a) -> Maybe a
whileLoop cond body = go ()
  where
    go _
      | cond () =
          case body () of
            Just v -> Just v
            Nothing -> go ()
      | otherwise = Nothing

avg :: (Integral a) => [a] -> a
avg xs
  | null xs = 0
  | otherwise = div (sum xs) (fromIntegral (length xs))

data MGroup k a = MGroup {key :: k, items :: [a]} deriving (Show)

_group_by :: (Ord k) => [a] -> (a -> k) -> [MGroup k a]
_group_by src keyfn =
  let go [] m order = (m, order)
      go (x : xs) m order =
        let k = keyfn x
         in case Map.lookup k m of
              Just is -> go xs (Map.insert k (is ++ [x]) m) order
              Nothing -> go xs (Map.insert k [x] m) (order ++ [k])
      (m, order) = go src Map.empty []
   in [MGroup k (fromMaybe [] (Map.lookup k m)) | k <- order]

_indexString :: String -> Int -> String
_indexString s i =
  let idx = if i < 0 then i + length s else i
   in if idx < 0 || idx >= length s
        then error "index out of range"
        else [s !! idx]

_append :: [a] -> a -> [a]
_append xs x = xs ++ [x]

_input :: IO String
_input = getLine

_readInput :: Maybe String -> IO String
_readInput Nothing = getContents
_readInput (Just p)
  | null p || p == "-" = getContents
  | otherwise = readFile p

_writeOutput :: Maybe String -> String -> IO ()
_writeOutput mp text = case mp of
  Nothing -> putStr text
  Just p
    | null p || p == "-" -> putStr text
    | otherwise -> writeFile p text

_split :: Char -> String -> [String]
_split _ "" = [""]
_split d s =
  let (h, t) = break (== d) s
   in h : case t of
        [] -> []
        (_ : rest) -> _split d rest

_parseCSV :: String -> Bool -> Char -> [Map.Map String String]
_parseCSV text header delim =
  let ls = filter (not . null) (lines text)
   in if null ls
        then []
        else
          let heads =
                if header
                  then _split delim (head ls)
                  else ["c" ++ show i | i <- [0 .. length (_split delim (head ls)) - 1]]
              start = if header then 1 else 0
              row line =
                let parts = _split delim line
                 in Map.fromList
                      [ (heads !! j, if j < length parts then parts !! j else "")
                        | j <- [0 .. length heads - 1]
                      ]
           in map row (drop start ls)

_json :: (Aeson.ToJSON a) => a -> IO ()
_json v = BSL.putStrLn (Aeson.encode v)

data AnyValue = VInt Int | VDouble Double | VString String | VBool Bool deriving (Show)

_asInt :: AnyValue -> Int
_asInt (VInt n) = n
_asInt v = error ("expected int, got " ++ show v)

_asDouble :: AnyValue -> Double
_asDouble (VDouble d) = d
_asDouble v = error ("expected double, got " ++ show v)

_asString :: AnyValue -> String
_asString (VString s) = s
_asString v = error ("expected string, got " ++ show v)

_asBool :: AnyValue -> Bool
_asBool (VBool b) = b
_asBool v = error ("expected bool, got " ++ show v)

_showAny :: AnyValue -> String
_showAny (VInt n) = show n
_showAny (VDouble d) = show d
_showAny (VString s) = s
_showAny (VBool b) = if b then "true" else "false"

expect :: Bool -> IO ()
expect True = pure ()
expect False = error "expect failed"

data StoreSale = StoreSale
  { ss_ticket_number :: Int,
    ss_item_sk :: Int,
    ss_customer_sk :: Int,
    ss_store_sk :: Int,
    ss_net_paid :: Double
  }
  deriving (Eq, Show, Generic)

data StoreReturn = StoreReturn
  { sr_ticket_number :: Int,
    sr_item_sk :: Int
  }
  deriving (Eq, Show, Generic)

data Store = Store
  { s_store_sk :: Int,
    s_store_name :: String,
    s_market_id :: Int,
    s_state :: String,
    s_zip :: String
  }
  deriving (Eq, Show, Generic)

data Item = Item
  { i_item_sk :: Int,
    i_color :: String,
    i_current_price :: Double,
    i_manager_id :: Int,
    i_units :: String,
    i_size :: String
  }
  deriving (Eq, Show, Generic)

data Customer = Customer
  { c_customer_sk :: Int,
    c_first_name :: String,
    c_last_name :: String,
    c_current_addr_sk :: Int,
    c_birth_country :: String
  }
  deriving (Eq, Show, Generic)

data CustomerAddress = CustomerAddress
  { ca_address_sk :: Int,
    ca_state :: String,
    ca_country :: String,
    ca_zip :: String
  }
  deriving (Eq, Show, Generic)

store_sales = [Map.fromList [("ss_ticket_number", VInt (1)), ("ss_item_sk", VInt (1)), ("ss_customer_sk", VInt (1)), ("ss_store_sk", VInt (1)), ("ss_net_paid", VDouble (100.0))], Map.fromList [("ss_ticket_number", VInt (2)), ("ss_item_sk", VInt (2)), ("ss_customer_sk", VInt (2)), ("ss_store_sk", VInt (1)), ("ss_net_paid", VDouble (50.0))]]

store_returns = [Map.fromList [("sr_ticket_number", (1 :: Int)), ("sr_item_sk", (1 :: Int))], Map.fromList [("sr_ticket_number", (2 :: Int)), ("sr_item_sk", (2 :: Int))]]

store = [Map.fromList [("s_store_sk", VInt (1)), ("s_store_name", VString ("Store1")), ("s_market_id", VInt (5)), ("s_state", VString ("CA")), ("s_zip", VString ("12345"))]]

item = [Map.fromList [("i_item_sk", VInt (1)), ("i_color", VString ("RED")), ("i_current_price", VDouble (10.0)), ("i_manager_id", VInt (1)), ("i_units", VString ("EA")), ("i_size", VString ("M"))], Map.fromList [("i_item_sk", VInt (2)), ("i_color", VString ("BLUE")), ("i_current_price", VDouble (20.0)), ("i_manager_id", VInt (2)), ("i_units", VString ("EA")), ("i_size", VString ("L"))]]

customer = [Map.fromList [("c_customer_sk", VInt (1)), ("c_first_name", VString ("Ann")), ("c_last_name", VString ("Smith")), ("c_current_addr_sk", VInt (1)), ("c_birth_country", VString ("Canada"))], Map.fromList [("c_customer_sk", VInt (2)), ("c_first_name", VString ("Bob")), ("c_last_name", VString ("Jones")), ("c_current_addr_sk", VInt (2)), ("c_birth_country", VString ("USA"))]]

customer_address = [Map.fromList [("ca_address_sk", VInt (1)), ("ca_state", VString ("CA")), ("ca_country", VString ("USA")), ("ca_zip", VString ("12345"))], Map.fromList [("ca_address_sk", VInt (2)), ("ca_state", VString ("CA")), ("ca_country", VString ("USA")), ("ca_zip", VString ("54321"))]]

ssales = [Map.fromList [("c_last_name", fromMaybe (error "missing") (Map.lookup "last" (key (g)))), ("c_first_name", fromMaybe (error "missing") (Map.lookup "first" (key (g)))), ("s_store_name", fromMaybe (error "missing") (Map.lookup "store_name" (key (g)))), ("color", fromMaybe (error "missing") (Map.lookup "color" (key (g)))), ("netpaid", VDouble (sum [fromMaybe (error "missing") (Map.lookup "ss_net_paid" (x)) | x <- g]))] | g <- _group_by [(ss, sr, s, i, c, ca) | ss <- store_sales, sr <- store_returns, s <- store, i <- item, c <- customer, ca <- customer_address, (((fromMaybe (error "missing") (Map.lookup "ss_ticket_number" (ss)) == fromMaybe (error "missing") (Map.lookup "sr_ticket_number" (sr))) && fromMaybe (error "missing") (Map.lookup "ss_item_sk" (ss))) == fromMaybe (error "missing") (Map.lookup "sr_item_sk" (sr))), (fromMaybe (error "missing") (Map.lookup "ss_store_sk" (ss)) == fromMaybe (error "missing") (Map.lookup "s_store_sk" (s))), (fromMaybe (error "missing") (Map.lookup "ss_item_sk" (ss)) == fromMaybe (error "missing") (Map.lookup "i_item_sk" (i))), (fromMaybe (error "missing") (Map.lookup "ss_customer_sk" (ss)) == fromMaybe (error "missing") (Map.lookup "c_customer_sk" (c))), (fromMaybe (error "missing") (Map.lookup "c_current_addr_sk" (c)) == fromMaybe (error "missing") (Map.lookup "ca_address_sk" (ca))), (((((fromMaybe (error "missing") (Map.lookup "c_birth_country" c) /= fromMaybe (error "missing") (Map.lookup "ToUpper" (strings)) fromMaybe (error "missing") (Map.lookup "ca_country" ca)) && fromMaybe (error "missing") (Map.lookup "s_zip" s)) == fromMaybe (error "missing") (Map.lookup "ca_zip" ca)) && fromMaybe (error "missing") (Map.lookup "s_market_id" s)) == 5)] (\(ss, sr, s, i, c, ca) -> Map.fromList [("last", fromMaybe (error "missing") (Map.lookup "c_last_name" c)), ("first", fromMaybe (error "missing") (Map.lookup "c_first_name" c)), ("store_name", fromMaybe (error "missing") (Map.lookup "s_store_name" s)), ("color", fromMaybe (error "missing") (Map.lookup "i_color" i))]), let g = g]

avg_paid = (sum [fromMaybe (error "missing") (Map.lookup "netpaid" x) | x <- ssales] `div` length [fromMaybe (error "missing") (Map.lookup "netpaid" x) | x <- ssales])

result = map snd (List.sortOn fst [([fromMaybe (error "missing") (Map.lookup "c_last_name" (x)), fromMaybe (error "missing") (Map.lookup "c_first_name" (x)), fromMaybe (error "missing") (Map.lookup "s_store_name" (x))], Map.fromList [("c_last_name", fromMaybe (error "missing") (Map.lookup "c_last_name" x)), ("c_first_name", fromMaybe (error "missing") (Map.lookup "c_first_name" x)), ("s_store_name", fromMaybe (error "missing") (Map.lookup "s_store_name" x)), ("paid", fromMaybe (error "missing") (Map.lookup "netpaid" x))]) | x <- ssales, ((((fromMaybe (error "missing") (Map.lookup "color" x) == "RED") && fromMaybe (error "missing") (Map.lookup "netpaid" x)) > 0.05) * avg_paid)])

test_TPCDS_Q24_customer_net_paid :: IO ()
test_TPCDS_Q24_customer_net_paid = do
  expect ((result == [Map.fromList [("c_last_name", VString ("Smith")), ("c_first_name", VString ("Ann")), ("s_store_name", VString ("Store1")), ("paid", VDouble (100.0))]]))

main :: IO ()
main = do
  _json result
  test_TPCDS_Q24_customer_net_paid
