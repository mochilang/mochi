open System

let rec _to_json (v: obj) : string =
    match v with
    | null -> "null"
    | :? string as s -> "\"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\""
    | :? bool
    | :? int
    | :? int64
    | :? double -> string v
    | :? System.Collections.Generic.IDictionary<string, obj> as m ->
        m
        |> Seq.map (fun (KeyValue(k, v)) -> "\"" + k.Replace("\"", "\\\"") + "\":" + _to_json v)
        |> String.concat ","
        |> fun s -> "{" + s + "}"
    | :? System.Collections.IEnumerable as e ->
        e
        |> Seq.cast<obj>
        |> Seq.map _to_json
        |> String.concat ","
        |> fun s -> "[" + s + "]"
    | _ -> "\"" + v.ToString().Replace("\\", "\\\\").Replace("\"", "\\\"") + "\""

let _json (v: obj) : unit = printfn "%s" (_to_json v)

let _reverse_string (s: string) : string =
    s.ToCharArray() |> Array.rev |> System.String

let _run_test (name: string) (f: unit -> unit) : bool =
    printf "%s ... " name

    try
        f ()
        printfn "PASS"
        true
    with e ->
        printfn "FAIL (%s)" e.Message
        false

let _slice_string (s: string) (i: int) (j: int) : string =
    let mutable start = i
    let mutable stop = j
    let n = s.Length

    if start < 0 then
        start <- start + n

    if stop < 0 then
        stop <- stop + n

    if start < 0 then
        start <- 0

    if stop > n then
        stop <- n

    if stop < start then
        stop <- start

    s.Substring(start, stop - start)

let store_sales = [||]
let date_dim = [||]
let store = [||]
let customer_address = [||]
let customer = [||]
ignore (_reverse_string _slice_string "zip" 0 2)
let result = [||]
ignore (_json result)

let test_TPCDS_Q8_empty () =
    if not ((result.Length = 0)) then
        failwith "expect failed"

let mutable failures = 0

if not (_run_test "TPCDS Q8 empty" test_TPCDS_Q8_empty) then
    failures <- failures + 1

if failures > 0 then
    printfn "\n[FAIL] %d test(s) failed." failures
