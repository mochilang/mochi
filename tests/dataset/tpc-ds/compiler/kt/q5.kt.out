fun test_TPCDS_Q5_empty() {
    check((result.size == 0))
}

fun main() {
    val store_sales = listOf<Any?>()
    val store_returns = listOf<Any?>()
    val store = listOf<Any?>()
    val catalog_sales = listOf<Any?>()
    val catalog_returns = listOf<Any?>()
    val catalog_page = listOf<Any?>()
    val web_sales = listOf<Any?>()
    val web_returns = listOf<Any?>()
    val web_site = listOf<Any?>()
    val date_dim = listOf<Any?>()
    val ss = run {
        val _src = store_sales
        val _rows = _query(_src, listOf(
        _JoinSpec(items = date_dim, on = { args ->
        val ss = args[0]
        val d = args[1]
        (ss["ss_sold_date_sk"] == d["d_date_sk"])
    })),
    _JoinSpec(items = store, on = { args ->
    val ss = args[0]
    val d = args[1]
    val s = args[2]
    (ss["ss_store_sk"] == s["s_store_sk"])
}))
), _QueryOpts(selectFn = { args ->
val ss = args[0]
val d = args[1]
val s = args[2]
mutableMapOf("channel" to "store channel", "id" to ("store" + g.key.toString()), "sales" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["ss"].ss_ext_sales_price }
    res
}), "returns" to 0, "profit" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["ss"].ss_net_profit }
    res
}), "profit_loss" to 0)
}, where = { args ->
val ss = args[0]
val d = args[1]
val s = args[2]
((d["d_date"] >= "1998-12-01") && (d["d_date"] <= "1998-12-15"))
}) )
val _groups = _group_by(_rows) { args ->
val ss = args[0]
val d = args[1]
val s = args[2]
s["s_store_id"]
}
val _res = mutableListOf<Any?>()
for (g in _groups) {
    _res.add(mutableMapOf("channel" to "store channel", "id" to ("store" + g.key.toString()), "sales" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["ss"].ss_ext_sales_price }
        res
    }), "returns" to 0, "profit" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["ss"].ss_net_profit }
        res
    }), "profit_loss" to 0))
}
_res
}
val sr = run {
    val _src = store_returns
    val _rows = _query(_src, listOf(
    _JoinSpec(items = date_dim, on = { args ->
    val sr = args[0]
    val d = args[1]
    (sr["sr_returned_date_sk"] == d["d_date_sk"])
})),
_JoinSpec(items = store, on = { args ->
val sr = args[0]
val d = args[1]
val s = args[2]
(sr["sr_store_sk"] == s["s_store_sk"])
}))
), _QueryOpts(selectFn = { args ->
val sr = args[0]
val d = args[1]
val s = args[2]
mutableMapOf("channel" to "store channel", "id" to ("store" + g.key.toString()), "sales" to 0, "returns" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["sr"].sr_return_amt }
    res
}), "profit" to 0, "profit_loss" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["sr"].sr_net_loss }
    res
}))
}, where = { args ->
val sr = args[0]
val d = args[1]
val s = args[2]
((d["d_date"] >= "1998-12-01") && (d["d_date"] <= "1998-12-15"))
}) )
val _groups = _group_by(_rows) { args ->
val sr = args[0]
val d = args[1]
val s = args[2]
s["s_store_id"]
}
val _res = mutableListOf<Any?>()
for (g in _groups) {
    _res.add(mutableMapOf("channel" to "store channel", "id" to ("store" + g.key.toString()), "sales" to 0, "returns" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["sr"].sr_return_amt }
        res
    }), "profit" to 0, "profit_loss" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["sr"].sr_net_loss }
        res
    })))
}
_res
}
val cs = run {
    val _src = catalog_sales
    val _rows = _query(_src, listOf(
    _JoinSpec(items = date_dim, on = { args ->
    val cs = args[0]
    val d = args[1]
    (cs["cs_sold_date_sk"] == d["d_date_sk"])
})),
_JoinSpec(items = catalog_page, on = { args ->
val cs = args[0]
val d = args[1]
val cp = args[2]
(cs["cs_catalog_page_sk"] == cp["cp_catalog_page_sk"])
}))
), _QueryOpts(selectFn = { args ->
val cs = args[0]
val d = args[1]
val cp = args[2]
mutableMapOf("channel" to "catalog channel", "id" to ("catalog_page" + g.key.toString()), "sales" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["cs"].cs_ext_sales_price }
    res
}), "returns" to 0, "profit" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["cs"].cs_net_profit }
    res
}), "profit_loss" to 0)
}, where = { args ->
val cs = args[0]
val d = args[1]
val cp = args[2]
((d["d_date"] >= "1998-12-01") && (d["d_date"] <= "1998-12-15"))
}) )
val _groups = _group_by(_rows) { args ->
val cs = args[0]
val d = args[1]
val cp = args[2]
cp["cp_catalog_page_id"]
}
val _res = mutableListOf<Any?>()
for (g in _groups) {
    _res.add(mutableMapOf("channel" to "catalog channel", "id" to ("catalog_page" + g.key.toString()), "sales" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["cs"].cs_ext_sales_price }
        res
    }), "returns" to 0, "profit" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["cs"].cs_net_profit }
        res
    }), "profit_loss" to 0))
}
_res
}
val cr = run {
    val _src = catalog_returns
    val _rows = _query(_src, listOf(
    _JoinSpec(items = date_dim, on = { args ->
    val cr = args[0]
    val d = args[1]
    (cr["cr_returned_date_sk"] == d["d_date_sk"])
})),
_JoinSpec(items = catalog_page, on = { args ->
val cr = args[0]
val d = args[1]
val cp = args[2]
(cr["cr_catalog_page_sk"] == cp["cp_catalog_page_sk"])
}))
), _QueryOpts(selectFn = { args ->
val cr = args[0]
val d = args[1]
val cp = args[2]
mutableMapOf("channel" to "catalog channel", "id" to ("catalog_page" + g.key.toString()), "sales" to 0, "returns" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["cr"].cr_return_amount }
    res
}), "profit" to 0, "profit_loss" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["cr"].cr_net_loss }
    res
}))
}, where = { args ->
val cr = args[0]
val d = args[1]
val cp = args[2]
((d["d_date"] >= "1998-12-01") && (d["d_date"] <= "1998-12-15"))
}) )
val _groups = _group_by(_rows) { args ->
val cr = args[0]
val d = args[1]
val cp = args[2]
cp["cp_catalog_page_id"]
}
val _res = mutableListOf<Any?>()
for (g in _groups) {
    _res.add(mutableMapOf("channel" to "catalog channel", "id" to ("catalog_page" + g.key.toString()), "sales" to 0, "returns" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["cr"].cr_return_amount }
        res
    }), "profit" to 0, "profit_loss" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["cr"].cr_net_loss }
        res
    })))
}
_res
}
val ws = run {
    val _src = web_sales
    val _rows = _query(_src, listOf(
    _JoinSpec(items = date_dim, on = { args ->
    val ws = args[0]
    val d = args[1]
    (ws["ws_sold_date_sk"] == d["d_date_sk"])
})),
_JoinSpec(items = web_site, on = { args ->
val ws = args[0]
val d = args[1]
val w = args[2]
(ws["ws_web_site_sk"] == w["web_site_sk"])
}))
), _QueryOpts(selectFn = { args ->
val ws = args[0]
val d = args[1]
val w = args[2]
mutableMapOf("channel" to "web channel", "id" to ("web_site" + g.key.toString()), "sales" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["ws"].ws_ext_sales_price }
    res
}), "returns" to 0, "profit" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["ws"].ws_net_profit }
    res
}), "profit_loss" to 0)
}, where = { args ->
val ws = args[0]
val d = args[1]
val w = args[2]
((d["d_date"] >= "1998-12-01") && (d["d_date"] <= "1998-12-15"))
}) )
val _groups = _group_by(_rows) { args ->
val ws = args[0]
val d = args[1]
val w = args[2]
w["web_site_id"]
}
val _res = mutableListOf<Any?>()
for (g in _groups) {
    _res.add(mutableMapOf("channel" to "web channel", "id" to ("web_site" + g.key.toString()), "sales" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["ws"].ws_ext_sales_price }
        res
    }), "returns" to 0, "profit" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["ws"].ws_net_profit }
        res
    }), "profit_loss" to 0))
}
_res
}
val wr = run {
    val _src = web_returns
    val _rows = _query(_src, listOf(
    _JoinSpec(items = web_sales, on = { args ->
    val wr = args[0]
    val ws = args[1]
    ((wr["wr_item_sk"] == ws["ws_item_sk"]) && (wr["wr_order_number"] == ws["ws_order_number"]))
})),
_JoinSpec(items = date_dim, on = { args ->
val wr = args[0]
val ws = args[1]
val d = args[2]
(wr["wr_returned_date_sk"] == d["d_date_sk"])
})),
_JoinSpec(items = web_site, on = { args ->
val wr = args[0]
val ws = args[1]
val d = args[2]
val w = args[3]
(ws["ws_web_site_sk"] == w["web_site_sk"])
}))
), _QueryOpts(selectFn = { args ->
val wr = args[0]
val ws = args[1]
val d = args[2]
val w = args[3]
mutableMapOf("channel" to "web channel", "id" to ("web_site" + g.key.toString()), "sales" to 0, "returns" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["wr"].wr_return_amt }
    res
}), "profit" to 0, "profit_loss" to _sum(run {
    var res = g.Items as List<Any?>
    res = res.map { x -> x["wr"].wr_net_loss }
    res
}))
}, where = { args ->
val wr = args[0]
val ws = args[1]
val d = args[2]
val w = args[3]
((d["d_date"] >= "1998-12-01") && (d["d_date"] <= "1998-12-15"))
}) )
val _groups = _group_by(_rows) { args ->
val wr = args[0]
val ws = args[1]
val d = args[2]
val w = args[3]
w["web_site_id"]
}
val _res = mutableListOf<Any?>()
for (g in _groups) {
    _res.add(mutableMapOf("channel" to "web channel", "id" to ("web_site" + g.key.toString()), "sales" to 0, "returns" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["wr"].wr_return_amt }
        res
    }), "profit" to 0, "profit_loss" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["wr"].wr_net_loss }
        res
    })))
}
_res
}
val per_channel = concat(_unionAll(ss, sr), _unionAll(cs, cr), _unionAll(ws, wr))
val result = run {
    val _src = per_channel
    val _rows = _query(_src, listOf(
    ), _QueryOpts(selectFn = { args ->
    val p = args[0]
    mutableMapOf("channel" to g.key.channel, "id" to g.key.id, "sales" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["p"].sales }
        res
    }), "returns" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["p"].returns }
        res
    }), "profit" to (_sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["p"].profit }
        res
    }) - _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["p"].profit_loss }
        res
    })))
}, sortKey = { args ->
val p = args[0]
g["key"].channel
}) )
val _groups = _group_by(_rows) { args ->
val p = args[0]
mutableMapOf("channel" to p["channel"], "id" to p["id"])
}
val _res = mutableListOf<Any?>()
for (g in _groups) {
    _res.add(mutableMapOf("channel" to g.key.channel, "id" to g.key.id, "sales" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["p"].sales }
        res
    }), "returns" to _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["p"].returns }
        res
    }), "profit" to (_sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["p"].profit }
        res
    }) - _sum(run {
        var res = g.Items as List<Any?>
        res = res.map { x -> x["p"].profit_loss }
        res
    }))))
}
_res
}
_json(result)
test_TPCDS_Q5_empty()
}

class _Group(var key: Any?) {
    val Items = mutableListOf<Any?>()
    val size: Int
    get() = Items.size
}
fun _arrConcat(a: Array<Any?>, b: Array<Any?>): Array<Any?> {
    return a + b
}
fun _group_by(src: List<Any?>, keyfn: (Any?) -> Any?): List<_Group> {
    val groups = mutableMapOf<String, _Group>()
    val order = mutableListOf<String>()
    for (it in src) {
        val key = keyfn(it)
        val ks = key.toString()
        var g = groups[ks]
        if (g == null) {
            g = _Group(key)
            groups[ks] = g
            order.add(ks)
        }
        if (it is Array<*> && it.size == 1) {
            g.Items.add(it[0])
        } else {
            g.Items.add(it)
        }
    }
    return order.map { groups[it]!! }
}
fun _json(v: Any?) {
    fun encode(x: Any?): String = when (x) {
        null -> "null"
        is String -> \"""${x.replace("\"", "\\\"")}\"""
        is Int, is Double, is Boolean -> x.toString()
        is List<*> -> x.joinToString(prefix = "[", postfix = "]") { encode(it) }
        is Map<*, *> -> x.entries.joinToString(prefix = "{", postfix = "}") { e ->
        "\"" + e.key.toString().replace("\"", "\\\"") + "\":" + encode(e.value)
    }
    else -> \"""${x.toString().replace("\"", "\\\"")}\"""
}
println(encode(v))
}
data class _JoinSpec(
val items: List<Any?>,
val on: ((Array<Any?>) -> Boolean)? = null,
val left: Boolean = false,
val right: Boolean = false,
)

data class _QueryOpts(
val selectFn: (Array<Any?>) -> Any?,
val where: ((Array<Any?>) -> Boolean)? = null,
val sortKey: ((Array<Any?>) -> Any?)? = null,
val skip: Int = -1,
val take: Int = -1,
)

fun _query(src: List<Any?>, joins: List<_JoinSpec>, opts: _QueryOpts): List<Any?> {
    var items = src.map { arrayOf(it) }.toMutableList()
    if (opts.where != null) {
        items = items.filter { opts.where.invoke(it) }.toMutableList()
    }
    for (j in joins) {
        val joined = mutableListOf<Array<Any?>>()
        if (j.right && j.left) {
            val matched = BooleanArray(j.items.size)
            for (left in items) {
                var m = false
                for ((ri, right) in j.items.withIndex()) {
                    var keep = true
                    if (j.on != null) {
                        keep = j.on.invoke(_arrConcat(left, arrayOf(right)))
                    }
                    if (!keep) continue
                    m = true
                    matched[ri] = true
                    joined.add(_arrConcat(left, arrayOf(right)))
                }
                if (!m) joined.add(_arrConcat(left, arrayOf<Any?>(null)))
            }
            for ((ri, right) in j.items.withIndex()) {
                if (!matched[ri]) {
                    val undef = Array<Any?>(items.firstOrNull()?.size ?: 0) { null }
                    joined.add(_arrConcat(undef, arrayOf(right)))
                }
            }
        } else if (j.right) {
            for (right in j.items) {
                var m = false
                for (left in items) {
                    var keep = true
                    if (j.on != null) {
                        keep = j.on.invoke(_arrConcat(left, arrayOf(right)))
                    }
                    if (!keep) continue
                    m = true
                    joined.add(_arrConcat(left, arrayOf(right)))
                }
                if (!m) {
                    val undef = Array<Any?>(items.firstOrNull()?.size ?: 0) { null }
                    joined.add(_arrConcat(undef, arrayOf(right)))
                }
            }
        } else {
            for (left in items) {
                var m = false
                for (right in j.items) {
                    var keep = true
                    if (j.on != null) {
                        keep = j.on.invoke(_arrConcat(left, arrayOf(right)))
                    }
                    if (!keep) continue
                    m = true
                    joined.add(_arrConcat(left, arrayOf(right)))
                }
                if (j.left && !m) joined.add(_arrConcat(left, arrayOf<Any?>(null)))
            }
        }
        items = joined
        if (opts.where != null) {
            items = items.filter { opts.where.invoke(it) }.toMutableList()
        }
    }
    if (opts.where != null) {
        items = items.filter { opts.where.invoke(it) }.toMutableList()
    }
    if (opts.sortKey != null) {
        val pairs = items.map { it to opts.sortKey.invoke(it) }.toMutableList()
        pairs.sortWith(java.util.Comparator { a, b ->
        val av = a.second
        val bv = b.second
        when (av) {
            is Int -> when (bv) {
                is Int -> av.compareTo(bv)
                is Double -> av.toDouble().compareTo(bv)
                else -> av.toString().compareTo(bv.toString())
            }
            is Double -> when (bv) {
                is Int -> av.compareTo(bv.toDouble())
                is Double -> av.compareTo(bv)
                else -> av.toString().compareTo(bv.toString())
            }
            is String -> av.compareTo(bv.toString())
            else -> av.toString().compareTo(bv.toString())
        }
    })
    items = pairs.map { it.first }.toMutableList()
}
if (opts.skip >= 0) {
    items = if (opts.skip < items.size) items.drop(opts.skip).toMutableList() else mutableListOf()
}
if (opts.take >= 0) {
    if (opts.take < items.size) items = items.take(opts.take).toMutableList()
}
val res = mutableListOf<Any?>()
for (r in items) {
    res.add(opts.selectFn.invoke(r))
}
return res
}
fun _sum(v: Any?): Double {
    var list: List<Any?>? = null
    when (v) {
        is List<*> -> list = v as List<Any?>
        is Map<*, *> -> {
            val items = when {
                v["items"] is List<*> -> v["items"] as List<*>
                v["Items"] is List<*> -> v["Items"] as List<*>
                else -> null
            }
            if (items != null) list = items as List<Any?>
        }
        is _Group -> list = v.Items
    }
    if (list == null || list.isEmpty()) return 0.0
    var sum = 0.0
    for (n in list!!) {
        sum += (n as Number).toDouble()
    }
    return sum
}
fun <T> _unionAll(a: List<T>, b: List<T>): List<T> = a + b


