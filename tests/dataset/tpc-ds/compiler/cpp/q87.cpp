// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
#include <iostream>
#include <map>
#include <numeric>
#include <string>
#include <unordered_map>
#include <vector>

template <typename T> void __json(const T &);
inline void __json(int v) { std::cout << v; }
inline void __json(double v) { std::cout << v; }
inline void __json(bool v) { std::cout << (v ? "true" : "false"); }
inline void __json(const std::string &v) { std::cout << "\"" << v << "\""; }
inline void __json(const char *v) { std::cout << "\"" << v << "\""; }
template <typename T> void __json(const std::vector<T> &v) {
  std::cout << "[";
  bool first = true;
  for (const auto &x : v) {
    if (!first)
      std::cout << ",";
    first = false;
    __json(x);
  }
  std::cout << "]";
}
template <typename K, typename V> void __json(const std::map<K, V> &m) {
  std::cout << "{";
  bool first = true;
  for (const auto &kv : m) {
    if (!first)
      std::cout << ",";
    first = false;
    __json(kv.first);
    std::cout << ":";
    __json(kv.second);
  }
  std::cout << "}";
}
template <typename K, typename V>
void __json(const std::unordered_map<K, V> &m) {
  std::cout << "{";
  bool first = true;
  for (const auto &kv : m) {
    if (!first)
      std::cout << ",";
    first = false;
    __json(kv.first);
    std::cout << ":";
    __json(kv.second);
  }
  std::cout << "}";
}

struct StoreSale {
  decltype(std::string("A")) cust;
  decltype(5) price;
};
inline void __json(const StoreSale &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"cust\":";
  __json(v.cust);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"price\":";
  __json(v.price);
  std::cout << "}";
}
int main() {
  std::vector<StoreSale> store_sales = {StoreSale{std::string("A"), 5},
                                        StoreSale{std::string("B"), 30},
                                        StoreSale{std::string("C"), 57}};
  std::vector<std::string> catalog_sales =
      std::vector<decltype(std::unordered_map<std::string, std::string>{
          {std::string("cust"), std::string("A")}})>{
          std::unordered_map<std::string, std::string>{
              {std::string("cust"), std::string("A")}}};
  std::vector<int> web_sales = {};
  auto store_customers = ([&]() {
    std::vector<decltype(s.cust)> __items;
    for (auto s : store_sales) {
      __items.push_back(s.cust);
    }
    return __items;
  })();
  auto catalog_customers = ([&]() {
    std::vector<decltype(s.cust)> __items;
    for (auto s : catalog_sales) {
      __items.push_back(s.cust);
    }
    return __items;
  })();
  auto web_customers = ([&]() {
    std::vector<decltype(s.cust)> __items;
    for (auto s : web_sales) {
      __items.push_back(s.cust);
    }
    return __items;
  })();
  auto store_only = ([&]() {
    std::vector<decltype(c)> __items;
    for (auto c : store_customers) {
      if (!(((([&]() {
                std::vector<decltype(x)> __items;
                for (auto x : catalog_customers) {
                  if (!((x == c)))
                    continue;
                  __items.push_back(x);
                }
                return __items;
              })()
                  .size() == 0) &&
             (([&]() {
                std::vector<decltype(x)> __items;
                for (auto x : web_customers) {
                  if (!((x == c)))
                    continue;
                  __items.push_back(x);
                }
                return __items;
              })()
                  .size() == 0))))
        continue;
      __items.push_back(c);
    }
    return __items;
  })();
  auto result = ([&](auto v) {
    return std::accumulate(v.begin(), v.end(), 0.0);
  })(([&]() {
    std::vector<decltype(s.price)> __items;
    for (auto s : store_sales) {
      if (!((([&]() {
               std::vector<decltype(x)> __items;
               for (auto x : store_only) {
                 if (!((x == s.cust)))
                   continue;
                 __items.push_back(x);
               }
               return __items;
             })()
                 .size() > 0)))
        continue;
      __items.push_back(s.price);
    }
    return __items;
  })());
  (__json(result));
  // test TPCDS Q87 sample
  return 0;
}
