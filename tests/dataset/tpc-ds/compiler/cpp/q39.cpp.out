// Generated by Mochi compiler v0.10.25 on 2025-07-15T04:54:32Z
#include <algorithm>
#include <iostream>
#include <map>
#include <numeric>
#include <string>
#include <unordered_map>
#include <vector>

template <typename T> void __json(const T &);
inline void __json(int v) { std::cout << v; }
inline void __json(double v) { std::cout << v; }
inline void __json(bool v) { std::cout << (v ? "true" : "false"); }
inline void __json(const std::string &v) { std::cout << "\"" << v << "\""; }
inline void __json(const char *v) { std::cout << "\"" << v << "\""; }
template <typename T> void __json(const std::vector<T> &v) {
  std::cout << "[";
  bool first = true;
  for (const auto &x : v) {
    if (!first)
      std::cout << ",";
    first = false;
    __json(x);
  }
  std::cout << "]";
}
template <typename K, typename V> void __json(const std::map<K, V> &m) {
  std::cout << "{";
  bool first = true;
  for (const auto &kv : m) {
    if (!first)
      std::cout << ",";
    first = false;
    __json(kv.first);
    std::cout << ":";
    __json(kv.second);
  }
  std::cout << "}";
}
template <typename K, typename V>
void __json(const std::unordered_map<K, V> &m) {
  std::cout << "{";
  bool first = true;
  for (const auto &kv : m) {
    if (!first)
      std::cout << ",";
    first = false;
    __json(kv.first);
    std::cout << ":";
    __json(kv.second);
  }
  std::cout << "}";
}

#include <cmath>
namespace math {
inline double sqrt(double x) { return std::sqrt(x); }
inline double pow(double x, double y) { return std::pow(x, y); }
inline double sin(double x) { return std::sin(x); }
inline double log(double x) { return std::log(x); }
const double pi = 3.141592653589793;
const double e = 2.718281828459045;
} // namespace math
struct Inventory {
  decltype(1) inv_item_sk;
  decltype(1) inv_warehouse_sk;
  decltype(1) inv_date_sk;
  decltype(10) inv_quantity_on_hand;
};
struct Warehouse {
  decltype(1) w_warehouse_sk;
  decltype(std::string("W1")) w_warehouse_name;
};
struct DateDim {
  decltype(1) d_date_sk;
  decltype(2000) d_year;
  decltype(1) d_moy;
};
struct Monthly {
  decltype(w.w_warehouse_sk) w;
  decltype(i.i_item_sk) i;
  decltype(d.d_moy) month;
};
struct __struct5 {
  decltype(inv) inv;
  decltype(d) d;
  std::string i;
  decltype(w) w;
};
struct __struct6 {
  Monthly key;
  std::vector<__struct5> items;
};
struct __struct7 {
  decltype(std::declval<__struct6>().key.w) w;
  decltype(std::declval<__struct6>().key.i) i;
  double qty;
};
struct Key {
  decltype(std::declval<__struct5>().w) w;
  decltype(std::declval<__struct5>().i) i;
};
template <typename T, typename U>
std::vector<T> __append(const std::vector<T> &v, const U &x) {
  auto r = v;
  r.push_back(x);
  return r;
}
struct __struct9 {
  decltype(g.w) w;
  decltype(g.i) i;
  decltype(__append(g.qtys, std::declval<__struct5>().qty)) qtys;
};
template <typename T> double __avg(const std::vector<T> &v) {
  if (v.empty())
    return 0;
  double s = 0;
  for (const auto &x : v)
    s += x;
  return s / v.size();
}
struct __struct10 {
  decltype(g.w) w_warehouse_sk;
  decltype(g.i) i_item_sk;
  decltype(cov) cov;
};
inline void __json(const DateDim &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"d_date_sk\":";
  __json(v.d_date_sk);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"d_year\":";
  __json(v.d_year);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"d_moy\":";
  __json(v.d_moy);
  std::cout << "}";
}
inline void __json(const Inventory &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"inv_item_sk\":";
  __json(v.inv_item_sk);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"inv_warehouse_sk\":";
  __json(v.inv_warehouse_sk);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"inv_date_sk\":";
  __json(v.inv_date_sk);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"inv_quantity_on_hand\":";
  __json(v.inv_quantity_on_hand);
  std::cout << "}";
}
inline void __json(const __struct5 &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"inv\":";
  __json(v.inv);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"d\":";
  __json(v.d);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"i\":";
  __json(v.i);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"w\":";
  __json(v.w);
  std::cout << "}";
}
inline void __json(const Key &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"w\":";
  __json(v.w);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"i\":";
  __json(v.i);
  std::cout << "}";
}
inline void __json(const Monthly &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"w\":";
  __json(v.w);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"i\":";
  __json(v.i);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"month\":";
  __json(v.month);
  std::cout << "}";
}
inline void __json(const __struct7 &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"w\":";
  __json(v.w);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"i\":";
  __json(v.i);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"qty\":";
  __json(v.qty);
  std::cout << "}";
}
inline void __json(const __struct9 &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"w\":";
  __json(v.w);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"i\":";
  __json(v.i);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"qtys\":";
  __json(v.qtys);
  std::cout << "}";
}
inline void __json(const __struct10 &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"w_warehouse_sk\":";
  __json(v.w_warehouse_sk);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"i_item_sk\":";
  __json(v.i_item_sk);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"cov\":";
  __json(v.cov);
  std::cout << "}";
}
inline void __json(const Warehouse &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"w_warehouse_sk\":";
  __json(v.w_warehouse_sk);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"w_warehouse_name\":";
  __json(v.w_warehouse_name);
  std::cout << "}";
}
int main() {
  std::vector<Inventory> inventory = {
      Inventory{1, 1, 1, 10}, Inventory{1, 1, 2, 10}, Inventory{1, 1, 3, 250}};
  std::vector<std::string> item =
      std::vector<decltype(std::unordered_map<std::string, decltype(1)>{
          {std::string("i_item_sk"), 1}})>{
          std::unordered_map<std::string, decltype(1)>{
              {std::string("i_item_sk"), 1}}};
  std::vector<Warehouse> warehouse = {Warehouse{1, std::string("W1")}};
  std::vector<DateDim> date_dim = {DateDim{1, 2000, 1}, DateDim{2, 2000, 2},
                                   DateDim{3, 2000, 3}};
  std::vector<__struct5> monthly = ([&]() {
    std::vector<__struct6> __groups;
    for (auto inv : inventory) {
      for (auto d : date_dim) {
        if (!((inv.inv_date_sk == d.d_date_sk)))
          continue;
        for (auto i : item) {
          if (!((inv.inv_item_sk == i.i_item_sk)))
            continue;
          for (auto w : warehouse) {
            if (!((inv.inv_warehouse_sk == w.w_warehouse_sk)))
              continue;
            if (!((d.d_year == 2000)))
              continue;
            auto __key = Monthly{w.w_warehouse_sk, i.i_item_sk, d.d_moy};
            bool __found = false;
            for (auto &__g : __groups) {
              if (__g.key == __key) {
                __g.items.push_back(__struct5{inv, d, i, w});
                __found = true;
                break;
              }
            }
            if (!__found) {
              __groups.push_back(__struct6{
                  __key, std::vector<__struct5>{__struct5{inv, d, i, w}}});
            }
          }
        }
      }
    }
    std::vector<__struct7> __items;
    for (auto &g : __groups) {
      __items.push_back(__struct7{
          g.key.w, g.key.i, ([&](auto v) {
            return std::accumulate(v.begin(), v.end(), 0.0);
          })(([&]() {
            std::vector<
                decltype(std::declval<__struct5>().inv_quantity_on_hand)>
                __items;
            for (auto x : g.items) {
              __items.push_back(x.inv_quantity_on_hand);
            }
            return __items;
          })())});
    }
    return __items;
  })();
  auto grouped = std::unordered_map<int, int>{};
  for (auto m : monthly) {
    auto key = std::to_string(Key{m.w, m.i});
    if ((std::find(grouped.begin(), grouped.end(), key) != grouped.end())) {
      auto g = grouped[key];
      grouped[key] = __struct9{g.w, g.i, __append(g.qtys, m.qty)};
    } else {
      grouped[key] = __struct9{m.w, m.i, std::vector<decltype(m.qty)>{m.qty}};
    }
  }
  std::vector<int> summary = {};
  for (auto g : ([&]() {
         std::vector<int> v;
         for (auto &p : grouped)
           v.push_back(p.second);
         return v;
       })()) {
    auto mean = __avg(g.qtys);
    auto sumsq = 0;
    for (auto q : g.qtys) {
      sumsq = (sumsq + (((q - mean)) * ((q - mean))));
    }
    auto variance = (sumsq / ((g.qtys.size() - 1)));
    auto cov = (math::sqrt(variance) / mean);
    if ((cov > 1.5)) {
      summary.push_back(__struct10{g.w, g.i, cov});
    }
  }
  (__json(summary));
  // test TPCDS Q39 simplified
  return 0;
}
