run: exit status 127
/tmp/q17.erl:13:173: variable '_' is unbound
%   13|     Result = [#{i_item_id => maps:get(i_item_id, Key0), i_item_desc => maps:get(i_item_desc, Key0), s_state => maps:get(s_state, Key0), store_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_sales_quantityave => (lists:sum([maps:get(qty, X) || X <- Val0]) / length([maps:get(qty, X) || X <- Val0])), store_sales_quantitystdev => 0, store_sales_quantitycov => 0, store_returns_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_returns_quantityave => (lists:sum([maps:get(ret, X) || X <- Val0]) / length([maps:get(ret, X) || X <- Val0])), store_returns_quantitystdev => 0, store_returns_quantitycov => 0, catalog_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), catalog_sales_quantityave => (lists:sum([maps:get(csq, X) || X <- Val0]) / length([maps:get(csq, X) || X <- Val0])), catalog_sales_quantitystdev => 0, catalog_sales_quantitycov => 0} || {Key0, Val0} <- maps:to_list(lists:foldl(fun({Key0, Val0}, Acc0) -> L = maps:get(Key0, Acc0, []), maps:put(Key0, [Val0 | L], Acc0) end, #{}, [{#{i_item_id => maps:get(i_item_id, J), i_item_desc => maps:get(i_item_desc, J), s_state => maps:get(s_state, J)}, J} || J <- Joined]))],
%     |                                                                                                                                                                             ^

/tmp/q17.erl:13:235: variable '_' is unbound
%   13|     Result = [#{i_item_id => maps:get(i_item_id, Key0), i_item_desc => maps:get(i_item_desc, Key0), s_state => maps:get(s_state, Key0), store_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_sales_quantityave => (lists:sum([maps:get(qty, X) || X <- Val0]) / length([maps:get(qty, X) || X <- Val0])), store_sales_quantitystdev => 0, store_sales_quantitycov => 0, store_returns_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_returns_quantityave => (lists:sum([maps:get(ret, X) || X <- Val0]) / length([maps:get(ret, X) || X <- Val0])), store_returns_quantitystdev => 0, store_returns_quantitycov => 0, catalog_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), catalog_sales_quantityave => (lists:sum([maps:get(csq, X) || X <- Val0]) / length([maps:get(csq, X) || X <- Val0])), catalog_sales_quantitystdev => 0, catalog_sales_quantitycov => 0} || {Key0, Val0} <- maps:to_list(lists:foldl(fun({Key0, Val0}, Acc0) -> L = maps:get(Key0, Acc0, []), maps:put(Key0, [Val0 | L], Acc0) end, #{}, [{#{i_item_id => maps:get(i_item_id, J), i_item_desc => maps:get(i_item_desc, J), s_state => maps:get(s_state, J)}, J} || J <- Joined]))],
%     |                                                                                                                                                                                                                                           ^

/tmp/q17.erl:13:473: variable '_' is unbound
%   13|     Result = [#{i_item_id => maps:get(i_item_id, Key0), i_item_desc => maps:get(i_item_desc, Key0), s_state => maps:get(s_state, Key0), store_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_sales_quantityave => (lists:sum([maps:get(qty, X) || X <- Val0]) / length([maps:get(qty, X) || X <- Val0])), store_sales_quantitystdev => 0, store_sales_quantitycov => 0, store_returns_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_returns_quantityave => (lists:sum([maps:get(ret, X) || X <- Val0]) / length([maps:get(ret, X) || X <- Val0])), store_returns_quantitystdev => 0, store_returns_quantitycov => 0, catalog_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), catalog_sales_quantityave => (lists:sum([maps:get(csq, X) || X <- Val0]) / length([maps:get(csq, X) || X <- Val0])), catalog_sales_quantitystdev => 0, catalog_sales_quantitycov => 0} || {Key0, Val0} <- maps:to_list(lists:foldl(fun({Key0, Val0}, Acc0) -> L = maps:get(Key0, Acc0, []), maps:put(Key0, [Val0 | L], Acc0) end, #{}, [{#{i_item_id => maps:get(i_item_id, J), i_item_desc => maps:get(i_item_desc, J), s_state => maps:get(s_state, J)}, J} || J <- Joined]))],
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^

/tmp/q17.erl:13:535: variable '_' is unbound
%   13|     Result = [#{i_item_id => maps:get(i_item_id, Key0), i_item_desc => maps:get(i_item_desc, Key0), s_state => maps:get(s_state, Key0), store_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_sales_quantityave => (lists:sum([maps:get(qty, X) || X <- Val0]) / length([maps:get(qty, X) || X <- Val0])), store_sales_quantitystdev => 0, store_sales_quantitycov => 0, store_returns_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_returns_quantityave => (lists:sum([maps:get(ret, X) || X <- Val0]) / length([maps:get(ret, X) || X <- Val0])), store_returns_quantitystdev => 0, store_returns_quantitycov => 0, catalog_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), catalog_sales_quantityave => (lists:sum([maps:get(csq, X) || X <- Val0]) / length([maps:get(csq, X) || X <- Val0])), catalog_sales_quantitystdev => 0, catalog_sales_quantitycov => 0} || {Key0, Val0} <- maps:to_list(lists:foldl(fun({Key0, Val0}, Acc0) -> L = maps:get(Key0, Acc0, []), maps:put(Key0, [Val0 | L], Acc0) end, #{}, [{#{i_item_id => maps:get(i_item_id, J), i_item_desc => maps:get(i_item_desc, J), s_state => maps:get(s_state, J)}, J} || J <- Joined]))],
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^

/tmp/q17.erl:13:779: variable '_' is unbound
%   13|     Result = [#{i_item_id => maps:get(i_item_id, Key0), i_item_desc => maps:get(i_item_desc, Key0), s_state => maps:get(s_state, Key0), store_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_sales_quantityave => (lists:sum([maps:get(qty, X) || X <- Val0]) / length([maps:get(qty, X) || X <- Val0])), store_sales_quantitystdev => 0, store_sales_quantitycov => 0, store_returns_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_returns_quantityave => (lists:sum([maps:get(ret, X) || X <- Val0]) / length([maps:get(ret, X) || X <- Val0])), store_returns_quantitystdev => 0, store_returns_quantitycov => 0, catalog_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), catalog_sales_quantityave => (lists:sum([maps:get(csq, X) || X <- Val0]) / length([maps:get(csq, X) || X <- Val0])), catalog_sales_quantitystdev => 0, catalog_sales_quantitycov => 0} || {Key0, Val0} <- maps:to_list(lists:foldl(fun({Key0, Val0}, Acc0) -> L = maps:get(Key0, Acc0, []), maps:put(Key0, [Val0 | L], Acc0) end, #{}, [{#{i_item_id => maps:get(i_item_id, J), i_item_desc => maps:get(i_item_desc, J), s_state => maps:get(s_state, J)}, J} || J <- Joined]))],
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^

/tmp/q17.erl:13:841: variable '_' is unbound
%   13|     Result = [#{i_item_id => maps:get(i_item_id, Key0), i_item_desc => maps:get(i_item_desc, Key0), s_state => maps:get(s_state, Key0), store_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_sales_quantityave => (lists:sum([maps:get(qty, X) || X <- Val0]) / length([maps:get(qty, X) || X <- Val0])), store_sales_quantitystdev => 0, store_sales_quantitycov => 0, store_returns_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), store_returns_quantityave => (lists:sum([maps:get(ret, X) || X <- Val0]) / length([maps:get(ret, X) || X <- Val0])), store_returns_quantitystdev => 0, store_returns_quantitycov => 0, catalog_sales_quantitycount => (case [_ || _ <- Val0] of #{items := It} -> length(It); _ -> length([_ || _ <- Val0]) end), catalog_sales_quantityave => (lists:sum([maps:get(csq, X) || X <- Val0]) / length([maps:get(csq, X) || X <- Val0])), catalog_sales_quantitystdev => 0, catalog_sales_quantitycov => 0} || {Key0, Val0} <- maps:to_list(lists:foldl(fun({Key0, Val0}, Acc0) -> L = maps:get(Key0, Acc0, []), maps:put(Key0, [Val0 | L], Acc0) end, #{}, [{#{i_item_id => maps:get(i_item_id, J), i_item_desc => maps:get(i_item_desc, J), s_state => maps:get(s_state, J)}, J} || J <- Joined]))],
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^

escript: There were compilation errors.
