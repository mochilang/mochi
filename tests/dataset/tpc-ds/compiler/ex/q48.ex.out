# Generated by Mochi Elixir compiler
defmodule Main do
  def main do
    store_sales = [%{cdemo_sk: 1, addr_sk: 1, sold_date_sk: 1, sales_price: 120, net_profit: 1000, quantity: 5}, %{cdemo_sk: 2, addr_sk: 2, sold_date_sk: 1, sales_price: 60, net_profit: 2000, quantity: 10}, %{cdemo_sk: 3, addr_sk: 3, sold_date_sk: 1, sales_price: 170, net_profit: 10000, quantity: 20}]
    store = [%{s_store_sk: 1}]
    customer_demographics = [%{cd_demo_sk: 1, cd_marital_status: "S", cd_education_status: "E1"}, %{cd_demo_sk: 2, cd_marital_status: "M", cd_education_status: "E2"}, %{cd_demo_sk: 3, cd_marital_status: "W", cd_education_status: "E3"}]
    customer_address = [%{ca_address_sk: 1, ca_country: "United States", ca_state: "TX"}, %{ca_address_sk: 2, ca_country: "United States", ca_state: "CA"}, %{ca_address_sk: 3, ca_country: "United States", ca_state: "NY"}]
    date_dim = [%{d_date_sk: 1, d_year: 2000}]
    year = 2000
    states1 = ["TX"]
    states2 = ["CA"]
    states3 = ["NY"]
    qty_base = for ss <- store_sales, cd <- customer_demographics, ca <- customer_address, d <- date_dim, ((ss.cdemo_sk == cd.cd_demo_sk) && (ss.addr_sk == ca.ca_address_sk) && (ss.sold_date_sk == d.d_date_sk)) && ((((d.d_year == year) && ((((((cd.cd_marital_status == "S") && (cd.cd_education_status == "E1")) && (ss.sales_price >= 100)) && (ss.sales_price <= 150)) || ((((cd.cd_marital_status == "M") && (cd.cd_education_status == "E2")) && (ss.sales_price >= 50)) && (ss.sales_price <= 100))) || ((((cd.cd_marital_status == "W") && (cd.cd_education_status == "E3")) && (ss.sales_price >= 150)) && (ss.sales_price <= 200)))) && (((((if is_map(states1), do: Map.has_key?(states1, ca.ca_state), else: Enum.member?(states1, ca.ca_state)) && (ss.net_profit >= 0)) && (ss.net_profit <= 2000)) || (((if is_map(states2), do: Map.has_key?(states2, ca.ca_state), else: Enum.member?(states2, ca.ca_state)) && (ss.net_profit >= 150)) && (ss.net_profit <= 3000))) || (((if is_map(states3), do: Map.has_key?(states3, ca.ca_state), else: Enum.member?(states3, ca.ca_state)) && (ss.net_profit >= 50)) && (ss.net_profit <= 25000))))), do: ss.quantity
    qty = qty_base
    result = _sum(qty)
    _json(result)
  end
  defp _escape_json(<<>>), do: ""
defp _escape_json(<<"\\", rest::binary>>), do: "\\\\" <> _escape_json(rest)
defp _escape_json(<<"\"", rest::binary>>), do: "\\\"" <> _escape_json(rest)
defp _escape_json(<<c::binary-size(1), rest::binary>>), do: c <> _escape_json(rest)
defp _to_json(v) when is_binary(v), do: "\"" <> _escape_json(v) <> "\""
defp _to_json(v) when is_number(v), do: to_string(v)
defp _to_json(v) when is_boolean(v), do: if v, do: "true", else: "false"
defp _to_json(v) when is_list(v), do: "[" <> Enum.map_join(v, ",", &_to_json/1) <> "]"
defp _to_json(v) when is_map(v) do
  keys = Map.keys(v) |> Enum.map(&to_string/1) |> Enum.sort()
  inner = Enum.map_join(keys, ",", fn k -> _to_json(k) <> ":" <> _to_json(Map.get(v, String.to_atom(k), Map.get(v, k))) end)
  "{" <> inner <> "}"
end
defp _to_json(_), do: "null"
defp _json(v), do: IO.puts(_to_json(v))

  defp _sum(v) do
  list = cond do
    is_map(v) and Map.has_key?(v, :items) -> v[:items]
    is_list(v) -> v
    true -> raise "sum() expects list or group"
  end
  Enum.sum(list)
end

  end
Main.main()
