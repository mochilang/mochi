(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:17Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable item : int; mutable call : int; mutable date : int; mutable price : float }
type record2 = { mutable i_item_sk : int; mutable i_category : string; mutable i_brand : string }
type record3 = { mutable cc_call_center_sk : int; mutable cc_name : string }
type record4 = { mutable d_date_sk : int; mutable d_year : int; mutable d_moy : int }
type record5 = { mutable cat : string; mutable call : string; mutable year : int }
type record6 = { mutable cat : Obj.t; mutable call : Obj.t; mutable year : Obj.t; mutable sum_sales : float }
type record7 = { mutable cat : string; mutable call : string; mutable year : int; mutable sum_sales : float }
type record8 = { mutable cat : string; mutable call : string }
type record9 = { mutable cat : Obj.t; mutable call : Obj.t; mutable avg_sales : float }
type record10 = { mutable cat : string; mutable call : string; mutable avg_sales : float }
type record11 = { mutable i_category : string; mutable sum_sales : float }

let catalog_sales : record1 list = [{ item = 1; call = 1; date = 1; price = 20. };{ item = 1; call = 1; date = 2; price = 20. };{ item = 1; call = 1; date = 3; price = 40. }]
let item : record2 list = [{ i_item_sk = 1; i_category = "A"; i_brand = "B" }]
let call_center : record3 list = [{ cc_call_center_sk = 1; cc_name = "C1" }]
let date_dim : record4 list = [{ d_date_sk = 1; d_year = 2000; d_moy = 11 };{ d_date_sk = 2; d_year = 2000; d_moy = 12 };{ d_date_sk = 3; d_year = 2001; d_moy = 1 }]
let rec abs (x : float) : float =
  if (x >= 0.) then x else -x

let grouped : record7 list = (let (__groups0 : (record5 * record1 list) list ref) = ref [] in
  List.iter (fun (cs : record1) ->
      List.iter (fun (i : record2) ->
            List.iter (fun (d : record4) ->
                    List.iter (fun (cc : record3) ->
                                    if (cs.item = i.i_item_sk) && (cs.date = d.d_date_sk) && (cs.call = cc.cc_call_center_sk) then (
            let (key : record5) = { cat = i.i_category; call = cc.cc_name; year = d.d_year } in
            let cur = try List.assoc key !__groups0 with Not_found -> [] in
            __groups0 := (key, cs :: cur) :: List.remove_assoc key !__groups0);
                    ) call_center;
            ) date_dim;
      ) item;
  ) catalog_sales;
  let __res0 = ref [] in
  List.iter (fun ((gKey : record5), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { cat = g.key.cat; call = g.key.call; year = g.key.year; sum_sales = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.price :: !__res1;
  ) g.items;
List.rev !__res1)
) } :: !__res0
  ) !__groups0;
  List.rev !__res0)

let avg_by_year : record10 list = (let (__groups2 : (record8 * record7 list) list ref) = ref [] in
  List.iter (fun (g : record7) ->
      let (key : record8) = { cat = g.cat; call = g.call } in
      let cur = try List.assoc key !__groups2 with Not_found -> [] in
      __groups2 := (key, g :: cur) :: List.remove_assoc key !__groups2;
  ) grouped;
  let __res2 = ref [] in
  List.iter (fun ((ggKey : record8), ggItems) ->
    let gg = { key = ggKey; items = List.rev ggItems } in
    __res2 := { cat = gg.key.cat; call = gg.key.call; avg_sales = (List.fold_left (+.) 0.0 (let __res3 = ref [] in
  List.iter (fun x ->
      __res3 := x.sum_sales :: !__res3;
  ) gg.items;
List.rev !__res3)
 /. float_of_int (List.length (let __res3 = ref [] in
  List.iter (fun x ->
      __res3 := x.sum_sales :: !__res3;
  ) gg.items;
List.rev !__res3)
)) } :: !__res2
  ) !__groups2;
  List.rev !__res2)

let result : record11 list = (let __res4 = ref [] in
  List.iter (fun g ->
    List.iter (fun a ->
      if ((g.cat = a.cat) && (g.call = a.call)) then (
        if (((((g.year = 2001) && (a.avg_sales > 0)) && abs (g.sum_sales -. a.avg_sales)) /. a.avg_sales) > 0.1) then __res4 := { i_category = g.cat; sum_sales = g.sum_sales } :: !__res4;
      )
    ) avg_by_year;
  ) grouped;
  List.rev !__res4)


let () =
  json result;
  assert ((result = []))
