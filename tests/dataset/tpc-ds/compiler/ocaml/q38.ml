(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:16Z *)
  exception Break
  exception Continue

  let list_union a b = List.sort_uniq compare (a @ b)
  let list_except a b = List.filter (fun x -> not (List.mem x b)) a
  let list_intersect a b = List.filter (fun x -> List.mem x b) a |> List.sort_uniq compare
  let list_union_all a b = a @ b

  type record1 = { mutable c_customer_sk : int; mutable c_last_name : string; mutable c_first_name : string }
  type record2 = { mutable ss_customer_sk : int; mutable d_month_seq : int }
  type record3 = { mutable cs_bill_customer_sk : int; mutable d_month_seq : int }
  type record4 = { mutable ws_bill_customer_sk : int; mutable d_month_seq : int }

let customer : record1 list = [{ c_customer_sk = 1; c_last_name = "Smith"; c_first_name = "John" };{ c_customer_sk = 2; c_last_name = "Jones"; c_first_name = "Alice" }]
let store_sales : record2 list = [{ ss_customer_sk = 1; d_month_seq = 1200 };{ ss_customer_sk = 2; d_month_seq = 1205 }]
let catalog_sales : record3 list = [{ cs_bill_customer_sk = 1; d_month_seq = 1203 }]
let web_sales : record4 list = [{ ws_bill_customer_sk = 1; d_month_seq = 1206 }]
let rec distinct (xs : any list) : any list =
  let out : Obj.t list ref = ref [] in
  let rec __loop0 lst =
    match lst with
      | [] -> ()
      | x::rest ->
        (try
          if not (contains (!out) x) then (
            out := ((!out) @ [x]);
          ) ;
        with Continue -> ())
        ; __loop0 rest
    in
    try __loop0 xs with Break -> ()
    (!out)

  let store_ids : Obj.t list = distinct (let __res1 = ref [] in
  List.iter (fun (s : record2) ->
      if ((s.d_month_seq >= 1200) && (s.d_month_seq <= 1211)) then
    __res1 := s.ss_customer_sk :: !__res1;
  ) store_sales;
List.rev !__res1)

  let catalog_ids : Obj.t list = distinct (let __res2 = ref [] in
  List.iter (fun (c : record3) ->
      if ((c.d_month_seq >= 1200) && (c.d_month_seq <= 1211)) then
    __res2 := c.cs_bill_customer_sk :: !__res2;
  ) catalog_sales;
List.rev !__res2)

  let web_ids : Obj.t list = distinct (let __res3 = ref [] in
  List.iter (fun (w : record4) ->
      if ((w.d_month_seq >= 1200) && (w.d_month_seq <= 1211)) then
    __res3 := w.ws_bill_customer_sk :: !__res3;
  ) web_sales;
List.rev !__res3)

  let hot : Obj.t list = (list_intersect (list_intersect store_ids catalog_ids) web_ids)
  let result : int = List.length hot

  let () =
    json result;
    assert ((result = 1))
