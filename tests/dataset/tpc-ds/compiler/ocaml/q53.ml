(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:17Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable i_item_sk : int; mutable i_manufact_id : int }
type record2 = { mutable item : int; mutable date : int; mutable price : float }
type record3 = { mutable d_date_sk : int; mutable d_month_seq : int }
type record4 = { mutable manu : Obj.t; mutable sum_sales : float; mutable avg_sales : float }
type record5 = { mutable manu : int; mutable sum_sales : float; mutable avg_sales : float }
type record6 = { mutable i_manufact_id : int; mutable sum_sales : float }

let item : record1 list = [{ i_item_sk = 1; i_manufact_id = 1 };{ i_item_sk = 2; i_manufact_id = 2 }]
let store_sales : record2 list = [{ item = 1; date = 1; price = 10. };{ item = 1; date = 2; price = 10. };{ item = 2; date = 1; price = 30. };{ item = 2; date = 2; price = 23. }]
let date_dim : record3 list = [{ d_date_sk = 1; d_month_seq = 1 };{ d_date_sk = 2; d_month_seq = 2 }]
let rec abs (x : float) : float =
  if (x >= 0.) then x else -x

let grouped : record5 list = (let (__groups0 : (int * record2 list) list ref) = ref [] in
  List.iter (fun (ss : record2) ->
      List.iter (fun (i : record1) ->
            List.iter (fun (d : record3) ->
                        if (ss.item = i.i_item_sk) && (ss.date = d.d_date_sk) then (
          let (key : int) = i.i_manufact_id in
          let cur = try List.assoc key !__groups0 with Not_found -> [] in
          __groups0 := (key, ss :: cur) :: List.remove_assoc key !__groups0);
            ) date_dim;
      ) item;
  ) store_sales;
  let __res0 = ref [] in
  List.iter (fun ((gKey : int), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { manu = g.key; sum_sales = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.price :: !__res1;
  ) g.items;
List.rev !__res1)
); avg_sales = (List.fold_left (+.) 0.0 (let __res2 = ref [] in
  List.iter (fun x ->
      __res2 := x.price :: !__res2;
  ) g.items;
List.rev !__res2)
 /. float_of_int (List.length (let __res2 = ref [] in
  List.iter (fun x ->
      __res2 := x.price :: !__res2;
  ) g.items;
List.rev !__res2)
)) } :: !__res0
  ) !__groups0;
  List.rev !__res0)

let result : record6 list = (let __res3 = ref [] in
  List.iter (fun (g : record5) ->
      if ((((g.avg_sales > 0.) && abs (g.sum_sales -. g.avg_sales)) /. g.avg_sales) > 0.1) then
    __res3 := { i_manufact_id = g.manu; sum_sales = g.sum_sales } :: !__res3;
  ) grouped;
List.rev !__res3)


let () =
  json result;
  assert ((result = [{ i_manufact_id = 1; sum_sales = 20. };{ i_manufact_id = 2; sum_sales = 53. }]))
