(* Generated by Mochi compiler v0.10.26 on 2025-07-15T06:41:43Z *)
  exception Break
  exception Continue


  type record1 = { mutable date : int; mutable price : float }
  type record2 = { mutable item : int; mutable date : int; mutable price : float }
  type record3 = { mutable date : int; mutable cum : float }
  type record4 = { mutable date : Obj.t; mutable cum : Obj.t }
  type record5 = { mutable item_sk : int; mutable d_date : int }

let web_sales : record2 list = [{ item = 1; date = 1; price = 30. };{ item = 1; date = 2; price = 20. }]
let store_sales : record2 list = [{ item = 1; date = 1; price = 5. };{ item = 1; date = 2; price = 19. }]
let dms : int = 1
let rec cumulative (xs : record1 list) : record3 list =
  let out = ref [] in
  let acc : float ref = ref 0. in
  let rec __loop0 lst =
    match lst with
      | [] -> ()
      | x::rest ->
        (try
          acc := ((!acc) +. x.price);
          out := ((!out) @ [{ date = x.date; cum = (!acc) }]);
        with Continue -> ())
        ; __loop0 rest
    in
    try __loop0 xs with Break -> ()
    (!out)

  let web_cum : record3 list = cumulative ((let __res1 = ref [] in
  List.iter (fun (w : record2) ->
      __res1 := { date = w.date; price = w.price } :: !__res1;
  ) web_sales;
List.rev !__res1)
)
  let store_cum : record3 list = cumulative ((let __res2 = ref [] in
  List.iter (fun (s : record2) ->
      __res2 := { date = s.date; price = s.price } :: !__res2;
  ) store_sales;
List.rev !__res2)
)
  let joined : record5 list = (let __res3 = ref [] in
  List.iter (fun w ->
    List.iter (fun s ->
      if (w.date = s.date) then (
        if (w.cum > s.cum) then __res3 := { item_sk = 1; d_date = w.date } :: !__res3;
      )
    ) store_cum;
  ) web_cum;
  List.rev !__res3)

  let result : (string * Obj.t) list list = joined

  let () =
    json result;
    assert ((result = [{ item_sk = 1; d_date = 1 };{ item_sk = 1; d_date = 2 }]))
