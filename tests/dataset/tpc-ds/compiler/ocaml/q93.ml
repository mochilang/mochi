(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:17Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable ss_item_sk : int; mutable ss_ticket_number : int; mutable ss_customer_sk : int; mutable ss_quantity : int; mutable ss_sales_price : float }
type record2 = { mutable sr_item_sk : int; mutable sr_ticket_number : int; mutable sr_reason_sk : int; mutable sr_return_quantity : int }
type record3 = { mutable r_reason_sk : int; mutable r_reason_desc : string }
type record4 = { mutable ss_customer_sk : int; mutable act_sales : float }
type record5 = { mutable ss_customer_sk : Obj.t; mutable sumsales : float }
type record6 = { mutable ss_customer_sk : int; mutable sumsales : float }

type storesale = { mutable ss_item_sk : int; mutable ss_ticket_number : int; mutable ss_customer_sk : int; mutable ss_quantity : int; mutable ss_sales_price : float }
type storereturn = { mutable sr_item_sk : int; mutable sr_ticket_number : int; mutable sr_reason_sk : int; mutable sr_return_quantity : int }
type reason = { mutable r_reason_sk : int; mutable r_reason_desc : string }
let store_sales : record1 list = [{ ss_item_sk = 1; ss_ticket_number = 1; ss_customer_sk = 1; ss_quantity = 5; ss_sales_price = 10. };{ ss_item_sk = 1; ss_ticket_number = 2; ss_customer_sk = 2; ss_quantity = 3; ss_sales_price = 20. }]
let store_returns : record2 list = [{ sr_item_sk = 1; sr_ticket_number = 1; sr_reason_sk = 1; sr_return_quantity = 1 }]
let reason : record3 list = [{ r_reason_sk = 1; r_reason_desc = "ReasonA" }]
let t : record4 list = (let __res0 = ref [] in
  List.iter (fun (ss : record1) ->
      List.iter (fun (sr : record2) ->
      let matched = ref false in
      List.iter (fun r ->
        if ((ss.ss_item_sk = sr.sr_item_sk) && (ss.ss_ticket_number = sr.sr_ticket_number)) && ((sr <> ()) && (sr.sr_reason_sk = r.r_reason_sk)) && ((r = ()) || (r.r_reason_desc = "ReasonA")) then (
          __res0 := { ss_customer_sk = ss.ss_customer_sk; act_sales = (if (sr <> ()) then (((ss.ss_quantity - sr.sr_return_quantity)) *. ss.ss_sales_price) else (ss.ss_quantity *. ss.ss_sales_price)) } :: !__res0;
          matched := true)
      ) reason;
      if not !matched then (
        let r = Obj.magic () in
        if ((ss.ss_item_sk = sr.sr_item_sk) && (ss.ss_ticket_number = sr.sr_ticket_number)) && ((r = ()) || (r.r_reason_desc = "ReasonA")) then __res0 := { ss_customer_sk = ss.ss_customer_sk; act_sales = (if (sr <> ()) then (((ss.ss_quantity - sr.sr_return_quantity)) *. ss.ss_sales_price) else (ss.ss_quantity *. ss.ss_sales_price)) } :: !__res0;
      );
      ) store_returns;
  ) store_sales;
List.rev !__res0)

let result : record6 list = (let (__groups1 : (int * record4 list) list ref) = ref [] in
  List.iter (fun (x : record4) ->
      let (key : int) = x.ss_customer_sk in
      let cur = try List.assoc key !__groups1 with Not_found -> [] in
      __groups1 := (key, x :: cur) :: List.remove_assoc key !__groups1;
  ) t;
  let __res1 = ref [] in
  List.iter (fun ((gKey : int), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res1 := { ss_customer_sk = g.key; sumsales = (sum_float (let __res2 = ref [] in
  List.iter (fun y ->
      __res2 := y.act_sales :: !__res2;
  ) g.items;
List.rev !__res2)
) } :: !__res1
  ) !__groups1;
  List.rev !__res1)


let () =
  json result;
  assert ((result = [{ ss_customer_sk = 1; sumsales = 40. };{ ss_customer_sk = 2; sumsales = 60. }]))
