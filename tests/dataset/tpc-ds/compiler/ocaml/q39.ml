(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:16Z *)
      let rec __show v =
        let open Obj in
        let rec list_aux o =
          if is_int o && (magic (obj o) : int) = 0 then "" else
           let hd = field o 0 in
           let tl = field o 1 in
           let rest = list_aux tl in
           if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
        in
        let r = repr v in
        if is_int r then string_of_int (magic v) else
        match tag r with
          | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
          | 252 -> (magic v : string)
          | 253 -> string_of_float (magic v)
          | _ -> "<value>"

      exception Break
      exception Continue

      let rec map_set m k v =
        match m with
          | [] -> [(k,Obj.repr v)]
          | (k2,v2)::tl -> if k2 = k then (k,Obj.repr v)::tl else (k2,v2)::map_set tl k v

      let sum lst = List.fold_left (+) 0 lst
      let sum_float lst = List.fold_left (+.) 0.0 lst
      type ('k,'v) group = { key : 'k; items : 'v list }

      type record1 = { mutable inv_item_sk : int; mutable inv_warehouse_sk : int; mutable inv_date_sk : int; mutable inv_quantity_on_hand : int }
      type record2 = { mutable i_item_sk : int }
      type record3 = { mutable w_warehouse_sk : int; mutable w_warehouse_name : string }
      type record4 = { mutable d_date_sk : int; mutable d_year : int; mutable d_moy : int }
      type record5 = { mutable w : int; mutable i : int; mutable month : int }
      type record6 = { mutable w : Obj.t; mutable i : Obj.t; mutable qty : float }
      type record7 = { mutable w : int; mutable i : int; mutable qty : float }
      type record8 = { mutable w : int; mutable i : int }
      type record9 = { mutable w : Obj.t; mutable i : Obj.t; mutable qtys : Obj.t list }
      type record10 = { mutable w : int; mutable i : int; mutable qtys : float list }
      type record11 = { mutable w_warehouse_sk : Obj.t; mutable i_item_sk : Obj.t; mutable cov : Obj.t }
      type record12 = { mutable w_warehouse_sk : int; mutable i_item_sk : int; mutable cov : float }

module Math = struct
  let pi = Float.pi
  let e = exp 1.0
  let sqrt x = sqrt x
  let pow x y = x ** y
  let sin x = sin x
  let log x = log x
end
let inventory : record1 list = [{ inv_item_sk = 1; inv_warehouse_sk = 1; inv_date_sk = 1; inv_quantity_on_hand = 10 };{ inv_item_sk = 1; inv_warehouse_sk = 1; inv_date_sk = 2; inv_quantity_on_hand = 10 };{ inv_item_sk = 1; inv_warehouse_sk = 1; inv_date_sk = 3; inv_quantity_on_hand = 250 }]
let item : record2 list = [[("i_item_sk",Obj.repr (1))]]
let warehouse : record3 list = [{ w_warehouse_sk = 1; w_warehouse_name = "W1" }]
let date_dim : record4 list = [{ d_date_sk = 1; d_year = 2000; d_moy = 1 };{ d_date_sk = 2; d_year = 2000; d_moy = 2 };{ d_date_sk = 3; d_year = 2000; d_moy = 3 }]
let monthly : record7 list = (let (__groups0 : (record5 * record1 list) list ref) = ref [] in
  List.iter (fun (inv : record1) ->
      List.iter (fun (d : record4) ->
            List.iter (fun i ->
                    List.iter (fun (w : record3) ->
                                    if (inv.inv_date_sk = d.d_date_sk) && (inv.inv_item_sk = Obj.obj (List.assoc "i_item_sk" i)) && (inv.inv_warehouse_sk = w.w_warehouse_sk) && (d.d_year = 2000) then (
            let (key : record5) = { w = w.w_warehouse_sk; i = Obj.obj (List.assoc "i_item_sk" i); month = d.d_moy } in
            let cur = try List.assoc key !__groups0 with Not_found -> [] in
            __groups0 := (key, inv :: cur) :: List.remove_assoc key !__groups0);
                    ) warehouse;
            ) item;
      ) date_dim;
  ) inventory;
  let __res0 = ref [] in
  List.iter (fun ((gKey : record5), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { w = g.key.w; i = g.key.i; qty = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.inv_quantity_on_hand :: !__res1;
  ) g.items;
List.rev !__res1)
) } :: !__res0
  ) !__groups0;
  List.rev !__res0)

let grouped : (string * Obj.t) list ref = ref []
let summary : Obj.t list ref = ref []

let () =
  let rec __loop2 lst =
    match lst with
      | [] -> ()
      | (m : record7)::rest ->
        (try
          let key : string = __show ({ w = m.w; i = m.i }) in
          if (List.mem_assoc key (!grouped)) then (
            let g : (string * Obj.t) list = Obj.obj (List.assoc key (!grouped)) in
            grouped := map_set !grouped key { w = g.w; i = g.i; qtys = (g.qtys @ [m.qty]) };
          ) else (
            grouped := map_set !grouped key { w = m.w; i = m.i; qtys = [m.qty] };
          ) ;
        with Continue -> ())
        ; __loop2 rest
    in
    try __loop2 monthly with Break -> ()
    let rec __loop3 lst =
      match lst with
        | [] -> ()
        | g::rest ->
          (try
            let mean : float = (float_of_int (List.fold_left (+) 0 Obj.obj (List.assoc "qtys" g)) /. float_of_int (List.length Obj.obj (List.assoc "qtys" g))) in
            let sumsq : float ref = ref 0. in
            let rec __loop4 lst =
              match lst with
                | [] -> ()
                | q::rest ->
                  (try
                    sumsq := (((!sumsq) + ((q - mean))) * ((q - mean)));
                  with Continue -> ())
                  ; __loop4 rest
              in
              try __loop4 Obj.obj (List.assoc "qtys" g) with Break -> ()
              let variance = ((!sumsq) / ((List.length Obj.obj (List.assoc "qtys" g) - 1))) in
              let cov = (Math.sqrt variance /. mean) in
              if (cov > 1.5) then (
                summary := ((!summary) @ [{ w_warehouse_sk = Obj.obj (List.assoc "w" g); i_item_sk = Obj.obj (List.assoc "i" g); cov = cov }]);
              ) ;
            with Continue -> ())
            ; __loop3 rest
        in
        try __loop3 List.map snd (!grouped) with Break -> ()
        json (!summary);
        assert (((!summary) = [{ w_warehouse_sk = 1; i_item_sk = 1; cov = 1.539600717839002 }]))
