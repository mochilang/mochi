(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:17Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable item : int; mutable price : float }
type record2 = { mutable item : Obj.t; mutable total : float }
type record3 = { mutable item : int; mutable total : float }
type record4 = { mutable i_item_id : Obj.t; mutable total_sales : float }
type record5 = { mutable i_item_id : int; mutable total_sales : float }

let store_sales : record1 list = [{ item = 1; price = 10. }]
let catalog_sales : record1 list = [{ item = 1; price = 20. }]
let web_sales : record1 list = [{ item = 1; price = 30. }]
let ss : record3 list = (let (__groups0 : (int * record1 list) list ref) = ref [] in
  List.iter (fun (s : record1) ->
      let (key : int) = s.item in
      let cur = try List.assoc key !__groups0 with Not_found -> [] in
      __groups0 := (key, s :: cur) :: List.remove_assoc key !__groups0;
  ) store_sales;
  let __res0 = ref [] in
  List.iter (fun ((gKey : int), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { item = g.key; total = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.price :: !__res1;
  ) g.items;
List.rev !__res1)
) } :: !__res0
  ) !__groups0;
  List.rev !__res0)

let cs : record3 list = (let (__groups2 : (int * record1 list) list ref) = ref [] in
  List.iter (fun (s : record1) ->
      let (key : int) = s.item in
      let cur = try List.assoc key !__groups2 with Not_found -> [] in
      __groups2 := (key, s :: cur) :: List.remove_assoc key !__groups2;
  ) catalog_sales;
  let __res2 = ref [] in
  List.iter (fun ((gKey : int), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res2 := { item = g.key; total = (sum_float (let __res3 = ref [] in
  List.iter (fun x ->
      __res3 := x.price :: !__res3;
  ) g.items;
List.rev !__res3)
) } :: !__res2
  ) !__groups2;
  List.rev !__res2)

let ws : record3 list = (let (__groups4 : (int * record1 list) list ref) = ref [] in
  List.iter (fun (s : record1) ->
      let (key : int) = s.item in
      let cur = try List.assoc key !__groups4 with Not_found -> [] in
      __groups4 := (key, s :: cur) :: List.remove_assoc key !__groups4;
  ) web_sales;
  let __res4 = ref [] in
  List.iter (fun ((gKey : int), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res4 := { item = g.key; total = (sum_float (let __res5 = ref [] in
  List.iter (fun x ->
      __res5 := x.price :: !__res5;
  ) g.items;
List.rev !__res5)
) } :: !__res4
  ) !__groups4;
  List.rev !__res4)

let union : Obj.t list = concat ss cs ws
let result : record4 list = (let (__groups6 : (Obj.t * Obj.t list) list ref) = ref [] in
  List.iter (fun u ->
      let key = u.item in
      let cur = try List.assoc key !__groups6 with Not_found -> [] in
      __groups6 := (key, u :: cur) :: List.remove_assoc key !__groups6;
  ) union;
  let __res6 = ref [] in
  List.iter (fun ((gKey,gItems)) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res6 := { i_item_id = g.key; total_sales = (sum_float (let __res7 = ref [] in
  List.iter (fun x ->
      __res7 := x.total :: !__res7;
  ) g.items;
List.rev !__res7)
) } :: !__res6
  ) !__groups6;
  List.rev !__res6)


let () =
  json result;
  assert ((result = [{ i_item_id = 1; total_sales = 60. }]))
