(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:16Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable i_item_sk : int; mutable i_manufact_id : int; mutable i_category : string }
type record2 = { mutable d_date_sk : int; mutable d_year : int; mutable d_moy : int }
type record3 = { mutable ca_address_sk : int; mutable ca_gmt_offset : int }
type record4 = { mutable ss_item_sk : int; mutable ss_ext_sales_price : float; mutable ss_sold_date_sk : int; mutable ss_addr_sk : int }
type record5 = { mutable cs_item_sk : int; mutable cs_ext_sales_price : float; mutable cs_sold_date_sk : int; mutable cs_bill_addr_sk : int }
type record6 = { mutable ws_item_sk : int; mutable ws_ext_sales_price : float; mutable ws_sold_date_sk : int; mutable ws_bill_addr_sk : int }
type record7 = { mutable manu : int; mutable price : float }
type record8 = { mutable i_manufact_id : Obj.t; mutable total_sales : float }
type record9 = { mutable i_manufact_id : int; mutable total_sales : float }

let item : record1 list = [{ i_item_sk = 1; i_manufact_id = 1; i_category = "Books" };{ i_item_sk = 2; i_manufact_id = 2; i_category = "Books" }]
let date_dim : record2 list = [{ d_date_sk = 1; d_year = 2000; d_moy = 1 }]
let customer_address : record3 list = [{ ca_address_sk = 1; ca_gmt_offset = -5 };{ ca_address_sk = 2; ca_gmt_offset = -5 }]
let store_sales : record4 list = [{ ss_item_sk = 1; ss_ext_sales_price = 100.; ss_sold_date_sk = 1; ss_addr_sk = 1 };{ ss_item_sk = 2; ss_ext_sales_price = 50.; ss_sold_date_sk = 1; ss_addr_sk = 2 }]
let catalog_sales : record5 list = [{ cs_item_sk = 1; cs_ext_sales_price = 20.; cs_sold_date_sk = 1; cs_bill_addr_sk = 1 }]
let web_sales : record6 list = [{ ws_item_sk = 1; ws_ext_sales_price = 30.; ws_sold_date_sk = 1; ws_bill_addr_sk = 1 }]
let month : int = 1
let year : int = 2000
let union_sales : Obj.t list = concat (let __res0 = ref [] in
  List.iter (fun (ss : record4) ->
      List.iter (fun (d : record2) ->
            List.iter (fun (ca : record3) ->
                    List.iter (fun (i : record1) ->
                                    if (ss.ss_sold_date_sk = d.d_date_sk) && (ss.ss_addr_sk = ca.ca_address_sk) && (ss.ss_item_sk = i.i_item_sk) && ((((i.i_category = "Books") && (d.d_year = year)) && (d.d_moy = month)) && (ca.ca_gmt_offset = (-5))) then
          __res0 := { manu = i.i_manufact_id; price = ss.ss_ext_sales_price } :: !__res0;
                    ) item;
            ) customer_address;
      ) date_dim;
  ) store_sales;
List.rev !__res0)
 (let __res1 = ref [] in
  List.iter (fun (cs : record5) ->
      List.iter (fun (d : record2) ->
            List.iter (fun (ca : record3) ->
                    List.iter (fun (i : record1) ->
                                    if (cs.cs_sold_date_sk = d.d_date_sk) && (cs.cs_bill_addr_sk = ca.ca_address_sk) && (cs.cs_item_sk = i.i_item_sk) && ((((i.i_category = "Books") && (d.d_year = year)) && (d.d_moy = month)) && (ca.ca_gmt_offset = (-5))) then
          __res1 := { manu = i.i_manufact_id; price = cs.cs_ext_sales_price } :: !__res1;
                    ) item;
            ) customer_address;
      ) date_dim;
  ) catalog_sales;
List.rev !__res1)
 (let __res2 = ref [] in
  List.iter (fun (ws : record6) ->
      List.iter (fun (d : record2) ->
            List.iter (fun (ca : record3) ->
                    List.iter (fun (i : record1) ->
                                    if (ws.ws_sold_date_sk = d.d_date_sk) && (ws.ws_bill_addr_sk = ca.ca_address_sk) && (ws.ws_item_sk = i.i_item_sk) && ((((i.i_category = "Books") && (d.d_year = year)) && (d.d_moy = month)) && (ca.ca_gmt_offset = (-5))) then
          __res2 := { manu = i.i_manufact_id; price = ws.ws_ext_sales_price } :: !__res2;
                    ) item;
            ) customer_address;
      ) date_dim;
  ) web_sales;
List.rev !__res2)

let result : record8 list = (let (__groups3 : (Obj.t * Obj.t list) list ref) = ref [] in
  List.iter (fun s ->
      let key = s.manu in
      let cur = try List.assoc key !__groups3 with Not_found -> [] in
      __groups3 := (key, s :: cur) :: List.remove_assoc key !__groups3;
  ) union_sales;
  let __res3 = ref [] in
  List.iter (fun ((gKey,gItems)) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res3 := { i_manufact_id = g.key; total_sales = (sum_float (let __res4 = ref [] in
  List.iter (fun x ->
      __res4 := x.price :: !__res4;
  ) g.items;
List.rev !__res4)
) } :: !__res3
  ) !__groups3;
  List.rev !__res3)


let () =
  json result;
  assert ((result = [{ i_manufact_id = 1; total_sales = 150. };{ i_manufact_id = 2; total_sales = 50. }]))
