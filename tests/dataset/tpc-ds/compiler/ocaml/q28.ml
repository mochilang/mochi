(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:16Z *)
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable ss_quantity : int; mutable ss_list_price : float; mutable ss_coupon_amt : float; mutable ss_wholesale_cost : float }
type record2 = { mutable B1_LP : float; mutable B1_CNT : int; mutable B1_CNTD : int; mutable B2_LP : float; mutable B2_CNT : int; mutable B2_CNTD : int }

type storesale = { mutable ss_quantity : int; mutable ss_list_price : float; mutable ss_coupon_amt : float; mutable ss_wholesale_cost : float }
let store_sales : record1 list = [{ ss_quantity = 3; ss_list_price = 100.; ss_coupon_amt = 50.; ss_wholesale_cost = 30. };{ ss_quantity = 8; ss_list_price = 80.; ss_coupon_amt = 10.; ss_wholesale_cost = 20. };{ ss_quantity = 12; ss_list_price = 60.; ss_coupon_amt = 5.; ss_wholesale_cost = 15. }]
let bucket1 : record1 list = (let __res0 = ref [] in
  List.iter (fun (ss : record1) ->
      if (((ss.ss_quantity >= 0) && (ss.ss_quantity <= 5)) && ((((((ss.ss_list_price >= 0) && (ss.ss_list_price <= 110))) || (((ss.ss_coupon_amt >= 0) && (ss.ss_coupon_amt <= 1000)))) || (((ss.ss_wholesale_cost >= 0) && (ss.ss_wholesale_cost <= 50)))))) then
    __res0 := ss :: !__res0;
  ) store_sales;
List.rev !__res0)

let bucket2 : record1 list = (let __res1 = ref [] in
  List.iter (fun (ss : record1) ->
      if (((ss.ss_quantity >= 6) && (ss.ss_quantity <= 10)) && ((((((ss.ss_list_price >= 0) && (ss.ss_list_price <= 110))) || (((ss.ss_coupon_amt >= 0) && (ss.ss_coupon_amt <= 1000)))) || (((ss.ss_wholesale_cost >= 0) && (ss.ss_wholesale_cost <= 50)))))) then
    __res1 := ss :: !__res1;
  ) store_sales;
List.rev !__res1)

let result : record2 = { B1_LP = (float_of_int (List.fold_left (+) 0 (let __res2 = ref [] in
  List.iter (fun (x : record1) ->
      __res2 := x.ss_list_price :: !__res2;
  ) bucket1;
List.rev !__res2)
) /. float_of_int (List.length (let __res2 = ref [] in
  List.iter (fun (x : record1) ->
      __res2 := x.ss_list_price :: !__res2;
  ) bucket1;
List.rev !__res2)
)); B1_CNT = List.length bucket1; B1_CNTD = List.length (let (__groups3 : (float * record1 list) list ref) = ref [] in
  List.iter (fun (x : record1) ->
      let (key : float) = x.ss_list_price in
      let cur = try List.assoc key !__groups3 with Not_found -> [] in
      __groups3 := (key, x :: cur) :: List.remove_assoc key !__groups3;
  ) bucket1;
  let __res3 = ref [] in
  List.iter (fun ((gKey : float), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res3 := g.key :: !__res3
  ) !__groups3;
  List.rev !__res3)
; B2_LP = (float_of_int (List.fold_left (+) 0 (let __res4 = ref [] in
  List.iter (fun (x : record1) ->
      __res4 := x.ss_list_price :: !__res4;
  ) bucket2;
List.rev !__res4)
) /. float_of_int (List.length (let __res4 = ref [] in
  List.iter (fun (x : record1) ->
      __res4 := x.ss_list_price :: !__res4;
  ) bucket2;
List.rev !__res4)
)); B2_CNT = List.length bucket2; B2_CNTD = List.length (let (__groups5 : (float * record1 list) list ref) = ref [] in
  List.iter (fun (x : record1) ->
      let (key : float) = x.ss_list_price in
      let cur = try List.assoc key !__groups5 with Not_found -> [] in
      __groups5 := (key, x :: cur) :: List.remove_assoc key !__groups5;
  ) bucket2;
  let __res5 = ref [] in
  List.iter (fun ((gKey : float), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res5 := g.key :: !__res5
  ) !__groups5;
  List.rev !__res5)
 }

let () =
  json result;
  assert ((result = { B1_LP = 100.; B1_CNT = 1; B1_CNTD = 1; B2_LP = 80.; B2_CNT = 1; B2_CNTD = 1 }))
