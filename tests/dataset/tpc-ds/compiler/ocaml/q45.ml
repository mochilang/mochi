(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:17Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable bill_customer_sk : int; mutable item_sk : int; mutable sold_date_sk : int; mutable sales_price : float }
type record2 = { mutable c_customer_sk : int; mutable c_current_addr_sk : int }
type record3 = { mutable ca_address_sk : int; mutable ca_zip : string }
type record4 = { mutable i_item_sk : int; mutable i_item_id : string }
type record5 = { mutable d_date_sk : int; mutable d_qoy : int; mutable d_year : int }
type record6 = { mutable ca_zip : Obj.t; mutable sum_ws_sales_price : float }
type record7 = { mutable ca_zip : string; mutable sum_ws_sales_price : float }

let web_sales : record1 list = [{ bill_customer_sk = 1; item_sk = 1; sold_date_sk = 1; sales_price = 50. };{ bill_customer_sk = 2; item_sk = 2; sold_date_sk = 1; sales_price = 30. }]
let customer : record2 list = [{ c_customer_sk = 1; c_current_addr_sk = 1 };{ c_customer_sk = 2; c_current_addr_sk = 2 }]
let customer_address : record3 list = [{ ca_address_sk = 1; ca_zip = "85669" };{ ca_address_sk = 2; ca_zip = "99999" }]
let item : record4 list = [{ i_item_sk = 1; i_item_id = "I1" };{ i_item_sk = 2; i_item_id = "I2" }]
let date_dim : record5 list = [{ d_date_sk = 1; d_qoy = 1; d_year = 2020 }]
let zip_list : string list = ["85669";"86197";"88274";"83405";"86475";"85392";"85460";"80348";"81792"]
let item_ids : string list = ["I2"]
let qoy : int = 1
let year : int = 2020
let base : record7 list = (let (__groups0 : (string * record1 list) list ref) = ref [] in
  List.iter (fun (ws : record1) ->
      List.iter (fun (c : record2) ->
            List.iter (fun (ca : record3) ->
                    List.iter (fun (i : record4) ->
                              List.iter (fun (d : record5) ->
                                                  if (ws.bill_customer_sk = c.c_customer_sk) && (c.c_current_addr_sk = ca.ca_address_sk) && (ws.item_sk = i.i_item_sk) && (ws.sold_date_sk = d.d_date_sk) && ((((List.mem ((List.mem substr ca.ca_zip 0 5 zip_list) || i.i_item_id) item_ids)) && (d.d_qoy = qoy)) && (d.d_year = year)) then (
              let (key : string) = ca.ca_zip in
              let cur = try List.assoc key !__groups0 with Not_found -> [] in
              __groups0 := (key, ws :: cur) :: List.remove_assoc key !__groups0);
                              ) date_dim;
                    ) item;
            ) customer_address;
      ) customer;
  ) web_sales;
  let __res0 = ref [] in
  List.iter (fun ((gKey : string), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { ca_zip = g.key; sum_ws_sales_price = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.ws.sales_price :: !__res1;
  ) g.items;
List.rev !__res1)
) } :: !__res0
  ) !__groups0;
  List.rev !__res0)

let records : (string * Obj.t) list list = base

let () =
  json records;
  assert ((records = [{ ca_zip = "85669"; sum_ws_sales_price = 50. };{ ca_zip = "99999"; sum_ws_sales_price = 30. }]))
