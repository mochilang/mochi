(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:16Z *)
  exception Break
  exception Continue

  let sum lst = List.fold_left (+) 0 lst
  let sum_float lst = List.fold_left (+.) 0.0 lst
  type ('k,'v) group = { key : 'k; items : 'v list }

  type record1 = { mutable cs_order_number : int; mutable cs_ship_date_sk : int; mutable cs_ship_addr_sk : int; mutable cs_call_center_sk : int; mutable cs_warehouse_sk : int; mutable cs_ext_ship_cost : float; mutable cs_net_profit : float }
  type record2 = { mutable d_date_sk : int; mutable d_date : string }
  type record3 = { mutable ca_address_sk : int; mutable ca_state : string }
  type record4 = { mutable cc_call_center_sk : int; mutable cc_county : string }
  type record5 = { mutable order_count : int; mutable total_shipping_cost : float; mutable total_net_profit : float }

type catalogsale = { mutable cs_order_number : int; mutable cs_ship_date_sk : int; mutable cs_ship_addr_sk : int; mutable cs_call_center_sk : int; mutable cs_warehouse_sk : int; mutable cs_ext_ship_cost : float; mutable cs_net_profit : float }
type datedim = { mutable d_date_sk : int; mutable d_date : string }
type customeraddress = { mutable ca_address_sk : int; mutable ca_state : string }
type callcenter = { mutable cc_call_center_sk : int; mutable cc_county : string }
type catalogreturn = { mutable cr_order_number : int }
let catalog_sales : record1 list = [{ cs_order_number = 1; cs_ship_date_sk = 1; cs_ship_addr_sk = 1; cs_call_center_sk = 1; cs_warehouse_sk = 1; cs_ext_ship_cost = 5.; cs_net_profit = 20. };{ cs_order_number = 1; cs_ship_date_sk = 1; cs_ship_addr_sk = 1; cs_call_center_sk = 1; cs_warehouse_sk = 2; cs_ext_ship_cost = 0.; cs_net_profit = 0. }]
let date_dim : record2 list = [{ d_date_sk = 1; d_date = "2000-03-01" }]
let customer_address : record3 list = [{ ca_address_sk = 1; ca_state = "CA" }]
let call_center : record4 list = [{ cc_call_center_sk = 1; cc_county = "CountyA" }]
let catalog_returns : Obj.t list = []
let rec distinct (xs : any list) : any list =
  let out : Obj.t list ref = ref [] in
  let rec __loop0 lst =
    match lst with
      | [] -> ()
      | x::rest ->
        (try
          if not (contains (!out) x) then (
            out := ((!out) @ [x]);
          ) ;
        with Continue -> ())
        ; __loop0 rest
    in
    try __loop0 xs with Break -> ()
    (!out)

  let filtered : record5 list = (let (__groups3 : ((Obj.t * Obj.t) list * record1 list) list ref) = ref [] in
  List.iter (fun (cs1 : record1) ->
      List.iter (fun (d : record2) ->
            List.iter (fun (ca : record3) ->
                    List.iter (fun (cc : record4) ->
                                    if (((cs1.cs_ship_date_sk = d.d_date_sk) && (d.d_date >= "2000-03-01")) && (d.d_date <= "2000-04-30")) && ((cs1.cs_ship_addr_sk = ca.ca_address_sk) && (ca.ca_state = "CA")) && ((cs1.cs_call_center_sk = cc.cc_call_center_sk) && (cc.cc_county = "CountyA")) && (((let __res1 = ref [] in
  List.iter (fun (cs2 : record1) ->
      if ((cs1.cs_order_number = cs2.cs_order_number) && (cs1.cs_warehouse_sk <> cs2.cs_warehouse_sk)) then
    __res1 := cs2 :: !__res1;
  ) catalog_sales;
List.rev !__res1)
 <> []) && (((let __res2 = ref [] in
  List.iter (fun cr ->
      if (cs1.cs_order_number = cr.cr_order_number) then
    __res2 := cr :: !__res2;
  ) catalog_returns;
List.rev !__res2)
 <> []) = false)) then (
            let (key : (Obj.t * Obj.t) list) = [] in
            let cur = try List.assoc key !__groups3 with Not_found -> [] in
            __groups3 := (key, cs1 :: cur) :: List.remove_assoc key !__groups3);
                    ) call_center;
            ) customer_address;
      ) date_dim;
  ) catalog_sales;
  let __res3 = ref [] in
  List.iter (fun ((gKey : (Obj.t * Obj.t) list), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res3 := { order_count = List.length distinct (let __res4 = ref [] in
  List.iter (fun x ->
      __res4 := x.cs_order_number :: !__res4;
  ) g.items;
List.rev !__res4)
; total_shipping_cost = (sum_float (let __res5 = ref [] in
  List.iter (fun x ->
      __res5 := x.cs_ext_ship_cost :: !__res5;
  ) g.items;
List.rev !__res5)
); total_net_profit = (sum_float (let __res6 = ref [] in
  List.iter (fun x ->
      __res6 := x.cs_net_profit :: !__res6;
  ) g.items;
List.rev !__res6)
) } :: !__res3
  ) !__groups3;
  List.rev !__res3)


  let () =
    json filtered;
    assert ((filtered = [{ order_count = 1; total_shipping_cost = 5.; total_net_profit = 20. }]))
