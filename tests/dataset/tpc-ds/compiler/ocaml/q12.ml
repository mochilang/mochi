(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:16Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable ws_item_sk : int; mutable ws_sold_date_sk : int; mutable ws_ext_sales_price : float }
type record2 = { mutable i_item_sk : int; mutable i_item_id : string; mutable i_item_desc : string; mutable i_category : string; mutable i_class : string; mutable i_current_price : float }
type record3 = { mutable d_date_sk : int; mutable d_date : string }
type record4 = { mutable id : string; mutable desc : string; mutable cat : string; mutable class : string; mutable price : float }
type record5 = { mutable i_item_id : Obj.t; mutable i_item_desc : Obj.t; mutable i_category : Obj.t; mutable i_class : Obj.t; mutable i_current_price : Obj.t; mutable itemrevenue : float }
type record6 = { mutable i_item_id : string; mutable i_item_desc : string; mutable i_category : string; mutable i_class : string; mutable i_current_price : float; mutable itemrevenue : float }
type record7 = { mutable class : Obj.t; mutable total : float }
type record8 = { mutable class : string; mutable total : float }
type record9 = { mutable i_item_id : string; mutable i_item_desc : string; mutable i_category : string; mutable i_class : string; mutable i_current_price : float; mutable itemrevenue : float; mutable revenueratio : float }

type websale = { mutable ws_item_sk : int; mutable ws_sold_date_sk : int; mutable ws_ext_sales_price : float }
type item = { mutable i_item_sk : int; mutable i_item_id : string; mutable i_item_desc : string; mutable i_category : string; mutable i_class : string; mutable i_current_price : float }
type datedim = { mutable d_date_sk : int; mutable d_date : string }
let web_sales : record1 list = [{ ws_item_sk = 1; ws_sold_date_sk = 1; ws_ext_sales_price = 100. };{ ws_item_sk = 1; ws_sold_date_sk = 2; ws_ext_sales_price = 100. };{ ws_item_sk = 2; ws_sold_date_sk = 2; ws_ext_sales_price = 200. };{ ws_item_sk = 3; ws_sold_date_sk = 3; ws_ext_sales_price = 50. }]
let item : record2 list = [{ i_item_sk = 1; i_item_id = "ITEM1"; i_item_desc = "Item One"; i_category = "A"; i_class = "C1"; i_current_price = 10. };{ i_item_sk = 2; i_item_id = "ITEM2"; i_item_desc = "Item Two"; i_category = "A"; i_class = "C1"; i_current_price = 20. };{ i_item_sk = 3; i_item_id = "ITEM3"; i_item_desc = "Item Three"; i_category = "B"; i_class = "C2"; i_current_price = 30. }]
let date_dim : record3 list = [{ d_date_sk = 1; d_date = "2001-01-20" };{ d_date_sk = 2; d_date = "2001-02-05" };{ d_date_sk = 3; d_date = "2001-03-05" }]
let filtered : record6 list = (let (__groups0 : (record4 * record1 list) list ref) = ref [] in
  List.iter (fun (ws : record1) ->
      List.iter (fun (i : record2) ->
            List.iter (fun (d : record3) ->
                        if (ws.ws_item_sk = i.i_item_sk) && (ws.ws_sold_date_sk = d.d_date_sk) && (((List.mem i.i_category ["A";"B";"C"]) && (d.d_date >= "2001-01-15")) && (d.d_date <= "2001-02-14")) then (
          let (key : record4) = { id = i.i_item_id; desc = i.i_item_desc; cat = i.i_category; class = i.i_class; price = i.i_current_price } in
          let cur = try List.assoc key !__groups0 with Not_found -> [] in
          __groups0 := (key, ws :: cur) :: List.remove_assoc key !__groups0);
            ) date_dim;
      ) item;
  ) web_sales;
  let __res0 = ref [] in
  List.iter (fun ((gKey : record4), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { i_item_id = g.key.id; i_item_desc = g.key.desc; i_category = g.key.cat; i_class = g.key.class; i_current_price = g.key.price; itemrevenue = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.ws_ext_sales_price :: !__res1;
  ) g.items;
List.rev !__res1)
) } :: !__res0
  ) !__groups0;
  List.rev !__res0)

let class_totals : record8 list = (let (__groups2 : (string * record6 list) list ref) = ref [] in
  List.iter (fun (f : record6) ->
      let (key : string) = f.i_class in
      let cur = try List.assoc key !__groups2 with Not_found -> [] in
      __groups2 := (key, f :: cur) :: List.remove_assoc key !__groups2;
  ) filtered;
  let __res2 = ref [] in
  List.iter (fun ((gKey : string), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res2 := { class = g.key; total = (sum_float (let __res3 = ref [] in
  List.iter (fun x ->
      __res3 := x.itemrevenue :: !__res3;
  ) g.items;
List.rev !__res3)
) } :: !__res2
  ) !__groups2;
  List.rev !__res2)

let result : record9 list = (let __res4 = ref [] in
  List.iter (fun f ->
    List.iter (fun t ->
      if (f.i_class = t.class) then (
        __res4 := { i_item_id = f.i_item_id; i_item_desc = f.i_item_desc; i_category = f.i_category; i_class = f.i_class; i_current_price = f.i_current_price; itemrevenue = f.itemrevenue; revenueratio = (((f.itemrevenue *. 100.)) /. t.total) } :: !__res4;
      )
    ) class_totals;
  ) filtered;
  List.rev !__res4)


let () =
  json result;
  assert ((result = [{ i_item_id = "ITEM1"; i_item_desc = "Item One"; i_category = "A"; i_class = "C1"; i_current_price = 10.; itemrevenue = 200.; revenueratio = 50. };{ i_item_id = "ITEM2"; i_item_desc = "Item Two"; i_category = "A"; i_class = "C1"; i_current_price = 20.; itemrevenue = 200.; revenueratio = 50. }]))
