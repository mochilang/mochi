(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:17Z *)
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable ss_customer_sk : int; mutable ss_item_sk : int }
type record2 = { mutable cs_bill_customer_sk : int; mutable cs_item_sk : int }
type record3 = { mutable customer_sk : int; mutable item_sk : int }
type record4 = { mutable customer_sk : Obj.t; mutable item_sk : Obj.t }
type record5 = { mutable store_only : int; mutable catalog_only : int; mutable store_and_catalog : int }

type storesale = { mutable ss_customer_sk : int; mutable ss_item_sk : int }
type catalogsale = { mutable cs_bill_customer_sk : int; mutable cs_item_sk : int }
let store_sales : record1 list = [{ ss_customer_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 2; ss_item_sk = 1 }]
let catalog_sales : record2 list = [{ cs_bill_customer_sk = 1; cs_item_sk = 1 };{ cs_bill_customer_sk = 3; cs_item_sk = 2 }]
let ssci : record3 list = (let (__groups0 : (record3 * record1 list) list ref) = ref [] in
  List.iter (fun (ss : record1) ->
      let (key : record3) = { customer_sk = ss.ss_customer_sk; item_sk = ss.ss_item_sk } in
      let cur = try List.assoc key !__groups0 with Not_found -> [] in
      __groups0 := (key, ss :: cur) :: List.remove_assoc key !__groups0;
  ) store_sales;
  let __res0 = ref [] in
  List.iter (fun ((gKey : record3), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { customer_sk = g.key.customer_sk; item_sk = g.key.item_sk } :: !__res0
  ) !__groups0;
  List.rev !__res0)

let csci : record3 list = (let (__groups1 : (record3 * record2 list) list ref) = ref [] in
  List.iter (fun (cs : record2) ->
      let (key : record3) = { customer_sk = cs.cs_bill_customer_sk; item_sk = cs.cs_item_sk } in
      let cur = try List.assoc key !__groups1 with Not_found -> [] in
      __groups1 := (key, cs :: cur) :: List.remove_assoc key !__groups1;
  ) catalog_sales;
  let __res1 = ref [] in
  List.iter (fun ((gKey : record3), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res1 := { customer_sk = g.key.customer_sk; item_sk = g.key.item_sk } :: !__res1
  ) !__groups1;
  List.rev !__res1)

let both : int = List.length (let __res2 = ref [] in
  List.iter (fun s ->
    List.iter (fun c ->
      if ((s.customer_sk = c.customer_sk) && (s.item_sk = c.item_sk)) then (
        __res2 := 1 :: !__res2;
      )
    ) csci;
  ) ssci;
  List.rev !__res2)

let store_only : int = List.length (let __res4 = ref [] in
  List.iter (fun (s : record3) ->
      if not ((((let __res3 = ref [] in
  List.iter (fun (c : record3) ->
      if ((s.customer_sk = c.customer_sk) && (s.item_sk = c.item_sk)) then
    __res3 := c :: !__res3;
  ) csci;
List.rev !__res3)
 <> []))) then
    __res4 := 1 :: !__res4;
  ) ssci;
List.rev !__res4)

let catalog_only : int = List.length (let __res6 = ref [] in
  List.iter (fun (c : record3) ->
      if not ((((let __res5 = ref [] in
  List.iter (fun (s : record3) ->
      if ((s.customer_sk = c.customer_sk) && (s.item_sk = c.item_sk)) then
    __res5 := s :: !__res5;
  ) ssci;
List.rev !__res5)
 <> []))) then
    __res6 := 1 :: !__res6;
  ) csci;
List.rev !__res6)

let result : record5 = { store_only = store_only; catalog_only = catalog_only; store_and_catalog = both }

let () =
  json result;
  assert ((((Obj.obj (List.assoc "store_only" result) = 1) && (Obj.obj (List.assoc "catalog_only" result) = 1)) && (Obj.obj (List.assoc "store_and_catalog" result) = 1)))
