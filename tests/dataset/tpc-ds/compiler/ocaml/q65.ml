(* Generated by Mochi compiler v0.10.26 on 2025-07-15T06:39:42Z *)
  exception Break
  exception Continue

  let sum lst = List.fold_left (+) 0 lst
  let sum_float lst = List.fold_left (+.) 0.0 lst
  type ('k,'v) group = { key : 'k; items : 'v list }

  type record1 = { mutable store : int; mutable item : int; mutable price : int }
  type record2 = { mutable item : int }
  type record3 = { mutable item : Obj.t; mutable revenue : float }
  type record4 = { mutable item : int; mutable revenue : float }

let store_sales : record1 list = [{ store = 1; item = 1; price = 1 };{ store = 1; item = 1; price = 1 };{ store = 1; item = 2; price = 60 }]
let rec average (xs : float list) : float =
  if (List.length xs = 0) then (
    0.
  ) ;
  let sum : Obj.t -> float ref = ref 0. in
  let rec __loop0 lst =
    match lst with
      | [] -> ()
      | x::rest ->
        (try
          sum := ((!sum) + x);
        with Continue -> ())
        ; __loop0 rest
    in
    try __loop0 xs with Break -> ()
    ((!sum) /. (float_of_int List.length xs))

  let item_revenue : record4 list = (let (__groups1 : (record2 * record1 list) list ref) = ref [] in
  List.iter (fun (ss : record1) ->
      let (key : record2) = [("item",Obj.repr (ss.item))] in
      let cur = try List.assoc key !__groups1 with Not_found -> [] in
      __groups1 := (key, ss :: cur) :: List.remove_assoc key !__groups1;
  ) store_sales;
  let __res1 = ref [] in
  List.iter (fun ((gKey : record2), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res1 := { item = g.key.item; revenue = (sum_float (let __res2 = ref [] in
  List.iter (fun x ->
      __res2 := x.price :: !__res2;
  ) g.items;
List.rev !__res2)
) } :: !__res1
  ) !__groups1;
  List.rev !__res1)

  let avg_rev : float = average (let __res3 = ref [] in
  List.iter (fun (ir : record4) ->
      __res3 := ir.revenue :: !__res3;
  ) item_revenue;
List.rev !__res3)

  let low_rev : Obj.t list = (let __res4 = ref [] in
  List.iter (fun (ir : record4) ->
      if ((ir.revenue <= 0.1) *. avg_rev) then
    __res4 := ir.revenue :: !__res4;
  ) item_revenue;
List.rev !__res4)

  let result : float = ((sum_float low_rev) +. 63)

  let () =
    json result;
    assert ((result = 65))
