(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:16Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable order : int; mutable item_sk : int; mutable warehouse_sk : int; mutable date_sk : int; mutable price : float }
type record2 = { mutable order : int; mutable item_sk : int; mutable refunded : float }
type record3 = { mutable item_sk : int; mutable item_id : string; mutable current_price : float }
type record4 = { mutable warehouse_sk : int; mutable state : string }
type record5 = { mutable date_sk : int; mutable date : string }
type record6 = { mutable w_state : string; mutable i_item_id : string; mutable sold_date : string; mutable net : float }
type record7 = { mutable w_state : string; mutable i_item_id : string }
type record8 = { mutable w_state : Obj.t; mutable i_item_id : Obj.t; mutable sales_before : float; mutable sales_after : float }
type record9 = { mutable w_state : string; mutable i_item_id : string; mutable sales_before : float; mutable sales_after : float }

let catalog_sales : record1 list = [{ order = 1; item_sk = 1; warehouse_sk = 1; date_sk = 1; price = 100. };{ order = 2; item_sk = 1; warehouse_sk = 1; date_sk = 2; price = 150. }]
let catalog_returns : record2 list = [{ order = 2; item_sk = 1; refunded = 150. }]
let item : record3 list = [{ item_sk = 1; item_id = "I1"; current_price = 1.2 }]
let warehouse : record4 list = [{ warehouse_sk = 1; state = "CA" }]
let date_dim : record5 list = [{ date_sk = 1; date = "2020-01-10" };{ date_sk = 2; date = "2020-01-20" }]
let sales_date : string = "2020-01-15"
let records : record6 list = (let __res0 = ref [] in
  List.iter (fun (cs : record1) ->
      List.iter (fun (cr : record2) ->
            List.iter (fun (w : record4) ->
                    List.iter (fun (i : record3) ->
                              List.iter (fun (d : record5) ->
                                                  if ((cs.order = cr.order) && (cs.item_sk = cr.item_sk)) && (cs.warehouse_sk = w.warehouse_sk) && (cs.item_sk = i.item_sk) && (cs.date_sk = d.date_sk) && ((i.current_price >= 0.99) && (i.current_price <= 1.49)) then
            __res0 := { w_state = w.state; i_item_id = i.item_id; sold_date = d.date; net = (cs.price -. ((if (cr = ()) then 0. else cr.refunded))) } :: !__res0;
                              ) date_dim;
                    ) item;
            ) warehouse;
      ) catalog_returns;
  ) catalog_sales;
List.rev !__res0)

let result : record9 list = (let (__groups1 : (record7 * record6 list) list ref) = ref [] in
  List.iter (fun (r : record6) ->
      let (key : record7) = { w_state = r.w_state; i_item_id = r.i_item_id } in
      let cur = try List.assoc key !__groups1 with Not_found -> [] in
      __groups1 := (key, r :: cur) :: List.remove_assoc key !__groups1;
  ) records;
  let __res1 = ref [] in
  List.iter (fun ((gKey : record7), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res1 := { w_state = g.key.w_state; i_item_id = g.key.i_item_id; sales_before = (sum_float (let __res2 = ref [] in
  List.iter (fun x ->
      __res2 := (if (x.sold_date < sales_date) then x.net else 0.) :: !__res2;
  ) g.items;
List.rev !__res2)
); sales_after = (sum_float (let __res3 = ref [] in
  List.iter (fun x ->
      __res3 := (if (x.sold_date >= sales_date) then x.net else 0.) :: !__res3;
  ) g.items;
List.rev !__res3)
) } :: !__res1
  ) !__groups1;
  List.rev !__res1)


let () =
  json result;
  assert ((result = [{ w_state = "CA"; i_item_id = "I1"; sales_before = 100.; sales_after = 0. }]))
