(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:17Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable s_store_sk : int; mutable s_state : string; mutable s_county : string }
type record2 = { mutable d_date_sk : int; mutable d_month_seq : int }
type record3 = { mutable ss_sold_date_sk : int; mutable ss_store_sk : int; mutable ss_net_profit : float }
type record4 = { mutable state : string; mutable county : string }
type record5 = { mutable s_state : Obj.t; mutable s_county : Obj.t; mutable total_sum : float }
type record6 = { mutable s_state : string; mutable s_county : string; mutable total_sum : float }

let store : record1 list = [{ s_store_sk = 1; s_state = "CA"; s_county = "Orange" };{ s_store_sk = 2; s_state = "CA"; s_county = "Orange" };{ s_store_sk = 3; s_state = "TX"; s_county = "Travis" }]
let date_dim : record2 list = [{ d_date_sk = 1; d_month_seq = 1200 };{ d_date_sk = 2; d_month_seq = 1201 }]
let store_sales : record3 list = [{ ss_sold_date_sk = 1; ss_store_sk = 1; ss_net_profit = 10. };{ ss_sold_date_sk = 1; ss_store_sk = 2; ss_net_profit = 5. };{ ss_sold_date_sk = 2; ss_store_sk = 3; ss_net_profit = 20. }]
let dms : int = 1200
let result : record6 list = (let (__groups0 : (record4 * record3 list) list ref) = ref [] in
  List.iter (fun (ss : record3) ->
      List.iter (fun (d : record2) ->
            List.iter (fun (s : record1) ->
                        if (d.d_date_sk = ss.ss_sold_date_sk) && (s.s_store_sk = ss.ss_store_sk) && (((d.d_month_seq >= dms) && (d.d_month_seq <= dms)) + 11) then (
          let (key : record4) = { state = s.s_state; county = s.s_county } in
          let cur = try List.assoc key !__groups0 with Not_found -> [] in
          __groups0 := (key, ss :: cur) :: List.remove_assoc key !__groups0);
            ) store;
      ) date_dim;
  ) store_sales;
  let __res0 = ref [] in
  List.iter (fun ((gKey : record4), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { s_state = g.key.state; s_county = g.key.county; total_sum = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.ss.ss_net_profit :: !__res1;
  ) g.items;
List.rev !__res1)
) } :: !__res0
  ) !__groups0;
  List.rev !__res0)


let () =
  json result;
  assert ((result = [{ s_state = "CA"; s_county = "Orange"; total_sum = 15. };{ s_state = "TX"; s_county = "Travis"; total_sum = 20. }]))
