(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:15Z *)
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable ca_address_sk : int; mutable ca_state : string; mutable ca_zip : string }
type record2 = { mutable c_customer_sk : int; mutable c_current_addr_sk : int }
type record3 = { mutable ss_customer_sk : int; mutable ss_sold_date_sk : int; mutable ss_item_sk : int }
type record4 = { mutable d_date_sk : int; mutable d_year : int; mutable d_moy : int; mutable d_month_seq : int }
type record5 = { mutable i_item_sk : int; mutable i_category : string; mutable i_current_price : float }
type record6 = { mutable state : Obj.t; mutable cnt : int }
type record7 = { mutable state : string; mutable cnt : int }

let customer_address : record1 list = [{ ca_address_sk = 1; ca_state = "CA"; ca_zip = "12345" }]
let customer : record2 list = [{ c_customer_sk = 1; c_current_addr_sk = 1 }]
let store_sales : record3 list = [{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 };{ ss_customer_sk = 1; ss_sold_date_sk = 1; ss_item_sk = 1 }]
let date_dim : record4 list = [{ d_date_sk = 1; d_year = 1999; d_moy = 5; d_month_seq = 120 }]
let item : record5 list = [{ i_item_sk = 1; i_category = "A"; i_current_price = 100. };{ i_item_sk = 2; i_category = "A"; i_current_price = 50. }]
let target_month_seq : int = max (let __res0 = ref [] in
  List.iter (fun (d : record4) ->
      if ((d.d_year = 1999) && (d.d_moy = 5)) then
    __res0 := d.d_month_seq :: !__res0;
  ) date_dim;
List.rev !__res0)

let result : record7 list = (let (__groups2 : (string * record1 list) list ref) = ref [] in
  List.iter (fun (a : record1) ->
      List.iter (fun (c : record2) ->
            List.iter (fun (s : record3) ->
                    List.iter (fun (d : record4) ->
                              List.iter (fun (i : record5) ->
                                                  if (a.ca_address_sk = c.c_current_addr_sk) && (c.c_customer_sk = s.ss_customer_sk) && (s.ss_sold_date_sk = d.d_date_sk) && (s.ss_item_sk = i.i_item_sk) && (((d.d_month_seq = target_month_seq) && (i.i_current_price > 1.2)) *. (float_of_int (List.fold_left (+) 0 (let __res1 = ref [] in
  List.iter (fun (j : record5) ->
      if (j.i_category = i.i_category) then
    __res1 := j.i_current_price :: !__res1;
  ) item;
List.rev !__res1)
) /. float_of_int (List.length (let __res1 = ref [] in
  List.iter (fun (j : record5) ->
      if (j.i_category = i.i_category) then
    __res1 := j.i_current_price :: !__res1;
  ) item;
List.rev !__res1)
))) then (
              let (key : string) = a.ca_state in
              let cur = try List.assoc key !__groups2 with Not_found -> [] in
              __groups2 := (key, a :: cur) :: List.remove_assoc key !__groups2);
                              ) item;
                    ) date_dim;
            ) store_sales;
      ) customer;
  ) customer_address;
  let __res2 = ref [] in
  List.iter (fun ((gKey : string), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res2 := { state = g.key; cnt = List.length g.items } :: !__res2
  ) !__groups2;
  List.rev !__res2)


let () =
  json result;
  assert ((result = [{ state = "CA"; cnt = 10 }]))
