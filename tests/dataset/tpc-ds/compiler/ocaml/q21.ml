(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:16Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable inv_item_sk : int; mutable inv_warehouse_sk : int; mutable inv_date_sk : int; mutable inv_quantity_on_hand : int }
type record2 = { mutable w_warehouse_sk : int; mutable w_warehouse_name : string }
type record3 = { mutable i_item_sk : int; mutable i_item_id : string }
type record4 = { mutable d_date_sk : int; mutable d_date : string }
type record5 = { mutable w : int; mutable i : int }
type record6 = { mutable w : Obj.t; mutable i : Obj.t; mutable qty : float }
type record7 = { mutable w : int; mutable i : int; mutable qty : float }
type record8 = { mutable w_name : string; mutable i_id : string; mutable before_qty : float; mutable after_qty : float; mutable ratio : float }
type record9 = { mutable w_warehouse_name : string; mutable i_item_id : string; mutable inv_before : float; mutable inv_after : float }
type record10 = { mutable w_warehouse_name : string; mutable i_item_id : string; mutable inv_before : int; mutable inv_after : int }

type inventory = { mutable inv_item_sk : int; mutable inv_warehouse_sk : int; mutable inv_date_sk : int; mutable inv_quantity_on_hand : int }
type warehouse = { mutable w_warehouse_sk : int; mutable w_warehouse_name : string }
type item = { mutable i_item_sk : int; mutable i_item_id : string }
type datedim = { mutable d_date_sk : int; mutable d_date : string }
let inventory : record1 list = [{ inv_item_sk = 1; inv_warehouse_sk = 1; inv_date_sk = 1; inv_quantity_on_hand = 30 };{ inv_item_sk = 1; inv_warehouse_sk = 1; inv_date_sk = 2; inv_quantity_on_hand = 40 };{ inv_item_sk = 2; inv_warehouse_sk = 2; inv_date_sk = 1; inv_quantity_on_hand = 20 };{ inv_item_sk = 2; inv_warehouse_sk = 2; inv_date_sk = 2; inv_quantity_on_hand = 20 }]
let warehouse : record2 list = [{ w_warehouse_sk = 1; w_warehouse_name = "Main" };{ w_warehouse_sk = 2; w_warehouse_name = "Backup" }]
let item : record3 list = [{ i_item_sk = 1; i_item_id = "ITEM1" };{ i_item_sk = 2; i_item_id = "ITEM2" }]
let date_dim : record4 list = [{ d_date_sk = 1; d_date = "2000-03-01" };{ d_date_sk = 2; d_date = "2000-03-20" }]
let before : record7 list = (let (__groups0 : (record5 * record1 list) list ref) = ref [] in
  List.iter (fun (inv : record1) ->
      List.iter (fun (d : record4) ->
              if (inv.inv_date_sk = d.d_date_sk) && (d.d_date < "2000-03-15") then (
        let (key : record5) = { w = inv.inv_warehouse_sk; i = inv.inv_item_sk } in
        let cur = try List.assoc key !__groups0 with Not_found -> [] in
        __groups0 := (key, inv :: cur) :: List.remove_assoc key !__groups0);
      ) date_dim;
  ) inventory;
  let __res0 = ref [] in
  List.iter (fun ((gKey : record5), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { w = g.key.w; i = g.key.i; qty = (sum_float (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.inv_quantity_on_hand :: !__res1;
  ) g.items;
List.rev !__res1)
) } :: !__res0
  ) !__groups0;
  List.rev !__res0)

let after : record7 list = (let (__groups2 : (record5 * record1 list) list ref) = ref [] in
  List.iter (fun (inv : record1) ->
      List.iter (fun (d : record4) ->
              if (inv.inv_date_sk = d.d_date_sk) && (d.d_date >= "2000-03-15") then (
        let (key : record5) = { w = inv.inv_warehouse_sk; i = inv.inv_item_sk } in
        let cur = try List.assoc key !__groups2 with Not_found -> [] in
        __groups2 := (key, inv :: cur) :: List.remove_assoc key !__groups2);
      ) date_dim;
  ) inventory;
  let __res2 = ref [] in
  List.iter (fun ((gKey : record5), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res2 := { w = g.key.w; i = g.key.i; qty = (sum_float (let __res3 = ref [] in
  List.iter (fun x ->
      __res3 := x.inv_quantity_on_hand :: !__res3;
  ) g.items;
List.rev !__res3)
) } :: !__res2
  ) !__groups2;
  List.rev !__res2)

let joined : record8 list = (let __res4 = ref [] in
  List.iter (fun (b : record7) ->
      List.iter (fun (a : record7) ->
            List.iter (fun (w : record2) ->
                    List.iter (fun (it : record3) ->
                                    if ((b.w = a.w) && (b.i = a.i)) && (w.w_warehouse_sk = b.w) && (it.i_item_sk = b.i) then
          __res4 := { w_name = w.w_warehouse_name; i_id = it.i_item_id; before_qty = b.qty; after_qty = a.qty; ratio = (a.qty /. b.qty) } :: !__res4;
                    ) item;
            ) warehouse;
      ) after;
  ) before;
List.rev !__res4)

let result : record9 list = (let __res5 = ref [] in
  List.iter (fun (r : record8) ->
      if ((r.ratio >= ((2. /. 3.))) && (r.ratio <= ((3. /. 2.)))) then
    __res5 := { w_warehouse_name = r.w_name; i_item_id = r.i_id; inv_before = r.before_qty; inv_after = r.after_qty } :: !__res5;
  ) joined;
List.rev !__res5)


let () =
  json result;
  assert ((result = [{ w_warehouse_name = "Backup"; i_item_id = "ITEM2"; inv_before = 20; inv_after = 20 };{ w_warehouse_name = "Main"; i_item_id = "ITEM1"; inv_before = 30; inv_after = 40 }]))
