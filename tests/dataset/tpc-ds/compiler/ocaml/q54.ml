(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:17Z *)
let sum lst = List.fold_left (+) 0 lst
let sum_float lst = List.fold_left (+.) 0.0 lst
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable customer : int; mutable sold_date : int; mutable price : float }
type record2 = { mutable d_date_sk : int; mutable d_month_seq : int }
type record3 = { mutable c_customer_sk : int; mutable c_current_addr_sk : int }
type record4 = { mutable ca_address_sk : int; mutable ca_county : string; mutable ca_state : string }
type record5 = { mutable s_store_sk : int; mutable s_county : string; mutable s_state : string }
type record6 = { mutable customer : int; mutable amt : float }
type record7 = { mutable customer : Obj.t; mutable revenue : float }
type record8 = { mutable customer : int; mutable revenue : float }
type record9 = { mutable seg : int }
type record10 = { mutable segment : Obj.t; mutable num_customers : int; mutable segment_base : Obj.t }
type record11 = { mutable segment : int; mutable num_customers : int; mutable segment_base : int }

let store_sales : record1 list = [{ customer = 1; sold_date = 2; price = 60. };{ customer = 2; sold_date = 2; price = 40. }]
let date_dim : record2 list = [{ d_date_sk = 2; d_month_seq = 5 }]
let customer : record3 list = [{ c_customer_sk = 1; c_current_addr_sk = 1 };{ c_customer_sk = 2; c_current_addr_sk = 1 }]
let customer_address : record4 list = [{ ca_address_sk = 1; ca_county = "X"; ca_state = "Y" }]
let store : record5 list = [{ s_store_sk = 1; s_county = "X"; s_state = "Y" }]
let rec int (x : float) : int =
  int_of_string x

let revenue : record6 list = (let __res0 = ref [] in
  List.iter (fun (ss : record1) ->
      List.iter (fun (d : record2) ->
            List.iter (fun (c : record3) ->
                    List.iter (fun (ca : record4) ->
                              List.iter (fun (s : record5) ->
                                                  if (ss.sold_date = d.d_date_sk) && (ss.customer = c.c_customer_sk) && (((c.c_current_addr_sk = ca.ca_address_sk) && (ca.ca_county = "X")) && (ca.ca_state = "Y")) && (((1 = s.s_store_sk) && (ca.ca_county = s.s_county)) && (ca.ca_state = s.s_state)) then
            __res0 := { customer = c.c_customer_sk; amt = ss.price } :: !__res0;
                              ) store;
                    ) customer_address;
            ) customer;
      ) date_dim;
  ) store_sales;
List.rev !__res0)

let by_customer : record8 list = (let (__groups1 : (int * record6 list) list ref) = ref [] in
  List.iter (fun (r : record6) ->
      let (key : int) = r.customer in
      let cur = try List.assoc key !__groups1 with Not_found -> [] in
      __groups1 := (key, r :: cur) :: List.remove_assoc key !__groups1;
  ) revenue;
  let __res1 = ref [] in
  List.iter (fun ((gKey : int), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res1 := { customer = g.key; revenue = (sum_float (let __res2 = ref [] in
  List.iter (fun x ->
      __res2 := x.amt :: !__res2;
  ) g.items;
List.rev !__res2)
) } :: !__res1
  ) !__groups1;
  List.rev !__res1)

let segments : record11 list = (let (__groups3 : (record9 * record8 list) list ref) = ref [] in
  List.iter (fun (r : record8) ->
      let (key : record9) = [("seg",Obj.repr (int (r.revenue /. 50)))] in
      let cur = try List.assoc key !__groups3 with Not_found -> [] in
      __groups3 := (key, r :: cur) :: List.remove_assoc key !__groups3;
  ) by_customer;
  let __res3 = ref [] in
  List.iter (fun ((gKey : record9), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res3 := { segment = g.key.seg; num_customers = List.length g.items; segment_base = (g.key.seg * 50) } :: !__res3
  ) !__groups3;
  List.rev !__res3)

let result : (string * Obj.t) list list = segments

let () =
  json result;
  assert ((result = [{ segment = 1; num_customers = 1; segment_base = 50 };{ segment = 0; num_customers = 1; segment_base = 0 }]))
