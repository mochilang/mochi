(* Generated by Mochi compiler v0.10.25 on 2025-07-15T04:50:17Z *)
type ('k,'v) group = { key : 'k; items : 'v list }

type record1 = { mutable ss_item_sk : int; mutable ss_store_sk : int; mutable ss_net_profit : float }
type record2 = { mutable i_item_sk : int; mutable i_product_name : string }
type record3 = { mutable item_sk : Obj.t; mutable avg_profit : float }
type record4 = { mutable best_performing : Obj.t; mutable worst_performing : Obj.t }
type record5 = { mutable best_performing : string; mutable worst_performing : string }

let store_sales : record1 list = [{ ss_item_sk = 1; ss_store_sk = 1; ss_net_profit = 5. };{ ss_item_sk = 1; ss_store_sk = 1; ss_net_profit = 5. };{ ss_item_sk = 2; ss_store_sk = 1; ss_net_profit = -1. }]
let item : record2 list = [{ i_item_sk = 1; i_product_name = "ItemA" };{ i_item_sk = 2; i_product_name = "ItemB" }]
let grouped_base : record3 list = ((let (__groups0 : (int * record1 list) list ref) = ref [] in
  List.iter (fun (ss : record1) ->
      let (key : int) = ss.ss_item_sk in
      let cur = try List.assoc key !__groups0 with Not_found -> [] in
      __groups0 := (key, ss :: cur) :: List.remove_assoc key !__groups0;
  ) store_sales;
  let __res0 = ref [] in
  List.iter (fun ((gKey : int), gItems) ->
    let g = { key = gKey; items = List.rev gItems } in
    __res0 := { item_sk = g.key; avg_profit = (List.fold_left (+.) 0.0 (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.ss_net_profit :: !__res1;
  ) g.items;
List.rev !__res1)
 /. float_of_int (List.length (let __res1 = ref [] in
  List.iter (fun x ->
      __res1 := x.ss_net_profit :: !__res1;
  ) g.items;
List.rev !__res1)
)) } :: !__res0
  ) !__groups0;
  List.rev !__res0)
)
let grouped : (string * Obj.t) list list = grouped_base
let best : (string * Obj.t) list = first (let __res2 = ref [] in
  List.iter (fun x ->
      __res2 := x :: !__res2;
  ) grouped;
List.rev !__res2)

let worst : (string * Obj.t) list = first (let __res3 = ref [] in
  List.iter (fun x ->
      __res3 := x :: !__res3;
  ) grouped;
List.rev !__res3)

let best_name = first (let __res4 = ref [] in
  List.iter (fun (i : record2) ->
      if (i.i_item_sk = best.item_sk) then
    __res4 := i.i_product_name :: !__res4;
  ) item;
List.rev !__res4)

let worst_name = first (let __res5 = ref [] in
  List.iter (fun (i : record2) ->
      if (i.i_item_sk = worst.item_sk) then
    __res5 := i.i_product_name :: !__res5;
  ) item;
List.rev !__res5)

let result : record4 = { best_performing = best_name; worst_performing = worst_name }

let () =
  json result;
  assert ((result = { best_performing = "ItemA"; worst_performing = "ItemB" }))
