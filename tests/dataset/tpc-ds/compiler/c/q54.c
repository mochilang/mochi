// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  double *data;
} list_float;
static list_float list_float_create(int len) {
  list_float l;
  l.len = len;
  l.data = calloc(len, sizeof(double));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static double _sum_float(list_float v) {
  double sum = 0;
  for (int i = 0; i < v.len; i++)
    sum += v.data[i];
  return sum;
}
static void _json_int(int v) { printf("%d", v); }
static void _json_float(double v) { printf("%g", v); }
static void _json_string(char *s) { printf("\"%s\"", s); }
static void _json_list_int(list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_int(v.data[i]);
  }
  printf("]");
}
static void _json_list_float(list_float v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_float(v.data[i]);
  }
  printf("]");
}
static void _json_list_string(list_string v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_string(v.data[i]);
  }
  printf("]");
}
static void _json_list_list_int(list_list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_list_int(v.data[i]);
  }
  printf("]");
}
typedef struct {
  int key;
  list_int items;
} _GroupInt;
typedef struct {
  int len;
  int cap;
  _GroupInt *data;
} list_group_int;
static list_group_int _group_by_int(list_int src) {
  list_group_int res;
  res.len = 0;
  res.cap = 0;
  res.data = NULL;
  for (int i = 0; i < src.len; i++) {
    int key = src.data[i];
    int idx = -1;
    for (int j = 0; j < res.len; j++)
      if (res.data[j].key == key) {
        idx = j;
        break;
      }
    if (idx == -1) {
      if (res.len >= res.cap) {
        res.cap = res.cap ? res.cap * 2 : 4;
        res.data = (_GroupInt *)realloc(res.data, sizeof(_GroupInt) * res.cap);
      }
      res.data[res.len].key = key;
      res.data[res.len].items = list_int_create(0);
      idx = res.len++;
    }
    _GroupInt *g = &res.data[idx];
    g->items.data =
        (int *)realloc(g->items.data, sizeof(int) * (g->items.len + 1));
    g->items.data[g->items.len++] = src.data[i];
  }
  return res;
}
typedef struct {
  int segment;
  int num_customers;
  int segment_base;
} tmp1_t;
typedef struct {
  int len;
  tmp1_t *data;
} tmp1_list_t;
tmp1_list_t create_tmp1_list(int len) {
  tmp1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int segment;
  int num_customers;
  int segment_base;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int customer;
  int sold_date;
  double price;
} store_sale_t;
typedef struct {
  int len;
  store_sale_t *data;
} store_sale_list_t;
store_sale_list_t create_store_sale_list(int len) {
  store_sale_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(store_sale_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int d_date_sk;
  int d_month_seq;
} date_dim_t;
typedef struct {
  int len;
  date_dim_t *data;
} date_dim_list_t;
date_dim_list_t create_date_dim_list(int len) {
  date_dim_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(date_dim_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int c_customer_sk;
  int c_current_addr_sk;
} customer_t;
typedef struct {
  int len;
  customer_t *data;
} customer_list_t;
customer_list_t create_customer_list(int len) {
  customer_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(customer_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int ca_address_sk;
  const char *ca_county;
  const char *ca_state;
} customer_addres_t;
typedef struct {
  int len;
  customer_addres_t *data;
} customer_addres_list_t;
customer_addres_list_t create_customer_addres_list(int len) {
  customer_addres_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(customer_addres_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int s_store_sk;
  const char *s_county;
  const char *s_state;
} store_t;
typedef struct {
  int len;
  store_t *data;
} store_list_t;
store_list_t create_store_list(int len) {
  store_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(store_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int customer;
  double amt;
} revenue_item_t;
typedef struct {
  int len;
  revenue_item_t *data;
} revenue_item_list_t;
revenue_item_list_t create_revenue_item_list(int len) {
  revenue_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(revenue_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int customer;
  double revenue;
} by_customer_item_t;
typedef struct {
  int len;
  by_customer_item_t *data;
} by_customer_item_list_t;
by_customer_item_list_t create_by_customer_item_list(int len) {
  by_customer_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(by_customer_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int segment;
  int num_customers;
  int segment_base;
} segments_item_t;
typedef struct {
  int len;
  segments_item_t *data;
} segments_item_list_t;
segments_item_list_t create_segments_item_list(int len) {
  segments_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(segments_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int _int(double x) { return (int)(x); }

static int test_TPCDS_Q54_simplified_result;
static void test_TPCDS_Q54_simplified() {
  tmp1_t tmp1[] = {
      (tmp1_t){.segment = 1, .num_customers = 1, .segment_base = 50},
      (tmp_item_t){.segment = 0, .num_customers = 1, .segment_base = 0}};
  int tmp1_len = sizeof(tmp1) / sizeof(tmp1[0]);
  int tmp2 = 1;
  if (test_TPCDS_Q54_simplified_result.len != tmp1.len) {
    tmp2 = 0;
  } else {
    for (int i3 = 0; i3 < test_TPCDS_Q54_simplified_result.len; i3++) {
      if (test_TPCDS_Q54_simplified_result.data[i3] != tmp1.data[i3]) {
        tmp2 = 0;
        break;
      }
    }
  }
  if (!(tmp2)) {
    fprintf(stderr, "expect failed\n");
    exit(1);
  }
}

int main() {
  store_sale_t store_sales[] = {
      (store_sale_t){.customer = 1, .sold_date = 2, .price = 60.0},
      (store_sale_t){.customer = 2, .sold_date = 2, .price = 40.0}};
  int store_sales_len = sizeof(store_sales) / sizeof(store_sales[0]);
  date_dim_t date_dim[] = {(date_dim_t){.d_date_sk = 2, .d_month_seq = 5}};
  int date_dim_len = sizeof(date_dim) / sizeof(date_dim[0]);
  customer_t customer[] = {
      (customer_t){.c_customer_sk = 1, .c_current_addr_sk = 1},
      (customer_t){.c_customer_sk = 2, .c_current_addr_sk = 1}};
  int customer_len = sizeof(customer) / sizeof(customer[0]);
  customer_addres_t customer_address[] = {(customer_addres_t){
      .ca_address_sk = 1, .ca_county = "X", .ca_state = "Y"}};
  int customer_address_len =
      sizeof(customer_address) / sizeof(customer_address[0]);
  store_t store[] = {
      (store_t){.s_store_sk = 1, .s_county = "X", .s_state = "Y"}};
  int store_len = sizeof(store) / sizeof(store[0]);
  revenue_item_list_t tmp4 =
      revenue_item_list_t_create(store_sales.len * date_dim.len * customer.len *
                                 customer_address.len * store.len);
  int tmp5 = 0;
  for (int tmp6 = 0; tmp6 < store_sales_len; tmp6++) {
    store_sale_t ss = store_sales[tmp6];
    for (int tmp7 = 0; tmp7 < date_dim_len; tmp7++) {
      date_dim_t d = date_dim[tmp7];
      if (!(ss.sold_date == d.d_date_sk)) {
        continue;
      }
      for (int tmp8 = 0; tmp8 < customer_len; tmp8++) {
        customer_t c = customer[tmp8];
        if (!(ss.customer == c.c_customer_sk)) {
          continue;
        }
        for (int tmp9 = 0; tmp9 < customer_address_len; tmp9++) {
          customer_addres_t ca = customer_address[tmp9];
          if (!(c.c_current_addr_sk == ca.ca_address_sk &&
                ca.ca_county == "X" && ca.ca_state == "Y")) {
            continue;
          }
          for (int tmp10 = 0; tmp10 < store_len; tmp10++) {
            store_t s = store[tmp10];
            if (!(1 == s.s_store_sk && ca.ca_county == s.s_county &&
                  ca.ca_state == s.s_state)) {
              continue;
            }
            tmp4.data[tmp5] =
                (revenue_item_t){.customer = c.c_customer_sk, .amt = ss.price};
            tmp5++;
          }
        }
      }
    }
  }
  tmp4.len = tmp5;
  revenue_item_list_t revenue = tmp4;
  revenue_item_list_t tmp11 = create_revenue_item_list(revenue.len);
  int tmp12_data[revenue.len];
  list_int tmp12 = {0, tmp12_data};
  int tmp13 = 0;
  for (int i14 = 0; i14 < revenue.len; i14++) {
    revenue_item_t r = revenue.data[i14];
    tmp11.data[tmp13] = r;
    tmp12.data[tmp13] = r.customer;
    tmp13++;
  }
  tmp11.len = tmp13;
  tmp12.len = tmp13;
  list_group_int tmp15 = _group_by_int(tmp12);
  by_customer_item_list_t tmp16 = by_customer_item_list_t_create(tmp15.len);
  int tmp17 = 0;
  for (int gi = 0; gi < tmp15.len; gi++) {
    _GroupInt _gp = tmp15.data[gi];
    revenue_item_list_t tmp18 = revenue_item_list_t_create(_gp.items.len);
    for (int i19 = 0; i19 < _gp.items.len; i19++) {
      tmp18.data[i19] = tmp11.data[_gp.items.data[i19]];
    }
    tmp18.len = _gp.items.len;
    struct {
      int key;
      revenue_item_list_t items;
    } g = {_gp.key, tmp18};
    list_float tmp20 = list_float_create(g.items.len);
    int tmp21 = 0;
    for (int i22 = 0; i22 < g.items.len; i22++) {
      revenue_item_t x = g.items.data[i22];
      tmp20.data[tmp21] = x.amt;
      tmp21++;
    }
    tmp20.len = tmp21;
    tmp16.data[tmp17] =
        (by_customer_item_t){.customer = g.key, .revenue = _sum_float(tmp20)};
    tmp17++;
  }
  tmp16.len = tmp17;
  by_customer_item_list_t by_customer = tmp16;
  segments_item_list_t segments = (segments_item_list_t){0, NULL};
  segments_item_list_t result = segments;
  printf("[");
  for (int i23 = 0; i23 < result.len; i23++) {
    if (i23 > 0)
      printf(",");
    segments_item_t it = result.data[i23];
    printf("{");
    _json_string("segment");
    printf(":");
    _json_int(it.segment);
    printf(",");
    _json_string("num_customers");
    printf(":");
    _json_int(it.num_customers);
    printf(",");
    _json_string("segment_base");
    printf(":");
    _json_int(it.segment_base);
    printf("}");
  }
  printf("]");
  test_TPCDS_Q54_simplified_result = result;
  test_TPCDS_Q54_simplified();
  return 0;
}
