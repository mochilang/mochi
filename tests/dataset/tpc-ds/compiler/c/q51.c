// Generated by Mochi compiler v0.10.26 on 2025-07-15T06:30:42Z
// Generated by Mochi compiler v0.10.26 on 2025-07-15T06:30:42Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  double *data;
} list_float;
static list_float list_float_create(int len) {
  list_float l;
  l.len = len;
  l.data = calloc(len, sizeof(double));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static void _json_int(int v) { printf("%d", v); }
static void _json_float(double v) { printf("%g", v); }
static void _json_string(char *s) { printf("\"%s\"", s); }
static void _json_list_int(list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_int(v.data[i]);
  }
  printf("]");
}
static void _json_list_float(list_float v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_float(v.data[i]);
  }
  printf("]");
}
static void _json_list_string(list_string v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_string(v.data[i]);
  }
  printf("]");
}
static void _json_list_list_int(list_list_int v) {
  printf("[");
  for (int i = 0; i < v.len; i++) {
    if (i > 0)
      printf(",");
    _json_list_int(v.data[i]);
  }
  printf("]");
}
static int dms = 1;

typedef struct {
  int date;
  double cum;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int item_sk;
  int d_date;
} tmp6_t;
typedef struct {
  int len;
  tmp6_t *data;
} tmp6_list_t;
tmp6_list_t create_tmp6_list(int len) {
  tmp6_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp6_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int item;
  int date;
  double price;
} web_sale_t;
typedef struct {
  int len;
  web_sale_t *data;
} web_sale_list_t;
web_sale_list_t create_web_sale_list(int len) {
  web_sale_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(web_sale_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int item;
  int date;
  double price;
} store_sale_t;
typedef struct {
  int len;
  store_sale_t *data;
} store_sale_list_t;
store_sale_list_t create_store_sale_list(int len) {
  store_sale_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(store_sale_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int date;
  double price;
} w_item_t;
typedef struct {
  int len;
  w_item_t *data;
} w_item_list_t;
w_item_list_t create_w_item_list(int len) {
  w_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(w_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int date;
  double price;
} s_item_t;
typedef struct {
  int len;
  s_item_t *data;
} s_item_list_t;
s_item_list_t create_s_item_list(int len) {
  s_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(s_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int item_sk;
  int d_date;
} joined_item_t;
typedef struct {
  int len;
  joined_item_t *data;
} joined_item_list_t;
joined_item_list_t create_joined_item_list(int len) {
  joined_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(joined_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

list_int cumulative(list_int xs) {
  list_int out = list_int_create(0);
  double acc = 0.0;
  for (int tmp1 = 0; tmp1 < xs.len; tmp1++) {
    int x = xs.data[tmp1];
    acc = acc + x.price;
    list_int tmp2 = list_int_create(0);
    int tmp3_data[1];
    list_int tmp3 = {1, tmp3_data};
    tmp3.data[0] = (tmp_item_t){.date = x.date, .cum = acc};
    list_int tmp4 = concat_list_int(tmp2, tmp3);
    out = tmp4;
  }
  list_int tmp5 = list_int_create(0);
  return tmp5;
}

static int test_TPCDS_Q51_simplified_result;
static void test_TPCDS_Q51_simplified() {
  tmp6_t tmp6[] = {(tmp6_t){.item_sk = 1, .d_date = 1},
                   (tmp_item_t){.item_sk = 1, .d_date = 2}};
  int tmp6_len = sizeof(tmp6) / sizeof(tmp6[0]);
  int tmp7 = 1;
  if (test_TPCDS_Q51_simplified_result.len != tmp6.len) {
    tmp7 = 0;
  } else {
    for (int i8 = 0; i8 < test_TPCDS_Q51_simplified_result.len; i8++) {
      if (test_TPCDS_Q51_simplified_result.data[i8] != tmp6.data[i8]) {
        tmp7 = 0;
        break;
      }
    }
  }
  if (!(tmp7)) {
    fprintf(stderr, "expect failed\n");
    exit(1);
  }
}

int main() {
  web_sale_t web_sales[] = {(web_sale_t){.item = 1, .date = 1, .price = 30.0},
                            (web_sale_t){.item = 1, .date = 2, .price = 20.0}};
  int web_sales_len = sizeof(web_sales) / sizeof(web_sales[0]);
  store_sale_t store_sales[] = {
      (store_sale_t){.item = 1, .date = 1, .price = 5.0},
      (store_sale_t){.item = 1, .date = 2, .price = 19.0}};
  int store_sales_len = sizeof(store_sales) / sizeof(store_sales[0]);
  w_item_list_t tmp9 = create_w_item_list(web_sales_len);
  int *tmp12 = (int *)malloc(sizeof(int) * web_sales_len);
  int tmp10 = 0;
  for (int tmp11 = 0; tmp11 < web_sales_len; tmp11++) {
    web_sale_t w = web_sales[tmp11];
    tmp9.data[tmp10] = (w_item_t){.date = w.date, .price = w.price};
    tmp12[tmp10] = w.date;
    tmp10++;
  }
  tmp9.len = tmp10;
  for (int i15 = 0; i15 < tmp10 - 1; i15++) {
    for (int i16 = i15 + 1; i16 < tmp10; i16++) {
      if (tmp12[i15] > tmp12[i16]) {
        int tmp13 = tmp12[i15];
        tmp12[i15] = tmp12[i16];
        tmp12[i16] = tmp13;
        w_item_t tmp14 = tmp9.data[i15];
        tmp9.data[i15] = tmp9.data[i16];
        tmp9.data[i16] = tmp14;
      }
    }
  }
  web_cum = cumulative((list_int)((tmp9)));
  s_item_list_t tmp17 = create_s_item_list(store_sales_len);
  int *tmp20 = (int *)malloc(sizeof(int) * store_sales_len);
  int tmp18 = 0;
  for (int tmp19 = 0; tmp19 < store_sales_len; tmp19++) {
    store_sale_t s = store_sales[tmp19];
    tmp17.data[tmp18] = (s_item_t){.date = s.date, .price = s.price};
    tmp20[tmp18] = s.date;
    tmp18++;
  }
  tmp17.len = tmp18;
  for (int i23 = 0; i23 < tmp18 - 1; i23++) {
    for (int i24 = i23 + 1; i24 < tmp18; i24++) {
      if (tmp20[i23] > tmp20[i24]) {
        int tmp21 = tmp20[i23];
        tmp20[i23] = tmp20[i24];
        tmp20[i24] = tmp21;
        s_item_t tmp22 = tmp17.data[i23];
        tmp17.data[i23] = tmp17.data[i24];
        tmp17.data[i24] = tmp22;
      }
    }
  }
  store_cum = cumulative((list_int)((tmp17)));
  joined_item_list_t tmp25 =
      joined_item_list_t_create(web_cum.len * store_cum.len);
  int tmp26 = 0;
  for (int tmp27 = 0; tmp27 < web_cum.len; tmp27++) {
    w = web_cum.data[tmp27];
    for (int tmp28 = 0; tmp28 < store_cum.len; tmp28++) {
      s = store_cum.data[tmp28];
      if (!(w.date == s.date)) {
        continue;
      }
      if (!(w.cum > s.cum)) {
        continue;
      }
      tmp25.data[tmp26] = (joined_item_t){.item_sk = 1, .d_date = w.date};
      tmp26++;
    }
  }
  tmp25.len = tmp26;
  joined_item_list_t joined = tmp25;
  joined_item_list_t result = joined;
  printf("[");
  for (int i29 = 0; i29 < result.len; i29++) {
    if (i29 > 0)
      printf(",");
    joined_item_t it = result.data[i29];
    printf("{");
    _json_string("item_sk");
    printf(":");
    _json_int(it.item_sk);
    printf(",");
    _json_string("d_date");
    printf(":");
    _json_int(it.d_date);
    printf("}");
  }
  printf("]");
  test_TPCDS_Q51_simplified_result = result;
  test_TPCDS_Q51_simplified();
  free(tmp9.data);
  free(tmp17.data);
  return 0;
}
