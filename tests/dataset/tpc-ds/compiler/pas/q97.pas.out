// Generated by Mochi compiler v0.10.26 on 2025-07-15T06:33:33Z
program Q97;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;
type StoreSale = record
  ss_customer_sk: integer;
  ss_item_sk: integer;
end;
type CatalogSale = record
  cs_bill_customer_sk: integer;
  cs_item_sk: integer;
end;

generic _Group<K,T> = record
  Key: K;
  Items: specialize TArray<T>;
end;

generic function _countList<T>(arr: specialize TArray<T>): integer;
begin
  Result := Length(arr);
end;

generic procedure _json<T>(v: T);
begin
  writeln('[]');
end;

var
  _tmp0: specialize TFPGMap<string, integer>;
  _tmp1: specialize TFPGMap<string, integer>;
  _tmp10: integer;
  _tmp11: specialize _Group<_, specialize TFPGMap<string, integer>>;
  _tmp12: specialize TArray<specialize TFPGMap<string, Variant>>;
  _tmp13: specialize TFPGMap<string, Variant>;
  _tmp14: specialize TFPGMap<string, integer>;
  _tmp15: specialize TArray<specialize TFPGMap<string, integer>>;
  _tmp16: specialize TArray<specialize _Group<_, specialize TFPGMap<string, integer>>>;
  _tmp17: _;
  _tmp18: string;
  _tmp19: integer;
  _tmp2: specialize TFPGMap<string, integer>;
  _tmp20: integer;
  _tmp21: specialize _Group<_, specialize TFPGMap<string, integer>>;
  _tmp22: specialize TArray<specialize TFPGMap<string, Variant>>;
  _tmp23: specialize TFPGMap<string, Variant>;
  _tmp24: specialize TArray<integer>;
  _tmp25: specialize TArray<specialize TFPGMap<string, Variant>>;
  _tmp26: specialize TArray<integer>;
  _tmp27: specialize TArray<specialize TFPGMap<string, Variant>>;
  _tmp28: specialize TArray<integer>;
  _tmp29: specialize TFPGMap<string, Variant>;
  _tmp3: specialize TFPGMap<string, integer>;
  _tmp4: specialize TFPGMap<string, integer>;
  _tmp5: specialize TArray<specialize TFPGMap<string, integer>>;
  _tmp6: specialize TArray<specialize _Group<_, specialize TFPGMap<string, integer>>>;
  _tmp7: _;
  _tmp8: string;
  _tmp9: integer;
  both: Variant;
  c: specialize TFPGMap<string, Variant>;
  catalog_only: Variant;
  catalog_sales: specialize TArray<specialize TFPGMap<string, integer>>;
  cs: specialize TFPGMap<string, integer>;
  csci: specialize TArray<specialize TFPGMap<string, Variant>>;
  _result: specialize TFPGMap<string, integer>;
  s: specialize TFPGMap<string, Variant>;
  ss: specialize TFPGMap<string, integer>;
  ssci: specialize TArray<specialize TFPGMap<string, Variant>>;
  store_only: Variant;
  store_sales: specialize TArray<specialize TFPGMap<string, integer>>;

procedure test_TPCDS_Q97_overlap;
begin
  if not ((((_result.KeyData['store_only'] = 1) and (_result.KeyData['catalog_only'] = 1)) and (_result.KeyData['store_and_catalog'] = 1))) then raise Exception.Create('expect failed');
end;

begin
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  _tmp0.AddOrSetData('ss_customer_sk', 1);
  _tmp0.AddOrSetData('ss_item_sk', 1);
  _tmp1 := specialize TFPGMap<string, integer>.Create;
  _tmp1.AddOrSetData('ss_customer_sk', 2);
  _tmp1.AddOrSetData('ss_item_sk', 1);
  store_sales := specialize TArray<specialize TFPGMap<string, integer>>([_tmp0, _tmp1]);
  _tmp2 := specialize TFPGMap<string, integer>.Create;
  _tmp2.AddOrSetData('cs_bill_customer_sk', 1);
  _tmp2.AddOrSetData('cs_item_sk', 1);
  _tmp3 := specialize TFPGMap<string, integer>.Create;
  _tmp3.AddOrSetData('cs_bill_customer_sk', 3);
  _tmp3.AddOrSetData('cs_item_sk', 2);
  catalog_sales := specialize TArray<specialize TFPGMap<string, integer>>([_tmp2, _tmp3]);
  _tmp4 := specialize TFPGMap<string, integer>.Create;
  _tmp4.AddOrSetData('customer_sk', ss.KeyData['ss_customer_sk']);
  _tmp4.AddOrSetData('item_sk', ss.KeyData['ss_item_sk']);
  SetLength(_tmp5, 0);
  for ss in store_sales do
  begin
    _tmp5 := Concat(_tmp5, [ss]);
  end;
  SetLength(_tmp6, 0);
  for ss in _tmp5 do
  begin
    _tmp7 := _tmp4;
    _tmp8 := VarToStr(_tmp7);
    _tmp9 := -1;
    for _tmp10 := 0 to High(_tmp6) do
      if VarToStr(_tmp6[_tmp10].Key) = _tmp8 then begin _tmp9 := _tmp10; Break; end;
    if _tmp9 = -1 then
    begin
      _tmp9 := Length(_tmp6);
      SetLength(_tmp6, _tmp9 + 1);
      _tmp6[_tmp9].Key := _tmp7;
      SetLength(_tmp6[_tmp9].Items, 0);
    end;
    SetLength(_tmp6[_tmp9].Items, Length(_tmp6[_tmp9].Items)+1);
    _tmp6[_tmp9].Items[High(_tmp6[_tmp9].Items)] := ss;
  end;
  SetLength(_tmp12, 0);
  for _tmp11 in _tmp6 do
  begin
    _tmp13 := specialize TFPGMap<string, Variant>.Create;
    _tmp13.AddOrSetData('customer_sk', g.key.customer_sk);
    _tmp13.AddOrSetData('item_sk', g.key.item_sk);
    _tmp12 := Concat(_tmp12, [_tmp13]);
  end;
  ssci := _tmp12;
  _tmp14 := specialize TFPGMap<string, integer>.Create;
  _tmp14.AddOrSetData('customer_sk', cs.KeyData['cs_bill_customer_sk']);
  _tmp14.AddOrSetData('item_sk', cs.KeyData['cs_item_sk']);
  SetLength(_tmp15, 0);
  for cs in catalog_sales do
  begin
    _tmp15 := Concat(_tmp15, [cs]);
  end;
  SetLength(_tmp16, 0);
  for cs in _tmp15 do
  begin
    _tmp17 := _tmp14;
    _tmp18 := VarToStr(_tmp17);
    _tmp19 := -1;
    for _tmp20 := 0 to High(_tmp16) do
      if VarToStr(_tmp16[_tmp20].Key) = _tmp18 then begin _tmp19 := _tmp20; Break; end;
    if _tmp19 = -1 then
    begin
      _tmp19 := Length(_tmp16);
      SetLength(_tmp16, _tmp19 + 1);
      _tmp16[_tmp19].Key := _tmp17;
      SetLength(_tmp16[_tmp19].Items, 0);
    end;
    SetLength(_tmp16[_tmp19].Items, Length(_tmp16[_tmp19].Items)+1);
    _tmp16[_tmp19].Items[High(_tmp16[_tmp19].Items)] := cs;
  end;
  SetLength(_tmp22, 0);
  for _tmp21 in _tmp16 do
  begin
    _tmp23 := specialize TFPGMap<string, Variant>.Create;
    _tmp23.AddOrSetData('customer_sk', g.key.customer_sk);
    _tmp23.AddOrSetData('item_sk', g.key.item_sk);
    _tmp22 := Concat(_tmp22, [_tmp23]);
  end;
  csci := _tmp22;
  SetLength(_tmp24, 0);
  for s in ssci do
  begin
    for c in csci do
    begin
      if not (((s.KeyData['customer_sk'] = c.KeyData['customer_sk']) and (s.KeyData['item_sk'] = c.KeyData['item_sk']))) then continue;
      _tmp24 := Concat(_tmp24, [1]);
    end;
  end;
  both := specialize _countList<integer>(_tmp24);
  SetLength(_tmp25, 0);
  for c in csci do
  begin
    if not (((s.KeyData['customer_sk'] = c.KeyData['customer_sk']) and (s.KeyData['item_sk'] = c.KeyData['item_sk']))) then continue;
    _tmp25 := Concat(_tmp25, [c]);
  end;
  SetLength(_tmp26, 0);
  for s in ssci do
  begin
    if not (not (Length(_tmp25) > 0)) then continue;
    _tmp26 := Concat(_tmp26, [1]);
  end;
  store_only := specialize _countList<integer>(_tmp26);
  SetLength(_tmp27, 0);
  for s in ssci do
  begin
    if not (((s.KeyData['customer_sk'] = c.KeyData['customer_sk']) and (s.KeyData['item_sk'] = c.KeyData['item_sk']))) then continue;
    _tmp27 := Concat(_tmp27, [s]);
  end;
  SetLength(_tmp28, 0);
  for c in csci do
  begin
    if not (not (Length(_tmp27) > 0)) then continue;
    _tmp28 := Concat(_tmp28, [1]);
  end;
  catalog_only := specialize _countList<integer>(_tmp28);
  _tmp29 := specialize TFPGMap<string, Variant>.Create;
  _tmp29.AddOrSetData('store_only', store_only);
  _tmp29.AddOrSetData('catalog_only', catalog_only);
  _tmp29.AddOrSetData('store_and_catalog', both);
  _result := _tmp29;
  specialize _json<specialize TFPGMap<string, integer>>(_result);
  test_TPCDS_Q97_overlap;
end.
