fun _count(v) {
  cond(sequential_p(v), count(v), map_p(v) && contains_p(v, Items), count([Items, v]), else, )
}
defrecord(_Group, key(Items))
fun _group_by(src, keyfn) {
  (fun(groups) => doseq(it(src), (fun(k) => when_not(contains_p(@groups, ks), swap_bang(groups, assoc, ks, _Group_(k, )), swap_bang(order, conj, ks)))(keyfn(it))))(atom({}))
}
fun _escape_json(s) {
  >(s, clojure_string_replace("\\", "\\\\"), clojure_string_replace("\"", "\\\""))
}
fun _to_json(v) {
  cond(nil_p(v), "null", string_p(v), str("\"", _escape_json(v), "\""), number_p(v), str(v), boolean_p(v), str(v), sequential_p(v), str("[", clojure_string_join(",", map(_to_json, v)), "]"), map_p(v), str("{", clojure_string_join(",", map(fn(, str("\"", _escape_json(name(k)), "\":", _to_json(val))), v)), "}"), else, str("\"", _escape_json(str(v)), "\""))
}
fun _json(v) {
  print(_to_json(v))
}
fun _query(src, joins, opts) {
  (fun(items) => doseq(j(joins), (fun(joined) => cond([right, j] && [left, j], (fun(matched) => doseq(left(@items), (fun(m) => doseq(, (fun(keep) => if keep {
  reset_bang(m, true)
  aset(matched, ri, true)
  swap_bang(joined, conj, conj(left, right))
})(if_let(f([on, j]), apply(f, conj(left, right)), true)), when_not(@m, swap_bang(joined, conj, conj(left, nil)))))(atom(false))))(boolean_array(count([items, j])))))(atom())))(atom(mapv(vector, src)))
}
