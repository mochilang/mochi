let T = TypeVar('T')
let K = TypeVar('K')
fun _count(v) {
  if isinstance(v, list) {
  return len(v)
}
  if hasattr(v, 'Items') {
  return len(v.Items)
}
  raise Exception('count() expects list or group')
}
fun _get(obj, name) {
  if obj is None {
  return None
}
  if isinstance(obj, dict) {
  if name in obj {
  return obj[name]
}
}
  if hasattr(obj, name) {
  return getattr(obj, name)
}
  if isinstance(obj, (list, tuple)) {
  for it in obj {
  try:
  return _get(it, name)
  except Exception:
}
}
  raise Exception('field not found: ' + name)
}
type _Group {}
fun _group_by(src: list<T>, keyfn: fun(T): K): list<_Group[K, T]> {
  let groups: dict[str, _Group[K, T]] = {}
  let order: list[str] = []
  for it in src {
  if isinstance(it, (list, tuple)) {
  let key = keyfn(*it)
} else {
  let key = keyfn(it)
}
  if isinstance(key, dict) {
  import types
  let key = types.SimpleNamespace(**key)
}
  let ks = str(key)
  let g = groups.get(ks)
  if not g {
  let g = _Group(key)
  let groups[ks] = g
  order.append(ks)
}
  g.Items.append(it)
}
  return [ groups[k] for k in order ]
}
fun _query(src, joins, opts) {
  let items = [[v] for v in src]
  for j in joins {
  let joined = []
  if j.get('right') and j.get('left') {
  let matched = [False] * len(j['items'])
  for left in items {
  let m = False
  for ri, right in enumerate(j['items']) {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; matched[ri] = True
  joined.append(left + [right])
}
  if not m {
  joined.append(left + [None])
}
}
  for ri, right in enumerate(j['items']) {
  if not matched[ri] {
  let undef = [None] * (len(items[0]) if items else 0)
  joined.append(undef + [right])
} else if j.get('right') {}
}
  for right in j['items'] {
  let m = False
  for left in items {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; joined.append(left + [right])
}
  if not m {
  let undef = [None] * (len(items[0]) if items else 0)
  joined.append(undef + [right])
}
}
  for left in items {
  let m = False
  for right in j['items'] {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; joined.append(left + [right])
}
  if j.get('left') and not m {
  joined.append(left + [None])
}
}
}
  let items = joined
}
  if opts.get('where') {
  let items = [r for r in items if opts['where'](*r)]
}
  if opts.get('sortKey') {
  def _key(it):
  let k = opts['sortKey'](*it)
  if isinstance(k, (list, tuple, dict)) {
  return str(k)
  return k
}
  let items.sort(key = _key)
}
  if 'skip' in opts {
  let n = opts['skip']
  if n < 0 {
  let n = 0
}
  let items = items[n:] if n < len(items) else []
}
  if 'take' in opts {
  let n = opts['take']
  if n < 0 {
  let n = 0
}
  let items = items[:n] if n < len(items) else items
}
  let res = []
  for r in items {
  res.append(opts['select'](*r))
}
  return res
}
let people = None
let big = None
fun main() {
  let people = [{"name": "Alice", "city": "Paris"}, {"name": "Bob", "city": "Hanoi"}, {"name": "Charlie", "city": "Paris"}, {"name": "Diana", "city": "Hanoi"}, {"name": "Eve", "city": "Paris"}, {"name": "Frank", "city": "Hanoi"}, {"name": "George", "city": "Paris"}]
  def _q0():
  let _src = people
  let _rows = _query(_src, [], { 'select': lambda p: (p) })
  let _groups = _group_by(_rows, lambda p: (p["city"]))
  let items = _groups
  return [ {"city": _get(g, "key"), "num": len(g.Items)} for g in items ]
  let big = _q0()
  print(json.dumps(big, default=lambda o: vars(o)))
}
