let T = TypeVar('T')
let K = TypeVar('K')
fun _get(obj, name) {
  if obj is None {
  return None
}
  if isinstance(obj, dict) {
  if name in obj {
  return obj[name]
}
}
  if hasattr(obj, name) {
  return getattr(obj, name)
}
  if isinstance(obj, (list, tuple)) {
  for it in obj {
  try:
  return _get(it, name)
  except Exception:
}
}
  raise Exception('field not found: ' + name)
}
type _Group {}
fun _group_by(src: list<T>, keyfn: fun(T): K): list<_Group[K, T]> {
  let groups: dict[str, _Group[K, T]] = {}
  let order: list[str] = []
  for it in src {
  if isinstance(it, (list, tuple)) {
  let key = keyfn(*it)
} else {
  let key = keyfn(it)
}
  if isinstance(key, dict) {
  import types
  let key = types.SimpleNamespace(**key)
}
  let ks = str(key)
  let g = groups.get(ks)
  if not g {
  let g = _Group(key)
  let groups[ks] = g
  order.append(ks)
}
  g.Items.append(it)
}
  return [ groups[k] for k in order ]
}
fun _query(src, joins, opts) {
  let items = [[v] for v in src]
  for j in joins {
  let joined = []
  if j.get('right') and j.get('left') {
  let matched = [False] * len(j['items'])
  for left in items {
  let m = False
  for ri, right in enumerate(j['items']) {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; matched[ri] = True
  joined.append(left + [right])
}
  if not m {
  joined.append(left + [None])
}
}
  for ri, right in enumerate(j['items']) {
  if not matched[ri] {
  let undef = [None] * (len(items[0]) if items else 0)
  joined.append(undef + [right])
} else if j.get('right') {}
}
  for right in j['items'] {
  let m = False
  for left in items {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; joined.append(left + [right])
}
  if not m {
  let undef = [None] * (len(items[0]) if items else 0)
  joined.append(undef + [right])
}
}
  for left in items {
  let m = False
  for right in j['items'] {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; joined.append(left + [right])
}
  if j.get('left') and not m {
  joined.append(left + [None])
}
}
}
  let items = joined
}
  if opts.get('where') {
  let items = [r for r in items if opts['where'](*r)]
}
  if opts.get('sortKey') {
  def _key(it):
  let k = opts['sortKey'](*it)
  if isinstance(k, (list, tuple, dict)) {
  return str(k)
  return k
}
  let items.sort(key = _key)
}
  if 'skip' in opts {
  let n = opts['skip']
  if n < 0 {
  let n = 0
}
  let items = items[n:] if n < len(items) else []
}
  if 'take' in opts {
  let n = opts['take']
  if n < 0 {
  let n = 0
}
  let items = items[:n] if n < len(items) else items
}
  let res = []
  for r in items {
  res.append(opts['select'](*r))
}
  return res
}
fun _sort_key(k) {
  if isinstance(k, (list, tuple, dict)) {
  return str(k)
}
  return k
}
let data = None
let groups = None
let tmp = []
let result = None
fun main() {
  let data = [{"tag": "a", "val": 1}, {"tag": "a", "val": 2}, {"tag": "b", "val": 3}]
  def _q0():
  let _src = data
  let _rows = _query(_src, [], { 'select': lambda d: (d) })
  let _groups = _group_by(_rows, lambda d: (d["tag"]))
  let items = _groups
  return [ g for g in items ]
  let groups = _q0()
  let tmp = []
  for g in groups {}
  let total = 0
  for x in _get(g, "items") {}
  let total = (total + _get(x, "val"))
  let tmp = tmp + [{"tag": _get(g, "key"), "total": total}]
  let result = [ r for r in sorted([ r for r in tmp ], key=lambda r: _sort_key(_get(r, "tag"))) ]
  print(*result)
}
