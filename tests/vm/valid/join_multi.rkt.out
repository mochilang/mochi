#lang racket
; generated by Mochi
(require racket/list)

(define (idx x i)
  (cond [(string? x) (let* ([n (string-length x)] [idx (if (< i 0) (+ i n) i)]) (char->integer (string-ref x idx)))]
        [(hash? x) (hash-ref x i)]
        [else (let* ([n (length x)] [idx (if (< i 0) (+ i n) i)]) (list-ref x idx))]))
(define (slice x s e)
  (if (string? x)
      (let* ([n (string-length x)]
             [start (if (< s 0) (+ s n) s)]
             [end (if (< e 0) (+ e n) e)]
             [start (max 0 start)]
             [end (min n end)]
             [end (if (< end start) start end)])
        (substring x start end))
      (let* ([n (length x)]
             [start (if (< s 0) (+ s n) s)]
             [end (if (< e 0) (+ e n) e)]
             [start (max 0 start)]
             [end (min n end)]
             [end (if (< end start) start end)])
        (take (drop x start) (- end start)))))
(define (count x)
  (cond [(string? x) (string-length x)]
        [(hash? x) (hash-count x)]
        [else (length x)]))
(define (avg x)
  (let ([n (count x)])
    (if (= n 0) 0
        (/ (for/fold ([s 0.0]) ([v x]) (+ s (real->double-flonum v))) n))))
(define (sum x)
  (for/fold ([s 0.0]) ([v x]) (+ s (real->double-flonum v))))
(define (min-list xs)
  (cond [(null? xs) 0]
        [(for/and ([v xs]) (number? v)) (apply min xs)]
        [(for/and ([v xs]) (string? v)) (for/fold ([m (car xs)]) ([v (cdr xs)]) (if (string<? v m) v m))]
        [else (error "unsupported min operands")]))
(define (_add a b)
  (cond [(and (number? a) (number? b)) (+ a b)]
        [(and (string? a) (string? b)) (string-append a b)]
        [(and (list? a) (list? b)) (append a b)]
        [else (error "unsupported + operands")]))
(define (_div a b)
  (cond [(and (integer? a) (integer? b)) (quotient a b)]
        [else (/ a b)]))

(define (expect cond) (unless cond (error "expect failed")))
(define customers (list (hash "id" 1 "name" "Alice") (hash "id" 2 "name" "Bob")))
(define orders (list (hash "id" 100 "customerId" 1) (hash "id" 101 "customerId" 2)))
(define items (list (hash "orderId" 100 "sku" "a") (hash "orderId" 101 "sku" "b")))
(define result (let ([_res '()])
  (for ([o orders])
    (for ([c customers])
      (when (equal? (hash-ref o "customerId") (hash-ref c "id"))
        (for ([i items])
          (when (equal? (hash-ref o "id") (hash-ref i "orderId"))
            (set! _res (append _res (list (hash "name" (hash-ref c "name") "sku" (hash-ref i "sku")))))
          )
        )
      )
    )
  )
  _res))
(displayln "--- Multi Join ---")
(for ([r (if (hash? result) (hash-keys result) result)])
  (displayln (format "~a ~a ~a" (hash-ref r "name") "bought item" (hash-ref r "sku")))
)
