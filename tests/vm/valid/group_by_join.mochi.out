fun _count(v) {
  cond(sequential_p(v), count(v), map_p(v) && contains_p(v, Items), count([Items, v]), else, )
}
defrecord(_Group, key(Items))
fun _group_by(src, keyfn) {
  (fun(groups) => doseq(it(src), (fun(k) => when_not(contains_p(@groups, ks), swap_bang(groups, assoc, ks, _Group_(k, )), swap_bang(order, conj, ks)))(keyfn(it))))(atom({}))
}
fun _query(src, joins, opts) {
  (fun(items) => doseq(j(joins), (fun(joined) => cond([right, j] && [left, j], (fun(matched) => doseq(left(@items), (fun(m) => doseq(, (fun(keep) => if keep {
  reset_bang(m, true)
  aset(matched, ri, true)
  swap_bang(joined, conj, conj(left, right))
})(if_let(f([on, j]), apply(f, conj(left, right)), true)), when_not(@m, swap_bang(joined, conj, conj(left, nil)))))(atom(false))))(boolean_array(count([items, j])))))(atom())))(atom(mapv(vector, src)))
}
