#lang racket
; generated by Mochi
(require racket/list)

(define (idx x i)
  (cond [(string? x) (let* ([n (string-length x)] [idx (if (< i 0) (+ i n) i)]) (char->integer (string-ref x idx)))]
        [(hash? x) (hash-ref x i)]
        [else (let* ([n (length x)] [idx (if (< i 0) (+ i n) i)]) (list-ref x idx))]))
(define (slice x s e)
  (if (string? x)
      (let* ([n (string-length x)]
             [start (if (< s 0) (+ s n) s)]
             [end (if (< e 0) (+ e n) e)]
             [start (max 0 start)]
             [end (min n end)]
             [end (if (< end start) start end)])
        (substring x start end))
      (let* ([n (length x)]
             [start (if (< s 0) (+ s n) s)]
             [end (if (< e 0) (+ e n) e)]
             [start (max 0 start)]
             [end (min n end)]
             [end (if (< end start) start end)])
        (take (drop x start) (- end start)))))
(define (count x)
  (cond [(string? x) (string-length x)]
        [(hash? x) (hash-count x)]
        [else (length x)]))
(define (avg x)
  (let ([n (count x)])
    (if (= n 0) 0
        (/ (for/fold ([s 0.0]) ([v x]) (+ s (real->double-flonum v))) n))))
(define (sum x)
  (for/fold ([s 0.0]) ([v x]) (+ s (real->double-flonum v))))
(define (min-list xs)
  (cond [(null? xs) 0]
        [(for/and ([v xs]) (number? v)) (apply min xs)]
        [(for/and ([v xs]) (string? v)) (for/fold ([m (car xs)]) ([v (cdr xs)]) (if (string<? v m) v m))]
        [else (error "unsupported min operands")]))
(define (_add a b)
  (cond [(and (number? a) (number? b)) (+ a b)]
        [(and (string? a) (string? b)) (string-append a b)]
        [(and (list? a) (list? b)) (append a b)]
        [else (error "unsupported + operands")]))
(define (_div a b)
  (cond [(and (integer? a) (integer? b)) (quotient a b)]
        [else (/ a b)]))

(define (expect cond) (unless cond (error "expect failed")))
(define products (list (hash "name" "Laptop" "price" 1500) (hash "name" "Smartphone" "price" 900) (hash "name" "Tablet" "price" 600) (hash "name" "Monitor" "price" 300) (hash "name" "Keyboard" "price" 100) (hash "name" "Mouse" "price" 50) (hash "name" "Headphones" "price" 200)))
(define expensive (let ([_res '()])
  (for ([p products])
    (set! _res (append _res (list (cons (- (hash-ref p "price")) p))))
  )
  (set! _res (map cdr (sort _res (lambda (a b)
    (let ([ak (car a)] [bk (car b)])
      (cond [(and (number? ak) (number? bk)) (< ak bk)]
            [(and (string? ak) (string? bk)) (string<? ak bk)]
            [else (string<? (format "~a" ak) (format "~a" bk))])))
  )))
  (set! _res (drop _res 1))
  (set! _res (take _res 3))
  _res))
(displayln "--- Top products (excluding most expensive) ---")
(for ([item (if (hash? expensive) (hash-keys expensive) expensive)])
  (displayln (format "~a ~a ~a" (hash-ref item "name") "costs $" (hash-ref item "price")))
)
