#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v)
  (cond
    [(eq? v #t) "true"]
    [(eq? v #f) "false"]
    [(void? v) "<nil>"]
    [(list? v) (string-join (map _to_string v) " ")]
    [else (format "~a" v)]))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define products (list (hash 'name "Laptop" 'price 1500) (hash 'name "Smartphone" 'price 900) (hash 'name "Tablet" 'price 600) (hash 'name "Monitor" 'price 300) (hash 'name "Keyboard" 'price 100) (hash 'name "Mouse" 'price 50) (hash 'name "Headphones" 'price 200)))
(define expensive (let ([_items0 (for*/list ([p products]) (hash 'p p))])
  (set! _items0 (sort _items0 (lambda (a b) (cond [(string? (let ((p (hash-ref a 'p))) (hash-ref p 'price))) (string>? (let ((p (hash-ref a 'p))) (hash-ref p 'price)) (let ((p (hash-ref b 'p))) (hash-ref p 'price)))] [(string? (let ((p (hash-ref b 'p))) (hash-ref p 'price))) (string>? (let ((p (hash-ref a 'p))) (hash-ref p 'price)) (let ((p (hash-ref b 'p))) (hash-ref p 'price)))] [else (> (let ((p (hash-ref a 'p))) (hash-ref p 'price)) (let ((p (hash-ref b 'p))) (hash-ref p 'price)))]))))
  (set! _items0 (drop _items0 (max 1 0)))
  (set! _items0 (take _items0 (max 3 0)))
  (for/list ([item _items0]) (let ((p (hash-ref item 'p))) p))))
(displayln (_to_string "--- Top products (excluding most expensive) ---"))
(for ([item (if (hash? expensive) (hash-keys expensive) expensive)])
(displayln (string-join (map _to_string (list (hash-ref item 'name) "costs $" (hash-ref item 'price))) " "))
)
