let T = TypeVar('T')
let K = TypeVar('K')
fun _avg(v) {
  if hasattr(v, 'Items') {
  let v = v.Items
}
  if not isinstance(v, list) {
  raise Exception('avg() expects list or group')
}
  if not v {
  return 0
}
  let s = 0.0
  for it in v {
  if isinstance(it, (int, float)) {
  let s = s + float(it)
} else {
  raise Exception('avg() expects numbers')
}
}
  return s / len(v)
}
fun _count(v) {
  if isinstance(v, list) {
  return len(v)
}
  if hasattr(v, 'Items') {
  return len(v.Items)
}
  raise Exception('count() expects list or group')
}
fun _get(obj, name) {
  if obj is None {
  return None
}
  if isinstance(obj, dict) {
  if name in obj {
  return obj[name]
}
}
  if hasattr(obj, name) {
  return getattr(obj, name)
}
  if isinstance(obj, (list, tuple)) {
  for it in obj {
  try:
  return _get(it, name)
  except Exception:
}
}
  raise Exception('field not found: ' + name)
}
type _Group {}
fun _group_by(src: list<T>, keyfn: fun(T): K): list<_Group[K, T]> {
  let groups: dict[str, _Group[K, T]] = {}
  let order: list[str] = []
  for it in src {
  if isinstance(it, (list, tuple)) {
  let key = keyfn(*it)
} else {
  let key = keyfn(it)
}
  if isinstance(key, dict) {
  import types
  let key = types.SimpleNamespace(**key)
}
  let ks = str(key)
  let g = groups.get(ks)
  if not g {
  let g = _Group(key)
  let groups[ks] = g
  order.append(ks)
}
  g.Items.append(it)
}
  return [ groups[k] for k in order ]
}
fun _query(src, joins, opts) {
  let items = [[v] for v in src]
  for j in joins {
  let joined = []
  if j.get('right') and j.get('left') {
  let matched = [False] * len(j['items'])
  for left in items {
  let m = False
  for ri, right in enumerate(j['items']) {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; matched[ri] = True
  joined.append(left + [right])
}
  if not m {
  joined.append(left + [None])
}
}
  for ri, right in enumerate(j['items']) {
  if not matched[ri] {
  let undef = [None] * (len(items[0]) if items else 0)
  joined.append(undef + [right])
} else if j.get('right') {}
}
  for right in j['items'] {
  let m = False
  for left in items {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; joined.append(left + [right])
}
  if not m {
  let undef = [None] * (len(items[0]) if items else 0)
  joined.append(undef + [right])
}
}
  for left in items {
  let m = False
  for right in j['items'] {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; joined.append(left + [right])
}
  if j.get('left') and not m {
  joined.append(left + [None])
}
}
}
  let items = joined
}
  if opts.get('where') {
  let items = [r for r in items if opts['where'](*r)]
}
  if opts.get('sortKey') {
  def _key(it):
  let k = opts['sortKey'](*it)
  if isinstance(k, (list, tuple, dict)) {
  return str(k)
  return k
}
  let items.sort(key = _key)
}
  if 'skip' in opts {
  let n = opts['skip']
  if n < 0 {
  let n = 0
}
  let items = items[n:] if n < len(items) else []
}
  if 'take' in opts {
  let n = opts['take']
  if n < 0 {
  let n = 0
}
  let items = items[:n] if n < len(items) else items
}
  let res = []
  for r in items {
  res.append(opts['select'](*r))
}
  return res
}
let people = None
let stats = None
fun main() {
  let people = [{"name": "Alice", "age": 30, "city": "Paris"}, {"name": "Bob", "age": 15, "city": "Hanoi"}, {"name": "Charlie", "age": 65, "city": "Paris"}, {"name": "Diana", "age": 45, "city": "Hanoi"}, {"name": "Eve", "age": 70, "city": "Paris"}, {"name": "Frank", "age": 22, "city": "Hanoi"}]
  def _q0():
  let _src = people
  let _rows = _query(_src, [], { 'select': lambda person: (person) })
  let _groups = _group_by(_rows, lambda person: (person["city"]))
  let items = _groups
  return [ {"city": _get(g, "key"), "count": len(g.Items), "avg_age": _avg([ p["age"] for p in g ])} for g in items ]
  let stats = _q0()
  print("--- People grouped by city ---")
  for s in stats {}
  print(s["city"], ": count =", s["count"], ", avg_age =", s["avg_age"])
}
