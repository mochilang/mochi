let T = TypeVar('T')
let K = TypeVar('K')
fun _get(obj, name) {
  if obj is None {
  return None
}
  if isinstance(obj, dict) {
  if name in obj {
  return obj[name]
}
}
  if hasattr(obj, name) {
  return getattr(obj, name)
}
  if isinstance(obj, (list, tuple)) {
  for it in obj {
  try:
  return _get(it, name)
  except Exception:
}
}
  raise Exception('field not found: ' + name)
}
type _Group {}
fun _group_by(src: list<T>, keyfn: fun(T): K): list<_Group[K, T]> {
  let groups: dict[str, _Group[K, T]] = {}
  let order: list[str] = []
  for it in src {
  if isinstance(it, (list, tuple)) {
  let key = keyfn(*it)
} else {
  let key = keyfn(it)
}
  if isinstance(key, dict) {
  import types
  let key = types.SimpleNamespace(**key)
}
  let ks = str(key)
  let g = groups.get(ks)
  if not g {
  let g = _Group(key)
  let groups[ks] = g
  order.append(ks)
}
  g.Items.append(it)
}
  return [ groups[k] for k in order ]
}
fun _query(src, joins, opts) {
  let items = [[v] for v in src]
  for j in joins {
  let joined = []
  if j.get('right') and j.get('left') {
  let matched = [False] * len(j['items'])
  for left in items {
  let m = False
  for ri, right in enumerate(j['items']) {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; matched[ri] = True
  joined.append(left + [right])
}
  if not m {
  joined.append(left + [None])
}
}
  for ri, right in enumerate(j['items']) {
  if not matched[ri] {
  let undef = [None] * (len(items[0]) if items else 0)
  joined.append(undef + [right])
} else if j.get('right') {}
}
  for right in j['items'] {
  let m = False
  for left in items {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; joined.append(left + [right])
}
  if not m {
  let undef = [None] * (len(items[0]) if items else 0)
  joined.append(undef + [right])
}
}
  for left in items {
  let m = False
  for right in j['items'] {
  let keep = True
  if j.get('on') {
  let keep = j['on'](*left, right)
}
  if not keep {
  continue
}
  let m = True; joined.append(left + [right])
}
  if j.get('left') and not m {
  joined.append(left + [None])
}
}
}
  let items = joined
}
  if opts.get('where') {
  let items = [r for r in items if opts['where'](*r)]
}
  if opts.get('sortKey') {
  def _key(it):
  let k = opts['sortKey'](*it)
  if isinstance(k, (list, tuple, dict)) {
  return str(k)
  return k
}
  let items.sort(key = _key)
}
  if 'skip' in opts {
  let n = opts['skip']
  if n < 0 {
  let n = 0
}
  let items = items[n:] if n < len(items) else []
}
  if 'take' in opts {
  let n = opts['take']
  if n < 0 {
  let n = 0
}
  let items = items[:n] if n < len(items) else items
}
  let res = []
  for r in items {
  res.append(opts['select'](*r))
}
  return res
}
fun _sort_key(k) {
  if isinstance(k, (list, tuple, dict)) {
  return str(k)
}
  return k
}
fun _sum(v) {
  if hasattr(v, 'Items') {
  let v = v.Items
}
  if not isinstance(v, list) {
  raise Exception('sum() expects list or group')
}
  let s = 0.0
  for it in v {
  if it is None {
  continue
}
  if isinstance(it, (int, float)) {
  let s = s + float(it)
} else {
  raise Exception('sum() expects numbers')
}
}
  return s
}
let nation = None
let customer = None
let orders = None
let lineitem = None
let start_date = '1993-10-01'
let end_date = '1994-01-01'
let result = None
fun main() {
  let nation = [{"n_nationkey": 1, "n_name": "BRAZIL"}]
  let customer = [{"c_custkey": 1, "c_name": "Alice", "c_acctbal": 100, "c_nationkey": 1, "c_address": "123 St", "c_phone": "123-456", "c_comment": "Loyal"}]
  let orders = [{"o_orderkey": 1000, "o_custkey": 1, "o_orderdate": "1993-10-15"}, {"o_orderkey": 2000, "o_custkey": 1, "o_orderdate": "1994-01-02"}]
  let lineitem = [{"l_orderkey": 1000, "l_returnflag": "R", "l_extendedprice": 1000, "l_discount": 0.1}, {"l_orderkey": 2000, "l_returnflag": "N", "l_extendedprice": 500, "l_discount": 0}]
  let start_date = "1993-10-01"
  let end_date = "1994-01-01"
  def _q0():
  let _src = customer
  let _rows = _query(_src, [{ 'items': orders, 'on': lambda c, o: ((o["o_custkey"] == c["c_custkey"])) }, { 'items': lineitem, 'on': lambda c, o, l: ((l["l_orderkey"] == o["o_orderkey"])) }, { 'items': nation, 'on': lambda c, o, l, n: ((n["n_nationkey"] == c["c_nationkey"])) }], { 'select': lambda c, o, l, n: (c, o, l, n), 'where': lambda c, o, l, n: ((((o["o_orderdate"] >= start_date) and (o["o_orderdate"] < end_date)) and (l["l_returnflag"] == "R"))) })
  let _groups = _group_by(_rows, lambda c, o, l, n: ({"c_custkey": c["c_custkey"], "c_name": c["c_name"], "c_acctbal": c["c_acctbal"], "c_address": c["c_address"], "c_phone": c["c_phone"], "c_comment": c["c_comment"], "n_name": n["n_name"]}))
  let items = _groups
  let items = sorted(items, key=lambda g: _sort_key((-_sum([ (x[2]["l_extendedprice"] * ((1 - x[2]["l_discount"]))) for x in g ]))))
  return [ {"c_custkey": _get(_get(g, "key"), "c_custkey"), "c_name": _get(_get(g, "key"), "c_name"), "revenue": _sum([ (x[2]["l_extendedprice"] * ((1 - x[2]["l_discount"]))) for x in g ]), "c_acctbal": _get(_get(g, "key"), "c_acctbal"), "n_name": _get(_get(g, "key"), "n_name"), "c_address": _get(_get(g, "key"), "c_address"), "c_phone": _get(_get(g, "key"), "c_phone"), "c_comment": _get(_get(g, "key"), "c_comment")} for g in items ]
  let result = _q0()
  print(*result)
}
