let PI: float = 3.141592653589793
let TWO_PI: float = 6.283185307179586
fun _mod(x: float, m: float): float {
  return (x - ((((x / m)) as int as float) * m))
}
fun _sin(x: float): float {
  let y: float = (_mod((x + PI), TWO_PI) - PI)
  let y2: float = (y * y)
  let y3: float = (y2 * y)
  let y5: float = (y3 * y2)
  let y7: float = (y5 * y2)
  return (((y - (y3 / 6)) + (y5 / 120)) - (y7 / 5040))
}
fun _cos(x: float): float {
  let y: float = (_mod((x + PI), TWO_PI) - PI)
  let y2: float = (y * y)
  let y4: float = (y2 * y2)
  let y6: float = (y4 * y2)
  return (((1 - (y2 / 2)) + (y4 / 24)) - (y6 / 720))
}
type Point3 {
  x: float
  y: float
  z: float
}
type Point2 {
  x: int
  y: int
}
let nodes: list<Point3> = [Point3 {x: -1, y: -1, z: -1}, Point3 {x: -1, y: -1, z: 1}, Point3 {x: -1, y: 1, z: -1}, Point3 {x: -1, y: 1, z: 1}, Point3 {x: 1, y: -1, z: -1}, Point3 {x: 1, y: -1, z: 1}, Point3 {x: 1, y: 1, z: -1}, Point3 {x: 1, y: 1, z: 1}]
let edges: list<list<int>> = [[0, 1], [1, 3], [3, 2], [2, 0], [4, 5], [5, 7], [7, 6], [6, 4], [0, 4], [1, 5], [2, 6], [3, 7]]
fun rotate(p: Point3, ax: float, ay: float): Point3 {
  let sinx: float = _sin(ax)
  let cosx: float = _cos(ax)
  let siny: float = _sin(ay)
  let cosy: float = _cos(ay)
  let x1: float = p.x
  let y1: float = ((p.y * cosx) - (p.z * sinx))
  let z1: float = ((p.y * sinx) + (p.z * cosx))
  let x2: float = ((x1 * cosy) + (z1 * siny))
  let z2: float = ((-x1 * siny) + (z1 * cosy))
  return Point3 {x: x2, y: y1, z: z2}
}
let width: int = 40
let height: int = 20
let distance: float = 3
let scale: float = 8
fun project(p: Point3): Point2 {
  let factor: float = (scale / ((p.z + distance)))
  let x: int = (((p.x * factor)) as int + (width / 2))
  let y: int = (((-p.y * factor)) as int + (height / 2))
  return Point2 {x: x, y: y}
}
fun clearGrid(): list<list<string>> {
  var g: list<list<string>>
  var y: int = 0
  while (y < height) {
    var row: list<string>
    var x: int = 0
    while (x < width) {
      row = append(row, " ")
      x = (x + 1)
    }
    g = append(g, row)
    y = (y + 1)
  }
  return g
}
fun drawPoint(g: list<list<string>>, x: int, y: int, ch: string): void {
  if ((((x >= 0) && (x < width)) && (y >= 0)) && (y < height)) {
    var row: list<string> = g[y]
    row[x] = ch
    g[y] = row
  }
}
fun bresenham(x0: int, y0: int, x1: int, y1: int, g: list<list<string>>, ch: string): void {
  var dx: int = (x1 - x0)
  if (dx < 0) {
    dx = -dx
  }
  var dy: int = (y1 - y0)
  if (dy < 0) {
    dy = -dy
  }
  var sx: int = -1
  if (x0 < x1) {
    sx = 1
  }
  var sy: int = -1
  if (y0 < y1) {
    sy = 1
  }
  var err: int = (dx - dy)
  while true {
    drawPoint(g, x0, y0, ch)
    if ((x0 == x1) && (y0 == y1)) {
      break
    }
    var e2: int = (2 * err)
    if (e2 > (-dy)) {
      err = (err - dy)
      x0 = (x0 + sx)
    }
    if (e2 < dx) {
      err = (err + dx)
      y0 = (y0 + sy)
    }
  }
}
fun render(g: list<list<string>>): string {
  var out: string = ""
  var y: int = 0
  while (y < height) {
    var line: string = ""
    var x: int = 0
    while (x < width) {
      line = (line + g[y][x])
      x = (x + 1)
    }
    out = ((out + line) + "\n")
    y = (y + 1)
  }
  return out
}
fun main(): void {
  var f: int = 0
  while (f < 10) {
    var grid: list<list<string>> = clearGrid()
    var rot: list<Point2>
    var i: int = 0
    var ay: float = (((PI / 4)) + (((f as float) * PI) / 10))
    while (i < len(nodes)) {
      let p: Point3 = rotate(nodes[i], (PI / 4), ay)
      let pp: Point2 = project(p)
      rot = append(rot, pp)
      i = (i + 1)
    }
    var e: int = 0
    while (e < len(edges)) {
      let a: int = edges[e][0]
      let b: int = edges[e][1]
      let p1: Point2 = rot[a]
      let p2: Point2 = rot[b]
      bresenham(p1.x, p1.y, p2.x, p2.y, grid, "#")
      e = (e + 1)
    }
    print(render(grid))
    f = (f + 1)
  }
}
main()
