fun absf(x: float): float {
  if (x < 0) {
    return -x
  }
  return x
}
fun maxf(a: float, b: float): float {
  if (a > b) {
    return a
  }
  return b
}
fun minf(a: float, b: float): float {
  if (a < b) {
    return a
  }
  return b
}
fun max3(a: float, b: float, c: float): float {
  var m: float = a
  if (b > m) {
    m = b
  }
  if (c > m) {
    m = c
  }
  return m
}
fun min3(a: float, b: float, c: float): float {
  var m: float = a
  if (b < m) {
    m = b
  }
  if (c < m) {
    m = c
  }
  return m
}
type Point {
  x: float
  y: float
}
type QuadSpline {
  c0: float
  c1: float
  c2: float
}
type QuadCurve {
  x: QuadSpline
  y: QuadSpline
}
type TestRes {
  exclude: bool
  accept: bool
  intersect: Point
}
fun subdivideQuadSpline(q: QuadSpline, t: float): list<QuadSpline> {
  let s: float = (1 - t)
  var u: QuadSpline = QuadSpline {c0: q.c0, c1: 0, c2: 0}
  var v: QuadSpline = QuadSpline {c0: 0, c1: 0, c2: q.c2}
  u.c1 = ((s * q.c0) + (t * q.c1))
  v.c1 = ((s * q.c1) + (t * q.c2))
  u.c2 = ((s * u.c1) + (t * v.c1))
  v.c0 = u.c2
  return [u, v]
}
fun subdivideQuadCurve(q: QuadCurve, t: float): list<QuadCurve> {
  let xs: list<QuadSpline> = subdivideQuadSpline(q.x, t)
  let ys: list<QuadSpline> = subdivideQuadSpline(q.y, t)
  var u: QuadCurve = QuadCurve {x: xs[0], y: ys[0]}
  var v: QuadCurve = QuadCurve {x: xs[1], y: ys[1]}
  return [u, v]
}
fun rectsOverlap(xa0: float, ya0: float, xa1: float, ya1: float, xb0: float, yb0: float, xb1: float, yb1: float): bool {
  return ((((xb0 <= xa1) && (xa0 <= xb1)) && (yb0 <= ya1)) && (ya0 <= yb1))
}
fun testIntersect(p: QuadCurve, q: QuadCurve, tol: float): TestRes {
  let pxmin: float = min3(p.x.c0, p.x.c1, p.x.c2)
  let pymin: float = min3(p.y.c0, p.y.c1, p.y.c2)
  let pxmax: float = max3(p.x.c0, p.x.c1, p.x.c2)
  let pymax: float = max3(p.y.c0, p.y.c1, p.y.c2)
  let qxmin: float = min3(q.x.c0, q.x.c1, q.x.c2)
  let qymin: float = min3(q.y.c0, q.y.c1, q.y.c2)
  let qxmax: float = max3(q.x.c0, q.x.c1, q.x.c2)
  let qymax: float = max3(q.y.c0, q.y.c1, q.y.c2)
  var res: TestRes = TestRes {exclude: true, accept: false, intersect: Point {x: 0, y: 0}}
  if rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax) {
    res.exclude = false
    let xmin: float = maxf(pxmin, qxmin)
    let xmax: float = minf(pxmax, qxmax)
    if ((xmax - xmin) <= tol) {
      let ymin: float = maxf(pymin, qymin)
      let ymax: float = minf(pymax, qymax)
      if ((ymax - ymin) <= tol) {
        res.accept = true
        res.intersect.x = (0.5 * ((xmin + xmax)))
        res.intersect.y = (0.5 * ((ymin + ymax)))
      }
    }
  }
  return res
}
fun seemsToBeDuplicate(pts: list<Point>, xy: Point, spacing: float): bool {
  var i: int = 0
  while (i < len(pts)) {
    let pt: Point = pts[i]
    if ((absf((pt.x - xy.x)) < spacing) && (absf((pt.y - xy.y)) < spacing)) {
      return true
    }
    i = (i + 1)
  }
  return false
}
fun findIntersects(p: QuadCurve, q: QuadCurve, tol: float, spacing: float): list<Point> {
  var inters: list<Point>
  var workload: list<map<string, QuadCurve>> = [{"p": p, "q": q}]
  while (len(workload) > 0) {
    let idx: int = (len(workload) - 1)
    let work: map<string, QuadCurve> = workload[idx]
    workload = workload[end]
    let res: TestRes = testIntersect(work["p"], work["q"], tol)
    let excl: bool = res.exclude
    let acc: bool = res.accept
    let inter: Point = res.intersect
    if acc {
      if !seemsToBeDuplicate(inters, inter, spacing) {
        inters = append(inters, inter)
      }
    } else     if !excl {
      let ps: list<QuadCurve> = subdivideQuadCurve(work["p"], 0.5)
      let qs: list<QuadCurve> = subdivideQuadCurve(work["q"], 0.5)
      let p0: QuadCurve = ps[0]
      let p1: QuadCurve = ps[1]
      let q0: QuadCurve = qs[0]
      let q1: QuadCurve = qs[1]
      let p0a: QuadCurve = p0
      let q0a: QuadCurve = q0
      let p1a: QuadCurve = p1
      let q1a: QuadCurve = q1
      workload = append(workload, {"p": p0a, "q": q0a})
      workload = append(workload, {"p": p0, "q": q1a})
      workload = append(workload, {"p": p1a, "q": q0})
      workload = append(workload, {"p": p1, "q": q1})
    }
  }
  return inters
}
fun main() {
  let p: QuadCurve = QuadCurve {x: QuadSpline {c0: -1, c1: 0, c2: 1}, y: QuadSpline {c0: 0, c1: 10, c2: 0}}
  let q: QuadCurve = QuadCurve {x: QuadSpline {c0: 2, c1: -8, c2: 2}, y: QuadSpline {c0: 1, c1: 2, c2: 3}}
  let tol: float = 1e-07
  let spacing: float = (tol * 10)
  let inters: list<Point> = findIntersects(p, q, tol, spacing)
  var i: int = 0
  while (i < len(inters)) {
    let pt: Point = inters[i]
    print((((("(" + str(pt.x)) + ", ") + str(pt.y)) + ")"))
    i = (i + 1)
  }
}
main()
