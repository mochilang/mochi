// Generated by Mochi Zig transpiler on 2025-07-21 14:42 +0000
const std = @import("std");
const Nation = struct {
    n_nationkey: i64,
    n_name: []u8,
};
const Customer = struct {
    c_custkey: i64,
    c_name: []u8,
    c_acctbal: f64,
    c_nationkey: i64,
    c_address: []u8,
    c_phone: []u8,
    c_comment: []u8,
};
const Order = struct {
    o_orderkey: i64,
    o_custkey: i64,
    o_orderdate: []u8,
};
const Lineitem = struct {
    l_orderkey: i64,
    l_returnflag: []u8,
    l_extendedprice: f64,
    l_discount: f64,
};
const Group0 = struct {
    key: std.StringHashMap(i64),
    items: []Customer,
};
pub fn main() void {
    const nation: [_]Nation = [_]Nation{.{.n_nationkey = 1, .n_name = "BRAZIL"}};
    const customer: [_]Customer = [_]Customer{.{.c_custkey = 1, .c_name = "Alice", , .c_nationkey = 1, .c_address = "123 St", .c_phone = "123-456", .c_comment = "Loyal"}};
    const orders: [_]Order = [_]Order{.{.o_orderkey = 1000, .o_custkey = 1, .o_orderdate = "1993-10-15"}, .{.o_orderkey = 2000, .o_custkey = 1, .o_orderdate = "1994-01-02"}};
    const lineitem: [_]Lineitem = [_]Lineitem{.{.l_orderkey = 1000, .l_returnflag = "R", , }, .{.l_orderkey = 2000, .l_returnflag = "N", , }};
    const start_date = "1993-10-01";
    const end_date = "1994-01-01";
    const result = blk: {
        const groups_map = std.AutoHashMap(std.StringHashMap(i64), std.ArrayList(Customer)).init(std.heap.page_allocator);
        for (customer) |c| {
            const k = blk: {
                const m = std.StringHashMap(i64).init(std.heap.page_allocator);
                m.put("c_custkey", c.c_custkey);
                m.put("c_name", c.c_name);
                m.put("c_acctbal", c.c_acctbal);
                m.put("c_address", c.c_address);
                m.put("c_phone", c.c_phone);
                m.put("c_comment", c.c_comment);
                m.put("n_name", n.n_name);
                break :blk m;
            };
            if (groups_map.getPtr(k)) {
            }
        }
        const groups = std.ArrayList(Group0).init(std.heap.page_allocator);
        const it = groups_map.iterator();
        it.next()kv{
            groups.append(.{.key = kv.key, .items = kv.value.toOwnedSlice()});
        }
        const arr = groups.toOwnedSlice();
        const result = std.ArrayList(std.StringHashMap(i64)).init(std.heap.page_allocator);
        for (arr) |g| {
            result.append(blk: {
                const m = std.StringHashMap(i64).init(std.heap.page_allocator);
                m.put("c_custkey", g.key.c_custkey);
                m.put("c_name", g.key.c_name);
                m.put("revenue", sum(blk: {
                    const arr = std.ArrayList(i64).init(std.heap.page_allocator);
                    for (g) |x| {
                        arr.append(x.l.l_extendedprice + 1 + x.l.l_discount);
                    }
                    const tmp = arr.toOwnedSlice();
                    break :blk tmp;
                }));
                m.put("c_acctbal", g.key.c_acctbal);
                m.put("n_name", g.key.n_name);
                m.put("c_address", g.key.c_address);
                m.put("c_phone", g.key.c_phone);
                m.put("c_comment", g.key.c_comment);
                break :blk m;
            });
        }
        const tmp = result.toOwnedSlice();
        break :blk tmp;
    };
    std.io.getStdOut().writer().print("{any}\n", .{result});
}
