// Generated by Mochi transpiler v0.10.34 on 2025-07-22 06:19 +0700
use std::collections::HashMap;
#[derive(Clone)]
struct Group<K, V> {
    key: K,
    items: Vec<V>,
}
#[derive(Debug, Clone)]
struct ItemsItem {
    a: String,
    b: i64,
    val: i64,
}
impl std::fmt::Display for ItemsItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"a\": \"{}\"", self.a)?;
        write!(f, ", ")?;
        write!(f, "\"b\": {}", self.b)?;
        write!(f, ", ")?;
        write!(f, "\"val\": {}", self.val)?;
        write!(f, "}}")
    }
}
#[derive(Debug, Clone)]
struct GroupKey {
    a: String,
    b: i64,
}
impl std::fmt::Display for GroupKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"a\": \"{}\"", self.a)?;
        write!(f, ", ")?;
        write!(f, "\"b\": {}", self.b)?;
        write!(f, "}}")
    }
}
#[derive(Debug, Clone)]
struct QueryItem {
    a: String,
    b: i64,
    total: i64,
}
impl std::fmt::Display for QueryItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"a\": \"{}\"", self.a)?;
        write!(f, ", ")?;
        write!(f, "\"b\": {}", self.b)?;
        write!(f, ", ")?;
        write!(f, "\"total\": {}", self.total)?;
        write!(f, "}}")
    }
}
fn main() {
    let items: Vec<ItemsItem> = vec![ItemsItem {a: String::from("x"), b: 1, val: 2}, ItemsItem {a: String::from("x"), b: 2, val: 3}, ItemsItem {a: String::from("y"), b: 1, val: 4}, ItemsItem {a: String::from("y"), b: 2, val: 1}];
    let grouped: Vec<QueryItem> = {
        let mut _q: Vec<QueryItem> = Vec::new();
        let mut _tmp: Vec<(i64, QueryItem)> = Vec::new();
        let mut _groups: HashMap<String, Group<GroupKey, ItemsItem>> = HashMap::new();
        let mut _order: Vec<String> = Vec::new();
        for i in &items {
            let key = GroupKey {a: i.a.clone(), b: i.b}.clone();
            let ks = format!("{:?}", &key);
            let e = _groups.entry(ks.clone()).or_insert_with(|| {
                _order.push(ks.clone());
                Group::<GroupKey, ItemsItem> {key: key.clone(), items: Vec::new()}
            });
            e.items.push(i.clone());
        }
        for ks in _order {
            let g = &_groups[&ks];
            _tmp.push((-{
                let mut _q: Vec<i64> = Vec::new();
                for x in g.items.clone() {
                    _q.push(x.val);
                }
                _q
            }.iter().map(|x| *x as f64).sum::<f64>(), QueryItem {a: String::from(g.key.clone().a), b: g.key.clone().b, total: {
                let mut _q: Vec<i64> = Vec::new();
                for x in g.items.clone() {
                    _q.push(x.val);
                }
                _q
            }.iter().map(|x| *x as f64).sum::<f64>()}));
        }
        _tmp.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
        for (_, v) in _tmp {
            _q.push(v);
        }
        _q
    };
    println!("{}", { let tmp = grouped; tmp.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(" ") });
}
