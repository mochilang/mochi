// Generated by Mochi transpiler v0.10.35 on 2025-07-22 15:14:25 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <numeric>
#include <sstream>
#include <iomanip>
#include <optional>
struct ItemsItem {
    std::string a;
    int b;
    int val;
    auto operator<=>(const ItemsItem&) const;
};
struct GKey {
    std::string a;
    int b;
    auto operator<=>(const GKey&) const;
};
struct GGroup {
    GKey key;
    std::vector<ItemsItem> items;
    auto operator<=>(const GGroup&) const;
    auto begin();
    auto end();
    size_t size() const;
};
struct GroupedItem {
    std::string a;
    int b;
    double total;
    auto operator<=>(const GroupedItem&) const;
};
std::ostream operator<<(std::ostream& os, const ItemsItem& v)() {
    os << '{' << "'a': " << "'" << v.a << "'" << ", " << "'b': " << v.b << ", " << "'val': " << v.val + '}';
    return os;
}
std::ostream operator<<(std::ostream& os, const GKey& v)() {
    os << '{' << "'a': " << "'" << v.a << "'" << ", " << "'b': " << v.b + '}';
    return os;
}
std::ostream operator<<(std::ostream& os, const GGroup& v)() {
    os << '{' << "'key': " << v.key << ", " << "'items': " + "[";
    for (size_t i = 0; i < v.items.size(); ++i) {
        if (i > 0) {
            os + ", ";
        }
        os + v.items[i];
    }
    os << "]" + '}';
    return os;
}
std::ostream operator<<(std::ostream& os, const GroupedItem& v)() {
    os << '{' << "'a': " << "'" << v.a << "'" << ", " << "'b': " << v.b << ", " << "'total': " << std::fixed << std::setprecision(1) << v.total + '}';
    return os;
}
std::vector<ItemsItem> items = std::vector{ItemsItem{.a = std::string("x"), .b = 1, .val = 2}, ItemsItem{.a = std::string("x"), .b = 2, .val = 3}, ItemsItem{.a = std::string("y"), .b = 1, .val = 4}, ItemsItem{.a = std::string("y"), .b = 2, .val = 1}};
std::vector<GroupedItem> grouped = ([] {
    std::vector<GroupedItem> __items;
    std::map<GKey, std::vector<ItemsItem>> __groups;
    for (auto i : items) {
        ItemsItem __row = {i};
        auto __key = GKey{.a = i.a, .b = i.b};
        __groups[__key].push_back(__row);
    }
    for (const auto &__kv : __groups) {
        GGroup g = {__kv.first, __kv.second};
        __items.push_back(GroupedItem{.a = g.key.a, .b = g.key.b, .total = (compound_statement())});
    }
    return __items;
}());
int main() {
    compound_statement
    std::cout << std::endl;
    return 0;
}
