// Generated by Mochi Zig transpiler on 2025-07-21 14:42 +0000
const std = @import("std");

const Nation = struct {
    n_nationkey: i64,
    n_name: []const u8,
};

const Customer = struct {
    c_custkey: i64,
    c_name: []const u8,
    c_acctbal: f64,
    c_nationkey: i64,
    c_address: []const u8,
    c_phone: []const u8,
    c_comment: []const u8,
};

const Order = struct {
    o_orderkey: i64,
    o_custkey: i64,
    o_orderdate: []const u8,
};

const Lineitem = struct {
    l_orderkey: i64,
    l_returnflag: []const u8,
    l_extendedprice: f64,
    l_discount: f64,
};

const Group0 = struct {
    key: std.StringHashMap(i64),
    items: []Customer,
};

pub fn main() void {
    const nation: [1]Nation = [1]Nation{.{ .n_nationkey = 1, .n_name = "BRAZIL" }};
    const customer: [1]Customer = [1]Customer{.{ .c_custkey = 1, .c_name = "Alice", .c_acctbal = 100.0, .c_nationkey = 1, .c_address = "123 St", .c_phone = "123-456", .c_comment = "Loyal" }};
    const orders: [2]Order = [2]Order{.{ .o_orderkey = 1000, .o_custkey = 1, .o_orderdate = "1993-10-15" }, .{ .o_orderkey = 2000, .o_custkey = 1, .o_orderdate = "1994-01-02" }};
    const lineitem: [2]Lineitem = [2]Lineitem{.{ .l_orderkey = 1000, .l_returnflag = "R", .l_extendedprice = 1000.0, .l_discount = 0.1 }, .{ .l_orderkey = 2000, .l_returnflag = "N", .l_extendedprice = 500.0, .l_discount = 0.0 }};
    const start_date = "1993-10-01";
    const end_date = "1994-01-01";
    const result = blk: {
    var groups_map = std.AutoHashMap(std.StringHashMap(i64), std.ArrayList(Customer)).init(std.heap.page_allocator);
    for (customer) |c| {
        const k = blk: { var m = std.StringHashMap(i64).init(std.heap.page_allocator); m.put("c_custkey", c.c_custkey) catch unreachable; m.put("c_name", c.c_name) catch unreachable; m.put("c_acctbal", c.c_acctbal) catch unreachable; m.put("c_address", c.c_address) catch unreachable; m.put("c_phone", c.c_phone) catch unreachable; m.put("c_comment", c.c_comment) catch unreachable; m.put("n_name", n.n_name) catch unreachable; break :blk m; };
        if (groups_map.getPtr(k)) |arr| {
            arr.*.append(c) catch unreachable;
        } else {
            var tmp_arr = std.ArrayList(Customer).init(std.heap.page_allocator);
            tmp_arr.append(c) catch unreachable;
            groups_map.put(k, tmp_arr) catch unreachable;
        }
    }
    var groups = std.ArrayList(Group0).init(std.heap.page_allocator);
    var it = groups_map.iterator();
    while (it.next()) |kv| {
        groups.append(.{ .key = kv.key.*, .items = kv.value.toOwnedSlice() catch unreachable }) catch unreachable;
    }
    const arr = groups.toOwnedSlice() catch unreachable;
    var result = std.ArrayList(std.StringHashMap(i64)).init(std.heap.page_allocator);
    for (arr) |g| {
        result.append(blk: { var m = std.StringHashMap(i64).init(std.heap.page_allocator); m.put("c_custkey", g.key.c_custkey) catch unreachable; m.put("c_name", g.key.c_name) catch unreachable; m.put("revenue", sum(blk: {
    var arr = std.ArrayList(i64).init(std.heap.page_allocator);
    for (g) |x| {
        arr.append(x.l.l_extendedprice * 1 - x.l.l_discount) catch unreachable;
    }
    var tmp = arr.toOwnedSlice() catch unreachable;
    break :blk tmp;
})) catch unreachable; m.put("c_acctbal", g.key.c_acctbal) catch unreachable; m.put("n_name", g.key.n_name) catch unreachable; m.put("c_address", g.key.c_address) catch unreachable; m.put("c_phone", g.key.c_phone) catch unreachable; m.put("c_comment", g.key.c_comment) catch unreachable; break :blk m; }) catch unreachable;
    }
    var tmp = result.toOwnedSlice() catch unreachable;
    break :blk tmp;
};
    std.io.getStdOut().writer().print("{any}\n", .{result}) catch unreachable;
}
