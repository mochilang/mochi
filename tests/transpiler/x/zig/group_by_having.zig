// Generated by Mochi Zig transpiler on 2025-07-22 05:20 +0700
const std = @import("std");

const People = struct {
    name: []const u8,
    city: []const u8,
};

const Result = struct {
    city: []const u8,
    num: i64,
};

pub fn main() void {
    const people = [_]People{
        .{ .name = "Alice", .city = "Paris" },
        .{ .name = "Bob", .city = "Hanoi" },
        .{ .name = "Charlie", .city = "Paris" },
        .{ .name = "Diana", .city = "Hanoi" },
        .{ .name = "Eve", .city = "Paris" },
        .{ .name = "Frank", .city = "Hanoi" },
        .{ .name = "George", .city = "Paris" },
    };
    var groups_map = std.StringHashMap(std.ArrayList(People)).init(std.heap.page_allocator);
    for (people) |p| {
        const k = p.city;
        if (groups_map.getPtr(k)) |arr| {
            arr.*.append(p) catch unreachable;
        } else {
            var tmp = std.ArrayList(People).init(std.heap.page_allocator);
            tmp.append(p) catch unreachable;
            groups_map.put(k, tmp) catch unreachable;
        }
    }
    var groups = std.ArrayList(struct{ key: []const u8, items: []People }).init(std.heap.page_allocator);
    var it = groups_map.iterator();
    while (it.next()) |kv| {
        groups.append(.{ .key = kv.key_ptr.*, .items = kv.value_ptr.*.toOwnedSlice() catch unreachable }) catch unreachable;
    }
    const arr = groups.toOwnedSlice() catch unreachable;
    var result = std.ArrayList(Result).init(std.heap.page_allocator);
    for (arr) |g| {
        if (@as(i64, g.items.len) >= 4) {
            result.append(.{ .city = g.key, .num = @as(i64, g.items.len) }) catch unreachable;
        }
    }
    var tmp = result.toOwnedSlice() catch unreachable;
    const __j = std.json.stringifyAlloc(std.heap.page_allocator, tmp, .{ .indent = .{ .spaces = 2 } }) catch unreachable;
    defer std.heap.page_allocator.free(__j);
    std.io.getStdOut().writer().print("{s}\n", .{__j}) catch unreachable;
}
