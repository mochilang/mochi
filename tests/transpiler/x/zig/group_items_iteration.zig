// Generated by Mochi Zig transpiler on 2025-07-21 10:57 +0000
const std = @import("std");

const Data = struct {
    tag: []const u8,
    val: i64,
};

const Group0 = struct {
    key: []const u8,
    items: []Data,
};

pub fn main() void {
    const data: [_]Data = [_]Data{.{ .tag = "a", .val = 1 }, .{ .tag = "a", .val = 2 }, .{ .tag = "b", .val = 3 }};
    const groups = blk: {
    var groups_map = std.AutoHashMap([]const u8, std.ArrayList(Data)).init(std.heap.page_allocator);
    for (data) |d| {
        const k = d.tag;
        if (groups_map.getPtr(k)) |arr| {
            arr.*.append(d) catch unreachable;
        } else {
            var tmp_arr = std.ArrayList(Data).init(std.heap.page_allocator);
            tmp_arr.append(d) catch unreachable;
            groups_map.put(k, tmp_arr) catch unreachable;
        }
    }
    var groups = std.ArrayList(Group0).init(std.heap.page_allocator);
    var it = groups_map.iterator();
    while (it.next()) |kv| {
        groups.append(.{ .key = kv.key.*, .items = kv.value.toOwnedSlice() catch unreachable }) catch unreachable;
    }
    const arr = groups.toOwnedSlice() catch unreachable;
    var result = std.ArrayList(i64).init(std.heap.page_allocator);
    for (arr) |g| {
        result.append(g) catch unreachable;
    }
    var tmp = result.toOwnedSlice() catch unreachable;
    break :blk tmp;
};
    var tmp = [_]i64{};
    for (groups) |g| {
        var total: i64 = 0;
        for (g.items) |x| {
            total = total + x.val;
        }
        tmp = append(tmp, blk: { var m = std.StringHashMap(i64).init(std.heap.page_allocator); m.put("tag", g.key) catch unreachable; m.put("total", total) catch unreachable; break :blk m; });
    }
    const result: []i64 = blk: {
    var arr = std.ArrayList(struct{key: i64, val: i64}).init(std.heap.page_allocator);
    for (tmp) |r| {
        arr.append(.{ .key = r.tag, .val = r }) catch unreachable;
    }
    var tmp = arr.toOwnedSlice() catch unreachable;
    std.sort.sort(struct{key: i64, val: i64}, tmp, {}, struct{fn lt(ctx: void, a: struct{key: i64, val: i64}, b: struct{key: i64, val: i64}) bool { return a.key < b.key; } }.lt);
    var result = std.ArrayList(i64).init(std.heap.page_allocator);
    for (tmp) |it| { result.append(it.val) catch unreachable; }
    tmp = result.toOwnedSlice() catch unreachable;
    break :blk tmp;
};
    try std.io.getStdOut().writer().print("{any}\n", .{result});
}
