// Generated by Mochi Zig transpiler on 2025-07-22 10:01 +0700
const std = @import("std");

const Entry2 = struct {
    a: i64,
    b: i64,
    total: i64,
};

const Item = struct {
    a: []const u8,
    b: i64,
    val: i64,
};

const Group0 = struct {
    key: std.StringHashMap(i64),
    items: []Item,
};

pub fn main() void {
    const items: [4]Item = [4]Item{.{ .a = "x", .b = 1, .val = 2 }, .{ .a = "x", .b = 2, .val = 3 }, .{ .a = "y", .b = 1, .val = 4 }, .{ .a = "y", .b = 2, .val = 1 }};
    const grouped = blk: {
    var groups_map = std.AutoHashMap(std.StringHashMap(i64), std.ArrayList(Item)).init(std.heap.page_allocator);
    for (items) |i| {
        const k = blk: { var m = std.StringHashMap([]const u8).init(std.heap.page_allocator); m.put("a", i.a) catch unreachable; m.put("b", i.b) catch unreachable; break :blk m; };
        if (groups_map.getPtr(k)) |arr| {
            arr.*.append(i) catch unreachable;
        } else {
            var tmp_arr = std.ArrayList(Item).init(std.heap.page_allocator);
            tmp_arr.append(i) catch unreachable;
            groups_map.put(k, tmp_arr) catch unreachable;
        }
    }
    var groups = std.ArrayList(Group0).init(std.heap.page_allocator);
    var it = groups_map.iterator();
    while (it.next()) |kv| {
        groups.append(.{ .key = kv.key.*, .items = kv.value.toOwnedSlice() catch unreachable }) catch unreachable;
    }
    const arr = groups.toOwnedSlice() catch unreachable;
    var result = std.ArrayList(struct{key: i64, val: Entry2}).init(std.heap.page_allocator);
    for (arr) |g| {
        result.append(.{ .key = sum(blk: {
    var arr = std.ArrayList(i64).init(std.heap.page_allocator);
    for (g) |x| {
        arr.append(x.val) catch unreachable;
    }
    var tmp = arr.toOwnedSlice() catch unreachable;
    break :blk tmp;
}), .val = .{ .a = g.key.a, .b = g.key.b, .total = sum(blk: {
    var arr = std.ArrayList(i64).init(std.heap.page_allocator);
    for (g) |x| {
        arr.append(x.val) catch unreachable;
    }
    var tmp = arr.toOwnedSlice() catch unreachable;
    break :blk tmp;
}) } }) catch unreachable;
    }
    var tmp = result.toOwnedSlice() catch unreachable;
    std.sort.sort(struct{key: i64, val: Entry2}, tmp, {}, struct{fn lt(ctx: void, a: struct{key: i64, val: Entry2}, b: struct{key: i64, val: Entry2}) bool { return a.key > b.key; } }.lt);
    var arr2 = std.ArrayList(Entry2).init(std.heap.page_allocator);
    for (tmp) |it| { arr2.append(it.val) catch unreachable; }
    tmp = arr2.toOwnedSlice() catch unreachable;
    break :blk tmp;
};
    std.io.getStdOut().writer().print("{any}\n", .{grouped}) catch unreachable;
}
