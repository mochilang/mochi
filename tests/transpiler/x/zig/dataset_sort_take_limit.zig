// Generated by Mochi Zig transpiler on 2025-07-21 10:57 +0000
const std = @import("std");

const Product = struct {
    name: []const u8,
    price: i64,
};

pub fn main() void {
    const products: [_]Product = [_]Product{.{ .name = "Laptop", .price = 1500 }, .{ .name = "Smartphone", .price = 900 }, .{ .name = "Tablet", .price = 600 }, .{ .name = "Monitor", .price = 300 }, .{ .name = "Keyboard", .price = 100 }, .{ .name = "Mouse", .price = 50 }, .{ .name = "Headphones", .price = 200 }};
    const expensive: []Product = blk: {
    var arr = std.ArrayList(struct{key: i64, val: Product}).init(std.heap.page_allocator);
    for (products) |p| {
        arr.append(.{ .key = p.price, .val = p }) catch unreachable;
    }
    var tmp = arr.toOwnedSlice() catch unreachable;
    std.sort.sort(struct{key: i64, val: Product}, tmp, {}, struct{fn lt(ctx: void, a: struct{key: i64, val: Product}, b: struct{key: i64, val: Product}) bool { return a.key > b.key; } }.lt);
    var result = std.ArrayList(Product).init(std.heap.page_allocator);
    for (tmp) |it| { result.append(it.val) catch unreachable; }
    tmp = result.toOwnedSlice() catch unreachable;
    var start: usize = 0;
    start = @intCast(usize, 1);
    var end: usize = tmp.len;
    end = @min(tmp.len, start + @intCast(usize, 3));
    tmp = tmp[start..end];
    break :blk tmp;
};
    try std.io.getStdOut().writer().print("{s}\n", .{"--- Top products (excluding most expensive) ---"});
    for (expensive) |item| {
        try std.io.getStdOut().writer().print("{any} {s} {any}\n", .{item.name, "costs $", item.price});
    }
}
