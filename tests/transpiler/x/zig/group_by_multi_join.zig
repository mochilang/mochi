// Generated by Mochi Zig transpiler on 2025-07-21 14:56 +0000
const std = @import("std");

const Entry3 = struct {
    part: i64,
    value: f64,
};

const Group0 = struct {
    key: i64,
    items: []Entry3,
};

const Entry5 = struct {
    part: i64,
    total: f64,
};

const Nation = struct {
    id: i64,
    name: []const u8,
};

const Supplier = struct {
    id: i64,
    nation: i64,
};

const Partsupp = struct {
    part: i64,
    supplier: i64,
    cost: f64,
    qty: i64,
};

pub fn main() void {
    const nations: [2]Nation = [2]Nation{.{ .id = 1, .name = "A" }, .{ .id = 2, .name = "B" }};
    const suppliers: [2]Supplier = [2]Supplier{.{ .id = 1, .nation = 1 }, .{ .id = 2, .nation = 2 }};
    const partsupp: [3]Partsupp = [3]Partsupp{.{ .part = 100, .supplier = 1, .cost = 10.0, .qty = 2 }, .{ .part = 100, .supplier = 2, .cost = 20.0, .qty = 1 }, .{ .part = 200, .supplier = 1, .cost = 5.0, .qty = 3 }};
    const filtered: []Entry3 = blk: {
    var arr = std.ArrayList(Entry3).init(std.heap.page_allocator);
    for (partsupp) |ps| {
        for (suppliers) |s| {
            for (nations) |n| {
                if (n.name == "A" and s.id == ps.supplier and n.id == s.nation) {
                    arr.append(.{ .part = ps.part, .value = ps.cost * ps.qty }) catch unreachable;
                }
            }
        }
    }
    var tmp = arr.toOwnedSlice() catch unreachable;
    break :blk tmp;
};
    const grouped = blk: {
    var groups_map = std.AutoHashMap(i64, std.ArrayList(Entry3)).init(std.heap.page_allocator);
    for (filtered) |x| {
        const k = x.part;
        if (groups_map.getPtr(k)) |arr| {
            arr.*.append(x) catch unreachable;
        } else {
            var tmp_arr = std.ArrayList(Entry3).init(std.heap.page_allocator);
            tmp_arr.append(x) catch unreachable;
            groups_map.put(k, tmp_arr) catch unreachable;
        }
    }
    var groups = std.ArrayList(Group0).init(std.heap.page_allocator);
    var it = groups_map.iterator();
    while (it.next()) |kv| {
        groups.append(.{ .key = kv.key.*, .items = kv.value.toOwnedSlice() catch unreachable }) catch unreachable;
    }
    const arr = groups.toOwnedSlice() catch unreachable;
    var result = std.ArrayList(Entry5).init(std.heap.page_allocator);
    for (arr) |g| {
        result.append(.{ .part = g.key, .total = sum(blk: {
    var arr = std.ArrayList(f64).init(std.heap.page_allocator);
    for (g) |r| {
        arr.append(r.value) catch unreachable;
    }
    var tmp = arr.toOwnedSlice() catch unreachable;
    break :blk tmp;
}) }) catch unreachable;
    }
    var tmp = result.toOwnedSlice() catch unreachable;
    break :blk tmp;
};
    std.io.getStdOut().writer().print("{any}\n", .{grouped}) catch unreachable;
}
