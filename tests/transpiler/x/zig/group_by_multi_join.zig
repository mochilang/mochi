// Generated by Mochi Zig transpiler on 2025-07-21 11:35 +0000
const std = @import("std");

const Nation = struct {
    id: i64,
    name: []const u8,
};

const Supplier = struct {
    id: i64,
    nation: i64,
};

const Partsupp = struct {
    part: i64,
    supplier: i64,
    cost: f64,
    qty: i64,
};

const Entry = struct {
    part: i64,
    value: i64,
};

const Group0 = struct {
    key: i64,
    items: []i64,
};

pub fn main() void {
    const nations: [_]Nation = [_]Nation{.{ .id = 1, .name = "A" }, .{ .id = 2, .name = "B" }};
    const suppliers: [_]Supplier = [_]Supplier{.{ .id = 1, .nation = 1 }, .{ .id = 2, .nation = 2 }};
    const partsupp: [_]Partsupp = [_]Partsupp{.{ .part = 100, .supplier = 1, .cost = 10.0, .qty = 2 }, .{ .part = 100, .supplier = 2, .cost = 20.0, .qty = 1 }, .{ .part = 200, .supplier = 1, .cost = 5.0, .qty = 3 }};
    const filtered: []Entry = blk: {
    var arr = std.ArrayList(Entry).init(std.heap.page_allocator);
    for (partsupp) |ps| {
        for (suppliers) |s| {
            for (nations) |n| {
                if (n.name == "A" && s.id == ps.supplier && n.id == s.nation) {
                    arr.append(.{ .part = ps.part, .value = ps.cost * ps.qty }) catch unreachable;
                }
            }
        }
    }
    var tmp = arr.toOwnedSlice() catch unreachable;
    break :blk tmp;
};
    const grouped = blk: {
    var groups_map = std.AutoHashMap(i64, std.ArrayList(i64)).init(std.heap.page_allocator);
    for (filtered) |x| {
        const k = x.part;
        if (groups_map.getPtr(k)) |arr| {
            arr.*.append(x) catch unreachable;
        } else {
            var tmp_arr = std.ArrayList(i64).init(std.heap.page_allocator);
            tmp_arr.append(x) catch unreachable;
            groups_map.put(k, tmp_arr) catch unreachable;
        }
    }
    var groups = std.ArrayList(Group0).init(std.heap.page_allocator);
    var it = groups_map.iterator();
    while (it.next()) |kv| {
        groups.append(.{ .key = kv.key.*, .items = kv.value.toOwnedSlice() catch unreachable }) catch unreachable;
    }
    const arr = groups.toOwnedSlice() catch unreachable;
    var result = std.ArrayList(std.StringHashMap(i64)).init(std.heap.page_allocator);
    for (arr) |g| {
        result.append(blk: { var m = std.StringHashMap(i64).init(std.heap.page_allocator); m.put("part", g.key) catch unreachable; m.put("total", sum(blk: {
    var arr = std.ArrayList(i64).init(std.heap.page_allocator);
    for (g) |r| {
        arr.append(r.value) catch unreachable;
    }
    var tmp = arr.toOwnedSlice() catch unreachable;
    break :blk tmp;
})) catch unreachable; break :blk m; }) catch unreachable;
    }
    var tmp = result.toOwnedSlice() catch unreachable;
    break :blk tmp;
};
    try std.io.getStdOut().writer().print("{any}\n", .{grouped});
}
