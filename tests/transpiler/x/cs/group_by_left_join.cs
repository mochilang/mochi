// Generated by Mochi 0.10.34 on 2025-07-21 22:29 +0700
using System;
using System.Collections.Generic;
using System.Linq;

struct Customer {
    public int id;
    public string name;
    public override string ToString() => $"{{'id': {id}, 'name': '{name}'}}";
}
struct Order {
    public int id;
    public int customerId;
    public override string ToString() => $"{{'id': {id}, 'customerId': {customerId}}}";
}
struct GRow {
    public Customer c;
    public Order o;
    public override string ToString() => $"{{'c': {c}, 'o': {o}}}";
}
struct GGroup {
    public string key;
    public GRow[] items;
    public override string ToString() => $"{{'key': '{key}', 'items': {items}}}";
}
struct GResult {
    public string name;
    public int count;
    public override string ToString() => $"{{'name': '{name}', 'count': {count}}}";
}
class Program {
    static Customer[] customers = new Customer[]{new Customer{id = 1, name = "Alice"}, new Customer{id = 2, name = "Bob"}, new Customer{id = 3, name = "Charlie"}};
    static Order[] orders = new Order[]{new Order{id = 100, customerId = 1}, new Order{id = 101, customerId = 1}, new Order{id = 102, customerId = 2}};
    static GResult[] stats = (from c in customers join o in orders on c.id equals o.customerId into oTmp from o in oTmp.DefaultIfEmpty() group new GRow{c = c, o = o} by c.name into gTmp let g = new GGroup{ key = gTmp.Key, items = gTmp.ToArray() } select new GResult{name = g.key, count = (from r in g.items where r.o select r).ToArray().Length}).ToArray();
    static void Main() {
        Console.WriteLine("--- Group Left Join ---");
        foreach (var s in stats) {
    Console.WriteLine(("[" + (string.Join(",", new object[]{s.name, "orders:", s.count}) + "]")));
}
    }
}
