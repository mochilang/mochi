// Generated by Mochi transpiler v0.10.34 on 2025-07-21 22:29 +0700
#[derive(Debug, Clone)]
struct CustomersItem {
    id: i64,
    name: String,
}
impl std::fmt::Display for CustomersItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"id\": {}", self.id)?;
        write!(f, ", ")?;
        write!(f, "\"name\": \"{}\"", self.name)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone)]
struct OrdersItem {
    id: i64,
    customerId: i64,
    total: i64,
}
impl std::fmt::Display for OrdersItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"id\": {}", self.id)?;
        write!(f, ", ")?;
        write!(f, "\"customerId\": {}", self.customerId)?;
        write!(f, ", ")?;
        write!(f, "\"total\": {}", self.total)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone)]
struct QueryItem {
    order: Option<OrdersItem>,
    customer: Option<CustomersItem>,
}
impl std::fmt::Display for QueryItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"order\": {:?}", self.order)?;
        write!(f, ", ")?;
        write!(f, "\"customer\": {:?}", self.customer)?;
        write!(f, "}}")
    }
}

fn main() {
    let customers: Vec<CustomersItem> = vec![CustomersItem {id: 1, name: String::from("Alice")}, CustomersItem {id: 2, name: String::from("Bob")}, CustomersItem {id: 3, name: String::from("Charlie")}, CustomersItem {id: 4, name: String::from("Diana")}];
    let orders: Vec<OrdersItem> = vec![OrdersItem {id: 100, customerId: 1, total: 250}, OrdersItem {id: 101, customerId: 2, total: 125}, OrdersItem {id: 102, customerId: 1, total: 300}, OrdersItem {id: 103, customerId: 5, total: 80}];
    let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); for o in &orders { let mut _matched = false; for c in &customers { if (o.customerId == c.id) { _matched = true; let o: Option<OrdersItem> = Some(o.clone()); let c: Option<CustomersItem> = Some(c.clone()); _q.push(QueryItem {order: o.clone(), customer: c.clone()}); } } if !_matched { let c: Option<CustomersItem> = None; let o: Option<OrdersItem> = Some(o.clone()); _q.push(QueryItem {order: o.clone(), customer: c.clone()}); } } for c in &customers { let mut _matched = false; for o in &orders { if (o.customerId == c.id) { _matched = true; break; } } if !_matched { let o: Option<OrdersItem> = None; let c: Option<CustomersItem> = Some(c.clone()); _q.push(QueryItem {order: o.clone(), customer: c.clone()}); } } _q };
    println!("{}", "--- Outer Join using syntax ---");
    for row in &result {
        if row.order.is_some() {
            if row.customer.is_some() {
                println!("{}", format!("{} {} {} {} {} {}", "Order", row.order.as_ref().unwrap().id, "by", row.customer.as_ref().unwrap().name, "- $", row.order.as_ref().unwrap().total).trim_end());
            } else {
                println!("{}", format!("{} {} {} {} {} {}", "Order", row.order.as_ref().unwrap().id, "by", "Unknown", "- $", row.order.as_ref().unwrap().total).trim_end());
            }
        } else {
            println!("{}", format!("{} {} {}", "Customer", row.customer.as_ref().unwrap().name, "has no orders").trim_end());
        }
    }
}
