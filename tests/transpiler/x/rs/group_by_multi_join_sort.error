rustc: exit status 1
error[E0425]: cannot find value `c_custkey` in this scope
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:573
    |
130 | ...l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c...
    |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `c_name` in this scope
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:599
    |
130 | ...let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c...
    |                                                        ^^^^^^ not found in this scope

error[E0425]: cannot find value `c_acctbal` in this scope
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:619
    |
130 | ...m([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment,...
    |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `c_address` in this scope
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:645
    |
130 | ...), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n....
    |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `c_phone` in this scope
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:671
    |
130 | ..._acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks...
    |                                                       ^^^^^^^ not found in this scope

error[E0425]: cannot find value `c_comment` in this scope
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:693
    |
130 | ... (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key...
    |                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find value `n_name` in this scope
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:719
    |
130 | ...), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry...
    |                                                        ^^^^^^ not found in this scope

warning: unnecessary parentheses around `if` condition
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:306
    |
130 | ...c::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_order...
    |                                                         ^                          ^
    |
    = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
    |
130 -     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
130 +     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if o.o_custkey == c.c_custkey { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
    |

warning: unnecessary parentheses around `if` condition
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:361
    |
130 | ...o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_natio...
    |                                                        ^                            ^
    |
help: remove these parentheses
    |
130 -     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
130 +     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if l.l_orderkey == o.o_orderkey { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
    |

warning: unnecessary parentheses around `if` condition
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:416
    |
130 | ..._orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_order...
    |                                                       ^                              ^
    |
help: remove these parentheses
    |
130 -     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
130 +     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if n.n_nationkey == c.c_nationkey { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
    |

warning: unnecessary parentheses around `if` condition
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:454
    |
130 | ...= c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::...
    |                          ^                                                                                        ^
    |
help: remove these parentheses
    |
130 -     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
130 +     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if ((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R") { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
    |

warning: unnecessary parentheses around method argument
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1114
    |
130 | ...c::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_c...
    |                                                 ^                                          ^
    |
help: remove these parentheses
    |
130 -     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
130 +     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push(x.l.l_extendedprice * (1 - x.l.l_discount)); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
    |

warning: unnecessary parentheses around method argument
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1347
    |
130 | ...c::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.k...
    |                                                 ^                                          ^
    |
help: remove these parentheses
    |
130 -     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
130 +     let result: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<HashMap<String, i64>, CustomerItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for c in &customer { for o in &orders { if (o.o_custkey == c.c_custkey) { for l in &lineitem { if (l.l_orderkey == o.o_orderkey) { for n in &nation { if (n.n_nationkey == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey), (c_name, c.c_name), (c_acctbal, c.c_acctbal), (c_address, c.c_address), (c_phone, c.c_phone), (c_comment, c.c_comment), (n_name, n.n_name)]).clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<HashMap<String, i64>, CustomerItem> { key: key.clone(), items: Vec::new() } }); e.items.push(c.clone()); } } } } } } } } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push(x.l.l_extendedprice * (1 - x.l.l_discount)); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
    |

error[E0308]: mismatched types
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:125:114
    |
125 | ...key: 1, c_name: String::from("Alice"), c_acctbal: 100, c_nationkey: 1, c_address: String::from("123 St"), c_phone: String::from("123-4...
    |                                                      ^^^ expected `f64`, found integer
    |
help: use a float literal
    |
125 |     let customer: Vec<CustomerItem> = vec![CustomerItem {c_custkey: 1, c_name: String::from("Alice"), c_acctbal: 100.0, c_nationkey: 1, c_address: String::from("123 St"), c_phone: String::from("123-456"), c_comment: String::from("Loyal")}];
    |                                                                                                                     ++

error[E0308]: mismatched types
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:127:126
    |
127 | ...l_returnflag: String::from("R"), l_extendedprice: 1000, l_discount: 0.1}, LineitemItem {l_orderkey: 2000, l_returnflag: String::from("...
    |                                                      ^^^^ expected `f64`, found integer
    |
help: use a float literal
    |
127 |     let lineitem: Vec<LineitemItem> = vec![LineitemItem {l_orderkey: 1000, l_returnflag: String::from("R"), l_extendedprice: 1000.0, l_discount: 0.1}, LineitemItem {l_orderkey: 2000, l_returnflag: String::from("N"), l_extendedprice: 500, l_discount: 0}];
    |                                                                                                                                  ++

error[E0308]: mismatched types
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:127:232
    |
127 | ...l_returnflag: String::from("N"), l_extendedprice: 500, l_discount: 0}];
    |                                                      ^^^ expected `f64`, found integer
    |
help: use a float literal
    |
127 |     let lineitem: Vec<LineitemItem> = vec![LineitemItem {l_orderkey: 1000, l_returnflag: String::from("R"), l_extendedprice: 1000, l_discount: 0.1}, LineitemItem {l_orderkey: 2000, l_returnflag: String::from("N"), l_extendedprice: 500.0, l_discount: 0}];
    |                                                                                                                                                                                                                                           ++

error[E0308]: mismatched types
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:127:249
    |
127 | ...ring::from("N"), l_extendedprice: 500, l_discount: 0}];
    |                                                       ^ expected `f64`, found integer
    |
help: use a float literal
    |
127 |     let lineitem: Vec<LineitemItem> = vec![LineitemItem {l_orderkey: 1000, l_returnflag: String::from("R"), l_extendedprice: 1000, l_discount: 0.1}, LineitemItem {l_orderkey: 2000, l_returnflag: String::from("N"), l_extendedprice: 500, l_discount: 0.0}];
    |                                                                                                                                                                                                                                                          ++

error[E0308]: mismatched types
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:474
    |
130 | ... == c.c_nationkey) { if (((o.o_orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap...
    |                               -------------    ^^^^^^^^^^- help: try using a conversion method: `.to_string()`
    |                               |                |
    |                               |                expected `String`, found `&str`
    |                               expected because this is `String`

error[E0308]: mismatched types
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:506
    |
130 | ...orderdate >= start_date) && (o.o_orderdate < end_date)) && (l.l_returnflag == "R")) { let key = HashMap::from([(c_custkey, c.c_custkey...
    |                                 -------------   ^^^^^^^^- help: try using a conversion method: `.to_string()`
    |                                 |               |
    |                                 |               expected `String`, found `&str`
    |                                 expected because this is `String`

error[E0609]: no field `l` on type `CustomerItem`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1117
    |
130 | ...c<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), Que...
    |                                                               ^ unknown field
    |
    = note: available fields are: `c_custkey`, `c_name`, `c_acctbal`, `c_nationkey`, `c_address` ... and 2 others

error[E0609]: no field `l` on type `CustomerItem`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1144
    |
130 | ...in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), QueryItem {c_custkey: g.key.cl...
    |                                                               ^ unknown field
    |
    = note: available fields are: `c_custkey`, `c_name`, `c_acctbal`, `c_nationkey`, `c_address` ... and 2 others

error[E0609]: no field `c_custkey` on type `HashMap<String, i64>`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1225
    |
130 | ...er().sum::<i64>(), QueryItem {c_custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec:...
    |                                                           ^^^^^^^^^ unknown field

error[E0609]: no field `c_name` on type `HashMap<String, i64>`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1258
    |
130 | ..._custkey: g.key.clone().c_custkey, c_name: g.key.clone().c_name, revenue: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone(...
    |                                                             ^^^^^^ unknown field

error[E0609]: no field `l` on type `CustomerItem`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1350
    |
130 | ...c<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_a...
    |                                                               ^ unknown field
    |
    = note: available fields are: `c_custkey`, `c_name`, `c_acctbal`, `c_nationkey`, `c_address` ... and 2 others

error[E0609]: no field `l` on type `CustomerItem`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1377
    |
130 | ...in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acc...
    |                                                               ^ unknown field
    |
    = note: available fields are: `c_custkey`, `c_name`, `c_acctbal`, `c_nationkey`, `c_address` ... and 2 others

error[E0308]: mismatched types
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1275
    |
130 | ...e: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push((x.l.l_extendedprice * (1 - x.l.l_discount))); } _q }.iter().sum::<i64>(), c...
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `i64`

error[E0609]: no field `c_acctbal` on type `HashMap<String, i64>`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1447
    |
130 | ...; } _q }.iter().sum::<i64>(), c_acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_...
    |                                                           ^^^^^^^^^ unknown field

error[E0609]: no field `n_name` on type `HashMap<String, i64>`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1480
    |
130 | ..._acctbal: g.key.clone().c_acctbal, n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c...
    |                                                             ^^^^^^ unknown field

error[E0609]: no field `c_address` on type `HashMap<String, i64>`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1513
    |
130 | ...n_name: g.key.clone().n_name, c_address: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})...
    |                                                           ^^^^^^^^^ unknown field

error[E0609]: no field `c_phone` on type `HashMap<String, i64>`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1547
    |
130 | ...ddress: g.key.clone().c_address, c_phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.parti...
    |                                                            ^^^^^^^ unknown field

error[E0609]: no field `c_comment` on type `HashMap<String, i64>`
   --> /workspace/mochi/tests/transpiler/x/rs/group_by_multi_join_sort.rs:130:1581
    |
130 | ...phone: g.key.clone().c_phone, c_comment: g.key.clone().c_comment})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) i...
    |                                                           ^^^^^^^^^ unknown field

error: aborting due to 25 previous errors; 6 warnings emitted

Some errors have detailed explanations: E0308, E0425, E0609.
For more information about an error, try `rustc --explain E0308`.
