// Generated by Mochi transpiler v0.10.34 on 2025-07-22 06:19 +0700
use std::collections::HashMap;
#[derive(Clone)]
struct Group<K, V> { key: K, items: Vec<V> }
#[derive(Debug, Clone)]
struct ItemsItem {
    a: String,
    b: i64,
    val: i64,
}
impl std::fmt::Display for ItemsItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"a\": \"{}\"", self.a)?;
        write!(f, ", ")?;
        write!(f, "\"b\": {}", self.b)?;
        write!(f, ", ")?;
        write!(f, "\"val\": {}", self.val)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone)]
struct GroupKey {
    a: String,
    b: i64,
}
impl std::fmt::Display for GroupKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"a\": \"{}\"", self.a)?;
        write!(f, ", ")?;
        write!(f, "\"b\": {}", self.b)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone)]
struct QueryItem {
    a: String,
    b: i64,
    total: i64,
}
impl std::fmt::Display for QueryItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"a\": \"{}\"", self.a)?;
        write!(f, ", ")?;
        write!(f, "\"b\": {}", self.b)?;
        write!(f, ", ")?;
        write!(f, "\"total\": {}", self.total)?;
        write!(f, "}}")
    }
}

fn main() {
    let items: Vec<ItemsItem> = vec![ItemsItem {a: String::from("x"), b: 1, val: 2}, ItemsItem {a: String::from("x"), b: 2, val: 3}, ItemsItem {a: String::from("y"), b: 1, val: 4}, ItemsItem {a: String::from("y"), b: 2, val: 1}];
    let grouped: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); let mut _tmp: Vec<(i64, QueryItem)> = Vec::new(); let mut _groups: HashMap<String, Group<GroupKey, ItemsItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for i in &items { let key = GroupKey {a: i.a.clone(), b: i.b}.clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<GroupKey, ItemsItem> { key: key.clone(), items: Vec::new() } }); e.items.push(i.clone()); } for ks in _order { let g = &_groups[&ks]; _tmp.push((-{ let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push(x.val); } _q }.iter().map(|x| *x as f64).sum::<f64>(), QueryItem {a: String::from(g.key.clone().a), b: g.key.clone().b, total: { let mut _q: Vec<i64> = Vec::new(); for x in g.items.clone() { _q.push(x.val); } _q }.iter().map(|x| *x as f64).sum::<f64>()})); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
    println!("{}", { let tmp = grouped; tmp.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(" ") });
}
