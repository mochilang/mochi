// Generated by Mochi transpiler v0.10.33 on 2025-07-21 18:06 +0700
use std::collections::HashMap;
#[derive(Clone)]
struct Group<K, V> { key: K, items: Vec<V> }
#[derive(Debug, Clone)]
struct NationsItem {
    id: i64,
    name: String,
}
impl std::fmt::Display for NationsItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"id\": {}", self.id)?;
        write!(f, ", ")?;
        write!(f, "\"name\": \"{}\"", self.name)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone)]
struct SuppliersItem {
    id: i64,
    nation: i64,
}
impl std::fmt::Display for SuppliersItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"id\": {}", self.id)?;
        write!(f, ", ")?;
        write!(f, "\"nation\": {}", self.nation)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone)]
struct PartsuppItem {
    part: i64,
    supplier: i64,
    cost: f64,
    qty: i64,
}
impl std::fmt::Display for PartsuppItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"part\": {}", self.part)?;
        write!(f, ", ")?;
        write!(f, "\"supplier\": {}", self.supplier)?;
        write!(f, ", ")?;
        write!(f, "\"cost\": {}", self.cost)?;
        write!(f, ", ")?;
        write!(f, "\"qty\": {}", self.qty)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone)]
struct QueryItem {
    part: i64,
    value: f64,
}
impl std::fmt::Display for QueryItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"part\": {}", self.part)?;
        write!(f, ", ")?;
        write!(f, "\"value\": {}", self.value)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone)]
struct QueryItem1 {
    part: i64,
    total: f64,
}
impl std::fmt::Display for QueryItem1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"part\": {}", self.part)?;
        write!(f, ", ")?;
        write!(f, "\"total\": {}", self.total)?;
        write!(f, "}}")
    }
}

fn main() {
    let nations: Vec<NationsItem> = vec![NationsItem {id: 1, name: String::from("A")}, NationsItem {id: 2, name: String::from("B")}];
    let suppliers: Vec<SuppliersItem> = vec![SuppliersItem {id: 1, nation: 1}, SuppliersItem {id: 2, nation: 2}];
    let partsupp: Vec<PartsuppItem> = vec![PartsuppItem {part: 100, supplier: 1, cost: 10, qty: 2}, PartsuppItem {part: 100, supplier: 2, cost: 20, qty: 1}, PartsuppItem {part: 200, supplier: 1, cost: 5, qty: 3}];
    let filtered: Vec<QueryItem> = { let mut _q: Vec<QueryItem> = Vec::new(); for ps in &partsupp { for s in &suppliers { if (s.id == ps.supplier) { for n in &nations { if (n.id == s.nation) { if (n.name == "A") { _q.push(QueryItem {part: ps.clone().part, value: (ps.clone().cost * ps.clone().qty)}); } } } } } } _q };
    let grouped: Vec<QueryItem1> = { let mut _q: Vec<QueryItem1> = Vec::new(); let mut _groups: HashMap<String, Group<i64, HashMap<String, i64>>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for x in &filtered { let key = x["part"].clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<i64, HashMap<String, i64>> { key: key.clone(), items: Vec::new() } }); e.items.push(x.clone()); } for ks in _order { let g = &_groups[&ks]; _q.push(QueryItem1 {part: g.key.clone(), total: { let mut _q: Vec<i64> = Vec::new(); for r in g.items.clone() { _q.push(r.value); } _q }.iter().sum::<i64>()}); } _q };
    println!("{}", { let tmp = grouped; tmp.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(" ") });
}
