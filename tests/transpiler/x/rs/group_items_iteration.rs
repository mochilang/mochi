// Generated by Mochi transpiler v0.10.33 on 2025-07-21 18:06 +0700
use std::collections::HashMap;
#[derive(Clone)]
struct Group<K, V> { key: K, items: Vec<V> }
#[derive(Debug, Clone)]
struct DataItem {
    tag: String,
    val: i64,
}
impl std::fmt::Display for DataItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"tag\": \"{}\"", self.tag)?;
        write!(f, ", ")?;
        write!(f, "\"val\": {}", self.val)?;
        write!(f, "}}")
    }
}

fn main() {
    let data: Vec<DataItem> = vec![DataItem {tag: String::from("a"), val: 1}, DataItem {tag: String::from("a"), val: 2}, DataItem {tag: String::from("b"), val: 3}];
    let groups: Vec<Group<String, DataItem>> = { let mut _q: Vec<Group<String, DataItem>> = Vec::new(); let mut _groups: HashMap<String, Group<String, DataItem>> = HashMap::new(); let mut _order: Vec<String> = Vec::new(); for d in &data { let key = d.tag.clone(); let ks = format!("{:?}", &key); let e = _groups.entry(ks.clone()).or_insert_with(|| { _order.push(ks.clone()); Group::<String, DataItem> { key: key.clone(), items: Vec::new() } }); e.items.push(d.clone()); } for ks in _order { let g = &_groups[&ks]; _q.push(g); } _q };
    let mut tmp: Vec<i64> = vec![];
    for g in groups {
        let mut total: i64 = 0;
        for x in g.items.clone() {
            total = (total + x.val);
        }
        tmp = { let mut v = tmp.clone(); v.push(HashMap::from([(tag, g.key.clone()), (total, total)])); v };
    }
    let result: Vec<i64> = { let mut _q: Vec<i64> = Vec::new(); let mut _tmp: Vec<(i64, i64)> = Vec::new(); for r in tmp { _tmp.push((r.tag, r)); } _tmp.sort_by(|a,b| a.0.partial_cmp(&b.0).unwrap()); for (_,v) in _tmp { _q.push(v); } _q };
    println!("{:?}", result);
}
