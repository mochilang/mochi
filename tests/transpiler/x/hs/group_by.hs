{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (age, avg_age, city, count, name)
-- Generated by Mochi transpiler v0.10.32 on 2025-07-21 12:53 GMT+7
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
data MGroup k a = MGroup {key :: k, items :: [a]} deriving (Show)

_group_by :: Ord k => [a] -> (a -> k) -> [MGroup k a]
_group_by src keyfn =
  let go [] m order = (m, order)
      go (x:xs) m order =
        let k = keyfn x
         in case Map.lookup k m of
              Just is -> go xs (Map.insert k (is ++ [x]) m) order
              Nothing -> go xs (Map.insert k [x] m) (order ++ [k])
      (m, order) = go src Map.empty []
   in [MGroup k (fromMaybe [] (Map.lookup k m)) | k <- order]

data GenType1 = GenType1
  { name :: String,
    age :: Int,
    city :: String
  } deriving (Show)


data GenType2 = GenType2
  { city :: String,
    count :: Int,
    avg_age :: Double
  } deriving (Show)


people = [GenType1 {name = "Alice", age = 30, city = "Paris"}, GenType1 {name = "Bob", age = 15, city = "Hanoi"}, GenType1 {name = "Charlie", age = 65, city = "Paris"}, GenType1 {name = "Diana", age = 45, city = "Hanoi"}, GenType1 {name = "Eve", age = 70, city = "Paris"}, GenType1 {name = "Frank", age = 22, city = "Hanoi"}]

stats = [GenType2 {city = g.key, count = length g.items, avg_age = fromIntegral (sum [p.age | p <- g.items]) / fromIntegral (length [p.age | p <- g.items])} | g <- _group_by [person | person <- people] (\person -> person.city)]

main :: IO ()
main = do
    putStrLn ("--- People grouped by city ---")
    mapM_ (\s -> do
        putStrLn (show s.city ++ ": count =" ++ show s.count ++ ", avg_age =" ++ show s.avg_age)
        ) stats
