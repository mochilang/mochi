//go:build ignore

// Generated by Mochi v0.10.34 on 2025-07-21 21:40:35 GMT+7
package main

import (
    "fmt"
    "strings"
    "encoding/json"
)

var nation []Nation = []Nation{Nation{
    NNationkey: 1,
    NName: "BRAZIL",
}}

type Nation struct {
    NNationkey int `json:"n_nationkey"`
    NName string `json:"n_name"`
}

var customer []Customer = []Customer{Customer{
    CCustkey: 1,
    CName: "Alice",
    CAcctbal: 100.0,
    CNationkey: 1,
    CAddress: "123 St",
    CPhone: "123-456",
    CComment: "Loyal",
}}

type Customer struct {
    CCustkey int `json:"c_custkey"`
    CName string `json:"c_name"`
    CAcctbal float64 `json:"c_acctbal"`
    CNationkey int `json:"c_nationkey"`
    CAddress string `json:"c_address"`
    CPhone string `json:"c_phone"`
    CComment string `json:"c_comment"`
}

var orders []Order = []Order{Order{
    OOrderkey: 1000,
    OCustkey: 1,
    OOrderdate: "1993-10-15",
}, Order{
    OOrderkey: 2000,
    OCustkey: 1,
    OOrderdate: "1994-01-02",
}}

type Order struct {
    OOrderkey int `json:"o_orderkey"`
    OCustkey int `json:"o_custkey"`
    OOrderdate string `json:"o_orderdate"`
}

var lineitem []Lineitem = []Lineitem{Lineitem{
    LOrderkey: 1000,
    LReturnflag: "R",
    LExtendedprice: 1000.0,
    LDiscount: 0.1,
}, Lineitem{
    LOrderkey: 2000,
    LReturnflag: "N",
    LExtendedprice: 500.0,
    LDiscount: 0.0,
}}

type Lineitem struct {
    LOrderkey int `json:"l_orderkey"`
    LReturnflag string `json:"l_returnflag"`
    LExtendedprice float64 `json:"l_extendedprice"`
    LDiscount float64 `json:"l_discount"`
}

var start_date string = "1993-10-01"

var end_date string = "1994-01-01"

var result []Result = func() []Result {
groups := map[string]struct{Key any; Items []GroupItem5}{}
order := []string{}
for _, c := range customer {
    k := fmt.Sprint(map[]{"c_custkey": c.CCustkey, "c_name": c.CName, "c_acctbal": c.CAcctbal, "c_address": c.CAddress, "c_phone": c.CPhone, "c_comment": c.CComment, "n_name": n.NName})
    grp, ok := groups[k]
    if !ok {
        grp = struct{Key any; Items []GroupItem5}{Key: map[]{"c_custkey": c.CCustkey, "c_name": c.CName, "c_acctbal": c.CAcctbal, "c_address": c.CAddress, "c_phone": c.CPhone, "c_comment": c.CComment, "n_name": n.NName}, Items: []GroupItem5{}}
        groups[k] = grp
        order = append(order, k)
    }
 for _, o := range orders { if (o.OCustkey == c.CCustkey) { for _, l := range lineitem { if (l.LOrderkey == o.OOrderkey) { for _, n := range nation { if (n.NNationkey == c.CNationkey) { if (((o.OOrderdate >= start_date) && (o.OOrderdate < end_date)) && (l.LReturnflag == "R")) {grp.Items = append(grp.Items, GroupItem5{C: c, O: o, L: l, N: n})
groups[k] = grp } } } } } } } }
res := []Result{}
for _, k := range order {
g := groups[k]
    res = append(res, Result{
    CCustkey: g.Key.CCustkey,
    CName: g.Key.CName,
    Revenue: func() float64 { s := 0.0; for _, n := range func() []float64 { res := []float64{}; for _, x := range g.Items { res = append(res, (x.L.LExtendedprice * (float64(1) - x.L.LDiscount))) }; return res }() { s += n }; return s }(),
    CAcctbal: g.Key.CAcctbal,
    NName: g.Key.NName,
    CAddress: g.Key.CAddress,
    CPhone: g.Key.CPhone,
    CComment: g.Key.CComment,
})
}
return res }()

type GroupItem5 struct {
    C Customer `json:"c"`
    O Order `json:"o"`
    L Lineitem `json:"l"`
    N Nation `json:"n"`
}

type Result struct {
    CCustkey int `json:"c_custkey"`
    CName string `json:"c_name"`
    Revenue float64 `json:"revenue"`
    CAcctbal float64 `json:"c_acctbal"`
    NName string `json:"n_name"`
    CAddress string `json:"c_address"`
    CPhone string `json:"c_phone"`
    CComment string `json:"c_comment"`
}

func main() {
    fmt.Println(func() string { b, _ := json.Marshal(result); s := string(b); s = strings.ReplaceAll(s, ":", ": "); s = strings.ReplaceAll(s, ",", ", "); s = strings.ReplaceAll(s, "\"", "'"); return s }())
}
