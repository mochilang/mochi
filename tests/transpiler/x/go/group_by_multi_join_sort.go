//go:build ignore

// Generated by Mochi v0.10.36 on 2025-07-22 18:26:30 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"
)

var nation []Nation = []Nation{Nation{
	NNationkey: 1,
	NName:      "BRAZIL",
}}

type Nation struct {
	NNationkey int    `json:"n_nationkey"`
	NName      string `json:"n_name"`
}

var customer []Customer = []Customer{Customer{
	CCustkey:   1,
	CName:      "Alice",
	CAcctbal:   100.0,
	CNationkey: 1,
	CAddress:   "123 St",
	CPhone:     "123-456",
	CComment:   "Loyal",
}}

type Customer struct {
	CCustkey   int     `json:"c_custkey"`
	CName      string  `json:"c_name"`
	CAcctbal   float64 `json:"c_acctbal"`
	CNationkey int     `json:"c_nationkey"`
	CAddress   string  `json:"c_address"`
	CPhone     string  `json:"c_phone"`
	CComment   string  `json:"c_comment"`
}

var orders []Order = []Order{Order{
	OOrderkey:  1000,
	OCustkey:   1,
	OOrderdate: "1993-10-15",
}, Order{
	OOrderkey:  2000,
	OCustkey:   1,
	OOrderdate: "1994-01-02",
}}

type Order struct {
	OOrderkey  int    `json:"o_orderkey"`
	OCustkey   int    `json:"o_custkey"`
	OOrderdate string `json:"o_orderdate"`
}

var lineitem []Lineitem = []Lineitem{Lineitem{
	LOrderkey:      1000,
	LReturnflag:    "R",
	LExtendedprice: 1000.0,
	LDiscount:      0.1,
}, Lineitem{
	LOrderkey:      2000,
	LReturnflag:    "N",
	LExtendedprice: 500.0,
	LDiscount:      0.0,
}}

type Lineitem struct {
	LOrderkey      int     `json:"l_orderkey"`
	LReturnflag    string  `json:"l_returnflag"`
	LExtendedprice float64 `json:"l_extendedprice"`
	LDiscount      float64 `json:"l_discount"`
}

var start_date string = "1993-10-01"

var end_date string = "1994-01-01"

type ResultKey struct {
	CCustkey int     `json:"c_custkey"`
	CName    string  `json:"c_name"`
	CAcctbal float64 `json:"c_acctbal"`
	CAddress string  `json:"c_address"`
	CPhone   string  `json:"c_phone"`
	CComment string  `json:"c_comment"`
	NName    string  `json:"n_name"`
}

type GroupItem6 struct {
	C Customer `json:"c"`
	O Order    `json:"o"`
	L Lineitem `json:"l"`
	N Nation   `json:"n"`
}

type Result struct {
	CCustkey int     `json:"c_custkey"`
	CName    string  `json:"c_name"`
	Revenue  float64 `json:"revenue"`
	CAcctbal float64 `json:"c_acctbal"`
	NName    string  `json:"n_name"`
	CAddress string  `json:"c_address"`
	CPhone   string  `json:"c_phone"`
	CComment string  `json:"c_comment"`
}

func main() {
	var result []Result = func() []Result {
		groups := map[string]struct {
			Key   ResultKey
			Items []GroupItem6
		}{}
		order := []string{}
		for _, c := range customer {
			for _, o := range orders {
				if o.OCustkey == c.CCustkey {
					for _, l := range lineitem {
						if l.LOrderkey == o.OOrderkey {
							for _, n := range nation {
								if n.NNationkey == c.CNationkey {
									if ((o.OOrderdate >= start_date) && (o.OOrderdate < end_date)) && (l.LReturnflag == "R") {
										k := fmt.Sprint(ResultKey{
											CCustkey: c.CCustkey,
											CName:    c.CName,
											CAcctbal: c.CAcctbal,
											CAddress: c.CAddress,
											CPhone:   c.CPhone,
											CComment: c.CComment,
											NName:    n.NName,
										})
										grp, ok := groups[k]
										if !ok {
											grp = struct {
												Key   ResultKey
												Items []GroupItem6
											}{Key: ResultKey{
												CCustkey: c.CCustkey,
												CName:    c.CName,
												CAcctbal: c.CAcctbal,
												CAddress: c.CAddress,
												CPhone:   c.CPhone,
												CComment: c.CComment,
												NName:    n.NName,
											}, Items: []GroupItem6{}}
											groups[k] = grp
											order = append(order, k)
										}
										grp.Items = append(grp.Items, GroupItem6{C: c, O: o, L: l, N: n})
										groups[k] = grp
									}
								}
							}
						}
					}
				}
			}
		}
		type pair struct {
			Key float64
			Val Result
		}
		pairs := []pair{}
		for _, k := range order {
			g := groups[k]
			pairs = append(pairs, pair{(0 - func() float64 {
				s := 0.0
				for _, n := range func() []float64 {
					res := []float64{}
					for _, x := range g.Items {
						res = append(res, (x.L.(map[string]any)["l_extendedprice"] * (float64(1) - x.L.(map[string]any)["l_discount"])))
					}
					return res
				}() {
					s += n
				}
				return s
			}()), Result{
				CCustkey: g.Key.(map[string]any)["c_custkey"],
				CName:    g.Key.(map[string]any)["c_name"],
				Revenue: func() float64 {
					s := 0.0
					for _, n := range func() []float64 {
						res := []float64{}
						for _, x := range g.Items {
							res = append(res, (x.L.(map[string]any)["l_extendedprice"] * (float64(1) - x.L.(map[string]any)["l_discount"])))
						}
						return res
					}() {
						s += n
					}
					return s
				}(),
				CAcctbal: g.Key.(map[string]any)["c_acctbal"],
				NName:    g.Key.(map[string]any)["n_name"],
				CAddress: g.Key.(map[string]any)["c_address"],
				CPhone:   g.Key.(map[string]any)["c_phone"],
				CComment: g.Key.(map[string]any)["c_comment"],
			}})
		}
		sort.Slice(pairs, func(i, j int) bool { return pairs[i].Key < pairs[j].Key })
		res := make([]Result, len(pairs))
		for i, p := range pairs {
			res[i] = p.Val
		}
		return res
	}()
	fmt.Println(func() string {
		b, _ := json.Marshal(result)
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "}, {", "},{")
		s = strings.ReplaceAll(s, "\"", "'")
		return s
	}())
}
