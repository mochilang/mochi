//go:build ignore

// Generated by Mochi v0.10.36 on 2025-07-22 17:32:58 GMT+7
package main

import (
	"fmt"
	"sort"
	"strings"
)

var nation []Nation = []Nation{Nation{
	NNationkey: 1,
	NName:      "BRAZIL",
}}

type Nation struct {
	NNationkey int    `json:"n_nationkey"`
	NName      string `json:"n_name"`
}

var customer []Customer = []Customer{Customer{
	CCustkey:   1,
	CName:      "Alice",
	CAcctbal:   100.0,
	CNationkey: 1,
	CAddress:   "123 St",
	CPhone:     "123-456",
	CComment:   "Loyal",
}}

type Customer struct {
	CCustkey   int     `json:"c_custkey"`
	CName      string  `json:"c_name"`
	CAcctbal   float64 `json:"c_acctbal"`
	CNationkey int     `json:"c_nationkey"`
	CAddress   string  `json:"c_address"`
	CPhone     string  `json:"c_phone"`
	CComment   string  `json:"c_comment"`
}

var orders []Order = []Order{Order{
	OOrderkey:  1000,
	OCustkey:   1,
	OOrderdate: "1993-10-15",
}, Order{
	OOrderkey:  2000,
	OCustkey:   1,
	OOrderdate: "1994-01-02",
}}

type Order struct {
	OOrderkey  int    `json:"o_orderkey"`
	OCustkey   int    `json:"o_custkey"`
	OOrderdate string `json:"o_orderdate"`
}

var lineitem []Lineitem = []Lineitem{Lineitem{
	LOrderkey:      1000,
	LReturnflag:    "R",
	LExtendedprice: 1000.0,
	LDiscount:      0.1,
}, Lineitem{
	LOrderkey:      2000,
	LReturnflag:    "N",
	LExtendedprice: 500.0,
	LDiscount:      0.0,
}}

type Lineitem struct {
	LOrderkey      int     `json:"l_orderkey"`
	LReturnflag    string  `json:"l_returnflag"`
	LExtendedprice float64 `json:"l_extendedprice"`
	LDiscount      float64 `json:"l_discount"`
}

var start_date string = "1993-10-01"

var end_date string = "1994-01-01"

type ResultKey struct {
	CCustkey int     `json:"c_custkey"`
	CName    string  `json:"c_name"`
	CAcctbal float64 `json:"c_acctbal"`
	CAddress string  `json:"c_address"`
	CPhone   string  `json:"c_phone"`
	CComment string  `json:"c_comment"`
	NName    string  `json:"n_name"`
}

type GroupItem6 struct {
	C Customer `json:"c"`
	O Order    `json:"o"`
	L Lineitem `json:"l"`
	N Nation   `json:"n"`
}

type Result struct {
	CCustkey int     `json:"c_custkey"`
	CName    string  `json:"c_name"`
	Revenue  float64 `json:"revenue"`
	CAcctbal float64 `json:"c_acctbal"`
	NName    string  `json:"n_name"`
	CAddress string  `json:"c_address"`
	CPhone   string  `json:"c_phone"`
	CComment string  `json:"c_comment"`
}

func main() {
	var result []Result = func() []Result {
		groups := map[string]struct {
			Key   ResultKey
			Items []GroupItem6
		}{}
		order := []string{}
		for _, c := range customer {
			for _, o := range orders {
				if o.OCustkey == c.CCustkey {
					for _, l := range lineitem {
						if l.LOrderkey == o.OOrderkey {
							for _, n := range nation {
								if n.NNationkey == c.CNationkey {
									if ((o.OOrderdate >= start_date) && (o.OOrderdate < end_date)) && (l.LReturnflag == "R") {
										k := fmt.Sprint(ResultKey{
											CCustkey: c.CCustkey,
											CName:    c.CName,
											CAcctbal: c.CAcctbal,
											CAddress: c.CAddress,
											CPhone:   c.CPhone,
											CComment: c.CComment,
											NName:    n.NName,
										})
										grp, ok := groups[k]
										if !ok {
											grp = struct {
												Key   ResultKey
												Items []GroupItem6
											}{Key: ResultKey{
												CCustkey: c.CCustkey,
												CName:    c.CName,
												CAcctbal: c.CAcctbal,
												CAddress: c.CAddress,
												CPhone:   c.CPhone,
												CComment: c.CComment,
												NName:    n.NName,
											}, Items: []GroupItem6{}}
											groups[k] = grp
											order = append(order, k)
										}
										grp.Items = append(grp.Items, GroupItem6{C: c, O: o, L: l, N: n})
										groups[k] = grp
									}
								}
							}
						}
					}
				}
			}
		}
		type pair struct {
			Key float64
			Val Result
		}
		pairs := []pair{}
		for _, k := range order {
			g := groups[k]
			pairs = append(pairs, pair{(0 - func() float64 {
				s := 0.0
				for _, n := range func() []float64 {
					res := []float64{}
					for _, x := range g.Items {
						res = append(res, (x.L.LExtendedprice * (float64(1) - x.L.LDiscount)))
					}
					return res
				}() {
					s += n
				}
				return s
			}()), Result{
				CCustkey: g.Key.CCustkey,
				CName:    g.Key.CName,
				Revenue: func() float64 {
					s := 0.0
					for _, n := range func() []float64 {
						res := []float64{}
						for _, x := range g.Items {
							res = append(res, (x.L.LExtendedprice * (float64(1) - x.L.LDiscount)))
						}
						return res
					}() {
						s += n
					}
					return s
				}(),
				CAcctbal: g.Key.CAcctbal,
				NName:    g.Key.NName,
				CAddress: g.Key.CAddress,
				CPhone:   g.Key.CPhone,
				CComment: g.Key.CComment,
			}})
		}
		sort.Slice(pairs, func(i, j int) bool { return pairs[i].Key < pairs[j].Key })
		res := make([]Result, len(pairs))
		for i, p := range pairs {
			res[i] = p.Val
		}
		return res
	}()
	fmt.Println(func() string {
		var sb strings.Builder
		sb.WriteByte('[')
		for i, v := range result {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(fmt.Sprint(v))
		}
		sb.WriteByte(']')
		return sb.String()
	}())
}
