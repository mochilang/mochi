//go:build ignore

// Generated by Mochi v0.10.34 on 2025-07-22 00:27:57 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"
)

var nation []Nation = []Nation{Nation{
	NNationkey: 1,
	NName:      "BRAZIL",
}}

type Nation struct {
	NNationkey int    `json:"n_nationkey"`
	NName      string `json:"n_name"`
}

var customer []Customer = []Customer{Customer{
	CCustkey:   1,
	CName:      "Alice",
	CAcctbal:   100.0,
	CNationkey: 1,
	CAddress:   "123 St",
	CPhone:     "123-456",
	CComment:   "Loyal",
}}

type Customer struct {
	CCustkey   int     `json:"c_custkey"`
	CName      string  `json:"c_name"`
	CAcctbal   float64 `json:"c_acctbal"`
	CNationkey int     `json:"c_nationkey"`
	CAddress   string  `json:"c_address"`
	CPhone     string  `json:"c_phone"`
	CComment   string  `json:"c_comment"`
}

var orders []Order = []Order{Order{
	OOrderkey:  1000,
	OCustkey:   1,
	OOrderdate: "1993-10-15",
}, Order{
	OOrderkey:  2000,
	OCustkey:   1,
	OOrderdate: "1994-01-02",
}}

type Order struct {
	OOrderkey  int    `json:"o_orderkey"`
	OCustkey   int    `json:"o_custkey"`
	OOrderdate string `json:"o_orderdate"`
}

var lineitem []Lineitem = []Lineitem{Lineitem{
	LOrderkey:      1000,
	LReturnflag:    "R",
	LExtendedprice: 1000.0,
	LDiscount:      0.1,
}, Lineitem{
	LOrderkey:      2000,
	LReturnflag:    "N",
	LExtendedprice: 500.0,
	LDiscount:      0.0,
}}

type Lineitem struct {
	LOrderkey      int     `json:"l_orderkey"`
	LReturnflag    string  `json:"l_returnflag"`
	LExtendedprice float64 `json:"l_extendedprice"`
	LDiscount      float64 `json:"l_discount"`
}

var start_date string = "1993-10-01"

var end_date string = "1994-01-01"

var result []Result = func() []Result {
	groups := map[string]struct {
		Key   ResultKey
		Items []GroupItem6
	}{}
	order := []string{}
	for _, c := range customer {
		for _, o := range orders {
			if o.OCustkey == c.CCustkey {
				for _, l := range lineitem {
					if l.LOrderkey == o.OOrderkey {
						for _, n := range nation {
							if n.NNationkey == c.CNationkey {
								if ((o.OOrderdate >= start_date) && (o.OOrderdate < end_date)) && (l.LReturnflag == "R") {
									k := fmt.Sprint(ResultKey{
										CCustkey: c.CCustkey,
										CName:    c.CName,
										CAcctbal: c.CAcctbal,
										CAddress: c.CAddress,
										CPhone:   c.CPhone,
										CComment: c.CComment,
										NName:    n.NName,
									})
									grp, ok := groups[k]
									if !ok {
										grp = struct {
											Key   ResultKey
											Items []GroupItem6
										}{Key: ResultKey{
											CCustkey: c.CCustkey,
											CName:    c.CName,
											CAcctbal: c.CAcctbal,
											CAddress: c.CAddress,
											CPhone:   c.CPhone,
											CComment: c.CComment,
											NName:    n.NName,
										}, Items: []GroupItem6{}}
										groups[k] = grp
										order = append(order, k)
									}
									grp.Items = append(grp.Items, GroupItem6{C: c, O: o, L: l, N: n})
									groups[k] = grp
								}
							}
						}
					}
				}
			}
		}
	}
	type pair struct {
		Key float64
		Val Result
	}
	tmp := []pair{}
	for _, k := range order {
		g := groups[k]
		tmp = append(tmp, pair{(0 - func() float64 {
			s := 0.0
			for _, n := range func() []float64 {
				res := []float64{}
				for _, x := range g.Items {
					res = append(res, (x.L.LExtendedprice * (float64(1) - x.L.LDiscount)))
				}
				return res
			}() {
				s += n
			}
			return s
		}()), Result{
			CCustkey: g.Key.CCustkey,
			CName:    g.Key.CName,
			Revenue: func() float64 {
				s := 0.0
				for _, n := range func() []float64 {
					res := []float64{}
					for _, x := range g.Items {
						res = append(res, (x.L.LExtendedprice * (float64(1) - x.L.LDiscount)))
					}
					return res
				}() {
					s += n
				}
				return s
			}(),
			CAcctbal: g.Key.CAcctbal,
			NName:    g.Key.NName,
			CAddress: g.Key.CAddress,
			CPhone:   g.Key.CPhone,
			CComment: g.Key.CComment,
		}})
	}
	sort.Slice(tmp, func(i, j int) bool { return tmp[i].Key < tmp[j].Key })
	res := make([]Result, len(tmp))
	for i, p := range tmp {
		res[i] = p.Val
	}
	return res
}()

type ResultKey struct {
	CCustkey int     `json:"c_custkey"`
	CName    string  `json:"c_name"`
	CAcctbal float64 `json:"c_acctbal"`
	CAddress string  `json:"c_address"`
	CPhone   string  `json:"c_phone"`
	CComment string  `json:"c_comment"`
	NName    string  `json:"n_name"`
}

type GroupItem6 struct {
	C Customer `json:"c"`
	O Order    `json:"o"`
	L Lineitem `json:"l"`
	N Nation   `json:"n"`
}

type Result struct {
	CCustkey int     `json:"c_custkey"`
	CName    string  `json:"c_name"`
	Revenue  float64 `json:"revenue"`
	CAcctbal float64 `json:"c_acctbal"`
	NName    string  `json:"n_name"`
	CAddress string  `json:"c_address"`
	CPhone   string  `json:"c_phone"`
	CComment string  `json:"c_comment"`
}

func main() {
	fmt.Println(func() string {
		b, _ := json.Marshal(result)
		s := string(b)
		s = strings.ReplaceAll(s, ":", ": ")
		s = strings.ReplaceAll(s, ",", ", ")
		s = strings.ReplaceAll(s, "\"", "'")
		return s
	}())
}
