// Generated by Mochi transpiler v0.10.33 on 2025-07-21 18:19:56 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <unordered_map>
#include <optional>
#include <sstream>
#include <iomanip>


struct CustomersItem {
    int id;
    std::string name;
};

struct OrdersItem {
    int id;
    int customerId;
};

struct StatsPair {
    CustomersItem c;
    std::optional<OrdersItem> o;
};

struct GGroup {
    std::string key;
    std::vector<StatsPair> items;
    auto begin() { return items.begin(); }
    auto end() { return items.end(); }
    size_t size() const { return items.size(); }
};

struct StatsItem {
    std::string name;
    int count;
};

std::vector<CustomersItem> customers = std::vector{CustomersItem{.id = 1, .name = std::string("Alice")}, CustomersItem{.id = 2, .name = std::string("Bob")}, CustomersItem{.id = 3, .name = std::string("Charlie")}};
std::vector<OrdersItem> orders = std::vector{OrdersItem{.id = 100, .customerId = 1}, OrdersItem{.id = 101, .customerId = 1}, OrdersItem{.id = 102, .customerId = 2}};
std::vector<StatsItem> stats = ([]{ std::vector<StatsItem> __items;
std::vector<GGroup> __groups;
std::unordered_map<std::string, size_t> __idx;
for (auto c : customers) {
    bool __matched = false;
    for (auto o : orders) {
        if((o.customerId == c.id)) {
            __matched = true;
            StatsPair __pair{c, std::optional<OrdersItem>(o)};
            auto __key = c.name;
            auto it = __idx.find(__key);
            if(it == __idx.end()) {
                GGroup __g{__key, {}};
                __g.items.push_back(__pair);
                __idx[__key] = __groups.size();
                __groups.push_back(__g);
            } else {
                __groups[it->second].items.push_back(__pair);
            }
        }
    }
    if(!__matched) {
        std::optional<OrdersItem> o = std::nullopt;
        StatsPair __pair{c, o};
        auto __key = c.name;
        auto it = __idx.find(__key);
        if(it == __idx.end()) {
            GGroup __g{__key, {}};
            __g.items.push_back(__pair);
            __idx[__key] = __groups.size();
            __groups.push_back(__g);
        } else {
            __groups[it->second].items.push_back(__pair);
        }
    }
}
for(auto &__g : __groups) {
    GGroup g = __g;
    __items.push_back(StatsItem{.name = g.key, .count = ([]{ std::vector<StatsPair> __items;
for (auto r : g) {
    if(r.o) {
        __items.push_back(r);
    }
}
return __items; }()).size()});
}
return __items; }());

int main() {
    std::cout << std::boolalpha << std::string("--- Group Left Join ---") << std::endl;
    for (auto s : stats) {
        std::cout << std::boolalpha << s.name << ' ' << std::string("orders:") << ' ' << s.count << std::endl;
    }
    return 0;
}
