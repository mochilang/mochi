#lang racket
(require racket/list)

(define (idx x i)
  (cond
    [(string? x)
     (let* ([n (string-length x)]
            [idx (if (< i 0)
                     (+ i n)
                     i)])
       (char->integer (string-ref x idx)))]
    [(hash? x) (hash-ref x i)]
    [else
     (let* ([n (length x)]
            [idx (if (< i 0)
                     (+ i n)
                     i)])
       (list-ref x idx))]))
(define (slice x s e)
  (if (string? x)
      (let* ([n (string-length x)]
             [start (if (< s 0)
                        (+ s n)
                        s)]
             [end (if (< e 0)
                      (+ e n)
                      e)]
             [start (max 0 start)]
             [end (min n end)]
             [end (if (< end start) start end)])
        (substring x start end))
      (let* ([n (length x)]
             [start (if (< s 0)
                        (+ s n)
                        s)]
             [end (if (< e 0)
                      (+ e n)
                      e)]
             [start (max 0 start)]
             [end (min n end)]
             [end (if (< end start) start end)])
        (take (drop x start) (- end start)))))
(define (count x)
  (cond
    [(string? x) (string-length x)]
    [(hash? x) (hash-count x)]
    [else (length x)]))
(define (avg x)
  (let ([n (count x)])
    (if (= n 0)
        0
        (/ (for/fold ([s 0.0]) ([v x])
             (+ s (real->double-flonum v)))
           n))))
(define (_add a b)
  (cond
    [(and (number? a) (number? b)) (+ a b)]
    [(and (string? a) (string? b)) (string-append a b)]
    [(and (list? a) (list? b)) (append a b)]
    [else (error "unsupported + operands")]))
(define (_div a b)
  (cond
    [(and (integer? a) (integer? b)) (quotient a b)]
    [else (/ a b)]))

(define (expect cond)
  (unless cond
    (error "expect failed")))

(define products
  (list (hash "name" "Laptop" "price" 1500)
        (hash "name" "Smartphone" "price" 900)
        (hash "name" "Tablet" "price" 600)
        (hash "name" "Monitor" "price" 300)
        (hash "name" "Keyboard" "price" 100)
        (hash "name" "Mouse" "price" 50)
        (hash "name" "Headphones" "price" 200)))
(define expensive
  (let ([_res '()])
    (for ([p products])
      (set! _res (append _res (list (cons (- (hash-ref p "price")) p)))))
    (set! _res
          (map cdr
               (sort _res
                     (lambda (a b)
                       (let ([ak (car a)]
                             [bk (car b)])
                         (cond
                           [(and (number? ak) (number? bk)) (< ak bk)]
                           [(and (string? ak) (string? bk)) (string<? ak bk)]
                           [else (string<? (format "~a" ak) (format "~a" bk))]))))))
    (set! _res (drop _res 1))
    (set! _res (take _res 3))
    _res))
(displayln "--- Top products (excluding most expensive) ---")
(for ([item (if (hash? expensive)
                (hash-keys expensive)
                expensive)])
  (displayln (format "~a ~a ~a" (hash-ref item "name") "costs $" (hash-ref item "price"))))
