# Generated by Mochi Elixir compiler
defmodule Main do
	def main do
		customers = [%{id: 1, name: "Alice"}, %{id: 2, name: "Bob"}, %{id: 3, name: "Charlie"}]
		orders = [%{id: 100, customerId: 1}, %{id: 101, customerId: 1}, %{id: 102, customerId: 2}]
		stats = (fn ->
	_src = customers
	_rows = _query(_src, [
		%{items: orders, on: fn c, o -> (o.customerId == c.id) end, left: true}
	], %{select: fn c, o -> [c, o] end })
	_groups = _group_by(_rows, fn c, o -> c.name end)
	_groups = Enum.map(_groups, fn g -> %{g | Items: Enum.map(g.Items, fn [c, o] -> c end)} end)
	items = _groups
	Enum.map(items, fn g -> %{name: g.key, count: _count(for r <- g, r.o, do: r)} end)
end)()
		IO.puts("--- Group Left Join ---")
		for s <- stats do
			IO.puts(Enum.join(Enum.map([s.name, "orders:", s.count], &to_string(&1)), " "))
		end
	end
	defp _count(v) do
  cond do
    is_list(v) -> length(v)
    is_map(v) and Map.has_key?(v, :Items) -> length(v[:Items])
    true -> raise "count() expects list or group"
  end
end

	defmodule _Group do
  defstruct key: nil, Items: []
end

	defp _group_by(src, keyfn) do
  {groups, order} = Enum.reduce(src, {%{}, []}, fn it, {groups, order} ->
    key = keyfn.(it)
    ks = to_string(key)
    {groups, order} = if Map.has_key?(groups, ks) do
      {groups, order}
    else
      {Map.put(groups, ks, %_Group{key: key}), order ++ [ks]}
    end
    groups = Map.update!(groups, ks, fn g -> %{g | Items: g.Items ++ [it]} end)
    {groups, order}
  end)
  Enum.map(order, fn k -> groups[k] end)
end

	defp _query(src, joins, opts \ %{}) do
  where = Map.get(opts, :where)
  items = Enum.map(src, fn v -> [v] end)
  items = if where, do: Enum.filter(items, fn r -> where.(r) end), else: items
  items = Enum.reduce(joins, items, fn j, items ->
    joined = cond do
      Map.get(j, :right) && Map.get(j, :left) ->
        matched = for _ <- j[:items], do: false
        {res, matched} = Enum.reduce(items, {[], matched}, fn left, {acc, matched} ->
          {acc, matched, m} = Enum.reduce(Enum.with_index(j[:items]), {acc, matched, false}, fn {right, ri}, {acc, matched, m} ->
            keep = if Map.has_key?(j, :on) and j[:on], do: apply(j[:on], left ++ [right]), else: true
            if keep do
              matched = List.replace_at(matched, ri, true)
              {acc ++ [left ++ [right]], matched, true}
            else
              {acc, matched, m}
            end
          end)
          acc = if !m, do: acc ++ [left ++ [nil]], else: acc
          {acc, matched}
        end)
        Enum.reduce(Enum.with_index(j[:items]), res, fn {right, ri}, acc ->
          if Enum.at(matched, ri) do
            acc
          else
            undef = List.duplicate(nil, if items == [], do: 0, else: length(hd(items)))
            acc ++ [undef ++ [right]]
          end
        end)
      Map.get(j, :right) ->
        Enum.reduce(j[:items], [], fn right, acc ->
          {acc2, m} = Enum.reduce(items, {acc, false}, fn left, {acc, m} ->
            keep = if Map.has_key?(j, :on) and j[:on], do: apply(j[:on], left ++ [right]), else: true
            if keep, do: {acc ++ [left ++ [right]], true}, else: {acc, m}
          end)
          if !m do
            undef = List.duplicate(nil, if items == [], do: 0, else: length(hd(items)))
            acc2 ++ [undef ++ [right]]
          else
            acc2
          end
        end)
      true ->
        Enum.reduce(items, [], fn left, acc ->
          {acc2, m} = Enum.reduce(j[:items], {acc, false}, fn right, {acc, m} ->
            keep = if Map.has_key?(j, :on) and j[:on], do: apply(j[:on], left ++ [right]), else: true
            if keep, do: {acc ++ [left ++ [right]], true}, else: {acc, m}
          end)
          if Map.get(j, :left) && !m do
            acc2 ++ [left ++ [nil]]
          else
            acc2
          end
        end)
    end
    joined = if where, do: Enum.filter(joined, fn r -> where.(r) end), else: joined
    joined
  end)
  items = if Map.has_key?(opts, :sortKey), do: Enum.sort_by(items, fn r -> apply(opts[:sortKey], r) end), else: items
  items = if Map.has_key?(opts, :skip), do: (n = opts[:skip]; if n < length(items), do: Enum.drop(items, n), else: []), else: items
  items = if Map.has_key?(opts, :take), do: (n = opts[:take]; if n < length(items), do: Enum.take(items, n), else: items), else: items
  Enum.map(items, fn r -> apply(opts[:select], r) end)
end

	end
Main.main()
