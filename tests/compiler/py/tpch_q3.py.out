# Generated by Mochi Python compiler
from __future__ import annotations

# test "Q3 returns revenue per order with correct priority" {
# test "Q3 returns revenue per order with correct priority" {
def test_Q3_returns_revenue_per_order_with_correct_priority():
    # expect order_line_join == [
    assert (order_line_join == [{"l_orderkey": 100, "revenue": ((1000 * 0.95) + 500), "o_orderdate": "1995-03-14", "o_shippriority": 1}])

def main():
    # let customer = [
    global customer
    customer: list[dict[str, typing.Any]] = [{"c_custkey": 1, "c_mktsegment": "BUILDING"}, {"c_custkey": 2, "c_mktsegment": "AUTOMOBILE"}]
    # let orders = [
    global orders
    orders: list[dict[str, typing.Any]] = [{"o_orderkey": 100, "o_custkey": 1, "o_orderdate": "1995-03-14", "o_shippriority": 1}, {"o_orderkey": 200, "o_custkey": 2, "o_orderdate": "1995-03-10", "o_shippriority": 2}]
    # let lineitem = [
    global lineitem
    lineitem: list[dict[str, typing.Any]] = [{"l_orderkey": 100, "l_extendedprice": 1000, "l_discount": 0.05, "l_shipdate": "1995-03-16"}, {"l_orderkey": 100, "l_extendedprice": 500, "l_discount": 0, "l_shipdate": "1995-03-20"}, {"l_orderkey": 200, "l_extendedprice": 1000, "l_discount": 0.1, "l_shipdate": "1995-03-14"}]
    # let cutoff = "1995-03-15"
    global cutoff
    cutoff: str = "1995-03-15"
    # let segment = "BUILDING"
    global segment
    segment: str = "BUILDING"
    # let building_customers =
    global building_customers
    building_customers: list[dict[str, typing.Any]] = [ c for c in customer if (c["c_mktsegment"] == segment) ]
    # let valid_orders =
    global valid_orders
    valid_orders: list[dict[str, typing.Any]] = _query(orders, [{ 'items': building_customers, 'on': lambda o, c: ((o["o_custkey"] == c["c_custkey"])) }], { 'select': lambda o, c: o, 'where': lambda o, c: ((o["o_orderdate"] < cutoff)) })
    # let valid_lineitems =
    global valid_lineitems
    valid_lineitems: list[dict[str, typing.Any]] = [ l for l in lineitem if (l["l_shipdate"] > cutoff) ]
    # let order_line_join =
    def _q0():
        _src = valid_orders
        _rows = _query(_src, [{ 'items': valid_lineitems, 'on': lambda o, l: ((l["l_orderkey"] == o["o_orderkey"])) }], { 'select': lambda o, l: (o, l) })
        _groups = _group_by(_rows, lambda o, l: ({"o_orderkey": o["o_orderkey"], "o_orderdate": o["o_orderdate"], "o_shippriority": o["o_shippriority"]}))
        items = _groups
        items = sorted(items, key=lambda g: [(-sum([ (r[1]["l_extendedprice"] * ((1 - r[1]["l_discount"]))) for r in g ])), g.key.o_orderdate])
        return [ {"l_orderkey": g.key.o_orderkey, "revenue": sum([ (r[1]["l_extendedprice"] * ((1 - r[1]["l_discount"]))) for r in g ]), "o_orderdate": g.key.o_orderdate, "o_shippriority": g.key.o_shippriority} for g in items ]
    
    global order_line_join
    order_line_join: list[dict[str, typing.Any]] = _q0()
    # print(order_line_join)
    print(*order_line_join)
    test_Q3_returns_revenue_per_order_with_correct_priority()

class _Group:
    def __init__(self, key):
        self.key = key
        self.Items = []
    def __iter__(self):
        return iter(self.Items)
def _group_by(src, keyfn):
    groups = {}
    order = []
    for it in src:
        if isinstance(it, (list, tuple)):
            key = keyfn(*it)
        else:
            key = keyfn(it)
        if isinstance(key, dict):
            import types
            key = types.SimpleNamespace(**key)
        ks = str(key)
        g = groups.get(ks)
        if not g:
            g = _Group(key)
            groups[ks] = g
            order.append(ks)
        g.Items.append(it)
    return [ groups[k] for k in order ]
def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get('right') and j.get('left'):
            matched = [False] * len(j['items'])
            for left in items:
                m = False
                for ri, right in enumerate(j['items']):
                    keep = True
                    if j.get('on'):
                        keep = j['on'](*left, right)
                    if not keep:
                        continue
                    m = True; matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j['items']):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get('right'):
            for right in j['items']:
                m = False
                for left in items:
                    keep = True
                    if j.get('on'):
                        keep = j['on'](*left, right)
                    if not keep:
                        continue
                    m = True; joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j['items']:
                    keep = True
                    if j.get('on'):
                        keep = j['on'](*left, right)
                    if not keep:
                        continue
                    m = True; joined.append(left + [right])
                if j.get('left') and not m:
                    joined.append(left + [None])
        items = joined
    if opts.get('where'):
        items = [r for r in items if opts['where'](*r)]
    if opts.get('sortKey'):
        items.sort(key=lambda it: opts['sortKey'](*it))
    if 'skip' in opts:
        n = opts['skip']
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if 'take' in opts:
        n = opts['take']
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts['select'](*r))
    return res
if __name__ == "__main__":
    main()
