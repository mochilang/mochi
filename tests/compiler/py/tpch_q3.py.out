# Generated by Mochi Python compiler
from __future__ import annotations

customer = None
orders = None
lineitem = None
cutoff = "1995-03-15"
segment = "BUILDING"
building_customers = None
valid_orders = None
valid_lineitems = None
order_line_join = None

def test_Q3_returns_revenue_per_order_with_correct_priority():
	assert (order_line_join == [{"l_orderkey": 100, "revenue": ((1000 * 0.95) + 500), "o_orderdate": "1995-03-14", "o_shippriority": 1}])

def main():
	global customer
	customer = [{"c_custkey": 1, "c_mktsegment": "BUILDING"}, {"c_custkey": 2, "c_mktsegment": "AUTOMOBILE"}]
	global orders
	orders = [{"o_orderkey": 100, "o_custkey": 1, "o_orderdate": "1995-03-14", "o_shippriority": 1}, {"o_orderkey": 200, "o_custkey": 2, "o_orderdate": "1995-03-10", "o_shippriority": 2}]
	global lineitem
	lineitem = [{"l_orderkey": 100, "l_extendedprice": 1000, "l_discount": 0.05, "l_shipdate": "1995-03-16"}, {"l_orderkey": 100, "l_extendedprice": 500, "l_discount": 0, "l_shipdate": "1995-03-20"}, {"l_orderkey": 200, "l_extendedprice": 1000, "l_discount": 0.1, "l_shipdate": "1995-03-14"}]
	global cutoff
	cutoff = "1995-03-15"
	global segment
	segment = "BUILDING"
	global building_customers
	building_customers = [ c for c in customer if (c["c_mktsegment"] == segment) ]
	global valid_orders
	valid_orders = _query(orders, [{ 'items': building_customers, 'on': lambda o, c: ((o["o_custkey"] == c["c_custkey"])) }], { 'select': lambda o, c: o, 'where': lambda o, c: ((o["o_orderdate"] < cutoff)) })
	global valid_lineitems
	valid_lineitems = [ l for l in lineitem if (l["l_shipdate"] > cutoff) ]
	def _q0():
		_src = valid_orders
		_rows = _query(_src, [{ 'items': valid_lineitems, 'on': lambda o, l: ((l["l_orderkey"] == o["o_orderkey"])) }], { 'select': lambda o, l: (o, l) })
		_groups = _group_by(_rows, lambda o, l: ({"o_orderkey": o["o_orderkey"], "o_orderdate": o["o_orderdate"], "o_shippriority": o["o_shippriority"]}))
		items = _groups
		items = sorted(items, key=lambda g: [(-sum([ (r[1]["l_extendedprice"] * ((1 - r[1]["l_discount"]))) for r in g ])), g.key.o_orderdate])
		return [ {"l_orderkey": g.key.o_orderkey, "revenue": sum([ (r[1]["l_extendedprice"] * ((1 - r[1]["l_discount"]))) for r in g ]), "o_orderdate": g.key.o_orderdate, "o_shippriority": g.key.o_shippriority} for g in items ]
	
	global order_line_join
	order_line_join = _q0()
	print(*order_line_join)
	test_Q3_returns_revenue_per_order_with_correct_priority()

class _Group:
    def __init__(self, key):
        self.key = key
        self.Items = []
    def __iter__(self):
        return iter(self.Items)
def _group_by(src, keyfn):
    groups = {}
    order = []
    for it in src:
        if isinstance(it, (list, tuple)):
            key = keyfn(*it)
        else:
            key = keyfn(it)
        if isinstance(key, dict):
            import types
            key = types.SimpleNamespace(**key)
        ks = str(key)
        g = groups.get(ks)
        if not g:
            g = _Group(key)
            groups[ks] = g
            order.append(ks)
        g.Items.append(it)
    return [ groups[k] for k in order ]
def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get('right') and j.get('left'):
            matched = [False] * len(j['items'])
            for left in items:
                m = False
                for ri, right in enumerate(j['items']):
                    keep = True
                    if j.get('on'):
                        keep = j['on'](*left, right)
                    if not keep:
                        continue
                    m = True; matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j['items']):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get('right'):
            for right in j['items']:
                m = False
                for left in items:
                    keep = True
                    if j.get('on'):
                        keep = j['on'](*left, right)
                    if not keep:
                        continue
                    m = True; joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j['items']:
                    keep = True
                    if j.get('on'):
                        keep = j['on'](*left, right)
                    if not keep:
                        continue
                    m = True; joined.append(left + [right])
                if j.get('left') and not m:
                    joined.append(left + [None])
        items = joined
    if opts.get('where'):
        items = [r for r in items if opts['where'](*r)]
    if opts.get('sortKey'):
        items.sort(key=lambda it: opts['sortKey'](*it))
    if 'skip' in opts:
        n = opts['skip']
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if 'take' in opts:
        n = opts['take']
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts['select'](*r))
    return res
if __name__ == "__main__":
	main()
