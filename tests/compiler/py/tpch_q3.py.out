# Generated by Mochi Python compiler
from __future__ import annotations

from typing import Any, TypeVar, Generic, Callable
T = TypeVar('T')
K = TypeVar('K')
def _get(obj, name):
    if obj is None:
        return None
    if isinstance(obj, dict):
        if name in obj:
            return obj[name]
    if hasattr(obj, name):
        return getattr(obj, name)
    if isinstance(obj, (list, tuple)):
        for it in obj:
            try:
                return _get(it, name)
            except Exception:
                pass
    raise Exception('field not found: ' + name)
class _Group(Generic[K, T]):
    def __init__(self, key: K):
        self.key = key
        self.Items: list[T] = []
    def __iter__(self):
        return iter(self.Items)
def _group_by(src: list[T], keyfn: Callable[[T], K]) -> list[_Group[K, T]]:
    groups: dict[str, _Group[K, T]] = {}
    order: list[str] = []
    for it in src:
        if isinstance(it, (list, tuple)):
            key = keyfn(*it)
        else:
            key = keyfn(it)
        if isinstance(key, dict):
            import types
            key = types.SimpleNamespace(**key)
        ks = str(key)
        g = groups.get(ks)
        if not g:
            g = _Group(key)
            groups[ks] = g
            order.append(ks)
        g.Items.append(it)
    return [ groups[k] for k in order ]
def _query(src, joins, opts):
    items = [[v] for v in src]
    for j in joins:
        joined = []
        if j.get('right') and j.get('left'):
            matched = [False] * len(j['items'])
            for left in items:
                m = False
                for ri, right in enumerate(j['items']):
                    keep = True
                    if j.get('on'):
                        keep = j['on'](*left, right)
                    if not keep:
                        continue
                    m = True; matched[ri] = True
                    joined.append(left + [right])
                if not m:
                    joined.append(left + [None])
            for ri, right in enumerate(j['items']):
                if not matched[ri]:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        elif j.get('right'):
            for right in j['items']:
                m = False
                for left in items:
                    keep = True
                    if j.get('on'):
                        keep = j['on'](*left, right)
                    if not keep:
                        continue
                    m = True; joined.append(left + [right])
                if not m:
                    undef = [None] * (len(items[0]) if items else 0)
                    joined.append(undef + [right])
        else:
            for left in items:
                m = False
                for right in j['items']:
                    keep = True
                    if j.get('on'):
                        keep = j['on'](*left, right)
                    if not keep:
                        continue
                    m = True; joined.append(left + [right])
                if j.get('left') and not m:
                    joined.append(left + [None])
        items = joined
    if opts.get('where'):
        items = [r for r in items if opts['where'](*r)]
    if opts.get('sortKey'):
        def _key(it):
            k = opts['sortKey'](*it)
            if isinstance(k, (list, tuple, dict)):
                return str(k)
            return k
        items.sort(key=_key)
    if 'skip' in opts:
        n = opts['skip']
        if n < 0:
            n = 0
        items = items[n:] if n < len(items) else []
    if 'take' in opts:
        n = opts['take']
        if n < 0:
            n = 0
        items = items[:n] if n < len(items) else items
    res = []
    for r in items:
        res.append(opts['select'](*r))
    return res
def _sort_key(k):
    if isinstance(k, (list, tuple, dict)):
        return str(k)
    return k
def _sum(v):
    if hasattr(v, 'Items'):
        v = v.Items
    if not isinstance(v, list):
        raise Exception('sum() expects list or group')
    s = 0.0
    for it in v:
        if it is None:
            continue
        if isinstance(it, (int, float)):
            s += float(it)
        else:
            raise Exception('sum() expects numbers')
    return s
customer = None
orders = None
lineitem = None
cutoff = "1995-03-15"
segment = "BUILDING"
building_customers = None
valid_orders = None
valid_lineitems = None
order_line_join = None

def test_Q3_returns_revenue_per_order_with_correct_priority():
	assert (order_line_join == [{"l_orderkey": 100, "revenue": ((1000 * 0.95) + 500), "o_orderdate": "1995-03-14", "o_shippriority": 1}])

def main():
	global customer
	customer = [{"c_custkey": 1, "c_mktsegment": "BUILDING"}, {"c_custkey": 2, "c_mktsegment": "AUTOMOBILE"}]
	global orders
	orders = [{"o_orderkey": 100, "o_custkey": 1, "o_orderdate": "1995-03-14", "o_shippriority": 1}, {"o_orderkey": 200, "o_custkey": 2, "o_orderdate": "1995-03-10", "o_shippriority": 2}]
	global lineitem
	lineitem = [{"l_orderkey": 100, "l_extendedprice": 1000, "l_discount": 0.05, "l_shipdate": "1995-03-16"}, {"l_orderkey": 100, "l_extendedprice": 500, "l_discount": 0, "l_shipdate": "1995-03-20"}, {"l_orderkey": 200, "l_extendedprice": 1000, "l_discount": 0.1, "l_shipdate": "1995-03-14"}]
	global cutoff
	cutoff = "1995-03-15"
	global segment
	segment = "BUILDING"
	global building_customers
	building_customers = [ c for c in customer if (c["c_mktsegment"] == segment) ]
	global valid_orders
	valid_orders = _query(orders, [{ 'items': building_customers, 'on': lambda o, c: ((o["o_custkey"] == c["c_custkey"])) }], { 'select': lambda o, c: o, 'where': lambda o, c: ((o["o_orderdate"] < cutoff)) })
	global valid_lineitems
	valid_lineitems = [ l for l in lineitem if (l["l_shipdate"] > cutoff) ]
	def _q0():
		_src = valid_orders
		_rows = _query(_src, [{ 'items': valid_lineitems, 'on': lambda o, l: ((l["l_orderkey"] == o["o_orderkey"])) }], { 'select': lambda o, l: (o, l) })
		_groups = _group_by(_rows, lambda o, l: ({"o_orderkey": o["o_orderkey"], "o_orderdate": o["o_orderdate"], "o_shippriority": o["o_shippriority"]}))
		items = _groups
		items = sorted(items, key=lambda g: _sort_key([(-_sum([ (r[1]["l_extendedprice"] * ((1 - r[1]["l_discount"]))) for r in g ])), _get(_get(g, "key"), "o_orderdate")]))
		return [ {"l_orderkey": _get(_get(g, "key"), "o_orderkey"), "revenue": _sum([ (r[1]["l_extendedprice"] * ((1 - r[1]["l_discount"]))) for r in g ]), "o_orderdate": _get(_get(g, "key"), "o_orderdate"), "o_shippriority": _get(_get(g, "key"), "o_shippriority")} for g in items ]
	
	global order_line_join
	order_line_join = _q0()
	print(*order_line_join)
	test_Q3_returns_revenue_per_order_with_correct_priority()

if __name__ == "__main__":
	main()
