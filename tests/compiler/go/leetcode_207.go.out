package main

import (
	"encoding/json"
	"fmt"
)

func canFinish(numCourses int, prerequisites [][]int) bool {
	var graph [][]int = [][]int{}
	var indegree []int = []int{}
	for _tmp0 := 0; _tmp0 < numCourses; _tmp0++ {
		graph = append(append([][]int{}, graph...), _convSlice[[]any,[]int]([][]any{[]any{}})...)
		indegree = append(append([]int{}, indegree...), []int{0}...)
	}
	for _, pair := range prerequisites {
		var a int = pair[0]
		var b int = pair[1]
		graph[b] = append(append([]int{}, graph[b]...), []int{a}...)
		indegree[a] = (indegree[a] + 1)
	}
	var queue []int = []int{}
	for i := 0; i < numCourses; i++ {
		if (indegree[i] == 0) {
			queue = append(append([]int{}, queue...), []int{i}...)
		}
	}
	var visited int = 0
	var idx int = 0
	for {
		if !((idx < len(queue))) {
			break
		}
		var course int = queue[idx]
		idx = (idx + 1)
		visited = (visited + 1)
		for _, next := range graph[course] {
			indegree[next] = (indegree[next] - 1)
			if (indegree[next] == 0) {
				queue = append(append([]int{}, queue...), []int{next}...)
			}
		}
	}
	return (visited == numCourses)
}

func main() {
	fmt.Println(canFinish(2, [][]int{[]int{1, 0}}))
	fmt.Println(canFinish(2, [][]int{[]int{1, 0}, []int{0, 1}}))
	fmt.Println(canFinish(4, [][]int{[]int{1, 0}, []int{2, 1}, []int{3, 2}}))
	fmt.Println(canFinish(3, [][]int{[]int{0, 1}, []int{1, 2}, []int{2, 0}}))
}

func _cast[T any](v any) T {
    data, err := json.Marshal(v)
    if err != nil { panic(err) }
    var out T
    if err := json.Unmarshal(data, &out); err != nil { panic(err) }
    return out
}

func _convSlice[T any, U any](s []T) []U {
    out := make([]U, len(s))
    for i, v := range s {
        if vv, ok := any(v).(U); ok {
            out[i] = vv
        } else {
            out[i] = _cast[U](v)
        }
    }
    return out
}
