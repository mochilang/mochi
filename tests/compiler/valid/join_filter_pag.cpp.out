// Generated by Mochi C++ compiler
#include <bits/stdc++.h>
using namespace std;

template <typename T> inline void _hash_combine(size_t &seed, const T &v) {
  seed ^= std::hash<T>{}(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

struct Person {
  int id;
  string name;
};
inline bool operator==(const Person &a, const Person &b) {
  return a.id == b.id && a.name == b.name;
}
namespace std {
template <> struct hash<Person> {
  size_t operator()(const Person &k) const noexcept {
    size_t h = 0;
    _hash_combine(h, k.id);
    _hash_combine(h, k.name);
    return h;
  }
};
} // namespace std

struct Purchase {
  int id;
  int personId;
  int total;
};
inline bool operator==(const Purchase &a, const Purchase &b) {
  return a.id == b.id && a.personId == b.personId && a.total == b.total;
}
namespace std {
template <> struct hash<Purchase> {
  size_t operator()(const Purchase &k) const noexcept {
    size_t h = 0;
    _hash_combine(h, k.id);
    _hash_combine(h, k.personId);
    _hash_combine(h, k.total);
    return h;
  }
};
} // namespace std

int main() {
  vector<Person> people =
      vector<Person>{Person{1, string("Alice")}, Person{2, string("Bob")},
                     Person{3, string("Charlie")}};
  vector<Purchase> purchases = vector<Purchase>{
      Purchase{1, 1, 200}, Purchase{2, 1, 50}, Purchase{3, 2, 150},
      Purchase{4, 3, 100}, Purchase{5, 2, 250}};
  auto result = ([&]() -> vector<unordered_map<string, any>> {
    vector<pair<unordered_map<string, any>, unordered_map<string, any>>> _tmp;
    for (auto &p : people) {
      for (auto &o : purchases) {
        if (!(p.id == o.personId))
          continue;
        if (o.total > 100) {
          _tmp.push_back({-o.total, unordered_map<string, any>{
                                        {string("person"), any(p.name)},
                                        {string("spent"), any(o.total)}}});
        }
      }
    }
    std::sort(_tmp.begin(), _tmp.end(),
              [](const auto &a, const auto &b) { return a.first < b.first; });
    vector<unordered_map<string, any>> _res;
    _res.reserve(_tmp.size());
    for (auto &_it : _tmp)
      _res.push_back(_it.second);
    int _skip = 1;
    if (_skip < (int)_res.size())
      _res.erase(_res.begin(), _res.begin() + _skip);
    else
      _res.clear();
    int _take = 2;
    if (_take < (int)_res.size())
      _res.resize(_take);
    return _res;
  })();
  for (const unordered_map<string, any> &r : result) {
    std::cout << (r["person"]) << " " << (r["spent"]) << std::endl;
  }
  return 0;
}
