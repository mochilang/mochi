// Original Mochi source:
// // Build BST from sorted list using nested recursive function
// 
//  type Tree =
//    Leaf
//    | Node(left: Tree, value: int, right: Tree)
// 
//  fun fromList(nums: list<int>): Tree {
//    fun helper(lo: int, hi: int): Tree {
//      if lo >= hi { return Leaf {} }
//      let mid = (lo + hi) / 2
//      return Node {
//        left: helper(lo, mid),
//        value: nums[mid],
//        right: helper(mid + 1, hi)
//      }
//    }
//    return helper(0, len(nums))
//  }
// 
//  fun inorder(t: Tree): list<int> {
//    return match t {
//      Leaf => []
//      Node(l, v, r) => inorder(l) + [v] + inorder(r)
//    }
//  }
// 
//  print(inorder(fromList([-10, -3, 0, 5, 9])))
// 

#include <bits/stdc++.h>
using namespace std;

//  type Tree =
struct Leaf {
};
struct Node {
    Tree left;
    int value;
    Tree right;
};
using Tree = std::variant<Leaf, Node>;

//  fun fromList(nums: list<int>): Tree {
Tree fromList(vector<int> nums){
    //    fun helper(lo: int, hi: int): Tree {
    //    return helper(0, len(nums))
    return helper(0, nums.size());
}

//  fun inorder(t: Tree): list<int> {
vector<int> inorder(Tree t){
    //    return match t {
    return ([&]() { auto _t0 = t; if (std::holds_alternative<Leaf>(_t0)) return vector<int>{}; if (std::holds_alternative<Node>(_t0)) { auto _v = std::get<Node>(_t0); auto l = _v.left; auto v = _v.value; auto r = _v.right; return ([&](vector<int> a, vector<int> b){ a.insert(a.end(), b.begin(), b.end()); return a; })(([&](vector<int> a, vector<int> b){ a.insert(a.end(), b.begin(), b.end()); return a; })(inorder(l), vector<int>{v}), inorder(r)); }return {}; })();
}

int main() {
    //  type Tree =
    //  print(inorder(fromList([-10, -3, 0, 5, 9])))
    std::cout << (inorder(fromList(vector<int>{-10, -3, 0, 5, 9}))) << std::endl;
    return 0;
}
