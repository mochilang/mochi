// Generated by Mochi C++ compiler
#include <bits/stdc++.h>
using namespace std;

template <typename T> inline void _hash_combine(size_t &seed, const T &v) {
  seed ^= std::hash<T>{}(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

struct Customer {
  int id;
  string name;
};
inline bool operator==(const Customer &a, const Customer &b) {
  return a.id == b.id && a.name == b.name;
}
namespace std {
template <> struct hash<Customer> {
  size_t operator()(const Customer &k) const noexcept {
    size_t h = 0;
    _hash_combine(h, k.id);
    _hash_combine(h, k.name);
    return h;
  }
};
} // namespace std

struct Order {
  int id;
  int customerId;
  int total;
};
inline bool operator==(const Order &a, const Order &b) {
  return a.id == b.id && a.customerId == b.customerId && a.total == b.total;
}
namespace std {
template <> struct hash<Order> {
  size_t operator()(const Order &k) const noexcept {
    size_t h = 0;
    _hash_combine(h, k.id);
    _hash_combine(h, k.customerId);
    _hash_combine(h, k.total);
    return h;
  }
};
} // namespace std

struct PairInfo {
  int orderId;
  int orderCustomerId;
  string pairedCustomerName;
  int orderTotal;
};
inline bool operator==(const PairInfo &a, const PairInfo &b) {
  return a.orderId == b.orderId && a.orderCustomerId == b.orderCustomerId &&
         a.pairedCustomerName == b.pairedCustomerName &&
         a.orderTotal == b.orderTotal;
}
namespace std {
template <> struct hash<PairInfo> {
  size_t operator()(const PairInfo &k) const noexcept {
    size_t h = 0;
    _hash_combine(h, k.orderId);
    _hash_combine(h, k.orderCustomerId);
    _hash_combine(h, k.pairedCustomerName);
    _hash_combine(h, k.orderTotal);
    return h;
  }
};
} // namespace std

int main() {
  vector<Customer> customers =
      vector<Customer>{Customer{1, string("Alice")}, Customer{2, string("Bob")},
                       Customer{3, string("Charlie")}};
  vector<Order> orders =
      vector<Order>{Order{100, 1, 250}, Order{101, 2, 125}, Order{102, 1, 300}};
  auto result = ([&]() -> vector<PairInfo> {
    vector<PairInfo> _res;
    for (auto &o : orders) {
      for (auto &c : customers) {
        _res.push_back(PairInfo{o.id, o.customerId, c.name, o.total});
      }
    }
    return _res;
  })();
  std::cout << (string("--- Cross Join: All order-customer pairs ---"))
            << std::endl;
  for (const PairInfo &entry : result) {
    std::cout << (string("Order")) << " " << (entry.orderId) << " "
              << (string("(customerId:")) << " " << (entry.orderCustomerId)
              << " " << (string(", total: $")) << " " << (entry.orderTotal)
              << " " << (string(") paired with")) << " "
              << (entry.pairedCustomerName) << std::endl;
  }
  return 0;
}
