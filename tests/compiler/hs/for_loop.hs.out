module Main where

import Data.Maybe (fromMaybe)


forLoop :: Int -> Int -> (Int -> Maybe a) -> Maybe a
forLoop start end f = go start
  where
    go i | i < end =
            case f i of
              Just v -> Just v
              Nothing -> go (i + 1)
         | otherwise = Nothing

avg :: Real a => [a] -> Double
avg xs | null xs = 0
      | otherwise = sum (map realToFrac xs) / fromIntegral (length xs)

_indexString :: String -> Int -> String
_indexString s i =
  let idx = if i < 0 then i + length s else i
  in if idx < 0 || idx >= length s
       then error "index out of range"
       else [s !! idx]

_input :: IO String
_input = getLine

forLoopIO :: Int -> Int -> (Int -> IO (Maybe a)) -> IO (Maybe a)
forLoopIO start end f = go start
  where
    go i | i < end = do
            r <- f i
            case r of
              Just v -> pure (Just v)
              Nothing -> go (i + 1)
         | otherwise = pure Nothing

whileLoop :: (() -> Bool) -> (() -> Maybe a) -> Maybe a
whileLoop cond body = go ()
  where
    go _ | cond () =
            case body () of
              Just v -> Just v
              Nothing -> go ()
         | otherwise = Nothing

whileLoopIO :: IO Bool -> IO (Maybe a) -> IO (Maybe a)
whileLoopIO cond body = go
  where
    go = do
      c <- cond
      if c then do
            r <- body
            case r of
              Just v -> pure (Just v)
              Nothing -> go
         else pure Nothing


main :: IO ()
main = do
    forLoopIO 1 4 (\i -> Nothing <$ (print (i))) >> return ()
