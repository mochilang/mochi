// Generated by Mochi v0.10.74 on 2025-08-27 07:38:23 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case m: scala.collection.Map[_, _] => scala.collection.immutable.ListMap(m.toSeq.sortBy(_._1.toString): _*).toString.replace("ListMap", "Map")
  case d: Double => { val i = d.toLong; if (d == i.toDouble) java.lang.Long.toString(i) else java.lang.Double.toString(d) }
  case other => String.valueOf(other)
}

def split(s: String, sep: String): ArrayBuffer[String] = {
  var parts: ArrayBuffer[String] = ArrayBuffer[String]()
  var cur: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt((s).length)) {
    if (((BigInt((sep).length) > BigInt(0) && i + BigInt((sep).length) <= BigInt((s).length)).asInstanceOf[Boolean] && s.slice((i).toInt, (i + BigInt((sep).length)).toInt) == sep)) {
      parts = (parts :+ (cur))
      cur = ""
      i = i + BigInt((sep).length)
    } else {
      cur = cur + s.slice((i).toInt, (i + BigInt(1)).toInt)
      i = i + BigInt(1)
    }
  }
  parts = (parts :+ (cur))
  return parts
}

def parse_ints(line: String): ArrayBuffer[BigInt] = {
  val pieces: ArrayBuffer[String] = ArrayBuffer(line.split(" "): _*)
  var nums: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var i: BigInt = BigInt(0)
  while (i < BigInt((pieces).size)) {
    val p: String = pieces.lift((i.toInt).toInt).getOrElse("")
    if (BigInt((p).size) > BigInt(0)) {
      nums = (nums :+ (BigInt(p.toString.toDouble.toInt)))
    }
    i = i + BigInt(1)
  }
  return nums
}

def sort_unique(arr: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
  var i: BigInt = BigInt(1)
  while (i < BigInt((arr).size)) {
    var j: BigInt = i
    while (j > BigInt(0) && arr.lift(((j - BigInt(1)).toInt).toInt).getOrElse(BigInt(0)) > arr.lift((j.toInt).toInt).getOrElse(BigInt(0))) {
      val tmp: BigInt = arr.lift(((j - BigInt(1)).toInt).toInt).getOrElse(BigInt(0))
      arr((j - BigInt(1)).toInt) = arr.lift((j.toInt).toInt).getOrElse(BigInt(0))
      arr((j).toInt) = tmp
      j = j - BigInt(1)
    }
    i = i + BigInt(1)
  }
  var res: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  i = BigInt(0)
  while (i < BigInt((arr).size)) {
    if ((i == BigInt(0) || arr.lift((i.toInt).toInt).getOrElse(BigInt(0)) != arr.lift(((i - BigInt(1)).toInt).toInt).getOrElse(BigInt(0)))) {
      res = (res :+ (arr.lift((i.toInt).toInt).getOrElse(BigInt(0))))
    }
    i = i + BigInt(1)
  }
  return res
}

def pointInPoly(xs: ArrayBuffer[BigInt], ys: ArrayBuffer[BigInt], px: Double, py: Double): Boolean = {
  var inside: Boolean = false
  var i: BigInt = BigInt(0)
  var j: BigInt = BigInt((xs).size) - BigInt(1)
  while (i < BigInt((xs).size)) {
    val xi: Double = (xs.lift((i.toInt).toInt).getOrElse(BigInt(0))).toDouble
    val yi: Double = (ys.lift((i.toInt).toInt).getOrElse(BigInt(0))).toDouble
    val xj: Double = (xs.lift((j.toInt).toInt).getOrElse(BigInt(0))).toDouble
    val yj: Double = (ys.lift((j.toInt).toInt).getOrElse(BigInt(0))).toDouble
    if (((yi > py && yj <= py).asInstanceOf[Boolean] || (yj > py && yi <= py).asInstanceOf[Boolean])) {
      val xint: Double = (xj - xi) * (py - yi) / (yj - yi) + xi
      if (px < xint) {
        inside = !inside
      }
    }
    j = i
    i = i + BigInt(1)
  }
  return inside
}

def make3DBool(a: BigInt, b: BigInt, c: BigInt): ArrayBuffer[ArrayBuffer[ArrayBuffer[Boolean]]] = {
  var arr: ArrayBuffer[ArrayBuffer[ArrayBuffer[Boolean]]] = ArrayBuffer[ArrayBuffer[ArrayBuffer[Boolean]]]()
  var i: BigInt = BigInt(0)
  while (i < a) {
    var plane: ArrayBuffer[ArrayBuffer[Boolean]] = ArrayBuffer[ArrayBuffer[Boolean]]()
    var j: BigInt = BigInt(0)
    while (j < b) {
      var row: ArrayBuffer[Boolean] = ArrayBuffer[Boolean]()
      var k: BigInt = BigInt(0)
      while (k < c) {
        row = (row :+ (false))
        k = k + BigInt(1)
      }
      plane = (plane :+ (row))
      j = j + BigInt(1)
    }
    arr = (arr :+ (plane))
    i = i + BigInt(1)
  }
  return arr
}

def main(): Any = {
  val tLine: String = (Option(scala.io.StdIn.readLine())).getOrElse("")
  if (tLine == "") {
    return
  }
  val t: BigInt = BigInt(tLine.toString.toDouble.toInt)
  var `case`: BigInt = BigInt(0)
  while (`case` < t) {
    val fLine: String = (Option(scala.io.StdIn.readLine())).getOrElse("")
    val F: BigInt = BigInt(fLine.toString.toDouble.toInt)
    var xs: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var ys: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var zs: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    xs = (xs :+ (BigInt(0)))
    xs = (xs :+ (BigInt(1001)))
    ys = (ys :+ (BigInt(0)))
    ys = (ys :+ (BigInt(1001)))
    zs = (zs :+ (BigInt(0)))
    zs = (zs :+ (BigInt(1001)))
    var faceXCoord: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    var faceYPoly: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
    var faceZPoly: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
    var i: BigInt = BigInt(0)
    while (i < F) {
      val line: String = (Option(scala.io.StdIn.readLine())).getOrElse("")
      val nums: ArrayBuffer[BigInt] = parse_ints(line)
      val P: BigInt = nums.lift((BigInt(0).toInt).toInt).getOrElse(BigInt(0))
      var ptsX: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
      var ptsY: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
      var ptsZ: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
      var j: BigInt = BigInt(0)
      while (j < P) {
        val x: BigInt = nums.lift(((BigInt(1) + BigInt(3) * j).toInt).toInt).getOrElse(BigInt(0))
        val y: BigInt = nums.lift(((BigInt(1) + BigInt(3) * j + BigInt(1)).toInt).toInt).getOrElse(BigInt(0))
        val z: BigInt = nums.lift(((BigInt(1) + BigInt(3) * j + BigInt(2)).toInt).toInt).getOrElse(BigInt(0))
        ptsX = (ptsX :+ (x))
        ptsY = (ptsY :+ (y))
        ptsZ = (ptsZ :+ (z))
        xs = (xs :+ (x))
        ys = (ys :+ (y))
        zs = (zs :+ (z))
        j = j + BigInt(1)
      }
      var allSame: Boolean = true
      j = BigInt(1)
      while (j < P) {
        if (ptsX.lift((j.toInt).toInt).getOrElse(BigInt(0)) != ptsX.lift((BigInt(0).toInt).toInt).getOrElse(BigInt(0))) {
          allSame = false
        }
        j = j + BigInt(1)
      }
      if (allSame) {
        faceXCoord = (faceXCoord :+ (ptsX.lift((BigInt(0).toInt).toInt).getOrElse(BigInt(0))))
        faceYPoly = (faceYPoly :+ (ptsY))
        faceZPoly = (faceZPoly :+ (ptsZ))
      }
      i = i + BigInt(1)
    }
    xs = sort_unique(xs)
    ys = sort_unique(ys)
    zs = sort_unique(zs)
    val nx: BigInt = BigInt((xs).size) - BigInt(1)
    val ny: BigInt = BigInt((ys).size) - BigInt(1)
    val nz: BigInt = BigInt((zs).size) - BigInt(1)
    var xIndex: scala.collection.mutable.Map[BigInt,BigInt] = (scala.collection.mutable.Map()).asInstanceOf[scala.collection.mutable.Map[BigInt,BigInt]]
    i = BigInt(0)
    while (i < BigInt((xs).size)) {
      xIndex.update(xs.lift((i.toInt).toInt).getOrElse(BigInt(0)), i)
      i = i + BigInt(1)
    }
    var dx: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    i = BigInt(0)
    while (i < nx) {
      dx = (dx :+ (xs.lift(((i + BigInt(1)).toInt).toInt).getOrElse(BigInt(0)) - xs.lift((i.toInt).toInt).getOrElse(BigInt(0))))
      i = i + BigInt(1)
    }
    var dy: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    i = BigInt(0)
    while (i < ny) {
      dy = (dy :+ (ys.lift(((i + BigInt(1)).toInt).toInt).getOrElse(BigInt(0)) - ys.lift((i.toInt).toInt).getOrElse(BigInt(0))))
      i = i + BigInt(1)
    }
    var dz: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
    i = BigInt(0)
    while (i < nz) {
      dz = (dz :+ (zs.lift(((i + BigInt(1)).toInt).toInt).getOrElse(BigInt(0)) - zs.lift((i.toInt).toInt).getOrElse(BigInt(0))))
      i = i + BigInt(1)
    }
    var blockX: ArrayBuffer[ArrayBuffer[ArrayBuffer[Boolean]]] = make3DBool(BigInt((xs).size), ny, nz)
    i = BigInt(0)
    while (i < BigInt((faceXCoord).size)) {
      val coord: BigInt = faceXCoord.lift((i.toInt).toInt).getOrElse(BigInt(0))
      val polyY: ArrayBuffer[BigInt] = faceYPoly.lift((i.toInt).toInt).getOrElse(ArrayBuffer[BigInt]())
      val polyZ: ArrayBuffer[BigInt] = faceZPoly.lift((i.toInt).toInt).getOrElse(ArrayBuffer[BigInt]())
      val xi: BigInt = xIndex.getOrElse(coord, BigInt(0)).asInstanceOf[BigInt]
      var j: BigInt = BigInt(0)
      while (j < ny) {
        val cy: Double = (ys.lift((j.toInt).toInt).getOrElse(BigInt(0)) + ys.lift(((j + BigInt(1)).toInt).toInt).getOrElse(BigInt(0))).toDouble / 2.0
        var k: BigInt = BigInt(0)
        while (k < nz) {
          val cz: Double = (zs.lift((k.toInt).toInt).getOrElse(BigInt(0)) + zs.lift(((k + BigInt(1)).toInt).toInt).getOrElse(BigInt(0))).toDouble / 2.0
          if (pointInPoly(polyY, polyZ, cy, cz)) {
            blockX((xi).toInt)((j).toInt)((k).toInt) = true
          }
          k = k + BigInt(1)
        }
        j = j + BigInt(1)
      }
      i = i + BigInt(1)
    }
    var solid: ArrayBuffer[ArrayBuffer[ArrayBuffer[Boolean]]] = make3DBool(nx, ny, nz)
    var j2: BigInt = BigInt(0)
    while (j2 < ny) {
      var k2: BigInt = BigInt(0)
      while (k2 < nz) {
        var inside: Boolean = false
        var i2: BigInt = BigInt(0)
        while (i2 < nx) {
          if (blockX.lift((i2.toInt).toInt).getOrElse(ArrayBuffer[ArrayBuffer[Boolean]]()).lift((j2.toInt).toInt).getOrElse(ArrayBuffer[Boolean]()).lift((k2.toInt).toInt).getOrElse(false)) {
            inside = !inside
          }
          if (inside) {
            solid((i2).toInt)((j2).toInt)((k2).toInt) = true
          }
          i2 = i2 + BigInt(1)
        }
        k2 = k2 + BigInt(1)
      }
      j2 = j2 + BigInt(1)
    }
    var volume: BigInt = BigInt(0)
    var i3: BigInt = BigInt(0)
    while (i3 < nx) {
      var j3: BigInt = BigInt(0)
      while (j3 < ny) {
        var k3: BigInt = BigInt(0)
        while (k3 < nz) {
          if (solid.lift((i3.toInt).toInt).getOrElse(ArrayBuffer[ArrayBuffer[Boolean]]()).lift((j3.toInt).toInt).getOrElse(ArrayBuffer[Boolean]()).lift((k3.toInt).toInt).getOrElse(false)) {
            volume = volume + dx.lift((i3.toInt).toInt).getOrElse(BigInt(0)) * dy.lift((j3.toInt).toInt).getOrElse(BigInt(0)) * dz.lift((k3.toInt).toInt).getOrElse(BigInt(0))
          }
          k3 = k3 + BigInt(1)
        }
        j3 = j3 + BigInt(1)
      }
      i3 = i3 + BigInt(1)
    }
    println(_str("The bulk is composed of " + _str(volume) + " units."))
    `case` = `case` + BigInt(1)
  }
  return null
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start).abs / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
