// Generated by Mochi v0.10.74 on 2025-08-27 07:38:37 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
    if (!_nowSeeded) { _nowSeed = 0L; _nowSeeded = true }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _str(x: Any): String = x match {
  case m: scala.collection.Map[_, _] => scala.collection.immutable.ListMap(m.toSeq.sortBy(_._1.toString): _*).toString.replace("ListMap", "Map")
  case d: Double => { val i = d.toLong; if (d == i.toDouble) java.lang.Long.toString(i) else java.lang.Double.toString(d) }
  case other => String.valueOf(other)
}

def parseInt(s: String): BigInt = {
  var i: BigInt = BigInt(0)
  var n: BigInt = BigInt(0)
  while (i < BigInt((s).length)) {
    n = n * BigInt(10) + digits.getOrElse(s.slice((i).toInt, (i + BigInt(1)).toInt), BigInt(0)).asInstanceOf[BigInt]
    i = i + BigInt(1)
  }
  return n
}

def split(s: String): ArrayBuffer[String] = {
  var parts: ArrayBuffer[String] = ArrayBuffer[String]()
  var cur: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt((s).length)) {
    val ch: String = s.slice((i).toInt, (i + BigInt(1)).toInt)
    if (ch == " ") {
      if (BigInt((cur).length) > BigInt(0)) {
        parts = (parts :+ (cur))
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + BigInt(1)
  }
  if (BigInt((cur).length) > BigInt(0)) {
    parts = (parts :+ (cur))
  }
  return parts
}

def absf(x: Double): Double = {
  if (x < 0.0) {
    return -x
  } else {
    return x
  }
  return 0.0
}

def sqrt(x: Double): Double = {
  if (x <= 0.0) {
    return 0.0
  }
  var r: Double = x
  var prev: Double = 0.0
  while (absf(r - prev) > 1e-12) {
    prev = r
    r = (r + x / r) / 2.0
  }
  return r
}

def makeBoolGrid(P: BigInt, Q: BigInt): ArrayBuffer[ArrayBuffer[Boolean]] = {
  var g: ArrayBuffer[ArrayBuffer[Boolean]] = ArrayBuffer[ArrayBuffer[Boolean]]()
  var i: BigInt = BigInt(0)
  while (i < P) {
    var row: ArrayBuffer[Boolean] = ArrayBuffer[Boolean]()
    var j: BigInt = BigInt(0)
    while (j < Q) {
      row = (row :+ (false))
      j = j + BigInt(1)
    }
    g = (g :+ (row))
    i = i + BigInt(1)
  }
  return g
}

def visible(grid: ArrayBuffer[ArrayBuffer[BigInt]], P: BigInt, Q: BigInt, R: BigInt, C: BigInt, BR: BigInt, BC: BigInt): Boolean = {
  val X1: Double = C.toDouble - 0.5
  val Y1: Double = R.toDouble - 0.5
  val Z1: Double = (grid.lift((R - BigInt(1).toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((C - BigInt(1).toInt).toInt).getOrElse(BigInt(0))).toDouble + 0.5
  val X2: Double = BC.toDouble - 0.5
  val Y2: Double = BR.toDouble - 0.5
  val Z2: Double = (grid.lift((BR - BigInt(1).toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((BC - BigInt(1).toInt).toInt).getOrElse(BigInt(0))).toDouble + 0.5
  val Dx: Double = X2 - X1
  val Dy: Double = Y2 - Y1
  val Dz: Double = Z2 - Z1
  val dist: Double = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
  var steps: BigInt = BigInt((dist * 20.0).toInt) + BigInt(1)
  val stepT: Double = 1.0 / steps.toDouble
  var i: BigInt = BigInt(1)
  while (i < steps) {
    val t: Double = stepT * i.toDouble
    val X: Double = X1 + Dx * t
    val Y: Double = Y1 + Dy * t
    val Z: Double = Z1 + Dz * t
    val rIdx: BigInt = BigInt(Y.toString.toDouble.toInt) + BigInt(1)
    val cIdx: BigInt = BigInt(X.toString.toDouble.toInt) + BigInt(1)
    if ((((rIdx < BigInt(1) || rIdx > P).asInstanceOf[Boolean] || cIdx < BigInt(1)).asInstanceOf[Boolean] || cIdx > Q)) {
      return false
    }
    val H: Double = (grid.lift((rIdx - BigInt(1).toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((cIdx - BigInt(1).toInt).toInt).getOrElse(BigInt(0))).toDouble
    if (Z <= H) {
      return false
    }
    i = i + BigInt(1)
  }
  return true
}

def computeVis(grid: ArrayBuffer[ArrayBuffer[BigInt]], P: BigInt, Q: BigInt, BR: BigInt, BC: BigInt): ArrayBuffer[ArrayBuffer[Boolean]] = {
  var vis: ArrayBuffer[ArrayBuffer[Boolean]] = makeBoolGrid(P, Q)
  var r: BigInt = BigInt(1)
  while (r <= P) {
    var c: BigInt = BigInt(1)
    while (c <= Q) {
      vis((r - BigInt(1)).toInt)((c - BigInt(1)).toInt) = visible(grid, P, Q, r, c, BR, BC)
      c = c + BigInt(1)
    }
    r = r + BigInt(1)
  }
  return vis
}

def bfs(grid: ArrayBuffer[ArrayBuffer[BigInt]], P: BigInt, Q: BigInt, R1: BigInt, C1: BigInt, R2: BigInt, C2: BigInt): BigInt = {
  val vis1: ArrayBuffer[ArrayBuffer[Boolean]] = computeVis(grid, P, Q, R1, C1)
  val vis2: ArrayBuffer[ArrayBuffer[Boolean]] = computeVis(grid, P, Q, R2, C2)
  var visited: ArrayBuffer[ArrayBuffer[Boolean]] = makeBoolGrid(P, Q)
  var qR: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var qC: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  var qD: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
  qR = (qR :+ (R1))
  qC = (qC :+ (C1))
  qD = (qD :+ (BigInt(0)))
  visited((R1 - BigInt(1)).toInt)((C1 - BigInt(1)).toInt) = true
  var head: BigInt = BigInt(0)
  while (head < BigInt((qR).size)) {
    val r: BigInt = qR.lift((head.toInt).toInt).getOrElse(BigInt(0))
    val c: BigInt = qC.lift((head.toInt).toInt).getOrElse(BigInt(0))
    val d: BigInt = qD.lift((head.toInt).toInt).getOrElse(BigInt(0))
    if ((r == R2 && c == C2)) {
      return d
    }
    val hr: BigInt = grid.lift((r - BigInt(1).toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((c - BigInt(1).toInt).toInt).getOrElse(BigInt(0))
    var idx: BigInt = BigInt(0)
    while (idx < BigInt(4)) {
      var nr: BigInt = r
      var nc: BigInt = c
      if (idx == BigInt(0)) {
        nr = nr - BigInt(1)
      }
      if (idx == BigInt(1)) {
        nr = nr + BigInt(1)
      }
      if (idx == BigInt(2)) {
        nc = nc - BigInt(1)
      }
      if (idx == BigInt(3)) {
        nc = nc + BigInt(1)
      }
      if ((((nr >= BigInt(1) && nr <= P).asInstanceOf[Boolean] && nc >= BigInt(1)).asInstanceOf[Boolean] && nc <= Q)) {
        if (!visited.lift((nr - BigInt(1).toInt).toInt).getOrElse(ArrayBuffer[Boolean]()).lift((nc - BigInt(1).toInt).toInt).getOrElse(false)) {
          val hn: BigInt = grid.lift((nr - BigInt(1).toInt).toInt).getOrElse(ArrayBuffer[BigInt]()).lift((nc - BigInt(1).toInt).toInt).getOrElse(BigInt(0))
          val diff: BigInt = hn - hr
          if ((diff <= BigInt(1) && diff >= BigInt(-3))) {
            if ((vis1.lift((nr - BigInt(1).toInt).toInt).getOrElse(ArrayBuffer[Boolean]()).lift((nc - BigInt(1).toInt).toInt).getOrElse(false) || vis2.lift((nr - BigInt(1).toInt).toInt).getOrElse(ArrayBuffer[Boolean]()).lift((nc - BigInt(1).toInt).toInt).getOrElse(false))) {
              visited((nr - BigInt(1)).toInt)((nc - BigInt(1)).toInt) = true
              qR = (qR :+ (nr))
              qC = (qC :+ (nc))
              qD = (qD :+ (d + BigInt(1)))
            }
          }
        }
      }
      idx = idx + BigInt(1)
    }
    head = head + BigInt(1)
  }
  return BigInt(-1)
}

def main(): Any = {
  val tLine: String = (Option(scala.io.StdIn.readLine())).getOrElse("")
  if (tLine == "") {
    return
  }
  val t: BigInt = parseInt(tLine)
  var `case`: BigInt = BigInt(0)
  while (`case` < t) {
    var line: String = (Option(scala.io.StdIn.readLine())).getOrElse("")
    while (line == "") {
      line = ((Option(scala.io.StdIn.readLine())).getOrElse("")).toString
    }
    val pq: ArrayBuffer[String] = split(line)
    val P: BigInt = parseInt(pq.lift((BigInt(0).toInt).toInt).getOrElse(""))
    val Q: BigInt = parseInt(pq.lift((BigInt(1).toInt).toInt).getOrElse(""))
    var grid: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer[ArrayBuffer[BigInt]]()
    var r: BigInt = BigInt(0)
    while (r < P) {
      val rowParts: ArrayBuffer[String] = split(((Option(scala.io.StdIn.readLine())).getOrElse("")).toString)
      var row: ArrayBuffer[BigInt] = ArrayBuffer[BigInt]()
      var c: BigInt = BigInt(0)
      while (c < Q) {
        row = (row :+ (parseInt(rowParts.lift((c.toInt).toInt).getOrElse(""))))
        c = c + BigInt(1)
      }
      grid = (grid :+ (row))
      r = r + BigInt(1)
    }
    val coords: ArrayBuffer[String] = split(((Option(scala.io.StdIn.readLine())).getOrElse("")).toString)
    val R1: BigInt = parseInt(coords.lift((BigInt(0).toInt).toInt).getOrElse(""))
    val C1: BigInt = parseInt(coords.lift((BigInt(1).toInt).toInt).getOrElse(""))
    val R2: BigInt = parseInt(coords.lift((BigInt(2).toInt).toInt).getOrElse(""))
    val C2: BigInt = parseInt(coords.lift((BigInt(3).toInt).toInt).getOrElse(""))
    val res: BigInt = bfs(grid, P, Q, R1, C1, R2, C2)
    if (res < BigInt(0)) {
      println(_str("Mission impossible!"))
    } else {
      println(_str("The shortest path is " + _str(res) + " steps long."))
    }
    `case` = `case` + BigInt(1)
  }
  return null
}

val digits: Map[String,BigInt] = scala.collection.mutable.Map("0" -> (BigInt(0)), "1" -> (BigInt(1)), "2" -> (BigInt(2)), "3" -> (BigInt(3)), "4" -> (BigInt(4)), "5" -> (BigInt(5)), "6" -> (BigInt(6)), "7" -> (BigInt(7)), "8" -> (BigInt(8)), "9" -> (BigInt(9)))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start).abs / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
