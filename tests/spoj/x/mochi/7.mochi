// Solution for SPOJ BULK - The Bulk!
// https://www.spoj.com/problems/BULK/

fun split(s: string, sep: string): list<string> {
  var parts: list<string> = []
  var cur: string = ""
  var i: int = 0
  while i < len(s) {
    if len(sep) > 0 && i + len(sep) <= len(s) && substring(s, i, i + len(sep)) == sep {
      parts = append(parts, cur)
      cur = ""
      i = i + len(sep)
    } else {
      cur = cur + s[i:i+1]
      i = i + 1
    }
  }
  parts = append(parts, cur)
  return parts
}

fun parse_ints(line: string): list<int> {
  let pieces = split(line, " ")
  var nums: list<int> = []
  var i = 0
  while i < len(pieces) {
    let p = pieces[i]
    if len(p) > 0 {
      nums = append(nums, p as int)
    }
    i = i + 1
  }
  return nums
}

fun sort_unique(arr: list<int>): list<int> {
  var i = 1
  while i < len(arr) {
    var j = i
    while j > 0 && arr[j-1] > arr[j] {
      let tmp = arr[j-1]
      arr[j-1] = arr[j]
      arr[j] = tmp
      j = j - 1
    }
    i = i + 1
  }
  var res: list<int> = []
  i = 0
  while i < len(arr) {
    if i == 0 || arr[i] != arr[i-1] {
      res = append(res, arr[i])
    }
    i = i + 1
  }
  return res
}

fun pointInPoly(xs: list<int>, ys: list<int>, px: float, py: float): bool {
  var inside = false
  var i = 0
  var j = len(xs) - 1
  while i < len(xs) {
    let xi = xs[i] as float
    let yi = ys[i] as float
    let xj = xs[j] as float
    let yj = ys[j] as float
    if ((yi > py) && (yj <= py)) || ((yj > py) && (yi <= py)) {
      let xint = (xj - xi) * (py - yi) / (yj - yi) + xi
      if px < xint {
        inside = !inside
      }
    }
    j = i
    i = i + 1
  }
  return inside
}

fun make3DBool(a: int, b: int, c: int): list<list<list<bool>>> {
  var arr: list<list<list<bool>>> = []
  var i = 0
  while i < a {
    var plane: list<list<bool>> = []
    var j = 0
    while j < b {
      var row: list<bool> = []
      var k = 0
      while k < c {
        row = append(row, false)
        k = k + 1
      }
      plane = append(plane, row)
      j = j + 1
    }
    arr = append(arr, plane)
    i = i + 1
  }
  return arr
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let t = tLine as int
  var case = 0
  while case < t {
    let fLine = input()
    let F = fLine as int
    var xs: list<int> = []
    var ys: list<int> = []
    var zs: list<int> = []
    xs = append(xs, 0)
    xs = append(xs, 1001)
    ys = append(ys, 0)
    ys = append(ys, 1001)
    zs = append(zs, 0)
    zs = append(zs, 1001)
    var faceXCoord: list<int> = []
    var faceYPoly: list<list<int>> = []
    var faceZPoly: list<list<int>> = []
    var i = 0
    while i < F {
      let line = input()
      let nums = parse_ints(line)
      let P = nums[0]
      var ptsX: list<int> = []
      var ptsY: list<int> = []
      var ptsZ: list<int> = []
      var j = 0
      while j < P {
        let x = nums[1 + 3*j]
        let y = nums[1 + 3*j + 1]
        let z = nums[1 + 3*j + 2]
        ptsX = append(ptsX, x)
        ptsY = append(ptsY, y)
        ptsZ = append(ptsZ, z)
        xs = append(xs, x)
        ys = append(ys, y)
        zs = append(zs, z)
        j = j + 1
      }
      var allSame = true
      j = 1
      while j < P {
        if ptsX[j] != ptsX[0] { allSame = false }
        j = j + 1
      }
      if allSame {
        faceXCoord = append(faceXCoord, ptsX[0])
        faceYPoly = append(faceYPoly, ptsY)
        faceZPoly = append(faceZPoly, ptsZ)
      }
      i = i + 1
    }
    xs = sort_unique(xs)
    ys = sort_unique(ys)
    zs = sort_unique(zs)
    let nx = len(xs) - 1
    let ny = len(ys) - 1
    let nz = len(zs) - 1
    var xIndex: map<int, int> = {}
    i = 0
    while i < len(xs) {
      xIndex[xs[i]] = i
      i = i + 1
    }
    var dx: list<int> = []
    i = 0
    while i < nx {
      dx = append(dx, xs[i+1] - xs[i])
      i = i + 1
    }
    var dy: list<int> = []
    i = 0
    while i < ny {
      dy = append(dy, ys[i+1] - ys[i])
      i = i + 1
    }
    var dz: list<int> = []
    i = 0
    while i < nz {
      dz = append(dz, zs[i+1] - zs[i])
      i = i + 1
    }
    var blockX = make3DBool(len(xs), ny, nz)
    i = 0
    while i < len(faceXCoord) {
      let coord = faceXCoord[i]
      let polyY = faceYPoly[i]
      let polyZ = faceZPoly[i]
      let xi = xIndex[coord]
      var j = 0
      while j < ny {
        let cy = ((ys[j] + ys[j+1]) as float) / 2.0
        var k = 0
        while k < nz {
          let cz = ((zs[k] + zs[k+1]) as float) / 2.0
          if pointInPoly(polyY, polyZ, cy, cz) {
            blockX[xi][j][k] = true
          }
          k = k + 1
        }
        j = j + 1
      }
      i = i + 1
    }
    var solid = make3DBool(nx, ny, nz)
    var j2 = 0
    while j2 < ny {
      var k2 = 0
      while k2 < nz {
        var inside = false
        var i2 = 0
        while i2 < nx {
          if blockX[i2][j2][k2] {
            inside = !inside
          }
          if inside {
            solid[i2][j2][k2] = true
          }
          i2 = i2 + 1
        }
        k2 = k2 + 1
      }
      j2 = j2 + 1
    }
    var volume = 0
    var i3 = 0
    while i3 < nx {
      var j3 = 0
      while j3 < ny {
        var k3 = 0
        while k3 < nz {
          if solid[i3][j3][k3] {
            volume = volume + dx[i3] * dy[j3] * dz[k3]
          }
          k3 = k3 + 1
        }
        j3 = j3 + 1
      }
      i3 = i3 + 1
    }
    print("The bulk is composed of " + str(volume) + " units.")
    case = case + 1
  }
}

main()
