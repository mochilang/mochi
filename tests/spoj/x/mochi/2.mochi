// https://www.spoj.com/problems/PRIME1
// Prime Generator using segmented sieve

fun split(s: string, sep: string): list<string> {
  var parts: list<string> = []
  var cur: string = ""
  var i: int = 0
  while i < len(s) {
    if len(sep) > 0 && i + len(sep) <= len(s) && substring(s, i, i + len(sep)) == sep {
      parts = append(parts, cur)
      cur = ""
      i = i + len(sep)
    } else {
      cur = cur + s[i:i+1]
      i = i + 1
    }
  }
  parts = append(parts, cur)
  return parts
}

fun precompute(limit: int): list<int> {
  var sieve: list<bool> = []
  for i in 0..(limit + 1) {
    sieve = append(sieve, true)
  }
  sieve[0] = false
  sieve[1] = false
  var p: int = 2
  while p * p <= limit {
    if sieve[p] {
      var j: int = p * p
      while j <= limit {
        sieve[j] = false
        j = j + p
      }
    }
    p = p + 1
  }
  var primes: list<int> = []
  for i in 2..(limit + 1) {
    if sieve[i] {
      primes = append(primes, i)
    }
  }
  return primes
}

let primes = precompute(32000)
let t = input() as int
var case_idx: int = 0
while case_idx < t {
  let line = input()
  let parts = split(line, " ")
  let m = parts[0] as int
  let n = parts[1] as int
  let size = n - m + 1
  var segment: list<bool> = []
  for i in 0..size {
    segment = append(segment, true)
  }
  for p in primes {
    if p * p > n {
      break
    }
    var start = p * p
    if start < m {
      let rem = m % p
      if rem == 0 {
        start = m
      } else {
        start = m + (p - rem)
      }
    }
    var j = start
    while j <= n {
      segment[j - m] = false
      j = j + p
    }
  }
  if m == 1 {
    segment[0] = false
  }
  var i = 0
  while i < size {
    if segment[i] {
      print(i + m)
    }
    i = i + 1
  }
  if case_idx < t - 1 {
    print("")
  }
  case_idx = case_idx + 1
}
