# Code generated by Mochi transpiler 2025-08-27 07:05 +0700
defmodule Main do
  defp _input() do
    case IO.gets("") do
      nil -> ""
      :eof -> ""
      line -> String.trim(line)
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def parseInt(s) do
    try do
      i = 0
      n = 0
      while_fun = fn while_fun, i, n ->
        if i < _len(s) do
          n = n * 10 + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Process.get(:digits)[_slice(s, i, (i + 1) - i)]))
          i = i + 1
          while_fun.(while_fun, i, n)
        else
          {i, n}
        end
      end
      {_, _} = try do
          while_fun.(while_fun, i, n)
        catch
          {:break, {_, _}} -> {0, 0}
        end

      throw {:return, n}
    catch
      {:return, val} -> val
    end
  end
  def split(s) do
    try do
      parts = []
      cur = ""
      i = 0
      while_fun_2 = fn while_fun_2, cur, i, parts ->
        if i < _len(s) do
          ch = _slice(s, i, (i + 1) - i)
          {cur, parts} = if ch == " " do
            {cur, parts} = if _len(cur) > 0 do
              parts = (parts ++ [cur])
              cur = ""
              {cur, parts}
            else
              {cur, parts}
            end
            {cur, parts}
          else
            cur = (cur <> ch)
            {cur, parts}
          end
          i = i + 1
          while_fun_2.(while_fun_2, cur, i, parts)
        else
          {cur, i, parts}
        end
      end
      {cur, _, parts} = try do
          while_fun_2.(while_fun_2, cur, i, parts)
        catch
          {:break, {cur, _, parts}} -> {cur, 0, parts}
        end

      parts = if _len(cur) > 0 do
        parts = (parts ++ [cur])
        parts
      else
        parts
      end
      throw {:return, parts}
    catch
      {:return, val} -> val
    end
  end
  def absf(x) do
    try do
      if x < 0.0 do
        throw {:return, -x}
      else
        throw {:return, x}
      end
    catch
      {:return, val} -> val
    end
  end
  def sqrt(x) do
    try do
      if x <= 0.0 do
        throw {:return, 0.0}
      end
      r = x
      prev = 0.0
      while_fun_3 = fn while_fun_3, prev, r ->
        if absf(r - prev) > 0.000000000001 do
          prev = r
          r = (r + x / r) / 2.0
          while_fun_3.(while_fun_3, prev, r)
        else
          {prev, r}
        end
      end
      {prev, _} = try do
          while_fun_3.(while_fun_3, prev, r)
        catch
          {:break, {prev, _}} -> {prev, 0}
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def makeBoolGrid(p, q) do
    try do
      g = []
      i = 0
      while_fun_4 = fn while_fun_4, g, i ->
        if i < p do
          row = []
          j = 0
          while_fun_5 = fn while_fun_5, j, row ->
            if j < q do
              row = (row ++ [false])
              j = j + 1
              while_fun_5.(while_fun_5, j, row)
            else
              {j, row}
            end
          end
          {_, row} = try do
              while_fun_5.(while_fun_5, j, row)
            catch
              {:break, {_, row}} -> {0, row}
            end

          g = (g ++ [row])
          i = i + 1
          while_fun_4.(while_fun_4, g, i)
        else
          {g, i}
        end
      end
      {g, _} = try do
          while_fun_4.(while_fun_4, g, i)
        catch
          {:break, {g, _}} -> {g, 0}
        end

      throw {:return, g}
    catch
      {:return, val} -> val
    end
  end
  def visible(grid, p, q, r, c, br, bc) do
    try do
      x1 = (:erlang.float(c)) - 0.5
      y1 = (:erlang.float(r)) - 0.5
      z1 = (:erlang.float(Enum.at(Enum.at(grid, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((r - 1)), []), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((c - 1)), 0))) + 0.5
      x2 = (:erlang.float(bc)) - 0.5
      y2 = (:erlang.float(br)) - 0.5
      z2 = (:erlang.float(Enum.at(Enum.at(grid, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((br - 1)), []), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((bc - 1)), 0))) + 0.5
      dx = x2 - x1
      dy = y2 - y1
      dz = z2 - z1
      dist = sqrt(dx * dx + dy * dy + dz * dz)
      steps = ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((dist * 20.0))) + 1
      stepT = 1.0 / (:erlang.float(steps))
      i = 1
      while_fun_6 = fn while_fun_6, i ->
        if i < steps do
          t = stepT * (:erlang.float(i))
          x = x1 + dx * t
          y = y1 + dy * t
          z = z1 + dz * t
          rIdx = (((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(y))) + 1
          cIdx = (((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(x))) + 1
          if rIdx < 1 || rIdx > p || cIdx < 1 || cIdx > q do
            throw {:return, false}
          end
          h = :erlang.float(Enum.at(Enum.at(grid, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((rIdx - 1)), []), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((cIdx - 1)), 0))
          if z <= h do
            throw {:return, false}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i)
        else
          i
        end
      end
      _ = try do
          while_fun_6.(while_fun_6, i)
        catch
          {:break, {_}} -> 0
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def computeVis(grid, p, q, br, bc) do
    try do
      vis = makeBoolGrid(p, q)
      r = 1
      while_fun_7 = fn while_fun_7, r, vis ->
        if r <= p do
          c = 1
          while_fun_8 = fn while_fun_8, c, vis ->
            if c <= q do
              vis = List.replace_at(vis, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((r - 1)), List.replace_at(Enum.at(vis, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((r - 1))), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((c - 1)), visible(grid, p, q, r, c, br, bc)))
              c = c + 1
              while_fun_8.(while_fun_8, c, vis)
            else
              {c, vis}
            end
          end
          {c, vis} = try do
              while_fun_8.(while_fun_8, c, vis)
            catch
              {:break, {c, vis}} -> {c, vis}
            end

          r = r + 1
          while_fun_7.(while_fun_7, r, vis)
        else
          {r, vis}
        end
      end
      {_, vis} = try do
          while_fun_7.(while_fun_7, r, vis)
        catch
          {:break, {_, vis}} -> {0, vis}
        end

      throw {:return, vis}
    catch
      {:return, val} -> val
    end
  end
  def bfs(grid, p, q, r1, c1, r2, c2) do
    try do
      vis1 = computeVis(grid, p, q, r1, c1)
      vis2 = computeVis(grid, p, q, r2, c2)
      visited = makeBoolGrid(p, q)
      qR = []
      qC = []
      qD = []
      qR = (qR ++ [r1])
      qC = (qC ++ [c1])
      qD = (qD ++ [0])
      visited = List.replace_at(visited, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((r1 - 1)), List.replace_at(Enum.at(visited, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((r1 - 1))), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((c1 - 1)), true))
      head = 0
      while_fun_9 = fn while_fun_9, head, qC, qD, qR, visited ->
        if head < _len(qR) do
          r = Enum.at(qR, head, [])
          c = Enum.at(qC, head, [])
          d = Enum.at(qD, head, [])
          if r == r2 && c == c2 do
            throw {:return, d}
          end
          hr = Enum.at(Enum.at(grid, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((r - 1)), []), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((c - 1)), 0)
          idx = 0
          while_fun_10 = fn while_fun_10, idx, qC, qD, qR, visited ->
            if idx < 4 do
              nr = r
              nc = c
              nr = if idx == 0 do
                nr = nr - 1
                nr
              else
                nr
              end
              nr = if idx == 1 do
                nr = nr + 1
                nr
              else
                nr
              end
              nc = if idx == 2 do
                nc = nc - 1
                nc
              else
                nc
              end
              nc = if idx == 3 do
                nc = nc + 1
                nc
              else
                nc
              end
              {qC, qD, qR, visited} = if nr >= 1 && nr <= p && nc >= 1 && nc <= q do
                {qC, qD, qR, visited} = if !Enum.at(Enum.at(visited, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nr - 1)), []), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nc - 1)), 0) do
                  hn = Enum.at(Enum.at(grid, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nr - 1)), []), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nc - 1)), 0)
                  diff = hn - hr
                  {qC, qD, qR, visited} = if diff <= 1 && diff >= 0 - 3 do
                    {qC, qD, qR, visited} = if Enum.at(Enum.at(vis1, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nr - 1)), []), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nc - 1)), 0) || Enum.at(Enum.at(vis2, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nr - 1)), []), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nc - 1)), 0) do
                      visited = List.replace_at(visited, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nr - 1)), List.replace_at(Enum.at(visited, (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nr - 1))), (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).((nc - 1)), true))
                      qR = (qR ++ [nr])
                      qC = (qC ++ [nc])
                      qD = (qD ++ [d + 1])
                      {qC, qD, qR, visited}
                    else
                      {qC, qD, qR, visited}
                    end
                    {qC, qD, qR, visited}
                  else
                    {qC, qD, qR, visited}
                  end
                  {qC, qD, qR, visited}
                else
                  {qC, qD, qR, visited}
                end
                {qC, qD, qR, visited}
              else
                {qC, qD, qR, visited}
              end
              idx = idx + 1
              while_fun_10.(while_fun_10, idx, qC, qD, qR, visited)
            else
              {idx, qC, qD, qR, visited}
            end
          end
          {_, qC, qD, qR, visited} = try do
              while_fun_10.(while_fun_10, idx, qC, qD, qR, visited)
            catch
              {:break, {_, qC, qD, qR, visited}} -> {0, qC, qD, qR, visited}
            end

          head = head + 1
          while_fun_9.(while_fun_9, head, qC, qD, qR, visited)
        else
          {head, qC, qD, qR, visited}
        end
      end
      {head, qC, qD, qR, visited} = try do
          while_fun_9.(while_fun_9, head, qC, qD, qR, visited)
        catch
          {:break, {head, qC, qD, qR, visited}} -> {head, qC, qD, qR, visited}
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      tLine = _input()
      if tLine == "" do
        throw {:return, nil}
      end
      t = parseInt(tLine)
      case = 0
      while_fun_11 = fn while_fun_11, case ->
        if case < t do
          line = _input()
          while_fun_12 = fn while_fun_12, line ->
            if line == "" do
              line = _input()
              while_fun_12.(while_fun_12, line)
            else
              line
            end
          end
          line = try do
              while_fun_12.(while_fun_12, line)
            catch
              {:break, {line}} -> line
            end

          pq = split(line)
          p = parseInt(Enum.at(pq, 0, []))
          q = parseInt(Enum.at(pq, 1, []))
          grid = []
          r = 0
          while_fun_13 = fn while_fun_13, grid, r ->
            if r < p do
              rowParts = split(_input())
              row = []
              c = 0
              while_fun_14 = fn while_fun_14, c, row ->
                if c < q do
                  row = (row ++ [parseInt(Enum.at(rowParts, c, []))])
                  c = c + 1
                  while_fun_14.(while_fun_14, c, row)
                else
                  {c, row}
                end
              end
              {c, row} = try do
                  while_fun_14.(while_fun_14, c, row)
                catch
                  {:break, {c, row}} -> {c, row}
                end

              grid = (grid ++ [row])
              r = r + 1
              while_fun_13.(while_fun_13, grid, r)
            else
              {grid, r}
            end
          end
          {grid, _} = try do
              while_fun_13.(while_fun_13, grid, r)
            catch
              {:break, {grid, _}} -> {grid, 0}
            end

          coords = split(_input())
          r1 = parseInt(Enum.at(coords, 0, []))
          c1 = parseInt(Enum.at(coords, 1, []))
          r2 = parseInt(Enum.at(coords, 2, []))
          c2 = parseInt(Enum.at(coords, 3, []))
          res = bfs(grid, p, q, r1, c1, r2, c2)
          if res < 0 do
            IO.puts("Mission impossible!")
          else
            IO.puts((("The shortest path is " <> Kernel.to_string(res)) <> " steps long."))
          end
          case = case + 1
          while_fun_11.(while_fun_11, case)
        else
          case
        end
      end
      case = try do
          while_fun_11.(while_fun_11, case)
        catch
          {:break, {case}} -> case
        end

    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    Process.put(:digits, %{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9})
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
