# Code generated by Mochi transpiler 2025-08-27 07:05 +0700
defmodule Main do
  defp _input() do
    case IO.gets("") do
      nil -> ""
      :eof -> ""
      line -> String.trim(line)
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def parseIntStr(str) do
    try do
      digits = %{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
      i = 0
      n = 0
      while_fun = fn while_fun, i, n ->
        if i < _len(str) do
          n = n * 10 + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(digits[_slice(str, i, (i + 1) - i)]))
          i = i + 1
          while_fun.(while_fun, i, n)
        else
          {i, n}
        end
      end
      {_, _} = try do
          while_fun.(while_fun, i, n)
        catch
          {:break, {_, _}} -> {0, 0}
        end

      throw {:return, n}
    catch
      {:return, val} -> val
    end
  end
  def precedence(op) do
    try do
      if op == "+" || op == "-" do
        throw {:return, 1}
      end
      if op == "*" || op == "/" do
        throw {:return, 2}
      end
      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def parse(s) do
    try do
      ops = []
      vals = []
      i = 0
      while_fun_2 = fn while_fun_2, i, ops, vals ->
        if i < _len(s) do
          ch = _slice(s, i, (i + 1) - i)
          {ops, vals} = if ch >= "a" && ch <= "z" do
            vals = (vals ++ [%{kind: "var", val: ch}])
            {ops, vals}
          else
            {ops, vals} = if ch == "(" do
              ops = (ops ++ [ch])
              {ops, vals}
            else
              {ops, vals} = if ch == ")" do
                while_fun_3 = fn while_fun_3, ops, vals ->
                  if _len(ops) > 0 && Enum.at(ops, _len(ops) - 1, []) != "(" do
                    op = Enum.at(ops, _len(ops) - 1, [])
                    ops = _slice(ops, 0, (_len(ops) - 1) - 0)
                    right = Enum.at(vals, _len(vals) - 1, [])
                    vals = _slice(vals, 0, (_len(vals) - 1) - 0)
                    left = Enum.at(vals, _len(vals) - 1, [])
                    vals = _slice(vals, 0, (_len(vals) - 1) - 0)
                    vals = (vals ++ [%{kind: "op", op: op, left: left, right: right}])
                    while_fun_3.(while_fun_3, ops, vals)
                  else
                    {ops, vals}
                  end
                end
                {ops, vals} = try do
                    while_fun_3.(while_fun_3, ops, vals)
                  catch
                    {:break, {ops, vals}} -> {ops, vals}
                  end

                ops = _slice(ops, 0, (_len(ops) - 1) - 0)
                {ops, vals}
              else
                while_fun_4 = fn while_fun_4, ops, vals ->
                  if _len(ops) > 0 && Enum.at(ops, _len(ops) - 1, []) != "(" && precedence(Enum.at(ops, _len(ops) - 1, [])) >= precedence(ch) do
                    op = Enum.at(ops, _len(ops) - 1, [])
                    ops = _slice(ops, 0, (_len(ops) - 1) - 0)
                    right = Enum.at(vals, _len(vals) - 1, [])
                    vals = _slice(vals, 0, (_len(vals) - 1) - 0)
                    left = Enum.at(vals, _len(vals) - 1, [])
                    vals = _slice(vals, 0, (_len(vals) - 1) - 0)
                    vals = (vals ++ [%{kind: "op", op: op, left: left, right: right}])
                    while_fun_4.(while_fun_4, ops, vals)
                  else
                    {ops, vals}
                  end
                end
                {ops, vals} = try do
                    while_fun_4.(while_fun_4, ops, vals)
                  catch
                    {:break, {ops, vals}} -> {ops, vals}
                  end

                ops = (ops ++ [ch])
                {ops, vals}
              end
              {ops, vals}
            end
            {ops, vals}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, ops, vals)
        else
          {i, ops, vals}
        end
      end
      {_, ops, vals} = try do
          while_fun_2.(while_fun_2, i, ops, vals)
        catch
          {:break, {_, ops, vals}} -> {0, ops, vals}
        end

      while_fun_5 = fn while_fun_5, ops, vals ->
        if _len(ops) > 0 do
          op = Enum.at(ops, _len(ops) - 1, [])
          ops = _slice(ops, 0, (_len(ops) - 1) - 0)
          right = Enum.at(vals, _len(vals) - 1, [])
          vals = _slice(vals, 0, (_len(vals) - 1) - 0)
          left = Enum.at(vals, _len(vals) - 1, [])
          vals = _slice(vals, 0, (_len(vals) - 1) - 0)
          vals = (vals ++ [%{kind: "op", op: op, left: left, right: right}])
          while_fun_5.(while_fun_5, ops, vals)
        else
          {ops, vals}
        end
      end
      {ops, vals} = try do
          while_fun_5.(while_fun_5, ops, vals)
        catch
          {:break, {ops, vals}} -> {ops, vals}
        end

      throw {:return, Enum.at(vals, _len(vals) - 1, [])}
    catch
      {:return, val} -> val
    end
  end
  def needParen(parent, isRight, child) do
    try do
      if child.kind != "op" do
        throw {:return, false}
      end
      p = precedence(parent)
      c = precedence(child.op)
      if c < p do
        throw {:return, true}
      end
      if c > p do
        throw {:return, false}
      end
      if parent == "-" && isRight && (child.op == "+" || child.op == "-") do
        throw {:return, true}
      end
      if parent == "/" && isRight && (child.op == "*" || child.op == "/") do
        throw {:return, true}
      end
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def formatRec(node_, parent, isRight) do
    try do
      if node_.kind != "op" do
        throw {:return, node_.val}
      end
      left = formatRec(node_.left, node_.op, false)
      right = formatRec(node_.right, node_.op, true)
      res = ((left <> node_.op) <> right)
      res = if parent != "" && needParen(parent, isRight, node_) do
        res = (("(" <> res) <> ")")
        res
      else
        res
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def makeNice(s) do
    try do
      root = parse(s)
      throw {:return, formatRec(root, "", false)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      tStr = _input()
      if tStr == "" do
        throw {:return, nil}
      end
      t = parseIntStr(tStr)
      Enum.each((0..(t - 1)), fn _ ->
        line = _input()
        IO.puts(Kernel.inspect(makeNice(line)))
      end)
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
