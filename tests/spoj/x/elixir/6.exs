# Code generated by Mochi transpiler 2025-08-27 07:05 +0700
defmodule Main do
  defp _input() do
    case IO.gets("") do
      nil -> ""
      :eof -> ""
      line -> String.trim(line)
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def repeat(s, n) do
    try do
      r = ""
      {r} = Enum.reduce((0..(n - 1)//1), {r}, fn _, {r} ->
        r = (r <> s)
        {r}
      end)
      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def add_str(a, b) do
    try do
      i = _len(a) - 1
      j = _len(b) - 1
      carry = 0
      res = ""
      while_fun = fn while_fun, carry, i, j, res ->
        if i >= 0 || j >= 0 || carry > 0 do
          da = 0
          da = if i >= 0 do
            da = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Process.get(:digitMap)[_slice(a, i, (i + 1) - i)])
            da
          else
            da
          end
          db = 0
          db = if j >= 0 do
            db = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Process.get(:digitMap)[_slice(b, j, (j + 1) - j)])
            db
          else
            db
          end
          sum = da + db + carry
          res = (Kernel.inspect(rem(sum, 10)) <> res)
          carry = div(sum, 10)
          i = i - 1
          j = j - 1
          while_fun.(while_fun, carry, i, j, res)
        else
          {carry, i, j, res}
        end
      end
      {carry, _, _, res} = try do
          while_fun.(while_fun, carry, i, j, res)
        catch
          {:break, {carry, _, _, res}} -> {carry, 0, 0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def sub_str(a, b) do
    try do
      i = _len(a) - 1
      j = _len(b) - 1
      borrow = 0
      res = ""
      while_fun_2 = fn while_fun_2, borrow, i, j, res ->
        if i >= 0 do
          da = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Process.get(:digitMap)[_slice(a, i, (i + 1) - i)]) - borrow
          db = 0
          db = if j >= 0 do
            db = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Process.get(:digitMap)[_slice(b, j, (j + 1) - j)])
            db
          else
            db
          end
          {borrow, da} = if da < db do
            da = da + 10
            borrow = 1
            {borrow, da}
          else
            borrow = 0
            {borrow, da}
          end
          diff = da - db
          res = (Kernel.to_string(diff) <> res)
          i = i - 1
          j = j - 1
          while_fun_2.(while_fun_2, borrow, i, j, res)
        else
          {borrow, i, j, res}
        end
      end
      {borrow, _, _, res} = try do
          while_fun_2.(while_fun_2, borrow, i, j, res)
        catch
          {:break, {borrow, _, _, res}} -> {borrow, 0, 0, res}
        end

      k = 0
      while_fun_3 = fn while_fun_3, k ->
        if k < _len(res) && _slice(res, k, (k + 1) - k) == "0" do
          k = k + 1
          while_fun_3.(while_fun_3, k)
        else
          k
        end
      end
      _ = try do
          while_fun_3.(while_fun_3, k)
        catch
          {:break, {_}} -> 0
        end

      if k == _len(res) do
        throw {:return, "0"}
      end
      throw {:return, _slice(res, k, _len(res) - k)}
    catch
      {:return, val} -> val
    end
  end
  def mul_digit(a, d) do
    try do
      if d == 0 do
        throw {:return, "0"}
      end
      i = _len(a) - 1
      carry = 0
      res = ""
      while_fun_4 = fn while_fun_4, carry, i, res ->
        if i >= 0 do
          prod = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Process.get(:digitMap)[_slice(a, i, (i + 1) - i)]) * d + carry
          res = (Kernel.to_string(rem(prod, 10)) <> res)
          carry = div(prod, 10)
          i = i - 1
          while_fun_4.(while_fun_4, carry, i, res)
        else
          {carry, i, res}
        end
      end
      {carry, _, res} = try do
          while_fun_4.(while_fun_4, carry, i, res)
        catch
          {:break, {carry, _, res}} -> {carry, 0, res}
        end

      res = if carry > 0 do
        res = (Kernel.to_string(carry) <> res)
        res
      else
        res
      end
      k = 0
      while_fun_5 = fn while_fun_5, k ->
        if k < _len(res) && _slice(res, k, (k + 1) - k) == "0" do
          k = k + 1
          while_fun_5.(while_fun_5, k)
        else
          k
        end
      end
      _ = try do
          while_fun_5.(while_fun_5, k)
        catch
          {:break, {_}} -> 0
        end

      if k == _len(res) do
        throw {:return, "0"}
      end
      throw {:return, _slice(res, k, _len(res) - k)}
    catch
      {:return, val} -> val
    end
  end
  def mul_str(a, b) do
    try do
      result = "0"
      shift = 0
      parts = []
      i = _len(b) - 1
      while_fun_6 = fn while_fun_6, i, parts, result, shift ->
        if i >= 0 do
          d = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Process.get(:digitMap)[_slice(b, i, (i + 1) - i)])
          part = mul_digit(a, d)
          parts = (parts ++ [%{"val" => part, "shift" => shift}])
          shifted = part
          {shifted} = Enum.reduce((0..(shift - 1)//1), {shifted}, fn _, {shifted} ->
            shifted = (shifted <> "0")
            {shifted}
          end)
          result = add_str(result, shifted)
          shift = shift + 1
          i = i - 1
          while_fun_6.(while_fun_6, i, parts, result, shift)
        else
          {i, parts, result, shift}
        end
      end
      {_, parts, result, shift} = try do
          while_fun_6.(while_fun_6, i, parts, result, shift)
        catch
          {:break, {_, parts, result, shift}} -> {0, parts, result, shift}
        end

      throw {:return, %{"res" => result, "parts" => parts}}
    catch
      {:return, val} -> val
    end
  end
  def pad_left(s, total) do
    try do
      r = ""
      {r} = Enum.reduce((0..((total - _len(s)) - 1)//1), {r}, fn _, {r} ->
        r = (r <> " ")
        {r}
      end)
      throw {:return, (r <> s)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      tStr = _input()
      if tStr == "" do
        throw {:return, nil}
      end
      t = String.to_integer(tStr)
      try do
        for _ <- (0..(t - 1)) do
          try do
            line = _input()
            if line == "" do
              throw :continue
            end
            idx = 0
            while_fun_7 = fn while_fun_7, idx ->
              if idx < _len(line) do
                ch = _slice(line, idx, (idx + 1) - idx)
                if ch == "+" || ch == "-" || ch == "*" do
                  throw {:break, {idx}}
                end
                idx = idx + 1
                while_fun_7.(while_fun_7, idx)
              else
                idx
              end
            end
            _ = try do
                while_fun_7.(while_fun_7, idx)
              catch
                {:break, {_}} -> 0
              end

            a = _slice(line, 0, idx - 0)
            op = _slice(line, idx, (idx + 1) - idx)
            b = _slice(line, idx + 1, _len(line) - idx + 1)
            res = ""
            parts = []
            {parts, res} = if op == "+" do
              res = add_str(a, b)
              {parts, res}
            else
              {parts, res} = if op == "-" do
                res = sub_str(a, b)
                {parts, res}
              else
                r = mul_str(a, b)
                res = r["res"]
                parts = r["parts"]
                {parts, res}
              end
              {parts, res}
            end
            width = _len(a)
            secondLen = _len(b) + 1
            width = if secondLen > width do
              width = secondLen
              width
            else
              width
            end
            width = if _len(res) > width do
              width = _len(res)
              width
            else
              width
            end
            {width} = Enum.reduce(parts, {width}, fn p, {width} ->
              l = _len(p["val"]) + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(p["shift"]))
              width = if l > width do
                width = l
                width
              else
                width
              end
              {width}
            end)
            IO.puts(Kernel.inspect(pad_left(a, width)))
            IO.puts(Kernel.inspect(pad_left((op <> b), width)))
            dash1 = 0
            dash1 = if op == "*" do
              dash1 = if _len(parts) > 0 do
                dash1 = _len(b) + 1
                firstPart = Enum.at(parts, 0, [])["val"]
                dash1 = if _len(firstPart) > dash1 do
                  dash1 = _len(firstPart)
                  dash1
                else
                  dash1
                end
                dash1
              else
                dash1 = _len(b) + 1
                dash1 = if _len(res) > dash1 do
                  dash1 = _len(res)
                  dash1
                else
                  dash1
                end
                dash1
              end
              dash1
            else
              dash1 = _len(b) + 1
              dash1 = if _len(res) > dash1 do
                dash1 = _len(res)
                dash1
              else
                dash1
              end
              dash1
            end
            IO.puts(Kernel.inspect(pad_left(repeat("-", dash1), width)))
            if op == "*" && _len(b) > 1 do
              Enum.each(parts, fn p ->
                val = p["val"]
                shift = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(p["shift"])
                spaces = width - shift - _len(val)
                line = ""
                {line} = Enum.reduce((0..(spaces - 1)//1), {line}, fn _, {line} ->
                  line = (line <> " ")
                  {line}
                end)
                line = (line <> val)
                line = IO.puts(line)
              end)
              IO.puts(Kernel.inspect(pad_left(repeat("-", _len(res)), width)))
            end
            IO.puts(Kernel.inspect(pad_left(res, width)))
            IO.puts("")
          catch
            :continue -> nil
            {:continue, _} -> nil
          end
        end
      catch
        :break -> nil
        {:break, _} -> nil
      end
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    Process.put(:digitMap, %{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9})
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
