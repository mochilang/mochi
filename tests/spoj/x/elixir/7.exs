# Code generated by Mochi transpiler 2025-08-27 07:05 +0700
defmodule Main do
  defp _input() do
    case IO.gets("") do
      nil -> ""
      :eof -> ""
      line -> String.trim(line)
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def split(s, sep) do
    try do
      parts = []
      cur = ""
      i = 0
      while_fun = fn while_fun, cur, i, parts ->
        if i < _len(s) do
          {cur, i, parts} = if _len(sep) > 0 && i + _len(sep) <= _len(s) && _slice(s, i, i + _len(sep) - (i)) == sep do
            parts = (parts ++ [cur])
            cur = ""
            i = i + _len(sep)
            {cur, i, parts}
          else
            cur = (cur <> _slice(s, i, (i + 1) - i))
            i = i + 1
            {cur, i, parts}
          end
          while_fun.(while_fun, cur, i, parts)
        else
          {cur, i, parts}
        end
      end
      {cur, _, parts} = try do
          while_fun.(while_fun, cur, i, parts)
        catch
          {:break, {cur, _, parts}} -> {cur, 0, parts}
        end

      parts = (parts ++ [cur])
      throw {:return, parts}
    catch
      {:return, val} -> val
    end
  end
  def parse_ints(line) do
    try do
      pieces = split(line, " ")
      nums = []
      i = 0
      while_fun_2 = fn while_fun_2, i, nums ->
        if i < _len(pieces) do
          p = Enum.at(pieces, i, [])
          nums = if _len(p) > 0 do
            nums = (nums ++ [(fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(p)])
            nums
          else
            nums
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, nums)
        else
          {i, nums}
        end
      end
      {_, nums} = try do
          while_fun_2.(while_fun_2, i, nums)
        catch
          {:break, {_, nums}} -> {0, nums}
        end

      throw {:return, nums}
    catch
      {:return, val} -> val
    end
  end
  def sort_unique(arr) do
    try do
      i = 1
      while_fun_3 = fn while_fun_3, arr, i ->
        if i < _len(arr) do
          j = i
          while_fun_4 = fn while_fun_4, arr, j ->
            if j > 0 && Enum.at(arr, j - 1, []) > Enum.at(arr, j, []) do
              tmp = Enum.at(arr, j - 1, [])
              arr = List.replace_at(arr, j - 1, Enum.at(arr, j, []))
              arr = List.replace_at(arr, j, tmp)
              j = j - 1
              while_fun_4.(while_fun_4, arr, j)
            else
              {arr, j}
            end
          end
          {arr, _} = try do
              while_fun_4.(while_fun_4, arr, j)
            catch
              {:break, {arr, _}} -> {arr, 0}
            end

          i = i + 1
          while_fun_3.(while_fun_3, arr, i)
        else
          {arr, i}
        end
      end
      {arr, _} = try do
          while_fun_3.(while_fun_3, arr, i)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      res = []
      i = 0
      while_fun_5 = fn while_fun_5, i, res ->
        if i < _len(arr) do
          res = if i == 0 || Enum.at(arr, i, []) != Enum.at(arr, i - 1, []) do
            res = (res ++ [Enum.at(arr, i, [])])
            res
          else
            res
          end
          i = i + 1
          while_fun_5.(while_fun_5, i, res)
        else
          {i, res}
        end
      end
      {_, res} = try do
          while_fun_5.(while_fun_5, i, res)
        catch
          {:break, {_, res}} -> {0, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def pointInPoly(xs, ys, px, py) do
    try do
      inside = false
      i = 0
      j = _len(xs) - 1
      while_fun_6 = fn while_fun_6, i, inside, j ->
        if i < _len(xs) do
          xi = :erlang.float(Enum.at(xs, i, []))
          yi = :erlang.float(Enum.at(ys, i, []))
          xj = :erlang.float(Enum.at(xs, j, []))
          yj = :erlang.float(Enum.at(ys, j, []))
          inside = if ((yi > py) && (yj <= py)) || ((yj > py) && (yi <= py)) do
            xint = (xj - xi) * (py - yi) / (yj - yi) + xi
            inside = if px < xint do
              inside = !inside
              inside
            else
              inside
            end
            inside
          else
            inside
          end
          j = i
          i = i + 1
          while_fun_6.(while_fun_6, i, inside, j)
        else
          {i, inside, j}
        end
      end
      {_, inside, _} = try do
          while_fun_6.(while_fun_6, i, inside, j)
        catch
          {:break, {_, inside, _}} -> {0, inside, 0}
        end

      throw {:return, inside}
    catch
      {:return, val} -> val
    end
  end
  def make3DBool(a, b, c) do
    try do
      arr = []
      i = 0
      while_fun_7 = fn while_fun_7, arr, i ->
        if i < a do
          plane = []
          j = 0
          while_fun_8 = fn while_fun_8, j, plane ->
            if j < b do
              row = []
              k = 0
              while_fun_9 = fn while_fun_9, k, row ->
                if k < c do
                  row = (row ++ [false])
                  k = k + 1
                  while_fun_9.(while_fun_9, k, row)
                else
                  {k, row}
                end
              end
              {_, row} = try do
                  while_fun_9.(while_fun_9, k, row)
                catch
                  {:break, {_, row}} -> {0, row}
                end

              plane = (plane ++ [row])
              j = j + 1
              while_fun_8.(while_fun_8, j, plane)
            else
              {j, plane}
            end
          end
          {_, plane} = try do
              while_fun_8.(while_fun_8, j, plane)
            catch
              {:break, {_, plane}} -> {0, plane}
            end

          arr = (arr ++ [plane])
          i = i + 1
          while_fun_7.(while_fun_7, arr, i)
        else
          {arr, i}
        end
      end
      {arr, _} = try do
          while_fun_7.(while_fun_7, arr, i)
        catch
          {:break, {arr, _}} -> {arr, 0}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      tLine = _input()
      if tLine == "" do
        throw {:return, nil}
      end
      t = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(tLine)
      case = 0
      while_fun_10 = fn while_fun_10, case ->
        if case < t do
          fLine = _input()
          f = (fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(fLine)
          xs = []
          ys = []
          zs = []
          xs = (xs ++ [0])
          xs = (xs ++ [1001])
          ys = (ys ++ [0])
          ys = (ys ++ [1001])
          zs = (zs ++ [0])
          zs = (zs ++ [1001])
          faceXCoord = []
          faceYPoly = []
          faceZPoly = []
          i = 0
          while_fun_11 = fn while_fun_11, faceXCoord, faceYPoly, faceZPoly, i, xs, ys, zs ->
            if i < f do
              line = _input()
              nums = parse_ints(line)
              p = Enum.at(nums, 0, [])
              ptsX = []
              ptsY = []
              ptsZ = []
              j = 0
              while_fun_12 = fn while_fun_12, j, ptsX, ptsY, ptsZ, xs, ys, zs ->
                if j < p do
                  x = Enum.at(nums, 1 + 3 * j, [])
                  y = Enum.at(nums, 1 + 3 * j + 1, [])
                  z = Enum.at(nums, 1 + 3 * j + 2, [])
                  ptsX = (ptsX ++ [x])
                  ptsY = (ptsY ++ [y])
                  ptsZ = (ptsZ ++ [z])
                  xs = (xs ++ [x])
                  ys = (ys ++ [y])
                  zs = (zs ++ [z])
                  j = j + 1
                  while_fun_12.(while_fun_12, j, ptsX, ptsY, ptsZ, xs, ys, zs)
                else
                  {j, ptsX, ptsY, ptsZ, xs, ys, zs}
                end
              end
              {_, ptsX, ptsY, ptsZ, xs, ys, zs} = try do
                  while_fun_12.(while_fun_12, j, ptsX, ptsY, ptsZ, xs, ys, zs)
                catch
                  {:break, {_, ptsX, ptsY, ptsZ, xs, ys, zs}} -> {0, ptsX, ptsY, ptsZ, xs, ys, zs}
                end

              allSame = true
              j = 1
              while_fun_13 = fn while_fun_13, allSame, j ->
                if j < p do
                  allSame = if Enum.at(ptsX, j, []) != Enum.at(ptsX, 0, []) do
                    allSame = false
                    allSame
                  else
                    allSame
                  end
                  j = j + 1
                  while_fun_13.(while_fun_13, allSame, j)
                else
                  {allSame, j}
                end
              end
              {allSame, _} = try do
                  while_fun_13.(while_fun_13, allSame, j)
                catch
                  {:break, {allSame, _}} -> {allSame, 0}
                end

              {faceXCoord, faceYPoly, faceZPoly} = if allSame do
                faceXCoord = (faceXCoord ++ [Enum.at(ptsX, 0, [])])
                faceYPoly = (faceYPoly ++ [ptsY])
                faceZPoly = (faceZPoly ++ [ptsZ])
                {faceXCoord, faceYPoly, faceZPoly}
              else
                {faceXCoord, faceYPoly, faceZPoly}
              end
              i = i + 1
              while_fun_11.(while_fun_11, faceXCoord, faceYPoly, faceZPoly, i, xs, ys, zs)
            else
              {faceXCoord, faceYPoly, faceZPoly, i, xs, ys, zs}
            end
          end
          {faceXCoord, faceYPoly, faceZPoly, _, xs, ys, zs} = try do
              while_fun_11.(while_fun_11, faceXCoord, faceYPoly, faceZPoly, i, xs, ys, zs)
            catch
              {:break, {faceXCoord, faceYPoly, faceZPoly, _, xs, ys, zs}} -> {faceXCoord, faceYPoly, faceZPoly, 0, xs, ys, zs}
            end

          xs = sort_unique(xs)
          ys = sort_unique(ys)
          zs = sort_unique(zs)
          nx = _len(xs) - 1
          ny = _len(ys) - 1
          nz = _len(zs) - 1
          xIndex = %{}
          i = 0
          while_fun_14 = fn while_fun_14, i, xIndex ->
            if i < _len(xs) do
              xIndex = Map.put(xIndex, Enum.at(xs, i, []), i)
              i = i + 1
              while_fun_14.(while_fun_14, i, xIndex)
            else
              {i, xIndex}
            end
          end
          {_, xIndex} = try do
              while_fun_14.(while_fun_14, i, xIndex)
            catch
              {:break, {_, xIndex}} -> {0, xIndex}
            end

          dx = []
          i = 0
          while_fun_15 = fn while_fun_15, dx, i ->
            if i < nx do
              dx = (dx ++ [Enum.at(xs, i + 1, []) - Enum.at(xs, i, [])])
              i = i + 1
              while_fun_15.(while_fun_15, dx, i)
            else
              {dx, i}
            end
          end
          {dx, _} = try do
              while_fun_15.(while_fun_15, dx, i)
            catch
              {:break, {dx, _}} -> {dx, 0}
            end

          dy = []
          i = 0
          while_fun_16 = fn while_fun_16, dy, i ->
            if i < ny do
              dy = (dy ++ [Enum.at(ys, i + 1, []) - Enum.at(ys, i, [])])
              i = i + 1
              while_fun_16.(while_fun_16, dy, i)
            else
              {dy, i}
            end
          end
          {dy, _} = try do
              while_fun_16.(while_fun_16, dy, i)
            catch
              {:break, {dy, _}} -> {dy, 0}
            end

          dz = []
          i = 0
          while_fun_17 = fn while_fun_17, dz, i ->
            if i < nz do
              dz = (dz ++ [Enum.at(zs, i + 1, []) - Enum.at(zs, i, [])])
              i = i + 1
              while_fun_17.(while_fun_17, dz, i)
            else
              {dz, i}
            end
          end
          {dz, _} = try do
              while_fun_17.(while_fun_17, dz, i)
            catch
              {:break, {dz, _}} -> {dz, 0}
            end

          blockX = make3DBool(_len(xs), ny, nz)
          i = 0
          while_fun_18 = fn while_fun_18, blockX, i ->
            if i < _len(faceXCoord) do
              coord = Enum.at(faceXCoord, i, [])
              polyY = Enum.at(faceYPoly, i, [])
              polyZ = Enum.at(faceZPoly, i, [])
              xi = xIndex[coord]
              j = 0
              while_fun_19 = fn while_fun_19, blockX, j ->
                if j < ny do
                  cy = (:erlang.float((Enum.at(ys, j, []) + Enum.at(ys, j + 1, [])))) / 2.0
                  k = 0
                  while_fun_20 = fn while_fun_20, blockX, k ->
                    if k < nz do
                      cz = (:erlang.float((Enum.at(zs, k, []) + Enum.at(zs, k + 1, [])))) / 2.0
                      blockX = if pointInPoly(polyY, polyZ, cy, cz) do
                        blockX = List.replace_at(blockX, xi, List.replace_at(Enum.at(blockX, xi), j, List.replace_at(Enum.at(Enum.at(blockX, xi), j), k, true)))
                        blockX
                      else
                        blockX
                      end
                      k = k + 1
                      while_fun_20.(while_fun_20, blockX, k)
                    else
                      {blockX, k}
                    end
                  end
                  {blockX, _} = try do
                      while_fun_20.(while_fun_20, blockX, k)
                    catch
                      {:break, {blockX, _}} -> {blockX, 0}
                    end

                  j = j + 1
                  while_fun_19.(while_fun_19, blockX, j)
                else
                  {blockX, j}
                end
              end
              {blockX, _} = try do
                  while_fun_19.(while_fun_19, blockX, j)
                catch
                  {:break, {blockX, _}} -> {blockX, 0}
                end

              i = i + 1
              while_fun_18.(while_fun_18, blockX, i)
            else
              {blockX, i}
            end
          end
          {blockX, _} = try do
              while_fun_18.(while_fun_18, blockX, i)
            catch
              {:break, {blockX, _}} -> {blockX, 0}
            end

          solid = make3DBool(nx, ny, nz)
          j2 = 0
          while_fun_21 = fn while_fun_21, j2, solid ->
            if j2 < ny do
              k2 = 0
              while_fun_22 = fn while_fun_22, k2, solid ->
                if k2 < nz do
                  inside = false
                  i2 = 0
                  while_fun_23 = fn while_fun_23, i2, inside, solid ->
                    if i2 < nx do
                      inside = if Enum.at(Enum.at(Enum.at(blockX, i2, []), j2, 0), k2, 0) do
                        inside = !inside
                        inside
                      else
                        inside
                      end
                      solid = if inside do
                        solid = List.replace_at(solid, i2, List.replace_at(Enum.at(solid, i2), j2, List.replace_at(Enum.at(Enum.at(solid, i2), j2), k2, true)))
                        solid
                      else
                        solid
                      end
                      i2 = i2 + 1
                      while_fun_23.(while_fun_23, i2, inside, solid)
                    else
                      {i2, inside, solid}
                    end
                  end
                  {i2, inside, solid} = try do
                      while_fun_23.(while_fun_23, i2, inside, solid)
                    catch
                      {:break, {i2, inside, solid}} -> {i2, inside, solid}
                    end

                  k2 = k2 + 1
                  while_fun_22.(while_fun_22, k2, solid)
                else
                  {k2, solid}
                end
              end
              {k2, solid} = try do
                  while_fun_22.(while_fun_22, k2, solid)
                catch
                  {:break, {k2, solid}} -> {k2, solid}
                end

              j2 = j2 + 1
              while_fun_21.(while_fun_21, j2, solid)
            else
              {j2, solid}
            end
          end
          {j2, solid} = try do
              while_fun_21.(while_fun_21, j2, solid)
            catch
              {:break, {j2, solid}} -> {j2, solid}
            end

          volume = 0
          i3 = 0
          while_fun_24 = fn while_fun_24, i3, volume ->
            if i3 < nx do
              j3 = 0
              while_fun_25 = fn while_fun_25, j3, volume ->
                if j3 < ny do
                  k3 = 0
                  while_fun_26 = fn while_fun_26, k3, volume ->
                    if k3 < nz do
                      volume = if Enum.at(Enum.at(Enum.at(solid, i3, []), j3, 0), k3, 0) do
                        volume = volume + Enum.at(dx, i3, []) * Enum.at(dy, j3, []) * Enum.at(dz, k3, [])
                        volume
                      else
                        volume
                      end
                      k3 = k3 + 1
                      while_fun_26.(while_fun_26, k3, volume)
                    else
                      {k3, volume}
                    end
                  end
                  {k3, volume} = try do
                      while_fun_26.(while_fun_26, k3, volume)
                    catch
                      {:break, {k3, volume}} -> {k3, volume}
                    end

                  j3 = j3 + 1
                  while_fun_25.(while_fun_25, j3, volume)
                else
                  {j3, volume}
                end
              end
              {j3, volume} = try do
                  while_fun_25.(while_fun_25, j3, volume)
                catch
                  {:break, {j3, volume}} -> {j3, volume}
                end

              i3 = i3 + 1
              while_fun_24.(while_fun_24, i3, volume)
            else
              {i3, volume}
            end
          end
          {i3, volume} = try do
              while_fun_24.(while_fun_24, i3, volume)
            catch
              {:break, {i3, volume}} -> {i3, volume}
            end

          IO.puts((("The bulk is composed of " <> Kernel.to_string(volume)) <> " units."))
          case = case + 1
          while_fun_10.(while_fun_10, case)
        else
          case
        end
      end
      case = try do
          while_fun_10.(while_fun_10, case)
        catch
          {:break, {case}} -> case
        end

    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
