# Code generated by Mochi transpiler 2025-08-27 07:05 +0700
defmodule Main do
  defp _input() do
    case IO.gets("") do
      nil -> ""
      :eof -> ""
      line -> String.trim(line)
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    len = if len < 0, do: 0, else: len
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> Kernel.length(x)
    end
  end
  def split(s, sep) do
    try do
      parts = []
      cur = ""
      i = 0
      while_fun = fn while_fun, cur, i, parts ->
        if i < _len(s) do
          {cur, i, parts} = if _len(sep) > 0 && i + _len(sep) <= _len(s) && _slice(s, i, i + _len(sep) - (i)) == sep do
            parts = (parts ++ [cur])
            cur = ""
            i = i + _len(sep)
            {cur, i, parts}
          else
            cur = (cur <> _slice(s, i, (i + 1) - i))
            i = i + 1
            {cur, i, parts}
          end
          while_fun.(while_fun, cur, i, parts)
        else
          {cur, i, parts}
        end
      end
      {cur, _, parts} = try do
          while_fun.(while_fun, cur, i, parts)
        catch
          {:break, {cur, _, parts}} -> {cur, 0, parts}
        end

      parts = (parts ++ [cur])
      throw {:return, parts}
    catch
      {:return, val} -> val
    end
  end
  def parse_ints(line) do
    try do
      pieces = split(line, " ")
      nums = []
      {nums} = Enum.reduce(pieces, {nums}, fn p, {nums} ->
        nums = if _len(p) > 0 do
          nums = (nums ++ [String.to_integer(p)])
          nums
        else
          nums
        end
        {nums}
      end)
      throw {:return, nums}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      tLine = _input()
      if tLine == "" do
        throw {:return, nil}
      end
      t = String.to_integer(tLine)
      caseIdx = 0
      while_fun_2 = fn while_fun_2, caseIdx ->
        if caseIdx < t do
          header = parse_ints(_input())
          s = Enum.at(header, 0, [])
          c = Enum.at(header, 1, [])
          seq = parse_ints(_input())
          levels = []
          levels = (levels ++ [seq])
          current = seq
          while_fun_3 = fn while_fun_3, current, levels ->
            if _len(current) > 1 do
              next = []
              i = 0
              while_fun_4 = fn while_fun_4, i, next ->
                if i + 1 < _len(current) do
                  next = (next ++ [Enum.at(current, i + 1, []) - Enum.at(current, i, [])])
                  i = i + 1
                  while_fun_4.(while_fun_4, i, next)
                else
                  {i, next}
                end
              end
              {_, next} = try do
                  while_fun_4.(while_fun_4, i, next)
                catch
                  {:break, {_, next}} -> {0, next}
                end

              levels = (levels ++ [next])
              current = next
              while_fun_3.(while_fun_3, current, levels)
            else
              {current, levels}
            end
          end
          {current, levels} = try do
              while_fun_3.(while_fun_3, current, levels)
            catch
              {:break, {current, levels}} -> {current, levels}
            end

          depth = _len(levels) - 1
          step = 0
          res = []
          while_fun_5 = fn while_fun_5, levels, res, step ->
            if step < c do
              bottom = Enum.at(levels, depth, [])
              bottom = (bottom ++ [Enum.at(bottom, _len(bottom) - 1, [])])
              levels = List.replace_at(levels, depth, bottom)
              level = depth - 1
              while_fun_6 = fn while_fun_6, level, levels ->
                if level >= 0 do
                  arr = Enum.at(levels, level, [])
                  arrBelow = Enum.at(levels, level + 1, [])
                  nextVal = Enum.at(arr, _len(arr) - 1, []) + Enum.at(arrBelow, _len(arrBelow) - 1, [])
                  arr = (arr ++ [nextVal])
                  levels = List.replace_at(levels, level, arr)
                  level = level - 1
                  while_fun_6.(while_fun_6, level, levels)
                else
                  {level, levels}
                end
              end
              {level, levels} = try do
                  while_fun_6.(while_fun_6, level, levels)
                catch
                  {:break, {level, levels}} -> {level, levels}
                end

              res = (res ++ [Enum.at(Enum.at(levels, 0, []), _len(Enum.at(levels, 0, [])) - 1, 0)])
              step = step + 1
              while_fun_5.(while_fun_5, levels, res, step)
            else
              {levels, res, step}
            end
          end
          {levels, res, step} = try do
              while_fun_5.(while_fun_5, levels, res, step)
            catch
              {:break, {levels, res, step}} -> {levels, res, step}
            end

          out = ""
          i2 = 0
          while_fun_7 = fn while_fun_7, i2, out ->
            if i2 < _len(res) do
              out = if i2 > 0 do
                out = (out <> " ")
                out
              else
                out
              end
              out = (out <> Kernel.to_string(Enum.at(res, i2, [])))
              i2 = i2 + 1
              while_fun_7.(while_fun_7, i2, out)
            else
              {i2, out}
            end
          end
          {i2, out} = try do
              while_fun_7.(while_fun_7, i2, out)
            catch
              {:break, {i2, out}} -> {i2, out}
            end

          out = IO.puts(out)
          caseIdx = caseIdx + 1
          while_fun_2.(while_fun_2, caseIdx)
        else
          caseIdx
        end
      end
      caseIdx = try do
          while_fun_2.(while_fun_2, caseIdx)
        catch
          {:break, {caseIdx}} -> caseIdx
        end

    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
