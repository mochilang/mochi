# Generated by Mochi transpiler v0.10.74 on 2025-08-27 07:05 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _input()
  line = STDIN.gets
  line ? line.chomp : ''
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if (arr.is_a?(Array) || arr.is_a?(String)) && idx.is_a?(Numeric)
    idx += arr.length if idx < 0
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _pow(a, b)
  res = (a.nil? ? 0 : a) ** (b.nil? ? 0 : b)
  res.is_a?(Float) && res == res.to_i ? res.to_i : res
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && b.is_a?(Array)
    a + b
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  arr = arr.nil? ? [] : arr.clone
  x = x.clone if x.is_a?(Array)
  arr << x
  arr
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-8 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    "[" + x.map { |e| _str(e) }.join(' ') + "]"
  elsif x.is_a?(Float)
    x % 1 == 0 ? x.to_i.to_s : x.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def split(s, sep)
    parts = []
    cur = ""
    i = 0
    while i < _len(s)
      if _len(sep) > 0 && _add(i, _len(sep)) <= _len(s) && _eq(s[i..._add(i, _len(sep))], sep)
        parts = _append(parts, cur)
        cur = ""
        i = _add(i, _len(sep))
      else
        cur = _add(cur, s[i..._add(i, 1)])
        i = _add(i, 1)
      end
    end
    parts = _append(parts, cur)
    return parts
  end
  def parse_ints(line)
    pieces = split(line, " ")
    nums = []
    i = 0
    while i < _len(pieces)
      p = (__tmp17 = pieces; __tmp17.is_a?(Hash) ? __tmp17[i] : _idx(__tmp17, i))
      if _len(p) > 0
        nums = _append(nums, (p).to_i)
      end
      i = _add(i, 1)
    end
    return nums
  end
  def sort_unique(arr)
    i = 1
    while i < _len(arr)
      j = i
      while j > 0 && (__tmp18 = arr; __tmp18.is_a?(Hash) ? __tmp18[j - 1] : _idx(__tmp18, j - 1)) > (__tmp19 = arr; __tmp19.is_a?(Hash) ? __tmp19[j] : _idx(__tmp19, j))
        tmp = (__tmp20 = arr; __tmp20.is_a?(Hash) ? __tmp20[j - 1] : _idx(__tmp20, j - 1))
        arr[j - 1] = (__tmp21 = arr; __tmp21.is_a?(Hash) ? __tmp21[j] : _idx(__tmp21, j))
        arr[j] = tmp
        j = j - 1
      end
      i = _add(i, 1)
    end
    res = []
    i = 0
    while i < _len(arr)
      if _eq(i, 0) || !_eq((__tmp22 = arr; __tmp22.is_a?(Hash) ? __tmp22[i] : _idx(__tmp22, i)), (__tmp23 = arr; __tmp23.is_a?(Hash) ? __tmp23[i - 1] : _idx(__tmp23, i - 1)))
        res = _append(res, (__tmp24 = arr; __tmp24.is_a?(Hash) ? __tmp24[i] : _idx(__tmp24, i)))
      end
      i = _add(i, 1)
    end
    return res
  end
  def pointInPoly(xs, ys, px, py)
    inside = false
    i = 0
    j = _len(xs) - 1
    while i < _len(xs)
      xi = ((__tmp25 = xs; __tmp25.is_a?(Hash) ? __tmp25[i] : _idx(__tmp25, i))).to_f
      yi = ((__tmp26 = ys; __tmp26.is_a?(Hash) ? __tmp26[i] : _idx(__tmp26, i))).to_f
      xj = ((__tmp27 = xs; __tmp27.is_a?(Hash) ? __tmp27[j] : _idx(__tmp27, j))).to_f
      yj = ((__tmp28 = ys; __tmp28.is_a?(Hash) ? __tmp28[j] : _idx(__tmp28, j))).to_f
      if ((yi > py) && (yj <= py)) || ((yj > py) && (yi <= py))
        xint = _add((xj - xi) * (py - yi) / (yj - yi), xi)
        if px < xint
          inside = !inside
        end
      end
      j = i
      i = _add(i, 1)
    end
    return inside
  end
  def make3DBool(a, b, c)
    arr = []
    i = 0
    while i < a
      plane = []
      j = 0
      while j < b
        row = []
        k = 0
        while k < c
          row = _append(row, false)
          k = _add(k, 1)
        end
        plane = _append(plane, row)
        j = _add(j, 1)
      end
      arr = _append(arr, plane)
      i = _add(i, 1)
    end
    return arr
  end
  def main()
    tLine = _input()
    if _eq(tLine, "")
      return
    end
    t = (tLine).to_i
    case_ = 0
    while case_ < t
      fLine = _input()
      _F = (fLine).to_i
      xs = []
      ys = []
      zs = []
      xs = _append(xs, 0)
      xs = _append(xs, 1001)
      ys = _append(ys, 0)
      ys = _append(ys, 1001)
      zs = _append(zs, 0)
      zs = _append(zs, 1001)
      faceXCoord = []
      faceYPoly = []
      faceZPoly = []
      i = 0
      while i < _F
        line = _input()
        nums = parse_ints(line)
        _P = (__tmp29 = nums; __tmp29.is_a?(Hash) ? __tmp29[0] : _idx(__tmp29, 0))
        ptsX = []
        ptsY = []
        ptsZ = []
        j = 0
        while j < _P
          x = (__tmp30 = nums; __tmp30.is_a?(Hash) ? __tmp30[_add(1, j * 3)] : _idx(__tmp30, _add(1, j * 3)))
          y = (__tmp31 = nums; __tmp31.is_a?(Hash) ? __tmp31[_add(_add(1, j * 3), 1)] : _idx(__tmp31, _add(_add(1, j * 3), 1)))
          z = (__tmp32 = nums; __tmp32.is_a?(Hash) ? __tmp32[_add(_add(1, j * 3), 2)] : _idx(__tmp32, _add(_add(1, j * 3), 2)))
          ptsX = _append(ptsX, x)
          ptsY = _append(ptsY, y)
          ptsZ = _append(ptsZ, z)
          xs = _append(xs, x)
          ys = _append(ys, y)
          zs = _append(zs, z)
          j = _add(j, 1)
        end
        allSame = true
        j = 1
        while j < _P
          if !_eq((__tmp33 = ptsX; __tmp33.is_a?(Hash) ? __tmp33[j] : _idx(__tmp33, j)), (__tmp34 = ptsX; __tmp34.is_a?(Hash) ? __tmp34[0] : _idx(__tmp34, 0)))
            allSame = false
          end
          j = _add(j, 1)
        end
        if allSame
          faceXCoord = _append(faceXCoord, (__tmp35 = ptsX; __tmp35.is_a?(Hash) ? __tmp35[0] : _idx(__tmp35, 0)))
          faceYPoly = _append(faceYPoly, ptsY)
          faceZPoly = _append(faceZPoly, ptsZ)
        end
        i = _add(i, 1)
      end
      xs = sort_unique(xs)
      ys = sort_unique(ys)
      zs = sort_unique(zs)
      nx = _len(xs) - 1
      ny = _len(ys) - 1
      nz = _len(zs) - 1
      xIndex = {}
      i = 0
      while i < _len(xs)
        xIndex[(__tmp36 = xs; __tmp36.is_a?(Hash) ? __tmp36[i] : _idx(__tmp36, i))] = i
        i = _add(i, 1)
      end
      dx = []
      i = 0
      while i < nx
        dx = _append(dx, (__tmp37 = xs; __tmp37.is_a?(Hash) ? __tmp37[_add(i, 1)] : _idx(__tmp37, _add(i, 1))) - (__tmp38 = xs; __tmp38.is_a?(Hash) ? __tmp38[i] : _idx(__tmp38, i)))
        i = _add(i, 1)
      end
      dy = []
      i = 0
      while i < ny
        dy = _append(dy, (__tmp39 = ys; __tmp39.is_a?(Hash) ? __tmp39[_add(i, 1)] : _idx(__tmp39, _add(i, 1))) - (__tmp40 = ys; __tmp40.is_a?(Hash) ? __tmp40[i] : _idx(__tmp40, i)))
        i = _add(i, 1)
      end
      dz = []
      i = 0
      while i < nz
        dz = _append(dz, (__tmp41 = zs; __tmp41.is_a?(Hash) ? __tmp41[_add(i, 1)] : _idx(__tmp41, _add(i, 1))) - (__tmp42 = zs; __tmp42.is_a?(Hash) ? __tmp42[i] : _idx(__tmp42, i)))
        i = _add(i, 1)
      end
      blockX = make3DBool(_len(xs), ny, nz)
      i = 0
      while i < _len(faceXCoord)
        coord = (__tmp43 = faceXCoord; __tmp43.is_a?(Hash) ? __tmp43[i] : _idx(__tmp43, i))
        polyY = (__tmp44 = faceYPoly; __tmp44.is_a?(Hash) ? __tmp44[i] : _idx(__tmp44, i))
        polyZ = (__tmp45 = faceZPoly; __tmp45.is_a?(Hash) ? __tmp45[i] : _idx(__tmp45, i))
        xi = (__tmp46 = xIndex; __tmp46.is_a?(Hash) ? __tmp46[coord] : _idx(__tmp46, coord))
        j = 0
        while j < ny
          cy = (((_add((__tmp47 = ys; __tmp47.is_a?(Hash) ? __tmp47[j] : _idx(__tmp47, j)), (__tmp48 = ys; __tmp48.is_a?(Hash) ? __tmp48[_add(j, 1)] : _idx(__tmp48, _add(j, 1)))))).to_f) / 2.0
          k = 0
          while k < nz
            cz = (((_add((__tmp49 = zs; __tmp49.is_a?(Hash) ? __tmp49[k] : _idx(__tmp49, k)), (__tmp50 = zs; __tmp50.is_a?(Hash) ? __tmp50[_add(k, 1)] : _idx(__tmp50, _add(k, 1)))))).to_f) / 2.0
            if pointInPoly(polyY, polyZ, cy, cz)
              (__tmp51 = (__tmp52 = blockX; __tmp52.is_a?(Hash) ? __tmp52[xi] : _idx(__tmp52, xi)); __tmp51.is_a?(Hash) ? __tmp51[j] : _idx(__tmp51, j))[k] = true
            end
            k = _add(k, 1)
          end
          j = _add(j, 1)
        end
        i = _add(i, 1)
      end
      solid = make3DBool(nx, ny, nz)
      j2 = 0
      while j2 < ny
        k2 = 0
        while k2 < nz
          inside = false
          i2 = 0
          while i2 < nx
            if (__tmp53 = (__tmp54 = (__tmp55 = blockX; __tmp55.is_a?(Hash) ? __tmp55[i2] : _idx(__tmp55, i2)); __tmp54.is_a?(Hash) ? __tmp54[j2] : _idx(__tmp54, j2)); __tmp53.is_a?(Hash) ? __tmp53[k2] : _idx(__tmp53, k2))
              inside = !inside
            end
            if inside
              (__tmp56 = (__tmp57 = solid; __tmp57.is_a?(Hash) ? __tmp57[i2] : _idx(__tmp57, i2)); __tmp56.is_a?(Hash) ? __tmp56[j2] : _idx(__tmp56, j2))[k2] = true
            end
            i2 = _add(i2, 1)
          end
          k2 = _add(k2, 1)
        end
        j2 = _add(j2, 1)
      end
      volume = 0
      i3 = 0
      while i3 < nx
        j3 = 0
        while j3 < ny
          k3 = 0
          while k3 < nz
            if (__tmp58 = (__tmp59 = (__tmp60 = solid; __tmp60.is_a?(Hash) ? __tmp60[i3] : _idx(__tmp60, i3)); __tmp59.is_a?(Hash) ? __tmp59[j3] : _idx(__tmp59, j3)); __tmp58.is_a?(Hash) ? __tmp58[k3] : _idx(__tmp58, k3))
              volume = _add(volume, (__tmp61 = dx; __tmp61.is_a?(Hash) ? __tmp61[i3] : _idx(__tmp61, i3)) * (__tmp62 = dy; __tmp62.is_a?(Hash) ? __tmp62[j3] : _idx(__tmp62, j3)) * (__tmp63 = dz; __tmp63.is_a?(Hash) ? __tmp63[k3] : _idx(__tmp63, k3)))
            end
            k3 = _add(k3, 1)
          end
          j3 = _add(j3, 1)
        end
        i3 = _add(i3, 1)
      end
      puts(_add(_add("The bulk is composed of ", _str(volume)), " units."))
      case_ = _add(case_, 1)
    end
  end
  main()
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
print("\n")
puts(JSON.pretty_generate(result))
