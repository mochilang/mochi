# Generated by Mochi transpiler v0.10.74 on 2025-08-27 07:05 +0700
$VERBOSE = nil
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
if !$now_seeded && ENV['MOCHI_BENCHMARK']
  $now_seeded = true
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1_664_525 + 1_013_904_223) % 2_147_483_647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _input()
  line = STDIN.gets
  line ? line.chomp : ''
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _idx(arr, idx)
  return nil if arr.nil?
  if (arr.is_a?(Array) || arr.is_a?(String)) && idx.is_a?(Numeric)
    idx += arr.length if idx < 0
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _pow(a, b)
  res = (a.nil? ? 0 : a) ** (b.nil? ? 0 : b)
  res.is_a?(Float) && res == res.to_i ? res.to_i : res
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && b.is_a?(Array)
    a + b
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  arr = arr.nil? ? [] : arr.clone
  x = x.clone if x.is_a?(Array)
  arr << x
  arr
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-8 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    "[" + x.map { |e| _str(e) }.join(' ') + "]"
  elsif x.is_a?(Float)
    x % 1 == 0 ? x.to_i.to_s : x.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
start_mem = _mem()
start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  def parseInt(s)
    i = 0
    n = 0
    while i < _len(s)
      n = _add(n * 10, (((__tmp80 = $digits; __tmp80.is_a?(Hash) ? __tmp80[s[i..._add(i, 1)]] : _idx(__tmp80, s[i..._add(i, 1)]))).to_i))
      i = _add(i, 1)
    end
    return n
  end
  def split(s)
    parts = []
    cur = ""
    i = 0
    while i < _len(s)
      ch = s[i..._add(i, 1)]
      if _eq(ch, " ")
        if _len(cur) > 0
          parts = _append(parts, cur)
          cur = ""
        end
      else
        cur = _add(cur, ch)
      end
      i = _add(i, 1)
    end
    if _len(cur) > 0
      parts = _append(parts, cur)
    end
    return parts
  end
  def absf(x)
    if x < 0.0
      return -x
    else
      return x
    end
  end
  def sqrt(x)
    if x <= 0.0
      return 0.0
    end
    r = x
    prev = 0.0
    while absf(r - prev) > 1e-12
      prev = r
      r = (_add(r, x / r)) / 2.0
    end
    return r
  end
  def makeBoolGrid(_P, _Q)
    g = []
    i = 0
    while i < _P
      row = []
      j = 0
      while j < _Q
        row = _append(row, false)
        j = _add(j, 1)
      end
      g = _append(g, row)
      i = _add(i, 1)
    end
    return g
  end
  def visible(grid, _P, _Q, _R, _C, _BR, _BC)
    _X1 = ((_C).to_f) - 0.5
    _Y1 = ((_R).to_f) - 0.5
    _Z1 = _add((((__tmp81 = (__tmp82 = grid; __tmp82.is_a?(Hash) ? __tmp82[((_R - 1)).to_i] : _idx(__tmp82, ((_R - 1)).to_i)); __tmp81.is_a?(Hash) ? __tmp81[((_C - 1)).to_i] : _idx(__tmp81, ((_C - 1)).to_i))).to_f), 0.5)
    _X2 = ((_BC).to_f) - 0.5
    _Y2 = ((_BR).to_f) - 0.5
    _Z2 = _add((((__tmp83 = (__tmp84 = grid; __tmp84.is_a?(Hash) ? __tmp84[((_BR - 1)).to_i] : _idx(__tmp84, ((_BR - 1)).to_i)); __tmp83.is_a?(Hash) ? __tmp83[((_BC - 1)).to_i] : _idx(__tmp83, ((_BC - 1)).to_i))).to_f), 0.5)
    _Dx = _X2 - _X1
    _Dy = _Y2 - _Y1
    _Dz = _Z2 - _Z1
    dist = sqrt(_add(_add(_Dx * _Dx, _Dy * _Dy), _Dz * _Dz))
    steps = _add((((dist * 20.0)).to_i), 1)
    stepT = 1.0 / ((steps).to_f)
    i = 1
    while i < steps
      t = stepT * ((i).to_f)
      _X = _add(_X1, _Dx * t)
      _Y = _add(_Y1, _Dy * t)
      _Z = _add(_Z1, _Dz * t)
      rIdx = _add((((_Y).to_i)), 1)
      cIdx = _add((((_X).to_i)), 1)
      if rIdx < 1 || rIdx > _P || cIdx < 1 || cIdx > _Q
        return false
      end
      _H = ((__tmp85 = (__tmp86 = grid; __tmp86.is_a?(Hash) ? __tmp86[((rIdx - 1)).to_i] : _idx(__tmp86, ((rIdx - 1)).to_i)); __tmp85.is_a?(Hash) ? __tmp85[((cIdx - 1)).to_i] : _idx(__tmp85, ((cIdx - 1)).to_i))).to_f
      if _Z <= _H
        return false
      end
      i = _add(i, 1)
    end
    return true
  end
  def computeVis(grid, _P, _Q, _BR, _BC)
    vis = makeBoolGrid(_P, _Q)
    r = 1
    while r <= _P
      c = 1
      while c <= _Q
        (__tmp87 = vis; __tmp87.is_a?(Hash) ? __tmp87[((r - 1)).to_i] : _idx(__tmp87, ((r - 1)).to_i))[((c - 1)).to_i] = visible(grid, _P, _Q, r, c, _BR, _BC)
        c = _add(c, 1)
      end
      r = _add(r, 1)
    end
    return vis
  end
  def bfs(grid, _P, _Q, _R1, _C1, _R2, _C2)
    vis1 = computeVis(grid, _P, _Q, _R1, _C1)
    vis2 = computeVis(grid, _P, _Q, _R2, _C2)
    visited = makeBoolGrid(_P, _Q)
    qR = []
    qC = []
    qD = []
    qR = _append(qR, _R1)
    qC = _append(qC, _C1)
    qD = _append(qD, 0)
    (__tmp88 = visited; __tmp88.is_a?(Hash) ? __tmp88[((_R1 - 1)).to_i] : _idx(__tmp88, ((_R1 - 1)).to_i))[((_C1 - 1)).to_i] = true
    head = 0
    while head < _len(qR)
      r = (__tmp89 = qR; __tmp89.is_a?(Hash) ? __tmp89[head] : _idx(__tmp89, head))
      c = (__tmp90 = qC; __tmp90.is_a?(Hash) ? __tmp90[head] : _idx(__tmp90, head))
      d = (__tmp91 = qD; __tmp91.is_a?(Hash) ? __tmp91[head] : _idx(__tmp91, head))
      if _eq(r, _R2) && _eq(c, _C2)
        return d
      end
      hr = (__tmp92 = (__tmp93 = grid; __tmp93.is_a?(Hash) ? __tmp93[((r - 1)).to_i] : _idx(__tmp93, ((r - 1)).to_i)); __tmp92.is_a?(Hash) ? __tmp92[((c - 1)).to_i] : _idx(__tmp92, ((c - 1)).to_i))
      idx = 0
      while idx < 4
        nr = r
        nc = c
        if _eq(idx, 0)
          nr = nr - 1
        end
        if _eq(idx, 1)
          nr = _add(nr, 1)
        end
        if _eq(idx, 2)
          nc = nc - 1
        end
        if _eq(idx, 3)
          nc = _add(nc, 1)
        end
        if nr >= 1 && nr <= _P && nc >= 1 && nc <= _Q
          if !(__tmp94 = (__tmp95 = visited; __tmp95.is_a?(Hash) ? __tmp95[((nr - 1)).to_i] : _idx(__tmp95, ((nr - 1)).to_i)); __tmp94.is_a?(Hash) ? __tmp94[((nc - 1)).to_i] : _idx(__tmp94, ((nc - 1)).to_i))
            hn = (__tmp96 = (__tmp97 = grid; __tmp97.is_a?(Hash) ? __tmp97[((nr - 1)).to_i] : _idx(__tmp97, ((nr - 1)).to_i)); __tmp96.is_a?(Hash) ? __tmp96[((nc - 1)).to_i] : _idx(__tmp96, ((nc - 1)).to_i))
            diff = hn - hr
            if diff <= 1 && diff >= 0 - 3
              if (__tmp98 = (__tmp99 = vis1; __tmp99.is_a?(Hash) ? __tmp99[((nr - 1)).to_i] : _idx(__tmp99, ((nr - 1)).to_i)); __tmp98.is_a?(Hash) ? __tmp98[((nc - 1)).to_i] : _idx(__tmp98, ((nc - 1)).to_i)) || (__tmp100 = (__tmp101 = vis2; __tmp101.is_a?(Hash) ? __tmp101[((nr - 1)).to_i] : _idx(__tmp101, ((nr - 1)).to_i)); __tmp100.is_a?(Hash) ? __tmp100[((nc - 1)).to_i] : _idx(__tmp100, ((nc - 1)).to_i))
                (__tmp102 = visited; __tmp102.is_a?(Hash) ? __tmp102[((nr - 1)).to_i] : _idx(__tmp102, ((nr - 1)).to_i))[((nc - 1)).to_i] = true
                qR = _append(qR, nr)
                qC = _append(qC, nc)
                qD = _append(qD, _add(d, 1))
              end
            end
          end
        end
        idx = _add(idx, 1)
      end
      head = _add(head, 1)
    end
    return -1
  end
  def main()
    tLine = _input()
    if _eq(tLine, "")
      return
    end
    t = parseInt(tLine)
    case_ = 0
    while case_ < t
      line = _input()
      while _eq(line, "")
        line = _input()
      end
      pq = split(line)
      _P = parseInt((__tmp103 = pq; __tmp103.is_a?(Hash) ? __tmp103[0] : _idx(__tmp103, 0)))
      _Q = parseInt((__tmp104 = pq; __tmp104.is_a?(Hash) ? __tmp104[1] : _idx(__tmp104, 1)))
      grid = []
      r = 0
      while r < _P
        rowParts = split(_input())
        row = []
        c = 0
        while c < _Q
          row = _append(row, parseInt((__tmp105 = rowParts; __tmp105.is_a?(Hash) ? __tmp105[c] : _idx(__tmp105, c))))
          c = _add(c, 1)
        end
        grid = _append(grid, row)
        r = _add(r, 1)
      end
      coords = split(_input())
      _R1 = parseInt((__tmp106 = coords; __tmp106.is_a?(Hash) ? __tmp106[0] : _idx(__tmp106, 0)))
      _C1 = parseInt((__tmp107 = coords; __tmp107.is_a?(Hash) ? __tmp107[1] : _idx(__tmp107, 1)))
      _R2 = parseInt((__tmp108 = coords; __tmp108.is_a?(Hash) ? __tmp108[2] : _idx(__tmp108, 2)))
      _C2 = parseInt((__tmp109 = coords; __tmp109.is_a?(Hash) ? __tmp109[3] : _idx(__tmp109, 3)))
      res = bfs(grid, _P, _Q, _R1, _C1, _R2, _C2)
      if res < 0
        puts("Mission impossible!")
      else
        puts(_add(_add("The shortest path is ", _str(res)), " steps long."))
      end
      case_ = _add(case_, 1)
    end
  end
  $digits = {"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
  main()
end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
print("\n")
puts(JSON.pretty_generate(result))
