# Generated by Mochi transpiler v0.10.74 on 2025-08-26 11:55 +0700
$VERBOSE = nil

def _input()
  line = STDIN.gets
  line ? line.chomp : ''
end


def _idx(arr, idx)
  return nil if arr.nil?
  if (arr.is_a?(Array) || arr.is_a?(String)) && idx.is_a?(Numeric)
    idx += arr.length if idx < 0
    return nil if idx < 0 || idx >= arr.length
  end
  arr[idx]
end


def _pow(a, b)
  res = (a.nil? ? 0 : a) ** (b.nil? ? 0 : b)
  res.is_a?(Float) && res == res.to_i ? res.to_i : res
end


def _len(x)
  x.respond_to?(:length) ? x.length : 0
end


def _has(obj, key)
  if obj.is_a?(Hash)
    obj.key?(key)
  elsif obj.respond_to?(:include?)
    obj.include?(key)
  elsif obj.respond_to?(:to_h)
    k = key.respond_to?(:to_sym) ? key.to_sym : key
    obj.to_h.key?(k)
  else
    false
  end
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  elsif a.is_a?(Array) && b.is_a?(Array)
    a + b
  elsif a.is_a?(Array) && !b.is_a?(Array)
    a + [b]
  elsif !a.is_a?(Array) && b.is_a?(Array)
    [a] + b
  elsif a.is_a?(String) || b.is_a?(String)
    a.to_s + b.to_s
  else
    (a.nil? ? 0 : a) + (b.nil? ? 0 : b)
  end
end


def _append(arr, x)
  arr = arr.nil? ? [] : arr.clone
  x = x.clone if x.is_a?(Array)
  arr << x
  arr
end


def _eq(a, b)
  if a.is_a?(Float) || b.is_a?(Float)
    diff = (a.to_f - b.to_f).abs
    scale = [a.to_f.abs, b.to_f.abs].max
    scale = 1.0 if scale == 0.0
    diff <= 1e-8 * scale
  else
    a == b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


def _padEnd(s, len, ch)
  s.to_s.ljust(len, ch)
end


def _str(x)
  if x.is_a?(Array)
    "[" + x.map { |e| _str(e) }.join(' ') + "]"
  elsif x.is_a?(Float)
    x % 1 == 0 ? x.to_i.to_s : x.to_s
  else
    x.to_s
  end
end


class String
  alias each each_char
end


def panic(msg)
  raise RuntimeError, msg
end

__name__ = '__main__'
def parseInt(str)
  digits = {"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
  i = 0
  n = 0
  while i < _len(str)
    ch = str[i..._add(i, 1)]
    if !_eq(ch, " ")
      n = _add(n * 10, (__tmp46 = digits; __tmp46.is_a?(Hash) ? __tmp46[ch] : _idx(__tmp46, ch)))
    end
    i = _add(i, 1)
  end
  return n
end
def parseInts(line)
  digits = {"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
  nums = []
  cur = 0
  inNum = false
  i = 0
  while i < _len(line)
    ch = line[i..._add(i, 1)]
    if _eq(ch, " ")
      if inNum
        nums = _append(nums, cur)
        cur = 0
        inNum = false
      end
    else
      cur = _add(cur * 10, (__tmp47 = digits; __tmp47.is_a?(Hash) ? __tmp47[ch] : _idx(__tmp47, ch)))
      inNum = true
    end
    i = _add(i, 1)
  end
  if inNum
    nums = _append(nums, cur)
  end
  return nums
end
def abs(x)
  if x < 0
    return 0 - x
  else
    return x
  end
end
def visible(h, r1, c1, r2, c2)
  if _eq(r1, r2) && _eq(c1, c2)
    return true
  end
  h0 = (__tmp48 = (__tmp49 = h; __tmp49.is_a?(Hash) ? __tmp49[r1] : _idx(__tmp49, r1)); __tmp48.is_a?(Hash) ? __tmp48[c1] : _idx(__tmp48, c1))
  h1 = (__tmp50 = (__tmp51 = h; __tmp51.is_a?(Hash) ? __tmp51[r2] : _idx(__tmp51, r2)); __tmp50.is_a?(Hash) ? __tmp50[c2] : _idx(__tmp50, c2))
  dr = r2 - r1
  dc = c2 - c1
  steps = dr.abs()
  if dc.abs() > steps
    steps = dc.abs()
  end
  x = _add(((c1).to_f), 0.5)
  y = _add(((r1).to_f), 0.5)
  z = _add(((h0).to_f), 0.5)
  incX = ((dc).to_f) / ((steps).to_f)
  incY = ((dr).to_f) / ((steps).to_f)
  incZ = (((h1 - h0)).to_f) / ((steps).to_f)
  i = 1
  while i < steps
    x = _add(x, incX)
    y = _add(y, incY)
    z = _add(z, incZ)
    cx = (x).to_i
    cy = (y).to_i
    if z <= (((__tmp52 = (__tmp53 = h; __tmp53.is_a?(Hash) ? __tmp53[cy] : _idx(__tmp53, cy)); __tmp52.is_a?(Hash) ? __tmp52[cx] : _idx(__tmp52, cx))).to_f)
      return false
    end
    i = _add(i, 1)
  end
  return true
end
def computeVis(h, p, q, r, c)
  vis = []
  (0...p).each do |i|
    row = []
    (0...q).each do |j|
      row = _append(row, visible(h, i, j, r, c))
    end
    vis = _append(vis, row)
  end
  return vis
end
def bfs(h, vis1, vis2, p, q, r1, c1, r2, c2)
  dist = []
  (0...p).each do |i|
    row = []
    (0...q).each do |j|
      row = _append(row, 0 - 1)
    end
    dist = _append(dist, row)
  end
  qr = []
  qc = []
  qr = _append(qr, r1)
  qc = _append(qc, c1)
  (__tmp54 = dist; __tmp54.is_a?(Hash) ? __tmp54[r1] : _idx(__tmp54, r1))[c1] = 0
  head = 0
  drs = [-1, 1, 0, 0]
  dcs = [0, 0, -1, 1]
  while head < _len(qr)
    r = (__tmp55 = qr; __tmp55.is_a?(Hash) ? __tmp55[head] : _idx(__tmp55, head))
    c = (__tmp56 = qc; __tmp56.is_a?(Hash) ? __tmp56[head] : _idx(__tmp56, head))
    head = _add(head, 1)
    if _eq(r, r2) && _eq(c, c2)
      break
    end
    hcur = (__tmp57 = (__tmp58 = h; __tmp58.is_a?(Hash) ? __tmp58[r] : _idx(__tmp58, r)); __tmp57.is_a?(Hash) ? __tmp57[c] : _idx(__tmp57, c))
    k = 0
    while k < 4
      nr = _add(r, (__tmp59 = drs; __tmp59.is_a?(Hash) ? __tmp59[k] : _idx(__tmp59, k)))
      nc = _add(c, (__tmp60 = dcs; __tmp60.is_a?(Hash) ? __tmp60[k] : _idx(__tmp60, k)))
      if nr >= 0 && nr < p && nc >= 0 && nc < q
        if _eq((__tmp61 = (__tmp62 = dist; __tmp62.is_a?(Hash) ? __tmp62[nr] : _idx(__tmp62, nr)); __tmp61.is_a?(Hash) ? __tmp61[nc] : _idx(__tmp61, nc)), 0 - 1)
          nh = (__tmp63 = (__tmp64 = h; __tmp64.is_a?(Hash) ? __tmp64[nr] : _idx(__tmp64, nr)); __tmp63.is_a?(Hash) ? __tmp63[nc] : _idx(__tmp63, nc))
          if nh <= _add(hcur, 1) && nh >= hcur - 3
            if (__tmp65 = (__tmp66 = vis1; __tmp66.is_a?(Hash) ? __tmp66[nr] : _idx(__tmp66, nr)); __tmp65.is_a?(Hash) ? __tmp65[nc] : _idx(__tmp65, nc)) || (__tmp67 = (__tmp68 = vis2; __tmp68.is_a?(Hash) ? __tmp68[nr] : _idx(__tmp68, nr)); __tmp67.is_a?(Hash) ? __tmp67[nc] : _idx(__tmp67, nc))
              (__tmp69 = dist; __tmp69.is_a?(Hash) ? __tmp69[nr] : _idx(__tmp69, nr))[nc] = _add((__tmp70 = (__tmp71 = dist; __tmp71.is_a?(Hash) ? __tmp71[r] : _idx(__tmp71, r)); __tmp70.is_a?(Hash) ? __tmp70[c] : _idx(__tmp70, c)), 1)
              qr = _append(qr, nr)
              qc = _append(qc, nc)
            end
          end
        end
      end
      k = _add(k, 1)
    end
  end
  return (__tmp72 = (__tmp73 = dist; __tmp73.is_a?(Hash) ? __tmp73[r2] : _idx(__tmp73, r2)); __tmp72.is_a?(Hash) ? __tmp72[c2] : _idx(__tmp72, c2))
end
def main()
  tStr = _input()
  if _eq(tStr, "")
    return
  end
  _T = parseInt(tStr)
  (0..._T).each do |_|
    line = _input()
    while _eq(line, "")
      line = _input()
    end
    dims = parseInts(line)
    _P = (__tmp74 = dims; __tmp74.is_a?(Hash) ? __tmp74[0] : _idx(__tmp74, 0))
    _Q = (__tmp75 = dims; __tmp75.is_a?(Hash) ? __tmp75[1] : _idx(__tmp75, 1))
    h = []
    (0..._P).each do |i|
      rowVals = parseInts(_input())
      h = _append(h, rowVals)
    end
    posLine = _input()
    pos = parseInts(posLine)
    r1 = (__tmp76 = pos; __tmp76.is_a?(Hash) ? __tmp76[0] : _idx(__tmp76, 0)) - 1
    c1 = (__tmp77 = pos; __tmp77.is_a?(Hash) ? __tmp77[1] : _idx(__tmp77, 1)) - 1
    r2 = (__tmp78 = pos; __tmp78.is_a?(Hash) ? __tmp78[2] : _idx(__tmp78, 2)) - 1
    c2 = (__tmp79 = pos; __tmp79.is_a?(Hash) ? __tmp79[3] : _idx(__tmp79, 3)) - 1
    vis1 = computeVis(h, _P, _Q, r1, c1)
    vis2 = computeVis(h, _P, _Q, r2, c2)
    res = bfs(h, vis1, vis2, _P, _Q, r1, c1, r2, c2)
    if _eq(res, 0 - 1)
      puts("Mission impossible!")
    else
      puts(_add(_add("The shortest path is ", _str(res)), " steps long."))
    end
  end
end
main()
