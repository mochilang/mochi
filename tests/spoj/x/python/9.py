# Code generated by Mochi transpiler.
# Version 0.10.74, generated on 2025-08-27 07:05 +0700
import json
import time

try:
    import resource
except Exception:
    resource = None
import sys
if hasattr(sys, "set_int_max_str_digits"):
    sys.set_int_max_str_digits(0)
if hasattr(sys, "setrecursionlimit"):
    sys.setrecursionlimit(1000000)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _append(lst, v):
    lst = [] if lst is None else lst[:]
    lst.append(v)
    return lst


import builtins
def _str(v):
    return builtins.str(v)


def _set_index(lst, idx, val):
    if lst is None:
        lst = []
    if idx >= len(lst):
        lst.extend([None] * (idx - len(lst) + 1))
    lst[idx] = val
    return lst

digits = {"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
def parseInt(s):
    i = 0
    n = 0
    while i < len(s):
        n = n * 10 + (int(digits.get(s[i:i + 1], 0)))
        i = i + 1
    return n
def split(s):
    parts = []
    cur = ""
    i = 0
    while i < len(s):
        ch = s[i:i + 1]
        if ch == " ":
            if len(cur) > 0:
                parts = _append(parts, cur)
                cur = ""
        else:
            cur = cur + ch
        i = i + 1
    if len(cur) > 0:
        parts = _append(parts, cur)
    return parts
def absf(x):
    if x < 0.0:
        return -x
    else:
        return x
def sqrt(x):
    if x <= 0.0:
        return 0.0
    r = x
    prev = 0.0
    while absf(r - prev) > 1e-12:
        prev = r
        r = (r + x / r) / 2.0
    return r
def makeBoolGrid(P, Q):
    g = []
    i = 0
    while i < P:
        row = []
        j = 0
        while j < Q:
            row = _append(row, False)
            j = j + 1
        g = _append(g, row)
        i = i + 1
    return g
def visible(grid, P, Q, R, C, BR, BC):
    X1 = (float(C)) - 0.5
    Y1 = (float(R)) - 0.5
    Z1 = (float(grid[int((R - 1))][int((C - 1))])) + 0.5
    X2 = (float(BC)) - 0.5
    Y2 = (float(BR)) - 0.5
    Z2 = (float(grid[int((BR - 1))][int((BC - 1))])) + 0.5
    Dx = X2 - X1
    Dy = Y2 - Y1
    Dz = Z2 - Z1
    dist = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
    steps = (int((dist * 20.0))) + 1
    stepT = 1.0 / (float(steps))
    i = 1
    while i < steps:
        t = stepT * (float(i))
        X = X1 + Dx * t
        Y = Y1 + Dy * t
        Z = Z1 + Dz * t
        rIdx = ((int(Y))) + 1
        cIdx = ((int(X))) + 1
        if rIdx < 1 or rIdx > P or cIdx < 1 or cIdx > Q:
            return False
        H = float(grid[int((rIdx - 1))][int((cIdx - 1))])
        if Z <= H:
            return False
        i = i + 1
    return True
def computeVis(grid, P, Q, BR, BC):
    vis = makeBoolGrid(P, Q)
    r = 1
    while r <= P:
        c = 1
        while c <= Q:
            vis[int((r - 1))][int((c - 1))] = visible(grid, P, Q, r, c, BR, BC)
            c = c + 1
        r = r + 1
    return vis
def bfs(grid, P, Q, R1, C1, R2, C2):
    vis1 = computeVis(grid, P, Q, R1, C1)
    vis2 = computeVis(grid, P, Q, R2, C2)
    visited = makeBoolGrid(P, Q)
    qR = []
    qC = []
    qD = []
    qR = _append(qR, R1)
    qC = _append(qC, C1)
    qD = _append(qD, 0)
    visited[int((R1 - 1))][int((C1 - 1))] = True
    head = 0
    while head < len(qR):
        r = qR[head]
        c = qC[head]
        d = qD[head]
        if r == R2 and c == C2:
            return d
        hr = grid[int((r - 1))][int((c - 1))]
        idx = 0
        while idx < 4:
            nr = r
            nc = c
            if idx == 0:
                nr = nr - 1
            if idx == 1:
                nr = nr + 1
            if idx == 2:
                nc = nc - 1
            if idx == 3:
                nc = nc + 1
            if nr >= 1 and nr <= P and nc >= 1 and nc <= Q:
                if not visited[int((nr - 1))][int((nc - 1))]:
                    hn = grid[int((nr - 1))][int((nc - 1))]
                    diff = hn - hr
                    if diff <= 1 and diff >= 0 - 3:
                        if vis1[int((nr - 1))][int((nc - 1))] or vis2[int((nr - 1))][int((nc - 1))]:
                            visited[int((nr - 1))][int((nc - 1))] = True
                            qR = _append(qR, nr)
                            qC = _append(qC, nc)
                            qD = _append(qD, d + 1)
            idx = idx + 1
        head = head + 1
    return -1
def main():
    if resource:
        _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    else:
        _bench_mem_start = 0
    _bench_start = _now()
    try:
        tLine = input()
        if tLine == "":
            return
        t = parseInt(tLine)
        case = 0
        while case < t:
            line = input()
            while line == "":
                line = input()
            pq = split(line)
            P = parseInt(pq[0])
            Q = parseInt(pq[1])
            grid = []
            r = 0
            while r < P:
                rowParts = split(input())
                row = []
                c = 0
                while c < Q:
                    row = _append(row, parseInt(rowParts[c]))
                    c = c + 1
                grid = _append(grid, row)
                r = r + 1
            coords = split(input())
            R1 = parseInt(coords[0])
            C1 = parseInt(coords[1])
            R2 = parseInt(coords[2])
            C2 = parseInt(coords[3])
            res = bfs(grid, P, Q, R1, C1, R2, C2)
            if res < 0:
                print("Mission impossible!")
            else:
                print("The shortest path is " + _str(res) + " steps long.")
            case = case + 1
    finally:
        _bench_end = _now()
        if resource:
            _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        else:
            _bench_mem_end = 0
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": (_bench_mem_end - _bench_mem_start)*1024, "name": "main"}, indent=2))
main()

