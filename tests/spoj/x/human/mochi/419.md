# TRANSP - Transposing is Fun

We need the minimal number of swaps to transpose a `2^a × 2^b` matrix stored
in row-major order. Transposition induces a permutation on the `2^{a+b}`
indices. For an element at linear index `i` with row `r` and column `c`, the
transposed position is `j = c·2^a + r`.

Observe that for all indices except the last one, this mapping is equivalent to
multiplying by `2^a` modulo `2^{a+b} - 1`. In binary this is a left rotation of
an `(a+b)`‑bit string by `a` positions. Thus cycle counting reduces to counting
orbits of such rotations.

Let `g = gcd(a, b)` and `q = (a + b) / g`. Using Burnside's lemma, the number of
cycles of the permutation is

```
cycles = (1/q) * Σ_{e|q} φ(e) · 2^{g·(q/e)}
```

where `φ` is Euler's totient and the sum runs over all divisors `e` of `q`.
The minimal number of swaps is then `2^{a+b} - cycles`.

To compute the answer modulo `1,000,003` we

1. Enumerate divisors of `q`.
2. For each divisor, add `φ(e) · 2^{g·(q/e)}` to the sum using modular
   exponentiation.
3. Multiply the sum by the modular inverse of `q` to obtain `cycles`.
4. Subtract `cycles` from `2^{a+b}`.

This runs in `O(√q)` per test case, which is easily fast enough for
`a + b ≤ 500000`.
