# [AB-words](https://www.spoj.com/problems/ABWORDS/)

## Problem Summary
Given multiple test cases, each providing a set of "nice" ab-words (strings of `a` and `b` with balanced counts and every prefix having at least as many `a` as `b`), compute the maximum number of words that can be chosen such that no two chosen words are similar. Two nice ab-words are similar if they represent the same structure under a recursive definition that allows swapping of subwords.

## Algorithm
1. Observe that every nice ab-word can be parsed by the grammar `S -> 'a' S S 'b'`, corresponding to a rooted binary tree where `a` opens a node and `b` closes it.
2. Parse each word recursively to build a canonical representation of this tree while ignoring the order of the two children:
   - Consume `'a'`, recursively parse the left subtree if the next symbol is `'a'` otherwise it is empty.
   - Recursively parse the right subtree similarly.
   - Consume `'b'` closing the node.
   - The canonical string for a node is `"(" + min(left,right) + max(left,right) + ")"`, using lexicographic order so swapped children yield the same form.
3. Insert the canonical form of every word into a set and count unique forms; this count is the level of diversity for the test case.

The recursion depth is bounded by half the word length (â‰¤100), and total time is linear in the combined length of all words.
