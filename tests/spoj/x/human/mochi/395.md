# [Anti-prime Sequences](https://www.spoj.com/problems/APRIME/)

## Problem Summary
Given integers \(n\), \(m\) and degree \(d\), reorder the consecutive numbers \(n\) to \(m\) so that every consecutive subsequence of length \(2\) through \(d\) has a composite sum. If multiple valid orderings exist, output the lexicographically smallest sequence. If none exist, print `No anti-prime sequence exists.`

## Algorithm
1. **Prime Sieve** – Precompute primes up to 10000 using the Sieve of Eratosthenes so primality checks are constant time.
2. **Depth‑First Search** – Build the permutation recursively.
   - Maintain the current sequence and a boolean array for used numbers.
   - Try unused numbers in ascending order to preserve lexicographic order.
   - After adding a number, verify that the sums of the last \(k\) elements for \(2 \le k \le d\) are composite using the sieve.
   - Backtrack on failure.
3. **Result** – When the sequence reaches length \(m-n+1\), format it as a comma‑separated string. If no arrangement satisfies the conditions, return the failure message.

The strong composite-sum constraints and the limit \(d \le 10\) keep the search space manageable.
