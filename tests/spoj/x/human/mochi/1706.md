# [Queens, Knights and Pawns](https://www.spoj.com/problems/QKP/)

## Problem Summary
Given an $n \times m$ chessboard (up to 1000×1000) with the positions of queens, knights, and pawns (at most 100 of each), count how many squares are not occupied and not attacked by any queen or knight. Queens attack along rows, columns, and diagonals until blocked by any piece. Knights attack in their usual L‑shaped jumps and are not blocked. Pawns only block squares; they do not attack. Input consists of multiple test cases terminated by `0 0`.

## Algorithm
1. Read board dimensions `n m`; stop when both are zero.
2. Read and record positions of queens, knights, and pawns. Track occupied squares in a set.
3. For every queen, step in each of the eight directions until leaving the board or hitting an occupied square, marking each visited square as attacked.
4. For every knight, apply its eight possible moves; if the target square is inside the board and unoccupied, mark it as attacked.
5. Safe squares = `n*m - occupied - attacked`.
6. Output the board number and the count of safe squares.

## Correctness
- Queens visit all squares visible to them until blocked, so all squares they can attack are marked. Knights' moves are independent of blockers, so all knight attacks are marked. Because occupied squares are excluded from the attack set, every unoccupied attacked square is counted exactly once.
- Every unoccupied square not marked as attacked is therefore safe. The final subtraction counts exactly the unoccupied, unattacked squares.

## Complexity
Let `q` be the number of queens and `k` the number of knights. Each queen may scan at most `O(n + m)` squares in total, and each knight checks 8 squares. Thus the running time is `O(q(n+m) + k)` and the memory usage is `O(q + k)` for storing piece positions and the attacked set.
