# LSORT - Sorting is not easy

Given a permutation we must build the sorted sequence `1..N` by repeatedly
extracting an element from the current list and attaching it to either end of
the result.  Removing the `x`-th remaining element at step `i` costs `x*i`.

To produce a sorted list we may start from any number and then repeatedly
extend the current interval `[L..R]` by adding either `L-1` to the left or
`R+1` to the right.  The order of these choices determines which element is
removed at each step and thus the cost.

## Algorithm

For each value `v` store its original position `pos[v]`.  Precompute `less[b][v]`
= number of values `<= b` that appear before `v` in the permutation.  When the
current interval of already taken values is `[L..R]`, the position of a value
`x` in the remaining list is

```
rank(x, L, R) = pos[x] - (less[R][x] - less[L-1][x]).
```

Dynamic programming over intervals expands the range step by step:

```
dp[L][R] – minimal cost after extracting all values in [L,R]
```

Base: `dp[k][k] = pos[k]` for all possible starting values `k`.
For an interval `[L,R]` the next step number is `len=[R-L+1] + 1`.  We may add
`L-1` or `R+1` with costs `rank(L-1,L,R)*step` or `rank(R+1,L,R)*step`
respectively.  The DP considers all states of width `1..N` and updates
neighbouring intervals.

The answer is `dp[1][N]` after processing all states.  Complexity is `O(N^2)`
per test case, which is feasible for `N ≤ 1000`.
