# HOLIDAY2 - Getting Rid of the Holidays (Act II)

We are given `n` holiday periods `t_i` and must remove exactly `k` of them so that the remaining holidays repeat every `r` days, with `r` as large as possible. For such an `r`, all retained periods must be multiples of `r`.

### Algorithm

1. Maintain a map `dp[g]` storing the minimum number of removed holidays needed to obtain a gcd of `g` for the processed periods. Start with `dp[0] = 0`.
2. For each period `t`:
   - For every existing gcd `g` in `dp`, update two transitions:
     - **Keep** the period: new gcd `g2 = gcd(g, t)` and removal count unchanged.
     - **Remove** the period: gcd stays `g` with removal count +1.
   - For each gcd, keep only the smallest removal count.
3. After processing all periods, scan all gcd values and choose the largest `g` with `dp[g] ≤ k` (since we can always remove additional multiples of `g` to reach exactly `k` removals).
4. Remove every holiday whose period is not divisible by `g`; if fewer than `k` are removed, discard extra multiples of `g` arbitrarily. Output the removed indices in increasing order.

### Complexity

The number of distinct gcd values remains small (at most a few thousand), yielding a time complexity of `O(n * m)` and memory `O(m)` where `m` is the number of gcd states. This easily fits within the limits (`n ≤ 100`).
