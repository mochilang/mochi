# [Exchange Operations](https://www.spoj.com/problems/EOPERA/)

## Problem Summary
Given a permutation of the numbers `0..11`. When the digit `0` is at position `i`, it may be swapped with position `j` if:

- `|i - j| = d_k` for `d = [1, 3, 6]`, and
- for `d = 1` the indices lie in the same block of size `3`,
- for `d = 3` the indices lie in the same block of size `6`,
- for `d = 6` the condition is always satisfied.

The task is to obtain the increasing sequence `0 1 2 ... 11` with the minimum number of such swaps.

## Algorithm
1. Build the graph of the 12 positions describing all allowed moves of `0`.
2. Pre-compute shortest distances between every pair of positions using BFS.
3. Solve each test case with Iterative Deepening A* (IDA*):
   - heuristic = sum of distances of every tile from its goal position,
   - recursively explore swapping `0` with neighbouring positions while
     avoiding the immediate backtracking move,
   - increase the search bound until a solution is found.
4. The bound at which IDA* succeeds is the minimal number of required exchanges.

The state space is tiny and IDA* finishes quickly for all inputs.
