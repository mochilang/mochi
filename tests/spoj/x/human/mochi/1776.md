# DNALAB - DNA Laboratory

We are given up to 15 DNA strings and must produce the shortest string that contains each of them as a substring. When multiple superstrings have the same minimal length, the lexicographically smallest one is required.

## Algorithm

1. **Prune input** – Remove duplicated strings and any string that is a substring of another. These strings do not affect the final superstring.
2. **Overlap computation** – For every pair of remaining strings `i` and `j`, compute the length of the longest suffix of `i` that matches a prefix of `j`.
3. **Bitmask DP** – Let `dp[mask][i]` be the best superstring that covers the set of strings encoded by `mask` and ends with string `i`.
   - Initialize `dp[1<<i][i] = s[i]` for all `i`.
   - For each state `(mask, i)` and each string `j` not in `mask`, attempt to append `j` to the current superstring using the pre‑computed overlap. Update `dp[mask | (1<<j)][j]` if the new string is shorter or equal in length but lexicographically smaller.
4. **Result** – The answer is the minimum among `dp[(1<<n)-1][i]` for all `i`.

This dynamic programming explores all permutations but uses overlaps to avoid recomputing common parts. Complexity is `O(n^2 * 2^n)` with `n ≤ 15`, which is feasible.
