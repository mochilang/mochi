# [Alphacode](https://www.spoj.com/problems/ACODE/)

## Problem Summary
Given a string of digits that encodes letters using 1 -> A through 26 -> Z, count how many possible decodings exist. Multiple test cases are provided, one per line, and the list terminates with a single 0. Each input string has length at most 5000 and does not start with 0. For each line output the number of decodings as a 64-bit integer.

## Algorithm
For a string `s` of length `n`:
1. Create an array `dp` of size `n + 1` with `dp[0] = 1`. `dp[i]` will hold the number of ways to decode the first `i` characters.
2. For `i` from 1 to `n`:
   - If `s[i-1]` is not `0`, add `dp[i-1]` to `dp[i]` (a valid single-digit code).
   - If `i >= 2` and the substring `s[i-2:i]` forms a number between 10 and 26, add `dp[i-2]` to `dp[i]` (a valid two-digit code).
3. The answer is `dp[n]`.

## Correctness
We prove by induction that `dp[i]` counts the decodings of the prefix of length `i`.
- **Base**: `dp[0] = 1` corresponds to the empty string.
- **Step**: For position `i`, every decoding either uses the single digit `s[i-1]` (if valid) extending a decoding of the first `i-1` characters, or it uses the two-digit number `s[i-2:i]` (if valid) extending a decoding of the first `i-2` characters. These cases are disjoint and cover all possibilities, so `dp[i]` counts all decodings.
Thus `dp[n]` equals the number of decodings of `s`.

## Complexity
The loop processes each character once, so the running time is `O(n)` and the memory usage is `O(n)` per input string.
