# [Expression](https://www.spoj.com/problems/EXPR1/)

## Problem Summary
Given an expression `E` of length `n` consisting of alternating operators `'+'` or `'-'` and digits `0..9` (the first character is an operator), and a target integer `k`, determine whether parentheses can be inserted so that the value of `E` becomes `k`. If possible, output the minimal number of parenthesis pairs required; otherwise print `NO`.

## Algorithm
1. Parse the expression into two arrays: `signs[i]` for each operator and `nums[i]` for the digits.
2. Use dynamic programming over the digits while tracking two parameters:
   - `open`: how many parenthesis groups are currently open (i.e., how many sign inversions are active).
   - `sum`: the current value produced so far.
   The DP table stores the minimal number of pairs used for each `(open, sum)` combination.
3. For each digit:
   - **Without opening a new parenthesis**: apply its operator. The effective sign is multiplied by `-1` if `open` is odd.
   - **Opening a new parenthesis** (allowed only if the operator is `'-'`): the minus becomes subtraction of an entire group, so the digit's sign becomes `'+'` under an increased `open` count. This adds one pair of parentheses to the cost.
   - After processing the digit, any number of currently open parentheses may be closed; closing does not change the cost.
4. Start with `open = 0`, `sum = 0`. After all digits are processed, check state `(0, k)`; the stored minimal cost is the answer, or `NO` if unreachable.

The number of digits is at most 20 and possible sums lie within `[-180,180]`, making the state space small and the algorithm efficient.
