# [Help the problem setter](https://www.spoj.com/problems/HELP/)

## Problem Summary
Given the structure of a binary search tree with nodes labelled `1..n`,
produce integer access frequencies for each node so that the provided tree is
the unique optimal binary search tree.
Each of the next `n` lines lists the left and right child of node `i` (`-1` for
an empty subtree). The input ends with a single `0`.

## Algorithm
1. Read the tree and determine the root (the one that never appears as a child).
2. Perform a depth-first search to compute the size of every node's subtree.
3. For each node, output the frequency `2^(size - 1)` where `size` is its
   subtree size. In any subtree this frequency is greater than the total
   frequency of all other nodes in that subtree, so choosing a different root
   would yield higher expected search cost.
4. Print the frequencies for nodes `1..n` separated by spaces.

The largest frequency is `2^(n-1)` (for the overall root), which is well below
`2^63`, meeting the problem's limit. Each test case is processed in `O(n)` time.
