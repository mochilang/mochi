# [Equatorial Bonfire](https://www.spoj.com/problems/BONFIRE/)

## Problem Summary
We are given up to 10 proposals for a millennial equatorial bonfire. For each proposal a speed `v` (degrees per hour) and `N ≤ 5000` bonfires are given. Each bonfire ignites at time `t_i` (hours after midnight) at longitude `p_i` in `(-180, 180]`. Fire from a bonfire spreads in both directions along the equator at speed `v`. For every proposal we must determine the time and longitude of the last point to catch fire. If several points burn last, choose the one encountered first when travelling east from the zero meridian.

## Algorithm
1. **Normalize and sort.** Map each longitude to `[0,360)` and sort bonfires by longitude.
2. **Duplicate for circularity.** Append a copy of each bonfire at longitude `p_i + 360` to handle wrap‑around.
3. **Forward sweep.** On the doubled list compute `L[i]`, the earliest time position `i` can burn from the left, with `L[i] = min(t_i, L[i-1] + dist/v)`.
4. **Backward sweep.** Compute `R[i]` similarly from right to left, giving earliest burn times from the right.
5. **Evaluate intervals.** For each original interval `i` between `p_i` and `p_{i+1}` (using the appended first bonfire for the last interval), let `lt = min(L[i], R[i])` and `rt = min(L[i+1], R[i+1])`. The last point in the interval occurs where the two fronts meet: `lt + d/v = rt + (len-d)/v`. Clamp this meeting point inside the interval if necessary. Record its time; update the answer if this time is larger, breaking ties by the smallest angle modulo 360.
6. **Output.** Convert the winning angle back to `[-180,180]` and print time and longitude with three decimal places.

## Correctness
- The forward sweep ensures `L[i]` is the earliest possible time the fire can reach position `i` from any bonfire at or to its left; similarly `R[i]` handles sources to the right. Because fire travels only along the equator, any route to position `i` must come through one of its adjacent stored positions.
- Any point on the circle lies within some interval bounded by two consecutive bonfires. Its earliest burn time is the minimum of the times coming from the left or right boundary plus travel time across the remaining distance. No other bonfire can reach it earlier without passing through one of these boundaries.
- The last point overall must therefore be the maximum of the times computed for these intervals. If several points achieve the same time, selecting the smallest angle eastward matches the problem's tie-breaking rule.

Thus, the algorithm correctly finds the time and location of the last place to catch fire for each proposal.

## Complexity Analysis
Insertion sort of `N` bonfires costs `O(N^2)` time. The forward and backward sweeps and interval evaluation each run in `O(N)` time and require `O(N)` additional space. Therefore the total complexity per proposal is `O(N^2)` with `O(N)` memory.
