# [Halloween treats](https://www.spoj.com/problems/HALLOW/)

## Problem Summary
Given `c` children and `n` neighbours, each neighbour `i` gives `a_i` sweets. Choose some neighbours so that the total sweets can be evenly divided among the children and each child receives at least one sweet. Output the indices of neighbours to visit or `no sweets` if it's impossible. Multiple test cases are given, terminated by `0 0`.

## Algorithm
We search for a contiguous range of neighbours whose sum of sweets is divisible by `c`.

1. Maintain an array `first` of length `c` initialized to `-1`. `first[r]` holds the earliest index where the prefix sum modulo `c` equals `r`. Set `first[0] = 0` to represent the empty prefix.
2. Iterate through neighbours, updating a running sum modulo `c`.
3. If the current remainder `s` has been seen before at index `first[s]`, the subsequence between `first[s]+1` and current index has total sweets divisible by `c`. Output all indices in this range.
4. Otherwise record the current index for remainder `s`.
5. If no remainder repeats, output `no sweets` (though with `n â‰¥ c` and positive sweets a valid range always exists).

This runs in `O(n)` time and `O(c)` additional space per test case.
