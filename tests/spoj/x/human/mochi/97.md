# [Party Schedule](https://www.spoj.com/problems/PARTY/)

## Problem Summary
Given a party budget `B` and `n` parties, each with an entrance fee and a fun value, choose a subset of parties that maximizes fun without exceeding the budget. If several subsets yield the same maximum fun, spend the smallest total fee among them. Multiple test cases end with `0 0`.

## Algorithm
1. Use **0/1 knapsack DP** where `dp[c]` stores the maximum fun attainable with total cost `c`.
2. Initialize `dp[0..B]` with zeros.
3. For each party `(cost, fun)` update the array from `B` down to `cost`:
   - `dp[c] = max(dp[c], dp[c - cost] + fun)`.
4. After processing all parties, scan `dp` from cost `0` upward to find the maximum fun and the smallest cost that achieves it.
5. Output this minimum cost and the corresponding maximum fun.

The DP runs in `O(B * n)` time and uses `O(B)` extra space.
