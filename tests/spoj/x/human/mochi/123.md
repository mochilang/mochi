# [Paying in Byteland](https://www.spoj.com/problems/PAYING/)

## Problem Summary
Given up to 50 test cases, each contains a nonâ€‘negative integer `n` (up to $10^{1000}$).
We have unlimited coins of values $2^0,2^1,2^2,\ldots$. A multiset of coins is **perfect** if every amount
from `0` to the total sum can be formed using some of them. For each `n`, find the minimal number of coins in
a perfect representation of `n`.

## Algorithm
1. Examine the binary representation of `n` by repeatedly dividing by `2`.
2. Count the number of `1` bits (`pop`). Track the first position of a `0` bit (`firstZero`) while scanning from least to most significant bit.
3. Let `high` be the index of the highest bit encountered. If a zero bit exists, extra coins are needed to fill the gap:
   `extra = high - firstZero`; otherwise `extra = 0`.
4. The minimal coins required are `pop + extra`.

Each test case processes the bits of `n`, giving `O(log n)` time complexity with big integer arithmetic.
