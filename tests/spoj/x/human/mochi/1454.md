# [Memory Distribution](https://www.spoj.com/problems/MEMDIS/)

## Problem Summary
Given `N` contiguous memory cells, each program arrives at time `X`,
requests `M` consecutive cells and runs for `P` time units. If a large
enough free block exists it is allocated with the smallest starting
address. Otherwise the program is queued. Whenever memory is freed the
head of the queue is tried first. Only after the queue is empty may new
arrivals be allocated. For each test case we must output the time when
all programs finish and the number of programs that were ever queued.

## Algorithm
- Maintain the free memory as a list of segments sorted by starting
  address.
- Use a min-heap of running programs keyed by their finish time.
- Keep a FIFO queue of waiting programs and count how many times a
  program is enqueued.
- Before each program arrival at time `X`, pop all running programs that
  finish by `X`, freeing their segments and merging adjacent free pieces.
  After each free operation, repeatedly allocate programs from the queue
  whenever the head fits into some free segment.
- After processing the arrivals, continue advancing time to the next
  completion, again freeing memory and trying to run queued programs,
  until both the running heap and waiting queue are empty.

Allocation always selects the first fitting free segment, merging is
performed during deallocation, and the running time of each program is
`O((n + q) log n)` where `n` is the number of programs and `q` the number
of times a program enters the queue.
