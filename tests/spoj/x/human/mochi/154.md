# [Sweet and Sour Rock](https://www.spoj.com/problems/ROCK/)

## Problem Summary
Given a stick of rock represented by a binary string where `1` denotes a sweet
segment and `0` a sour one, break the stick into pieces. A piece can be sold only if it contains more sweet segments than sour segments. For each test case, find the maximum total length of sellable pieces.

## Algorithm
1. Treat `1` as `+1` and `0` as `-1` and build prefix sums `pref[i]` of these values.
2. Use dynamic programming over positions `i` in the string:
   - `dp[i]` – maximum sellable length considering the first `i` segments.
   - For every pair `i < j`, if `pref[j] - pref[i] > 0` then the segment `i..j-1` has more sweet segments, so update `dp[j] = max(dp[j], dp[i] + (j - i))`.
   - After processing `i`, propagate `dp[i+1] = max(dp[i+1], dp[i])` to allow skipping a starting point.
3. The answer is `dp[n]` where `n` is the length of the string.

This DP checks `O(n^2)` segments with constant work each. With `n ≤ 200`, it runs comfortably fast and uses `O(n)` additional space.
