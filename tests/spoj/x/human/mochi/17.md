# [The Bytelandian Cryptographer (Act I)](https://www.spoj.com/problems/CRYPTO1/)

Given a number `r = t^2 mod 4000000007` where `t` is the number of seconds
since the Unix epoch, recover the original timestamp (1970–2030 range) and
print it using the standard 26‑character format (`Sun Jun 13 16:20:39 2004`).

## Algorithm

1. Let `p = 4000000007`. For prime `p ≡ 3 (mod 4)` the square root of `r`
   modulo `p` is `s = r^((p+1)/4) mod p`. Compute it with fast modular
   exponentiation.
2. The timestamp is the smaller value between `s` and `p - s` (the other root
   exceeds the possible range < 2·10⁹ seconds).
3. Convert the seconds to a calendar date:
   - Split into days and seconds within the day.
   - Iterate years from 1970 accounting for leap years until the remaining
     days fit in the current year.
   - Iterate months to obtain month and day.
   - The day of week is `(totalDays + 4) mod 7` because 1970‑01‑01 was a
     Thursday.
   - Format using month/day names and zero padding.

## Correctness

- Step 1 yields a square root of `r` modulo `p`. Because `p` is prime and
  greater than any valid timestamp, the true `t` must be congruent to one of
  `±s` modulo `p`.
- The range of timestamps (< 2·10⁹) is less than `p/2`, therefore only one of
  `s` or `p - s` is within the range. Picking the smaller one recovers the
  original `t`.
- The conversion in step 3 uses standard Gregorian calendar rules, so it
  yields the correct year, month, day, time and weekday for any `t` between
  1970 and 2030.

## Complexity

Let `k = log₂ p`. Modular exponentiation runs in `O(k)` time and the calendar
conversion loops over at most 60 years and 12 months, so the overall time is
`O(k)` with constant space.
