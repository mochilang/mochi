# [The Secret of an Aerolite](https://www.spoj.com/problems/AEROLITE/)

## Problem Summary
Given counts of `L1` curly pairs `{}`, `L2` square pairs `[]`, and `L3` parenthesis pairs `()` along with a required depth `D`, count the number of valid strings (REs) built using these pairs under nested restrictions:
- `()` cannot contain `[]` or `{}` inside.
- `[]` cannot contain `{}` but may contain `()` and `[]`.
- `{}` may contain any bracket type.
The depth of an expression increases by one for each enclosing pair, and concatenation takes the maximum depth. Compute the number of REs with **exactly** depth `D` modulo 11380.

## Algorithm
1. Use dynamic programming with memoization for three helper functions counting expressions with depth at most `d`:
   - `H(p,d)` – only parentheses allowed.
   - `G(b,p,d)` – no curly braces, so only `[]` and `()`.
   - `F(c,b,p,d)` – all three bracket types.
2. For each function, consider the first pair type and partition remaining pairs between the inside and the suffix:
   - The inside uses depth `d-1`, the remainder uses depth `d`.
   - Sum all combinations of pair splits, multiplying counts of inside and remainder.
3. Memoize results for all `(l1,l2,l3,d)` states to avoid recomputation.
4. The final answer for depth `D` is `F(L1,L2,L3,D) - F(L1,L2,L3,D-1)` modulo 11380.

This DP explores at most `11×11×11×31` states and partitions each state over small counts, so it runs comfortably within limits.
