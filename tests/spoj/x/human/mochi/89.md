# [Hang or not to hang](https://www.spoj.com/problems/HANGLET/)

## Problem Summary
Given a nondeterministic program with up to 16 instructions and 32 one-bit registers, determine the minimum number of instruction cycles needed for the program to reach a `STOP` instruction. Registers may initially contain any values and `RANDOM` instructions can assign either 0 or 1. If no sequence of choices leads to termination, output `HANGS`.

## Algorithm
1. Parse the program into operation and operand arrays.
2. Perform a breadth‑first search over states consisting of
   - program counter,
   - register values (array of 32 entries: `-1` unknown, `0`, or `1`),
   - elapsed time.
3. The initial state sets the program counter to 0 and all registers to unknown.
4. For each instruction:
   - For deterministic assignments (`AND`, `OR`, `XOR`, `NOT`, `MOV`, `SET`) enumerate possible operand values consistent with the current state and enqueue resulting states with updated registers.
   - For `RANDOM`, enqueue states for both 0 and 1.
   - `JMP` and `JZ` update the program counter; `JZ` also branches on whether the tested register is 0 or 1.
5. Each time we visit a state, generate a unique key from the program counter and register array to avoid revisiting.
6. When a `STOP` instruction is dequeued, return the time + 1 (every instruction, including `STOP`, costs one cycle).
7. If BFS exhausts without reaching `STOP`, the program cannot halt.

The BFS explores all feasible assignments while tracking correlations between registers, ensuring the first time `STOP` is encountered is the shortest possible runtime.

## Complexity
Let `k` be the number of registers whose values affect control flow. In the worst case the BFS may explore up to `O(2^k * n)` states, but with `n ≤ 16` and `k ≤ 32` this remains manageable for the problem constraints.
