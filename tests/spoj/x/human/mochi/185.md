# SPOJ CHASE1 - Chase

We are given a triangle-free connected graph. Player A (runner) moves first in each turn and can stay in place or move to an adjacent vertex. Then player B (chaser) moves similarly. If at any moment both players stand on the same vertex, B has caught A. For each test case we must decide whether B has a strategy to guarantee capture and, if so, the minimal number of turns required assuming optimal play.

This is a two-player perfect information game.  We consider states defined by the pair of positions and whose turn it is.  From a state where it is A's move, A may move to any adjacent vertex or remain; from a state where it is B's move, B may move or remain likewise.  Captured states (both pieces on the same vertex) are terminal.

The state space contains at most `2 * n * n` states.  We use retrograde BFS (similar to solving the "cat and mouse" game) to propagate winning information from terminal states backwards:

- For every vertex `v`, states `(v,v,turn)` are wins for B with distance `0`.
- When processing a winning state where it is A's turn, any predecessor B-move that can reach it is also winning for B (B chooses such a move).
- When processing a winning state where it is B's turn, we decrement the remaining degree of each predecessor A-move.  If all moves from a predecessor lead to B wins, then that A-turn state is also winning for B.

Distances are increased by one while propagating to predecessors, giving the number of moves until capture for those states.  Finally, the starting state `(a,b, A-turn)` is checked.  If it was not marked winning, player B cannot force a capture.  Otherwise the stored distance is converted to turns `(moves + 1) / 2`.

The graph sizes in the problem constraints allow this `O(n^2)` state exploration.
