# Algorithm for SPOJ ONEZERO

For each test case with integer `n`, we need the smallest positive multiple of `n`
that is composed only of digits `0` and `1` (and begins with `1`).

## Approach

We perform a breadth‑first search over remainders modulo `n`.
The search starts with the remainder of the number `1` (`1 % n`).
For each remainder `r` dequeued from the queue we generate two new numbers by
appending digits `0` and `1`:

* `r0 = (r * 10) % n`
* `r1 = (r * 10 + 1) % n`

If a remainder has not been visited we record its parent remainder and the digit
used to reach it, then enqueue it. When remainder `0` is reached, we reconstruct
the answer by backtracking through the parent links and digits.

Using BFS guarantees that the first time we see remainder `0` we have the
shortest (and lexicographically smallest) sequence of digits, which is the
required number.

The search uses at most `n` states because there are only `n` possible
remainders, satisfying the constraint `n ≤ 20000`.
