# [Huge Knap Sack](https://www.spoj.com/problems/HKNAP/)

## Problem Summary
For each test case we have `N` types of golden statues with weight `W[i]` and volume `V[i]` (unlimited supply). We own `S` sacks, each of capacity `Y`. Any number of sacks may be stitched together into a larger sack, paying `C` gold for each stitching (i.e. a sack formed by `k` original sacks costs `(k-1)*C`).
Determine the maximum total gold weight we can take home after paying stitching costs.

## Algorithm
1. Let `M` be the maximum statue volume and find the statue with the best weight/volume ratio `(Wbest,Vbest)`.
2. Precompute `dp[v]` – the maximum achievable weight for volume `v` – using an unbounded knapsack for `v` up to `M*M + M`.  With small `M (≤18)` this table is tiny.
3. For any larger capacity `cap` we can fill it mostly with the best‑ratio statue.  If `cap > limit = M*M + M`,
   - remove `k = ceil((cap - limit)/Vbest)` copies of the best statue,
   - the remainder `r = cap - k*Vbest` is at most `limit`,
   - return `k*Wbest + dp[r]`.
   This yields the optimal weight for any capacity.
4. For each possible stitched sack size `k (1…S)` compute its gain
   `gain[k] = bestWeight(k*Y) - (k-1)*C`.
5. Dynamic programming over the number of sacks: `best[0]=0`. For `s=1…S`
   - start with `best[s-1]` (skip sack `s`),
   - for each `k ≤ s` update `best[s] = max(best[s], best[s-k] + gain[k])`.
6. Output `best[S]`.

## Complexity
Time complexity is `O(N*M^2 + S^2)` (`M ≤ 18`), and space complexity is `O(M^2 + S)`.
