# SPOJ 1678 - Royal Treasury

Given a hierarchy tree of clerks, we must form disjoint pairs between a clerk and one of their direct subordinates.
The goal is to maximize the number of such pairs and count how many different optimal pairings exist.

We treat the office structure as a rooted tree (root at clerk 1). Each edge can be used at most once in a matching.
This is the classic maximum matching problem on a tree, solvable with dynamic programming.

For each node `u`, compute two states:

- `dp0[u]`: best result when `u` is not paired with any child.
- `dp1[u]`: best result when `u` is paired with exactly one child.

Each state stores `(pairs, ways)` where `pairs` is the number of pairs in the subtree and `ways` is a `bigint`
counting distinct optimal configurations.

For `dp0[u]`, every child `v` can independently choose its best state. The total pairs is the sum of children's best `pairs`,
and the total ways is the product of the chosen counts (summing counts when child states tie).

For `dp1[u]`, choose one child `v` to pair with `u`. `v` must use `dp0[v]`. Other children still contribute their best states.
We evaluate each child as the partner and select the maximum `pairs`, summing the `ways` for ties.

Finally, the answer for the tree is the better of `dp0[1]` and `dp1[1]`.
The algorithm runs in `O(N)` time for the tree of up to 1000 nodes.
