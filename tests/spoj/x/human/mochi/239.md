# BTOUR - Tour de Byteland

[SPOJ problem](https://www.spoj.com/problems/BTOUR/)

## Algorithm

1. For every undirected edge `(u, v, w)` consider cycles that contain it.
2. Run Dijkstra from `u` on the graph with this edge removed to get shortest distances `dist`.
3. If `v` is unreachable, no cycle uses this edge.
4. Build a DAG of all edges that lie on shortest paths from `u` by orienting each edge `a–b` from the closer vertex to the farther one when `dist[a] + w = dist[b]`.
5. Perform dynamic programming on the DAG to count shortest paths from `u` to `v` grouped by number of edges.
6. For each path using `k` edges, the cycle length is `dist[v] + w` and it contains `k + 1` edges.
7. Track the minimum cycle length and accumulate counts for each cycle size. After processing all edges, divide the counts for size `E` by `E` because every cycle is discovered once per edge it contains.

## Correctness

- Removing the tested edge and finding a shortest path between its endpoints guarantees every obtained cycle is simple and includes that edge exactly once.
- Orienting edges by distance yields a DAG containing precisely the edges of all shortest paths from `u`; DP over this DAG counts each shortest path without duplication.
- Each simple cycle is counted once for each of its edges. Dividing the accumulated counts by the number of edges therefore gives the number of distinct cycles of minimal length.

## Complexity

Let `n` be the number of intersections and `m` the number of streets (`m ≤ 2n`). For each of the `m` edges we run Dijkstra in `O(m log n)` time and a linear DAG DP in `O(m + n)`. The overall complexity is `O(m^2 log n)` with `O(n + m)` memory.
