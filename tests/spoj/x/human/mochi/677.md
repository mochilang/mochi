# [A place for the brewery](https://www.spoj.com/problems/BROW)

## Problem Summary
Given an island with `n` coastal cities connected by a circular highway, each city `i` demands `z_i` tanks of beer per day and the distance to the next city clockwise is `d_i`. The brewery must be built in one of the cities. The cost of serving a city equals its demand multiplied by the shorter highway distance from the brewery. Determine the city which minimizes the total daily cost.

## Algorithm
1. Compute prefix positions `pos[i]` along the circle where `pos[0] = 0` and `pos[i+1] = pos[i] + d_i`. Let `L = pos[n]` be the total circumference.
2. Duplicate the arrays of positions and demands to length `2n` to handle wrap-around.
3. Build prefix sums of weights `prefW` and weighted positions `prefWP` over the duplicated arrays.
4. For each city `i` (0 ≤ i < n), move a pointer `j` clockwise while `pos[j] - pos[i] ≤ L/2`. Cities in `(i, j]` are reached clockwise; the others are served counter-clockwise.
5. Using the prefix sums compute in O(1):
   - Clockwise cost from `(i, j]`.
   - Counter-clockwise cost from `(j, i+n)`.
   The second cost uses `L - distance` for each city.
6. Track the minimum total cost over all `i`.

This two-pointer sweep runs in `O(n)` time and uses `O(n)` memory.
