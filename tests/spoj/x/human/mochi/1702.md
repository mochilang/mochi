# [Cleaning Robot](https://www.spoj.com/problems/CLEANRBT/)

## Problem Summary
A rectangular room of at most 20 × 20 tiles contains empty cells (`.`), obstacles (`x`), dirty tiles (`*`) and one robot (`o`).
The robot may move north, south, east or west to adjacent tiles avoiding obstacles.  Visiting a dirty tile cleans it and the robot
may revisit tiles. For each map, determine the minimum number of moves required to clean all dirty tiles, or report `-1` if any
dirty tile cannot be reached.

## Algorithm
1. Collect the coordinates of the robot and all dirty tiles (there are at most 10).
2. For each of these positions run a BFS on the grid to compute the shortest distance to every other cell.
   The pairwise distances between the robot and dirty tiles are recorded.  If a dirty tile is unreachable the answer is `-1`.
3. With `n` dirty tiles, run a bitmask dynamic programming (Travelling Salesman) over the distance matrix:
   - `dp[mask][i]` is the minimum cost to start from the robot, visit tiles in `mask` and end at dirty tile `i`.
   - Initialise `dp[1<<i][i] = dist(robot, dirty[i])`.
   - For each state, try to extend to an unvisited tile `j`: `dp[mask|1<<j][j] = min(dp[mask|1<<j][j], dp[mask][i] + dist(i,j))`.
   - The result is `min_i dp[(1<<n)-1][i]`.

This approach runs in `O((n+1)·w·h + n·2^n)` time, which is fast for `n ≤ 10` and `w,h ≤ 20`.
