# PT07F - A short vacation in Disneyland

[Problem link](https://www.spoj.com/problems/PT07F/)

## Algorithm

We are given a tree with `N` vertices. A route is a simple path; we want to cover all
vertices with a minimum number of vertex-disjoint routes.

The task is equivalent to choosing a maximum number of edges so that the remaining
subgraph is a forest where every vertex has degree at most two. Each connected
component of such a forest is a path. If we keep `E` edges the number of routes is
`N - E`.

Dynamic programming over the rooted tree solves the problem.
For every vertex `v` we maintain two values:

* `dp0[v]` – maximum number of edges we can keep in the subtree of `v` when the edge
  from `v` to its parent is **not** kept.
* `dp1[v]` – same but when the edge to the parent **is** kept.

Let `child` range over the children of `v`.
The base contribution is the sum of `dp0[child]` for all children.  Each child can
optionally be connected to `v`, which yields an additional edge and forces the child
into state `dp1`.

*For state `dp1`* we may connect at most one child (otherwise degree would exceed two).
Hence `dp1[v]` is the base plus the best positive gain among children.

*For state `dp0`* we may connect at most two children.  We take the two children with
largest positive gains.  Gains are `1 + dp1[child] - dp0[child]`.

During the DP we also record which children are chosen in each state.  A second DFS
reconstructs the set of kept edges.  Finally we traverse the resulting forest and output
all paths by starting at every vertex of degree ≤ 1 and walking until the end of the path.

The complexity is `O(N)`.

## Correctness Proof

We prove that the algorithm outputs a minimum number of routes that cover all vertices.

### Lemma 1
For every vertex `v`, `dp0[v]` (respectively `dp1[v]`) equals the maximum number of
edges we can keep inside the subtree of `v` under the stated constraint with (without)
connecting `v` to its parent.

*Proof.* The recursion considers all children independently.  For each child we either
connect it to `v` (consuming one of the available slots at `v`) or keep it separate.
The gains used in the transitions are exactly the benefits of connecting a child.
Because we try all allowed combinations (up to one child in state `1` and up to two in
state `0`), the values are optimal.  □

### Lemma 2
Let `E` be the number of edges kept after reconstruction.  The produced forest is a set
of vertex-disjoint paths containing all vertices.

*Proof.*  By Lemma&nbsp;1, during reconstruction we keep exactly the edges whose choices were
recorded in the optimal DP.  For every vertex we connect to at most two neighbours,
therefore degrees are at most two.  The graph is still acyclic because it is a subgraph
of the tree, so each connected component is a path.  Every vertex appears in exactly one
component.  □

### Lemma 3
The number of routes output by the algorithm equals `N - E` and is minimal.

*Proof.*  Each connected component of the final forest with `k` vertices has exactly
`k-1` kept edges and represents one route.  Summing over all components gives `E = N - K`
where `K` is the number of routes.  Since the DP maximizes `E`, it minimizes `K`.
Any solution with more kept edges would contradict Lemma&nbsp;1.  □

### Theorem
The algorithm outputs a collection of routes that visit every vertex exactly once and
uses the minimum possible number of routes.

*Proof.*  By Lemma&nbsp;2 the output is a valid collection of routes.  By Lemma&nbsp;3 their
number is minimal.  Hence the algorithm is correct.  □

## Complexity Analysis

For each vertex we process its children once; all operations are constant time per edge.
Thus the running time is `O(N)` and the memory usage is also `O(N)`.

## Reference Implementation

See [1482.mochi](../../human/x/mochi/1482.mochi) for the complete implementation.
