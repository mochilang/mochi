# [Permutations](https://www.spoj.com/problems/PERMUT1/)

## Problem Summary
Given integers n (1 ≤ n ≤ 12) and k (0 ≤ k ≤ 98), count how many permutations of 1..n contain exactly k inversions. An inversion is a pair of indices (i, j) with i < j and a_i > a_j. The input begins with the number of test cases followed by the pairs n and k; output the count for each pair.

## Algorithm
Use dynamic programming. Let dp[i][j] be the number of permutations of length i with j inversions. The recurrence inserts element i into a permutation of length i-1:

dp[0][0] = 1
for i = 1..12:
    for j = 0..98:
        dp[i][j] = sum_{t=0}^{min(j, i-1)} dp[i-1][j-t]

The term t counts how many inversions are created when placing i among the previous i-1 elements. After precomputing dp, each query (n, k) is answered by outputting dp[n][k].

This approach runs in O(n * k * n) time for precomputation (~14k operations) and answers each query in O(1) time using O(n * k) space.
