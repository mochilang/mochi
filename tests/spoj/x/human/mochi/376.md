# ACS - A concrete simulation

[SPOJ problem](https://www.spoj.com/problems/ACS/)

## Algorithm

1. Initialize two arrays `row` (size 1235) and `col` (size 5679) that map the current row/column index to the original one. Also keep
   inverse arrays `rpos` and `cpos` mapping original indices to their current positions.
2. For command `R x y` swap `row[x]` with `row[y]` and update `rpos` for the swapped rows. Similarly handle command `C x y` for
   columns using `col` and `cpos`.
3. For query `Q x y` the matrix value is `(row[x]-1) * 5678 + col[y]` because row/column numbers are 1-based and the matrix is
   filled in row-major order.
4. For query `W z` compute the original row `r = (z-1) / 5678 + 1` and column `c = (z-1) % 5678 + 1`. The current position is
   `x = rpos[r]` and `y = cpos[c]`.
5. Process commands until EOF, printing results for `Q` and `W` queries.

## Correctness

- `row` and `col` always represent the original row and column indices for every current position. Swapping updates these arrays
  and their inverses, so they stay consistent.
- For `Q x y`, the computed value uses the original indices of the row and column at that position, matching how the matrix was
  initially filled. Thus the printed number equals the current value at `(x, y)`.
- For `W z`, reversing the row-major formula recovers the original indices of the element `z`, and the inverse arrays give its
  current location. Therefore the output coordinates `(x, y)` satisfy `M(x, y) = z`.

## Complexity

Let `m` be the number of commands. Each command performs only a constant amount of work on the arrays. Hence the time
complexity is `O(m)` and the memory usage is `O(1234 + 5678)` for the four mapping arrays.
