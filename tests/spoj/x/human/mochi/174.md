# PAINTTMP - Paint templates

[SPOJ problem](https://www.spoj.com/problems/PAINTTMP/)

## Algorithm

1. A matrix of size `n` has size `2^n` by `2^n`. A cell contains a hole if and only if at each bit position at least one of the
   row or column bits is `1`, i.e. `row OR col = 2^n-1`.
2. After shifting the second matrix by `(x, y)`, we look for positions `(i, j)` such that both matrices have holes at
   `(i, j)` and `(i + y, j - x)`. Only cells with `0 \le i < 2^n - y` and `x \le j < 2^n` can overlap.
3. The conditions reduce to `i | j = mask` and `(i + y) | (j - x) = mask` where `mask = 2^n - 1`.
4. Iterate over the `n` bit positions from least significant to most significant with dynamic programming.
   - State: bit index, carry from adding `y`, borrow from subtracting `x`.
   - For each state, try all non-zero pairs of bits `(bi, bj)` for `(i, j)`.
   - Compute the resulting bits of `i + y` and `j - x` with the current carry/borrow.
   - Only keep transitions where the resulting bits are not both zero.
5. The DP counts ways using arbitrary precision integers. The answer is the number of valid states after processing all bits
   with zero carry and zero borrow.

## Correctness

- **Hole characterization**: The construction guarantees that a cell is a hole iff its row and column contain no bit position
  with both bits `0`. Thus `row OR col` must equal `2^n - 1`.
- **Shifted overlap**: The overlap requires both `(i, j)` and `(i + y, j - x)` to be holes. Using the above characterization,
  the conditions become `i|j = mask` and `(i+y)|(j-x) = mask`.
- **DP transitions**: At each bit we enumerate allowed bit pairs `(bi, bj)` (excluding `(0,0)`), update carry/borrow for
  `i + y` and `j - x`, and ensure resulting bits are not `(0,0)`. This mirrors the hole condition for the shifted matrix at
  each bit.
- **Final state**: Only states with zero carry and zero borrow correspond to positions within the valid intersection region.
  Counting all such states gives the number of stains.

## Complexity

Let `n` be the matrix size parameter. The DP processes `n` bits with a constant number of states (4 combinations of carry and
borrow) and constant transitions, giving a time complexity of `O(n)`. Memory usage is `O(1)` besides the bit arrays.
