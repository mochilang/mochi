# Mobiles - MOBILE2

Given a binary tree of rods where each node has two children (either another rod or a toy),
we may swap the left and right subtrees of any node. Each swap costs one.
Ike likes mobiles where all toys are at depth `d` or `d+1`, and toys on the left are never
higher than toys on the right. This means that, when listing toys from left to right, their
depths form a non-increasing sequence whose maximum and minimum differ by at most one.

## Algorithm
1. Build arrays `L` and `R` storing the left and right children for each rod.
2. Depth–first search from the root to determine the minimum and maximum depth of any toy.
   If these depths differ by more than one, the mobile can never satisfy Ike and we output `-1`.
3. Label each toy by whether its depth equals the maximum depth (`deep`) or the minimum depth
   (`shallow`).
4. Bottom‑up recursion computes for every rod:
   - the number of deep and shallow toys in its subtree;
   - the minimal swaps needed to arrange the toys inside the subtree so that all deep toys
     appear before shallow ones.
   Swapping a rod’s children reverses the order of its two subtrees and costs one.
   Combining two ordered subtrees is valid only if the left subtree contains no shallow toy
   when the right subtree contains a deep toy (and vice versa for the swapped case).
5. The result for the root is the minimal number of swaps; if no orientation satisfies the
   condition, return `-1`.

The traversal touches each rod once, giving `O(n)` time and `O(n)` memory.
