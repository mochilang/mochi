# [Partial Sums](https://www.spoj.com/problems/PARTSUM/)

## Problem Summary
Given a sequence of `N` positive integers and two integers `K` and `P`,
consider every partial sum `a_i + ... + a_j` modulo `P`.
Output the smallest value of these sums that is at least `K`.
`N` is up to 100000.

## Algorithm
1. Compute prefix sums modulo `P`: `pref[0] = 0` and
   `pref[i] = (pref[i-1] + a_i) mod P`.
2. Coordinate‑compress all prefix values so that we can index them.
3. Maintain a Fenwick tree over the sorted prefix values storing which
   values have appeared so far.
4. For each `pref[j]`:
   - **No wrap:** find the largest previous prefix value `x ≤ pref[j] - K`.
     Candidate value is `pref[j] - x`.
   - **Wrap around:** find the largest prefix value
     `x ≤ min(P-1, pref[j] + P - K)` and `x > pref[j]`.
     Candidate value is `P + pref[j] - x`.
   - Keep the minimal candidate ≥ `K`, then insert `pref[j]` into the tree.
5. Print the minimal candidate.

Each Fenwick tree operation runs in `O(log N)`, so the overall
complexity per test case is `O(N log N)`.
