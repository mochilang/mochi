# PPATH - Prime Path

Given two four-digit primes, we must transform the first into the second by
changing one digit at a time while keeping all intermediate numbers prime.  The
number of single-digit changes is the cost and we seek the minimal cost, or
report that it is impossible.

## Algorithm

1. **Prime generation.** Precompute all primes up to 9999 using the sieve of
   Eratosthenes.  This gives an `Array Bool` where index `n` indicates whether
   `n` is prime.
2. **Graph edges.** For a four-digit prime `p`, generate neighbours by replacing
   each digit with `0..9` (for the thousands digit, `1..9`) and keeping the
   number if it remains prime.  There are at most `4 * 9` neighbours.
3. **Breadth-first search.** For each query `(a, b)` perform BFS starting from
   `a`.  Use a queue of pairs `(number, distance)` and a boolean visited array.
   When `b` is dequeued, the distance is the minimal cost.
4. If the queue empties without reaching `b`, output `Impossible`.

The state space has at most 9000 four-digit primes, and each step inspects at
most 36 candidates, so the BFS easily fits within the limits.
