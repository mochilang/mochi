# [Anti-prime Sequences](https://www.spoj.com/problems/APRIME/)

## Problem Summary
Given integers `n` and `m` with `1 ≤ n < m ≤ 1000` and a degree `d`, we must
rearrange the consecutive numbers `n..m` into a sequence so that every
consecutive subsequence of length `2..d` has a composite sum.  If multiple
sequences exist we output the lexicographically first; otherwise we print
`"No anti-prime sequence exists."`

## Algorithm
1. Precompute a primality test using trial division.
2. Use backtracking to build the sequence incrementally in lexicographic order.
   - Maintain the current prefix (stored in reverse order) and a set of used
     numbers.
   - When trying to append a number `x`, check for each length `k = 2..d`
     whether the sum of the last `k` numbers including `x` is composite.
     If any such sum is prime, prune this branch.
   - Once all numbers are used, the reversed prefix is the desired sequence.
3. For each input triple `n m d` read until `0 0 0`, run the search and print
   the sequence joined by commas or the failure message.

This depth‑first search prunes aggressively thanks to the composite sum check,
allowing it to handle the problem limits.
