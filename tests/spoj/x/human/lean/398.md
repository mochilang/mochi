# Roll Playing Games

We are given several fully defined dice and must design one more die with a fixed
number of faces.  For a list of target sums we know how many different ways
(thinking of the dice faces as distinct) these sums must be achieved when rolling
all dice together.  Face values are integers between 1 and 50.  If multiple dice
satisfy the requirements, we must output the one with lexicographically smallest
(non-decreasing) face values.

## Algorithm

1. **Count ways for known dice.**  Using dynamic programming we convolve the
   distributions of all specified dice.  `ways[s]` stores how many ways the known
dice set can achieve sum `s`.
2. **Pre-compute contributions.**  For each possible value `v` (1‥50) and each
target sum `t`, the unknown die contributes `ways[t - v]` ways (0 when negative
or out of range).
3. **Backtracking search.**  We choose `r` face values in non-decreasing order.
   While building the die we keep remaining required counts for each target sum
   and try every possible value from the current minimum upwards.  A candidate is
   valid if its contribution does not exceed the remaining counts.  When all
   counts reach zero, we have a solution.
4. Because we try values in ascending order and enforce non-decreasing choices,
   the first solution found is the lexicographically smallest.

The dynamic programming runs in `O(n * maxSum * faces)` where `maxSum` is at most
`20 * 50 = 1000`.  The backtracking explores at most `C(50+r-1, r)` states with
`r ≤ 6`, which is manageable.
