# Solution

We have four lists `A`, `B`, `C` and `D` each with `n` integers. We need to count
quadruples `(a,b,c,d)` with `a+b+c+d = 0`.  A direct `O(n^4)` enumeration is too
slow.

Observe that `a+b = -(c+d)`.  We precompute all `n^2` values of `a+b` and store
for each sum its frequency in a hash map.  Then for each pair `(c,d)` we look up
`-(c+d)` in this map and accumulate the frequency.  The map operations are
constant on average, so the complexity is `O(n^2)` and the memory usage is also
`O(n^2)`.

In Lean we use `Std.HashMap Int Nat` to store the counts.  After reading the
input arrays we fill the map with all `A[i]+B[j]` sums, then iterate over all
`C[k]+D[l]` sums, adding to the answer the frequency of their negation.  The
final count is printed.
