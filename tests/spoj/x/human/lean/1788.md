# [Fractan](https://www.spoj.com/problems/FRACTAN/)

## Problem Summary
Given a starting integer `N` and a list of fractions `f1..fk`, define a sequence `S0 = N` and for each step pick the earliest fraction `fi` such that `Sj * fi` is an integer and set `Sj+1 = Sj * fi`. The process stops when no fraction applies. For each test case output the exponents of the first `m` powers of two that appear in this sequence.

## Algorithm
1. Read `m`, `N`, `k` and the `k` fractions (numerator and denominator pairs).
2. Initialize `current := N` and an empty list of exponents.
3. While fewer than `m` exponents collected:
   - If `current` is a power of two, append its exponent.
   - Scan the fractions in order to find the first `(num, den)` where `(current * num) % den = 0` and set `current := (current * num) / den`.
4. Output the collected exponents separated by spaces.

The constraints are small (`k ≤ 100`, `m ≤ 40`), so direct simulation with arbitrary-precision `Nat` is efficient.
