# [Making Jumps](https://www.spoj.com/problems/MKJUMPS/)

## Problem Summary
We are given several test cases describing irregular chessboards. Each case starts with a row count `n` (1 ≤ n ≤ 10). For each row `i` we read two integers: the number of skipped cells before the row starts and the number of consecutive cells present in that row. The knight begins on the first cell of the first row. Using standard knight moves it may traverse the board without visiting any square twice. For each case we must report how many of the valid squares are unreachable by the knight.

## Algorithm
1. Parse all integers from input and process cases until a leading `0` is encountered.
2. For each case, build a boolean board representation with up to `n` rows and 10 columns where `true` marks a valid square.
3. Perform a breadth‑first search from the starting cell using the eight knight moves. Enqueue neighbors that are valid squares and have not been visited yet.
4. Count the number of visited squares; the unreachable count is the total number of valid squares minus this value.
5. Print `Case k, X square(s) can not be reached.` using singular or plural accordingly.

## Correctness
The BFS explores the move graph defined by knight moves and the given board. A square is enqueued only if it is within the board and has not been visited previously, matching the requirement that the knight cannot rest on a square more than once. Therefore every reachable square is visited exactly once during BFS. The difference between total squares and visited squares equals the number of squares that cannot be reached.

## Complexity
Let `S` be the total number of valid squares (at most 100). BFS visits each square once and examines a constant number of moves. The time complexity is `O(S)` and the memory usage is also `O(S)`.
