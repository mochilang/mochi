# [Can you answer these queries I](https://www.spoj.com/problems/GSS1)

## Problem Summary
Given an array `A[1..N]` with `|A[i]| ≤ 15007` and `1 ≤ N ≤ 50000`, each query asks for the maximum subarray sum inside a subsegment `[x, y]`. For `M` such queries we must output one result per line.

## Algorithm
1. Build a segment tree.  Each node stores four values for its interval:
   - `sum`: total sum of the interval.
   - `pref`: maximum prefix sum.
   - `suff`: maximum suffix sum.
   - `best`: maximum subarray sum anywhere inside the interval.
2. For a leaf these values equal the element itself.
3. To combine two children `L` and `R`:
   - `sum = L.sum + R.sum`
   - `pref = max(L.pref, L.sum + R.pref)`
   - `suff = max(R.suff, R.sum + L.suff)`
   - `best = max(L.best, R.best, L.suff + R.pref)`
4. Answer each query `[x, y]` by recursively combining nodes that cover this range; the answer is the `best` field of the resulting node.

## Correctness
- The base case (leaf) clearly stores the correct sums for a single element.
- The combination step considers the best subarray entirely in the left, entirely in the right, or crossing the middle (`L.suff + R.pref`), so `best` is correct for the union interval.
- Prefix and suffix values ensure that when combining higher nodes the necessary cross-boundary sums are propagated.  By induction on the tree height, every node's fields correctly describe its interval.
- The query merges only nodes wholly inside `[x, y]`.  Therefore the final `best` equals the maximum subarray sum in that range.

## Complexity
Building the tree takes `O(N)` time and space.  Each query visits at most `O(log N)` nodes, yielding `O(M log N)` overall.
