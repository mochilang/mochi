# [Random Number](https://www.spoj.com/problems/RNUMBER/)

## Problem Summary
Given integers `M` and `N` with `1 ≤ N ≤ M ≤ 200`, consider all non‑decreasing
sequences `u(1)..u(N)` such that `p ≤ u(p) ≤ M` for every position `p`.  These
sequences are ordered lexicographically.  A binary fraction `0.b(1)...b(p)`
encodes an index `k` in `[1,T]`, where `T` is the total number of sequences,
using repeated bisection of that interval.  The task is to output the `k`‑th
sequence.

## Algorithm
1. **DP table.**  Let `dp[pos][prev]` be the number of valid sequences for
   positions `pos..N` assuming the previous value is `prev`.  Base case:
   `dp[N+1][v] = 1`.  For `pos` from `N` down to `1`, compute
   `dp[pos][prev] = Σ_{x=max(prev,pos)}^M dp[pos+1][x]` using a cumulative sum
   over `dp[pos+1]`.  The total number of sequences is `dp[1][0]`.
2. **Index selection.**  Starting with interval `[1, dp[1][0]]`, read the bits
   of the binary fraction.  Each bit performs a binary search step to narrow
   the interval and yields the target index `k`.
3. **Sequence construction.**  For each position `pos` from `1` to `N`, try
   values `v` from `max(prev,pos)` upward.  For each candidate, check how many
   sequences follow using `dp[pos+1][v]`.  Subtract counts until the index
   falls within one block; that `v` becomes `u(pos)` and we continue with the
   remaining positions.
4. **Output.**  Print the sequence numbers in fields of width `3`, placing at
   most `20` numbers per line.

The DP has `O(N·M)` states and uses big integers (`Nat`) to handle the large
counts required by the problem constraints.
