# [Paint templates](https://www.spoj.com/problems/PAINTTMP)

## Problem Summary
Given two identical fractal matrices of size `n`, each containing `3^n` holes arranged recursively, shift one matrix `x` columns right and `y` rows up and count the overlapping holes. A point `(x, y)` is a hole iff every binary position satisfies that the `y` bit is not `1` when the corresponding `x` bit is `0`.

## Algorithm
1. Observe that hole locations obey `y & ~x = 0` for `0 ≤ x, y < 2^n`.
2. When shifting the second matrix by `(x, y)`, a point contributes to the overlap when both `(x₁, y₁)` and `(x₁ + x, y₁ + y)` satisfy the above condition.
3. Run a dynamic program over the `n` binary positions from least to most significant bits, tracking carries for the additions of `x` and `y`.
4. For each step try the four possibilities for bits `x₁` and `y₁` with `y₁ ≤ x₁`; propagate carries, ensure the resulting bits also satisfy `y₂ ≤ x₂`, and accumulate counts for the next state.
5. The DP has only four carry states, so the complexity is `O(n)`.

This approach handles very large `n` (up to 100) and large shifts using arbitrary-precision integers.
