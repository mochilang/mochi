# TREASURY - Royal Treasury

We are given a rooted tree representing the hierarchy of clerks.  A valid arrangement is a matching: each pair connects a clerk with one of their direct subordinates and no clerk appears in more than one pair.  For each test case we must output the size of a maximum matching and the number of distinct matchings achieving that size.

## Algorithm

We run a depth‑first search with dynamic programming.  For every node `u` we compute two states:

* `state0` – the maximum number of pairs and the count of ways inside the subtree of `u` when `u` is free to choose any of its children (i.e. `u` is not matched with its parent).
* `state1` – the same but `u` is already matched with its parent and therefore cannot be paired with any child.

For each child we know its `state0` and `state1`.  We first compute the contribution when `u` remains unmatched:

```
baseSize = Σ max(child.state0.size, child.state1.size)
baseWays = Π ways chosen for the larger size
```

Then we try matching `u` with each child `w` individually:

```
size = 1 + w.state1.size + Σ_{v≠w} max(v.state0.size, v.state1.size)
ways = w.state1.ways * Π_{v≠w} ways chosen for the larger size
```

Among the base case and all candidates we keep the maximum size and sum the ways of every candidate achieving it.

`state1` is simpler: if `u` is matched with its parent, each child must act independently in state0.

Finally, the answer for the root (which has no parent) is its `state0`.

The tree contains at most 1000 nodes so the dynamic programming runs in `O(n)` time.
