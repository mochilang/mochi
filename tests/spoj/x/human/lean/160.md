# [Choosing a Palindromic Sequence](https://www.spoj.com/problems/PALSEC)

## Problem Summary
We are given two sequences of `n` words, `X` and `Y`. For each position `i` we may choose either `xi` or `yi`.
The task is to count how many choices produce a concatenated string that is a palindrome.

## Algorithm
We simulate building the palindrome from both ends simultaneously.
Let `l` and `r` be indices of the leftmost and rightmost positions that are
not fully processed yet. Additionally we keep offsets `i` and `j` inside the
currently chosen words on the left and right and flags `tL`/`tR` describing
which word (0 = none, 1 = X, 2 = Y) is used at those positions.  The recursive
procedure `dfs(l,i,tL,r,j,tR)` performs the following steps:

1. If `l > r` the whole string was processed; it is valid only when both
   partial words are finished.
2. If `l == r` we are in the middle of the string.  Either we choose a word
   here and check whether it is a palindrome, or if one side already chose a
   word, the other side must use the same word and we verify that the
   remaining substring is palindromic.
3. If no word is currently chosen on the left (resp. right) side, we branch by
   trying `X[l]` and `Y[l]` (resp. `X[r]` and `Y[r]`).
4. When both sides have words chosen, we compare the next characters.  If they
   match we advance the offsets; when a word is fully consumed we move the
   corresponding index inward and reset the flag.
5. Results of states are memoised in a hash map so each combination of
   parameters is computed only once.

This depth‑first search explores only consistent partial palindromes and
runs efficiently for `n ≤ 30` and word length up to 400.
