# Countdown (CDOWN)

Given a rooted family tree we receive queries asking who has the largest number of descendants that are exactly `d` generations away. For each test case we must print the top three people by this measure, breaking ties alphabetically and extending the list if the third position is tied. People with zero such descendants are ignored.

## Algorithm

1. Parse the tree description into a map `children : name → list of children`.
2. For every person in the map compute the number of descendants at depth `d` using a breadth‑first search:
   - start from the person at depth 0;
   - expand downwards until reaching depth `d`;
   - count nodes when the search depth equals `d`.
3. Collect all `(name, count)` pairs where `count > 0` and sort them primarily by descending `count` and secondarily by name.
4. Output the first three entries, but if the third entry is tied with following ones include all tied names.

The tree has at most 1000 nodes, so performing a BFS for each person is efficient (`O(n^2)` in the worst case).

## Correctness Argument

- Step 1 records the parent→children relationships exactly as given, forming the entire tree.
- The BFS in step 2 explores all descendants of a person. Because edges only go from parent to child and there are no cycles, each descendant at distance `d` is enqueued exactly once and counted when its depth equals `d`. Thus the count returned is precisely the number of descendants `d` generations away.
- Step 3 orders people according to the required criteria. Because all counts greater than zero are considered, the list contains exactly those who have descendants.
- Step 4 outputs the top three counts and all names tied with the third count, matching the problem statement.

Therefore the algorithm prints for each test case the people with the most descendants `d` generations away in the correct order.

## Complexity Analysis

Let `n` be the number of people. BFS from one node visits at most `n` nodes and edges. Repeating this for every person yields `O(n^2)` time. The additional sorting is `O(n log n)` but dominated by the BFS work. The memory usage is `O(n)` for the adjacency list and search queue.

## References

- [SPOJ Problem CDOWN](https://www.spoj.com/problems/CDOWN/)
