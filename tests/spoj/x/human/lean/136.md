# [Transformation](https://www.spoj.com/problems/TRANS)

## Problem Summary
Given two sequences `X` and `Y` of length `N` and `M` (with `M` ≥ `N`), and a set of replacement rules of the form `a -> b c` or `a -> b c d`, determine the minimum number of rule applications needed to transform `X` into `Y`. Each rule replaces one occurrence of `a` by a sequence of two or three numbers. If `Y` cannot be obtained, output `-1`.

## Algorithm
1. **Dynamic programming on substrings**
   * Let `dp[a][i][j]` be the minimum steps to derive `Y[i..j]` (inclusive) from a single symbol `a`.
   * Initialize `dp[a][i][i] = 0` when `a = Y[i]` and `∞` otherwise.
   * For increasing substring lengths, compute `dp[a][i][j]` using the replacement rules:
     - For each rule `a -> b c`, try all splits `i ≤ k < j` and update `dp[a][i][j]` with `dp[b][i][k] + dp[c][k+1][j] + 1`.
     - For each rule `a -> b c d`, try all `i ≤ k1 < k2 < j` and update with `dp[b][i][k1] + dp[c][k1+1][k2] + dp[d][k2+1][j] + 1`.
2. **Sequence assembly**
   * Using the precomputed `dp`, build `Y` from left to right for the symbols of `X`.
   * `cost[i]` = minimum steps to produce the first `i` symbols of `Y` from the processed prefix of `X`.
   * For each symbol `x` in `X`, try all possible end positions `j` such that `dp[x][i][j]` is finite and update `cost[j+1]`.
3. The answer is `cost[M]` if finite, otherwise `-1`.

The constraints (`M ≤ 50` and at most 30 distinct symbols) make the `O(30 * M^4)` DP feasible.
