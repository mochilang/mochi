# [PT07F - A Short Vacation in Disneyland](https://www.spoj.com/problems/PT07F/)

The park map is a tree with `N` vertices. We must partition the vertices into the
minimum number of vertex-disjoint paths (each path is a sequence of adjacent
vertices). The answer should also list one such optimal collection of paths.

## Algorithm

For a tree, a path decomposition can be viewed as selecting a subset of edges
such that every vertex has degree at most two. Each connected component of this
subgraph is a path. To minimise the number of paths we maximise the number of
selected edges. This is the *maximum 2-matching* problem on a tree.

We process the tree in two passes.

1. **Dynamic programming.** We compute two values for every vertex `v`:
   - `dp0[v]` – maximum number of edges that can be selected in the subtree of
     `v` when the edge to its parent is **not** used.
   - `dp1[v]` – same but when the edge to the parent **is** used. In this case
     `v` already has degree 1 so only one child edge may be selected.

   For each vertex we evaluate all children, compute the gain of connecting a
   child, and keep the best `2` gains for `dp0` (or the best `1` gain for `dp1`).
   This yields the maximum number of selectable edges.

2. **Reconstruction.** We traverse the tree again, choosing for every vertex the
   children that were used in the optimal solution. The chosen edges define a
   forest where every vertex has degree at most two.

3. **Extract paths.** We iterate over all vertices, starting a DFS from every
   vertex whose selected-degree is `≤ 1`. Following the chosen edges yields all
   paths of the optimal decomposition.

The number of paths equals `N - (#selected edges)`. The algorithm runs in
`O(N log N)` time because of sorting the child gains (with at most `N` edges).

## Correctness

* **Lemma 1.** For every vertex `v`, the dynamic programming values `dp0[v]` and
  `dp1[v]` equal the maximal number of selectable edges in the subtree of `v`
  under the stated conditions.

  *Proof.* Each child subtree is independent. If the edge `v–child` is chosen,
  one edge is added and the child must use its `dp1` state; otherwise the child
  uses its `dp0` state. Choosing more than `2` children would exceed the degree
  limit of `v` (or more than `1` when `v` is already connected to its parent).
  Thus keeping the best gains yields the optimal result.

* **Lemma 2.** The reconstruction phase chooses exactly the edges used in some
  optimal solution.

  *Proof.* At each vertex we select the same children that contributed positive
  gains to the DP values. Because the DP states are optimal, the reconstruction
  produces a maximal set of edges without violating degree constraints.

* **Lemma 3.** The selected edges form a disjoint union of paths covering all
  vertices.

  *Proof.* Every vertex has degree at most two by construction, hence each
  component of the selected subgraph is a path. Every vertex either appears in a
  selected edge or forms a single-vertex path.

* **Theorem.** The algorithm outputs a minimum path cover of the tree.

  *Proof.* The number of paths equals `N` minus the number of selected edges.
  The DP maximises the latter, therefore the number of paths is minimal.

## Complexity

Let `N` be the number of vertices (`N ≤ 10^4`). The DFS passes visit each edge a
constant number of times and sorting the child gains per vertex keeps the total
complexity `O(N log N)`. The memory usage is `O(N)`.
