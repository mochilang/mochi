# PT07J - Query on a tree III

We are given a rooted tree where each node has a unique label.  For a query `(x, k)`
we must find the index of the node whose label is the `k`‑th largest inside the
subtree of `x`.

## Algorithm

1. Perform an Euler tour of the tree to flatten every subtree to a contiguous
   segment `[tin[x], tout[x]]`.
2. Compress all node labels in **descending** order so the largest label has rank
   `1`.  Also remember which node owns each rank.
3. Build an array `arr` of ranks in Euler order and construct a **persistent
   segment tree** over these ranks.  `root[i]` stores the multiset of ranks in the
   prefix of length `i` of the Euler tour.
4. For a query `(x, k)` use the roots `root[tout[x]]` and `root[tin[x]-1]` to
   obtain the rank of the `k`‑th smallest element (which corresponds to the
   `k`‑th largest label) in the subtree.  Finally map this rank back to the node
   index.

The persistent tree provides `O(log n)` update and query time, so the whole
complexity is `O((n + m) log n)` with `O(n log n)` memory.
