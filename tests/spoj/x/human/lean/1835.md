# SETSTACK - The SetStack Computer

[Problem link](https://www.spoj.com/problems/SETSTACK/)

## Algorithm

The machine manipulates a stack whose elements are sets. Sets themselves can contain
other sets, so we represent each distinct set by an integer identifier.  A map is
used to assign identifiers: whenever a new set is created we look it up in the map;
if it exists we reuse its identifier, otherwise we insert it with the next id.
The actual elements of a set are stored as a sorted list of identifiers so that
two equal sets have an identical representation.

Operations are implemented as follows:

- **PUSH**: push the empty set `{}` onto the stack.
- **DUP**: duplicate the top identifier.
- **UNION/INTERSECT**: pop two identifiers `a` and `b`, compute union or
  intersection of their represented sets using merge on the sorted lists, obtain
  the identifier of the resulting set and push it.
- **ADD**: pop `a` and `b`, insert the identifier `a` into set `b` (while
  keeping the list sorted and unique) and push the identifier of the resulting
  set.

After each operation the size of the set on the top of the stack is printed.
A line containing `***` is printed after finishing each test case.

## Correctness

We prove by induction on the sequence of operations that the program outputs the
correct size after each step.

*Base*: before any operation the stack is empty. `PUSH` assigns the unique id for
`{}` and pushes it. Its representation is an empty list so the program outputs `0`,
which is the size of the empty set.

*Induction*: assume the invariant that every identifier on the stack refers to
a set equal to its mathematical meaning and the map stores consistent mappings.
Each operation processes the top identifiers:

- **PUSH** inserts (or retrieves) the id for `{}`. The map guarantees the same id
  for identical sets; the pushed set is `{}`, whose size is `0`.
- **DUP** duplicates the top id, leaving the represented set unchanged and
  therefore outputs the same size.
- **UNION** and **INTERSECT** retrieve the sets represented by the two popped ids
  and compute union/intersection using list merge which yields a sorted, duplicate
  free representation. `getId` then returns the correct id for this set, ensuring
  the stack stores the new set. The size of the resulting set is the length of
  the list and is printed.
- **ADD** inserts the id of the first set into the second set’s list using
  `ordInsert`, maintaining sorting and uniqueness. The id returned by `getId`
  corresponds to the set `B ∪ {A}` and its size is printed.

Therefore the invariant holds after each operation and the printed sizes are
correct. Finally, `***` is printed between test cases as required.

## Complexity Analysis

Let `n` be the number of operations in a test case and `k` the maximum set size.
Each operation performs at most a merge or insertion on sorted lists of length at
most `k`, costing `O(k)`. Thus the total running time is `O(n · k)` and memory
usage is `O(k · m)` where `m` is the number of distinct sets created.

## Reference Implementation

See [`1835.lean`](../../human/x/lean/1835.lean) for the full implementation.
