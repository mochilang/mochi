# HAN01 - Ha-noi!

We start with `n` discs on peg 1 and Sabrina follows the optimal Tower of Hanoi strategy to move them to peg 2. The puzzle can be split recursively:

* Move `n-1` discs from `src` to `aux` – this uses `2^(n-1)-1` moves.
* Move disc `n` from `src` to `dst` – one move.
* Move `n-1` discs from `aux` to `dst` – again `2^(n-1)-1` moves.

Given a number of steps `k` ( `0 < k < 2^n` ) we recursively determine the state:

1. Let `m = 2^(n-1) - 1` be the moves needed for the first phase.
2. If `k ≤ m`, we are still solving the first phase; disc `n` stays on `src` and we recurse on `n-1` discs with parameters `(src, aux, dst)`.
3. Otherwise disc `n` has moved to `dst`. If `k = m + 1` the first phase just finished and all other discs are on `aux`. For larger `k` we continue with the second phase and recurse on `n-1` discs with parameters `(aux, dst, src)` and remaining steps `k - (m + 1)`.

This recursion only depends on `n` (which decreases every call) and therefore terminates quickly even for `n = 60`.

Once the position of every disc is known, we build the three towers by iterating discs from smallest to largest and placing each into its peg's list. The lists are built by cons-ing larger discs in front, so the final order is from largest to smallest as required by the output format.

The program reads all test cases, computes the peg contents, and prints three lines per case:
`i: d_m|d_{m-1}|...|d_1` for peg `i`, omitting the space and numbers when a peg is empty.
