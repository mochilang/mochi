# DRAGON2 - Greedy Hydra II

[Problem link](https://www.spoj.com/problems/DRAGON2/)

We are given a tree with `N` nodes and weighted edges. We must remove exactly `M-1` edges so that the resulting forest has `M` connected components. The component containing node `1` must contain exactly `K` nodes. Removing an edge costs its weight and we seek the minimum total cost.

## Algorithm

We root the tree at node `1` and perform a depth‑first search.  For each node `u` we compute a table `dp_u[s] = (cost, cuts)` where:

* `s` – number of nodes from the subtree of `u` kept in the component containing `u` (always including `u`),
* `cost` – minimal total weight of removed edges needed to keep exactly `s` nodes,
* `cuts` – number of edges removed when achieving this state.

The table for a leaf is `dp[1] = (0,0)`.  When merging a child `v` connected by an edge of weight `w` we have two choices:

1. **Cut the edge**: the entire subtree of `v` becomes a separate component, contributing cost `w` and one additional cut.
2. **Keep part of the child**: for every `t ≥ 1` we may keep `t` nodes from `v`’s subtree using `dp_v[t]`, combining it with the current state to obtain `s+t` nodes.

This is a tree‑knapsack dynamic programming; the inner loops iterate over all possible numbers of selected nodes.  After processing all children we obtain `dp_u` for node `u`.

The answer is taken from `dp_1[K]`.  If the recorded number of cuts plus one equals `M`, the minimal cost is reported; otherwise the required division is impossible and we output `-1`.

## Complexity

Let `K` be the required size of the root component.  The DP table for each node contains at most `K` entries and merging a child takes `O(K^2)` time in the worst case.  Hence the overall complexity is `O(N · K^2)` time and `O(N · K)` memory, which is acceptable for small inputs.
