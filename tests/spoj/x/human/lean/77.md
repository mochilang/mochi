# BRICKS - New bricks disorder

[Problem link](https://www.spoj.com/problems/BRICKS/)

## Algorithm

We are given two strings describing the initial and desired order of bricks.
Only adjacent bricks whose letters appear in an allowed pair may be swapped.
For every test case:

1. If the strings have different lengths the answer is `-1`.
2. For the target string we store, for each letter `a..z`, the list of
   positions where this letter occurs.
3. We scan the source string from left to right. For each letter we take the
   next unused target position `p` of the same letter. For every letter `d` we
   count how many already processed occurrences of `d` lie to the right of
   `p`; these represent inversions requiring a swap between `d` and the
   current letter. The counts are accumulated in a 26×26 matrix and summed to
   obtain the total number of swaps.
4. After processing all letters we check every pair `(x,y)` that needs to
   cross. If the pair is not allowed, the configuration is impossible and we
   output `-1`.
5. Otherwise the accumulated number of swaps modulo `2^32` is printed.

This approach is `O(26 · n)` for the number of letters in the string.

## Correctness Proof

We process characters in the source string in order.  When we match a letter
with its target position `p`, every previously processed letter with a larger
final position must cross the current letter.  Each such crossing corresponds
exactly to one required adjacent swap, so counting these inversions gives the
minimal number of swaps needed.

If any required pair `(x,y)` is not in the allowed set, the letters `x` and
`y` can never swap places, hence the transformation is impossible.  Conversely,
if all required pairs are allowed, performing the computed number of swaps
suffices to transform the source into the target string.

## Complexity Analysis

Let `n` be the length of the strings (≤ 100000).  For each of the `n` letters
we examine the counts for the 26 letters, leading to `O(26 · n)` time.  The
memory usage is `O(26 · n)` for storing positions.

## Reference Implementation

The reference implementation in Lean is available in
`tests/spoj/human/x/lean/77.lean` and follows the algorithm described above.
