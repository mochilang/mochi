# BRCKTS - Brackets

The problem provides a bracket string of length up to 30,000 and a sequence of
operations. Two kinds of operations are supported:

* **Replacement** – toggle the bracket at position `k` between `(` and `)`.
* **Check** – verify if the current string is a correct bracket expression.

A string is correct when the number of opening and closing brackets is the same
and no prefix ever contains more closing than opening brackets.

## Algorithm

We maintain a segment tree where each node stores two values for its segment:

* `sum` – the total balance of brackets (`(` as `+1`, `)` as `-1`).
* `minPref` – the minimum prefix sum within the segment.

For two adjacent segments `a` and `b` we combine them as

```
 sum = a.sum + b.sum
 minPref = min(a.minPref, a.sum + b.minPref)
```

A leaf represents a single bracket with values `(+1,0)` for `(` and
`(-1,-1)` for `)`.

Updating position `k` flips the value and we update the tree along the path to
the root.  To answer a check query we examine the root node: the expression is
correct when `sum = 0` and `minPref ≥ 0`.

This yields `O(log n)` time per update or query while using `O(n)` memory.

## Correctness

We prove that the segment tree correctly reflects the properties of the bracket
string.

*For a leaf*: the stored `sum` and `minPref` obviously match the single
character.

*For an internal node*: by induction assume children `a` and `b` represent their
segments correctly.  The combined `sum` equals the total number of opening minus
closing brackets.  Any prefix of the concatenated segment is either entirely
inside `a` or consists of all of `a` and a prefix of `b`; hence the minimum
prefix is `min(a.minPref, a.sum + b.minPref)`.  Thus the node represents its
segment correctly.

By induction on the tree structure every node maintains correct information.
The entire string is a correct bracket expression iff the root has balance zero
and never dips below zero, which is exactly `sum = 0` and `minPref ≥ 0`.

## Complexity

Let `n` be the length of the bracket string and `m` the number of operations.
Building the tree takes `O(n)` time.  Each update or check touches `O(log n)`
nodes.  Therefore the total running time is `O(n + m log n)` and the memory
usage is `O(n)`.
