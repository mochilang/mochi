# [Promotion](https://www.spoj.com/problems/PRO)

## Problem Summary
Each day new receipt amounts are added to a common box. At day's end the highest and lowest amounts are removed and their difference is paid as a prize. Removed receipts do not return to the box. Compute the total prize value over the entire promotion.

## Algorithm
1. Maintain an array `freq[0..1_000_000]` storing how many receipts of each value currently remain.
2. Track two pointers `minVal` and `maxVal` indicating the smallest and largest values still present.
3. For each day:
   - Read all receipt values, increment their counts in `freq`, and update `minVal`/`maxVal`.
   - Move `minVal` upward until its count is non‑zero and remove one occurrence.
   - Move `maxVal` downward until its count is non‑zero and remove one occurrence.
   - Add `maxVal - minVal` to the running total.
4. After processing all days, output the accumulated total.

Pointers only move forward across the value range, so the total work is `O(number of receipts + 1_000_001)` with `O(1_000_001)` memory.
