# Party Schedule

We are given a spending limit and several parties, each with an entrance fee and a fun value. 
The goal is to choose a subset of parties such that the total fee does not exceed the budget, 
and the total fun is maximized. If multiple subsets give the same fun, we must pick the one 
with the smallest total fee.

This is a classic 0/1 knapsack problem. We use dynamic programming on the cost.
`dp[c]` stores the maximum fun achievable with exactly `c` money. For each party we update 
this array from high to low cost:

```
for cost from budget down to fee:
    dp[cost] = max(dp[cost], dp[cost - fee] + fun)
```

After processing all parties, we scan `dp` to find the highest fun value, and among those 
entries choose the smallest cost index. This gives both the minimal spent amount and the 
maximum fun.

The budget is at most 500 and the number of parties at most 100, giving a complexity of 
`O(budget * parties)` with `O(budget)` extra memory.
