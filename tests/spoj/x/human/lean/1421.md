# SPOJ FIRM - Goods

We are given a permutation `p` where dealer `i` wants goods owned by dealer `p[i]`.
Every goods type is desired by exactly one dealer.  In one day we may execute
several pairwise exchanges, but each dealer can participate in at most one
exchange per day.  The task is to reach the desired configuration with the
minimal number of days and output one valid schedule of exchanges.

## Algorithm

1. Decompose the permutation into disjoint cycles.
2. For a cycle `[v₀, v₁, …, v_{k−1}]` perform parallel pairwise swaps:
   - Day 1: swap `(v₀,v₁)`, `(v₂,v₃)`, … .  After these swaps the dealers in
     even positions are satisfied; the remaining unsatisfied dealers form a new
     cycle consisting of the second element of each swap and the last element if
     `k` is odd.
   - Repeat the same procedure on the new cycle until it has one dealer left.
3. Merge the schedules from all cycles day by day.  The total number of days is
   the maximum over `ceil(log₂ k)` for each cycle length `k`.

## Complexity

Let `n` be the number of dealers.  Each cycle of length `k` contributes
`O(k)` swaps spread over `⌈log₂ k⌉` days.  As the cycles partition the dealers,
the algorithm runs in `O(n)` time and uses `O(n)` memory.
