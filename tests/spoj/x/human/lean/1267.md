# Origin of Life (ORIGLIFE)

We have an `m × n` grid (`m ≤ 4`, `n ≤ 5`) where each cell is either alive or dead.
The transition to the next generation depends only on the number of live neighbours
in the eight surrounding cells:

- a live cell dies if it has fewer than `a` or more than `b` live neighbours;
- a dead cell becomes alive if it has more than `c` live neighbours;
- otherwise the cell keeps its state.

The grid is very small (`m*n ≤ 20`), so the number of possible states is at most
`2^(m*n)` (≈ 1 million).  For each test case we enumerate **all** states and
compute their next generation.  From this we build a reverse transition map:
for every state `T` we collect all states `S` such that `next(S) = T`.

With this reverse graph we run a BFS starting from the given target state.
Whenever we reach a state with no predecessors it is a *Garden of Eden* and the
current BFS depth is the minimal number of steps needed to reach the target from
such a state.  If the search finishes without encountering a Garden of Eden the
answer is `-1`.

All states are represented as bit masks inside a natural number; neighbour masks
are pre‑computed for efficiency.  BFS and enumeration are done with mutable
arrays in the `Id` monad.
