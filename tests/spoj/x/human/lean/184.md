# [Automatic Teller Machines](https://www.spoj.com/problems/ATMS/)

## Problem Summary
A network of 100 ATMs is numbered from 0 to 99.  ATM `i` pays out `2^i` ducats when `i` is even and receives `2^i` ducats when `i` is odd.  To borrow an amount `A` (< 10^30) a client may use each ATM at most once, choosing withdrawals from some even-numbered ATMs and deposits to some odd-numbered ATMs.  We must determine whether the desired loan can be obtained, and similarly whether the loan can be repaid, and list the ATMs used in decreasing order.  If it is impossible, output `No`.

## Algorithm
The effect of using ATM `i` is `(-1)^i * 2^i`.  The set of reachable sums is therefore exactly the representation of integers in base `-2` (negabinary) with digits `0` or `1`, where digit `1` means that ATM `i` is used.  Any integer has a unique negabinary representation, so to test feasibility we convert the requested amount to base `-2`.

1. Implement conversion of an integer `n` to base `-2` using the recurrence:
   - While `n â‰  0`, set `r = n mod 2` and update `n = (r - n) / 2`.
   - If `r = 1`, record the current bit position `i`.
2. The positions are generated from least to most significant.  Prepending each position yields a list already in decreasing order.
3. If during the process the position index reaches `100` while `n` is still non-zero, representation exceeds available ATMs; return `No`.
4. Apply the conversion to `A` to compute the ATMs for obtaining the loan, and to `-A` for returning the loan.

The loop runs at most 100 iterations and uses only big-integer arithmetic, giving an overall complexity of `O(log A)` per query.
