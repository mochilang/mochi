# SPOJ ACODE - Alphacode

## Algorithm
1. Convert the input string to an array of characters.
2. Use dynamic programming from the end of the array:
   - `dp[i]` stores the number of ways to decode the suffix starting at position `i`.
   - Initialize `dp[n] = 1` for the empty suffix.
   - For each position `i` from `n-1` down to `0`:
     - If the current digit is `'0'`, `dp[i] = 0`.
     - Otherwise, set `dp[i] = dp[i+1]` for decoding the single digit.
     - If the next two digits form a number between 10 and 26, add `dp[i+2]`.
3. The answer for the whole string is `dp[0]`.

This counts the number of valid interpretations where `"1" -> 'A'` up to `"26" -> 'Z'`.

## Correctness
- `dp[i]` considers all valid decodings of the suffix starting at `i`.
- Single-digit decoding is valid for digits `'1'` to `'9'`; two-digit decoding is valid only
  for numbers `10` to `26`.
- The recurrence ensures every decoding is counted exactly once by extending shorter suffixes.
- By processing positions from right to left, we ensure that needed future values are already
  computed.

## Complexity
Let `n` be the length of the string (â‰¤ 5000).
- Time complexity: `O(n)` since each position is processed once.
- Space complexity: `O(n)` for the DP array.
