# [BARB - Barbarians](https://www.spoj.com/problems/BARB/)

## Algorithm

- Enumerate the possible number of caves `M` starting from `max(C_i)`.
- For each candidate `M`, check all pairs of barbarians.
- Two barbarians `i` and `j` meet at year `t` when
  `(P_i - P_j) * t ≡ C_j - C_i (mod M)`.
- Solve this linear congruence using the extended Euclidean algorithm:
  - Let `g = gcd(P_i - P_j, M)`. If `C_j - C_i` is not divisible by `g`,
    they never meet.
  - Otherwise reduce the equation modulo `M/g` and compute `t₀` using a
    modular inverse.
  - If `t₀ ≤ min(L_i, L_j)`, the pair meets before one dies and `M` is invalid.
- The first `M` passing all pair checks is the minimal number of caves.

## Correctness Proof

The algorithm tests increasing values of `M` and only accepts a value when no
pair of barbarians meets before one of them dies. For a given pair, solving the
congruence exactly characterizes the years when they occupy the same cave. If a
  solution exists with `t ≤ min(L_i, L_j)`, a conflict occurs, so the candidate `M`
is rejected. If no such solution exists for all pairs, then no two barbarians
share a cave in any year, making the candidate valid. Since we test candidates
in increasing order, the first valid `M` found is the minimal one satisfying the
requirements.

## Complexity Analysis

Let `N` be the number of barbarians (≤ 15) and `M` the answer (≤ 1e6).
For each `M` we check `O(N^2)` pairs and solve a linear congruence in
`O(log M)` time, giving a worst-case complexity of `O(M · N^2 · log M)`.
This is feasible for the given limits.

## References

- [Extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)
- [Modular multiplicative inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)
