# MUSKET - Musketeers

The players stand on a circle and each duel must be between two
neighbouring players.  After every duel the loser is removed and the
circle closes again.  The goal is to determine which starting players
can end up as the final survivor when the order of duels is chosen
freely.

## Algorithm

Let `A[i][j] = 1` if player `i` defeats player `j`.  For every player
`j` we precompute the set `beaters[j]` containing all players who defeat
`j`.

We double the circular list to a length of `2n` so that every interval of
length `n` represents the original circle starting at some position.  We
use dynamic programming on intervals:

`dp[l][r]` – bitset of players (indexed modulo `n`) that can win the
game restricted to the contiguous segment from position `l` to `r`
in the doubled list.

Base case: `dp[i][i]` contains only the player at position `i`.

Transition: For an interval `[l, r]` and any split point `m` between
`l` and `r` we combine winners from the left `[l, m]` and right
`[m+1, r]` parts.  A player `p` from the left can become champion if he
belongs to `beaters` of at least one player from the right; similarly for
a player from the right.  The bitset operations make this combination
efficient.

After filling the DP for lengths from `2` to `n`, the possible champions
for the whole circle are obtained by taking the union of `dp[i][i+n-1]`
for all starting positions `i`.

## Complexity

The dynamic programming runs in `O(n^3)` time with `n ≤ 100` and uses
`O(n^2)` memory.
