# CLEANRBT - Cleaning Robot

The room is a grid up to 20×20 containing clean tiles, obstacles, and at most
10 dirty tiles. A robot starts at `o` and can move in four directions; visiting
a dirty tile cleans it. The goal is to find the minimum number of moves needed
to clean all dirty tiles or report `-1` if some are unreachable.

## Algorithm

1. **Parse the map** to locate the start and enumerate dirty tiles. Each dirty
tile is assigned an index (0‥k-1).
2. **State representation**: `(x, y, mask)` where `mask` is a bitmask of the
   cleaned dirty tiles. There are at most `20×20×2^k` states (≤ 409 600).
3. **BFS** starting from the robot position with mask `0`.
   - For each dequeued state, explore the four neighbours (if inside the grid
     and not an obstacle).
   - When moving onto a dirty tile with index `i`, set bit `i` in `mask`.
   - Maintain a visited array indexed by `(x, y, mask)` to avoid revisiting.
4. **Termination**: when a state with `mask = (1<<k) - 1` (all dirty tiles
   cleaned) is dequeued, the current distance is the minimum moves. If the BFS
   finishes without such a state, output `-1`.

The BFS guarantees optimality because each edge has unit cost.
