# CLTZ - Collatz

We are given the recurrence

- `f(1) = N`
- `f(k) = (0.5 + 2.5 * (f(k-1) mod 2)) * f(k-1) + (f(k-1) mod 2)` for `k > 1`

`f(k-1) mod 2` is `0` when the previous term is even and `1` when odd.
Substituting gives:

- if `f(k-1)` is even: `f(k) = f(k-1) / 2`
- if `f(k-1)` is odd: `f(k) = 3 * f(k-1) + 1`

Thus the sequence is the classic Collatz iteration.  For each starting value `N`
we must find the smallest `L` such that the sequence reaches `1` at `f(L)`.

Algorithm:

1. Set a counter `c = 0` and current value `x = N`.
2. Repeat until `x = 1`:
   - Increment `c`.
   - If `x` is even, set `x := x / 2`.
   - Otherwise set `x := 3 * x + 1`.
3. The answer is `c + 1` (including the starting term).

Lean's arbitrary-precision `Nat` handles the very large numbers specified, so the
implementation simply loops using these operations.
