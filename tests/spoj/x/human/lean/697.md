# Matrix Words (MWORDS)

We are given an `N × N` grid of uppercase letters.  Starting at the
upper‑left corner `(1,1)` we must reach `(N,N)` in exactly `2N-1`
characters while never crossing the main diagonal.  A path that stays
on or above the diagonal belongs to the *upper* partition, a path that
stays on or below it belongs to the *lower* partition.  All strings from
both partitions are collected (duplicates allowed), sorted
lexicographically and the string at position `I mod M` is reported.

## Algorithm

* Only right and down moves can appear in a shortest path of length
  `2N‑1`, so every valid path consists of `N-1` rights and `N-1` downs.
* For every cell we pre‑compute how many paths from that cell to `(N,N)`
stay in the upper partition and in the lower partition.  This is done by
simple dynamic programming over the grid.  The counts fit in 64 bits
(`N ≤ 30`).
* To build the answer we walk from `(1,1)` to `(N,N)` choosing moves in
lexicographic order of the next character.  For each candidate move we
know how many valid continuations exist from the pre‑computed tables; we
subtract these counts from `k = I mod M` until the appropriate branch is
selected.  The chosen character is appended and the process repeats until
the destination is reached.

The procedure runs in `O(N^2)` preprocessing per test case and
`O(N)` for constructing the requested string.
