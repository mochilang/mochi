# [K-path cover](https://www.spoj.com/problems/COVER/)

## Problem Summary
We are given a directed graph with `n` vertices and `m` edges.  Each vertex has a cost.
A **k-path cover** is a set of exactly `k` edges such that no two edges share the same
start vertex and no two share the same end vertex.  The cost of an edge is the sum of
the costs of its endpoints, and the cost of a k-path cover is the sum of its edge
costs.  For each test case we must output the cost of the cheapest k-path cover or
`NONE` if no such cover exists.

## Algorithm
1. Model the problem as a minimum cost flow on a bipartite graph.
   - Split every vertex `i` into a left copy `i` (used as start) and a right copy `i+n`
     (used as end).
   - Connect a super source to every left copy with capacity `1` and cost `0`, and every
     right copy to a super sink with capacity `1` and cost `0`.
   - For each original directed edge `u → v`, add an edge from `u` on the left to `v` on
     the right with capacity `1` and cost `cost[u] + cost[v]`.
2. Run the successive shortest augmenting path algorithm to send `k` units of flow
   from source to sink.
   - Because edge costs may be negative, use SPFA to find the cheapest augmenting path.
   - Augment along the path, updating residual capacities and accumulating the total
     cost.
   - If at some step no augmenting path exists, the graph has no k-path cover.
3. After `k` successful augmentations, the accumulated cost is the answer.

The network has `2n+2` vertices and `m + 2n` edges.  SPFA runs in `O(V+E)` time, and we
run it at most `k ≤ 100` times, which satisfies the problem constraints.
