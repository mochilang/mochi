# The Clever Typist (CLEVER)

Blue Mary's keyboard only has six special keys.  We model the screen as six positions and a cursor.  The operations are:

- **Swap0** – swap the digit under the cursor with position 1.
- **Swap1** – swap the digit under the cursor with position 6.
- **Left/Right** – move the cursor one step.
- **Up/Down** – increase/decrease the digit under the cursor.

The goal is to transform a 6‑digit start string into a target string using the fewest key presses.  The final cursor position is irrelevant.

## Algorithm

The operations separate into two kinds:

1. **Reordering digits** (Swap0, Swap1 and cursor moves).
2. **Changing digit values** (Up/Down).

Up/Down does not move the cursor, so whenever the cursor is visiting a position we can perform all required increases/decreases there without affecting later moves.  Therefore the number of Up/Down presses for a fixed assignment of start digits to final positions is simply the sum of absolute differences of the digits.

The difficult part is reordering digits with minimum cursor moves and swaps while ensuring that every position where the digit changes is visited at least once (otherwise we could not press Up/Down).

There are only six positions.  We pre‑compute a shortest path table using BFS over states `(perm, cursor, visited)` where:

- `perm` is the permutation describing which original position currently occupies each slot (encoded in 3 bits per slot).
- `cursor` is the current cursor index `0…5`.
- `visited` is a 6‑bit mask of positions that have been visited by the cursor.

From any state we generate up to four transitions: move left, move right, swap with position 1, swap with position 6.  Swaps are ignored when they would have no effect.  The BFS starting from the identity permutation with the cursor at position 1 computes the minimum number of presses for every reachable `(perm, visited)` pair.

During a test case we try all 6! permutations `p`.  For each permutation we compute:

```
requiredMask = { i | start[p[i]] != target[i] }
upDownCost   = Σ |start[p[i]] – target[i]|
```

The pre‑computed table gives the minimum number of swaps and cursor moves to obtain `p` while visiting all positions in `requiredMask`.  Adding `upDownCost` yields the total presses for that assignment.  Taking the minimum over all permutations gives the optimal answer.

The state space contains only `720 × 6 × 64 = 276 480` states, so the BFS and the per‑query enumeration are fast.

## Complexity

- Pre‑computation BFS explores at most 276k states.
- For each test case we examine all 720 permutations and 64 masks, so the worst‑case time is about `720 × 64` simple operations.
- Memory usage is small (a few megabytes).
