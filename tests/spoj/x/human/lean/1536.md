# BLUEEQ3 - Help Blue Mary Please! (Act III)

[Problem link](https://www.spoj.com/problems/BLUEEQ3/)

We are given, for each test case, an integer `n (1 ≤ n ≤ 21)` and three
strings of length `n` composed of the first `n` uppercase letters.  Each
letter represents a distinct digit in base `n`.  Interpreting the three
strings as base-`n` numbers, the first two sum to the third.  We must
recover the permutation of digits `0 … n-1` corresponding to the letters
`A …` and output the digits in order.

## Algorithm

We solve the alphametic puzzle by depth‑first search, processing the
addition column by column from the least significant digit.

1. Maintain two arrays:
   - `map[i]` = assigned digit for letter `i` (`A` → 0, …), or `none` if
     unassigned.
   - `used[d]` marks which digits have been used.
2. Recursively consider position `pos` counting from the right.
   For the letters `x`, `y`, `z` from the three numbers at this
   position, iterate over all available digits for `x` and `y` that are
   compatible with the current mapping.
3. For every pair `(dx, dy)` compute `s = dx + dy + carry`.
   - `dz = s mod n` must be assigned to `z` (checking consistency with
     previous assignments).
   - Recurse to the next position with carry `s / n`.
4. When all positions are processed, a solution is found iff the final
   carry is zero.  The mapping is then fully determined.

Because at each step assignments are consistent with the addition, the
search space prunes quickly, and with `n ≤ 21` and a guaranteed unique
solution the program runs easily within limits.

## Complexity

Let `n` be the base.  In the worst case the DFS explores a small fraction
of the `n!` possible permutations, but practical complexity is tiny:
for the maximal `n = 21` the search completes in milliseconds.

