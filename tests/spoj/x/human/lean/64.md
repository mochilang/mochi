# SPOJ PERMUT1 - Permutations

[Problem link](https://www.spoj.com/problems/PERMUT1/)

We are asked to count the number of permutations of `n` elements that have exactly `k`
inversions. An inversion is a pair of indices `(i, j)` with `i < j` and
`a_i > a_j`.

For `n ≤ 12` and `k ≤ 98` we can precompute all answers using dynamic
programming. Let `dp[n][k]` be the number of permutations of size `n`
with exactly `k` inversions. When inserting the largest element `n` into a
permutation of size `n-1`, it can create `i` new inversions where
`0 ≤ i ≤ n-1`. This leads to the recurrence

```
dp[0][0] = 1
for n ≥ 1:
  dp[n][k] = sum_{i=0}^{min(k, n-1)} dp[n-1][k - i]
```

Filling a table with this recurrence up to the maximum `n` and `k` allows
answering each query in constant time by a simple lookup.
