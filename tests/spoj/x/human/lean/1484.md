# Solution for SPOJ PT07H - Search in XML

We are given a text XML document and another XML document that acts as a
pattern.  Tags have no attributes or text content and, importantly, siblings of
any node have distinct names.  Every element in the text is numbered by the
order of its start tag.

A pattern matches a position in the text if the root of the pattern is placed on
that node and every pattern child can be mapped to the unique child with the
same tag in the text, recursively.

## Algorithm

1. **Parse XML** – Read the whole input and remove all whitespace.  Parse the
   first XML tree assigning incremental ids to nodes as their start tags are
   encountered.  Continue parsing the remaining characters as the pattern tree.
   Because tags are simple, a recursive descent parser over the characters
   suffices.
2. **Match pattern** – For every node in the text tree perform a recursive
   check:
   - The current node labels must be equal.
   - For each child of the pattern node, find the unique child with that label
     in the text and recurse on it.  Extra children in the text are ignored.
3. **Collect ids** – If a node matches the pattern, record its id.  Traverse the
   text tree in pre-order so the ids are already sorted.
4. **Output** – Print the number of matches followed by the ids in increasing
   order.

## Correctness

We prove the algorithm outputs exactly the ids of nodes where the pattern
occurs.

- During parsing every start tag creates a node and increments the counter, so
  ids correspond to the order of appearance of start tags as required.
- When `matchPattern` succeeds on a text node and the pattern root:
  - The node names are equal, so the roots match.
  - For each pattern child there exists a text child with the same label and
    the recursive call ensures their subtrees match.  Since siblings have
    distinct labels, the correspondence is unique.
  Hence, the entire pattern embeds in the text starting at that node.
- If the pattern embeds at some node, the above checks all pass, so our function
  will record that id.  Conversely, if any required child is absent or fails to
  match, the function returns `false`, so such a node is not recorded.

Therefore the recorded ids are precisely those positions where the pattern
occurs.

## Complexity

Let `N` be the number of nodes in the text and `M` the number of nodes in the
pattern.  Parsing is linear in the size of the input.  For each text node we may
need to inspect its children while trying to match the pattern, but every
matching attempt walks through at most `M` nodes.  Hence the total time is
`O(N * M)` and the memory usage is `O(N + M)` for storing the trees.
