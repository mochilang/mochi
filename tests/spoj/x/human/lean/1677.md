# [Halloween treats](https://www.spoj.com/problems/HALLOW)

## Problem Summary
Given the number of children `c` and the amount of sweets `a_i` offered by each of `n` neighbours, choose a subset of neighbours
so that the total number of sweets is divisible by `c`. Each child must receive the same positive number of sweets. For multiple
test cases, output the indices of the neighbours to visit or `no sweets` if no such subset exists.

## Algorithm
Because `c â‰¤ n`, by the pigeonhole principle there is always a non-empty subset whose total is divisible by `c`. We can find such
a subset using prefix sums modulo `c`:

1. Maintain an array `first` of size `c` recording the first index where each prefix sum modulo `c` occurs. Initialize `first[0] = 0`.
2. Scan the neighbours, updating the running sum modulo `c`.
3. When the current modulo has been seen before at position `j`, the neighbours from `j+1` to the current position form a valid subset
   because their sum is divisible by `c`.
4. Output these indices. If the scan finishes without a repetition (which should not happen given the constraints), output `no sweets`.

The scan runs in `O(n)` time and uses `O(c)` additional memory per test case.
