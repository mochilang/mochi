# [Menu](https://www.spoj.com/problems/MENU)

## Problem Summary
Plan meals for `k` days choosing among `n` dishes.  Each dish `i` has cost `cᵢ` and benefit `vᵢ`.  Cooking the same dish on consecutive days halves the benefit on the second day and reduces it to zero from the third day onward.  Select a sequence of dishes whose total cost does not exceed the budget `m` and whose total benefit is maximized.  In case of ties, pick the plan with minimum cost.  If no plan fits the budget, the benefit is zero and no dishes are printed.

## Algorithm
Use dynamic programming on four dimensions:
- day index `d` from `0` to `k`;
- total cost spent `b` up to `m`;
- last cooked dish `l` (`0` meaning none);
- how many consecutive times `r` that dish was cooked (`0`, `1`, or `2`, where `2` stands for "two or more").

`dp[d][b][l][r]` stores the maximum benefit (scaled by two to avoid fractions) achievable after day `d` with cost `b` and last dish `l` repeated `r` times.  For every reachable state we try cooking each dish on the next day, updating `dp[d+1][b+c][j][r']` with the gained benefit:
- `2·v` for a new dish,
- `v` when repeating a dish once,
- `0` for three or more repetitions.
Parent pointers record the previous state for reconstruction.

After processing all days, scan the states at day `k` to find the maximum benefit; break ties by minimal cost.  Backtrack using the stored parents to recover the sequence of dishes.

The state space is at most `(k+1)·(m+1)·(n+1)·3 ≤ 3.4·10⁵`, and for each state we iterate over at most `n` dishes (`n ≤ 50`), which is easily manageable.

## Correctness
The DP explores every feasible plan exactly once.  The benefit update rules implement the problem's scoring for first, second, and further consecutive uses of a dish.  Because each transition accounts for the cost and benefit of the chosen dish, the optimal value stored in `dp[k][b][l][r]` represents the best benefit for the first `k` days with total cost `b` and final dish `l` repeated `r` times.  The final scan chooses the highest benefit among budgets not exceeding `m`, and the parent pointers allow reconstruction of one optimal plan.

## Complexity Analysis
Let `K = k`, `N = n`, and `M = m`.  The DP has `O(K·M·N)` states, and each state considers up to `N` transitions, leading to a total time complexity of `O(K·M·N²)` (≤ about 5·10⁶ operations for the given limits).  The memory usage is `O(K·M·N)`.
