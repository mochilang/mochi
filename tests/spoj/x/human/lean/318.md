# [Pythagorean Legacy](https://www.spoj.com/problems/PITPAIR)

## Problem Summary
Given an integer `N`, find the smallest integer hypotenuse `R` such that there
are exactly `N` distinct right triangles with integer sides and hypotenuse `R`.
For that `R`, output the shorter leg of each triangle in ascending order.

## Algorithm
1. For the desired count `N`, compute `M = 2N + 1` and factor `M` into primes.
   For each prime factor `q^e`, add the exponent `(q-1)/2` repeated `e` times to
   a list of exponents.
2. Sort these exponents in descending order and assign them to the smallest
   primes congruent to `1 (mod 4)` in increasing order.  The resulting
   hypotenuse is `R = ∏ p_i^{a_i}` where `a_i` are the assigned exponents.
   This follows from the formula for the number of representations of `R` as a
   sum of two squares.
3. To recover all triangles for this `R`, enumerate primitive Pythagorean
   triples using Euclid's formula `a = m^2 - n^2`, `b = 2mn`, `c = m^2 + n^2`.
   For each triple whose hypotenuse divides `R`, scale it by `k = R / c` and
   record the shorter leg `k * min(a, b)`.
4. Output `R` and the collected legs in ascending order.

This construction works for `N ≤ 2000` and produces the minimal hypotenuse.
