# [Sweet and Sour Rock](https://www.spoj.com/problems/ROCK)

## Problem Summary
Given a stick of length \(N\) divided into centimetre segments marked as sweet (`1`) or sour (`0`), we may break the stick at any boundaries. A piece of rock is sellable only when it contains more sweet segments than sour ones. Determine the maximum total length of sellable pieces after optimally breaking the stick.

## Algorithm
1. Convert the input string to an array of numbers (1 for sweet, 0 for sour) and build a prefix-sum array of sweet counts.
2. Dynamic programming on prefixes:
   - `dp[i]` stores the maximum sellable length using the first `i` segments.
   - For each end position `r` from `1` to `N`:
     - Start with `best = dp[r-1]` (skip segment `r`).
     - For each start `l` from `0` to `r-1`:
       - Let `ones = prefix[r] - prefix[l]`, `len = r - l`.
       - If `ones * 2 > len`, the segment `[l, r)` has more sweet than sour, so set `best = max(best, dp[l] + len)`.
     - Set `dp[r] = best`.
3. The answer is `dp[N]`, the maximum sellable length for the whole stick.

The stick length is at most 200, so the \(O(N^2)\) DP is easily fast enough.
