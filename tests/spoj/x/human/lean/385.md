# [GAME - Game schedule required](https://www.spoj.com/problems/GAME/)

## Algorithm

1. Read number of teams `n`, team names and the `n-1` desired games.
2. Build an undirected tree `adj` connecting teams. The games form a tree.
3. Choose the last team as the final champion and root the tree at this node using a DFS to
   compute each node's parent.
4. While more than one team remains:
   - For the current set of alive nodes compute the degrees considering only alive
     neighbors.
   - Use a queue of leaves to build a maximum matching: repeatedly take a leaf whose
     parent has not yet been used in this round and pair it with that parent. Mark both
     nodes as used so the parent cannot play twice in the same round and decrease the
     degrees of its neighbors. The collected pairs constitute all matches of this round.
   - Any remaining unused node (if `n` is odd) becomes the wildcard.
   - For each pair output "parent defeats child" (the parent is determined from the DFS) and
     eliminate the child from the tournament.
5. After all rounds only the root team remains – print it as the winner.

## Correctness

- The input games form a tree, so rooting it at the champion gives every game a unique
  parent-child relationship. The parent must win for its child to appear in later games.
- In a tree a greedy leaf-removal algorithm finds a maximum matching. Each chosen leaf is
  paired with its parent, and that parent is marked used so it cannot be matched twice in
  the same round. Because maximum matchings in a tree have size `floor(n/2)`, the number of
  matches per round satisfies the tournament rules. At most one node remains unmatched,
  which correctly becomes the wildcard when the number of teams is odd.
- Eliminated nodes are removed from consideration in later rounds. Since each edge is
  played exactly once and winners always move toward the root, eventually only the root
  remains, which is reported as the tournament winner.

## Complexity

Let `n` be the number of teams (≤1000).
Each round processes every remaining edge at most once. Since the tree has `n-1` edges,
across all rounds the algorithm runs in `O(n)` time. The memory usage is `O(n)` for the
adjacency lists and auxiliary arrays.
