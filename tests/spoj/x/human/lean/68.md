# EXPR1 - Expression

We are given an expression of the form `0 o1 d1 o2 d2 ... om dm` where each `oi` is `+` or `-` and each `di` is a single digit.  The goal is to insert the smallest number of pairs of parentheses so that the value of the expression becomes a target `k`.

For a subarray of consecutive numbers we need to know every value it can produce and the minimal number of parentheses needed for that value.  Let `solve(l,r)` denote the map for numbers `l..r` (inclusive).  If `l = r` the only possible value is the number itself with cost `0`.

For `l < r` we choose an operation position `k` with `l ≤ k < r`.  This splits the segment into `solve(l,k)` and `solve(k+1,r)` combined using operator `ops[k]`.  If `k` is the last operation in the segment (`k = r-1`), the evaluation order matches the default left‑to‑right order and no extra parentheses are required.  Otherwise the right segment must be computed first and we pay one additional pair of parentheses.  The costs from the two segments and the possible result values are merged, always keeping the minimal cost for each value.

The number of different `(l,r)` pairs is at most 210 (for 20 digits), and each map only stores reachable results within `[-180,180]`.  Memoising `solve(l,r)` therefore explores all parenthesisations without enumerating them explicitly.

After computing `solve(0,m)` (where `m` is the number of digits) we report the cost for `k` if it exists, or `NO` otherwise.
