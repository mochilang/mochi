# [CUBERT - Cube Root](https://www.spoj.com/problems/CUBERT/)

## Problem Summary
Given up to twenty positive integers (each up to 150 digits), compute the
cube root of each number.  The root must be truncated after ten decimal
places and printed along with a checksum: the sum of all printed digits
modulo ten.

## Algorithm
To obtain ten decimal digits of precision we scale the input number `n`
by `10^30` and compute the integer cube root of this scaled value.  Since
`cuberoot(n * 10^30) = cuberoot(n) * 10^10`, taking the integer cube root
and then dividing by `10^10` yields the original cube root truncated to
ten decimal places.

The integer cube root of the scaled number is found via binary search:

1. Set the search interval to `[0, n*10^30 + 1)`.
2. Repeatedly take the midpoint and compare its cube with the target.
3. Narrow the interval accordingly until its size is one.  The lower
   bound is then the floor of the cube root.

After obtaining `r = floor(cuberoot(n) * 10^10)`, we derive the output:

- Integer part: `r / 10^10`.
- Fractional part: `r % 10^10` formatted with leading zeros.
- Checksum: sum of all digits in the formatted number modulo 10.

## Correctness
Scaling by `10^30` ensures the integer cube root `r` equals
`floor(cuberoot(n) * 10^10)`.  Dividing and taking the remainder by
`10^10` therefore reconstructs the cube root truncated after ten digits.
The binary search examines a bounded interval that always contains the
true cube root, and each iteration halves the interval, guaranteeing
termination with the correct floor value.

## Complexity Analysis
Let `L` be the number of digits in the input (`L â‰¤ 150`).  The binary
search on a number with `O(L)` digits performs `O(log n) = O(L)`
iterations, each involving big integer arithmetic on `O(L)`-digit
numbers.  Thus each test case runs in roughly `O(L^2)` time, which is
fast enough for the given constraints.

## Reference Implementation
See [`291.lean`](../../human/x/lean/291.lean) for a complete implementation.
