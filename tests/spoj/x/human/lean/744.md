# Longest Permutation (LPERMUT)

We are given an array `A` of length `n` with `1 ≤ A[i] ≤ n`.  A contiguous subarray
forms a permutation if it contains each integer from `1` to `k` exactly once for
some `k`.  The task is to find the maximum possible `k`.

## Algorithm

The implemented solution checks every starting index and extends the subarray to
the right until it can no longer be a permutation.

For each start `i`:

1. Maintain a boolean array `seen` to mark which numbers have already appeared
   in the current subarray.
2. Track the current minimum and maximum values.
3. For each new element `A[j]`:
   - If `A[j]` was already seen, the subarray cannot be extended further.
   - Update `seen`, `max`, and `min`.
   - If `min = 1` and `max = j - i + 1`, the subarray contains exactly the
     numbers `1..max`, so update the best length.

The outer loop then moves to the next starting index and repeats the process.
The answer is the maximum length found.

## Complexity

In the worst case the algorithm examines `O(n^2)` pairs of indices, but `n`
(100000) keeps memory usage small and the logic remains straightforward.
