(* Generated by Mochi transpiler v0.10.74 on 2025-08-26 11:55 +0700 *)


let rec __is_list v =
  let open Obj in
  let rec loop x =
    let r = repr x in
    if is_int r then (magic r : int) = 0
    else
      match tag r with
      | 0 -> loop (field r 1)
      | _ -> false
  in
  loop v

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0

exception Break
exception Continue

exception Return

let rec parseInt str =
  let __ret = ref 0 in
  (try
  let digits = ref ([(__str (Obj.repr ("0")), 0); (__str (Obj.repr ("1")), 1); (__str (Obj.repr ("2")), 2); (__str (Obj.repr ("3")), 3); (__str (Obj.repr ("4")), 4); (__str (Obj.repr ("5")), 5); (__str (Obj.repr ("6")), 6); (__str (Obj.repr ("7")), 7); (__str (Obj.repr ("8")), 8); (__str (Obj.repr ("9")), 9)]) in
  let i = ref (0) in
  let n = ref (0) in
  (try while (!i < String.length (str)) do
    try
  let ch = (let __s = str in let __st = !i in let __len = ((!i + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") in
  if (ch <> " ") then (
  n := ((!n * 10) + (match List.assoc_opt (__str (Obj.repr (ch))) (!digits) with Some v -> (Obj.magic v : int) | None -> 0));
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!n) : int); raise Return
  with Return -> !__ret)

and parseInts line =
  let __ret = ref ([] : (int) list) in
  (try
  let digits = ref ([(__str (Obj.repr ("0")), 0); (__str (Obj.repr ("1")), 1); (__str (Obj.repr ("2")), 2); (__str (Obj.repr ("3")), 3); (__str (Obj.repr ("4")), 4); (__str (Obj.repr ("5")), 5); (__str (Obj.repr ("6")), 6); (__str (Obj.repr ("7")), 7); (__str (Obj.repr ("8")), 8); (__str (Obj.repr ("9")), 9)]) in
  let nums = ref (([] : (int) list)) in
  let cur = ref (0) in
  let inNum = ref (false) in
  let i = ref (0) in
  (try while (!i < String.length (line)) do
    try
  let ch = (let __s = line in let __st = !i in let __len = ((!i + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") in
  if (ch = " ") then (
  if !inNum then (
  nums := (Obj.magic ((List.append (!nums) [(Obj.magic (!cur) : int)])) : int list);
  cur := 0;
  inNum := false;
  );
  ) else (
  cur := ((!cur * 10) + (match List.assoc_opt (__str (Obj.repr (ch))) (!digits) with Some v -> (Obj.magic v : int) | None -> 0));
  inNum := true;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if !inNum then (
  nums := (Obj.magic ((List.append (!nums) [(Obj.magic (!cur) : int)])) : int list);
  );
  __ret := (Obj.magic (!nums) : int list); raise Return
  with Return -> !__ret)

and abs x =
  let __ret = ref 0 in
  (try
  let x = (Obj.magic x : int) in
  if (x < 0) then (
  __ret := (Obj.magic ((0 - x)) : int); raise Return
  ) else (
  __ret := (Obj.magic (x) : int); raise Return
  );
    !__ret
  with Return -> !__ret)

and visible h r1 c1 r2 c2 =
  let __ret = ref false in
  (try
  let h = (Obj.magic h : int list list) in
  let r1 = (Obj.magic r1 : int) in
  let c1 = (Obj.magic c1 : int) in
  let r2 = (Obj.magic r2 : int) in
  let c2 = (Obj.magic c2 : int) in
  if ((r1 = r2) && (c1 = c2)) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  let h0 = (let __l = (let __l = h in let __i = r1 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []) in let __i = c1 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let h1 = (let __l = (let __l = h in let __i = r2 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []) in let __i = c2 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let dr = ref ((r2 - r1)) in
  let dc = ref ((c2 - c1)) in
  let steps = ref (abs !dr) in
  if (abs !dc > !steps) then (
  steps := abs !dc;
  );
  let x = ref ((float_of_int (c1) +. 0.5)) in
  let y = ref ((float_of_int (r1) +. 0.5)) in
  let z = ref ((float_of_int (h0) +. 0.5)) in
  let incX = ref ((float_of_int (!dc) /. float_of_int (!steps))) in
  let incY = ref ((float_of_int (!dr) /. float_of_int (!steps))) in
  let incZ = ref ((float_of_int ((h1 - h0)) /. float_of_int (!steps))) in
  let i = ref (1) in
  (try while (!i < !steps) do
    try
  x := (!x +. !incX);
  y := (!y +. !incY);
  z := (!z +. !incZ);
  let cx = int_of_float (!x) in
  let cy = int_of_float (!y) in
  if (!z <= float_of_int ((let __l = (let __l = h in let __i = cy in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []) in let __i = cx in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0))) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)

and computeVis h _p _q r c =
  let __ret = ref ([] : (bool list) list) in
  (try
  let h = (Obj.magic h : int list list) in
  let _p = (Obj.magic _p : int) in
  let _q = (Obj.magic _q : int) in
  let r = (Obj.magic r : int) in
  let c = (Obj.magic c : int) in
  let vis = ref (([] : (bool list) list)) in
  (try for i = 0 to (_p - 1) do
    try
  let row = ref (([] : (bool) list)) in
  (try for j = 0 to (_q - 1) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic (visible (h) (Obj.repr (i)) (Obj.repr (j)) (Obj.repr (r)) (Obj.repr (c))) : bool)])) : bool list);
    with Continue -> ()
  done with Break -> ());
  vis := (Obj.magic ((List.append (!vis) [(Obj.magic (!row) : bool list)])) : bool list list);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!vis) : bool list list); raise Return
  with Return -> !__ret)

and bfs h vis1 vis2 _p _q r1 c1 r2 c2 =
  let __ret = ref 0 in
  (try
  let h = (Obj.magic h : int list list) in
  let vis1 = (Obj.magic vis1 : bool list list) in
  let vis2 = (Obj.magic vis2 : bool list list) in
  let _p = (Obj.magic _p : int) in
  let _q = (Obj.magic _q : int) in
  let r1 = (Obj.magic r1 : int) in
  let c1 = (Obj.magic c1 : int) in
  let r2 = (Obj.magic r2 : int) in
  let c2 = (Obj.magic c2 : int) in
  let dist = ref (([] : (int list) list)) in
  (try for i = 0 to (_p - 1) do
    try
  let row = ref (([] : (int) list)) in
  (try for j = 0 to (_q - 1) do
    try
  row := (Obj.magic ((List.append (!row) [(Obj.magic ((0 - 1)) : int)])) : int list);
    with Continue -> ()
  done with Break -> ());
  dist := (Obj.magic ((List.append (!dist) [(Obj.magic (!row) : int list)])) : int list list);
    with Continue -> ()
  done with Break -> ());
  let qr = ref (([] : (int) list)) in
  let qc = ref (([] : (int) list)) in
  qr := (Obj.magic ((List.append (!qr) [(Obj.magic (r1) : int)])) : int list);
  qc := (Obj.magic ((List.append (!qc) [(Obj.magic (c1) : int)])) : int list);
  dist := (List.mapi (fun __i __x -> if __i = r1 then (List.mapi (fun __i __x -> if __i = c1 then 0 else __x) ((let __l = !dist in let __i = r1 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []))) else __x) (!dist));
  let head = ref (0) in
  let drs = ref ([-(1); 1; 0; 0]) in
  let dcs = ref ([0; 0; -(1); 1]) in
  (try while (!head < List.length (!qr)) do
    try
  let r = (let __l = !qr in let __i = !head in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let c = (let __l = !qc in let __i = !head in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  head := (!head + 1);
  if ((r = r2) && (c = c2)) then (
  raise Break;
  );
  let hcur = (let __l = (let __l = h in let __i = r in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []) in let __i = c in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let k = ref (0) in
  (try while (!k < 4) do
    try
  let nr = (r + (let __l = !drs in let __i = !k in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) in
  let nc = (c + (let __l = !dcs in let __i = !k in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) in
  if ((((nr >= 0) && (nr < _p)) && (nc >= 0)) && (nc < _q)) then (
  if ((let __l = (let __l = !dist in let __i = nr in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []) in let __i = nc in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) = (0 - 1)) then (
  let nh = (let __l = (let __l = h in let __i = nr in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []) in let __i = nc in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  if ((nh <= (hcur + 1)) && (nh >= (hcur - 3))) then (
  if ((let __l = (let __l = vis1 in let __i = nr in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : bool list) | None -> []) in let __i = nc in if __i < 0 then false else match List.nth_opt __l __i with Some v -> (Obj.magic v : bool) | None -> false) || (let __l = (let __l = vis2 in let __i = nr in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : bool list) | None -> []) in let __i = nc in if __i < 0 then false else match List.nth_opt __l __i with Some v -> (Obj.magic v : bool) | None -> false)) then (
  dist := (List.mapi (fun __i __x -> if __i = nr then (List.mapi (fun __i __x -> if __i = nc then ((let __l = (let __l = !dist in let __i = r in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []) in let __i = c in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) + 1) else __x) ((let __l = !dist in let __i = nr in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []))) else __x) (!dist));
  qr := (Obj.magic ((List.append (!qr) [(Obj.magic (nr) : int)])) : int list);
  qc := (Obj.magic ((List.append (!qc) [(Obj.magic (nc) : int)])) : int list);
  );
  );
  );
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((let __l = (let __l = !dist in let __i = r2 in if __i < 0 then [] else match List.nth_opt __l __i with Some v -> (Obj.magic v : int list) | None -> []) in let __i = c2 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0)) : int); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let tStr = (try read_line () with End_of_file -> "") in
  if (tStr = "") then (
  __ret := (); raise Return
  );
  let _t = parseInt (tStr) in
  (try for _ = 0 to (_t - 1) do
    try
  let line = ref ((try read_line () with End_of_file -> "")) in
  (try while (!line = "") do
    try
  line := (try read_line () with End_of_file -> "");
    with Continue -> ()
  done with Break -> ());
  let dims = ref (parseInts (!line)) in
  let _p = (let __l = !dims in let __i = 0 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let _q = (let __l = !dims in let __i = 1 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) in
  let h = ref (([] : (int list) list)) in
  (try for i = 0 to (_p - 1) do
    try
  let rowVals = ref (parseInts ((try read_line () with End_of_file -> ""))) in
  h := (Obj.magic ((List.append (!h) [(Obj.magic (!rowVals) : int list)])) : int list list);
    with Continue -> ()
  done with Break -> ());
  let posLine = (try read_line () with End_of_file -> "") in
  let pos = ref (parseInts (posLine)) in
  let r1 = ((let __l = !pos in let __i = 0 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) - 1) in
  let c1 = ((let __l = !pos in let __i = 1 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) - 1) in
  let r2 = ((let __l = !pos in let __i = 2 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) - 1) in
  let c2 = ((let __l = !pos in let __i = 3 in if __i < 0 then 0 else match List.nth_opt __l __i with Some v -> (Obj.magic v : int) | None -> 0) - 1) in
  let vis1 = ref (computeVis (!h) (Obj.repr (_p)) (Obj.repr (_q)) (Obj.repr (r1)) (Obj.repr (c1))) in
  let vis2 = ref (computeVis (!h) (Obj.repr (_p)) (Obj.repr (_q)) (Obj.repr (r2)) (Obj.repr (c2))) in
  let res = bfs (!h) (!vis1) (!vis2) (Obj.repr (_p)) (Obj.repr (_q)) (Obj.repr (r1)) (Obj.repr (c1)) (Obj.repr (r2)) (Obj.repr (c2)) in
  if (res = (0 - 1)) then (
  print_endline ("Mission impossible!");
  ) else (
  print_endline ((("The shortest path is " ^ (string_of_int (Obj.magic (res) : int))) ^ " steps long."));
  );
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)


let () =
  ignore (main ());
  ()
