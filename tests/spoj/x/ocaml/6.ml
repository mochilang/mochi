(* Generated by Mochi transpiler v0.10.74 on 2025-08-26 14:25 +0700 *)


let rec __is_list v =
  let open Obj in
  let rec loop x =
    let r = repr x in
    if is_int r then (magic r : int) = 0
    else
      match tag r with
      | 0 -> loop (field r 1)
      | _ -> false
  in
  loop v

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0

exception Break
exception Continue

exception Return

let digitMap = ref ([(__str (Obj.repr ("0")), 0); (__str (Obj.repr ("1")), 1); (__str (Obj.repr ("2")), 2); (__str (Obj.repr ("3")), 3); (__str (Obj.repr ("4")), 4); (__str (Obj.repr ("5")), 5); (__str (Obj.repr ("6")), 6); (__str (Obj.repr ("7")), 7); (__str (Obj.repr ("8")), 8); (__str (Obj.repr ("9")), 9)])
let rec repeat s n =
  let __ret = ref "" in
  (try
  let n = (Obj.magic n : int) in
  let r = ref ("") in
  (try for _ = 0 to (n - 1) do
    try
  r := (!r ^ s);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!r) : string); raise Return
  with Return -> !__ret)

and add_str a b =
  let __ret = ref "" in
  (try
  let i = ref ((String.length (a) - 1)) in
  let j = ref ((String.length (b) - 1)) in
  let carry = ref (0) in
  let res = ref ("") in
  (try while (((!i >= 0) || (!j >= 0)) || (!carry > 0)) do
    try
  let da = ref (0) in
  if (!i >= 0) then (
  da := (match List.assoc_opt (__str (Obj.repr ((let __s = a in let __st = !i in let __len = ((!i + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")))) (!digitMap) with Some v -> (Obj.magic v : int) | None -> 0);
  );
  let db = ref (0) in
  if (!j >= 0) then (
  db := (match List.assoc_opt (__str (Obj.repr ((let __s = b in let __st = !j in let __len = ((!j + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")))) (!digitMap) with Some v -> (Obj.magic v : int) | None -> 0);
  );
  let sum = ref (((!da + !db) + !carry)) in
  res := ((string_of_int (Obj.magic (((!sum mod 10 + 10) mod 10)) : int)) ^ !res);
  carry := (!sum / 10);
  i := (!i - 1);
  j := (!j - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : string); raise Return
  with Return -> !__ret)

and sub_str a b =
  let __ret = ref "" in
  (try
  let i = ref ((String.length (a) - 1)) in
  let j = ref ((String.length (b) - 1)) in
  let borrow = ref (0) in
  let res = ref ("") in
  (try while (!i >= 0) do
    try
  let da = ref (((match List.assoc_opt (__str (Obj.repr ((let __s = a in let __st = !i in let __len = ((!i + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")))) (!digitMap) with Some v -> (Obj.magic v : int) | None -> 0) - !borrow)) in
  let db = ref (0) in
  if (!j >= 0) then (
  db := (match List.assoc_opt (__str (Obj.repr ((let __s = b in let __st = !j in let __len = ((!j + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")))) (!digitMap) with Some v -> (Obj.magic v : int) | None -> 0);
  );
  if (!da < !db) then (
  da := (!da + 10);
  borrow := 1;
  ) else (
  borrow := 0;
  );
  let diff = ref ((!da - !db)) in
  res := ((string_of_int (Obj.magic (!diff) : int)) ^ !res);
  i := (!i - 1);
  j := (!j - 1);
    with Continue -> ()
  done with Break -> ());
  let k = ref (0) in
  (try while ((!k < String.length (!res)) && ((let __s = !res in let __st = !k in let __len = ((!k + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") = "0")) do
    try
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  if (!k = String.length (!res)) then (
  __ret := (Obj.magic ("0") : string); raise Return
  );
  __ret := (Obj.magic ((let __s = !res in let __st = !k in let __len = (String.length (!res) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")) : string); raise Return
  with Return -> !__ret)

and mul_digit a d =
  let __ret = ref "" in
  (try
  let d = (Obj.magic d : int) in
  if (d = 0) then (
  __ret := (Obj.magic ("0") : string); raise Return
  );
  let i = ref ((String.length (a) - 1)) in
  let carry = ref (0) in
  let res = ref ("") in
  (try while (!i >= 0) do
    try
  let prod = ref ((((match List.assoc_opt (__str (Obj.repr ((let __s = a in let __st = !i in let __len = ((!i + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")))) (!digitMap) with Some v -> (Obj.magic v : int) | None -> 0) * d) + !carry)) in
  res := ((string_of_int (Obj.magic (((!prod mod 10 + 10) mod 10)) : int)) ^ !res);
  carry := (!prod / 10);
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  if (!carry > 0) then (
  res := ((string_of_int (Obj.magic (!carry) : int)) ^ !res);
  );
  let k = ref (0) in
  (try while ((!k < String.length (!res)) && ((let __s = !res in let __st = !k in let __len = ((!k + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") = "0")) do
    try
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  if (!k = String.length (!res)) then (
  __ret := (Obj.magic ("0") : string); raise Return
  );
  __ret := (Obj.magic ((let __s = !res in let __st = !k in let __len = (String.length (!res) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")) : string); raise Return
  with Return -> !__ret)

and mul_str a b =
  let __ret = ref [] in
  (try
  let result = ref ("0") in
  let shift = ref (0) in
  let parts = ref (([] : (Obj.t) list)) in
  let i = ref ((String.length (b) - 1)) in
  (try while (!i >= 0) do
    try
  let d = (match List.assoc_opt (__str (Obj.repr ((let __s = b in let __st = !i in let __len = ((!i + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "")))) (!digitMap) with Some v -> (Obj.magic v : int) | None -> 0) in
  let part = mul_digit (a) (Obj.repr (d)) in
  parts := (Obj.magic ((List.append (!parts) [(Obj.magic ([(__str (Obj.repr ("val")), Obj.repr (part)); (__str (Obj.repr ("shift")), Obj.repr (!shift))]) : Obj.t)])) : Obj.t list);
  let shifted = ref (part) in
  (try for _ = 0 to (!shift - 1) do
    try
  shifted := (!shifted ^ "0");
    with Continue -> ()
  done with Break -> ());
  result := add_str (!result) (!shifted);
  shift := (!shift + 1);
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([(__str (Obj.repr ("res")), Obj.repr (!result)); (__str (Obj.repr ("parts")), Obj.repr (!parts))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and pad_left s total =
  let __ret = ref "" in
  (try
  let total = (Obj.magic total : int) in
  let r = ref ("") in
  (try for _ = 0 to ((total - String.length (s)) - 1) do
    try
  r := (!r ^ " ");
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!r ^ s)) : string); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let tStr = (try read_line () with End_of_file -> "") in
  if (tStr = "") then (
  __ret := (); raise Return
  );
  let t = int_of_string (tStr) in
  (try for _ = 0 to (t - 1) do
    try
  let line = ref ((try read_line () with End_of_file -> "")) in
  if (!line = "") then (
  raise Continue;
  );
  let idx = ref (0) in
  (try while (!idx < String.length (!line)) do
    try
  let ch = (let __s = !line in let __st = !idx in let __len = ((!idx + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") in
  if (((ch = "+") || (ch = "-")) || (ch = "*")) then (
  raise Break;
  );
  idx := (!idx + 1);
    with Continue -> ()
  done with Break -> ());
  let a = (let __s = !line in let __st = 0 in let __len = (!idx - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") in
  let op = (let __s = !line in let __st = !idx in let __len = ((!idx + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") in
  let b = (let __s = !line in let __st = (!idx + 1) in let __len = (String.length (!line) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else "") in
  let res = ref ("") in
  let parts = ref (([] : (Obj.t) list)) in
  if (op = "+") then (
  res := add_str (a) (b);
  ) else (
  if (op = "-") then (
  res := sub_str (a) (b);
  ) else (
  let r = ref (mul_str (a) (b)) in
  res := (match List.assoc_opt (__str (Obj.repr ("res"))) (Obj.magic (!r) : (string * Obj.t) list) with Some v -> (Obj.magic v : string) | None -> "");
  parts := (Obj.magic ((Obj.magic ((match List.assoc_opt (__str (Obj.repr ("parts"))) (Obj.magic (!r) : (string * Obj.t) list) with Some v -> (Obj.magic v : Obj.t) | None -> Obj.repr 0)) : Obj.t list)) : Obj.t list);
  );
  );
  let width = ref (String.length (a)) in
  let secondLen = (String.length (b) + 1) in
  if (secondLen > !width) then (
  width := secondLen;
  );
  if (String.length (!res) > !width) then (
  width := String.length (!res);
  );
  (try List.iter (fun p ->
    try
  let l = (String.length ((Obj.magic ((match List.assoc_opt (__str (Obj.repr ("val"))) (Obj.magic (p) : (string * Obj.t) list) with Some v -> (Obj.magic v : Obj.t) | None -> Obj.repr 0)) : string)) + (Obj.magic ((match List.assoc_opt (__str (Obj.repr ("shift"))) (Obj.magic (p) : (string * Obj.t) list) with Some v -> (Obj.magic v : Obj.t) | None -> Obj.repr 0)) : int)) in
  if (l > !width) then (
  width := l;
  );
    with Continue -> ()) (!parts) with Break -> ());
  print_endline ((pad_left (a) (Obj.repr (!width))));
  print_endline ((pad_left ((op ^ b)) (Obj.repr (!width))));
  let dash1 = ref (0) in
  if (op = "*") then (
  if (List.length (!parts) > 0) then (
  dash1 := (String.length (b) + 1);
  let firstPart = (Obj.magic ((match List.assoc_opt (__str (Obj.repr ("val"))) (Obj.magic ((let __l = !parts in let __i = 0 in if __i < 0 then ([] : (string * Obj.t) list) else match List.nth_opt __l __i with Some v -> (Obj.magic v : (string * Obj.t) list) | None -> ([] : (string * Obj.t) list))) : (string * Obj.t) list) with Some v -> (Obj.magic v : Obj.t) | None -> Obj.repr 0)) : string) in
  if (String.length (firstPart) > !dash1) then (
  dash1 := String.length (firstPart);
  );
  ) else (
  dash1 := (String.length (b) + 1);
  if (String.length (!res) > !dash1) then (
  dash1 := String.length (!res);
  );
  );
  ) else (
  dash1 := (String.length (b) + 1);
  if (String.length (!res) > !dash1) then (
  dash1 := String.length (!res);
  );
  );
  print_endline ((pad_left (repeat ("-") (Obj.repr (!dash1))) (Obj.repr (!width))));
  if ((op = "*") && (String.length (b) > 1)) then (
  (try List.iter (fun p ->
    try
  let val_ = (Obj.magic ((match List.assoc_opt (__str (Obj.repr ("val"))) (Obj.magic (p) : (string * Obj.t) list) with Some v -> (Obj.magic v : Obj.t) | None -> Obj.repr 0)) : string) in
  let shift = (Obj.magic ((match List.assoc_opt (__str (Obj.repr ("shift"))) (Obj.magic (p) : (string * Obj.t) list) with Some v -> (Obj.magic v : Obj.t) | None -> Obj.repr 0)) : int) in
  let spaces = ((!width - shift) - String.length (val_)) in
  let line = ref ("") in
  (try for _ = 0 to (spaces - 1) do
    try
  line := (!line ^ " ");
    with Continue -> ()
  done with Break -> ());
  line := (!line ^ val_);
  print_endline (!line);
    with Continue -> ()) (!parts) with Break -> ());
  print_endline ((pad_left (repeat ("-") (Obj.repr (String.length (!res)))) (Obj.repr (!width))));
  );
  print_endline ((pad_left (!res) (Obj.repr (!width))));
  print_endline ("");
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)


let () =
  ignore (main ());
  ()
