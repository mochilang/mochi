(* Generated by Mochi transpiler v0.10.74 on 2025-08-26 11:55 +0700 *)


let rec __is_list v =
  let open Obj in
  let rec loop x =
    let r = repr x in
    if is_int r then (magic r : int) = 0
    else
      match tag r with
      | 0 -> loop (field r 1)
      | _ -> false
  in
  loop v

let rec __show v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __show_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __show_tuple (Obj.magic v)
    | 252 -> Printf.sprintf "'%s'" (String.escaped (magic v : string))
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __show_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __show l) ^ "]"
and __show_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __show (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"
and __str v =
  let open Obj in
  let r = repr v in
  if __is_list v then
    __str_list (Obj.magic v)
  else if is_int r then
    string_of_int (magic v : int)
  else
    match tag r with
    | 0 -> __str_tuple (Obj.magic v)
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"
and __str_list l =
  match l with
  | [] -> "[]"
  | _ -> "[" ^ String.concat " " (List.map __str l) ^ "]"
and __str_tuple t =
  let open Obj in
  let r = repr t in
  let rec aux i =
    if i >= size r then []
    else __str (Obj.obj (field r i)) :: aux (i + 1)
  in
  "(" ^ String.concat ", " (aux 0) ^ ")"


let nil = Obj.repr 0

exception Break
exception Continue

exception Return

let rec split s sep =
  let __ret = ref ([] : (string) list) in
  (try
  let parts = ref (([] : (string) list)) in
  let cur = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if (((String.length (sep) > 0) && ((!i + String.length (sep)) <= String.length (s))) && ((let __s = s in let __st = !i in let __en = (!i + String.length (sep)) in let __len_s = String.length __s in let __st = (if __st < 0 then __len_s + __st else __st) in let __en = (if __en < 0 then __len_s + __en else __en) in let __st = if __st < 0 then 0 else if __st > __len_s then __len_s else __st in let __en = if __en < 0 then 0 else if __en > __len_s then __len_s else __en in if __st >= __en then "" else String.sub __s __st (__en - __st)) = sep)) then (
  parts := (Obj.magic ((List.append (!parts) [(Obj.magic (!cur) : string)])) : string list);
  cur := "";
  i := (!i + String.length (sep));
  ) else (
  cur := (!cur ^ (let __s = s in let __st = !i in let __len = ((!i + 1) - __st) in if __st + __len <= String.length __s then String.sub __s __st __len else ""));
  i := (!i + 1);
  );
    with Continue -> ()
  done with Break -> ());
  parts := (Obj.magic ((List.append (!parts) [(Obj.magic (!cur) : string)])) : string list);
  __ret := (Obj.magic (!parts) : string list); raise Return
  with Return -> !__ret)

and precompute limit =
  let __ret = ref ([] : (int) list) in
  (try
  let limit = (Obj.magic limit : int) in
  let sieve = ref (([] : (bool) list)) in
  (try for i = 0 to ((limit + 1) - 1) do
    try
  sieve := (Obj.magic ((List.append (!sieve) [(Obj.magic (true) : bool)])) : bool list);
    with Continue -> ()
  done with Break -> ());
  sieve := (List.mapi (fun __i __x -> if __i = 0 then false else __x) (!sieve));
  sieve := (List.mapi (fun __i __x -> if __i = 1 then false else __x) (!sieve));
  let p = ref (2) in
  (try while ((!p * !p) <= limit) do
    try
  if (let __l = !sieve in let __i = !p in if __i < 0 then false else match List.nth_opt __l __i with Some v -> (Obj.magic v : bool) | None -> false) then (
  let j = ref ((!p * !p)) in
  (try while (!j <= limit) do
    try
  sieve := (List.mapi (fun __i __x -> if __i = !j then false else __x) (!sieve));
  j := (!j + !p);
    with Continue -> ()
  done with Break -> ());
  );
  p := (!p + 1);
    with Continue -> ()
  done with Break -> ());
  let primes = ref (([] : (int) list)) in
  (try for i = 2 to ((limit + 1) - 1) do
    try
  if (let __l = !sieve in let __i = i in if __i < 0 then false else match List.nth_opt __l __i with Some v -> (Obj.magic v : bool) | None -> false) then (
  primes := (Obj.magic ((List.append (!primes) [(Obj.magic (i) : int)])) : int list);
  );
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!primes) : int list); raise Return
  with Return -> !__ret)


let primes = ref (precompute (Obj.repr (32000)))
let t = int_of_string ((try read_line () with End_of_file -> ""))
let case_idx = ref (0)
let () =
  (try while (!case_idx < t) do
    try
  let line = (try read_line () with End_of_file -> "") in
  let parts = ref (split (line) (" ")) in
  let m = int_of_string ((let __l = !parts in let __i = 0 in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "")) in
  let n = int_of_string ((let __l = !parts in let __i = 1 in if __i < 0 then "" else match List.nth_opt __l __i with Some v -> (Obj.magic v : string) | None -> "")) in
  let size = ((n - m) + 1) in
  let segment = ref (([] : (bool) list)) in
  (try for i = 0 to (size - 1) do
    try
  segment := (Obj.magic ((List.append (!segment) [(Obj.magic (true) : bool)])) : bool list);
    with Continue -> ()
  done with Break -> ());
  (try List.iter (fun p ->
    try
  if ((p * p) > n) then (
  raise Break;
  );
  let start = ref ((p * p)) in
  if (!start < m) then (
  let rem = ((m mod p + p) mod p) in
  if (rem = 0) then (
  start := m;
  ) else (
  start := (m + (p - rem));
  );
  );
  let j = ref (!start) in
  (try while (!j <= n) do
    try
  segment := (List.mapi (fun __i __x -> if __i = (!j - m) then false else __x) (!segment));
  j := (!j + p);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()) (!primes) with Break -> ());
  if (m = 1) then (
  segment := (List.mapi (fun __i __x -> if __i = 0 then false else __x) (!segment));
  );
  let i = ref (0) in
  (try while (!i < size) do
    try
  if (let __l = !segment in let __i = !i in if __i < 0 then false else match List.nth_opt __l __i with Some v -> (Obj.magic v : bool) | None -> false) then (
  print_endline (string_of_int (!i + m));
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (!case_idx < (t - 1)) then (
  print_endline ("");
  );
  case_idx := (!case_idx + 1);
    with Continue -> ()
  done with Break -> ());
  ()
