-- Generated by Mochi v0.10.74 on 2025-08-27 07:05 GMT+7
function input()
  local line = io.read('*l')
  if line == nil then return '' end
  return line
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _len(v)
if type(v) == 'table' and v.items ~= nil then
  return #v.items
elseif type(v) == 'table' and (v[1] == nil or v[0] ~= nil) then
    local c = 0
    for k in pairs(v) do
      if k ~= '__name' and k ~= '__order' then
        c = c + 1
      end
    end
    return c
  elseif type(v) == 'string' then
      local l = utf8.len(v)
      if l then return l end
      return #v
    elseif type(v) == 'table' then
        return #v
      else
        return 0
      end
    end
    
    local function _str(v)
    if type(v) == 'number' then
      local s = tostring(v)
      s = string.gsub(s, '%.0+$', '')
      return s
    elseif type(v) == 'boolean' then
        if v then return 'true' else return 'false' end
      elseif type(v) == 'table' then
          local src = v
          if v.items ~= nil then
            src = v.items
          end
          local parts = {}
          for i = 1, #src do
            parts[#parts+1] = _str(src[i])
          end
          return '[' .. table.concat(parts, ', ') .. ']'
        end
        return tostring(v)
      end
      
      local function _split(s, sep)
      local t = {}
      local pattern = string.format("([^%s]+)", sep)
      string.gsub(s, pattern, function(c) t[#t+1] = c end)
      return t
    end
    do
      collectgarbage()
      local _bench_start_mem = collectgarbage('count') * 1024
      local _bench_start = os.clock()
      function parseInt(s)
        local i = 0
        local n = 0
        while (i < _len(s)) do
          n = ((n * 10) + (function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)(digits[string.sub(s, (i + 1), (i + 1))]))
          i = (i + 1)
        end
        return n
      end
      function split(s)
        local parts = {}
        local cur = ""
        local i = 0
        while (i < _len(s)) do
          local ch = string.sub(s, (i + 1), (i + 1))
          if (ch == " ") then
            if (_len(cur) > 0) then
              parts = (function(lst, item)
              local res = {table.unpack(lst or {})}
              res[#res+1] = item
              return res
            end)(parts, cur)
            cur = ""
          end
        else
          cur = (cur .. ch)
        end
        i = (i + 1)
      end
      if (_len(cur) > 0) then
        parts = (function(lst, item)
        local res = {table.unpack(lst or {})}
        res[#res+1] = item
        return res
      end)(parts, cur)
    end
    return parts
  end
  function absf(x)
    if (x < 0.0) then
      return (-x)
    else
      return x
    end
  end
  function sqrt(x)
    if (x <= 0.0) then
      return 0.0
    end
    local r = x
    local prev = 0.0
    while (absf((r - prev)) > 1e-12) do
      prev = r
      r = ((r + (x / r)) / 2.0)
    end
    return r
  end
  function makeBoolGrid(P, Q)
    local g = {}
    local i = 0
    while (i < P) do
      local row = {}
      local j = 0
      while (j < Q) do
        row = (function(lst, item)
        local res = {table.unpack(lst or {})}
        res[#res+1] = item
        return res
      end)(row, false)
      j = (j + 1)
    end
    g = (function(lst, item)
    local res = {table.unpack(lst or {})}
    res[#res+1] = item
    return res
  end)(g, row)
  i = (i + 1)
end
return g
end
function visible(grid, P, Q, R, C, BR, BC)
  local X1 = (C - 0.5)
  local Y1 = (R - 0.5)
  local Z1 = (grid[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((R - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((C - 1)) + 1] + 0.5)
  local X2 = (BC - 0.5)
  local Y2 = (BR - 0.5)
  local Z2 = (grid[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((BR - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((BC - 1)) + 1] + 0.5)
  local Dx = (X2 - X1)
  local Dy = (Y2 - Y1)
  local Dz = (Z2 - Z1)
  local dist = sqrt((((Dx * Dx) + (Dy * Dy)) + (Dz * Dz)))
  local steps = ((function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((dist * 20.0)) + 1)
  local stepT = (1.0 / steps)
  local i = 1
  while (i < steps) do
    local t = (stepT * i)
    local X = (X1 + (Dx * t))
    local Y = (Y1 + (Dy * t))
    local Z = (Z1 + (Dz * t))
    local rIdx = ((function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)(Y) + 1)
    local cIdx = ((function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)(X) + 1)
    if ((((rIdx < 1) or (rIdx > P)) or (cIdx < 1)) or (cIdx > Q)) then
      return false
    end
    local H = grid[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((rIdx - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((cIdx - 1)) + 1]
    if (Z <= H) then
      return false
    end
    i = (i + 1)
  end
  return true
end
function computeVis(grid, P, Q, BR, BC)
  local vis = makeBoolGrid(P, Q)
  local r = 1
  while (r <= P) do
    local c = 1
    while (c <= Q) do
      vis[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((r - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((c - 1)) + 1] = visible(grid, P, Q, r, c, BR, BC)
      c = (c + 1)
    end
    r = (r + 1)
  end
  return vis
end
function bfs(grid, P, Q, R1, C1, R2, C2)
  local vis1 = computeVis(grid, P, Q, R1, C1)
  local vis2 = computeVis(grid, P, Q, R2, C2)
  local visited = makeBoolGrid(P, Q)
  local qR = {}
  local qC = {}
  local qD = {}
  qR = (function(lst, item)
  local res = {table.unpack(lst or {})}
  res[#res+1] = item
  return res
end)(qR, R1)
qC = (function(lst, item)
local res = {table.unpack(lst or {})}
res[#res+1] = item
return res
end)(qC, C1)
qD = (function(lst, item)
local res = {table.unpack(lst or {})}
res[#res+1] = item
return res
end)(qD, 0)
visited[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((R1 - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((C1 - 1)) + 1] = true
local head = 0
while (head < _len(qR)) do
  local r = qR[head + 1]
  local c = qC[head + 1]
  local d = qD[head + 1]
  if ((r == R2) and (c == C2)) then
    return d
  end
  local hr = grid[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((r - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((c - 1)) + 1]
  local idx = 0
  while (idx < 4) do
    local nr = r
    local nc = c
    if (idx == 0) then
      nr = (nr - 1)
    end
    if (idx == 1) then
      nr = (nr + 1)
    end
    if (idx == 2) then
      nc = (nc - 1)
    end
    if (idx == 3) then
      nc = (nc + 1)
    end
    if ((((nr >= 1) and (nr <= P)) and (nc >= 1)) and (nc <= Q)) then
      if (not visited[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nr - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nc - 1)) + 1]) then
        local hn = grid[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nr - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nc - 1)) + 1]
        local diff = (hn - hr)
        if ((diff <= 1) and (diff >= (0 - 3))) then
          if (vis1[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nr - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nc - 1)) + 1] or vis2[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nr - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nc - 1)) + 1]) then
            visited[(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nr - 1)) + 1][(function(v) if type(v)=='string' then v=tonumber(v) or 0 end if v >= 0 then return math.floor(v) else return math.ceil(v) end end)((nc - 1)) + 1] = true
            qR = (function(lst, item)
            local res = {table.unpack(lst or {})}
            res[#res+1] = item
            return res
          end)(qR, nr)
          qC = (function(lst, item)
          local res = {table.unpack(lst or {})}
          res[#res+1] = item
          return res
        end)(qC, nc)
        qD = (function(lst, item)
        local res = {table.unpack(lst or {})}
        res[#res+1] = item
        return res
      end)(qD, (d + 1))
    end
  end
end
end
idx = (idx + 1)
end
head = (head + 1)
end
return (-1)
end
function main()
  local tLine = input()
  if (tLine == "") then
    return
  end
  local t = parseInt(tLine)
  local case = 0
  while (case < t) do
    local line = input()
    while (line == "") do
      line = input()
    end
    local pq = split(line)
    local P = parseInt(pq[0 + 1])
    local Q = parseInt(pq[1 + 1])
    local grid = {}
    local r = 0
    while (r < P) do
      local rowParts = split(input())
      local row = {}
      local c = 0
      while (c < Q) do
        row = (function(lst, item)
        local res = {table.unpack(lst or {})}
        res[#res+1] = item
        return res
      end)(row, parseInt(rowParts[c + 1]))
      c = (c + 1)
    end
    grid = (function(lst, item)
    local res = {table.unpack(lst or {})}
    res[#res+1] = item
    return res
  end)(grid, row)
  r = (r + 1)
end
local coords = split(input())
local R1 = parseInt(coords[0 + 1])
local C1 = parseInt(coords[1 + 1])
local R2 = parseInt(coords[2 + 1])
local C2 = parseInt(coords[3 + 1])
local res = bfs(grid, P, Q, R1, C1, R2, C2)
if (res < 0) then
  print("Mission impossible!")
else
  print((((type((("The shortest path is " .. _str(res)) .. " steps long.")) == "table")) and (
  (function(v)
  local function encode(x)
  if type(x) == "table" then
    if x.__name and x.__order then
      local parts = {x.__name, " {"}
      for i, k in ipairs(x.__order) do
        if i > 1 then parts[#parts+1] = ", " end
        parts[#parts+1] = k .. " = " .. encode(x[k])
      end
      parts[#parts+1] = "}"
      return table.concat(parts)
    elseif #x > 0 then
        local allTables = true
        for _, v in ipairs(x) do
          if type(v) ~= "table" then allTables = false break end
        end
        local parts = {}
        if not allTables then parts[#parts+1] = "[" end
        for i, val in ipairs(x) do
          parts[#parts+1] = encode(val)
          if i < #x then parts[#parts+1] = " " end
        end
        if not allTables then parts[#parts+1] = "]" end
        return table.concat(parts)
      else
        local keys = {}
        for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
        table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
        local parts = {"{"}
        for i, k in ipairs(keys) do
          parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
          if i < #keys then parts[#parts+1] = ", " end
        end
        parts[#parts+1] = "}"
        return table.concat(parts)
      end
    elseif type(x) == "number" then
        if math.type and math.type(x) == "integer" then
          return string.format("%d", x)
        else
          local s = string.format("%g", x)
          if not string.find(s, "[%.eE]") then
            s = s .. ".0"
          end
          return s
        end
      elseif type(x) == "string" then
          return '"' .. x .. '"'
        else
          return tostring(x)
        end
      end
      return encode(v)
    end)((("The shortest path is " .. _str(res)) .. " steps long."))) or ((("The shortest path is " .. _str(res)) .. " steps long."))))
  end
  case = (case + 1)
end
end
digits = {__name = "GenType1", __order = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}, ["0"] = 0, ["1"] = 1, ["2"] = 2, ["3"] = 3, ["4"] = 4, ["5"] = 5, ["6"] = 6, ["7"] = 7, ["8"] = 8, ["9"] = 9}
main()
local _bench_end = os.clock()
collectgarbage()
local _bench_end_mem = collectgarbage('count') * 1024
local _bench_duration_us = math.floor((_bench_end - _bench_start) * 1000000)
local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
end;
