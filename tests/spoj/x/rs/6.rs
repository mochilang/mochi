// Generated by Mochi transpiler v0.10.74
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
use std::io::{self, Read};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn input() -> String {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).unwrap();
    s.trim_end().to_string()
}
fn int(x: i64) -> i64 { x }
fn main() {
        let _start: i64 = _now();;
    let digitMap: HashMap<String, i64> = HashMap::from([(String::from("0"), 0), (String::from("1"), 1), (String::from("2"), 2), (String::from("3"), 3), (String::from("4"), 4), (String::from("5"), 5), (String::from("6"), 6), (String::from("7"), 7), (String::from("8"), 8), (String::from("9"), 9)]);;
    fn repeat(mut s: String, mut n: i64) -> String {
    let mut r: String = String::new();;
    for _ in 0..n {
        r = format!("{}{}", r, s);
    }
    return r.clone()
};
    fn add_str(mut a: String, mut b: String) -> String {
    let mut i: i64 = ((a.len() as i64) - 1);;
    let mut j: i64 = ((b.len() as i64) - 1);;
    let mut carry: i64 = 0;;
    let mut res: String = String::new();;
    while (((i >= 0) || (j >= 0)) || (carry > 0)) {
        let mut da: i64 = 0;;
        if (i >= 0) {
            da = digitMap.get(a.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().as_str()).cloned().unwrap_or_default();
        }
        let mut db: i64 = 0;;
        if (j >= 0) {
            db = digitMap.get(b.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>().as_str()).cloned().unwrap_or_default();
        }
        let mut sum: i64 = ((da + db) + carry);;
        res = format!("{}{}", (sum % 10).to_string(), res);
        carry = (sum / 10);
        i = (i - 1);
        j = (j - 1);
    }
    return res.clone()
};
    fn sub_str(mut a: String, mut b: String) -> String {
    let mut i: i64 = ((a.len() as i64) - 1);;
    let mut j: i64 = ((b.len() as i64) - 1);;
    let mut borrow: i64 = 0;;
    let mut res: String = String::new();;
    while (i >= 0) {
        let mut da: i64 = (digitMap.get(a.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().as_str()).cloned().unwrap_or_default() - borrow);;
        let mut db: i64 = 0;;
        if (j >= 0) {
            db = digitMap.get(b.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>().as_str()).cloned().unwrap_or_default();
        }
        if (da < db) {
            da = (da + 10);
            borrow = 1;
        } else {
            borrow = 0;
        }
        let mut diff: i64 = (da - db);;
        res = format!("{}{}", diff.to_string(), res);
        i = (i - 1);
        j = (j - 1);
    }
    let mut k: i64 = 0;;
    while ((k < (res.len() as i64)) && (res.chars().skip(k as usize).take(((k + 1) - k) as usize).collect::<String>().as_str() == "0")) {
        k = (k + 1);
    }
    if (k == (res.len() as i64)) {
        return String::from("0")
    }
    return res.chars().skip(k as usize).take(usize::MAX as usize).collect::<String>().clone()
};
    fn mul_digit(mut a: String, mut d: i64) -> String {
    if (d == 0) {
        return String::from("0")
    }
    let mut i: i64 = ((a.len() as i64) - 1);;
    let mut carry: i64 = 0;;
    let mut res: String = String::new();;
    while (i >= 0) {
        let mut prod: i64 = ((digitMap.get(a.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().as_str()).cloned().unwrap_or_default() * d) + carry);;
        res = format!("{}{}", (prod % 10).to_string(), res);
        carry = (prod / 10);
        i = (i - 1);
    }
    if (carry > 0) {
        res = format!("{}{}", carry.to_string(), res);
    }
    let mut k: i64 = 0;;
    while ((k < (res.len() as i64)) && (res.chars().skip(k as usize).take(((k + 1) - k) as usize).collect::<String>().as_str() == "0")) {
        k = (k + 1);
    }
    if (k == (res.len() as i64)) {
        return String::from("0")
    }
    return res.chars().skip(k as usize).take(usize::MAX as usize).collect::<String>().clone()
};
    fn mul_str(mut a: String, mut b: String) -> HashMap<String, String> {
    let mut result: String = String::from("0");;
    let mut shift: i64 = 0;;
    let mut parts: Vec<String> = vec![];;
    let mut i: i64 = ((b.len() as i64) - 1);;
    while (i >= 0) {
        let d: i64 = digitMap.get(b.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().as_str()).cloned().unwrap_or_default();;
        let part: String = mul_digit(a.clone(), d).clone();;
        parts = { let mut _v = parts.clone(); _v.push(HashMap::from([(String::from("val"), String::from(part.clone())), (String::from("shift"), format!("{}", shift))]).to_string()); _v };
        let mut shifted: String = part.clone();;
        for _ in 0..shift {
            shifted = format!("{}{}", shifted, "0");
        }
        result = add_str(result.clone(), shifted.clone());
        shift = (shift + 1);
        i = (i - 1);
    }
    return HashMap::from([(String::from("res"), String::from(result.clone())), (String::from("parts"), format!("{}", parts))])
};
    fn pad_left(mut s: String, mut total: i64) -> String {
    let mut r: String = String::new();;
    for _ in 0..(total - (s.len() as i64)) {
        r = format!("{}{}", r, " ");
    }
    return format!("{}{}", r, s).clone()
};
    let mut mochi_main = || {
    let tStr: String = input().clone();;
    if (tStr.as_str() == "") {
        return
    }
    let t = { let n: i64 = tStr.parse().unwrap(); n };;
    for _ in 0..t {
        let line: String = input().clone();;
        if (line.as_str() == "") {
            continue
        }
        let mut idx: i64 = 0;;
        while (idx < (line.len() as i64)) {
            let ch: String = line.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>().clone();;
            if (((ch.as_str() == "+") || (ch.as_str() == "-")) || (ch.as_str() == "*")) {
                break
            }
            idx = (idx + 1);
        }
        let a: String = line.chars().skip(0 as usize).take(idx as usize).collect::<String>().clone();;
        let op: String = line.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>().clone();;
        let b: String = line.chars().skip((idx + 1) as usize).take(usize::MAX as usize).collect::<String>().clone();;
        let mut res: String = String::new();;
        let mut parts: Vec<String> = vec![];;
        if (op.as_str() == "+") {
            res = add_str(a.clone(), b.clone());
        } else if (op.as_str() == "-") {
            res = sub_str(a.clone(), b.clone());
        } else {
            let r: HashMap<String, String> = mul_str(a.clone(), b.clone());;
            res = r.get("res").cloned().unwrap_or_default().clone();
            let mut parts: String = r.get("parts").cloned().unwrap_or_default();;
        }
        let mut width: i64 = (a.len() as i64);;
        let secondLen: i64 = ((b.len() as i64) + 1);;
        if (secondLen > width) {
            width = secondLen;
        }
        if ((res.len() as i64) > width) {
            width = (res.len() as i64);
        }
        for p in parts.chars() {
            let p = p.to_string();;
            let l: i64 = ((p.chars().nth("val" as usize).unwrap().to_string().clone().len() as i64) + { let n: i64 = p.chars().nth("shift" as usize).unwrap().to_string().parse().unwrap(); n });;
            if (l > width) {
                width = l;
            }
        }
        println!("{}", pad_left(a.clone(), width));;
        println!("{}", pad_left(format!("{}{}", op, b), width));;
        let mut dash1: i64 = 0;;
        if (op.as_str() == "*") {
            if ((parts.len() as i64) > 0) {
                dash1 = ((b.len() as i64) + 1);
                let firstPart: String = parts.chars().nth(0 as usize).unwrap().to_string().chars().nth("val" as usize).unwrap().to_string().clone();;
                if ((firstPart.len() as i64) > dash1) {
                    dash1 = (firstPart.len() as i64);
                }
            } else {
                dash1 = ((b.len() as i64) + 1);
                if ((res.len() as i64) > dash1) {
                    dash1 = (res.len() as i64);
                }
            }
        } else {
            dash1 = ((b.len() as i64) + 1);
            if ((res.len() as i64) > dash1) {
                dash1 = (res.len() as i64);
            }
        }
        println!("{}", pad_left(repeat(String::from("-"), dash1), width));;
        if ((op.as_str() == "*") && ((b.len() as i64) > 1)) {
            for p in parts {
                let p = p.to_string();;
                let val: String = p.chars().nth("val" as usize).unwrap().to_string().clone();;
                let shift = { let n: i64 = p.chars().nth("shift" as usize).unwrap().to_string().parse().unwrap(); n };;
                let spaces: i64 = ((width - shift) - (val.len() as i64));;
                let mut line: String = String::new();;
                for _ in 0..spaces {
                    line = format!("{}{}", line, " ");
                }
                line = format!("{}{}", line, val);
                println!("{}", line);;
            }
            println!("{}", pad_left(repeat(String::from("-"), (res.len() as i64)), width));;
        }
        println!("{}", pad_left(res.clone(), width));;
        println!("{}", "");;
    }
};;
    mochi_main();;
    let _end: i64 = _now();;
    let duration_us: i64 = ((_end - _start) / 1000);;
    let memory_bytes: i64 = _mem();;
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
