// Generated by Mochi transpiler v0.10.74
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
use std::io::{self, Read};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn input() -> String {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).unwrap();
    s.trim_end().to_string()
}
fn int(x: i64) -> i64 { x }
fn main() {
        let _start: i64 = _now();;
    fn parseInt(mut str: String) -> i64 {
    let digits: HashMap<String, i64> = HashMap::from([(String::from("0"), 0), (String::from("1"), 1), (String::from("2"), 2), (String::from("3"), 3), (String::from("4"), 4), (String::from("5"), 5), (String::from("6"), 6), (String::from("7"), 7), (String::from("8"), 8), (String::from("9"), 9)]);;
    let mut i: i64 = 0;;
    let mut n: i64 = 0;;
    while (i < (str.len() as i64)) {
        let ch: String = str.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().clone();;
        if (ch.as_str() != " ") {
            n = ((n * 10) + digits.get(ch.as_str()).cloned().unwrap_or_default());
        }
        i = (i + 1);
    }
    return n
};
    fn parseInts(mut line: String) -> Vec<i64> {
    let digits: HashMap<String, i64> = HashMap::from([(String::from("0"), 0), (String::from("1"), 1), (String::from("2"), 2), (String::from("3"), 3), (String::from("4"), 4), (String::from("5"), 5), (String::from("6"), 6), (String::from("7"), 7), (String::from("8"), 8), (String::from("9"), 9)]);;
    let mut nums: Vec<i64> = vec![];;
    let mut cur: i64 = 0;;
    let mut inNum: bool = false;;
    let mut i: i64 = 0;;
    while (i < (line.len() as i64)) {
        let ch: String = line.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().clone();;
        if (ch.as_str() == " ") {
            if inNum {
                nums = { let mut _v = nums.clone(); _v.push(cur); _v };
                cur = 0;
                inNum = false;
            }
        } else {
            cur = ((cur * 10) + digits.get(ch.as_str()).cloned().unwrap_or_default());
            inNum = true;
        }
        i = (i + 1);
    }
    if inNum {
        nums = { let mut _v = nums.clone(); _v.push(cur); _v };
    }
    return nums
};
    fn abs(mut x: i64) -> i64 {
    if (x < 0) {
        return (-x)
    } else {
        return x
    }
};
    fn visible(mut h: Vec<Vec<i64>>, mut r1: i64, mut c1: i64, mut r2: i64, mut c2: i64) -> bool {
    if ((r1 == r2) && (c1 == c2)) {
        return true
    }
    let h0: i64 = h[r1 as usize].clone()[c1 as usize];;
    let h1: i64 = h[r2 as usize].clone()[c2 as usize];;
    let mut dr: i64 = (r2 - r1);;
    let mut dc: i64 = (c2 - c1);;
    let mut steps: i64 = abs(dr);;
    if (abs(dc) > steps) {
        steps = abs(dc);
    }
    let mut x: f64 = ((c1 as f64) + 0.5);;
    let mut y: f64 = ((r1 as f64) + 0.5);;
    let mut z: f64 = ((h0 as f64) + 0.5);;
    let mut incX: f64 = ((dc as f64) / (steps as f64));;
    let mut incY: f64 = ((dr as f64) / (steps as f64));;
    let mut incZ: f64 = (((h1 - h0) as f64) / (steps as f64));;
    let mut i: i64 = 1;;
    while (i < steps) {
        x = (x + incX);
        y = (y + incY);
        z = (z + incZ);
        let cx: i64 = (x as i64);;
        let cy: i64 = (y as i64);;
        if (z <= (h[cy as usize].clone()[cx as usize] as f64)) {
            return false
        }
        i = (i + 1);
    }
    return true
};
    fn computeVis(mut h: Vec<Vec<i64>>, mut P: i64, mut Q: i64, mut r: i64, mut c: i64) -> Vec<Vec<bool>> {
    let mut vis: Vec<Vec<bool>> = vec![];;
    for i in 0..P {
        let mut row: Vec<bool> = vec![];;
        for j in 0..Q {
            row = { let mut _v = row.clone(); _v.push(visible(h.clone(), i, j, r, c)); _v };
        }
        vis = { let mut _v = vis.clone(); _v.push(row.clone()); _v };
    }
    return vis
};
    fn bfs(mut h: Vec<Vec<i64>>, mut vis1: Vec<Vec<bool>>, mut vis2: Vec<Vec<bool>>, mut P: i64, mut Q: i64, mut r1: i64, mut c1: i64, mut r2: i64, mut c2: i64) -> i64 {
    let mut dist: Vec<Vec<i64>> = vec![];;
    for i in 0..P {
        let mut row: Vec<i64> = vec![];;
        for j in 0..Q {
            row = { let mut _v = row.clone(); _v.push((-1)); _v };
        }
        dist = { let mut _v = dist.clone(); _v.push(row.clone()); _v };
    }
    let mut qr: Vec<i64> = vec![];;
    let mut qc: Vec<i64> = vec![];;
    qr = { let mut _v = qr.clone(); _v.push(r1); _v };
    qc = { let mut _v = qc.clone(); _v.push(c1); _v };
    dist[r1 as usize][c1 as usize] = 0;;
    let mut head: i64 = 0;;
    let drs: Vec<i64> = vec![-1, 1, 0, 0];;
    let dcs: Vec<i64> = vec![0, 0, -1, 1];;
    while (head < (qr.len() as i64)) {
        let r: i64 = qr[head as usize];;
        let c: i64 = qc[head as usize];;
        head = (head + 1);
        if ((r == r2) && (c == c2)) {
            break
        }
        let hcur: i64 = h[r as usize].clone()[c as usize];;
        let mut k: i64 = 0;;
        while (k < 4) {
            let nr: i64 = (r + drs[k as usize]);;
            let nc: i64 = (c + dcs[k as usize]);;
            if ((((nr >= 0) && (nr < P)) && (nc >= 0)) && (nc < Q)) {
                if (dist[nr as usize].clone()[nc as usize] == (-1)) {
                    let nh: i64 = h[nr as usize].clone()[nc as usize];;
                    if ((nh <= (hcur + 1)) && (nh >= (hcur - 3))) {
                        if (vis1[nr as usize].clone()[nc as usize] || vis2[nr as usize].clone()[nc as usize]) {
                            dist[nr as usize][nc as usize] = (dist[r as usize].clone()[c as usize] + 1);;
                            qr = { let mut _v = qr.clone(); _v.push(nr); _v };
                            qc = { let mut _v = qc.clone(); _v.push(nc); _v };
                        }
                    }
                }
            }
            k = (k + 1);
        }
    }
    return dist[r2 as usize].clone()[c2 as usize]
};
    let mut mochi_main = || {
    let tStr: String = input().clone();;
    if (tStr.as_str() == "") {
        return
    }
    let T: i64 = parseInt(tStr.clone());;
    for _ in 0..T {
        let mut line: String = input().clone();;
        while (line.as_str() == "") {
            line = input();
        }
        let dims: Vec<i64> = parseInts(line.clone());;
        let P: i64 = dims[0 as usize];;
        let Q: i64 = dims[1 as usize];;
        let mut h: Vec<Vec<i64>> = vec![];;
        for i in 0..P {
            let rowVals: Vec<i64> = parseInts(input());;
            h = { let mut _v = h.clone(); _v.push(rowVals.clone()); _v };
        }
        let posLine: String = input().clone();;
        let pos: Vec<i64> = parseInts(posLine.clone());;
        let r1: i64 = (pos[0 as usize] - 1);;
        let c1: i64 = (pos[1 as usize] - 1);;
        let r2: i64 = (pos[2 as usize] - 1);;
        let c2: i64 = (pos[3 as usize] - 1);;
        let vis1: Vec<Vec<bool>> = computeVis(h.clone(), P, Q, r1, c1);;
        let vis2: Vec<Vec<bool>> = computeVis(h.clone(), P, Q, r2, c2);;
        let res: i64 = bfs(h.clone(), vis1.clone(), vis2.clone(), P, Q, r1, c1, r2, c2);;
        if (res == (-1)) {
            println!("{}", "Mission impossible!");;
        } else {
            println!("{}", format!("{}{}", format!("{}{}", "The shortest path is ", res.to_string()), " steps long."));;
        }
    }
};;
    mochi_main();;
    let _end: i64 = _now();;
    let duration_us: i64 = ((_end - _start) / 1000);;
    let memory_bytes: i64 = _mem();;
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
