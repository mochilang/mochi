// Solution for SPOJ COMCB - Complete Chess Boards
// https://www.spoj.com/problems/COMCB/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var n = 0
  while i < len(str) {
    let ch = str[i:i+1]
    if ch >= "0" && ch <= "9" {
      n = n * 10 + (digits[ch] as int)
    }
    i = i + 1
  }
  return n
}

fun split_ws(s: string): list<string> {
  var res: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" {
      if cur != "" { res = append(res, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if cur != "" { res = append(res, cur) }
  return res
}

let letters = [
  "A","B","C","D","E","F","G","H","I","J","K","L","M",
  "N","O","P","Q","R","S","T","U","V","W","X","Y","Z",
]

let dx = [-2,-2,-1,-1,1,1,2,2]
let dy = [-1,1,-2,2,-2,2,-1,1]

type Move = { r: int, c: int, name: string }

var rows = 0
var cols = 0
var total = 0

fun coordName(r: int, c: int): string {
  return letters[c] + str(r + 1)
}

fun copyVisited(src: list<bool>): list<bool> {
  var dst: list<bool> = []
  var i = 0
  while i < len(src) {
    dst = append(dst, src[i])
    i = i + 1
  }
  return dst
}

fun copyPath(src: list<string>): list<string> {
  var dst: list<string> = []
  var i = 0
  while i < len(src) {
    dst = append(dst, src[i])
    i = i + 1
  }
  return dst
}

fun dfs(r: int, c: int, visited: list<bool>, path: list<string>): list<string> {
  let idx = (r * cols + c) as int
  var v = copyVisited(visited)
  var p = copyPath(path)
  v[idx] = true
  p = append(p, coordName(r, c))
  if len(p) == total { return p }
  var moves: list<Move> = []
  var i = 0
  while i < 8 {
    let nr = r + dx[i]
    let nc = c + dy[i]
    if nr >= 0 && nr < rows && nc >= 0 && nc < cols {
      let nidx = (nr * cols + nc) as int
      if v[nidx] == false {
        moves = append(moves, Move{ r: nr, c: nc, name: coordName(nr, nc) })
      }
    }
    i = i + 1
  }
  i = 1
  while i < len(moves) {
    var j = i
    while j > 0 && moves[j-1].name > moves[j].name {
      let tmp = moves[j-1]
      moves[j-1] = moves[j]
      moves[j] = tmp
      j = j - 1
    }
    i = i + 1
  }
  i = 0
  while i < len(moves) {
    let mv = moves[i]
    let res = dfs(mv.r, mv.c, v, p)
    if len(res) == total { return res }
    i = i + 1
  }
  return []
}

fun solve(x: int, y: int): string {
  rows = x
  cols = y
  total = (rows * cols) as int
  var visited: list<bool> = []
  var i = 0
  while i < total { visited = append(visited, false); i = i + 1 }
  var starts: list<Move> = []
  var r = 0
  while r < rows {
    var c = 0
    while c < cols {
      starts = append(starts, Move{ r: r, c: c, name: coordName(r, c) })
      c = c + 1
    }
    r = r + 1
  }
  i = 1
  while i < len(starts) {
    var j = i
    while j > 0 && starts[j-1].name > starts[j].name {
      let tmp = starts[j-1]
      starts[j-1] = starts[j]
      starts[j] = tmp
      j = j - 1
    }
    i = i + 1
  }
  var s = 0
  while s < len(starts) {
    let res = dfs(starts[s].r, starts[s].c, visited, [])
    if len(res) == total {
      var out = ""
      var k = 0
      while k < len(res) {
        out = out + res[k]
        k = k + 1
      }
      return out
    }
    s = s + 1
  }
  return "-1"
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let t = parseIntStr(tLine)
  var case = 0
  while case < t {
    var line = input()
    while line == "" { line = input() }
    let parts = split_ws(line)
    let x = parseIntStr(parts[0])
    let y = parseIntStr(parts[1])
    print(solve(x, y))
    case = case + 1
  }
}

main()
