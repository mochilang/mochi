# [Matrix Words](https://www.spoj.com/problems/MWORDS/)

## Problem Summary
Given an $N \times N$ grid of uppercase letters ($N \le 30$). Starting at the top-left cell, consider all paths that reach the bottom-right cell in exactly $2N-1$ steps while never crossing the main diagonal. Paths may lie entirely above or below the diagonal but can touch it. Each path yields a string by concatenating the letters encountered. Collect all such strings from both partitions, allowing duplicates, sort them lexicographically, and for a given index $I$ output the string at position $I \bmod M$, where $M$ is the total number of strings.

## Algorithm
1. **Dynamic Programming for Path Counts**
   - Compute `upper[r][c]`: number of valid suffix paths from cell $(r,c)$ to $(N-1,N-1)$ staying at or above the diagonal.
   - Compute `lower[r][c]` analogously for paths staying at or below the diagonal.
   - Recurrences sum counts from right and down neighbors when those moves keep the path inside its region.
2. **Lexicographic Selection**
   - Maintain a frontier list of cells that may appear next in the string (initially `(0,1)` for upper and `(1,0)` for lower). The result begins with the letter in `(0,0)`.
   - Repeat $2N-2$ times:
     - For each frontier cell, add its contribution (`upper` or `lower` count) to an array indexed by its letter.
     - Find the smallest letter whose cumulative count exceeds the desired index `k = I % M`; append this letter to the answer.
     - Update the frontier with neighbors of cells having the chosen letter.
3. Output the constructed string.

This approach avoids enumerating all paths and runs in $O(N^2)$ time with 64-bit integer counts.
