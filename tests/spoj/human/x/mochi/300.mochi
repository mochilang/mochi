// Solution for SPOJ CABLETV - Cable TV Network
// https://www.spoj.com/problems/CABLETV/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var sign = 1
  if len(str) > 0 && str[0:1] == "-" {
    sign = 0-1
    i = 1
  }
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  return sign * n
}

fun readAllInts(): list<int> {
  var data = ""
  while true {
    let line = input()
    if line == "" { break }
    data = data + " " + line
  }
  var res: list<int> = []
  var i = 0
  while i < len(data) {
    let ch = data[i:i+1]
    if ch == "-" || (ch >= "0" && ch <= "9") {
      var j = i + 1
      while j < len(data) {
        let cj = data[j:j+1]
        if cj >= "0" && cj <= "9" { j = j + 1 } else { break }
      }
      res = append(res, parseIntStr(data[i:j]))
      i = j
    } else {
      i = i + 1
    }
  }
  return res
}

fun cloneMatrix(mat: list<list<int>>): list<list<int>> {
  var res: list<list<int>> = []
  var i = 0
  while i < len(mat) {
    var row: list<int> = []
    var j = 0
    while j < len(mat[i]) {
      row = append(row, mat[i][j])
      j = j + 1
    }
    res = append(res, row)
    i = i + 1
  }
  return res
}

fun bfs(cap: list<list<int>>, s: int, t: int): (int, list<int>) {
  let n = len(cap)
  var parent: list<int> = []
  var vis: list<int> = []
  var i = 0
  while i < n {
    parent = append(parent, 0-1)
    vis = append(vis, 0)
    i = i + 1
  }
  var q: list<int> = [s]
  vis[s] = 1
  var qh = 0
  while qh < len(q) {
    let u = q[qh]
    qh = qh + 1
    if u == t { break }
    var v = 0
    while v < n {
      if vis[v] == 0 && cap[u][v] > 0 {
        vis[v] = 1
        parent[v] = u
        q = append(q, v)
      }
      v = v + 1
    }
  }
  if vis[t] == 0 { return (0, parent) }
  var flow = 1000000000
  var v2 = t
  while parent[v2] != 0-1 {
    let u = parent[v2]
    if cap[u][v2] < flow { flow = cap[u][v2] }
    v2 = u
  }
  return (flow, parent)
}

fun maxflow(cap: list<list<int>>, s: int, t: int): int {
  var total = 0
  while true {
    let (f, parent) = bfs(cap, s, t)
    if f == 0 { break }
    total = total + f
    var v = t
    while parent[v] != 0-1 {
      let u = parent[v]
      cap[u][v] = cap[u][v] - f
      cap[v][u] = cap[v][u] + f
      v = u
    }
  }
  return total
}

fun solve(n: int, edges: list<list<int>>): int {
  if n <= 1 { return n }
  if len(edges) == n * (n - 1) / 2 { return n }
  let size = n * 2
  var base: list<list<int>> = []
  var i = 0
  while i < size {
    var row: list<int> = []
    var j = 0
    while j < size {
      row = append(row, 0)
      j = j + 1
    }
    base = append(base, row)
    i = i + 1
  }
  i = 0
  while i < n {
    base[i][i+n] = 1
    i = i + 1
  }
  let INF = 1000
  var e = 0
  while e < len(edges) {
    let u = edges[e][0]
    let v = edges[e][1]
    base[u+n][v] = INF
    base[v+n][u] = INF
    e = e + 1
  }
  var ans = n
  var s = 0
  while s < n {
    var t = s + 1
    while t < n {
      var cap = cloneMatrix(base)
      cap[s][s+n] = INF
      cap[t][t+n] = INF
      let f = maxflow(cap, s+n, t)
      if f < ans { ans = f }
      if ans == 0 { return 0 }
      t = t + 1
    }
    s = s + 1
  }
  return ans
}

fun main() {
  let nums = readAllInts()
  if len(nums) == 0 { return }
  var idx = 0
  let t = nums[idx]
  idx = idx + 1
  var out: list<string> = []
  var cas = 0
  while cas < t {
    let n = nums[idx]; idx = idx + 1
    let m = nums[idx]; idx = idx + 1
    var edges: list<list<int>> = []
    var k = 0
    while k < m {
      let u = nums[idx]; let v = nums[idx+1]
      idx = idx + 2
      edges = append(edges, [u, v])
      k = k + 1
    }
    out = append(out, str(solve(n, edges)))
    cas = cas + 1
  }
  var i = 0
  while i < len(out) {
    print(out[i])
    i = i + 1
  }
}

main()
