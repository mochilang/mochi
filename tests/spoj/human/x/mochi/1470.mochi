// Solution for SPOJ SEQ2 - Another Sequence Problem
// https://www.spoj.com/problems/SEQ2/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur: string = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 { parts = append(parts, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun parseIntStr(str: string): int {
  var i = 0
  var neg = false
  if len(str) > 0 && str[0:1] == "-" {
    neg = true
    i = 1
  }
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  if neg { n = -n }
  return n
}

var tokens: list<string> = []
fun nextInt(): int {
  while len(tokens) == 0 {
    let line = input()
    if line == nil { return 0 }
    let parts = splitSpaces(line)
    var j = 0
    while j < len(parts) {
      tokens = append(tokens, parts[j])
      j = j + 1
    }
  }
  let v = parseIntStr(tokens[0])
  tokens = tokens[1:len(tokens)]
  return v
}

fun maxSubarray(a: list<int>): int {
  if len(a) == 0 { return 0 }
  var best = a[0]
  var cur = a[0]
  var i = 1
  while i < len(a) {
    let x = a[i]
    if cur + x > x { cur = cur + x } else { cur = x }
    if cur > best { best = cur }
    i = i + 1
  }
  return best
}

fun concat(a: list<int>, b: list<int>): list<int> {
  var res = a
  var i = 0
  while i < len(b) {
    res = append(res, b[i])
    i = i + 1
  }
  return res
}

fun main() {
  let T = nextInt()
  var case = 0
  while case < T {
    let n = nextInt()
    let m = nextInt()
    var seq: list<int> = []
    var i = 0
    while i < n {
      seq = append(seq, nextInt())
      i = i + 1
    }
    var op = 0
    while op < m {
      var line = input()
      while line != nil && len(splitSpaces(line)) == 0 {
        line = input()
      }
      if line == nil { break }
      let parts = splitSpaces(line)
      let name = parts[0]
      if name == "MAKE-SAME" {
        let idx = parseIntStr(parts[1]) - 1
        let t = parseIntStr(parts[2])
        let c = parseIntStr(parts[3])
        var k = 0
        while k < t {
          seq[idx+k] = c
          k = k + 1
        }
      } else if name == "INSERT" {
        let pos = parseIntStr(parts[1])
        let t = parseIntStr(parts[2])
        var nums: list<int> = []
        var k = 0
        while k < t {
          nums = append(nums, parseIntStr(parts[3+k]))
          k = k + 1
        }
        var left = seq[0:pos]
        var right = seq[pos:len(seq)]
        seq = concat(concat(left, nums), right)
      } else if name == "DELETE" {
        let idx = parseIntStr(parts[1]) - 1
        let t = parseIntStr(parts[2])
        var left = seq[0:idx]
        var right = seq[idx+t:len(seq)]
        seq = concat(left, right)
      } else if name == "REVERSE" {
        let idx = parseIntStr(parts[1]) - 1
        let t = parseIntStr(parts[2])
        var start = idx
        var end = idx + t - 1
        while start < end {
          let tmp = seq[start]
          seq[start] = seq[end]
          seq[end] = tmp
          start = start + 1
          end = end - 1
        }
      } else if name == "GET-SUM" {
        let idx = parseIntStr(parts[1]) - 1
        let t = parseIntStr(parts[2])
        var sum = 0
        var k = 0
        while k < t {
          sum = sum + seq[idx+k]
          k = k + 1
        }
        print(sum)
      } else if name == "MAX-SUM" {
        print(maxSubarray(seq))
      }
      op = op + 1
    }
    case = case + 1
  }
}

main()
