# Royal Treasury

* Problem: [TREASURY - Royal Treasury](https://www.spoj.com/problems/TREASURY/)
* Solution language: Mochi

## Algorithm
1. The hierarchy forms a rooted tree (rooted at clerk 1).
2. For each node `u` maintain two DP states:
   - `dp0[u]`: `u` is **not** matched with its parent. `u` may optionally match with one of its children.
   - `dp1[u]`: `u` **is** matched with its parent, so it cannot match any child.
3. Recursively process children.
4. `dp1[u]` is easy – all children are in state `dp0`, so we sum their pair counts and multiply their ways.
5. To compute `dp0[u]`:
   - Start with the base case where `u` is unmatched: sum `dp0` of all children and multiply their ways.
   - For every child `v`, consider pairing `u` with `v`. This adds `1 + dp1[v].pairs - dp0[v].pairs` pairs.
   - Choose the child(ren) giving the maximal increase and sum the corresponding ways.
6. Use big integers for counting combinations.

## Correctness
- Each clerk can belong to at most one pair, so matching edges form a matching.
- `dp1[u]` correctly forbids matching `u` with any child.
- For `dp0[u]`, trying every child as the partner ensures we consider all optimal matchings that involve `u`.
- Counting multiplies ways of independent subtrees and sums over different optimal choices for the partnering child.
- The root has no parent, so the final answer is `dp0[1]`.

## Complexity
Let `N` be the number of clerks (≤ 1000). Each node is processed once and we iterate over its children, so the time complexity is `O(N)` and the space complexity is `O(N)`.
