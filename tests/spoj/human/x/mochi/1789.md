# [Huffman's Greed](https://www.spoj.com/problems/GREEDULM/)

## Problem Summary
Given `n` ordered strings `K1..Kn`, and frequencies for successful searches (`p1..pn`) and unsuccessful searches (`q0..qn`), build a binary search tree that minimises the expected number of comparisons when searching. Frequencies are provided as integers; the answer should be the minimal cost multiplied by the sum of all frequencies.

## Algorithm
We use the classic dynamic programming algorithm for the Optimal Binary Search Tree (OBST):

1. The input gives `p1..pn` first followed by `q0..qn`.
2. Arrays `e[i][j]` store minimal cost for keys `Ki..Kj` (with `e[i][i-1] = q_{i-1}`) and `w[i][j]` store total weights for the same range.
3. For lengths `l = 1..n` and each `i`, compute `j = i+l-1`:
   - `w[i][j] = w[i][j-1] + p_j + q_j`.
   - `e[i][j] = min_{r=i..j} (e[i][r-1] + e[r+1][j] + w[i][j])`.
4. The dynamic programming above counts each `q` one extra time. Subtract `sum(q0..qn)` from `e[1][n]` to obtain the required cost.

This runs in `O(n^3)` time with `n â‰¤ 200`, which is easily feasible.
