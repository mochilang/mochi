// Solution for SPOJ MATRIX - Count maximum matrices
// https://www.spoj.com/problems/MATRIX/

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur: string = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 {
        parts = append(parts, cur)
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun parseInts(line: string): list<int> {
  let parts = splitSpaces(line)
  var nums: list<int> = []
  var i = 0
  while i < len(parts) {
    nums = append(nums, int(parts[i]))
    i = i + 1
  }
  return nums
}

fun make2d(rows: int, cols: int, v: int): list<list<int>> {
  var res: list<list<int>> = []
  var r = 0
  while r < rows {
    var row: list<int> = []
    var c = 0
    while c < cols {
      row = append(row, v)
      c = c + 1
    }
    res = append(res, row)
    r = r + 1
  }
  return res
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let T = int(tLine)
  var caseIndex = 0
  while caseIndex < T {
    let dims = parseInts(input())
    let M = dims[0]
    let N = dims[1]
    var val = make2d(M, N, 0)
    var r = 0
    while r < M {
      let rowVals = parseInts(input())
      var c = 0
      while c < N {
        val[r][c] = if rowVals[c] == 1 { 1 } else { -1 }
        c = c + 1
      }
      r = r + 1
    }
    var colPref = make2d(M + 1, N, 0)
    r = 0
    while r < M {
      var c = 0
      while c < N {
        colPref[r + 1][c] = colPref[r][c] + val[r][c]
        c = c + 1
      }
      r = r + 1
    }
    var W = -1000000
    var S = 0
    var r1 = 0
    while r1 < M {
      var r2 = r1
      while r2 < M {
        var tb: list<int> = []
        var vert: list<int> = []
        var c = 0
        while c < N {
          let v1 = val[r1][c]
          let v2 = if r1 == r2 { 0 } else { val[r2][c] }
          tb = append(tb, v1 + v2)
          var vc = 0
          if r2 > r1 + 1 {
            vc = colPref[r2][c] - colPref[r1 + 1][c]
          } else {
            vc = 0
          }
          vert = append(vert, vc)
          c = c + 1
        }
        var pref: list<int> = []
        pref = append(pref, 0)
        var j = 0
        while j < N {
          pref = append(pref, pref[j] + tb[j])
          j = j + 1
        }
        var maxLeft = -1000000
        var countLeft = 0
        var c2 = 0
        while c2 < N {
          let single = tb[c2] + vert[c2]
          if single > W {
            W = single
            S = 1
          } else if single == W {
            S = S + 1
          }
          if c2 > 0 {
            let value = pref[c2 + 1] + vert[c2] + maxLeft
            if value > W {
              W = value
              S = countLeft
            } else if value == W {
              S = S + countLeft
            }
          }
          let cand = vert[c2] - pref[c2]
          if cand > maxLeft {
            maxLeft = cand
            countLeft = 1
          } else if cand == maxLeft {
            countLeft = countLeft + 1
          }
          c2 = c2 + 1
        }
        r2 = r2 + 1
      }
      r1 = r1 + 1
    }
    print(str(W) + " " + str(S))
    caseIndex = caseIndex + 1
  }
}

main()
