# MINIMAX - Minimizing maximizer

The Maximizer consists of a sequence of sorters `Sorter(i, j)`; each sorts inputs `i..j` so that the
largest element of that interval moves to position `j`. The overall output is the value at position `n`
after all sorters are applied. We need the shortest subsequence of sorters that still guarantees the
maximum reaches position `n` for any initial arrangement.

Process the sorters from the end of the pipeline backwards while maintaining `L`, the leftmost position
currently guaranteed to reach the output. Initially `L = n`. For each sorter `(i, j)` seen in reverse
order:

- If `j >= L` and `i < L`, this sorter can move a value from the left into the guaranteed range.
  It is necessary, so increment the answer and update `L = i`.
- Otherwise the sorter doesn't help move the maximum towards `n` and can be ignored.

When `L` becomes `1`, every input can reach the output, and the number of selected sorters is minimal.
This greedy approach works because sorters are considered only if they extend the covered range to the
left; any other sorter is redundant.

**Complexity:** Each test case scans the sorters once, resulting in `O(m)` time and `O(m)` memory.
