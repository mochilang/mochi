# SPOJ GREED - Greedy island

We need the cards to contain every number from 1..N exactly once.  The player may
exchange card `x` for card `y` (and back) if an edge `(x,y)` is given.  Each
exchange has cost 1.

Algorithm:

1. Count how many cards of each value we currently have.  For numbers `1..N`
   keep one copy if it exists, the rest become **surplus** cards.  Any number in
   `1..N` not present is a **missing** number.  Cards with value outside
   `1..N` are also surplus.
2. Build an undirected graph from all values that appear either on cards,
   as targets `1..N`, or in the exchange list.
3. For each distinct surplus value run BFS on this graph to obtain the distance
   to every other number.  This distance is the minimum number of exchanges
   needed to turn that card into another value.
4. Construct a cost matrix where `cost[i][j]` is the distance from the `i`‑th
   surplus card to the `j`‑th missing number.  If a number is unreachable the
   cost is treated as infinite.
5. Use the Hungarian algorithm on this matrix to find the minimum total cost
   assignment between surplus cards and missing numbers.
6. The sum of the chosen costs is the minimal number of exchanges.

With `N ≤ 500` the graph and the cost matrix are small.  BFS runs in `O(V+E)` and
the Hungarian algorithm runs in `O(N^3)` which is easily fast enough.
