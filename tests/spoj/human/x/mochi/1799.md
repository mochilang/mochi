# [The Bottom of a Graph](https://www.spoj.com/problems/BOTTOM/)

## Problem Summary
Given multiple directed graphs, a node v is a sink if for every node w reachable from v, w can also reach v. The bottom of the graph is the set of all such sink nodes. For each test case, output these nodes in ascending order.

## Algorithm
1. Build adjacency and reverse adjacency lists for the graph.
2. Run Kosaraju's algorithm to compute strongly connected components (SCCs):
   - Perform DFS on the original graph to record vertices in order of completion.
   - Perform DFS on the reversed graph, processing vertices in reverse completion order, to assign component IDs.
3. For every edge (u â†’ v), if their component IDs differ, mark the component of u as having an outgoing edge.
4. All vertices whose component is unmarked form the bottom; list them in increasing numerical order.

## Correctness Proof
- Kosaraju's algorithm partitions the vertices into SCCs where every vertex in a component can reach every other vertex in that component.
- A vertex satisfies the sink definition iff its SCC has no outgoing edges to other components. Any outgoing edge would reach a vertex that cannot reach back, contradicting the definition.
- Step 3 marks exactly those components with outgoing edges. Step 4 outputs precisely the vertices in unmarked components, which are exactly the bottom nodes.

## Complexity Analysis
Let V be the number of vertices and E the number of edges.
Kosaraju's algorithm runs in O(V + E) time and uses O(V + E) space.
The additional pass to mark outgoing components and collect vertices is also O(V + E).
Thus each test case is solved in O(V + E) time with O(V + E) memory.

## Reference Implementation (Mochi)
```mochi
// Solution for SPOJ BOTTOM - The Bottom of a Graph
// https://www.spoj.com/problems/BOTTOM/

var tokens: list<string> = []
var tokIdx = 0

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 { parts = append(parts, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun nextToken(): string {
  while tokIdx >= len(tokens) {
    let line = input()
    if line == nil { return nil }
    tokens = splitSpaces(line)
    tokIdx = 0
  }
  let t = tokens[tokIdx]
  tokIdx = tokIdx + 1
  return t
}

fun nextInt(): int { return int(nextToken()) }

fun scc(n: int, adj: list<list<int>>, radj: list<list<int>>): list<int> {
  var used: list<bool> = []
  var i = 0
  while i < n {
    used = append(used, false)
    i = i + 1
  }
  var order: list<int> = []
  var v = 0
  while v < n {
    if !used[v] {
      var st: list<int> = []
      var it: list<int> = []
      st = append(st, v)
      it = append(it, 0)
      used[v] = true
      while len(st) > 0 {
        let cur = st[len(st)-1]
        let idxIt = it[len(it)-1]
        if idxIt < len(adj[cur]) {
          let to = adj[cur][idxIt]
          it[len(it)-1] = idxIt + 1
          if !used[to] {
            used[to] = true
            st = append(st, to)
            it = append(it, 0)
          }
        } else {
          order = append(order, cur)
          st = st[:len(st)-1]
          it = it[:len(it)-1]
        }
      }
    }
    v = v + 1
  }
  var comp: list<int> = []
  i = 0
  while i < n {
    comp = append(comp, -1)
    i = i + 1
  }
  var cid = 0
  var idxOrd = len(order) - 1
  while idxOrd >= 0 {
    let start = order[idxOrd]
    idxOrd = idxOrd - 1
    if comp[start] >= 0 { continue }
    var st: list<int> = []
    st = append(st, start)
    comp[start] = cid
    while len(st) > 0 {
      let cur = st[len(st)-1]
      st = st[:len(st)-1]
      var j = 0
      while j < len(radj[cur]) {
        let to = radj[cur][j]
        if comp[to] < 0 {
          comp[to] = cid
          st = append(st, to)
        }
        j = j + 1
      }
    }
    cid = cid + 1
  }
  return comp
}

fun main() {
  while true {
    let tok = nextToken()
    if tok == nil { return }
    let v = int(tok)
    if v == 0 { break }
    let e = nextInt()
    var adj: list<list<int>> = []
    var radj: list<list<int>> = []
    var i = 0
    while i < v {
      adj = append(adj, [])
      radj = append(radj, [])
      i = i + 1
    }
    var j = 0
    while j < e {
      let a = nextInt() - 1
      let b = nextInt() - 1
      adj[a] = append(adj[a], b)
      radj[b] = append(radj[b], a)
      j = j + 1
    }
    let comp = scc(v, adj, radj)
    var outComp: list<bool> = []
    i = 0
    while i < v {
      outComp = append(outComp, false)
      i = i + 1
    }
    i = 0
    while i < v {
      var k = 0
      while k < len(adj[i]) {
        let to = adj[i][k]
        if comp[i] != comp[to] {
          outComp[comp[i]] = true
        }
        k = k + 1
      }
      i = i + 1
    }
    var res: list<int> = []
    i = 0
    while i < v {
      if !outComp[comp[i]] {
        res = append(res, i + 1)
      }
      i = i + 1
    }
    var outStr = ""
    i = 0
    while i < len(res) {
      if i > 0 { outStr = outStr + " " }
      outStr = outStr + str(res[i])
      i = i + 1
    }
    print(outStr)
  }
}

main()
```
