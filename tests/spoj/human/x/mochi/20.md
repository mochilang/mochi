# [The Bytelandian Cryptographer (Act IV)](https://www.spoj.com/problems/CRYPTO4/)

## Problem Summary
We are given an upper bound on the length of a periodic Vigenère key.
The plaintext `x` and ciphertext `y` of a message are known but some
characters are missing and replaced by `*`.  For each test case we must
reconstruct the original plaintext, writing `*` only for positions that
cannot be determined uniquely.

## Algorithm
1. Convert letters `A`-`Z` to numbers `0`-`25`.
2. For every position where both `x[i]` and `y[i]` are known, compute the
difference `d_i = (y_i - x_i) mod 26`; otherwise mark the position as
unknown.
3. For each key length `n` from `1` to `m`:
   - Initialise an array `key[0..n-1]` with `-1`.
   - For each known `d_i`, check consistency: if `key[i mod n]` is unset,
     assign it `d_i`; if it conflicts, discard this `n`.
   - For valid `n`, reconstruct missing letters: for every position where
     `x[i]` is `*` and `y[i]` is known, if `key[i mod n]` is fixed then
     `x[i] = (y_i - key[i mod n]) mod 26`.
   - Maintain an intersection of the letters obtained for each position;
     if any `n` leaves a position unknown or produces a different letter,
     the position becomes `*` in the final answer.
4. Output the known characters from `x` and the resolved letters for the
others; unresolved positions are `*`.

The algorithm checks all possible key lengths up to `m` and for each valid
length scans the message once.  For message length `L`, the worst-case time
complexity is `O(m · L)` and the space usage is `O(L + m)`.
