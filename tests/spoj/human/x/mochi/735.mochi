// Solution for SPOJ MDST - Minimum Diameter Spanning Tree
// https://www.spoj.com/problems/MDST/

fun parseIntStr(str: string): int {
  let digits = {
    "0":0,"1":1,"2":2,"3":3,"4":4,
    "5":5,"6":6,"7":7,"8":8,"9":9,
  }
  var i = 0
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  return n
}

fun readNonEmpty(): string {
  var line = input()
  while line == "" {
    line = input()
  }
  return line
}

fun bfs(start: int, n: int, adj: list<list<int>>): list<int> {
  var dist: list<int> = []
  var i = 0
  while i < n {
    dist = append(dist, 0 - 1)
    i = i + 1
  }
  var q: list<int> = []
  var qi = 0
  dist[start] = 0
  q = append(q, start)
  while qi < len(q) {
    let v = q[qi]
    qi = qi + 1
    var j = 0
    while j < len(adj[v]) {
      let to = adj[v][j]
      if dist[to] == 0 - 1 {
        dist[to] = dist[v] + 1
        q = append(q, to)
      }
      j = j + 1
    }
  }
  return dist
}

fun main() {
  let t = parseIntStr(readNonEmpty())
  var case = 0
  while case < t {
    let n = parseIntStr(readNonEmpty())
    var adj: list<list<int>> = []
    var i = 0
    while i < n {
      adj = append(adj, [])
      i = i + 1
    }
    i = 0
    while i < n {
      let parts = split(readNonEmpty())
      let idx = parseIntStr(parts[0]) - 1
      let m = parseIntStr(parts[1])
      var j = 0
      var neighbors: list<int> = []
      while j < m {
        neighbors = append(neighbors, parseIntStr(parts[2 + j]) - 1)
        j = j + 1
      }
      adj[idx] = neighbors
      i = i + 1
    }
    var ecc: list<int> = []
    i = 0
    while i < n {
      let dist = bfs(i, n, adj)
      var md = 0
      var j = 0
      while j < n {
        if dist[j] > md {
          md = dist[j]
        }
        j = j + 1
      }
      ecc = append(ecc, md)
      i = i + 1
    }
    var r = ecc[0]
    i = 1
    while i < n {
      if ecc[i] < r {
        r = ecc[i]
      }
      i = i + 1
    }
    var centers: list<int> = []
    i = 0
    while i < n {
      if ecc[i] == r {
        centers = append(centers, i)
      }
      i = i + 1
    }
    var ans = 2 * r
    var found = false
    i = 0
    while i < len(centers) {
      let u = centers[i]
      var j = 0
      while j < len(adj[u]) {
        let v = adj[u][j]
        if ecc[v] == r {
          found = true
          break
        }
        j = j + 1
      }
      if found {
        break
      }
      i = i + 1
    }
    if found && r > 0 {
      ans = 2 * r - 1
    }
    print(str(ans))
    case = case + 1
  }
}

main()
