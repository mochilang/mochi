// Solution for SPOJ SEQPAR - Partition the sequence
// https://www.spoj.com/problems/SEQPAR/

fun readInts(line: string): list<int> {
  var nums: list<int> = []
  var cur = ""
  var i = 0
  while i < len(line) {
    let ch = line[i:i+1]
    if ch == " " {
      if len(cur) > 0 {
        nums = append(nums, cur as int)
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 {
    nums = append(nums, cur as int)
  }
  return nums
}

fun minMaxSum(arr: list<int>, n: int, k: int): int {
  let INF = 1000000000000000000
  let MIN = -INF
  var pref: list<int> = []
  var sum = 0
  pref = append(pref, 0)
  var i = 0
  while i < n {
    sum = sum + arr[i]
    pref = append(pref, sum)
    i = i + 1
  }
  var dp: list<list<int>> = []
  var a = 0
  while a <= n {
    var row: list<int> = []
    var b = 0
    while b <= k {
      row = append(row, INF)
      b = b + 1
    }
    dp = append(dp, row)
    a = a + 1
  }
  dp[0][0] = MIN
  i = 1
  while i <= n {
    dp[i][1] = pref[i]
    i = i + 1
  }
  i = 1
  while i <= n {
    var j = 2
    while j <= k {
      var p = 0
      var best = dp[i][j]
      while p < i {
        let val1 = dp[p][j-1]
        let seg = pref[i] - pref[p]
        var m = val1
        if seg > m { m = seg }
        if m < best { best = m }
        p = p + 1
      }
      dp[i][j] = best
      j = j + 1
    }
    i = i + 1
  }
  return dp[n][k]
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let T = tLine as int
  var case = 0
  while case < T {
    let nkLine = input()
    let nk = readInts(nkLine)
    let n = nk[0]
    let k = nk[1]
    var arr: list<int> = []
    var i = 0
    while i < n {
      let line = input()
      arr = append(arr, line as int)
      i = i + 1
    }
    let ans = minMaxSum(arr, n, k)
    print(str(ans))
    case = case + 1
  }
}

main()
