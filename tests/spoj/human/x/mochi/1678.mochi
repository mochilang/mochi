// Solution for SPOJ TREASURY - Royal Treasury
// https://www.spoj.com/problems/TREASURY/

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 { parts = append(parts, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun parseIntStr(str: string): int {
  let digits = {
    "0":0,"1":1,"2":2,"3":3,"4":4,
    "5":5,"6":6,"7":7,"8":8,"9":9,
  }
  var i = 0
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  return n
}

type DP { p0: int, w0: bigint, p1: int, w1: bigint }

var children: list<list<int>>

fun dfs(u: int): DP {
  let ch = children[u]
  let k = len(ch)
  if k == 0 {
    return DP{ p0:0, w0:1 as bigint, p1:0, w1:1 as bigint }
  }
  var basePairs = 0
  var baseWays: bigint = 1 as bigint
  var deltas: list<int> = []
  var w0list: list<bigint> = []
  var w1list: list<bigint> = []
  var i = 0
  while i < k {
    let v = ch[i]
    let res = dfs(v)
    basePairs = basePairs + res.p0
    baseWays = baseWays * res.w0
    deltas = append(deltas, (res.p1 + 1) - res.p0)
    w0list = append(w0list, res.w0)
    w1list = append(w1list, res.w1)
    i = i + 1
  }
  let p1 = basePairs
  let w1 = baseWays
  var best = 0
  i = 0
  while i < k {
    let d = deltas[i]
    if d > best { best = d }
    i = i + 1
  }
  var p0 = basePairs + best
  var w0: bigint
  // prefix products
  var prefix: list<bigint> = []
  var prod: bigint = 1 as bigint
  i = 0
  while i < k {
    prefix = append(prefix, prod)
    prod = prod * w0list[i]
    i = i + 1
  }
  // suffix products
  var suffix: list<bigint> = []
  i = 0
  while i < k {
    suffix = append(suffix, 1 as bigint)
    i = i + 1
  }
  prod = 1 as bigint
  i = k - 1
  while i >= 0 {
    suffix[i] = prod
    prod = prod * w0list[i]
    i = i - 1
  }
  if best > 0 {
    w0 = 0 as bigint
    i = 0
    while i < k {
      if deltas[i] == best {
        var ways_i: bigint = w1list[i]
        ways_i = ways_i * prefix[i]
        ways_i = ways_i * suffix[i]
        w0 = w0 + ways_i
      }
      i = i + 1
    }
  } else {
    w0 = baseWays
    i = 0
    while i < k {
      if deltas[i] == 0 {
        var ways_i: bigint = w1list[i]
        ways_i = ways_i * prefix[i]
        ways_i = ways_i * suffix[i]
        w0 = w0 + ways_i
      }
      i = i + 1
    }
  }
  return DP{ p0:p0, w0:w0, p1:p1, w1:w1 }
}

fun main() {
  while true {
    let line = input()
    if line == "" { break }
    let n = parseIntStr(line)
    children = []
    var i = 0
    while i <= n {
      children = append(children, [])
      i = i + 1
    }
    var j = 0
    while j < n {
      let ln = input()
      let parts = splitSpaces(ln)
      let id = parseIntStr(parts[0])
      let k = parseIntStr(parts[1])
      var lst: list<int> = []
      var t = 0
      while t < k {
        lst = append(lst, parseIntStr(parts[2 + t]))
        t = t + 1
      }
      children[id] = lst
      j = j + 1
    }
    let res = dfs(1)
    print(str(res.p0))
    print(str(res.w0))
  }
}

main()
