# SPOJ BRCKGAME - A Game of Toy Bricks

We are given `N` cuboids with dimensions `(length, width, height)` and ids
from `1` to `N`. We must build exactly `M` piles.  For any `K`, every id in
`PileK` must be greater than all ids in `PileK+1`.  Inside a pile cuboids are
stacked in increasing id order and each lower cuboid must have length and
width **not smaller** than the one above it.  The goal is to maximize the sum
of heights of the `M` piles.

## Algorithm

1. **Precomputation for segments**
   * Because of the id restriction, the set of ids assigned to a pile forms a
     contiguous segment.  For every segment `[l,r]` (0‑based) we compute the
     maximum tower height using cuboids with ids in that segment.
   * This is a longest non‑increasing subsequence in two dimensions (length
     and width).  We iterate `r` from `l` to `N-1` and keep `dp[i]` – best
     height ending with cuboid `i`.  When processing cuboid `r`, we scan all
     `j` in `[l,r)` where `len[j] ≥ len[r]` and `wid[j] ≥ wid[r]` and update
     `dp[r] = max(dp[j] + h[r])`.  The best value among `dp[l..r]` becomes
     `best[l][r]` – the optimal tower height for that segment.

2. **Dynamic programming over segments**
   * Let `F[i][k]` be the maximum total height using the first `i` cuboids to
     build `k` piles.  Transition:
     `F[i][k] = max_{j < i} ( F[j][k-1] + best[j][i-1] )` with `best[j][i-1] > 0`.
   * Initialize `F[i][0] = 0`.  The answer is `max_{i≥M} F[i][M]` since we may
     ignore high‑id cuboids entirely.

Both steps run in `O(N^3)` time which is fine for `N ≤ 100`.

## Correctness

*Every pile is a contiguous id segment.*  By the problem rule, all ids in a
higher‑numbered pile are greater than all ids in lower piles.  Sorting by id
results in each pile occupying a contiguous index range.

*`best[l][r]` gives the optimal tower height for segment `[l,r]`.*  The DP for
segments considers all sequences of cuboids in order where each step keeps
length and width non‑increasing, exactly matching the stacking constraints.
Any valid tower in `[l,r]` corresponds to a path in this DP and vice versa.

*`F[i][k]` builds the global optimum.*  When constructing `k` piles using the
first `i` cuboids, the last pile must use some segment `[j,i-1]`.  Its height
is `best[j][i-1]` and the previous piles are optimally built using `F[j][k-1]`.
Taking the maximum over all splits ensures an optimal total.  Ignoring extra
high‑id cuboids is handled by considering all `i` in the final answer.

Therefore the algorithm returns the maximum possible sum of pile heights.

## Complexity Analysis

Precomputing `best` takes `O(N^3)` time and `O(N^2)` memory.  The DP over
segments also runs in `O(N^3)` time with `O(NM)` memory.  With `N ≤ 100` and
`M ≤ N`, the solution easily fits within limits.

## Reference

- [Problem statement](https://www.spoj.com/problems/BRCKGAME/)
