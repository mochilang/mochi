# [Exchange Operations](https://www.spoj.com/problems/EOPERA/)

## Problem Summary
We are given a sequence of the numbers `0..11` in some order. The number `0` can be swapped with another number at position `j` when:

- `|i - j|` is one of `1`, `3` or `6`, and
- for distance `1` the two indices must be in the same group of 3 (`i/3 == j/3`),
- for distance `3` the indices must be in the same group of 6 (`i/6 == j/6`),
- for distance `6` there is no extra restriction.

The task is to find the minimum number of such swaps needed to transform the sequence into the sorted order `0 1 2 3 4 5 6 7 8 9 10 11`.

## Algorithm
The state of the puzzle can be represented by the permutation itself.  From any
state we can generate neighbouring states by swapping `0` with the valid
positions listed above.  Because each move has equal cost, the shortest sequence
of moves can be found with a breadth‑first search (BFS).

1. Serialize the permutation to a string so it can be stored in a hash map of
   visited states.
2. Start BFS from the given permutation.  For each dequeued state:
   - locate the index of `0`;
   - generate new states by swapping it with the positions permitted by the
     rules (±1 within the same triple, ±3 within the same half, ±6 anywhere);
   - if a generated state has not been visited, enqueue it with distance + 1.
3. The search ends when the sorted permutation is found.  Its distance is the
   answer.

The state space is small enough that BFS over explored states is fast.  Each
state has at most six neighbours and the required depths are modest (below 20
for the given tests), so the search completes quickly.
