// Solution for SPOJ BOTTOM - The Bottom of a Graph
// https://www.spoj.com/problems/BOTTOM/

var tokens: list<string> = []
var tokIdx = 0

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 { parts = append(parts, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun nextToken(): string {
  while tokIdx >= len(tokens) {
    let line = input()
    if line == nil { return nil }
    tokens = splitSpaces(line)
    tokIdx = 0
  }
  let t = tokens[tokIdx]
  tokIdx = tokIdx + 1
  return t
}

fun nextInt(): int { return int(nextToken()) }

fun scc(n: int, adj: list<list<int>>, radj: list<list<int>>): list<int> {
  var used: list<bool> = []
  var i = 0
  while i < n {
    used = append(used, false)
    i = i + 1
  }
  var order: list<int> = []
  var v = 0
  while v < n {
    if !used[v] {
      var st: list<int> = []
      var it: list<int> = []
      st = append(st, v)
      it = append(it, 0)
      used[v] = true
      while len(st) > 0 {
        let cur = st[len(st)-1]
        let idxIt = it[len(it)-1]
        if idxIt < len(adj[cur]) {
          let to = adj[cur][idxIt]
          it[len(it)-1] = idxIt + 1
          if !used[to] {
            used[to] = true
            st = append(st, to)
            it = append(it, 0)
          }
        } else {
          order = append(order, cur)
          st = st[:len(st)-1]
          it = it[:len(it)-1]
        }
      }
    }
    v = v + 1
  }
  var comp: list<int> = []
  i = 0
  while i < n {
    comp = append(comp, -1)
    i = i + 1
  }
  var cid = 0
  var idxOrd = len(order) - 1
  while idxOrd >= 0 {
    let start = order[idxOrd]
    idxOrd = idxOrd - 1
    if comp[start] >= 0 { continue }
    var st: list<int> = []
    st = append(st, start)
    comp[start] = cid
    while len(st) > 0 {
      let cur = st[len(st)-1]
      st = st[:len(st)-1]
      var j = 0
      while j < len(radj[cur]) {
        let to = radj[cur][j]
        if comp[to] < 0 {
          comp[to] = cid
          st = append(st, to)
        }
        j = j + 1
      }
    }
    cid = cid + 1
  }
  return comp
}

fun main() {
  while true {
    let tok = nextToken()
    if tok == nil { return }
    let v = int(tok)
    if v == 0 { break }
    let e = nextInt()
    var adj: list<list<int>> = []
    var radj: list<list<int>> = []
    var i = 0
    while i < v {
      adj = append(adj, [])
      radj = append(radj, [])
      i = i + 1
    }
    var j = 0
    while j < e {
      let a = nextInt() - 1
      let b = nextInt() - 1
      adj[a] = append(adj[a], b)
      radj[b] = append(radj[b], a)
      j = j + 1
    }
    let comp = scc(v, adj, radj)
    var outComp: list<bool> = []
    i = 0
    while i < v {
      outComp = append(outComp, false)
      i = i + 1
    }
    i = 0
    while i < v {
      var k = 0
      while k < len(adj[i]) {
        let to = adj[i][k]
        if comp[i] != comp[to] {
          outComp[comp[i]] = true
        }
        k = k + 1
      }
      i = i + 1
    }
    var res: list<int> = []
    i = 0
    while i < v {
      if !outComp[comp[i]] {
        res = append(res, i + 1)
      }
      i = i + 1
    }
    var outStr = ""
    i = 0
    while i < len(res) {
      if i > 0 { outStr = outStr + " " }
      outStr = outStr + str(res[i])
      i = i + 1
    }
    print(outStr)
  }
}

main()
