// Solution for SPOJ MKJUMPS - Making Jumps
// https://www.spoj.com/problems/MKJUMPS/

var tokens: list<string> = []
var tokIdx = 0

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 { parts = append(parts, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun nextToken(): string {
  while tokIdx >= len(tokens) {
    let line = input()
    if line == nil { return nil }
    tokens = splitSpaces(line)
    tokIdx = 0
  }
  let t = tokens[tokIdx]
  tokIdx = tokIdx + 1
  return t
}

fun nextInt(): int {
  let t = nextToken()
  if t == nil { return 0 }
  return int(t)
}

fun makeBoolMatrix(rows: int, cols: int): list<list<bool>> {
  var mat: list<list<bool>> = []
  var r = 0
  while r < rows {
    var row: list<bool> = []
    var c = 0
    while c < cols {
      row = append(row, false)
      c = c + 1
    }
    mat = append(mat, row)
    r = r + 1
  }
  return mat
}

let dr = [-2,-2,-1,-1,1,1,2,2]
let dc = [-1,1,-2,2,-2,2,-1,1]

var board: list<list<bool>> = []
var visited: list<list<bool>> = []

fun dfs(r: int, c: int, count: int): int {
  var best = count
  var k = 0
  while k < 8 {
    let nr = r + dr[k]
    let nc = c + dc[k]
    if nr >= 0 && nr < 10 && nc >= 0 && nc < 10 {
      if board[nr][nc] {
        if !visited[nr][nc] {
          visited[nr][nc] = true
          let res = dfs(nr, nc, count + 1)
          if res > best { best = res }
          visited[nr][nc] = false
        }
      }
    }
    k = k + 1
  }
  return best
}

fun main() {
  var caseNum = 1
  while true {
    let n = nextInt()
    if n == 0 { break }
    board = makeBoolMatrix(10,10)
    visited = makeBoolMatrix(10,10)
    var offsets: list<int> = []
    var total = 0
    var i = 0
    while i < n {
      let off = nextInt()
      let cnt = nextInt()
      offsets = append(offsets, off)
      var c = 0
      while c < cnt {
        board[i][off + c] = true
        c = c + 1
      }
      total = total + cnt
      i = i + 1
    }
    visited[0][offsets[0]] = true
    let best = dfs(0, offsets[0], 1)
    let unreachable = total - best
    if unreachable == 1 {
      print("Case " + str(caseNum) + ", 1 square can not be reached.")
    } else {
      print("Case " + str(caseNum) + ", " + str(unreachable) + " squares can not be reached.")
    }
    caseNum = caseNum + 1
  }
}

main()
