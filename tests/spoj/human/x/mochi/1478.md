# [PT07B - The Easiest Problem](https://www.spoj.com/problems/PT07B/)

## Problem Summary
Given an undirected tree with up to one million nodes, find a largest connected subtree that is *special*. In a special tree, any node with degree at least three can have at most two neighbours whose degree is at least two. The output should be the number of nodes in such a maximal subtree followed by the list of edges belonging to it.

## Algorithm
1. Compute the degree of every node in the tree and assign each node a weight `w = degree - 1`.
2. The optimal special subtree has a backbone that is a single path. The size of the largest special subtree that uses a path `P` is `sum_{v in P}(degree(v) - 1) + 2`. Hence, we need the path that maximises the sum of weights.
3. To find this path, perform two breadth-first searches treating the weight of a node as the cost of entering it:
   - Run from an arbitrary node to find the farthest node `A` in terms of accumulated weight.
   - Run again from `A` to find the farthest node `B` and record parents to rebuild the path.
4. Reconstruct the path from `A` to `B`. Every node on this path belongs to the backbone of the special subtree.
5. The final subtree consists of this path plus every neighbour of a path node that is not on the path (each such neighbour becomes a leaf). The number of nodes is the length of the path plus the number of these additional leaves.
6. Output the node count followed by all edges of the subtree: first the path edges, then edges connecting path nodes to their extra leaf neighbours.

The algorithm runs in linear time `O(N)` and uses `O(N)` memory.
