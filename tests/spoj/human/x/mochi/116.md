# [Intervals](https://www.spoj.com/problems/INTERVAL/)

## Problem Summary
Given `n` integer intervals `[a_i, b_i]` and integers `c_i`, find the smallest set `Z` of integers such that each interval contains at least `c_i` elements of `Z`. The number line is limited to `0..50000` and multiple test cases are provided.

## Algorithm
1. **Sort intervals** by increasing right endpoint `b` (tie by `a`). Processing in this order lets us place required numbers as far right as possible.
2. Maintain a **Fenwick tree** over `0..50000` to count how many numbers have already been chosen.
3. Use a **disjoint-set union** that maps each index to the next free position on its left. After selecting position `p`, union it with `p-1` so subsequent searches skip it.
4. For each interval:
   - Let `cur = sum(b) - sum(a-1)` be the number of already chosen elements inside the interval.
   - While `cur < c_i`, repeatedly find the rightmost free position `p \le b` using the DSU, add it to the set (update Fenwick and DSU), and increment `cur`.
5. The total number of inserted positions is the minimal size of `Z`.

## Complexity
Sorting takes `O(n log n)` and each insertion costs `O(log U)` where `U = 50000`. Overall time is `O(n log n + ans log U)` with `O(U)` memory.
