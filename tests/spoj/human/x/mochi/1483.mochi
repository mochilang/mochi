// Solution for SPOJ PT07G - Colorful Lights Party
// https://www.spoj.com/problems/PT07G/

fun split(s: string, sep: string): list<string> {
  var parts: list<string> = []
  var cur: string = ""
  var i: int = 0
  while i < len(s) {
    if len(sep) > 0 && i + len(sep) <= len(s) && substring(s, i, i + len(sep)) == sep {
      parts = append(parts, cur)
      cur = ""
      i = i + len(sep)
    } else {
      cur = cur + s[i:i+1]
      i = i + 1
    }
  }
  parts = append(parts, cur)
  return parts
}

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var neg = false
  if len(str) > 0 && str[0:1] == "-" {
    neg = true
    i = 1
  }
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  if neg { n = -n }
  return n
}

fun tokenize(s: string): list<string> {
  var tokens: list<string> = []
  var cur: string = ""
  var i = 0
  while i < len(s) {
    let c = s[i:i+1]
    if c == " " || c == "\n" || c == "\t" || c == "\r" {
      if len(cur) > 0 {
        tokens = append(tokens, cur)
        cur = ""
      }
    } else {
      cur = cur + c
    }
    i = i + 1
  }
  if len(cur) > 0 { tokens = append(tokens, cur) }
  return tokens
}

type Edge { u: int, v: int }

fun solveSmall(n: int, edges: list<Edge>): list<int> {
  var adj: list<list<int>> = []
  var i = 0
  while i <= n {
    adj = append(adj, [])
    i = i + 1
  }
  i = 0
  while i < len(edges) {
    let e = edges[i]
    adj[e.u] = append(adj[e.u], e.v)
    adj[e.v] = append(adj[e.v], e.u)
    i = i + 1
  }
  var order: list<Edge> = []
  var visited: list<int> = []
  i = 0
  while i <= n {
    visited = append(visited, 0)
    i = i + 1
  }
  fun dfs(u: int, p: int) {
    visited[u] = 1
    var j = 0
    while j < len(adj[u]) {
      let v = adj[u][j]
      if v != p {
        order = append(order, Edge{u:u, v:v})
        if visited[v] == 0 { dfs(v, u) }
      }
      j = j + 1
    }
  }
  dfs(1, 0)
  var labels: list<int> = []
  i = 0
  while i <= n {
    labels = append(labels, 0 - 1)
    i = i + 1
  }
  labels[1] = 0
  var used: list<int> = []
  var diffUsed: list<int> = []
  i = 0
  while i < n {
    used = append(used, 0)
    diffUsed = append(diffUsed, 0)
    i = i + 1
  }
  used[0] = 1
  var found = 0
  fun backtrack(idx: int) {
    if idx == len(order) {
      found = 1
      return
    }
    let e = order[idx]
    let d = n - 1 - idx
    let parent = e.u
    let child = e.v
    if labels[child] != 0 - 1 {
      let diff = labels[parent] - labels[child]
      if diff < 0 { diff = -diff }
      if diff == d && diffUsed[d] == 0 {
        diffUsed[d] = 1
        backtrack(idx + 1)
        if found == 1 { return }
        diffUsed[d] = 0
      }
      return
    }
    var val = labels[parent] + d
    if val < n && used[val] == 0 {
      labels[child] = val
      used[val] = 1
      diffUsed[d] = 1
      backtrack(idx + 1)
      if found == 1 { return }
      labels[child] = 0 - 1
      used[val] = 0
      diffUsed[d] = 0
    }
    val = labels[parent] - d
    if val >= 0 && used[val] == 0 {
      labels[child] = val
      used[val] = 1
      diffUsed[d] = 1
      backtrack(idx + 1)
      if found == 1 { return }
      labels[child] = 0 - 1
      used[val] = 0
      diffUsed[d] = 0
    }
  }
  backtrack(0)
  if found == 0 {
    var res: list<int> = []
    i = 0
    while i < n {
      res = append(res, 0 - 1)
      i = i + 1
    }
    return res
  }
  var res: list<int> = []
  i = 1
  while i <= n {
    res = append(res, labels[i])
    i = i + 1
  }
  return res
}

fun solveLarge(k: int, t: int): list<int> {
  let n = 1 + k * (t + 1)
  var labels: list<int> = []
  var i = 0
  while i <= n {
    labels = append(labels, 0)
    i = i + 1
  }
  labels[1] = 0
  i = 1
  while i <= k {
    var j = 1
    while j <= t + 1 {
      let idx = 2 + (j - 1) * k + (i - 1)
      if j % 2 == 1 {
        labels[idx] = n - (i - 1) * (t + 1) - (j + 1) / 2
      } else {
        labels[idx] = (i - 1) * (t + 1) + j / 2
      }
      j = j + 1
    }
    i = i + 1
  }
  var res: list<int> = []
  i = 1
  while i <= n {
    res = append(res, labels[i])
    i = i + 1
  }
  return res
}

fun main() {
  var all: string = ""
  while true {
    let line = input()
    if line == nil { break }
    all = all + line + "\n"
  }
  let toks = tokenize(all)
  var idx = 0
  fun nextInt(): int {
    let v = parseIntStr(toks[idx])
    idx = idx + 1
    return v
  }
  let T = nextInt()
  var tc = 0
  while tc < T {
    let kind = nextInt()
    if kind == 1 {
      let n = nextInt()
      var edges: list<Edge> = []
      var i = 0
      while i < n - 1 {
        let u = nextInt()
        let v = nextInt()
        edges = append(edges, Edge{u:u, v:v})
        i = i + 1
      }
      let ans = solveSmall(n, edges)
      var out = ""
      i = 0
      while i < len(ans) {
        out = out + str(ans[i])
        if i + 1 < len(ans) { out = out + " " }
        i = i + 1
      }
      print(out)
    } else {
      let k = nextInt()
      let t = nextInt()
      let ans = solveLarge(k, t)
      var out = ""
      var i = 0
      while i < len(ans) {
        out = out + str(ans[i])
        if i + 1 < len(ans) { out = out + " " }
        i = i + 1
      }
      print(out)
    }
    tc = tc + 1
  }
}

main()
