# Optimal Marks

We are given an undirected graph where some vertices have fixed marks (0 ≤ mark < 2^31). For an edge (u,v) the cost is `mark[u] xor mark[v]`. The task is to assign marks to the remaining vertices so that the total cost is minimal. If several assignments have the same cost, the one with the smallest sum of marks should be output.

## Algorithm

For any connected component made only of unknown vertices, assigning different values to its vertices would introduce additional cost on edges inside the component. Therefore every such component should receive a single value `x`.

Consider all edges between this component and known vertices. Let `S` be the multiset of marks of the known endpoints (each edge contributes one value). For a candidate value `x`, the cost contributed by the component is `sum_{p in S} (x xor p)`.

Since XOR works bitwise, each bit position can be optimized independently. For a particular bit:

* `count1` – number of edges in `S` whose known endpoint has that bit set.
* `total` – total number of edges in `S`.

Setting the bit to 1 gives cost `total - count1`, while setting it to 0 gives `count1`. We choose 1 when `count1 > total/2`; otherwise we choose 0. Ties are resolved toward 0 which also minimizes the sum of marks.

After computing `x`, assign this value to every vertex in the component. Components that have no edges to known vertices receive mark 0.

## Correctness

- All vertices in a component share one value. Any differing assignment would introduce extra XOR cost on some internal edge and cannot reduce costs elsewhere.
- For a fixed component, the cost depends only on edges to known vertices. Optimizing each bit independently yields the minimum `sum (x xor p)` by a majority decision for that bit. Choosing 0 on ties ensures the minimal total mark sum.

Thus the algorithm produces an assignment with minimal total edge cost and, among those, minimal sum of marks.

## Complexity

Let B = 31 be the number of bits in marks. Each vertex and edge is processed once while exploring components, and each incident edge to a known vertex updates B counters. The overall time complexity is `O((N + M) * B)` which satisfies the problem limits (N ≤ 500, M ≤ 3000).
