// Solution for SPOJ SOLIT - Solitaire
// https://www.spoj.com/problems/SOLIT/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  return n
}

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 { parts = append(parts, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun parseInts(line: string): list<int> {
  let parts = splitSpaces(line)
  var nums: list<int> = []
  var i = 0
  while i < len(parts) {
    nums = append(nums, parseIntStr(parts[i]))
    i = i + 1
  }
  return nums
}

fun sortInts(arr: list<int>): list<int> {
  var i = 1
  while i < len(arr) {
    var j = i
    while j > 0 && arr[j-1] > arr[j] {
      let tmp = arr[j-1]
      arr[j-1] = arr[j]
      arr[j] = tmp
      j = j - 1
    }
    i = i + 1
  }
  return arr
}

fun encode(pos: list<int>): int {
  // assumes pos sorted
  return ((pos[0]*64 + pos[1])*64 + pos[2])*64 + pos[3]
}

fun neighbors(state: list<int>): list<list<int>> {
  var occ: list<bool> = []
  var i = 0
  while i < 64 {
    occ = append(occ, false)
    i = i + 1
  }
  for p in state { occ[p] = true }
  let drs = [-1,1,0,0]
  let dcs = [0,0,-1,1]
  var res: list<list<int>> = []
  var idx = 0
  while idx < 4 {
    let p = state[idx]
    let r = p / 8
    let c = p % 8
    var d = 0
    while d < 4 {
      let nr = r + drs[d]
      let nc = c + dcs[d]
      if nr >= 0 && nr < 8 && nc >= 0 && nc < 8 {
        let np = nr * 8 + nc
        if occ[np] == false {
          var ns = state[0:len(state)]
          ns[idx] = np
          ns = sortInts(ns)
          res = append(res, ns)
        } else {
          let nr2 = r + drs[d] * 2
          let nc2 = c + dcs[d] * 2
          if nr2 >= 0 && nr2 < 8 && nc2 >= 0 && nc2 < 8 {
            let np2 = nr2 * 8 + nc2
            if occ[np] && occ[np2] == false {
              var ns2 = state[0:len(state)]
              ns2[idx] = np2
              ns2 = sortInts(ns2)
              res = append(res, ns2)
            }
          }
        }
      }
      d = d + 1
    }
    idx = idx + 1
  }
  return res
}

fun reachable(start: list<int>, goal: list<int>): bool {
  let goalEnc = encode(goal)
  if encode(start) == goalEnc { return true }
  var visited: map<int, bool> = {}
  visited[encode(start)] = true
  var queue: list<list<int>> = [start]
  var depth: list<int> = [0]
  var qi = 0
  while qi < len(queue) {
    let st = queue[qi]
    let d = depth[qi]
    qi = qi + 1
    if d == 8 { continue }
    let neigh = neighbors(st)
    var i = 0
    while i < len(neigh) {
      let ns = neigh[i]
      let enc = encode(ns)
      if visited[enc] == nil {
        if enc == goalEnc { return true }
        visited[enc] = true
        queue = append(queue, ns)
        depth = append(depth, d + 1)
      }
      i = i + 1
    }
  }
  return false
}

fun parseConfig(nums: list<int>): list<int> {
  var pos: list<int> = []
  var i = 0
  while i < 8 {
    let r = nums[i]
    let c = nums[i+1]
    pos = append(pos, (r-1) * 8 + (c-1))
    i = i + 2
  }
  return sortInts(pos)
}

fun main() {
  let tStr = input()
  if tStr == nil || tStr == "" { return }
  let t = parseIntStr(tStr)
  for _ in 0..t {
    let startNums = parseInts(input())
    let goalNums = parseInts(input())
    let start = parseConfig(startNums)
    let goal = parseConfig(goalNums)
    if reachable(start, goal) { print("YES") } else { print("NO") }
  }
}

main()
