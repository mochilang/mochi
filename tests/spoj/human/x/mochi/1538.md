# [Making Jumps](https://www.spoj.com/problems/MKJUMPS/)

## Problem Summary
Given a jagged chessboard (each row may start after a horizontal offset and have a specific length), a knight starts in the
upper-left valid square. The knight may move in the standard `2+1` L-shape and must never land on a square more than once.
The task is to determine how many squares cannot be visited in such a path.

## Algorithm
1. **Board Construction** – Build a `10 x 10` boolean grid and mark the valid squares for each row according to its offset and
   width.
2. **Backtracking Search** – Starting from the top-left square, explore all possible knight moves with a recursive DFS that
   tracks visited squares. After each move, backtrack to explore alternative paths and keep the longest path length found.
3. **Answer** – Subtract the length of the longest achievable path from the total number of valid squares to obtain the number
   of unreachable squares. Output the result with proper singular/plural wording.

With at most 100 squares, this exhaustive search is fast enough for the given constraints.
