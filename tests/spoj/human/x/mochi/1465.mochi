// Solution for SPOJ CHRIS - On the Way to Find Chris
// https://www.spoj.com/problems/CHRIS/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseInts(line: string): list<int> {
  var nums: list<int> = []
  var i = 0
  var cur = 0
  var sign = 1
  var inNum = false
  while i < len(line) {
    let ch = line[i:i+1]
    if ch == "-" {
      sign = -1
      i = i + 1
    } else if ch >= "0" && ch <= "9" {
      cur = cur * 10 + (digits[ch] as int)
      inNum = true
      i = i + 1
    } else {
      if inNum {
        nums = append(nums, sign * cur)
        cur = 0
        sign = 1
        inNum = false
      }
      i = i + 1
    }
  }
  if inNum {
    nums = append(nums, sign * cur)
  }
  return nums
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let t = tLine as int
  var case = 0
  while case < t {
    var line = input()
    while line == "" { line = input() }
    let parts = parseInts(line)
    let n = parts[0] as int
    let m = parts[1] as int

    var adj: list<list<int>> = []
    var wt: list<list<int>> = []
    var i = 0
    while i < n {
      adj = append(adj, [])
      wt = append(wt, [])
      i = i + 1
    }

    var e = 0
    while e < m {
      line = input()
      if line == "" { continue }
      let p = parseInts(line)
      let x = (p[0] as int) - 1
      let y = (p[1] as int) - 1
      let z = p[2] as int
      adj[x] = append(adj[x], y)
      wt[x] = append(wt[x], z)
      adj[y] = append(adj[y], x)
      wt[y] = append(wt[y], z)
      e = e + 1
    }

    var parent: list<int> = []
    var order: list<int> = []
    var stack: list<int> = [0]
    i = 0
    while i < n {
      parent = append(parent, -1)
      i = i + 1
    }
    parent[0] = 0
    while len(stack) > 0 {
      let u = stack[len(stack)-1] as int
      stack = stack[0:len(stack)-1]
      order = append(order, u)
      var j = 0
      while j < len(adj[u]) {
        let v = adj[u][j] as int
        if v != parent[u] {
          parent[v] = u
          stack = append(stack, v)
        }
        j = j + 1
      }
    }

    var best1: list<int> = []
    var best2: list<int> = []
    var child1: list<int> = []
    i = 0
    while i < n {
      best1 = append(best1, 0)
      best2 = append(best2, 0)
      child1 = append(child1, -1)
      i = i + 1
    }

    i = len(order) - 1
    while i >= 0 {
      let u = order[i] as int
      var j = 0
      while j < len(adj[u]) {
        let v = adj[u][j] as int
        if v != parent[u] {
          let dist = (wt[u][j] as int) + best1[v]
          if dist > best1[u] {
            best2[u] = best1[u]
            best1[u] = dist
            child1[u] = v
          } else if dist > best2[u] {
            best2[u] = dist
          }
        }
        j = j + 1
      }
      i = i - 1
    }

    var up: list<int> = []
    i = 0
    while i < n {
      up = append(up, 0)
      i = i + 1
    }

    i = 0
    while i < len(order) {
      let u = order[i] as int
      var j = 0
      while j < len(adj[u]) {
        let v = adj[u][j] as int
        if v != parent[u] {
          var use = best1[u]
          if child1[u] == v { use = best2[u] }
          var cand = up[u]
          if use > cand { cand = use }
          up[v] = cand + (wt[u][j] as int)
        }
        j = j + 1
      }
      i = i + 1
    }

    var ans = 0
    var u = 0
    while u < n {
      var d1 = 0
      var d2 = 0
      var d3 = 0
      var val = up[u]
      if val > d1 { d3 = d2; d2 = d1; d1 = val }
      else if val > d2 { d3 = d2; d2 = val }
      else if val > d3 { d3 = val }
      var j = 0
      while j < len(adj[u]) {
        let v = adj[u][j] as int
        if v != parent[u] {
          val = (wt[u][j] as int) + best1[v]
          if val > d1 { d3 = d2; d2 = d1; d1 = val }
          else if val > d2 { d3 = d2; d2 = val }
          else if val > d3 { d3 = val }
        }
        j = j + 1
      }
      let cand = d1 + 2*d2 + d3
      if cand > ans { ans = cand }
      u = u + 1
    }

    print(str(ans))
    case = case + 1
  }
}

main()
