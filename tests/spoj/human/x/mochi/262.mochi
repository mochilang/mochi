// Solution for SPOJ CONNECT - Connections
// https://www.spoj.com/problems/CONNECT/

type Edge { to: int, cost: int }

type PQNode { v: int, w: int }

type PopRes { heap: list<PQNode>, node: PQNode }

type Query { c: int, d: int, k: int, idx: int }

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseInts(line: string): list<int> {
  var nums: list<int> = []
  var i = 0
  var cur = 0
  var sign = 1
  var has = false
  while i < len(line) {
    let ch = line[i:i+1]
    if ch == "-" {
      sign = -1
      i = i + 1
    } else if ch >= "0" && ch <= "9" {
      cur = cur * 10 + (digits[ch] as int)
      has = true
      i = i + 1
    } else {
      if has {
        nums = append(nums, sign * cur)
        cur = 0
        sign = 1
        has = false
      }
      i = i + 1
    }
  }
  if has { nums = append(nums, sign * cur) }
  return nums
}

fun make_edge_list(n: int): list<list<Edge>> {
  var lst: list<list<Edge>> = []
  var i = 0
  while i <= n {
    lst = append(lst, [])
    i = i + 1
  }
  return lst
}

fun make_int_list(n: int, value: int): list<int> {
  var lst: list<int> = []
  var i = 0
  while i < n {
    lst = append(lst, value)
    i = i + 1
  }
  return lst
}

fun make_query_groups(n: int): list<list<Query>> {
  var groups: list<list<Query>> = []
  var i = 0
  while i <= n {
    groups = append(groups, [])
    i = i + 1
  }
  return groups
}

fun sortInts(arr: list<int>): list<int> {
  var i = 1
  while i < len(arr) {
    var j = i
    while j > 0 && arr[j-1] > arr[j] {
      let tmp = arr[j-1]
      arr[j-1] = arr[j]
      arr[j] = tmp
      j = j - 1
    }
    i = i + 1
  }
  return arr
}

fun heap_push(h: list<PQNode>, item: PQNode): list<PQNode> {
  var heap = append(h, item)
  var i = len(heap) - 1
  while i > 0 {
    let p = (i - 1) / 2
    if heap[p].w <= heap[i].w { break }
    let tmp = heap[p]
    heap[p] = heap[i]
    heap[i] = tmp
    i = p
  }
  return heap
}

fun heap_pop(h: list<PQNode>): PopRes {
  let top = h[0]
  var heap = h[0:len(h)-1]
  if len(heap) > 0 {
    heap[0] = h[len(h)-1]
    var i = 0
    while true {
      let l = 2*i + 1
      let r = 2*i + 2
      var smallest = i
      if l < len(heap) && heap[l].w < heap[smallest].w { smallest = l }
      if r < len(heap) && heap[r].w < heap[smallest].w { smallest = r }
      if smallest == i { break }
      let tmp = heap[i]
      heap[i] = heap[smallest]
      heap[smallest] = tmp
      i = smallest
    }
  }
  return PopRes { heap: heap, node: top }
}

fun dijkstraK(graph: list<list<Edge>>, n: int, src: int, need: list<int>): list<list<int>> {
  var dist: list<list<int>> = []
  var i = 0
  while i <= n {
    dist = append(dist, [])
    i = i + 1
  }
  var heap: list<PQNode> = []
  heap = heap_push(heap, PQNode{ v:src, w:0 })
  while len(heap) > 0 {
    let pr = heap_pop(heap)
    heap = pr.heap
    let cur = pr.node
    if len(dist[cur.v]) >= need[cur.v] { continue }
    dist[cur.v] = append(dist[cur.v], cur.w)
    var j = 0
    while j < len(graph[cur.v]) {
      let e = graph[cur.v][j]
      let nd = cur.w + e.cost
      if len(dist[e.to]) < need[e.to] {
        heap = heap_push(heap, PQNode{ v:e.to, w:nd })
      }
      j = j + 1
    }
  }
  return dist
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let T = tLine as int
  var case = 0
  while case < T {
    var line = input()
    while line == "" { line = input() }
    var nm = parseInts(line)
    let n = nm[0]
    let m = nm[1]
    var g = make_edge_list(n)
    var i = 0
    while i < m {
      let l = input()
      if l == "" { continue }
      let parts = parseInts(l)
      let a = parts[0]
      let b = parts[1]
      let w = parts[2]
      g[a] = append(g[a], Edge{ to:b, cost:w })
      i = i + 1
    }
    var qLine = input()
    while qLine == "" { qLine = input() }
    let q = qLine as int
    var groups = make_query_groups(n)
    var queries: list<Query> = []
    var idx = 0
    while idx < q {
      let l = input()
      if l == "" { continue }
      let ps = parseInts(l)
      let c = ps[0]
      let d = ps[1]
      let k = ps[2]
      let qu = Query{ c:c, d:d, k:k, idx:idx }
      queries = append(queries, qu)
      groups[c] = append(groups[c], qu)
      idx = idx + 1
    }
    var ans = make_int_list(q, 0)
    var s = 1
    while s <= n {
      if len(groups[s]) == 0 {
        s = s + 1
        continue
      }
      var maxK = 0
      var j = 0
      while j < len(groups[s]) {
        let qu = groups[s][j]
        let needK = if qu.c == qu.d { qu.k + 1 } else { qu.k }
        if needK > maxK { maxK = needK }
        j = j + 1
      }
      var need = make_int_list(n+1, maxK)
      let dists = dijkstraK(g, n, s, need)
      var v = 1
      while v <= n {
        if len(dists[v]) > 1 {
          dists[v] = sortInts(dists[v])
        }
        v = v + 1
      }
      j = 0
      while j < len(groups[s]) {
        let qu = groups[s][j]
        let ds = dists[qu.d]
        if qu.c == qu.d {
          if qu.k < len(ds) {
            ans[qu.idx] = ds[qu.k]
          } else {
            ans[qu.idx] = -1
          }
        } else {
          if qu.k <= len(ds) {
            ans[qu.idx] = ds[qu.k-1]
          } else {
            ans[qu.idx] = -1
          }
        }
        j = j + 1
      }
      s = s + 1
    }
    var outIdx = 0
    while outIdx < q {
      print(str(ans[outIdx]))
      outIdx = outIdx + 1
    }
    print("")
    case = case + 1
  }
}

main()
