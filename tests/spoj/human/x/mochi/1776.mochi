/*
SPOJ: DNALAB - DNA Laboratory
https://www.spoj.com/problems/DNALAB/
*/

fun contains(a: string, b: string): bool {
  if len(b) > len(a) { return false }
  var i: int = 0
  while i <= len(a) - len(b) {
    if a[i:i+len(b)] == b { return true }
    i = i + 1
  }
  return false
}

fun dedup(arr: list<string>): list<string> {
  var seen: map<string,bool> = {}
  var res: list<string> = []
  var i = 0
  while i < len(arr) {
    let s = arr[i]
    if seen[s] == nil {
      seen[s] = true
      res = append(res, s)
    }
    i = i + 1
  }
  return res
}

fun removeSubs(arr: list<string>): list<string> {
  var res: list<string> = []
  var i = 0
  while i < len(arr) {
    var j = 0
    var skip = false
    while j < len(arr) {
      if i != j && contains(arr[j], arr[i]) {
        skip = true
        break
      }
      j = j + 1
    }
    if !skip {
      res = append(res, arr[i])
    }
    i = i + 1
  }
  return res
}

fun overlap(a: string, b: string): int {
  var k = len(a)
  if len(b) < k { k = len(b) }
  while k > 0 {
    if a[len(a)-k:len(a)] == b[0:k] { return k }
    k = k - 1
  }
  return 0
}

fun shortestSuper(strs: list<string>): string {
  var arr = dedup(strs)
  arr = removeSubs(arr)
  let n = len(arr)
  if n == 0 { return "" }
    var over: list<list<int> > = []
    var i = 0
    while i < n {
      var row: list<int> = []
      var j = 0
      while j < n {
        if i == j {
          row = append(row, 0)
        } else {
          row = append(row, overlap(arr[i], arr[j]))
        }
        j = j + 1
      }
      over = append(over, row)
      i = i + 1
    }
    var pow2: list<int> = []
    i = 0
    while i < n {
      if i == 0 { pow2 = append(pow2, 1) } else { pow2 = append(pow2, pow2[i-1] * 2) }
      i = i + 1
    }
    let total = pow2[n-1] * 2
    var dp: list<list<string> > = []
    var mask = 0
    while mask < total {
      var row: list<string> = []
      var k = 0
      while k < n {
        row = append(row, "")
        k = k + 1
      }
      dp = append(dp, row)
      mask = mask + 1
    }
    i = 0
    while i < n {
      dp[pow2[i]][i] = arr[i]
      i = i + 1
    }
    mask = 0
    while mask < total {
    i = 0
    while i < n {
      let cur = dp[mask][i]
      if len(cur) > 0 {
            var j = 0
            while j < n {
              let b = pow2[j]
              if ((mask / b) % 2) == 0 {
                let add = arr[j][over[i][j]:len(arr[j])]
                let cand = cur + add
                let nextMask = mask + b
                let old = dp[nextMask][j]
                if old == "" || len(cand) < len(old) || (len(cand) == len(old) && cand < old) {
                  dp[nextMask][j] = cand
                }
              }
              j = j + 1
            }
      }
      i = i + 1
    }
    mask = mask + 1
  }
  var best = ""
  i = 0
  let full = total - 1
  while i < n {
    let s = dp[full][i]
    if s != "" {
      if best == "" || len(s) < len(best) || (len(s) == len(best) && s < best) {
        best = s
      }
    }
    i = i + 1
  }
  return best
}

fun main() {
  let tLine = input()
  if tLine == nil { return }
  let t = int(tLine)
  var case = 1
  while case <= t {
    var line = input()
    while line == "" { line = input() }
    let n = int(line)
    var strs: list<string> = []
    var i = 0
    while i < n {
      let s = input()
      if s == nil { s = "" }
      if s == "" { continue }
      strs = append(strs, s)
      i = i + 1
    }
    let ans = shortestSuper(strs)
    print("Scenario #" + str(case) + ":")
    print(ans)
    if case < t { print("") }
    case = case + 1
  }
}

main()
