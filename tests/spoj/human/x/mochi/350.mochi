# Solution for SPOJ LANDSCAP - Landscaping
# https://www.spoj.com/problems/LANDSCAP/

fun readInts(line: string): list<int> {
  var nums: list<int> = []
  var cur = ""
  var i = 0
  while i < len(line) {
    let ch = line[i:i+1]
    if ch == " " {
      if len(cur) > 0 {
        nums = append(nums, cur as int)
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 {
    nums = append(nums, cur as int)
  }
  return nums
}

let INF = 1000000000000

fun costPeak(a: list<int>, l: int, r: int): int {
  var best = INF
  var m = l
  while m <= r {
    let peak = a[m]
    var cost = 0
    var h = peak
    var i = m - 1
    while i >= l {
      if a[i] > h {
        cost = cost + (a[i] - h)
      } else {
        h = a[i]
      }
      i = i - 1
    }
    h = peak
    i = m + 1
    while i <= r {
      if a[i] > h {
        cost = cost + (a[i] - h)
      } else {
        h = a[i]
      }
      i = i + 1
    }
    if cost < best { best = cost }
    m = m + 1
  }
  return best
}

fun solveCase(n: int, k: int, a: list<int>): int {
  var cost: list<list<int>> = []
  var i = 0
  while i < n {
    var row: list<int> = []
    var j = 0
    while j < n {
      row = append(row, 0)
      j = j + 1
    }
    cost = append(cost, row)
    i = i + 1
  }
  var l = 0
  while l < n {
    var r = l
    while r < n {
      cost[l][r] = costPeak(a, l, r)
      r = r + 1
    }
    l = l + 1
  }
  var K = k
  if K > n { K = n }
  var dp: list<list<int>> = []
  var kk = 0
  while kk <= K {
    var row: list<int> = []
    var j = 0
    while j < n {
      row = append(row, INF)
      j = j + 1
    }
    dp = append(dp, row)
    kk = kk + 1
  }
  var r = 0
  while r < n {
    dp[1][r] = cost[0][r]
    r = r + 1
  }
  var kcur = 2
  while kcur <= K {
    r = 0
    while r < n {
      var best = INF
      var p = 0
      while p < r {
        let v = dp[kcur-1][p] + cost[p+1][r]
        if v < best { best = v }
        p = p + 1
      }
      dp[kcur][r] = best
      r = r + 1
    }
    kcur = kcur + 1
  }
  var ans = INF
  var kk2 = 1
  while kk2 <= K {
    if dp[kk2][n-1] < ans { ans = dp[kk2][n-1] }
    kk2 = kk2 + 1
  }
  return ans
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let T = tLine as int
  var case = 0
  while case < T {
    let nk = readInts(input())
    let n = nk[0]
    let k = nk[1]
    var a: list<int> = []
    var i = 0
    while i < n {
      let h = int(input())
      a = append(a, h)
      i = i + 1
    }
    print(str(solveCase(n, k, a)))
    case = case + 1
  }
}

main()
