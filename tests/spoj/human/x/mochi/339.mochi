// Solution for SPOJ SEQ - Recursive Sequence
// https://www.spoj.com/problems/SEQ/

let MOD = 1000000000

let digits = {
  "0":0, "1":1, "2":2, "3":3, "4":4,
  "5":5, "6":6, "7":7, "8":8, "9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  return n
}

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 { parts = append(parts, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun parseInts(line: string): list<int> {
  let parts = splitSpaces(line)
  var nums: list<int> = []
  var i = 0
  while i < len(parts) {
    nums = append(nums, parseIntStr(parts[i]))
    i = i + 1
  }
  return nums
}

fun matMul(a: list<list<int>>, b: list<list<int>>): list<list<int>> {
  let n = len(a)
  let m = len(b[0])
  let p = len(b)
  var res: list<list<int>> = []
  var i = 0
  while i < n {
    var row: list<int> = []
    var j = 0
    while j < m {
      row = append(row, 0)
      j = j + 1
    }
    res = append(res, row)
    i = i + 1
  }
  i = 0
  while i < n {
    var j = 0
    while j < m {
      var val = 0
      var k = 0
      while k < p {
        val = (val + (a[i][k] * b[k][j]) % MOD) % MOD
        k = k + 1
      }
      res[i][j] = val
      j = j + 1
    }
    i = i + 1
  }
  return res
}

fun matPow(m: list<list<int>>, power: int): list<list<int>> {
  let size = len(m)
  var result: list<list<int>> = []
  var i = 0
  while i < size {
    var row: list<int> = []
    var j = 0
    while j < size {
      if i == j { row = append(row, 1) } else { row = append(row, 0) }
      j = j + 1
    }
    result = append(result, row)
    i = i + 1
  }
  var base = m
  var p = power
  while p > 0 {
    if p % 2 == 1 { result = matMul(result, base) }
    base = matMul(base, base)
    p = p / 2
  }
  return result
}

fun solve(k: int, b: list<int>, c: list<int>, n: int): int {
  if n <= k { return b[n-1] % MOD }
  var T: list<list<int>> = []
  var firstRow: list<int> = []
  var i = 0
  while i < k {
    firstRow = append(firstRow, c[i] % MOD)
    i = i + 1
  }
  T = append(T, firstRow)
  i = 1
  while i < k {
    var row: list<int> = []
    var j = 0
    while j < k {
      if j == i-1 { row = append(row, 1) } else { row = append(row, 0) }
      j = j + 1
    }
    T = append(T, row)
    i = i + 1
  }
  let M = matPow(T, n - k)
  var F: list<list<int>> = []
  var idx = k - 1
  while idx >= 0 {
    F = append(F, [b[idx] % MOD])
    idx = idx - 1
  }
  let res = matMul(M, F)
  return res[0][0] % MOD
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let t = parseIntStr(tLine)
  var case = 0
  while case < t {
    let kLine = input()
    let k = parseIntStr(kLine)
    let bLine = input()
    let bVals = parseInts(bLine)
    let cLine = input()
    let cVals = parseInts(cLine)
    let nLine = input()
    let n = parseIntStr(nLine)
    let ans = solve(k, bVals, cVals, n)
    print(str(ans))
    case = case + 1
  }
}

main()
