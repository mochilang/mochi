# ROMAN - Converting number formats

We are given numbers spelled out digit by digit using uppercase English words
("ZERO", "ONE", ..., "NINE" with `OH` as an alias for zero).  The first line
contains the number of test cases.  For each case we must convert the numeric
value into a variant of Roman numerals that supports values up to 32‑bit by
using overlines and lowercase letters.

## Algorithm

1. **Parse digits** – split the line on spaces and map each word to its digit
   character to build the decimal string, then convert it to an integer.
2. **Roman for values < 4000** – a standard greedy conversion using value and
   symbol tables.
3. **Millions part** – `n / 1_000_000` is converted with the Roman helper and
   converted to lowercase to denote "×1,000,000"; the first output line gets
   matching spaces.
4. **Thousands part** – from the remainder, take `k = rem / 1000`:
   - If `k >= 4`, convert `k` to Roman.  Any trailing `I`'s are peeled off and
     emitted as plain `M`'s (1000) without an overline.
   - The remaining prefix is written normally and the first line receives
     underscores of equal length to show an overline.
   - If `k < 4`, output `M` repeated `k` times with no overline.
5. **Units** – convert `rem % 1000` with the Roman helper and append spaces of
   equal length to the first line.
6. **Output** – print two lines: underscores/spaces for the overline row and the
   constructed Roman numeral row.

This approach mirrors the “butchered” Roman system used by the original
problem: lowercase letters indicate millions and underscores mark an overline
for thousands.
