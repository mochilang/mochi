# The Bytelandian Cryptographer (Act I)

Problem: [https://www.spoj.com/problems/CRYPTO1](https://www.spoj.com/problems/CRYPTO1)

## Algorithm

1. Read integer `r`, the encrypted timestamp.
2. Compute `t` such that `t^2 ≡ r (mod p)` where `p = 4000000007`.
   - Because `p ≡ 3 (mod 4)`, the square root is `r^{(p+1)/4} mod p`.
   - The prime modulus yields two roots `t` and `p - t`.
   - Select the smaller root, which lies in the valid timestamp range.
3. Convert `t` seconds since Unix epoch to a GMT date/time string.
   - Decompose `t` into total days and day seconds.
   - Iterate years and months accounting for leap years.
   - Compute weekday from total days (`1970-01-01` is Thursday).
   - Format as `Sun Jun 13 16:20:39 2004` using ctime's 26‑character style.

## Correctness

- For primes `p ≡ 3 (mod 4)`, raising to `(p+1)/4` gives a square root `x` with `x^2 ≡ r (mod p)`.
- `p - x` is the second root; exactly one is within `[0, p/2)` and equals the true timestamp.
- Unix timestamp conversion with leap year logic yields the correct UTC date.
- Formatting functions pad components to match the required layout.

## Complexity

- Modular exponentiation runs in `O(log p)` time.
- Date conversion iterates over years and months at most 60+12 times.
- Overall time complexity is `O(log p)` and memory usage is `O(1)`.

## References

- [Modular square root](https://en.wikipedia.org/wiki/Modular_square_root)
