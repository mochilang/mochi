# SPOJ VHUFFM - Variable Radix Huffman Encoding

We must encode the first `N` letters (A..Z) using an `R`-ary Huffman code. The
frequencies for each letter are given. When `R>2` the number of symbols must
satisfy `N' = R + k*(R-1)`; we pad with zero‑frequency dummy symbols to meet this.

## Algorithm
1. Read datasets until `R = 0`.
2. For each set, append dummy letters so that `(N' - R) % (R-1) = 0`.
3. Build nodes with fields: `freq`, `min` (smallest original letter index for
   tie-breaking), and `letters` (indices contained).
4. Repeat until one node remains:
   - Sort nodes by `(freq, min)`.
   - Take the lowest `R` nodes, assign digits `0..R-1` to them (lowest
     frequency gets the smallest digit) and prepend the digit to every letter's
     code in that node.
   - Merge these nodes into a new combination node and push back to the list.
5. After codes are produced for the first `N` letters, compute the weighted
   average length `sum(freq[i]*len(code[i])) / sum(freq[i])`, rounded to two
   decimals.
6. Output the set number, average length, and each letter with its code.

This direct simulation of the general `R`‑ary Huffman algorithm works because
`N ≤ 26`, so the data structures remain small.
