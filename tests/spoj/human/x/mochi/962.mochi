// Solution for SPOJ IM - Intergalactic Map
// https://www.spoj.com/problems/IM/

fun parseIntStr(str: string): int {
  let digits = {
    "0":0,"1":1,"2":2,"3":3,"4":4,
    "5":5,"6":6,"7":7,"8":8,"9":9,
  }
  var i = 0
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  return n
}

fun split_ws(s: string): list<string> {
  var res: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " {
      if cur != "" {
        res = append(res, cur)
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if cur != "" { res = append(res, cur) }
  return res
}

type Edge = { to: int, rev: int, cap: int }

fun minInt(a: int, b: int): int { if a < b { return a } return b }

fun addEdge(g: list<list<Edge>>, u: int, v: int, c: int): list<list<Edge>> {
  let r1 = len(g[v])
  let r2 = len(g[u])
  g[u] = append(g[u], Edge{ to: v, rev: r1, cap: c })
  g[v] = append(g[v], Edge{ to: u, rev: r2, cap: 0 })
  return g
}

fun bfs(g: list<list<Edge>>, s: int, t: int): list<int> {
  var level: list<int> = []
  var i = 0
  while i < len(g) {
    level = append(level, 0 - 1)
    i = i + 1
  }
  var q: list<int> = []
  q = append(q, s)
  level[s] = 0
  var qi = 0
  while qi < len(q) {
    let v = q[qi]
    qi = qi + 1
    var j = 0
    while j < len(g[v]) {
      let e = g[v][j]
      if e.cap > 0 && level[e.to] == 0 - 1 {
        level[e.to] = level[v] + 1
        q = append(q, e.to)
      }
      j = j + 1
    }
  }
  return level
}

fun dfs(g: list<list<Edge>>, level: list<int>, iter: list<int>, v: int, t: int, f: int): int {
  if v == t { return f }
  var i = iter[v]
  while i < len(g[v]) {
    let e = g[v][i]
    if e.cap > 0 && level[v] + 1 == level[e.to] {
      let d = dfs(g, level, iter, e.to, t, minInt(f, e.cap))
      if d > 0 {
        let e1 = g[v][i]
        g[v][i] = Edge{ to: e1.to, rev: e1.rev, cap: e1.cap - d }
        let ri = e1.rev
        let re = g[e1.to][ri]
        g[e1.to][ri] = Edge{ to: re.to, rev: re.rev, cap: re.cap + d }
        return d
      }
    }
    i = i + 1
    iter[v] = i
  }
  return 0
}

fun maxflow(g: list<list<Edge>>, s: int, t: int): int {
  var flow = 0
  let n = len(g)
  while true {
    let level = bfs(g, s, t)
    if level[t] == 0 - 1 { break }
    var iter: list<int> = []
    var i = 0
    while i < n { iter = append(iter, 0); i = i + 1 }
    while true {
      let f = dfs(g, level, iter, s, t, 1000000000)
      if f == 0 { break }
      flow = flow + f
    }
  }
  return flow
}

fun solve(n: int, edges: list<list<int>>): string {
  let total = 2 * n + 1
  var g: list<list<Edge>> = []
  var i = 0
  while i <= total {
    g = append(g, [])
    i = i + 1
  }
  var v = 1
  while v <= n {
    if v == 2 {
      g = addEdge(g, v, v + n, 2)
    } else if v != 1 && v != 3 {
      g = addEdge(g, v, v + n, 1)
    }
    v = v + 1
  }
  var e = 0
  while e < len(edges) {
    let a = edges[e][0]
    let b = edges[e][1]
    if a != 1 && a != 3 && b != 2 {
      g = addEdge(g, a + n, b, 1)
    }
    if b != 1 && b != 3 && a != 2 {
      g = addEdge(g, b + n, a, 1)
    }
    e = e + 1
  }
  let sink = 2 * n + 1
  g = addEdge(g, 1, sink, 1)
  g = addEdge(g, 3, sink, 1)
  let source = 2 + n
  let f = maxflow(g, source, sink)
  if f >= 2 { return "YES" }
  return "NO"
}

fun main() {
  let tStr = input()
  if tStr == "" { return }
  let t = parseIntStr(tStr)
  var cs = 0
  while cs < t {
    let line = input()
    let p = split_ws(line)
    let n = parseIntStr(p[0])
    let m = parseIntStr(p[1])
    var edges: list<list<int>> = []
    var i = 0
    while i < m {
      let el = input()
      let ep = split_ws(el)
      var pair: list<int> = []
      pair = append(pair, parseIntStr(ep[0]))
      pair = append(pair, parseIntStr(ep[1]))
      edges = append(edges, pair)
      i = i + 1
    }
    let ans = solve(n, edges)
    print(ans)
    cs = cs + 1
  }
}

main()
