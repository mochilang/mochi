/*
SPOJ: ALIENS - Aliens
https://www.spoj.com/problems/ALIENS/
*/

type Point = { x: float, y: float }
type Circle = { x: float, y: float, r: float }

let EPS = 1e-9

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun split(s: string, sep: string): list<string> {
  var parts: list<string> = []
  var cur: string = ""
  var i: int = 0
  while i < len(s) {
    if len(sep) > 0 && i + len(sep) <= len(s) && substring(s, i, i + len(sep)) == sep {
      parts = append(parts, cur)
      cur = ""
      i = i + len(sep)
    } else {
      cur = cur + s[i:i+1]
      i = i + 1
    }
  }
  parts = append(parts, cur)
  return parts
}

fun parseFloat(str: string): float {
  var i = 0
  var neg = false
  if len(str) > 0 && str[0:1] == "-" {
    neg = true
    i = 1
  }
  var intPart = 0
  while i < len(str) && str[i:i+1] != "." {
    intPart = intPart * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  var frac = 0.0
  var scale = 0.1
  if i < len(str) && str[i:i+1] == "." {
    i = i + 1
    while i < len(str) {
      frac = frac + (digits[str[i:i+1]] as float) * scale
      scale = scale / 10.0
      i = i + 1
    }
  }
  var res = (intPart as float) + frac
  if neg { res = -res }
  return res
}

fun absf(x: float): float { if x < 0.0 { return -x } else { return x } }

fun sqrt(x: float): float {
  if x <= 0.0 { return 0.0 }
  var r = x
  var prev = 0.0
  while absf(r - prev) > 1e-12 {
    prev = r
    r = (r + x / r) / 2.0
  }
  return r
}

fun format2(x: float): string {
  var neg = false
  if x < 0.0 {
    neg = true
    x = -x
  }
  var scaled = x * 100.0 + 0.5
  var n = scaled as int
  var whole = n / 100
  var frac = n % 100
  var fracStr = str(frac)
  if len(fracStr) < 2 {
    fracStr = "0" + fracStr
  }
  var res = str(whole) + "." + fracStr
  if neg { res = "-" + res }
  return res
}

var randSeed = 123456789

fun rand(n: int): int {
  randSeed = (randSeed * 1103515245 + 12345) % 2147483647
  return randSeed % n
}

fun shuffle(arr: list<Point>): list<Point> {
  var i = len(arr) - 1
  while i > 0 {
    let j = rand(i + 1)
    let tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp
    i = i - 1
  }
  return arr
}

fun contains(c: Circle, p: Point): bool {
  let dx = c.x - p.x
  let dy = c.y - p.y
  return dx * dx + dy * dy <= c.r * c.r + EPS
}

fun circleFrom2(a: Point, b: Point): Circle {
  let cx = (a.x + b.x) / 2.0
  let cy = (a.y + b.y) / 2.0
  let dx = a.x - b.x
  let dy = a.y - b.y
  let r = sqrt(dx * dx + dy * dy) / 2.0
  return Circle{ x: cx, y: cy, r: r }
}

fun circleFrom3(a: Point, b: Point, c: Point): Circle {
  let A = b.x - a.x
  let B = b.y - a.y
  let C = c.x - a.x
  let D = c.y - a.y
  let E = A * (a.x + b.x) + B * (a.y + b.y)
  let F = C * (a.x + c.x) + D * (a.y + c.y)
  let G = 2.0 * (A * (c.y - b.y) - B * (c.x - b.x))
  if absf(G) < 1e-12 {
    var c1 = circleFrom2(a, b)
    var c2 = circleFrom2(a, c)
    var c3 = circleFrom2(b, c)
    var res = c1
    if c2.r > res.r { res = c2 }
    if c3.r > res.r { res = c3 }
    return res
  }
  let cx = (D * E - B * F) / G
  let cy = (A * F - C * E) / G
  let r = sqrt((cx - a.x) * (cx - a.x) + (cy - a.y) * (cy - a.y))
  return Circle{ x: cx, y: cy, r: r }
}

fun minimalCircle(points: list<Point>): Circle {
  shuffle(points)
  let p0 = points[0]
  var c = Circle{ x: p0.x, y: p0.y, r: 0.0 }
  var i = 1
  while i < len(points) {
    if contains(c, points[i]) {
      i = i + 1
    } else {
        let pi = points[i]
        c = Circle{ x: pi.x, y: pi.y, r: 0.0 }
      var j = 0
      while j < i {
        if contains(c, points[j]) {
          j = j + 1
        } else {
          c = circleFrom2(points[i], points[j])
          var k = 0
          while k < j {
            if contains(c, points[k]) {
              k = k + 1
            } else {
              c = circleFrom3(points[i], points[j], points[k])
            }
          }
          j = j + 1
        }
      }
      i = i + 1
    }
  }
  return c
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let t = int(tLine)
  var case = 0
  while case < t {
    let nLine = input()
    let n = int(nLine)
    var pts: list<Point> = []
    var i = 0
    while i < n {
      let line = input()
      let parts = split(line, " ")
      let x = parseFloat(parts[0])
      let y = parseFloat(parts[1])
      pts = append(pts, Point{ x: x, y: y })
      i = i + 1
    }
    let c = minimalCircle(pts)
    print(format2(c.r))
    print(format2(c.x) + " " + format2(c.y))
    case = case + 1
  }
}

main()
