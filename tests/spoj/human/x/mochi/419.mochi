// Solution for SPOJ TRANSP - Transposing is Fun
// https://www.spoj.com/problems/TRANSP/

let MOD = 1000003

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseInts(line: string): list<int> {
  var nums: list<int> = []
  var cur = 0
  var sign = 1
  var inNum = false
  var i = 0
  while i < len(line) {
    let ch = line[i:i+1]
    if ch >= "0" && ch <= "9" {
      cur = cur * 10 + (digits[ch] as int)
      inNum = true
    } else if ch == "-" {
      sign = -1
    } else {
      if inNum {
        nums = append(nums, cur * sign)
        cur = 0
        sign = 1
        inNum = false
      }
    }
    i = i + 1
  }
  if inNum {
    nums = append(nums, cur * sign)
  }
  return nums
}

fun gcd(a: int, b: int): int {
  var x = a
  var y = b
  while y != 0 {
    let t = x % y
    x = y
    y = t
  }
  if x < 0 { x = -x }
  return x
}

fun powMod(base: int, exp: int, mod: int): int {
  var res = 1
  var b = base % mod
  var e = exp
  while e > 0 {
    if e % 2 == 1 {
      res = (res * b) % mod
    }
    b = (b * b) % mod
    e = e / 2
  }
  return res
}

fun modInv(a: int, mod: int): int {
  return powMod(a, mod - 2, mod)
}

fun factor(n: int): list<list<int>> {
  var x = n
  var res: list<list<int>> = []
  var p = 2
  while p * p <= x {
    if x % p == 0 {
      var cnt = 0
      while x % p == 0 {
        x = x / p
        cnt = cnt + 1
      }
      res = append(res, [p, cnt])
    }
    p = p + 1
  }
  if x > 1 {
    res = append(res, [x, 1])
  }
  return res
}

fun phiFromFactors(n: int, factors: list<list<int>>): int {
  var result = n
  var m = n
  var i = 0
  while i < len(factors) {
    let p = factors[i][0]
    if m % p == 0 {
      result = result / p * (p - 1)
      while m % p == 0 { m = m / p }
    }
    i = i + 1
  }
  return result
}

fun getDivisors(factors: list<list<int>>): list<int> {
  var divs: list<int> = [1]
  var i = 0
  while i < len(factors) {
    let p = factors[i][0]
    let e = factors[i][1]
    var newDivs: list<int> = []
    var j = 0
    while j < len(divs) {
      var d = divs[j]
      var k = 0
      var mult = 1
      while k <= e {
        newDivs = append(newDivs, d * mult)
        mult = mult * p
        k = k + 1
      }
      j = j + 1
    }
    divs = newDivs
    i = i + 1
  }
  return divs
}

fun solve(a: int, b: int): int {
  let n = a + b
  if n == 0 { return 0 }
  let g = gcd(a, b)
  let m = n / g
  let factors = factor(m)
  let divs = getDivisors(factors)
  var sum = 0
  var i = 0
  while i < len(divs) {
    let t = divs[i]
    let phi_t = phiFromFactors(t, factors)
    let exp = g * (m / t)
    let term = (phi_t % MOD) * powMod(2, exp, MOD) % MOD
    sum = (sum + term) % MOD
    i = i + 1
  }
  let cycles = (sum * modInv(m % MOD, MOD)) % MOD
  let total = powMod(2, n, MOD)
  var ans = (total - cycles) % MOD
  if ans < 0 { ans = ans + MOD }
  return ans
}

fun main() {
  let first = input()
  if first == "" { return }
  let t = parseInts(first)[0]
  var case = 0
  while case < t {
    var line = input()
    while line == "" { line = input() }
    let nums = parseInts(line)
    let a = nums[0]
    let b = nums[1]
    let res = solve(a, b)
    print(str(res))
    case = case + 1
  }
}

main()
