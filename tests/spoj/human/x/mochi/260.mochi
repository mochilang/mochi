// Solution for SPOJ CTAIN - Containers
// https://www.spoj.com/problems/CTAIN/

fun split(s: string): list<string> {
  var res: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " {
      if len(cur) > 0 {
        res = append(res, cur)
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 {
    res = append(res, cur)
  }
  return res
}

fun parseInts(line: string): list<int> {
  let parts = split(line)
  var res: list<int> = []
  var i = 0
  while i < len(parts) {
    res = append(res, int(parts[i]))
    i = i + 1
  }
  return res
}

fun encode(vols: list<int>, caps: list<int>, n: int): int {
  var idx = 0
  var i = 0
  while i < n {
    idx = idx * (caps[i] + 1) + vols[i]
    i = i + 1
  }
  return idx
}

fun decode(idx: int, caps: list<int>, n: int): list<int> {
  var rev: list<int> = []
  var rem = idx
  var i = n - 1
  while i >= 0 {
    let base = caps[i] + 1
    let v = rem % base
    rev = append(rev, v)
    rem = rem / base
    i = i - 1
  }
  var res: list<int> = []
  var j = len(rev) - 1
  while j >= 0 {
    res = append(res, rev[j])
    j = j - 1
  }
  return res
}

fun copyList(a: list<int>, n: int): list<int> {
  var res: list<int> = []
  var i = 0
  while i < n {
    res = append(res, a[i])
    i = i + 1
  }
  return res
}

fun bfs(n: int, caps: list<int>, target: list<int>): int {
  var start: list<int> = []
  var i = 0
  while i < n {
    start = append(start, caps[i])
    i = i + 1
  }
  let targetIdx = encode(target, caps, n)
  let startIdx = encode(start, caps, n)
  if startIdx == targetIdx { return 0 }
  var q: list<int> = []
  q = append(q, startIdx)
  var dist: map<int,int> = {}
  dist[startIdx] = 0
  var head = 0
  while head < len(q) {
    let cur = q[head]
    head = head + 1
    let curDist = dist[cur]
    let vols = decode(cur, caps, n)
    var i = 0
    while i < n {
      if vols[i] > 0 {
        // pour away
        var next0 = copyList(vols, n)
        next0[i] = 0
        let idx0 = encode(next0, caps, n)
        if !(idx0 in dist) {
          dist[idx0] = curDist + 1
          if idx0 == targetIdx { return curDist + 1 }
          q = append(q, idx0)
        }
        var j = 0
        while j < n {
          if i != j {
            // pour all from i to j
            if vols[i] + vols[j] <= caps[j] {
              var next1 = copyList(vols, n)
              next1[j] = vols[i] + vols[j]
              next1[i] = 0
              let idx1 = encode(next1, caps, n)
              if !(idx1 in dist) {
                dist[idx1] = curDist + 1
                if idx1 == targetIdx { return curDist + 1 }
                q = append(q, idx1)
              }
            }
            // fill j from i
            let need = caps[j] - vols[j]
            if need > 0 && vols[i] >= need {
              var next2 = copyList(vols, n)
              next2[j] = caps[j]
              next2[i] = vols[i] - need
              let idx2 = encode(next2, caps, n)
              if !(idx2 in dist) {
                dist[idx2] = curDist + 1
                if idx2 == targetIdx { return curDist + 1 }
                q = append(q, idx2)
              }
            }
          }
          j = j + 1
        }
      }
      i = i + 1
    }
  }
  return -1
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let t = int(tLine)
  var case = 0
  while case < t {
    var line = input()
    while line == "" { line = input() }
    let n = int(line)
    line = input()
    while line == "" { line = input() }
    let caps = parseInts(line)
    line = input()
    while line == "" { line = input() }
    let target = parseInts(line)
    let ans = bfs(n, caps, target)
    if ans < 0 {
      print("NO")
    } else {
      print(str(ans))
    }
    case = case + 1
  }
}

main()
