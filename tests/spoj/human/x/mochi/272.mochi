// Solution for SPOJ CAVE - Cave Exploration
// https://www.spoj.com/problems/CAVE/

fun split(s: string): list<string> {
  var res: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = substring(s, i, i+1)
    if ch == " " || ch == "\t" || ch == "\r" { 
      if cur != "" { res = append(res, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if cur != "" { res = append(res, cur) }
  return res
}

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var neg = false
  if len(str) > 0 && str[0:1] == "-" {
    neg = true
    i = 1
  }
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  if neg { n = -n }
  return n
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let T = parseIntStr(tLine)
  var tc = 0
  while tc < T {
    let nLine = input()
    let N = parseIntStr(nLine)
    var hx1: list<int> = []
    var hx2: list<int> = []
    var hy: list<int> = []
    var vx: list<int> = []
    var vy1: list<int> = []
    var vy2: list<int> = []
    var i = 0
    while i < N {
      let line = input()
      if line == "" { continue }
      let p = split(line)
      if p[0] == "H" {
        let y = parseIntStr(p[1])
        var a = parseIntStr(p[2])
        var b = parseIntStr(p[3])
        if a > b { let t = a; a = b; b = t }
        hy = append(hy, y)
        hx1 = append(hx1, a)
        hx2 = append(hx2, b)
      } else {
        let x = parseIntStr(p[1])
        var a = parseIntStr(p[2])
        var b = parseIntStr(p[3])
        if a > b { let t = a; a = b; b = t }
        vx = append(vx, x)
        vy1 = append(vy1, a)
        vy2 = append(vy2, b)
      }
      i = i + 1
    }
    let last = input()
    let pp = split(last)
    let sx = parseIntStr(pp[0])
    let sy = parseIntStr(pp[1])
    let dirChar = pp[2]
    var dir = 0
    if dirChar == "N" { dir = 0 } else if dirChar == "E" { dir = 1 } else if dirChar == "S" { dir = 2 } else { dir = 3 }
    var currType = 0
    var currIdx = 0
    if dir == 1 || dir == 3 {
      currType = 0
      currIdx = 0
      while currIdx < len(hx1) {
        if hy[currIdx] == sy && hx1[currIdx] <= sx && sx <= hx2[currIdx] {
          break
        }
        currIdx = currIdx + 1
      }
    } else {
      currType = 1
      currIdx = 0
      while currIdx < len(vx) {
        if vx[currIdx] == sx && vy1[currIdx] <= sy && sy <= vy2[currIdx] {
          break
        }
        currIdx = currIdx + 1
      }
    }
    var visitedH: list<int> = []
    i = 0
    while i < len(hx1) { visitedH = append(visitedH, 0); i = i + 1 }
    var visitedV: list<int> = []
    i = 0
    while i < len(vx) { visitedV = append(visitedV, 0); i = i + 1 }
    var x = sx
    var y = sy
    var first = true
    while true {
      if !first && x == sx && y == sy { break }
      first = false
      if currType == 0 { visitedH[currIdx] = 1 } else { visitedV[currIdx] = 1 }
      var hAt = -1
      var vAt = -1
      if currType == 0 {
        hAt = currIdx
        if dir == 1 {
          var nx = hx2[currIdx]
          var cross = -1
          i = 0
          while i < len(vx) {
            let vx0 = vx[i]
            if vy1[i] <= y && y <= vy2[i] && x < vx0 && vx0 <= nx {
              if vx0 < nx { nx = vx0; cross = i }
            }
            i = i + 1
          }
          x = nx
          vAt = cross
        } else {
          var nx = hx1[currIdx]
          var cross = -1
          i = 0
          while i < len(vx) {
            let vx0 = vx[i]
            if vy1[i] <= y && y <= vy2[i] && x > vx0 && vx0 >= nx {
              if vx0 > nx { nx = vx0; cross = i }
            }
            i = i + 1
          }
          x = nx
          vAt = cross
        }
      } else {
        vAt = currIdx
        if dir == 0 {
          var ny = vy2[currIdx]
          var cross = -1
          i = 0
          while i < len(hy) {
            let hy0 = hy[i]
            if hx1[i] <= x && x <= hx2[i] && y < hy0 && hy0 <= ny {
              if hy0 < ny { ny = hy0; cross = i }
            }
            i = i + 1
          }
          y = ny
          hAt = cross
        } else {
          var ny = vy1[currIdx]
          var cross = -1
          i = 0
          while i < len(hy) {
            let hy0 = hy[i]
            if hx1[i] <= x && x <= hx2[i] && y > hy0 && hy0 >= ny {
              if hy0 > ny { ny = hy0; cross = i }
            }
            i = i + 1
          }
          y = ny
          hAt = cross
        }
      }
      var dirs: list<int> = []
      dirs = append(dirs, (dir + 3) % 4)
      dirs = append(dirs, dir)
      dirs = append(dirs, (dir + 1) % 4)
      dirs = append(dirs, (dir + 2) % 4)
      var j = 0
      while j < 4 {
        let c = dirs[j]
        if c == 0 {
          if vAt != -1 && y < vy2[vAt] { dir = c; currIdx = vAt; currType = 1; break }
        } else if c == 1 {
          if hAt != -1 && x < hx2[hAt] { dir = c; currIdx = hAt; currType = 0; break }
        } else if c == 2 {
          if vAt != -1 && y > vy1[vAt] { dir = c; currIdx = vAt; currType = 1; break }
        } else {
          if hAt != -1 && x > hx1[hAt] { dir = c; currIdx = hAt; currType = 0; break }
        }
        j = j + 1
      }
    }
    var visited = 0
    i = 0
    while i < len(visitedH) { if visitedH[i] == 1 { visited = visited + 1 }; i = i + 1 }
    i = 0
    while i < len(visitedV) { if visitedV[i] == 1 { visited = visited + 1 }; i = i + 1 }
    let total = len(hx1) + len(vx)
    let unvisited = total - visited
    print(unvisited)
    tc = tc + 1
  }
}

main()
