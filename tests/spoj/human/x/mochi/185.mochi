// Solution for SPOJ CHASE1 - Chase
// https://www.spoj.com/problems/CHASE1/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseInts(line: string): list<int> {
  var nums: list<int> = []
  var i = 0
  var cur = 0
  var sign = 1
  var inNum = false
  while i < len(line) {
    let ch = line[i:i+1]
    if ch == "-" {
      sign = -1
      i = i + 1
    } else if ch >= "0" && ch <= "9" {
      cur = cur * 10 + (digits[ch] as int)
      inNum = true
      i = i + 1
    } else {
      if inNum {
        nums = append(nums, sign * cur)
        cur = 0
        sign = 1
        inNum = false
      }
      i = i + 1
    }
  }
  if inNum {
    nums = append(nums, sign * cur)
  }
  return nums
}

fun bfs(start: int, n: int, adj: list<list<int>>): list<int> {
  var dist: list<int> = []
  for i in 0..(n + 1) {
    dist = append(dist, 0 - 1)
  }
  var q: list<int> = [start]
  dist[start] = 0
  var head = 0
  while head < len(q) {
    let u = q[head] as int
    head = head + 1
    let d = dist[u] as int
    var j = 0
    while j < len(adj[u]) {
      let v = adj[u][j] as int
      if dist[v] == 0 - 1 {
        dist[v] = d + 1
        q = append(q, v)
      }
      j = j + 1
    }
  }
  return dist
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let t = int(tLine)
  var case = 0
  while case < t {
    var line = input()
    while line == "" { line = input() }
    let first = parseInts(line)
    let n = first[0] as int
    let m = first[1] as int
    let a = first[2] as int
    let b = first[3] as int
    var adj: list<list<int>> = []
    for i in 0..(n + 1) {
      adj = append(adj, [])
    }
    var i = 0
    while i < m {
      let eLine = input()
      if eLine == "" { continue }
      let e = parseInts(eLine)
      let u = e[0] as int
      let v = e[1] as int
      adj[u] = append(adj[u], v)
      adj[v] = append(adj[v], u)
      i = i + 1
    }
    var deg: list<int> = []
    for i in 0..(n + 1) {
      deg = append(deg, len(adj[i]) as int)
    }
    var onCycle: list<bool> = []
    for i in 0..(n + 1) { onCycle = append(onCycle, true) }
    var q: list<int> = []
    var head = 0
    for i in 1..(n + 1) {
      if deg[i] <= 1 {
        q = append(q, i)
      }
    }
    while head < len(q) {
      let u = q[head] as int
      head = head + 1
      if !(onCycle[u]) { continue }
      onCycle[u] = false
      var j = 0
      while j < len(adj[u]) {
        let v = adj[u][j] as int
        if onCycle[v] {
          deg[v] = (deg[v] as int) - 1
          if deg[v] == 1 {
            q = append(q, v)
          }
        }
        j = j + 1
      }
    }
    let distA = bfs(a, n, adj)
    let distB = bfs(b, n, adj)
    var escape = false
    for i in 1..(n + 1) {
      if onCycle[i] && (distA[i] as int) < (distB[i] as int) {
        escape = true
      }
    }
    if escape {
      print("No")
    } else {
      var maxTime = distB[a] as int
      for i in 1..(n + 1) {
        let db = distB[i] as int
        let da = distA[i] as int
        if db <= da && db > maxTime {
          maxTime = db
        }
      }
      print(str(maxTime))
    }
    case = case + 1
  }
}

main()
