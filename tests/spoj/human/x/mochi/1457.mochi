// Solution for SPOJ BLUEEQ - Help Blue Mary Please! (Act I)
// https://www.spoj.com/problems/BLUEEQ/

let lettersStr = "abcdefghijklm"
let digitMap = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun idxChar(ch: string): int {
  var i = 0
  while i < 13 {
    if lettersStr[i:i+1] == ch { return i }
    i = i + 1
  }
  return 0
}

fun parseIntStr(str: string): int {
  var i = 0
  var n = 0
  while i < len(str) {
    n = n * 10 + (digitMap[str[i:i+1]] as int)
    i = i + 1
  }
  return n
}

fun evalExpr(s: string): any {
  var sum = 0
  var prod = 1
  var num = 0
  var digits = 0
  var i = 0
  while i <= len(s) {
    let ch = if i < len(s) { s[i:i+1] } else { "+" }
    if ch >= "0" && ch <= "9" {
      let d = digitMap[ch] as int
      if digits == 0 {
        num = d
        digits = 1
      } else {
        if num == 0 { return nil }
        num = num * 10 + d
        digits = digits + 1
      }
    } else if ch == "*" || ch == "+" {
      if digits == 0 { return nil }
      prod = prod * num
      if ch == "+" {
        sum = sum + prod
        prod = 1
      }
      num = 0
      digits = 0
    } else {
      return nil
    }
    i = i + 1
  }
  return sum
}

fun checkEq(mapping: list<string>, eqs: list<string>): bool {
  var idxEq = 0
  while idxEq < len(eqs) {
    let s = eqs[idxEq]
    var mapped = ""
    var j = 0
    while j < len(s) {
      let c = s[j:j+1]
      let mi = idxChar(c)
      let sym = mapping[mi]
      if sym == " " { return false }
      mapped = mapped + sym
      j = j + 1
    }
    var countEq = 0
    var k = 0
    while k < len(mapped) {
      if mapped[k:k+1] == "=" { countEq = countEq + 1 }
      k = k + 1
    }
    if countEq != 1 { return false }
    var parts: list<string> = []
    var cur = ""
    k = 0
    while k < len(mapped) {
      let ch = mapped[k:k+1]
      if ch == "=" {
        parts = append(parts, cur)
        cur = ""
      } else {
        cur = cur + ch
      }
      k = k + 1
    }
    parts = append(parts, cur)
    if len(parts) != 2 { return false }
    let lAny = evalExpr(parts[0])
    let rAny = evalExpr(parts[1])
    if lAny == nil || rAny == nil { return false }
    if (lAny as int) != (rAny as int) { return false }
    idxEq = idxEq + 1
  }
  return true
}

fun dfs(pos: int, letters: list<int>, mapping: list<string>, used: list<int>, eqs: list<string>, symbols: list<string>, poss: list<map<string,int>>, present: list<int>): int {
  if pos == len(letters) {
    if checkEq(mapping, eqs) {
      var i = 0
      while i < 13 {
        if present[i] == 1 {
          let sym = mapping[i]
          if sym != " " {
            var m = poss[i] as map<string,int>
            m[sym] = 1
            poss[i] = m
          }
        }
        i = i + 1
      }
      return 1
    }
    return 0
  }
  let idxL = letters[pos]
  var total = 0
  var sIdx = 0
  while sIdx < len(symbols) {
    if used[sIdx] == 0 {
      mapping[idxL] = symbols[sIdx]
      used[sIdx] = 1
      total = total + dfs(pos + 1, letters, mapping, used, eqs, symbols, poss, present)
      used[sIdx] = 0
      mapping[idxL] = " "
    }
    sIdx = sIdx + 1
  }
  return total
}

fun solveCase(eqs: list<string>): list<string> {
  var present: list<int> = []
  var i = 0
  while i < 13 { present = append(present, 0); i = i + 1 }
  var eqIdx = 0
  while eqIdx < len(eqs) {
    let s = eqs[eqIdx]
    var j = 0
    while j < len(s) {
      let c = s[j:j+1]
      present[idxChar(c)] = 1
      j = j + 1
    }
    eqIdx = eqIdx + 1
  }
  var cand: list<int> = []
  i = 0
  while i < 13 { cand = append(cand, i); i = i + 1 }
  eqIdx = 0
  while eqIdx < len(eqs) {
    let s = eqs[eqIdx]
    var counts: list<int> = []
    i = 0
    while i < 13 { counts = append(counts, 0); i = i + 1 }
    var j = 0
    while j < len(s) {
      let c = s[j:j+1]
      let id = idxChar(c)
      counts[id] = counts[id] + 1
      j = j + 1
    }
    var newCand: list<int> = []
    i = 0
    while i < len(cand) {
      let idc = cand[i]
      if counts[idc] == 1 { newCand = append(newCand, idc) }
      i = i + 1
    }
    cand = newCand
    eqIdx = eqIdx + 1
  }
  var poss: list<map<string,int>> = []
  i = 0
  while i < 13 { poss = append(poss, {}); i = i + 1 }
  let symbolsStr = "0123456789+*"
  var symbols: list<string> = []
  i = 0
  while i < len(symbolsStr) {
    symbols = append(symbols, symbolsStr[i:i+1])
    i = i + 1
  }
  var total = 0
  var cIdx = 0
  while cIdx < len(cand) {
    let e = cand[cIdx]
    var mapping: list<string> = []
    i = 0
    while i < 13 { mapping = append(mapping, " "); i = i + 1 }
    mapping[e] = "="
    var used: list<int> = []
    i = 0
    while i < 12 { used = append(used, 0); i = i + 1 }
    var letters: list<int> = []
    i = 0
    while i < 13 {
      if present[i] == 1 && i != e { letters = append(letters, i) }
      i = i + 1
    }
    total = total + dfs(0, letters, mapping, used, eqs, symbols, poss, present)
    cIdx = cIdx + 1
  }
  if total == 0 { return ["noway"] }
  var result: list<string> = []
  i = 0
  while i < 13 {
    if present[i] == 1 {
      var m = poss[i] as map<string,int>
      var count = 0
      var sym = ""
      for s in m {
        count = count + 1
        sym = s as string
      }
      if count == 1 {
        let letter = lettersStr[i:i+1]
        result = append(result, letter + sym)
      }
    }
    i = i + 1
  }
  return result
}

fun join(parts: list<string>, sep: string): string {
  if len(parts) == 0 { return "" }
  var res = parts[0]
  var i = 1
  while i < len(parts) {
    res = res + sep + parts[i]
    i = i + 1
  }
  return res
}

fun main() {
  let tStr = input()
  if tStr == nil || tStr == "" { return }
  let t = parseIntStr(tStr)
  var outputs: list<string> = []
  var cs = 0
  while cs < t {
    let nStr = input()
    let n = parseIntStr(nStr)
    var eqs: list<string> = []
    var i = 0
    while i < n {
      eqs = append(eqs, input())
      i = i + 1
    }
    let res = solveCase(eqs)
    outputs = append(outputs, join(res, "\n"))
    cs = cs + 1
  }
  print(join(outputs, "\n"))
}

main()
