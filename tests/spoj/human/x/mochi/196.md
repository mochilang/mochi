# [Musketeers](https://www.spoj.com/problems/MUSKET/)

## Problem Summary
Given \(n\) musketeers arranged in a circle and a matrix \(A\) describing pairwise duel outcomes
(\(A_{i,j}=1\) if player \(i\) always beats player \(j\)), determine which musketeers can
become the final survivor. In each step a chosen musketeer fights his neighbour to the right,
the loser is removed, and the circle closes. We seek all players who can win for some
sequence of duels.

## Algorithm
1. Duplicate the list of players so we can treat the circle as a line and consider any
   starting position.
2. Use dynamic programming over intervals.  `dp[l][r]` stores all players that can win
   when only the players in positions `l..r` remain and fights happen inside this
   interval.
3. Base case: `dp[i][i]` contains the single player at position `i`.
4. For longer intervals, try every split `m` and combine winners from the left and right
   subintervals.  For every pair of winners `a` from the left and `b` from the right:
   - if `A[a][b] = 1`, then `a` can win the merged interval,
   - if `A[b][a] = 1`, then `b` can win the merged interval.
   Duplicates are ignored with a boolean array.
5. The possible champions for the whole circle are the union of `dp[s][s+n-1]`
   for all starting positions `s`.
6. Output the number of such players and their indices in ascending order.

The dynamic programming examines \(O(n^3)\) interval combinations and each combination
considers only winners from subintervals, keeping the algorithm within the limits for
\(n \le 100\).
