// Solution for SPOJ RECTNG1 - Rectangles
// https://www.spoj.com/problems/RECTNG1/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  return n
}

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 { parts = append(parts, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun parseInts(line: string): list<int> {
  let parts = splitSpaces(line)
  var nums: list<int> = []
  var i = 0
  while i < len(parts) {
    nums = append(nums, parseIntStr(parts[i]))
    i = i + 1
  }
  return nums
}

type Rect {
  x1: int,
  y1: int,
  x2: int,
  y2: int,
}

fun overlap(a1: int, a2: int, b1: int, b2: int): bool {
  let l = if a1 > b1 { a1 } else { b1 }
  let r = if a2 < b2 { a2 } else { b2 }
  return l < r
}

fun connected(r1: Rect, r2: Rect): bool {
  if overlap(r1.x1, r1.x2, r2.x1, r2.x2) && overlap(r1.y1, r1.y2, r2.y1, r2.y2) {
    return true
  }
  if (r1.x2 == r2.x1 || r2.x2 == r1.x1) && overlap(r1.y1, r1.y2, r2.y1, r2.y2) {
    return true
  }
  if (r1.y2 == r2.y1 || r2.y2 == r1.y1) && overlap(r1.x1, r1.x2, r2.x1, r2.x2) {
    return true
  }
  return false
}

fun find(parent: list<int>, x: int): int {
  var r = x
  while parent[r] != r {
    r = parent[r]
  }
  var i = x
  while parent[i] != r {
    let next = parent[i]
    parent[i] = r
    i = next
  }
  return r
}

fun union(parent: list<int>, rank: list<int>, a: int, b: int) {
  let ra = find(parent, a)
  let rb = find(parent, b)
  if ra == rb { return }
  if rank[ra] < rank[rb] {
    parent[ra] = rb
  } else if rank[ra] > rank[rb] {
    parent[rb] = ra
  } else {
    parent[rb] = ra
    rank[ra] = rank[ra] + 1
  }
}

fun main() {
  let tLine = input()
  if tLine == nil || tLine == "" { return }
  let t = parseIntStr(tLine)
  var case = 0
  while case < t {
    var line = input()
    while line == "" { line = input() }
    let n = parseIntStr(line)
    var rects: list<Rect> = []
    var i = 0
    while i < n {
      let nums = parseInts(input())
      rects = append(rects, Rect{x1:nums[0], y1:nums[1], x2:nums[2], y2:nums[3]})
      i = i + 1
    }
    var parent: list<int> = []
    var rank: list<int> = []
    i = 0
    while i < n {
      parent = append(parent, i)
      rank = append(rank, 0)
      i = i + 1
    }
    i = 0
    while i < n {
      var j = i + 1
      while j < n {
        if connected(rects[i], rects[j]) {
          union(parent, rank, i, j)
        }
        j = j + 1
      }
      i = i + 1
    }
    var roots: map<int, int> = {}
    i = 0
    while i < n {
      let r = find(parent, i)
      roots[r] = 1
      i = i + 1
    }
    var cnt = 0
    for key in roots { cnt = cnt + 1 }
    print(str(cnt))
    case = case + 1
  }
}

main()
