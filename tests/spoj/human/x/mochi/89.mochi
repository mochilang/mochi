// Solution for SPOJ HANGLET - Hang or not to hang
// https://www.spoj.com/problems/HANGLET/

fun split(s: string): list<string> {
  var parts: list<string> = []
  var cur: string = ""
  var i: int = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " {
      if len(cur) > 0 {
        parts = append(parts, cur)
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 {
    parts = append(parts, cur)
  }
  return parts
}

fun copyRegs(regs: list<int>): list<int> {
  var r: list<int> = []
  var i = 0
  while i < 32 {
    r = append(r, regs[i])
    i = i + 1
  }
  return r
}

fun keyState(pc: int, regs: list<int>): string {
  var s = str(pc) + ":"
  var i = 0
  while i < 32 {
    let v = regs[i]
    if v == 2 {
      s = s + "2"
    } else {
      s = s + str(v)
    }
    s = s + ","
    i = i + 1
  }
  return s
}

fun possible(v: int): list<int> {
  if v == 2 { return [0,1] }
  return [v]
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let T = int(tLine)
  var case = 0
  while case < T {
    let nLine = input()
    if nLine == "" { break }
    let n = int(nLine)
    var ops: list<string> = []
    var a1: list<int> = []
    var a2: list<int> = []
    var i = 0
    while i < n {
      let line = input()
      let p = split(line)
      let op = p[0]
      ops = append(ops, op)
      if op == "AND" || op == "OR" || op == "XOR" || op == "MOV" {
        a1 = append(a1, int(p[1]))
        a2 = append(a2, int(p[2]))
      } else if op == "NOT" || op == "RANDOM" {
        a1 = append(a1, int(p[1]))
        a2 = append(a2, 0)
      } else if op == "SET" {
        a1 = append(a1, int(p[1]))
        a2 = append(a2, int(p[2]))
      } else if op == "JMP" {
        a1 = append(a1, int(p[1]))
        a2 = append(a2, 0)
      } else if op == "JZ" {
        a1 = append(a1, int(p[1]))
        a2 = append(a2, int(p[2]))
      } else { // STOP
        a1 = append(a1, 0)
        a2 = append(a2, 0)
      }
      i = i + 1
    }
    var queue: list<map<string, any>> = []
    var startRegs: list<int> = []
    i = 0
    while i < 32 {
      startRegs = append(startRegs, 2)
      i = i + 1
    }
    queue = append(queue, { pc: 0, regs: startRegs, time: 0 })
    var qi = 0
    var visited: map<string,bool> = {}
    var ans = -1
    while qi < len(queue) {
      let st = queue[qi]
      qi = qi + 1
      let pc = st["pc"] as int
      let regs = st["regs"] as list<int>
      let time = st["time"] as int
      if pc < 0 || pc >= n { continue }
      let key = keyState(pc, regs)
      if visited[key] == true { continue }
      visited[key] = true
      let op = ops[pc]
      if op == "STOP" {
        ans = time + 1
        break
      } else if op == "AND" {
        let a = a1[pc]
        let b = a2[pc]
        for va in possible(regs[a]) {
          for vb in possible(regs[b]) {
            var nr = copyRegs(regs)
            nr[a] = if va == 1 && vb == 1 { 1 } else { 0 }
            nr[b] = vb
            queue = append(queue, { pc: pc + 1, regs: nr, time: time + 1 })
          }
        }
      } else if op == "OR" {
        let a = a1[pc]
        let b = a2[pc]
        for va in possible(regs[a]) {
          for vb in possible(regs[b]) {
            var nr = copyRegs(regs)
            nr[a] = if va == 1 || vb == 1 { 1 } else { 0 }
            nr[b] = vb
            queue = append(queue, { pc: pc + 1, regs: nr, time: time + 1 })
          }
        }
      } else if op == "XOR" {
        let a = a1[pc]
        let b = a2[pc]
        for va in possible(regs[a]) {
          for vb in possible(regs[b]) {
            var nr = copyRegs(regs)
            nr[a] = if va != vb { 1 } else { 0 }
            nr[b] = vb
            queue = append(queue, { pc: pc + 1, regs: nr, time: time + 1 })
          }
        }
      } else if op == "NOT" {
        let a = a1[pc]
        for va in possible(regs[a]) {
          var nr = copyRegs(regs)
          nr[a] = if va == 0 { 1 } else { 0 }
          queue = append(queue, { pc: pc + 1, regs: nr, time: time + 1 })
        }
      } else if op == "MOV" {
        let a = a1[pc]
        let b = a2[pc]
        for vb in possible(regs[b]) {
          var nr = copyRegs(regs)
          nr[b] = vb
          nr[a] = vb
          queue = append(queue, { pc: pc + 1, regs: nr, time: time + 1 })
        }
      } else if op == "SET" {
        let a = a1[pc]
        let c = a2[pc]
        var nr = copyRegs(regs)
        nr[a] = c
        queue = append(queue, { pc: pc + 1, regs: nr, time: time + 1 })
      } else if op == "RANDOM" {
        let a = a1[pc]
        var nr0 = copyRegs(regs)
        nr0[a] = 0
        queue = append(queue, { pc: pc + 1, regs: nr0, time: time + 1 })
        var nr1 = copyRegs(regs)
        nr1[a] = 1
        queue = append(queue, { pc: pc + 1, regs: nr1, time: time + 1 })
      } else if op == "JMP" {
        let x = a1[pc]
        queue = append(queue, { pc: x, regs: copyRegs(regs), time: time + 1 })
      } else if op == "JZ" {
        let x = a1[pc]
        let a = a2[pc]
        for va in possible(regs[a]) {
          var nr = copyRegs(regs)
          nr[a] = va
          let npc = if va == 0 { x } else { pc + 1 }
          queue = append(queue, { pc: npc, regs: nr, time: time + 1 })
        }
      }
    }
    if ans < 0 {
      print("HANGS")
    } else {
      print(str(ans))
    }
    case = case + 1
  }
}

main()
