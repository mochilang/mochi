// Solution for SPOJ SWTHIN - Swamp Things
// https://www.spoj.com/problems/SWTHIN/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var neg = false
  if len(str) > 0 && str[0:1] == "-" {
    neg = true
    i = 1
  }
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  if neg { n = -n }
  return n
}

fun parseInts(line: string): list<int> {
  var res: list<int> = []
  var i = 0
  var num = 0
  var sign = 1
  var has = false
  while i < len(line) {
    let ch = line[i:i+1]
    if ch == " " {
      if has {
        res = append(res, num * sign)
        num = 0
        sign = 1
        has = false
      }
    } else if ch == "-" {
      sign = -1
    } else {
      num = num * 10 + (digits[ch] as int)
      has = true
    }
    i = i + 1
  }
  if has { res = append(res, num * sign) }
  return res
}

fun intToString(n: int): string {
  if n == 0 { return "0" }
  let digs = ["0","1","2","3","4","5","6","7","8","9"]
  var neg = false
  var m = n
  if m < 0 {
    neg = true
    m = -m
  }
  var s = ""
  while m > 0 {
    let d = m % 10
    s = digs[d] + s
    m = m / 10
  }
  if neg { return "-" + s }
  return s
}

fun abs(n: int): int { if n < 0 { return -n } return n }

fun gcd(a: int, b: int): int {
  var x = abs(a)
  var y = abs(b)
  while y != 0 {
    let t = x % y
    x = y
    y = t
  }
  return x
}

fun sortStrs(arr: list<string>): list<string> {
  var res: list<string> = []
  var tmp = arr
  while len(tmp) > 0 {
    var min = tmp[0]
    var idx = 0
    var i = 1
    while i < len(tmp) {
      if tmp[i] < min {
        min = tmp[i]
        idx = i
      }
      i = i + 1
    }
    res = append(res, min)
    var out: list<string> = []
    var j = 0
    while j < len(tmp) {
      if j != idx { out = append(out, tmp[j]) }
      j = j + 1
    }
    tmp = out
  }
  return res
}

fun maxCollinear(xs: list<int>, ys: list<int>, n: int): int {
  var best = 1
  var i = 0
  while i < n {
    var slopes: list<string> = []
    var j = i + 1
    while j < n {
      var dx = xs[j] - xs[i]
      var dy = ys[j] - ys[i]
      var g = gcd(dx, dy)
      if g != 0 {
        dx = dx / g
        dy = dy / g
      }
      if dx < 0 {
        dx = -dx
        dy = -dy
      }
      if dx == 0 { dy = 1 }
      if dy == 0 { dx = 1 }
      let key = intToString(dy) + "/" + intToString(dx)
      slopes = append(slopes, key)
      j = j + 1
    }
    slopes = sortStrs(slopes)
    var k = 1
    var count = 1
    while k < len(slopes) {
      if slopes[k] == slopes[k-1] {
        count = count + 1
      } else {
        if count + 1 > best { best = count + 1 }
        count = 1
      }
      k = k + 1
    }
    if count + 1 > best { best = count + 1 }
    i = i + 1
  }
  return best
}

fun main() {
  var photo = 1
  while true {
    let line = input()
    if line == nil { break }
    if line == "" { continue }
    let n = parseIntStr(line)
    if n == 0 { break }
    var xs: list<int> = []
    var ys: list<int> = []
    var i = 0
    while i < n {
      let parts = parseInts(input())
      xs = append(xs, parts[0])
      ys = append(ys, parts[1])
      i = i + 1
    }
    let m = maxCollinear(xs, ys, n)
    var removed = 0
    if m >= 4 { removed = m }
    print("Photo " + intToString(photo) + ": " + intToString(removed) + " points eliminated")
    photo = photo + 1
  }
}

main()
