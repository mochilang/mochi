// Solution for SPOJ CONDUIT - I Conduit
// https://www.spoj.com/problems/CONDUIT/

type Interval { start: int, end: int }

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var neg = false
  if len(str) > 0 && str[0:1] == "-" {
    neg = true
    i = 1
  }
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  if neg { n = -n }
  return n
}

fun parseCoord(str: string): int {
  var i = 0
  var neg = false
  if len(str) > 0 && str[0:1] == "-" {
    neg = true
    i = 1
  }
  var intPart = 0
  while i < len(str) && str[i:i+1] != "." {
    intPart = intPart * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  var frac = 0
  var digitsCount = 0
  if i < len(str) && str[i:i+1] == "." {
    i = i + 1
    while i < len(str) && digitsCount < 2 {
      frac = frac * 10 + (digits[str[i:i+1]] as int)
      i = i + 1
      digitsCount = digitsCount + 1
    }
  }
  while digitsCount < 2 {
    frac = frac * 10
    digitsCount = digitsCount + 1
  }
  var res = intPart * 100 + frac
  if neg { res = -res }
  return res
}

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " || ch == "\t" || ch == "\r" || ch == "\n" {
      if len(cur) > 0 {
        parts = append(parts, cur)
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if len(cur) > 0 { parts = append(parts, cur) }
  return parts
}

fun absInt(x: int): int { if x < 0 { return -x } else { return x } }

fun gcd(a: int, b: int): int {
  var x = absInt(a)
  var y = absInt(b)
  while y != 0 {
    let t = x % y
    x = y
    y = t
  }
  return x
}

fun mergeIntervals(left: list<Interval>, right: list<Interval>): list<Interval> {
  var res: list<Interval> = []
  var i = 0
  var j = 0
  while i < len(left) && j < len(right) {
    let L = left[i]
    let R = right[j]
    if L.start < R.start {
      res = append(res, L)
      i = i + 1
    } else {
      res = append(res, R)
      j = j + 1
    }
  }
  while i < len(left) { res = append(res, left[i]); i = i + 1 }
  while j < len(right) { res = append(res, right[j]); j = j + 1 }
  return res
}

fun sortIntervals(arr: list<Interval>): list<Interval> {
  if len(arr) <= 1 { return arr }
  let mid = len(arr) / 2
  let left = sortIntervals(arr[0:mid])
  let right = sortIntervals(arr[mid:len(arr)])
  return mergeIntervals(left, right)
}

fun countSegments(intervals: list<Interval>): int {
  if len(intervals) == 0 { return 0 }
  var cnt = 0
  var curStart = intervals[0].start
  var curEnd = intervals[0].end
  var i = 1
  while i < len(intervals) {
    let seg = intervals[i]
    if seg.start <= curEnd {
      if seg.end > curEnd { curEnd = seg.end }
    } else {
      cnt = cnt + 1
      curStart = seg.start
      curEnd = seg.end
    }
    i = i + 1
  }
  cnt = cnt + 1
  return cnt
}

fun readNonEmpty(): string {
  var line = input()
  while line != nil && line == "" {
    line = input()
  }
  return line
}

fun main() {
  while true {
    var line = readNonEmpty()
    if line == nil { break }
    let n = parseIntStr(line)
    if n == 0 { break }
    var keys: list<string> = []
    var segs: list<list<Interval>> = []
    var i = 0
    while i < n {
      var l = readNonEmpty()
      let parts = splitSpaces(l)
      var x1 = parseCoord(parts[0])
      var y1 = parseCoord(parts[1])
      var x2 = parseCoord(parts[2])
      var y2 = parseCoord(parts[3])
      var dx = x2 - x1
      var dy = y2 - y1
      if dx < 0 || (dx == 0 && dy < 0) {
        dx = -dx
        dy = -dy
        let tx = x1; let ty = y1
        x1 = x2; y1 = y2
        x2 = tx; y2 = ty
      }
      let g = gcd(dx, dy)
      dx = dx / g
      dy = dy / g
      let c = x1 * dy - y1 * dx
      let key = str(dx) + "," + str(dy) + "," + str(c)
      let t1 = x1 * dx + y1 * dy
      let t2 = x2 * dx + y2 * dy
      var s = t1
      var e = t2
      if s > e { let tmp = s; s = e; e = tmp }
      var idx = 0
      var found = -1
      while idx < len(keys) {
        if keys[idx] == key { found = idx; break }
        idx = idx + 1
      }
      if found < 0 {
        keys = append(keys, key)
        segs = append(segs, [])
        found = len(segs) - 1
      }
      segs[found] = append(segs[found], Interval { start: s, end: e })
      i = i + 1
    }
    var total = 0
    var j = 0
    while j < len(segs) {
      var arr = segs[j]
      arr = sortIntervals(arr)
      total = total + countSegments(arr)
      j = j + 1
    }
    print(str(total))
  }
}

main()
