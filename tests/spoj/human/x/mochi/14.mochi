/*
SPOJ: I-Keyboard
https://www.spoj.com/problems/IKEYB
*/

fun split(s: string, sep: string): list<string> {
  var parts: list<string> = []
  var cur: string = ""
  var i: int = 0
  while i < len(s) {
    if len(sep) > 0 && i + len(sep) <= len(s) && substring(s, i, i + len(sep)) == sep {
      parts = append(parts, cur)
      cur = ""
      i = i + len(sep)
    } else {
      cur = cur + s[i:i+1]
      i = i + 1
    }
  }
  parts = append(parts, cur)
  return parts
}

fun better(a: list<int>, b: list<int>, k: int): bool {
  var i: int = k - 1
  while i >= 0 {
    let ai = a[i]
    let bi = b[i]
    if ai > bi {
      return true
    }
    if ai < bi {
      return false
    }
    i = i - 1
  }
  return false
}

fun main() {
  let t = input() as int
  var case_idx: int = 1
  while case_idx <= t {
    let parts = split(input(), " ")
    let k = parts[0] as int
    let l = parts[1] as int
    let keys = input()
    let letters = input()
    var freq: list<int> = []
    var i: int = 0
    while i < l {
      freq = append(freq, (input() as int))
      i = i + 1
    }
    var prefix: list<int> = [0]
    var prefixW: list<int> = [0]
    i = 0
    while i < l {
      let f = freq[i]
      prefix = append(prefix, prefix[i] + f)
      prefixW = append(prefixW, prefixW[i] + f * (i + 1))
      i = i + 1
    }
    var dp: list<list<int>> = []
    var cnt: list<list<list<int>>> = []
    var kk: int = 0
    while kk <= k {
      var row: list<int> = []
      var crow: list<list<int>> = []
      var ll: int = 0
      while ll <= l {
        row = append(row, 1000000000)
        crow = append(crow, [])
        ll = ll + 1
      }
      dp = append(dp, row)
      cnt = append(cnt, crow)
      kk = kk + 1
    }
    dp[0][0] = 0
    cnt[0][0] = []
    kk = 1
    while kk <= k {
      var ll: int = 1
      while ll <= l {
        var bestCost: int = 1000000000
        var bestCount: list<int> = []
        var j: int = kk - 1
        while j <= ll - 1 {
          if dp[kk - 1][j] < 1000000000 {
            let totalFreq = prefix[ll] - prefix[j]
            let weighted = prefixW[ll] - prefixW[j]
            let segCost = weighted - j * totalFreq
            let cost = dp[kk - 1][j] + segCost
            var candidate = cnt[kk - 1][j]
            candidate = append(candidate, ll - j)
            if bestCost == 1000000000 || cost < bestCost || (cost == bestCost && better(candidate, bestCount, kk)) {
              bestCost = cost
              bestCount = candidate
            }
          }
          j = j + 1
        }
        dp[kk][ll] = bestCost
        cnt[kk][ll] = bestCount
        ll = ll + 1
      }
      kk = kk + 1
    }
    print("Keypad #" + str(case_idx) + ":")
    var pos: int = 0
    var idx: int = 0
    var counts = cnt[k][l]
    while idx < k {
      let key = substring(keys, idx, idx + 1)
      let count = counts[idx]
      let segment = substring(letters, pos, pos + count)
      print(key + ": " + segment)
      pos = pos + count
      idx = idx + 1
    }
    print("")
    case_idx = case_idx + 1
  }
}

main()
