// Solution for SPOJ SERVERS - Servers
// https://www.spoj.com/problems/SERVERS/

type Edge { to: int, cost: int }

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  return n
}

fun split(s: string): list<string> {
  var res: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = substring(s, i, i+1)
    if ch == " " || ch == "\t" {
      if cur != "" { res = append(res, cur); cur = "" }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if cur != "" { res = append(res, cur) }
  return res
}

fun make_edge_list(n: int): list<list<Edge>> {
  var g: list<list<Edge>> = []
  var i = 0
  while i <= n {
    g = append(g, [])
    i = i + 1
  }
  return g
}

fun make_int_list(n: int, value: int): list<int> {
  var lst: list<int> = []
  var i = 0
  while i < n {
    lst = append(lst, value)
    i = i + 1
  }
  return lst
}

fun count_b(g: list<list<Edge>>, n: int, start: int, ranks: list<int>): int {
  let inf = 1000000000
  var dist = make_int_list(n+1, inf)
  var used = make_int_list(n+1, 0)
  dist[start] = 0
  var maxR = 0
  var cnt = 0
  var k = 0
  while k < n {
    var v = 0
    var best = inf + 1
    var i = 1
    while i <= n {
      if used[i] == 0 && dist[i] < best {
        best = dist[i]
        v = i
      }
      i = i + 1
    }
    if v == 0 { break }
    if dist[v] == inf { break }
    used[v] = 1
    let r = ranks[v]
    if r >= maxR {
      cnt = cnt + 1
      if r > maxR { maxR = r }
    }
    var j = 0
    while j < len(g[v]) {
      let e = g[v][j]
      let nd = dist[v] + e.cost
      if nd < dist[e.to] {
        dist[e.to] = nd
      }
      j = j + 1
    }
    k = k + 1
  }
  return cnt
}

fun main() {
  let zStr = input()
  if zStr == nil || zStr == "" { return }
  let z = parseIntStr(zStr)
  var caseIndex = 0
  while caseIndex < z {
    var line = input()
    while line == "" { line = input() }
    let parts = split(line)
    let n = parseIntStr(parts[0])
    let m = parseIntStr(parts[1])
    var ranks: list<int> = [0]
    var i = 0
    while i < n {
      let rStr = input()
      ranks = append(ranks, parseIntStr(rStr))
      i = i + 1
    }
    var g = make_edge_list(n)
    i = 0
    while i < m {
      let l = input()
      let ps = split(l)
      let a = parseIntStr(ps[0])
      let b = parseIntStr(ps[1])
      let t = parseIntStr(ps[2])
      g[a] = append(g[a], Edge{ to:b, cost:t })
      g[b] = append(g[b], Edge{ to:a, cost:t })
      i = i + 1
    }
    var total = 0
    i = 1
    while i <= n {
      total = total + count_b(g, n, i, ranks)
      i = i + 1
    }
    print(str(total))
    caseIndex = caseIndex + 1
  }
}

main()
