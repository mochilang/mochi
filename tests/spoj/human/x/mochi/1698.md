# SPOJ PLSEARCH - Polygonal Line Search

## Algorithm

1. **Read input** consisting of several datasets. Each dataset begins with `n`. Then `n+1` polygonal
   lines follow. `Polygonal line0` is the template.
2. **Encode polygonal lines**:
   - For each pair of consecutive points compute the segment direction and length.
   - Direction is encoded as `0=E`, `1=N`, `2=W`, `3=S`.
3. **Canonical representation**:
   - Generate segment sequences for both orientations (original and reversed). For the reversed
     orientation the directions are rotated by 180 degrees.
   - For each orientation, rotate directions by 0°, 90°, 180°, and 270°.
   - Encode each rotated sequence as a string `dir:length;...` and keep the lexicographically
     smallest string. This canonical form is invariant under rotation and translation.
4. **Compare** the canonical form of every polygonal line with the canonical form of the template.
   Output indices of matching lines in ascending order followed by `+++++`.

## Correctness Proof

We prove that the algorithm outputs exactly the polygonal lines that have the same shape as the
template.

### Lemma 1
For any polygonal line, the sequence of (direction, length) pairs uniquely determines its shape
up to translation.

*Proof.* Each segment is parallel to an axis and defined by its direction and length. Starting from
a reference point the whole line is reconstructed by concatenating the segments. Translation only
changes the starting point, thus the sequence is translation invariant. ∎

### Lemma 2
Reversing the order of vertices results in the same sequence of segments as the original after
reversing the direction of every segment.

*Proof.* Traversing the line backwards visits the segments in reverse order and with the opposite
direction. Adjusting each direction by 180° therefore yields the same geometric path. ∎

### Lemma 3
Rotating a polygonal line by multiples of 90° is equivalent to cyclically shifting the direction
codes by the same amount.

*Proof.* A 90° rotation maps east→north→west→south→east which is exactly adding 1 modulo 4 to the
direction code. Applying this to every segment simulates the rotation. ∎

### Lemma 4
The canonical representation produced by the algorithm is the same for two polygonal lines iff the
lines are congruent by rotation and translation.

*Proof.* By Lemmas 2 and 3 the algorithm enumerates all possible rotations and both orientations of a
polygonal line, generating a sequence for each. The lexicographically smallest sequence therefore is
identical for two lines exactly when one of their oriented rotations coincide, i.e. when they have
the same shape. ∎

### Theorem
For each dataset, the algorithm prints the indices of exactly those polygonal lines that have the
same shape as the template.

*Proof.* By Lemma 1 the segment sequence captures the line shape up to translation. Lemmas 2 and 3
show that the canonical form accounts for orientation and rotation. Lemma 4 states that two lines
have equal canonical forms iff they are congruent by rotation and translation. Therefore the
algorithm identifies all polygonal lines with the same shape as the template. ∎

## Complexity Analysis

Let `m` be the number of vertices of a polygonal line (≤ 10) and `n` the number of lines (≤ 50).
Building the segment list takes `O(m)`. Computing all 8 variants (4 rotations × 2 orientations) also
takes `O(m)` time. For each dataset we thus spend `O(n·m)` time and `O(m)` memory.

## References

- [SPOJ Problem PLSEARCH](https://www.spoj.com/problems/PLSEARCH/)
