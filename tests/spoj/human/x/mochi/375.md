# [Query on a tree](https://www.spoj.com/problems/QTREE/)

## Problem Summary
For each test case we are given a tree with up to 10â€¯000 nodes. Each edge has a cost and an index. Two types of operations are performed repeatedly:
- `CHANGE i t` updates the cost of the i-th edge.
- `QUERY a b` asks for the maximum edge cost on the path between nodes `a` and `b`.

We must process these operations until the command `DONE` and output the result for every query.

## Algorithm
For clarity a straightforward breadth-first search is applied for each query.

1. Build an adjacency list where every edge stores its index so that edge weights can be updated in O(1).
2. For `QUERY a b` run a BFS from node `a` until `b` is reached, keeping the parent node and the edge index used to reach each visited node.
3. Reconstruct the path from `b` back to `a` using the parent pointers and take the maximum weight among the traversed edges.
4. For `CHANGE i t` simply update the weight of the i-th edge; the adjacency list keeps edge indices so no structure needs to be rebuilt.

Each query explores at most all nodes of the tree (`O(N)`), which is sufficient for the problem constraints, while updates run in constant time.
