// Solution for SPOJ DELCOMM2 - DEL Command II
// https://www.spoj.com/problems/DELCOMM2/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseIntStr(str: string): int {
  var i = 0
  var n = 0
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  return n
}

fun splitSpace(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " {
      if cur != "" {
        parts = append(parts, cur)
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if cur != "" { parts = append(parts, cur) }
  return parts
}

type Pair {
  i: int,
  j: int,
}

fun lcsPos(a: string, b: string): list<Pair> {
  let n = len(a)
  let m = len(b)
  var dp: list<list<int>> = []
  var i = 0
  while i <= n {
    var row: list<int> = []
    var j = 0
    while j <= m {
      row = append(row, 0)
      j = j + 1
    }
    dp = append(dp, row)
    i = i + 1
  }
  i = n - 1
  while i >= 0 {
    var j = m - 1
    while j >= 0 {
      if a[i:i+1] == b[j:j+1] {
        dp[i][j] = dp[i+1][j+1] + 1
      } else {
        if dp[i+1][j] >= dp[i][j+1] {
          dp[i][j] = dp[i+1][j]
        } else {
          dp[i][j] = dp[i][j+1]
        }
      }
      j = j - 1
    }
    i = i - 1
  }
  var res: list<Pair> = []
  i = 0
  var j = 0
  while i < n && j < m {
    if a[i:i+1] == b[j:j+1] {
      res = append(res, Pair { i: i, j: j })
      i = i + 1
      j = j + 1
    } else if dp[i+1][j] >= dp[i][j+1] {
      i = i + 1
    } else {
      j = j + 1
    }
  }
  return res
}

fun patternLCS(a: string, b: string): string {
  let matches = lcsPos(a, b)
  var pat = ""
  var ia = 0
  var ib = 0
  var idx = 0
  while idx < len(matches) {
    let m = matches[idx]
    let ga = m.i - ia
    let gb = m.j - ib
    if ga == gb {
      var k = 0
      while k < ga {
        pat = pat + "?"
        k = k + 1
      }
    } else {
      if pat == "" || pat[len(pat)-1:len(pat)] != "*" {
        pat = pat + "*"
      }
    }
    pat = pat + a[m.i:m.i+1]
    ia = m.i + 1
    ib = m.j + 1
    idx = idx + 1
  }
  let ga = len(a) - ia
  let gb = len(b) - ib
  if ga == gb {
    var k = 0
    while k < ga {
      pat = pat + "?"
      k = k + 1
    }
  } else if ga > 0 || gb > 0 {
    if pat == "" || pat[len(pat)-1:len(pat)] != "*" {
      pat = pat + "*"
    }
  }
  return pat
}

fun patternQS(a: string, b: string): string {
  let la = len(a)
  let lb = len(b)
  var i = 0
  while i < la && i < lb && a[i:i+1] == b[i:i+1] {
    i = i + 1
  }
  var j = 0
  while j < la - i && j < lb - i && a[la-1-j:la-j] == b[lb-1-j:lb-j] {
    j = j + 1
  }
  let prefix = a[0:i]
  let suffix = a[la-j:la]
  let midA = a[i:la-j]
  let midB = b[i:lb-j]
  if len(midA) == len(midB) {
    var mid = ""
    var k = 0
    while k < len(midA) {
      if midA[k:k+1] == midB[k:k+1] {
        mid = mid + midA[k:k+1]
      } else {
        mid = mid + "?"
      }
      k = k + 1
    }
    return prefix + mid + suffix
  }
  if prefix == "" && suffix == "" {
    return "*"
  }
  return prefix + "*" + suffix
}

fun matchPat(p: string, s: string): bool {
  var i = 0
  var j = 0
  var star = -1
  var mp = 0
  while j < len(s) {
    if i < len(p) && (p[i:i+1] == s[j:j+1] || p[i:i+1] == "?") {
      i = i + 1
      j = j + 1
    } else if i < len(p) && p[i:i+1] == "*" {
      star = i
      mp = j
      i = i + 1
    } else if star >= 0 {
      i = star + 1
      mp = mp + 1
      j = mp
    } else {
      return false
    }
  }
  while i < len(p) && p[i:i+1] == "*" { i = i + 1 }
  return i == len(p)
}

fun solveDataset(pos: list<string>, neg: list<string>): int {
  var pats: map<string, bool> = {}
  var i = 0
  while i < len(pos) {
    pats[pos[i]] = true
    i = i + 1
  }
  i = 0
  while i < len(pos) {
    var j = i + 1
    while j < len(pos) {
      let p1 = patternLCS(pos[i], pos[j])
      if len(p1) <= 8 { pats[p1] = true }
      let p2 = patternQS(pos[i], pos[j])
      if len(p2) <= 8 { pats[p2] = true }
      j = j + 1
    }
    i = i + 1
  }
  var best = 0
  for pat in pats {
    var bad = false
    var k = 0
    while k < len(neg) {
      if matchPat(pat, neg[k]) { bad = true; break }
      k = k + 1
    }
    if bad { continue }
    k = 0
    var cnt = 0
    while k < len(pos) {
      if matchPat(pat, pos[k]) { cnt = cnt + 1 }
      k = k + 1
    }
    if cnt > best { best = cnt }
  }
  return best
}

fun main() {
  var lines: list<string> = []
  while true {
    let l = input()
    if l == nil { break }
    lines = append(lines, l)
  }
  if len(lines) == 0 { return }
  var idx = 0
  let m = parseIntStr(lines[idx])
  idx = idx + 1
  while idx < len(lines) && lines[idx] == "" { idx = idx + 1 }
  var ds = 0
  while ds < m && idx < len(lines) {
    var pos: list<string> = []
    var neg: list<string> = []
    while idx < len(lines) && lines[idx] != "" {
      let parts = splitSpace(lines[idx])
      let name = parts[0]
      if parts[1] == "+" {
        pos = append(pos, name)
      } else {
        neg = append(neg, name)
      }
      idx = idx + 1
    }
    let ans = solveDataset(pos, neg)
    print(str(ans))
    ds = ds + 1
    while idx < len(lines) && lines[idx] == "" { idx = idx + 1 }
  }
}

main()
