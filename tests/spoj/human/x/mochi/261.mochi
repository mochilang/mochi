// Solution for SPOJ TRIPART - Triangle Partitioning
// https://www.spoj.com/problems/TRIPART/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseInts(line: string): list<int> {
  var nums: list<int> = []
  var i = 0
  var cur = 0
  var sign = 1
  var has = false
  while i < len(line) {
    let ch = line[i:i+1]
    if ch == "-" {
      sign = -1
      i = i + 1
    } else if ch >= "0" && ch <= "9" {
      cur = cur * 10 + (digits[ch] as int)
      has = true
      i = i + 1
    } else {
      if has {
        nums = append(nums, sign * cur)
        cur = 0
        sign = 1
        has = false
      }
      i = i + 1
    }
  }
  if has {
    nums = append(nums, sign * cur)
  }
  return nums
}

fun gcd(a: int, b: int): int {
  var x = if a < 0 { -a } else { a }
  var y = if b < 0 { -b } else { b }
  while y != 0 {
    let t = x % y
    x = y
    y = t
  }
  return x
}

type Tri = { a: int, b: int, c: int }

fun normalize(a: int, b: int, c: int): Tri {
  var x = a
  var y = b
  var z = c
  if x > y { var t = x; x = y; y = t }
  if y > z { var t = y; y = z; z = t }
  if x > y { var t = x; x = y; y = t }
  let g1 = gcd(x, y)
  let g2 = gcd(g1, z)
  return Tri{ a: x / g2, b: y / g2, c: z / g2 }
}

fun key(t: Tri): string {
  return str(t.a) + "," + str(t.b) + "," + str(t.c)
}

fun containsStr(lst: list<string>, target: string): bool {
  for s in lst {
    if s == target { return true }
  }
  return false
}

fun countStyles(a: int, b: int, c: int): int {
  var start = normalize(a * a, b * b, c * c)
  var seen: list<string> = []
  var queue: list<Tri> = []
  seen = append(seen, key(start))
  queue = append(queue, start)
  var idx = 0
  while idx < len(queue) {
    let cur = queue[idx]
    idx = idx + 1
    let x = cur.a
    let y = cur.b
    let z = cur.c
    let m = 2 * x + 2 * y - z
    var t1 = normalize(4 * x, m, z)
    let k1 = key(t1)
    if !containsStr(seen, k1) {
      seen = append(seen, k1)
      queue = append(queue, t1)
    }
    var t2 = normalize(4 * y, m, z)
    let k2 = key(t2)
    if !containsStr(seen, k2) {
      seen = append(seen, k2)
      queue = append(queue, t2)
    }
  }
  return len(seen)
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let t = tLine as int
  var case = 0
  while case < t {
    var line = input()
    if line == "" { continue }
    let nums = parseInts(line)
    let a = nums[0]
    let b = nums[1]
    let c = nums[2]
    let ans = countStyles(a, b, c)
    print(str(ans))
    case = case + 1
  }
}

main()
