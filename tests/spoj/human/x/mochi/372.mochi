// Solution for SPOJ BENEFACT - The Benefactor
// https://www.spoj.com/problems/BENEFACT/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseInts(line: string): list<int> {
  var nums: list<int> = []
  var i = 0
  var cur = 0
  var sign = 1
  var inNum = false
  while i < len(line) {
    let ch = line[i:i+1]
    if ch == "-" {
      sign = -1
      i = i + 1
    } else if ch >= "0" && ch <= "9" {
      cur = cur * 10 + (digits[ch] as int)
      inNum = true
      i = i + 1
    } else {
      if inNum {
        nums = append(nums, sign * cur)
        cur = 0
        sign = 1
        inNum = false
      }
      i = i + 1
    }
  }
  if inNum {
    nums = append(nums, sign * cur)
  }
  return nums
}

type Edge { to: int, w: int }

fun bfs(start: int, adj: list<list<Edge>>, n: int): list<int> {
  var dist: list<int> = []
  var i = 0
  while i <= n {
    dist = append(dist, 0 - 1)
    i = i + 1
  }
  var q: list<int> = []
  var head = 0
  q = append(q, start)
  dist[start] = 0
  while head < len(q) {
    let v = q[head]
    head = head + 1
    var j = 0
    while j < len(adj[v]) {
      let e = adj[v][j]
      let u = e.to
      if dist[u] == 0 - 1 {
        dist[u] = dist[v] + e.w
        q = append(q, u)
      }
      j = j + 1
    }
  }
  var maxNode = start
  var maxDist = 0
  i = 1
  while i <= n {
    if dist[i] > maxDist {
      maxDist = dist[i]
      maxNode = i
    }
    i = i + 1
  }
  var res: list<int> = []
  res = append(res, maxNode)
  res = append(res, maxDist)
  return res
}

fun main() {
  let tLine = input()
  if tLine == "" { return }
  let T = parseInts(tLine)[0]
  var case = 0
  while case < T {
    var line = input()
    while line == "" { line = input() }
    let n = parseInts(line)[0]
    var adj: list<list<Edge>> = []
    var i = 0
    while i <= n {
      adj = append(adj, [])
      i = i + 1
    }
    var e = 0
    while e < n - 1 {
      let l = input()
      if l == "" { continue }
      let vals = parseInts(l)
      let a = vals[0] as int
      let b = vals[1] as int
      let w = vals[2] as int
      adj[a] = append(adj[a] as list<Edge>, Edge{ to:b, w:w })
      adj[b] = append(adj[b] as list<Edge>, Edge{ to:a, w:w })
      e = e + 1
    }
    let tmp = bfs(1, adj, n)
    let start = tmp[0] as int
    let ans = bfs(start, adj, n)
    print(str(ans[1]))
    case = case + 1
  }
}

main()
