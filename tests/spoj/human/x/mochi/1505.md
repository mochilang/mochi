# [Whac-a-Mole](https://www.spoj.com/problems/MOLE/)

## Problem Summary
You play the Whac-a-Mole game on an `n × n` grid of holes. At time `t` each mole pops up at an integer coordinate `(x, y)` for one time step. Between steps you may move your hammer in a straight line to any other integer point at Euclidean distance at most `d` from its current position. Any mole whose hole lies on the line segment of this move (including the endpoints) is whacked and scores a point. You may place the hammer anywhere before time `1`. Given up to `m ≤ 1000` mole appearances with times `1 ≤ t ≤ 10`, find the maximum score.

## Algorithm
1. Build a 3‑D array `moles[t][x][y]` counting how many moles appear at each time and position.
2. Dynamic programming over time and hammer position:
   - `dp[t][x][y]` is the maximum score after processing time `t` and ending at `(x, y)`.
   - Initialize `dp[0][x][y] = 0` for all positions since the hammer may start anywhere.
   - For each time `t` and starting cell `(x1, y1)`, iterate over every cell `(x2, y2)` within distance `d`.
   - Let `dx = x2 - x1` and `dy = y2 - y1`. The line segment between the points contains `gcd(|dx|, |dy|) + 1` integer points spaced by `(dx/g, dy/g)`.
   - Sum `moles[t][x][y]` over these points to count all moles whacked along the move and update `dp[t][x2][y2]`.
3. The answer is the maximum value in `dp[maxT]` after the last time step.

The grid is at most `20 × 20` and `d ≤ 5`, so the DP runs in `O(T · n^2 · d^2)` time which is easily manageable.
