# SPOJ ZOO - Zoo

Given a circular zoo with `N` enclosures and `C` children, each child sees five
consecutive enclosures starting at `E`. Every child provides the indices of the
animals they fear and love (subsets of those five). A child is happy if at least
one feared animal is removed or at least one loved animal remains. The goal is
to remove animals from some enclosures to maximize the number of happy
children.

## Algorithm

We model each enclosure as a binary variable: 1 if the animal is removed,
0 otherwise. For a child whose view starts at `E`, let `window` be a 5‑bit mask
representing the removal status of enclosures `E..E+4`.

A child with fear mask `F` and love mask `L` is happy if
`(F & window) != 0` (some feared animal removed) or
`(L & (~window)) != 0` (some loved animal kept).

Children are grouped by their starting enclosure. For each start position we
precompute, for all `32` possible windows, how many children become happy.

To handle the circular structure, we enumerate the initial removal pattern for
the first four enclosures (`16` possibilities). For each pattern we run dynamic
programming over the zoo:

- State: 4‑bit mask of the last four enclosures.
- Transition: choose removal for the next enclosure, evaluate the child whose
  window now closes, and shift the mask.
- The last four positions are fixed to match the initial pattern.

The DP visits `N + 4` positions. The best result over all starting patterns is
the maximum number of happy children.

## Complexity

There are at most `16` starting patterns, each processed with `O(N * 16 * 2)`
operations. Precomputing scores uses `O(N * 32 * avgChildren)` which is about
`1.6` million iterations. The total time is well within the limits for
`N ≤ 10^4` and `C ≤ 5·10^4`.
