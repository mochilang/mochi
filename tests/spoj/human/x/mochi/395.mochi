// Solution for SPOJ APRIME - Anti-prime Sequences
// https://www.spoj.com/problems/APRIME/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun parseInts(line: string): list<int> {
  var nums: list<int> = []
  var i = 0
  var cur = 0
  var sign = 1
  var inNum = false
  while i < len(line) {
    let ch = line[i:i+1]
    if ch == "-" {
      sign = -1
      i = i + 1
    } else if ch >= "0" && ch <= "9" {
      cur = cur * 10 + (digits[ch] as int)
      inNum = true
      i = i + 1
    } else {
      if inNum {
        nums = append(nums, sign * cur)
        cur = 0
        sign = 1
        inNum = false
      }
      i = i + 1
    }
  }
  if inNum {
    nums = append(nums, sign * cur)
  }
  return nums
}

var primes: list<bool> = []

fun initPrimes(limit: int) {
  primes = []
  var i = 0
  while i <= limit {
    primes = append(primes, true)
    i = i + 1
  }
  primes[0] = false
  primes[1] = false
  var p = 2
  while p * p <= limit {
    if primes[p] {
      var j = p * p
      while j <= limit {
        primes[j] = false
        j = j + p
      }
    }
    p = p + 1
  }
}

var nums: list<int> = []
var used: list<bool> = []
var seq: list<int> = []
var result: list<int> = []
var total = 0
var maxD = 0

fun dfs(): bool {
  if len(seq) == total {
    result = seq
    return true
  }
  var i = 0
  while i < total {
    if used[i] == false {
      let num = nums[i] as int
      var sum = num
      var ok = true
      var k = 1
      while k <= maxD - 1 && k <= len(seq) {
        sum = sum + (seq[len(seq) - k] as int)
        if primes[sum] {
          ok = false
          break
        }
        k = k + 1
      }
      if ok {
        used[i] = true
        seq = append(seq, num)
        if dfs() { return true }
        seq = seq[0:len(seq)-1]
        used[i] = false
      }
    }
    i = i + 1
  }
  return false
}

fun solve(n: int, m: int, d: int): string {
  nums = []
  var x = n
  while x <= m {
    nums = append(nums, x)
    x = x + 1
  }
  total = len(nums)
  used = []
  var i = 0
  while i < total {
    used = append(used, false)
    i = i + 1
  }
  seq = []
  result = []
  maxD = d
  if dfs() {
    var out = ""
    var j = 0
    while j < total {
      if j > 0 { out = out + "," }
      out = out + str(result[j] as int)
      j = j + 1
    }
    return out
  }
  return "No anti-prime sequence exists."
}

fun main() {
  initPrimes(10000)
  while true {
    let line = input()
    if line == "" { break }
    let parts = parseInts(line)
    if len(parts) < 3 { continue }
    let n = parts[0] as int
    let m = parts[1] as int
    let d = parts[2] as int
    if n == 0 && m == 0 && d == 0 { break }
    print(solve(n, m, d))
  }
}

main()
