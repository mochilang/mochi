# [Collatz](https://www.spoj.com/problems/CLTZ/)

## Problem Summary
Given a starting positive integer `N`, define the sequence
`f(1) = N` and for `K > 1`
```
f(K) = (0.5 + 2.5 * (f(K-1) mod 2)) * f(K-1) + (f(K-1) mod 2)
```
This simplifies to the classic Collatz rule: if the current value is even,
divide it by 2; if it is odd, multiply by 3 and add 1. For each input `N`,
compute the smallest `L` such that `f(L) = 1`.

## Algorithm
1. Read each line until EOF and parse `N` as an arbitrary-precision `bigint`.
2. Initialise a step counter `L = 1` and a variable `x = N`.
3. While `x` is not `1`:
   - Compute `q = x / 2` and `r = x - q * 2` to obtain the remainder `r`.
   - If `r` is `0`, set `x = q` (even case); otherwise set `x = 3 * x + 1` (odd case).
   - Increment `L`.
4. Output `L`.

The use of `bigint` ensures correctness for values up to `10^1888`. Each
iteration reduces or transforms the number according to Collatz rules, so the
loop runs exactly `L - 1` times.
