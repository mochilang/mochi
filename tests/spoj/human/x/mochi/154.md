# [Sweet and Sour Rock](https://www.spoj.com/problems/ROCK/)

## Problem Summary
Given a stick of rock represented by a binary string where `1` marks a sweet segment and `0` marks a sour one, we may break the stick into pieces at any boundaries. A piece can be sold only if it has more sweet segments than sour ones. For each test case, compute the maximum total length of sellable pieces.

## Algorithm
1. Convert the string to values `+1` (sweet) and `-1` (sour) and compute prefix sums.
2. Dynamic programming over positions:
   - `dp[i]` stores the maximum sellable length using the first `i` segments.
   - For every `i < j`, if the segment `i..j-1` has positive sum (`pref[j]-pref[i] > 0`), update `dp[j] = max(dp[j], dp[i] + (j-i))`.
   - Carry forward `dp[i]` to `dp[i+1]` to allow skipping.
3. Answer is `dp[n]`.

The DP examines `O(n^2)` segments and uses `O(n)` memory, suitable for `n â‰¤ 200`.
