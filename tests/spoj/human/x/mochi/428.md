# [Particular Palindromes](https://www.spoj.com/problems/PARTPALI/)

## Problem Summary
Given integers `m` and `s`, count how many positive `s`-digit palindromes are divisible by `m`. The first line contains the number of test cases followed by lines with `m s` where `1 < m < 1000` and `s < 20`.

## Algorithm
1. A palindrome is determined by its first `ceil(s/2)` digits. The first digit cannot be zero.
2. Precompute powers of ten modulo `m` for all positions. When choosing digit `d` for position `i` (and its mirrored position `j = s-1-i`):
   - If `i == j` (the middle digit for odd `s`), its contribution is `d * 10^i`.
   - Otherwise, the contribution is `d * (10^i + 10^j)`.
3. Use dynamic programming over positions and current remainder modulo `m`:
   - `dp[r]` is the number of ways to fill processed positions resulting in remainder `r`.
   - For each position, try all valid digits and update new remainders using the precomputed contributions.
4. After processing all positions, `dp[0]` gives the count of palindromes divisible by `m`.

The state space is at most `m` (â‰¤1000) and we process up to 10 positions with 10 digits each, so the algorithm runs in around `O(m * s * 10)` operations, easily within limits.
