# [Yet Another N-Queen Problem](https://www.spoj.com/problems/NQUEEN/)

## Problem Summary
Given an \(N\times N\) board (\(N \le 50\)), some rows may already have a queen fixed in a
specified column.  Each line of input gives \(N\) followed by the column for each row
(0 means no preset queen).  Find one placement of \(N\) queens so that no two
attack each other and all preset queens remain in place.

## Algorithm
1. Maintain three boolean arrays to mark used columns and the two diagonal types:
   - `cols[c]` indicates column \(c\) already has a queen.
   - `diag1[r+c]` marks \(\nearrow\) diagonals.
   - `diag2[r-c+N]` marks \(\searrow\) diagonals.
2. Use depth-first search over rows:
   - If row `r` has a preset column `c`, verify it is free and recurse to `r+1`.
   - Otherwise try each column `c` that is free; place the queen, mark arrays,
     recurse, and backtrack on failure.
3. Once all rows are processed, output the recorded column positions.

This backtracking places queens row by row and prunes conflicts in \(O(N)\)
per check, which is fast enough for the given limit.
