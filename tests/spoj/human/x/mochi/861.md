# [Counting inversions](https://www.spoj.com/problems/SWAPS/)

## Problem Summary
Given a sequence of up to 250000 integers (values 1..50000), perform M (≤10000) operations. Each operation assigns a new value to one position and asks for the number of inversions in the sequence (pairs i < j with Ai > Aj) after the change.

## Algorithm
1. Divide the array into blocks of roughly 700 elements and keep for each block a sorted list of its values.
2. Compute the initial inversion count by iterating through the array and using the block structure to count how many later elements are smaller than the current value.
3. For an update at position `x`:
   - Let `old` be the current value. Count contributions of `old` to inversions:
     - Elements before `x` greater than `old`.
     - Elements after `x` smaller than `old`.
     These counts are obtained by scanning the partial block containing `x` and by binary searching the sorted lists of full blocks.
   - Subtract these counts from the total inversion count.
   - Remove `old` from its block and insert the new value `y` keeping the block sorted.
   - Count and add the new contributions of `y` using the same method.
   - Output the updated inversion count.

The per‑update work touches at most one partial block plus all preceding or following blocks via binary search, giving roughly `O(√N log N)` time.

## Complexity
- Initial inversion count and block construction: `O(N √N)`.
- Each update: `O(√N log N)`.
This is fast enough for the given limits.
