// Solution for SPOJ MAZE - The Long and Narrow Maze
// https://www.spoj.com/problems/MAZE/

let digits = {
  "0":0,"1":1,"2":2,"3":3,"4":4,
  "5":5,"6":6,"7":7,"8":8,"9":9,
}

fun splitSpaces(s: string): list<string> {
  var parts: list<string> = []
  var cur = ""
  var i = 0
  while i < len(s) {
    let ch = s[i:i+1]
    if ch == " " {
      if cur != "" {
        parts = append(parts, cur)
        cur = ""
      }
    } else {
      cur = cur + ch
    }
    i = i + 1
  }
  if cur != "" { parts = append(parts, cur) }
  return parts
}

fun parseIntStr(str: string): int {
  var i = 0
  var n = 0
  var neg = false
  if len(str) > 0 && str[0:1] == "-" {
    neg = true
    i = 1
  }
  while i < len(str) {
    n = n * 10 + (digits[str[i:i+1]] as int)
    i = i + 1
  }
  if neg { n = 0 - n }
  return n
}

fun allowed(t: int, dirIn: int): list<int> {
  if t == 1 {
    if dirIn == 0 { return [2] }
    if dirIn == 2 { return [0] }
    if dirIn == 1 { return [3] }
    if dirIn == 3 { return [1] }
  } else if t == 2 {
    if dirIn == 0 || dirIn == 2 { return [1, 3] }
    if dirIn == 1 || dirIn == 3 { return [0, 2] }
  }
  return []
}

fun canSolve(grid: list<list<int>>, n: int): bool {
  let total = 3 * n * 4
  var visited: list<bool> = []
  var i = 0
  while i < total { visited = append(visited, false); i = i + 1 }
  var queue: list<int> = []
  var head = 0
  var r = 0
  while r < 3 {
    if grid[r][0] != 0 {
      let id = ((r * n) + 0) * 4 + 0
      visited[id] = true
      queue = append(queue, id)
    }
    r = r + 1
  }
  let dr = [0, -1, 0, 1]
  let dc = [-1, 0, 1, 0]
  let opp = [2, 3, 0, 1]
  while head < len(queue) {
    let state = queue[head]
    head = head + 1
    var tmp = state
    let dirIn = tmp % 4
    tmp = tmp / 4
    let c = tmp % n
    let r = tmp / n
    let t = grid[r][c]
    let exits = allowed(t, dirIn)
    var ei = 0
    while ei < len(exits) {
      let dirOut = exits[ei]
      if dirOut == 2 && c == n - 1 { return true }
      let nr = r + dr[dirOut]
      let nc = c + dc[dirOut]
      if nr >= 0 && nr < 3 && nc >= 0 && nc < n {
        if grid[nr][nc] != 0 {
          let ndir = opp[dirOut]
          let id2 = ((nr * n) + nc) * 4 + ndir
          if !visited[id2] {
            visited[id2] = true
            queue = append(queue, id2)
          }
        }
      }
      ei = ei + 1
    }
  }
  return false
}

fun main() {
  let tLine = input()
  if tLine == nil || tLine == "" { return }
  let t = parseIntStr(tLine)
  var case = 0
  while case < t {
    let n = parseIntStr(input())
    var g0: list<int> = []
    var g1: list<int> = []
    var g2: list<int> = []
    var i = 0
    while i < n {
      let line = input()
      let parts = splitSpaces(line)
      g0 = append(g0, parseIntStr(parts[0]))
      g1 = append(g1, parseIntStr(parts[1]))
      g2 = append(g2, parseIntStr(parts[2]))
      i = i + 1
    }
    let grid = [g0, g1, g2]
    if canSolve(grid, n) { print("yes") } else { print("no") }
    case = case + 1
  }
}

main()
