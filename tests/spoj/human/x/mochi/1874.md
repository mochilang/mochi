# BWHEELER - Burrows Wheeler Precompression

[https://www.spoj.com/problems/BWHEELER/](https://www.spoj.com/problems/BWHEELER/)

## Algorithm

Given the output of the Burrows–Wheeler Transform (the last column `L` and the row index `R` of the original string), reconstruct the original string.

The inverse transform is performed with the standard `next` array technique:

1. Count occurrences of each character in `L` and record for every position `i` the occurrence number `occ[i]` of `L[i]`.
2. Compute for every character `c` the starting index `start[c]` of `c` in the first column `F` (which is just `L` sorted).
3. For each position `i`, set `next[i] = start[L[i]] + occ[i] - 1`.  This maps row `i` in the matrix to the row that follows it when rotating.
4. Starting at row `R-1`, repeatedly output `L[row]` and update `row = next[row]` for `n` steps, filling the result from the end.

## Correctness

- Each rotation of the original string corresponds to one row of the BWT matrix.  The character in the last column `L[i]` precedes the rotation starting at row `next[i]`.
- `start[c]` gives the first row in `F` whose rotation starts with character `c`.  Adding the occurrence number minus one maps a specific occurrence in `L` to its corresponding row in `F`.
- Following `next` from row `R-1` traverses the rotations in reverse order of the original string. Filling the output from the end reconstructs the original string exactly.

## Complexity

Let `n = len(L)` (≤ 1000). Building the counts and the `next` array is `O(n)`, and reconstructing the string takes another `O(n)`.  The algorithm therefore runs in linear time and uses `O(n)` extra memory.
