# [Voracious Steve](https://www.spoj.com/problems/STEVE/)

## Problem Summary
Two players alternately take 1..m donuts from a box of n donuts. Whoever
empties the box eats their collected donuts; the other player's donuts are
returned to the box and the loser begins the next round. The game repeats until
all donuts are eaten. Assuming optimal play, determine how many donuts Steve,
who starts the first round, can guarantee to eat.

## Algorithm
We model the game with minimax dynamic programming on states `(n, s, d, turn)`
where `n` is donuts left in the current round, `s` and `d` are donuts collected
by Steve and Digit in this round, and `turn` indicates whose move it is
(`0` for Steve, `1` for Digit).

- When `n == 0`, the round is finished. If Steve made the last move (`turn == 1`),
  he adds `s` donuts to his total and the next round starts with `d` donuts and
  Digit's turn. If Digit made the last move, Steve's `s` donuts become the next
  round's starting count and Steve moves first again.
- On Steve's turn we try every possible take `k` in `[1, min(m, n)]` and select
  the move maximizing his eventual total.
- On Digit's turn we choose the move minimizing Steve's total.
- Memoization over the four parameters ensures each state is solved only once.

## Complexity
The state space is `O(n^3)` (for `n â‰¤ 100`), and each state explores at most `m`
transitions, giving `O(n^3 * m)` time and `O(n^3)` memory, easily manageable for
the constraints.
