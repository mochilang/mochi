# Voracious Steve (STEVE)

Given `n` donuts and a limit `m` per move, Steve and Digit alternately take `1..m` donuts from the box. When a player empties the box he eats the donuts he collected, the other player returns his donuts to the box, and the game continues with that player starting. Both play optimally and the goal is to maximize Steve's total donuts.

## Algorithm
- Use minimax recursion with memoization on states `(n, s, d, turn)` where
  - `n` – donuts remaining in the box,
  - `s` – donuts currently held by Steve,
  - `d` – donuts currently held by Digit,
  - `turn` – `0` if Steve moves next, `1` if Digit moves next.
- If `n = 0` the round finished.  
  - If `turn = 0` Digit emptied the box: restart with `n = s` and Steve to move.  
  - If `turn = 1` Steve emptied the box: he eats `s` donuts and the game restarts with Digit starting on `n = d`, so Steve gains `s + (d - F(d))` where `F` is the result for a starting player.
- Otherwise simulate all legal moves `1..min(m, n)`.  
  - When `turn = 0` choose the move maximizing Steve's final donuts.  
  - When `turn = 1` choose the move minimizing Steve's final donuts.
- Memoize results for each state to avoid recomputation.

The state space is at most `101³ × 2` states (≈2 million). Each state explores up to `m ≤ 100` moves, so the solution runs comfortably within the limits for `n ≤ 100`.
