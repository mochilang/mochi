# HKNAP - Huge Knap Sack

[Problem Link](https://www.spoj.com/problems/HKNAP/)

We have `S` sacks of volume `Y` each and `N` types of statues available in unlimited
quantities.  Type `i` has weight `W[i]` and occupies volume `V[i]`.  Sacks may be
stitched together: joining `k` sacks costs `(k-1)*C` and yields a sack of volume `k*Y`.
For each test case we must maximise the total transported weight minus stitching
costs.

## Algorithm

1. Among all statue types find the one with the best weight/volume ratio
   `(W/V)`.  Let its weight and volume be `w0` and `v0`.
2. Precompute via unbounded knapsack the maximal weight for all volumes up to
   `B = 20000 + v0` using standard dynamic programming.  This covers any
   remainder after removing many best-ratio statues.
3. Define `value(cap)` to return the maximal weight for capacity `cap`:
   - If `cap ≤ B`, use the precomputed table.
   - Otherwise subtract `k = (cap - 20000) / v0` copies of the best statue,
     leaving a remainder `r = cap - k*v0 ≤ B`.  The answer is
     `dp[r] + k*w0`.
4. For every possible group size `t` (`1 ≤ t ≤ S`) compute
   `gain[t] = value(t*Y) - (t-1)*C`.
5. Use another DP over the number of sacks to partition them into groups:
   `dp[0]=0` and
   `dp[i] = max_{1≤t≤i} (dp[i-t] + gain[t])`.
6. The result is `dp[S]`.

The precomputation is `O(N*B)` and the final partition DP is `O(S^2)`, both
within the limits of the problem.
