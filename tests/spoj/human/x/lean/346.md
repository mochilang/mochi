# Solution for SPOJ problem [COINS](https://www.spoj.com/problems/COINS/)

## Algorithm

1. For a coin with value `n`, you may either exchange it into three coins
   of values `n/2`, `n/3`, and `n/4` (integer division) or sell it directly
   for `n` dollars.
2. Define `f(n)` as the maximum dollars obtainable from a coin `n`.
   Then
   `f(n) = max(n, f(n/2) + f(n/3) + f(n/4))`.
3. Compute `f(n)` recursively and store already computed results in a hash
   map (memoization) because the same subproblems appear many times.
4. For each input line, evaluate `f(n)` using the memoization map and print
   the result.

## Correctness Proof

We prove by strong induction on `n` that the algorithm computes `f(n)` as
defined above.

*Base cases*: For `n < 12`, exchanging the coin yields less than `n`
  dollars, so the algorithm returns `n`, which equals `max(n, f(n/2)+f(n/3)+f(n/4))`.

*Inductive step*: Assume for all `m < n` the algorithm returns `f(m)`.
  When evaluating `f(n)`, the algorithm recursively computes
  `f(n/2)`, `f(n/3)`, and `f(n/4)`. By the induction hypothesis these are
  correct. It then returns the maximum between `n` and their sum, which is
  exactly the definition of `f(n)`. Therefore the algorithm returns the
  correct value for `n`.

By induction, the algorithm is correct for all `n`.

## Complexity Analysis

Each recursive call reduces the argument at least by half, so the recursion
depth is `O(log n)`. Each distinct `n` is computed only once and stored in
  the memoization map. Therefore the overall time complexity for each test
case is `O(log n)` and the space complexity is also `O(log n)` for the call
stack and the memoized values.

## References

- [SPOJ COINS - Bytelandian gold coins](https://www.spoj.com/problems/COINS/)
