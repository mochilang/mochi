# Bundling (SPOJ 83)

We are given up to `10^5` instructions, each with a type `A..J` and a dependency to a previous instruction.  Bundles hold up to three instructions.  Each template specifies the allowed type in each slot and optionally a stop after slot 1 or 2.  Between two consecutive stops no instruction may depend on another instruction in the same segment.

For every test case we must minimize the number of bundles used; among all packings with minimal bundles we minimize the number of inserted stops.

## Algorithm

Dynamic programming over the processed prefix is used.  Let `dp[i] = (b,s)` be the minimal pair
`(bundles, stops)` for the first `i` instructions assuming there is a stop right before instruction `i`.
`dp[0] = (0,0)`.

For every position `i` and template we try to place a bundle of length `k = 1..3` starting at `i`:

1. The first `k` instruction types must match the template slots.
2. While scanning the `k` instructions we maintain the start of the current segment
   (the instruction following the last stop).  For every instruction `r` in the bundle
   we ensure that its dependency is strictly before the current segment start.
   If the template inserts an internal stop after slot `p` we update the segment start.
3. If the bundle is valid we update `dp[i+k]` with `(b+1, s + inner + end)` where
   `inner` counts the stop inside the bundle and `end` counts the stop between bundles
   (none is added after the last bundle).

Lexicographical minimization on `(bundles, stops)` is applied at every state.
The answer is `dp[n]`.

The complexity is `O(n * t * 3)` where `t` is the number of templates.

