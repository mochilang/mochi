# SPIN - Spin

We model the puzzle as a bit string `S` of length `N` and a cursor `x` for the
position of the slide. Bit `i` is `1` when disk `i` (numbered from the left,
starting at `0`) is vertical and `0` when it is horizontal. The cursor satisfies
`0 ≤ x ≤ N` and indicates which disk lies above the `0` mark.

Valid moves are:

* Move the cursor left or right by one unit (cost `1`). Moving right from
  `x` requires disk `x` to be horizontal.
* Rotate disk `x` (flip bit `x`) – also cost `1` – but only when disk `x+1`
  is vertical (or `x = N-1`).

The goal position in this formulation is all disks horizontal (`S = 0`) with the
cursor at the leftmost position (`x = 0`). The original puzzle's “Win” mark is
one move further to the right, hence we add `1` at the end.

Let `d(N,S,x,Q0)` be the minimal number of moves to reach the goal from a state
with `N` disks, configuration bits `S`, cursor `x`, and where the target state’s
least significant bit is `Q0` (either `0` for all zeros or `1` for a single
trailing one). The following recursion solves the puzzle:

```
d(N,S,x,Q0):
  if N = 1:
    return x          if S = Q0
    return 3 - x      otherwise
  if (S & 1) = Q0:
    return 1 + d(N-1, S>>1, x-1, 0)
  else:
    return 2 + d(N-1, S>>1, x-1, 1) + d(N-1, 1, 0, 0)
```

We memoise results for tuples `(N,S,x,Q0)` to stay within the constraints
(`N < 30`). After converting the orientation string to `S`, the final answer is
`1 + d(N,S,x,0)`.
