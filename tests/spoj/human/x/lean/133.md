# [AB-words](https://www.spoj.com/problems/ABWORDS/)

## Problem Summary
We are given a set of *nice* ab-words, strings over `a` and `b` that contain an equal number of each letter and every prefix has at least as many `a`'s as `b`'s. Two nice words are considered similar through an inductive definition that allows stripping matching outer letters and splitting the word into two nice parts, where the parts may also be swapped. For each test case we must find the largest subset of the given words such that no two chosen words are similar.

## Algorithm
A nice ab-word encodes a rooted tree where `a` starts a node and the matching `b` closes it. The similarity relation corresponds exactly to isomorphism of these trees when the order of children is ignored. To compare words we therefore compute a canonical form of the tree representing each word:

1. Parse the word into a tree using a recursive descent: after reading an `a`, recursively parse successive children until the matching `b` is encountered.
2. For a node, recursively compute canonical strings for all children, sort them lexicographically and concatenate them between an outer `a` and `b`.
3. Two words are similar iff their canonical forms are equal. For each test case insert the canonical form of every word into a hash set and output the size of the set.

Each word has length at most 200 so sorting the child strings keeps the total time per word at `O(L log L)` and the memory usage small.
