# SUPPER - Supernumbers in a permutation

We are given a permutation of `n` (up to 100000) and must output all numbers
that belong to at least one longest increasing subsequence (LIS). Each test
case contains the value of `n` followed by a line with the permutation.

## Algorithm

1. **Forward LIS lengths** – iterate through the array and maintain `tails`,
   where `tails[k]` is the smallest possible tail of an increasing subsequence
   of length `k+1`. For each element `a[i]`, find the position `p` using
   binary search (lower bound) and update `tails[p]`. Store `L[i] = p+1`.
2. **Backward LIS lengths** – process the array from right to left using the
   same procedure but on negated values so that we effectively compute the LIS
   starting at each position. Store the results in `R[i]`.
3. The overall LIS length is `lis = max L[i]`. An element `a[i]` belongs to
   some LIS iff `L[i] + R[i] - 1 = lis`. Collect such elements and sort them.

## Correctness

- `L[i]` is the length of the longest increasing subsequence ending at `a[i]`.
- `R[i]` is the length of the longest increasing subsequence starting at `a[i]`.
- Any LIS that includes `a[i]` consists of a subsequence ending at `i` and a
  subsequence starting at `i`, overlapping on `a[i]`, so its length is
  `L[i] + R[i] - 1`. Therefore `a[i]` is a *supernumber* iff this equals `lis`.
- All such values are collected and output in increasing order.

## Complexity

Each LIS computation runs in `O(n log n)` time using binary search and arrays,
so a test case is processed in `O(n log n)` time and `O(n)` memory.
