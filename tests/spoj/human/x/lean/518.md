# Zig-Zag Permutation

The input gives a multiset of the letters `a`-`j` (in sorted order) and a number `D`.
For every test case we must list the lexicographically ordered zig‑zag permutations
whose rank is divisible by `D` and finally output the total number of zig‑zag
permutations.

A word is zig‑zag if adjacent comparisons alternate between `<` and `>`.
This happens when the relation between the last two letters is reversed by the
next letter added.

## Algorithm

1. Count how many of each letter (`a`–`j`) appears.
2. Recursively build permutations in lexicographic order. The recursion keeps the
   two previously placed letters so that a new letter can be appended only when
   it creates the alternating `<`/`>` pattern. Equal adjacent letters are not
   allowed.
3. Whenever a complete permutation is produced, increment a global rank. If the
   rank is divisible by `D`, record the permutation. The total number of zig‑zag
   permutations is simply the final rank.
4. After exploring the whole search tree, print the recorded permutations in the
   order they were generated followed by the total count and an empty line.

The search only explores valid zig‑zag prefixes, so the complexity is linear in
the number of zig‑zag permutations, which is small for the given constraints.
