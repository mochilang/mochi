# SWAPS - Counting inversions

[Problem link](https://www.spoj.com/problems/SWAPS/)

## Algorithm

We are given an array `A[1..N]` with `N ≤ 250000` and up to `M = 10000`
point updates.  After each update we have to output the number of inversions
in the sequence.  An inversion is a pair `(i, j)` such that `i < j` and
`A[i] > A[j]`.

### Data structure

The updates affect only pairs that involve the modified position.  We divide
the array into blocks of size `≈ √N` (computed as `⌊√N⌋ + 1`).  For each block
we keep its elements sorted.  This allows queries of the form

* number of elements before position `p` that are greater than `v` – obtained
  by scanning the block containing `p` and by binary searching in every full
  block to its left;
* number of elements after position `p` that are less than `v` – obtained by
  scanning the block containing `p` and binary searching all blocks to its
  right.

Each query therefore costs `O(√N log N)` time.

### Processing an update

When position `p` changes from `old` to `new` the inversion count changes only
by the pairs involving `p`.  We compute

```
oldGreater  = elements before p  greater than old
oldLess     = elements after  p  less    than old
newGreater  = elements before p  greater than new
newLess     = elements after  p  less    than new
```

and update the global inversion count as

```
inv = inv - oldGreater - oldLess + newGreater + newLess
```

Finally the block containing `p` is rebuilt (its slice is extracted from the
array and re-sorted).

### Initial inversion count

Before processing updates the initial number of inversions is computed using a
standard merge-sort based procedure which counts cross inversions while
merging (`O(N log N)`).

The overall complexity is `O((N + M) log N + M √N log N)` which is sufficient
for the given constraints.
