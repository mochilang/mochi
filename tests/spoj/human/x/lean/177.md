# [AB-words](https://www.spoj.com/problems/ABWORDS)

## Problem Summary
Given multiple test cases, each provides a set `S` of *nice* ab-words. A nice ab-word is a string over `a` and `b` with equal counts of `a` and `b` where every prefix has at least as many `a` as `b`.
Two nice ab-words are **similar** if they are both empty or if they have the same length and either
1. they begin with the same letter, end with the same letter and the middle parts are similar, or
2. they can be split into two nice subwords whose corresponding parts are similar, possibly after swapping the parts.
For each test case we must output the maximal size of a subset of `S` containing only pairwise non-similar words (the level of diversity of `S`).

## Algorithm
1. Treat each nice ab-word as a balanced-parentheses sequence where `a` is `(` and `b` is `)`.
2. Parse the word into a rooted tree: each matching `a`…`b` pair becomes a node whose children are the balanced subwords inside it.
3. To account for similarity rules, children of a node are considered unordered. For a node with child canonical strings `c₁ … cₖ`, sort these strings and concatenate them inside parentheses to form a canonical representation.
4. Traverse the word with a stack: push an empty child list on `a`; on `b`, pop the list, sort and combine as above, and append the result to the parent list.
5. After parsing a word, its canonical string uniquely represents its similarity class. Count distinct canonical strings across the set `S`.

The algorithm runs in time linear in the word length apart from sorting of child lists (bounded by the word length), which is efficient for the given constraints (`n ≤ 1000`, word length ≤ 200).

