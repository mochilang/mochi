# HOLIDAY2 - Getting Rid of the Holidays (Act II)

Given `n` holiday periods `t₁…tₙ` and an integer `k`, remove exactly `k` holidays so
that the remaining ones all occur on the same day of a new working rhythm.
If workers rest every `r` days, each kept holiday must recur only on days off,
so `r` must divide every remaining `tᵢ`.  Therefore we want to keep `n-k`
periods whose greatest common divisor is as large as possible.

## Algorithm

1. For every single period and for every pair of periods compute their gcd.
2. For each candidate gcd `g` count how many periods are divisible by `g`.
   If at least `n-k` periods are divisible by `g`, `g` is feasible.
3. Take the maximum feasible gcd `g*` and keep the first `n-k` periods
   divisible by `g*`; remove the rest.
4. Output the indices of the removed periods in increasing order.

The enumeration of all pairs gives at most `C(100,2)=4950` candidates, and
counting divisibility over all `n ≤ 100` periods keeps the complexity around
`O(n³)` which is easily within limits.

## Correctness

- Any valid rhythm length `r` must divide the gcd of the kept periods, so the
  optimal `r` equals the gcd of some subset of size `n-k`.
- The gcd of any subset is also the gcd of at least one pair from that subset,
  thus every optimal gcd appears among the candidates we test.
- We only choose a gcd when at least `n-k` periods are divisible by it, so we
  can always keep `n-k` periods whose gcd is a multiple of that candidate.
- Because we process candidates in increasing order, the final `g*` is the
  largest gcd achievable after removing exactly `k` periods, and the selected
  indices produce this gcd.

## Complexity

Let `n ≤ 100`.  We check `O(n²)` candidate gcds and, for each, count divisibility
across `n` elements.  Thus the total time is `O(n³)` and memory usage is `O(n)`.
