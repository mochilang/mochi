# The Easiest Problem

Link: https://www.spoj.com/problems/PT07B/

## Algorithm

A tree is **special** if every vertex of degree at least three has at most two
neighbours whose degree is also at least two.  Leaves never count towards this
limit.  To obtain the largest special subtree we may keep every vertex but we
can only keep the full subtrees of at most two children of any vertex; the
others may remain only as leaves.

1. Root the tree at a vertex with degree greater than one (or at `1` if the tree
   is a path).
2. Perform a DFS that computes for each vertex the maximal size of a special
   subtree of its descendants.  For every child we know the size of its best
   subtree.  Keeping a child as a leaf contributes `1` node, while keeping its
   subtree contributes `size[child]` nodes and consumes one of the available
   "heavy" child slots.
3. For each vertex, sort the gains `size[child] - 1` and keep the two largest
   when the vertex is the root and at most one otherwise.  Record which children
   are kept as heavy for reconstruction.
4. A second DFS outputs all edges of the chosen subtree: every child edge is
   printed, and we recurse only on the heavy children.

The first DFS is linear in the number of vertices and uses only the two largest
positive gains at each vertex.  The second DFS outputs exactly the edges of the
constructed subtree.
