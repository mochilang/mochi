/- Solution for SPOJ CARD - Cardsharper
https://www.spoj.com/problems/CARD/
-/
import Std
open Std

/-- Compose current permutation `p` with generator `g` (apply `g` after `p`). -/
def compose (p : List Nat) (g : Array Nat) : List Nat :=
  p.map (fun i => g.get! i)

/-- Breadth-first search of permutations generated by `A` and `B`. -/
partial def bfs (n : Nat) (A B : Array Nat) : HashMap (List Nat) (List Char) :=
  let start := List.range n
  let rec loop (queue : List (List Nat)) (vis : HashMap (List Nat) (List Char)) :
      HashMap (List Nat) (List Char) :=
    match queue with
    | [] => vis
    | p :: qs =>
      let path := vis.find! p
      let step :=
        fun (s : HashMap (List Nat) (List Char) × List (List Nat)) (op : Char × Array Nat) =>
          let (v, q) := s
          let (ch, g) := op
          let nxt := compose p g
          if v.contains nxt then (v, q)
          else (v.insert nxt (path ++ [ch]), q ++ [nxt])
      let (vis, qs) := [('A', A), ('B', B)].foldl step (vis, qs)
      loop qs vis
  loop [start] (HashMap.empty.insert start [])

/-- Convert a list of operations "A"/"B" into run-length encoding. -/
def encode (ops : List Char) : List Nat :=
  if ops.isEmpty then []
  else
    let rec countA (xs : List Char) : Nat × List Char :=
      match xs with
      | [] => (0, [])
      | 'A' :: t =>
        let (n, rest) := countA t
        (n + 1, rest)
      | _ => (0, xs)
    let (first, rest) := countA ops
    if rest.isEmpty then [first]
    else
      let rec run (curr : Char) (cnt : Nat) (xs : List Char) (acc : List Nat) : List Nat :=
        match xs with
        | [] => acc ++ [cnt]
        | h :: t =>
          if h = curr then run curr (cnt + 1) t acc
          else run h 1 t (acc ++ [cnt])
      run rest.head! 1 rest.tail! [first]

/-- Evaluate candidate `B` and return how many targets are reachable and the visited map. -/
def evaluate (n : Nat) (A B : Array Nat) (targets : List (List Nat)) :
    Nat × HashMap (List Nat) (List Char) :=
  let vis := bfs n A B
  let cnt := targets.foldl (fun c t => if vis.contains t then c + 1 else c) 0
  (cnt, vis)

/-- Parse a permutation from tokens starting at index `idx`. Returns permutation and new index. -/
def readPerm (tokens : Array String) (idx n : Nat) : List Nat × Nat :=
  let rec loop (i : Nat) (idx : Nat) (acc : List Nat) :=
    if i = n then (acc.reverse, idx)
    else
      let v := (tokens.get! idx).toNat!
      loop (i+1) (idx+1) ((v-1)::acc)
  loop 0 idx []

/-- Main entry point. -/
def main : IO Unit := do
  let data ← IO.readStdin
  let tokens := data.split (fun c => c = ' ' || c = '\n' || c = '\t' || c = '\r')
                |>.filter (fun s => s ≠ "")
                |> Array.ofList
  let mut idx := 0
  let n := (tokens.get! idx).toNat!
  idx := idx + 1
  let (alist, idx) := readPerm tokens idx n
  let A := Array.ofList alist
  let k := (tokens.get! idx).toNat!
  idx := idx + 1
  let rec readTargets (i : Nat) (idx : Nat) (acc : List (List Nat)) : List (List Nat) × Nat :=
    if i = 0 then (acc.reverse, idx)
    else
      let (p, idx') := readPerm tokens idx n
      readTargets (i-1) idx' (p :: acc)
  let (targets, idx) := readTargets k idx []
  let perms := List.permutations (List.range n)
  let mut bestB := A
  let mut bestCnt : Nat := 0
  let mut bestVis : HashMap (List Nat) (List Char) := HashMap.empty
  let mut first := true
  for blist in perms do
    let B := Array.ofList blist
    let (cnt, vis) := evaluate n A B targets
    if first || cnt > bestCnt then
      bestCnt := cnt
      bestB := B
      bestVis := vis
      first := false
  let lineB := String.intercalate " " (bestB.toList.map (fun x => toString (x+1)))
  IO.println lineB
  for t in targets do
    match bestVis.find? t with
    | none => IO.println "-1"
    | some ops =>
      let counts := encode ops
      if counts.isEmpty then
        IO.println "0"
      else
        let line := s!"{counts.length} " ++ String.intercalate " " (counts.map toString)
        IO.println line
