# [Voracious Steve](https://www.spoj.com/problems/STEVE)

## Problem Summary
Two players alternately take between 1 and `m` donuts from a box initially
holding `n` donuts. When a player empties the box he eats the donuts he has
collected; the opponent returns his donuts to the box and starts the next round
with that many donuts. Steve starts the game. Both players aim to maximise the
number of donuts they eat. Determine how many donuts Steve can guarantee to
consume.

## Algorithm
Let `f[i]` be the number of donuts the starting player can secure with `i`
donuts remaining. For `i > 0` let `q = i / (m+1)` and `r = i % (m+1)`. Define
`mx = max(f[k])` for `k` in `[q, q*m]` (or `0` if `q = 0`).

- If `r > 0`, the starter can win the round and eat `i - mx` donuts because the
  opponent will choose a move sequence leaving `k` donuts that maximises
  `f[k]`.
- If `r = 0`, the starter must lose and can choose how many donuts `k` remain
  for the next round; hence `f[i] = mx`.

Compute `f` iteratively from `1` to `n` using the above recurrence and output
`f[n]` for each test case.

## Complexity
For each test case the dynamic program processes up to `n â‰¤ 100` states and for
each examines at most `m` values, giving `O(nm)` time and `O(n)` memory.
