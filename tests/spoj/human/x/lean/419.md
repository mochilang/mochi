# Solution for SPOJ TRANSP - Transposing is Fun

Given a 2^a × 2^b array stored sequentially, we seek the minimal number of swaps
needed to transpose it in place. Indexing in row-major order, transposition
corresponds to rotating the binary representation of each index by `a` bits.

## Algorithm

1. Let `g = gcd(a, b)`. Set `a0 = a / g`, `b0 = b / g`, and `m0 = a0 + b0`.
2. Using Burnside's lemma, the number of cycles in the permutation equals
   `cycles = (1/m0) * Σ_{d | m0} φ(m0 / d) * 2^{g * d}`, where `φ` is Euler's
   totient.
3. The minimal number of swaps is `2^{a+b} - cycles`.
4. All computations are done modulo `1_000_003` using fast exponentiation and
   modular inverses.

## Correctness

- Rotation by `a` bits describes exactly how indices move under transposition; the
  orbits of this rotation correspond to cycles of the permutation.
- Burnside's lemma counts these orbits by summing fixed strings under each power
  of the rotation. Subtracting the number of cycles from the total elements gives
  the minimal swaps.

## Complexity

Let `n = a + b` (≤ 500000). Factoring `m0 = a0 + b0` and iterating over its
divisors costs `O(sqrt(m0))`. Each term uses logarithmic-time exponentiation,
so the algorithm easily handles up to 100 test cases within limits.
