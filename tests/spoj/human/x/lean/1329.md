# KPMATRIX - Matrix

Given an `N × M` matrix (both up to 250) and numbers `A` and `B`, count the
submatrices whose sum of elements lies in `[A, B]`.

## Algorithm

1. Iterate over all pairs of top and bottom rows. There are `O(N²)` such pairs.
2. For each pair we accumulate column sums, turning the 2‑D problem into a
   1‑D array `col` of length `M` that stores sums of elements between the chosen
   rows for every column.
3. Count subarrays of `col` with sum in `[A, B]`:
   - Build prefix sums of `col`.
   - Coordinate-compress the prefix sums and maintain a Fenwick tree of counts
     of prefix sums seen so far.
   - For each prefix `s` the number of valid subarrays ending at this position
     equals `count(≤ s − A) − count(≤ s − B − 1)`.
   - Insert `s` into the Fenwick tree and continue.
4. Accumulate results over all row pairs.

## Correctness

- Every submatrix can be uniquely represented by choosing its top and bottom
  rows and a contiguous segment of columns. Step 1 enumerates all possible row
  pairs, and Step 2 converts the elements between them into an array `col` whose
  subarrays correspond exactly to submatrices with those row boundaries.
- For a fixed `col`, any subarray sum equals the difference of two prefix sums.
  The Fenwick tree in Step 3 stores counts of previously seen prefix sums. For a
  current prefix `s`, any earlier prefix `t` with `s − t ∈ [A, B]` produces a
  valid subarray. The query `count(≤ s − A) − count(≤ s − B − 1)` counts exactly
  those `t`, so every valid subarray is counted once.
- Therefore, all submatrices with sum in `[A, B]` are counted exactly once and
  no others are counted.

## Complexity Analysis

- There are `O(N²)` row pairs. For each, counting subarrays with the Fenwick
  tree takes `O(M log M)` time. Hence the total complexity is
  `O(N² · M log M)` which is at most about `250² · 250 · log 250` operations.
- Additional memory used is `O(M)` for the column sums and Fenwick tree.

