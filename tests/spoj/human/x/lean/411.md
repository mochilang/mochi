# NUMQDW - Number of quite different words

We must count the words of length `n` over the first `c` capital letters that
have no common subsequence of length ≥ 2 with a given word `w`.
Two words share a subsequence `xy` of length 2 iff letter `x` appears in `w`
before letter `y`.

## Algorithm
1. Scan `w` once while maintaining a bitmask `seen` of letters encountered so
   far. For each occurrence of letter `y` add `seen` to `pred[y]`.  `pred[y]`
   therefore contains all letters that appear before `y` in `w` (including `y`
   itself if it occurs more than once).
2. Consider every subset `S` of the `c` letters as a state, meaning the set of
   letters that already occurred in the constructed word.  From state `S` we may
   append letter `y` only if no letter from `pred[y]` is contained in `S`.
   Repeating a letter is allowed when it has no self–precedence.
3. These transitions form a `2^c × 2^c` matrix `T`.  Starting from the empty
   set we need the sum of all entries of `e₀·Tⁿ`, so we perform fast exponent-
   iation on this matrix while multiplying an initial vector on the left.
4. Sum the resulting vector and output it modulo `4242`.

`c ≤ 6` gives at most `64` states, so matrix exponentiation is easily fast
enough even for very large `n`.

## Correctness
- `pred[y]` contains exactly those letters that appear before `y` in `w`.  If a
  letter from `pred[y]` already occurred in the constructed word, appending `y`
  would create a common subsequence of length 2, hence such transitions are
  forbidden.
- A self–loop arises when `y` occurs at least twice in `w`; `pred[y]` then
  contains `y` itself which disables choosing `y` again.
- Any valid word corresponds to a path in the transition graph that respects
  the above rule, therefore the number of words of length `n` equals the number
  of paths of length `n` starting at the empty state.  The matrix exponentiation
  computes exactly this count.

## Complexity
Let `N = 2^c` (≤ 64).  Matrix multiplication is `O(N³)` and exponentiation uses
`O(log n)` multiplications, so the total complexity is `O(N³ log n)` time and
`O(N²)` memory.
