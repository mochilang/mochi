# SPOJ FTOUR2 - Free tour II

The `N` places form a tree. Each node may be "crowded" and each edge has an
interest value (which can be negative). We must choose a path whose total
interest is maximized while visiting at most `K` crowded places.

For every node we compute dynamic programming states representing the best
interest of a downward path starting from that node.  `best[j]` stores the
maximum sum of edge weights for a path that begins at the node and goes into its
subtree visiting exactly `j` crowded places in total.

Processing is done with a depth‑first search:

1. Initialize `best` for the current node depending on whether it is crowded.
2. For every child, first compute its DP table recursively.
3. Update the global answer by combining the child's table with the current
   `best` table: every pair of states `(i,j)` such that `i + j ≤ K` yields a
   candidate path going through the current node, `best[i] + child[j] + w`.
4. Merge the child's table into `best` to allow paths that go from the current
   node down through that child.

This DP enumerates all distributions of the allowed number of crowded nodes
across subtrees, so every valid path is considered.  The complexity is roughly
`O(N * K^2)` which is sufficient for small `K` and the provided sample.
