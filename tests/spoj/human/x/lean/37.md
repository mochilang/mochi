# PROPKEY - The Proper Key

We are given a 2D key and a wooden lock.  The key may slide left or right and
fall down; it cannot be rotated.  We must compute the deepest position (measured
from the top of the lock to the bottom of the key) that the key can reach without
overlapping any wooden square in the lock.  If the key can move completely
through the lock, we state that it can fall through.

## Algorithm

We model the movement of the key on a grid.  The key has height `R` and width
`C` and is represented by the coordinates of its wooden squares.  The lock is a
`D × W` grid of wooden and empty cells.

For every horizontal position `x` in `[0, W − C]` we consider the starting state
with the key above the lock.  We perform a breadth‑first search over states
`(x, y)` where `x` is the horizontal offset and `y` is the depth of the key’s
bottom edge.  From each state we may move:

- left or right if the key remains inside the lock width and does not collide,
- down by one unit if moving down does not cause a collision.

Collision checking is done by testing all wooden squares of the key against the
lock grid.  We use a visited table to avoid revisiting states.  During the BFS we
track the maximum `y` reached.  If we ever reach a state with `y ≥ D + R`, then
all of the key lies below the lock and it can fall through.

## Complexity

Let `W` be the lock width and `D` the depth.  The BFS explores at most
`(W − C + 1) × (D + R + 1)` states and each transition checks at most `R × C`
key squares, giving a worst‑case complexity of `O(W D R C)` which satisfies the
problem limits.
