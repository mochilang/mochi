# Window (SPOJ WINDOW1)

## Algorithm

We are given a simple orthogonal polygon (edges parallel to axes) and an axis-aligned rectangle
(window). We need to count the number of connected components of the polygon's interior visible
through the window.

For every horizontal unit strip of the window we look at the line in the middle of the strip and
compute all intersection points with vertical edges of the polygon. The intersections come in pairs,
forming horizontal segments that lie inside the polygon. Each such segment is clipped to the
window's horizontal range. Segments with non‑zero length represent portions of the polygon visible
at that strip of the window.

To determine connected components we build a disjoint set of all segments. Two segments from
consecutive strips are connected if their horizontal intervals overlap. After processing all pairs of
neighbouring strips the number of different roots in the disjoint set is exactly the number of
visible fragments.

## Correctness

- A horizontal line intersects the interior of an orthogonal polygon in disjoint intervals bounded
  by consecutive intersections with vertical edges. Pairing the sorted intersection x-coordinates
  therefore yields all maximal horizontal segments lying inside the polygon at that height.
- A point inside the window belongs to the polygon's interior if and only if it lies on one of the
  segments computed for its strip. Thus the union of all segments over the strips equals the
  intersection of the polygon's interior with the window.
- Two points in different strips are connected through the interior if and only if the corresponding
  segments in neighbouring strips overlap horizontally. The union–find structure merges exactly such
  overlapping segments, so each connected component of the intersection is represented by a single
  disjoint-set root.
- Consequently, counting the distinct roots after processing all strips returns the exact number of
  connected components of the polygon visible through the window.

## Complexity Analysis

Let `H = y1 - y2` be the window's height and `n` the number of polygon vertices. For each of the `H`
rows we scan all `n` edges to collect intersections and sort them, yielding a running time of
`O(H * (n + k log k))` where `k` is the number of intersections in a row (at most `n`). The union
step processes each segment at most once, giving an additional `O(m α(m))` time where `m` is the
number of segments and `α` the inverse Ackermann function. Memory usage is `O(m)`.

## Reference

- [SPOJ - WINDOW1](https://www.spoj.com/problems/WINDOW1/)
