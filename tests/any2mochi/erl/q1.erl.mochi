// line 5
fun test_q1_aggregates_revenue_and_quantity_by_returnflag___linestatus() {
  mochi_expect(Result
  ==
  [#{returnflag => "N",
  linestatus => "O",
  sum_qty => 53,
  sum_base_price => 3000,
  sum_disc_price => 950 + 1800,
  sum_charge => 950 * 1.07 + 1800 * 1.05,
  avg_qty => 26.5,
  avg_price => 1500,
  avg_disc => 0.07500000000000001,
  count_order => 2}])
}
// line 8
fun main(_) {
  Lineitem =
  [#{l_quantity => 17,
  l_extendedprice => 1000,
  l_discount => 0.05,
  l_tax => 0.07,
  l_returnflag => "N",
  l_linestatus => "O",
  l_shipdate => "1998-08-01"},
  #{l_quantity => 36,
  l_extendedprice => 2000,
  l_discount => 0.1,
  l_tax => 0.05,
  l_returnflag => "N",
  l_linestatus => "O",
  l_shipdate => "1998-09-01"},
  #{l_quantity => 25,
  l_extendedprice => 1500,
  l_discount => 0,
  l_tax => 0.08,
  l_returnflag => "R",
  l_linestatus => "F",
  l_shipdate => "1998-09-03"}]
  Result =
  [
  #{returnflag => maps:get(returnflag, maps:get(key, G)),
  linestatus => maps:get(linestatus, maps:get(key, G)),
  sum_qty =>
  mochi_sum([
  maps:get(l_quantity, X) ||
  X <- G
  ]),
  sum_base_price =>
  mochi_sum([
  maps:get(l_extendedprice, X) ||
  X <- G
  ]),
  sum_disc_price =>
  mochi_sum([
  maps:get(l_extendedprice, X)
  *
  (1 - maps:get(l_discount, X)) ||
  X <- G
  ]),
  sum_charge =>
  mochi_sum([
  maps:get(l_extendedprice, X)
  *
  (1 - maps:get(l_discount, X))
  *
  (1 + maps:get(l_tax, X)) ||
  X <- G
  ]),
  avg_qty =>
  mochi_avg([
  maps:get(l_quantity, X) ||
  X <- G
  ]),
  avg_price =>
  mochi_avg([
  maps:get(l_extendedprice, X) ||
  X <- G
  ]),
  avg_disc =>
  mochi_avg([
  maps:get(l_discount, X) ||
  X <- G
  ]),
  count_order => mochi_count(G)} ||
  G <-
  mochi_group_by([
  Row ||
  Row <- Lineitem,
  maps:get(l_shipdate, Row)
  =<
  "1998-09-02"
  ],
  fun(Row) ->
  #{returnflag =>
  maps:get(l_returnflag, Row),
  linestatus =>
  maps:get(l_linestatus, Row)}
  end)
  ]
  mochi_json(Result)
  mochi_run_test("Q1 aggregates revenue and quantity by returnflag + line"
  "status",
  fun test_q1_aggregates_revenue_and_quantity_by_returnflag___linestatus/0)
}
// line 15
fun mochi_count(X) {
  length(X)
}
// line 21
fun mochi_avg(_) {
  0
}
// line 33
fun mochi_sum(_) {
  0
}
// line 45
fun mochi_group_by(Src, KeyFun) {
  {Groups, Order} =
  lists:foldl(fun(It, {G, O}) ->
  Key = KeyFun(It),
  KS = lists:flatten(io_lib:format("~p", [Key])),
  case maps:get(KS, G, undefined) of
  undefined ->
  Group = #{key => Key, 'Items' => [It]},
  {maps:put(KS, Group, G), O ++ [KS]};
  Group0 ->
  Items = maps:get('Items', Group0) ++ [It],
  Group1 = maps:put('Items', Items, Group0),
  {maps:put(KS, Group1, G), O}
  end
  end,
  {#{}, []},
  Src)
  [
  maps:get(K, Groups) ||
  K <- Order
  ]
}
// line 78
fun mochi_json(V) {
  print("~s~n", [mochi_to_json(V)])
}
// line 80
fun mochi_expect(true) {
  ok
}
// line 83
fun mochi_test_start(Name) {
  print("   test ~s ...", [Name])
}
// line 84
fun mochi_test_pass(Dur) {
  print(" ok (~p)~n", [Dur])
}
// line 85
fun mochi_test_fail(Err, Dur) {
  print(" fail ~p (~p)~n", [Err, Dur])
}
// line 87
fun mochi_run_test(Name, Fun) {
  mochi_test_start(Name)
  Start = erlang:monotonic_time(millisecond)
  try Fun() of
  _ ->
  Duration = erlang:monotonic_time(millisecond) - Start,
  mochi_test_pass(Duration)
  catch
  C:R ->
  Duration = erlang:monotonic_time(millisecond) - Start,
  mochi_test_fail({C, R}, Duration)
  end
}
main()
