// line 5
fun main(_) {
  Xs = [1, 1, 2]
  Groups =
  [
  #{k => maps:get(key, G), c => mochi_count(G)} ||
  G <-
  mochi_group_by(Xs,
  fun(X) ->
  X
  end)
  ]
  mochi_foreach(fun(G) ->
  mochi_print([maps:get(k, G), maps:get(c, G)])
  end,
  Groups)
}
// line 12
fun mochi_print(Args) {
  Strs =
  [
  mochi_format(A) ||
  A <- Args
  ]
  print("~s~n", [lists:flatten(Strs)])
}
// line 16
fun mochi_format(X) {
  integer_to_list(X)
}
// line 21
fun mochi_count(X) {
  length(X)
}
// line 27
fun mochi_foreach(F, L) {
  try
  mochi_foreach_loop(F, L)
  catch
  throw:mochi_break ->
  ok
  end
}
// line 30
fun mochi_foreach_loop(_, _) {
  ok
}
// line 38
fun mochi_group_by(Src, KeyFun) {
  {Groups, Order} =
  lists:foldl(fun(It, {G, O}) ->
  Key = KeyFun(It),
  KS = lists:flatten(io_lib:format("~p", [Key])),
  case maps:get(KS, G, undefined) of
  undefined ->
  Group = #{key => Key, 'Items' => [It]},
  {maps:put(KS, Group, G), O ++ [KS]};
  Group0 ->
  Items = maps:get('Items', Group0) ++ [It],
  Group1 = maps:put('Items', Items, Group0),
  {maps:put(KS, Group1, G), O}
  end
  end,
  {#{}, []},
  Src)
  [
  maps:get(K, Groups) ||
  K <- Order
  ]
}
main()
