fun test_Q1_aggregates_revenue_and_quantity_by_returnflag___linestatus() {
  expect((result = = scala.collection.mutable.ArrayBuffer(scala.collection.mutable.Map("returnflag" -> "N", "linestatus" -> "O", "sum_qty" -> 53, "sum_base_price" -> 3000, "sum_disc_price" -> (950 + 1800), "sum_charge" -> (((950 * 1.07)) + ((1800 * 1.05))), "avg_qty" -> 26.5, "avg_price" -> 1500, "avg_disc" -> 0.07500000000000001, "count_order" -> 2))))
}
let lineitem = [scala.collection.mutable.Map("l_quantity" -> 17, "l_extendedprice" -> 1000, "l_discount" -> 0.05, "l_tax" -> 0.07, "l_returnflag" -> "N", "l_linestatus" -> "O", "l_shipdate" -> "1998-08-01"), scala.collection.mutable.Map("l_quantity" -> 36, "l_extendedprice" -> 2000, "l_discount" -> 0.1, "l_tax" -> 0.05, "l_returnflag" -> "N", "l_linestatus" -> "O", "l_shipdate" -> "1998-09-01"), scala.collection.mutable.Map("l_quantity" -> 25, "l_extendedprice" -> 1500, "l_discount" -> 0, "l_tax" -> 0.08, "l_returnflag" -> "R", "l_linestatus" -> "F", "l_shipdate" -> "1998-09-03")]
let result = _group_by((() => {
let src = lineitem
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let row = args(0)
}), "where" -> ((args: Seq[Any]) = > {
let row = args(0)
(row.l_shipdate < = "1998-09-02")
})(), (row: Any) = > scala.collection.mutable.Map("returnflag" -> row.l_returnflag, "linestatus" -> row.l_linestatus)).map(g => scala.collection.mutable.Map("returnflag" -> g.key.returnflag, "linestatus" -> g.key.linestatus, "sum_qty" -> sum((() => {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)
})()), "sum_base_price" -> sum((() = > {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)
})()), "sum_disc_price" -> sum((() = > {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)
})()), "sum_charge" -> sum((() = > {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)
})()), "avg_qty" -> ((() = > {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)
})().sum / (() = > {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)
})().size), "avg_price" -> ((() = > {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)
})().sum / (() = > {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)
})().size), "avg_disc" -> ((() = > {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)
})().sum / (() = > {
let src = g
let res = _query(src, Seq(
), Map("select" -> ((args: Seq[Any]) = > {
let x = args(0)

fun expect(cond) {
}
fun _group_by(src, keyfn) {
  let groups = scala.collection.mutable.LinkedHashMap[String,_Group]()
  for it in src {
    let key = keyfn(it)
    let ks = key.toString
    let g = groups.getOrElseUpdate(ks, new _Group(key))
    append(g.Items, it)
  }
}
fun _json(v) {
  print(_to_json(v))
}
fun _query(src, joins, Any]], opts, Any]) {
  var items = src.map(v => Seq[Any](v))
  for j in joins {
    let joined = scala.collection.mutable.ArrayBuffer[Seq[Any]]()
    let jitems = j("items").asInstanceOf[Seq[Any]]
    let on = j.get("on").map(_.asInstanceOf[Seq[Any] => Boolean])
    let left = j.get("left").exists(_.asInstanceOf[Boolean])
    let right = j.get("right").exists(_.asInstanceOf[Boolean])
    if left && right {
      let matched = Array.fill(jitems.length)(false)
      for leftRow in items {
        var m = false
        for (rightRow, ri) in jitems.zipWithIndex {
          var keep = true
          if (on.isDefined) keep = on.get(leftRow :+ rightRow)
          if keep {
          }
          append(if (!m) joined, leftRow :+ null)
        }
        for (rightRow, ri) in jitems.zipWithIndex {
          if !matched(ri) {
            let undef = if (items.nonEmpty) Seq.fill(items.head.length)(null) else Seq[Any]()
            append(joined, undef :+ rightRow)
          }
        }
      else if right {
        for rightRow in jitems {
          var m = false
          for leftRow in items {
            var keep = true
            if (on.isDefined) keep = on.get(leftRow :+ rightRow)
            if keep {
            }
            if !m {
              let undef = if (items.nonEmpty) Seq.fill(items.head.length)(null) else Seq[Any]()
              append(joined, undef :+ rightRow)
            }
          }
        else {
          for leftRow in items {
            var m = false
            for rightRow in jitems {
              var keep = true
              if (on.isDefined) keep = on.get(leftRow :+ rightRow)
              if keep {
              }
              append(if (left && !m) joined, leftRow :+ null)
            }
          }
          items = joined.toSeq
        }
        var it = items
        opts.get("where").foreach { f = >
        let fn = f.asInstanceOf[Seq[Any] => Boolean]
        it = it.filter(r => fn(r))
      }
      opts.get("sortKey").foreach { f = >
      let fn = f.asInstanceOf[Seq[Any] => Any]
      it = it.sortBy(r => fn(r))(_anyOrdering)
    }
    opts.get("skip").foreach { n = > it = it.drop(n.asInstanceOf[Int]) }
    opts.get("take").foreach { n = > it = it.take(n.asInstanceOf[Int]) }
    let sel = opts("select").asInstanceOf[Seq[Any] => Any]
    it.map(r = > sel(r))
}
fun _to_json(v) {
  match v {
}
