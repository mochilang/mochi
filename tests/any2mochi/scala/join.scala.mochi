let customers = [Customer(id = 1, name = "Alice"), Customer(id = 2, name = "Bob"), Customer(id = 3, name = "Charlie")]
let orders = [Order(id = 100, customerId = 1, total = 250), Order(id = 101, customerId = 2, total = 125), Order(id = 102, customerId = 1, total = 300), Order(id = 103, customerId = 4, total = 80)]
let result = (() => {
let src = orders
let res = _query(src, Seq(
Map("items" -> customers, "on" -> ((args: Seq[Any]) = > {
let o = args(0)
let c = args(1)
(o.customerId = = c.id)
), Map("select" -> ((args: Seq[Any]) = > {
let o = args(0)
let c = args(1)
PairInfo(orderId = o.id, customerName = c.name, total = o.total)
print("--- Orders with customer info ---")
let it1 = result.iterator
while it1.hasNext {
  let entry = it1.next()
  print("Order", entry.orderId, "by", entry.customerName, "- $", entry.total)
}

fun _query(src, joins, Any]], opts, Any]) {
  var items = src.map(v => Seq[Any](v))
  for j in joins {
    let joined = scala.collection.mutable.ArrayBuffer[Seq[Any]]()
    let jitems = j("items").asInstanceOf[Seq[Any]]
    let on = j.get("on").map(_.asInstanceOf[Seq[Any] => Boolean])
    let left = j.get("left").exists(_.asInstanceOf[Boolean])
    let right = j.get("right").exists(_.asInstanceOf[Boolean])
    if left && right {
      let matched = Array.fill(jitems.length)(false)
      for leftRow in items {
        var m = false
        for (rightRow, ri) in jitems.zipWithIndex {
          var keep = true
          if (on.isDefined) keep = on.get(leftRow :+ rightRow)
          if keep {
          }
          append(if (!m) joined, leftRow :+ null)
        }
        for (rightRow, ri) in jitems.zipWithIndex {
          if !matched(ri) {
            let undef = if (items.nonEmpty) Seq.fill(items.head.length)(null) else Seq[Any]()
            append(joined, undef :+ rightRow)
          }
        }
      else if right {
        for rightRow in jitems {
          var m = false
          for leftRow in items {
            var keep = true
            if (on.isDefined) keep = on.get(leftRow :+ rightRow)
            if keep {
            }
            if !m {
              let undef = if (items.nonEmpty) Seq.fill(items.head.length)(null) else Seq[Any]()
              append(joined, undef :+ rightRow)
            }
          }
        else {
          for leftRow in items {
            var m = false
            for rightRow in jitems {
              var keep = true
              if (on.isDefined) keep = on.get(leftRow :+ rightRow)
              if keep {
              }
              append(if (left && !m) joined, leftRow :+ null)
            }
          }
          items = joined.toSeq
        }
        var it = items
        opts.get("where").foreach { f = >
        let fn = f.asInstanceOf[Seq[Any] => Boolean]
        it = it.filter(r => fn(r))
      }
      opts.get("sortKey").foreach { f = >
      let fn = f.asInstanceOf[Seq[Any] => Any]
      it = it.sortBy(r => fn(r))(_anyOrdering)
    }
    opts.get("skip").foreach { n = > it = it.drop(n.asInstanceOf[Int]) }
    opts.get("take").foreach { n = > it = it.take(n.asInstanceOf[Int]) }
    let sel = opts("select").asInstanceOf[Seq[Any] => Any]
    it.map(r = > sel(r))
}
