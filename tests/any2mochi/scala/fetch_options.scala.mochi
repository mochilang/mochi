let resp = _fetch("https://example.com", scala.collection.mutable.Map("method" -> "POST", "headers" -> scala.collection.mutable.Map("Content-Type" -> "application/json"), "query" -> scala.collection.mutable.Map("q" -> "test"), "body" -> scala.collection.mutable.Map("x" -> 1), "timeout" -> 5))
print(resp)

fun _fetch(url, opts, Any]) {
  var u = url
  if opts != null && opts.contains("query") {
    let q = opts("query").asInstanceOf[scala.collection.Map[String, Any]]
    let qs = q.map { case (k, v) =>
    URLEncoder.encode(k, "UTF-8") + " = " + URLEncoder.encode(String.valueOf(v), "UTF-8")
    let sep = if (u.contains("?")) "&" else "?"
    u = u + sep + qs
  }
  let conn = new URL(u).openConnection().asInstanceOf[HttpURLConnection]
  var method = "GET"
  if opts != null && opts.contains("method") {
    method = opts("method").toString
  }
  if opts != null && opts.contains("headers") {
    let hs = opts("headers").asInstanceOf[scala.collection.Map[String, Any]]
    hs.foreach { case (k, v) = > conn.setRequestProperty(k, v.toString) }
  }
  if opts != null && opts.contains("timeout") {
    let t = opts("timeout") match {
    case i: Int = > i.toDouble
    case l: Long = > l.toDouble
    case f: Float = > f.toDouble
    case d: Double = > d
    case other = > other.toString.toDouble
  }
  let ms = (t * 1000).toInt
}
if opts != null && opts.contains("body") {
  let data = _to_json(opts("body"))
  let w = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream))
}
let src = scala.io.Source.fromInputStream(conn.getInputStream)
let data = src.mkString
}
