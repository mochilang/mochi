# Generated by Mochi C# compiler
type Person {
  name: string
  age: int
  email: string
}
type Program {
}
fun Program.Main() {
  var people = _load("people.json", new Dictionary<string, string> { { "format", "json" } }).Select(e => _cast<Person>(e)).ToList()
  Dictionary<string, string>[] adults = new List<Dictionary<string, dynamic>>(people.Select(p => new Dictionary<string, dynamic> { { "name", p.name }, { "email", p.email } }))
  for a in adults {
  print(string.Join(" ", new [] { Convert.ToString(a.name), Convert.ToString(a.email) }))
  }
}
fun Program._load(path: string, Dictionary<string, opts): list<any> {
  var format = opts != null && opts.ContainsKey("format") ? Convert.ToString(opts["format"]) : "csv"
  var header = opts != null && opts.ContainsKey("header") ? Convert.ToBoolean(opts["header"]) : true
  var delim = opts != null && opts.ContainsKey("delimiter") ? Convert.ToString(opts["delimiter"])[0] : ','
  var text
  if string.IsNullOrEmpty(path) || path == "-" {
  text = Console.In.ReadToEnd()
  } else {
  text = File.ReadAllText(path)
  }
  switch (format) {
  case "jsonl":
  var list = new List<dynamic>()
  for line in text.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)) list.Add(JsonSerializer.Deserialize<dynamic>(line)) {
  return list
  case "json":
  return JsonSerializer.Deserialize<List<dynamic>>(text)
  case "yaml":
  var deser = new DeserializerBuilder().Build()
  var obj = deser.Deserialize<object>(new StringReader(text))
  if obj is IList<object> lst) return lst.Cast<dynamic>().ToList() {
  if obj is IDictionary<object, object> m {
  var d = new Dictionary<string, object>()
  for kv in m) d[Convert.ToString(kv.Key)] = kv.Value {
  return new List<dynamic> { d }
  }
  return new List<dynamic>()
  case "tsv":
  delim = '    '; goto default
  default:
  var lines = text.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
  var out = new List<dynamic>()
  var headers = null
  for int i in 0..lines.Length {
  var parts = lines[i].Split(delim)
  if i == 0 && header) { headers = parts; continue; } {
  var obj = new Dictionary<string, object>()
  for int j in 0..parts.Length {
  var key = headers != null && j < headers.Length ? headers[j] : $"col{j}"
  obj[key] = parts[j]
  }
  out.Add(obj)
  }
  return out
  }
}
fun Program._cast(v: any) {
  if v is T tv) return tv {
  if typeof(T) == typeof(int) {
  if v is int) return (T)v {
  if v is double) return (T)(object)(int)(double)v {
  if v is float) return (T)(object)(int)(float)v {
  }
  if typeof(T) == typeof(double) {
  if v is int) return (T)(object)(double)(int)v {
  if v is double) return (T)v {
  if v is float) return (T)(object)(double)(float)v {
  }
  if typeof(T) == typeof(float) {
  if v is int) return (T)(object)(float)(int)v {
  if v is double) return (T)(object)(float)(double)v {
  if v is float) return (T)v {
  }
  if typeof(T).IsGenericType && typeof(T).GetGenericTypeDefinition() == typeof(Dictionary<,>) && v is System.Collections.IDictionary d {
  var args = typeof(T).GetGenericArguments()
  var res = (System.Collections.IDictionary)Activator.CreateInstance(typeof(Dictionary<,>).MakeGenericType(args))
  var mCast = typeof(Program).GetMethod("_cast")
  for kv in d {
  var k = mCast.MakeGenericMethod(args[0]).Invoke(null, new object[]{kv.Key})
  var val = mCast.MakeGenericMethod(args[1]).Invoke(null, new object[]{kv.Value})
  res.Add(k, val)
  }
  return (T)res
  }
  if v is System.Collections.Generic.IDictionary<object, object> dm {
  var m = new Dictionary<string, object>()
  for kv in dm) m[Convert.ToString(kv.Key)] = kv.Value {
  v = m
  }
  var json = JsonSerializer.Serialize(v)
  return JsonSerializer.Deserialize<T>(json)
}
