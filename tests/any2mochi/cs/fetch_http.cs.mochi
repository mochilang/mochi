# Generated by Mochi C# compiler
type Todo {
  userId: int
  id: int
  title: string
  completed: bool
}
type Program {
}
fun Program.Main() {
  var todo = _cast<Todo>(_fetch("https://jsonplaceholder.typicode.com/todos/1", null))
  print(todo.title)
}
fun Program._cast(v: any) {
  if v is T tv) return tv {
  if typeof(T) == typeof(int) {
  if v is int) return (T)v {
  if v is double) return (T)(object)(int)(double)v {
  if v is float) return (T)(object)(int)(float)v {
  }
  if typeof(T) == typeof(double) {
  if v is int) return (T)(object)(double)(int)v {
  if v is double) return (T)v {
  if v is float) return (T)(object)(double)(float)v {
  }
  if typeof(T) == typeof(float) {
  if v is int) return (T)(object)(float)(int)v {
  if v is double) return (T)(object)(float)(double)v {
  if v is float) return (T)v {
  }
  if typeof(T).IsGenericType && typeof(T).GetGenericTypeDefinition() == typeof(Dictionary<,>) && v is System.Collections.IDictionary d {
  var args = typeof(T).GetGenericArguments()
  var res = (System.Collections.IDictionary)Activator.CreateInstance(typeof(Dictionary<,>).MakeGenericType(args))
  var mCast = typeof(Program).GetMethod("_cast")
  for kv in d {
  var k = mCast.MakeGenericMethod(args[0]).Invoke(null, new object[]{kv.Key})
  var val = mCast.MakeGenericMethod(args[1]).Invoke(null, new object[]{kv.Value})
  res.Add(k, val)
  }
  return (T)res
  }
  if v is System.Collections.Generic.IDictionary<object, object> dm {
  var m = new Dictionary<string, object>()
  for kv in dm) m[Convert.ToString(kv.Key)] = kv.Value {
  v = m
  }
  var json = JsonSerializer.Serialize(v)
  return JsonSerializer.Deserialize<T>(json)
}
fun Program._fetch(url: string, Dictionary<string, opts): any {
  var method = "GET"
  if opts != null && opts.ContainsKey("method")) method = Convert.ToString(opts["method"]) {
  var query = opts != null && opts.ContainsKey("query") ? opts["query"] as Dictionary<string, object> : null
  if query != null {
  var qs = System.Web.HttpUtility.ParseQueryString("")
  for kv in query) qs[kv.Key] = Convert.ToString(kv.Value) {
  var sep = url.Contains('?') ? '&' : '?'
  url = url + sep + qs.ToString()
  }
  var req = new HttpRequestMessage(new HttpMethod(method), url)
  if opts != null && opts.ContainsKey("headers") {
  var hs = opts["headers"] as Dictionary<string, object>
  if hs != null) foreach (var kv in hs) req.Headers.TryAddWithoutValidation(kv.Key, Convert.ToString(kv.Value)) {
  }
  if opts != null && opts.ContainsKey("body") {
  var data = JsonSerializer.Serialize(opts["body"])
  req.Content = new StringContent(data, System.Text.Encoding.UTF8, "application/json")
  }
  var client = new HttpClient()
  if opts != null && opts.ContainsKey("timeout") {
  var t = Convert.ToDouble(opts["timeout"])
  client.Timeout = TimeSpan.FromSeconds(t)
  }
  var resp = client.Send(req)
  var text = resp.Content.ReadAsStringAsync().Result
  return JsonSerializer.Deserialize<dynamic>(text)
}
