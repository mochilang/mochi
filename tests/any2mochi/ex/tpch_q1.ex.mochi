fun main() {
  let lineitem = [%{l_quantity: 17, l_extendedprice: 1000, l_discount: 0.05, l_tax: 0.07, l_returnflag: "N", l_linestatus: "O", l_shipdate: "1998-08-01"}, %{l_quantity: 36, l_extendedprice: 2000, l_discount: 0.1, l_tax: 0.05, l_returnflag: "N", l_linestatus: "O", l_shipdate: "1998-09-01"}, %{l_quantity: 25, l_extendedprice: 1500, l_discount: 0, l_tax: 0.08, l_returnflag: "R", l_linestatus: "F", l_shipdate: "1998-09-03"}]
  let result = (fn ->
  let _src = lineitem
  let _rows = _query(_src, [
  let ], %{select: fn row -> [row] end, where: fn row -> (row.l_shipdate < = "1998-09-02") end })
  let _groups = _group_by(_rows, fn row -> %{returnflag: row.l_returnflag, linestatus: row.l_linestatus} end)
  let _groups = Enum.map(_groups, fn g -> %{g | Items: Enum.map(g.Items, fn [row] -> row end)} end)
  let items = _groups
  Enum.map(items, fn g -> %{returnflag: g.key.returnflag, linestatus: g.key.linestatus, sum_qty: _sum(for x <- g, do: x.l_quantity), sum_base_price: _sum(for x <- g, do: x.l_extendedprice), sum_disc_price: _sum(for x <- g, do: (x.l_extendedprice * (1 - x.l_discount))), sum_charge: _sum(for x <- g, do: ((x.l_extendedprice * (1 - x.l_discount)) * (1 + x.l_tax))), avg_qty: _avg(for x <- g, do: x.l_quantity), avg_price: _avg(for x <- g, do: x.l_extendedprice), avg_disc: _avg(for x <- g, do: x.l_discount), count_order: _count(g)} end)
  end)()
  print(Jason.encode!(result))
}
main()
fun _avg(v) {
  let list = cond do
  is_map(v) and Map.has_key?(v, :Items) -> v[:Items]
  is_list(v) -> v
  true -> raise "avg() expects list or group"
}
fun _count(v) {
  cond do
  is_list(v) -> length(v)
  is_map(v) and Map.has_key?(v, :Items) -> length(v[:Items])
  true -> raise "count() expects list or group"
}
fun _group_by(src, keyfn) {
  let {groups, order} = Enum.reduce(src, {%{}, []}, fn it, {groups, order} ->
  let key = keyfn.(it)
  let ks = to_string(key)
  let {groups, order} = if Map.has_key?(groups, ks) do
  {groups, order}
  else
  {Map.put(groups, ks, %_Group{key: key}), order ++ [ks]}
}
fun _query(src, joins, opts) {
  let where = Map.get(opts, :where)
  let items = Enum.map(src, fn v -> [v] end)
  let items = if where, do: Enum.filter(items, fn r -> where.(r) end), else: items
  let items = Enum.reduce(joins, items, fn j, items ->
  let joined = cond do
  Map.get(j, :right) && Map.get(j, :left) ->
  let matched = for _ <- j[:items], do: false
  let {res, matched} = Enum.reduce(items, {[], matched}, fn left, {acc, matched} ->
  let {acc, matched, m} = Enum.reduce(Enum.with_index(j[:items]), {acc, matched, false}, fn {right, ri}, {acc, matched, m} ->
  let keep = if Map.has_key?(j, :on) and j[:on], do: apply(j[:on], left ++ [right]), else: true
  if keep do
  let matched = List.replace_at(matched, ri, true)
  {acc ++ [left ++ [right]], matched, true}
  else
  {acc, matched, m}
}
fun _sum(v) {
  let list = cond do
  is_map(v) and Map.has_key?(v, :Items) -> v[:Items]
  is_list(v) -> v
  true -> raise "sum() expects list or group"
}
