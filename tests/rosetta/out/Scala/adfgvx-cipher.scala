// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
object adfgvx_cipher {
  def shuffleStr(s: String): String = {
    var arr: List[String] = scala.collection.mutable.ArrayBuffer[String]()
    var i = 0
    while (i < s.length) {
      arr += List(s.charAt(i))
      i += 1
    }
    var j = arr.length - 1
    while (j > 0) {
      val k = now() % (j + 1)
      val tmp = (arr).apply(j)
      arr(j) = (arr).apply(k)
      arr(k) = tmp
      j -= 1
    }
    var out = ""
    i = 0
    while (i < arr.length) {
      out += (arr).apply(i)
      i += 1
    }
    return out
  }
  
  def createPolybius(): List[String] = {
    val shuffled = shuffleStr(alphabet)
    println("6 x 6 Polybius square:\n")
    println("  | A D F G V X")
    println("---------------")
    var p: List[String] = scala.collection.mutable.ArrayBuffer[String]()
    var i = 0
    while (i < 6) {
      var row = shuffled.substring(i * 6, (i + 1) * 6)
      p += List(row)
      var line = adfgvx.charAt(i) + " | "
      var j = 0
      while (j < 6) {
        line = line + row.charAt(j) + " "
        j += 1
      }
      println(line)
      i += 1
    }
    return p
  }
  
  def createKey(n: Int): String = {
    if (n < 7 || n > 12) {
      println("Key should be within 7 and 12 letters long.")
    }
    var pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    var key = ""
    var i = 0
    while (i < n) {
      val idx = now() % pool.length
      key += pool.charAt(idx)
      pool = pool.substring(0, idx) + pool.substring(idx + 1, pool.length)
      i += 1
    }
    println("\nThe key is " + key)
    return key
  }
  
  def orderKey(key: String): List[Int] = {
    var pairs = scala.collection.mutable.ArrayBuffer[Any]()
    var i = 0
    while (i < key.length) {
      pairs += List(List(key.charAt(i), i))
      i += 1
    }
    var n = pairs.length
    var m = 0
    while (m < n) {
      var j = 0
      while (j < n - 1) {
        if ((((pairs).apply(j)).apply(0)).asInstanceOf[Int] > (((pairs).apply(j + 1)).apply(0)).asInstanceOf[Int]) {
          val tmp = (pairs).apply(j)
          pairs(j) = (pairs).apply(j + 1)
          pairs(j + 1) = tmp
        }
        j += 1
      }
      m += 1
    }
    var res = scala.collection.mutable.ArrayBuffer[Any]()
    i = 0
    while (i < n) {
      res += List(((pairs).apply(i)).apply(1).toInt)
      i += 1
    }
    return res
  }
  
  def encrypt(polybius: List[String], key: String, plainText: String): String = {
    var temp = ""
    var i = 0
    while (i < plainText.length) {
      var r = 0
      while (r < 6) {
        var c = 0
        while (c < 6) {
          if ((polybius).apply(r).charAt(c) == plainText.charAt(i)) {
            temp = temp + adfgvx.charAt(r) + adfgvx.charAt(c)
          }
          c += 1
        }
        r += 1
      }
      i += 1
    }
    var colLen = temp.length / key.length
    if (temp.length % key.length > 0) {
      colLen += 1
    }
    var table: List[List[String]] = scala.collection.mutable.ArrayBuffer[List[String]]()
    var rIdx = 0
    while (rIdx < colLen) {
      var row: List[String] = scala.collection.mutable.ArrayBuffer[String]()
      var j = 0
      while (j < key.length) {
        row += List("")
        j += 1
      }
      table += List(row)
      rIdx += 1
    }
    var idx = 0
    while (idx < temp.length) {
      val row = idx / key.length
      val col = idx % key.length
      val _tmp0 = table(row).updated(col, temp.substring(idx, idx + 1))
      table = table.updated(row, _tmp0)
      idx += 1
    }
    val order = orderKey(key)
    var cols: List[String] = scala.collection.mutable.ArrayBuffer[String]()
    var ci = 0
    while (ci < key.length) {
      var colStr = ""
      var ri = 0
      while (ri < colLen) {
        colStr += ((table).apply(ri)).apply((order).apply(ci))
        ri += 1
      }
      cols += List(colStr)
      ci += 1
    }
    var result = ""
    ci = 0
    while (ci < cols.length) {
      result += (cols).apply(ci)
      if (ci < cols.length - 1) {
        result += " "
      }
      ci += 1
    }
    return result
  }
  
  def indexOf(s: String, ch: String): Int = {
    var i = 0
    while (i < s.length) {
      if (s.charAt(i) == ch) {
        return i
      }
      i += 1
    }
    return -1
  }
  
  def decrypt(polybius: List[String], key: String, cipherText: String): String = {
    var colStrs: List[String] = scala.collection.mutable.ArrayBuffer[String]()
    var start = 0
    var i = 0
    while (i <= cipherText.length) {
      if (i == cipherText.length || cipherText.charAt(i) == " ") {
        colStrs += List(cipherText.substring(start, i))
        start = i + 1
      }
      i += 1
    }
    var maxColLen = 0
    i = 0
    while (i < colStrs.length) {
      if ((colStrs).apply(i).length > maxColLen) {
        maxColLen = (colStrs).apply(i).length
      }
      i += 1
    }
    var cols: List[List[String]] = scala.collection.mutable.ArrayBuffer[List[String]]()
    i = 0
    while (i < colStrs.length) {
      var s = (colStrs).apply(i)
      var ls: List[String] = scala.collection.mutable.ArrayBuffer[String]()
      var j = 0
      while (j < s.length) {
        ls += List(s.charAt(j))
        j += 1
      }
      if (s.length < maxColLen) {
        var pad: List[String] = scala.collection.mutable.ArrayBuffer[String]()
        var k = 0
        while (k < maxColLen) {
          if (k < ls.length) {
            pad += List((ls).apply(k))
          } else {
            pad += List("")
          }
          k += 1
        }
        cols += List(pad)
      } else {
        cols += List(ls)
      }
      i += 1
    }
    var table: List[List[String]] = scala.collection.mutable.ArrayBuffer[List[String]]()
    var r = 0
    while (r < maxColLen) {
      var row: List[String] = scala.collection.mutable.ArrayBuffer[String]()
      var c = 0
      while (c < key.length) {
        row += List("")
        c += 1
      }
      table += List(row)
      r += 1
    }
    val order = orderKey(key)
    r = 0
    while (r < maxColLen) {
      var c = 0
      while (c < key.length) {
        val _tmp1 = table(r).updated((order).apply(c), ((cols).apply(c)).apply(r))
        table = table.updated(r, _tmp1)
        c += 1
      }
      r += 1
    }
    var temp = ""
    r = 0
    while (r < table.length) {
      var j = 0
      while (j < (table).apply(r).length) {
        temp += ((table).apply(r)).apply(j)
        j += 1
      }
      r += 1
    }
    var plainText = ""
    var idx = 0
    while (idx < temp.length) {
      val rIdx = indexOf(adfgvx, temp.substring(idx, idx + 1))
      val cIdx = indexOf(adfgvx, temp.substring(idx + 1, idx + 2))
      plainText += (polybius).apply(rIdx).charAt(cIdx)
      idx += 2
    }
    return plainText
  }
  
  def main() = {
    val plainText = "ATTACKAT1200AM"
    val polybius = createPolybius()
    val key = createKey(9)
    println("\nPlaintext : " + plainText)
    val cipherText = encrypt(polybius, key, plainText)
    println("\nEncrypted : " + cipherText)
    val plainText2 = decrypt(polybius, key, cipherText)
    println("\nDecrypted : " + plainText2)
  }
  
  def main(args: Array[String]): Unit = {
    var adfgvx = "ADFGVX"
    var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    main()
  }
}
