// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:49:36Z
object abelian_sandpile_model_identity {
  def neighborsList(): List[List[Int]] = List(List(1, 3), List(0, 2, 4), List(1, 5), List(0, 4, 6), List(1, 3, 5, 7), List(2, 4, 8), List(3, 7), List(4, 6, 8), List(5, 7))
  
  def plus(a: List[Int], b: List[Int]): List[Int] = {
    var res: List[Int] = scala.collection.mutable.ArrayBuffer[Any]()
    var i = 0
    while (i < a.length) {
      res = res :+ (a).apply(i) + (b).apply(i)
      i += 1
    }
    return res
  }
  
  def isStable(p: List[Int]): Boolean = {
    for(v <- p) {
      if (v > 3) {
        return false
      }
    }
    return true
  }
  
  def topple(p: List[Int]): Int = {
    val neighbors = neighborsList()
    var i = 0
    while (i < p.length) {
      if ((p).apply(i) > 3) {
        p(i) = (p).apply(i) - 4
        val nbs = (neighbors).apply(i)
        for(j <- nbs) {
          p(j) = (p).apply(j) + 1
        }
        return 0
      }
      i += 1
    }
    return 0
  }
  
  def pileString(p: List[Int]): String = {
    var s = ""
    var r = 0
    while (r < 3) {
      var c = 0
      while (c < 3) {
        s = (s + (p).apply(3 * r + c).toString).asInstanceOf[Int] + " "
        c += 1
      }
      s += "\n"
      r += 1
    }
    return s
  }
  
  def main(args: Array[String]): Unit = {
    println("Avalanche of topplings:\n")
    var s4 = scala.collection.mutable.ArrayBuffer(4, 3, 3, 3, 1, 2, 0, 2, 3)
    println(pileString(s4))
    while (!isStable(s4)) {
      topple(s4)
      println(pileString(s4))
    }
    println("Commutative additions:\n")
    var s1 = scala.collection.mutable.ArrayBuffer(1, 2, 0, 2, 1, 1, 0, 1, 3)
    var s2 = scala.collection.mutable.ArrayBuffer(2, 1, 3, 1, 0, 1, 0, 1, 0)
    var s3_a = plus(s1, s2)
    while (!isStable(s3_a)) {
      topple(s3_a)
    }
    var s3_b = plus(s2, s1)
    while (!isStable(s3_b)) {
      topple(s3_b)
    }
    println((((pileString(s1) + "\nplus\n\n").asInstanceOf[Int] + pileString(s2)).asInstanceOf[Int] + "\nequals\n\n").asInstanceOf[Int] + pileString(s3_a))
    println((((("and\n\n" + pileString(s2)).asInstanceOf[Int] + "\nplus\n\n").asInstanceOf[Int] + pileString(s1)).asInstanceOf[Int] + "\nalso equals\n\n").asInstanceOf[Int] + pileString(s3_b))
    println("Addition of identity sandpile:\n")
    var s3 = scala.collection.mutable.ArrayBuffer(3, 3, 3, 3, 3, 3, 3, 3, 3)
    var s3_id = scala.collection.mutable.ArrayBuffer(2, 1, 2, 1, 0, 1, 2, 1, 2)
    var s4b = plus(s3, s3_id)
    while (!isStable(s4b)) {
      topple(s4b)
    }
    println((((pileString(s3) + "\nplus\n\n").asInstanceOf[Int] + pileString(s3_id)).asInstanceOf[Int] + "\nequals\n\n").asInstanceOf[Int] + pileString(s4b))
    println("Addition of identities:\n")
    var s5 = plus(s3_id, s3_id)
    while (!isStable(s5)) {
      topple(s5)
    }
    println((((pileString(s3_id) + "\nplus\n\n").asInstanceOf[Int] + pileString(s3_id)).asInstanceOf[Int] + "\nequals\n\n").asInstanceOf[Int] + pileString(s5))
  }
}
