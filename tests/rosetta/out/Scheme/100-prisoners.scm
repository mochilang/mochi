; Generated by Mochi compiler v0.10.30 on 2025-07-18T18:26:30Z
(define (list-set lst idx val)
    (let loop ((i idx) (l lst))
        (if (null? l)
            '()
            (if (= i 0)
                (cons val (cdr l))
                (cons (car l) (loop (- i 1) (cdr l))))))
)
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))

(define (shuffle xs)
  (call/cc (lambda (return)
    (define arr '())
    (define i '())
    (define j '())
    (define tmp '())
    (set! arr xs)
    (set! i 99)
    (let loop ()
      (if (> i 0)
        (begin
          (set! j (modulo (now) (+ i 1)))
          (set! tmp (list-ref arr i))
          (set! arr (list-set arr i (list-ref arr j)))
          (set! arr (list-set arr j tmp))
          (set! i (- i 1))
          (loop)
        )
      '()
    )
  )
  (return arr)
))
)

(define (doTrials trials np strategy)
(call/cc (lambda (return)
  (define d '())
  (define drawers '())
  (define found '())
  (define i '())
  (define k '())
  (define n '())
  (define opened '())
  (define p '())
  (define pardoned '())
  (define prev '())
  (define rf '())
  (define success '())
  (define t '())
  (define this '())
  (set! pardoned 0)
  (set! t 0)
  (call/cc (lambda (brk0)
    (let loop0 ()
      (when (< t trials)
        (set! drawers (list ))
        (set! i 0)
        (let loop ()
          (if (< i 100)
            (begin
              (set! drawers (append drawers (list i)))
              (set! i (+ i 1))
              (loop)
            )
          '()
        )
      )
      (set! drawers (shuffle drawers))
      (set! p 0)
      (set! success #t)
      (call/cc (lambda (brk1)
        (let loop1 ()
          (when (< p np)
            (set! found #f)
            (if (equal? strategy "optimal")
              (begin
                (set! prev p)
                (set! d 0)
                (call/cc (lambda (brk2)
                  (let loop2 ()
                    (when (< d 50)
                      (set! this (list-ref drawers prev))
                      (when (equal? this p)
                        (set! found #t)
                        (brk2 '())
                      )
                      (set! prev this)
                      (set! d (+ d 1))
                      (loop2))
                    )
                  )
                )
              )
              (begin
                (set! opened (list ))
                (set! k 0)
                (let loop ()
                  (if (< k 100)
                    (begin
                      (set! opened (append opened (list #f)))
                      (set! k (+ k 1))
                      (loop)
                    )
                  '()
                )
              )
              (set! d 0)
              (call/cc (lambda (brk2)
                (let loop2 ()
                  (when (< d 50)
                    (set! n (modulo (now) 100))
                    (let loop ()
                      (if (list-ref opened n)
                        (begin
                          (set! n (modulo (now) 100))
                          (loop)
                        )
                      '()
                    )
                  )
                  (set! opened (list-set opened n #t))
                  (when (equal? (list-ref drawers n) p)
                    (set! found #t)
                    (brk2 '())
                  )
                  (set! d (+ d 1))
                  (loop2))
                )
              )
            )
          )
        )
        (when (not found)
          (set! success #f)
          (brk1 '())
        )
        (set! p (+ p 1))
        (loop1))
      )
    )
  )
  (when success
    (set! pardoned (+ pardoned 1))
  )
  (set! t (+ t 1))
  (loop0))
)
)
)
(set! rf (* (quotient (exact->inexact pardoned) (exact->inexact trials)) 100.0))
(begin (display (string-append (string-append (string-append (string-append (string-append (string-append "  strategy = " strategy) "  pardoned = ") (let ((s (open-output-string))) (write pardoned s) (get-output-string s))) " relative frequency = ") (let ((s (open-output-string))) (write rf s) (get-output-string s))) "%")) (newline))
))
)

(define (main )
(call/cc (lambda (return)
(define trials '())
(set! trials 1000)
(let loop ((np_idx 0))
(if (< np_idx (length (list 10 100)))
(begin
  (let ((np (list-ref (list 10 100) np_idx)))
    (begin (display (string-append (string-append (string-append (string-append "Results from " (let ((s (open-output-string))) (write trials s) (get-output-string s))) " trials with ") (let ((s (open-output-string))) (write np s) (get-output-string s))) " prisoners:\n")) (newline))
    (let loop ((strat_idx 0))
      (if (< strat_idx (length (list "random" "optimal")))
        (begin
          (let ((strat (list-ref (list "random" "optimal") strat_idx)))
            (doTrials trials np strat)
          )
          (loop (+ strat_idx 1))
        )
      '()
      )
    )
  )
  (loop (+ np_idx 1))
)
'()
)
)
))
)

(main )
