; Generated by Mochi compiler v0.10.30 on 2025-07-18T18:26:56Z
(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)

(define (validComb a b c d e f g)
  (call/cc (lambda (return)
    (define square1 '())
    (define square2 '())
    (define square3 '())
    (define square4 '())
    (set! square1 (+ a b))
    (set! square2 (+ (+ b c) d))
    (set! square3 (+ (+ d e) f))
    (set! square4 (+ f g))
    (return (and (and (equal? square1 square2) (equal? square2 square3)) (equal? square3 square4)))
  ))
)

(define (isUnique a b c d e f g)
  (call/cc (lambda (return)
    (define i '())
    (define j '())
    (define nums '())
    (set! nums (list a b c d e f g))
    (set! i 0)
    (let loop ()
      (if (< i (length nums))
        (begin
          (set! j (+ i 1))
          (let loop ()
            (if (< j (length nums))
              (begin
                (when (equal? (list-ref nums i) (list-ref nums j))
                  (return #f)
                )
                (set! j (+ j 1))
                (loop)
              )
            '()
          )
        )
        (set! i (+ i 1))
        (loop)
      )
    '()
  )
)
(return #t)
))
)

(define (getCombs low high unique)
(call/cc (lambda (return)
(define a '())
(define count '())
(define g '())
(define s '())
(define valid '())
(set! valid (list ))
(set! count 0)
(call/cc (lambda (brk0)
  (let loop0 ((b low))
    (when (< b (+ high 1))
      (call/cc (lambda (brk1)
        (let loop1 ((c low))
          (when (< c (+ high 1))
            (call/cc (lambda (brk2)
              (let loop2 ((d low))
                (when (< d (+ high 1))
                  (set! s (+ (+ b c) d))
                  (call/cc (lambda (brk3)
                    (let loop3 ((e low))
                      (when (< e (+ high 1))
                        (call/cc (lambda (brk4)
                          (let loop4 ((f low))
                            (when (< f (+ high 1))
                              (set! a (- s b))
                              (set! g (- s f))
                              (when (or (< a low) (> a high))
                                (loop4 (+ f 1))
                              )
                              (when (or (< g low) (> g high))
                                (loop4 (+ f 1))
                              )
                              (when (not (equal? (+ (+ d e) f) s))
                                (loop4 (+ f 1))
                              )
                              (when (not (equal? (+ f g) s))
                                (loop4 (+ f 1))
                              )
                              (when (or (not unique) (isUnique a b c d e f g))
                                (set! valid (append valid (list (list a b c d e f g))))
                                (set! count (+ count 1))
                              )
                              (loop4 (+ f 1)))
                            )
                          )
                        )
                        (loop3 (+ e 1)))
                      )
                    )
                  )
                  (loop2 (+ d 1)))
                )
              )
            )
            (loop1 (+ c 1)))
          )
        )
      )
      (loop0 (+ b 1)))
    )
  )
)
(return (list (cons "count" count) (cons "list" valid)))
))
)

(define r1 '())
(define r2 '())
(define r3 '())
(set! r1 (getCombs 1 7 #t))
(begin (display (string-append (let ((s (open-output-string))) (write (map-get r1 "count") s) (get-output-string s)) " unique solutions in 1 to 7")) (newline))
(begin (display (map-get r1 "list")) (newline))
(set! r2 (getCombs 3 9 #t))
(begin (display (string-append (let ((s (open-output-string))) (write (map-get r2 "count") s) (get-output-string s)) " unique solutions in 3 to 9")) (newline))
(begin (display (map-get r2 "list")) (newline))
(set! r3 (getCombs 0 9 #f))
(begin (display (string-append (let ((s (open-output-string))) (write (map-get r3 "count") s) (get-output-string s)) " non-unique solutions in 0 to 9")) (newline))
