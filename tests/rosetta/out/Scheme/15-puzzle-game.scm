; Generated by Mochi compiler v0.10.30 on 2025-07-18T19:09:33Z
(define (list-set lst idx val)
    (let loop ((i idx) (l lst))
        (if (null? l)
            '()
            (if (= i 0)
                (cons val (cdr l))
                (cons (car l) (loop (- i 1) (cdr l))))))
)
(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))
(define (_slice obj i j)
  (let* ((n (if (string? obj) (string-length obj) (length obj)))
         (start i)
         (end j))
    (when (< start 0) (set! start (+ n start)))
    (when (< end 0) (set! end (+ n end)))
    (when (< start 0) (set! start 0))
    (when (> end n) (set! end n))
    (when (< end start) (set! end start))
        (if (string? obj)
        (substring obj start end)
        (let loop ((idx 0) (xs obj) (out '()))
          (if (or (null? xs) (>= idx end))
              (reverse out)
              (loop (+ idx 1) (cdr xs)
                    (if (>= idx start)
                        (cons (car xs) out)
                        out)))))))

(define (randMove )
  (call/cc (lambda (return)
    (return (modulo (now) 4))
  ))
)

(define (isSolved )
  (call/cc (lambda (return)
    (define i '())
    (set! i 0)
    (let loop ()
      (if (< i 16)
        (begin
          (when (not (equal? (list-ref board i) (list-ref solved i)))
            (return #f)
          )
          (set! i (+ i 1))
          (loop)
        )
      '()
    )
  )
  (return #t)
))
)

(define (isValidMove m)
(call/cc (lambda (return)
  (when (equal? m 0)
    (return (list (cons "idx" (- empty 4)) (cons "ok" (> (quotient empty 4) 0))))
  )
  (when (equal? m 1)
    (return (list (cons "idx" (+ empty 4)) (cons "ok" (< (quotient empty 4) 3))))
  )
  (when (equal? m 2)
    (return (list (cons "idx" (+ empty 1)) (cons "ok" (< (modulo empty 4) 3))))
  )
  (when (equal? m 3)
    (return (list (cons "idx" (- empty 1)) (cons "ok" (> (modulo empty 4) 0))))
  )
  (return (list (cons "idx" 0) (cons "ok" #f)))
))
)

(define (doMove m)
(call/cc (lambda (return)
  (define i '())
  (define j '())
  (define r '())
  (define tmp '())
  (set! r (isValidMove m))
  (when (not (map-get r "ok"))
    (return #f)
  )
  (set! i empty)
  (set! j (inexact->exact (map-get r "idx")))
  (set! tmp (list-ref board i))
  (set! board (list-set board i (list-ref board j)))
  (set! board (list-set board j tmp))
  (set! empty j)
  (set! moves (+ moves 1))
  (return #t)
))
)

(define (shuffle n)
(call/cc (lambda (return)
  (define i '())
  (set! i 0)
  (let loop ()
    (if (or (< i n) (isSolved ))
      (begin
        (when (doMove (randMove ))
          (set! i (+ i 1))
        )
        (loop)
      )
    '()
  )
)
))
)

(define (printBoard )
(call/cc (lambda (return)
(define i '())
(define line '())
(define s '())
(define val '())
(set! line "")
(set! i 0)
(let loop ()
  (if (< i 16)
    (begin
      (set! val (list-ref board i))
      (if (equal? val 0)
        (begin
          (set! line (string-append line "  ."))
        )
        (begin
          (set! s (let ((s (open-output-string))) (write val s) (get-output-string s)))
          (if (< val 10)
            (begin
              (set! line (string-append (string-append line "  ") s))
            )
            (begin
              (set! line (string-append (string-append line " ") s))
            )
          )
        )
      )
      (when (equal? (modulo i 4) 3)
        (begin (display line) (newline))
        (set! line "")
      )
      (set! i (+ i 1))
      (loop)
    )
  '()
)
)
))
)

(define (playOneMove )
(call/cc (lambda (return)
(define c '())
(define m '())
(define s '())
(call/cc (lambda (brk0)
(let loop0 ()
  (when #t
    (begin (display (string-append (string-append "Enter move #" (let ((s (open-output-string))) (write (+ moves 1) s) (get-output-string s))) " (U, D, L, R, or Q): ")) (newline))
    (set! s (read-line))
    (when (equal? s "")
      (loop0)
    )
    (set! c (_slice s 0 1))
    (set! m 0)
    (if (or (equal? c "U") (equal? c "u"))
      (begin
        (set! m 0)
      )
      (if (or (equal? c "D") (equal? c "d"))
        (begin
          (set! m 1)
        )
        (if (or (equal? c "R") (equal? c "r"))
          (begin
            (set! m 2)
          )
          (if (or (equal? c "L") (equal? c "l"))
            (begin
              (set! m 3)
            )
            (if (or (equal? c "Q") (equal? c "q"))
              (begin
                (begin (display (string-append (string-append "Quiting after " (let ((s (open-output-string))) (write moves s) (get-output-string s))) " moves.")) (newline))
                (set! quit #t)
                (return '())
              )
              (begin
                (begin (display (string-append (string-append (string-append "Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" "up, down, left, or right. You can also enter \"Q\" to quit.\n") "Upper or lowercase is accepted and only the first non-blank\n") "character is important (i.e. you may enter \"up\" if you like).")) (newline))
                (loop0)
              )
            )
          )
        )
      )
    )
    (when (not (doMove m))
      (begin (display "That is not a valid move at the moment.") (newline))
      (loop0)
    )
    (return '())
    (loop0))
  )
)
)
))
)

(define (play )
(call/cc (lambda (return)
(begin (display "Starting board:") (newline))
(let loop ()
(if (and (not quit) (equal? (isSolved ) #f))
  (begin
    (begin (display "") (newline))
    (printBoard )
    (playOneMove )
    (loop)
  )
'()
)
)
(when (isSolved )
(begin (display (string-append (string-append "You solved the puzzle in " (let ((s (open-output-string))) (write moves s) (get-output-string s))) " moves.")) (newline))
)
))
)

(define (main )
(call/cc (lambda (return)
(shuffle 50)
(play )
))
)

(define board '())
(define empty '())
(define moves '())
(define quit '())
(define solved '())
(set! board (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0))
(set! solved (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0))
(set! empty 15)
(set! moves 0)
(set! quit #f)
(main )
