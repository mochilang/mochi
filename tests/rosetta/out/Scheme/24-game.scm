; Generated by Mochi compiler v0.10.30 on 2025-07-18T18:26:54Z
(define (list-set lst idx val)
    (let loop ((i idx) (l lst))
        (if (null? l)
            '()
            (if (= i 0)
                (cons val (cdr l))
                (cons (car l) (loop (- i 1) (cdr l))))))
)
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))
(define (_slice obj i j)
  (let* ((n (if (string? obj) (string-length obj) (length obj)))
         (start i)
         (end j))
    (when (< start 0) (set! start (+ n start)))
    (when (< end 0) (set! end (+ n end)))
    (when (< start 0) (set! start 0))
    (when (> end n) (set! end n))
    (when (< end start) (set! end start))
        (if (string? obj)
        (substring obj start end)
        (let loop ((idx 0) (xs obj) (out '()))
          (if (or (null? xs) (>= idx end))
              (reverse out)
              (loop (+ idx 1) (cdr xs)
                    (if (>= idx start)
                        (cons (car xs) out)
                        out)))))))

(define (randDigit )
  (call/cc (lambda (return)
    (return (+ (modulo (now) 9) 1))
  ))
)

(define (main )
  (call/cc (lambda (return)
    (define a '())
    (define b '())
    (define ch '())
    (define digits '())
    (define expr '())
    (define i '())
    (define j '())
    (define numstr '())
    (define stack '())
    (define valid '())
    (set! digits (list ))
    (let loop ((i 0))
      (if (< i 4)
        (begin
          (set! digits (append digits (list (randDigit ))))
          (loop (+ i 1))
        )
      '()
    )
  )
  (set! numstr "")
  (let loop ((i 0))
    (if (< i 4)
      (begin
        (set! numstr (string-append numstr (let ((s (open-output-string))) (write (list-ref digits i) s) (get-output-string s))))
        (loop (+ i 1))
      )
    '()
  )
)
(begin (display (string-append (string-append "Your numbers: " numstr) "\n")) (newline))
(begin (display "Enter RPN: ") (newline))
(set! expr (read-line))
(when (not (equal? (string-length expr) 7))
  (begin (display "invalid. expression length must be 7. (4 numbers, 3 operators, no spaces)") (newline))
  (return '())
)
(set! stack (list ))
(set! i 0)
(set! valid #t)
(call/cc (lambda (brk0)
  (let loop0 ()
    (when (< i (string-length expr))
      (set! ch (substring expr i (+ i 1)))
      (if (and (string>=? ch "0") (string<=? ch "9"))
        (begin
          (when (equal? (length digits) 0)
            (begin (display "too many numbers.") (newline))
            (return '())
          )
          (set! j 0)
          (let loop ()
            (if (not (equal? (list-ref digits j) (- (int ch) (int "0"))))
              (begin
                (set! j (+ j 1))
                (when (equal? j (length digits))
                  (begin (display "wrong numbers.") (newline))
                  (return '())
                )
                (loop)
              )
            '()
          )
        )
        (set! digits (+ (_slice digits 0 j) (_slice digits (+ j 1) (length digits))))
        (set! stack (append stack (list (float (- (int ch) (int "0"))))))
      )
      (begin
        (when (< (length stack) 2)
          (begin (display "invalid expression syntax.") (newline))
          (set! valid #f)
          (brk0 '())
        )
        (set! b (list-ref stack (- (length stack) 1)))
        (set! a (list-ref stack (- (length stack) 2)))
        (if (equal? ch "+")
          (begin
            (set! stack (list-set stack (- (length stack) 2) (+ a b)))
          )
          (if (equal? ch "-")
            (begin
              (set! stack (list-set stack (- (length stack) 2) (- a b)))
            )
            (if (equal? ch "*")
              (begin
                (set! stack (list-set stack (- (length stack) 2) (* a b)))
              )
              (if (equal? ch "/")
                (begin
                  (set! stack (list-set stack (- (length stack) 2) (quotient a b)))
                )
                (begin
                  (begin (display (string-append ch " invalid.")) (newline))
                  (set! valid #f)
                  (brk0 '())
                )
              )
            )
          )
        )
        (set! stack (_slice stack 0 (- (length stack) 1)))
      )
    )
    (set! i (+ i 1))
    (loop0))
  )
)
)
(when valid
(if (> (abs (- (list-ref stack 0) 24.0)) 0.000001)
  (begin
    (begin (display (string-append (string-append "incorrect. " (let ((s (open-output-string))) (write (list-ref stack 0) s) (get-output-string s))) " != 24")) (newline))
  )
  (begin
    (begin (display "correct.") (newline))
  )
)
)
))
)

(main )
