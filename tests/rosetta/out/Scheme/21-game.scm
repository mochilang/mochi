; Generated by Mochi compiler v0.10.30 on 2025-07-18T18:26:50Z
(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))
(define (_slice obj i j)
  (let* ((n (if (string? obj) (string-length obj) (length obj)))
         (start i)
         (end j))
    (when (< start 0) (set! start (+ n start)))
    (when (< end 0) (set! end (+ n end)))
    (when (< start 0) (set! start 0))
    (when (> end n) (set! end n))
    (when (< end start) (set! end start))
        (if (string? obj)
        (substring obj start end)
        (let loop ((idx 0) (xs obj) (out '()))
          (if (or (null? xs) (>= idx end))
              (reverse out)
              (loop (+ idx 1) (cdr xs)
                    (if (>= idx start)
                        (cons (car xs) out)
                        out)))))))

(define (parseIntStr str)
  (call/cc (lambda (return)
    (define digits '())
    (define i '())
    (define n '())
    (define neg '())
    (set! i 0)
    (set! neg #f)
    (when (and (> (string-length str) 0) (equal? (_slice str 0 1) "-"))
      (set! neg #t)
      (set! i 1)
    )
    (set! n 0)
    (set! digits (list (cons "0" 0) (cons "1" 1) (cons "2" 2) (cons "3" 3) (cons "4" 4) (cons "5" 5) (cons "6" 6) (cons "7" 7) (cons "8" 8) (cons "9" 9)))
    (let loop ()
      (if (< i (string-length str))
        (begin
          (set! n (+ (* n 10) (map-get digits (_slice str i (+ i 1)))))
          (set! i (+ i 1))
          (loop)
        )
      '()
    )
  )
  (when neg
    (set! n (- n))
  )
  (return n)
))
)

(define (main )
(call/cc (lambda (return)
  (define choice '())
  (define computer '())
  (define done '())
  (define i '())
  (define line '())
  (define num '())
  (define round '())
  (define total '())
  (set! total 0)
  (set! computer (equal? (modulo (now) 2) 0))
  (begin (display "Enter q to quit at any time\n") (newline))
  (if computer
    (begin
      (begin (display "The computer will choose first") (newline))
    )
    (begin
      (begin (display "You will choose first") (newline))
    )
  )
  (begin (display "\n\nRunning total is now 0\n\n") (newline))
  (set! round 1)
  (set! done #f)
  (call/cc (lambda (brk0)
    (let loop0 ()
      (when (not done)
        (begin (display (string-append (string-append "ROUND " (let ((s (open-output-string))) (write round s) (get-output-string s))) ":\n\n")) (newline))
        (set! i 0)
        (call/cc (lambda (brk1)
          (let loop1 ()
            (when (and (< i 2) (not done))
              (if computer
                (begin
                  (set! choice 0)
                  (if (< total 18)
                    (begin
                      (set! choice (+ (modulo (now) 3) 1))
                    )
                    (begin
                      (set! choice (- 21 total))
                    )
                  )
                  (set! total (+ total choice))
                  (begin (display (string-append "The computer chooses " (let ((s (open-output-string))) (write choice s) (get-output-string s)))) (newline))
                  (begin (display (string-append "Running total is now " (let ((s (open-output-string))) (write total s) (get-output-string s)))) (newline))
                  (when (equal? total 21)
                    (begin (display "\nSo, commiserations, the computer has won!") (newline))
                    (set! done #t)
                  )
                )
                (begin
                  (call/cc (lambda (brk2)
                    (let loop2 ()
                      (when #t
                        (begin (display "Your choice 1 to 3 : ") (newline))
                        (set! line (read-line))
                        (when (or (equal? line "q") (equal? line "Q"))
                          (begin (display "OK, quitting the game") (newline))
                          (set! done #t)
                          (brk2 '())
                        )
                        (set! num (parseIntStr line))
                        (when (or (< num 1) (> num 3))
                          (if (> (+ total num) 21)
                            (begin
                              (begin (display "Too big, try again") (newline))
                            )
                            (begin
                              (begin (display "Out of range, try again") (newline))
                            )
                          )
                          (loop2)
                        )
                        (when (> (+ total num) 21)
                          (begin (display "Too big, try again") (newline))
                          (loop2)
                        )
                        (set! total (+ total num))
                        (begin (display (string-append "Running total is now " (let ((s (open-output-string))) (write total s) (get-output-string s)))) (newline))
                        (brk2 '())
                        (loop2))
                      )
                    )
                  )
                  (when (equal? total 21)
                    (begin (display "\nSo, congratulations, you've won!") (newline))
                    (set! done #t)
                  )
                )
              )
              (begin (display "\n") (newline))
              (set! computer (not computer))
              (set! i (+ i 1))
              (loop1))
            )
          )
        )
        (set! round (+ round 1))
        (loop0))
      )
    )
  )
))
)

(main )
