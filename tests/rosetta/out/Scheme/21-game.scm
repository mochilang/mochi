; Generated by Mochi compiler v0.10.26 on 2025-07-16T12:16:58Z
(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (srfi 1) (srfi 95) (chibi json) (chibi io) (chibi process) (chibi) (chibi string))

(define (_fmt . parts)
  (apply string-append (map _to_string parts)))

(define (_to_string v)
  (call-with-output-string (lambda (p) (write v p))))

(define (_yaml_value v)
  (let ((n (string->number v)))
    (if n n v)))

(define (_parse_yaml text)
  (let ((rows '()) (cur '()))
    (for-each (lambda (ln)
                (when (and (>= (string-length ln) 2) (string-prefix? "- " ln))
                  (when (not (null? cur))
                    (set! rows (append rows (list cur))))
                  (set! cur '())
                  (set! ln (substring ln 2 (string-length ln))))
                (when (string-contains ln ":")
                  (let* ((p (string-split ln #\:))
                         (k (string-trim (car p)))
                         (val (string-trim (string-join (cdr p) ":"))))
                    (set! cur (append cur (list (cons k (_yaml_value val))))))))
              (string-split text #\newline))
    (when (not (null? cur))
      (set! rows (append rows (list cur))))
    rows))

(define (_fetch url opts)
  (let* ((method (if (and opts (assq 'method opts)) (cdr (assq 'method opts)) "GET"))
         (args (list "curl" "-s" "-X" method)))
    (when (and opts (assq 'headers opts))
      (for-each (lambda (p)
                  (set! args (append args (list "-H" (_fmt (car p) ": " (cdr p))))))
                (cdr (assq 'headers opts))))
    (when (and opts (assq 'query opts))
      (let* ((q (cdr (assq 'query opts)))
             (qs (string-join (map (lambda (p) (_fmt (car p) "=" (cdr p))) q) "&")))
        (set! url (string-append url (if (string-contains url "?") "&" "?") qs))))
    (when (and opts (assq 'body opts))
      (set! args (append args (list "-d" (json->string (cdr (assq 'body opts)))))))
    (when (and opts (assq 'timeout opts))
      (set! args (append args (list "--max-time" (_to_string (cdr (assq 'timeout opts)))))))
    (set! args (append args (list url)))
    (let* ((p (open-input-pipe (string-join args " ")))
           (txt (port->string p)))
      (close-input-port p)
      (string->json txt))))

(define (_load path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (in (if (or (not path) (string=? path "") (string=? path "-"))
                 (current-input-port)
                 (open-input-file path)))
         (text (port->string in)))
    (when (not (eq? in (current-input-port)))
      (close-input-port in))
    (cond ((string=? fmt "jsonl")
           (map string->json
                (filter (lambda (l) (not (string=? l "")))
                        (string-split text #\newline))))
          ((string=? fmt "yaml")
           (_parse_yaml text))
          (else
           (let ((d (string->json text)))
             (if (list? d) d (list d)))))))

(define (_save rows path opts)
  (let* ((fmt (if (and opts (assq 'format opts)) (cdr (assq 'format opts)) "json"))
         (out (if (or (not path) (string=? path "") (string=? path "-"))
                  (current-output-port)
                  (open-output-file path))))
  (cond ((string=? fmt "jsonl")
           (for-each (lambda (r) (write-string (json->string r) out) (newline out)) rows))
          (else
           (write-string (json->string rows) out)))
    (when (not (eq? out (current-output-port)))
      (close-output-port out))))

(define (_date_number s)
  (let ((parts (string-split s #\-)))
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_lt a b)
  (cond
    ((and (number? a) (number? b)) (< a b))
    ((and (string? a) (string? b))
      (let ((da (_date_number a))
            (db (_date_number b)))
        (if (and da db)
            (< da db)
            (string<? a b))))
    ((and (pair? a) (pair? b))
      (cond
        ((null? a) (not (null? b)))
        ((null? b) #f)
        (else (let ((ka (car a)) (kb (car b)))
                (if (equal? ka kb)
                    (_lt (cdr a) (cdr b))
                    (_lt ka kb)))))
    )
    (else (string<? (_to_string a) (_to_string b)))))

(define (_le a b)
  (or (_lt a b) (equal? a b)))

(define (_gt a b)
  (_lt b a))

(define (_ge a b)
  (or (_gt a b) (equal? a b)))

(define (_sort pairs)
  (letrec ((cmp (lambda (a b) (_lt (cdr a) (cdr b))))
           (insert (lambda (x lst)
                     (cond ((null? lst) (list x))
                           ((cmp x (car lst)) (cons x lst))
                           (else (cons (car lst) (insert x (cdr lst)))))))
           (loop (lambda (xs out)
                   (if (null? xs)
                       out
                       (loop (cdr xs) (insert (car xs) out))))) )
    (loop pairs '())))
(define (_slice obj i j)
  (let* ((n (if (string? obj) (string-length obj) (length obj)))
         (start i)
         (end j))
    (when (< start 0) (set! start (+ n start)))
    (when (< end 0) (set! end (+ n end)))
    (when (< start 0) (set! start 0))
    (when (> end n) (set! end n))
    (when (< end start) (set! end start))
        (if (string? obj)
        (substring obj start end)
        (let loop ((idx 0) (xs obj) (out '()))
          (if (or (null? xs) (>= idx end))
              (reverse out)
              (loop (+ idx 1) (cdr xs)
                    (if (>= idx start)
                        (cons (car xs) out)
                        out)))))))

(define (parseIntStr str)
  (call/cc (lambda (return)
    (define digits '())
    (define i '())
    (define n '())
    (define neg '())
    (set! i 0)
    (set! neg #f)
    (when (and (_gt (string-length str) 0) (equal? (_slice str 0 1) "-"))
      (set! neg #t)
      (set! i 1)
    )
    (set! n 0)
    (set! digits (list (cons "0" 0) (cons "1" 1) (cons "2" 2) (cons "3" 3) (cons "4" 4) (cons "5" 5) (cons "6" 6) (cons "7" 7) (cons "8" 8) (cons "9" 9)))
    (let loop ()
      (if (_lt i (string-length str))
        (begin
          (set! n (+ (* n 10) (map-get digits (_slice str i (+ i 1)))))
          (set! i (+ i 1))
          (loop)
        )
      '()
    )
  )
  (when neg
    (set! n (- n))
  )
  (return n)
))
)

(define (main )
(call/cc (lambda (return)
  (define choice '())
  (define computer '())
  (define done '())
  (define i '())
  (define line '())
  (define num '())
  (define round '())
  (define total '())
  (set! total 0)
  (set! computer (equal? (modulo (now ) 2) 0))
  (begin (display "Enter q to quit at any time\n") (newline))
  (if computer
    (begin
      (begin (display "The computer will choose first") (newline))
    )
    (begin
      (begin (display "You will choose first") (newline))
    )
  )
  (begin (display "\n\nRunning total is now 0\n\n") (newline))
  (set! round 1)
  (set! done #f)
  (call/cc (lambda (brk0)
    (let loop0 ()
      (when (not done)
        (begin (display (string-append (string-append "ROUND " (let ((s (open-output-string))) (write round s) (get-output-string s))) ":\n\n")) (newline))
        (set! i 0)
        (call/cc (lambda (brk1)
          (let loop1 ()
            (when (and (_lt i 2) (not done))
              (if computer
                (begin
                  (set! choice 0)
                  (if (_lt total 18)
                    (begin
                      (set! choice (+ (modulo (now ) 3) 1))
                    )
                    (begin
                      (set! choice (- 21 total))
                    )
                  )
                  (set! total (+ total choice))
                  (begin (display (string-append "The computer chooses " (let ((s (open-output-string))) (write choice s) (get-output-string s)))) (newline))
                  (begin (display (string-append "Running total is now " (let ((s (open-output-string))) (write total s) (get-output-string s)))) (newline))
                  (when (equal? total 21)
                    (begin (display "\nSo, commiserations, the computer has won!") (newline))
                    (set! done #t)
                  )
                )
                (begin
                  (call/cc (lambda (brk2)
                    (let loop2 ()
                      (when #t
                        (begin (display "Your choice 1 to 3 : ") (newline))
                        (set! line (read-line))
                        (when (or (equal? line "q") (equal? line "Q"))
                          (begin (display "OK, quitting the game") (newline))
                          (set! done #t)
                          (brk2 '())
                        )
                        (set! num (parseIntStr line))
                        (when (or (_lt num 1) (_gt num 3))
                          (if (_gt (+ total num) 21)
                            (begin
                              (begin (display "Too big, try again") (newline))
                            )
                            (begin
                              (begin (display "Out of range, try again") (newline))
                            )
                          )
                          (loop2)
                        )
                        (when (_gt (+ total num) 21)
                          (begin (display "Too big, try again") (newline))
                          (loop2)
                        )
                        (set! total (+ total num))
                        (begin (display (string-append "Running total is now " (let ((s (open-output-string))) (write total s) (get-output-string s)))) (newline))
                        (brk2 '())
                        (loop2))
                      )
                    )
                  )
                  (when (equal? total 21)
                    (begin (display "\nSo, congratulations, you've won!") (newline))
                    (set! done #t)
                  )
                )
              )
              (begin (display "\n") (newline))
              (set! computer (not computer))
              (set! i (+ i 1))
              (loop1))
            )
          )
        )
        (set! round (+ round 1))
        (loop0))
      )
    )
  )
))
)

(main )
