; Generated by Mochi compiler v0.10.30 on 2025-07-18T18:26:51Z
(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))

(define (newNum n)
  (call/cc (lambda (return)
    (return (list (cons "op" OP_NUM) (cons "value" (list (cons "num" n) (cons "denom" 1)))))
  ))
)

(define (exprEval x)
  (call/cc (lambda (return)
    (define l '())
    (define r '())
    (when (equal? (map-get x "op") OP_NUM)
      (return (map-get x "value"))
    )
    (set! l (exprEval (map-get x "left")))
    (set! r (exprEval (map-get x "right")))
    (when (equal? (map-get x "op") OP_ADD)
      (return (list (cons "num" (+ (* (list-ref l "num") (list-ref r "denom")) (* (list-ref l "denom") (list-ref r "num")))) (cons "denom" (* (list-ref l "denom") (list-ref r "denom")))))
    )
    (when (equal? (map-get x "op") OP_SUB)
      (return (list (cons "num" (- (* (list-ref l "num") (list-ref r "denom")) (* (list-ref l "denom") (list-ref r "num")))) (cons "denom" (* (list-ref l "denom") (list-ref r "denom")))))
    )
    (when (equal? (map-get x "op") OP_MUL)
      (return (list (cons "num" (* (list-ref l "num") (list-ref r "num"))) (cons "denom" (* (list-ref l "denom") (list-ref r "denom")))))
    )
    (return (list (cons "num" (* (list-ref l "num") (list-ref r "denom"))) (cons "denom" (* (list-ref l "denom") (list-ref r "num")))))
  ))
)

(define (exprString x)
  (call/cc (lambda (return)
    (define ls '())
    (define opstr '())
    (define rs '())
    (when (equal? (map-get x "op") OP_NUM)
      (return (let ((s (open-output-string))) (write (map-get (map-get x "value") "num") s) (get-output-string s)))
    )
    (set! ls (exprString (map-get x "left")))
    (set! rs (exprString (map-get x "right")))
    (set! opstr "")
    (if (equal? (map-get x "op") OP_ADD)
      (begin
        (set! opstr " + ")
      )
      (if (equal? (map-get x "op") OP_SUB)
        (begin
          (set! opstr " - ")
        )
        (if (equal? (map-get x "op") OP_MUL)
          (begin
            (set! opstr " * ")
          )
          (begin
            (set! opstr " / ")
          )
        )
      )
    )
    (return (string-append (string-append (string-append (string-append "(" ls) opstr) rs) ")"))
  ))
)

(define (solve xs)
  (call/cc (lambda (return)
    (define a '())
    (define b '())
    (define f '())
    (define i '())
    (define j '())
    (define k '())
    (define node '())
    (define rest '())
    (when (equal? (length xs) 1)
      (set! f (exprEval (list-ref xs 0)))
      (when (and (not (equal? (list-ref f "denom") 0)) (equal? (list-ref f "num") (* (list-ref f "denom") goal)))
        (begin (display (exprString (list-ref xs 0))) (newline))
        (return #t)
      )
      (return #f)
    )
    (set! i 0)
    (let loop ()
      (if (< i (length xs))
        (begin
          (set! j (+ i 1))
          (let loop ()
            (if (< j (length xs))
              (begin
                (set! rest (list ))
                (set! k 0)
                (let loop ()
                  (if (< k (length xs))
                    (begin
                      (when (and (not (equal? k i)) (not (equal? k j)))
                        (set! rest (append rest (list (list-ref xs k))))
                      )
                      (set! k (+ k 1))
                      (loop)
                    )
                  '()
                )
              )
              (set! a (list-ref xs i))
              (set! b (list-ref xs j))
              (let loop ((op_idx 0))
                (if (< op_idx (length (list OP_ADD OP_SUB OP_MUL OP_DIV)))
                  (begin
                    (let ((op (list-ref (list OP_ADD OP_SUB OP_MUL OP_DIV) op_idx)))
                      (set! node (list (cons "op" op) (cons "left" a) (cons "right" b)))
                      (when (solve (append rest (list node)))
                        (return #t)
                      )
                    )
                    (loop (+ op_idx 1))
                  )
                '()
                )
              )
              (set! node (list (cons "op" OP_SUB) (cons "left" b) (cons "right" a)))
              (when (solve (append rest (list node)))
                (return #t)
              )
              (set! node (list (cons "op" OP_DIV) (cons "left" b) (cons "right" a)))
              (when (solve (append rest (list node)))
                (return #t)
              )
              (set! j (+ j 1))
              (loop)
            )
          '()
        )
      )
      (set! i (+ i 1))
      (loop)
    )
  '()
)
)
(return #f)
))
)

(define (main )
(call/cc (lambda (return)
(define cards '())
(define i '())
(define iter '())
(define n '())
(set! iter 0)
(let loop ()
(if (< iter 10)
  (begin
    (set! cards (list ))
    (set! i 0)
    (let loop ()
      (if (< i n_cards)
        (begin
          (set! n (+ (modulo (now) (- digit_range 1)) 1))
          (set! cards (append cards (list (newNum n))))
          (begin (display (string-append " " (let ((s (open-output-string))) (write n s) (get-output-string s)))) (newline))
          (set! i (+ i 1))
          (loop)
        )
      '()
    )
  )
  (begin (display ":  ") (newline))
  (when (not (solve cards))
    (begin (display "No solution") (newline))
  )
  (set! iter (+ iter 1))
  (loop)
)
'()
)
)
))
)

(define OP_ADD '())
(define OP_DIV '())
(define OP_MUL '())
(define OP_NUM '())
(define OP_SUB '())
(define digit_range '())
(define goal '())
(define n_cards '())
(set! OP_NUM 0)
(set! OP_ADD 1)
(set! OP_SUB 2)
(set! OP_MUL 3)
(set! OP_DIV 4)
(set! n_cards 4)
(set! goal 24)
(set! digit_range 9)
(main )
