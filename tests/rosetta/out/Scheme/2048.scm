; Generated by Mochi compiler v0.10.30 on 2025-07-18T18:26:49Z
(define (list-set lst idx val)
    (let loop ((i idx) (l lst))
        (if (null? l)
            '()
            (if (= i 0)
                (cons val (cdr l))
                (cons (car l) (loop (- i 1) (cdr l))))))
)
(define (map-get m k)
    (let ((p (assoc k m)))
        (if p (cdr p) '()))
)
(define (map-set m k v)
    (let ((p (assoc k m)))
        (if p
            (begin (set-cdr! p v) m)
            (cons (cons k v) m)))
)
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))

(define (newBoard )
  (call/cc (lambda (return)
    (define b '())
    (define row '())
    (define x '())
    (define y '())
    (set! b (list ))
    (set! y 0)
    (let loop ()
      (if (< y SIZE)
        (begin
          (set! row (list ))
          (set! x 0)
          (let loop ()
            (if (< x SIZE)
              (begin
                (set! row (append row (list 0)))
                (set! x (+ x 1))
                (loop)
              )
            '()
          )
        )
        (set! b (append b (list row)))
        (set! y (+ y 1))
        (loop)
      )
    '()
  )
)
(return b)
))
)

(define (spawnTile b)
(call/cc (lambda (return)
(define cell '())
(define empty '())
(define idx '())
(define val '())
(define x '())
(define y '())
(set! empty (list ))
(set! y 0)
(let loop ()
  (if (< y SIZE)
    (begin
      (set! x 0)
      (let loop ()
        (if (< x SIZE)
          (begin
            (when (equal? (list-ref (list-ref b y) x) 0)
              (set! empty (append empty (list (list x y))))
            )
            (set! x (+ x 1))
            (loop)
          )
        '()
      )
    )
    (set! y (+ y 1))
    (loop)
  )
'()
)
)
(when (equal? (length empty) 0)
(return (list (cons "board" b) (cons "full" #t)))
)
(set! idx (modulo (now) (length empty)))
(set! cell (list-ref empty idx))
(set! val 4)
(when (< (modulo (now) 10) 9)
(set! val 2)
)
(set! b (list-set b (list-ref cell 1) (list-set (list-ref b (list-ref cell 1)) (list-ref cell 0) val)))
(return (list (cons "board" b) (cons "full" (equal? (length empty) 1))))
))
)

(define (pad n)
(call/cc (lambda (return)
(define i '())
(define out '())
(define pad '())
(define s '())
(set! s (let ((s (open-output-string))) (write n s) (get-output-string s)))
(set! pad (- 4 (string-length s)))
(set! i 0)
(set! out "")
(let loop ()
(if (< i pad)
(begin
  (set! out (string-append out " "))
  (set! i (+ i 1))
  (loop)
)
'()
)
)
(return (string-append out s))
))
)

(define (draw b score)
(call/cc (lambda (return)
(define line '())
(define v '())
(define x '())
(define y '())
(begin (display (string-append "Score: " (let ((s (open-output-string))) (write score s) (get-output-string s)))) (newline))
(set! y 0)
(let loop ()
(if (< y SIZE)
(begin
(begin (display "+----+----+----+----+") (newline))
(set! line "|")
(set! x 0)
(let loop ()
  (if (< x SIZE)
    (begin
      (set! v (list-ref (list-ref b y) x))
      (if (equal? v 0)
        (begin
          (set! line (string-append line "    |"))
        )
        (begin
          (set! line (string-append (string-append line (pad v)) "|"))
        )
      )
      (set! x (+ x 1))
      (loop)
    )
  '()
)
)
(begin (display line) (newline))
(set! y (+ y 1))
(loop)
)
'()
)
)
(begin (display "+----+----+----+----+") (newline))
(begin (display "W=Up S=Down A=Left D=Right Q=Quit") (newline))
))
)

(define (reverseRow r)
(call/cc (lambda (return)
(define i '())
(define out '())
(set! out (list ))
(set! i (- (length r) 1))
(let loop ()
(if (>= i 0)
(begin
(set! out (append out (list (map-get r i))))
(set! i (- i 1))
(loop)
)
'()
)
)
(return out)
))
)

(define (slideLeft row)
(call/cc (lambda (return)
(define gain '())
(define i '())
(define res '())
(define v '())
(define xs '())
(set! xs (list ))
(set! i 0)
(let loop ()
(if (< i (length row))
(begin
(when (not (equal? (list-ref row i) 0))
(set! xs (append xs (list (list-ref row i))))
)
(set! i (+ i 1))
(loop)
)
'()
)
)
(set! res (list ))
(set! gain 0)
(set! i 0)
(let loop ()
(if (< i (length xs))
(begin
(if (and (< (+ i 1) (length xs)) (equal? (list-ref xs i) (list-ref xs (+ i 1))))
(begin
(set! v (* (list-ref xs i) 2))
(set! gain (+ gain v))
(set! res (append res (list v)))
(set! i (+ i 2))
)
(begin
(set! res (append res (list (list-ref xs i))))
(set! i (+ i 1))
)
)
(loop)
)
'()
)
)
(let loop ()
(if (< (length res) SIZE)
(begin
(set! res (append res (list 0)))
(loop)
)
'()
)
)
(return (list (cons "row" res) (cons "gain" gain)))
))
)

(define (moveLeft b score)
(call/cc (lambda (return)
(define moved '())
(define new '())
(define r '())
(define x '())
(define y '())
(set! moved #f)
(set! y 0)
(let loop ()
(if (< y SIZE)
(begin
(set! r (slideLeft (list-ref b y)))
(set! new (map-get r "row"))
(set! score (+ score (map-get r "gain")))
(set! x 0)
(let loop ()
(if (< x SIZE)
(begin
(when (not (equal? (list-ref (list-ref b y) x) (map-get new x)))
(set! moved #t)
)
(set! b (list-set b y (list-set (list-ref b y) x (map-get new x))))
(set! x (+ x 1))
(loop)
)
'()
)
)
(set! y (+ y 1))
(loop)
)
'()
)
)
(return (list (cons "board" b) (cons "score" score) (cons "moved" moved)))
))
)

(define (moveRight b score)
(call/cc (lambda (return)
(define moved '())
(define r '())
(define rev '())
(define x '())
(define y '())
(set! moved #f)
(set! y 0)
(let loop ()
(if (< y SIZE)
(begin
(set! rev (reverseRow (list-ref b y)))
(set! r (slideLeft rev))
(set! rev (map-get r "row"))
(set! score (+ score (map-get r "gain")))
(set! rev (reverseRow rev))
(set! x 0)
(let loop ()
(if (< x SIZE)
(begin
(when (not (equal? (list-ref (list-ref b y) x) (map-get rev x)))
(set! moved #t)
)
(set! b (list-set b y (list-set (list-ref b y) x (map-get rev x))))
(set! x (+ x 1))
(loop)
)
'()
)
)
(set! y (+ y 1))
(loop)
)
'()
)
)
(return (list (cons "board" b) (cons "score" score) (cons "moved" moved)))
))
)

(define (getCol b x)
(call/cc (lambda (return)
(define col '())
(define y '())
(set! col (list ))
(set! y 0)
(let loop ()
(if (< y SIZE)
(begin
(set! col (append col (list (list-ref (list-ref b y) x))))
(set! y (+ y 1))
(loop)
)
'()
)
)
(return col)
))
)

(define (setCol b x col)
(call/cc (lambda (return)
(define y '())
(set! y 0)
(let loop ()
(if (< y SIZE)
(begin
(set! b (list-set b y (list-set (list-ref b y) x (list-ref col y))))
(set! y (+ y 1))
(loop)
)
'()
)
)
))
)

(define (moveUp b score)
(call/cc (lambda (return)
(define col '())
(define moved '())
(define new '())
(define r '())
(define x '())
(define y '())
(set! moved #f)
(set! x 0)
(let loop ()
(if (< x SIZE)
(begin
(set! col (getCol b x))
(set! r (slideLeft col))
(set! new (map-get r "row"))
(set! score (+ score (map-get r "gain")))
(set! y 0)
(let loop ()
(if (< y SIZE)
(begin
(when (not (equal? (list-ref (list-ref b y) x) (map-get new y)))
(set! moved #t)
)
(set! b (list-set b y (list-set (list-ref b y) x (map-get new y))))
(set! y (+ y 1))
(loop)
)
'()
)
)
(set! x (+ x 1))
(loop)
)
'()
)
)
(return (list (cons "board" b) (cons "score" score) (cons "moved" moved)))
))
)

(define (moveDown b score)
(call/cc (lambda (return)
(define col '())
(define moved '())
(define r '())
(define x '())
(define y '())
(set! moved #f)
(set! x 0)
(let loop ()
(if (< x SIZE)
(begin
(set! col (reverseRow (getCol b x)))
(set! r (slideLeft col))
(set! col (map-get r "row"))
(set! score (+ score (map-get r "gain")))
(set! col (reverseRow col))
(set! y 0)
(let loop ()
(if (< y SIZE)
(begin
(when (not (equal? (list-ref (list-ref b y) x) (map-get col y)))
(set! moved #t)
)
(set! b (list-set b y (list-set (list-ref b y) x (map-get col y))))
(set! y (+ y 1))
(loop)
)
'()
)
)
(set! x (+ x 1))
(loop)
)
'()
)
)
(return (list (cons "board" b) (cons "score" score) (cons "moved" moved)))
))
)

(define (hasMoves b)
(call/cc (lambda (return)
(define x '())
(define y '())
(set! y 0)
(let loop ()
(if (< y SIZE)
(begin
(set! x 0)
(let loop ()
(if (< x SIZE)
(begin
(when (equal? (list-ref (list-ref b y) x) 0)
(return #t)
)
(when (and (< (+ x 1) SIZE) (equal? (list-ref (list-ref b y) x) (list-ref (list-ref b y) (+ x 1))))
(return #t)
)
(when (and (< (+ y 1) SIZE) (equal? (list-ref (list-ref b y) x) (list-ref (list-ref b (+ y 1)) x)))
(return #t)
)
(set! x (+ x 1))
(loop)
)
'()
)
)
(set! y (+ y 1))
(loop)
)
'()
)
)
(return #f)
))
)

(define (has2048 b)
(call/cc (lambda (return)
(define x '())
(define y '())
(set! y 0)
(let loop ()
(if (< y SIZE)
(begin
(set! x 0)
(let loop ()
(if (< x SIZE)
(begin
(when (>= (list-ref (list-ref b y) x) 2048)
(return #t)
)
(set! x (+ x 1))
(loop)
)
'()
)
)
(set! y (+ y 1))
(loop)
)
'()
)
)
(return #f)
))
)

(define SIZE '())
(define board '())
(define cmd '())
(define full '())
(define m '())
(define moved '())
(define r '())
(define r2 '())
(define score '())
(set! SIZE 4)
(set! board (newBoard ))
(set! r (spawnTile board))
(set! board (map-get r "board"))
(set! full (map-get r "full"))
(set! r (spawnTile board))
(set! board (map-get r "board"))
(set! full (map-get r "full"))
(set! score 0)
(draw board score)
(call/cc (lambda (brk0)
(let loop0 ()
(when #t
(begin (display "Move: ") (newline))
(set! cmd (read-line))
(set! moved #f)
(when (or (equal? cmd "a") (equal? cmd "A"))
(set! m (moveLeft board score))
(set! board (list-ref m "board"))
(set! score (list-ref m "score"))
(set! moved (list-ref m "moved"))
)
(when (or (equal? cmd "d") (equal? cmd "D"))
(set! m (moveRight board score))
(set! board (list-ref m "board"))
(set! score (list-ref m "score"))
(set! moved (list-ref m "moved"))
)
(when (or (equal? cmd "w") (equal? cmd "W"))
(set! m (moveUp board score))
(set! board (list-ref m "board"))
(set! score (list-ref m "score"))
(set! moved (list-ref m "moved"))
)
(when (or (equal? cmd "s") (equal? cmd "S"))
(set! m (moveDown board score))
(set! board (list-ref m "board"))
(set! score (list-ref m "score"))
(set! moved (list-ref m "moved"))
)
(when (or (equal? cmd "q") (equal? cmd "Q"))
(brk0 '())
)
(when moved
(set! r2 (spawnTile board))
(set! board (list-ref r2 "board"))
(set! full (list-ref r2 "full"))
(when (and full (not (hasMoves board)))
(draw board score)
(begin (display "Game Over") (newline))
(brk0 '())
)
)
(draw board score)
(when (has2048 board)
(begin (display "You win!") (newline))
(brk0 '())
)
(when (not (hasMoves board))
(begin (display "Game Over") (newline))
(brk0 '())
)
(loop0))
)
)
)
