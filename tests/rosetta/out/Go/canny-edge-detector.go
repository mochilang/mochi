//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 3
func conv2d(img [][]float64, k [][]float64) [][]float64 {
	h := len(any(img))
	w := len(any(img[0]))
	n := len(any(k))
	half := (float64(n) / float64(2))
	var out [][]float64 = [][]float64{}
	y := 0
	for y < h {
		var row []float64 = []float64{}
		x := 0
		for x < w {
			sum := 0.0
			j := 0
			for j < n {
				i := 0
				for i < n {
					yy := (float64((y + j)) - half)
					if yy < float64(0) {
						yy = float64(float64(float64(0)))
					}
					if yy >= float64(h) {
						yy = float64(float64(float64((h - 1))))
					}
					xx := (float64((x + i)) - half)
					if xx < float64(0) {
						xx = float64(float64(float64(0)))
					}
					if xx >= float64(w) {
						xx = float64(float64(float64((w - 1))))
					}
					sum = (sum + (img[yy][xx] * k[j][i]))
					i = (i + 1)
				}
				j = (j + 1)
			}
			row = append(_toAnySlice(row), any(sum))
			x = (x + 1)
		}
		out = append(_toAnySlice(out), any(row))
		y = (y + 1)
	}
	return out
}

// line 39
func gradient(img [][]float64) [][]float64 {
	hx := [][]float64{[]float64{-1.0, 0.0, 1.0}, []float64{-2.0, 0.0, 2.0}, []float64{-1.0, 0.0, 1.0}}
	hy := [][]float64{[]float64{1.0, 2.0, 1.0}, []float64{0.0, 0.0, 0.0}, []float64{-1.0, -2.0, -1.0}}
	gx := conv2d(img, hx)
	gy := conv2d(img, hy)
	h := len(any(img))
	w := len(any(img[0]))
	var out [][]float64 = [][]float64{}
	y := 0
	for y < h {
		var row []float64 = []float64{}
		x := 0
		for x < w {
			g := ((gx[y][x] * gx[y][x]) + (gy[y][x] * gy[y][x]))
			row = append(_toAnySlice(row), any(g))
			x = (x + 1)
		}
		out = append(_toAnySlice(out), any(row))
		y = (y + 1)
	}
	return out
}

// line 62
func threshold(g [][]float64, t float64) [][]int {
	h := len(any(g))
	w := len(any(g[0]))
	var out [][]int = [][]int{}
	y := 0
	for y < h {
		var row []int = []int{}
		x := 0
		for x < w {
			if g[y][x] >= t {
				row = append(_toAnySlice(row), any(1))
			} else {
				row = append(_toAnySlice(row), any(0))
			}
			x = (x + 1)
		}
		out = append(_toAnySlice(out), any(row))
		y = (y + 1)
	}
	return out
}

// line 80
func printMatrix(m [][]int) {
	y := 0
	for y < len(any(m)) {
		line := ""
		x := 0
		for x < len(any(m[0])) {
			line = line + fmt.Sprint(any(m[y][x]))
			if x < (len(any(m[0])) - 1) {
				line = line + " "
			}
			x = (x + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
		y = (y + 1)
	}
}

// line 95
func main() {
	img := [][]float64{
		[]float64{
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
		},
		[]float64{
			0.0,
			255.0,
			255.0,
			255.0,
			0.0,
		},
		[]float64{
			0.0,
			255.0,
			255.0,
			255.0,
			0.0,
		},
		[]float64{
			0.0,
			255.0,
			255.0,
			255.0,
			0.0,
		},
		[]float64{
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
		},
	}
	g := gradient(img)
	edges := threshold(g, (1020.0 * 1020.0))
	printMatrix(edges)
}

func main() {
	PI := 3.141592653589793
	_ = PI
	main()
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
