//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func trimSpace(s string) string {
	start := 0
	for (start < len(s)) && (string([]rune(s)[start:(start+1)]) == " ") {
		start = (start + 1)
	}
	end := len(s)
	for (end > start) && (string([]rune(s)[(end-1):end]) == " ") {
		end = (end - 1)
	}
	return string([]rune(s)[start:end])
}

// line 16
func isUpper(ch string) bool {
	return ((ch >= "A") && (ch <= "Z"))
}

// line 20
func padLeft(s string, w int) string {
	res := ""
	n := (w - len(s))
	for n > 0 {
		res = res + " "
		n = (n - 1)
	}
	return res + s
}

// line 30
func snakeToCamel(s string) string {
	s = trimSpace(s)
	out := ""
	up := false
	i := 0
	for i < len(s) {
		ch := string([]rune(s)[i:(i + 1)])
		if (((ch == "_") || (ch == "-")) || (ch == " ")) || (ch == ".") {
			up = true
			i = (i + 1)
			continue
		}
		if i == 0 {
			out = out + strings.ToLower(ch)
			up = false
			i = (i + 1)
			continue
		}
		if up {
			out = out + strings.ToUpper(ch)
			up = false
		} else {
			out = out + ch
		}
		i = (i + 1)
	}
	return out
}

// line 59
func camelToSnake(s string) string {
	s = trimSpace(s)
	out := ""
	prevUnd := false
	i := 0
	for i < len(s) {
		ch := string([]rune(s)[i:(i + 1)])
		if ((ch == " ") || (ch == "-")) || (ch == ".") {
			if !prevUnd && (len(out) > 0) {
				out = out + "_"
				prevUnd = true
			}
			i = (i + 1)
			continue
		}
		if ch == "_" {
			if !prevUnd && (len(out) > 0) {
				out = out + "_"
				prevUnd = true
			}
			i = (i + 1)
			continue
		}
		if isUpper(ch) {
			if (i > 0) && (!prevUnd) {
				out = out + "_"
			}
			out = out + strings.ToLower(ch)
			prevUnd = false
		} else {
			out = out + strings.ToLower(ch)
			prevUnd = false
		}
		i = (i + 1)
	}
	start := 0
	for (start < len(out)) && (string([]rune(out)[start:(start+1)]) == "_") {
		start = (start + 1)
	}
	end := len(out)
	for (end > start) && (string([]rune(out)[(end-1):end]) == "_") {
		end = (end - 1)
	}
	out = string([]rune(out)[start:end])
	res := ""
	j := 0
	lastUnd := false
	for j < len(out) {
		c := string([]rune(out)[j:(j + 1)])
		if c == "_" {
			if !lastUnd {
				res = res + c
			}
			lastUnd = true
		} else {
			res = res + c
			lastUnd = false
		}
		j = (j + 1)
	}
	return res
}

// line 119
func main() {
	samples := []string{
		"snakeCase",
		"snake_case",
		"snake-case",
		"snake case",
		"snake CASE",
		"snake.case",
		"variable_10_case",
		"variable10Case",
		"É›rgo rE tHis",
		"hurry-up-joe!",
		"c://my-docs/happy_Flag-Day/12.doc",
		" spaces ",
	}
	fmt.Println("=== To snake_case ===")
	for _, s := range samples {
		fmt.Println(padLeft(s, 34) + " => " + camelToSnake(s))
	}
	fmt.Println("")
	fmt.Println("=== To camelCase ===")
	for _, s := range samples {
		fmt.Println(padLeft(s, 34) + " => " + snakeToCamel(s))
	}
}

func main() {
	main()
}
