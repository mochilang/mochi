//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
	"time"
)

type v map[string]any

func main() {
	nPts := 100
	rMin := 10
	rMax := 15
	span := ((rMax + 1) + rMax)
	var rows [][]string = [][]string{}
	r := 0
	for r < span {
		var row []string = []string{}
		c := 0
		for c < (span * 2) {
			row = append(_toAnySlice(row), any(" "))
			c = (c + 1)
		}
		rows = append(_toAnySlice(rows), any(row))
		r = (r + 1)
	}
	u := 0
	var seen map[string]bool = map[string]bool{}
	min2 := (rMin * rMin)
	max2 := (rMax * rMax)
	n := 0
	for n < nPts {
		x := (int64((int64(time.Now().UnixNano()) % int64(span))) - int64(rMax))
		y := (int64((int64(time.Now().UnixNano()) % int64(span))) - int64(rMax))
		rs := (int64((int64(x) * int64(x))) + int64((int64(y) * int64(y))))
		if (rs < min2) || (rs > max2) {
			continue
		}
		n = (n + 1)
		row := (int64(y) + int64(rMax))
		col := (int64((int64(x) + int64(rMax))) * int64(2))
		rows[row][col] = "*"
		key := fmt.Sprint(any(row)) + "," + fmt.Sprint(any(col))
		if !(seen[key]) {
			seen[key] = true
			u = (u + 1)
		}
	}
	i := 0
	for i < span {
		line := ""
		j := 0
		for j < (span * 2) {
			line = line + rows[i][j]
			j = (j + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
		i = (i + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(fmt.Sprint(any(u))+" unique points")), "\n"))
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
