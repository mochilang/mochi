//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func sqrtApprox(x float64) float64 {
	guess := x
	i := 0
	for i < 20 {
		guess = ((guess + (x / guess)) / 2.0)
		i = (i + 1)
	}
	return guess
}

// line 15
func makeSym(order int, elements []float64) map[string]any {
	return map[string]any{"order": order, "ele": elements}
}

// line 20
func unpackSym(m map[string]any) [][]float64 {
	n := m["order"]
	ele := m["ele"]
	var mat [][]float64 = [][]float64{}
	idx := 0
	r := 0
	for r < (n).(int) {
		var row []float64 = []float64{}
		c := 0
		for c <= r {
			row = _convSlice[any, float64](append(_toAnySlice(row), (ele).([]any)[idx]))
			idx = (idx + 1)
			c = (c + 1)
		}
		for c < (n).(int) {
			row = append(_toAnySlice(row), any(0.0))
			c = (c + 1)
		}
		mat = append(_toAnySlice(mat), any(row))
		r = (r + 1)
	}
	r = 0
	for r < (n).(int) {
		c := (r + 1)
		for c < (n).(int) {
			mat[r][c] = mat[c][r]
			c = (c + 1)
		}
		r = (r + 1)
	}
	return mat
}

// line 53
func printMat(m [][]float64) {
	i := 0
	for i < len(any(m)) {
		line := ""
		j := 0
		for j < len(any(m[i])) {
			line = line + fmt.Sprint(any(m[i][j]))
			if j < (len(any(m[i])) - 1) {
				line = line + " "
			}
			j = (j + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
		i = (i + 1)
	}
}

// line 68
func printSym(m map[string]any) {
	printMat(unpackSym(m))
}

// line 73
func printLower(m map[string]any) {
	n := m["order"]
	ele := m["ele"]
	var mat [][]float64 = [][]float64{}
	idx := 0
	r := 0
	for r < (n).(int) {
		var row []float64 = []float64{}
		c := 0
		for c <= r {
			row = _convSlice[any, float64](append(_toAnySlice(row), (ele).([]any)[idx]))
			idx = (idx + 1)
			c = (c + 1)
		}
		for c < (n).(int) {
			row = append(_toAnySlice(row), any(0.0))
			c = (c + 1)
		}
		mat = append(_toAnySlice(mat), any(row))
		r = (r + 1)
	}
	printMat(mat)
}

// line 98
func choleskyLower(a map[string]any) map[string]any {
	n := a["order"]
	ae := a["ele"]
	var le []float64 = []float64{}
	idx := 0
	for idx < len(ae) {
		le = append(_toAnySlice(le), any(0.0))
		idx = (idx + 1)
	}
	row := 1
	col := 1
	dr := 0
	dc := 0
	i := 0
	for i < len(ae) {
		e := (ae).([]any)[i]
		if i < dr {
			d := (float64(((e).(float64) - le[i])) / le[dc])
			le[i] = (((d).(float64)).(float64)).(float64)
			ci := col
			cx := dc
			j := (i + 1)
			for j <= dr {
				cx = (cx + ci)
				ci = (ci + 1)
				le[j] = float64(float64(float64((le[j] + ((d).(float64) * le[cx])))))
				j = (j + 1)
			}
			col = (col + 1)
			dc = (dc + col)
		} else {
			le[i] = sqrtApprox(float64(((e).(float64) - le[i])))
			row = (row + 1)
			dr = (dr + row)
			col = 1
			dc = 0
		}
		i = (i + 1)
	}
	return map[string]any{"order": n, "ele": le}
}

// line 141
func demo(a map[string]any) {
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("A:")), "\n"))
	printSym(a)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("L:")), "\n"))
	l := choleskyLower(a)
	printLower(l)
}

func main() {
	demo(makeSym(3, []float64{
		25.0,
		15.0,
		18.0,
		-5.0,
		0.0,
		11.0,
	}))
	demo(makeSym(4, []float64{
		18.0,
		22.0,
		70.0,
		54.0,
		86.0,
		174.0,
		42.0,
		62.0,
		134.0,
		106.0,
	}))
}

func _convSlice[T any, U any](s []T) []U {
	out := make([]U, len(s))
	for i, v := range s {
		out[i] = any(v).(U)
	}
	return out
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
