//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func neighborsList() [][]int {
	return [][]int{
		[]int{1, 3},
		[]int{0, 2, 4},
		[]int{1, 5},
		[]int{0, 4, 6},
		[]int{
			1,
			3,
			5,
			7,
		},
		[]int{2, 4, 8},
		[]int{3, 7},
		[]int{4, 6, 8},
		[]int{5, 7},
	}
}

// line 18
func plus(a []int, b []int) []int {
	var res []int = []int{}
	i := 0
	for i < len(any(a)) {
		res = append(_toAnySlice(res), any((a[i] + b[i])))
		i = (i + 1)
	}
	return res
}

// line 28
func isStable(p []int) bool {
	for _, v := range p {
		if v > 3 {
			return false
		}
	}
	return true
}

// line 35
func topple(p *[]int) int {
	neighbors := neighborsList()
	i := 0
	for i < len(any(p)) {
		if p[i] > 3 {
			p[i] = (p[i] - 4)
			nbs := neighbors[i]
			for _, j := range nbs {
				p[j] = (p[j] + 1)
			}
			return 0
		}
		i = (i + 1)
	}
	return 0
}

// line 52
func pileString(p []int) string {
	s := ""
	r := 0
	for r < 3 {
		c := 0
		for c < 3 {
			s = s + fmt.Sprint(any(p[((3*r)+c)])) + " "
			c = (c + 1)
		}
		s = s + "\n"
		r = (r + 1)
	}
	return s
}

func main() {
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Avalanche of topplings:\n")), "\n"))
	s4 := []int{
		4,
		3,
		3,
		3,
		1,
		2,
		0,
		2,
		3,
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(pileString(s4))), "\n"))
	for !(isStable(s4)) {
		topple(s4)
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(pileString(s4))), "\n"))
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Commutative additions:\n")), "\n"))
	s1 := []int{
		1,
		2,
		0,
		2,
		1,
		1,
		0,
		1,
		3,
	}
	s2 := []int{
		2,
		1,
		3,
		1,
		0,
		1,
		0,
		1,
		0,
	}
	s3_a := plus(s1, s2)
	for !(isStable(s3_a)) {
		topple(s3_a)
	}
	s3_b := plus(s2, s1)
	for !(isStable(s3_b)) {
		topple(s3_b)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(pileString(s1)+"\nplus\n\n"+pileString(s2)+"\nequals\n\n"+pileString(s3_a))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("and\n\n"+pileString(s2)+"\nplus\n\n"+pileString(s1)+"\nalso equals\n\n"+pileString(s3_b))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Addition of identity sandpile:\n")), "\n"))
	s3 := []int{
		3,
		3,
		3,
		3,
		3,
		3,
		3,
		3,
		3,
	}
	s3_id := []int{
		2,
		1,
		2,
		1,
		0,
		1,
		2,
		1,
		2,
	}
	s4b := plus(s3, s3_id)
	for !(isStable(s4b)) {
		topple(s4b)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(pileString(s3)+"\nplus\n\n"+pileString(s3_id)+"\nequals\n\n"+pileString(s4b))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Addition of identities:\n")), "\n"))
	s5 := plus(s3_id, s3_id)
	for !(isStable(s5)) {
		topple(s5)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(pileString(s3_id)+"\nplus\n\n"+pileString(s3_id)+"\nequals\n\n"+pileString(s5))), "\n"))
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
