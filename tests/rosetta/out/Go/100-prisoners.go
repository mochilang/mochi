//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
	"time"
)

type v map[string]any

// line 1
func shuffle(xs []int) []int {
	arr := xs
	i := 99
	for i > 0 {
		j := (int64(time.Now().UnixNano()) % int64((i + 1)))
		tmp := arr[i]
		arr[i] = arr[j]
		arr[j] = tmp
		i = (i - 1)
	}
	return arr
}

// line 14
func doTrials(trials int, np int, strategy string) {
	pardoned := 0
	t := 0
	for t < trials {
		var drawers []int = []int{}
		i := 0
		for i < 100 {
			drawers = append(_toAnySlice(drawers), any(i))
			i = (i + 1)
		}
		drawers = shuffle(drawers)
		p := 0
		success := true
		for p < np {
			found := false
			if strategy == "optimal" {
				prev := p
				d := 0
				for d < 50 {
					this := drawers[prev]
					if this == p {
						found = true
						break
					}
					prev = this
					d = (d + 1)
				}
			} else {
				var opened []bool = []bool{}
				k := 0
				for k < 100 {
					opened = append(_toAnySlice(opened), any(false))
					k = (k + 1)
				}
				d := 0
				for d < 50 {
					n := (int64(time.Now().UnixNano()) % int64(100))
					for opened[n] {
						n = (int64(time.Now().UnixNano()) % int64(100))
					}
					opened[n] = true
					if drawers[n] == p {
						found = true
						break
					}
					d = (d + 1)
				}
			}
			if !(found) {
				success = false
				break
			}
			p = (p + 1)
		}
		if success {
			pardoned = (pardoned + 1)
		}
		t = (t + 1)
	}
	rf := (((float64(pardoned)) / (float64(trials))) * 100.0)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("  strategy = "+strategy+"  pardoned = "+fmt.Sprint(any(pardoned))+" relative frequency = "+fmt.Sprint(any(rf))+"%")), "\n"))
}

// line 77
func main() {
	trials := 1000
	for _, np := range []int{10, 100} {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Results from "+"1000"+" trials with "+fmt.Sprint(any(np))+" prisoners:\n")), "\n"))
		for _, strat := range []string{"random", "optimal"} {
			doTrials(trials, np, strat)
		}
	}
}

func main() {
	main()
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
