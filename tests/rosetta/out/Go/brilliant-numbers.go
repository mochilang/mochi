//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"reflect"
	"strings"
)

type v map[string]any

// line 4
func primesUpTo(n int) []int {
	var sieve []bool = []bool{}
	i := 0
	for i <= n {
		sieve = append(sieve, true)
		i = (i + 1)
	}
	p := 2
	for (p * p) <= n {
		if sieve[p] {
			m := (p * p)
			for m <= n {
				sieve[m] = false
				m = (m + p)
			}
		}
		p = (p + 1)
	}
	var res []int = []int{}
	x := 2
	for x <= n {
		if sieve[x] {
			res = append(res, x)
		}
		x = (x + 1)
	}
	return res
}

// line 31
func sortInts(xs []int) []int {
	var res []int = []int{}
	tmp := xs
	for len(tmp) > 0 {
		min := tmp[0]
		idx := 0
		i := 1
		for i < len(tmp) {
			if tmp[i] < min {
				min = tmp[i]
				idx = i
			}
			i = (i + 1)
		}
		res = append(res, min)
		var out []int = []int{}
		j := 0
		for j < len(tmp) {
			if j != idx {
				out = append(out, tmp[j])
			}
			j = (j + 1)
		}
		tmp = out
	}
	return res
}

// line 57
func commatize(n int) string {
	s := fmt.Sprint(n)
	i := (len(s) - 3)
	for i >= 1 {
		s = string([]rune(s)[0:i]) + "," + string([]rune(s)[i:len(s)])
		i = (i - 3)
	}
	return s
}

// line 69
func getBrilliant(digits int, limit int, countOnly bool) map[string]any {
	var brilliant []int = []int{}
	count := 0
	pow := 1
	next := 999999999999999
	k := 1
	for k <= digits {
		var s []int = []int{}
		for _, p := range primes {
			if p >= (pow * 10) {
				break
			}
			if p > pow {
				s = append(s, p)
			}
		}
		i := 0
		for i < len(s) {
			j := i
			for j < len(s) {
				prod := (s[i] * s[j])
				if prod < limit {
					if countOnly {
						count = (count + 1)
					} else {
						brilliant = append(brilliant, prod)
					}
				} else {
					if prod < next {
						next = prod
					}
					break
				}
				j = (j + 1)
			}
			i = (i + 1)
		}
		pow = (pow * 10)
		k = (k + 1)
	}
	if countOnly {
		return map[string]int{"bc": count, "next": next}
	}
	return map[string]any{"bc": brilliant, "next": next}
}

// line 107
func main() {
	fmt.Println("First 100 brilliant numbers:")
	r := getBrilliant(2, 10000, false)
	br := sortInts((r["bc"]).([]int))
	br = br[0:100]
	i := 0
	for i < len(br) {
		fmt.Println(fmt.Sprint(fmt.Sprint(br[i])(4, " "))+" ", false)
		if ((i + 1) % 10) == 0 {
			fmt.Println("", true)
		}
		i = (i + 1)
	}
	fmt.Println("", true)
	k := 1
	for k <= 13 {
		limit := pow(10, k)
		r2 := getBrilliant(k, (limit).(int), true)
		total := r2["bc"]
		next := r2["next"]
		climit := commatize((limit).(int))
		_ = climit
		ctotal := commatize(int(((total).(float64) + float64(1))))
		_ = ctotal
		cnext := commatize((next).(int))
		_ = cnext
		fmt.Println("First >= " + fmt.Sprint(_getField(climit, "padStart")(18, " ")) + " is " + fmt.Sprint(_getField(ctotal, "padStart")(14, " ")) + " in the series: " + fmt.Sprint(_getField(cnext, "padStart")(18, " ")))
		k = (k + 1)
	}
}

var primes []int

func main() {
	primes = primesUpTo(3200000)
}

func _convertMapAny(m map[any]any) map[string]any {
	out := make(map[string]any, len(m))
	for k, v := range m {
		key := fmt.Sprint(k)
		if sub, ok := v.(map[any]any); ok {
			out[key] = _convertMapAny(sub)
		} else {
			out[key] = v
		}
	}
	return out
}

func _getField(v any, name string) any {
	switch m := v.(type) {
	case map[string]any:
		return m[name]
	case map[string]string:
		if s, ok := m[name]; ok {
			return s
		}
	case map[any]any:
		return _convertMapAny(m)[name]
	default:
		rv := reflect.ValueOf(m)
		if rv.Kind() == reflect.Struct {
			rt := rv.Type()
			for i := 0; i < rv.NumField(); i++ {
				fn := rt.Field(i)
				field := fn.Name
				if tag := fn.Tag.Get("json"); tag != "" {
					if c := strings.Index(tag, ","); c >= 0 {
						tag = tag[:c]
					}
					if tag != "-" {
						field = tag
					}
				}
				if field == name {
					return rv.Field(i).Interface()
				}
			}
		}
	}
	return nil
}
