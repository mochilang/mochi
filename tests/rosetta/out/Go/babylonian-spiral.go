//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func push(h *[]map[string]int, it map[string]int) []map[string]int {
	h = append(_toAnySlice(h), any(it))
	i := (len(any(h)) - 1)
	for (i > 0) && (h[(i - 1)]["s"] > h[i]["s"]) {
		tmp := h[(i - 1)]
		h[(i - 1)] = h[i]
		h[i] = tmp
		i = (i - 1)
	}
	return h
}

// line 16
func step(h []map[string]int, nv int, dir []int) map[string]any {
	for (len(any(h)) == 0) || ((nv * nv) <= h[0]["s"]) {
		h = push(h, map[string]int{
			"s": (nv * nv),
			"a": nv,
			"b": 0,
		})
		nv = (nv + 1)
	}
	s := h[0]["s"]
	var v [][]int = [][]int{}
	for (len(any(h)) > 0) && (h[0]["s"] == s) {
		it := h[0]
		h = h[1:len(h)]
		v = append(_toAnySlice(v), any([]int{it["a"], it["b"]}))
		if it["a"] > it["b"] {
			h = push(h, map[string]int{
				"s": ((it["a"] * it["a"]) + ((it["b"] + 1) * (it["b"] + 1))),
				"a": it["a"],
				"b": (it["b"] + 1),
			})
		}
	}
	var list [][]int = [][]int{}
	for _, p := range v {
		list = append(_toAnySlice(list), any(p))
	}
	var temp [][]int = list
	for _, p := range temp {
		if p[0] != p[1] {
			list = append(_toAnySlice(list), any([]int{p[1], p[0]}))
		}
	}
	temp = list
	for _, p := range temp {
		if p[1] != 0 {
			list = append(_toAnySlice(list), any([]int{p[0], -p[1]}))
		}
	}
	temp = list
	for _, p := range temp {
		if p[0] != 0 {
			list = append(_toAnySlice(list), any([]int{-p[0], p[1]}))
		}
	}
	bestDot := -999999999
	best := dir
	for _, p := range list {
		cross := ((p[0] * dir[1]) - (p[1] * dir[0]))
		if cross >= 0 {
			dot := ((p[0] * dir[0]) + (p[1] * dir[1]))
			if dot > bestDot {
				bestDot = dot
				best = p
			}
		}
	}
	return map[string]any{
		"d":    best,
		"heap": h,
		"n":    nv,
	}
}

// line 57
func positions(n int) [][]int {
	var pos [][]int = [][]int{}
	x := 0
	y := 0
	var dir []int = []int{0, 1}
	var heap []map[string]int = []map[string]int{}
	nv := 1
	i := 0
	for i < n {
		pos = append(_toAnySlice(pos), any([]int{x, y}))
		st := step(heap, nv, dir)
		dir = (st["d"]).([]int)
		heap = (st["heap"]).([]map[string]int)
		nv = (st["n"]).(int)
		x = (x + dir[0])
		y = (y + dir[1])
		i = (i + 1)
	}
	return pos
}

// line 78
func pad(s string, w int) string {
	r := s
	for len(any(r)) < w {
		r = r + " "
	}
	return r
}

// line 84
func main() {
	pts := positions(40)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("The first 40 Babylonian spiral points are:")), "\n"))
	line := ""
	i := 0
	for i < len(any(pts)) {
		p := pts[i]
		s := pad("("+fmt.Sprint(any(p[0]))+", "+fmt.Sprint(any(p[1]))+")", 10)
		line = line + s
		if ((i + 1) % 10) == 0 {
			fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
			line = ""
		}
		i = (i + 1)
	}
}

func main() {
	main()
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
