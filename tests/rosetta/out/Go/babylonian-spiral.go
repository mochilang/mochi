//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
)

type v map[string]any

// line 4
func push(h *[]map[string]int, it map[string]int) []map[string]int {
	h = append(h, it)
	i := (len(h) - 1)
	for (i > 0) && (h[(i - 1)]["s"] > h[i]["s"]) {
		tmp := h[(i - 1)]
		h[(i - 1)] = h[i]
		h[i] = tmp
		i = (i - 1)
	}
	return h
}

// line 16
func step(h []map[string]int, nv int, dir []int) map[string]any {
	for (len(h) == 0) || ((nv * nv) <= h[0]["s"]) {
		h = push(h, map[string]int{
			"s": (nv * nv),
			"a": nv,
			"b": 0,
		})
		nv = (nv + 1)
	}
	s := h[0]["s"]
	var v [][]int = [][]int{}
	for (len(h) > 0) && (h[0]["s"] == s) {
		it := h[0]
		h = h[1:len(h)]
		v = append(v, []int{it["a"], it["b"]})
		if it["a"] > it["b"] {
			h = push(h, map[string]int{
				"s": ((it["a"] * it["a"]) + ((it["b"] + 1) * (it["b"] + 1))),
				"a": it["a"],
				"b": (it["b"] + 1),
			})
		}
	}
	var list [][]int = [][]int{}
	for _, p := range v {
		list = append(list, p)
	}
	var temp [][]int = list
	for _, p := range temp {
		if p[0] != p[1] {
			list = append(list, []int{p[1], p[0]})
		}
	}
	temp = list
	for _, p := range temp {
		if p[1] != 0 {
			list = append(list, []int{p[0], -p[1]})
		}
	}
	temp = list
	for _, p := range temp {
		if p[0] != 0 {
			list = append(list, []int{-p[0], p[1]})
		}
	}
	bestDot := -999999999
	best := dir
	for _, p := range list {
		cross := ((p[0] * dir[1]) - (p[1] * dir[0]))
		if cross >= 0 {
			dot := ((p[0] * dir[0]) + (p[1] * dir[1]))
			if dot > bestDot {
				bestDot = dot
				best = p
			}
		}
	}
	return map[string]any{
		"d":    best,
		"heap": h,
		"n":    nv,
	}
}

// line 57
func positions(n int) [][]int {
	var pos [][]int = [][]int{}
	x := 0
	y := 0
	var dir []int = []int{0, 1}
	var heap []map[string]int = []map[string]int{}
	nv := 1
	i := 0
	for i < n {
		pos = append(pos, []int{x, y})
		st := step(heap, nv, dir)
		dir = (st["d"]).([]int)
		heap = (st["heap"]).([]map[string]int)
		nv = (st["n"]).(int)
		x = (x + dir[0])
		y = (y + dir[1])
		i = (i + 1)
	}
	return pos
}

// line 78
func pad(s string, w int) string {
	r := s
	for len(r) < w {
		r = r + " "
	}
	return r
}

// line 84
func main() {
	pts := positions(40)
	fmt.Println("The first 40 Babylonian spiral points are:")
	line := ""
	i := 0
	for i < len(pts) {
		p := pts[i]
		s := pad("("+fmt.Sprint(p[0])+", "+fmt.Sprint(p[1])+")", 10)
		line = line + s
		if ((i + 1) % 10) == 0 {
			fmt.Println(line)
			line = ""
		}
		i = (i + 1)
	}
}

func main() {
	main()
}
