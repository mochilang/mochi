//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"mochi/runtime/data"
	"reflect"
	"strings"
)

type v map[string]any

type Point struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
}
type QuadSpline struct {
	C0 float64 `json:"c0"`
	C1 float64 `json:"c1"`
	C2 float64 `json:"c2"`
}
type QuadCurve struct {
	X QuadSpline `json:"x"`
	Y QuadSpline `json:"y"`
}

// line 5
func absf(x float64) float64 {
	if x < 0.0 {
		return -x
	}
	return x
}

// line 10
func maxf(a float64, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

// line 15
func minf(a float64, b float64) float64 {
	if a < b {
		return a
	}
	return b
}

// line 20
func max3(a float64, b float64, c float64) float64 {
	m := a
	if b > m {
		m = b
	}
	if c > m {
		m = c
	}
	return m
}

// line 27
func min3(a float64, b float64, c float64) float64 {
	m := a
	if b < m {
		m = b
	}
	if c < m {
		m = c
	}
	return m
}

// line 51
func subdivideQuadSpline(q QuadSpline, t float64) []QuadSpline {
	s := (1.0 - t)
	u := QuadSpline{C0: q.C0, C1: 0.0, C2: 0.0}
	v := QuadSpline{C0: 0.0, C1: 0.0, C2: q.C2}
	u.C1 = ((s * q.C0) + (t * q.C1))
	v.C1 = ((s * q.C1) + (t * q.C2))
	u.C2 = ((s * u.C1) + (t * v.C1))
	v.C0 = u.C2
	return []QuadSpline{u, v}
}

// line 62
func subdivideQuadCurve(q QuadCurve, t float64) []QuadCurve {
	xs := subdivideQuadSpline(&q.X, t)
	ys := subdivideQuadSpline(&q.Y, t)
	u := QuadCurve{X: xs[0], Y: ys[0]}
	v := QuadCurve{X: xs[1], Y: ys[1]}
	return []QuadCurve{u, v}
}

// line 70
func rectsOverlap(xa0 float64, ya0 float64, xa1 float64, ya1 float64, xb0 float64, yb0 float64, xb1 float64, yb1 float64) bool {
	return ((((xb0 <= xa1) && (xa0 <= xb1)) && (yb0 <= ya1)) && (ya0 <= yb1))
}

// line 75
func testIntersect(p QuadCurve, q QuadCurve, tol float64) map[string]any {
	pxmin := min3(p.X.C0, p.X.C1, p.X.C2)
	pymin := min3(p.Y.C0, p.Y.C1, p.Y.C2)
	pxmax := max3(p.X.C0, p.X.C1, p.X.C2)
	pymax := max3(p.Y.C0, p.Y.C1, p.Y.C2)
	qxmin := min3(q.X.C0, q.X.C1, q.X.C2)
	qymin := min3(q.Y.C0, q.Y.C1, q.Y.C2)
	qxmax := max3(q.X.C0, q.X.C1, q.X.C2)
	qymax := max3(q.Y.C0, q.Y.C1, q.Y.C2)
	exclude := true
	accept := false
	inter := Point{X: 0.0, Y: 0.0}
	if rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax) {
		exclude = false
		xmin := maxf(pxmin, qxmin)
		xmax := minf(pxmax, qxmax)
		if (xmax - xmin) <= tol {
			ymin := maxf(pymin, qymin)
			ymax := minf(pymax, qymax)
			if (ymax - ymin) <= tol {
				accept = true
				inter.X = (0.5 * (xmin + xmax))
				inter.Y = (0.5 * (ymin + ymax))
			}
		}
	}
	return map[string]any{
		"exclude":   exclude,
		"accept":    accept,
		"intersect": inter,
	}
}

// line 106
func seemsToBeDuplicate(pts []Point, xy Point, spacing float64) bool {
	i := 0
	for i < len(any(pts)) {
		pt := pts[i]
		_ = pt
		if (absf((pt.X - xy.X)) < spacing) && (absf((pt.Y - xy.Y)) < spacing) {
			return true
		}
		i = (i + 1)
	}
	return false
}

// line 118
func findIntersects(p QuadCurve, q QuadCurve, tol float64, spacing float64) []Point {
	var inters []Point = []Point{}
	var workload []map[string]QuadCurve = []map[string]QuadCurve{map[string]QuadCurve{"p": p, "q": q}}
	for len(any(workload)) > 0 {
		idx := (len(any(workload)) - 1)
		work := workload[idx]
		workload = workload[0:idx]
		res := testIntersect(&work["p"], &work["q"], tol)
		excl := res["exclude"]
		acc := res["accept"]
		inter := (res["intersect"]).(Point)
		if _exists(acc) {
			if !(seemsToBeDuplicate(inters, &inter, spacing)) {
				inters = append(_toAnySlice(inters), any(inter))
			}
		} else if _exists(!((excl).(bool))) {
			ps := subdivideQuadCurve(&work["p"], 0.5)
			qs := subdivideQuadCurve(&work["q"], 0.5)
			p0 := ps[0]
			p1 := ps[1]
			q0 := qs[0]
			q1 := qs[1]
			workload = append(_toAnySlice(workload), any(map[string]QuadCurve{"p": p0, "q": q0}))
			workload = append(_toAnySlice(workload), any(map[string]QuadCurve{"p": p0, "q": q1}))
			workload = append(_toAnySlice(workload), any(map[string]QuadCurve{"p": p1, "q": q0}))
			workload = append(_toAnySlice(workload), any(map[string]QuadCurve{"p": p1, "q": q1}))
		}
	}
	return inters
}

// line 149
func main() {
	p := QuadCurve{X: QuadSpline{C0: -1.0, C1: 0.0, C2: 1.0}, Y: QuadSpline{C0: 0.0, C1: 10.0, C2: 0.0}}
	q := QuadCurve{X: QuadSpline{C0: 2.0, C1: -8.0, C2: 2.0}, Y: QuadSpline{C0: 1.0, C1: 2.0, C2: 3.0}}
	tol := 0.0000001
	spacing := (tol * 10.0)
	inters := findIntersects(&p, &q, tol, spacing)
	i := 0
	for i < len(any(inters)) {
		pt := inters[i]
		_ = pt
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("("+fmt.Sprint(any(pt.X))+", "+fmt.Sprint(any(pt.Y))+")")), "\n"))
		i = (i + 1)
	}
}

func main() {
	main()
}

func _exists(v any) bool {
	if g, ok := v.(*data.Group); ok {
		return len(g.Items) > 0
	}
	switch s := v.(type) {
	case []any:
		return len(s) > 0
	case []int:
		return len(s) > 0
	case []float64:
		return len(s) > 0
	case []string:
		return len(s) > 0
	case []bool:
		return len(s) > 0
	case bool:
		return s
	case []map[string]any:
		return len(s) > 0
	case map[string]any:
		return len(s) > 0
	case map[string]int:
		return len(s) > 0
	case string:
		return len([]rune(s)) > 0
	}
	rv := reflect.ValueOf(v)
	switch rv.Kind() {
	case reflect.Slice, reflect.Array:
		return rv.Len() > 0
	case reflect.Map:
		return !rv.IsNil() && rv.Len() > 0
	case reflect.Pointer:
		return !rv.IsNil()
	case reflect.Struct:
		return !rv.IsZero()
	}
	return false
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
