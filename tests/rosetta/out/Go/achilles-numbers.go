//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func pow10(exp int) int {
	n := 1
	i := 0
	for i < exp {
		n = (n * 10)
		i = (i + 1)
	}
	return n
}

// line 14
func totient(n int) int {
	tot := n
	nn := n
	i := 2
	for (i * i) <= nn {
		if (nn % i) == 0 {
			for (nn % i) == 0 {
				nn = int(int(int((float64(nn) / float64(i)))))
			}
			tot = int(int(int((float64(tot) - (float64(tot) / float64(i))))))
		}
		if i == 2 {
			i = 1
		}
		i = (i + 2)
	}
	if nn > 1 {
		tot = int(int(int((float64(tot) - (float64(tot) / float64(nn))))))
	}
	return tot
}

// line 38
func getPerfectPowers(maxExp int) {
	upper := pow10(maxExp)
	i := 2
	for (i * i) < upper {
		p := (i * i)
		for {
			p = (p * i)
			if p >= upper {
				break
			}
			pps[p] = true
		}
		i = (i + 1)
	}
}

// line 52
func getAchilles(minExp int, maxExp int) map[int]bool {
	lower := pow10(minExp)
	upper := pow10(maxExp)
	var achilles map[int]bool = map[int]bool{}
	b := 1
	for ((b * b) * b) < upper {
		b3 := ((b * b) * b)
		a := 1
		for {
			p := ((b3 * a) * a)
			if p >= upper {
				break
			}
			if p >= lower {
				key0 := p
				m1 := pps
				_, ok2 := m1[key0]
				if !(ok2) {
					achilles[p] = true
				}
			}
			a = (a + 1)
		}
		b = (b + 1)
	}
	return achilles
}

// line 75
func sortInts(xs []int) []int {
	var res []int = []int{}
	tmp := xs
	for len(any(tmp)) > 0 {
		min := tmp[0]
		idx := 0
		i := 1
		for i < len(any(tmp)) {
			if tmp[i] < min {
				min = tmp[i]
				idx = i
			}
			i = (i + 1)
		}
		res = append(append([]int{}, res...), []int{min}...)
		var out []int = []int{}
		j := 0
		for j < len(any(tmp)) {
			if j != idx {
				out = append(append([]int{}, out...), []int{tmp[j]}...)
			}
			j = (j + 1)
		}
		tmp = out
	}
	return res
}

// line 101
func pad(n int, width int) string {
	s := fmt.Sprint(any(n))
	for len(any(s)) < width {
		s = " " + s
	}
	return s
}

// line 109
func main() {
	maxDigits := 15
	getPerfectPowers(maxDigits)
	achSet := getAchilles(1, 5)
	var ach []int = []int{}
	for _, k := range achSet["keys"]() {
		ach = _convSlice[any, int](append(append([]int{}, ach...), []int{(k).(int)}...))
	}
	ach = sortInts(ach)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("First 50 Achilles numbers:")), "\n"))
	i := 0
	for i < 50 {
		line := ""
		j := 0
		for j < 10 {
			line = line + pad(ach[i], 4)
			if j < 9 {
				line = line + " "
			}
			i = (i + 1)
			j = (j + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nFirst 30 strong Achilles numbers:")), "\n"))
	var strong []int = []int{}
	count := 0
	idx := 0
	for count < 30 {
		tot := totient(ach[idx])
		key3 := tot
		m4 := achSet
		_, ok5 := m4[key3]
		if ok5 {
			strong = append(append([]int{}, strong...), []int{ach[idx]}...)
			count = (count + 1)
		}
		idx = (idx + 1)
	}
	i = 0
	for i < 30 {
		line := ""
		j := 0
		for j < 10 {
			line = line + pad(strong[i], 5)
			if j < 9 {
				line = line + " "
			}
			i = (i + 1)
			j = (j + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nNumber of Achilles numbers with:")), "\n"))
	counts := []int{
		1,
		12,
		47,
		192,
		664,
		2242,
		7395,
		24008,
		77330,
		247449,
		788855,
		2508051,
		7960336,
		25235383,
	}
	d := 2
	for d <= maxDigits {
		c := counts[(d - 2)]
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(pad(d, 2)+" digits: "+fmt.Sprint(any(c)))), "\n"))
		d = (d + 1)
	}
}

var pps map[int]bool

func main() {
	pps = map[int]bool{}
	main()
}

func _convSlice[T any, U any](s []T) []U {
	out := make([]U, len(s))
	for i, v := range s {
		out[i] = any(v).(U)
	}
	return out
}
