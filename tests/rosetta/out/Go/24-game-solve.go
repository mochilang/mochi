//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"reflect"
	"strings"
	"time"
)

type v map[string]any

type Node struct {
	Op    int            `json:"op"`
	Left  map[string]any `json:"left"`
	Right map[string]any `json:"right"`
}

// line 10
func newNum(n int) map[string]any {
	return map[string]any{"op": OP_NUM, "value": map[string]int{"num": n, "denom": 1}}
}

// line 14
func exprEval(x map[string]any) map[string]int {
	if _equal(x["op"], OP_NUM) {
		return (x["value"]).(map[string]int)
	}
	l := exprEval((x["left"]).(map[string]any))
	r := exprEval((x["right"]).(map[string]any))
	if _equal(x["op"], OP_ADD) {
		return map[string]int{"num": ((l["num"] * r["denom"]) + (l["denom"] * r["num"])), "denom": (l["denom"] * r["denom"])}
	}
	if _equal(x["op"], OP_SUB) {
		return map[string]int{"num": ((l["num"] * r["denom"]) - (l["denom"] * r["num"])), "denom": (l["denom"] * r["denom"])}
	}
	if _equal(x["op"], OP_MUL) {
		return map[string]int{"num": (l["num"] * r["num"]), "denom": (l["denom"] * r["denom"])}
	}
	return map[string]int{"num": (l["num"] * r["denom"]), "denom": (l["denom"] * r["num"])}
}

// line 31
func exprString(x map[string]any) string {
	if _equal(x["op"], OP_NUM) {
		return fmt.Sprint((x["value"]).(map[string]any)["num"])
	}
	ls := exprString((x["left"]).(map[string]any))
	rs := exprString((x["right"]).(map[string]any))
	opstr := ""
	if _equal(x["op"], OP_ADD) {
		opstr = " + "
	} else if _equal(x["op"], OP_SUB) {
		opstr = " - "
	} else if _equal(x["op"], OP_MUL) {
		opstr = " * "
	} else {
		opstr = " / "
	}
	return "(" + ls + opstr + rs + ")"
}

// line 47
func solve(xs []map[string]any) bool {
	if len(any(xs)) == 1 {
		f := exprEval(xs[0])
		if (f["denom"] != 0) && (f["num"] == (f["denom"] * goal)) {
			fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(exprString(xs[0]))), "\n"))
			return true
		}
		return false
	}
	i := 0
	for i < len(any(xs)) {
		j := (i + 1)
		for j < len(any(xs)) {
			var rest []map[string]any = []map[string]any{}
			k := 0
			for k < len(any(xs)) {
				if (k != i) && (k != j) {
					rest = append(_toAnySlice(rest), any(xs[k]))
				}
				k = (k + 1)
			}
			a := xs[i]
			b := xs[j]
			for _, op := range []int{
				OP_ADD,
				OP_SUB,
				OP_MUL,
				OP_DIV,
			} {
				node := Node{
					Op:    op,
					Left:  a,
					Right: b,
				}
				if solve(_convSlice[any, map[string]any](append(_toAnySlice(rest), any(node)))) {
					return true
				}
			}
			node := Node{
				Op:    OP_SUB,
				Left:  b,
				Right: a,
			}
			if solve(_convSlice[any, map[string]any](append(_toAnySlice(rest), any(node)))) {
				return true
			}
			node = Node{
				Op:    OP_DIV,
				Left:  b,
				Right: a,
			}
			if solve(_convSlice[any, map[string]any](append(_toAnySlice(rest), any(node)))) {
				return true
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return false
}

// line 83
func main() {
	iter := 0
	for iter < 10 {
		var cards []map[string]any = []map[string]any{}
		i := 0
		for i < n_cards {
			n := (int64((int64(time.Now().UnixNano()) % int64((digit_range - 1)))) + int64(1))
			cards = append(_toAnySlice(cards), any(newNum(n)))
			fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(" "+fmt.Sprint(any(n)))), "\n"))
			i = (i + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(":  ")), "\n"))
		if !(solve(cards)) {
			fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("No solution")), "\n"))
		}
		iter = (iter + 1)
	}
}

var OP_NUM int
var OP_ADD int
var OP_SUB int
var OP_MUL int
var OP_DIV int
var n_cards int
var goal int
var digit_range int

func main() {
	OP_NUM = 0
	OP_ADD = 1
	OP_SUB = 2
	OP_MUL = 3
	OP_DIV = 4
	n_cards = 4
	goal = 24
	digit_range = 9
	main()
}

func _convSlice[T any, U any](s []T) []U {
	out := make([]U, len(s))
	for i, v := range s {
		out[i] = any(v).(U)
	}
	return out
}

func _convertMapAny(m map[any]any) map[string]any {
	out := make(map[string]any, len(m))
	for k, v := range m {
		key := fmt.Sprint(k)
		if sub, ok := v.(map[any]any); ok {
			out[key] = _convertMapAny(sub)
		} else {
			out[key] = v
		}
	}
	return out
}

func _copyToMap(dst map[string]any, src any) {
	switch m := src.(type) {
	case map[string]any:
		for k, v := range m {
			dst[k] = v
		}
	case map[string]string:
		for k, v := range m {
			dst[k] = v
		}
	case map[any]any:
		for k, v := range _convertMapAny(m) {
			dst[k] = v
		}
	default:
		rv := reflect.ValueOf(m)
		if rv.Kind() == reflect.Struct {
			rt := rv.Type()
			for i := 0; i < rv.NumField(); i++ {
				name := rt.Field(i).Name
				if tag := rt.Field(i).Tag.Get("json"); tag != "" {
					if c := strings.Index(tag, ","); c >= 0 {
						tag = tag[:c]
					}
					if tag != "-" {
						name = tag
					}
				}
				dst[name] = rv.Field(i).Interface()
			}
		}
	}
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Struct && bv.Kind() == reflect.Map {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Struct {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
