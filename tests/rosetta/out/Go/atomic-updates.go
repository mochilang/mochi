//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func randOrder(seed int, n int) []int {
	next := (((seed * 1664525) + 1013904223) % 2147483647)
	return []int{next, (next % n)}
}

// line 9
func randChaos(seed int, n int) []int {
	next := (((seed * 1103515245) + 12345) % 2147483647)
	return []int{next, (next % n)}
}

// line 14
func main() {
	nBuckets := 10
	initialSum := 1000
	var buckets []int = []int{}
	for i := 0; i < nBuckets; i++ {
		buckets = append(_toAnySlice(buckets), any(0))
	}
	i := nBuckets
	dist := initialSum
	for i > 0 {
		v := (float64(dist) / float64(i))
		i = (i - 1)
		buckets[i] = int(int(int(v)))
		dist = int(int(int((float64(dist) - v))))
	}
	tc0 := 0
	tc1 := 0
	total := 0
	nTicks := 0
	seedOrder := 1
	seedChaos := 2
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("sum  ---updates---    mean  buckets")), "\n"))
	t := 0
	for t < 5 {
		r := randOrder(seedOrder, nBuckets)
		seedOrder = r[0]
		b1 := r[1]
		b2 := ((b1 + 1) % nBuckets)
		v1 := buckets[b1]
		v2 := buckets[b2]
		if v1 > v2 {
			a := int((float64((v1 - v2)) / float64(2)))
			if a > buckets[b1] {
				a = buckets[b1]
			}
			buckets[b1] = (buckets[b1] - a)
			buckets[b2] = (buckets[b2] + a)
		} else {
			a := int((float64((v2 - v1)) / float64(2)))
			if a > buckets[b2] {
				a = buckets[b2]
			}
			buckets[b2] = (buckets[b2] - a)
			buckets[b1] = (buckets[b1] + a)
		}
		tc0 = (tc0 + 1)
		r = randChaos(seedChaos, nBuckets)
		seedChaos = r[0]
		b1 = r[1]
		b2 = ((b1 + 1) % nBuckets)
		r = randChaos(seedChaos, (buckets[b1] + 1))
		seedChaos = r[0]
		amt := r[1]
		if amt > buckets[b1] {
			amt = buckets[b1]
		}
		buckets[b1] = (buckets[b1] - amt)
		buckets[b2] = (buckets[b2] + amt)
		tc1 = (tc1 + 1)
		sum := 0
		idx := 0
		for idx < nBuckets {
			sum = (sum + buckets[idx])
			idx = (idx + 1)
		}
		total = ((total + tc0) + tc1)
		nTicks = (nTicks + 1)
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(fmt.Sprint(any(sum))+" "+fmt.Sprint(any(tc0))+" "+fmt.Sprint(any(tc1))+" "+fmt.Sprint(any((float64(total)/float64(nTicks))))+"  "+fmt.Sprint(any(buckets)))), "\n"))
		tc0 = 0
		tc1 = 0
		t = (t + 1)
	}
}

func main() {
	main()
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
