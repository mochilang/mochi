//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 1
func indexOf(s string, ch string) int {
	i := 0
	for i < len(any(s)) {
		if string([]rune(s)[i]) == ch {
			return i
		}
		i = (i + 1)
	}
	return -1
}

// line 12
func parseIntStr(str string) int {
	i := 0
	neg := false
	if (len(any(str)) > 0) && (string([]rune(str)[0]) == "-") {
		neg = true
		i = 1
	}
	n := 0
	digits := map[string]int{
		"0": 0,
		"1": 1,
		"2": 2,
		"3": 3,
		"4": 4,
		"5": 5,
		"6": 6,
		"7": 7,
		"8": 8,
		"9": 9,
	}
	for i < len(any(str)) {
		n = ((n * 10) + digits[string([]rune(str)[i])])
		i = (i + 1)
	}
	if neg {
		n = -n
	}
	return n
}

// line 40
func ord(ch string) int {
	upper := "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	lower := "abcdefghijklmnopqrstuvwxyz"
	idx := indexOf(upper, ch)
	if idx >= 0 {
		return (65 + idx)
	}
	idx = indexOf(lower, ch)
	if idx >= 0 {
		return (97 + idx)
	}
	if (ch >= "0") && (ch <= "9") {
		return (48 + parseIntStr(ch))
	}
	if ch == "+" {
		return 43
	}
	if ch == "/" {
		return 47
	}
	if ch == " " {
		return 32
	}
	if ch == "=" {
		return 61
	}
	return 0
}

// line 55
func chr(n int) string {
	upper := "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	lower := "abcdefghijklmnopqrstuvwxyz"
	if (n >= 65) && (n < 91) {
		return string([]rune(upper)[(n - 65):(n - 64)])
	}
	if (n >= 97) && (n < 123) {
		return string([]rune(lower)[(n - 97):(n - 96)])
	}
	if (n >= 48) && (n < 58) {
		digits := "0123456789"
		return string([]rune(digits)[(n - 48):(n - 47)])
	}
	if n == 43 {
		return "+"
	}
	if n == 47 {
		return "/"
	}
	if n == 32 {
		return " "
	}
	if n == 61 {
		return "="
	}
	return "?"
}

// line 70
func toBinary(n int, bits int) string {
	b := ""
	val := n
	i := 0
	for i < bits {
		b = fmt.Sprint(any((val % 2))) + b
		val = int((float64(val) / float64(2)))
		i = (i + 1)
	}
	return b
}

// line 82
func binToInt(bits string) int {
	n := 0
	i := 0
	for i < len(any(bits)) {
		n = ((n * 2) + parseIntStr(string([]rune(bits)[i:(i+1)])))
		i = (i + 1)
	}
	return n
}

// line 92
func base64Encode(text string) string {
	alphabet := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	bin := ""
	for _, r := range []rune(text) {
		ch := string(r)
		bin = bin + toBinary(ord(ch), 8)
	}
	for (len(any(bin)) % 6) != 0 {
		bin = bin + "0"
	}
	out := ""
	i := 0
	for i < len(any(bin)) {
		chunk := string([]rune(bin)[i:(i + 6)])
		val := binToInt(chunk)
		out = out + string([]rune(alphabet)[val:(val+1)])
		i = (i + 6)
	}
	pad := ((3 - (len(any(text)) % 3)) % 3)
	if pad == 1 {
		out = string([]rune(out)[0:(len(any(out))-1)]) + "="
	}
	if pad == 2 {
		out = string([]rune(out)[0:(len(any(out))-2)]) + "=="
	}
	return out
}

// line 113
func base64Decode(enc string) string {
	alphabet := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	bin := ""
	i := 0
	for i < len(any(enc)) {
		ch := string([]rune(enc)[i])
		if ch == "=" {
			break
		}
		idx := indexOf(alphabet, ch)
		bin = bin + toBinary(idx, 6)
		i = (i + 1)
	}
	out := ""
	i = 0
	for (i + 8) <= len(any(bin)) {
		chunk := string([]rune(bin)[i:(i + 8)])
		val := binToInt(chunk)
		out = out + chr(val)
		i = (i + 8)
	}
	return out
}

var enc string

func main() {
	enc = base64Encode(msg)
	msg := "Rosetta Code Base64 decode data task"
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Original : "+msg)), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nEncoded  : "+enc)), "\n"))
	dec := base64Decode(enc)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nDecoded  : "+dec)), "\n"))
}
