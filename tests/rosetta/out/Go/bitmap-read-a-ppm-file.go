//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

type Pixel struct {
	R int `json:"R"`
	G int `json:"G"`
	B int `json:"B"`
}
type Bitmap struct {
	W       int       `json:"w"`
	H       int       `json:"h"`
	Max     int       `json:"max"`
	DataVar [][]Pixel `json:"data"`
}

// line 18
func newBitmap(w int, h int, max int) Bitmap {
	var rows [][]Pixel = [][]Pixel{}
	y := 0
	for y < h {
		var row []Pixel = []Pixel{}
		x := 0
		for x < w {
			row = append(_toAnySlice(row), any(Pixel{R: 0, G: 0, B: 0}))
			x = (x + 1)
		}
		rows = append(_toAnySlice(rows), any(row))
		y = (y + 1)
	}
	return Bitmap{W: w, H: h, Max: max, DataVar: rows}
}

// line 34
func setPx(b *Bitmap, x int, y int, p Pixel) {
	rows := b.DataVar
	row := rows[y]
	row[x] = p
	rows[y] = row
	b.DataVar = rows
}

// line 42
func getPx(b Bitmap, x int, y int) Pixel {
	return b.DataVar[y][x]
}

// line 46
func splitLines(s string) []string {
	var out []string = []string{}
	cur := ""
	i := 0
	for i < len(any(s)) {
		ch := _sliceString(s, i, (i + 1))
		if ch == "\n" {
			out = append(_toAnySlice(out), any(cur))
			cur = ""
		} else {
			cur = cur + ch
		}
		i = (i + 1)
	}
	out = append(_toAnySlice(out), any(cur))
	return out
}

// line 64
func splitWS(s string) []string {
	var out []string = []string{}
	cur := ""
	i := 0
	for i < len(any(s)) {
		ch := _sliceString(s, i, (i + 1))
		if (((ch == " ") || (ch == "\t")) || (ch == "\r")) || (ch == "\n") {
			if len(any(cur)) > 0 {
				out = append(_toAnySlice(out), any(cur))
				cur = ""
			}
		} else {
			cur = cur + ch
		}
		i = (i + 1)
	}
	if len(any(cur)) > 0 {
		out = append(_toAnySlice(out), any(cur))
	}
	return out
}

// line 86
func parseIntStr(str string) int {
	i := 0
	neg := false
	if (len(any(str)) > 0) && (string([]rune(str)[0:1]) == "-") {
		neg = true
		i = 1
	}
	n := 0
	digits := map[string]int{
		"0": 0,
		"1": 1,
		"2": 2,
		"3": 3,
		"4": 4,
		"5": 5,
		"6": 6,
		"7": 7,
		"8": 8,
		"9": 9,
	}
	for i < len(any(str)) {
		n = ((n * 10) + digits[string([]rune(str)[i:(i+1)])])
		i = (i + 1)
	}
	if neg {
		n = -n
	}
	return n
}

// line 114
func tokenize(s string) []string {
	lines := splitLines(s)
	var toks []string = []string{}
	i := 0
	for i < len(any(lines)) {
		line := lines[i]
		if (len(any(line)) > 0) && (_sliceString(line, 0, 1) == "#") {
			i = (i + 1)
			continue
		}
		parts := splitWS(line)
		j := 0
		for j < len(any(parts)) {
			toks = append(_toAnySlice(toks), any(parts[j]))
			j = (j + 1)
		}
		i = (i + 1)
	}
	return toks
}

// line 135
func readP3(text string) Bitmap {
	toks := tokenize(text)
	if len(any(toks)) < 4 {
		return newBitmap(0, 0, 0)
	}
	if toks[0] != "P3" {
		return newBitmap(0, 0, 0)
	}
	var w int = parseIntStr(toks[1])
	var h int = parseIntStr(toks[2])
	var maxv int = parseIntStr(toks[3])
	idx := 4
	bm := newBitmap(w, h, maxv)
	y := (h - 1)
	for y >= 0 {
		x := 0
		for x < w {
			var r int = parseIntStr(toks[idx])
			var g int = parseIntStr(toks[(idx + 1)])
			var b int = parseIntStr(toks[(idx + 2)])
			setPx(&bm, x, y, &Pixel{R: r, G: g, B: b})
			idx = (idx + 3)
			x = (x + 1)
		}
		y = (y - 1)
	}
	return bm
}

// line 160
func toGrey(b *Bitmap) {
	var h int = b.H
	var w int = b.W
	m := 0
	y := 0
	for y < h {
		x := 0
		for x < w {
			p := getPx(&b, x, y)
			_ = p
			l := (float64((((p.R * 2126) + (p.G * 7152)) + (p.B * 722))) / float64(10000))
			if l > float64(b.Max) {
				l = float64(float64(float64(b.Max)))
			}
			setPx(&b, x, y, &Pixel{R: int(l), G: int(l), B: int(l)})
			if l > float64(m) {
				m = int(int(int(l)))
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	b.Max = m
}

// line 180
func pad(n int, w int) string {
	s := fmt.Sprint(any(n))
	for len(any(s)) < w {
		s = " " + s
	}
	return s
}

// line 186
func writeP3(b Bitmap) string {
	var h int = b.H
	var w int = b.W
	max := b.Max
	digits := len(any(fmt.Sprint(any(max))))
	out := "P3\n# generated from Bitmap.writeppmp3\n" + fmt.Sprint(any(w)) + " " + fmt.Sprint(any(h)) + "\n" + fmt.Sprint(any(max)) + "\n"
	y := (h - 1)
	for y >= 0 {
		line := ""
		x := 0
		for x < w {
			p := getPx(&b, x, y)
			_ = p
			line = line + "   " + pad(p.R, digits) + " " + pad(p.G, digits) + " " + pad(p.B, digits)
			x = (x + 1)
		}
		out = out + line + "\n"
		y = (y - 1)
	}
	return out
}

var bm Bitmap
var out string

func main() {
	bm = readP3(ppmtxt)
	out = writeP3(&bm)
	ppmtxt := "P3\n" + "# feep.ppm\n" + "4 4\n" + "15\n" + " 0  0  0    0  0  0    0  0  0   15  0 15\n" + " 0  0  0    0 15  7    0  0  0    0  0  0\n" + " 0  0  0    0  0  0    0 15  7    0  0  0\n" + "15  0 15    0  0  0    0  0  0    0  0  0\n"
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Original Colour PPM file")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(ppmtxt)), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Grey PPM:")), "\n"))
	toGrey(&bm)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(out)), "\n"))
}

func _sliceString(s string, i, j int) string {
	start := i
	end := j
	n := len([]rune(s))
	if start < 0 {
		start += n
	}
	if end < 0 {
		end += n
	}
	if start < 0 {
		start = 0
	}
	if end > n {
		end = n
	}
	if end < start {
		end = start
	}
	return string([]rune(s)[start:end])
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
