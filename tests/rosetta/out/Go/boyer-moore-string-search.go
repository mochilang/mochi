//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 1
func indexOfStr(h string, n string) int {
	hlen := len(any(h))
	nlen := len(any(n))
	if nlen == 0 {
		return 0
	}
	i := 0
	for i <= (hlen - nlen) {
		if string([]rune(h)[i:(i+nlen)]) == n {
			return i
		}
		i = (i + 1)
	}
	return -1
}

// line 13
func stringSearchSingle(h string, n string) int {
	return indexOfStr(h, n)
}

// line 17
func stringSearch(h string, n string) []int {
	var result []int = []int{}
	start := 0
	hlen := len(any(h))
	nlen := len(any(n))
	for start < hlen {
		idx := indexOfStr(string([]rune(h)[start:hlen]), n)
		if idx >= 0 {
			result = append(_toAnySlice(result), any((start + idx)))
			start = ((start + idx) + nlen)
		} else {
			break
		}
	}
	return result
}

// line 34
func display(nums []int) string {
	s := "["
	i := 0
	for i < len(any(nums)) {
		if i > 0 {
			s = s + ", "
		}
		s = s + fmt.Sprint(any(nums[i]))
		i = (i + 1)
	}
	s = s + "]"
	return s
}

// line 46
func main() {
	texts := []string{
		"GCTAGCTCTACGAGTCTA",
		"GGCTATAATGCGTA",
		"there would have been a time for such a word",
		"needle need noodle needle",
		"DKnuthusesandprogramsanimaginarycomputertheMIXanditsassociatedmachinecodeandassemblylanguages",
		"Nearby farms grew an acre of alfalfa on the dairy's behalf, with bales of that alfalfa exchanged for milk.",
	}
	patterns := []string{
		"TCTA",
		"TAATAAA",
		"word",
		"needle",
		"and",
		"alfalfa",
	}
	i := 0
	for i < len(any(texts)) {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("text"+fmt.Sprint(any((i+1)))+" = "+texts[i])), "\n"))
		i = (i + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
	j := 0
	for j < len(any(texts)) {
		idxs := stringSearch(texts[j], patterns[j])
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Found \""+patterns[j]+"\" in 'text"+fmt.Sprint(any((j+1)))+"' at indexes "+display(idxs))), "\n"))
		j = (j + 1)
	}
}

func main() {
	main()
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
