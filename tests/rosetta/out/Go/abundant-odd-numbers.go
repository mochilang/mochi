//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"

	"golang.org/x/exp/constraints"
)

type v map[string]any

// line 4
func divisors(n int) []int {
	var divs []int = []int{1}
	var divs2 []int = []int{}
	i := 2
	for (i * i) <= n {
		if (n % i) == 0 {
			j := int((float64(n) / float64(i)))
			divs = append(divs, i)
			if i != j {
				divs2 = append(divs2, j)
			}
		}
		i = (i + 1)
	}
	j := (len(divs2) - 1)
	for j >= 0 {
		divs = append(divs, divs2[j])
		j = (j - 1)
	}
	return divs
}

// line 26
func sum(xs []int) int {
	tot := 0
	for _, v := range xs {
		tot = (tot + v)
	}
	return tot
}

// line 34
func sumStr(xs []int) string {
	s := ""
	i := 0
	for i < len(xs) {
		s = s + fmt.Sprint(xs[i]) + " + "
		i = (i + 1)
	}
	return string([]rune(s)[0:(len(s) - 3)])
}

// line 44
func pad2(n int) string {
	s := fmt.Sprint(n)
	if len(s) < 2 {
		return " " + s
	}
	return s
}

// line 50
func pad5(n int) string {
	s := fmt.Sprint(n)
	for len(s) < 5 {
		s = " " + s
	}
	return s
}

// line 58
func abundantOdd(searchFrom int, countFrom int, countTo int, printOne bool) int {
	count := countFrom
	n := searchFrom
	for count < countTo {
		divs := divisors(n)
		tot := _sumOrdered[int](divs)
		if tot > float64(n) {
			count = (count + 1)
			if printOne && (count < countTo) {
				n = (n + 2)
				continue
			}
			s := sumStr(divs)
			if !printOne {
				fmt.Println(pad2(count) + ". " + pad5(n) + " < " + s + " = " + fmt.Sprint(tot))
			} else {
				fmt.Println(fmt.Sprint(n) + " < " + s + " = " + fmt.Sprint(tot))
			}
		}
		n = (n + 2)
	}
	return n
}

// line 82
func main() {
	max := 25
	fmt.Println("The first " + "25" + " abundant odd numbers are:")
	n := abundantOdd(1, 0, max, false)
	fmt.Println("\nThe one thousandth abundant odd number is:")
	abundantOdd(n, max, 1000, true)
	fmt.Println("\nThe first abundant odd number above one billion is:")
	abundantOdd(1000000001, 0, 1, true)
}

func main() {
	main()
}

func _sumOrdered[T constraints.Integer | constraints.Float](s []T) float64 {
	var sum float64
	for _, v := range s {
		sum += float64(v)
	}
	return sum
}
