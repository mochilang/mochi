//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

type Point struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
	Z float64 `json:"z"`
}
type Edge struct {
	Pn1 int   `json:"pn1"`
	Pn2 int   `json:"pn2"`
	Fn1 int   `json:"fn1"`
	Fn2 int   `json:"fn2"`
	Cp  Point `json:"cp"`
}
type PointEx struct {
	P Point `json:"p"`
	N int   `json:"n"`
}

// line 23
func indexOf(s string, ch string) int {
	i := 0
	for i < len(any(s)) {
		if string([]rune(s)[i:(i+1)]) == ch {
			return i
		}
		i = (i + 1)
	}
	return -1
}

// line 32
func fmt4(x float64) string {
	y := (x * 10000.0)
	if y >= float64(0) {
		y = (y + 0.5)
	} else {
		y = (y - 0.5)
	}
	y = (float64((int(y))) / 10000.0)
	s := fmt.Sprint(any(y))
	dot := indexOf(s, ".")
	if dot == (0 - 1) {
		s = s + ".0000"
	} else {
		decs := ((len(any(s)) - dot) - 1)
		if decs > 4 {
			s = string([]rune(s)[0:(dot + 5)])
		} else {
			for decs < 4 {
				s = s + "0"
				decs = (decs + 1)
			}
		}
	}
	if x >= 0.0 {
		s = " " + s
	}
	return s
}

// line 55
func fmt2(n int) string {
	s := fmt.Sprint(any(n))
	if len(any(s)) < 2 {
		return " " + s
	}
	return s
}

// line 61
func sumPoint(p1 Point, p2 Point) Point {
	return Point{X: (p1.X + p2.X), Y: (p1.Y + p2.Y), Z: (p1.Z + p2.Z)}
}

// line 65
func mulPoint(p Point, m float64) Point {
	return Point{X: (p.X * m), Y: (p.Y * m), Z: (p.Z * m)}
}

// line 69
func divPoint(p Point, d float64) Point {
	return mulPoint(&p, (1.0 / d))
}

// line 71
func centerPoint(p1 Point, p2 Point) Point {
	return divPoint(&sumPoint(&p1, &p2), 2.0)
}

// line 73
func getFacePoints(points []Point, faces [][]int) []Point {
	var facePoints []Point = []Point{}
	i := 0
	for i < len(any(faces)) {
		face := faces[i]
		fp := Point{X: 0.0, Y: 0.0, Z: 0.0}
		for _, idx := range face {
			fp = sumPoint(&fp, &points[idx])
		}
		fp = divPoint(&fp, (float64(len(any(face)))))
		facePoints = append(_toAnySlice(facePoints), any(fp))
		i = (i + 1)
	}
	return facePoints
}

// line 87
func sortEdges(edges [][]int) [][]int {
	var res [][]int = [][]int{}
	tmp := edges
	for len(any(tmp)) > 0 {
		min := tmp[0]
		idx := 0
		j := 1
		for j < len(any(tmp)) {
			e := tmp[j]
			if (e[0] < min[0]) || ((e[0] == min[0]) && ((e[1] < min[1]) || ((e[1] == min[1]) && (e[2] < min[2])))) {
				min = e
				idx = j
			}
			j = (j + 1)
		}
		res = append(_toAnySlice(res), any(min))
		var out [][]int = [][]int{}
		k := 0
		for k < len(any(tmp)) {
			if k != idx {
				out = append(_toAnySlice(out), any(tmp[k]))
			}
			k = (k + 1)
		}
		tmp = out
	}
	return res
}

// line 114
func getEdgesFaces(points []Point, faces [][]int) []Edge {
	var edges [][]int = [][]int{}
	fnum := 0
	for fnum < len(any(faces)) {
		face := faces[fnum]
		numP := len(any(face))
		pi := 0
		for pi < numP {
			pn1 := face[pi]
			pn2 := 0
			if pi < (numP - 1) {
				pn2 = face[(pi + 1)]
			} else {
				pn2 = face[0]
			}
			if pn1 > pn2 {
				tmpn := pn1
				pn1 = pn2
				pn2 = tmpn
			}
			edges = append(_toAnySlice(edges), any([]int{pn1, pn2, fnum}))
			pi = (pi + 1)
		}
		fnum = (fnum + 1)
	}
	edges = sortEdges(edges)
	var merged [][]int = [][]int{}
	idx := 0
	for idx < len(any(edges)) {
		e1 := edges[idx]
		if idx < (len(any(edges)) - 1) {
			e2 := edges[(idx + 1)]
			if (e1[0] == e2[0]) && (e1[1] == e2[1]) {
				merged = append(_toAnySlice(merged), any([]int{
					e1[0],
					e1[1],
					e1[2],
					e2[2],
				}))
				idx = (idx + 2)
				continue
			}
		}
		merged = append(_toAnySlice(merged), any([]int{
			e1[0],
			e1[1],
			e1[2],
			-1,
		}))
		idx = (idx + 1)
	}
	var edgesCenters []Edge = []Edge{}
	for _, me := range merged {
		p1 := points[me[0]]
		p2 := points[me[1]]
		cp := centerPoint(&p1, &p2)
		edgesCenters = append(_toAnySlice(edgesCenters), any(Edge{Pn1: me[0], Pn2: me[1], Fn1: me[2], Fn2: me[3], Cp: cp}))
	}
	return edgesCenters
}

// line 161
func getEdgePoints(points []Point, edgesFaces []Edge, facePoints []Point) []Point {
	var edgePoints []Point = []Point{}
	i := 0
	for i < len(any(edgesFaces)) {
		edge := edgesFaces[i]
		_ = edge
		cp := edge.Cp
		fp1 := facePoints[edge.Fn1]
		fp2 := fp1
		if edge.Fn2 != (0 - 1) {
			fp2 = facePoints[edge.Fn2]
		}
		cfp := centerPoint(&fp1, &fp2)
		edgePoints = append(_toAnySlice(edgePoints), any(centerPoint(&cp, &cfp)))
		i = (i + 1)
	}
	return edgePoints
}

// line 179
func getAvgFacePoints(points []Point, faces [][]int, facePoints []Point) []Point {
	numP := len(any(points))
	var temp []PointEx = []PointEx{}
	i := 0
	for i < numP {
		temp = append(_toAnySlice(temp), any(PointEx{P: Point{X: 0.0, Y: 0.0, Z: 0.0}, N: 0}))
		i = (i + 1)
	}
	fnum := 0
	for fnum < len(any(faces)) {
		fp := facePoints[fnum]
		for _, pn := range faces[fnum] {
			tp := temp[pn]
			_ = tp
			temp[pn] = PointEx{P: sumPoint(&tp.P, &fp), N: (tp.N + 1)}
		}
		fnum = (fnum + 1)
	}
	var avg []Point = []Point{}
	j := 0
	for j < numP {
		tp := temp[j]
		_ = tp
		avg = append(_toAnySlice(avg), any(divPoint(&tp.P, float64(tp.N))))
		j = (j + 1)
	}
	return avg
}

// line 206
func getAvgMidEdges(points []Point, edgesFaces []Edge) []Point {
	numP := len(any(points))
	var temp []PointEx = []PointEx{}
	i := 0
	for i < numP {
		temp = append(_toAnySlice(temp), any(PointEx{P: Point{X: 0.0, Y: 0.0, Z: 0.0}, N: 0}))
		i = (i + 1)
	}
	for _, edge := range edgesFaces {
		cp := edge.Cp
		arr := []int{edge.Pn1, edge.Pn2}
		for _, pn := range arr {
			tp := temp[pn]
			_ = tp
			temp[pn] = PointEx{P: sumPoint(&tp.P, &cp), N: (tp.N + 1)}
		}
	}
	var avg []Point = []Point{}
	j := 0
	for j < numP {
		tp := temp[j]
		_ = tp
		avg = append(_toAnySlice(avg), any(divPoint(&tp.P, float64(tp.N))))
		j = (j + 1)
	}
	return avg
}

// line 232
func getPointsFaces(points []Point, faces [][]int) []int {
	var pf []int = []int{}
	i := 0
	for i < len(any(points)) {
		pf = append(_toAnySlice(pf), any(0))
		i = (i + 1)
	}
	fnum := 0
	for fnum < len(any(faces)) {
		for _, pn := range faces[fnum] {
			pf[pn] = (pf[pn] + 1)
		}
		fnum = (fnum + 1)
	}
	return pf
}

// line 247
func getNewPoints(points []Point, pf []int, afp []Point, ame []Point) []Point {
	var newPts []Point = []Point{}
	i := 0
	for i < len(any(points)) {
		n := float64(pf[i])
		m1 := ((n - 3.0) / n)
		m2 := (1.0 / n)
		m3 := (2.0 / n)
		old := points[i]
		p1 := mulPoint(&old, m1)
		p2 := mulPoint(&afp[i], m2)
		p3 := mulPoint(&ame[i], m3)
		newPts = append(_toAnySlice(newPts), any(sumPoint(&sumPoint(&p1, &p2), &p3)))
		i = (i + 1)
	}
	return newPts
}

// line 265
func key(a int, b int) string {
	if a < b {
		return fmt.Sprint(any(a)) + "," + fmt.Sprint(any(b))
	}
	return fmt.Sprint(any(b)) + "," + fmt.Sprint(any(a))
}

// line 270
func cmcSubdiv(points []Point, faces [][]int) []any {
	facePoints := getFacePoints(points, faces)
	edgesFaces := getEdgesFaces(points, faces)
	edgePoints := getEdgePoints(points, edgesFaces, facePoints)
	avgFacePoints := getAvgFacePoints(points, faces, facePoints)
	avgMidEdges := getAvgMidEdges(points, edgesFaces)
	pointsFaces := getPointsFaces(points, faces)
	newPoints := getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges)
	var facePointNums []int = []int{}
	nextPoint := len(any(newPoints))
	for _, fp := range facePoints {
		newPoints = append(_toAnySlice(newPoints), any(fp))
		facePointNums = append(_toAnySlice(facePointNums), any(nextPoint))
		nextPoint = (nextPoint + 1)
	}
	var edgePointNums map[string]int = map[string]int{}
	idx := 0
	for idx < len(any(edgesFaces)) {
		e := edgesFaces[idx]
		_ = e
		newPoints = append(_toAnySlice(newPoints), any(edgePoints[idx]))
		edgePointNums[key(e.Pn1, e.Pn2)] = nextPoint
		nextPoint = (nextPoint + 1)
		idx = (idx + 1)
	}
	var newFaces [][]int = [][]int{}
	fnum := 0
	for fnum < len(any(faces)) {
		oldFace := faces[fnum]
		if len(any(oldFace)) == 4 {
			a := oldFace[0]
			b := oldFace[1]
			c := oldFace[2]
			d := oldFace[3]
			fpnum := facePointNums[fnum]
			ab := edgePointNums[key(a, b)]
			da := edgePointNums[key(d, a)]
			bc := edgePointNums[key(b, c)]
			cd := edgePointNums[key(c, d)]
			newFaces = append(_toAnySlice(newFaces), any([]int{
				a,
				ab,
				fpnum,
				da,
			}))
			newFaces = append(_toAnySlice(newFaces), any([]int{
				b,
				bc,
				fpnum,
				ab,
			}))
			newFaces = append(_toAnySlice(newFaces), any([]int{
				c,
				cd,
				fpnum,
				bc,
			}))
			newFaces = append(_toAnySlice(newFaces), any([]int{
				d,
				da,
				fpnum,
				cd,
			}))
		}
		fnum = (fnum + 1)
	}
	return []any{_toAnySlice(newPoints), _toAnySlice(newFaces)}
}

// line 318
func formatPoint(p Point) string {
	return "[" + fmt4(p.X) + " " + fmt4(p.Y) + " " + fmt4(p.Z) + "]"
}

// line 322
func formatFace(f []int) string {
	if len(any(f)) == 0 {
		return "[]"
	}
	s := "[" + fmt2(f[0])
	i := 1
	for i < len(any(f)) {
		s = s + " " + fmt2(f[i])
		i = (i + 1)
	}
	s = s + "]"
	return s
}

// line 334
func main() {
	inputPoints := []Point{
		Point{X: -1.0, Y: 1.0, Z: 1.0},
		Point{X: -1.0, Y: -1.0, Z: 1.0},
		Point{X: 1.0, Y: -1.0, Z: 1.0},
		Point{X: 1.0, Y: 1.0, Z: 1.0},
		Point{X: 1.0, Y: -1.0, Z: -1.0},
		Point{X: 1.0, Y: 1.0, Z: -1.0},
		Point{X: -1.0, Y: -1.0, Z: -1.0},
		Point{X: -1.0, Y: 1.0, Z: -1.0},
	}
	inputFaces := [][]int{
		[]int{
			0,
			1,
			2,
			3,
		},
		[]int{
			3,
			2,
			4,
			5,
		},
		[]int{
			5,
			4,
			6,
			7,
		},
		[]int{
			7,
			0,
			3,
			5,
		},
		[]int{
			7,
			6,
			1,
			0,
		},
		[]int{
			6,
			1,
			2,
			4,
		},
	}
	outputPoints := inputPoints
	outputFaces := inputFaces
	i := 0
	for i < 1 {
		res := cmcSubdiv(outputPoints, outputFaces)
		outputPoints = (((res[0]).([]Point)).([]Point)).([]Point)
		outputFaces = (((res[1]).([][]int)).([][]int)).([][]int)
		i = (i + 1)
	}
	for _, p := range outputPoints {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(formatPoint(&p))), "\n"))
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
	for _, f := range outputFaces {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(formatFace(f))), "\n"))
	}
}

func main() {
	main()
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
