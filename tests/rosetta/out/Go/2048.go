//go:build ignore

// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"mochi/runtime/data"
	"os"
	"reflect"
	"strconv"
	"strings"
	"time"
)

type v map[string]any

// line 4
func newBoard() [][]int {
	var b [][]int = [][]int{}
	y := 0
	for y < SIZE {
		var row []int = []int{}
		x := 0
		for x < SIZE {
			row = append(row, 0)
			x = (x + 1)
		}
		b = append(b, row)
		y = (y + 1)
	}
	return b
}

// line 20
func spawnTile(b *[][]int) map[string]any {
	var empty [][]int = [][]int{}
	y := 0
	for y < SIZE {
		x := 0
		for x < SIZE {
			if _equal((*b)[y][x], 0) {
				empty = append(empty, []int{x, y})
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	if len(empty) == 0 {
		return map[string]any{"board": b, "full": true}
	}
	idx := (int64(_now()) % int64(len(empty)))
	cell := empty[idx]
	val := 4
	if (int64(_now()) % int64(10)) < 9 {
		val = 2
	}
	(*b)[cell[1]][cell[0]] = val
	return map[string]any{"board": b, "full": (len(empty) == 1)}
}

// line 42
func pad(n int) string {
	s := fmt.Sprint(any(n))
	pad := (4 - len([]rune(s)))
	i := 0
	out := ""
	for i < pad {
		out = out + " "
		i = (i + 1)
	}
	return out + s
}

// line 54
func draw(b [][]int, score int) {
	fmt.Println(any("Score: " + fmt.Sprint(any(score))))
	y := 0
	for y < SIZE {
		fmt.Println(any("+----+----+----+----+"))
		line := "|"
		x := 0
		for x < SIZE {
			v := b[y][x]
			if v == 0 {
				line = line + "    |"
			} else {
				line = line + pad(v) + "|"
			}
			x = (x + 1)
		}
		fmt.Println(any(line))
		y = (y + 1)
	}
	fmt.Println(any("+----+----+----+----+"))
	fmt.Println(any("W=Up S=Down A=Left D=Right Q=Quit"))
}

// line 77
func reverseRow(r []int) []int {
	var out []int = []int{}
	i := (len(r) - 1)
	for i >= 0 {
		out = append(out, r[i])
		i = (i - 1)
	}
	return out
}

// line 87
func slideLeft(row []int) map[string]any {
	var xs []int = []int{}
	i := 0
	for i < len(row) {
		if row[i] != 0 {
			xs = append(xs, row[i])
		}
		i = (i + 1)
	}
	var res []int = []int{}
	gain := 0
	i = 0
	for i < len(xs) {
		if ((i + 1) < len(xs)) && (xs[i] == xs[(i+1)]) {
			v := (xs[i] * 2)
			gain = (gain + v)
			res = append(res, v)
			i = (i + 2)
		} else {
			res = append(res, xs[i])
			i = (i + 1)
		}
	}
	for len(res) < SIZE {
		res = append(res, 0)
	}
	return map[string]any{"row": res, "gain": gain}
}

// line 112
func moveLeft(b *[][]int, score int) map[string]any {
	moved := false
	y := 0
	for y < SIZE {
		r := slideLeft(((*b)[y]).([]int))
		new := r["row"]
		score = int(int(int((float64(score) + (r["gain"]).(float64)))))
		x := 0
		for x < SIZE {
			if !_equal((*b)[y][x], (new).([]any)[x]) {
				moved = true
			}
			(*b)[y][x] = ((((new).([]any)[x]).(int)).(int)).(int)
			x = (x + 1)
		}
		y = (y + 1)
	}
	return map[string]any{
		"board": b,
		"score": score,
		"moved": moved,
	}
}

// line 130
func moveRight(b *[][]int, score int) map[string]any {
	moved := false
	y := 0
	for y < SIZE {
		rev := reverseRow(((*b)[y]).([]int))
		r := slideLeft(rev)
		rev = (((r["row"]).([]int)).([]int)).([]int)
		score = int(int(int((float64(score) + (r["gain"]).(float64)))))
		rev = reverseRow(rev)
		x := 0
		for x < SIZE {
			if !_equal((*b)[y][x], rev[x]) {
				moved = true
			}
			(*b)[y][x] = rev[x]
			x = (x + 1)
		}
		y = (y + 1)
	}
	return map[string]any{
		"board": b,
		"score": score,
		"moved": moved,
	}
}

// line 150
func getCol(b [][]int, x int) []int {
	var col []int = []int{}
	y := 0
	for y < SIZE {
		col = append(col, b[y][x])
		y = (y + 1)
	}
	return col
}

// line 160
func setCol(b *[][]int, x int, col []int) {
	y := 0
	for y < SIZE {
		(*b)[y][x] = col[y]
		y = (y + 1)
	}
}

// line 168
func moveUp(b *[][]int, score int) map[string]any {
	moved := false
	x := 0
	for x < SIZE {
		col := getCol(b, x)
		r := slideLeft(col)
		new := r["row"]
		score = int(int(int((float64(score) + (r["gain"]).(float64)))))
		y := 0
		for y < SIZE {
			if !_equal((*b)[y][x], (new).([]any)[y]) {
				moved = true
			}
			(*b)[y][x] = ((((new).([]any)[y]).(int)).(int)).(int)
			y = (y + 1)
		}
		x = (x + 1)
	}
	return map[string]any{
		"board": b,
		"score": score,
		"moved": moved,
	}
}

// line 187
func moveDown(b *[][]int, score int) map[string]any {
	moved := false
	x := 0
	for x < SIZE {
		col := reverseRow(getCol(b, x))
		r := slideLeft(col)
		col = (((r["row"]).([]int)).([]int)).([]int)
		score = int(int(int((float64(score) + (r["gain"]).(float64)))))
		col = reverseRow(col)
		y := 0
		for y < SIZE {
			if !_equal((*b)[y][x], col[y]) {
				moved = true
			}
			(*b)[y][x] = col[y]
			y = (y + 1)
		}
		x = (x + 1)
	}
	return map[string]any{
		"board": b,
		"score": score,
		"moved": moved,
	}
}

// line 207
func hasMoves(b [][]int) bool {
	y := 0
	for y < SIZE {
		x := 0
		for x < SIZE {
			if b[y][x] == 0 {
				return true
			}
			if ((x + 1) < SIZE) && (b[y][x] == b[y][(x+1)]) {
				return true
			}
			if ((y + 1) < SIZE) && (b[y][x] == b[(y + 1)][x]) {
				return true
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return false
}

// line 222
func has2048(b [][]int) bool {
	y := 0
	for y < SIZE {
		x := 0
		for x < SIZE {
			if b[y][x] >= 2048 {
				return true
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return false
}

func main() {
	SIZE = 4
	board = newBoard()
	r = spawnTile(board)
	full = r["full"]
	score = 0
	board := newBoard()
	board = (((r["board"]).([][]int)).([][]int)).([][]int)
	full := r["full"]
	r = spawnTile(board)
	board = (((r["board"]).([][]int)).([][]int)).([][]int)
	full = r["full"]
	draw(board, score)
	for {
		fmt.Println(any("Move: "))
		cmd := _input()
		moved := false
		if (cmd == "a") || (cmd == "A") {
			m := moveLeft(board, score)
			board = (((m["board"]).([][]int)).([][]int)).([][]int)
			score = (((m["score"]).(int)).(int)).(int)
			moved = _exists(_exists(_exists(m["moved"])))
		}
		if (cmd == "d") || (cmd == "D") {
			m := moveRight(board, score)
			board = (((m["board"]).([][]int)).([][]int)).([][]int)
			score = (((m["score"]).(int)).(int)).(int)
			moved = _exists(_exists(_exists(m["moved"])))
		}
		if (cmd == "w") || (cmd == "W") {
			m := moveUp(board, score)
			board = (((m["board"]).([][]int)).([][]int)).([][]int)
			score = (((m["score"]).(int)).(int)).(int)
			moved = _exists(_exists(_exists(m["moved"])))
		}
		if (cmd == "s") || (cmd == "S") {
			m := moveDown(board, score)
			board = (((m["board"]).([][]int)).([][]int)).([][]int)
			score = (((m["score"]).(int)).(int)).(int)
			moved = _exists(_exists(_exists(m["moved"])))
		}
		if (cmd == "q") || (cmd == "Q") {
			break
		}
		if moved {
			r2 := spawnTile(board)
			board = (((r2["board"]).([][]int)).([][]int)).([][]int)
			full = r2["full"]
			if _exists((_exists(full) && (!(hasMoves(board))))) {
				draw(board, score)
				fmt.Println(any("Game Over"))
				break
			}
		}
		draw(board, score)
		if has2048(board) {
			fmt.Println(any("You win!"))
			break
		}
		if !(hasMoves(board)) {
			fmt.Println(any("Game Over"))
			break
		}
	}
}

func _convertMapAny(m map[any]any) map[string]any {
	out := make(map[string]any, len(m))
	for k, v := range m {
		key := fmt.Sprint(k)
		if sub, ok := v.(map[any]any); ok {
			out[key] = _convertMapAny(sub)
		} else {
			out[key] = v
		}
	}
	return out
}

func _copyToMap(dst map[string]any, src any) {
	switch m := src.(type) {
	case map[string]any:
		for k, v := range m {
			dst[k] = v
		}
	case map[string]string:
		for k, v := range m {
			dst[k] = v
		}
	case map[any]any:
		for k, v := range _convertMapAny(m) {
			dst[k] = v
		}
	default:
		rv := reflect.ValueOf(m)
		if rv.Kind() == reflect.Struct {
			rt := rv.Type()
			for i := 0; i < rv.NumField(); i++ {
				name := rt.Field(i).Name
				if tag := rt.Field(i).Tag.Get("json"); tag != "" {
					if c := strings.Index(tag, ","); c >= 0 {
						tag = tag[:c]
					}
					if tag != "-" {
						name = tag
					}
				}
				dst[name] = rv.Field(i).Interface()
			}
		}
	}
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Struct && bv.Kind() == reflect.Map {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Struct {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}

func _exists(v any) bool {
	if g, ok := v.(*data.Group); ok {
		return len(g.Items) > 0
	}
	switch s := v.(type) {
	case []any:
		return len(s) > 0
	case []int:
		return len(s) > 0
	case []float64:
		return len(s) > 0
	case []string:
		return len(s) > 0
	case []bool:
		return len(s) > 0
	case bool:
		return s
	case []map[string]any:
		return len(s) > 0
	case map[string]any:
		return len(s) > 0
	case map[string]int:
		return len(s) > 0
	case string:
		return len([]rune(s)) > 0
	}
	rv := reflect.ValueOf(v)
	switch rv.Kind() {
	case reflect.Slice, reflect.Array:
		return rv.Len() > 0
	case reflect.Map:
		return !rv.IsNil() && rv.Len() > 0
	case reflect.Pointer:
		return !rv.IsNil()
	case reflect.Struct:
		return !rv.IsZero()
	}
	return false
}

func _input() string {
	var s string
	fmt.Scanln(&s)
	return s
}

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}
