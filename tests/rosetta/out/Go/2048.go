//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"mochi/runtime/data"
	"reflect"
	"strings"
	"time"
)

type v map[string]any

// line 4
func newBoard() [][]int {
	var b [][]int = [][]int{}
	y := 0
	for y < SIZE {
		var row []int = []int{}
		x := 0
		for x < SIZE {
			row = append(_toAnySlice(row), any(0))
			x = (x + 1)
		}
		b = append(_toAnySlice(b), any(row))
		y = (y + 1)
	}
	return b
}

// line 20
func spawnTile(b *[][]int) map[string]any {
	var empty [][]int = [][]int{}
	y := 0
	for y < SIZE {
		x := 0
		for x < SIZE {
			if b[y][x] == 0 {
				empty = append(_toAnySlice(empty), any([]int{x, y}))
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	if len(any(empty)) == 0 {
		return map[string]any{"board": b, "full": true}
	}
	idx := (int64(time.Now().UnixNano()) % int64(len(any(empty))))
	cell := empty[idx]
	val := 4
	if (int64(time.Now().UnixNano()) % int64(10)) < 9 {
		val = 2
	}
	b[cell[1]][cell[0]] = val
	return map[string]any{"board": b, "full": (len(any(empty)) == 1)}
}

// line 42
func pad(n int) string {
	s := fmt.Sprint(any(n))
	pad := (4 - len(any(s)))
	i := 0
	out := ""
	for i < pad {
		out = out + " "
		i = (i + 1)
	}
	return out + s
}

// line 54
func draw(b [][]int, score int) {
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Score: "+fmt.Sprint(any(score)))), "\n"))
	y := 0
	for y < SIZE {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("+----+----+----+----+")), "\n"))
		line := "|"
		x := 0
		for x < SIZE {
			v := b[y][x]
			if v == 0 {
				line = line + "    |"
			} else {
				line = line + pad(v) + "|"
			}
			x = (x + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
		y = (y + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("+----+----+----+----+")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("W=Up S=Down A=Left D=Right Q=Quit")), "\n"))
}

// line 77
func reverseRow(r []int) []int {
	var out []int = []int{}
	i := (len(any(r)) - 1)
	for i >= 0 {
		out = append(_toAnySlice(out), any(r[i]))
		i = (i - 1)
	}
	return out
}

// line 87
func slideLeft(row []int) map[string]any {
	var xs []int = []int{}
	i := 0
	for i < len(any(row)) {
		if row[i] != 0 {
			xs = append(_toAnySlice(xs), any(row[i]))
		}
		i = (i + 1)
	}
	var res []int = []int{}
	gain := 0
	i = 0
	for i < len(any(xs)) {
		if ((i + 1) < len(any(xs))) && (xs[i] == xs[(i+1)]) {
			v := (xs[i] * 2)
			gain = (gain + v)
			res = append(_toAnySlice(res), any(v))
			i = (i + 2)
		} else {
			res = append(_toAnySlice(res), any(xs[i]))
			i = (i + 1)
		}
	}
	for len(any(res)) < SIZE {
		res = append(_toAnySlice(res), any(0))
	}
	return map[string]any{"row": res, "gain": gain}
}

// line 112
func moveLeft(b *[][]int, score int) map[string]any {
	moved := false
	y := 0
	for y < SIZE {
		r := slideLeft(b[y])
		new := r["row"]
		score = int(int(int((float64(score) + (r["gain"]).(float64)))))
		x := 0
		for x < SIZE {
			if !_equal(b[y][x], (new).([]any)[x]) {
				moved = true
			}
			b[y][x] = ((((new).([]any)[x]).(int)).(int)).(int)
			x = (x + 1)
		}
		y = (y + 1)
	}
	return map[string]any{
		"board": b,
		"score": score,
		"moved": moved,
	}
}

// line 130
func moveRight(b *[][]int, score int) map[string]any {
	moved := false
	y := 0
	for y < SIZE {
		rev := reverseRow(b[y])
		r := slideLeft(rev)
		rev = (((r["row"]).([]int)).([]int)).([]int)
		score = int(int(int((float64(score) + (r["gain"]).(float64)))))
		rev = reverseRow(rev)
		x := 0
		for x < SIZE {
			if b[y][x] != rev[x] {
				moved = true
			}
			b[y][x] = rev[x]
			x = (x + 1)
		}
		y = (y + 1)
	}
	return map[string]any{
		"board": b,
		"score": score,
		"moved": moved,
	}
}

// line 150
func getCol(b [][]int, x int) []int {
	var col []int = []int{}
	y := 0
	for y < SIZE {
		col = append(_toAnySlice(col), any(b[y][x]))
		y = (y + 1)
	}
	return col
}

// line 160
func setCol(b *[][]int, x int, col []int) {
	y := 0
	for y < SIZE {
		b[y][x] = col[y]
		y = (y + 1)
	}
}

// line 168
func moveUp(b *[][]int, score int) map[string]any {
	moved := false
	x := 0
	for x < SIZE {
		col := getCol(b, x)
		r := slideLeft(col)
		new := r["row"]
		score = int(int(int((float64(score) + (r["gain"]).(float64)))))
		y := 0
		for y < SIZE {
			if !_equal(b[y][x], (new).([]any)[y]) {
				moved = true
			}
			b[y][x] = ((((new).([]any)[y]).(int)).(int)).(int)
			y = (y + 1)
		}
		x = (x + 1)
	}
	return map[string]any{
		"board": b,
		"score": score,
		"moved": moved,
	}
}

// line 187
func moveDown(b *[][]int, score int) map[string]any {
	moved := false
	x := 0
	for x < SIZE {
		col := reverseRow(getCol(b, x))
		r := slideLeft(col)
		col = (((r["row"]).([]int)).([]int)).([]int)
		score = int(int(int((float64(score) + (r["gain"]).(float64)))))
		col = reverseRow(col)
		y := 0
		for y < SIZE {
			if b[y][x] != col[y] {
				moved = true
			}
			b[y][x] = col[y]
			y = (y + 1)
		}
		x = (x + 1)
	}
	return map[string]any{
		"board": b,
		"score": score,
		"moved": moved,
	}
}

// line 207
func hasMoves(b [][]int) bool {
	y := 0
	for y < SIZE {
		x := 0
		for x < SIZE {
			if b[y][x] == 0 {
				return true
			}
			if ((x + 1) < SIZE) && (b[y][x] == b[y][(x+1)]) {
				return true
			}
			if ((y + 1) < SIZE) && (b[y][x] == b[(y + 1)][x]) {
				return true
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return false
}

// line 222
func has2048(b [][]int) bool {
	y := 0
	for y < SIZE {
		x := 0
		for x < SIZE {
			if b[y][x] >= 2048 {
				return true
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return false
}

var SIZE int
var r map[string]any
var score int

func main() {
	SIZE = 4
	r = spawnTile(board)
	score = 0
	board := newBoard()
	board = (((r["board"]).([][]int)).([][]int)).([][]int)
	full := r["full"]
	r = spawnTile(board)
	board = (((r["board"]).([][]int)).([][]int)).([][]int)
	full = r["full"]
	draw(board, score)
	for {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Move: ")), "\n"))
		cmd := _input()
		moved := false
		if (cmd == "a") || (cmd == "A") {
			m := moveLeft(board, score)
			board = (((m["board"]).([][]int)).([][]int)).([][]int)
			score = (((m["score"]).(int)).(int)).(int)
			moved = _exists(_exists(_exists(m["moved"])))
		}
		if (cmd == "d") || (cmd == "D") {
			m := moveRight(board, score)
			board = (((m["board"]).([][]int)).([][]int)).([][]int)
			score = (((m["score"]).(int)).(int)).(int)
			moved = _exists(_exists(_exists(m["moved"])))
		}
		if (cmd == "w") || (cmd == "W") {
			m := moveUp(board, score)
			board = (((m["board"]).([][]int)).([][]int)).([][]int)
			score = (((m["score"]).(int)).(int)).(int)
			moved = _exists(_exists(_exists(m["moved"])))
		}
		if (cmd == "s") || (cmd == "S") {
			m := moveDown(board, score)
			board = (((m["board"]).([][]int)).([][]int)).([][]int)
			score = (((m["score"]).(int)).(int)).(int)
			moved = _exists(_exists(_exists(m["moved"])))
		}
		if (cmd == "q") || (cmd == "Q") {
			break
		}
		if moved {
			r2 := spawnTile(board)
			board = (((r2["board"]).([][]int)).([][]int)).([][]int)
			full = r2["full"]
			if _exists((_exists(full) && (!(hasMoves(board))))) {
				draw(board, score)
				fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Game Over")), "\n"))
				break
			}
		}
		draw(board, score)
		if has2048(board) {
			fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("You win!")), "\n"))
			break
		}
		if !(hasMoves(board)) {
			fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Game Over")), "\n"))
			break
		}
	}
}

func _convertMapAny(m map[any]any) map[string]any {
	out := make(map[string]any, len(m))
	for k, v := range m {
		key := fmt.Sprint(k)
		if sub, ok := v.(map[any]any); ok {
			out[key] = _convertMapAny(sub)
		} else {
			out[key] = v
		}
	}
	return out
}

func _copyToMap(dst map[string]any, src any) {
	switch m := src.(type) {
	case map[string]any:
		for k, v := range m {
			dst[k] = v
		}
	case map[string]string:
		for k, v := range m {
			dst[k] = v
		}
	case map[any]any:
		for k, v := range _convertMapAny(m) {
			dst[k] = v
		}
	default:
		rv := reflect.ValueOf(m)
		if rv.Kind() == reflect.Struct {
			rt := rv.Type()
			for i := 0; i < rv.NumField(); i++ {
				name := rt.Field(i).Name
				if tag := rt.Field(i).Tag.Get("json"); tag != "" {
					if c := strings.Index(tag, ","); c >= 0 {
						tag = tag[:c]
					}
					if tag != "-" {
						name = tag
					}
				}
				dst[name] = rv.Field(i).Interface()
			}
		}
	}
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Struct && bv.Kind() == reflect.Map {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Struct {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}

func _exists(v any) bool {
	if g, ok := v.(*data.Group); ok {
		return len(g.Items) > 0
	}
	switch s := v.(type) {
	case []any:
		return len(s) > 0
	case []int:
		return len(s) > 0
	case []float64:
		return len(s) > 0
	case []string:
		return len(s) > 0
	case []bool:
		return len(s) > 0
	case bool:
		return s
	case []map[string]any:
		return len(s) > 0
	case map[string]any:
		return len(s) > 0
	case map[string]int:
		return len(s) > 0
	case string:
		return len([]rune(s)) > 0
	}
	rv := reflect.ValueOf(v)
	switch rv.Kind() {
	case reflect.Slice, reflect.Array:
		return rv.Len() > 0
	case reflect.Map:
		return !rv.IsNil() && rv.Len() > 0
	case reflect.Pointer:
		return !rv.IsNil()
	case reflect.Struct:
		return !rv.IsZero()
	}
	return false
}

func _input() string {
	var s string
	fmt.Scanln(&s)
	return s
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
