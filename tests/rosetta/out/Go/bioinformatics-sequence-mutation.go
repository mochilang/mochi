//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 5
func randInt(s int, n int) []int {
	next := (((s * 1664525) + 1013904223) % 2147483647)
	return []int{next, (next % n)}
}

// line 10
func padLeft(s string, w int) string {
	res := ""
	n := (w - len(any(s)))
	for n > 0 {
		res = res + " "
		n = (n - 1)
	}
	return res + s
}

// line 20
func makeSeq(s int, le int) []any {
	bases := "ACGT"
	out := ""
	i := 0
	for i < le {
		r := randInt(s, 4)
		s = r[0]
		idx := r[1]
		out = out + string([]rune(bases)[idx:(idx+1)])
		i = (i + 1)
	}
	return []any{s, out}
}

// line 34
func mutate(s int, dna string, w []int) []any {
	bases := "ACGT"
	le := len(any(dna))
	r := randInt(s, le)
	s = r[0]
	p := r[1]
	r = randInt(s, 300)
	s = r[0]
	x := r[1]
	var arr []string = []string{}
	i := 0
	for i < le {
		arr = append(_toAnySlice(arr), any(string([]rune(dna)[i:(i+1)])))
		i = (i + 1)
	}
	if x < w[0] {
		r = randInt(s, 4)
		s = r[0]
		idx := r[1]
		b := string([]rune(bases)[idx:(idx + 1)])
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("  Change @"+padLeft(fmt.Sprint(any(p)), 3)+" '"+arr[p]+"' to '"+b+"'")), "\n"))
		arr[p] = b
	} else if x < (w[0] + w[1]) {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("  Delete @"+padLeft(fmt.Sprint(any(p)), 3)+" '"+arr[p]+"'")), "\n"))
		j := p
		for j < (len(any(arr)) - 1) {
			arr[j] = arr[(j + 1)]
			j = (j + 1)
		}
		arr = arr[0:(len(any(arr)) - 1)]
	} else {
		r = randInt(s, 4)
		s = r[0]
		idx2 := r[1]
		b := string([]rune(bases)[idx2:(idx2 + 1)])
		arr = append(_toAnySlice(arr), any(""))
		j := (len(any(arr)) - 1)
		for j > p {
			arr[j] = arr[(j - 1)]
			j = (j - 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("  Insert @"+padLeft(fmt.Sprint(any(p)), 3)+" '"+b+"'")), "\n"))
		arr[p] = b
	}
	out := ""
	i = 0
	for i < len(any(arr)) {
		out = out + arr[i]
		i = (i + 1)
	}
	return []any{s, out}
}

// line 90
func prettyPrint(dna string, rowLen int) {
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("SEQUENCE:")), "\n"))
	le := len(any(dna))
	i := 0
	for i < le {
		k := (i + rowLen)
		if k > le {
			k = le
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(padLeft(fmt.Sprint(any(i)), 5)+": "+string([]rune(dna)[i:k]))), "\n"))
		i = (i + rowLen)
	}
	a := 0
	c := 0
	g := 0
	t := 0
	idx := 0
	for idx < le {
		ch := string([]rune(dna)[idx:(idx + 1)])
		if ch == "A" {
			a = (a + 1)
		} else {
			if ch == "C" {
				c = (c + 1)
			} else {
				if ch == "G" {
					g = (g + 1)
				} else {
					if ch == "T" {
						t = (t + 1)
					}
				}
			}
		}
		idx = (idx + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("BASE COUNT:")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("    A: "+padLeft(fmt.Sprint(any(a)), 3))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("    C: "+padLeft(fmt.Sprint(any(c)), 3))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("    G: "+padLeft(fmt.Sprint(any(g)), 3))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("    T: "+padLeft(fmt.Sprint(any(t)), 3))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("    ------")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("    Î£: "+fmt.Sprint(any(le)))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("    ======")), "\n"))
}

// line 127
func wstring(w []int) string {
	return "  Change: " + fmt.Sprint(any(w[0])) + "\n  Delete: " + fmt.Sprint(any(w[1])) + "\n  Insert: " + fmt.Sprint(any(w[2])) + "\n"
}

// line 131
func main() {
	seed := 1
	res := makeSeq(seed, 250)
	seed = (((res[0]).(int)).(int)).(int)
	dna := (res[1]).(string)
	prettyPrint(dna, 50)
	muts := 10
	w := []int{100, 100, 100}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nWEIGHTS (ex 300):")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(wstring(w))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("MUTATIONS ("+"10"+"):")), "\n"))
	i := 0
	for i < muts {
		res = mutate(seed, dna, w)
		seed = (((res[0]).(int)).(int)).(int)
		dna = (res[1]).(string)
		i = (i + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
	prettyPrint(dna, 50)
}

func main() {
	main()
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
