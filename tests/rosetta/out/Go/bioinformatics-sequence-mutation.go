//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
)

type v map[string]any

// line 5
func randInt(s int, n int) []int {
	next := (((s * 1664525) + 1013904223) % 2147483647)
	return []int{next, (next % n)}
}

// line 10
func padLeft(s string, w int) string {
	res := ""
	n := (w - len(s))
	for n > 0 {
		res = res + " "
		n = (n - 1)
	}
	return res + s
}

// line 20
func makeSeq(s int, le int) []any {
	bases := "ACGT"
	out := ""
	i := 0
	for i < le {
		r := randInt(s, 4)
		s = r[0]
		idx := r[1]
		out = out + string([]rune(bases)[idx:(idx+1)])
		i = (i + 1)
	}
	return []any{s, out}
}

// line 34
func mutate(s int, dna string, w []int) []any {
	bases := "ACGT"
	le := len(dna)
	r := randInt(s, le)
	s = r[0]
	p := r[1]
	r = randInt(s, 300)
	s = r[0]
	x := r[1]
	var arr []string = []string{}
	i := 0
	for i < le {
		arr = append(arr, string([]rune(dna)[i:(i+1)]))
		i = (i + 1)
	}
	if x < w[0] {
		r = randInt(s, 4)
		s = r[0]
		idx := r[1]
		b := string([]rune(bases)[idx:(idx + 1)])
		fmt.Println("  Change @" + padLeft(fmt.Sprint(p), 3) + " '" + arr[p] + "' to '" + b + "'")
		arr[p] = b
	} else if x < (w[0] + w[1]) {
		fmt.Println("  Delete @" + padLeft(fmt.Sprint(p), 3) + " '" + arr[p] + "'")
		j := p
		for j < (len(arr) - 1) {
			arr[j] = arr[(j + 1)]
			j = (j + 1)
		}
		arr = arr[0:(len(arr) - 1)]
	} else {
		r = randInt(s, 4)
		s = r[0]
		idx2 := r[1]
		b := string([]rune(bases)[idx2:(idx2 + 1)])
		arr = append(arr, "")
		j := (len(arr) - 1)
		for j > p {
			arr[j] = arr[(j - 1)]
			j = (j - 1)
		}
		fmt.Println("  Insert @" + padLeft(fmt.Sprint(p), 3) + " '" + b + "'")
		arr[p] = b
	}
	out := ""
	i = 0
	for i < len(arr) {
		out = out + arr[i]
		i = (i + 1)
	}
	return []any{s, out}
}

// line 90
func prettyPrint(dna string, rowLen int) {
	fmt.Println("SEQUENCE:")
	le := len(dna)
	i := 0
	for i < le {
		k := (i + rowLen)
		if k > le {
			k = le
		}
		fmt.Println(padLeft(fmt.Sprint(i), 5) + ": " + string([]rune(dna)[i:k]))
		i = (i + rowLen)
	}
	a := 0
	c := 0
	g := 0
	t := 0
	idx := 0
	for idx < le {
		ch := string([]rune(dna)[idx:(idx + 1)])
		if ch == "A" {
			a = (a + 1)
		} else {
			if ch == "C" {
				c = (c + 1)
			} else {
				if ch == "G" {
					g = (g + 1)
				} else {
					if ch == "T" {
						t = (t + 1)
					}
				}
			}
		}
		idx = (idx + 1)
	}
	fmt.Println("")
	fmt.Println("BASE COUNT:")
	fmt.Println("    A: " + padLeft(fmt.Sprint(a), 3))
	fmt.Println("    C: " + padLeft(fmt.Sprint(c), 3))
	fmt.Println("    G: " + padLeft(fmt.Sprint(g), 3))
	fmt.Println("    T: " + padLeft(fmt.Sprint(t), 3))
	fmt.Println("    ------")
	fmt.Println("    Î£: " + fmt.Sprint(le))
	fmt.Println("    ======")
}

// line 127
func wstring(w []int) string {
	return "  Change: " + fmt.Sprint(w[0]) + "\n  Delete: " + fmt.Sprint(w[1]) + "\n  Insert: " + fmt.Sprint(w[2]) + "\n"
}

// line 131
func main() {
	seed := 1
	res := makeSeq(seed, 250)
	seed = (((res[0]).(int)).(int)).(int)
	dna := (res[1]).(string)
	prettyPrint(dna, 50)
	muts := 10
	w := []int{100, 100, 100}
	fmt.Println("\nWEIGHTS (ex 300):")
	fmt.Println(wstring(w))
	fmt.Println("MUTATIONS (" + "10" + "):")
	i := 0
	for i < muts {
		res = mutate(seed, dna, w)
		seed = (((res[0]).(int)).(int)).(int)
		dna = (res[1]).(string)
		i = (i + 1)
	}
	fmt.Println("")
	prettyPrint(dna, 50)
}

func main() {
	main()
}
