//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func sieve(limit int) []int {
	var spf []int = []int{}
	i := 0
	for i <= limit {
		spf = append(_toAnySlice(spf), any(0))
		i = (i + 1)
	}
	i = 2
	for i <= limit {
		if spf[i] == 0 {
			spf[i] = i
			if (i * i) <= limit {
				j := (i * i)
				for j <= limit {
					if spf[j] == 0 {
						spf[j] = i
					}
					j = (j + i)
				}
			}
		}
		i = (i + 1)
	}
	return spf
}

// line 28
func primesFrom(spf []int, limit int) []int {
	var primes []int = []int{}
	i := 3
	for i <= limit {
		if spf[i] == i {
			primes = append(_toAnySlice(primes), any(i))
		}
		i = (i + 1)
	}
	return primes
}

// line 38
func pad3(n int) string {
	s := fmt.Sprint(any(n))
	for len(any(s)) < 3 {
		s = " " + s
	}
	return s
}

// line 44
func commatize(n int) string {
	s := fmt.Sprint(any(n))
	out := ""
	i := (len(any(s)) - 1)
	c := 0
	for i >= 0 {
		out = string([]rune(s)[i:(i+1)]) + out
		c = (c + 1)
		if ((c % 3) == 0) && (i > 0) {
			out = "," + out
		}
		i = (i - 1)
	}
	return out
}

// line 58
func primeCount(primes []int, last int, spf []int) int {
	lo := 0
	hi := len(any(primes))
	for lo < hi {
		mid := int((float64((lo + hi)) / float64(2)))
		if primes[mid] < last {
			lo = (mid + 1)
		} else {
			hi = mid
		}
	}
	count := (lo + 1)
	if spf[last] != last {
		count = (count - 1)
	}
	return count
}

// line 74
func arithmeticNumbers(limit int, spf []int) []int {
	var arr []int = []int{1}
	n := 3
	for len(any(arr)) < limit {
		if spf[n] == n {
			arr = append(_toAnySlice(arr), any(n))
		} else {
			x := n
			sigma := 1
			tau := 1
			for x > 1 {
				p := spf[x]
				if p == 0 {
					p = x
				}
				cnt := 0
				power := p
				sum := 1
				for (x % p) == 0 {
					x = int(int(int((float64(x) / float64(p)))))
					cnt = (cnt + 1)
					sum = (sum + power)
					power = (power * p)
				}
				sigma = (sigma * sum)
				tau = (tau * (cnt + 1))
			}
			if (sigma % tau) == 0 {
				arr = append(_toAnySlice(arr), any(n))
			}
		}
		n = (n + 1)
	}
	return arr
}

// line 106
func main() {
	limit := 1228663
	spf := sieve(limit)
	primes := primesFrom(spf, limit)
	arr := arithmeticNumbers(1000000, spf)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("The first 100 arithmetic numbers are:")), "\n"))
	i := 0
	for i < 100 {
		line := ""
		j := 0
		for j < 10 {
			line = line + pad3(arr[(i+j)])
			if j < 9 {
				line = line + " "
			}
			j = (j + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
		i = (i + 10)
	}
	for _, x := range []int{
		1000,
		10000,
		100000,
		1000000,
	} {
		last := arr[(x - 1)]
		lastc := commatize(last)
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nThe "+commatize(x)+"th arithmetic number is: "+lastc)), "\n"))
		pc := primeCount(primes, last, spf)
		comp := ((x - pc) - 1)
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("The count of such numbers <= "+lastc+" which are composite is "+commatize(comp)+".")), "\n"))
	}
}

func main() {
	main()
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
