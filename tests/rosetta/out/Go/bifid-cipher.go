//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 3
func square_to_maps(square [][]string) map[string]any {
	var emap map[string][]int = map[string][]int{}
	var dmap map[string]string = map[string]string{}
	x := 0
	for x < len(square) {
		row := square[x]
		y := 0
		for y < len(row) {
			ch := row[y]
			emap[ch] = []int{x, y}
			dmap[fmt.Sprint(x)+","+fmt.Sprint(y)] = ch
			y = (y + 1)
		}
		x = (x + 1)
	}
	return map[string]any{"e": emap, "d": dmap}
}

// line 21
func remove_space(text string, emap map[string][]int) string {
	s := strings.ToUpper(text)
	out := ""
	i := 0
	for i < len(s) {
		ch := string([]rune(s)[i:(i + 1)])
		key0 := ch
		m1 := emap
		_, ok2 := m1[key0]
		if (ch != " ") && ok2 {
			out = out + ch
		}
		i = (i + 1)
	}
	return out
}

// line 33
func encrypt(text string, emap map[string][]int, dmap map[string]string) string {
	text = remove_space(text, emap)
	var row0 []int = []int{}
	var row1 []int = []int{}
	i := 0
	for i < len(text) {
		ch := string([]rune(text)[i:(i + 1)])
		xy := emap[ch]
		row0 = append(row0, xy[0])
		row1 = append(row1, xy[1])
		i = (i + 1)
	}
	for _, v := range row1 {
		row0 = append(row0, v)
	}
	res := ""
	j := 0
	for j < len(row0) {
		key := fmt.Sprint(row0[j]) + "," + fmt.Sprint(row0[(j+1)])
		res = res + dmap[key]
		j = (j + 2)
	}
	return res
}

// line 56
func decrypt(text string, emap map[string][]int, dmap map[string]string) string {
	text = remove_space(text, emap)
	var coords []int = []int{}
	i := 0
	for i < len(text) {
		ch := string([]rune(text)[i:(i + 1)])
		xy := emap[ch]
		coords = append(coords, xy[0])
		coords = append(coords, xy[1])
		i = (i + 1)
	}
	half := (float64(len(coords)) / float64(2))
	var k1 []int = []int{}
	var k2 []int = []int{}
	idx := 0
	for float64(idx) < half {
		k1 = append(k1, coords[idx])
		idx = (idx + 1)
	}
	for idx < len(coords) {
		k2 = append(k2, coords[idx])
		idx = (idx + 1)
	}
	res := ""
	j := 0
	for float64(j) < half {
		key := fmt.Sprint(k1[j]) + "," + fmt.Sprint(k2[j])
		res = res + dmap[key]
		j = (j + 1)
	}
	return res
}

// line 89
func main() {
	squareRosetta := [][]string{
		[]string{
			"A",
			"B",
			"C",
			"D",
			"E",
		},
		[]string{
			"F",
			"G",
			"H",
			"I",
			"K",
		},
		[]string{
			"L",
			"M",
			"N",
			"O",
			"P",
		},
		[]string{
			"Q",
			"R",
			"S",
			"T",
			"U",
		},
		[]string{
			"V",
			"W",
			"X",
			"Y",
			"Z",
		},
		[]string{
			"J",
			"1",
			"2",
			"3",
			"4",
		},
	}
	squareWikipedia := [][]string{
		[]string{
			"B",
			"G",
			"W",
			"K",
			"Z",
		},
		[]string{
			"Q",
			"P",
			"N",
			"D",
			"S",
		},
		[]string{
			"I",
			"O",
			"A",
			"X",
			"E",
		},
		[]string{
			"F",
			"C",
			"L",
			"U",
			"M",
		},
		[]string{
			"T",
			"H",
			"Y",
			"V",
			"R",
		},
		[]string{
			"J",
			"1",
			"2",
			"3",
			"4",
		},
	}
	textRosetta := "0ATTACKATDAWN"
	textWikipedia := "FLEEATONCE"
	textTest := "The invasion will start on the first of January"
	maps := square_to_maps(squareRosetta)
	emap := maps["e"]
	dmap := maps["d"]
	fmt.Println("from Rosettacode")
	fmt.Println("original:\t " + textRosetta)
	s := encrypt(textRosetta, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println("codiert:\t " + s)
	s = decrypt(s, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println("and back:\t " + s)
	maps = square_to_maps(squareWikipedia)
	emap = maps["e"]
	dmap = maps["d"]
	fmt.Println("from Wikipedia")
	fmt.Println("original:\t " + textWikipedia)
	s = encrypt(textWikipedia, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println("codiert:\t " + s)
	s = decrypt(s, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println("and back:\t " + s)
	maps = square_to_maps(squareWikipedia)
	emap = maps["e"]
	dmap = maps["d"]
	fmt.Println("from Rosettacode long part")
	fmt.Println("original:\t " + textTest)
	s = encrypt(textTest, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println("codiert:\t " + s)
	s = decrypt(s, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println("and back:\t " + s)
}

func main() {
	main()
}
