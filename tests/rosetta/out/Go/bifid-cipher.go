//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 3
func square_to_maps(square [][]string) map[string]any {
	var emap map[string][]int = map[string][]int{}
	var dmap map[string]string = map[string]string{}
	x := 0
	for x < len(any(square)) {
		row := square[x]
		y := 0
		for y < len(any(row)) {
			ch := row[y]
			emap[ch] = []int{x, y}
			dmap[fmt.Sprint(any(x))+","+fmt.Sprint(any(y))] = ch
			y = (y + 1)
		}
		x = (x + 1)
	}
	return map[string]any{"e": emap, "d": dmap}
}

// line 21
func remove_space(text string, emap map[string][]int) string {
	s := strings.ToUpper(text)
	out := ""
	i := 0
	for i < len(any(s)) {
		ch := string([]rune(s)[i:(i + 1)])
		key0 := ch
		m1 := emap
		_, ok2 := m1[key0]
		if (ch != " ") && ok2 {
			out = out + ch
		}
		i = (i + 1)
	}
	return out
}

// line 33
func encrypt(text string, emap map[string][]int, dmap map[string]string) string {
	text = remove_space(text, emap)
	var row0 []int = []int{}
	var row1 []int = []int{}
	i := 0
	for i < len(any(text)) {
		ch := string([]rune(text)[i:(i + 1)])
		xy := emap[ch]
		row0 = append(_toAnySlice(row0), any(xy[0]))
		row1 = append(_toAnySlice(row1), any(xy[1]))
		i = (i + 1)
	}
	for _, v := range row1 {
		row0 = append(_toAnySlice(row0), any(v))
	}
	res := ""
	j := 0
	for j < len(any(row0)) {
		key := fmt.Sprint(any(row0[j])) + "," + fmt.Sprint(any(row0[(j+1)]))
		res = res + dmap[key]
		j = (j + 2)
	}
	return res
}

// line 56
func decrypt(text string, emap map[string][]int, dmap map[string]string) string {
	text = remove_space(text, emap)
	var coords []int = []int{}
	i := 0
	for i < len(any(text)) {
		ch := string([]rune(text)[i:(i + 1)])
		xy := emap[ch]
		coords = append(_toAnySlice(coords), any(xy[0]))
		coords = append(_toAnySlice(coords), any(xy[1]))
		i = (i + 1)
	}
	half := (float64(len(any(coords))) / float64(2))
	var k1 []int = []int{}
	var k2 []int = []int{}
	idx := 0
	for float64(idx) < half {
		k1 = append(_toAnySlice(k1), any(coords[idx]))
		idx = (idx + 1)
	}
	for idx < len(any(coords)) {
		k2 = append(_toAnySlice(k2), any(coords[idx]))
		idx = (idx + 1)
	}
	res := ""
	j := 0
	for float64(j) < half {
		key := fmt.Sprint(any(k1[j])) + "," + fmt.Sprint(any(k2[j]))
		res = res + dmap[key]
		j = (j + 1)
	}
	return res
}

// line 89
func main() {
	squareRosetta := [][]string{
		[]string{
			"A",
			"B",
			"C",
			"D",
			"E",
		},
		[]string{
			"F",
			"G",
			"H",
			"I",
			"K",
		},
		[]string{
			"L",
			"M",
			"N",
			"O",
			"P",
		},
		[]string{
			"Q",
			"R",
			"S",
			"T",
			"U",
		},
		[]string{
			"V",
			"W",
			"X",
			"Y",
			"Z",
		},
		[]string{
			"J",
			"1",
			"2",
			"3",
			"4",
		},
	}
	squareWikipedia := [][]string{
		[]string{
			"B",
			"G",
			"W",
			"K",
			"Z",
		},
		[]string{
			"Q",
			"P",
			"N",
			"D",
			"S",
		},
		[]string{
			"I",
			"O",
			"A",
			"X",
			"E",
		},
		[]string{
			"F",
			"C",
			"L",
			"U",
			"M",
		},
		[]string{
			"T",
			"H",
			"Y",
			"V",
			"R",
		},
		[]string{
			"J",
			"1",
			"2",
			"3",
			"4",
		},
	}
	textRosetta := "0ATTACKATDAWN"
	textWikipedia := "FLEEATONCE"
	textTest := "The invasion will start on the first of January"
	maps := square_to_maps(squareRosetta)
	emap := maps["e"]
	dmap := maps["d"]
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("from Rosettacode")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("original:\t "+textRosetta)), "\n"))
	s := encrypt(textRosetta, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("codiert:\t "+s)), "\n"))
	s = decrypt(s, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("and back:\t "+s)), "\n"))
	maps = square_to_maps(squareWikipedia)
	emap = maps["e"]
	dmap = maps["d"]
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("from Wikipedia")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("original:\t "+textWikipedia)), "\n"))
	s = encrypt(textWikipedia, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("codiert:\t "+s)), "\n"))
	s = decrypt(s, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("and back:\t "+s)), "\n"))
	maps = square_to_maps(squareWikipedia)
	emap = maps["e"]
	dmap = maps["d"]
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("from Rosettacode long part")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("original:\t "+textTest)), "\n"))
	s = encrypt(textTest, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("codiert:\t "+s)), "\n"))
	s = decrypt(s, (emap).(map[string][]int), (dmap).(map[string]string))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("and back:\t "+s)), "\n"))
}

func main() {
	main()
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
