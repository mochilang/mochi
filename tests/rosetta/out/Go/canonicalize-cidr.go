//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func split(s string, sep string) []string {
	var parts []string = []string{}
	cur := ""
	i := 0
	for i < len(any(s)) {
		if ((len(any(sep)) > 0) && ((i + len(any(sep))) <= len(any(s)))) && (string([]rune(s)[i:(i+len(any(sep)))]) == sep) {
			parts = append(_toAnySlice(parts), any(cur))
			cur = ""
			i = (i + len(any(sep)))
		} else {
			cur = cur + string([]rune(s)[i:(i+1)])
			i = (i + 1)
		}
	}
	parts = append(_toAnySlice(parts), any(cur))
	return parts
}

// line 22
func join(xs []string, sep string) string {
	res := ""
	i := 0
	for i < len(any(xs)) {
		if i > 0 {
			res = res + sep
		}
		res = res + xs[i]
		i = (i + 1)
	}
	return res
}

// line 33
func repeat(ch string, n int) string {
	out := ""
	i := 0
	for i < n {
		out = out + ch
		i = (i + 1)
	}
	return out
}

// line 43
func parseIntStr(str string) int {
	i := 0
	neg := false
	if (len(any(str)) > 0) && (string([]rune(str)[0:1]) == "-") {
		neg = true
		i = 1
	}
	n := 0
	digits := map[string]int{
		"0": 0,
		"1": 1,
		"2": 2,
		"3": 3,
		"4": 4,
		"5": 5,
		"6": 6,
		"7": 7,
		"8": 8,
		"9": 9,
	}
	for i < len(any(str)) {
		n = ((n * 10) + digits[string([]rune(str)[i:(i+1)])])
		i = (i + 1)
	}
	if neg {
		n = -n
	}
	return n
}

// line 71
func toBinary(n int, bits int) string {
	b := ""
	val := n
	i := 0
	for i < bits {
		b = fmt.Sprint(any((val % 2))) + b
		val = int((float64(val) / float64(2)))
		i = (i + 1)
	}
	return b
}

// line 83
func binToInt(bits string) int {
	n := 0
	i := 0
	for i < len(any(bits)) {
		n = ((n * 2) + parseIntStr(string([]rune(bits)[i:(i+1)])))
		i = (i + 1)
	}
	return n
}

// line 93
func padRight(s string, width int) string {
	out := s
	for len(any(out)) < width {
		out = out + " "
	}
	return out
}

// line 101
func canonicalize(cidr string) string {
	parts := split(cidr, "/")
	dotted := parts[0]
	size := parseIntStr(parts[1])
	var binParts []string = []string{}
	for _, p := range split(dotted, ".") {
		binParts = append(_toAnySlice(binParts), any(toBinary(parseIntStr(p), 8)))
	}
	binary := join(binParts, "")
	binary = string([]rune(binary)[0:size]) + repeat("0", (32-size))
	var canonParts []string = []string{}
	i := 0
	for i < len(any(binary)) {
		canonParts = append(_toAnySlice(canonParts), any(fmt.Sprint(any(binToInt(string([]rune(binary)[i:(i+8)]))))))
		i = (i + 8)
	}
	return join(canonParts, ".") + "/" + parts[1]
}

func main() {
	tests := []string{
		"87.70.141.1/22",
		"36.18.154.103/12",
		"62.62.197.11/29",
		"67.137.119.181/4",
		"161.214.74.21/24",
		"184.232.176.184/18",
	}
	for _, t := range tests {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(padRight(t, 18)+" -> "+canonicalize(t))), "\n"))
	}
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
