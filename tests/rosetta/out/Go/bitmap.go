//go:build ignore

// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"mochi/runtime/data"
	"reflect"
	"strings"
)

type Bitmap struct {
	Cols int       `json:"cols"`
	Rows int       `json:"rows"`
	Px   [][]Pixel `json:"px"`
}

type Pixel struct {
	R int `json:"R"`
	G int `json:"G"`
	B int `json:"B"`
}

type v map[string]any

// line 13
func pixelFromRgb(c int) Pixel {
	r := ((int((float64(c) / float64(65536)))) % 256)
	g := ((int((float64(c) / float64(256)))) % 256)
	b := (c % 256)
	return Pixel{R: r, G: g, B: b}
}

// line 20
func rgbFromPixel(p Pixel) int {
	return (((p.R * 65536) + (p.G * 256)) + p.B)
}

// line 31
func NewBitmap(x int, y int) Bitmap {
	var dataVar [][]Pixel = [][]Pixel{}
	row := 0
	for row < y {
		var r []Pixel = []Pixel{}
		col := 0
		for col < x {
			r = append(r, Pixel{R: 0, G: 0, B: 0})
			col = (col + 1)
		}
		dataVar = append(dataVar, r)
		row = (row + 1)
	}
	return Bitmap{Cols: x, Rows: y, Px: dataVar}
}

// line 47
func Extent(b Bitmap) map[string]int {
	return map[string]int{"cols": b.Cols, "rows": b.Rows}
}

// line 51
func Fill(b *Bitmap, p Pixel) {
	y := 0
	for y < b.Rows {
		x := 0
		for x < b.Cols {
			px := b.Px
			row := px[y]
			row[x] = p
			px[y] = row
			b.Px = px
			x = (x + 1)
		}
		y = (y + 1)
	}
}

// line 67
func FillRgb(b Bitmap, c int) {
	Fill(&b, &pixelFromRgb(c))
}

// line 69
func SetPx(b *Bitmap, x int, y int, p Pixel) bool {
	if (((x < 0) || (x >= b.Cols)) || (y < 0)) || (y >= b.Rows) {
		return false
	}
	px := b.Px
	row := px[y]
	row[x] = p
	px[y] = row
	b.Px = px
	return true
}

// line 79
func SetPxRgb(b Bitmap, x int, y int, c int) bool {
	return SetPx(&b, x, y, &pixelFromRgb(c))
}

// line 83
func GetPx(b Bitmap, x int, y int) map[string]any {
	if (((x < 0) || (x >= b.Cols)) || (y < 0)) || (y >= b.Rows) {
		return map[string]bool{"ok": false}
	}
	row := b.Px[y]
	return map[string]any{"ok": true, "pixel": row[x]}
}

// line 91
func GetPxRgb(b Bitmap, x int, y int) map[string]any {
	r := GetPx(&b, x, y)
	_ = r
	if _exists(!r["ok"]) {
		return map[string]bool{"ok": false}
	}
	return map[string]any{"ok": true, "rgb": rgbFromPixel(&(r["pixel"]).(Pixel))}
}

// line 97
func ppmSize(b Bitmap) int {
	header := "P6\n# Creator: Rosetta Code http://rosettacode.org/\n" + fmt.Sprint(b.Cols) + " " + fmt.Sprint(b.Rows) + "\n255\n"
	return (len(header) + ((3 * b.Cols) * b.Rows))
}

// line 103
func pixelStr(p Pixel) string {
	return "{" + fmt.Sprint(p.R) + " " + fmt.Sprint(p.G) + " " + fmt.Sprint(p.B) + "}"
}

// line 107
func main() {
	bm := NewBitmap(300, 240)
	FillRgb(&bm, 16711680)
	SetPxRgb(&bm, 10, 20, 255)
	SetPxRgb(&bm, 20, 30, 0)
	SetPxRgb(&bm, 30, 40, 1056816)
	c1 := GetPx(&bm, 0, 0)
	_ = c1
	c2 := GetPx(&bm, 10, 20)
	_ = c2
	c3 := GetPx(&bm, 30, 40)
	_ = c3
	fmt.Println("Image size: " + fmt.Sprint(bm.Cols) + " Ã— " + fmt.Sprint(bm.Rows))
	fmt.Println(fmt.Sprint(ppmSize(&bm)) + " bytes when encoded as PPM.")
	if _exists(c1["ok"]) {
		fmt.Println("Pixel at (0,0) is " + pixelStr(&(c1["pixel"]).(Pixel)))
	}
	if _exists(c2["ok"]) {
		fmt.Println("Pixel at (10,20) is " + pixelStr(&(c2["pixel"]).(Pixel)))
	}
	if _exists(c3["ok"]) {
		p := c3["pixel"]
		_ = p
		r16 := ((_getField(p, "R")).(float64) * float64(257))
		g16 := ((_getField(p, "G")).(float64) * float64(257))
		b16 := ((_getField(p, "B")).(float64) * float64(257))
		fmt.Println("Pixel at (30,40) has R=" + fmt.Sprint(r16) + ", G=" + fmt.Sprint(g16) + ", B=" + fmt.Sprint(b16))
	}
}

func main() {
	main()
}

func _convertMapAny(m map[any]any) map[string]any {
	out := make(map[string]any, len(m))
	for k, v := range m {
		key := fmt.Sprint(k)
		if sub, ok := v.(map[any]any); ok {
			out[key] = _convertMapAny(sub)
		} else {
			out[key] = v
		}
	}
	return out
}

func _exists(v any) bool {
	if g, ok := v.(*data.Group); ok {
		return len(g.Items) > 0
	}
	switch s := v.(type) {
	case []any:
		return len(s) > 0
	case []int:
		return len(s) > 0
	case []float64:
		return len(s) > 0
	case []string:
		return len(s) > 0
	case []bool:
		return len(s) > 0
	case []map[string]any:
		return len(s) > 0
	case map[string]any:
		return len(s) > 0
	case map[string]int:
		return len(s) > 0
	case string:
		return len([]rune(s)) > 0
	}
	rv := reflect.ValueOf(v)
	switch rv.Kind() {
	case reflect.Slice, reflect.Array:
		return rv.Len() > 0
	case reflect.Map:
		return !rv.IsNil() && rv.Len() > 0
	case reflect.Pointer:
		return !rv.IsNil()
	case reflect.Struct:
		return !rv.IsZero()
	}
	return false
}

func _getField(v any, name string) any {
	switch m := v.(type) {
	case map[string]any:
		return m[name]
	case map[string]string:
		if s, ok := m[name]; ok {
			return s
		}
	case map[any]any:
		return _convertMapAny(m)[name]
	default:
		rv := reflect.ValueOf(m)
		if rv.Kind() == reflect.Struct {
			rt := rv.Type()
			for i := 0; i < rv.NumField(); i++ {
				fn := rt.Field(i)
				field := fn.Name
				if tag := fn.Tag.Get("json"); tag != "" {
					if c := strings.Index(tag, ","); c >= 0 {
						tag = tag[:c]
					}
					if tag != "-" {
						field = tag
					}
				}
				if field == name {
					return rv.Field(i).Interface()
				}
			}
		}
	}
	return nil
}
