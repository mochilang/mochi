//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"mochi/runtime/data"
	"reflect"
	"strings"
)

type v map[string]any

// line 5
func Node(dataVar int) map[string]any {
	return map[string]any{
		"Data":    dataVar,
		"Balance": 0,
		"Link":    []any{nil, nil},
	}
}

// line 9
func getLink(n map[string]any, dir int) any {
	return (((n["Link"]).([]any))[dir]).(any)
}

// line 13
func setLink(n *map[string]any, dir int, v any) {
	links := (n["Link"]).([]any)
	links[dir] = v
	n["Link"] = any(any(any(links)))
}

// line 19
func opp(dir int) int {
	return (1 - dir)
}

// line 21
func single(root map[string]any, dir int) map[string]any {
	tmp := getLink(root, opp(dir))
	setLink(root, opp(dir), getLink((tmp).(map[string]any), dir))
	setLink((tmp).(map[string]any), dir, any(root))
	return (tmp).(map[string]any)
}

// line 28
func double(root map[string]any, dir int) map[string]any {
	tmp := getLink((getLink(root, opp(dir))).(map[string]any), dir)
	setLink((getLink(root, opp(dir))).(map[string]any), dir, getLink((tmp).(map[string]any), opp(dir)))
	setLink((tmp).(map[string]any), opp(dir), getLink(root, opp(dir)))
	setLink(root, opp(dir), tmp)
	tmp = getLink(root, opp(dir))
	setLink(root, opp(dir), getLink((tmp).(map[string]any), dir))
	setLink((tmp).(map[string]any), dir, any(root))
	return (tmp).(map[string]any)
}

// line 40
func adjustBalance(root *map[string]any, dir int, bal int) {
	n := (getLink(root, dir)).(map[string]any)
	nn := (getLink(n, opp(dir))).(map[string]any)
	if _equal(nn["Balance"], 0) {
		root["Balance"] = any(any(any(0)))
		n["Balance"] = any(any(any(0)))
	} else if _equal(nn["Balance"], bal) {
		root["Balance"] = any(any(any(-bal)))
		n["Balance"] = any(any(any(0)))
	} else {
		root["Balance"] = any(any(any(0)))
		n["Balance"] = any(any(any(bal)))
	}
	nn["Balance"] = any(any(any(0)))
}

// line 56
func insertBalance(root *map[string]any, dir int) map[string]any {
	n := (getLink(root, dir)).(map[string]any)
	bal := ((2 * dir) - 1)
	if _equal(n["Balance"], bal) {
		root["Balance"] = any(any(any(0)))
		n["Balance"] = any(any(any(0)))
		return single(root, opp(dir))
	}
	adjustBalance(root, dir, bal)
	return double(root, opp(dir))
}

// line 68
func insertR(root any, dataVar int) map[string]any {
	if _equal(root, nil) {
		return map[string]any{"node": Node(dataVar), "done": false}
	}
	node := (root).(map[string]any)
	dir := 0
	if ((node["Data"]).(int)) < dataVar {
		dir = 1
	}
	r := insertR(getLink(node, dir), dataVar)
	setLink(node, dir, r["node"])
	if _exists(r["done"]) {
		return map[string]any{"node": node, "done": true}
	}
	node["Balance"] = any(any(any((((node["Balance"]).(int)) + ((2 * dir) - 1)))))
	if _equal(node["Balance"], 0) {
		return map[string]any{"node": node, "done": true}
	}
	if _equal(node["Balance"], 1) || _equal(node["Balance"], (-1)) {
		return map[string]any{"node": node, "done": false}
	}
	return map[string]any{"node": insertBalance(node, dir), "done": true}
}

// line 86
func Insert(tree any, dataVar int) any {
	r := insertR(tree, dataVar)
	return (r["node"]).(any)
}

// line 91
func removeBalance(root *map[string]any, dir int) map[string]any {
	n := (getLink(root, opp(dir))).(map[string]any)
	bal := ((2 * dir) - 1)
	if _equal(n["Balance"], (-bal)) {
		root["Balance"] = any(any(any(0)))
		n["Balance"] = any(any(any(0)))
		return map[string]any{"node": single(root, dir), "done": false}
	}
	if _equal(n["Balance"], bal) {
		adjustBalance(root, opp(dir), (-bal))
		return map[string]any{"node": double(root, dir), "done": false}
	}
	root["Balance"] = any(any(any(-bal)))
	n["Balance"] = any(any(any(bal)))
	return map[string]any{"node": single(root, dir), "done": true}
}

// line 108
func removeR(root any, dataVar int) map[string]any {
	if _equal(root, nil) {
		return map[string]any{"node": nil, "done": false}
	}
	node := (root).(map[string]any)
	if ((node["Data"]).(int)) == dataVar {
		if _equal(getLink(node, 0), nil) {
			return map[string]any{"node": getLink(node, 1), "done": false}
		}
		if _equal(getLink(node, 1), nil) {
			return map[string]any{"node": getLink(node, 0), "done": false}
		}
		heir := getLink(node, 0)
		for !_equal(getLink((heir).(map[string]any), 1), nil) {
			heir = getLink((heir).(map[string]any), 1)
		}
		node["Data"] = (heir).(map[string]any)["Data"]
		dataVar = ((heir).(map[string]any)["Data"]).(int)
	}
	dir := 0
	if ((node["Data"]).(int)) < dataVar {
		dir = 1
	}
	r := removeR(getLink(node, dir), dataVar)
	setLink(node, dir, r["node"])
	if _exists(r["done"]) {
		return map[string]any{"node": node, "done": true}
	}
	node["Balance"] = any(any(any(((((node["Balance"]).(int)) + 1) - (2 * dir)))))
	if _equal(node["Balance"], 1) || _equal(node["Balance"], (-1)) {
		return map[string]any{"node": node, "done": true}
	}
	if _equal(node["Balance"], 0) {
		return map[string]any{"node": node, "done": false}
	}
	return removeBalance(node, dir)
}

// line 132
func Remove(tree any, dataVar int) any {
	r := removeR(tree, dataVar)
	return (r["node"]).(any)
}

// line 137
func indentStr(n int) string {
	s := ""
	i := 0
	for i < n {
		s = s + " "
		i = (i + 1)
	}
	return s
}

// line 147
func dumpNode(node any, indent int, comma bool) {
	sp := indentStr(indent)
	if _equal(node, nil) {
		line := sp + "null"
		if comma {
			line = line + ","
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
	} else {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(sp+"{")), "\n"))
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(indentStr((indent+3))+"\"Data\": "+fmt.Sprint((node).(map[string]any)["Data"])+",")), "\n"))
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(indentStr((indent+3))+"\"Balance\": "+fmt.Sprint((node).(map[string]any)["Balance"])+",")), "\n"))
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(indentStr((indent+3))+"\"Link\": [")), "\n"))
		dumpNode(getLink((node).(map[string]any), 0), (indent + 6), true)
		dumpNode(getLink((node).(map[string]any), 1), (indent + 6), false)
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(indentStr((indent+3))+"]")), "\n"))
		end := sp + "}"
		if comma {
			end = end + ","
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(end)), "\n"))
	}
}

// line 167
func dump(node any, indent int) {
	dumpNode(node, indent, false)
}

// line 171
func main() {
	tree := nil
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Empty tree:")), "\n"))
	dump(tree, 0)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Insert test:")), "\n"))
	tree = Insert(tree, 3)
	tree = Insert(tree, 1)
	tree = Insert(tree, 4)
	tree = Insert(tree, 1)
	tree = Insert(tree, 5)
	dump(tree, 0)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Remove test:")), "\n"))
	tree = Remove(tree, 3)
	tree = Remove(tree, 1)
	t := (tree).(map[string]any)
	t["Balance"] = any(any(any(0)))
	tree = any(any(any(t)))
	dump(tree, 0)
}

func main() {
	main()
}

func _convertMapAny(m map[any]any) map[string]any {
	out := make(map[string]any, len(m))
	for k, v := range m {
		key := fmt.Sprint(k)
		if sub, ok := v.(map[any]any); ok {
			out[key] = _convertMapAny(sub)
		} else {
			out[key] = v
		}
	}
	return out
}

func _copyToMap(dst map[string]any, src any) {
	switch m := src.(type) {
	case map[string]any:
		for k, v := range m {
			dst[k] = v
		}
	case map[string]string:
		for k, v := range m {
			dst[k] = v
		}
	case map[any]any:
		for k, v := range _convertMapAny(m) {
			dst[k] = v
		}
	default:
		rv := reflect.ValueOf(m)
		if rv.Kind() == reflect.Struct {
			rt := rv.Type()
			for i := 0; i < rv.NumField(); i++ {
				name := rt.Field(i).Name
				if tag := rt.Field(i).Tag.Get("json"); tag != "" {
					if c := strings.Index(tag, ","); c >= 0 {
						tag = tag[:c]
					}
					if tag != "-" {
						name = tag
					}
				}
				dst[name] = rv.Field(i).Interface()
			}
		}
	}
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Struct && bv.Kind() == reflect.Map {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Struct {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}

func _exists(v any) bool {
	if g, ok := v.(*data.Group); ok {
		return len(g.Items) > 0
	}
	switch s := v.(type) {
	case []any:
		return len(s) > 0
	case []int:
		return len(s) > 0
	case []float64:
		return len(s) > 0
	case []string:
		return len(s) > 0
	case []bool:
		return len(s) > 0
	case bool:
		return s
	case []map[string]any:
		return len(s) > 0
	case map[string]any:
		return len(s) > 0
	case map[string]int:
		return len(s) > 0
	case string:
		return len([]rune(s)) > 0
	}
	rv := reflect.ValueOf(v)
	switch rv.Kind() {
	case reflect.Slice, reflect.Array:
		return rv.Len() > 0
	case reflect.Map:
		return !rv.IsNil() && rv.Len() > 0
	case reflect.Pointer:
		return !rv.IsNil()
	case reflect.Struct:
		return !rv.IsZero()
	}
	return false
}
