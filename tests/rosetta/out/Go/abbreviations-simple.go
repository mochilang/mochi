//go:build ignore

// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 3
func fields(s string) []string {
	var words []string = []string{}
	var cur string = ""
	var i int = 0
	for i < len([]rune(s)) {
		var ch string = string([]rune(s)[i:(i + 1)])
		if ((ch == " ") || (ch == "\n")) || (ch == "\t") {
			if len([]rune(cur)) > 0 {
				words = append(words, cur)
				cur = ""
			}
		} else {
			cur = cur + ch
		}
		i = (i + 1)
	}
	if len([]rune(cur)) > 0 {
		words = append(words, cur)
	}
	return words
}

// line 23
func padRight(s string, width int) string {
	var out string = s
	var i int = len([]rune(s))
	for i < width {
		out = out + " "
		i = (i + 1)
	}
	return out
}

// line 33
func join(xs []string, sep string) string {
	var res string = ""
	var i int = 0
	for i < len(xs) {
		if i > 0 {
			res = res + sep
		}
		res = res + xs[i]
		i = (i + 1)
	}
	return res
}

// line 44
func parseIntStr(str string) int {
	var i int = 0
	var neg bool = false
	if (len([]rune(str)) > 0) && (string([]rune(str)[0:1]) == "-") {
		neg = true
		i = 1
	}
	var n int = 0
	var digits map[string]int = map[string]int{
		"0": 0,
		"1": 1,
		"2": 2,
		"3": 3,
		"4": 4,
		"5": 5,
		"6": 6,
		"7": 7,
		"8": 8,
		"9": 9,
	}
	for i < len([]rune(str)) {
		n = ((n * 10) + digits[string([]rune(str)[i:(i+1)])])
		i = (i + 1)
	}
	if neg {
		n = -n
	}
	return n
}

// line 72
func isDigits(s string) bool {
	if len([]rune(s)) == 0 {
		return false
	}
	var i int = 0
	for i < len([]rune(s)) {
		var ch string = string([]rune(s)[i:(i + 1)])
		if (ch < "0") || (ch > "9") {
			return false
		}
		i = (i + 1)
	}
	return true
}

// line 83
func readTable(table string) map[string]any {
	var toks []string = fields(table)
	var cmds []string = []string{}
	var mins []int = []int{}
	var i int = 0
	for i < len(toks) {
		var cmd string = toks[i]
		var minlen int = len([]rune(cmd))
		i = (i + 1)
		if (i < len(toks)) && isDigits(toks[i]) {
			var num int = parseIntStr(toks[i])
			if (num >= 1) && (num < len([]rune(cmd))) {
				minlen = num
				i = (i + 1)
			}
		}
		cmds = append(cmds, cmd)
		mins = append(mins, minlen)
	}
	return map[string]any{"commands": cmds, "mins": mins}
}

// line 105
func validate(commands []string, mins []int, words []string) []string {
	var results []string = []string{}
	var wi int = 0
	for wi < len(words) {
		var w string = words[wi]
		var found bool = false
		var wlen int = len([]rune(w))
		var ci int = 0
		for ci < len(commands) {
			var cmd string = commands[ci]
			if ((mins[ci] != 0) && (wlen >= mins[ci])) && (wlen <= len([]rune(cmd))) {
				var c string = strings.ToUpper(cmd)
				var ww string = strings.ToUpper(w)
				if string([]rune(c)[0:wlen]) == ww {
					results = append(results, c)
					found = true
					break
				}
			}
			ci = (ci + 1)
		}
		if !(found) {
			results = append(results, "*error*")
		}
		wi = (wi + 1)
	}
	return results
}

// line 132
func mainFn() {
	var table string = "" + "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 " + "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate " + "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 " + "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load " + "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 " + "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 " + "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left " + "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 "
	var sentence string = "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin"
	var tbl map[string]any = readTable(table)
	var commands []string = (tbl["commands"]).([]string)
	var mins []int = (tbl["mins"]).([]int)
	var words []string = fields(sentence)
	var results []string = validate(commands, mins, words)
	var out1 string = "user words:"
	var k int = 0
	for k < len(words) {
		out1 = out1 + " "
		if k < (len(words) - 1) {
			out1 = out1 + padRight(words[k], len([]rune(results[k])))
		} else {
			out1 = out1 + words[k]
		}
		k = (k + 1)
	}
	fmt.Println(any(out1))
	fmt.Println(any("full words: " + join(results, " ")))
}

func main() {
	mainFn()
}
