//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 3
func fields(s string) []string {
	var words []string = []string{}
	cur := ""
	i := 0
	for i < len(any(s)) {
		ch := string([]rune(s)[i:(i + 1)])
		if ((ch == " ") || (ch == "\n")) || (ch == "\t") {
			if len(any(cur)) > 0 {
				words = append(words, cur)
				cur = ""
			}
		} else {
			cur = cur + ch
		}
		i = (i + 1)
	}
	if len(any(cur)) > 0 {
		words = append(words, cur)
	}
	return words
}

// line 23
func padRight(s string, width int) string {
	out := s
	i := len(any(s))
	for i < width {
		out = out + " "
		i = (i + 1)
	}
	return out
}

// line 33
func join(xs []string, sep string) string {
	res := ""
	i := 0
	for i < len(any(xs)) {
		if i > 0 {
			res = res + sep
		}
		res = res + xs[i]
		i = (i + 1)
	}
	return res
}

// line 44
func parseIntStr(str string) int {
	i := 0
	neg := false
	if (len(any(str)) > 0) && (string([]rune(str)[0:1]) == "-") {
		neg = true
		i = 1
	}
	n := 0
	digits := map[string]int{
		"0": 0,
		"1": 1,
		"2": 2,
		"3": 3,
		"4": 4,
		"5": 5,
		"6": 6,
		"7": 7,
		"8": 8,
		"9": 9,
	}
	for i < len(any(str)) {
		n = ((n * 10) + digits[string([]rune(str)[i:(i+1)])])
		i = (i + 1)
	}
	if neg {
		n = -n
	}
	return n
}

// line 72
func isDigits(s string) bool {
	if len(any(s)) == 0 {
		return false
	}
	i := 0
	for i < len(any(s)) {
		ch := string([]rune(s)[i:(i + 1)])
		if (ch < "0") || (ch > "9") {
			return false
		}
		i = (i + 1)
	}
	return true
}

// line 83
func readTable(table string) map[string]any {
	toks := fields(table)
	var cmds []string = []string{}
	var mins []int = []int{}
	i := 0
	for i < len(any(toks)) {
		cmd := toks[i]
		minlen := len(any(cmd))
		i = (i + 1)
		if (i < len(any(toks))) && isDigits(toks[i]) {
			num := parseIntStr(toks[i])
			if (num >= 1) && (num < len(any(cmd))) {
				minlen = num
				i = (i + 1)
			}
		}
		cmds = append(cmds, cmd)
		mins = append(mins, minlen)
	}
	return map[string]any{"commands": cmds, "mins": mins}
}

// line 105
func validate(commands []string, mins []int, words []string) []string {
	var results []string = []string{}
	wi := 0
	for wi < len(any(words)) {
		w := words[wi]
		found := false
		wlen := len(any(w))
		ci := 0
		for ci < len(any(commands)) {
			cmd := commands[ci]
			if ((mins[ci] != 0) && (wlen >= mins[ci])) && (wlen <= len(any(cmd))) {
				c := strings.ToUpper(cmd)
				ww := strings.ToUpper(w)
				if string([]rune(c)[0:wlen]) == ww {
					results = append(results, c)
					found = true
					break
				}
			}
			ci = (ci + 1)
		}
		if !(found) {
			results = append(results, "*error*")
		}
		wi = (wi + 1)
	}
	return results
}

// line 132
func mainFn() {
	table := "" + "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 " + "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate " + "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 " + "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load " + "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 " + "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 " + "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left " + "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 "
	sentence := "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin"
	tbl := readTable(table)
	commands := (tbl["commands"]).([]string)
	mins := (tbl["mins"]).([]int)
	words := fields(sentence)
	results := validate(commands, mins, words)
	out1 := "user words:"
	k := 0
	for k < len(any(words)) {
		out1 = out1 + " "
		if k < (len(any(words)) - 1) {
			out1 = out1 + padRight(words[k], len(any(results[k])))
		} else {
			out1 = out1 + words[k]
		}
		k = (k + 1)
	}
	fmt.Println(any(out1))
	fmt.Println(any("full words: " + join(results, " ")))
}

func main() {
	mainFn()
}
