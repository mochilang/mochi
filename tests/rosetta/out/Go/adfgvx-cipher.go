//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
	"time"
)

type v map[string]any

// line 4
func shuffleStr(s string) string {
	var arr []string = []string{}
	i := 0
	for i < len(any(s)) {
		arr = append(append([]string{}, arr...), []string{string([]rune(s)[i])}...)
		i = (i + 1)
	}
	j := (len(any(arr)) - 1)
	for j > 0 {
		k := (int64(time.Now().UnixNano()) % int64((j + 1)))
		tmp := arr[j]
		arr[j] = arr[k]
		arr[k] = tmp
		j = (j - 1)
	}
	out := ""
	i = 0
	for i < len(any(arr)) {
		out = out + arr[i]
		i = (i + 1)
	}
	return out
}

// line 28
func createPolybius() []string {
	shuffled := shuffleStr(alphabet)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("6 x 6 Polybius square:\n")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("  | A D F G V X")), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("---------------")), "\n"))
	var p []string = []string{}
	i := 0
	for i < 6 {
		row := string([]rune(shuffled)[(i * 6):((i + 1) * 6)])
		p = append(append([]string{}, p...), []string{row}...)
		line := string([]rune(adfgvx)[i]) + " | "
		j := 0
		for j < 6 {
			line = line + string([]rune(row)[j]) + " "
			j = (j + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
		i = (i + 1)
	}
	return p
}

// line 50
func createKey(n int) string {
	if (n < 7) || (n > 12) {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Key should be within 7 and 12 letters long.")), "\n"))
	}
	pool := "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	key := ""
	i := 0
	for i < n {
		idx := (int64(time.Now().UnixNano()) % int64(len(any(pool))))
		key = key + string([]rune(pool)[idx])
		pool = string([]rune(pool)[0:idx]) + string([]rune(pool)[(int64(idx)+int64(1)):len(any(pool))])
		i = (i + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nThe key is "+key)), "\n"))
	return key
}

// line 67
func orderKey(key string) []int {
	pairs := []any{}
	i := 0
	for i < len(any(key)) {
		pairs = append(append([]any{}, pairs...), []any{any([]any{string([]rune(key)[i]), i})}...)
		i = (i + 1)
	}
	n := len(any(pairs))
	m := 0
	for m < n {
		j := 0
		for j < (n - 1) {
			if ((pairs[j]).([]any)[0]).(float64) > float64((pairs[(j + 1)]).([]any)[0]) {
				tmp := pairs[j]
				pairs[j] = pairs[(j + 1)]
				pairs[(j + 1)] = tmp
			}
			j = (j + 1)
		}
		m = (m + 1)
	}
	res := []any{}
	i = 0
	for i < n {
		res = append(append([]any{}, res...), []any{any(((pairs[i]).([]any)[1]).(int))}...)
		i = (i + 1)
	}
	return _convSlice[any, int](res)
}

// line 98
func encrypt(polybius []string, key string, plainText string) string {
	temp := ""
	i := 0
	for i < len(any(plainText)) {
		r := 0
		for r < 6 {
			c := 0
			for c < 6 {
				if string([]rune(polybius[r])[c]) == string([]rune(plainText)[i]) {
					temp = temp + string([]rune(adfgvx)[r]) + string([]rune(adfgvx)[c])
				}
				c = (c + 1)
			}
			r = (r + 1)
		}
		i = (i + 1)
	}
	colLen := (float64(len(any(temp))) / float64(len(any(key))))
	if (len(any(temp)) % len(any(key))) > 0 {
		colLen = (colLen + float64(1))
	}
	var table [][]string = [][]string{}
	rIdx := 0
	for float64(rIdx) < colLen {
		var row []string = []string{}
		j := 0
		for j < len(any(key)) {
			row = append(append([]string{}, row...), []string{""}...)
			j = (j + 1)
		}
		table = append(append([][]string{}, table...), [][]string{row}...)
		rIdx = (rIdx + 1)
	}
	idx := 0
	for idx < len(any(temp)) {
		row := (float64(idx) / float64(len(any(key))))
		col := (idx % len(any(key)))
		table[row][col] = string([]rune(temp)[idx:(idx + 1)])
		idx = (idx + 1)
	}
	order := orderKey(key)
	var cols []string = []string{}
	ci := 0
	for ci < len(any(key)) {
		colStr := ""
		ri := 0
		for float64(ri) < colLen {
			colStr = colStr + table[ri][order[ci]]
			ri = (ri + 1)
		}
		cols = append(append([]string{}, cols...), []string{colStr}...)
		ci = (ci + 1)
	}
	result := ""
	ci = 0
	for ci < len(any(cols)) {
		result = result + cols[ci]
		if ci < (len(any(cols)) - 1) {
			result = result + " "
		}
		ci = (ci + 1)
	}
	return result
}

// line 163
func indexOf(s string, ch string) int {
	i := 0
	for i < len(any(s)) {
		if string([]rune(s)[i]) == ch {
			return i
		}
		i = (i + 1)
	}
	return -1
}

// line 174
func decrypt(polybius []string, key string, cipherText string) string {
	var colStrs []string = []string{}
	start := 0
	i := 0
	for i <= len(any(cipherText)) {
		if (i == len(any(cipherText))) || (string([]rune(cipherText)[i]) == " ") {
			colStrs = append(append([]string{}, colStrs...), []string{string([]rune(cipherText)[start:i])}...)
			start = (i + 1)
		}
		i = (i + 1)
	}
	maxColLen := 0
	i = 0
	for i < len(any(colStrs)) {
		if len(any(colStrs[i])) > maxColLen {
			maxColLen = len(any(colStrs[i]))
		}
		i = (i + 1)
	}
	var cols [][]string = [][]string{}
	i = 0
	for i < len(any(colStrs)) {
		s := colStrs[i]
		var ls []string = []string{}
		j := 0
		for j < len(any(s)) {
			ls = append(append([]string{}, ls...), []string{string([]rune(s)[j])}...)
			j = (j + 1)
		}
		if len(any(s)) < maxColLen {
			var pad []string = []string{}
			k := 0
			for k < maxColLen {
				if k < len(any(ls)) {
					pad = append(append([]string{}, pad...), []string{ls[k]}...)
				} else {
					pad = append(append([]string{}, pad...), []string{""}...)
				}
				k = (k + 1)
			}
			cols = append(append([][]string{}, cols...), [][]string{pad}...)
		} else {
			cols = append(append([][]string{}, cols...), [][]string{ls}...)
		}
		i = (i + 1)
	}
	var table [][]string = [][]string{}
	r := 0
	for r < maxColLen {
		var row []string = []string{}
		c := 0
		for c < len(any(key)) {
			row = append(append([]string{}, row...), []string{""}...)
			c = (c + 1)
		}
		table = append(append([][]string{}, table...), [][]string{row}...)
		r = (r + 1)
	}
	order := orderKey(key)
	r = 0
	for r < maxColLen {
		c := 0
		for c < len(any(key)) {
			table[r][order[c]] = cols[c][r]
			c = (c + 1)
		}
		r = (r + 1)
	}
	temp := ""
	r = 0
	for r < len(any(table)) {
		j := 0
		for j < len(any(table[r])) {
			temp = temp + table[r][j]
			j = (j + 1)
		}
		r = (r + 1)
	}
	plainText := ""
	idx := 0
	for idx < len(any(temp)) {
		rIdx := indexOf(adfgvx, string([]rune(temp)[idx:(idx+1)]))
		cIdx := indexOf(adfgvx, string([]rune(temp)[(idx+1):(idx+2)]))
		plainText = plainText + string([]rune(polybius[rIdx])[cIdx])
		idx = (idx + 2)
	}
	return plainText
}

// line 263
func main() {
	plainText := "ATTACKAT1200AM"
	polybius := createPolybius()
	key := createKey(9)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nPlaintext : "+plainText)), "\n"))
	cipherText := encrypt(polybius, key, plainText)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nEncrypted : "+cipherText)), "\n"))
	plainText2 := decrypt(polybius, key, cipherText)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("\nDecrypted : "+plainText2)), "\n"))
}

var adfgvx string
var alphabet string

func main() {
	adfgvx = "ADFGVX"
	alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	main()
}

func _convSlice[T any, U any](s []T) []U {
	out := make([]U, len(s))
	for i, v := range s {
		out[i] = any(v).(U)
	}
	return out
}
