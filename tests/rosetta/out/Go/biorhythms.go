//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"reflect"
	"strings"
)

type v map[string]any

// line 7
func sinApprox(x float64) float64 {
	term := x
	sum := x
	n := 1
	for n <= 8 {
		denom := float64(((2 * n) * ((2 * n) + 1)))
		term = (((-term * x) * x) / denom)
		sum = (sum + term)
		n = (n + 1)
	}
	return sum
}

// line 20
func floor(x float64) float64 {
	i := int(x)
	if (float64(i)) > x {
		i = (i - 1)
	}
	return float64(i)
}

// line 26
func absFloat(x float64) float64 {
	if x < 0.0 {
		return -x
	}
	return x
}

// line 27
func absInt(n int) int {
	if n < 0 {
		return -n
	}
	return n
}

// line 29
func parseIntStr(str string) int {
	i := 0
	neg := false
	if (len(any(str)) > 0) && (string([]rune(str)[0:1]) == "-") {
		neg = true
		i = 1
	}
	n := 0
	digits := map[string]int{
		"0": 0,
		"1": 1,
		"2": 2,
		"3": 3,
		"4": 4,
		"5": 5,
		"6": 6,
		"7": 7,
		"8": 8,
		"9": 9,
	}
	for i < len(any(str)) {
		n = ((n * 10) + digits[string([]rune(str)[i:(i+1)])])
		i = (i + 1)
	}
	if neg {
		n = -n
	}
	return n
}

// line 57
func parseDate(s string) []int {
	y := parseIntStr(string([]rune(s)[0:4]))
	m := parseIntStr(string([]rune(s)[5:7]))
	d := parseIntStr(string([]rune(s)[8:10]))
	return []int{y, m, d}
}

// line 64
func leap(y int) bool {
	if (y % 400) == 0 {
		return true
	}
	if (y % 100) == 0 {
		return false
	}
	return ((y % 4) == 0)
}

// line 70
func daysInMonth(y int, m int) int {
	feb := func() int {
		if leap(y) {
			return 29
		} else {
			return 28
		}
	}()
	lengths := []int{
		31,
		feb,
		31,
		30,
		31,
		30,
		31,
		31,
		30,
		31,
		30,
		31,
	}
	return lengths[(m - 1)]
}

// line 76
func addDays(y int, m int, d int, n int) []int {
	yy := y
	mm := m
	dd := d
	if n >= 0 {
		i := 0
		for i < n {
			dd = (dd + 1)
			if dd > daysInMonth(yy, mm) {
				dd = 1
				mm = (mm + 1)
				if mm > 12 {
					mm = 1
					yy = (yy + 1)
				}
			}
			i = (i + 1)
		}
	} else {
		i := 0
		for i > n {
			dd = (dd - 1)
			if dd < 1 {
				mm = (mm - 1)
				if mm < 1 {
					mm = 12
					yy = (yy - 1)
				}
				dd = daysInMonth(yy, mm)
			}
			i = (i - 1)
		}
	}
	return []int{yy, mm, dd}
}

// line 112
func pad2(n int) string {
	if n < 10 {
		return "0" + fmt.Sprint(any(n))
	}
	return fmt.Sprint(any(n))
}

// line 114
func dateString(y int, m int, d int) string {
	return fmt.Sprint(any(y)) + "-" + pad2(m) + "-" + pad2(d)
}

// line 118
func day(y int, m int, d int) int {
	part1 := (367 * y)
	part2 := int((float64((7 * (int((float64(y) + (float64((m + 9)) / float64(12))))))) / float64(4)))
	part3 := int((float64((275 * m)) / float64(9)))
	return ((((part1 - part2) + part3) + d) - 730530)
}

// line 125
func biorhythms(birth string, target string) {
	bparts := parseDate(birth)
	by := bparts[0]
	bm := bparts[1]
	bd := bparts[2]
	tparts := parseDate(target)
	ty := tparts[0]
	tm := tparts[1]
	td := tparts[2]
	diff := absInt((day(ty, tm, td) - day(by, bm, bd)))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Born "+birth+", Target "+target)), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Day "+fmt.Sprint(any(diff)))), "\n"))
	cycles := []string{"Physical day ", "Emotional day", "Mental day   "}
	lengths := []int{23, 28, 33}
	quadrants := [][]string{
		[]string{"up and rising", "peak"},
		[]string{"up but falling", "transition"},
		[]string{"down and falling", "valley"},
		[]string{"down but rising", "transition"},
	}
	i := 0
	for i < 3 {
		length := lengths[i]
		cycle := cycles[i]
		position := (diff % length)
		quadrant := (float64((position * 4)) / float64(length))
		percent := sinApprox((((2.0 * PI) * (float64(position))) / (float64(length))))
		percent = (floor((percent * 1000.0)) / 10.0)
		description := ""
		if percent > 95.0 {
			description = " peak"
		} else if percent < (-95.0) {
			description = " valley"
		} else if absFloat(percent) < 5.0 {
			description = " critical transition"
		} else {
			daysToAdd := ((((quadrant + float64(1)) * float64(length)) / float64(4)) - float64(position))
			res := addDays(ty, tm, td, int(daysToAdd))
			ny := res[0]
			nm := res[1]
			nd := res[2]
			transition := dateString(ny, nm, nd)
			trend := quadrants[quadrant][0]
			next := quadrants[quadrant][1]
			pct := fmt.Sprint(any(percent))
			if !(_contains(pct, ".")) {
				pct = pct + ".0"
			}
			description = " " + pct + "% (" + trend + ", next " + next + " " + transition + ")"
		}
		posStr := fmt.Sprint(any(position))
		if position < 10 {
			posStr = " " + posStr
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(cycle+posStr+" : "+description)), "\n"))
		i = (i + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
}

// line 179
func main() {
	pairs := [][]string{[]string{"1943-03-09", "1972-07-11"}, []string{"1809-01-12", "1863-11-19"}, []string{"1809-02-12", "1863-11-19"}}
	idx := 0
	for idx < len(any(pairs)) {
		p := pairs[idx]
		biorhythms(p[0], p[1])
		idx = (idx + 1)
	}
}

var PI float64

func main() {
	PI = 3.141592653589793
	var TWO_PI float64 = 6.283185307179586
	_ = TWO_PI
	main()
}

func _contains(c any, v any) bool {
	switch s := c.(type) {
	case string:
		return strings.Contains(s, fmt.Sprint(v))
	case map[string]any:
		_, ok := s[fmt.Sprint(v)]
		return ok
	}
	rv := reflect.ValueOf(c)
	if rv.Kind() == reflect.Slice || rv.Kind() == reflect.Array {
		for i := 0; i < rv.Len(); i++ {
			if _equal(rv.Index(i).Interface(), v) {
				return true
			}
		}
		return false
	}
	return false
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Struct && bv.Kind() == reflect.Map {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Struct {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}
