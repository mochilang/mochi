//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"reflect"
	"strings"
)

type v map[string]any

// line 1
func bernoulli(n int) any {
	var a []any = []any{}
	m := 0
	for m <= n {
		a = append(a, any((any(1) / (any((m + 1))))))
		j := m
		for j >= 1 {
			a[(j - 1)] = any(any(any(((any(j)) * (a[(j-1)] - a[j])))))
			j = (j - 1)
		}
		m = (m + 1)
	}
	return a[0]
}

func main() {
	for i := 0; i < 61; i++ {
		b := bernoulli(i)
		if num(b) != 0 {
			numStr := fmt.Sprint(num(b))
			_ = numStr
			denStr := fmt.Sprint(denom(b))
			fmt.Println(strings.TrimSuffix(fmt.Sprintln("B("+fmt.Sprint(fmt.Sprint(any(i))(2, " "))+") ="+fmt.Sprint(_getField(numStr, "padStart")(45, " "))+"/"+denStr), "\n"))
		}
	}
}

func _convertMapAny(m map[any]any) map[string]any {
	out := make(map[string]any, len(m))
	for k, v := range m {
		key := fmt.Sprint(k)
		if sub, ok := v.(map[any]any); ok {
			out[key] = _convertMapAny(sub)
		} else {
			out[key] = v
		}
	}
	return out
}

func _getField(v any, name string) any {
	switch m := v.(type) {
	case map[string]any:
		return m[name]
	case map[string]string:
		if s, ok := m[name]; ok {
			return s
		}
	case map[any]any:
		return _convertMapAny(m)[name]
	default:
		rv := reflect.ValueOf(m)
		if rv.Kind() == reflect.Struct {
			rt := rv.Type()
			for i := 0; i < rv.NumField(); i++ {
				fn := rt.Field(i)
				field := fn.Name
				if tag := fn.Tag.Get("json"); tag != "" {
					if c := strings.Index(tag, ","); c >= 0 {
						tag = tag[:c]
					}
					if tag != "-" {
						field = tag
					}
				}
				if field == name {
					return rv.Field(i).Interface()
				}
			}
		}
	}
	return nil
}
