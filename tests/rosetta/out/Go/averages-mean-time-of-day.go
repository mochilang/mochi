//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func sinApprox(x float64) float64 {
	term := x
	sum := x
	n := 1
	for n <= 8 {
		denom := float64(((2 * n) * ((2 * n) + 1)))
		term = (((-term * x) * x) / denom)
		sum = (sum + term)
		n = (n + 1)
	}
	return sum
}

// line 17
func cosApprox(x float64) float64 {
	term := 1.0
	sum := 1.0
	n := 1
	for n <= 8 {
		denom := float64((((2 * n) - 1) * (2 * n)))
		term = (((-term * x) * x) / denom)
		sum = (sum + term)
		n = (n + 1)
	}
	return sum
}

// line 30
func atanApprox(x float64) float64 {
	if x > 1.0 {
		return ((PI / 2.0) - (x / ((x * x) + 0.28)))
	}
	if x < (-1.0) {
		return ((-PI / 2.0) - (x / ((x * x) + 0.28)))
	}
	return (x / (1.0 + ((0.28 * x) * x)))
}

// line 36
func atan2Approx(y float64, x float64) float64 {
	if x > 0.0 {
		return atanApprox((y / x))
	}
	if x < 0.0 {
		if y >= 0.0 {
			return (atanApprox((y / x)) + PI)
		}
		return (atanApprox((y / x)) - PI)
	}
	if y > 0.0 {
		return (PI / 2.0)
	}
	if y < 0.0 {
		return (-PI / 2.0)
	}
	return 0.0
}

// line 47
func digit(ch string) int {
	digits := "0123456789"
	i := 0
	for i < 10 {
		if string([]rune(digits)[i:(i+1)]) == ch {
			return i
		}
		i = (i + 1)
	}
	return 0
}

// line 57
func parseTwo(s string, idx int) int {
	return ((digit(string([]rune(s)[idx:(idx+1)])) * 10) + digit(string([]rune(s)[(idx+1):(idx+2)])))
}

// line 61
func parseSec(s string) float64 {
	h := parseTwo(s, 0)
	m := parseTwo(s, 3)
	sec := parseTwo(s, 6)
	return float64(((((h * 60) + m) * 60) + sec))
}

// line 68
func pad(n int) string {
	if n < 10 {
		return "0" + fmt.Sprint(any(n))
	}
	return fmt.Sprint(any(n))
}

// line 73
func meanTime(times []string) string {
	ssum := 0.0
	csum := 0.0
	i := 0
	for i < len(any(times)) {
		sec := parseSec(times[i])
		ang := (((sec * 2.0) * PI) / 86400.0)
		ssum = (ssum + sinApprox(ang))
		csum = (csum + cosApprox(ang))
		i = (i + 1)
	}
	theta := atan2Approx(ssum, csum)
	frac := (theta / (2.0 * PI))
	for frac < 0.0 {
		frac = (frac + 1.0)
	}
	total := (frac * 86400.0)
	si := int(total)
	h := int((float64(si) / float64(3600)))
	m := int((float64((si % 3600)) / float64(60)))
	s := (si % 60)
	return pad(h) + ":" + pad(m) + ":" + pad(s)
}

// line 95
func main() {
	inputs := []string{
		"23:00:17",
		"23:40:20",
		"00:12:45",
		"00:17:19",
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(meanTime(inputs))), "\n"))
}

var PI float64

func main() {
	PI = 3.141592653589793
	main()
}
