//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 3
func parseIntStr(str string) int {
	i := 0
	neg := false
	if (len(any(str)) > 0) && (string([]rune(str)[0:1]) == "-") {
		neg = true
		i = 1
	}
	n := 0
	digits := map[string]int{
		"0": 0,
		"1": 1,
		"2": 2,
		"3": 3,
		"4": 4,
		"5": 5,
		"6": 6,
		"7": 7,
		"8": 8,
		"9": 9,
	}
	for i < len(any(str)) {
		n = ((n * 10) + digits[string([]rune(str)[i:(i+1)])])
		i = (i + 1)
	}
	if neg {
		n = -n
	}
	return n
}

// line 31
func splitWs(s string) []string {
	var parts []string = []string{}
	cur := ""
	i := 0
	for i < len(any(s)) {
		ch := string([]rune(s)[i:(i + 1)])
		if (((ch == " ") || (ch == "\n")) || (ch == "\t")) || (ch == "\r") {
			if len(any(cur)) > 0 {
				parts = append(_toAnySlice(parts), any(cur))
				cur = ""
			}
		} else {
			cur = cur + ch
		}
		i = (i + 1)
	}
	if len(any(cur)) > 0 {
		parts = append(_toAnySlice(parts), any(cur))
	}
	return parts
}

// line 51
func parsePpm(dataVar string) map[string]any {
	toks := splitWs(dataVar)
	if len(any(toks)) < 4 {
		return map[string]any(map[string]bool{"err": true})
	}
	magic := toks[0]
	w := parseIntStr(toks[1])
	h := parseIntStr(toks[2])
	maxv := parseIntStr(toks[3])
	var px []int = []int{}
	i := 4
	for i < len(any(toks)) {
		px = append(_toAnySlice(px), any(parseIntStr(toks[i])))
		i = (i + 1)
	}
	return map[string]any{
		"magic": magic,
		"w":     w,
		"h":     h,
		"max":   maxv,
		"px":    px,
	}
}

func main() {
	ppmData := "P3\n2 2\n1\n0 1 1 0 1 0 0 1 1 1 0 0\n"
	img := parsePpm(ppmData)
	_ = img
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("width="+fmt.Sprint(img["w"])+" height="+fmt.Sprint(img["h"]))), "\n"))
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
