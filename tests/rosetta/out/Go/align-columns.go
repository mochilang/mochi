//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 4
func split(s string, sep string) []string {
	var parts []string = []string{}
	cur := ""
	i := 0
	for i < len(any(s)) {
		if ((len(any(sep)) > 0) && ((i + len(any(sep))) <= len(any(s)))) && (string([]rune(s)[i:(i+len(any(sep)))]) == sep) {
			parts = append(_toAnySlice(parts), any(cur))
			cur = ""
			i = (i + len(any(sep)))
		} else {
			cur = cur + string([]rune(s)[i:(i+1)])
			i = (i + 1)
		}
	}
	parts = append(_toAnySlice(parts), any(cur))
	return parts
}

// line 22
func rstripEmpty(words []string) []string {
	n := len(any(words))
	for (n > 0) && (words[(n-1)] == "") {
		n = (n - 1)
	}
	return words[0:n]
}

// line 30
func spaces(n int) string {
	out := ""
	i := 0
	for i < n {
		out = out + " "
		i = (i + 1)
	}
	return out
}

// line 40
func pad(word string, width int, align int) string {
	diff := (width - len(any(word)))
	if align == 0 {
		return word + spaces(diff)
	}
	if align == 2 {
		return spaces(diff) + word
	}
	left := int((float64(diff) / float64(2)))
	right := (diff - left)
	return spaces(left) + word + spaces(right)
}

// line 53
func newFormatter(text string) map[string]any {
	lines := split(text, "\n")
	var fmtLines [][]string = [][]string{}
	var width []int = []int{}
	i := 0
	for i < len(any(lines)) {
		if len(any(lines[i])) == 0 {
			i = (i + 1)
			continue
		}
		words := rstripEmpty(split(lines[i], "$"))
		fmtLines = append(_toAnySlice(fmtLines), any(words))
		j := 0
		for j < len(any(words)) {
			wlen := len(any(words[j]))
			if j == len(any(width)) {
				width = append(_toAnySlice(width), any(wlen))
			} else if wlen > width[j] {
				width[j] = wlen
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return map[string]any{"text": fmtLines, "width": width}
}

// line 80
func printFmt(f map[string]any, align int) {
	lines := (f["text"]).([][]string)
	width := (f["width"]).([]int)
	i := 0
	for i < len(any(lines)) {
		words := lines[i]
		line := ""
		j := 0
		for j < len(any(words)) {
			line = line + pad(words[j], width[j], align) + " "
			j = (j + 1)
		}
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(line)), "\n"))
		i = (i + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
}

var text string
var f map[string]any

func main() {
	text = "Given$a$text$file$of$many$lines,$where$fields$within$a$line\n" + "are$delineated$by$a$single$'dollar'$character,$write$a$program\n" + "that$aligns$each$column$of$fields$by$ensuring$that$words$in$each\n" + "column$are$separated$by$at$least$one$space.\n" + "Further,$allow$for$each$word$in$a$column$to$be$either$left\n" + "justified,$right$justified,$or$center$justified$within$its$column."
	f = newFormatter(text)
	printFmt(f, 0)
	printFmt(f, 1)
	printFmt(f, 2)
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
