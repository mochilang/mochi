//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"reflect"
	"strings"
)

type v map[string]any

// line 6
func indexOf(xs []int, value int) int {
	i := 0
	for i < len(any(xs)) {
		if xs[i] == value {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

// line 15
func contains(xs []int, value int) bool {
	return (indexOf(xs, value) != (0 - 1))
}

// line 19
func maxOf(a int, b int) int {
	if a > b {
		return a
	} else {
		return b
	}
}

// line 21
func intSqrt(n int) int {
	if n == 0 {
		return 0
	}
	x := n
	y := (float64((x + 1)) / float64(2))
	for y < float64(x) {
		x = int(int(int(y)))
		y = ((float64(x) + (float64(n) / float64(x))) / float64(2))
	}
	return x
}

// line 32
func sumProperDivisors(n int) int {
	if n < 2 {
		return 0
	}
	sqrt := intSqrt(n)
	sum := 1
	i := 2
	for i <= sqrt {
		if (n % i) == 0 {
			sum = int(int(int((float64((sum + i)) + (float64(n) / float64(i))))))
		}
		i = (i + 1)
	}
	if (sqrt * sqrt) == n {
		sum = (sum - sqrt)
	}
	return sum
}

// line 47
func classifySequence(k int) map[string]any {
	last := k
	var seq []int = []int{k}
	for {
		last = sumProperDivisors(last)
		seq = append(_toAnySlice(seq), any(last))
		n := len(any(seq))
		aliquot := ""
		if last == 0 {
			aliquot = "Terminating"
		} else if (n == 2) && (last == k) {
			aliquot = "Perfect"
		} else if (n == 3) && (last == k) {
			aliquot = "Amicable"
		} else if (n >= 4) && (last == k) {
			aliquot = "Sociable[" + fmt.Sprint(any((n - 1))) + "]"
		} else if last == seq[(n-2)] {
			aliquot = "Aspiring"
		} else if _contains(seq[1:maxOf(1, (n-2))], last) {
			idx := indexOf(seq, last)
			aliquot = "Cyclic[" + fmt.Sprint(any(((n - 1) - idx))) + "]"
		} else if (n == 16) || (last > THRESHOLD) {
			aliquot = "Non-Terminating"
		}
		if aliquot != "" {
			return map[string]any{"seq": seq, "aliquot": aliquot}
		}
	}
	return map[string]any{"seq": seq, "aliquot": ""}
}

// line 76
func padLeft(n int, w int) string {
	s := fmt.Sprint(any(n))
	for len(any(s)) < w {
		s = " " + s
	}
	return s
}

// line 82
func padRight(s string, w int) string {
	r := s
	for len(any(r)) < w {
		r = r + " "
	}
	return r
}

// line 88
func joinWithCommas(seq []int) string {
	s := "["
	i := 0
	for i < len(any(seq)) {
		s = s + fmt.Sprint(any(seq[i]))
		if i < (len(any(seq)) - 1) {
			s = s + ", "
		}
		i = (i + 1)
	}
	s = s + "]"
	return s
}

// line 100
func main() {
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n")), "\n"))
	k := 1
	for k <= 10 {
		res := classifySequence(k)
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(padLeft(k, 2)+": "+padRight((res["aliquot"]).(string), 15)+" "+joinWithCommas((res["seq"]).([]int)))), "\n"))
		k = (k + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
	s := []int{
		11,
		12,
		28,
		496,
		220,
		1184,
		12496,
		1264460,
		790,
		909,
		562,
		1064,
		1488,
	}
	i := 0
	for i < len(any(s)) {
		val := s[i]
		res := classifySequence(val)
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any(padLeft(val, 7)+": "+padRight((res["aliquot"]).(string), 15)+" "+joinWithCommas((res["seq"]).([]int)))), "\n"))
		i = (i + 1)
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("")), "\n"))
	big := 15355717786080
	r := classifySequence(big)
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("15355717786080"+": "+padRight((r["aliquot"]).(string), 15)+" "+joinWithCommas((r["seq"]).([]int)))), "\n"))
}

var THRESHOLD int

func main() {
	THRESHOLD = 140737488355328
	main()
}

func _contains(c any, v any) bool {
	switch s := c.(type) {
	case string:
		return strings.Contains(s, fmt.Sprint(v))
	case map[string]any:
		_, ok := s[fmt.Sprint(v)]
		return ok
	}
	rv := reflect.ValueOf(c)
	if rv.Kind() == reflect.Slice || rv.Kind() == reflect.Array {
		for i := 0; i < rv.Len(); i++ {
			if _equal(rv.Index(i).Interface(), v) {
				return true
			}
		}
		return false
	}
	return false
}

func _equal(a, b any) bool {
	av := reflect.ValueOf(a)
	bv := reflect.ValueOf(b)
	if av.Kind() == reflect.Struct && bv.Kind() == reflect.Map {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Struct {
		am := map[string]any{}
		_copyToMap(am, a)
		bm := map[string]any{}
		_copyToMap(bm, b)
		return _equal(am, bm)
	}
	if av.Kind() == reflect.Slice && bv.Kind() == reflect.Slice {
		if av.Len() != bv.Len() {
			return false
		}
		for i := 0; i < av.Len(); i++ {
			if !_equal(av.Index(i).Interface(), bv.Index(i).Interface()) {
				return false
			}
		}
		return true
	}
	if av.Kind() == reflect.Map && bv.Kind() == reflect.Map {
		if av.Len() != bv.Len() {
			return false
		}
		for _, k := range av.MapKeys() {
			bvVal := bv.MapIndex(k)
			if !bvVal.IsValid() {
				return false
			}
			if !_equal(av.MapIndex(k).Interface(), bvVal.Interface()) {
				return false
			}
		}
		return true
	}
	if (av.Kind() == reflect.Int || av.Kind() == reflect.Int64 || av.Kind() == reflect.Float64) &&
		(bv.Kind() == reflect.Int || bv.Kind() == reflect.Int64 || bv.Kind() == reflect.Float64) {
		return av.Convert(reflect.TypeOf(float64(0))).Float() == bv.Convert(reflect.TypeOf(float64(0))).Float()
	}
	return reflect.DeepEqual(a, b)
}

func _toAnySlice[T any](s []T) []any {
	out := make([]any, len(s))
	for i, v := range s {
		out[i] = v
	}
	return out
}
