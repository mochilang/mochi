//go:build ignore

// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z

package main

import (
	"fmt"
	"strings"
)

type v map[string]any

// line 1
func toUnsigned16(n int) int {
	u := n
	if u < 0 {
		u = (u + 65536)
	}
	return (u % 65536)
}

// line 7
func bin16(n int) string {
	u := toUnsigned16(n)
	bits := ""
	mask := 32768
	for i := 0; i < 16; i++ {
		if u >= mask {
			bits = bits + "1"
			u = (u - mask)
		} else {
			bits = bits + "0"
		}
		mask = int((float64(mask) / float64(2)))
	}
	return bits
}

// line 23
func bit_and(a int, b int) int {
	ua := toUnsigned16(a)
	ub := toUnsigned16(b)
	res := 0
	bit := 1
	for i := 0; i < 16; i++ {
		if ((ua % 2) == 1) && ((ub % 2) == 1) {
			res = (res + bit)
		}
		ua = int((float64(ua) / float64(2)))
		ub = int((float64(ub) / float64(2)))
		bit = (bit * 2)
	}
	return res
}

// line 37
func bit_or(a int, b int) int {
	ua := toUnsigned16(a)
	ub := toUnsigned16(b)
	res := 0
	bit := 1
	for i := 0; i < 16; i++ {
		if ((ua % 2) == 1) || ((ub % 2) == 1) {
			res = (res + bit)
		}
		ua = int((float64(ua) / float64(2)))
		ub = int((float64(ub) / float64(2)))
		bit = (bit * 2)
	}
	return res
}

// line 51
func bit_xor(a int, b int) int {
	ua := toUnsigned16(a)
	ub := toUnsigned16(b)
	res := 0
	bit := 1
	for i := 0; i < 16; i++ {
		abit := (ua % 2)
		bbit := (ub % 2)
		if ((abit == 1) && (bbit == 0)) || ((abit == 0) && (bbit == 1)) {
			res = (res + bit)
		}
		ua = int((float64(ua) / float64(2)))
		ub = int((float64(ub) / float64(2)))
		bit = (bit * 2)
	}
	return res
}

// line 69
func bit_not(a int) int {
	ua := toUnsigned16(a)
	return (65535 - ua)
}

// line 74
func shl(a int, b int) int {
	ua := toUnsigned16(a)
	i := 0
	for i < b {
		ua = ((ua * 2) % 65536)
		i = (i + 1)
	}
	return ua
}

// line 84
func shr(a int, b int) int {
	ua := toUnsigned16(a)
	i := 0
	for i < b {
		ua = int((float64(ua) / float64(2)))
		i = (i + 1)
	}
	return ua
}

// line 94
func las(a int, b int) int {
	return shl(a, b)
}

// line 98
func ras(a int, b int) int {
	val := a
	i := 0
	for i < b {
		if val >= 0 {
			val = int((float64(val) / float64(2)))
		} else {
			val = int((float64((val - 1)) / float64(2)))
		}
		i = (i + 1)
	}
	return toUnsigned16(val)
}

// line 112
func rol(a int, b int) int {
	ua := toUnsigned16(a)
	left := shl(ua, b)
	right := shr(ua, (16 - b))
	return toUnsigned16((left + right))
}

// line 119
func ror(a int, b int) int {
	ua := toUnsigned16(a)
	right := shr(ua, b)
	left := shl(ua, (16 - b))
	return toUnsigned16((left + right))
}

// line 126
func bitwise(a int, b int) {
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("a:   "+bin16(a))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("b:   "+bin16(b))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("and: "+bin16(bit_and(a, b)))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("or:  "+bin16(bit_or(a, b)))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("xor: "+bin16(bit_xor(a, b)))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("not: "+bin16(bit_not(a)))), "\n"))
	if b < 0 {
		fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("Right operand is negative, but all shifts require an unsigned right operand (shift distance).")), "\n"))
		return nil
	}
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("shl: "+bin16(shl(a, b)))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("shr: "+bin16(shr(a, b)))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("las: "+bin16(las(a, b)))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("ras: "+bin16(ras(a, b)))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("rol: "+bin16(rol(a, b)))), "\n"))
	fmt.Println(strings.TrimSuffix(fmt.Sprintln(any("ror: "+bin16(ror(a, b)))), "\n"))
}

func main() {
	bitwise(-460, 6)
}
