// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_list(comptime T: type, v: []const T, start: i32, end: i32, step: i32) []T {
    var s = start;
    var e = end;
    var st = step;
    const n: i32 = @as(i32, @intCast(v.len));
    if (s < 0) s += n;
    if (e < 0) e += n;
    if (st == 0) st = 1;
    if (s < 0) s = 0;
    if (e > n) e = n;
    if (st > 0 and e < s) e = s;
    if (st < 0 and e > s) e = s;
    var res = std.ArrayList(T).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = s;
    while ((st > 0 and i < e) or (st < 0 and i > e)) : (i += st) {
        res.append(v[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn randInt(s: i32, n: i32) []const i32 {
    const next = @mod((((s * 1664525) + 1013904223)), 2147483647); // i32
    return [_]i32{
    next,
    @mod(next, n),
};
}

fn padLeft(s: []const u8, w: i32) []const u8 {
    var res = ""; // []const u8
    var n = (w - (s).len); // i32
    while (n > 0) {
        res = _concat_string(res, " ");
        n = (n - 1);
    }
    return _concat_string(res, s);
}

fn makeSeq(s: i32, le: i32) []const i32 {
    const bases = "ACGT"; // []const u8
    var out = ""; // []const u8
    var i = 0; // i32
    while (i < le) {
        var r = randInt(s, 4); // []const i32
        s = r[0];
        const idx = @as(i32, r[1]); // i32
        out = _concat_string(out, substring(bases, idx, (idx + 1)));
        i = (i + 1);
    }
    return [_]i32{
    s,
    out,
};
}

fn mutate(s: i32, dna: []const u8, w: []const i32) []const i32 {
    const bases = "ACGT"; // []const u8
    const le = (dna).len; // i32
    var r = randInt(s, le); // []const i32
    s = r[0];
    const p = @as(i32, r[1]); // i32
    r = randInt(s, 300);
    s = r[0];
    const x = @as(i32, r[1]); // i32
    var arr = std.ArrayList(u8).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < le) {
        arr = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(arr) catch |err| handleError(err); _tmp0.append(substring(dna, i, (i + 1))) catch |err| handleError(err); break :blk0 _tmp0.items; };
        i = (i + 1);
    }
    if (x < w[0]) {
        r = randInt(s, 4);
        s = r[0];
        const idx = @as(i32, r[1]); // i32
        const b = substring(bases, idx, (idx + 1)); // []const u8
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("  Change @", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{p}) catch |err| handleError(err), 3)), " '"), arr[p]), "' to '"), b), "'")});
        arr.items[p] = b;
    } else     if (x < (w[0] + w[1])) {
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("  Delete @", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{p}) catch |err| handleError(err), 3)), " '"), arr[p]), "'")});
        var j = p; // i32
        while (j < ((arr).len - 1)) {
            arr.items[j] = arr[(j + 1)];
            j = (j + 1);
        }
        arr = _slice_list([]const u8, arr, 0, ((arr).len - 1), 1);
    } else {
        r = randInt(s, 4);
        s = r[0];
        const idx2 = @as(i32, r[1]); // i32
        const b = substring(bases, idx2, (idx2 + 1)); // []const u8
        arr = blk1: { var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(arr) catch |err| handleError(err); _tmp1.append("") catch |err| handleError(err); break :blk1 _tmp1.items; };
        var j = ((arr).len - 1); // i32
        while (j > p) {
            arr.items[j] = arr[(j - 1)];
            j = (j - 1);
        }
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("  Insert @", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{p}) catch |err| handleError(err), 3)), " '"), b), "'")});
        arr.items[p] = b;
    }
    var out = ""; // []const u8
    i = 0;
    while (i < (arr).len) {
        out = _concat_string(out, arr[i]);
        i = (i + 1);
    }
    return [_]i32{
    s,
    out,
};
}

fn prettyPrint(dna: []const u8, rowLen: i32) void {
    std.debug.print("SEQUENCE:\n", .{});
    const le = (dna).len; // i32
    var i = 0; // i32
    while (i < le) {
        var k = (i + rowLen); // i32
        if (k > le) {
            k = le;
        }
        std.debug.print("{s}\n", .{_concat_string(_concat_string(padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{i}) catch |err| handleError(err), 5), ": "), _slice_string(dna, i, k, 1))});
        i = (i + rowLen);
    }
    var a = 0; // i32
    var c = 0; // i32
    var g = 0; // i32
    var t = 0; // i32
    var idx = 0; // i32
    while (idx < le) {
        const ch = substring(dna, idx, (idx + 1)); // []const u8
        if (std.mem.eql(u8, ch, "A")) {
            a = (a + 1);
        } else {
            if (std.mem.eql(u8, ch, "C")) {
                c = (c + 1);
            } else {
                if (std.mem.eql(u8, ch, "G")) {
                    g = (g + 1);
                } else {
                    if (std.mem.eql(u8, ch, "T")) {
                        t = (t + 1);
                    }
                }
            }
        }
        idx = (idx + 1);
    }
    std.debug.print("\n", .{});
    std.debug.print("BASE COUNT:\n", .{});
    std.debug.print("{s}\n", .{_concat_string("    A: ", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{a}) catch |err| handleError(err), 3))});
    std.debug.print("{s}\n", .{_concat_string("    C: ", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{c}) catch |err| handleError(err), 3))});
    std.debug.print("{s}\n", .{_concat_string("    G: ", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{g}) catch |err| handleError(err), 3))});
    std.debug.print("{s}\n", .{_concat_string("    T: ", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{t}) catch |err| handleError(err), 3))});
    std.debug.print("    ------\n", .{});
    std.debug.print("{s}\n", .{_concat_string("    Î£: ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{le}) catch |err| handleError(err))});
    std.debug.print("    ======\n", .{});
}

fn wstring(w: []const i32) []const u8 {
    return _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("  Change: ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{w[0]}) catch |err| handleError(err)), "\n  Delete: "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{w[1]}) catch |err| handleError(err)), "\n  Insert: "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{w[2]}) catch |err| handleError(err)), "\n");
}

fn main() void {
    var seed = 1; // i32
    var res = makeSeq(seed, 250); // []const i32
    seed = res[0];
    var dna = @as([]const u8, res[1]); // []const u8
    prettyPrint(dna, 50);
    const muts = 10; // i32
    const w = &[_]i32{
    100,
    100,
    100,
}; // []const i32
    std.debug.print("\nWEIGHTS (ex 300):\n", .{});
    std.debug.print("{s}\n", .{wstring(w)});
    std.debug.print("{s}\n", .{_concat_string(_concat_string("MUTATIONS (", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{muts}) catch |err| handleError(err)), "):")});
    var i = 0; // i32
    while (i < muts) {
        res = mutate(seed, dna, w);
        seed = res[0];
        dna = @as([]const u8, res[1]);
        i = (i + 1);
    }
    std.debug.print("\n", .{});
    prettyPrint(dna, 50);
}

pub fn main() void {
    main();
}
