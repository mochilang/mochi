// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

var arr1 = &[_]i32{
    2,
    7,
    1,
    8,
    2,
}; // []const i32
var counts1: std.AutoHashMap(i32, i32) = undefined; // std.AutoHashMap(i32, i32)
var keys1: []const i32 = &[]i32{};
var i = 0; // i32
var max1 = 0; // i32
var modes1: []const i32 = &[]i32{};
var arr2 = &[_]i32{
    2,
    7,
    1,
    8,
    2,
    8,
}; // []const i32
var counts2: std.AutoHashMap(i32, i32) = undefined; // std.AutoHashMap(i32, i32)
var keys2: []const i32 = &[]i32{};
var max2 = 0; // i32
var modes2: []const i32 = &[]i32{};

pub fn main() void {
    counts1 = (blk0: { var _map0 = std.AutoHashMap(i32, i32).init(std.heap.page_allocator); break :blk0 _map0; });
    while (i < (arr1).len) {
        const v = arr1[i]; // i32
        if (counts1.contains(v)) {
            _ = counts1.put(v, (counts1[v] + 1)) catch |err| handleError(err);
        } else {
            _ = counts1.put(v, 1) catch |err| handleError(err);
            keys1 = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(keys1) catch |err| handleError(err); _tmp2.append(v) catch |err| handleError(err); break :blk2 _tmp2.items; };
        }
        i = (i + 1);
    }
    i = 0;
    while (i < (keys1).len) {
        const k = keys1[i]; // i32
        const c = counts1[k]; // i32
        if (c > max1) {
            max1 = c;
        }
        i = (i + 1);
    }
    i = 0;
    while (i < (keys1).len) {
        const k = keys1[i]; // i32
        if (counts1[k] == max1) {
            modes1 = blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(modes1) catch |err| handleError(err); _tmp3.append(k) catch |err| handleError(err); break :blk3 _tmp3.items; };
        }
        i = (i + 1);
    }
    std.debug.print("{s}\n", .{std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{modes1}) catch |err| handleError(err)});
    counts2 = (blk1: { var _map1 = std.AutoHashMap(i32, i32).init(std.heap.page_allocator); break :blk1 _map1; });
    i = 0;
    while (i < (arr2).len) {
        const v = arr2[i]; // i32
        if (counts2.contains(v)) {
            _ = counts2.put(v, (counts2[v] + 1)) catch |err| handleError(err);
        } else {
            _ = counts2.put(v, 1) catch |err| handleError(err);
            keys2 = blk4: { var _tmp4 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(keys2) catch |err| handleError(err); _tmp4.append(v) catch |err| handleError(err); break :blk4 _tmp4.items; };
        }
        i = (i + 1);
    }
    i = 0;
    while (i < (keys2).len) {
        const k = keys2[i]; // i32
        const c = counts2[k]; // i32
        if (c > max2) {
            max2 = c;
        }
        i = (i + 1);
    }
    i = 0;
    while (i < (keys2).len) {
        const k = keys2[i]; // i32
        if (counts2[k] == max2) {
            modes2 = blk5: { var _tmp5 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp5.deinit(); _tmp5.appendSlice(modes2) catch |err| handleError(err); _tmp5.append(k) catch |err| handleError(err); break :blk5 _tmp5.items; };
        }
        i = (i + 1);
    }
    std.debug.print("{s}\n", .{std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{modes2}) catch |err| handleError(err)});
}
