// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:41:07Z
const std = @import("std");

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn shuffle(xs: []const i32) []const i32 {
    var arr = xs; // []const i32
    var i: i32 = 99; // i32
    while (i > 0) {
        const j = @mod(std.time.nanoTimestamp(), ((i + 1))); // i32
        const tmp = arr[i]; // i32
        arr.items[i] = arr[j];
        arr.items[j] = tmp;
        i = (i - 1);
    }
    return arr.items;
}

fn doTrials(trials: i32, np: i32, strategy: []const u8) void {
    var pardoned: i32 = 0; // i32
    var t: i32 = 0; // i32
    while (t < trials) {
        var drawers = std.ArrayList(i32).init(std.heap.page_allocator);
        var i: i32 = 0; // i32
        while (i < 100) {
            drawers = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(drawers) catch |err| handleError(err); _tmp0.append(i) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
            i = (i + 1);
        }
        drawers = shuffle(drawers);
        var p: i32 = 0; // i32
        var success: bool = true; // bool
        while (p < np) {
            var found: bool = false; // bool
            if (std.mem.eql(u8, strategy, "optimal")) {
                var prev: i32 = p; // i32
                var d: i32 = 0; // i32
                while (d < 50) {
                    const this = drawers[prev]; // i32
                    if (this == p) {
                        found = true;
                        break;
                    }
                    prev = this;
                    d = (d + 1);
                }
            } else {
                var opened = std.ArrayList(bool).init(std.heap.page_allocator);
                var k: i32 = 0; // i32
                while (k < 100) {
                    opened = blk1: { var _tmp1 = std.ArrayList(bool).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(opened) catch |err| handleError(err); _tmp1.append(false) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
                    k = (k + 1);
                }
                var d: i32 = 0; // i32
                while (d < 50) {
                    var n = @mod(std.time.nanoTimestamp(), 100); // i32
                    while (opened[n]) {
                        n = @mod(std.time.nanoTimestamp(), 100);
                    }
                    opened.items[n] = true;
                    if (drawers[n] == p) {
                        found = true;
                        break;
                    }
                    d = (d + 1);
                }
            }
            if (!found) {
                success = false;
                break;
            }
            p = (p + 1);
        }
        if (success) {
            pardoned = (pardoned + 1);
        }
        t = (t + 1);
    }
    const rf = (((@as(f64, pardoned)) / (@as(f64, trials))) * 100.0); // f64
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("  strategy = ", strategy), "  pardoned = "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{pardoned}) catch |err| handleError(err)), " relative frequency = "), std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{rf}) catch |err| handleError(err)), "%")});
}

fn user_main() void {
    const trials: i32 = 1000; // i32
    for (&[_]i32{
    10,
    100,
}) |np| {
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("Results from ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{trials}) catch |err| handleError(err)), " trials with "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{np}) catch |err| handleError(err)), " prisoners:\n")});
        for (&[_][]const u8{
    "random",
    "optimal",
}) |strat| {
            doTrials(trials, np, strat);
        }
    }
}

pub fn main() void {
    user_main();
}
