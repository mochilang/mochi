// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:54Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const dim = 16; // i32

fn newPile(d: i32) []const []const i32 {
    var b = std.ArrayList(i32).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < d) {
        var row = std.ArrayList(i32).init(std.heap.page_allocator);
        var x = 0; // i32
        while (x < d) {
            row = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(row) catch |err| handleError(err); _tmp0.append(0) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
            x = (x + 1);
        }
        b = blk1: { var _tmp1 = std.ArrayList([]const i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(b) catch |err| handleError(err); _tmp1.append(row) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
        y = (y + 1);
    }
    return b.items;
}

fn handlePile(pile: []const []const i32, x: i32, y: i32) []const []const i32 {
    if (pile[y][x] >= 4) {
        pile.items[y][x] = (pile[y][x] - 4);
        if (y > 0) {
            pile.items[(y - 1)][x] = (pile[(y - 1)][x] + 1);
            if (pile[(y - 1)][x] >= 4) {
                pile = handlePile(pile, x, (y - 1));
            }
        }
        if (x > 0) {
            pile.items[y][(x - 1)] = (pile[y][(x - 1)] + 1);
            if (pile[y][(x - 1)] >= 4) {
                pile = handlePile(pile, (x - 1), y);
            }
        }
        if (y < (dim - 1)) {
            pile.items[(y + 1)][x] = (pile[(y + 1)][x] + 1);
            if (pile[(y + 1)][x] >= 4) {
                pile = handlePile(pile, x, (y + 1));
            }
        }
        if (x < (dim - 1)) {
            pile.items[y][(x + 1)] = (pile[y][(x + 1)] + 1);
            if (pile[y][(x + 1)] >= 4) {
                pile = handlePile(pile, (x + 1), y);
            }
        }
        pile = handlePile(pile, x, y);
    }
    return pile.items;
}

fn drawPile(pile: []const []const i32, d: i32) void {
    const chars = &[_][]const u8{
    " ",
    "░",
    "▓",
    "█",
}; // []const []const u8
    var row = 0; // i32
    while (row < d) {
        var line = ""; // []const u8
        var col = 0; // i32
        while (col < d) {
            var v = pile[row][col]; // i32
            if (v > 3) {
                v = 3;
            }
            line = _concat_string(line, chars[v]);
            col = (col + 1);
        }
        std.debug.print("{s}\n", .{line});
        row = (row + 1);
    }
}

fn user_main() void {
    var pile = newPile(16); // []const []const i32
    const hdim = 7; // i32
    pile.items[hdim][hdim] = 16;
    pile = handlePile(pile, hdim, hdim);
    drawPile(pile, 16);
}

pub fn main() void {
    user_main();
}
