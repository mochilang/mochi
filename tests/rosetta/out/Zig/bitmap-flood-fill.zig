// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

var grid = &[_][]const []const u8{
    &[_][]const u8{
    ".",
    ".",
    ".",
    ".",
    ".",
},
    &[_][]const u8{
    ".",
    "#",
    "#",
    "#",
    ".",
},
    &[_][]const u8{
    ".",
    "#",
    ".",
    "#",
    ".",
},
    &[_][]const u8{
    ".",
    "#",
    "#",
    "#",
    ".",
},
    &[_][]const u8{
    ".",
    ".",
    ".",
    ".",
    ".",
},
}; // []const []const []const u8

fn flood(x: i32, y: i32, repl: []const u8) void {
    const target = grid[y][x]; // []const u8
    if (std.mem.eql(u8, target, repl)) {
        return ;
    }
    const ff = (struct { grid: []const []const []const u8, repl: []const u8, target: []const u8, fn call(self: @This(), px: i32, py: i32) i32 {
        if ((((px < 0) or (py < 0)) or (py >= (self.grid).len)) or (px >= (self.grid[0]).len)) {
            return ;
        }
        if (!std.mem.eql(u8, self.grid[py][px], self.target)) {
            return ;
        }
        grid.items[py][px] = self.repl;
        ff((px - 1), py);
        ff((px + 1), py);
        ff(px, (py - 1));
        ff(px, (py + 1));
} }{ .grid = grid, .repl = repl, .target = target }).call;
    ff(x, y);
}

pub fn main() void {
    flood(2, 2, "o");
    for (grid) |row| {
        var line = ""; // []const u8
        for (row) |ch| {
            line = _concat_string(line, ch);
        }
        std.debug.print("{s}\n", .{line});
    }
}
