// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_list(comptime T: type, v: []const T, start: i32, end: i32, step: i32) []T {
    var s = start;
    var e = end;
    var st = step;
    const n: i32 = @as(i32, @intCast(v.len));
    if (s < 0) s += n;
    if (e < 0) e += n;
    if (st == 0) st = 1;
    if (s < 0) s = 0;
    if (e > n) e = n;
    if (st > 0 and e < s) e = s;
    if (st < 0 and e > s) e = s;
    var res = std.ArrayList(T).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = s;
    while ((st > 0 and i < e) or (st < 0 and i > e)) : (i += st) {
        res.append(v[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn poolPut(p: []const i32, x: i32) []const i32 {
    return blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(p) catch |err| handleError(err); _tmp0.append(x) catch |err| handleError(err); break :blk0 _tmp0.items; };
}

fn poolGet(p: []const i32) std.AutoHashMap([]const u8, i32) {
    if ((p).len == 0) {
        std.debug.print("pool empty\n", .{});
        return struct {
    pool: []const i32,
    val: i32,
}{
    .pool = p,
    .val = 0,
};
    }
    const idx = ((p).len - 1); // i32
    const v = p[idx]; // i32
    p = _slice_list(i32, p, 0, idx, 1);
    return struct {
    pool: []const i32,
    val: i32,
}{
    .pool = p,
    .val = v,
};
}

fn clearPool(p: []const i32) []const i32 {
    return []i32{};
}

fn user_main() void {
    var pool = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 1; // i32
    var j = 2; // i32
    std.debug.print("{s}\n", .{std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{(i + j)}) catch |err| handleError(err)});
    pool = poolPut(pool, i);
    pool = poolPut(pool, j);
    i = 0;
    j = 0;
    const res1 = poolGet(pool); // std.StringHashMap(i32)
    pool = @as([]const i32, res1["pool"]);
    i = @as(i32, res1["val"]);
    const res2 = poolGet(pool); // std.StringHashMap(i32)
    pool = @as([]const i32, res2["pool"]);
    j = @as(i32, res2["val"]);
    i = 4;
    j = 5;
    std.debug.print("{s}\n", .{std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{(i + j)}) catch |err| handleError(err)});
    pool = poolPut(pool, i);
    pool = poolPut(pool, j);
    i = 0;
    j = 0;
    pool = clearPool(pool);
    const res3 = poolGet(pool); // std.StringHashMap(i32)
    pool = @as([]const i32, res3["pool"]);
    i = @as(i32, res3["val"]);
    const res4 = poolGet(pool); // std.StringHashMap(i32)
    pool = @as([]const i32, res4["pool"]);
    j = @as(i32, res4["val"]);
    i = 7;
    j = 8;
    std.debug.print("{s}\n", .{std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{(i + j)}) catch |err| handleError(err)});
}

pub fn main() void {
    user_main();
}
