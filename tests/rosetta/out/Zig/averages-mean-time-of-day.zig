// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const PI = 3.141592653589793; // f64

fn sinApprox(x: f64) f64 {
    var term = x; // f64
    var sum = x; // f64
    var n = 1; // i32
    while (n <= 8) {
        const denom = @as(f64, ((((2 * n)) * (((2 * n) + 1))))); // f64
        term = (((-term * x) * x) / denom);
        sum = (sum + term);
        n = (n + 1);
    }
    return sum;
}

fn cosApprox(x: f64) f64 {
    var term = 1.0; // f64
    var sum = 1.0; // f64
    var n = 1; // i32
    while (n <= 8) {
        const denom = @as(f64, (((((2 * n) - 1)) * ((2 * n))))); // f64
        term = (((-term * x) * x) / denom);
        sum = (sum + term);
        n = (n + 1);
    }
    return sum;
}

fn atanApprox(x: f64) f64 {
    if (x > 1.0) {
        return ((PI / 2.0) - (x / (((x * x) + 0.28))));
    }
    if (x < (-1.0)) {
        return ((-PI / 2.0) - (x / (((x * x) + 0.28))));
    }
    return (x / ((1.0 + ((0.28 * x) * x))));
}

fn atan2Approx(y: f64, x: f64) f64 {
    if (x > 0.0) {
        return atanApprox((y / x));
    }
    if (x < 0.0) {
        if (y >= 0.0) {
            return (atanApprox((y / x)) + PI);
        }
        return (atanApprox((y / x)) - PI);
    }
    if (y > 0.0) {
        return (PI / 2.0);
    }
    if (y < 0.0) {
        return (-PI / 2.0);
    }
    return 0.0;
}

fn digit(ch: []const u8) i32 {
    const digits = "0123456789"; // []const u8
    var i = 0; // i32
    while (i < (digits).len) {
        if (std.mem.eql(u8, substring(digits, i, (i + 1)), ch)) {
            return i;
        }
        i = (i + 1);
    }
    return 0;
}

fn parseTwo(s: []const u8, idx: i32) i32 {
    return ((digit(substring(s, idx, (idx + 1))) * 10) + digit(substring(s, (idx + 1), (idx + 2))));
}

fn parseSec(s: []const u8) f64 {
    const h = parseTwo(s, 0); // i32
    const m = parseTwo(s, 3); // i32
    const sec = parseTwo(s, 6); // i32
    return @as(f64, ((((((h * 60) + m)) * 60) + sec)));
}

fn pad(n: i32) []const u8 {
    if (n < 10) {
        return _concat_string("0", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err));
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err);
}

fn meanTime(times: []const []const u8) []const u8 {
    var ssum = 0.0; // f64
    var csum = 0.0; // f64
    var i = 0; // i32
    while (i < (times).len) {
        const sec = parseSec(times[i]); // f64
        const ang = (((sec * 2.0) * PI) / 86400.0); // f64
        ssum = (ssum + sinApprox(ang));
        csum = (csum + cosApprox(ang));
        i = (i + 1);
    }
    var theta = atan2Approx(ssum, csum); // f64
    var frac = (theta / ((2.0 * PI))); // f64
    while (frac < 0.0) {
        frac = (frac + 1.0);
    }
    const total = (frac * 86400.0); // f64
    const si = @as(i32, total); // i32
    const h = @as(i32, ((si / 3600))); // i32
    const m = @as(i32, (((@mod(si, 3600)) / 60))); // i32
    const s = @as(i32, (@mod(si, 60))); // i32
    return _concat_string(_concat_string(_concat_string(_concat_string(pad(h), ":"), pad(m)), ":"), pad(s));
}

fn main() void {
    const inputs = &[_][]const u8{
    "23:00:17",
    "23:40:20",
    "00:12:45",
    "00:17:19",
}; // []const []const u8
    std.debug.print("{s}\n", .{meanTime(inputs)});
}

pub fn main() void {
    main();
}
