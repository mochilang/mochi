// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_list(comptime T: type, v: []const T, start: i32, end: i32, step: i32) []T {
    var s = start;
    var e = end;
    var st = step;
    const n: i32 = @as(i32, @intCast(v.len));
    if (s < 0) s += n;
    if (e < 0) e += n;
    if (st == 0) st = 1;
    if (s < 0) s = 0;
    if (e > n) e = n;
    if (st > 0 and e < s) e = s;
    if (st < 0 and e > s) e = s;
    var res = std.ArrayList(T).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = s;
    while ((st > 0 and i < e) or (st < 0 and i > e)) : (i += st) {
        res.append(v[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn isPrime(n: i32) bool {
    if (n < 2) {
        return false;
    }
    if (@mod(n, 2) == 0) {
        return (n == 2);
    }
    if (@mod(n, 3) == 0) {
        return (n == 3);
    }
    var d = 5; // i32
    while ((d * d) <= n) {
        if (@mod(n, d) == 0) {
            return false;
        }
        d = (d + 2);
        if (@mod(n, d) == 0) {
            return false;
        }
        d = (d + 4);
    }
    return true;
}

fn bigTrim(a: []const i32) []const i32 {
    var n = (a).len; // i32
    while ((n > 1) and (a[(n - 1)] == 0)) {
        a = _slice_list(i32, a, 0, (n - 1), 1);
        n = (n - 1);
    }
    return a.items;
}

fn bigFromInt(x: i32) []const i32 {
    if (x == 0) {
        return [_]i32{0};
    }
    var digits = std.ArrayList(i32).init(std.heap.page_allocator);
    var n = x; // i32
    while (n > 0) {
        digits = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(digits) catch |err| handleError(err); _tmp0.append(@mod(n, 10)) catch |err| handleError(err); break :blk0 _tmp0.items; };
        n = (n / 10);
    }
    return digits.items;
}

fn bigMulSmall(a: []const i32, m: i32) []const i32 {
    if (m == 0) {
        return [_]i32{0};
    }
    var res = std.ArrayList(i32).init(std.heap.page_allocator);
    var carry = 0; // i32
    var i = 0; // i32
    while (i < (a).len) {
        var prod = ((a[i] * m) + carry); // i32
        res = blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(res) catch |err| handleError(err); _tmp1.append(@mod(prod, 10)) catch |err| handleError(err); break :blk1 _tmp1.items; };
        carry = (prod / 10);
        i = (i + 1);
    }
    while (carry > 0) {
        res = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(res) catch |err| handleError(err); _tmp2.append(@mod(carry, 10)) catch |err| handleError(err); break :blk2 _tmp2.items; };
        carry = (carry / 10);
    }
    return bigTrim(res);
}

fn bigToString(a: []const i32) []const u8 {
    var s = ""; // []const u8
    var i = ((a).len - 1); // i32
    while (i >= 0) {
        s = _concat_string(s, std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{a[i]}) catch |err| handleError(err));
        i = (i - 1);
    }
    return s;
}

fn pow2(k: i32) i32 {
    var r = 1; // i32
    var i = 0; // i32
    while (i < k) {
        r = (r * 2);
        i = (i + 1);
    }
    return r;
}

fn ccFactors(n: i32, m: i32) []const i32 {
    var p = ((6 * m) + 1); // i32
    if (!isPrime(p)) {
        return []i32{};
    }
    var prod = bigFromInt(p); // []const i32
    p = ((12 * m) + 1);
    if (!isPrime(p)) {
        return []i32{};
    }
    prod = bigMulSmall(prod, p);
    var i = 1; // i32
    while (i <= (n - 2)) {
        p = ((((pow2(i) * 9) * m)) + 1);
        if (!isPrime(p)) {
            return []i32{};
        }
        prod = bigMulSmall(prod, p);
        i = (i + 1);
    }
    return prod.items;
}

fn ccNumbers(start: i32, end: i32) void {
    var n = start; // i32
    while (n <= end) {
        var m = 1; // i32
        if (n > 4) {
            m = pow2((n - 4));
        }
        while (true) {
            const num = ccFactors(n, m); // []const i32
            if ((num).len > 0) {
                std.debug.print("{any}\n", .{_concat_string(_concat_string(_concat_string("a(", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err)), ") = "), bigToString(num))});
                break;
            }
            if (n <= 4) {
                m = (m + 1);
            } else {
                m = (m + pow2((n - 4)));
            }
        }
        n = (n + 1);
    }
}

pub fn main() void {
    ccNumbers(3, 9);
}
