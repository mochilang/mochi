// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const PI = 3.141592653589793; // f64
const TWO_PI = 6.283185307179586; // f64

fn sinApprox(x: f64) f64 {
    var term = x; // f64
    var sum = x; // f64
    var n = 1; // i32
    while (n <= 8) {
        const denom = @as(f64, ((((2 * n)) * (((2 * n) + 1))))); // f64
        term = (((-term * x) * x) / denom);
        sum = (sum + term);
        n = (n + 1);
    }
    return sum;
}

fn floor(x: f64) f64 {
    var i = @as(i32, x); // i32
    if ((@as(f64, i)) > x) {
        i = (i - 1);
    }
    return @as(f64, i);
}

fn absFloat(x: f64) f64 {
    if (x < 0.0) {
        return -x;
    }
    return x;
}

fn absInt(n: i32) i32 {
    if (n < 0) {
        return -n;
    }
    return n;
}

fn parseIntStr(str: []const u8) i32 {
    var i = 0; // i32
    var neg = false; // bool
    if (((str).len > 0) and std.mem.eql(u8, _slice_string(str, 0, 1, 1), "-")) {
        neg = true;
        i = 1;
    }
    var n = 0; // i32
    const Digits = struct {
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
};
    const digits = Digits{
    ._ = 0,
    ._ = 1,
    ._ = 2,
    ._ = 3,
    ._ = 4,
    ._ = 5,
    ._ = 6,
    ._ = 7,
    ._ = 8,
    ._ = 9,
}; // struct {
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
}
    while (i < (str).len) {
        n = ((n * 10) + digits[_slice_string(str, i, (i + 1), 1)]);
        i = (i + 1);
    }
    if (neg) {
        n = -n;
    }
    return n;
}

fn parseDate(s: []const u8) []const i32 {
    const y = parseIntStr(_slice_string(s, 0, 4, 1)); // i32
    const m = parseIntStr(_slice_string(s, 5, 7, 1)); // i32
    const d = parseIntStr(_slice_string(s, 8, 10, 1)); // i32
    return [_]i32{
    y,
    m,
    d,
};
}

fn leap(y: i32) bool {
    if (@mod(y, 400) == 0) {
        return true;
    }
    if (@mod(y, 100) == 0) {
        return false;
    }
    return (@mod(y, 4) == 0);
}

fn daysInMonth(y: i32, m: i32) i32 {
    const feb = if (leap(y)) (29) else (28); // i32
    const lengths = &[_]i32{
    31,
    feb,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31,
}; // []const i32
    return lengths[(m - 1)];
}

fn addDays(y: i32, m: i32, d: i32, n: i32) []const i32 {
    var yy = y; // i32
    var mm = m; // i32
    var dd = d; // i32
    if (n >= 0) {
        var i = 0; // i32
        while (i < n) {
            dd = (dd + 1);
            if (dd > daysInMonth(yy, mm)) {
                dd = 1;
                mm = (mm + 1);
                if (mm > 12) {
                    mm = 1;
                    yy = (yy + 1);
                }
            }
            i = (i + 1);
        }
    } else {
        var i = 0; // i32
        while (i > n) {
            dd = (dd - 1);
            if (dd < 1) {
                mm = (mm - 1);
                if (mm < 1) {
                    mm = 12;
                    yy = (yy - 1);
                }
                dd = daysInMonth(yy, mm);
            }
            i = (i - 1);
        }
    }
    return [_]i32{
    yy,
    mm,
    dd,
};
}

fn pad2(n: i32) []const u8 {
    if (n < 10) {
        return _concat_string("0", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err));
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err);
}

fn dateString(y: i32, m: i32, d: i32) []const u8 {
    return _concat_string(_concat_string(_concat_string(_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{y}) catch |err| handleError(err), "-"), pad2(m)), "-"), pad2(d));
}

fn day(y: i32, m: i32, d: i32) i32 {
    const part1 = (367 * y); // i32
    const part2 = @as(i32, ((((7 * (@as(i32, ((y + ((((m + 9)) / 12)))))))) / 4))); // i32
    const part3 = @as(i32, ((((275 * m)) / 9))); // i32
    return ((((part1 - part2) + part3) + d) - 730530);
}

fn biorhythms(birth: []const u8, target: []const u8) void {
    const bparts = parseDate(birth); // []const i32
    const by = bparts[0]; // i32
    const bm = bparts[1]; // i32
    const bd = bparts[2]; // i32
    const tparts = parseDate(target); // []const i32
    const ty = tparts[0]; // i32
    const tm = tparts[1]; // i32
    const td = tparts[2]; // i32
    const diff = absInt((day(ty, tm, td) - day(by, bm, bd))); // i32
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string("Born ", birth), ", Target "), target)});
    std.debug.print("{s}\n", .{_concat_string("Day ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{diff}) catch |err| handleError(err))});
    const cycles = &[_][]const u8{
    "Physical day ",
    "Emotional day",
    "Mental day   ",
}; // []const []const u8
    const lengths = &[_]i32{
    23,
    28,
    33,
}; // []const i32
    const quadrants = &[_][]const []const u8{
    &[_][]const u8{
    "up and rising",
    "peak",
},
    &[_][]const u8{
    "up but falling",
    "transition",
},
    &[_][]const u8{
    "down and falling",
    "valley",
},
    &[_][]const u8{
    "down but rising",
    "transition",
},
}; // []const []const []const u8
    var i = 0; // i32
    while (i < 3) {
        const length = lengths[i]; // i32
        const cycle = cycles[i]; // []const u8
        const position = @mod(diff, length); // i32
        const quadrant = (((position * 4)) / length); // f64
        var percent = sinApprox((((2.0 * PI) * (@as(f64, position))) / (@as(f64, length)))); // f64
        percent = (floor((percent * 1000.0)) / 10.0);
        var description = ""; // []const u8
        if (percent > 95.0) {
            description = " peak";
        } else         if (percent < (-95.0)) {
            description = " valley";
        } else         if (absFloat(percent) < 5.0) {
            description = " critical transition";
        } else {
            const daysToAdd = (((((quadrant + 1)) * length) / 4) - position); // f64
            const res: i32 = addDays(ty, tm, td, daysToAdd); // i32
            const ny: i32 = res[0]; // i32
            const nm: i32 = res[1]; // i32
            const nd: i32 = res[2]; // i32
            const transition = dateString(ny, nm, nd); // []const u8
            const trend: i32 = quadrants[quadrant][0]; // i32
            const next: i32 = quadrants[quadrant][1]; // i32
            var pct = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{percent}) catch |err| handleError(err); // []const u8
            if (!contains(pct, ".")) {
                pct = _concat_string(pct, ".0");
            }
            description = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(" ", pct), "% ("), trend), ", next "), next), " "), transition), ")");
        }
        var posStr = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{position}) catch |err| handleError(err); // []const u8
        if (position < 10) {
            posStr = _concat_string(" ", posStr);
        }
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(cycle, posStr), " : "), description)});
        i = (i + 1);
    }
    std.debug.print("\n", .{});
}

fn main() void {
    const pairs = &[_][]const []const u8{
    &[_][]const u8{
    "1943-03-09",
    "1972-07-11",
},
    &[_][]const u8{
    "1809-01-12",
    "1863-11-19",
},
    &[_][]const u8{
    "1809-02-12",
    "1863-11-19",
},
}; // []const []const []const u8
    var idx = 0; // i32
    while (idx < (pairs).len) {
        const p = pairs[idx]; // []const []const u8
        biorhythms(p[0], p[1]);
        idx = (idx + 1);
    }
}

pub fn main() void {
    main();
}
