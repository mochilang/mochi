// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn isPrime(n: i32) bool {
    if (n < 2) {
        return false;
    }
    if (@mod(n, 2) == 0) {
        return (n == 2);
    }
    if (@mod(n, 3) == 0) {
        return (n == 3);
    }
    var d = 5; // i32
    while ((d * d) <= n) {
        if (@mod(n, d) == 0) {
            return false;
        }
        d = (d + 2);
        if (@mod(n, d) == 0) {
            return false;
        }
        d = (d + 4);
    }
    return true;
}

fn firstPrimeFactor(n: i32) i32 {
    if (n == 1) {
        return 1;
    }
    if (@mod(n, 3) == 0) {
        return 3;
    }
    if (@mod(n, 5) == 0) {
        return 5;
    }
    var inc = &[_]i32{
    4,
    2,
    4,
    2,
    4,
    6,
    2,
    6,
}; // []const i32
    var k = 7; // i32
    var i = 0; // i32
    while ((k * k) <= n) {
        if (@mod(n, k) == 0) {
            return k;
        }
        k = (k + inc[i]);
        i = @mod(((i + 1)), (inc).len);
    }
    return n;
}

fn indexOf(s: []const u8, ch: []const u8) i32 {
    var i = 0; // i32
    while (i < (s).len) {
        if (std.mem.eql(u8, substring(s, i, (i + 1)), ch)) {
            return i;
        }
        i = (i + 1);
    }
    return -1;
}

fn padLeft(n: i32, width: i32) []const u8 {
    var s = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err); // []const u8
    while ((s).len < width) {
        s = _concat_string(" ", s);
    }
    return s;
}

fn formatFloat(f: f64, prec: i32) []const u8 {
    const s = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{f}) catch |err| handleError(err); // []const u8
    const idx = indexOf(s, "."); // i32
    if (idx < 0) {
        return s;
    }
    const need = ((idx + 1) + prec); // i32
    if ((s).len > need) {
        return substring(s, 0, need);
    }
    return s;
}

fn user_main() void {
    var blum = std.ArrayList(i32).init(std.heap.page_allocator);
    var counts = &[_]i32{
    0,
    0,
    0,
    0,
}; // []const i32
    var digits = &[_]i32{
    1,
    3,
    7,
    9,
}; // []const i32
    var i = 1; // i32
    var bc = 0; // i32
    while (true) {
        const p = firstPrimeFactor(i); // i32
        if (@mod(p, 4) == 3) {
            const q = @as(i32, ((i / p))); // i32
            if (((q != p) and (@mod(q, 4) == 3)) and isPrime(q)) {
                if (bc < 50) {
                    blum = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(blum) catch |err| handleError(err); _tmp0.append(i) catch |err| handleError(err); break :blk0 _tmp0.items; };
                }
                const d = @mod(i, 10); // i32
                if (d == 1) {
                    counts.items[0] = (counts[0] + 1);
                } else                 if (d == 3) {
                    counts.items[1] = (counts[1] + 1);
                } else                 if (d == 7) {
                    counts.items[2] = (counts[2] + 1);
                } else                 if (d == 9) {
                    counts.items[3] = (counts[3] + 1);
                }
                bc = (bc + 1);
                if (bc == 50) {
                    std.debug.print("First 50 Blum integers:\n", .{});
                    var idx = 0; // i32
                    while (idx < 50) {
                        var line = ""; // []const u8
                        var j = 0; // i32
                        while (j < 10) {
                            line = _concat_string(_concat_string(line, padLeft(blum[idx], 3)), " ");
                            idx = (idx + 1);
                            j = (j + 1);
                        }
                        std.debug.print("{any}\n", .{substring(line, 0, ((line).len - 1))});
                    }
                    break;
                }
            }
        }
        if (@mod(i, 5) == 3) {
            i = (i + 4);
        } else {
            i = (i + 2);
        }
    }
}

pub fn main() void {
    user_main();
}
