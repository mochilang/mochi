// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn _join_strings(parts: []const []const u8, sep: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.join(u8, sep, parts, alloc) catch |err| handleError(err);
}

fn fields(s: []const u8) []const []const u8 {
    var words = std.ArrayList(u8).init(std.heap.page_allocator);
    var cur = ""; // []const u8
    var i = 0; // i32
    while (i < (s).len) {
        const ch = substring(s, i, (i + 1)); // []const u8
        if ((std.mem.eql(u8, ch, " ") or std.mem.eql(u8, ch, "\n")) or std.mem.eql(u8, ch, "\t")) {
            if ((cur).len > 0) {
                words = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(words) catch |err| handleError(err); _tmp0.append(cur) catch |err| handleError(err); break :blk0 _tmp0.items; };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, ch);
        }
        i = (i + 1);
    }
    if ((cur).len > 0) {
        words = blk1: { var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(words) catch |err| handleError(err); _tmp1.append(cur) catch |err| handleError(err); break :blk1 _tmp1.items; };
    }
    return words.items;
}

fn join(xs: []const []const u8, sep: []const u8) []const u8 {
    var res = ""; // []const u8
    var i = 0; // i32
    while (i < (xs).len) {
        if (i > 0) {
            res = _concat_string(res, sep);
        }
        res = _concat_string(res, xs[i]);
        i = (i + 1);
    }
    return res;
}

fn numberName(n: i32) []const u8 {
    const small = &[_][]const u8{
    "no",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "ten",
    "eleven",
    "twelve",
    "thirteen",
    "fourteen",
    "fifteen",
    "sixteen",
    "seventeen",
    "eighteen",
    "nineteen",
}; // []const []const u8
    const tens = &[_][]const u8{
    "ones",
    "ten",
    "twenty",
    "thirty",
    "forty",
    "fifty",
    "sixty",
    "seventy",
    "eighty",
    "ninety",
}; // []const []const u8
    if (n < 0) {
        return "";
    }
    if (n < 20) {
        return small[n];
    }
    if (n < 100) {
        var t = tens[@as(i32, ((n / 10)))]; // []const u8
        var s = @mod(n, 10); // i32
        if (s > 0) {
            t = _concat_string(_concat_string(t, " "), small[s]);
        }
        return t;
    }
    return "";
}

fn pluralizeFirst(s: []const u8, n: i32) []const u8 {
    if (n == 1) {
        return s;
    }
    const w = fields(s); // []const []const u8
    if ((w).len > 0) {
        w.items[0] = _concat_string(w[0], "s");
    }
    return _join_strings(w, " ");
}

fn randInt(seed: i32, n: i32) i32 {
    const next = @mod((((seed * 1664525) + 1013904223)), 2147483647); // i32
    return @mod(next, n);
}

fn slur(p: []const u8, d: i32) []const u8 {
    if ((p).len <= 2) {
        return p;
    }
    var a = std.ArrayList(u8).init(std.heap.page_allocator);
    var i = 1; // i32
    while (i < ((p).len - 1)) {
        a = blk2: { var _tmp2 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(a) catch |err| handleError(err); _tmp2.append(substring(p, i, (i + 1))) catch |err| handleError(err); break :blk2 _tmp2.items; };
        i = (i + 1);
    }
    var idx = ((a).len - 1); // i32
    var seed = d; // i32
    while (idx >= 1) {
        seed = @mod((((seed * 1664525) + 1013904223)), 2147483647);
        if (@mod(seed, 100) >= d) {
            const j = @mod(seed, ((idx + 1))); // i32
            const tmp = a[idx]; // []const u8
            a.items[idx] = a[j];
            a.items[j] = tmp;
        }
        idx = (idx - 1);
    }
    var s = substring(p, 0, 1); // []const u8
    var k = 0; // i32
    while (k < (a).len) {
        s = _concat_string(s, a[k]);
        k = (k + 1);
    }
    s = _concat_string(s, substring(p, ((p).len - 1), (p).len));
    const w = fields(s); // []const []const u8
    return _join_strings(w, " ");
}

fn main() void {
    var i = 99; // i32
    while (i > 0) {
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(slur(numberName(i), i), " "), pluralizeFirst(slur("bottle of", i), i)), " "), slur("beer on the wall", i))});
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(slur(numberName(i), i), " "), pluralizeFirst(slur("bottle of", i), i)), " "), slur("beer", i))});
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(slur("take one", i), " "), slur("down", i)), " "), slur("pass it around", i))});
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(slur(numberName((i - 1)), i), " "), pluralizeFirst(slur("bottle of", i), (i - 1))), " "), slur("beer on the wall", i))});
        i = (i - 1);
    }
}

pub fn main() void {
    main();
}
