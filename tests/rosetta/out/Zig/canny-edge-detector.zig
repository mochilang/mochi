// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const PI = 3.141592653589793; // f64

fn conv2d(img: []const []const f64, k: []const []const f64) []const []const f64 {
    const h = (img).len; // i32
    const w = (img[0]).len; // i32
    const n = (k).len; // i32
    const half = (n / 2); // f64
    var out = std.ArrayList(f64).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < h) {
        var row = std.ArrayList(f64).init(std.heap.page_allocator);
        var x = 0; // i32
        while (x < w) {
            var sum = 0.0; // f64
            var j = 0; // i32
            while (j < n) {
                var i = 0; // i32
                while (i < n) {
                    var yy = ((y + j) - half); // f64
                    if (yy < 0) {
                        yy = 0;
                    }
                    if (yy >= h) {
                        yy = (h - 1);
                    }
                    var xx = ((x + i) - half); // f64
                    if (xx < 0) {
                        xx = 0;
                    }
                    if (xx >= w) {
                        xx = (w - 1);
                    }
                    sum = (sum + (img[yy][xx] * k[j][i]));
                    i = (i + 1);
                }
                j = (j + 1);
            }
            row = blk0: { var _tmp0 = std.ArrayList(f64).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(row) catch |err| handleError(err); _tmp0.append(sum) catch |err| handleError(err); break :blk0 _tmp0.items; };
            x = (x + 1);
        }
        out = blk1: { var _tmp1 = std.ArrayList([]const f64).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(out) catch |err| handleError(err); _tmp1.append(row) catch |err| handleError(err); break :blk1 _tmp1.items; };
        y = (y + 1);
    }
    return out.items;
}

fn gradient(img: []const []const f64) []const []const f64 {
    const hx = &[_][]const f64{
    &[_]f64{
    -1.0,
    0.0,
    1.0,
},
    &[_]f64{
    -2.0,
    0.0,
    2.0,
},
    &[_]f64{
    -1.0,
    0.0,
    1.0,
},
}; // []const []const f64
    const hy = &[_][]const f64{
    &[_]f64{
    1.0,
    2.0,
    1.0,
},
    &[_]f64{
    0.0,
    0.0,
    0.0,
},
    &[_]f64{
    -1.0,
    -2.0,
    -1.0,
},
}; // []const []const f64
    var gx = conv2d(img, hx); // []const []const f64
    var gy = conv2d(img, hy); // []const []const f64
    var h = (img).len; // i32
    var w = (img[0]).len; // i32
    var out = std.ArrayList(f64).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < h) {
        var row = std.ArrayList(f64).init(std.heap.page_allocator);
        var x = 0; // i32
        while (x < w) {
            const g = ((gx[y][x] * gx[y][x]) + (gy[y][x] * gy[y][x])); // f64
            row = blk2: { var _tmp2 = std.ArrayList(f64).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(row) catch |err| handleError(err); _tmp2.append(g) catch |err| handleError(err); break :blk2 _tmp2.items; };
            x = (x + 1);
        }
        out = blk3: { var _tmp3 = std.ArrayList([]const f64).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(out) catch |err| handleError(err); _tmp3.append(row) catch |err| handleError(err); break :blk3 _tmp3.items; };
        y = (y + 1);
    }
    return out.items;
}

fn threshold(g: []const []const f64, t: f64) []const []const i32 {
    var h = (g).len; // i32
    var w = (g[0]).len; // i32
    var out = std.ArrayList(i32).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < h) {
        var row = std.ArrayList(i32).init(std.heap.page_allocator);
        var x = 0; // i32
        while (x < w) {
            if (g[y][x] >= t) {
                row = blk4: { var _tmp4 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(row) catch |err| handleError(err); _tmp4.append(1) catch |err| handleError(err); break :blk4 _tmp4.items; };
            } else {
                row = blk5: { var _tmp5 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp5.deinit(); _tmp5.appendSlice(row) catch |err| handleError(err); _tmp5.append(0) catch |err| handleError(err); break :blk5 _tmp5.items; };
            }
            x = (x + 1);
        }
        out = blk6: { var _tmp6 = std.ArrayList([]const i32).init(std.heap.page_allocator); defer _tmp6.deinit(); _tmp6.appendSlice(out) catch |err| handleError(err); _tmp6.append(row) catch |err| handleError(err); break :blk6 _tmp6.items; };
        y = (y + 1);
    }
    return out.items;
}

fn printMatrix(m: []const []const i32) void {
    var y = 0; // i32
    while (y < (m).len) {
        var line = ""; // []const u8
        var x = 0; // i32
        while (x < (m[0]).len) {
            line = _concat_string(line, std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{m[y][x]}) catch |err| handleError(err));
            if (x < ((m[0]).len - 1)) {
                line = _concat_string(line, " ");
            }
            x = (x + 1);
        }
        std.debug.print("{s}\n", .{line});
        y = (y + 1);
    }
}

fn main() void {
    const img = &[_][]const f64{
    &[_]f64{
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
},
    &[_]f64{
    0.0,
    255.0,
    255.0,
    255.0,
    0.0,
},
    &[_]f64{
    0.0,
    255.0,
    255.0,
    255.0,
    0.0,
},
    &[_]f64{
    0.0,
    255.0,
    255.0,
    255.0,
    0.0,
},
    &[_]f64{
    0.0,
    0.0,
    0.0,
    0.0,
    0.0,
},
}; // []const []const f64
    const g = gradient(img); // []const []const f64
    const edges = threshold(g, (1020.0 * 1020.0)); // []const []const i32
    printMatrix(edges);
}

pub fn main() void {
    main();
}
