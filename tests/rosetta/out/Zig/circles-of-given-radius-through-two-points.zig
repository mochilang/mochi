// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const Point = struct {
    x: f64,
    y: f64,
};

const Two = "Two circles."; // []const u8
const R0 = "R==0.0 does not describe circles."; // []const u8
const Co = "Coincident points describe an infinite number of circles."; // []const u8
const CoR0 = "Coincident points with r==0.0 describe a degenerate circle."; // []const u8
const Diam = "Points form a diameter and describe only a single circle."; // []const u8
const Far = "Points too far apart to form circles."; // []const u8
var td = &[_][]const i32{
    &[_]Point{
    Point{
    .x = 0.1234,
    .y = 0.9876,
},
    Point{
    .x = 0.8765,
    .y = 0.2345,
},
    2.0,
},
    &[_]Point{
    Point{
    .x = 0.0,
    .y = 2.0,
},
    Point{
    .x = 0.0,
    .y = 0.0,
},
    1.0,
},
    &[_]Point{
    Point{
    .x = 0.1234,
    .y = 0.9876,
},
    Point{
    .x = 0.1234,
    .y = 0.9876,
},
    2.0,
},
    &[_]Point{
    Point{
    .x = 0.1234,
    .y = 0.9876,
},
    Point{
    .x = 0.8765,
    .y = 0.2345,
},
    0.5,
},
    &[_]Point{
    Point{
    .x = 0.1234,
    .y = 0.9876,
},
    Point{
    .x = 0.1234,
    .y = 0.9876,
},
    0.0,
},
}; // []const []const i32

fn sqrtApprox(x: f64) f64 {
    var g = x; // f64
    var i = 0; // i32
    while (i < 40) {
        g = (((g + (x / g))) / 2.0);
        i = (i + 1);
    }
    return g;
}

fn hypot(x: f64, y: f64) f64 {
    return sqrtApprox(((x * x) + (y * y)));
}

fn circles(p1: *Point, p2: *Point, r: f64) []const i32 {
    if ((p1.x == p2.x) and (p1.y == p2.y)) {
        if (r == 0.0) {
            return [_]Point{
    p1,
    p1,
    "Coincident points with r==0.0 describe a degenerate circle.",
};
        }
        return [_]Point{
    p1,
    p2,
    "Coincident points describe an infinite number of circles.",
};
    }
    if (r == 0.0) {
        return [_]Point{
    p1,
    p2,
    "R==0.0 does not describe circles.",
};
    }
    const dx = (p2.x - p1.x); // f64
    const dy = (p2.y - p1.y); // f64
    const q = hypot(dx, dy); // f64
    if (q > (2.0 * r)) {
        return [_]Point{
    p1,
    p2,
    "Points too far apart to form circles.",
};
    }
    const m = Point{
    .x = (((p1.x + p2.x)) / 2.0),
    .y = (((p1.y + p2.y)) / 2.0),
}; // Point
    if (q == (2.0 * r)) {
        return [_]Point{
    m,
    m,
    "Points form a diameter and describe only a single circle.",
};
    }
    const d = sqrtApprox(((r * r) - ((q * q) / 4.0))); // f64
    const ox = ((d * dx) / q); // f64
    const oy = ((d * dy) / q); // f64
    return [_]Point{
    Point{
    .x = (m.x - oy),
    .y = (m.y + ox),
},
    Point{
    .x = (m.x + oy),
    .y = (m.y - ox),
},
    "Two circles.",
};
}

pub fn main() void {
    for (td) |tc| {
        const p1: i32 = tc[0]; // i32
        const p2: i32 = tc[1]; // i32
        const r: i32 = tc[2]; // i32
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("p1:  {", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{p1.x}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{p1.y}) catch |err| handleError(err)), "}")});
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("p2:  {", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{p2.x}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{p2.y}) catch |err| handleError(err)), "}")});
        std.debug.print("{s}\n", .{_concat_string("r:  ", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{r}) catch |err| handleError(err))});
        const res = circles(&p1, &p2, r); // []const i32
        const c1: i32 = res[0]; // i32
        const c2: i32 = res[1]; // i32
        const caseStr: i32 = res[2]; // i32
        std.debug.print("{any}\n", .{_concat_string("   ", caseStr)});
        if (std.mem.eql(u8, caseStr, "Points form a diameter and describe only a single circle.") or std.mem.eql(u8, caseStr, "Coincident points with r==0.0 describe a degenerate circle.")) {
            std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("   Center:  {", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{c1.x}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{c1.y}) catch |err| handleError(err)), "}")});
        } else {
            if (std.mem.eql(u8, caseStr, "Two circles.")) {
                std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("   Center 1:  {", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{c1.x}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{c1.y}) catch |err| handleError(err)), "}")});
                std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("   Center 2:  {", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{c2.x}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{c2.y}) catch |err| handleError(err)), "}")});
            }
        }
        std.debug.print("\n", .{});
    }
}
