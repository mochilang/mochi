// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const Pixel = struct {
    R: i32,
    G: i32,
    B: i32,
};

const Bitmap = struct {
    w: i32,
    h: i32,
    max: i32,
    data: []const []const Pixel,
};

var ppmtxt = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("P3\n# feep.ppm\n", "4 4\n"), "15\n"), " 0  0  0    0  0  0    0  0  0   15  0 15\n"), " 0  0  0    0 15  7    0  0  0    0  0  0\n"), " 0  0  0    0  0  0    0 15  7    0  0  0\n"), "15  0 15    0  0  0    0  0  0    0  0  0\n"); // []const u8
var bm = readP3(ppmtxt); // Bitmap
const out = writeP3(&bm); // []const u8

fn newBitmap(w: i32, h: i32, max: i32) Bitmap {
    var rows = std.ArrayList(Pixel).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < h) {
        var row = std.ArrayList(Pixel).init(std.heap.page_allocator);
        var x = 0; // i32
        while (x < w) {
            row = blk0: { var _tmp0 = std.ArrayList(Pixel).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(row) catch |err| handleError(err); _tmp0.append(Pixel{
    .R = 0,
    .G = 0,
    .B = 0,
}) catch |err| handleError(err); break :blk0 _tmp0.items; };
            x = (x + 1);
        }
        rows = blk1: { var _tmp1 = std.ArrayList([]const Pixel).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(rows) catch |err| handleError(err); _tmp1.append(row) catch |err| handleError(err); break :blk1 _tmp1.items; };
        y = (y + 1);
    }
    return Bitmap{
    .w = w,
    .h = h,
    .max = max,
    .data = rows,
};
}

fn setPx(b: *Bitmap, x: i32, y: i32, p: *Pixel) void {
    var rows = b.data; // []const []const Pixel
    var row = rows[y]; // []const Pixel
    row.items[x] = p;
    rows.items[y] = row;
    b.data = rows;
}

fn getPx(b: *Bitmap, x: i32, y: i32) Pixel {
    return b.data[y][x];
}

fn splitLines(s: []const u8) []const []const u8 {
    var out = std.ArrayList(u8).init(std.heap.page_allocator);
    var cur = ""; // []const u8
    var i = 0; // i32
    while (i < (s).len) {
        const ch = _slice_string(s, i, (i + 1), 1); // []const u8
        if (std.mem.eql(u8, ch, "\n")) {
            out = blk2: { var _tmp2 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(out) catch |err| handleError(err); _tmp2.append(cur) catch |err| handleError(err); break :blk2 _tmp2.items; };
            cur = "";
        } else {
            cur = _concat_string(cur, ch);
        }
        i = (i + 1);
    }
    out = blk3: { var _tmp3 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(out) catch |err| handleError(err); _tmp3.append(cur) catch |err| handleError(err); break :blk3 _tmp3.items; };
    return out.items;
}

fn splitWS(s: []const u8) []const []const u8 {
    var out = std.ArrayList(u8).init(std.heap.page_allocator);
    var cur = ""; // []const u8
    var i = 0; // i32
    while (i < (s).len) {
        const ch = _slice_string(s, i, (i + 1), 1); // []const u8
        if (((std.mem.eql(u8, ch, " ") or std.mem.eql(u8, ch, "\t")) or std.mem.eql(u8, ch, "\r")) or std.mem.eql(u8, ch, "\n")) {
            if ((cur).len > 0) {
                out = blk4: { var _tmp4 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(out) catch |err| handleError(err); _tmp4.append(cur) catch |err| handleError(err); break :blk4 _tmp4.items; };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, ch);
        }
        i = (i + 1);
    }
    if ((cur).len > 0) {
        out = blk5: { var _tmp5 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp5.deinit(); _tmp5.appendSlice(out) catch |err| handleError(err); _tmp5.append(cur) catch |err| handleError(err); break :blk5 _tmp5.items; };
    }
    return out.items;
}

fn parseIntStr(str: []const u8) i32 {
    var i = 0; // i32
    var neg = false; // bool
    if (((str).len > 0) and std.mem.eql(u8, _slice_string(str, 0, 1, 1), "-")) {
        neg = true;
        i = 1;
    }
    var n = 0; // i32
    const Digits = struct {
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
};
    const digits = Digits{
    ._ = 0,
    ._ = 1,
    ._ = 2,
    ._ = 3,
    ._ = 4,
    ._ = 5,
    ._ = 6,
    ._ = 7,
    ._ = 8,
    ._ = 9,
}; // struct {
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
}
    while (i < (str).len) {
        n = ((n * 10) + digits[_slice_string(str, i, (i + 1), 1)]);
        i = (i + 1);
    }
    if (neg) {
        n = -n;
    }
    return n;
}

fn tokenize(s: []const u8) []const []const u8 {
    const lines = splitLines(s); // []const []const u8
    var toks = std.ArrayList(u8).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < (lines).len) {
        const line = lines[i]; // []const u8
        if (((line).len > 0) and std.mem.eql(u8, _slice_string(line, 0, 1, 1), "#")) {
            i = (i + 1);
            continue;
        }
        const parts = splitWS(line); // []const []const u8
        var j = 0; // i32
        while (j < (parts).len) {
            toks = blk6: { var _tmp6 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp6.deinit(); _tmp6.appendSlice(toks) catch |err| handleError(err); _tmp6.append(parts[j]) catch |err| handleError(err); break :blk6 _tmp6.items; };
            j = (j + 1);
        }
        i = (i + 1);
    }
    return toks.items;
}

fn readP3(text: []const u8) Bitmap {
    const toks = tokenize(text); // []const []const u8
    if ((toks).len < 4) {
        return newBitmap(0, 0, 0);
    }
    if (!std.mem.eql(u8, toks[0], "P3")) {
        return newBitmap(0, 0, 0);
    }
    const w: i32 = parseIntStr(toks[1]); // i32
    const h: i32 = parseIntStr(toks[2]); // i32
    const maxv: i32 = parseIntStr(toks[3]); // i32
    var idx = 4; // i32
    var bm = newBitmap(w, h, maxv); // Bitmap
    var y = (h - 1); // i32
    while (y >= 0) {
        var x = 0; // i32
        while (x < w) {
            const r: i32 = parseIntStr(toks[idx]); // i32
            const g: i32 = parseIntStr(toks[(idx + 1)]); // i32
            const b: i32 = parseIntStr(toks[(idx + 2)]); // i32
            setPx(&bm, x, y, &Pixel{
    .R = r,
    .G = g,
    .B = b,
});
            idx = (idx + 3);
            x = (x + 1);
        }
        y = (y - 1);
    }
    return bm;
}

fn toGrey(b: *Bitmap) void {
    const h: i32 = b.h; // i32
    const w: i32 = b.w; // i32
    var m = 0; // i32
    var y = 0; // i32
    while (y < h) {
        var x = 0; // i32
        while (x < w) {
            const p = getPx(&b, x, y); // Pixel
            var l = (((((p.R * 2126) + (p.G * 7152)) + (p.B * 722))) / 10000); // f64
            if (l > b.max) {
                l = b.max;
            }
            setPx(&b, x, y, &Pixel{
    .R = l,
    .G = l,
    .B = l,
});
            if (l > m) {
                m = l;
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    b.max = m;
}

fn pad(n: i32, w: i32) []const u8 {
    var s = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err); // []const u8
    while ((s).len < w) {
        s = _concat_string(" ", s);
    }
    return s;
}

fn writeP3(b: *Bitmap) []const u8 {
    const h: i32 = b.h; // i32
    const w: i32 = b.w; // i32
    var max = b.max; // i32
    const digits = (std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{max}) catch |err| handleError(err)).len; // i32
    var out = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("P3\n# generated from Bitmap.writeppmp3\n", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{w}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{h}) catch |err| handleError(err)), "\n"), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{max}) catch |err| handleError(err)), "\n"); // []const u8
    var y = (h - 1); // i32
    while (y >= 0) {
        var line = ""; // []const u8
        var x = 0; // i32
        while (x < w) {
            const p = getPx(&b, x, y); // Pixel
            line = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(line, "   "), pad(p.R, digits)), " "), pad(p.G, digits)), " "), pad(p.B, digits));
            x = (x + 1);
        }
        out = _concat_string(_concat_string(out, line), "\n");
        y = (y - 1);
    }
    return out;
}

pub fn main() void {
    std.debug.print("Original Colour PPM file\n", .{});
    std.debug.print("{s}\n", .{ppmtxt});
    std.debug.print("Grey PPM:\n", .{});
    toGrey(&bm);
    std.debug.print("{s}\n", .{out});
}
