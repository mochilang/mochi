// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:32:01Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const SIZE = 4; // i32
var board = newBoard(); // []const []const i32
var r = spawnTile(board); // std.StringHashMap(i32)
var full = r["full"]; // i32
var score = 0; // i32

fn newBoard() []const []const i32 {
    var b = std.ArrayList(i32).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < SIZE) {
        var row = std.ArrayList(i32).init(std.heap.page_allocator);
        var x = 0; // i32
        while (x < SIZE) {
            row = blk0: {
                var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator);
                defer _tmp0.deinit();
                _tmp0.appendSlice(row) catch |err| handleError(err);
                _tmp0.append(0) catch |err| handleError(err);
                const res = _tmp0.toOwnedSlice() catch |err| handleError(err);
                break :blk0 res;
            };
            x = (x + 1);
        }
        b = blk1: {
            var _tmp1 = std.ArrayList([]const i32).init(std.heap.page_allocator);
            defer _tmp1.deinit();
            _tmp1.appendSlice(b) catch |err| handleError(err);
            _tmp1.append(row) catch |err| handleError(err);
            const res = _tmp1.toOwnedSlice() catch |err| handleError(err);
            break :blk1 res;
        };
        y = (y + 1);
    }
    return b.items;
}

fn spawnTile(b: []const []const i32) std.AutoHashMap([]const u8, i32) {
    var empty = std.ArrayList(i32).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < SIZE) {
        var x = 0; // i32
        while (x < SIZE) {
            if (b[y][x] == 0) {
                empty = blk2: {
                    var _tmp2 = std.ArrayList([]const i32).init(std.heap.page_allocator);
                    defer _tmp2.deinit();
                    _tmp2.appendSlice(empty) catch |err| handleError(err);
                    _tmp2.append(&[_]i32{
                        x,
                        y,
                    }) catch |err| handleError(err);
                    const res = _tmp2.toOwnedSlice() catch |err| handleError(err);
                    break :blk2 res;
                };
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    if (@as(i32, @intCast((empty).len)) == 0) {
        return struct {
            board: []const []const i32,
            full: bool,
        }{
            .board = b,
            .full = true,
        };
    }
    var idx = @mod(std.time.nanoTimestamp(), @as(i32, @intCast((empty).len))); // i32
    const cell = empty[idx]; // []const i32
    var val = 4; // i32
    if (@mod(std.time.nanoTimestamp(), 10) < 9) {
        val = 2;
    }
    b.items[cell[1]][cell[0]] = val;
    return struct {
        board: []const []const i32,
        full: bool,
    }{
        .board = b,
        .full = (@as(i32, @intCast((empty).len)) == 1),
    };
}

fn pad(n: i32) []const u8 {
    var s = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err); // []const u8
    var pad = (4 - @as(i32, @intCast((s).len))); // i32
    var i = 0; // i32
    var out = ""; // []const u8
    while (i < pad) {
        out = _concat_string(out, " ");
        i = (i + 1);
    }
    return _concat_string(out, s);
}

fn draw(b: []const []const i32, score: i32) void {
    std.debug.print("{s}\n", .{_concat_string("Score: ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{score}) catch |err| handleError(err))});
    var y = 0; // i32
    while (y < SIZE) {
        std.debug.print("+----+----+----+----+\n", .{});
        var line = "|"; // []const u8
        var x = 0; // i32
        while (x < SIZE) {
            var v = b[y][x]; // i32
            if (v == 0) {
                line = _concat_string(line, "    |");
            } else {
                line = _concat_string(_concat_string(line, pad(v)), "|");
            }
            x = (x + 1);
        }
        std.debug.print("{s}\n", .{line});
        y = (y + 1);
    }
    std.debug.print("+----+----+----+----+\n", .{});
    std.debug.print("W=Up S=Down A=Left D=Right Q=Quit\n", .{});
}

fn reverseRow(r: []const i32) []const i32 {
    var out = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = (@as(i32, @intCast((r).len)) - 1); // i32
    while (i >= 0) {
        out = blk3: {
            var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator);
            defer _tmp3.deinit();
            _tmp3.appendSlice(out) catch |err| handleError(err);
            _tmp3.append(r[i]) catch |err| handleError(err);
            const res = _tmp3.toOwnedSlice() catch |err| handleError(err);
            break :blk3 res;
        };
        i = (i - 1);
    }
    return out.items;
}

fn slideLeft(row: []const i32) std.AutoHashMap([]const u8, i32) {
    var xs = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < @as(i32, @intCast((row).len))) {
        if (row[i] != 0) {
            xs = blk4: {
                var _tmp4 = std.ArrayList(i32).init(std.heap.page_allocator);
                defer _tmp4.deinit();
                _tmp4.appendSlice(xs) catch |err| handleError(err);
                _tmp4.append(row[i]) catch |err| handleError(err);
                const res = _tmp4.toOwnedSlice() catch |err| handleError(err);
                break :blk4 res;
            };
        }
        i = (i + 1);
    }
    var res = std.ArrayList(i32).init(std.heap.page_allocator);
    var gain = 0; // i32
    i = 0;
    while (i < @as(i32, @intCast((xs).len))) {
        if (((i + 1) < @as(i32, @intCast((xs).len))) and (xs[i] == xs[(i + 1)])) {
            const v = (xs[i] * 2); // i32
            gain = (gain + v);
            res = blk5: {
                var _tmp5 = std.ArrayList(i32).init(std.heap.page_allocator);
                defer _tmp5.deinit();
                _tmp5.appendSlice(res) catch |err| handleError(err);
                _tmp5.append(v) catch |err| handleError(err);
                const res = _tmp5.toOwnedSlice() catch |err| handleError(err);
                break :blk5 res;
            };
            i = (i + 2);
        } else {
            res = blk6: {
                var _tmp6 = std.ArrayList(i32).init(std.heap.page_allocator);
                defer _tmp6.deinit();
                _tmp6.appendSlice(res) catch |err| handleError(err);
                _tmp6.append(xs[i]) catch |err| handleError(err);
                const res = _tmp6.toOwnedSlice() catch |err| handleError(err);
                break :blk6 res;
            };
            i = (i + 1);
        }
    }
    while (@as(i32, @intCast((res).len)) < SIZE) {
        res = blk7: {
            var _tmp7 = std.ArrayList(i32).init(std.heap.page_allocator);
            defer _tmp7.deinit();
            _tmp7.appendSlice(res) catch |err| handleError(err);
            _tmp7.append(0) catch |err| handleError(err);
            const res = _tmp7.toOwnedSlice() catch |err| handleError(err);
            break :blk7 res;
        };
    }
    return struct {
        row: []const i32,
        gain: i32,
    }{
        .row = res,
        .gain = gain,
    };
}

fn moveLeft(b: []const []const i32, score: i32) std.AutoHashMap([]const u8, i32) {
    var moved = false; // bool
    var y = 0; // i32
    while (y < SIZE) {
        const r = slideLeft(b[y]); // std.StringHashMap(i32)
        const new: i32 = r["row"]; // i32
        score = (score + r["gain"]);
        var x = 0; // i32
        while (x < SIZE) {
            if (b[y][x] != new[x]) {
                moved = true;
            }
            b.items[y][x] = new[x];
            x = (x + 1);
        }
        y = (y + 1);
    }
    return struct {
        board: []const []const i32,
        score: i32,
        moved: bool,
    }{
        .board = b,
        .score = score,
        .moved = moved,
    };
}

fn moveRight(b: []const []const i32, score: i32) std.AutoHashMap([]const u8, i32) {
    var moved = false; // bool
    var y = 0; // i32
    while (y < SIZE) {
        var rev = reverseRow(b[y]); // []const i32
        const r = slideLeft(rev); // std.StringHashMap(i32)
        rev = r["row"];
        score = (score + r["gain"]);
        rev = reverseRow(rev);
        var x = 0; // i32
        while (x < SIZE) {
            if (b[y][x] != rev[x]) {
                moved = true;
            }
            b.items[y][x] = rev[x];
            x = (x + 1);
        }
        y = (y + 1);
    }
    return struct {
        board: []const []const i32,
        score: i32,
        moved: bool,
    }{
        .board = b,
        .score = score,
        .moved = moved,
    };
}

fn getCol(b: []const []const i32, x: i32) []const i32 {
    var col = std.ArrayList(i32).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < SIZE) {
        col = blk8: {
            var _tmp8 = std.ArrayList(i32).init(std.heap.page_allocator);
            defer _tmp8.deinit();
            _tmp8.appendSlice(col) catch |err| handleError(err);
            _tmp8.append(b[y][x]) catch |err| handleError(err);
            const res = _tmp8.toOwnedSlice() catch |err| handleError(err);
            break :blk8 res;
        };
        y = (y + 1);
    }
    return col.items;
}

fn setCol(b: []const []const i32, x: i32, col: []const i32) void {
    var y = 0; // i32
    while (y < SIZE) {
        b.items[y][x] = col[y];
        y = (y + 1);
    }
}

fn moveUp(b: []const []const i32, score: i32) std.AutoHashMap([]const u8, i32) {
    var moved = false; // bool
    var x = 0; // i32
    while (x < SIZE) {
        var col = getCol(b, x); // []const i32
        const r = slideLeft(col); // std.StringHashMap(i32)
        const new: i32 = r["row"]; // i32
        score = (score + r["gain"]);
        var y = 0; // i32
        while (y < SIZE) {
            if (b[y][x] != new[y]) {
                moved = true;
            }
            b.items[y][x] = new[y];
            y = (y + 1);
        }
        x = (x + 1);
    }
    return struct {
        board: []const []const i32,
        score: i32,
        moved: bool,
    }{
        .board = b,
        .score = score,
        .moved = moved,
    };
}

fn moveDown(b: []const []const i32, score: i32) std.AutoHashMap([]const u8, i32) {
    var moved = false; // bool
    var x = 0; // i32
    while (x < SIZE) {
        var col = reverseRow(getCol(b, x)); // []const i32
        const r = slideLeft(col); // std.StringHashMap(i32)
        col = r["row"];
        score = (score + r["gain"]);
        col = reverseRow(col);
        var y = 0; // i32
        while (y < SIZE) {
            if (b[y][x] != col[y]) {
                moved = true;
            }
            b.items[y][x] = col[y];
            y = (y + 1);
        }
        x = (x + 1);
    }
    return struct {
        board: []const []const i32,
        score: i32,
        moved: bool,
    }{
        .board = b,
        .score = score,
        .moved = moved,
    };
}

fn hasMoves(b: []const []const i32) bool {
    var y = 0; // i32
    while (y < SIZE) {
        var x = 0; // i32
        while (x < SIZE) {
            if (b[y][x] == 0) {
                return true;
            }
            if (((x + 1) < SIZE) and (b[y][x] == b[y][(x + 1)])) {
                return true;
            }
            if (((y + 1) < SIZE) and (b[y][x] == b[(y + 1)][x])) {
                return true;
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    return false;
}

fn has2048(b: []const []const i32) bool {
    var y = 0; // i32
    while (y < SIZE) {
        var x = 0; // i32
        while (x < SIZE) {
            if (b[y][x] >= 2048) {
                return true;
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    return false;
}

pub fn main() void {
    board = r["board"];
    r = spawnTile(board);
    board = r["board"];
    full = r["full"];
    draw(board, score);
    while (true) {
        std.debug.print("Move: \n", .{});
        const cmd = input(); // []const u8
        var moved = false; // bool
        if (std.mem.eql(u8, cmd, "a") or std.mem.eql(u8, cmd, "A")) {
            const m = moveLeft(board, score); // std.StringHashMap(i32)
            board = m["board"];
            score = m["score"];
            moved = m["moved"];
        }
        if (std.mem.eql(u8, cmd, "d") or std.mem.eql(u8, cmd, "D")) {
            const m = moveRight(board, score); // std.StringHashMap(i32)
            board = m["board"];
            score = m["score"];
            moved = m["moved"];
        }
        if (std.mem.eql(u8, cmd, "w") or std.mem.eql(u8, cmd, "W")) {
            const m = moveUp(board, score); // std.StringHashMap(i32)
            board = m["board"];
            score = m["score"];
            moved = m["moved"];
        }
        if (std.mem.eql(u8, cmd, "s") or std.mem.eql(u8, cmd, "S")) {
            const m = moveDown(board, score); // std.StringHashMap(i32)
            board = m["board"];
            score = m["score"];
            moved = m["moved"];
        }
        if (std.mem.eql(u8, cmd, "q") or std.mem.eql(u8, cmd, "Q")) {
            break;
        }
        if (moved) {
            const r2 = spawnTile(board); // std.StringHashMap(i32)
            board = r2["board"];
            full = r2["full"];
            if (full and (!hasMoves(board))) {
                draw(board, score);
                std.debug.print("Game Over\n", .{});
                break;
            }
        }
        draw(board, score);
        if (has2048(board)) {
            std.debug.print("You win!\n", .{});
            break;
        }
        if (!hasMoves(board)) {
            std.debug.print("Game Over\n", .{});
            break;
        }
    }
}
