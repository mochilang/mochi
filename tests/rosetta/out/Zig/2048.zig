// Generated by Mochi Zig transpiler on 2025-07-23 09:39 +0700
const std = @import("std");

fn newBoard() [][]i64 {
    var b: [][]i64 = &[_][]i64{};
    var y: i64 = 0;
    while (y < SIZE) {
        var row: []i64 = &[_]i64{};
        var x: i64 = 0;
        while (x < SIZE) {
            row = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(row) catch unreachable; _tmp.append(0) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            x = x + 1;
        }
        b = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(b) catch unreachable; _tmp.append(row) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        y = y + 1;
    }
    return b;
}

fn spawnTile(b: [][]i64) i64 {
    var empty: [][]i64 = &[_][]i64{};
    var y: i64 = 0;
    while (y < SIZE) {
        var x: i64 = 0;
        while (x < SIZE) {
            if (b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] == 0) {
                empty = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(empty) catch unreachable; _tmp.append([2]i64{x, y}) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            }
            x = x + 1;
        }
        y = y + 1;
    }
    if (std.mem.len(empty) == 0) {
        return blk: { var m = std.StringHashMap([][]i64).init(std.heap.page_allocator); m.put("board", b) catch unreachable; m.put("full", true) catch unreachable; break :blk m; };
    }
    var idx = @mod(_now(), std.mem.len(empty));
    const cell = empty[@as(usize, @intCast(idx))];
    var val: i64 = 4;
    if (@mod(_now(), 10) < 9) {
        val = 2;
    }
    b[@as(usize, @intCast(cell[@as(usize, @intCast(1))]))][@as(usize, @intCast(cell[@as(usize, @intCast(0))]))] = val;
    return blk: { var m = std.StringHashMap([][]i64).init(std.heap.page_allocator); m.put("board", b) catch unreachable; m.put("full", std.mem.len(empty) == 1) catch unreachable; break :blk m; };
}

fn pad(n: i64) []const u8 {
    var s = _str(n);
    var pad = 4 - std.mem.len(s);
    var i: i64 = 0;
    var out = "";
    while (i < pad) {
        out = _concat_string(out, " ");
        i = i + 1;
    }
    return _concat_string(out, s);
}

fn draw(b: [][]i64, score: i64) void {
    std.io.getStdOut().writer().print("{any}\n", .{_concat_string("Score: ", _str(score))}) catch unreachable;
    var y: i64 = 0;
    while (y < SIZE) {
        std.io.getStdOut().writer().print("{s}\n", .{"+----+----+----+----+"}) catch unreachable;
        var line = "|";
        var x: i64 = 0;
        while (x < SIZE) {
            var v = b[@as(usize, @intCast(y))][@as(usize, @intCast(x))];
            if (v == 0) {
                line = _concat_string(line, "    |");
            } else {
                line = _concat_string(_concat_string(line, pad(v)), "|");
            }
            x = x + 1;
        }
        std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
        y = y + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{"+----+----+----+----+"}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{"W=Up S=Down A=Left D=Right Q=Quit"}) catch unreachable;
}

fn reverseRow(r: []i64) []i64 {
    var out: []i64 = &[_]i64{};
    var i = std.mem.len(r) - 1;
    while (i >= 0) {
        out = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(out) catch unreachable; _tmp.append(r[@as(usize, @intCast(i))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i - 1;
    }
    return out;
}

fn slideLeft(row: []i64) i64 {
    var xs: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < std.mem.len(row)) {
        if (row[@as(usize, @intCast(i))] != 0) {
            xs = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(xs) catch unreachable; _tmp.append(row[@as(usize, @intCast(i))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        }
        i = i + 1;
    }
    var res: []i64 = &[_]i64{};
    var gain: i64 = 0;
    i = 0;
    while (i < std.mem.len(xs)) {
        if (i + 1 < std.mem.len(xs) and xs[@as(usize, @intCast(i))] == xs[@as(usize, @intCast(i + 1))]) {
            const v = xs[@as(usize, @intCast(i))] * 2;
            gain = gain + v;
            res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(v) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            i = i + 2;
        } else {
            res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(xs[@as(usize, @intCast(i))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            i = i + 1;
        }
    }
    while (std.mem.len(res) < SIZE) {
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(0) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
    }
    return blk: { var m = std.StringHashMap([]i64).init(std.heap.page_allocator); m.put("row", res) catch unreachable; m.put("gain", gain) catch unreachable; break :blk m; };
}

fn moveLeft(b: [][]i64, score: i64) i64 {
    var moved = false;
    var y: i64 = 0;
    while (y < SIZE) {
        const r = slideLeft(b[@as(usize, @intCast(y))]);
        const new = r[@as(usize, @intCast("row"))];
        score = score + r[@as(usize, @intCast("gain"))];
        var x: i64 = 0;
        while (x < SIZE) {
            if (b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] != new[@as(usize, @intCast(x))]) {
                moved = true;
            }
            b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = new[@as(usize, @intCast(x))];
            x = x + 1;
        }
        y = y + 1;
    }
    return blk: { var m = std.StringHashMap([][]i64).init(std.heap.page_allocator); m.put("board", b) catch unreachable; m.put("score", score) catch unreachable; m.put("moved", moved) catch unreachable; break :blk m; };
}

fn moveRight(b: [][]i64, score: i64) i64 {
    var moved = false;
    var y: i64 = 0;
    while (y < SIZE) {
        var rev = reverseRow(b[@as(usize, @intCast(y))]);
        const r = slideLeft(rev);
        rev = r[@as(usize, @intCast("row"))];
        score = score + r[@as(usize, @intCast("gain"))];
        rev = reverseRow(rev);
        var x: i64 = 0;
        while (x < SIZE) {
            if (b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] != rev[@as(usize, @intCast(x))]) {
                moved = true;
            }
            b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = rev[@as(usize, @intCast(x))];
            x = x + 1;
        }
        y = y + 1;
    }
    return blk: { var m = std.StringHashMap([][]i64).init(std.heap.page_allocator); m.put("board", b) catch unreachable; m.put("score", score) catch unreachable; m.put("moved", moved) catch unreachable; break :blk m; };
}

fn getCol(b: [][]i64, x: i64) []i64 {
    var col: []i64 = &[_]i64{};
    var y: i64 = 0;
    while (y < SIZE) {
        col = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(col) catch unreachable; _tmp.append(b[@as(usize, @intCast(y))][@as(usize, @intCast(x))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        y = y + 1;
    }
    return col;
}

fn setCol(b: [][]i64, x: i64, col: []i64) void {
    var y: i64 = 0;
    while (y < SIZE) {
        b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = col[@as(usize, @intCast(y))];
        y = y + 1;
    }
}

fn moveUp(b: [][]i64, score: i64) i64 {
    var moved = false;
    var x: i64 = 0;
    while (x < SIZE) {
        var col = getCol(b, x);
        const r = slideLeft(col);
        const new = r[@as(usize, @intCast("row"))];
        score = score + r[@as(usize, @intCast("gain"))];
        var y: i64 = 0;
        while (y < SIZE) {
            if (b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] != new[@as(usize, @intCast(y))]) {
                moved = true;
            }
            b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = new[@as(usize, @intCast(y))];
            y = y + 1;
        }
        x = x + 1;
    }
    return blk: { var m = std.StringHashMap([][]i64).init(std.heap.page_allocator); m.put("board", b) catch unreachable; m.put("score", score) catch unreachable; m.put("moved", moved) catch unreachable; break :blk m; };
}

fn moveDown(b: [][]i64, score: i64) i64 {
    var moved = false;
    var x: i64 = 0;
    while (x < SIZE) {
        var col = reverseRow(getCol(b, x));
        const r = slideLeft(col);
        col = r[@as(usize, @intCast("row"))];
        score = score + r[@as(usize, @intCast("gain"))];
        col = reverseRow(col);
        var y: i64 = 0;
        while (y < SIZE) {
            if (b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] != col[@as(usize, @intCast(y))]) {
                moved = true;
            }
            b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = col[@as(usize, @intCast(y))];
            y = y + 1;
        }
        x = x + 1;
    }
    return blk: { var m = std.StringHashMap([][]i64).init(std.heap.page_allocator); m.put("board", b) catch unreachable; m.put("score", score) catch unreachable; m.put("moved", moved) catch unreachable; break :blk m; };
}

fn hasMoves(b: [][]i64) bool {
    var y: i64 = 0;
    while (y < SIZE) {
        var x: i64 = 0;
        while (x < SIZE) {
            if (b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] == 0) {
                return true;
            }
            if (x + 1 < SIZE and b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] == b[@as(usize, @intCast(y))][@as(usize, @intCast(x + 1))]) {
                return true;
            }
            if (y + 1 < SIZE and b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] == b[@as(usize, @intCast(y + 1))][@as(usize, @intCast(x))]) {
                return true;
            }
            x = x + 1;
        }
        y = y + 1;
    }
    return false;
}

fn has2048(b: [][]i64) bool {
    var y: i64 = 0;
    while (y < SIZE) {
        var x: i64 = 0;
        while (x < SIZE) {
            if (b[@as(usize, @intCast(y))][@as(usize, @intCast(x))] >= 2048) {
                return true;
            }
            x = x + 1;
        }
        y = y + 1;
    }
    return false;
}

pub fn main() void {
    const SIZE = 4;
    var board = newBoard();
    var r = spawnTile(board);
    board = r[@as(usize, @intCast("board"))];
    var full = r[@as(usize, @intCast("full"))];
    r = spawnTile(board);
    board = r[@as(usize, @intCast("board"))];
    full = r[@as(usize, @intCast("full"))];
    var score: i64 = 0;
    draw(board, score);
    while (true) {
        std.io.getStdOut().writer().print("{s}\n", .{"Move: "}) catch unreachable;
        const cmd = input();
        var moved = false;
        if (cmd == "a" or cmd == "A") {
            const m = moveLeft(board, score);
            board = m[@as(usize, @intCast("board"))];
            score = m[@as(usize, @intCast("score"))];
            moved = m[@as(usize, @intCast("moved"))];
        }
        if (cmd == "d" or cmd == "D") {
            const m = moveRight(board, score);
            board = m[@as(usize, @intCast("board"))];
            score = m[@as(usize, @intCast("score"))];
            moved = m[@as(usize, @intCast("moved"))];
        }
        if (cmd == "w" or cmd == "W") {
            const m = moveUp(board, score);
            board = m[@as(usize, @intCast("board"))];
            score = m[@as(usize, @intCast("score"))];
            moved = m[@as(usize, @intCast("moved"))];
        }
        if (cmd == "s" or cmd == "S") {
            const m = moveDown(board, score);
            board = m[@as(usize, @intCast("board"))];
            score = m[@as(usize, @intCast("score"))];
            moved = m[@as(usize, @intCast("moved"))];
        }
        if (cmd == "q" or cmd == "Q") {
            break;
        }
        if (moved) {
            const r2 = spawnTile(board);
            board = r2[@as(usize, @intCast("board"))];
            full = r2[@as(usize, @intCast("full"))];
            if (full and !(hasMoves(board))) {
                draw(board, score);
                std.io.getStdOut().writer().print("{s}\n", .{"Game Over"}) catch unreachable;
                break;
            }
        }
        draw(board, score);
        if (has2048(board)) {
            std.io.getStdOut().writer().print("{s}\n", .{"You win!"}) catch unreachable;
            break;
        }
        if (!(hasMoves(board))) {
            std.io.getStdOut().writer().print("{s}\n", .{"Game Over"}) catch unreachable;
            break;
        }
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |s| {
            defer std.heap.page_allocator.free(s);
            if (std.fmt.parseInt(i64, s, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _str(v: anytype) []const u8 {
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
