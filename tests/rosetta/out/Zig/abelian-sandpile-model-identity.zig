// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

var s4 = &[_]i32{
    4,
    3,
    3,
    3,
    1,
    2,
    0,
    2,
    3,
}; // []const i32
var s1 = &[_]i32{
    1,
    2,
    0,
    2,
    1,
    1,
    0,
    1,
    3,
}; // []const i32
var s2 = &[_]i32{
    2,
    1,
    3,
    1,
    0,
    1,
    0,
    1,
    0,
}; // []const i32
var s3_a = plus(s1, s2); // []const i32
var s3_b = plus(s2, s1); // []const i32
var s3 = &[_]i32{
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
}; // []const i32
var s3_id = &[_]i32{
    2,
    1,
    2,
    1,
    0,
    1,
    2,
    1,
    2,
}; // []const i32
var s4b = plus(s3, s3_id); // []const i32
var s5 = plus(s3_id, s3_id); // []const i32

fn neighborsList() []const []const i32 {
    return [_][]const i32{
    &[_]i32{
    1,
    3,
},
    &[_]i32{
    0,
    2,
    4,
},
    &[_]i32{
    1,
    5,
},
    &[_]i32{
    0,
    4,
    6,
},
    &[_]i32{
    1,
    3,
    5,
    7,
},
    &[_]i32{
    2,
    4,
    8,
},
    &[_]i32{
    3,
    7,
},
    &[_]i32{
    4,
    6,
    8,
},
    &[_]i32{
    5,
    7,
},
};
}

fn plus(a: []const i32, b: []const i32) []const i32 {
    var res = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < (a).len) {
        res = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(res) catch |err| handleError(err); _tmp0.append((a[i] + b[i])) catch |err| handleError(err); break :blk0 _tmp0.items; };
        i = (i + 1);
    }
    return res.items;
}

fn isStable(p: []const i32) bool {
    for (p) |v| {
        if (v > 3) {
            return false;
        }
    }
    return true;
}

fn topple(p: []const i32) i32 {
    const neighbors = neighborsList(); // []const []const i32
    var i = 0; // i32
    while (i < (p).len) {
        if (p[i] > 3) {
            p.items[i] = (p[i] - 4);
            const nbs = neighbors[i]; // []const i32
            for (nbs) |j| {
                p.items[j] = (p[j] + 1);
            }
            return 0;
        }
        i = (i + 1);
    }
    return 0;
}

fn pileString(p: []const i32) []const u8 {
    var s = ""; // []const u8
    var r = 0; // i32
    while (r < 3) {
        var c = 0; // i32
        while (c < 3) {
            s = _concat_string(_concat_string(s, std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{p[((3 * r) + c)]}) catch |err| handleError(err)), " ");
            c = (c + 1);
        }
        s = _concat_string(s, "\n");
        r = (r + 1);
    }
    return s;
}

pub fn main() void {
    std.debug.print("Avalanche of topplings:\n\n", .{});
    std.debug.print("{s}\n", .{pileString(s4)});
    while (!isStable(s4)) {
        topple(s4);
        std.debug.print("{s}\n", .{pileString(s4)});
    }
    std.debug.print("Commutative additions:\n\n", .{});
    while (!isStable(s3_a)) {
        topple(s3_a);
    }
    while (!isStable(s3_b)) {
        topple(s3_b);
    }
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(pileString(s1), "\nplus\n\n"), pileString(s2)), "\nequals\n\n"), pileString(s3_a))});
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("and\n\n", pileString(s2)), "\nplus\n\n"), pileString(s1)), "\nalso equals\n\n"), pileString(s3_b))});
    std.debug.print("Addition of identity sandpile:\n\n", .{});
    while (!isStable(s4b)) {
        topple(s4b);
    }
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(pileString(s3), "\nplus\n\n"), pileString(s3_id)), "\nequals\n\n"), pileString(s4b))});
    std.debug.print("Addition of identities:\n\n", .{});
    while (!isStable(s5)) {
        topple(s5);
    }
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(pileString(s3_id), "\nplus\n\n"), pileString(s3_id)), "\nequals\n\n"), pileString(s5))});
}
