// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const Colour = struct {
    R: i32,
    G: i32,
    B: i32,
};

const Bitmap = struct {
    width: i32,
    height: i32,
    pixels: []const []const Colour,
};

fn newBitmap(w: i32, h: i32, c: *Colour) Bitmap {
    var rows = std.ArrayList(Colour).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < h) {
        var row = std.ArrayList(Colour).init(std.heap.page_allocator);
        var x = 0; // i32
        while (x < w) {
            row = blk0: { var _tmp0 = std.ArrayList(Colour).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(row) catch |err| handleError(err); _tmp0.append(c) catch |err| handleError(err); break :blk0 _tmp0.items; };
            x = (x + 1);
        }
        rows = blk1: { var _tmp1 = std.ArrayList([]const Colour).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(rows) catch |err| handleError(err); _tmp1.append(row) catch |err| handleError(err); break :blk1 _tmp1.items; };
        y = (y + 1);
    }
    return Bitmap{
    .width = w,
    .height = h,
    .pixels = rows,
};
}

fn setPixel(b: *Bitmap, x: i32, y: i32, c: *Colour) void {
    var rows = b.pixels; // []const []const Colour
    var row = rows[y]; // []const Colour
    row.items[x] = c;
    rows.items[y] = row;
    b.pixels = rows;
}

fn fillRect(b: *Bitmap, x: i32, y: i32, w: i32, h: i32, c: *Colour) void {
    var yy = y; // i32
    while (yy < (y + h)) {
        var xx = x; // i32
        while (xx < (x + w)) {
            setPixel(&b, xx, yy, &c);
            xx = (xx + 1);
        }
        yy = (yy + 1);
    }
}

fn pad(n: i32, width: i32) []const u8 {
    var s = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err); // []const u8
    while ((s).len < width) {
        s = _concat_string(" ", s);
    }
    return s;
}

fn writePPMP3(b: *Bitmap) []const u8 {
    var maxv = 0; // i32
    var y = 0; // i32
    while (y < b.height) {
        var x = 0; // i32
        while (x < b.width) {
            const p = b.pixels[y][x]; // Colour
            if (p.R > maxv) {
                maxv = p.R;
            }
            if (p.G > maxv) {
                maxv = p.G;
            }
            if (p.B > maxv) {
                maxv = p.B;
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    var out = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("P3\n# generated from Bitmap.writeppmp3\n", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{b.width}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{b.height}) catch |err| handleError(err)), "\n"), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{maxv}) catch |err| handleError(err)), "\n"); // []const u8
    var numsize = (std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{maxv}) catch |err| handleError(err)).len; // i32
    y = (b.height - 1);
    while (y >= 0) {
        var line = ""; // []const u8
        var x = 0; // i32
        while (x < b.width) {
            const p = b.pixels[y][x]; // Colour
            line = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(line, "   "), pad(p.R, numsize)), " "), pad(p.G, numsize)), " "), pad(p.B, numsize));
            x = (x + 1);
        }
        out = _concat_string(out, line);
        if (y > 0) {
            out = _concat_string(out, "\n");
        } else {
            out = _concat_string(out, "\n");
        }
        y = (y - 1);
    }
    return out;
}

fn main() void {
    const black = Colour{
    .R = 0,
    .G = 0,
    .B = 0,
}; // Colour
    const white = Colour{
    .R = 255,
    .G = 255,
    .B = 255,
}; // Colour
    var bm = newBitmap(4, 4, &black); // Bitmap
    fillRect(&bm, 1, 0, 1, 2, &white);
    setPixel(&bm, 3, 3, &Colour{
    .R = 127,
    .G = 0,
    .B = 63,
});
    const ppm = writePPMP3(&bm); // []const u8
    std.debug.print("{s}\n", .{ppm});
}

pub fn main() void {
    main();
}
