// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn sqrtApprox(x: f64) f64 {
    var guess = x; // f64
    var i = 0; // i32
    while (i < 20) {
        guess = (((guess + (x / guess))) / 2.0);
        i = (i + 1);
    }
    return guess;
}

fn makeSym(order: i32, elements: []const f64) std.AutoHashMap([]const u8, i32) {
    return struct {
    order: i32,
    ele: []const f64,
}{
    .order = order,
    .ele = elements,
};
}

fn unpackSym(m: std.AutoHashMap([]const u8, i32)) []const []const f64 {
    const n: i32 = m["order"]; // i32
    const ele: i32 = m["ele"]; // i32
    var mat = std.ArrayList(f64).init(std.heap.page_allocator);
    var idx = 0; // i32
    var r = 0; // i32
    while (r < n) {
        var row = std.ArrayList(f64).init(std.heap.page_allocator);
        var c = 0; // i32
        while (c <= r) {
            row = blk0: { var _tmp0 = std.ArrayList(f64).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(row) catch |err| handleError(err); _tmp0.append(ele[idx]) catch |err| handleError(err); break :blk0 _tmp0.items; };
            idx = (idx + 1);
            c = (c + 1);
        }
        while (c < n) {
            row = blk1: { var _tmp1 = std.ArrayList(f64).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(row) catch |err| handleError(err); _tmp1.append(0.0) catch |err| handleError(err); break :blk1 _tmp1.items; };
            c = (c + 1);
        }
        mat = blk2: { var _tmp2 = std.ArrayList([]const f64).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(mat) catch |err| handleError(err); _tmp2.append(row) catch |err| handleError(err); break :blk2 _tmp2.items; };
        r = (r + 1);
    }
    r = 0;
    while (r < n) {
        var c = (r + 1); // i32
        while (c < n) {
            mat.items[r][c] = mat[c][r];
            c = (c + 1);
        }
        r = (r + 1);
    }
    return mat.items;
}

fn printMat(m: []const []const f64) void {
    var i = 0; // i32
    while (i < (m).len) {
        var line = ""; // []const u8
        var j = 0; // i32
        while (j < (m[i]).len) {
            line = _concat_string(line, std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{m[i][j]}) catch |err| handleError(err));
            if (j < ((m[i]).len - 1)) {
                line = _concat_string(line, " ");
            }
            j = (j + 1);
        }
        std.debug.print("{s}\n", .{line});
        i = (i + 1);
    }
}

fn printSym(m: std.AutoHashMap([]const u8, i32)) void {
    printMat(unpackSym(m));
}

fn printLower(m: std.AutoHashMap([]const u8, i32)) void {
    const n: i32 = m["order"]; // i32
    const ele: i32 = m["ele"]; // i32
    var mat = std.ArrayList(f64).init(std.heap.page_allocator);
    var idx = 0; // i32
    var r = 0; // i32
    while (r < n) {
        var row = std.ArrayList(f64).init(std.heap.page_allocator);
        var c = 0; // i32
        while (c <= r) {
            row = blk3: { var _tmp3 = std.ArrayList(f64).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(row) catch |err| handleError(err); _tmp3.append(ele[idx]) catch |err| handleError(err); break :blk3 _tmp3.items; };
            idx = (idx + 1);
            c = (c + 1);
        }
        while (c < n) {
            row = blk4: { var _tmp4 = std.ArrayList(f64).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(row) catch |err| handleError(err); _tmp4.append(0.0) catch |err| handleError(err); break :blk4 _tmp4.items; };
            c = (c + 1);
        }
        mat = blk5: { var _tmp5 = std.ArrayList([]const f64).init(std.heap.page_allocator); defer _tmp5.deinit(); _tmp5.appendSlice(mat) catch |err| handleError(err); _tmp5.append(row) catch |err| handleError(err); break :blk5 _tmp5.items; };
        r = (r + 1);
    }
    printMat(mat);
}

fn choleskyLower(a: std.AutoHashMap([]const u8, i32)) std.AutoHashMap([]const u8, i32) {
    const n: i32 = a["order"]; // i32
    const ae: i32 = a["ele"]; // i32
    var le = std.ArrayList(f64).init(std.heap.page_allocator);
    var idx = 0; // i32
    while (idx < (ae).len) {
        le = blk6: { var _tmp6 = std.ArrayList(f64).init(std.heap.page_allocator); defer _tmp6.deinit(); _tmp6.appendSlice(le) catch |err| handleError(err); _tmp6.append(0.0) catch |err| handleError(err); break :blk6 _tmp6.items; };
        idx = (idx + 1);
    }
    var row = 1; // i32
    var col = 1; // i32
    var dr = 0; // i32
    var dc = 0; // i32
    var i = 0; // i32
    while (i < (ae).len) {
        const e: i32 = ae[i]; // i32
        if (i < dr) {
            var d: i32 = (((e - le[i])) / le[dc]); // i32
            le.items[i] = d;
            var ci = col; // i32
            var cx = dc; // i32
            var j = (i + 1); // i32
            while (j <= dr) {
                cx = (cx + ci);
                ci = (ci + 1);
                le.items[j] = (le[j] + (d * le[cx]));
                j = (j + 1);
            }
            col = (col + 1);
            dc = (dc + col);
        } else {
            le.items[i] = sqrtApprox((e - le[i]));
            row = (row + 1);
            dr = (dr + row);
            col = 1;
            dc = 0;
        }
        i = (i + 1);
    }
    return struct {
    order: i32,
    ele: []const f64,
}{
    .order = n,
    .ele = le,
};
}

fn demo(a: std.AutoHashMap([]const u8, i32)) void {
    std.debug.print("A:\n", .{});
    printSym(a);
    std.debug.print("L:\n", .{});
    const l = choleskyLower(a); // std.StringHashMap(i32)
    printLower(l);
}

pub fn main() void {
    demo(makeSym(3, &[_]f64{
    25.0,
    15.0,
    18.0,
    -5.0,
    0.0,
    11.0,
}));
    demo(makeSym(4, &[_]f64{
    18.0,
    22.0,
    70.0,
    54.0,
    86.0,
    174.0,
    42.0,
    62.0,
    134.0,
    106.0,
}));
}
