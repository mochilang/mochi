// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const xMin = -2.182; // f64
const xMax = 2.6558; // f64
const yMin = 0.0; // f64
const yMax = 9.9983; // f64
const width = 60; // i32
const nIter = 10000; // i32
const dx = (xMax - xMin); // f64
const dy = (yMax - yMin); // f64
const height = @as(i32, (((width * dy) / dx))); // i32
var grid: []const []const []const u8 = &[]i32{};
var row = 0; // i32
var seed = 1; // i32
var x = 0.0; // f64
var y = 0.0; // f64
var ix = @as(i32, ((((@as(f64, width)) * ((x - xMin))) / dx))); // i32
var iy = @as(i32, ((((@as(f64, height)) * ((yMax - y))) / dy))); // i32
var i = 0; // i32

fn randInt(s: i32, n: i32) []const i32 {
    const next = @mod((((s * 1664525) + 1013904223)), 2147483647); // i32
    return [_]i32{
    next,
    @mod(next, n),
};
}

pub fn main() void {
    while (row < height) {
        var line = std.ArrayList(u8).init(std.heap.page_allocator);
        var col = 0; // i32
        while (col < width) {
            line = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(line) catch |err| handleError(err); _tmp0.append(" ") catch |err| handleError(err); break :blk0 _tmp0.items; };
            col = (col + 1);
        }
        grid = blk1: { var _tmp1 = std.ArrayList([]const []const u8).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(grid) catch |err| handleError(err); _tmp1.append(line) catch |err| handleError(err); break :blk1 _tmp1.items; };
        row = (row + 1);
    }
    if ((((ix >= 0) and (ix < width)) and (iy >= 0)) and (iy < height)) {
        grid.items[iy][ix] = "*";
    }
    while (i < nIter) {
        var res = randInt(seed, 100); // []const i32
        seed = res[0];
        const r = res[1]; // i32
        if (r < 85) {
            const nx = ((0.85 * x) + (0.04 * y)); // f64
            const ny = (((-0.04 * x) + (0.85 * y)) + 1.6); // f64
            x = nx;
            y = ny;
        } else         if (r < 92) {
            const nx = ((0.2 * x) - (0.26 * y)); // f64
            const ny = (((0.23 * x) + (0.22 * y)) + 1.6); // f64
            x = nx;
            y = ny;
        } else         if (r < 99) {
            const nx = ((-0.15 * x) + (0.28 * y)); // f64
            const ny = (((0.26 * x) + (0.24 * y)) + 0.44); // f64
            x = nx;
            y = ny;
        } else {
            x = 0.0;
            y = (0.16 * y);
        }
        ix = @as(i32, ((((@as(f64, width)) * ((x - xMin))) / dx)));
        iy = @as(i32, ((((@as(f64, height)) * ((yMax - y))) / dy)));
        if ((((ix >= 0) and (ix < width)) and (iy >= 0)) and (iy < height)) {
            grid.items[iy][ix] = "*";
        }
        i = (i + 1);
    }
    row = 0;
    while (row < height) {
        var line = ""; // []const u8
        var col = 0; // i32
        while (col < width) {
            line = _concat_string(line, grid[row][col]);
            col = (col + 1);
        }
        std.debug.print("{s}\n", .{line});
        row = (row + 1);
    }
}
