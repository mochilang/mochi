// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn fields(s: []const u8) []const []const u8 {
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    var cur = ""; // []const u8
    var i = 0; // i32
    while (i < (s).len) {
        const c = _slice_string(s, i, (i + 1), 1); // []const u8
        if (std.mem.eql(u8, c, " ")) {
            if ((cur).len > 0) {
                res = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(res) catch |err| handleError(err); _tmp0.append(cur) catch |err| handleError(err); break :blk0 _tmp0.items; };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, c);
        }
        i = (i + 1);
    }
    if ((cur).len > 0) {
        res = blk1: { var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(res) catch |err| handleError(err); _tmp1.append(cur) catch |err| handleError(err); break :blk1 _tmp1.items; };
    }
    return res.items;
}

fn canSpell(word: []const u8, blks: []const []const u8) bool {
    if ((word).len == 0) {
        return true;
    }
    const c = std.ascii.lowerString(_slice_string(word, 0, 1, 1)); // []const u8
    var i = 0; // i32
    while (i < (blks).len) {
        const b = blks[i]; // []const u8
        if (std.mem.eql(u8, c, std.ascii.lowerString(_slice_string(b, 0, 1, 1))) or std.mem.eql(u8, c, std.ascii.lowerString(_slice_string(b, 1, 2, 1)))) {
            var rest = std.ArrayList(u8).init(std.heap.page_allocator);
            var j = 0; // i32
            while (j < (blks).len) {
                if (j != i) {
                    rest = blk2: { var _tmp2 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(rest) catch |err| handleError(err); _tmp2.append(blks[j]) catch |err| handleError(err); break :blk2 _tmp2.items; };
                }
                j = (j + 1);
            }
            if (canSpell(_slice_string(word, 1, word.len, 1), rest)) {
                return true;
            }
        }
        i = (i + 1);
    }
    return false;
}

fn newSpeller(blocks: []const u8) fn([]const u8) bool {
    const bl = fields(blocks); // []const []const u8
    return (struct { bl: []const []const u8, fn call(self: @This(), w: []const u8) bool {
        return canSpell(w, self.bl);
} }{ .bl = bl }).call;
}

fn user_main() void {
    const sp: i32 = newSpeller("BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"); // i32
    for (&[_][]const u8{
    "A",
    "BARK",
    "BOOK",
    "TREAT",
    "COMMON",
    "SQUAD",
    "CONFUSE",
}) |word| {
        std.debug.print("{any}\n", .{_concat_string(_concat_string(word, " "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{sp(word)}) catch |err| handleError(err))});
    }
}

pub fn main() void {
    user_main();
}
