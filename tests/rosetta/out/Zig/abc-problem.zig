// Generated by Mochi compiler v0.10.30 on 2025-07-19T00:26:05Z
const std = @import("std");

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn fields(s: []const u8) []const []const u8 {
    var res: []u8 = &[_]u8{};
    var cur: []const u8 = ""; // []const u8
    var i: i32 = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        const c = _slice_string(s, i, (i + 1), 1); // []const u8
        if (std.mem.eql(u8, c, " ")) {
            if (@as(i32, @intCast((cur).len)) > 0) {
                res = blk0: {
                    var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator);
                    defer _tmp0.deinit();
                    _tmp0.appendSlice(res.items) catch |err| handleError(err);
                    _tmp0.append(cur) catch |err| handleError(err);
                    const res = _tmp0.toOwnedSlice() catch |err| handleError(err);
                    break :blk0 res;
                };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, c);
        }
        i = (i + 1);
    }
    if (@as(i32, @intCast((cur).len)) > 0) {
        res = blk1: {
            var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator);
            defer _tmp1.deinit();
            _tmp1.appendSlice(res.items) catch |err| handleError(err);
            _tmp1.append(cur) catch |err| handleError(err);
            const res = _tmp1.toOwnedSlice() catch |err| handleError(err);
            break :blk1 res;
        };
    }
    return res.items;
}

fn canSpell(word: []const u8, blks: []const []const u8) bool {
    if (@as(i32, @intCast((word).len)) == 0) {
        return true;
    }
    const c = std.ascii.lowerString(word[0..1]); // []const u8
    var i: i32 = 0; // i32
    while (i < @as(i32, @intCast((blks).len))) {
        const b = blks[i]; // []const u8
        if (std.mem.eql(u8, c, std.ascii.lowerString(b[0..1])) or std.mem.eql(u8, c, std.ascii.lowerString(b[1..2]))) {
            var rest: []u8 = &[_]u8{};
            var j: i32 = 0; // i32
            while (j < @as(i32, @intCast((blks).len))) {
                if (j != i) {
                    rest = blk2: {
                        var _tmp2 = std.ArrayList([]const u8).init(std.heap.page_allocator);
                        defer _tmp2.deinit();
                        _tmp2.appendSlice(rest.items) catch |err| handleError(err);
                        _tmp2.append(blks[j]) catch |err| handleError(err);
                        const res = _tmp2.toOwnedSlice() catch |err| handleError(err);
                        break :blk2 res;
                    };
                }
                j = (j + 1);
            }
            if (canSpell(word[1..word.len], rest)) {
                return true;
            }
        }
        i = (i + 1);
    }
    return false;
}

fn newSpeller(blocks: []const u8) fn ([]const u8) bool {
    const bl = fields(blocks); // []const []const u8
    return (blk: {
        const closure = struct {
            bl: []const []const u8,
        }{ .bl = bl };
        break :blk struct {
            fn inner(w: []const u8) bool {
                return canSpell(w, closure.bl);
            }
        }.inner;
    });
}

fn user_main() void {
    const sp: i32 = newSpeller("BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"); // i32
    for (&[_][]const u8{
        "A",
        "BARK",
        "BOOK",
        "TREAT",
        "COMMON",
        "SQUAD",
        "CONFUSE",
    }) |word| {
        std.debug.print("{s}\n", .{_concat_string(_concat_string(word, " "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{sp(word)}) catch |err| handleError(err))});
    }
}

pub fn main() void {
    user_main();
}
