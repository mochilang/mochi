// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const dna = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG", "CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG"), "AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT"), "GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT"), "CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG"), "TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"), "TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT"), "CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG"), "TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC"), "GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT"); // []const u8
const le = (dna).len; // i32
var i = 0; // i32
var a = 0; // i32
var c = 0; // i32
var g = 0; // i32
var t = 0; // i32
var idx = 0; // i32

fn padLeft(s: []const u8, w: i32) []const u8 {
    var res = ""; // []const u8
    var n = (w - (s).len); // i32
    while (n > 0) {
        res = _concat_string(res, " ");
        n = (n - 1);
    }
    return _concat_string(res, s);
}

pub fn main() void {
    std.debug.print("SEQUENCE:\n", .{});
    while (i < le) {
        var k = (i + 50); // i32
        if (k > le) {
            k = le;
        }
        std.debug.print("{s}\n", .{_concat_string(_concat_string(padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{i}) catch |err| handleError(err), 5), ": "), _slice_string(dna, i, k, 1))});
        i = (i + 50);
    }
    while (idx < le) {
        const ch = substring(dna, idx, (idx + 1)); // []const u8
        if (std.mem.eql(u8, ch, "A")) {
            a = (a + 1);
        } else {
            if (std.mem.eql(u8, ch, "C")) {
                c = (c + 1);
            } else {
                if (std.mem.eql(u8, ch, "G")) {
                    g = (g + 1);
                } else {
                    if (std.mem.eql(u8, ch, "T")) {
                        t = (t + 1);
                    }
                }
            }
        }
        idx = (idx + 1);
    }
    std.debug.print("\n", .{});
    std.debug.print("BASE COUNT:\n", .{});
    std.debug.print("{s}\n", .{_concat_string("    A: ", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{a}) catch |err| handleError(err), 3))});
    std.debug.print("{s}\n", .{_concat_string("    C: ", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{c}) catch |err| handleError(err), 3))});
    std.debug.print("{s}\n", .{_concat_string("    G: ", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{g}) catch |err| handleError(err), 3))});
    std.debug.print("{s}\n", .{_concat_string("    T: ", padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{t}) catch |err| handleError(err), 3))});
    std.debug.print("    ------\n", .{});
    std.debug.print("{s}\n", .{_concat_string("    Î£: ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{le}) catch |err| handleError(err))});
    std.debug.print("    ======\n", .{});
}
