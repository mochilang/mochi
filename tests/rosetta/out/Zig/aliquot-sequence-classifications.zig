// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:59Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const THRESHOLD = 140737488355328; // i32

fn indexOf(xs: []const i32, value: i32) i32 {
    var i = 0; // i32
    while (i < @as(i32, @intCast((xs).len))) {
        if (xs[i] == value) {
            return i;
        }
        i = (i + 1);
    }
    return (0 - 1);
}

fn contains(xs: []const i32, value: i32) bool {
    return (indexOf(xs, value) != (0 - 1));
}

fn maxOf(a: i32, b: i32) i32 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}

fn intSqrt(n: i32) i32 {
    if (n == 0) {
        return 0;
    }
    var x = n; // i32
    var y = (((x + 1)) / 2); // f64
    while (y < x) {
        x = y;
        y = (((x + (n / x))) / 2);
    }
    return x;
}

fn sumProperDivisors(n: i32) i32 {
    if (n < 2) {
        return 0;
    }
    const sqrt = intSqrt(n); // i32
    var sum = 1; // i32
    var i = 2; // i32
    while (i <= sqrt) {
        if (@mod(n, i) == 0) {
            sum = ((sum + i) + (n / i));
        }
        i = (i + 1);
    }
    if ((sqrt * sqrt) == n) {
        sum = (sum - sqrt);
    }
    return sum;
}

fn classifySequence(k: i32) std.AutoHashMap([]const u8, i32) {
    var last = k; // i32
    var seq: []const i32 = &[_]i32{k}; // []const i32
    while (true) {
        last = sumProperDivisors(last);
        seq = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(seq) catch |err| handleError(err); _tmp0.append(last) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
        const n = @as(i32, @intCast((seq).len)); // i32
        var aliquot = ""; // []const u8
        if (last == 0) {
            aliquot = "Terminating";
        } else         if ((n == 2) and (last == k)) {
            aliquot = "Perfect";
        } else         if ((n == 3) and (last == k)) {
            aliquot = "Amicable";
        } else         if ((n >= 4) and (last == k)) {
            aliquot = _concat_string(_concat_string("Sociable[", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{(n - 1)}) catch |err| handleError(err)), "]");
        } else         if (last == seq[(n - 2)]) {
            aliquot = "Aspiring";
        } else         if (contains(seq[1..@as(usize, @intCast(maxOf(1, (n - 2))))], last)) {
            const idx: i32 = indexOf(seq, last); // i32
            aliquot = _concat_string(_concat_string("Cyclic[", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{((n - 1) - idx)}) catch |err| handleError(err)), "]");
        } else         if ((n == 16) or (last > THRESHOLD)) {
            aliquot = "Non-Terminating";
        }
        if (!std.mem.eql(u8, aliquot, "")) {
            return struct {
    seq: []const i32,
    aliquot: []const u8,
}{
    .seq = seq,
    .aliquot = aliquot,
};
        }
    }
    return struct {
    seq: []const i32,
    aliquot: []const u8,
}{
    .seq = seq,
    .aliquot = "",
};
}

fn padLeft(n: i32, w: i32) []const u8 {
    var s = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err); // []const u8
    while (@as(i32, @intCast((s).len)) < w) {
        s = _concat_string(" ", s);
    }
    return s;
}

fn padRight(s: []const u8, w: i32) []const u8 {
    var r = s; // []const u8
    while (@as(i32, @intCast((r).len)) < w) {
        r = _concat_string(r, " ");
    }
    return r;
}

fn joinWithCommas(seq: []const i32) []const u8 {
    var s = "["; // []const u8
    var i = 0; // i32
    while (i < @as(i32, @intCast((seq).len))) {
        s = _concat_string(s, std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{seq[i]}) catch |err| handleError(err));
        if (i < (@as(i32, @intCast((seq).len)) - 1)) {
            s = _concat_string(s, ", ");
        }
        i = (i + 1);
    }
    s = _concat_string(s, "]");
    return s;
}

fn user_main() void {
    std.debug.print("Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n\n", .{});
    var k = 1; // i32
    while (k <= 10) {
        const res = classifySequence(k); // std.StringHashMap(i32)
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(padLeft(k, 2), ": "), padRight(@as([]const u8, res["aliquot"]), 15)), " "), joinWithCommas(@as([]const i32, res["seq"])))});
        k = (k + 1);
    }
    std.debug.print("\n", .{});
    const s = &[_]i32{
    11,
    12,
    28,
    496,
    220,
    1184,
    12496,
    1264460,
    790,
    909,
    562,
    1064,
    1488,
}; // []const i32
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        const val = s[i]; // i32
        const res = classifySequence(val); // std.StringHashMap(i32)
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(padLeft(val, 7), ": "), padRight(@as([]const u8, res["aliquot"]), 15)), " "), joinWithCommas(@as([]const i32, res["seq"])))});
        i = (i + 1);
    }
    std.debug.print("\n", .{});
    const big = 15355717786080; // i32
    const r = classifySequence(big); // std.StringHashMap(i32)
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{big}) catch |err| handleError(err), ": "), padRight(@as([]const u8, r["aliquot"]), 15)), " "), joinWithCommas(@as([]const i32, r["seq"])))});
}

pub fn main() void {
    user_main();
}
