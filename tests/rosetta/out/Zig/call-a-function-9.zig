// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:22Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn f() []const i32 {
    return [_]i32{
    0,
    0.0,
};
}

fn g(a: i32, b: f64) i32 {
    return 0;
}

fn h(s: []const u8, nums: []const i32) void {
}

fn user_main() void {
    const ab = f(); // []const i32
    const a: i32 = ab[0]; // i32
    const b: i32 = ab[1]; // i32
    const cb: i32 = f()[1]; // i32
    const d = g(a, cb); // i32
    const e = g(d, b); // i32
    var i = g(d, 2.0); // i32
    var list = std.ArrayList(i32).init(std.heap.page_allocator);
    list = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(list) catch |err| handleError(err); _tmp0.append(a) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
    list = blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(list) catch |err| handleError(err); _tmp1.append(d) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
    list = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(list) catch |err| handleError(err); _tmp2.append(e) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
    list = blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(list) catch |err| handleError(err); _tmp3.append(i) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
    i = @as(i32, @intCast((list).len));
}

pub fn main() void {
    user_main();
}
