// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_list(comptime T: type, v: []const T, start: i32, end: i32, step: i32) []T {
    var s = start;
    var e = end;
    var st = step;
    const n: i32 = @as(i32, @intCast(v.len));
    if (s < 0) s += n;
    if (e < 0) e += n;
    if (st == 0) st = 1;
    if (s < 0) s = 0;
    if (e > n) e = n;
    if (st > 0 and e < s) e = s;
    if (st < 0 and e > s) e = s;
    var res = std.ArrayList(T).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = s;
    while ((st > 0 and i < e) or (st < 0 and i > e)) : (i += st) {
        res.append(v[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn qsel(a: []const f64, k: i32) f64 {
    var arr = a; // []const f64
    while ((arr).len > 1) {
        var px = @mod(std.time.nanoTimestamp(), (arr).len); // i64
        var pv = arr[px]; // f64
        const last = ((arr).len - 1); // i32
        const tmp = arr[px]; // f64
        arr.items[px] = arr[last];
        arr.items[last] = tmp;
        px = 0;
        var i = 0; // i32
        while (i < last) {
            const v = arr[i]; // f64
            if (v < pv) {
                const tmp2 = arr[px]; // f64
                arr.items[px] = arr[i];
                arr.items[i] = tmp2;
                px = (px + 1);
            }
            i = (i + 1);
        }
        if (px == k) {
            return pv;
        }
        if (k < px) {
            arr = _slice_list(f64, arr, 0, px, 1);
        } else {
            const tmp2 = arr[px]; // f64
            arr.items[px] = pv;
            arr.items[last] = tmp2;
            arr = _slice_list(f64, arr, ((px + 1)), arr.len, 1);
            k = (k - ((px + 1)));
        }
    }
    return arr.items[0];
}

fn median(list: []const f64) f64 {
    var arr = list; // []const f64
    const half = @as(i32, (((arr).len / 2))); // i32
    const med = qsel(arr, half); // f64
    if (@mod((arr).len, 2) == 0) {
        return (((med + qsel(arr, (half - 1)))) / 2.0);
    }
    return med;
}

pub fn main() void {
    std.debug.print("{s}\n", .{std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{median(&[_]f64{
    3.0,
    1.0,
    4.0,
    1.0,
})}) catch |err| handleError(err)});
    std.debug.print("{s}\n", .{std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{median(&[_]f64{
    3.0,
    1.0,
    4.0,
    1.0,
    5.0,
})}) catch |err| handleError(err)});
}
