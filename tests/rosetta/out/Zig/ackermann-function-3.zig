// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

var err = ""; // []const u8

fn pow_big(base: i32, exp: i32) i32 {
    var result: i32 = 1; // i32
    var b: i32 = base; // i32
    var e = exp; // i32
    while (e > 0) {
        if (@mod(e, 2) == 1) {
            result = (result * b);
        }
        b = (b * b);
        e = @as(i32, ((e / 2)));
    }
    return result;
}

fn bit_len(x: i32) i32 {
    var n: i32 = x; // i32
    var c = 0; // i32
    while (n > 0) {
        n = (n / 2);
        c = (c + 1);
    }
    return c;
}

fn ackermann2(m: i32, n: i32) i32 {
    if (!std.mem.eql(u8, err, "")) {
        return @as(i32, 0);
    }
    if (m <= 3) {
        const mi = int(m); // i32
        if (mi == 0) {
            return (n + 1);
        }
        if (mi == 1) {
            return (n + 2);
        }
        if (mi == 2) {
            return ((2 * n) + 3);
        }
        if (mi == 3) {
            const nb = bit_len(n); // i32
            if (nb > 64) {
                err = _concat_string(_concat_string("A(m,n) had n of ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{nb}) catch |err| handleError(err)), " bits; too large");
                return @as(i32, 0);
            }
            const r: i32 = pow_big(@as(i32, 2), int(n)); // i32
            return ((8 * r) - 3);
        }
    }
    if (bit_len(n) == 0) {
        return ackermann2((m - (@as(i32, 1))), @as(i32, 1));
    }
    return ackermann2((m - (@as(i32, 1))), ackermann2(m, (n - (@as(i32, 1)))));
}

fn show(m: i32, n: i32) void {
    err = "";
    const res: i32 = ackermann2(@as(i32, m), @as(i32, n)); // i32
    if (!std.mem.eql(u8, err, "")) {
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("A(", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{m}) catch |err| handleError(err)), ", "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err)), ") = Error: "), err)});
        return ;
    }
    if (bit_len(res) <= 256) {
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("A(", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{m}) catch |err| handleError(err)), ", "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err)), ") = "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{res}) catch |err| handleError(err))});
    } else {
        const s = std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{res}) catch |err| handleError(err); // []const u8
        const pre = substring(s, 0, 20); // []const u8
        const suf: i32 = substring(s, ((s).len - 20), (s).len); // i32
        std.debug.print("{any}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("A(", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{m}) catch |err| handleError(err)), ", "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err)), ") = "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{(s).len}) catch |err| handleError(err)), " digits starting/ending with: "), pre), "..."), suf)});
    }
}

fn user_main() void {
    show(0, 0);
    show(1, 2);
    show(2, 4);
    show(3, 100);
    show(3, 1000000);
    show(4, 1);
    show(4, 2);
    show(4, 3);
}

pub fn main() void {
    user_main();
}
