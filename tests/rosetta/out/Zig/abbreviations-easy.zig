// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn _join_strings(parts: []const []const u8, sep: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.join(u8, sep, parts, alloc) catch |err| handleError(err);
}

fn fields(s: []const u8) []const []const u8 {
    var words = std.ArrayList(u8).init(std.heap.page_allocator);
    var cur = ""; // []const u8
    var i = 0; // i32
    while (i < (s).len) {
        const ch: i32 = substring(s, i, (i + 1)); // i32
        if ((std.mem.eql(u8, ch, " ") or std.mem.eql(u8, ch, "\n")) or std.mem.eql(u8, ch, "\t")) {
            if ((cur).len > 0) {
                words = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(words) catch |err| handleError(err); _tmp0.append(cur) catch |err| handleError(err); break :blk0 _tmp0.items; };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, ch);
        }
        i = (i + 1);
    }
    if ((cur).len > 0) {
        words = blk1: { var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(words) catch |err| handleError(err); _tmp1.append(cur) catch |err| handleError(err); break :blk1 _tmp1.items; };
    }
    return words.items;
}

fn padRight(s: []const u8, width: i32) []const u8 {
    var out = s; // []const u8
    var i = (s).len; // i32
    while (i < width) {
        out = _concat_string(out, " ");
        i = (i + 1);
    }
    return out;
}

fn join(xs: []const []const u8, sep: []const u8) []const u8 {
    var res = ""; // []const u8
    var i = 0; // i32
    while (i < (xs).len) {
        if (i > 0) {
            res = _concat_string(res, sep);
        }
        res = _concat_string(res, xs[i]);
        i = (i + 1);
    }
    return res;
}

fn validate(commands: []const []const u8, words: []const []const u8, mins: []const i32) []const []const u8 {
    var results = std.ArrayList(u8).init(std.heap.page_allocator);
    if ((words).len == 0) {
        return results.items;
    }
    var wi = 0; // i32
    while (wi < (words).len) {
        const w = words[wi]; // []const u8
        var found = false; // bool
        const wlen = (w).len; // i32
        var ci = 0; // i32
        while (ci < (commands).len) {
            const cmd = commands[ci]; // []const u8
            if (((mins[ci] != 0) and (wlen >= mins[ci])) and (wlen <= (cmd).len)) {
                const c = upper(cmd); // []const u8
                const ww = upper(w); // []const u8
                if (std.mem.eql(u8, substring(c, 0, wlen), ww)) {
                    results = blk2: { var _tmp2 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(results) catch |err| handleError(err); _tmp2.append(c) catch |err| handleError(err); break :blk2 _tmp2.items; };
                    found = true;
                    break;
                }
            }
            ci = (ci + 1);
        }
        if (!found) {
            results = blk3: { var _tmp3 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(results) catch |err| handleError(err); _tmp3.append("*error*") catch |err| handleError(err); break :blk3 _tmp3.items; };
        }
        wi = (wi + 1);
    }
    return results.items;
}

fn user_main() void {
    const table = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ", "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "), " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "), "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "), "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "), "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "); // []const u8
    const commands = fields(table); // []const []const u8
    var mins = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < (commands).len) {
        var count = 0; // i32
        var j = 0; // i32
        const cmd = commands[i]; // []const u8
        while (j < (cmd).len) {
            const ch: i32 = substring(cmd, j, (j + 1)); // i32
            if (std.mem.order(u8, ch, "A") != .lt and std.mem.order(u8, ch, "Z") != .gt) {
                count = (count + 1);
            }
            j = (j + 1);
        }
        mins = blk4: { var _tmp4 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(mins) catch |err| handleError(err); _tmp4.append(count) catch |err| handleError(err); break :blk4 _tmp4.items; };
        i = (i + 1);
    }
    const sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"; // []const u8
    const words = fields(sentence); // []const []const u8
    const results = validate(commands, words, mins); // []const []const u8
    var out1 = "user words:  "; // []const u8
    var k = 0; // i32
    while (k < (words).len) {
        out1 = _concat_string(_concat_string(out1, padRight(words[k], (results[k]).len)), " ");
        k = (k + 1);
    }
    std.debug.print("{s}\n", .{out1});
    std.debug.print("{s}\n", .{_concat_string("full words:  ", _join_strings(results, " "))});
}

pub fn main() void {
    user_main();
}
