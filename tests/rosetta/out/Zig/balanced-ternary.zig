// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:14Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn trimLeftZeros(s: []const u8) []const u8 {
    var i = 0; // i32
    while ((i < @as(i32, @intCast((s).len))) and std.mem.eql(u8, _slice_string(s, i, (i + 1), 1), "0")) {
        i = (i + 1);
    }
    return _slice_string(s, i, @as(i32, @intCast((s).len)), 1);
}

fn btString(s: []const u8) std.AutoHashMap([]const u8, i32) {
    s = trimLeftZeros(s);
    var b = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = (@as(i32, @intCast((s).len)) - 1); // i32
    while (i >= 0) {
        const ch = _slice_string(s, i, (i + 1), 1); // []const u8
        if (std.mem.eql(u8, ch, "+")) {
            b = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(b) catch |err| handleError(err); _tmp0.append(1) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
        } else {
            if (std.mem.eql(u8, ch, "0")) {
                b = blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(b) catch |err| handleError(err); _tmp1.append(0) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
            } else {
                if (std.mem.eql(u8, ch, "-")) {
                    b = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(b) catch |err| handleError(err); _tmp2.append((0 - 1)) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
                } else {
                    return struct {
    bt: []const i32,
    ok: bool,
}{
    .bt = &[]i32{},
    .ok = false,
};
                }
            }
        }
        i = (i - 1);
    }
    return struct {
    bt: []const i32,
    ok: bool,
}{
    .bt = b,
    .ok = true,
};
}

fn btToString(b: []const i32) []const u8 {
    if (@as(i32, @intCast((b).len)) == 0) {
        return "0";
    }
    var r = ""; // []const u8
    var i = (@as(i32, @intCast((b).len)) - 1); // i32
    while (i >= 0) {
        const d = b[i]; // i32
        if (d == (0 - 1)) {
            r = _concat_string(r, "-");
        } else {
            if (d == 0) {
                r = _concat_string(r, "0");
            } else {
                r = _concat_string(r, "+");
            }
        }
        i = (i - 1);
    }
    return r;
}

fn btInt(i: i32) []const i32 {
    if (i == 0) {
        return []i32{};
    }
    var n = i; // i32
    var b = std.ArrayList(i32).init(std.heap.page_allocator);
    while (n != 0) {
        var m = @mod(n, 3); // i32
        n = @as(i32, ((n / 3)));
        if (m == 2) {
            m = (0 - 1);
            n = (n + 1);
        } else {
            if (m == (0 - 2)) {
                m = 1;
                n = (n - 1);
            }
        }
        b = blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(b) catch |err| handleError(err); _tmp3.append(m) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
    }
    return b.items;
}

fn btToInt(b: []const i32) i32 {
    var r = 0; // i32
    var pt = 1; // i32
    var i = 0; // i32
    while (i < @as(i32, @intCast((b).len))) {
        r = (r + (b[i] * pt));
        pt = (pt * 3);
        i = (i + 1);
    }
    return r;
}

fn btNeg(b: []const i32) []const i32 {
    var r = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < @as(i32, @intCast((b).len))) {
        r = blk4: { var _tmp4 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(r) catch |err| handleError(err); _tmp4.append(-b[i]) catch |err| handleError(err); const res = _tmp4.toOwnedSlice() catch |err| handleError(err); break :blk4 res; };
        i = (i + 1);
    }
    return r.items;
}

fn btAdd(a: []const i32, b: []const i32) []const i32 {
    return btInt((btToInt(a) + btToInt(b)));
}

fn btMul(a: []const i32, b: []const i32) []const i32 {
    return btInt((btToInt(a) * btToInt(b)));
}

fn padLeft(s: []const u8, w: i32) []const u8 {
    var r = s; // []const u8
    while (@as(i32, @intCast((r).len)) < w) {
        r = _concat_string(" ", r);
    }
    return r;
}

fn show(label: []const u8, b: []const i32) void {
    const l = padLeft(label, 7); // []const u8
    const bs = padLeft(btToString(b), 12); // []const u8
    const is = padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{btToInt(b)}) catch |err| handleError(err), 7); // []const u8
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(l, " "), bs), " "), is)});
}

fn user_main() void {
    const ares = btString("+-0++0+"); // std.StringHashMap(i32)
    const a: i32 = ares["bt"]; // i32
    const b = btInt(-436); // []const i32
    const cres = btString("+-++-"); // std.StringHashMap(i32)
    const c: i32 = cres["bt"]; // i32
    show("a:", a);
    show("b:", b);
    show("c:", c);
    show("a(b-c):", btMul(a, btAdd(b, btNeg(c))));
}

pub fn main() void {
    user_main();
}
