// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const Pixel = struct {
    R: i32,
    G: i32,
    B: i32,
};

const Bitmap = struct {
    cols: i32,
    rows: i32,
    px: []const []const Pixel,
};

fn pixelFromRgb(c: i32) Pixel {
    const r = @mod((@as(i32, ((c / 65536)))), 256); // i32
    const g = @mod((@as(i32, ((c / 256)))), 256); // i32
    const b = @mod(c, 256); // i32
    return Pixel{
    .R = r,
    .G = g,
    .B = b,
};
}

fn rgbFromPixel(p: *Pixel) i32 {
    return (((p.R * 65536) + (p.G * 256)) + p.B);
}

fn NewBitmap(x: i32, y: i32) Bitmap {
    var data = std.ArrayList(Pixel).init(std.heap.page_allocator);
    var row = 0; // i32
    while (row < y) {
        var r = std.ArrayList(Pixel).init(std.heap.page_allocator);
        var col = 0; // i32
        while (col < x) {
            r = blk0: { var _tmp0 = std.ArrayList(Pixel).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(r) catch |err| handleError(err); _tmp0.append(Pixel{
    .R = 0,
    .G = 0,
    .B = 0,
}) catch |err| handleError(err); break :blk0 _tmp0.items; };
            col = (col + 1);
        }
        data = blk1: { var _tmp1 = std.ArrayList([]const Pixel).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(data) catch |err| handleError(err); _tmp1.append(r) catch |err| handleError(err); break :blk1 _tmp1.items; };
        row = (row + 1);
    }
    return Bitmap{
    .cols = x,
    .rows = y,
    .px = data,
};
}

fn FillRgb(b: *Bitmap, c: i32) void {
    var y = 0; // i32
    const p = pixelFromRgb(c); // Pixel
    while (y < b.rows) {
        var x = 0; // i32
        while (x < b.cols) {
            var px = b.px; // []const []const Pixel
            var row = px[y]; // []const Pixel
            row.items[x] = p;
            px.items[y] = row;
            b.px = px;
            x = (x + 1);
        }
        y = (y + 1);
    }
}

fn SetPxRgb(b: *Bitmap, x: i32, y: i32, c: i32) bool {
    if ((((x < 0) or (x >= b.cols)) or (y < 0)) or (y >= b.rows)) {
        return false;
    }
    var px = b.px; // []const []const Pixel
    var row = px[y]; // []const Pixel
    row.items[x] = pixelFromRgb(c);
    px.items[y] = row;
    b.px = px;
    return true;
}

fn nextRand(seed: i32) i32 {
    return @mod((((seed * 1664525) + 1013904223)), 2147483648);
}

fn main() void {
    var bm = NewBitmap(400, 300); // Bitmap
    FillRgb(&bm, 12615744);
    var seed = std.time.nanoTimestamp(); // i64
    var i = 0; // i32
    while (i < 2000) {
        seed = nextRand(seed);
        const x = @mod(seed, 400); // i64
        seed = nextRand(seed);
        const y = @mod(seed, 300); // i64
        SetPxRgb(&bm, x, y, 8405024);
        i = (i + 1);
    }
    var x = 0; // i32
    while (x < 400) {
        var y = 240; // i32
        while (y < 245) {
            SetPxRgb(&bm, x, y, 8405024);
            y = (y + 1);
        }
        y = 260;
        while (y < 265) {
            SetPxRgb(&bm, x, y, 8405024);
            y = (y + 1);
        }
        x = (x + 1);
    }
    var y = 0; // i32
    while (y < 300) {
        var x = 80; // i32
        while (x < 85) {
            SetPxRgb(&bm, x, y, 8405024);
            x = (x + 1);
        }
        x = 95;
        while (x < 100) {
            SetPxRgb(&bm, x, y, 8405024);
            x = (x + 1);
        }
        y = (y + 1);
    }
}

pub fn main() void {
    main();
}
