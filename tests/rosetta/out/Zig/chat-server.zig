// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn removeName(names: []const []const u8, name: []const u8) []const []const u8 {
    var out = std.ArrayList(u8).init(std.heap.page_allocator);
    for (names) |n| {
        if (!std.mem.eql(u8, n, name)) {
            out = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(out) catch |err| handleError(err); _tmp0.append(n) catch |err| handleError(err); break :blk0 _tmp0.items; };
        }
    }
    return out.items;
}

fn main() void {
    var clients = std.ArrayList(u8).init(std.heap.page_allocator);
    const broadcast = fn (msg: []const u8) i32 {
        std.debug.print("{s}\n", .{msg});
};
    const add = (struct { clients: []const []const u8, fn call(self: @This(), name: []const u8) i32 {
        clients = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(self.clients) catch |err| handleError(err); _tmp0.append(name) catch |err| handleError(err); break :blk0 _tmp0.items; };
        broadcast(_concat_string(_concat_string("+++ \"", name), "\" connected +++\n"));
} }{ .clients = clients }).call;
    const send = fn (name: []const u8, msg: []const u8) i32 {
        broadcast(_concat_string(_concat_string(_concat_string(name, "> "), msg), "\n"));
};
    const remove = (struct { clients: []const []const u8, fn call(self: @This(), name: []const u8) i32 {
        clients = removeName(self.clients, name);
        broadcast(_concat_string(_concat_string("--- \"", name), "\" disconnected ---\n"));
} }{ .clients = clients }).call;
    add("Alice");
    add("Bob");
    send("Alice", "Hello Bob!");
    send("Bob", "Hi Alice!");
    remove("Bob");
    remove("Alice");
    broadcast("Server stopping!\n");
}

pub fn main() void {
    main();
}
