// Generated by Mochi compiler v0.10.30 on 2025-07-19T00:25:47Z
const std = @import("std");

fn _input() []const u8 {
    var buf = std.ArrayList(u8).init(std.heap.page_allocator);
    defer buf.deinit();
    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(&buf, '
') catch return "";
    return std.mem.trim(u8, buf.items, "
");
}

fn _int(v: anytype) i32 {
    return switch (@TypeOf(v)) {
        i32 => v,
        f64 => @as(i32, @intFromFloat(v)),
        bool => @intFromBool(v),
        []const u8 => std.fmt.parseInt(i32, v, 10) catch 0,
        else => 0,
    };
}

fn _slice_list(comptime T: type, v: []const T, start: i32, end: i32, step: i32) []T {
    var s = start;
    var e = end;
    var st = step;
    const n: i32 = @as(i32, @intCast(v.len));
    if (s < 0) s += n;
    if (e < 0) e += n;
    if (st == 0) st = 1;
    if (s < 0) s = 0;
    if (e > n) e = n;
    if (st > 0 and e < s) e = s;
    if (st < 0 and e > s) e = s;
    var res = std.ArrayList(T).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = s;
    while ((st > 0 and i < e) or (st < 0 and i > e)) : (i += st) {
        res.append(v[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn randDigit() i32 {
    return ((@mod(std.time.nanoTimestamp(), 9)) + 1);
}

fn user_main() void {
    var digits: []i32 = &[_]i32{};
    for (0 .. 4) |_| {
        digits = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(digits.items) catch |err| handleError(err); _tmp0.append(randDigit()) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
    }
    var numstr: []const u8 = ""; // []const u8
    for (0 .. 4) |i| {
        numstr = _concat_string(numstr, std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{digits[i]}) catch |err| handleError(err));
    }
    std.debug.print("{s}\n", .{_concat_string(_concat_string("Your numbers: ", numstr), "\n")});
    std.debug.print("Enter RPN: \n", .{});
    var expr: []const u8 = _input(); // []const u8
    if (@as(i32, @intCast((expr).len)) != 7) {
        std.debug.print("invalid. expression length must be 7. (4 numbers, 3 operators, no spaces)\n", .{});
        return ;
    }
    var stack: []i32 = &[_]i32{};
    var i: i32 = 0; // i32
    var valid: bool = true; // bool
    while (i < @as(i32, @intCast((expr).len))) {
        const ch = _slice_string(expr, i, (i + 1), 1); // []const u8
        if (std.mem.order(u8, ch, "0") != .lt and std.mem.order(u8, ch, "9") != .gt) {
            if (@as(i32, @intCast((digits).len)) == 0) {
                std.debug.print("too many numbers.\n", .{});
                return ;
            }
            var j: i32 = 0; // i32
            while (digits[j] != (_int(ch) - _int("0"))) {
                j = (j + 1);
                if (j == @as(i32, @intCast((digits).len))) {
                    std.debug.print("wrong numbers.\n", .{});
                    return ;
                }
            }
            digits = (_slice_list(i32, digits, 0, j, 1) + _slice_list(i32, digits, (j + 1), digits.len, 1));
            stack = blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(stack.items) catch |err| handleError(err); _tmp1.append(float((_int(ch) - _int("0")))) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
        } else {
            if (@as(i32, @intCast((stack).len)) < 2) {
                std.debug.print("invalid expression syntax.\n", .{});
                valid = false;
                break;
            }
            var b: i32 = stack[(@as(i32, @intCast((stack).len)) - 1)]; // i32
            var a: i32 = stack[(@as(i32, @intCast((stack).len)) - 2)]; // i32
            if (std.mem.eql(u8, ch, "+")) {
                stack.items[(@as(i32, @intCast((stack).len)) - 2)] = (a + b);
            } else             if (std.mem.eql(u8, ch, "-")) {
                stack.items[(@as(i32, @intCast((stack).len)) - 2)] = (a - b);
            } else             if (std.mem.eql(u8, ch, "*")) {
                stack.items[(@as(i32, @intCast((stack).len)) - 2)] = (a * b);
            } else             if (std.mem.eql(u8, ch, "/")) {
                stack.items[(@as(i32, @intCast((stack).len)) - 2)] = (a / b);
            } else {
                std.debug.print("{s}\n", .{_concat_string(ch, " invalid.")});
                valid = false;
                break;
            }
            stack = _slice_list(i32, stack, 0, (@as(i32, @intCast((stack).len)) - 1), 1);
        }
        i = (i + 1);
    }
    if (valid) {
        if (std.math.abs((stack[0] - 24.0)) > 0.000001) {
            std.debug.print("{s}\n", .{_concat_string(_concat_string("incorrect. ", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{stack[0]}) catch |err| handleError(err)), " != 24")});
        } else {
            std.debug.print("correct.\n", .{});
        }
    }
}

pub fn main() void {
    user_main();
}
