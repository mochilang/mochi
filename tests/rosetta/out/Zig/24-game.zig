// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:03:05Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_list(comptime T: type, v: []const T, start: i32, end: i32, step: i32) []T {
    var s = start;
    var e = end;
    var st = step;
    const n: i32 = @as(i32, @intCast(v.len));
    if (s < 0) s += n;
    if (e < 0) e += n;
    if (st == 0) st = 1;
    if (s < 0) s = 0;
    if (e > n) e = n;
    if (st > 0 and e < s) e = s;
    if (st < 0 and e > s) e = s;
    var res = std.ArrayList(T).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = s;
    while ((st > 0 and i < e) or (st < 0 and i > e)) : (i += st) {
        res.append(v[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn randDigit() i32 {
    return ((@mod(std.time.nanoTimestamp(), 9)) + 1);
}

fn user_main() void {
    var digits = std.ArrayList(i32).init(std.heap.page_allocator);
    for (0..4) |i| {
        digits = blk0: {
            var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator);
            defer _tmp0.deinit();
            _tmp0.appendSlice(digits) catch |err| handleError(err);
            _tmp0.append(randDigit()) catch |err| handleError(err);
            const res = _tmp0.toOwnedSlice() catch |err| handleError(err);
            break :blk0 res;
        };
    }
    var numstr = ""; // []const u8
    for (0..4) |i| {
        numstr = _concat_string(numstr, std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{digits[i]}) catch |err| handleError(err));
    }
    std.debug.print("{s}\n", .{_concat_string(_concat_string("Your numbers: ", numstr), "\n")});
    std.debug.print("Enter RPN: \n", .{});
    var expr = input(); // []const u8
    if (@as(i32, @intCast((expr).len)) != 7) {
        std.debug.print("invalid. expression length must be 7. (4 numbers, 3 operators, no spaces)\n", .{});
        return;
    }
    var stack = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    var valid = true; // bool
    while (i < @as(i32, @intCast((expr).len))) {
        const ch = _slice_string(expr, i, (i + 1), 1); // []const u8
        if (std.mem.order(u8, ch, "0") != .lt and std.mem.order(u8, ch, "9") != .gt) {
            if (@as(i32, @intCast((digits).len)) == 0) {
                std.debug.print("too many numbers.\n", .{});
                return;
            }
            var j = 0; // i32
            while (digits[j] != (int(ch) - int("0"))) {
                j = (j + 1);
                if (j == @as(i32, @intCast((digits).len))) {
                    std.debug.print("wrong numbers.\n", .{});
                    return;
                }
            }
            digits = (_slice_list(i32, digits, 0, j, 1) + _slice_list(i32, digits, (j + 1), digits.len, 1));
            stack = blk1: {
                var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator);
                defer _tmp1.deinit();
                _tmp1.appendSlice(stack) catch |err| handleError(err);
                _tmp1.append(float((int(ch) - int("0")))) catch |err| handleError(err);
                const res = _tmp1.toOwnedSlice() catch |err| handleError(err);
                break :blk1 res;
            };
        } else {
            if (@as(i32, @intCast((stack).len)) < 2) {
                std.debug.print("invalid expression syntax.\n", .{});
                valid = false;
                break;
            }
            var b: i32 = stack[(@as(i32, @intCast((stack).len)) - 1)]; // i32
            var a: i32 = stack[(@as(i32, @intCast((stack).len)) - 2)]; // i32
            if (std.mem.eql(u8, ch, "+")) {
                stack.items[(@as(i32, @intCast((stack).len)) - 2)] = (a + b);
            } else if (std.mem.eql(u8, ch, "-")) {
                stack.items[(@as(i32, @intCast((stack).len)) - 2)] = (a - b);
            } else if (std.mem.eql(u8, ch, "*")) {
                stack.items[(@as(i32, @intCast((stack).len)) - 2)] = (a * b);
            } else if (std.mem.eql(u8, ch, "/")) {
                stack.items[(@as(i32, @intCast((stack).len)) - 2)] = (a / b);
            } else {
                std.debug.print("{s}\n", .{_concat_string(ch, " invalid.")});
                valid = false;
                break;
            }
            stack = _slice_list(i32, stack, 0, (@as(i32, @intCast((stack).len)) - 1), 1);
        }
        i = (i + 1);
    }
    if (valid) {
        if (std.math.abs((stack[0] - 24.0)) > 0.000001) {
            std.debug.print("{s}\n", .{_concat_string(_concat_string("incorrect. ", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{stack[0]}) catch |err| handleError(err)), " != 24")});
        } else {
            std.debug.print("correct.\n", .{});
        }
    }
}

pub fn main() void {
    user_main();
}
