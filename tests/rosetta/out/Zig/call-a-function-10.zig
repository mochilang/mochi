// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:20Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn user_main() void {
    var list = std.ArrayList(i32).init(std.heap.page_allocator);
    var a = 1; // i32
    var d = 2; // i32
    var e = 3; // i32
    var i = 4; // i32
    list = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(list) catch |err| handleError(err); _tmp0.append(a) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
    list = blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(list) catch |err| handleError(err); _tmp1.append(d) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
    list = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(list) catch |err| handleError(err); _tmp2.append(e) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
    list = blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(list) catch |err| handleError(err); _tmp3.append(i) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
    i = @as(i32, @intCast((list).len));
}

pub fn main() void {
    user_main();
}
