// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const Birthday = struct {
    month: i32,
    day: i32,
};

var choices = &[_]Birthday{
    Birthday{
    .month = 5,
    .day = 15,
},
    Birthday{
    .month = 5,
    .day = 16,
},
    Birthday{
    .month = 5,
    .day = 19,
},
    Birthday{
    .month = 6,
    .day = 17,
},
    Birthday{
    .month = 6,
    .day = 18,
},
    Birthday{
    .month = 7,
    .day = 14,
},
    Birthday{
    .month = 7,
    .day = 16,
},
    Birthday{
    .month = 8,
    .day = 14,
},
    Birthday{
    .month = 8,
    .day = 15,
},
    Birthday{
    .month = 8,
    .day = 17,
},
}; // []const Birthday
var filtered: []const Birthday = &[]i32{};
var filtered2: []const Birthday = &[]i32{};
var filtered3: []const Birthday = &[]i32{};
var filtered4: []const Birthday = &[]i32{};

fn monthUnique(b: *Birthday, list: []const Birthday) bool {
    var c = 0; // i32
    for (list) |x| {
        if (x.month == b.month) {
            c = (c + 1);
        }
    }
    return (c == 1);
}

fn dayUnique(b: *Birthday, list: []const Birthday) bool {
    var c = 0; // i32
    for (list) |x| {
        if (x.day == b.day) {
            c = (c + 1);
        }
    }
    return (c == 1);
}

fn monthWithUniqueDay(b: *Birthday, list: []const Birthday) bool {
    for (list) |x| {
        if ((x.month == b.month) and dayUnique(&x, list)) {
            return true;
        }
    }
    return false;
}

fn bstr(b: *Birthday) []const u8 {
    const months = &[_][]const u8{
    "",
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
}; // []const []const u8
    return _concat_string(_concat_string(months[b.month], " "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{b.day}) catch |err| handleError(err));
}

pub fn main() void {
    for (choices) |bd| {
        if (!monthUnique(&bd, choices)) {
            filtered = blk0: { var _tmp0 = std.ArrayList(Birthday).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(filtered) catch |err| handleError(err); _tmp0.append(bd) catch |err| handleError(err); break :blk0 _tmp0.items; };
        }
    }
    for (filtered) |bd| {
        if (!monthWithUniqueDay(&bd, filtered)) {
            filtered2 = blk1: { var _tmp1 = std.ArrayList(Birthday).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(filtered2) catch |err| handleError(err); _tmp1.append(bd) catch |err| handleError(err); break :blk1 _tmp1.items; };
        }
    }
    for (filtered2) |bd| {
        if (dayUnique(&bd, filtered2)) {
            filtered3 = blk2: { var _tmp2 = std.ArrayList(Birthday).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(filtered3) catch |err| handleError(err); _tmp2.append(bd) catch |err| handleError(err); break :blk2 _tmp2.items; };
        }
    }
    for (filtered3) |bd| {
        if (monthUnique(&bd, filtered3)) {
            filtered4 = blk3: { var _tmp3 = std.ArrayList(Birthday).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(filtered4) catch |err| handleError(err); _tmp3.append(bd) catch |err| handleError(err); break :blk3 _tmp3.items; };
        }
    }
    if ((filtered4).len == 1) {
        std.debug.print("{s}\n", .{_concat_string("Cheryl's birthday is ", bstr(&filtered4[0]))});
    } else {
        std.debug.print("Something went wrong!\n", .{});
    }
}
