// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const a = &[_]f64{
    1.0,
    -0.00000000000000027756,
    0.33333333,
    -0.0000000000000000185,
}; // []const f64
const b = &[_]f64{
    0.16666667,
    0.5,
    0.5,
    0.16666667,
}; // []const f64
const sig = &[_]f64{
    -0.917843918645,
    0.141984778794,
    1.20536903482,
    0.190286794412,
    -0.662370894973,
    -1.00700480494,
    -0.404707073677,
    0.800482325044,
    0.743500089861,
    1.01090520172,
    0.741527555207,
    0.277841675195,
    0.400833448236,
    -0.2085993586,
    -0.172842103641,
    -0.134316096293,
    0.0259303398477,
    0.490105989562,
    0.549391221511,
    0.9047198589,
}; // []const f64
const res = applyFilter(sig, a, b); // []const f64
var k = 0; // i32

fn applyFilter(input: []const f64, a: []const f64, b: []const f64) []const f64 {
    var out = std.ArrayList(f64).init(std.heap.page_allocator);
    const scale = (1.0 / a[0]); // f64
    var i = 0; // i32
    while (i < (input).len) {
        var tmp = 0.0; // f64
        var j = 0; // i32
        while ((j <= i) and (j < (b).len)) {
            tmp = (tmp + (b[j] * input[(i - j)]));
            j = (j + 1);
        }
        j = 0;
        while ((j < i) and ((j + 1) < (a).len)) {
            tmp = (tmp - (a[(j + 1)] * out[((i - j) - 1)]));
            j = (j + 1);
        }
        out = blk0: { var _tmp0 = std.ArrayList(f64).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(out) catch |err| handleError(err); _tmp0.append((tmp * scale)) catch |err| handleError(err); break :blk0 _tmp0.items; };
        i = (i + 1);
    }
    return out.items;
}

pub fn main() void {
    while (k < (res).len) {
        std.debug.print("{d}\n", .{res[k]});
        k = (k + 1);
    }
}
