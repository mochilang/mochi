// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const Pixel = struct {
    r: i32,
    g: i32,
    b: i32,
};

const b2Seg = 20; // i32
var b = newBitmap(400, 300); // std.StringHashMap(i32)

fn pixelFromRgb(rgb: i32) Pixel {
    const r = @as(i32, (@mod(((rgb / 65536)), 256))); // i32
    const g = @as(i32, (@mod(((rgb / 256)), 256))); // i32
    const b = @as(i32, (@mod(rgb, 256))); // i32
    return Pixel{
    .r = r,
    .g = g,
    .b = b,
};
}

fn newBitmap(cols: i32, rows: i32) std.AutoHashMap([]const u8, i32) {
    var d = std.ArrayList(Pixel).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < rows) {
        var row = std.ArrayList(Pixel).init(std.heap.page_allocator);
        var x = 0; // i32
        while (x < cols) {
            row = blk0: { var _tmp0 = std.ArrayList(Pixel).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(row) catch |err| handleError(err); _tmp0.append(Pixel{
    .r = 0,
    .g = 0,
    .b = 0,
}) catch |err| handleError(err); break :blk0 _tmp0.items; };
            x = (x + 1);
        }
        d = blk1: { var _tmp1 = std.ArrayList([]const Pixel).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(d) catch |err| handleError(err); _tmp1.append(row) catch |err| handleError(err); break :blk1 _tmp1.items; };
        y = (y + 1);
    }
    return struct {
    cols: i32,
    rows: i32,
    data: []const []const Pixel,
}{
    .cols = cols,
    .rows = rows,
    .data = d,
};
}

fn setPx(b: std.AutoHashMap([]const u8, i32), x: i32, y: i32, p: *Pixel) void {
    const cols = @as(i32, b["cols"]); // i32
    const rows = @as(i32, b["rows"]); // i32
    if ((((x >= 0) and (x < cols)) and (y >= 0)) and (y < rows)) {
        b["data"][y][x] = p;
    }
}

fn fill(b: std.AutoHashMap([]const u8, i32), p: *Pixel) void {
    const cols = @as(i32, b["cols"]); // i32
    const rows = @as(i32, b["rows"]); // i32
    var y = 0; // i32
    while (y < rows) {
        var x = 0; // i32
        while (x < cols) {
            b["data"][y][x] = p;
            x = (x + 1);
        }
        y = (y + 1);
    }
}

fn fillRgb(b: std.AutoHashMap([]const u8, i32), rgb: i32) void {
    fill(b, &pixelFromRgb(rgb));
}

fn line(b: std.AutoHashMap([]const u8, i32), x0: i32, y0: i32, x1: i32, y1: i32, p: *Pixel) void {
    var dx = (x1 - x0); // i32
    if (dx < 0) {
        dx = -dx;
    }
    var dy = (y1 - y0); // i32
    if (dy < 0) {
        dy = -dy;
    }
    var sx = -1; // i32
    if (x0 < x1) {
        sx = 1;
    }
    var sy = -1; // i32
    if (y0 < y1) {
        sy = 1;
    }
    var err = (dx - dy); // i32
    while (true) {
        setPx(b, x0, y0, &p);
        if ((x0 == x1) and (y0 == y1)) {
            break;
        }
        const e2 = (2 * err); // i32
        if (e2 > ((0 - dy))) {
            err = (err - dy);
            x0 = (x0 + sx);
        }
        if (e2 < dx) {
            err = (err + dx);
            y0 = (y0 + sy);
        }
    }
}

fn bezier2(b: std.AutoHashMap([]const u8, i32), x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, p: *Pixel) void {
    var px = std.ArrayList(i32).init(std.heap.page_allocator);
    var py = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i <= b2Seg) {
        px = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(px) catch |err| handleError(err); _tmp2.append(0) catch |err| handleError(err); break :blk2 _tmp2.items; };
        py = blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(py) catch |err| handleError(err); _tmp3.append(0) catch |err| handleError(err); break :blk3 _tmp3.items; };
        i = (i + 1);
    }
    const fx1 = @as(f64, x1); // f64
    const fy1 = @as(f64, y1); // f64
    const fx2 = @as(f64, x2); // f64
    const fy2 = @as(f64, y2); // f64
    const fx3 = @as(f64, x3); // f64
    const fy3 = @as(f64, y3); // f64
    i = 0;
    while (i <= b2Seg) {
        const c = ((@as(f64, i)) / (@as(f64, b2Seg))); // f64
        var a = (1.0 - c); // f64
        var a2 = (a * a); // f64
        var b2 = ((2.0 * c) * a); // f64
        var c2 = (c * c); // f64
        px.items[i] = @as(i32, ((((a2 * fx1) + (b2 * fx2)) + (c2 * fx3))));
        py.items[i] = @as(i32, ((((a2 * fy1) + (b2 * fy2)) + (c2 * fy3))));
        i = (i + 1);
    }
    var x0 = px[0]; // i32
    var y0 = py[0]; // i32
    i = 1;
    while (i <= b2Seg) {
        const x = px[i]; // i32
        const y = py[i]; // i32
        line(b, x0, y0, x, y, &p);
        x0 = x;
        y0 = y;
        i = (i + 1);
    }
}

pub fn main() void {
    fillRgb(b, 14614575);
    bezier2(b, 20, 150, 500, -100, 300, 280, &pixelFromRgb(4165615));
}
