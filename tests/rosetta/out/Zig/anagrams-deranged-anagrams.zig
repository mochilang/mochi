// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn sortRunes(s: []const u8) []const u8 {
    var arr = std.ArrayList(u8).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < (s).len) {
        arr = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(arr) catch |err| handleError(err); _tmp0.append(_slice_string(s, i, (i + 1), 1)) catch |err| handleError(err); break :blk0 _tmp0.items; };
        i = (i + 1);
    }
    var n = (arr).len; // i32
    var m = 0; // i32
    while (m < n) {
        var j = 0; // i32
        while (j < (n - 1)) {
            if (arr[j] > arr[(j + 1)]) {
                const tmp = arr[j]; // []const u8
                arr.items[j] = arr[(j + 1)];
                arr.items[(j + 1)] = tmp;
            }
            j = (j + 1);
        }
        m = (m + 1);
    }
    var out = ""; // []const u8
    i = 0;
    while (i < n) {
        out = _concat_string(out, arr[i]);
        i = (i + 1);
    }
    return out;
}

fn deranged(a: []const u8, b: []const u8) bool {
    if ((a).len != (b).len) {
        return false;
    }
    var i = 0; // i32
    while (i < (a).len) {
        if (_slice_string(a, i, (i + 1), 1) == _slice_string(b, i, (i + 1), 1)) {
            return false;
        }
        i = (i + 1);
    }
    return true;
}

fn user_main() void {
    const words = &[_][]const u8{
    "constitutionalism",
    "misconstitutional",
}; // []const []const u8
    var m = std.AutoHashMap([]const u8, []const []const u8).init(std.heap.page_allocator);
    var bestLen = 0; // i32
    var w1 = ""; // []const u8
    var w2 = ""; // []const u8
    for (words) |w| {
        if ((w).len <= bestLen) {
            continue;
        }
        const k = sortRunes(w); // []const u8
        if (!(m.contains(k))) {
            _ = m.put(k, &[_][]const u8{w}) catch |err| handleError(err);
            continue;
        }
        for (m[k]) |c| {
            if (deranged(w, c)) {
                bestLen = (w).len;
                w1 = c;
                w2 = w;
                break;
            }
        }
        _ = m.put(k, blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(m[k]) catch |err| handleError(err); _tmp1.append(w) catch |err| handleError(err); break :blk1 _tmp1.items; }) catch |err| handleError(err);
    }
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(w1, " "), w2), " : Length "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{bestLen}) catch |err| handleError(err))});
}

pub fn main() void {
    user_main();
}
