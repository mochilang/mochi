// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn indexOf(s: []const u8, ch: []const u8) i32 {
    var i = 0; // i32
    while (i < (s).len) {
        if (std.mem.eql(u8, substring(s, i, (i + 1)), ch)) {
            return i;
        }
        i = (i + 1);
    }
    return -1;
}

fn ord(ch: []const u8) i32 {
    const upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // []const u8
    const lower = "abcdefghijklmnopqrstuvwxyz"; // []const u8
    var idx: i32 = indexOf(upper, ch); // i32
    if (idx >= 0) {
        return (65 + idx);
    }
    idx = indexOf(lower, ch);
    if (idx >= 0) {
        return (97 + idx);
    }
    return 0;
}

fn chr(n: i32) []const u8 {
    const upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // []const u8
    const lower = "abcdefghijklmnopqrstuvwxyz"; // []const u8
    if ((n >= 65) and (n < 91)) {
        return _slice_string(upper, (n - 65), (n - 64), 1);
    }
    if ((n >= 97) and (n < 123)) {
        return _slice_string(lower, (n - 97), (n - 96), 1);
    }
    return "?";
}

fn shiftRune(r: []const u8, k: i32) []const u8 {
    if (std.mem.order(u8, r, "a") != .lt and std.mem.order(u8, r, "z") != .gt) {
        return chr(((@mod((((ord(r) - 97) + k)), 26)) + 97));
    }
    if (std.mem.order(u8, r, "A") != .lt and std.mem.order(u8, r, "Z") != .gt) {
        return chr(((@mod((((ord(r) - 65) + k)), 26)) + 65));
    }
    return r;
}

fn encipher(s: []const u8, k: i32) []const u8 {
    var out = ""; // []const u8
    var i = 0; // i32
    while (i < (s).len) {
        out = _concat_string(out, shiftRune(_slice_string(s, i, (i + 1), 1), k));
        i = (i + 1);
    }
    return out;
}

fn decipher(s: []const u8, k: i32) []const u8 {
    return encipher(s, @mod(((26 - @mod(k, 26))), 26));
}

fn main() void {
    const pt = "The five boxing wizards jump quickly"; // []const u8
    std.debug.print("{s}\n", .{_concat_string("Plaintext: ", pt)});
    for (&[_]i32{
    0,
    1,
    7,
    25,
    26,
}) |key| {
        if ((key < 1) or (key > 25)) {
            std.debug.print("{s}\n", .{_concat_string(_concat_string("Key ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{key}) catch |err| handleError(err)), " invalid")});
            continue;
        }
        const ct = encipher(pt, key); // []const u8
        std.debug.print("{s}\n", .{_concat_string("Key ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{key}) catch |err| handleError(err))});
        std.debug.print("{s}\n", .{_concat_string("  Enciphered: ", ct)});
        std.debug.print("{s}\n", .{_concat_string("  Deciphered: ", decipher(ct, key))});
    }
}

pub fn main() void {
    main();
}
