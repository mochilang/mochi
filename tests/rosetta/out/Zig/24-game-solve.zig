// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:03:04Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const OP_NUM = 0; // i32
const OP_ADD = 1; // i32
const OP_SUB = 2; // i32
const OP_MUL = 3; // i32
const OP_DIV = 4; // i32
const n_cards = 4; // i32
const goal = 24; // i32
const digit_range = 9; // i32

fn newNum(n: i32) std.AutoHashMap([]const u8, i32) {
    return struct {
        op: i32,
        value: struct {
            num: i32,
            denom: i32,
        },
    }{
        .op = OP_NUM,
        .value = struct {
            num: i32,
            denom: i32,
        }{
            .num = n,
            .denom = 1,
        },
    };
}

fn exprEval(x: std.AutoHashMap([]const u8, i32)) std.AutoHashMap([]const u8, i32) {
    if (x["op"] == OP_NUM) {
        return x["value"];
    }
    const l = exprEval(x["left"]); // std.StringHashMap(i32)
    const r = exprEval(x["right"]); // std.StringHashMap(i32)
    if (x["op"] == OP_ADD) {
        return struct {
            num: i32,
            denom: i32,
        }{
            .num = ((l["num"] * r["denom"]) + (l["denom"] * r["num"])),
            .denom = (l["denom"] * r["denom"]),
        };
    }
    if (x["op"] == OP_SUB) {
        return struct {
            num: i32,
            denom: i32,
        }{
            .num = ((l["num"] * r["denom"]) - (l["denom"] * r["num"])),
            .denom = (l["denom"] * r["denom"]),
        };
    }
    if (x["op"] == OP_MUL) {
        return struct {
            num: i32,
            denom: i32,
        }{
            .num = (l["num"] * r["num"]),
            .denom = (l["denom"] * r["denom"]),
        };
    }
    return struct {
        num: i32,
        denom: i32,
    }{
        .num = (l["num"] * r["denom"]),
        .denom = (l["denom"] * r["num"]),
    };
}

fn exprString(x: std.AutoHashMap([]const u8, i32)) []const u8 {
    if (x["op"] == OP_NUM) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{x["value"]["num"]}) catch |err| handleError(err);
    }
    const ls = exprString(x["left"]); // []const u8
    const rs = exprString(x["right"]); // []const u8
    var opstr = ""; // []const u8
    if (x["op"] == OP_ADD) {
        opstr = " + ";
    } else if (x["op"] == OP_SUB) {
        opstr = " - ";
    } else if (x["op"] == OP_MUL) {
        opstr = " * ";
    } else {
        opstr = " / ";
    }
    return _concat_string(_concat_string(_concat_string(_concat_string("(", ls), opstr), rs), ")");
}

fn solve(xs: []const std.AutoHashMap([]const u8, i32)) bool {
    if (@as(i32, @intCast((xs).len)) == 1) {
        const f = exprEval(xs[0]); // std.StringHashMap(i32)
        if ((f["denom"] != 0) and (f["num"] == (f["denom"] * goal))) {
            std.debug.print("{s}\n", .{exprString(xs[0])});
            return true;
        }
        return false;
    }
    var i = 0; // i32
    while (i < @as(i32, @intCast((xs).len))) {
        var j = (i + 1); // i32
        while (j < @as(i32, @intCast((xs).len))) {
            var rest = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator);
            var k = 0; // i32
            while (k < @as(i32, @intCast((xs).len))) {
                if ((k != i) and (k != j)) {
                    rest = blk0: {
                        var _tmp0 = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator);
                        defer _tmp0.deinit();
                        _tmp0.appendSlice(rest) catch |err| handleError(err);
                        _tmp0.append(xs[k]) catch |err| handleError(err);
                        const res = _tmp0.toOwnedSlice() catch |err| handleError(err);
                        break :blk0 res;
                    };
                }
                k = (k + 1);
            }
            const a = xs[i]; // std.StringHashMap(i32)
            const b = xs[j]; // std.StringHashMap(i32)
            for (&[_]i32{
                OP_ADD,
                OP_SUB,
                OP_MUL,
                OP_DIV,
            }) |op| {
                var node = (blk1: {
                    var _map1 = std.StringHashMap(i32).init(std.heap.page_allocator);
                    _map1.put("op", op) catch |err| handleError(err);
                    _map1.put("left", a) catch |err| handleError(err);
                    _map1.put("right", b) catch |err| handleError(err);
                    break :blk1 _map1;
                }); // std.StringHashMap(i32)
                if (solve(blk2: {
                    var _tmp2 = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator);
                    defer _tmp2.deinit();
                    _tmp2.appendSlice(rest) catch |err| handleError(err);
                    _tmp2.append(node) catch |err| handleError(err);
                    const res = _tmp2.toOwnedSlice() catch |err| handleError(err);
                    break :blk2 res;
                })) {
                    return true;
                }
            }
            var node = (blk3: {
                var _map3 = std.StringHashMap(i32).init(std.heap.page_allocator);
                _map3.put("op", OP_SUB) catch |err| handleError(err);
                _map3.put("left", b) catch |err| handleError(err);
                _map3.put("right", a) catch |err| handleError(err);
                break :blk3 _map3;
            }); // std.StringHashMap(i32)
            if (solve(blk4: {
                var _tmp4 = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator);
                defer _tmp4.deinit();
                _tmp4.appendSlice(rest) catch |err| handleError(err);
                _tmp4.append(node) catch |err| handleError(err);
                const res = _tmp4.toOwnedSlice() catch |err| handleError(err);
                break :blk4 res;
            })) {
                return true;
            }
            node = struct {
                op: i32,
                left: std.StringHashMap(i32),
                right: std.StringHashMap(i32),
            }{
                .op = OP_DIV,
                .left = b,
                .right = a,
            };
            if (solve(blk5: {
                var _tmp5 = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator);
                defer _tmp5.deinit();
                _tmp5.appendSlice(rest) catch |err| handleError(err);
                _tmp5.append(node) catch |err| handleError(err);
                const res = _tmp5.toOwnedSlice() catch |err| handleError(err);
                break :blk5 res;
            })) {
                return true;
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return false;
}

fn user_main() void {
    var iter = 0; // i32
    while (iter < 10) {
        var cards = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator);
        var i = 0; // i32
        while (i < n_cards) {
            const n = ((@mod(std.time.nanoTimestamp(), ((digit_range - 1)))) + 1); // i32
            cards = blk6: {
                var _tmp6 = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator);
                defer _tmp6.deinit();
                _tmp6.appendSlice(cards) catch |err| handleError(err);
                _tmp6.append(newNum(n)) catch |err| handleError(err);
                const res = _tmp6.toOwnedSlice() catch |err| handleError(err);
                break :blk6 res;
            };
            std.debug.print("{s}\n", .{_concat_string(" ", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{n}) catch |err| handleError(err))});
            i = (i + 1);
        }
        std.debug.print(":  \n", .{});
        if (!solve(cards)) {
            std.debug.print("No solution\n", .{});
        }
        iter = (iter + 1);
    }
}

pub fn main() void {
    user_main();
}
