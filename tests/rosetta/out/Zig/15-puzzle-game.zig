// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:03:03Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

var board = &[_]i32{
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    0,
}; // []const i32
const solved = &[_]i32{
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    0,
}; // []const i32
var empty = 15; // i32
var moves = 0; // i32
var quit = false; // bool

fn randMove() i32 {
    return @mod(std.time.nanoTimestamp(), 4);
}

fn isSolved() bool {
    var i = 0; // i32
    while (i < 16) {
        if (board[i] != solved[i]) {
            return false;
        }
        i = (i + 1);
    }
    return true;
}

fn isValidMove(m: i32) std.AutoHashMap([]const u8, i32) {
    if (m == 0) {
        return struct {
            idx: i32,
            ok: bool,
        }{
            .idx = (empty - 4),
            .ok = ((empty / 4) > 0),
        };
    }
    if (m == 1) {
        return struct {
            idx: i32,
            ok: bool,
        }{
            .idx = (empty + 4),
            .ok = ((empty / 4) < 3),
        };
    }
    if (m == 2) {
        return struct {
            idx: i32,
            ok: bool,
        }{
            .idx = (empty + 1),
            .ok = (@mod(empty, 4) < 3),
        };
    }
    if (m == 3) {
        return struct {
            idx: i32,
            ok: bool,
        }{
            .idx = (empty - 1),
            .ok = (@mod(empty, 4) > 0),
        };
    }
    return struct {
        idx: i32,
        ok: bool,
    }{
        .idx = 0,
        .ok = false,
    };
}

fn doMove(m: i32) bool {
    const r = isValidMove(m); // std.StringHashMap(i32)
    if (!r["ok"]) {
        return false;
    }
    const i = empty; // i32
    const j = int(r["idx"]); // i32
    const tmp = board[i]; // i32
    board.items[i] = board[j];
    board.items[j] = tmp;
    empty = j;
    moves = (moves + 1);
    return true;
}

fn shuffle(n: i32) void {
    var i = 0; // i32
    while ((i < n) or isSolved()) {
        if (doMove(randMove())) {
            i = (i + 1);
        }
    }
}

fn printBoard() void {
    var line = ""; // []const u8
    var i = 0; // i32
    while (i < 16) {
        const val = board[i]; // i32
        if (val == 0) {
            line = _concat_string(line, "  .");
        } else {
            const s = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{val}) catch |err| handleError(err); // []const u8
            if (val < 10) {
                line = _concat_string(_concat_string(line, "  "), s);
            } else {
                line = _concat_string(_concat_string(line, " "), s);
            }
        }
        if (@mod(i, 4) == 3) {
            std.debug.print("{s}\n", .{line});
            line = "";
        }
        i = (i + 1);
    }
}

fn playOneMove() void {
    while (true) {
        std.debug.print("{s}\n", .{_concat_string(_concat_string("Enter move #", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{(moves + 1)}) catch |err| handleError(err)), " (U, D, L, R, or Q): ")});
        const s = input(); // []const u8
        if (std.mem.eql(u8, s, "")) {
            continue;
        }
        const c = s[0..1]; // []const u8
        var m = 0; // i32
        if (std.mem.eql(u8, c, "U") or std.mem.eql(u8, c, "u")) {
            m = 0;
        } else if (std.mem.eql(u8, c, "D") or std.mem.eql(u8, c, "d")) {
            m = 1;
        } else if (std.mem.eql(u8, c, "R") or std.mem.eql(u8, c, "r")) {
            m = 2;
        } else if (std.mem.eql(u8, c, "L") or std.mem.eql(u8, c, "l")) {
            m = 3;
        } else if (std.mem.eql(u8, c, "Q") or std.mem.eql(u8, c, "q")) {
            std.debug.print("{s}\n", .{_concat_string(_concat_string("Quiting after ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{moves}) catch |err| handleError(err)), " moves.")});
            quit = true;
            return;
        } else {
            std.debug.print("{s}\n", .{_concat_string(_concat_string("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\nup, down, left, or right. You can also enter \"Q\" to quit.\n", "Upper or lowercase is accepted and only the first non-blank\n"), "character is important (i.e. you may enter \"up\" if you like).")});
            continue;
        }
        if (!doMove(m)) {
            std.debug.print("That is not a valid move at the moment.\n", .{});
            continue;
        }
        return;
    }
}

fn play() void {
    std.debug.print("Starting board:\n", .{});
    while ((!quit and (!isSolved()))) {
        std.debug.print("\n", .{});
        printBoard();
        playOneMove();
    }
    if (isSolved()) {
        std.debug.print("{s}\n", .{_concat_string(_concat_string("You solved the puzzle in ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{moves}) catch |err| handleError(err)), " moves.")});
    }
}

fn user_main() void {
    shuffle(50);
    play();
}

pub fn main() void {
    user_main();
}
