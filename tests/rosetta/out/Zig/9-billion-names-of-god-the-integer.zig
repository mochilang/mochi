// Generated by Mochi compiler v0.10.30 on 2025-07-19T00:25:48Z
const std = @import("std");

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

var x: i32 = 1; // i32

fn bigTrim(a: []const i32) []const i32 {
    var n: i32 = @as(i32, @intCast((a).len)); // i32
    while ((n > 1) and (a[(n - 1)] == 0)) {
        a = a[0..@as(usize, @intCast(n - 1))];
        n = (n - 1);
    }
    return a.items;
}

fn bigFromInt(x: i32) []const i32 {
    if (x == 0) {
        return [_]i32{0};
    }
    var digits: []i32 = &[_]i32{};
    var n: i32 = x; // i32
    while (n > 0) {
        digits = blk0: {
            var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator);
            defer _tmp0.deinit();
            _tmp0.appendSlice(digits.items) catch |err| handleError(err);
            _tmp0.append(@mod(n, 10)) catch |err| handleError(err);
            const res = _tmp0.toOwnedSlice() catch |err| handleError(err);
            break :blk0 res;
        };
        n = (n / 10);
    }
    return digits.items;
}

fn bigAdd(a: []const i32, b: []const i32) []const i32 {
    var res: []i32 = &[_]i32{};
    var carry: i32 = 0; // i32
    var i: i32 = 0; // i32
    while (((i < @as(i32, @intCast((a).len))) or (i < @as(i32, @intCast((b).len)))) or (carry > 0)) {
        var av: i32 = 0; // i32
        if (i < @as(i32, @intCast((a).len))) {
            av = a[i];
        }
        var bv: i32 = 0; // i32
        if (i < @as(i32, @intCast((b).len))) {
            bv = b[i];
        }
        var s = ((av + bv) + carry); // i32
        res = blk1: {
            var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator);
            defer _tmp1.deinit();
            _tmp1.appendSlice(res.items) catch |err| handleError(err);
            _tmp1.append(@mod(s, 10)) catch |err| handleError(err);
            const res = _tmp1.toOwnedSlice() catch |err| handleError(err);
            break :blk1 res;
        };
        carry = (s / 10);
        i = (i + 1);
    }
    return bigTrim(res);
}

fn bigSub(a: []const i32, b: []const i32) []const i32 {
    var res: []i32 = &[_]i32{};
    var borrow: i32 = 0; // i32
    var i: i32 = 0; // i32
    while (i < @as(i32, @intCast((a).len))) {
        var av: i32 = a[i]; // i32
        var bv: i32 = 0; // i32
        if (i < @as(i32, @intCast((b).len))) {
            bv = b[i];
        }
        var diff = ((av - bv) - borrow); // i32
        if (diff < 0) {
            diff = (diff + 10);
            borrow = 1;
        } else {
            borrow = 0;
        }
        res = blk2: {
            var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator);
            defer _tmp2.deinit();
            _tmp2.appendSlice(res.items) catch |err| handleError(err);
            _tmp2.append(diff) catch |err| handleError(err);
            const res = _tmp2.toOwnedSlice() catch |err| handleError(err);
            break :blk2 res;
        };
        i = (i + 1);
    }
    return bigTrim(res);
}

fn bigToString(a: []const i32) []const u8 {
    var s: []const u8 = ""; // []const u8
    var i = (@as(i32, @intCast((a).len)) - 1); // i32
    while (i >= 0) {
        s = _concat_string(s, std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{a[i]}) catch |err| handleError(err));
        i = (i - 1);
    }
    return s;
}

fn minInt(a: i32, b: i32) i32 {
    if (a < b) {
        return a;
    } else {
        return b;
    }
}

fn cumu(n: i32) []const []const i32 {
    var cache: []const []const []const i32 = &[_][]const []const i32{&[_][]const i32{bigFromInt(1)}}; // []const []const []const i32
    var y: i32 = 1; // i32
    while (y <= n) {
        var row: []const []const i32 = &[_][]const i32{bigFromInt(0)}; // []const []const i32
        var x: i32 = 1; // i32
        while (x <= y) {
            const val = cache[(y - x)][minInt(x, (y - x))]; // []const i32
            row = blk3: {
                var _tmp3 = std.ArrayList([]const i32).init(std.heap.page_allocator);
                defer _tmp3.deinit();
                _tmp3.appendSlice(row.items) catch |err| handleError(err);
                _tmp3.append(bigAdd(row[(@as(i32, @intCast((row).len)) - 1)], val)) catch |err| handleError(err);
                const res = _tmp3.toOwnedSlice() catch |err| handleError(err);
                break :blk3 res;
            };
            x = (x + 1);
        }
        cache = blk4: {
            var _tmp4 = std.ArrayList([]const []const i32).init(std.heap.page_allocator);
            defer _tmp4.deinit();
            _tmp4.appendSlice(cache.items) catch |err| handleError(err);
            _tmp4.append(row) catch |err| handleError(err);
            const res = _tmp4.toOwnedSlice() catch |err| handleError(err);
            break :blk4 res;
        };
        y = (y + 1);
    }
    return cache.items[n];
}

fn row(n: i32) []const []const u8 {
    const e = cumu(n); // []const []const i32
    var out: []u8 = &[_]u8{};
    var i: i32 = 0; // i32
    while (i < n) {
        const diff = bigSub(e[(i + 1)], e[i]); // []const i32
        out = blk5: {
            var _tmp5 = std.ArrayList([]const u8).init(std.heap.page_allocator);
            defer _tmp5.deinit();
            _tmp5.appendSlice(out.items) catch |err| handleError(err);
            _tmp5.append(bigToString(diff)) catch |err| handleError(err);
            const res = _tmp5.toOwnedSlice() catch |err| handleError(err);
            break :blk5 res;
        };
        i = (i + 1);
    }
    return out.items;
}

pub fn main() void {
    std.debug.print("rows:\n", .{});
    while (x < 11) {
        const r = row(x); // []const []const u8
        var line: []const u8 = ""; // []const u8
        var i: i32 = 0; // i32
        while (i < @as(i32, @intCast((r).len))) {
            line = _concat_string(_concat_string(_concat_string(line, " "), r[i]), " ");
            i = (i + 1);
        }
        std.debug.print("{s}\n", .{line});
        x = (x + 1);
    }
    std.debug.print("\n", .{});
    std.debug.print("sums:\n", .{});
    for (&[_]i32{
        23,
        123,
        1234,
    }) |num| {
        const r: i32 = cumu(num); // i32
        std.debug.print("{any}\n", .{_concat_string(_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{num}) catch |err| handleError(err), " "), bigToString(r[(@as(i32, @intCast((r).len)) - 1)]))});
    }
}
