// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn trimSpace(s: []const u8) []const u8 {
    var start = 0; // i32
    while ((start < (s).len) and std.mem.eql(u8, _slice_string(s, start, (start + 1), 1), " ")) {
        start = (start + 1);
    }
    var end = (s).len; // i32
    while ((end > start) and std.mem.eql(u8, _slice_string(s, (end - 1), end, 1), " ")) {
        end = (end - 1);
    }
    return _slice_string(s, start, end, 1);
}

fn isUpper(ch: []const u8) bool {
    return (std.mem.order(u8, ch, "A") != .lt and std.mem.order(u8, ch, "Z") != .gt);
}

fn padLeft(s: []const u8, w: i32) []const u8 {
    var res = ""; // []const u8
    var n = (w - (s).len); // i32
    while (n > 0) {
        res = _concat_string(res, " ");
        n = (n - 1);
    }
    return _concat_string(res, s);
}

fn snakeToCamel(s: []const u8) []const u8 {
    s = trimSpace(s);
    var out = ""; // []const u8
    var up = false; // bool
    var i = 0; // i32
    while (i < (s).len) {
        const ch = _slice_string(s, i, (i + 1), 1); // []const u8
        if (((std.mem.eql(u8, ch, "_") or std.mem.eql(u8, ch, "-")) or std.mem.eql(u8, ch, " ")) or std.mem.eql(u8, ch, ".")) {
            up = true;
            i = (i + 1);
            continue;
        }
        if (i == 0) {
            out = _concat_string(out, std.ascii.lowerString(ch));
            up = false;
            i = (i + 1);
            continue;
        }
        if (up) {
            out = _concat_string(out, upper(ch));
            up = false;
        } else {
            out = _concat_string(out, ch);
        }
        i = (i + 1);
    }
    return out;
}

fn camelToSnake(s: []const u8) []const u8 {
    s = trimSpace(s);
    var out = ""; // []const u8
    var prevUnd = false; // bool
    var i = 0; // i32
    while (i < (s).len) {
        const ch = _slice_string(s, i, (i + 1), 1); // []const u8
        if ((std.mem.eql(u8, ch, " ") or std.mem.eql(u8, ch, "-")) or std.mem.eql(u8, ch, ".")) {
            if (!prevUnd and ((out).len > 0)) {
                out = _concat_string(out, "_");
                prevUnd = true;
            }
            i = (i + 1);
            continue;
        }
        if (std.mem.eql(u8, ch, "_")) {
            if (!prevUnd and ((out).len > 0)) {
                out = _concat_string(out, "_");
                prevUnd = true;
            }
            i = (i + 1);
            continue;
        }
        if (isUpper(ch)) {
            if ((i > 0) and (!prevUnd)) {
                out = _concat_string(out, "_");
            }
            out = _concat_string(out, std.ascii.lowerString(ch));
            prevUnd = false;
        } else {
            out = _concat_string(out, std.ascii.lowerString(ch));
            prevUnd = false;
        }
        i = (i + 1);
    }
    var start = 0; // i32
    while ((start < (out).len) and std.mem.eql(u8, _slice_string(out, start, (start + 1), 1), "_")) {
        start = (start + 1);
    }
    var end = (out).len; // i32
    while ((end > start) and std.mem.eql(u8, _slice_string(out, (end - 1), end, 1), "_")) {
        end = (end - 1);
    }
    out = _slice_string(out, start, end, 1);
    var res = ""; // []const u8
    var j = 0; // i32
    var lastUnd = false; // bool
    while (j < (out).len) {
        const c = _slice_string(out, j, (j + 1), 1); // []const u8
        if (std.mem.eql(u8, c, "_")) {
            if (!lastUnd) {
                res = _concat_string(res, c);
            }
            lastUnd = true;
        } else {
            res = _concat_string(res, c);
            lastUnd = false;
        }
        j = (j + 1);
    }
    return res;
}

fn main() void {
    const samples = &[_][]const u8{
    "snakeCase",
    "snake_case",
    "snake-case",
    "snake case",
    "snake CASE",
    "snake.case",
    "variable_10_case",
    "variable10Case",
    "É›rgo rE tHis",
    "hurry-up-joe!",
    "c://my-docs/happy_Flag-Day/12.doc",
    " spaces ",
}; // []const []const u8
    std.debug.print("=== To snake_case ===\n", .{});
    for (samples) |s| {
        std.debug.print("{s}\n", .{_concat_string(_concat_string(padLeft(s, 34), " => "), camelToSnake(s))});
    }
    std.debug.print("\n", .{});
    std.debug.print("=== To camelCase ===\n", .{});
    for (samples) |s| {
        std.debug.print("{s}\n", .{_concat_string(_concat_string(padLeft(s, 34), " => "), snakeToCamel(s))});
    }
}

pub fn main() void {
    main();
}
