// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:52Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const r1 = getCombs(1, 7, true); // std.StringHashMap(i32)
const r2 = getCombs(3, 9, true); // std.StringHashMap(i32)
const r3 = getCombs(0, 9, false); // std.StringHashMap(i32)

fn validComb(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32) bool {
    const square1 = (a + b); // i32
    const square2 = ((b + c) + d); // i32
    const square3 = ((d + e) + f); // i32
    const square4 = (f + g); // i32
    return (((square1 == square2) and (square2 == square3)) and (square3 == square4));
}

fn isUnique(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32) bool {
    var nums = &[_]i32{
    a,
    b,
    c,
    d,
    e,
    f,
    g,
}; // []const i32
    var i = 0; // i32
    while (i < @as(i32, @intCast((nums).len))) {
        var j = (i + 1); // i32
        while (j < @as(i32, @intCast((nums).len))) {
            if (nums[i] == nums[j]) {
                return false;
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return true;
}

fn getCombs(low: i32, high: i32, unique: bool) std.AutoHashMap([]const u8, i32) {
    var valid = std.ArrayList(i32).init(std.heap.page_allocator);
    var count = 0; // i32
    for (low .. ((high + 1))) |b| {
        for (low .. ((high + 1))) |c| {
            for (low .. ((high + 1))) |d| {
                const s = ((b + c) + d); // i32
                for (low .. ((high + 1))) |e| {
                    for (low .. ((high + 1))) |f| {
                        const a = (s - b); // i32
                        const g = (s - f); // i32
                        if ((a < low) or (a > high)) {
                            continue;
                        }
                        if ((g < low) or (g > high)) {
                            continue;
                        }
                        if (((d + e) + f) != s) {
                            continue;
                        }
                        if ((f + g) != s) {
                            continue;
                        }
                        if (!unique or isUnique(a, b, c, d, e, f, g)) {
                            valid = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(valid) catch |err| handleError(err); _tmp0.append(&[_]i32{
    a,
    b,
    c,
    d,
    e,
    f,
    g,
}) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
                            count = (count + 1);
                        }
                    }
                }
            }
        }
    }
    return struct {
    count: fn(i32) i32,
    list: []const i32,
}{
    .count = count,
    .list = valid,
};
}

pub fn main() void {
    std.debug.print("{s}\n", .{_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{r1["count"]}) catch |err| handleError(err), " unique solutions in 1 to 7")});
    std.debug.print("{any}\n", .{r1["list"]});
    std.debug.print("{s}\n", .{_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{r2["count"]}) catch |err| handleError(err), " unique solutions in 3 to 9")});
    std.debug.print("{any}\n", .{r2["list"]});
    std.debug.print("{s}\n", .{_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{r3["count"]}) catch |err| handleError(err), " non-unique solutions in 0 to 9")});
}
