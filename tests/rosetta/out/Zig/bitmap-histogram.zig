// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:16Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn image() []const []const i32 {
    return [_][]const i32{
    &[_]i32{
    0,
    0,
    10000,
},
    &[_]i32{
    65535,
    65535,
    65535,
},
    &[_]i32{
    65535,
    65535,
    65535,
},
};
}

fn histogram(g: []const []const i32, bins: i32) []const i32 {
    if (bins <= 0) {
        bins = @as(i32, @intCast((g[0]).len));
    }
    var h = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < bins) {
        h = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(h) catch |err| handleError(err); _tmp0.append(0) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
        i = (i + 1);
    }
    var y = 0; // i32
    while (y < @as(i32, @intCast((g).len))) {
        var row = g[y]; // []const i32
        var x = 0; // i32
        while (x < @as(i32, @intCast((row).len))) {
            var p = row[x]; // i32
            var idx = @as(i32, ((((p * ((bins - 1)))) / 65535))); // i32
            h.items[idx] = (h[idx] + 1);
            x = (x + 1);
        }
        y = (y + 1);
    }
    return h.items;
}

fn medianThreshold(h: []const i32) i32 {
    var lb = 0; // i32
    var ub = (@as(i32, @intCast((h).len)) - 1); // i32
    var lSum = 0; // i32
    var uSum = 0; // i32
    while (lb <= ub) {
        if ((lSum + h[lb]) < (uSum + h[ub])) {
            lSum = (lSum + h[lb]);
            lb = (lb + 1);
        } else {
            uSum = (uSum + h[ub]);
            ub = (ub - 1);
        }
    }
    return @as(i32, ((((ub * 65535)) / @as(i32, @intCast((h).len)))));
}

fn threshold(g: []const []const i32, t: i32) []const []const i32 {
    var out = std.ArrayList(i32).init(std.heap.page_allocator);
    var y = 0; // i32
    while (y < @as(i32, @intCast((g).len))) {
        var row = g[y]; // []const i32
        var newRow = std.ArrayList(i32).init(std.heap.page_allocator);
        var x = 0; // i32
        while (x < @as(i32, @intCast((row).len))) {
            if (row[x] < t) {
                newRow = blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(newRow) catch |err| handleError(err); _tmp1.append(0) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
            } else {
                newRow = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(newRow) catch |err| handleError(err); _tmp2.append(65535) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
            }
            x = (x + 1);
        }
        out = blk3: { var _tmp3 = std.ArrayList([]const i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(out) catch |err| handleError(err); _tmp3.append(newRow) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
        y = (y + 1);
    }
    return out.items;
}

fn printImage(g: []const []const i32) void {
    var y = 0; // i32
    while (y < @as(i32, @intCast((g).len))) {
        var row = g[y]; // []const i32
        var line = ""; // []const u8
        var x = 0; // i32
        while (x < @as(i32, @intCast((row).len))) {
            if (row[x] == 0) {
                line = _concat_string(line, "0");
            } else {
                line = _concat_string(line, "1");
            }
            x = (x + 1);
        }
        std.debug.print("{s}\n", .{line});
        y = (y + 1);
    }
}

fn user_main() void {
    const img = image(); // []const []const i32
    const h = histogram(img, 0); // []const i32
    std.debug.print("{s}\n", .{_concat_string("Histogram: ", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{h}) catch |err| handleError(err))});
    const t = medianThreshold(h); // i32
    std.debug.print("{s}\n", .{_concat_string("Threshold: ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{t}) catch |err| handleError(err))});
    const bw = threshold(img, t); // []const []const i32
    printImage(bw);
}

pub fn main() void {
    user_main();
}
