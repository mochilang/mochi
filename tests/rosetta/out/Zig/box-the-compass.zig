// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const compassPoint = &[_][]const u8{
    "North",
    "North by east",
    "North-northeast",
    "Northeast by north",
    "Northeast",
    "Northeast by east",
    "East-northeast",
    "East by north",
    "East",
    "East by south",
    "East-southeast",
    "Southeast by east",
    "Southeast",
    "Southeast by south",
    "South-southeast",
    "South by east",
    "South",
    "South by west",
    "South-southwest",
    "Southwest by south",
    "Southwest",
    "Southwest by west",
    "West-southwest",
    "West by south",
    "West",
    "West by north",
    "West-northwest",
    "Northwest by west",
    "Northwest",
    "Northwest by north",
    "North-northwest",
    "North by west",
}; // []const []const u8
const headings = &[_]f64{
    0.0,
    16.87,
    16.88,
    33.75,
    50.62,
    50.63,
    67.5,
    84.37,
    84.38,
    101.25,
    118.12,
    118.13,
    135.0,
    151.87,
    151.88,
    168.75,
    185.62,
    185.63,
    202.5,
    219.37,
    219.38,
    236.25,
    253.12,
    253.13,
    270.0,
    286.87,
    286.88,
    303.75,
    320.62,
    320.63,
    337.5,
    354.37,
    354.38,
}; // []const f64
var i = 0; // i32

fn padLeft(s: []const u8, w: i32) []const u8 {
    var res = ""; // []const u8
    var n = (w - (s).len); // i32
    while (n > 0) {
        res = _concat_string(res, " ");
        n = (n - 1);
    }
    return _concat_string(res, s);
}

fn padRight(s: []const u8, w: i32) []const u8 {
    var out = s; // []const u8
    var i = (s).len; // i32
    while (i < w) {
        out = _concat_string(out, " ");
        i = (i + 1);
    }
    return out;
}

fn indexOf(s: []const u8, ch: []const u8) i32 {
    var i = 0; // i32
    while (i < (s).len) {
        if (std.mem.eql(u8, substring(s, i, (i + 1)), ch)) {
            return i;
        }
        i = (i + 1);
    }
    return -1;
}

fn format2(f: f64) []const u8 {
    var s = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{f}) catch |err| handleError(err); // []const u8
    const idx = indexOf(s, "."); // i32
    if (idx < 0) {
        s = _concat_string(s, ".00");
    } else {
        var need = (idx + 3); // i32
        if ((s).len > need) {
            s = substring(s, 0, need);
        } else {
            while ((s).len < need) {
                s = _concat_string(s, "0");
            }
        }
    }
    return s;
}

fn cpx(h: f64) i32 {
    var x = @as(i32, ((((h / 11.25)) + 0.5))); // i32
    x = @mod(x, 32);
    if (x < 0) {
        x = (x + 32);
    }
    return x;
}

fn degrees2compasspoint(h: f64) []const u8 {
    return compassPoint[cpx(h)];
}

pub fn main() void {
    std.debug.print("Index  Compass point         Degree\n", .{});
    while (i < (headings).len) {
        const h = headings[i]; // f64
        const idx = (@mod(i, 32) + 1); // i32
        const cp = degrees2compasspoint(h); // []const u8
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(padLeft(std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{idx}) catch |err| handleError(err), 4), "   "), padRight(cp, 19)), " "), format2(h)), "Â°")});
        i = (i + 1);
    }
}
