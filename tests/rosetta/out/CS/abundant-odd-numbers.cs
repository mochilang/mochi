// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:29:35Z
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;

class Program
{
    static List<int> divisors(int n)
    {
        List<int> divs = new List<int> { 1 };
        List<int> divs2 = new List<int>();
        int i = 2;
        while ((i * i) <= n)
        {
            if ((n % i) == 0)
            {
                int j = _cast<int>(((n / i)));
                divs = new List<int>(divs) { i };
                if (i != j)
                {
                    divs2 = new List<int>(divs2) { j };
                }
            }
            i = (i + 1);
        }
        int j = (divs2.Length - 1);
        while (j >= 0)
        {
            divs = new List<int>(divs) { _indexList(divs2, j) };
            j = (j - 1);
        }
        return divs;
    }

    static int sum(List<int> xs)
    {
        int tot = 0;
        foreach (var v in xs)
        {
            tot = (tot + v);
        }
        return tot;
    }

    static string sumStr(List<int> xs)
    {
        string s = "";
        int i = 0;
        while (i < xs.Length)
        {
            s = ((s + Convert.ToString(_indexList(xs, i))) + " + ");
            i = (i + 1);
        }
        return _sliceString(s, 0, (s.Length - 3));
    }

    static string pad2(int n)
    {
        string s = Convert.ToString(n);
        if (s.Length < 2)
        {
            return string.Concat(" ", s);
        }
        return s;
    }

    static string pad5(int n)
    {
        string s = Convert.ToString(n);
        while (s.Length < 5)
        {
            s = string.Concat(" ", s);
        }
        return s;
    }

    static int abundantOdd(int searchFrom, int countFrom, int countTo, bool printOne)
    {
        var count = countFrom;
        var n = searchFrom;
        while (count < countTo)
        {
            List<int> divs = divisors(n);
            int tot = Enumerable.Sum(divs);
            if (tot > n)
            {
                count = (count + 1);
                if (printOne && (count < countTo))
                {
                    n = (n + 2);
                    continue;
                }
                string s = sumStr(divs);
                if (!printOne)
                {
                    Console.WriteLine(((((((pad2(count) + ". ") + pad5(n)) + " < ") + s) + " = ") + Convert.ToString(tot)));
                }
                else
                {
                    Console.WriteLine(((((Convert.ToString(n) + " < ") + s) + " = ") + Convert.ToString(tot)));
                }
            }
            n = (n + 2);
        }
        return n;
    }

    static void main()
    {
        var max = 25;
        Console.WriteLine((("The first " + Convert.ToString(max)) + " abundant odd numbers are:"));
        var n = abundantOdd(1, 0, max, false);
        Console.WriteLine("\nThe one thousandth abundant odd number is:");
        abundantOdd(n, max, 1000, true);
        Console.WriteLine("\nThe first abundant odd number above one billion is:");
        abundantOdd(1000000001, 0, 1, true);
    }

    static void Main()
    {
        main();
    }
    static T _cast<T>(dynamic v)
    {
        if (v is T tv) return tv;
        if (typeof(T) == typeof(long))
        {
            if (v is long) return (T)v;
            if (v is int) return (T)(object)(long)(int)v;
            if (v is double) return (T)(object)(long)(double)v;
            if (v is float) return (T)(object)(long)(float)v;
            if (v is string) return (T)(object)long.Parse((string)v);
        }
        if (typeof(T) == typeof(int))
        {
            if (v is int) return (T)v;
            if (v is long) return (T)(object)(int)(long)v;
            if (v is double) return (T)(object)(int)(double)v;
            if (v is float) return (T)(object)(int)(float)v;
            if (v is string) return (T)(object)int.Parse((string)v);
        }
        if (typeof(T) == typeof(double))
        {
            if (v is int) return (T)(object)(double)(int)v;
            if (v is double) return (T)v;
            if (v is float) return (T)(object)(double)(float)v;
            if (v is string) return (T)(object)double.Parse((string)v);
        }
        if (typeof(T) == typeof(float))
        {
            if (v is int) return (T)(object)(float)(int)v;
            if (v is double) return (T)(object)(float)(double)v;
            if (v is float) return (T)v;
            if (v is string) return (T)(object)float.Parse((string)v);
        }
        if (typeof(T).IsGenericType && typeof(T).GetGenericTypeDefinition() == typeof(Dictionary<,>) && v is System.Collections.IDictionary d)
        {
            var args = typeof(T).GetGenericArguments();
            var res = (System.Collections.IDictionary)Activator.CreateInstance(typeof(Dictionary<,>).MakeGenericType(args));
            var mCast = typeof(Program).GetMethod("_cast");
            foreach (System.Collections.DictionaryEntry kv in d)
            {
                var k = mCast.MakeGenericMethod(args[0]).Invoke(null, new object[] { kv.Key });
                var val = mCast.MakeGenericMethod(args[1]).Invoke(null, new object[] { kv.Value });
                res.Add(k, val);
            }
            return (T)res;
        }
        if (v is System.Collections.Generic.IDictionary<object, object> dm)
        {
            var m = new Dictionary<string, object>();
            foreach (var kv in dm) m[Convert.ToString(kv.Key)] = kv.Value;
            v = m;
        }
        var json = JsonSerializer.Serialize(v, new JsonSerializerOptions { IncludeFields = true });
        return JsonSerializer.Deserialize<T>(json, new JsonSerializerOptions { IncludeFields = true });
    }

    static dynamic _indexList(dynamic l, long i)
    {
        var list = l as System.Collections.IList;
        if (list == null) throw new Exception("index() expects list");
        if (i < 0) i += list.Count;
        if (i < 0 || i >= list.Count) throw new Exception("index out of range");
        return list[(int)i];
    }

    static string _sliceString(string s, long i, long j)
    {
        var start = i;
        var end = j;
        var n = s.Length;
        if (start < 0) start += n;
        if (end < 0) end += n;
        if (start < 0) start = 0;
        if (end > n) end = n;
        if (end < start) end = start;
        return s.Substring((int)start, (int)(end - start));
    }

}
