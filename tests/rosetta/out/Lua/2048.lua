-- Generated by Mochi compiler v0.10.26 on 2025-07-16T12:28:39Z
function __add(a, b)
    if type(a) == 'table' and type(b) == 'table' then
        local out = {}
        for i = 1, #a do out[#out+1] = a[i] end
        for i = 1, #b do out[#out+1] = b[i] end
        return out
    elseif type(a) == 'string' or type(b) == 'string' then
        return tostring(a) .. tostring(b)
    else
        return a + b
    end
end
function __append(lst, v)
    local out = {}
    if lst then for i = 1, #lst do out[#out+1] = lst[i] end end
    out[#out+1] = v
    return out
end
function __count(v)
    if type(v) == 'table' then
        if v.items ~= nil then return #v.items end
        if v[1] ~= nil or #v > 0 then return #v end
        local n = 0
        for _ in pairs(v) do n = n + 1 end
        return n
    elseif type(v) == 'string' then
        return #v
    else
        error('count() expects list or group')
    end
end
function __eq(a, b)
    if type(a) ~= type(b) then return false end
    if type(a) == 'number' then return math.abs(a-b) < 1e-9 end
    if type(a) ~= 'table' then return a == b end
    if (a[1] ~= nil or #a > 0) and (b[1] ~= nil or #b > 0) then
        if #a ~= #b then return false end
        for i = 1, #a do if not __eq(a[i], b[i]) then return false end end
        return true
    end
    for k, v in pairs(a) do if not __eq(v, b[k]) then return false end end
    for k, _ in pairs(b) do if a[k] == nil then return false end end
    return true
end
function __index(obj, i)
    if type(obj) == 'string' then
        return __indexString(obj, i)
    elseif type(obj) == 'table' then
        if obj[1] ~= nil or #obj > 0 then
            return obj[(i)+1]
        else
            return obj[i]
        end
    else
        error('cannot index')
    end
end
function __indexString(s, i)
    local len = #s
    if i < 0 then
        i = len + i + 1
    else
        i = i + 1
    end
    if i < 1 or i > len then error('index out of range') end
    return string.sub(s, i, i)
end
function __input()
    local line = io.read('*l')
    if line == nil then return '' end
    return line
end
function __print(v)
    if type(v) == 'table' and (v[1] ~= nil or #v > 0) and type(v[1]) == 'table' then
        local parts = {}
        for i=1,#v do parts[#parts+1] = __str(v[i]) end
        print(table.concat(parts, ' '))
    else
        print(__str(v))
    end
end
function __str(v)
    local t = type(v)
    if t == 'table' then
        if v[1] ~= nil or #v > 0 then
            local parts = {}
            for i=1,#v do parts[#parts+1] = __str(v[i]) end
            return '['..table.concat(parts, ' ')..']'
        else
            local keys = {}
            for k in pairs(v) do keys[#keys+1] = k end
            table.sort(keys, function(a,b) return tostring(a)<tostring(b) end)
            local parts = {}
            for _,k in ipairs(keys) do parts[#parts+1] = __str(k)..':'..__str(v[k]) end
            return '{'..table.concat(parts, ',')..'}'
        end
    else
        return tostring(v)
    end
end
function newBoard()
    local b = {}
    local y = 0
    while (y < SIZE) do
        local row = {}
        local x = 0
        while (x < SIZE) do
            row = __append(row, 0)
            x = __add(x, 1)
        end
        b = __append(b, row)
        y = __add(y, 1)
    end
    return b
end

function spawnTile(b)
    local empty = {}
    local y = 0
    while (y < SIZE) do
        local x = 0
        while (x < SIZE) do
            if __eq(__index(__index(b, y), x), 0) then
                empty = __append(empty, {x, y})
            end
            x = __add(x, 1)
        end
        y = __add(y, 1)
    end
    if (#empty == 0) then
        return {["board"]=b, ["full"]=true}
    end
    local idx = (os.time()*1000000000 % #empty)
    local cell = __index(empty, idx)
    local val = 4
    if ((os.time()*1000000000 % 10) < 9) then
        val = 2
    end
    b[__index(cell, 1)][__index(cell, 0)] = val
    return {["board"]=b, ["full"]=(#empty == 1)}
end

function pad(n)
    local s = __str(n)
    local pad = (4 - #s)
    local i = 0
    local out = ""
    while (i < pad) do
        out = __add(out, " ")
        i = __add(i, 1)
    end
    return __add(out, s)
end

function draw(b, score)
    __print(("Score: " .. __str(score)))
    local y = 0
    while (y < SIZE) do
        __print("+----+----+----+----+")
        local line = "|"
        local x = 0
        while (x < SIZE) do
            local v = __index(__index(b, y), x)
            if __eq(v, 0) then
                line = __add(line, "    |")
            else
                line = (__add(line, pad(v)) .. "|")
            end
            x = __add(x, 1)
        end
        __print(line)
        y = __add(y, 1)
    end
    __print("+----+----+----+----+")
    __print("W=Up S=Down A=Left D=Right Q=Quit")
end

function reverseRow(r)
    local out = {}
    local i = (__count(r) - 1)
    while (i >= 0) do
        out = __append(out, r[i])
        i = (i - 1)
    end
    return out
end

function slideLeft(row)
    local xs = {}
    local i = 0
    while (i < #row) do
        if not __eq(__index(row, i), 0) then
            xs = __append(xs, __index(row, i))
        end
        i = __add(i, 1)
    end
    local res = {}
    local gain = 0
    i = 0
    while (i < #xs) do
        if ((__add(i, 1) < #xs) and (__index(xs, i) == __index(xs, __add(i, 1)))) then
            local v = (__index(xs, i) * 2)
            gain = __add(gain, v)
            res = __append(res, v)
            i = __add(i, 2)
        else
            res = __append(res, __index(xs, i))
            i = __add(i, 1)
        end
    end
    while (#res < SIZE) do
        res = __append(res, 0)
    end
    return {["row"]=res, ["gain"]=gain}
end

function moveLeft(b, score)
    local moved = false
    local y = 0
    while (y < SIZE) do
        local r = slideLeft(__index(b, y))
        local new = r["row"]
        score = __add(score, r["gain"])
        local x = 0
        while (x < SIZE) do
            if not __eq(__index(__index(b, y), x), __index(new, x)) then
                moved = true
            end
            b[y][x] = __index(new, x)
            x = __add(x, 1)
        end
        y = __add(y, 1)
    end
    return {["board"]=b, ["score"]=score, ["moved"]=moved}
end

function moveRight(b, score)
    local moved = false
    local y = 0
    while (y < SIZE) do
        local rev = reverseRow(__index(b, y))
        local r = slideLeft(rev)
        rev = r["row"]
        score = __add(score, r["gain"])
        rev = reverseRow(rev)
        local x = 0
        while (x < SIZE) do
            if not __eq(__index(__index(b, y), x), __index(rev, x)) then
                moved = true
            end
            b[y][x] = __index(rev, x)
            x = __add(x, 1)
        end
        y = __add(y, 1)
    end
    return {["board"]=b, ["score"]=score, ["moved"]=moved}
end

function getCol(b, x)
    local col = {}
    local y = 0
    while (y < SIZE) do
        col = __append(col, __index(__index(b, y), x))
        y = __add(y, 1)
    end
    return col
end

function setCol(b, x, col)
    local y = 0
    while (y < SIZE) do
        b[y][x] = __index(col, y)
        y = __add(y, 1)
    end
end

function moveUp(b, score)
    local moved = false
    local x = 0
    while (x < SIZE) do
        local col = getCol(b, x)
        local r = slideLeft(col)
        local new = r["row"]
        score = __add(score, r["gain"])
        local y = 0
        while (y < SIZE) do
            if not __eq(__index(__index(b, y), x), __index(new, y)) then
                moved = true
            end
            b[y][x] = __index(new, y)
            y = __add(y, 1)
        end
        x = __add(x, 1)
    end
    return {["board"]=b, ["score"]=score, ["moved"]=moved}
end

function moveDown(b, score)
    local moved = false
    local x = 0
    while (x < SIZE) do
        local col = reverseRow(getCol(b, x))
        local r = slideLeft(col)
        col = r["row"]
        score = __add(score, r["gain"])
        col = reverseRow(col)
        local y = 0
        while (y < SIZE) do
            if not __eq(__index(__index(b, y), x), __index(col, y)) then
                moved = true
            end
            b[y][x] = __index(col, y)
            y = __add(y, 1)
        end
        x = __add(x, 1)
    end
    return {["board"]=b, ["score"]=score, ["moved"]=moved}
end

function hasMoves(b)
    local y = 0
    while (y < SIZE) do
        local x = 0
        while (x < SIZE) do
            if __eq(__index(__index(b, y), x), 0) then
                return true
            end
            if ((__add(x, 1) < SIZE) and (__index(__index(b, y), x) == __index(__index(b, y), __add(x, 1)))) then
                return true
            end
            if ((__add(y, 1) < SIZE) and (__index(__index(b, y), x) == __index(__index(b, __add(y, 1)), x))) then
                return true
            end
            x = __add(x, 1)
        end
        y = __add(y, 1)
    end
    return false
end

function has2048(b)
    local y = 0
    while (y < SIZE) do
        local x = 0
        while (x < SIZE) do
            if (__index(__index(b, y), x) >= 2048) then
                return true
            end
            x = __add(x, 1)
        end
        y = __add(y, 1)
    end
    return false
end

SIZE = 4
board = newBoard()
r = spawnTile(board)
board = r["board"]
full = r["full"]
r = spawnTile(board)
board = r["board"]
full = r["full"]
score = 0
draw(board, score)
while true do
    __print("Move: ")
    local cmd = __input()
    local moved = false
    if (__eq(cmd, "a") or __eq(cmd, "A")) then
        local m = moveLeft(board, score)
        board = m["board"]
        score = m["score"]
        moved = m["moved"]
    end
    if (__eq(cmd, "d") or __eq(cmd, "D")) then
        local m = moveRight(board, score)
        board = m["board"]
        score = m["score"]
        moved = m["moved"]
    end
    if (__eq(cmd, "w") or __eq(cmd, "W")) then
        local m = moveUp(board, score)
        board = m["board"]
        score = m["score"]
        moved = m["moved"]
    end
    if (__eq(cmd, "s") or __eq(cmd, "S")) then
        local m = moveDown(board, score)
        board = m["board"]
        score = m["score"]
        moved = m["moved"]
    end
    if (__eq(cmd, "q") or __eq(cmd, "Q")) then
        break
    end
    if moved then
        local r2 = spawnTile(board)
        board = r2["board"]
        full = r2["full"]
        if (full and (not hasMoves(board))) then
            draw(board, score)
            __print("Game Over")
            break
        end
    end
    draw(board, score)
    if has2048(board) then
        __print("You win!")
        break
    end
    if not hasMoves(board) then
        __print("Game Over")
        break
    end
end
