-- Generated by Mochi compiler v0.10.26 on 2025-07-16T09:29:44Z
function __add(a, b)
    if type(a) == 'table' and type(b) == 'table' then
        local out = {}
        for i = 1, #a do out[#out+1] = a[i] end
        for i = 1, #b do out[#out+1] = b[i] end
        return out
    elseif type(a) == 'string' or type(b) == 'string' then
        return tostring(a) .. tostring(b)
    else
        return a + b
    end
end
function __append(lst, v)
    local out = {}
    if lst then for i = 1, #lst do out[#out+1] = lst[i] end end
    out[#out+1] = v
    return out
end
function __eq(a, b)
    if type(a) ~= type(b) then return false end
    if type(a) == 'number' then return math.abs(a-b) < 1e-9 end
    if type(a) ~= 'table' then return a == b end
    if (a[1] ~= nil or #a > 0) and (b[1] ~= nil or #b > 0) then
        if #a ~= #b then return false end
        for i = 1, #a do if not __eq(a[i], b[i]) then return false end end
        return true
    end
    for k, v in pairs(a) do if not __eq(v, b[k]) then return false end end
    for k, _ in pairs(b) do if a[k] == nil then return false end end
    return true
end
function __index(obj, i)
    if type(obj) == 'string' then
        return __indexString(obj, i)
    elseif type(obj) == 'table' then
        if obj[1] ~= nil or #obj > 0 then
            return obj[(i)+1]
        else
            return obj[i]
        end
    else
        error('cannot index')
    end
end
function __indexString(s, i)
    local len = #s
    if i < 0 then
        i = len + i + 1
    else
        i = i + 1
    end
    if i < 1 or i > len then error('index out of range') end
    return string.sub(s, i, i)
end
function __slice(obj, i, j)
    if i == nil then i = 0 end
    if type(obj) == 'string' then
        local len = #obj
        if j == nil then j = len end
        if i < 0 then i = len + i end
        if j < 0 then j = len + j end
        if i < 0 then i = 0 end
        if j > len then j = len end
        return string.sub(obj, i+1, j)
    elseif type(obj) == 'table' then
        local len = #obj
        if j == nil then j = len end
        if i < 0 then i = len + i end
        if j < 0 then j = len + j end
        if i < 0 then i = 0 end
        if j > len then j = len end
        local out = {}
        for k = i+1, j do
            out[#out+1] = obj[k]
        end
        return out
    else
        return {}
    end
end
function fields(s)
    local words = {}
    local cur = ""
    local i = 0
    while (i < #s) do
        local ch = __slice(s, i, __add(i, 1))
        if ((__eq(ch, " ") or __eq(ch, "\n")) or __eq(ch, "\t")) then
            if (#cur > 0) then
                words = __append(words, cur)
                cur = ""
            end
        else
            cur = __add(cur, ch)
        end
        i = __add(i, 1)
    end
    if (#cur > 0) then
        words = __append(words, cur)
    end
    return words
end

function padRight(s, width)
    local out = s
    local i = #s
    while (i < width) do
        out = __add(out, " ")
        i = __add(i, 1)
    end
    return out
end

function join(xs, sep)
    local res = ""
    local i = 0
    while (i < #xs) do
        if (i > 0) then
            res = __add(res, sep)
        end
        res = __add(res, __index(xs, i))
        i = __add(i, 1)
    end
    return res
end

function validate(commands, words, mins)
    local results = {}
    if (#words == 0) then
        return results
    end
    local wi = 0
    while (wi < #words) do
        local w = __index(words, wi)
        local found = false
        local wlen = #w
        local ci = 0
        while (ci < #commands) do
            local cmd = __index(commands, ci)
            if ((not __eq(__index(mins, ci), 0) and (wlen >= __index(mins, ci))) and (wlen <= #cmd)) then
                local c = upper(cmd)
                local ww = upper(w)
                if __eq(__slice(c, 0, wlen), ww) then
                    results = __append(results, c)
                    found = true
                    break
                end
            end
            ci = __add(ci, 1)
        end
        if not found then
            results = __append(results, "*error*")
        end
        wi = __add(wi, 1)
    end
    return results
end

function main()
    local table = (((((("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " .. "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ") .. "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ") .. " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ") .. "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ") .. "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ") .. "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp ")
    local commands = fields(table)
    local mins = {}
    local i = 0
    while (i < #commands) do
        local count = 0
        local j = 0
        local cmd = __index(commands, i)
        while (j < #cmd) do
            local ch = __slice(cmd, j, __add(j, 1))
            if ((ch >= "A") and (ch <= "Z")) then
                count = __add(count, 1)
            end
            j = __add(j, 1)
        end
        mins = __append(mins, count)
        i = __add(i, 1)
    end
    local sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"
    local words = fields(sentence)
    local results = validate(commands, words, mins)
    local out1 = "user words:  "
    local k = 0
    while (k < #words) do
        out1 = (__add(out1, padRight(__index(words, k), #__index(results, k))) .. " ")
        k = __add(k, 1)
    end
    print(out1)
    print(("full words:  " .. join(results, " ")))
end

main()
