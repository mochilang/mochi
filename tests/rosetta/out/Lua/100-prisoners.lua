-- Generated by Mochi compiler v0.10.26 on 2025-07-16T12:28:37Z
function __add(a, b)
    if type(a) == 'table' and type(b) == 'table' then
        local out = {}
        for i = 1, #a do out[#out+1] = a[i] end
        for i = 1, #b do out[#out+1] = b[i] end
        return out
    elseif type(a) == 'string' or type(b) == 'string' then
        return tostring(a) .. tostring(b)
    else
        return a + b
    end
end
function __append(lst, v)
    local out = {}
    if lst then for i = 1, #lst do out[#out+1] = lst[i] end end
    out[#out+1] = v
    return out
end
function __eq(a, b)
    if type(a) ~= type(b) then return false end
    if type(a) == 'number' then return math.abs(a-b) < 1e-9 end
    if type(a) ~= 'table' then return a == b end
    if (a[1] ~= nil or #a > 0) and (b[1] ~= nil or #b > 0) then
        if #a ~= #b then return false end
        for i = 1, #a do if not __eq(a[i], b[i]) then return false end end
        return true
    end
    for k, v in pairs(a) do if not __eq(v, b[k]) then return false end end
    for k, _ in pairs(b) do if a[k] == nil then return false end end
    return true
end
function __index(obj, i)
    if type(obj) == 'string' then
        return __indexString(obj, i)
    elseif type(obj) == 'table' then
        if obj[1] ~= nil or #obj > 0 then
            return obj[(i)+1]
        else
            return obj[i]
        end
    else
        error('cannot index')
    end
end
function __indexString(s, i)
    local len = #s
    if i < 0 then
        i = len + i + 1
    else
        i = i + 1
    end
    if i < 1 or i > len then error('index out of range') end
    return string.sub(s, i, i)
end
function __print(v)
    if type(v) == 'table' and (v[1] ~= nil or #v > 0) and type(v[1]) == 'table' then
        local parts = {}
        for i=1,#v do parts[#parts+1] = __str(v[i]) end
        print(table.concat(parts, ' '))
    else
        print(__str(v))
    end
end
function __str(v)
    local t = type(v)
    if t == 'table' then
        if v[1] ~= nil or #v > 0 then
            local parts = {}
            for i=1,#v do parts[#parts+1] = __str(v[i]) end
            return '['..table.concat(parts, ' ')..']'
        else
            local keys = {}
            for k in pairs(v) do keys[#keys+1] = k end
            table.sort(keys, function(a,b) return tostring(a)<tostring(b) end)
            local parts = {}
            for _,k in ipairs(keys) do parts[#parts+1] = __str(k)..':'..__str(v[k]) end
            return '{'..table.concat(parts, ',')..'}'
        end
    else
        return tostring(v)
    end
end
function shuffle(xs)
    local arr = xs
    local i = 99
    while (i > 0) do
        local j = (os.time()*1000000000 % (__add(i, 1)))
        local tmp = __index(arr, i)
        arr[i] = __index(arr, j)
        arr[j] = tmp
        i = (i - 1)
    end
    return arr
end

function doTrials(trials, np, strategy)
    local pardoned = 0
    local t = 0
    while (t < trials) do
        local drawers = {}
        local i = 0
        while (i < 100) do
            drawers = __append(drawers, i)
            i = __add(i, 1)
        end
        drawers = shuffle(drawers)
        local p = 0
        local success = true
        while (p < np) do
            local found = false
            if __eq(strategy, "optimal") then
                local prev = p
                local d = 0
                while (d < 50) do
                    local this = __index(drawers, prev)
                    if __eq(this, p) then
                        found = true
                        break
                    end
                    prev = this
                    d = __add(d, 1)
                end
            else
                local opened = {}
                local k = 0
                while (k < 100) do
                    opened = __append(opened, false)
                    k = __add(k, 1)
                end
                local d = 0
                while (d < 50) do
                    local n = (os.time()*1000000000 % 100)
                    while __index(opened, n) do
                        n = (os.time()*1000000000 % 100)
                    end
                    opened[n] = true
                    if __eq(__index(drawers, n), p) then
                        found = true
                        break
                    end
                    d = __add(d, 1)
                end
            end
            if not found then
                success = false
                break
            end
            p = __add(p, 1)
        end
        if success then
            pardoned = __add(pardoned, 1)
        end
        t = __add(t, 1)
    end
    local rf = (((pardoned) / (trials)) * 100.0)
    __print((((((__add("  strategy = ", strategy) .. "  pardoned = ") .. __str(pardoned)) .. " relative frequency = ") .. __str(rf)) .. "%"))
end

function main()
    local trials = 1000
    for _, np in ipairs({10, 100}) do
        __print((((("Results from " .. __str(trials)) .. " trials with ") .. __str(np)) .. " prisoners:\n"))
        for _, strat in ipairs({"random", "optimal"}) do
            doTrials(trials, np, strat)
        end
    end
end

main()
