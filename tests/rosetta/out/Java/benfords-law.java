// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:10:39Z
// benfords-law.mochi
import java.util.*;

public class BenfordsLaw {
    static double floorf(double x) {
        return Double.parseDouble(String.valueOf((Integer.parseInt(x))));
    }
    static int indexOf(String s, String ch) {
        int i = 0;
        while (i < s.length()) {
            if (Objects.equals(s.substring(i, i + 1), ch)) {
                return i;
            }
            i = (int)(i + 1);
        }
        return -1;
    }
    static String fmtF3(double x) {
        double y = floorf(x * 1000.000000 + 0.500000) / 1000.000000;
        String s = String.valueOf(y);
        int dot = indexOf(s, ".");
        if (Objects.equals(dot, 0 - 1)) {
            s = s + ".000";
        }
        else {
            int decs = s.length() - dot - 1;
            if (decs > 3) {
                s = s.substring(0, dot + 4);
            }
            else {
                while (decs < 3) {
                    s = s + "0";
                    decs = (int)(decs + 1);
                }
            }
        }
        return s;
    }
    static String padFloat3(double x, int width) {
        String s = fmtF3(x);
        while (s.length() < width) {
            s = " " + s;
        }
        return s;
    }
    static List<Double> fib1000() {
        double a = 0.000000;
        double b = 1.000000;
        List<Double> res = Arrays.asList();
        int i = 0;
        while (i < 1000) {
            res.add(b);
            double t = b;
            b = b + a;
            a = t;
            i = (int)(i + 1);
        }
        return res;
    }
    static int leadingDigit(double x) {
        if (x < 0.000000) {
            x = -x;
        }
        while (x >= 10.000000) {
            x = x / 10.000000;
        }
        while (x > 0.000000 && x < 1.000000) {
            x = x * 10.000000;
        }
        return Integer.parseInt(x);
    }
    static void show(List<? extends Number> nums, String title) {
        List<Integer> counts = new ArrayList<>(Arrays.asList(0, 0, 0, 0, 0, 0, 0, 0, 0));
        for (Number n : nums) {
            int d = leadingDigit(n);
            if (d >= 1 && d <= 9) {
                counts.set(d - 1, ((Number)counts.get(d - 1)).doubleValue() + 1);
            }
        }
        List<Double> preds = new ArrayList<>(Arrays.asList(0.301000, 0.176000, 0.125000, 0.097000, 0.079000, 0.067000, 0.058000, 0.051000, 0.046000));
        int total = nums.size();
        System.out.println(title);
        System.out.println("Digit  Observed  Predicted");
        int i = 0;
        while (i < 9) {
            double obs = ((Number)(Double.parseDouble(String.valueOf(((List)counts.get(i)))))).doubleValue() / (Double.parseDouble(String.valueOf(total)));
            int line = "  " + String.valueOf(i + 1) + "  " + padFloat3(obs, 9) + "  " + ((Number)padFloat3(preds.get(i), 8)).doubleValue();
            System.out.println(line);
            i = (int)(i + 1);
        }
    }
    static void main() {
        show(fib1000(), "First 1000 Fibonacci numbers");
    }
    static <T> List<T> append(List<T> list, T item) {
        List<T> res = new ArrayList<>(list);
        res.add(item);
        return res;
    }
    public static void main(String[] args) {
    main();
    }
}
