// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:09:23Z
// abelian-sandpile-model-identity.mochi
import java.util.*;

public class AbelianSandpileModelIdentity {
    static List<List<Integer>> neighborsList() {
        return Arrays.asList(Arrays.asList(1, 3), Arrays.asList(0, 2, 4), Arrays.asList(1, 5), Arrays.asList(0, 4, 6), Arrays.asList(1, 3, 5, 7), Arrays.asList(2, 4, 8), Arrays.asList(3, 7), Arrays.asList(4, 6, 8), Arrays.asList(5, 7));
    }
    static List<Integer> plus(List<Integer> a, List<Integer> b) {
        List<Integer> res = Arrays.asList();
        int i = 0;
        while (i < a.size()) {
            res.add(((Number)a.get(i)).doubleValue() + ((Number)b.get(i)).doubleValue());
            i = (int)(i + 1);
        }
        return res;
    }
    static boolean isStable(List<Integer> p) {
        for (Integer v : p) {
            if (v > 3) {
                return false;
            }
        }
        return true;
    }
    static int topple(List<Integer> p) {
        List<List<Integer>> neighbors = neighborsList();
        int i = 0;
        while (i < p.size()) {
            if (((Number)p.get(i)).doubleValue() > 3) {
                p.set(i, ((Number)p.get(i)).doubleValue() - 4);
                List<List<Integer>> nbs = neighbors.get(i);
                for (List<Integer> j : nbs) {
                    p.set(j, ((Number)p.get(j)).doubleValue() + 1);
                }
                return 0;
            }
            i = (int)(i + 1);
        }
        return 0;
    }
    static String pileString(List<Integer> p) {
        String s = "";
        int r = 0;
        while (r < 3) {
            int c = 0;
            while (c < 3) {
                s = ((Number)s + ((Number)String.valueOf(p.get(3 * r + c))).doubleValue()).doubleValue() + " ";
                c = (int)(c + 1);
            }
            s = s + "\n";
            r = (int)(r + 1);
        }
        return s;
    }
    static <T> List<T> append(List<T> list, T item) {
        List<T> res = new ArrayList<>(list);
        res.add(item);
        return res;
    }
    public static void main(String[] args) {
    System.out.println("Avalanche of topplings:\n");
    List<Integer> s4 = new ArrayList<>(Arrays.asList(4, 3, 3, 3, 1, 2, 0, 2, 3));
    System.out.println(pileString(s4));
    while (!isStable(s4)) {
        topple(s4);
        System.out.println(pileString(s4));
    }
    System.out.println("Commutative additions:\n");
    List<Integer> s1 = new ArrayList<>(Arrays.asList(1, 2, 0, 2, 1, 1, 0, 1, 3));
    List<Integer> s2 = new ArrayList<>(Arrays.asList(2, 1, 3, 1, 0, 1, 0, 1, 0));
    List<Integer> s3_a = plus(s1, s2);
    while (!isStable(s3_a)) {
        topple(s3_a);
    }
    List<Integer> s3_b = plus(s2, s1);
    while (!isStable(s3_b)) {
        topple(s3_b);
    }
    System.out.println(pileString(s1) + "\nplus\n\n" + pileString(s2) + "\nequals\n\n" + pileString(s3_a));
    System.out.println("and\n\n" + pileString(s2) + "\nplus\n\n" + pileString(s1) + "\nalso equals\n\n" + pileString(s3_b));
    System.out.println("Addition of identity sandpile:\n");
    List<Integer> s3 = new ArrayList<>(Arrays.asList(3, 3, 3, 3, 3, 3, 3, 3, 3));
    List<Integer> s3_id = new ArrayList<>(Arrays.asList(2, 1, 2, 1, 0, 1, 2, 1, 2));
    List<Integer> s4b = plus(s3, s3_id);
    while (!isStable(s4b)) {
        topple(s4b);
    }
    System.out.println(pileString(s3) + "\nplus\n\n" + pileString(s3_id) + "\nequals\n\n" + pileString(s4b));
    System.out.println("Addition of identities:\n");
    List<Integer> s5 = plus(s3_id, s3_id);
    while (!isStable(s5)) {
        topple(s5);
    }
    System.out.println(pileString(s3_id) + "\nplus\n\n" + pileString(s3_id) + "\nequals\n\n" + pileString(s5));
    }
}
