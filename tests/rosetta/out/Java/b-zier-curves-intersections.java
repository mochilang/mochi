// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
// b-zier-curves-intersections.mochi
import java.util.*;

class Point {
    double x;
    double y;
    Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Point other)) return false;
        return Objects.equals(this.x, other.x) && Objects.equals(this.y, other.y);
    }
    @Override public int hashCode() {
        return Objects.hash(x, y);
    }
}
class QuadSpline {
    double c0;
    double c1;
    double c2;
    QuadSpline(double c0, double c1, double c2) {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof QuadSpline other)) return false;
        return Objects.equals(this.c0, other.c0) && Objects.equals(this.c1, other.c1) && Objects.equals(this.c2, other.c2);
    }
    @Override public int hashCode() {
        return Objects.hash(c0, c1, c2);
    }
}
class QuadCurve {
    QuadSpline x;
    QuadSpline y;
    QuadCurve(QuadSpline x, QuadSpline y) {
        this.x = x;
        this.y = y;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof QuadCurve other)) return false;
        return Objects.equals(this.x, other.x) && Objects.equals(this.y, other.y);
    }
    @Override public int hashCode() {
        return Objects.hash(x, y);
    }
}
public class BZierCurvesIntersections {
    static double absf(double x) {
        if (x < 0.000000) {
            return -x;
        }
        return x;
    }
    static double maxf(double a, double b) {
        if (a > b) {
            return a;
        }
        return b;
    }
    static double minf(double a, double b) {
        if (a < b) {
            return a;
        }
        return b;
    }
    static double max3(double a, double b, double c) {
        double m = a;
        if (b > m) {
            m = b;
        }
        if (c > m) {
            m = c;
        }
        return m;
    }
    static double min3(double a, double b, double c) {
        double m = a;
        if (b < m) {
            m = b;
        }
        if (c < m) {
            m = c;
        }
        return m;
    }
    static List<QuadSpline> subdivideQuadSpline(QuadSpline q, double t) {
        double s = 1.000000 - t;
        QuadSpline u = new QuadSpline(q.c0, 0.000000, 0.000000);
        QuadSpline v = new QuadSpline(0.000000, 0.000000, q.c2);
        u.c1 = s * q.c0 + t * q.c1;
        v.c1 = s * q.c1 + t * q.c2;
        u.c2 = s * u.c1 + t * v.c1;
        v.c0 = u.c2;
        return Arrays.asList(u, v);
    }
    static List<QuadCurve> subdivideQuadCurve(QuadCurve q, double t) {
        List<QuadSpline> xs = subdivideQuadSpline(q.x, t);
        List<QuadSpline> ys = subdivideQuadSpline(q.y, t);
        QuadCurve u = new QuadCurve(xs.get(0), ys.get(0));
        QuadCurve v = new QuadCurve(xs.get(1), ys.get(1));
        return Arrays.asList(u, v);
    }
    static boolean rectsOverlap(double xa0, double ya0, double xa1, double ya1, double xb0, double yb0, double xb1, double yb1) {
        return xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1;
    }
    static Map<String,Object> testIntersect(QuadCurve p, QuadCurve q, double tol) {
        double pxmin = min3(p.x.c0, p.x.c1, p.x.c2);
        double pymin = min3(p.y.c0, p.y.c1, p.y.c2);
        double pxmax = max3(p.x.c0, p.x.c1, p.x.c2);
        double pymax = max3(p.y.c0, p.y.c1, p.y.c2);
        double qxmin = min3(q.x.c0, q.x.c1, q.x.c2);
        double qymin = min3(q.y.c0, q.y.c1, q.y.c2);
        double qxmax = max3(q.x.c0, q.x.c1, q.x.c2);
        double qymax = max3(q.y.c0, q.y.c1, q.y.c2);
        boolean exclude = true;
        boolean accept = false;
        Point inter = new Point(0.000000, 0.000000);
        if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
            exclude = false;
            double xmin = maxf(pxmin, qxmin);
            double xmax = minf(pxmax, qxmax);
            if (xmax - xmin <= tol) {
                double ymin = maxf(pymin, qymin);
                double ymax = minf(pymax, qymax);
                if (ymax - ymin <= tol) {
                    accept = true;
                    inter.x = 0.500000 * (xmin + xmax);
                    inter.y = 0.500000 * (ymin + ymax);
                }
            }
        }
        return new ExcludeAcceptIntersect(exclude, accept, inter);
    }
    static boolean seemsToBeDuplicate(List<Point> pts, Point xy, double spacing) {
        int i = 0;
        while (i < pts.size()) {
            List<Point> pt = pts.get(i);
            if (absf(pt.x - xy.x) < spacing && absf(pt.y - xy.y) < spacing) {
                return true;
            }
            i = (int)(i + 1);
        }
        return false;
    }
    static List<Point> findIntersects(QuadCurve p, QuadCurve q, double tol, double spacing) {
        List<Point> inters = Arrays.asList();
        List<Map<String,QuadCurve>> workload = Arrays.asList(new Workload(p, q));
        while (workload.size() > 0) {
            int idx = workload.size() - 1;
            List<Map<String,QuadCurve>> work = workload.get(idx);
            workload = ((List)workload).subList(0, idx);
            Map<String,Object> res = testIntersect(work.get("p"), work.get("q"), tol);
            Map<String,Object> excl = res.get("exclude");
            Map<String,Object> acc = res.get("accept");
            Point inter = (Point)((Map)res.get("intersect"));
            if (acc != null) {
                if (!((Boolean)seemsToBeDuplicate(inters, inter, spacing))) {
                    inters.add(inter);
                }
            }
        }
        return inters;
    }
    static void main() {
        QuadCurve p = new QuadCurve(new QuadSpline(-1.000000, 0.000000, 1.000000), new QuadSpline(0.000000, 10.000000, 0.000000));
        QuadCurve q = new QuadCurve(new QuadSpline(2.000000, -8.000000, 2.000000), new QuadSpline(1.000000, 2.000000, 3.000000));
        double tol = 0.000000;
        double spacing = tol * 10.000000;
        List<Point> inters = findIntersects(p, q, tol, spacing);
        int i = 0;
        while (i < inters.size()) {
            List<Point> pt = inters.get(i);
            System.out.println("(" + String.valueOf(pt.x) + ", " + String.valueOf(pt.y) + ")");
            i = (int)(i + 1);
        }
    }
    public static void main(String[] args) {
        main();
    }
}
