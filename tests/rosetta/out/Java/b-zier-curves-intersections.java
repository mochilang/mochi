// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:10:33Z
// b-zier-curves-intersections.mochi
import java.util.*;

class Point {
    double x;
    double y;
    Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Point other)) return false;
        return Objects.equals(this.x, other.x) && Objects.equals(this.y, other.y);
    }
    @Override public int hashCode() {
        return Objects.hash(x, y);
    }
}
class QuadSpline {
    double c0;
    double c1;
    double c2;
    QuadSpline(double c0, double c1, double c2) {
        this.c0 = c0;
        this.c1 = c1;
        this.c2 = c2;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof QuadSpline other)) return false;
        return Objects.equals(this.c0, other.c0) && Objects.equals(this.c1, other.c1) && Objects.equals(this.c2, other.c2);
    }
    @Override public int hashCode() {
        return Objects.hash(c0, c1, c2);
    }
}
class QuadCurve {
    Object x;
    Object y;
    QuadCurve(Object x, Object y) {
        this.x = x;
        this.y = y;
    }
    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof QuadCurve other)) return false;
        return Objects.equals(this.x, other.x) && Objects.equals(this.y, other.y);
    }
    @Override public int hashCode() {
        return Objects.hash(x, y);
    }
}
public class BZierCurvesIntersections {
    static double absf(double x) {
        if (x < 0.000000) {
            return -x;
        }
        return x;
    }
    static double maxf(double a, double b) {
        if (a > b) {
            return a;
        }
        return b;
    }
    static double minf(double a, double b) {
        if (a < b) {
            return a;
        }
        return b;
    }
    static double max3(double a, double b, double c) {
        double m = a;
        if (b > m) {
            m = b;
        }
        if (c > m) {
            m = c;
        }
        return m;
    }
    static double min3(double a, double b, double c) {
        double m = a;
        if (b < m) {
            m = b;
        }
        if (c < m) {
            m = c;
        }
        return m;
    }
    static List<Object> subdivideQuadSpline(Object q, double t) {
        double s = 1.000000 - t;
        QuadSpline u = new QuadSpline(((Map<?,?>)q).get("c0"), 0.000000, 0.000000);
        QuadSpline v = new QuadSpline(0.000000, 0.000000, ((Map<?,?>)q).get("c2"));
        u.c1 = ((Number)s * ((Number)((Map<?,?>)q).get("c0")).doubleValue()).doubleValue() + ((Number)t * ((Number)((Map<?,?>)q).get("c1")).doubleValue()).doubleValue();
        v.c1 = ((Number)s * ((Number)((Map<?,?>)q).get("c1")).doubleValue()).doubleValue() + ((Number)t * ((Number)((Map<?,?>)q).get("c2")).doubleValue()).doubleValue();
        u.c2 = s * u.c1 + t * v.c1;
        v.c0 = u.c2;
        return Arrays.asList(u, v);
    }
    static List<Object> subdivideQuadCurve(Object q, double t) {
        List<Object> xs = subdivideQuadSpline(((Map<?,?>)q).get("x"), t);
        List<Object> ys = subdivideQuadSpline(((Map<?,?>)q).get("y"), t);
        QuadCurve u = new QuadCurve(xs.get(0), ys.get(0));
        QuadCurve v = new QuadCurve(xs.get(1), ys.get(1));
        return Arrays.asList(u, v);
    }
    static boolean rectsOverlap(double xa0, double ya0, double xa1, double ya1, double xb0, double yb0, double xb1, double yb1) {
        return xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1;
    }
    static Map<String,Object> testIntersect(Object p, Object q, double tol) {
        double pxmin = min3(((Map<?,?>)p).get("x").c0, ((Map<?,?>)p).get("x").c1, ((Map<?,?>)p).get("x").c2);
        double pymin = min3(((Map<?,?>)p).get("y").c0, ((Map<?,?>)p).get("y").c1, ((Map<?,?>)p).get("y").c2);
        double pxmax = max3(((Map<?,?>)p).get("x").c0, ((Map<?,?>)p).get("x").c1, ((Map<?,?>)p).get("x").c2);
        double pymax = max3(((Map<?,?>)p).get("y").c0, ((Map<?,?>)p).get("y").c1, ((Map<?,?>)p).get("y").c2);
        double qxmin = min3(((Map<?,?>)q).get("x").c0, ((Map<?,?>)q).get("x").c1, ((Map<?,?>)q).get("x").c2);
        double qymin = min3(((Map<?,?>)q).get("y").c0, ((Map<?,?>)q).get("y").c1, ((Map<?,?>)q).get("y").c2);
        double qxmax = max3(((Map<?,?>)q).get("x").c0, ((Map<?,?>)q).get("x").c1, ((Map<?,?>)q).get("x").c2);
        double qymax = max3(((Map<?,?>)q).get("y").c0, ((Map<?,?>)q).get("y").c1, ((Map<?,?>)q).get("y").c2);
        boolean exclude = true;
        boolean accept = false;
        Point inter = new Point(0.000000, 0.000000);
        if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
            exclude = false;
            double xmin = maxf(pxmin, qxmin);
            double xmax = minf(pxmax, qxmax);
            if (xmax - xmin <= tol) {
                double ymin = maxf(pymin, qymin);
                double ymax = minf(pymax, qymax);
                if (ymax - ymin <= tol) {
                    accept = true;
                    inter.x = 0.500000 * (xmin + xmax);
                    inter.y = 0.500000 * (ymin + ymax);
                }
            }
        }
        return new ExcludeAcceptIntersect(exclude, accept, inter);
    }
    static boolean seemsToBeDuplicate(List<Object> pts, Object xy, double spacing) {
        int i = 0;
        while (i < pts.size()) {
            List<Object> pt = pts.get(i);
            if (((Number)absf(pt.x - ((Number)((Map<?,?>)xy).get("x")).doubleValue())).doubleValue() < spacing && ((Number)absf(pt.y - ((Number)((Map<?,?>)xy).get("y")).doubleValue())).doubleValue() < spacing) {
                return true;
            }
            i = (int)(i + 1);
        }
        return false;
    }
    static List<Object> findIntersects(Object p, Object q, double tol, double spacing) {
        List<Object> inters = Arrays.asList();
        List<Map<String,Object>> workload = Arrays.asList(new PQ(p, q));
        while (workload.size() > 0) {
            int idx = workload.size() - 1;
            List<Map<String,Object>> work = workload.get(idx);
            workload = ((List)workload).subList(0, idx);
            Map<String,Object> res = testIntersect(work.get("p"), work.get("q"), tol);
            Map<String,Object> excl = res.get("exclude");
            Map<String,Object> acc = res.get("accept");
            Object inter = (Object)((Map)res.get("intersect"));
            if (acc != null) {
                if (!seemsToBeDuplicate(inters, inter, spacing)) {
                    inters.add(inter);
                }
            }
        }
        return inters;
    }
    static void main() {
        QuadCurve p = new QuadCurve(new QuadSpline(-1.000000, 0.000000, 1.000000), new QuadSpline(0.000000, 10.000000, 0.000000));
        QuadCurve q = new QuadCurve(new QuadSpline(2.000000, -8.000000, 2.000000), new QuadSpline(1.000000, 2.000000, 3.000000));
        double tol = 0.000000;
        double spacing = tol * 10.000000;
        List<Object> inters = findIntersects(p, q, tol, spacing);
        int i = 0;
        while (i < inters.size()) {
            List<Object> pt = inters.get(i);
            System.out.println("(" + String.valueOf(pt.x) + ", " + String.valueOf(pt.y) + ")");
            i = (int)(i + 1);
        }
    }
    static <T> List<T> append(List<T> list, T item) {
        List<T> res = new ArrayList<>(list);
        res.add(item);
        return res;
    }
    public static void main(String[] args) {
    main();
    }
}
