// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
open System

type Anon1 = {
}
let square_to_maps (square) =
    let mutable emap: Anon1 = {  }
    let mutable dmap: Anon1 = {  }
    let mutable x: int = 0
    while x < List.length square do
        let row: obj = square.[x]
        let mutable y: int = 0
        while y < List.length row do
            let ch: obj = row.[y]
            emap.[ch] <- [x; y]
            dmap.[string x + "," + string y] <- ch
            y <- y + 1
        x <- x + 1
    dict [("e", emap); ("d", dmap)]
let remove_space (text) (emap) =
    let s: obj = upper text
    let mutable out: string = ""
    let mutable i: int = 0
    while i < List.length s do
        let ch: obj = s.[i..(i + 1-1)]
        if emap.ContainsKey ch <> " " && ch then
            out <- out + ch
        i <- i + 1
    out
let encrypt (text) (emap) (dmap) =
    text <- remove_space text emap
    let mutable row0: obj = [||]
    let mutable row1: obj = [||]
    let mutable i: int = 0
    while i < List.length text do
        let ch: obj = text.[i..(i + 1-1)]
        let xy: Anon1 = emap.[ch]
        row0 <- row0 @ [xy.[0]]
        row1 <- row1 @ [xy.[1]]
        i <- i + 1
    for v in row1 do
        row0 <- row0 @ [v]
    let mutable res: string = ""
    let mutable j: int = 0
    while j < List.length row0 do
        let key: obj = string row0.[j] + "," + string row0.[j + 1]
        res <- res + dmap.[key]
        j <- j + 2
    res
let decrypt (text) (emap) (dmap) =
    text <- remove_space text emap
    let mutable coords: obj = [||]
    let mutable i: int = 0
    while i < List.length text do
        let ch: obj = text.[i..(i + 1-1)]
        let xy: Anon1 = emap.[ch]
        coords <- coords @ [xy.[0]]
        coords <- coords @ [xy.[1]]
        i <- i + 1
    let mutable half: obj = List.length coords / 2
    let mutable k1: obj = [||]
    let mutable k2: obj = [||]
    let mutable idx: int = 0
    while idx < half do
        k1 <- k1 @ [coords.[idx]]
        idx <- idx + 1
    while idx < List.length coords do
        k2 <- k2 @ [coords.[idx]]
        idx <- idx + 1
    let mutable res: string = ""
    let mutable j: int = 0
    while j < half do
        let key: obj = string k1.[j] + "," + string k2.[j]
        res <- res + dmap.[key]
        j <- j + 1
    res
let main () =
    let squareRosetta: string list list = [["A"; "B"; "C"; "D"; "E"]; ["F"; "G"; "H"; "I"; "K"]; ["L"; "M"; "N"; "O"; "P"]; ["Q"; "R"; "S"; "T"; "U"]; ["V"; "W"; "X"; "Y"; "Z"]; ["J"; "1"; "2"; "3"; "4"]]
    let squareWikipedia: string list list = [["B"; "G"; "W"; "K"; "Z"]; ["Q"; "P"; "N"; "D"; "S"]; ["I"; "O"; "A"; "X"; "E"]; ["F"; "C"; "L"; "U"; "M"]; ["T"; "H"; "Y"; "V"; "R"]; ["J"; "1"; "2"; "3"; "4"]]
    let textRosetta: string = "0ATTACKATDAWN"
    let textWikipedia: string = "FLEEATONCE"
    let textTest: string = "The invasion will start on the first of January"
    let mutable maps: obj = square_to_maps squareRosetta
    let mutable emap: obj = maps.["e"]
    let mutable dmap: obj = maps.["d"]
    printfn "%s" "from Rosettacode"
    printfn "%s" ("original:\t " + textRosetta)
    let mutable s: obj = encrypt textRosetta emap dmap
    printfn "%s" ("codiert:\t " + s)
    s <- decrypt s emap dmap
    printfn "%s" ("and back:\t " + s)
    maps <- square_to_maps squareWikipedia
    emap <- maps.["e"]
    dmap <- maps.["d"]
    printfn "%s" "from Wikipedia"
    printfn "%s" ("original:\t " + textWikipedia)
    s <- encrypt textWikipedia emap dmap
    printfn "%s" ("codiert:\t " + s)
    s <- decrypt s emap dmap
    printfn "%s" ("and back:\t " + s)
    maps <- square_to_maps squareWikipedia
    emap <- maps.["e"]
    dmap <- maps.["d"]
    printfn "%s" "from Rosettacode long part"
    printfn "%s" ("original:\t " + textTest)
    s <- encrypt textTest emap dmap
    printfn "%s" ("codiert:\t " + s)
    s <- decrypt s emap dmap
    printfn "%s" ("and back:\t " + s)
printfn "%A" (main())
