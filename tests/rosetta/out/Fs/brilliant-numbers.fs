// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
open System

exception Break
exception Continue

let primesUpTo (n) =
    let mutable sieve: obj = [||]
    let mutable i: int = 0
    while i <= n do
        sieve <- sieve @ [true]
        i <- i + 1
    let mutable p: int = 2
    while p * p <= n do
        if sieve.[p] then
            let mutable m: int = p * p
            while m <= n do
                sieve.[m] <- false
                m <- m + p
        p <- p + 1
    let mutable res: obj = [||]
    let mutable x: int = 2
    while x <= n do
        if sieve.[x] then
            res <- res @ [x]
        x <- x + 1
    res
let sortInts (xs) =
    let mutable res: obj = [||]
    let mutable tmp: obj = xs
    while List.length tmp > 0 do
        let mutable min: obj = tmp.[0]
        let mutable idx: int = 0
        let mutable i: int = 1
        while i < List.length tmp do
            if tmp.[i] < min then
                min <- tmp.[i]
                idx <- i
            i <- i + 1
        res <- res @ [min]
        let mutable out: obj = [||]
        let mutable j: int = 0
        while j < List.length tmp do
            if j <> idx then
                out <- out @ [tmp.[j]]
            j <- j + 1
        tmp <- out
    res
let commatize (n) =
    let mutable s: obj = string n
    let mutable i: obj = List.length s - 3
    while i >= 1 do
        s <- s.[0..(i-1)] + "," + s.[i..(List.length s-1)]
        i <- i - 3
    s
let mutable primes: obj = primesUpTo 3200000
let getBrilliant (digits) (limit) (countOnly) =
    let mutable brilliant: obj = [||]
    let mutable count: int = 0
    let mutable pow: int = 1
    let mutable next: int = 999999999999999
    let mutable k: int = 1
    try
        while k <= digits do
            try
                let mutable s: obj = [||]
                try
                    for p in primes do
                        try
                            if p >= pow * 10 then
                                raise Break
                            if p > pow then
                                s <- s @ [p]
                        with Continue -> ()
                    with Break -> ()
                    let mutable i: int = 0
                    try
                        while i < List.length s do
                            try
                                let mutable j: int = i
                                try
                                    while j < List.length s do
                                        try
                                            let mutable prod: obj = s.[i] * s.[j]
                                            if prod < limit then
                                                if countOnly then
                                                    count <- count + 1
                                                else
                                                    brilliant <- brilliant @ [prod]
                                            else
                                                if prod < next then
                                                    next <- prod
                                                raise Break
                                            j <- j + 1
                                        with Continue -> ()
                                with Break -> ()
                                i <- i + 1
                            with Continue -> ()
                    with Break -> ()
                    pow <- pow * 10
                    k <- k + 1
                with Continue -> ()
        with Break -> ()
        if countOnly then
            dict [("bc", count); ("next", next)]
        dict [("bc", brilliant); ("next", next)]
    let main () =
        printfn "%s" "First 100 brilliant numbers:"
        let r: obj = getBrilliant 2 10000 false
        let mutable br: obj = sortInts r.["bc"]
        br <- br.[0..(100-1)]
        let mutable i: int = 0
        while i < List.length br do
            printfn "%s" (String.concat " " [string string br.[i].padStart(4, " ") + " "; sprintf "%b" false])
            if (i + 1) % 10 = 0 then
                printfn "%s" (String.concat " " [string ""; sprintf "%b" true])
            i <- i + 1
        printfn "%s" (String.concat " " [string ""; sprintf "%b" true])
        let mutable k: int = 1
        while k <= 13 do
            let limit: obj = pow 10 k
            let r2: obj = getBrilliant k limit true
            let total: obj = r2.["bc"]
            let next: obj = r2.["next"]
            let climit: obj = commatize limit
            let ctotal: obj = commatize total + 1
            let cnext: obj = commatize next
            printfn "%s" ("First >= " + climit.padStart(18, " ") + " is " + ctotal.padStart(14, " ") + " in the series: " + cnext.padStart(18, " "))
            k <- k + 1
