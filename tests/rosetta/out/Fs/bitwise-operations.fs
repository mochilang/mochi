// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
open System

let toUnsigned16 (n) =
    let mutable u: obj = n
    if u < 0 then
        u <- u + 65536
    u % 65536
let bin16 (n) =
    let mutable u: obj = toUnsigned16 n
    let mutable bits: string = ""
    let mutable mask: int = 32768
    for i in 0 .. 16 do
        if u >= mask then
            bits <- bits + "1"
            u <- u - mask
        else
            bits <- bits + "0"
        mask <- (mask / 2)
    bits
let bit_and (a) (b) =
    let mutable ua: obj = toUnsigned16 a
    let mutable ub: obj = toUnsigned16 b
    let mutable res: int = 0
    let mutable bit: int = 1
    for i in 0 .. 16 do
        if ua % 2 = 1 && ub % 2 = 1 then
            res <- res + bit
        ua <- (ua / 2)
        ub <- (ub / 2)
        bit <- bit * 2
    res
let bit_or (a) (b) =
    let mutable ua: obj = toUnsigned16 a
    let mutable ub: obj = toUnsigned16 b
    let mutable res: int = 0
    let mutable bit: int = 1
    for i in 0 .. 16 do
        if ua % 2 = 1 || ub % 2 = 1 then
            res <- res + bit
        ua <- (ua / 2)
        ub <- (ub / 2)
        bit <- bit * 2
    res
let bit_xor (a) (b) =
    let mutable ua: obj = toUnsigned16 a
    let mutable ub: obj = toUnsigned16 b
    let mutable res: int = 0
    let mutable bit: int = 1
    for i in 0 .. 16 do
        let abit: obj = ua % 2
        let bbit: obj = ub % 2
        if (abit = 1 && bbit = 0) || (abit = 0 && bbit = 1) then
            res <- res + bit
        ua <- (ua / 2)
        ub <- (ub / 2)
        bit <- bit * 2
    res
let bit_not (a) =
    let mutable ua: obj = toUnsigned16 a
    65535 - ua
let shl (a) (b) =
    let mutable ua: obj = toUnsigned16 a
    let mutable i: int = 0
    while i < b do
        ua <- (ua * 2) % 65536
        i <- i + 1
    ua
let shr (a) (b) =
    let mutable ua: obj = toUnsigned16 a
    let mutable i: int = 0
    while i < b do
        ua <- (ua / 2)
        i <- i + 1
    ua
let las (a) (b) =
    shl a b
let ras (a) (b) =
    let mutable val: obj = a
    let mutable i: int = 0
    while i < b do
        if val >= 0 then
            val <- (val / 2)
        else
            val <- ((val - 1) / 2)
        i <- i + 1
    toUnsigned16 val
let rol (a) (b) =
    let mutable ua: obj = toUnsigned16 a
    let left: obj = shl ua b
    let right: obj = shr ua 16 - b
    toUnsigned16 left + right
let ror (a) (b) =
    let mutable ua: obj = toUnsigned16 a
    let right: obj = shr ua b
    let left: obj = shl ua 16 - b
    toUnsigned16 left + right
let bitwise (a) (b) =
    printfn "%s" ("a:   " + bin16 a)
    printfn "%s" ("b:   " + bin16 b)
    printfn "%s" ("and: " + bin16 bit_and a b)
    printfn "%s" ("or:  " + bin16 bit_or a b)
    printfn "%s" ("xor: " + bin16 bit_xor a b)
    printfn "%s" ("not: " + bin16 bit_not a)
    if b < 0 then
        printfn "%s" "Right operand is negative, but all shifts require an unsigned right operand (shift distance)."
        ()
    printfn "%s" ("shl: " + bin16 shl a b)
    printfn "%s" ("shr: " + bin16 shr a b)
    printfn "%s" ("las: " + bin16 las a b)
    printfn "%s" ("ras: " + bin16 ras a b)
    printfn "%s" ("rol: " + bin16 rol a b)
    printfn "%s" ("ror: " + bin16 ror a b)
printfn "%A" (bitwise -460 6)
