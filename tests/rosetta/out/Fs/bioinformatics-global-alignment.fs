// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
open System

exception Break
exception Continue

let padLeft (s) (w) =
    let mutable res: string = ""
    let mutable n: obj = w - List.length s
    while n > 0 do
        res <- res + " "
        n <- n - 1
    res + s
let indexOfFrom (s) (ch) (start) =
    let mutable i: obj = start
    while i < List.length s do
        if s.Substring(i, i + 1 - i) = ch then
            i
        i <- i + 1
    -1
let containsStr (s) (sub) =
    let mutable i: int = 0
    let sl: obj = List.length s
    let subl: obj = List.length sub
    while i <= sl - subl do
        if s.Substring(i, i + subl - i) = sub then
            true
        i <- i + 1
    false
let distinct (slist) =
    let mutable res: obj = [||]
    try
        for s in slist do
            try
                let mutable found: bool = false
                try
                    for r in res do
                        try
                            if r = s then
                                found <- true
                                raise Break
                        with Continue -> ()
                    with Break -> ()
                    if not found then
                        res <- res @ [s]
                with Continue -> ()
            with Break -> ()
            res
        let permutations (xs) =
            if List.length xs <= 1 then
                [xs]
            let mutable res: obj = [||]
            let mutable i: int = 0
            while i < List.length xs do
                let mutable rest: obj = [||]
                let mutable j: int = 0
                while j < List.length xs do
                    if j <> i then
                        rest <- rest @ [xs.[j]]
                    j <- j + 1
                let subs: obj = permutations rest
                for p in subs do
                    let mutable perm: obj list = [|xs.[i]|]
                    let mutable k: int = 0
                    while k < List.length p do
                        perm <- perm @ [p.[k]]
                        k <- k + 1
                    res <- res @ [perm]
                i <- i + 1
            res
        let headTailOverlap (s1) (s2) =
            let mutable start: int = 0
            while true do
                let ix: obj = indexOfFrom s1 s2.[0..(1-1)] start
                if ix = 0 - 1 then
                    0
                start <- ix
                if s2.Substring(0, List.length s1 - start - 0) = s1.Substring(start, List.length s1 - start) then
                    List.length s1 - start
                start <- start + 1
        let deduplicate (slist) =
            let arr: obj = distinct slist
            let mutable filtered: obj = [||]
            let mutable i: int = 0
            try
                while i < List.length arr do
                    try
                        let s1: obj = arr.[i]
                        let mutable within: bool = false
                        let mutable j: int = 0
                        try
                            while j < List.length arr do
                                try
                                    if j <> i && containsStr arr.[j] s1 then
                                        within <- true
                                        raise Break
                                    j <- j + 1
                                with Continue -> ()
                        with Break -> ()
                        if not within then
                            filtered <- filtered @ [s1]
                        i <- i + 1
                    with Continue -> ()
            with Break -> ()
            filtered
        let joinAll (ss) =
            let mutable out: string = ""
            for s in ss do
                out <- out + s
            out
        let shortestCommonSuperstring (slist) =
            let ss: obj = deduplicate slist
            let mutable shortest: obj = joinAll ss
            let perms: obj = permutations ss
            let mutable idx: int = 0
            while idx < List.length perms do
                let perm: obj = perms.[idx]
                let mutable sup: obj = perm.[0]
                let mutable i: int = 0
                while i < List.length ss - 1 do
                    let ov: obj = headTailOverlap perm.[i] perm.[i + 1]
                    sup <- sup + perm.[i + 1].Substring(ov, List.length perm.[i + 1] - ov)
                    i <- i + 1
                if List.length sup < List.length shortest then
                    shortest <- sup
                idx <- idx + 1
            shortest
        let printCounts (seq) =
            let mutable a: int = 0
            let mutable c: int = 0
            let mutable g: int = 0
            let mutable t: int = 0
            let mutable i: int = 0
            while i < List.length seq do
                let ch: obj = seq.Substring(i, i + 1 - i)
                if ch = "A" then
                    a <- a + 1
                else
                    if ch = "C" then
                        c <- c + 1
                    else
                        if ch = "G" then
                            g <- g + 1
                        else
                            if ch = "T" then
                                t <- t + 1
                i <- i + 1
            let total: obj = List.length seq
            printfn "%s" "\nNucleotide counts for " + seq + ":\n"
            printfn "%A" (padLeft "A" 10 + padLeft string a 12)
            printfn "%A" (padLeft "C" 10 + padLeft string c 12)
            printfn "%A" (padLeft "G" 10 + padLeft string g 12)
            printfn "%A" (padLeft "T" 10 + padLeft string t 12)
            printfn "%A" (padLeft "Other" 10 + padLeft string total - (a + c + g + t) 12)
            printfn "%s" "  ____________________"
            printfn "%A" (padLeft "Total length" 14 + padLeft string total 8)
        let main () =
            let tests: string list list = [["TA"; "AAG"; "TA"; "GAA"; "TA"]; ["CATTAGGG"; "ATTAG"; "GGG"; "TA"]; ["AAGAUGGA"; "GGAGCGCAUC"; "AUCGCAAUAAGGA"]; ["ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT"; "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT"; "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"; "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC"; "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT"; "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC"; "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT"; "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC"; "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC"; "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT"; "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC"; "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"; "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"]]
            for seqs in tests do
                let scs: obj = shortestCommonSuperstring seqs
                printfn "%A" (printCounts scs)
        printfn "%A" (main())
