// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
open System

let sieve (limit) =
    let mutable spf: obj = [||]
    let mutable i: int = 0
    while i <= limit do
        spf <- spf @ [0]
        i <- i + 1
    i <- 2
    while i <= limit do
        if spf.[i] = 0 then
            spf.[i] <- i
            if i * i <= limit then
                let mutable j: int = i * i
                while j <= limit do
                    if spf.[j] = 0 then
                        spf.[j] <- i
                    j <- j + i
        i <- i + 1
    spf
let primesFrom (spf) (limit) =
    let mutable primes: obj = [||]
    let mutable i: int = 3
    while i <= limit do
        if spf.[i] = i then
            primes <- primes @ [i]
        i <- i + 1
    primes
let pad3 (n) =
    let mutable s: obj = string n
    while List.length s < 3 do
        s <- " " + s
    s
let commatize (n) =
    let mutable s: obj = string n
    let mutable out: string = ""
    let mutable i: obj = List.length s - 1
    let mutable c: int = 0
    while i >= 0 do
        out <- s.Substring(i, i + 1 - i) + out
        c <- c + 1
        if c % 3 = 0 && i > 0 then
            out <- "," + out
        i <- i - 1
    out
let primeCount (primes) (last) (spf) =
    let mutable lo: int = 0
    let mutable hi: obj = List.length primes
    while lo < hi do
        let mutable mid: obj = ((lo + hi) / 2)
        if primes.[mid] < last then
            lo <- mid + 1
        else
            hi <- mid
    let mutable count: int = lo + 1
    if spf.[last] <> last then
        count <- count - 1
    count
let arithmeticNumbers (limit) (spf) =
    let mutable arr: int list = [|1|]
    let mutable n: int = 3
    while List.length arr < limit do
        if spf.[n] = n then
            arr <- arr @ [n]
        else
            let mutable x: int = n
            let mutable sigma: int = 1
            let mutable tau: int = 1
            while x > 1 do
                let mutable p: obj = spf.[x]
                if p = 0 then
                    p <- x
                let mutable cnt: int = 0
                let mutable power: obj = p
                let mutable sum: int = 1
                while x % p = 0 do
                    x <- x / p
                    cnt <- cnt + 1
                    sum <- sum + power
                    power <- power * p
                sigma <- sigma * sum
                tau <- tau * (cnt + 1)
            if sigma % tau = 0 then
                arr <- arr @ [n]
        n <- n + 1
    arr
let main () =
    let limit: int = 1228663
    let spf: obj = sieve limit
    let primes: obj = primesFrom spf limit
    let arr: obj = arithmeticNumbers 1000000 spf
    printfn "%s" "The first 100 arithmetic numbers are:"
    let mutable i: int = 0
    while i < 100 do
        let mutable line: string = ""
        let mutable j: int = 0
        while j < 10 do
            line <- line + pad3 arr.[i + j]
            if j < 9 then
                line <- line + " "
            j <- j + 1
        printfn "%s" line
        i <- i + 10
    for x in [1000; 10000; 100000; 1000000] do
        let last: obj = arr.[x - 1]
        let lastc: obj = commatize last
        printfn "%s" ("\nThe " + commatize x + "th arithmetic number is: " + lastc)
        let pc: obj = primeCount primes last spf
        let comp: int = x - pc - 1
        printfn "%s" "The count of such numbers <= " + lastc + " which are composite is " + commatize comp + "."
printfn "%A" (main())
