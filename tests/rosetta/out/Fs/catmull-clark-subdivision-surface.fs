// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
open System

exception Break
exception Continue

type Anon1 = {
    x: float
    y: float
    z: float
}
type Anon2 = {
}
type Point = {
    mutable x: float
    mutable y: float
    mutable z: float
}
type Edge = {
    mutable pn1: int
    mutable pn2: int
    mutable fn1: int
    mutable fn2: int
    mutable cp: Point
}
type PointEx = {
    mutable p: Point
    mutable n: int
}
let indexOf (s) (ch) =
    let mutable i: int = 0
    while i < List.length s do
        if s.Substring(i, i + 1 - i) = ch then
            i
        i <- i + 1
    -1
let fmt4 (x) =
    let mutable y: obj = x * 10000.0
    if y >= 0 then
        y <- y + 0.5
    else
        y <- y - 0.5
    y <- (y) / 10000.0
    let mutable s: obj = string y
    let mutable dot: obj = indexOf s "."
    if dot = 0 - 1 then
        s <- s + ".0000"
    else
        let mutable decs: obj = List.length s - dot - 1
        if decs > 4 then
            s <- s.Substring(0, dot + 5 - 0)
        else
            while decs < 4 do
                s <- s + "0"
                decs <- decs + 1
    if x >= 0.0 then
        s <- " " + s
    s
let fmt2 (n) =
    let s: obj = string n
    if List.length s < 2 then
        " " + s
    s
let sumPoint (p1) (p2) =
    { x = p1.x + p2.x; y = p1.y + p2.y; z = p1.z + p2.z }
let mulPoint (p) (m) =
    { x = p.x * m; y = p.y * m; z = p.z * m }
let divPoint (p) (d) =
    mulPoint p 1.0 / d
let centerPoint (p1) (p2) =
    divPoint sumPoint p1 p2 2.0
let getFacePoints (points) (faces) =
    let mutable facePoints: obj = [||]
    let mutable i: int = 0
    while i < List.length faces do
        let face: obj = faces.[i]
        let mutable fp: Anon1 = { x = 0.0; y = 0.0; z = 0.0 }
        for idx in face do
            fp <- sumPoint fp points.[idx]
        fp <- divPoint fp (List.length face)
        facePoints <- facePoints @ [fp]
        i <- i + 1
    facePoints
let sortEdges (edges) =
    let mutable res: obj = [||]
    let mutable tmp: obj = edges
    while List.length tmp > 0 do
        let mutable min: obj = tmp.[0]
        let mutable idx: int = 0
        let mutable j: int = 1
        while j < List.length tmp do
            let e: obj = tmp.[j]
            if e.[0] < min.[0] || (e.[0] = min.[0] && (e.[1] < min.[1] || (e.[1] = min.[1] && e.[2] < min.[2]))) then
                min <- e
                idx <- j
            j <- j + 1
        res <- res @ [min]
        let mutable out: obj = [||]
        let mutable k: int = 0
        while k < List.length tmp do
            if k <> idx then
                out <- out @ [tmp.[k]]
            k <- k + 1
        tmp <- out
    res
let getEdgesFaces (points) (faces) =
    let mutable edges: obj = [||]
    let mutable fnum: int = 0
    while fnum < List.length faces do
        let face: obj = faces.[fnum]
        let mutable numP: obj = List.length face
        let mutable pi: int = 0
        while pi < numP do
            let mutable pn1: obj = face.[pi]
            let mutable pn2: int = 0
            if pi < numP - 1 then
                pn2 <- face.[pi + 1]
            else
                pn2 <- face.[0]
            if pn1 > pn2 then
                let mutable tmpn: obj = pn1
                pn1 <- pn2
                pn2 <- tmpn
            edges <- edges @ [[pn1; pn2; fnum]]
            pi <- pi + 1
        fnum <- fnum + 1
    edges <- sortEdges edges
    let mutable merged: obj = [||]
    let mutable idx: int = 0
    try
        while idx < List.length edges do
            try
                let e1: obj = edges.[idx]
                if idx < List.length edges - 1 then
                    let e2: obj = edges.[idx + 1]
                    if e1.[0] = e2.[0] && e1.[1] = e2.[1] then
                        merged <- merged @ [[e1.[0]; e1.[1]; e1.[2]; e2.[2]]]
                        idx <- idx + 2
                        raise Continue
                merged <- merged @ [[e1.[0]; e1.[1]; e1.[2]; -1]]
                idx <- idx + 1
            with Continue -> ()
    with Break -> ()
    let mutable edgesCenters: obj = [||]
    for me in merged do
        let p1: obj = points.[me.[0]]
        let p2: obj = points.[me.[1]]
        let cp: obj = centerPoint p1 p2
        edgesCenters <- edgesCenters @ [{ pn1 = me.[0]; pn2 = me.[1]; fn1 = me.[2]; fn2 = me.[3]; cp = cp }]
    edgesCenters
let getEdgePoints (points) (edgesFaces) (facePoints) =
    let mutable edgePoints: obj = [||]
    let mutable i: int = 0
    while i < List.length edgesFaces do
        let edge: obj = edgesFaces.[i]
        let cp: obj = edge.cp
        let fp1: obj = facePoints.[edge.fn1]
        let mutable fp2: obj = fp1
        if edge.fn2 <> 0 - 1 then
            fp2 <- facePoints.[edge.fn2]
        let cfp: obj = centerPoint fp1 fp2
        edgePoints <- edgePoints @ [centerPoint cp cfp]
        i <- i + 1
    edgePoints
let getAvgFacePoints (points) (faces) (facePoints) =
    let mutable numP: obj = List.length points
    let mutable temp: obj = [||]
    let mutable i: int = 0
    while i < numP do
        temp <- temp @ [{ p = { x = 0.0; y = 0.0; z = 0.0 }; n = 0 }]
        i <- i + 1
    let mutable fnum: int = 0
    while fnum < List.length faces do
        let fp: obj = facePoints.[fnum]
        for pn in faces.[fnum] do
            let tp: obj = temp.[pn]
            temp.[pn] <- { p = sumPoint tp.p fp; n = tp.n + 1 }
        fnum <- fnum + 1
    let mutable avg: obj = [||]
    let mutable j: int = 0
    while j < numP do
        let tp: obj = temp.[j]
        avg <- avg @ [divPoint tp.p tp.n]
        j <- j + 1
    avg
let getAvgMidEdges (points) (edgesFaces) =
    let mutable numP: obj = List.length points
    let mutable temp: obj = [||]
    let mutable i: int = 0
    while i < numP do
        temp <- temp @ [{ p = { x = 0.0; y = 0.0; z = 0.0 }; n = 0 }]
        i <- i + 1
    for edge in edgesFaces do
        let cp: obj = edge.cp
        let mutable arr: obj list = [|edge.pn1; edge.pn2|]
        for pn in arr do
            let tp: obj = temp.[pn]
            temp.[pn] <- { p = sumPoint tp.p cp; n = tp.n + 1 }
    let mutable avg: obj = [||]
    let mutable j: int = 0
    while j < numP do
        let tp: obj = temp.[j]
        avg <- avg @ [divPoint tp.p tp.n]
        j <- j + 1
    avg
let getPointsFaces (points) (faces) =
    let mutable pf: obj = [||]
    let mutable i: int = 0
    while i < List.length points do
        pf <- pf @ [0]
        i <- i + 1
    let mutable fnum: int = 0
    while fnum < List.length faces do
        for pn in faces.[fnum] do
            pf.[pn] <- pf.[pn] + 1
        fnum <- fnum + 1
    pf
let getNewPoints (points) (pf) (afp) (ame) =
    let mutable newPts: obj = [||]
    let mutable i: int = 0
    while i < List.length points do
        let mutable n: obj = pf.[i]
        let mutable m1: obj = (n - 3.0) / n
        let mutable m2: float = 1.0 / n
        let mutable m3: float = 2.0 / n
        let old: obj = points.[i]
        let p1: obj = mulPoint old m1
        let p2: obj = mulPoint afp.[i] m2
        let p3: obj = mulPoint ame.[i] m3
        newPts <- newPts @ [sumPoint sumPoint p1 p2 p3]
        i <- i + 1
    newPts
let key (a) (b) =
    if a < b then
        string a + "," + string b
    string b + "," + string a
let cmcSubdiv (points) (faces) =
    let facePoints: obj = getFacePoints points faces
    let edgesFaces: obj = getEdgesFaces points faces
    let edgePoints: obj = getEdgePoints points edgesFaces facePoints
    let avgFacePoints: obj = getAvgFacePoints points faces facePoints
    let avgMidEdges: obj = getAvgMidEdges points edgesFaces
    let pointsFaces: obj = getPointsFaces points faces
    let mutable newPoints: obj = getNewPoints points pointsFaces avgFacePoints avgMidEdges
    let mutable facePointNums: obj = [||]
    let mutable nextPoint: obj = List.length newPoints
    for fp in facePoints do
        newPoints <- newPoints @ [fp]
        facePointNums <- facePointNums @ [nextPoint]
        nextPoint <- nextPoint + 1
    let mutable edgePointNums: Anon2 = {  }
    let mutable idx: int = 0
    while idx < List.length edgesFaces do
        let e: obj = edgesFaces.[idx]
        newPoints <- newPoints @ [edgePoints.[idx]]
        edgePointNums.[key e.pn1 e.pn2] <- nextPoint
        nextPoint <- nextPoint + 1
        idx <- idx + 1
    let mutable newFaces: obj = [||]
    let mutable fnum: int = 0
    while fnum < List.length faces do
        let oldFace: obj = faces.[fnum]
        if List.length oldFace = 4 then
            let a: obj = oldFace.[0]
            let b: obj = oldFace.[1]
            let c: obj = oldFace.[2]
            let d: obj = oldFace.[3]
            let fpnum: obj = facePointNums.[fnum]
            let ab: Anon2 = edgePointNums.[key a b]
            let da: Anon2 = edgePointNums.[key d a]
            let bc: Anon2 = edgePointNums.[key b c]
            let cd: Anon2 = edgePointNums.[key c d]
            newFaces <- newFaces @ [[a; ab; fpnum; da]]
            newFaces <- newFaces @ [[b; bc; fpnum; ab]]
            newFaces <- newFaces @ [[c; cd; fpnum; bc]]
            newFaces <- newFaces @ [[d; da; fpnum; cd]]
        fnum <- fnum + 1
    [newPoints; newFaces]
let formatPoint (p) =
    "[" + fmt4 p.x + " " + fmt4 p.y + " " + fmt4 p.z + "]"
let formatFace (f) =
    if List.length f = 0 then
        "[]"
    let mutable s: string = "[" + fmt2 f.[0]
    let mutable i: int = 1
    while i < List.length f do
        s <- s + " " + fmt2 f.[i]
        i <- i + 1
    s <- s + "]"
    s
let main () =
    let inputPoints: Anon1 list = [{ x = -1.0; y = 1.0; z = 1.0 }; { x = -1.0; y = -1.0; z = 1.0 }; { x = 1.0; y = -1.0; z = 1.0 }; { x = 1.0; y = 1.0; z = 1.0 }; { x = 1.0; y = -1.0; z = -1.0 }; { x = 1.0; y = 1.0; z = -1.0 }; { x = -1.0; y = -1.0; z = -1.0 }; { x = -1.0; y = 1.0; z = -1.0 }]
    let inputFaces: int list list = [[0; 1; 2; 3]; [3; 2; 4; 5]; [5; 4; 6; 7]; [7; 0; 3; 5]; [7; 6; 1; 0]; [6; 1; 2; 4]]
    let mutable outputPoints: Anon1 list = inputPoints
    let mutable outputFaces: int list list = inputFaces
    let mutable i: int = 0
    while i < 1 do
        let res: obj = cmcSubdiv outputPoints outputFaces
        outputPoints <- res.[0]
        outputFaces <- res.[1]
        i <- i + 1
    for p in outputPoints do
        printfn "%A" (formatPoint p)
    printfn "%s" ""
    for f in outputFaces do
        printfn "%A" (formatFace f)
printfn "%A" (main())
