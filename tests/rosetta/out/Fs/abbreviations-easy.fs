// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
open System

exception Break
exception Continue

let fields (s) =
    let mutable words: obj = [||]
    let mutable cur: string = ""
    let mutable i: int = 0
    while i < List.length s do
        let ch: obj = s.Substring(i, i + 1 - i)
        if ch = " " || ch = "\n" || ch = "\t" then
            if List.length cur > 0 then
                words <- words @ [cur]
                cur <- ""
        else
            cur <- cur + ch
        i <- i + 1
    if List.length cur > 0 then
        words <- words @ [cur]
    words
let padRight (s) (width) =
    let mutable out: obj = s
    let mutable i: obj = List.length s
    while i < width do
        out <- out + " "
        i <- i + 1
    out
let join (xs) (sep) =
    let mutable res: string = ""
    let mutable i: int = 0
    while i < List.length xs do
        if i > 0 then
            res <- res + sep
        res <- res + xs.[i]
        i <- i + 1
    res
let validate (commands) (words) (mins) =
    let mutable results: obj = [||]
    if List.length words = 0 then
        results
    let mutable wi: int = 0
    try
        while wi < List.length words do
            try
                let w: obj = words.[wi]
                let mutable found: bool = false
                let wlen: obj = List.length w
                let mutable ci: int = 0
                try
                    while ci < List.length commands do
                        try
                            let cmd: obj = commands.[ci]
                            if mins.[ci] <> 0 && wlen >= mins.[ci] && wlen <= List.length cmd then
                                let c: obj = upper cmd
                                let ww: obj = upper w
                                if c.Substring(0, wlen - 0) = ww then
                                    results <- results @ [c]
                                    found <- true
                                    raise Break
                            ci <- ci + 1
                        with Continue -> ()
                with Break -> ()
                if not found then
                    results <- results @ ["*error*"]
                wi <- wi + 1
            with Continue -> ()
    with Break -> ()
    results
let main () =
    let table: string = "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " + "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find " + "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput " + " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO " + "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT " + "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT " + "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "
    let commands: obj = fields table
    let mutable mins: obj = [||]
    let mutable i: int = 0
    while i < List.length commands do
        let mutable count: int = 0
        let mutable j: int = 0
        let cmd: obj = commands.[i]
        while j < List.length cmd do
            let ch: obj = cmd.Substring(j, j + 1 - j)
            if ch >= "A" && ch <= "Z" then
                count <- count + 1
            j <- j + 1
        mins <- mins @ [count]
        i <- i + 1
    let sentence: string = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"
    let words: obj = fields sentence
    let results: obj = validate commands words mins
    let mutable out1: string = "user words:  "
    let mutable k: int = 0
    while k < List.length words do
        out1 <- out1 + padRight words.[k] List.length results.[k] + " "
        k <- k + 1
    printfn "%s" out1
    printfn "%s" "full words:  " + join results " "
printfn "%A" (main())
