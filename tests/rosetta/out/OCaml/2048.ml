(* Generated by Mochi compiler v0.10.30 on 2025-07-19T00:24:49Z *)
let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
     let hd = field o 0 in
     let tl = field o 1 in
     let rest = list_aux tl in
     if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
    | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"

exception Break
exception Continue

let list_set lst idx value =
  List.mapi (fun i v -> if i = idx then value else v) lst


Random.self_init ()

let SIZE : int = 4
let rec newBoard () : int list list =
  let b = ref [] in
  let y : int ref = ref 0 in
  let rec __loop0 () =
    if ((!y) < SIZE) then (
      try
        let row = ref [] in
        let x : int ref = ref 0 in
        let rec __loop1 () =
          if ((!x) < SIZE) then (
            try
              row := ((!row) @ [0]);
              x := ((!x) + 1);
              __loop1 ()
            with Continue -> ()
          ) else ()
        in try __loop1 () with Break -> ()
        ;
        b := ((!b) @ [(!row)]);
        y := ((!y) + 1);
        __loop0 ()
      with Continue -> ()
    ) else ()
  in try __loop0 () with Break -> ()
  ;
  (!b)

let rec spawnTile (b : int list list) : (string * Obj.t) list =
  let empty = ref [] in
  let y : int ref = ref 0 in
  let rec __loop2 () =
    if ((!y) < SIZE) then (
      try
        let x : int ref = ref 0 in
        let rec __loop3 () =
          if ((!x) < SIZE) then (
            try
              if (List.nth (List.nth ((!b)) (!y)) (!x) = 0) then (
                empty := ((!empty) @ [[(!x);(!y)]]);
              ) ;
              x := ((!x) + 1);
              __loop3 ()
            with Continue -> ()
          ) else ()
        in try __loop3 () with Break -> ()
        ;
        y := ((!y) + 1);
        __loop2 ()
      with Continue -> ()
    ) else ()
  in try __loop2 () with Break -> ()
  ;
  if (List.length (!empty) = 0) then (
    [("board",Obj.repr ((!b)));("full",Obj.repr (true))]
  ) ;
  let idx : int ref = ref (Random.bits () mod List.length (!empty)) in
  let cell = List.nth ((!empty)) (!idx) in
  let val_ : int ref = ref 4 in
  if ((Random.bits () mod 10) < 9) then (
    val_ := 2;
  ) ;
  b := list_set !b List.nth (cell) 1 (list_set (List.nth !b List.nth (cell) 1) List.nth (cell) 0 ((!val_)));
  [("board",Obj.repr ((!b)));("full",Obj.repr ((List.length (!empty) = 1)))]

let rec pad (n : int) : string =
  let s : string ref = ref __show (n) in
  let pad : int -> string ref = ref (4 - String.length (!s)) in
  let i : int ref = ref 0 in
  let out : string ref = ref "" in
  let rec __loop4 () =
    if ((!i) < (!pad)) then (
      try
        out := ((!out) ^ " ");
        i := ((!i) + 1);
        __loop4 ()
      with Continue -> ()
    ) else ()
  in try __loop4 () with Break -> ()
  ;
  ((!out) + (!s))

let rec draw (b : int list list) (score : int) =
  print_endline (("Score: " ^ __show (score)));
  let y : int ref = ref 0 in
  let rec __loop5 () =
    if ((!y) < SIZE) then (
      try
        print_endline ("+----+----+----+----+");
        let line : string ref = ref "|" in
        let x : int ref = ref 0 in
        let rec __loop6 () =
          if ((!x) < SIZE) then (
            try
              let v = ref List.nth (List.nth ((!b)) (!y)) (!x) in
              if ((!v) = 0) then (
                line := ((!line) ^ "    |");
              ) else (
                line := (((!line) + pad (!v)) ^ "|");
              ) ;
              x := ((!x) + 1);
              __loop6 ()
            with Continue -> ()
          ) else ()
        in try __loop6 () with Break -> ()
        ;
        print_endline ((!line));
        y := ((!y) + 1);
        __loop5 ()
      with Continue -> ()
    ) else ()
  in try __loop5 () with Break -> ()
  ;
  print_endline ("+----+----+----+----+");
  print_endline ("W=Up S=Down A=Left D=Right Q=Quit");

let rec reverseRow (r : int list) : int list =
  let out = ref [] in
  let i : int ref = ref (List.length r - 1) in
  let rec __loop7 () =
    if ((!i) >= 0) then (
      try
        out := ((!out) @ [Obj.obj (List.assoc (!i) (r))]);
        i := ((!i) - 1);
        __loop7 ()
      with Continue -> ()
    ) else ()
  in try __loop7 () with Break -> ()
  ;
  (!out)

let rec slideLeft (row : int list) : (string * Obj.t) list =
  let xs = ref [] in
  let i : int ref = ref 0 in
  let rec __loop8 () =
    if ((!i) < List.length row) then (
      try
        if (List.nth (row) (!i) <> 0) then (
          xs := ((!xs) @ [List.nth (row) (!i)]);
        ) ;
        i := ((!i) + 1);
        __loop8 ()
      with Continue -> ()
    ) else ()
  in try __loop8 () with Break -> ()
  ;
  let res = ref [] in
  let gain : int ref = ref 0 in
  i := 0;
  let rec __loop9 () =
    if ((!i) < List.length (!xs)) then (
      try
        if ((((!i) + 1) < List.length (!xs)) && (List.nth ((!xs)) (!i) = List.nth ((!xs)) ((!i) + 1))) then (
          let v = (List.nth ((!xs)) (!i) * 2) in
          gain := ((!gain) + v);
          res := ((!res) @ [v]);
          i := ((!i) + 2);
        ) else (
          res := ((!res) @ [List.nth ((!xs)) (!i)]);
          i := ((!i) + 1);
        ) ;
        __loop9 ()
      with Continue -> ()
    ) else ()
  in try __loop9 () with Break -> ()
  ;
  let rec __loop10 () =
    if (List.length (!res) < SIZE) then (
      try
        res := ((!res) @ [0]);
        __loop10 ()
      with Continue -> ()
    ) else ()
  in try __loop10 () with Break -> ()
  ;
  [("row",Obj.repr ((!res)));("gain",Obj.repr ((!gain)))]

let rec moveLeft (b : int list list) (score : int) : (string * Obj.t) list =
  let moved : bool ref = ref false in
  let y : int ref = ref 0 in
  let rec __loop11 () =
    if ((!y) < SIZE) then (
      try
        let r = slideLeft List.nth ((!b)) (!y) in
        let new_ = Obj.obj (List.assoc "row" (r)) in
        (* assignment to score unsupported *)
        let x : int ref = ref 0 in
        let rec __loop12 () =
          if ((!x) < SIZE) then (
            try
              if (List.nth (List.nth ((!b)) (!y)) (!x) <> List.nth (new_) (!x)) then (
                moved := true;
              ) ;
              b := list_set !b (!y) (list_set (List.nth !b (!y)) (!x) (List.nth (new_) (!x)));
              x := ((!x) + 1);
              __loop12 ()
            with Continue -> ()
          ) else ()
        in try __loop12 () with Break -> ()
        ;
        y := ((!y) + 1);
        __loop11 ()
      with Continue -> ()
    ) else ()
  in try __loop11 () with Break -> ()
  ;
  [("board",Obj.repr ((!b)));("score",Obj.repr (score));("moved",Obj.repr ((!moved)))]

let rec moveRight (b : int list list) (score : int) : (string * Obj.t) list =
  let moved : bool ref = ref false in
  let y : int ref = ref 0 in
  let rec __loop13 () =
    if ((!y) < SIZE) then (
      try
        let rev : int list ref = ref reverseRow List.nth ((!b)) (!y) in
        let r = slideLeft (!rev) in
        rev := Obj.obj (List.assoc "row" (r));
        (* assignment to score unsupported *)
        rev := reverseRow (!rev);
        let x : int ref = ref 0 in
        let rec __loop14 () =
          if ((!x) < SIZE) then (
            try
              if (List.nth (List.nth ((!b)) (!y)) (!x) <> List.nth ((!rev)) (!x)) then (
                moved := true;
              ) ;
              b := list_set !b (!y) (list_set (List.nth !b (!y)) (!x) (List.nth ((!rev)) (!x)));
              x := ((!x) + 1);
              __loop14 ()
            with Continue -> ()
          ) else ()
        in try __loop14 () with Break -> ()
        ;
        y := ((!y) + 1);
        __loop13 ()
      with Continue -> ()
    ) else ()
  in try __loop13 () with Break -> ()
  ;
  [("board",Obj.repr ((!b)));("score",Obj.repr (score));("moved",Obj.repr ((!moved)))]

let rec getCol (b : int list list) (x : int) : int list =
  let col = ref [] in
  let y : int ref = ref 0 in
  let rec __loop15 () =
    if ((!y) < SIZE) then (
      try
        col := ((!col) @ [List.nth (List.nth ((!b)) (!y)) x]);
        y := ((!y) + 1);
        __loop15 ()
      with Continue -> ()
    ) else ()
  in try __loop15 () with Break -> ()
  ;
  (!col)

let rec setCol (b : int list list) (x : int) (col : int list) =
  let y : int ref = ref 0 in
  let rec __loop16 () =
    if ((!y) < SIZE) then (
      try
        b := list_set !b (!y) (list_set (List.nth !b (!y)) x (List.nth ((!col)) (!y)));
        y := ((!y) + 1);
        __loop16 ()
      with Continue -> ()
    ) else ()
  in try __loop16 () with Break -> ()
  ;
  ()

let rec moveUp (b : int list list) (score : int) : (string * Obj.t) list =
  let moved : bool ref = ref false in
  let x : int ref = ref 0 in
  let rec __loop17 () =
    if ((!x) < SIZE) then (
      try
        let col : int list ref = ref getCol (!b) (!x) in
        let r = slideLeft (!col) in
        let new_ = Obj.obj (List.assoc "row" (r)) in
        (* assignment to score unsupported *)
        let y : int ref = ref 0 in
        let rec __loop18 () =
          if ((!y) < SIZE) then (
            try
              if (List.nth (List.nth ((!b)) (!y)) (!x) <> List.nth (new_) (!y)) then (
                moved := true;
              ) ;
              b := list_set !b (!y) (list_set (List.nth !b (!y)) (!x) (List.nth (new_) (!y)));
              y := ((!y) + 1);
              __loop18 ()
            with Continue -> ()
          ) else ()
        in try __loop18 () with Break -> ()
        ;
        x := ((!x) + 1);
        __loop17 ()
      with Continue -> ()
    ) else ()
  in try __loop17 () with Break -> ()
  ;
  [("board",Obj.repr ((!b)));("score",Obj.repr (score));("moved",Obj.repr ((!moved)))]

let rec moveDown (b : int list list) (score : int) : (string * Obj.t) list =
  let moved : bool ref = ref false in
  let x : int ref = ref 0 in
  let rec __loop19 () =
    if ((!x) < SIZE) then (
      try
        let col : int list ref = ref reverseRow getCol (!b) (!x) in
        let r = slideLeft (!col) in
        col := Obj.obj (List.assoc "row" (r));
        (* assignment to score unsupported *)
        col := reverseRow (!col);
        let y : int ref = ref 0 in
        let rec __loop20 () =
          if ((!y) < SIZE) then (
            try
              if (List.nth (List.nth ((!b)) (!y)) (!x) <> List.nth ((!col)) (!y)) then (
                moved := true;
              ) ;
              b := list_set !b (!y) (list_set (List.nth !b (!y)) (!x) (List.nth ((!col)) (!y)));
              y := ((!y) + 1);
              __loop20 ()
            with Continue -> ()
          ) else ()
        in try __loop20 () with Break -> ()
        ;
        x := ((!x) + 1);
        __loop19 ()
      with Continue -> ()
    ) else ()
  in try __loop19 () with Break -> ()
  ;
  [("board",Obj.repr ((!b)));("score",Obj.repr (score));("moved",Obj.repr ((!moved)))]

let rec hasMoves (b : int list list) : bool =
  let y : int ref = ref 0 in
  let rec __loop21 () =
    if ((!y) < SIZE) then (
      try
        let x : int ref = ref 0 in
        let rec __loop22 () =
          if ((!x) < SIZE) then (
            try
              if (List.nth (List.nth ((!b)) (!y)) (!x) = 0) then (
                true
              ) ;
              if ((((!x) + 1) < SIZE) && (List.nth (List.nth ((!b)) (!y)) (!x) = List.nth (List.nth ((!b)) (!y)) ((!x) + 1))) then (
                true
              ) ;
              if ((((!y) + 1) < SIZE) && (List.nth (List.nth ((!b)) (!y)) (!x) = List.nth (List.nth ((!b)) ((!y) + 1)) (!x))) then (
                true
              ) ;
              x := ((!x) + 1);
              __loop22 ()
            with Continue -> ()
          ) else ()
        in try __loop22 () with Break -> ()
        ;
        y := ((!y) + 1);
        __loop21 ()
      with Continue -> ()
    ) else ()
  in try __loop21 () with Break -> ()
  ;
  false

let rec has2048 (b : int list list) : bool =
  let y : int ref = ref 0 in
  let rec __loop23 () =
    if ((!y) < SIZE) then (
      try
        let x : int ref = ref 0 in
        let rec __loop24 () =
          if ((!x) < SIZE) then (
            try
              if (List.nth (List.nth ((!b)) (!y)) (!x) >= 2048) then (
                true
              ) ;
              x := ((!x) + 1);
              __loop24 ()
            with Continue -> ()
          ) else ()
        in try __loop24 () with Break -> ()
        ;
        y := ((!y) + 1);
        __loop23 ()
      with Continue -> ()
    ) else ()
  in try __loop23 () with Break -> ()
  ;
  false

let board : int list list ref = ref newBoard ()
let r = ref spawnTile (!board)
let full = ref Obj.obj (List.assoc "full" ((!r)))
let score : int ref = ref 0

let () =
  board := Obj.obj (List.assoc "board" ((!r)));
  r := spawnTile (!board);
  board := Obj.obj (List.assoc "board" ((!r)));
  full := Obj.obj (List.assoc "full" ((!r)));
  draw (!board) (!score);
  let rec __loop25 () =
    if true then (
      try
        print_endline ("Move: ");
        let cmd : string = input () in
        let moved : bool ref = ref false in
        if ((cmd = "a") || (cmd = "A")) then (
          let m = moveLeft (!board) (!score) in
          board := Obj.obj (List.assoc "board" (m));
          score := Obj.obj (List.assoc "score" (m));
          moved := Obj.obj (List.assoc "moved" (m));
        ) ;
        if ((cmd = "d") || (cmd = "D")) then (
          let m = moveRight (!board) (!score) in
          board := Obj.obj (List.assoc "board" (m));
          score := Obj.obj (List.assoc "score" (m));
          moved := Obj.obj (List.assoc "moved" (m));
        ) ;
        if ((cmd = "w") || (cmd = "W")) then (
          let m = moveUp (!board) (!score) in
          board := Obj.obj (List.assoc "board" (m));
          score := Obj.obj (List.assoc "score" (m));
          moved := Obj.obj (List.assoc "moved" (m));
        ) ;
        if ((cmd = "s") || (cmd = "S")) then (
          let m = moveDown (!board) (!score) in
          board := Obj.obj (List.assoc "board" (m));
          score := Obj.obj (List.assoc "score" (m));
          moved := Obj.obj (List.assoc "moved" (m));
        ) ;
        if ((cmd = "q") || (cmd = "Q")) then (
          raise Break
        ) ;
        if (!moved) then (
          let r2 = spawnTile (!board) in
          board := Obj.obj (List.assoc "board" (r2));
          full := Obj.obj (List.assoc "full" (r2));
          if ((!full) && (not (hasMoves (!board)))) then (
            draw (!board) (!score);
            print_endline ("Game Over");
            raise Break
          ) ;
        ) ;
        draw (!board) (!score);
        if has2048 (!board) then (
          print_endline ("You win!");
          raise Break
        ) ;
        if not (hasMoves (!board)) then (
          print_endline ("Game Over");
          raise Break
        ) ;
        __loop25 ()
      with Continue -> ()
    ) else ()
  in try __loop25 () with Break -> ()
  ;
