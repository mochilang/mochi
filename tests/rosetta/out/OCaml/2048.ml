(* Generated by Mochi transpiler v0.10.57 on 2025-08-05 00:30 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let _size = 4
let rec newBoard () =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let b = ref (([] : (int list) list)) in
  let y = ref (0) in
  (try while (!y < _size) do
    try
  let row = ref (([] : (int) list)) in
  let x = ref (0) in
  (try while (!x < _size) do
    try
  row := (List.append (!row) [(Obj.magic (0) : int)]);
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  b := (List.append (!b) [(Obj.magic (!row) : int list)]);
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("cells", Obj.repr (!b))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and spawnTile b =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let grid = ref ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) in
  let empty = ref (([] : (int list) list)) in
  let y = ref (0) in
  (try while (!y < _size) do
    try
  let x = ref (0) in
  (try while (!x < _size) do
    try
  if (List.nth (List.nth (!grid) (!y)) (!x) = 0) then (
  empty := (List.append (!empty) [(Obj.magic ([!x; !y]) : int list)]);
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  if (List.length (!empty) = 0) then (
  __ret := (Obj.magic ([("board", Obj.repr (b)); ("full", Obj.repr (true))]) : (string * Obj.t) list); raise Return
  );
  let idx = ref ((_now () mod List.length (!empty))) in
  let cell = ref (List.nth (!empty) (!idx)) in
  let val_ = ref (4) in
  if ((_now () mod 10) < 9) then (
  val_ := 2;
  );
  grid := (List.mapi (fun __i __x -> if __i = List.nth (!cell) (1) then (List.mapi (fun __i __x -> if __i = List.nth (!cell) (0) then !val_ else __x) (List.nth (!grid) (List.nth (!cell) (1)))) else __x) (!grid));
  __ret := (Obj.magic ([("board", Obj.repr ([("cells", Obj.repr (!grid))])); ("full", Obj.repr ((List.length (!empty) = 1)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and pad n =
  let __ret = ref "" in
  (try
  let n = (Obj.magic n : int) in
  let s = ref ((string_of_int (n))) in
  let pad = ref ((4 - String.length (!s))) in
  let i = ref (0) in
  let out = ref ("") in
  (try while (!i < !pad) do
    try
  out := (!out ^ " ");
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!out ^ !s)) : string); raise Return
  with Return -> !__ret)

and draw b score =
  let __ret = ref (Obj.magic 0) in
  (try
  let score = (Obj.magic score : int) in
  print_endline (("Score: " ^ (string_of_int (score))));
  let y = ref (0) in
  (try while (!y < _size) do
    try
  print_endline ("+----+----+----+----+");
  let line = ref ("|") in
  let x = ref (0) in
  (try while (!x < _size) do
    try
  let v = ref (List.nth (List.nth ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) (!y)) (!x)) in
  if (!v = 0) then (
  line := (!line ^ "    |");
  ) else (
  line := ((!line ^ pad (Obj.repr (!v))) ^ "|");
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline (__show !line);
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline ("+----+----+----+----+");
  print_endline ("W=Up S=Down A=Left D=Right Q=Quit");
    !__ret
  with Return -> !__ret)

and reverseRow r =
  let __ret = ref ([] : (int) list) in
  (try
  let out = ref (([] : (int) list)) in
  let i = ref ((List.length (r) - 1)) in
  (try while (!i >= 0) do
    try
  out := (List.append (!out) [(Obj.magic (List.nth (r) (!i)) : int)]);
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!out) : int list); raise Return
  with Return -> !__ret)

and slideLeft row =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let xs = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < List.length (row)) do
    try
  if (List.nth (row) (!i) <> 0) then (
  xs := (List.append (!xs) [(Obj.magic (List.nth (row) (!i)) : int)]);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let res = ref (([] : (int) list)) in
  let gain = ref (0) in
  i := 0;
  (try while (!i < List.length (!xs)) do
    try
  if (((!i + 1) < List.length (!xs)) && (List.nth (!xs) (!i) = List.nth (!xs) ((!i + 1)))) then (
  let v = (List.nth (!xs) (!i) * 2) in
  gain := (!gain + v);
  res := (List.append (!res) [(Obj.magic (v) : int)]);
  i := (!i + 2);
  ) else (
  res := (List.append (!res) [(Obj.magic (List.nth (!xs) (!i)) : int)]);
  i := (!i + 1);
  );
    with Continue -> ()
  done with Break -> ());
  (try while (List.length (!res) < _size) do
    try
  res := (List.append (!res) [(Obj.magic (0) : int)]);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("row", Obj.repr (!res)); ("gain", Obj.repr (!gain))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and moveLeft b score =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  score := (Obj.magic !score : int);
  let grid = ref ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) in
  let moved = ref (false) in
  let y = ref (0) in
  (try while (!y < _size) do
    try
  let r = slideLeft (List.nth (!grid) (!y)) in
  let new_ = ref ((Obj.obj (List.assoc ("row") (r) : Obj.t) : int list)) in
  score := (!score + (Obj.obj (List.assoc ("gain") (r) : Obj.t) : int));
  let x = ref (0) in
  (try while (!x < _size) do
    try
  if (List.nth (List.nth (!grid) (!y)) (!x) <> List.nth (!new_) (!x)) then (
  moved := true;
  );
  grid := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then List.nth (!new_) (!x) else __x) (List.nth (!grid) (!y))) else __x) (!grid));
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("board", Obj.repr ([("cells", Obj.repr (!grid))])); ("score", Obj.repr (!score)); ("moved", Obj.repr (!moved))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and moveRight b score =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  score := (Obj.magic !score : int);
  let grid = ref ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) in
  let moved = ref (false) in
  let y = ref (0) in
  (try while (!y < _size) do
    try
  let rev = ref (reverseRow (List.nth (!grid) (!y))) in
  let r = slideLeft (!rev) in
  rev := (Obj.obj (List.assoc ("row") (r) : Obj.t) : int list);
  score := (!score + (Obj.obj (List.assoc ("gain") (r) : Obj.t) : int));
  rev := reverseRow (!rev);
  let x = ref (0) in
  (try while (!x < _size) do
    try
  if (List.nth (List.nth (!grid) (!y)) (!x) <> List.nth (!rev) (!x)) then (
  moved := true;
  );
  grid := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then List.nth (!rev) (!x) else __x) (List.nth (!grid) (!y))) else __x) (!grid));
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("board", Obj.repr ([("cells", Obj.repr (!grid))])); ("score", Obj.repr (!score)); ("moved", Obj.repr (!moved))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and getCol b x =
  let __ret = ref ([] : (int) list) in
  (try
  let x = (Obj.magic x : int) in
  let col = ref (([] : (int) list)) in
  let y = ref (0) in
  (try while (!y < _size) do
    try
  col := (List.append (!col) [(Obj.magic (List.nth (List.nth ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) (!y)) (x)) : int)]);
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!col) : int list); raise Return
  with Return -> !__ret)

and setCol b x col =
  let __ret = ref (Obj.magic 0) in
  (try
  let x = (Obj.magic x : int) in
  let rows = ref ((Obj.obj (List.assoc ("cells") (!b) : Obj.t) : int list list)) in
  let y = ref (0) in
  (try while (!y < _size) do
    try
  let row = ref (List.nth (!rows) (!y)) in
  row := (List.mapi (fun __i __x -> if __i = x then List.nth (col) (!y) else __x) (!row));
  rows := (List.mapi (fun __i __x -> if __i = !y then !row else __x) (!rows));
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  b := (("cells", Obj.repr (!rows)) :: List.remove_assoc ("cells") (Obj.magic (!b) : (string * Obj.t) list));
    !__ret
  with Return -> !__ret)

and moveUp b score =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  score := (Obj.magic !score : int);
  let grid = ref ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) in
  let moved = ref (false) in
  let x = ref (0) in
  (try while (!x < _size) do
    try
  let col = ref (getCol ((Obj.magic b : (string * Obj.t) list)) (Obj.repr (!x))) in
  let r = slideLeft (!col) in
  let new_ = ref ((Obj.obj (List.assoc ("row") (r) : Obj.t) : int list)) in
  score := (!score + (Obj.obj (List.assoc ("gain") (r) : Obj.t) : int));
  let y = ref (0) in
  (try while (!y < _size) do
    try
  if (List.nth (List.nth (!grid) (!y)) (!x) <> List.nth (!new_) (!y)) then (
  moved := true;
  );
  grid := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then List.nth (!new_) (!y) else __x) (List.nth (!grid) (!y))) else __x) (!grid));
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("board", Obj.repr ([("cells", Obj.repr (!grid))])); ("score", Obj.repr (!score)); ("moved", Obj.repr (!moved))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and moveDown b score =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  score := (Obj.magic !score : int);
  let grid = ref ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) in
  let moved = ref (false) in
  let x = ref (0) in
  (try while (!x < _size) do
    try
  let col = ref (reverseRow (getCol ((Obj.magic b : (string * Obj.t) list)) (Obj.repr (!x)))) in
  let r = slideLeft (!col) in
  col := (Obj.obj (List.assoc ("row") (r) : Obj.t) : int list);
  score := (!score + (Obj.obj (List.assoc ("gain") (r) : Obj.t) : int));
  col := reverseRow (!col);
  let y = ref (0) in
  (try while (!y < _size) do
    try
  if (List.nth (List.nth (!grid) (!y)) (!x) <> List.nth (!col) (!y)) then (
  moved := true;
  );
  grid := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then List.nth (!col) (!y) else __x) (List.nth (!grid) (!y))) else __x) (!grid));
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("board", Obj.repr ([("cells", Obj.repr (!grid))])); ("score", Obj.repr (!score)); ("moved", Obj.repr (!moved))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and hasMoves b =
  let __ret = ref false in
  (try
  let y = ref (0) in
  (try while (!y < _size) do
    try
  let x = ref (0) in
  (try while (!x < _size) do
    try
  if (List.nth (List.nth ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) (!y)) (!x) = 0) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  if (((!x + 1) < _size) && (List.nth (List.nth ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) (!y)) (!x) = List.nth (List.nth ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) (!y)) ((!x + 1)))) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  if (((!y + 1) < _size) && (List.nth (List.nth ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) (!y)) (!x) = List.nth (List.nth ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) ((!y + 1))) (!x))) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)

and has2048 b =
  let __ret = ref false in
  (try
  let y = ref (0) in
  (try while (!y < _size) do
    try
  let x = ref (0) in
  (try while (!x < _size) do
    try
  if (List.nth (List.nth ((Obj.obj (List.assoc ("cells") (b) : Obj.t) : int list list)) (!y)) (!x) >= 2048) then (
  __ret := (Obj.magic (true) : bool); raise Return
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (false) : bool); raise Return
  with Return -> !__ret)


let board = ref (newBoard ())
let r = ref (spawnTile (!board))
let () =
  let mem_start = _mem () in
  let start = _now () in
  board := (Obj.obj (List.assoc ("board") (!r) : Obj.t) : ( string * Obj.t ) list);
  let full = ref ((Obj.obj (List.assoc ("full") (!r) : Obj.t) : bool)) in
  r := spawnTile (!board);
  board := (Obj.obj (List.assoc ("board") (!r) : Obj.t) : ( string * Obj.t ) list);
  full := (Obj.obj (List.assoc ("full") (!r) : Obj.t) : bool);
  let score = ref (0) in
  ignore (draw (!board) (Obj.repr (!score)));
  (try while true do
    try
  print_endline ("Move: ");
  let cmd = (try read_line () with End_of_file -> "") in
  let moved = ref (false) in
  if ((cmd = "a") || (cmd = "A")) then (
  let m = moveLeft (!board) (score) in
  board := (Obj.obj (List.assoc ("board") (m) : Obj.t) : ( string * Obj.t ) list);
  score := (Obj.obj (List.assoc ("score") (m) : Obj.t) : int);
  moved := (Obj.obj (List.assoc ("moved") (m) : Obj.t) : bool);
  );
  if ((cmd = "d") || (cmd = "D")) then (
  let m = moveRight (!board) (score) in
  board := (Obj.obj (List.assoc ("board") (m) : Obj.t) : ( string * Obj.t ) list);
  score := (Obj.obj (List.assoc ("score") (m) : Obj.t) : int);
  moved := (Obj.obj (List.assoc ("moved") (m) : Obj.t) : bool);
  );
  if ((cmd = "w") || (cmd = "W")) then (
  let m = moveUp (!board) (score) in
  board := (Obj.obj (List.assoc ("board") (m) : Obj.t) : ( string * Obj.t ) list);
  score := (Obj.obj (List.assoc ("score") (m) : Obj.t) : int);
  moved := (Obj.obj (List.assoc ("moved") (m) : Obj.t) : bool);
  );
  if ((cmd = "s") || (cmd = "S")) then (
  let m = moveDown (!board) (score) in
  board := (Obj.obj (List.assoc ("board") (m) : Obj.t) : ( string * Obj.t ) list);
  score := (Obj.obj (List.assoc ("score") (m) : Obj.t) : int);
  moved := (Obj.obj (List.assoc ("moved") (m) : Obj.t) : bool);
  );
  if ((cmd = "q") || (cmd = "Q")) then (
  raise Break;
  );
  if !moved then (
  let r2 = spawnTile (!board) in
  board := (Obj.obj (List.assoc ("board") (r2) : Obj.t) : ( string * Obj.t ) list);
  full := (Obj.obj (List.assoc ("full") (r2) : Obj.t) : bool);
  if (!full && not (hasMoves (!board))) then (
  ignore (draw (!board) (Obj.repr (!score)));
  print_endline ("Game Over");
  raise Break;
  );
  );
  ignore (draw (!board) (Obj.repr (!score)));
  if has2048 (!board) then (
  print_endline ("You win!");
  raise Break;
  );
  if not (hasMoves (!board)) then (
  print_endline ("Game Over");
  raise Break;
  );
    with Continue -> ()
  done with Break -> ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = Stdlib.max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()