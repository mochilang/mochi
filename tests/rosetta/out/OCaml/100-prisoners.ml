(* Generated by Mochi compiler v0.10.30 on 2025-07-19T00:24:49Z *)
let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
     let hd = field o 0 in
     let tl = field o 1 in
     let rest = list_aux tl in
     if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
    | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"

exception Break
exception Continue

let list_set lst idx value =
  List.mapi (fun i v -> if i = idx then value else v) lst


Random.self_init ()

let rec shuffle (xs : int list) : int list =
  let arr = ref xs in
  let i : int ref = ref 99 in
  let rec __loop0 () =
    if ((!i) > 0) then (
      try
        let j = (Random.bits () mod (((!i) + 1))) in
        let tmp = List.nth ((!arr)) (!i) in
        arr := list_set !arr (!i) (List.nth ((!arr)) j);
        arr := list_set !arr j (tmp);
        i := ((!i) - 1);
        __loop0 ()
      with Continue -> ()
    ) else ()
  in try __loop0 () with Break -> ()
  ;
  (!arr)

let rec doTrials (trials : int) (np : int) (strategy : string) =
  let pardoned : int ref = ref 0 in
  let t : int ref = ref 0 in
  let rec __loop1 () =
    if ((!t) < trials) then (
      try
        let drawers = ref [] in
        let i : int ref = ref 0 in
        let rec __loop2 () =
          if ((!i) < 100) then (
            try
              drawers := ((!drawers) @ [(!i)]);
              i := ((!i) + 1);
              __loop2 ()
            with Continue -> ()
          ) else ()
        in try __loop2 () with Break -> ()
        ;
        drawers := shuffle (!drawers);
        let p : int ref = ref 0 in
        let success : bool ref = ref true in
        let rec __loop3 () =
          if ((!p) < np) then (
            try
              let found : bool ref = ref false in
              if (strategy = "optimal") then (
                let prev = ref (!p) in
                let d : int ref = ref 0 in
                let rec __loop4 () =
                  if ((!d) < 50) then (
                    try
                      let this = List.nth ((!drawers)) (!prev) in
                      if (this = (!p)) then (
                        found := true;
                        raise Break
                      ) ;
                      prev := this;
                      d := ((!d) + 1);
                      __loop4 ()
                    with Continue -> ()
                  ) else ()
                in try __loop4 () with Break -> ()
                ;
              ) else (
                let opened = ref [] in
                let k : int ref = ref 0 in
                let rec __loop5 () =
                  if ((!k) < 100) then (
                    try
                      opened := ((!opened) @ [false]);
                      k := ((!k) + 1);
                      __loop5 ()
                    with Continue -> ()
                  ) else ()
                in try __loop5 () with Break -> ()
                ;
                let d : int ref = ref 0 in
                let rec __loop6 () =
                  if ((!d) < 50) then (
                    try
                      let n : int ref = ref (Random.bits () mod 100) in
                      let rec __loop7 () =
                        if List.nth ((!opened)) (!n) then (
                          try
                            n := (Random.bits () mod 100);
                            __loop7 ()
                          with Continue -> ()
                        ) else ()
                      in try __loop7 () with Break -> ()
                      ;
                      opened := list_set !opened (!n) (true);
                      if (List.nth ((!drawers)) (!n) = (!p)) then (
                        found := true;
                        raise Break
                      ) ;
                      d := ((!d) + 1);
                      __loop6 ()
                    with Continue -> ()
                  ) else ()
                in try __loop6 () with Break -> ()
                ;
              ) ;
              if not ((!found)) then (
                success := false;
                raise Break
              ) ;
              p := ((!p) + 1);
              __loop3 ()
            with Continue -> ()
          ) else ()
        in try __loop3 () with Break -> ()
        ;
        if (!success) then (
          pardoned := ((!pardoned) + 1);
        ) ;
        t := ((!t) + 1);
        __loop1 ()
      with Continue -> ()
    ) else ()
  in try __loop1 () with Break -> ()
  ;
  let rf : float = (((float_of_int (!pardoned)) /. (float_of_int trials)) *. 100.) in
  print_endline (__show ((((((("  strategy = " ^ strategy) ^ "  pardoned = ") ^ __show ((!pardoned))) ^ " relative frequency = ") ^ __show (rf)) ^ "%")));

let rec main () =
  let trials : int = 1000 in
  let rec __loop8 lst =
    match lst with
      | [] -> ()
      | np::rest ->
        (try
          print_endline ((((("Results from " ^ __show (trials)) ^ " trials with ") ^ __show (np)) ^ " prisoners:\n"));
          let rec __loop9 lst =
            match lst with
              | [] -> ()
              | strat::rest ->
                (try
                  doTrials trials np strat;
                with Continue -> ())
                ; __loop9 rest
            in
            try __loop9 ["random";"optimal"] with Break -> ()
            ;
          with Continue -> ())
          ; __loop8 rest
      in
      try __loop8 [10;100] with Break -> ()
      ;
      ()


let () =
  main ();
