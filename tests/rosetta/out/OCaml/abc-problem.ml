(* Generated by Mochi compiler v0.10.30 on 2025-07-19T00:24:49Z *)
let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
     let hd = field o 0 in
     let tl = field o 1 in
     let rest = list_aux tl in
     if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
    | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"

exception Break
exception Continue

let slice lst i j =
  lst |> List.mapi (fun idx x -> idx, x)
      |> List.filter (fun (idx, _) -> idx >= i && idx < j)
      |> List.map snd

let string_slice s i j = String.sub s i (j - i)


let rec fields (s : string) : string list =
  let res = ref [] in
  let cur : string ref = ref "" in
  let i : int ref = ref 0 in
  let rec __loop0 () =
    if ((!i) < String.length s) then (
      try
        let c = string_slice s ((!i)) (((!i) + 1)) in
        if (c = " ") then (
          if (String.length (!cur) > 0) then (
            res := ((!res) @ [(!cur)]);
            cur := "";
          ) ;
        ) else (
          cur := ((!cur) + c);
        ) ;
        i := ((!i) + 1);
        __loop0 ()
      with Continue -> ()
    ) else ()
  in try __loop0 () with Break -> ()
  ;
  if (String.length (!cur) > 0) then (
    res := ((!res) @ [(!cur)]);
  ) ;
  (!res)

let rec canSpell (word : string) (blks : string list) : bool =
  if (String.length word = 0) then (
    true
  ) ;
  let c : string = lower string_slice word (0) (1) in
  let i : int ref = ref 0 in
  let rec __loop1 () =
    if ((!i) < List.length blks) then (
      try
        let b = List.nth (blks) (!i) in
        if ((c = lower slice b (0) (1)) || (c = lower slice b (1) (2))) then (
          let rest = ref [] in
          let j : int ref = ref 0 in
          let rec __loop2 () =
            if ((!j) < List.length blks) then (
              try
                if ((!j) <> (!i)) then (
                  rest := ((!rest) @ [List.nth (blks) (!j)]);
                ) ;
                j := ((!j) + 1);
                __loop2 ()
              with Continue -> ()
            ) else ()
          in try __loop2 () with Break -> ()
          ;
          if canSpell string_slice word (1) (String.length word) (!rest) then (
            true
          ) ;
        ) ;
        i := ((!i) + 1);
        __loop1 ()
      with Continue -> ()
    ) else ()
  in try __loop1 () with Break -> ()
  ;
  false

let rec newSpeller (blocks : string) : string -> bool =
  let bl : string list = fields blocks in
  fun w -> canSpell w bl

let rec main () =
  let sp : string -> bool = newSpeller "BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM" in
  let rec __loop3 lst =
    match lst with
      | [] -> ()
      | word::rest ->
        (try
          print_endline (((word ^ " ") ^ __show (sp word)));
        with Continue -> ())
        ; __loop3 rest
    in
    try __loop3 ["A";"BARK";"BOOK";"TREAT";"COMMON";"SQUAD";"CONFUSE"] with Break -> ()
    ;
    ()


let () =
  main ();
