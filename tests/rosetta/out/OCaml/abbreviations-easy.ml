(* Generated by Mochi compiler v0.10.30 on 2025-07-19T00:24:49Z *)
let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
     let hd = field o 0 in
     let tl = field o 1 in
     let rest = list_aux tl in
     if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
    | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"

exception Break
exception Continue


let rec fields (s : string) : string list =
  let words = ref [] in
  let cur : string ref = ref "" in
  let i : int ref = ref 0 in
  let rec __loop0 () =
    if ((!i) < String.length s) then (
      try
        let ch : string = String.sub s (!i) (((!i) + 1) - (!i)) in
        if (((ch = " ") || (ch = "\n")) || (ch = "\t")) then (
          if (String.length (!cur) > 0) then (
            words := ((!words) @ [(!cur)]);
            cur := "";
          ) ;
        ) else (
          cur := ((!cur) + ch);
        ) ;
        i := ((!i) + 1);
        __loop0 ()
      with Continue -> ()
    ) else ()
  in try __loop0 () with Break -> ()
  ;
  if (String.length (!cur) > 0) then (
    words := ((!words) @ [(!cur)]);
  ) ;
  (!words)

let rec padRight (s : string) (width : int) : string =
  let out = ref s in
  let i : int ref = ref String.length s in
  let rec __loop1 () =
    if ((!i) < width) then (
      try
        out := ((!out) ^ " ");
        i := ((!i) + 1);
        __loop1 ()
      with Continue -> ()
    ) else ()
  in try __loop1 () with Break -> ()
  ;
  (!out)

let rec join (xs : string list) (sep : string) : string =
  let res : string ref = ref "" in
  let i : int ref = ref 0 in
  let rec __loop2 () =
    if ((!i) < List.length xs) then (
      try
        if ((!i) > 0) then (
          res := ((!res) + sep);
        ) ;
        res := ((!res) + List.nth (xs) (!i));
        i := ((!i) + 1);
        __loop2 ()
      with Continue -> ()
    ) else ()
  in try __loop2 () with Break -> ()
  ;
  (!res)

let rec validate (commands : string list) (words : string list) (mins : int list) : string list =
  let results = ref [] in
  if (List.length (!words) = 0) then (
    (!results)
  ) ;
  let wi : int ref = ref 0 in
  let rec __loop3 () =
    if ((!wi) < List.length (!words)) then (
      try
        let w = List.nth ((!words)) (!wi) in
        let found : bool ref = ref false in
        let wlen : int = List.length w in
        let ci : int ref = ref 0 in
        let rec __loop4 () =
          if ((!ci) < List.length commands) then (
            try
              let cmd = List.nth (commands) (!ci) in
              if (((List.nth (mins) (!ci) <> 0) && (wlen >= List.nth (mins) (!ci))) && (wlen <= List.length cmd)) then (
                let c : string = upper cmd in
                let ww : string = upper w in
                if (String.sub c 0 (wlen - 0) = ww) then (
                  results := ((!results) @ [c]);
                  found := true;
                  raise Break
                ) ;
              ) ;
              ci := ((!ci) + 1);
              __loop4 ()
            with Continue -> ()
          ) else ()
        in try __loop4 () with Break -> ()
        ;
        if not ((!found)) then (
          results := ((!results) @ ["*error*"]);
        ) ;
        wi := ((!wi) + 1);
        __loop3 ()
      with Continue -> ()
    ) else ()
  in try __loop3 () with Break -> ()
  ;
  (!results)

let rec main () =
  let table : string = (((((("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " ^ "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ") ^ "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ") ^ " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ") ^ "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ") ^ "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ") ^ "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp ") in
  let commands : string list = fields table in
  let mins = ref [] in
  let i : int ref = ref 0 in
  let rec __loop5 () =
    if ((!i) < List.length commands) then (
      try
        let count : int ref = ref 0 in
        let j : int ref = ref 0 in
        let cmd = List.nth (commands) (!i) in
        let rec __loop6 () =
          if ((!j) < List.length cmd) then (
            try
              let ch : string = String.sub cmd (!j) (((!j) + 1) - (!j)) in
              if ((ch >= "A") && (ch <= "Z")) then (
                count := ((!count) + 1);
              ) ;
              j := ((!j) + 1);
              __loop6 ()
            with Continue -> ()
          ) else ()
        in try __loop6 () with Break -> ()
        ;
        mins := ((!mins) @ [(!count)]);
        i := ((!i) + 1);
        __loop5 ()
      with Continue -> ()
    ) else ()
  in try __loop5 () with Break -> ()
  ;
  let sentence : string = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin" in
  let words : string list = fields sentence in
  let results : string list = validate commands words (!mins) in
  let out1 : string ref = ref "user words:  " in
  let k : int ref = ref 0 in
  let rec __loop7 () =
    if ((!k) < List.length words) then (
      try
        out1 := (((!out1) + padRight List.nth (words) (!k) List.length List.nth (results) (!k)) ^ " ");
        k := ((!k) + 1);
        __loop7 ()
      with Continue -> ()
    ) else ()
  in try __loop7 () with Break -> ()
  ;
  print_endline ((!out1));
  print_endline (("full words:  " ^ join results " "));


let () =
  main ();
