(* Generated by Mochi compiler v0.10.30 on 2025-07-19T00:24:49Z *)
let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
     let hd = field o 0 in
     let tl = field o 1 in
     let rest = list_aux tl in
     if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
    | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"

exception Break
exception Continue

let string_slice s i j = String.sub s i (j - i)


let rec fields (s : string) : string list =
  let words = ref [] in
  let cur : string ref = ref "" in
  let i : int ref = ref 0 in
  let rec __loop0 () =
    if ((!i) < String.length s) then (
      try
        let ch : string = String.sub s (!i) (((!i) + 1) - (!i)) in
        if (((ch = " ") || (ch = "\n")) || (ch = "\t")) then (
          if (String.length (!cur) > 0) then (
            words := ((!words) @ [(!cur)]);
            cur := "";
          ) ;
        ) else (
          cur := ((!cur) + ch);
        ) ;
        i := ((!i) + 1);
        __loop0 ()
      with Continue -> ()
    ) else ()
  in try __loop0 () with Break -> ()
  ;
  if (String.length (!cur) > 0) then (
    words := ((!words) @ [(!cur)]);
  ) ;
  (!words)

let rec padRight (s : string) (width : int) : string =
  let out = ref s in
  let i : int ref = ref String.length s in
  let rec __loop1 () =
    if ((!i) < width) then (
      try
        out := ((!out) ^ " ");
        i := ((!i) + 1);
        __loop1 ()
      with Continue -> ()
    ) else ()
  in try __loop1 () with Break -> ()
  ;
  (!out)

let rec join (xs : string list) (sep : string) : string =
  let res : string ref = ref "" in
  let i : int ref = ref 0 in
  let rec __loop2 () =
    if ((!i) < List.length xs) then (
      try
        if ((!i) > 0) then (
          res := ((!res) + sep);
        ) ;
        res := ((!res) + List.nth (xs) (!i));
        i := ((!i) + 1);
        __loop2 ()
      with Continue -> ()
    ) else ()
  in try __loop2 () with Break -> ()
  ;
  (!res)

let rec parseIntStr (str : string) : int =
  let i : int ref = ref 0 in
  let neg : bool ref = ref false in
  if ((String.length str > 0) && (string_slice str (0) (1) = "-")) then (
    neg := true;
    i := 1;
  ) ;
  let n : int ref = ref 0 in
  let digits = [("0",Obj.repr (0));("1",Obj.repr (1));("2",Obj.repr (2));("3",Obj.repr (3));("4",Obj.repr (4));("5",Obj.repr (5));("6",Obj.repr (6));("7",Obj.repr (7));("8",Obj.repr (8));("9",Obj.repr (9))] in
  let rec __loop3 () =
    if ((!i) < String.length str) then (
      try
        n := (((!n) * 10) + List.nth (digits) string_slice str ((!i)) (((!i) + 1)));
        i := ((!i) + 1);
        __loop3 ()
      with Continue -> ()
    ) else ()
  in try __loop3 () with Break -> ()
  ;
  if (!neg) then (
    n := -(!n);
  ) ;
  (!n)

let rec isDigits (s : string) : bool =
  if (String.length s = 0) then (
    false
  ) ;
  let i : int ref = ref 0 in
  let rec __loop4 () =
    if ((!i) < String.length s) then (
      try
        let ch : string = String.sub s (!i) (((!i) + 1) - (!i)) in
        if ((ch < "0") || (ch > "9")) then (
          false
        ) ;
        i := ((!i) + 1);
        __loop4 ()
      with Continue -> ()
    ) else ()
  in try __loop4 () with Break -> ()
  ;
  true

let rec readTable (table : string) : (string * Obj.t) list =
  let toks : string list = fields table in
  let cmds = ref [] in
  let mins = ref [] in
  let i : int ref = ref 0 in
  let rec __loop5 () =
    if ((!i) < List.length toks) then (
      try
        let cmd = List.nth (toks) (!i) in
        let minlen : int ref = ref List.length cmd in
        i := ((!i) + 1);
        if (((!i) < List.length toks) && isDigits List.nth (toks) (!i)) then (
          let num : int = parseIntStr List.nth (toks) (!i) in
          if ((num >= 1) && (num < List.length cmd)) then (
            minlen := num;
            i := ((!i) + 1);
          ) ;
        ) ;
        cmds := ((!cmds) @ [cmd]);
        mins := ((!mins) @ [(!minlen)]);
        __loop5 ()
      with Continue -> ()
    ) else ()
  in try __loop5 () with Break -> ()
  ;
  [("commands",Obj.repr ((!cmds)));("mins",Obj.repr ((!mins)))]

let rec validate (commands : string list) (mins : int list) (words : string list) : string list =
  let results = ref [] in
  let wi : int ref = ref 0 in
  let rec __loop6 () =
    if ((!wi) < List.length (!words)) then (
      try
        let w = List.nth ((!words)) (!wi) in
        let found : bool ref = ref false in
        let wlen : int = List.length w in
        let ci : int ref = ref 0 in
        let rec __loop7 () =
          if ((!ci) < List.length commands) then (
            try
              let cmd = List.nth (commands) (!ci) in
              if (((List.nth ((!mins)) (!ci) <> 0) && (wlen >= List.nth ((!mins)) (!ci))) && (wlen <= List.length cmd)) then (
                let c : string = upper cmd in
                let ww : string = upper w in
                if (String.sub c 0 (wlen - 0) = ww) then (
                  results := ((!results) @ [c]);
                  found := true;
                  raise Break
                ) ;
              ) ;
              ci := ((!ci) + 1);
              __loop7 ()
            with Continue -> ()
          ) else ()
        in try __loop7 () with Break -> ()
        ;
        if not ((!found)) then (
          results := ((!results) @ ["*error*"]);
        ) ;
        wi := ((!wi) + 1);
        __loop6 ()
      with Continue -> ()
    ) else ()
  in try __loop6 () with Break -> ()
  ;
  (!results)

let rec main () =
  let table : string = (((((((("" ^ "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ") ^ "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ") ^ "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ") ^ "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ") ^ "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ") ^ "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ") ^ "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ") ^ "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ") in
  let sentence : string = "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin" in
  let tbl = readTable table in
  let commands : string list = Obj.obj (List.assoc "commands" (tbl)) in
  let mins : int list = Obj.obj (List.assoc "mins" (tbl)) in
  let words : string list = fields sentence in
  let results : string list = validate commands mins words in
  let out1 : string ref = ref "user words:" in
  let k : int ref = ref 0 in
  let rec __loop8 () =
    if ((!k) < List.length words) then (
      try
        out1 := ((!out1) ^ " ");
        if (((!k) < List.length words) - 1) then (
          out1 := ((!out1) + padRight List.nth (words) (!k) List.length List.nth (results) (!k));
        ) else (
          out1 := ((!out1) + List.nth (words) (!k));
        ) ;
        k := ((!k) + 1);
        __loop8 ()
      with Continue -> ()
    ) else ()
  in try __loop8 () with Break -> ()
  ;
  print_endline ((!out1));
  print_endline (("full words: " ^ join results " "));


let () =
  main ();
