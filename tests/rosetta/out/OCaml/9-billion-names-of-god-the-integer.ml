(* Generated by Mochi compiler v0.10.30 on 2025-07-19T00:24:49Z *)
  let rec __show v =
    let open Obj in
    let rec list_aux o =
      if is_int o && (magic (obj o) : int) = 0 then "" else
       let hd = field o 0 in
       let tl = field o 1 in
       let rest = list_aux tl in
       if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
    in
    let r = repr v in
    if is_int r then string_of_int (magic v) else
    match tag r with
      | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
      | 252 -> (magic v : string)
      | 253 -> string_of_float (magic v)
      | _ -> "<value>"

  exception Break
  exception Continue

  let slice lst i j =
    lst |> List.mapi (fun idx x -> idx, x)
        |> List.filter (fun (idx, _) -> idx >= i && idx < j)
        |> List.map snd
  

let rec bigTrim (a : int list) : int list =
  let n : int ref = ref List.length a in
  let rec __loop0 () =
    if (((!n) > 1) && (List.nth (a) ((!n) - 1) = 0)) then (
      try
        (* assignment to a unsupported *)
        n := ((!n) - 1);
        __loop0 ()
      with Continue -> ()
    ) else ()
  in try __loop0 () with Break -> ()
  ;
  a

let rec bigFromInt (x : int) : int list =
  if (x = 0) then (
    [0]
  ) ;
  let digits = ref [] in
  let n : int ref = ref x in
  let rec __loop1 () =
    if ((!n) > 0) then (
      try
        digits := ((!digits) @ [((!n) mod 10)]);
        n := ((!n) / 10);
        __loop1 ()
      with Continue -> ()
    ) else ()
  in try __loop1 () with Break -> ()
  ;
  (!digits)

let rec bigAdd (a : int list) (b : int list) : int list =
  let res = ref [] in
  let carry : int ref = ref 0 in
  let i : int ref = ref 0 in
  let rec __loop2 () =
    if ((((!i) < List.length a) || ((!i) < List.length b)) || ((!carry) > 0)) then (
      try
        let av : int ref = ref 0 in
        if ((!i) < List.length a) then (
          av := List.nth (a) (!i);
        ) ;
        let bv : int ref = ref 0 in
        if ((!i) < List.length b) then (
          bv := List.nth (b) (!i);
        ) ;
        let s = ref (((!av) + (!bv)) + (!carry)) in
        res := ((!res) @ [((!s) mod 10)]);
        carry := ((!s) / 10);
        i := ((!i) + 1);
        __loop2 ()
      with Continue -> ()
    ) else ()
  in try __loop2 () with Break -> ()
  ;
  bigTrim (!res)

let rec bigSub (a : int list) (b : int list) : int list =
  let res = ref [] in
  let borrow : int ref = ref 0 in
  let i : int ref = ref 0 in
  let rec __loop3 () =
    if ((!i) < List.length a) then (
      try
        let av = ref List.nth (a) (!i) in
        let bv : int ref = ref 0 in
        if ((!i) < List.length b) then (
          bv := List.nth (b) (!i);
        ) ;
        let diff = ref (((!av) - (!bv)) - (!borrow)) in
        if ((!diff) < 0) then (
          diff := ((!diff) + 10);
          borrow := 1;
        ) else (
          borrow := 0;
        ) ;
        res := ((!res) @ [(!diff)]);
        i := ((!i) + 1);
        __loop3 ()
      with Continue -> ()
    ) else ()
  in try __loop3 () with Break -> ()
  ;
  bigTrim (!res)

let rec bigToString (a : int list) : string =
  let s : string ref = ref "" in
  let i : int ref = ref (List.length a - 1) in
  let rec __loop4 () =
    if ((!i) >= 0) then (
      try
        s := ((!s) ^ __show (List.nth (a) (!i)));
        i := ((!i) - 1);
        __loop4 ()
      with Continue -> ()
    ) else ()
  in try __loop4 () with Break -> ()
  ;
  (!s)

let rec minInt (a : int) (b : int) : int =
  if (a < b) then (
    a
  ) else (
    b
  ) ;
  ()

let rec cumu (n : int) : int list list =
  let cache : int list list list ref = ref [[bigFromInt 1]] in
  let y : int ref = ref 1 in
  let rec __loop5 () =
    if ((!y) <= (!n)) then (
      try
        let row : int -> string list ref = ref [bigFromInt 0] in
        let x : int ref = ref 1 in
        let rec __loop6 () =
          if ((!x) <= (!y)) then (
            try
              let val_ = List.nth (List.nth ((!cache)) ((!y) - (!x))) minInt (!x) ((!y) - (!x)) in
              row := ((!row) @ [bigAdd List.nth ((!row)) (List.length (!row) - 1) val_]);
              x := ((!x) + 1);
              __loop6 ()
            with Continue -> ()
          ) else ()
        in try __loop6 () with Break -> ()
        ;
        cache := ((!cache) @ [(!row)]);
        y := ((!y) + 1);
        __loop5 ()
      with Continue -> ()
    ) else ()
  in try __loop5 () with Break -> ()
  ;
  List.nth ((!cache)) (!n)

let rec row (n : int) : string list =
  let e : int list list = cumu (!n) in
  let out = ref [] in
  let i : int ref = ref 0 in
  let rec __loop7 () =
    if ((!i) < (!n)) then (
      try
        let diff : int list = bigSub List.nth (e) ((!i) + 1) List.nth (e) (!i) in
        out := ((!out) @ [bigToString diff]);
        i := ((!i) + 1);
        __loop7 ()
      with Continue -> ()
    ) else ()
  in try __loop7 () with Break -> ()
  ;
  (!out)

let x : int ref = ref 1

let () =
  print_endline ("rows:");
  let rec __loop8 () =
    if ((!x) < 11) then (
      try
        let r : string list = row (!x) in
        let line : string ref = ref "" in
        let i : int ref = ref 0 in
        let rec __loop9 () =
          if ((!i) < List.length r) then (
            try
              line := ((((!line) ^ " ") + List.nth (r) (!i)) ^ " ");
              i := ((!i) + 1);
              __loop9 ()
            with Continue -> ()
          ) else ()
        in try __loop9 () with Break -> ()
        ;
        print_endline ((!line));
        x := ((!x) + 1);
        __loop8 ()
      with Continue -> ()
    ) else ()
  in try __loop8 () with Break -> ()
  ;
  print_endline ("");
  print_endline ("sums:");
  let rec __loop10 lst =
    match lst with
      | [] -> ()
      | num::rest ->
        (try
          let r : int list list = cumu num in
          print_endline (((__show (num) ^ " ") ^ bigToString List.nth (r) (List.length r - 1)));
        with Continue -> ())
        ; __loop10 rest
    in
    try __loop10 [23;123;1234] with Break -> ()
    ;
