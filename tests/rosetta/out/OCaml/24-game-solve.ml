(* Generated by Mochi compiler v0.10.30 on 2025-07-19T00:24:49Z *)
let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
     let hd = field o 0 in
     let tl = field o 1 in
     let rest = list_aux tl in
     if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
    | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
    | 252 -> (magic v : string)
    | 253 -> string_of_float (magic v)
    | _ -> "<value>"

exception Break
exception Continue


Random.self_init ()

let OP_NUM : int = 0
let OP_ADD : int = 1
let OP_SUB : int = 2
let OP_MUL : int = 3
let OP_DIV : int = 4
let rec newNum (n : int) : (string * Obj.t) list =
  [("op",Obj.repr (OP_NUM));("value",Obj.repr ([("num",Obj.repr (n));("denom",Obj.repr (1))]))]

let rec exprEval (x : (string * Obj.t) list) : (string * int) list =
  if (Obj.obj (List.assoc "op" (x)) = OP_NUM) then (
    Obj.obj (List.assoc "value" (x))
  ) ;
  let l = exprEval Obj.obj (List.assoc "left" (x)) in
  let r = exprEval Obj.obj (List.assoc "right" (x)) in
  if (Obj.obj (List.assoc "op" (x)) = OP_ADD) then (
    [("num",Obj.repr ((((Obj.obj (List.assoc "num" (l)) * Obj.obj (List.assoc "denom" (r))) + Obj.obj (List.assoc "denom" (l))) * Obj.obj (List.assoc "num" (r)))));("denom",Obj.repr ((Obj.obj (List.assoc "denom" (l)) * Obj.obj (List.assoc "denom" (r)))))]
  ) ;
  if (Obj.obj (List.assoc "op" (x)) = OP_SUB) then (
    [("num",Obj.repr ((((Obj.obj (List.assoc "num" (l)) * Obj.obj (List.assoc "denom" (r))) - Obj.obj (List.assoc "denom" (l))) * Obj.obj (List.assoc "num" (r)))));("denom",Obj.repr ((Obj.obj (List.assoc "denom" (l)) * Obj.obj (List.assoc "denom" (r)))))]
  ) ;
  if (Obj.obj (List.assoc "op" (x)) = OP_MUL) then (
    [("num",Obj.repr ((Obj.obj (List.assoc "num" (l)) * Obj.obj (List.assoc "num" (r)))));("denom",Obj.repr ((Obj.obj (List.assoc "denom" (l)) * Obj.obj (List.assoc "denom" (r)))))]
  ) ;
  [("num",Obj.repr ((Obj.obj (List.assoc "num" (l)) * Obj.obj (List.assoc "denom" (r)))));("denom",Obj.repr ((Obj.obj (List.assoc "denom" (l)) * Obj.obj (List.assoc "num" (r)))))]

let rec exprString (x : (string * Obj.t) list) : string =
  if (Obj.obj (List.assoc "op" (x)) = OP_NUM) then (
    __show (Obj.obj (List.assoc "num" (Obj.obj (List.assoc "value" (x)))))
  ) ;
  let ls : string = exprString Obj.obj (List.assoc "left" (x)) in
  let rs : string = exprString Obj.obj (List.assoc "right" (x)) in
  let opstr : string ref = ref "" in
  if (Obj.obj (List.assoc "op" (x)) = OP_ADD) then (
    opstr := " + ";
  ) else (
    if (Obj.obj (List.assoc "op" (x)) = OP_SUB) then (
      opstr := " - ";
    ) else (
      if (Obj.obj (List.assoc "op" (x)) = OP_MUL) then (
        opstr := " * ";
      ) else (
        opstr := " / ";
      ) ;
    ) ;
  ) ;
  (((("(" ^ ls) ^ (!opstr)) ^ rs) ^ ")")

let n_cards : int = 4
let goal : int = 24
let digit_range : int = 9
let rec solve (xs : (string * Obj.t) list list) : bool =
  if (List.length xs = 1) then (
    let f = exprEval List.nth (xs) 0 in
    if (((Obj.obj (List.assoc "denom" (f)) <> 0) && (Obj.obj (List.assoc "num" (f)) = Obj.obj (List.assoc "denom" (f)))) * goal) then (
      print_endline (exprString List.nth (xs) 0);
      true
    ) ;
    false
  ) ;
  let i : int ref = ref 0 in
  let rec __loop0 () =
    if ((!i) < List.length xs) then (
      try
        let j = ref ((!i) + 1) in
        let rec __loop1 () =
          if ((!j) < List.length xs) then (
            try
              let rest = ref [] in
              let k : int ref = ref 0 in
              let rec __loop2 () =
                if ((!k) < List.length xs) then (
                  try
                    if (((!k) <> (!i)) && ((!k) <> (!j))) then (
                      rest := ((!rest) @ [List.nth (xs) (!k)]);
                    ) ;
                    k := ((!k) + 1);
                    __loop2 ()
                  with Continue -> ()
                ) else ()
              in try __loop2 () with Break -> ()
              ;
              let a = List.nth (xs) (!i) in
              let b = List.nth (xs) (!j) in
              let rec __loop3 lst =
                match lst with
                  | [] -> ()
                  | op::rest ->
                    (try
                      let node = ref [("op",Obj.repr (op));("left",Obj.repr (a));("right",Obj.repr (b))] in
                      if solve ((!rest) @ [(!node)]) then (
                        true
                      ) ;
                    with Continue -> ())
                    ; __loop3 rest
                in
                try __loop3 [OP_ADD;OP_SUB;OP_MUL;OP_DIV] with Break -> ()
                ;
                let node = ref [("op",Obj.repr (OP_SUB));("left",Obj.repr (b));("right",Obj.repr (a))] in
                if solve ((!rest) @ [(!node)]) then (
                  true
                ) ;
                node := [("op",Obj.repr (OP_DIV));("left",Obj.repr (b));("right",Obj.repr (a))];
                if solve ((!rest) @ [(!node)]) then (
                  true
                ) ;
                j := ((!j) + 1);
                __loop1 ()
              with Continue -> ()
            ) else ()
          in try __loop1 () with Break -> ()
          ;
          i := ((!i) + 1);
          __loop0 ()
        with Continue -> ()
      ) else ()
    in try __loop0 () with Break -> ()
    ;
    false

let rec main () =
  let iter : int ref = ref 0 in
  let rec __loop4 () =
    if ((!iter) < 10) then (
      try
        let cards = ref [] in
        let i : int ref = ref 0 in
        let rec __loop5 () =
          if ((!i) < n_cards) then (
            try
              let n : int = (((Random.bits () mod ((digit_range - 1)))) + 1) in
              cards := ((!cards) @ [newNum n]);
              print_endline ((" " ^ __show (n)));
              i := ((!i) + 1);
              __loop5 ()
            with Continue -> ()
          ) else ()
        in try __loop5 () with Break -> ()
        ;
        print_endline (":  ");
        if not (solve (!cards)) then (
          print_endline ("No solution");
        ) ;
        iter := ((!iter) + 1);
        __loop4 ()
      with Continue -> ()
    ) else ()
  in try __loop4 () with Break -> ()
  ;
  ()


let () =
  main ();
