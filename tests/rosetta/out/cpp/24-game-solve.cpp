// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
#include <any>
#include <chrono>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

inline bool __any_eq(const std::any &a, const std::any &b) {
  if (a.type() != b.type())
    return false;
  if (a.type() == typeid(int))
    return std::any_cast<int>(a) == std::any_cast<int>(b);
  if (a.type() == typeid(double))
    return std::any_cast<double>(a) == std::any_cast<double>(b);
  if (a.type() == typeid(bool))
    return std::any_cast<bool>(a) == std::any_cast<bool>(b);
  if (a.type() == typeid(std::string))
    return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);
  return false;
}
inline void __print_any(const std::any &a) {
  if (a.type() == typeid(int))
    std::cout << std::any_cast<int>(a);
  else if (a.type() == typeid(double))
    std::cout << std::any_cast<double>(a);
  else if (a.type() == typeid(bool))
    std::cout << (std::any_cast<bool>(a) ? "true" : "false");
  else if (a.type() == typeid(std::string))
    std::cout << std::any_cast<std::string>(a);
}
inline std::string __any_str(const std::any &a) {
  if (a.type() == typeid(int))
    return std::to_string(std::any_cast<int>(a));
  if (a.type() == typeid(double))
    return std::to_string(std::any_cast<double>(a));
  if (a.type() == typeid(bool))
    return std::any_cast<bool>(a) ? "true" : "false";
  if (a.type() == typeid(std::string))
    return std::any_cast<std::string>(a);
  return "";
}

template <typename T, typename U>
std::vector<T> __append(const std::vector<T> &v, const U &x) {
  auto r = v;
  r.push_back(x);
  return r;
}
inline long long _now() {
  auto n = std::chrono::system_clock::now().time_since_epoch();
  return std::chrono::duration_cast<std::chrono::nanoseconds>(n).count();
}
auto OP_NUM = 0;
auto OP_ADD = 1;
auto OP_SUB = 2;
auto OP_MUL = 3;
auto OP_DIV = 4;

auto newNum(int n) {
  return std::unordered_map<std::string, std::any>{
      {std::string("op"), OP_NUM},
      {std::string("value"),
       std::unordered_map<std::string, int>{{std::string("num"), n},
                                            {std::string("denom"), 1}}}};
}

auto exprEval(auto x) {
  if ((x[std::string("op")] == OP_NUM)) {
    return x[std::string("value")];
  }
  auto l = exprEval(x[std::string("left")]);
  auto r = exprEval(x[std::string("right")]);
  if ((x[std::string("op")] == OP_ADD)) {
    return std::unordered_map<std::string, std::any>{
        {std::string("num"),
         ((l[std::string("num")] * r[std::string("denom")]) +
          (l[std::string("denom")] * r[std::string("num")]))},
        {std::string("denom"),
         (l[std::string("denom")] * r[std::string("denom")])}};
  }
  if ((x[std::string("op")] == OP_SUB)) {
    return std::unordered_map<std::string, std::any>{
        {std::string("num"),
         ((l[std::string("num")] * r[std::string("denom")]) -
          (l[std::string("denom")] * r[std::string("num")]))},
        {std::string("denom"),
         (l[std::string("denom")] * r[std::string("denom")])}};
  }
  if ((x[std::string("op")] == OP_MUL)) {
    return std::unordered_map<std::string, std::any>{
        {std::string("num"), (l[std::string("num")] * r[std::string("num")])},
        {std::string("denom"),
         (l[std::string("denom")] * r[std::string("denom")])}};
  }
  return std::unordered_map<std::string, std::any>{
      {std::string("num"), (l[std::string("num")] * r[std::string("denom")])},
      {std::string("denom"),
       (l[std::string("denom")] * r[std::string("num")])}};
}

std::string exprString(auto x) {
  if ((x[std::string("op")] == OP_NUM)) {
    return std::to_string(x[std::string("value")][std::string("num")]);
  }
  auto ls = exprString(x[std::string("left")]);
  auto rs = exprString(x[std::string("right")]);
  auto opstr = std::string("");
  if ((x[std::string("op")] == OP_ADD)) {
    opstr = std::string(" + ");
  }
  return ((((std::string("(") + ls) + opstr) + rs) + std::string(")"));
}

bool solve(std::vector<auto> xs) {
  if ((xs.size() == 1)) {
    auto f = exprEval(xs[0]);
    if ((!__any_eq(f[std::string("denom")], std::any{0}) &&
         __any_eq(f[std::string("num")],
                  std::any{(f[std::string("denom")] * goal)}))) {
      std::cout << exprString(xs[0]) << std::endl;
      return true;
    }
    return false;
  }
  auto i = 0;
  while ((i < xs.size())) {
    auto j = (i + 1);
    while ((j < xs.size())) {
      std::vector<auto> rest = std::vector<>{};
      auto k = 0;
      while ((k < xs.size())) {
        if (((k != i) && (k != j))) {
          rest.push_back(xs[k]);
        }
        k = (k + 1);
      }
      std::vector<auto> a = xs[i];
      std::vector<auto> b = xs[j];
      for (auto op : std::vector<int>{OP_ADD, OP_SUB, OP_MUL, OP_DIV}) {
        auto node = std::unordered_map<std::string, std::any>{
            {std::string("op"), op},
            {std::string("left"), a},
            {std::string("right"), b}};
        if (solve(__append(rest, node))) {
          return true;
        }
      }
      auto node =
          std::unordered_map<std::string, std::any>{{std::string("op"), OP_SUB},
                                                    {std::string("left"), b},
                                                    {std::string("right"), a}};
      if (solve(__append(rest, node))) {
        return true;
      }
      node =
          std::unordered_map<std::string, std::any>{{std::string("op"), OP_DIV},
                                                    {std::string("left"), b},
                                                    {std::string("right"), a}};
      if (solve(__append(rest, node))) {
        return true;
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
  return false;
}

auto __mochi_main() {
  auto iter = 0;
  while ((iter < 10)) {
    std::vector<auto> cards = std::vector<>{};
    auto i = 0;
    while ((i < n_cards)) {
      auto n = (((_now() % ((digit_range - 1)))) + 1);
      cards.push_back(newNum(n));
      std::cout << (std::string(" ") + std::to_string(n)) << std::endl;
      i = (i + 1);
    }
    std::cout << std::string(":  ") << std::endl;
    if ((!solve(cards))) {
      std::cout << std::string("No solution") << std::endl;
    }
    iter = (iter + 1);
  }
}

int main() {
  auto n_cards = 4;
  auto goal = 24;
  auto digit_range = 9;
  __mochi_main();
  return 0;
}
