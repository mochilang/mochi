// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:21:14Z
#include <iostream>
#include <string>
#include <vector>

struct Point {
  float x;
  float y;
};

float sqrtApprox(float x) {
  auto g = x;
  auto i = 0;
  while ((i < 40)) {
    g = (((g + (x / g))) / 2);
    i = (i + 1);
  }
  return g;
}

float hypot(float x, float y) { return sqrtApprox(((x * x) + (y * y))); }

auto circles(Point p1, Point p2, float r) {
  if (((p1.x == p2.x) && (p1.y == p2.y))) {
    if ((r == 0)) {
      return std::vector<decltype(p1)>{
          p1, p1,
          std::string(
              "Coincident points with r==0.0 describe a degenerate circle.")};
    }
    return std::vector<decltype(p1)>{
        p1, p2,
        std::string(
            "Coincident points describe an infinite number of circles.")};
  }
  if ((r == 0)) {
    return std::vector<decltype(p1)>{
        p1, p2, std::string("R==0.0 does not describe circles.")};
  }
  auto dx = (p2.x - p1.x);
  auto dy = (p2.y - p1.y);
  auto q = hypot(dx, dy);
  if ((q > (2 * r))) {
    return std::vector<decltype(p1)>{
        p1, p2, std::string("Points too far apart to form circles.")};
  }
  auto m = Point{(((p1.x + p2.x)) / 2), (((p1.y + p2.y)) / 2)};
  if ((q == (2 * r))) {
    return std::vector<decltype(m)>{
        m, m,
        std::string(
            "Points form a diameter and describe only a single circle.")};
  }
  auto d = sqrtApprox(((r * r) - ((q * q) / 4)));
  auto ox = ((d * dx) / q);
  auto oy = ((d * dy) / q);
  return std::vector<Point>{Point{(m.x - oy), (m.y + ox)},
                            Point{(m.x + oy), (m.y - ox)},
                            std::string("Two circles.")};
}

int main() {
  auto Two = std::string("Two circles.");
  auto R0 = std::string("R==0.0 does not describe circles.");
  auto Co =
      std::string("Coincident points describe an infinite number of circles.");
  auto CoR0 = std::string(
      "Coincident points with r==0.0 describe a degenerate circle.");
  auto Diam =
      std::string("Points form a diameter and describe only a single circle.");
  auto Far = std::string("Points too far apart to form circles.");
  auto td = std::vector<decltype(std::vector<Point>{Point{0.1234, 0.9876},
                                                    Point{0.8765, 0.2345}, 2})>{
      std::vector<Point>{Point{0.1234, 0.9876}, Point{0.8765, 0.2345}, 2},
      std::vector<Point>{Point{0, 2}, Point{0, 0}, 1},
      std::vector<Point>{Point{0.1234, 0.9876}, Point{0.1234, 0.9876}, 2},
      std::vector<Point>{Point{0.1234, 0.9876}, Point{0.8765, 0.2345}, 0.5},
      std::vector<Point>{Point{0.1234, 0.9876}, Point{0.1234, 0.9876}, 0}};
  for (auto tc : td) {
    auto p1 = tc[0];
    auto p2 = tc[1];
    auto r = tc[2];
    std::cout << ((((std::string("p1:  {") + std::to_string(p1.x)) +
                    std::string(" ")) +
                   std::to_string(p1.y)) +
                  std::string("}"))
              << std::endl;
    std::cout << ((((std::string("p2:  {") + std::to_string(p2.x)) +
                    std::string(" ")) +
                   std::to_string(p2.y)) +
                  std::string("}"))
              << std::endl;
    std::cout << (std::string("r:  ") + std::to_string(r)) << std::endl;
    auto res = circles(p1, p2, r);
    auto c1 = res[0];
    auto c2 = res[1];
    auto caseStr = res[2];
    std::cout << (std::string("   ") + caseStr) << std::endl;
    if (((caseStr ==
          std::string(
              "Points form a diameter and describe only a single circle.")) ||
         (caseStr == std::string("Coincident points with r==0.0 describe a "
                                 "degenerate circle.")))) {
      std::cout << ((((std::string("   Center:  {") + std::to_string(c1.x)) +
                      std::string(" ")) +
                     std::to_string(c1.y)) +
                    std::string("}"))
                << std::endl;
    } else {
      if ((caseStr == std::string("Two circles."))) {
        std::cout << ((((std::string("   Center 1:  {") +
                         std::to_string(c1.x)) +
                        std::string(" ")) +
                       std::to_string(c1.y)) +
                      std::string("}"))
                  << std::endl;
        std::cout << ((((std::string("   Center 2:  {") +
                         std::to_string(c2.x)) +
                        std::string(" ")) +
                       std::to_string(c2.y)) +
                      std::string("}"))
                  << std::endl;
      }
    }
    std::cout << std::string("") << std::endl;
  }
  return 0;
}
