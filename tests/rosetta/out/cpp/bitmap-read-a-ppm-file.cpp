// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:21:10Z
#include <iostream>
#include <map>
#include <string>
#include <unordered_map>
#include <vector>

template <typename T> void __json(const T &);
inline void __json(int v) { std::cout << v; }
inline void __json(double v) { std::cout << v; }
inline void __json(bool v) { std::cout << (v ? "true" : "false"); }
inline void __json(const std::string &v) { std::cout << "\"" << v << "\""; }
inline void __json(const char *v) { std::cout << "\"" << v << "\""; }
template <typename T> void __json(const std::vector<T> &v) {
  std::cout << "[";
  bool first = true;
  for (const auto &x : v) {
    if (!first)
      std::cout << ",";
    first = false;
    __json(x);
  }
  std::cout << "]";
}
template <typename K, typename V> void __json(const std::map<K, V> &m) {
  std::cout << "{";
  bool first = true;
  for (const auto &kv : m) {
    if (!first)
      std::cout << ",";
    first = false;
    __json(kv.first);
    std::cout << ":";
    __json(kv.second);
  }
  std::cout << "}";
}
template <typename K, typename V>
void __json(const std::unordered_map<K, V> &m) {
  std::cout << "{";
  bool first = true;
  for (const auto &kv : m) {
    if (!first)
      std::cout << ",";
    first = false;
    __json(kv.first);
    std::cout << ":";
    __json(kv.second);
  }
  std::cout << "}";
}

struct Pixel {
  int R;
  int G;
  int B;
};
struct Bitmap {
  int w;
  int h;
  int max;
  auto data;
};
inline void __json(const Bitmap &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"w\":";
  __json(v.w);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"h\":";
  __json(v.h);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"max\":";
  __json(v.max);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"data\":";
  __json(v.data);
  std::cout << "}";
}
inline void __json(const Pixel &v) {
  bool first = true;
  std::cout << "{";
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"R\":";
  __json(v.R);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"G\":";
  __json(v.G);
  if (!first)
    std::cout << ",";
  first = false;
  std::cout << "\"B\":";
  __json(v.B);
  std::cout << "}";
}

Bitmap newBitmap(int w, int h, int max) {
  auto rows = std::vector<int>{};
  auto y = 0;
  while ((y < h)) {
    auto row = std::vector<int>{};
    auto x = 0;
    while ((x < w)) {
      row.push_back(Pixel{0, 0, 0});
      x = (x + 1);
    }
    rows.push_back(row);
    y = (y + 1);
  }
  return Bitmap{w, h, max, rows};
}

auto setPx(Bitmap b, int x, int y, Pixel p) {
  auto rows = b.data;
  auto row = rows[y];
  row[x] = p;
  rows[y] = row;
  b.data = rows;
}

Pixel getPx(Bitmap b, int x, int y) { return b.data[y][x]; }

auto splitLines(std::string s) {
  auto out = std::vector<int>{};
  auto cur = std::string("");
  auto i = 0;
  while ((i < s.size())) {
    auto ch = substr(s, i, (i + 1));
    if ((ch == std::string("\n"))) {
      out.push_back(cur);
      cur = std::string("");
    } else {
      cur = (cur + ch);
    }
    i = (i + 1);
  }
  out.push_back(cur);
  return out;
}

auto splitWS(std::string s) {
  auto out = std::vector<int>{};
  auto cur = std::string("");
  auto i = 0;
  while ((i < s.size())) {
    auto ch = substr(s, i, (i + 1));
    if (((((ch == std::string(" ")) || (ch == std::string("\t"))) ||
          (ch == std::string("\r"))) ||
         (ch == std::string("\n")))) {
      if ((cur.size() > 0)) {
        out.push_back(cur);
        cur = std::string("");
      }
    } else {
      cur = (cur + ch);
    }
    i = (i + 1);
  }
  if ((cur.size() > 0)) {
    out.push_back(cur);
  }
  return out;
}

int parseIntStr(std::string str) {
  auto i = 0;
  auto neg = false;
  if (((str.size() > 0) &&
       (std::string(str).substr(0, (1) - (0)) == std::string("-")))) {
    neg = true;
    i = 1;
  }
  auto n = 0;
  auto digits = std::unordered_map<std::string, decltype(0)>{
      {std::string("0"), 0}, {std::string("1"), 1}, {std::string("2"), 2},
      {std::string("3"), 3}, {std::string("4"), 4}, {std::string("5"), 5},
      {std::string("6"), 6}, {std::string("7"), 7}, {std::string("8"), 8},
      {std::string("9"), 9}};
  while ((i < str.size())) {
    n = ((n * 10) + digits[std::string(str).substr(i, ((i + 1)) - (i))]);
    i = (i + 1);
  }
  if (neg) {
    n = (-n);
  }
  return n;
}

auto tokenize(std::string s) {
  auto lines = splitLines(s);
  auto toks = std::vector<int>{};
  auto i = 0;
  while ((i < lines.size())) {
    auto line = lines[i];
    if (((line.size() > 0) && (substr(line, 0, 1) == std::string("#")))) {
      i = (i + 1);
      continue;
    }
    auto parts = splitWS(line);
    auto j = 0;
    while ((j < parts.size())) {
      toks.push_back(parts[j]);
      j = (j + 1);
    }
    i = (i + 1);
  }
  return toks;
}

Bitmap readP3(std::string text) {
  auto toks = tokenize(text);
  if ((toks.size() < 4)) {
    return newBitmap(0, 0, 0);
  }
  if ((toks[0] != std::string("P3"))) {
    return newBitmap(0, 0, 0);
  }
  int w = parseIntStr(toks[1]);
  int h = parseIntStr(toks[2]);
  int maxv = parseIntStr(toks[3]);
  auto idx = 4;
  auto bm = newBitmap(w, h, maxv);
  auto y = (h - 1);
  while ((y >= 0)) {
    auto x = 0;
    while ((x < w)) {
      int r = parseIntStr(toks[idx]);
      int g = parseIntStr(toks[(idx + 1)]);
      int b = parseIntStr(toks[(idx + 2)]);
      setPx(bm, x, y, Pixel{r, g, b});
      idx = (idx + 3);
      x = (x + 1);
    }
    y = (y - 1);
  }
  return bm;
}

auto toGrey(Bitmap b) {
  int h = b.h;
  int w = b.w;
  auto m = 0;
  auto y = 0;
  while ((y < h)) {
    auto x = 0;
    while ((x < w)) {
      auto p = getPx(b, x, y);
      auto l = (((((p.R * 2126) + (p.G * 7152)) + (p.B * 722))) / 10000);
      if ((l > b.max)) {
        l = b.max;
      }
      setPx(b, x, y, Pixel{l, l, l});
      if ((l > m)) {
        m = l;
      }
      x = (x + 1);
    }
    y = (y + 1);
  }
  b.max = m;
}

std::string pad(int n, int w) {
  auto s = std::to_string(n);
  while ((s.size() < w)) {
    s = (std::string(" ") + s);
  }
  return s;
}

std::string writeP3(Bitmap b) {
  int h = b.h;
  int w = b.w;
  auto max = b.max;
  auto digits = std::to_string(max).size();
  auto out = ((((((std::string("P3\n# generated from Bitmap.writeppmp3\n") +
                   std::to_string(w)) +
                  std::string(" ")) +
                 std::to_string(h)) +
                std::string("\n")) +
               std::to_string(max)) +
              std::string("\n"));
  auto y = (h - 1);
  while ((y >= 0)) {
    auto line = std::string("");
    auto x = 0;
    while ((x < w)) {
      auto p = getPx(b, x, y);
      line = ((((((line + std::string("   ")) + pad(p.R, digits)) +
                 std::string(" ")) +
                pad(p.G, digits)) +
               std::string(" ")) +
              pad(p.B, digits));
      x = (x + 1);
    }
    out = ((out + line) + std::string("\n"));
    y = (y - 1);
  }
  return out;
}

int main() {
  auto ppmtxt = std::string("P3\n"
                            "# feep.ppm\n"
                            "4 4\n"
                            "15\n"
                            " 0  0  0    0  0  0    0  0  0   15  0 15\n"
                            " 0  0  0    0 15  7    0  0  0    0  0  0\n"
                            " 0  0  0    0  0  0    0 15  7    0  0  0\n"
                            "15  0 15    0  0  0    0  0  0    0  0  0\n");
  std::cout << std::string("Original Colour PPM file") << std::endl;
  std::cout << ppmtxt << std::endl;
  auto bm = readP3(ppmtxt);
  std::cout << std::string("Grey PPM:") << std::endl;
  toGrey(bm);
  auto out = writeP3(bm);
  __json(out);
  std::cout << std::endl;
  return 0;
}
