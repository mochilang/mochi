// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:21:08Z
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

auto Node(int data) {
  return std::unordered_map<std::string, decltype(data)>{
      {std::string("Data"), data},
      {std::string("Balance"), 0},
      {std::string("Link"), std::vector<decltype(nullptr)>{nullptr, nullptr}}};
}

any getLink(auto n, int dir) { return (n[std::string("Link")])[dir]; }

auto setLink(auto n, int dir, any v) {
  auto links = n[std::string("Link")];
  links[dir] = v;
  n[std::string("Link")] = links;
}

int opp(int dir) { return (1 - dir); }

auto single(auto root, int dir) {
  auto tmp = getLink(root, opp(dir));
  setLink(root, opp(dir), getLink(tmp, dir));
  setLink(tmp, dir, root);
  return tmp;
}

auto double(auto root, int dir) {
  auto tmp = getLink(getLink(root, opp(dir)), dir);
  setLink(getLink(root, opp(dir)), dir, getLink(tmp, opp(dir)));
  setLink(tmp, opp(dir), getLink(root, opp(dir)));
  setLink(root, opp(dir), tmp);
  tmp = getLink(root, opp(dir));
  setLink(root, opp(dir), getLink(tmp, dir));
  setLink(tmp, dir, root);
  return tmp;
}

auto adjustBalance(auto root, int dir, int bal) {
  auto n = getLink(root, dir);
  auto nn = getLink(n, opp(dir));
  if ((nn[std::string("Balance")] == 0)) {
    root[std::string("Balance")] = 0;
    n[std::string("Balance")] = 0;
  }
  nn[std::string("Balance")] = 0;
}

auto insertBalance(auto root, int dir) {
  auto n = getLink(root, dir);
  auto bal = ((2 * dir) - 1);
  if ((n[std::string("Balance")] == bal)) {
    root[std::string("Balance")] = 0;
    n[std::string("Balance")] = 0;
    return single(root, opp(dir));
  }
  adjustBalance(root, dir, bal);
  return double(root, opp(dir));
}

auto insertR(any root, int data) {
  if ((root == nullptr)) {
    return std::unordered_map<std::string, decltype(Node(data))>{
        {std::string("node"), Node(data)}, {std::string("done"), false}};
  }
  auto node = root;
  auto dir = 0;
  if (((std::stoi(node[std::string("Data")])) < data)) {
    dir = 1;
  }
  auto r = insertR(getLink(node, dir), data);
  setLink(node, dir, r[std::string("node")]);
  if (r[std::string("done")]) {
    return std::unordered_map<std::string, decltype(node)>{
        {std::string("node"), node}, {std::string("done"), true}};
  }
  node[std::string("Balance")] =
      ((std::stoi(node[std::string("Balance")])) + (((2 * dir) - 1)));
  if ((node[std::string("Balance")] == 0)) {
    return std::unordered_map<std::string, decltype(node)>{
        {std::string("node"), node}, {std::string("done"), true}};
  }
  if (((node[std::string("Balance")] == 1) ||
       (node[std::string("Balance")] == (-1)))) {
    return std::unordered_map<std::string, decltype(node)>{
        {std::string("node"), node}, {std::string("done"), false}};
  }
  return std::unordered_map<std::string, decltype(insertBalance(node, dir))>{
      {std::string("node"), insertBalance(node, dir)},
      {std::string("done"), true}};
}

any Insert(any tree, int data) {
  auto r = insertR(tree, data);
  return r[std::string("node")];
}

auto removeBalance(auto root, int dir) {
  auto n = getLink(root, opp(dir));
  auto bal = ((2 * dir) - 1);
  if ((n[std::string("Balance")] == ((-bal)))) {
    root[std::string("Balance")] = 0;
    n[std::string("Balance")] = 0;
    return std::unordered_map<std::string, decltype(single(root, dir))>{
        {std::string("node"), single(root, dir)}, {std::string("done"), false}};
  }
  if ((n[std::string("Balance")] == bal)) {
    adjustBalance(root, opp(dir), ((-bal)));
    return std::unordered_map<std::string, decltype(double(root, dir))>{
        {std::string("node"), double(root, dir)}, {std::string("done"), false}};
  }
  root[std::string("Balance")] = (-bal);
  n[std::string("Balance")] = bal;
  return std::unordered_map<std::string, decltype(single(root, dir))>{
      {std::string("node"), single(root, dir)}, {std::string("done"), true}};
}

auto removeR(any root, int data) {
  if ((root == nullptr)) {
    return std::unordered_map<std::string, decltype(nullptr)>{
        {std::string("node"), nullptr}, {std::string("done"), false}};
  }
  auto node = root;
  if (((std::stoi(node[std::string("Data")])) == data)) {
    if ((getLink(node, 0) == nullptr)) {
      return std::unordered_map<std::string, decltype(getLink(node, 1))>{
          {std::string("node"), getLink(node, 1)},
          {std::string("done"), false}};
    }
    if ((getLink(node, 1) == nullptr)) {
      return std::unordered_map<std::string, decltype(getLink(node, 0))>{
          {std::string("node"), getLink(node, 0)},
          {std::string("done"), false}};
    }
    auto heir = getLink(node, 0);
    while ((getLink(heir, 1) != nullptr)) {
      heir = getLink(heir, 1);
    }
    node[std::string("Data")] = heir[std::string("Data")];
    data = std::stoi(heir[std::string("Data")]);
  }
  auto dir = 0;
  if (((std::stoi(node[std::string("Data")])) < data)) {
    dir = 1;
  }
  auto r = removeR(getLink(node, dir), data);
  setLink(node, dir, r[std::string("node")]);
  if (r[std::string("done")]) {
    return std::unordered_map<std::string, decltype(node)>{
        {std::string("node"), node}, {std::string("done"), true}};
  }
  node[std::string("Balance")] =
      (((std::stoi(node[std::string("Balance")])) + 1) - (2 * dir));
  if (((node[std::string("Balance")] == 1) ||
       (node[std::string("Balance")] == (-1)))) {
    return std::unordered_map<std::string, decltype(node)>{
        {std::string("node"), node}, {std::string("done"), true}};
  }
  if ((node[std::string("Balance")] == 0)) {
    return std::unordered_map<std::string, decltype(node)>{
        {std::string("node"), node}, {std::string("done"), false}};
  }
  return removeBalance(node, dir);
}

any Remove(any tree, int data) {
  auto r = removeR(tree, data);
  return r[std::string("node")];
}

std::string indentStr(int n) {
  auto s = std::string("");
  auto i = 0;
  while ((i < n)) {
    s = (s + std::string(" "));
    i = (i + 1);
  }
  return s;
}

auto dumpNode(any node, int indent, bool comma) {
  auto sp = indentStr(indent);
  if ((node == nullptr)) {
    auto line = (sp + std::string("null"));
    if (comma) {
      line = (line + std::string(","));
    }
    std::cout << line << std::endl;
  } else {
    std::cout << (sp + std::string("{")) << std::endl;
    std::cout << (((indentStr((indent + 3)) + std::string("\"Data\": ")) +
                   std::to_string(node[std::string("Data")])) +
                  std::string(","))
              << std::endl;
    std::cout << (((indentStr((indent + 3)) + std::string("\"Balance\": ")) +
                   std::to_string(node[std::string("Balance")])) +
                  std::string(","))
              << std::endl;
    std::cout << (indentStr((indent + 3)) + std::string("\"Link\": ["))
              << std::endl;
    dumpNode(getLink(node, 0), (indent + 6), true);
    dumpNode(getLink(node, 1), (indent + 6), false);
    std::cout << (indentStr((indent + 3)) + std::string("]")) << std::endl;
    auto end = (sp + std::string("}"));
    if (comma) {
      end = (end + std::string(","));
    }
    std::cout << end << std::endl;
  }
}

auto dump(any node, int indent) { dumpNode(node, indent, false); }

auto main() {
  auto tree = nullptr;
  std::cout << std::string("Empty tree:") << std::endl;
  dump(tree, 0);
  std::cout << std::string("") << std::endl;
  std::cout << std::string("Insert test:") << std::endl;
  tree = Insert(tree, 3);
  tree = Insert(tree, 1);
  tree = Insert(tree, 4);
  tree = Insert(tree, 1);
  tree = Insert(tree, 5);
  dump(tree, 0);
  std::cout << std::string("") << std::endl;
  std::cout << std::string("Remove test:") << std::endl;
  tree = Remove(tree, 3);
  tree = Remove(tree, 1);
  auto t = tree;
  t[std::string("Balance")] = 0;
  tree = t;
  dump(tree, 0);
}

int main() {
  main();
  return 0;
}
