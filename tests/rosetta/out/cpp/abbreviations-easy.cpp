// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
#include <iostream>
#include <string>
#include <vector>

auto fields(std::string s) {
  auto words = std::vector<int>{};
  auto cur = std::string("");
  auto i = 0;
  while ((i < s.size())) {
    auto ch = std::string(s).substr(i, ((i + 1)) - (i));
    if ((((ch == std::string(" ")) || (ch == std::string("\n"))) ||
         (ch == std::string("\t")))) {
      if ((cur.size() > 0)) {
        words.push_back(cur);
        cur = std::string("");
      }
    } else {
      cur = (cur + ch);
    }
    i = (i + 1);
  }
  if ((cur.size() > 0)) {
    words.push_back(cur);
  }
  return words;
}

std::string padRight(std::string s, int width) {
  auto out = s;
  auto i = s.size();
  while ((i < width)) {
    out = (out + std::string(" "));
    i = (i + 1);
  }
  return out;
}

std::string join(auto xs, std::string sep) {
  auto res = std::string("");
  auto i = 0;
  while ((i < xs.size())) {
    if ((i > 0)) {
      res = (res + sep);
    }
    res = (res + xs[i]);
    i = (i + 1);
  }
  return res;
}

auto validate(auto commands, auto words, auto mins) {
  auto results = std::vector<int>{};
  if ((words.size() == 0)) {
    return results;
  }
  auto wi = 0;
  while ((wi < words.size())) {
    auto w = words[wi];
    auto found = false;
    auto wlen = w.size();
    auto ci = 0;
    while ((ci < commands.size())) {
      auto cmd = commands[ci];
      if ((((mins[ci] != 0) && (wlen >= mins[ci])) && (wlen <= cmd.size()))) {
        auto c = upper(cmd);
        auto ww = upper(w);
        if ((std::string(c).substr(0, (wlen) - (0)) == ww)) {
          results.push_back(c);
          found = true;
          break;
        }
      }
      ci = (ci + 1);
    }
    if ((!found)) {
      results.push_back(std::string("*error*"));
    }
    wi = (wi + 1);
  }
  return results;
}

auto main() {
  auto table = std::string("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  "
                           "CInsert CLAst COMPress Copy "
                           "COUnt COVerlay CURsor DELete CDelete Down "
                           "DUPlicate Xedit EXPand EXTract Find "
                           "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET "
                           "Help HEXType Input POWerinput "
                           " Join SPlit SPLTJOIN  LOAD  Locate CLocate  "
                           "LOWercase UPPercase  LPrefix MACRO "
                           "MErge MODify MOve MSG Next Overlay PARSE PREServe "
                           "PURge PUT PUTD  Query  QUIT "
                           "READ  RECover REFRESH RENum REPeat  Replace "
                           "CReplace  RESet  RESTore  RGTLEFT "
                           "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck "
                           "STATus  TOP TRAnsfer TypeUp ");
  auto commands = fields(table);
  auto mins = std::vector<int>{};
  auto i = 0;
  while ((i < commands.size())) {
    auto count = 0;
    auto j = 0;
    auto cmd = commands[i];
    while ((j < cmd.size())) {
      auto ch = std::string(cmd).substr(j, ((j + 1)) - (j));
      if (((ch >= std::string("A")) && (ch <= std::string("Z")))) {
        count = (count + 1);
      }
      j = (j + 1);
    }
    mins.push_back(count);
    i = (i + 1);
  }
  auto sentence = std::string(
      "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin");
  auto words = fields(sentence);
  auto results = validate(commands, words, mins);
  auto out1 = std::string("user words:  ");
  auto k = 0;
  while ((k < words.size())) {
    out1 = ((out1 + padRight(words[k], results[k].size())) + std::string(" "));
    k = (k + 1);
  }
  std::cout << out1 << std::endl;
  std::cout << (std::string("full words:  ") + join(results, std::string(" ")))
            << std::endl;
}

int main() {
  main();
  return 0;
}
