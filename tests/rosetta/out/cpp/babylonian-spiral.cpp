// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:21:09Z
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

auto push(auto h, auto it) {
  h.push_back(it);
  auto i = (h.size() - 1);
  while (((i > 0) && (h[(i - 1)][std::string("s")] > h[i][std::string("s")]))) {
    auto tmp = h[(i - 1)];
    h[(i - 1)] = h[i];
    h[i] = tmp;
    i = (i - 1);
  }
  return h;
}

auto step(auto h, int nv, auto dir) {
  while (((h.size() == 0) || ((nv * nv) <= h[0][std::string("s")]))) {
    h = push(h, std::unordered_map<std::string, decltype((nv * nv))>{
                    {std::string("s"), (nv * nv)},
                    {std::string("a"), nv},
                    {std::string("b"), 0}});
    nv = (nv + 1);
  }
  auto s = h[0][std::string("s")];
  auto v = std::vector<int>{};
  while (((h.size() > 0) && (h[0][std::string("s")] == s))) {
    auto it = h[0];
    h = std::string(h).substr(1, (h.size()) - (1));
    v.push_back(std::vector<decltype(it[std::string("a")])>{
        it[std::string("a")], it[std::string("b")]});
    if ((it[std::string("a")] > it[std::string("b")])) {
      h = push(
          h,
          std::unordered_map<std::string,
                             decltype((
                                 (it[std::string("a")] * it[std::string("a")]) +
                                 (((it[std::string("b")] + 1)) *
                                  ((it[std::string("b")] + 1)))))>{
              {std::string("s"),
               ((it[std::string("a")] * it[std::string("a")]) +
                (((it[std::string("b")] + 1)) * ((it[std::string("b")] + 1))))},
              {std::string("a"), it[std::string("a")]},
              {std::string("b"), (it[std::string("b")] + 1)}});
    }
  }
  auto list = std::vector<int>{};
  for (auto p : v) {
    list.push_back(p);
  }
  auto temp = list;
  for (auto p : temp) {
    if ((p[0] != p[1])) {
      list.push_back(std::vector<decltype(p[1])>{p[1], p[0]});
    }
  }
  temp = list;
  for (auto p : temp) {
    if ((p[1] != 0)) {
      list.push_back(std::vector<decltype(p[0])>{p[0], (-p[1])});
    }
  }
  temp = list;
  for (auto p : temp) {
    if ((p[0] != 0)) {
      list.push_back(std::vector<decltype((-p[0]))>{(-p[0]), p[1]});
    }
  }
  auto bestDot = -999999999;
  auto best = dir;
  for (auto p : list) {
    auto cross = ((p[0] * dir[1]) - (p[1] * dir[0]));
    if ((cross >= 0)) {
      auto dot = ((p[0] * dir[0]) + (p[1] * dir[1]));
      if ((dot > bestDot)) {
        bestDot = dot;
        best = p;
      }
    }
  }
  return std::unordered_map<std::string, decltype(best)>{
      {std::string("d"), best},
      {std::string("heap"), h},
      {std::string("n"), nv}};
}

auto positions(int n) {
  auto pos = std::vector<int>{};
  auto x = 0;
  auto y = 0;
  auto dir = std::vector<int>{0, 1};
  auto heap = std::vector<int>{};
  auto nv = 1;
  auto i = 0;
  while ((i < n)) {
    pos.push_back(std::vector<decltype(x)>{x, y});
    auto st = step(heap, nv, dir);
    dir = st[std::string("d")];
    heap = st[std::string("heap")];
    nv = std::stoi(st[std::string("n")]);
    x = (x + dir[0]);
    y = (y + dir[1]);
    i = (i + 1);
  }
  return pos;
}

std::string pad(std::string s, int w) {
  auto r = s;
  while ((r.size() < w)) {
    r = (r + std::string(" "));
  }
  return r;
}

auto main() {
  auto pts = positions(40);
  std::cout << std::string("The first 40 Babylonian spiral points are:")
            << std::endl;
  auto line = std::string("");
  auto i = 0;
  while ((i < pts.size())) {
    auto p = pts[i];
    auto s =
        pad(((((std::string("(") + std::to_string(p[0])) + std::string(", ")) +
              std::to_string(p[1])) +
             std::string(")")),
            10);
    line = (line + s);
    if (((((i + 1)) % 10) == 0)) {
      std::cout << line << std::endl;
      line = std::string("");
    }
    i = (i + 1);
  }
}

int main() {
  main();
  return 0;
}
