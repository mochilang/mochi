// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
#include <any>
#include <chrono>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

inline bool __any_eq(const std::any &a, const std::any &b) {
  if (a.type() != b.type())
    return false;
  if (a.type() == typeid(int))
    return std::any_cast<int>(a) == std::any_cast<int>(b);
  if (a.type() == typeid(double))
    return std::any_cast<double>(a) == std::any_cast<double>(b);
  if (a.type() == typeid(bool))
    return std::any_cast<bool>(a) == std::any_cast<bool>(b);
  if (a.type() == typeid(std::string))
    return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);
  return false;
}
inline void __print_any(const std::any &a) {
  if (a.type() == typeid(int))
    std::cout << std::any_cast<int>(a);
  else if (a.type() == typeid(double))
    std::cout << std::any_cast<double>(a);
  else if (a.type() == typeid(bool))
    std::cout << (std::any_cast<bool>(a) ? "true" : "false");
  else if (a.type() == typeid(std::string))
    std::cout << std::any_cast<std::string>(a);
}
inline std::string __any_str(const std::any &a) {
  if (a.type() == typeid(int))
    return std::to_string(std::any_cast<int>(a));
  if (a.type() == typeid(double))
    return std::to_string(std::any_cast<double>(a));
  if (a.type() == typeid(bool))
    return std::any_cast<bool>(a) ? "true" : "false";
  if (a.type() == typeid(std::string))
    return std::any_cast<std::string>(a);
  return "";
}

inline long long _now() {
  auto n = std::chrono::system_clock::now().time_since_epoch();
  return std::chrono::duration_cast<std::chrono::nanoseconds>(n).count();
}
auto SIZE = 4;

std::vector<std::vector<int>> newBoard() {
  std::vector<std::vector<int>> b = std::vector<>{};
  auto y = 0;
  while ((y < SIZE)) {
    std::vector<int> row = std::vector<>{};
    auto x = 0;
    while ((x < SIZE)) {
      row.push_back(0);
      x = (x + 1);
    }
    b.push_back(row);
    y = (y + 1);
  }
  return b;
}

auto spawnTile(std::vector<std::vector<int>> b) {
  std::vector<std::vector<int>> empty = std::vector<>{};
  auto y = 0;
  while ((y < SIZE)) {
    auto x = 0;
    while ((x < SIZE)) {
      if ((b[y][x] == 0)) {
        empty.push_back(std::vector<int>{x, y});
      }
      x = (x + 1);
    }
    y = (y + 1);
  }
  if ((empty.size() == 0)) {
    return std::unordered_map<std::string, std::any>{
        {std::string("board"), b}, {std::string("full"), true}};
  }
  auto idx = (_now() % empty.size());
  std::vector<std::vector<int>> cell = empty[idx];
  auto val = 4;
  if (((_now() % 10) < 9)) {
    val = 2;
  }
  b[cell[1]][cell[0]] = val;
  return std::unordered_map<std::string, std::any>{
      {std::string("board"), b}, {std::string("full"), (empty.size() == 1)}};
}

std::string pad(int n) {
  auto s = std::to_string(n);
  auto pad = (4 - s.size());
  auto i = 0;
  auto out = std::string("");
  while ((i < pad)) {
    out = (out + std::string(" "));
    i = (i + 1);
  }
  return (out + s);
}

auto draw(std::vector<std::vector<int>> b, int score) {
  std::cout << (std::string("Score: ") + std::to_string(score)) << std::endl;
  auto y = 0;
  while ((y < SIZE)) {
    std::cout << std::string("+----+----+----+----+") << std::endl;
    auto line = std::string("|");
    auto x = 0;
    while ((x < SIZE)) {
      std::vector<std::vector<int>> v = b[y][x];
      if ((v == 0)) {
        line = (line + std::string("    |"));
      } else {
        line = ((line + pad(v)) + std::string("|"));
      }
      x = (x + 1);
    }
    std::cout << line << std::endl;
    y = (y + 1);
  }
  std::cout << std::string("+----+----+----+----+") << std::endl;
  std::cout << std::string("W=Up S=Down A=Left D=Right Q=Quit") << std::endl;
}

std::vector<int> reverseRow(std::vector<int> r) {
  std::vector<int> out = std::vector<>{};
  auto i = (r.size() - 1);
  while ((i >= 0)) {
    out.push_back(r[i]);
    i = (i - 1);
  }
  return out;
}

auto slideLeft(std::vector<int> row) {
  std::vector<int> xs = std::vector<>{};
  auto i = 0;
  while ((i < row.size())) {
    if ((row[i] != 0)) {
      xs.push_back(row[i]);
    }
    i = (i + 1);
  }
  std::vector<int> res = std::vector<>{};
  auto gain = 0;
  i = 0;
  while ((i < xs.size())) {
    if ((((i + 1) < xs.size()) && (xs[i] == xs[(i + 1)]))) {
      auto v = (xs[i] * 2);
      gain = (gain + v);
      res.push_back(v);
      i = (i + 2);
    } else {
      res.push_back(xs[i]);
      i = (i + 1);
    }
  }
  while ((res.size() < SIZE)) {
    res.push_back(0);
  }
  return std::unordered_map<std::string, std::any>{{std::string("row"), res},
                                                   {std::string("gain"), gain}};
}

auto moveLeft(std::vector<std::vector<int>> b, int score) {
  auto moved = false;
  auto y = 0;
  while ((y < SIZE)) {
    auto r = slideLeft(b[y]);
    std::vector<std::any> _new = r[std::string("row")];
    score = (score + r[std::string("gain")]);
    auto x = 0;
    while ((x < SIZE)) {
      if ((b[y][x] != _new[x])) {
        moved = true;
      }
      b[y][x] = _new[x];
      x = (x + 1);
    }
    y = (y + 1);
  }
  return std::unordered_map<std::string, std::any>{
      {std::string("board"), b},
      {std::string("score"), score},
      {std::string("moved"), moved}};
}

auto moveRight(std::vector<std::vector<int>> b, int score) {
  auto moved = false;
  auto y = 0;
  while ((y < SIZE)) {
    auto rev = reverseRow(b[y]);
    auto r = slideLeft(rev);
    rev = r[std::string("row")];
    score = (score + r[std::string("gain")]);
    rev = reverseRow(rev);
    auto x = 0;
    while ((x < SIZE)) {
      if ((b[y][x] != rev[x])) {
        moved = true;
      }
      b[y][x] = rev[x];
      x = (x + 1);
    }
    y = (y + 1);
  }
  return std::unordered_map<std::string, std::any>{
      {std::string("board"), b},
      {std::string("score"), score},
      {std::string("moved"), moved}};
}

std::vector<int> getCol(std::vector<std::vector<int>> b, int x) {
  std::vector<int> col = std::vector<>{};
  auto y = 0;
  while ((y < SIZE)) {
    col.push_back(b[y][x]);
    y = (y + 1);
  }
  return col;
}

auto setCol(std::vector<std::vector<int>> b, int x, std::vector<int> col) {
  auto y = 0;
  while ((y < SIZE)) {
    b[y][x] = col[y];
    y = (y + 1);
  }
}

auto moveUp(std::vector<std::vector<int>> b, int score) {
  auto moved = false;
  auto x = 0;
  while ((x < SIZE)) {
    auto col = getCol(b, x);
    auto r = slideLeft(col);
    std::vector<std::any> _new = r[std::string("row")];
    score = (score + r[std::string("gain")]);
    auto y = 0;
    while ((y < SIZE)) {
      if ((b[y][x] != _new[y])) {
        moved = true;
      }
      b[y][x] = _new[y];
      y = (y + 1);
    }
    x = (x + 1);
  }
  return std::unordered_map<std::string, std::any>{
      {std::string("board"), b},
      {std::string("score"), score},
      {std::string("moved"), moved}};
}

auto moveDown(std::vector<std::vector<int>> b, int score) {
  auto moved = false;
  auto x = 0;
  while ((x < SIZE)) {
    auto col = reverseRow(getCol(b, x));
    auto r = slideLeft(col);
    col = r[std::string("row")];
    score = (score + r[std::string("gain")]);
    col = reverseRow(col);
    auto y = 0;
    while ((y < SIZE)) {
      if ((b[y][x] != col[y])) {
        moved = true;
      }
      b[y][x] = col[y];
      y = (y + 1);
    }
    x = (x + 1);
  }
  return std::unordered_map<std::string, std::any>{
      {std::string("board"), b},
      {std::string("score"), score},
      {std::string("moved"), moved}};
}

bool hasMoves(std::vector<std::vector<int>> b) {
  auto y = 0;
  while ((y < SIZE)) {
    auto x = 0;
    while ((x < SIZE)) {
      if ((b[y][x] == 0)) {
        return true;
      }
      if ((((x + 1) < SIZE) && (b[y][x] == b[y][(x + 1)]))) {
        return true;
      }
      if ((((y + 1) < SIZE) && (b[y][x] == b[(y + 1)][x]))) {
        return true;
      }
      x = (x + 1);
    }
    y = (y + 1);
  }
  return false;
}

bool has2048(std::vector<std::vector<int>> b) {
  auto y = 0;
  while ((y < SIZE)) {
    auto x = 0;
    while ((x < SIZE)) {
      if ((b[y][x] >= 2048)) {
        return true;
      }
      x = (x + 1);
    }
    y = (y + 1);
  }
  return false;
}

int main() {
  auto board = newBoard();
  auto r = spawnTile(board);
  board = r[std::string("board")];
  std::vector<std::any> full = r[std::string("full")];
  r = spawnTile(board);
  board = r[std::string("board")];
  full = r[std::string("full")];
  auto score = 0;
  draw(board, score);
  while (true) {
    std::cout << std::string("Move: ") << std::endl;
    auto cmd = input();
    auto moved = false;
    if (((cmd == std::string("a")) || (cmd == std::string("A")))) {
      auto m = moveLeft(board, score);
      board = m[std::string("board")];
      score = m[std::string("score")];
      moved = m[std::string("moved")];
    }
    if (((cmd == std::string("d")) || (cmd == std::string("D")))) {
      auto m = moveRight(board, score);
      board = m[std::string("board")];
      score = m[std::string("score")];
      moved = m[std::string("moved")];
    }
    if (((cmd == std::string("w")) || (cmd == std::string("W")))) {
      auto m = moveUp(board, score);
      board = m[std::string("board")];
      score = m[std::string("score")];
      moved = m[std::string("moved")];
    }
    if (((cmd == std::string("s")) || (cmd == std::string("S")))) {
      auto m = moveDown(board, score);
      board = m[std::string("board")];
      score = m[std::string("score")];
      moved = m[std::string("moved")];
    }
    if (((cmd == std::string("q")) || (cmd == std::string("Q")))) {
      break;
    }
    if (moved) {
      auto r2 = spawnTile(board);
      board = r2[std::string("board")];
      full = r2[std::string("full")];
      if ((full && ((!hasMoves(board))))) {
        draw(board, score);
        std::cout << std::string("Game Over") << std::endl;
        break;
      }
    }
    draw(board, score);
    if (has2048(board)) {
      std::cout << std::string("You win!") << std::endl;
      break;
    }
    if ((!hasMoves(board))) {
      std::cout << std::string("Game Over") << std::endl;
      break;
    }
  }
  return 0;
}
