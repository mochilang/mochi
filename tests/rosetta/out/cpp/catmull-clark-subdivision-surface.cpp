// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:21:13Z
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

struct Point {
  float x;
  float y;
  float z;
};
struct Edge {
  int pn1;
  int pn2;
  int fn1;
  int fn2;
  Point cp;
};
struct PointEx {
  Point p;
  int n;
};

int indexOf(std::string s, std::string ch) {
  auto i = 0;
  while ((i < s.size())) {
    if ((std::string(s).substr(i, ((i + 1)) - (i)) == ch)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}

std::string fmt4(float x) {
  auto y = (x * 10000);
  if ((y >= 0)) {
    y = (y + 0.5);
  } else {
    y = (y - 0.5);
  }
  y = ((std::stoi(y)) / 10000);
  auto s = std::to_string(y);
  auto dot = indexOf(s, std::string("."));
  if ((dot == -1)) {
    s = (s + std::string(".0000"));
  } else {
    auto decs = ((s.size() - dot) - 1);
    if ((decs > 4)) {
      s = std::string(s).substr(0, ((dot + 5)) - (0));
    } else {
      while ((decs < 4)) {
        s = (s + std::string("0"));
        decs = (decs + 1);
      }
    }
  }
  if ((x >= 0)) {
    s = (std::string(" ") + s);
  }
  return s;
}

std::string fmt2(int n) {
  auto s = std::to_string(n);
  if ((s.size() < 2)) {
    return (std::string(" ") + s);
  }
  return s;
}

Point sumPoint(Point p1, Point p2) {
  return Point{(p1.x + p2.x), (p1.y + p2.y), (p1.z + p2.z)};
}

Point mulPoint(Point p, float m) {
  return Point{(p.x * m), (p.y * m), (p.z * m)};
}

Point divPoint(Point p, float d) { return mulPoint(p, (1 / d)); }

Point centerPoint(Point p1, Point p2) { return divPoint(sumPoint(p1, p2), 2); }

auto getFacePoints(auto points, auto faces) {
  auto facePoints = std::vector<int>{};
  auto i = 0;
  while ((i < faces.size())) {
    auto face = faces[i];
    auto fp = Point{0, 0, 0};
    for (auto idx : face) {
      fp = sumPoint(fp, points[idx]);
    }
    fp = divPoint(fp, (face.size()));
    facePoints.push_back(fp);
    i = (i + 1);
  }
  return facePoints;
}

auto sortEdges(auto edges) {
  auto res = std::vector<int>{};
  auto tmp = edges;
  while ((tmp.size() > 0)) {
    auto min = tmp[0];
    auto idx = 0;
    auto j = 1;
    while ((j < tmp.size())) {
      auto e = tmp[j];
      if (((e[0] < min[0]) || (((e[0] == min[0]) &&
                                (((e[1] < min[1]) || (((e[1] == min[1]) &&
                                                       (e[2] < min[2]))))))))) {
        min = e;
        idx = j;
      }
      j = (j + 1);
    }
    res.push_back(min);
    auto out = std::vector<int>{};
    auto k = 0;
    while ((k < tmp.size())) {
      if ((k != idx)) {
        out.push_back(tmp[k]);
      }
      k = (k + 1);
    }
    tmp = out;
  }
  return res;
}

auto getEdgesFaces(auto points, auto faces) {
  auto edges = std::vector<int>{};
  auto fnum = 0;
  while ((fnum < faces.size())) {
    auto face = faces[fnum];
    auto numP = face.size();
    auto pi = 0;
    while ((pi < numP)) {
      auto pn1 = face[pi];
      auto pn2 = 0;
      if ((pi < (numP - 1))) {
        pn2 = face[(pi + 1)];
      } else {
        pn2 = face[0];
      }
      if ((pn1 > pn2)) {
        auto tmpn = pn1;
        pn1 = pn2;
        pn2 = tmpn;
      }
      edges.push_back(std::vector<decltype(pn1)>{pn1, pn2, fnum});
      pi = (pi + 1);
    }
    fnum = (fnum + 1);
  }
  edges = sortEdges(edges);
  auto merged = std::vector<int>{};
  auto idx = 0;
  while ((idx < edges.size())) {
    auto e1 = edges[idx];
    if ((idx < (edges.size() - 1))) {
      auto e2 = edges[(idx + 1)];
      if (((e1[0] == e2[0]) && (e1[1] == e2[1]))) {
        merged.push_back(
            std::vector<decltype(e1[0])>{e1[0], e1[1], e1[2], e2[2]});
        idx = (idx + 2);
        continue;
      }
    }
    merged.push_back(std::vector<decltype(e1[0])>{e1[0], e1[1], e1[2], -1});
    idx = (idx + 1);
  }
  auto edgesCenters = std::vector<int>{};
  for (auto me : merged) {
    auto p1 = points[me[0]];
    auto p2 = points[me[1]];
    auto cp = centerPoint(p1, p2);
    edgesCenters.push_back(Edge{me[0], me[1], me[2], me[3], cp});
  }
  return edgesCenters;
}

auto getEdgePoints(auto points, auto edgesFaces, auto facePoints) {
  auto edgePoints = std::vector<int>{};
  auto i = 0;
  while ((i < edgesFaces.size())) {
    auto edge = edgesFaces[i];
    auto cp = edge.cp;
    auto fp1 = facePoints[edge.fn1];
    auto fp2 = fp1;
    if ((edge.fn2 != -1)) {
      fp2 = facePoints[edge.fn2];
    }
    auto cfp = centerPoint(fp1, fp2);
    edgePoints.push_back(centerPoint(cp, cfp));
    i = (i + 1);
  }
  return edgePoints;
}

auto getAvgFacePoints(auto points, auto faces, auto facePoints) {
  auto numP = points.size();
  auto temp = std::vector<int>{};
  auto i = 0;
  while ((i < numP)) {
    temp.push_back(PointEx{Point{0, 0, 0}, 0});
    i = (i + 1);
  }
  auto fnum = 0;
  while ((fnum < faces.size())) {
    auto fp = facePoints[fnum];
    for (auto pn : faces[fnum]) {
      auto tp = temp[pn];
      temp[pn] = PointEx{sumPoint(tp.p, fp), (tp.n + 1)};
    }
    fnum = (fnum + 1);
  }
  auto avg = std::vector<int>{};
  auto j = 0;
  while ((j < numP)) {
    auto tp = temp[j];
    avg.push_back(divPoint(tp.p, tp.n));
    j = (j + 1);
  }
  return avg;
}

auto getAvgMidEdges(auto points, auto edgesFaces) {
  auto numP = points.size();
  auto temp = std::vector<int>{};
  auto i = 0;
  while ((i < numP)) {
    temp.push_back(PointEx{Point{0, 0, 0}, 0});
    i = (i + 1);
  }
  for (auto edge : edgesFaces) {
    auto cp = edge.cp;
    auto arr = std::vector<decltype(edge.pn1)>{edge.pn1, edge.pn2};
    for (auto pn : arr) {
      auto tp = temp[pn];
      temp[pn] = PointEx{sumPoint(tp.p, cp), (tp.n + 1)};
    }
  }
  auto avg = std::vector<int>{};
  auto j = 0;
  while ((j < numP)) {
    auto tp = temp[j];
    avg.push_back(divPoint(tp.p, tp.n));
    j = (j + 1);
  }
  return avg;
}

auto getPointsFaces(auto points, auto faces) {
  auto pf = std::vector<int>{};
  auto i = 0;
  while ((i < points.size())) {
    pf.push_back(0);
    i = (i + 1);
  }
  auto fnum = 0;
  while ((fnum < faces.size())) {
    for (auto pn : faces[fnum]) {
      pf[pn] = (pf[pn] + 1);
    }
    fnum = (fnum + 1);
  }
  return pf;
}

auto getNewPoints(auto points, auto pf, auto afp, auto ame) {
  auto newPts = std::vector<int>{};
  auto i = 0;
  while ((i < points.size())) {
    auto n = pf[i];
    auto m1 = (((n - 3)) / n);
    auto m2 = (1 / n);
    auto m3 = (2 / n);
    auto old = points[i];
    auto p1 = mulPoint(old, m1);
    auto p2 = mulPoint(afp[i], m2);
    auto p3 = mulPoint(ame[i], m3);
    newPts.push_back(sumPoint(sumPoint(p1, p2), p3));
    i = (i + 1);
  }
  return newPts;
}

std::string key(int a, int b) {
  if ((a < b)) {
    return ((std::to_string(a) + std::string(",")) + std::to_string(b));
  }
  return ((std::to_string(b) + std::string(",")) + std::to_string(a));
}

auto cmcSubdiv(auto points, auto faces) {
  auto facePoints = getFacePoints(points, faces);
  auto edgesFaces = getEdgesFaces(points, faces);
  auto edgePoints = getEdgePoints(points, edgesFaces, facePoints);
  auto avgFacePoints = getAvgFacePoints(points, faces, facePoints);
  auto avgMidEdges = getAvgMidEdges(points, edgesFaces);
  auto pointsFaces = getPointsFaces(points, faces);
  auto newPoints =
      getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges);
  auto facePointNums = std::vector<int>{};
  auto nextPoint = newPoints.size();
  for (auto fp : facePoints) {
    newPoints.push_back(fp);
    facePointNums.push_back(nextPoint);
    nextPoint = (nextPoint + 1);
  }
  auto edgePointNums = std::unordered_map<int, int>{};
  auto idx = 0;
  while ((idx < edgesFaces.size())) {
    auto e = edgesFaces[idx];
    newPoints.push_back(edgePoints[idx]);
    edgePointNums[key(e.pn1, e.pn2)] = nextPoint;
    nextPoint = (nextPoint + 1);
    idx = (idx + 1);
  }
  auto newFaces = std::vector<int>{};
  auto fnum = 0;
  while ((fnum < faces.size())) {
    auto oldFace = faces[fnum];
    if ((oldFace.size() == 4)) {
      auto a = oldFace[0];
      auto b = oldFace[1];
      auto c = oldFace[2];
      auto d = oldFace[3];
      auto fpnum = facePointNums[fnum];
      auto ab = edgePointNums[key(a, b)];
      auto da = edgePointNums[key(d, a)];
      auto bc = edgePointNums[key(b, c)];
      auto cd = edgePointNums[key(c, d)];
      newFaces.push_back(std::vector<decltype(a)>{a, ab, fpnum, da});
      newFaces.push_back(std::vector<decltype(b)>{b, bc, fpnum, ab});
      newFaces.push_back(std::vector<decltype(c)>{c, cd, fpnum, bc});
      newFaces.push_back(std::vector<decltype(d)>{d, da, fpnum, cd});
    }
    fnum = (fnum + 1);
  }
  return std::vector<int>{newPoints, newFaces};
}

std::string formatPoint(Point p) {
  return ((((((std::string("[") + fmt4(p.x)) + std::string(" ")) + fmt4(p.y)) +
            std::string(" ")) +
           fmt4(p.z)) +
          std::string("]"));
}

std::string formatFace(auto f) {
  if ((f.size() == 0)) {
    return std::string("[]");
  }
  auto s = (std::string("[") + fmt2(f[0]));
  auto i = 1;
  while ((i < f.size())) {
    s = ((s + std::string(" ")) + fmt2(f[i]));
    i = (i + 1);
  }
  s = (s + std::string("]"));
  return s;
}

auto main() {
  std::vector<Point> inputPoints = {
      Point{-1, 1, 1},  Point{-1, -1, 1}, Point{1, -1, 1},   Point{1, 1, 1},
      Point{1, -1, -1}, Point{1, 1, -1},  Point{-1, -1, -1}, Point{-1, 1, -1}};
  auto inputFaces = std::vector<decltype(std::vector<int>{0, 1, 2, 3})>{
      std::vector<int>{0, 1, 2, 3}, std::vector<int>{3, 2, 4, 5},
      std::vector<int>{5, 4, 6, 7}, std::vector<int>{7, 0, 3, 5},
      std::vector<int>{7, 6, 1, 0}, std::vector<int>{6, 1, 2, 4}};
  auto outputPoints = inputPoints;
  auto outputFaces = inputFaces;
  auto i = 0;
  while ((i < 1)) {
    auto res = cmcSubdiv(outputPoints, outputFaces);
    outputPoints = res[0];
    outputFaces = res[1];
    i = (i + 1);
  }
  for (auto p : outputPoints) {
    std::cout << formatPoint(p) << std::endl;
  }
  std::cout << std::string("") << std::endl;
  for (auto f : outputFaces) {
    std::cout << formatFace(f) << std::endl;
  }
}

int main() {
  main();
  return 0;
}
