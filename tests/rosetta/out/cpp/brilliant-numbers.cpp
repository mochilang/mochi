// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:21:11Z
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

auto primesUpTo(int n) {
  auto sieve = std::vector<int>{};
  auto i = 0;
  while ((i <= n)) {
    sieve.push_back(true);
    i = (i + 1);
  }
  auto p = 2;
  while (((p * p) <= n)) {
    if (sieve[p]) {
      auto m = (p * p);
      while ((m <= n)) {
        sieve[m] = false;
        m = (m + p);
      }
    }
    p = (p + 1);
  }
  auto res = std::vector<int>{};
  auto x = 2;
  while ((x <= n)) {
    if (sieve[x]) {
      res.push_back(x);
    }
    x = (x + 1);
  }
  return res;
}

auto sortInts(auto xs) {
  auto res = std::vector<int>{};
  auto tmp = xs;
  while ((tmp.size() > 0)) {
    auto min = tmp[0];
    auto idx = 0;
    auto i = 1;
    while ((i < tmp.size())) {
      if ((tmp[i] < min)) {
        min = tmp[i];
        idx = i;
      }
      i = (i + 1);
    }
    res.push_back(min);
    auto out = std::vector<int>{};
    auto j = 0;
    while ((j < tmp.size())) {
      if ((j != idx)) {
        out.push_back(tmp[j]);
      }
      j = (j + 1);
    }
    tmp = out;
  }
  return res;
}

std::string commatize(int n) {
  auto s = std::to_string(n);
  auto i = (s.size() - 3);
  while ((i >= 1)) {
    s = std::string(s).substr(0, (i) - (0) "," s).substr(i, (s.size()) - (i));
    i = (i - 3);
  }
  return s;
}

auto getBrilliant(int digits, int limit, bool countOnly) {
  auto brilliant = std::vector<int>{};
  auto count = 0;
  auto pow = 1;
  auto next = 999999999999999;
  auto k = 1;
  while ((k <= digits)) {
    auto s = std::vector<int>{};
    for (auto p : primes) {
      if ((p >= (pow * 10))) {
        break;
      }
      if ((p > pow)) {
        s.push_back(p);
      }
    }
    auto i = 0;
    while ((i < s.size())) {
      auto j = i;
      while ((j < s.size())) {
        auto prod = (s[i] * s[j]);
        if ((prod < limit)) {
          if (countOnly) {
            count = (count + 1);
          } else {
            brilliant.push_back(prod);
          }
        } else {
          if ((prod < next)) {
            next = prod;
          }
          break;
        }
        j = (j + 1);
      }
      i = (i + 1);
    }
    pow = (pow * 10);
    k = (k + 1);
  }
  if (countOnly) {
    return std::unordered_map<std::string, decltype(count)>{
        {std::string("bc"), count}, {std::string("next"), next}};
  }
  return std::unordered_map<std::string, decltype(brilliant)>{
      {std::string("bc"), brilliant}, {std::string("next"), next}};
}

auto main() {
  std::cout << std::string("First 100 brilliant numbers:") << std::endl;
  auto r = getBrilliant(2, 10000, false);
  auto br = sortInts(r[std::string("bc")]);
  br = std::string(br).substr(0, (100) - (0));
  auto i = 0;
  while ((i < br.size())) {
    {
      std::cout << (std::to_string(br[i])(4, std::string(" ")) +
                    std::string(" "));
      std::cout << ' ';
      std::cout << (false ? "true" : "false");
      std::cout << std::endl;
    }
    if (((((i + 1)) % 10) == 0)) {
      {
        std::cout << std::string("");
        std::cout << ' ';
        std::cout << (true ? "true" : "false");
        std::cout << std::endl;
      }
    }
    i = (i + 1);
  }
  {
    std::cout << std::string("");
    std::cout << ' ';
    std::cout << (true ? "true" : "false");
    std::cout << std::endl;
  }
  auto k = 1;
  while ((k <= 13)) {
    auto limit = pow(10, k);
    auto r2 = getBrilliant(k, limit, true);
    auto total = r2[std::string("bc")];
    auto next = r2[std::string("next")];
    auto climit = commatize(limit);
    auto ctotal = commatize((total + 1));
    auto cnext = commatize(next);
    std::cout << (((((std::string("First >= ") +
                      climit.padStart(18, std::string(" "))) +
                     std::string(" is ")) +
                    ctotal.padStart(14, std::string(" "))) +
                   std::string(" in the series: ")) +
                  cnext.padStart(18, std::string(" ")))
              << std::endl;
    k = (k + 1);
  }
}

int main() {
  auto primes = primesUpTo(3200000);
  return 0;
}
