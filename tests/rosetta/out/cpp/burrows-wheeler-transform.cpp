// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:21:11Z
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

auto stx = std::string("\x02");
auto etx = std::string("\x03");

bool contains(std::string s, std::string ch) {
  auto i = 0;
  while ((i < s.size())) {
    if ((std::string(s).substr(i, ((i + 1)) - (i)) == ch)) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}

auto sortStrings(auto xs) {
  auto arr = xs;
  auto n = arr.size();
  auto i = 0;
  while ((i < n)) {
    auto j = 0;
    while ((j < (n - 1))) {
      if ((arr[j] > arr[(j + 1)])) {
        auto tmp = arr[j];
        arr[j] = arr[(j + 1)];
        arr[(j + 1)] = tmp;
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
  return arr;
}

auto bwt(std::string s) {
  if ((contains(s, stx) || contains(s, etx))) {
    return std::unordered_map<std::string, decltype(true)>{
        {std::string("err"), true}, {std::string("res"), std::string("")}};
  }
  s = ((stx + s) + etx);
  auto le = s.size();
  auto table = std::vector<int>{};
  auto i = 0;
  while ((i < le)) {
    auto rot = std::string(s).substr(i, (le) - (i)s).substr(0, (i) - (0));
    table.push_back(rot);
    i = (i + 1);
  }
  table = sortStrings(table);
  auto last = std::string("");
  i = 0;
  while ((i < le)) {
    last = (last + std::string(table[i]).substr((le - 1), (le) - ((le - 1))));
    i = (i + 1);
  }
  return std::unordered_map<std::string, decltype(false)>{
      {std::string("err"), false}, {std::string("res"), last}};
}

std::string ibwt(std::string r) {
  auto le = r.size();
  auto table = std::vector<int>{};
  auto i = 0;
  while ((i < le)) {
    table.push_back(std::string(""));
    i = (i + 1);
  }
  auto n = 0;
  while ((n < le)) {
    i = 0;
    while ((i < le)) {
      table[i] = (std::string(r).substr(i, ((i + 1)) - (i)) + table[i]);
      i = (i + 1);
    }
    table = sortStrings(table);
    n = (n + 1);
  }
  i = 0;
  while ((i < le)) {
    if ((std::string(table[i]).substr((le - 1), (le) - ((le - 1))) == etx)) {
      return std::string(table[i]).substr(1, ((le - 1)) - (1));
    }
    i = (i + 1);
  }
  return std::string("");
}

std::string makePrintable(std::string s) {
  auto out = std::string("");
  auto i = 0;
  while ((i < s.size())) {
    auto ch = std::string(s).substr(i, ((i + 1)) - (i));
    if ((ch == stx)) {
      out = (out + std::string("^"));
    }
    i = (i + 1);
  }
  return out;
}

auto main() {
  std::vector<std::string> examples = {
      std::string("banana"),
      std::string("appellee"),
      std::string("dogwood"),
      std::string("TO BE OR NOT TO BE OR WANT TO BE OR NOT?"),
      std::string("SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES"),
      std::string("\x02ABC\x03")};
  for (auto t : examples) {
    std::cout << makePrintable(t) << std::endl;
    auto res = bwt(t);
    if (res[std::string("err")]) {
      std::cout << std::string(" --> ERROR: String can't contain STX or ETX")
                << std::endl;
      std::cout << std::string(" -->") << std::endl;
    } else {
      auto enc = std::to_string(res[std::string("res")]);
      std::cout << (std::string(" --> ") + makePrintable(enc)) << std::endl;
      auto r = ibwt(enc);
      std::cout << (std::string(" --> ") + r) << std::endl;
    }
    std::cout << std::string("") << std::endl;
  }
}

int main() {
  main();
  return 0;
}
