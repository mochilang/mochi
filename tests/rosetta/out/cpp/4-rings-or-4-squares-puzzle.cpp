// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
#include <any>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

inline bool __any_eq(const std::any &a, const std::any &b) {
  if (a.type() != b.type())
    return false;
  if (a.type() == typeid(int))
    return std::any_cast<int>(a) == std::any_cast<int>(b);
  if (a.type() == typeid(double))
    return std::any_cast<double>(a) == std::any_cast<double>(b);
  if (a.type() == typeid(bool))
    return std::any_cast<bool>(a) == std::any_cast<bool>(b);
  if (a.type() == typeid(std::string))
    return std::any_cast<std::string>(a) == std::any_cast<std::string>(b);
  return false;
}
inline void __print_any(const std::any &a) {
  if (a.type() == typeid(int))
    std::cout << std::any_cast<int>(a);
  else if (a.type() == typeid(double))
    std::cout << std::any_cast<double>(a);
  else if (a.type() == typeid(bool))
    std::cout << (std::any_cast<bool>(a) ? "true" : "false");
  else if (a.type() == typeid(std::string))
    std::cout << std::any_cast<std::string>(a);
}
inline std::string __any_str(const std::any &a) {
  if (a.type() == typeid(int))
    return std::to_string(std::any_cast<int>(a));
  if (a.type() == typeid(double))
    return std::to_string(std::any_cast<double>(a));
  if (a.type() == typeid(bool))
    return std::any_cast<bool>(a) ? "true" : "false";
  if (a.type() == typeid(std::string))
    return std::any_cast<std::string>(a);
  return "";
}

bool validComb(int a, int b, int c, int d, int e, int f, int g) {
  auto square1 = (a + b);
  auto square2 = ((b + c) + d);
  auto square3 = ((d + e) + f);
  auto square4 = (f + g);
  return (((square1 == square2) && (square2 == square3)) &&
          (square3 == square4));
}

bool isUnique(int a, int b, int c, int d, int e, int f, int g) {
  std::vector<int> nums = {a, b, c, d, e, f, g};
  auto i = 0;
  while ((i < nums.size())) {
    auto j = (i + 1);
    while ((j < nums.size())) {
      if ((nums[i] == nums[j])) {
        return false;
      }
      j = (j + 1);
    }
    i = (i + 1);
  }
  return true;
}

auto getCombs(int low, int high, bool unique) {
  std::vector<std::vector<int>> valid = {};
  auto count = 0;
  for (int b = low; b < ((high + 1)); b++) {
    for (int c = low; c < ((high + 1)); c++) {
      for (int d = low; d < ((high + 1)); d++) {
        auto s = ((b + c) + d);
        for (int e = low; e < ((high + 1)); e++) {
          for (int f = low; f < ((high + 1)); f++) {
            auto a = (s - b);
            auto g = (s - f);
            if (((a < low) || (a > high))) {
              continue;
            }
            if (((g < low) || (g > high))) {
              continue;
            }
            if ((((d + e) + f) != s)) {
              continue;
            }
            if (((f + g) != s)) {
              continue;
            }
            if (((!unique) || isUnique(a, b, c, d, e, f, g))) {
              valid.push_back(std::vector<int>{a, b, c, d, e, f, g});
              count = (count + 1);
            }
          }
        }
      }
    }
  }
  return std::unordered_map<std::string, std::any>{
      {std::string("count"), count}, {std::string("list"), valid}};
}

int main() {
  auto r1 = getCombs(1, 7, true);
  std::cout << (__any_str(r1[std::string("count")]) +
                std::string(" unique solutions in 1 to 7"))
            << std::endl;
  __print_any(r1[std::string("list")]);
  std::cout << std::endl;
  auto r2 = getCombs(3, 9, true);
  std::cout << (__any_str(r2[std::string("count")]) +
                std::string(" unique solutions in 3 to 9"))
            << std::endl;
  __print_any(r2[std::string("list")]);
  std::cout << std::endl;
  auto r3 = getCombs(0, 9, false);
  std::cout << (__any_str(r3[std::string("count")]) +
                std::string(" non-unique solutions in 0 to 9"))
            << std::endl;
  return 0;
}
