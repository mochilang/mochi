// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:12:27Z
// Source: /workspace/mochi/tests/rosetta/x/Mochi/aliquot-sequence-classifications.mochi

function indexOf(xs: number[], value: number): number {
  var i = 0;
  while ((i < xs.length)) {
    if ((xs[i] == value)) {
      return i;
    }
    i = i + 1;
  }
  return (0 - 1);
}

function contains(xs: number[], value: number): boolean {
  return (indexOf(xs, value) != (0 - 1));
}

function maxOf(a: number, b: number): number {
  if ((a > b)) {
    return a;
  } else {
    return b;
  }
}

function intSqrt(n: number): number {
  if ((n == 0)) {
    return 0;
  }
  var x = n;
  var y = Math.trunc((x + 1) / 2);
  while ((y < x)) {
    x = y;
    y = Math.trunc((x + Math.trunc(n / x)) / 2);
  }
  return x;
}

function sumProperDivisors(n: number): number {
  if ((n < 2)) {
    return 0;
  }
  let sqrt = intSqrt(n);
  var sum = 1;
  var i = 2;
  while ((i <= sqrt)) {
    if (((n % i) == 0)) {
      sum = (sum + i) + Math.trunc(n / i);
    }
    i = i + 1;
  }
  if (((sqrt * sqrt) == n)) {
    sum = sum - sqrt;
  }
  return sum;
}

function classifySequence(k: number): Record<string, any> {
  var last = k;
  var seq: number[] = [k];
  while (true) {
    last = sumProperDivisors(last);
    seq = [...seq, last];
    let n = seq.length;
    var aliquot = "";
    if ((last == 0)) {
      aliquot = "Terminating";
    } else if (((n == 2) && (last == k))) {
      aliquot = "Perfect";
    } else if (((n == 3) && (last == k))) {
      aliquot = "Amicable";
    } else if (((n >= 4) && (last == k))) {
      aliquot = `Sociable[${String(n - 1)}]`;
    } else if ((last == seq[n - 2])) {
      aliquot = "Aspiring";
    } else if (_contains(seq.slice(1, maxOf(1, n - 2)), last)) {
      let idx = indexOf(seq, last);
      aliquot = `Cyclic[${String((n - 1) - idx)}]`;
    } else if (((n == 16) || (last > THRESHOLD))) {
      aliquot = "Non-Terminating";
    }
    if ((aliquot != "")) {
      return {
        "seq": seq,
        "aliquot": aliquot,
      };
    }
  }
  return {
    "seq": seq,
    "aliquot": "",
  };
}

function padLeft(n: number, w: number): string {
  var s = String(n);
  while ((s.length < w)) {
    s = ` ${s}`;
  }
  return s;
}

function padRight(s: string, w: number): string {
  var r = s;
  while ((r.length < w)) {
    r = `${r} `;
  }
  return r;
}

function joinWithCommas(seq: number[]): string {
  var s = "[";
  var i = 0;
  while ((i < seq.length)) {
    s = `${s}${String(seq[i])}`;
    if ((i < (seq.length - 1))) {
      s = `${s}, `;
    }
    i = i + 1;
  }
  s = `${s}]`;
  return s;
}

function main(): void {
  console.log(
    "Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n",
  );
  var k = 1;
  while ((k <= 10)) {
    let res = classifySequence(k);
    console.log(
      `${padLeft(k, 2)}: ${padRight(res["aliquot"], 15)} ${
        joinWithCommas(res["seq"])
      }`,
    );
    k = k + 1;
  }
  console.log("");
  let s = [
    11,
    12,
    28,
    496,
    220,
    1184,
    12496,
    1264460,
    790,
    909,
    562,
    1064,
    1488,
  ];
  var i = 0;
  while ((i < s.length)) {
    let val = s[i];
    let res = classifySequence(val);
    console.log(
      `${padLeft(val, 7)}: ${padRight(res["aliquot"], 15)} ${
        joinWithCommas(res["seq"])
      }`,
    );
    i = i + 1;
  }
  console.log("");
  let big = 15355717786080;
  let r = classifySequence(big);
  return console.log(
    `${String(big)}: ${padRight(r["aliquot"], 15)} ${joinWithCommas(r["seq"])}`,
  );
}

let THRESHOLD: number;

function main(): void {
  THRESHOLD = 140737488355328;
  main();
}
function _contains(c: any, v: any): boolean {
  if (Array.isArray(c)) return c.includes(v);
  if (typeof c === "string") return c.includes(String(v));
  if (c && typeof c === "object") {
    return Object.prototype.hasOwnProperty.call(c, String(v));
  }
  return false;
}

main();
