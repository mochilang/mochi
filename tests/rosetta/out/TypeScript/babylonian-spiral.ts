// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:12:37Z
// Source: /workspace/mochi/tests/rosetta/x/Mochi/babylonian-spiral.mochi

function push(
  h: { [key: string]: number }[],
  it: { [key: string]: number },
): { [key: string]: number }[] {
  h = [...h, it];
  var i = h.length - 1;
  while (((i > 0) && (h[i - 1]["s"] > h[i]["s"]))) {
    let tmp = h[i - 1];
    h[i - 1] = h[i];
    h[i] = tmp;
    i = i - 1;
  }
  return h;
}

function step(
  h: { [key: string]: number }[],
  nv: number,
  dir: number[],
): Record<string, any> {
  while (((h.length == 0) || ((nv * nv) <= h[0]["s"]))) {
    h = push(h, {
      "s": (nv * nv),
      "a": nv,
      "b": 0,
    });
    nv = nv + 1;
  }
  let s = h[0]["s"];
  var v: number[][] = [];
  while (((h.length > 0) && (h[0]["s"] == s))) {
    let it = h[0];
    h = h.slice(1, h.length);
    v = [...v, [
      it["a"],
      it["b"],
    ]];
    if ((it["a"] > it["b"])) {
      h = push(h, {
        "s": ((it["a"] * it["a"]) + ((it["b"] + 1) * (it["b"] + 1))),
        "a": it["a"],
        "b": (it["b"] + 1),
      });
    }
  }
  var list: number[][] = [];
  for (const p of v) {
    list = [...list, p];
  }
  var temp: number[][] = list;
  for (const p of temp) {
    if ((p[0] != p[1])) {
      list = [...list, [
        p[1],
        p[0],
      ]];
    }
  }
  temp = list;
  for (const p of temp) {
    if ((p[1] != 0)) {
      list = [...list, [
        p[0],
        -p[1],
      ]];
    }
  }
  temp = list;
  for (const p of temp) {
    if ((p[0] != 0)) {
      list = [...list, [
        -p[0],
        p[1],
      ]];
    }
  }
  var bestDot = -999999999;
  var best = dir;
  for (const p of list) {
    let cross = (p[0] * dir[1]) - (p[1] * dir[0]);
    if ((cross >= 0)) {
      let dot = (p[0] * dir[0]) + (p[1] * dir[1]);
      if ((dot > bestDot)) {
        bestDot = dot;
        best = p;
      }
    }
  }
  return {
    "d": best,
    "heap": h,
    "n": nv,
  };
}

function positions(n: number): number[][] {
  var pos: number[][] = [];
  var x = 0;
  var y = 0;
  var dir: number[] = [
    0,
    1,
  ];
  var heap: { [key: string]: number }[] = [];
  var nv = 1;
  var i = 0;
  while ((i < n)) {
    pos = [...pos, [
      x,
      y,
    ]];
    let st = step(heap, nv, dir);
    dir = st["d"];
    heap = st["heap"];
    nv = st["n"];
    x = x + dir[0];
    y = y + dir[1];
    i = i + 1;
  }
  return pos;
}

function pad(s: string, w: number): string {
  var r = s;
  while ((r.length < w)) {
    r = `${r} `;
  }
  return r;
}

function main(): void {
  let pts = positions(40);
  console.log("The first 40 Babylonian spiral points are:");
  var line = "";
  var i = 0;
  while ((i < pts.length)) {
    let p = pts[i];
    let s = pad(`(${String(p[0])}, ${String(p[1])})`, 10);
    line = `${line}${s}`;
    if ((((i + 1) % 10) == 0)) {
      console.log(line);
      line = "";
    }
    i = i + 1;
  }
}

function main(): void {
  main();
}
main();
