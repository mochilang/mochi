// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:12:38Z
// Source: /workspace/mochi/tests/rosetta/x/Mochi/bifid-cipher.mochi

function square_to_maps(square: string[][]): Record<string, any> {
  var emap: { [key: string]: number[] } = {};
  var dmap: { [key: string]: string } = {};
  var x = 0;
  while ((x < square.length)) {
    let row = square[x];
    var y = 0;
    while ((y < row.length)) {
      let ch = row[y];
      emap[ch] = [
        x,
        y,
      ];
      dmap[`${String(x)},${String(y)}`] = ch;
      y = y + 1;
    }
    x = x + 1;
  }
  return {
    "e": emap,
    "d": dmap,
  };
}

function remove_space(text: string, emap: { [key: string]: number[] }): string {
  let s = String(text).toUpperCase();
  var out = "";
  var i = 0;
  while ((i < s.length)) {
    let ch = _sliceString(s, i, i + 1);
    if (
      ((ch != " ") && Object.prototype.hasOwnProperty.call(emap, String(ch)))
    ) {
      out = `${out}${ch}`;
    }
    i = i + 1;
  }
  return out;
}

function encrypt(
  text: string,
  emap: { [key: string]: number[] },
  dmap: { [key: string]: string },
): string {
  text = remove_space(text, emap);
  var row0: number[] = [];
  var row1: number[] = [];
  var i = 0;
  while ((i < text.length)) {
    let ch = _sliceString(text, i, i + 1);
    let xy = emap[ch];
    row0 = [...row0, xy[0]];
    row1 = [...row1, xy[1]];
    i = i + 1;
  }
  for (const v of row1) {
    row0 = [...row0, v];
  }
  var res = "";
  var j = 0;
  while ((j < row0.length)) {
    let key = `${String(row0[j])},${String(row0[j + 1])}`;
    res = `${res}${dmap[key]}`;
    j = j + 2;
  }
  return res;
}

function decrypt(
  text: string,
  emap: { [key: string]: number[] },
  dmap: { [key: string]: string },
): string {
  text = remove_space(text, emap);
  var coords: number[] = [];
  var i = 0;
  while ((i < text.length)) {
    let ch = _sliceString(text, i, i + 1);
    let xy = emap[ch];
    coords = [...coords, xy[0]];
    coords = [...coords, xy[1]];
    i = i + 1;
  }
  var half = Math.trunc(coords.length / 2);
  var k1: number[] = [];
  var k2: number[] = [];
  var idx = 0;
  while ((idx < half)) {
    k1 = [...k1, coords[idx]];
    idx = idx + 1;
  }
  while ((idx < coords.length)) {
    k2 = [...k2, coords[idx]];
    idx = idx + 1;
  }
  var res = "";
  var j = 0;
  while ((j < half)) {
    let key = `${String(k1[j])},${String(k2[j])}`;
    res = `${res}${dmap[key]}`;
    j = j + 1;
  }
  return res;
}

function main(): void {
  let squareRosetta = [
    [
      "A",
      "B",
      "C",
      "D",
      "E",
    ],
    [
      "F",
      "G",
      "H",
      "I",
      "K",
    ],
    [
      "L",
      "M",
      "N",
      "O",
      "P",
    ],
    [
      "Q",
      "R",
      "S",
      "T",
      "U",
    ],
    [
      "V",
      "W",
      "X",
      "Y",
      "Z",
    ],
    [
      "J",
      "1",
      "2",
      "3",
      "4",
    ],
  ];
  let squareWikipedia = [
    [
      "B",
      "G",
      "W",
      "K",
      "Z",
    ],
    [
      "Q",
      "P",
      "N",
      "D",
      "S",
    ],
    [
      "I",
      "O",
      "A",
      "X",
      "E",
    ],
    [
      "F",
      "C",
      "L",
      "U",
      "M",
    ],
    [
      "T",
      "H",
      "Y",
      "V",
      "R",
    ],
    [
      "J",
      "1",
      "2",
      "3",
      "4",
    ],
  ];
  let textRosetta = "0ATTACKATDAWN";
  let textWikipedia = "FLEEATONCE";
  let textTest = "The invasion will start on the first of January";
  var maps = square_to_maps(squareRosetta);
  var emap = maps["e"];
  var dmap = maps["d"];
  console.log("from Rosettacode");
  console.log(`original:	 ${textRosetta}`);
  var s = encrypt(textRosetta, emap, dmap);
  console.log(`codiert:	 ${s}`);
  s = decrypt(s, emap, dmap);
  console.log(`and back:	 ${s}`);
  maps = square_to_maps(squareWikipedia);
  emap = maps["e"];
  dmap = maps["d"];
  console.log("from Wikipedia");
  console.log(`original:	 ${textWikipedia}`);
  s = encrypt(textWikipedia, emap, dmap);
  console.log(`codiert:	 ${s}`);
  s = decrypt(s, emap, dmap);
  console.log(`and back:	 ${s}`);
  maps = square_to_maps(squareWikipedia);
  emap = maps["e"];
  dmap = maps["d"];
  console.log("from Rosettacode long part");
  console.log(`original:	 ${textTest}`);
  s = encrypt(textTest, emap, dmap);
  console.log(`codiert:	 ${s}`);
  s = decrypt(s, emap, dmap);
  return console.log(`and back:	 ${s}`);
}

function main(): void {
  main();
}
function _sliceString(s: string, i: number, j: number): string {
  let start = i;
  let end = j;
  const runes = Array.from(s);
  const n = runes.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (end > n) end = n;
  if (end < start) end = start;
  return runes.slice(start, end).join("");
}

main();
