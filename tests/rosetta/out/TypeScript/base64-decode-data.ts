// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:12:37Z
// Source: /workspace/mochi/tests/rosetta/x/Mochi/base64-decode-data.mochi

function indexOf(s: string, ch: string): number {
  var i = 0;
  while ((i < s.length)) {
    if ((_indexString(s, i) == ch)) {
      return i;
    }
    i = i + 1;
  }
  return (-1);
}

function parseIntStr(str: string): number {
  var i = 0;
  var neg = false;
  if (((str.length > 0) && (_indexString(str, 0) == "-"))) {
    neg = true;
    i = 1;
  }
  var n = 0;
  let digits = {
    "_": 0,
    "_": 1,
    "_": 2,
    "_": 3,
    "_": 4,
    "_": 5,
    "_": 6,
    "_": 7,
    "_": 8,
    "_": 9,
  };
  while ((i < str.length)) {
    n = (n * 10) + digits[_indexString(str, i)];
    i = i + 1;
  }
  if (neg) {
    n = -n;
  }
  return n;
}

function ord(ch: string): number {
  let upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let lower = "abcdefghijklmnopqrstuvwxyz";
  var idx = indexOf(upper, ch);
  if ((idx >= 0)) {
    return (65 + idx);
  }
  idx = indexOf(lower, ch);
  if ((idx >= 0)) {
    return (97 + idx);
  }
  if (((ch >= "0") && (ch <= "9"))) {
    return (48 + parseIntStr(ch));
  }
  if ((ch == "+")) {
    return 43;
  }
  if ((ch == "/")) {
    return 47;
  }
  if ((ch == " ")) {
    return 32;
  }
  if ((ch == "=")) {
    return 61;
  }
  return 0;
}

function chr(n: number): string {
  let upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let lower = "abcdefghijklmnopqrstuvwxyz";
  if (((n >= 65) && (n < 91))) {
    return _slice(upper, n - 65, n - 64);
  }
  if (((n >= 97) && (n < 123))) {
    return _slice(lower, n - 97, n - 96);
  }
  if (((n >= 48) && (n < 58))) {
    let digits = "0123456789";
    return _sliceString(digits, n - 48, n - 47);
  }
  if ((n == 43)) {
    return "+";
  }
  if ((n == 47)) {
    return "/";
  }
  if ((n == 32)) {
    return " ";
  }
  if ((n == 61)) {
    return "=";
  }
  return "?";
}

function toBinary(n: number, bits: number): string {
  var b = "";
  var val = n;
  var i = 0;
  while ((i < bits)) {
    b = `${String(val % 2)}${b}`;
    val = Math.trunc(val / 2);
    i = i + 1;
  }
  return b;
}

function binToInt(bits: string): number {
  var n = 0;
  var i = 0;
  while ((i < bits.length)) {
    n = (n * 2) + parseIntStr(_sliceString(bits, i, i + 1));
    i = i + 1;
  }
  return n;
}

function base64Encode(text: string): string {
  let alphabet =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var bin = "";
  for (const ch of text) {
    bin = `${bin}${toBinary(ord(ch), 8)}`;
  }
  while (((bin.length % 6) != 0)) {
    bin = `${bin}0`;
  }
  var out = "";
  var i = 0;
  while ((i < bin.length)) {
    let chunk = _sliceString(bin, i, i + 6);
    let val = binToInt(chunk);
    out = `${out}${_sliceString(alphabet, val, val + 1)}`;
    i = i + 6;
  }
  let pad = (3 - (text.length % 3)) % 3;
  if ((pad == 1)) {
    out = `${_sliceString(out, 0, out.length - 1)}=`;
  }
  if ((pad == 2)) {
    out = `${_sliceString(out, 0, out.length - 2)}==`;
  }
  return out;
}

function base64Decode(enc: string): string {
  let alphabet =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var bin = "";
  var i = 0;
  while ((i < enc.length)) {
    let ch = _indexString(enc, i);
    if ((ch == "=")) {
      break;
    }
    let idx = indexOf(alphabet, ch);
    bin = `${bin}${toBinary(idx, 6)}`;
    i = i + 1;
  }
  var out = "";
  i = 0;
  while (((i + 8) <= bin.length)) {
    let chunk = _sliceString(bin, i, i + 8);
    let val = binToInt(chunk);
    out = `${out}${chr(val)}`;
    i = i + 8;
  }
  return out;
}

let dec: string;
let enc: string;
let msg: string;

function main(): void {
  msg = "Rosetta Code Base64 decode data task";
  console.log(`Original : ${msg}`);
  enc = base64Encode(msg);
  console.log(`
Encoded  : ${enc}`);
  dec = base64Decode(enc);
  console.log(`
Decoded  : ${dec}`);
}
function _indexString(s: string, i: number): string {
  const runes = Array.from(s);
  if (i < 0) i += runes.length;
  if (i < 0 || i >= runes.length) throw new Error("index out of range");
  return runes[i];
}

function _slice<T>(v: T[] | string, i: number, j: number): T[] | string {
  if (typeof v === "string") return _sliceString(v, i, j);
  if (!Array.isArray(v)) return [];
  let start = i;
  let end = j;
  const n = v.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (end > n) end = n;
  if (end < start) end = start;
  return v.slice(start, end);
}

function _sliceString(s: string, i: number, j: number): string {
  let start = i;
  let end = j;
  const runes = Array.from(s);
  const n = runes.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (end > n) end = n;
  if (end < start) end = start;
  return runes.slice(start, end).join("");
}

main();
