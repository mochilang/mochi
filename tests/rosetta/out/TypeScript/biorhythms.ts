// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:12:39Z
// Source: /workspace/mochi/tests/rosetta/x/Mochi/biorhythms.mochi

function sinApprox(x: number): number {
  var term = x;
  var sum = x;
  var n = 1;
  while ((n <= 8)) {
    let denom = (2 * n) * ((2 * n) + 1);
    term = (((-term) * x) * x) / denom;
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

function floor(x: number): number {
  var i = x;
  if ((i > x)) {
    i = i - 1;
  }
  return i;
}

function absFloat(x: number): number {
  if ((x < 0)) {
    return (-x);
  }
  return x;
}

function absInt(n: number): number {
  if ((n < 0)) {
    return (-n);
  }
  return n;
}

function parseIntStr(str: string): number {
  var i = 0;
  var neg = false;
  if (((str.length > 0) && (_sliceString(str, 0, 1) == "-"))) {
    neg = true;
    i = 1;
  }
  var n = 0;
  let digits = {
    "_": 0,
    "_": 1,
    "_": 2,
    "_": 3,
    "_": 4,
    "_": 5,
    "_": 6,
    "_": 7,
    "_": 8,
    "_": 9,
  };
  while ((i < str.length)) {
    n = (n * 10) + digits[_sliceString(str, i, i + 1)];
    i = i + 1;
  }
  if (neg) {
    n = -n;
  }
  return n;
}

function parseDate(s: string): number[] {
  let y = parseIntStr(_sliceString(s, 0, 4));
  let m = parseIntStr(_sliceString(s, 5, 7));
  let d = parseIntStr(_sliceString(s, 8, 10));
  return [
    y,
    m,
    d,
  ];
}

function leap(y: number): boolean {
  if (((y % 400) == 0)) {
    return true;
  }
  if (((y % 100) == 0)) {
    return false;
  }
  return ((y % 4) == 0);
}

function daysInMonth(y: number, m: number): number {
  let feb = leap(y) ? 29 : 28;
  let lengths = [
    31,
    feb,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31,
  ];
  return lengths[m - 1];
}

function addDays(y: number, m: number, d: number, n: number): number[] {
  var yy = y;
  var mm = m;
  var dd = d;
  if ((n >= 0)) {
    var i = 0;
    while ((i < n)) {
      dd = dd + 1;
      if ((dd > daysInMonth(yy, mm))) {
        dd = 1;
        mm = mm + 1;
        if ((mm > 12)) {
          mm = 1;
          yy = yy + 1;
        }
      }
      i = i + 1;
    }
  } else {
    var i = 0;
    while ((i > n)) {
      dd = dd - 1;
      if ((dd < 1)) {
        mm = mm - 1;
        if ((mm < 1)) {
          mm = 12;
          yy = yy - 1;
        }
        dd = daysInMonth(yy, mm);
      }
      i = i - 1;
    }
  }
  return [
    yy,
    mm,
    dd,
  ];
}

function pad2(n: number): string {
  if ((n < 10)) {
    return `0${String(n)}`;
  }
  return String(n);
}

function dateString(y: number, m: number, d: number): string {
  return `${String(y)}-${pad2(m)}-${pad2(d)}`;
}

function day(y: number, m: number, d: number): number {
  let part1 = 367 * y;
  let part2 = Math.trunc((7 * (y + (Math.trunc((m + 9) / 12)))) / 4);
  let part3 = Math.trunc((275 * m) / 9);
  return ((((part1 - part2) + part3) + d) - 730530);
}

function biorhythms(birth: string, target: string): void {
  let bparts = parseDate(birth);
  let by = bparts[0];
  let bm = bparts[1];
  let bd = bparts[2];
  let tparts = parseDate(target);
  let ty = tparts[0];
  let tm = tparts[1];
  let td = tparts[2];
  let diff = absInt(day(ty, tm, td) - day(by, bm, bd));
  console.log(`Born ${birth}, Target ${target}`);
  console.log(`Day ${String(diff)}`);
  let cycles = [
    "Physical day ",
    "Emotional day",
    "Mental day   ",
  ];
  let lengths = [
    23,
    28,
    33,
  ];
  let quadrants = [
    [
      "up and rising",
      "peak",
    ],
    [
      "up but falling",
      "transition",
    ],
    [
      "down and falling",
      "valley",
    ],
    [
      "down but rising",
      "transition",
    ],
  ];
  var i = 0;
  while ((i < 3)) {
    let length = lengths[i];
    let cycle = cycles[i];
    let position = diff % length;
    let quadrant = Math.trunc((position * 4) / length);
    var percent = sinApprox(((2 * PI) * position) / length);
    percent = Math.floor(percent * 1000) / 10;
    var description = "";
    if ((percent > 95)) {
      description = " peak";
    } else if ((percent < (-95))) {
      description = " valley";
    } else if ((absFloat(percent) < 5)) {
      description = " critical transition";
    } else {
      let daysToAdd = Math.trunc(((quadrant + 1) * length) / 4) - position;
      let res = addDays(ty, tm, td, daysToAdd);
      let ny = res[0];
      let nm = res[1];
      let nd = res[2];
      let transition = dateString(ny, nm, nd);
      let trend = quadrants[quadrant][0];
      let next = quadrants[quadrant][1];
      var pct = String(percent);
      if ((!_contains(pct, "."))) {
        pct = `${pct}.0`;
      }
      description = ` ${pct}% (${trend}, next ${next} ${transition})`;
    }
    var posStr = String(position);
    if ((position < 10)) {
      posStr = ` ${posStr}`;
    }
    console.log(`${cycle}${posStr} : ${description}`);
    i = i + 1;
  }
  return console.log("");
}

function main(): void {
  let pairs = [
    [
      "1943-03-09",
      "1972-07-11",
    ],
    [
      "1809-01-12",
      "1863-11-19",
    ],
    [
      "1809-02-12",
      "1863-11-19",
    ],
  ];
  var idx = 0;
  while ((idx < pairs.length)) {
    let p = pairs[idx];
    biorhythms(p[0], p[1]);
    idx = idx + 1;
  }
}

let PI: number;
let TWO_PI: number;

function main(): void {
  PI = 3.141592653589793;
  TWO_PI = 6.283185307179586;
  main();
}
function _contains(c: any, v: any): boolean {
  if (Array.isArray(c)) return c.includes(v);
  if (typeof c === "string") return c.includes(String(v));
  if (c && typeof c === "object") {
    return Object.prototype.hasOwnProperty.call(c, String(v));
  }
  return false;
}

function _sliceString(s: string, i: number, j: number): string {
  let start = i;
  let end = j;
  const runes = Array.from(s);
  const n = runes.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (end > n) end = n;
  if (end < start) end = start;
  return runes.slice(start, end).join("");
}

main();
