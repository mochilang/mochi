// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:12:34Z
// Source: /workspace/mochi/tests/rosetta/x/Mochi/arithmetic-numbers.mochi

function sieve(limit: number): number[] {
  var spf: number[] = [];
  var i = 0;
  while ((i <= limit)) {
    spf = [...spf, 0];
    i = i + 1;
  }
  i = 2;
  while ((i <= limit)) {
    if ((spf[i] == 0)) {
      spf[i] = i;
      if (((i * i) <= limit)) {
        var j = i * i;
        while ((j <= limit)) {
          if ((spf[j] == 0)) {
            spf[j] = i;
          }
          j = j + i;
        }
      }
    }
    i = i + 1;
  }
  return spf;
}

function primesFrom(spf: number[], limit: number): number[] {
  var primes: number[] = [];
  var i = 3;
  while ((i <= limit)) {
    if ((spf[i] == i)) {
      primes = [...primes, i];
    }
    i = i + 1;
  }
  return primes;
}

function pad3(n: number): string {
  var s = String(n);
  while ((s.length < 3)) {
    s = ` ${s}`;
  }
  return s;
}

function commatize(n: number): string {
  var s = String(n);
  var out = "";
  var i = s.length - 1;
  var c = 0;
  while ((i >= 0)) {
    out = `${s.substring(i, i + (i + 1))}${out}`;
    c = c + 1;
    if ((((c % 3) == 0) && (i > 0))) {
      out = `,${out}`;
    }
    i = i - 1;
  }
  return out;
}

function primeCount(primes: number[], last: number, spf: number[]): number {
  var lo = 0;
  var hi = primes.length;
  while ((lo < hi)) {
    var mid = Math.trunc((lo + hi) / 2);
    if ((primes[mid] < last)) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  var count = lo + 1;
  if ((spf[last] != last)) {
    count = count - 1;
  }
  return count;
}

function arithmeticNumbers(limit: number, spf: number[]): number[] {
  var arr: number[] = [1];
  var n = 3;
  while ((arr.length < limit)) {
    if ((spf[n] == n)) {
      arr = [...arr, n];
    } else {
      var x = n;
      var sigma = 1;
      var tau = 1;
      while ((x > 1)) {
        var p = spf[x];
        if ((p == 0)) {
          p = x;
        }
        var cnt = 0;
        var power = p;
        var sum = 1;
        while (((x % p) == 0)) {
          x = Math.trunc(x / p);
          cnt = cnt + 1;
          sum = sum + power;
          power = power * p;
        }
        sigma = sigma * sum;
        tau = tau * (cnt + 1);
      }
      if (((sigma % tau) == 0)) {
        arr = [...arr, n];
      }
    }
    n = n + 1;
  }
  return arr;
}

function main(): void {
  let limit = 1228663;
  let spf = sieve(limit);
  let primes = primesFrom(spf, limit);
  let arr = arithmeticNumbers(1000000, spf);
  console.log("The first 100 arithmetic numbers are:");
  var i = 0;
  while ((i < 100)) {
    var line = "";
    var j = 0;
    while ((j < 10)) {
      line = `${line}${pad3(arr[i + j])}`;
      if ((j < 9)) {
        line = `${line} `;
      }
      j = j + 1;
    }
    console.log(line);
    i = i + 10;
  }
  for (
    const x of [
      1000,
      10000,
      100000,
      1000000,
    ]
  ) {
    let last = arr[x - 1];
    let lastc = commatize(last);
    console.log(`
The ${commatize(x)}th arithmetic number is: ${lastc}`);
    let pc = primeCount(primes, last, spf);
    let comp = (x - pc) - 1;
    console.log(
      `The count of such numbers <= ${lastc} which are composite is ${
        commatize(comp)
      }.`,
    );
  }
}

function main(): void {
  main();
}
main();
