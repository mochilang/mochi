// Generated by Mochi compiler v0.10.30 on 2025-07-19T01:03:08Z
// Source: /workspace/mochi/tests/rosetta/x/Mochi/abbreviations-simple.mochi

function fields(s: string): string[] {
  var words: string[] = [];
  var cur = "";
  var i = 0;
  while ((i < s.length)) {
    let ch = s.substring(i, i + (i + 1));
    if ((((ch == " ") || (ch == "\n")) || (ch == "\t"))) {
      if ((cur.length > 0)) {
        words = [...words, cur];
        cur = "";
      }
    } else {
      cur = `${cur}${ch}`;
    }
    i = i + 1;
  }
  if ((cur.length > 0)) {
    words = [...words, cur];
  }
  return words;
}

function padRight(s: string, width: number): string {
  var out = s;
  var i = s.length;
  while ((i < width)) {
    out = `${out} `;
    i = i + 1;
  }
  return out;
}

function join(xs: string[], sep: string): string {
  var res = "";
  var i = 0;
  while ((i < xs.length)) {
    if ((i > 0)) {
      res = `${res}${sep}`;
    }
    res = `${res}${xs[i]}`;
    i = i + 1;
  }
  return res;
}

function parseIntStr(str: string): number {
  var i = 0;
  var neg = false;
  if (((str.length > 0) && (str.slice(0, 1) == "-"))) {
    neg = true;
    i = 1;
  }
  var n = 0;
  let digits = {
    "_": 0,
    "_": 1,
    "_": 2,
    "_": 3,
    "_": 4,
    "_": 5,
    "_": 6,
    "_": 7,
    "_": 8,
    "_": 9,
  };
  while ((i < str.length)) {
    n = (n * 10) + digits[str.slice(i, i + 1)];
    i = i + 1;
  }
  if (neg) {
    n = -n;
  }
  return n;
}

function isDigits(s: string): boolean {
  if ((s.length == 0)) {
    return false;
  }
  var i = 0;
  while ((i < s.length)) {
    let ch = s.substring(i, i + (i + 1));
    if (((ch < "0") || (ch > "9"))) {
      return false;
    }
    i = i + 1;
  }
  return true;
}

function readTable(table: string): Record<string, any> {
  let toks = fields(table);
  var cmds: string[] = [];
  var mins: number[] = [];
  var i = 0;
  while ((i < toks.length)) {
    let cmd = toks[i];
    var minlen = cmd.length;
    i = i + 1;
    if (((i < toks.length) && isDigits(toks[i]))) {
      let num = parseIntStr(toks[i]);
      if (((num >= 1) && (num < cmd.length))) {
        minlen = num;
        i = i + 1;
      }
    }
    cmds = [...cmds, cmd];
    mins = [...mins, minlen];
  }
  return {
    "commands": cmds,
    "mins": mins,
  };
}

function validate(
  commands: string[],
  mins: number[],
  words: string[],
): string[] {
  var results: string[] = [];
  var wi = 0;
  while ((wi < words.length)) {
    let w = words[wi];
    var found = false;
    let wlen = w.length;
    var ci = 0;
    while ((ci < commands.length)) {
      let cmd = commands[ci];
      if ((((mins[ci] != 0) && (wlen >= mins[ci])) && (wlen <= cmd.length))) {
        let c = String(cmd).toUpperCase();
        let ww = String(w).toUpperCase();
        if ((c.substring(0, (0) + wlen) == ww)) {
          results = [...results, c];
          found = true;
          break;
        }
      }
      ci = ci + 1;
    }
    if ((!found)) {
      results = [...results, "*error*"];
    }
    wi = wi + 1;
  }
  return results;
}

function main(): void {
  let table =
    `add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate 3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left 2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 `;
  let sentence =
    "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin";
  let tbl = readTable(table);
  let commands = tbl["commands"] as string[];
  let mins = tbl["mins"] as number[];
  let words = fields(sentence);
  let results = validate(commands, mins, words);
  var out1 = "user words:";
  var k = 0;
  while ((k < words.length)) {
    out1 = `${out1} `;
    if ((k < (words.length - 1))) {
      out1 = `${out1}${padRight(words[k], results[k].length)}`;
    } else {
      out1 = `${out1}${words[k]}`;
    }
    k = k + 1;
  }
  console.log(out1);
  return console.log(`full words: ${join(results, " ")}`);
}

main();
