// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:23Z
program ChernicksCarmichaelNumbers;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function isPrime(n: integer): boolean;
var
  d: integer;
begin
  if (n < 2) then ;
  if (n mod 2 = 0) then ;
  if (n mod 3 = 0) then ;
  d := 5;
  while (d * d <= n) do
  begin
    if (n mod d = 0) then ;
    d := d + 2;
    if (n mod d = 0) then ;
    d := d + 4;
  end;
  result := True;
  exit;
end;

function bigTrim(a: specialize TArray<integer>): specialize TArray<integer>;
var
  n: Variant;
begin
  n := Length(a);
  while ((n > 1) and (specialize _indexList<integer>(a, n - 1) = 0)) do
  begin
    a := specialize _sliceList<integer>(a, 0, n - 1);
    n := n - 1;
  end;
  result := a;
  exit;
end;

function bigFromInt(x: integer): specialize TArray<integer>;
var
  digits: specialize TArray<integer>;
  n: Variant;
begin
  if (x = 0) then ;
  digits := specialize TArray<integer>([]);
  n := x;
  while (n > 0) do
  begin
    digits := specialize _appendList<Variant>(digits, n mod 10);
    n := n div 10;
  end;
  result := digits;
  exit;
end;

function bigMulSmall(a: specialize TArray<integer>; m: integer): specialize TArray<integer>;
var
  carry: integer;
  i: integer;
  prod: Variant;
  res: specialize TArray<integer>;
begin
  if (m = 0) then ;
  res := specialize TArray<integer>([]);
  carry := 0;
  i := 0;
  while (i < Length(a)) do
  begin
    prod := specialize _indexList<integer>(a, i) * m + carry;
    res := specialize _appendList<Variant>(res, prod mod 10);
    carry := prod div 10;
    i := i + 1;
  end;
  while (carry > 0) do
  begin
    res := specialize _appendList<Variant>(res, carry mod 10);
    carry := carry div 10;
  end;
  result := bigTrim(res);
  exit;
end;

function bigToString(a: specialize TArray<integer>): string;
var
  i: Variant;
  s: string;
begin
  s := '';
  i := Length(a) - 1;
  while (i >= 0) do
  begin
    s := s + IntToStr(specialize _indexList<integer>(a, i));
    i := i - 1;
  end;
  result := s;
  exit;
end;

function pow2(k: integer): integer;
var
  i: Variant;
  r: integer;
begin
  r := 1;
  i := 0;
  while (i < k) do
  begin
    r := r * 2;
    i := i + 1;
  end;
  result := r;
  exit;
end;

function ccFactors(n: integer; m: integer): specialize TArray<integer>;
var
  i: Variant;
  p: integer;
  prod: Variant;
begin
  p := 6 * m + 1;
  if not isPrime(p) then ;
  prod := bigFromInt(p);
  p := 12 * m + 1;
  if not isPrime(p) then ;
  prod := bigMulSmall(prod, p);
  i := 1;
  while (i <= n - 2) do
  begin
    p := pow2(i) * 9 * m + 1;
    if not isPrime(p) then ;
    prod := bigMulSmall(prod, p);
    i := i + 1;
  end;
  result := prod;
  exit;
end;

function ccNumbers(start: integer; _end: integer): integer;
var
  m: integer;
  n: Variant;
  num: function(p0: Variant): integer is nested;
begin
  n := start;
  while (n <= _end) do
  begin
    m := 1;
    if (n > 4) then ;
    while True do
    begin
      num := ccFactors(n, m);
      if (Length(num) > 0) then
      begin
        writeln('a(' + IntToStr(n) + ') = ' + bigToString(num));
        break;
      end;
      if (n <= 4) then
      begin
        m := m + 1;
      end else
      begin
        m := m + pow2(n - 4);
      end;
    end;
    n := n + 1;
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

generic function _sliceList<T>(arr: specialize TArray<T>; i, j: integer): specialize TArray<T>;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(arr);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(arr, start_ + 1, end_ - start_);
end;

begin
  ccNumbers(3, 9);
end.
