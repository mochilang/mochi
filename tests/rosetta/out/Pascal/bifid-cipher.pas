// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:13Z
program BifidCipher;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function square_to_maps(square: specialize TArray<specialize TArray<string>>): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, integer>;
  _tmp1: specialize TFPGMap<string, integer>;
  _tmp2: specialize TFPGMap<string, Variant>;
  ch: Variant;
  dmap: specialize TFPGMap<string, string>;
  emap: specialize TFPGMap<string, specialize TArray<integer>>;
  row: Variant;
  x: integer;
  y: integer;
begin
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  emap := _tmp0;
  _tmp1 := specialize TFPGMap<string, integer>.Create;
  dmap := _tmp1;
  x := 0;
  while (x < Length(square)) do
  begin
    row := specialize _indexList<integer>(square, x);
    y := 0;
    while (y < Length(row)) do
    begin
      ch := row[y];
      emap[ch] := specialize TArray<Variant>([x, y]);
      dmap[IntToStr(x) + ',' + IntToStr(y)] := ch;
      y := y + 1;
    end;
    x := x + 1;
  end;
  _tmp2 := specialize TFPGMap<string, Variant>.Create;
  _tmp2.AddOrSetData('e', emap);
  _tmp2.AddOrSetData('d', dmap);
  result := _tmp2;
  exit;
end;

function remove_space(text: string; emap: specialize TFPGMap<string, specialize TArray<integer>>): string;
var
  ch: Variant;
  i: integer;
  out: string;
  s: Variant;
begin
  s := UpperCase(text);
  out := '';
  i := 0;
  while (i < Length(s)) do
  begin
    ch := Copy(s, i + 1, i + 1 - i);
    if ((ch <> ' ') and (ch in emap)) then ;
    i := i + 1;
  end;
  result := out;
  exit;
end;

function encrypt(text: string; emap: specialize TFPGMap<string, specialize TArray<integer>>; dmap: specialize TFPGMap<string, string>): string;
var
  ch: Variant;
  i: integer;
  j: integer;
  key: Variant;
  res: string;
  row0: specialize TArray<integer>;
  row1: specialize TArray<integer>;
  xy: specialize TFPGMap<string, specialize TArray<integer>>;
begin
  text := remove_space(text, emap);
  row0 := specialize TArray<integer>([]);
  row1 := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(text)) do
  begin
    ch := _sliceString(text, i, i + 1);
    xy := emap.KeyData[ch];
    row0 := specialize _appendList<Variant>(row0, xy[0]);
    row1 := specialize _appendList<Variant>(row1, xy[1]);
    i := i + 1;
  end;
  for v in row1 do
  begin
    row0 := specialize _appendList<Variant>(row0, v);
  end;
  res := '';
  j := 0;
  while (j < Length(row0)) do
  begin
    key := IntToStr(row0[j]) + ',' + IntToStr(row0[j + 1]);
    res := res + dmap.KeyData[key];
    j := j + 2;
  end;
  result := res;
  exit;
end;

function decrypt(text: string; emap: specialize TFPGMap<string, specialize TArray<integer>>; dmap: specialize TFPGMap<string, string>): string;
var
  ch: Variant;
  coords: specialize TArray<integer>;
  half: Variant;
  i: integer;
  idx: integer;
  j: integer;
  k1: specialize TArray<integer>;
  k2: specialize TArray<integer>;
  key: Variant;
  res: string;
  xy: specialize TFPGMap<string, specialize TArray<integer>>;
begin
  text := remove_space(text, emap);
  coords := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(text)) do
  begin
    ch := _sliceString(text, i, i + 1);
    xy := emap.KeyData[ch];
    coords := specialize _appendList<Variant>(coords, xy.KeyData[0]);
    coords := specialize _appendList<Variant>(coords, xy.KeyData[1]);
    i := i + 1;
  end;
  half := Length(coords) div 2;
  k1 := specialize TArray<integer>([]);
  k2 := specialize TArray<integer>([]);
  idx := 0;
  while (idx < half) do
  begin
    k1 := specialize _appendList<Variant>(k1, coords[idx]);
    idx := idx + 1;
  end;
  while (idx < Length(coords)) do
  begin
    k2 := specialize _appendList<Variant>(k2, coords[idx]);
    idx := idx + 1;
  end;
  res := '';
  j := 0;
  while (j < half) do
  begin
    key := IntToStr(k1[j]) + ',' + IntToStr(k2[j]);
    res := res + dmap.KeyData[key];
    j := j + 1;
  end;
  result := res;
  exit;
end;

function main(): integer;
var
  dmap: specialize TFPGMap<string, string>;
  emap: specialize TFPGMap<string, specialize TArray<integer>>;
  maps: Variant;
  s: Variant;
  squareRosetta: specialize TArray<Variant>;
  squareWikipedia: specialize TArray<Variant>;
  textRosetta: string;
  textTest: string;
  textWikipedia: string;
begin
  squareRosetta := specialize TArray<specialize TArray<string>>([specialize TArray<string>(['A', 'B', 'C', 'D', 'E']), specialize TArray<string>(['F', 'G', 'H', 'I', 'K']), specialize TArray<string>(['L', 'M', 'N', 'O', 'P']), specialize TArray<string>(['Q', 'R', 'S', 'T', 'U']), specialize TArray<string>(['V', 'W', 'X', 'Y', 'Z']), specialize TArray<string>(['J', '1', '2', '3', '4'])]);
  squareWikipedia := specialize TArray<specialize TArray<string>>([specialize TArray<string>(['B', 'G', 'W', 'K', 'Z']), specialize TArray<string>(['Q', 'P', 'N', 'D', 'S']), specialize TArray<string>(['I', 'O', 'A', 'X', 'E']), specialize TArray<string>(['F', 'C', 'L', 'U', 'M']), specialize TArray<string>(['T', 'H', 'Y', 'V', 'R']), specialize TArray<string>(['J', '1', '2', '3', '4'])]);
  textRosetta := '0ATTACKATDAWN';
  textWikipedia := 'FLEEATONCE';
  textTest := 'The invasion will start on the first of January';
  maps := square_to_maps(squareRosetta);
  emap := maps['e'];
  dmap := maps['d'];
  writeln('from Rosettacode');
  writeln('original:   ' + textRosetta);
  s := encrypt(textRosetta, emap, dmap);
  writeln('codiert:   ' + s);
  s := decrypt(s, emap, dmap);
  writeln('and back:   ' + s);
  maps := square_to_maps(squareWikipedia);
  emap := maps['e'];
  dmap := maps['d'];
  writeln('from Wikipedia');
  writeln('original:   ' + textWikipedia);
  s := encrypt(textWikipedia, emap, dmap);
  writeln('codiert:   ' + s);
  s := decrypt(s, emap, dmap);
  writeln('and back:   ' + s);
  maps := square_to_maps(squareWikipedia);
  emap := maps['e'];
  dmap := maps['d'];
  writeln('from Rosettacode long part');
  writeln('original:   ' + textTest);
  s := encrypt(textTest, emap, dmap);
  writeln('codiert:   ' + s);
  s := decrypt(s, emap, dmap);
  writeln('and back:   ' + s);
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
