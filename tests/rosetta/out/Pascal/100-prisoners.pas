// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program _00Prisoners;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _now(): int64;
begin
  Result := Trunc(Now * 86400000000000.0);
end;


function shuffle(xs: specialize TArray<integer>): specialize TArray<integer>;
var
  arr: Variant;
  i: integer;
  j: Variant;
  tmp: Variant;
begin
  arr := xs;
  i := 99;
  while (i > 0) do
  begin
    j := _now() mod i + 1;
    tmp := arr[i];
    arr[i] := arr[j];
    arr[j] := tmp;
    i := i - 1;
  end;
  result := arr;
  exit;
end;

procedure doTrials(trials: integer; np: integer; strategy: string);
var
  d: integer;
  drawers: specialize TArray<integer>;
  found: boolean;
  i: integer;
  k: integer;
  n: Variant;
  opened: specialize TArray<boolean>;
  p: integer;
  pardoned: integer;
  prev: integer;
  rf: Variant;
  success: boolean;
  t: integer;
  this: specialize TArray<integer>;
begin
  pardoned := 0;
  t := 0;
  while (t < trials) do
  begin
    drawers := specialize TArray<integer>([]);
    i := 0;
    while (i < 100) do
    begin
      drawers := specialize _appendList<integer>(drawers, i);
      i := i + 1;
    end;
    drawers := shuffle(drawers);
    p := 0;
    success := True;
    while (p < np) do
    begin
      found := False;
      if (strategy = 'optimal') then
      begin
        prev := p;
        d := 0;
        while (d < 50) do
        begin
          this := specialize _indexList<integer>(drawers, prev);
          if (this = p) then
          begin
            found := True;
            break;
          end;
          prev := this;
          d := d + 1;
        end;
      end else
      begin
        opened := specialize TArray<boolean>([]);
        k := 0;
        while (k < 100) do
        begin
          opened := specialize _appendList<boolean>(opened, False);
          k := k + 1;
        end;
        d := 0;
        while (d < 50) do
        begin
          n := _now() mod 100;
          while specialize _indexList<boolean>(opened, n) do
          begin
            n := _now() mod 100;
          end;
          opened[n] := True;
          if (specialize _indexList<integer>(drawers, n) = p) then
          begin
            found := True;
            break;
          end;
          d := d + 1;
        end;
      end;
      if not found then
      begin
        success := False;
        break;
      end;
      p := p + 1;
    end;
    if success then ;
    t := t + 1;
  end;
  rf := Double(pardoned) / Double(trials) * 100;
  writeln('  strategy = ' + strategy + '  pardoned = ' + IntToStr(pardoned) + ' relative frequency = ' + IntToStr(rf) + '%');
end;

procedure main();
var
  np: Variant;
  strat: Variant;
  trials: integer;
begin
  trials := 1000;
  for np in specialize TArray<integer>([10, 100]) do
  begin
    writeln('Results from ' + IntToStr(trials) + ' trials with ' + IntToStr(np) + ' prisoners:
');
    for strat in specialize TArray<string>(['random', 'optimal']) do
    begin
      doTrials(trials, np, strat);
    end;
  end;
end;

begin
  main();
end.
