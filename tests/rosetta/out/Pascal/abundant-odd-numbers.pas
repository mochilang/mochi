// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program AbundantOddNumbers;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

generic function _sumList<T>(arr: specialize TArray<T>): double;
var i: integer; s: double;
begin
  s := 0;
  for i := 0 to High(arr) do
    s := s + arr[i];
  Result := s;
end;


function divisors(n: integer): specialize TArray<integer>;
var
  divs: specialize TArray<Variant>;
  divs2: specialize TArray<Variant>;
  i: integer;
  j: Variant;
begin
  divs := specialize TArray<Variant>([1]);
  divs2 := specialize TArray<Variant>([]);
  i := 2;
  while (i * i <= n) do
  begin
    if (n mod i = 0) then
    begin
      j := Trunc(n div i);
      divs := specialize _appendList<Variant>(divs, i);
      if (i <> j) then ;
    end;
    i := i + 1;
  end;
  j := Length(divs2) - 1;
  while (j >= 0) do
  begin
    divs := specialize _appendList<Variant>(divs, specialize _indexList<Variant>(divs2, j));
    j := j - 1;
  end;
  result := divs;
  exit;
end;

function sum(xs: specialize TArray<integer>): integer;
var
  tot: integer;
  v: Variant;
begin
  tot := 0;
  for v in xs do
  begin
    tot := tot + v;
  end;
  result := tot;
  exit;
end;

function sumStr(xs: specialize TArray<integer>): string;
var
  i: integer;
  s: string;
begin
  s := '';
  i := 0;
  while (i < Length(xs)) do
  begin
    s := s + IntToStr(specialize _indexList<integer>(xs, i)) + ' + ';
    i := i + 1;
  end;
  result := _sliceString(s, 0, 0 + Length(s) - 3);
  exit;
end;

function pad2(n: integer): string;
var
  s: string;
begin
  s := IntToStr(n);
  if (Length(s) < 2) then ;
  result := s;
  exit;
end;

function pad5(n: integer): string;
var
  s: string;
begin
  s := IntToStr(n);
  while (Length(s) < 5) do
  begin
    s := ' ' + s;
  end;
  result := s;
  exit;
end;

function abundantOdd(searchFrom: integer; countFrom: integer; countTo: integer; printOne: boolean): integer;
var
  count: function(p0: Variant): integer is nested;
  divs: specialize TArray<Variant>;
  n: Variant;
  s: string;
  tot: Variant;
begin
  count := countFrom;
  n := searchFrom;
  while (count < countTo) do
  begin
    divs := divisors(n);
    tot := specialize _sumList<Variant>(divs);
    if (tot > n) then
    begin
      count := count + 1;
      if (printOne and (count < countTo)) then
      begin
        n := n + 2;
        continue;
      end;
      s := sumStr(divs);
      if not printOne then
      begin
        writeln(pad2(count) + '. ' + pad5(n) + ' < ' + s + ' = ' + IntToStr(tot));
      end else
      begin
        writeln(IntToStr(n) + ' < ' + s + ' = ' + IntToStr(tot));
      end;
    end;
    n := n + 2;
  end;
  result := n;
  exit;
end;

procedure main();
var
  max: function(p0: Variant): Variant is nested;
  n: Variant;
begin
  max := 25;
  writeln('The first ' + IntToStr(max) + ' abundant odd numbers are:');
  n := abundantOdd(1, 0, max, False);
  writeln('
The one thousandth abundant odd number is:');
  abundantOdd(n, max, 1000, True);
  writeln('
The first abundant odd number above one billion is:');
  abundantOdd(1000000001, 0, 1, True);
end;

begin
  main();
end.
