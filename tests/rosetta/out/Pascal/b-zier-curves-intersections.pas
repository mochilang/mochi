// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:12Z
program BZierCurvesIntersections;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;
type Point = record
  x: double;
  y: double;
end;
type QuadSpline = record
  c0: double;
  c1: double;
  c2: double;
end;
type QuadCurve = record
  x: QuadSpline;
  y: QuadSpline;
end;

function absf(x: double): double;
begin
  if (x < 0) then ;
  result := x;
  exit;
end;

function maxf(a: double; b: double): double;
begin
  if (a > b) then ;
  result := b;
  exit;
end;

function minf(a: double; b: double): double;
begin
  if (a < b) then ;
  result := b;
  exit;
end;

function max3(a: double; b: double; c: double): double;
var
  m: Variant;
begin
  m := a;
  if (b > m) then ;
  if (c > m) then ;
  result := m;
  exit;
end;

function min3(a: double; b: double; c: double): double;
var
  m: Variant;
begin
  m := a;
  if (b < m) then ;
  if (c < m) then ;
  result := m;
  exit;
end;

function subdivideQuadSpline(q: QuadSpline; t: double): specialize TArray<QuadSpline>;
var
  _tmp0: QuadSpline;
  _tmp1: QuadSpline;
  s: double;
  u: Variant;
  v: Variant;
begin
  s := 1 - t;
  _tmp0.c0 := q.c0;
  _tmp0.c1 := 0;
  _tmp0.c2 := 0;
  u := _tmp0;
  _tmp1.c0 := 0;
  _tmp1.c1 := 0;
  _tmp1.c2 := q.c2;
  v := _tmp1;
  u := s * q.c0 + t * q.c1;
  v := s * q.c1 + t * q.c2;
  u := s * u.c1 + t * v.c1;
  v := u.c2;
  result := specialize TArray<integer>([u, v]);
  exit;
end;

function subdivideQuadCurve(q: QuadCurve; t: double): specialize TArray<QuadCurve>;
var
  _tmp2: QuadCurve;
  _tmp3: QuadCurve;
  u: Variant;
  v: Variant;
  xs: Variant;
  ys: Variant;
begin
  xs := subdivideQuadSpline(q.x, t);
  ys := subdivideQuadSpline(q.y, t);
  _tmp2.x := xs[0];
  _tmp2.y := ys[0];
  u := _tmp2;
  _tmp3.x := xs[1];
  _tmp3.y := ys[1];
  v := _tmp3;
  result := specialize TArray<integer>([u, v]);
  exit;
end;

function rectsOverlap(xa0: double; ya0: double; xa1: double; ya1: double; xb0: double; yb0: double; xb1: double; yb1: double): boolean;
begin
  result := ((((xb0 <= xa1) and (xa0 <= xb1)) and (yb0 <= ya1)) and (ya0 <= yb1));
  exit;
end;

function testIntersect(p: QuadCurve; q: QuadCurve; tol: double): specialize TFPGMap<string, any>;
var
  _tmp4: Point;
  _tmp5: specialize TFPGMap<string, Variant>;
  accept: boolean;
  exclude: boolean;
  inter: Variant;
  pxmax: Variant;
  pxmin: Variant;
  pymax: Variant;
  pymin: Variant;
  qxmax: Variant;
  qxmin: Variant;
  qymax: Variant;
  qymin: Variant;
  xmax: Variant;
  xmin: Variant;
  ymax: Variant;
  ymin: Variant;
begin
  pxmin := min3(p.x.c0, p.x.c1, p.x.c2);
  pymin := min3(p.y.c0, p.y.c1, p.y.c2);
  pxmax := max3(p.x.c0, p.x.c1, p.x.c2);
  pymax := max3(p.y.c0, p.y.c1, p.y.c2);
  qxmin := min3(q.x.c0, q.x.c1, q.x.c2);
  qymin := min3(q.y.c0, q.y.c1, q.y.c2);
  qxmax := max3(q.x.c0, q.x.c1, q.x.c2);
  qymax := max3(q.y.c0, q.y.c1, q.y.c2);
  exclude := True;
  accept := False;
  _tmp4.x := 0;
  _tmp4.y := 0;
  inter := _tmp4;
  if rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax) then
  begin
    exclude := False;
    xmin := maxf(pxmin, qxmin);
    xmax := minf(pxmax, qxmax);
    if (xmax - xmin <= tol) then
    begin
      ymin := maxf(pymin, qymin);
      ymax := minf(pymax, qymax);
      if (ymax - ymin <= tol) then
      begin
        accept := True;
        inter := 0.5 * xmin + xmax;
        inter := 0.5 * ymin + ymax;
      end;
    end;
  end;
  _tmp5 := specialize TFPGMap<string, Variant>.Create;
  _tmp5.AddOrSetData('exclude', exclude);
  _tmp5.AddOrSetData('accept', accept);
  _tmp5.AddOrSetData('intersect', inter);
  result := _tmp5;
  exit;
end;

function seemsToBeDuplicate(pts: specialize TArray<Point>; xy: Point; spacing: double): boolean;
var
  i: integer;
  pt: Variant;
begin
  i := 0;
  while (i < Length(pts)) do
  begin
    pt := specialize _indexList<integer>(pts, i);
    if ((absf(pt.x - xy.x) < spacing) and (absf(pt.y - xy.y) < spacing)) then ;
    i := i + 1;
  end;
  result := False;
  exit;
end;

function findIntersects(p: QuadCurve; q: QuadCurve; tol: double; spacing: double): specialize TArray<Point>;
var
  _tmp10: specialize TFPGMap<string, Variant>;
  _tmp6: specialize TFPGMap<string, Variant>;
  _tmp7: specialize TFPGMap<string, Variant>;
  _tmp8: specialize TFPGMap<string, Variant>;
  _tmp9: specialize TFPGMap<string, Variant>;
  acc: Variant;
  excl: Variant;
  idx: Variant;
  inter: Variant;
  inters: specialize TArray<integer>;
  p0: Variant;
  p1: Variant;
  ps: Variant;
  q0: Variant;
  q1: Variant;
  qs: Variant;
  res: Variant;
  work: specialize TArray<specialize TFPGMap<string, integer>>;
  workload: specialize TArray<specialize TFPGMap<string, integer>>;
begin
  inters := specialize TArray<integer>([]);
  _tmp6 := specialize TFPGMap<string, Variant>.Create;
  _tmp6.AddOrSetData('p', p);
  _tmp6.AddOrSetData('q', q);
  workload := specialize TArray<specialize TFPGMap<string, integer>>([_tmp6]);
  while (Length(workload) > 0) do
  begin
    idx := Length(workload) - 1;
    work := workload[idx];
    workload := Copy(workload, 1, idx - 0);
    res := testIntersect(work['p'], work['q'], tol);
    excl := res['exclude'];
    acc := res['accept'];
    inter := Trunc(res['intersect']);
    if acc then
    begin
      if not seemsToBeDuplicate(inters, inter, spacing) then ;
    end else if not excl then
    begin
      ps := subdivideQuadCurve(work['p'], 0.5);
      qs := subdivideQuadCurve(work['q'], 0.5);
      p0 := ps[0];
      p1 := ps[1];
      q0 := qs[0];
      q1 := qs[1];
      _tmp7 := specialize TFPGMap<string, Variant>.Create;
      _tmp7.AddOrSetData('p', p0);
      _tmp7.AddOrSetData('q', q0);
      workload := specialize _appendList<Variant>(workload, _tmp7);
      _tmp8 := specialize TFPGMap<string, Variant>.Create;
      _tmp8.AddOrSetData('p', p0);
      _tmp8.AddOrSetData('q', q1);
      workload := specialize _appendList<Variant>(workload, _tmp8);
      _tmp9 := specialize TFPGMap<string, Variant>.Create;
      _tmp9.AddOrSetData('p', p1);
      _tmp9.AddOrSetData('q', q0);
      workload := specialize _appendList<Variant>(workload, _tmp9);
      _tmp10 := specialize TFPGMap<string, Variant>.Create;
      _tmp10.AddOrSetData('p', p1);
      _tmp10.AddOrSetData('q', q1);
      workload := specialize _appendList<Variant>(workload, _tmp10);
    end;
  end;
  result := inters;
  exit;
end;

function main(): integer;
var
  _tmp11: QuadCurve;
  _tmp12: QuadSpline;
  _tmp13: QuadSpline;
  _tmp14: QuadCurve;
  _tmp15: QuadSpline;
  _tmp16: QuadSpline;
  i: integer;
  inters: specialize TArray<integer>;
  p: Variant;
  pt: Variant;
  q: Variant;
  spacing: double;
  tol: double;
begin
  _tmp12.c0 := -1;
  _tmp12.c1 := 0;
  _tmp12.c2 := 1;
  _tmp11.x := _tmp12;
  _tmp13.c0 := 0;
  _tmp13.c1 := 10;
  _tmp13.c2 := 0;
  _tmp11.y := _tmp13;
  p := _tmp11;
  _tmp15.c0 := 2;
  _tmp15.c1 := -8;
  _tmp15.c2 := 2;
  _tmp14.x := _tmp15;
  _tmp16.c0 := 1;
  _tmp16.c1 := 2;
  _tmp16.c2 := 3;
  _tmp14.y := _tmp16;
  q := _tmp14;
  tol := 1e-07;
  spacing := tol * 10;
  inters := findIntersects(p, q, tol, spacing);
  i := 0;
  while (i < Length(inters)) do
  begin
    pt := specialize _indexList<integer>(inters, i);
    writeln('(' + IntToStr(pt.x) + ', ' + IntToStr(pt.y) + ')');
    i := i + 1;
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

begin
  main();
end.
