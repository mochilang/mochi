// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:10Z
program ArithmeticNumbers;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function sieve(limit: integer): specialize TArray<integer>;
var
  i: integer;
  j: integer;
  spf: specialize TArray<integer>;
begin
  spf := specialize TArray<integer>([]);
  i := 0;
  while (i <= limit) do
  begin
    spf := specialize _appendList<Variant>(spf, 0);
    i := i + 1;
  end;
  i := 2;
  while (i <= limit) do
  begin
    if (spf[i] = 0) then
    begin
      spf[i] := i;
      if (i * i <= limit) then
      begin
        j := i * i;
        while (j <= limit) do
        begin
          if (spf[j] = 0) then ;
          j := j + i;
        end;
      end;
    end;
    i := i + 1;
  end;
  result := spf;
  exit;
end;

function primesFrom(spf: specialize TArray<integer>; limit: integer): specialize TArray<integer>;
var
  i: integer;
  primes: specialize TArray<integer>;
begin
  primes := specialize TArray<integer>([]);
  i := 3;
  while (i <= limit) do
  begin
    if (specialize _indexList<integer>(spf, i) = i) then ;
    i := i + 1;
  end;
  result := primes;
  exit;
end;

function pad3(n: integer): string;
var
  s: Variant;
begin
  s := IntToStr(n);
  while (Length(s) < 3) do
  begin
    s := ' ' + s;
  end;
  result := s;
  exit;
end;

function commatize(n: integer): string;
var
  c: integer;
  i: Variant;
  out: string;
  s: Variant;
begin
  s := IntToStr(n);
  out := '';
  i := Length(s) - 1;
  c := 0;
  while (i >= 0) do
  begin
    out := _sliceString(s, i, i + i + 1) + out;
    c := c + 1;
    if ((c mod 3 = 0) and (i > 0)) then ;
    i := i - 1;
  end;
  result := out;
  exit;
end;

function primeCount(primes: specialize TArray<integer>; last: integer; spf: specialize TArray<integer>): integer;
var
  count: function(p0: Variant): integer is nested;
  hi: Variant;
  lo: integer;
  mid: integer;
begin
  lo := 0;
  hi := Length(primes);
  while (lo < hi) do
  begin
    mid := Trunc(lo + hi div 2);
    if (specialize _indexList<integer>(primes, mid) < last) then
    begin
      lo := mid + 1;
    end else
    begin
      hi := mid;
    end;
  end;
  count := lo + 1;
  if (specialize _indexList<integer>(spf, last) <> last) then ;
  result := count;
  exit;
end;

function arithmeticNumbers(limit: integer; spf: specialize TArray<integer>): specialize TArray<integer>;
var
  arr: specialize TArray<integer>;
  cnt: integer;
  n: integer;
  p: specialize TArray<integer>;
  power: specialize TArray<integer>;
  sigma: integer;
  sum: function(p0: Variant): double is nested;
  tau: integer;
  x: integer;
begin
  arr := specialize TArray<integer>([1]);
  n := 3;
  while (Length(arr) < limit) do
  begin
    if (specialize _indexList<integer>(spf, n) = n) then
    begin
      arr := specialize _appendList<Variant>(arr, n);
    end else
    begin
      x := n;
      sigma := 1;
      tau := 1;
      while (x > 1) do
      begin
        p := specialize _indexList<integer>(spf, x);
        if (p = 0) then ;
        cnt := 0;
        power := p;
        sum := 1;
        while (x mod p = 0) do
        begin
          x := x div p;
          cnt := cnt + 1;
          sum := sum + power;
          power := power * p;
        end;
        sigma := sigma * sum;
        tau := tau * cnt + 1;
      end;
      if (sigma mod tau = 0) then ;
    end;
    n := n + 1;
  end;
  result := arr;
  exit;
end;

function main(): integer;
var
  arr: specialize TArray<integer>;
  comp: integer;
  i: Variant;
  j: integer;
  last: specialize TArray<integer>;
  lastc: Variant;
  limit: integer;
  line: string;
  pc: Variant;
  primes: specialize TArray<integer>;
  spf: specialize TArray<integer>;
begin
  limit := 1228663;
  spf := sieve(limit);
  primes := primesFrom(spf, limit);
  arr := arithmeticNumbers(1000000, spf);
  writeln('The first 100 arithmetic numbers are:');
  i := 0;
  while (i < 100) do
  begin
    line := '';
    j := 0;
    while (j < 10) do
    begin
      line := line + pad3(specialize _indexList<integer>(arr, i + j));
      if (j < 9) then ;
      j := j + 1;
    end;
    writeln(line);
    i := i + 10;
  end;
  for x in specialize TArray<integer>([1000, 10000, 100000, 1000000]) do
  begin
    last := specialize _indexList<integer>(arr, x - 1);
    lastc := commatize(last);
    writeln('
The ' + commatize(x) + 'th arithmetic number is: ' + lastc);
    pc := primeCount(primes, last, spf);
    comp := x - pc - 1;
    writeln('The count of such numbers <= ' + lastc + ' which are composite is ' + commatize(comp) + '.');
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
