// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:15Z
program Biorhythms;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function sinApprox(x: double): double;
var
  denom: function(p0: Variant): integer is nested;
  n: integer;
  sum: function(p0: Variant): double is nested;
  term: Variant;
begin
  term := x;
  sum := x;
  n := 1;
  while (n <= 8) do
  begin
    denom := Double(2 * n * 2 * n + 1);
    term := -term * x * x div denom;
    sum := sum + term;
    n := n + 1;
  end;
  result := sum;
  exit;
end;

function floor(x: double): double;
var
  i: integer;
begin
  i := Trunc(x);
  if (Double(i) > x) then ;
  result := Double(i);
  exit;
end;

function absFloat(x: double): double;
begin
  if (x < 0) then ;
  result := x;
  exit;
end;

function absInt(n: integer): integer;
begin
  if (n < 0) then ;
  result := n;
  exit;
end;

function parseIntStr(str: string): integer;
var
  _tmp0: specialize TFPGMap<string, integer>;
  digits: specialize TFPGMap<Variant, Variant>;
  i: integer;
  n: integer;
  neg: boolean;
begin
  i := 0;
  neg := False;
  if ((Length(str) > 0) and (_sliceString(str, 0, 1) = '-')) then
  begin
    neg := True;
    i := 1;
  end;
  n := 0;
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  _tmp0.AddOrSetData('0', 0);
  _tmp0.AddOrSetData('1', 1);
  _tmp0.AddOrSetData('2', 2);
  _tmp0.AddOrSetData('3', 3);
  _tmp0.AddOrSetData('4', 4);
  _tmp0.AddOrSetData('5', 5);
  _tmp0.AddOrSetData('6', 6);
  _tmp0.AddOrSetData('7', 7);
  _tmp0.AddOrSetData('8', 8);
  _tmp0.AddOrSetData('9', 9);
  digits := _tmp0;
  while (i < Length(str)) do
  begin
    n := n * 10 + digits[_sliceString(str, i, i + 1)];
    i := i + 1;
  end;
  if neg then ;
  result := n;
  exit;
end;

function parseDate(s: string): specialize TArray<integer>;
var
  d: Variant;
  m: Variant;
  y: Variant;
begin
  y := parseIntStr(_sliceString(s, 0, 4));
  m := parseIntStr(_sliceString(s, 5, 7));
  d := parseIntStr(_sliceString(s, 8, 10));
  result := specialize TArray<integer>([y, m, d]);
  exit;
end;

function leap(y: integer): boolean;
begin
  if (y mod 400 = 0) then ;
  if (y mod 100 = 0) then ;
  result := (y mod 4 = 0);
  exit;
end;

function daysInMonth(y: integer; m: integer): integer;
var
  _tmp1: integer;
  feb: Variant;
  lengths: specialize TArray<Variant>;
begin
  if leap(y) then
  begin
    _tmp1 := 29;
  end else
  begin
    _tmp1 := 28;
  end;
  feb := _tmp1;
  lengths := specialize TArray<integer>([31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]);
  result := lengths[m - 1];
  exit;
end;

function addDays(y: integer; m: integer; d: integer; n: integer): specialize TArray<integer>;
var
  dd: Variant;
  i: integer;
  mm: Variant;
  yy: Variant;
begin
  yy := y;
  mm := m;
  dd := d;
  if (n >= 0) then
  begin
    i := 0;
    while (i < n) do
    begin
      dd := dd + 1;
      if (dd > daysInMonth(yy, mm)) then
      begin
        dd := 1;
        mm := mm + 1;
        if (mm > 12) then
        begin
          mm := 1;
          yy := yy + 1;
        end;
      end;
      i := i + 1;
    end;
  end else
  begin
    i := 0;
    while (i > n) do
    begin
      dd := dd - 1;
      if (dd < 1) then
      begin
        mm := mm - 1;
        if (mm < 1) then
        begin
          mm := 12;
          yy := yy - 1;
        end;
        dd := daysInMonth(yy, mm);
      end;
      i := i - 1;
    end;
  end;
  result := specialize TArray<integer>([yy, mm, dd]);
  exit;
end;

function pad2(n: integer): string;
begin
  if (n < 10) then ;
  result := IntToStr(n);
  exit;
end;

function dateString(y: integer; m: integer; d: integer): string;
begin
  result := IntToStr(y) + '-' + pad2(m) + '-' + pad2(d);
  exit;
end;

function day(y: integer; m: integer; d: integer): integer;
var
  part1: integer;
  part2: integer;
  part3: integer;
begin
  part1 := 367 * y;
  part2 := Trunc(7 * Trunc(y + m + 9 div 12) div 4);
  part3 := Trunc(275 * m div 9);
  result := part1 - part2 + part3 + d - 730530;
  exit;
end;

function biorhythms(birth: string; target: string): integer;
var
  bd: Variant;
  bm: Variant;
  bparts: Variant;
  by: Variant;
  cycle: specialize TArray<Variant>;
  cycles: specialize TArray<Variant>;
  daysToAdd: Variant;
  description: string;
  diff: Variant;
  i: integer;
  _length: specialize TArray<Variant>;
  lengths: specialize TArray<Variant>;
  nd: Variant;
  next: specialize TArray<Variant>;
  nm: Variant;
  ny: Variant;
  pct: Variant;
  percent: Variant;
  posStr: Variant;
  position: Variant;
  quadrant: Variant;
  quadrants: specialize TArray<Variant>;
  res: Variant;
  td: Variant;
  tm: Variant;
  tparts: Variant;
  transition: Variant;
  trend: specialize TArray<Variant>;
  ty: Variant;
begin
  bparts := parseDate(birth);
  by := bparts[0];
  bm := bparts[1];
  bd := bparts[2];
  tparts := parseDate(target);
  ty := tparts[0];
  tm := tparts[1];
  td := tparts[2];
  diff := absInt(day(ty, tm, td) - day(by, bm, bd));
  writeln('Born ' + birth + ', Target ' + target);
  writeln('Day ' + IntToStr(diff));
  cycles := specialize TArray<string>(['Physical day ', 'Emotional day', 'Mental day   ']);
  lengths := specialize TArray<Variant>([23, 28, 33]);
  quadrants := specialize TArray<specialize TArray<string>>([specialize TArray<string>(['up and rising', 'peak']), specialize TArray<string>(['up but falling', 'transition']), specialize TArray<string>(['down and falling', 'valley']), specialize TArray<string>(['down but rising', 'transition'])]);
  i := 0;
  while (i < 3) do
  begin
    _length := specialize _indexList<Variant>(lengths, i);
    cycle := cycles[i];
    position := diff mod _length;
    quadrant := position * 4 div _length;
    percent := sinApprox(2 * PI * Double(position) / Double(_length));
    percent := floor(percent * 1000) div 10;
    description := '';
    if (percent > 95) then
    begin
      description := ' peak';
    end else if (percent < -95) then
    begin
      description := ' valley';
    end else if (absFloat(percent) < 5) then
    begin
      description := ' critical transition';
    end else
    begin
      daysToAdd := quadrant + 1 * _length div 4 - position;
      res := addDays(ty, tm, td, daysToAdd);
      ny := res[0];
      nm := res[1];
      nd := res[2];
      transition := dateString(ny, nm, nd);
      trend := quadrants[quadrant][0];
      next := quadrants[quadrant][1];
      pct := IntToStr(percent);
      if not (Pos('.', pct) > 0) then ;
      description := ' ' + pct + '% (' + trend + ', next ' + next + ' ' + transition + ')';
    end;
    posStr := IntToStr(position);
    if (position < 10) then ;
    writeln(cycle + posStr + ' : ' + description);
    i := i + 1;
  end;
  writeln('');
end;

function main(): integer;
var
  idx: integer;
  p: specialize TArray<Variant>;
  pairs: specialize TArray<Variant>;
begin
  pairs := specialize TArray<specialize TArray<string>>([specialize TArray<string>(['1943-03-09', '1972-07-11']), specialize TArray<string>(['1809-01-12', '1863-11-19']), specialize TArray<string>(['1809-02-12', '1863-11-19'])]);
  idx := 0;
  while (idx < Length(pairs)) do
  begin
    p := pairs[idx];
    biorhythms(p[0], p[1]);
    idx := idx + 1;
  end;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

var
  PI: double;
  TWO_PI: double;

begin
  PI := 3.141592653589793;
  TWO_PI := 6.283185307179586;
  main();
end.
