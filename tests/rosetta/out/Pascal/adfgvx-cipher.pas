// Generated by Mochi compiler v0.10.26 on 2025-07-16T10:01:09Z
program AdfgvxCipher;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function shuffleStr(s: string): string;
var
  arr: specialize TArray<string>;
  i: integer;
  j: Variant;
  k: Variant;
  out: string;
  tmp: specialize TArray<string>;
begin
  arr := specialize TArray<string>([]);
  i := 0;
  while (i < Length(s)) do
  begin
    arr := Concat(arr, specialize TArray<Variant>([_indexString(s, i)]));
    i := i + 1;
  end;
  j := Length(arr) - 1;
  while (j > 0) do
  begin
    k := now() mod j + 1;
    tmp := arr[j];
    arr[j] := arr[k];
    arr[k] := tmp;
    j := j - 1;
  end;
  out := '';
  i := 0;
  while (i < Length(arr)) do
  begin
    out := out + arr[i];
    i := i + 1;
  end;
  result := out;
  exit;
end;

function createPolybius(): specialize TArray<string>;
var
  i: integer;
  j: Variant;
  line: string;
  p: specialize TArray<string>;
  row: Variant;
  shuffled: Variant;
begin
  shuffled := shuffleStr(alphabet);
  writeln('6 x 6 Polybius square:
');
  writeln('  | A D F G V X');
  writeln('---------------');
  p := specialize TArray<string>([]);
  i := 0;
  while (i < 6) do
  begin
    row := Copy(shuffled, i * 6 + 1, i + 1 * 6 - i * 6);
    p := Concat(p, specialize TArray<Variant>([row]));
    line := _indexString(adfgvx, i) + ' | ';
    j := 0;
    while (j < 6) do
    begin
      line := line + row[j] + ' ';
      j := j + 1;
    end;
    writeln(line);
    i := i + 1;
  end;
  result := p;
  exit;
end;

function createKey(n: integer): string;
var
  i: integer;
  idx: Variant;
  key: string;
  pool: string;
begin
  if ((n < 7) or (n > 12)) then ;
  pool := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  key := '';
  i := 0;
  while (i < n) do
  begin
    idx := now() mod Length(pool);
    key := key + pool[idx];
    pool := Copy(pool, 1, idx - 0) + Copy(pool, idx + 1 + 1, Length(pool) - idx + 1);
    i := i + 1;
  end;
  writeln('
The key is ' + key);
  result := key;
  exit;
end;

function orderKey(key: string): specialize TArray<integer>;
var
  i: integer;
  j: Variant;
  m: integer;
  n: Variant;
  pairs: specialize TArray<Variant>;
  res: specialize TArray<Variant>;
  tmp: specialize TArray<string>;
begin
  pairs := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(key)) do
  begin
    pairs := Concat(pairs, specialize TArray<specialize TArray<Variant>>([specialize TArray<string>([_indexString(key, i), i])]));
    i := i + 1;
  end;
  n := Length(pairs);
  m := 0;
  while (m < n) do
  begin
    j := 0;
    while (j < n - 1) do
    begin
      if (pairs[j][0] > pairs[j + 1][0]) then
      begin
        tmp := pairs[j];
        pairs[j] := pairs[j + 1];
        pairs[j + 1] := tmp;
      end;
      j := j + 1;
    end;
    m := m + 1;
  end;
  res := specialize TArray<integer>([]);
  i := 0;
  while (i < n) do
  begin
    res := Concat(res, specialize TArray<integer>([Trunc(pairs[i][1])]));
    i := i + 1;
  end;
  result := res;
  exit;
end;

function encrypt(polybius: specialize TArray<string>; key: string; plainText: string): string;
var
  c: integer;
  ci: integer;
  col: Variant;
  colLen: Variant;
  colStr: string;
  cols: specialize TArray<string>;
  i: integer;
  idx: Variant;
  j: Variant;
  order: Variant;
  r: integer;
  rIdx: integer;
  _result: string;
  ri: integer;
  row: Variant;
  table: specialize TArray<specialize TArray<string>>;
  temp: string;
begin
  temp := '';
  i := 0;
  while (i < Length(plainText)) do
  begin
    r := 0;
    while (r < 6) do
    begin
      c := 0;
      while (c < 6) do
      begin
        if (specialize _indexList<integer>(specialize _indexList<integer>(polybius, r), c) = _indexString(plainText, i)) then ;
        c := c + 1;
      end;
      r := r + 1;
    end;
    i := i + 1;
  end;
  colLen := Length(temp) div Length(key);
  if (Length(temp) mod Length(key) > 0) then ;
  table := specialize TArray<specialize TArray<string>>([]);
  rIdx := 0;
  while (rIdx < colLen) do
  begin
    row := specialize TArray<integer>([]);
    j := 0;
    while (j < Length(key)) do
    begin
      row := Concat(row, specialize TArray<string>(['']));
      j := j + 1;
    end;
    table := Concat(table, specialize TArray<Variant>([row]));
    rIdx := rIdx + 1;
  end;
  idx := 0;
  while (idx < Length(temp)) do
  begin
    row := idx div Length(key);
    col := idx mod Length(key);
    table[row][col] := Copy(temp, idx + 1, idx + 1 - idx);
    idx := idx + 1;
  end;
  order := orderKey(key);
  cols := specialize TArray<string>([]);
  ci := 0;
  while (ci < Length(key)) do
  begin
    colStr := '';
    ri := 0;
    while (ri < colLen) do
    begin
      colStr := colStr + table[ri][order[ci]];
      ri := ri + 1;
    end;
    cols := Concat(cols, specialize TArray<Variant>([colStr]));
    ci := ci + 1;
  end;
  _result := '';
  ci := 0;
  while (ci < Length(cols)) do
  begin
    _result := _result + cols[ci];
    if (ci < Length(cols) - 1) then ;
    ci := ci + 1;
  end;
  result := _result;
  exit;
end;

function indexOf(s: string; ch: string): integer;
var
  i: integer;
begin
  i := 0;
  while (i < Length(s)) do
  begin
    if (_indexString(s, i) = ch) then ;
    i := i + 1;
  end;
  result := -1;
  exit;
end;

function decrypt(polybius: specialize TArray<string>; key: string; cipherText: string): string;
var
  c: integer;
  cIdx: Variant;
  colStrs: specialize TArray<string>;
  cols: specialize TArray<string>;
  i: integer;
  idx: Variant;
  j: Variant;
  k: Variant;
  ls: specialize TArray<string>;
  maxColLen: integer;
  order: Variant;
  pad: specialize TArray<string>;
  plainText: string;
  r: integer;
  rIdx: Variant;
  row: Variant;
  s: specialize TArray<string>;
  start: integer;
  table: specialize TArray<specialize TArray<string>>;
  temp: string;
begin
  colStrs := specialize TArray<string>([]);
  start := 0;
  i := 0;
  while (i <= Length(cipherText)) do
  begin
    if ((i = Length(cipherText)) or (_indexString(cipherText, i) = ' ')) then
    begin
      colStrs := Concat(colStrs, specialize TArray<Variant>([_sliceString(cipherText, start, i)]));
      start := i + 1;
    end;
    i := i + 1;
  end;
  maxColLen := 0;
  i := 0;
  while (i < Length(colStrs)) do
  begin
    if (Length(colStrs[i]) > maxColLen) then ;
    i := i + 1;
  end;
  cols := specialize TArray<string>([]);
  i := 0;
  while (i < Length(colStrs)) do
  begin
    s := colStrs[i];
    ls := specialize TArray<string>([]);
    j := 0;
    while (j < Length(s)) do
    begin
      ls := Concat(ls, specialize TArray<Variant>([s[j]]));
      j := j + 1;
    end;
    if (Length(s) < maxColLen) then
    begin
      pad := specialize TArray<string>([]);
      k := 0;
      while (k < maxColLen) do
      begin
        if (k < Length(ls)) then
        begin
          pad := Concat(pad, specialize TArray<Variant>([ls[k]]));
        end else
        begin
          pad := Concat(pad, specialize TArray<string>(['']));
        end;
        k := k + 1;
      end;
      cols := Concat(cols, specialize TArray<string>([pad]));
    end else
    begin
      cols := Concat(cols, specialize TArray<string>([ls]));
    end;
    i := i + 1;
  end;
  table := specialize TArray<specialize TArray<string>>([]);
  r := 0;
  while (r < maxColLen) do
  begin
    row := specialize TArray<integer>([]);
    c := 0;
    while (c < Length(key)) do
    begin
      row := Concat(row, specialize TArray<string>(['']));
      c := c + 1;
    end;
    table := Concat(table, specialize TArray<specialize TArray<string>>([row]));
    r := r + 1;
  end;
  order := orderKey(key);
  r := 0;
  while (r < maxColLen) do
  begin
    c := 0;
    while (c < Length(key)) do
    begin
      table[r][order[c]] := specialize _indexList<string>(specialize _indexList<string>(cols, c), r);
      c := c + 1;
    end;
    r := r + 1;
  end;
  temp := '';
  r := 0;
  while (r < Length(table)) do
  begin
    j := 0;
    while (j < Length(specialize _indexList<specialize TArray<string>>(table, r))) do
    begin
      temp := temp + specialize _indexList<specialize TArray<string>>(specialize _indexList<specialize TArray<string>>(table, r), j);
      j := j + 1;
    end;
    r := r + 1;
  end;
  plainText := '';
  idx := 0;
  while (idx < Length(temp)) do
  begin
    rIdx := indexOf(adfgvx, _sliceString(temp, idx, idx + 1));
    cIdx := indexOf(adfgvx, _sliceString(temp, idx + 1, idx + 2));
    plainText := plainText + specialize _indexList<integer>(specialize _indexList<integer>(polybius, rIdx), cIdx);
    idx := idx + 2;
  end;
  result := plainText;
  exit;
end;

function main(): integer;
var
  cipherText: Variant;
  key: string;
  plainText: string;
  plainText2: Variant;
  polybius: Variant;
begin
  plainText := 'ATTACKAT1200AM';
  polybius := createPolybius();
  key := createKey(9);
  writeln('
Plaintext : ' + plainText);
  cipherText := encrypt(polybius, key, plainText);
  writeln('
Encrypted : ' + cipherText);
  plainText2 := decrypt(polybius, key, cipherText);
  writeln('
Decrypted : ' + plainText2);
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _indexString(s: string; i: integer): string;
begin
  if i < 0 then i := Length(s) + i;
  if (i < 0) or (i >= Length(s)) then
    raise Exception.Create('index out of range');
  Result := s[i + 1];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

var
  adfgvx: string;
  alphabet: string;

begin
  adfgvx := 'ADFGVX';
  alphabet := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  main();
end.
