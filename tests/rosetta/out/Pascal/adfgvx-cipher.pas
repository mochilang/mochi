// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program AdfgvxCipher;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _indexString(s: string; i: integer): string;
begin
  if i < 0 then i := Length(s) + i;
  if (i < 0) or (i >= Length(s)) then
    raise Exception.Create('index out of range');
  Result := s[i + 1];
end;

function _now(): int64;
begin
  Result := Trunc(Now * 86400000000000.0);
end;

generic procedure _printList<T>(arr: specialize TArray<T>);
var i: Integer;
begin
  for i := 0 to High(arr) do
  begin
    if i > 0 then Write(' ');
    Write(arr[i]);
  end;
  writeln();
end;

generic function _sliceList<T>(arr: specialize TArray<T>; i, j: integer): specialize TArray<T>;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(arr);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(arr, start_ + 1, end_ - start_);
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;


var
  adfgvx: string;
  alphabet: string;

function shuffleStr(s: string): string;
var
  arr: specialize TArray<Variant>;
  i: integer;
  j: Variant;
  k: Variant;
  out: string;
  tmp: specialize TArray<Variant>;
begin
  arr := specialize TArray<Variant>([]);
  i := 0;
  while (i < Length(s)) do
  begin
    arr := specialize _appendList<Variant>(arr, _sliceString(s, i, i + 1));
    i := i + 1;
  end;
  j := Length(arr) - 1;
  while (j > 0) do
  begin
    k := _now() mod j + 1;
    tmp := specialize _indexList<Variant>(arr, j);
    arr[j] := specialize _indexList<Variant>(arr, k);
    arr[k] := tmp;
    j := j - 1;
  end;
  out := '';
  i := 0;
  while (i < Length(arr)) do
  begin
    out := out + specialize _indexList<Variant>(arr, i);
    i := i + 1;
  end;
  result := out;
  exit;
end;

function createPolybius(): specialize TArray<string>;
var
  i: integer;
  j: Variant;
  labels: specialize TArray<Variant>;
  li: integer;
  line: specialize TArray<Variant>;
  p: specialize TArray<Variant>;
  row: Variant;
  shuffled: Variant;
begin
  shuffled := shuffleStr(alphabet);
  labels := specialize TArray<Variant>([]);
  li := 0;
  while (li < Length(adfgvx)) do
  begin
    labels := specialize _appendList<Variant>(labels, _sliceString(adfgvx, li, li + 1));
    li := li + 1;
  end;
  writeln('6 x 6 Polybius square:
');
  writeln('  | A D F G V X');
  writeln('---------------');
  p := specialize TArray<Variant>([]);
  i := 0;
  while (i < 6) do
  begin
    row := Copy(shuffled, i * 6 + 1, i + 1 * 6 - i * 6);
    p := specialize _appendList<Variant>(p, row);
    line := specialize _sliceList<Variant>(labels, i, i + 1) + ' | ';
    j := 0;
    while (j < 6) do
    begin
      line := Concat(Concat(line, Copy(row, j + 1, j + 1 - j)), ' ');
      j := j + 1;
    end;
    specialize _printList<Variant>(line);
    i := i + 1;
  end;
  result := p;
  exit;
end;

function createKey(n: integer): string;
var
  i: integer;
  idx: Variant;
  key: string;
  pool: string;
begin
  if ((n < 7) or (n > 12)) then ;
  pool := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  key := '';
  i := 0;
  while (i < n) do
  begin
    idx := _now() mod Length(pool);
    key := key + _indexString(pool, idx);
    pool := _sliceString(pool, 0, idx) + _sliceString(pool, idx + 1, Length(pool));
    i := i + 1;
  end;
  writeln('
The key is ' + key);
  result := key;
  exit;
end;

function orderKey(key: string): specialize TArray<integer>;
var
  i: integer;
  j: Variant;
  m: integer;
  n: Variant;
  pairs: specialize TArray<Variant>;
  res: specialize TArray<Variant>;
  tmp: specialize TArray<Variant>;
begin
  pairs := specialize TArray<Variant>([]);
  i := 0;
  while (i < Length(key)) do
  begin
    pairs := specialize _appendList<Variant>(pairs, specialize TArray<Variant>([_sliceString(key, i, i + 1), i]));
    i := i + 1;
  end;
  n := Length(pairs);
  m := 0;
  while (m < n) do
  begin
    j := 0;
    while (j < n - 1) do
    begin
      if (specialize _indexList<Variant>(specialize _indexList<Variant>(pairs, j), 0) > specialize _indexList<Variant>(specialize _indexList<Variant>(pairs, j + 1), 0)) then
      begin
        tmp := specialize _indexList<Variant>(pairs, j);
        pairs[j] := specialize _indexList<Variant>(pairs, j + 1);
        pairs[j + 1] := tmp;
      end;
      j := j + 1;
    end;
    m := m + 1;
  end;
  res := specialize TArray<Variant>([]);
  i := 0;
  while (i < n) do
  begin
    res := specialize _appendList<Variant>(res, Trunc(specialize _indexList<Variant>(specialize _indexList<Variant>(pairs, i), 1)));
    i := i + 1;
  end;
  result := res;
  exit;
end;

function encrypt(polybius: specialize TArray<string>; key: string; plainText: string): string;
var
  c: integer;
  ci: integer;
  col: Variant;
  colLen: Variant;
  colStr: string;
  cols: specialize TArray<Variant>;
  i: integer;
  idx: Variant;
  j: Variant;
  labels: specialize TArray<Variant>;
  li: integer;
  order: Variant;
  r: integer;
  rIdx: integer;
  _result: string;
  ri: integer;
  row: Variant;
  table: specialize TArray<Variant>;
  temp: string;
begin
  labels := specialize TArray<Variant>([]);
  li := 0;
  while (li < Length(adfgvx)) do
  begin
    labels := specialize _appendList<Variant>(labels, _sliceString(adfgvx, li, li + 1));
    li := li + 1;
  end;
  temp := '';
  i := 0;
  while (i < Length(plainText)) do
  begin
    r := 0;
    while (r < 6) do
    begin
      c := 0;
      while (c < 6) do
      begin
        if (specialize _sliceList<integer>(specialize _indexList<integer>(polybius, r), c, c + 1) = _sliceString(plainText, i, i + 1)) then ;
        c := c + 1;
      end;
      r := r + 1;
    end;
    i := i + 1;
  end;
  colLen := Length(temp) div Length(key);
  if (Length(temp) mod Length(key) > 0) then ;
  table := specialize TArray<Variant>([]);
  rIdx := 0;
  while (rIdx < colLen) do
  begin
    row := specialize TArray<integer>([]);
    j := 0;
    while (j < Length(key)) do
    begin
      row := specialize _appendList<Variant>(row, '');
      j := j + 1;
    end;
    table := specialize _appendList<Variant>(table, row);
    rIdx := rIdx + 1;
  end;
  idx := 0;
  while (idx < Length(temp)) do
  begin
    row := idx div Length(key);
    col := idx mod Length(key);
    table[row][col] := _sliceString(temp, idx, idx + 1);
    idx := idx + 1;
  end;
  order := orderKey(key);
  cols := specialize TArray<Variant>([]);
  ci := 0;
  while (ci < Length(key)) do
  begin
    colStr := '';
    ri := 0;
    while (ri < colLen) do
    begin
      colStr := colStr + specialize _indexList<Variant>(specialize _indexList<Variant>(table, ri), order[ci]);
      ri := ri + 1;
    end;
    cols := specialize _appendList<Variant>(cols, colStr);
    ci := ci + 1;
  end;
  _result := '';
  ci := 0;
  while (ci < Length(cols)) do
  begin
    _result := _result + specialize _indexList<Variant>(cols, ci);
    if (ci < Length(cols) - 1) then ;
    ci := ci + 1;
  end;
  result := _result;
  exit;
end;

function indexOf(s: string; ch: string): integer;
var
  i: integer;
begin
  i := 0;
  while (i < Length(s)) do
  begin
    if (_sliceString(s, i, i + 1) = ch) then ;
    i := i + 1;
  end;
  result := -1;
  exit;
end;

function decrypt(polybius: specialize TArray<string>; key: string; cipherText: string): string;
var
  c: integer;
  cIdx: Variant;
  colStrs: specialize TArray<Variant>;
  cols: specialize TArray<Variant>;
  i: integer;
  idx: Variant;
  j: Variant;
  k: Variant;
  ls: specialize TArray<Variant>;
  maxColLen: integer;
  order: Variant;
  pad: specialize TArray<Variant>;
  plainText: string;
  r: integer;
  rIdx: Variant;
  row: Variant;
  s: specialize TArray<Variant>;
  start: integer;
  table: specialize TArray<Variant>;
  temp: string;
begin
  colStrs := specialize TArray<Variant>([]);
  start := 0;
  i := 0;
  while (i <= Length(cipherText)) do
  begin
    if ((i = Length(cipherText)) or (_indexString(cipherText, i) = ' ')) then
    begin
      colStrs := specialize _appendList<Variant>(colStrs, _sliceString(cipherText, start, i));
      start := i + 1;
    end;
    i := i + 1;
  end;
  maxColLen := 0;
  i := 0;
  while (i < Length(colStrs)) do
  begin
    if (Length(specialize _indexList<Variant>(colStrs, i)) > maxColLen) then ;
    i := i + 1;
  end;
  cols := specialize TArray<Variant>([]);
  i := 0;
  while (i < Length(colStrs)) do
  begin
    s := specialize _indexList<Variant>(colStrs, i);
    ls := specialize TArray<Variant>([]);
    j := 0;
    while (j < Length(s)) do
    begin
      ls := specialize _appendList<Variant>(ls, specialize _sliceList<Variant>(s, j, j + 1));
      j := j + 1;
    end;
    if (Length(s) < maxColLen) then
    begin
      pad := specialize TArray<Variant>([]);
      k := 0;
      while (k < maxColLen) do
      begin
        if (k < Length(ls)) then
        begin
          pad := specialize _appendList<Variant>(pad, specialize _indexList<Variant>(ls, k));
        end else
        begin
          pad := specialize _appendList<Variant>(pad, '');
        end;
        k := k + 1;
      end;
      cols := specialize _appendList<Variant>(cols, pad);
    end else
    begin
      cols := specialize _appendList<Variant>(cols, ls);
    end;
    i := i + 1;
  end;
  table := specialize TArray<Variant>([]);
  r := 0;
  while (r < maxColLen) do
  begin
    row := specialize TArray<integer>([]);
    c := 0;
    while (c < Length(key)) do
    begin
      row := specialize _appendList<Variant>(row, '');
      c := c + 1;
    end;
    table := specialize _appendList<Variant>(table, row);
    r := r + 1;
  end;
  order := orderKey(key);
  r := 0;
  while (r < maxColLen) do
  begin
    c := 0;
    while (c < Length(key)) do
    begin
      table[r][order[c]] := specialize _indexList<Variant>(specialize _indexList<Variant>(cols, c), r);
      c := c + 1;
    end;
    r := r + 1;
  end;
  temp := '';
  r := 0;
  while (r < Length(table)) do
  begin
    j := 0;
    while (j < Length(specialize _indexList<Variant>(table, r))) do
    begin
      temp := temp + specialize _indexList<Variant>(specialize _indexList<Variant>(table, r), j);
      j := j + 1;
    end;
    r := r + 1;
  end;
  plainText := '';
  idx := 0;
  while (idx < Length(temp)) do
  begin
    rIdx := indexOf(adfgvx, _sliceString(temp, idx, idx + 1));
    cIdx := indexOf(adfgvx, _sliceString(temp, idx + 1, idx + 2));
    plainText := plainText + specialize _indexList<integer>(specialize _indexList<integer>(polybius, rIdx), cIdx);
    idx := idx + 2;
  end;
  result := plainText;
  exit;
end;

procedure main();
var
  cipherText: Variant;
  key: string;
  plainText: string;
  plainText2: Variant;
  polybius: Variant;
begin
  plainText := 'ATTACKAT1200AM';
  polybius := createPolybius();
  key := createKey(9);
  writeln('
Plaintext : ' + plainText);
  cipherText := encrypt(polybius, key, plainText);
  writeln('
Encrypted : ' + cipherText);
  plainText2 := decrypt(polybius, key, cipherText);
  writeln('
Decrypted : ' + plainText2);
end;

begin
  adfgvx := 'ADFGVX';
  alphabet := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  main();
end.
