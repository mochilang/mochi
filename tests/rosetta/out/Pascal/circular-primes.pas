// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:24Z
program CircularPrimes;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function isPrime(n: integer): boolean;
var
  d: integer;
begin
  if (n < 2) then ;
  if (n mod 2 = 0) then ;
  if (n mod 3 = 0) then ;
  d := 5;
  while (d * d <= n) do
  begin
    if (n mod d = 0) then ;
    d := d + 2;
    if (n mod d = 0) then ;
    d := d + 4;
  end;
  result := True;
  exit;
end;

function isCircular(n: integer): boolean;
var
  f: Variant;
  nn: Variant;
  pow: integer;
begin
  nn := n;
  pow := 1;
  while (nn > 0) do
  begin
    pow := pow * 10;
    nn := nn div 10;
  end;
  nn := n;
  while True do
  begin
    nn := nn * 10;
    f := nn div pow;
    nn := nn + f * 1 - pow;
    if (nn = n) then ;
    if not isPrime(nn) then ;
  end;
  result := True;
  exit;
end;

function showList(xs: specialize TArray<integer>): string;
var
  i: integer;
  out: string;
begin
  out := '[';
  i := 0;
  while (i < Length(xs)) do
  begin
    out := out + IntToStr(specialize _indexList<integer>(xs, i));
    if (i < Length(xs) - 1) then ;
    i := i + 1;
  end;
  result := out + ']';
  exit;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

generic function _sliceList<T>(arr: specialize TArray<T>; i, j: integer): specialize TArray<T>;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(arr);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(arr, start_ + 1, end_ - start_);
end;

var
  circs: specialize TArray<integer>;
  count: integer;
  d: integer;
  digits: specialize TArray<integer>;
  f: Variant;
  fd: specialize TArray<integer>;
  fq: specialize TArray<integer>;
  i: Variant;
  q: specialize TArray<integer>;

begin
  circs := specialize TArray<integer>([]);
  writeln('The first 19 circular primes are:');
  digits := specialize TArray<integer>([1, 3, 7, 9]);
  q := specialize TArray<integer>([1, 2, 3, 5, 7, 9]);
  fq := specialize TArray<integer>([1, 2, 3, 5, 7, 9]);
  count := 0;
  while True do
  begin
    f := specialize _indexList<integer>(q, 0);
    fd := specialize _indexList<integer>(fq, 0);
    if (isPrime(f) and isCircular(f)) then
    begin
      circs := specialize _appendList<integer>(circs, f);
      count := count + 1;
      if (count = 19) then ;
    end;
    q := specialize _sliceList<integer>(q, 1, Length(q));
    fq := specialize _sliceList<integer>(fq, 1, Length(fq));
    if ((f <> 2) and (f <> 5)) then ;
  end;
  writeln(showList(circs));
  writeln('
The next 4 circular primes, in repunit format, are:');
  writeln('[R(19) R(23) R(317) R(1031)]');
  writeln('
The following repunits are probably circular primes:');
  for i in specialize TArray<integer>([5003, 9887, 15073, 25031, 35317, 49081]) do
  begin
    writeln('R(' + IntToStr(i) + ') : true');
  end;
end.
