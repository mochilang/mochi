// Generated by Mochi compiler v0.10.26 on 2025-07-16T10:01:22Z
program AveragesMode;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

var
  _tmp0: specialize TFPGMap<string, integer>;
  _tmp1: specialize TFPGMap<string, integer>;
  arr1: specialize TArray<integer>;
  arr2: specialize TArray<integer>;
  c: specialize TFPGMap<integer, integer>;
  counts1: specialize TFPGMap<integer, integer>;
  counts2: specialize TFPGMap<integer, integer>;
  i: integer;
  k: specialize TArray<integer>;
  keys1: specialize TArray<integer>;
  keys2: specialize TArray<integer>;
  max1: integer;
  max2: integer;
  modes1: specialize TArray<integer>;
  modes2: specialize TArray<integer>;
  v: specialize TArray<integer>;

begin
  arr1 := specialize TArray<integer>([2, 7, 1, 8, 2]);
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  counts1 := _tmp0;
  keys1 := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(arr1)) do
  begin
    v := specialize _indexList<integer>(arr1, i);
    if (counts1.IndexOf(v) >= 0) then
    begin
      counts1.KeyData[v] := counts1.KeyData[v] + 1;
    end else
    begin
      counts1.KeyData[v] := 1;
      keys1 := specialize _appendList<integer>(keys1, v);
    end;
    i := i + 1;
  end;
  max1 := 0;
  i := 0;
  while (i < Length(keys1)) do
  begin
    k := specialize _indexList<integer>(keys1, i);
    c := counts1.KeyData[k];
    if (c > max1) then ;
    i := i + 1;
  end;
  modes1 := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(keys1)) do
  begin
    k := specialize _indexList<integer>(keys1, i);
    if (counts1.KeyData[k] = max1) then ;
    i := i + 1;
  end;
  writeln(IntToStr(modes1));
  arr2 := specialize TArray<integer>([2, 7, 1, 8, 2, 8]);
  _tmp1 := specialize TFPGMap<string, integer>.Create;
  counts2 := _tmp1;
  keys2 := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(arr2)) do
  begin
    v := specialize _indexList<integer>(arr2, i);
    if (counts2.IndexOf(v) >= 0) then
    begin
      counts2.KeyData[v] := counts2.KeyData[v] + 1;
    end else
    begin
      counts2.KeyData[v] := 1;
      keys2 := specialize _appendList<integer>(keys2, v);
    end;
    i := i + 1;
  end;
  max2 := 0;
  i := 0;
  while (i < Length(keys2)) do
  begin
    k := specialize _indexList<integer>(keys2, i);
    c := counts2.KeyData[k];
    if (c > max2) then ;
    i := i + 1;
  end;
  modes2 := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(keys2)) do
  begin
    k := specialize _indexList<integer>(keys2, i);
    if (counts2.KeyData[k] = max2) then ;
    i := i + 1;
  end;
  writeln(IntToStr(modes2));
end.
