// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:16Z
program BitmapWriteAPpmFile;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;
type Colour = record
  R: integer;
  G: integer;
  B: integer;
end;
type Bitmap = record
  width: integer;
  height: integer;
  pixels: specialize TArray<specialize TArray<Colour>>;
end;

function newBitmap(w: integer; h: integer; c: Colour): Bitmap;
var
  _tmp0: Bitmap;
  row: specialize TArray<integer>;
  rows: specialize TArray<specialize TArray<integer>>;
  x: integer;
  y: integer;
begin
  rows := specialize TArray<specialize TArray<integer>>([]);
  y := 0;
  while (y < h) do
  begin
    row := specialize TArray<integer>([]);
    x := 0;
    while (x < w) do
    begin
      row := specialize _appendList<Variant>(row, c);
      x := x + 1;
    end;
    rows := specialize _appendList<Variant>(rows, row);
    y := y + 1;
  end;
  _tmp0.width := w;
  _tmp0.height := h;
  _tmp0.pixels := rows;
  result := _tmp0;
  exit;
end;

function setPixel(b: Bitmap; x: integer; y: integer; c: Colour): integer;
var
  row: specialize TArray<integer>;
  rows: specialize TArray<specialize TArray<integer>>;
begin
  rows := b.pixels;
  row := specialize _indexList<specialize TArray<integer>>(rows, y);
  row[x] := c;
  rows[y] := row;
  b := rows;
end;

function fillRect(b: Bitmap; x: integer; y: integer; w: integer; h: integer; c: Colour): integer;
var
  xx: integer;
  yy: integer;
begin
  yy := y;
  while (yy < y + h) do
  begin
    xx := x;
    while (xx < x + w) do
    begin
      setPixel(b, xx, yy, c);
      xx := xx + 1;
    end;
    yy := yy + 1;
  end;
end;

function pad(n: integer; width: integer): string;
var
  s: Variant;
begin
  s := IntToStr(n);
  while (Length(s) < width) do
  begin
    s := ' ' + s;
  end;
  result := s;
  exit;
end;

function writePPMP3(b: Bitmap): string;
var
  line: string;
  maxv: integer;
  numsize: Variant;
  out: string;
  p: Variant;
  x: integer;
  y: integer;
begin
  maxv := 0;
  y := 0;
  while (y < b.height) do
  begin
    x := 0;
    while (x < b.width) do
    begin
      p := b.pixels[y][x];
      if (p.R > maxv) then ;
      if (p.G > maxv) then ;
      if (p.B > maxv) then ;
      x := x + 1;
    end;
    y := y + 1;
  end;
  out := 'P3
# generated from Bitmap.writeppmp3
' + IntToStr(b.width) + ' ' + IntToStr(b.height) + '
' + IntToStr(maxv) + '
';
  numsize := Length(IntToStr(maxv));
  y := b.height - 1;
  while (y >= 0) do
  begin
    line := '';
    x := 0;
    while (x < b.width) do
    begin
      p := b.pixels[y][x];
      line := line + '   ' + pad(p.R, numsize) + ' ' + pad(p.G, numsize) + ' ' + pad(p.B, numsize);
      x := x + 1;
    end;
    out := out + line;
    if (y > 0) then
    begin
      out := out + '
';
    end else
    begin
      out := out + '
';
    end;
    y := y - 1;
  end;
  result := out;
  exit;
end;

function main(): integer;
var
  _tmp1: Colour;
  _tmp2: Colour;
  _tmp3: Colour;
  black: Variant;
  bm: Variant;
  ppm: Variant;
  white: Variant;
begin
  _tmp1.R := 0;
  _tmp1.G := 0;
  _tmp1.B := 0;
  black := _tmp1;
  _tmp2.R := 255;
  _tmp2.G := 255;
  _tmp2.B := 255;
  white := _tmp2;
  bm := newBitmap(4, 4, black);
  fillRect(bm, 1, 0, 1, 2, white);
  _tmp3.R := 127;
  _tmp3.G := 0;
  _tmp3.B := 63;
  setPixel(bm, 3, 3, _tmp3);
  ppm := writePPMP3(bm);
  writeln(ppm);
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

begin
  main();
end.
