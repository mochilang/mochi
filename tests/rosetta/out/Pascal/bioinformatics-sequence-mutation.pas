// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:14Z
program BioinformaticsSequenceMutation;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function randInt(s: integer; n: integer): specialize TArray<integer>;
var
  next: Variant;
begin
  next := s * 1664525 + 1013904223 mod 2147483647;
  result := specialize TArray<integer>([next, next mod n]);
  exit;
end;

function padLeft(s: string; w: integer): string;
var
  n: Variant;
  res: string;
begin
  res := '';
  n := w - Length(s);
  while (n > 0) do
  begin
    res := res + ' ';
    n := n - 1;
  end;
  result := res + s;
  exit;
end;

function makeSeq(s: integer; le: integer): specialize TArray<any>;
var
  bases: string;
  i: integer;
  idx: integer;
  out: string;
  r: Variant;
begin
  bases := 'ACGT';
  out := '';
  i := 0;
  while (i < le) do
  begin
    r := randInt(s, 4);
    s := r[0];
    idx := Trunc(r[1]);
    out := out + _sliceString(bases, idx, idx + idx + 1);
    i := i + 1;
  end;
  result := specialize TArray<integer>([s, out]);
  exit;
end;

function mutate(s: integer; dna: string; w: specialize TArray<integer>): specialize TArray<any>;
var
  arr: specialize TArray<string>;
  b: Variant;
  bases: string;
  i: integer;
  idx: integer;
  idx2: integer;
  j: Variant;
  le: Variant;
  out: string;
  p: integer;
  r: Variant;
  x: integer;
begin
  bases := 'ACGT';
  le := Length(dna);
  r := randInt(s, le);
  s := r[0];
  p := Trunc(r[1]);
  r := randInt(s, 300);
  s := r[0];
  x := Trunc(r[1]);
  arr := specialize TArray<string>([]);
  i := 0;
  while (i < le) do
  begin
    arr := specialize _appendList<Variant>(arr, _sliceString(dna, i, i + i + 1));
    i := i + 1;
  end;
  if (x < specialize _indexList<integer>(w, 0)) then
  begin
    r := randInt(s, 4);
    s := r[0];
    idx := Trunc(r[1]);
    b := _sliceString(bases, idx, idx + idx + 1);
    writeln('  Change @' + padLeft(IntToStr(p), 3) + ' ''' + arr[p] + ''' to ''' + b + '''');
    arr[p] := b;
  end else if (x < specialize _indexList<integer>(w, 0) + specialize _indexList<integer>(w, 1)) then
  begin
    writeln('  Delete @' + padLeft(IntToStr(p), 3) + ' ''' + arr[p] + '''');
    j := p;
    while (j < Length(arr) - 1) do
    begin
      arr[j] := arr[j + 1];
      j := j + 1;
    end;
    arr := Copy(arr, 1, Length(arr) - 1 - 0);
  end else
  begin
    r := randInt(s, 4);
    s := r[0];
    idx2 := Trunc(r[1]);
    b := _sliceString(bases, idx2, idx2 + idx2 + 1);
    arr := specialize _appendList<Variant>(arr, '');
    j := Length(arr) - 1;
    while (j > p) do
    begin
      arr[j] := arr[j - 1];
      j := j - 1;
    end;
    writeln('  Insert @' + padLeft(IntToStr(p), 3) + ' ''' + b + '''');
    arr[p] := b;
  end;
  out := '';
  i := 0;
  while (i < Length(arr)) do
  begin
    out := out + arr[i];
    i := i + 1;
  end;
  result := specialize TArray<integer>([s, out]);
  exit;
end;

function prettyPrint(dna: string; rowLen: integer): integer;
var
  a: integer;
  c: integer;
  ch: Variant;
  g: integer;
  i: integer;
  idx: integer;
  k: integer;
  le: Variant;
  t: integer;
begin
  writeln('SEQUENCE:');
  le := Length(dna);
  i := 0;
  while (i < le) do
  begin
    k := i + rowLen;
    if (k > le) then ;
    writeln(padLeft(IntToStr(i), 5) + ': ' + _sliceString(dna, i, k));
    i := i + rowLen;
  end;
  a := 0;
  c := 0;
  g := 0;
  t := 0;
  idx := 0;
  while (idx < le) do
  begin
    ch := _sliceString(dna, idx, idx + idx + 1);
    if (ch = 'A') then
    begin
      a := a + 1;
    end else
    begin
      if (ch = 'C') then
      begin
        c := c + 1;
      end else
      begin
        if (ch = 'G') then
        begin
          g := g + 1;
        end else
        begin
          if (ch = 'T') then ;
        end;
      end;
    end;
    idx := idx + 1;
  end;
  writeln('');
  writeln('BASE COUNT:');
  writeln('    A: ' + padLeft(IntToStr(a), 3));
  writeln('    C: ' + padLeft(IntToStr(c), 3));
  writeln('    G: ' + padLeft(IntToStr(g), 3));
  writeln('    T: ' + padLeft(IntToStr(t), 3));
  writeln('    ------');
  writeln('    Î£: ' + IntToStr(le));
  writeln('    ======');
end;

function wstring(w: specialize TArray<integer>): string;
begin
  result := '  Change: ' + IntToStr(specialize _indexList<integer>(w, 0)) + '
  Delete: ' + IntToStr(specialize _indexList<integer>(w, 1)) + '
  Insert: ' + IntToStr(specialize _indexList<integer>(w, 2)) + '
';
  exit;
end;

function main(): integer;
var
  dna: string;
  i: integer;
  muts: integer;
  res: string;
  seed: integer;
  w: specialize TArray<Variant>;
begin
  seed := 1;
  res := makeSeq(seed, 250);
  seed := _indexString(res, 0);
  dna := Trunc(_indexString(res, 1));
  prettyPrint(dna, 50);
  muts := 10;
  w := specialize TArray<integer>([100, 100, 100]);
  writeln('
WEIGHTS (ex 300):');
  writeln(wstring(w));
  writeln('MUTATIONS (' + IntToStr(muts) + '):');
  i := 0;
  while (i < muts) do
  begin
    res := mutate(seed, dna, w);
    seed := _indexString(res, 0);
    dna := Trunc(_indexString(res, 1));
    i := i + 1;
  end;
  writeln('');
  prettyPrint(dna, 50);
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _indexString(s: string; i: integer): string;
begin
  if i < 0 then i := Length(s) + i;
  if (i < 0) or (i >= Length(s)) then
    raise Exception.Create('index out of range');
  Result := s[i + 1];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
