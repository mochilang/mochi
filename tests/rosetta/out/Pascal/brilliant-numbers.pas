// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:17Z
program BrilliantNumbers;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function primesUpTo(n: integer): specialize TArray<integer>;
var
  i: integer;
  m: integer;
  p: integer;
  res: specialize TArray<integer>;
  sieve: specialize TArray<boolean>;
  x: integer;
begin
  sieve := specialize TArray<boolean>([]);
  i := 0;
  while (i <= n) do
  begin
    sieve := specialize _appendList<Variant>(sieve, True);
    i := i + 1;
  end;
  p := 2;
  while (p * p <= n) do
  begin
    if sieve[p] then
    begin
      m := p * p;
      while (m <= n) do
      begin
        sieve[m] := False;
        m := m + p;
      end;
    end;
    p := p + 1;
  end;
  res := specialize TArray<integer>([]);
  x := 2;
  while (x <= n) do
  begin
    if sieve[x] then ;
    x := x + 1;
  end;
  result := res;
  exit;
end;

function sortInts(xs: specialize TArray<integer>): specialize TArray<integer>;
var
  i: integer;
  idx: integer;
  j: integer;
  min: function(p0: Variant): Variant is nested;
  out: specialize TArray<integer>;
  res: specialize TArray<integer>;
  tmp: Variant;
begin
  res := specialize TArray<integer>([]);
  tmp := xs;
  while (Length(tmp) > 0) do
  begin
    min := tmp[0];
    idx := 0;
    i := 1;
    while (i < Length(tmp)) do
    begin
      if (tmp[i] < min) then
      begin
        min := tmp[i];
        idx := i;
      end;
      i := i + 1;
    end;
    res := specialize _appendList<integer>(res, min);
    out := specialize TArray<integer>([]);
    j := 0;
    while (j < Length(tmp)) do
    begin
      if (j <> idx) then ;
      j := j + 1;
    end;
    tmp := out;
  end;
  result := res;
  exit;
end;

function commatize(n: integer): string;
var
  i: Variant;
  s: Variant;
begin
  s := IntToStr(n);
  i := Length(s) - 3;
  while (i >= 1) do
  begin
    s := Copy(s, 1, i - 0) + ',' + Copy(s, i + 1, Length(s) - i);
    i := i - 3;
  end;
  result := s;
  exit;
end;

function getBrilliant(digits: integer; limit: integer; countOnly: boolean): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
  _tmp1: specialize TFPGMap<string, Variant>;
  brilliant: specialize TArray<integer>;
  count: function(p0: Variant): integer is nested;
  i: Variant;
  j: Variant;
  k: integer;
  next: integer;
  pow: integer;
  prod: Variant;
  s: Variant;
begin
  brilliant := specialize TArray<integer>([]);
  count := 0;
  pow := 1;
  next := 999999999999999;
  k := 1;
  while (k <= digits) do
  begin
    s := specialize TArray<integer>([]);
    for p in primes do
    begin
      if (p >= pow * 10) then ;
      if (p > pow) then ;
    end;
    i := 0;
    while (i < Length(s)) do
    begin
      j := i;
      while (j < Length(s)) do
      begin
        prod := s[i] * s[j];
        if (prod < limit) then
        begin
          if countOnly then
          begin
            count := count + 1;
          end else
          begin
            brilliant := specialize _appendList<Variant>(brilliant, prod);
          end;
        end else
        begin
          if (prod < next) then ;
          break;
        end;
        j := j + 1;
      end;
      i := i + 1;
    end;
    pow := pow * 10;
    k := k + 1;
  end;
  if countOnly then ;
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('bc', brilliant);
  _tmp1.AddOrSetData('next', next);
  result := _tmp1;
  exit;
end;

function main(): integer;
var
  br: Variant;
  climit: Variant;
  cnext: Variant;
  ctotal: Variant;
  i: Variant;
  k: integer;
  limit: Variant;
  next: Variant;
  r: Variant;
  r2: Variant;
  total: Variant;
begin
  writeln('First 100 brilliant numbers:');
  r := getBrilliant(2, 10000, False);
  br := sortInts(r['bc']);
  br := Copy(br, 1, 100 - 0);
  i := 0;
  while (i < Length(br)) do
  begin
    writeln(IntToStr(br[i]).padStart(4, ' ') + ' ', ' ', False);
    if (i + 1 mod 10 = 0) then ;
    i := i + 1;
  end;
  writeln('', ' ', True);
  k := 1;
  while (k <= 13) do
  begin
    limit := pow(10, k);
    r2 := getBrilliant(k, limit, True);
    total := r2['bc'];
    next := r2['next'];
    climit := commatize(limit);
    ctotal := commatize(total + 1);
    cnext := commatize(next);
    writeln('First >= ' + climit.padStart(18, ' ') + ' is ' + ctotal.padStart(14, ' ') + ' in the series: ' + cnext.padStart(18, ' '));
    k := k + 1;
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

var
  primes: specialize TArray<integer>;

begin
  primes := primesUpTo(3200000);
end.
