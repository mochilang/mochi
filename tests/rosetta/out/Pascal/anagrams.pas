// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:06Z
program Anagrams;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function sortRunes(s: string): string;
var
  arr: specialize TArray<string>;
  i: integer;
  j: integer;
  m: integer;
  n: Variant;
  out: string;
  tmp: specialize TArray<string>;
begin
  arr := specialize TArray<string>([]);
  i := 0;
  while (i < Length(s)) do
  begin
    arr := specialize _appendList<Variant>(arr, _sliceString(s, i, i + 1));
    i := i + 1;
  end;
  n := Length(arr);
  m := 0;
  while (m < n) do
  begin
    j := 0;
    while (j < n - 1) do
    begin
      if (arr[j] > arr[j + 1]) then
      begin
        tmp := arr[j];
        arr[j] := arr[j + 1];
        arr[j + 1] := tmp;
      end;
      j := j + 1;
    end;
    m := m + 1;
  end;
  out := '';
  i := 0;
  while (i < n) do
  begin
    out := out + arr[i];
    i := i + 1;
  end;
  result := out;
  exit;
end;

function sortStrings(xs: specialize TArray<string>): specialize TArray<string>;
var
  i: integer;
  idx: integer;
  j: integer;
  min: function(p0: Variant): Variant is nested;
  out: string;
  res: specialize TArray<string>;
  tmp: specialize TArray<string>;
begin
  res := specialize TArray<string>([]);
  tmp := xs;
  while (Length(tmp) > 0) do
  begin
    min := specialize _indexList<string>(tmp, 0);
    idx := 0;
    i := 1;
    while (i < Length(tmp)) do
    begin
      if (specialize _indexList<string>(tmp, i) < min) then
      begin
        min := specialize _indexList<string>(tmp, i);
        idx := i;
      end;
      i := i + 1;
    end;
    res := specialize _appendList<Variant>(res, min);
    out := specialize TArray<integer>([]);
    j := 0;
    while (j < Length(tmp)) do
    begin
      if (j <> idx) then ;
      j := j + 1;
    end;
    tmp := out;
  end;
  result := res;
  exit;
end;

function main(): integer;
var
  _tmp0: specialize TFPGMap<string, integer>;
  _tmp1: specialize TFPGMap<string, integer>;
  g: Variant;
  groups: specialize TFPGMap<string, specialize TArray<string>>;
  i: integer;
  k: Variant;
  line: string;
  maxLen: integer;
  printed: specialize TFPGMap<string, boolean>;
  words: specialize TArray<Variant>;
begin
  words := specialize TArray<string>(['abel', 'able', 'bale', 'bela', 'elba', 'alger', 'glare', 'lager', 'large', 'regal', 'angel', 'angle', 'galen', 'glean', 'lange', 'caret', 'carte', 'cater', 'crate', 'trace', 'elan', 'lane', 'lean', 'lena', 'neal', 'evil', 'levi', 'live', 'veil', 'vile']);
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  groups := _tmp0;
  maxLen := 0;
  for w in words do
  begin
    k := sortRunes(w);
    if not (k in groups) then
    begin
      groups[k] := specialize TArray<integer>([w]);
    end else
    begin
      groups[k] := specialize _appendList<Variant>(groups[k], w);
    end;
    if (Length(groups[k]) > maxLen) then ;
  end;
  _tmp1 := specialize TFPGMap<string, integer>.Create;
  printed := _tmp1;
  for w in words do
  begin
    k := sortRunes(w);
    if (Length(groups[k]) = maxLen) then ;
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
