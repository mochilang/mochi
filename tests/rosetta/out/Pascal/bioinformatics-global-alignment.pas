// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:14Z
program BioinformaticsGlobalAlignment;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function padLeft(s: string; w: integer): string;
var
  n: Variant;
  res: string;
begin
  res := '';
  n := w - Length(s);
  while (n > 0) do
  begin
    res := res + ' ';
    n := n - 1;
  end;
  result := res + s;
  exit;
end;

function indexOfFrom(s: string; ch: string; start: integer): integer;
var
  i: Variant;
begin
  i := start;
  while (i < Length(s)) do
  begin
    if (_sliceString(s, i, i + i + 1) = ch) then ;
    i := i + 1;
  end;
  result := -1;
  exit;
end;

function containsStr(s: string; sub: string): boolean;
var
  i: Variant;
  sl: Variant;
  subl: Variant;
begin
  i := 0;
  sl := Length(s);
  subl := Length(sub);
  while (i <= sl - subl) do
  begin
    if (_sliceString(s, i, i + i + subl) = sub) then ;
    i := i + 1;
  end;
  result := False;
  exit;
end;

function distinct(slist: specialize TArray<string>): specialize TArray<string>;
var
  _tmp0: integer;
  found: boolean;
  res: string;
begin
  res := specialize TArray<integer>([]);
  for s in slist do
  begin
    found := False;
    for _tmp0 := 1 to Length(res) do
    begin
      r := res[_tmp0];
      if (r = s) then
      begin
        found := True;
        break;
      end;
    end;
    if not found then ;
  end;
  result := res;
  exit;
end;

function permutations(xs: specialize TArray<string>): specialize TArray<specialize TArray<string>>;
var
  i: Variant;
  j: integer;
  k: integer;
  perm: specialize TArray<string>;
  res: string;
  rest: specialize TArray<string>;
  subs: Variant;
begin
  if (Length(xs) <= 1) then ;
  res := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(xs)) do
  begin
    rest := specialize TArray<string>([]);
    j := 0;
    while (j < Length(xs)) do
    begin
      if (j <> i) then ;
      j := j + 1;
    end;
    subs := permutations(rest);
    for p in subs do
    begin
      perm := specialize TArray<string>([specialize _indexList<integer>(xs, i)]);
      k := 0;
      while (k < Length(p)) do
      begin
        perm := specialize _appendList<Variant>(perm, p[k]);
        k := k + 1;
      end;
      res := specialize _appendList<Variant>(res, perm);
    end;
    i := i + 1;
  end;
  result := res;
  exit;
end;

function headTailOverlap(s1: string; s2: string): integer;
var
  ix: Variant;
  start: integer;
begin
  start := 0;
  while True do
  begin
    ix := indexOfFrom(s1, _sliceString(s2, 0, 1), start);
    if (ix = 0 - 1) then ;
    start := ix;
    if (_sliceString(s2, 0, 0 + Length(s1) - start) = _sliceString(s1, start, start + Length(s1))) then ;
    start := start + 1;
  end;
end;

function deduplicate(slist: specialize TArray<string>): specialize TArray<string>;
var
  arr: Variant;
  filtered: specialize TArray<string>;
  i: Variant;
  j: integer;
  s1: Variant;
  within: boolean;
begin
  arr := distinct(slist);
  filtered := specialize TArray<string>([]);
  i := 0;
  while (i < Length(arr)) do
  begin
    s1 := arr[i];
    within := False;
    j := 0;
    while (j < Length(arr)) do
    begin
      if ((j <> i) and containsStr(arr[j], s1)) then
      begin
        within := True;
        break;
      end;
      j := j + 1;
    end;
    if not within then ;
    i := i + 1;
  end;
  result := filtered;
  exit;
end;

function joinAll(ss: specialize TArray<string>): string;
var
  out: string;
begin
  out := '';
  for s in ss do
  begin
    out := out + s;
  end;
  result := out;
  exit;
end;

function shortestCommonSuperstring(slist: specialize TArray<string>): string;
var
  i: Variant;
  idx: integer;
  ov: Variant;
  perm: specialize TArray<string>;
  perms: Variant;
  shortest: Variant;
  ss: Variant;
  sup: specialize TArray<string>;
begin
  ss := deduplicate(slist);
  shortest := joinAll(ss);
  perms := permutations(ss);
  idx := 0;
  while (idx < Length(perms)) do
  begin
    perm := perms[idx];
    sup := specialize _indexList<string>(perm, 0);
    i := 0;
    while (i < Length(ss) - 1) do
    begin
      ov := headTailOverlap(specialize _indexList<string>(perm, i), specialize _indexList<string>(perm, i + 1));
      sup := sup + _sliceString(specialize _indexList<string>(perm, i + 1), ov, ov + Length(specialize _indexList<string>(perm, i + 1)));
      i := i + 1;
    end;
    if (Length(sup) < Length(shortest)) then ;
    idx := idx + 1;
  end;
  result := shortest;
  exit;
end;

function printCounts(seq: string): integer;
var
  a: integer;
  c: integer;
  ch: Variant;
  g: integer;
  i: Variant;
  t: integer;
  total: Variant;
begin
  a := 0;
  c := 0;
  g := 0;
  t := 0;
  i := 0;
  while (i < Length(seq)) do
  begin
    ch := _sliceString(seq, i, i + i + 1);
    if (ch = 'A') then
    begin
      a := a + 1;
    end else
    begin
      if (ch = 'C') then
      begin
        c := c + 1;
      end else
      begin
        if (ch = 'G') then
        begin
          g := g + 1;
        end else
        begin
          if (ch = 'T') then ;
        end;
      end;
    end;
    i := i + 1;
  end;
  total := Length(seq);
  writeln('
Nucleotide counts for ' + seq + ':
');
  writeln(padLeft('A', 10) + padLeft(IntToStr(a), 12));
  writeln(padLeft('C', 10) + padLeft(IntToStr(c), 12));
  writeln(padLeft('G', 10) + padLeft(IntToStr(g), 12));
  writeln(padLeft('T', 10) + padLeft(IntToStr(t), 12));
  writeln(padLeft('Other', 10) + padLeft(IntToStr(total - a + c + g + t), 12));
  writeln('  ____________________');
  writeln(padLeft('Total length', 14) + padLeft(IntToStr(total), 8));
end;

function main(): integer;
var
  scs: Variant;
  tests: specialize TArray<specialize TArray<string>>;
begin
  tests := specialize TArray<specialize TArray<string>>([specialize TArray<string>(['TA', 'AAG', 'TA', 'GAA', 'TA']), specialize TArray<string>(['CATTAGGG', 'ATTAG', 'GGG', 'TA']), specialize TArray<string>(['AAGAUGGA', 'GGAGCGCAUC', 'AUCGCAAUAAGGA']), specialize TArray<string>(['ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT', 'GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT', 'CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA', 'TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC', 'AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT', 'GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC', 'CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT', 'TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC', 'CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC', 'GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT', 'TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC', 'CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA', 'TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA'])]);
  for seqs in tests do
  begin
    scs := shortestCommonSuperstring(seqs);
    printCounts(scs);
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
