// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program _048;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _now(): int64;
begin
  Result := Trunc(Now * 86400000000000.0);
end;


var
  SIZE: integer;
  board: specialize TArray<specialize TArray<integer>>;
  cmd: Variant;
  full: specialize TFPGMap<string, Variant>;
  m: Variant;
  moved: boolean;
  r: specialize TFPGMap<string, Variant>;
  r2: Variant;
  score: integer;

function newBoard(): specialize TArray<specialize TArray<integer>>;
var
  b: specialize TArray<specialize TArray<integer>>;
  row: specialize TArray<integer>;
  x: integer;
  y: integer;
begin
  b := specialize TArray<specialize TArray<integer>>([]);
  y := 0;
  while (y < SIZE) do
  begin
    row := specialize TArray<integer>([]);
    x := 0;
    while (x < SIZE) do
    begin
      row := specialize _appendList<integer>(row, 0);
      x := x + 1;
    end;
    b := specialize _appendList<specialize TArray<integer>>(b, row);
    y := y + 1;
  end;
  result := b;
  exit;
end;

function spawnTile(b: specialize TArray<specialize TArray<integer>>): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
  _tmp1: specialize TFPGMap<string, Variant>;
  cell: specialize TArray<specialize TArray<integer>>;
  empty: specialize TArray<specialize TArray<integer>>;
  idx: Variant;
  val: integer;
  x: integer;
  y: integer;
begin
  empty := specialize TArray<specialize TArray<integer>>([]);
  y := 0;
  while (y < SIZE) do
  begin
    x := 0;
    while (x < SIZE) do
    begin
      if (specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x) = 0) then ;
      x := x + 1;
    end;
    y := y + 1;
  end;
  if (Length(empty) = 0) then ;
  idx := _now() mod Length(empty);
  cell := specialize _indexList<specialize TArray<integer>>(empty, idx);
  val := 4;
  if (_now() mod 10 < 9) then ;
  b[specialize _indexList<specialize TArray<integer>>(cell, 1)][specialize _indexList<specialize TArray<integer>>(cell, 0)] := val;
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('board', b);
  _tmp1.AddOrSetData('full', (Length(empty) = 1));
  result := _tmp1;
  exit;
end;

function pad(n: integer): string;
var
  i: integer;
  out: string;
  pad: function(p0: integer): string is nested;
  s: Variant;
begin
  s := IntToStr(n);
  pad := 4 - Length(s);
  i := 0;
  out := '';
  while (i < pad) do
  begin
    out := out + ' ';
    i := i + 1;
  end;
  result := out + s;
  exit;
end;

procedure draw(b: specialize TArray<specialize TArray<integer>>; score: integer);
var
  line: string;
  v: specialize TArray<specialize TArray<integer>>;
  x: integer;
  y: integer;
begin
  writeln('Score: ' + IntToStr(score));
  y := 0;
  while (y < SIZE) do
  begin
    writeln('+----+----+----+----+');
    line := '|';
    x := 0;
    while (x < SIZE) do
    begin
      v := specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x);
      if (v = 0) then
      begin
        line := line + '    |';
      end else
      begin
        line := line + pad(v) + '|';
      end;
      x := x + 1;
    end;
    writeln(line);
    y := y + 1;
  end;
  writeln('+----+----+----+----+');
  writeln('W=Up S=Down A=Left D=Right Q=Quit');
end;

function reverseRow(r: specialize TArray<integer>): specialize TArray<integer>;
var
  i: Variant;
  out: specialize TArray<integer>;
begin
  out := specialize TArray<integer>([]);
  i := r.Count - 1;
  while (i >= 0) do
  begin
    out := specialize _appendList<integer>(out, r.KeyData[i]);
    i := i - 1;
  end;
  result := out;
  exit;
end;

function slideLeft(row: specialize TArray<integer>): specialize TFPGMap<string, any>;
var
  _tmp2: specialize TFPGMap<string, Variant>;
  gain: integer;
  i: integer;
  res: specialize TArray<integer>;
  v: specialize TArray<specialize TArray<integer>>;
  xs: specialize TArray<integer>;
begin
  xs := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(row)) do
  begin
    if (specialize _indexList<integer>(row, i) <> 0) then ;
    i := i + 1;
  end;
  res := specialize TArray<integer>([]);
  gain := 0;
  i := 0;
  while (i < Length(xs)) do
  begin
    if ((i + 1 < Length(xs)) and (specialize _indexList<integer>(xs, i) = specialize _indexList<integer>(xs, i + 1))) then
    begin
      v := specialize _indexList<integer>(xs, i) * 2;
      gain := Concat(gain, v);
      res := specialize _appendList<integer>(res, v);
      i := i + 2;
    end else
    begin
      res := specialize _appendList<integer>(res, specialize _indexList<integer>(xs, i));
      i := i + 1;
    end;
  end;
  while (Length(res) < SIZE) do
  begin
    res := specialize _appendList<integer>(res, 0);
  end;
  _tmp2 := specialize TFPGMap<string, Variant>.Create;
  _tmp2.AddOrSetData('row', res);
  _tmp2.AddOrSetData('gain', gain);
  result := _tmp2;
  exit;
end;

function moveLeft(b: specialize TArray<specialize TArray<integer>>; score: integer): specialize TFPGMap<string, any>;
var
  _tmp3: specialize TFPGMap<string, Variant>;
  moved: boolean;
  new: specialize TFPGMap<string, Variant>;
  r: specialize TFPGMap<string, Variant>;
  x: integer;
  y: integer;
begin
  moved := False;
  y := 0;
  while (y < SIZE) do
  begin
    r := slideLeft(specialize _indexList<specialize TArray<integer>>(b, y));
    new := r.KeyData['row'];
    score := score + r.KeyData['gain'];
    x := 0;
    while (x < SIZE) do
    begin
      if (specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x) <> new.KeyData[x]) then ;
      b[y][x] := new.KeyData[x];
      x := x + 1;
    end;
    y := y + 1;
  end;
  _tmp3 := specialize TFPGMap<string, Variant>.Create;
  _tmp3.AddOrSetData('board', b);
  _tmp3.AddOrSetData('score', score);
  _tmp3.AddOrSetData('moved', moved);
  result := _tmp3;
  exit;
end;

function moveRight(b: specialize TArray<specialize TArray<integer>>; score: integer): specialize TFPGMap<string, any>;
var
  _tmp4: specialize TFPGMap<string, Variant>;
  moved: boolean;
  r: specialize TFPGMap<string, Variant>;
  rev: Variant;
  x: integer;
  y: integer;
begin
  moved := False;
  y := 0;
  while (y < SIZE) do
  begin
    rev := reverseRow(specialize _indexList<specialize TArray<integer>>(b, y));
    r := slideLeft(rev);
    rev := r.KeyData['row'];
    score := score + r.KeyData['gain'];
    rev := reverseRow(rev);
    x := 0;
    while (x < SIZE) do
    begin
      if (specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x) <> rev[x]) then ;
      b[y][x] := rev[x];
      x := x + 1;
    end;
    y := y + 1;
  end;
  _tmp4 := specialize TFPGMap<string, Variant>.Create;
  _tmp4.AddOrSetData('board', b);
  _tmp4.AddOrSetData('score', score);
  _tmp4.AddOrSetData('moved', moved);
  result := _tmp4;
  exit;
end;

function getCol(b: specialize TArray<specialize TArray<integer>>; x: integer): specialize TArray<integer>;
var
  col: specialize TArray<integer>;
  y: integer;
begin
  col := specialize TArray<integer>([]);
  y := 0;
  while (y < SIZE) do
  begin
    col := specialize _appendList<integer>(col, specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x));
    y := y + 1;
  end;
  result := col;
  exit;
end;

procedure setCol(b: specialize TArray<specialize TArray<integer>>; x: integer; col: specialize TArray<integer>);
var
  y: integer;
begin
  y := 0;
  while (y < SIZE) do
  begin
    b[y][x] := specialize _indexList<integer>(col, y);
    y := y + 1;
  end;
end;

function moveUp(b: specialize TArray<specialize TArray<integer>>; score: integer): specialize TFPGMap<string, any>;
var
  _tmp5: specialize TFPGMap<string, Variant>;
  col: specialize TArray<integer>;
  moved: boolean;
  new: specialize TFPGMap<string, Variant>;
  r: specialize TFPGMap<string, Variant>;
  x: integer;
  y: integer;
begin
  moved := False;
  x := 0;
  while (x < SIZE) do
  begin
    col := getCol(b, x);
    r := slideLeft(col);
    new := r.KeyData['row'];
    score := score + r.KeyData['gain'];
    y := 0;
    while (y < SIZE) do
    begin
      if (specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x) <> new.KeyData[y]) then ;
      b[y][x] := new.KeyData[y];
      y := y + 1;
    end;
    x := x + 1;
  end;
  _tmp5 := specialize TFPGMap<string, Variant>.Create;
  _tmp5.AddOrSetData('board', b);
  _tmp5.AddOrSetData('score', score);
  _tmp5.AddOrSetData('moved', moved);
  result := _tmp5;
  exit;
end;

function moveDown(b: specialize TArray<specialize TArray<integer>>; score: integer): specialize TFPGMap<string, any>;
var
  _tmp6: specialize TFPGMap<string, Variant>;
  col: specialize TArray<integer>;
  moved: boolean;
  r: specialize TFPGMap<string, Variant>;
  x: integer;
  y: integer;
begin
  moved := False;
  x := 0;
  while (x < SIZE) do
  begin
    col := reverseRow(getCol(b, x));
    r := slideLeft(col);
    col := r.KeyData['row'];
    score := score + r.KeyData['gain'];
    col := reverseRow(col);
    y := 0;
    while (y < SIZE) do
    begin
      if (specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x) <> specialize _indexList<integer>(col, y)) then ;
      b[y][x] := specialize _indexList<integer>(col, y);
      y := y + 1;
    end;
    x := x + 1;
  end;
  _tmp6 := specialize TFPGMap<string, Variant>.Create;
  _tmp6.AddOrSetData('board', b);
  _tmp6.AddOrSetData('score', score);
  _tmp6.AddOrSetData('moved', moved);
  result := _tmp6;
  exit;
end;

function hasMoves(b: specialize TArray<specialize TArray<integer>>): boolean;
var
  x: integer;
  y: integer;
begin
  y := 0;
  while (y < SIZE) do
  begin
    x := 0;
    while (x < SIZE) do
    begin
      if (specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x) = 0) then ;
      if ((x + 1 < SIZE) and (specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x) = specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x + 1))) then ;
      if ((y + 1 < SIZE) and (specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x) = specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y + 1), x))) then ;
      x := x + 1;
    end;
    y := y + 1;
  end;
  result := False;
  exit;
end;

function has2048(b: specialize TArray<specialize TArray<integer>>): boolean;
var
  x: integer;
  y: integer;
begin
  y := 0;
  while (y < SIZE) do
  begin
    x := 0;
    while (x < SIZE) do
    begin
      if (specialize _indexList<specialize TArray<integer>>(specialize _indexList<specialize TArray<integer>>(b, y), x) >= 2048) then ;
      x := x + 1;
    end;
    y := y + 1;
  end;
  result := False;
  exit;
end;

begin
  SIZE := 4;
  board := newBoard();
  r := spawnTile(board);
  board := r.KeyData['board'];
  full := r.KeyData['full'];
  r := spawnTile(board);
  board := r.KeyData['board'];
  full := r.KeyData['full'];
  score := 0;
  draw(board, score);
  while True do
  begin
    writeln('Move: ');
    cmd := input();
    moved := False;
    if ((cmd = 'a') or (cmd = 'A')) then
    begin
      m := moveLeft(board, score);
      board := m['board'];
      score := m['score'];
      moved := m['moved'];
    end;
    if ((cmd = 'd') or (cmd = 'D')) then
    begin
      m := moveRight(board, score);
      board := m['board'];
      score := m['score'];
      moved := m['moved'];
    end;
    if ((cmd = 'w') or (cmd = 'W')) then
    begin
      m := moveUp(board, score);
      board := m['board'];
      score := m['score'];
      moved := m['moved'];
    end;
    if ((cmd = 's') or (cmd = 'S')) then
    begin
      m := moveDown(board, score);
      board := m['board'];
      score := m['score'];
      moved := m['moved'];
    end;
    if ((cmd = 'q') or (cmd = 'Q')) then ;
    if moved then
    begin
      r2 := spawnTile(board);
      board := r2['board'];
      full := r2['full'];
      if (full and not hasMoves(board)) then
      begin
        draw(board, score);
        writeln('Game Over');
        break;
      end;
    end;
    draw(board, score);
    if has2048(board) then
    begin
      writeln('You win!');
      break;
    end;
    if not hasMoves(board) then
    begin
      writeln('Game Over');
      break;
    end;
  end;
end.
