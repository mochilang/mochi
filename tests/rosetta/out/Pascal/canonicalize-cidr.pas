// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:19Z
program CanonicalizeCidr;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function split(s: string; sep: string): specialize TArray<string>;
var
  cur: string;
  i: integer;
  parts: specialize TArray<string>;
begin
  parts := specialize TArray<string>([]);
  cur := '';
  i := 0;
  while (i < Length(s)) do
  begin
    if (((Length(sep) > 0) and (i + Length(sep) <= Length(s))) and (_sliceString(s, i, i + i + Length(sep)) = sep)) then
    begin
      parts := specialize _appendList<Variant>(parts, cur);
      cur := '';
      i := i + Length(sep);
    end else
    begin
      cur := cur + _sliceString(s, i, i + 1);
      i := i + 1;
    end;
  end;
  parts := specialize _appendList<Variant>(parts, cur);
  result := parts;
  exit;
end;

function join(xs: specialize TArray<string>; sep: string): string;
var
  i: integer;
  res: string;
begin
  res := '';
  i := 0;
  while (i < Length(xs)) do
  begin
    if (i > 0) then ;
    res := res + specialize _indexList<integer>(xs, i);
    i := i + 1;
  end;
  result := res;
  exit;
end;

function _repeat(ch: string; n: integer): string;
var
  i: integer;
  out: string;
begin
  out := '';
  i := 0;
  while (i < n) do
  begin
    out := out + ch;
    i := i + 1;
  end;
  result := out;
  exit;
end;

function parseIntStr(str: string): integer;
var
  _tmp0: specialize TFPGMap<string, integer>;
  digits: specialize TFPGMap<Variant, Variant>;
  i: integer;
  n: integer;
  neg: boolean;
begin
  i := 0;
  neg := False;
  if ((Length(str) > 0) and (_sliceString(str, 0, 1) = '-')) then
  begin
    neg := True;
    i := 1;
  end;
  n := 0;
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  _tmp0.AddOrSetData('0', 0);
  _tmp0.AddOrSetData('1', 1);
  _tmp0.AddOrSetData('2', 2);
  _tmp0.AddOrSetData('3', 3);
  _tmp0.AddOrSetData('4', 4);
  _tmp0.AddOrSetData('5', 5);
  _tmp0.AddOrSetData('6', 6);
  _tmp0.AddOrSetData('7', 7);
  _tmp0.AddOrSetData('8', 8);
  _tmp0.AddOrSetData('9', 9);
  digits := _tmp0;
  while (i < Length(str)) do
  begin
    n := n * 10 + digits[_sliceString(str, i, i + 1)];
    i := i + 1;
  end;
  if neg then ;
  result := n;
  exit;
end;

function toBinary(n: integer; bits: integer): string;
var
  b: string;
  i: integer;
  val: integer;
begin
  b := '';
  val := n;
  i := 0;
  while (i < bits) do
  begin
    b := IntToStr(val mod 2) + b;
    val := Trunc(val div 2);
    i := i + 1;
  end;
  result := b;
  exit;
end;

function binToInt(bits: string): integer;
var
  i: integer;
  n: integer;
begin
  n := 0;
  i := 0;
  while (i < Length(bits)) do
  begin
    n := n * 2 + parseIntStr(_sliceString(bits, i, i + 1));
    i := i + 1;
  end;
  result := n;
  exit;
end;

function padRight(s: string; width: integer): string;
var
  out: string;
begin
  out := s;
  while (Length(out) < width) do
  begin
    out := out + ' ';
  end;
  result := out;
  exit;
end;

function canonicalize(cidr: string): string;
var
  binParts: specialize TArray<string>;
  binary: Variant;
  canonParts: specialize TArray<string>;
  dotted: specialize TArray<string>;
  i: integer;
  parts: specialize TArray<string>;
  size: Variant;
begin
  parts := _splitString(cidr, '/');
  dotted := specialize _indexList<string>(parts, 0);
  size := parseIntStr(specialize _indexList<string>(parts, 1));
  binParts := specialize TArray<string>([]);
  for p in _splitString(dotted, '.') do
  begin
    binParts := specialize _appendList<Variant>(binParts, toBinary(parseIntStr(p), 8));
  end;
  binary := _joinStrings(binParts, '');
  binary := Copy(binary, 1, size - 0) + _repeat('0', 32 - size);
  canonParts := specialize TArray<string>([]);
  i := 0;
  while (i < Length(binary)) do
  begin
    canonParts := specialize _appendList<Variant>(canonParts, IntToStr(binToInt(Copy(binary, i + 1, i + 8 - i))));
    i := i + 8;
  end;
  result := _joinStrings(canonParts, '.') + '/' + specialize _indexList<string>(parts, 1);
  exit;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _joinStrings(parts: specialize TArray<string>; sep: string): string;
var i: Integer;
begin
  Result := '';
  for i := 0 to High(parts) do
  begin
    if i > 0 then Result := Result + sep;
    Result := Result + parts[i];
  end;
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

function _splitString(s, sep: string): specialize TArray<string>;
var sl: TStringList; i: Integer;
begin
  sl := TStringList.Create;
  try
    sl.Delimiter := sep[1];
    sl.StrictDelimiter := True;
    sl.DelimitedText := s;
    SetLength(Result, sl.Count);
    for i := 0 to sl.Count - 1 do
      Result[i] := sl[i];
  finally
    sl.Free;
  end;
end;

var
  t: string;
  tests: specialize TArray<string>;

begin
  tests := specialize TArray<string>(['87.70.141.1/22', '36.18.154.103/12', '62.62.197.11/29', '67.137.119.181/4', '161.214.74.21/24', '184.232.176.184/18']);
  for t in tests do
  begin
    writeln(padRight(t, 18) + ' -> ' + canonicalize(t));
  end;
end.
