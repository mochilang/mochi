// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:06Z
program AliquotSequenceClassifications;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function indexOf(xs: specialize TArray<integer>; value: integer): integer;
var
  i: integer;
begin
  i := 0;
  while (i < Length(xs)) do
  begin
    if (specialize _indexList<integer>(xs, i) = value) then ;
    i := i + 1;
  end;
  result := 0 - 1;
  exit;
end;

function contains(xs: specialize TArray<integer>; value: integer): boolean;
begin
  result := (indexOf(xs, value) <> 0 - 1);
  exit;
end;

function maxOf(a: integer; b: integer): integer;
begin
  if (a > b) then
  begin
    result := a;
    exit;
  end else
  begin
    result := b;
    exit;
  end;
end;

function intSqrt(n: integer): integer;
var
  x: Variant;
  y: Variant;
begin
  if (n = 0) then ;
  x := n;
  y := x + 1 div 2;
  while (y < x) do
  begin
    x := y;
    y := x + n div x div 2;
  end;
  result := x;
  exit;
end;

function sumProperDivisors(n: integer): integer;
var
  i: integer;
  sqrt: Variant;
  sum: function(p0: Variant): double is nested;
begin
  if (n < 2) then ;
  sqrt := intSqrt(n);
  sum := 1;
  i := 2;
  while (i <= sqrt) do
  begin
    if (n mod i = 0) then ;
    i := i + 1;
  end;
  if (sqrt * sqrt = n) then ;
  result := sum;
  exit;
end;

function classifySequence(k: integer): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
  _tmp1: specialize TFPGMap<string, Variant>;
  aliquot: string;
  idx: Variant;
  last: Variant;
  n: Variant;
  seq: specialize TArray<integer>;
begin
  last := k;
  seq := specialize TArray<integer>([k]);
  while True do
  begin
    last := sumProperDivisors(last);
    seq := specialize _appendList<Variant>(seq, last);
    n := Length(seq);
    aliquot := '';
    if (last = 0) then
    begin
      aliquot := 'Terminating';
    end else if ((n = 2) and (last = k)) then
    begin
      aliquot := 'Perfect';
    end else if ((n = 3) and (last = k)) then
    begin
      aliquot := 'Amicable';
    end else if ((n >= 4) and (last = k)) then
    begin
      aliquot := 'Sociable[' + IntToStr(n - 1) + ']';
    end else if (last = seq[n - 2]) then
    begin
      aliquot := 'Aspiring';
    end else if (Pos(last, Copy(seq, 1 + 1, maxOf(1, n - 2) - 1)) > 0) then
    begin
      idx := indexOf(seq, last);
      aliquot := 'Cyclic[' + IntToStr(n - 1 - idx) + ']';
    end else if ((n = 16) or (last > THRESHOLD)) then
    begin
      aliquot := 'Non-Terminating';
    end;
    if (aliquot <> '') then ;
  end;
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('seq', seq);
  _tmp1.AddOrSetData('aliquot', '');
  result := _tmp1;
  exit;
end;

function padLeft(n: integer; w: integer): string;
var
  s: Variant;
begin
  s := IntToStr(n);
  while (Length(s) < w) do
  begin
    s := ' ' + s;
  end;
  result := s;
  exit;
end;

function padRight(s: string; w: integer): string;
var
  r: Variant;
begin
  r := s;
  while (Length(r) < w) do
  begin
    r := r + ' ';
  end;
  result := r;
  exit;
end;

function joinWithCommas(seq: specialize TArray<integer>): string;
var
  i: integer;
  s: Variant;
begin
  s := '[';
  i := 0;
  while (i < Length(seq)) do
  begin
    s := s + IntToStr(specialize _indexList<integer>(seq, i));
    if (i < Length(seq) - 1) then ;
    i := i + 1;
  end;
  s := s + ']';
  result := s;
  exit;
end;

function main(): integer;
var
  big: integer;
  i: integer;
  k: integer;
  r: Variant;
  res: Variant;
  s: Variant;
  val: Variant;
begin
  writeln('Aliquot classifications - periods for Sociable/Cyclic in square brackets:
');
  k := 1;
  while (k <= 10) do
  begin
    res := classifySequence(k);
    writeln(padLeft(k, 2) + ': ' + padRight(Trunc(res['aliquot']), 15) + ' ' + joinWithCommas(Trunc(res['seq'])));
    k := k + 1;
  end;
  writeln('');
  s := specialize TArray<integer>([11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]);
  i := 0;
  while (i < Length(s)) do
  begin
    val := s[i];
    res := classifySequence(val);
    writeln(padLeft(val, 7) + ': ' + padRight(Trunc(res['aliquot']), 15) + ' ' + joinWithCommas(Trunc(res['seq'])));
    i := i + 1;
  end;
  writeln('');
  big := 15355717786080;
  r := classifySequence(big);
  writeln(IntToStr(big) + ': ' + padRight(Trunc(r['aliquot']), 15) + ' ' + joinWithCommas(Trunc(r['seq'])));
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

var
  THRESHOLD: integer;

begin
  THRESHOLD := 140737488355328;
  main();
end.
