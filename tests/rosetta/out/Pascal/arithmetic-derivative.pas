// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program ArithmeticDerivative;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;


function primeFactors(n: integer): specialize TArray<integer>;
var
  factors: specialize TArray<Variant>;
  p: integer;
  x: Variant;
begin
  factors := specialize TArray<Variant>([]);
  x := n;
  while (x mod 2 = 0) do
  begin
    factors := specialize _appendList<Variant>(factors, 2);
    x := Trunc(x div 2);
  end;
  p := 3;
  while (p * p <= x) do
  begin
    while (x mod p = 0) do
    begin
      factors := specialize _appendList<Variant>(factors, p);
      x := Trunc(x div p);
    end;
    p := p + 2;
  end;
  if (x > 1) then ;
  result := factors;
  exit;
end;

function _repeat(ch: string; n: integer): string;
var
  i: integer;
  s: string;
begin
  s := '';
  i := 0;
  while (i < n) do
  begin
    s := s + ch;
    i := i + 1;
  end;
  result := s;
  exit;
end;

function D(n: double): double;
var
  c: Variant;
  d: Variant;
  factors: specialize TArray<Variant>;
  g: integer;
begin
  if (n < 0) then ;
  if (n < 2) then ;
  factors := specialize TArray<Variant>([]);
  if (n < 1e+19) then
  begin
    factors := primeFactors(Trunc(n));
  end else
  begin
    g := Trunc(n div 100);
    factors := primeFactors(g);
    factors := specialize _appendList<Variant>(factors, 2);
    factors := specialize _appendList<Variant>(factors, 2);
    factors := specialize _appendList<Variant>(factors, 5);
    factors := specialize _appendList<Variant>(factors, 5);
  end;
  c := Length(factors);
  if (c = 1) then ;
  if (c = 2) then ;
  d := n / Double(specialize _indexList<Variant>(factors, 0));
  result := D(d) * Double(specialize _indexList<Variant>(factors, 0)) + d;
  exit;
end;

function pad(n: integer): string;
var
  s: string;
begin
  s := IntToStr(n);
  while (Length(s) < 4) do
  begin
    s := ' ' + s;
  end;
  result := s;
  exit;
end;

procedure main();
var
  exp: Variant;
  i: integer;
  j: integer;
  line: string;
  m: integer;
  n: integer;
  pow: double;
  res: Variant;
  vals: specialize TArray<Variant>;
begin
  vals := specialize TArray<Variant>([]);
  n := -99;
  while (n < 101) do
  begin
    vals := specialize _appendList<Variant>(vals, Trunc(D(Double(n))));
    n := n + 1;
  end;
  i := 0;
  while (i < Length(vals)) do
  begin
    line := '';
    j := 0;
    while (j < 10) do
    begin
      line := line + pad(specialize _indexList<Variant>(vals, i + j));
      if (j < 9) then ;
      j := j + 1;
    end;
    writeln(line);
    i := i + 10;
  end;
  pow := 1;
  m := 1;
  while (m < 21) do
  begin
    pow := pow * 10;
    exp := IntToStr(m);
    if (Length(exp) < 2) then ;
    res := IntToStr(m) + _repeat('0', m - 1);
    writeln('D(10^' + exp + ') / 7 = ' + res);
    m := m + 1;
  end;
end;

begin
  main();
end.
