// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:17Z
program BurrowsWheelerTransform;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function contains(s: string; ch: string): boolean;
var
  i: integer;
begin
  i := 0;
  while (i < Length(s)) do
  begin
    if (_sliceString(s, i, i + i + 1) = ch) then ;
    i := i + 1;
  end;
  result := False;
  exit;
end;

function sortStrings(xs: specialize TArray<string>): specialize TArray<string>;
var
  arr: Variant;
  i: integer;
  j: integer;
  n: Variant;
  tmp: Variant;
begin
  arr := xs;
  n := Length(arr);
  i := 0;
  while (i < n) do
  begin
    j := 0;
    while (j < n - 1) do
    begin
      if (arr[j] > arr[j + 1]) then
      begin
        tmp := arr[j];
        arr[j] := arr[j + 1];
        arr[j + 1] := tmp;
      end;
      j := j + 1;
    end;
    i := i + 1;
  end;
  result := arr;
  exit;
end;

function bwt(s: string): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
  _tmp1: specialize TFPGMap<string, Variant>;
  i: integer;
  last: string;
  le: Variant;
  rot: Variant;
  table: specialize TArray<string>;
begin
  if ((Pos(stx, s) > 0) or (Pos(etx, s) > 0)) then ;
  s := stx + s + etx;
  le := Length(s);
  table := specialize TArray<string>([]);
  i := 0;
  while (i < le) do
  begin
    rot := _sliceString(s, i, i + le) + _sliceString(s, 0, 0 + i);
    table := specialize _appendList<Variant>(table, rot);
    i := i + 1;
  end;
  table := sortStrings(table);
  last := '';
  i := 0;
  while (i < le) do
  begin
    last := last + _sliceString(table[i], le - 1, le - 1 + le);
    i := i + 1;
  end;
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('err', False);
  _tmp1.AddOrSetData('res', last);
  result := _tmp1;
  exit;
end;

function ibwt(r: string): string;
var
  i: integer;
  le: Variant;
  n: Variant;
  table: specialize TArray<string>;
begin
  le := Length(r);
  table := specialize TArray<string>([]);
  i := 0;
  while (i < le) do
  begin
    table := specialize _appendList<string>(table, '');
    i := i + 1;
  end;
  n := 0;
  while (n < le) do
  begin
    i := 0;
    while (i < le) do
    begin
      table[i] := _sliceString(r, i, i + i + 1) + specialize _indexList<string>(table, i);
      i := i + 1;
    end;
    table := sortStrings(table);
    n := n + 1;
  end;
  i := 0;
  while (i < le) do
  begin
    if (_sliceString(specialize _indexList<string>(table, i), le - 1, le - 1 + le) = etx) then ;
    i := i + 1;
  end;
  result := '';
  exit;
end;

function makePrintable(s: string): string;
var
  ch: Variant;
  i: integer;
  out: string;
begin
  out := '';
  i := 0;
  while (i < Length(s)) do
  begin
    ch := _sliceString(s, i, i + i + 1);
    if (ch = stx) then
    begin
      out := out + '^';
    end else if (ch = etx) then
    begin
      out := out + '|';
    end else
    begin
      out := out + ch;
    end;
    i := i + 1;
  end;
  result := out;
  exit;
end;

function main(): integer;
var
  enc: string;
  examples: specialize TArray<Variant>;
  r: Variant;
  res: Variant;
begin
  examples := specialize TArray<string>(['banana', 'appellee', 'dogwood', 'TO BE OR NOT TO BE OR WANT TO BE OR NOT?', 'SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES', 'ABC']);
  for t in examples do
  begin
    writeln(makePrintable(t));
    res := bwt(t);
    if res['err'] then
    begin
      writeln(' --> ERROR: String can''t contain STX or ETX');
      writeln(' -->');
    end else
    begin
      enc := Trunc(res['res']);
      writeln(' --> ' + makePrintable(enc));
      r := ibwt(enc);
      writeln(' --> ' + r);
    end;
    writeln('');
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

var
  etx: string;
  stx: string;

begin
  stx := '';
  etx := '';
  main();
end.
