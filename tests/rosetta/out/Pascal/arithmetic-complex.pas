// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program ArithmeticComplex;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
type Complex = record
  re: double;
  im: double;
end;

var
  _tmp5: Complex;
  _tmp6: Complex;
  a: Complex;
  b: Complex;

function add(a: Complex; b: Complex): Complex;
var
  _tmp0: Complex;
begin
  _tmp0.re := a.re + b.re;
  _tmp0.im := a.im + b.im;
  result := _tmp0;
  exit;
end;

function mul(a: Complex; b: Complex): Complex;
var
  _tmp1: Complex;
begin
  _tmp1.re := a.re * b.re - a.im * b.im;
  _tmp1.im := a.re * b.im + a.im * b.re;
  result := _tmp1;
  exit;
end;

function neg(a: Complex): Complex;
var
  _tmp2: Complex;
begin
  _tmp2.re := -a.re;
  _tmp2.im := -a.im;
  result := _tmp2;
  exit;
end;

function inv(a: Complex): Complex;
var
  _tmp3: Complex;
  denom: function(p0: Variant): integer is nested;
begin
  denom := a.re * a.re + a.im * a.im;
  _tmp3.re := a.re / denom;
  _tmp3.im := -a.im / denom;
  result := _tmp3;
  exit;
end;

function conj(a: Complex): Complex;
var
  _tmp4: Complex;
begin
  _tmp4.re := a.re;
  _tmp4.im := -a.im;
  result := _tmp4;
  exit;
end;

function cstr(a: Complex): string;
var
  s: string;
begin
  s := '(' + FloatToStr(a.re);
  if (a.im >= 0) then
  begin
    s := s + '+' + FloatToStr(a.im) + 'i)';
  end else
  begin
    s := s + FloatToStr(a.im) + 'i)';
  end;
  result := s;
  exit;
end;

begin
  _tmp5.re := 1;
  _tmp5.im := 1;
  a := _tmp5;
  _tmp6.re := 3.14159;
  _tmp6.im := 1.25;
  b := _tmp6;
  writeln('a:       ' + cstr(a));
  writeln('b:       ' + cstr(b));
  writeln('a + b:   ' + cstr(add(a, b)));
  writeln('a * b:   ' + cstr(mul(a, b)));
  writeln('-a:      ' + cstr(neg(a)));
  writeln('1 / a:   ' + cstr(inv(a)));
  writeln('aÌ…:       ' + cstr(conj(a)));
end.
