// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:24Z
program CirclesOfGivenRadiusThroughTwoPoints;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;
type Point = record
  x: double;
  y: double;
end;

function sqrtApprox(x: double): double;
var
  g: Variant;
  i: integer;
begin
  g := x;
  i := 0;
  while (i < 40) do
  begin
    g := g + x div g div 2;
    i := i + 1;
  end;
  result := g;
  exit;
end;

function hypot(x: double; y: double): double;
begin
  result := sqrtApprox(x * x + y * y);
  exit;
end;

function circles(p1: Point; p2: Point; r: double): specialize TArray<any>;
var
  _tmp0: Point;
  _tmp1: Point;
  _tmp2: Point;
  d: Variant;
  dx: Variant;
  dy: Variant;
  m: Variant;
  ox: Variant;
  oy: Variant;
  q: Variant;
begin
  if ((p1.x = p2.x) and (p1.y = p2.y)) then
  begin
    if (r = 0) then ;
    result := specialize TArray<integer>([p1, p2, 'Coincident points describe an infinite number of circles.']);
    exit;
  end;
  if (r = 0) then ;
  dx := p2.x - p1.x;
  dy := p2.y - p1.y;
  q := hypot(dx, dy);
  if (q > 2 * r) then ;
  _tmp0.x := p1.x + p2.x / 2;
  _tmp0.y := p1.y + p2.y / 2;
  m := _tmp0;
  if (q = 2 * r) then ;
  d := sqrtApprox(r * r - q * q div 4);
  ox := d * dx div q;
  oy := d * dy div q;
  _tmp1.x := m.x - oy;
  _tmp1.y := m.y + ox;
  _tmp2.x := m.x + oy;
  _tmp2.y := m.y - ox;
  result := specialize TArray<integer>([_tmp1, _tmp2, 'Two circles.']);
  exit;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

var
  Co: string;
  CoR0: string;
  Diam: string;
  Far: string;
  R0: string;
  Two: string;
  _tmp10: Point;
  _tmp11: Point;
  _tmp12: Point;
  _tmp3: Point;
  _tmp4: Point;
  _tmp5: Point;
  _tmp6: Point;
  _tmp7: Point;
  _tmp8: Point;
  _tmp9: Point;
  c1: Variant;
  c2: Variant;
  caseStr: Variant;
  p1: Variant;
  p2: Variant;
  r: Variant;
  res: Variant;
  tc: Variant;
  td: specialize TArray<specialize TArray<Variant>>;

begin
  Two := 'Two circles.';
  R0 := 'R==0.0 does not describe circles.';
  Co := 'Coincident points describe an infinite number of circles.';
  CoR0 := 'Coincident points with r==0.0 describe a degenerate circle.';
  Diam := 'Points form a diameter and describe only a single circle.';
  Far := 'Points too far apart to form circles.';
  _tmp3.x := 0.1234;
  _tmp3.y := 0.9876;
  _tmp4.x := 0.8765;
  _tmp4.y := 0.2345;
  _tmp5.x := 0;
  _tmp5.y := 2;
  _tmp6.x := 0;
  _tmp6.y := 0;
  _tmp7.x := 0.1234;
  _tmp7.y := 0.9876;
  _tmp8.x := 0.1234;
  _tmp8.y := 0.9876;
  _tmp9.x := 0.1234;
  _tmp9.y := 0.9876;
  _tmp10.x := 0.8765;
  _tmp10.y := 0.2345;
  _tmp11.x := 0.1234;
  _tmp11.y := 0.9876;
  _tmp12.x := 0.1234;
  _tmp12.y := 0.9876;
  td := specialize TArray<specialize TArray<Variant>>([specialize TArray<Variant>([_tmp3, _tmp4, 2]), specialize TArray<Variant>([_tmp5, _tmp6, 1]), specialize TArray<Variant>([_tmp7, _tmp8, 2]), specialize TArray<Variant>([_tmp9, _tmp10, 0.5]), specialize TArray<Variant>([_tmp11, _tmp12, 0])]);
  for tc in td do
  begin
    p1 := specialize _indexList<Variant>(tc, 0);
    p2 := specialize _indexList<Variant>(tc, 1);
    r := specialize _indexList<Variant>(tc, 2);
    writeln('p1:  {' + IntToStr(p1.x) + ' ' + IntToStr(p1.y) + '}');
    writeln('p2:  {' + IntToStr(p2.x) + ' ' + IntToStr(p2.y) + '}');
    writeln('r:  ' + IntToStr(r));
    res := circles(p1, p2, r);
    c1 := res[0];
    c2 := res[1];
    caseStr := res[2];
    writeln('   ' + caseStr);
    if ((caseStr = 'Points form a diameter and describe only a single circle.') or (caseStr = 'Coincident points with r==0.0 describe a degenerate circle.')) then
    begin
      writeln('   Center:  {' + IntToStr(c1.x) + ' ' + IntToStr(c1.y) + '}');
    end else
    begin
      if (caseStr = 'Two circles.') then
      begin
        writeln('   Center 1:  {' + IntToStr(c1.x) + ' ' + IntToStr(c1.y) + '}');
        writeln('   Center 2:  {' + IntToStr(c2.x) + ' ' + IntToStr(c2.y) + '}');
      end;
    end;
    writeln('');
  end;
end.
