// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:16Z
program Bitmap;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;
type Pixel = record
  R: integer;
  G: integer;
  B: integer;
end;
type Bitmap = record
  cols: integer;
  rows: integer;
  px: specialize TArray<specialize TArray<Pixel>>;
end;

function pixelFromRgb(c: integer): Pixel;
var
  _tmp0: Pixel;
  b: Variant;
  g: Variant;
  r: Variant;
begin
  r := Trunc(c div 65536) mod 256;
  g := Trunc(c div 256) mod 256;
  b := c mod 256;
  _tmp0.R := r;
  _tmp0.G := g;
  _tmp0.B := b;
  result := _tmp0;
  exit;
end;

function rgbFromPixel(p: Pixel): integer;
begin
  result := p.R * 65536 + p.G * 256 + p.B;
  exit;
end;

function NewBitmap(x: integer; y: integer): Bitmap;
var
  _tmp1: Pixel;
  _tmp2: Bitmap;
  col: integer;
  data: specialize TArray<specialize TArray<integer>>;
  r: Variant;
  row: integer;
begin
  data := specialize TArray<specialize TArray<integer>>([]);
  row := 0;
  while (row < y) do
  begin
    r := specialize TArray<integer>([]);
    col := 0;
    while (col < x) do
    begin
      _tmp1.R := 0;
      _tmp1.G := 0;
      _tmp1.B := 0;
      r := specialize _appendList<Variant>(r, _tmp1);
      col := col + 1;
    end;
    data := specialize _appendList<Variant>(data, r);
    row := row + 1;
  end;
  _tmp2.cols := x;
  _tmp2.rows := y;
  _tmp2.px := data;
  result := _tmp2;
  exit;
end;

function Extent(b: Bitmap): specialize TFPGMap<string, integer>;
var
  _tmp3: specialize TFPGMap<string, Variant>;
begin
  _tmp3 := specialize TFPGMap<string, Variant>.Create;
  _tmp3.AddOrSetData('cols', b.cols);
  _tmp3.AddOrSetData('rows', b.rows);
  result := _tmp3;
  exit;
end;

function Fill(b: Bitmap; p: Pixel): integer;
var
  px: Variant;
  row: Variant;
  x: integer;
  y: integer;
begin
  y := 0;
  while (y < b.rows) do
  begin
    x := 0;
    while (x < b.cols) do
    begin
      px := b.px;
      row := px[y];
      row[x] := p;
      px[y] := row;
      b := px;
      x := x + 1;
    end;
    y := y + 1;
  end;
end;

function FillRgb(b: Bitmap; c: integer): integer;
begin
  Fill(b, pixelFromRgb(c));
end;

function SetPx(b: Bitmap; x: integer; y: integer; p: Pixel): boolean;
var
  px: Variant;
  row: Variant;
begin
  if ((((x < 0) or (x >= b.cols)) or (y < 0)) or (y >= b.rows)) then ;
  px := b.px;
  row := px[y];
  row[x] := p;
  px[y] := row;
  b := px;
  result := True;
  exit;
end;

function SetPxRgb(b: Bitmap; x: integer; y: integer; c: integer): boolean;
begin
  result := SetPx(b, x, y, pixelFromRgb(c));
  exit;
end;

function GetPx(b: Bitmap; x: integer; y: integer): specialize TFPGMap<string, any>;
var
  _tmp4: specialize TFPGMap<string, boolean>;
  _tmp5: specialize TFPGMap<string, Variant>;
  row: Variant;
begin
  if ((((x < 0) or (x >= b.cols)) or (y < 0)) or (y >= b.rows)) then ;
  row := b.px[y];
  _tmp5 := specialize TFPGMap<string, Variant>.Create;
  _tmp5.AddOrSetData('ok', True);
  _tmp5.AddOrSetData('pixel', row[x]);
  result := _tmp5;
  exit;
end;

function GetPxRgb(b: Bitmap; x: integer; y: integer): specialize TFPGMap<string, any>;
var
  _tmp6: specialize TFPGMap<string, boolean>;
  _tmp7: specialize TFPGMap<string, Variant>;
  r: Variant;
begin
  r := GetPx(b, x, y);
  if not r.ok then ;
  _tmp7 := specialize TFPGMap<string, Variant>.Create;
  _tmp7.AddOrSetData('ok', True);
  _tmp7.AddOrSetData('rgb', rgbFromPixel(r.pixel));
  result := _tmp7;
  exit;
end;

function ppmSize(b: Bitmap): integer;
var
  header: string;
begin
  header := 'P6
# Creator: Rosetta Code http://rosettacode.org/
' + IntToStr(b.cols) + ' ' + IntToStr(b.rows) + '
255
';
  result := Length(header) + 3 * b.cols * b.rows;
  exit;
end;

function pixelStr(p: Pixel): string;
begin
  result := '{' + IntToStr(p.R) + ' ' + IntToStr(p.G) + ' ' + IntToStr(p.B) + '}';
  exit;
end;

function main(): integer;
var
  b16: Variant;
  bm: Variant;
  c1: Variant;
  c2: Variant;
  c3: Variant;
  g16: Variant;
  p: Variant;
  r16: Variant;
begin
  bm := NewBitmap(300, 240);
  FillRgb(bm, 16711680);
  SetPxRgb(bm, 10, 20, 255);
  SetPxRgb(bm, 20, 30, 0);
  SetPxRgb(bm, 30, 40, 1056816);
  c1 := GetPx(bm, 0, 0);
  c2 := GetPx(bm, 10, 20);
  c3 := GetPx(bm, 30, 40);
  writeln('Image size: ' + IntToStr(bm.cols) + ' Ã— ' + IntToStr(bm.rows));
  writeln(IntToStr(ppmSize(bm)) + ' bytes when encoded as PPM.');
  if c1.ok then ;
  if c2.ok then ;
  if c3.ok then
  begin
    p := c3.pixel;
    r16 := p.R * 257;
    g16 := p.G * 257;
    b16 := p.B * 257;
    writeln('Pixel at (30,40) has R=' + IntToStr(r16) + ', G=' + IntToStr(g16) + ', B=' + IntToStr(b16));
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

begin
  main();
end.
