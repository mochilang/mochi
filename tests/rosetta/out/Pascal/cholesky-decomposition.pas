// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:23Z
program CholeskyDecomposition;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function sqrtApprox(x: double): double;
var
  guess: Variant;
  i: integer;
begin
  guess := x;
  i := 0;
  while (i < 20) do
  begin
    guess := guess + x div guess div 2;
    i := i + 1;
  end;
  result := guess;
  exit;
end;

function cholesky(a: specialize TArray<specialize TArray<double>>): specialize TArray<specialize TArray<double>>;
var
  i: integer;
  j: integer;
  k: integer;
  l: specialize TArray<specialize TArray<double>>;
  n: Variant;
  row: specialize TArray<double>;
  sum: function(p0: Variant): double is nested;
begin
  n := Length(a);
  l := specialize TArray<specialize TArray<double>>([]);
  i := 0;
  while (i < n) do
  begin
    row := specialize TArray<double>([]);
    j := 0;
    while (j < n) do
    begin
      row := specialize _appendList<Variant>(row, 0);
      j := j + 1;
    end;
    l := specialize _appendList<Variant>(l, row);
    i := i + 1;
  end;
  i := 0;
  while (i < n) do
  begin
    j := 0;
    while (j <= i) do
    begin
      sum := specialize _indexList<integer>(specialize _indexList<integer>(a, i), j);
      k := 0;
      while (k < j) do
      begin
        sum := sum - l[i][k] * l[j][k];
        k := k + 1;
      end;
      if (i = j) then
      begin
        l[i][j] := sqrtApprox(sum);
      end else
      begin
        l[i][j] := sum div l[j][j];
      end;
      j := j + 1;
    end;
    i := i + 1;
  end;
  result := l;
  exit;
end;

function printMat(m: specialize TArray<specialize TArray<double>>): integer;
var
  i: integer;
  j: integer;
  line: string;
begin
  i := 0;
  while (i < Length(m)) do
  begin
    line := '';
    j := 0;
    while (j < Length(specialize _indexList<integer>(m, i))) do
    begin
      line := line + IntToStr(specialize _indexList<integer>(specialize _indexList<integer>(m, i), j));
      if (j < Length(specialize _indexList<integer>(m, i)) - 1) then ;
      j := j + 1;
    end;
    writeln(line);
    i := i + 1;
  end;
end;

function demo(a: specialize TArray<specialize TArray<double>>): integer;
var
  l: specialize TArray<specialize TArray<double>>;
begin
  writeln('A:');
  printMat(a);
  l := cholesky(a);
  writeln('L:');
  printMat(l);
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

begin
  demo(specialize TArray<specialize TArray<double>>([specialize TArray<double>([25, 15, -5]), specialize TArray<double>([15, 18, 0]), specialize TArray<double>([-5, 0, 11])]));
  demo(specialize TArray<specialize TArray<double>>([specialize TArray<double>([18, 22, 54, 42]), specialize TArray<double>([22, 70, 86, 62]), specialize TArray<double>([54, 86, 174, 134]), specialize TArray<double>([42, 62, 134, 106])]));
end.
