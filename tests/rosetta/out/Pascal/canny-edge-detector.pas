// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:19Z
program CannyEdgeDetector;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function conv2d(img: specialize TArray<specialize TArray<double>>; k: specialize TArray<specialize TArray<double>>): specialize TArray<specialize TArray<double>>;
var
  h: Variant;
  half: Variant;
  i: integer;
  j: integer;
  n: Variant;
  out: specialize TArray<specialize TArray<double>>;
  row: specialize TArray<double>;
  sum: function(p0: Variant): double is nested;
  w: Variant;
  x: integer;
  xx: integer;
  y: integer;
  yy: integer;
begin
  h := Length(img);
  w := Length(specialize _indexList<integer>(img, 0));
  n := Length(k);
  half := n div 2;
  out := specialize TArray<specialize TArray<double>>([]);
  y := 0;
  while (y < h) do
  begin
    row := specialize TArray<double>([]);
    x := 0;
    while (x < w) do
    begin
      sum := 0;
      j := 0;
      while (j < n) do
      begin
        i := 0;
        while (i < n) do
        begin
          yy := y + j - half;
          if (yy < 0) then ;
          if (yy >= h) then ;
          xx := x + i - half;
          if (xx < 0) then ;
          if (xx >= w) then ;
          sum := sum + specialize _indexList<integer>(specialize _indexList<integer>(img, yy), xx) * specialize _indexList<integer>(specialize _indexList<integer>(k, j), i);
          i := i + 1;
        end;
        j := j + 1;
      end;
      row := specialize _appendList<Variant>(row, sum);
      x := x + 1;
    end;
    out := specialize _appendList<Variant>(out, row);
    y := y + 1;
  end;
  result := out;
  exit;
end;

function gradient(img: specialize TArray<specialize TArray<double>>): specialize TArray<specialize TArray<double>>;
var
  g: Variant;
  gx: Variant;
  gy: Variant;
  h: Variant;
  hx: specialize TArray<Variant>;
  hy: specialize TArray<Variant>;
  out: specialize TArray<specialize TArray<double>>;
  row: specialize TArray<double>;
  w: Variant;
  x: integer;
  y: integer;
begin
  hx := specialize TArray<specialize TArray<double>>([specialize TArray<double>([-1, 0, 1]), specialize TArray<double>([-2, 0, 2]), specialize TArray<double>([-1, 0, 1])]);
  hy := specialize TArray<specialize TArray<double>>([specialize TArray<double>([1, 2, 1]), specialize TArray<double>([0, 0, 0]), specialize TArray<double>([-1, -2, -1])]);
  gx := conv2d(img, hx);
  gy := conv2d(img, hy);
  h := Length(img);
  w := Length(specialize _indexList<integer>(img, 0));
  out := specialize TArray<specialize TArray<double>>([]);
  y := 0;
  while (y < h) do
  begin
    row := specialize TArray<double>([]);
    x := 0;
    while (x < w) do
    begin
      g := gx[y][x] * gx[y][x] + gy[y][x] * gy[y][x];
      row := specialize _appendList<double>(row, g);
      x := x + 1;
    end;
    out := specialize _appendList<specialize TArray<double>>(out, row);
    y := y + 1;
  end;
  result := out;
  exit;
end;

function threshold(g: specialize TArray<specialize TArray<double>>; t: double): specialize TArray<specialize TArray<integer>>;
var
  h: Variant;
  out: specialize TArray<specialize TArray<double>>;
  row: specialize TArray<double>;
  w: Variant;
  x: integer;
  y: integer;
begin
  h := Length(g);
  w := Length(specialize _indexList<integer>(g, 0));
  out := specialize TArray<specialize TArray<double>>([]);
  y := 0;
  while (y < h) do
  begin
    row := specialize TArray<double>([]);
    x := 0;
    while (x < w) do
    begin
      if (specialize _indexList<integer>(specialize _indexList<integer>(g, y), x) >= t) then
      begin
        row := specialize _appendList<double>(row, 1);
      end else
      begin
        row := specialize _appendList<double>(row, 0);
      end;
      x := x + 1;
    end;
    out := specialize _appendList<specialize TArray<double>>(out, row);
    y := y + 1;
  end;
  result := out;
  exit;
end;

function printMatrix(m: specialize TArray<specialize TArray<integer>>): integer;
var
  line: string;
  x: integer;
  y: integer;
begin
  y := 0;
  while (y < Length(m)) do
  begin
    line := '';
    x := 0;
    while (x < Length(specialize _indexList<integer>(m, 0))) do
    begin
      line := line + IntToStr(specialize _indexList<integer>(specialize _indexList<integer>(m, y), x));
      if (x < Length(specialize _indexList<integer>(m, 0)) - 1) then ;
      x := x + 1;
    end;
    writeln(line);
    y := y + 1;
  end;
end;

function main(): integer;
var
  edges: Variant;
  g: Variant;
  img: specialize TArray<Variant>;
begin
  img := specialize TArray<specialize TArray<double>>([specialize TArray<double>([0, 0, 0, 0, 0]), specialize TArray<double>([0, 255, 255, 255, 0]), specialize TArray<double>([0, 255, 255, 255, 0]), specialize TArray<double>([0, 255, 255, 255, 0]), specialize TArray<double>([0, 0, 0, 0, 0])]);
  g := gradient(img);
  edges := threshold(g, 1020 * 1020);
  printMatrix(edges);
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

var
  PI: double;

begin
  PI := 3.141592653589793;
  main();
end.
