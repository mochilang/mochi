// Generated by Mochi compiler v0.10.26 on 2025-07-16T10:01:21Z
program AveragesMeanTimeOfDay;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function sinApprox(x: double): double;
var
  denom: function(p0: Variant): integer is nested;
  n: integer;
  sum: function(p0: Variant): double is nested;
  term: Variant;
begin
  term := x;
  sum := x;
  n := 1;
  while (n <= 8) do
  begin
    denom := Double(2 * n * 2 * n + 1);
    term := -term * x * x div denom;
    sum := sum + term;
    n := n + 1;
  end;
  result := sum;
  exit;
end;

function cosApprox(x: double): double;
var
  denom: function(p0: Variant): integer is nested;
  n: integer;
  sum: function(p0: Variant): double is nested;
  term: Variant;
begin
  term := 1;
  sum := 1;
  n := 1;
  while (n <= 8) do
  begin
    denom := Double(2 * n - 1 * 2 * n);
    term := -term * x * x div denom;
    sum := sum + term;
    n := n + 1;
  end;
  result := sum;
  exit;
end;

function atanApprox(x: double): double;
begin
  if (x > 1) then ;
  if (x < -1) then ;
  result := x / 1 + 0.28 * x * x;
  exit;
end;

function atan2Approx(y: double; x: double): double;
begin
  if (x > 0) then ;
  if (x < 0) then
  begin
    if (y >= 0) then ;
    result := atanApprox(y div x) - PI;
    exit;
  end;
  if (y > 0) then ;
  if (y < 0) then ;
  result := 0;
  exit;
end;

function digit(ch: string): integer;
var
  digits: string;
  i: integer;
begin
  digits := '0123456789';
  i := 0;
  while (i < Length(digits)) do
  begin
    if (_sliceString(digits, i, i + i + 1) = ch) then ;
    i := i + 1;
  end;
  result := 0;
  exit;
end;

function parseTwo(s: string; idx: integer): integer;
begin
  result := digit(_sliceString(s, idx, idx + idx + 1)) * 10 + digit(_sliceString(s, idx + 1, idx + 1 + idx + 2));
  exit;
end;

function parseSec(s: string): double;
var
  h: Variant;
  m: Variant;
  sec: Variant;
begin
  h := parseTwo(s, 0);
  m := parseTwo(s, 3);
  sec := parseTwo(s, 6);
  result := Double(h * 60 + m * 60 + sec);
  exit;
end;

function pad(n: integer): string;
begin
  if (n < 10) then ;
  result := IntToStr(n);
  exit;
end;

function meanTime(times: specialize TArray<string>): string;
var
  ang: Variant;
  csum: double;
  frac: Variant;
  h: Variant;
  i: integer;
  m: Variant;
  s: integer;
  sec: Variant;
  si: integer;
  ssum: double;
  theta: Variant;
  total: Variant;
begin
  ssum := 0;
  csum := 0;
  i := 0;
  while (i < Length(times)) do
  begin
    sec := parseSec(specialize _indexList<integer>(times, i));
    ang := sec * 2 * PI div 86400;
    ssum := ssum + sinApprox(ang);
    csum := csum + cosApprox(ang);
    i := i + 1;
  end;
  theta := atan2Approx(ssum, csum);
  frac := theta div 2 * PI;
  while (frac < 0) do
  begin
    frac := frac + 1;
  end;
  total := frac * 86400;
  si := Trunc(total);
  h := Trunc(si div 3600);
  m := Trunc(si mod 3600 div 60);
  s := Trunc(si mod 60);
  result := pad(h) + ':' + pad(m) + ':' + pad(s);
  exit;
end;

function main(): integer;
var
  inputs: specialize TArray<Variant>;
begin
  inputs := specialize TArray<string>(['23:00:17', '23:40:20', '00:12:45', '00:17:19']);
  writeln(meanTime(inputs));
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

var
  PI: double;

begin
  PI := 3.141592653589793;
  main();
end.
