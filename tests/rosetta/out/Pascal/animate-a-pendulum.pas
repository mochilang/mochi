// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program AnimateAPendulum;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;

var
  G: double;
  L: double;
  PI: double;
  dt: double;
  omega: double;
  phi: double;
  phi0: double;
  pos: integer;
  step: integer;
  t: double;

function sinApprox(x: double): double;
var
  denom: function(p0: Variant): integer is nested;
  n: integer;
  sum: function(p0: Variant): double is nested;
  term: Variant;
begin
  term := x;
  sum := x;
  n := 1;
  while (n <= 10) do
  begin
    denom := Double(2 * n * 2 * n + 1);
    term := -term * x * x div denom;
    sum := sum + term;
    n := n + 1;
  end;
  result := sum;
  exit;
end;

function cosApprox(x: double): double;
var
  denom: function(p0: Variant): integer is nested;
  n: integer;
  sum: function(p0: Variant): double is nested;
  term: Variant;
begin
  term := 1;
  sum := 1;
  n := 1;
  while (n <= 10) do
  begin
    denom := Double(2 * n - 1 * 2 * n);
    term := -term * x * x div denom;
    sum := sum + term;
    n := n + 1;
  end;
  result := sum;
  exit;
end;

function sqrtApprox(x: double): double;
var
  guess: Variant;
  i: integer;
begin
  guess := x;
  i := 0;
  while (i < 10) do
  begin
    guess := guess + x div guess div 2;
    i := i + 1;
  end;
  result := guess;
  exit;
end;

begin
  PI := 3.141592653589793;
  L := 10;
  G := 9.81;
  dt := 0.2;
  phi0 := PI div 4;
  omega := sqrtApprox(G div L);
  t := 0;
  for step := 0 to 10 - 1 do
  begin
    phi := phi0 * cosApprox(omega * t);
    pos := Trunc(10 * sinApprox(phi) + 0.5);
    writeln(IntToStr(pos));
    t := t + dt;
  end;
end.
