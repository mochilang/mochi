// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:02Z
program _4GameSolve;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function newNum(n: integer): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
  _tmp1: specialize TFPGMap<string, Variant>;
begin
  _tmp0 := specialize TFPGMap<string, Variant>.Create;
  _tmp0.AddOrSetData('op', OP_NUM);
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('num', n);
  _tmp1.AddOrSetData('denom', 1);
  _tmp0.AddOrSetData('value', _tmp1);
  result := _tmp0;
  exit;
end;

function exprEval(x: specialize TFPGMap<string, any>): specialize TFPGMap<string, integer>;
var
  _tmp2: specialize TFPGMap<string, Variant>;
  _tmp3: specialize TFPGMap<string, Variant>;
  _tmp4: specialize TFPGMap<string, Variant>;
  _tmp5: specialize TFPGMap<string, Variant>;
  l: Variant;
  r: Variant;
begin
  if (x.KeyData['op'] = OP_NUM) then ;
  l := exprEval(x.KeyData['left']);
  r := exprEval(x.KeyData['right']);
  if (x.KeyData['op'] = OP_ADD) then ;
  if (x.KeyData['op'] = OP_SUB) then ;
  if (x.KeyData['op'] = OP_MUL) then ;
  _tmp5 := specialize TFPGMap<string, Variant>.Create;
  _tmp5.AddOrSetData('num', l['num'] * r['denom']);
  _tmp5.AddOrSetData('denom', l['denom'] * r['num']);
  result := _tmp5;
  exit;
end;

function exprString(x: specialize TFPGMap<string, any>): string;
var
  ls: Variant;
  opstr: string;
  rs: Variant;
begin
  if (x.KeyData['op'] = OP_NUM) then ;
  ls := exprString(x.KeyData['left']);
  rs := exprString(x.KeyData['right']);
  opstr := '';
  if (x.KeyData['op'] = OP_ADD) then
  begin
    opstr := ' + ';
  end else if (x.KeyData['op'] = OP_SUB) then
  begin
    opstr := ' - ';
  end else if (x.KeyData['op'] = OP_MUL) then
  begin
    opstr := ' * ';
  end else
  begin
    opstr := ' / ';
  end;
  result := '(' + ls + opstr + rs + ')';
  exit;
end;

function solve(xs: specialize TArray<specialize TFPGMap<string, any>>): boolean;
var
  _tmp6: specialize TFPGMap<string, Variant>;
  _tmp7: specialize TFPGMap<string, Variant>;
  _tmp8: specialize TFPGMap<string, Variant>;
  a: Variant;
  b: Variant;
  f: Variant;
  i: integer;
  j: integer;
  k: integer;
  node: specialize TFPGMap<Variant, Variant>;
  rest: specialize TArray<specialize TFPGMap<string, integer>>;
begin
  if (Length(xs) = 1) then
  begin
    f := exprEval(specialize _indexList<integer>(xs, 0));
    if ((f['denom'] <> 0) and (f['num'] = f['denom'] * goal)) then
    begin
      writeln(exprString(specialize _indexList<integer>(xs, 0)));
      result := True;
      exit;
    end;
    result := False;
    exit;
  end;
  i := 0;
  while (i < Length(xs)) do
  begin
    j := i + 1;
    while (j < Length(xs)) do
    begin
      rest := specialize TArray<specialize TFPGMap<string, integer>>([]);
      k := 0;
      while (k < Length(xs)) do
      begin
        if ((k <> i) and (k <> j)) then ;
        k := k + 1;
      end;
      a := specialize _indexList<integer>(xs, i);
      b := specialize _indexList<integer>(xs, j);
      for op in specialize TArray<integer>([OP_ADD, OP_SUB, OP_MUL, OP_DIV]) do
      begin
        _tmp6 := specialize TFPGMap<string, Variant>.Create;
        _tmp6.AddOrSetData('op', op);
        _tmp6.AddOrSetData('left', a);
        _tmp6.AddOrSetData('right', b);
        node := _tmp6;
        if solve(specialize _appendList<Variant>(rest, node)) then ;
      end;
      _tmp7 := specialize TFPGMap<string, Variant>.Create;
      _tmp7.AddOrSetData('op', OP_SUB);
      _tmp7.AddOrSetData('left', b);
      _tmp7.AddOrSetData('right', a);
      node := _tmp7;
      if solve(specialize _appendList<Variant>(rest, node)) then ;
      _tmp8 := specialize TFPGMap<string, Variant>.Create;
      _tmp8.AddOrSetData('op', OP_DIV);
      _tmp8.AddOrSetData('left', b);
      _tmp8.AddOrSetData('right', a);
      node := _tmp8;
      if solve(specialize _appendList<Variant>(rest, node)) then ;
      j := j + 1;
    end;
    i := i + 1;
  end;
  result := False;
  exit;
end;

function main(): integer;
var
  cards: specialize TArray<specialize TFPGMap<string, integer>>;
  i: integer;
  iter: integer;
  n: Variant;
begin
  iter := 0;
  while (iter < 10) do
  begin
    cards := specialize TArray<specialize TFPGMap<string, integer>>([]);
    i := 0;
    while (i < n_cards) do
    begin
      n := now() mod digit_range - 1 + 1;
      cards := specialize _appendList<Variant>(cards, newNum(n));
      writeln(' ' + IntToStr(n));
      i := i + 1;
    end;
    writeln(':  ');
    if not solve(cards) then ;
    iter := iter + 1;
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

var
  OP_ADD: integer;
  OP_DIV: integer;
  OP_MUL: integer;
  OP_NUM: integer;
  OP_SUB: integer;
  digit_range: integer;
  goal: integer;
  n_cards: integer;

begin
  OP_NUM := 0;
  OP_ADD := 1;
  OP_SUB := 2;
  OP_MUL := 3;
  OP_DIV := 4;
  n_cards := 4;
  goal := 24;
  digit_range := 9;
  main();
end.
