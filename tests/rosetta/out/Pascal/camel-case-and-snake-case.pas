// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:19Z
program CamelCaseAndSnakeCase;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function trimSpace(s: string): string;
var
  _end: Variant;
  start: integer;
begin
  start := 0;
  while ((start < Length(s)) and (_sliceString(s, start, start + 1) = ' ')) do
  begin
    start := start + 1;
  end;
  _end := Length(s);
  while ((_end > start) and (_sliceString(s, _end - 1, _end) = ' ')) do
  begin
    _end := _end - 1;
  end;
  result := _sliceString(s, start, _end);
  exit;
end;

function isUpper(ch: string): boolean;
begin
  result := ((ch >= 'A') and (ch <= 'Z'));
  exit;
end;

function padLeft(s: string; w: integer): string;
var
  n: Variant;
  res: string;
begin
  res := '';
  n := w - Length(s);
  while (n > 0) do
  begin
    res := res + ' ';
    n := n - 1;
  end;
  result := res + s;
  exit;
end;

function snakeToCamel(s: string): string;
var
  ch: Variant;
  i: integer;
  out: string;
  up: boolean;
begin
  s := trimSpace(s);
  out := '';
  up := False;
  i := 0;
  while (i < Length(s)) do
  begin
    ch := _sliceString(s, i, i + 1);
    if ((((ch = '_') or (ch = '-')) or (ch = ' ')) or (ch = '.')) then
    begin
      up := True;
      i := i + 1;
      continue;
    end;
    if (i = 0) then
    begin
      out := out + LowerCase(ch);
      up := False;
      i := i + 1;
      continue;
    end;
    if up then
    begin
      out := out + UpperCase(ch);
      up := False;
    end else
    begin
      out := out + ch;
    end;
    i := i + 1;
  end;
  result := out;
  exit;
end;

function camelToSnake(s: string): string;
var
  c: string;
  ch: Variant;
  _end: Variant;
  i: integer;
  j: integer;
  lastUnd: boolean;
  out: string;
  prevUnd: boolean;
  res: string;
  start: integer;
begin
  s := trimSpace(s);
  out := '';
  prevUnd := False;
  i := 0;
  while (i < Length(s)) do
  begin
    ch := _sliceString(s, i, i + 1);
    if (((ch = ' ') or (ch = '-')) or (ch = '.')) then
    begin
      if (not prevUnd and (Length(out) > 0)) then
      begin
        out := out + '_';
        prevUnd := True;
      end;
      i := i + 1;
      continue;
    end;
    if (ch = '_') then
    begin
      if (not prevUnd and (Length(out) > 0)) then
      begin
        out := out + '_';
        prevUnd := True;
      end;
      i := i + 1;
      continue;
    end;
    if isUpper(ch) then
    begin
      if ((i > 0) and not prevUnd) then ;
      out := out + LowerCase(ch);
      prevUnd := False;
    end else
    begin
      out := out + LowerCase(ch);
      prevUnd := False;
    end;
    i := i + 1;
  end;
  start := 0;
  while ((start < Length(out)) and (_sliceString(out, start, start + 1) = '_')) do
  begin
    start := start + 1;
  end;
  _end := Length(out);
  while ((_end > start) and (_sliceString(out, _end - 1, _end) = '_')) do
  begin
    _end := _end - 1;
  end;
  out := _sliceString(out, start, _end);
  res := '';
  j := 0;
  lastUnd := False;
  while (j < Length(out)) do
  begin
    c := _sliceString(out, j, j + 1);
    if (c = '_') then
    begin
      if not lastUnd then ;
      lastUnd := True;
    end else
    begin
      res := res + c;
      lastUnd := False;
    end;
    j := j + 1;
  end;
  result := res;
  exit;
end;

function main(): integer;
var
  samples: specialize TArray<Variant>;
begin
  samples := specialize TArray<string>(['snakeCase', 'snake_case', 'snake-case', 'snake case', 'snake CASE', 'snake.case', 'variable_10_case', 'variable10Case', 'É›rgo rE tHis', 'hurry-up-joe!', 'c://my-docs/happy_Flag-Day/12.doc', ' spaces ']);
  writeln('=== To snake_case ===');
  for s in samples do
  begin
    writeln(padLeft(s, 34) + ' => ' + camelToSnake(s));
  end;
  writeln('');
  writeln('=== To camelCase ===');
  for s in samples do
  begin
    writeln(padLeft(s, 34) + ' => ' + snakeToCamel(s));
  end;
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
