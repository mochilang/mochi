// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:23Z
program ChineseRemainderTheorem;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function egcd(a: integer; b: integer): specialize TArray<integer>;
var
  g: Variant;
  res: Variant;
  x1: Variant;
  y1: Variant;
begin
  if (a = 0) then ;
  res := egcd(b mod a, a);
  g := res[0];
  x1 := res[1];
  y1 := res[2];
  result := specialize TArray<integer>([g, y1 - b div a * x1, x1]);
  exit;
end;

function modInv(a: integer; m: integer): integer;
var
  r: Variant;
  x: Variant;
begin
  r := egcd(a, m);
  if (r[0] <> 1) then ;
  x := r[1];
  if (x < 0) then ;
  result := x;
  exit;
end;

function crt(a: specialize TArray<integer>; n: specialize TArray<integer>): integer;
var
  ai: specialize TArray<integer>;
  i: integer;
  inv: Variant;
  ni: specialize TArray<integer>;
  p: integer;
  prod: integer;
  x: Variant;
begin
  prod := 1;
  i := 0;
  while (i < Length(n)) do
  begin
    prod := prod * specialize _indexList<integer>(n, i);
    i := i + 1;
  end;
  x := 0;
  i := 0;
  while (i < Length(n)) do
  begin
    ni := specialize _indexList<integer>(n, i);
    ai := specialize _indexList<integer>(a, i);
    p := prod div ni;
    inv := modInv(p mod ni, ni);
    x := x + ai * inv * p;
    i := i + 1;
  end;
  result := x mod prod;
  exit;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

var
  a: specialize TArray<integer>;
  n: specialize TArray<integer>;
  res: Variant;

begin
  n := specialize TArray<integer>([3, 5, 7]);
  a := specialize TArray<integer>([2, 3, 2]);
  res := crt(a, n);
  writeln(IntToStr(res) + ' <nil>');
end.
