// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:11Z
program AtomicUpdates;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function randOrder(seed: integer; n: integer): specialize TArray<integer>;
var
  next: Variant;
begin
  next := seed * 1664525 + 1013904223 mod 2147483647;
  result := specialize TArray<integer>([next, next mod n]);
  exit;
end;

function randChaos(seed: integer; n: integer): specialize TArray<integer>;
var
  next: Variant;
begin
  next := seed * 1103515245 + 12345 mod 2147483647;
  result := specialize TArray<integer>([next, next mod n]);
  exit;
end;

function main(): integer;
var
  a: integer;
  amt: Variant;
  b1: Variant;
  b2: Variant;
  buckets: specialize TArray<integer>;
  dist: integer;
  idx: integer;
  initialSum: integer;
  nBuckets: integer;
  nTicks: integer;
  r: Variant;
  seedChaos: integer;
  seedOrder: integer;
  sum: function(p0: Variant): double is nested;
  t: integer;
  tc0: integer;
  tc1: integer;
  total: integer;
  v: integer;
  v1: specialize TArray<integer>;
  v2: specialize TArray<integer>;
begin
  nBuckets := 10;
  initialSum := 1000;
  buckets := specialize TArray<integer>([]);
  for i := 0 to nBuckets - 1 do
  begin
    buckets := specialize _appendList<Variant>(buckets, 0);
  end;
  i := nBuckets;
  dist := initialSum;
  while (i > 0) do
  begin
    v := dist div i;
    i := i - 1;
    buckets[i] := v;
    dist := dist - v;
  end;
  tc0 := 0;
  tc1 := 0;
  total := 0;
  nTicks := 0;
  seedOrder := 1;
  seedChaos := 2;
  writeln('sum  ---updates---    mean  buckets');
  t := 0;
  while (t < 5) do
  begin
    r := randOrder(seedOrder, nBuckets);
    seedOrder := r[0];
    b1 := r[1];
    b2 := b1 + 1 mod nBuckets;
    v1 := buckets[b1];
    v2 := buckets[b2];
    if (v1 > v2) then
    begin
      a := Trunc(v1 - v2 div 2);
      if (a > buckets[b1]) then ;
      buckets[b1] := buckets[b1] - a;
      buckets[b2] := buckets[b2] + a;
    end else
    begin
      a := Trunc(v2 - v1 div 2);
      if (a > buckets[b2]) then ;
      buckets[b2] := buckets[b2] - a;
      buckets[b1] := buckets[b1] + a;
    end;
    tc0 := tc0 + 1;
    r := randChaos(seedChaos, nBuckets);
    seedChaos := r[0];
    b1 := r[1];
    b2 := b1 + 1 mod nBuckets;
    r := randChaos(seedChaos, buckets[b1] + 1);
    seedChaos := r[0];
    amt := r[1];
    if (amt > buckets[b1]) then ;
    buckets[b1] := buckets[b1] - amt;
    buckets[b2] := buckets[b2] + amt;
    tc1 := tc1 + 1;
    sum := 0;
    idx := 0;
    while (idx < nBuckets) do
    begin
      sum := sum + buckets[idx];
      idx := idx + 1;
    end;
    total := total + tc0 + tc1;
    nTicks := nTicks + 1;
    writeln(IntToStr(sum) + ' ' + IntToStr(tc0) + ' ' + IntToStr(tc1) + ' ' + IntToStr(total div nTicks) + '  ' + IntToStr(buckets));
    tc0 := 0;
    tc1 := 0;
    t := t + 1;
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

begin
  main();
end.
