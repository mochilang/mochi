// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:13Z
program Base64DecodeData;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function indexOf(s: string; ch: string): integer;
var
  i: integer;
begin
  i := 0;
  while (i < Length(s)) do
  begin
    if (_indexString(s, i) = ch) then ;
    i := i + 1;
  end;
  result := -1;
  exit;
end;

function parseIntStr(str: string): integer;
var
  _tmp0: specialize TFPGMap<string, integer>;
  digits: specialize TFPGMap<Variant, Variant>;
  i: integer;
  n: integer;
  neg: boolean;
begin
  i := 0;
  neg := False;
  if ((Length(str) > 0) and (_indexString(str, 0) = '-')) then
  begin
    neg := True;
    i := 1;
  end;
  n := 0;
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  _tmp0.AddOrSetData('0', 0);
  _tmp0.AddOrSetData('1', 1);
  _tmp0.AddOrSetData('2', 2);
  _tmp0.AddOrSetData('3', 3);
  _tmp0.AddOrSetData('4', 4);
  _tmp0.AddOrSetData('5', 5);
  _tmp0.AddOrSetData('6', 6);
  _tmp0.AddOrSetData('7', 7);
  _tmp0.AddOrSetData('8', 8);
  _tmp0.AddOrSetData('9', 9);
  digits := _tmp0;
  while (i < Length(str)) do
  begin
    n := n * 10 + digits[_indexString(str, i)];
    i := i + 1;
  end;
  if neg then ;
  result := n;
  exit;
end;

function ord(ch: string): integer;
var
  idx: Variant;
  lower: function(p0: Variant): string is nested;
  upper: function(p0: string): string is nested;
begin
  upper := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  lower := 'abcdefghijklmnopqrstuvwxyz';
  idx := indexOf(upper, ch);
  if (idx >= 0) then ;
  idx := indexOf(lower, ch);
  if (idx >= 0) then ;
  if ((ch >= '0') and (ch <= '9')) then ;
  if (ch = '+') then ;
  if (ch = '/') then ;
  if (ch = ' ') then ;
  if (ch = '=') then ;
  result := 0;
  exit;
end;

function chr(n: integer): string;
var
  digits: specialize TFPGMap<Variant, Variant>;
  lower: function(p0: Variant): string is nested;
  upper: function(p0: string): string is nested;
begin
  upper := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  lower := 'abcdefghijklmnopqrstuvwxyz';
  if ((n >= 65) and (n < 91)) then ;
  if ((n >= 97) and (n < 123)) then ;
  if ((n >= 48) and (n < 58)) then
  begin
    digits := '0123456789';
    result := Copy(digits, n - 48 + 1, n - 47 - n - 48);
    exit;
  end;
  if (n = 43) then ;
  if (n = 47) then ;
  if (n = 32) then ;
  if (n = 61) then ;
  result := '?';
  exit;
end;

function toBinary(n: integer; bits: integer): string;
var
  b: string;
  i: integer;
  val: integer;
begin
  b := '';
  val := n;
  i := 0;
  while (i < bits) do
  begin
    b := IntToStr(val mod 2) + b;
    val := Trunc(val div 2);
    i := i + 1;
  end;
  result := b;
  exit;
end;

function binToInt(bits: string): integer;
var
  i: integer;
  n: integer;
begin
  n := 0;
  i := 0;
  while (i < Length(bits)) do
  begin
    n := n * 2 + parseIntStr(_sliceString(bits, i, i + 1));
    i := i + 1;
  end;
  result := n;
  exit;
end;

function base64Encode(text: string): string;
var
  _tmp1: integer;
  alphabet: string;
  bin: string;
  chunk: string;
  i: integer;
  out: string;
  pad: Variant;
  val: Variant;
begin
  alphabet := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  bin := '';
  for _tmp1 := 1 to Length(text) do
  begin
    ch := text[_tmp1];
    bin := bin + toBinary(ord(ch), 8);
  end;
  while (Length(bin) mod 6 <> 0) do
  begin
    bin := bin + '0';
  end;
  out := '';
  i := 0;
  while (i < Length(bin)) do
  begin
    chunk := Copy(bin, i + 1, i + 6 - i);
    val := binToInt(chunk);
    out := out + Copy(alphabet, val + 1, val + 1 - val);
    i := i + 6;
  end;
  pad := 3 - Length(text) mod 3 mod 3;
  if (pad = 1) then ;
  if (pad = 2) then ;
  result := out;
  exit;
end;

function base64Decode(enc: string): string;
var
  alphabet: string;
  bin: string;
  ch: string;
  chunk: string;
  i: integer;
  idx: Variant;
  out: string;
  val: Variant;
begin
  alphabet := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  bin := '';
  i := 0;
  while (i < Length(enc)) do
  begin
    ch := _indexString(enc, i);
    if (ch = '=') then ;
    idx := indexOf(alphabet, ch);
    bin := bin + toBinary(idx, 6);
    i := i + 1;
  end;
  out := '';
  i := 0;
  while (i + 8 <= Length(bin)) do
  begin
    chunk := _sliceString(bin, i, i + 8);
    val := binToInt(chunk);
    out := out + chr(val);
    i := i + 8;
  end;
  result := out;
  exit;
end;

function _indexString(s: string; i: integer): string;
begin
  if i < 0 then i := Length(s) + i;
  if (i < 0) or (i >= Length(s)) then
    raise Exception.Create('index out of range');
  Result := s[i + 1];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

var
  dec: string;
  enc: string;
  msg: string;

begin
  msg := 'Rosetta Code Base64 decode data task';
  writeln('Original : ' + msg);
  enc := base64Encode(msg);
  writeln('
Encoded  : ' + enc);
  dec := base64Decode(enc);
  writeln('
Decoded  : ' + dec);
end.
