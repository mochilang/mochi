// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program AbelianSandpileModel;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;


var
  dim: integer;

function newPile(d: integer): specialize TArray<specialize TArray<integer>>;
var
  b: specialize TArray<Variant>;
  row: specialize TArray<Variant>;
  x: integer;
  y: integer;
begin
  b := specialize TArray<Variant>([]);
  y := 0;
  while (y < d) do
  begin
    row := specialize TArray<Variant>([]);
    x := 0;
    while (x < d) do
    begin
      row := specialize _appendList<Variant>(row, 0);
      x := x + 1;
    end;
    b := specialize _appendList<Variant>(b, row);
    y := y + 1;
  end;
  result := b;
  exit;
end;

function handlePile(pile: specialize TArray<specialize TArray<integer>>; x: integer; y: integer): specialize TArray<specialize TArray<integer>>;
begin
  if (specialize _indexList<integer>(specialize _indexList<integer>(pile, y), x) >= 4) then
  begin
    pile[y][x] := specialize _indexList<integer>(specialize _indexList<integer>(pile, y), x) - 4;
    if (y > 0) then
    begin
      pile[y - 1][x] := specialize _indexList<integer>(specialize _indexList<integer>(pile, y - 1), x) + 1;
      if (specialize _indexList<integer>(specialize _indexList<integer>(pile, y - 1), x) >= 4) then ;
    end;
    if (x > 0) then
    begin
      pile[y][x - 1] := specialize _indexList<integer>(specialize _indexList<integer>(pile, y), x - 1) + 1;
      if (specialize _indexList<integer>(specialize _indexList<integer>(pile, y), x - 1) >= 4) then ;
    end;
    if (y < dim - 1) then
    begin
      pile[y + 1][x] := specialize _indexList<integer>(specialize _indexList<integer>(pile, y + 1), x) + 1;
      if (specialize _indexList<integer>(specialize _indexList<integer>(pile, y + 1), x) >= 4) then ;
    end;
    if (x < dim - 1) then
    begin
      pile[y][x + 1] := specialize _indexList<integer>(specialize _indexList<integer>(pile, y), x + 1) + 1;
      if (specialize _indexList<integer>(specialize _indexList<integer>(pile, y), x + 1) >= 4) then ;
    end;
    pile := handlePile(pile, x, y);
  end;
  result := pile;
  exit;
end;

procedure drawPile(pile: specialize TArray<specialize TArray<integer>>; d: integer);
var
  chars: specialize TArray<Variant>;
  col: integer;
  line: string;
  row: specialize TArray<Variant>;
  v: Variant;
begin
  chars := specialize TArray<Variant>([' ', '░', '▓', '█']);
  row := 0;
  while (row < d) do
  begin
    line := '';
    col := 0;
    while (col < d) do
    begin
      v := specialize _indexList<integer>(specialize _indexList<integer>(pile, row), col);
      if (v > 3) then ;
      line := line + specialize _indexList<Variant>(chars, v);
      col := col + 1;
    end;
    writeln(line);
    row := Concat(row, 1);
  end;
end;

procedure main();
var
  hdim: integer;
  pile: Variant;
begin
  pile := newPile(16);
  hdim := 7;
  pile[hdim][hdim] := 16;
  pile := handlePile(pile, hdim, hdim);
  drawPile(pile, 16);
end;

begin
  dim := 16;
  main();
end.
