// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:13Z
program BestShuffle;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function nextRand(seed: integer): integer;
begin
  result := seed * 1664525 + 1013904223 mod 2147483647;
  exit;
end;

function shuffleChars(s: string; seed: integer): specialize TArray<any>;
var
  chars: specialize TArray<string>;
  i: integer;
  idx: Variant;
  j: Variant;
  res: string;
  sd: Variant;
  tmp: specialize TArray<string>;
begin
  chars := specialize TArray<string>([]);
  i := 0;
  while (i < Length(s)) do
  begin
    chars := specialize _appendList<Variant>(chars, _sliceString(s, i, i + i + 1));
    i := i + 1;
  end;
  sd := seed;
  idx := Length(chars) - 1;
  while (idx > 0) do
  begin
    sd := nextRand(sd);
    j := sd mod idx + 1;
    tmp := chars[idx];
    chars[idx] := chars[j];
    chars[j] := tmp;
    idx := idx - 1;
  end;
  res := '';
  i := 0;
  while (i < Length(chars)) do
  begin
    res := res + chars[i];
    i := i + 1;
  end;
  result := specialize TArray<integer>([res, sd]);
  exit;
end;

function bestShuffle(s: string; seed: integer): specialize TArray<any>;
var
  arr: specialize TArray<string>;
  count: function(p0: Variant): integer is nested;
  i: integer;
  j: Variant;
  out: string;
  r: Variant;
  sd: Variant;
  t: Variant;
  tmp: specialize TArray<string>;
begin
  r := shuffleChars(s, seed);
  t := r[0];
  sd := r[1];
  arr := specialize TArray<string>([]);
  i := 0;
  while (i < Length(t)) do
  begin
    arr := specialize _appendList<Variant>(arr, _sliceString(t, i, i + i + 1));
    i := i + 1;
  end;
  i := 0;
  while (i < Length(arr)) do
  begin
    j := 0;
    while (j < Length(arr)) do
    begin
      if (((i <> j) and (arr[i] <> _sliceString(s, j, j + j + 1))) and (arr[j] <> _sliceString(s, i, i + i + 1))) then
      begin
        tmp := arr[i];
        arr[i] := arr[j];
        arr[j] := tmp;
        break;
      end;
      j := j + 1;
    end;
    i := i + 1;
  end;
  count := 0;
  i := 0;
  while (i < Length(arr)) do
  begin
    if (arr[i] = _sliceString(s, i, i + i + 1)) then ;
    i := i + 1;
  end;
  out := '';
  i := 0;
  while (i < Length(arr)) do
  begin
    out := out + arr[i];
    i := i + 1;
  end;
  result := specialize TArray<integer>([out, sd, count]);
  exit;
end;

function main(): integer;
var
  cnt: Variant;
  i: integer;
  r: Variant;
  seed: integer;
  shuf: Variant;
  ts: specialize TArray<Variant>;
begin
  ts := specialize TArray<string>(['abracadabra', 'seesaw', 'elk', 'grrrrrr', 'up', 'a']);
  seed := 1;
  i := 0;
  while (i < Length(ts)) do
  begin
    r := bestShuffle(ts[i], seed);
    shuf := r[0];
    seed := r[1];
    cnt := r[2];
    writeln(ts[i] + ' -> ' + shuf + ' (' + IntToStr(cnt) + ')');
    i := i + 1;
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
