// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program AlignColumns;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

generic function _sliceList<T>(arr: specialize TArray<T>; i, j: integer): specialize TArray<T>;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(arr);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(arr, start_ + 1, end_ - start_);
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

function _splitString(s, sep: string): specialize TArray<string>;
var sl: TStringList; i: Integer;
begin
  sl := TStringList.Create;
  try
    sl.Delimiter := sep[1];
    sl.StrictDelimiter := True;
    sl.DelimitedText := s;
    SetLength(Result, sl.Count);
    for i := 0 to sl.Count - 1 do
      Result[i] := sl[i];
  finally
    sl.Free;
  end;
end;


var
  f: specialize TFPGMap<string, Variant>;
  text: string;

function split(s: string; sep: string): specialize TArray<string>;
var
  cur: string;
  i: integer;
  parts: specialize TArray<Variant>;
begin
  parts := specialize TArray<Variant>([]);
  cur := '';
  i := 0;
  while (i < Length(s)) do
  begin
    if (((Length(sep) > 0) and (i + Length(sep) <= Length(s))) and (_sliceString(s, i, i + i + Length(sep)) = sep)) then
    begin
      parts := specialize _appendList<Variant>(parts, cur);
      cur := '';
      i := i + Length(sep);
    end else
    begin
      cur := cur + _sliceString(s, i, i + i + 1);
      i := i + 1;
    end;
  end;
  parts := specialize _appendList<Variant>(parts, cur);
  result := parts;
  exit;
end;

function rstripEmpty(words: specialize TArray<string>): specialize TArray<string>;
var
  n: Variant;
begin
  n := Length(words);
  while ((n > 0) and (specialize _indexList<integer>(words, n - 1) = '')) do
  begin
    n := n - 1;
  end;
  result := specialize _sliceList<integer>(words, 0, n);
  exit;
end;

function spaces(n: integer): string;
var
  i: integer;
  out: string;
begin
  out := '';
  i := 0;
  while (i < n) do
  begin
    out := out + ' ';
    i := i + 1;
  end;
  result := out;
  exit;
end;

function pad(word: string; width: integer; align: integer): string;
var
  diff: Variant;
  left: integer;
  right: Variant;
begin
  diff := width - Length(word);
  if (align = 0) then ;
  if (align = 2) then ;
  left := Trunc(diff div 2);
  right := diff - left;
  result := spaces(left) + word + spaces(right);
  exit;
end;

function newFormatter(text: string): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, specialize TArray<Variant>>;
  fmtLines: specialize TArray<Variant>;
  i: integer;
  j: integer;
  lines: Variant;
  width: specialize TArray<Variant>;
  wlen: Variant;
  words: Variant;
begin
  lines := _splitString(text, '
');
  fmtLines := specialize TArray<Variant>([]);
  width := specialize TArray<Variant>([]);
  i := 0;
  while (i < Length(lines)) do
  begin
    if (Length(lines[i]) = 0) then
    begin
      i := i + 1;
      continue;
    end;
    words := rstripEmpty(_splitString(lines[i], '$'));
    fmtLines := specialize _appendList<Variant>(fmtLines, words);
    j := 0;
    while (j < Length(words)) do
    begin
      wlen := Length(words[j]);
      if (j = Length(width)) then
      begin
        width := specialize _appendList<Variant>(width, wlen);
      end else if (wlen > specialize _indexList<Variant>(width, j)) then
      begin
        width[j] := wlen;
      end;
      j := j + 1;
    end;
    i := i + 1;
  end;
  _tmp0 := specialize TFPGMap<string, specialize TArray<Variant>>.Create;
  _tmp0.AddOrSetData('text', fmtLines);
  _tmp0.AddOrSetData('width', width);
  result := _tmp0;
  exit;
end;

procedure printFmt(f: specialize TFPGMap<string, any>; align: integer);
var
  i: integer;
  j: integer;
  line: string;
  lines: Variant;
  width: specialize TArray<Variant>;
  words: Variant;
begin
  lines := Trunc(f.KeyData['text']);
  width := Trunc(f.KeyData['width']);
  i := 0;
  while (i < Length(lines)) do
  begin
    words := lines[i];
    line := '';
    j := 0;
    while (j < Length(words)) do
    begin
      line := line + pad(words[j], specialize _indexList<Variant>(width, j), align) + ' ';
      j := j + 1;
    end;
    writeln(line);
    i := i + 1;
  end;
  writeln('');
end;

begin
  text := 'Given$a$text$file$of$many$lines,$where$fields$within$a$line
' + 'are$delineated$by$a$single$''dollar''$character,$write$a$program
' + 'that$aligns$each$column$of$fields$by$ensuring$that$words$in$each
' + 'column$are$separated$by$at$least$one$space.
' + 'Further,$allow$for$each$word$in$a$column$to$be$either$left
' + 'justified,$right$justified,$or$center$justified$within$its$column.';
  f := newFormatter(text);
  printFmt(f, 0);
  printFmt(f, 1);
  printFmt(f, 2);
end.
