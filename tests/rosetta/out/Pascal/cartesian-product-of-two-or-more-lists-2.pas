// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:19Z
program CartesianProductOfTwoOrMoreLists2;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function listStr(xs: specialize TArray<integer>): string;
var
  i: integer;
  s: string;
begin
  s := '[';
  i := 0;
  while (i < Length(xs)) do
  begin
    s := s + IntToStr(specialize _indexList<integer>(xs, i));
    if (i < Length(xs) - 1) then ;
    i := i + 1;
  end;
  s := s + ']';
  result := s;
  exit;
end;

function llStr(lst: specialize TArray<specialize TArray<integer>>): string;
var
  i: integer;
  s: string;
begin
  s := '[';
  i := 0;
  while (i < Length(lst)) do
  begin
    s := s + listStr(specialize _indexList<integer>(lst, i));
    if (i < Length(lst) - 1) then ;
    i := i + 1;
  end;
  s := s + ']';
  result := s;
  exit;
end;

function cartN(lists: any): specialize TArray<specialize TArray<integer>>;
var
  _tmp0: integer;
  a: specialize TArray<specialize TArray<integer>>;
  c: integer;
  count: function(p0: Variant): integer is nested;
  idx: specialize TArray<integer>;
  j: integer;
  k: Variant;
  n: Variant;
  res: specialize TArray<specialize TArray<integer>>;
  row: specialize TArray<integer>;
begin
  if (lists = Null) then ;
  a := Trunc(lists);
  if (Length(a) = 0) then ;
  c := 1;
  for xs in a do
  begin
    c := c * Length(xs);
  end;
  if (c = 0) then ;
  res := specialize TArray<specialize TArray<integer>>([]);
  idx := specialize TArray<integer>([]);
  for _tmp0 in a do
  begin
    idx := specialize _appendList<Variant>(idx, 0);
  end;
  n := Length(a);
  count := 0;
  while (count < c) do
  begin
    row := specialize TArray<integer>([]);
    j := 0;
    while (j < n) do
    begin
      row := specialize _appendList<Variant>(row, a[j][idx[j]]);
      j := j + 1;
    end;
    res := specialize _appendList<Variant>(res, row);
    k := n - 1;
    while (k >= 0) do
    begin
      idx[k] := idx[k] + 1;
      if (idx[k] < Length(a[k])) then ;
      idx[k] := 0;
      k := k - 1;
    end;
    count := count + 1;
  end;
  result := res;
  exit;
end;

function main(): integer;
begin
  writeln(llStr(cartN(specialize TArray<specialize TArray<integer>>([specialize TArray<integer>([1, 2]), specialize TArray<integer>([3, 4])]))));
  writeln(llStr(cartN(specialize TArray<specialize TArray<integer>>([specialize TArray<integer>([3, 4]), specialize TArray<integer>([1, 2])]))));
  writeln(llStr(cartN(specialize TArray<specialize TArray<integer>>([specialize TArray<integer>([1, 2]), specialize TArray<integer>([])]))));
  writeln(llStr(cartN(specialize TArray<specialize TArray<Variant>>([specialize TArray<integer>([]), specialize TArray<integer>([1, 2])]))));
  writeln('');
  writeln('[');
  for p in cartN(specialize TArray<specialize TArray<integer>>([specialize TArray<integer>([1776, 1789]), specialize TArray<integer>([7, 12]), specialize TArray<integer>([4, 14, 23]), specialize TArray<integer>([0, 1])])) do
  begin
    writeln(' ' + listStr(p));
  end;
  writeln(']');
  writeln(llStr(cartN(specialize TArray<specialize TArray<integer>>([specialize TArray<integer>([1, 2, 3]), specialize TArray<integer>([30]), specialize TArray<integer>([500, 100])]))));
  writeln(llStr(cartN(specialize TArray<specialize TArray<integer>>([specialize TArray<integer>([1, 2, 3]), specialize TArray<integer>([]), specialize TArray<integer>([500, 100])]))));
  writeln('');
  writeln(llStr(cartN(Null)));
  writeln(llStr(cartN(specialize TArray<integer>([]))));
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

begin
  main();
end.
