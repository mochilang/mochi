// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:23Z
program CholeskyDecomposition1;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function sqrtApprox(x: double): double;
var
  guess: Variant;
  i: integer;
begin
  guess := x;
  i := 0;
  while (i < 20) do
  begin
    guess := guess + x div guess div 2;
    i := i + 1;
  end;
  result := guess;
  exit;
end;

function makeSym(order: integer; elements: specialize TArray<double>): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
begin
  _tmp0 := specialize TFPGMap<string, Variant>.Create;
  _tmp0.AddOrSetData('order', order);
  _tmp0.AddOrSetData('ele', elements);
  result := _tmp0;
  exit;
end;

function unpackSym(m: specialize TFPGMap<string, any>): specialize TArray<specialize TArray<double>>;
var
  c: integer;
  ele: Variant;
  idx: integer;
  mat: specialize TArray<specialize TArray<double>>;
  n: Variant;
  r: integer;
  row: specialize TArray<double>;
begin
  n := m.KeyData['order'];
  ele := m.KeyData['ele'];
  mat := specialize TArray<specialize TArray<double>>([]);
  idx := 0;
  r := 0;
  while (r < n) do
  begin
    row := specialize TArray<double>([]);
    c := 0;
    while (c <= r) do
    begin
      row := specialize _appendList<Variant>(row, ele[idx]);
      idx := idx + 1;
      c := c + 1;
    end;
    while (c < n) do
    begin
      row := specialize _appendList<Variant>(row, 0);
      c := c + 1;
    end;
    mat := specialize _appendList<Variant>(mat, row);
    r := r + 1;
  end;
  r := 0;
  while (r < n) do
  begin
    c := r + 1;
    while (c < n) do
    begin
      mat[r][c] := mat[c][r];
      c := c + 1;
    end;
    r := r + 1;
  end;
  result := mat;
  exit;
end;

function printMat(m: specialize TArray<specialize TArray<double>>): integer;
var
  i: integer;
  j: integer;
  line: string;
begin
  i := 0;
  while (i < Length(m)) do
  begin
    line := '';
    j := 0;
    while (j < Length(specialize _indexList<integer>(m, i))) do
    begin
      line := line + IntToStr(specialize _indexList<integer>(specialize _indexList<integer>(m, i), j));
      if (j < Length(specialize _indexList<integer>(m, i)) - 1) then ;
      j := j + 1;
    end;
    writeln(line);
    i := i + 1;
  end;
end;

function printSym(m: specialize TFPGMap<string, any>): integer;
begin
  printMat(unpackSym(m));
end;

function printLower(m: specialize TFPGMap<string, any>): integer;
var
  c: integer;
  ele: Variant;
  idx: integer;
  mat: specialize TArray<specialize TArray<double>>;
  n: Variant;
  r: integer;
  row: specialize TArray<double>;
begin
  n := m.KeyData['order'];
  ele := m.KeyData['ele'];
  mat := specialize TArray<specialize TArray<double>>([]);
  idx := 0;
  r := 0;
  while (r < n) do
  begin
    row := specialize TArray<double>([]);
    c := 0;
    while (c <= r) do
    begin
      row := specialize _appendList<double>(row, ele[idx]);
      idx := idx + 1;
      c := c + 1;
    end;
    while (c < n) do
    begin
      row := specialize _appendList<double>(row, 0);
      c := c + 1;
    end;
    mat := specialize _appendList<specialize TArray<double>>(mat, row);
    r := r + 1;
  end;
  printMat(mat);
end;

function choleskyLower(a: specialize TFPGMap<string, any>): specialize TFPGMap<string, any>;
var
  _tmp1: specialize TFPGMap<string, Variant>;
  ae: Variant;
  ci: integer;
  col: integer;
  cx: integer;
  d: Variant;
  dc: integer;
  dr: integer;
  e: Variant;
  i: integer;
  idx: integer;
  j: integer;
  le: specialize TArray<double>;
  n: Variant;
  row: specialize TArray<double>;
begin
  n := a.KeyData['order'];
  ae := a.KeyData['ele'];
  le := specialize TArray<double>([]);
  idx := 0;
  while (idx < Length(ae)) do
  begin
    le := specialize _appendList<Variant>(le, 0);
    idx := idx + 1;
  end;
  row := 1;
  col := 1;
  dr := 0;
  dc := 0;
  i := 0;
  while (i < Length(ae)) do
  begin
    e := ae[i];
    if (i < dr) then
    begin
      d := e - le[i] div le[dc];
      le[i] := d;
      ci := col;
      cx := dc;
      j := i + 1;
      while (j <= dr) do
      begin
        cx := cx + ci;
        ci := ci + 1;
        le[j] := le[j] + d * le[cx];
        j := j + 1;
      end;
      col := col + 1;
      dc := dc + col;
    end else
    begin
      le[i] := sqrtApprox(e - le[i]);
      row := Concat(row, 1);
      dr := Concat(dr, row);
      col := 1;
      dc := 0;
    end;
    i := i + 1;
  end;
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('order', n);
  _tmp1.AddOrSetData('ele', le);
  result := _tmp1;
  exit;
end;

function demo(a: specialize TFPGMap<string, any>): integer;
var
  l: Variant;
begin
  writeln('A:');
  printSym(a);
  writeln('L:');
  l := choleskyLower(a);
  printLower(l);
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

begin
  demo(makeSym(3, specialize TArray<double>([25, 15, 18, -5, 0, 11])));
  demo(makeSym(4, specialize TArray<double>([18, 22, 70, 54, 86, 174, 42, 62, 134, 106])));
end.
