// Generated by Mochi compiler v0.10.26 on 2025-07-16T10:01:38Z
program Chaocipher;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function indexOf(s: string; ch: string): integer;
var
  i: integer;
begin
  i := 0;
  while (i < Length(s)) do
  begin
    if (_sliceString(s, i, i + 1) = ch) then ;
    i := i + 1;
  end;
  result := -1;
  exit;
end;

function rotate(s: string; n: integer): string;
begin
  result := _sliceString(s, n, Length(s)) + _sliceString(s, 0, n);
  exit;
end;

function scrambleLeft(s: string): string;
begin
  result := _sliceString(s, 0, 1) + _sliceString(s, 2, 14) + _sliceString(s, 1, 2) + _sliceString(s, 14, Length(s));
  exit;
end;

function scrambleRight(s: string): string;
begin
  result := _sliceString(s, 1, 3) + _sliceString(s, 4, 15) + _sliceString(s, 3, 4) + _sliceString(s, 15, Length(s)) + _sliceString(s, 0, 1);
  exit;
end;

function chao(text: string; encode: boolean): string;
var
  ch: Variant;
  i: integer;
  idx: integer;
  left: string;
  out: string;
  right: string;
begin
  left := 'HXUCZVAMDSLKPEFJRIGTWOBNYQ';
  right := 'PTLNBQDEOYSFAVZKGJRIHWXUMC';
  out := '';
  i := 0;
  while (i < Length(text)) do
  begin
    ch := _sliceString(text, i, i + 1);
    idx := 0;
    if encode then
    begin
      idx := indexOf(right, ch);
      out := out + Copy(left, idx + 1, idx + 1 - idx);
    end else
    begin
      idx := indexOf(left, ch);
      out := out + Copy(right, idx + 1, idx + 1 - idx);
    end;
    left := rotate(left, idx);
    right := rotate(right, idx);
    left := scrambleLeft(left);
    right := scrambleRight(right);
    i := i + 1;
  end;
  result := out;
  exit;
end;

function main(): integer;
var
  cipher: Variant;
  plain: string;
begin
  plain := 'WELLDONEISBETTERTHANWELLSAID';
  cipher := chao(plain, True);
  writeln(plain);
  writeln(cipher);
  writeln(chao(cipher, False));
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
