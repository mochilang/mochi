// Generated by Mochi compiler v0.10.26 on 2025-07-16T10:01:24Z
program AvlTree;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function Node(data: integer): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
begin
  _tmp0 := specialize TFPGMap<string, Variant>.Create;
  _tmp0.AddOrSetData('Data', data);
  _tmp0.AddOrSetData('Balance', 0);
  _tmp0.AddOrSetData('Link', specialize TArray<Variant>([Null, Null]));
  result := _tmp0;
  exit;
end;

function getLink(n: specialize TFPGMap<string, any>; dir: integer): any;
begin
  result := Trunc(n.KeyData['Link'])[dir];
  exit;
end;

function setLink(n: specialize TFPGMap<string, any>; dir: integer; v: any): integer;
var
  links: specialize TArray<Variant>;
begin
  links := Trunc(n.KeyData['Link']);
  links[dir] := v;
  n['Link'] := links;
end;

function opp(dir: integer): integer;
begin
  result := 1 - dir;
  exit;
end;

function single(root: specialize TFPGMap<string, any>; dir: integer): specialize TFPGMap<string, any>;
var
  tmp: Variant;
begin
  tmp := getLink(root, opp(dir));
  setLink(root, opp(dir), getLink(tmp, dir));
  setLink(tmp, dir, root);
  result := tmp;
  exit;
end;

function double(root: specialize TFPGMap<string, any>; dir: integer): specialize TFPGMap<string, any>;
var
  tmp: Variant;
begin
  tmp := getLink(getLink(root, opp(dir)), dir);
  setLink(getLink(root, opp(dir)), dir, getLink(tmp, opp(dir)));
  setLink(tmp, opp(dir), getLink(root, opp(dir)));
  setLink(root, opp(dir), tmp);
  tmp := getLink(root, opp(dir));
  setLink(root, opp(dir), getLink(tmp, dir));
  setLink(tmp, dir, root);
  result := tmp;
  exit;
end;

function adjustBalance(root: specialize TFPGMap<string, any>; dir: integer; bal: integer): integer;
var
  n: specialize TFPGMap<string, Variant>;
  nn: specialize TFPGMap<string, Variant>;
begin
  n := Trunc(getLink(root, dir));
  nn := Trunc(getLink(n, opp(dir)));
  if (nn['Balance'] = 0) then
  begin
    root['Balance'] := 0;
    n['Balance'] := 0;
  end else if (nn['Balance'] = bal) then
  begin
    root['Balance'] := -bal;
    n['Balance'] := 0;
  end else
  begin
    root['Balance'] := 0;
    n['Balance'] := bal;
  end;
  nn['Balance'] := 0;
end;

function insertBalance(root: specialize TFPGMap<string, any>; dir: integer): specialize TFPGMap<string, any>;
var
  bal: integer;
  n: specialize TFPGMap<string, Variant>;
begin
  n := Trunc(getLink(root, dir));
  bal := 2 * dir - 1;
  if (n.KeyData['Balance'] = bal) then
  begin
    root['Balance'] := 0;
    n.KeyData['Balance'] := 0;
    result := single(root, opp(dir));
    exit;
  end;
  adjustBalance(root, dir, bal);
  result := double(root, opp(dir));
  exit;
end;

function insertR(root: any; data: integer): specialize TFPGMap<string, any>;
var
  _tmp1: specialize TFPGMap<string, Variant>;
  _tmp2: specialize TFPGMap<string, Variant>;
  _tmp3: specialize TFPGMap<string, Variant>;
  _tmp4: specialize TFPGMap<string, Variant>;
  _tmp5: specialize TFPGMap<string, Variant>;
  dir: integer;
  node: specialize TFPGMap<string, Variant>;
  r: Variant;
begin
  if (root = Null) then ;
  node := Trunc(root);
  dir := 0;
  if (Trunc(node['Data']) < data) then ;
  r := insertR(getLink(node, dir), data);
  setLink(node, dir, r['node']);
  if r['done'] then ;
  node['Balance'] := Trunc(node['Balance']) + 2 * dir - 1;
  if (node['Balance'] = 0) then ;
  if ((node['Balance'] = 1) or (node['Balance'] = -1)) then ;
  _tmp5 := specialize TFPGMap<string, Variant>.Create;
  _tmp5.AddOrSetData('node', insertBalance(node, dir));
  _tmp5.AddOrSetData('done', True);
  result := _tmp5;
  exit;
end;

function Insert(tree: any; data: integer): any;
var
  r: Variant;
begin
  r := insertR(tree, data);
  result := r['node'];
  exit;
end;

function removeBalance(root: specialize TFPGMap<string, any>; dir: integer): specialize TFPGMap<string, any>;
var
  _tmp6: specialize TFPGMap<string, Variant>;
  _tmp7: specialize TFPGMap<string, Variant>;
  _tmp8: specialize TFPGMap<string, Variant>;
  bal: integer;
  n: specialize TFPGMap<string, Variant>;
begin
  n := Trunc(getLink(root, opp(dir)));
  bal := 2 * dir - 1;
  if (n.KeyData['Balance'] = -bal) then
  begin
    root['Balance'] := 0;
    n.KeyData['Balance'] := 0;
    _tmp6 := specialize TFPGMap<string, Variant>.Create;
    _tmp6.AddOrSetData('node', single(root, dir));
    _tmp6.AddOrSetData('done', False);
    result := _tmp6;
    exit;
  end;
  if (n.KeyData['Balance'] = bal) then
  begin
    adjustBalance(root, opp(dir), -bal);
    _tmp7 := specialize TFPGMap<string, Variant>.Create;
    _tmp7.AddOrSetData('node', double(root, dir));
    _tmp7.AddOrSetData('done', False);
    result := _tmp7;
    exit;
  end;
  root['Balance'] := -bal;
  n.KeyData['Balance'] := bal;
  _tmp8 := specialize TFPGMap<string, Variant>.Create;
  _tmp8.AddOrSetData('node', single(root, dir));
  _tmp8.AddOrSetData('done', True);
  result := _tmp8;
  exit;
end;

function removeR(root: any; data: integer): specialize TFPGMap<string, any>;
var
  _tmp10: specialize TFPGMap<string, Variant>;
  _tmp11: specialize TFPGMap<string, Variant>;
  _tmp12: specialize TFPGMap<string, Variant>;
  _tmp13: specialize TFPGMap<string, Variant>;
  _tmp14: specialize TFPGMap<string, Variant>;
  _tmp9: specialize TFPGMap<string, Variant>;
  dir: integer;
  heir: Variant;
  node: specialize TFPGMap<string, Variant>;
  r: Variant;
begin
  if (root = Null) then ;
  node := Trunc(root);
  if (Trunc(node.KeyData['Data']) = data) then
  begin
    if (getLink(node, 0) = Null) then ;
    if (getLink(node, 1) = Null) then ;
    heir := getLink(node, 0);
    while (getLink(heir, 1) <> Null) do
    begin
      heir := getLink(heir, 1);
    end;
    node.KeyData['Data'] := heir['Data'];
    data := Trunc(heir['Data']);
  end;
  dir := 0;
  if (Trunc(node.KeyData['Data']) < data) then ;
  r := removeR(getLink(node, dir), data);
  setLink(node, dir, r['node']);
  if r['done'] then ;
  node.KeyData['Balance'] := Trunc(node.KeyData['Balance']) + 1 - 2 * dir;
  if ((node.KeyData['Balance'] = 1) or (node.KeyData['Balance'] = -1)) then ;
  if (node.KeyData['Balance'] = 0) then ;
  result := removeBalance(node, dir);
  exit;
end;

function Remove(tree: any; data: integer): any;
var
  r: Variant;
begin
  r := removeR(tree, data);
  result := r['node'];
  exit;
end;

function indentStr(n: integer): string;
var
  i: integer;
  s: string;
begin
  s := '';
  i := 0;
  while (i < n) do
  begin
    s := s + ' ';
    i := i + 1;
  end;
  result := s;
  exit;
end;

function dumpNode(node: any; indent: integer; comma: boolean): integer;
var
  _end: Variant;
  line: Variant;
  sp: Variant;
begin
  sp := indentStr(indent);
  if (node = Null) then
  begin
    line := sp + 'null';
    if comma then ;
    writeln(line);
  end else
  begin
    writeln(sp + '{');
    writeln(indentStr(indent + 3) + '"Data": ' + IntToStr(node.KeyData['Data']) + ',');
    writeln(indentStr(indent + 3) + '"Balance": ' + IntToStr(node.KeyData['Balance']) + ',');
    writeln(indentStr(indent + 3) + '"Link": [');
    dumpNode(getLink(node, 0), indent + 6, True);
    dumpNode(getLink(node, 1), indent + 6, False);
    writeln(indentStr(indent + 3) + ']');
    _end := sp + '}';
    if comma then ;
    writeln(_end);
  end;
end;

function dump(node: any; indent: integer): integer;
begin
  dumpNode(node, indent, False);
end;

function main(): integer;
var
  t: specialize TFPGMap<string, Variant>;
  tree: Variant;
begin
  tree := Null;
  writeln('Empty tree:');
  dump(tree, 0);
  writeln('');
  writeln('Insert test:');
  tree := Insert(tree, 3);
  tree := Insert(tree, 1);
  tree := Insert(tree, 4);
  tree := Insert(tree, 1);
  tree := Insert(tree, 5);
  dump(tree, 0);
  writeln('');
  writeln('Remove test:');
  tree := Remove(tree, 3);
  tree := Remove(tree, 1);
  t := Trunc(tree);
  t['Balance'] := 0;
  tree := t;
  dump(tree, 0);
end;

begin
  main();
end.
