// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program AbelianSandpileModelIdentity;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;


var
  s1: specialize TArray<integer>;
  s2: specialize TArray<integer>;
  s3: specialize TArray<integer>;
  s3_a: specialize TArray<integer>;
  s3_b: specialize TArray<integer>;
  s3_id: specialize TArray<integer>;
  s4: specialize TArray<integer>;
  s4b: specialize TArray<integer>;
  s5: specialize TArray<integer>;

function neighborsList(): specialize TArray<specialize TArray<integer>>;
begin
  result := specialize TArray<specialize TArray<integer>>([specialize TArray<integer>([1, 3]), specialize TArray<integer>([0, 2, 4]), specialize TArray<integer>([1, 5]), specialize TArray<integer>([0, 4, 6]), specialize TArray<integer>([1, 3, 5, 7]), specialize TArray<integer>([2, 4, 8]), specialize TArray<integer>([3, 7]), specialize TArray<integer>([4, 6, 8]), specialize TArray<integer>([5, 7])]);
  exit;
end;

function plus(a: specialize TArray<integer>; b: specialize TArray<integer>): specialize TArray<integer>;
var
  i: integer;
  res: specialize TArray<Variant>;
begin
  res := specialize TArray<Variant>([]);
  i := 0;
  while (i < Length(a)) do
  begin
    res := specialize _appendList<Variant>(res, specialize _indexList<integer>(a, i) + specialize _indexList<integer>(b, i));
    i := i + 1;
  end;
  result := res;
  exit;
end;

function isStable(p: specialize TArray<integer>): boolean;
var
  v: Variant;
begin
  for v in p do
  begin
    if (v > 3) then ;
  end;
  result := True;
  exit;
end;

function topple(p: specialize TArray<integer>): integer;
var
  i: integer;
  j: Variant;
  nbs: Variant;
  neighbors: Variant;
begin
  neighbors := neighborsList();
  i := 0;
  while (i < Length(p)) do
  begin
    if (specialize _indexList<integer>(p, i) > 3) then
    begin
      p[i] := specialize _indexList<integer>(p, i) - 4;
      nbs := neighbors[i];
      for j in nbs do
      begin
        p[j] := specialize _indexList<integer>(p, j) + 1;
      end;
      result := 0;
      exit;
    end;
    i := i + 1;
  end;
  result := 0;
  exit;
end;

function pileString(p: specialize TArray<integer>): string;
var
  c: integer;
  r: integer;
  s: string;
begin
  s := '';
  r := 0;
  while (r < 3) do
  begin
    c := 0;
    while (c < 3) do
    begin
      s := s + IntToStr(specialize _indexList<integer>(p, 3 * r + c)) + ' ';
      c := c + 1;
    end;
    s := s + '
';
    r := r + 1;
  end;
  result := s;
  exit;
end;

begin
  writeln('Avalanche of topplings:
');
  s4 := specialize TArray<integer>([4, 3, 3, 3, 1, 2, 0, 2, 3]);
  writeln(pileString(s4));
  while not isStable(s4) do
  begin
    topple(s4);
    writeln(pileString(s4));
  end;
  writeln('Commutative additions:
');
  s1 := specialize TArray<integer>([1, 2, 0, 2, 1, 1, 0, 1, 3]);
  s2 := specialize TArray<integer>([2, 1, 3, 1, 0, 1, 0, 1, 0]);
  s3_a := plus(s1, s2);
  while not isStable(s3_a) do
  begin
    topple(s3_a);
  end;
  s3_b := plus(s2, s1);
  while not isStable(s3_b) do
  begin
    topple(s3_b);
  end;
  writeln(pileString(s1) + '
plus

' + pileString(s2) + '
equals

' + pileString(s3_a));
  writeln('and

' + pileString(s2) + '
plus

' + pileString(s1) + '
also equals

' + pileString(s3_b));
  writeln('Addition of identity sandpile:
');
  s3 := specialize TArray<integer>([3, 3, 3, 3, 3, 3, 3, 3, 3]);
  s3_id := specialize TArray<integer>([2, 1, 2, 1, 0, 1, 2, 1, 2]);
  s4b := plus(s3, s3_id);
  while not isStable(s4b) do
  begin
    topple(s4b);
  end;
  writeln(pileString(s3) + '
plus

' + pileString(s3_id) + '
equals

' + pileString(s4b));
  writeln('Addition of identities:
');
  s5 := plus(s3_id, s3_id);
  while not isStable(s5) do
  begin
    topple(s5);
  end;
  writeln(pileString(s3_id) + '
plus

' + pileString(s3_id) + '
equals

' + pileString(s5));
end.
