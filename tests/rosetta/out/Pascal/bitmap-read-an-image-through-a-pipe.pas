// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:16Z
program BitmapReadAnImageThroughAPipe;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function parseIntStr(str: string): integer;
var
  _tmp0: specialize TFPGMap<string, integer>;
  digits: specialize TFPGMap<Variant, Variant>;
  i: integer;
  n: integer;
  neg: boolean;
begin
  i := 0;
  neg := False;
  if ((Length(str) > 0) and (_sliceString(str, 0, 1) = '-')) then
  begin
    neg := True;
    i := 1;
  end;
  n := 0;
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  _tmp0.AddOrSetData('0', 0);
  _tmp0.AddOrSetData('1', 1);
  _tmp0.AddOrSetData('2', 2);
  _tmp0.AddOrSetData('3', 3);
  _tmp0.AddOrSetData('4', 4);
  _tmp0.AddOrSetData('5', 5);
  _tmp0.AddOrSetData('6', 6);
  _tmp0.AddOrSetData('7', 7);
  _tmp0.AddOrSetData('8', 8);
  _tmp0.AddOrSetData('9', 9);
  digits := _tmp0;
  while (i < Length(str)) do
  begin
    n := n * 10 + digits[_sliceString(str, i, i + 1)];
    i := i + 1;
  end;
  if neg then ;
  result := n;
  exit;
end;

function splitWs(s: string): specialize TArray<string>;
var
  ch: Variant;
  cur: string;
  i: integer;
  parts: specialize TArray<string>;
begin
  parts := specialize TArray<string>([]);
  cur := '';
  i := 0;
  while (i < Length(s)) do
  begin
    ch := _sliceString(s, i, i + i + 1);
    if ((((ch = ' ') or (ch = '
')) or (ch = '  ')) or (ch = '')) then
    begin
      if (Length(cur) > 0) then
      begin
        parts := specialize _appendList<Variant>(parts, cur);
        cur := '';
      end;
    end else
    begin
      cur := cur + ch;
    end;
    i := i + 1;
  end;
  if (Length(cur) > 0) then ;
  result := parts;
  exit;
end;

function parsePpm(data: string): specialize TFPGMap<string, any>;
var
  _tmp1: specialize TFPGMap<string, boolean>;
  _tmp2: specialize TFPGMap<string, Variant>;
  h: Variant;
  i: integer;
  magic: Variant;
  maxv: Variant;
  px: specialize TArray<integer>;
  toks: Variant;
  w: Variant;
begin
  toks := splitWs(data);
  if (Length(toks) < 4) then ;
  magic := toks[0];
  w := parseIntStr(toks[1]);
  h := parseIntStr(toks[2]);
  maxv := parseIntStr(toks[3]);
  px := specialize TArray<integer>([]);
  i := 4;
  while (i < Length(toks)) do
  begin
    px := specialize _appendList<Variant>(px, parseIntStr(toks[i]));
    i := i + 1;
  end;
  _tmp2 := specialize TFPGMap<string, Variant>.Create;
  _tmp2.AddOrSetData('magic', magic);
  _tmp2.AddOrSetData('w', w);
  _tmp2.AddOrSetData('h', h);
  _tmp2.AddOrSetData('max', maxv);
  _tmp2.AddOrSetData('px', px);
  result := _tmp2;
  exit;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

var
  img: specialize TFPGMap<string, Variant>;
  ppmData: string;

begin
  ppmData := 'P3
2 2
1
0 1 1 0 1 0 0 1 1 1 0 0
';
  img := parsePpm(ppmData);
  writeln('width=' + IntToStr(img.KeyData['w']) + ' height=' + IntToStr(img.KeyData['h']));
end.
