// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:13Z
program BabylonianSpiral;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function push(h: specialize TArray<specialize TFPGMap<string, integer>>; it: specialize TFPGMap<string, integer>): specialize TArray<specialize TFPGMap<string, integer>>;
var
  i: Variant;
  tmp: Variant;
begin
  h := specialize _appendList<Variant>(h, it);
  i := Length(h) - 1;
  while ((i > 0) and (specialize _indexList<integer>(specialize _indexList<integer>(h, i - 1), 's') > specialize _indexList<integer>(specialize _indexList<integer>(h, i), 's'))) do
  begin
    tmp := specialize _indexList<integer>(h, i - 1);
    h[i - 1] := specialize _indexList<integer>(h, i);
    h[i] := tmp;
    i := i - 1;
  end;
  result := h;
  exit;
end;

function step(h: specialize TArray<specialize TFPGMap<string, integer>>; nv: integer; dir: specialize TArray<integer>): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
  _tmp1: specialize TFPGMap<string, Variant>;
  _tmp2: specialize TFPGMap<string, Variant>;
  best: Variant;
  bestDot: integer;
  cross: Variant;
  dot: Variant;
  it: Variant;
  list: specialize TArray<specialize TArray<integer>>;
  s: Variant;
  temp: specialize TArray<specialize TArray<integer>>;
  v: specialize TArray<specialize TArray<integer>>;
begin
  while ((Length(h) = 0) or (nv * nv <= specialize _indexList<integer>(specialize _indexList<integer>(h, 0), 's'))) do
  begin
    _tmp0 := specialize TFPGMap<string, Variant>.Create;
    _tmp0.AddOrSetData('s', nv * nv);
    _tmp0.AddOrSetData('a', nv);
    _tmp0.AddOrSetData('b', 0);
    h := push(h, _tmp0);
    nv := nv + 1;
  end;
  s := specialize _indexList<integer>(specialize _indexList<integer>(h, 0), 's');
  v := specialize TArray<specialize TArray<integer>>([]);
  while ((Length(h) > 0) and (specialize _indexList<integer>(specialize _indexList<integer>(h, 0), 's') = s)) do
  begin
    it := specialize _indexList<integer>(h, 0);
    h := specialize _sliceList<integer>(h, 1, Length(h));
    v := specialize _appendList<Variant>(v, specialize TArray<Variant>([it['a'], it['b']]));
    if (it['a'] > it['b']) then ;
  end;
  list := specialize TArray<specialize TArray<integer>>([]);
  for p in v do
  begin
    list := specialize _appendList<Variant>(list, p);
  end;
  temp := list;
  for p in temp do
  begin
    if (p[0] <> p[1]) then ;
  end;
  temp := list;
  for p in temp do
  begin
    if (p[1] <> 0) then ;
  end;
  temp := list;
  for p in temp do
  begin
    if (p[0] <> 0) then ;
  end;
  bestDot := -999999999;
  best := dir;
  for p in list do
  begin
    cross := p[0] * specialize _indexList<integer>(dir, 1) - p[1] * specialize _indexList<integer>(dir, 0);
    if (cross >= 0) then
    begin
      dot := p[0] * specialize _indexList<integer>(dir, 0) + p[1] * specialize _indexList<integer>(dir, 1);
      if (dot > bestDot) then
      begin
        bestDot := dot;
        best := p;
      end;
    end;
  end;
  _tmp2 := specialize TFPGMap<string, Variant>.Create;
  _tmp2.AddOrSetData('d', best);
  _tmp2.AddOrSetData('heap', h);
  _tmp2.AddOrSetData('n', nv);
  result := _tmp2;
  exit;
end;

function positions(n: integer): specialize TArray<specialize TArray<integer>>;
var
  dir: specialize TArray<integer>;
  heap: specialize TArray<specialize TFPGMap<string, integer>>;
  i: Variant;
  nv: integer;
  pos: specialize TArray<specialize TArray<integer>>;
  st: Variant;
  x: integer;
  y: integer;
begin
  pos := specialize TArray<specialize TArray<integer>>([]);
  x := 0;
  y := 0;
  dir := specialize TArray<integer>([0, 1]);
  heap := specialize TArray<specialize TFPGMap<string, integer>>([]);
  nv := 1;
  i := 0;
  while (i < n) do
  begin
    pos := specialize _appendList<Variant>(pos, specialize TArray<Variant>([x, y]));
    st := step(heap, nv, dir);
    dir := Trunc(st['d']);
    heap := Trunc(st['heap']);
    nv := Trunc(st['n']);
    x := x + dir[0];
    y := y + dir[1];
    i := i + 1;
  end;
  result := pos;
  exit;
end;

function pad(s: string; w: integer): string;
var
  r: Variant;
begin
  r := s;
  while (Length(r) < w) do
  begin
    r := r + ' ';
  end;
  result := r;
  exit;
end;

function main(): integer;
var
  i: Variant;
  line: string;
  p: Variant;
  pts: Variant;
  s: Variant;
begin
  pts := positions(40);
  writeln('The first 40 Babylonian spiral points are:');
  line := '';
  i := 0;
  while (i < Length(pts)) do
  begin
    p := pts[i];
    s := pad('(' + IntToStr(p[0]) + ', ' + IntToStr(p[1]) + ')', 10);
    line := line + s;
    if (i + 1 mod 10 = 0) then
    begin
      writeln(line);
      line := '';
    end;
    i := i + 1;
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

generic function _sliceList<T>(arr: specialize TArray<T>; i, j: integer): specialize TArray<T>;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(arr);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(arr, start_ + 1, end_ - start_);
end;

begin
  main();
end.
