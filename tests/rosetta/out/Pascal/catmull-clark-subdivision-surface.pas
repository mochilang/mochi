// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:21Z
program CatmullClarkSubdivisionSurface;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;
type Point = record
  x: double;
  y: double;
  z: double;
end;
type Edge = record
  pn1: integer;
  pn2: integer;
  fn1: integer;
  fn2: integer;
  cp: Point;
end;
type PointEx = record
  p: Point;
  n: integer;
end;

function indexOf(s: string; ch: string): integer;
var
  i: integer;
begin
  i := 0;
  while (i < Length(s)) do
  begin
    if (_sliceString(s, i, i + i + 1) = ch) then ;
    i := i + 1;
  end;
  result := -1;
  exit;
end;

function fmt4(x: double): string;
var
  decs: Variant;
  dot: Variant;
  s: Variant;
  y: Variant;
begin
  y := x * 10000;
  if (y >= 0) then
  begin
    y := y + 0.5;
  end else
  begin
    y := y - 0.5;
  end;
  y := Double(Trunc(y)) / 10000;
  s := IntToStr(y);
  dot := indexOf(s, '.');
  if (dot = 0 - 1) then
  begin
    s := s + '.0000';
  end else
  begin
    decs := Length(s) - dot - 1;
    if (decs > 4) then
    begin
      s := _sliceString(s, 0, 0 + dot + 5);
    end else
    begin
      while (decs < 4) do
      begin
        s := s + '0';
        decs := decs + 1;
      end;
    end;
  end;
  if (x >= 0) then ;
  result := s;
  exit;
end;

function fmt2(n: integer): string;
var
  s: Variant;
begin
  s := IntToStr(n);
  if (Length(s) < 2) then ;
  result := s;
  exit;
end;

function sumPoint(p1: Point; p2: Point): Point;
var
  _tmp0: Point;
begin
  _tmp0.x := p1.x + p2.x;
  _tmp0.y := p1.y + p2.y;
  _tmp0.z := p1.z + p2.z;
  result := _tmp0;
  exit;
end;

function mulPoint(p: Point; m: double): Point;
var
  _tmp1: Point;
begin
  _tmp1.x := p.x * m;
  _tmp1.y := p.y * m;
  _tmp1.z := p.z * m;
  result := _tmp1;
  exit;
end;

function divPoint(p: Point; d: double): Point;
begin
  result := mulPoint(p, 1 div d);
  exit;
end;

function centerPoint(p1: Point; p2: Point): Point;
begin
  result := divPoint(sumPoint(p1, p2), 2);
  exit;
end;

function getFacePoints(points: specialize TArray<Point>; faces: specialize TArray<specialize TArray<integer>>): specialize TArray<Point>;
var
  _tmp2: Point;
  face: Variant;
  facePoints: specialize TArray<integer>;
  fp: Variant;
  i: integer;
begin
  facePoints := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(faces)) do
  begin
    face := specialize _indexList<integer>(faces, i);
    _tmp2.x := 0;
    _tmp2.y := 0;
    _tmp2.z := 0;
    fp := _tmp2;
    for idx in face do
    begin
      fp := sumPoint(fp, specialize _indexList<integer>(points, idx));
    end;
    fp := divPoint(fp, Double(Length(face)));
    facePoints := specialize _appendList<Variant>(facePoints, fp);
    i := i + 1;
  end;
  result := facePoints;
  exit;
end;

function sortEdges(edges: specialize TArray<specialize TArray<integer>>): specialize TArray<specialize TArray<integer>>;
var
  e: Variant;
  idx: integer;
  j: integer;
  k: integer;
  min: function(p0: Variant): Variant is nested;
  out: specialize TArray<specialize TArray<integer>>;
  res: specialize TArray<specialize TArray<integer>>;
  tmp: Variant;
begin
  res := specialize TArray<specialize TArray<integer>>([]);
  tmp := edges;
  while (Length(tmp) > 0) do
  begin
    min := tmp[0];
    idx := 0;
    j := 1;
    while (j < Length(tmp)) do
    begin
      e := tmp[j];
      if ((e[0] < min[0]) or ((e[0] = min[0]) and ((e[1] < min[1]) or ((e[1] = min[1]) and (e[2] < min[2]))))) then
      begin
        min := e;
        idx := j;
      end;
      j := j + 1;
    end;
    res := specialize _appendList<Variant>(res, min);
    out := specialize TArray<specialize TArray<integer>>([]);
    k := 0;
    while (k < Length(tmp)) do
    begin
      if (k <> idx) then ;
      k := k + 1;
    end;
    tmp := out;
  end;
  result := res;
  exit;
end;

function getEdgesFaces(points: specialize TArray<Point>; faces: specialize TArray<specialize TArray<integer>>): specialize TArray<Edge>;
var
  _tmp3: Edge;
  cp: Variant;
  e1: specialize TArray<specialize TArray<integer>>;
  e2: specialize TArray<specialize TArray<integer>>;
  edges: specialize TArray<specialize TArray<integer>>;
  edgesCenters: specialize TArray<integer>;
  face: Variant;
  fnum: integer;
  idx: integer;
  merged: specialize TArray<specialize TArray<integer>>;
  numP: Variant;
  p1: Variant;
  p2: Variant;
  pi: integer;
  pn1: Variant;
  pn2: integer;
  tmpn: Variant;
begin
  edges := specialize TArray<specialize TArray<integer>>([]);
  fnum := 0;
  while (fnum < Length(faces)) do
  begin
    face := specialize _indexList<integer>(faces, fnum);
    numP := Length(face);
    pi := 0;
    while (pi < numP) do
    begin
      pn1 := face[pi];
      pn2 := 0;
      if (pi < numP - 1) then
      begin
        pn2 := face[pi + 1];
      end else
      begin
        pn2 := face[0];
      end;
      if (pn1 > pn2) then
      begin
        tmpn := pn1;
        pn1 := pn2;
        pn2 := tmpn;
      end;
      edges := specialize _appendList<Variant>(edges, specialize TArray<Variant>([pn1, pn2, fnum]));
      pi := pi + 1;
    end;
    fnum := fnum + 1;
  end;
  edges := sortEdges(edges);
  merged := specialize TArray<specialize TArray<integer>>([]);
  idx := 0;
  while (idx < Length(edges)) do
  begin
    e1 := edges[idx];
    if (idx < Length(edges) - 1) then
    begin
      e2 := edges[idx + 1];
      if ((e1[0] = e2[0]) and (e1[1] = e2[1])) then
      begin
        merged := specialize _appendList<Variant>(merged, specialize TArray<Variant>([e1[0], e1[1], e1[2], e2[2]]));
        idx := idx + 2;
        continue;
      end;
    end;
    merged := specialize _appendList<Variant>(merged, specialize TArray<Variant>([e1[0], e1[1], e1[2], -1]));
    idx := idx + 1;
  end;
  edgesCenters := specialize TArray<integer>([]);
  for me in merged do
  begin
    p1 := specialize _indexList<integer>(points, me[0]);
    p2 := specialize _indexList<integer>(points, me[1]);
    cp := centerPoint(p1, p2);
    _tmp3.pn1 := me[0];
    _tmp3.pn2 := me[1];
    _tmp3.fn1 := me[2];
    _tmp3.fn2 := me[3];
    _tmp3.cp := cp;
    edgesCenters := specialize _appendList<Variant>(edgesCenters, _tmp3);
  end;
  result := edgesCenters;
  exit;
end;

function getEdgePoints(points: specialize TArray<Point>; edgesFaces: specialize TArray<Edge>; facePoints: specialize TArray<Point>): specialize TArray<Point>;
var
  cfp: Variant;
  cp: Variant;
  edge: Variant;
  edgePoints: specialize TArray<integer>;
  fp1: specialize TArray<integer>;
  fp2: specialize TArray<integer>;
  i: integer;
begin
  edgePoints := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(edgesFaces)) do
  begin
    edge := specialize _indexList<integer>(edgesFaces, i);
    cp := edge.cp;
    fp1 := specialize _indexList<integer>(facePoints, edge.fn1);
    fp2 := fp1;
    if (edge.fn2 <> 0 - 1) then ;
    cfp := centerPoint(fp1, fp2);
    edgePoints := specialize _appendList<Variant>(edgePoints, centerPoint(cp, cfp));
    i := i + 1;
  end;
  result := edgePoints;
  exit;
end;

function getAvgFacePoints(points: specialize TArray<Point>; faces: specialize TArray<specialize TArray<integer>>; facePoints: specialize TArray<Point>): specialize TArray<Point>;
var
  _tmp4: PointEx;
  _tmp5: Point;
  _tmp6: PointEx;
  avg: function(p0: Variant): double is nested;
  fnum: integer;
  fp: Variant;
  i: integer;
  j: integer;
  numP: Variant;
  temp: specialize TArray<integer>;
  tp: specialize TArray<integer>;
begin
  numP := Length(points);
  temp := specialize TArray<integer>([]);
  i := 0;
  while (i < numP) do
  begin
    _tmp5.x := 0;
    _tmp5.y := 0;
    _tmp5.z := 0;
    _tmp4.p := _tmp5;
    _tmp4.n := 0;
    temp := specialize _appendList<Variant>(temp, _tmp4);
    i := i + 1;
  end;
  fnum := 0;
  while (fnum < Length(faces)) do
  begin
    fp := specialize _indexList<integer>(facePoints, fnum);
    for pn in specialize _indexList<integer>(faces, fnum) do
    begin
      tp := temp[pn];
      _tmp6.p := sumPoint(tp.p, fp);
      _tmp6.n := tp.n + 1;
      temp[pn] := _tmp6;
    end;
    fnum := fnum + 1;
  end;
  avg := specialize TArray<integer>([]);
  j := 0;
  while (j < numP) do
  begin
    tp := temp[j];
    avg := specialize _appendList<Variant>(avg, divPoint(tp.p, Double(tp.n)));
    j := j + 1;
  end;
  result := avg;
  exit;
end;

function getAvgMidEdges(points: specialize TArray<Point>; edgesFaces: specialize TArray<Edge>): specialize TArray<Point>;
var
  _tmp7: PointEx;
  _tmp8: Point;
  _tmp9: PointEx;
  arr: specialize TArray<Variant>;
  avg: function(p0: Variant): double is nested;
  cp: Variant;
  i: integer;
  j: integer;
  numP: Variant;
  temp: specialize TArray<integer>;
  tp: specialize TArray<integer>;
begin
  numP := Length(points);
  temp := specialize TArray<integer>([]);
  i := 0;
  while (i < numP) do
  begin
    _tmp8.x := 0;
    _tmp8.y := 0;
    _tmp8.z := 0;
    _tmp7.p := _tmp8;
    _tmp7.n := 0;
    temp := specialize _appendList<integer>(temp, _tmp7);
    i := i + 1;
  end;
  for edge in edgesFaces do
  begin
    cp := edge.cp;
    arr := specialize TArray<Variant>([edge.pn1, edge.pn2]);
    for pn in arr do
    begin
      tp := specialize _indexList<integer>(temp, pn);
      _tmp9.p := sumPoint(tp.p, cp);
      _tmp9.n := Concat(tp.n, 1);
      temp[pn] := _tmp9;
    end;
  end;
  avg := specialize TArray<integer>([]);
  j := 0;
  while (j < numP) do
  begin
    tp := specialize _indexList<integer>(temp, j);
    avg := specialize _appendList<Variant>(avg, divPoint(tp.p, Double(tp.n)));
    j := j + 1;
  end;
  result := avg;
  exit;
end;

function getPointsFaces(points: specialize TArray<Point>; faces: specialize TArray<specialize TArray<integer>>): specialize TArray<integer>;
var
  fnum: integer;
  i: integer;
  pf: specialize TArray<integer>;
begin
  pf := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(points)) do
  begin
    pf := specialize _appendList<Variant>(pf, 0);
    i := i + 1;
  end;
  fnum := 0;
  while (fnum < Length(faces)) do
  begin
    for pn in specialize _indexList<integer>(faces, fnum) do
    begin
      pf[pn] := pf[pn] + 1;
    end;
    fnum := fnum + 1;
  end;
  result := pf;
  exit;
end;

function getNewPoints(points: specialize TArray<Point>; pf: specialize TArray<integer>; afp: specialize TArray<Point>; ame: specialize TArray<Point>): specialize TArray<Point>;
var
  i: integer;
  m1: Variant;
  m2: double;
  m3: double;
  n: double;
  newPts: specialize TArray<integer>;
  old: Variant;
  p1: Variant;
  p2: Variant;
  p3: Variant;
begin
  newPts := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(points)) do
  begin
    n := Double(specialize _indexList<integer>(pf, i));
    m1 := n - 3 div n;
    m2 := 1 div n;
    m3 := 2 div n;
    old := specialize _indexList<integer>(points, i);
    p1 := mulPoint(old, m1);
    p2 := mulPoint(specialize _indexList<integer>(afp, i), m2);
    p3 := mulPoint(specialize _indexList<integer>(ame, i), m3);
    newPts := specialize _appendList<Variant>(newPts, sumPoint(sumPoint(p1, p2), p3));
    i := i + 1;
  end;
  result := newPts;
  exit;
end;

function key(a: integer; b: integer): string;
begin
  if (a < b) then ;
  result := IntToStr(b) + ',' + IntToStr(a);
  exit;
end;

function cmcSubdiv(points: specialize TArray<Point>; faces: specialize TArray<specialize TArray<integer>>): specialize TArray<any>;
var
  _tmp10: specialize TFPGMap<string, integer>;
  a: Variant;
  ab: specialize TFPGMap<string, integer>;
  avgFacePoints: Variant;
  avgMidEdges: Variant;
  b: Variant;
  bc: specialize TFPGMap<string, integer>;
  c: Variant;
  cd: specialize TFPGMap<string, integer>;
  d: Variant;
  da: specialize TFPGMap<string, integer>;
  e: Variant;
  edgePointNums: specialize TFPGMap<string, integer>;
  edgePoints: specialize TArray<integer>;
  edgesFaces: Variant;
  facePointNums: specialize TArray<integer>;
  facePoints: specialize TArray<integer>;
  fnum: integer;
  fpnum: specialize TArray<integer>;
  idx: integer;
  newFaces: specialize TArray<specialize TArray<integer>>;
  newPoints: Variant;
  nextPoint: Variant;
  oldFace: Variant;
  pointsFaces: Variant;
begin
  facePoints := getFacePoints(points, faces);
  edgesFaces := getEdgesFaces(points, faces);
  edgePoints := getEdgePoints(points, edgesFaces, facePoints);
  avgFacePoints := getAvgFacePoints(points, faces, facePoints);
  avgMidEdges := getAvgMidEdges(points, edgesFaces);
  pointsFaces := getPointsFaces(points, faces);
  newPoints := getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges);
  facePointNums := specialize TArray<integer>([]);
  nextPoint := Length(newPoints);
  for fp in facePoints do
  begin
    newPoints := specialize _appendList<Variant>(newPoints, fp);
    facePointNums := specialize _appendList<Variant>(facePointNums, nextPoint);
    nextPoint := nextPoint + 1;
  end;
  _tmp10 := specialize TFPGMap<string, integer>.Create;
  edgePointNums := _tmp10;
  idx := 0;
  while (idx < Length(edgesFaces)) do
  begin
    e := edgesFaces[idx];
    newPoints := specialize _appendList<Variant>(newPoints, specialize _indexList<integer>(edgePoints, idx));
    edgePointNums[key(e.pn1, e.pn2)] := nextPoint;
    nextPoint := nextPoint + 1;
    idx := idx + 1;
  end;
  newFaces := specialize TArray<specialize TArray<integer>>([]);
  fnum := 0;
  while (fnum < Length(faces)) do
  begin
    oldFace := specialize _indexList<integer>(faces, fnum);
    if (Length(oldFace) = 4) then
    begin
      a := oldFace[0];
      b := oldFace[1];
      c := oldFace[2];
      d := oldFace[3];
      fpnum := facePointNums[fnum];
      ab := edgePointNums[key(a, b)];
      da := edgePointNums[key(d, a)];
      bc := edgePointNums[key(b, c)];
      cd := edgePointNums[key(c, d)];
      newFaces := specialize _appendList<Variant>(newFaces, specialize TArray<Variant>([a, ab, fpnum, da]));
      newFaces := specialize _appendList<Variant>(newFaces, specialize TArray<Variant>([b, bc, fpnum, ab]));
      newFaces := specialize _appendList<Variant>(newFaces, specialize TArray<Variant>([c, cd, fpnum, bc]));
      newFaces := specialize _appendList<Variant>(newFaces, specialize TArray<Variant>([d, da, fpnum, cd]));
    end;
    fnum := fnum + 1;
  end;
  result := specialize TArray<integer>([newPoints, newFaces]);
  exit;
end;

function formatPoint(p: Point): string;
begin
  result := '[' + fmt4(p.x) + ' ' + fmt4(p.y) + ' ' + fmt4(p.z) + ']';
  exit;
end;

function formatFace(f: specialize TArray<integer>): string;
var
  i: integer;
  s: Variant;
begin
  if (Length(f) = 0) then ;
  s := '[' + fmt2(specialize _indexList<integer>(f, 0));
  i := 1;
  while (i < Length(f)) do
  begin
    s := s + ' ' + fmt2(specialize _indexList<integer>(f, i));
    i := i + 1;
  end;
  s := s + ']';
  result := s;
  exit;
end;

function main(): integer;
var
  _tmp11: Point;
  _tmp12: Point;
  _tmp13: Point;
  _tmp14: Point;
  _tmp15: Point;
  _tmp16: Point;
  _tmp17: Point;
  _tmp18: Point;
  i: integer;
  inputFaces: specialize TArray<Variant>;
  inputPoints: specialize TArray<Variant>;
  outputFaces: specialize TArray<Variant>;
  outputPoints: specialize TArray<Variant>;
  res: specialize TArray<specialize TArray<integer>>;
begin
  _tmp11.x := -1;
  _tmp11.y := 1;
  _tmp11.z := 1;
  _tmp12.x := -1;
  _tmp12.y := -1;
  _tmp12.z := 1;
  _tmp13.x := 1;
  _tmp13.y := -1;
  _tmp13.z := 1;
  _tmp14.x := 1;
  _tmp14.y := 1;
  _tmp14.z := 1;
  _tmp15.x := 1;
  _tmp15.y := -1;
  _tmp15.z := -1;
  _tmp16.x := 1;
  _tmp16.y := 1;
  _tmp16.z := -1;
  _tmp17.x := -1;
  _tmp17.y := -1;
  _tmp17.z := -1;
  _tmp18.x := -1;
  _tmp18.y := 1;
  _tmp18.z := -1;
  inputPoints := specialize TArray<Point>([_tmp11, _tmp12, _tmp13, _tmp14, _tmp15, _tmp16, _tmp17, _tmp18]);
  inputFaces := specialize TArray<specialize TArray<integer>>([specialize TArray<integer>([0, 1, 2, 3]), specialize TArray<integer>([3, 2, 4, 5]), specialize TArray<integer>([5, 4, 6, 7]), specialize TArray<integer>([7, 0, 3, 5]), specialize TArray<integer>([7, 6, 1, 0]), specialize TArray<integer>([6, 1, 2, 4])]);
  outputPoints := inputPoints;
  outputFaces := inputFaces;
  i := 0;
  while (i < 1) do
  begin
    res := cmcSubdiv(outputPoints, outputFaces);
    outputPoints := specialize _indexList<specialize TArray<integer>>(res, 0);
    outputFaces := specialize _indexList<specialize TArray<integer>>(res, 1);
    i := i + 1;
  end;
  for p in outputPoints do
  begin
    writeln(formatPoint(p));
  end;
  writeln('');
  for f in outputFaces do
  begin
    writeln(formatFace(f));
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
