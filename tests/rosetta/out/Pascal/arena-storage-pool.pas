// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program ArenaStoragePool;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

generic function _sliceList<T>(arr: specialize TArray<T>; i, j: integer): specialize TArray<T>;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(arr);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(arr, start_ + 1, end_ - start_);
end;


function poolPut(p: specialize TArray<integer>; x: integer): specialize TArray<integer>;
begin
  result := specialize _appendList<Variant>(p, x);
  exit;
end;

function poolGet(p: specialize TArray<integer>): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
  _tmp1: specialize TFPGMap<string, Variant>;
  idx: Variant;
  v: Variant;
begin
  if (Length(p) = 0) then
  begin
    writeln('pool empty');
    _tmp0 := specialize TFPGMap<string, Variant>.Create;
    _tmp0.AddOrSetData('pool', p);
    _tmp0.AddOrSetData('val', 0);
    result := _tmp0;
    exit;
  end;
  idx := Length(p) - 1;
  v := specialize _indexList<integer>(p, idx);
  p := specialize _sliceList<integer>(p, 0, idx);
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('pool', p);
  _tmp1.AddOrSetData('val', v);
  result := _tmp1;
  exit;
end;

function clearPool(p: specialize TArray<integer>): specialize TArray<integer>;
begin
  result := specialize TArray<integer>([]);
  exit;
end;

procedure main();
var
  i: integer;
  j: integer;
  pool: specialize TArray<Variant>;
  res1: Variant;
  res2: Variant;
  res3: Variant;
  res4: Variant;
begin
  pool := specialize TArray<Variant>([]);
  i := 1;
  j := 2;
  writeln(IntToStr(i + j));
  pool := poolPut(pool, i);
  pool := poolPut(pool, j);
  i := 0;
  j := 0;
  res1 := poolGet(pool);
  pool := Trunc(res1['pool']);
  i := Trunc(res1['val']);
  res2 := poolGet(pool);
  pool := Trunc(res2['pool']);
  j := Trunc(res2['val']);
  i := 4;
  j := 5;
  writeln(IntToStr(i + j));
  pool := poolPut(pool, i);
  pool := poolPut(pool, j);
  i := 0;
  j := 0;
  pool := clearPool(pool);
  res3 := poolGet(pool);
  pool := Trunc(res3['pool']);
  i := Trunc(res3['val']);
  res4 := poolGet(pool);
  pool := Trunc(res4['pool']);
  j := Trunc(res4['val']);
  i := 7;
  j := 8;
  writeln(IntToStr(i + j));
end;

begin
  main();
end.
