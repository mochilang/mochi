// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program _RingsOr4SquaresPuzzle;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;


var
  r1: specialize TFPGMap<string, Variant>;
  r2: specialize TFPGMap<string, Variant>;
  r3: specialize TFPGMap<string, Variant>;

function validComb(a: integer; b: integer; c: integer; d: integer; e: integer; f: integer; g: integer): boolean;
var
  square1: Variant;
  square2: Variant;
  square3: Variant;
  square4: Variant;
begin
  square1 := a + b;
  square2 := b + c + d;
  square3 := d + e + f;
  square4 := f + g;
  result := (((square1 = square2) and (square2 = square3)) and (square3 = square4));
  exit;
end;

function isUnique(a: integer; b: integer; c: integer; d: integer; e: integer; f: integer; g: integer): boolean;
var
  i: integer;
  j: integer;
  nums: specialize TArray<Variant>;
begin
  nums := specialize TArray<Variant>([a, b, c, d, e, f, g]);
  i := 0;
  while (i < Length(nums)) do
  begin
    j := i + 1;
    while (j < Length(nums)) do
    begin
      if (specialize _indexList<Variant>(nums, i) = specialize _indexList<Variant>(nums, j)) then ;
      j := j + 1;
    end;
    i := i + 1;
  end;
  result := True;
  exit;
end;

function getCombs(low: integer; high: integer; unique: boolean): specialize TFPGMap<string, any>;
var
  _tmp0: specialize TFPGMap<string, Variant>;
  a: Variant;
  b: Variant;
  c: Variant;
  count: function(p0: Variant): integer is nested;
  d: Variant;
  e: Variant;
  f: Variant;
  g: Variant;
  s: Variant;
  valid: specialize TArray<Variant>;
begin
  valid := specialize TArray<Variant>([]);
  count := 0;
  for b := low to high + 1 - 1 do
  begin
    for c := low to high + 1 - 1 do
    begin
      for d := low to high + 1 - 1 do
      begin
        s := b + c + d;
        for e := low to high + 1 - 1 do
        begin
          for f := low to high + 1 - 1 do
          begin
            a := s - b;
            g := s - f;
            if ((a < low) or (a > high)) then ;
            if ((g < low) or (g > high)) then ;
            if (d + e + f <> s) then ;
            if (f + g <> s) then ;
            if (not unique or isUnique(a, b, c, d, e, f, g)) then
            begin
              valid := specialize _appendList<Variant>(valid, specialize TArray<Variant>([a, b, c, d, e, f, g]));
              count := count + 1;
            end;
          end;
        end;
      end;
    end;
  end;
  _tmp0 := specialize TFPGMap<string, Variant>.Create;
  _tmp0.AddOrSetData('count', count);
  _tmp0.AddOrSetData('list', valid);
  result := _tmp0;
  exit;
end;

begin
  r1 := getCombs(1, 7, True);
  writeln(IntToStr(r1.KeyData['count']) + ' unique solutions in 1 to 7');
  writeln(r1.KeyData['list']);
  r2 := getCombs(3, 9, True);
  writeln(IntToStr(r2.KeyData['count']) + ' unique solutions in 3 to 9');
  writeln(r2.KeyData['list']);
  r3 := getCombs(0, 9, False);
  writeln(IntToStr(r3.KeyData['count']) + ' non-unique solutions in 0 to 9');
end.
