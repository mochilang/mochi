// Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
program AchillesNumbers;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, Classes, Variants;

type
  generic TArray<T> = array of T;
generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;


var
  _tmp1: specialize TFPGMap<string, integer>;
  pps: specialize TFPGMap<integer, boolean>;

function pow10(exp: integer): integer;
var
  i: integer;
  n: integer;
begin
  n := 1;
  i := 0;
  while (i < exp) do
  begin
    n := n * 10;
    i := i + 1;
  end;
  result := n;
  exit;
end;

function totient(n: integer): integer;
var
  i: integer;
  nn: integer;
  tot: integer;
begin
  tot := n;
  nn := n;
  i := 2;
  while (i * i <= nn) do
  begin
    if (nn mod i = 0) then
    begin
      while (nn mod i = 0) do
      begin
        nn := nn div i;
      end;
      tot := tot - tot div i;
    end;
    if (i = 2) then ;
    i := i + 2;
  end;
  if (nn > 1) then ;
  result := tot;
  exit;
end;

procedure getPerfectPowers(maxExp: integer);
var
  i: integer;
  p: integer;
  upper: function(p0: string): string is nested;
begin
  upper := pow10(maxExp);
  i := 2;
  while (i * i < upper) do
  begin
    p := i * i;
    while True do
    begin
      p := p * i;
      if (p >= upper) then ;
      pps.KeyData[p] := True;
    end;
    i := i + 1;
  end;
end;

function getAchilles(minExp: integer; maxExp: integer): specialize TFPGMap<integer, boolean>;
var
  _tmp0: specialize TFPGMap<string, integer>;
  a: integer;
  achilles: specialize TFPGMap<Variant, Variant>;
  b: integer;
  b3: integer;
  lower: function(p0: Variant): string is nested;
  p: integer;
  upper: function(p0: string): string is nested;
begin
  lower := pow10(minExp);
  upper := pow10(maxExp);
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  achilles := _tmp0;
  b := 1;
  while (b * b * b < upper) do
  begin
    b3 := b * b * b;
    a := 1;
    while True do
    begin
      p := b3 * a * a;
      if (p >= upper) then ;
      if (p >= lower) then ;
      a := a + 1;
    end;
    b := b + 1;
  end;
  result := achilles;
  exit;
end;

function sortInts(xs: specialize TArray<integer>): specialize TArray<integer>;
var
  i: integer;
  idx: integer;
  j: integer;
  min: function(p0: Variant): Variant is nested;
  out: specialize TArray<Variant>;
  res: specialize TArray<Variant>;
  tmp: Variant;
begin
  res := specialize TArray<Variant>([]);
  tmp := xs;
  while (Length(tmp) > 0) do
  begin
    min := tmp[0];
    idx := 0;
    i := 1;
    while (i < Length(tmp)) do
    begin
      if (tmp[i] < min) then
      begin
        min := tmp[i];
        idx := i;
      end;
      i := i + 1;
    end;
    res := Concat(res, specialize TArray<Variant>([min]));
    out := specialize TArray<Variant>([]);
    j := 0;
    while (j < Length(tmp)) do
    begin
      if (j <> idx) then ;
      j := j + 1;
    end;
    tmp := out;
  end;
  result := res;
  exit;
end;

function pad(n: integer; width: integer): string;
var
  s: Variant;
begin
  s := IntToStr(n);
  while (Length(s) < width) do
  begin
    s := ' ' + s;
  end;
  result := s;
  exit;
end;

procedure main();
var
  ach: specialize TArray<Variant>;
  achSet: Variant;
  c: specialize TArray<Variant>;
  count: function(p0: Variant): integer is nested;
  counts: specialize TArray<Variant>;
  d: integer;
  i: integer;
  idx: integer;
  j: integer;
  k: Variant;
  line: string;
  maxDigits: integer;
  strong: specialize TArray<Variant>;
  tot: Variant;
begin
  maxDigits := 15;
  getPerfectPowers(maxDigits);
  achSet := getAchilles(1, 5);
  ach := specialize TArray<Variant>([]);
  for k in achSet.keys() do
  begin
    ach := Concat(ach, specialize TArray<Variant>([k]));
  end;
  ach := sortInts(ach);
  writeln('First 50 Achilles numbers:');
  i := 0;
  while (i < 50) do
  begin
    line := '';
    j := 0;
    while (j < 10) do
    begin
      line := line + pad(specialize _indexList<Variant>(ach, i), 4);
      if (j < 9) then ;
      i := i + 1;
      j := j + 1;
    end;
    writeln(line);
  end;
  writeln('
First 30 strong Achilles numbers:');
  strong := specialize TArray<Variant>([]);
  count := 0;
  idx := 0;
  while (count < 30) do
  begin
    tot := totient(specialize _indexList<Variant>(ach, idx));
    if (tot in achSet) then
    begin
      strong := Concat(strong, specialize TArray<Variant>([specialize _indexList<Variant>(ach, idx)]));
      count := count + 1;
    end;
    idx := idx + 1;
  end;
  i := 0;
  while (i < 30) do
  begin
    line := '';
    j := 0;
    while (j < 10) do
    begin
      line := line + pad(specialize _indexList<Variant>(strong, i), 5);
      if (j < 9) then ;
      i := i + 1;
      j := j + 1;
    end;
    writeln(line);
  end;
  writeln('
Number of Achilles numbers with:');
  counts := specialize TArray<Variant>([1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383]);
  d := 2;
  while (d <= maxDigits) do
  begin
    c := specialize _indexList<Variant>(counts, d - 2);
    writeln(pad(d, 2) + ' digits: ' + IntToStr(c));
    d := d + 1;
  end;
end;

begin
  _tmp1 := specialize TFPGMap<string, integer>.Create;
  pps := _tmp1;
  main();
end.
