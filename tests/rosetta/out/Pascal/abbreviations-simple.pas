// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:03Z
program AbbreviationsSimple;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function fields(s: string): specialize TArray<string>;
var
  ch: Variant;
  cur: string;
  i: integer;
  words: specialize TArray<string>;
begin
  words := specialize TArray<string>([]);
  cur := '';
  i := 0;
  while (i < Length(s)) do
  begin
    ch := _sliceString(s, i, i + i + 1);
    if (((ch = ' ') or (ch = '
')) or (ch = '  ')) then
    begin
      if (Length(cur) > 0) then
      begin
        words := specialize _appendList<Variant>(words, cur);
        cur := '';
      end;
    end else
    begin
      cur := cur + ch;
    end;
    i := i + 1;
  end;
  if (Length(cur) > 0) then ;
  result := words;
  exit;
end;

function padRight(s: string; width: integer): string;
var
  i: Variant;
  out: Variant;
begin
  out := s;
  i := Length(s);
  while (i < width) do
  begin
    out := out + ' ';
    i := i + 1;
  end;
  result := out;
  exit;
end;

function join(xs: specialize TArray<string>; sep: string): string;
var
  i: Variant;
  res: string;
begin
  res := '';
  i := 0;
  while (i < Length(xs)) do
  begin
    if (i > 0) then ;
    res := res + specialize _indexList<integer>(xs, i);
    i := i + 1;
  end;
  result := res;
  exit;
end;

function parseIntStr(str: string): integer;
var
  _tmp0: specialize TFPGMap<string, integer>;
  digits: specialize TFPGMap<Variant, Variant>;
  i: Variant;
  n: integer;
  neg: boolean;
begin
  i := 0;
  neg := False;
  if ((Length(str) > 0) and (_sliceString(str, 0, 1) = '-')) then
  begin
    neg := True;
    i := 1;
  end;
  n := 0;
  _tmp0 := specialize TFPGMap<string, integer>.Create;
  _tmp0.AddOrSetData('0', 0);
  _tmp0.AddOrSetData('1', 1);
  _tmp0.AddOrSetData('2', 2);
  _tmp0.AddOrSetData('3', 3);
  _tmp0.AddOrSetData('4', 4);
  _tmp0.AddOrSetData('5', 5);
  _tmp0.AddOrSetData('6', 6);
  _tmp0.AddOrSetData('7', 7);
  _tmp0.AddOrSetData('8', 8);
  _tmp0.AddOrSetData('9', 9);
  digits := _tmp0;
  while (i < Length(str)) do
  begin
    n := n * 10 + digits[_sliceString(str, i, i + 1)];
    i := i + 1;
  end;
  if neg then ;
  result := n;
  exit;
end;

function isDigits(s: string): boolean;
var
  ch: Variant;
  i: Variant;
begin
  if (Length(s) = 0) then ;
  i := 0;
  while (i < Length(s)) do
  begin
    ch := _sliceString(s, i, i + i + 1);
    if ((ch < '0') or (ch > '9')) then ;
    i := i + 1;
  end;
  result := True;
  exit;
end;

function readTable(table: string): specialize TFPGMap<string, any>;
var
  _tmp1: specialize TFPGMap<string, Variant>;
  cmd: Variant;
  cmds: specialize TArray<string>;
  i: Variant;
  minlen: Variant;
  mins: specialize TArray<integer>;
  num: function(p0: Variant): integer is nested;
  toks: Variant;
begin
  toks := fields(table);
  cmds := specialize TArray<string>([]);
  mins := specialize TArray<integer>([]);
  i := 0;
  while (i < Length(toks)) do
  begin
    cmd := toks[i];
    minlen := Length(cmd);
    i := i + 1;
    if ((i < Length(toks)) and isDigits(toks[i])) then
    begin
      num := parseIntStr(toks[i]);
      if ((num >= 1) and (num < Length(cmd))) then
      begin
        minlen := num;
        i := i + 1;
      end;
    end;
    cmds := specialize _appendList<Variant>(cmds, cmd);
    mins := specialize _appendList<Variant>(mins, minlen);
  end;
  _tmp1 := specialize TFPGMap<string, Variant>.Create;
  _tmp1.AddOrSetData('commands', cmds);
  _tmp1.AddOrSetData('mins', mins);
  result := _tmp1;
  exit;
end;

function validate(commands: specialize TArray<string>; mins: specialize TArray<integer>; words: specialize TArray<string>): specialize TArray<string>;
var
  c: Variant;
  ci: integer;
  cmd: Variant;
  found: boolean;
  results: specialize TArray<string>;
  w: specialize TArray<string>;
  wi: integer;
  wlen: Variant;
  ww: Variant;
begin
  results := specialize TArray<string>([]);
  wi := 0;
  while (wi < Length(words)) do
  begin
    w := specialize _indexList<string>(words, wi);
    found := False;
    wlen := Length(w);
    ci := 0;
    while (ci < Length(commands)) do
    begin
      cmd := specialize _indexList<integer>(commands, ci);
      if (((specialize _indexList<integer>(mins, ci) <> 0) and (wlen >= specialize _indexList<integer>(mins, ci))) and (wlen <= Length(cmd))) then
      begin
        c := UpperCase(cmd);
        ww := UpperCase(w);
        if (_sliceString(c, 0, 0 + wlen) = ww) then
        begin
          results := specialize _appendList<Variant>(results, c);
          found := True;
          break;
        end;
      end;
      ci := ci + 1;
    end;
    if not found then ;
    wi := wi + 1;
  end;
  result := results;
  exit;
end;

function main(): integer;
var
  commands: specialize TArray<string>;
  k: integer;
  mins: specialize TArray<integer>;
  out1: string;
  results: specialize TArray<string>;
  sentence: string;
  table: string;
  tbl: Variant;
  words: specialize TArray<string>;
begin
  table := '' + 'add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ' + 'compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ' + '3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ' + 'forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ' + 'locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ' + 'msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ' + 'refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ' + '2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ';
  sentence := 'riG   rePEAT copies  put mo   rest    types   fup.    6
poweRin';
  tbl := readTable(table);
  commands := Trunc(tbl['commands']);
  mins := Trunc(tbl['mins']);
  words := fields(sentence);
  results := validate(commands, mins, words);
  out1 := 'user words:';
  k := 0;
  while (k < Length(words)) do
  begin
    out1 := out1 + ' ';
    if (k < Length(words) - 1) then
    begin
      out1 := out1 + padRight(specialize _indexList<string>(words, k), Length(specialize _indexList<string>(results, k)));
    end else
    begin
      out1 := out1 + specialize _indexList<string>(words, k);
    end;
    k := k + 1;
  end;
  writeln(out1);
  writeln('full words: ' + _joinStrings(results, ' '));
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

generic function _indexList<T>(arr: specialize TArray<T>; i: integer): T;
begin
  if i < 0 then i := Length(arr) + i;
  if (i < 0) or (i >= Length(arr)) then
    raise Exception.Create('index out of range');
  Result := arr[i];
end;

function _joinStrings(parts: specialize TArray<string>; sep: string): string;
var i: Integer;
begin
  Result := '';
  for i := 0 to High(parts) do
  begin
    if i > 0 then Result := Result + sep;
    Result := Result + parts[i];
  end;
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
