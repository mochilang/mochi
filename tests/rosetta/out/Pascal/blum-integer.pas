// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:16Z
program BlumInteger;
{$mode objfpc}
{$modeswitch nestedprocvars}
uses SysUtils, fgl, fphttpclient, Classes, Variants, fpjson, jsonparser, fpjsonrtti;

type
  generic TArray<T> = array of T;

function isPrime(n: integer): boolean;
var
  d: integer;
begin
  if (n < 2) then ;
  if (n mod 2 = 0) then ;
  if (n mod 3 = 0) then ;
  d := 5;
  while (d * d <= n) do
  begin
    if (n mod d = 0) then ;
    d := d + 2;
    if (n mod d = 0) then ;
    d := d + 4;
  end;
  result := True;
  exit;
end;

function firstPrimeFactor(n: integer): integer;
var
  i: integer;
  inc: specialize TArray<Variant>;
  k: integer;
begin
  if (n = 1) then ;
  if (n mod 3 = 0) then ;
  if (n mod 5 = 0) then ;
  inc := specialize TArray<integer>([4, 2, 4, 2, 4, 6, 2, 6]);
  k := 7;
  i := 0;
  while (k * k <= n) do
  begin
    if (n mod k = 0) then ;
    k := k + inc[i];
    i := i + 1 mod Length(inc);
  end;
  result := n;
  exit;
end;

function indexOf(s: string; ch: string): integer;
var
  i: integer;
begin
  i := 0;
  while (i < Length(s)) do
  begin
    if (_sliceString(s, i, i + i + 1) = ch) then ;
    i := i + 1;
  end;
  result := -1;
  exit;
end;

function padLeft(n: integer; width: integer): string;
var
  s: Variant;
begin
  s := IntToStr(n);
  while (Length(s) < width) do
  begin
    s := ' ' + s;
  end;
  result := s;
  exit;
end;

function formatFloat(f: double; prec: integer): string;
var
  idx: Variant;
  need: Variant;
  s: Variant;
begin
  s := IntToStr(f);
  idx := indexOf(s, '.');
  if (idx < 0) then ;
  need := idx + 1 + prec;
  if (Length(s) > need) then ;
  result := s;
  exit;
end;

function main(): integer;
var
  bc: integer;
  blum: specialize TArray<integer>;
  counts: specialize TArray<Variant>;
  d: integer;
  digits: specialize TArray<Variant>;
  i: integer;
  idx: Variant;
  j: integer;
  line: string;
  p: Variant;
  q: integer;
begin
  blum := specialize TArray<integer>([]);
  counts := specialize TArray<integer>([0, 0, 0, 0]);
  digits := specialize TArray<integer>([1, 3, 7, 9]);
  i := 1;
  bc := 0;
  while True do
  begin
    p := firstPrimeFactor(i);
    if (p mod 4 = 3) then
    begin
      q := Trunc(i div p);
      if (((q <> p) and (q mod 4 = 3)) and isPrime(q)) then
      begin
        if (bc < 50) then ;
        d := i mod 10;
        if (d = 1) then
        begin
          counts[0] := counts[0] + 1;
        end else if (d = 3) then
        begin
          counts[1] := counts[1] + 1;
        end else if (d = 7) then
        begin
          counts[2] := counts[2] + 1;
        end else if (d = 9) then
        begin
          counts[3] := counts[3] + 1;
        end;
        bc := bc + 1;
        if (bc = 50) then
        begin
          writeln('First 50 Blum integers:');
          idx := 0;
          while (idx < 50) do
          begin
            line := '';
            j := 0;
            while (j < 10) do
            begin
              line := line + padLeft(blum[idx], 3) + ' ';
              idx := idx + 1;
              j := j + 1;
            end;
            writeln(_sliceString(line, 0, 0 + Length(line) - 1));
          end;
          break;
        end;
      end;
    end;
    if (i mod 5 = 3) then
    begin
      i := i + 4;
    end else
    begin
      i := i + 2;
    end;
  end;
end;

generic function _appendList<T>(arr: specialize TArray<T>; val: T): specialize TArray<T>;
var i,n: Integer;
begin
  n := Length(arr);
  SetLength(Result, n + 1);
  for i := 0 to n - 1 do
    Result[i] := arr[i];
  Result[n] := val;
end;

function _sliceString(s: string; i, j: integer): string;
var start_, end_, n: integer;
begin
  start_ := i;
  end_ := j;
  n := Length(s);
  if start_ < 0 then start_ := n + start_;
  if end_ < 0 then end_ := n + end_;
  if start_ < 0 then start_ := 0;
  if end_ > n then end_ := n;
  if end_ < start_ then end_ := start_;
  Result := Copy(s, start_ + 1, end_ - start_);
end;

begin
  main();
end.
