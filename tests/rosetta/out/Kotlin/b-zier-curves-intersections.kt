// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}

fun toBool(v: Any?): Boolean = when (v) {
    is Boolean -> v
    is Int -> v != 0
    is Double -> v != 0.0
    is String -> v.isNotEmpty()
    null -> false
    else -> true
}
// Code generated from b-zier-curves-intersections.mochi

data class Point(var x: Double, var y: Double)

data class QuadSpline(var c0: Double, var c1: Double, var c2: Double)

data class QuadCurve(var x: QuadSpline, var y: QuadSpline)

/**
 * Auto-generated from Mochi
 * @param x Double
 * @return Double
 */
fun absf(x: Double): Double {
    if (x < 0.0) {
        return -x
    }
    return x
}

/**
 * Auto-generated from Mochi
 * @param a Double
 * @param b Double
 * @return Double
 */
fun maxf(a: Double, b: Double): Double {
    if (a > b) {
        return a
    }
    return b
}

/**
 * Auto-generated from Mochi
 * @param a Double
 * @param b Double
 * @return Double
 */
fun minf(a: Double, b: Double): Double {
    if (a < b) {
        return a
    }
    return b
}

/**
 * Auto-generated from Mochi
 * @param a Double
 * @param b Double
 * @param c Double
 * @return Double
 */
fun max3(a: Double, b: Double, c: Double): Double {
    var m = a
    if (b > m) {
        m = b
    }
    if (c > m) {
        m = c
    }
    return m
}

/**
 * Auto-generated from Mochi
 * @param a Double
 * @param b Double
 * @param c Double
 * @return Double
 */
fun min3(a: Double, b: Double, c: Double): Double {
    var m = a
    if (b < m) {
        m = b
    }
    if (c < m) {
        m = c
    }
    return m
}

/**
 * Auto-generated from Mochi
 * @param q QuadSpline
 * @param t Double
 * @return MutableList<QuadSpline>
 */
fun subdivideQuadSpline(q: QuadSpline, t: Double): MutableList<QuadSpline> {
    val s = 1.0 - t
    var u = QuadSpline(c0 = q.c0, c1 = 0.0, c2 = 0.0)
    var v = QuadSpline(c0 = 0.0, c1 = 0.0, c2 = q.c2)
    u.c1 = s * q.c0 + t * q.c1
    v.c1 = s * q.c1 + t * q.c2
    u.c2 = s * u.c1 + t * v.c1
    v.c0 = u.c2
    return mutableListOf(u, v)
}

/**
 * Auto-generated from Mochi
 * @param q QuadCurve
 * @param t Double
 * @return MutableList<QuadCurve>
 */
fun subdivideQuadCurve(q: QuadCurve, t: Double): MutableList<QuadCurve> {
    val xs = subdivideQuadSpline(q.x, t)
    val ys = subdivideQuadSpline(q.y, t)
    var u = QuadCurve(x = xs[0], y = ys[0])
    var v = QuadCurve(x = xs[1], y = ys[1])
    return mutableListOf(u, v)
}

/**
 * Auto-generated from Mochi
 * @param xa0 Double
 * @param ya0 Double
 * @param xa1 Double
 * @param ya1 Double
 * @param xb0 Double
 * @param yb0 Double
 * @param xb1 Double
 * @param yb1 Double
 * @return Boolean
 */
fun rectsOverlap(xa0: Double, ya0: Double, xa1: Double, ya1: Double, xb0: Double, yb0: Double, xb1: Double, yb1: Double): Boolean {
    return xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1
}

/**
 * Auto-generated from Mochi
 * @param p QuadCurve
 * @param q QuadCurve
 * @param tol Double
 * @return MutableMap<String, Any>
 */
fun testIntersect(p: QuadCurve, q: QuadCurve, tol: Double): MutableMap<String, Any> {
    val pxmin = min3(p.x.c0, p.x.c1, p.x.c2)
    val pymin = min3(p.y.c0, p.y.c1, p.y.c2)
    val pxmax = max3(p.x.c0, p.x.c1, p.x.c2)
    val pymax = max3(p.y.c0, p.y.c1, p.y.c2)
    val qxmin = min3(q.x.c0, q.x.c1, q.x.c2)
    val qymin = min3(q.y.c0, q.y.c1, q.y.c2)
    val qxmax = max3(q.x.c0, q.x.c1, q.x.c2)
    val qymax = max3(q.y.c0, q.y.c1, q.y.c2)
    var exclude = true
    var accept = false
    var inter = Point(x = 0.0, y = 0.0)
    if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
        exclude = false
        val xmin = maxf(pxmin, qxmin)
        val xmax = minf(pxmax, qxmax)
        if (xmax - xmin <= tol) {
            val ymin = maxf(pymin, qymin)
            val ymax = minf(pymax, qymax)
            if (ymax - ymin <= tol) {
                accept = true
                inter.x = 0.5 * (xmin + xmax)
                inter.y = 0.5 * (ymin + ymax)
            }
        }
    }
    return mutableMapOf("exclude" to exclude, "accept" to accept, "intersect" to inter)
}

/**
 * Auto-generated from Mochi
 * @param pts MutableList<Point>
 * @param xy Point
 * @param spacing Double
 * @return Boolean
 */
fun seemsToBeDuplicate(pts: MutableList<Point>, xy: Point, spacing: Double): Boolean {
    var i = 0
    while (i < pts.size) {
        val pt = pts[i]
        if (absf(pt.x - xy.x) < spacing && absf(pt.y - xy.y) < spacing) {
            return true
        }
        i = i + 1
    }
    return false
}

/**
 * Auto-generated from Mochi
 * @param p QuadCurve
 * @param q QuadCurve
 * @param tol Double
 * @param spacing Double
 * @return MutableList<Point>
 */
fun findIntersects(p: QuadCurve, q: QuadCurve, tol: Double, spacing: Double): MutableList<Point> {
    var inters: MutableList<Point> = mutableListOf<Point>()
    var workload: MutableList<MutableMap<String, QuadCurve>> = mutableListOf(mutableMapOf("p" to p, "q" to q))
    while (workload.size > 0) {
        val idx = workload.size - 1
        val work = workload[idx]
        workload = workload.subList(0, idx)
        val res = testIntersect(work["p"], work["q"], tol)
        val excl = res["exclude"]
        val acc = res["accept"]
        val inter = (res["intersect"] as Any?) as Point
        if (toBool(acc)) {
            if (!seemsToBeDuplicate(inters, inter, spacing)) {
                inters = append(inters, inter)
            }
        }
        else
        if (toBool(!toBool(excl))) {
            val ps = subdivideQuadCurve(work["p"], 0.5)
            val qs = subdivideQuadCurve(work["q"], 0.5)
            val p0 = ps[0]
            val p1 = ps[1]
            val q0 = qs[0]
            val q1 = qs[1]
            workload = append(workload, mutableMapOf("p" to p0, "q" to q0))
            workload = append(workload, mutableMapOf("p" to p0, "q" to q1))
            workload = append(workload, mutableMapOf("p" to p1, "q" to q0))
            workload = append(workload, mutableMapOf("p" to p1, "q" to q1))
        }
    }
    return inters
}

/**
 * Auto-generated from Mochi
 */
fun main(): Unit {
    val p = QuadCurve(x = QuadSpline(c0 = -1.0, c1 = 0.0, c2 = 1.0), y = QuadSpline(c0 = 0.0, c1 = 10.0, c2 = 0.0))
    val q = QuadCurve(x = QuadSpline(c0 = 2.0, c1 = -8.0, c2 = 2.0), y = QuadSpline(c0 = 1.0, c1 = 2.0, c2 = 3.0))
    val tol = 0.0000001
    val spacing = tol * 10.0
    val inters = findIntersects(p, q, tol, spacing)
    var i = 0
    while (i < inters.size) {
        val pt = inters[i]
        println("(" + pt.x.toString() + ", " + pt.y.toString() + ")")
        i = i + 1
    }
}

