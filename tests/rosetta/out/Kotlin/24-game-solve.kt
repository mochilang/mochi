// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:11:11Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}

fun String.starts_with(prefix: String): Boolean = this.startsWith(prefix)

fun toDouble(v: Any?): Double = when (v) {
    is Double -> v
    is Int -> v.toDouble()
    is String -> v.toDouble()
    else -> 0.0
}
// Code generated from 24-game-solve.mochi

val OP_NUM = 0

val OP_ADD = 1

val OP_SUB = 2

val OP_MUL = 3

val OP_DIV = 4

val n_cards = 4

val goal = 24

val digit_range = 9

/**
 * Auto-generated from Mochi
 * @param n Int
 * @return MutableMap<String, Any>
 */
fun newNum(n: Int): MutableMap<String, Any> {
    return mutableMapOf("op" to OP_NUM, "value" to mutableMapOf("num" to n, "denom" to 1))
}

/**
 * Auto-generated from Mochi
 * @param x MutableMap<String, Any>
 * @return MutableMap<String, Int>
 */
fun exprEval(x: MutableMap<String, Any>): MutableMap<String, Int> {
    if (toDouble(x["op"]) == OP_NUM) {
        return x["value"]
    }
    val l = exprEval(x["left"])
    val r = exprEval(x["right"])
    if (toDouble(x["op"]) == OP_ADD) {
        return mutableMapOf("num" to l["num"] * r["denom"] + l["denom"] * r["num"], "denom" to l["denom"] * r["denom"])
    }
    if (toDouble(x["op"]) == OP_SUB) {
        return mutableMapOf("num" to l["num"] * r["denom"] - l["denom"] * r["num"], "denom" to l["denom"] * r["denom"])
    }
    if (toDouble(x["op"]) == OP_MUL) {
        return mutableMapOf("num" to l["num"] * r["num"], "denom" to l["denom"] * r["denom"])
    }
    return mutableMapOf("num" to l["num"] * r["denom"], "denom" to l["denom"] * r["num"])
}

/**
 * Auto-generated from Mochi
 * @param x MutableMap<String, Any>
 * @return String
 */
fun exprString(x: MutableMap<String, Any>): String {
    if (toDouble(x["op"]) == OP_NUM) {
        return (x["value"] as Any?)["num"].toString()
    }
    val ls = exprString(x["left"])
    val rs = exprString(x["right"])
    var opstr = ""
    if (toDouble(x["op"]) == OP_ADD) {
        opstr = " + "
    }
    else
    if (toDouble(x["op"]) == OP_SUB) {
        opstr = " - "
    }
    else
    if (toDouble(x["op"]) == OP_MUL) {
        opstr = " * "
    }
    else {
        opstr = " / "
    }
    return "(" + ls + opstr + rs + ")"
}

/**
 * Auto-generated from Mochi
 * @param xs MutableList<MutableMap<String, Any>>
 * @return Boolean
 */
fun solve(xs: MutableList<MutableMap<String, Any>>): Boolean {
    if (xs.size == 1) {
        val f = exprEval(xs[0])
        if (f["denom"] != 0 && f["num"] == f["denom"] * goal) {
            println(exprString(xs[0]))
            return true
        }
        return false
    }
    var i = 0
    while (i < xs.size) {
        var j = i + 1
        while (j < xs.size) {
            var rest: MutableList<MutableMap<String, Any>> = mutableListOf<MutableMap<String, Any?>>()
            var k = 0
            while (k < xs.size) {
                if (k != i && k != j) {
                    rest = append(rest, xs[k])
                }
                k = k + 1
            }
            val a = xs[i]
            val b = xs[j]
            for (op in mutableListOf(OP_ADD, OP_SUB, OP_MUL, OP_DIV)) {
                var node = mutableMapOf("op" to op, "left" to a, "right" to b)
                if (solve(append(rest, node))) {
                    return true
                }
            }
            var node = mutableMapOf("op" to OP_SUB, "left" to b, "right" to a)
            if (solve(append(rest, node))) {
                return true
            }
            node = mutableMapOf("op" to OP_DIV, "left" to b, "right" to a)
            if (solve(append(rest, node))) {
                return true
            }
            j = j + 1
        }
        i = i + 1
    }
    return false
}

/**
 * Auto-generated from Mochi
 */
fun main(): Unit {
    var iter = 0
    while (iter < 10) {
        var cards: MutableList<MutableMap<String, Any>> = mutableListOf<MutableMap<String, Any?>>()
        var i = 0
        while (i < n_cards) {
            val n = (System.nanoTime().toInt() % (digit_range - 1)) + 1
            cards = append(cards, newNum(n))
            println(" " + n.toString())
            i = i + 1
        }
        println(":  ")
        if (!solve(cards)) {
            println("No solution")
        }
        iter = iter + 1
    }
}

