// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}

fun String.starts_with(prefix: String): Boolean = this.startsWith(prefix)
// Code generated from abbreviations-easy.mochi

/**
 * Auto-generated from Mochi
 * @param s String
 * @return MutableList<String>
 */
fun fields(s: String): MutableList<String> {
    var words: MutableList<String> = mutableListOf<String>()
    var cur = ""
    var i = 0
    while (i < s.length) {
        val ch = s.substring(i, i + 1)
        if (ch == " " || ch == "\n" || ch == "\t") {
            if (cur.length > 0) {
                words = append(words, cur)
                cur = ""
            }
        }
        else {
            cur = cur + ch
        }
        i = i + 1
    }
    if (cur.length > 0) {
        words = append(words, cur)
    }
    return words
}

/**
 * Auto-generated from Mochi
 * @param s String
 * @param width Int
 * @return String
 */
fun padRight(s: String, width: Int): String {
    var out = s
    var i = s.length
    while (i < width) {
        out = out + " "
        i = i + 1
    }
    return out
}

/**
 * Auto-generated from Mochi
 * @param xs MutableList<String>
 * @param sep String
 * @return String
 */
fun join(xs: MutableList<String>, sep: String): String {
    var res = ""
    var i = 0
    while (i < xs.size) {
        if (i > 0) {
            res = res + sep
        }
        res = res + xs[i]
        i = i + 1
    }
    return res
}

/**
 * Auto-generated from Mochi
 * @param commands MutableList<String>
 * @param words MutableList<String>
 * @param mins MutableList<Int>
 * @return MutableList<String>
 */
fun validate(commands: MutableList<String>, words: MutableList<String>, mins: MutableList<Int>): MutableList<String> {
    var results: MutableList<String> = mutableListOf<String>()
    if (words.size == 0) {
        return results
    }
    var wi = 0
    while (wi < words.size) {
        val w = words[wi]
        var found = false
        val wlen = w.length
        var ci = 0
        while (ci < commands.size) {
            val cmd = commands[ci]
            if (mins[ci] != 0 && wlen >= mins[ci] && wlen <= cmd.length) {
                val c = upper(cmd)
                val ww = upper(w)
                if (c.substring(0, wlen) == ww) {
                    results = append(results, c)
                    found = true
                    break
                }
            }
            ci = ci + 1
        }
        if (!found) {
            results = append(results, "*error*")
        }
        wi = wi + 1
    }
    return results
}

/**
 * Auto-generated from Mochi
 */
fun main(): Unit {
    val table = "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " + "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find " + "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput " + " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO " + "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT " + "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT " + "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "
    val commands = fields(table)
    var mins: MutableList<Int> = mutableListOf<Int>()
    var i = 0
    while (i < commands.size) {
        var count = 0
        var j = 0
        val cmd = commands[i]
        while (j < cmd.length) {
            val ch = cmd.substring(j, j + 1)
            if (ch >= "A" && ch <= "Z") {
                count = count + 1
            }
            j = j + 1
        }
        mins = append(mins, count)
        i = i + 1
    }
    val sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"
    val words = fields(sentence)
    val results = validate(commands, words, mins)
    var out1 = "user words:  "
    var k = 0
    while (k < words.size) {
        out1 = out1 + padRight(words[k], results[k].size) + " "
        k = k + 1
    }
    println(out1)
    println("full words:  " + join(results, " "))
}

