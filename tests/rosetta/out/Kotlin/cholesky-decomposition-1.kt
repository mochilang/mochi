// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}

fun div(a: Any?, b: Any?): Double {
    val x = toDouble(a)
    val y = toDouble(b)
    return if (y == 0.0) 0.0 else x / y
}

fun toDouble(v: Any?): Double = when (v) {
    is Double -> v
    is Int -> v.toDouble()
    is String -> v.toDouble()
    else -> 0.0
}
// Code generated from cholesky-decomposition-1.mochi

/**
 * Auto-generated from Mochi
 * @param x Double
 * @return Double
 */
fun sqrtApprox(x: Double): Double {
    var guess = x
    var i = 0
    while (i < 20) {
        guess = (guess + x / guess) / 2.0
        i = i + 1
    }
    return guess
}

/**
 * Auto-generated from Mochi
 * @param order Int
 * @param elements MutableList<Double>
 * @return MutableMap<String, Any>
 */
fun makeSym(order: Int, elements: MutableList<Double>): MutableMap<String, Any> {
    return mutableMapOf("order" to order, "ele" to elements)
}

/**
 * Auto-generated from Mochi
 * @param m MutableMap<String, Any>
 * @return MutableList<MutableList<Double>>
 */
fun unpackSym(m: MutableMap<String, Any>): MutableList<MutableList<Double>> {
    val n = m["order"]
    val ele = m["ele"]
    var mat: MutableList<MutableList<Double>> = mutableListOf<MutableList<Double>>()
    var idx = 0
    var r = 0
    while (r < toDouble(n)) {
        var row: MutableList<Double> = mutableListOf<Double>()
        var c = 0
        while (c <= r) {
            row = append(row, ele[idx])
            idx = idx + 1
            c = c + 1
        }
        while (c < toDouble(n)) {
            row = append(row, 0.0)
            c = c + 1
        }
        mat = append(mat, row)
        r = r + 1
    }
    r = 0
    while (r < toDouble(n)) {
        var c = r + 1
        while (c < toDouble(n)) {
            mat[r]!![c] = (mat[c] as MutableList<Double>)[r]
            c = c + 1
        }
        r = r + 1
    }
    return mat
}

/**
 * Auto-generated from Mochi
 * @param m MutableList<MutableList<Double>>
 */
fun printMat(m: MutableList<MutableList<Double>>): Unit {
    var i = 0
    while (i < m.size) {
        var line = ""
        var j = 0
        while (j < m[i].size) {
            line = line + (m[i] as MutableList<Double>)[j].toString()
            if (j < m[i].size - 1) {
                line = line + " "
            }
            j = j + 1
        }
        println(line)
        i = i + 1
    }
}

/**
 * Auto-generated from Mochi
 * @param m MutableMap<String, Any>
 */
fun printSym(m: MutableMap<String, Any>): Unit {
    printMat(unpackSym(m))
}

/**
 * Auto-generated from Mochi
 * @param m MutableMap<String, Any>
 */
fun printLower(m: MutableMap<String, Any>): Unit {
    val n = m["order"]
    val ele = m["ele"]
    var mat: MutableList<MutableList<Double>> = mutableListOf<MutableList<Double>>()
    var idx = 0
    var r = 0
    while (r < toDouble(n)) {
        var row: MutableList<Double> = mutableListOf<Double>()
        var c = 0
        while (c <= r) {
            row = append(row, ele[idx])
            idx = idx + 1
            c = c + 1
        }
        while (c < toDouble(n)) {
            row = append(row, 0.0)
            c = c + 1
        }
        mat = append(mat, row)
        r = r + 1
    }
    printMat(mat)
}

/**
 * Auto-generated from Mochi
 * @param a MutableMap<String, Any>
 * @return MutableMap<String, Any>
 */
fun choleskyLower(a: MutableMap<String, Any>): MutableMap<String, Any> {
    val n = a["order"]
    val ae = a["ele"]
    var le: MutableList<Double> = mutableListOf<Double>()
    var idx = 0
    while (idx < ae.size) {
        le = append(le, 0.0)
        idx = idx + 1
    }
    var row = 1
    var col = 1
    var dr = 0
    var dc = 0
    var i = 0
    while (i < ae.size) {
        val e = ae[i]
        if (i < dr) {
            var d = div(toDouble((toDouble(e) - le[i])), le[dc])
            le[i] = d
            var ci = col
            var cx = dc
            var j = i + 1
            while (j <= dr) {
                cx = cx + ci
                ci = ci + 1
                le[j] = le[j] + toDouble(d) * le[cx]
                j = j + 1
            }
            col = col + 1
            dc = dc + col
        }
        else {
            le[i] = sqrtApprox(toDouble(e) - le[i])
            row = row + 1
            dr = dr + row
            col = 1
            dc = 0
        }
        i = i + 1
    }
    return mutableMapOf("order" to n, "ele" to le)
}

/**
 * Auto-generated from Mochi
 * @param a MutableMap<String, Any>
 */
fun demo(a: MutableMap<String, Any>): Unit {
    println("A:")
    printSym(a)
    println("L:")
    val l = choleskyLower(a)
    printLower(l)
}

fun main() {
    demo(makeSym(3, mutableListOf(25.0, 15.0, 18.0, -5.0, 0.0, 11.0)))
    demo(makeSym(4, mutableListOf(18.0, 22.0, 70.0, 54.0, 86.0, 174.0, 42.0, 62.0, 134.0, 106.0)))
}
