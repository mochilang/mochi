// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}
// Code generated from abelian-sandpile-model-identity.mochi

/**
 * Auto-generated from Mochi
 * @return MutableList<MutableList<Int>>
 */
fun neighborsList(): MutableList<MutableList<Int>> {
    return mutableListOf(mutableListOf(1, 3), mutableListOf(0, 2, 4), mutableListOf(1, 5), mutableListOf(0, 4, 6), mutableListOf(1, 3, 5, 7), mutableListOf(2, 4, 8), mutableListOf(3, 7), mutableListOf(4, 6, 8), mutableListOf(5, 7))
}

/**
 * Auto-generated from Mochi
 * @param a MutableList<Int>
 * @param b MutableList<Int>
 * @return MutableList<Int>
 */
fun plus(a: MutableList<Int>, b: MutableList<Int>): MutableList<Int> {
    var res: MutableList<Int> = mutableListOf<Int>()
    var i = 0
    while (i < a.size) {
        res = append(res, a[i] + b[i])
        i = i + 1
    }
    return res
}

/**
 * Auto-generated from Mochi
 * @param p MutableList<Int>
 * @return Boolean
 */
fun isStable(p: MutableList<Int>): Boolean {
    for (v in p) {
        if (v > 3) {
            return false
        }
    }
    return true
}

/**
 * Auto-generated from Mochi
 * @param p MutableList<Int>
 * @return Int
 */
fun topple(p: MutableList<Int>): Int {
    val neighbors = neighborsList()
    var i = 0
    while (i < p.size) {
        if (p[i] > 3) {
            p[i] = p[i] - 4
            val nbs = neighbors[i]
            for (j in nbs) {
                p[j] = p[j] + 1
            }
            return 0
        }
        i = i + 1
    }
    return 0
}

/**
 * Auto-generated from Mochi
 * @param p MutableList<Int>
 * @return String
 */
fun pileString(p: MutableList<Int>): String {
    var s = ""
    var r = 0
    while (r < 3) {
        var c = 0
        while (c < 3) {
            s = s + p[3 * r + c].toString() + " "
            c = c + 1
        }
        s = s + "\n"
        r = r + 1
    }
    return s
}

fun main() {
    println("Avalanche of topplings:\n")
    var s4 = mutableListOf(4, 3, 3, 3, 1, 2, 0, 2, 3)
    println(pileString(s4))
    while (!isStable(s4)) {
        topple(s4)
        println(pileString(s4))
    }
    println("Commutative additions:\n")
    var s1 = mutableListOf(1, 2, 0, 2, 1, 1, 0, 1, 3)
    var s2 = mutableListOf(2, 1, 3, 1, 0, 1, 0, 1, 0)
    var s3_a = plus(s1, s2)
    while (!isStable(s3_a)) {
        topple(s3_a)
    }
    var s3_b = plus(s2, s1)
    while (!isStable(s3_b)) {
        topple(s3_b)
    }
    println(pileString(s1) + "\nplus\n\n" + pileString(s2) + "\nequals\n\n" + pileString(s3_a))
    println("and\n\n" + pileString(s2) + "\nplus\n\n" + pileString(s1) + "\nalso equals\n\n" + pileString(s3_b))
    println("Addition of identity sandpile:\n")
    var s3 = mutableListOf(3, 3, 3, 3, 3, 3, 3, 3, 3)
    var s3_id = mutableListOf(2, 1, 2, 1, 0, 1, 2, 1, 2)
    var s4b = plus(s3, s3_id)
    while (!isStable(s4b)) {
        topple(s4b)
    }
    println(pileString(s3) + "\nplus\n\n" + pileString(s3_id) + "\nequals\n\n" + pileString(s4b))
    println("Addition of identities:\n")
    var s5 = plus(s3_id, s3_id)
    while (!isStable(s5)) {
        topple(s5)
    }
    println(pileString(s3_id) + "\nplus\n\n" + pileString(s3_id) + "\nequals\n\n" + pileString(s5))
}
