// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}
// Code generated from atomic-updates.mochi

/**
 * Auto-generated from Mochi
 * @param seed Int
 * @param n Int
 * @return MutableList<Int>
 */
fun randOrder(seed: Int, n: Int): MutableList<Int> {
    val next = (seed * 1664525 + 1013904223) % 2147483647
    return mutableListOf(next, next % n)
}

/**
 * Auto-generated from Mochi
 * @param seed Int
 * @param n Int
 * @return MutableList<Int>
 */
fun randChaos(seed: Int, n: Int): MutableList<Int> {
    val next = (seed * 1103515245 + 12345) % 2147483647
    return mutableListOf(next, next % n)
}

/**
 * Auto-generated from Mochi
 */
fun main(): Unit {
    val nBuckets = 10
    val initialSum = 1000
    var buckets: MutableList<Int> = mutableListOf<Int>()
    for (i in 0 until nBuckets) {
        buckets = append(buckets, 0)
    }
    var i = nBuckets
    var dist = initialSum
    while (i > 0) {
        val v = (dist).toDouble() / (i).toDouble()
        i = i - 1
        buckets[i] = v
        dist = (dist).toDouble() - v
    }
    var tc0 = 0
    var tc1 = 0
    var total = 0
    var nTicks = 0
    var seedOrder = 1
    var seedChaos = 2
    println("sum  ---updates---    mean  buckets")
    var t = 0
    while (t < 5) {
        var r = randOrder(seedOrder, nBuckets)
        seedOrder = r[0]
        var b1 = r[1]
        var b2 = (b1 + 1) % nBuckets
        val v1 = buckets[b1]
        val v2 = buckets[b2]
        if (v1 > v2) {
            var a = ((((v1 - v2)).toDouble() / (2).toDouble())).toInt()
            if (a > buckets[b1]) {
                a = buckets[b1]
            }
            buckets[b1] = buckets[b1] - a
            buckets[b2] = buckets[b2] + a
        }
        else {
            var a = ((((v2 - v1)).toDouble() / (2).toDouble())).toInt()
            if (a > buckets[b2]) {
                a = buckets[b2]
            }
            buckets[b2] = buckets[b2] - a
            buckets[b1] = buckets[b1] + a
        }
        tc0 = tc0 + 1
        r = randChaos(seedChaos, nBuckets)
        seedChaos = r[0]
        b1 = r[1]
        b2 = (b1 + 1) % nBuckets
        r = randChaos(seedChaos, buckets[b1] + 1)
        seedChaos = r[0]
        var amt = r[1]
        if (amt > buckets[b1]) {
            amt = buckets[b1]
        }
        buckets[b1] = buckets[b1] - amt
        buckets[b2] = buckets[b2] + amt
        tc1 = tc1 + 1
        var sum = 0
        var idx = 0
        while (idx < nBuckets) {
            sum = sum + buckets[idx]
            idx = idx + 1
        }
        total = total + tc0 + tc1
        nTicks = nTicks + 1
        println(sum.toString() + " " + tc0.toString() + " " + tc1.toString() + " " + (total).toDouble() / (nTicks).toDouble().toString() + "  " + buckets.toString())
        tc0 = 0
        tc1 = 0
        t = t + 1
    }
}

