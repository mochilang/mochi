// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}

fun toDouble(v: Any?): Double = when (v) {
    is Double -> v
    is Int -> v.toDouble()
    is String -> v.toDouble()
    else -> 0.0
}
// Code generated from catmull-clark-subdivision-surface.mochi

data class Point(var x: Double, var y: Double, var z: Double)

data class Edge(var pn1: Int, var pn2: Int, var fn1: Int, var fn2: Int, var cp: Point)

data class PointEx(var p: Point, var n: Int)

/**
 * Auto-generated from Mochi
 * @param s String
 * @param ch String
 * @return Int
 */
fun indexOf(s: String, ch: String): Int {
    var i = 0
    while (i < s.length) {
        if (s.substring(i, i + 1) == ch) {
            return i
        }
        i = i + 1
    }
    return -1
}

/**
 * Auto-generated from Mochi
 * @param x Double
 * @return String
 */
fun fmt4(x: Double): String {
    var y = x * 10000.0
    if (y >= 0) {
        y = y + 0.5
    }
    else {
        y = y - 0.5
    }
    y = ((y).toInt()) as Double / 10000.0
    var s = y.toString()
    var dot = indexOf(s, ".")
    if (dot == 0 - 1) {
        s = s + ".0000"
    }
    else {
        var decs = s.length - dot - 1
        if (decs > 4) {
            s = s.substring(0, dot + 5)
        }
        else {
            while (decs < 4) {
                s = s + "0"
                decs = decs + 1
            }
        }
    }
    if (x >= 0.0) {
        s = " " + s
    }
    return s
}

/**
 * Auto-generated from Mochi
 * @param n Int
 * @return String
 */
fun fmt2(n: Int): String {
    val s = n.toString()
    if (s.length < 2) {
        return " " + s
    }
    return s
}

/**
 * Auto-generated from Mochi
 * @param p1 Point
 * @param p2 Point
 * @return Point
 */
fun sumPoint(p1: Point, p2: Point): Point {
    return Point(x = p1.x + p2.x, y = p1.y + p2.y, z = p1.z + p2.z)
}

/**
 * Auto-generated from Mochi
 * @param p Point
 * @param m Double
 * @return Point
 */
fun mulPoint(p: Point, m: Double): Point {
    return Point(x = p.x * m, y = p.y * m, z = p.z * m)
}

/**
 * Auto-generated from Mochi
 * @param p Point
 * @param d Double
 * @return Point
 */
fun divPoint(p: Point, d: Double): Point {
    return mulPoint(p, 1.0 / d)
}

/**
 * Auto-generated from Mochi
 * @param p1 Point
 * @param p2 Point
 * @return Point
 */
fun centerPoint(p1: Point, p2: Point): Point {
    return divPoint(sumPoint(p1, p2), 2.0)
}

/**
 * Auto-generated from Mochi
 * @param points MutableList<Point>
 * @param faces MutableList<MutableList<Int>>
 * @return MutableList<Point>
 */
fun getFacePoints(points: MutableList<Point>, faces: MutableList<MutableList<Int>>): MutableList<Point> {
    var facePoints: MutableList<Point> = mutableListOf<Point>()
    var i = 0
    while (i < faces.size) {
        val face = faces[i]
        var fp = Point(x = 0.0, y = 0.0, z = 0.0)
        for (idx in face) {
            fp = sumPoint(fp, points[idx])
        }
        fp = divPoint(fp, (face.size as Double))
        facePoints = append(facePoints, fp)
        i = i + 1
    }
    return facePoints
}

/**
 * Auto-generated from Mochi
 * @param edges MutableList<MutableList<Int>>
 * @return MutableList<MutableList<Int>>
 */
fun sortEdges(edges: MutableList<MutableList<Int>>): MutableList<MutableList<Int>> {
    var res: MutableList<MutableList<Int>> = mutableListOf<MutableList<Int>>()
    var tmp = edges
    while (tmp.size > 0) {
        var min = tmp[0]
        var idx = 0
        var j = 1
        while (j < tmp.size) {
            val e = tmp[j]
            if (e[0] < toDouble(min[0]) || (e[0] == toDouble(min[0]) && (e[1] < toDouble(min[1]) || (e[1] == toDouble(min[1]) && e[2] < toDouble(min[2]))))) {
                min = e
                idx = j
            }
            j = j + 1
        }
        res = append(res, min)
        var out: MutableList<MutableList<Int>> = mutableListOf<MutableList<Int>>()
        var k = 0
        while (k < tmp.size) {
            if (k != idx) {
                out = append(out, tmp[k])
            }
            k = k + 1
        }
        tmp = out
    }
    return res
}

/**
 * Auto-generated from Mochi
 * @param points MutableList<Point>
 * @param faces MutableList<MutableList<Int>>
 * @return MutableList<Edge>
 */
fun getEdgesFaces(points: MutableList<Point>, faces: MutableList<MutableList<Int>>): MutableList<Edge> {
    var edges: MutableList<MutableList<Int>> = mutableListOf<MutableList<Int>>()
    var fnum = 0
    while (fnum < faces.size) {
        val face = faces[fnum]
        var numP = face.size
        var pi = 0
        while (pi < numP) {
            var pn1 = face[pi]
            var pn2 = 0
            if (pi < numP - 1) {
                pn2 = face[pi + 1]
            }
            else {
                pn2 = face[0]
            }
            if (pn1 > pn2) {
                var tmpn = pn1
                pn1 = pn2
                pn2 = tmpn
            }
            edges = append(edges, mutableListOf(pn1, pn2, fnum))
            pi = pi + 1
        }
        fnum = fnum + 1
    }
    edges = sortEdges(edges)
    var merged: MutableList<MutableList<Int>> = mutableListOf<MutableList<Int>>()
    var idx = 0
    while (idx < edges.size) {
        val e1 = edges[idx]
        if (idx < edges.size - 1) {
            val e2 = edges[idx + 1]
            if (e1[0] == e2[0] && e1[1] == e2[1]) {
                merged = append(merged, mutableListOf(e1[0], e1[1], e1[2], e2[2]))
                idx = idx + 2
                continue
            }
        }
        merged = append(merged, mutableListOf(e1[0], e1[1], e1[2], -1))
        idx = idx + 1
    }
    var edgesCenters: MutableList<Edge> = mutableListOf<Edge>()
    for (me in merged) {
        val p1 = points[me[0]]
        val p2 = points[me[1]]
        val cp = centerPoint(p1, p2)
        edgesCenters = append(edgesCenters, Edge(pn1 = me[0], pn2 = me[1], fn1 = me[2], fn2 = me[3], cp = cp))
    }
    return edgesCenters
}

/**
 * Auto-generated from Mochi
 * @param points MutableList<Point>
 * @param edgesFaces MutableList<Edge>
 * @param facePoints MutableList<Point>
 * @return MutableList<Point>
 */
fun getEdgePoints(points: MutableList<Point>, edgesFaces: MutableList<Edge>, facePoints: MutableList<Point>): MutableList<Point> {
    var edgePoints: MutableList<Point> = mutableListOf<Point>()
    var i = 0
    while (i < edgesFaces.size) {
        val edge = edgesFaces[i]
        val cp = edge.cp
        val fp1 = facePoints[edge.fn1]
        var fp2 = fp1
        if (edge.fn2 != 0 - 1) {
            fp2 = facePoints[edge.fn2]
        }
        val cfp = centerPoint(fp1, fp2)
        edgePoints = append(edgePoints, centerPoint(cp, cfp))
        i = i + 1
    }
    return edgePoints
}

/**
 * Auto-generated from Mochi
 * @param points MutableList<Point>
 * @param faces MutableList<MutableList<Int>>
 * @param facePoints MutableList<Point>
 * @return MutableList<Point>
 */
fun getAvgFacePoints(points: MutableList<Point>, faces: MutableList<MutableList<Int>>, facePoints: MutableList<Point>): MutableList<Point> {
    var numP = points.size
    var temp: MutableList<PointEx> = mutableListOf<PointEx>()
    var i = 0
    while (i < numP) {
        temp = append(temp, PointEx(p = Point(x = 0.0, y = 0.0, z = 0.0), n = 0))
        i = i + 1
    }
    var fnum = 0
    while (fnum < faces.size) {
        val fp = facePoints[fnum]
        for (pn in faces[fnum]) {
            val tp = temp[pn]
            temp[pn] = PointEx(p = sumPoint(tp.p, fp), n = tp.n + 1)
        }
        fnum = fnum + 1
    }
    var avg: MutableList<Point> = mutableListOf<Point>()
    var j = 0
    while (j < numP) {
        val tp = temp[j]
        avg = append(avg, divPoint(tp.p, tp.n as Double))
        j = j + 1
    }
    return avg
}

/**
 * Auto-generated from Mochi
 * @param points MutableList<Point>
 * @param edgesFaces MutableList<Edge>
 * @return MutableList<Point>
 */
fun getAvgMidEdges(points: MutableList<Point>, edgesFaces: MutableList<Edge>): MutableList<Point> {
    var numP = points.size
    var temp: MutableList<PointEx> = mutableListOf<PointEx>()
    var i = 0
    while (i < numP) {
        temp = append(temp, PointEx(p = Point(x = 0.0, y = 0.0, z = 0.0), n = 0))
        i = i + 1
    }
    for (edge in edgesFaces) {
        val cp = edge.cp
        var arr = mutableListOf(edge.pn1, edge.pn2)
        for (pn in arr) {
            val tp = temp[pn]
            temp[pn] = PointEx(p = sumPoint(tp.p, cp), n = tp.n + 1)
        }
    }
    var avg: MutableList<Point> = mutableListOf<Point>()
    var j = 0
    while (j < numP) {
        val tp = temp[j]
        avg = append(avg, divPoint(tp.p, tp.n as Double))
        j = j + 1
    }
    return avg
}

/**
 * Auto-generated from Mochi
 * @param points MutableList<Point>
 * @param faces MutableList<MutableList<Int>>
 * @return MutableList<Int>
 */
fun getPointsFaces(points: MutableList<Point>, faces: MutableList<MutableList<Int>>): MutableList<Int> {
    var pf: MutableList<Int> = mutableListOf<Int>()
    var i = 0
    while (i < points.size) {
        pf = append(pf, 0)
        i = i + 1
    }
    var fnum = 0
    while (fnum < faces.size) {
        for (pn in faces[fnum]) {
            pf[pn] = pf[pn] + 1
        }
        fnum = fnum + 1
    }
    return pf
}

/**
 * Auto-generated from Mochi
 * @param points MutableList<Point>
 * @param pf MutableList<Int>
 * @param afp MutableList<Point>
 * @param ame MutableList<Point>
 * @return MutableList<Point>
 */
fun getNewPoints(points: MutableList<Point>, pf: MutableList<Int>, afp: MutableList<Point>, ame: MutableList<Point>): MutableList<Point> {
    var newPts: MutableList<Point> = mutableListOf<Point>()
    var i = 0
    while (i < points.size) {
        var n = (pf[i] as Int) as Double
        var m1 = (n - 3.0) / n
        var m2 = 1.0 / n
        var m3 = 2.0 / n
        val old = points[i]
        val p1 = mulPoint(old, m1)
        val p2 = mulPoint(afp[i], m2)
        val p3 = mulPoint(ame[i], m3)
        newPts = append(newPts, sumPoint(sumPoint(p1, p2), p3))
        i = i + 1
    }
    return newPts
}

/**
 * Auto-generated from Mochi
 * @param a Int
 * @param b Int
 * @return String
 */
fun key(a: Int, b: Int): String {
    if (a < b) {
        return a.toString() + "," + b.toString()
    }
    return b.toString() + "," + a.toString()
}

/**
 * Auto-generated from Mochi
 * @param points MutableList<Point>
 * @param faces MutableList<MutableList<Int>>
 * @return MutableList<Any>
 */
fun cmcSubdiv(points: MutableList<Point>, faces: MutableList<MutableList<Int>>): MutableList<Any> {
    val facePoints = getFacePoints(points, faces)
    val edgesFaces = getEdgesFaces(points, faces)
    val edgePoints = getEdgePoints(points, edgesFaces, facePoints)
    val avgFacePoints = getAvgFacePoints(points, faces, facePoints)
    val avgMidEdges = getAvgMidEdges(points, edgesFaces)
    val pointsFaces = getPointsFaces(points, faces)
    var newPoints = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges)
    var facePointNums: MutableList<Int> = mutableListOf<Int>()
    var nextPoint = newPoints.size
    for (fp in facePoints) {
        newPoints = append(newPoints, fp)
        facePointNums = append(facePointNums, nextPoint)
        nextPoint = nextPoint + 1
    }
    var edgePointNums: MutableMap<String, Int> = mutableMapOf<String, Int>()
    var idx = 0
    while (idx < edgesFaces.size) {
        val e = edgesFaces[idx]
        newPoints = append(newPoints, edgePoints[idx])
        edgePointNums[key(e.pn1, e.pn2)] = nextPoint
        nextPoint = nextPoint + 1
        idx = idx + 1
    }
    var newFaces: MutableList<MutableList<Int>> = mutableListOf<MutableList<Int>>()
    var fnum = 0
    while (fnum < faces.size) {
        val oldFace = faces[fnum]
        if (oldFace.size == 4) {
            val a = oldFace[0]
            val b = oldFace[1]
            val c = oldFace[2]
            val d = oldFace[3]
            val fpnum = facePointNums[fnum]
            val ab = edgePointNums[key(a, b)]
            val da = edgePointNums[key(d, a)]
            val bc = edgePointNums[key(b, c)]
            val cd = edgePointNums[key(c, d)]
            newFaces = append(newFaces, mutableListOf(a, ab, fpnum, da))
            newFaces = append(newFaces, mutableListOf(b, bc, fpnum, ab))
            newFaces = append(newFaces, mutableListOf(c, cd, fpnum, bc))
            newFaces = append(newFaces, mutableListOf(d, da, fpnum, cd))
        }
        fnum = fnum + 1
    }
    return mutableListOf(newPoints, newFaces)
}

/**
 * Auto-generated from Mochi
 * @param p Point
 * @return String
 */
fun formatPoint(p: Point): String {
    return "[" + fmt4(p.x) + " " + fmt4(p.y) + " " + fmt4(p.z) + "]"
}

/**
 * Auto-generated from Mochi
 * @param f MutableList<Int>
 * @return String
 */
fun formatFace(f: MutableList<Int>): String {
    if (f.size == 0) {
        return "[]"
    }
    var s = "[" + fmt2(f[0])
    var i = 1
    while (i < f.size) {
        s = s + " " + fmt2(f[i])
        i = i + 1
    }
    s = s + "]"
    return s
}

/**
 * Auto-generated from Mochi
 */
fun main(): Unit {
    val inputPoints = mutableListOf(Point(x = -1.0, y = 1.0, z = 1.0), Point(x = -1.0, y = -1.0, z = 1.0), Point(x = 1.0, y = -1.0, z = 1.0), Point(x = 1.0, y = 1.0, z = 1.0), Point(x = 1.0, y = -1.0, z = -1.0), Point(x = 1.0, y = 1.0, z = -1.0), Point(x = -1.0, y = -1.0, z = -1.0), Point(x = -1.0, y = 1.0, z = -1.0))
    val inputFaces = mutableListOf(mutableListOf(0, 1, 2, 3), mutableListOf(3, 2, 4, 5), mutableListOf(5, 4, 6, 7), mutableListOf(7, 0, 3, 5), mutableListOf(7, 6, 1, 0), mutableListOf(6, 1, 2, 4))
    var outputPoints = inputPoints
    var outputFaces = inputFaces
    var i = 0
    while (i < 1) {
        val res = cmcSubdiv(outputPoints, outputFaces)
        outputPoints = res[0]
        outputFaces = res[1]
        i = i + 1
    }
    for (p in outputPoints) {
        println(formatPoint(p))
    }
    println("")
    for (f in outputFaces) {
        println(formatFace(f))
    }
}

