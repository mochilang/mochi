// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun toDouble(v: Any?): Double = when (v) {
    is Double -> v
    is Int -> v.toDouble()
    is String -> v.toDouble()
    else -> 0.0
}
// Code generated from adfgvx-cipher.mochi

var adfgvx = "ADFGVX"

var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

/**
 * Auto-generated from Mochi
 * @param s String
 * @return String
 */
fun shuffleStr(s: String): String {
    var arr: MutableList<String> = mutableListOf<String>()
    var i = 0
    while (i < s.length) {
        arr = arr + mutableListOf(s[i])
        i = i + 1
    }
    var j = arr.size - 1
    while (j > 0) {
        val k = System.nanoTime().toInt() % (j + 1)
        val tmp = arr[j]
        arr[j] = arr[k]
        arr[k] = tmp
        j = j - 1
    }
    var out = ""
    i = 0
    while (i < arr.size) {
        out = out + arr[i]
        i = i + 1
    }
    return out
}

/**
 * Auto-generated from Mochi
 * @return MutableList<String>
 */
fun createPolybius(): MutableList<String> {
    val shuffled = shuffleStr(alphabet)
    println("6 x 6 Polybius square:\n")
    println("  | A D F G V X")
    println("---------------")
    var p: MutableList<String> = mutableListOf<String>()
    var i = 0
    while (i < 6) {
        var row = shuffled.substring(i * 6, (i + 1) * 6)
        p = p + mutableListOf(row)
        var line = adfgvx[i] + " | "
        var j = 0
        while (j < 6) {
            line = line + row[j] + " "
            j = j + 1
        }
        println(line)
        i = i + 1
    }
    return p
}

/**
 * Auto-generated from Mochi
 * @param n Int
 * @return String
 */
fun createKey(n: Int): String {
    if (n < 7 || n > 12) {
        println("Key should be within 7 and 12 letters long.")
    }
    var pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    var key = ""
    var i = 0
    while (i < n) {
        val idx = System.nanoTime().toInt() % pool.length
        key = key + pool[idx]
        pool = pool.substring(0, idx) + pool.substring(idx + 1, pool.length)
        i = i + 1
    }
    println("\nThe key is " + key)
    return key
}

/**
 * Auto-generated from Mochi
 * @param key String
 * @return MutableList<Int>
 */
fun orderKey(key: String): MutableList<Int> {
    var pairs = mutableListOf<Any?>()
    var i = 0
    while (i < key.length) {
        pairs = pairs + mutableListOf(mutableListOf(key[i], i))
        i = i + 1
    }
    var n = pairs.size
    var m = 0
    while (m < n) {
        var j = 0
        while (j < n - 1) {
            if (toDouble(pairs[j]!![0]) > toDouble(pairs[j + 1]!![0])) {
                val tmp = pairs[j]
                pairs[j] = pairs[j + 1]
                pairs[j + 1] = tmp
            }
            j = j + 1
        }
        m = m + 1
    }
    var res = mutableListOf<Any?>()
    i = 0
    while (i < n) {
        res = res + mutableListOf((pairs[i]!![1]!!).toInt())
        i = i + 1
    }
    return res
}

/**
 * Auto-generated from Mochi
 * @param polybius MutableList<String>
 * @param key String
 * @param plainText String
 * @return String
 */
fun encrypt(polybius: MutableList<String>, key: String, plainText: String): String {
    var temp = ""
    var i = 0
    while (i < plainText.length) {
        var r = 0
        while (r < 6) {
            var c = 0
            while (c < 6) {
                if ((polybius[r] as String)[c] == plainText[i]) {
                    temp = temp + adfgvx[r] + adfgvx[c]
                }
                c = c + 1
            }
            r = r + 1
        }
        i = i + 1
    }
    var colLen = (temp.length).toDouble() / (key.length).toDouble()
    if (temp.length % key.length > 0) {
        colLen = colLen + (1).toDouble()
    }
    var table: MutableList<MutableList<String>> = mutableListOf<MutableList<String>>()
    var rIdx = 0
    while (rIdx < colLen) {
        var row: MutableList<String> = mutableListOf<String>()
        var j = 0
        while (j < key.length) {
            row = row + mutableListOf("")
            j = j + 1
        }
        table = table + mutableListOf(row)
        rIdx = rIdx + 1
    }
    var idx = 0
    while (idx < temp.length) {
        val row = (idx).toDouble() / (key.length).toDouble()
        val col = idx % key.length
        table[row]!![col] = temp.substring(idx, idx + 1)
        idx = idx + 1
    }
    val order = orderKey(key)
    var cols: MutableList<String> = mutableListOf<String>()
    var ci = 0
    while (ci < key.length) {
        var colStr = ""
        var ri = 0
        while (ri < colLen) {
            colStr = colStr + (table[ri] as MutableList<String>)[order[ci]]
            ri = ri + 1
        }
        cols = cols + mutableListOf(colStr)
        ci = ci + 1
    }
    var result = ""
    ci = 0
    while (ci < cols.size) {
        result = result + cols[ci]
        if (ci < cols.size - 1) {
            result = result + " "
        }
        ci = ci + 1
    }
    return result
}

/**
 * Auto-generated from Mochi
 * @param s String
 * @param ch String
 * @return Int
 */
fun indexOf(s: String, ch: String): Int {
    var i = 0
    while (i < s.length) {
        if (s[i] == ch) {
            return i
        }
        i = i + 1
    }
    return -1
}

/**
 * Auto-generated from Mochi
 * @param polybius MutableList<String>
 * @param key String
 * @param cipherText String
 * @return String
 */
fun decrypt(polybius: MutableList<String>, key: String, cipherText: String): String {
    var colStrs: MutableList<String> = mutableListOf<String>()
    var start = 0
    var i = 0
    while (i <= cipherText.length) {
        if (i == cipherText.length || cipherText[i] == " ") {
            colStrs = colStrs + mutableListOf(cipherText.substring(start, i))
            start = i + 1
        }
        i = i + 1
    }
    var maxColLen = 0
    i = 0
    while (i < colStrs.size) {
        if (colStrs[i].size > maxColLen) {
            maxColLen = colStrs[i].size
        }
        i = i + 1
    }
    var cols: MutableList<MutableList<String>> = mutableListOf<MutableList<String>>()
    i = 0
    while (i < colStrs.size) {
        var s = colStrs[i]
        var ls: MutableList<String> = mutableListOf<String>()
        var j = 0
        while (j < s.length) {
            ls = ls + mutableListOf(s[j])
            j = j + 1
        }
        if (s.length < maxColLen) {
            var pad: MutableList<String> = mutableListOf<String>()
            var k = 0
            while (k < maxColLen) {
                if (k < ls.size) {
                    pad = pad + mutableListOf(ls[k])
                }
                else {
                    pad = pad + mutableListOf("")
                }
                k = k + 1
            }
            cols = cols + mutableListOf(pad)
        }
        else {
            cols = cols + mutableListOf(ls)
        }
        i = i + 1
    }
    var table: MutableList<MutableList<String>> = mutableListOf<MutableList<String>>()
    var r = 0
    while (r < maxColLen) {
        var row: MutableList<String> = mutableListOf<String>()
        var c = 0
        while (c < key.length) {
            row = row + mutableListOf("")
            c = c + 1
        }
        table = table + mutableListOf(row)
        r = r + 1
    }
    val order = orderKey(key)
    r = 0
    while (r < maxColLen) {
        var c = 0
        while (c < key.length) {
            table[r]!![order[c]] = (cols[c] as MutableList<String>)[r]
            c = c + 1
        }
        r = r + 1
    }
    var temp = ""
    r = 0
    while (r < table.size) {
        var j = 0
        while (j < table[r].size) {
            temp = temp + (table[r] as MutableList<String>)[j]
            j = j + 1
        }
        r = r + 1
    }
    var plainText = ""
    var idx = 0
    while (idx < temp.length) {
        val rIdx = indexOf(adfgvx, temp.substring(idx, idx + 1))
        val cIdx = indexOf(adfgvx, temp.substring(idx + 1, idx + 2))
        plainText = plainText + (polybius[rIdx] as String)[cIdx]
        idx = idx + 2
    }
    return plainText
}

/**
 * Auto-generated from Mochi
 */
fun main(): Unit {
    val plainText = "ATTACKAT1200AM"
    val polybius = createPolybius()
    val key = createKey(9)
    println("\nPlaintext : " + plainText)
    val cipherText = encrypt(polybius, key, plainText)
    println("\nEncrypted : " + cipherText)
    val plainText2 = decrypt(polybius, key, cipherText)
    println("\nDecrypted : " + plainText2)
}

