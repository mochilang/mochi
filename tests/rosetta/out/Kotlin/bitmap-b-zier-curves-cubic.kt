// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}
// Code generated from bitmap-b-zier-curves-cubic.mochi

data class Pixel(var r: Int, var g: Int, var b: Int)

val b3Seg = 30

var b = newBitmap(400, 300)

/**
 * Auto-generated from Mochi
 * @param rgb Int
 * @return Pixel
 */
fun pixelFromRgb(rgb: Int): Pixel {
    val r = ((((rgb).toDouble() / (65536).toDouble()) % (256).toDouble())).toInt()
    val g = ((((rgb).toDouble() / (256).toDouble()) % (256).toDouble())).toInt()
    val b = ((rgb % 256)).toInt()
    return Pixel(r = r, g = g, b = b)
}

/**
 * Auto-generated from Mochi
 * @param cols Int
 * @param rows Int
 * @return MutableMap<String, Any>
 */
fun newBitmap(cols: Int, rows: Int): MutableMap<String, Any> {
    var d: MutableList<MutableList<Pixel>> = mutableListOf<MutableList<Pixel>>()
    var y = 0
    while (y < rows) {
        var row: MutableList<Pixel> = mutableListOf<Pixel>()
        var x = 0
        while (x < cols) {
            row = append(row, Pixel(r = 0, g = 0, b = 0))
            x = x + 1
        }
        d = append(d, row)
        y = y + 1
    }
    return mutableMapOf("cols" to cols, "rows" to rows, "data" to d)
}

/**
 * Auto-generated from Mochi
 * @param b MutableMap<String, Any>
 * @param x Int
 * @param y Int
 * @param p Pixel
 */
fun setPx(b: MutableMap<String, Any>, x: Int, y: Int, p: Pixel): Unit {
    val cols = ((b["cols"] as Any?)).toInt()
    val rows = ((b["rows"] as Any?)).toInt()
    if (x >= 0 && x < cols && y >= 0 && y < rows) {
        b["data"]!![y]!![x] = p
    }
}

/**
 * Auto-generated from Mochi
 * @param b MutableMap<String, Any>
 * @param p Pixel
 */
fun fill(b: MutableMap<String, Any>, p: Pixel): Unit {
    val cols = ((b["cols"] as Any?)).toInt()
    val rows = ((b["rows"] as Any?)).toInt()
    var y = 0
    while (y < rows) {
        var x = 0
        while (x < cols) {
            b["data"]!![y]!![x] = p
            x = x + 1
        }
        y = y + 1
    }
}

/**
 * Auto-generated from Mochi
 * @param b MutableMap<String, Any>
 * @param rgb Int
 */
fun fillRgb(b: MutableMap<String, Any>, rgb: Int): Unit {
    fill(b, pixelFromRgb(rgb))
}

/**
 * Auto-generated from Mochi
 * @param b MutableMap<String, Any>
 * @param x0 Int
 * @param y0 Int
 * @param x1 Int
 * @param y1 Int
 * @param p Pixel
 */
fun line(b: MutableMap<String, Any>, x0: Int, y0: Int, x1: Int, y1: Int, p: Pixel): Unit {
    var dx = x1 - x0
    if (dx < 0) {
        dx = -dx
    }
    var dy = y1 - y0
    if (dy < 0) {
        dy = -dy
    }
    var sx = -1
    if (x0 < x1) {
        sx = 1
    }
    var sy = -1
    if (y0 < y1) {
        sy = 1
    }
    var err = dx - dy
    while (true) {
        setPx(b, x0, y0, p)
        if (x0 == x1 && y0 == y1) {
            break
        }
        val e2 = 2 * err
        if (e2 > (0 - dy)) {
            err = err - dy
            x0 = x0 + sx
        }
        if (e2 < dx) {
            err = err + dx
            y0 = y0 + sy
        }
    }
}

/**
 * Auto-generated from Mochi
 * @param b MutableMap<String, Any>
 * @param x1 Int
 * @param y1 Int
 * @param x2 Int
 * @param y2 Int
 * @param x3 Int
 * @param y3 Int
 * @param x4 Int
 * @param y4 Int
 * @param p Pixel
 */
fun bezier3(b: MutableMap<String, Any>, x1: Int, y1: Int, x2: Int, y2: Int, x3: Int, y3: Int, x4: Int, y4: Int, p: Pixel): Unit {
    var px: MutableList<Int> = mutableListOf<Int>()
    var py: MutableList<Int> = mutableListOf<Int>()
    var i = 0
    while (i <= b3Seg) {
        px = append(px, 0)
        py = append(py, 0)
        i = i + 1
    }
    val fx1 = x1 as Double
    val fy1 = y1 as Double
    val fx2 = x2 as Double
    val fy2 = y2 as Double
    val fx3 = x3 as Double
    val fy3 = y3 as Double
    val fx4 = x4 as Double
    val fy4 = y4 as Double
    i = 0
    while (i <= b3Seg) {
        val d = (i as Double) / (b3Seg as Double)
        var a = 1.0 - d
        var bcoef = a * a
        var ccoef = d * d
        var a2 = a * bcoef
        var b2 = 3.0 * bcoef * d
        var c2 = 3.0 * a * ccoef
        var d2 = ccoef * d
        px[i] = ((a2 * fx1 + b2 * fx2 + c2 * fx3 + d2 * fx4)).toInt()
        py[i] = ((a2 * fy1 + b2 * fy2 + c2 * fy3 + d2 * fy4)).toInt()
        i = i + 1
    }
    var x0 = px[0]
    var y0 = py[0]
    i = 1
    while (i <= b3Seg) {
        val x = px[i]
        val y = py[i]
        line(b, x0, y0, x, y, p)
        x0 = x
        y0 = y
        i = i + 1
    }
}

fun main() {
    fillRgb(b, 16773055)
    bezier3(b, 20, 200, 700, 50, -300, 50, 380, 150, pixelFromRgb(4165615))
}
