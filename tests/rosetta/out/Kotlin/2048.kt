// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:31:00Z
fun String.starts_with(prefix: String): Boolean = this.startsWith(prefix)

fun toInt(v: Any?): Int = when (v) {
    is Int -> v
    is Double -> v.toInt()
    is String -> v.toInt()
    is Boolean -> if (v) 1 else 0
    else -> 0
}

fun toDouble(v: Any?): Double = when (v) {
    is Double -> v
    is Int -> v.toDouble()
    is String -> v.toDouble()
    else -> 0.0
}

fun toBool(v: Any?): Boolean = when (v) {
    is Boolean -> v
    is Int -> v != 0
    is Double -> v != 0.0
    is String -> v.isNotEmpty()
    null -> false
    else -> true
}
// Code generated from 2048.mochi

val SIZE = 4

var board = newBoard()

var r = spawnTile(board)

var full = r["full"]

var score = 0

/**
 * Auto-generated from Mochi
 * @return MutableList<MutableList<Int>>
 */
fun newBoard(): MutableList<MutableList<Int>> {
    var b: MutableList<MutableList<Int>> = mutableListOf()
    var y = 0
    while (y < SIZE) {
        var row: MutableList<Int> = mutableListOf()
        var x = 0
        while (x < SIZE) {
            row = row + 0
            x = x + 1
        }
        b = b + row
        y = y + 1
    }
    return b
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @return MutableMap<String, Any>
 */
fun spawnTile(b: MutableList<MutableList<Int>>): MutableMap<String, Any> {
    var empty: MutableList<MutableList<Int>> = mutableListOf()
    var y = 0
    while (y < SIZE) {
        var x = 0
        while (x < SIZE) {
            if ((b[y] as MutableList<Int>)[x] == 0) {
                empty = empty + mutableListOf(x, y)
            }
            x = x + 1
        }
        y = y + 1
    }
    if (empty.size == 0) {
        return mutableMapOf("board" to b, "full" to true)
    }
    var idx = now() % empty.size
    val cell = empty[idx]
    var val = 4
    if (now() % 10 < 9) {
        val = 2
    }
    b[cell[1]]!![cell[0]] = val
    return mutableMapOf("board" to b, "full" to empty.size == 1)
}

/**
 * Auto-generated from Mochi
 * @param n Int
 * @return String
 */
fun pad(n: Int): String {
    var s = n.toString()
    var pad = 4 - s.length
    var i = 0
    var out = ""
    while (i < pad) {
        out = out + " "
        i = i + 1
    }
    return out + s
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @param score Int
 */
fun draw(b: MutableList<MutableList<Int>>, score: Int): Unit {
    println("Score: " + score.toString())
    var y = 0
    while (y < SIZE) {
        println("+----+----+----+----+")
        var line = "|"
        var x = 0
        while (x < SIZE) {
            var v = (b[y] as MutableList<Int>)[x]
            if (v == 0) {
                line = line + "    |"
            }
            else {
                line = line + pad(v) + "|"
            }
            x = x + 1
        }
        println(line)
        y = y + 1
    }
    println("+----+----+----+----+")
    println("W=Up S=Down A=Left D=Right Q=Quit")
}

/**
 * Auto-generated from Mochi
 * @param r MutableList<Int>
 * @return MutableList<Int>
 */
fun reverseRow(r: MutableList<Int>): MutableList<Int> {
    var out: MutableList<Int> = mutableListOf()
    var i = r.size - 1
    while (i >= 0) {
        out = out + r[i]
        i = i - 1
    }
    return out
}

/**
 * Auto-generated from Mochi
 * @param row MutableList<Int>
 * @return MutableMap<String, Any>
 */
fun slideLeft(row: MutableList<Int>): MutableMap<String, Any> {
    var xs: MutableList<Int> = mutableListOf()
    var i = 0
    while (i < row.size) {
        if (row[i] != 0) {
            xs = xs + row[i]
        }
        i = i + 1
    }
    var res: MutableList<Int> = mutableListOf()
    var gain = 0
    i = 0
    while (i < xs.size) {
        if (i + 1 < xs.size && xs[i] == xs[i + 1]) {
            val v = xs[i] * 2
            gain = gain + v
            res = res + v
            i = i + 2
        }
        else {
            res = res + xs[i]
            i = i + 1
        }
    }
    while (res.size < SIZE) {
        res = res + 0
    }
    return mutableMapOf("row" to res, "gain" to gain)
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @param score Int
 * @return MutableMap<String, Any>
 */
fun moveLeft(b: MutableList<MutableList<Int>>, score: Int): MutableMap<String, Any> {
    var moved = false
    var y = 0
    while (y < SIZE) {
        val r = slideLeft(b[y])
        val new = r["row"]
        score = score + toInt(r["gain"])
        var x = 0
        while (x < SIZE) {
            if ((b[y] as MutableList<Int>)[x] != toDouble(new[x])) {
                moved = true
            }
            b[y]!![x] = new[x]
            x = x + 1
        }
        y = y + 1
    }
    return mutableMapOf("board" to b, "score" to score, "moved" to moved)
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @param score Int
 * @return MutableMap<String, Any>
 */
fun moveRight(b: MutableList<MutableList<Int>>, score: Int): MutableMap<String, Any> {
    var moved = false
    var y = 0
    while (y < SIZE) {
        var rev = reverseRow(b[y])
        val r = slideLeft(rev)
        rev = r["row"]
        score = score + toInt(r["gain"])
        rev = reverseRow(rev)
        var x = 0
        while (x < SIZE) {
            if ((b[y] as MutableList<Int>)[x] != rev[x]) {
                moved = true
            }
            b[y]!![x] = rev[x]
            x = x + 1
        }
        y = y + 1
    }
    return mutableMapOf("board" to b, "score" to score, "moved" to moved)
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @param x Int
 * @return MutableList<Int>
 */
fun getCol(b: MutableList<MutableList<Int>>, x: Int): MutableList<Int> {
    var col: MutableList<Int> = mutableListOf()
    var y = 0
    while (y < SIZE) {
        col = col + (b[y] as MutableList<Int>)[x]
        y = y + 1
    }
    return col
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @param x Int
 * @param col MutableList<Int>
 */
fun setCol(b: MutableList<MutableList<Int>>, x: Int, col: MutableList<Int>): Unit {
    var y = 0
    while (y < SIZE) {
        b[y]!![x] = col[y]
        y = y + 1
    }
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @param score Int
 * @return MutableMap<String, Any>
 */
fun moveUp(b: MutableList<MutableList<Int>>, score: Int): MutableMap<String, Any> {
    var moved = false
    var x = 0
    while (x < SIZE) {
        var col = getCol(b, x)
        val r = slideLeft(col)
        val new = r["row"]
        score = score + toInt(r["gain"])
        var y = 0
        while (y < SIZE) {
            if ((b[y] as MutableList<Int>)[x] != toDouble(new[y])) {
                moved = true
            }
            b[y]!![x] = new[y]
            y = y + 1
        }
        x = x + 1
    }
    return mutableMapOf("board" to b, "score" to score, "moved" to moved)
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @param score Int
 * @return MutableMap<String, Any>
 */
fun moveDown(b: MutableList<MutableList<Int>>, score: Int): MutableMap<String, Any> {
    var moved = false
    var x = 0
    while (x < SIZE) {
        var col = reverseRow(getCol(b, x))
        val r = slideLeft(col)
        col = r["row"]
        score = score + toInt(r["gain"])
        col = reverseRow(col)
        var y = 0
        while (y < SIZE) {
            if ((b[y] as MutableList<Int>)[x] != col[y]) {
                moved = true
            }
            b[y]!![x] = col[y]
            y = y + 1
        }
        x = x + 1
    }
    return mutableMapOf("board" to b, "score" to score, "moved" to moved)
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @return Boolean
 */
fun hasMoves(b: MutableList<MutableList<Int>>): Boolean {
    var y = 0
    while (y < SIZE) {
        var x = 0
        while (x < SIZE) {
            if ((b[y] as MutableList<Int>)[x] == 0) {
                return true
            }
            if (x + 1 < SIZE && (b[y] as MutableList<Int>)[x] == (b[y] as MutableList<Int>)[x + 1]) {
                return true
            }
            if (y + 1 < SIZE && (b[y] as MutableList<Int>)[x] == (b[y + 1] as MutableList<Int>)[x]) {
                return true
            }
            x = x + 1
        }
        y = y + 1
    }
    return false
}

/**
 * Auto-generated from Mochi
 * @param b MutableList<MutableList<Int>>
 * @return Boolean
 */
fun has2048(b: MutableList<MutableList<Int>>): Boolean {
    var y = 0
    while (y < SIZE) {
        var x = 0
        while (x < SIZE) {
            if ((b[y] as MutableList<Int>)[x] >= 2048) {
                return true
            }
            x = x + 1
        }
        y = y + 1
    }
    return false
}

fun main() {
    board = r["board"]
    r = spawnTile(board)
    board = r["board"]
    full = r["full"]
    draw(board, score)
    while (true) {
        println("Move: ")
        val cmd = input()
        var moved = false
        if (cmd == "a" || cmd == "A") {
            val m = moveLeft(board, score)
            board = m["board"]
            score = m["score"]
            moved = m["moved"]
        }
        if (cmd == "d" || cmd == "D") {
            val m = moveRight(board, score)
            board = m["board"]
            score = m["score"]
            moved = m["moved"]
        }
        if (cmd == "w" || cmd == "W") {
            val m = moveUp(board, score)
            board = m["board"]
            score = m["score"]
            moved = m["moved"]
        }
        if (cmd == "s" || cmd == "S") {
            val m = moveDown(board, score)
            board = m["board"]
            score = m["score"]
            moved = m["moved"]
        }
        if (cmd == "q" || cmd == "Q") {
            break
        }
        if (moved) {
            val r2 = spawnTile(board)
            board = r2["board"]
            full = r2["full"]
            if (toBool(full && (!hasMoves(board)))) {
                draw(board, score)
                println("Game Over")
                break
            }
        }
        draw(board, score)
        if (has2048(board)) {
            println("You win!")
            break
        }
        if (!hasMoves(board)) {
            println("Game Over")
            break
        }
    }
}
