// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}
// Code generated from bitmap-read-a-ppm-file.mochi

data class Pixel(var R: Int, var G: Int, var B: Int)

data class Bitmap(var w: Int, var h: Int, var max: Int, var data: MutableList<MutableList<Pixel>>)

var ppmtxt = "P3\n" + "# feep.ppm\n" + "4 4\n" + "15\n" + " 0  0  0    0  0  0    0  0  0   15  0 15\n" + " 0  0  0    0 15  7    0  0  0    0  0  0\n" + " 0  0  0    0  0  0    0 15  7    0  0  0\n" + "15  0 15    0  0  0    0  0  0    0  0  0\n"

/**
 * Auto-generated from Mochi
 * @param w Int
 * @param h Int
 * @param max Int
 * @return Bitmap
 */
fun newBitmap(w: Int, h: Int, max: Int): Bitmap {
    var rows: MutableList<MutableList<Pixel>> = mutableListOf<MutableList<Pixel>>()
    var y = 0
    while (y < h) {
        var row: MutableList<Pixel> = mutableListOf<Pixel>()
        var x = 0
        while (x < w) {
            row = append(row, Pixel(R = 0, G = 0, B = 0))
            x = x + 1
        }
        rows = append(rows, row)
        y = y + 1
    }
    return Bitmap(w = w, h = h, max = max, data = rows)
}

/**
 * Auto-generated from Mochi
 * @param b Bitmap
 * @param x Int
 * @param y Int
 * @param p Pixel
 */
fun setPx(b: Bitmap, x: Int, y: Int, p: Pixel): Unit {
    var rows = b.data
    var row = rows[y]
    row[x] = p
    rows[y] = row
    b.data = rows
}

/**
 * Auto-generated from Mochi
 * @param b Bitmap
 * @param x Int
 * @param y Int
 * @return Pixel
 */
fun getPx(b: Bitmap, x: Int, y: Int): Pixel {
    return (b.data[y] as MutableList<Pixel>)[x]
}

/**
 * Auto-generated from Mochi
 * @param s String
 * @return MutableList<String>
 */
fun splitLines(s: String): MutableList<String> {
    var out: MutableList<String> = mutableListOf<String>()
    var cur = ""
    var i = 0
    while (i < s.length) {
        val ch = substr(s, i, i + 1)
        if (ch == "\n") {
            out = append(out, cur)
            cur = ""
        }
        else {
            cur = cur + ch
        }
        i = i + 1
    }
    out = append(out, cur)
    return out
}

/**
 * Auto-generated from Mochi
 * @param s String
 * @return MutableList<String>
 */
fun splitWS(s: String): MutableList<String> {
    var out: MutableList<String> = mutableListOf<String>()
    var cur = ""
    var i = 0
    while (i < s.length) {
        val ch = substr(s, i, i + 1)
        if (ch == " " || ch == "\t" || ch == "\r" || ch == "\n") {
            if (cur.length > 0) {
                out = append(out, cur)
                cur = ""
            }
        }
        else {
            cur = cur + ch
        }
        i = i + 1
    }
    if (cur.length > 0) {
        out = append(out, cur)
    }
    return out
}

/**
 * Auto-generated from Mochi
 * @param str String
 * @return Int
 */
fun parseIntStr(str: String): Int {
    var i = 0
    var neg = false
    if (str.length > 0 && str.substring(0, 1) == "-") {
        neg = true
        i = 1
    }
    var n = 0
    val digits = mutableMapOf("0" to 0, "1" to 1, "2" to 2, "3" to 3, "4" to 4, "5" to 5, "6" to 6, "7" to 7, "8" to 8, "9" to 9)
    while (i < str.length) {
        n = n * 10 + digits[str.substring(i, i + 1)]
        i = i + 1
    }
    if (neg) {
        n = -n
    }
    return n
}

/**
 * Auto-generated from Mochi
 * @param s String
 * @return MutableList<String>
 */
fun tokenize(s: String): MutableList<String> {
    val lines = splitLines(s)
    var toks: MutableList<String> = mutableListOf<String>()
    var i = 0
    while (i < lines.size) {
        val line = lines[i]
        if (line.length > 0 && substr(line, 0, 1) == "#") {
            i = i + 1
            continue
        }
        val parts = splitWS(line)
        var j = 0
        while (j < parts.size) {
            toks = append(toks, parts[j])
            j = j + 1
        }
        i = i + 1
    }
    return toks
}

/**
 * Auto-generated from Mochi
 * @param text String
 * @return Bitmap
 */
fun readP3(text: String): Bitmap {
    val toks = tokenize(text)
    if (toks.size < 4) {
        return newBitmap(0, 0, 0)
    }
    if (toks[0] != "P3") {
        return newBitmap(0, 0, 0)
    }
    val w: Int = parseIntStr(toks[1])
    val h: Int = parseIntStr(toks[2])
    val maxv: Int = parseIntStr(toks[3])
    var idx = 4
    var bm = newBitmap(w, h, maxv)
    var y = h - 1
    while (y >= 0) {
        var x = 0
        while (x < w) {
            val r: Int = parseIntStr(toks[idx])
            val g: Int = parseIntStr(toks[idx + 1])
            val b: Int = parseIntStr(toks[idx + 2])
            setPx(bm, x, y, Pixel(R = r, G = g, B = b))
            idx = idx + 3
            x = x + 1
        }
        y = y - 1
    }
    return bm
}

/**
 * Auto-generated from Mochi
 * @param b Bitmap
 */
fun toGrey(b: Bitmap): Unit {
    val h: Int = b.h
    val w: Int = b.w
    var m = 0
    var y = 0
    while (y < h) {
        var x = 0
        while (x < w) {
            val p = getPx(b, x, y)
            var l = ((p.R * 2126 + p.G * 7152 + p.B * 722)).toDouble() / (10000).toDouble()
            if (l > b.max) {
                l = b.max
            }
            setPx(b, x, y, Pixel(R = l, G = l, B = l))
            if (l > m) {
                m = l
            }
            x = x + 1
        }
        y = y + 1
    }
    b.max = m
}

/**
 * Auto-generated from Mochi
 * @param n Int
 * @param w Int
 * @return String
 */
fun pad(n: Int, w: Int): String {
    var s = n.toString()
    while (s.length < w) {
        s = " " + s
    }
    return s
}

/**
 * Auto-generated from Mochi
 * @param b Bitmap
 * @return String
 */
fun writeP3(b: Bitmap): String {
    val h: Int = b.h
    val w: Int = b.w
    var max = b.max
    val digits = max.toString().size
    var out = "P3\n# generated from Bitmap.writeppmp3\n" + w.toString() + " " + h.toString() + "\n" + max.toString() + "\n"
    var y = h - 1
    while (y >= 0) {
        var line = ""
        var x = 0
        while (x < w) {
            val p = getPx(b, x, y)
            line = line + "   " + pad(p.R, digits) + " " + pad(p.G, digits) + " " + pad(p.B, digits)
            x = x + 1
        }
        out = out + line + "\n"
        y = y - 1
    }
    return out
}

fun main() {
    println("Original Colour PPM file")
    println(ppmtxt)
    var bm = readP3(ppmtxt)
    println("Grey PPM:")
    toGrey(bm)
    val out = writeP3(bm)
    println(out)
}
