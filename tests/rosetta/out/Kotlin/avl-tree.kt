// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun toDouble(v: Any?): Double = when (v) {
    is Double -> v
    is Int -> v.toDouble()
    is String -> v.toDouble()
    else -> 0.0
}

fun toBool(v: Any?): Boolean = when (v) {
    is Boolean -> v
    is Int -> v != 0
    is Double -> v != 0.0
    is String -> v.isNotEmpty()
    null -> false
    else -> true
}
// Code generated from avl-tree.mochi

/**
 * Auto-generated from Mochi
 * @param data Int
 * @return MutableMap<String, Any>
 */
fun Node(data: Int): MutableMap<String, Any> {
    return mutableMapOf("Data" to data, "Balance" to 0, "Link" to (mutableListOf(null, null)))
}

/**
 * Auto-generated from Mochi
 * @param n MutableMap<String, Any>
 * @param dir Int
 * @return Any
 */
fun getLink(n: MutableMap<String, Any>, dir: Int): Any {
    return ((n["Link"] as Any?) as MutableList<Any>)[dir]
}

/**
 * Auto-generated from Mochi
 * @param n MutableMap<String, Any>
 * @param dir Int
 * @param v Any
 */
fun setLink(n: MutableMap<String, Any>, dir: Int, v: Any): Unit {
    var links = (n["Link"] as Any?) as MutableList<Any>
    links[dir] = v
    n["Link"] = links
}

/**
 * Auto-generated from Mochi
 * @param dir Int
 * @return Int
 */
fun opp(dir: Int): Int {
    return 1 - dir
}

/**
 * Auto-generated from Mochi
 * @param root MutableMap<String, Any>
 * @param dir Int
 * @return MutableMap<String, Any>
 */
fun single(root: MutableMap<String, Any>, dir: Int): MutableMap<String, Any> {
    var tmp = getLink(root, opp(dir))
    setLink(root, opp(dir), getLink(tmp, dir))
    setLink(tmp, dir, root)
    return tmp
}

/**
 * Auto-generated from Mochi
 * @param root MutableMap<String, Any>
 * @param dir Int
 * @return MutableMap<String, Any>
 */
fun double(root: MutableMap<String, Any>, dir: Int): MutableMap<String, Any> {
    var tmp = getLink(getLink(root, opp(dir)), dir)
    setLink(getLink(root, opp(dir)), dir, getLink(tmp, opp(dir)))
    setLink(tmp, opp(dir), getLink(root, opp(dir)))
    setLink(root, opp(dir), tmp)
    tmp = getLink(root, opp(dir))
    setLink(root, opp(dir), getLink(tmp, dir))
    setLink(tmp, dir, root)
    return tmp
}

/**
 * Auto-generated from Mochi
 * @param root MutableMap<String, Any>
 * @param dir Int
 * @param bal Int
 */
fun adjustBalance(root: MutableMap<String, Any>, dir: Int, bal: Int): Unit {
    var n = getLink(root, dir) as MutableMap<String, Any>
    var nn = getLink(n, opp(dir)) as MutableMap<String, Any>
    if (toDouble(nn["Balance"]) == 0) {
        root["Balance"] = 0
        n["Balance"] = 0
    }
    else
    if (toDouble(nn["Balance"]) == bal) {
        root["Balance"] = -bal
        n["Balance"] = 0
    }
    else {
        root["Balance"] = 0
        n["Balance"] = bal
    }
    nn["Balance"] = 0
}

/**
 * Auto-generated from Mochi
 * @param root MutableMap<String, Any>
 * @param dir Int
 * @return MutableMap<String, Any>
 */
fun insertBalance(root: MutableMap<String, Any>, dir: Int): MutableMap<String, Any> {
    var n = getLink(root, dir) as MutableMap<String, Any>
    var bal = 2 * dir - 1
    if (toDouble(n["Balance"]) == bal) {
        root["Balance"] = 0
        n["Balance"] = 0
        return single(root, opp(dir))
    }
    adjustBalance(root, dir, bal)
    return double(root, opp(dir))
}

/**
 * Auto-generated from Mochi
 * @param root Any
 * @param data Int
 * @return MutableMap<String, Any>
 */
fun insertR(root: Any, data: Int): MutableMap<String, Any> {
    if (toDouble(root) == toDouble(null)) {
        return mutableMapOf("node" to (Node(data)), "done" to false)
    }
    var node = root as MutableMap<String, Any>
    var dir = 0
    if ((((node["Data"] as Any?)).toInt()) < data) {
        dir = 1
    }
    var r = insertR(getLink(node, dir), data)
    setLink(node, dir, r["node"])
    if (toBool(r["done"])) {
        return mutableMapOf("node" to node, "done" to true)
    }
    node["Balance"] = (((node["Balance"] as Any?)).toInt()) + (2 * dir - 1)
    if (toDouble(node["Balance"]) == 0) {
        return mutableMapOf("node" to node, "done" to true)
    }
    if (toDouble(node["Balance"]) == 1 || toDouble(node["Balance"]) == (-1)) {
        return mutableMapOf("node" to node, "done" to false)
    }
    return mutableMapOf("node" to (insertBalance(node, dir)), "done" to true)
}

/**
 * Auto-generated from Mochi
 * @param tree Any
 * @param data Int
 * @return Any
 */
fun Insert(tree: Any, data: Int): Any {
    val r = insertR(tree, data)
    return r["node"]
}

/**
 * Auto-generated from Mochi
 * @param root MutableMap<String, Any>
 * @param dir Int
 * @return MutableMap<String, Any>
 */
fun removeBalance(root: MutableMap<String, Any>, dir: Int): MutableMap<String, Any> {
    var n = getLink(root, opp(dir)) as MutableMap<String, Any>
    var bal = 2 * dir - 1
    if (toDouble(n["Balance"]) == (-bal)) {
        root["Balance"] = 0
        n["Balance"] = 0
        return mutableMapOf("node" to (single(root, dir)), "done" to false)
    }
    if (toDouble(n["Balance"]) == bal) {
        adjustBalance(root, opp(dir), (-bal))
        return mutableMapOf("node" to (double(root, dir)), "done" to false)
    }
    root["Balance"] = -bal
    n["Balance"] = bal
    return mutableMapOf("node" to (single(root, dir)), "done" to true)
}

/**
 * Auto-generated from Mochi
 * @param root Any
 * @param data Int
 * @return MutableMap<String, Any>
 */
fun removeR(root: Any, data: Int): MutableMap<String, Any> {
    if (toDouble(root) == toDouble(null)) {
        return mutableMapOf("node" to null, "done" to false)
    }
    var node = root as MutableMap<String, Any>
    if ((((node["Data"] as Any?)).toInt()) == data) {
        if (toDouble(getLink(node, 0)) == toDouble(null)) {
            return mutableMapOf("node" to (getLink(node, 1)), "done" to false)
        }
        if (toDouble(getLink(node, 1)) == toDouble(null)) {
            return mutableMapOf("node" to (getLink(node, 0)), "done" to false)
        }
        var heir = getLink(node, 0)
        while (toDouble(getLink(heir, 1)) != toDouble(null)) {
            heir = getLink(heir, 1)
        }
        node["Data"] = heir["Data"]
        data = (heir["Data"]!!).toInt()
    }
    var dir = 0
    if ((((node["Data"] as Any?)).toInt()) < data) {
        dir = 1
    }
    var r = removeR(getLink(node, dir), data)
    setLink(node, dir, r["node"])
    if (toBool(r["done"])) {
        return mutableMapOf("node" to node, "done" to true)
    }
    node["Balance"] = (((node["Balance"] as Any?)).toInt()) + 1 - 2 * dir
    if (toDouble(node["Balance"]) == 1 || toDouble(node["Balance"]) == (-1)) {
        return mutableMapOf("node" to node, "done" to true)
    }
    if (toDouble(node["Balance"]) == 0) {
        return mutableMapOf("node" to node, "done" to false)
    }
    return removeBalance(node, dir)
}

/**
 * Auto-generated from Mochi
 * @param tree Any
 * @param data Int
 * @return Any
 */
fun Remove(tree: Any, data: Int): Any {
    val r = removeR(tree, data)
    return r["node"]
}

/**
 * Auto-generated from Mochi
 * @param n Int
 * @return String
 */
fun indentStr(n: Int): String {
    var s = ""
    var i = 0
    while (i < n) {
        s = s + " "
        i = i + 1
    }
    return s
}

/**
 * Auto-generated from Mochi
 * @param node Any
 * @param indent Int
 * @param comma Boolean
 */
fun dumpNode(node: Any, indent: Int, comma: Boolean): Unit {
    val sp = indentStr(indent)
    if (toDouble(node) == toDouble(null)) {
        var line = sp + "null"
        if (comma) {
            line = line + ","
        }
        println(line)
    }
    else {
        println(sp + "{")
        println(indentStr(indent + 3) + "\"Data\": " + node["Data"].toString() + ",")
        println(indentStr(indent + 3) + "\"Balance\": " + node["Balance"].toString() + ",")
        println(indentStr(indent + 3) + "\"Link\": [")
        dumpNode(getLink(node, 0), indent + 6, true)
        dumpNode(getLink(node, 1), indent + 6, false)
        println(indentStr(indent + 3) + "]")
        var end = sp + "}"
        if (comma) {
            end = end + ","
        }
        println(end)
    }
}

/**
 * Auto-generated from Mochi
 * @param node Any
 * @param indent Int
 */
fun dump(node: Any, indent: Int): Unit {
    dumpNode(node, indent, false)
}

/**
 * Auto-generated from Mochi
 */
fun main(): Unit {
    var tree = null
    println("Empty tree:")
    dump(tree, 0)
    println("")
    println("Insert test:")
    tree = Insert(tree, 3)
    tree = Insert(tree, 1)
    tree = Insert(tree, 4)
    tree = Insert(tree, 1)
    tree = Insert(tree, 5)
    dump(tree, 0)
    println("")
    println("Remove test:")
    tree = Remove(tree, 3)
    tree = Remove(tree, 1)
    var t = tree as MutableMap<String, Any>
    t["Balance"] = 0
    tree = t
    dump(tree, 0)
}

