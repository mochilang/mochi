// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun toDouble(v: Any?): Double = when (v) {
    is Double -> v
    is Int -> v.toDouble()
    is String -> v.toDouble()
    else -> 0.0
}
// Code generated from algebraic-data-types.mochi

var tr: Any = null

var i = 1

/**
 * Auto-generated from Mochi
 * @param cl String
 * @param le Any
 * @param aa Int
 * @param ri Any
 * @return MutableMap<String, Any>
 */
fun node(cl: String, le: Any, aa: Int, ri: Any): MutableMap<String, Any> {
    return mutableMapOf("cl" to cl, "le" to le, "aa" to aa, "ri" to ri)
}

/**
 * Auto-generated from Mochi
 * @param t Any
 * @return String
 */
fun treeString(t: Any): String {
    if (toDouble(t) == toDouble(null)) {
        return "E"
    }
    val m = t as MutableMap<String, Any>
    return "T(" + toDouble(m["cl"]) + ", " + treeString(m["le"]) + ", " + m["aa"].toString() + ", " + treeString(m["ri"]) + ")"
}

/**
 * Auto-generated from Mochi
 * @param t Any
 * @return Any
 */
fun balance(t: Any): Any {
    if (toDouble(t) == toDouble(null)) {
        return t
    }
    val m = t as MutableMap<String, Any>
    if (toDouble(m["cl"]) != "B") {
        return t
    }
    val le = m["le"]
    val ri = m["ri"]
    if (toDouble(le) != toDouble(null)) {
        val leMap = le as MutableMap<String, Any>
        if (toDouble(leMap["cl"]) == "R") {
            val lele = leMap["le"]
            if (toDouble(lele) != toDouble(null)) {
                val leleMap = lele as MutableMap<String, Any>
                if (toDouble(leleMap["cl"]) == "R") {
                    return node("R", node("B", leleMap["le"], leleMap["aa"], leleMap["ri"]), leMap["aa"], node("B", leMap["ri"], m["aa"], ri))
                }
            }
            val leri = leMap["ri"]
            if (toDouble(leri) != toDouble(null)) {
                val leriMap = leri as MutableMap<String, Any>
                if (toDouble(leriMap["cl"]) == "R") {
                    return node("R", node("B", leMap["le"], leMap["aa"], leriMap["le"]), leriMap["aa"], node("B", leriMap["ri"], m["aa"], ri))
                }
            }
        }
    }
    if (toDouble(ri) != toDouble(null)) {
        val riMap = ri as MutableMap<String, Any>
        if (toDouble(riMap["cl"]) == "R") {
            val rile = riMap["le"]
            if (toDouble(rile) != toDouble(null)) {
                val rileMap = rile as MutableMap<String, Any>
                if (toDouble(rileMap["cl"]) == "R") {
                    return node("R", node("B", m["le"], m["aa"], rileMap["le"]), rileMap["aa"], node("B", rileMap["ri"], riMap["aa"], riMap["ri"]))
                }
            }
            val riri = riMap["ri"]
            if (toDouble(riri) != toDouble(null)) {
                val ririMap = riri as MutableMap<String, Any>
                if (toDouble(ririMap["cl"]) == "R") {
                    return node("R", node("B", m["le"], m["aa"], riMap["le"]), riMap["aa"], node("B", ririMap["le"], ririMap["aa"], ririMap["ri"]))
                }
            }
        }
    }
    return t
}

/**
 * Auto-generated from Mochi
 * @param tr Any
 * @param x Int
 * @return Any
 */
fun ins(tr: Any, x: Int): Any {
    if (toDouble(tr) == toDouble(null)) {
        return node("R", null, x, null)
    }
    if (x < toDouble(tr["aa"])) {
        return balance(node(tr["cl"], ins(tr["le"], x), tr["aa"], tr["ri"]))
    }
    if (x > toDouble(tr["aa"])) {
        return balance(node(tr["cl"], tr["le"], tr["aa"], ins(tr["ri"], x)))
    }
    return tr
}

/**
 * Auto-generated from Mochi
 * @param tr Any
 * @param x Int
 * @return Any
 */
fun insert(tr: Any, x: Int): Any {
    val t = ins(tr, x)
    if (toDouble(t) == toDouble(null)) {
        return null
    }
    val m = t as MutableMap<String, Any>
    return node("B", m["le"], m["aa"], m["ri"])
}

fun main() {
    while (i <= 16) {
        tr = insert(tr, i)
        i = i + 1
    }
    println(treeString(tr))
}
