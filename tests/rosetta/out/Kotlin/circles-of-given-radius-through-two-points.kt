// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun toDouble(v: Any?): Double = when (v) {
    is Double -> v
    is Int -> v.toDouble()
    is String -> v.toDouble()
    else -> 0.0
}
// Code generated from circles-of-given-radius-through-two-points.mochi

data class Point(var x: Double, var y: Double)

val Two = "Two circles."

val R0 = "R==0.0 does not describe circles."

val Co = "Coincident points describe an infinite number of circles."

val CoR0 = "Coincident points with r==0.0 describe a degenerate circle."

val Diam = "Points form a diameter and describe only a single circle."

val Far = "Points too far apart to form circles."

var td = mutableListOf(mutableListOf(Point(x = 0.1234, y = 0.9876), Point(x = 0.8765, y = 0.2345), 2.0), mutableListOf(Point(x = 0.0, y = 2.0), Point(x = 0.0, y = 0.0), 1.0), mutableListOf(Point(x = 0.1234, y = 0.9876), Point(x = 0.1234, y = 0.9876), 2.0), mutableListOf(Point(x = 0.1234, y = 0.9876), Point(x = 0.8765, y = 0.2345), 0.5), mutableListOf(Point(x = 0.1234, y = 0.9876), Point(x = 0.1234, y = 0.9876), 0.0))

/**
 * Auto-generated from Mochi
 * @param x Double
 * @return Double
 */
fun sqrtApprox(x: Double): Double {
    var g = x
    var i = 0
    while (i < 40) {
        g = (g + x / g) / 2.0
        i = i + 1
    }
    return g
}

/**
 * Auto-generated from Mochi
 * @param x Double
 * @param y Double
 * @return Double
 */
fun hypot(x: Double, y: Double): Double {
    return sqrtApprox(x * x + y * y)
}

/**
 * Auto-generated from Mochi
 * @param p1 Point
 * @param p2 Point
 * @param r Double
 * @return MutableList<Any>
 */
fun circles(p1: Point, p2: Point, r: Double): MutableList<Any> {
    if (p1.x == p2.x && p1.y == p2.y) {
        if (r == 0.0) {
            return mutableListOf(p1, p1, "Coincident points with r==0.0 describe a degenerate circle.")
        }
        return mutableListOf(p1, p2, "Coincident points describe an infinite number of circles.")
    }
    if (r == 0.0) {
        return mutableListOf(p1, p2, "R==0.0 does not describe circles.")
    }
    val dx = p2.x - p1.x
    val dy = p2.y - p1.y
    val q = hypot(dx, dy)
    if (q > 2.0 * r) {
        return mutableListOf(p1, p2, "Points too far apart to form circles.")
    }
    val m = Point(x = (p1.x + p2.x) / 2.0, y = (p1.y + p2.y) / 2.0)
    if (q == 2.0 * r) {
        return mutableListOf(m, m, "Points form a diameter and describe only a single circle.")
    }
    val d = sqrtApprox(r * r - q * q / 4.0)
    val ox = d * dx / q
    val oy = d * dy / q
    return mutableListOf(Point(x = m.x - oy, y = m.y + ox), Point(x = m.x + oy, y = m.y - ox), "Two circles.")
}

fun main() {
    for (tc in td) {
        val p1 = tc[0]
        val p2 = tc[1]
        val r = tc[2]
        println("p1:  {" + (p1 as MutableMap<*, *>)["x"].toString() + " " + (p1 as MutableMap<*, *>)["y"].toString() + "}")
        println("p2:  {" + (p2 as MutableMap<*, *>)["x"].toString() + " " + (p2 as MutableMap<*, *>)["y"].toString() + "}")
        println("r:  " + r.toString())
        val res = circles(p1, p2, r)
        val c1 = res[0]
        val c2 = res[1]
        val caseStr = res[2]
        println("   " + toDouble(caseStr))
        if (toDouble(caseStr) == "Points form a diameter and describe only a single circle." || toDouble(caseStr) == "Coincident points with r==0.0 describe a degenerate circle.") {
            println("   Center:  {" + (c1 as MutableMap<*, *>)["x"].toString() + " " + (c1 as MutableMap<*, *>)["y"].toString() + "}")
        }
        else {
            if (toDouble(caseStr) == "Two circles.") {
                println("   Center 1:  {" + (c1 as MutableMap<*, *>)["x"].toString() + " " + (c1 as MutableMap<*, *>)["y"].toString() + "}")
                println("   Center 2:  {" + (c2 as MutableMap<*, *>)["x"].toString() + " " + (c2 as MutableMap<*, *>)["y"].toString() + "}")
            }
        }
        println("")
    }
}
