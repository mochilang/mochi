// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fun <T> append(list: MutableList<T>, item: T): MutableList<T> {
    val res = list.toMutableList()
    res.add(item)
    return res
}

fun toDouble(v: Any?): Double = when (v) {
    is Double -> v
    is Int -> v.toDouble()
    is String -> v.toDouble()
    else -> 0.0
}
// Code generated from casting-out-nines.mochi

val testCases = mutableListOf(mutableMapOf("base" to 10, "begin" to "1", "end" to "100", "kaprekar" to (mutableListOf("1", "9", "45", "55", "99"))), mutableMapOf("base" to 17, "begin" to "10", "end" to "gg", "kaprekar" to (mutableListOf("3d", "d4", "gg"))))

var idx = 0

/**
 * Auto-generated from Mochi
 * @param s String
 * @param base Int
 * @return Int
 */
fun parseIntBase(s: String, base: Int): Int {
    val digits = "0123456789abcdefghijklmnopqrstuvwxyz"
    var n = 0
    var i = 0
    while (i < s.length) {
        var j = 0
        var v = 0
        while (j < digits.length) {
            if (digits.substring(j, j + 1) == s.substring(i, i + 1)) {
                v = j
                break
            }
            j = j + 1
        }
        n = n * base + v
        i = i + 1
    }
    return n
}

/**
 * Auto-generated from Mochi
 * @param n Int
 * @param base Int
 * @return String
 */
fun intToBase(n: Int, base: Int): String {
    val digits = "0123456789abcdefghijklmnopqrstuvwxyz"
    if (n == 0) {
        return "0"
    }
    var out = ""
    var v = n
    while (v > 0) {
        val d = v % base
        out = digits.substring(d, d + 1) + out
        v = (v).toDouble() / (base).toDouble()
    }
    return out
}

/**
 * Auto-generated from Mochi
 * @param base Int
 * @param begin String
 * @param end String
 * @return MutableList<String>
 */
fun subset(base: Int, begin: String, end: String): MutableList<String> {
    var b = parseIntBase(begin, base)
    var e = parseIntBase(end, base)
    var out: MutableList<String> = mutableListOf<String>()
    var k = b
    while (k <= e) {
        val ks = intToBase(k, base)
        val mod = base - 1
        val r1 = parseIntBase(ks, base) % mod
        val r2 = (parseIntBase(ks, base) * parseIntBase(ks, base)) % mod
        if (r1 == r2) {
            out = append(out, ks)
        }
        k = k + 1
    }
    return out
}

fun main() {
    while (idx < testCases.size) {
        val tc = testCases[idx]
        println("\nTest case base = " + tc["base"].toString() + ", begin = " + toDouble(tc["begin"]) + ", end = " + toDouble(tc["end"]) + ":")
        val s = subset(tc["base"], tc["begin"], tc["end"])
        println("Subset:  " + s.toString())
        println("Kaprekar:" + tc["kaprekar"].toString())
        var sx = 0
        var valid = true
        var i = 0
        while (i < tc["kaprekar"].size) {
            val k = (tc["kaprekar"] as Any?)[i]
            var found = false
            while (sx < s.size) {
                if (s[sx] == toDouble(k)) {
                    found = true
                    sx = sx + 1
                    break
                }
                sx = sx + 1
            }
            if (!found) {
                println("Fail:" + toDouble(k) + " not in subset")
                valid = false
                break
            }
            i = i + 1
        }
        if (valid) {
            println("Valid subset.")
        }
        idx = idx + 1
    }
}
