// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:20:42Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:20:41Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static int index_of_string(char *s, char *sub) {
  char *pos = strstr(s, sub);
  if (!pos)
    return -1;
  return pos - s;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
double absf(double x) {
  if (x < 0.0) {
    return (-x);
  }
  return x;
}

double floorf(double x) { return (double)(((int)(x))); }

int indexOf(char *s, char *ch) {
  int i = 0;
  while (i < strlen(s)) {
    if (slice_string(s, i, i + 1) == ch) {
      return i;
    }
    i = i + 1;
  }
  return (-1);
}

char *fmtF(double x) {
  double y = floorf(x * 10000.0 + 0.5) / 10000.0;
  char *tmp1 = _str(y);
  char *s = tmp1;
  int dot = index_of_string(s, ".");
  if (dot == 0 - 1) {
    char *tmp2 = concat_string(s, ".0000");
    s = tmp2;
  } else {
    int decs = strlen(s) - dot - 1;
    if (decs > 4) {
      s = slice_string(s, 0, dot + 5);
    } else {
      while (decs < 4) {
        char *tmp3 = concat_string(s, "0");
        s = tmp3;
        decs = decs + 1;
      }
    }
  }
  return s;
}

char *padInt(int n, int width) {
  char *tmp4 = _str(n);
  char *s = tmp4;
  while (strlen(s) < width) {
    char *tmp5 = concat_string(" ", s);
    s = tmp5;
  }
  return s;
}

char *padFloat(double x, int width) {
  char *s = fmtF(x);
  while (strlen(s) < width) {
    char *tmp6 = concat_string(" ", s);
    s = tmp6;
  }
  return s;
}

double avgLen(int n) {
  int tests = 10000;
  int sum = 0;
  int seed = 1;
  int t = 0;
  while (t < tests) {
    list_int visited = {0, NULL};
    int i = 0;
    while (i < n) {
      int tmp7_data[1];
      list_int tmp7 = {1, tmp7_data};
      tmp7.data[0] = 0;
      list_int tmp8 = concat_list_int(visited, tmp7);
      visited = tmp8;
      i = i + 1;
    }
    int x = 0;
    while ((!visited.data[x])) {
      visited.data[x] = 1;
      sum = sum + 1;
      seed = (seed * 1664525 + 1013904223) % 2147483647;
      x = seed % n;
    }
    t = t + 1;
  }
  return ((double)(sum)) / tests;
}

double ana(int n) {
  double nn = (double)(n);
  double term = 1.0;
  double sum = 1.0;
  double i = nn - 1.0;
  while (i >= 1.0) {
    term = term * (i / nn);
    sum = sum + term;
    i = i - 1.0;
  }
  return sum;
}

int mochi_main() {
  int nmax = 20;
  printf(" N    average    analytical    (error)\n");
  printf("===  =========  ============  =========\n");
  int n = 1;
  while (n <= nmax) {
    double a = avgLen(n);
    double b = ana(n);
    double err = absf(a - b) / b * 100.0;
    char *line = padInt(n, 3) + "  " + padFloat(a, 9) + "  " + padFloat(b, 12) +
                 "  (" + padFloat(err, 6) + "%)";
    printf("%s\n", line);
    n = n + 1;
  }
}

int _mochi_main() {
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
