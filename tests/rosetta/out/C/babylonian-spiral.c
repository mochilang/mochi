// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:49Z
// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:49Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  char *key;
  int value;
} pair_string_int;
static pair_string_int pair_string_int_new(char *key, int value) {
  pair_string_int p;
  p.key = key;
  p.value = value;
  return p;
}
typedef struct {
  int len;
  int cap;
  pair_string_int *data;
} map_string_int;
static map_string_int map_string_int_create(int cap) {
  map_string_int m;
  m.len = 0;
  m.cap = cap;
  m.data = cap ? calloc(cap, sizeof(pair_string_int)) : NULL;
  if (cap && !m.data) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return m;
}
static void map_string_int_put(map_string_int *m, char *k, int v) {
  for (int i = 0; i < m->len; i++)
    if (strcmp(m->data[i].key, k) == 0) {
      m->data[i].value = v;
      return;
    }
  if (m->len >= m->cap) {
    m->cap = m->cap ? m->cap * 2 : 4;
    m->data =
        (pair_string_int *)realloc(m->data, sizeof(pair_string_int) * m->cap);
  }
  m->data[m->len++] = pair_string_int_new(k, v);
}
static int map_string_int_get(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return m.data[i].value;
  return 0;
}
static int map_string_int_contains(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return 1;
  return 0;
}
static int cmp_map_string_int(map_string_int a, map_string_int b) {
  int aa = map_string_int_get(a, "a");
  int ba = map_string_int_get(b, "a");
  if (aa != ba)
    return aa > ba ? 1 : -1;
  int ab = map_string_int_get(a, "b");
  int bb = map_string_int_get(b, "b");
  if (ab != bb)
    return ab > bb ? 1 : -1;
  return 0;
}
static list_list_int concat_list_list_int(list_list_int a, list_list_int b) {
  list_list_int r = list_list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static list_int slice_list_int(list_int v, int start, int end) {
  if (start < 0)
    start += v.len;
  if (end < 0)
    end += v.len;
  if (start < 0)
    start = 0;
  if (end > v.len)
    end = v.len;
  if (start > end)
    start = end;
  list_int r = list_int_create(end - start);
  for (int i = 0; i < r.len; i++)
    r.data[i] = v.data[start + i];
  return r;
}
typedef struct {
  int s;
  int a;
  int b;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int s;
  int a;
  int b;
} tmp_item1_t;
typedef struct {
  int len;
  tmp_item1_t *data;
} tmp_item1_list_t;
tmp_item1_list_t create_tmp_item1_list(int len) {
  tmp_item1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  list_int d;
  int heap;
  int n;
} tmp_item2_t;
typedef struct {
  int len;
  tmp_item2_t *data;
} tmp_item2_list_t;
tmp_item2_list_t create_tmp_item2_list(int len) {
  tmp_item2_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item2_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int push(int h, map_string_int it) {
  h = 0;
  int i = h.len - 1;
  while (i > 0 && h.data[i - 1].data["s"] > h.data[i].data["s"]) {
    map_string_int tmp = h.data[i - 1];
    h.data[i - 1] = h.data[i];
    h.data[i] = tmp;
    i = i - 1;
  }
  return h;
}

int step(int h, int nv, list_int dir) {
  while (h.len == 0 || nv * nv <= h.data[0].data["s"]) {
    h = push(h, (tmp_item_t){.s = nv * nv, .a = nv, .b = 0});
    nv = nv + 1;
  }
  int s = h.data[0].data["s"];
  list_list_int tmp1 = {0, NULL};
  list_list_int v = tmp1;
  while (h.len > 0 && h.data[0].data["s"] == s) {
    map_string_int it = h.data[0];
    list_int tmp2 = slice_list_int(h, 1, h.len);
    h = tmp2;
    list_int tmp3 = list_int_create(2);
    tmp3.data[0] = map_string_int_get(it, "a");
    tmp3.data[1] = map_string_int_get(it, "b");
    list_list_int tmp4 = list_list_int_create(1);
    tmp4.data[0] = tmp3;
    list_list_int tmp5 = concat_list_list_int(v, tmp4);
    v = tmp5;
    if (map_string_int_get(it, "a") > map_string_int_get(it, "b")) {
      h = push(h, (tmp_item1_t){.s = map_string_int_get(it, "a") *
                                         map_string_int_get(it, "a") +
                                     (map_string_int_get(it, "b") + 1) *
                                         (map_string_int_get(it, "b") + 1),
                                .a = map_string_int_get(it, "a"),
                                .b = map_string_int_get(it, "b") + 1});
    }
  }
  list_list_int tmp6 = {0, NULL};
  list_list_int list = tmp6;
  for (int tmp7 = 0; tmp7 < v.len; tmp7++) {
    list_int p = v.data[tmp7];
    list_list_int tmp8 = list_list_int_create(1);
    tmp8.data[0] = p;
    list_list_int tmp9 = concat_list_list_int(list, tmp8);
    list = tmp9;
  }
  list_list_int temp = list;
  for (int tmp10 = 0; tmp10 < temp.len; tmp10++) {
    list_int p = temp.data[tmp10];
    if (p.data[0] != p.data[1]) {
      list_int tmp11 = list_int_create(2);
      tmp11.data[0] = p.data[1];
      tmp11.data[1] = p.data[0];
      list_list_int tmp12 = list_list_int_create(1);
      tmp12.data[0] = tmp11;
      list_list_int tmp13 = concat_list_list_int(list, tmp12);
      list = tmp13;
    }
  }
  temp = list;
  for (int tmp14 = 0; tmp14 < temp.len; tmp14++) {
    list_int p = temp.data[tmp14];
    if (p.data[1] != 0) {
      list_int tmp15 = list_int_create(2);
      tmp15.data[0] = p.data[0];
      tmp15.data[1] = (-p.data[1]);
      list_list_int tmp16 = list_list_int_create(1);
      tmp16.data[0] = tmp15;
      list_list_int tmp17 = concat_list_list_int(list, tmp16);
      list = tmp17;
    }
  }
  temp = list;
  for (int tmp18 = 0; tmp18 < temp.len; tmp18++) {
    list_int p = temp.data[tmp18];
    if (p.data[0] != 0) {
      list_int tmp19 = list_int_create(2);
      tmp19.data[0] = (-p.data[0]);
      tmp19.data[1] = p.data[1];
      list_list_int tmp20 = list_list_int_create(1);
      tmp20.data[0] = tmp19;
      list_list_int tmp21 = concat_list_list_int(list, tmp20);
      list = tmp21;
    }
  }
  int bestDot = (-999999999);
  list_int best = dir;
  for (int tmp22 = 0; tmp22 < list.len; tmp22++) {
    list_int p = list.data[tmp22];
    int cross = p.data[0] * dir.data[1] - p.data[1] * dir.data[0];
    if (cross >= 0) {
      int dot = p.data[0] * dir.data[0] + p.data[1] * dir.data[1];
      if (dot > bestDot) {
        bestDot = dot;
        best = p;
      }
    }
  }
  return (tmp_item2_t){.d = best, .heap = h, .n = nv};
}

list_list_int positions(int n) {
  list_list_int tmp23 = {0, NULL};
  list_list_int pos = tmp23;
  int x = 0;
  int y = 0;
  list_int dir = list_int_create(2);
  dir.data[0] = 0;
  dir.data[1] = 1;
  list_int tmp24 = list_int_create(0);
  int heap = tmp24;
  int nv = 1;
  int i = 0;
  while (i < n) {
    list_int tmp25 = list_int_create(2);
    tmp25.data[0] = x;
    tmp25.data[1] = y;
    list_list_int tmp26 = list_list_int_create(1);
    tmp26.data[0] = tmp25;
    list_list_int tmp27 = concat_list_list_int(pos, tmp26);
    pos = tmp27;
    list_int tmp28 = list_int_create(2);
    tmp28.data[0] = 0;
    tmp28.data[1] = 1;
    int st = step(heap, nv, tmp28);
    dir = (list_int)(st.data["d"]);
    heap = (int)(st.data["heap"]);
    nv = (int)(st.data["n"]);
    x = x + dir.data[0];
    y = y + dir.data[1];
    i = i + 1;
  }
  return pos;
}

const char *pad(char *s, int w) {
  const char *r = s;
  while (strlen(r) < w) {
    char *tmp29 = concat_string(r, " ");
    r = tmp29;
  }
  return r;
}

int main() {
  list_list_int pts = positions(40);
  printf("The first 40 Babylonian spiral points are:\n");
  const char *line = "";
  int i = 0;
  while (i < pts.len) {
    list_int p = pts.data[i];
    char *tmp30 = _str(p.data[0]);
    char *tmp31 = concat_string("(", tmp30);
    char *tmp32 = concat_string(tmp31, ", ");
    char *tmp33 = _str(p.data[1]);
    char *tmp34 = concat_string(tmp32, tmp33);
    char *tmp35 = concat_string(tmp34, ")");
    const char *s = pad(tmp35, 10);
    char *tmp36 = concat_string(line, s);
    line = tmp36;
    if ((i + 1) % 10 == 0) {
      printf("%s\n", line);
      line = "";
    }
    i = i + 1;
  }
}

int main() {
  main();
  return 0;
}
