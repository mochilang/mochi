// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:53Z
// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:53Z
#include <stdio.h>
#include <stdlib.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct Pixel Pixel;

static int b3Seg = 30;

typedef struct {
  int cols;
  int rows;
  int data;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct Pixel {
  int r;
  int g;
  int b;
} Pixel;
typedef struct {
  int len;
  pixel_t *data;
} pixel_list_t;
pixel_list_t create_pixel_list(int len) {
  pixel_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(pixel_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

pixel_t pixelFromRgb(int rgb) {
  int r = (int)(((((double)rgb) / ((double)65536)) % 256));
  int g = (int)(((((double)rgb) / ((double)256)) % 256));
  int b = (int)((rgb % 256));
  return (Pixel){.r = r, .g = g, .b = b};
}

int newBitmap(int cols, int rows) {
  list_int tmp1 = list_int_create(0);
  int d = tmp1;
  int y = 0;
  while (y < rows) {
    list_int tmp2 = list_int_create(0);
    pixel_list_t row = tmp2;
    int x = 0;
    while (x < cols) {
      row = 0;
      x = x + 1;
    }
    d = 0;
    y = y + 1;
  }
  return (tmp_item_t){.cols = cols, .rows = rows, .data = d};
}

int setPx(map_string_int b, int x, int y, Pixel *p) {
  int cols = (int)(b.data["cols"]);
  int rows = (int)(b.data["rows"]);
  if (x >= 0 && x < cols && y >= 0 && y < rows) {
    b.data["data"].data[y].data[x] = p;
  }
}

int fill(map_string_int b, Pixel *p) {
  int cols = (int)(b.data["cols"]);
  int rows = (int)(b.data["rows"]);
  int y = 0;
  while (y < rows) {
    int x = 0;
    while (x < cols) {
      b.data["data"].data[y].data[x] = p;
      x = x + 1;
    }
    y = y + 1;
  }
}

int fillRgb(map_string_int b, int rgb) { fill(b, &pixelFromRgb(rgb)); }

int line(map_string_int b, int x0, int y0, int x1, int y1, Pixel *p) {
  int dx = x1 - x0;
  if (dx < 0) {
    dx = (-dx);
  }
  int dy = y1 - y0;
  if (dy < 0) {
    dy = (-dy);
  }
  int sx = (-1);
  if (x0 < x1) {
    sx = 1;
  }
  int sy = (-1);
  if (y0 < y1) {
    sy = 1;
  }
  int err = dx - dy;
  while (1) {
    setPx(b, x0, y0, &p);
    if (x0 == x1 && y0 == y1) {
      break;
    }
    int e2 = 2 * err;
    if (e2 > (0 - dy)) {
      err = err - dy;
      x0 = x0 + sx;
    }
    if (e2 < dx) {
      err = err + dx;
      y0 = y0 + sy;
    }
  }
}

int bezier3(map_string_int b, int x1, int y1, int x2, int y2, int x3, int y3,
            int x4, int y4, Pixel *p) {
  list_int px = list_int_create(0);
  list_int py = list_int_create(0);
  int i = 0;
  while (i <= b3Seg) {
    px = 0;
    py = 0;
    i = i + 1;
  }
  double fx1 = (double)(x1);
  double fy1 = (double)(y1);
  double fx2 = (double)(x2);
  double fy2 = (double)(y2);
  double fx3 = (double)(x3);
  double fy3 = (double)(y3);
  double fx4 = (double)(x4);
  double fy4 = (double)(y4);
  i = 0;
  while (i <= b3Seg) {
    double d = ((double)(i)) / ((double)(b3Seg));
    double a = 1.0 - d;
    double bcoef = a * a;
    double ccoef = d * d;
    double a2 = a * bcoef;
    double b2 = 3.0 * bcoef * d;
    double c2 = 3.0 * a * ccoef;
    double d2 = ccoef * d;
    px.data[i] = (int)((a2 * fx1 + b2 * fx2 + c2 * fx3 + d2 * fx4));
    py.data[i] = (int)((a2 * fy1 + b2 * fy2 + c2 * fy3 + d2 * fy4));
    i = i + 1;
  }
  int x0 = px.data[0];
  int y0 = py.data[0];
  i = 1;
  while (i <= b3Seg) {
    int x = px.data[i];
    int y = py.data[i];
    line(b, x0, y0, x, y, &p);
    x0 = x;
    y0 = y;
    i = i + 1;
  }
}

int main() {
  int b = newBitmap(400, 300);
  fillRgb(b, 16773055);
  bezier3(b, 20, 200, 700, 50, (-300), 50, 380, 150, &pixelFromRgb(4165615));
  return 0;
}
