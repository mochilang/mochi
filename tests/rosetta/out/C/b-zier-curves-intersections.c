// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:37:19Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static list_int slice_list_int(list_int v, int start, int end) {
  if (start < 0)
    start += v.len;
  if (end < 0)
    end += v.len;
  if (start < 0)
    start = 0;
  if (end > v.len)
    end = v.len;
  if (start > end)
    start = end;
  list_int r = list_int_create(end - start);
  for (int i = 0; i < r.len; i++)
    r.data[i] = v.data[start + i];
  return r;
}
typedef struct Point Point;
typedef struct QuadSpline QuadSpline;
typedef struct QuadCurve QuadCurve;

typedef struct {
  int exclude;
  int accept;
  point_t intersect;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  double x;
  double y;
  double x;
  double y;
} point_t;

typedef struct {
  quad_curve_t p;
  quad_curve_t q;
} workload_t;
typedef struct {
  int len;
  workload_t *data;
} workload_list_t;
workload_list_t create_workload_list(int len) {
  workload_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(workload_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  quad_spline_t x;
  quad_spline_t y;
  quad_spline_t x;
  quad_spline_t y;
} quad_curve_t;

typedef struct {
  double c0;
  double c1;
  double c2;
  double c0;
  double c1;
  double c2;
} quad_spline_t;

typedef struct {
  int p;
  int q;
} tmp_item1_t;
typedef struct {
  int len;
  tmp_item1_t *data;
} tmp_item1_list_t;
tmp_item1_list_t create_tmp_item1_list(int len) {
  tmp_item1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int p;
  int q;
} tmp_item2_t;
typedef struct {
  int len;
  tmp_item2_t *data;
} tmp_item2_list_t;
tmp_item2_list_t create_tmp_item2_list(int len) {
  tmp_item2_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item2_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int p;
  int q;
} tmp_item3_t;
typedef struct {
  int len;
  tmp_item3_t *data;
} tmp_item3_list_t;
tmp_item3_list_t create_tmp_item3_list(int len) {
  tmp_item3_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item3_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct Point {
  double x;
  double y;
} Point;
typedef struct {
  int len;
  point_t *data;
} point_list_t;
point_list_t create_point_list(int len) {
  point_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(point_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct QuadSpline {
  double c0;
  double c1;
  double c2;
} QuadSpline;
typedef struct {
  int len;
  quad_spline_t *data;
} quad_spline_list_t;
quad_spline_list_t create_quad_spline_list(int len) {
  quad_spline_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(quad_spline_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct QuadCurve {
  QuadSpline x;
  QuadSpline y;
} QuadCurve;
typedef struct {
  int len;
  quad_curve_t *data;
} quad_curve_list_t;
quad_curve_list_t create_quad_curve_list(int len) {
  quad_curve_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(quad_curve_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

double absf(double x) {
  if (x < 0.0) {
    return (-x);
  }
  return x;
}

double maxf(double a, double b) {
  if (a > b) {
    return a;
  }
  return b;
}

double minf(double a, double b) {
  if (a < b) {
    return a;
  }
  return b;
}

double max3(double a, double b, double c) {
  double m = a;
  if (b > m) {
    m = b;
  }
  if (c > m) {
    m = c;
  }
  return m;
}

double min3(double a, double b, double c) {
  double m = a;
  if (b < m) {
    m = b;
  }
  if (c < m) {
    m = c;
  }
  return m;
}

quad_spline_list_t subdivideQuadSpline(QuadSpline *q, double t) {
  double s = 1.0 - t;
  quad_spline_t u = (QuadSpline){.c0 = q->c0, .c1 = 0.0, .c2 = 0.0};
  quad_spline_t v = (QuadSpline){.c0 = 0.0, .c1 = 0.0, .c2 = q->c2};
  u.c1 = s * q->c0 + t * q->c1;
  v.c1 = s * q->c1 + t * q->c2;
  u.c2 = s * u.c1 + t * v.c1;
  v.c0 = u.c2;
  list_int tmp1 = list_int_create(2);
  tmp1.data[0] = u;
  tmp1.data[1] = v;
  return tmp1;
}

quad_curve_list_t subdivideQuadCurve(QuadCurve *q, double t) {
  quad_spline_list_t xs = subdivideQuadSpline(&q->x, t);
  quad_spline_list_t ys = subdivideQuadSpline(&q->y, t);
  quad_curve_t u = (QuadCurve){.x = xs.data[0], .y = ys.data[0]};
  quad_curve_t v = (QuadCurve){.x = xs.data[1], .y = ys.data[1]};
  list_int tmp2 = list_int_create(2);
  tmp2.data[0] = u;
  tmp2.data[1] = v;
  return tmp2;
}

int rectsOverlap(double xa0, double ya0, double xa1, double ya1, double xb0,
                 double yb0, double xb1, double yb1) {
  return xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1;
}

int testIntersect(QuadCurve *p, QuadCurve *q, double tol) {
  double pxmin = min3(p->x.c0, p->x.c1, p->x.c2);
  double pymin = min3(p->y.c0, p->y.c1, p->y.c2);
  double pxmax = max3(p->x.c0, p->x.c1, p->x.c2);
  double pymax = max3(p->y.c0, p->y.c1, p->y.c2);
  double qxmin = min3(q->x.c0, q->x.c1, q->x.c2);
  double qymin = min3(q->y.c0, q->y.c1, q->y.c2);
  double qxmax = max3(q->x.c0, q->x.c1, q->x.c2);
  double qymax = max3(q->y.c0, q->y.c1, q->y.c2);
  int exclude = 1;
  int accept = 0;
  point_t inter = (Point){.x = 0.0, .y = 0.0};
  if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
    exclude = 0;
    double xmin = maxf(pxmin, qxmin);
    double xmax = minf(pxmax, qxmax);
    if (xmax - xmin <= tol) {
      double ymin = maxf(pymin, qymin);
      double ymax = minf(pymax, qymax);
      if (ymax - ymin <= tol) {
        accept = 1;
        inter.x = 0.5 * (xmin + xmax);
        inter.y = 0.5 * (ymin + ymax);
      }
    }
  }
  return (tmp_item_t){.exclude = exclude, .accept = accept, .intersect = inter};
}

int seemsToBeDuplicate(int pts, Point *xy, double spacing) {
  int i = 0;
  while (i < pts.len) {
    point_t pt = pts.data[i];
    if (absf(pt.x - xy->x) < spacing && absf(pt.y - xy->y) < spacing) {
      return 1;
    }
    i = i + 1;
  }
  return 0;
}

point_list_t findIntersects(QuadCurve *p, QuadCurve *q, double tol,
                            double spacing) {
  list_int tmp3 = list_int_create(0);
  point_list_t inters = tmp3;
  workload_t workload[] = {(workload_t){.p = p, .q = q}};
  int workload_len = sizeof(workload) / sizeof(workload[0]);
  while (workload_len > 0) {
    int idx = workload_len - 1;
    workload_t work = workload[idx];
    list_int tmp4 = slice_list_int(workload, 0, idx);
    workload = tmp4;
    int res = testIntersect(work.p, work.q, tol);
    int excl = res.data["exclude"];
    int acc = res.data["accept"];
    int inter = (Point)(res.data["intersect"]);
    if ((acc)) {
      if ((!seemsToBeDuplicate(inters, inter, spacing))) {
        inters = 0;
      }
    } else if (((!excl))) {
      int ps = subdivideQuadCurve(work.p, 0.5);
      int qs = subdivideQuadCurve(work.q, 0.5);
      int p0 = ps.data[0];
      int p1 = ps.data[1];
      int q0 = qs.data[0];
      int q1 = qs.data[1];
      workload = 0;
      workload = 0;
      workload = 0;
      workload = 0;
    }
  }
  return inters;
}

int main() {
  quad_curve_t p =
      (QuadCurve){.x = (QuadSpline){.c0 = (-1.0), .c1 = 0.0, .c2 = 1.0},
                  .y = (QuadSpline){.c0 = 0.0, .c1 = 10.0, .c2 = 0.0}};
  quad_curve_t q =
      (QuadCurve){.x = (QuadSpline){.c0 = 2.0, .c1 = (-8.0), .c2 = 2.0},
                  .y = (QuadSpline){.c0 = 1.0, .c1 = 2.0, .c2 = 3.0}};
  double tol = 0.0000001;
  double spacing = tol * 10.0;
  point_list_t inters = findIntersects(&p, &q, tol, spacing);
  int i = 0;
  while (i < inters.len) {
    point_t pt = inters.data[i];
    char *tmp5 = _str(pt.x);
    char *tmp6 = concat_string("(", tmp5);
    char *tmp7 = concat_string(tmp6, ", ");
    char *tmp8 = _str(pt.y);
    char *tmp9 = concat_string(tmp7, tmp8);
    char *tmp10 = concat_string(tmp9, ")");
    printf("%s\n", tmp10);
    i = i + 1;
  }
}

int main() {
  main();
  return 0;
}
