// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:09:36Z
// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:09:36Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static list_int slice_list_int(list_int v, int start, int end) {
  if (start < 0)
    start += v.len;
  if (end < 0)
    end += v.len;
  if (start < 0)
    start = 0;
  if (end > v.len)
    end = v.len;
  if (start > end)
    start = end;
  list_int r = list_int_create(end - start);
  for (int i = 0; i < r.len; i++)
    r.data[i] = v.data[start + i];
  return r;
}
typedef struct point_t point_t;
typedef struct quad_spline_t quad_spline_t;
typedef struct quad_curve_t quad_curve_t;

typedef struct {
  int exclude;
  int accept;
  point_t intersect;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  quad_curve_t p;
  quad_curve_t q;
} workload_t;
typedef struct {
  int len;
  workload_t *data;
} workload_list_t;
workload_list_t create_workload_list(int len) {
  workload_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(workload_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int p;
  int q;
} tmp_item1_t;
typedef struct {
  int len;
  tmp_item1_t *data;
} tmp_item1_list_t;
tmp_item1_list_t create_tmp_item1_list(int len) {
  tmp_item1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int p;
  int q;
} tmp_item2_t;
typedef struct {
  int len;
  tmp_item2_t *data;
} tmp_item2_list_t;
tmp_item2_list_t create_tmp_item2_list(int len) {
  tmp_item2_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item2_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int p;
  int q;
} tmp_item3_t;
typedef struct {
  int len;
  tmp_item3_t *data;
} tmp_item3_list_t;
tmp_item3_list_t create_tmp_item3_list(int len) {
  tmp_item3_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item3_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct point_t {
  double x;
  double y;
} point_t;
typedef struct {
  int len;
  point_t *data;
} point_list_t;
point_list_t create_point_list(int len) {
  point_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(point_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct quad_spline_t {
  double c0;
  double c1;
  double c2;
} quad_spline_t;
typedef struct {
  int len;
  quad_spline_t *data;
} quad_spline_list_t;
quad_spline_list_t create_quad_spline_list(int len) {
  quad_spline_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(quad_spline_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct quad_curve_t {
  quad_spline_t x;
  quad_spline_t y;
} quad_curve_t;
typedef struct {
  int len;
  quad_curve_t *data;
} quad_curve_list_t;
quad_curve_list_t create_quad_curve_list(int len) {
  quad_curve_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(quad_curve_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

double absf(double x) {
  if (x < 0.0) {
    return (-x);
  }
  return x;
}

double maxf(double a, double b) {
  if (a > b) {
    return a;
  }
  return b;
}

double minf(double a, double b) {
  if (a < b) {
    return a;
  }
  return b;
}

double max3(double a, double b, double c) {
  __auto_type m = a;
  if (b > m) {
    m = b;
  }
  if (c > m) {
    m = c;
  }
  return m;
}

double min3(double a, double b, double c) {
  __auto_type m = a;
  if (b < m) {
    m = b;
  }
  if (c < m) {
    m = c;
  }
  return m;
}

quad_spline_list_t subdivideQuadSpline(quad_spline_t *q, double t) {
  __auto_type s = 1.0 - t;
  __auto_type u = (quad_spline_t){.c0 = q->c0, .c1 = 0.0, .c2 = 0.0};
  __auto_type v = (quad_spline_t){.c0 = 0.0, .c1 = 0.0, .c2 = q->c2};
  u.c1 = s * q->c0 + t * q->c1;
  v.c1 = s * q->c1 + t * q->c2;
  u.c2 = s * u.c1 + t * v.c1;
  v.c0 = u.c2;
  list_int tmp1 = list_int_create(2);
  tmp1.data[0] = u;
  tmp1.data[1] = v;
  return tmp1;
}

quad_curve_list_t subdivideQuadCurve(quad_curve_t *q, double t) {
  __auto_type xs = subdivideQuadSpline(&q->x, t);
  __auto_type ys = subdivideQuadSpline(&q->y, t);
  __auto_type u = (quad_curve_t){.x = xs.data[0], .y = ys.data[0]};
  __auto_type v = (quad_curve_t){.x = xs.data[1], .y = ys.data[1]};
  list_int tmp2 = list_int_create(2);
  tmp2.data[0] = u;
  tmp2.data[1] = v;
  return tmp2;
}

int rectsOverlap(double xa0, double ya0, double xa1, double ya1, double xb0,
                 double yb0, double xb1, double yb1) {
  return xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1;
}

int testIntersect(quad_curve_t *p, quad_curve_t *q, double tol) {
  __auto_type pxmin = min3(p->x.c0, p->x.c1, p->x.c2);
  __auto_type pymin = min3(p->y.c0, p->y.c1, p->y.c2);
  __auto_type pxmax = max3(p->x.c0, p->x.c1, p->x.c2);
  __auto_type pymax = max3(p->y.c0, p->y.c1, p->y.c2);
  __auto_type qxmin = min3(q->x.c0, q->x.c1, q->x.c2);
  __auto_type qymin = min3(q->y.c0, q->y.c1, q->y.c2);
  __auto_type qxmax = max3(q->x.c0, q->x.c1, q->x.c2);
  __auto_type qymax = max3(q->y.c0, q->y.c1, q->y.c2);
  __auto_type exclude = 1;
  __auto_type accept = 0;
  __auto_type inter = (point_t){.x = 0.0, .y = 0.0};
  if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
    exclude = 0;
    __auto_type xmin = maxf(pxmin, qxmin);
    __auto_type xmax = minf(pxmax, qxmax);
    if (xmax - xmin <= tol) {
      __auto_type ymin = maxf(pymin, qymin);
      __auto_type ymax = minf(pymax, qymax);
      if (ymax - ymin <= tol) {
        accept = 1;
        inter.x = 0.5 * (xmin + xmax);
        inter.y = 0.5 * (ymin + ymax);
      }
    }
  }
  return (tmp_item_t){.exclude = exclude, .accept = accept, .intersect = inter};
}

int seemsToBeDuplicate(int pts, point_t *xy, double spacing) {
  __auto_type i = 0;
  while (i < pts.len) {
    __auto_type pt = pts.data[i];
    if (absf(pt.x - xy->x) < spacing && absf(pt.y - xy->y) < spacing) {
      return 1;
    }
    i = i + 1;
  }
  return 0;
}

point_list_t findIntersects(quad_curve_t *p, quad_curve_t *q, double tol,
                            double spacing) {
  point_list_t inters = {0, NULL};
  workload_t workload[] = {{p, q}};
  int workload_len = sizeof(workload) / sizeof(workload[0]);
  while (workload_len > 0) {
    __auto_type idx = workload_len - 1;
    __auto_type work = workload[idx];
    list_int tmp4 = {workload_len, workload};
    list_int tmp3 = slice_list_int(tmp4, 0, idx);
    workload = tmp3;
    __auto_type res = testIntersect(work.p, work.q, tol);
    __auto_type excl = res.data["exclude"];
    __auto_type acc = res.data["accept"];
    __auto_type inter = (point_t)(res.data["intersect"]);
    if ((acc)) {
      if ((!seemsToBeDuplicate(inters, inter, spacing))) {
        point_list_t tmp5 = create_point_list(inters.len + 1);
        for (int i6 = 0; i6 < inters.len; i6++) {
          tmp5.data[i6] = inters.data[i6];
        }
        tmp5.data[inters.len] = inter;
        tmp5.len = inters.len + 1;
        inters = tmp5;
      }
    } else if (((!excl))) {
      __auto_type ps = subdivideQuadCurve(work.p, 0.5);
      __auto_type qs = subdivideQuadCurve(work.q, 0.5);
      __auto_type p0 = ps.data[0];
      __auto_type p1 = ps.data[1];
      __auto_type q0 = qs.data[0];
      __auto_type q1 = qs.data[1];
      workload_list_t tmp7 = create_workload_list(workload.len + 1);
      for (int i8 = 0; i8 < workload.len; i8++) {
        tmp7.data[i8] = workload.data[i8];
      }
      tmp7.data[workload.len] = (tmp_item_t){.p = p0, .q = q0};
      tmp7.len = workload.len + 1;
      workload = tmp7;
      workload_list_t tmp9 = create_workload_list(workload.len + 1);
      for (int i10 = 0; i10 < workload.len; i10++) {
        tmp9.data[i10] = workload.data[i10];
      }
      tmp9.data[workload.len] = (tmp_item1_t){.p = p0, .q = q1};
      tmp9.len = workload.len + 1;
      workload = tmp9;
      workload_list_t tmp11 = create_workload_list(workload.len + 1);
      for (int i12 = 0; i12 < workload.len; i12++) {
        tmp11.data[i12] = workload.data[i12];
      }
      tmp11.data[workload.len] = (tmp_item2_t){.p = p1, .q = q0};
      tmp11.len = workload.len + 1;
      workload = tmp11;
      workload_list_t tmp13 = create_workload_list(workload.len + 1);
      for (int i14 = 0; i14 < workload.len; i14++) {
        tmp13.data[i14] = workload.data[i14];
      }
      tmp13.data[workload.len] = (tmp_item3_t){.p = p1, .q = q1};
      tmp13.len = workload.len + 1;
      workload = tmp13;
    }
  }
  return inters;
}

int mochi_main() {
  __auto_type p =
      (quad_curve_t){.x = (quad_spline_t){.c0 = (-1.0), .c1 = 0.0, .c2 = 1.0},
                     .y = (quad_spline_t){.c0 = 0.0, .c1 = 10.0, .c2 = 0.0}};
  __auto_type q =
      (quad_curve_t){.x = (quad_spline_t){.c0 = 2.0, .c1 = (-8.0), .c2 = 2.0},
                     .y = (quad_spline_t){.c0 = 1.0, .c1 = 2.0, .c2 = 3.0}};
  __auto_type tol = 0.0000001;
  __auto_type spacing = tol * 10.0;
  __auto_type inters = findIntersects(&p, &q, tol, spacing);
  __auto_type i = 0;
  while (i < inters.len) {
    __auto_type pt = inters.data[i];
    char *tmp15 = _str(pt.x);
    char *tmp16 = concat_string("(", tmp15);
    char *tmp17 = concat_string(tmp16, ", ");
    char *tmp18 = _str(pt.y);
    char *tmp19 = concat_string(tmp17, tmp18);
    char *tmp20 = concat_string(tmp19, ")");
    printf("%s\n", tmp20);
    i = i + 1;
  }
}

int _mochi_main() {
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
