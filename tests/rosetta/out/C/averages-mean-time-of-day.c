// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:20:42Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:20:42Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static double PI = 3.141592653589793;

double sinApprox(double x) {
  double term = x;
  double sum = x;
  int n = 1;
  while (n <= 8) {
    double denom = (double)(((2 * n) * (2 * n + 1)));
    term = (-term) * x * x / denom;
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

double cosApprox(double x) {
  double term = 1.0;
  double sum = 1.0;
  int n = 1;
  while (n <= 8) {
    double denom = (double)(((2 * n - 1) * (2 * n)));
    term = (-term) * x * x / denom;
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

double atanApprox(double x) {
  if (x > 1.0) {
    return PI / 2.0 - x / (x * x + 0.28);
  }
  if (x < ((-1.0))) {
    return (-PI) / 2.0 - x / (x * x + 0.28);
  }
  return x / (1.0 + 0.28 * x * x);
}

double atan2Approx(double y, double x) {
  if (x > 0.0) {
    return atanApprox(y / x);
  }
  if (x < 0.0) {
    if (y >= 0.0) {
      return atanApprox(y / x) + PI;
    }
    return atanApprox(y / x) - PI;
  }
  if (y > 0.0) {
    return PI / 2.0;
  }
  if (y < 0.0) {
    return (-PI) / 2.0;
  }
  return 0.0;
}

int digit(char *ch) {
  char *digits = "0123456789";
  int i = 0;
  while (i < strlen(digits)) {
    if (slice_string(digits, i, i + 1) == ch) {
      return i;
    }
    i = i + 1;
  }
  return 0;
}

int parseTwo(char *s, int idx) {
  return digit(slice_string(s, idx, idx + 1)) * 10 +
         digit(slice_string(s, idx + 1, idx + 2));
}

double parseSec(char *s) {
  int h = parseTwo(s, 0);
  int m = parseTwo(s, 3);
  int sec = parseTwo(s, 6);
  return (double)(((h * 60 + m) * 60 + sec));
}

char *pad(int n) {
  if (n < 10) {
    char *tmp1 = _str(n);
    char *tmp2 = concat_string("0", tmp1);
    return tmp2;
  }
  char *tmp3 = _str(n);
  return tmp3;
}

char *meanTime(list_string times) {
  double ssum = 0.0;
  double csum = 0.0;
  int i = 0;
  while (i < times.len) {
    double sec = parseSec(times.data[i]);
    double ang = sec * 2.0 * PI / 86400.0;
    ssum = ssum + sinApprox(ang);
    csum = csum + cosApprox(ang);
    i = i + 1;
  }
  double theta = atan2Approx(ssum, csum);
  double frac = theta / (2.0 * PI);
  while (frac < 0.0) {
    frac = frac + 1.0;
  }
  double total = frac * 86400.0;
  int si = (int)(total);
  int h = (int)((((double)si) / ((double)3600)));
  int m = (int)(((si % 3600) / 60));
  int s = (int)((si % 60));
  return pad(h) + ":" + pad(m) + ":" + pad(s);
}

int mochi_main() {
  list_string inputs = list_string_create(4);
  inputs.data[0] = "23:00:17";
  inputs.data[1] = "23:40:20";
  inputs.data[2] = "00:12:45";
  inputs.data[3] = "00:17:19";
  printf("%d\n", meanTime(inputs));
}

int _mochi_main() {
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
