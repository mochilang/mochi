// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:11:46Z
// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:11:46Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static int tr;
static int i = 1;

typedef struct {
  char *cl;
  int le;
  int aa;
  int ri;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int node(char *cl, int le, int aa, int ri) {
  return (tmp_item_t){.cl = cl, .le = le, .aa = aa, .ri = ri};
}

char *treeString(int t) {
  if ((t == 0)) {
    return "E";
  }
  __auto_type m = (map_string_int)(t);
  char *tmp1 = concat_string("T(", m.data["cl"]);
  char *tmp2 = concat_string(tmp1, ", ");
  char *tmp3 = concat_string(tmp2, treeString(m.data["le"]));
  char *tmp4 = concat_string(tmp3, ", ");
  char *tmp5 = _str(m.data["aa"]);
  char *tmp6 = concat_string(tmp4, tmp5);
  char *tmp7 = concat_string(tmp6, ", ");
  char *tmp8 = concat_string(tmp7, treeString(m.data["ri"]));
  char *tmp9 = concat_string(tmp8, ")");
  return tmp9;
}

int balance(int t) {
  if ((t == 0)) {
    return t;
  }
  __auto_type m = (map_string_int)(t);
  if ((m.data["cl"] != "B")) {
    return t;
  }
  __auto_type le = m.data["le"];
  __auto_type ri = m.data["ri"];
  if ((le != 0)) {
    __auto_type leMap = (map_string_int)(le);
    if ((leMap.data["cl"] == "R")) {
      __auto_type lele = leMap.data["le"];
      if ((lele != 0)) {
        __auto_type leleMap = (map_string_int)(lele);
        if ((leleMap.data["cl"] == "R")) {
          return node("R",
                      node("B", leleMap.data["le"], leleMap.data["aa"],
                           leleMap.data["ri"]),
                      leMap.data["aa"],
                      node("B", leMap.data["ri"], m.data["aa"], ri));
        }
      }
      __auto_type leri = leMap.data["ri"];
      if ((leri != 0)) {
        __auto_type leriMap = (map_string_int)(leri);
        if ((leriMap.data["cl"] == "R")) {
          return node(
              "R",
              node("B", leMap.data["le"], leMap.data["aa"], leriMap.data["le"]),
              leriMap.data["aa"],
              node("B", leriMap.data["ri"], m.data["aa"], ri));
        }
      }
    }
  }
  if ((ri != 0)) {
    __auto_type riMap = (map_string_int)(ri);
    if ((riMap.data["cl"] == "R")) {
      __auto_type rile = riMap.data["le"];
      if ((rile != 0)) {
        __auto_type rileMap = (map_string_int)(rile);
        if ((rileMap.data["cl"] == "R")) {
          return node("R",
                      node("B", m.data["le"], m.data["aa"], rileMap.data["le"]),
                      rileMap.data["aa"],
                      node("B", rileMap.data["ri"], riMap.data["aa"],
                           riMap.data["ri"]));
        }
      }
      __auto_type riri = riMap.data["ri"];
      if ((riri != 0)) {
        __auto_type ririMap = (map_string_int)(riri);
        if ((ririMap.data["cl"] == "R")) {
          return node("R",
                      node("B", m.data["le"], m.data["aa"], riMap.data["le"]),
                      riMap.data["aa"],
                      node("B", ririMap.data["le"], ririMap.data["aa"],
                           ririMap.data["ri"]));
        }
      }
    }
  }
  return t;
}

int ins(int tr, int x) {
  if ((tr == 0)) {
    return node("R", 0, x, 0);
  }
  if ((x < tr.data["aa"])) {
    return balance(node(tr.data["cl"], ins(tr.data["le"], x), tr.data["aa"],
                        tr.data["ri"]));
  }
  if ((x > tr.data["aa"])) {
    return balance(node(tr.data["cl"], tr.data["le"], tr.data["aa"],
                        ins(tr.data["ri"], x)));
  }
  return tr;
}

int insert(int tr, int x) {
  __auto_type t = ins(tr, x);
  if ((t == 0)) {
    return 0;
  }
  __auto_type m = (map_string_int)(t);
  return node("B", m.data["le"], m.data["aa"], m.data["ri"]);
}

int _mochi_main() {
  tr = 0;
  while (i <= 16) {
    tr = insert(tr, i);
    i = i + 1;
  }
  printf("%s\n", treeString(tr));
  return 0;
}
int main() { return _mochi_main(); }
