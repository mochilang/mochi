// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:09:47Z
// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:09:47Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static list_string concat_list_string(list_string a, list_string b) {
  list_string r = list_string_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_input() {
  char buf[1024];
  if (!fgets(buf, sizeof(buf), stdin))
    return strdup("");
  size_t len = strlen(buf);
  if (len > 0 && buf[len - 1] == '\n')
    buf[len - 1] = '\0';
  return strdup(buf);
}
static int index_of_string(char *s, char *sub) {
  char *pos = strstr(s, sub);
  if (!pos)
    return -1;
  return pos - s;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static list_string slice_list_string(list_string v, int start, int end) {
  if (start < 0)
    start += v.len;
  if (end < 0)
    end += v.len;
  if (start < 0)
    start = 0;
  if (end > v.len)
    end = v.len;
  if (start > end)
    start = end;
  list_string r = list_string_create(end - start);
  for (int i = 0; i < r.len; i++)
    r.data[i] = v.data[start + i];
  return r;
}
int indexOf(char *s, char *ch) {
  __auto_type i = 0;
  while (i < strlen(s)) {
    if ((strcmp(slice_string(s, i, i + 1), ch) == 0)) {
      return i;
    }
    i = i + 1;
  }
  return (-1);
}

list_string fields(char *s) {
  list_string words = list_string_create(0);
  __auto_type cur = "";
  __auto_type i = 0;
  while (i < strlen(s)) {
    __auto_type ch = slice_string(s, i, i + 1);
    if ((strcmp(ch, " ") == 0) || ch == "\t" || ch == "\n") {
      if (strlen(cur) > 0) {
        list_string tmp1 = list_string_create(1);
        tmp1.data[0] = cur;
        list_string tmp2 = concat_list_string(words, tmp1);
        words = tmp2;
        cur = "";
      }
    } else {
      char *tmp3 = concat_string(cur, ch);
      cur = tmp3;
    }
    i = i + 1;
  }
  if (strlen(cur) > 0) {
    list_string tmp4 = list_string_create(1);
    tmp4.data[0] = cur;
    list_string tmp5 = concat_list_string(words, tmp4);
    words = tmp5;
  }
  return words;
}

list_string makePatterns() {
  list_string digits = list_string_create(9);
  digits.data[0] = "1";
  digits.data[1] = "2";
  digits.data[2] = "3";
  digits.data[3] = "4";
  digits.data[4] = "5";
  digits.data[5] = "6";
  digits.data[6] = "7";
  digits.data[7] = "8";
  digits.data[8] = "9";
  list_string pats = list_string_create(0);
  __auto_type i = 0;
  while ((i < 9)) {
    __auto_type j = 0;
    while ((j < 9)) {
      if (j != i) {
        __auto_type k = 0;
        while ((k < 9)) {
          if (k != i && k != j) {
            __auto_type l = 0;
            while ((l < 9)) {
              if (l != i && l != j && l != k) {
                int tmp6_data[1];
                list_int tmp6 = {1, tmp6_data};
                tmp6.data[0] = digits.data[i] + digits.data[j] +
                               digits.data[k] + digits.data[l];
                list_int tmp7 = concat_list_int(pats, tmp6);
                pats = tmp7;
              }
              l = l + 1;
            }
          }
          k = k + 1;
        }
      }
      j = j + 1;
    }
    i = i + 1;
  }
  return pats;
}

int mochi_main() {
  char *tmp8 = concat_string(
      "Cows and bulls/player\n",
      "You think of four digit number of unique digits in the range 1 to 9.\n");
  char *tmp9 = concat_string(tmp8, "I guess.  You score my guess:\n");
  char *tmp10 = concat_string(
      tmp9, "    A correct digit but not in the correct place is a cow.\n");
  char *tmp11 = concat_string(
      tmp10, "    A correct digit in the correct place is a bull.\n");
  char *tmp12 = concat_string(
      tmp11, "You give my score as two numbers separated with a space.");
  printf("%s\n", tmp12);
  __auto_type patterns = makePatterns();
  while (1) {
    if (patterns.len == 0) {
      printf("Oops, check scoring.\n");
      return;
    }
    __auto_type guess = patterns.data[0];
    list_string tmp13 = slice_list_string(patterns, 1, patterns.len);
    patterns = tmp13;
    __auto_type cows = 0;
    __auto_type bulls = 0;
    while (1) {
      char *tmp14 = concat_string("My guess: ", guess);
      char *tmp15 = concat_string(tmp14, ".  Score? (c b) ");
      printf("%s\n", tmp15);
      __auto_type line = _input();
      __auto_type toks = fields(line);
      if (toks.len == 2) {
        __auto_type c = atoi(toks.data[0]);
        __auto_type b = atoi(toks.data[1]);
        if (c >= 0 && c <= 4 && b >= 0 && b <= 4 && c + b <= 4) {
          cows = c;
          bulls = b;
          break;
        }
      }
      printf("Score guess as two numbers: cows bulls\n");
    }
    if (bulls == 4) {
      printf("I did it. :)\n");
      return;
    }
    list_string next = list_string_create(0);
    __auto_type idx = 0;
    while (idx < patterns.len) {
      __auto_type pat = patterns.data[idx];
      __auto_type c = 0;
      __auto_type b = 0;
      __auto_type i = 0;
      while (i < 4) {
        __auto_type cg = slice_string(guess, i, i + 1);
        __auto_type cp = slice_string(pat, i, i + 1);
        if ((strcmp(cg, cp) == 0)) {
          b = b + 1;
        } else if (index_of_string(pat, cg) >= 0) {
          c = c + 1;
        }
        i = i + 1;
      }
      if (c == cows && b == bulls) {
        list_string tmp16 = list_string_create(1);
        tmp16.data[0] = pat;
        list_string tmp17 = concat_list_string(next, tmp16);
        next = tmp17;
      }
      idx = idx + 1;
    }
    patterns = next;
  }
}

int _mochi_main() {
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
