// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:14:41Z
// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:14:40Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_input() {
  char buf[1024];
  if (!fgets(buf, sizeof(buf), stdin))
    return strdup("");
  size_t len = strlen(buf);
  if (len > 0 && buf[len - 1] == '\n')
    buf[len - 1] = '\0';
  return strdup(buf);
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static long long _now() {
  struct timespec ts;
  clock_gettime(CLOCK_REALTIME, &ts);
  return (long long)ts.tv_sec * 1000000000LL + ts.tv_nsec;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static list_int board;
static list_int solved;
static int empty = 15;
static int moves = 0;
static int quit = 0;

typedef struct {
  int idx;
  int ok;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int idx;
  int ok;
} tmp_item1_t;
typedef struct {
  int len;
  tmp_item1_t *data;
} tmp_item1_list_t;
tmp_item1_list_t create_tmp_item1_list(int len) {
  tmp_item1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int idx;
  int ok;
} tmp_item2_t;
typedef struct {
  int len;
  tmp_item2_t *data;
} tmp_item2_list_t;
tmp_item2_list_t create_tmp_item2_list(int len) {
  tmp_item2_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item2_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int idx;
  int ok;
} tmp_item3_t;
typedef struct {
  int len;
  tmp_item3_t *data;
} tmp_item3_list_t;
tmp_item3_list_t create_tmp_item3_list(int len) {
  tmp_item3_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item3_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int idx;
  int ok;
} tmp_item4_t;
typedef struct {
  int len;
  tmp_item4_t *data;
} tmp_item4_list_t;
tmp_item4_list_t create_tmp_item4_list(int len) {
  tmp_item4_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item4_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int randMove() { return _now() % 4; }

int isSolved() {
  __auto_type i = 0;
  while (i < 16) {
    if (board.data[i] != solved.data[i]) {
      return 0;
    }
    i = i + 1;
  }
  return 1;
}

int isValidMove(int m) {
  if (m == 0) {
    return (tmp_item_t){.idx = empty - 4,
                        .ok = ((double)empty) / ((double)4) > 0};
  }
  if (m == 1) {
    return (tmp_item1_t){.idx = empty + 4,
                         .ok = ((double)empty) / ((double)4) < 3};
  }
  if (m == 2) {
    return (tmp_item2_t){.idx = empty + 1, .ok = empty % 4 < 3};
  }
  if (m == 3) {
    return (tmp_item3_t){.idx = empty - 1, .ok = empty % 4 > 0};
  }
  return (tmp_item4_t){.idx = 0, .ok = 0};
}

int doMove(int m) {
  __auto_type r = isValidMove(m);
  if (((!r.data["ok"]))) {
    return 0;
  }
  __auto_type i = empty;
  __auto_type j = atoi(r.data["idx"]);
  __auto_type tmp = board.data[i];
  board.data[i] = board.data[j];
  board.data[j] = tmp;
  empty = j;
  moves = moves + 1;
  return 1;
}

int shuffle(int n) {
  __auto_type i = 0;
  while (i < n || isSolved()) {
    if (doMove(randMove())) {
      i = i + 1;
    }
  }
}

int printBoard() {
  __auto_type line = "";
  __auto_type i = 0;
  while (i < 16) {
    __auto_type val = board.data[i];
    if (val == 0) {
      char *tmp1 = concat_string(line, "  .");
      line = tmp1;
    } else {
      char *tmp2 = _str(val);
      __auto_type s = tmp2;
      if (val < 10) {
        char *tmp3 = concat_string(line, "  ");
        char *tmp4 = concat_string(tmp3, s);
        line = tmp4;
      } else {
        char *tmp5 = concat_string(line, " ");
        char *tmp6 = concat_string(tmp5, s);
        line = tmp6;
      }
    }
    if (i % 4 == 3) {
      printf("%s\n", line);
      line = "";
    }
    i = i + 1;
  }
}

int playOneMove() {
  while (1) {
    char *tmp7 = _str(moves + 1);
    char *tmp8 = concat_string("Enter move #", tmp7);
    char *tmp9 = concat_string(tmp8, " (U, D, L, R, or Q): ");
    printf("%s\n", tmp9);
    __auto_type s = _input();
    if ((strcmp(s, "") == 0)) {
      continue;
    }
    char *tmp10 = slice_string(s, 0, 1);
    __auto_type c = tmp10;
    __auto_type m = 0;
    if ((strcmp(c, "U") == 0) || c == "u") {
      m = 0;
    } else if ((strcmp(c, "D") == 0) || c == "d") {
      m = 1;
    } else if ((strcmp(c, "R") == 0) || c == "r") {
      m = 2;
    } else if ((strcmp(c, "L") == 0) || c == "l") {
      m = 3;
    } else if ((strcmp(c, "Q") == 0) || c == "q") {
      char *tmp11 = _str(moves);
      char *tmp12 = concat_string("Quiting after ", tmp11);
      char *tmp13 = concat_string(tmp12, " moves.");
      printf("%s\n", tmp13);
      quit = 1;
      return;
    } else {
      char *tmp14 = concat_string(
          "Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n",
          "up, down, left, or right. You can also enter \"Q\" to quit.\n");
      char *tmp15 = concat_string(
          tmp14,
          "Upper or lowercase is accepted and only the first non-blank\n");
      char *tmp16 = concat_string(
          tmp15,
          "character is important (i.e. you may enter \"up\" if you like).");
      printf("%s\n", tmp16);
      continue;
    }
    if ((!doMove(m))) {
      printf("That is not a valid move at the moment.\n");
      continue;
    }
    return;
  }
}

int play() {
  printf("Starting board:\n");
  while (((!quit) && ((!isSolved())))) {
    printf("\n");
    printBoard();
    playOneMove();
  }
  if (isSolved()) {
    char *tmp17 = _str(moves);
    char *tmp18 = concat_string("You solved the puzzle in ", tmp17);
    char *tmp19 = concat_string(tmp18, " moves.");
    printf("%s\n", tmp19);
  }
}

int mochi_main() {
  shuffle(50);
  play();
}

int _mochi_main() {
  list_int tmp20 = list_int_create(16);
  tmp20.data[0] = 1;
  tmp20.data[1] = 2;
  tmp20.data[2] = 3;
  tmp20.data[3] = 4;
  tmp20.data[4] = 5;
  tmp20.data[5] = 6;
  tmp20.data[6] = 7;
  tmp20.data[7] = 8;
  tmp20.data[8] = 9;
  tmp20.data[9] = 10;
  tmp20.data[10] = 11;
  tmp20.data[11] = 12;
  tmp20.data[12] = 13;
  tmp20.data[13] = 14;
  tmp20.data[14] = 15;
  tmp20.data[15] = 0;
  board = tmp20;
  list_int tmp21 = list_int_create(16);
  tmp21.data[0] = 1;
  tmp21.data[1] = 2;
  tmp21.data[2] = 3;
  tmp21.data[3] = 4;
  tmp21.data[4] = 5;
  tmp21.data[5] = 6;
  tmp21.data[6] = 7;
  tmp21.data[7] = 8;
  tmp21.data[8] = 9;
  tmp21.data[9] = 10;
  tmp21.data[10] = 11;
  tmp21.data[11] = 12;
  tmp21.data[12] = 13;
  tmp21.data[13] = 14;
  tmp21.data[14] = 15;
  tmp21.data[15] = 0;
  solved = tmp21;
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
