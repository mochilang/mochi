// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:41Z
// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:41Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_string concat_list_string(list_string a, list_string b) {
  list_string r = list_string_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
int amb(int wordsets, list_string res, int idx) {
  if (idx == wordsets.len) {
    return 1;
  }
  const char *prev = "";
  if (idx > 0) {
    prev = res.data[idx - 1];
  }
  int i = 0;
  while (i < wordsets.data[idx].len) {
    const char *w = wordsets.data[idx].data[i];
    if (idx == 0 || slice_string(prev, strlen(prev) - 1, strlen(prev)) ==
                        slice_string(w, 0, 1)) {
      res.data[idx] = w;
      if (amb(wordsets, res, idx + 1)) {
        return 1;
      }
    }
    i = i + 1;
  }
  return 0;
}

int main() {
  list_string wordset = list_string_create(3);
  wordset.data[0] = "the";
  wordset.data[1] = "that";
  wordset.data[2] = "a";
  list_string wordset = list_string_create(3);
  wordset.data[0] = "frog";
  wordset.data[1] = "elephant";
  wordset.data[2] = "thing";
  list_string wordset = list_string_create(3);
  wordset.data[0] = "walked";
  wordset.data[1] = "treaded";
  wordset.data[2] = "grows";
  list_string wordset = list_string_create(2);
  wordset.data[0] = "slowly";
  wordset.data[1] = "quickly";
  list_int wordset_data[] = {wordset, wordset, wordset, wordset};
  list_list_int wordset = {4, wordset_data};
  list_int wordset = wordset;
  list_string tmp1 = {0, NULL};
  int res = tmp1;
  int i = 0;
  while (i < wordset.len) {
    list_string tmp2 = list_string_create(1);
    tmp2.data[0] = "";
    list_string tmp3 = concat_list_string(res, tmp2);
    res = tmp3;
    i = i + 1;
  }
  if (amb(wordset, res, 0)) {
    char *tmp4 = concat_string("[", res.data[0]);
    const char *out = tmp4;
    int j = 1;
    while (j < res.len) {
      char *tmp5 = concat_string(out, " ");
      char *tmp6 = concat_string(tmp5, res.data[j]);
      out = tmp6;
      j = j + 1;
    }
    char *tmp7 = concat_string(out, "]");
    out = tmp7;
    printf("%s\n", out);
  } else {
    printf("No amb found\n");
  }
}

int main() {
  main();
  return 0;
}
