// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:11:37Z
// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:11:37Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static int r1;
static int r2;
static int r3;

typedef struct {
  int (*)(int) count;
  int list;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int validComb(int a, int b, int c, int d, int e, int f, int g) {
  __auto_type square1 = a + b;
  __auto_type square2 = b + c + d;
  __auto_type square3 = d + e + f;
  __auto_type square4 = f + g;
  return square1 == square2 && square2 == square3 && square3 == square4;
}

int isUnique(int a, int b, int c, int d, int e, int f, int g) {
  list_int nums = list_int_create(7);
  nums.data[0] = a;
  nums.data[1] = b;
  nums.data[2] = c;
  nums.data[3] = d;
  nums.data[4] = e;
  nums.data[5] = f;
  nums.data[6] = g;
  __auto_type i = 0;
  while (i < 7) {
    __auto_type j = i + 1;
    while (j < 7) {
      if (nums.data[i] == nums.data[j]) {
        return 0;
      }
      j = j + 1;
    }
    i = i + 1;
  }
  return 1;
}

int getCombs(int low, int high, int unique) {
  list_int valid = list_int_create(0);
  __auto_type count = 0;
  for (int b = low; b < (high + 1); b++) {
    for (int c = low; c < (high + 1); c++) {
      for (int d = low; d < (high + 1); d++) {
        __auto_type s = b + c + d;
        for (int e = low; e < (high + 1); e++) {
          for (int f = low; f < (high + 1); f++) {
            __auto_type a = s - b;
            __auto_type g = s - f;
            if (a < low || a > high) {
              continue;
            }
            if (g < low || g > high) {
              continue;
            }
            if (d + e + f != s) {
              continue;
            }
            if (f + g != s) {
              continue;
            }
            if ((!unique) || isUnique(a, b, c, d, e, f, g)) {
              list_int tmp1 = list_int_create(7);
              tmp1.data[0] = a;
              tmp1.data[1] = b;
              tmp1.data[2] = c;
              tmp1.data[3] = d;
              tmp1.data[4] = e;
              tmp1.data[5] = f;
              tmp1.data[6] = g;
              valid = 0;
              count = count + 1;
            }
          }
        }
      }
    }
  }
  return (tmp_item_t){.count = count, .list = valid};
}

int _mochi_main() {
  r1 = getCombs(1, 7, 1);
  r2 = getCombs(3, 9, 1);
  r3 = getCombs(0, 9, 0);
  char *tmp2 = _str(r1.data["count"]);
  char *tmp3 = concat_string(tmp2, " unique solutions in 1 to 7");
  printf("%s\n", tmp3);
  printf("%d\n", r1.data["list"]);
  char *tmp4 = _str(r2.data["count"]);
  char *tmp5 = concat_string(tmp4, " unique solutions in 3 to 9");
  printf("%s\n", tmp5);
  printf("%d\n", r2.data["list"]);
  char *tmp6 = _str(r3.data["count"]);
  char *tmp7 = concat_string(tmp6, " non-unique solutions in 0 to 9");
  printf("%s\n", tmp7);
  return 0;
}
int main() { return _mochi_main(); }
