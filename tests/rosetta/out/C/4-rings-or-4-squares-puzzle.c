// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
typedef struct {
  int (*)(int) count;
  list_int list;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int validComb(int a, int b, int c, int d, int e, int f, int g) {
  int square1 = a + b;
  int square2 = b + c + d;
  int square3 = d + e + f;
  int square4 = f + g;
  return square1 == square2 && square2 == square3 && square3 == square4;
}

int isUnique(int a, int b, int c, int d, int e, int f, int g) {
  list_int nums = list_int_create(7);
  nums.data[0] = a;
  nums.data[1] = b;
  nums.data[2] = c;
  nums.data[3] = d;
  nums.data[4] = e;
  nums.data[5] = f;
  nums.data[6] = g;
  list_int nums = nums;
  int i = 0;
  while (i < 7) {
    int j = i + 1;
    while (j < 7) {
      if (nums.data[i] == nums.data[j]) {
        return 0;
      }
      j = j + 1;
    }
    i = i + 1;
  }
  return 1;
}

int getCombs(int low, int high, int unique) {
  list_int valid = list_int_create(0);
  int count = 0;
  for (int b = low; b < (high + 1); b++) {
    for (int c = low; c < (high + 1); c++) {
      for (int d = low; d < (high + 1); d++) {
        int s = b + c + d;
        for (int e = low; e < (high + 1); e++) {
          for (int f = low; f < (high + 1); f++) {
            int a = s - b;
            int g = s - f;
            if (a < low || a > high) {
              continue;
            }
            if (g < low || g > high) {
              continue;
            }
            if (d + e + f != s) {
              continue;
            }
            if (f + g != s) {
              continue;
            }
            if ((!unique) || isUnique(a, b, c, d, e, f, g)) {
              list_int tmp1 = list_int_create(0);
              list_int tmp2 = list_int_create(7);
              tmp2.data[0] = a;
              tmp2.data[1] = b;
              tmp2.data[2] = c;
              tmp2.data[3] = d;
              tmp2.data[4] = e;
              tmp2.data[5] = f;
              tmp2.data[6] = g;
              int tmp3_data[1];
              list_int tmp3 = {1, tmp3_data};
              tmp3.data[0] = tmp2;
              list_int tmp4 = concat_list_int(tmp1, tmp3);
              valid = tmp4;
              count = count + 1;
            }
          }
        }
      }
    }
  }
  list_int tmp5 = list_int_create(0);
  return (tmp_item_t){.count = count, .list = tmp5};
}

int main() {
  int r1 = getCombs(1, 7, 1);
  char *tmp6 = _str(r1.data["count"]);
  char *tmp7 = concat_string(tmp6, " unique solutions in 1 to 7");
  printf("%s\n", tmp7);
  printf("%d\n", r1.data["list"]);
  int r2 = getCombs(3, 9, 1);
  char *tmp8 = _str(r2.data["count"]);
  char *tmp9 = concat_string(tmp8, " unique solutions in 3 to 9");
  printf("%s\n", tmp9);
  printf("%d\n", r2.data["list"]);
  int r3 = getCombs(0, 9, 0);
  char *tmp10 = _str(r3.data["count"]);
  char *tmp11 = concat_string(tmp10, " non-unique solutions in 0 to 9");
  printf("%s\n", tmp11);
  return 0;
}
