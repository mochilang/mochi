// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:09:42Z
// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:09:42Z
#include <stdio.h>
#include <stdlib.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
typedef struct pixel_t pixel_t;

static int b2Seg = 20;
static int b;

typedef struct {
  int cols;
  int rows;
  int data;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct pixel_t {
  int r;
  int g;
  int b;
} pixel_t;
typedef struct {
  int len;
  pixel_t *data;
} pixel_list_t;
pixel_list_t create_pixel_list(int len) {
  pixel_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(pixel_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

pixel_t pixelFromRgb(int rgb) {
  __auto_type r = (int)(((((double)rgb) / ((double)65536)) % 256));
  __auto_type g = (int)(((((double)rgb) / ((double)256)) % 256));
  __auto_type b = (int)((rgb % 256));
  return (pixel_t){.r = r, .g = g, .b = b};
}

int newBitmap(int cols, int rows) {
  __auto_type y = 0;
  while (y < rows) {
    pixel_list_t row = {0, NULL};
    __auto_type x = 0;
    while (x < cols) {
      pixel_list_t tmp1 = create_pixel_list(row.len + 1);
      for (int i2 = 0; i2 < row.len; i2++) {
        tmp1.data[i2] = row.data[i2];
      }
      tmp1.data[row.len] = (pixel_t){.r = 0, .g = 0, .b = 0};
      tmp1.len = row.len + 1;
      row = tmp1;
      x = x + 1;
    }
    d = 0;
    y = y + 1;
  }
  return (tmp_item_t){.cols = cols, .rows = rows, .data = d};
}

int setPx(map_string_int b, int x, int y, pixel_t *p) {
  __auto_type cols = (int)(b.data["cols"]);
  __auto_type rows = (int)(b.data["rows"]);
  if (x >= 0 && x < cols && y >= 0 && y < rows) {
    b.data["data"].data[y].data[x] = p;
  }
}

int fill(map_string_int b, pixel_t *p) {
  __auto_type cols = (int)(b.data["cols"]);
  __auto_type rows = (int)(b.data["rows"]);
  __auto_type y = 0;
  while (y < rows) {
    __auto_type x = 0;
    while (x < cols) {
      b.data["data"].data[y].data[x] = p;
      x = x + 1;
    }
    y = y + 1;
  }
}

int fillRgb(map_string_int b, int rgb) { fill(b, &pixelFromRgb(rgb)); }

int line(map_string_int b, int x0, int y0, int x1, int y1, pixel_t *p) {
  __auto_type dx = x1 - x0;
  if (dx < 0) {
    dx = (-dx);
  }
  __auto_type dy = y1 - y0;
  if (dy < 0) {
    dy = (-dy);
  }
  __auto_type sx = (-1);
  if (x0 < x1) {
    sx = 1;
  }
  __auto_type sy = (-1);
  if (y0 < y1) {
    sy = 1;
  }
  __auto_type err = dx - dy;
  while (1) {
    setPx(b, x0, y0, &p);
    if (x0 == x1 && y0 == y1) {
      break;
    }
    __auto_type e2 = 2 * err;
    if (e2 > (0 - dy)) {
      err = err - dy;
      x0 = x0 + sx;
    }
    if (e2 < dx) {
      err = err + dx;
      y0 = y0 + sy;
    }
  }
}

int bezier2(map_string_int b, int x1, int y1, int x2, int y2, int x3, int y3,
            pixel_t *p) {
  list_int px = list_int_create(0);
  list_int py = list_int_create(0);
  __auto_type i = 0;
  while (i <= b2Seg) {
    int tmp3_data[1];
    list_int tmp3 = {1, tmp3_data};
    tmp3.data[0] = 0;
    list_int tmp4 = concat_list_int(px, tmp3);
    px = tmp4;
    int tmp5_data[1];
    list_int tmp5 = {1, tmp5_data};
    tmp5.data[0] = 0;
    list_int tmp6 = concat_list_int(py, tmp5);
    py = tmp6;
    i = i + 1;
  }
  __auto_type fx1 = (double)(x1);
  __auto_type fy1 = (double)(y1);
  __auto_type fx2 = (double)(x2);
  __auto_type fy2 = (double)(y2);
  __auto_type fx3 = (double)(x3);
  __auto_type fy3 = (double)(y3);
  i = 0;
  while (i <= b2Seg) {
    __auto_type c = ((double)(i)) / ((double)(b2Seg));
    __auto_type a = 1.0 - c;
    __auto_type a2 = a * a;
    __auto_type b2 = 2.0 * c * a;
    __auto_type c2 = c * c;
    px.data[i] = (int)((a2 * fx1 + b2 * fx2 + c2 * fx3));
    py.data[i] = (int)((a2 * fy1 + b2 * fy2 + c2 * fy3));
    i = i + 1;
  }
  __auto_type x0 = px.data[0];
  __auto_type y0 = py.data[0];
  i = 1;
  while (i <= b2Seg) {
    __auto_type x = px.data[i];
    __auto_type y = py.data[i];
    line(b, x0, y0, x, y, &p);
    x0 = x;
    y0 = y;
    i = i + 1;
  }
}

int _mochi_main() {
  b = newBitmap(400, 300);
  fillRgb(b, 14614575);
  bezier2(b, 20, 150, 500, (-100), 300, 280, &pixelFromRgb(4165615));
  return 0;
}
int main() { return _mochi_main(); }
