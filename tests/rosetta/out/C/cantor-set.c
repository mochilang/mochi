// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:59Z
// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:59Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_string concat_list_string(list_string a, list_string b) {
  list_string r = list_string_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static list_int slice_list_int(list_int v, int start, int end) {
  if (start < 0)
    start += v.len;
  if (end < 0)
    end += v.len;
  if (start < 0)
    start = 0;
  if (end > v.len)
    end = v.len;
  if (start > end)
    start = end;
  list_int r = list_int_create(end - start);
  for (int i = 0; i < r.len; i++)
    r.data[i] = v.data[start + i];
  return r;
}
static int width = 81;
static int height = 5;

typedef struct {
  int start;
  int len;
  int index;
} stack_t;
typedef struct {
  int len;
  stack_t *data;
} stack_list_t;
stack_list_t create_stack_list(int len) {
  stack_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(stack_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int start;
  int len;
  int index;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int start;
  int len;
  int index;
} tmp_item1_t;
typedef struct {
  int len;
  tmp_item1_t *data;
} tmp_item1_list_t;
tmp_item1_list_t create_tmp_item1_list(int len) {
  tmp_item1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

const char *setChar(char *s, int idx, char *ch) {
  return slice_string(s, 0, idx) + ch + slice_string(s, idx + 1, strlen(s));
}

int main() {
  list_string tmp1 = {0, NULL};
  int lines = tmp1;
  for (int i = 0; i < height; i++) {
    const char *row = "";
    int j = 0;
    while (j < width) {
      char *tmp2 = concat_string(row, "*");
      row = tmp2;
      j = j + 1;
    }
    list_string tmp3 = list_string_create(1);
    tmp3.data[0] = row;
    list_string tmp4 = concat_list_string(lines, tmp3);
    lines = tmp4;
  }
  stack_t stack[] = {(stack_t){.start = 0, .len = width, .index = 1}};
  int stack_len = sizeof(stack) / sizeof(stack[0]);
  while (stack_len > 0) {
    stack_t frame = stack[stack_len - 1];
    list_int tmp5 = slice_list_int(stack, 0, stack_len - 1);
    stack = tmp5;
    int start = frame.start;
    int lenSeg = frame.len;
    int index = frame.index;
    int seg = (int)((lenSeg / 3));
    if (seg == 0) {
      continue;
    }
    int i = index;
    while ((i < height)) {
      int j = start + seg;
      while ((j < start + 2 * seg)) {
        lines.data[i] = setChar(lines.data[i], j, " ");
        j = j + 1;
      }
      i = i + 1;
    }
    stack = 0;
    stack = 0;
  }
  for (int tmp6 = 0; tmp6 < lines.len; tmp6++) {
    char *line = lines.data[tmp6];
    printf("%s\n", line);
  }
  return 0;
}
