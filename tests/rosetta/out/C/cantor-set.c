// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:20:49Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:20:49Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_string concat_list_string(list_string a, list_string b) {
  list_string r = list_string_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static list_int slice_list_int(list_int v, int start, int end) {
  if (start < 0)
    start += v.len;
  if (end < 0)
    end += v.len;
  if (start < 0)
    start = 0;
  if (end > v.len)
    end = v.len;
  if (start > end)
    start = end;
  list_int r = list_int_create(end - start);
  for (int i = 0; i < r.len; i++)
    r.data[i] = v.data[start + i];
  return r;
}
static int width = 81;
static int height = 5;

typedef struct {
  int start;
  int len;
  int index;
} stack_t;
typedef struct {
  int len;
  stack_t *data;
} stack_list_t;
stack_list_t create_stack_list(int len) {
  stack_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(stack_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int start;
  int len;
  int index;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int start;
  int len;
  int index;
} tmp_item1_t;
typedef struct {
  int len;
  tmp_item1_t *data;
} tmp_item1_list_t;
tmp_item1_list_t create_tmp_item1_list(int len) {
  tmp_item1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

char *setChar(char *s, int idx, char *ch) {
  return slice_string(s, 0, idx) + ch + slice_string(s, idx + 1, strlen(s));
}

int _mochi_main() {
  list_string lines = list_string_create(0);
  for (int i = 0; i < height; i++) {
    char *row = "";
    int j = 0;
    while (j < width) {
      char *tmp1 = concat_string(row, "*");
      row = tmp1;
      j = j + 1;
    }
    list_string tmp2 = list_string_create(1);
    tmp2.data[0] = row;
    list_string tmp3 = concat_list_string(lines, tmp2);
    lines = tmp3;
  }
  stack_t stack[] = {(stack_t){.start = 0, .len = width, .index = 1}};
  int stack_len = sizeof(stack) / sizeof(stack[0]);
  while (stack_len > 0) {
    stack_t frame = stack[stack_len - 1];
    list_int tmp5 = {stack_len, stack};
    list_int tmp4 = slice_list_int(tmp5, 0, stack_len - 1);
    stack = tmp4;
    int start = frame.start;
    int lenSeg = frame.len;
    int index = frame.index;
    int seg = (int)((lenSeg / 3));
    if (seg == 0) {
      continue;
    }
    int i = index;
    while ((i < height)) {
      int j = start + seg;
      while ((j < start + 2 * seg)) {
        lines.data[i] = setChar(lines.data[i], j, " ");
        j = j + 1;
      }
      i = i + 1;
    }
    stack_list_t tmp6 = create_stack_list(stack.len + 1);
    for (int i7 = 0; i7 < stack.len; i7++) {
      tmp6.data[i7] = stack.data[i7];
    }
    tmp6.data[stack.len] =
        (tmp_item_t){.start = start, .len = seg, .index = index + 1};
    tmp6.len = stack.len + 1;
    stack = tmp6;
    stack_list_t tmp8 = create_stack_list(stack.len + 1);
    for (int i9 = 0; i9 < stack.len; i9++) {
      tmp8.data[i9] = stack.data[i9];
    }
    tmp8.data[stack.len] =
        (tmp_item1_t){.start = start + seg * 2, .len = seg, .index = index + 1};
    tmp8.len = stack.len + 1;
    stack = tmp8;
  }
  for (int tmp10 = 0; tmp10 < lines.len; tmp10++) {
    char *line = lines.data[tmp10];
    printf("%s\n", line);
  }
  return 0;
}
int main() { return _mochi_main(); }
