// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:11:57Z
// Generated by Mochi compiler v0.10.30 on 2025-07-18T17:11:57Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static double PI = 3.141592653589793;
static double degreesIncr;
static double turns = 2.0;
static double stop;
static double width = 600.0;
static double centre;
static double a = 1.0;
static double b = 20.0;
static double theta = 0.0;
static int count = 0;

double sinApprox(double x) {
  __auto_type term = x;
  __auto_type sum = x;
  __auto_type n = 1;
  while (n <= 10) {
    __auto_type denom = (double)(((2 * n) * (2 * n + 1)));
    term = (-term) * x * x / denom;
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

double cosApprox(double x) {
  __auto_type term = 1.0;
  __auto_type sum = 1.0;
  __auto_type n = 1;
  while (n <= 10) {
    __auto_type denom = (double)(((2 * n - 1) * (2 * n)));
    term = (-term) * x * x / denom;
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

int _mochi_main() {
  degreesIncr = 0.1 * PI / 180.0;
  stop = 360.0 * turns * 10.0 * degreesIncr;
  centre = width / 2.0;
  while (theta < stop) {
    __auto_type r = a + b * theta;
    __auto_type x = r * cosApprox(theta);
    __auto_type y = r * sinApprox(theta);
    if ((count % 100 == 0)) {
      char *tmp1 = _str(centre + x);
      char *tmp2 = concat_string(tmp1, ",");
      char *tmp3 = _str(centre - y);
      char *tmp4 = concat_string(tmp2, tmp3);
      printf("%s\n", tmp4);
    }
    theta = theta + degreesIncr;
    count = count + 1;
  }
  return 0;
}
int main() { return _mochi_main(); }
