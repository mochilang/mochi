// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:05Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:04Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  char *key;
  int value;
} pair_string_int;
static pair_string_int pair_string_int_new(char *key, int value) {
  pair_string_int p;
  p.key = key;
  p.value = value;
  return p;
}
typedef struct {
  int len;
  int cap;
  pair_string_int *data;
} map_string_int;
static map_string_int map_string_int_create(int cap) {
  map_string_int m;
  m.len = 0;
  m.cap = cap;
  m.data = cap ? calloc(cap, sizeof(pair_string_int)) : NULL;
  if (cap && !m.data) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return m;
}
static void map_string_int_put(map_string_int *m, char *k, int v) {
  for (int i = 0; i < m->len; i++)
    if (strcmp(m->data[i].key, k) == 0) {
      m->data[i].value = v;
      return;
    }
  if (m->len >= m->cap) {
    m->cap = m->cap ? m->cap * 2 : 4;
    m->data =
        (pair_string_int *)realloc(m->data, sizeof(pair_string_int) * m->cap);
  }
  m->data[m->len++] = pair_string_int_new(k, v);
}
static int map_string_int_get(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return m.data[i].value;
  return 0;
}
static int map_string_int_contains(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return 1;
  return 0;
}
static int cmp_map_string_int(map_string_int a, map_string_int b) {
  int aa = map_string_int_get(a, "a");
  int ba = map_string_int_get(b, "a");
  if (aa != ba)
    return aa > ba ? 1 : -1;
  int ab = map_string_int_get(a, "b");
  int bb = map_string_int_get(b, "b");
  if (ab != bb)
    return ab > bb ? 1 : -1;
  return 0;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static list_list_int concat_list_list_int(list_list_int a, list_list_int b) {
  list_list_int r = list_list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static int index_of_string(char *s, char *sub) {
  char *pos = strstr(s, sub);
  if (!pos)
    return -1;
  return pos - s;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
typedef struct point_t point_t;
typedef struct edge_t edge_t;
typedef struct point_ex_t point_ex_t;

typedef struct point_t {
  double x;
  double y;
  double z;
} point_t;
typedef struct {
  int len;
  point_t *data;
} point_list_t;
point_list_t create_point_list(int len) {
  point_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(point_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct edge_t {
  int pn1;
  int pn2;
  int fn1;
  int fn2;
  point_t cp;
} edge_t;
typedef struct {
  int len;
  edge_t *data;
} edge_list_t;
edge_list_t create_edge_list(int len) {
  edge_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(edge_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct point_ex_t {
  point_t p;
  int n;
} point_ex_t;
typedef struct {
  int len;
  point_ex_t *data;
} point_ex_list_t;
point_ex_list_t create_point_ex_list(int len) {
  point_ex_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(point_ex_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int indexOf(char *s, char *ch) {
  int i = 0;
  while (i < strlen(s)) {
    if (slice_string(s, i, i + 1) == ch) {
      return i;
    }
    i = i + 1;
  }
  return (-1);
}

char *fmt4(double x) {
  double y = x * 10000.0;
  if (y >= 0) {
    y = y + 0.5;
  } else {
    y = y - 0.5;
  }
  y = (double)(((int)(y))) / 10000.0;
  char *tmp1 = _str(y);
  char *s = tmp1;
  int dot = index_of_string(s, ".");
  if (dot == 0 - 1) {
    char *tmp2 = concat_string(s, ".0000");
    s = tmp2;
  } else {
    int decs = strlen(s) - dot - 1;
    if (decs > 4) {
      s = slice_string(s, 0, dot + 5);
    } else {
      while (decs < 4) {
        char *tmp3 = concat_string(s, "0");
        s = tmp3;
        decs = decs + 1;
      }
    }
  }
  if (x >= 0.0) {
    char *tmp4 = concat_string(" ", s);
    s = tmp4;
  }
  return s;
}

char *fmt2(int n) {
  char *tmp5 = _str(n);
  char *s = tmp5;
  if (strlen(s) < 2) {
    char *tmp6 = concat_string(" ", s);
    return tmp6;
  }
  return s;
}

point_t sumPoint(point_t *p1, point_t *p2) {
  return (point_t){.x = p1->x + p2->x, .y = p1->y + p2->y, .z = p1->z + p2->z};
}

point_t mulPoint(point_t *p, double m) {
  return (point_t){.x = p->x * m, .y = p->y * m, .z = p->z * m};
}

point_t divPoint(point_t *p, double d) { return mulPoint(&p, 1.0 / d); }

point_t centerPoint(point_t *p1, point_t *p2) {
  return divPoint(&sumPoint(&p1, &p2), 2.0);
}

point_list_t getFacePoints(int points, list_list_int faces) {
  point_list_t facePoints = {0, NULL};
  int i = 0;
  while (i < faces.len) {
    list_int face = faces.data[i];
    point_t fp = (point_t){.x = 0.0, .y = 0.0, .z = 0.0};
    for (int tmp7 = 0; tmp7 < face.len; tmp7++) {
      int idx = face.data[tmp7];
      fp = sumPoint(&fp, &points.data[idx]);
    }
    fp = divPoint(&fp, ((double)(face.len)));
    point_list_t tmp8 = create_point_list(facePoints.len + 1);
    for (int i9 = 0; i9 < facePoints.len; i9++) {
      tmp8.data[i9] = facePoints.data[i9];
    }
    tmp8.data[facePoints.len] = fp;
    tmp8.len = facePoints.len + 1;
    facePoints = tmp8;
    i = i + 1;
  }
  return facePoints;
}

list_list_int sortEdges(list_list_int edges) {
  list_list_int res = {0, NULL};
  list_list_int tmp = edges;
  while (tmp.len > 0) {
    list_int min = tmp.data[0];
    int idx = 0;
    int j = 1;
    while (j < tmp.len) {
      list_int e = tmp.data[j];
      if ((e.data[0] < min.data[0] ||
           (e.data[0] == min.data[0] &&
            (e.data[1] < min.data[1] ||
             (e.data[1] == min.data[1] && e.data[2] < min.data[2]))))) {
        min = e;
        idx = j;
      }
      j = j + 1;
    }
    list_list_int tmp10 = list_list_int_create(1);
    tmp10.data[0] = min;
    list_list_int tmp11 = concat_list_list_int(res, tmp10);
    res = tmp11;
    list_list_int out = {0, NULL};
    int k = 0;
    while (k < tmp.len) {
      if (k != idx) {
        list_list_int tmp12 = list_list_int_create(1);
        tmp12.data[0] = tmp.data[k];
        list_list_int tmp13 = concat_list_list_int(out, tmp12);
        out = tmp13;
      }
      k = k + 1;
    }
    tmp = out;
  }
  return res;
}

edge_list_t getEdgesFaces(int points, list_list_int faces) {
  list_list_int edges = {0, NULL};
  int fnum = 0;
  while (fnum < faces.len) {
    list_int face = faces.data[fnum];
    int numP = face.len;
    int pi = 0;
    while (pi < numP) {
      int pn1 = face.data[pi];
      int pn2 = 0;
      if (pi < numP - 1) {
        pn2 = face.data[pi + 1];
      } else {
        pn2 = face.data[0];
      }
      if (pn1 > pn2) {
        int tmpn = pn1;
        pn1 = pn2;
        pn2 = tmpn;
      }
      list_int tmp14 = list_int_create(3);
      tmp14.data[0] = pn1;
      tmp14.data[1] = pn2;
      tmp14.data[2] = fnum;
      list_list_int tmp15 = list_list_int_create(1);
      tmp15.data[0] = tmp14;
      list_list_int tmp16 = concat_list_list_int(edges, tmp15);
      edges = tmp16;
      pi = pi + 1;
    }
    fnum = fnum + 1;
  }
  edges = sortEdges(edges);
  list_list_int merged = {0, NULL};
  int idx = 0;
  while (idx < edges.len) {
    list_int e1 = edges.data[idx];
    if (idx < edges.len - 1) {
      list_int e2 = edges.data[idx + 1];
      if (e1.data[0] == e2.data[0] && e1.data[1] == e2.data[1]) {
        list_int tmp17 = list_int_create(4);
        tmp17.data[0] = e1.data[0];
        tmp17.data[1] = e1.data[1];
        tmp17.data[2] = e1.data[2];
        tmp17.data[3] = e2.data[2];
        list_list_int tmp18 = list_list_int_create(1);
        tmp18.data[0] = tmp17;
        list_list_int tmp19 = concat_list_list_int(merged, tmp18);
        merged = tmp19;
        idx = idx + 2;
        continue;
      }
    }
    list_int tmp20 = list_int_create(4);
    tmp20.data[0] = e1.data[0];
    tmp20.data[1] = e1.data[1];
    tmp20.data[2] = e1.data[2];
    tmp20.data[3] = (-1);
    list_list_int tmp21 = list_list_int_create(1);
    tmp21.data[0] = tmp20;
    list_list_int tmp22 = concat_list_list_int(merged, tmp21);
    merged = tmp22;
    idx = idx + 1;
  }
  edge_list_t edgesCenters = {0, NULL};
  for (int tmp23 = 0; tmp23 < merged.len; tmp23++) {
    list_int me = merged.data[tmp23];
    point_t p1 = points.data[me.data[0]];
    point_t p2 = points.data[me.data[1]];
    point_t cp = centerPoint(&p1, &p2);
    edge_list_t tmp24 = create_edge_list(edgesCenters.len + 1);
    for (int i25 = 0; i25 < edgesCenters.len; i25++) {
      tmp24.data[i25] = edgesCenters.data[i25];
    }
    tmp24.data[edgesCenters.len] = (edge_t){.pn1 = me.data[0],
                                            .pn2 = me.data[1],
                                            .fn1 = me.data[2],
                                            .fn2 = me.data[3],
                                            .cp = cp};
    tmp24.len = edgesCenters.len + 1;
    edgesCenters = tmp24;
  }
  return edgesCenters;
}

point_list_t getEdgePoints(int points, int edgesFaces, int facePoints) {
  point_list_t edgePoints = {0, NULL};
  int i = 0;
  while (i < edgesFaces.len) {
    edge_t edge = edgesFaces.data[i];
    point_t cp = edge.cp;
    point_t fp1 = facePoints.data[edge.fn1];
    point_t fp2 = fp1;
    if (edge.fn2 != 0 - 1) {
      fp2 = facePoints.data[edge.fn2];
    }
    point_t cfp = centerPoint(&fp1, &fp2);
    point_list_t tmp26 = create_point_list(edgePoints.len + 1);
    for (int i27 = 0; i27 < edgePoints.len; i27++) {
      tmp26.data[i27] = edgePoints.data[i27];
    }
    tmp26.data[edgePoints.len] = centerPoint(&cp, &cfp);
    tmp26.len = edgePoints.len + 1;
    edgePoints = tmp26;
    i = i + 1;
  }
  return edgePoints;
}

point_list_t getAvgFacePoints(int points, list_list_int faces, int facePoints) {
  int numP = points.len;
  point_ex_list_t temp = {0, NULL};
  int i = 0;
  while (i < numP) {
    point_ex_list_t tmp28 = create_point_ex_list(temp.len + 1);
    for (int i29 = 0; i29 < temp.len; i29++) {
      tmp28.data[i29] = temp.data[i29];
    }
    tmp28.data[temp.len] =
        (point_ex_t){.p = (point_t){.x = 0.0, .y = 0.0, .z = 0.0}, .n = 0};
    tmp28.len = temp.len + 1;
    temp = tmp28;
    i = i + 1;
  }
  int fnum = 0;
  while (fnum < faces.len) {
    point_t fp = facePoints.data[fnum];
    for (int tmp30 = 0; tmp30 < faces.data[fnum].len; tmp30++) {
      int pn = faces.data[fnum].data[tmp30];
      point_ex_t tp = temp.data[pn];
      temp.data[pn] = (point_ex_t){.p = sumPoint(&tp.p, &fp), .n = tp.n + 1};
    }
    fnum = fnum + 1;
  }
  point_list_t avg = {0, NULL};
  int j = 0;
  while (j < numP) {
    point_ex_t tp = temp.data[j];
    point_list_t tmp31 = create_point_list(avg.len + 1);
    for (int i32 = 0; i32 < avg.len; i32++) {
      tmp31.data[i32] = avg.data[i32];
    }
    tmp31.data[avg.len] = divPoint(&tp.p, (double)(tp.n));
    tmp31.len = avg.len + 1;
    avg = tmp31;
    j = j + 1;
  }
  return avg;
}

point_list_t getAvgMidEdges(int points, int edgesFaces) {
  int numP = points.len;
  point_ex_list_t temp = {0, NULL};
  int i = 0;
  while (i < numP) {
    point_ex_list_t tmp33 = create_point_ex_list(temp.len + 1);
    for (int i34 = 0; i34 < temp.len; i34++) {
      tmp33.data[i34] = temp.data[i34];
    }
    tmp33.data[temp.len] =
        (point_ex_t){.p = (point_t){.x = 0.0, .y = 0.0, .z = 0.0}, .n = 0};
    tmp33.len = temp.len + 1;
    temp = tmp33;
    i = i + 1;
  }
  for (int tmp35 = 0; tmp35 < edgesFaces.len; tmp35++) {
    edge_t edge = edgesFaces.data[tmp35];
    point_t cp = edge.cp;
    list_int arr = list_int_create(2);
    arr.data[0] = edge.pn1;
    arr.data[1] = edge.pn2;
    for (int tmp36 = 0; tmp36 < 2; tmp36++) {
      int pn = arr.data[tmp36];
      point_ex_t tp = temp.data[pn];
      temp.data[pn] = (point_ex_t){.p = sumPoint(&tp.p, &cp), .n = tp.n + 1};
    }
  }
  point_list_t avg = {0, NULL};
  int j = 0;
  while (j < numP) {
    point_ex_t tp = temp.data[j];
    point_list_t tmp37 = create_point_list(avg.len + 1);
    for (int i38 = 0; i38 < avg.len; i38++) {
      tmp37.data[i38] = avg.data[i38];
    }
    tmp37.data[avg.len] = divPoint(&tp.p, (double)(tp.n));
    tmp37.len = avg.len + 1;
    avg = tmp37;
    j = j + 1;
  }
  return avg;
}

list_int getPointsFaces(int points, list_list_int faces) {
  list_int pf = list_int_create(0);
  int i = 0;
  while (i < points.len) {
    int tmp39_data[1];
    list_int tmp39 = {1, tmp39_data};
    tmp39.data[0] = 0;
    list_int tmp40 = concat_list_int(pf, tmp39);
    pf = tmp40;
    i = i + 1;
  }
  int fnum = 0;
  while (fnum < faces.len) {
    for (int tmp41 = 0; tmp41 < faces.data[fnum].len; tmp41++) {
      int pn = faces.data[fnum].data[tmp41];
      pf.data[pn] = pf.data[pn] + 1;
    }
    fnum = fnum + 1;
  }
  return pf;
}

point_list_t getNewPoints(int points, list_int pf, int afp, int ame) {
  point_list_t newPts = {0, NULL};
  int i = 0;
  while (i < points.len) {
    double n = (double)(pf.data[i]);
    double m1 = (n - 3.0) / n;
    double m2 = 1.0 / n;
    double m3 = 2.0 / n;
    point_t old = points.data[i];
    point_t p1 = mulPoint(&old, m1);
    point_t p2 = mulPoint(&afp.data[i], m2);
    point_t p3 = mulPoint(&ame.data[i], m3);
    point_list_t tmp42 = create_point_list(newPts.len + 1);
    for (int i43 = 0; i43 < newPts.len; i43++) {
      tmp42.data[i43] = newPts.data[i43];
    }
    tmp42.data[newPts.len] = sumPoint(&sumPoint(&p1, &p2), &p3);
    tmp42.len = newPts.len + 1;
    newPts = tmp42;
    i = i + 1;
  }
  return newPts;
}

char *key(int a, int b) {
  if (a < b) {
    char *tmp44 = _str(a);
    char *tmp45 = concat_string(tmp44, ",");
    char *tmp46 = _str(b);
    char *tmp47 = concat_string(tmp45, tmp46);
    return tmp47;
  }
  char *tmp48 = _str(b);
  char *tmp49 = concat_string(tmp48, ",");
  char *tmp50 = _str(a);
  char *tmp51 = concat_string(tmp49, tmp50);
  return tmp51;
}

list_int cmcSubdiv(int points, list_list_int faces) {
  point_list_t facePoints = getFacePoints(points, faces);
  edge_list_t edgesFaces = getEdgesFaces(points, faces);
  point_list_t edgePoints = getEdgePoints(points, edgesFaces, facePoints);
  point_list_t avgFacePoints = getAvgFacePoints(points, faces, facePoints);
  point_list_t avgMidEdges = getAvgMidEdges(points, edgesFaces);
  list_int pointsFaces = getPointsFaces(points, faces);
  point_list_t newPoints =
      getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges);
  list_int facePointNums = list_int_create(0);
  int nextPoint = newPoints.len;
  for (int tmp52 = 0; tmp52 < facePoints.len; tmp52++) {
    point_t fp = facePoints.data[tmp52];
    point_list_t tmp53 = create_point_list(newPoints.len + 1);
    for (int i54 = 0; i54 < newPoints.len; i54++) {
      tmp53.data[i54] = newPoints.data[i54];
    }
    tmp53.data[newPoints.len] = fp;
    tmp53.len = newPoints.len + 1;
    newPoints = tmp53;
    int tmp55_data[1];
    list_int tmp55 = {1, tmp55_data};
    tmp55.data[0] = nextPoint;
    list_int tmp56 = concat_list_int(facePointNums, tmp55);
    facePointNums = tmp56;
    nextPoint = nextPoint + 1;
  }
  map_string_int tmp57 = map_string_int_create(0);
  map_string_int edgePointNums = tmp57;
  int idx = 0;
  while (idx < edgesFaces.len) {
    edge_t e = edgesFaces.data[idx];
    point_list_t tmp58 = create_point_list(newPoints.len + 1);
    for (int i59 = 0; i59 < newPoints.len; i59++) {
      tmp58.data[i59] = newPoints.data[i59];
    }
    tmp58.data[newPoints.len] = edgePoints.data[idx];
    tmp58.len = newPoints.len + 1;
    newPoints = tmp58;
    map_string_int_put(&edgePointNums, key(e.pn1, e.pn2), nextPoint);
    nextPoint = nextPoint + 1;
    idx = idx + 1;
  }
  list_list_int newFaces = {0, NULL};
  int fnum = 0;
  while (fnum < faces.len) {
    list_int oldFace = faces.data[fnum];
    if (oldFace.len == 4) {
      int a = oldFace.data[0];
      int b = oldFace.data[1];
      int c = oldFace.data[2];
      int d = oldFace.data[3];
      int fpnum = facePointNums.data[fnum];
      int ab = map_string_int_get(edgePointNums, key(a, b));
      int da = map_string_int_get(edgePointNums, key(d, a));
      int bc = map_string_int_get(edgePointNums, key(b, c));
      int cd = map_string_int_get(edgePointNums, key(c, d));
      list_int tmp60 = list_int_create(4);
      tmp60.data[0] = a;
      tmp60.data[1] = ab;
      tmp60.data[2] = fpnum;
      tmp60.data[3] = da;
      list_list_int tmp61 = list_list_int_create(1);
      tmp61.data[0] = tmp60;
      list_list_int tmp62 = concat_list_list_int(newFaces, tmp61);
      newFaces = tmp62;
      list_int tmp63 = list_int_create(4);
      tmp63.data[0] = b;
      tmp63.data[1] = bc;
      tmp63.data[2] = fpnum;
      tmp63.data[3] = ab;
      list_list_int tmp64 = list_list_int_create(1);
      tmp64.data[0] = tmp63;
      list_list_int tmp65 = concat_list_list_int(newFaces, tmp64);
      newFaces = tmp65;
      list_int tmp66 = list_int_create(4);
      tmp66.data[0] = c;
      tmp66.data[1] = cd;
      tmp66.data[2] = fpnum;
      tmp66.data[3] = bc;
      list_list_int tmp67 = list_list_int_create(1);
      tmp67.data[0] = tmp66;
      list_list_int tmp68 = concat_list_list_int(newFaces, tmp67);
      newFaces = tmp68;
      list_int tmp69 = list_int_create(4);
      tmp69.data[0] = d;
      tmp69.data[1] = da;
      tmp69.data[2] = fpnum;
      tmp69.data[3] = cd;
      list_list_int tmp70 = list_list_int_create(1);
      tmp70.data[0] = tmp69;
      list_list_int tmp71 = concat_list_list_int(newFaces, tmp70);
      newFaces = tmp71;
    }
    fnum = fnum + 1;
  }
  list_int tmp72 = list_int_create(2);
  tmp72.data[0] = newPoints;
  tmp72.data[1] = newFaces;
  return tmp72;
}

char *formatPoint(point_t *p) {
  return "[" + fmt4(p->x) + " " + fmt4(p->y) + " " + fmt4(p->z) + "]";
}

char *formatFace(list_int f) {
  if (f.len == 0) {
    return "[]";
  }
  char *s = "[" + fmt2(f.data[0]);
  int i = 1;
  while (i < f.len) {
    char *tmp73 = concat_string(s, " ");
    s = tmp73 + fmt2(f.data[i]);
    i = i + 1;
  }
  char *tmp74 = concat_string(s, "]");
  s = tmp74;
  return s;
}

int mochi_main() {
  point_t inputPoints[] = {(point_t){.x = (-1.0), .y = 1.0, .z = 1.0},
                           (point_t){.x = (-1.0), .y = (-1.0), .z = 1.0},
                           (point_t){.x = 1.0, .y = (-1.0), .z = 1.0},
                           (point_t){.x = 1.0, .y = 1.0, .z = 1.0},
                           (point_t){.x = 1.0, .y = (-1.0), .z = (-1.0)},
                           (point_t){.x = 1.0, .y = 1.0, .z = (-1.0)},
                           (point_t){.x = (-1.0), .y = (-1.0), .z = (-1.0)},
                           (point_t){.x = (-1.0), .y = 1.0, .z = (-1.0)}};
  int inputPoints_len = sizeof(inputPoints) / sizeof(inputPoints[0]);
  list_int tmp75 = list_int_create(4);
  tmp75.data[0] = 0;
  tmp75.data[1] = 1;
  tmp75.data[2] = 2;
  tmp75.data[3] = 3;
  list_int tmp76 = list_int_create(4);
  tmp76.data[0] = 3;
  tmp76.data[1] = 2;
  tmp76.data[2] = 4;
  tmp76.data[3] = 5;
  list_int tmp77 = list_int_create(4);
  tmp77.data[0] = 5;
  tmp77.data[1] = 4;
  tmp77.data[2] = 6;
  tmp77.data[3] = 7;
  list_int tmp78 = list_int_create(4);
  tmp78.data[0] = 7;
  tmp78.data[1] = 0;
  tmp78.data[2] = 3;
  tmp78.data[3] = 5;
  list_int tmp79 = list_int_create(4);
  tmp79.data[0] = 7;
  tmp79.data[1] = 6;
  tmp79.data[2] = 1;
  tmp79.data[3] = 0;
  list_int tmp80 = list_int_create(4);
  tmp80.data[0] = 6;
  tmp80.data[1] = 1;
  tmp80.data[2] = 2;
  tmp80.data[3] = 4;
  list_int inputFaces_data[] = {tmp75, tmp76, tmp77, tmp78, tmp79, tmp80};
  list_list_int inputFaces = {6, inputFaces_data};
  point_list_t outputPoints = inputPoints;
  list_list_int outputFaces = inputFaces;
  int i = 0;
  while (i < 1) {
    list_int res = cmcSubdiv(outputPoints, outputFaces);
    outputPoints = res.data[0];
    outputFaces = res.data[1];
    i = i + 1;
  }
  for (int tmp81 = 0; tmp81 < outputPoints.len; tmp81++) {
    point_t p = outputPoints.data[tmp81];
    printf("%s\n", formatPoint(&p));
  }
  printf("\n");
  for (int tmp82 = 0; tmp82 < outputFaces.len; tmp82++) {
    list_int f = outputFaces.data[tmp82];
    printf("%s\n", formatFace(f));
  }
}

int _mochi_main() {
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
