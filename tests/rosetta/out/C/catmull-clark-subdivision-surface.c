// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:37:24Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  char *key;
  int value;
} pair_string_int;
static pair_string_int pair_string_int_new(char *key, int value) {
  pair_string_int p;
  p.key = key;
  p.value = value;
  return p;
}
typedef struct {
  int len;
  int cap;
  pair_string_int *data;
} map_string_int;
static map_string_int map_string_int_create(int cap) {
  map_string_int m;
  m.len = 0;
  m.cap = cap;
  m.data = cap ? calloc(cap, sizeof(pair_string_int)) : NULL;
  if (cap && !m.data) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return m;
}
static void map_string_int_put(map_string_int *m, char *k, int v) {
  for (int i = 0; i < m->len; i++)
    if (strcmp(m->data[i].key, k) == 0) {
      m->data[i].value = v;
      return;
    }
  if (m->len >= m->cap) {
    m->cap = m->cap ? m->cap * 2 : 4;
    m->data =
        (pair_string_int *)realloc(m->data, sizeof(pair_string_int) * m->cap);
  }
  m->data[m->len++] = pair_string_int_new(k, v);
}
static int map_string_int_get(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return m.data[i].value;
  return 0;
}
static int map_string_int_contains(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return 1;
  return 0;
}
static int cmp_map_string_int(map_string_int a, map_string_int b) {
  int aa = map_string_int_get(a, "a");
  int ba = map_string_int_get(b, "a");
  if (aa != ba)
    return aa > ba ? 1 : -1;
  int ab = map_string_int_get(a, "b");
  int bb = map_string_int_get(b, "b");
  if (ab != bb)
    return ab > bb ? 1 : -1;
  return 0;
}
static list_list_int concat_list_list_int(list_list_int a, list_list_int b) {
  list_list_int r = list_list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static int index_of_string(char *s, char *sub) {
  char *pos = strstr(s, sub);
  if (!pos)
    return -1;
  return pos - s;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
typedef struct Point Point;
typedef struct Edge Edge;
typedef struct PointEx PointEx;

typedef struct {
  double x;
  double y;
  double z;
  double x;
  double y;
  double z;
} point_t;

typedef struct Point {
  double x;
  double y;
  double z;
} Point;
typedef struct {
  int len;
  point_t *data;
} point_list_t;
point_list_t create_point_list(int len) {
  point_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(point_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct Edge {
  int pn1;
  int pn2;
  int fn1;
  int fn2;
  Point cp;
} Edge;
typedef struct {
  int len;
  edge_t *data;
} edge_list_t;
edge_list_t create_edge_list(int len) {
  edge_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(edge_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct PointEx {
  Point p;
  int n;
} PointEx;
typedef struct {
  int len;
  point_ex_t *data;
} point_ex_list_t;
point_ex_list_t create_point_ex_list(int len) {
  point_ex_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(point_ex_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int indexOf(char *s, char *ch) {
  int i = 0;
  while (i < strlen(s)) {
    if ((slice_string(s, i, i + 1) == ch)) {
      return i;
    }
    i = i + 1;
  }
  return (-1);
}

const char *fmt4(double x) {
  double y = x * 10000.0;
  if (y >= 0) {
    y = y + 0.5;
  } else {
    y = y - 0.5;
  }
  y = (double)(((int)(y))) / 10000.0;
  char *tmp1 = _str(y);
  const char *s = tmp1;
  int dot = index_of_string(s, ".");
  if (dot == 0 - 1) {
    char *tmp2 = concat_string(s, ".0000");
    s = tmp2;
  } else {
    int decs = strlen(s) - dot - 1;
    if (decs > 4) {
      s = slice_string(s, 0, dot + 5);
    } else {
      while (decs < 4) {
        char *tmp3 = concat_string(s, "0");
        s = tmp3;
        decs = decs + 1;
      }
    }
  }
  if (x >= 0.0) {
    char *tmp4 = concat_string(" ", s);
    s = tmp4;
  }
  return s;
}

const char *fmt2(int n) {
  char *tmp5 = _str(n);
  const char *s = tmp5;
  if (strlen(s) < 2) {
    char *tmp6 = concat_string(" ", s);
    return tmp6;
  }
  return s;
}

point_t sumPoint(Point *p1, Point *p2) {
  return (Point){.x = p1->x + p2->x, .y = p1->y + p2->y, .z = p1->z + p2->z};
}

point_t mulPoint(Point *p, double m) {
  return (Point){.x = p->x * m, .y = p->y * m, .z = p->z * m};
}

point_t divPoint(Point *p, double d) { return mulPoint(&p, 1.0 / d); }

point_t centerPoint(Point *p1, Point *p2) {
  return divPoint(&sumPoint(&p1, &p2), 2.0);
}

point_list_t getFacePoints(int points, list_list_int faces) {
  list_int tmp7 = list_int_create(0);
  point_list_t facePoints = tmp7;
  int i = 0;
  while (i < faces.len) {
    list_int face = faces.data[i];
    point_t fp = (Point){.x = 0.0, .y = 0.0, .z = 0.0};
    for (int tmp8 = 0; tmp8 < face.len; tmp8++) {
      int idx = face.data[tmp8];
      fp = sumPoint(&fp, &points.data[idx]);
    }
    fp = divPoint(&fp, ((double)(face.len)));
    facePoints = 0;
    i = i + 1;
  }
  return facePoints;
}

list_list_int sortEdges(list_list_int edges) {
  list_list_int tmp9 = {0, NULL};
  list_list_int res = tmp9;
  list_list_int tmp = edges;
  while (tmp.len > 0) {
    list_int min = tmp.data[0];
    int idx = 0;
    int j = 1;
    while (j < tmp.len) {
      list_int e = tmp.data[j];
      if ((e.data[0] < min.data[0] ||
           (e.data[0] == min.data[0] &&
            (e.data[1] < min.data[1] ||
             (e.data[1] == min.data[1] && e.data[2] < min.data[2]))))) {
        min = e;
        idx = j;
      }
      j = j + 1;
    }
    list_list_int tmp10 = list_list_int_create(1);
    tmp10.data[0] = min;
    list_list_int tmp11 = concat_list_list_int(res, tmp10);
    res = tmp11;
    list_list_int tmp12 = {0, NULL};
    list_list_int out = tmp12;
    int k = 0;
    while (k < tmp.len) {
      if (k != idx) {
        list_list_int tmp13 = list_list_int_create(1);
        tmp13.data[0] = tmp.data[k];
        list_list_int tmp14 = concat_list_list_int(out, tmp13);
        out = tmp14;
      }
      k = k + 1;
    }
    tmp = out;
  }
  return res;
}

edge_list_t getEdgesFaces(int points, list_list_int faces) {
  list_list_int tmp15 = {0, NULL};
  list_list_int edges = tmp15;
  int fnum = 0;
  while (fnum < faces.len) {
    list_int face = faces.data[fnum];
    int numP = face.len;
    int pi = 0;
    while (pi < numP) {
      int pn1 = face.data[pi];
      int pn2 = 0;
      if (pi < numP - 1) {
        pn2 = face.data[pi + 1];
      } else {
        pn2 = face.data[0];
      }
      if (pn1 > pn2) {
        int tmpn = pn1;
        pn1 = pn2;
        pn2 = tmpn;
      }
      list_int tmp16 = list_int_create(3);
      tmp16.data[0] = pn1;
      tmp16.data[1] = pn2;
      tmp16.data[2] = fnum;
      list_list_int tmp17 = list_list_int_create(1);
      tmp17.data[0] = tmp16;
      list_list_int tmp18 = concat_list_list_int(edges, tmp17);
      edges = tmp18;
      pi = pi + 1;
    }
    fnum = fnum + 1;
  }
  edges = sortEdges(edges);
  list_list_int tmp19 = {0, NULL};
  list_list_int merged = tmp19;
  int idx = 0;
  while (idx < edges.len) {
    list_int e1 = edges.data[idx];
    if (idx < edges.len - 1) {
      list_int e2 = edges.data[idx + 1];
      if (e1.data[0] == e2.data[0] && e1.data[1] == e2.data[1]) {
        list_int tmp20 = list_int_create(4);
        tmp20.data[0] = e1.data[0];
        tmp20.data[1] = e1.data[1];
        tmp20.data[2] = e1.data[2];
        tmp20.data[3] = e2.data[2];
        list_list_int tmp21 = list_list_int_create(1);
        tmp21.data[0] = tmp20;
        list_list_int tmp22 = concat_list_list_int(merged, tmp21);
        merged = tmp22;
        idx = idx + 2;
        continue;
      }
    }
    list_int tmp23 = list_int_create(4);
    tmp23.data[0] = e1.data[0];
    tmp23.data[1] = e1.data[1];
    tmp23.data[2] = e1.data[2];
    tmp23.data[3] = (-1);
    list_list_int tmp24 = list_list_int_create(1);
    tmp24.data[0] = tmp23;
    list_list_int tmp25 = concat_list_list_int(merged, tmp24);
    merged = tmp25;
    idx = idx + 1;
  }
  list_int tmp26 = list_int_create(0);
  edge_list_t edgesCenters = tmp26;
  for (int tmp27 = 0; tmp27 < merged.len; tmp27++) {
    list_int me = merged.data[tmp27];
    point_t p1 = points.data[me.data[0]];
    point_t p2 = points.data[me.data[1]];
    point_t cp = centerPoint(&p1, &p2);
    edgesCenters = 0;
  }
  return edgesCenters;
}

point_list_t getEdgePoints(int points, int edgesFaces, int facePoints) {
  list_int tmp28 = list_int_create(0);
  point_list_t edgePoints = tmp28;
  int i = 0;
  while (i < edgesFaces.len) {
    edge_t edge = edgesFaces.data[i];
    point_t cp = edge.cp;
    point_t fp1 = facePoints.data[edge.fn1];
    point_t fp2 = fp1;
    if (edge.fn2 != 0 - 1) {
      fp2 = facePoints.data[edge.fn2];
    }
    point_t cfp = centerPoint(&fp1, &fp2);
    edgePoints = 0;
    i = i + 1;
  }
  return edgePoints;
}

point_list_t getAvgFacePoints(int points, list_list_int faces, int facePoints) {
  int numP = points.len;
  list_int tmp29 = list_int_create(0);
  point_ex_list_t temp = tmp29;
  int i = 0;
  while (i < numP) {
    temp = 0;
    i = i + 1;
  }
  int fnum = 0;
  while (fnum < faces.len) {
    point_t fp = facePoints.data[fnum];
    for (int tmp30 = 0; tmp30 < faces.data[fnum].len; tmp30++) {
      int pn = faces.data[fnum].data[tmp30];
      point_ex_t tp = temp.data[pn];
      temp.data[pn] = (PointEx){.p = sumPoint(&tp.p, &fp), .n = tp.n + 1};
    }
    fnum = fnum + 1;
  }
  list_int tmp31 = list_int_create(0);
  point_list_t avg = tmp31;
  int j = 0;
  while (j < numP) {
    point_ex_t tp = temp.data[j];
    avg = 0;
    j = j + 1;
  }
  return avg;
}

point_list_t getAvgMidEdges(int points, int edgesFaces) {
  int numP = points.len;
  list_int tmp32 = list_int_create(0);
  point_ex_list_t temp = tmp32;
  int i = 0;
  while (i < numP) {
    temp = 0;
    i = i + 1;
  }
  for (int tmp33 = 0; tmp33 < edgesFaces.len; tmp33++) {
    edge_t edge = edgesFaces.data[tmp33];
    point_t cp = edge.cp;
    list_int arr = list_int_create(2);
    arr.data[0] = edge.pn1;
    arr.data[1] = edge.pn2;
    list_int arr = arr;
    for (int tmp34 = 0; tmp34 < 2; tmp34++) {
      int pn = arr[tmp34];
      point_ex_t tp = temp.data[pn];
      temp.data[pn] = (PointEx){.p = sumPoint(&tp.p, &cp), .n = tp.n + 1};
    }
  }
  list_int tmp35 = list_int_create(0);
  point_list_t avg = tmp35;
  int j = 0;
  while (j < numP) {
    point_ex_t tp = temp.data[j];
    avg = 0;
    j = j + 1;
  }
  return avg;
}

list_int getPointsFaces(int points, list_list_int faces) {
  list_int pf = list_int_create(0);
  int i = 0;
  while (i < points.len) {
    list_int tmp36 = list_int_create(1);
    tmp36.data[0] = 0;
    pf = tmp36;
    i = i + 1;
  }
  int fnum = 0;
  while (fnum < faces.len) {
    for (int tmp37 = 0; tmp37 < faces.data[fnum].len; tmp37++) {
      int pn = faces.data[fnum].data[tmp37];
      pf[pn] = pf.data[pn] + 1;
    }
    fnum = fnum + 1;
  }
  list_int tmp38 = list_int_create(0);
  return tmp38;
}

point_list_t getNewPoints(int points, list_int pf, int afp, int ame) {
  list_int tmp39 = list_int_create(0);
  point_list_t newPts = tmp39;
  int i = 0;
  while (i < points.len) {
    double n = (double)(pf.data[i]);
    double m1 = (n - 3.0) / n;
    double m2 = 1.0 / n;
    double m3 = 2.0 / n;
    point_t old = points.data[i];
    point_t p1 = mulPoint(&old, m1);
    point_t p2 = mulPoint(&afp.data[i], m2);
    point_t p3 = mulPoint(&ame.data[i], m3);
    newPts = 0;
    i = i + 1;
  }
  return newPts;
}

const char *key(int a, int b) {
  if (a < b) {
    char *tmp40 = _str(a);
    char *tmp41 = concat_string(tmp40, ",");
    char *tmp42 = _str(b);
    char *tmp43 = concat_string(tmp41, tmp42);
    return tmp43;
  }
  char *tmp44 = _str(b);
  char *tmp45 = concat_string(tmp44, ",");
  char *tmp46 = _str(a);
  char *tmp47 = concat_string(tmp45, tmp46);
  return tmp47;
}

list_int cmcSubdiv(int points, list_list_int faces) {
  point_list_t facePoints = getFacePoints(points, faces);
  edge_list_t edgesFaces = getEdgesFaces(points, faces);
  point_list_t edgePoints = getEdgePoints(points, edgesFaces, facePoints);
  point_list_t avgFacePoints = getAvgFacePoints(points, faces, facePoints);
  point_list_t avgMidEdges = getAvgMidEdges(points, edgesFaces);
  list_int pointsFaces = getPointsFaces(points, faces);
  point_list_t newPoints =
      getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges);
  list_int facePointNums = list_int_create(0);
  int nextPoint = newPoints.len;
  for (int tmp48 = 0; tmp48 < facePoints.len; tmp48++) {
    point_t fp = facePoints.data[tmp48];
    newPoints = 0;
    list_int tmp49 = list_int_create(0);
    facePointNums = 0;
    nextPoint = nextPoint + 1;
  }
  map_string_int tmp50 = map_string_int_create(0);
  map_string_int edgePointNums = tmp50;
  int idx = 0;
  while (idx < edgesFaces.len) {
    edge_t e = edgesFaces.data[idx];
    newPoints = 0;
    map_string_int_put(&edgePointNums, key(e.pn1, e.pn2), nextPoint);
    nextPoint = nextPoint + 1;
    idx = idx + 1;
  }
  list_list_int tmp51 = {0, NULL};
  list_list_int newFaces = tmp51;
  int fnum = 0;
  while (fnum < faces.len) {
    list_int oldFace = faces.data[fnum];
    if (oldFace.len == 4) {
      int a = oldFace.data[0];
      int b = oldFace.data[1];
      int c = oldFace.data[2];
      int d = oldFace.data[3];
      int fpnum = facePointNums.data[fnum];
      int ab = map_string_int_get(edgePointNums, key(a, b));
      int da = map_string_int_get(edgePointNums, key(d, a));
      int bc = map_string_int_get(edgePointNums, key(b, c));
      int cd = map_string_int_get(edgePointNums, key(c, d));
      list_int tmp52 = list_int_create(4);
      tmp52.data[0] = a;
      tmp52.data[1] = ab;
      tmp52.data[2] = fpnum;
      tmp52.data[3] = da;
      list_list_int tmp53 = list_list_int_create(1);
      tmp53.data[0] = tmp52;
      list_list_int tmp54 = concat_list_list_int(newFaces, tmp53);
      newFaces = tmp54;
      list_int tmp55 = list_int_create(4);
      tmp55.data[0] = b;
      tmp55.data[1] = bc;
      tmp55.data[2] = fpnum;
      tmp55.data[3] = ab;
      list_list_int tmp56 = list_list_int_create(1);
      tmp56.data[0] = tmp55;
      list_list_int tmp57 = concat_list_list_int(newFaces, tmp56);
      newFaces = tmp57;
      list_int tmp58 = list_int_create(4);
      tmp58.data[0] = c;
      tmp58.data[1] = cd;
      tmp58.data[2] = fpnum;
      tmp58.data[3] = bc;
      list_list_int tmp59 = list_list_int_create(1);
      tmp59.data[0] = tmp58;
      list_list_int tmp60 = concat_list_list_int(newFaces, tmp59);
      newFaces = tmp60;
      list_int tmp61 = list_int_create(4);
      tmp61.data[0] = d;
      tmp61.data[1] = da;
      tmp61.data[2] = fpnum;
      tmp61.data[3] = cd;
      list_list_int tmp62 = list_list_int_create(1);
      tmp62.data[0] = tmp61;
      list_list_int tmp63 = concat_list_list_int(newFaces, tmp62);
      newFaces = tmp63;
    }
    fnum = fnum + 1;
  }
  list_int tmp64 = list_int_create(2);
  tmp64.data[0] = newPoints;
  tmp64.data[1] = newFaces;
  return tmp64;
}

const char *formatPoint(Point *p) {
  return "[" + fmt4(p->x) + " " + fmt4(p->y) + " " + fmt4(p->z) + "]";
}

const char *formatFace(list_int f) {
  if (f.len == 0) {
    return "[]";
  }
  const char *s = "[" + fmt2(f.data[0]);
  int i = 1;
  while (i < f.len) {
    char *tmp65 = concat_string(s, " ");
    s = tmp65 + fmt2(f.data[i]);
    i = i + 1;
  }
  char *tmp66 = concat_string(s, "]");
  s = tmp66;
  return s;
}

int main() {
  point_t inputPoints[] = {(Point){.x = (-1.0), .y = 1.0, .z = 1.0},
                           (Point){.x = (-1.0), .y = (-1.0), .z = 1.0},
                           (Point){.x = 1.0, .y = (-1.0), .z = 1.0},
                           (Point){.x = 1.0, .y = 1.0, .z = 1.0},
                           (Point){.x = 1.0, .y = (-1.0), .z = (-1.0)},
                           (Point){.x = 1.0, .y = 1.0, .z = (-1.0)},
                           (Point){.x = (-1.0), .y = (-1.0), .z = (-1.0)},
                           (Point){.x = (-1.0), .y = 1.0, .z = (-1.0)}};
  int inputPoints_len = sizeof(inputPoints) / sizeof(inputPoints[0]);
  list_int tmp67 = list_int_create(4);
  tmp67.data[0] = 0;
  tmp67.data[1] = 1;
  tmp67.data[2] = 2;
  tmp67.data[3] = 3;
  list_int tmp68 = list_int_create(4);
  tmp68.data[0] = 3;
  tmp68.data[1] = 2;
  tmp68.data[2] = 4;
  tmp68.data[3] = 5;
  list_int tmp69 = list_int_create(4);
  tmp69.data[0] = 5;
  tmp69.data[1] = 4;
  tmp69.data[2] = 6;
  tmp69.data[3] = 7;
  list_int tmp70 = list_int_create(4);
  tmp70.data[0] = 7;
  tmp70.data[1] = 0;
  tmp70.data[2] = 3;
  tmp70.data[3] = 5;
  list_int tmp71 = list_int_create(4);
  tmp71.data[0] = 7;
  tmp71.data[1] = 6;
  tmp71.data[2] = 1;
  tmp71.data[3] = 0;
  list_int tmp72 = list_int_create(4);
  tmp72.data[0] = 6;
  tmp72.data[1] = 1;
  tmp72.data[2] = 2;
  tmp72.data[3] = 4;
  list_int inputFaces_data[] = {{4, tmp67}, {4, tmp68}, {4, tmp69},
                                {4, tmp70}, {4, tmp71}, {4, tmp72}};
  list_list_int inputFaces = {6, inputFaces_data};
  list_list_int inputFaces = inputFaces;
  point_list_t outputPoints = inputPoints;
  list_list_int outputFaces = inputFaces;
  int i = 0;
  while (i < 1) {
    list_int res = cmcSubdiv(outputPoints, outputFaces);
    outputPoints = res.data[0];
    outputFaces = res.data[1];
    i = i + 1;
  }
  for (int tmp73 = 0; tmp73 < outputPoints.len; tmp73++) {
    point_t p = outputPoints.data[tmp73];
    printf("%s\n", formatPoint(&p));
  }
  printf("\n");
  for (int tmp74 = 0; tmp74 < outputFaces.len; tmp74++) {
    list_int f = outputFaces.data[tmp74];
    printf("%s\n", formatFace(f));
  }
}

int main() {
  main();
  return 0;
}
