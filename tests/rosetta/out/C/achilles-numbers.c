// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:58:40Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:58:40Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int key;
  int value;
} map_int_bool_item;
static map_int_bool_item *map_int_bool_item_new(int key, int value) {
  map_int_bool_item *it = calloc(1, sizeof(map_int_bool_item));
  if (!it) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  it->key = key;
  it->value = value;
  return it;
}
typedef struct {
  int len;
  int cap;
  map_int_bool_item **data;
} map_int_bool;
static map_int_bool map_int_bool_create(int cap) {
  map_int_bool m;
  m.len = 0;
  m.cap = cap;
  m.data = cap ? calloc(cap, sizeof(map_int_bool_item *)) : NULL;
  if (cap && !m.data) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return m;
}
static void map_int_bool_put(map_int_bool *m, int key, int value) {
  for (int i = 0; i < m->len; i++)
    if (m->data[i]->key == key) {
      m->data[i]->value = value;
      return;
    }
  if (m->len >= m->cap) {
    m->cap = m->cap ? m->cap * 2 : 4;
    m->data = (map_int_bool_item **)realloc(
        m->data, sizeof(map_int_bool_item *) * m->cap);
  }
  m->data[m->len++] = map_int_bool_item_new(key, value);
}
static int map_int_bool_contains(map_int_bool m, int key) {
  for (int i = 0; i < m.len; i++)
    if (m.data[i]->key == key)
      return 1;
  return 0;
}
typedef struct {
  char *key;
  int value;
} pair_string_int;
static pair_string_int pair_string_int_new(char *key, int value) {
  pair_string_int p;
  p.key = key;
  p.value = value;
  return p;
}
typedef struct {
  int len;
  int cap;
  pair_string_int *data;
} map_string_int;
static map_string_int map_string_int_create(int cap) {
  map_string_int m;
  m.len = 0;
  m.cap = cap;
  m.data = cap ? calloc(cap, sizeof(pair_string_int)) : NULL;
  if (cap && !m.data) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return m;
}
static void map_string_int_put(map_string_int *m, char *k, int v) {
  for (int i = 0; i < m->len; i++)
    if (strcmp(m->data[i].key, k) == 0) {
      m->data[i].value = v;
      return;
    }
  if (m->len >= m->cap) {
    m->cap = m->cap ? m->cap * 2 : 4;
    m->data =
        (pair_string_int *)realloc(m->data, sizeof(pair_string_int) * m->cap);
  }
  m->data[m->len++] = pair_string_int_new(k, v);
}
static int map_string_int_get(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return m.data[i].value;
  return 0;
}
static int map_string_int_contains(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return 1;
  return 0;
}
static int cmp_map_string_int(map_string_int a, map_string_int b) {
  int aa = map_string_int_get(a, "a");
  int ba = map_string_int_get(b, "a");
  if (aa != ba)
    return aa > ba ? 1 : -1;
  int ab = map_string_int_get(a, "b");
  int bb = map_string_int_get(b, "b");
  if (ab != bb)
    return ab > bb ? 1 : -1;
  return 0;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
int pow10(int exp) {
  int n = 1;
  int i = 0;
  while (i < exp) {
    n = n * 10;
    i = i + 1;
  }
  return n;
}

int totient(int n) {
  int tot = n;
  int nn = n;
  int i = 2;
  while (i * i <= nn) {
    if (nn % i == 0) {
      while (nn % i == 0) {
        nn = ((double)nn) / ((double)i);
      }
      tot = ((double)tot - tot) / ((double)i);
    }
    if (i == 2) {
      i = 1;
    }
    i = i + 2;
  }
  if (nn > 1) {
    tot = ((double)tot - tot) / ((double)nn);
  }
  return tot;
}

int getPerfectPowers(int maxExp) {
  int upper = pow10(maxExp);
  int i = 2;
  while ((i * i < upper)) {
    int p = i * i;
    while (1) {
      p = p * i;
      if ((p >= upper)) {
        break;
      }
      map_int_bool_put(&pps, p, 1);
    }
    i = i + 1;
  }
}

map_int_bool getAchilles(int minExp, int maxExp) {
  int lower = pow10(minExp);
  int upper = pow10(maxExp);
  map_string_int tmp1 = map_string_int_create(0);
  map_int_bool achilles = tmp1;
  int b = 1;
  while ((b * b * b < upper)) {
    int b3 = b * b * b;
    int a = 1;
    while (1) {
      int p = b3 * a * a;
      if ((p >= upper)) {
        break;
      }
      if ((p >= lower)) {
        if ((!(map_int_bool_contains(pps, p)))) {
          map_int_bool_put(&achilles, p, 1);
        }
      }
      a = a + 1;
    }
    b = b + 1;
  }
  return achilles;
}

list_int sortInts(list_int xs) {
  list_int res = list_int_create(0);
  list_int tmp = xs;
  while (tmp.len > 0) {
    int min = tmp.data[0];
    int idx = 0;
    int i = 1;
    while (i < tmp.len) {
      if ((tmp.data[i] < min)) {
        min = tmp.data[i];
        idx = i;
      }
      i = i + 1;
    }
    list_int tmp2 = list_int_create(1);
    tmp2.data[0] = min;
    res = res + tmp2;
    list_int out = list_int_create(0);
    int j = 0;
    while (j < tmp.len) {
      if (j != idx) {
        list_int tmp3 = list_int_create(1);
        tmp3.data[0] = tmp.data[j];
        out = out + tmp3;
      }
      j = j + 1;
    }
    list_int tmp4 = list_int_create(0);
    tmp = tmp4;
  }
  list_int tmp5 = list_int_create(0);
  return tmp5;
}

char *pad(int n, int width) {
  char *tmp6 = _str(n);
  char *s = tmp6;
  while (strlen(s) < width) {
    char *tmp7 = concat_string(" ", s);
    s = tmp7;
  }
  return s;
}

int mochi_main() {
  int maxDigits = 15;
  getPerfectPowers(maxDigits);
  map_int_bool achSet = getAchilles(1, 5);
  list_int ach = list_int_create(0);
  for (int tmp8 = 0; tmp8 < achSet.keys().len; tmp8++) {
    int k = achSet.keys().data[tmp8];
    list_int tmp9 = list_int_create(1);
    tmp9.data[0] = k;
    ach = ach + tmp9;
  }
  list_int tmp10 = list_int_create(0);
  ach = sortInts(tmp10);
  printf("First 50 Achilles numbers:\n");
  int i = 0;
  while (i < 50) {
    char *line = "";
    int j = 0;
    while (j < 10) {
      line = line + pad(ach.data[i], 4);
      if (j < 9) {
        char *tmp11 = concat_string(line, " ");
        line = tmp11;
      }
      i = i + 1;
      j = j + 1;
    }
    printf("%s\n", line);
  }
  printf("\\nFirst 30 strong Achilles numbers:\n");
  list_int strong = list_int_create(0);
  int count = 0;
  int idx = 0;
  while ((count < 30)) {
    int tot = totient(ach.data[idx]);
    if ((map_int_bool_contains(achSet, tot))) {
      list_int tmp12 = list_int_create(1);
      tmp12.data[0] = ach.data[idx];
      strong = strong + tmp12;
      count = count + 1;
    }
    idx = idx + 1;
  }
  i = 0;
  while (i < 30) {
    char *line = "";
    int j = 0;
    while (j < 10) {
      line = line + pad(strong.data[i], 5);
      if (j < 9) {
        char *tmp13 = concat_string(line, " ");
        line = tmp13;
      }
      i = i + 1;
      j = j + 1;
    }
    printf("%s\n", line);
  }
  printf("\\nNumber of Achilles numbers with:\n");
  list_int counts = list_int_create(14);
  counts.data[0] = 1;
  counts.data[1] = 12;
  counts.data[2] = 47;
  counts.data[3] = 192;
  counts.data[4] = 664;
  counts.data[5] = 2242;
  counts.data[6] = 7395;
  counts.data[7] = 24008;
  counts.data[8] = 77330;
  counts.data[9] = 247449;
  counts.data[10] = 788855;
  counts.data[11] = 2508051;
  counts.data[12] = 7960336;
  counts.data[13] = 25235383;
  int d = 2;
  while (d <= maxDigits) {
    int c = counts.data[d - 2];
    char *tmp14 = _str(c);
    printf("%s\n", pad(d, 2) + " digits: " + tmp14);
    d = d + 1;
  }
}

int _mochi_main() {
  map_string_int tmp15 = map_string_int_create(0);
  map_int_bool pps = tmp15;
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
