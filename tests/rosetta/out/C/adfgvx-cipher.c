// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:40Z
// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:40Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static list_string concat_list_string(list_string a, list_string b) {
  list_string r = list_string_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static long long _now() {
  struct timespec ts;
  clock_gettime(CLOCK_REALTIME, &ts);
  return (long long)ts.tv_sec * 1000000000LL + ts.tv_nsec;
}
static char *_index_string(char *s, int i) {
  int len = strlen(s);
  if (i < 0)
    i += len;
  if (i < 0 || i >= len) {
    fprintf(stderr, "index out of range\n");
    exit(1);
  }
  char *buf = (char *)malloc(2);
  buf[0] = s[i];
  buf[1] = '\0';
  return buf;
}
static int index_of_string(char *s, char *sub) {
  char *pos = strstr(s, sub);
  if (!pos)
    return -1;
  return pos - s;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static char *adfgvx = "ADFGVX";
static char *alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

const char *shuffleStr(char *s) {
  list_string tmp1 = {0, NULL};
  int arr = tmp1;
  int i = 0;
  while (i < strlen(s)) {
    char *tmp3 = _index_string(s, i);
    list_string tmp2 = list_string_create(1);
    tmp2.data[0] = tmp3;
    list_string tmp4 = concat_list_string(arr, tmp2);
    arr = tmp4;
    i = i + 1;
  }
  int j = arr.len - 1;
  while (j > 0) {
    long long k = _now() % (j + 1);
    const char *tmp = arr.data[j];
    arr.data[j] = arr.data[k];
    arr.data[k] = tmp;
    j = j - 1;
  }
  const char *out = "";
  i = 0;
  while (i < arr.len) {
    char *tmp5 = concat_string(out, arr.data[i]);
    out = tmp5;
    i = i + 1;
  }
  return out;
}

int createPolybius() {
  const char *shuffled = shuffleStr(alphabet);
  printf("6 x 6 Polybius square:\\n\n");
  printf("  | A D F G V X\n");
  printf("---------------\n");
  list_string tmp6 = {0, NULL};
  int p = tmp6;
  int i = 0;
  while (i < 6) {
    char *tmp7 = slice_string(shuffled, i * 6, (i + 1) * 6);
    const char *row = tmp7;
    list_string tmp8 = list_string_create(1);
    tmp8.data[0] = row;
    list_string tmp9 = concat_list_string(p, tmp8);
    p = tmp9;
    char *tmp10 = _index_string(adfgvx, i);
    char *tmp11 = concat_string(tmp10, " | ");
    const char *line = tmp11;
    int j = 0;
    while (j < 6) {
      char *tmp12 = _index_string(row, j);
      char *tmp13 = concat_string(line, tmp12);
      char *tmp14 = concat_string(tmp13, " ");
      line = tmp14;
      j = j + 1;
    }
    printf("%s\n", line);
    i = i + 1;
  }
  return p;
}

const char *createKey(int n) {
  if (n < 7 || n > 12) {
    printf("Key should be within 7 and 12 letters long.\n");
  }
  const char *pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  const char *key = "";
  int i = 0;
  while (i < n) {
    long long idx = _now() % strlen(pool);
    char *tmp15 = _index_string(pool, idx);
    char *tmp16 = concat_string(key, tmp15);
    key = tmp16;
    char *tmp17 = slice_string(pool, 0, idx);
    char *tmp18 = slice_string(pool, idx + 1, strlen(pool));
    char *tmp19 = concat_string(tmp17, tmp18);
    pool = tmp19;
    i = i + 1;
  }
  char *tmp20 = concat_string("\nThe key is ", key);
  printf("%s\n", tmp20);
  return key;
}

list_int orderKey(char *key) {
  list_int pairs = list_int_create(0);
  int i = 0;
  while (i < strlen(key)) {
    char *tmp23 = _index_string(key, i);
    list_string tmp22 = list_string_create(2);
    tmp22.data[0] = tmp23;
    tmp22.data[1] = i;
    list_int tmp21_data[] = {tmp22};
    list_list_int tmp21 = {1, tmp21_data};
    pairs = pairs + tmp21;
    i = i + 1;
  }
  int n = 0;
  int m = 0;
  while (m < n) {
    int j = 0;
    while (j < n - 1) {
      if ((pairs.data[j].data[0] > pairs.data[j + 1].data[0])) {
        int tmp = pairs.data[j];
        pairs[j] = pairs.data[j + 1];
        pairs[j + 1] = tmp;
      }
      j = j + 1;
    }
    m = m + 1;
  }
  list_int res = list_int_create(0);
  i = 0;
  while (i < n) {
    list_int tmp24 = list_int_create(1);
    tmp24.data[0] = (int)(pairs.data[i].data[1]);
    list_int tmp25 = concat_list_int(res, tmp24);
    res = tmp25;
    i = i + 1;
  }
  list_int tmp26 = list_int_create(0);
  return tmp26;
}

const char *encrypt(list_string polybius, char *key, char *plainText) {
  const char *temp = "";
  int i = 0;
  while (i < strlen(plainText)) {
    int r = 0;
    while (r < 6) {
      int c = 0;
      while (c < 6) {
        char *tmp27 = _index_string(polybius.data[r], c);
        char *tmp28 = _index_string(plainText, i);
        if ((strcmp(tmp27, tmp28) == 0)) {
          char *tmp29 = _index_string(adfgvx, r);
          char *tmp30 = concat_string(temp, tmp29);
          char *tmp31 = _index_string(adfgvx, c);
          char *tmp32 = concat_string(tmp30, tmp31);
          temp = tmp32;
        }
        c = c + 1;
      }
      r = r + 1;
    }
    i = i + 1;
  }
  double colLen = ((double)strlen(temp)) / ((double)strlen(key));
  if (strlen(temp) % strlen(key) > 0) {
    colLen = colLen + 1;
  }
  list_int tmp33 = list_int_create(0);
  list_int table = tmp33;
  int rIdx = 0;
  while (rIdx < colLen) {
    list_string tmp34 = {0, NULL};
    int row = tmp34;
    int j = 0;
    while (j < strlen(key)) {
      list_string tmp35 = list_string_create(1);
      tmp35.data[0] = "";
      list_string tmp36 = concat_list_string(row, tmp35);
      row = tmp36;
      j = j + 1;
    }
    list_int tmp37 = list_int_create(1);
    tmp37.data[0] = row;
    table = table + tmp37;
    rIdx = rIdx + 1;
  }
  int idx = 0;
  while (idx < strlen(temp)) {
    double row = ((double)idx) / ((double)strlen(key));
    int col = idx % strlen(key);
    char *tmp38 = slice_string(temp, idx, idx + 1);
    table.data[row].data[col] = tmp38;
    idx = idx + 1;
  }
  list_int order = orderKey(key);
  list_string tmp39 = {0, NULL};
  int cols = tmp39;
  int ci = 0;
  while (ci < strlen(key)) {
    const char *colStr = "";
    int ri = 0;
    while (ri < colLen) {
      colStr = colStr + table.data[ri].data[order.data[ci]];
      ri = ri + 1;
    }
    list_string tmp40 = list_string_create(1);
    tmp40.data[0] = colStr;
    list_string tmp41 = concat_list_string(cols, tmp40);
    cols = tmp41;
    ci = ci + 1;
  }
  const char *result = "";
  ci = 0;
  while (ci < cols.len) {
    char *tmp42 = concat_string(result, cols.data[ci]);
    result = tmp42;
    if (ci < cols.len - 1) {
      char *tmp43 = concat_string(result, " ");
      result = tmp43;
    }
    ci = ci + 1;
  }
  return result;
}

int indexOf(char *s, char *ch) {
  int i = 0;
  while (i < strlen(s)) {
    char *tmp44 = _index_string(s, i);
    if ((strcmp(tmp44, ch) == 0)) {
      return i;
    }
    i = i + 1;
  }
  return (-1);
}

const char *decrypt(list_string polybius, char *key, char *cipherText) {
  list_string tmp45 = {0, NULL};
  int colStrs = tmp45;
  int start = 0;
  int i = 0;
  while (i <= strlen(cipherText)) {
    char *tmp46 = _index_string(cipherText, i);
    if (i == strlen(cipherText) || tmp46 == " ") {
      char *tmp48 = slice_string(cipherText, start, i);
      list_string tmp47 = list_string_create(1);
      tmp47.data[0] = tmp48;
      list_string tmp49 = concat_list_string(colStrs, tmp47);
      colStrs = tmp49;
      start = i + 1;
    }
    i = i + 1;
  }
  int maxColLen = 0;
  i = 0;
  while (i < colStrs.len) {
    if (strlen(colStrs.data[i]) > maxColLen) {
      maxColLen = strlen(colStrs.data[i]);
    }
    i = i + 1;
  }
  list_int tmp50 = list_int_create(0);
  list_int cols = tmp50;
  i = 0;
  while (i < colStrs.len) {
    const char *s = colStrs.data[i];
    list_string tmp51 = {0, NULL};
    int ls = tmp51;
    int j = 0;
    while (j < strlen(s)) {
      char *tmp53 = _index_string(s, j);
      list_string tmp52 = list_string_create(1);
      tmp52.data[0] = tmp53;
      list_string tmp54 = concat_list_string(ls, tmp52);
      ls = tmp54;
      j = j + 1;
    }
    if (strlen(s) < maxColLen) {
      list_string tmp55 = {0, NULL};
      int pad = tmp55;
      int k = 0;
      while (k < maxColLen) {
        if (k < ls.len) {
          list_string tmp56 = list_string_create(1);
          tmp56.data[0] = ls.data[k];
          list_string tmp57 = concat_list_string(pad, tmp56);
          pad = tmp57;
        } else {
          list_string tmp58 = list_string_create(1);
          tmp58.data[0] = "";
          list_string tmp59 = concat_list_string(pad, tmp58);
          pad = tmp59;
        }
        k = k + 1;
      }
      list_int tmp60 = list_int_create(1);
      tmp60.data[0] = pad;
      cols = cols + tmp60;
    } else {
      list_int tmp61 = list_int_create(1);
      tmp61.data[0] = ls;
      cols = cols + tmp61;
    }
    i = i + 1;
  }
  list_int tmp62 = list_int_create(0);
  list_int table = tmp62;
  int r = 0;
  while (r < maxColLen) {
    list_string tmp63 = {0, NULL};
    int row = tmp63;
    int c = 0;
    while (c < strlen(key)) {
      list_string tmp64 = list_string_create(1);
      tmp64.data[0] = "";
      list_string tmp65 = concat_list_string(row, tmp64);
      row = tmp65;
      c = c + 1;
    }
    list_int tmp66 = list_int_create(1);
    tmp66.data[0] = row;
    table = table + tmp66;
    r = r + 1;
  }
  list_int order = orderKey(key);
  r = 0;
  while (r < maxColLen) {
    int c = 0;
    while (c < strlen(key)) {
      table.data[r].data[order.data[c]] = cols.data[c].data[r];
      c = c + 1;
    }
    r = r + 1;
  }
  const char *temp = "";
  r = 0;
  while (r < table.len) {
    int j = 0;
    while (j < table.data[r].len) {
      temp = temp + table.data[r].data[j];
      j = j + 1;
    }
    r = r + 1;
  }
  const char *plainText = "";
  int idx = 0;
  while (idx < strlen(temp)) {
    char *tmp67 = slice_string(temp, idx, idx + 1);
    int rIdx = index_of_string(adfgvx, tmp67);
    char *tmp68 = slice_string(temp, idx + 1, idx + 2);
    int cIdx = index_of_string(adfgvx, tmp68);
    char *tmp69 = _index_string(polybius.data[rIdx], cIdx);
    char *tmp70 = concat_string(plainText, tmp69);
    plainText = tmp70;
    idx = idx + 2;
  }
  return plainText;
}

int main() {
  const char *plainText = "ATTACKAT1200AM";
  int polybius = createPolybius();
  const char *key = createKey(9);
  char *tmp71 = concat_string("\nPlaintext : ", plainText);
  printf("%s\n", tmp71);
  const char *cipherText = encrypt(polybius, key, plainText);
  char *tmp72 = concat_string("\nEncrypted : ", cipherText);
  printf("%s\n", tmp72);
  const char *plainText2 = decrypt(polybius, key, cipherText);
  char *tmp73 = concat_string("\nDecrypted : ", plainText2);
  printf("%s\n", tmp73);
}

int main() {
  main();
  return 0;
}
