// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:23:46Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:23:46Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static list_string concat_list_string(list_string a, list_string b) {
  list_string r = list_string_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static long long _now() {
  struct timespec ts;
  clock_gettime(CLOCK_REALTIME, &ts);
  return (long long)ts.tv_sec * 1000000000LL + ts.tv_nsec;
}
static char *_index_string(char *s, int i) {
  int len = strlen(s);
  if (i < 0)
    i += len;
  if (i < 0 || i >= len) {
    fprintf(stderr, "index out of range\n");
    exit(1);
  }
  char *buf = (char *)malloc(2);
  buf[0] = s[i];
  buf[1] = '\0';
  return buf;
}
static int index_of_string(char *s, char *sub) {
  char *pos = strstr(s, sub);
  if (!pos)
    return -1;
  return pos - s;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static list_string slice_list_string(list_string v, int start, int end) {
  if (start < 0)
    start += v.len;
  if (end < 0)
    end += v.len;
  if (start < 0)
    start = 0;
  if (end > v.len)
    end = v.len;
  if (start > end)
    start = end;
  list_string r = list_string_create(end - start);
  for (int i = 0; i < r.len; i++)
    r.data[i] = v.data[start + i];
  return r;
}
static char *adfgvx = "ADFGVX";
static char *alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

char *shuffleStr(char *s) {
  list_string arr = list_string_create(0);
  int i = 0;
  while (i < strlen(s)) {
    char *tmp1 = slice_string(s, i, i + 1);
    list_string tmp2 = list_string_create(1);
    tmp2.data[0] = tmp1;
    list_string tmp3 = concat_list_string(arr, tmp2);
    arr = tmp3;
    i = i + 1;
  }
  int j = arr.len - 1;
  while (j > 0) {
    long long k = _now() % (j + 1);
    char *tmp = arr.data[j];
    arr.data[j] = arr.data[k];
    arr.data[k] = tmp;
    j = j - 1;
  }
  char *out = "";
  i = 0;
  while (i < arr.len) {
    char *tmp4 = concat_string(out, arr.data[i]);
    out = tmp4;
    i = i + 1;
  }
  return out;
}

list_string createPolybius() {
  char *shuffled = shuffleStr(alphabet);
  list_string labels = list_string_create(0);
  int li = 0;
  while (li < strlen(adfgvx)) {
    char *tmp5 = slice_string(adfgvx, li, li + 1);
    list_string tmp6 = list_string_create(1);
    tmp6.data[0] = tmp5;
    list_string tmp7 = concat_list_string(labels, tmp6);
    labels = tmp7;
    li = li + 1;
  }
  printf("6 x 6 Polybius square:\\n\n");
  printf("  | A D F G V X\n");
  printf("---------------\n");
  list_string p = list_string_create(0);
  int i = 0;
  while (i < 6) {
    char *tmp8 = slice_string(shuffled, i * 6, (i + 1) * 6);
    char *row = tmp8;
    list_string tmp9 = list_string_create(1);
    tmp9.data[0] = row;
    list_string tmp10 = concat_list_string(p, tmp9);
    p = tmp10;
    list_string tmp11 = slice_list_string(labels, i, i + 1);
    char *tmp12 = concat_string(tmp11, " | ");
    char *line = tmp12;
    int j = 0;
    while (j < 6) {
      char *tmp13 = slice_string(row, j, j + 1);
      char *tmp14 = concat_string(line, tmp13);
      char *tmp15 = concat_string(tmp14, " ");
      line = tmp15;
      j = j + 1;
    }
    printf("%s\n", line);
    i = i + 1;
  }
  return p;
}

char *createKey(int n) {
  if (n < 7 || n > 12) {
    printf("Key should be within 7 and 12 letters long.\n");
  }
  char *pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  char *key = "";
  int i = 0;
  while (i < n) {
    long long idx = _now() % strlen(pool);
    char *tmp16 = _index_string(pool, idx);
    char *tmp17 = concat_string(key, tmp16);
    key = tmp17;
    char *tmp18 = slice_string(pool, 0, idx);
    char *tmp19 = slice_string(pool, idx + 1, strlen(pool));
    char *tmp20 = concat_string(tmp18, tmp19);
    pool = tmp20;
    i = i + 1;
  }
  char *tmp21 = concat_string("\nThe key is ", key);
  printf("%s\n", tmp21);
  return key;
}

list_int orderKey(char *key) {
  list_int pairs = list_int_create(0);
  int i = 0;
  while (i < strlen(key)) {
    char *tmp23 = slice_string(key, i, i + 1);
    list_string tmp22 = list_string_create(2);
    tmp22.data[0] = tmp23;
    tmp22.data[1] = i;
    int tmp24_data[1];
    list_int tmp24 = {1, tmp24_data};
    tmp24.data[0] = tmp22;
    list_int tmp25 = concat_list_int(pairs, tmp24);
    pairs = tmp25;
    i = i + 1;
  }
  int n = pairs.len;
  int m = 0;
  while (m < n) {
    int j = 0;
    while (j < n - 1) {
      if ((pairs.data[j].data[0] > pairs.data[j + 1].data[0])) {
        int tmp = pairs.data[j];
        pairs.data[j] = pairs.data[j + 1];
        pairs.data[j + 1] = tmp;
      }
      j = j + 1;
    }
    m = m + 1;
  }
  list_int res = list_int_create(0);
  i = 0;
  while (i < n) {
    int tmp26_data[1];
    list_int tmp26 = {1, tmp26_data};
    tmp26.data[0] = (int)(pairs.data[i].data[1]);
    list_int tmp27 = concat_list_int(res, tmp26);
    res = tmp27;
    i = i + 1;
  }
  return res;
}

char *encrypt(list_string polybius, char *key, char *plainText) {
  list_string labels = list_string_create(0);
  int li = 0;
  while (li < strlen(adfgvx)) {
    char *tmp28 = slice_string(adfgvx, li, li + 1);
    list_string tmp29 = list_string_create(1);
    tmp29.data[0] = tmp28;
    list_string tmp30 = concat_list_string(labels, tmp29);
    labels = tmp30;
    li = li + 1;
  }
  char *temp = "";
  int i = 0;
  while (i < strlen(plainText)) {
    int r = 0;
    while (r < 6) {
      int c = 0;
      while (c < 6) {
        char *tmp31 = slice_string(polybius.data[r], c, c + 1);
        char *tmp32 = slice_string(plainText, i, i + 1);
        if ((strcmp(tmp31, tmp32) == 0)) {
          list_string tmp33 = slice_list_string(labels, r, r + 1);
          char *tmp34 = concat_string(temp, tmp33);
          list_string tmp35 = slice_list_string(labels, c, c + 1);
          char *tmp36 = concat_string(tmp34, tmp35);
          temp = tmp36;
        }
        c = c + 1;
      }
      r = r + 1;
    }
    i = i + 1;
  }
  double colLen = ((double)strlen(temp)) / ((double)strlen(key));
  if (strlen(temp) % strlen(key) > 0) {
    colLen = colLen + 1;
  }
  int rIdx = 0;
  while (rIdx < colLen) {
    list_string row = list_string_create(0);
    int j = 0;
    while (j < strlen(key)) {
      list_string tmp37 = list_string_create(1);
      tmp37.data[0] = "";
      list_string tmp38 = concat_list_string(row, tmp37);
      row = tmp38;
      j = j + 1;
    }
    table = 0;
    rIdx = rIdx + 1;
  }
  int idx = 0;
  while (idx < strlen(temp)) {
    double row = ((double)idx) / ((double)strlen(key));
    int col = idx % strlen(key);
    char *tmp39 = slice_string(temp, idx, idx + 1);
    table.data[row].data[col] = tmp39;
    idx = idx + 1;
  }
  list_int order = orderKey(key);
  list_string cols = list_string_create(0);
  int ci = 0;
  while (ci < strlen(key)) {
    char *colStr = "";
    int ri = 0;
    while (ri < colLen) {
      colStr = colStr + table.data[ri].data[order.data[ci]];
      ri = ri + 1;
    }
    list_string tmp40 = list_string_create(1);
    tmp40.data[0] = colStr;
    list_string tmp41 = concat_list_string(cols, tmp40);
    cols = tmp41;
    ci = ci + 1;
  }
  char *result = "";
  ci = 0;
  while (ci < cols.len) {
    char *tmp42 = concat_string(result, cols.data[ci]);
    result = tmp42;
    if (ci < cols.len - 1) {
      char *tmp43 = concat_string(result, " ");
      result = tmp43;
    }
    ci = ci + 1;
  }
  return result;
}

int indexOf(char *s, char *ch) {
  int i = 0;
  while (i < strlen(s)) {
    char *tmp44 = slice_string(s, i, i + 1);
    if ((strcmp(tmp44, ch) == 0)) {
      return i;
    }
    i = i + 1;
  }
  return (-1);
}

char *decrypt(list_string polybius, char *key, char *cipherText) {
  list_string colStrs = list_string_create(0);
  int start = 0;
  int i = 0;
  while (i <= strlen(cipherText)) {
    char *tmp45 = _index_string(cipherText, i);
    if (i == strlen(cipherText) || tmp45 == " ") {
      char *tmp46 = slice_string(cipherText, start, i);
      list_string tmp47 = list_string_create(1);
      tmp47.data[0] = tmp46;
      list_string tmp48 = concat_list_string(colStrs, tmp47);
      colStrs = tmp48;
      start = i + 1;
    }
    i = i + 1;
  }
  int maxColLen = 0;
  i = 0;
  while (i < colStrs.len) {
    if (strlen(colStrs.data[i]) > maxColLen) {
      maxColLen = strlen(colStrs.data[i]);
    }
    i = i + 1;
  }
  i = 0;
  while (i < colStrs.len) {
    char *s = colStrs.data[i];
    list_string ls = list_string_create(0);
    int j = 0;
    while (j < strlen(s)) {
      char *tmp49 = slice_string(s, j, j + 1);
      list_string tmp50 = list_string_create(1);
      tmp50.data[0] = tmp49;
      list_string tmp51 = concat_list_string(ls, tmp50);
      ls = tmp51;
      j = j + 1;
    }
    if (strlen(s) < maxColLen) {
      list_string pad = list_string_create(0);
      int k = 0;
      while (k < maxColLen) {
        if (k < ls.len) {
          list_string tmp52 = list_string_create(1);
          tmp52.data[0] = ls.data[k];
          list_string tmp53 = concat_list_string(pad, tmp52);
          pad = tmp53;
        } else {
          list_string tmp54 = list_string_create(1);
          tmp54.data[0] = "";
          list_string tmp55 = concat_list_string(pad, tmp54);
          pad = tmp55;
        }
        k = k + 1;
      }
      cols = 0;
    } else {
      cols = 0;
    }
    i = i + 1;
  }
  int r = 0;
  while (r < maxColLen) {
    list_string row = list_string_create(0);
    int c = 0;
    while (c < strlen(key)) {
      list_string tmp56 = list_string_create(1);
      tmp56.data[0] = "";
      list_string tmp57 = concat_list_string(row, tmp56);
      row = tmp57;
      c = c + 1;
    }
    table = 0;
    r = r + 1;
  }
  list_int order = orderKey(key);
  r = 0;
  while (r < maxColLen) {
    int c = 0;
    while (c < strlen(key)) {
      table.data[r].data[order.data[c]] = cols.data[c].data[r];
      c = c + 1;
    }
    r = r + 1;
  }
  char *temp = "";
  r = 0;
  while (r < table.len) {
    int j = 0;
    while (j < table.data[r].len) {
      temp = temp + table.data[r].data[j];
      j = j + 1;
    }
    r = r + 1;
  }
  char *plainText = "";
  int idx = 0;
  while (idx < strlen(temp)) {
    char *tmp58 = slice_string(temp, idx, idx + 1);
    int rIdx = index_of_string(adfgvx, tmp58);
    char *tmp59 = slice_string(temp, idx + 1, idx + 2);
    int cIdx = index_of_string(adfgvx, tmp59);
    char *tmp60 = _index_string(polybius.data[rIdx], cIdx);
    char *tmp61 = concat_string(plainText, tmp60);
    plainText = tmp61;
    idx = idx + 2;
  }
  return plainText;
}

int mochi_main() {
  char *plainText = "ATTACKAT1200AM";
  list_string polybius = createPolybius();
  char *key = createKey(9);
  char *tmp62 = concat_string("\nPlaintext : ", plainText);
  printf("%s\n", tmp62);
  char *cipherText = encrypt(polybius, key, plainText);
  char *tmp63 = concat_string("\nEncrypted : ", cipherText);
  printf("%s\n", tmp63);
  char *plainText2 = decrypt(polybius, key, cipherText);
  char *tmp64 = concat_string("\nDecrypted : ", plainText2);
  printf("%s\n", tmp64);
}

int _mochi_main() {
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
