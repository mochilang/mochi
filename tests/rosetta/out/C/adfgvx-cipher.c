// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:58:41Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:58:41Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static long long _now() {
  struct timespec ts;
  clock_gettime(CLOCK_REALTIME, &ts);
  return (long long)ts.tv_sec * 1000000000LL + ts.tv_nsec;
}
static char *_index_string(char *s, int i) {
  int len = strlen(s);
  if (i < 0)
    i += len;
  if (i < 0 || i >= len) {
    fprintf(stderr, "index out of range\n");
    exit(1);
  }
  char *buf = (char *)malloc(2);
  buf[0] = s[i];
  buf[1] = '\0';
  return buf;
}
static int index_of_string(char *s, char *sub) {
  char *pos = strstr(s, sub);
  if (!pos)
    return -1;
  return pos - s;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static char *adfgvx = "ADFGVX";
static char *alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

char *shuffleStr(char *s) {
  list_string arr = list_string_create(0);
  int i = 0;
  while (i < strlen(s)) {
    char *tmp2 = _index_string(s, i);
    list_string tmp1 = list_string_create(1);
    tmp1.data[0] = tmp2;
    arr = arr + tmp1;
    i = i + 1;
  }
  int j = 0 - 1;
  while ((j > 0)) {
    long long k = _now() % (j + 1);
    int tmp = arr.data[j];
    arr.data[j] = arr.data[k];
    arr.data[k] = tmp;
    j = j - 1;
  }
  char *out = "";
  i = 0;
  while ((i < 0)) {
    out = out + arr.data[i];
    i = i + 1;
  }
  return out;
}

list_string createPolybius() {
  char *shuffled = shuffleStr(alphabet);
  printf("6 x 6 Polybius square:\\n\n");
  printf("  | A D F G V X\n");
  printf("---------------\n");
  list_string p = list_string_create(0);
  int i = 0;
  while (i < 6) {
    char *tmp3 = slice_string(shuffled, i * 6, (i + 1) * 6);
    char *row = tmp3;
    list_string tmp4 = list_string_create(1);
    tmp4.data[0] = row;
    p = p + tmp4;
    char *tmp5 = _index_string(adfgvx, i);
    char *tmp6 = concat_string(tmp5, " | ");
    char *line = tmp6;
    int j = 0;
    while (j < 6) {
      char *tmp7 = _index_string(row, j);
      char *tmp8 = concat_string(line, tmp7);
      char *tmp9 = concat_string(tmp8, " ");
      line = tmp9;
      j = j + 1;
    }
    printf("%s\n", line);
    i = i + 1;
  }
  return p;
}

char *createKey(int n) {
  if (n < 7 || n > 12) {
    printf("Key should be within 7 and 12 letters long.\n");
  }
  char *pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  char *key = "";
  int i = 0;
  while (i < n) {
    long long idx = _now() % strlen(pool);
    char *tmp10 = _index_string(pool, idx);
    char *tmp11 = concat_string(key, tmp10);
    key = tmp11;
    char *tmp12 = slice_string(pool, 0, idx);
    char *tmp13 = slice_string(pool, idx + 1, strlen(pool));
    char *tmp14 = concat_string(tmp12, tmp13);
    pool = tmp14;
    i = i + 1;
  }
  char *tmp15 = concat_string("\nThe key is ", key);
  printf("%s\n", tmp15);
  return key;
}

list_int orderKey(char *key) {
  list_int pairs = list_int_create(0);
  int i = 0;
  while (i < strlen(key)) {
    char *tmp18 = _index_string(key, i);
    list_string tmp17 = list_string_create(2);
    tmp17.data[0] = tmp18;
    tmp17.data[1] = i;
    list_int tmp16_data[] = {tmp17};
    list_list_int tmp16 = {1, tmp16_data};
    pairs = pairs + tmp16;
    i = i + 1;
  }
  int n = 0;
  int m = 0;
  while (m < n) {
    int j = 0;
    while (j < n - 1) {
      if ((pairs.data[j].data[0] > pairs.data[j + 1].data[0])) {
        int tmp = pairs.data[j];
        pairs.data[j] = pairs.data[j + 1];
        pairs.data[j + 1] = tmp;
      }
      j = j + 1;
    }
    m = m + 1;
  }
  list_int res = list_int_create(0);
  i = 0;
  while (i < n) {
    list_int tmp19 = list_int_create(1);
    tmp19.data[0] = (int)(pairs.data[i].data[1]);
    list_int tmp20 = concat_list_int(res, tmp19);
    res = tmp20;
    i = i + 1;
  }
  list_int tmp21 = list_int_create(0);
  return tmp21;
}

char *encrypt(list_string polybius, char *key, char *plainText) {
  char *temp = "";
  int i = 0;
  while (i < strlen(plainText)) {
    int r = 0;
    while (r < 6) {
      int c = 0;
      while (c < 6) {
        char *tmp22 = _index_string(polybius.data[r], c);
        char *tmp23 = _index_string(plainText, i);
        if ((strcmp(tmp22, tmp23) == 0)) {
          char *tmp24 = _index_string(adfgvx, r);
          char *tmp25 = concat_string(temp, tmp24);
          char *tmp26 = _index_string(adfgvx, c);
          char *tmp27 = concat_string(tmp25, tmp26);
          temp = tmp27;
        }
        c = c + 1;
      }
      r = r + 1;
    }
    i = i + 1;
  }
  double colLen = ((double)strlen(temp)) / ((double)strlen(key));
  if (strlen(temp) % strlen(key) > 0) {
    colLen = colLen + 1;
  }
  int rIdx = 0;
  while (rIdx < colLen) {
    list_string row = list_string_create(0);
    int j = 0;
    while (j < strlen(key)) {
      list_string tmp28 = list_string_create(1);
      tmp28.data[0] = "";
      row = row + tmp28;
      j = j + 1;
    }
    list_int tmp29 = list_int_create(1);
    tmp29.data[0] = row;
    table = table + tmp29;
    rIdx = rIdx + 1;
  }
  int idx = 0;
  while (idx < strlen(temp)) {
    double row = ((double)idx) / ((double)strlen(key));
    int col = idx % strlen(key);
    char *tmp30 = slice_string(temp, idx, idx + 1);
    table.data[row].data[col] = tmp30;
    idx = idx + 1;
  }
  list_int order = orderKey(key);
  list_string cols = list_string_create(0);
  int ci = 0;
  while (ci < strlen(key)) {
    char *colStr = "";
    int ri = 0;
    while (ri < colLen) {
      colStr = colStr + table.data[ri].data[order.data[ci]];
      ri = ri + 1;
    }
    list_string tmp31 = list_string_create(1);
    tmp31.data[0] = colStr;
    cols = cols + tmp31;
    ci = ci + 1;
  }
  char *result = "";
  ci = 0;
  while ((ci < 0)) {
    result = result + cols.data[ci];
    if ((ci < 0 - 1)) {
      char *tmp32 = concat_string(result, " ");
      result = tmp32;
    }
    ci = ci + 1;
  }
  return result;
}

int indexOf(char *s, char *ch) {
  int i = 0;
  while (i < strlen(s)) {
    char *tmp33 = _index_string(s, i);
    if ((strcmp(tmp33, ch) == 0)) {
      return i;
    }
    i = i + 1;
  }
  return (-1);
}

char *decrypt(list_string polybius, char *key, char *cipherText) {
  list_string colStrs = list_string_create(0);
  int start = 0;
  int i = 0;
  while (i <= strlen(cipherText)) {
    char *tmp34 = _index_string(cipherText, i);
    if (i == strlen(cipherText) || tmp34 == " ") {
      char *tmp36 = slice_string(cipherText, start, i);
      list_string tmp35 = list_string_create(1);
      tmp35.data[0] = tmp36;
      colStrs = colStrs + tmp35;
      start = i + 1;
    }
    i = i + 1;
  }
  int maxColLen = 0;
  i = 0;
  while ((i < 0)) {
    if ((colStrs.data[i].len > maxColLen)) {
      maxColLen = colStrs.data[i].len;
    }
    i = i + 1;
  }
  i = 0;
  while ((i < 0)) {
    int s = colStrs.data[i];
    list_string ls = list_string_create(0);
    int j = 0;
    while (j < s.len) {
      list_int tmp37 = list_int_create(1);
      tmp37.data[0] = s.data[j];
      ls = ls + tmp37;
      j = j + 1;
    }
    if (s.len < maxColLen) {
      list_string pad = list_string_create(0);
      int k = 0;
      while (k < maxColLen) {
        if ((k < 0)) {
          list_int tmp38 = list_int_create(1);
          tmp38.data[0] = ls.data[k];
          pad = pad + tmp38;
        } else {
          list_string tmp39 = list_string_create(1);
          tmp39.data[0] = "";
          pad = pad + tmp39;
        }
        k = k + 1;
      }
      list_int tmp40 = list_int_create(1);
      tmp40.data[0] = pad;
      cols = cols + tmp40;
    } else {
      list_int tmp41 = list_int_create(1);
      tmp41.data[0] = ls;
      cols = cols + tmp41;
    }
    i = i + 1;
  }
  int r = 0;
  while (r < maxColLen) {
    list_string row = list_string_create(0);
    int c = 0;
    while (c < strlen(key)) {
      list_string tmp42 = list_string_create(1);
      tmp42.data[0] = "";
      row = row + tmp42;
      c = c + 1;
    }
    list_int tmp43 = list_int_create(1);
    tmp43.data[0] = row;
    table = table + tmp43;
    r = r + 1;
  }
  list_int order = orderKey(key);
  r = 0;
  while (r < maxColLen) {
    int c = 0;
    while (c < strlen(key)) {
      table.data[r].data[order.data[c]] = cols.data[c].data[r];
      c = c + 1;
    }
    r = r + 1;
  }
  char *temp = "";
  r = 0;
  while (r < table.len) {
    int j = 0;
    while (j < table.data[r].len) {
      temp = temp + table.data[r].data[j];
      j = j + 1;
    }
    r = r + 1;
  }
  char *plainText = "";
  int idx = 0;
  while (idx < strlen(temp)) {
    char *tmp44 = slice_string(temp, idx, idx + 1);
    int rIdx = index_of_string(adfgvx, tmp44);
    char *tmp45 = slice_string(temp, idx + 1, idx + 2);
    int cIdx = index_of_string(adfgvx, tmp45);
    char *tmp46 = _index_string(polybius.data[rIdx], cIdx);
    char *tmp47 = concat_string(plainText, tmp46);
    plainText = tmp47;
    idx = idx + 2;
  }
  return plainText;
}

int mochi_main() {
  char *plainText = "ATTACKAT1200AM";
  list_string polybius = createPolybius();
  char *key = createKey(9);
  char *tmp48 = concat_string("\nPlaintext : ", plainText);
  printf("%s\n", tmp48);
  char *cipherText = encrypt(polybius, key, plainText);
  char *tmp49 = concat_string("\nEncrypted : ", cipherText);
  printf("%s\n", tmp49);
  char *plainText2 = decrypt(polybius, key, cipherText);
  char *tmp50 = concat_string("\nDecrypted : ", plainText2);
  printf("%s\n", tmp50);
}

int _mochi_main() {
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
