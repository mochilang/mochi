// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
int toUnsigned16(int n) {
  int u = n;
  if (u < 0) {
    u = u + 65536;
  }
  return u % 65536;
}

const char *bin16(int n) {
  int u = toUnsigned16(n);
  const char *bits = "";
  int mask = 32768;
  for (int i = 0; i < 16; i++) {
    if (u >= mask) {
      char *tmp1 = concat_string(bits, "1");
      bits = tmp1;
      u = u - mask;
    } else {
      char *tmp2 = concat_string(bits, "0");
      bits = tmp2;
    }
    mask = (int)((((double)mask) / ((double)2)));
  }
  return bits;
}

int bit_and(int a, int b) {
  int ua = toUnsigned16(a);
  int ub = toUnsigned16(b);
  int res = 0;
  int bit = 1;
  for (int i = 0; i < 16; i++) {
    if (ua % 2 == 1 && ub % 2 == 1) {
      res = res + bit;
    }
    ua = (int)((((double)ua) / ((double)2)));
    ub = (int)((((double)ub) / ((double)2)));
    bit = bit * 2;
  }
  return res;
}

int bit_or(int a, int b) {
  int ua = toUnsigned16(a);
  int ub = toUnsigned16(b);
  int res = 0;
  int bit = 1;
  for (int i = 0; i < 16; i++) {
    if (ua % 2 == 1 || ub % 2 == 1) {
      res = res + bit;
    }
    ua = (int)((((double)ua) / ((double)2)));
    ub = (int)((((double)ub) / ((double)2)));
    bit = bit * 2;
  }
  return res;
}

int bit_xor(int a, int b) {
  int ua = toUnsigned16(a);
  int ub = toUnsigned16(b);
  int res = 0;
  int bit = 1;
  for (int i = 0; i < 16; i++) {
    int abit = ua % 2;
    int bbit = ub % 2;
    if ((abit == 1 && bbit == 0) || (abit == 0 && bbit == 1)) {
      res = res + bit;
    }
    ua = (int)((((double)ua) / ((double)2)));
    ub = (int)((((double)ub) / ((double)2)));
    bit = bit * 2;
  }
  return res;
}

int bit_not(int a) {
  int ua = toUnsigned16(a);
  return 65535 - ua;
}

int shl(int a, int b) {
  int ua = toUnsigned16(a);
  int i = 0;
  while (i < b) {
    ua = (ua * 2) % 65536;
    i = i + 1;
  }
  return ua;
}

int shr(int a, int b) {
  int ua = toUnsigned16(a);
  int i = 0;
  while (i < b) {
    ua = (int)((((double)ua) / ((double)2)));
    i = i + 1;
  }
  return ua;
}

int las(int a, int b) { return shl(a, b); }

int ras(int a, int b) {
  int val = a;
  int i = 0;
  while (i < b) {
    if (val >= 0) {
      val = (int)((((double)val) / ((double)2)));
    } else {
      val = (int)((((double)(val - 1)) / ((double)2)));
    }
    i = i + 1;
  }
  return toUnsigned16(val);
}

int rol(int a, int b) {
  int ua = toUnsigned16(a);
  int left = shl(ua, b);
  int right = shr(ua, 16 - b);
  return toUnsigned16(left + right);
}

int ror(int a, int b) {
  int ua = toUnsigned16(a);
  int right = shr(ua, b);
  int left = shl(ua, 16 - b);
  return toUnsigned16(left + right);
}

int bitwise(int a, int b) {
  printf("%s\n", "a:   " + bin16(a));
  printf("%s\n", "b:   " + bin16(b));
  printf("%s\n", "and: " + bin16(bit_and(a, b)));
  printf("%s\n", "or:  " + bin16(bit_or(a, b)));
  printf("%s\n", "xor: " + bin16(bit_xor(a, b)));
  printf("%s\n", "not: " + bin16(bit_not(a)));
  if (b < 0) {
    printf("Right operand is negative, but all shifts require an unsigned "
           "right operand (shift distance).\n");
    return 0;
  }
  printf("%s\n", "shl: " + bin16(shl(a, b)));
  printf("%s\n", "shr: " + bin16(shr(a, b)));
  printf("%s\n", "las: " + bin16(las(a, b)));
  printf("%s\n", "ras: " + bin16(ras(a, b)));
  printf("%s\n", "rol: " + bin16(rol(a, b)));
  printf("%s\n", "ror: " + bin16(ror(a, b)));
}

int main() {
  bitwise((-460), 6);
  return 0;
}
