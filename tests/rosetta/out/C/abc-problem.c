// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:23:44Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:23:44Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_string concat_list_string(list_string a, list_string b) {
  list_string r = list_string_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static list_string _lambda0_bl;
int _lambda0(char *w) { return canSpell(w, _lambda0_bl); }

list_string fields(char *s) {
  list_string res = list_string_create(0);
  char *cur = "";
  int i = 0;
  while (i < strlen(s)) {
    char *tmp1 = slice_string(s, i, i + 1);
    char *c = tmp1;
    if ((strcmp(c, " ") == 0)) {
      if (strlen(cur) > 0) {
        list_string tmp2 = list_string_create(1);
        tmp2.data[0] = cur;
        list_string tmp3 = concat_list_string(res, tmp2);
        res = tmp3;
        cur = "";
      }
    } else {
      char *tmp4 = concat_string(cur, c);
      cur = tmp4;
    }
    i = i + 1;
  }
  if (strlen(cur) > 0) {
    list_string tmp5 = list_string_create(1);
    tmp5.data[0] = cur;
    list_string tmp6 = concat_list_string(res, tmp5);
    res = tmp6;
  }
  return res;
}

int canSpell(char *word, list_string blks) {
  if (strlen(word) == 0) {
    return 1;
  }
  char *tmp7 = slice_string(word, 0, 1);
  char *c = lower(tmp7);
  int i = 0;
  while (i < blks.len) {
    char *b = blks.data[i];
    char *tmp8 = slice_string(b, 0, 1);
    char *tmp9 = slice_string(b, 1, 2);
    if ((strcmp(c, lower(tmp8)) == 0) || c == lower(tmp9)) {
      list_string rest = list_string_create(0);
      int j = 0;
      while (j < blks.len) {
        if (j != i) {
          list_string tmp10 = list_string_create(1);
          tmp10.data[0] = blks.data[j];
          list_string tmp11 = concat_list_string(rest, tmp10);
          rest = tmp11;
        }
        j = j + 1;
      }
      char *tmp12 = slice_string(word, 1, word.len);
      if (canSpell(tmp12, rest)) {
        return 1;
      }
    }
    i = i + 1;
  }
  return 0;
}

int (*newSpeller(char *blocks))(char *) {
  list_string bl = fields(blocks);
  return (_lambda0_bl = bl, _lambda0);
}

int mochi_main() {
  int (*sp)(char *) =
      newSpeller("BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM");
  list_string tmp13 = list_string_create(7);
  tmp13.data[0] = "A";
  tmp13.data[1] = "BARK";
  tmp13.data[2] = "BOOK";
  tmp13.data[3] = "TREAT";
  tmp13.data[4] = "COMMON";
  tmp13.data[5] = "SQUAD";
  tmp13.data[6] = "CONFUSE";
  for (int tmp14 = 0; tmp14 < 7; tmp14++) {
    char *word = tmp13.data[tmp14];
    char *tmp15 = concat_string(word, " ");
    char *tmp16 = _str(sp(word));
    char *tmp17 = concat_string(tmp15, tmp16);
    printf("%s\n", tmp17);
  }
}

int _mochi_main() {
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
