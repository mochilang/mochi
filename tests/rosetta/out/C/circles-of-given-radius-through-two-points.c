// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:08Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:08Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
typedef struct point_t point_t;

static char *Two = "Two circles.";
static char *R0 = "R==0.0 does not describe circles.";
static char *Co = "Coincident points describe an infinite number of circles.";
static char *CoR0 =
    "Coincident points with r==0.0 describe a degenerate circle.";
static char *Diam = "Points form a diameter and describe only a single circle.";
static char *Far = "Points too far apart to form circles.";

typedef struct point_t {
  double x;
  double y;
} point_t;
typedef struct {
  int len;
  point_t *data;
} point_list_t;
point_list_t create_point_list(int len) {
  point_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(point_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

double sqrtApprox(double x) {
  double g = x;
  int i = 0;
  while (i < 40) {
    g = (g + x / g) / 2.0;
    i = i + 1;
  }
  return g;
}

double hypot(double x, double y) { return sqrtApprox(x * x + y * y); }

list_int circles(point_t *p1, point_t *p2, double r) {
  if (p1->x == p2->x && p1->y == p2->y) {
    if (r == 0.0) {
      list_int tmp1 = list_int_create(3);
      tmp1.data[0] = p1;
      tmp1.data[1] = p1;
      tmp1.data[2] =
          "Coincident points with r==0.0 describe a degenerate circle.";
      return tmp1;
    }
    list_int tmp2 = list_int_create(3);
    tmp2.data[0] = p1;
    tmp2.data[1] = p2;
    tmp2.data[2] = "Coincident points describe an infinite number of circles.";
    return tmp2;
  }
  if (r == 0.0) {
    list_int tmp3 = list_int_create(3);
    tmp3.data[0] = p1;
    tmp3.data[1] = p2;
    tmp3.data[2] = "R==0.0 does not describe circles.";
    return tmp3;
  }
  double dx = p2->x - p1->x;
  double dy = p2->y - p1->y;
  double q = hypot(dx, dy);
  if (q > 2.0 * r) {
    list_int tmp4 = list_int_create(3);
    tmp4.data[0] = p1;
    tmp4.data[1] = p2;
    tmp4.data[2] = "Points too far apart to form circles.";
    return tmp4;
  }
  point_t m = (point_t){.x = (p1->x + p2->x) / 2.0, .y = (p1->y + p2->y) / 2.0};
  if (q == 2.0 * r) {
    list_int tmp5 = list_int_create(3);
    tmp5.data[0] = m;
    tmp5.data[1] = m;
    tmp5.data[2] = "Points form a diameter and describe only a single circle.";
    return tmp5;
  }
  double d = sqrtApprox(r * r - q * q / 4.0);
  double ox = d * dx / q;
  double oy = d * dy / q;
  point_t tmp6[] = {(point_t){.x = m.x - oy, .y = m.y + ox},
                    (point_t){.x = m.x + oy, .y = m.y - ox}, "Two circles."};
  int tmp6_len = sizeof(tmp6) / sizeof(tmp6[0]);
  return tmp6;
}

int _mochi_main() {
  point_t td[] = {(point_t){.x = 0.1234, .y = 0.9876},
                  (point_t){.x = 0.8765, .y = 0.2345}, 2.0};
  int td_len = sizeof(td) / sizeof(td[0]);
  point_t td[] = {(point_t){.x = 0.0, .y = 2.0}, (point_t){.x = 0.0, .y = 0.0},
                  1.0};
  int td_len = sizeof(td) / sizeof(td[0]);
  point_t td[] = {(point_t){.x = 0.1234, .y = 0.9876},
                  (point_t){.x = 0.1234, .y = 0.9876}, 2.0};
  int td_len = sizeof(td) / sizeof(td[0]);
  point_t td[] = {(point_t){.x = 0.1234, .y = 0.9876},
                  (point_t){.x = 0.8765, .y = 0.2345}, 0.5};
  int td_len = sizeof(td) / sizeof(td[0]);
  point_t td[] = {(point_t){.x = 0.1234, .y = 0.9876},
                  (point_t){.x = 0.1234, .y = 0.9876}, 0.0};
  int td_len = sizeof(td) / sizeof(td[0]);
  list_int td_data[] = {td, td, td, td, td};
  list_list_int td = {5, td_data};
  for (int tmp7 = 0; tmp7 < td_len; tmp7++) {
    list_int tc = td[tmp7];
    int p1 = tc.data[0];
    int p2 = tc.data[1];
    int r = tc.data[2];
    char *tmp8 = _str(p1.x);
    char *tmp9 = concat_string("p1:  {", tmp8);
    char *tmp10 = concat_string(tmp9, " ");
    char *tmp11 = _str(p1.y);
    char *tmp12 = concat_string(tmp10, tmp11);
    char *tmp13 = concat_string(tmp12, "}");
    printf("%s\n", tmp13);
    char *tmp14 = _str(p2.x);
    char *tmp15 = concat_string("p2:  {", tmp14);
    char *tmp16 = concat_string(tmp15, " ");
    char *tmp17 = _str(p2.y);
    char *tmp18 = concat_string(tmp16, tmp17);
    char *tmp19 = concat_string(tmp18, "}");
    printf("%s\n", tmp19);
    char *tmp20 = _str(r);
    char *tmp21 = concat_string("r:  ", tmp20);
    printf("%s\n", tmp21);
    list_int res = circles(p1, p2, r);
    int c1 = res.data[0];
    int c2 = res.data[1];
    int caseStr = res.data[2];
    printf("%d\n", "   " + caseStr);
    if ((caseStr ==
             "Points form a diameter and describe only a single circle." ||
         caseStr ==
             "Coincident points with r==0.0 describe a degenerate circle.")) {
      char *tmp22 = _str(c1.x);
      char *tmp23 = concat_string("   Center:  {", tmp22);
      char *tmp24 = concat_string(tmp23, " ");
      char *tmp25 = _str(c1.y);
      char *tmp26 = concat_string(tmp24, tmp25);
      char *tmp27 = concat_string(tmp26, "}");
      printf("%s\n", tmp27);
    } else {
      if ((caseStr == "Two circles.")) {
        char *tmp28 = _str(c1.x);
        char *tmp29 = concat_string("   Center 1:  {", tmp28);
        char *tmp30 = concat_string(tmp29, " ");
        char *tmp31 = _str(c1.y);
        char *tmp32 = concat_string(tmp30, tmp31);
        char *tmp33 = concat_string(tmp32, "}");
        printf("%s\n", tmp33);
        char *tmp34 = _str(c2.x);
        char *tmp35 = concat_string("   Center 2:  {", tmp34);
        char *tmp36 = concat_string(tmp35, " ");
        char *tmp37 = _str(c2.y);
        char *tmp38 = concat_string(tmp36, tmp37);
        char *tmp39 = concat_string(tmp38, "}");
        printf("%s\n", tmp39);
      }
    }
    printf("\n");
  }
  return 0;
}
int main() { return _mochi_main(); }
