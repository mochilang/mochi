// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:20:52Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:20:52Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  double *data;
} list_float;
static list_float list_float_create(int len) {
  list_float l;
  l.len = len;
  l.data = calloc(len, sizeof(double));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static list_float concat_list_float(list_float a, list_float b) {
  list_float r = list_float_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
typedef struct {
  int order;
  list_float ele;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

double sqrtApprox(double x) {
  double guess = x;
  int i = 0;
  while (i < 20) {
    guess = (guess + x / guess) / 2.0;
    i = i + 1;
  }
  return guess;
}

int makeSym(int order, list_float elements) {
  return (tmp_item_t){.order = order, .ele = elements};
}

int unpackSym(map_string_int m) {
  int n = m.data["order"];
  int ele = m.data["ele"];
  int idx = 0;
  int r = 0;
  while ((r < n)) {
    list_float row = list_float_create(0);
    int c = 0;
    while (c <= r) {
      int tmp1_data[1];
      list_int tmp1 = {1, tmp1_data};
      tmp1.data[0] = ele.data[idx];
      list_int tmp2 = concat_list_int(row, tmp1);
      row = tmp2;
      idx = idx + 1;
      c = c + 1;
    }
    while ((c < n)) {
      int tmp3_data[1];
      list_int tmp3 = {1, tmp3_data};
      tmp3.data[0] = 0.0;
      list_int tmp4 = concat_list_int(row, tmp3);
      row = tmp4;
      c = c + 1;
    }
    mat = 0;
    r = r + 1;
  }
  r = 0;
  while ((r < n)) {
    int c = r + 1;
    while ((c < n)) {
      mat.data[r].data[c] = mat.data[c].data[r];
      c = c + 1;
    }
    r = r + 1;
  }
  return mat;
}

int printMat(int m) {
  int i = 0;
  while (i < m.len) {
    char *line = "";
    int j = 0;
    while (j < m.data[i].len) {
      char *tmp5 = _str(m.data[i].data[j]);
      char *tmp6 = concat_string(line, tmp5);
      line = tmp6;
      if (j < m.data[i].len - 1) {
        char *tmp7 = concat_string(line, " ");
        line = tmp7;
      }
      j = j + 1;
    }
    printf("%s\n", line);
    i = i + 1;
  }
}

int printSym(map_string_int m) { printMat(unpackSym(m)); }

int printLower(map_string_int m) {
  int n = m.data["order"];
  int ele = m.data["ele"];
  int idx = 0;
  int r = 0;
  while ((r < n)) {
    list_float row = list_float_create(0);
    int c = 0;
    while (c <= r) {
      int tmp8_data[1];
      list_int tmp8 = {1, tmp8_data};
      tmp8.data[0] = ele.data[idx];
      list_int tmp9 = concat_list_int(row, tmp8);
      row = tmp9;
      idx = idx + 1;
      c = c + 1;
    }
    while ((c < n)) {
      int tmp10_data[1];
      list_int tmp10 = {1, tmp10_data};
      tmp10.data[0] = 0.0;
      list_int tmp11 = concat_list_int(row, tmp10);
      row = tmp11;
      c = c + 1;
    }
    mat = 0;
    r = r + 1;
  }
  printMat(mat);
}

int choleskyLower(map_string_int a) {
  int n = a.data["order"];
  int ae = a.data["ele"];
  list_float le = list_float_create(0);
  int idx = 0;
  while (idx < ae.len) {
    list_float tmp12 = list_float_create(1);
    tmp12.data[0] = 0.0;
    list_float tmp13 = concat_list_float(le, tmp12);
    le = tmp13;
    idx = idx + 1;
  }
  int row = 1;
  int col = 1;
  int dr = 0;
  int dc = 0;
  int i = 0;
  while (i < ae.len) {
    int e = ae.data[i];
    if (i < dr) {
      int d = (e - le.data[i]) / le.data[dc];
      le.data[i] = d;
      int ci = col;
      int cx = dc;
      int j = i + 1;
      while (j <= dr) {
        cx = cx + ci;
        ci = ci + 1;
        le.data[j] = le.data[j] + d * le.data[cx];
        j = j + 1;
      }
      col = col + 1;
      dc = dc + col;
    } else {
      le.data[i] = sqrtApprox(e - le.data[i]);
      row = row + 1;
      dr = dr + row;
      col = 1;
      dc = 0;
    }
    i = i + 1;
  }
  return (tmp_item_t){.order = n, .ele = le};
}

int demo(map_string_int a) {
  printf("A:\n");
  printSym(a);
  printf("L:\n");
  int l = choleskyLower(a);
  printLower(l);
}

int _mochi_main() {
  list_float tmp14 = list_float_create(6);
  tmp14.data[0] = 25.0;
  tmp14.data[1] = 15.0;
  tmp14.data[2] = 18.0;
  tmp14.data[3] = (-5.0);
  tmp14.data[4] = 0.0;
  tmp14.data[5] = 11.0;
  demo(makeSym(3, tmp14));
  list_float tmp15 = list_float_create(10);
  tmp15.data[0] = 18.0;
  tmp15.data[1] = 22.0;
  tmp15.data[2] = 70.0;
  tmp15.data[3] = 54.0;
  tmp15.data[4] = 86.0;
  tmp15.data[5] = 174.0;
  tmp15.data[6] = 42.0;
  tmp15.data[7] = 62.0;
  tmp15.data[8] = 134.0;
  tmp15.data[9] = 106.0;
  demo(makeSym(4, tmp15));
  return 0;
}
int main() { return _mochi_main(); }
