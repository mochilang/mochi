// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:37:20Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  char **data;
} list_string;
static list_string list_string_create(int len) {
  list_string l;
  l.len = len;
  l.data = calloc(len, sizeof(char *));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  int len;
  list_int *data;
} list_list_int;
static list_list_int list_list_int_create(int len) {
  list_list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(list_int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  char *key;
  int value;
} pair_string_int;
static pair_string_int pair_string_int_new(char *key, int value) {
  pair_string_int p;
  p.key = key;
  p.value = value;
  return p;
}
typedef struct {
  int len;
  int cap;
  pair_string_int *data;
} map_string_int;
static map_string_int map_string_int_create(int cap) {
  map_string_int m;
  m.len = 0;
  m.cap = cap;
  m.data = cap ? calloc(cap, sizeof(pair_string_int)) : NULL;
  if (cap && !m.data) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return m;
}
static void map_string_int_put(map_string_int *m, char *k, int v) {
  for (int i = 0; i < m->len; i++)
    if (strcmp(m->data[i].key, k) == 0) {
      m->data[i].value = v;
      return;
    }
  if (m->len >= m->cap) {
    m->cap = m->cap ? m->cap * 2 : 4;
    m->data =
        (pair_string_int *)realloc(m->data, sizeof(pair_string_int) * m->cap);
  }
  m->data[m->len++] = pair_string_int_new(k, v);
}
static int map_string_int_get(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return m.data[i].value;
  return 0;
}
static int map_string_int_contains(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return 1;
  return 0;
}
static int cmp_map_string_int(map_string_int a, map_string_int b) {
  int aa = map_string_int_get(a, "a");
  int ba = map_string_int_get(b, "a");
  if (aa != ba)
    return aa > ba ? 1 : -1;
  int ab = map_string_int_get(a, "b");
  int bb = map_string_int_get(b, "b");
  if (ab != bb)
    return ab > bb ? 1 : -1;
  return 0;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static char *slice_string(char *s, int start, int end) {
  int len = strlen(s);
  if (start < 0)
    start += len;
  if (end < 0)
    end += len;
  if (start < 0)
    start = 0;
  if (end > len)
    end = len;
  if (start > end)
    start = end;
  char *buf = (char *)malloc(end - start + 1);
  memcpy(buf, s + start, end - start);
  buf[end - start] = '\0';
  return buf;
}
static double PI = 3.141592653589793;
static double TWO_PI = 6.283185307179586;

typedef struct {
  int _;
  int _;
  int _;
  int _;
  int _;
  int _;
  int _;
  int _;
  int _;
  int _;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

double sinApprox(double x) {
  double term = x;
  double sum = x;
  int n = 1;
  while (n <= 8) {
    double denom = (double)(((2 * n) * (2 * n + 1)));
    term = (-term) * x * x / denom;
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

double floor(double x) {
  int i = (int)(x);
  if (((double)(i)) > x) {
    i = i - 1;
  }
  return (double)(i);
}

double absFloat(double x) {
  if (x < 0.0) {
    return (-x);
  }
  return x;
}

int absInt(int n) {
  if (n < 0) {
    return (-n);
  }
  return n;
}

int parseIntStr(char *str) {
  int i = 0;
  int neg = 0;
  char *tmp1 = slice_string(str, 0, 1);
  if ((str.len > 0 && tmp1 == "-")) {
    neg = 1;
    i = 1;
  }
  int n = 0;
  map_string_int digits = (tmp_item_t){._ = 0,
                                       ._ = 1,
                                       ._ = 2,
                                       ._ = 3,
                                       ._ = 4,
                                       ._ = 5,
                                       ._ = 6,
                                       ._ = 7,
                                       ._ = 8,
                                       ._ = 9};
  while ((i < str.len)) {
    char *tmp2 = slice_string(str, i, i + 1);
    n = n * 10 + map_string_int_get(digits, tmp2);
    i = i + 1;
  }
  if (neg) {
    n = (-n);
  }
  return n;
}

list_int parseDate(char *s) {
  char *tmp3 = slice_string(s, 0, 4);
  int y = parseIntStr(tmp3);
  char *tmp4 = slice_string(s, 5, 7);
  int m = parseIntStr(tmp4);
  char *tmp5 = slice_string(s, 8, 10);
  int d = parseIntStr(tmp5);
  list_int tmp6 = list_int_create(3);
  tmp6.data[0] = y;
  tmp6.data[1] = m;
  tmp6.data[2] = d;
  return tmp6;
}

int leap(int y) {
  if (y % 400 == 0) {
    return 1;
  }
  if (y % 100 == 0) {
    return 0;
  }
  return y % 4 == 0;
}

int daysInMonth(int y, int m) {
  int feb = (leap(y) ? 29 : 28);
  list_int lengths = list_int_create(12);
  lengths.data[0] = 31;
  lengths.data[1] = feb;
  lengths.data[2] = 31;
  lengths.data[3] = 30;
  lengths.data[4] = 31;
  lengths.data[5] = 30;
  lengths.data[6] = 31;
  lengths.data[7] = 31;
  lengths.data[8] = 30;
  lengths.data[9] = 31;
  lengths.data[10] = 30;
  lengths.data[11] = 31;
  list_int lengths = lengths;
  return lengths.data[m - 1];
}

list_int addDays(int y, int m, int d, int n) {
  int yy = y;
  int mm = m;
  int dd = d;
  if (n >= 0) {
    int i = 0;
    while (i < n) {
      dd = dd + 1;
      if (dd > daysInMonth(yy, mm)) {
        dd = 1;
        mm = mm + 1;
        if (mm > 12) {
          mm = 1;
          yy = yy + 1;
        }
      }
      i = i + 1;
    }
  } else {
    int i = 0;
    while (i > n) {
      dd = dd - 1;
      if (dd < 1) {
        mm = mm - 1;
        if (mm < 1) {
          mm = 12;
          yy = yy - 1;
        }
        dd = daysInMonth(yy, mm);
      }
      i = i - 1;
    }
  }
  list_int tmp7 = list_int_create(3);
  tmp7.data[0] = yy;
  tmp7.data[1] = mm;
  tmp7.data[2] = dd;
  return tmp7;
}

const char *pad2(int n) {
  if (n < 10) {
    char *tmp8 = _str(n);
    char *tmp9 = concat_string("0", tmp8);
    return tmp9;
  }
  char *tmp10 = _str(n);
  return tmp10;
}

const char *dateString(int y, int m, int d) {
  char *tmp11 = _str(y);
  char *tmp12 = concat_string(tmp11, "-");
  return tmp12 + pad2(m) + "-" + pad2(d);
}

int day(int y, int m, int d) {
  int part1 = 367 * y;
  int part2 = (int)(((7 * ((int)((y + ((m + 9) / 12))))) / 4));
  int part3 = (int)(((275 * m) / 9));
  return part1 - part2 + part3 + d - 730530;
}

int biorhythms(char *birth, char *target) {
  list_int bparts = parseDate(birth);
  int by = bparts.data[0];
  int bm = bparts.data[1];
  int bd = bparts.data[2];
  list_int tparts = parseDate(target);
  int ty = tparts.data[0];
  int tm = tparts.data[1];
  int td = tparts.data[2];
  int diff = absInt(day(ty, tm, td) - day(by, bm, bd));
  char *tmp13 = concat_string("Born ", birth);
  char *tmp14 = concat_string(tmp13, ", Target ");
  char *tmp15 = concat_string(tmp14, target);
  printf("%s\n", tmp15);
  char *tmp16 = _str(diff);
  char *tmp17 = concat_string("Day ", tmp16);
  printf("%s\n", tmp17);
  list_string cycles = list_string_create(3);
  cycles.data[0] = "Physical day ";
  cycles.data[1] = "Emotional day";
  cycles.data[2] = "Mental day   ";
  int cycles = cycles;
  list_int lengths = list_int_create(3);
  lengths.data[0] = 23;
  lengths.data[1] = 28;
  lengths.data[2] = 33;
  list_string quadrants = list_string_create(2);
  quadrants.data[0] = "up and rising";
  quadrants.data[1] = "peak";
  list_string quadrants = list_string_create(2);
  quadrants.data[0] = "up but falling";
  quadrants.data[1] = "transition";
  list_string quadrants = list_string_create(2);
  quadrants.data[0] = "down and falling";
  quadrants.data[1] = "valley";
  list_string quadrants = list_string_create(2);
  quadrants.data[0] = "down but rising";
  quadrants.data[1] = "transition";
  list_int quadrants_data[] = {quadrants, quadrants, quadrants, quadrants};
  list_list_int quadrants = {4, quadrants_data};
  list_int quadrants = quadrants;
  int i = 0;
  while (i < 3) {
    int length = lengths.data[i];
    const char *cycle = cycles.data[i];
    int position = diff % length;
    int quadrant = (position * 4) / length;
    double percent =
        sinApprox(2.0 * PI * ((double)(position)) / ((double)(length)));
    percent = floor(percent * 1000.0) / 10.0;
    const char *description = "";
    if (percent > 95.0) {
      description = " peak";
    } else if (percent < ((-95.0))) {
      description = " valley";
    } else if (absFloat(percent) < 5.0) {
      description = " critical transition";
    } else {
      int daysToAdd = (quadrant + 1) * length / 4 - position;
      list_int res = addDays(ty, tm, td, daysToAdd);
      int ny = res.data[0];
      int nm = res.data[1];
      int nd = res.data[2];
      const char *transition = dateString(ny, nm, nd);
      const char *trend = quadrants.data[quadrant].data[0];
      const char *next = quadrants.data[quadrant].data[1];
      char *tmp18 = _str(percent);
      const char *pct = tmp18;
      if ((!contains(pct, "."))) {
        char *tmp19 = concat_string(pct, ".0");
        pct = tmp19;
      }
      char *tmp20 = concat_string(" ", pct);
      char *tmp21 = concat_string(tmp20, "% (");
      char *tmp22 = concat_string(tmp21, trend);
      char *tmp23 = concat_string(tmp22, ", next ");
      char *tmp24 = concat_string(tmp23, next);
      char *tmp25 = concat_string(tmp24, " ");
      char *tmp26 = concat_string(tmp25, transition);
      char *tmp27 = concat_string(tmp26, ")");
      description = tmp27;
    }
    char *tmp28 = _str(position);
    const char *posStr = tmp28;
    if ((position < 10)) {
      char *tmp29 = concat_string(" ", posStr);
      posStr = tmp29;
    }
    char *tmp30 = concat_string(cycle, posStr);
    char *tmp31 = concat_string(tmp30, " : ");
    char *tmp32 = concat_string(tmp31, description);
    printf("%s\n", tmp32);
    i = i + 1;
  }
  printf("\n");
}

int main() {
  list_string pairs = list_string_create(2);
  pairs.data[0] = "1943-03-09";
  pairs.data[1] = "1972-07-11";
  list_string pairs = list_string_create(2);
  pairs.data[0] = "1809-01-12";
  pairs.data[1] = "1863-11-19";
  list_string pairs = list_string_create(2);
  pairs.data[0] = "1809-02-12";
  pairs.data[1] = "1863-11-19";
  list_int pairs_data[] = {pairs, pairs, pairs};
  list_list_int pairs = {3, pairs_data};
  list_int pairs = pairs;
  int idx = 0;
  while (idx < pairs.len) {
    int p = pairs.data[idx];
    biorhythms(p.data[0], p.data[1]);
    idx = idx + 1;
  }
}

int main() {
  main();
  return 0;
}
