// Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static list_int slice_list_int(list_int v, int start, int end) {
  if (start < 0)
    start += v.len;
  if (end < 0)
    end += v.len;
  if (start < 0)
    start = 0;
  if (end > v.len)
    end = v.len;
  if (start > end)
    start = end;
  list_int r = list_int_create(end - start);
  for (int i = 0; i < r.len; i++)
    r.data[i] = v.data[start + i];
  return r;
}
static int THRESHOLD = 140737488355328;

typedef struct {
  list_int seq;
  const char *aliquot;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  list_int seq;
  const char *aliquot;
} tmp_item1_t;
typedef struct {
  int len;
  tmp_item1_t *data;
} tmp_item1_list_t;
tmp_item1_list_t create_tmp_item1_list(int len) {
  tmp_item1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int indexOf(list_int xs, int value) {
  int i = 0;
  while (i < xs.len) {
    if (xs.data[i] == value) {
      return i;
    }
    i = i + 1;
  }
  return 0 - 1;
}

int contains(list_int xs, int value) { return indexOf(xs, value) != 0 - 1; }

int maxOf(int a, int b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

int intSqrt(int n) {
  if (n == 0) {
    return 0;
  }
  int x = n;
  double y = ((double)(x + 1)) / ((double)2);
  while (y < x) {
    x = y;
    y = (((double)x + n) / ((double)x)) / 2;
  }
  return x;
}

int sumProperDivisors(int n) {
  if (n < 2) {
    return 0;
  }
  int sqrt = intSqrt(n);
  int sum = 1;
  int i = 2;
  while (i <= sqrt) {
    if (n % i == 0) {
      sum = sum + i + n / i;
    }
    i = i + 1;
  }
  if (sqrt * sqrt == n) {
    sum = sum - sqrt;
  }
  return sum;
}

int classifySequence(int k) {
  int last = k;
  list_int seq = list_int_create(1);
  seq.data[0] = k;
  list_int seq = seq;
  while (1) {
    last = sumProperDivisors(last);
    int tmp1_data[1];
    list_int tmp1 = {1, tmp1_data};
    tmp1.data[0] = last;
    list_int tmp2 = concat_list_int(seq, tmp1);
    seq = tmp2;
    int n = 1;
    const char *aliquot = "";
    if (last == 0) {
      aliquot = "Terminating";
    } else if (n == 2 && last == k) {
      aliquot = "Perfect";
    } else if (n == 3 && last == k) {
      aliquot = "Amicable";
    } else if (n >= 4 && last == k) {
      char *tmp3 = _str(n - 1);
      char *tmp4 = concat_string("Sociable[", tmp3);
      char *tmp5 = concat_string(tmp4, "]");
      aliquot = tmp5;
    } else if (last == seq.data[n - 2]) {
      aliquot = "Aspiring";
    } else
      list_int tmp7 = {1, seq};
    list_int tmp6 = slice_list_int(tmp7, 1, maxOf(1, n - 2));
    if ((contains(tmp6, last))) {
      int idx = indexOf(seq, last);
      char *tmp8 = _str(n - 1 - idx);
      char *tmp9 = concat_string("Cyclic[", tmp8);
      char *tmp10 = concat_string(tmp9, "]");
      aliquot = tmp10;
    } else if (n == 16 || last > THRESHOLD) {
      aliquot = "Non-Terminating";
    }
    if ((strcmp(aliquot, "") != 0)) {
      return (tmp_item_t){.seq = seq, .aliquot = aliquot};
    }
  }
  return (tmp_item1_t){.seq = seq, .aliquot = ""};
}

const char *padLeft(int n, int w) {
  char *tmp11 = _str(n);
  const char *s = tmp11;
  while (strlen(s) < w) {
    char *tmp12 = concat_string(" ", s);
    s = tmp12;
  }
  return s;
}

const char *padRight(char *s, int w) {
  const char *r = s;
  while (strlen(r) < w) {
    char *tmp13 = concat_string(r, " ");
    r = tmp13;
  }
  return r;
}

const char *joinWithCommas(list_int seq) {
  const char *s = "[";
  int i = 0;
  while (i < 1) {
    char *tmp14 = _str(seq.data[i]);
    char *tmp15 = concat_string(s, tmp14);
    s = tmp15;
    if (i < 1 - 1) {
      char *tmp16 = concat_string(s, ", ");
      s = tmp16;
    }
    i = i + 1;
  }
  char *tmp17 = concat_string(s, "]");
  s = tmp17;
  return s;
}

int main() {
  printf("Aliquot classifications - periods for Sociable/Cyclic in square "
         "brackets:\\n\n");
  int k = 1;
  while (k <= 10) {
    int res = classifySequence(k);
    printf("%s\n", padLeft(k, 2) + ": " +
                       padRight((char *)(res.data["aliquot"]), 15) + " " +
                       joinWithCommas((list_int)(res.data["seq"])));
    k = k + 1;
  }
  printf("\n");
  list_int s = list_int_create(13);
  s.data[0] = 11;
  s.data[1] = 12;
  s.data[2] = 28;
  s.data[3] = 496;
  s.data[4] = 220;
  s.data[5] = 1184;
  s.data[6] = 12496;
  s.data[7] = 1264460;
  s.data[8] = 790;
  s.data[9] = 909;
  s.data[10] = 562;
  s.data[11] = 1064;
  s.data[12] = 1488;
  int i = 0;
  while ((i < 13)) {
    int val = s.data[i];
    int res = classifySequence(val);
    printf("%s\n", padLeft(val, 7) + ": " +
                       padRight((char *)(res.data["aliquot"]), 15) + " " +
                       joinWithCommas((list_int)(res.data["seq"])));
    i = i + 1;
  }
  printf("\n");
  int big = 15355717786080;
  int r = classifySequence(big);
  char *tmp18 = _str(big);
  char *tmp19 = concat_string(tmp18, ": ");
  printf("%s\n", tmp19 + padRight((char *)(r.data["aliquot"]), 15) + " " +
                     joinWithCommas((list_int)(r.data["seq"])));
}

int main() {
  main();
  return 0;
}
