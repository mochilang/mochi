// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:49Z
// Generated by Mochi compiler v0.10.26 on 2025-07-16T12:35:49Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
typedef struct {
  int data;
  int balance;
  int link;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int node;
  int done;
} tmp_item1_t;
typedef struct {
  int len;
  tmp_item1_t *data;
} tmp_item1_list_t;
tmp_item1_list_t create_tmp_item1_list(int len) {
  tmp_item1_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item1_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int node;
  int done;
} tmp_item2_t;
typedef struct {
  int len;
  tmp_item2_t *data;
} tmp_item2_list_t;
tmp_item2_list_t create_tmp_item2_list(int len) {
  tmp_item2_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item2_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int node;
  int done;
} tmp_item3_t;
typedef struct {
  int len;
  tmp_item3_t *data;
} tmp_item3_list_t;
tmp_item3_list_t create_tmp_item3_list(int len) {
  tmp_item3_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item3_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int node;
  int done;
} tmp_item4_t;
typedef struct {
  int len;
  tmp_item4_t *data;
} tmp_item4_list_t;
tmp_item4_list_t create_tmp_item4_list(int len) {
  tmp_item4_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item4_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int node;
  int done;
} tmp_item5_t;
typedef struct {
  int len;
  tmp_item5_t *data;
} tmp_item5_list_t;
tmp_item5_list_t create_tmp_item5_list(int len) {
  tmp_item5_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item5_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int Node(int data) {
  list_int tmp1 = list_int_create(2);
  tmp1.data[0] = 0;
  tmp1.data[1] = 0;
  return (tmp_item_t){.data = data, .balance = 0, .link = tmp1};
}

int getLink(map_string_int n, int dir) {
  return ((list_int)(n.data["Link"])).data[dir];
}

int setLink(map_string_int n, int dir, int v) {
  list_int links = (list_int)(n.data["Link"]);
  links.data[dir] = v;
  n.data["Link"] = links;
}

int opp(int dir) { return 1 - dir; }

int single(map_string_int root, int dir) {
  int tmp = getLink(root, opp(dir));
  setLink(root, opp(dir), getLink(tmp, dir));
  setLink(tmp, dir, root);
  return tmp;
}

int _double(map_string_int root, int dir) {
  int tmp = getLink(getLink(root, opp(dir)), dir);
  setLink(getLink(root, opp(dir)), dir, getLink(tmp, opp(dir)));
  setLink(tmp, opp(dir), getLink(root, opp(dir)));
  setLink(root, opp(dir), tmp);
  tmp = getLink(root, opp(dir));
  setLink(root, opp(dir), getLink(tmp, dir));
  setLink(tmp, dir, root);
  return tmp;
}

int adjustBalance(map_string_int root, int dir, int bal) {
  int n = (map_string_int)(getLink(root, dir));
  int nn = (map_string_int)(getLink(n, opp(dir)));
  if ((nn.data["Balance"] == 0)) {
    root.data["Balance"] = 0;
    n.data["Balance"] = 0;
  } else if ((nn.data["Balance"] == bal)) {
    root.data["Balance"] = (-bal);
    n.data["Balance"] = 0;
  } else {
    root.data["Balance"] = 0;
    n.data["Balance"] = bal;
  }
  nn.data["Balance"] = 0;
}

int insertBalance(map_string_int root, int dir) {
  int n = (map_string_int)(getLink(root, dir));
  int bal = 2 * dir - 1;
  if ((n.data["Balance"] == bal)) {
    root.data["Balance"] = 0;
    n.data["Balance"] = 0;
    return single(root, opp(dir));
  }
  adjustBalance(root, dir, bal);
  return _double(root, opp(dir));
}

int insertR(int root, int data) {
  if ((root == 0)) {
    return (tmp_item_t){.node = Node(data), .done = 0};
  }
  int node = (map_string_int)(root);
  int dir = 0;
  if (((int)(node.data["Data"])) < data) {
    dir = 1;
  }
  int r = insertR(getLink(node, dir), data);
  setLink(node, dir, r.data["node"]);
  if ((r.data["done"])) {
    return (tmp_item1_t){.node = node, .done = 1};
  }
  node.data["Balance"] = ((int)(node.data["Balance"])) + (2 * dir - 1);
  if ((node.data["Balance"] == 0)) {
    return (tmp_item2_t){.node = node, .done = 1};
  }
  if ((node.data["Balance"] == 1 || node.data["Balance"] == ((-1)))) {
    return (tmp_item3_t){.node = node, .done = 0};
  }
  return (tmp_item4_t){.node = insertBalance(node, dir), .done = 1};
}

int Insert(int tree, int data) {
  int r = insertR(tree, data);
  return r.data["node"];
}

int removeBalance(map_string_int root, int dir) {
  int n = (map_string_int)(getLink(root, opp(dir)));
  int bal = 2 * dir - 1;
  if ((n.data["Balance"] == ((-bal)))) {
    root.data["Balance"] = 0;
    n.data["Balance"] = 0;
    return (tmp_item_t){.node = single(root, dir), .done = 0};
  }
  if ((n.data["Balance"] == bal)) {
    adjustBalance(root, opp(dir), ((-bal)));
    return (tmp_item1_t){.node = _double(root, dir), .done = 0};
  }
  root.data["Balance"] = (-bal);
  n.data["Balance"] = bal;
  return (tmp_item2_t){.node = single(root, dir), .done = 1};
}

int removeR(int root, int data) {
  if ((root == 0)) {
    return (tmp_item_t){.node = 0, .done = 0};
  }
  int node = (map_string_int)(root);
  if (((int)(node.data["Data"])) == data) {
    if ((getLink(node, 0) == 0)) {
      return (tmp_item1_t){.node = getLink(node, 1), .done = 0};
    }
    if ((getLink(node, 1) == 0)) {
      return (tmp_item2_t){.node = getLink(node, 0), .done = 0};
    }
    int heir = getLink(node, 0);
    while ((getLink(heir, 1) != 0)) {
      heir = getLink(heir, 1);
    }
    node.data["Data"] = heir.data["Data"];
    data = (int)(heir.data["Data"]);
  }
  int dir = 0;
  if (((int)(node.data["Data"])) < data) {
    dir = 1;
  }
  int r = removeR(getLink(node, dir), data);
  setLink(node, dir, r.data["node"]);
  if ((r.data["done"])) {
    return (tmp_item3_t){.node = node, .done = 1};
  }
  node.data["Balance"] = ((int)(node.data["Balance"])) + 1 - 2 * dir;
  if ((node.data["Balance"] == 1 || node.data["Balance"] == ((-1)))) {
    return (tmp_item4_t){.node = node, .done = 1};
  }
  if ((node.data["Balance"] == 0)) {
    return (tmp_item5_t){.node = node, .done = 0};
  }
  return removeBalance(node, dir);
}

int Remove(int tree, int data) {
  int r = removeR(tree, data);
  return r.data["node"];
}

const char *indentStr(int n) {
  const char *s = "";
  int i = 0;
  while (i < n) {
    char *tmp2 = concat_string(s, " ");
    s = tmp2;
    i = i + 1;
  }
  return s;
}

int dumpNode(int node, int indent, int comma) {
  const char *sp = indentStr(indent);
  if ((node == 0)) {
    char *tmp3 = concat_string(sp, "null");
    const char *line = tmp3;
    if (comma) {
      char *tmp4 = concat_string(line, ",");
      line = tmp4;
    }
    printf("%s\n", line);
  } else {
    char *tmp5 = concat_string(sp, "{");
    printf("%s\n", tmp5);
    char *tmp6 = _str(node.data["Data"]);
    char *tmp7 = _str(node.data["Data"]);
    printf("%d\n", indentStr(indent + 3) + "\"Data\": " + tmp7 + ",");
    char *tmp8 = _str(node.data["Balance"]);
    char *tmp9 = _str(node.data["Balance"]);
    printf("%d\n", indentStr(indent + 3) + "\"Balance\": " + tmp9 + ",");
    printf("%s\n", indentStr(indent + 3) + "\"Link\": [");
    dumpNode(getLink(node, 0), indent + 6, 1);
    dumpNode(getLink(node, 1), indent + 6, 0);
    printf("%s\n", indentStr(indent + 3) + "]");
    char *tmp10 = concat_string(sp, "}");
    const char *end = tmp10;
    if (comma) {
      char *tmp11 = concat_string(end, ",");
      end = tmp11;
    }
    printf("%s\n", end);
  }
}

int dump(int node, int indent) { dumpNode(node, indent, 0); }

int main() {
  int tree = 0;
  printf("Empty tree:\n");
  dump(tree, 0);
  printf("\n");
  printf("Insert test:\n");
  tree = Insert(tree, 3);
  tree = Insert(tree, 1);
  tree = Insert(tree, 4);
  tree = Insert(tree, 1);
  tree = Insert(tree, 5);
  dump(tree, 0);
  printf("\n");
  printf("Remove test:\n");
  tree = Remove(tree, 3);
  tree = Remove(tree, 1);
  int t = (map_string_int)(tree);
  t.data["Balance"] = 0;
  tree = t;
  dump(tree, 0);
}

int main() {
  main();
  return 0;
}
