// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:23:43Z
// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:23:43Z
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct {
  int len;
  int *data;
} list_int;
static list_int list_int_create(int len) {
  list_int l;
  l.len = len;
  l.data = calloc(len, sizeof(int));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}
typedef struct {
  char *key;
  int value;
} pair_string_int;
static pair_string_int pair_string_int_new(char *key, int value) {
  pair_string_int p;
  p.key = key;
  p.value = value;
  return p;
}
typedef struct {
  int len;
  int cap;
  pair_string_int *data;
} map_string_int;
static map_string_int map_string_int_create(int cap) {
  map_string_int m;
  m.len = 0;
  m.cap = cap;
  m.data = cap ? calloc(cap, sizeof(pair_string_int)) : NULL;
  if (cap && !m.data) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return m;
}
static void map_string_int_put(map_string_int *m, char *k, int v) {
  for (int i = 0; i < m->len; i++)
    if (strcmp(m->data[i].key, k) == 0) {
      m->data[i].value = v;
      return;
    }
  if (m->len >= m->cap) {
    m->cap = m->cap ? m->cap * 2 : 4;
    m->data =
        (pair_string_int *)realloc(m->data, sizeof(pair_string_int) * m->cap);
  }
  m->data[m->len++] = pair_string_int_new(k, v);
}
static int map_string_int_get(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return m.data[i].value;
  return 0;
}
static int map_string_int_contains(map_string_int m, const char *k) {
  for (int i = 0; i < m.len; i++)
    if (strcmp(m.data[i].key, k) == 0)
      return 1;
  return 0;
}
static int cmp_map_string_int(map_string_int a, map_string_int b) {
  int aa = map_string_int_get(a, "a");
  int ba = map_string_int_get(b, "a");
  if (aa != ba)
    return aa > ba ? 1 : -1;
  int ab = map_string_int_get(a, "b");
  int bb = map_string_int_get(b, "b");
  if (ab != bb)
    return ab > bb ? 1 : -1;
  return 0;
}
static list_int concat_list_int(list_int a, list_int b) {
  list_int r = list_int_create(a.len + b.len);
  for (int i = 0; i < a.len; i++)
    r.data[i] = a.data[i];
  for (int i = 0; i < b.len; i++)
    r.data[a.len + i] = b.data[i];
  return r;
}
static char *concat_string(char *a, char *b) {
  size_t len1 = strlen(a);
  size_t len2 = strlen(b);
  char *buf = (char *)malloc(len1 + len2 + 1);
  memcpy(buf, a, len1);
  memcpy(buf + len1, b, len2);
  buf[len1 + len2] = '\0';
  return buf;
}
static char *_str(int v) {
  char *buf = (char *)malloc(32);
  sprintf(buf, "%d", v);
  return buf;
}
static long long _now() {
  struct timespec ts;
  clock_gettime(CLOCK_REALTIME, &ts);
  return (long long)ts.tv_sec * 1000000000LL + ts.tv_nsec;
}
static int OP_NUM = 0;
static int OP_ADD = 1;
static int OP_SUB = 2;
static int OP_MUL = 3;
static int OP_DIV = 4;
static int n_cards = 4;
static int goal = 24;
static int digit_range = 9;

typedef struct {
  int num;
  int denom;
} value_item_t;
typedef struct {
  int len;
  value_item_t *data;
} value_item_list_t;
value_item_list_t create_value_item_list(int len) {
  value_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(value_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int op;
  value_item_t value;
} tmp_item_t;
typedef struct {
  int len;
  tmp_item_t *data;
} tmp_item_list_t;
tmp_item_list_t create_tmp_item_list(int len) {
  tmp_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(tmp_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

typedef struct {
  int op;
  int left;
  int right;
} node_item_t;
typedef struct {
  int len;
  node_item_t *data;
} node_item_list_t;
node_item_list_t create_node_item_list(int len) {
  node_item_list_t l;
  l.len = len;
  l.data = calloc(len, sizeof(node_item_t));
  if (!l.data && len > 0) {
    fprintf(stderr, "alloc failed\n");
    exit(1);
  }
  return l;
}

int newNum(int n) {
  return (tmp_item_t){.op = OP_NUM,
                      .value = (value_item_t){.num = n, .denom = 1}};
}

map_string_int exprEval(map_string_int x) {
  if ((x.data["op"] == OP_NUM)) {
    return x.data["value"];
  }
  map_string_int l = exprEval(x.data["left"]);
  map_string_int r = exprEval(x.data["right"]);
  if ((x.data["op"] == OP_ADD)) {
    map_string_int tmp1 = map_string_int_create(2);
    map_string_int_put(
        &tmp1, "num",
        map_string_int_get(l, "num") * map_string_int_get(r, "denom") +
            map_string_int_get(l, "denom") * map_string_int_get(r, "num"));
    map_string_int_put(&tmp1, "denom",
                       map_string_int_get(l, "denom") *
                           map_string_int_get(r, "denom"));
    return tmp1;
  }
  if ((x.data["op"] == OP_SUB)) {
    map_string_int tmp2 = map_string_int_create(2);
    map_string_int_put(
        &tmp2, "num",
        map_string_int_get(l, "num") * map_string_int_get(r, "denom") -
            map_string_int_get(l, "denom") * map_string_int_get(r, "num"));
    map_string_int_put(&tmp2, "denom",
                       map_string_int_get(l, "denom") *
                           map_string_int_get(r, "denom"));
    return tmp2;
  }
  if ((x.data["op"] == OP_MUL)) {
    map_string_int tmp3 = map_string_int_create(2);
    map_string_int_put(&tmp3, "num",
                       map_string_int_get(l, "num") *
                           map_string_int_get(r, "num"));
    map_string_int_put(&tmp3, "denom",
                       map_string_int_get(l, "denom") *
                           map_string_int_get(r, "denom"));
    return tmp3;
  }
  map_string_int tmp4 = map_string_int_create(2);
  map_string_int_put(&tmp4, "num",
                     map_string_int_get(l, "num") *
                         map_string_int_get(r, "denom"));
  map_string_int_put(&tmp4, "denom",
                     map_string_int_get(l, "denom") *
                         map_string_int_get(r, "num"));
  return tmp4;
}

char *exprString(map_string_int x) {
  if ((x.data["op"] == OP_NUM)) {
    char *tmp5 = _str(x.data["value"].data["num"]);
    return tmp5;
  }
  char *ls = exprString(x.data["left"]);
  char *rs = exprString(x.data["right"]);
  char *opstr = "";
  if ((x.data["op"] == OP_ADD)) {
    opstr = " + ";
  } else if ((x.data["op"] == OP_SUB)) {
    opstr = " - ";
  } else if ((x.data["op"] == OP_MUL)) {
    opstr = " * ";
  } else {
    opstr = " / ";
  }
  char *tmp6 = concat_string("(", ls);
  char *tmp7 = concat_string(tmp6, opstr);
  char *tmp8 = concat_string(tmp7, rs);
  char *tmp9 = concat_string(tmp8, ")");
  return tmp9;
}

int solve(int xs) {
  if (xs.len == 1) {
    map_string_int f = exprEval(xs.data[0]);
    if (map_string_int_get(f, "denom") != 0 &&
        map_string_int_get(f, "num") == map_string_int_get(f, "denom") * goal) {
      printf("%s\n", exprString(xs.data[0]));
      return 1;
    }
    return 0;
  }
  int i = 0;
  while (i < xs.len) {
    int j = i + 1;
    while (j < xs.len) {
      list_int rest = list_int_create(0);
      int k = 0;
      while (k < xs.len) {
        if (k != i && k != j) {
          int tmp10_data[1];
          list_int tmp10 = {1, tmp10_data};
          tmp10.data[0] = xs.data[k];
          list_int tmp11 = concat_list_int(rest, tmp10);
          rest = tmp11;
        }
        k = k + 1;
      }
      int a = xs.data[i];
      int b = xs.data[j];
      list_int tmp12 = list_int_create(4);
      tmp12.data[0] = OP_ADD;
      tmp12.data[1] = OP_SUB;
      tmp12.data[2] = OP_MUL;
      tmp12.data[3] = OP_DIV;
      for (int tmp13 = 0; tmp13 < 4; tmp13++) {
        int op = tmp12.data[tmp13];
        node_item_t node = (node_item_t){.op = op, .left = a, .right = b};
        int tmp14_data[1];
        list_int tmp14 = {1, tmp14_data};
        tmp14.data[0] = node;
        list_int tmp15 = concat_list_int(rest, tmp14);
        if (solve(tmp15)) {
          return 1;
        }
      }
      node_item_t node = (node_item_t){.op = OP_SUB, .left = b, .right = a};
      int tmp16_data[1];
      list_int tmp16 = {1, tmp16_data};
      tmp16.data[0] = node;
      list_int tmp17 = concat_list_int(rest, tmp16);
      if (solve(tmp17)) {
        return 1;
      }
      node = (tmp_item_t){.op = OP_DIV, .left = b, .right = a};
      int tmp18_data[1];
      list_int tmp18 = {1, tmp18_data};
      tmp18.data[0] = node;
      list_int tmp19 = concat_list_int(rest, tmp18);
      if (solve(tmp19)) {
        return 1;
      }
      j = j + 1;
    }
    i = i + 1;
  }
  return 0;
}

int mochi_main() {
  int iter = 0;
  while (iter < 10) {
    list_int cards = list_int_create(0);
    int i = 0;
    while (i < n_cards) {
      int n = (_now() % (digit_range - 1)) + 1;
      int tmp20_data[1];
      list_int tmp20 = {1, tmp20_data};
      tmp20.data[0] = newNum(n);
      list_int tmp21 = concat_list_int(cards, tmp20);
      cards = tmp21;
      char *tmp22 = _str(n);
      char *tmp23 = concat_string(" ", tmp22);
      printf("%s\n", tmp23);
      i = i + 1;
    }
    printf(":  \n");
    if (((!solve(cards)))) {
      printf("No solution\n");
    }
    iter = iter + 1;
  }
}

int _mochi_main() {
  mochi_main();
  return 0;
}
int main() { return _mochi_main(); }
