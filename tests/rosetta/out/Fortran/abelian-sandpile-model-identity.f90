! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program abelian_sandpile_model_identity
  implicit none
  integer, dimension(9) :: s4
  integer, dimension(9) :: s1
  integer, dimension(9) :: s2
  integer :: s3_a
  integer :: s3_b
  integer, dimension(9) :: s3
  integer, dimension(9) :: s3_id
  integer :: s4b
  integer :: s5
  character(len=256) :: pbuf0
  character(len=256) :: pbuf1
  character(len=256) :: pbuf2
  character(len=256) :: pbuf3
    integer, allocatable, dimension(:) :: res
    integer :: i
      integer, allocatable, dimension(:) :: app4
    integer :: v
    integer :: i5
    integer :: neighbors
    integer :: nbs
    integer :: j
        integer :: i6
    character(len=100) :: s
    integer :: r
    integer :: c
        character(len=100) :: s7
  print *, 'Avalanche of topplings:'//char(10)//''
  s4 = (/4,3,3,3,1,2,0,2,3/)
  print *, pileString(s4)
  do while (.not. isStable(s4))
    topple(s4)
    print *, pileString(s4)
  end do
  print *, 'Commutative additions:'//char(10)//''
  s1 = (/1,2,0,2,1,1,0,1,3/)
  s2 = (/2,1,3,1,0,1,0,1,0/)
  s3_a = plus(s1,s2)
  do while (.not. isStable(s3_a))
    topple(s3_a)
  end do
  s3_b = plus(s2,s1)
  do while (.not. isStable(s3_b))
    topple(s3_b)
  end do
  pbuf0 = trim(trim(trim(pileString(s1) // ''//char(10)//'plus'//char(10)//''//char(10)//'') // pileString(s2)) // ''//char(10)//'equals'//char(10)//''//char(10)//'') // pileString(s3_a)
  print *, pbuf0
  pbuf1 = trim(trim(trim(trim('and'//char(10)//''//char(10)//'' // pileString(s2)) // ''//char(10)//'plus'//char(10)//''//char(10)//'') // pileString(s1)) // ''//char(10)//'also equals'//char(10)//''//char(10)//'') // pileString(s3_b)
  print *, pbuf1
  print *, 'Addition of identity sandpile:'//char(10)//''
  s3 = (/3,3,3,3,3,3,3,3,3/)
  s3_id = (/2,1,2,1,0,1,2,1,2/)
  s4b = plus(s3,s3_id)
  do while (.not. isStable(s4b))
    topple(s4b)
  end do
  pbuf2 = trim(trim(trim(pileString(s3) // ''//char(10)//'plus'//char(10)//''//char(10)//'') // pileString(s3_id)) // ''//char(10)//'equals'//char(10)//''//char(10)//'') // pileString(s4b)
  print *, pbuf2
  print *, 'Addition of identities:'//char(10)//''
  s5 = plus(s3_id,s3_id)
  do while (.not. isStable(s5))
    topple(s5)
  end do
  pbuf3 = trim(trim(trim(pileString(s3_id) // ''//char(10)//'plus'//char(10)//''//char(10)//'') // pileString(s3_id)) // ''//char(10)//'equals'//char(10)//''//char(10)//'') // pileString(s5)
  print *, pbuf3
  
  contains
  recursive integer function neighborsList() result(res)
    res = (/(/1,3/),(/0,2,4/),(/1,5/),(/0,4,6/),(/1,3,5,7/),(/2,4,8/),(/3,7/),(/4,6,8/),(/5,7/)/)
    return
  end function neighborsList
  recursive integer function plus(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    allocate(res(0))
    i = 0
    do while ((i < size(a)))
      if (allocated(app4)) deallocate(app4)
      allocate(app4(size(res)+1))
      app4(1:size(res)) = res
      app4(size(res)+1) = (a(((i)+1)) + b(((i)+1)))
      res = app4
      i = (i + 1)
    end do
    res = res
    return
  end function plus
  recursive logical function isStable(p) result(res)
    integer, intent(in) :: p
    do i5 = 1, size(p)
      v = p(i5)
      if ((v > 3)) then
        res = .false.
        return
      end if
    end do
    res = .true.
    return
  end function isStable
  recursive integer function topple(p) result(res)
    integer, intent(in) :: p
    neighbors = neighborsList()
    i = 0
    do while ((i < size(p)))
      if ((p(((i)+1)) > 3)) then
        p(((i)+1)) = (p(((i)+1)) - 4)
        nbs = neighbors(((i)+1))
        do i6 = 1, size(nbs)
          j = nbs(i6)
          p(((j)+1)) = (p(((j)+1)) + 1)
        end do
        res = 0
        return
      end if
      i = (i + 1)
    end do
    res = 0
    return
  end function topple
  recursive character(len=100) function pileString(p) result(res)
    integer, intent(in) :: p
    s = ''
    r = 0
    do while ((r < 3))
      c = 0
      do while ((c < 3))
        write(s7,'(G0)') p(((((3 * r) + c))+1))
        s = (s + s7) // ' '
        c = (c + 1)
      end do
      s = s // ''//char(10)//''
      r = (r + 1)
    end do
    res = s
    return
  end function pileString
end program abelian_sandpile_model_identity
