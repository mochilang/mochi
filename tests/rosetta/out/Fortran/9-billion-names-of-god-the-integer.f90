! Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
program p_9_billion_names_of_god_the_integer
  implicit none
  integer :: x
    integer :: r
    character(len=100) :: line
    integer :: i
  integer :: num
  integer, dimension(3) :: arr0 = (/23,123,1234/)
  integer :: i0
    character(len=100) :: s1
    integer :: n
    integer, allocatable, dimension(:) :: digits
      integer, allocatable, dimension(:) :: app2
    integer, allocatable, dimension(:) :: res
    integer :: carry
      integer :: av
      integer :: bv
      integer :: s
      integer, allocatable, dimension(:) :: app3
    integer :: borrow
      integer :: diff
      integer, allocatable, dimension(:) :: app4
      character(len=100) :: s5
    integer, dimension(1,1) :: cache
    integer :: y
      integer, dimension(1) :: row
        integer :: val
        integer, allocatable, dimension(:) :: app6
      integer, allocatable, dimension(:) :: app7
    integer :: e
    integer, allocatable, dimension(:) :: out
      integer, allocatable, dimension(:) :: app8
  print *, 'rows:'
  x = 1
  do while ((x < 11))
    r = row(x)
    line = ''
    i = 0
    do while ((i < size(r)))
      line = trim(trim(line // ' ') // r(((i)+1))) // ' '
      i = (i + 1)
    end do
    print *, line
    x = (x + 1)
  end do
  print *, ''
  print *, 'sums:'
  do i0 = 1, 3
    num = arr0(i0)
    r = cumu(num)
    write(s1,'(G0)') num
    print *, trim(s1 // ' ') // bigToString(r((((size(r) - 1))+1)))
  end do
  contains
  recursive integer function bigTrim(a) result(res)
    integer, intent(in) :: a
    n = size(a)
    do while ((((n > 1) .and. a((((n - 1))+1))) == 0))
      a = a(1:(n - 1))
      n = (n - 1)
    end do
    res = a
    return
  end function bigTrim
  recursive integer function bigFromInt(x) result(res)
    integer, intent(in) :: x
    if ((x == 0)) then
      res = (/0/)
      return
    end if
    allocate(digits(0))
    n = x
    do while ((n > 0))
      if (allocated(app2)) deallocate(app2)
      allocate(app2(size(digits)+1))
      app2(1:size(digits)) = digits
      app2(size(digits)+1) = mod(n,10)
      digits = app2
      n = (n / 10)
    end do
    res = digits
    return
  end function bigFromInt
  recursive integer function bigAdd(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    allocate(res(0))
    carry = 0
    i = 0
    do while ((((((i < size(a)) .or. i) < size(b)) .or. carry) > 0))
      av = 0
      if ((i < size(a))) then
        av = a(((i)+1))
      end if
      bv = 0
      if ((i < size(b))) then
        bv = b(((i)+1))
      end if
      s = ((av + bv) + carry)
      if (allocated(app3)) deallocate(app3)
      allocate(app3(size(res)+1))
      app3(1:size(res)) = res
      app3(size(res)+1) = mod(s,10)
      res = app3
      carry = (s / 10)
      i = (i + 1)
    end do
    res = bigTrim(res)
    return
  end function bigAdd
  recursive integer function bigSub(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    allocate(res(0))
    borrow = 0
    i = 0
    do while ((i < size(a)))
      av = a(((i)+1))
      bv = 0
      if ((i < size(b))) then
        bv = b(((i)+1))
      end if
      diff = ((av - bv) - borrow)
      if ((diff < 0)) then
        diff = (diff + 10)
        borrow = 1
      else
        borrow = 0
      end if
      if (allocated(app4)) deallocate(app4)
      allocate(app4(size(res)+1))
      app4(1:size(res)) = res
      app4(size(res)+1) = diff
      res = app4
      i = (i + 1)
    end do
    res = bigTrim(res)
    return
  end function bigSub
  recursive character(len=100) function bigToString(a) result(res)
    integer, intent(in) :: a
    s = ''
    i = (size(a) - 1)
    do while ((i >= 0))
      write(s5,'(G0)') a(((i)+1))
      s = (s + s5)
      i = (i - 1)
    end do
    res = s
    return
  end function bigToString
  recursive integer function minInt(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    if ((a < b)) then
      res = a
      return
    else
      res = b
      return
    end if
  end function minInt
  recursive integer function cumu(n) result(res)
    integer, intent(in) :: n
    cache = reshape((/bigFromInt(1)/),(/1,1/))
    y = 1
    do while ((y <= n))
      row = (/bigFromInt(0)/)
      x = 1
      do while ((x <= y))
        val = cache((((y - x))+1),((minInt(x,(y - x)))+1))
        if (allocated(app6)) deallocate(app6)
        allocate(app6(size(row)+1))
        app6(1:size(row)) = row
        app6(size(row)+1) = bigAdd(row((((size(row) - 1))+1)),val)
        row = app6
        x = (x + 1)
      end do
      if (allocated(app7)) deallocate(app7)
      allocate(app7(size(cache)+1))
      app7(1:size(cache)) = cache
      app7(size(cache)+1) = row
      cache = app7
      y = (y + 1)
    end do
    res = cache(((n)+1))
    return
  end function cumu
  recursive integer function row(n) result(res)
    integer, intent(in) :: n
    e = cumu(n)
    allocate(out(0))
    i = 0
    do while ((i < n))
      diff = bigSub(e((((i + 1))+1)),e(((i)+1)))
      if (allocated(app8)) deallocate(app8)
      allocate(app8(size(out)+1))
      app8(1:size(out)) = out
      app8(size(out)+1) = bigToString(diff)
      out = app8
      i = (i + 1)
    end do
    res = out
    return
  end function row
end program p_9_billion_names_of_god_the_integer
