! Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
program averages_mean_time_of_day
  implicit none
  real :: PI
    integer :: term
    integer :: sum
    integer :: n
      integer :: denom
    character(len=100) :: digits
    integer :: i
    integer :: h
    integer :: m
    integer :: sec
      character(len=100) :: s0
    character(len=100) :: s1
    real :: ssum
    real :: csum
      integer :: ang
    integer :: theta
    integer :: frac
    integer :: total
    integer :: si
    integer, dimension(4) :: inputs
  PI = 3.141592653589793
  call main()
  contains
  recursive real function sinApprox(x) result(res)
    real, intent(in) :: x
    term = x
    sum = x
    n = 1
    do while ((n <= 8))
      denom = real(((((2 * n)) * (((2 * n) + 1)))))
      term = (((-term * x) * x) / denom)
      sum = (sum + term)
      n = (n + 1)
    end do
    res = sum
    return
  end function sinApprox
  recursive real function cosApprox(x) result(res)
    real, intent(in) :: x
    term = 1
    sum = 1
    n = 1
    do while ((n <= 8))
      denom = real((((((2 * n) - 1)) * ((2 * n)))))
      term = (((-term * x) * x) / denom)
      sum = (sum + term)
      n = (n + 1)
    end do
    res = sum
    return
  end function cosApprox
  recursive real function atanApprox(x) result(res)
    real, intent(in) :: x
    if ((x > 1)) then
      res = (((PI / 2) - x) / (((x * x) + 0.28)))
      return
    end if
    if ((x < (-1))) then
      res = (((-PI / 2) - x) / (((x * x) + 0.28)))
      return
    end if
    res = (x / ((((1 + 0.28) * x) * x)))
    return
  end function atanApprox
  recursive real function atan2Approx(y,x) result(res)
    real, intent(in) :: y
    real, intent(in) :: x
    if ((x > 0)) then
      res = atanApprox((y / x))
      return
    end if
    if ((x < 0)) then
      if ((y >= 0)) then
        res = (atanApprox((y / x)) + PI)
        return
      end if
      res = (atanApprox((y / x)) - PI)
      return
    end if
    if ((y > 0)) then
      res = (PI / 2)
      return
    end if
    if ((y < 0)) then
      res = (-PI / 2)
      return
    end if
    res = 0
    return
  end function atan2Approx
  recursive integer function digit(ch) result(res)
    character(len=100), intent(in) :: ch
    digits = '0123456789'
    i = 0
    do while ((i < size(digits)))
      if ((digits(i+1:(i + 1)) == ch)) then
        res = i
        return
      end if
      i = (i + 1)
    end do
    res = 0
    return
  end function digit
  recursive integer function parseTwo(s,idx) result(res)
    character(len=100), intent(in) :: s
    integer, intent(in) :: idx
    res = ((digit(s(idx+1:(idx + 1))) * 10) + digit(s((idx + 1)+1:(idx + 2))))
    return
  end function parseTwo
  recursive real function parseSec(s) result(res)
    character(len=100), intent(in) :: s
    h = parseTwo(s,0)
    m = parseTwo(s,3)
    sec = parseTwo(s,6)
    res = real(((((((h * 60) + m)) * 60) + sec)))
    return
  end function parseSec
  recursive character(len=100) function pad(n) result(res)
    integer, intent(in) :: n
    if ((n < 10)) then
      write(s0,'(G0)') n
      res = '0' // s0
      return
    end if
    write(s1,'(G0)') n
    res = s1
    return
  end function pad
  recursive character(len=100) function meanTime(times) result(res)
    integer, intent(in) :: times
    ssum = 0
    csum = 0
    i = 0
    do while ((i < size(times)))
      sec = parseSec(times(((i)+1)))
      ang = (((sec * 2) * PI) / 86400)
      ssum = (ssum + sinApprox(ang))
      csum = (csum + cosApprox(ang))
      i = (i + 1)
    end do
    theta = atan2Approx(ssum,csum)
    frac = (theta / ((2 * PI)))
    do while ((frac < 0))
      frac = (frac + 1)
    end do
    total = (frac * 86400)
    si = int(total)
    h = int(((si / 3600)))
    m = int((((mod(si,3600)) / 60)))
    s = int((mod(si,60)))
    res = trim(trim(trim(pad(h) // ':') // pad(m)) // ':') // pad(s)
    return
  end function meanTime
  recursive subroutine main()
    inputs = (/'23:00:17','23:40:20','00:12:45','00:17:19'/)
    print *, meanTime(inputs)
  end subroutine main
end program averages_mean_time_of_day
