! Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
program abelian_sandpile_model
  implicit none
  integer :: dim
    integer, dimension(0) :: b
    integer :: y
      integer, dimension(0) :: row
      integer :: x
        integer, allocatable, dimension(:) :: app0
      integer, allocatable, dimension(:) :: app1
    integer, dimension(4) :: chars
      character(len=100) :: line
      integer :: col
        integer :: v
    integer :: hdim
  dim = 16
  main()
  contains
  recursive integer function newPile(d) result(res)
    integer, intent(in) :: d
    b = (//)
    y = 0
    do while ((y < d))
      row = (//)
      x = 0
      do while ((x < d))
        allocate(app0(size(row)+1))
        app0(1:size(row)) = row
        app0(size(row)+1) = 0
        row = app0
        x = (x + 1)
      end do
      allocate(app1(size(b)+1))
      app1(1:size(b)) = b
      app1(size(b)+1) = row
      b = app1
      y = (y + 1)
    end do
    res = b
    return
  end function newPile
  recursive integer function handlePile(pile,x,y) result(res)
    integer, intent(in) :: pile
    integer, intent(in) :: x
    integer, intent(in) :: y
    if ((pile(((y)+1),((x)+1)) >= 4)) then
      pile(((y)+1),((x)+1)) = (pile(((y)+1),((x)+1)) - 4)
      if ((y > 0)) then
        pile((((y - 1))+1),((x)+1)) = (pile((((y - 1))+1),((x)+1)) + 1)
        if ((pile((((y - 1))+1),((x)+1)) >= 4)) then
          pile = handlePile(pile,x,(y - 1))
        end if
      end if
      if ((x > 0)) then
        pile(((y)+1),(((x - 1))+1)) = (pile(((y)+1),(((x - 1))+1)) + 1)
        if ((pile(((y)+1),(((x - 1))+1)) >= 4)) then
          pile = handlePile(pile,(x - 1),y)
        end if
      end if
      if (((y < dim) - 1)) then
        pile((((y + 1))+1),((x)+1)) = (pile((((y + 1))+1),((x)+1)) + 1)
        if ((pile((((y + 1))+1),((x)+1)) >= 4)) then
          pile = handlePile(pile,x,(y + 1))
        end if
      end if
      if (((x < dim) - 1)) then
        pile(((y)+1),(((x + 1))+1)) = (pile(((y)+1),(((x + 1))+1)) + 1)
        if ((pile(((y)+1),(((x + 1))+1)) >= 4)) then
          pile = handlePile(pile,(x + 1),y)
        end if
      end if
      pile = handlePile(pile,x,y)
    end if
    res = pile
    return
  end function handlePile
  recursive integer function drawPile(pile,d) result(res)
    integer, intent(in) :: pile
    integer, intent(in) :: d
    chars = (/' ','░','▓','█'/)
    row = 0
    do while ((row < d))
      line = ''
      col = 0
      do while ((col < d))
        v = pile(((row)+1),((col)+1))
        if ((v > 3)) then
          v = 3
        end if
        line = (line + chars(((v)+1)))
        col = (col + 1)
      end do
      print *, line
      row = (row + 1)
    end do
  end function drawPile
  recursive integer function main() result(res)
    pile = newPile(16)
    hdim = 7
    pile(((hdim)+1),((hdim)+1)) = 16
    pile = handlePile(pile,hdim,hdim)
    drawPile(pile,16)
  end function main
end program abelian_sandpile_model
