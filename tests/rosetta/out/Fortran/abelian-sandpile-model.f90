! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program abelian_sandpile_model
  implicit none
  integer :: dim
    integer, allocatable, dimension(:) :: b
    integer :: y
    integer, allocatable, dimension(:) :: row
    integer :: x
      integer, allocatable, dimension(:) :: app0
    integer, dimension(4) :: chars
    character(len=100) :: line
    integer :: col
    integer :: v
    integer :: hdim
  dim = 16
  call main()
  
  contains
  recursive integer function newPile(d) result(res)
    integer, intent(in) :: d
    allocate(b(0))
    y = 0
    do while ((y < d))
      allocate(row(0))
      x = 0
      do while ((x < d))
        row = (/0/)
        x = (x + 1)
      end do
      if (allocated(app0)) deallocate(app0)
      allocate(app0(size(b)+1))
      app0(1:size(b)) = b
      app0(size(b)+1) = row
      b = app0
      y = (y + 1)
    end do
    res = b
    return
  end function newPile
  recursive integer function handlePile(pile,x,y) result(res)
    integer, intent(in) :: pile
    integer, intent(in) :: x
    integer, intent(in) :: y
    if ((pile(((y)+1),((x)+1)) >= 4)) then
      pile(((y)+1),((x)+1)) = (pile(((y)+1),((x)+1)) - 4)
      if ((y > 0)) then
        pile((((y - 1))+1),((x)+1)) = (pile((((y - 1))+1),((x)+1)) + 1)
        if ((pile((((y - 1))+1),((x)+1)) >= 4)) then
          pile = handlePile(pile,x,(y - 1))
        end if
      end if
      if ((x > 0)) then
        pile(((y)+1),(((x - 1))+1)) = (pile(((y)+1),(((x - 1))+1)) + 1)
        if ((pile(((y)+1),(((x - 1))+1)) >= 4)) then
          pile = handlePile(pile,(x - 1),y)
        end if
      end if
      if (((y < dim) - 1)) then
        pile((((y + 1))+1),((x)+1)) = (pile((((y + 1))+1),((x)+1)) + 1)
        if ((pile((((y + 1))+1),((x)+1)) >= 4)) then
          pile = handlePile(pile,x,(y + 1))
        end if
      end if
      if (((x < dim) - 1)) then
        pile(((y)+1),(((x + 1))+1)) = (pile(((y)+1),(((x + 1))+1)) + 1)
        if ((pile(((y)+1),(((x + 1))+1)) >= 4)) then
          pile = handlePile(pile,(x + 1),y)
        end if
      end if
      pile = handlePile(pile,x,y)
    end if
    res = pile
    return
  end function handlePile
  recursive subroutine drawPile(pile,d)
    integer, intent(in) :: pile
    integer, intent(in) :: d
    chars = (/' ','░','▓','█'/)
    row = 0
    do while ((row < d))
      line = ''
      col = 0
      do while ((col < d))
        v = pile(((row)+1),((col)+1))
        if ((v > 3)) then
          v = 3
        end if
        line = (line + chars(((v)+1)))
        col = (col + 1)
      end do
      print *, line
      row = (row + 1)
    end do
  end subroutine drawPile
  recursive subroutine main()
    pile = newPile(16)
    hdim = 7
    pile(((hdim)+1),((hdim)+1)) = 16
    pile = handlePile(pile,hdim,hdim)
    call drawPile(pile,16)
  end subroutine main
end program abelian_sandpile_model
