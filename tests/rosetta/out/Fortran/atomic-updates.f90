! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program atomic_updates
  implicit none
    integer :: next
    integer :: nBuckets
    integer :: initialSum
    integer, allocatable, dimension(:) :: buckets
    integer :: i
    integer :: dist
    integer :: v
    integer :: tc0
    integer :: tc1
    integer :: total
    integer :: nTicks
    integer :: seedOrder
    integer :: seedChaos
    integer :: t
    integer :: r
    integer :: b1
    integer :: b2
    integer :: v1
    integer :: v2
    integer :: a
    integer :: amt
    integer :: sum
    integer :: idx
      character(len=100) :: s0
      character(len=100) :: s1
      character(len=100) :: s2
      character(len=100) :: s3
      character(len=100) :: s4
  call main()
  
  contains
  recursive integer function randOrder(seed,n) result(res)
    integer, intent(in) :: seed
    integer, intent(in) :: n
    next = mod((((seed * 1664525) + 1013904223)),2147483647)
    res = (/next,mod(next,n)/)
    return
  end function randOrder
  recursive integer function randChaos(seed,n) result(res)
    integer, intent(in) :: seed
    integer, intent(in) :: n
    next = mod((((seed * 1103515245) + 12345)),2147483647)
    res = (/next,mod(next,n)/)
    return
  end function randChaos
  recursive subroutine main()
    nBuckets = 10
    initialSum = 1000
    allocate(buckets(0))
    do i = 0, nBuckets
      buckets = (/0/)
    end do
    i = nBuckets
    dist = initialSum
    do while ((i > 0))
      v = (dist / i)
      i = (i - 1)
      buckets(((i)+1)) = v
      dist = (dist - v)
    end do
    tc0 = 0
    tc1 = 0
    total = 0
    nTicks = 0
    seedOrder = 1
    seedChaos = 2
    print *, 'sum  ---updates---    mean  buckets'
    t = 0
    do while ((t < 5))
      r = randOrder(seedOrder,nBuckets)
      seedOrder = r(((0)+1))
      b1 = r(((1)+1))
      b2 = mod(((b1 + 1)),nBuckets)
      v1 = buckets(((b1)+1))
      v2 = buckets(((b2)+1))
      if ((v1 > v2)) then
        a = int(((((v1 - v2)) / 2)))
        if ((a > buckets(((b1)+1)))) then
          a = buckets(((b1)+1))
        end if
        buckets(((b1)+1)) = (buckets(((b1)+1)) - a)
        buckets(((b2)+1)) = (buckets(((b2)+1)) + a)
      else
        a = int(((((v2 - v1)) / 2)))
        if ((a > buckets(((b2)+1)))) then
          a = buckets(((b2)+1))
        end if
        buckets(((b2)+1)) = (buckets(((b2)+1)) - a)
        buckets(((b1)+1)) = (buckets(((b1)+1)) + a)
      end if
      tc0 = (tc0 + 1)
      r = randChaos(seedChaos,nBuckets)
      seedChaos = r(((0)+1))
      b1 = r(((1)+1))
      b2 = mod(((b1 + 1)),nBuckets)
      r = randChaos(seedChaos,(buckets(((b1)+1)) + 1))
      seedChaos = r(((0)+1))
      amt = r(((1)+1))
      if ((amt > buckets(((b1)+1)))) then
        amt = buckets(((b1)+1))
      end if
      buckets(((b1)+1)) = (buckets(((b1)+1)) - amt)
      buckets(((b2)+1)) = (buckets(((b2)+1)) + amt)
      tc1 = (tc1 + 1)
      sum = 0
      idx = 0
      do while ((idx < nBuckets))
        sum = (sum + buckets(((idx)+1)))
        idx = (idx + 1)
      end do
      total = ((total + tc0) + tc1)
      nTicks = (nTicks + 1)
      write(s0,'(G0)') sum
      write(s1,'(G0)') tc0
      write(s2,'(G0)') tc1
      write(s3,'(G0)') (total / nTicks)
      write(s4,'(G0)') buckets
      print *, trim(trim(trim(trim(trim(trim(trim(s0 // ' ') // s1) // ' ') // s2) // ' ') // s3) // '  ') // s4
      tc0 = 0
      tc1 = 0
      t = (t + 1)
    end do
  end subroutine main
end program atomic_updates
