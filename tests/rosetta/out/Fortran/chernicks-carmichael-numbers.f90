! Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
program chernicks_carmichael_numbers
  implicit none
    integer :: d
    integer, allocatable, dimension(:) :: digits
      integer, allocatable, dimension(:) :: app0
    integer, allocatable, dimension(:) :: res
    integer :: carry
    integer :: i
      integer :: prod
      integer, allocatable, dimension(:) :: app1
      integer, allocatable, dimension(:) :: app2
    character(len=100) :: s
      character(len=100) :: s3
    integer :: r
    integer :: p
        integer :: num
          character(len=100) :: s4
  call ccNumbers(3,9)
  contains
  recursive logical function isPrime(n) result(res)
    integer, intent(in) :: n
    if ((n < 2)) then
      res = .false.
      return
    end if
    if ((mod(n,2) == 0)) then
      res = (n == 2)
      return
    end if
    if ((mod(n,3) == 0)) then
      res = (n == 3)
      return
    end if
    d = 5
    do while (((d * d) <= n))
      if ((mod(n,d) == 0)) then
        res = .false.
        return
      end if
      d = (d + 2)
      if ((mod(n,d) == 0)) then
        res = .false.
        return
      end if
      d = (d + 4)
    end do
    res = .true.
    return
  end function isPrime
  recursive integer function bigTrim(a) result(res)
    integer, intent(in) :: a
    n = size(a)
    do while ((((n > 1) .and. a((((n - 1))+1))) == 0))
      a = a(1:(n - 1))
      n = (n - 1)
    end do
    res = a
    return
  end function bigTrim
  recursive integer function bigFromInt(x) result(res)
    integer, intent(in) :: x
    if ((x == 0)) then
      res = (/0/)
      return
    end if
    allocate(digits(0))
    n = x
    do while ((n > 0))
      if (allocated(app0)) deallocate(app0)
      allocate(app0(size(digits)+1))
      app0(1:size(digits)) = digits
      app0(size(digits)+1) = mod(n,10)
      digits = app0
      n = (n / 10)
    end do
    res = digits
    return
  end function bigFromInt
  recursive integer function bigMulSmall(a,m) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: m
    if ((m == 0)) then
      res = (/0/)
      return
    end if
    allocate(res(0))
    carry = 0
    i = 0
    do while ((i < size(a)))
      prod = ((a(((i)+1)) * m) + carry)
      if (allocated(app1)) deallocate(app1)
      allocate(app1(size(res)+1))
      app1(1:size(res)) = res
      app1(size(res)+1) = mod(prod,10)
      res = app1
      carry = (prod / 10)
      i = (i + 1)
    end do
    do while ((carry > 0))
      if (allocated(app2)) deallocate(app2)
      allocate(app2(size(res)+1))
      app2(1:size(res)) = res
      app2(size(res)+1) = mod(carry,10)
      res = app2
      carry = (carry / 10)
    end do
    res = bigTrim(res)
    return
  end function bigMulSmall
  recursive character(len=100) function bigToString(a) result(res)
    integer, intent(in) :: a
    s = ''
    i = (size(a) - 1)
    do while ((i >= 0))
      write(s3,'(G0)') a(((i)+1))
      s = (s + s3)
      i = (i - 1)
    end do
    res = s
    return
  end function bigToString
  recursive integer function pow2(k) result(res)
    integer, intent(in) :: k
    r = 1
    i = 0
    do while ((i < k))
      r = (r * 2)
      i = (i + 1)
    end do
    res = r
    return
  end function pow2
  recursive integer function ccFactors(n,m) result(res)
    integer, intent(in) :: n
    integer, intent(in) :: m
    p = ((6 * m) + 1)
    if (.not. isPrime(p)) then
      res = (//)
      return
    end if
    prod = bigFromInt(p)
    p = ((12 * m) + 1)
    if (.not. isPrime(p)) then
      res = (//)
      return
    end if
    prod = bigMulSmall(prod,p)
    i = 1
    do while (((i <= n) - 2))
      p = ((((pow2(i) * 9) * m)) + 1)
      if (.not. isPrime(p)) then
        res = (//)
        return
      end if
      prod = bigMulSmall(prod,p)
      i = (i + 1)
    end do
    res = prod
    return
  end function ccFactors
  recursive subroutine ccNumbers(start,end)
    integer, intent(in) :: start
    integer, intent(in) :: end
    n = start
    do while ((n <= end))
      m = 1
      if ((n > 4)) then
        m = pow2((n - 4))
      end if
      do while (.true.)
        num = ccFactors(n,m)
        if ((size(num) > 0)) then
          write(s4,'(G0)') n
          print *, trim(trim('a(' // s4) // ') = ') // bigToString(num)
          exit
        end if
        if ((n <= 4)) then
          m = (m + 1)
        else
          m = (m + pow2((n - 4)))
        end if
      end do
      n = (n + 1)
    end do
  end subroutine ccNumbers
end program chernicks_carmichael_numbers
