! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program cholesky_decomposition
  implicit none
    integer :: guess
    integer :: i
    integer :: n
    integer, allocatable, dimension(:) :: l
    integer, allocatable, dimension(:) :: row
    integer :: j
    integer :: sum
    integer :: k
        real, allocatable, dimension(:) :: app0
      integer, allocatable, dimension(:) :: app1
    character(len=100) :: line
        character(len=100) :: s2
  call demo((/(/25.0,15.0,-5.0/),(/15.0,18.0,0.0/),(/-5.0,0.0,11.0/)/))
  call demo((/(/18.0,22.0,54.0,42.0/),(/22.0,70.0,86.0,62.0/),(/54.0,86.0,174.0,134.0/),(/42.0,62.0,134.0,106.0/)/))
  
  contains
  recursive real function sqrtApprox(x) result(res)
    real, intent(in) :: x
    guess = x
    i = 0
    do while ((i < 20))
      guess = ((((guess + x) / guess)) / 2.0)
      i = (i + 1)
    end do
    res = guess
    return
  end function sqrtApprox
  recursive integer function cholesky(a) result(res)
    integer, intent(in) :: a
    n = size(a)
    allocate(l(0))
    i = 0
    do while ((i < n))
      allocate(row(0))
      j = 0
      do while ((j < n))
        if (allocated(app0)) deallocate(app0)
        allocate(app0(size(row)+1))
        app0(1:size(row)) = row
        app0(size(row)+1) = 0.0
        row = app0
        j = (j + 1)
      end do
      if (allocated(app1)) deallocate(app1)
      allocate(app1(size(l)+1))
      app1(1:size(l)) = l
      app1(size(l)+1) = row
      l = app1
      i = (i + 1)
    end do
    i = 0
    do while ((i < n))
      j = 0
      do while ((j <= i))
        sum = a(((i)+1),((j)+1))
        k = 0
        do while ((k < j))
          sum = ((sum - l(((i)+1),((k)+1))) * l(((j)+1),((k)+1)))
          k = (k + 1)
        end do
        if ((i == j)) then
          l(((i)+1),((j)+1)) = sqrtApprox(sum)
        else
          l(((i)+1),((j)+1)) = (sum / l(((j)+1),((j)+1)))
        end if
        j = (j + 1)
      end do
      i = (i + 1)
    end do
    res = l
    return
  end function cholesky
  recursive subroutine printMat(m)
    integer, intent(in) :: m
    i = 0
    do while ((i < size(m)))
      line = ''
      j = 0
      do while ((j < size(m(((i)+1)))))
        write(s2,'(G0)') m(((i)+1),((j)+1))
        line = (line + s2)
        if (((j < size(m(((i)+1)))) - 1)) then
          line = line // ' '
        end if
        j = (j + 1)
      end do
      print *, line
      i = (i + 1)
    end do
  end subroutine printMat
  recursive subroutine demo(a)
    integer, intent(in) :: a
    print *, 'A:'
    call printMat(a)
    l = cholesky(a)
    print *, 'L:'
    call printMat(l)
  end subroutine demo
end program cholesky_decomposition
