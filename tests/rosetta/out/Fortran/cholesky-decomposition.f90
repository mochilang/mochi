! Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
program cholesky_decomposition
  implicit none
    integer :: guess
    integer :: i
    integer :: n
    integer, dimension(0) :: l
      integer, dimension(0) :: row
      integer :: j
        integer, allocatable, dimension(:) :: app0
      integer, allocatable, dimension(:) :: app1
        integer :: sum
        integer :: k
      character(len=100) :: line
        character(len=100) :: s2
  demo((/(/25,15,-5/),(/15,18,0/),(/-5,0,11/)/))
  demo((/(/18,22,54,42/),(/22,70,86,62/),(/54,86,174,134/),(/42,62,134,106/)/))
  contains
  recursive real function sqrtApprox(x) result(res)
    real, intent(in) :: x
    guess = x
    i = 0
    do while ((i < 20))
      guess = ((((guess + x) / guess)) / 2)
      i = (i + 1)
    end do
    res = guess
    return
  end function sqrtApprox
  recursive integer function cholesky(a) result(res)
    integer, intent(in) :: a
    n = size(a)
    l = (//)
    i = 0
    do while ((i < n))
      row = (//)
      j = 0
      do while ((j < n))
        allocate(app0(size(row)+1))
        app0(1:size(row)) = row
        app0(size(row)+1) = 0
        row = app0
        j = (j + 1)
      end do
      allocate(app1(size(l)+1))
      app1(1:size(l)) = l
      app1(size(l)+1) = row
      l = app1
      i = (i + 1)
    end do
    i = 0
    do while ((i < n))
      j = 0
      do while ((j <= i))
        sum = a(((i)+1),((j)+1))
        k = 0
        do while ((k < j))
          sum = ((sum - l(((i)+1),((k)+1))) * l(((j)+1),((k)+1)))
          k = (k + 1)
        end do
        if ((i == j)) then
          l(((i)+1),((j)+1)) = sqrtApprox(sum)
        else
          l(((i)+1),((j)+1)) = (sum / l(((j)+1),((j)+1)))
        end if
        j = (j + 1)
      end do
      i = (i + 1)
    end do
    res = l
    return
  end function cholesky
  recursive integer function printMat(m) result(res)
    integer, intent(in) :: m
    i = 0
    do while ((i < size(m)))
      line = ''
      j = 0
      do while ((j < size(m(((i)+1)))))
        write(s2,'(G0)') m(((i)+1),((j)+1))
        line = (line + s2)
        if (((j < size(m(((i)+1)))) - 1)) then
          line = line // ' '
        end if
        j = (j + 1)
      end do
      print *, line
      i = (i + 1)
    end do
  end function printMat
  recursive integer function demo(a) result(res)
    integer, intent(in) :: a
    print *, 'A:'
    printMat(a)
    l = cholesky(a)
    print *, 'L:'
    printMat(l)
  end function demo
end program cholesky_decomposition
