! Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
program box_the_compass
  implicit none
  integer, dimension(32) :: compassPoint
  integer, dimension(33) :: headings
  integer :: i
    integer :: h
    integer :: idx
    integer :: cp
    character(len=100) :: s0
    character(len=100) :: res
    integer :: n
    integer :: out
    character(len=100) :: s1
      integer :: need
    integer :: x
  compassPoint = (/'North','North by east','North-northeast','Northeast by north','Northeast','Northeast by east','East-northeast','East by north','East','East by south','East-southeast','Southeast by east','Southeast','Southeast by south','South-southeast','South by east','South','South by west','South-southwest','Southwest by south','Southwest','Southwest by west','West-southwest','West by south','West','West by north','West-northwest','Northwest by west','Northwest','Northwest by north','North-northwest','North by west'/)
  headings = (/0,16.87,16.88,33.75,50.62,50.63,67.5,84.37,84.38,101.25,118.12,118.13,135,151.87,151.88,168.75,185.62,185.63,202.5,219.37,219.38,236.25,253.12,253.13,270,286.87,286.88,303.75,320.62,320.63,337.5,354.37,354.38/)
  print *, 'Index  Compass point         Degree'
  i = 0
  do while ((i < size(headings)))
    h = headings(((i)+1))
    idx = (mod(i,32) + 1)
    cp = degrees2compasspoint(h)
    write(s0,'(G0)') idx
    print *, trim(trim(trim(trim(padLeft(s0,4) // '   ') // padRight(cp,19)) // ' ') // format2(h)) // 'Â°'
    i = (i + 1)
  end do
  contains
  recursive character(len=100) function padLeft(s,w) result(res)
    character(len=100), intent(in) :: s
    integer, intent(in) :: w
    res = ''
    n = (w - size(s))
    do while ((n > 0))
      res = res // ' '
      n = (n - 1)
    end do
    res = (res + s)
    return
  end function padLeft
  recursive character(len=100) function padRight(s,w) result(res)
    character(len=100), intent(in) :: s
    integer, intent(in) :: w
    out = s
    i = size(s)
    do while ((i < w))
      out = out // ' '
      i = (i + 1)
    end do
    res = out
    return
  end function padRight
  recursive integer function indexOf(s,ch) result(res)
    character(len=100), intent(in) :: s
    character(len=100), intent(in) :: ch
    i = 0
    do while ((i < size(s)))
      if ((s(i+1:(i + 1)) == ch)) then
        res = i
        return
      end if
      i = (i + 1)
    end do
    res = -1
    return
  end function indexOf
  recursive character(len=100) function format2(f) result(res)
    real, intent(in) :: f
    write(s1,'(G0)') f
    s = s1
    idx = indexOf(s,'.')
    if ((idx < 0)) then
      s = s // '.00'
    else
      need = (idx + 3)
      if ((size(s) > need)) then
        s = s(0+1:need)
      else
        do while ((size(s) < need))
          s = s // '0'
        end do
      end if
    end if
    res = s
    return
  end function format2
  recursive integer function cpx(h) result(res)
    real, intent(in) :: h
    x = int(((((h / 11.25)) + 0.5)))
    x = mod(x,32)
    if ((x < 0)) then
      x = (x + 32)
    end if
    res = x
    return
  end function cpx
  recursive character(len=100) function degrees2compasspoint(h) result(res)
    real, intent(in) :: h
    res = compassPoint(((cpx(h))+1))
    return
  end function degrees2compasspoint
end program box_the_compass
