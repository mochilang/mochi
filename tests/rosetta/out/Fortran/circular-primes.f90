! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program circular_primes
  implicit none
  integer, allocatable, dimension(:) :: circs
  integer, dimension(4) :: digits
  integer, dimension(6) :: q
  integer, dimension(6) :: fq
  integer :: count
    integer :: f
    integer :: fd
      integer, allocatable, dimension(:) :: app0
      integer :: d
      integer :: i1
        integer, allocatable, dimension(:) :: app2
        integer, allocatable, dimension(:) :: app3
  integer :: i
  integer, dimension(6) :: arr4 = (/5003,9887,15073,25031,35317,49081/)
  integer :: i4
    character(len=100) :: s5
    integer :: nn
    integer :: pow
    character(len=100) :: out
      character(len=100) :: s6
  allocate(circs(0))
  print *, 'The first 19 circular primes are:'
  digits = (/1,3,7,9/)
  q = (/1,2,3,5,7,9/)
  fq = (/1,2,3,5,7,9/)
  count = 0
  do while (.true.)
    f = q(((0)+1))
    fd = fq(((0)+1))
    if ((isPrime(f) .and. isCircular(f))) then
      if (allocated(app0)) deallocate(app0)
      allocate(app0(size(circs)+1))
      app0(1:size(circs)) = circs
      app0(size(circs)+1) = f
      circs = app0
      count = (count + 1)
      if ((count == 19)) then
        exit
      end if
    end if
    q = q((1)+1:size(q))
    fq = fq((1)+1:size(fq))
    if ((((f /= 2) .and. f) /= 5)) then
      do i1 = 1, size(digits)
        d = digits(i1)
        if (allocated(app2)) deallocate(app2)
        allocate(app2(size(q)+1))
        app2(1:size(q)) = q
        app2(size(q)+1) = ((f * 10) + d)
        q = app2
        if (allocated(app3)) deallocate(app3)
        allocate(app3(size(fq)+1))
        app3(1:size(fq)) = fq
        app3(size(fq)+1) = fd
        fq = app3
      end do
    end if
  end do
  print *, showList(circs)
  print *, ''//char(10)//'The next 4 circular primes, in repunit format, are:'
  print *, '[R(19) R(23) R(317) R(1031)]'
  print *, ''//char(10)//'The following repunits are probably circular primes:'
  do i4 = 1, 6
    i = arr4(i4)
    write(s5,'(G0)') i
    print *, trim('R(' // s5) // ') : true'
  end do
  
  contains
  recursive logical function isPrime(n) result(res)
    integer, intent(in) :: n
    if ((n < 2)) then
      res = .false.
      return
    end if
    if ((mod(n,2) == 0)) then
      res = (n == 2)
      return
    end if
    if ((mod(n,3) == 0)) then
      res = (n == 3)
      return
    end if
    d = 5
    do while (((d * d) <= n))
      if ((mod(n,d) == 0)) then
        res = .false.
        return
      end if
      d = (d + 2)
      if ((mod(n,d) == 0)) then
        res = .false.
        return
      end if
      d = (d + 4)
    end do
    res = .true.
    return
  end function isPrime
  recursive logical function isCircular(n) result(res)
    integer, intent(in) :: n
    nn = n
    pow = 1
    do while ((nn > 0))
      pow = (pow * 10)
      nn = (nn / 10)
    end do
    nn = n
    do while (.true.)
      nn = (nn * 10)
      f = (nn / pow)
      nn = ((nn + f) * ((1 - pow)))
      if ((nn == n)) then
        exit
      end if
      if (.not. isPrime(nn)) then
        res = .false.
        return
      end if
    end do
    res = .true.
    return
  end function isCircular
  recursive character(len=100) function showList(xs) result(res)
    integer, intent(in) :: xs
    out = '['
    i = 0
    do while ((i < size(xs)))
      write(s6,'(G0)') xs(((i)+1))
      out = (out + s6)
      if (((i < size(xs)) - 1)) then
        out = out // ', '
      end if
      i = (i + 1)
    end do
    res = out // ']'
    return
  end function showList
end program circular_primes
