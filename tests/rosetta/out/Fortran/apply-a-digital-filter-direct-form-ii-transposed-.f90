! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program apply_a_digital_filter_direct_form_ii_transposed_
  implicit none
  integer, dimension(4) :: a
  integer, dimension(4) :: b
  integer, dimension(20) :: sig
  integer :: res
  integer :: k
    integer, allocatable, dimension(:) :: out
    real :: scale
    integer :: i
    real :: tmp
    integer :: j
      integer, allocatable, dimension(:) :: app0
  a = (/1.0,-2.7756e-16,0.33333333,-1.85e-17/)
  b = (/0.16666667,0.5,0.5,0.16666667/)
  sig = (/-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,0.0259303398477,0.490105989562,0.549391221511,0.9047198589/)
  res = applyFilter(sig,a,b)
  k = 0
  do while ((k < size(res)))
    print *, res(((k)+1))
    k = (k + 1)
  end do
  
  contains
  recursive integer function applyFilter(input,a,b) result(res)
    integer, intent(in) :: input
    integer, intent(in) :: a
    integer, intent(in) :: b
    allocate(out(0))
    scale = (1.0 / a(((0)+1)))
    i = 0
    do while ((i < size(input)))
      tmp = 0.0
      j = 0
      do while ((((j <= i) .and. j) < 4))
        tmp = ((tmp + b(((j)+1))) * input((((i - j))+1)))
        j = (j + 1)
      end do
      j = 0
      do while (((((j < i) .and. j) + 1) < size(a)))
        tmp = ((tmp - a((((j + 1))+1))) * out(((((i - j) - 1))+1)))
        j = (j + 1)
      end do
      if (allocated(app0)) deallocate(app0)
      allocate(app0(size(out)+1))
      app0(1:size(out)) = out
      app0(size(out)+1) = (tmp * scale)
      out = app0
      i = (i + 1)
    end do
    res = out
    return
  end function applyFilter
end program apply_a_digital_filter_direct_form_ii_transposed_
