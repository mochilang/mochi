! Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
program blum_integer
  implicit none
    integer :: d
    integer, dimension(8) :: inc
    integer :: k
    integer :: i
    character(len=100) :: s0
    character(len=100) :: s1
    integer :: idx
    integer :: need
    integer, dimension(0) :: blum
    integer, dimension(4) :: counts
    integer, dimension(4) :: digits
    integer :: bc
      integer :: p
        integer :: q
            integer, allocatable, dimension(:) :: app2
              character(len=100) :: line
              integer :: j
  main()
  contains
  recursive logical function isPrime(n) result(res)
    integer, intent(in) :: n
    if ((n < 2)) then
      res = .false.
      return
    end if
    if ((mod(n,2) == 0)) then
      res = (n == 2)
      return
    end if
    if ((mod(n,3) == 0)) then
      res = (n == 3)
      return
    end if
    d = 5
    do while (((d * d) <= n))
      if ((mod(n,d) == 0)) then
        res = .false.
        return
      end if
      d = (d + 2)
      if ((mod(n,d) == 0)) then
        res = .false.
        return
      end if
      d = (d + 4)
    end do
    res = .true.
    return
  end function isPrime
  recursive integer function firstPrimeFactor(n) result(res)
    integer, intent(in) :: n
    if ((n == 1)) then
      res = 1
      return
    end if
    if ((mod(n,3) == 0)) then
      res = 3
      return
    end if
    if ((mod(n,5) == 0)) then
      res = 5
      return
    end if
    inc = (/4,2,4,2,4,6,2,6/)
    k = 7
    i = 0
    do while (((k * k) <= n))
      if ((mod(n,k) == 0)) then
        res = k
        return
      end if
      k = (k + inc(((i)+1)))
      i = mod(((i + 1)),size(inc))
    end do
    res = n
    return
  end function firstPrimeFactor
  recursive integer function indexOf(s,ch) result(res)
    character(len=100), intent(in) :: s
    character(len=100), intent(in) :: ch
    i = 0
    do while ((i < size(s)))
      if ((s(i+1:(i + 1)) == ch)) then
        res = i
        return
      end if
      i = (i + 1)
    end do
    res = -1
    return
  end function indexOf
  recursive character(len=100) function padLeft(n,width) result(res)
    integer, intent(in) :: n
    integer, intent(in) :: width
    write(s0,'(G0)') n
    s = s0
    do while ((size(s) < width))
      s = ' ' // s
    end do
    res = s
    return
  end function padLeft
  recursive character(len=100) function formatFloat(f,prec) result(res)
    real, intent(in) :: f
    integer, intent(in) :: prec
    write(s1,'(G0)') f
    s = s1
    idx = indexOf(s,'.')
    if ((idx < 0)) then
      res = s
      return
    end if
    need = ((idx + 1) + prec)
    if ((size(s) > need)) then
      res = s(0+1:need)
      return
    end if
    res = s
    return
  end function formatFloat
  recursive integer function main() result(res)
    blum = (//)
    counts = (/0,0,0,0/)
    digits = (/1,3,7,9/)
    i = 1
    bc = 0
    do while (.true.)
      p = firstPrimeFactor(i)
      if ((mod(p,4) == 3)) then
        q = int(((i / p)))
        if (((mod(((q /= p) .and. q),4) == 3) .and. isPrime(q))) then
          if ((bc < 50)) then
            allocate(app2(size(blum)+1))
            app2(1:size(blum)) = blum
            app2(size(blum)+1) = i
            blum = app2
          end if
          d = mod(i,10)
          if ((d == 1)) then
            counts(((0)+1)) = (counts(((0)+1)) + 1)
          else if ((d == 3)) then
            counts(((1)+1)) = (counts(((1)+1)) + 1)
          else if ((d == 7)) then
            counts(((2)+1)) = (counts(((2)+1)) + 1)
          else if ((d == 9)) then
            counts(((3)+1)) = (counts(((3)+1)) + 1)
          end if
          bc = (bc + 1)
          if ((bc == 50)) then
            print *, 'First 50 Blum integers:'
            idx = 0
            do while ((idx < 50))
              line = ''
              j = 0
              do while ((j < 10))
                line = (line + padLeft(blum(((idx)+1)),3)) // ' '
                idx = (idx + 1)
                j = (j + 1)
              end do
              print *, line(0+1:(size(line) - 1))
            end do
            exit
          end if
        end if
      end if
      if ((mod(i,5) == 3)) then
        i = (i + 4)
      else
        i = (i + 2)
      end if
    end do
  end function main
end program blum_integer
