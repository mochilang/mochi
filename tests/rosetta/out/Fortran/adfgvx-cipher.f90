! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program adfgvx_cipher
  implicit none
  character(len=100) :: adfgvx
  character(len=100) :: alphabet
    integer, allocatable, dimension(:) :: arr
    integer :: i
    integer :: j
    integer :: k
    integer :: tmp
    character(len=100) :: out
      integer, allocatable, dimension(:) :: app0
    integer :: shuffled
    integer, allocatable, dimension(:) :: labels
    integer :: li
    integer, allocatable, dimension(:) :: p
    integer :: row
    integer :: line
      character(len=100), allocatable, dimension(:) :: app1
      integer, allocatable, dimension(:) :: app2
    character(len=100) :: pool
    character(len=100) :: key
    integer :: idx
    logical, allocatable, dimension(:) :: pairs
    integer :: m
    logical, allocatable, dimension(:) :: res
      integer, allocatable, dimension(:) :: app3
      integer, allocatable, dimension(:) :: app4
    character(len=100) :: temp
    integer :: r
    integer :: c
    integer :: colLen
    integer, allocatable, dimension(:) :: table
    integer :: rIdx
    integer :: col
    integer :: order
    integer, allocatable, dimension(:) :: cols
    integer :: ci
    character(len=100) :: colStr
    integer :: ri
    character(len=100) :: result
      character(len=100), allocatable, dimension(:) :: app5
        character(len=100), allocatable, dimension(:) :: app6
      integer, allocatable, dimension(:) :: app7
      integer, allocatable, dimension(:) :: app8
    integer, allocatable, dimension(:) :: colStrs
    integer :: start
    integer :: maxColLen
    integer, allocatable, dimension(:) :: ls
    integer, allocatable, dimension(:) :: pad
    integer :: cIdx
        integer, allocatable, dimension(:) :: app9
        integer, allocatable, dimension(:) :: app10
            integer, allocatable, dimension(:) :: app11
            character(len=100), allocatable, dimension(:) :: app12
        integer, allocatable, dimension(:) :: app13
        integer, allocatable, dimension(:) :: app14
        character(len=100), allocatable, dimension(:) :: app15
      integer, allocatable, dimension(:) :: app16
    integer :: plainText2
  adfgvx = 'ADFGVX'
  alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  call main()
  
  contains
  recursive character(len=100) function shuffleStr(s) result(res)
    character(len=100), intent(in) :: s
    allocate(arr(0))
    i = 0
    do while ((i < size(s)))
      if (allocated(app0)) deallocate(app0)
      allocate(app0(size(arr)+1))
      app0(1:size(arr)) = arr
      app0(size(arr)+1) = s((i)+1:(i + 1))
      arr = app0
      i = (i + 1)
    end do
    j = (size(arr) - 1)
    do while ((j > 0))
      k = mod(now(),((j + 1)))
      tmp = arr(((j)+1))
      arr(((j)+1)) = arr(((k)+1))
      arr(((k)+1)) = tmp
      j = (j - 1)
    end do
    out = ''
    i = 0
    do while ((i < size(arr)))
      out = (out + arr(((i)+1)))
      i = (i + 1)
    end do
    res = out
    return
  end function shuffleStr
  recursive integer function createPolybius() result(res)
    shuffled = shuffleStr(alphabet)
    allocate(labels(0))
    li = 0
    do while ((li < 6))
      if (allocated(app1)) deallocate(app1)
      allocate(app1(size(labels)+1))
      app1(1:size(labels)) = labels
      app1(size(labels)+1) = adfgvx((li)+1:(li + 1))
      labels = app1
      li = (li + 1)
    end do
    print *, '6 x 6 Polybius square:'//char(10)//''
    print *, '  | A D F G V X'
    print *, '---------------'
    allocate(p(0))
    i = 0
    do while ((i < 6))
      row = shuffled(((i * 6))+1:(((i + 1)) * 6))
      if (allocated(app2)) deallocate(app2)
      allocate(app2(size(p)+1))
      app2(1:size(p)) = p
      app2(size(p)+1) = row
      p = app2
      line = labels((i)+1:(i + 1)) // ' | '
      j = 0
      do while ((j < 6))
        line = (line + row((j)+1:(j + 1))) // ' '
        j = (j + 1)
      end do
      print *, line
      i = (i + 1)
    end do
    res = p
    return
  end function createPolybius
  recursive character(len=100) function createKey(n) result(res)
    integer, intent(in) :: n
    if ((((n < 7) .or. n) > 12)) then
      print *, 'Key should be within 7 and 12 letters long.'
    end if
    pool = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    key = ''
    i = 0
    do while ((i < n))
      idx = mod(now(),36)
      key = (key + pool(((idx)+1)))
      pool = (pool(1:idx) + pool(((idx + 1))+1:36))
      i = (i + 1)
    end do
    print *, ''//char(10)//'The key is ' // key
    res = key
    return
  end function createKey
  recursive integer function orderKey(key) result(res)
    character(len=100), intent(in) :: key
    allocate(pairs(0))
    i = 0
    do while ((i < size(key)))
      if (allocated(app3)) deallocate(app3)
      allocate(app3(size(pairs)+1))
      app3(1:size(pairs)) = pairs
      app3(size(pairs)+1) = (/key((i)+1:(i + 1)),i/)
      pairs = app3
      i = (i + 1)
    end do
    n = size(pairs)
    m = 0
    do while ((m < n))
      j = 0
      do while (((j < n) - 1))
        if ((pairs(((j)+1),((0)+1)) > pairs((((j + 1))+1),((0)+1)))) then
          tmp = pairs(((j)+1))
          pairs(((j)+1)) = pairs((((j + 1))+1))
          pairs((((j + 1))+1)) = tmp
        end if
        j = (j + 1)
      end do
      m = (m + 1)
    end do
    allocate(res(0))
    i = 0
    do while ((i < n))
      if (allocated(app4)) deallocate(app4)
      allocate(app4(size(res)+1))
      app4(1:size(res)) = res
      app4(size(res)+1) = int(pairs(((i)+1),((1)+1)))
      res = app4
      i = (i + 1)
    end do
    res = res
    return
  end function orderKey
  recursive character(len=100) function encrypt(polybius,key,plainText) result(res)
    integer, intent(in) :: polybius
    character(len=100), intent(in) :: key
    character(len=100), intent(in) :: plainText
    allocate(labels(0))
    li = 0
    do while ((li < 6))
      if (allocated(app5)) deallocate(app5)
      allocate(app5(size(labels)+1))
      app5(1:size(labels)) = labels
      app5(size(labels)+1) = adfgvx((li)+1:(li + 1))
      labels = app5
      li = (li + 1)
    end do
    temp = ''
    i = 0
    do while ((i < size(plainText)))
      r = 0
      do while ((r < 6))
        c = 0
        do while ((c < 6))
          if ((polybius(((r)+1),(c)+1:(c + 1)) == plainText((i)+1:(i + 1)))) then
            temp = ((temp + labels((r)+1:(r + 1))) + labels((c)+1:(c + 1)))
          end if
          c = (c + 1)
        end do
        r = (r + 1)
      end do
      i = (i + 1)
    end do
    colLen = (size(temp) / size(key))
    if ((mod(size(temp),size(key)) > 0)) then
      colLen = (colLen + 1)
    end if
    allocate(table(0))
    rIdx = 0
    do while ((rIdx < colLen))
      allocate(row(0))
      j = 0
      do while ((j < size(key)))
        if (allocated(app6)) deallocate(app6)
        allocate(app6(size(row)+1))
        app6(1:size(row)) = row
        app6(size(row)+1) = ''
        row = app6
        j = (j + 1)
      end do
      if (allocated(app7)) deallocate(app7)
      allocate(app7(size(table)+1))
      app7(1:size(table)) = table
      app7(size(table)+1) = row
      table = app7
      rIdx = (rIdx + 1)
    end do
    idx = 0
    do while ((idx < size(temp)))
      row = (idx / size(key))
      col = mod(idx,size(key))
      table(((row)+1),((col)+1)) = temp((idx)+1:(idx + 1))
      idx = (idx + 1)
    end do
    order = orderKey(key)
    allocate(cols(0))
    ci = 0
    do while ((ci < size(key)))
      colStr = ''
      ri = 0
      do while ((ri < colLen))
        colStr = (colStr + table(((ri)+1),((order(((ci)+1)))+1)))
        ri = (ri + 1)
      end do
      if (allocated(app8)) deallocate(app8)
      allocate(app8(size(cols)+1))
      app8(1:size(cols)) = cols
      app8(size(cols)+1) = colStr
      cols = app8
      ci = (ci + 1)
    end do
    result = ''
    ci = 0
    do while ((ci < size(cols)))
      result = (result + cols(((ci)+1)))
      if (((ci < size(cols)) - 1)) then
        result = result // ' '
      end if
      ci = (ci + 1)
    end do
    res = result
    return
  end function encrypt
  recursive integer function indexOf(s,ch) result(res)
    character(len=100), intent(in) :: s
    character(len=100), intent(in) :: ch
    i = 0
    do while ((i < size(s)))
      if ((s((i)+1:(i + 1)) == ch)) then
        res = i
        return
      end if
      i = (i + 1)
    end do
    res = -1
    return
  end function indexOf
  recursive character(len=100) function decrypt(polybius,key,cipherText) result(res)
    integer, intent(in) :: polybius
    character(len=100), intent(in) :: key
    character(len=100), intent(in) :: cipherText
    allocate(colStrs(0))
    start = 0
    i = 0
    do while ((i <= size(cipherText)))
      if ((((i == size(cipherText)) .or. cipherText(((i)+1))) == ' ')) then
        if (allocated(app9)) deallocate(app9)
        allocate(app9(size(colStrs)+1))
        app9(1:size(colStrs)) = colStrs
        app9(size(colStrs)+1) = cipherText((start)+1:i)
        colStrs = app9
        start = (i + 1)
      end if
      i = (i + 1)
    end do
    maxColLen = 0
    i = 0
    do while ((i < size(colStrs)))
      if ((size(colStrs(((i)+1))) > maxColLen)) then
        maxColLen = size(colStrs(((i)+1)))
      end if
      i = (i + 1)
    end do
    allocate(cols(0))
    i = 0
    do while ((i < size(colStrs)))
      s = colStrs(((i)+1))
      allocate(ls(0))
      j = 0
      do while ((j < size(s)))
        if (allocated(app10)) deallocate(app10)
        allocate(app10(size(ls)+1))
        app10(1:size(ls)) = ls
        app10(size(ls)+1) = s((j)+1:(j + 1))
        ls = app10
        j = (j + 1)
      end do
      if ((size(s) < maxColLen)) then
        allocate(pad(0))
        k = 0
        do while ((k < maxColLen))
          if ((k < size(ls))) then
            if (allocated(app11)) deallocate(app11)
            allocate(app11(size(pad)+1))
            app11(1:size(pad)) = pad
            app11(size(pad)+1) = ls(((k)+1))
            pad = app11
          else
            if (allocated(app12)) deallocate(app12)
            allocate(app12(size(pad)+1))
            app12(1:size(pad)) = pad
            app12(size(pad)+1) = ''
            pad = app12
          end if
          k = (k + 1)
        end do
        if (allocated(app13)) deallocate(app13)
        allocate(app13(size(cols)+1))
        app13(1:size(cols)) = cols
        app13(size(cols)+1) = pad
        cols = app13
      else
        if (allocated(app14)) deallocate(app14)
        allocate(app14(size(cols)+1))
        app14(1:size(cols)) = cols
        app14(size(cols)+1) = ls
        cols = app14
      end if
      i = (i + 1)
    end do
    allocate(table(0))
    r = 0
    do while ((r < maxColLen))
      allocate(row(0))
      c = 0
      do while ((c < size(key)))
        if (allocated(app15)) deallocate(app15)
        allocate(app15(size(row)+1))
        app15(1:size(row)) = row
        app15(size(row)+1) = ''
        row = app15
        c = (c + 1)
      end do
      if (allocated(app16)) deallocate(app16)
      allocate(app16(size(table)+1))
      app16(1:size(table)) = table
      app16(size(table)+1) = row
      table = app16
      r = (r + 1)
    end do
    order = orderKey(key)
    r = 0
    do while ((r < maxColLen))
      c = 0
      do while ((c < size(key)))
        table(((r)+1),((order(((c)+1)))+1)) = cols(((c)+1),((r)+1))
        c = (c + 1)
      end do
      r = (r + 1)
    end do
    temp = ''
    r = 0
    do while ((r < size(table)))
      j = 0
      do while ((j < size(table(((r)+1)))))
        temp = (temp + table(((r)+1),((j)+1)))
        j = (j + 1)
      end do
      r = (r + 1)
    end do
    plainText = ''
    idx = 0
    do while ((idx < size(temp)))
      rIdx = indexOf(adfgvx,temp((idx)+1:(idx + 1)))
      cIdx = indexOf(adfgvx,temp(((idx + 1))+1:(idx + 2)))
      plainText = (plainText + polybius(((rIdx)+1),((cIdx)+1)))
      idx = (idx + 2)
    end do
    res = plainText
    return
  end function decrypt
  recursive subroutine main()
    plainText = 'ATTACKAT1200AM'
    polybius = createPolybius()
    key = createKey(9)
    print *, ''//char(10)//'Plaintext : ' // plainText
    cipherText = encrypt(polybius,key,plainText)
    print *, ''//char(10)//'Encrypted : ' // cipherText
    plainText2 = decrypt(polybius,key,cipherText)
    print *, ''//char(10)//'Decrypted : ' // plainText2
  end subroutine main
end program adfgvx_cipher
