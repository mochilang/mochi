! Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
program adfgvx_cipher
  implicit none
  character(len=100) :: adfgvx
  character(len=100) :: alphabet
    integer, allocatable, dimension(:) :: arr
    integer :: i
    integer :: j
      integer :: k
      integer :: tmp
    character(len=100) :: out
    integer :: shuffled
    integer, allocatable, dimension(:) :: p
      integer :: row
      character(len=100) :: line
    character(len=100) :: pool
    character(len=100) :: key
      integer :: idx
    logical, allocatable, dimension(:) :: pairs
    integer :: m
    logical, allocatable, dimension(:) :: res
    character(len=100) :: temp
      integer :: r
        integer :: c
    integer :: colLen
    integer, allocatable, dimension(:) :: table
    integer :: rIdx
      integer :: col
    integer :: order
    integer, allocatable, dimension(:) :: cols
    integer :: ci
      character(len=100) :: colStr
      integer :: ri
    character(len=100) :: result
    integer, allocatable, dimension(:) :: colStrs
    integer :: start
    integer :: maxColLen
      integer, allocatable, dimension(:) :: ls
        integer, allocatable, dimension(:) :: pad
      integer :: cIdx
    integer :: plainText2
  adfgvx = 'ADFGVX'
  alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  call main()
  contains
  recursive character(len=100) function shuffleStr(s) result(res)
    character(len=100), intent(in) :: s
    allocate(arr(0))
    i = 0
    do while ((i < size(s)))
      arr = (arr + (/s(((i)+1))/))
      i = (i + 1)
    end do
    j = (size(arr) - 1)
    do while ((j > 0))
      k = mod(now(),((j + 1)))
      tmp = arr(((j)+1))
      arr(((j)+1)) = arr(((k)+1))
      arr(((k)+1)) = tmp
      j = (j - 1)
    end do
    out = ''
    i = 0
    do while ((i < size(arr)))
      out = (out + arr(((i)+1)))
      i = (i + 1)
    end do
    res = out
    return
  end function shuffleStr
  recursive integer function createPolybius() result(res)
    shuffled = shuffleStr(alphabet)
    print *, '6 x 6 Polybius square:'//char(10)//''
    print *, '  | A D F G V X'
    print *, '---------------'
    allocate(p(0))
    i = 0
    do while ((i < 6))
      row = shuffled(((i * 6))+1:(((i + 1)) * 6))
      p = (p + (/row/))
      line = trim(adfgvx((i)+1:(i)+1)) // ' | '
      j = 0
      do while ((j < 6))
        line = (line + row(((j)+1))) // ' '
        j = (j + 1)
      end do
      print *, line
      i = (i + 1)
    end do
    res = p
    return
  end function createPolybius
  recursive character(len=100) function createKey(n) result(res)
    integer, intent(in) :: n
    if ((((n < 7) .or. n) > 12)) then
      print *, 'Key should be within 7 and 12 letters long.'
    end if
    pool = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    key = ''
    i = 0
    do while ((i < n))
      idx = mod(now(),size(pool))
      key = (key + pool(((idx)+1)))
      pool = (pool(1:idx) + pool(((idx + 1))+1:size(pool)))
      i = (i + 1)
    end do
    print *, ''//char(10)//'The key is ' // key
    res = key
    return
  end function createKey
  recursive integer function orderKey(key) result(res)
    character(len=100), intent(in) :: key
    allocate(pairs(0))
    i = 0
    do while ((i < size(key)))
      pairs = (pairs + (/(/key(((i)+1)),i/)/))
      i = (i + 1)
    end do
    n = size(pairs)
    m = 0
    do while ((m < n))
      j = 0
      do while (((j < n) - 1))
        if ((pairs(((j)+1),((0)+1)) > pairs((((j + 1))+1),((0)+1)))) then
          tmp = pairs(((j)+1))
          pairs(((j)+1)) = pairs((((j + 1))+1))
          pairs((((j + 1))+1)) = tmp
        end if
        j = (j + 1)
      end do
      m = (m + 1)
    end do
    allocate(res(0))
    i = 0
    do while ((i < n))
      res = (res + (/int(pairs(((i)+1),((1)+1)))/))
      i = (i + 1)
    end do
    res = res
    return
  end function orderKey
  recursive character(len=100) function encrypt(polybius,key,plainText) result(res)
    integer, intent(in) :: polybius
    character(len=100), intent(in) :: key
    character(len=100), intent(in) :: plainText
    temp = ''
    i = 0
    do while ((i < size(plainText)))
      r = 0
      do while ((r < 6))
        c = 0
        do while ((c < 6))
          if ((polybius(((r)+1),((c)+1)) == plainText(((i)+1)))) then
            temp = trim(temp // trim(adfgvx((r)+1:(r)+1))) // trim(adfgvx((c)+1:(c)+1))
          end if
          c = (c + 1)
        end do
        r = (r + 1)
      end do
      i = (i + 1)
    end do
    colLen = (size(temp) / size(key))
    if ((mod(size(temp),size(key)) > 0)) then
      colLen = (colLen + 1)
    end if
    allocate(table(0))
    rIdx = 0
    do while ((rIdx < colLen))
      allocate(row(0))
      j = 0
      do while ((j < size(key)))
        row = (row + (/''/))
        j = (j + 1)
      end do
      table = (table + (/row/))
      rIdx = (rIdx + 1)
    end do
    idx = 0
    do while ((idx < size(temp)))
      row = (idx / size(key))
      col = mod(idx,size(key))
      table(((row)+1),((col)+1)) = temp((idx)+1:(idx + 1))
      idx = (idx + 1)
    end do
    order = orderKey(key)
    allocate(cols(0))
    ci = 0
    do while ((ci < size(key)))
      colStr = ''
      ri = 0
      do while ((ri < colLen))
        colStr = (colStr + table(((ri)+1),((order(((ci)+1)))+1)))
        ri = (ri + 1)
      end do
      cols = (cols + (/colStr/))
      ci = (ci + 1)
    end do
    result = ''
    ci = 0
    do while ((ci < size(cols)))
      result = (result + cols(((ci)+1)))
      if (((ci < size(cols)) - 1)) then
        result = result // ' '
      end if
      ci = (ci + 1)
    end do
    res = result
    return
  end function encrypt
  recursive integer function indexOf(s,ch) result(res)
    character(len=100), intent(in) :: s
    character(len=100), intent(in) :: ch
    i = 0
    do while ((i < size(s)))
      if ((s(((i)+1)) == ch)) then
        res = i
        return
      end if
      i = (i + 1)
    end do
    res = -1
    return
  end function indexOf
  recursive character(len=100) function decrypt(polybius,key,cipherText) result(res)
    integer, intent(in) :: polybius
    character(len=100), intent(in) :: key
    character(len=100), intent(in) :: cipherText
    allocate(colStrs(0))
    start = 0
    i = 0
    do while ((i <= size(cipherText)))
      if ((((i == size(cipherText)) .or. cipherText(((i)+1))) == ' ')) then
        colStrs = (colStrs + (/cipherText((start)+1:i)/))
        start = (i + 1)
      end if
      i = (i + 1)
    end do
    maxColLen = 0
    i = 0
    do while ((i < size(colStrs)))
      if ((size(colStrs(((i)+1))) > maxColLen)) then
        maxColLen = size(colStrs(((i)+1)))
      end if
      i = (i + 1)
    end do
    allocate(cols(0))
    i = 0
    do while ((i < size(colStrs)))
      s = colStrs(((i)+1))
      allocate(ls(0))
      j = 0
      do while ((j < size(s)))
        ls = (ls + (/s(((j)+1))/))
        j = (j + 1)
      end do
      if ((size(s) < maxColLen)) then
        allocate(pad(0))
        k = 0
        do while ((k < maxColLen))
          if ((k < size(ls))) then
            pad = (pad + (/ls(((k)+1))/))
          else
            pad = (pad + (/''/))
          end if
          k = (k + 1)
        end do
        cols = (cols + (/pad/))
      else
        cols = (cols + (/ls/))
      end if
      i = (i + 1)
    end do
    allocate(table(0))
    r = 0
    do while ((r < maxColLen))
      allocate(row(0))
      c = 0
      do while ((c < size(key)))
        row = (row + (/''/))
        c = (c + 1)
      end do
      table = (table + (/row/))
      r = (r + 1)
    end do
    order = orderKey(key)
    r = 0
    do while ((r < maxColLen))
      c = 0
      do while ((c < size(key)))
        table(((r)+1),((order(((c)+1)))+1)) = cols(((c)+1),((r)+1))
        c = (c + 1)
      end do
      r = (r + 1)
    end do
    temp = ''
    r = 0
    do while ((r < size(table)))
      j = 0
      do while ((j < size(table(((r)+1)))))
        temp = (temp + table(((r)+1),((j)+1)))
        j = (j + 1)
      end do
      r = (r + 1)
    end do
    plainText = ''
    idx = 0
    do while ((idx < size(temp)))
      rIdx = indexOf(adfgvx,temp((idx)+1:(idx + 1)))
      cIdx = indexOf(adfgvx,temp(((idx + 1))+1:(idx + 2)))
      plainText = (plainText + polybius(((rIdx)+1),((cIdx)+1)))
      idx = (idx + 2)
    end do
    res = plainText
    return
  end function decrypt
  recursive subroutine main()
    plainText = 'ATTACKAT1200AM'
    polybius = createPolybius()
    key = createKey(9)
    print *, ''//char(10)//'Plaintext : ' // plainText
    cipherText = encrypt(polybius,key,plainText)
    print *, ''//char(10)//'Encrypted : ' // cipherText
    plainText2 = decrypt(polybius,key,cipherText)
    print *, ''//char(10)//'Decrypted : ' // plainText2
  end subroutine main
end program adfgvx_cipher
