! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program consecutive_primes_with_ascending_or_descending_differences
  implicit none
  integer :: LIMIT
  integer :: primes
    integer, allocatable, dimension(:) :: sieve
    integer :: i
    integer :: p
    integer :: m
    integer, allocatable, dimension(:) :: res
    integer :: x
      logical, allocatable, dimension(:) :: app0
        integer, allocatable, dimension(:) :: app1
    integer :: pd
    integer, dimension(1,1) :: longSeqs
    integer, dimension(1) :: currSeq
    integer :: d
    integer :: ls
    integer, allocatable, dimension(:) :: diffs
    integer :: j
    integer :: k
          integer, allocatable, dimension(:) :: app2
        integer, allocatable, dimension(:) :: app3
      integer, allocatable, dimension(:) :: app4
    character(len=100) :: s5
    integer :: i6
        integer, allocatable, dimension(:) :: app7
        character(len=100) :: s8
        character(len=100) :: s9
      character(len=100) :: s10
    character(len=10), dimension(2) :: arr11 = (/'ascending ','descending'/)
    integer :: i11
  LIMIT = 999999
  primes = primesUpTo(LIMIT)
  call main()
  
  contains
  recursive integer function primesUpTo(n) result(res)
    integer, intent(in) :: n
    allocate(sieve(0))
    i = 0
    do while ((i <= n))
      if (allocated(app0)) deallocate(app0)
      allocate(app0(size(sieve)+1))
      app0(1:size(sieve)) = sieve
      app0(size(sieve)+1) = .true.
      sieve = app0
      i = (i + 1)
    end do
    p = 2
    do while (((p * p) <= n))
      if (sieve(((p)+1))) then
        m = (p * p)
        do while ((m <= n))
          sieve(((m)+1)) = .false.
          m = (m + p)
        end do
      end if
      p = (p + 1)
    end do
    allocate(res(0))
    x = 2
    do while ((x <= n))
      if (sieve(((x)+1))) then
        if (allocated(app1)) deallocate(app1)
        allocate(app1(size(res)+1))
        app1(1:size(res)) = res
        app1(size(res)+1) = x
        res = app1
      end if
      x = (x + 1)
    end do
    res = res
    return
  end function primesUpTo
  recursive subroutine longestSeq(dir)
    character(len=100), intent(in) :: dir
    pd = 0
    longSeqs = reshape((/2/),(/1,1/))
    currSeq = (/2/)
    i = 1
    do while ((i < size(primes)))
      d = (primes(((i)+1)) - primes((((i - 1))+1)))
      if ((((((dir == 'ascending') .and. d) <= pd)) .or. ((((dir == 'descending') .and. d) >= pd)))) then
        if ((1 > size(longSeqs(((0)+1))))) then
          longSeqs = (/currSeq/)
        else if ((1 == size(longSeqs(((0)+1))))) then
          if (allocated(app2)) deallocate(app2)
          allocate(app2(size(longSeqs)+1))
          app2(1:size(longSeqs)) = longSeqs
          app2(size(longSeqs)+1) = currSeq
          longSeqs = app2
        end if
        currSeq = (/primes((((i - 1))+1)),primes(((i)+1))/)
      else
        if (allocated(app3)) deallocate(app3)
        allocate(app3(size(currSeq)+1))
        app3(1:size(currSeq)) = currSeq
        app3(size(currSeq)+1) = primes(((i)+1))
        currSeq = app3
      end if
      pd = d
      i = (i + 1)
    end do
    if ((size(currSeq) > size(longSeqs(((0)+1))))) then
      longSeqs = (/currSeq/)
    else if ((size(currSeq) == size(longSeqs(((0)+1))))) then
      if (allocated(app4)) deallocate(app4)
      allocate(app4(size(longSeqs)+1))
      app4(1:size(longSeqs)) = longSeqs
      app4(size(longSeqs)+1) = currSeq
      longSeqs = app4
    end if
    write(s5,'(G0)') size(longSeqs(((0)+1)))
    print *, trim(trim(trim('Longest run(s) of primes with ' // dir) // ' differences is ') // s5) // ' :'
    do i6 = 1, size(longSeqs)
      ls = longSeqs(i6)
      allocate(diffs(0))
      j = 1
      do while ((j < size(ls)))
        if (allocated(app7)) deallocate(app7)
        allocate(app7(size(diffs)+1))
        app7(1:size(diffs)) = diffs
        app7(size(diffs)+1) = (ls(((j)+1)) - ls((((j - 1))+1)))
        diffs = app7
        j = (j + 1)
      end do
      k = 0
      do while (((k < size(ls)) - 1))
        write(s8,'(G0)') ls(((k)+1))
        write(s9,'(G0)') diffs(((k)+1))
        print *, trim(trim(s8 // ' (') // s9) // ') ', merge('true','false', .false.)
        k = (k + 1)
      end do
      write(s10,'(G0)') ls((((size(ls) - 1))+1))
      print *, s10
    end do
    print *, ''
  end subroutine longestSeq
  recursive subroutine main()
    print *, 'For primes < 1 million:'//char(10)//''
    do i11 = 1, 2
      dir = arr11(i11)
      call longestSeq(dir)
    end do
  end subroutine main
end program consecutive_primes_with_ascending_or_descending_differences
