! Generated by Mochi compiler v0.10.26 on 2025-07-16T09:28:40Z
program bitwise_operations
  implicit none
    integer :: u
    integer :: bits
    integer :: mask
    integer :: i
    integer :: ua
    integer :: ub
    integer :: res
    integer :: bit
      integer :: abit
      integer :: bbit
    integer :: val
    integer :: left
    integer :: right
  bitwise(-460,6)
  contains
  recursive integer function toUnsigned16(n) result(res)
    integer, intent(in) :: n
    u = n
    if ((u < 0)) then
      u = (u + 65536)
    end if
    res = mod(u,65536)
    return
  end function toUnsigned16
  recursive character(len=100) function bin16(n) result(res)
    integer, intent(in) :: n
    u = toUnsigned16(n)
    bits = ''
    mask = 32768
    do i = 0, 16
      if ((u >= mask)) then
        bits = bits // '1'
        u = (u - mask)
      else
        bits = bits // '0'
      end if
      mask = int(((mask / 2)))
    end do
    res = bits
    return
  end function bin16
  recursive integer function bit_and(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    ua = toUnsigned16(a)
    ub = toUnsigned16(b)
    res = 0
    bit = 1
    do i = 0, 16
      if ((mod(((mod(ua,2) == 1) .and. ub),2) == 1)) then
        res = (res + bit)
      end if
      ua = int(((ua / 2)))
      ub = int(((ub / 2)))
      bit = (bit * 2)
    end do
    res = res
    return
  end function bit_and
  recursive integer function bit_or(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    ua = toUnsigned16(a)
    ub = toUnsigned16(b)
    res = 0
    bit = 1
    do i = 0, 16
      if ((mod(((mod(ua,2) == 1) .or. ub),2) == 1)) then
        res = (res + bit)
      end if
      ua = int(((ua / 2)))
      ub = int(((ub / 2)))
      bit = (bit * 2)
    end do
    res = res
    return
  end function bit_or
  recursive integer function bit_xor(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    ua = toUnsigned16(a)
    ub = toUnsigned16(b)
    res = 0
    bit = 1
    do i = 0, 16
      abit = mod(ua,2)
      bbit = mod(ub,2)
      if ((((((abit == 1) .and. bbit) == 0)) .or. ((((abit == 0) .and. bbit) == 1)))) then
        res = (res + bit)
      end if
      ua = int(((ua / 2)))
      ub = int(((ub / 2)))
      bit = (bit * 2)
    end do
    res = res
    return
  end function bit_xor
  recursive integer function bit_not(a) result(res)
    integer, intent(in) :: a
    ua = toUnsigned16(a)
    res = (65535 - ua)
    return
  end function bit_not
  recursive integer function shl(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    ua = toUnsigned16(a)
    i = 0
    do while ((i < b))
      ua = mod(((ua * 2)),65536)
      i = (i + 1)
    end do
    res = ua
    return
  end function shl
  recursive integer function shr(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    ua = toUnsigned16(a)
    i = 0
    do while ((i < b))
      ua = int(((ua / 2)))
      i = (i + 1)
    end do
    res = ua
    return
  end function shr
  recursive integer function las(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    res = shl(a,b)
    return
  end function las
  recursive integer function ras(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    val = a
    i = 0
    do while ((i < b))
      if ((val >= 0)) then
        val = int(((val / 2)))
      else
        val = int(((((val - 1)) / 2)))
      end if
      i = (i + 1)
    end do
    res = toUnsigned16(val)
    return
  end function ras
  recursive integer function rol(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    ua = toUnsigned16(a)
    left = shl(ua,b)
    right = shr(ua,(16 - b))
    res = toUnsigned16((left + right))
    return
  end function rol
  recursive integer function ror(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    ua = toUnsigned16(a)
    right = shr(ua,b)
    left = shl(ua,(16 - b))
    res = toUnsigned16((left + right))
    return
  end function ror
  recursive integer function bitwise(a,b) result(res)
    integer, intent(in) :: a
    integer, intent(in) :: b
    print *, 'a:   ' // bin16(a)
    print *, 'b:   ' // bin16(b)
    print *, 'and: ' // bin16(bit_and(a,b))
    print *, 'or:  ' // bin16(bit_or(a,b))
    print *, 'xor: ' // bin16(bit_xor(a,b))
    print *, 'not: ' // bin16(bit_not(a))
    if ((b < 0)) then
      print *, 'Right operand is negative, but all shifts require an unsigned right operand (shift distance).'
      res = 0
      return
    end if
    print *, 'shl: ' // bin16(shl(a,b))
    print *, 'shr: ' // bin16(shr(a,b))
    print *, 'las: ' // bin16(las(a,b))
    print *, 'ras: ' // bin16(ras(a,b))
    print *, 'rol: ' // bin16(rol(a,b))
    print *, 'ror: ' // bin16(ror(a,b))
  end function bitwise
end program bitwise_operations
