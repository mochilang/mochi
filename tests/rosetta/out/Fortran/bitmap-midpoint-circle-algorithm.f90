! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program bitmap_midpoint_circle_algorithm
  implicit none
  integer :: g
  integer :: row
  integer :: i0
    integer :: y
    integer :: x
        character(len=100), allocatable, dimension(:) :: app1
      integer, allocatable, dimension(:) :: app2
    integer :: err
    integer :: end
    character(len=100) :: s
    integer :: i
  g = circle(10)
  do i0 = 1, size(g)
    row = g(i0)
    print *, trimRight(row)
  end do
  
  contains
  recursive integer function initGrid(size) result(res)
    integer, intent(in) :: size
    allocate(g(0))
    y = 0
    do while ((y < size))
      allocate(row(0))
      x = 0
      do while ((x < size))
        if (allocated(app1)) deallocate(app1)
        allocate(app1(size(row)+1))
        app1(1:size(row)) = row
        app1(size(row)+1) = ' '
        row = app1
        x = (x + 1)
      end do
      if (allocated(app2)) deallocate(app2)
      allocate(app2(size(g)+1))
      app2(1:size(g)) = g
      app2(size(g)+1) = row
      g = app2
      y = (y + 1)
    end do
    res = g
    return
  end function initGrid
  recursive subroutine set(g,x,y)
    integer, intent(in) :: g
    integer, intent(in) :: x
    integer, intent(in) :: y
    if ((((((((x >= 0) .and. x) < size(g(((0)+1)))) .and. y) >= 0) .and. y) < size(g))) then
      g(((y)+1),((x)+1)) = '#'
    end if
  end subroutine set
  recursive integer function circle(r) result(res)
    integer, intent(in) :: r
    size = ((r * 2) + 1)
    g = initGrid(size)
    x = r
    y = 0
    err = (1 - r)
    do while ((y <= x))
      call set(g,(r + x),(r + y))
      call set(g,(r + y),(r + x))
      call set(g,(r - x),(r + y))
      call set(g,(r - y),(r + x))
      call set(g,(r - x),(r - y))
      call set(g,(r - y),(r - x))
      call set(g,(r + x),(r - y))
      call set(g,(r + y),(r - x))
      y = (y + 1)
      if ((err < 0)) then
        err = (((err + 2) * y) + 1)
      else
        x = (x - 1)
        err = (((err + 2) * ((y - x))) + 1)
      end if
    end do
    res = g
    return
  end function circle
  recursive character(len=100) function trimRight(row) result(res)
    integer, intent(in) :: row
    end = size(row)
    do while ((((end > 0) .and. row((((end - 1))+1))) == ' '))
      end = (end - 1)
    end do
    s = ''
    i = 0
    do while ((i < end))
      s = (s + row(((i)+1)))
      i = (i + 1)
    end do
    res = s
    return
  end function trimRight
end program bitmap_midpoint_circle_algorithm
