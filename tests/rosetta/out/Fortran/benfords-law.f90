! Generated by Mochi compiler v0.10.26 on 2006-01-02T15:04:05Z
program benfords_law
  implicit none
    integer :: i
    integer :: y
    character(len=100) :: s0
    integer :: dot
      integer :: decs
    integer :: a
    integer :: b
    integer, allocatable, dimension(:) :: res
      integer, allocatable, dimension(:) :: app1
      integer :: t
    integer, dimension(9) :: counts
    integer :: n
    integer :: i2
      integer :: d
    integer, dimension(9) :: preds
    integer :: total
      integer :: obs
      character(len=100) :: line
      character(len=100) :: s3
  call main()
  contains
  recursive real function floorf(x) result(res)
    real, intent(in) :: x
    res = real((int(x)))
    return
  end function floorf
  recursive integer function indexOf(s,ch) result(res)
    character(len=100), intent(in) :: s
    character(len=100), intent(in) :: ch
    i = 0
    do while ((i < size(s)))
      if ((s(i+1:(i + 1)) == ch)) then
        res = i
        return
      end if
      i = (i + 1)
    end do
    res = -1
    return
  end function indexOf
  recursive character(len=100) function fmtF3(x) result(res)
    real, intent(in) :: x
    y = (floorf(((x * 1000) + 0.5)) / 1000)
    write(s0,'(G0)') y
    s = s0
    dot = indexOf(s,'.')
    if (((dot == 0) - 1)) then
      s = s // '.000'
    else
      decs = ((size(s) - dot) - 1)
      if ((decs > 3)) then
        s = s(0+1:(dot + 4))
      else
        do while ((decs < 3))
          s = s // '0'
          decs = (decs + 1)
        end do
      end if
    end if
    res = s
    return
  end function fmtF3
  recursive character(len=100) function padFloat3(x,width) result(res)
    real, intent(in) :: x
    integer, intent(in) :: width
    s = fmtF3(x)
    do while ((size(s) < width))
      s = ' ' // s
    end do
    res = s
    return
  end function padFloat3
  recursive integer function fib1000() result(res)
    a = 0
    b = 1
    allocate(res(0))
    i = 0
    do while ((i < 1000))
      if (allocated(app1)) deallocate(app1)
      allocate(app1(size(res)+1))
      app1(1:size(res)) = res
      app1(size(res)+1) = b
      res = app1
      t = b
      b = (b + a)
      a = t
      i = (i + 1)
    end do
    res = res
    return
  end function fib1000
  recursive integer function leadingDigit(x) result(res)
    real, intent(in) :: x
    if ((x < 0)) then
      x = -x
    end if
    do while ((x >= 10))
      x = (x / 10)
    end do
    do while ((((x > 0) .and. x) < 1))
      x = (x * 10)
    end do
    res = int(x)
    return
  end function leadingDigit
  recursive subroutine show(nums,title)
    integer, intent(in) :: nums
    character(len=100), intent(in) :: title
    counts = (/0,0,0,0,0,0,0,0,0/)
    do i2 = 1, size(nums)
      n = nums(i2)
      d = leadingDigit(n)
      if ((((d >= 1) .and. d) <= 9)) then
        counts((((d - 1))+1)) = (counts((((d - 1))+1)) + 1)
      end if
    end do
    preds = (/0.301,0.176,0.125,0.097,0.079,0.067,0.058,0.051,0.046/)
    total = size(nums)
    print *, title
    print *, 'Digit  Observed  Predicted'
    i = 0
    do while ((i < 9))
      obs = ((real(counts(((i)+1)))) / (real(total)))
      write(s3,'(G0)') (i + 1)
      line = trim(trim(trim(trim('  ' // s3) // '  ') // padFloat3(obs,9)) // '  ') // padFloat3(preds(((i)+1)),8)
      print *, line
      i = (i + 1)
    end do
  end subroutine show
  recursive subroutine main()
    call show(fib1000(),'First 1000 Fibonacci numbers')
  end subroutine main
end program benfords_law
