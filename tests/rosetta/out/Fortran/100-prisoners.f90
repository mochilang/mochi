! Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
program p_100_prisoners
  implicit none
    integer :: arr
    integer :: i
    integer :: j
    integer :: tmp
    integer :: pardoned
    integer :: t
    integer, allocatable, dimension(:) :: drawers
    integer :: p
    logical :: success
    logical :: found
    integer :: prev
    integer :: d
    integer :: this
    logical, allocatable, dimension(:) :: opened
    integer :: k
    integer :: n
    integer :: rf
        integer, allocatable, dimension(:) :: app0
            logical, allocatable, dimension(:) :: app1
    character(len=100) :: s2
    character(len=100) :: s3
    character(len=256) :: pbuf4
    integer :: strat
    integer, dimension(2) :: arr5 = (/10,100/)
    integer :: i5
      character(len=100) :: s6
      character(len=100) :: s7
      character(len=7), dimension(2) :: arr8 = (/'random ','optimal'/)
      integer :: i8
  call main()
  
  contains
  recursive function shuffle(xs) result(res)
    integer, allocatable, dimension(:) :: res
    integer, intent(in), dimension(:) :: xs
    arr = xs
    i = 99
    do while ((i > 0))
      j = mod(now(),((i + 1)))
      tmp = arr(((i)+1))
      arr(((i)+1)) = arr(((j)+1))
      arr(((j)+1)) = tmp
      i = (i - 1)
    end do
    res = arr
    return
  end function shuffle
  recursive subroutine doTrials(trials,np,strategy)
    integer, intent(in) :: trials
    integer, intent(in) :: np
    character(len=100), intent(in) :: strategy
    pardoned = 0
    t = 0
    do while ((t < trials))
      allocate(drawers(0))
      i = 0
      do while ((i < 100))
        if (allocated(app0)) deallocate(app0)
        allocate(app0(size(drawers)+1))
        app0(1:size(drawers)) = drawers
        app0(size(drawers)+1) = i
        drawers = app0
        i = (i + 1)
      end do
      drawers = shuffle(drawers)
      p = 0
      success = .true.
      do while ((p < np))
        found = .false.
        if ((strategy == 'optimal')) then
          prev = p
          d = 0
          do while ((d < 50))
            this = drawers(((prev)+1))
            if ((this == p)) then
              found = .true.
              exit
            end if
            prev = this
            d = (d + 1)
          end do
        else
          allocate(opened(0))
          k = 0
          do while ((k < 100))
            if (allocated(app1)) deallocate(app1)
            allocate(app1(size(opened)+1))
            app1(1:size(opened)) = opened
            app1(size(opened)+1) = .false.
            opened = app1
            k = (k + 1)
          end do
          d = 0
          do while ((d < 50))
            n = mod(now(),100)
            do while (opened(((n)+1)))
              n = mod(now(),100)
            end do
            opened(((n)+1)) = .true.
            if ((drawers(((n)+1)) == p)) then
              found = .true.
              exit
            end if
            d = (d + 1)
          end do
        end if
        if (.not. found) then
          success = .false.
          exit
        end if
        p = (p + 1)
      end do
      if (success) then
        pardoned = (pardoned + 1)
      end if
      t = (t + 1)
    end do
    rf = (((real(pardoned)) / (real(trials))) * 100.0)
    write(s2,'(G0)') pardoned
    write(s3,'(G0)') rf
    pbuf4 = trim(trim(trim(trim(trim('  strategy = ' // strategy) // '  pardoned = ') // s2) // ' relative frequency = ') // s3) // '%'
    print *, pbuf4
  end subroutine doTrials
  recursive subroutine main()
    trials = 1000
    do i5 = 1, 2
      np = arr5(i5)
      write(s6,'(G0)') trials
      write(s7,'(G0)') np
      print *, trim(trim(trim('Results from ' // s6) // ' trials with ') // s7) // ' prisoners:'//char(10)//''
      do i8 = 1, 2
        strat = arr8(i8)
        call doTrials(trials,np,strat)
      end do
    end do
  end subroutine main
  integer function now() result(res)
    integer :: c,r
    call system_clock(count=c,count_rate=r)
    res = c
    return
  end function now
end program p_100_prisoners
