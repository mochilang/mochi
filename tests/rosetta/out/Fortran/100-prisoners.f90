! Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
program p_100_prisoners
  implicit none
    integer :: arr
    integer :: i
      integer :: j
      integer :: tmp
    integer :: pardoned
    integer :: t
    integer :: rf
      integer, allocatable, dimension(:) :: drawers
        integer, allocatable, dimension(:) :: app0
      integer :: p
      logical :: success
        logical :: found
          integer :: prev
          integer :: d
            integer :: this
          integer, allocatable, dimension(:) :: opened
          integer :: k
            logical, allocatable, dimension(:) :: app1
            integer :: n
    character(len=100) :: s2
    character(len=100) :: s3
    integer, dimension(2) :: arr4 = (/10,100/)
    integer :: i4
      character(len=100) :: s5
      character(len=100) :: s6
      integer :: strat
      character(len=7), dimension(2) :: arr7 = (/'random ','optimal'/)
      integer :: i7
  call main()
  
  contains
  recursive integer function shuffle(xs) result(res)
    integer, intent(in) :: xs
    arr = xs
    i = 99
    do while ((i > 0))
      j = mod(now(),((i + 1)))
      tmp = arr(((i)+1))
      arr(((i)+1)) = arr(((j)+1))
      arr(((j)+1)) = tmp
      i = (i - 1)
    end do
    res = arr
    return
  end function shuffle
  recursive subroutine doTrials(trials,np,strategy)
    integer, intent(in) :: trials
    integer, intent(in) :: np
    character(len=100), intent(in) :: strategy
    pardoned = 0
    t = 0
    do while ((t < trials))
      allocate(drawers(0))
      i = 0
      do while ((i < 100))
        if (allocated(app0)) deallocate(app0)
        allocate(app0(size(drawers)+1))
        app0(1:size(drawers)) = drawers
        app0(size(drawers)+1) = i
        drawers = app0
        i = (i + 1)
      end do
      drawers = shuffle(drawers)
      p = 0
      success = .true.
      do while ((p < np))
        found = .false.
        if ((strategy == 'optimal')) then
          prev = p
          d = 0
          do while ((d < 50))
            this = drawers(((prev)+1))
            if ((this == p)) then
              found = .true.
              exit
            end if
            prev = this
            d = (d + 1)
          end do
        else
          allocate(opened(0))
          k = 0
          do while ((k < 100))
            if (allocated(app1)) deallocate(app1)
            allocate(app1(size(opened)+1))
            app1(1:size(opened)) = opened
            app1(size(opened)+1) = .false.
            opened = app1
            k = (k + 1)
          end do
          d = 0
          do while ((d < 50))
            n = mod(now(),100)
            do while (opened(((n)+1)))
              n = mod(now(),100)
            end do
            opened(((n)+1)) = .true.
            if ((drawers(((n)+1)) == p)) then
              found = .true.
              exit
            end if
            d = (d + 1)
          end do
        end if
        if (.not. found) then
          success = .false.
          exit
        end if
        p = (p + 1)
      end do
      if (success) then
        pardoned = (pardoned + 1)
      end if
      t = (t + 1)
    end do
    rf = (((real(pardoned)) / (real(trials))) * 100.0)
    write(s2,'(G0)') pardoned
    write(s3,'(G0)') rf
    print *, trim(trim(trim(trim(trim('  strategy = ' // strategy) // '  pardoned = ') // s2) // ' relative frequency = ') // s3) // '%'
  end subroutine doTrials
  recursive subroutine main()
    trials = 1000
    do i4 = 1, 2
      np = arr4(i4)
      write(s5,'(G0)') trials
      write(s6,'(G0)') np
      print *, trim(trim(trim('Results from ' // s5) // ' trials with ') // s6) // ' prisoners:'//char(10)//''
      do i7 = 1, 2
        strat = arr7(i7)
        call doTrials(trials,np,strat)
      end do
    end do
  end subroutine main
end program p_100_prisoners
