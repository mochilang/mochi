# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:44Z
defmodule Pixel do
  @type t :: %__MODULE__{R: integer(), G: integer(), B: integer()}
  defstruct R: nil, G: nil, B: nil
end

defmodule Bitmap do
  @type t :: %__MODULE__{cols: integer(), rows: integer(), px: list(list(Pixel))}
  defstruct cols: nil, rows: nil, px: nil
end

defmodule Main do
	@spec pixelFromRgb(integer()) :: Pixel
	def pixelFromRgb(c) do
		try do
			r = rem(String.to_integer((c / 65536)), 256)
			g = rem(String.to_integer((c / 256)), 256)
			b = rem(c, 256)
			throw {:return, %Pixel{R: r, G: g, B: b}}
		catch {:return, v} -> v end
	end
	
	@spec rgbFromPixel(Pixel) :: integer()
	def rgbFromPixel(p) do
		try do
			throw {:return, (((p.R * 65536) + (p.G * 256)) + p.B)}
		catch {:return, v} -> v end
	end
	
	@spec NewBitmap(integer(), integer()) :: Bitmap
	def NewBitmap(x, y) do
		try do
			data = []
			_ = data
			row = 0
			_ = row
			t1 = fn t1, data, row ->
				try do
					if (row < y) do
						r = []
						_ = r
						col = 0
						_ = col
						t2 = fn t2, col, r ->
							try do
								if (col < x) do
									r = r ++ [%Pixel{R: 0, G: 0, B: 0}]
									col = (col + 1)
									t2.(t2, col, r)
								else
									{:ok, col, r}
								end
							catch :break ->
								{:ok, col, r}
							end
						end
						{_, col, r} = t2.(t2, col, r)
						_ = col
						_ = r
						data = data ++ [r]
						row = (row + 1)
						t1.(t1, data, row)
					else
						{:ok, data, row}
					end
				catch :break ->
					{:ok, data, row}
				end
			end
			{_, data, row} = t1.(t1, data, row)
			_ = data
			_ = row
			throw {:return, %Bitmap{cols: x, rows: y, px: data}}
		catch {:return, v} -> v end
	end
	
	@spec FillRgb(Bitmap, integer()) :: nil
	def FillRgb(b, c) do
		try do
			y = 0
			_ = y
			p = pixelFromRgb(c)
			t3 = fn t3, b, y ->
				try do
					if (y < b.rows) do
						x = 0
						_ = x
						t4 = fn t4, b, x ->
							try do
								if (x < b.cols) do
									px = b.px
									_ = px
									row = Enum.at((px), y)
									_ = row
									row = Map.put(row, x, p)
									px = Map.put(px, y, row)
									b = %{b | px: px}
									x = (x + 1)
									t4.(t4, b, x)
								else
									{:ok, b, x}
								end
							catch :break ->
								{:ok, b, x}
							end
						end
						{_, b, x} = t4.(t4, b, x)
						_ = b
						_ = x
						y = (y + 1)
						t3.(t3, b, y)
					else
						{:ok, b, y}
					end
				catch :break ->
					{:ok, b, y}
				end
			end
			{_, b, y} = t3.(t3, b, y)
			_ = b
			_ = y
		catch {:return, v} -> v end
	end
	
	@spec SetPxRgb(Bitmap, integer(), integer(), integer()) :: boolean()
	def SetPxRgb(b, x, y, c) do
		try do
			if ((((x < 0) || (x >= b.cols)) || (y < 0)) || (y >= b.rows)) do
				throw {:return, false}
			end
			px = b.px
			_ = px
			row = Enum.at((px), y)
			_ = row
			row = Map.put(row, x, pixelFromRgb(c))
			px = Map.put(px, y, row)
			b = %{b | px: px}
			throw {:return, true}
		catch {:return, v} -> v end
	end
	
	@spec nextRand(integer()) :: integer()
	def nextRand(seed) do
		try do
			throw {:return, rem(((seed * 1664525) + 1013904223), 2147483648)}
		catch {:return, v} -> v end
	end
	
	@spec main() :: nil
	def main() do
		try do
			bm = NewBitmap(400, 300)
			_ = bm
			FillRgb(bm, 12615744)
			seed = _now()
			_ = seed
			i = 0
			_ = i
			t5 = fn t5, i, seed ->
				try do
					if (i < 2000) do
						seed = nextRand(seed)
						x = rem(seed, 400)
						seed = nextRand(seed)
						y = rem(seed, 300)
						SetPxRgb(bm, x, y, 8405024)
						i = (i + 1)
						t5.(t5, i, seed)
					else
						{:ok, i, seed}
					end
				catch :break ->
					{:ok, i, seed}
				end
			end
			{_, i, seed} = t5.(t5, i, seed)
			_ = i
			_ = seed
			x = 0
			_ = x
			t6 = fn t6, x ->
				try do
					if (x < 400) do
						y = 240
						_ = y
						t7 = fn t7, y ->
							try do
								if (y < 245) do
									SetPxRgb(bm, x, y, 8405024)
									y = (y + 1)
									t7.(t7, y)
								else
									{:ok, y}
								end
							catch :break ->
								{:ok, y}
							end
						end
						{_, y} = t7.(t7, y)
						_ = y
						y = 260
						t8 = fn t8, y ->
							try do
								if (y < 265) do
									SetPxRgb(bm, x, y, 8405024)
									y = (y + 1)
									t8.(t8, y)
								else
									{:ok, y}
								end
							catch :break ->
								{:ok, y}
							end
						end
						{_, y} = t8.(t8, y)
						_ = y
						x = (x + 1)
						t6.(t6, x)
					else
						{:ok, x}
					end
				catch :break ->
					{:ok, x}
				end
			end
			{_, x} = t6.(t6, x)
			_ = x
			y = 0
			_ = y
			t9 = fn t9, y ->
				try do
					if (y < 300) do
						x = 80
						_ = x
						t10 = fn t10, x ->
							try do
								if (x < 85) do
									SetPxRgb(bm, x, y, 8405024)
									x = (x + 1)
									t10.(t10, x)
								else
									{:ok, x}
								end
							catch :break ->
								{:ok, x}
							end
						end
						{_, x} = t10.(t10, x)
						_ = x
						x = 95
						t11 = fn t11, x ->
							try do
								if (x < 100) do
									SetPxRgb(bm, x, y, 8405024)
									x = (x + 1)
									t11.(t11, x)
								else
									{:ok, x}
								end
							catch :break ->
								{:ok, x}
							end
						end
						{_, x} = t11.(t11, x)
						_ = x
						y = (y + 1)
						t9.(t9, y)
					else
						{:ok, y}
					end
				catch :break ->
					{:ok, y}
				end
			end
			{_, y} = t9.(t9, y)
			_ = y
		catch {:return, v} -> v end
	end
	
	def main do
		main()
	end
	defp _now() do
  System.os_time(:millisecond)
end

	end
Main.main()
