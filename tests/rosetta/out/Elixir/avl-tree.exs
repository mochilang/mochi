# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:07Z
defmodule Main do
	@spec Node(integer()) :: map()
	def Node(data) do
		try do
			throw {:return, %{"Data" => data, "Balance" => 0, "Link" => [nil, nil]}}
		catch {:return, v} -> v end
	end
	
	@spec getLink(map(), integer()) :: any()
	def getLink(n, dir) do
		try do
			throw {:return, Enum.at((Enum.at((n), "Link")), dir)}
		catch {:return, v} -> v end
	end
	
	@spec setLink(map(), integer(), any()) :: nil
	def setLink(n, dir, v) do
		try do
			links = Enum.at((n), "Link")
			_ = links
			links = Map.put(links, dir, v)
			n = Map.put(n, "Link", links)
		catch {:return, v} -> v end
	end
	
	@spec opp(integer()) :: integer()
	def opp(dir) do
		try do
			throw {:return, (1 - dir)}
		catch {:return, v} -> v end
	end
	
	@spec single(map(), integer()) :: map()
	def single(root, dir) do
		try do
			tmp = getLink(root, opp(dir))
			_ = tmp
			setLink(root, opp(dir), getLink(tmp, dir))
			setLink(tmp, dir, root)
			throw {:return, tmp}
		catch {:return, v} -> v end
	end
	
	@spec double(map(), integer()) :: map()
	def double(root, dir) do
		try do
			tmp = getLink(getLink(root, opp(dir)), dir)
			_ = tmp
			setLink(getLink(root, opp(dir)), dir, getLink(tmp, opp(dir)))
			setLink(tmp, opp(dir), getLink(root, opp(dir)))
			setLink(root, opp(dir), tmp)
			tmp = getLink(root, opp(dir))
			setLink(root, opp(dir), getLink(tmp, dir))
			setLink(tmp, dir, root)
			throw {:return, tmp}
		catch {:return, v} -> v end
	end
	
	@spec adjustBalance(map(), integer(), integer()) :: nil
	def adjustBalance(root, dir, bal) do
		try do
			n = getLink(root, dir)
			_ = n
			nn = getLink(n, opp(dir))
			_ = nn
			if (Enum.at((nn), "Balance") == 0) do
				root = Map.put(root, "Balance", 0)
				n = Map.put(n, "Balance", 0)
			else
				if (Enum.at((nn), "Balance") == bal) do
					root = Map.put(root, "Balance", -bal)
					n = Map.put(n, "Balance", 0)
				else
					root = Map.put(root, "Balance", 0)
					n = Map.put(n, "Balance", bal)
				end
			end
			nn = Map.put(nn, "Balance", 0)
		catch {:return, v} -> v end
	end
	
	@spec insertBalance(map(), integer()) :: map()
	def insertBalance(root, dir) do
		try do
			n = getLink(root, dir)
			_ = n
			bal = ((2 * dir) - 1)
			_ = bal
			if (Enum.at((n), "Balance") == bal) do
				root = Map.put(root, "Balance", 0)
				n = Map.put(n, "Balance", 0)
				throw {:return, single(root, opp(dir))}
			end
			adjustBalance(root, dir, bal)
			throw {:return, double(root, opp(dir))}
		catch {:return, v} -> v end
	end
	
	@spec insertR(any(), integer()) :: map()
	def insertR(root, data) do
		try do
			if (root == nil) do
				throw {:return, %{"node" => Node(data), "done" => false}}
			end
			node = root
			_ = node
			dir = 0
			_ = dir
			if (String.to_integer(Enum.at((node), "Data")) < data) do
				dir = 1
			end
			r = insertR(getLink(node, dir), data)
			_ = r
			setLink(node, dir, Enum.at((r), "node"))
			if Enum.at((r), "done") do
				throw {:return, %{"node" => node, "done" => true}}
			end
			node = Map.put(node, "Balance", (String.to_integer(Enum.at((node), "Balance")) + ((2 * dir) - 1)))
			if (Enum.at((node), "Balance") == 0) do
				throw {:return, %{"node" => node, "done" => true}}
			end
			if ((Enum.at((node), "Balance") == 1) || (Enum.at((node), "Balance") == -1)) do
				throw {:return, %{"node" => node, "done" => false}}
			end
			throw {:return, %{"node" => insertBalance(node, dir), "done" => true}}
		catch {:return, v} -> v end
	end
	
	@spec Insert(any(), integer()) :: any()
	def Insert(tree, data) do
		try do
			r = insertR(tree, data)
			throw {:return, Enum.at((r), "node")}
		catch {:return, v} -> v end
	end
	
	@spec removeBalance(map(), integer()) :: map()
	def removeBalance(root, dir) do
		try do
			n = getLink(root, opp(dir))
			_ = n
			bal = ((2 * dir) - 1)
			_ = bal
			if (Enum.at((n), "Balance") == -bal) do
				root = Map.put(root, "Balance", 0)
				n = Map.put(n, "Balance", 0)
				throw {:return, %{"node" => single(root, dir), "done" => false}}
			end
			if (Enum.at((n), "Balance") == bal) do
				adjustBalance(root, opp(dir), -bal)
				throw {:return, %{"node" => double(root, dir), "done" => false}}
			end
			root = Map.put(root, "Balance", -bal)
			n = Map.put(n, "Balance", bal)
			throw {:return, %{"node" => single(root, dir), "done" => true}}
		catch {:return, v} -> v end
	end
	
	@spec removeR(any(), integer()) :: map()
	def removeR(root, data) do
		try do
			if (root == nil) do
				throw {:return, %{"node" => nil, "done" => false}}
			end
			node = root
			_ = node
			if (String.to_integer(Enum.at((node), "Data")) == data) do
				if (getLink(node, 0) == nil) do
					throw {:return, %{"node" => getLink(node, 1), "done" => false}}
				end
				if (getLink(node, 1) == nil) do
					throw {:return, %{"node" => getLink(node, 0), "done" => false}}
				end
				heir = getLink(node, 0)
				_ = heir
				t1 = fn t1, heir ->
					try do
						if (getLink(heir, 1) != nil) do
							heir = getLink(heir, 1)
							t1.(t1, heir)
						else
							{:ok, heir}
						end
					catch :break ->
						{:ok, heir}
					end
				end
				{_, heir} = t1.(t1, heir)
				_ = heir
				node = Map.put(node, "Data", Enum.at((heir), "Data"))
				data = String.to_integer(Enum.at((heir), "Data"))
			end
			dir = 0
			_ = dir
			if (String.to_integer(Enum.at((node), "Data")) < data) do
				dir = 1
			end
			r = removeR(getLink(node, dir), data)
			_ = r
			setLink(node, dir, Enum.at((r), "node"))
			if Enum.at((r), "done") do
				throw {:return, %{"node" => node, "done" => true}}
			end
			node = Map.put(node, "Balance", ((String.to_integer(Enum.at((node), "Balance")) + 1) - (2 * dir)))
			if ((Enum.at((node), "Balance") == 1) || (Enum.at((node), "Balance") == -1)) do
				throw {:return, %{"node" => node, "done" => true}}
			end
			if (Enum.at((node), "Balance") == 0) do
				throw {:return, %{"node" => node, "done" => false}}
			end
			throw {:return, removeBalance(node, dir)}
		catch {:return, v} -> v end
	end
	
	@spec Remove(any(), integer()) :: any()
	def Remove(tree, data) do
		try do
			r = removeR(tree, data)
			throw {:return, Enum.at((r), "node")}
		catch {:return, v} -> v end
	end
	
	@spec indentStr(integer()) :: String.t()
	def indentStr(n) do
		try do
			s = ""
			_ = s
			i = 0
			_ = i
			t2 = fn t2, i, s ->
				try do
					if (i < n) do
						s = (s <> " ")
						i = (i + 1)
						t2.(t2, i, s)
					else
						{:ok, i, s}
					end
				catch :break ->
					{:ok, i, s}
				end
			end
			{_, i, s} = t2.(t2, i, s)
			_ = i
			_ = s
			throw {:return, s}
		catch {:return, v} -> v end
	end
	
	@spec dumpNode(any(), integer(), boolean()) :: nil
	def dumpNode(node, indent, comma) do
		try do
			sp = indentStr(indent)
			if (node == nil) do
				line = (sp <> "null")
				_ = line
				if comma do
					line = (line <> ",")
				end
				IO.inspect(line)
			else
				IO.inspect((sp <> "{"))
				IO.puts((((indentStr((indent + 3)) <> "\"Data\": ") <> to_string(Enum.at((node), "Data"))) <> ","))
				IO.puts((((indentStr((indent + 3)) <> "\"Balance\": ") <> to_string(Enum.at((node), "Balance"))) <> ","))
				IO.puts((indentStr((indent + 3)) <> "\"Link\": ["))
				dumpNode(getLink(node, 0), (indent + 6), true)
				dumpNode(getLink(node, 1), (indent + 6), false)
				IO.puts((indentStr((indent + 3)) <> "]"))
				end_ = (sp <> "}")
				_ = end_
				if comma do
					end_ = (end_ <> ",")
				end
				IO.inspect(end_)
			end
		catch {:return, v} -> v end
	end
	
	@spec dump(any(), integer()) :: nil
	def dump(node, indent) do
		try do
			dumpNode(node, indent, false)
		catch {:return, v} -> v end
	end
	
	@spec main() :: nil
	def main() do
		try do
			tree = nil
			_ = tree
			IO.puts("Empty tree:")
			dump(tree, 0)
			IO.puts("")
			IO.puts("Insert test:")
			tree = Insert(tree, 3)
			tree = Insert(tree, 1)
			tree = Insert(tree, 4)
			tree = Insert(tree, 1)
			tree = Insert(tree, 5)
			dump(tree, 0)
			IO.puts("")
			IO.puts("Remove test:")
			tree = Remove(tree, 3)
			tree = Remove(tree, 1)
			t = tree
			_ = t
			t = Map.put(t, "Balance", 0)
			tree = t
			dump(tree, 0)
		catch {:return, v} -> v end
	end
	
	def main do
		main()
	end
	end
Main.main()
