# Generated by Mochi compiler v0.10.26 on 2025-07-16T14:14:32Z
defmodule Main do
  @spec indexOf(String.t(), String.t()) :: integer()
  def indexOf(s, ch) do
    try do
      i = 0
      _ = i

      t1 = fn t1, i ->
        try do
          if i < _length(s) do
            if _slice_string(s, i, i + 1) == ch do
              throw({:return, i})
            end

            i = i + 1
            t1.(t1, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t1.(t1, i)
      _ = i
      throw({:return, -1})
    catch
      {:return, v} -> v
    end
  end

  @spec ord(String.t()) :: integer()
  def ord(ch) do
    try do
      # upper :: (String.t() -> String.t())
      upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      # lower :: (any() -> String.t())
      lower = "abcdefghijklmnopqrstuvwxyz"
      idx = indexOf(upper, ch)
      _ = idx

      if idx >= 0 do
        throw({:return, 65 + idx})
      end

      idx = indexOf(lower, ch)

      if idx >= 0 do
        throw({:return, 97 + idx})
      end

      throw({:return, 0})
    catch
      {:return, v} -> v
    end
  end

  @spec chr(integer()) :: String.t()
  def chr(n) do
    try do
      # upper :: (String.t() -> String.t())
      upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      # lower :: (any() -> String.t())
      lower = "abcdefghijklmnopqrstuvwxyz"

      if n >= 65 && n < 91 do
        throw({:return, _slice_string(upper, n - 65, n - 64)})
      end

      if n >= 97 && n < 123 do
        throw({:return, _slice_string(lower, n - 97, n - 96)})
      end

      throw({:return, "?"})
    catch
      {:return, v} -> v
    end
  end

  @spec shiftRune(String.t(), integer()) :: String.t()
  def shiftRune(r, k) do
    try do
      if r >= "a" && r <= "z" do
        throw({:return, chr(rem(ord(r) - 97 + k, 26) + 97)})
      end

      if r >= "A" && r <= "Z" do
        throw({:return, chr(rem(ord(r) - 65 + k, 26) + 65)})
      end

      throw({:return, r})
    catch
      {:return, v} -> v
    end
  end

  @spec encipher(String.t(), integer()) :: String.t()
  def encipher(s, k) do
    try do
      out = ""
      _ = out
      i = 0
      _ = i

      t2 = fn t2, i, out ->
        try do
          if i < _length(s) do
            out = out + shiftRune(_slice_string(s, i, i + 1), k)
            i = i + 1
            t2.(t2, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t2.(t2, i, out)
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec decipher(String.t(), integer()) :: String.t()
  def decipher(s, k) do
    try do
      throw({:return, encipher(s, rem(26 - rem(k, 26), 26))})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      pt = "The five boxing wizards jump quickly"
      IO.inspect("Plaintext: " <> pt)

      _ =
        Enum.reduce_while([0, 1, 7, 25, 26], :ok, fn key, _acc ->
          try do
            if key < 1 || key > 25 do
              IO.puts(("Key " <> to_string(key)) <> " invalid")
              throw(:continue)
            end

            ct = encipher(pt, key)
            IO.puts("Key " <> to_string(key))
            IO.inspect("  Enciphered: " <> ct)
            IO.puts("  Deciphered: " <> decipher(ct, key))
            {:cont, :ok}
          catch
            :break -> {:halt, :ok}
            :continue -> {:cont, :ok}
          end
        end)
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _length(v) do
    cond do
      is_binary(v) -> String.length(v)
      is_list(v) -> length(v)
      is_map(v) and Map.has_key?(v, :items) -> length(Map.get(v, :items))
      is_map(v) -> map_size(v)
      true -> raise "len expects list, map or string"
    end
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
