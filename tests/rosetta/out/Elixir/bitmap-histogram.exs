# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:40Z
defmodule Main do
  @spec image() :: list(list(integer()))
  def image() do
    try do
      throw({:return, [[0, 0, 10000], [65535, 65535, 65535], [65535, 65535, 65535]]})
    catch
      {:return, v} -> v
    end
  end

  @spec histogram(list(list(integer())), integer()) :: list(integer())
  def histogram(g, bins) do
    try do
      if bins <= 0 do
        bins = length(Enum.at(g, 0))
      end

      h = []
      _ = h
      i = 0
      _ = i

      t1 = fn t1, h, i ->
        try do
          if i < bins do
            h = h ++ [0]
            i = i + 1
            t1.(t1, h, i)
          else
            {:ok, h, i}
          end
        catch
          :break ->
            {:ok, h, i}
        end
      end

      {_, h, i} = t1.(t1, h, i)
      _ = h
      _ = i
      y = 0
      _ = y

      t2 = fn t2, h, y ->
        try do
          if y < length(g) do
            row = Enum.at(g, y)
            _ = row
            x = 0
            _ = x

            t3 = fn t3, h, x ->
              try do
                if x < length(row) do
                  p = Enum.at(row, x)
                  _ = p
                  idx = String.to_integer(p * (bins - 1) / 65535)
                  _ = idx
                  h = Map.put(h, idx, Enum.at(h, idx) + 1)
                  x = x + 1
                  t3.(t3, h, x)
                else
                  {:ok, h, x}
                end
              catch
                :break ->
                  {:ok, h, x}
              end
            end

            {_, h, x} = t3.(t3, h, x)
            _ = h
            _ = x
            y = y + 1
            t2.(t2, h, y)
          else
            {:ok, h, y}
          end
        catch
          :break ->
            {:ok, h, y}
        end
      end

      {_, h, y} = t2.(t2, h, y)
      _ = h
      _ = y
      throw({:return, h})
    catch
      {:return, v} -> v
    end
  end

  @spec medianThreshold(list(integer())) :: integer()
  def medianThreshold(h) do
    try do
      lb = 0
      _ = lb
      ub = length(h) - 1
      _ = ub
      lSum = 0
      _ = lSum
      uSum = 0
      _ = uSum

      t4 = fn t4, lSum, lb, uSum, ub ->
        try do
          if lb <= ub do
            if lSum + Enum.at(h, lb) < uSum + Enum.at(h, ub) do
              lSum = lSum + Enum.at(h, lb)
              lb = lb + 1
            else
              uSum = uSum + Enum.at(h, ub)
              ub = ub - 1
            end

            t4.(t4, lSum, lb, uSum, ub)
          else
            {:ok, lSum, lb, uSum, ub}
          end
        catch
          :break ->
            {:ok, lSum, lb, uSum, ub}
        end
      end

      {_, lSum, lb, uSum, ub} = t4.(t4, lSum, lb, uSum, ub)
      _ = lSum
      _ = lb
      _ = uSum
      _ = ub
      throw({:return, String.to_integer(ub * 65535 / length(h))})
    catch
      {:return, v} -> v
    end
  end

  @spec threshold(list(list(integer())), integer()) :: list(list(integer()))
  def threshold(g, t) do
    try do
      out = []
      _ = out
      y = 0
      _ = y

      t5 = fn t5, out, y ->
        try do
          if y < length(g) do
            row = Enum.at(g, y)
            _ = row
            newRow = []
            _ = newRow
            x = 0
            _ = x

            t6 = fn t6, newRow, x ->
              try do
                if x < length(row) do
                  if Enum.at(row, x) < t do
                    newRow = newRow ++ [0]
                  else
                    newRow = newRow ++ [65535]
                  end

                  x = x + 1
                  t6.(t6, newRow, x)
                else
                  {:ok, newRow, x}
                end
              catch
                :break ->
                  {:ok, newRow, x}
              end
            end

            {_, newRow, x} = t6.(t6, newRow, x)
            _ = newRow
            _ = x
            out = out ++ [newRow]
            y = y + 1
            t5.(t5, out, y)
          else
            {:ok, out, y}
          end
        catch
          :break ->
            {:ok, out, y}
        end
      end

      {_, out, y} = t5.(t5, out, y)
      _ = out
      _ = y
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec printImage(list(list(integer()))) :: nil
  def printImage(g) do
    try do
      y = 0
      _ = y

      t7 = fn t7, y ->
        try do
          if y < length(g) do
            row = Enum.at(g, y)
            _ = row
            line = ""
            _ = line
            x = 0
            _ = x

            t8 = fn t8, line, x ->
              try do
                if x < length(row) do
                  if Enum.at(row, x) == 0 do
                    line = line <> "0"
                  else
                    line = line <> "1"
                  end

                  x = x + 1
                  t8.(t8, line, x)
                else
                  {:ok, line, x}
                end
              catch
                :break ->
                  {:ok, line, x}
              end
            end

            {_, line, x} = t8.(t8, line, x)
            _ = line
            _ = x
            IO.inspect(line)
            y = y + 1
            t7.(t7, y)
          else
            {:ok, y}
          end
        catch
          :break ->
            {:ok, y}
        end
      end

      {_, y} = t7.(t7, y)
      _ = y
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      img = image()
      h = histogram(img, 0)
      IO.puts("Histogram: " <> to_string(h))
      t = medianThreshold(h)
      IO.puts("Threshold: " <> to_string(t))
      bw = threshold(img, t)
      printImage(bw)
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end
end

Main.main()
