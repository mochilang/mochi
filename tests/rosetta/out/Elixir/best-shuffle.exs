# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:20Z
defmodule Main do
  @spec nextRand(integer()) :: integer()
  def nextRand(seed) do
    try do
      throw({:return, rem(seed * 1_664_525 + 1_013_904_223, 2_147_483_647)})
    catch
      {:return, v} -> v
    end
  end

  @spec shuffleChars(String.t(), integer()) :: list(any())
  def shuffleChars(s, seed) do
    try do
      chars = []
      _ = chars
      i = 0
      _ = i

      t1 = fn t1, chars, i ->
        try do
          if i < length(s) do
            chars = chars ++ [_slice_string(s, i, i + 1)]
            i = i + 1
            t1.(t1, chars, i)
          else
            {:ok, chars, i}
          end
        catch
          :break ->
            {:ok, chars, i}
        end
      end

      {_, chars, i} = t1.(t1, chars, i)
      _ = chars
      _ = i
      sd = seed
      _ = sd
      idx = length(chars) - 1
      _ = idx

      t2 = fn t2, chars, idx, sd ->
        try do
          if idx > 0 do
            sd = nextRand(sd)
            j = rem(sd, idx + 1)
            _ = j
            tmp = Enum.at(chars, idx)
            chars = Map.put(chars, idx, Enum.at(chars, j))
            chars = Map.put(chars, j, tmp)
            idx = idx - 1
            t2.(t2, chars, idx, sd)
          else
            {:ok, chars, idx, sd}
          end
        catch
          :break ->
            {:ok, chars, idx, sd}
        end
      end

      {_, chars, idx, sd} = t2.(t2, chars, idx, sd)
      _ = chars
      _ = idx
      _ = sd
      res = ""
      _ = res
      i = 0

      t3 = fn t3, i, res ->
        try do
          if i < length(chars) do
            res = res + Enum.at(chars, i)
            i = i + 1
            t3.(t3, i, res)
          else
            {:ok, i, res}
          end
        catch
          :break ->
            {:ok, i, res}
        end
      end

      {_, i, res} = t3.(t3, i, res)
      _ = i
      _ = res
      throw({:return, [res, sd]})
    catch
      {:return, v} -> v
    end
  end

  @spec bestShuffle(String.t(), integer()) :: list(any())
  def bestShuffle(s, seed) do
    try do
      r = shuffleChars(s, seed)
      t = Enum.at(r, 0)
      _ = t
      sd = Enum.at(r, 1)
      _ = sd
      arr = []
      _ = arr
      i = 0
      _ = i

      t4 = fn t4, arr, i ->
        try do
          if i < length(t) do
            arr = arr ++ [_slice_string(t, i, i + 1)]
            i = i + 1
            t4.(t4, arr, i)
          else
            {:ok, arr, i}
          end
        catch
          :break ->
            {:ok, arr, i}
        end
      end

      {_, arr, i} = t4.(t4, arr, i)
      _ = arr
      _ = i
      i = 0

      t5 = fn t5, arr, i ->
        try do
          if i < length(arr) do
            j = 0
            _ = j

            t6 = fn t6, arr, j ->
              try do
                if j < length(arr) do
                  if i != j && Enum.at(arr, i) != _slice_string(s, j, j + 1) &&
                       Enum.at(arr, j) != _slice_string(s, i, i + 1) do
                    tmp = Enum.at(arr, i)
                    arr = Map.put(arr, i, Enum.at(arr, j))
                    arr = Map.put(arr, j, tmp)
                    throw(:break)
                  end

                  j = j + 1
                  t6.(t6, arr, j)
                else
                  {:ok, arr, j}
                end
              catch
                :break ->
                  {:ok, arr, j}
              end
            end

            {_, arr, j} = t6.(t6, arr, j)
            _ = arr
            _ = j
            i = i + 1
            t5.(t5, arr, i)
          else
            {:ok, arr, i}
          end
        catch
          :break ->
            {:ok, arr, i}
        end
      end

      {_, arr, i} = t5.(t5, arr, i)
      _ = arr
      _ = i
      # count :: (any() -> integer())
      count = 0
      _ = count
      i = 0

      t7 = fn t7, count, i ->
        try do
          if i < length(arr) do
            if Enum.at(arr, i) == _slice_string(s, i, i + 1) do
              count = count + 1
            end

            i = i + 1
            t7.(t7, count, i)
          else
            {:ok, count, i}
          end
        catch
          :break ->
            {:ok, count, i}
        end
      end

      {_, count, i} = t7.(t7, count, i)
      _ = count
      _ = i
      out = ""
      _ = out
      i = 0

      t8 = fn t8, i, out ->
        try do
          if i < length(arr) do
            out = out + Enum.at(arr, i)
            i = i + 1
            t8.(t8, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t8.(t8, i, out)
      _ = i
      _ = out
      throw({:return, [out, sd, count]})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      ts = ["abracadabra", "seesaw", "elk", "grrrrrr", "up", "a"]
      seed = 1
      _ = seed
      i = 0
      _ = i

      t9 = fn t9, i, seed ->
        try do
          if i < length(ts) do
            r = bestShuffle(Enum.at(ts, i), seed)
            shuf = Enum.at(r, 0)
            seed = Enum.at(r, 1)
            cnt = Enum.at(r, 2)
            IO.inspect(((((Enum.at(ts, i) <> " -> ") <> shuf) <> " (") <> to_string(cnt)) <> ")")
            i = i + 1
            t9.(t9, i, seed)
          else
            {:ok, i, seed}
          end
        catch
          :break ->
            {:ok, i, seed}
        end
      end

      {_, i, seed} = t9.(t9, i, seed)
      _ = i
      _ = seed
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
