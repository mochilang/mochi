# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:45:50Z
defmodule Main do
  @spec absf(float()) :: float()
  def absf(x) do
    try do
      if x < 0 do
        throw({:return, -x})
      end

      throw({:return, x})
    catch
      {:return, v} -> v
    end
  end

  @spec floorf(float()) :: float()
  def floorf(x) do
    try do
      throw({:return, String.to_float(String.to_integer(x))})
    catch
      {:return, v} -> v
    end
  end

  @spec indexOf(String.t(), String.t()) :: integer()
  def indexOf(s, ch) do
    try do
      i = 0
      _ = i

      t1 = fn t1, i ->
        try do
          if i < length(s) do
            if _slice_string(s, i, i + 1) == ch do
              throw({:return, i})
            end

            i = i + 1
            t1.(t1, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t1.(t1, i)
      _ = i
      throw({:return, -1})
    catch
      {:return, v} -> v
    end
  end

  @spec fmtF(float()) :: String.t()
  def fmtF(x) do
    try do
      y = floorf(x * 10000 + 0.5) / 10000
      _ = y
      s = to_string(y)
      _ = s
      dot = indexOf(s, ".")
      _ = dot

      if dot == 0 - 1 do
        s = s <> ".0000"
      else
        decs = length(s) - dot - 1
        _ = decs

        if decs > 4 do
          s = _slice_string(s, 0, dot + 5)
        else
          t2 = fn t2, decs, s ->
            try do
              if decs < 4 do
                s = s <> "0"
                decs = decs + 1
                t2.(t2, decs, s)
              else
                {:ok, decs, s}
              end
            catch
              :break ->
                {:ok, decs, s}
            end
          end

          {_, decs, s} = t2.(t2, decs, s)
          _ = decs
          _ = s
        end
      end

      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec padInt(integer(), integer()) :: String.t()
  def padInt(n, width) do
    try do
      s = to_string(n)
      _ = s

      t3 = fn t3, s ->
        try do
          if length(s) < width do
            s = " " <> s
            t3.(t3, s)
          else
            {:ok, s}
          end
        catch
          :break ->
            {:ok, s}
        end
      end

      {_, s} = t3.(t3, s)
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec padFloat(float(), integer()) :: String.t()
  def padFloat(x, width) do
    try do
      s = fmtF(x)
      _ = s

      t4 = fn t4, s ->
        try do
          if length(s) < width do
            s = " " <> s
            t4.(t4, s)
          else
            {:ok, s}
          end
        catch
          :break ->
            {:ok, s}
        end
      end

      {_, s} = t4.(t4, s)
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec avgLen(integer()) :: float()
  def avgLen(n) do
    try do
      tests = 10000
      # sum :: (any() -> float())
      sum = 0
      _ = sum
      seed = 1
      _ = seed
      t = 0
      _ = t

      t5 = fn t5, seed, sum, t ->
        try do
          if t < tests do
            visited = []
            _ = visited
            i = 0
            _ = i

            t6 = fn t6, i, visited ->
              try do
                if i < n do
                  visited = visited ++ [false]
                  i = i + 1
                  t6.(t6, i, visited)
                else
                  {:ok, i, visited}
                end
              catch
                :break ->
                  {:ok, i, visited}
              end
            end

            {_, i, visited} = t6.(t6, i, visited)
            _ = i
            _ = visited
            x = 0
            _ = x

            t7 = fn t7, seed, sum, visited, x ->
              try do
                if !Enum.at(visited, x) do
                  visited = Map.put(visited, x, true)
                  sum = sum + 1
                  seed = rem(seed * 1_664_525 + 1_013_904_223, 2_147_483_647)
                  x = rem(seed, n)
                  t7.(t7, seed, sum, visited, x)
                else
                  {:ok, seed, sum, visited, x}
                end
              catch
                :break ->
                  {:ok, seed, sum, visited, x}
              end
            end

            {_, seed, sum, visited, x} = t7.(t7, seed, sum, visited, x)
            _ = seed
            _ = sum
            _ = visited
            _ = x
            t = t + 1
            t5.(t5, seed, sum, t)
          else
            {:ok, seed, sum, t}
          end
        catch
          :break ->
            {:ok, seed, sum, t}
        end
      end

      {_, seed, sum, t} = t5.(t5, seed, sum, t)
      _ = seed
      _ = sum
      _ = t
      throw({:return, String.to_float(sum) / tests})
    catch
      {:return, v} -> v
    end
  end

  @spec ana(integer()) :: float()
  def ana(n) do
    try do
      nn = String.to_float(n)
      _ = nn
      term = 1
      _ = term
      # sum :: (any() -> float())
      sum = 1
      _ = sum
      i = nn - 1
      _ = i

      t8 = fn t8, i, sum, term ->
        try do
          if i >= 1 do
            term = term * (i / nn)
            sum = sum + term
            i = i - 1
            t8.(t8, i, sum, term)
          else
            {:ok, i, sum, term}
          end
        catch
          :break ->
            {:ok, i, sum, term}
        end
      end

      {_, i, sum, term} = t8.(t8, i, sum, term)
      _ = i
      _ = sum
      _ = term
      throw({:return, sum})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      nmax = 20
      IO.puts(" N    average    analytical    (error)")
      IO.puts("===  =========  ============  =========")
      n = 1
      _ = n

      t9 = fn t9, n ->
        try do
          if n <= nmax do
            a = avgLen(n)
            b = ana(n)
            err = absf(a - b) / b * 100

            line =
              ((((((padInt(n, 3) <> "  ") <> padFloat(a, 9)) <> "  ") <> padFloat(b, 12)) <> "  (") <>
                 padFloat(err, 6)) <> "%)"

            _ = line
            IO.inspect(line)
            n = n + 1
            t9.(t9, n)
          else
            {:ok, n}
          end
        catch
          :break ->
            {:ok, n}
        end
      end

      {_, n} = t9.(t9, n)
      _ = n
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
