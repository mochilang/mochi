# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:45:05Z
defmodule Complex do
  @type t :: %__MODULE__{re: float(), im: float()}
  defstruct re: nil, im: nil
end

defmodule Main do
  @a %Complex{re: 1, im: 1}
  @b %Complex{re: 3.14159, im: 1.25}
  @spec add(Complex, Complex) :: Complex
  def add(a, b) do
    try do
      throw({:return, %Complex{re: @a.re + @b.re, im: @a.im + @b.im}})
    catch
      {:return, v} -> v
    end
  end

  @spec mul(Complex, Complex) :: Complex
  def mul(a, b) do
    try do
      throw(
        {:return, %Complex{re: @a.re * @b.re - @a.im * @b.im, im: @a.re * @b.im + @a.im * @b.re}}
      )
    catch
      {:return, v} -> v
    end
  end

  @spec neg(Complex) :: Complex
  def neg(a) do
    try do
      throw({:return, %Complex{re: -@a.re, im: -@a.im}})
    catch
      {:return, v} -> v
    end
  end

  @spec inv(Complex) :: Complex
  def inv(a) do
    try do
      # denom :: (any() -> any())
      denom = @a.re * @a.re + @a.im * @a.im
      throw({:return, %Complex{re: @a.re / denom, im: -@a.im / denom}})
    catch
      {:return, v} -> v
    end
  end

  @spec conj(Complex) :: Complex
  def conj(a) do
    try do
      throw({:return, %Complex{re: @a.re, im: -@a.im}})
    catch
      {:return, v} -> v
    end
  end

  @spec cstr(Complex) :: String.t()
  def cstr(a) do
    try do
      s = "(" <> to_string(@a.re)
      _ = s

      if @a.im >= 0 do
        s = ((s <> "+") <> to_string(@a.im)) <> "i)"
      else
        s = (s + to_string(@a.im)) <> "i)"
      end

      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  def main do
    IO.puts("a:       " <> cstr(@a))
    IO.puts("b:       " <> cstr(@b))
    IO.puts("a + b:   " <> cstr(add(@a, @b)))
    IO.puts("a * b:   " <> cstr(mul(@a, @b)))
    IO.puts("-a:      " <> cstr(neg(@a)))
    IO.puts("1 / a:   " <> cstr(inv(@a)))
    IO.puts("aÌ…:       " <> cstr(conj(@a)))
  end
end

Main.main()
