# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:12Z
defmodule Main do
  @spec trimLeftZeros(String.t()) :: String.t()
  def trimLeftZeros(s) do
    try do
      i = 0
      _ = i

      t1 = fn t1, i ->
        try do
          if i < length(s) && _slice_string(s, i, i + 1) == "0" do
            i = i + 1
            t1.(t1, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t1.(t1, i)
      _ = i
      throw({:return, _slice_string(s, i, length(s))})
    catch
      {:return, v} -> v
    end
  end

  @spec btString(String.t()) :: map()
  def btString(s) do
    try do
      s = trimLeftZeros(s)
      b = []
      _ = b
      i = length(s) - 1
      _ = i

      t2 = fn t2, b, i ->
        try do
          if i >= 0 do
            ch = _slice_string(s, i, i + 1)

            if ch == "+" do
              b = b ++ [1]
            else
              if ch == "0" do
                b = b ++ [0]
              else
                if ch == "-" do
                  b = b ++ [0 - 1]
                else
                  throw({:return, %{"bt" => [], "ok" => false}})
                end
              end
            end

            i = i - 1
            t2.(t2, b, i)
          else
            {:ok, b, i}
          end
        catch
          :break ->
            {:ok, b, i}
        end
      end

      {_, b, i} = t2.(t2, b, i)
      _ = b
      _ = i
      throw({:return, %{"bt" => b, "ok" => true}})
    catch
      {:return, v} -> v
    end
  end

  @spec btToString(list(integer())) :: String.t()
  def btToString(b) do
    try do
      if length(b) == 0 do
        throw({:return, "0"})
      end

      r = ""
      _ = r
      i = length(b) - 1
      _ = i

      t3 = fn t3, i, r ->
        try do
          if i >= 0 do
            d = Enum.at(b, i)

            if d == 0 - 1 do
              r = r <> "-"
            else
              if d == 0 do
                r = r <> "0"
              else
                r = r <> "+"
              end
            end

            i = i - 1
            t3.(t3, i, r)
          else
            {:ok, i, r}
          end
        catch
          :break ->
            {:ok, i, r}
        end
      end

      {_, i, r} = t3.(t3, i, r)
      _ = i
      _ = r
      throw({:return, r})
    catch
      {:return, v} -> v
    end
  end

  @spec btInt(integer()) :: list(integer())
  def btInt(i) do
    try do
      if i == 0 do
        throw({:return, []})
      end

      n = i
      _ = n
      b = []
      _ = b

      t4 = fn t4, b, n ->
        try do
          if n != 0 do
            m = rem(n, 3)
            _ = m
            n = String.to_integer(n / 3)

            if m == 2 do
              m = 0 - 1
              n = n + 1
            else
              if m == 0 - 2 do
                m = 1
                n = n - 1
              end
            end

            b = b ++ [m]
            t4.(t4, b, n)
          else
            {:ok, b, n}
          end
        catch
          :break ->
            {:ok, b, n}
        end
      end

      {_, b, n} = t4.(t4, b, n)
      _ = b
      _ = n
      throw({:return, b})
    catch
      {:return, v} -> v
    end
  end

  @spec btToInt(list(integer())) :: integer()
  def btToInt(b) do
    try do
      r = 0
      _ = r
      pt = 1
      _ = pt
      i = 0
      _ = i

      t5 = fn t5, i, pt, r ->
        try do
          if i < length(b) do
            r = r + Enum.at(b, i) * pt
            pt = pt * 3
            i = i + 1
            t5.(t5, i, pt, r)
          else
            {:ok, i, pt, r}
          end
        catch
          :break ->
            {:ok, i, pt, r}
        end
      end

      {_, i, pt, r} = t5.(t5, i, pt, r)
      _ = i
      _ = pt
      _ = r
      throw({:return, r})
    catch
      {:return, v} -> v
    end
  end

  @spec btNeg(list(integer())) :: list(integer())
  def btNeg(b) do
    try do
      r = []
      _ = r
      i = 0
      _ = i

      t6 = fn t6, i, r ->
        try do
          if i < length(b) do
            r = r ++ [-Enum.at(b, i)]
            i = i + 1
            t6.(t6, i, r)
          else
            {:ok, i, r}
          end
        catch
          :break ->
            {:ok, i, r}
        end
      end

      {_, i, r} = t6.(t6, i, r)
      _ = i
      _ = r
      throw({:return, r})
    catch
      {:return, v} -> v
    end
  end

  @spec btAdd(list(integer()), list(integer())) :: list(integer())
  def btAdd(a, b) do
    try do
      throw({:return, btInt(btToInt(a) + btToInt(b))})
    catch
      {:return, v} -> v
    end
  end

  @spec btMul(list(integer()), list(integer())) :: list(integer())
  def btMul(a, b) do
    try do
      throw({:return, btInt(btToInt(a) * btToInt(b))})
    catch
      {:return, v} -> v
    end
  end

  @spec padLeft(String.t(), integer()) :: String.t()
  def padLeft(s, w) do
    try do
      r = s
      _ = r

      t7 = fn t7, r ->
        try do
          if length(r) < w do
            r = " " <> r
            t7.(t7, r)
          else
            {:ok, r}
          end
        catch
          :break ->
            {:ok, r}
        end
      end

      {_, r} = t7.(t7, r)
      _ = r
      throw({:return, r})
    catch
      {:return, v} -> v
    end
  end

  @spec show(String.t(), list(integer())) :: nil
  def show(label, b) do
    try do
      l = padLeft(label, 7)
      bs = padLeft(btToString(b), 12)
      is = padLeft(to_string(btToInt(b)), 7)
      IO.inspect((((l <> " ") <> bs) <> " ") <> is)
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      ares = btString("+-0++0+")
      a = Enum.at(ares, "bt")
      b = btInt(-436)
      cres = btString("+-++-")
      c = Enum.at(cres, "bt")
      show("a:", a)
      show("b:", b)
      show("c:", c)
      show("a(b-c):", btMul(a, btAdd(b, btNeg(c))))
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
