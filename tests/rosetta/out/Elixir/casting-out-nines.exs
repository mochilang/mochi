# Generated by Mochi compiler v0.10.26 on 2025-07-16T14:09:08Z
defmodule Main do
  @testCases [
    %{"base" => 10, "begin" => "1", "end" => "100", "kaprekar" => ["1", "9", "45", "55", "99"]},
    %{"base" => 17, "begin" => "10", "end" => "gg", "kaprekar" => ["3d", "d4", "gg"]}
  ]
  @spec parseIntBase(String.t(), integer()) :: integer()
  def parseIntBase(s, base) do
    try do
      digits = "0123456789abcdefghijklmnopqrstuvwxyz"
      n = 0
      _ = n
      i = 0
      _ = i

      t1 = fn t1, i, n ->
        try do
          if i < length(s) do
            j = 0
            _ = j
            v = 0
            _ = v

            t2 = fn t2, j, v ->
              try do
                if j < length(digits) do
                  if _slice_string(digits, j, j + 1) == Enum.slice(s, i, i + 1 - i) do
                    v = j
                    throw(:break)
                  end

                  j = j + 1
                  t2.(t2, j, v)
                else
                  {:ok, j, v}
                end
              catch
                :break ->
                  {:ok, j, v}
              end
            end

            {_, j, v} = t2.(t2, j, v)
            _ = j
            _ = v
            n = n * base + v
            i = i + 1
            t1.(t1, i, n)
          else
            {:ok, i, n}
          end
        catch
          :break ->
            {:ok, i, n}
        end
      end

      {_, i, n} = t1.(t1, i, n)
      _ = i
      _ = n
      throw({:return, n})
    catch
      {:return, v} -> v
    end
  end

  @spec intToBase(integer(), integer()) :: String.t()
  def intToBase(n, base) do
    try do
      digits = "0123456789abcdefghijklmnopqrstuvwxyz"

      if n == 0 do
        throw({:return, "0"})
      end

      out = ""
      _ = out
      v = n
      _ = v

      t3 = fn t3, out, v ->
        try do
          if v > 0 do
            d = rem(v, base)
            out = Enum.slice(digits, d, d + 1 - d) + out
            v = v / base
            t3.(t3, out, v)
          else
            {:ok, out, v}
          end
        catch
          :break ->
            {:ok, out, v}
        end
      end

      {_, out, v} = t3.(t3, out, v)
      _ = out
      _ = v
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec subset(integer(), String.t(), String.t()) :: list(String.t())
  def subset(base, begin, end_) do
    try do
      b = parseIntBase(begin, base)
      _ = b
      e = parseIntBase(end_, base)
      _ = e
      out = []
      _ = out
      k = b
      _ = k

      t4 = fn t4, k, out ->
        try do
          if k <= e do
            ks = intToBase(k, base)
            mod = base - 1
            r1 = rem(parseIntBase(ks, base), mod)
            r2 = rem(parseIntBase(ks, base) * parseIntBase(ks, base), mod)

            if r1 == r2 do
              out = out ++ [ks]
            end

            k = k + 1
            t4.(t4, k, out)
          else
            {:ok, k, out}
          end
        catch
          :break ->
            {:ok, k, out}
        end
      end

      {_, k, out} = t4.(t4, k, out)
      _ = k
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  def main do
    # idx :: integer()
    idx = 0
    _ = idx

    t5 = fn t5, idx ->
      try do
        if idx < length(@testCases) do
          tc = Enum.at(@testCases, idx)

          IO.inspect(
            ((((("\nTest case base = " <> to_string(Enum.at(tc, "base"))) <> ", begin = ") <>
                 Enum.at(tc, "begin")) <> ", end = ") <> Enum.at(tc, "end")) <> ":"
          )

          s = subset(Enum.at(tc, "base"), Enum.at(tc, "begin"), Enum.at(tc, "end"))
          IO.puts("Subset:  " <> to_string(s))
          IO.puts("Kaprekar:" <> to_string(Enum.at(tc, "kaprekar")))
          sx = 0
          _ = sx
          valid = true
          _ = valid
          i = 0
          _ = i

          t6 = fn t6, i, sx, valid ->
            try do
              if i < length(Enum.at(tc, "kaprekar")) do
                k = Enum.at(Enum.at(tc, "kaprekar"), i)
                found = false
                _ = found

                t7 = fn t7, found, sx ->
                  try do
                    if sx < length(s) do
                      if Enum.at(s, sx) == k do
                        found = true
                        sx = sx + 1
                        throw(:break)
                      end

                      sx = sx + 1
                      t7.(t7, found, sx)
                    else
                      {:ok, found, sx}
                    end
                  catch
                    :break ->
                      {:ok, found, sx}
                  end
                end

                {_, found, sx} = t7.(t7, found, sx)
                _ = found
                _ = sx

                if !found do
                  IO.inspect(("Fail:" <> k) <> " not in subset")
                  valid = false
                  throw(:break)
                end

                i = i + 1
                t6.(t6, i, sx, valid)
              else
                {:ok, i, sx, valid}
              end
            catch
              :break ->
                {:ok, i, sx, valid}
            end
          end

          {_, i, sx, valid} = t6.(t6, i, sx, valid)
          _ = i
          _ = sx
          _ = valid

          if valid do
            IO.puts("Valid subset.")
          end

          idx = idx + 1
          t5.(t5, idx)
        else
          {:ok, idx}
        end
      catch
        :break ->
          {:ok, idx}
      end
    end

    {_, idx} = t5.(t5, idx)
    _ = idx
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
