# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:54Z
defmodule Main do
  @spec isPrime(integer()) :: boolean()
  def isPrime(n) do
    try do
      if n < 2 do
        throw({:return, false})
      end

      if rem(n, 2) == 0 do
        throw({:return, n == 2})
      end

      if rem(n, 3) == 0 do
        throw({:return, n == 3})
      end

      d = 5
      _ = d

      t1 = fn t1, d ->
        try do
          if d * d <= n do
            if rem(n, d) == 0 do
              throw({:return, false})
            end

            d = d + 2

            if rem(n, d) == 0 do
              throw({:return, false})
            end

            d = d + 4
            t1.(t1, d)
          else
            {:ok, d}
          end
        catch
          :break ->
            {:ok, d}
        end
      end

      {_, d} = t1.(t1, d)
      _ = d
      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec firstPrimeFactor(integer()) :: integer()
  def firstPrimeFactor(n) do
    try do
      if n == 1 do
        throw({:return, 1})
      end

      if rem(n, 3) == 0 do
        throw({:return, 3})
      end

      if rem(n, 5) == 0 do
        throw({:return, 5})
      end

      inc = [4, 2, 4, 2, 4, 6, 2, 6]
      _ = inc
      k = 7
      _ = k
      i = 0
      _ = i

      t2 = fn t2, i, k ->
        try do
          if k * k <= n do
            if rem(n, k) == 0 do
              throw({:return, k})
            end

            k = k + Enum.at(inc, i)
            i = rem(i + 1, length(inc))
            t2.(t2, i, k)
          else
            {:ok, i, k}
          end
        catch
          :break ->
            {:ok, i, k}
        end
      end

      {_, i, k} = t2.(t2, i, k)
      _ = i
      _ = k
      throw({:return, n})
    catch
      {:return, v} -> v
    end
  end

  @spec indexOf(String.t(), String.t()) :: integer()
  def indexOf(s, ch) do
    try do
      i = 0
      _ = i

      t3 = fn t3, i ->
        try do
          if i < length(s) do
            if _slice_string(s, i, i + 1) == ch do
              throw({:return, i})
            end

            i = i + 1
            t3.(t3, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t3.(t3, i)
      _ = i
      throw({:return, -1})
    catch
      {:return, v} -> v
    end
  end

  @spec padLeft(integer(), integer()) :: String.t()
  def padLeft(n, width) do
    try do
      s = to_string(n)
      _ = s

      t4 = fn t4, s ->
        try do
          if length(s) < width do
            s = " " <> s
            t4.(t4, s)
          else
            {:ok, s}
          end
        catch
          :break ->
            {:ok, s}
        end
      end

      {_, s} = t4.(t4, s)
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec formatFloat(float(), integer()) :: String.t()
  def formatFloat(f, prec) do
    try do
      s = to_string(f)
      idx = indexOf(s, ".")

      if idx < 0 do
        throw({:return, s})
      end

      need = idx + 1 + prec

      if length(s) > need do
        throw({:return, _slice_string(s, 0, need)})
      end

      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      blum = []
      _ = blum
      counts = [0, 0, 0, 0]
      _ = counts
      digits = [1, 3, 7, 9]
      _ = digits
      i = 1
      _ = i
      bc = 0
      _ = bc

      t5 = fn t5, bc, blum, counts, i ->
        try do
          if true do
            p = firstPrimeFactor(i)

            if rem(p, 4) == 3 do
              q = String.to_integer(i / p)

              if q != p && rem(q, 4) == 3 && isPrime(q) do
                if bc < 50 do
                  blum = blum ++ [i]
                end

                d = rem(i, 10)

                if d == 1 do
                  counts = Map.put(counts, 0, Enum.at(counts, 0) + 1)
                else
                  if d == 3 do
                    counts = Map.put(counts, 1, Enum.at(counts, 1) + 1)
                  else
                    if d == 7 do
                      counts = Map.put(counts, 2, Enum.at(counts, 2) + 1)
                    else
                      if d == 9 do
                        counts = Map.put(counts, 3, Enum.at(counts, 3) + 1)
                      end
                    end
                  end
                end

                bc = bc + 1

                if bc == 50 do
                  IO.puts("First 50 Blum integers:")
                  idx = 0
                  _ = idx

                  t6 = fn t6, idx ->
                    try do
                      if idx < 50 do
                        line = ""
                        _ = line
                        j = 0
                        _ = j

                        t7 = fn t7, idx, j, line ->
                          try do
                            if j < 10 do
                              line = (line + padLeft(Enum.at(blum, idx), 3)) <> " "
                              idx = idx + 1
                              j = j + 1
                              t7.(t7, idx, j, line)
                            else
                              {:ok, idx, j, line}
                            end
                          catch
                            :break ->
                              {:ok, idx, j, line}
                          end
                        end

                        {_, idx, j, line} = t7.(t7, idx, j, line)
                        _ = idx
                        _ = j
                        _ = line
                        IO.puts(_slice_string(line, 0, length(line) - 1))
                        t6.(t6, idx)
                      else
                        {:ok, idx}
                      end
                    catch
                      :break ->
                        {:ok, idx}
                    end
                  end

                  {_, idx} = t6.(t6, idx)
                  _ = idx
                  throw(:break)
                end
              end
            end

            if rem(i, 5) == 3 do
              i = i + 4
            else
              i = i + 2
            end

            t5.(t5, bc, blum, counts, i)
          else
            {:ok, bc, blum, counts, i}
          end
        catch
          :break ->
            {:ok, bc, blum, counts, i}
        end
      end

      {_, bc, blum, counts, i} = t5.(t5, bc, blum, counts, i)
      _ = bc
      _ = blum
      _ = counts
      _ = i
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
