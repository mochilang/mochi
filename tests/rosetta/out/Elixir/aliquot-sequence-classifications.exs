# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:44:20Z
defmodule Main do
	@THRESHOLD 140737488355328
	@spec indexOf(list(integer()), integer()) :: integer()
	def indexOf(xs, value) do
		try do
			i = 0
			_ = i
			t1 = fn t1, i ->
				try do
					if (i < length(xs)) do
						if (Enum.at((xs), i) == value) do
							throw {:return, i}
						end
						i = (i + 1)
						t1.(t1, i)
					else
						{:ok, i}
					end
				catch :break ->
					{:ok, i}
				end
			end
			{_, i} = t1.(t1, i)
			_ = i
			throw {:return, (0 - 1)}
		catch {:return, v} -> v end
	end
	
	@spec contains(list(integer()), integer()) :: boolean()
	def contains(xs, value) do
		try do
			throw {:return, (indexOf(xs, value) != (0 - 1))}
		catch {:return, v} -> v end
	end
	
	@spec maxOf(integer(), integer()) :: integer()
	def maxOf(a, b) do
		try do
			if (a > b) do
				throw {:return, a}
			else
				throw {:return, b}
			end
		catch {:return, v} -> v end
	end
	
	@spec intSqrt(integer()) :: integer()
	def intSqrt(n) do
		try do
			if (n == 0) do
				throw {:return, 0}
			end
			x = n
			_ = x
			y = ((x + 1) / 2)
			_ = y
			t2 = fn t2, x, y ->
				try do
					if (y < x) do
						x = y
						y = ((x + (n / x)) / 2)
						t2.(t2, x, y)
					else
						{:ok, x, y}
					end
				catch :break ->
					{:ok, x, y}
				end
			end
			{_, x, y} = t2.(t2, x, y)
			_ = x
			_ = y
			throw {:return, x}
		catch {:return, v} -> v end
	end
	
	@spec sumProperDivisors(integer()) :: integer()
	def sumProperDivisors(n) do
		try do
			if (n < 2) do
				throw {:return, 0}
			end
			sqrt = intSqrt(n)
			# sum :: (any() -> float())
			sum = 1
			_ = sum
			i = 2
			_ = i
			t3 = fn t3, i, sum ->
				try do
					if (i <= sqrt) do
						if (rem(n, i) == 0) do
							sum = ((sum + i) + (n / i))
						end
						i = (i + 1)
						t3.(t3, i, sum)
					else
						{:ok, i, sum}
					end
				catch :break ->
					{:ok, i, sum}
				end
			end
			{_, i, sum} = t3.(t3, i, sum)
			_ = i
			_ = sum
			if ((sqrt * sqrt) == n) do
				sum = (sum - sqrt)
			end
			throw {:return, sum}
		catch {:return, v} -> v end
	end
	
	@spec classifySequence(integer()) :: map()
	def classifySequence(k) do
		try do
			last = k
			_ = last
			seq = [k]
			_ = seq
			t4 = fn t4, last, seq ->
				try do
					if true do
						last = sumProperDivisors(last)
						seq = seq ++ [last]
						n = length(seq)
						aliquot = ""
						_ = aliquot
						if (last == 0) do
							aliquot = "Terminating"
						else
							if ((n == 2) && (last == k)) do
								aliquot = "Perfect"
							else
								if ((n == 3) && (last == k)) do
									aliquot = "Amicable"
								else
									if ((n >= 4) && (last == k)) do
										aliquot = (("Sociable[" <> to_string((n - 1))) <> "]")
									else
										if (last == Enum.at((seq), (n - 2))) do
											aliquot = "Aspiring"
										else
											if contains(Enum.slice((seq), 1, (maxOf(1, (n - 2))) - 1), last) do
												idx = indexOf(seq, last)
												aliquot = (("Cyclic[" <> to_string(((n - 1) - idx))) <> "]")
											else
												if ((n == 16) || (last > @THRESHOLD)) do
													aliquot = "Non-Terminating"
												end
											end
										end
									end
								end
							end
						end
						if (aliquot != "") do
							throw {:return, %{"seq" => seq, "aliquot" => aliquot}}
						end
						t4.(t4, last, seq)
					else
						{:ok, last, seq}
					end
				catch :break ->
					{:ok, last, seq}
				end
			end
			{_, last, seq} = t4.(t4, last, seq)
			_ = last
			_ = seq
			throw {:return, %{"seq" => seq, "aliquot" => ""}}
		catch {:return, v} -> v end
	end
	
	@spec padLeft(integer(), integer()) :: String.t()
	def padLeft(n, w) do
		try do
			s = to_string(n)
			_ = s
			t5 = fn t5, s ->
				try do
					if (length(s) < w) do
						s = (" " <> s)
						t5.(t5, s)
					else
						{:ok, s}
					end
				catch :break ->
					{:ok, s}
				end
			end
			{_, s} = t5.(t5, s)
			_ = s
			throw {:return, s}
		catch {:return, v} -> v end
	end
	
	@spec padRight(String.t(), integer()) :: String.t()
	def padRight(s, w) do
		try do
			r = s
			_ = r
			t6 = fn t6, r ->
				try do
					if (length(r) < w) do
						r = (r <> " ")
						t6.(t6, r)
					else
						{:ok, r}
					end
				catch :break ->
					{:ok, r}
				end
			end
			{_, r} = t6.(t6, r)
			_ = r
			throw {:return, r}
		catch {:return, v} -> v end
	end
	
	@spec joinWithCommas(list(integer())) :: String.t()
	def joinWithCommas(seq) do
		try do
			s = "["
			_ = s
			i = 0
			_ = i
			t7 = fn t7, i, s ->
				try do
					if (i < length(seq)) do
						s = (s + to_string(Enum.at((seq), i)))
						if (i < (length(seq) - 1)) do
							s = (s <> ", ")
						end
						i = (i + 1)
						t7.(t7, i, s)
					else
						{:ok, i, s}
					end
				catch :break ->
					{:ok, i, s}
				end
			end
			{_, i, s} = t7.(t7, i, s)
			_ = i
			_ = s
			s = (s <> "]")
			throw {:return, s}
		catch {:return, v} -> v end
	end
	
	@spec main() :: nil
	def main() do
		try do
			IO.puts("Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n")
			k = 1
			_ = k
			t8 = fn t8, k ->
				try do
					if (k <= 10) do
						res = classifySequence(k)
						IO.puts(((((padLeft(k, 2) <> ": ") <> padRight(Enum.at((res), "aliquot"), 15)) <> " ") <> joinWithCommas(Enum.at((res), "seq"))))
						k = (k + 1)
						t8.(t8, k)
					else
						{:ok, k}
					end
				catch :break ->
					{:ok, k}
				end
			end
			{_, k} = t8.(t8, k)
			_ = k
			IO.puts("")
			s = [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]
			i = 0
			_ = i
			t9 = fn t9, i ->
				try do
					if (i < length(s)) do
						val = Enum.at((s), i)
						res = classifySequence(val)
						IO.puts(((((padLeft(val, 7) <> ": ") <> padRight(Enum.at((res), "aliquot"), 15)) <> " ") <> joinWithCommas(Enum.at((res), "seq"))))
						i = (i + 1)
						t9.(t9, i)
					else
						{:ok, i}
					end
				catch :break ->
					{:ok, i}
				end
			end
			{_, i} = t9.(t9, i)
			_ = i
			IO.puts("")
			big = 15355717786080
			r = classifySequence(big)
			IO.puts(((((to_string(big) <> ": ") <> padRight(Enum.at((r), "aliquot"), 15)) <> " ") <> joinWithCommas(Enum.at((r), "seq"))))
		catch {:return, v} -> v end
	end
	
	def main do
		main()
	end
	end
Main.main()
