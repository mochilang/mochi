# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:49:36Z
defmodule Main do
  @spec divisors(integer()) :: list(integer())
  def divisors(n) do
    try do
      divs = [1]
      _ = divs
      divs2 = []
      _ = divs2
      i = 2
      _ = i

      t1 = fn t1, divs, divs2, i ->
        try do
          if i * i <= n do
            if rem(n, i) == 0 do
              j = String.to_integer(n / i)
              divs = divs ++ [i]

              if i != j do
                divs2 = divs2 ++ [j]
              end
            end

            i = i + 1
            t1.(t1, divs, divs2, i)
          else
            {:ok, divs, divs2, i}
          end
        catch
          :break ->
            {:ok, divs, divs2, i}
        end
      end

      {_, divs, divs2, i} = t1.(t1, divs, divs2, i)
      _ = divs
      _ = divs2
      _ = i
      j = length(divs2) - 1
      _ = j

      t2 = fn t2, divs, j ->
        try do
          if j >= 0 do
            divs = divs ++ [Enum.at(divs2, j)]
            j = j - 1
            t2.(t2, divs, j)
          else
            {:ok, divs, j}
          end
        catch
          :break ->
            {:ok, divs, j}
        end
      end

      {_, divs, j} = t2.(t2, divs, j)
      _ = divs
      _ = j
      throw({:return, divs})
    catch
      {:return, v} -> v
    end
  end

  @spec sum(list(integer())) :: integer()
  def sum(xs) do
    try do
      tot = 0
      _ = tot

      {tot} =
        Enum.reduce(_iter(xs), {tot}, fn v, {tot} ->
          tot = tot + v
          {tot}
        end)

      _ = tot
      throw({:return, tot})
    catch
      {:return, v} -> v
    end
  end

  @spec sumStr(list(integer())) :: String.t()
  def sumStr(xs) do
    try do
      s = ""
      _ = s
      i = 0
      _ = i

      t3 = fn t3, i, s ->
        try do
          if i < length(xs) do
            s = (s + to_string(Enum.at(xs, i))) <> " + "
            i = i + 1
            t3.(t3, i, s)
          else
            {:ok, i, s}
          end
        catch
          :break ->
            {:ok, i, s}
        end
      end

      {_, i, s} = t3.(t3, i, s)
      _ = i
      _ = s
      throw({:return, _slice_string(s, 0, length(s) - 3)})
    catch
      {:return, v} -> v
    end
  end

  @spec pad2(integer()) :: String.t()
  def pad2(n) do
    try do
      s = to_string(n)

      if length(s) < 2 do
        throw({:return, " " <> s})
      end

      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec pad5(integer()) :: String.t()
  def pad5(n) do
    try do
      s = to_string(n)
      _ = s

      t4 = fn t4, s ->
        try do
          if length(s) < 5 do
            s = " " <> s
            t4.(t4, s)
          else
            {:ok, s}
          end
        catch
          :break ->
            {:ok, s}
        end
      end

      {_, s} = t4.(t4, s)
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec abundantOdd(integer(), integer(), integer(), boolean()) :: integer()
  def abundantOdd(searchFrom, countFrom, countTo, printOne) do
    try do
      # count :: (any() -> integer())
      count = countFrom
      _ = count
      n = searchFrom
      _ = n

      t5 = fn t5, count, n ->
        try do
          if count < countTo do
            divs = divisors(n)
            tot = _sum(divs)

            if tot > n do
              count = count + 1

              if printOne && count < countTo do
                n = n + 2
                throw(:continue)
              end

              s = sumStr(divs)

              if !printOne do
                IO.inspect(
                  (((((pad2(count) <> ". ") <> pad5(n)) <> " < ") <> s) <> " = ") <>
                    to_string(tot)
                )
              else
                IO.inspect((((to_string(n) <> " < ") <> s) <> " = ") <> to_string(tot))
              end
            end

            n = n + 2
            t5.(t5, count, n)
          else
            {:ok, count, n}
          end
        catch
          :break ->
            {:ok, count, n}
        end
      end

      {_, count, n} = t5.(t5, count, n)
      _ = count
      _ = n
      throw({:return, n})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      # max :: (any() -> any())
      max = 25
      IO.puts(("The first " <> to_string(max)) <> " abundant odd numbers are:")
      n = abundantOdd(1, 0, max, false)
      IO.puts("\nThe one thousandth abundant odd number is:")
      abundantOdd(n, max, 1000, true)
      IO.puts("\nThe first abundant odd number above one billion is:")
      abundantOdd(1_000_000_001, 0, 1, true)
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _iter(v) do
    if is_map(v) do
      Map.keys(v)
    else
      v
    end
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end

  defp _sum(v) do
    list =
      cond do
        is_map(v) and Map.has_key?(v, :items) -> Map.get(v, :items)
        is_list(v) -> v
        true -> raise "sum() expects list or group"
      end

    Enum.sum(list)
  end
end

Main.main()
