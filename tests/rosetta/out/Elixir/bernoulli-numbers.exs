# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:18Z
defmodule Main do
  @spec bernoulli(integer()) :: any()
  def bernoulli(n) do
    try do
      a = []
      _ = a
      m = 0
      _ = m

      t1 = fn t1, a, m ->
        try do
          if m <= n do
            a = a ++ [1 / (m + 1)]
            j = m
            _ = j

            t2 = fn t2, a, j ->
              try do
                if j >= 1 do
                  a = Map.put(a, j - 1, j * (Enum.at(a, j - 1) - Enum.at(a, j)))
                  j = j - 1
                  t2.(t2, a, j)
                else
                  {:ok, a, j}
                end
              catch
                :break ->
                  {:ok, a, j}
              end
            end

            {_, a, j} = t2.(t2, a, j)
            _ = a
            _ = j
            m = m + 1
            t1.(t1, a, m)
          else
            {:ok, a, m}
          end
        catch
          :break ->
            {:ok, a, m}
        end
      end

      {_, a, m} = t1.(t1, a, m)
      _ = a
      _ = m
      throw({:return, Enum.at(a, 0)})
    catch
      {:return, v} -> v
    end
  end

  def main do
    for i <- 0..(61 - 1) do
      b = bernoulli(i)

      if num.(b) != 0 do
        numStr = to_string(num.(b))
        denStr = to_string(denom.(b))

        IO.inspect(
          (((("B(" <> to_string(i)(2, " ")) <> ") =") <> numStr.padStart(45, " ")) <> "/") <>
            denStr
        )
      end
    end
  end
end

Main.main()
