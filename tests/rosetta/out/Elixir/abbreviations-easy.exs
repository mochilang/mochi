# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:49:22Z
defmodule Main do
  @spec fields(String.t()) :: list(String.t())
  def fields(s) do
    try do
      words = []
      _ = words
      cur = ""
      _ = cur
      i = 0
      _ = i

      t1 = fn t1, cur, i, words ->
        try do
          if i < length(s) do
            ch = _slice_string(s, i, i + 1)

            if ch == " " || ch == "\n" || ch == "\t" do
              if length(cur) > 0 do
                words = words ++ [cur]
                cur = ""
              end
            else
              cur = cur + ch
            end

            i = i + 1
            t1.(t1, cur, i, words)
          else
            {:ok, cur, i, words}
          end
        catch
          :break ->
            {:ok, cur, i, words}
        end
      end

      {_, cur, i, words} = t1.(t1, cur, i, words)
      _ = cur
      _ = i
      _ = words

      if length(cur) > 0 do
        words = words ++ [cur]
      end

      throw({:return, words})
    catch
      {:return, v} -> v
    end
  end

  @spec padRight(String.t(), integer()) :: String.t()
  def padRight(s, width) do
    try do
      out = s
      _ = out
      i = length(s)
      _ = i

      t2 = fn t2, i, out ->
        try do
          if i < width do
            out = out <> " "
            i = i + 1
            t2.(t2, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t2.(t2, i, out)
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec join(list(String.t()), String.t()) :: String.t()
  def join(xs, sep) do
    try do
      res = ""
      _ = res
      i = 0
      _ = i

      t3 = fn t3, i, res ->
        try do
          if i < length(xs) do
            if i > 0 do
              res = res + sep
            end

            res = res + Enum.at(xs, i)
            i = i + 1
            t3.(t3, i, res)
          else
            {:ok, i, res}
          end
        catch
          :break ->
            {:ok, i, res}
        end
      end

      {_, i, res} = t3.(t3, i, res)
      _ = i
      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec validate(list(String.t()), list(String.t()), list(integer())) :: list(String.t())
  def validate(commands, words, mins) do
    try do
      results = []
      _ = results

      if length(words) == 0 do
        throw({:return, results})
      end

      wi = 0
      _ = wi

      t4 = fn t4, results, wi ->
        try do
          if wi < length(words) do
            w = Enum.at(words, wi)
            found = false
            _ = found
            wlen = length(w)
            ci = 0
            _ = ci

            t5 = fn t5, ci, found, results ->
              try do
                if ci < length(commands) do
                  cmd = Enum.at(commands, ci)

                  if Enum.at(mins, ci) != 0 && wlen >= Enum.at(mins, ci) && wlen <= length(cmd) do
                    c = upper.(cmd)
                    ww = upper.(w)

                    if _slice_string(c, 0, wlen) == ww do
                      results = results ++ [c]
                      found = true
                      throw(:break)
                    end
                  end

                  ci = ci + 1
                  t5.(t5, ci, found, results)
                else
                  {:ok, ci, found, results}
                end
              catch
                :break ->
                  {:ok, ci, found, results}
              end
            end

            {_, ci, found, results} = t5.(t5, ci, found, results)
            _ = ci
            _ = found
            _ = results

            if !found do
              results = results ++ ["*error*"]
            end

            wi = wi + 1
            t4.(t4, results, wi)
          else
            {:ok, results, wi}
          end
        catch
          :break ->
            {:ok, results, wi}
        end
      end

      {_, results, wi} = t4.(t4, results, wi)
      _ = results
      _ = wi
      throw({:return, results})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      table =
        ((((("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " <>
               "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ") <>
              "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ") <>
             " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ") <>
            "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ") <>
           "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ") <>
          "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "

      commands = fields(table)
      mins = []
      _ = mins
      i = 0
      _ = i

      t6 = fn t6, i, mins ->
        try do
          if i < length(commands) do
            # count :: (any() -> integer())
            count = 0
            _ = count
            j = 0
            _ = j
            cmd = Enum.at(commands, i)

            t7 = fn t7, count, j ->
              try do
                if j < length(cmd) do
                  ch = _slice_string(cmd, j, j + 1)

                  if ch >= "A" && ch <= "Z" do
                    count = count + 1
                  end

                  j = j + 1
                  t7.(t7, count, j)
                else
                  {:ok, count, j}
                end
              catch
                :break ->
                  {:ok, count, j}
              end
            end

            {_, count, j} = t7.(t7, count, j)
            _ = count
            _ = j
            mins = mins ++ [count]
            i = i + 1
            t6.(t6, i, mins)
          else
            {:ok, i, mins}
          end
        catch
          :break ->
            {:ok, i, mins}
        end
      end

      {_, i, mins} = t6.(t6, i, mins)
      _ = i
      _ = mins
      sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"
      words = fields(sentence)
      results = validate(commands, words, mins)
      out1 = "user words:  "
      _ = out1
      k = 0
      _ = k

      t8 = fn t8, k, out1 ->
        try do
          if k < length(words) do
            out1 = (out1 + padRight(Enum.at(words, k), length(Enum.at(results, k)))) <> " "
            k = k + 1
            t8.(t8, k, out1)
          else
            {:ok, k, out1}
          end
        catch
          :break ->
            {:ok, k, out1}
        end
      end

      {_, k, out1} = t8.(t8, k, out1)
      _ = k
      _ = out1
      IO.inspect(out1)
      IO.puts("full words:  " <> join(results, " "))
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
