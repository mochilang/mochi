# Generated by Mochi compiler v0.10.30 on 2025-07-19T01:02:34Z
defmodule Main do
  @spec fields(String.t()) :: list(String.t())
  def fields(s) do
    try do
      # words :: list(String.t())
      words = []
      _ = words
      # cur :: String.t()
      cur = ""
      _ = cur
      # i :: integer()
      i = 0
      _ = i

      t1 = fn t1, cur, i, words ->
        try do
          if i < String.length(s) do
            ch = String.slice(s, i, i + 1 - i)

            if ch == " " || ch == "\n" || ch == "\t" do
              if String.length(cur) > 0 do
                words = words ++ [cur]
                cur = ""
              end
            else
              cur = cur <> ch
            end

            i = i + 1
            t1.(t1, cur, i, words)
          else
            {:ok, cur, i, words}
          end
        catch
          :break ->
            {:ok, cur, i, words}
        end
      end

      {_, cur, i, words} = t1.(t1, cur, i, words)
      _ = cur
      _ = i
      _ = words

      if String.length(cur) > 0 do
        words = words ++ [cur]
      end

      throw({:return, words})
    catch
      {:return, v} -> v
    end
  end

  @spec padRight(String.t(), integer()) :: String.t()
  def padRight(s, width) do
    try do
      # out :: String.t()
      out = s
      _ = out
      # i :: integer()
      i = String.length(s)
      _ = i

      t2 = fn t2, i, out ->
        try do
          if i < width do
            out = out <> " "
            i = i + 1
            t2.(t2, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t2.(t2, i, out)
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec join(list(String.t()), String.t()) :: String.t()
  def join(xs, sep) do
    try do
      # res :: String.t()
      res = ""
      _ = res
      # i :: integer()
      i = 0
      _ = i

      t3 = fn t3, i, res ->
        try do
          if i < length(xs) do
            if i > 0 do
              res = res <> sep
            end

            res = res <> Enum.at(xs, i)
            i = i + 1
            t3.(t3, i, res)
          else
            {:ok, i, res}
          end
        catch
          :break ->
            {:ok, i, res}
        end
      end

      {_, i, res} = t3.(t3, i, res)
      _ = i
      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec validate(list(String.t()), list(String.t()), list(integer())) :: list(String.t())
  def validate(commands, words, mins) do
    try do
      # results :: list(String.t())
      results = []
      _ = results

      if length(words) == 0 do
        throw({:return, results})
      end

      # wi :: integer()
      wi = 0
      _ = wi

      t4 = fn t4, results, wi ->
        try do
          if wi < length(words) do
            w = Enum.at(words, wi)
            # found :: boolean()
            found = false
            _ = found
            wlen = _length(w)
            # ci :: integer()
            ci = 0
            _ = ci

            t5 = fn t5, ci, found, results ->
              try do
                if ci < length(commands) do
                  cmd = Enum.at(commands, ci)

                  if Enum.at(mins, ci) != 0 && wlen >= Enum.at(mins, ci) && wlen <= _length(cmd) do
                    c = upper.(cmd)
                    ww = upper.(w)

                    if String.slice(c, 0, wlen - 0) == ww do
                      results = results ++ [c]
                      found = true
                      throw(:break)
                    end
                  end

                  ci = ci + 1
                  t5.(t5, ci, found, results)
                else
                  {:ok, ci, found, results}
                end
              catch
                :break ->
                  {:ok, ci, found, results}
              end
            end

            {_, ci, found, results} = t5.(t5, ci, found, results)
            _ = ci
            _ = found
            _ = results

            if !found do
              results = results ++ ["*error*"]
            end

            wi = wi + 1
            t4.(t4, results, wi)
          else
            {:ok, results, wi}
          end
        catch
          :break ->
            {:ok, results, wi}
        end
      end

      {_, results, wi} = t4.(t4, results, wi)
      _ = results
      _ = wi
      throw({:return, results})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      table =
        ((((("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " <>
               "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ") <>
              "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ") <>
             " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ") <>
            "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ") <>
           "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ") <>
          "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "

      commands = fields(table)
      # mins :: list(integer())
      mins = []
      _ = mins
      # i :: integer()
      i = 0
      _ = i

      t6 = fn t6, i, mins ->
        try do
          if i < _length(commands) do
            # count :: integer()
            count = 0
            _ = count
            # j :: integer()
            j = 0
            _ = j
            cmd = Enum.at(commands, i)

            t7 = fn t7, count, j ->
              try do
                if j < _length(cmd) do
                  ch = String.slice(cmd, j, j + 1 - j)

                  if ch >= "A" && ch <= "Z" do
                    count = count + 1
                  end

                  j = j + 1
                  t7.(t7, count, j)
                else
                  {:ok, count, j}
                end
              catch
                :break ->
                  {:ok, count, j}
              end
            end

            {_, count, j} = t7.(t7, count, j)
            _ = count
            _ = j
            mins = mins ++ [count]
            i = i + 1
            t6.(t6, i, mins)
          else
            {:ok, i, mins}
          end
        catch
          :break ->
            {:ok, i, mins}
        end
      end

      {_, i, mins} = t6.(t6, i, mins)
      _ = i
      _ = mins
      sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"
      words = fields(sentence)
      results = validate(commands, words, mins)
      # out1 :: String.t()
      out1 = "user words:  "
      _ = out1
      # k :: integer()
      k = 0
      _ = k

      t8 = fn t8, k, out1 ->
        try do
          if k < _length(words) do
            out1 = (out1 <> padRight(Enum.at(words, k), _length(Enum.at(results, k)))) <> " "
            k = k + 1
            t8.(t8, k, out1)
          else
            {:ok, k, out1}
          end
        catch
          :break ->
            {:ok, k, out1}
        end
      end

      {_, k, out1} = t8.(t8, k, out1)
      _ = k
      _ = out1
      IO.puts(out1)
      IO.puts("full words:  " <> join(results, " "))
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _length(v) do
    cond do
      is_binary(v) -> String.length(v)
      is_list(v) -> length(v)
      is_map(v) and Map.has_key?(v, :items) -> length(Map.get(v, :items))
      is_map(v) -> map_size(v)
      true -> raise "len expects list, map or string"
    end
  end
end

Main.main()
