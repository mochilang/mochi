# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:45:47Z
defmodule Main do
  @spec randOrder(integer(), integer()) :: list(integer())
  def randOrder(seed, n) do
    try do
      next = rem(seed * 1_664_525 + 1_013_904_223, 2_147_483_647)
      throw({:return, [next, rem(next, n)]})
    catch
      {:return, v} -> v
    end
  end

  @spec randChaos(integer(), integer()) :: list(integer())
  def randChaos(seed, n) do
    try do
      next = rem(seed * 1_103_515_245 + 12345, 2_147_483_647)
      throw({:return, [next, rem(next, n)]})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      nBuckets = 10
      initialSum = 1000
      buckets = []
      _ = buckets

      {buckets} =
        Enum.reduce(0..(nBuckets - 1), {buckets}, fn i, {buckets} ->
          buckets = buckets ++ [0]
          {buckets}
        end)

      _ = buckets
      i = nBuckets
      _ = i
      dist = initialSum
      _ = dist

      t1 = fn t1, buckets, dist, i ->
        try do
          if i > 0 do
            v = dist / i
            i = i - 1
            buckets = Map.put(buckets, i, v)
            dist = dist - v
            t1.(t1, buckets, dist, i)
          else
            {:ok, buckets, dist, i}
          end
        catch
          :break ->
            {:ok, buckets, dist, i}
        end
      end

      {_, buckets, dist, i} = t1.(t1, buckets, dist, i)
      _ = buckets
      _ = dist
      _ = i
      tc0 = 0
      _ = tc0
      tc1 = 0
      _ = tc1
      total = 0
      _ = total
      nTicks = 0
      _ = nTicks
      seedOrder = 1
      _ = seedOrder
      seedChaos = 2
      _ = seedChaos
      IO.puts("sum  ---updates---    mean  buckets")
      t = 0
      _ = t

      t2 = fn t2, buckets, nTicks, seedChaos, seedOrder, t, tc0, tc1, total ->
        try do
          if t < 5 do
            r = randOrder(seedOrder, nBuckets)
            _ = r
            seedOrder = Enum.at(r, 0)
            b1 = Enum.at(r, 1)
            _ = b1
            b2 = rem(b1 + 1, nBuckets)
            _ = b2
            v1 = Enum.at(buckets, b1)
            v2 = Enum.at(buckets, b2)

            if v1 > v2 do
              a = String.to_integer((v1 - v2) / 2)
              _ = a

              if a > Enum.at(buckets, b1) do
                a = Enum.at(buckets, b1)
              end

              buckets = Map.put(buckets, b1, Enum.at(buckets, b1) - a)
              buckets = Map.put(buckets, b2, Enum.at(buckets, b2) + a)
            else
              a = String.to_integer((v2 - v1) / 2)
              _ = a

              if a > Enum.at(buckets, b2) do
                a = Enum.at(buckets, b2)
              end

              buckets = Map.put(buckets, b2, Enum.at(buckets, b2) - a)
              buckets = Map.put(buckets, b1, Enum.at(buckets, b1) + a)
            end

            tc0 = tc0 + 1
            r = randChaos(seedChaos, nBuckets)
            seedChaos = Enum.at(r, 0)
            b1 = Enum.at(r, 1)
            b2 = rem(b1 + 1, nBuckets)
            r = randChaos(seedChaos, Enum.at(buckets, b1) + 1)
            seedChaos = Enum.at(r, 0)
            amt = Enum.at(r, 1)
            _ = amt

            if amt > Enum.at(buckets, b1) do
              amt = Enum.at(buckets, b1)
            end

            buckets = Map.put(buckets, b1, Enum.at(buckets, b1) - amt)
            buckets = Map.put(buckets, b2, Enum.at(buckets, b2) + amt)
            tc1 = tc1 + 1
            # sum :: (any() -> float())
            sum = 0
            _ = sum
            idx = 0
            _ = idx

            t3 = fn t3, idx, sum ->
              try do
                if idx < nBuckets do
                  sum = sum + Enum.at(buckets, idx)
                  idx = idx + 1
                  t3.(t3, idx, sum)
                else
                  {:ok, idx, sum}
                end
              catch
                :break ->
                  {:ok, idx, sum}
              end
            end

            {_, idx, sum} = t3.(t3, idx, sum)
            _ = idx
            _ = sum
            total = total + tc0 + tc1
            nTicks = nTicks + 1

            IO.puts(
              (((((((to_string(sum) <> " ") <> to_string(tc0)) <> " ") <> to_string(tc1)) <> " ") <>
                  to_string(total / nTicks)) <> "  ") <> to_string(buckets)
            )

            tc0 = 0
            tc1 = 0
            t = t + 1
            t2.(t2, buckets, nTicks, seedChaos, seedOrder, t, tc0, tc1, total)
          else
            {:ok, buckets, nTicks, seedChaos, seedOrder, t, tc0, tc1, total}
          end
        catch
          :break ->
            {:ok, buckets, nTicks, seedChaos, seedOrder, t, tc0, tc1, total}
        end
      end

      {_, buckets, nTicks, seedChaos, seedOrder, t, tc0, tc1, total} =
        t2.(t2, buckets, nTicks, seedChaos, seedOrder, t, tc0, tc1, total)

      _ = buckets
      _ = nTicks
      _ = seedChaos
      _ = seedOrder
      _ = t
      _ = tc0
      _ = tc1
      _ = total
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end
end

Main.main()
