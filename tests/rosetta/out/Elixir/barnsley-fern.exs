# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:13Z
defmodule Main do
  @xMax 2.6558
  @yMin 0
  @yMax 9.9983
  @width 60
  @nIter 10000
  @spec randInt(integer(), integer()) :: list(integer())
  def randInt(s, n) do
    try do
      next = rem(s * 1_664_525 + 1_013_904_223, 2_147_483_647)
      throw({:return, [next, rem(next, n)]})
    catch
      {:return, v} -> v
    end
  end

  def main do
    # xMin :: float()
    xMin = -2.182
    # dx :: float()
    dx = @xMax - xMin
    # dy :: float()
    dy = @yMax - @yMin
    # height :: integer()
    height = String.to_integer(@width * dy / dx)
    # grid :: list(list(String.t()))
    grid = []
    _ = grid
    # row :: integer()
    row = 0
    _ = row

    t1 = fn t1, grid, row ->
      try do
        if row < height do
          line = []
          _ = line
          col = 0
          _ = col

          t2 = fn t2, col, line ->
            try do
              if col < @width do
                line = line ++ [" "]
                col = col + 1
                t2.(t2, col, line)
              else
                {:ok, col, line}
              end
            catch
              :break ->
                {:ok, col, line}
            end
          end

          {_, col, line} = t2.(t2, col, line)
          _ = col
          _ = line
          grid = grid ++ [line]
          row = row + 1
          t1.(t1, grid, row)
        else
          {:ok, grid, row}
        end
      catch
        :break ->
          {:ok, grid, row}
      end
    end

    {_, grid, row} = t1.(t1, grid, row)
    _ = grid
    _ = row
    # seed :: integer()
    seed = 1
    _ = seed
    # x :: float()
    x = 0
    _ = x
    # y :: float()
    y = 0
    _ = y
    # ix :: integer()
    ix = String.to_integer(String.to_float(@width) * (x - xMin) / dx)
    _ = ix
    # iy :: integer()
    iy = String.to_integer(String.to_float(height) * (@yMax - y) / dy)
    _ = iy

    if ix >= 0 && ix < @width && iy >= 0 && iy < height do
      grid = List.update_at(grid, iy, fn it -> List.replace_at(it, ix, "*") end)
    end

    # i :: integer()
    i = 0
    _ = i

    t3 = fn t3, grid, i, ix, iy, seed, x, y ->
      try do
        if i < @nIter do
          res = randInt(seed, 100)
          _ = res
          seed = Enum.at(res, 0)
          r = Enum.at(res, 1)

          if r < 85 do
            nx = 0.85 * x + 0.04 * y
            ny = -0.04 * x + 0.85 * y + 1.6
            x = nx
            y = ny
          else
            if r < 92 do
              nx = 0.2 * x - 0.26 * y
              ny = 0.23 * x + 0.22 * y + 1.6
              x = nx
              y = ny
            else
              if r < 99 do
                nx = -0.15 * x + 0.28 * y
                ny = 0.26 * x + 0.24 * y + 0.44
                x = nx
                y = ny
              else
                x = 0
                y = 0.16 * y
              end
            end
          end

          ix = String.to_integer(String.to_float(@width) * (x - xMin) / dx)
          iy = String.to_integer(String.to_float(height) * (@yMax - y) / dy)

          if ix >= 0 && ix < @width && iy >= 0 && iy < height do
            grid = List.update_at(grid, iy, fn it -> List.replace_at(it, ix, "*") end)
          end

          i = i + 1
          t3.(t3, grid, i, ix, iy, seed, x, y)
        else
          {:ok, grid, i, ix, iy, seed, x, y}
        end
      catch
        :break ->
          {:ok, grid, i, ix, iy, seed, x, y}
      end
    end

    {_, grid, i, ix, iy, seed, x, y} = t3.(t3, grid, i, ix, iy, seed, x, y)
    _ = grid
    _ = i
    _ = ix
    _ = iy
    _ = seed
    _ = x
    _ = y
    row = 0

    t4 = fn t4, row ->
      try do
        if row < height do
          line = ""
          _ = line
          col = 0
          _ = col

          t5 = fn t5, col, line ->
            try do
              if col < @width do
                line = line + Enum.at(Enum.at(grid, row), col)
                col = col + 1
                t5.(t5, col, line)
              else
                {:ok, col, line}
              end
            catch
              :break ->
                {:ok, col, line}
            end
          end

          {_, col, line} = t5.(t5, col, line)
          _ = col
          _ = line
          IO.inspect(line)
          row = row + 1
          t4.(t4, row)
        else
          {:ok, row}
        end
      catch
        :break ->
          {:ok, row}
      end
    end

    {_, row} = t4.(t4, row)
    _ = row
  end
end

Main.main()
