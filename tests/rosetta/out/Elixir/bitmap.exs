# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:51Z
defmodule Pixel do
  @type t :: %__MODULE__{R: integer(), G: integer(), B: integer()}
  defstruct R: nil, G: nil, B: nil
end

defmodule Bitmap do
  @type t :: %__MODULE__{cols: integer(), rows: integer(), px: list(list(Pixel))}
  defstruct cols: nil, rows: nil, px: nil
end

defmodule Main do
	@spec pixelFromRgb(integer()) :: Pixel
	def pixelFromRgb(c) do
		try do
			r = rem(String.to_integer((c / 65536)), 256)
			g = rem(String.to_integer((c / 256)), 256)
			b = rem(c, 256)
			throw {:return, %Pixel{R: r, G: g, B: b}}
		catch {:return, v} -> v end
	end
	
	@spec rgbFromPixel(Pixel) :: integer()
	def rgbFromPixel(p) do
		try do
			throw {:return, (((p.R * 65536) + (p.G * 256)) + p.B)}
		catch {:return, v} -> v end
	end
	
	@spec NewBitmap(integer(), integer()) :: Bitmap
	def NewBitmap(x, y) do
		try do
			data = []
			_ = data
			row = 0
			_ = row
			t1 = fn t1, data, row ->
				try do
					if (row < y) do
						r = []
						_ = r
						col = 0
						_ = col
						t2 = fn t2, col, r ->
							try do
								if (col < x) do
									r = r ++ [%Pixel{R: 0, G: 0, B: 0}]
									col = (col + 1)
									t2.(t2, col, r)
								else
									{:ok, col, r}
								end
							catch :break ->
								{:ok, col, r}
							end
						end
						{_, col, r} = t2.(t2, col, r)
						_ = col
						_ = r
						data = data ++ [r]
						row = (row + 1)
						t1.(t1, data, row)
					else
						{:ok, data, row}
					end
				catch :break ->
					{:ok, data, row}
				end
			end
			{_, data, row} = t1.(t1, data, row)
			_ = data
			_ = row
			throw {:return, %Bitmap{cols: x, rows: y, px: data}}
		catch {:return, v} -> v end
	end
	
	@spec Extent(Bitmap) :: map()
	def Extent(b) do
		try do
			throw {:return, %{"cols" => b.cols, "rows" => b.rows}}
		catch {:return, v} -> v end
	end
	
	@spec Fill(Bitmap, Pixel) :: nil
	def Fill(b, p) do
		try do
			y = 0
			_ = y
			t3 = fn t3, b, y ->
				try do
					if (y < b.rows) do
						x = 0
						_ = x
						t4 = fn t4, b, x ->
							try do
								if (x < b.cols) do
									px = b.px
									_ = px
									row = Enum.at((px), y)
									_ = row
									row = Map.put(row, x, p)
									px = Map.put(px, y, row)
									b = %{b | px: px}
									x = (x + 1)
									t4.(t4, b, x)
								else
									{:ok, b, x}
								end
							catch :break ->
								{:ok, b, x}
							end
						end
						{_, b, x} = t4.(t4, b, x)
						_ = b
						_ = x
						y = (y + 1)
						t3.(t3, b, y)
					else
						{:ok, b, y}
					end
				catch :break ->
					{:ok, b, y}
				end
			end
			{_, b, y} = t3.(t3, b, y)
			_ = b
			_ = y
		catch {:return, v} -> v end
	end
	
	@spec FillRgb(Bitmap, integer()) :: nil
	def FillRgb(b, c) do
		try do
			Fill(b, pixelFromRgb(c))
		catch {:return, v} -> v end
	end
	
	@spec SetPx(Bitmap, integer(), integer(), Pixel) :: boolean()
	def SetPx(b, x, y, p) do
		try do
			if ((((x < 0) || (x >= b.cols)) || (y < 0)) || (y >= b.rows)) do
				throw {:return, false}
			end
			px = b.px
			_ = px
			row = Enum.at((px), y)
			_ = row
			row = Map.put(row, x, p)
			px = Map.put(px, y, row)
			b = %{b | px: px}
			throw {:return, true}
		catch {:return, v} -> v end
	end
	
	@spec SetPxRgb(Bitmap, integer(), integer(), integer()) :: boolean()
	def SetPxRgb(b, x, y, c) do
		try do
			throw {:return, SetPx(b, x, y, pixelFromRgb(c))}
		catch {:return, v} -> v end
	end
	
	@spec GetPx(Bitmap, integer(), integer()) :: map()
	def GetPx(b, x, y) do
		try do
			if ((((x < 0) || (x >= b.cols)) || (y < 0)) || (y >= b.rows)) do
				throw {:return, %{"ok" => false}}
			end
			row = Enum.at((b.px), y)
			throw {:return, %{"ok" => true, "pixel" => Enum.at((row), x)}}
		catch {:return, v} -> v end
	end
	
	@spec GetPxRgb(Bitmap, integer(), integer()) :: map()
	def GetPxRgb(b, x, y) do
		try do
			r = GetPx(b, x, y)
			if !r.ok do
				throw {:return, %{"ok" => false}}
			end
			throw {:return, %{"ok" => true, "rgb" => rgbFromPixel(r.pixel)}}
		catch {:return, v} -> v end
	end
	
	@spec ppmSize(Bitmap) :: integer()
	def ppmSize(b) do
		try do
			header = (((("P6\n# Creator: Rosetta Code http://rosettacode.org/\n" <> to_string(b.cols)) <> " ") <> to_string(b.rows)) <> "\n255\n")
			throw {:return, (length(header) + ((3 * b.cols) * b.rows))}
		catch {:return, v} -> v end
	end
	
	@spec pixelStr(Pixel) :: String.t()
	def pixelStr(p) do
		try do
			throw {:return, (((((("{" <> to_string(p.R)) <> " ") <> to_string(p.G)) <> " ") <> to_string(p.B)) <> "}")}
		catch {:return, v} -> v end
	end
	
	@spec main() :: nil
	def main() do
		try do
			bm = NewBitmap(300, 240)
			_ = bm
			FillRgb(bm, 16711680)
			SetPxRgb(bm, 10, 20, 255)
			SetPxRgb(bm, 20, 30, 0)
			SetPxRgb(bm, 30, 40, 1056816)
			c1 = GetPx(bm, 0, 0)
			c2 = GetPx(bm, 10, 20)
			c3 = GetPx(bm, 30, 40)
			IO.puts(((("Image size: " <> to_string(bm.cols)) <> " Ã— ") <> to_string(bm.rows)))
			IO.puts((to_string(ppmSize(bm)) <> " bytes when encoded as PPM."))
			if c1.ok do
				IO.puts(("Pixel at (0,0) is " <> pixelStr(c1.pixel)))
			end
			if c2.ok do
				IO.puts(("Pixel at (10,20) is " <> pixelStr(c2.pixel)))
			end
			if c3.ok do
				p = c3.pixel
				r16 = (p.R * 257)
				_ = r16
				g16 = (p.G * 257)
				_ = g16
				b16 = (p.B * 257)
				_ = b16
				IO.puts(((((("Pixel at (30,40) has R=" <> to_string(r16)) <> ", G=") <> to_string(g16)) <> ", B=") <> to_string(b16)))
			end
		catch {:return, v} -> v end
	end
	
	def main do
		main()
	end
	end
Main.main()
