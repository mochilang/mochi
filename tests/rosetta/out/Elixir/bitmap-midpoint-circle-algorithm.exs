# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:41Z
defmodule Main do
  @spec initGrid(integer()) :: list(list(String.t()))
  def initGrid(size) do
    try do
      # g :: list(list(String.t()))
      g = []
      _ = g
      y = 0
      _ = y

      t1 = fn t1, g, y ->
        try do
          if y < size do
            row = []
            _ = row
            x = 0
            _ = x

            t2 = fn t2, row, x ->
              try do
                if x < size do
                  row = row ++ [" "]
                  x = x + 1
                  t2.(t2, row, x)
                else
                  {:ok, row, x}
                end
              catch
                :break ->
                  {:ok, row, x}
              end
            end

            {_, row, x} = t2.(t2, row, x)
            _ = row
            _ = x
            g = g ++ [row]
            y = y + 1
            t1.(t1, g, y)
          else
            {:ok, g, y}
          end
        catch
          :break ->
            {:ok, g, y}
        end
      end

      {_, g, y} = t1.(t1, g, y)
      _ = g
      _ = y
      throw({:return, g})
    catch
      {:return, v} -> v
    end
  end

  @spec set(list(list(String.t())), integer(), integer()) :: nil
  def set(g, x, y) do
    try do
      if x >= 0 && x < length(Enum.at(g, 0)) && y >= 0 && y < length(g) do
        g = List.update_at(g, y, fn it -> List.replace_at(it, x, "#") end)
      end
    catch
      {:return, v} -> v
    end
  end

  @spec circle(integer()) :: list(list(String.t()))
  def circle(r) do
    try do
      size = r * 2 + 1
      # g :: list(list(String.t()))
      g = initGrid(size)
      _ = g
      x = r
      _ = x
      y = 0
      _ = y
      err = 1 - r
      _ = err

      t3 = fn t3, err, x, y ->
        try do
          if y <= x do
            set(g, r + x, r + y)
            set(g, r + y, r + x)
            set(g, r - x, r + y)
            set(g, r - y, r + x)
            set(g, r - x, r - y)
            set(g, r - y, r - x)
            set(g, r + x, r - y)
            set(g, r + y, r - x)
            y = y + 1

            if err < 0 do
              err = err + 2 * y + 1
            else
              x = x - 1
              err = err + 2 * (y - x) + 1
            end

            t3.(t3, err, x, y)
          else
            {:ok, err, x, y}
          end
        catch
          :break ->
            {:ok, err, x, y}
        end
      end

      {_, err, x, y} = t3.(t3, err, x, y)
      _ = err
      _ = x
      _ = y
      throw({:return, g})
    catch
      {:return, v} -> v
    end
  end

  @spec trimRight(list(String.t())) :: String.t()
  def trimRight(row) do
    try do
      end_ = length(row)
      _ = end_

      t4 = fn t4, end_ ->
        try do
          if end_ > 0 && Enum.at(row, end_ - 1) == " " do
            end_ = end_ - 1
            t4.(t4, end_)
          else
            {:ok, end_}
          end
        catch
          :break ->
            {:ok, end_}
        end
      end

      {_, end_} = t4.(t4, end_)
      _ = end_
      s = ""
      _ = s
      i = 0
      _ = i

      t5 = fn t5, i, s ->
        try do
          if i < end_ do
            s = s + Enum.at(row, i)
            i = i + 1
            t5.(t5, i, s)
          else
            {:ok, i, s}
          end
        catch
          :break ->
            {:ok, i, s}
        end
      end

      {_, i, s} = t5.(t5, i, s)
      _ = i
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  def main do
    # g :: list(list(String.t()))
    g = circle(10)
    _ = g

    for row <- g do
      IO.puts(trimRight(row))
    end
  end
end

Main.main()
