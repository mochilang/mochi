# Generated by Mochi compiler v0.10.30 on 2025-07-19T01:02:27Z
defmodule Main do
  @spec fields(String.t()) :: list(String.t())
  def fields(s) do
    try do
      # words :: list(String.t())
      words = []
      _ = words
      # cur :: String.t()
      cur = ""
      _ = cur
      # i :: integer()
      i = 0
      _ = i

      t1 = fn t1, cur, i, words ->
        try do
          if i < String.length(s) do
            ch = String.slice(s, i, i + 1 - i)

            if ch == " " || ch == "\n" || ch == "\t" do
              if String.length(cur) > 0 do
                words = words ++ [cur]
                cur = ""
              end
            else
              cur = cur <> ch
            end

            i = i + 1
            t1.(t1, cur, i, words)
          else
            {:ok, cur, i, words}
          end
        catch
          :break ->
            {:ok, cur, i, words}
        end
      end

      {_, cur, i, words} = t1.(t1, cur, i, words)
      _ = cur
      _ = i
      _ = words

      if String.length(cur) > 0 do
        words = words ++ [cur]
      end

      throw({:return, words})
    catch
      {:return, v} -> v
    end
  end

  @spec join(list(String.t()), String.t()) :: String.t()
  def join(xs, sep) do
    try do
      # res :: String.t()
      res = ""
      _ = res
      # i :: integer()
      i = 0
      _ = i

      t2 = fn t2, i, res ->
        try do
          if i < length(xs) do
            if i > 0 do
              res = res <> sep
            end

            res = res <> Enum.at(xs, i)
            i = i + 1
            t2.(t2, i, res)
          else
            {:ok, i, res}
          end
        catch
          :break ->
            {:ok, i, res}
        end
      end

      {_, i, res} = t2.(t2, i, res)
      _ = i
      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec numberName(integer()) :: String.t()
  def numberName(n) do
    try do
      small = [
        "no",
        "one",
        "two",
        "three",
        "four",
        "five",
        "six",
        "seven",
        "eight",
        "nine",
        "ten",
        "eleven",
        "twelve",
        "thirteen",
        "fourteen",
        "fifteen",
        "sixteen",
        "seventeen",
        "eighteen",
        "nineteen"
      ]

      tens = [
        "ones",
        "ten",
        "twenty",
        "thirty",
        "forty",
        "fifty",
        "sixty",
        "seventy",
        "eighty",
        "ninety"
      ]

      if n < 0 do
        throw({:return, ""})
      end

      if n < 20 do
        throw({:return, Enum.at(small, n)})
      end

      if n < 100 do
        # t :: any()
        t = Enum.at(tens, String.to_integer(n / 10))
        _ = t
        # s :: integer()
        s = rem(n, 10)
        _ = s

        if s > 0 do
          t = (t <> " ") <> Enum.at(small, s)
        end

        throw({:return, t})
      end

      throw({:return, ""})
    catch
      {:return, v} -> v
    end
  end

  @spec pluralizeFirst(String.t(), integer()) :: String.t()
  def pluralizeFirst(s, n) do
    try do
      if n == 1 do
        throw({:return, s})
      end

      w = fields(s)

      if _length(w) > 0 do
        w = Map.put(w, 0, Enum.at(w, 0) <> "s")
      end

      throw({:return, join(w, " ")})
    catch
      {:return, v} -> v
    end
  end

  @spec randInt(integer(), integer()) :: integer()
  def randInt(seed, n) do
    try do
      next = rem(seed * 1_664_525 + 1_013_904_223, 2_147_483_647)
      throw({:return, rem(next, n)})
    catch
      {:return, v} -> v
    end
  end

  @spec slur(String.t(), integer()) :: String.t()
  def slur(p, d) do
    try do
      if String.length(p) <= 2 do
        throw({:return, p})
      end

      # a :: list(String.t())
      a = []
      _ = a
      # i :: integer()
      i = 1
      _ = i

      t3 = fn t3, a, i ->
        try do
          if i < String.length(p) - 1 do
            a = a ++ [String.slice(p, i, i + 1 - i)]
            i = i + 1
            t3.(t3, a, i)
          else
            {:ok, a, i}
          end
        catch
          :break ->
            {:ok, a, i}
        end
      end

      {_, a, i} = t3.(t3, a, i)
      _ = a
      _ = i
      # idx :: integer()
      idx = length(a) - 1
      _ = idx
      # seed :: integer()
      seed = d
      _ = seed

      t4 = fn t4, a, idx, seed ->
        try do
          if idx >= 1 do
            seed = rem(seed * 1_664_525 + 1_013_904_223, 2_147_483_647)

            if rem(seed, 100) >= d do
              j = rem(seed, idx + 1)
              tmp = Enum.at(a, idx)
              a = List.replace_at(a, idx, Enum.at(a, j))
              a = List.replace_at(a, j, tmp)
            end

            idx = idx - 1
            t4.(t4, a, idx, seed)
          else
            {:ok, a, idx, seed}
          end
        catch
          :break ->
            {:ok, a, idx, seed}
        end
      end

      {_, a, idx, seed} = t4.(t4, a, idx, seed)
      _ = a
      _ = idx
      _ = seed
      # s :: String.t()
      s = String.slice(p, 0, 1 - 0)
      _ = s
      # k :: integer()
      k = 0
      _ = k

      t5 = fn t5, k, s ->
        try do
          if k < length(a) do
            s = s <> Enum.at(a, k)
            k = k + 1
            t5.(t5, k, s)
          else
            {:ok, k, s}
          end
        catch
          :break ->
            {:ok, k, s}
        end
      end

      {_, k, s} = t5.(t5, k, s)
      _ = k
      _ = s
      s = s <> String.slice(p, String.length(p) - 1, String.length(p) - (String.length(p) - 1))
      w = fields(s)
      throw({:return, join(w, " ")})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      # i :: integer()
      i = 99
      _ = i

      t6 = fn t6, i ->
        try do
          if i > 0 do
            IO.puts(
              (((slur(numberName(i), i) <> " ") <> pluralizeFirst(slur("bottle of", i), i)) <> " ") <>
                slur("beer on the wall", i)
            )

            IO.puts(
              (((slur(numberName(i), i) <> " ") <> pluralizeFirst(slur("bottle of", i), i)) <> " ") <>
                slur("beer", i)
            )

            IO.puts(
              (((slur("take one", i) <> " ") <> slur("down", i)) <> " ") <>
                slur("pass it around", i)
            )

            IO.puts(
              (((slur(numberName(i - 1), i) <> " ") <> pluralizeFirst(slur("bottle of", i), i - 1)) <>
                 " ") <> slur("beer on the wall", i)
            )

            i = i - 1
            t6.(t6, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t6.(t6, i)
      _ = i
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _length(v) do
    cond do
      is_binary(v) -> String.length(v)
      is_list(v) -> length(v)
      is_map(v) and Map.has_key?(v, :items) -> length(Map.get(v, :items))
      is_map(v) -> map_size(v)
      true -> raise "len expects list, map or string"
    end
  end
end

Main.main()
