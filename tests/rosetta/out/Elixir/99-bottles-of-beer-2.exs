# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:49:16Z
defmodule Main do
  @spec fields(String.t()) :: list(String.t())
  def fields(s) do
    try do
      words = []
      _ = words
      cur = ""
      _ = cur
      i = 0
      _ = i

      t1 = fn t1, cur, i, words ->
        try do
          if i < length(s) do
            ch = _slice_string(s, i, i + 1)

            if ch == " " || ch == "\n" || ch == "\t" do
              if length(cur) > 0 do
                words = words ++ [cur]
                cur = ""
              end
            else
              cur = cur + ch
            end

            i = i + 1
            t1.(t1, cur, i, words)
          else
            {:ok, cur, i, words}
          end
        catch
          :break ->
            {:ok, cur, i, words}
        end
      end

      {_, cur, i, words} = t1.(t1, cur, i, words)
      _ = cur
      _ = i
      _ = words

      if length(cur) > 0 do
        words = words ++ [cur]
      end

      throw({:return, words})
    catch
      {:return, v} -> v
    end
  end

  @spec join(list(String.t()), String.t()) :: String.t()
  def join(xs, sep) do
    try do
      res = ""
      _ = res
      i = 0
      _ = i

      t2 = fn t2, i, res ->
        try do
          if i < length(xs) do
            if i > 0 do
              res = res + sep
            end

            res = res + Enum.at(xs, i)
            i = i + 1
            t2.(t2, i, res)
          else
            {:ok, i, res}
          end
        catch
          :break ->
            {:ok, i, res}
        end
      end

      {_, i, res} = t2.(t2, i, res)
      _ = i
      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec numberName(integer()) :: String.t()
  def numberName(n) do
    try do
      small = [
        "no",
        "one",
        "two",
        "three",
        "four",
        "five",
        "six",
        "seven",
        "eight",
        "nine",
        "ten",
        "eleven",
        "twelve",
        "thirteen",
        "fourteen",
        "fifteen",
        "sixteen",
        "seventeen",
        "eighteen",
        "nineteen"
      ]

      tens = [
        "ones",
        "ten",
        "twenty",
        "thirty",
        "forty",
        "fifty",
        "sixty",
        "seventy",
        "eighty",
        "ninety"
      ]

      if n < 0 do
        throw({:return, ""})
      end

      if n < 20 do
        throw({:return, Enum.at(small, n)})
      end

      if n < 100 do
        t = Enum.at(tens, String.to_integer(n / 10))
        _ = t
        s = rem(n, 10)
        _ = s

        if s > 0 do
          t = (t <> " ") <> Enum.at(small, s)
        end

        throw({:return, t})
      end

      throw({:return, ""})
    catch
      {:return, v} -> v
    end
  end

  @spec pluralizeFirst(String.t(), integer()) :: String.t()
  def pluralizeFirst(s, n) do
    try do
      if n == 1 do
        throw({:return, s})
      end

      w = fields(s)

      if length(w) > 0 do
        w = Map.put(w, 0, Enum.at(w, 0) <> "s")
      end

      throw({:return, join(w, " ")})
    catch
      {:return, v} -> v
    end
  end

  @spec randInt(integer(), integer()) :: integer()
  def randInt(seed, n) do
    try do
      next = rem(seed * 1_664_525 + 1_013_904_223, 2_147_483_647)
      throw({:return, rem(next, n)})
    catch
      {:return, v} -> v
    end
  end

  @spec slur(String.t(), integer()) :: String.t()
  def slur(p, d) do
    try do
      if length(p) <= 2 do
        throw({:return, p})
      end

      a = []
      _ = a
      i = 1
      _ = i

      t3 = fn t3, a, i ->
        try do
          if i < length(p) - 1 do
            a = a ++ [_slice_string(p, i, i + 1)]
            i = i + 1
            t3.(t3, a, i)
          else
            {:ok, a, i}
          end
        catch
          :break ->
            {:ok, a, i}
        end
      end

      {_, a, i} = t3.(t3, a, i)
      _ = a
      _ = i
      idx = length(a) - 1
      _ = idx
      seed = d
      _ = seed

      t4 = fn t4, a, idx, seed ->
        try do
          if idx >= 1 do
            seed = rem(seed * 1_664_525 + 1_013_904_223, 2_147_483_647)

            if rem(seed, 100) >= d do
              j = rem(seed, idx + 1)
              tmp = Enum.at(a, idx)
              a = Map.put(a, idx, Enum.at(a, j))
              a = Map.put(a, j, tmp)
            end

            idx = idx - 1
            t4.(t4, a, idx, seed)
          else
            {:ok, a, idx, seed}
          end
        catch
          :break ->
            {:ok, a, idx, seed}
        end
      end

      {_, a, idx, seed} = t4.(t4, a, idx, seed)
      _ = a
      _ = idx
      _ = seed
      s = _slice_string(p, 0, 1)
      _ = s
      k = 0
      _ = k

      t5 = fn t5, k, s ->
        try do
          if k < length(a) do
            s = s + Enum.at(a, k)
            k = k + 1
            t5.(t5, k, s)
          else
            {:ok, k, s}
          end
        catch
          :break ->
            {:ok, k, s}
        end
      end

      {_, k, s} = t5.(t5, k, s)
      _ = k
      _ = s
      s = s + _slice_string(p, length(p) - 1, length(p))
      w = fields(s)
      throw({:return, join(w, " ")})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      i = 99
      _ = i

      t6 = fn t6, i ->
        try do
          if i > 0 do
            IO.puts(
              (((slur(numberName(i), i) <> " ") <> pluralizeFirst(slur("bottle of", i), i)) <> " ") <>
                slur("beer on the wall", i)
            )

            IO.puts(
              (((slur(numberName(i), i) <> " ") <> pluralizeFirst(slur("bottle of", i), i)) <> " ") <>
                slur("beer", i)
            )

            IO.puts(
              (((slur("take one", i) <> " ") <> slur("down", i)) <> " ") <>
                slur("pass it around", i)
            )

            IO.puts(
              (((slur(numberName(i - 1), i) <> " ") <> pluralizeFirst(slur("bottle of", i), i - 1)) <>
                 " ") <> slur("beer on the wall", i)
            )

            i = i - 1
            t6.(t6, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t6.(t6, i)
      _ = i
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
