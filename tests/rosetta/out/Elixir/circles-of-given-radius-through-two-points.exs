# Generated by Mochi compiler v0.10.26 on 2025-07-16T14:09:11Z
defmodule Point do
  @type t :: %__MODULE__{x: float(), y: float()}
  defstruct x: nil, y: nil
end

defmodule Main do
	@Two "Two circles."
	@R0 "R==0.0 does not describe circles."
	@Co "Coincident points describe an infinite number of circles."
	@Diam "Points form a diameter and describe only a single circle."
	@Far "Points too far apart to form circles."
	@spec sqrtApprox(float()) :: float()
	def sqrtApprox(x) do
		try do
			g = x
			_ = g
			i = 0
			_ = i
			t1 = fn t1, g, i ->
				try do
					if (i < 40) do
						g = ((g + (x / g)) / 2)
						i = (i + 1)
						t1.(t1, g, i)
					else
						{:ok, g, i}
					end
				catch :break ->
					{:ok, g, i}
				end
			end
			{_, g, i} = t1.(t1, g, i)
			_ = g
			_ = i
			throw {:return, g}
		catch {:return, v} -> v end
	end
	
	@spec hypot(float(), float()) :: float()
	def hypot(x, y) do
		try do
			throw {:return, sqrtApprox(((x * x) + (y * y)))}
		catch {:return, v} -> v end
	end
	
	@spec circles(Point, Point, float()) :: list(any())
	def circles(p1, p2, r) do
		try do
			if ((p1.x == p2.x) && (p1.y == p2.y)) do
				if (r == 0) do
					throw {:return, [p1, p1, "Coincident points with r==0.0 describe a degenerate circle."]}
				end
				throw {:return, [p1, p2, "Coincident points describe an infinite number of circles."]}
			end
			if (r == 0) do
				throw {:return, [p1, p2, "R==0.0 does not describe circles."]}
			end
			dx = (p2.x - p1.x)
			dy = (p2.y - p1.y)
			q = hypot(dx, dy)
			if (q > (2 * r)) do
				throw {:return, [p1, p2, "Points too far apart to form circles."]}
			end
			m = %Point{x: ((p1.x + p2.x) / 2), y: ((p1.y + p2.y) / 2)}
			if (q == (2 * r)) do
				throw {:return, [m, m, "Points form a diameter and describe only a single circle."]}
			end
			d = sqrtApprox(((r * r) - ((q * q) / 4)))
			ox = ((d * dx) / q)
			oy = ((d * dy) / q)
			throw {:return, [%Point{x: (m.x - oy), y: (m.y + ox)}, %Point{x: (m.x + oy), y: (m.y - ox)}, "Two circles."]}
		catch {:return, v} -> v end
	end
	
	def main do
		# CoR0 :: String.t()
		CoR0 = "Coincident points with r==0.0 describe a degenerate circle."
		# td :: list(list(any()))
		td = [[%Point{x: 0.1234, y: 0.9876}, %Point{x: 0.8765, y: 0.2345}, 2], [%Point{x: 0, y: 2}, %Point{x: 0, y: 0}, 1], [%Point{x: 0.1234, y: 0.9876}, %Point{x: 0.1234, y: 0.9876}, 2], [%Point{x: 0.1234, y: 0.9876}, %Point{x: 0.8765, y: 0.2345}, 0.5], [%Point{x: 0.1234, y: 0.9876}, %Point{x: 0.1234, y: 0.9876}, 0]]
		_ = td
		for tc <- td do
			p1 = Enum.at((tc), 0)
			p2 = Enum.at((tc), 1)
			r = Enum.at((tc), 2)
			IO.puts((((("p1:  {" <> to_string(p1.x)) <> " ") <> to_string(p1.y)) <> "}"))
			IO.puts((((("p2:  {" <> to_string(p2.x)) <> " ") <> to_string(p2.y)) <> "}"))
			IO.puts(("r:  " <> to_string(r)))
			res = circles(p1, p2, r)
			c1 = Enum.at((res), 0)
			c2 = Enum.at((res), 1)
			caseStr = Enum.at((res), 2)
			IO.inspect(("   " <> caseStr))
			if ((caseStr == "Points form a diameter and describe only a single circle.") || (caseStr == "Coincident points with r==0.0 describe a degenerate circle.")) do
				IO.puts((((("   Center:  {" <> to_string(c1.x)) <> " ") <> to_string(c1.y)) <> "}"))
			else
				if (caseStr == "Two circles.") do
					IO.puts((((("   Center 1:  {" <> to_string(c1.x)) <> " ") <> to_string(c1.y)) <> "}"))
					IO.puts((((("   Center 2:  {" <> to_string(c2.x)) <> " ") <> to_string(c2.y)) <> "}"))
				end
			end
			IO.puts("")
		end
	end
	end
Main.main()
