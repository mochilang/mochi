# Generated by Mochi compiler v0.10.30 on 2025-07-19T01:02:20Z
defmodule Main do
  @size 4
  @spec newBoard() :: list(list(integer()))
  def newBoard() do
    try do
      # b :: list(list(integer()))
      b = []
      _ = b
      # y :: integer()
      y = 0
      _ = y

      t1 = fn t1, b, y ->
        try do
          if y < @size do
            # row :: list(integer())
            row = []
            _ = row
            # x :: integer()
            x = 0
            _ = x

            t2 = fn t2, row, x ->
              try do
                if x < @size do
                  row = row ++ [0]
                  x = x + 1
                  t2.(t2, row, x)
                else
                  {:ok, row, x}
                end
              catch
                :break ->
                  {:ok, row, x}
              end
            end

            {_, row, x} = t2.(t2, row, x)
            _ = row
            _ = x
            b = b ++ [row]
            y = y + 1
            t1.(t1, b, y)
          else
            {:ok, b, y}
          end
        catch
          :break ->
            {:ok, b, y}
        end
      end

      {_, b, y} = t1.(t1, b, y)
      _ = b
      _ = y
      throw({:return, b})
    catch
      {:return, v} -> v
    end
  end

  @spec spawnTile(list(list(integer()))) :: map()
  def spawnTile(b) do
    try do
      # empty :: list(list(integer()))
      empty = []
      _ = empty
      # y :: integer()
      y = 0
      _ = y

      t3 = fn t3, empty, y ->
        try do
          if y < @size do
            # x :: integer()
            x = 0
            _ = x

            t4 = fn t4, empty, x ->
              try do
                if x < @size do
                  if Enum.at(Enum.at(b, y), x) == 0 do
                    empty = empty ++ [[x, y]]
                  end

                  x = x + 1
                  t4.(t4, empty, x)
                else
                  {:ok, empty, x}
                end
              catch
                :break ->
                  {:ok, empty, x}
              end
            end

            {_, empty, x} = t4.(t4, empty, x)
            _ = empty
            _ = x
            y = y + 1
            t3.(t3, empty, y)
          else
            {:ok, empty, y}
          end
        catch
          :break ->
            {:ok, empty, y}
        end
      end

      {_, empty, y} = t3.(t3, empty, y)
      _ = empty
      _ = y

      if length(empty) == 0 do
        throw({:return, %{"board" => b, "full" => true}})
      end

      # idx :: integer()
      idx = rem(_now(), length(empty))
      _ = idx
      cell = Enum.at(empty, idx)
      # val :: integer()
      val = 4
      _ = val

      if rem(_now(), 10) < 9 do
        val = 2
      end

      b =
        List.update_at(b, Enum.at(cell, 1), fn it ->
          List.replace_at(it, Enum.at(cell, 0), val)
        end)

      throw({:return, %{"board" => b, "full" => length(empty) == 1}})
    catch
      {:return, v} -> v
    end
  end

  @spec pad(integer()) :: String.t()
  def pad(n) do
    try do
      # s :: String.t()
      s = to_string(n)
      _ = s
      # pad :: integer()
      pad = 4 - String.length(s)
      _ = pad
      # i :: integer()
      i = 0
      _ = i
      # out :: String.t()
      out = ""
      _ = out

      t5 = fn t5, i, out ->
        try do
          if i < pad do
            out = out <> " "
            i = i + 1
            t5.(t5, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t5.(t5, i, out)
      _ = i
      _ = out
      throw({:return, out <> s})
    catch
      {:return, v} -> v
    end
  end

  @spec draw(list(list(integer())), integer()) :: nil
  def draw(b, score) do
    try do
      IO.puts("Score: " <> to_string(score))
      # y :: integer()
      y = 0
      _ = y

      t6 = fn t6, y ->
        try do
          if y < @size do
            IO.puts("+----+----+----+----+")
            # line :: String.t()
            line = "|"
            _ = line
            # x :: integer()
            x = 0
            _ = x

            t7 = fn t7, line, x ->
              try do
                if x < @size do
                  # v :: integer()
                  v = Enum.at(Enum.at(b, y), x)
                  _ = v

                  if v == 0 do
                    line = line <> "    |"
                  else
                    line = (line <> pad(v)) <> "|"
                  end

                  x = x + 1
                  t7.(t7, line, x)
                else
                  {:ok, line, x}
                end
              catch
                :break ->
                  {:ok, line, x}
              end
            end

            {_, line, x} = t7.(t7, line, x)
            _ = line
            _ = x
            IO.puts(line)
            y = y + 1
            t6.(t6, y)
          else
            {:ok, y}
          end
        catch
          :break ->
            {:ok, y}
        end
      end

      {_, y} = t6.(t6, y)
      _ = y
      IO.puts("+----+----+----+----+")
      IO.puts("W=Up S=Down A=Left D=Right Q=Quit")
    catch
      {:return, v} -> v
    end
  end

  @spec reverseRow(list(integer())) :: list(integer())
  def reverseRow(r) do
    try do
      # out :: list(integer())
      out = []
      _ = out
      # i :: integer()
      i = length(r) - 1
      _ = i

      t8 = fn t8, i, out ->
        try do
          if i >= 0 do
            out = out ++ [Enum.at(r, i)]
            i = i - 1
            t8.(t8, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t8.(t8, i, out)
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec slideLeft(list(integer())) :: map()
  def slideLeft(row) do
    try do
      # xs :: list(integer())
      xs = []
      _ = xs
      # i :: integer()
      i = 0
      _ = i

      t9 = fn t9, i, xs ->
        try do
          if i < length(row) do
            if Enum.at(row, i) != 0 do
              xs = xs ++ [Enum.at(row, i)]
            end

            i = i + 1
            t9.(t9, i, xs)
          else
            {:ok, i, xs}
          end
        catch
          :break ->
            {:ok, i, xs}
        end
      end

      {_, i, xs} = t9.(t9, i, xs)
      _ = i
      _ = xs
      # res :: list(integer())
      res = []
      _ = res
      # gain :: integer()
      gain = 0
      _ = gain
      i = 0

      t10 = fn t10, gain, i, res ->
        try do
          if i < length(xs) do
            if i + 1 < length(xs) && Enum.at(xs, i) == Enum.at(xs, i + 1) do
              v = Enum.at(xs, i) * 2
              gain = gain + v
              res = res ++ [v]
              i = i + 2
            else
              res = res ++ [Enum.at(xs, i)]
              i = i + 1
            end

            t10.(t10, gain, i, res)
          else
            {:ok, gain, i, res}
          end
        catch
          :break ->
            {:ok, gain, i, res}
        end
      end

      {_, gain, i, res} = t10.(t10, gain, i, res)
      _ = gain
      _ = i
      _ = res

      t11 = fn t11, res ->
        try do
          if length(res) < @size do
            res = res ++ [0]
            t11.(t11, res)
          else
            {:ok, res}
          end
        catch
          :break ->
            {:ok, res}
        end
      end

      {_, res} = t11.(t11, res)
      _ = res
      throw({:return, %{"row" => res, "gain" => gain}})
    catch
      {:return, v} -> v
    end
  end

  @spec moveLeft(list(list(integer())), integer()) :: map()
  def moveLeft(b, score) do
    try do
      # moved :: boolean()
      moved = false
      _ = moved
      # y :: integer()
      y = 0
      _ = y

      t12 = fn t12, b, moved, score, y ->
        try do
          if y < @size do
            # r :: map()
            r = slideLeft(Enum.at(b, y))
            new = Map.get(r, "row")
            score = score + Map.get(r, "gain")
            # x :: integer()
            x = 0
            _ = x

            t13 = fn t13, b, moved, x ->
              try do
                if x < @size do
                  if Enum.at(Enum.at(b, y), x) != Enum.at(new, x) do
                    moved = true
                  end

                  b = List.update_at(b, y, fn it -> List.replace_at(it, x, Enum.at(new, x)) end)
                  x = x + 1
                  t13.(t13, b, moved, x)
                else
                  {:ok, b, moved, x}
                end
              catch
                :break ->
                  {:ok, b, moved, x}
              end
            end

            {_, b, moved, x} = t13.(t13, b, moved, x)
            _ = b
            _ = moved
            _ = x
            y = y + 1
            t12.(t12, b, moved, score, y)
          else
            {:ok, b, moved, score, y}
          end
        catch
          :break ->
            {:ok, b, moved, score, y}
        end
      end

      {_, b, moved, score, y} = t12.(t12, b, moved, score, y)
      _ = b
      _ = moved
      _ = score
      _ = y
      throw({:return, %{"board" => b, "score" => score, "moved" => moved}})
    catch
      {:return, v} -> v
    end
  end

  @spec moveRight(list(list(integer())), integer()) :: map()
  def moveRight(b, score) do
    try do
      # moved :: boolean()
      moved = false
      _ = moved
      # y :: integer()
      y = 0
      _ = y

      t14 = fn t14, b, moved, score, y ->
        try do
          if y < @size do
            # rev :: list(integer())
            rev = reverseRow(Enum.at(b, y))
            _ = rev
            # r :: map()
            r = slideLeft(rev)
            rev = Map.get(r, "row")
            score = score + Map.get(r, "gain")
            rev = reverseRow(rev)
            # x :: integer()
            x = 0
            _ = x

            t15 = fn t15, b, moved, x ->
              try do
                if x < @size do
                  if Enum.at(Enum.at(b, y), x) != Enum.at(rev, x) do
                    moved = true
                  end

                  b = List.update_at(b, y, fn it -> List.replace_at(it, x, Enum.at(rev, x)) end)
                  x = x + 1
                  t15.(t15, b, moved, x)
                else
                  {:ok, b, moved, x}
                end
              catch
                :break ->
                  {:ok, b, moved, x}
              end
            end

            {_, b, moved, x} = t15.(t15, b, moved, x)
            _ = b
            _ = moved
            _ = x
            y = y + 1
            t14.(t14, b, moved, score, y)
          else
            {:ok, b, moved, score, y}
          end
        catch
          :break ->
            {:ok, b, moved, score, y}
        end
      end

      {_, b, moved, score, y} = t14.(t14, b, moved, score, y)
      _ = b
      _ = moved
      _ = score
      _ = y
      throw({:return, %{"board" => b, "score" => score, "moved" => moved}})
    catch
      {:return, v} -> v
    end
  end

  @spec getCol(list(list(integer())), integer()) :: list(integer())
  def getCol(b, x) do
    try do
      # col :: list(integer())
      col = []
      _ = col
      # y :: integer()
      y = 0
      _ = y

      t16 = fn t16, col, y ->
        try do
          if y < @size do
            col = col ++ [Enum.at(Enum.at(b, y), x)]
            y = y + 1
            t16.(t16, col, y)
          else
            {:ok, col, y}
          end
        catch
          :break ->
            {:ok, col, y}
        end
      end

      {_, col, y} = t16.(t16, col, y)
      _ = col
      _ = y
      throw({:return, col})
    catch
      {:return, v} -> v
    end
  end

  @spec setCol(list(list(integer())), integer(), list(integer())) :: nil
  def setCol(b, x, col) do
    try do
      # y :: integer()
      y = 0
      _ = y

      t17 = fn t17, b, y ->
        try do
          if y < @size do
            b = List.update_at(b, y, fn it -> List.replace_at(it, x, Enum.at(col, y)) end)
            y = y + 1
            t17.(t17, b, y)
          else
            {:ok, b, y}
          end
        catch
          :break ->
            {:ok, b, y}
        end
      end

      {_, b, y} = t17.(t17, b, y)
      _ = b
      _ = y
    catch
      {:return, v} -> v
    end
  end

  @spec moveUp(list(list(integer())), integer()) :: map()
  def moveUp(b, score) do
    try do
      # moved :: boolean()
      moved = false
      _ = moved
      # x :: integer()
      x = 0
      _ = x

      t18 = fn t18, b, moved, score, x ->
        try do
          if x < @size do
            # col :: list(integer())
            col = getCol(b, x)
            _ = col
            # r :: map()
            r = slideLeft(col)
            new = Map.get(r, "row")
            score = score + Map.get(r, "gain")
            # y :: integer()
            y = 0
            _ = y

            t19 = fn t19, b, moved, y ->
              try do
                if y < @size do
                  if Enum.at(Enum.at(b, y), x) != Enum.at(new, y) do
                    moved = true
                  end

                  b = List.update_at(b, y, fn it -> List.replace_at(it, x, Enum.at(new, y)) end)
                  y = y + 1
                  t19.(t19, b, moved, y)
                else
                  {:ok, b, moved, y}
                end
              catch
                :break ->
                  {:ok, b, moved, y}
              end
            end

            {_, b, moved, y} = t19.(t19, b, moved, y)
            _ = b
            _ = moved
            _ = y
            x = x + 1
            t18.(t18, b, moved, score, x)
          else
            {:ok, b, moved, score, x}
          end
        catch
          :break ->
            {:ok, b, moved, score, x}
        end
      end

      {_, b, moved, score, x} = t18.(t18, b, moved, score, x)
      _ = b
      _ = moved
      _ = score
      _ = x
      throw({:return, %{"board" => b, "score" => score, "moved" => moved}})
    catch
      {:return, v} -> v
    end
  end

  @spec moveDown(list(list(integer())), integer()) :: map()
  def moveDown(b, score) do
    try do
      # moved :: boolean()
      moved = false
      _ = moved
      # x :: integer()
      x = 0
      _ = x

      t20 = fn t20, b, moved, score, x ->
        try do
          if x < @size do
            # col :: list(integer())
            col = reverseRow(getCol(b, x))
            _ = col
            # r :: map()
            r = slideLeft(col)
            col = Map.get(r, "row")
            score = score + Map.get(r, "gain")
            col = reverseRow(col)
            # y :: integer()
            y = 0
            _ = y

            t21 = fn t21, b, moved, y ->
              try do
                if y < @size do
                  if Enum.at(Enum.at(b, y), x) != Enum.at(col, y) do
                    moved = true
                  end

                  b = List.update_at(b, y, fn it -> List.replace_at(it, x, Enum.at(col, y)) end)
                  y = y + 1
                  t21.(t21, b, moved, y)
                else
                  {:ok, b, moved, y}
                end
              catch
                :break ->
                  {:ok, b, moved, y}
              end
            end

            {_, b, moved, y} = t21.(t21, b, moved, y)
            _ = b
            _ = moved
            _ = y
            x = x + 1
            t20.(t20, b, moved, score, x)
          else
            {:ok, b, moved, score, x}
          end
        catch
          :break ->
            {:ok, b, moved, score, x}
        end
      end

      {_, b, moved, score, x} = t20.(t20, b, moved, score, x)
      _ = b
      _ = moved
      _ = score
      _ = x
      throw({:return, %{"board" => b, "score" => score, "moved" => moved}})
    catch
      {:return, v} -> v
    end
  end

  @spec hasMoves(list(list(integer()))) :: boolean()
  def hasMoves(b) do
    try do
      # y :: integer()
      y = 0
      _ = y

      t22 = fn t22, y ->
        try do
          if y < @size do
            # x :: integer()
            x = 0
            _ = x

            t23 = fn t23, x ->
              try do
                if x < @size do
                  if Enum.at(Enum.at(b, y), x) == 0 do
                    throw({:return, true})
                  end

                  if x + 1 < @size && Enum.at(Enum.at(b, y), x) == Enum.at(Enum.at(b, y), x + 1) do
                    throw({:return, true})
                  end

                  if y + 1 < @size && Enum.at(Enum.at(b, y), x) == Enum.at(Enum.at(b, y + 1), x) do
                    throw({:return, true})
                  end

                  x = x + 1
                  t23.(t23, x)
                else
                  {:ok, x}
                end
              catch
                :break ->
                  {:ok, x}
              end
            end

            {_, x} = t23.(t23, x)
            _ = x
            y = y + 1
            t22.(t22, y)
          else
            {:ok, y}
          end
        catch
          :break ->
            {:ok, y}
        end
      end

      {_, y} = t22.(t22, y)
      _ = y
      throw({:return, false})
    catch
      {:return, v} -> v
    end
  end

  @spec has2048(list(list(integer()))) :: boolean()
  def has2048(b) do
    try do
      # y :: integer()
      y = 0
      _ = y

      t24 = fn t24, y ->
        try do
          if y < @size do
            # x :: integer()
            x = 0
            _ = x

            t25 = fn t25, x ->
              try do
                if x < @size do
                  if Enum.at(Enum.at(b, y), x) >= 2048 do
                    throw({:return, true})
                  end

                  x = x + 1
                  t25.(t25, x)
                else
                  {:ok, x}
                end
              catch
                :break ->
                  {:ok, x}
              end
            end

            {_, x} = t25.(t25, x)
            _ = x
            y = y + 1
            t24.(t24, y)
          else
            {:ok, y}
          end
        catch
          :break ->
            {:ok, y}
        end
      end

      {_, y} = t24.(t24, y)
      _ = y
      throw({:return, false})
    catch
      {:return, v} -> v
    end
  end

  def main do
    # board :: list(list(integer()))
    board = newBoard()
    _ = board
    # r :: map()
    r = spawnTile(board)
    _ = r
    board = Map.get(r, "board")
    # full :: any()
    full = Map.get(r, "full")
    _ = full
    r = spawnTile(board)
    board = Map.get(r, "board")
    full = Map.get(r, "full")
    # score :: integer()
    score = 0
    _ = score
    draw(board, score)

    t26 = fn t26, board, full, score ->
      try do
        if true do
          IO.puts("Move: ")
          cmd = _input()
          # moved :: boolean()
          moved = false
          _ = moved

          if cmd == "a" || cmd == "A" do
            m = moveLeft(board, score)
            board = Map.get(m, "board")
            score = Map.get(m, "score")
            moved = Map.get(m, "moved")
          end

          if cmd == "d" || cmd == "D" do
            m = moveRight(board, score)
            board = Map.get(m, "board")
            score = Map.get(m, "score")
            moved = Map.get(m, "moved")
          end

          if cmd == "w" || cmd == "W" do
            m = moveUp(board, score)
            board = Map.get(m, "board")
            score = Map.get(m, "score")
            moved = Map.get(m, "moved")
          end

          if cmd == "s" || cmd == "S" do
            m = moveDown(board, score)
            board = Map.get(m, "board")
            score = Map.get(m, "score")
            moved = Map.get(m, "moved")
          end

          if cmd == "q" || cmd == "Q" do
            throw(:break)
          end

          if moved do
            r2 = spawnTile(board)
            board = Map.get(r2, "board")
            full = Map.get(r2, "full")

            if full && !hasMoves(board) do
              draw(board, score)
              IO.puts("Game Over")
              throw(:break)
            end
          end

          draw(board, score)

          if has2048(board) do
            IO.puts("You win!")
            throw(:break)
          end

          if !hasMoves(board) do
            IO.puts("Game Over")
            throw(:break)
          end

          t26.(t26, board, full, score)
        else
          {:ok, board, full, score}
        end
      catch
        :break ->
          {:ok, board, full, score}
      end
    end

    {_, board, full, score} = t26.(t26, board, full, score)
    _ = board
    _ = full
    _ = score
  end

  defp _input() do
    case IO.gets("") do
      :eof -> ""
      other -> String.trim(other)
    end
  end

  defp _now() do
    System.os_time(:millisecond)
  end
end

Main.main()
