# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:49:08Z
defmodule Main do
	@SIZE 4
	@spec newBoard() :: list(list(integer()))
	def newBoard() do
		try do
			b = []
			_ = b
			y = 0
			_ = y
			t1 = fn t1, b, y ->
				try do
					if (y < @SIZE) do
						row = []
						_ = row
						x = 0
						_ = x
						t2 = fn t2, row, x ->
							try do
								if (x < @SIZE) do
									row = row ++ [0]
									x = (x + 1)
									t2.(t2, row, x)
								else
									{:ok, row, x}
								end
							catch :break ->
								{:ok, row, x}
							end
						end
						{_, row, x} = t2.(t2, row, x)
						_ = row
						_ = x
						b = b ++ [row]
						y = (y + 1)
						t1.(t1, b, y)
					else
						{:ok, b, y}
					end
				catch :break ->
					{:ok, b, y}
				end
			end
			{_, b, y} = t1.(t1, b, y)
			_ = b
			_ = y
			throw {:return, b}
		catch {:return, v} -> v end
	end
	
	@spec spawnTile(list(list(integer()))) :: map()
	def spawnTile(b) do
		try do
			empty = []
			_ = empty
			y = 0
			_ = y
			t3 = fn t3, empty, y ->
				try do
					if (y < @SIZE) do
						x = 0
						_ = x
						t4 = fn t4, empty, x ->
							try do
								if (x < @SIZE) do
									if (Enum.at((Enum.at((b), y)), x) == 0) do
										empty = empty ++ [[x, y]]
									end
									x = (x + 1)
									t4.(t4, empty, x)
								else
									{:ok, empty, x}
								end
							catch :break ->
								{:ok, empty, x}
							end
						end
						{_, empty, x} = t4.(t4, empty, x)
						_ = empty
						_ = x
						y = (y + 1)
						t3.(t3, empty, y)
					else
						{:ok, empty, y}
					end
				catch :break ->
					{:ok, empty, y}
				end
			end
			{_, empty, y} = t3.(t3, empty, y)
			_ = empty
			_ = y
			if (length(empty) == 0) do
				throw {:return, %{"board" => b, "full" => true}}
			end
			idx = rem(_now(), length(empty))
			_ = idx
			cell = Enum.at((empty), idx)
			val = 4
			_ = val
			if (rem(_now(), 10) < 9) do
				val = 2
			end
			b = Map.put(b, Enum.at((cell), 1), val)
			throw {:return, %{"board" => b, "full" => (length(empty) == 1)}}
		catch {:return, v} -> v end
	end
	
	@spec pad(integer()) :: String.t()
	def pad(n) do
		try do
			s = to_string(n)
			_ = s
			# pad :: (integer() -> String.t())
			pad = (4 - length(s))
			_ = pad
			i = 0
			_ = i
			out = ""
			_ = out
			t5 = fn t5, i, out ->
				try do
					if (i < pad) do
						out = (out <> " ")
						i = (i + 1)
						t5.(t5, i, out)
					else
						{:ok, i, out}
					end
				catch :break ->
					{:ok, i, out}
				end
			end
			{_, i, out} = t5.(t5, i, out)
			_ = i
			_ = out
			throw {:return, (out + s)}
		catch {:return, v} -> v end
	end
	
	@spec draw(list(list(integer())), integer()) :: nil
	def draw(b, score) do
		try do
			IO.puts(("Score: " <> to_string(score)))
			y = 0
			_ = y
			t6 = fn t6, y ->
				try do
					if (y < @SIZE) do
						IO.puts("+----+----+----+----+")
						line = "|"
						_ = line
						x = 0
						_ = x
						t7 = fn t7, line, x ->
							try do
								if (x < @SIZE) do
									v = Enum.at((Enum.at((b), y)), x)
									_ = v
									if (v == 0) do
										line = (line <> "    |")
									else
										line = ((line + pad(v)) <> "|")
									end
									x = (x + 1)
									t7.(t7, line, x)
								else
									{:ok, line, x}
								end
							catch :break ->
								{:ok, line, x}
							end
						end
						{_, line, x} = t7.(t7, line, x)
						_ = line
						_ = x
						IO.inspect(line)
						y = (y + 1)
						t6.(t6, y)
					else
						{:ok, y}
					end
				catch :break ->
					{:ok, y}
				end
			end
			{_, y} = t6.(t6, y)
			_ = y
			IO.puts("+----+----+----+----+")
			IO.puts("W=Up S=Down A=Left D=Right Q=Quit")
		catch {:return, v} -> v end
	end
	
	@spec reverseRow(list(integer())) :: list(integer())
	def reverseRow(r) do
		try do
			out = []
			_ = out
			i = (map_size(r) - 1)
			_ = i
			t8 = fn t8, i, out ->
				try do
					if (i >= 0) do
						out = out ++ [Map.get(r, i)]
						i = (i - 1)
						t8.(t8, i, out)
					else
						{:ok, i, out}
					end
				catch :break ->
					{:ok, i, out}
				end
			end
			{_, i, out} = t8.(t8, i, out)
			_ = i
			_ = out
			throw {:return, out}
		catch {:return, v} -> v end
	end
	
	@spec slideLeft(list(integer())) :: map()
	def slideLeft(row) do
		try do
			xs = []
			_ = xs
			i = 0
			_ = i
			t9 = fn t9, i, xs ->
				try do
					if (i < length(row)) do
						if (Enum.at((row), i) != 0) do
							xs = xs ++ [Enum.at((row), i)]
						end
						i = (i + 1)
						t9.(t9, i, xs)
					else
						{:ok, i, xs}
					end
				catch :break ->
					{:ok, i, xs}
				end
			end
			{_, i, xs} = t9.(t9, i, xs)
			_ = i
			_ = xs
			res = []
			_ = res
			gain = 0
			_ = gain
			i = 0
			t10 = fn t10, gain, i, res ->
				try do
					if (i < length(xs)) do
						if (((i + 1) < length(xs)) && (Enum.at((xs), i) == Enum.at((xs), (i + 1)))) do
							v = (Enum.at((xs), i) * 2)
							gain = (gain + v)
							res = res ++ [v]
							i = (i + 2)
						else
							res = res ++ [Enum.at((xs), i)]
							i = (i + 1)
						end
						t10.(t10, gain, i, res)
					else
						{:ok, gain, i, res}
					end
				catch :break ->
					{:ok, gain, i, res}
				end
			end
			{_, gain, i, res} = t10.(t10, gain, i, res)
			_ = gain
			_ = i
			_ = res
			t11 = fn t11, res ->
				try do
					if (length(res) < @SIZE) do
						res = res ++ [0]
						t11.(t11, res)
					else
						{:ok, res}
					end
				catch :break ->
					{:ok, res}
				end
			end
			{_, res} = t11.(t11, res)
			_ = res
			throw {:return, %{"row" => res, "gain" => gain}}
		catch {:return, v} -> v end
	end
	
	@spec moveLeft(list(list(integer())), integer()) :: map()
	def moveLeft(b, score) do
		try do
			moved = false
			_ = moved
			y = 0
			_ = y
			t12 = fn t12, b, moved, score, y ->
				try do
					if (y < @SIZE) do
						# r :: map()
						r = slideLeft(Enum.at((b), y))
						new = Map.get(r, "row")
						score = (score + Map.get(r, "gain"))
						x = 0
						_ = x
						t13 = fn t13, b, moved, x ->
							try do
								if (x < @SIZE) do
									if (Enum.at((Enum.at((b), y)), x) != Enum.at((new), x)) do
										moved = true
									end
									b = Map.put(b, y, Enum.at((new), x))
									x = (x + 1)
									t13.(t13, b, moved, x)
								else
									{:ok, b, moved, x}
								end
							catch :break ->
								{:ok, b, moved, x}
							end
						end
						{_, b, moved, x} = t13.(t13, b, moved, x)
						_ = b
						_ = moved
						_ = x
						y = (y + 1)
						t12.(t12, b, moved, score, y)
					else
						{:ok, b, moved, score, y}
					end
				catch :break ->
					{:ok, b, moved, score, y}
				end
			end
			{_, b, moved, score, y} = t12.(t12, b, moved, score, y)
			_ = b
			_ = moved
			_ = score
			_ = y
			throw {:return, %{"board" => b, "score" => score, "moved" => moved}}
		catch {:return, v} -> v end
	end
	
	@spec moveRight(list(list(integer())), integer()) :: map()
	def moveRight(b, score) do
		try do
			moved = false
			_ = moved
			y = 0
			_ = y
			t14 = fn t14, b, moved, score, y ->
				try do
					if (y < @SIZE) do
						rev = reverseRow(Enum.at((b), y))
						_ = rev
						# r :: map()
						r = slideLeft(rev)
						rev = Map.get(r, "row")
						score = (score + Map.get(r, "gain"))
						rev = reverseRow(rev)
						x = 0
						_ = x
						t15 = fn t15, b, moved, x ->
							try do
								if (x < @SIZE) do
									if (Enum.at((Enum.at((b), y)), x) != Enum.at((rev), x)) do
										moved = true
									end
									b = Map.put(b, y, Enum.at((rev), x))
									x = (x + 1)
									t15.(t15, b, moved, x)
								else
									{:ok, b, moved, x}
								end
							catch :break ->
								{:ok, b, moved, x}
							end
						end
						{_, b, moved, x} = t15.(t15, b, moved, x)
						_ = b
						_ = moved
						_ = x
						y = (y + 1)
						t14.(t14, b, moved, score, y)
					else
						{:ok, b, moved, score, y}
					end
				catch :break ->
					{:ok, b, moved, score, y}
				end
			end
			{_, b, moved, score, y} = t14.(t14, b, moved, score, y)
			_ = b
			_ = moved
			_ = score
			_ = y
			throw {:return, %{"board" => b, "score" => score, "moved" => moved}}
		catch {:return, v} -> v end
	end
	
	@spec getCol(list(list(integer())), integer()) :: list(integer())
	def getCol(b, x) do
		try do
			col = []
			_ = col
			y = 0
			_ = y
			t16 = fn t16, col, y ->
				try do
					if (y < @SIZE) do
						col = col ++ [Enum.at((Enum.at((b), y)), x)]
						y = (y + 1)
						t16.(t16, col, y)
					else
						{:ok, col, y}
					end
				catch :break ->
					{:ok, col, y}
				end
			end
			{_, col, y} = t16.(t16, col, y)
			_ = col
			_ = y
			throw {:return, col}
		catch {:return, v} -> v end
	end
	
	@spec setCol(list(list(integer())), integer(), list(integer())) :: nil
	def setCol(b, x, col) do
		try do
			y = 0
			_ = y
			t17 = fn t17, b, y ->
				try do
					if (y < @SIZE) do
						b = Map.put(b, y, Enum.at((col), y))
						y = (y + 1)
						t17.(t17, b, y)
					else
						{:ok, b, y}
					end
				catch :break ->
					{:ok, b, y}
				end
			end
			{_, b, y} = t17.(t17, b, y)
			_ = b
			_ = y
		catch {:return, v} -> v end
	end
	
	@spec moveUp(list(list(integer())), integer()) :: map()
	def moveUp(b, score) do
		try do
			moved = false
			_ = moved
			x = 0
			_ = x
			t18 = fn t18, b, moved, score, x ->
				try do
					if (x < @SIZE) do
						col = getCol(b, x)
						_ = col
						# r :: map()
						r = slideLeft(col)
						new = Map.get(r, "row")
						score = (score + Map.get(r, "gain"))
						y = 0
						_ = y
						t19 = fn t19, b, moved, y ->
							try do
								if (y < @SIZE) do
									if (Enum.at((Enum.at((b), y)), x) != Enum.at((new), y)) do
										moved = true
									end
									b = Map.put(b, y, Enum.at((new), y))
									y = (y + 1)
									t19.(t19, b, moved, y)
								else
									{:ok, b, moved, y}
								end
							catch :break ->
								{:ok, b, moved, y}
							end
						end
						{_, b, moved, y} = t19.(t19, b, moved, y)
						_ = b
						_ = moved
						_ = y
						x = (x + 1)
						t18.(t18, b, moved, score, x)
					else
						{:ok, b, moved, score, x}
					end
				catch :break ->
					{:ok, b, moved, score, x}
				end
			end
			{_, b, moved, score, x} = t18.(t18, b, moved, score, x)
			_ = b
			_ = moved
			_ = score
			_ = x
			throw {:return, %{"board" => b, "score" => score, "moved" => moved}}
		catch {:return, v} -> v end
	end
	
	@spec moveDown(list(list(integer())), integer()) :: map()
	def moveDown(b, score) do
		try do
			moved = false
			_ = moved
			x = 0
			_ = x
			t20 = fn t20, b, moved, score, x ->
				try do
					if (x < @SIZE) do
						col = reverseRow(getCol(b, x))
						_ = col
						# r :: map()
						r = slideLeft(col)
						col = Map.get(r, "row")
						score = (score + Map.get(r, "gain"))
						col = reverseRow(col)
						y = 0
						_ = y
						t21 = fn t21, b, moved, y ->
							try do
								if (y < @SIZE) do
									if (Enum.at((Enum.at((b), y)), x) != Enum.at((col), y)) do
										moved = true
									end
									b = Map.put(b, y, Enum.at((col), y))
									y = (y + 1)
									t21.(t21, b, moved, y)
								else
									{:ok, b, moved, y}
								end
							catch :break ->
								{:ok, b, moved, y}
							end
						end
						{_, b, moved, y} = t21.(t21, b, moved, y)
						_ = b
						_ = moved
						_ = y
						x = (x + 1)
						t20.(t20, b, moved, score, x)
					else
						{:ok, b, moved, score, x}
					end
				catch :break ->
					{:ok, b, moved, score, x}
				end
			end
			{_, b, moved, score, x} = t20.(t20, b, moved, score, x)
			_ = b
			_ = moved
			_ = score
			_ = x
			throw {:return, %{"board" => b, "score" => score, "moved" => moved}}
		catch {:return, v} -> v end
	end
	
	@spec hasMoves(list(list(integer()))) :: boolean()
	def hasMoves(b) do
		try do
			y = 0
			_ = y
			t22 = fn t22, y ->
				try do
					if (y < @SIZE) do
						x = 0
						_ = x
						t23 = fn t23, x ->
							try do
								if (x < @SIZE) do
									if (Enum.at((Enum.at((b), y)), x) == 0) do
										throw {:return, true}
									end
									if (((x + 1) < @SIZE) && (Enum.at((Enum.at((b), y)), x) == Enum.at((Enum.at((b), y)), (x + 1)))) do
										throw {:return, true}
									end
									if (((y + 1) < @SIZE) && (Enum.at((Enum.at((b), y)), x) == Enum.at((Enum.at((b), (y + 1))), x))) do
										throw {:return, true}
									end
									x = (x + 1)
									t23.(t23, x)
								else
									{:ok, x}
								end
							catch :break ->
								{:ok, x}
							end
						end
						{_, x} = t23.(t23, x)
						_ = x
						y = (y + 1)
						t22.(t22, y)
					else
						{:ok, y}
					end
				catch :break ->
					{:ok, y}
				end
			end
			{_, y} = t22.(t22, y)
			_ = y
			throw {:return, false}
		catch {:return, v} -> v end
	end
	
	@spec has2048(list(list(integer()))) :: boolean()
	def has2048(b) do
		try do
			y = 0
			_ = y
			t24 = fn t24, y ->
				try do
					if (y < @SIZE) do
						x = 0
						_ = x
						t25 = fn t25, x ->
							try do
								if (x < @SIZE) do
									if (Enum.at((Enum.at((b), y)), x) >= 2048) do
										throw {:return, true}
									end
									x = (x + 1)
									t25.(t25, x)
								else
									{:ok, x}
								end
							catch :break ->
								{:ok, x}
							end
						end
						{_, x} = t25.(t25, x)
						_ = x
						y = (y + 1)
						t24.(t24, y)
					else
						{:ok, y}
					end
				catch :break ->
					{:ok, y}
				end
			end
			{_, y} = t24.(t24, y)
			_ = y
			throw {:return, false}
		catch {:return, v} -> v end
	end
	
	def main do
		# board :: list(list(integer()))
		board = newBoard()
		_ = board
		# r :: map()
		r = spawnTile(board)
		_ = r
		board = Map.get(r, "board")
		# full :: any()
		full = Map.get(r, "full")
		_ = full
		r = spawnTile(board)
		board = Map.get(r, "board")
		full = Map.get(r, "full")
		# score :: integer()
		score = 0
		_ = score
		draw(board, score)
		t26 = fn t26, board, full, score ->
			try do
				if true do
					IO.puts("Move: ")
					cmd = _input()
					moved = false
					_ = moved
					if ((cmd == "a") || (cmd == "A")) do
						m = moveLeft(board, score)
						board = Enum.at((m), "board")
						score = Enum.at((m), "score")
						moved = Enum.at((m), "moved")
					end
					if ((cmd == "d") || (cmd == "D")) do
						m = moveRight(board, score)
						board = Enum.at((m), "board")
						score = Enum.at((m), "score")
						moved = Enum.at((m), "moved")
					end
					if ((cmd == "w") || (cmd == "W")) do
						m = moveUp(board, score)
						board = Enum.at((m), "board")
						score = Enum.at((m), "score")
						moved = Enum.at((m), "moved")
					end
					if ((cmd == "s") || (cmd == "S")) do
						m = moveDown(board, score)
						board = Enum.at((m), "board")
						score = Enum.at((m), "score")
						moved = Enum.at((m), "moved")
					end
					if ((cmd == "q") || (cmd == "Q")) do
						throw :break
					end
					if moved do
						r2 = spawnTile(board)
						board = Enum.at((r2), "board")
						full = Enum.at((r2), "full")
						if (full && !hasMoves(board)) do
							draw(board, score)
							IO.puts("Game Over")
							throw :break
						end
					end
					draw(board, score)
					if has2048(board) do
						IO.puts("You win!")
						throw :break
					end
					if !hasMoves(board) do
						IO.puts("Game Over")
						throw :break
					end
					t26.(t26, board, full, score)
				else
					{:ok, board, full, score}
				end
			catch :break ->
				{:ok, board, full, score}
			end
		end
		{_, board, full, score} = t26.(t26, board, full, score)
		_ = board
		_ = full
		_ = score
	end
	defp _input() do
  String.trim(IO.gets(""))
end

	defp _now() do
  System.os_time(:millisecond)
end

	end
Main.main()
