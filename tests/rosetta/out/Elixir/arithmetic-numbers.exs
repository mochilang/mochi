# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:45:15Z
defmodule Main do
  @spec sieve(integer()) :: list(integer())
  def sieve(limit) do
    try do
      spf = []
      _ = spf
      i = 0
      _ = i

      t1 = fn t1, i, spf ->
        try do
          if i <= limit do
            spf = spf ++ [0]
            i = i + 1
            t1.(t1, i, spf)
          else
            {:ok, i, spf}
          end
        catch
          :break ->
            {:ok, i, spf}
        end
      end

      {_, i, spf} = t1.(t1, i, spf)
      _ = i
      _ = spf
      i = 2

      t2 = fn t2, i, spf ->
        try do
          if i <= limit do
            if Enum.at(spf, i) == 0 do
              spf = Map.put(spf, i, i)

              if i * i <= limit do
                j = i * i
                _ = j

                t3 = fn t3, j, spf ->
                  try do
                    if j <= limit do
                      if Enum.at(spf, j) == 0 do
                        spf = Map.put(spf, j, i)
                      end

                      j = j + i
                      t3.(t3, j, spf)
                    else
                      {:ok, j, spf}
                    end
                  catch
                    :break ->
                      {:ok, j, spf}
                  end
                end

                {_, j, spf} = t3.(t3, j, spf)
                _ = j
                _ = spf
              end
            end

            i = i + 1
            t2.(t2, i, spf)
          else
            {:ok, i, spf}
          end
        catch
          :break ->
            {:ok, i, spf}
        end
      end

      {_, i, spf} = t2.(t2, i, spf)
      _ = i
      _ = spf
      throw({:return, spf})
    catch
      {:return, v} -> v
    end
  end

  @spec primesFrom(list(integer()), integer()) :: list(integer())
  def primesFrom(spf, limit) do
    try do
      primes = []
      _ = primes
      i = 3
      _ = i

      t4 = fn t4, i, primes ->
        try do
          if i <= limit do
            if Enum.at(spf, i) == i do
              primes = primes ++ [i]
            end

            i = i + 1
            t4.(t4, i, primes)
          else
            {:ok, i, primes}
          end
        catch
          :break ->
            {:ok, i, primes}
        end
      end

      {_, i, primes} = t4.(t4, i, primes)
      _ = i
      _ = primes
      throw({:return, primes})
    catch
      {:return, v} -> v
    end
  end

  @spec pad3(integer()) :: String.t()
  def pad3(n) do
    try do
      s = to_string(n)
      _ = s

      t5 = fn t5, s ->
        try do
          if length(s) < 3 do
            s = " " <> s
            t5.(t5, s)
          else
            {:ok, s}
          end
        catch
          :break ->
            {:ok, s}
        end
      end

      {_, s} = t5.(t5, s)
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec commatize(integer()) :: String.t()
  def commatize(n) do
    try do
      s = to_string(n)
      _ = s
      out = ""
      _ = out
      i = length(s) - 1
      _ = i
      c = 0
      _ = c

      t6 = fn t6, c, i, out ->
        try do
          if i >= 0 do
            out = _slice_string(s, i, i + 1) + out
            c = c + 1

            if rem(c, 3) == 0 && i > 0 do
              out = "," <> out
            end

            i = i - 1
            t6.(t6, c, i, out)
          else
            {:ok, c, i, out}
          end
        catch
          :break ->
            {:ok, c, i, out}
        end
      end

      {_, c, i, out} = t6.(t6, c, i, out)
      _ = c
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec primeCount(list(integer()), integer(), list(integer())) :: integer()
  def primeCount(primes, last, spf) do
    try do
      lo = 0
      _ = lo
      hi = length(primes)
      _ = hi

      t7 = fn t7, hi, lo ->
        try do
          if lo < hi do
            mid = String.to_integer((lo + hi) / 2)
            _ = mid

            if Enum.at(primes, mid) < last do
              lo = mid + 1
            else
              hi = mid
            end

            t7.(t7, hi, lo)
          else
            {:ok, hi, lo}
          end
        catch
          :break ->
            {:ok, hi, lo}
        end
      end

      {_, hi, lo} = t7.(t7, hi, lo)
      _ = hi
      _ = lo
      # count :: (any() -> integer())
      count = lo + 1
      _ = count

      if Enum.at(spf, last) != last do
        count = count - 1
      end

      throw({:return, count})
    catch
      {:return, v} -> v
    end
  end

  @spec arithmeticNumbers(integer(), list(integer())) :: list(integer())
  def arithmeticNumbers(limit, spf) do
    try do
      arr = [1]
      _ = arr
      n = 3
      _ = n

      t8 = fn t8, arr, n ->
        try do
          if length(arr) < limit do
            if Enum.at(spf, n) == n do
              arr = arr ++ [n]
            else
              x = n
              _ = x
              sigma = 1
              _ = sigma
              tau = 1
              _ = tau

              t9 = fn t9, sigma, tau, x ->
                try do
                  if x > 1 do
                    p = Enum.at(spf, x)
                    _ = p

                    if p == 0 do
                      p = x
                    end

                    cnt = 0
                    _ = cnt
                    power = p
                    _ = power
                    # sum :: (any() -> float())
                    sum = 1
                    _ = sum

                    t10 = fn t10, cnt, power, sum, x ->
                      try do
                        if rem(x, p) == 0 do
                          x = x / p
                          cnt = cnt + 1
                          sum = sum + power
                          power = power * p
                          t10.(t10, cnt, power, sum, x)
                        else
                          {:ok, cnt, power, sum, x}
                        end
                      catch
                        :break ->
                          {:ok, cnt, power, sum, x}
                      end
                    end

                    {_, cnt, power, sum, x} = t10.(t10, cnt, power, sum, x)
                    _ = cnt
                    _ = power
                    _ = sum
                    _ = x
                    sigma = sigma * sum
                    tau = tau * (cnt + 1)
                    t9.(t9, sigma, tau, x)
                  else
                    {:ok, sigma, tau, x}
                  end
                catch
                  :break ->
                    {:ok, sigma, tau, x}
                end
              end

              {_, sigma, tau, x} = t9.(t9, sigma, tau, x)
              _ = sigma
              _ = tau
              _ = x

              if rem(sigma, tau) == 0 do
                arr = arr ++ [n]
              end
            end

            n = n + 1
            t8.(t8, arr, n)
          else
            {:ok, arr, n}
          end
        catch
          :break ->
            {:ok, arr, n}
        end
      end

      {_, arr, n} = t8.(t8, arr, n)
      _ = arr
      _ = n
      throw({:return, arr})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      limit = 1_228_663
      spf = sieve(limit)
      primes = primesFrom(spf, limit)
      arr = arithmeticNumbers(1_000_000, spf)
      IO.puts("The first 100 arithmetic numbers are:")
      i = 0
      _ = i

      t11 = fn t11, i ->
        try do
          if i < 100 do
            line = ""
            _ = line
            j = 0
            _ = j

            t12 = fn t12, j, line ->
              try do
                if j < 10 do
                  line = line + pad3(Enum.at(arr, i + j))

                  if j < 9 do
                    line = line <> " "
                  end

                  j = j + 1
                  t12.(t12, j, line)
                else
                  {:ok, j, line}
                end
              catch
                :break ->
                  {:ok, j, line}
              end
            end

            {_, j, line} = t12.(t12, j, line)
            _ = j
            _ = line
            IO.inspect(line)
            i = i + 10
            t11.(t11, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t11.(t11, i)
      _ = i

      for x <- [1000, 10000, 100_000, 1_000_000] do
        last = Enum.at(arr, x - 1)
        lastc = commatize(last)
        IO.inspect((("\nThe " <> commatize(x)) <> "th arithmetic number is: ") <> lastc)
        pc = primeCount(primes, last, spf)
        comp = x - pc - 1

        IO.inspect(
          ((("The count of such numbers <= " <> lastc) <> " which are composite is ") <>
             commatize(comp)) <> "."
        )
      end
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
