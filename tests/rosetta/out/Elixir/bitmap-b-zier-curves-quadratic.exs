# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:38Z
defmodule Pixel do
  @type t :: %__MODULE__{r: integer(), g: integer(), b: integer()}
  defstruct r: nil, g: nil, b: nil
end

defmodule Main do
  @b2Seg 20
  @spec pixelFromRgb(integer()) :: Pixel
  def pixelFromRgb(rgb) do
    try do
      r = String.to_integer(rem(rgb / 65536, 256))
      g = String.to_integer(rem(rgb / 256, 256))
      # b :: map()
      b = String.to_integer(rem(rgb, 256))
      throw({:return, %Pixel{r: r, g: g, b: b}})
    catch
      {:return, v} -> v
    end
  end

  @spec newBitmap(integer(), integer()) :: map()
  def newBitmap(cols, rows) do
    try do
      d = []
      _ = d
      y = 0
      _ = y

      t1 = fn t1, d, y ->
        try do
          if y < rows do
            row = []
            _ = row
            x = 0
            _ = x

            t2 = fn t2, row, x ->
              try do
                if x < cols do
                  row = row ++ [%Pixel{r: 0, g: 0, b: 0}]
                  x = x + 1
                  t2.(t2, row, x)
                else
                  {:ok, row, x}
                end
              catch
                :break ->
                  {:ok, row, x}
              end
            end

            {_, row, x} = t2.(t2, row, x)
            _ = row
            _ = x
            d = d ++ [row]
            y = y + 1
            t1.(t1, d, y)
          else
            {:ok, d, y}
          end
        catch
          :break ->
            {:ok, d, y}
        end
      end

      {_, d, y} = t1.(t1, d, y)
      _ = d
      _ = y
      throw({:return, %{"cols" => cols, "rows" => rows, "data" => d}})
    catch
      {:return, v} -> v
    end
  end

  @spec setPx(map(), integer(), integer(), Pixel) :: nil
  def setPx(b, x, y, p) do
    try do
      cols = String.to_integer(Map.get(b, "cols"))
      rows = String.to_integer(Map.get(b, "rows"))

      if x >= 0 && x < cols && y >= 0 && y < rows do
        b =
          Map.update!(b, "data", fn it -> Map.update!(it, y, fn it -> Map.put(it, x, p) end) end)
      end
    catch
      {:return, v} -> v
    end
  end

  @spec fill(map(), Pixel) :: nil
  def fill(b, p) do
    try do
      cols = String.to_integer(Map.get(b, "cols"))
      rows = String.to_integer(Map.get(b, "rows"))
      y = 0
      _ = y

      t3 = fn t3, b, y ->
        try do
          if y < rows do
            x = 0
            _ = x

            t4 = fn t4, b, x ->
              try do
                if x < cols do
                  b =
                    Map.update!(b, "data", fn it ->
                      Map.update!(it, y, fn it -> Map.put(it, x, p) end)
                    end)

                  x = x + 1
                  t4.(t4, b, x)
                else
                  {:ok, b, x}
                end
              catch
                :break ->
                  {:ok, b, x}
              end
            end

            {_, b, x} = t4.(t4, b, x)
            _ = b
            _ = x
            y = y + 1
            t3.(t3, b, y)
          else
            {:ok, b, y}
          end
        catch
          :break ->
            {:ok, b, y}
        end
      end

      {_, b, y} = t3.(t3, b, y)
      _ = b
      _ = y
    catch
      {:return, v} -> v
    end
  end

  @spec fillRgb(map(), integer()) :: nil
  def fillRgb(b, rgb) do
    try do
      fill(b, pixelFromRgb(rgb))
    catch
      {:return, v} -> v
    end
  end

  @spec line(map(), integer(), integer(), integer(), integer(), Pixel) :: nil
  def line(b, x0, y0, x1, y1, p) do
    try do
      dx = x1 - x0
      _ = dx

      if dx < 0 do
        dx = -dx
      end

      dy = y1 - y0
      _ = dy

      if dy < 0 do
        dy = -dy
      end

      sx = -1
      _ = sx

      if x0 < x1 do
        sx = 1
      end

      sy = -1
      _ = sy

      if y0 < y1 do
        sy = 1
      end

      err = dx - dy
      _ = err

      t5 = fn t5, err, x0, y0 ->
        try do
          if true do
            setPx(b, x0, y0, p)

            if x0 == x1 && y0 == y1 do
              throw(:break)
            end

            e2 = 2 * err

            if e2 > 0 - dy do
              err = err - dy
              x0 = x0 + sx
            end

            if e2 < dx do
              err = err + dx
              y0 = y0 + sy
            end

            t5.(t5, err, x0, y0)
          else
            {:ok, err, x0, y0}
          end
        catch
          :break ->
            {:ok, err, x0, y0}
        end
      end

      {_, err, x0, y0} = t5.(t5, err, x0, y0)
      _ = err
      _ = x0
      _ = y0
    catch
      {:return, v} -> v
    end
  end

  @spec bezier2(map(), integer(), integer(), integer(), integer(), integer(), integer(), Pixel) ::
          nil
  def bezier2(b, x1, y1, x2, y2, x3, y3, p) do
    try do
      px = []
      _ = px
      py = []
      _ = py
      i = 0
      _ = i

      t6 = fn t6, i, px, py ->
        try do
          if i <= @b2Seg do
            px = px ++ [0]
            py = py ++ [0]
            i = i + 1
            t6.(t6, i, px, py)
          else
            {:ok, i, px, py}
          end
        catch
          :break ->
            {:ok, i, px, py}
        end
      end

      {_, i, px, py} = t6.(t6, i, px, py)
      _ = i
      _ = px
      _ = py
      fx1 = String.to_float(x1)
      fy1 = String.to_float(y1)
      fx2 = String.to_float(x2)
      fy2 = String.to_float(y2)
      fx3 = String.to_float(x3)
      fy3 = String.to_float(y3)
      i = 0

      t7 = fn t7, i, px, py ->
        try do
          if i <= @b2Seg do
            c = String.to_float(i) / String.to_float(@b2Seg)
            a = 1 - c
            _ = a
            a2 = a * a
            _ = a2
            b2 = 2 * c * a
            _ = b2
            c2 = c * c
            _ = c2
            px = Map.put(px, i, String.to_integer(a2 * fx1 + b2 * fx2 + c2 * fx3))
            py = Map.put(py, i, String.to_integer(a2 * fy1 + b2 * fy2 + c2 * fy3))
            i = i + 1
            t7.(t7, i, px, py)
          else
            {:ok, i, px, py}
          end
        catch
          :break ->
            {:ok, i, px, py}
        end
      end

      {_, i, px, py} = t7.(t7, i, px, py)
      _ = i
      _ = px
      _ = py
      x0 = Enum.at(px, 0)
      _ = x0
      y0 = Enum.at(py, 0)
      _ = y0
      i = 1

      t8 = fn t8, i, x0, y0 ->
        try do
          if i <= @b2Seg do
            x = Enum.at(px, i)
            y = Enum.at(py, i)
            line(b, x0, y0, x, y, p)
            x0 = x
            y0 = y
            i = i + 1
            t8.(t8, i, x0, y0)
          else
            {:ok, i, x0, y0}
          end
        catch
          :break ->
            {:ok, i, x0, y0}
        end
      end

      {_, i, x0, y0} = t8.(t8, i, x0, y0)
      _ = i
      _ = x0
      _ = y0
    catch
      {:return, v} -> v
    end
  end

  def main do
    # b :: map()
    b = newBitmap(400, 300)
    _ = b
    fillRgb(b, 14_614_575)
    bezier2(b, 20, 150, 500, -100, 300, 280, pixelFromRgb(4_165_615))
  end
end

Main.main()
