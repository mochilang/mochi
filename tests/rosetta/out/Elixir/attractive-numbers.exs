# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:45:48Z
defmodule Main do
  @spec isPrime(integer()) :: boolean()
  def isPrime(n) do
    try do
      if n < 2 do
        throw({:return, false})
      end

      if rem(n, 2) == 0 do
        throw({:return, n == 2})
      end

      if rem(n, 3) == 0 do
        throw({:return, n == 3})
      end

      d = 5
      _ = d

      t1 = fn t1, d ->
        try do
          if d * d <= n do
            if rem(n, d) == 0 do
              throw({:return, false})
            end

            d = d + 2

            if rem(n, d) == 0 do
              throw({:return, false})
            end

            d = d + 4
            t1.(t1, d)
          else
            {:ok, d}
          end
        catch
          :break ->
            {:ok, d}
        end
      end

      {_, d} = t1.(t1, d)
      _ = d
      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec countPrimeFactors(integer()) :: integer()
  def countPrimeFactors(n) do
    try do
      if n == 1 do
        throw({:return, 0})
      end

      if isPrime(n) do
        throw({:return, 1})
      end

      # count :: (any() -> integer())
      count = 0
      _ = count
      f = 2
      _ = f

      t2 = fn t2, count, f, n ->
        try do
          if true do
            if rem(n, f) == 0 do
              count = count + 1
              n = n / f

              if n == 1 do
                throw({:return, count})
              end

              if isPrime(n) do
                f = n
              end
            else
              if f >= 3 do
                f = f + 2
              else
                f = 3
              end
            end

            t2.(t2, count, f, n)
          else
            {:ok, count, f, n}
          end
        catch
          :break ->
            {:ok, count, f, n}
        end
      end

      {_, count, f, n} = t2.(t2, count, f, n)
      _ = count
      _ = f
      _ = n
      throw({:return, count})
    catch
      {:return, v} -> v
    end
  end

  @spec pad4(integer()) :: String.t()
  def pad4(n) do
    try do
      s = to_string(n)
      _ = s

      t3 = fn t3, s ->
        try do
          if length(s) < 4 do
            s = " " <> s
            t3.(t3, s)
          else
            {:ok, s}
          end
        catch
          :break ->
            {:ok, s}
        end
      end

      {_, s} = t3.(t3, s)
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      # max :: (any() -> any())
      max = 120
      IO.puts(("The attractive numbers up to and including " <> to_string(max)) <> " are:")
      # count :: (any() -> integer())
      count = 0
      _ = count
      line = ""
      _ = line
      lineCount = 0
      _ = lineCount
      i = 1
      _ = i

      t4 = fn t4, count, i, line, lineCount ->
        try do
          if i <= max do
            c = countPrimeFactors(i)

            if isPrime(c) do
              line = line + pad4(i)
              count = count + 1
              lineCount = lineCount + 1

              if lineCount == 20 do
                IO.inspect(line)
                line = ""
                lineCount = 0
              end
            end

            i = i + 1
            t4.(t4, count, i, line, lineCount)
          else
            {:ok, count, i, line, lineCount}
          end
        catch
          :break ->
            {:ok, count, i, line, lineCount}
        end
      end

      {_, count, i, line, lineCount} = t4.(t4, count, i, line, lineCount)
      _ = count
      _ = i
      _ = line
      _ = lineCount

      if lineCount > 0 do
        IO.inspect(line)
      end
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end
end

Main.main()
