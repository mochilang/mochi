# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:17Z
defmodule Main do
  @spec floorf(float()) :: float()
  def floorf(x) do
    try do
      throw({:return, String.to_float(String.to_integer(x))})
    catch
      {:return, v} -> v
    end
  end

  @spec indexOf(String.t(), String.t()) :: integer()
  def indexOf(s, ch) do
    try do
      i = 0
      _ = i

      t1 = fn t1, i ->
        try do
          if i < length(s) do
            if _slice_string(s, i, i + 1) == ch do
              throw({:return, i})
            end

            i = i + 1
            t1.(t1, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t1.(t1, i)
      _ = i
      throw({:return, -1})
    catch
      {:return, v} -> v
    end
  end

  @spec fmtF3(float()) :: String.t()
  def fmtF3(x) do
    try do
      y = floorf(x * 1000 + 0.5) / 1000
      _ = y
      s = to_string(y)
      _ = s
      dot = indexOf(s, ".")
      _ = dot

      if dot == 0 - 1 do
        s = s <> ".000"
      else
        decs = length(s) - dot - 1
        _ = decs

        if decs > 3 do
          s = _slice_string(s, 0, dot + 4)
        else
          t2 = fn t2, decs, s ->
            try do
              if decs < 3 do
                s = s <> "0"
                decs = decs + 1
                t2.(t2, decs, s)
              else
                {:ok, decs, s}
              end
            catch
              :break ->
                {:ok, decs, s}
            end
          end

          {_, decs, s} = t2.(t2, decs, s)
          _ = decs
          _ = s
        end
      end

      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec padFloat3(float(), integer()) :: String.t()
  def padFloat3(x, width) do
    try do
      s = fmtF3(x)
      _ = s

      t3 = fn t3, s ->
        try do
          if length(s) < width do
            s = " " <> s
            t3.(t3, s)
          else
            {:ok, s}
          end
        catch
          :break ->
            {:ok, s}
        end
      end

      {_, s} = t3.(t3, s)
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec fib1000() :: list(float())
  def fib1000() do
    try do
      a = 0
      _ = a
      b = 1
      _ = b
      res = []
      _ = res
      i = 0
      _ = i

      t4 = fn t4, a, b, i, res ->
        try do
          if i < 1000 do
            res = res ++ [b]
            t = b
            _ = t
            b = b + a
            a = t
            i = i + 1
            t4.(t4, a, b, i, res)
          else
            {:ok, a, b, i, res}
          end
        catch
          :break ->
            {:ok, a, b, i, res}
        end
      end

      {_, a, b, i, res} = t4.(t4, a, b, i, res)
      _ = a
      _ = b
      _ = i
      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec leadingDigit(float()) :: integer()
  def leadingDigit(x) do
    try do
      if x < 0 do
        x = -x
      end

      t5 = fn t5, x ->
        try do
          if x >= 10 do
            x = x / 10
            t5.(t5, x)
          else
            {:ok, x}
          end
        catch
          :break ->
            {:ok, x}
        end
      end

      {_, x} = t5.(t5, x)
      _ = x

      t6 = fn t6, x ->
        try do
          if x > 0 && x < 1 do
            x = x * 10
            t6.(t6, x)
          else
            {:ok, x}
          end
        catch
          :break ->
            {:ok, x}
        end
      end

      {_, x} = t6.(t6, x)
      _ = x
      throw({:return, String.to_integer(x)})
    catch
      {:return, v} -> v
    end
  end

  @spec show(list(float()), String.t()) :: nil
  def show(nums, title) do
    try do
      counts = [0, 0, 0, 0, 0, 0, 0, 0, 0]
      _ = counts

      {counts} =
        Enum.reduce(_iter(nums), {counts}, fn n, {counts} ->
          d = leadingDigit(n)

          if d >= 1 && d <= 9 do
            counts = Map.put(counts, d - 1, Enum.at(counts, d - 1) + 1)
          end

          {counts}
        end)

      _ = counts
      preds = [0.301, 0.176, 0.125, 0.097, 0.079, 0.067, 0.058, 0.051, 0.046]
      total = length(nums)
      IO.inspect(title)
      IO.puts("Digit  Observed  Predicted")
      i = 0
      _ = i

      t7 = fn t7, i ->
        try do
          if i < 9 do
            obs = String.to_float(Enum.at(counts, i)) / String.to_float(total)

            line =
              (((("  " <> to_string(i + 1)) <> "  ") <> padFloat3(obs, 9)) <> "  ") <>
                padFloat3(Enum.at(preds, i), 8)

            _ = line
            IO.inspect(line)
            i = i + 1
            t7.(t7, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t7.(t7, i)
      _ = i
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      show(fib1000(), "First 1000 Fibonacci numbers")
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _iter(v) do
    if is_map(v) do
      Map.keys(v)
    else
      v
    end
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
