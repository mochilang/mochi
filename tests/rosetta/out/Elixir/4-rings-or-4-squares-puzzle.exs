# Generated by Mochi compiler v0.10.26 on 2025-07-16T09:29:22Z
defmodule Main do
  @spec validComb(integer(), integer(), integer(), integer(), integer(), integer(), integer()) ::
          boolean()
  def validComb(a, b, c, d, e, f, g) do
    try do
      square1 = a + b
      square2 = b + c + d
      square3 = d + e + f
      square4 = f + g
      throw({:return, square1 == square2 && square2 == square3 && square3 == square4})
    catch
      {:return, v} -> v
    end
  end

  @spec isUnique(integer(), integer(), integer(), integer(), integer(), integer(), integer()) ::
          boolean()
  def isUnique(a, b, c, d, e, f, g) do
    try do
      nums = [a, b, c, d, e, f, g]
      _ = nums
      i = 0
      _ = i

      t1 = fn t1, i ->
        try do
          if i < length(nums) do
            j = i + 1
            _ = j

            t2 = fn t2, j ->
              try do
                if j < length(nums) do
                  if Enum.at(nums, i) == Enum.at(nums, j) do
                    throw({:return, false})
                  end

                  j = j + 1
                  t2.(t2, j)
                else
                  {:ok, j}
                end
              catch
                :break ->
                  {:ok, j}
              end
            end

            {_, j} = t2.(t2, j)
            _ = j
            i = i + 1
            t1.(t1, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t1.(t1, i)
      _ = i
      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec getCombs(integer(), integer(), boolean()) :: map()
  def getCombs(low, high, unique) do
    try do
      valid = []
      _ = valid
      # count :: (any() -> integer())
      count = 0
      _ = count

      {count, valid} =
        Enum.reduce_while(low..(high + 1 - 1), {count, valid}, fn b, {count, valid} ->
          try do
            {count, valid} =
              Enum.reduce_while(low..(high + 1 - 1), {count, valid}, fn c, {count, valid} ->
                try do
                  {count, valid} =
                    Enum.reduce_while(low..(high + 1 - 1), {count, valid}, fn d, {count, valid} ->
                      try do
                        s = b + c + d

                        {count, valid} =
                          Enum.reduce_while(low..(high + 1 - 1), {count, valid}, fn e,
                                                                                    {count, valid} ->
                            try do
                              {count, valid} =
                                Enum.reduce_while(low..(high + 1 - 1), {count, valid}, fn f,
                                                                                          {count,
                                                                                           valid} ->
                                  try do
                                    a = s - b
                                    g = s - f

                                    if a < low || a > high do
                                      throw(:continue)
                                    end

                                    if g < low || g > high do
                                      throw(:continue)
                                    end

                                    if d + e + f != s do
                                      throw(:continue)
                                    end

                                    if f + g != s do
                                      throw(:continue)
                                    end

                                    if !unique || isUnique(a, b, c, d, e, f, g) do
                                      valid = valid ++ [[a, b, c, d, e, f, g]]
                                      count = count + 1
                                    end

                                    {:cont, {count, valid}}
                                  catch
                                    :break -> {:halt, {count, valid}}
                                    :continue -> {:cont, {count, valid}}
                                  end
                                end)

                              _ = count
                              _ = valid
                              {:cont, {count, valid}}
                            catch
                              :break -> {:halt, {count, valid}}
                              :continue -> {:cont, {count, valid}}
                            end
                          end)

                        _ = count
                        _ = valid
                        {:cont, {count, valid}}
                      catch
                        :break -> {:halt, {count, valid}}
                        :continue -> {:cont, {count, valid}}
                      end
                    end)

                  _ = count
                  _ = valid
                  {:cont, {count, valid}}
                catch
                  :break -> {:halt, {count, valid}}
                  :continue -> {:cont, {count, valid}}
                end
              end)

            _ = count
            _ = valid
            {:cont, {count, valid}}
          catch
            :break -> {:halt, {count, valid}}
            :continue -> {:cont, {count, valid}}
          end
        end)

      _ = count
      _ = valid
      throw({:return, %{"count" => count, "list" => valid}})
    catch
      {:return, v} -> v
    end
  end

  def main do
    # r1 :: map()
    r1 = getCombs(1, 7, true)
    IO.puts(to_string(Map.get(r1, "count")) <> " unique solutions in 1 to 7")
    IO.inspect(Map.get(r1, "list"))
    # r2 :: map()
    r2 = getCombs(3, 9, true)
    IO.puts(to_string(Map.get(r2, "count")) <> " unique solutions in 3 to 9")
    IO.inspect(Map.get(r2, "list"))
    # r3 :: map()
    r3 = getCombs(0, 9, false)
    IO.puts(to_string(Map.get(r3, "count")) <> " non-unique solutions in 0 to 9")
  end
end

Main.main()
