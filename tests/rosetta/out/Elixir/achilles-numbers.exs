# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:49:39Z
defmodule Main do
  @spec pow10(integer()) :: integer()
  def pow10(exp) do
    try do
      n = 1
      _ = n
      i = 0
      _ = i

      t1 = fn t1, i, n ->
        try do
          if i < exp do
            n = n * 10
            i = i + 1
            t1.(t1, i, n)
          else
            {:ok, i, n}
          end
        catch
          :break ->
            {:ok, i, n}
        end
      end

      {_, i, n} = t1.(t1, i, n)
      _ = i
      _ = n
      throw({:return, n})
    catch
      {:return, v} -> v
    end
  end

  @spec totient(integer()) :: integer()
  def totient(n) do
    try do
      tot = n
      _ = tot
      nn = n
      _ = nn
      i = 2
      _ = i

      t2 = fn t2, i, nn, tot ->
        try do
          if i * i <= nn do
            if rem(nn, i) == 0 do
              t3 = fn t3, nn ->
                try do
                  if rem(nn, i) == 0 do
                    nn = nn / i
                    t3.(t3, nn)
                  else
                    {:ok, nn}
                  end
                catch
                  :break ->
                    {:ok, nn}
                end
              end

              {_, nn} = t3.(t3, nn)
              _ = nn
              tot = tot - tot / i
            end

            if i == 2 do
              i = 1
            end

            i = i + 2
            t2.(t2, i, nn, tot)
          else
            {:ok, i, nn, tot}
          end
        catch
          :break ->
            {:ok, i, nn, tot}
        end
      end

      {_, i, nn, tot} = t2.(t2, i, nn, tot)
      _ = i
      _ = nn
      _ = tot

      if nn > 1 do
        tot = tot - tot / nn
      end

      throw({:return, tot})
    catch
      {:return, v} -> v
    end
  end

  @spec getPerfectPowers(integer()) :: nil
  def getPerfectPowers(maxExp) do
    try do
      # upper :: (String.t() -> String.t())
      upper = pow10(maxExp)
      i = 2
      _ = i

      t4 = fn t4, i, pps ->
        try do
          if i * i < upper do
            p = i * i
            _ = p

            t5 = fn t5, p, pps ->
              try do
                if true do
                  p = p * i

                  if p >= upper do
                    throw(:break)
                  end

                  pps = Map.put(pps, p, true)
                  t5.(t5, p, pps)
                else
                  {:ok, p, pps}
                end
              catch
                :break ->
                  {:ok, p, pps}
              end
            end

            {_, p, pps} = t5.(t5, p, pps)
            _ = p
            _ = pps
            i = i + 1
            t4.(t4, i, pps)
          else
            {:ok, i, pps}
          end
        catch
          :break ->
            {:ok, i, pps}
        end
      end

      {_, i, pps} = t4.(t4, i, pps)
      _ = i
      _ = pps
    catch
      {:return, v} -> v
    end
  end

  @spec getAchilles(integer(), integer()) :: map()
  def getAchilles(minExp, maxExp) do
    try do
      # lower :: (any() -> String.t())
      lower = pow10(minExp)
      # upper :: (String.t() -> String.t())
      upper = pow10(maxExp)
      achilles = %{}
      _ = achilles
      b = 1
      _ = b

      t6 = fn t6, achilles, b ->
        try do
          if b * b * b < upper do
            b3 = b * b * b
            a = 1
            _ = a

            t7 = fn t7, a, achilles ->
              try do
                if true do
                  p = b3 * a * a

                  if p >= upper do
                    throw(:break)
                  end

                  if p >= lower do
                    if !if(is_map(pps), do: Map.has_key?(pps, p), else: Enum.member?(pps, p)) do
                      achilles = Map.put(achilles, p, true)
                    end
                  end

                  a = a + 1
                  t7.(t7, a, achilles)
                else
                  {:ok, a, achilles}
                end
              catch
                :break ->
                  {:ok, a, achilles}
              end
            end

            {_, a, achilles} = t7.(t7, a, achilles)
            _ = a
            _ = achilles
            b = b + 1
            t6.(t6, achilles, b)
          else
            {:ok, achilles, b}
          end
        catch
          :break ->
            {:ok, achilles, b}
        end
      end

      {_, achilles, b} = t6.(t6, achilles, b)
      _ = achilles
      _ = b
      throw({:return, achilles})
    catch
      {:return, v} -> v
    end
  end

  @spec sortInts(list(integer())) :: list(integer())
  def sortInts(xs) do
    try do
      res = []
      _ = res
      tmp = xs
      _ = tmp

      t8 = fn t8, res, tmp ->
        try do
          if length(tmp) > 0 do
            # min :: (any() -> any())
            min = Enum.at(tmp, 0)
            _ = min
            idx = 0
            _ = idx
            i = 1
            _ = i

            t9 = fn t9, i, idx, min ->
              try do
                if i < length(tmp) do
                  if Enum.at(tmp, i) < min do
                    min = Enum.at(tmp, i)
                    idx = i
                  end

                  i = i + 1
                  t9.(t9, i, idx, min)
                else
                  {:ok, i, idx, min}
                end
              catch
                :break ->
                  {:ok, i, idx, min}
              end
            end

            {_, i, idx, min} = t9.(t9, i, idx, min)
            _ = i
            _ = idx
            _ = min
            res = res ++ [min]
            out = []
            _ = out
            j = 0
            _ = j

            t10 = fn t10, j, out ->
              try do
                if j < length(tmp) do
                  if j != idx do
                    out = out ++ [Enum.at(tmp, j)]
                  end

                  j = j + 1
                  t10.(t10, j, out)
                else
                  {:ok, j, out}
                end
              catch
                :break ->
                  {:ok, j, out}
              end
            end

            {_, j, out} = t10.(t10, j, out)
            _ = j
            _ = out
            tmp = out
            t8.(t8, res, tmp)
          else
            {:ok, res, tmp}
          end
        catch
          :break ->
            {:ok, res, tmp}
        end
      end

      {_, res, tmp} = t8.(t8, res, tmp)
      _ = res
      _ = tmp
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec pad(integer(), integer()) :: String.t()
  def pad(n, width) do
    try do
      s = to_string(n)
      _ = s

      t11 = fn t11, s ->
        try do
          if length(s) < width do
            s = " " <> s
            t11.(t11, s)
          else
            {:ok, s}
          end
        catch
          :break ->
            {:ok, s}
        end
      end

      {_, s} = t11.(t11, s)
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      maxDigits = 15
      getPerfectPowers(maxDigits)
      achSet = getAchilles(1, 5)
      ach = []
      _ = ach

      {ach} =
        Enum.reduce(Map.keys(achSet), {ach}, fn k, {ach} ->
          ach = ach ++ [k]
          {ach}
        end)

      _ = ach
      ach = sortInts(ach)
      IO.puts("First 50 Achilles numbers:")
      i = 0
      _ = i

      t12 = fn t12, i ->
        try do
          if i < 50 do
            line = ""
            _ = line
            j = 0
            _ = j

            t13 = fn t13, i, j, line ->
              try do
                if j < 10 do
                  line = line + pad(Enum.at(ach, i), 4)

                  if j < 9 do
                    line = line <> " "
                  end

                  i = i + 1
                  j = j + 1
                  t13.(t13, i, j, line)
                else
                  {:ok, i, j, line}
                end
              catch
                :break ->
                  {:ok, i, j, line}
              end
            end

            {_, i, j, line} = t13.(t13, i, j, line)
            _ = i
            _ = j
            _ = line
            IO.inspect(line)
            t12.(t12, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t12.(t12, i)
      _ = i
      IO.puts("\nFirst 30 strong Achilles numbers:")
      strong = []
      _ = strong
      # count :: (any() -> integer())
      count = 0
      _ = count
      idx = 0
      _ = idx

      t14 = fn t14, count, idx, strong ->
        try do
          if count < 30 do
            tot = totient(Enum.at(ach, idx))

            if if is_map(achSet), do: Map.has_key?(achSet, tot), else: Enum.member?(achSet, tot) do
              strong = strong ++ [Enum.at(ach, idx)]
              count = count + 1
            end

            idx = idx + 1
            t14.(t14, count, idx, strong)
          else
            {:ok, count, idx, strong}
          end
        catch
          :break ->
            {:ok, count, idx, strong}
        end
      end

      {_, count, idx, strong} = t14.(t14, count, idx, strong)
      _ = count
      _ = idx
      _ = strong
      i = 0

      t15 = fn t15, i ->
        try do
          if i < 30 do
            line = ""
            _ = line
            j = 0
            _ = j

            t16 = fn t16, i, j, line ->
              try do
                if j < 10 do
                  line = line + pad(Enum.at(strong, i), 5)

                  if j < 9 do
                    line = line <> " "
                  end

                  i = i + 1
                  j = j + 1
                  t16.(t16, i, j, line)
                else
                  {:ok, i, j, line}
                end
              catch
                :break ->
                  {:ok, i, j, line}
              end
            end

            {_, i, j, line} = t16.(t16, i, j, line)
            _ = i
            _ = j
            _ = line
            IO.inspect(line)
            t15.(t15, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t15.(t15, i)
      _ = i
      IO.puts("\nNumber of Achilles numbers with:")

      counts = [
        1,
        12,
        47,
        192,
        664,
        2242,
        7395,
        24008,
        77330,
        247_449,
        788_855,
        2_508_051,
        7_960_336,
        25_235_383
      ]

      d = 2
      _ = d

      t17 = fn t17, d ->
        try do
          if d <= maxDigits do
            c = Enum.at(counts, d - 2)
            IO.puts((pad(d, 2) <> " digits: ") <> to_string(c))
            d = d + 1
            t17.(t17, d)
          else
            {:ok, d}
          end
        catch
          :break ->
            {:ok, d}
        end
      end

      {_, d} = t17.(t17, d)
      _ = d
    catch
      {:return, v} -> v
    end
  end

  def main do
    # pps :: map()
    pps = %{}
    _ = pps
    main()
  end
end

Main.main()
