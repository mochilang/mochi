# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:32Z
defmodule Main do
  @spec randInt(integer(), integer()) :: list(integer())
  def randInt(s, n) do
    try do
      next = rem(s * 1_664_525 + 1_013_904_223, 2_147_483_647)
      throw({:return, [next, rem(next, n)]})
    catch
      {:return, v} -> v
    end
  end

  @spec padLeft(String.t(), integer()) :: String.t()
  def padLeft(s, w) do
    try do
      res = ""
      _ = res
      n = w - length(s)
      _ = n

      t1 = fn t1, n, res ->
        try do
          if n > 0 do
            res = res <> " "
            n = n - 1
            t1.(t1, n, res)
          else
            {:ok, n, res}
          end
        catch
          :break ->
            {:ok, n, res}
        end
      end

      {_, n, res} = t1.(t1, n, res)
      _ = n
      _ = res
      throw({:return, res + s})
    catch
      {:return, v} -> v
    end
  end

  @spec makeSeq(integer(), integer()) :: list(any())
  def makeSeq(s, le) do
    try do
      bases = "ACGT"
      out = ""
      _ = out
      i = 0
      _ = i

      t2 = fn t2, i, out, s ->
        try do
          if i < le do
            r = randInt(s, 4)
            _ = r
            s = Enum.at(r, 0)
            idx = String.to_integer(Enum.at(r, 1))
            out = out + _slice_string(bases, idx, idx + 1)
            i = i + 1
            t2.(t2, i, out, s)
          else
            {:ok, i, out, s}
          end
        catch
          :break ->
            {:ok, i, out, s}
        end
      end

      {_, i, out, s} = t2.(t2, i, out, s)
      _ = i
      _ = out
      _ = s
      throw({:return, [s, out]})
    catch
      {:return, v} -> v
    end
  end

  @spec mutate(integer(), String.t(), list(integer())) :: list(any())
  def mutate(s, dna, w) do
    try do
      bases = "ACGT"
      le = length(dna)
      r = randInt(s, le)
      _ = r
      s = Enum.at(r, 0)
      p = String.to_integer(Enum.at(r, 1))
      r = randInt(s, 300)
      s = Enum.at(r, 0)
      x = String.to_integer(Enum.at(r, 1))
      arr = []
      _ = arr
      i = 0
      _ = i

      t3 = fn t3, arr, i ->
        try do
          if i < le do
            arr = arr ++ [_slice_string(dna, i, i + 1)]
            i = i + 1
            t3.(t3, arr, i)
          else
            {:ok, arr, i}
          end
        catch
          :break ->
            {:ok, arr, i}
        end
      end

      {_, arr, i} = t3.(t3, arr, i)
      _ = arr
      _ = i

      if x < Enum.at(w, 0) do
        r = randInt(s, 4)
        s = Enum.at(r, 0)
        idx = String.to_integer(Enum.at(r, 1))
        b = _slice_string(bases, idx, idx + 1)

        IO.inspect(
          ((((("  Change @" <> padLeft(to_string(p), 3)) <> " '") <> Enum.at(arr, p)) <> "' to '") <>
             b) <> "'"
        )

        arr = Map.put(arr, p, b)
      else
        if x < Enum.at(w, 0) + Enum.at(w, 1) do
          IO.inspect(
            ((("  Delete @" <> padLeft(to_string(p), 3)) <> " '") <> Enum.at(arr, p)) <> "'"
          )

          j = p
          _ = j

          t4 = fn t4, arr, j ->
            try do
              if j < length(arr) - 1 do
                arr = Map.put(arr, j, Enum.at(arr, j + 1))
                j = j + 1
                t4.(t4, arr, j)
              else
                {:ok, arr, j}
              end
            catch
              :break ->
                {:ok, arr, j}
            end
          end

          {_, arr, j} = t4.(t4, arr, j)
          _ = arr
          _ = j
          arr = Enum.slice(arr, 0, length(arr) - 1 - 0)
        else
          r = randInt(s, 4)
          s = Enum.at(r, 0)
          idx2 = String.to_integer(Enum.at(r, 1))
          b = _slice_string(bases, idx2, idx2 + 1)
          arr = arr ++ [""]
          j = length(arr) - 1
          _ = j

          t5 = fn t5, arr, j ->
            try do
              if j > p do
                arr = Map.put(arr, j, Enum.at(arr, j - 1))
                j = j - 1
                t5.(t5, arr, j)
              else
                {:ok, arr, j}
              end
            catch
              :break ->
                {:ok, arr, j}
            end
          end

          {_, arr, j} = t5.(t5, arr, j)
          _ = arr
          _ = j
          IO.inspect(((("  Insert @" <> padLeft(to_string(p), 3)) <> " '") <> b) <> "'")
          arr = Map.put(arr, p, b)
        end
      end

      out = ""
      _ = out
      i = 0

      t6 = fn t6, i, out ->
        try do
          if i < length(arr) do
            out = out + Enum.at(arr, i)
            i = i + 1
            t6.(t6, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t6.(t6, i, out)
      _ = i
      _ = out
      throw({:return, [s, out]})
    catch
      {:return, v} -> v
    end
  end

  @spec prettyPrint(String.t(), integer()) :: nil
  def prettyPrint(dna, rowLen) do
    try do
      IO.puts("SEQUENCE:")
      le = length(dna)
      i = 0
      _ = i

      t7 = fn t7, i ->
        try do
          if i < le do
            k = i + rowLen
            _ = k

            if k > le do
              k = le
            end

            IO.inspect((padLeft(to_string(i), 5) <> ": ") <> Enum.slice(dna, i, k - i))
            i = i + rowLen
            t7.(t7, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t7.(t7, i)
      _ = i
      a = 0
      _ = a
      c = 0
      _ = c
      g = 0
      _ = g
      t = 0
      _ = t
      idx = 0
      _ = idx

      t8 = fn t8, a, c, g, idx, t ->
        try do
          if idx < le do
            ch = _slice_string(dna, idx, idx + 1)

            if ch == "A" do
              a = a + 1
            else
              if ch == "C" do
                c = c + 1
              else
                if ch == "G" do
                  g = g + 1
                else
                  if ch == "T" do
                    t = t + 1
                  end
                end
              end
            end

            idx = idx + 1
            t8.(t8, a, c, g, idx, t)
          else
            {:ok, a, c, g, idx, t}
          end
        catch
          :break ->
            {:ok, a, c, g, idx, t}
        end
      end

      {_, a, c, g, idx, t} = t8.(t8, a, c, g, idx, t)
      _ = a
      _ = c
      _ = g
      _ = idx
      _ = t
      IO.puts("")
      IO.puts("BASE COUNT:")
      IO.puts("    A: " <> padLeft(to_string(a), 3))
      IO.puts("    C: " <> padLeft(to_string(c), 3))
      IO.puts("    G: " <> padLeft(to_string(g), 3))
      IO.puts("    T: " <> padLeft(to_string(t), 3))
      IO.puts("    ------")
      IO.puts("    Î£: " <> to_string(le))
      IO.puts("    ======")
    catch
      {:return, v} -> v
    end
  end

  @spec wstring(list(integer())) :: String.t()
  def wstring(w) do
    try do
      throw(
        {:return,
         ((((("  Change: " <> to_string(Enum.at(w, 0))) <> "\n  Delete: ") <>
              to_string(Enum.at(w, 1))) <> "\n  Insert: ") <> to_string(Enum.at(w, 2))) <> "\n"}
      )
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      seed = 1
      _ = seed
      res = makeSeq(seed, 250)
      _ = res
      seed = Enum.at(res, 0)
      dna = Enum.at(res, 1)
      _ = dna
      prettyPrint(dna, 50)
      muts = 10
      w = [100, 100, 100]
      IO.puts("\nWEIGHTS (ex 300):")
      IO.puts(wstring(w))
      IO.puts(("MUTATIONS (" <> to_string(muts)) <> "):")
      i = 0
      _ = i

      t9 = fn t9, dna, i, res, seed ->
        try do
          if i < muts do
            res = mutate(seed, dna, w)
            seed = Enum.at(res, 0)
            dna = Enum.at(res, 1)
            i = i + 1
            t9.(t9, dna, i, res, seed)
          else
            {:ok, dna, i, res, seed}
          end
        catch
          :break ->
            {:ok, dna, i, res, seed}
        end
      end

      {_, dna, i, res, seed} = t9.(t9, dna, i, res, seed)
      _ = dna
      _ = i
      _ = res
      _ = seed
      IO.puts("")
      prettyPrint(dna, 50)
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
