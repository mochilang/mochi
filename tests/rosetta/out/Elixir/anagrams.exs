# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:44:36Z
defmodule Main do
  @spec sortRunes(String.t()) :: String.t()
  def sortRunes(s) do
    try do
      arr = []
      _ = arr
      i = 0
      _ = i

      t1 = fn t1, arr, i ->
        try do
          if i < length(s) do
            arr = arr ++ [Enum.slice(s, i, i + 1 - i)]
            i = i + 1
            t1.(t1, arr, i)
          else
            {:ok, arr, i}
          end
        catch
          :break ->
            {:ok, arr, i}
        end
      end

      {_, arr, i} = t1.(t1, arr, i)
      _ = arr
      _ = i
      n = length(arr)
      _ = n
      m = 0
      _ = m

      t2 = fn t2, arr, m ->
        try do
          if m < n do
            j = 0
            _ = j

            t3 = fn t3, arr, j ->
              try do
                if j < n - 1 do
                  if Enum.at(arr, j) > Enum.at(arr, j + 1) do
                    tmp = Enum.at(arr, j)
                    arr = Map.put(arr, j, Enum.at(arr, j + 1))
                    arr = Map.put(arr, j + 1, tmp)
                  end

                  j = j + 1
                  t3.(t3, arr, j)
                else
                  {:ok, arr, j}
                end
              catch
                :break ->
                  {:ok, arr, j}
              end
            end

            {_, arr, j} = t3.(t3, arr, j)
            _ = arr
            _ = j
            m = m + 1
            t2.(t2, arr, m)
          else
            {:ok, arr, m}
          end
        catch
          :break ->
            {:ok, arr, m}
        end
      end

      {_, arr, m} = t2.(t2, arr, m)
      _ = arr
      _ = m
      out = ""
      _ = out
      i = 0

      t4 = fn t4, i, out ->
        try do
          if i < n do
            out = out + Enum.at(arr, i)
            i = i + 1
            t4.(t4, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t4.(t4, i, out)
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec sortStrings(list(String.t())) :: list(String.t())
  def sortStrings(xs) do
    try do
      res = []
      _ = res
      tmp = xs
      _ = tmp

      t5 = fn t5, res, tmp ->
        try do
          if length(tmp) > 0 do
            # min :: (any() -> any())
            min = Enum.at(tmp, 0)
            _ = min
            idx = 0
            _ = idx
            i = 1
            _ = i

            t6 = fn t6, i, idx, min ->
              try do
                if i < length(tmp) do
                  if Enum.at(tmp, i) < min do
                    min = Enum.at(tmp, i)
                    idx = i
                  end

                  i = i + 1
                  t6.(t6, i, idx, min)
                else
                  {:ok, i, idx, min}
                end
              catch
                :break ->
                  {:ok, i, idx, min}
              end
            end

            {_, i, idx, min} = t6.(t6, i, idx, min)
            _ = i
            _ = idx
            _ = min
            res = res ++ [min]
            out = []
            _ = out
            j = 0
            _ = j

            t7 = fn t7, j, out ->
              try do
                if j < length(tmp) do
                  if j != idx do
                    out = out ++ [Enum.at(tmp, j)]
                  end

                  j = j + 1
                  t7.(t7, j, out)
                else
                  {:ok, j, out}
                end
              catch
                :break ->
                  {:ok, j, out}
              end
            end

            {_, j, out} = t7.(t7, j, out)
            _ = j
            _ = out
            tmp = out
            t5.(t5, res, tmp)
          else
            {:ok, res, tmp}
          end
        catch
          :break ->
            {:ok, res, tmp}
        end
      end

      {_, res, tmp} = t5.(t5, res, tmp)
      _ = res
      _ = tmp
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      words = [
        "abel",
        "able",
        "bale",
        "bela",
        "elba",
        "alger",
        "glare",
        "lager",
        "large",
        "regal",
        "angel",
        "angle",
        "galen",
        "glean",
        "lange",
        "caret",
        "carte",
        "cater",
        "crate",
        "trace",
        "elan",
        "lane",
        "lean",
        "lena",
        "neal",
        "evil",
        "levi",
        "live",
        "veil",
        "vile"
      ]

      groups = %{}
      _ = groups
      maxLen = 0
      _ = maxLen

      {groups, maxLen} =
        Enum.reduce(_iter(words), {groups, maxLen}, fn w, {groups, maxLen} ->
          k = sortRunes(w)

          if !if(is_map(groups), do: Map.has_key?(groups, k), else: Enum.member?(groups, k)) do
            groups = Map.put(groups, k, [w])
          else
            groups = Map.put(groups, k, Enum.at(groups, k) ++ [w])
          end

          if length(Enum.at(groups, k)) > maxLen do
            maxLen = length(Enum.at(groups, k))
          end

          {groups, maxLen}
        end)

      _ = groups
      _ = maxLen
      printed = %{}
      _ = printed

      {printed} =
        Enum.reduce(_iter(words), {printed}, fn w, {printed} ->
          k = sortRunes(w)

          if length(Enum.at(groups, k)) == maxLen do
            if !if(is_map(printed), do: Map.has_key?(printed, k), else: Enum.member?(printed, k)) do
              g = sortStrings(Enum.at(groups, k))
              _ = g
              line = "[" <> Enum.at(g, 0)
              _ = line
              i = 1
              _ = i

              t8 = fn t8, i, line ->
                try do
                  if i < length(g) do
                    line = (line <> " ") <> Enum.at(g, i)
                    i = i + 1
                    t8.(t8, i, line)
                  else
                    {:ok, i, line}
                  end
                catch
                  :break ->
                    {:ok, i, line}
                end
              end

              {_, i, line} = t8.(t8, i, line)
              _ = i
              _ = line
              line = line <> "]"
              IO.inspect(line)
              printed = Map.put(printed, k, true)
            end
          end

          {printed}
        end)

      _ = printed
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _iter(v) do
    if is_map(v) do
      Map.keys(v)
    else
      v
    end
  end
end

Main.main()
