# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:52Z
defmodule Main do
  @spec toUnsigned16(integer()) :: integer()
  def toUnsigned16(n) do
    try do
      u = n
      _ = u

      if u < 0 do
        u = u + 65536
      end

      throw({:return, rem(u, 65536)})
    catch
      {:return, v} -> v
    end
  end

  @spec bin16(integer()) :: String.t()
  def bin16(n) do
    try do
      u = toUnsigned16(n)
      _ = u
      bits = ""
      _ = bits
      mask = 32768
      _ = mask

      {bits, mask, u} =
        Enum.reduce(0..(16 - 1), {bits, mask, u}, fn i, {bits, mask, u} ->
          if u >= mask do
            bits = bits <> "1"
            u = u - mask
          else
            bits = bits <> "0"
          end

          mask = String.to_integer(mask / 2)
          {bits, mask, u}
        end)

      _ = bits
      _ = mask
      _ = u
      throw({:return, bits})
    catch
      {:return, v} -> v
    end
  end

  @spec bit_and(integer(), integer()) :: integer()
  def bit_and(a, b) do
    try do
      ua = toUnsigned16(a)
      _ = ua
      ub = toUnsigned16(b)
      _ = ub
      res = 0
      _ = res
      bit = 1
      _ = bit

      {bit, res, ua, ub} =
        Enum.reduce(0..(16 - 1), {bit, res, ua, ub}, fn i, {bit, res, ua, ub} ->
          if rem(ua, 2) == 1 && rem(ub, 2) == 1 do
            res = res + bit
          end

          ua = String.to_integer(ua / 2)
          ub = String.to_integer(ub / 2)
          bit = bit * 2
          {bit, res, ua, ub}
        end)

      _ = bit
      _ = res
      _ = ua
      _ = ub
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec bit_or(integer(), integer()) :: integer()
  def bit_or(a, b) do
    try do
      ua = toUnsigned16(a)
      _ = ua
      ub = toUnsigned16(b)
      _ = ub
      res = 0
      _ = res
      bit = 1
      _ = bit

      {bit, res, ua, ub} =
        Enum.reduce(0..(16 - 1), {bit, res, ua, ub}, fn i, {bit, res, ua, ub} ->
          if rem(ua, 2) == 1 || rem(ub, 2) == 1 do
            res = res + bit
          end

          ua = String.to_integer(ua / 2)
          ub = String.to_integer(ub / 2)
          bit = bit * 2
          {bit, res, ua, ub}
        end)

      _ = bit
      _ = res
      _ = ua
      _ = ub
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec bit_xor(integer(), integer()) :: integer()
  def bit_xor(a, b) do
    try do
      ua = toUnsigned16(a)
      _ = ua
      ub = toUnsigned16(b)
      _ = ub
      res = 0
      _ = res
      bit = 1
      _ = bit

      {bit, res, ua, ub} =
        Enum.reduce(0..(16 - 1), {bit, res, ua, ub}, fn i, {bit, res, ua, ub} ->
          abit = rem(ua, 2)
          bbit = rem(ub, 2)

          if (abit == 1 && bbit == 0) || (abit == 0 && bbit == 1) do
            res = res + bit
          end

          ua = String.to_integer(ua / 2)
          ub = String.to_integer(ub / 2)
          bit = bit * 2
          {bit, res, ua, ub}
        end)

      _ = bit
      _ = res
      _ = ua
      _ = ub
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec bit_not(integer()) :: integer()
  def bit_not(a) do
    try do
      ua = toUnsigned16(a)
      _ = ua
      throw({:return, 65535 - ua})
    catch
      {:return, v} -> v
    end
  end

  @spec shl(integer(), integer()) :: integer()
  def shl(a, b) do
    try do
      ua = toUnsigned16(a)
      _ = ua
      i = 0
      _ = i

      t1 = fn t1, i, ua ->
        try do
          if i < b do
            ua = rem(ua * 2, 65536)
            i = i + 1
            t1.(t1, i, ua)
          else
            {:ok, i, ua}
          end
        catch
          :break ->
            {:ok, i, ua}
        end
      end

      {_, i, ua} = t1.(t1, i, ua)
      _ = i
      _ = ua
      throw({:return, ua})
    catch
      {:return, v} -> v
    end
  end

  @spec shr(integer(), integer()) :: integer()
  def shr(a, b) do
    try do
      ua = toUnsigned16(a)
      _ = ua
      i = 0
      _ = i

      t2 = fn t2, i, ua ->
        try do
          if i < b do
            ua = String.to_integer(ua / 2)
            i = i + 1
            t2.(t2, i, ua)
          else
            {:ok, i, ua}
          end
        catch
          :break ->
            {:ok, i, ua}
        end
      end

      {_, i, ua} = t2.(t2, i, ua)
      _ = i
      _ = ua
      throw({:return, ua})
    catch
      {:return, v} -> v
    end
  end

  @spec las(integer(), integer()) :: integer()
  def las(a, b) do
    try do
      throw({:return, shl(a, b)})
    catch
      {:return, v} -> v
    end
  end

  @spec ras(integer(), integer()) :: integer()
  def ras(a, b) do
    try do
      val = a
      _ = val
      i = 0
      _ = i

      t3 = fn t3, i, val ->
        try do
          if i < b do
            if val >= 0 do
              val = String.to_integer(val / 2)
            else
              val = String.to_integer((val - 1) / 2)
            end

            i = i + 1
            t3.(t3, i, val)
          else
            {:ok, i, val}
          end
        catch
          :break ->
            {:ok, i, val}
        end
      end

      {_, i, val} = t3.(t3, i, val)
      _ = i
      _ = val
      throw({:return, toUnsigned16(val)})
    catch
      {:return, v} -> v
    end
  end

  @spec rol(integer(), integer()) :: integer()
  def rol(a, b) do
    try do
      ua = toUnsigned16(a)
      _ = ua
      left = shl(ua, b)
      right = shr(ua, 16 - b)
      throw({:return, toUnsigned16(left + right)})
    catch
      {:return, v} -> v
    end
  end

  @spec ror(integer(), integer()) :: integer()
  def ror(a, b) do
    try do
      ua = toUnsigned16(a)
      _ = ua
      right = shr(ua, b)
      left = shl(ua, 16 - b)
      throw({:return, toUnsigned16(left + right)})
    catch
      {:return, v} -> v
    end
  end

  @spec bitwise(integer(), integer()) :: nil
  def bitwise(a, b) do
    try do
      IO.puts("a:   " <> bin16(a))
      IO.puts("b:   " <> bin16(b))
      IO.puts("and: " <> bin16(bit_and(a, b)))
      IO.puts("or:  " <> bin16(bit_or(a, b)))
      IO.puts("xor: " <> bin16(bit_xor(a, b)))
      IO.puts("not: " <> bin16(bit_not(a)))

      if b < 0 do
        IO.puts(
          "Right operand is negative, but all shifts require an unsigned right operand (shift distance)."
        )

        throw({:return, nil})
      end

      IO.puts("shl: " <> bin16(shl(a, b)))
      IO.puts("shr: " <> bin16(shr(a, b)))
      IO.puts("las: " <> bin16(las(a, b)))
      IO.puts("ras: " <> bin16(ras(a, b)))
      IO.puts("rol: " <> bin16(rol(a, b)))
      IO.puts("ror: " <> bin16(ror(a, b)))
    catch
      {:return, v} -> v
    end
  end

  def main do
    bitwise(-460, 6)
  end
end

Main.main()
