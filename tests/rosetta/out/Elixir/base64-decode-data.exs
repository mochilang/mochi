# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:15Z
defmodule Main do
  @spec indexOf(String.t(), String.t()) :: integer()
  def indexOf(s, ch) do
    try do
      i = 0
      _ = i

      t1 = fn t1, i ->
        try do
          if i < length(s) do
            if Enum.at(s, i) == ch do
              throw({:return, i})
            end

            i = i + 1
            t1.(t1, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t1.(t1, i)
      _ = i
      throw({:return, -1})
    catch
      {:return, v} -> v
    end
  end

  @spec parseIntStr(String.t()) :: integer()
  def parseIntStr(str) do
    try do
      i = 0
      _ = i
      neg = false
      _ = neg

      if length(str) > 0 && Enum.at(str, 0) == "-" do
        neg = true
        i = 1
      end

      n = 0
      _ = n

      digits = %{
        "0" => 0,
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        "6" => 6,
        "7" => 7,
        "8" => 8,
        "9" => 9
      }

      t2 = fn t2, i, n ->
        try do
          if i < length(str) do
            n = n * 10 + Enum.at(digits, Enum.at(str, i))
            i = i + 1
            t2.(t2, i, n)
          else
            {:ok, i, n}
          end
        catch
          :break ->
            {:ok, i, n}
        end
      end

      {_, i, n} = t2.(t2, i, n)
      _ = i
      _ = n

      if neg do
        n = -n
      end

      throw({:return, n})
    catch
      {:return, v} -> v
    end
  end

  @spec ord(String.t()) :: integer()
  def ord(ch) do
    try do
      # upper :: (String.t() -> String.t())
      upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      # lower :: (any() -> String.t())
      lower = "abcdefghijklmnopqrstuvwxyz"
      idx = indexOf(upper, ch)
      _ = idx

      if idx >= 0 do
        throw({:return, 65 + idx})
      end

      idx = indexOf(lower, ch)

      if idx >= 0 do
        throw({:return, 97 + idx})
      end

      if ch >= "0" && ch <= "9" do
        throw({:return, 48 + parseIntStr(ch)})
      end

      if ch == "+" do
        throw({:return, 43})
      end

      if ch == "/" do
        throw({:return, 47})
      end

      if ch == " " do
        throw({:return, 32})
      end

      if ch == "=" do
        throw({:return, 61})
      end

      throw({:return, 0})
    catch
      {:return, v} -> v
    end
  end

  @spec chr(integer()) :: String.t()
  def chr(n) do
    try do
      # upper :: (String.t() -> String.t())
      upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      # lower :: (any() -> String.t())
      lower = "abcdefghijklmnopqrstuvwxyz"

      if n >= 65 && n < 91 do
        throw({:return, Enum.slice(upper, n - 65, n - 64 - (n - 65))})
      end

      if n >= 97 && n < 123 do
        throw({:return, Enum.slice(lower, n - 97, n - 96 - (n - 97))})
      end

      if n >= 48 && n < 58 do
        digits = "0123456789"
        throw({:return, Enum.slice(digits, n - 48, n - 47 - (n - 48))})
      end

      if n == 43 do
        throw({:return, "+"})
      end

      if n == 47 do
        throw({:return, "/"})
      end

      if n == 32 do
        throw({:return, " "})
      end

      if n == 61 do
        throw({:return, "="})
      end

      throw({:return, "?"})
    catch
      {:return, v} -> v
    end
  end

  @spec toBinary(integer(), integer()) :: String.t()
  def toBinary(n, bits) do
    try do
      b = ""
      _ = b
      val = n
      _ = val
      i = 0
      _ = i

      t3 = fn t3, b, i, val ->
        try do
          if i < bits do
            b = to_string(rem(val, 2)) + b
            val = String.to_integer(val / 2)
            i = i + 1
            t3.(t3, b, i, val)
          else
            {:ok, b, i, val}
          end
        catch
          :break ->
            {:ok, b, i, val}
        end
      end

      {_, b, i, val} = t3.(t3, b, i, val)
      _ = b
      _ = i
      _ = val
      throw({:return, b})
    catch
      {:return, v} -> v
    end
  end

  @spec binToInt(String.t()) :: integer()
  def binToInt(bits) do
    try do
      n = 0
      _ = n
      i = 0
      _ = i

      t4 = fn t4, i, n ->
        try do
          if i < length(bits) do
            n = n * 2 + parseIntStr(Enum.slice(bits, i, i + 1 - i))
            i = i + 1
            t4.(t4, i, n)
          else
            {:ok, i, n}
          end
        catch
          :break ->
            {:ok, i, n}
        end
      end

      {_, i, n} = t4.(t4, i, n)
      _ = i
      _ = n
      throw({:return, n})
    catch
      {:return, v} -> v
    end
  end

  @spec base64Encode(String.t()) :: String.t()
  def base64Encode(text) do
    try do
      alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
      bin = ""
      _ = bin

      {bin} =
        Enum.reduce(_iter(text), {bin}, fn ch, {bin} ->
          bin = bin + toBinary(ord(ch), 8)
          {bin}
        end)

      _ = bin

      t5 = fn t5, bin ->
        try do
          if rem(length(bin), 6) != 0 do
            bin = bin <> "0"
            t5.(t5, bin)
          else
            {:ok, bin}
          end
        catch
          :break ->
            {:ok, bin}
        end
      end

      {_, bin} = t5.(t5, bin)
      _ = bin
      out = ""
      _ = out
      i = 0
      _ = i

      t6 = fn t6, i, out ->
        try do
          if i < length(bin) do
            chunk = Enum.slice(bin, i, i + 6 - i)
            val = binToInt(chunk)
            out = out + Enum.slice(alphabet, val, val + 1 - val)
            i = i + 6
            t6.(t6, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t6.(t6, i, out)
      _ = i
      _ = out
      pad = rem(3 - rem(length(text), 3), 3)

      if pad == 1 do
        out = Enum.slice(out, 0, length(out) - 1 - 0) <> "="
      end

      if pad == 2 do
        out = Enum.slice(out, 0, length(out) - 2 - 0) <> "=="
      end

      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec base64Decode(String.t()) :: String.t()
  def base64Decode(enc) do
    try do
      alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
      bin = ""
      _ = bin
      i = 0
      _ = i

      t7 = fn t7, bin, i ->
        try do
          if i < String.length(enc) do
            ch = _index_string(enc, i)

            if ch == "=" do
              throw(:break)
            end

            idx = indexOf(alphabet, ch)
            bin = bin + toBinary(idx, 6)
            i = i + 1
            t7.(t7, bin, i)
          else
            {:ok, bin, i}
          end
        catch
          :break ->
            {:ok, bin, i}
        end
      end

      {_, bin, i} = t7.(t7, bin, i)
      _ = bin
      _ = i
      out = ""
      _ = out
      i = 0

      t8 = fn t8, i, out ->
        try do
          if i + 8 <= length(bin) do
            chunk = Enum.slice(bin, i, i + 8 - i)
            val = binToInt(chunk)
            out = out + chr(val)
            i = i + 8
            t8.(t8, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t8.(t8, i, out)
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  def main do
    # msg :: String.t()
    msg = "Rosetta Code Base64 decode data task"
    IO.puts("Original : " <> msg)
    # enc :: String.t()
    enc = base64Encode(msg)
    IO.puts("\nEncoded  : " <> enc)
    # dec :: String.t()
    dec = base64Decode(enc)
    IO.puts("\nDecoded  : " <> dec)
  end

  defp _index_string(s, i) do
    chars = String.graphemes(s)
    idx = if i < 0, do: i + length(chars), else: i
    if idx < 0 or idx >= length(chars), do: raise("index out of range")
    Enum.at(chars, idx)
  end

  defp _iter(v) do
    if is_map(v) do
      Map.keys(v)
    else
      v
    end
  end
end

Main.main()
