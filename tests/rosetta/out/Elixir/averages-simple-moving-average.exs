# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:05Z
defmodule Main do
  @spec indexOf(String.t(), String.t()) :: integer()
  def indexOf(s, ch) do
    try do
      i = 0
      _ = i

      t1 = fn t1, i ->
        try do
          if i < length(s) do
            if _slice_string(s, i, i + 1) == ch do
              throw({:return, i})
            end

            i = i + 1
            t1.(t1, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t1.(t1, i)
      _ = i
      throw({:return, -1})
    catch
      {:return, v} -> v
    end
  end

  @spec fmt3(float()) :: String.t()
  def fmt3(x) do
    try do
      y = String.to_float(String.to_integer(x * 1000 + 0.5)) / 1000
      _ = y
      s = to_string(y)
      _ = s
      dot = indexOf(s, ".")
      _ = dot

      if dot == 0 - 1 do
        s = s <> ".000"
      else
        decs = length(s) - dot - 1
        _ = decs

        if decs > 3 do
          s = _slice_string(s, 0, dot + 4)
        else
          t2 = fn t2, decs, s ->
            try do
              if decs < 3 do
                s = s <> "0"
                decs = decs + 1
                t2.(t2, decs, s)
              else
                {:ok, decs, s}
              end
            catch
              :break ->
                {:ok, decs, s}
            end
          end

          {_, decs, s} = t2.(t2, decs, s)
          _ = decs
          _ = s
        end
      end

      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec pad(String.t(), integer()) :: String.t()
  def pad(s, width) do
    try do
      out = s
      _ = out

      t3 = fn t3, out ->
        try do
          if length(out) < width do
            out = " " <> out
            t3.(t3, out)
          else
            {:ok, out}
          end
        catch
          :break ->
            {:ok, out}
        end
      end

      {_, out} = t3.(t3, out)
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec smaSeries(list(float()), integer()) :: list(float())
  def smaSeries(xs, period) do
    try do
      res = []
      _ = res
      # sum :: (any() -> float())
      sum = 0
      _ = sum
      i = 0
      _ = i

      t4 = fn t4, i, res, sum ->
        try do
          if i < length(xs) do
            sum = sum + Enum.at(xs, i)

            if i >= period do
              sum = sum - Enum.at(xs, i - period)
            end

            # denom :: (any() -> any())
            denom = i + 1
            _ = denom

            if denom > period do
              denom = period
            end

            res = res ++ [sum / String.to_float(denom)]
            i = i + 1
            t4.(t4, i, res, sum)
          else
            {:ok, i, res, sum}
          end
        catch
          :break ->
            {:ok, i, res, sum}
        end
      end

      {_, i, res, sum} = t4.(t4, i, res, sum)
      _ = i
      _ = res
      _ = sum
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      xs = [1, 2, 3, 4, 5, 5, 4, 3, 2, 1]
      _ = xs
      sma3 = smaSeries(xs, 3)
      _ = sma3
      sma5 = smaSeries(xs, 5)
      _ = sma5
      IO.puts("x       sma3   sma5")
      i = 0
      _ = i

      t5 = fn t5, i ->
        try do
          if i < length(xs) do
            line =
              (((pad(fmt3(Enum.at(xs, i)), 5) <> "  ") <> pad(fmt3(Enum.at(sma3, i)), 5)) <> "  ") <>
                pad(fmt3(Enum.at(sma5, i)), 5)

            IO.inspect(line)
            i = i + 1
            t5.(t5, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t5.(t5, i)
      _ = i
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
