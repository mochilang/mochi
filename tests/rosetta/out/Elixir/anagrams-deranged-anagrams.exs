# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:44:35Z
defmodule Main do
  @spec sortRunes(String.t()) :: String.t()
  def sortRunes(s) do
    try do
      arr = []
      _ = arr
      i = 0
      _ = i

      t1 = fn t1, arr, i ->
        try do
          if i < length(s) do
            arr = arr ++ [Enum.slice(s, i, i + 1 - i)]
            i = i + 1
            t1.(t1, arr, i)
          else
            {:ok, arr, i}
          end
        catch
          :break ->
            {:ok, arr, i}
        end
      end

      {_, arr, i} = t1.(t1, arr, i)
      _ = arr
      _ = i
      n = length(arr)
      _ = n
      m = 0
      _ = m

      t2 = fn t2, arr, m ->
        try do
          if m < n do
            j = 0
            _ = j

            t3 = fn t3, arr, j ->
              try do
                if j < n - 1 do
                  if Enum.at(arr, j) > Enum.at(arr, j + 1) do
                    tmp = Enum.at(arr, j)
                    arr = Map.put(arr, j, Enum.at(arr, j + 1))
                    arr = Map.put(arr, j + 1, tmp)
                  end

                  j = j + 1
                  t3.(t3, arr, j)
                else
                  {:ok, arr, j}
                end
              catch
                :break ->
                  {:ok, arr, j}
              end
            end

            {_, arr, j} = t3.(t3, arr, j)
            _ = arr
            _ = j
            m = m + 1
            t2.(t2, arr, m)
          else
            {:ok, arr, m}
          end
        catch
          :break ->
            {:ok, arr, m}
        end
      end

      {_, arr, m} = t2.(t2, arr, m)
      _ = arr
      _ = m
      out = ""
      _ = out
      i = 0

      t4 = fn t4, i, out ->
        try do
          if i < n do
            out = out + Enum.at(arr, i)
            i = i + 1
            t4.(t4, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t4.(t4, i, out)
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec deranged(String.t(), String.t()) :: boolean()
  def deranged(a, b) do
    try do
      if length(a) != length(b) do
        throw({:return, false})
      end

      i = 0
      _ = i

      t5 = fn t5, i ->
        try do
          if i < length(a) do
            if Enum.slice(a, i, i + 1 - i) == Enum.slice(b, i, i + 1 - i) do
              throw({:return, false})
            end

            i = i + 1
            t5.(t5, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t5.(t5, i)
      _ = i
      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      words = ["constitutionalism", "misconstitutional"]
      m = %{}
      _ = m
      bestLen = 0
      _ = bestLen
      w1 = ""
      _ = w1
      w2 = ""
      _ = w2

      {bestLen, m, w1, w2} =
        Enum.reduce_while(_iter(words), {bestLen, m, w1, w2}, fn w, {bestLen, m, w1, w2} ->
          try do
            if length(w) <= bestLen do
              throw(:continue)
            end

            k = sortRunes(w)

            if !if(is_map(m), do: Map.has_key?(m, k), else: Enum.member?(m, k)) do
              m = Map.put(m, k, [w])
              throw(:continue)
            end

            {bestLen, w1, w2} =
              Enum.reduce_while(_iter(Enum.at(m, k)), {bestLen, w1, w2}, fn c,
                                                                            {bestLen, w1, w2} ->
                try do
                  if deranged(w, c) do
                    bestLen = length(w)
                    w1 = c
                    w2 = w
                    throw(:break)
                  end

                  {:cont, {bestLen, w1, w2}}
                catch
                  :break -> {:halt, {bestLen, w1, w2}}
                  :continue -> {:cont, {bestLen, w1, w2}}
                end
              end)

            _ = bestLen
            _ = w1
            _ = w2
            m = Map.put(m, k, Enum.at(m, k) ++ [w])
            {:cont, {bestLen, m, w1, w2}}
          catch
            :break -> {:halt, {bestLen, m, w1, w2}}
            :continue -> {:cont, {bestLen, m, w1, w2}}
          end
        end)

      _ = bestLen
      _ = m
      _ = w1
      _ = w2
      IO.inspect((((w1 <> " ") <> w2) <> " : Length ") <> to_string(bestLen))
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _iter(v) do
    if is_map(v) do
      Map.keys(v)
    else
      v
    end
  end
end

Main.main()
