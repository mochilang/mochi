# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:34Z
defmodule Main do
	@PI 3.141592653589793
	@TWO_PI 6.283185307179586
	@spec sinApprox(float()) :: float()
	def sinApprox(x) do
		try do
			term = x
			_ = term
			# sum :: (any() -> float())
			sum = x
			_ = sum
			n = 1
			_ = n
			t1 = fn t1, n, sum, term ->
				try do
					if (n <= 8) do
						# denom :: (any() -> any())
						denom = String.to_float(((2 * n) * ((2 * n) + 1)))
						term = (((-term * x) * x) / denom)
						sum = (sum + term)
						n = (n + 1)
						t1.(t1, n, sum, term)
					else
						{:ok, n, sum, term}
					end
				catch :break ->
					{:ok, n, sum, term}
				end
			end
			{_, n, sum, term} = t1.(t1, n, sum, term)
			_ = n
			_ = sum
			_ = term
			throw {:return, sum}
		catch {:return, v} -> v end
	end
	
	@spec floor(float()) :: float()
	def floor(x) do
		try do
			i = String.to_integer(x)
			_ = i
			if (String.to_float(i) > x) do
				i = (i - 1)
			end
			throw {:return, String.to_float(i)}
		catch {:return, v} -> v end
	end
	
	@spec absFloat(float()) :: float()
	def absFloat(x) do
		try do
			if (x < 0) do
				throw {:return, -x}
			end
			throw {:return, x}
		catch {:return, v} -> v end
	end
	
	@spec absInt(integer()) :: integer()
	def absInt(n) do
		try do
			if (n < 0) do
				throw {:return, -n}
			end
			throw {:return, n}
		catch {:return, v} -> v end
	end
	
	@spec parseIntStr(String.t()) :: integer()
	def parseIntStr(str) do
		try do
			i = 0
			_ = i
			neg = false
			_ = neg
			if ((length(str) > 0) && (Enum.slice((str), 0, (1) - 0) == "-")) do
				neg = true
				i = 1
			end
			n = 0
			_ = n
			digits = %{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
			t2 = fn t2, i, n ->
				try do
					if (i < length(str)) do
						n = ((n * 10) + Enum.at((digits), Enum.slice((str), i, ((i + 1)) - i)))
						i = (i + 1)
						t2.(t2, i, n)
					else
						{:ok, i, n}
					end
				catch :break ->
					{:ok, i, n}
				end
			end
			{_, i, n} = t2.(t2, i, n)
			_ = i
			_ = n
			if neg do
				n = -n
			end
			throw {:return, n}
		catch {:return, v} -> v end
	end
	
	@spec parseDate(String.t()) :: list(integer())
	def parseDate(s) do
		try do
			y = parseIntStr(Enum.slice((s), 0, (4) - 0))
			m = parseIntStr(Enum.slice((s), 5, (7) - 5))
			d = parseIntStr(Enum.slice((s), 8, (10) - 8))
			throw {:return, [y, m, d]}
		catch {:return, v} -> v end
	end
	
	@spec leap(integer()) :: boolean()
	def leap(y) do
		try do
			if (rem(y, 400) == 0) do
				throw {:return, true}
			end
			if (rem(y, 100) == 0) do
				throw {:return, false}
			end
			throw {:return, (rem(y, 4) == 0)}
		catch {:return, v} -> v end
	end
	
	@spec daysInMonth(integer(), integer()) :: integer()
	def daysInMonth(y, m) do
		try do
			feb = (fn ->
	if leap(y) do
		29
	else
		28
	end
end).()
			lengths = [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
			throw {:return, Enum.at((lengths), (m - 1))}
		catch {:return, v} -> v end
	end
	
	@spec addDays(integer(), integer(), integer(), integer()) :: list(integer())
	def addDays(y, m, d, n) do
		try do
			yy = y
			_ = yy
			mm = m
			_ = mm
			dd = d
			_ = dd
			if (n >= 0) do
				i = 0
				_ = i
				t3 = fn t3, dd, i, mm, yy ->
					try do
						if (i < n) do
							dd = (dd + 1)
							if (dd > daysInMonth(yy, mm)) do
								dd = 1
								mm = (mm + 1)
								if (mm > 12) do
									mm = 1
									yy = (yy + 1)
								end
							end
							i = (i + 1)
							t3.(t3, dd, i, mm, yy)
						else
							{:ok, dd, i, mm, yy}
						end
					catch :break ->
						{:ok, dd, i, mm, yy}
					end
				end
				{_, dd, i, mm, yy} = t3.(t3, dd, i, mm, yy)
				_ = dd
				_ = i
				_ = mm
				_ = yy
			else
				i = 0
				_ = i
				t4 = fn t4, dd, i, mm, yy ->
					try do
						if (i > n) do
							dd = (dd - 1)
							if (dd < 1) do
								mm = (mm - 1)
								if (mm < 1) do
									mm = 12
									yy = (yy - 1)
								end
								dd = daysInMonth(yy, mm)
							end
							i = (i - 1)
							t4.(t4, dd, i, mm, yy)
						else
							{:ok, dd, i, mm, yy}
						end
					catch :break ->
						{:ok, dd, i, mm, yy}
					end
				end
				{_, dd, i, mm, yy} = t4.(t4, dd, i, mm, yy)
				_ = dd
				_ = i
				_ = mm
				_ = yy
			end
			throw {:return, [yy, mm, dd]}
		catch {:return, v} -> v end
	end
	
	@spec pad2(integer()) :: String.t()
	def pad2(n) do
		try do
			if (n < 10) do
				throw {:return, ("0" <> to_string(n))}
			end
			throw {:return, to_string(n)}
		catch {:return, v} -> v end
	end
	
	@spec dateString(integer(), integer(), integer()) :: String.t()
	def dateString(y, m, d) do
		try do
			throw {:return, ((((to_string(y) <> "-") <> pad2(m)) <> "-") <> pad2(d))}
		catch {:return, v} -> v end
	end
	
	@spec day(integer(), integer(), integer()) :: integer()
	def day(y, m, d) do
		try do
			part1 = (367 * y)
			part2 = String.to_integer(((7 * String.to_integer((y + ((m + 9) / 12)))) / 4))
			part3 = String.to_integer(((275 * m) / 9))
			throw {:return, ((((part1 - part2) + part3) + d) - 730530)}
		catch {:return, v} -> v end
	end
	
	@spec biorhythms(String.t(), String.t()) :: nil
	def biorhythms(birth, target) do
		try do
			bparts = parseDate(birth)
			by = Enum.at((bparts), 0)
			bm = Enum.at((bparts), 1)
			bd = Enum.at((bparts), 2)
			tparts = parseDate(target)
			ty = Enum.at((tparts), 0)
			tm = Enum.at((tparts), 1)
			td = Enum.at((tparts), 2)
			diff = absInt((day(ty, tm, td) - day(by, bm, bd)))
			IO.inspect(((("Born " <> birth) <> ", Target ") <> target))
			IO.puts(("Day " <> to_string(diff)))
			cycles = ["Physical day ", "Emotional day", "Mental day   "]
			lengths = [23, 28, 33]
			quadrants = [["up and rising", "peak"], ["up but falling", "transition"], ["down and falling", "valley"], ["down but rising", "transition"]]
			i = 0
			_ = i
			t5 = fn t5, i ->
				try do
					if (i < 3) do
						length = Enum.at((lengths), i)
						cycle = Enum.at((cycles), i)
						position = rem(diff, length)
						quadrant = ((position * 4) / length)
						percent = sinApprox((((2 * @PI) * String.to_float(position)) / String.to_float(length)))
						_ = percent
						percent = (floor((percent * 1000)) / 10)
						description = ""
						_ = description
						if (percent > 95) do
							description = " peak"
						else
							if (percent < -95) do
								description = " valley"
							else
								if (absFloat(percent) < 5) do
									description = " critical transition"
								else
									daysToAdd = ((((quadrant + 1) * length) / 4) - position)
									res = addDays(ty, tm, td, daysToAdd)
									ny = Enum.at((res), 0)
									nm = Enum.at((res), 1)
									nd = Enum.at((res), 2)
									transition = dateString(ny, nm, nd)
									trend = Enum.at((Enum.at((quadrants), quadrant)), 0)
									next = Enum.at((Enum.at((quadrants), quadrant)), 1)
									pct = to_string(percent)
									_ = pct
									if !contains.(pct, ".") do
										pct = (pct <> ".0")
									end
									description = ((((((((" " <> pct) <> "% (") <> trend) <> ", next ") <> next) <> " ") <> transition) <> ")")
								end
							end
						end
						posStr = to_string(position)
						_ = posStr
						if (position < 10) do
							posStr = (" " <> posStr)
						end
						IO.inspect((((cycle + posStr) <> " : ") <> description))
						i = (i + 1)
						t5.(t5, i)
					else
						{:ok, i}
					end
				catch :break ->
					{:ok, i}
				end
			end
			{_, i} = t5.(t5, i)
			_ = i
			IO.puts("")
		catch {:return, v} -> v end
	end
	
	@spec main() :: nil
	def main() do
		try do
			pairs = [["1943-03-09", "1972-07-11"], ["1809-01-12", "1863-11-19"], ["1809-02-12", "1863-11-19"]]
			idx = 0
			_ = idx
			t6 = fn t6, idx ->
				try do
					if (idx < length(pairs)) do
						p = Enum.at((pairs), idx)
						biorhythms(Enum.at((p), 0), Enum.at((p), 1))
						idx = (idx + 1)
						t6.(t6, idx)
					else
						{:ok, idx}
					end
				catch :break ->
					{:ok, idx}
				end
			end
			{_, idx} = t6.(t6, idx)
			_ = idx
		catch {:return, v} -> v end
	end
	
	def main do
		main()
	end
	end
Main.main()
