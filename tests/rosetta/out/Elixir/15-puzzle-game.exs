# Generated by Mochi compiler v0.10.30 on 2025-07-19T01:02:17Z
defmodule Main do
  @solved [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
  @spec randMove() :: integer()
  def randMove() do
    try do
      throw({:return, rem(_now(), 4)})
    catch
      {:return, v} -> v
    end
  end

  @spec isSolved() :: boolean()
  def isSolved() do
    try do
      # i :: integer()
      i = 0
      _ = i

      t1 = fn t1, i ->
        try do
          if i < 16 do
            if Enum.at(board, i) != Enum.at(@solved, i) do
              throw({:return, false})
            end

            i = i + 1
            t1.(t1, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t1.(t1, i)
      _ = i
      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec isValidMove(integer()) :: map()
  def isValidMove(m) do
    try do
      if m == 0 do
        throw({:return, %{"idx" => empty - 4, "ok" => empty / 4 > 0}})
      end

      if m == 1 do
        throw({:return, %{"idx" => empty + 4, "ok" => empty / 4 < 3}})
      end

      if m == 2 do
        throw({:return, %{"idx" => empty + 1, "ok" => rem(empty, 4) < 3}})
      end

      if m == 3 do
        throw({:return, %{"idx" => empty - 1, "ok" => rem(empty, 4) > 0}})
      end

      throw({:return, %{"idx" => 0, "ok" => false}})
    catch
      {:return, v} -> v
    end
  end

  @spec doMove(integer()) :: boolean()
  def doMove(m) do
    try do
      r = isValidMove(m)

      if !Map.get(r, "ok") do
        throw({:return, false})
      end

      i = empty
      j = _int(Map.get(r, "idx"))
      tmp = Enum.at(board, i)
      board = List.replace_at(board, i, Enum.at(board, j))
      board = List.replace_at(board, j, tmp)
      empty = j
      moves = moves + 1
      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec shuffle(integer()) :: nil
  def shuffle(n) do
    try do
      # i :: integer()
      i = 0
      _ = i

      t2 = fn t2, i ->
        try do
          if i < n || isSolved() do
            if doMove(randMove()) do
              i = i + 1
            end

            t2.(t2, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t2.(t2, i)
      _ = i
    catch
      {:return, v} -> v
    end
  end

  @spec printBoard() :: nil
  def printBoard() do
    try do
      # line :: String.t()
      line = ""
      _ = line
      # i :: integer()
      i = 0
      _ = i

      t3 = fn t3, i, line ->
        try do
          if i < 16 do
            val = Enum.at(board, i)

            if val == 0 do
              line = line <> "  ."
            else
              s = to_string(val)

              if val < 10 do
                line = (line <> "  ") <> s
              else
                line = (line <> " ") <> s
              end
            end

            if rem(i, 4) == 3 do
              IO.puts(line)
              line = ""
            end

            i = i + 1
            t3.(t3, i, line)
          else
            {:ok, i, line}
          end
        catch
          :break ->
            {:ok, i, line}
        end
      end

      {_, i, line} = t3.(t3, i, line)
      _ = i
      _ = line
    catch
      {:return, v} -> v
    end
  end

  @spec playOneMove() :: nil
  def playOneMove() do
    try do
      t4 = fn t4, quit ->
        try do
          if true do
            IO.puts(("Enter move #" <> to_string(moves + 1)) <> " (U, D, L, R, or Q): ")
            s = _input()

            if s == "" do
              throw(:continue)
            end

            c = _slice_string(s, 0, 1)
            # m :: integer()
            m = 0
            _ = m

            if c == "U" || c == "u" do
              m = 0
            else
              if c == "D" || c == "d" do
                m = 1
              else
                if c == "R" || c == "r" do
                  m = 2
                else
                  if c == "L" || c == "l" do
                    m = 3
                  else
                    if c == "Q" || c == "q" do
                      IO.puts(("Quiting after " <> to_string(moves)) <> " moves.")
                      quit = true
                      throw({:return, nil})
                    else
                      IO.puts(
                        (("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" <>
                            "up, down, left, or right. You can also enter \"Q\" to quit.\n") <>
                           "Upper or lowercase is accepted and only the first non-blank\n") <>
                          "character is important (i.e. you may enter \"up\" if you like)."
                      )

                      throw(:continue)
                    end
                  end
                end
              end
            end

            if !doMove(m) do
              IO.puts("That is not a valid move at the moment.")
              throw(:continue)
            end

            throw({:return, nil})
            t4.(t4, quit)
          else
            {:ok, quit}
          end
        catch
          :break ->
            {:ok, quit}
        end
      end

      {_, quit} = t4.(t4, quit)
      _ = quit
    catch
      {:return, v} -> v
    end
  end

  @spec play() :: nil
  def play() do
    try do
      IO.puts("Starting board:")

      t5 = fn t5 ->
        try do
          if !quit && isSolved() == false do
            IO.puts("")
            printBoard()
            playOneMove()
            t5.(t5)
          else
            :ok
          end
        catch
          :break ->
            :ok
        end
      end

      t5.(t5)

      if isSolved() do
        IO.puts(("You solved the puzzle in " <> to_string(moves)) <> " moves.")
      end
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      shuffle(50)
      play()
    catch
      {:return, v} -> v
    end
  end

  def main do
    # board :: list(integer())
    board = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
    _ = board
    # empty :: integer()
    empty = 15
    _ = empty
    # moves :: integer()
    moves = 0
    _ = moves
    # quit :: boolean()
    quit = false
    _ = quit
    main()
  end

  defp _input() do
    case IO.gets("") do
      :eof -> ""
      other -> String.trim(other)
    end
  end

  defp _int(v) do
    cond do
      is_integer(v) ->
        v

      is_float(v) ->
        trunc(v)

      is_binary(v) ->
        case Integer.parse(String.trim(v)) do
          {i, ""} -> i
          _ -> raise "invalid int"
        end

      true ->
        raise "invalid int"
    end
  end

  defp _now() do
    System.os_time(:millisecond)
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
