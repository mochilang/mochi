# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:44:59Z
defmodule Main do
  @spec abs(float()) :: float()
  def abs(x) do
    try do
      if x < 0 do
        throw({:return, -x})
      end

      throw({:return, x})
    catch
      {:return, v} -> v
    end
  end

  @spec maxf(float(), float()) :: float()
  def maxf(a, b) do
    try do
      if a > b do
        throw({:return, a})
      end

      throw({:return, b})
    catch
      {:return, v} -> v
    end
  end

  @spec isClose(float(), float()) :: boolean()
  def isClose(a, b) do
    try do
      relTol = 0.000000001
      t = abs(a - b)
      u = relTol * maxf(abs(a), abs(b))
      throw({:return, t <= u})
    catch
      {:return, v} -> v
    end
  end

  @spec sqrtApprox(float()) :: float()
  def sqrtApprox(x) do
    try do
      guess = x
      _ = guess
      i = 0
      _ = i

      t1 = fn t1, guess, i ->
        try do
          if i < 10 do
            guess = (guess + x / guess) / 2
            i = i + 1
            t1.(t1, guess, i)
          else
            {:ok, guess, i}
          end
        catch
          :break ->
            {:ok, guess, i}
        end
      end

      {_, guess, i} = t1.(t1, guess, i)
      _ = guess
      _ = i
      throw({:return, guess})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      root2 = sqrtApprox(2)

      pairs = [
        [100_000_000_000_000.02, 100_000_000_000_000.02],
        [100.01, 100.011],
        [10_000_000_000_000.002 / 10000, 1_000_000_000.0000001],
        [0.001, 0.0010000001],
        [0.000000000000000000000101, 0],
        [root2 * root2, 2],
        [-root2 * root2, -2],
        [100_000_000_000_000_000, 100_000_000_000_000_000],
        [3.141592653589793, 3.141592653589793]
      ]

      for pair <- _iter(pairs) do
        a = Enum.at(pair, 0)
        b = Enum.at(pair, 1)

        s =
          (fn ->
             if isClose(a, b) do
               "≈"
             else
               "≉"
             end
           end).()

        IO.inspect((((to_string(a) <> " ") <> s) <> " ") <> to_string(b))
      end
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _iter(v) do
    if is_map(v) do
      Map.keys(v)
    else
      v
    end
  end
end

Main.main()
