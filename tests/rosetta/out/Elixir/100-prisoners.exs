# Generated by Mochi compiler v0.10.30 on 2025-07-18T12:30:33Z
defmodule Main do
  @spec shuffle(list(integer())) :: list(integer())
  def shuffle(xs) do
    try do
      # arr :: list(integer())
      arr = xs
      _ = arr
      # i :: integer()
      i = 99
      _ = i

      t1 = fn t1, arr, i ->
        try do
          if i > 0 do
            j = rem(_now(), i + 1)
            tmp = Enum.at(arr, i)
            arr = List.replace_at(arr, i, Enum.at(arr, j))
            arr = List.replace_at(arr, j, tmp)
            i = i - 1
            t1.(t1, arr, i)
          else
            {:ok, arr, i}
          end
        catch
          :break ->
            {:ok, arr, i}
        end
      end

      {_, arr, i} = t1.(t1, arr, i)
      _ = arr
      _ = i
      throw({:return, arr})
    catch
      {:return, v} -> v
    end
  end

  @spec doTrials(integer(), integer(), String.t()) :: nil
  def doTrials(trials, np, strategy) do
    try do
      # pardoned :: integer()
      pardoned = 0
      _ = pardoned
      # t :: integer()
      t = 0
      _ = t

      t2 = fn t2, pardoned, t ->
        try do
          if t < trials do
            # drawers :: list(integer())
            drawers = []
            _ = drawers
            # i :: integer()
            i = 0
            _ = i

            t3 = fn t3, drawers, i ->
              try do
                if i < 100 do
                  drawers = drawers ++ [i]
                  i = i + 1
                  t3.(t3, drawers, i)
                else
                  {:ok, drawers, i}
                end
              catch
                :break ->
                  {:ok, drawers, i}
              end
            end

            {_, drawers, i} = t3.(t3, drawers, i)
            _ = drawers
            _ = i
            drawers = shuffle(drawers)
            # p :: integer()
            p = 0
            _ = p
            # success :: boolean()
            success = true
            _ = success

            t4 = fn t4, p, success ->
              try do
                if p < np do
                  # found :: boolean()
                  found = false
                  _ = found

                  if strategy == "optimal" do
                    # prev :: integer()
                    prev = p
                    _ = prev
                    # d :: integer()
                    d = 0
                    _ = d

                    t5 = fn t5, d, found, prev ->
                      try do
                        if d < 50 do
                          this = Enum.at(drawers, prev)

                          if this == p do
                            found = true
                            throw(:break)
                          end

                          prev = this
                          d = d + 1
                          t5.(t5, d, found, prev)
                        else
                          {:ok, d, found, prev}
                        end
                      catch
                        :break ->
                          {:ok, d, found, prev}
                      end
                    end

                    {_, d, found, prev} = t5.(t5, d, found, prev)
                    _ = d
                    _ = found
                    _ = prev
                  else
                    # opened :: list(boolean())
                    opened = []
                    _ = opened
                    # k :: integer()
                    k = 0
                    _ = k

                    t6 = fn t6, k, opened ->
                      try do
                        if k < 100 do
                          opened = opened ++ [false]
                          k = k + 1
                          t6.(t6, k, opened)
                        else
                          {:ok, k, opened}
                        end
                      catch
                        :break ->
                          {:ok, k, opened}
                      end
                    end

                    {_, k, opened} = t6.(t6, k, opened)
                    _ = k
                    _ = opened
                    # d :: integer()
                    d = 0
                    _ = d

                    t7 = fn t7, d, found, opened ->
                      try do
                        if d < 50 do
                          # n :: integer()
                          n = rem(_now(), 100)
                          _ = n

                          t8 = fn t8, n ->
                            try do
                              if Enum.at(opened, n) do
                                n = rem(_now(), 100)
                                t8.(t8, n)
                              else
                                {:ok, n}
                              end
                            catch
                              :break ->
                                {:ok, n}
                            end
                          end

                          {_, n} = t8.(t8, n)
                          _ = n
                          opened = List.replace_at(opened, n, true)

                          if Enum.at(drawers, n) == p do
                            found = true
                            throw(:break)
                          end

                          d = d + 1
                          t7.(t7, d, found, opened)
                        else
                          {:ok, d, found, opened}
                        end
                      catch
                        :break ->
                          {:ok, d, found, opened}
                      end
                    end

                    {_, d, found, opened} = t7.(t7, d, found, opened)
                    _ = d
                    _ = found
                    _ = opened
                  end

                  if !found do
                    success = false
                    throw(:break)
                  end

                  p = p + 1
                  t4.(t4, p, success)
                else
                  {:ok, p, success}
                end
              catch
                :break ->
                  {:ok, p, success}
              end
            end

            {_, p, success} = t4.(t4, p, success)
            _ = p
            _ = success

            if success do
              pardoned = pardoned + 1
            end

            t = t + 1
            t2.(t2, pardoned, t)
          else
            {:ok, pardoned, t}
          end
        catch
          :break ->
            {:ok, pardoned, t}
        end
      end

      {_, pardoned, t} = t2.(t2, pardoned, t)
      _ = pardoned
      _ = t
      rf = :erlang.float(pardoned) / :erlang.float(trials) * 100

      IO.puts(
        ((((("  strategy = " <> strategy) <> "  pardoned = ") <> to_string(pardoned)) <>
            " relative frequency = ") <> to_string(rf)) <> "%"
      )
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      trials = 1000

      for np <- [10, 100] do
        IO.puts(
          ((("Results from " <> to_string(trials)) <> " trials with ") <> to_string(np)) <>
            " prisoners:\n"
        )

        for strat <- ["random", "optimal"] do
          doTrials(trials, np, strat)
        end
      end
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _now() do
    System.os_time(:millisecond)
  end
end

Main.main()
