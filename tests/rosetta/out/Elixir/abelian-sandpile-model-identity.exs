# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:49:26Z
defmodule Main do
  @spec neighborsList() :: list(list(integer()))
  def neighborsList() do
    try do
      throw(
        {:return,
         [
           [1, 3],
           [0, 2, 4],
           [1, 5],
           [0, 4, 6],
           [1, 3, 5, 7],
           [2, 4, 8],
           [3, 7],
           [4, 6, 8],
           [5, 7]
         ]}
      )
    catch
      {:return, v} -> v
    end
  end

  @spec plus(list(integer()), list(integer())) :: list(integer())
  def plus(a, b) do
    try do
      res = []
      _ = res
      i = 0
      _ = i

      t1 = fn t1, i, res ->
        try do
          if i < length(a) do
            res = res ++ [Enum.at(a, i) + Enum.at(b, i)]
            i = i + 1
            t1.(t1, i, res)
          else
            {:ok, i, res}
          end
        catch
          :break ->
            {:ok, i, res}
        end
      end

      {_, i, res} = t1.(t1, i, res)
      _ = i
      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec isStable(list(integer())) :: boolean()
  def isStable(p) do
    try do
      for v <- _iter(p) do
        if v > 3 do
          throw({:return, false})
        end
      end

      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec topple(list(integer())) :: integer()
  def topple(p) do
    try do
      neighbors = neighborsList()
      i = 0
      _ = i

      t2 = fn t2, i, p ->
        try do
          if i < length(p) do
            if Enum.at(p, i) > 3 do
              p = Map.put(p, i, Enum.at(p, i) - 4)
              nbs = Enum.at(neighbors, i)

              {p} =
                Enum.reduce(_iter(nbs), {p}, fn j, {p} ->
                  p = Map.put(p, j, Enum.at(p, j) + 1)
                  {p}
                end)

              _ = p
              throw({:return, 0})
            end

            i = i + 1
            t2.(t2, i, p)
          else
            {:ok, i, p}
          end
        catch
          :break ->
            {:ok, i, p}
        end
      end

      {_, i, p} = t2.(t2, i, p)
      _ = i
      _ = p
      throw({:return, 0})
    catch
      {:return, v} -> v
    end
  end

  @spec pileString(list(integer())) :: String.t()
  def pileString(p) do
    try do
      s = ""
      _ = s
      r = 0
      _ = r

      t3 = fn t3, r, s ->
        try do
          if r < 3 do
            c = 0
            _ = c

            t4 = fn t4, c, s ->
              try do
                if c < 3 do
                  s = (s + to_string(Enum.at(p, 3 * r + c))) <> " "
                  c = c + 1
                  t4.(t4, c, s)
                else
                  {:ok, c, s}
                end
              catch
                :break ->
                  {:ok, c, s}
              end
            end

            {_, c, s} = t4.(t4, c, s)
            _ = c
            _ = s
            s = s <> "\n"
            r = r + 1
            t3.(t3, r, s)
          else
            {:ok, r, s}
          end
        catch
          :break ->
            {:ok, r, s}
        end
      end

      {_, r, s} = t3.(t3, r, s)
      _ = r
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  def main do
    IO.puts("Avalanche of topplings:\n")
    # s4 :: list(integer())
    s4 = [4, 3, 3, 3, 1, 2, 0, 2, 3]
    _ = s4
    IO.puts(pileString(s4))

    t5 = fn t5 ->
      try do
        if !isStable(s4) do
          topple(s4)
          IO.puts(pileString(s4))
          t5.(t5)
        else
          :ok
        end
      catch
        :break ->
          :ok
      end
    end

    t5.(t5)
    IO.puts("Commutative additions:\n")
    # s1 :: list(integer())
    s1 = [1, 2, 0, 2, 1, 1, 0, 1, 3]
    _ = s1
    # s2 :: list(integer())
    s2 = [2, 1, 3, 1, 0, 1, 0, 1, 0]
    _ = s2
    # s3_a :: list(integer())
    s3_a = plus(s1, s2)
    _ = s3_a

    t6 = fn t6 ->
      try do
        if !isStable(s3_a) do
          topple(s3_a)
          t6.(t6)
        else
          :ok
        end
      catch
        :break ->
          :ok
      end
    end

    t6.(t6)
    # s3_b :: list(integer())
    s3_b = plus(s2, s1)
    _ = s3_b

    t7 = fn t7 ->
      try do
        if !isStable(s3_b) do
          topple(s3_b)
          t7.(t7)
        else
          :ok
        end
      catch
        :break ->
          :ok
      end
    end

    t7.(t7)

    IO.puts(
      (((pileString(s1) <> "\nplus\n\n") <> pileString(s2)) <> "\nequals\n\n") <> pileString(s3_a)
    )

    IO.puts(
      (((("and\n\n" <> pileString(s2)) <> "\nplus\n\n") <> pileString(s1)) <> "\nalso equals\n\n") <>
        pileString(s3_b)
    )

    IO.puts("Addition of identity sandpile:\n")
    # s3 :: list(integer())
    s3 = [3, 3, 3, 3, 3, 3, 3, 3, 3]
    _ = s3
    # s3_id :: list(integer())
    s3_id = [2, 1, 2, 1, 0, 1, 2, 1, 2]
    _ = s3_id
    # s4b :: list(integer())
    s4b = plus(s3, s3_id)
    _ = s4b

    t8 = fn t8 ->
      try do
        if !isStable(s4b) do
          topple(s4b)
          t8.(t8)
        else
          :ok
        end
      catch
        :break ->
          :ok
      end
    end

    t8.(t8)

    IO.puts(
      (((pileString(s3) <> "\nplus\n\n") <> pileString(s3_id)) <> "\nequals\n\n") <>
        pileString(s4b)
    )

    IO.puts("Addition of identities:\n")
    # s5 :: list(integer())
    s5 = plus(s3_id, s3_id)
    _ = s5

    t9 = fn t9 ->
      try do
        if !isStable(s5) do
          topple(s5)
          t9.(t9)
        else
          :ok
        end
      catch
        :break ->
          :ok
      end
    end

    t9.(t9)

    IO.puts(
      (((pileString(s3_id) <> "\nplus\n\n") <> pileString(s3_id)) <> "\nequals\n\n") <>
        pileString(s5)
    )
  end

  defp _iter(v) do
    if is_map(v) do
      Map.keys(v)
    else
      v
    end
  end
end

Main.main()
