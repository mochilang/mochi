# Generated by Mochi compiler v0.10.26 on 2025-07-16T14:09:13Z
defmodule Main do
  @spec mod(integer(), integer()) :: integer()
  def mod(n, m) do
    try do
      throw({:return, rem(rem(n, m) + m, m)})
    catch
      {:return, v} -> v
    end
  end

  @spec isPrime(integer()) :: boolean()
  def isPrime(n) do
    try do
      if n < 2 do
        throw({:return, false})
      end

      if rem(n, 2) == 0 do
        throw({:return, n == 2})
      end

      if rem(n, 3) == 0 do
        throw({:return, n == 3})
      end

      d = 5
      _ = d

      t1 = fn t1, d ->
        try do
          if d * d <= n do
            if rem(n, d) == 0 do
              throw({:return, false})
            end

            d = d + 2

            if rem(n, d) == 0 do
              throw({:return, false})
            end

            d = d + 4
            t1.(t1, d)
          else
            {:ok, d}
          end
        catch
          :break ->
            {:ok, d}
        end
      end

      {_, d} = t1.(t1, d)
      _ = d
      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec pad(integer(), integer()) :: String.t()
  def pad(n, width) do
    try do
      s = to_string(n)
      _ = s

      t2 = fn t2, s ->
        try do
          if length(s) < width do
            s = " " <> s
            t2.(t2, s)
          else
            {:ok, s}
          end
        catch
          :break ->
            {:ok, s}
        end
      end

      {_, s} = t2.(t2, s)
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec carmichael(integer()) :: nil
  def carmichael(p1) do
    try do
      _ =
        Enum.reduce_while(2..(p1 - 1), :ok, fn h3, _acc ->
          try do
            _ =
              Enum.reduce_while(1..(h3 + p1 - 1), :ok, fn d, _acc ->
                try do
                  if rem((h3 + p1) * (p1 - 1), d) == 0 && mod(-p1 * p1, h3) == rem(d, h3) do
                    p2 = 1 + (p1 - 1) * (h3 + p1) / d

                    if !isPrime(p2) do
                      throw(:continue)
                    end

                    p3 = 1 + p1 * p2 / h3

                    if !isPrime(p3) do
                      throw(:continue)
                    end

                    if rem(p2 * p3, p1 - 1) != 1 do
                      throw(:continue)
                    end

                    c = p1 * p2 * p3

                    IO.puts(
                      (((((pad(p1, 2) <> "   ") <> pad(p2, 4)) <> "   ") <> pad(p3, 5)) <> "     ") <>
                        to_string(c)
                    )
                  end

                  {:cont, :ok}
                catch
                  :break -> {:halt, :ok}
                  :continue -> {:cont, :ok}
                end
              end)

            {:cont, :ok}
          catch
            :break -> {:halt, :ok}
            :continue -> {:cont, :ok}
          end
        end)
    catch
      {:return, v} -> v
    end
  end

  def main do
    IO.puts("The following are Carmichael munbers for p1 <= 61:\n")
    IO.puts("p1     p2      p3     product")
    IO.puts("==     ==      ==     =======")

    for p1 <- 2..(62 - 1) do
      if isPrime(p1) do
        carmichael(p1)
      end
    end
  end
end

Main.main()
