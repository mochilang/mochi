# Generated by Mochi compiler v0.10.30 on 2025-07-19T01:02:35Z
defmodule Main do
  @spec fields(String.t()) :: list(String.t())
  def fields(s) do
    try do
      # words :: list(String.t())
      words = []
      _ = words
      # cur :: String.t()
      cur = ""
      _ = cur
      # i :: integer()
      i = 0
      _ = i

      t1 = fn t1, cur, i, words ->
        try do
          if i < String.length(s) do
            ch = String.slice(s, i, i + 1 - i)

            if ch == " " || ch == "\n" || ch == "\t" do
              if String.length(cur) > 0 do
                words = words ++ [cur]
                cur = ""
              end
            else
              cur = cur <> ch
            end

            i = i + 1
            t1.(t1, cur, i, words)
          else
            {:ok, cur, i, words}
          end
        catch
          :break ->
            {:ok, cur, i, words}
        end
      end

      {_, cur, i, words} = t1.(t1, cur, i, words)
      _ = cur
      _ = i
      _ = words

      if String.length(cur) > 0 do
        words = words ++ [cur]
      end

      throw({:return, words})
    catch
      {:return, v} -> v
    end
  end

  @spec padRight(String.t(), integer()) :: String.t()
  def padRight(s, width) do
    try do
      # out :: String.t()
      out = s
      _ = out
      # i :: integer()
      i = String.length(s)
      _ = i

      t2 = fn t2, i, out ->
        try do
          if i < width do
            out = out <> " "
            i = i + 1
            t2.(t2, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t2.(t2, i, out)
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec join(list(String.t()), String.t()) :: String.t()
  def join(xs, sep) do
    try do
      # res :: String.t()
      res = ""
      _ = res
      # i :: integer()
      i = 0
      _ = i

      t3 = fn t3, i, res ->
        try do
          if i < length(xs) do
            if i > 0 do
              res = res <> sep
            end

            res = res <> Enum.at(xs, i)
            i = i + 1
            t3.(t3, i, res)
          else
            {:ok, i, res}
          end
        catch
          :break ->
            {:ok, i, res}
        end
      end

      {_, i, res} = t3.(t3, i, res)
      _ = i
      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec parseIntStr(String.t()) :: integer()
  def parseIntStr(str) do
    try do
      # i :: integer()
      i = 0
      _ = i
      # neg :: boolean()
      neg = false
      _ = neg

      if String.length(str) > 0 && String.slice(str, 0, 1 - 0) == "-" do
        neg = true
        i = 1
      end

      # n :: integer()
      n = 0
      _ = n

      digits = %{
        "0" => 0,
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        "6" => 6,
        "7" => 7,
        "8" => 8,
        "9" => 9
      }

      t4 = fn t4, i, n ->
        try do
          if i < String.length(str) do
            n = n * 10 + Enum.at(digits, String.slice(str, i, i + 1 - i))
            i = i + 1
            t4.(t4, i, n)
          else
            {:ok, i, n}
          end
        catch
          :break ->
            {:ok, i, n}
        end
      end

      {_, i, n} = t4.(t4, i, n)
      _ = i
      _ = n

      if neg do
        n = -n
      end

      throw({:return, n})
    catch
      {:return, v} -> v
    end
  end

  @spec isDigits(String.t()) :: boolean()
  def isDigits(s) do
    try do
      if String.length(s) == 0 do
        throw({:return, false})
      end

      # i :: integer()
      i = 0
      _ = i

      t5 = fn t5, i ->
        try do
          if i < String.length(s) do
            ch = String.slice(s, i, i + 1 - i)

            if ch < "0" || ch > "9" do
              throw({:return, false})
            end

            i = i + 1
            t5.(t5, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t5.(t5, i)
      _ = i
      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec readTable(String.t()) :: map()
  def readTable(table) do
    try do
      toks = fields(table)
      # cmds :: list(String.t())
      cmds = []
      _ = cmds
      # mins :: list(integer())
      mins = []
      _ = mins
      # i :: integer()
      i = 0
      _ = i

      t6 = fn t6, cmds, i, mins ->
        try do
          if i < _length(toks) do
            cmd = Enum.at(toks, i)
            # minlen :: integer()
            minlen = _length(cmd)
            _ = minlen
            i = i + 1

            if i < _length(toks) && isDigits(Enum.at(toks, i)) do
              # num :: (any() -> any())
              num = parseIntStr(Enum.at(toks, i))

              if num >= 1 && num < _length(cmd) do
                minlen = num
                i = i + 1
              end
            end

            cmds = cmds ++ [cmd]
            mins = mins ++ [minlen]
            t6.(t6, cmds, i, mins)
          else
            {:ok, cmds, i, mins}
          end
        catch
          :break ->
            {:ok, cmds, i, mins}
        end
      end

      {_, cmds, i, mins} = t6.(t6, cmds, i, mins)
      _ = cmds
      _ = i
      _ = mins
      throw({:return, %{"commands" => cmds, "mins" => mins}})
    catch
      {:return, v} -> v
    end
  end

  @spec validate(list(String.t()), list(integer()), list(String.t())) :: list(String.t())
  def validate(commands, mins, words) do
    try do
      # results :: list(String.t())
      results = []
      _ = results
      # wi :: integer()
      wi = 0
      _ = wi

      t7 = fn t7, results, wi ->
        try do
          if wi < length(words) do
            w = Enum.at(words, wi)
            # found :: boolean()
            found = false
            _ = found
            wlen = _length(w)
            # ci :: integer()
            ci = 0
            _ = ci

            t8 = fn t8, ci, found, results ->
              try do
                if ci < length(commands) do
                  cmd = Enum.at(commands, ci)

                  if Enum.at(mins, ci) != 0 && wlen >= Enum.at(mins, ci) && wlen <= _length(cmd) do
                    c = upper.(cmd)
                    ww = upper.(w)

                    if String.slice(c, 0, wlen - 0) == ww do
                      results = results ++ [c]
                      found = true
                      throw(:break)
                    end
                  end

                  ci = ci + 1
                  t8.(t8, ci, found, results)
                else
                  {:ok, ci, found, results}
                end
              catch
                :break ->
                  {:ok, ci, found, results}
              end
            end

            {_, ci, found, results} = t8.(t8, ci, found, results)
            _ = ci
            _ = found
            _ = results

            if !found do
              results = results ++ ["*error*"]
            end

            wi = wi + 1
            t7.(t7, results, wi)
          else
            {:ok, results, wi}
          end
        catch
          :break ->
            {:ok, results, wi}
        end
      end

      {_, results, wi} = t7.(t7, results, wi)
      _ = results
      _ = wi
      throw({:return, results})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      table =
        ((((((("" <>
                 "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ") <>
                "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ") <>
               "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ") <>
              "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ") <>
             "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ") <>
            "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ") <>
           "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ") <>
          "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 "

      sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin"
      tbl = readTable(table)
      commands = Map.get(tbl, "commands")
      mins = Map.get(tbl, "mins")
      words = fields(sentence)
      results = validate(commands, mins, words)
      # out1 :: String.t()
      out1 = "user words:"
      _ = out1
      # k :: integer()
      k = 0
      _ = k

      t9 = fn t9, k, out1 ->
        try do
          if k < _length(words) do
            out1 = out1 <> " "

            if k < _length(words) - 1 do
              out1 = out1 <> padRight(Enum.at(words, k), _length(Enum.at(results, k)))
            else
              out1 = out1 <> Enum.at(words, k)
            end

            k = k + 1
            t9.(t9, k, out1)
          else
            {:ok, k, out1}
          end
        catch
          :break ->
            {:ok, k, out1}
        end
      end

      {_, k, out1} = t9.(t9, k, out1)
      _ = k
      _ = out1
      IO.puts(out1)
      IO.puts("full words: " <> join(results, " "))
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _length(v) do
    cond do
      is_binary(v) -> String.length(v)
      is_list(v) -> length(v)
      is_map(v) and Map.has_key?(v, :items) -> length(Map.get(v, :items))
      is_map(v) -> map_size(v)
      true -> raise "len expects list, map or string"
    end
  end
end

Main.main()
