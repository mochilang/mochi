# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:29Z
defmodule Main do
  @spec padLeft(String.t(), integer()) :: String.t()
  def padLeft(s, w) do
    try do
      res = ""
      _ = res
      n = w - length(s)
      _ = n

      t1 = fn t1, n, res ->
        try do
          if n > 0 do
            res = res <> " "
            n = n - 1
            t1.(t1, n, res)
          else
            {:ok, n, res}
          end
        catch
          :break ->
            {:ok, n, res}
        end
      end

      {_, n, res} = t1.(t1, n, res)
      _ = n
      _ = res
      throw({:return, res + s})
    catch
      {:return, v} -> v
    end
  end

  @spec indexOfFrom(String.t(), String.t(), integer()) :: integer()
  def indexOfFrom(s, ch, start) do
    try do
      i = start
      _ = i

      t2 = fn t2, i ->
        try do
          if i < length(s) do
            if _slice_string(s, i, i + 1) == ch do
              throw({:return, i})
            end

            i = i + 1
            t2.(t2, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t2.(t2, i)
      _ = i
      throw({:return, -1})
    catch
      {:return, v} -> v
    end
  end

  @spec containsStr(String.t(), String.t()) :: boolean()
  def containsStr(s, sub) do
    try do
      i = 0
      _ = i
      sl = length(s)
      subl = length(sub)

      t3 = fn t3, i ->
        try do
          if i <= sl - subl do
            if _slice_string(s, i, i + subl) == sub do
              throw({:return, true})
            end

            i = i + 1
            t3.(t3, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t3.(t3, i)
      _ = i
      throw({:return, false})
    catch
      {:return, v} -> v
    end
  end

  @spec distinct(list(String.t())) :: list(String.t())
  def distinct(slist) do
    try do
      res = []
      _ = res

      {res} =
        Enum.reduce_while(_iter(slist), {res}, fn s, {res} ->
          try do
            found = false
            _ = found

            {found} =
              Enum.reduce_while(_iter(res), {found}, fn r, {found} ->
                try do
                  if r == s do
                    found = true
                    throw(:break)
                  end

                  {:cont, {found}}
                catch
                  :break -> {:halt, {found}}
                  :continue -> {:cont, {found}}
                end
              end)

            _ = found

            if !found do
              res = res ++ [s]
            end

            {:cont, {res}}
          catch
            :break -> {:halt, {res}}
            :continue -> {:cont, {res}}
          end
        end)

      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec permutations(list(String.t())) :: list(list(String.t()))
  def permutations(xs) do
    try do
      if length(xs) <= 1 do
        throw({:return, [xs]})
      end

      res = []
      _ = res
      i = 0
      _ = i

      t4 = fn t4, i, res ->
        try do
          if i < length(xs) do
            rest = []
            _ = rest
            j = 0
            _ = j

            t5 = fn t5, j, rest ->
              try do
                if j < length(xs) do
                  if j != i do
                    rest = rest ++ [Enum.at(xs, j)]
                  end

                  j = j + 1
                  t5.(t5, j, rest)
                else
                  {:ok, j, rest}
                end
              catch
                :break ->
                  {:ok, j, rest}
              end
            end

            {_, j, rest} = t5.(t5, j, rest)
            _ = j
            _ = rest
            subs = permutations(rest)

            {res} =
              Enum.reduce(_iter(subs), {res}, fn p, {res} ->
                perm = [Enum.at(xs, i)]
                _ = perm
                k = 0
                _ = k

                t6 = fn t6, k, perm ->
                  try do
                    if k < length(p) do
                      perm = perm ++ [Enum.at(p, k)]
                      k = k + 1
                      t6.(t6, k, perm)
                    else
                      {:ok, k, perm}
                    end
                  catch
                    :break ->
                      {:ok, k, perm}
                  end
                end

                {_, k, perm} = t6.(t6, k, perm)
                _ = k
                _ = perm
                res = res ++ [perm]
                {res}
              end)

            _ = res
            i = i + 1
            t4.(t4, i, res)
          else
            {:ok, i, res}
          end
        catch
          :break ->
            {:ok, i, res}
        end
      end

      {_, i, res} = t4.(t4, i, res)
      _ = i
      _ = res
      throw({:return, res})
    catch
      {:return, v} -> v
    end
  end

  @spec headTailOverlap(String.t(), String.t()) :: integer()
  def headTailOverlap(s1, s2) do
    try do
      start = 0
      _ = start

      t7 = fn t7, start ->
        try do
          if true do
            ix = indexOfFrom(s1, Enum.slice(s2, 0, 1 - 0), start)

            if ix == 0 - 1 do
              throw({:return, 0})
            end

            start = ix

            if _slice_string(s2, 0, length(s1) - start) == _slice_string(s1, start, length(s1)) do
              throw({:return, length(s1) - start})
            end

            start = start + 1
            t7.(t7, start)
          else
            {:ok, start}
          end
        catch
          :break ->
            {:ok, start}
        end
      end

      {_, start} = t7.(t7, start)
      _ = start
    catch
      {:return, v} -> v
    end
  end

  @spec deduplicate(list(String.t())) :: list(String.t())
  def deduplicate(slist) do
    try do
      arr = distinct(slist)
      filtered = []
      _ = filtered
      i = 0
      _ = i

      t8 = fn t8, filtered, i ->
        try do
          if i < length(arr) do
            s1 = Enum.at(arr, i)
            within = false
            _ = within
            j = 0
            _ = j

            t9 = fn t9, j, within ->
              try do
                if j < length(arr) do
                  if j != i && containsStr(Enum.at(arr, j), s1) do
                    within = true
                    throw(:break)
                  end

                  j = j + 1
                  t9.(t9, j, within)
                else
                  {:ok, j, within}
                end
              catch
                :break ->
                  {:ok, j, within}
              end
            end

            {_, j, within} = t9.(t9, j, within)
            _ = j
            _ = within

            if !within do
              filtered = filtered ++ [s1]
            end

            i = i + 1
            t8.(t8, filtered, i)
          else
            {:ok, filtered, i}
          end
        catch
          :break ->
            {:ok, filtered, i}
        end
      end

      {_, filtered, i} = t8.(t8, filtered, i)
      _ = filtered
      _ = i
      throw({:return, filtered})
    catch
      {:return, v} -> v
    end
  end

  @spec joinAll(list(String.t())) :: String.t()
  def joinAll(ss) do
    try do
      out = ""
      _ = out

      {out} =
        Enum.reduce(_iter(ss), {out}, fn s, {out} ->
          out = out + s
          {out}
        end)

      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  @spec shortestCommonSuperstring(list(String.t())) :: String.t()
  def shortestCommonSuperstring(slist) do
    try do
      ss = deduplicate(slist)
      shortest = joinAll(ss)
      _ = shortest
      perms = permutations(ss)
      idx = 0
      _ = idx

      t10 = fn t10, idx, shortest ->
        try do
          if idx < length(perms) do
            perm = Enum.at(perms, idx)
            sup = Enum.at(perm, 0)
            _ = sup
            i = 0
            _ = i

            t11 = fn t11, i, sup ->
              try do
                if i < length(ss) - 1 do
                  ov = headTailOverlap(Enum.at(perm, i), Enum.at(perm, i + 1))

                  sup =
                    sup + _slice_string(Enum.at(perm, i + 1), ov, length(Enum.at(perm, i + 1)))

                  i = i + 1
                  t11.(t11, i, sup)
                else
                  {:ok, i, sup}
                end
              catch
                :break ->
                  {:ok, i, sup}
              end
            end

            {_, i, sup} = t11.(t11, i, sup)
            _ = i
            _ = sup

            if length(sup) < length(shortest) do
              shortest = sup
            end

            idx = idx + 1
            t10.(t10, idx, shortest)
          else
            {:ok, idx, shortest}
          end
        catch
          :break ->
            {:ok, idx, shortest}
        end
      end

      {_, idx, shortest} = t10.(t10, idx, shortest)
      _ = idx
      _ = shortest
      throw({:return, shortest})
    catch
      {:return, v} -> v
    end
  end

  @spec printCounts(String.t()) :: nil
  def printCounts(seq) do
    try do
      a = 0
      _ = a
      c = 0
      _ = c
      g = 0
      _ = g
      t = 0
      _ = t
      i = 0
      _ = i

      t12 = fn t12, a, c, g, i, t ->
        try do
          if i < length(seq) do
            ch = _slice_string(seq, i, i + 1)

            if ch == "A" do
              a = a + 1
            else
              if ch == "C" do
                c = c + 1
              else
                if ch == "G" do
                  g = g + 1
                else
                  if ch == "T" do
                    t = t + 1
                  end
                end
              end
            end

            i = i + 1
            t12.(t12, a, c, g, i, t)
          else
            {:ok, a, c, g, i, t}
          end
        catch
          :break ->
            {:ok, a, c, g, i, t}
        end
      end

      {_, a, c, g, i, t} = t12.(t12, a, c, g, i, t)
      _ = a
      _ = c
      _ = g
      _ = i
      _ = t
      total = length(seq)
      IO.inspect(("\nNucleotide counts for " <> seq) <> ":\n")
      IO.puts(padLeft("A", 10) + padLeft(to_string(a), 12))
      IO.puts(padLeft("C", 10) + padLeft(to_string(c), 12))
      IO.puts(padLeft("G", 10) + padLeft(to_string(g), 12))
      IO.puts(padLeft("T", 10) + padLeft(to_string(t), 12))
      IO.puts(padLeft("Other", 10) + padLeft(to_string(total - (a + c + g + t)), 12))
      IO.puts("  ____________________")
      IO.puts(padLeft("Total length", 14) + padLeft(to_string(total), 8))
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      tests = [
        ["TA", "AAG", "TA", "GAA", "TA"],
        ["CATTAGGG", "ATTAG", "GGG", "TA"],
        ["AAGAUGGA", "GGAGCGCAUC", "AUCGCAAUAAGGA"],
        [
          "ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT",
          "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT",
          "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA",
          "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC",
          "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT",
          "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC",
          "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT",
          "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC",
          "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC",
          "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT",
          "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC",
          "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA",
          "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"
        ]
      ]

      for seqs <- _iter(tests) do
        scs = shortestCommonSuperstring(seqs)
        printCounts(scs)
      end
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _iter(v) do
    if is_map(v) do
      Map.keys(v)
    else
      v
    end
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
