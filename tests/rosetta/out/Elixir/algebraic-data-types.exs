# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:44:18Z
defmodule Main do
  @spec node(String.t(), any(), integer(), any()) :: map()
  def node(cl, le, aa, ri) do
    try do
      throw({:return, %{"cl" => cl, "le" => le, "aa" => aa, "ri" => ri}})
    catch
      {:return, v} -> v
    end
  end

  @spec treeString(any()) :: String.t()
  def treeString(t) do
    try do
      if t == nil do
        throw({:return, "E"})
      end

      m = t

      throw(
        {:return,
         ((((((("T(" <> Enum.at(m, "cl")) <> ", ") <> treeString(Enum.at(m, "le"))) <> ", ") <>
              to_string(Enum.at(m, "aa"))) <> ", ") <> treeString(Enum.at(m, "ri"))) <> ")"}
      )
    catch
      {:return, v} -> v
    end
  end

  @spec balance(any()) :: any()
  def balance(t) do
    try do
      if t == nil do
        throw({:return, t})
      end

      m = t

      if Enum.at(m, "cl") != "B" do
        throw({:return, t})
      end

      le = Enum.at(m, "le")
      ri = Enum.at(m, "ri")

      if le != nil do
        leMap = le

        if Enum.at(leMap, "cl") == "R" do
          lele = Enum.at(leMap, "le")

          if lele != nil do
            leleMap = lele

            if Enum.at(leleMap, "cl") == "R" do
              throw(
                {:return,
                 node(
                   "R",
                   node(
                     "B",
                     Enum.at(leleMap, "le"),
                     Enum.at(leleMap, "aa"),
                     Enum.at(leleMap, "ri")
                   ),
                   Enum.at(leMap, "aa"),
                   node("B", Enum.at(leMap, "ri"), Enum.at(m, "aa"), ri)
                 )}
              )
            end
          end

          leri = Enum.at(leMap, "ri")

          if leri != nil do
            leriMap = leri

            if Enum.at(leriMap, "cl") == "R" do
              throw(
                {:return,
                 node(
                   "R",
                   node("B", Enum.at(leMap, "le"), Enum.at(leMap, "aa"), Enum.at(leriMap, "le")),
                   Enum.at(leriMap, "aa"),
                   node("B", Enum.at(leriMap, "ri"), Enum.at(m, "aa"), ri)
                 )}
              )
            end
          end
        end
      end

      if ri != nil do
        riMap = ri

        if Enum.at(riMap, "cl") == "R" do
          rile = Enum.at(riMap, "le")

          if rile != nil do
            rileMap = rile

            if Enum.at(rileMap, "cl") == "R" do
              throw(
                {:return,
                 node(
                   "R",
                   node("B", Enum.at(m, "le"), Enum.at(m, "aa"), Enum.at(rileMap, "le")),
                   Enum.at(rileMap, "aa"),
                   node("B", Enum.at(rileMap, "ri"), Enum.at(riMap, "aa"), Enum.at(riMap, "ri"))
                 )}
              )
            end
          end

          riri = Enum.at(riMap, "ri")

          if riri != nil do
            ririMap = riri

            if Enum.at(ririMap, "cl") == "R" do
              throw(
                {:return,
                 node(
                   "R",
                   node("B", Enum.at(m, "le"), Enum.at(m, "aa"), Enum.at(riMap, "le")),
                   Enum.at(riMap, "aa"),
                   node(
                     "B",
                     Enum.at(ririMap, "le"),
                     Enum.at(ririMap, "aa"),
                     Enum.at(ririMap, "ri")
                   )
                 )}
              )
            end
          end
        end
      end

      throw({:return, t})
    catch
      {:return, v} -> v
    end
  end

  @spec ins(any(), integer()) :: any()
  def ins(tr, x) do
    try do
      if tr == nil do
        throw({:return, node("R", nil, x, nil)})
      end

      if x < Enum.at(tr, "aa") do
        throw(
          {:return,
           balance(
             node(
               Enum.at(tr, "cl"),
               ins(Enum.at(tr, "le"), x),
               Enum.at(tr, "aa"),
               Enum.at(tr, "ri")
             )
           )}
        )
      end

      if x > Enum.at(tr, "aa") do
        throw(
          {:return,
           balance(
             node(
               Enum.at(tr, "cl"),
               Enum.at(tr, "le"),
               Enum.at(tr, "aa"),
               ins(Enum.at(tr, "ri"), x)
             )
           )}
        )
      end

      throw({:return, tr})
    catch
      {:return, v} -> v
    end
  end

  @spec insert(any(), integer()) :: any()
  def insert(tr, x) do
    try do
      t = ins(tr, x)

      if t == nil do
        throw({:return, nil})
      end

      m = t
      throw({:return, node("B", Enum.at(m, "le"), Enum.at(m, "aa"), Enum.at(m, "ri"))})
    catch
      {:return, v} -> v
    end
  end

  def main do
    # tr :: any()
    tr = nil
    _ = tr
    # i :: integer()
    i = 1
    _ = i

    t1 = fn t1, i, tr ->
      try do
        if i <= 16 do
          tr = insert(tr, i)
          i = i + 1
          t1.(t1, i, tr)
        else
          {:ok, i, tr}
        end
      catch
        :break ->
          {:ok, i, tr}
      end
    end

    {_, i, tr} = t1.(t1, i, tr)
    _ = i
    _ = tr
    IO.puts(treeString(tr))
  end
end

Main.main()
