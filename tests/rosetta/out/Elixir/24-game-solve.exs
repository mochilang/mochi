# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:49:12Z
defmodule Main do
	@OP_NUM 0
	@OP_ADD 1
	@OP_SUB 2
	@OP_MUL 3
	@OP_DIV 4
	@n_cards 4
	@goal 24
	@digit_range 9
	@spec newNum(integer()) :: map()
	def newNum(n) do
		try do
			throw {:return, %{"op" => @OP_NUM, "value" => %{"num" => n, "denom" => 1}}}
		catch {:return, v} -> v end
	end
	
	@spec exprEval(map()) :: map()
	def exprEval(x) do
		try do
			if (Enum.at((x), "op") == @OP_NUM) do
				throw {:return, Enum.at((x), "value")}
			end
			l = exprEval(Enum.at((x), "left"))
			r = exprEval(Enum.at((x), "right"))
			if (Enum.at((x), "op") == @OP_ADD) do
				throw {:return, %{"num" => ((Enum.at((l), "num") * Enum.at((r), "denom")) + (Enum.at((l), "denom") * Enum.at((r), "num"))), "denom" => (Enum.at((l), "denom") * Enum.at((r), "denom"))}}
			end
			if (Enum.at((x), "op") == @OP_SUB) do
				throw {:return, %{"num" => ((Enum.at((l), "num") * Enum.at((r), "denom")) - (Enum.at((l), "denom") * Enum.at((r), "num"))), "denom" => (Enum.at((l), "denom") * Enum.at((r), "denom"))}}
			end
			if (Enum.at((x), "op") == @OP_MUL) do
				throw {:return, %{"num" => (Enum.at((l), "num") * Enum.at((r), "num")), "denom" => (Enum.at((l), "denom") * Enum.at((r), "denom"))}}
			end
			throw {:return, %{"num" => (Enum.at((l), "num") * Enum.at((r), "denom")), "denom" => (Enum.at((l), "denom") * Enum.at((r), "num"))}}
		catch {:return, v} -> v end
	end
	
	@spec exprString(map()) :: String.t()
	def exprString(x) do
		try do
			if (Enum.at((x), "op") == @OP_NUM) do
				throw {:return, to_string(Enum.at((Enum.at((x), "value")), "num"))}
			end
			ls = exprString(Enum.at((x), "left"))
			rs = exprString(Enum.at((x), "right"))
			opstr = ""
			_ = opstr
			if (Enum.at((x), "op") == @OP_ADD) do
				opstr = " + "
			else
				if (Enum.at((x), "op") == @OP_SUB) do
					opstr = " - "
				else
					if (Enum.at((x), "op") == @OP_MUL) do
						opstr = " * "
					else
						opstr = " / "
					end
				end
			end
			throw {:return, (((("(" <> ls) <> opstr) <> rs) <> ")")}
		catch {:return, v} -> v end
	end
	
	@spec solve(list(map())) :: boolean()
	def solve(xs) do
		try do
			if (length(xs) == 1) do
				f = exprEval(Enum.at((xs), 0))
				if ((Enum.at((f), "denom") != 0) && (Enum.at((f), "num") == (Enum.at((f), "denom") * @goal))) do
					IO.puts(exprString(Enum.at((xs), 0)))
					throw {:return, true}
				end
				throw {:return, false}
			end
			i = 0
			_ = i
			t1 = fn t1, i ->
				try do
					if (i < length(xs)) do
						j = (i + 1)
						_ = j
						t2 = fn t2, j ->
							try do
								if (j < length(xs)) do
									rest = []
									_ = rest
									k = 0
									_ = k
									t3 = fn t3, k, rest ->
										try do
											if (k < length(xs)) do
												if ((k != i) && (k != j)) do
													rest = rest ++ [Enum.at((xs), k)]
												end
												k = (k + 1)
												t3.(t3, k, rest)
											else
												{:ok, k, rest}
											end
										catch :break ->
											{:ok, k, rest}
										end
									end
									{_, k, rest} = t3.(t3, k, rest)
									_ = k
									_ = rest
									a = Enum.at((xs), i)
									b = Enum.at((xs), j)
									for op <- [@OP_ADD, @OP_SUB, @OP_MUL, @OP_DIV] do
										node = %{"op" => op, "left" => a, "right" => b}
										_ = node
										if solve(rest ++ [node]) do
											throw {:return, true}
										end
									end
									node = %{"op" => @OP_SUB, "left" => b, "right" => a}
									_ = node
									if solve(rest ++ [node]) do
										throw {:return, true}
									end
									node = %{"op" => @OP_DIV, "left" => b, "right" => a}
									if solve(rest ++ [node]) do
										throw {:return, true}
									end
									j = (j + 1)
									t2.(t2, j)
								else
									{:ok, j}
								end
							catch :break ->
								{:ok, j}
							end
						end
						{_, j} = t2.(t2, j)
						_ = j
						i = (i + 1)
						t1.(t1, i)
					else
						{:ok, i}
					end
				catch :break ->
					{:ok, i}
				end
			end
			{_, i} = t1.(t1, i)
			_ = i
			throw {:return, false}
		catch {:return, v} -> v end
	end
	
	@spec main() :: nil
	def main() do
		try do
			iter = 0
			_ = iter
			t4 = fn t4, iter ->
				try do
					if (iter < 10) do
						cards = []
						_ = cards
						i = 0
						_ = i
						t5 = fn t5, cards, i ->
							try do
								if (i < @n_cards) do
									n = (rem(_now(), (@digit_range - 1)) + 1)
									cards = cards ++ [newNum(n)]
									IO.puts((" " <> to_string(n)))
									i = (i + 1)
									t5.(t5, cards, i)
								else
									{:ok, cards, i}
								end
							catch :break ->
								{:ok, cards, i}
							end
						end
						{_, cards, i} = t5.(t5, cards, i)
						_ = cards
						_ = i
						IO.puts(":  ")
						if !solve(cards) do
							IO.puts("No solution")
						end
						iter = (iter + 1)
						t4.(t4, iter)
					else
						{:ok, iter}
					end
				catch :break ->
					{:ok, iter}
				end
			end
			{_, iter} = t4.(t4, iter)
			_ = iter
		catch {:return, v} -> v end
	end
	
	def main do
		main()
	end
	defp _now() do
  System.os_time(:millisecond)
end

	end
Main.main()
