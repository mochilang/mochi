# Generated by Mochi compiler v0.10.30 on 2025-07-19T01:02:22Z
defmodule Main do
  @op_num 0
  @op_add 1
  @op_sub 2
  @op_mul 3
  @op_div 4
  @n_cards 4
  @goal 24
  @digit_range 9
  @spec newNum(integer()) :: map()
  def newNum(n) do
    try do
      throw({:return, %{"op" => @op_num, "value" => %{"num" => n, "denom" => 1}}})
    catch
      {:return, v} -> v
    end
  end

  @spec exprEval(map()) :: map()
  def exprEval(x) do
    try do
      if Map.get(x, "op") == @op_num do
        throw({:return, Map.get(x, "value")})
      end

      l = exprEval(Map.get(x, "left"))
      r = exprEval(Map.get(x, "right"))

      if Map.get(x, "op") == @op_add do
        throw(
          {:return,
           %{
             "num" =>
               Map.get(l, "num") * Map.get(r, "denom") + Map.get(l, "denom") * Map.get(r, "num"),
             "denom" => Map.get(l, "denom") * Map.get(r, "denom")
           }}
        )
      end

      if Map.get(x, "op") == @op_sub do
        throw(
          {:return,
           %{
             "num" =>
               Map.get(l, "num") * Map.get(r, "denom") - Map.get(l, "denom") * Map.get(r, "num"),
             "denom" => Map.get(l, "denom") * Map.get(r, "denom")
           }}
        )
      end

      if Map.get(x, "op") == @op_mul do
        throw(
          {:return,
           %{
             "num" => Map.get(l, "num") * Map.get(r, "num"),
             "denom" => Map.get(l, "denom") * Map.get(r, "denom")
           }}
        )
      end

      throw(
        {:return,
         %{
           "num" => Map.get(l, "num") * Map.get(r, "denom"),
           "denom" => Map.get(l, "denom") * Map.get(r, "num")
         }}
      )
    catch
      {:return, v} -> v
    end
  end

  @spec exprString(map()) :: String.t()
  def exprString(x) do
    try do
      if Map.get(x, "op") == @op_num do
        throw({:return, to_string(Map.get(Map.get(x, "value"), "num"))})
      end

      ls = exprString(Map.get(x, "left"))
      rs = exprString(Map.get(x, "right"))
      # opstr :: String.t()
      opstr = ""
      _ = opstr

      if Map.get(x, "op") == @op_add do
        opstr = " + "
      else
        if Map.get(x, "op") == @op_sub do
          opstr = " - "
        else
          if Map.get(x, "op") == @op_mul do
            opstr = " * "
          else
            opstr = " / "
          end
        end
      end

      throw({:return, ((("(" <> ls) <> opstr) <> rs) <> ")"})
    catch
      {:return, v} -> v
    end
  end

  @spec solve(list(map())) :: boolean()
  def solve(xs) do
    try do
      if length(xs) == 1 do
        f = exprEval(Enum.at(xs, 0))

        if Map.get(f, "denom") != 0 && Map.get(f, "num") == Map.get(f, "denom") * @goal do
          IO.puts(exprString(Enum.at(xs, 0)))
          throw({:return, true})
        end

        throw({:return, false})
      end

      # i :: integer()
      i = 0
      _ = i

      t1 = fn t1, i ->
        try do
          if i < length(xs) do
            # j :: integer()
            j = i + 1
            _ = j

            t2 = fn t2, j ->
              try do
                if j < length(xs) do
                  # rest :: list(map())
                  rest = []
                  _ = rest
                  # k :: integer()
                  k = 0
                  _ = k

                  t3 = fn t3, k, rest ->
                    try do
                      if k < length(xs) do
                        if k != i && k != j do
                          rest = rest ++ [Enum.at(xs, k)]
                        end

                        k = k + 1
                        t3.(t3, k, rest)
                      else
                        {:ok, k, rest}
                      end
                    catch
                      :break ->
                        {:ok, k, rest}
                    end
                  end

                  {_, k, rest} = t3.(t3, k, rest)
                  _ = k
                  _ = rest
                  a = Enum.at(xs, i)
                  b = Enum.at(xs, j)

                  for op <- [@op_add, @op_sub, @op_mul, @op_div] do
                    # node :: map()
                    node = %{"op" => op, "left" => a, "right" => b}
                    _ = node

                    if solve(rest ++ [node]) do
                      throw({:return, true})
                    end
                  end

                  # node :: map()
                  node = %{"op" => @op_sub, "left" => b, "right" => a}
                  _ = node

                  if solve(rest ++ [node]) do
                    throw({:return, true})
                  end

                  node = %{"op" => @op_div, "left" => b, "right" => a}

                  if solve(rest ++ [node]) do
                    throw({:return, true})
                  end

                  j = j + 1
                  t2.(t2, j)
                else
                  {:ok, j}
                end
              catch
                :break ->
                  {:ok, j}
              end
            end

            {_, j} = t2.(t2, j)
            _ = j
            i = i + 1
            t1.(t1, i)
          else
            {:ok, i}
          end
        catch
          :break ->
            {:ok, i}
        end
      end

      {_, i} = t1.(t1, i)
      _ = i
      throw({:return, false})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      # iter :: integer()
      iter = 0
      _ = iter

      t4 = fn t4, iter ->
        try do
          if iter < 10 do
            # cards :: list(map())
            cards = []
            _ = cards
            # i :: integer()
            i = 0
            _ = i

            t5 = fn t5, cards, i ->
              try do
                if i < @n_cards do
                  n = rem(_now(), @digit_range - 1) + 1
                  cards = cards ++ [newNum(n)]
                  IO.puts(" " <> to_string(n))
                  i = i + 1
                  t5.(t5, cards, i)
                else
                  {:ok, cards, i}
                end
              catch
                :break ->
                  {:ok, cards, i}
              end
            end

            {_, cards, i} = t5.(t5, cards, i)
            _ = cards
            _ = i
            IO.puts(":  ")

            if !solve(cards) do
              IO.puts("No solution")
            end

            iter = iter + 1
            t4.(t4, iter)
          else
            {:ok, iter}
          end
        catch
          :break ->
            {:ok, iter}
        end
      end

      {_, iter} = t4.(t4, iter)
      _ = iter
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end

  defp _now() do
    System.os_time(:millisecond)
  end
end

Main.main()
