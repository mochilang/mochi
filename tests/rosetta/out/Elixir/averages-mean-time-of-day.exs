# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:45:54Z
defmodule Main do
	@PI 3.141592653589793
	@spec sinApprox(float()) :: float()
	def sinApprox(x) do
		try do
			term = x
			_ = term
			# sum :: (any() -> float())
			sum = x
			_ = sum
			n = 1
			_ = n
			t1 = fn t1, n, sum, term ->
				try do
					if (n <= 8) do
						# denom :: (any() -> any())
						denom = String.to_float(((2 * n) * ((2 * n) + 1)))
						term = (((-term * x) * x) / denom)
						sum = (sum + term)
						n = (n + 1)
						t1.(t1, n, sum, term)
					else
						{:ok, n, sum, term}
					end
				catch :break ->
					{:ok, n, sum, term}
				end
			end
			{_, n, sum, term} = t1.(t1, n, sum, term)
			_ = n
			_ = sum
			_ = term
			throw {:return, sum}
		catch {:return, v} -> v end
	end
	
	@spec cosApprox(float()) :: float()
	def cosApprox(x) do
		try do
			term = 1
			_ = term
			# sum :: (any() -> float())
			sum = 1
			_ = sum
			n = 1
			_ = n
			t2 = fn t2, n, sum, term ->
				try do
					if (n <= 8) do
						# denom :: (any() -> any())
						denom = String.to_float((((2 * n) - 1) * (2 * n)))
						term = (((-term * x) * x) / denom)
						sum = (sum + term)
						n = (n + 1)
						t2.(t2, n, sum, term)
					else
						{:ok, n, sum, term}
					end
				catch :break ->
					{:ok, n, sum, term}
				end
			end
			{_, n, sum, term} = t2.(t2, n, sum, term)
			_ = n
			_ = sum
			_ = term
			throw {:return, sum}
		catch {:return, v} -> v end
	end
	
	@spec atanApprox(float()) :: float()
	def atanApprox(x) do
		try do
			if (x > 1) do
				throw {:return, ((@PI / 2) - (x / ((x * x) + 0.28)))}
			end
			if (x < -1) do
				throw {:return, ((-@PI / 2) - (x / ((x * x) + 0.28)))}
			end
			throw {:return, (x / (1 + ((0.28 * x) * x)))}
		catch {:return, v} -> v end
	end
	
	@spec atan2Approx(float(), float()) :: float()
	def atan2Approx(y, x) do
		try do
			if (x > 0) do
				throw {:return, atanApprox((y / x))}
			end
			if (x < 0) do
				if (y >= 0) do
					throw {:return, (atanApprox((y / x)) + @PI)}
				end
				throw {:return, (atanApprox((y / x)) - @PI)}
			end
			if (y > 0) do
				throw {:return, (@PI / 2)}
			end
			if (y < 0) do
				throw {:return, (-@PI / 2)}
			end
			throw {:return, 0}
		catch {:return, v} -> v end
	end
	
	@spec digit(String.t()) :: integer()
	def digit(ch) do
		try do
			digits = "0123456789"
			i = 0
			_ = i
			t3 = fn t3, i ->
				try do
					if (i < length(digits)) do
						if (_slice_string(digits, i, (i + 1)) == ch) do
							throw {:return, i}
						end
						i = (i + 1)
						t3.(t3, i)
					else
						{:ok, i}
					end
				catch :break ->
					{:ok, i}
				end
			end
			{_, i} = t3.(t3, i)
			_ = i
			throw {:return, 0}
		catch {:return, v} -> v end
	end
	
	@spec parseTwo(String.t(), integer()) :: integer()
	def parseTwo(s, idx) do
		try do
			throw {:return, ((digit(_slice_string(s, idx, (idx + 1))) * 10) + digit(_slice_string(s, (idx + 1), (idx + 2))))}
		catch {:return, v} -> v end
	end
	
	@spec parseSec(String.t()) :: float()
	def parseSec(s) do
		try do
			h = parseTwo(s, 0)
			m = parseTwo(s, 3)
			sec = parseTwo(s, 6)
			throw {:return, String.to_float(((((h * 60) + m) * 60) + sec))}
		catch {:return, v} -> v end
	end
	
	@spec pad(integer()) :: String.t()
	def pad(n) do
		try do
			if (n < 10) do
				throw {:return, ("0" <> to_string(n))}
			end
			throw {:return, to_string(n)}
		catch {:return, v} -> v end
	end
	
	@spec meanTime(list(String.t())) :: String.t()
	def meanTime(times) do
		try do
			ssum = 0
			_ = ssum
			csum = 0
			_ = csum
			i = 0
			_ = i
			t4 = fn t4, csum, i, ssum ->
				try do
					if (i < length(times)) do
						sec = parseSec(Enum.at((times), i))
						ang = (((sec * 2) * @PI) / 86400)
						ssum = (ssum + sinApprox(ang))
						csum = (csum + cosApprox(ang))
						i = (i + 1)
						t4.(t4, csum, i, ssum)
					else
						{:ok, csum, i, ssum}
					end
				catch :break ->
					{:ok, csum, i, ssum}
				end
			end
			{_, csum, i, ssum} = t4.(t4, csum, i, ssum)
			_ = csum
			_ = i
			_ = ssum
			theta = atan2Approx(ssum, csum)
			_ = theta
			frac = (theta / (2 * @PI))
			_ = frac
			t5 = fn t5, frac ->
				try do
					if (frac < 0) do
						frac = (frac + 1)
						t5.(t5, frac)
					else
						{:ok, frac}
					end
				catch :break ->
					{:ok, frac}
				end
			end
			{_, frac} = t5.(t5, frac)
			_ = frac
			total = (frac * 86400)
			si = String.to_integer(total)
			h = String.to_integer((si / 3600))
			m = String.to_integer((rem(si, 3600) / 60))
			s = String.to_integer(rem(si, 60))
			throw {:return, ((((pad(h) <> ":") <> pad(m)) <> ":") <> pad(s))}
		catch {:return, v} -> v end
	end
	
	@spec main() :: nil
	def main() do
		try do
			inputs = ["23:00:17", "23:40:20", "00:12:45", "00:17:19"]
			IO.puts(meanTime(inputs))
		catch {:return, v} -> v end
	end
	
	def main do
		main()
	end
	defp _slice_string(s, i, j) do
  chars = String.graphemes(s)
  n = length(chars)
  start = if i < 0, do: i + n, else: i
  finish = if j < 0, do: j + n, else: j
  start = if start < 0, do: 0, else: start
  finish = if finish > n, do: n, else: finish
  finish = if finish < start, do: start, else: finish
  Enum.slice(chars, start, finish - start) |> Enum.join()
end

	end
Main.main()
