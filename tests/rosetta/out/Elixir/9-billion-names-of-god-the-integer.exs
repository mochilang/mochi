# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:49:14Z
defmodule Main do
  @spec bigTrim(list(integer())) :: list(integer())
  def bigTrim(a) do
    try do
      n = _count(a)
      _ = n

      t1 = fn t1, a, n ->
        try do
          if n > 1 && Enum.at(a, n - 1) == 0 do
            a = Enum.slice(a, 0, n - 1 - 0)
            n = n - 1
            t1.(t1, a, n)
          else
            {:ok, a, n}
          end
        catch
          :break ->
            {:ok, a, n}
        end
      end

      {_, a, n} = t1.(t1, a, n)
      _ = a
      _ = n
      throw({:return, a})
    catch
      {:return, v} -> v
    end
  end

  @spec bigFromInt(integer()) :: list(integer())
  def bigFromInt(x) do
    try do
      if x == 0 do
        throw({:return, [0]})
      end

      digits = []
      _ = digits
      n = x
      _ = n

      t2 = fn t2, digits, n ->
        try do
          if n > 0 do
            digits = digits ++ [rem(n, 10)]
            n = n / 10
            t2.(t2, digits, n)
          else
            {:ok, digits, n}
          end
        catch
          :break ->
            {:ok, digits, n}
        end
      end

      {_, digits, n} = t2.(t2, digits, n)
      _ = digits
      _ = n
      throw({:return, digits})
    catch
      {:return, v} -> v
    end
  end

  @spec bigAdd(list(integer()), list(integer())) :: list(integer())
  def bigAdd(a, b) do
    try do
      res = []
      _ = res
      carry = 0
      _ = carry
      i = 0
      _ = i

      t3 = fn t3, carry, i, res ->
        try do
          if i < _count(a) || i < _count(b) || carry > 0 do
            av = 0
            _ = av

            if i < _count(a) do
              av = Enum.at(a, i)
            end

            bv = 0
            _ = bv

            if i < _count(b) do
              bv = Enum.at(b, i)
            end

            s = av + bv + carry
            _ = s
            res = res ++ [rem(s, 10)]
            carry = s / 10
            i = i + 1
            t3.(t3, carry, i, res)
          else
            {:ok, carry, i, res}
          end
        catch
          :break ->
            {:ok, carry, i, res}
        end
      end

      {_, carry, i, res} = t3.(t3, carry, i, res)
      _ = carry
      _ = i
      _ = res
      throw({:return, bigTrim(res)})
    catch
      {:return, v} -> v
    end
  end

  @spec bigSub(list(integer()), list(integer())) :: list(integer())
  def bigSub(a, b) do
    try do
      res = []
      _ = res
      borrow = 0
      _ = borrow
      i = 0
      _ = i

      t4 = fn t4, borrow, i, res ->
        try do
          if i < _count(a) do
            av = Enum.at(a, i)
            _ = av
            bv = 0
            _ = bv

            if i < _count(b) do
              bv = Enum.at(b, i)
            end

            diff = av - bv - borrow
            _ = diff

            if diff < 0 do
              diff = diff + 10
              borrow = 1
            else
              borrow = 0
            end

            res = res ++ [diff]
            i = i + 1
            t4.(t4, borrow, i, res)
          else
            {:ok, borrow, i, res}
          end
        catch
          :break ->
            {:ok, borrow, i, res}
        end
      end

      {_, borrow, i, res} = t4.(t4, borrow, i, res)
      _ = borrow
      _ = i
      _ = res
      throw({:return, bigTrim(res)})
    catch
      {:return, v} -> v
    end
  end

  @spec bigToString(list(integer())) :: String.t()
  def bigToString(a) do
    try do
      s = ""
      _ = s
      i = _count(a) - 1
      _ = i

      t5 = fn t5, i, s ->
        try do
          if i >= 0 do
            s = s + to_string(Enum.at(a, i))
            i = i - 1
            t5.(t5, i, s)
          else
            {:ok, i, s}
          end
        catch
          :break ->
            {:ok, i, s}
        end
      end

      {_, i, s} = t5.(t5, i, s)
      _ = i
      _ = s
      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec minInt(integer(), integer()) :: integer()
  def minInt(a, b) do
    try do
      if a < b do
        throw({:return, a})
      else
        throw({:return, b})
      end
    catch
      {:return, v} -> v
    end
  end

  @spec cumu(integer()) :: list(list(integer()))
  def cumu(n) do
    try do
      cache = [[bigFromInt(1)]]
      _ = cache
      y = 1
      _ = y

      t6 = fn t6, cache, y ->
        try do
          if y <= n do
            # row :: (integer() -> list(String.t()))
            row = [bigFromInt(0)]
            _ = row
            # x :: integer()
            x = 1
            _ = x

            t7 = fn t7, row, x ->
              try do
                if x <= y do
                  val = Enum.at(Enum.at(cache, y - x), minInt(x, y - x))
                  row = row ++ [bigAdd(Enum.at(row, _count(row) - 1), val)]
                  x = x + 1
                  t7.(t7, row, x)
                else
                  {:ok, row, x}
                end
              catch
                :break ->
                  {:ok, row, x}
              end
            end

            {_, row, x} = t7.(t7, row, x)
            _ = row
            _ = x
            cache = cache ++ [row]
            y = y + 1
            t6.(t6, cache, y)
          else
            {:ok, cache, y}
          end
        catch
          :break ->
            {:ok, cache, y}
        end
      end

      {_, cache, y} = t6.(t6, cache, y)
      _ = cache
      _ = y
      throw({:return, Enum.at(cache, n)})
    catch
      {:return, v} -> v
    end
  end

  @spec row(integer()) :: list(String.t())
  def row(n) do
    try do
      e = cumu(n)
      out = []
      _ = out
      i = 0
      _ = i

      t8 = fn t8, i, out ->
        try do
          if i < n do
            diff = bigSub(Enum.at(e, i + 1), Enum.at(e, i))
            out = out ++ [bigToString(diff)]
            i = i + 1
            t8.(t8, i, out)
          else
            {:ok, i, out}
          end
        catch
          :break ->
            {:ok, i, out}
        end
      end

      {_, i, out} = t8.(t8, i, out)
      _ = i
      _ = out
      throw({:return, out})
    catch
      {:return, v} -> v
    end
  end

  def main do
    IO.puts("rows:")
    # x :: integer()
    x = 1
    _ = x

    t9 = fn t9, x ->
      try do
        if x < 11 do
          r = row(x)
          line = ""
          _ = line
          i = 0
          _ = i

          t10 = fn t10, i, line ->
            try do
              if i < _count(r) do
                line = ((line <> " ") <> Enum.at(r, i)) <> " "
                i = i + 1
                t10.(t10, i, line)
              else
                {:ok, i, line}
              end
            catch
              :break ->
                {:ok, i, line}
            end
          end

          {_, i, line} = t10.(t10, i, line)
          _ = i
          _ = line
          IO.inspect(line)
          x = x + 1
          t9.(t9, x)
        else
          {:ok, x}
        end
      catch
        :break ->
          {:ok, x}
      end
    end

    {_, x} = t9.(t9, x)
    _ = x
    IO.puts("")
    IO.puts("sums:")

    for num <- [23, 123, 1234] do
      r = cumu(num)
      IO.puts((to_string(num) <> " ") <> bigToString(Enum.at(r, _count(r) - 1)))
    end
  end

  defp _count(v) do
    cond do
      is_list(v) -> length(v)
      is_map(v) and Map.has_key?(v, :items) -> length(Map.get(v, :items))
      true -> raise "count() expects list or group"
    end
  end
end

Main.main()
