# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:44:17Z
defmodule Main do
  @spec poly(integer()) :: String.t()
  def poly(p) do
    try do
      s = ""
      _ = s
      coef = 1
      _ = coef
      i = p
      _ = i

      if coef != 1 do
        s = s + to_string(coef)
      end

      t1 = fn t1, coef, i, s ->
        try do
          if i > 0 do
            s = s <> "x"

            if i != 1 do
              s = (s <> "^") <> to_string(i)
            end

            coef = String.to_integer(coef * i / (p - i + 1))
            d = coef
            _ = d

            if rem(p - (i - 1), 2) == 1 do
              d = -d
            end

            if d < 0 do
              s = (s <> " - ") <> to_string(-d)
            else
              s = (s <> " + ") <> to_string(d)
            end

            i = i - 1
            t1.(t1, coef, i, s)
          else
            {:ok, coef, i, s}
          end
        catch
          :break ->
            {:ok, coef, i, s}
        end
      end

      {_, coef, i, s} = t1.(t1, coef, i, s)
      _ = coef
      _ = i
      _ = s

      if s == "" do
        s = "1"
      end

      throw({:return, s})
    catch
      {:return, v} -> v
    end
  end

  @spec aks(integer()) :: boolean()
  def aks(n) do
    try do
      if n < 2 do
        throw({:return, false})
      end

      c = n
      _ = c
      i = 1
      _ = i

      t2 = fn t2, c, i ->
        try do
          if i < n do
            if rem(c, n) != 0 do
              throw({:return, false})
            end

            c = String.to_integer(c * (n - i) / (i + 1))
            i = i + 1
            t2.(t2, c, i)
          else
            {:ok, c, i}
          end
        catch
          :break ->
            {:ok, c, i}
        end
      end

      {_, c, i} = t2.(t2, c, i)
      _ = c
      _ = i
      throw({:return, true})
    catch
      {:return, v} -> v
    end
  end

  @spec main() :: nil
  def main() do
    try do
      p = 0
      _ = p

      t3 = fn t3, p ->
        try do
          if p <= 7 do
            IO.puts((to_string(p) <> ":  ") <> poly(p))
            p = p + 1
            t3.(t3, p)
          else
            {:ok, p}
          end
        catch
          :break ->
            {:ok, p}
        end
      end

      {_, p} = t3.(t3, p)
      _ = p
      # first :: (list(any()) -> any())
      first = true
      _ = first
      p = 2
      line = ""
      _ = line

      t4 = fn t4, first, line, p ->
        try do
          if p < 50 do
            if aks(p) do
              if first do
                line = line + to_string(p)
                first = false
              else
                line = (line <> " ") <> to_string(p)
              end
            end

            p = p + 1
            t4.(t4, first, line, p)
          else
            {:ok, first, line, p}
          end
        catch
          :break ->
            {:ok, first, line, p}
        end
      end

      {_, first, line, p} = t4.(t4, first, line, p)
      _ = first
      _ = line
      _ = p
      IO.inspect(line)
    catch
      {:return, v} -> v
    end
  end

  def main do
    main()
  end
end

Main.main()
