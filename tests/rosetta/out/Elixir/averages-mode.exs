# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:00Z
defmodule Main do
  def main do
    # arr1 :: list(integer())
    arr1 = [2, 7, 1, 8, 2]
    _ = arr1
    # counts1 :: map()
    counts1 = %{}
    _ = counts1
    # keys1 :: list(integer())
    keys1 = []
    _ = keys1
    # i :: integer()
    i = 0
    _ = i

    t1 = fn t1, counts1, i, keys1 ->
      try do
        if i < length(arr1) do
          v = Enum.at(arr1, i)

          if if is_map(counts1), do: Map.has_key?(counts1, v), else: Enum.member?(counts1, v) do
            counts1 = Map.put(counts1, v, Map.get(counts1, v) + 1)
          else
            counts1 = Map.put(counts1, v, 1)
            keys1 = keys1 ++ [v]
          end

          i = i + 1
          t1.(t1, counts1, i, keys1)
        else
          {:ok, counts1, i, keys1}
        end
      catch
        :break ->
          {:ok, counts1, i, keys1}
      end
    end

    {_, counts1, i, keys1} = t1.(t1, counts1, i, keys1)
    _ = counts1
    _ = i
    _ = keys1
    # max1 :: integer()
    max1 = 0
    _ = max1
    i = 0

    t2 = fn t2, i, max1 ->
      try do
        if i < length(keys1) do
          k = Enum.at(keys1, i)
          c = Map.get(counts1, k)

          if c > max1 do
            max1 = c
          end

          i = i + 1
          t2.(t2, i, max1)
        else
          {:ok, i, max1}
        end
      catch
        :break ->
          {:ok, i, max1}
      end
    end

    {_, i, max1} = t2.(t2, i, max1)
    _ = i
    _ = max1
    # modes1 :: list(integer())
    modes1 = []
    _ = modes1
    i = 0

    t3 = fn t3, i, modes1 ->
      try do
        if i < length(keys1) do
          k = Enum.at(keys1, i)

          if Map.get(counts1, k) == max1 do
            modes1 = modes1 ++ [k]
          end

          i = i + 1
          t3.(t3, i, modes1)
        else
          {:ok, i, modes1}
        end
      catch
        :break ->
          {:ok, i, modes1}
      end
    end

    {_, i, modes1} = t3.(t3, i, modes1)
    _ = i
    _ = modes1
    IO.puts(to_string(modes1))
    # arr2 :: list(integer())
    arr2 = [2, 7, 1, 8, 2, 8]
    _ = arr2
    # counts2 :: map()
    counts2 = %{}
    _ = counts2
    # keys2 :: list(integer())
    keys2 = []
    _ = keys2
    i = 0

    t4 = fn t4, counts2, i, keys2 ->
      try do
        if i < length(arr2) do
          v = Enum.at(arr2, i)

          if if is_map(counts2), do: Map.has_key?(counts2, v), else: Enum.member?(counts2, v) do
            counts2 = Map.put(counts2, v, Map.get(counts2, v) + 1)
          else
            counts2 = Map.put(counts2, v, 1)
            keys2 = keys2 ++ [v]
          end

          i = i + 1
          t4.(t4, counts2, i, keys2)
        else
          {:ok, counts2, i, keys2}
        end
      catch
        :break ->
          {:ok, counts2, i, keys2}
      end
    end

    {_, counts2, i, keys2} = t4.(t4, counts2, i, keys2)
    _ = counts2
    _ = i
    _ = keys2
    # max2 :: integer()
    max2 = 0
    _ = max2
    i = 0

    t5 = fn t5, i, max2 ->
      try do
        if i < length(keys2) do
          k = Enum.at(keys2, i)
          c = Map.get(counts2, k)

          if c > max2 do
            max2 = c
          end

          i = i + 1
          t5.(t5, i, max2)
        else
          {:ok, i, max2}
        end
      catch
        :break ->
          {:ok, i, max2}
      end
    end

    {_, i, max2} = t5.(t5, i, max2)
    _ = i
    _ = max2
    # modes2 :: list(integer())
    modes2 = []
    _ = modes2
    i = 0

    t6 = fn t6, i, modes2 ->
      try do
        if i < length(keys2) do
          k = Enum.at(keys2, i)

          if Map.get(counts2, k) == max2 do
            modes2 = modes2 ++ [k]
          end

          i = i + 1
          t6.(t6, i, modes2)
        else
          {:ok, i, modes2}
        end
      catch
        :break ->
          {:ok, i, modes2}
      end
    end

    {_, i, modes2} = t6.(t6, i, modes2)
    _ = i
    _ = modes2
    IO.puts(to_string(modes2))
  end
end

Main.main()
