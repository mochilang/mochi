# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:44:43Z
defmodule Main do
	@PI 3.141592653589793
	@L 10
	@G 9.81
	@dt 0.2
	@spec sinApprox(float()) :: float()
	def sinApprox(x) do
		try do
			term = x
			_ = term
			# sum :: (any() -> float())
			sum = x
			_ = sum
			n = 1
			_ = n
			t1 = fn t1, n, sum, term ->
				try do
					if (n <= 10) do
						# denom :: (any() -> any())
						denom = String.to_float(((2 * n) * ((2 * n) + 1)))
						term = (((-term * x) * x) / denom)
						sum = (sum + term)
						n = (n + 1)
						t1.(t1, n, sum, term)
					else
						{:ok, n, sum, term}
					end
				catch :break ->
					{:ok, n, sum, term}
				end
			end
			{_, n, sum, term} = t1.(t1, n, sum, term)
			_ = n
			_ = sum
			_ = term
			throw {:return, sum}
		catch {:return, v} -> v end
	end
	
	@spec cosApprox(float()) :: float()
	def cosApprox(x) do
		try do
			term = 1
			_ = term
			# sum :: (any() -> float())
			sum = 1
			_ = sum
			n = 1
			_ = n
			t2 = fn t2, n, sum, term ->
				try do
					if (n <= 10) do
						# denom :: (any() -> any())
						denom = String.to_float((((2 * n) - 1) * (2 * n)))
						term = (((-term * x) * x) / denom)
						sum = (sum + term)
						n = (n + 1)
						t2.(t2, n, sum, term)
					else
						{:ok, n, sum, term}
					end
				catch :break ->
					{:ok, n, sum, term}
				end
			end
			{_, n, sum, term} = t2.(t2, n, sum, term)
			_ = n
			_ = sum
			_ = term
			throw {:return, sum}
		catch {:return, v} -> v end
	end
	
	@spec sqrtApprox(float()) :: float()
	def sqrtApprox(x) do
		try do
			guess = x
			_ = guess
			i = 0
			_ = i
			t3 = fn t3, guess, i ->
				try do
					if (i < 10) do
						guess = ((guess + (x / guess)) / 2)
						i = (i + 1)
						t3.(t3, guess, i)
					else
						{:ok, guess, i}
					end
				catch :break ->
					{:ok, guess, i}
				end
			end
			{_, guess, i} = t3.(t3, guess, i)
			_ = guess
			_ = i
			throw {:return, guess}
		catch {:return, v} -> v end
	end
	
	def main do
		# phi0 :: float()
		phi0 = (@PI / 4)
		# omega :: float()
		omega = sqrtApprox((@G / @L))
		# t :: float()
		t = 0
		_ = t
		{t} = Enum.reduce(0..(10 - 1), {t}, fn step, {t} ->
			phi = (phi0 * cosApprox((omega * t)))
			pos = String.to_integer(((10 * sinApprox(phi)) + 0.5))
			IO.puts(to_string(pos))
			t = (t + @dt)
			{t}
		end)
		_ = t
	end
	end
Main.main()
