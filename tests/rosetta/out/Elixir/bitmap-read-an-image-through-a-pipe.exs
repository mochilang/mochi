# Generated by Mochi compiler v0.10.26 on 2025-07-16T12:46:47Z
defmodule Main do
  @ppmData "P3\n2 2\n1\n0 1 1 0 1 0 0 1 1 1 0 0\n"
  @spec parseIntStr(String.t()) :: integer()
  def parseIntStr(str) do
    try do
      i = 0
      _ = i
      neg = false
      _ = neg

      if length(str) > 0 && Enum.slice(str, 0, 1 - 0) == "-" do
        neg = true
        i = 1
      end

      n = 0
      _ = n

      digits = %{
        "0" => 0,
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        "6" => 6,
        "7" => 7,
        "8" => 8,
        "9" => 9
      }

      t1 = fn t1, i, n ->
        try do
          if i < length(str) do
            n = n * 10 + Enum.at(digits, Enum.slice(str, i, i + 1 - i))
            i = i + 1
            t1.(t1, i, n)
          else
            {:ok, i, n}
          end
        catch
          :break ->
            {:ok, i, n}
        end
      end

      {_, i, n} = t1.(t1, i, n)
      _ = i
      _ = n

      if neg do
        n = -n
      end

      throw({:return, n})
    catch
      {:return, v} -> v
    end
  end

  @spec splitWs(String.t()) :: list(String.t())
  def splitWs(s) do
    try do
      parts = []
      _ = parts
      cur = ""
      _ = cur
      i = 0
      _ = i

      t2 = fn t2, cur, i, parts ->
        try do
          if i < length(s) do
            ch = _slice_string(s, i, i + 1)

            if ch == " " || ch == "\n" || ch == "\t" || ch == "\r" do
              if length(cur) > 0 do
                parts = parts ++ [cur]
                cur = ""
              end
            else
              cur = cur + ch
            end

            i = i + 1
            t2.(t2, cur, i, parts)
          else
            {:ok, cur, i, parts}
          end
        catch
          :break ->
            {:ok, cur, i, parts}
        end
      end

      {_, cur, i, parts} = t2.(t2, cur, i, parts)
      _ = cur
      _ = i
      _ = parts

      if length(cur) > 0 do
        parts = parts ++ [cur]
      end

      throw({:return, parts})
    catch
      {:return, v} -> v
    end
  end

  @spec parsePpm(String.t()) :: map()
  def parsePpm(data) do
    try do
      toks = splitWs(data)

      if length(toks) < 4 do
        throw({:return, %{"err" => true}})
      end

      magic = Enum.at(toks, 0)
      w = parseIntStr(Enum.at(toks, 1))
      h = parseIntStr(Enum.at(toks, 2))
      maxv = parseIntStr(Enum.at(toks, 3))
      px = []
      _ = px
      i = 4
      _ = i

      t3 = fn t3, i, px ->
        try do
          if i < length(toks) do
            px = px ++ [parseIntStr(Enum.at(toks, i))]
            i = i + 1
            t3.(t3, i, px)
          else
            {:ok, i, px}
          end
        catch
          :break ->
            {:ok, i, px}
        end
      end

      {_, i, px} = t3.(t3, i, px)
      _ = i
      _ = px
      throw({:return, %{"magic" => magic, "w" => w, "h" => h, "max" => maxv, "px" => px}})
    catch
      {:return, v} -> v
    end
  end

  def main do
    # img :: map()
    img = parsePpm(@ppmData)
    IO.puts((("width=" <> to_string(img.w)) <> " height=") <> to_string(img.h))
  end

  defp _slice_string(s, i, j) do
    chars = String.graphemes(s)
    n = length(chars)
    start = if i < 0, do: i + n, else: i
    finish = if j < 0, do: j + n, else: j
    start = if start < 0, do: 0, else: start
    finish = if finish > n, do: n, else: finish
    finish = if finish < start, do: start, else: finish
    Enum.slice(chars, start, finish - start) |> Enum.join()
  end
end

Main.main()
