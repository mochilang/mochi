# Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
from __future__ import annotations
import time
from typing import Any, TypeVar, Generic, Callable

T = TypeVar("T")
K = TypeVar("K")
UNDEFINED = object()
import sys

sys.set_int_max_str_digits(0)


def _input():
    try:
        return input()
    except EOFError:
        return ""


def _int(v):
    try:
        return int(v)
    except Exception:
        return 0


import os, time

_now_seeded = False
_now_seed = 0


def _now():
    global _now_seeded, _now_seed
    if not _now_seeded:
        s = os.getenv("MOCHI_NOW_SEED")
        if s and s.isdigit():
            _now_seed = int(s)
            _now_seeded = True
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def randMove():
    return _now() % 4


def isSolved():
    i = 0
    while i < 16:
        if board[i] != solved[i]:
            return False
        i = i + 1
    return True


def isValidMove(m):
    if m == 0:
        return {"idx": empty - 4, "ok": empty // 4 > 0}
    if m == 1:
        return {"idx": empty + 4, "ok": empty // 4 < 3}
    if m == 2:
        return {"idx": empty + 1, "ok": empty % 4 < 3}
    if m == 3:
        return {"idx": empty - 1, "ok": empty % 4 > 0}
    return {"idx": 0, "ok": False}


def doMove(m):
    global board
    global empty
    global moves
    r = isValidMove(m)
    if not r["ok"]:
        return False
    i = empty
    j = _int(r["idx"])
    tmp = board[i]
    board[i] = board[j]
    board[j] = tmp
    empty = j
    moves = moves + 1
    return True


def shuffle(n):
    i = 0
    while i < n or isSolved():
        if doMove(randMove()):
            i = i + 1


def printBoard():
    line = ""
    i = 0
    while i < 16:
        val = board[i]
        if val == 0:
            line = line + "  ."
        else:
            s = str(val)
            if val < 10:
                line = line + "  " + s
            else:
                line = line + " " + s
        if i % 4 == 3:
            print(line)
            line = ""
        i = i + 1


def playOneMove():
    global quit
    while True:
        print("Enter move #" + str(moves + 1) + " (U, D, L, R, or Q): ")
        s = _input()
        if s == "":
            continue
        c = s[0:1]
        m = 0
        if c == "U" or c == "u":
            m = 0
        elif c == "D" or c == "d":
            m = 1
        elif c == "R" or c == "r":
            m = 2
        elif c == "L" or c == "l":
            m = 3
        elif c == "Q" or c == "q":
            print("Quiting after " + str(moves) + " moves.")
            quit = True
            return
        else:
            print(
                'Please enter "U", "D", "L", or "R" to move the empty cell\n'
                + 'up, down, left, or right. You can also enter "Q" to quit.\n'
                + "Upper or lowercase is accepted and only the first non-blank\n"
                + 'character is important (i.e. you may enter "up" if you like).'
            )
            continue
        if not doMove(m):
            print("That is not a valid move at the moment.")
            continue
        return


def play():
    print("Starting board:")
    while not quit and isSolved() == False:
        print("")
        printBoard()
        playOneMove()
    if isSolved():
        print("You solved the puzzle in " + str(moves) + " moves.")


def main():
    shuffle(50)
    play()


board = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
solved = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
empty = 15
moves = 0
quit = False
main()
