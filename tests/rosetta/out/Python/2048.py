# Generated by Mochi compiler v0.10.28 on 2025-07-18T09:21:24Z
from __future__ import annotations
import time


def newBoard():
    b = []
    y = 0
    while y < SIZE:
        row = []
        x = 0
        while x < SIZE:
            row = row + [0]
            x = x + 1
        b = b + [row]
        y = y + 1
    return b


def spawnTile(b):
    empty = []
    y = 0
    while y < SIZE:
        x = 0
        while x < SIZE:
            if b[y][x] == 0:
                empty = empty + [[x, y]]
            x = x + 1
        y = y + 1
    if len(empty) == 0:
        return {"board": b, "full": True}
    idx = time.time_ns() % len(empty)
    cell = empty[idx]
    val = 4
    if time.time_ns() % 10 < 9:
        val = 2
    b[cell[1]][cell[0]] = val
    return {"board": b, "full": len(empty) == 1}


def pad(n):
    s = str(n)
    pad = 4 - len(s)
    i = 0
    out = ""
    while i < pad:
        out = out + " "
        i = i + 1
    return out + s


def draw(b, score):
    print("Score: " + str(score))
    y = 0
    while y < SIZE:
        print("+----+----+----+----+")
        line = "|"
        x = 0
        while x < SIZE:
            v = b[y][x]
            if v == 0:
                line = line + "    |"
            else:
                line = line + pad(v) + "|"
            x = x + 1
        print(line)
        y = y + 1
    print("+----+----+----+----+")
    print("W=Up S=Down A=Left D=Right Q=Quit")


def reverseRow(r):
    out = []
    i = len(r) - 1
    while i >= 0:
        out = out + [r[i]]
        i = i - 1
    return out


def slideLeft(row):
    xs = []
    i = 0
    while i < len(row):
        if row[i] != 0:
            xs = xs + [row[i]]
        i = i + 1
    res = []
    gain = 0
    i = 0
    while i < len(xs):
        if i + 1 < len(xs) and xs[i] == xs[i + 1]:
            v = xs[i] * 2
            gain = gain + v
            res = res + [v]
            i = i + 2
        else:
            res = res + [xs[i]]
            i = i + 1
    while len(res) < SIZE:
        res = res + [0]
    return {"row": res, "gain": gain}


def moveLeft(b, score):
    moved = False
    y = 0
    while y < SIZE:
        r = slideLeft(b[y])
        new = r["row"]
        score = score + r["gain"]
        x = 0
        while x < SIZE:
            if b[y][x] != new[x]:
                moved = True
            b[y][x] = new[x]
            x = x + 1
        y = y + 1
    return {"board": b, "score": score, "moved": moved}


def moveRight(b, score):
    moved = False
    y = 0
    while y < SIZE:
        rev = reverseRow(b[y])
        r = slideLeft(rev)
        rev = r["row"]
        score = score + r["gain"]
        rev = reverseRow(rev)
        x = 0
        while x < SIZE:
            if b[y][x] != rev[x]:
                moved = True
            b[y][x] = rev[x]
            x = x + 1
        y = y + 1
    return {"board": b, "score": score, "moved": moved}


def getCol(b, x):
    col = []
    y = 0
    while y < SIZE:
        col = col + [b[y][x]]
        y = y + 1
    return col


def setCol(b, x, col):
    y = 0
    while y < SIZE:
        b[y][x] = col[y]
        y = y + 1


def moveUp(b, score):
    moved = False
    x = 0
    while x < SIZE:
        col = getCol(b, x)
        r = slideLeft(col)
        new = r["row"]
        score = score + r["gain"]
        y = 0
        while y < SIZE:
            if b[y][x] != new[y]:
                moved = True
            b[y][x] = new[y]
            y = y + 1
        x = x + 1
    return {"board": b, "score": score, "moved": moved}


def moveDown(b, score):
    moved = False
    x = 0
    while x < SIZE:
        col = reverseRow(getCol(b, x))
        r = slideLeft(col)
        col = r["row"]
        score = score + r["gain"]
        col = reverseRow(col)
        y = 0
        while y < SIZE:
            if b[y][x] != col[y]:
                moved = True
            b[y][x] = col[y]
            y = y + 1
        x = x + 1
    return {"board": b, "score": score, "moved": moved}


def hasMoves(b):
    y = 0
    while y < SIZE:
        x = 0
        while x < SIZE:
            if b[y][x] == 0:
                return True
            if x + 1 < SIZE and b[y][x] == b[y][x + 1]:
                return True
            if y + 1 < SIZE and b[y][x] == b[y + 1][x]:
                return True
            x = x + 1
        y = y + 1
    return False


def has2048(b):
    y = 0
    while y < SIZE:
        x = 0
        while x < SIZE:
            if b[y][x] >= 2048:
                return True
            x = x + 1
        y = y + 1
    return False


SIZE = 4
board = newBoard()
r = spawnTile(board)
board = r["board"]
full = r["full"]
r = spawnTile(board)
board = r["board"]
full = r["full"]
score = 0
draw(board, score)
while True:
    print("Move: ")
    cmd = input()
    moved = False
    if cmd == "a" or cmd == "A":
        m = moveLeft(board, score)
        board = m["board"]
        score = m["score"]
        moved = m["moved"]
    if cmd == "d" or cmd == "D":
        m = moveRight(board, score)
        board = m["board"]
        score = m["score"]
        moved = m["moved"]
    if cmd == "w" or cmd == "W":
        m = moveUp(board, score)
        board = m["board"]
        score = m["score"]
        moved = m["moved"]
    if cmd == "s" or cmd == "S":
        m = moveDown(board, score)
        board = m["board"]
        score = m["score"]
        moved = m["moved"]
    if cmd == "q" or cmd == "Q":
        break
    if moved:
        r2 = spawnTile(board)
        board = r2["board"]
        full = r2["full"]
        if full and (not hasMoves(board)):
            draw(board, score)
            print("Game Over")
            break
    draw(board, score)
    if has2048(board):
        print("You win!")
        break
    if not hasMoves(board):
        print("Game Over")
        break
