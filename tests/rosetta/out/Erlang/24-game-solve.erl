#!/usr/bin/env escript
% Generated by Mochi compiler v0.10.26 on 2025-07-16T12:06:03Z
% 24-game-solve.erl - generated from 24-game-solve.mochi

newNum(N) ->
    #{"op" => 0, "value" => #{"num" => N, "denom" => 1}}.

exprEval(X) ->
    (case (mochi_get("op", X) == 0) of true -> mochi_get("value", X); _ -> ok end),
    L = exprEval(mochi_get("left", X)),
    R = exprEval(mochi_get("right", X)),
    (case (mochi_get("op", X) == 1) of true -> #{"num" => ((mochi_get("num", L) * mochi_get("denom", R)) + (mochi_get("denom", L) * mochi_get("num", R))), "denom" => (mochi_get("denom", L) * mochi_get("denom", R))}; _ -> ok end),
    (case (mochi_get("op", X) == 2) of true -> #{"num" => ((mochi_get("num", L) * mochi_get("denom", R)) - (mochi_get("denom", L) * mochi_get("num", R))), "denom" => (mochi_get("denom", L) * mochi_get("denom", R))}; _ -> ok end),
    (case (mochi_get("op", X) == 3) of true -> #{"num" => (mochi_get("num", L) * mochi_get("num", R)), "denom" => (mochi_get("denom", L) * mochi_get("denom", R))}; _ -> ok end),
    #{"num" => (mochi_get("num", L) * mochi_get("denom", R)), "denom" => (mochi_get("denom", L) * mochi_get("num", R))}.

exprString(X) ->
    (case (mochi_get("op", X) == 0) of true -> lists:flatten(io_lib:format("~p", [mochi_get("num", mochi_get("value", X))])); _ -> ok end),
    Ls = exprString(mochi_get("left", X)),
    Rs = exprString(mochi_get("right", X)),
    Opstr0 = "",
    (case (mochi_get("op", X) == 1) of true -> Opstr1 = " + "; _ -> (case (mochi_get("op", X) == 2) of true -> Opstr2 = " - "; _ -> (case (mochi_get("op", X) == 3) of true -> Opstr3 = " * "; _ -> Opstr4 = " / " end) end) end),
    "(" ++ Ls ++ Opstr4 ++ Rs ++ ")".

solve(Xs) ->
    (case (length(Xs) == 1) of true -> F = exprEval(lists:nth((0)+1, Xs)), (case ((mochi_get("denom", F) /= 0) andalso (mochi_get("num", F) == (mochi_get("denom", F) * 24))) of true -> io:format("~p~n", [exprString(lists:nth((0)+1, Xs))]), true; _ -> ok end), false; _ -> ok end),
    I0 = 0,
    (fun Loop2(I) -> case (I < length(Xs)) of true -> J0 = (I + 1), (fun Loop1(J, Node) -> case (J < length(Xs)) of true -> Rest0 = [], K0 = 0, (fun Loop0(K) -> case (K < length(Xs)) of true -> (case ((K /= I) andalso (K /= J)) of true -> Rest1 = Rest0 ++ [lists:nth((K)+1, Xs)]; _ -> ok end), K1 = (K + 1), Loop0(K1); _ -> ok end end)(K0), A = lists:nth((I)+1, Xs), B = lists:nth((J)+1, Xs), lists:foreach(fun(Op) -> Node0 = #{"op" => Op, "left" => A, "right" => B}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end) end, [1, 2, 3, 4]), Node1 = #{"op" => 2, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end), Node2 = #{"op" => 4, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node2]) of undefined -> ok; false -> ok; _ -> true end), J1 = (J + 1), Loop1(Node2, J1); _ -> ok end end)(J0, Node), I1 = (I + 1), Loop2(I1); _ -> ok end end)(I0),
    false.

main() ->
    Iter0 = 0,
    (fun Loop4(Iter) -> case (Iter < 10) of true -> Cards0 = [], I2 = 0, (fun Loop3(I, Cards) -> case (I < 4) of true -> N = (((now() rem ((9 - 1)))) + 1), Cards1 = Cards ++ [newNum(N)], io:format("~p~n", [" " ++ lists:flatten(io_lib:format("~p", [N]))]), I3 = (I + 1), Loop3(Cards1, I3); _ -> ok end end)(I2, Cards0), io:format("~p~n", [":  "]), (case not solve(Cards1) of true -> io:format("~p~n", ["No solution"]); _ -> ok end), Iter1 = (Iter + 1), Loop4(Iter1); _ -> ok end end)(Iter0).

main(_) ->
    main().

mochi_get(K, M) ->
    case maps:find(K, M) of
        {ok, V} -> V;
        error ->
            Name = atom_to_list(K),
            case string:tokens(Name, "_") of
                [Pref|_] ->
                    P = list_to_atom(Pref),
                    case maps:find(P, M) of
                        {ok, Sub} when is_map(Sub) -> maps:get(K, Sub, undefined);
                        _ -> undefined
                    end;
                _ -> undefined
            end
        end.
