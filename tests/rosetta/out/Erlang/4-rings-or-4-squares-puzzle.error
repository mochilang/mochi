run: exit status 127
/tmp/4-rings-or-4-squares-puzzle.erl:21:833: variable 'Count1' unsafe in 'try' (line 21, column 345)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:841: variable 'Valid1' unsafe in 'try' (line 21, column 345)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:855: variable 'Count1' unsafe in 'try' (line 21, column 345)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:863: variable 'Valid1' unsafe in 'try' (line 21, column 345)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:979: variable 'Count1' unsafe in 'try' (line 21, column 280)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:987: variable 'Valid1' unsafe in 'try' (line 21, column 280)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1001: variable 'Count1' unsafe in 'try' (line 21, column 280)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1009: variable 'Valid1' unsafe in 'try' (line 21, column 280)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1125: variable 'Valid1' unsafe in 'try' (line 21, column 196)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1133: variable 'Count1' unsafe in 'try' (line 21, column 196)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1147: variable 'Valid1' unsafe in 'try' (line 21, column 196)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1155: variable 'Count1' unsafe in 'try' (line 21, column 196)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1271: variable 'Valid1' unsafe in 'try' (line 21, column 131)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1279: variable 'Count1' unsafe in 'try' (line 21, column 131)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1293: variable 'Valid1' unsafe in 'try' (line 21, column 131)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1301: variable 'Count1' unsafe in 'try' (line 21, column 131)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1417: variable 'Valid1' unsafe in 'try' (line 21, column 66)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1425: variable 'Count1' unsafe in 'try' (line 21, column 66)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1439: variable 'Valid1' unsafe in 'try' (line 21, column 66)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:1447: variable 'Count1' unsafe in 'try' (line 21, column 66)
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ^

/tmp/4-rings-or-4-squares-puzzle.erl:22:18: variable 'Count1' unsafe in 'try' (line 21, column 5)
%   22|     #{"count" => Count1, "list" => Valid1}.
%     |                  ^

/tmp/4-rings-or-4-squares-puzzle.erl:22:36: variable 'Valid1' unsafe in 'try' (line 21, column 5)
%   22|     #{"count" => Count1, "list" => Valid1}.
%     |                                    ^

/tmp/4-rings-or-4-squares-puzzle.erl:5:1: Warning: function validComb/7 is unused
%    5| validComb(A, B, C, D, E, F, G) ->
%     | ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:113: Warning: variable 'Valid' shadowed in 'fun'
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                 ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:120: Warning: variable 'Count' shadowed in 'fun'
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                        ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:178: Warning: variable 'Valid' shadowed in 'fun'
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                  ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:185: Warning: variable 'Count' shadowed in 'fun'
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                         ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:262: Warning: variable 'Valid' shadowed in 'fun'
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                      ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:269: Warning: variable 'Count' shadowed in 'fun'
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                             ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:327: Warning: variable 'Valid' shadowed in 'fun'
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                       ^

/tmp/4-rings-or-4-squares-puzzle.erl:21:334: Warning: variable 'Count' shadowed in 'fun'
%   21|     try {Valid1, Count1} = lists:foldl(fun(B, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(C, {Valid, Count}) -> try try {Valid1, Count1} = lists:foldl(fun(D, {Valid, Count}) -> try S = ((B + C) + D), try {Count1, Valid1} = lists:foldl(fun(E, {Valid, Count}) -> try try {Count1, Valid1} = lists:foldl(fun(F, {Valid, Count}) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid ++ [[A, B, C, D, E, F, G]], Count1 = (Count + 1); _ -> ok end) catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Count1, Valid1} end, {Count1, Valid1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid, Count}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> {Valid1, Count1} end, {Valid1, Count1} end, {Valid0, Count0}, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
%     |                                                                                                                                                                                                                                                                                                                                              ^

escript: There were compilation errors.
