#!/usr/bin/env escript
% Generated by Mochi compiler v0.10.26 on 2025-07-16T09:59:08Z
% 9-billion-names-of-god-the-integer.erl - generated from 9-billion-names-of-god-the-integer.mochi

bigTrim(A) ->
    N0 = (case A of #{items := It} -> length(It); _ -> length(A) end),
    (fun Loop0(A, N) -> case ((N > 1) andalso (lists:nth(((N - 1))+1, A) == 0)) of true -> A0 = lists:sublist(A, (0)+1, ((N - 1))-(0)), N1 = (N - 1), Loop0(A0, N1); _ -> ok end end(A, N0)),
    A0.

bigFromInt(X) ->
    (case (X == 0) of true -> [0]; _ -> ok end),
    Digits0 = [],
    N2 = X,
    (fun Loop1(Digits, N) -> case (N > 0) of true -> Digits1 = Digits ++ [rem(N, 10)], N3 = (N / 10), Loop1(Digits1, N3); _ -> ok end end(Digits0, N2)),
    Digits1.

bigAdd(A, B) ->
    Res0 = [],
    Carry0 = 0,
    I0 = 0,
    (fun Loop2(Res, Carry, I) -> case (((I < (case A0 of #{items := It} -> length(It); _ -> length(A0) end)) orelse (I < (case B of #{items := It} -> length(It); _ -> length(B) end))) orelse (Carry > 0)) of true -> Av0 = 0, (case (I < (case A0 of #{items := It} -> length(It); _ -> length(A0) end)) of true -> Av1 = lists:nth((I)+1, A0); _ -> ok end), Bv0 = 0, (case (I < (case B of #{items := It} -> length(It); _ -> length(B) end)) of true -> Bv1 = lists:nth((I)+1, B); _ -> ok end), S0 = ((Av1 + Bv1) + Carry), Res1 = Res ++ [rem(S0, 10)], Carry1 = (S0 / 10), I1 = (I + 1), Loop2(Res1, Carry1, I1); _ -> ok end end(Res0, Carry0, I0)),
    bigTrim(Res1).

bigSub(A, B) ->
    Res2 = [],
    Borrow0 = 0,
    I2 = 0,
    (fun Loop3(I, Res) -> case (I < (case A0 of #{items := It} -> length(It); _ -> length(A0) end)) of true -> Av2 = lists:nth((I)+1, A0), Bv2 = 0, (case (I < (case B of #{items := It} -> length(It); _ -> length(B) end)) of true -> Bv3 = lists:nth((I)+1, B); _ -> ok end), Diff0 = ((Av2 - Bv3) - Borrow0), (case (Diff0 < 0) of true -> Diff1 = (Diff0 + 10), Borrow1 = 1; _ -> Borrow2 = 0 end), Res3 = Res ++ [Diff1], I3 = (I + 1), Loop3(Res3, I3); _ -> ok end end(I2, Res2)),
    bigTrim(Res3).

bigToString(A) ->
    S1 = "",
    I4 = ((case A0 of #{items := It} -> length(It); _ -> length(A0) end) - 1),
    (fun Loop4(S, I) -> case (I >= 0) of true -> S2 = (S + lists:flatten(io_lib:format("~p", [lists:nth((I)+1, A0)]))), I5 = (I - 1), Loop4(S2, I5); _ -> ok end end(S1, I4)),
    S2.

minInt(A, B) ->
    (case (A0 < B) of true -> A0; _ -> B end).

cumu(N) ->
    Cache0 = [[bigFromInt(1)]],
    Y0 = 1,
    (fun Loop6(Cache, Y) -> case (Y =< N3) of true -> Row0 = [bigFromInt(0)], X0 = 1, (fun Loop5(Row, X) -> case (X =< Y) of true -> Val = mochi_get(minInt(X, (Y - X)), lists:nth(((Y - X))+1, Cache)), Row1 = Row ++ [bigAdd(lists:nth((((case Row of #{items := It} -> length(It); _ -> length(Row) end) - 1))+1, Row), Val)], X1 = (X + 1), Loop5(Row1, X1); _ -> ok end end(Row0, X0)), Cache1 = Cache ++ [Row1], Y1 = (Y + 1), Loop6(Cache1, Y1); _ -> ok end end(Cache0, Y0)),
    lists:nth((N3)+1, Cache1).

row(N) ->
    E = cumu(N3),
    Out0 = [],
    I6 = 0,
    (fun Loop7(Out, I) -> case (I < N3) of true -> Diff = bigSub(mochi_get((I + 1), E), mochi_get(I, E)), Out1 = Out ++ [bigToString(Diff)], I7 = (I + 1), Loop7(Out1, I7); _ -> ok end end(Out0, I6)),
    Out1.

main(_) ->
    io:format("~p~n", ["rows:"]),
    X2 = 1,
    (fun Loop9(X) -> case (X < 11) of true -> R = Row1(X), Line0 = "", I8 = 0, (fun Loop8(Line, I) -> case (I < (case R of #{items := It} -> length(It); _ -> length(R) end)) of true -> Line1 = Line ++ " " ++ mochi_get(I, R) ++ " ", I9 = (I + 1), Loop8(I9, Line1); _ -> ok end end(Line0, I8)), io:format("~p~n", [Line1]), X3 = (X + 1), Loop9(X3); _ -> ok end end(X2)),
    io:format("~p~n", [""]),
    io:format("~p~n", ["sums:"]),
    lists:foreach(fun(Num) -> R = cumu(Num), io:format("~p~n", [lists:flatten(io_lib:format("~p", [Num])) ++ " " ++ bigToString(mochi_get(((case R of #{items := It} -> length(It); _ -> length(R) end) - 1), R))]) end, [23, 123, 1234]).

mochi_get(K, M) ->
    case maps:find(K, M) of
        {ok, V} -> V;
        error ->
            Name = atom_to_list(K),
            case string:tokens(Name, "_") of
                [Pref|_] ->
                    P = list_to_atom(Pref),
                    case maps:find(P, M) of
                        {ok, Sub} when is_map(Sub) -> maps:get(K, Sub, undefined);
                        _ -> undefined
                    end;
                _ -> undefined
            end
        end.
