#!/usr/bin/env escript
% Generated by Mochi compiler v0.10.26 on 2025-07-16T09:59:09Z
% abbreviations-simple.erl - generated from abbreviations-simple.mochi

fields(S) ->
    Words0 = [],
    Cur0 = "",
    I0 = 0,
    (fun Loop0(I) -> case (I < length(S)) of true -> Ch = string:substr(S, (I)+1, ((I + 1))-(I)), (case (((Ch == " ") orelse (Ch == "\n")) orelse (Ch == "\t")) of true -> (case (length(Cur0) > 0) of true -> Words1 = Words0 ++ [Cur0], Cur1 = ""; _ -> ok end); _ -> Cur2 = (Cur1 + Ch) end), I1 = (I + 1), Loop0(I1); _ -> ok end end(I0)),
    (case (length(Cur2) > 0) of true -> Words2 = Words1 ++ [Cur2]; _ -> ok end),
    Words2.

padRight(S, Width) ->
    Out0 = S,
    I2 = length(S),
    (fun Loop1(Out, I) -> case (I < Width) of true -> Out1 = Out ++ " ", I3 = (I + 1), Loop1(Out1, I3); _ -> ok end end(Out0, I2)),
    Out1.

join(Xs, Sep) ->
    Res0 = "",
    I4 = 0,
    (fun Loop2(Res, I) -> case (I < length(Xs)) of true -> (case (I > 0) of true -> Res1 = (Res + Sep); _ -> ok end), Res2 = (Res + lists:nth((I)+1, Xs)), I5 = (I + 1), Loop2(Res2, I5); _ -> ok end end(Res0, I4)),
    Res2.

parseIntStr(Str) ->
    I6 = 0,
    Neg0 = false,
    (case ((length(Str) > 0) andalso (string:substr(Str, (0)+1, (1)-(0)) == "-")) of true -> Neg1 = true, I7 = 1; _ -> ok end),
    N0 = 0,
    Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
    (fun Loop3(N, I) -> case (I < length(Str)) of true -> N1 = ((N * 10) + mochi_get(string:substr(Str, (I)+1, ((I + 1))-(I)), Digits)), I8 = (I + 1), Loop3(I8, N1); _ -> ok end end(N0, I7)),
    (case Neg1 of undefined -> ok; false -> ok; _ -> N2 = -N1 end),
    N2.

isDigits(S) ->
    (case (length(S) == 0) of true -> false; _ -> ok end),
    I9 = 0,
    (fun Loop4(I) -> case (I < length(S)) of true -> Ch = string:substr(S, (I)+1, ((I + 1))-(I)), (case ((Ch < "0") orelse (Ch > "9")) of true -> false; _ -> ok end), I10 = (I + 1), Loop4(I10); _ -> ok end end(I9)),
    true.

readTable(Table) ->
    Toks = fields(Table),
    Cmds0 = [],
    Mins0 = [],
    I11 = 0,
    (fun Loop5(Mins, I, Cmds) -> case (I < length(Toks)) of true -> Cmd = mochi_get(I, Toks), Minlen0 = length(Cmd), I12 = (I + 1), (case ((I < length(Toks)) andalso isDigits(mochi_get(I, Toks))) of true -> Num = parseIntStr(mochi_get(I, Toks)), (case ((Num >= 1) andalso (Num < length(Cmd))) of true -> Minlen1 = Num, I13 = (I + 1); _ -> ok end); _ -> ok end), Cmds1 = Cmds ++ [Cmd], Mins1 = Mins ++ [Minlen1], Loop5(I13, Cmds1, Mins1); _ -> ok end end(Mins0, I11, Cmds0)),
    #{"commands" => Cmds1, "mins" => Mins1}.

validate(Commands, Mins, Words) ->
    Results0 = [],
    Wi0 = 0,
    (fun Loop7(Wi) -> case (Wi < length(Words2)) of true -> W = lists:nth((Wi)+1, Words2), Found0 = false, Wlen = length(W), Ci0 = 0, (fun Loop6(Ci) -> case (Ci < length(Commands)) of true -> Cmd = lists:nth((Ci)+1, Commands), (case (((lists:nth((Ci)+1, Mins1) /= 0) andalso (Wlen >= lists:nth((Ci)+1, Mins1))) andalso (Wlen =< length(Cmd))) of true -> C = upper(Cmd), Ww = upper(W), (case (string:substr(C, (0)+1, (Wlen)-(0)) == Ww) of true -> Results1 = Results0 ++ [C], Found1 = true, throw(break); _ -> ok end); _ -> ok end), Ci1 = (Ci + 1), Loop6(Ci1); _ -> ok end end(Ci0)), (case not Found1 of true -> Results2 = Results1 ++ ["*error*"]; _ -> ok end), Wi1 = (Wi + 1), Loop7(Wi1); _ -> ok end end(Wi0)),
    Results2.

main() ->
    Table = "" ++ "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 " ++ "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate " ++ "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 " ++ "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load " ++ "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 " ++ "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 " ++ "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left " ++ "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ",
    Tbl = readTable(Table),
    Commands = mochi_get("commands", Tbl),
    Mins = mochi_get("mins", Tbl),
    Words = fields(Sentence),
    Results = validate(Commands, Mins, Words),
    Out10 = "user words:",
    K0 = 0,
    (fun Loop8(Out1, K) -> case (K < length(Words)) of true -> Out11 = Out1 ++ " ", (case (K < (length(Words) - 1)) of true -> Out12 = (Out1 + padRight(lists:nth((K)+1, Words), length(lists:nth((K)+1, Results)))); _ -> Out13 = (Out1 + lists:nth((K)+1, Words)) end), K1 = (K + 1), Loop8(Out13, K1); _ -> ok end end(Out10, K0)),
    io:format("~p~n", [Out13]),
    io:format("~p~n", ["full words: " ++ join(Results, " ")]).

main(_) ->
    main().

mochi_get(K, M) ->
    case maps:find(K, M) of
        {ok, V} -> V;
        error ->
            Name = atom_to_list(K),
            case string:tokens(Name, "_") of
                [Pref|_] ->
                    P = list_to_atom(Pref),
                    case maps:find(P, M) of
                        {ok, Sub} when is_map(Sub) -> maps:get(K, Sub, undefined);
                        _ -> undefined
                    end;
                _ -> undefined
            end
        end.
