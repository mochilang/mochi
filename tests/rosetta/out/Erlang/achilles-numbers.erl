#!/usr/bin/env escript
% Generated by Mochi compiler v0.10.26 on 2025-07-16T09:34:13Z
% achilles-numbers.erl - generated from achilles-numbers.mochi

pow10(Exp) ->
    N0 = 1,
    I0 = 0,
    (fun Loop0(N, I) -> case (I < Exp) of true -> N1 = (N * 10), I1 = (I + 1), Loop0(N1, I1); _ -> ok end end(N0, I0)),
    N1.

totient(N) ->
    Tot0 = N1,
    Nn0 = N1,
    I2 = 2,
    (fun Loop2(I) -> case ((I * I) =< Nn0) of true -> (case (rem(Nn0, I) == 0) of true -> (fun Loop1(Nn) -> case (rem(Nn, I) == 0) of true -> Nn1 = (Nn / I), Loop1(Nn1); _ -> ok end end(Nn0)), Tot1 = (Tot0 - (Tot0 / I)); _ -> ok end), (case (I == 2) of true -> I3 = 1; _ -> ok end), I4 = (I + 2), Loop2(I4); _ -> ok end end(I2)),
    (case (Nn1 > 1) of true -> Tot2 = (Tot1 - (Tot1 / Nn1)); _ -> ok end),
    Tot2.

getPerfectPowers(MaxExp) ->
    Upper = pow10(MaxExp),
    I5 = 2,
    (fun Loop4(I) -> case ((I * I) < Upper) of true -> P0 = (I * I), (fun Loop3(P, Pps) -> case true of true -> P1 = (P * I), (case (P >= Upper) of true -> throw(break); _ -> ok end), Pps0 = maps:put(P, true, Pps), Loop3(P1, Pps0); _ -> ok end end(P0, Pps)), I6 = (I + 1), Loop4(I6); _ -> ok end end(I5)).

getAchilles(MinExp, MaxExp) ->
    Lower = pow10(MinExp),
    Upper = pow10(MaxExp),
    Achilles0 = #{},
    B0 = 1,
    (fun Loop6(B) -> case (((B * B) * B) < Upper) of true -> B3 = ((B * B) * B), A0 = 1, (fun Loop5(A) -> case true of true -> P = ((B3 * A) * A), (case (P >= Upper) of true -> throw(break); _ -> ok end), (case (P >= Lower) of true -> (case not (lists:member(P, Pps0)) of true -> Achilles1 = maps:put(P, true, Achilles0); _ -> ok end); _ -> ok end), A1 = (A + 1), Loop5(A1); _ -> ok end end(A0)), B1 = (B + 1), Loop6(B1); _ -> ok end end(B0)),
    Achilles1.

sortInts(Xs) ->
    Res0 = [],
    Tmp0 = Xs,
    (fun Loop9(Res, Tmp) -> case (length(Tmp) > 0) of true -> Min0 = lists:nth((0)+1, Tmp), Idx0 = 0, I7 = 1, (fun Loop7(I) -> case (I < length(Tmp)) of true -> (case (mochi_get(I, Tmp) < Min0) of true -> Min1 = mochi_get(I, Tmp), Idx1 = I; _ -> ok end), I8 = (I + 1), Loop7(I8); _ -> ok end end(I7)), Res1 = (Res + [Min1]), Out0 = [], J0 = 0, (fun Loop8(J) -> case (J < length(Tmp)) of true -> (case (J /= Idx1) of true -> Out1 = (Out0 + [mochi_get(J, Tmp)]); _ -> ok end), J1 = (J + 1), Loop8(J1); _ -> ok end end(J0)), Tmp1 = Out1, Loop9(Res1, Tmp1); _ -> ok end end(Res0, Tmp0)),
    Res1.

pad(N, Width) ->
    S0 = lists:flatten(io_lib:format("~p", [N1])),
    (fun Loop10(S) -> case (length(S) < Width) of true -> S1 = " " ++ S, Loop10(S1); _ -> ok end end(S0)),
    S1.

main() ->
    getPerfectPowers(MaxDigits),
    AchSet = getAchilles(1, 5),
    Ach0 = [],
    {Ach1} = lists:foldl(fun(K, {Ach}) -> Ach1 = (Ach + [K]), {Ach1} end, {Ach0}, mochi_get(keys, AchSet)()),
    Ach2 = sortInts(Ach1),
    io:format("~p~n", ["First 50 Achilles numbers:"]),
    I9 = 0,
    (fun Loop12() -> case (I9 < 50) of true -> Line0 = "", J2 = 0, (fun Loop11(Line, I, J) -> case (J < 10) of true -> Line1 = (Line + pad(lists:nth((I)+1, Ach2), 4)), (case (J < 9) of true -> Line2 = Line ++ " "; _ -> ok end), I10 = (I + 1), J3 = (J + 1), Loop11(J3, Line2, I10); _ -> ok end end(Line0, I9, J2)), io:format("~p~n", [Line2]), Loop12(); _ -> ok end end()),
    io:format("~p~n", ["\nFirst 30 strong Achilles numbers:"]),
    Strong0 = [],
    Count0 = 0,
    Idx2 = 0,
    (fun Loop13(Idx) -> case (Count0 < 30) of true -> Tot = totient(lists:nth((Idx)+1, Ach2)), (case lists:member(Tot, AchSet) of true -> Strong1 = (Strong0 + [lists:nth((Idx)+1, Ach2)]), Count1 = (Count0 + 1); _ -> ok end), Idx3 = (Idx + 1), Loop13(Idx3); _ -> ok end end(Idx2)),
    I11 = 0,
    (fun Loop15() -> case (I11 < 30) of true -> Line3 = "", J4 = 0, (fun Loop14(Line, I, J) -> case (J < 10) of true -> Line4 = (Line + pad(lists:nth((I)+1, Strong1), 5)), (case (J < 9) of true -> Line5 = Line ++ " "; _ -> ok end), I12 = (I + 1), J5 = (J + 1), Loop14(Line5, I12, J5); _ -> ok end end(Line3, I11, J4)), io:format("~p~n", [Line5]), Loop15(); _ -> ok end end()),
    io:format("~p~n", ["\nNumber of Achilles numbers with:"]),
    Counts = [1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383],
    D0 = 2,
    (fun Loop16(D) -> case (D =< MaxDigits) of true -> C = lists:nth(((D - 2))+1, Counts), io:format("~p~n", [pad(D, 2) ++ " digits: " ++ lists:flatten(io_lib:format("~p", [C]))]), D1 = (D + 1), Loop16(D1); _ -> ok end end(D0)).

main(_) ->
    Pps1 = #{},
    main().

mochi_get(K, M) ->
    case maps:find(K, M) of
        {ok, V} -> V;
        error ->
            Name = atom_to_list(K),
            case string:tokens(Name, "_") of
                [Pref|_] ->
                    P = list_to_atom(Pref),
                    case maps:find(P, M) of
                        {ok, Sub} when is_map(Sub) -> maps:get(K, Sub, undefined);
                        _ -> undefined
                    end;
                _ -> undefined
            end
        end.
