#!/usr/bin/env escript
% Generated by Mochi compiler v0.10.26 on 2025-07-16T12:03:23Z
% 21-game.erl - generated from 21-game.mochi

parseIntStr(Str) ->
    I0 = 0,
    Neg0 = false,
    (case ((length(Str) > 0) andalso (string:substr(Str, (0)+1, (1)-(0)) == "-")) of true -> Neg1 = true, I1 = 1; _ -> ok end),
    N0 = 0,
    Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
    (fun Loop0(N, I) -> case (I < length(Str)) of true -> N1 = ((N * 10) + mochi_get(string:substr(Str, (I)+1, ((I + 1))-(I)), Digits)), I2 = (I + 1), Loop0(N1, I2); _ -> ok end end)(N0, I1),
    (case Neg1 of undefined -> ok; false -> ok; _ -> N2 = -N1 end),
    N2.

main() ->
    Total0 = 0,
    Computer0 = (rem(now(), 2) == 0),
    io:format("~p~n", ["Enter q to quit at any time\n"]),
    (case Computer0 of undefined -> io:format("~p~n", ["You will choose first"]); false -> io:format("~p~n", ["You will choose first"]); _ -> io:format("~p~n", ["The computer will choose first"]) end),
    io:format("~p~n", ["\n\nRunning total is now 0\n\n"]),
    Round0 = 1,
    Done0 = false,
    (fun Loop3(Round) -> case not Done0 of true -> io:format("~p~n", ["ROUND " ++ lists:flatten(io_lib:format("~p", [Round])) ++ ":\n\n"]), I3 = 0, (fun Loop2(Computer, I) -> case ((I < 2) andalso (not Done0)) of true -> (case Computer of undefined -> (fun Loop1(Total) -> case true of true -> io:format("~p~n", ["Your choice 1 to 3 : "]), Line = input(), (case ((Line == "q") orelse (Line == "Q")) of true -> io:format("~p~n", ["OK, quitting the game"]), Done2 = true, throw(break); _ -> ok end), Num0 = parseIntStr(Line), (case ((Num0 < 1) orelse (Num0 > 3)) of true -> (case ((Total + Num0) > 21) of true -> io:format("~p~n", ["Too big, try again"]); _ -> io:format("~p~n", ["Out of range, try again"]) end), throw(continue); _ -> ok end), (case ((Total + Num0) > 21) of true -> io:format("~p~n", ["Too big, try again"]), throw(continue); _ -> ok end), Total2 = (Total + Num0), io:format("~p~n", ["Running total is now " ++ lists:flatten(io_lib:format("~p", [Total2]))]), throw(break), Loop1(Total2); _ -> ok end end)(Total1), (case (Total2 == 21) of true -> io:format("~p~n", ["\nSo, congratulations, you've won!"]), Done3 = true; _ -> ok end); false -> (fun Loop1(Total) -> case true of true -> io:format("~p~n", ["Your choice 1 to 3 : "]), Line = input(), (case ((Line == "q") orelse (Line == "Q")) of true -> io:format("~p~n", ["OK, quitting the game"]), Done2 = true, throw(break); _ -> ok end), Num0 = parseIntStr(Line), (case ((Num0 < 1) orelse (Num0 > 3)) of true -> (case ((Total + Num0) > 21) of true -> io:format("~p~n", ["Too big, try again"]); _ -> io:format("~p~n", ["Out of range, try again"]) end), throw(continue); _ -> ok end), (case ((Total + Num0) > 21) of true -> io:format("~p~n", ["Too big, try again"]), throw(continue); _ -> ok end), Total2 = (Total + Num0), io:format("~p~n", ["Running total is now " ++ lists:flatten(io_lib:format("~p", [Total2]))]), throw(break), Loop1(Total2); _ -> ok end end)(Total1), (case (Total2 == 21) of true -> io:format("~p~n", ["\nSo, congratulations, you've won!"]), Done3 = true; _ -> ok end); _ -> Choice0 = 0, (case (Total0 < 18) of true -> Choice1 = (rem(now(), 3) + 1); _ -> Choice2 = (21 - Total0) end), Total1 = (Total0 + Choice2), io:format("~p~n", ["The computer chooses " ++ lists:flatten(io_lib:format("~p", [Choice2]))]), io:format("~p~n", ["Running total is now " ++ lists:flatten(io_lib:format("~p", [Total1]))]), (case (Total1 == 21) of true -> io:format("~p~n", ["\nSo, commiserations, the computer has won!"]), Done1 = true; _ -> ok end) end), io:format("~p~n", ["\n"]), Computer1 = not Computer, I4 = (I + 1), Loop2(Computer1, I4); _ -> ok end end)(Computer0, I3), Round1 = (Round + 1), Loop3(Round1); _ -> ok end end)(Round0).

main(_) ->
    main().

mochi_get(K, M) ->
    case maps:find(K, M) of
        {ok, V} -> V;
        error ->
            Name = atom_to_list(K),
            case string:tokens(Name, "_") of
                [Pref|_] ->
                    P = list_to_atom(Pref),
                    case maps:find(P, M) of
                        {ok, Sub} when is_map(Sub) -> maps:get(K, Sub, undefined);
                        _ -> undefined
                    end;
                _ -> undefined
            end
        end.
