#!/usr/bin/env escript
% Generated by Mochi compiler v0.10.26 on 2025-07-16T12:03:26Z
% abelian-sandpile-model-identity.erl - generated from abelian-sandpile-model-identity.mochi

neighborsList() ->
    [[1, 3], [0, 2, 4], [1, 5], [0, 4, 6], [1, 3, 5, 7], [2, 4, 8], [3, 7], [4, 6, 8], [5, 7]].

plus(A, B) ->
    Res0 = [],
    I0 = 0,
    (fun Loop0(I, Res) -> case (I < length(A)) of true -> Res1 = Res ++ [(lists:nth((I)+1, A) + lists:nth((I)+1, B))], I1 = (I + 1), Loop0(Res1, I1); _ -> ok end end)(I0, Res0),
    Res1.

isStable(P) ->
    lists:foreach(fun(V) -> (case (V > 3) of true -> false; _ -> ok end) end, P),
    true.

topple(P) ->
    Neighbors = neighborsList(),
    I2 = 0,
    (fun Loop1(I) -> case (I < length(P)) of true -> (case (lists:nth((I)+1, P) > 3) of true -> P0 = lists:sublist(P, I) ++ [(lists:nth((I)+1, P) - 4)] ++ lists:nthtail((I)+1, P), Nbs = mochi_get(I, Neighbors), {P1} = lists:foldl(fun(J, {P}) -> P1 = lists:sublist(P, J) ++ [(lists:nth((J)+1, P) + 1)] ++ lists:nthtail((J)+1, P), {P1} end, {P0}, Nbs), 0; _ -> ok end), I3 = (I + 1), Loop1(I3); _ -> ok end end)(I2),
    0.

pileString(P) ->
    S0 = "",
    R0 = 0,
    (fun Loop3(S, R) -> case (R < 3) of true -> C0 = 0, (fun Loop2(S, C) -> case (C < 3) of true -> S1 = (S + lists:flatten(io_lib:format("~p", [lists:nth((((3 * R) + C))+1, P1)]))) ++ " ", C1 = (C + 1), Loop2(S1, C1); _ -> ok end end)(S, C0), S2 = S1 ++ "\n", R1 = (R + 1), Loop3(S2, R1); _ -> ok end end)(S0, R0),
    S2.

main(_) ->
    io:format("~p~n", ["Avalanche of topplings:\n"]),
    S40 = [4, 3, 3, 3, 1, 2, 0, 2, 3],
    io:format("~p~n", [pileString(S40)]),
    (fun Loop4() -> case not isStable(S40) of true -> topple(S40), io:format("~p~n", [pileString(S40)]), Loop4(); _ -> ok end end)(),
    io:format("~p~n", ["Commutative additions:\n"]),
    S10 = [1, 2, 0, 2, 1, 1, 0, 1, 3],
    S20 = [2, 1, 3, 1, 0, 1, 0, 1, 0],
    S3_a0 = plus(S10, S20),
    (fun Loop5() -> case not isStable(S3_a0) of true -> topple(S3_a0), Loop5(); _ -> ok end end)(),
    S3_b0 = plus(S20, S10),
    (fun Loop6() -> case not isStable(S3_b0) of true -> topple(S3_b0), Loop6(); _ -> ok end end)(),
    io:format("~p~n", [pileString(S10) ++ "\nplus\n\n" ++ pileString(S20) ++ "\nequals\n\n" ++ pileString(S3_a0)]),
    io:format("~p~n", ["and\n\n" ++ pileString(S20) ++ "\nplus\n\n" ++ pileString(S10) ++ "\nalso equals\n\n" ++ pileString(S3_b0)]),
    io:format("~p~n", ["Addition of identity sandpile:\n"]),
    S30 = [3, 3, 3, 3, 3, 3, 3, 3, 3],
    S3_id0 = [2, 1, 2, 1, 0, 1, 2, 1, 2],
    S4b0 = plus(S30, S3_id0),
    (fun Loop7() -> case not isStable(S4b0) of true -> topple(S4b0), Loop7(); _ -> ok end end)(),
    io:format("~p~n", [pileString(S30) ++ "\nplus\n\n" ++ pileString(S3_id0) ++ "\nequals\n\n" ++ pileString(S4b0)]),
    io:format("~p~n", ["Addition of identities:\n"]),
    S50 = plus(S3_id0, S3_id0),
    (fun Loop8() -> case not isStable(S50) of true -> topple(S50), Loop8(); _ -> ok end end)(),
    io:format("~p~n", [pileString(S3_id0) ++ "\nplus\n\n" ++ pileString(S3_id0) ++ "\nequals\n\n" ++ pileString(S50)]).

mochi_get(K, M) ->
    case maps:find(K, M) of
        {ok, V} -> V;
        error ->
            Name = atom_to_list(K),
            case string:tokens(Name, "_") of
                [Pref|_] ->
                    P = list_to_atom(Pref),
                    case maps:find(P, M) of
                        {ok, Sub} when is_map(Sub) -> maps:get(K, Sub, undefined);
                        _ -> undefined
                    end;
                _ -> undefined
            end
        end.
