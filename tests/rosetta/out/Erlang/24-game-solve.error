run: exit status 127
/tmp/24-game-solve.erl:23:18: variable 'Opstr4' unsafe in 'case' (line 22, column 6)
%   23|     "(" ++ Ls ++ Opstr4 ++ Rs ++ ")".
%     |                  ^

/tmp/24-game-solve.erl:28:481: variable 'Rest1' is unbound
%   28|     (fun Loop2(I) -> case (I < length(Xs)) of true -> J0 = (I + 1), (fun Loop1(J, Node) -> case (J < length(Xs)) of true -> Rest0 = [], K0 = 0, (fun Loop0(K) -> case (K < length(Xs)) of true -> (case ((K /= I) andalso (K /= J)) of true -> Rest1 = Rest0 ++ [lists:nth((K)+1, Xs)]; _ -> ok end), K1 = (K + 1), Loop0(K1); _ -> ok end end)(K0), A = lists:nth((I)+1, Xs), B = lists:nth((J)+1, Xs), lists:foreach(fun(Op) -> Node0 = #{"op" => Op, "left" => A, "right" => B}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end) end, [1, 2, 3, 4]), Node1 = #{"op" => 2, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end), Node2 = #{"op" => 4, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node2]) of undefined -> ok; false -> ok; _ -> true end), J1 = (J + 1), Loop1(Node2, J1); _ -> ok end end)(J0, Node), I1 = (I + 1), Loop2(I1); _ -> ok end end)(I0),
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^

/tmp/24-game-solve.erl:28:627: variable 'Rest1' is unbound
%   28|     (fun Loop2(I) -> case (I < length(Xs)) of true -> J0 = (I + 1), (fun Loop1(J, Node) -> case (J < length(Xs)) of true -> Rest0 = [], K0 = 0, (fun Loop0(K) -> case (K < length(Xs)) of true -> (case ((K /= I) andalso (K /= J)) of true -> Rest1 = Rest0 ++ [lists:nth((K)+1, Xs)]; _ -> ok end), K1 = (K + 1), Loop0(K1); _ -> ok end end)(K0), A = lists:nth((I)+1, Xs), B = lists:nth((J)+1, Xs), lists:foreach(fun(Op) -> Node0 = #{"op" => Op, "left" => A, "right" => B}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end) end, [1, 2, 3, 4]), Node1 = #{"op" => 2, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end), Node2 = #{"op" => 4, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node2]) of undefined -> ok; false -> ok; _ -> true end), J1 = (J + 1), Loop1(Node2, J1); _ -> ok end end)(J0, Node), I1 = (I + 1), Loop2(I1); _ -> ok end end)(I0),
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ^

/tmp/24-game-solve.erl:28:874: variable 'Node' is unbound
%   28|     (fun Loop2(I) -> case (I < length(Xs)) of true -> J0 = (I + 1), (fun Loop1(J, Node) -> case (J < length(Xs)) of true -> Rest0 = [], K0 = 0, (fun Loop0(K) -> case (K < length(Xs)) of true -> (case ((K /= I) andalso (K /= J)) of true -> Rest1 = Rest0 ++ [lists:nth((K)+1, Xs)]; _ -> ok end), K1 = (K + 1), Loop0(K1); _ -> ok end end)(K0), A = lists:nth((I)+1, Xs), B = lists:nth((J)+1, Xs), lists:foreach(fun(Op) -> Node0 = #{"op" => Op, "left" => A, "right" => B}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end) end, [1, 2, 3, 4]), Node1 = #{"op" => 2, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end), Node2 = #{"op" => 4, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node2]) of undefined -> ok; false -> ok; _ -> true end), J1 = (J + 1), Loop1(Node2, J1); _ -> ok end end)(J0, Node), I1 = (I + 1), Loop2(I1); _ -> ok end end)(I0),
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ^

/tmp/24-game-solve.erl:33:364: variable 'Cards1' is unbound
%   33|     (fun Loop4(Iter) -> case (Iter < 10) of true -> Cards0 = [], I2 = 0, (fun Loop3(I, Cards) -> case (I < 4) of true -> N = (((now() rem ((9 - 1)))) + 1), Cards1 = Cards ++ [newNum(N)], io:format("~p~n", [" " ++ lists:flatten(io_lib:format("~p", [N]))]), I3 = (I + 1), Loop3(Cards1, I3); _ -> ok end end)(I2, Cards0), io:format("~p~n", [":  "]), (case not solve(Cards1) of true -> io:format("~p~n", ["No solution"]); _ -> ok end), Iter1 = (Iter + 1), Loop4(Iter1); _ -> ok end end)(Iter0).
%     |                                                                                                                                                                                                                                                                                                                                                                            ^

/tmp/24-game-solve.erl:21:5: Warning: variable 'Opstr0' is unused
%   21|     Opstr0 = "",
%     |     ^

/tmp/24-game-solve.erl:22:48: Warning: variable 'Opstr1' is unused
%   22|     (case (mochi_get("op", X) == 1) of true -> Opstr1 = " + "; _ -> (case (mochi_get("op", X) == 2) of true -> Opstr2 = " - "; _ -> (case (mochi_get("op", X) == 3) of true -> Opstr3 = " * "; _ -> Opstr4 = " / " end) end) end),
%     |                                                ^

/tmp/24-game-solve.erl:22:112: Warning: variable 'Opstr2' is unused
%   22|     (case (mochi_get("op", X) == 1) of true -> Opstr1 = " + "; _ -> (case (mochi_get("op", X) == 2) of true -> Opstr2 = " - "; _ -> (case (mochi_get("op", X) == 3) of true -> Opstr3 = " * "; _ -> Opstr4 = " / " end) end) end),
%     |                                                                                                                ^

/tmp/24-game-solve.erl:22:176: Warning: variable 'Opstr3' is unused
%   22|     (case (mochi_get("op", X) == 1) of true -> Opstr1 = " + "; _ -> (case (mochi_get("op", X) == 2) of true -> Opstr2 = " - "; _ -> (case (mochi_get("op", X) == 3) of true -> Opstr3 = " * "; _ -> Opstr4 = " / " end) end) end),
%     |                                                                                                                                                                                ^

/tmp/24-game-solve.erl:28:240: Warning: variable 'Rest1' is unused
%   28|     (fun Loop2(I) -> case (I < length(Xs)) of true -> J0 = (I + 1), (fun Loop1(J, Node) -> case (J < length(Xs)) of true -> Rest0 = [], K0 = 0, (fun Loop0(K) -> case (K < length(Xs)) of true -> (case ((K /= I) andalso (K /= J)) of true -> Rest1 = Rest0 ++ [lists:nth((K)+1, Xs)]; _ -> ok end), K1 = (K + 1), Loop0(K1); _ -> ok end end)(K0), A = lists:nth((I)+1, Xs), B = lists:nth((J)+1, Xs), lists:foreach(fun(Op) -> Node0 = #{"op" => Op, "left" => A, "right" => B}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end) end, [1, 2, 3, 4]), Node1 = #{"op" => 2, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end), Node2 = #{"op" => 4, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node2]) of undefined -> ok; false -> ok; _ -> true end), J1 = (J + 1), Loop1(Node2, J1); _ -> ok end end)(J0, Node), I1 = (I + 1), Loop2(I1); _ -> ok end end)(I0),
%     |                                                                                                                                                                                                                                                ^

/tmp/24-game-solve.erl:28:419: Warning: variable 'Node0' is unused
%   28|     (fun Loop2(I) -> case (I < length(Xs)) of true -> J0 = (I + 1), (fun Loop1(J, Node) -> case (J < length(Xs)) of true -> Rest0 = [], K0 = 0, (fun Loop0(K) -> case (K < length(Xs)) of true -> (case ((K /= I) andalso (K /= J)) of true -> Rest1 = Rest0 ++ [lists:nth((K)+1, Xs)]; _ -> ok end), K1 = (K + 1), Loop0(K1); _ -> ok end end)(K0), A = lists:nth((I)+1, Xs), B = lists:nth((J)+1, Xs), lists:foreach(fun(Op) -> Node0 = #{"op" => Op, "left" => A, "right" => B}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end) end, [1, 2, 3, 4]), Node1 = #{"op" => 2, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end), Node2 = #{"op" => 4, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node2]) of undefined -> ok; false -> ok; _ -> true end), J1 = (J + 1), Loop1(Node2, J1); _ -> ok end end)(J0, Node), I1 = (I + 1), Loop2(I1); _ -> ok end end)(I0),
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                   ^

/tmp/24-game-solve.erl:28:566: Warning: variable 'Node1' is unused
%   28|     (fun Loop2(I) -> case (I < length(Xs)) of true -> J0 = (I + 1), (fun Loop1(J, Node) -> case (J < length(Xs)) of true -> Rest0 = [], K0 = 0, (fun Loop0(K) -> case (K < length(Xs)) of true -> (case ((K /= I) andalso (K /= J)) of true -> Rest1 = Rest0 ++ [lists:nth((K)+1, Xs)]; _ -> ok end), K1 = (K + 1), Loop0(K1); _ -> ok end end)(K0), A = lists:nth((I)+1, Xs), B = lists:nth((J)+1, Xs), lists:foreach(fun(Op) -> Node0 = #{"op" => Op, "left" => A, "right" => B}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end) end, [1, 2, 3, 4]), Node1 = #{"op" => 2, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node]) of undefined -> ok; false -> ok; _ -> true end), Node2 = #{"op" => 4, "left" => B, "right" => A}, (case solve(Rest1 ++ [Node2]) of undefined -> ok; false -> ok; _ -> true end), J1 = (J + 1), Loop1(Node2, J1); _ -> ok end end)(J0, Node), I1 = (I + 1), Loop2(I1); _ -> ok end end)(I0),
%     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^

/tmp/24-game-solve.erl:33:129: Warning: erlang:now/0 is deprecated; see the "Time and Time Correction in Erlang" chapter of the ERTS User's Guide for more information
%   33|     (fun Loop4(Iter) -> case (Iter < 10) of true -> Cards0 = [], I2 = 0, (fun Loop3(I, Cards) -> case (I < 4) of true -> N = (((now() rem ((9 - 1)))) + 1), Cards1 = Cards ++ [newNum(N)], io:format("~p~n", [" " ++ lists:flatten(io_lib:format("~p", [N]))]), I3 = (I + 1), Loop3(Cards1, I3); _ -> ok end end)(I2, Cards0), io:format("~p~n", [":  "]), (case not solve(Cards1) of true -> io:format("~p~n", ["No solution"]); _ -> ok end), Iter1 = (Iter + 1), Loop4(Iter1); _ -> ok end end)(Iter0).
%     |                                                                                                                                 ^

escript: There were compilation errors.
