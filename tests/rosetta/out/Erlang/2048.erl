#!/usr/bin/env escript
% Generated by Mochi compiler v0.10.26 on 2025-07-16T12:03:23Z
% 2048.erl - generated from 2048.mochi

newBoard() ->
    B0 = [],
    Y0 = 0,
    (fun Loop1(B, Y) -> case (Y < 4) of true -> Row0 = [], X0 = 0, (fun Loop0(Row, X) -> case (X < 4) of true -> Row1 = Row ++ [0], X1 = (X + 1), Loop0(Row1, X1); _ -> ok end end)(Row0, X0), B1 = B ++ [Row1], Y1 = (Y + 1), Loop1(B1, Y1); _ -> ok end end)(B0, Y0),
    B1.

spawnTile(B) ->
    Empty0 = [],
    Y2 = 0,
    (fun Loop3(Y) -> case (Y < 4) of true -> X2 = 0, (fun Loop2(X) -> case (X < 4) of true -> (case (mochi_get(X, lists:nth((Y)+1, B1)) == 0) of true -> Empty1 = Empty0 ++ [[X, Y]]; _ -> ok end), X3 = (X + 1), Loop2(X3); _ -> ok end end)(X2), Y3 = (Y + 1), Loop3(Y3); _ -> ok end end)(Y2),
    (case (length(Empty1) == 0) of true -> #{"board" => B1, "full" => true}; _ -> ok end),
    Idx0 = rem(now(), length(Empty1)),
    Cell = lists:nth((Idx0)+1, Empty1),
    Val0 = 4,
    (case (rem(now(), 10) < 9) of true -> Val1 = 2; _ -> ok end),
    BInner0 = mochi_get(lists:nth((1)+1, Cell), B1), BInnerUpd0 = maps:put(lists:nth((0)+1, Cell), Val1, BInner0), B2 = B1#{lists:nth((1)+1, Cell) => BInnerUpd0},
    #{"board" => B2, "full" => (length(Empty1) == 1)}.

pad(N) ->
    S0 = lists:flatten(io_lib:format("~p", [N])),
    Pad0 = (4 - length(S0)),
    I0 = 0,
    Out0 = "",
    (fun Loop4(Out, I) -> case (I < Pad0) of true -> Out1 = Out ++ " ", I1 = (I + 1), Loop4(Out1, I1); _ -> ok end end)(Out0, I0),
    (Out1 + S0).

draw(B, Score) ->
    io:format("~p~n", ["Score: " ++ lists:flatten(io_lib:format("~p", [Score]))]),
    Y4 = 0,
    (fun Loop6(Y) -> case (Y < 4) of true -> io:format("~p~n", ["+----+----+----+----+"]), Line0 = "|", X4 = 0, (fun Loop5(X) -> case (X < 4) of true -> V0 = mochi_get(X, lists:nth((Y)+1, B2)), (case (V0 == 0) of true -> Line1 = Line0 ++ "    |"; _ -> Line2 = (Line1 + Pad0(V0)) ++ "|" end), X5 = (X + 1), Loop5(X5); _ -> ok end end)(X4), io:format("~p~n", [Line2]), Y5 = (Y + 1), Loop6(Y5); _ -> ok end end)(Y4),
    io:format("~p~n", ["+----+----+----+----+"]),
    io:format("~p~n", ["W=Up S=Down A=Left D=Right Q=Quit"]).

reverseRow(R) ->
    Out2 = [],
    I2 = (length(R) - 1),
    (fun Loop7(I, Out) -> case (I >= 0) of true -> Out3 = Out ++ [lists:nth((I)+1, R)], I3 = (I - 1), Loop7(Out3, I3); _ -> ok end end)(I2, Out2),
    Out3.

slideLeft(Row) ->
    Xs0 = [],
    I4 = 0,
    (fun Loop8(I) -> case (I < length(Row1)) of true -> (case (lists:nth((I)+1, Row1) /= 0) of true -> Xs1 = Xs0 ++ [lists:nth((I)+1, Row1)]; _ -> ok end), I5 = (I + 1), Loop8(I5); _ -> ok end end)(I4),
    Res0 = [],
    Gain0 = 0,
    I6 = 0,
    (fun Loop9() -> case (I6 < length(Xs1)) of true -> (case (((I6 + 1) < length(Xs1)) andalso (lists:nth((I6)+1, Xs1) == lists:nth(((I6 + 1))+1, Xs1))) of true -> V = (lists:nth((I6)+1, Xs1) * 2), Gain1 = (Gain0 + V), Res1 = Res0 ++ [V], I7 = (I6 + 2); _ -> Res2 = Res1 ++ [lists:nth((I7)+1, Xs1)], I8 = (I7 + 1) end), Loop9(); _ -> ok end end)(),
    (fun Loop10(Res) -> case (length(Res) < 4) of true -> Res3 = Res ++ [0], Loop10(Res3); _ -> ok end end)(Res2),
    #{"row" => Res3, "gain" => Gain1}.

moveLeft(B, Score) ->
    Moved0 = false,
    Y6 = 0,
    (fun Loop12(Score, Y) -> case (Y < 4) of true -> R = slideLeft(lists:nth((Y)+1, B2)), New = lists:nth(("row")+1, R), Score0 = (Score + lists:nth(("gain")+1, R)), X6 = 0, (fun Loop11(X, B) -> case (X < 4) of true -> (case (mochi_get(X, lists:nth((Y)+1, B)) /= mochi_get(X, New)) of true -> Moved1 = true; _ -> ok end), BInner1 = mochi_get(Y, B), BInnerUpd1 = maps:put(X, mochi_get(X, New), BInner1), B3 = B#{Y => BInnerUpd1}, X7 = (X + 1), Loop11(B3, X7); _ -> ok end end)(X6, B2), Y7 = (Y + 1), Loop12(Score0, Y7); _ -> ok end end)(Score, Y6),
    #{"board" => B3, "score" => Score0, "moved" => Moved1}.

moveRight(B, Score) ->
    Moved2 = false,
    Y8 = 0,
    (fun Loop14(Rev, Score, Y) -> case (Y < 4) of true -> Rev0 = reverseRow(lists:nth((Y)+1, B3)), R = slideLeft(Rev), Rev1 = lists:nth(("row")+1, R), Score1 = (Score + lists:nth(("gain")+1, R)), Rev2 = reverseRow(Rev1), X8 = 0, (fun Loop13(B, X) -> case (X < 4) of true -> (case (mochi_get(X, lists:nth((Y)+1, B)) /= mochi_get(X, Rev2)) of true -> Moved3 = true; _ -> ok end), BInner2 = mochi_get(Y, B), BInnerUpd2 = maps:put(X, mochi_get(X, Rev2), BInner2), B4 = B#{Y => BInnerUpd2}, X9 = (X + 1), Loop13(B4, X9); _ -> ok end end)(B3, X8), Y9 = (Y + 1), Loop14(Rev2, Score1, Y9); _ -> ok end end)(Rev, Score0, Y8),
    #{"board" => B4, "score" => Score1, "moved" => Moved3}.

getCol(B, X) ->
    Col0 = [],
    Y10 = 0,
    (fun Loop15(Col, Y) -> case (Y < 4) of true -> Col1 = Col ++ [mochi_get(X9, lists:nth((Y)+1, B4))], Y11 = (Y + 1), Loop15(Col1, Y11); _ -> ok end end)(Col0, Y10),
    Col1.

setCol(B, X, Col) ->
    Y12 = 0,
    (fun Loop16(B, Y) -> case (Y < 4) of true -> BInner3 = mochi_get(Y, B), BInnerUpd3 = maps:put(X9, lists:nth((Y)+1, Col1), BInner3), B5 = B#{Y => BInnerUpd3}, Y13 = (Y + 1), Loop16(B5, Y13); _ -> ok end end)(B4, Y12).

moveUp(B, Score) ->
    Moved4 = false,
    X10 = 0,
    (fun Loop18(Score, X) -> case (X < 4) of true -> Col2 = getCol(B5, X), R = slideLeft(Col2), New = lists:nth(("row")+1, R), Score2 = (Score + lists:nth(("gain")+1, R)), Y14 = 0, (fun Loop17(B, Y) -> case (Y < 4) of true -> (case (mochi_get(X, lists:nth((Y)+1, B)) /= mochi_get(Y, New)) of true -> Moved5 = true; _ -> ok end), BInner4 = mochi_get(Y, B), BInnerUpd4 = maps:put(X, mochi_get(Y, New), BInner4), B6 = B#{Y => BInnerUpd4}, Y15 = (Y + 1), Loop17(B6, Y15); _ -> ok end end)(B5, Y14), X11 = (X + 1), Loop18(Score2, X11); _ -> ok end end)(Score1, X10),
    #{"board" => B6, "score" => Score2, "moved" => Moved5}.

moveDown(B, Score) ->
    Moved6 = false,
    X12 = 0,
    (fun Loop20(Score, X, Col) -> case (X < 4) of true -> Col3 = reverseRow(getCol(B6, X)), R = slideLeft(Col), Col4 = lists:nth(("row")+1, R), Score3 = (Score + lists:nth(("gain")+1, R)), Col5 = reverseRow(Col4), Y16 = 0, (fun Loop19(B, Y) -> case (Y < 4) of true -> (case (mochi_get(X, lists:nth((Y)+1, B)) /= lists:nth((Y)+1, Col5)) of true -> Moved7 = true; _ -> ok end), BInner5 = mochi_get(Y, B), BInnerUpd5 = maps:put(X, lists:nth((Y)+1, Col5), BInner5), B7 = B#{Y => BInnerUpd5}, Y17 = (Y + 1), Loop19(B7, Y17); _ -> ok end end)(B6, Y16), X13 = (X + 1), Loop20(Col5, Score3, X13); _ -> ok end end)(Score2, X12, Col2),
    #{"board" => B7, "score" => Score3, "moved" => Moved7}.

hasMoves(B) ->
    Y18 = 0,
    (fun Loop22(Y) -> case (Y < 4) of true -> X14 = 0, (fun Loop21(X) -> case (X < 4) of true -> (case (mochi_get(X, lists:nth((Y)+1, B7)) == 0) of true -> true; _ -> ok end), (case (((X + 1) < 4) andalso (mochi_get(X, lists:nth((Y)+1, B7)) == mochi_get((X + 1), lists:nth((Y)+1, B7)))) of true -> true; _ -> ok end), (case (((Y + 1) < 4) andalso (mochi_get(X, lists:nth((Y)+1, B7)) == mochi_get(X, lists:nth(((Y + 1))+1, B7)))) of true -> true; _ -> ok end), X15 = (X + 1), Loop21(X15); _ -> ok end end)(X14), Y19 = (Y + 1), Loop22(Y19); _ -> ok end end)(Y18),
    false.

has2048(B) ->
    Y20 = 0,
    (fun Loop24(Y) -> case (Y < 4) of true -> X16 = 0, (fun Loop23(X) -> case (X < 4) of true -> (case (mochi_get(X, lists:nth((Y)+1, B7)) >= 2048) of true -> true; _ -> ok end), X17 = (X + 1), Loop23(X17); _ -> ok end end)(X16), Y21 = (Y + 1), Loop24(Y21); _ -> ok end end)(Y20),
    false.

main(_) ->
    Board0 = newBoard(),
    R0 = spawnTile(Board0),
    Board1 = lists:nth(("board")+1, R),
    Full0 = lists:nth(("full")+1, R),
    R1 = spawnTile(Board1),
    Board2 = lists:nth(("board")+1, R1),
    Full1 = lists:nth(("full")+1, R1),
    Score4 = 0,
    draw(Board2, Score4),
    (fun Loop25() -> case true of true -> io:format("~p~n", ["Move: "]), Cmd = input(), Moved8 = false, (case ((Cmd == "a") orelse (Cmd == "A")) of true -> M = moveLeft(Board2, Score4), Board3 = mochi_get("board", M), Score5 = mochi_get("score", M), Moved9 = mochi_get("moved", M); _ -> ok end), (case ((Cmd == "d") orelse (Cmd == "D")) of true -> M = moveRight(Board3, Score5), Board4 = mochi_get("board", M), Score6 = mochi_get("score", M), Moved10 = mochi_get("moved", M); _ -> ok end), (case ((Cmd == "w") orelse (Cmd == "W")) of true -> M = moveUp(Board4, Score6), Board5 = mochi_get("board", M), Score7 = mochi_get("score", M), Moved11 = mochi_get("moved", M); _ -> ok end), (case ((Cmd == "s") orelse (Cmd == "S")) of true -> M = moveDown(Board5, Score7), Board6 = mochi_get("board", M), Score8 = mochi_get("score", M), Moved12 = mochi_get("moved", M); _ -> ok end), (case ((Cmd == "q") orelse (Cmd == "Q")) of true -> throw(break); _ -> ok end), (case Moved12 of undefined -> ok; false -> ok; _ -> R2 = spawnTile(Board6), Board7 = mochi_get("board", R2), Full2 = mochi_get("full", R2), (case (Full2 andalso (not hasMoves(Board7))) of true -> draw(Board7, Score8), io:format("~p~n", ["Game Over"]), throw(break); _ -> ok end) end), draw(Board7, Score8), (case has2048(Board7) of undefined -> ok; false -> ok; _ -> io:format("~p~n", ["You win!"]), throw(break) end), (case not hasMoves(Board7) of true -> io:format("~p~n", ["Game Over"]), throw(break); _ -> ok end), Loop25(); _ -> ok end end)().

mochi_get(K, M) ->
    case maps:find(K, M) of
        {ok, V} -> V;
        error ->
            Name = atom_to_list(K),
            case string:tokens(Name, "_") of
                [Pref|_] ->
                    P = list_to_atom(Pref),
                    case maps:find(P, M) of
                        {ok, Sub} when is_map(Sub) -> maps:get(K, Sub, undefined);
                        _ -> undefined
                    end;
                _ -> undefined
            end
        end.
