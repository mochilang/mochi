#!/usr/bin/env escript
% Generated by Mochi compiler v0.10.26 on 2025-07-16T09:59:07Z
% 4-rings-or-4-squares-puzzle.erl - generated from 4-rings-or-4-squares-puzzle.mochi

validComb(A, B, C, D, E, F, G) ->
    Square1 = (A + B),
    Square2 = ((B + C) + D),
    Square3 = ((D + E) + F),
    Square4 = (F + G),
    (((Square1 == Square2) andalso (Square2 == Square3)) andalso (Square3 == Square4)).

isUnique(A, B, C, D, E, F, G) ->
    Nums0 = [A, B, C, D, E, F, G],
    I0 = 0,
    (fun Loop1(I) -> case (I < length(Nums0)) of true -> J0 = (I + 1), (fun Loop0(J) -> case (J < length(Nums0)) of true -> (case (lists:nth((I)+1, Nums0) == lists:nth((J)+1, Nums0)) of true -> false; _ -> ok end), J1 = (J + 1), Loop0(J1); _ -> ok end end(J0)), I1 = (I + 1), Loop1(I1); _ -> ok end end(I0)),
    true.

getCombs(Low, High, Unique) ->
    Valid0 = [],
    Count0 = 0,
    try lists:foreach(fun(B) -> try try lists:foreach(fun(C) -> try try lists:foreach(fun(D) -> try S = ((B + C) + D), try lists:foreach(fun(E) -> try try lists:foreach(fun(F) -> try A = (S - B), G = (S - F), (case ((A < Low) orelse (A > High)) of true -> throw(continue); _ -> ok end), (case ((G < Low) orelse (G > High)) of true -> throw(continue); _ -> ok end), (case (((D + E) + F) /= S) of true -> throw(continue); _ -> ok end), (case ((F + G) /= S) of true -> throw(continue); _ -> ok end), (case (not Unique orelse isUnique(A, B, C, D, E, F, G)) of true -> Valid1 = Valid0 ++ [[A, B, C, D, E, F, G]], Count1 = (Count0 + 1); _ -> ok end) catch throw:continue -> ok end end, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> ok end end, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> ok end end, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> ok end end, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end catch throw:continue -> ok end end, lists:seq(Low, (((High + 1)))-1)) catch throw:break -> ok end,
    #{"count" => Count1, "list" => Valid1}.

main(_) ->
    R1 = getCombs(1, 7, true),
    io:format("~p~n", [lists:flatten(io_lib:format("~p", [mochi_get("count", R1)])) ++ " unique solutions in 1 to 7"]),
    io:format("~p~n", [mochi_get("list", R1)]),
    R2 = getCombs(3, 9, true),
    io:format("~p~n", [lists:flatten(io_lib:format("~p", [mochi_get("count", R2)])) ++ " unique solutions in 3 to 9"]),
    io:format("~p~n", [mochi_get("list", R2)]),
    R3 = getCombs(0, 9, false),
    io:format("~p~n", [lists:flatten(io_lib:format("~p", [mochi_get("count", R3)])) ++ " non-unique solutions in 0 to 9"]).

mochi_get(K, M) ->
    case maps:find(K, M) of
        {ok, V} -> V;
        error ->
            Name = atom_to_list(K),
            case string:tokens(Name, "_") of
                [Pref|_] ->
                    P = list_to_atom(Pref),
                    case maps:find(P, M) of
                        {ok, Sub} when is_map(Sub) -> maps:get(K, Sub, undefined);
                        _ -> undefined
                    end;
                _ -> undefined
            end
        end.
