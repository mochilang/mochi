; Generated by Mochi compiler v0.10.26 on 2025-07-16T11:35:54Z
#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v) (format "~a" v))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define SIZE 4)
(define (newBoard )
  (let/ec return
(define b '())
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(define row '())
(define x 0)
(let/ec break
  (let loop ()
    (when (_lt x SIZE)
      (let/ec continue
(set! row (append row (list 0)))
(set! x (+ x 1))
      )
      (loop)))
)
(set! b (append b (list row)))
(set! y (+ y 1))
      )
      (loop)))
)
(return b)
  ))
(define (spawnTile b)
  (let/ec return
(define empty '())
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(define x 0)
(let/ec break
  (let loop ()
    (when (_lt x SIZE)
      (let/ec continue
(if (equal? (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]) 0)
  (begin
(set! empty (append empty (list (list x y))))
  )
  (void)
)
(set! x (+ x 1))
      )
      (loop)))
)
(set! y (+ y 1))
      )
      (loop)))
)
(if (equal? (cond [(string? empty) (string-length empty)] [(hash? empty) (hash-count empty)] [else (length empty)]) 0)
  (begin
(return (hash "board" b "full" #t))
  )
  (void)
)
(define idx (remainder (now ) (cond [(string? empty) (string-length empty)] [(hash? empty) (hash-count empty)] [else (length empty)])))
(define cell (cond [(string? empty) (string-ref empty idx)] [(hash? empty) (hash-ref empty idx)] [else (list-ref empty idx)]))
(define val 4)
(if (_lt (remainder (now ) 10) 9)
  (begin
(set! val 2)
  )
  (void)
)
(set! b (cond [(hash? b) (hash-set b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]) (cond [(hash? (cond [(hash? b) (hash-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))] [else (list-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))])) (hash-set (cond [(hash? b) (hash-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))] [else (list-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))]) (cond [(string? cell) (string-ref cell 0)] [(hash? cell) (hash-ref cell 0)] [else (list-ref cell 0)]) val)] [else (list-set (cond [(hash? b) (hash-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))] [else (list-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))]) (cond [(string? cell) (string-ref cell 0)] [(hash? cell) (hash-ref cell 0)] [else (list-ref cell 0)]) val)]))] [else (list-set b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]) (cond [(hash? (cond [(hash? b) (hash-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))] [else (list-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))])) (hash-set (cond [(hash? b) (hash-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))] [else (list-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))]) (cond [(string? cell) (string-ref cell 0)] [(hash? cell) (hash-ref cell 0)] [else (list-ref cell 0)]) val)] [else (list-set (cond [(hash? b) (hash-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))] [else (list-ref b (cond [(string? cell) (string-ref cell 1)] [(hash? cell) (hash-ref cell 1)] [else (list-ref cell 1)]))]) (cond [(string? cell) (string-ref cell 0)] [(hash? cell) (hash-ref cell 0)] [else (list-ref cell 0)]) val)]))]))
(return (hash "board" b "full" (equal? (cond [(string? empty) (string-length empty)] [(hash? empty) (hash-count empty)] [else (length empty)]) 1)))
  ))
(define (pad n)
  (let/ec return
(define s (number->string n))
(define pad (- 4 (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])))
(define i 0)
(define out "")
(let/ec break
  (let loop ()
    (when (_lt i pad)
      (let/ec continue
(set! out (string-append out " "))
(set! i (+ i 1))
      )
      (loop)))
)
(return (string-append out s))
  ))
(define (draw b score)
  (let/ec return
(displayln (string-append "Score: " (number->string score)))
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(displayln "+----+----+----+----+")
(define line "|")
(define x 0)
(let/ec break
  (let loop ()
    (when (_lt x SIZE)
      (let/ec continue
(define v (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]))
(if (equal? v 0)
  (begin
(set! line (string-append line "    |"))
  )
  (begin
(set! line (string-append (string-append line (pad v)) "|"))
  )
)
(set! x (+ x 1))
      )
      (loop)))
)
(displayln line)
(set! y (+ y 1))
      )
      (loop)))
)
(displayln "+----+----+----+----+")
(displayln "W=Up S=Down A=Left D=Right Q=Quit")
  ))
(define (reverseRow r)
  (let/ec return
(define out '())
(define i (- (cond [(string? r) (string-length r)] [(hash? r) (hash-count r)] [else (length r)]) 1))
(let/ec break
  (let loop ()
    (when (_ge i 0)
      (let/ec continue
(set! out (append out (list (cond [(string? r) (string-ref r i)] [(hash? r) (hash-ref r i)] [else (list-ref r i)]))))
(set! i (- i 1))
      )
      (loop)))
)
(return out)
  ))
(define (slideLeft row)
  (let/ec return
(define xs '())
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? row) (string-length row)] [(hash? row) (hash-count row)] [else (length row)]))
      (let/ec continue
(if (not (equal? (cond [(string? row) (string-ref row i)] [(hash? row) (hash-ref row i)] [else (list-ref row i)]) 0))
  (begin
(set! xs (append xs (list (cond [(string? row) (string-ref row i)] [(hash? row) (hash-ref row i)] [else (list-ref row i)]))))
  )
  (void)
)
(set! i (+ i 1))
      )
      (loop)))
)
(define res '())
(define gain 0)
(set! i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]))
      (let/ec continue
(if (and (_lt (+ i 1) (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)])) (equal? (cond [(string? xs) (string-ref xs i)] [(hash? xs) (hash-ref xs i)] [else (list-ref xs i)]) (cond [(string? xs) (string-ref xs (+ i 1))] [(hash? xs) (hash-ref xs (+ i 1))] [else (list-ref xs (+ i 1))])))
  (begin
(define v (* (cond [(string? xs) (string-ref xs i)] [(hash? xs) (hash-ref xs i)] [else (list-ref xs i)]) 2))
(set! gain (+ gain v))
(set! res (append res (list v)))
(set! i (+ i 2))
  )
  (begin
(set! res (append res (list (cond [(string? xs) (string-ref xs i)] [(hash? xs) (hash-ref xs i)] [else (list-ref xs i)]))))
(set! i (+ i 1))
  )
)
      )
      (loop)))
)
(let/ec break
  (let loop ()
    (when (_lt (cond [(string? res) (string-length res)] [(hash? res) (hash-count res)] [else (length res)]) SIZE)
      (let/ec continue
(set! res (append res (list 0)))
      )
      (loop)))
)
(return (hash "row" res "gain" gain))
  ))
(define (moveLeft b score)
  (let/ec return
(define moved #f)
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(define r (slideLeft (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])))
(define new (cond [(string? r) (string-ref r "row")] [(hash? r) (hash-ref r "row")] [else (list-ref r "row")]))
(set! score (+ score (cond [(string? r) (string-ref r "gain")] [(hash? r) (hash-ref r "gain")] [else (list-ref r "gain")])))
(define x 0)
(let/ec break
  (let loop ()
    (when (_lt x SIZE)
      (let/ec continue
(if (not (equal? (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]) (cond [(string? new) (string-ref new x)] [(hash? new) (hash-ref new x)] [else (list-ref new x)])))
  (begin
(set! moved #t)
  )
  (void)
)
(set! b (cond [(hash? b) (hash-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? new) (string-ref new x)] [(hash? new) (hash-ref new x)] [else (list-ref new x)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? new) (string-ref new x)] [(hash? new) (hash-ref new x)] [else (list-ref new x)]))]))] [else (list-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? new) (string-ref new x)] [(hash? new) (hash-ref new x)] [else (list-ref new x)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? new) (string-ref new x)] [(hash? new) (hash-ref new x)] [else (list-ref new x)]))]))]))
(set! x (+ x 1))
      )
      (loop)))
)
(set! y (+ y 1))
      )
      (loop)))
)
(return (hash "board" b "score" score "moved" moved))
  ))
(define (moveRight b score)
  (let/ec return
(define moved #f)
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(define rev (reverseRow (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])))
(define r (slideLeft rev))
(set! rev (cond [(string? r) (string-ref r "row")] [(hash? r) (hash-ref r "row")] [else (list-ref r "row")]))
(set! score (+ score (cond [(string? r) (string-ref r "gain")] [(hash? r) (hash-ref r "gain")] [else (list-ref r "gain")])))
(set! rev (reverseRow rev))
(define x 0)
(let/ec break
  (let loop ()
    (when (_lt x SIZE)
      (let/ec continue
(if (not (equal? (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]) (cond [(string? rev) (string-ref rev x)] [(hash? rev) (hash-ref rev x)] [else (list-ref rev x)])))
  (begin
(set! moved #t)
  )
  (void)
)
(set! b (cond [(hash? b) (hash-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? rev) (string-ref rev x)] [(hash? rev) (hash-ref rev x)] [else (list-ref rev x)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? rev) (string-ref rev x)] [(hash? rev) (hash-ref rev x)] [else (list-ref rev x)]))]))] [else (list-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? rev) (string-ref rev x)] [(hash? rev) (hash-ref rev x)] [else (list-ref rev x)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? rev) (string-ref rev x)] [(hash? rev) (hash-ref rev x)] [else (list-ref rev x)]))]))]))
(set! x (+ x 1))
      )
      (loop)))
)
(set! y (+ y 1))
      )
      (loop)))
)
(return (hash "board" b "score" score "moved" moved))
  ))
(define (getCol b x)
  (let/ec return
(define col '())
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(set! col (append col (list (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]))))
(set! y (+ y 1))
      )
      (loop)))
)
(return col)
  ))
(define (setCol b x col)
  (let/ec return
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(set! b (cond [(hash? b) (hash-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? col) (string-ref col y)] [(hash? col) (hash-ref col y)] [else (list-ref col y)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? col) (string-ref col y)] [(hash? col) (hash-ref col y)] [else (list-ref col y)]))]))] [else (list-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? col) (string-ref col y)] [(hash? col) (hash-ref col y)] [else (list-ref col y)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? col) (string-ref col y)] [(hash? col) (hash-ref col y)] [else (list-ref col y)]))]))]))
(set! y (+ y 1))
      )
      (loop)))
)
  ))
(define (moveUp b score)
  (let/ec return
(define moved #f)
(define x 0)
(let/ec break
  (let loop ()
    (when (_lt x SIZE)
      (let/ec continue
(define col (getCol b x))
(define r (slideLeft col))
(define new (cond [(string? r) (string-ref r "row")] [(hash? r) (hash-ref r "row")] [else (list-ref r "row")]))
(set! score (+ score (cond [(string? r) (string-ref r "gain")] [(hash? r) (hash-ref r "gain")] [else (list-ref r "gain")])))
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(if (not (equal? (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]) (cond [(string? new) (string-ref new y)] [(hash? new) (hash-ref new y)] [else (list-ref new y)])))
  (begin
(set! moved #t)
  )
  (void)
)
(set! b (cond [(hash? b) (hash-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? new) (string-ref new y)] [(hash? new) (hash-ref new y)] [else (list-ref new y)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? new) (string-ref new y)] [(hash? new) (hash-ref new y)] [else (list-ref new y)]))]))] [else (list-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? new) (string-ref new y)] [(hash? new) (hash-ref new y)] [else (list-ref new y)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? new) (string-ref new y)] [(hash? new) (hash-ref new y)] [else (list-ref new y)]))]))]))
(set! y (+ y 1))
      )
      (loop)))
)
(set! x (+ x 1))
      )
      (loop)))
)
(return (hash "board" b "score" score "moved" moved))
  ))
(define (moveDown b score)
  (let/ec return
(define moved #f)
(define x 0)
(let/ec break
  (let loop ()
    (when (_lt x SIZE)
      (let/ec continue
(define col (reverseRow (getCol b x)))
(define r (slideLeft col))
(set! col (cond [(string? r) (string-ref r "row")] [(hash? r) (hash-ref r "row")] [else (list-ref r "row")]))
(set! score (+ score (cond [(string? r) (string-ref r "gain")] [(hash? r) (hash-ref r "gain")] [else (list-ref r "gain")])))
(set! col (reverseRow col))
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(if (not (equal? (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]) (cond [(string? col) (string-ref col y)] [(hash? col) (hash-ref col y)] [else (list-ref col y)])))
  (begin
(set! moved #t)
  )
  (void)
)
(set! b (cond [(hash? b) (hash-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? col) (string-ref col y)] [(hash? col) (hash-ref col y)] [else (list-ref col y)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? col) (string-ref col y)] [(hash? col) (hash-ref col y)] [else (list-ref col y)]))]))] [else (list-set b y (cond [(hash? (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? col) (string-ref col y)] [(hash? col) (hash-ref col y)] [else (list-ref col y)]))] [else (list-set (cond [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x (cond [(string? col) (string-ref col y)] [(hash? col) (hash-ref col y)] [else (list-ref col y)]))]))]))
(set! y (+ y 1))
      )
      (loop)))
)
(set! x (+ x 1))
      )
      (loop)))
)
(return (hash "board" b "score" score "moved" moved))
  ))
(define (hasMoves b)
  (let/ec return
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(define x 0)
(let/ec break
  (let loop ()
    (when (_lt x SIZE)
      (let/ec continue
(if (equal? (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]) 0)
  (begin
(return #t)
  )
  (void)
)
(if (and (_lt (+ x 1) SIZE) (equal? (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]) (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) (+ x 1))] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) (+ x 1))] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) (+ x 1))])))
  (begin
(return #t)
  )
  (void)
)
(if (and (_lt (+ y 1) SIZE) (equal? (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]) (cond [(string? (cond [(string? b) (string-ref b (+ y 1))] [(hash? b) (hash-ref b (+ y 1))] [else (list-ref b (+ y 1))])) (string-ref (cond [(string? b) (string-ref b (+ y 1))] [(hash? b) (hash-ref b (+ y 1))] [else (list-ref b (+ y 1))]) x)] [(hash? (cond [(string? b) (string-ref b (+ y 1))] [(hash? b) (hash-ref b (+ y 1))] [else (list-ref b (+ y 1))])) (hash-ref (cond [(string? b) (string-ref b (+ y 1))] [(hash? b) (hash-ref b (+ y 1))] [else (list-ref b (+ y 1))]) x)] [else (list-ref (cond [(string? b) (string-ref b (+ y 1))] [(hash? b) (hash-ref b (+ y 1))] [else (list-ref b (+ y 1))]) x)])))
  (begin
(return #t)
  )
  (void)
)
(set! x (+ x 1))
      )
      (loop)))
)
(set! y (+ y 1))
      )
      (loop)))
)
(return #f)
  ))
(define (has2048 b)
  (let/ec return
(define y 0)
(let/ec break
  (let loop ()
    (when (_lt y SIZE)
      (let/ec continue
(define x 0)
(let/ec break
  (let loop ()
    (when (_lt x SIZE)
      (let/ec continue
(if (_ge (cond [(string? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (string-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [(hash? (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)])) (hash-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)] [else (list-ref (cond [(string? b) (string-ref b y)] [(hash? b) (hash-ref b y)] [else (list-ref b y)]) x)]) 2048)
  (begin
(return #t)
  )
  (void)
)
(set! x (+ x 1))
      )
      (loop)))
)
(set! y (+ y 1))
      )
      (loop)))
)
(return #f)
  ))
(define board (newBoard ))
(define r (spawnTile board))
(set! board (cond [(string? r) (string-ref r "board")] [(hash? r) (hash-ref r "board")] [else (list-ref r "board")]))
(define full (cond [(string? r) (string-ref r "full")] [(hash? r) (hash-ref r "full")] [else (list-ref r "full")]))
(set! r (spawnTile board))
(set! board (cond [(string? r) (string-ref r "board")] [(hash? r) (hash-ref r "board")] [else (list-ref r "board")]))
(set! full (cond [(string? r) (string-ref r "full")] [(hash? r) (hash-ref r "full")] [else (list-ref r "full")]))
(define score 0)
(draw board score)
(let/ec break
  (let loop ()
    (when #t
      (let/ec continue
(displayln "Move: ")
(define cmd (input ))
(define moved #f)
(if (or (string=? cmd "a") (string=? cmd "A"))
  (begin
(define m (moveLeft board score))
(set! board (cond [(string? m) (string-ref m "board")] [(hash? m) (hash-ref m "board")] [else (list-ref m "board")]))
(set! score (cond [(string? m) (string-ref m "score")] [(hash? m) (hash-ref m "score")] [else (list-ref m "score")]))
(set! moved (cond [(string? m) (string-ref m "moved")] [(hash? m) (hash-ref m "moved")] [else (list-ref m "moved")]))
  )
  (void)
)
(if (or (string=? cmd "d") (string=? cmd "D"))
  (begin
(define m (moveRight board score))
(set! board (cond [(string? m) (string-ref m "board")] [(hash? m) (hash-ref m "board")] [else (list-ref m "board")]))
(set! score (cond [(string? m) (string-ref m "score")] [(hash? m) (hash-ref m "score")] [else (list-ref m "score")]))
(set! moved (cond [(string? m) (string-ref m "moved")] [(hash? m) (hash-ref m "moved")] [else (list-ref m "moved")]))
  )
  (void)
)
(if (or (string=? cmd "w") (string=? cmd "W"))
  (begin
(define m (moveUp board score))
(set! board (cond [(string? m) (string-ref m "board")] [(hash? m) (hash-ref m "board")] [else (list-ref m "board")]))
(set! score (cond [(string? m) (string-ref m "score")] [(hash? m) (hash-ref m "score")] [else (list-ref m "score")]))
(set! moved (cond [(string? m) (string-ref m "moved")] [(hash? m) (hash-ref m "moved")] [else (list-ref m "moved")]))
  )
  (void)
)
(if (or (string=? cmd "s") (string=? cmd "S"))
  (begin
(define m (moveDown board score))
(set! board (cond [(string? m) (string-ref m "board")] [(hash? m) (hash-ref m "board")] [else (list-ref m "board")]))
(set! score (cond [(string? m) (string-ref m "score")] [(hash? m) (hash-ref m "score")] [else (list-ref m "score")]))
(set! moved (cond [(string? m) (string-ref m "moved")] [(hash? m) (hash-ref m "moved")] [else (list-ref m "moved")]))
  )
  (void)
)
(if (or (string=? cmd "q") (string=? cmd "Q"))
  (begin
(break)
  )
  (void)
)
(if moved
  (begin
(define r2 (spawnTile board))
(set! board (cond [(string? r2) (string-ref r2 "board")] [(hash? r2) (hash-ref r2 "board")] [else (list-ref r2 "board")]))
(set! full (cond [(string? r2) (string-ref r2 "full")] [(hash? r2) (hash-ref r2 "full")] [else (list-ref r2 "full")]))
(if (and full (not (hasMoves board)))
  (begin
(draw board score)
(displayln "Game Over")
(break)
  )
  (void)
)
  )
  (void)
)
(draw board score)
(if (has2048 board)
  (begin
(displayln "You win!")
(break)
  )
  (void)
)
(if (not (hasMoves board))
  (begin
(displayln "Game Over")
(break)
  )
  (void)
)
      )
      (loop)))
)
