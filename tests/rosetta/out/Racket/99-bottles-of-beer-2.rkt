; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
#lang racket
(require racket/list)
(define (fields s)
  (let/ec return
(define words '())
(define cur "")
(define i 0)
(let/ec break
  (let loop ()
    (when (< i (string-length s))
      (let/ec continue
        (let ()
(define ch (substring s i (+ i 1)))
(if (or (or (string=? ch " ") (string=? ch "\n")) (string=? ch "\t"))
  (begin
    (let ()
(if (> (string-length cur) 0)
  (begin
    (let ()
(set! words (append words (list cur)))
(set! cur "")
    )
  )
  (void)
)
    )
  )
  (begin
    (let ()
(set! cur (string-append cur ch))
    )
  )
)
(set! i (+ i 1))
        )
      )
      (loop)))
)
(if (> (string-length cur) 0)
  (begin
    (let ()
(set! words (append words (list cur)))
    )
  )
  (void)
)
(return words)
  ))
(define (join xs sep)
  (let/ec return
(define res "")
(define i 0)
(let/ec break
  (let loop ()
    (when (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]))
      (let/ec continue
        (let ()
(if (> i 0)
  (begin
    (let ()
(set! res (string-append res sep))
    )
  )
  (void)
)
(set! res (string-append res (cond [(string? xs) (string-ref xs i)] [(hash? xs) (hash-ref xs i)] [else (list-ref xs i)])))
(set! i (+ i 1))
        )
      )
      (loop)))
)
(return res)
  ))
(define (numberName n)
  (let/ec return
(define small '("no" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))
(define tens '("ones" "ten" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"))
(if (< n 0)
  (begin
    (let ()
(return "")
    )
  )
  (void)
)
(if (< n 20)
  (begin
    (let ()
(return (cond [(string? small) (string-ref small n)] [(hash? small) (hash-ref small n)] [else (list-ref small n)]))
    )
  )
  (void)
)
(if (< n 100)
  (begin
    (let ()
(define t (cond [(string? tens) (string-ref tens (string->number (/ n 10)))] [(hash? tens) (hash-ref tens (string->number (/ n 10)))] [else (list-ref tens (string->number (/ n 10)))]))
(define s (remainder n 10))
(if (> s 0)
  (begin
    (let ()
(set! t (string-append (string-append t " ") (cond [(string? small) (string-ref small s)] [(hash? small) (hash-ref small s)] [else (list-ref small s)])))
    )
  )
  (void)
)
(return t)
    )
  )
  (void)
)
(return "")
  ))
(define (pluralizeFirst s n)
  (let/ec return
(if (equal? n 1)
  (begin
    (let ()
(return s)
    )
  )
  (void)
)
(define w (fields s))
(if (> (cond [(string? w) (string-length w)] [(hash? w) (hash-count w)] [else (length w)]) 0)
  (begin
    (let ()
(set! w (cond [(hash? w) (hash-set w 0 (string-append (cond [(string? w) (string-ref w 0)] [(hash? w) (hash-ref w 0)] [else (list-ref w 0)]) "s"))] [else (list-set w 0 (string-append (cond [(string? w) (string-ref w 0)] [(hash? w) (hash-ref w 0)] [else (list-ref w 0)]) "s"))]))
    )
  )
  (void)
)
(return (join w " "))
  ))
(define (randInt seed n)
  (let/ec return
(define next (remainder (+ (* seed 1664525) 1013904223) 2147483647))
(return (remainder next n))
  ))
(define (slur p d)
  (let/ec return
(if (<= (string-length p) 2)
  (begin
    (let ()
(return p)
    )
  )
  (void)
)
(define a '())
(define i 1)
(let/ec break
  (let loop ()
    (when (< i (- (string-length p) 1))
      (let/ec continue
        (let ()
(set! a (append a (list (substring p i (+ i 1)))))
(set! i (+ i 1))
        )
      )
      (loop)))
)
(define idx (- (length a) 1))
(define seed d)
(let/ec break
  (let loop ()
    (when (>= idx 1)
      (let/ec continue
        (let ()
(set! seed (remainder (+ (* seed 1664525) 1013904223) 2147483647))
(if (>= (remainder seed 100) d)
  (begin
    (let ()
(define j (remainder seed (+ idx 1)))
(define tmp (cond [(string? a) (string-ref a idx)] [(hash? a) (hash-ref a idx)] [else (list-ref a idx)]))
(set! a (cond [(hash? a) (hash-set a idx (cond [(string? a) (string-ref a j)] [(hash? a) (hash-ref a j)] [else (list-ref a j)]))] [else (list-set a idx (cond [(string? a) (string-ref a j)] [(hash? a) (hash-ref a j)] [else (list-ref a j)]))]))
(set! a (cond [(hash? a) (hash-set a j tmp)] [else (list-set a j tmp)]))
    )
  )
  (void)
)
(set! idx (- idx 1))
        )
      )
      (loop)))
)
(define s (substring p 0 1))
(define k 0)
(let/ec break
  (let loop ()
    (when (< k (length a))
      (let/ec continue
        (let ()
(set! s (if (and (string? s) (string? (cond [(string? a) (string-ref a k)] [(hash? a) (hash-ref a k)] [else (list-ref a k)]))) (string-append s (cond [(string? a) (string-ref a k)] [(hash? a) (hash-ref a k)] [else (list-ref a k)])) (+ s (cond [(string? a) (string-ref a k)] [(hash? a) (hash-ref a k)] [else (list-ref a k)]))))
(set! k (+ k 1))
        )
      )
      (loop)))
)
(set! s (if (and (string? s) (string? (substring p (- (string-length p) 1) (string-length p)))) (string-append s (substring p (- (string-length p) 1) (string-length p))) (+ s (substring p (- (string-length p) 1) (string-length p)))))
(define w (fields s))
(return (join w " "))
  ))
(define (main )
  (let/ec return
(define i 99)
(let/ec break
  (let loop ()
    (when (> i 0)
      (let/ec continue
        (let ()
(displayln (string-append (string-append (string-append (string-append (slur (numberName i) i) " ") (pluralizeFirst (slur "bottle of" i) i)) " ") (slur "beer on the wall" i)))
(displayln (string-append (string-append (string-append (string-append (slur (numberName i) i) " ") (pluralizeFirst (slur "bottle of" i) i)) " ") (slur "beer" i)))
(displayln (string-append (string-append (string-append (string-append (slur "take one" i) " ") (slur "down" i)) " ") (slur "pass it around" i)))
(displayln (string-append (string-append (string-append (string-append (slur (numberName (- i 1)) i) " ") (pluralizeFirst (slur "bottle of" i) (- i 1))) " ") (slur "beer on the wall" i)))
(set! i (- i 1))
        )
      )
      (loop)))
)
  ))
(main )
