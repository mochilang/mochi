; Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:03Z
#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v) (format "~a" v))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define (fields s)
  (let/ec return
(define res '())
(define cur "")
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))
      (let/ec continue
(define c (cond [(string? s) (substring s i (+ i 1))] [(hash? s) (hash-ref s i)] [else (take (drop s i) (- (+ i 1) i))]))
(if (string=? c " ")
  (begin
(if (_gt (string-length cur) 0)
  (begin
(set! res (append res (list cur)))
(set! cur "")
  )
  (void)
)
  )
  (begin
(set! cur (string-append cur c))
  )
)
(set! i (+ i 1))
      )
      (loop)))
)
(if (_gt (string-length cur) 0)
  (begin
(set! res (append res (list cur)))
  )
  (void)
)
(return res)
  ))
(define (canSpell word blks)
  (let/ec return
(if (equal? (cond [(string? word) (string-length word)] [(hash? word) (hash-count word)] [else (length word)]) 0)
  (begin
(return #t)
  )
  (void)
)
(define c (lower (cond [(string? word) (substring word 0 1)] [(hash? word) (hash-ref word 0)] [else (take (drop word 0) (- 1 0))])))
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? blks) (string-length blks)] [(hash? blks) (hash-count blks)] [else (length blks)]))
      (let/ec continue
(define b (cond [(string? blks) (string-ref blks i)] [(hash? blks) (hash-ref blks i)] [else (list-ref blks i)]))
(if (or (equal? c (lower (cond [(string? b) (substring b 0 1)] [(hash? b) (hash-ref b 0)] [else (take (drop b 0) (- 1 0))]))) (equal? c (lower (cond [(string? b) (substring b 1 2)] [(hash? b) (hash-ref b 1)] [else (take (drop b 1) (- 2 1))]))))
  (begin
(define rest '())
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j (cond [(string? blks) (string-length blks)] [(hash? blks) (hash-count blks)] [else (length blks)]))
      (let/ec continue
(if (not (equal? j i))
  (begin
(set! rest (append rest (list (cond [(string? blks) (string-ref blks j)] [(hash? blks) (hash-ref blks j)] [else (list-ref blks j)]))))
  )
  (void)
)
(set! j (+ j 1))
      )
      (loop)))
)
(if (canSpell (cond [(string? word) (substring word 1 (if (string? word) (string-length word) (length word)))] [(hash? word) (hash-ref word 1)] [else (take (drop word 1) (- (if (string? word) (string-length word) (length word)) 1))]) rest)
  (begin
(return #t)
  )
  (void)
)
  )
  (void)
)
(set! i (+ i 1))
      )
      (loop)))
)
(return #f)
  ))
(define (newSpeller blocks)
  (let/ec return
(define bl (fields blocks))
(return (lambda (w) (canSpell w bl)))
  ))
(define (main )
  (let/ec return
(define sp (newSpeller "BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"))
(for ([word (if (hash? '("A" "BARK" "BOOK" "TREAT" "COMMON" "SQUAD" "CONFUSE")) (hash-keys '("A" "BARK" "BOOK" "TREAT" "COMMON" "SQUAD" "CONFUSE")) '("A" "BARK" "BOOK" "TREAT" "COMMON" "SQUAD" "CONFUSE"))])
(displayln (string-append (string-append word " ") (number->string (sp word))))
)
  ))
(main )
