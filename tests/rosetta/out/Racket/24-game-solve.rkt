; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
#lang racket
(require racket/list)
(define (_to_string v)
  (cond
    [(eq? v #t) "true"]
    [(eq? v #f) "false"]
    [(void? v) "<nil>"]
    [(list? v) (string-join (map _to_string v) " ")]
    [else (format "~a" v)]))
(define OP_NUM 0)
(define OP_ADD 1)
(define OP_SUB 2)
(define OP_MUL 3)
(define OP_DIV 4)
(define (newNum n)
  (let/ec return
(return (hash "op" OP_NUM "value" (hash "num" n "denom" 1)))
  ))
(define (exprEval x)
  (let/ec return
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_NUM)
  (begin
    (let ()
(return (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")]))
    )
  )
  (void)
)
(define l (exprEval (cond [(string? x) (string-ref x "left")] [(hash? x) (hash-ref x "left")] [else (list-ref x "left")])))
(define r (exprEval (cond [(string? x) (string-ref x "right")] [(hash? x) (hash-ref x "right")] [else (list-ref x "right")])))
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_ADD)
  (begin
    (let ()
(return (hash "num" (if (and (string? (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")]))) (string? (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")])))) (string-append (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")])) (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")]))) (+ (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")])) (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")])))) "denom" (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")]))))
    )
  )
  (void)
)
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_SUB)
  (begin
    (let ()
(return (hash "num" (- (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")])) (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")]))) "denom" (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")]))))
    )
  )
  (void)
)
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_MUL)
  (begin
    (let ()
(return (hash "num" (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")])) "denom" (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")]))))
    )
  )
  (void)
)
(return (hash "num" (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")])) "denom" (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")]))))
  ))
(define (exprString x)
  (let/ec return
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_NUM)
  (begin
    (let ()
(return (number->string (cond [(string? (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")])) (string-ref (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")]) "num")] [(hash? (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")])) (hash-ref (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")]) "num")] [else (list-ref (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")]) "num")])))
    )
  )
  (void)
)
(define ls (exprString (cond [(string? x) (string-ref x "left")] [(hash? x) (hash-ref x "left")] [else (list-ref x "left")])))
(define rs (exprString (cond [(string? x) (string-ref x "right")] [(hash? x) (hash-ref x "right")] [else (list-ref x "right")])))
(define opstr "")
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_ADD)
  (begin
    (let ()
(set! opstr " + ")
    )
  )
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_SUB)
  (begin
    (let ()
(set! opstr " - ")
    )
  )
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_MUL)
  (begin
    (let ()
(set! opstr " * ")
    )
  )
  (begin
    (let ()
(set! opstr " / ")
    )
  )
)
)
)
(return (string-append (string-append (string-append (string-append "(" ls) opstr) rs) ")"))
  ))
(define n_cards 4)
(define goal 24)
(define digit_range 9)
(define (solve xs)
  (let/ec return
(if (equal? (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]) 1)
  (begin
    (let ()
(define f (exprEval (cond [(string? xs) (string-ref xs 0)] [(hash? xs) (hash-ref xs 0)] [else (list-ref xs 0)])))
(if (and (not (equal? (cond [(string? f) (string-ref f "denom")] [(hash? f) (hash-ref f "denom")] [else (list-ref f "denom")]) 0)) (equal? (cond [(string? f) (string-ref f "num")] [(hash? f) (hash-ref f "num")] [else (list-ref f "num")]) (* (cond [(string? f) (string-ref f "denom")] [(hash? f) (hash-ref f "denom")] [else (list-ref f "denom")]) goal)))
  (begin
    (let ()
(displayln (_to_string (exprString (cond [(string? xs) (string-ref xs 0)] [(hash? xs) (hash-ref xs 0)] [else (list-ref xs 0)]))))
(return #t)
    )
  )
  (void)
)
(return #f)
    )
  )
  (void)
)
(define i 0)
(let/ec break
  (let loop ()
    (when (< i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]))
      (let/ec continue
        (let ()
(define j (+ i 1))
(let/ec break
  (let loop ()
    (when (< j (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]))
      (let/ec continue
        (let ()
(define rest '())
(define k 0)
(let/ec break
  (let loop ()
    (when (< k (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]))
      (let/ec continue
        (let ()
(if (and (not (equal? k i)) (not (equal? k j)))
  (begin
    (let ()
(set! rest (append rest (list (cond [(string? xs) (string-ref xs k)] [(hash? xs) (hash-ref xs k)] [else (list-ref xs k)]))))
    )
  )
  (void)
)
(set! k (+ k 1))
        )
      )
      (loop)))
)
(define a (cond [(string? xs) (string-ref xs i)] [(hash? xs) (hash-ref xs i)] [else (list-ref xs i)]))
(define b (cond [(string? xs) (string-ref xs j)] [(hash? xs) (hash-ref xs j)] [else (list-ref xs j)]))
(for ([op (if (hash? (list OP_ADD OP_SUB OP_MUL OP_DIV)) (hash-keys (list OP_ADD OP_SUB OP_MUL OP_DIV)) (list OP_ADD OP_SUB OP_MUL OP_DIV))])
  (let ()
(define node (hash "op" op "left" a "right" b))
(if (solve (append rest (list node)))
  (begin
    (let ()
(return #t)
    )
  )
  (void)
)
  )
)
(define node (hash "op" OP_SUB "left" b "right" a))
(if (solve (append rest (list node)))
  (begin
    (let ()
(return #t)
    )
  )
  (void)
)
(set! node (hash "op" OP_DIV "left" b "right" a))
(if (solve (append rest (list node)))
  (begin
    (let ()
(return #t)
    )
  )
  (void)
)
(set! j (+ j 1))
        )
      )
      (loop)))
)
(set! i (+ i 1))
        )
      )
      (loop)))
)
(return #f)
  ))
(define (main )
  (let/ec return
(define iter 0)
(let/ec break
  (let loop ()
    (when (< iter 10)
      (let/ec continue
        (let ()
(define cards '())
(define i 0)
(let/ec break
  (let loop ()
    (when (< i n_cards)
      (let/ec continue
        (let ()
(define n (if (and (string? (remainder (inexact->exact (round (* (current-inexact-milliseconds) 1000000))) (- digit_range 1))) (string? 1)) (string-append (remainder (inexact->exact (round (* (current-inexact-milliseconds) 1000000))) (- digit_range 1)) 1) (+ (remainder (inexact->exact (round (* (current-inexact-milliseconds) 1000000))) (- digit_range 1)) 1)))
(set! cards (append cards (list (newNum n))))
(displayln (string-append " " (number->string n)))
(set! i (+ i 1))
        )
      )
      (loop)))
)
(displayln ":  ")
(if (not (solve cards))
  (begin
    (let ()
(displayln "No solution")
    )
  )
  (void)
)
(set! iter (+ iter 1))
        )
      )
      (loop)))
)
  ))
(main )
