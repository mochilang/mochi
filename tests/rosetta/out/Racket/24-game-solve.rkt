; Generated by Mochi compiler v0.10.26 on 2025-07-16T11:35:56Z
#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v) (format "~a" v))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define OP_NUM 0)
(define OP_ADD 1)
(define OP_SUB 2)
(define OP_MUL 3)
(define OP_DIV 4)
(define (newNum n)
  (let/ec return
(return (hash "op" OP_NUM "value" (hash "num" n "denom" 1)))
  ))
(define (exprEval x)
  (let/ec return
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_NUM)
  (begin
(return (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")]))
  )
  (void)
)
(define l (exprEval (cond [(string? x) (string-ref x "left")] [(hash? x) (hash-ref x "left")] [else (list-ref x "left")])))
(define r (exprEval (cond [(string? x) (string-ref x "right")] [(hash? x) (hash-ref x "right")] [else (list-ref x "right")])))
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_ADD)
  (begin
(return (hash "num" (+ (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")])) (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")]))) "denom" (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")]))))
  )
  (void)
)
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_SUB)
  (begin
(return (hash "num" (- (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")])) (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")]))) "denom" (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")]))))
  )
  (void)
)
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_MUL)
  (begin
(return (hash "num" (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")])) "denom" (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")]))))
  )
  (void)
)
(return (hash "num" (* (cond [(string? l) (string-ref l "num")] [(hash? l) (hash-ref l "num")] [else (list-ref l "num")]) (cond [(string? r) (string-ref r "denom")] [(hash? r) (hash-ref r "denom")] [else (list-ref r "denom")])) "denom" (* (cond [(string? l) (string-ref l "denom")] [(hash? l) (hash-ref l "denom")] [else (list-ref l "denom")]) (cond [(string? r) (string-ref r "num")] [(hash? r) (hash-ref r "num")] [else (list-ref r "num")]))))
  ))
(define (exprString x)
  (let/ec return
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_NUM)
  (begin
(return (number->string (cond [(string? (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")])) (string-ref (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")]) "num")] [(hash? (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")])) (hash-ref (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")]) "num")] [else (list-ref (cond [(string? x) (string-ref x "value")] [(hash? x) (hash-ref x "value")] [else (list-ref x "value")]) "num")])))
  )
  (void)
)
(define ls (exprString (cond [(string? x) (string-ref x "left")] [(hash? x) (hash-ref x "left")] [else (list-ref x "left")])))
(define rs (exprString (cond [(string? x) (string-ref x "right")] [(hash? x) (hash-ref x "right")] [else (list-ref x "right")])))
(define opstr "")
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_ADD)
  (begin
(set! opstr " + ")
  )
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_SUB)
  (begin
(set! opstr " - ")
  )
(if (equal? (cond [(string? x) (string-ref x "op")] [(hash? x) (hash-ref x "op")] [else (list-ref x "op")]) OP_MUL)
  (begin
(set! opstr " * ")
  )
  (begin
(set! opstr " / ")
  )
)
)
)
(return (string-append (string-append (string-append (string-append "(" ls) opstr) rs) ")"))
  ))
(define n_cards 4)
(define goal 24)
(define digit_range 9)
(define (solve xs)
  (let/ec return
(if (equal? (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]) 1)
  (begin
(define f (exprEval (cond [(string? xs) (string-ref xs 0)] [(hash? xs) (hash-ref xs 0)] [else (list-ref xs 0)])))
(if (and (not (equal? (cond [(string? f) (string-ref f "denom")] [(hash? f) (hash-ref f "denom")] [else (list-ref f "denom")]) 0)) (equal? (cond [(string? f) (string-ref f "num")] [(hash? f) (hash-ref f "num")] [else (list-ref f "num")]) (* (cond [(string? f) (string-ref f "denom")] [(hash? f) (hash-ref f "denom")] [else (list-ref f "denom")]) goal)))
  (begin
(displayln (exprString (cond [(string? xs) (string-ref xs 0)] [(hash? xs) (hash-ref xs 0)] [else (list-ref xs 0)])))
(return #t)
  )
  (void)
)
(return #f)
  )
  (void)
)
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]))
      (let/ec continue
(define j (+ i 1))
(let/ec break
  (let loop ()
    (when (_lt j (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]))
      (let/ec continue
(define rest '())
(define k 0)
(let/ec break
  (let loop ()
    (when (_lt k (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]))
      (let/ec continue
(if (and (not (equal? k i)) (not (equal? k j)))
  (begin
(set! rest (append rest (list (cond [(string? xs) (string-ref xs k)] [(hash? xs) (hash-ref xs k)] [else (list-ref xs k)]))))
  )
  (void)
)
(set! k (+ k 1))
      )
      (loop)))
)
(define a (cond [(string? xs) (string-ref xs i)] [(hash? xs) (hash-ref xs i)] [else (list-ref xs i)]))
(define b (cond [(string? xs) (string-ref xs j)] [(hash? xs) (hash-ref xs j)] [else (list-ref xs j)]))
(for ([op (if (hash? (list OP_ADD OP_SUB OP_MUL OP_DIV)) (hash-keys (list OP_ADD OP_SUB OP_MUL OP_DIV)) (list OP_ADD OP_SUB OP_MUL OP_DIV))])
(define node (hash "op" op "left" a "right" b))
(if (solve (append rest (list node)))
  (begin
(return #t)
  )
  (void)
)
)
(define node (hash "op" OP_SUB "left" b "right" a))
(if (solve (append rest (list node)))
  (begin
(return #t)
  )
  (void)
)
(set! node (hash "op" OP_DIV "left" b "right" a))
(if (solve (append rest (list node)))
  (begin
(return #t)
  )
  (void)
)
(set! j (+ j 1))
      )
      (loop)))
)
(set! i (+ i 1))
      )
      (loop)))
)
(return #f)
  ))
(define (main )
  (let/ec return
(define iter 0)
(let/ec break
  (let loop ()
    (when (_lt iter 10)
      (let/ec continue
(define cards '())
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i n_cards)
      (let/ec continue
(define n (+ (remainder (now ) (- digit_range 1)) 1))
(set! cards (append cards (list (newNum n))))
(displayln (string-append " " (number->string n)))
(set! i (+ i 1))
      )
      (loop)))
)
(displayln ":  ")
(if (not (solve cards))
  (begin
(displayln "No solution")
  )
  (void)
)
(set! iter (+ iter 1))
      )
      (loop)))
)
  ))
(main )
