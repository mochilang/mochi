; Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:44Z
#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v) (format "~a" v))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define adfgvx "ADFGVX")
(define alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
(define (shuffleStr s)
  (let/ec return
(define arr '())
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))
      (let/ec continue
(set! arr (+ arr (list (cond [(string? s) (string-ref s i)] [(hash? s) (hash-ref s i)] [else (list-ref s i)]))))
(set! i (+ i 1))
      )
      (loop)))
)
(define j (- (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)]) 1))
(let/ec break
  (let loop ()
    (when (_gt j 0)
      (let/ec continue
(define k (remainder (now ) (+ j 1)))
(define tmp (cond [(string? arr) (string-ref arr j)] [(hash? arr) (hash-ref arr j)] [else (list-ref arr j)]))
(set! arr (cond [(hash? arr) (hash-set arr j (cond [(string? arr) (string-ref arr k)] [(hash? arr) (hash-ref arr k)] [else (list-ref arr k)]))] [else (list-set arr j (cond [(string? arr) (string-ref arr k)] [(hash? arr) (hash-ref arr k)] [else (list-ref arr k)]))]))
(set! arr (cond [(hash? arr) (hash-set arr k tmp)] [else (list-set arr k tmp)]))
(set! j (- j 1))
      )
      (loop)))
)
(define out "")
(set! i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)]))
      (let/ec continue
(set! out (string-append out (cond [(string? arr) (string-ref arr i)] [(hash? arr) (hash-ref arr i)] [else (list-ref arr i)])))
(set! i (+ i 1))
      )
      (loop)))
)
(return out)
  ))
(define (createPolybius )
  (let/ec return
(define shuffled (shuffleStr alphabet))
(displayln "6 x 6 Polybius square:\n")
(displayln "  | A D F G V X")
(displayln "---------------")
(define p '())
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i 6)
      (let/ec continue
(define row (cond [(string? shuffled) (substring shuffled (* i 6) (* (+ i 1) 6))] [(hash? shuffled) (hash-ref shuffled (* i 6))] [else (take (drop shuffled (* i 6)) (- (* (+ i 1) 6) (* i 6)))]))
(set! p (+ p (list row)))
(define line (string-append (cond [(string? adfgvx) (string-ref adfgvx i)] [(hash? adfgvx) (hash-ref adfgvx i)] [else (list-ref adfgvx i)]) " | "))
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j 6)
      (let/ec continue
(set! line (string-append (+ line (cond [(string? row) (string-ref row j)] [(hash? row) (hash-ref row j)] [else (list-ref row j)])) " "))
(set! j (+ j 1))
      )
      (loop)))
)
(displayln line)
(set! i (+ i 1))
      )
      (loop)))
)
(return p)
  ))
(define (createKey n)
  (let/ec return
(if (or (_lt n 7) (_gt n 12))
  (begin
(displayln "Key should be within 7 and 12 letters long.")
  )
  (void)
)
(define pool "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
(define key "")
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i n)
      (let/ec continue
(define idx (remainder (now ) (string-length pool)))
(set! key (string-append key (cond [(string? pool) (string-ref pool idx)] [(hash? pool) (hash-ref pool idx)] [else (list-ref pool idx)])))
(set! pool (string-append (cond [(string? pool) (substring pool 0 idx)] [(hash? pool) (hash-ref pool 0)] [else (take (drop pool 0) (- idx 0))]) (cond [(string? pool) (substring pool (+ idx 1) (string-length pool))] [(hash? pool) (hash-ref pool (+ idx 1))] [else (take (drop pool (+ idx 1)) (- (string-length pool) (+ idx 1)))])))
(set! i (+ i 1))
      )
      (loop)))
)
(displayln (string-append "\nThe key is " key))
(return key)
  ))
(define (orderKey key)
  (let/ec return
(define pairs '())
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)]))
      (let/ec continue
(set! pairs (+ pairs (list (list (cond [(string? key) (string-ref key i)] [(hash? key) (hash-ref key i)] [else (list-ref key i)]) i))))
(set! i (+ i 1))
      )
      (loop)))
)
(define n (cond [(string? pairs) (string-length pairs)] [(hash? pairs) (hash-count pairs)] [else (length pairs)]))
(define m 0)
(let/ec break
  (let loop ()
    (when (_lt m n)
      (let/ec continue
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j (- n 1))
      (let/ec continue
(if (_gt (cond [(string? (cond [(string? pairs) (string-ref pairs j)] [(hash? pairs) (hash-ref pairs j)] [else (list-ref pairs j)])) (string-ref (cond [(string? pairs) (string-ref pairs j)] [(hash? pairs) (hash-ref pairs j)] [else (list-ref pairs j)]) 0)] [(hash? (cond [(string? pairs) (string-ref pairs j)] [(hash? pairs) (hash-ref pairs j)] [else (list-ref pairs j)])) (hash-ref (cond [(string? pairs) (string-ref pairs j)] [(hash? pairs) (hash-ref pairs j)] [else (list-ref pairs j)]) 0)] [else (list-ref (cond [(string? pairs) (string-ref pairs j)] [(hash? pairs) (hash-ref pairs j)] [else (list-ref pairs j)]) 0)]) (cond [(string? (cond [(string? pairs) (string-ref pairs (+ j 1))] [(hash? pairs) (hash-ref pairs (+ j 1))] [else (list-ref pairs (+ j 1))])) (string-ref (cond [(string? pairs) (string-ref pairs (+ j 1))] [(hash? pairs) (hash-ref pairs (+ j 1))] [else (list-ref pairs (+ j 1))]) 0)] [(hash? (cond [(string? pairs) (string-ref pairs (+ j 1))] [(hash? pairs) (hash-ref pairs (+ j 1))] [else (list-ref pairs (+ j 1))])) (hash-ref (cond [(string? pairs) (string-ref pairs (+ j 1))] [(hash? pairs) (hash-ref pairs (+ j 1))] [else (list-ref pairs (+ j 1))]) 0)] [else (list-ref (cond [(string? pairs) (string-ref pairs (+ j 1))] [(hash? pairs) (hash-ref pairs (+ j 1))] [else (list-ref pairs (+ j 1))]) 0)]))
  (begin
(define tmp (cond [(string? pairs) (string-ref pairs j)] [(hash? pairs) (hash-ref pairs j)] [else (list-ref pairs j)]))
(set! pairs (cond [(hash? pairs) (hash-set pairs j (cond [(string? pairs) (string-ref pairs (+ j 1))] [(hash? pairs) (hash-ref pairs (+ j 1))] [else (list-ref pairs (+ j 1))]))] [else (list-set pairs j (cond [(string? pairs) (string-ref pairs (+ j 1))] [(hash? pairs) (hash-ref pairs (+ j 1))] [else (list-ref pairs (+ j 1))]))]))
(set! pairs (cond [(hash? pairs) (hash-set pairs (+ j 1) tmp)] [else (list-set pairs (+ j 1) tmp)]))
  )
  (void)
)
(set! j (+ j 1))
      )
      (loop)))
)
(set! m (+ m 1))
      )
      (loop)))
)
(define res '())
(set! i 0)
(let/ec break
  (let loop ()
    (when (_lt i n)
      (let/ec continue
(set! res (+ res (list (string->number (cond [(string? (cond [(string? pairs) (string-ref pairs i)] [(hash? pairs) (hash-ref pairs i)] [else (list-ref pairs i)])) (string-ref (cond [(string? pairs) (string-ref pairs i)] [(hash? pairs) (hash-ref pairs i)] [else (list-ref pairs i)]) 1)] [(hash? (cond [(string? pairs) (string-ref pairs i)] [(hash? pairs) (hash-ref pairs i)] [else (list-ref pairs i)])) (hash-ref (cond [(string? pairs) (string-ref pairs i)] [(hash? pairs) (hash-ref pairs i)] [else (list-ref pairs i)]) 1)] [else (list-ref (cond [(string? pairs) (string-ref pairs i)] [(hash? pairs) (hash-ref pairs i)] [else (list-ref pairs i)]) 1)])))))
(set! i (+ i 1))
      )
      (loop)))
)
(return res)
  ))
(define (encrypt polybius key plainText)
  (let/ec return
(define temp "")
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? plainText) (string-length plainText)] [(hash? plainText) (hash-count plainText)] [else (length plainText)]))
      (let/ec continue
(define r 0)
(let/ec break
  (let loop ()
    (when (_lt r 6)
      (let/ec continue
(define c 0)
(let/ec break
  (let loop ()
    (when (_lt c 6)
      (let/ec continue
(if (equal? (cond [(string? (cond [(string? polybius) (string-ref polybius r)] [(hash? polybius) (hash-ref polybius r)] [else (list-ref polybius r)])) (string-ref (cond [(string? polybius) (string-ref polybius r)] [(hash? polybius) (hash-ref polybius r)] [else (list-ref polybius r)]) c)] [(hash? (cond [(string? polybius) (string-ref polybius r)] [(hash? polybius) (hash-ref polybius r)] [else (list-ref polybius r)])) (hash-ref (cond [(string? polybius) (string-ref polybius r)] [(hash? polybius) (hash-ref polybius r)] [else (list-ref polybius r)]) c)] [else (list-ref (cond [(string? polybius) (string-ref polybius r)] [(hash? polybius) (hash-ref polybius r)] [else (list-ref polybius r)]) c)]) (cond [(string? plainText) (string-ref plainText i)] [(hash? plainText) (hash-ref plainText i)] [else (list-ref plainText i)]))
  (begin
(set! temp (string-append (string-append temp (cond [(string? adfgvx) (string-ref adfgvx r)] [(hash? adfgvx) (hash-ref adfgvx r)] [else (list-ref adfgvx r)])) (cond [(string? adfgvx) (string-ref adfgvx c)] [(hash? adfgvx) (hash-ref adfgvx c)] [else (list-ref adfgvx c)])))
  )
  (void)
)
(set! c (+ c 1))
      )
      (loop)))
)
(set! r (+ r 1))
      )
      (loop)))
)
(set! i (+ i 1))
      )
      (loop)))
)
(define colLen (/ (string-length temp) (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])))
(if (_gt (remainder (string-length temp) (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])) 0)
  (begin
(set! colLen (+ colLen 1))
  )
  (void)
)
(define table '())
(define rIdx 0)
(let/ec break
  (let loop ()
    (when (_lt rIdx colLen)
      (let/ec continue
(define row '())
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)]))
      (let/ec continue
(set! row (+ row '("")))
(set! j (+ j 1))
      )
      (loop)))
)
(set! table (+ table (list row)))
(set! rIdx (+ rIdx 1))
      )
      (loop)))
)
(define idx 0)
(let/ec break
  (let loop ()
    (when (_lt idx (string-length temp))
      (let/ec continue
(define row (/ idx (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])))
(define col (remainder idx (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])))
(set! table (cond [(hash? table) (hash-set table row (cond [(hash? (cond [(hash? table) (hash-ref table row)] [else (list-ref table row)])) (hash-set (cond [(hash? table) (hash-ref table row)] [else (list-ref table row)]) col (cond [(string? temp) (substring temp idx (+ idx 1))] [(hash? temp) (hash-ref temp idx)] [else (take (drop temp idx) (- (+ idx 1) idx))]))] [else (list-set (cond [(hash? table) (hash-ref table row)] [else (list-ref table row)]) col (cond [(string? temp) (substring temp idx (+ idx 1))] [(hash? temp) (hash-ref temp idx)] [else (take (drop temp idx) (- (+ idx 1) idx))]))]))] [else (list-set table row (cond [(hash? (cond [(hash? table) (hash-ref table row)] [else (list-ref table row)])) (hash-set (cond [(hash? table) (hash-ref table row)] [else (list-ref table row)]) col (cond [(string? temp) (substring temp idx (+ idx 1))] [(hash? temp) (hash-ref temp idx)] [else (take (drop temp idx) (- (+ idx 1) idx))]))] [else (list-set (cond [(hash? table) (hash-ref table row)] [else (list-ref table row)]) col (cond [(string? temp) (substring temp idx (+ idx 1))] [(hash? temp) (hash-ref temp idx)] [else (take (drop temp idx) (- (+ idx 1) idx))]))]))]))
(set! idx (+ idx 1))
      )
      (loop)))
)
(define order (orderKey key))
(define cols '())
(define ci 0)
(let/ec break
  (let loop ()
    (when (_lt ci (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)]))
      (let/ec continue
(define colStr "")
(define ri 0)
(let/ec break
  (let loop ()
    (when (_lt ri colLen)
      (let/ec continue
(set! colStr (string-append colStr (cond [(string? (cond [(string? table) (string-ref table ri)] [(hash? table) (hash-ref table ri)] [else (list-ref table ri)])) (string-ref (cond [(string? table) (string-ref table ri)] [(hash? table) (hash-ref table ri)] [else (list-ref table ri)]) (cond [(string? order) (string-ref order ci)] [(hash? order) (hash-ref order ci)] [else (list-ref order ci)]))] [(hash? (cond [(string? table) (string-ref table ri)] [(hash? table) (hash-ref table ri)] [else (list-ref table ri)])) (hash-ref (cond [(string? table) (string-ref table ri)] [(hash? table) (hash-ref table ri)] [else (list-ref table ri)]) (cond [(string? order) (string-ref order ci)] [(hash? order) (hash-ref order ci)] [else (list-ref order ci)]))] [else (list-ref (cond [(string? table) (string-ref table ri)] [(hash? table) (hash-ref table ri)] [else (list-ref table ri)]) (cond [(string? order) (string-ref order ci)] [(hash? order) (hash-ref order ci)] [else (list-ref order ci)]))])))
(set! ri (+ ri 1))
      )
      (loop)))
)
(set! cols (+ cols (list colStr)))
(set! ci (+ ci 1))
      )
      (loop)))
)
(define result "")
(set! ci 0)
(let/ec break
  (let loop ()
    (when (_lt ci (cond [(string? cols) (string-length cols)] [(hash? cols) (hash-count cols)] [else (length cols)]))
      (let/ec continue
(set! result (string-append result (cond [(string? cols) (string-ref cols ci)] [(hash? cols) (hash-ref cols ci)] [else (list-ref cols ci)])))
(if (_lt ci (- (cond [(string? cols) (string-length cols)] [(hash? cols) (hash-count cols)] [else (length cols)]) 1))
  (begin
(set! result (string-append result " "))
  )
  (void)
)
(set! ci (+ ci 1))
      )
      (loop)))
)
(return result)
  ))
(define (indexOf s ch)
  (let/ec return
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))
      (let/ec continue
(if (equal? (cond [(string? s) (string-ref s i)] [(hash? s) (hash-ref s i)] [else (list-ref s i)]) ch)
  (begin
(return i)
  )
  (void)
)
(set! i (+ i 1))
      )
      (loop)))
)
(return (- 1))
  ))
(define (decrypt polybius key cipherText)
  (let/ec return
(define colStrs '())
(define start 0)
(define i 0)
(let/ec break
  (let loop ()
    (when (_le i (cond [(string? cipherText) (string-length cipherText)] [(hash? cipherText) (hash-count cipherText)] [else (length cipherText)]))
      (let/ec continue
(if (or (equal? i (cond [(string? cipherText) (string-length cipherText)] [(hash? cipherText) (hash-count cipherText)] [else (length cipherText)])) (string=? (cond [(string? cipherText) (string-ref cipherText i)] [(hash? cipherText) (hash-ref cipherText i)] [else (list-ref cipherText i)]) " "))
  (begin
(set! colStrs (+ colStrs (list (cond [(string? cipherText) (substring cipherText start i)] [(hash? cipherText) (hash-ref cipherText start)] [else (take (drop cipherText start) (- i start))]))))
(set! start (+ i 1))
  )
  (void)
)
(set! i (+ i 1))
      )
      (loop)))
)
(define maxColLen 0)
(set! i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? colStrs) (string-length colStrs)] [(hash? colStrs) (hash-count colStrs)] [else (length colStrs)]))
      (let/ec continue
(if (_gt (cond [(string? (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)])) (string-length (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)]))] [(hash? (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)])) (hash-count (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)]))] [else (length (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)]))]) maxColLen)
  (begin
(set! maxColLen (cond [(string? (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)])) (string-length (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)]))] [(hash? (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)])) (hash-count (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)]))] [else (length (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)]))]))
  )
  (void)
)
(set! i (+ i 1))
      )
      (loop)))
)
(define cols '())
(set! i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? colStrs) (string-length colStrs)] [(hash? colStrs) (hash-count colStrs)] [else (length colStrs)]))
      (let/ec continue
(define s (cond [(string? colStrs) (string-ref colStrs i)] [(hash? colStrs) (hash-ref colStrs i)] [else (list-ref colStrs i)]))
(define ls '())
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))
      (let/ec continue
(set! ls (+ ls (list (cond [(string? s) (string-ref s j)] [(hash? s) (hash-ref s j)] [else (list-ref s j)]))))
(set! j (+ j 1))
      )
      (loop)))
)
(if (_lt (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) maxColLen)
  (begin
(define pad '())
(define k 0)
(let/ec break
  (let loop ()
    (when (_lt k maxColLen)
      (let/ec continue
(if (_lt k (cond [(string? ls) (string-length ls)] [(hash? ls) (hash-count ls)] [else (length ls)]))
  (begin
(set! pad (+ pad (list (cond [(string? ls) (string-ref ls k)] [(hash? ls) (hash-ref ls k)] [else (list-ref ls k)]))))
  )
  (begin
(set! pad (+ pad '("")))
  )
)
(set! k (+ k 1))
      )
      (loop)))
)
(set! cols (+ cols (list pad)))
  )
  (begin
(set! cols (+ cols (list ls)))
  )
)
(set! i (+ i 1))
      )
      (loop)))
)
(define table '())
(define r 0)
(let/ec break
  (let loop ()
    (when (_lt r maxColLen)
      (let/ec continue
(define row '())
(define c 0)
(let/ec break
  (let loop ()
    (when (_lt c (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)]))
      (let/ec continue
(set! row (+ row '("")))
(set! c (+ c 1))
      )
      (loop)))
)
(set! table (+ table (list row)))
(set! r (+ r 1))
      )
      (loop)))
)
(define order (orderKey key))
(set! r 0)
(let/ec break
  (let loop ()
    (when (_lt r maxColLen)
      (let/ec continue
(define c 0)
(let/ec break
  (let loop ()
    (when (_lt c (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)]))
      (let/ec continue
(set! table (cond [(hash? table) (hash-set table r (cond [(hash? (cond [(hash? table) (hash-ref table r)] [else (list-ref table r)])) (hash-set (cond [(hash? table) (hash-ref table r)] [else (list-ref table r)]) (cond [(string? order) (string-ref order c)] [(hash? order) (hash-ref order c)] [else (list-ref order c)]) (cond [(string? (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)])) (string-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)] [(hash? (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)])) (hash-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)] [else (list-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)]))] [else (list-set (cond [(hash? table) (hash-ref table r)] [else (list-ref table r)]) (cond [(string? order) (string-ref order c)] [(hash? order) (hash-ref order c)] [else (list-ref order c)]) (cond [(string? (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)])) (string-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)] [(hash? (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)])) (hash-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)] [else (list-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)]))]))] [else (list-set table r (cond [(hash? (cond [(hash? table) (hash-ref table r)] [else (list-ref table r)])) (hash-set (cond [(hash? table) (hash-ref table r)] [else (list-ref table r)]) (cond [(string? order) (string-ref order c)] [(hash? order) (hash-ref order c)] [else (list-ref order c)]) (cond [(string? (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)])) (string-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)] [(hash? (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)])) (hash-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)] [else (list-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)]))] [else (list-set (cond [(hash? table) (hash-ref table r)] [else (list-ref table r)]) (cond [(string? order) (string-ref order c)] [(hash? order) (hash-ref order c)] [else (list-ref order c)]) (cond [(string? (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)])) (string-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)] [(hash? (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)])) (hash-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)] [else (list-ref (cond [(string? cols) (string-ref cols c)] [(hash? cols) (hash-ref cols c)] [else (list-ref cols c)]) r)]))]))]))
(set! c (+ c 1))
      )
      (loop)))
)
(set! r (+ r 1))
      )
      (loop)))
)
(define temp "")
(set! r 0)
(let/ec break
  (let loop ()
    (when (_lt r (cond [(string? table) (string-length table)] [(hash? table) (hash-count table)] [else (length table)]))
      (let/ec continue
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j (cond [(string? (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)])) (string-length (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)]))] [(hash? (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)])) (hash-count (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)]))] [else (length (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)]))]))
      (let/ec continue
(set! temp (string-append temp (cond [(string? (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)])) (string-ref (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)]) j)] [(hash? (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)])) (hash-ref (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)]) j)] [else (list-ref (cond [(string? table) (string-ref table r)] [(hash? table) (hash-ref table r)] [else (list-ref table r)]) j)])))
(set! j (+ j 1))
      )
      (loop)))
)
(set! r (+ r 1))
      )
      (loop)))
)
(define plainText "")
(define idx 0)
(let/ec break
  (let loop ()
    (when (_lt idx (string-length temp))
      (let/ec continue
(define rIdx (indexOf adfgvx (cond [(string? temp) (substring temp idx (+ idx 1))] [(hash? temp) (hash-ref temp idx)] [else (take (drop temp idx) (- (+ idx 1) idx))])))
(define cIdx (indexOf adfgvx (cond [(string? temp) (substring temp (+ idx 1) (+ idx 2))] [(hash? temp) (hash-ref temp (+ idx 1))] [else (take (drop temp (+ idx 1)) (- (+ idx 2) (+ idx 1)))])))
(set! plainText (string-append plainText (cond [(string? (cond [(string? polybius) (string-ref polybius rIdx)] [(hash? polybius) (hash-ref polybius rIdx)] [else (list-ref polybius rIdx)])) (string-ref (cond [(string? polybius) (string-ref polybius rIdx)] [(hash? polybius) (hash-ref polybius rIdx)] [else (list-ref polybius rIdx)]) cIdx)] [(hash? (cond [(string? polybius) (string-ref polybius rIdx)] [(hash? polybius) (hash-ref polybius rIdx)] [else (list-ref polybius rIdx)])) (hash-ref (cond [(string? polybius) (string-ref polybius rIdx)] [(hash? polybius) (hash-ref polybius rIdx)] [else (list-ref polybius rIdx)]) cIdx)] [else (list-ref (cond [(string? polybius) (string-ref polybius rIdx)] [(hash? polybius) (hash-ref polybius rIdx)] [else (list-ref polybius rIdx)]) cIdx)])))
(set! idx (+ idx 2))
      )
      (loop)))
)
(return plainText)
  ))
(define (main )
  (let/ec return
(define plainText "ATTACKAT1200AM")
(define polybius (createPolybius ))
(define key (createKey 9))
(displayln (string-append "\nPlaintext : " plainText))
(define cipherText (encrypt polybius key plainText))
(displayln (string-append "\nEncrypted : " cipherText))
(define plainText2 (decrypt polybius key cipherText))
(displayln (string-append "\nDecrypted : " plainText2))
  ))
(main )
