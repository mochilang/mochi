; Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:03Z
#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v) (format "~a" v))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define (fields s)
  (let/ec return
(define words '())
(define cur "")
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))
      (let/ec continue
(define ch (substring s i (+ i 1)))
(if (or (or (string=? ch " ") (string=? ch "\n")) (string=? ch "\t"))
  (begin
(if (_gt (string-length cur) 0)
  (begin
(set! words (append words (list cur)))
(set! cur "")
  )
  (void)
)
  )
  (begin
(set! cur (string-append cur ch))
  )
)
(set! i (+ i 1))
      )
      (loop)))
)
(if (_gt (string-length cur) 0)
  (begin
(set! words (append words (list cur)))
  )
  (void)
)
(return words)
  ))
(define (padRight s width)
  (let/ec return
(define out s)
(define i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))
(let/ec break
  (let loop ()
    (when (_lt i width)
      (let/ec continue
(set! out (string-append out " "))
(set! i (+ i 1))
      )
      (loop)))
)
(return out)
  ))
(define (join xs sep)
  (let/ec return
(define res "")
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? xs) (string-length xs)] [(hash? xs) (hash-count xs)] [else (length xs)]))
      (let/ec continue
(if (_gt i 0)
  (begin
(set! res (string-append res sep))
  )
  (void)
)
(set! res (string-append res (cond [(string? xs) (string-ref xs i)] [(hash? xs) (hash-ref xs i)] [else (list-ref xs i)])))
(set! i (+ i 1))
      )
      (loop)))
)
(return res)
  ))
(define (validate commands words mins)
  (let/ec return
(define results '())
(if (equal? (cond [(string? words) (string-length words)] [(hash? words) (hash-count words)] [else (length words)]) 0)
  (begin
(return results)
  )
  (void)
)
(define wi 0)
(let/ec break
  (let loop ()
    (when (_lt wi (cond [(string? words) (string-length words)] [(hash? words) (hash-count words)] [else (length words)]))
      (let/ec continue
(define w (cond [(string? words) (string-ref words wi)] [(hash? words) (hash-ref words wi)] [else (list-ref words wi)]))
(define found #f)
(define wlen (cond [(string? w) (string-length w)] [(hash? w) (hash-count w)] [else (length w)]))
(define ci 0)
(let/ec break
  (let loop ()
    (when (_lt ci (cond [(string? commands) (string-length commands)] [(hash? commands) (hash-count commands)] [else (length commands)]))
      (let/ec continue
(define cmd (cond [(string? commands) (string-ref commands ci)] [(hash? commands) (hash-ref commands ci)] [else (list-ref commands ci)]))
(if (and (and (not (equal? (cond [(string? mins) (string-ref mins ci)] [(hash? mins) (hash-ref mins ci)] [else (list-ref mins ci)]) 0)) (_ge wlen (cond [(string? mins) (string-ref mins ci)] [(hash? mins) (hash-ref mins ci)] [else (list-ref mins ci)]))) (_le wlen (cond [(string? cmd) (string-length cmd)] [(hash? cmd) (hash-count cmd)] [else (length cmd)])))
  (begin
(define c (upper cmd))
(define ww (upper w))
(if (equal? (substring c 0 wlen) ww)
  (begin
(set! results (append results (list c)))
(set! found #t)
(break)
  )
  (void)
)
  )
  (void)
)
(set! ci (+ ci 1))
      )
      (loop)))
)
(if (not found)
  (begin
(set! results (append results (list "*error*")))
  )
  (void)
)
(set! wi (+ wi 1))
      )
      (loop)))
)
(return results)
  ))
(define (main )
  (let/ec return
(define table (string-append (string-append (string-append (string-append (string-append (string-append "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ") "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ") " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ") "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ") "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ") "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "))
(define commands (fields table))
(define mins '())
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? commands) (string-length commands)] [(hash? commands) (hash-count commands)] [else (length commands)]))
      (let/ec continue
(define count 0)
(define j 0)
(define cmd (cond [(string? commands) (string-ref commands i)] [(hash? commands) (hash-ref commands i)] [else (list-ref commands i)]))
(let/ec break
  (let loop ()
    (when (_lt j (cond [(string? cmd) (string-length cmd)] [(hash? cmd) (hash-count cmd)] [else (length cmd)]))
      (let/ec continue
(define ch (substring cmd j (+ j 1)))
(if (and (string>=? ch "A") (string<=? ch "Z"))
  (begin
(set! count (+ count 1))
  )
  (void)
)
(set! j (+ j 1))
      )
      (loop)))
)
(set! mins (append mins (list count)))
(set! i (+ i 1))
      )
      (loop)))
)
(define sentence "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin")
(define words (fields sentence))
(define results (validate commands words mins))
(define out1 "user words:  ")
(define k 0)
(let/ec break
  (let loop ()
    (when (_lt k (cond [(string? words) (string-length words)] [(hash? words) (hash-count words)] [else (length words)]))
      (let/ec continue
(set! out1 (string-append (string-append out1 (padRight (cond [(string? words) (string-ref words k)] [(hash? words) (hash-ref words k)] [else (list-ref words k)]) (cond [(string? (cond [(string? results) (string-ref results k)] [(hash? results) (hash-ref results k)] [else (list-ref results k)])) (string-length (cond [(string? results) (string-ref results k)] [(hash? results) (hash-ref results k)] [else (list-ref results k)]))] [(hash? (cond [(string? results) (string-ref results k)] [(hash? results) (hash-ref results k)] [else (list-ref results k)])) (hash-count (cond [(string? results) (string-ref results k)] [(hash? results) (hash-ref results k)] [else (list-ref results k)]))] [else (length (cond [(string? results) (string-ref results k)] [(hash? results) (hash-ref results k)] [else (list-ref results k)]))]))) " "))
(set! k (+ k 1))
      )
      (loop)))
)
(displayln out1)
(displayln (string-append "full words:  " (join results " ")))
  ))
(main )
