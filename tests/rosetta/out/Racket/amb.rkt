; Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:48Z
#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v) (format "~a" v))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define (amb wordsets res idx)
  (let/ec return
(if (equal? idx (cond [(string? wordsets) (string-length wordsets)] [(hash? wordsets) (hash-count wordsets)] [else (length wordsets)]))
  (begin
(return #t)
  )
  (void)
)
(define prev "")
(if (_gt idx 0)
  (begin
(set! prev (cond [(string? res) (string-ref res (- idx 1))] [(hash? res) (hash-ref res (- idx 1))] [else (list-ref res (- idx 1))]))
  )
  (void)
)
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)])) (string-length (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)]))] [(hash? (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)])) (hash-count (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)]))] [else (length (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)]))]))
      (let/ec continue
(define w (cond [(string? (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)])) (string-ref (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)]) i)] [(hash? (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)])) (hash-ref (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)]) i)] [else (list-ref (cond [(string? wordsets) (string-ref wordsets idx)] [(hash? wordsets) (hash-ref wordsets idx)] [else (list-ref wordsets idx)]) i)]))
(if (or (equal? idx 0) (equal? (substring prev (- (string-length prev) 1) (string-length prev)) (substring w 0 1)))
  (begin
(set! res (cond [(hash? res) (hash-set res idx w)] [else (list-set res idx w)]))
(if (amb wordsets res (+ idx 1))
  (begin
(return #t)
  )
  (void)
)
  )
  (void)
)
(set! i (+ i 1))
      )
      (loop)))
)
(return #f)
  ))
(define (main )
  (let/ec return
(define wordset (list '("the" "that" "a") '("frog" "elephant" "thing") '("walked" "treaded" "grows") '("slowly" "quickly")))
(define res '())
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? wordset) (string-length wordset)] [(hash? wordset) (hash-count wordset)] [else (length wordset)]))
      (let/ec continue
(set! res (append res (list "")))
(set! i (+ i 1))
      )
      (loop)))
)
(if (amb wordset res 0)
  (begin
(define out (string-append "[" (cond [(string? res) (string-ref res 0)] [(hash? res) (hash-ref res 0)] [else (list-ref res 0)])))
(define j 1)
(let/ec break
  (let loop ()
    (when (_lt j (cond [(string? res) (string-length res)] [(hash? res) (hash-count res)] [else (length res)]))
      (let/ec continue
(set! out (string-append (string-append out " ") (cond [(string? res) (string-ref res j)] [(hash? res) (hash-ref res j)] [else (list-ref res j)])))
(set! j (+ j 1))
      )
      (loop)))
)
(set! out (string-append out "]"))
(displayln out)
  )
  (begin
(displayln "No amb found")
  )
)
  ))
(main )
