; Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:24Z
#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v) (format "~a" v))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define (pow10 exp)
  (let/ec return
(define n 1)
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i exp)
      (let/ec continue
(set! n (* n 10))
(set! i (+ i 1))
      )
      (loop)))
)
(return n)
  ))
(define (totient n)
  (let/ec return
(define tot n)
(define nn n)
(define i 2)
(let/ec break
  (let loop ()
    (when (_le (* i i) nn)
      (let/ec continue
(if (equal? (remainder nn i) 0)
  (begin
(let/ec break
  (let loop ()
    (when (equal? (remainder nn i) 0)
      (let/ec continue
(set! nn (/ nn i))
      )
      (loop)))
)
(set! tot (- tot (/ tot i)))
  )
  (void)
)
(if (equal? i 2)
  (begin
(set! i 1)
  )
  (void)
)
(set! i (+ i 2))
      )
      (loop)))
)
(if (_gt nn 1)
  (begin
(set! tot (- tot (/ tot nn)))
  )
  (void)
)
(return tot)
  ))
(define pps (hash ))
(define (getPerfectPowers maxExp)
  (let/ec return
(define upper (pow10 maxExp))
(define i 2)
(let/ec break
  (let loop ()
    (when (_lt (* i i) upper)
      (let/ec continue
(define p (* i i))
(let/ec break
  (let loop ()
    (when #t
      (let/ec continue
(set! p (* p i))
(if (_ge p upper)
  (begin
(break)
  )
  (void)
)
(set! pps (cond [(hash? pps) (hash-set pps p #t)] [else (list-set pps p #t)]))
      )
      (loop)))
)
(set! i (+ i 1))
      )
      (loop)))
)
  ))
(define (getAchilles minExp maxExp)
  (let/ec return
(define lower (pow10 minExp))
(define upper (pow10 maxExp))
(define achilles (hash ))
(define b 1)
(let/ec break
  (let loop ()
    (when (_lt (* (* b b) b) upper)
      (let/ec continue
(define b3 (* (* b b) b))
(define a 1)
(let/ec break
  (let loop ()
    (when #t
      (let/ec continue
(define p (* (* b3 a) a))
(if (_ge p upper)
  (begin
(break)
  )
  (void)
)
(if (_ge p lower)
  (begin
(if (not (cond [(string? pps) (regexp-match? (regexp p) pps)] [(hash? pps) (hash-has-key? pps p)] [else (member p pps)]))
  (begin
(set! achilles (cond [(hash? achilles) (hash-set achilles p #t)] [else (list-set achilles p #t)]))
  )
  (void)
)
  )
  (void)
)
(set! a (+ a 1))
      )
      (loop)))
)
(set! b (+ b 1))
      )
      (loop)))
)
(return achilles)
  ))
(define (sortInts xs)
  (let/ec return
(define res '())
(define tmp xs)
(let/ec break
  (let loop ()
    (when (_gt (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)]) 0)
      (let/ec continue
(define min (cond [(string? tmp) (string-ref tmp 0)] [(hash? tmp) (hash-ref tmp 0)] [else (list-ref tmp 0)]))
(define idx 0)
(define i 1)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)]))
      (let/ec continue
(if (_lt (cond [(string? tmp) (string-ref tmp i)] [(hash? tmp) (hash-ref tmp i)] [else (list-ref tmp i)]) min)
  (begin
(set! min (cond [(string? tmp) (string-ref tmp i)] [(hash? tmp) (hash-ref tmp i)] [else (list-ref tmp i)]))
(set! idx i)
  )
  (void)
)
(set! i (+ i 1))
      )
      (loop)))
)
(set! res (+ res (list min)))
(define out '())
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)]))
      (let/ec continue
(if (not (equal? j idx))
  (begin
(set! out (+ out (list (cond [(string? tmp) (string-ref tmp j)] [(hash? tmp) (hash-ref tmp j)] [else (list-ref tmp j)]))))
  )
  (void)
)
(set! j (+ j 1))
      )
      (loop)))
)
(set! tmp out)
      )
      (loop)))
)
(return res)
  ))
(define (pad n width)
  (let/ec return
(define s (number->string n))
(let/ec break
  (let loop ()
    (when (_lt (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) width)
      (let/ec continue
(set! s (string-append " " s))
      )
      (loop)))
)
(return s)
  ))
(define (main )
  (let/ec return
(define maxDigits 15)
(getPerfectPowers maxDigits)
(define achSet (getAchilles 1 5))
(define ach '())
(for ([k (if (hash? ((hash-ref achSet 'keys))) (hash-keys ((hash-ref achSet 'keys))) ((hash-ref achSet 'keys)))])
(set! ach (+ ach (list k)))
)
(set! ach (sortInts ach))
(displayln "First 50 Achilles numbers:")
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i 50)
      (let/ec continue
(define line "")
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j 10)
      (let/ec continue
(set! line (string-append line (pad (cond [(string? ach) (string-ref ach i)] [(hash? ach) (hash-ref ach i)] [else (list-ref ach i)]) 4)))
(if (_lt j 9)
  (begin
(set! line (string-append line " "))
  )
  (void)
)
(set! i (+ i 1))
(set! j (+ j 1))
      )
      (loop)))
)
(displayln line)
      )
      (loop)))
)
(displayln "\nFirst 30 strong Achilles numbers:")
(define strong '())
(define count 0)
(define idx 0)
(let/ec break
  (let loop ()
    (when (_lt count 30)
      (let/ec continue
(define tot (totient (cond [(string? ach) (string-ref ach idx)] [(hash? ach) (hash-ref ach idx)] [else (list-ref ach idx)])))
(if (cond [(string? achSet) (regexp-match? (regexp tot) achSet)] [(hash? achSet) (hash-has-key? achSet tot)] [else (member tot achSet)])
  (begin
(set! strong (+ strong (list (cond [(string? ach) (string-ref ach idx)] [(hash? ach) (hash-ref ach idx)] [else (list-ref ach idx)]))))
(set! count (+ count 1))
  )
  (void)
)
(set! idx (+ idx 1))
      )
      (loop)))
)
(set! i 0)
(let/ec break
  (let loop ()
    (when (_lt i 30)
      (let/ec continue
(define line "")
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j 10)
      (let/ec continue
(set! line (string-append line (pad (cond [(string? strong) (string-ref strong i)] [(hash? strong) (hash-ref strong i)] [else (list-ref strong i)]) 5)))
(if (_lt j 9)
  (begin
(set! line (string-append line " "))
  )
  (void)
)
(set! i (+ i 1))
(set! j (+ j 1))
      )
      (loop)))
)
(displayln line)
      )
      (loop)))
)
(displayln "\nNumber of Achilles numbers with:")
(define counts '(1 12 47 192 664 2242 7395 24008 77330 247449 788855 2508051 7960336 25235383))
(define d 2)
(let/ec break
  (let loop ()
    (when (_le d maxDigits)
      (let/ec continue
(define c (cond [(string? counts) (string-ref counts (- d 2))] [(hash? counts) (hash-ref counts (- d 2))] [else (list-ref counts (- d 2))]))
(displayln (string-append (string-append (pad d 2) " digits: ") (number->string c)))
(set! d (+ d 1))
      )
      (loop)))
)
  ))
(main )
