; Generated by Mochi compiler v0.10.26 on 2025-07-16T11:37:31Z
#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v) (format "~a" v))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define (sortRunes s)
  (let/ec return
(define arr '())
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))
      (let/ec continue
(set! arr (append arr (list (cond [(string? s) (substring s i (+ i 1))] [(hash? s) (hash-ref s i)] [else (take (drop s i) (- (+ i 1) i))]))))
(set! i (+ i 1))
      )
      (loop)))
)
(define n (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)]))
(define m 0)
(let/ec break
  (let loop ()
    (when (_lt m n)
      (let/ec continue
(define j 0)
(let/ec break
  (let loop ()
    (when (_lt j (- n 1))
      (let/ec continue
(if (_gt (cond [(string? arr) (string-ref arr j)] [(hash? arr) (hash-ref arr j)] [else (list-ref arr j)]) (cond [(string? arr) (string-ref arr (+ j 1))] [(hash? arr) (hash-ref arr (+ j 1))] [else (list-ref arr (+ j 1))]))
  (begin
(define tmp (cond [(string? arr) (string-ref arr j)] [(hash? arr) (hash-ref arr j)] [else (list-ref arr j)]))
(set! arr (cond [(hash? arr) (hash-set arr j (cond [(string? arr) (string-ref arr (+ j 1))] [(hash? arr) (hash-ref arr (+ j 1))] [else (list-ref arr (+ j 1))]))] [else (list-set arr j (cond [(string? arr) (string-ref arr (+ j 1))] [(hash? arr) (hash-ref arr (+ j 1))] [else (list-ref arr (+ j 1))]))]))
(set! arr (cond [(hash? arr) (hash-set arr (+ j 1) tmp)] [else (list-set arr (+ j 1) tmp)]))
  )
  (void)
)
(set! j (+ j 1))
      )
      (loop)))
)
(set! m (+ m 1))
      )
      (loop)))
)
(define out "")
(set! i 0)
(let/ec break
  (let loop ()
    (when (_lt i n)
      (let/ec continue
(set! out (string-append out (cond [(string? arr) (string-ref arr i)] [(hash? arr) (hash-ref arr i)] [else (list-ref arr i)])))
(set! i (+ i 1))
      )
      (loop)))
)
(return out)
  ))
(define (deranged a b)
  (let/ec return
(if (not (equal? (cond [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)]) (cond [(string? b) (string-length b)] [(hash? b) (hash-count b)] [else (length b)])))
  (begin
(return #f)
  )
  (void)
)
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)]))
      (let/ec continue
(if (equal? (cond [(string? a) (substring a i (+ i 1))] [(hash? a) (hash-ref a i)] [else (take (drop a i) (- (+ i 1) i))]) (cond [(string? b) (substring b i (+ i 1))] [(hash? b) (hash-ref b i)] [else (take (drop b i) (- (+ i 1) i))]))
  (begin
(return #f)
  )
  (void)
)
(set! i (+ i 1))
      )
      (loop)))
)
(return #t)
  ))
(define (main )
  (let/ec return
(define words '("constitutionalism" "misconstitutional"))
(define m (hash ))
(define bestLen 0)
(define w1 "")
(define w2 "")
(let/ec break
  (for ([w (if (hash? words) (hash-keys words) words)])
    (let/ec continue
(if (_le (cond [(string? w) (string-length w)] [(hash? w) (hash-count w)] [else (length w)]) bestLen)
  (begin
(continue)
  )
  (void)
)
(define k (sortRunes w))
(if (not (cond [(string? m) (regexp-match? (regexp k) m)] [(hash? m) (hash-has-key? m k)] [else (member k m)]))
  (begin
(set! m (cond [(hash? m) (hash-set m k (list w))] [else (list-set m k (list w))]))
(continue)
  )
  (void)
)
(let/ec break
  (for ([c (if (hash? (cond [(string? m) (string-ref m k)] [(hash? m) (hash-ref m k)] [else (list-ref m k)])) (hash-keys (cond [(string? m) (string-ref m k)] [(hash? m) (hash-ref m k)] [else (list-ref m k)])) (cond [(string? m) (string-ref m k)] [(hash? m) (hash-ref m k)] [else (list-ref m k)]))])
    (let/ec continue
(if (deranged w c)
  (begin
(set! bestLen (cond [(string? w) (string-length w)] [(hash? w) (hash-count w)] [else (length w)]))
(set! w1 c)
(set! w2 w)
(break)
  )
  (void)
)
    )
  )
)
(set! m (cond [(hash? m) (hash-set m k (append (cond [(string? m) (string-ref m k)] [(hash? m) (hash-ref m k)] [else (list-ref m k)]) (list w)))] [else (list-set m k (append (cond [(string? m) (string-ref m k)] [(hash? m) (hash-ref m k)] [else (list-ref m k)]) (list w)))]))
    )
  )
)
(displayln (string-append (string-append (string-append (string-append w1 " ") w2) " : Length ") (number->string bestLen)))
  ))
(main )
