; Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:05Z
#lang racket
(require racket/list)
(define (_date_number s)
  (let ([parts (string-split s "-")])
    (if (= (length parts) 3)
        (+ (* (string->number (list-ref parts 0)) 10000)
           (* (string->number (list-ref parts 1)) 100)
           (string->number (list-ref parts 2)))
        #f)))

(define (_to_string v) (format "~a" v))

(define (_lt a b)
  (cond
    [(and (number? a) (number? b)) (< a b)]
    [(and (string? a) (string? b))
     (let ([da (_date_number a)]
           [db (_date_number b)])
       (if (and da db)
           (< da db)
           (string<? a b)))]
    [(and (list? a) (list? b))
     (cond [(null? a) (not (null? b))]
           [(null? b) #f]
           [else (let ([ka (car a)] [kb (car b)])
                   (if (equal? ka kb)
                       (_lt (cdr a) (cdr b))
                       (_lt ka kb)))])]
    [else (string<? (_to_string a) (_to_string b))]))

(define (_gt a b) (_lt b a))
(define (_le a b) (or (_lt a b) (equal? a b)))
(define (_ge a b) (or (_gt a b) (equal? a b)))

(define (_min v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_lt n m) (set! m n))))
    m))

(define (_max v)
  (let* ([lst (cond [(and (hash? v) (hash-has-key? v 'items)) (hash-ref v 'items)]
                    [(list? v) v]
                    [else '()])]
         [m 0])
    (when (not (null? lst))
      (set! m (car lst))
      (for ([n (cdr lst)])
        (when (_gt n m) (set! m n))))
    m))

(define (_json-fix v)
  (cond
    [(and (number? v) (rational? v) (not (integer? v))) (real->double-flonum v)]
    [(list? v) (map _json-fix v)]
    [(hash? v) (for/hash ([(k val) v]) (values k (_json-fix val)))]
    [else v]))

(define (neighborsList )
  (let/ec return
(return (list '(1 3) '(0 2 4) '(1 5) '(0 4 6) '(1 3 5 7) '(2 4 8) '(3 7) '(4 6 8) '(5 7)))
  ))
(define (plus a b)
  (let/ec return
(define res '())
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)]))
      (let/ec continue
(set! res (append res (list (+ (cond [(string? a) (string-ref a i)] [(hash? a) (hash-ref a i)] [else (list-ref a i)]) (cond [(string? b) (string-ref b i)] [(hash? b) (hash-ref b i)] [else (list-ref b i)])))))
(set! i (+ i 1))
      )
      (loop)))
)
(return res)
  ))
(define (isStable p)
  (let/ec return
(for ([v (if (hash? p) (hash-keys p) p)])
(if (_gt v 3)
  (begin
(return #f)
  )
  (void)
)
)
(return #t)
  ))
(define (topple p)
  (let/ec return
(define neighbors (neighborsList ))
(define i 0)
(let/ec break
  (let loop ()
    (when (_lt i (cond [(string? p) (string-length p)] [(hash? p) (hash-count p)] [else (length p)]))
      (let/ec continue
(if (_gt (cond [(string? p) (string-ref p i)] [(hash? p) (hash-ref p i)] [else (list-ref p i)]) 3)
  (begin
(set! p (cond [(hash? p) (hash-set p i (- (cond [(string? p) (string-ref p i)] [(hash? p) (hash-ref p i)] [else (list-ref p i)]) 4))] [else (list-set p i (- (cond [(string? p) (string-ref p i)] [(hash? p) (hash-ref p i)] [else (list-ref p i)]) 4))]))
(define nbs (cond [(string? neighbors) (string-ref neighbors i)] [(hash? neighbors) (hash-ref neighbors i)] [else (list-ref neighbors i)]))
(for ([j (if (hash? nbs) (hash-keys nbs) nbs)])
(set! p (cond [(hash? p) (hash-set p j (+ (cond [(string? p) (string-ref p j)] [(hash? p) (hash-ref p j)] [else (list-ref p j)]) 1))] [else (list-set p j (+ (cond [(string? p) (string-ref p j)] [(hash? p) (hash-ref p j)] [else (list-ref p j)]) 1))]))
)
(return 0)
  )
  (void)
)
(set! i (+ i 1))
      )
      (loop)))
)
(return 0)
  ))
(define (pileString p)
  (let/ec return
(define s "")
(define r 0)
(let/ec break
  (let loop ()
    (when (_lt r 3)
      (let/ec continue
(define c 0)
(let/ec break
  (let loop ()
    (when (_lt c 3)
      (let/ec continue
(set! s (string-append (string-append s (number->string (cond [(string? p) (string-ref p (+ (* 3 r) c))] [(hash? p) (hash-ref p (+ (* 3 r) c))] [else (list-ref p (+ (* 3 r) c))]))) " "))
(set! c (+ c 1))
      )
      (loop)))
)
(set! s (string-append s "\n"))
(set! r (+ r 1))
      )
      (loop)))
)
(return s)
  ))
(displayln "Avalanche of topplings:\n")
(define s4 '(4 3 3 3 1 2 0 2 3))
(displayln (pileString s4))
(let/ec break
  (let loop ()
    (when (not (isStable s4))
      (let/ec continue
(topple s4)
(displayln (pileString s4))
      )
      (loop)))
)
(displayln "Commutative additions:\n")
(define s1 '(1 2 0 2 1 1 0 1 3))
(define s2 '(2 1 3 1 0 1 0 1 0))
(define s3_a (plus s1 s2))
(let/ec break
  (let loop ()
    (when (not (isStable s3_a))
      (let/ec continue
(topple s3_a)
      )
      (loop)))
)
(define s3_b (plus s2 s1))
(let/ec break
  (let loop ()
    (when (not (isStable s3_b))
      (let/ec continue
(topple s3_b)
      )
      (loop)))
)
(displayln (string-append (string-append (string-append (string-append (pileString s1) "\nplus\n\n") (pileString s2)) "\nequals\n\n") (pileString s3_a)))
(displayln (string-append (string-append (string-append (string-append (string-append "and\n\n" (pileString s2)) "\nplus\n\n") (pileString s1)) "\nalso equals\n\n") (pileString s3_b)))
(displayln "Addition of identity sandpile:\n")
(define s3 '(3 3 3 3 3 3 3 3 3))
(define s3_id '(2 1 2 1 0 1 2 1 2))
(define s4b (plus s3 s3_id))
(let/ec break
  (let loop ()
    (when (not (isStable s4b))
      (let/ec continue
(topple s4b)
      )
      (loop)))
)
(displayln (string-append (string-append (string-append (string-append (pileString s3) "\nplus\n\n") (pileString s3_id)) "\nequals\n\n") (pileString s4b)))
(displayln "Addition of identities:\n")
(define s5 (plus s3_id s3_id))
(let/ec break
  (let loop ()
    (when (not (isStable s5))
      (let/ec continue
(topple s5)
      )
      (loop)))
)
(displayln (string-append (string-append (string-append (string-append (pileString s3_id) "\nplus\n\n") (pileString s3_id)) "\nequals\n\n") (pileString s5)))
