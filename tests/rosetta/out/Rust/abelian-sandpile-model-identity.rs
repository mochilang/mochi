// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn neighborsList() -> Vec<Vec<i32>> {
        return vec![vec![1, 3], vec![0, 2, 4], vec![1, 5], vec![0, 4, 6], vec![1, 3, 5, 7], vec![2, 4, 8], vec![3, 7], vec![4, 6, 8], vec![5, 7]];
    }
    fn plus(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {
        let mut res: Vec<i32> = vec![];
        let mut i = 0;
        while i < a.len() as i32 {
            res = { let mut tmp = res.clone(); tmp.push(a[i as usize] + b[i as usize]); tmp };
            i += 1;
        }
        return res;
    }
    fn isStable(p: Vec<i32>) -> bool {
        for v in p {
            if v > 3 {
                return false;
            }
        }
        return true;
    }
    fn topple(p: &mut Vec<i32>) -> i32 {
        let neighbors = neighborsList();
        let mut i = 0;
        while i < p.len() as i32 {
            if p[i as usize] > 3 {
                p[i as usize] = p[i as usize] - 4;
                let nbs = neighbors[i as usize];
                for j in nbs {
                    p[j as usize] = p[j as usize] + 1;
                }
                return 0;
            }
            i += 1;
        }
        return 0;
    }
    fn pileString(p: Vec<i32>) -> &'static str {
        let mut s = String::new();
        let mut r = 0;
        while r < 3 {
            let mut c = 0;
            while c < 3 {
                s = format!("{}{}", format!("{}{}", s, p[3 * r + c as usize].to_string()), " ");
                c += 1;
            }
            s += "
";
            r += 1;
        }
        return s;
    }
    println!("Avalanche of topplings:\n");
    let mut s4 = vec![4, 3, 3, 3, 1, 2, 0, 2, 3];
    println!("{}", vec![format!("{}", pileString(s4))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    while !isStable(s4) {
        topple(&mut s4);
        println!("{}", vec![format!("{}", pileString(s4))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    }
    println!("Commutative additions:\n");
    let mut s1 = vec![1, 2, 0, 2, 1, 1, 0, 1, 3];
    let mut s2 = vec![2, 1, 3, 1, 0, 1, 0, 1, 0];
    let mut s3_a = plus(s1, s2);
    while !isStable(s3_a) {
        topple(&mut s3_a);
    }
    let mut s3_b = plus(s2, s1);
    while !isStable(s3_b) {
        topple(&mut s3_b);
    }
    println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", pileString(s1), "
plus

"), pileString(s2)), "
equals

"), pileString(s3_a)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "and

", pileString(s2)), "
plus

"), pileString(s1)), "
also equals

"), pileString(s3_b)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    println!("Addition of identity sandpile:\n");
    let mut s3 = vec![3, 3, 3, 3, 3, 3, 3, 3, 3];
    let mut s3_id = vec![2, 1, 2, 1, 0, 1, 2, 1, 2];
    let mut s4b = plus(s3, s3_id);
    while !isStable(s4b) {
        topple(&mut s4b);
    }
    println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", pileString(s3), "
plus

"), pileString(s3_id)), "
equals

"), pileString(s4b)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    println!("Addition of identities:\n");
    let mut s5 = plus(s3_id, s3_id);
    while !isStable(s5) {
        topple(&mut s5);
    }
    println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", pileString(s3_id), "
plus

"), pileString(s3_id)), "
equals

"), pileString(s5)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
}
