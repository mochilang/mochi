// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:49Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn trimLeftZeros(s: &'static str) -> &'static str {
        let mut i = 0;
        while i < s.len() as i32 && &s[i as usize..i + 1 as usize] == "0" {
            i += 1;
        }
        return &s[i as usize..s.len() as i32 as usize];
    }
    fn btString(s: &mut &'static str) -> std::collections::HashMap<&'static str, i32> {
        s = trimLeftZeros(s);
        let mut b: Vec<i32> = vec![];
        let mut i = s.len() as i32 - 1;
        while i >= 0 {
            let ch = &s[i as usize..i + 1 as usize];
            if ch == "+" {
                b = append(b, 1);
            } else {
                if ch == "0" {
                    b = append(b, 0);
                } else {
                    if ch == "-" {
                        b = append(b, 0 - 1);
                    } else {
                        return { let mut m = std::collections::BTreeMap::new(); m.insert("bt", vec![]); m.insert("ok", false); m };
                    }
                }
            }
            i -= 1;
        }
        return { let mut m = std::collections::BTreeMap::new(); m.insert("bt", b); m.insert("ok", true); m };
    }
    fn btToString(b: Vec<i32>) -> &'static str {
        if b.len() as i32 == 0 {
            return "0";
        }
        let mut r = "";
        let mut i = b.len() as i32 - 1;
        while i >= 0 {
            let d = b[i as usize];
            if d == 0 - 1 {
                r += "-";
            } else {
                if d == 0 {
                    r += "0";
                } else {
                    r += "+";
                }
            }
            i -= 1;
        }
        return r;
    }
    fn btInt(i: i32) -> Vec<i32> {
        if i == 0 {
            return vec![];
        }
        let mut n = i;
        let mut b: Vec<i32> = vec![];
        while n != 0 {
            let mut m = n % 3;
            n = ((n as f64) / (3 as f64)).parse::<i32>().unwrap();
            if m == 2 {
                m = 0 - 1;
                n += 1;
            } else {
                if m == 0 - 2 {
                    m = 1;
                    n -= 1;
                }
            }
            b = append(b, m);
        }
        return b;
    }
    fn btToInt(b: Vec<i32>) -> i32 {
        let mut r = 0;
        let mut pt = 1;
        let mut i = 0;
        while i < b.len() as i32 {
            r = r + b[i as usize] * pt;
            pt *= 3;
            i += 1;
        }
        return r;
    }
    fn btNeg(b: Vec<i32>) -> Vec<i32> {
        let mut r: Vec<i32> = vec![];
        let mut i = 0;
        while i < b.len() as i32 {
            r = append(r, -b[i as usize]);
            i += 1;
        }
        return r;
    }
    fn btAdd(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {
        return btInt(btToInt(a) + btToInt(b));
    }
    fn btMul(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {
        return btInt(btToInt(a) * btToInt(b));
    }
    fn padLeft(s: &'static str, w: i32) -> &'static str {
        let mut r = s;
        while r.len() as i32 < w {
            r = format!("{}{}", " ", r);
        }
        return r;
    }
    fn show(label: &'static str, b: Vec<i32>) -> () {
        let l = padLeft(label, 7);
        let bs = padLeft(btToString(b), 12);
        let is = padLeft(btToInt(b).to_string(), 7);
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", l, " "), bs), " "), is));
    }
    fn main() -> () {
        let ares = btString(&mut "+-0++0+");
        let a = ares[&"bt"];
        let b = btInt(-436);
        let cres = btString(&mut "+-++-");
        let c = cres[&"bt"];
        show("a:", a);
        show("b:", b);
        show("c:", c);
        show("a(b-c):", btMul(a, btAdd(b, btNeg(c))));
    }
    main();
}
