// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:45Z
fn main() {
    fn indexOf(s: &'static str, ch: &'static str) -> i32 {
        let mut i = 0;
        while i < s.len() as i32 {
            if s.chars().nth(i as usize).unwrap() == ch {
                return i;
            }
            i += 1;
        }
        return -1;
    }
    fn parseIntStr(str: &'static str) -> i32 {
        let mut i = 0;
        let mut neg = false;
        if str.len() as i32 > 0 && str.chars().nth(0).unwrap() == "-" {
            neg = true;
            i = 1;
        }
        let mut n = 0;
        let digits = { let mut m = std::collections::BTreeMap::new(); m.insert("0", 0); m.insert("1", 1); m.insert("2", 2); m.insert("3", 3); m.insert("4", 4); m.insert("5", 5); m.insert("6", 6); m.insert("7", 7); m.insert("8", 8); m.insert("9", 9); m };
        while i < str.len() as i32 {
            n = n * 10 + digits[&str.chars().nth(i as usize).unwrap()];
            i += 1;
        }
        if neg {
            n = -n;
        }
        return n;
    }
    fn ord(ch: &'static str) -> i32 {
        let upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let lower = "abcdefghijklmnopqrstuvwxyz";
        let mut idx = indexOf(upper, ch);
        if idx >= 0 {
            return 65 + idx;
        }
        idx = indexOf(lower, ch);
        if idx >= 0 {
            return 97 + idx;
        }
        if ch >= "0" && ch <= "9" {
            return 48 + parseIntStr(ch);
        }
        if ch == "+" {
            return 43;
        }
        if ch == "/" {
            return 47;
        }
        if ch == " " {
            return 32;
        }
        if ch == "=" {
            return 61;
        }
        return 0;
    }
    fn chr(n: i32) -> &'static str {
        let upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let lower = "abcdefghijklmnopqrstuvwxyz";
        if n >= 65 && n < 91 {
            return &upper[n - 65 as usize..n - 64 as usize];
        }
        if n >= 97 && n < 123 {
            return &lower[n - 97 as usize..n - 96 as usize];
        }
        if n >= 48 && n < 58 {
            let digits = "0123456789";
            return &digits[n - 48 as usize..n - 47 as usize];
        }
        if n == 43 {
            return "+";
        }
        if n == 47 {
            return "/";
        }
        if n == 32 {
            return " ";
        }
        if n == 61 {
            return "=";
        }
        return "?";
    }
    fn toBinary(n: i32, bits: i32) -> &'static str {
        let mut b = "";
        let mut val = n;
        let mut i = 0;
        while i < bits {
            b = format!("{}{}", val % 2.to_string(), b);
            val = ((val as f64) / (2 as f64)).parse::<i32>().unwrap();
            i += 1;
        }
        return b;
    }
    fn binToInt(bits: &'static str) -> i32 {
        let mut n = 0;
        let mut i = 0;
        while i < bits.len() as i32 {
            n = n * 2 + parseIntStr(&bits[i as usize..i + 1 as usize]);
            i += 1;
        }
        return n;
    }
    fn base64Encode(text: &'static str) -> &'static str {
        let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        let mut bin = "";
        for ch in text {
            bin += toBinary(ord(ch), 8);
        }
        while bin.len() as i32 % 6 != 0 {
            bin += "0";
        }
        let mut out = "";
        let mut i = 0;
        while i < bin.len() as i32 {
            let chunk = &bin[i as usize..i + 6 as usize];
            let val = binToInt(chunk);
            out += &alphabet[val as usize..val + 1 as usize];
            i += 6;
        }
        let pad = (3 - (text.len() as i32 % 3)) % 3;
        if pad == 1 {
            out = format!("{}{}", &out[0 as usize..out.len() as i32 - 1 as usize], "=");
        }
        if pad == 2 {
            out = format!("{}{}", &out[0 as usize..out.len() as i32 - 2 as usize], "==");
        }
        return out;
    }
    fn base64Decode(enc: &'static str) -> &'static str {
        let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        let mut bin = "";
        let mut i = 0;
        while i < enc.len() as i32 {
            let ch = enc.chars().nth(i as usize).unwrap();
            if ch == "=" {
                break;
            }
            let idx = indexOf(alphabet, ch);
            bin += toBinary(idx, 6);
            i += 1;
        }
        let mut out = "";
        i = 0;
        while i + 8 <= bin.len() as i32 {
            let chunk = &bin[i as usize..i + 8 as usize];
            let val = binToInt(chunk);
            out += chr(val);
            i += 8;
        }
        return out;
    }
    let msg = "Rosetta Code Base64 decode data task";
    println!("{}", format!("{}{}", "Original : ", msg));
    let enc = base64Encode(msg);
    println!("{}", format!("{}{}", "
Encoded  : ", enc));
    let dec = base64Decode(enc);
    println!("{}", format!("{}{}", "
Decoded  : ", dec));
}
