// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:56Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    let PI = 3.141592653589793;
    fn conv2d(img: Vec<Vec<f64>>, k: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
        let h = img.len() as i32;
        let w = img[0].len() as i32;
        let n = k.len() as i32;
        let half = (n as f64) / (2 as f64);
        let mut out: Vec<Vec<f64>> = vec![];
        let mut y = 0;
        while y < h {
            let mut row: Vec<f64> = vec![];
            let mut x = 0;
            while x < w {
                let mut sum = 0.0;
                let mut j = 0;
                while j < n {
                    let mut i = 0;
                    while i < n {
                        let mut yy = (y + j as f64) - half;
                        if yy < 0 as f64 {
                            yy = 0;
                        }
                        if yy >= h as f64 {
                            yy = h - 1;
                        }
                        let mut xx = (x + i as f64) - half;
                        if xx < 0 as f64 {
                            xx = 0;
                        }
                        if xx >= w as f64 {
                            xx = w - 1;
                        }
                        sum = sum + img[yy as usize][xx as usize] * k[j as usize][i as usize];
                        i += 1;
                    }
                    j += 1;
                }
                row = append(row, sum);
                x += 1;
            }
            out = append(out, row);
            y += 1;
        }
        return out;
    }
    fn gradient(img: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
        let hx = vec![vec![-1.0, 0.0, 1.0], vec![-2.0, 0.0, 2.0], vec![-1.0, 0.0, 1.0]];
        let hy = vec![vec![1.0, 2.0, 1.0], vec![0.0, 0.0, 0.0], vec![-1.0, -2.0, -1.0]];
        let mut gx = conv2d(img, hx);
        let mut gy = conv2d(img, hy);
        let mut h = img.len() as i32;
        let mut w = img[0].len() as i32;
        let mut out: Vec<Vec<f64>> = vec![];
        let mut y = 0;
        while y < h {
            let mut row: Vec<f64> = vec![];
            let mut x = 0;
            while x < w {
                let g = gx[y as usize][x as usize] * gx[y as usize][x as usize] + gy[y as usize][x as usize] * gy[y as usize][x as usize];
                row = append(row, g);
                x += 1;
            }
            out = append(out, row);
            y += 1;
        }
        return out;
    }
    fn threshold(g: Vec<Vec<f64>>, t: f64) -> Vec<Vec<i32>> {
        let mut h = g.len() as i32;
        let mut w = g[0].len() as i32;
        let mut out: Vec<Vec<i32>> = vec![];
        let mut y = 0;
        while y < h {
            let mut row: Vec<i32> = vec![];
            let mut x = 0;
            while x < w {
                if g[y as usize][x as usize] >= t {
                    row = append(row, 1);
                } else {
                    row = append(row, 0);
                }
                x += 1;
            }
            out = append(out, row);
            y += 1;
        }
        return out;
    }
    fn printMatrix(m: Vec<Vec<i32>>) -> () {
        let mut y = 0;
        while y < m.len() as i32 {
            let mut line = "";
            let mut x = 0;
            while x < m[0].len() as i32 {
                line += m[y as usize][x as usize].to_string();
                if x < m[0].len() as i32 - 1 {
                    line += " ";
                }
                x += 1;
            }
            println!("{}", line);
            y += 1;
        }
    }
    fn main() -> () {
        let img = vec![vec![0.0, 0.0, 0.0, 0.0, 0.0], vec![0.0, 255.0, 255.0, 255.0, 0.0], vec![0.0, 255.0, 255.0, 255.0, 0.0], vec![0.0, 255.0, 255.0, 255.0, 0.0], vec![0.0, 0.0, 0.0, 0.0, 0.0]];
        let g = gradient(img);
        let edges = threshold(g, 1020.0 * 1020.0);
        printMatrix(edges);
    }
    main();
}
