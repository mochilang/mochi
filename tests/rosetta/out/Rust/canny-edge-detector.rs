// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    let PI = 3.141592653589793;
    fn conv2d(img: Vec<Vec<f64>>, k: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
        let h = img.len() as i32;
        let w = img[0].len() as i32;
        let n = k.len() as i32;
        let half = (n as f64) / (2 as f64);
        let mut out: Vec<Vec<f64>> = vec![];
        let mut y = 0;
        while y < h {
            let mut row: Vec<f64> = vec![];
            let mut x = 0;
            while x < w {
                let mut sum = 0.0;
                let mut j = 0;
                while j < n {
                    let mut i = 0;
                    while i < n {
                        let mut yy = (y + j as f64) - half;
                        if yy < 0 as f64 {
                            yy = 0;
                        }
                        if yy >= h as f64 {
                            yy = h - 1;
                        }
                        let mut xx = (x + i as f64) - half;
                        if xx < 0 as f64 {
                            xx = 0;
                        }
                        if xx >= w as f64 {
                            xx = w - 1;
                        }
                        sum = sum + img[yy as usize][xx as usize] * k[j as usize][i as usize];
                        i += 1;
                    }
                    j += 1;
                }
                row = { let mut tmp = row.clone(); tmp.push(sum); tmp };
                x += 1;
            }
            out = { let mut tmp = out.clone(); tmp.push(row); tmp };
            y += 1;
        }
        return out;
    }
    fn gradient(img: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
        let hx = vec![vec![-1.0, 0.0, 1.0], vec![-2.0, 0.0, 2.0], vec![-1.0, 0.0, 1.0]];
        let hy = vec![vec![1.0, 2.0, 1.0], vec![0.0, 0.0, 0.0], vec![-1.0, -2.0, -1.0]];
        let mut gx = conv2d(img, hx);
        let mut gy = conv2d(img, hy);
        let mut h = img.len() as i32;
        let mut w = img[0].len() as i32;
        let mut out: Vec<Vec<f64>> = vec![];
        let mut y = 0;
        while y < h {
            let mut row: Vec<f64> = vec![];
            let mut x = 0;
            while x < w {
                let g = gx[y as usize][x as usize] * gx[y as usize][x as usize] + gy[y as usize][x as usize] * gy[y as usize][x as usize];
                row = { let mut tmp = row.clone(); tmp.push(g); tmp };
                x += 1;
            }
            out = { let mut tmp = out.clone(); tmp.push(row); tmp };
            y += 1;
        }
        return out;
    }
    fn threshold(g: Vec<Vec<f64>>, t: f64) -> Vec<Vec<i32>> {
        let mut h = g.len() as i32;
        let mut w = g[0].len() as i32;
        let mut out: Vec<Vec<i32>> = vec![];
        let mut y = 0;
        while y < h {
            let mut row: Vec<i32> = vec![];
            let mut x = 0;
            while x < w {
                if g[y as usize][x as usize] >= t {
                    row = { let mut tmp = row.clone(); tmp.push(1); tmp };
                } else {
                    row = { let mut tmp = row.clone(); tmp.push(0); tmp };
                }
                x += 1;
            }
            out = { let mut tmp = out.clone(); tmp.push(row); tmp };
            y += 1;
        }
        return out;
    }
    fn printMatrix(m: Vec<Vec<i32>>) -> () {
        let mut y = 0;
        while y < m.len() as i32 {
            let mut line = String::new();
            let mut x = 0;
            while x < m[0].len() as i32 {
                line += m[y as usize][x as usize].to_string();
                if x < m[0].len() as i32 - 1 {
                    line += " ";
                }
                x += 1;
            }
            println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            y += 1;
        }
    }
    fn main() -> () {
        let img = vec![vec![0.0, 0.0, 0.0, 0.0, 0.0], vec![0.0, 255.0, 255.0, 255.0, 0.0], vec![0.0, 255.0, 255.0, 255.0, 0.0], vec![0.0, 255.0, 255.0, 255.0, 0.0], vec![0.0, 0.0, 0.0, 0.0, 0.0]];
        let g = gradient(img);
        let edges = threshold(g, 1020.0 * 1020.0);
        printMatrix(edges);
    }
    main();
}
