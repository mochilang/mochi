// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:56Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Stack {
    start: i32,
    len: i32,
    index: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item {
    start: i32,
    len: i32,
    index: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct Item1 {
    start: i32,
    len: i32,
    index: i32,
}

fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    let width = 81;
    let height = 5;
    let mut lines: Vec<&'static str> = vec![];
    for i in 0..height {
        let mut row = "";
        let mut j = 0;
        while j < width {
            row += "*";
            j += 1;
        }
        lines = append(lines, row);
    }
    fn setChar(s: &'static str, idx: i32, ch: &'static str) -> &'static str {
        return format!("{}{}", format!("{}{}", &s[0 as usize..idx as usize], ch), &s[idx + 1 as usize..s.len() as i32 as usize]);
    }
    let mut stack = vec![Stack { start: 0, len: width, index: 1 }];
    while stack.len() as i32 > 0 {
        let mut frame = stack[stack.len() as i32 - 1 as usize];
        stack = stack[0 as usize..stack.len() as i32 - 1 as usize].to_vec();
        let start = frame.clone()["start" as usize];
        let lenSeg = frame.clone()["len" as usize];
        let index = frame.clone()["index" as usize];
        let seg = ((lenSeg as f64) / 3 as f64).parse::<i32>().unwrap();
        if seg == 0 {
            continue;
        }
        let mut i = index;
        while i < height {
            let mut j = start + seg;
            while j < start + 2 as f64 * seg {
                lines[i as usize] = setChar(lines[i as usize], j, " ");
                j += 1;
            }
            i += 1;
        }
        stack = append(stack, Item { start: start, len: seg, index: index + 1 as f64 });
        stack = append(stack, Item1 { start: start + seg * 2, len: seg, index: index + 1 as f64 });
    }
    for line in lines {
        println!("{}", line);
    }
}
