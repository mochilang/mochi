// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn floorf(x: f64) -> f64 {
        return (x.parse::<i32>().unwrap()).parse::<f64>().unwrap();
    }
    fn indexOf(s: &'static str, ch: &'static str) -> i32 {
        let mut i = 0;
        while i < s.len() as i32 {
            if &s[i as usize..i + 1 as usize] == ch {
                return i;
            }
            i += 1;
        }
        return -1;
    }
    fn fmtF3(x: f64) -> &'static str {
        let mut y = floorf(x * 1000.0 + 0.5) / 1000.0;
        let mut s = y.to_string();
        let mut dot = indexOf(s, ".");
        if dot == 0 - 1 {
            s += ".000";
        } else {
            let mut decs = s.len() as i32 - dot - 1;
            if decs > 3 {
                s = &s[0 as usize..dot + 4 as usize];
            } else {
                while decs < 3 {
                    s += "0";
                    decs += 1;
                }
            }
        }
        return s;
    }
    fn padFloat3(x: f64, width: i32) -> &'static str {
        let mut s = fmtF3(x);
        while s.len() as i32 < width {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn fib1000() -> Vec<f64> {
        let mut a = 0.0;
        let mut b = 1.0;
        let mut res: Vec<f64> = vec![];
        let mut i = 0;
        while i < 1000 {
            res = { let mut tmp = res.clone(); tmp.push(b); tmp };
            let mut t = b;
            b += a;
            a = t;
            i += 1;
        }
        return res;
    }
    fn leadingDigit(x: &mut f64) -> i32 {
        if x < 0.0 {
            x = -x;
        }
        while x >= 10.0 {
            x /= 10.0;
        }
        while x > 0.0 && x < 1.0 {
            x *= 10.0;
        }
        return x.parse::<i32>().unwrap();
    }
    fn show(nums: Vec<f64>, title: &'static str) -> () {
        let mut counts = vec![0, 0, 0, 0, 0, 0, 0, 0, 0];
        for n in nums {
            let d = leadingDigit(&mut n);
            if d >= 1 && d <= 9 {
                counts[d - 1 as usize] = counts[d - 1 as usize] + 1;
            }
        }
        let preds = vec![0.301, 0.176, 0.125, 0.097, 0.079, 0.067, 0.058, 0.051, 0.046];
        let total = nums.len() as i32;
        println!("{}", vec![format!("{}", title)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("Digit  Observed  Predicted");
        let mut i = 0;
        while i < 9 {
            let obs = (counts[i as usize].parse::<f64>().unwrap()) / (total.parse::<f64>().unwrap());
            let mut line = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "  ", i + 1.to_string()), "  "), padFloat3(obs, 9)), "  "), padFloat3(preds[i as usize], 8));
            println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            i += 1;
        }
    }
    fn main() -> () {
        show(fib1000(), "First 1000 Fibonacci numbers");
    }
    main();
}
