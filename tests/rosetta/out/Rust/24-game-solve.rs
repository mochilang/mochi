// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
use std::sync::{atomic::{AtomicBool, AtomicI64, Ordering}, Once};
static INIT_NOW: Once = Once::new();
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);

fn _init_now_seed() {
    INIT_NOW.call_once(|| {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    });
}

fn _now() -> i32 {
    _init_now_seed();
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let mut n = NOW_SEED.load(Ordering::SeqCst);
        n = (n * 1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(n, Ordering::SeqCst);
        return n as i32;
    }
    use std::time::{SystemTime, UNIX_EPOCH};
    (SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64 % i64::from(i32::MAX)) as i32
}

fn main() {
    let OP_NUM = 0;
    let OP_ADD = 1;
    let OP_SUB = 2;
    let OP_MUL = 3;
    let OP_DIV = 4;
    let newNum = move |n: i32| -> std::collections::HashMap<String, i32> {
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("op"), OP_NUM); m.insert(String::from("value"), { let mut m = std::collections::HashMap::new(); m.insert(String::from("num"), n); m.insert(String::from("denom"), 1); m }); m };
    };
    let exprEval = move |x: &std::collections::HashMap<String, i32>| -> std::collections::HashMap<String, i32> {
        if *x.get(&String::from("op")).unwrap() == OP_NUM {
            return *x.get(&String::from("value")).unwrap();
        }
        let l = exprEval(&*x.get(&String::from("left")).unwrap());
        let r = exprEval(&*x.get(&String::from("right")).unwrap());
        if *x.get(&String::from("op")).unwrap() == OP_ADD {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("num"), *l.get(&String::from("num")).unwrap() * *r.get(&String::from("denom")).unwrap() + *l.get(&String::from("denom")).unwrap() * *r.get(&String::from("num")).unwrap()); m.insert(String::from("denom"), *l.get(&String::from("denom")).unwrap() * *r.get(&String::from("denom")).unwrap()); m };
        }
        if *x.get(&String::from("op")).unwrap() == OP_SUB {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("num"), *l.get(&String::from("num")).unwrap() * *r.get(&String::from("denom")).unwrap() - *l.get(&String::from("denom")).unwrap() * *r.get(&String::from("num")).unwrap()); m.insert(String::from("denom"), *l.get(&String::from("denom")).unwrap() * *r.get(&String::from("denom")).unwrap()); m };
        }
        if *x.get(&String::from("op")).unwrap() == OP_MUL {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("num"), *l.get(&String::from("num")).unwrap() * *r.get(&String::from("num")).unwrap()); m.insert(String::from("denom"), *l.get(&String::from("denom")).unwrap() * *r.get(&String::from("denom")).unwrap()); m };
        }
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("num"), *l.get(&String::from("num")).unwrap() * *r.get(&String::from("denom")).unwrap()); m.insert(String::from("denom"), *l.get(&String::from("denom")).unwrap() * *r.get(&String::from("num")).unwrap()); m };
    };
    let exprString = move |x: &std::collections::HashMap<String, i32>| -> String {
        if *x.get(&String::from("op")).unwrap() == OP_NUM {
            return *x.get(&String::from("value")).unwrap().get(&String::from("num")).unwrap().to_string();
        }
        let ls = exprString(&*x.get(&String::from("left")).unwrap());
        let rs = exprString(&*x.get(&String::from("right")).unwrap());
        let mut opstr = String::new();
        if *x.get(&String::from("op")).unwrap() == OP_ADD {
            opstr = String::from(" + ");
        }
        return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", String::from("("), ls), opstr), rs), String::from(")"));
    };
    let n_cards = 4;
    let goal = 24;
    let digit_range = 9;
    let solve = move |xs: Vec<std::collections::HashMap<String, i32>>| -> bool {
        if (xs.len() as i32) == 1 {
            let f = exprEval(&xs[0]);
            if *f.get(&String::from("denom")).unwrap() != 0 && *f.get(&String::from("num")).unwrap() == *f.get(&String::from("denom")).unwrap() * goal {
                println!("{}", vec![format!("{}", exprString(&xs[0]))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                return true;
            }
            return false;
        }
        let mut i = 0;
        while i < (xs.len() as i32) {
            let mut j = i + 1;
            while j < (xs.len() as i32) {
                let mut rest: Vec<std::collections::HashMap<String, i32>> = vec![];
                let mut k = 0;
                while k < (xs.len() as i32) {
                    if k != i && k != j {
                        rest = { let mut tmp = rest.clone(); tmp.push(xs[(k) as usize]); tmp };
                    }
                    k += 1;
                }
                let a = xs[(i) as usize];
                let b = xs[(j) as usize];
                for op in vec![OP_ADD, OP_SUB, OP_MUL, OP_DIV] {
                    let mut node = { let mut m = std::collections::HashMap::new(); m.insert(String::from("op"), op); m.insert(String::from("left"), a); m.insert(String::from("right"), b); m };
                    if solve({ let mut tmp = rest.clone(); tmp.push(node); tmp }) {
                        return true;
                    }
                }
                let mut node = { let mut m = std::collections::HashMap::new(); m.insert(String::from("op"), OP_SUB); m.insert(String::from("left"), b); m.insert(String::from("right"), a); m };
                if solve({ let mut tmp = rest.clone(); tmp.push(node); tmp }) {
                    return true;
                }
                node = { let mut m = std::collections::HashMap::new(); m.insert(String::from("op"), OP_DIV); m.insert(String::from("left"), b); m.insert(String::from("right"), a); m };
                if solve({ let mut tmp = rest.clone(); tmp.push(node); tmp }) {
                    return true;
                }
                j += 1;
            }
            i += 1;
        }
        return false;
    };
    let main = move || -> () {
        let mut iter = 0;
        while iter < 10 {
            let mut cards: Vec<std::collections::HashMap<String, i32>> = vec![];
            let mut i = 0;
            while i < n_cards {
                let n = (_now() % (digit_range - 1)) + 1;
                cards = { let mut tmp = cards.clone(); tmp.push(newNum(n)); tmp };
                println!("{}", vec![format!("{}", format!("{}{}", String::from(" "), n.to_string()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                i += 1;
            }
            println!(":  ");
            if !solve(cards) {
                println!("No solution");
            }
            iter += 1;
        }
    };
    main();
}
