// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    let OP_NUM = 0;
    let OP_ADD = 1;
    let OP_SUB = 2;
    let OP_MUL = 3;
    let OP_DIV = 4;
    let newNum = move |n: i32| -> std::collections::HashMap<&'static str, i32> {
        return { let mut m = std::collections::BTreeMap::new(); m.insert("op", OP_NUM); m.insert("value", { let mut m = std::collections::BTreeMap::new(); m.insert("num", n); m.insert("denom", 1); m }); m };
    };
    let exprEval = move |x: std::collections::HashMap<&'static str, i32>| -> std::collections::HashMap<&'static str, i32> {
        if *x.get(&"op").unwrap() == OP_NUM {
            return *x.get(&"value").unwrap();
        }
        let l = exprEval(*x.get(&"left").unwrap());
        let r = exprEval(*x.get(&"right").unwrap());
        if *x.get(&"op").unwrap() == OP_ADD {
            return { let mut m = std::collections::BTreeMap::new(); m.insert("num", *l.get(&"num").unwrap() * *r.get(&"denom").unwrap() + *l.get(&"denom").unwrap() * *r.get(&"num").unwrap()); m.insert("denom", *l.get(&"denom").unwrap() * *r.get(&"denom").unwrap()); m };
        }
        if *x.get(&"op").unwrap() == OP_SUB {
            return { let mut m = std::collections::BTreeMap::new(); m.insert("num", *l.get(&"num").unwrap() * *r.get(&"denom").unwrap() - *l.get(&"denom").unwrap() * *r.get(&"num").unwrap()); m.insert("denom", *l.get(&"denom").unwrap() * *r.get(&"denom").unwrap()); m };
        }
        if *x.get(&"op").unwrap() == OP_MUL {
            return { let mut m = std::collections::BTreeMap::new(); m.insert("num", *l.get(&"num").unwrap() * *r.get(&"num").unwrap()); m.insert("denom", *l.get(&"denom").unwrap() * *r.get(&"denom").unwrap()); m };
        }
        return { let mut m = std::collections::BTreeMap::new(); m.insert("num", *l.get(&"num").unwrap() * *r.get(&"denom").unwrap()); m.insert("denom", *l.get(&"denom").unwrap() * *r.get(&"num").unwrap()); m };
    };
    let exprString = move |x: std::collections::HashMap<&'static str, i32>| -> &'static str {
        if *x.get(&"op").unwrap() == OP_NUM {
            return *x.get(&"value").unwrap().get(&"num").unwrap().to_string();
        }
        let ls = exprString(*x.get(&"left").unwrap());
        let rs = exprString(*x.get(&"right").unwrap());
        let mut opstr = String::new();
        if *x.get(&"op").unwrap() == OP_ADD {
            opstr = " + ";
        }
        return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "(", ls), opstr), rs), ")");
    };
    let n_cards = 4;
    let goal = 24;
    let digit_range = 9;
    let solve = move |xs: Vec<std::collections::HashMap<&'static str, i32>>| -> bool {
        if xs.len() as i32 == 1 {
            let f = exprEval(xs[0]);
            if *f.get(&"denom").unwrap() != 0 && *f.get(&"num").unwrap() == *f.get(&"denom").unwrap() * goal {
                println!("{}", vec![format!("{}", exprString(xs[0]))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                return true;
            }
            return false;
        }
        let mut i = 0;
        while i < xs.len() as i32 {
            let mut j = i + 1;
            while j < xs.len() as i32 {
                let mut rest: Vec<std::collections::HashMap<&'static str, i32>> = vec![];
                let mut k = 0;
                while k < xs.len() as i32 {
                    if k != i && k != j {
                        rest = { let mut tmp = rest.clone(); tmp.push(xs[k as usize]); tmp };
                    }
                    k += 1;
                }
                let a = xs[i as usize];
                let b = xs[j as usize];
                for op in vec![OP_ADD, OP_SUB, OP_MUL, OP_DIV] {
                    let mut node = { let mut m = std::collections::BTreeMap::new(); m.insert("op", op); m.insert("left", a); m.insert("right", b); m };
                    if solve({ let mut tmp = rest.clone(); tmp.push(node); tmp }) {
                        return true;
                    }
                }
                let mut node = { let mut m = std::collections::BTreeMap::new(); m.insert("op", OP_SUB); m.insert("left", b); m.insert("right", a); m };
                if solve({ let mut tmp = rest.clone(); tmp.push(node); tmp }) {
                    return true;
                }
                node = { let mut m = std::collections::BTreeMap::new(); m.insert("op", OP_DIV); m.insert("left", b); m.insert("right", a); m };
                if solve({ let mut tmp = rest.clone(); tmp.push(node); tmp }) {
                    return true;
                }
                j += 1;
            }
            i += 1;
        }
        return false;
    };
    let main = move || -> () {
        let mut iter = 0;
        while iter < 10 {
            let mut cards: Vec<std::collections::HashMap<&'static str, i32>> = vec![];
            let mut i = 0;
            while i < n_cards {
                let n = (now() % (digit_range - 1)) + 1;
                cards = { let mut tmp = cards.clone(); tmp.push(newNum(n)); tmp };
                println!("{}", vec![format!("{}", format!("{}{}", " ", n.to_string()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                i += 1;
            }
            println!(":  ");
            if !solve(cards) {
                println!("No solution");
            }
            iter += 1;
        }
    };
    main();
}
