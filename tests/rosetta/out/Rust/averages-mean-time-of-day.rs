// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    let PI = 3.141592653589793;
    fn sinApprox(x: f64) -> f64 {
        let mut term = x;
        let mut sum = x;
        let mut n = 1;
        while n <= 8 {
            let denom = ((2 * n) * (2 * n + 1)).parse::<f64>().unwrap();
            term = -term * x * x / denom;
            sum += term;
            n += 1;
        }
        return sum;
    }
    fn cosApprox(x: f64) -> f64 {
        let mut term = 1.0;
        let mut sum = 1.0;
        let mut n = 1;
        while n <= 8 {
            let denom = ((2 * n - 1) * (2 * n)).parse::<f64>().unwrap();
            term = -term * x * x / denom;
            sum += term;
            n += 1;
        }
        return sum;
    }
    let atanApprox = move |x: f64| -> f64 {
        if x > 1.0 {
            return PI / 2.0 - x / (x * x + 0.28);
        }
        if x < (-1.0) {
            return -PI / 2.0 - x / (x * x + 0.28);
        }
        return x / (1.0 + 0.28 * x * x);
    };
    let atan2Approx = move |y: f64, x: f64| -> f64 {
        if x > 0.0 {
            return atanApprox(y / x);
        }
        if x < 0.0 {
            if y >= 0.0 {
                return atanApprox(y / x) + PI;
            }
            return atanApprox(y / x) - PI;
        }
        if y > 0.0 {
            return PI / 2.0;
        }
        if y < 0.0 {
            return -PI / 2.0;
        }
        return 0.0;
    };
    fn digit(ch: &'static str) -> i32 {
        let digits = "0123456789";
        let mut i = 0;
        while i < digits.len() as i32 {
            if &digits[i as usize..i + 1 as usize] == ch {
                return i;
            }
            i += 1;
        }
        return 0;
    }
    fn parseTwo(s: &'static str, idx: i32) -> i32 {
        return digit(&s[idx as usize..idx + 1 as usize]) * 10 + digit(&s[idx + 1 as usize..idx + 2 as usize]);
    }
    fn parseSec(s: &'static str) -> f64 {
        let h = parseTwo(s, 0);
        let m = parseTwo(s, 3);
        let sec = parseTwo(s, 6);
        return ((h * 60 + m) * 60 + sec).parse::<f64>().unwrap();
    }
    fn pad(n: i32) -> &'static str {
        if n < 10 {
            return format!("{}{}", "0", n.to_string());
        }
        return n.to_string();
    }
    let meanTime = move |times: Vec<&'static str>| -> &'static str {
        let mut ssum = 0.0;
        let mut csum = 0.0;
        let mut i = 0;
        while i < times.len() as i32 {
            let sec = parseSec(times[i as usize]);
            let ang = sec * 2.0 * PI / 86400.0;
            ssum += sinApprox(ang);
            csum += cosApprox(ang);
            i += 1;
        }
        let mut theta = atan2Approx(ssum, csum);
        let mut frac = theta / (2.0 * PI);
        while frac < 0.0 {
            frac += 1.0;
        }
        let total = frac * 86400.0;
        let si = total.parse::<i32>().unwrap();
        let h = ((si as f64) / (3600 as f64)).parse::<i32>().unwrap();
        let m = (((si % 3600) as f64) / (60 as f64)).parse::<i32>().unwrap();
        let s = (si % 60).parse::<i32>().unwrap();
        return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", pad(h), ":"), pad(m)), ":"), pad(s));
    };
    fn main() -> () {
        let inputs = vec!["23:00:17", "23:40:20", "00:12:45", "00:17:19"];
        println!("{}", vec![format!("{}", meanTime(inputs))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    }
    main();
}
