// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn primesUpTo(n: i32) -> Vec<i32> {
        let mut sieve: Vec<bool> = vec![];
        let mut i = 0;
        while i <= n {
            sieve = { let mut tmp = sieve.clone(); tmp.push(true); tmp };
            i += 1;
        }
        let mut p = 2;
        while p * p <= n {
            if sieve[p as usize] {
                let mut m = p * p;
                while m <= n {
                    sieve[m as usize] = false;
                    m += p;
                }
            }
            p += 1;
        }
        let mut res: Vec<i32> = vec![];
        let mut x = 2;
        while x <= n {
            if sieve[x as usize] {
                res = { let mut tmp = res.clone(); tmp.push(x); tmp };
            }
            x += 1;
        }
        return res;
    }
    let LIMIT = 999999;
    let primes = primesUpTo(LIMIT);
    let longestSeq = move |dir: &'static str| -> () {
        let mut pd = 0;
        let mut longSeqs: Vec<Vec<i32>> = vec![vec![2]];
        let mut currSeq: Vec<i32> = vec![2];
        let mut i = 1;
        while i < primes.len() as i32 {
            let d = primes[i as usize] - primes[i - 1 as usize];
            if (dir == "ascending" && d <= pd) || (dir == "descending" && d >= pd) {
                if currSeq.len() as i32 > longSeqs[0].len() as i32 {
                    longSeqs = vec![currSeq];
                }
                currSeq = vec![primes[i - 1 as usize], primes[i as usize]];
            } else {
                currSeq = { let mut tmp = currSeq.clone(); tmp.push(primes[i as usize]); tmp };
            }
            pd = d;
            i += 1;
        }
        if currSeq.len() as i32 > longSeqs[0].len() as i32 {
            longSeqs = vec![currSeq];
        }
        println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Longest run(s) of primes with ", dir), " differences is "), longSeqs[0].len() as i32.to_string()), " :"))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        for ls in longSeqs {
            let mut diffs: Vec<i32> = vec![];
            let mut j = 1;
            while j < ls.len() as i32 {
                diffs = { let mut tmp = diffs.clone(); tmp.push(ls[j as usize] - ls[j - 1 as usize]); tmp };
                j += 1;
            }
            let mut k = 0;
            while k < ls.len() as i32 - 1 {
                println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", ls[k as usize].to_string(), " ("), diffs[k as usize].to_string()), ") ")), format!("{}", if false {1} else {0})].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                k += 1;
            }
            println!("{}", vec![format!("{}", ls[ls.len() as i32 - 1 as usize].to_string())].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        }
        println!("");
    };
    fn main() -> () {
        println!("For primes < 1 million:\n");
        for dir in vec!["ascending", "descending"] {
            longestSeq(dir);
        }
    }
    main();
}
