// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:57Z
#[derive(Default, Debug, Clone, PartialEq)]
struct Point {
        x: f64,
        y: f64,
}

fn main() {
    fn sqrtApprox(x: f64) -> f64 {
        let mut g = x;
        let mut i = 0;
        while i < 40 {
            g = (g + x / g) / 2.0;
            i += 1;
        }
        return g;
    }
    fn hypot(x: f64, y: f64) -> f64 {
        return sqrtApprox(x * x + y * y);
    }
    let Two = "Two circles.";
    let R0 = "R==0.0 does not describe circles.";
    let Co = "Coincident points describe an infinite number of circles.";
    let CoR0 = "Coincident points with r==0.0 describe a degenerate circle.";
    let Diam = "Points form a diameter and describe only a single circle.";
    let Far = "Points too far apart to form circles.";
    fn circles(p1: Point, p2: Point, r: f64) -> Vec<i32> {
        if p1.x == p2.x && p1.y == p2.y {
            if r == 0.0 {
                return vec![p1.clone(), p1.clone(), "Coincident points with r==0.0 describe a degenerate circle."];
            }
            return vec![p1.clone(), p2.clone(), "Coincident points describe an infinite number of circles."];
        }
        if r == 0.0 {
            return vec![p1.clone(), p2.clone(), "R==0.0 does not describe circles."];
        }
        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;
        let q = hypot(dx, dy);
        if q > 2.0 * r {
            return vec![p1.clone(), p2.clone(), "Points too far apart to form circles."];
        }
        let m = Point { x: (p1.x + p2.x) / 2.0, y: (p1.y + p2.y) / 2.0 };
        if q == 2.0 * r {
            return vec![m.clone(), m.clone(), "Points form a diameter and describe only a single circle."];
        }
        let d = sqrtApprox(r * r - q * q / 4.0);
        let ox = d * dx / q;
        let oy = d * dy / q;
        return vec![Point { x: m.x - oy, y: m.y + ox }, Point { x: m.x + oy, y: m.y - ox }, "Two circles."];
    }
    let mut td = vec![vec![Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }, 2.0], vec![Point { x: 0.0, y: 2.0 }, Point { x: 0.0, y: 0.0 }, 1.0], vec![Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 }, 2.0], vec![Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }, 0.5], vec![Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 }, 0.0]];
    for tc in td {
        let p1 = tc[0];
        let p2 = tc[1];
        let r = tc[2];
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "p1:  {", p1.x.to_string()), " "), p1.y.to_string()), "}"));
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "p2:  {", p2.x.to_string()), " "), p2.y.to_string()), "}"));
        println!("{}", format!("{}{}", "r:  ", r.to_string()));
        let res = circles(&p1, &p2, r);
        let c1 = res[0];
        let c2 = res[1];
        let caseStr = res[2];
        println!("{:?}", format!("{}{}", "   ", caseStr));
        if caseStr == "Points form a diameter and describe only a single circle." || caseStr == "Coincident points with r==0.0 describe a degenerate circle." {
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "   Center:  {", c1.x.to_string()), " "), c1.y.to_string()), "}"));
        } else {
            if caseStr == "Two circles." {
                println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "   Center 1:  {", c1.x.to_string()), " "), c1.y.to_string()), "}"));
                println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "   Center 2:  {", c2.x.to_string()), " "), c2.y.to_string()), "}"));
            }
        }
        println!("");
    }
}
