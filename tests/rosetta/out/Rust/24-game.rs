// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
use std::sync::{atomic::{AtomicBool, AtomicI64, Ordering}, Once};
static INIT_NOW: Once = Once::new();
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);

fn _init_now_seed() {
    INIT_NOW.call_once(|| {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    });
}

fn _now() -> i32 {
    _init_now_seed();
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let mut n = NOW_SEED.load(Ordering::SeqCst);
        n = (n * 1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(n, Ordering::SeqCst);
        return n as i32;
    }
    use std::time::{SystemTime, UNIX_EPOCH};
    (SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64 % i64::from(i32::MAX)) as i32
}

fn main() {
    let randDigit = move || -> i32 {
        return (_now() % 9) + 1;
    };
    let main = move || -> () {
        let mut digits = vec![];
        for i in 0..4 {
            digits = { let mut tmp = digits.clone(); tmp.push(randDigit()); tmp };
        }
        let mut numstr = String::new();
        for i in 0..4 {
            numstr = format!("{}{}", numstr, digits[(i) as usize].clone().to_string());
        }
        println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", String::from("Your numbers: "), numstr), String::from("
")))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("Enter RPN: ");
        let mut expr = input();
        if (expr.len() as i32) != 7 {
            println!("invalid. expression length must be 7. (4 numbers, 3 operators, no spaces)");
            return ();
        }
        let mut stack = vec![];
        let mut i = 0;
        let mut valid = true;
        while i < (expr.len() as i32) {
            let ch = expr[(i) as usize..(i + 1) as usize].to_string();
            if ch >= String::from("0") && ch <= String::from("9") {
                if (digits.len() as i32) == 0 {
                    println!("too many numbers.");
                    return ();
                }
                let mut j = 0;
                while digits[(j) as usize].clone() != int(ch) - int(String::from("0")) {
                    j += 1;
                    if j == (digits.len() as i32) {
                        println!("wrong numbers.");
                        return ();
                    }
                }
                digits = digits[(0) as usize..(j) as usize].to_vec() + digits[(j + 1) as usize..(digits.len()) as usize].to_vec();
                stack = { let mut tmp = stack.clone(); tmp.push(float(int(ch) - int(String::from("0")))); tmp };
            } else {
                if (stack.len() as i32) < 2 {
                    println!("invalid expression syntax.");
                    valid = false;
                    break;
                }
                let mut b = stack[((stack.len() as i32) - 1) as usize].clone();
                let mut a = stack[((stack.len() as i32) - 2) as usize].clone();
                if ch == String::from("+") {
                    stack[((stack.len() as i32) - 2) as usize] = a + b;
                }
                stack = stack[(0) as usize..((stack.len() as i32) - 1) as usize].to_vec();
            }
            i += 1;
        }
        if valid {
            if abs(stack[0].clone() - 24.0) > 1e-06 {
                println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", String::from("incorrect. "), stack[0].clone().to_string()), String::from(" != 24")))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            } else {
                println!("correct.");
            }
        }
    };
    main();
}
