// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn trimSpace(s: &'static str) -> &'static str {
        let mut start = 0;
        while start < s.len() as i32 && &s[start as usize..start + 1 as usize] == " " {
            start += 1;
        }
        let mut end = s.len() as i32;
        while end > start && &s[end - 1 as usize..end as usize] == " " {
            end -= 1;
        }
        return &s[start as usize..end as usize];
    }
    fn isUpper(ch: &'static str) -> bool {
        return ch >= "A" && ch <= "Z";
    }
    fn padLeft(s: &'static str, w: i32) -> &'static str {
        let mut res = String::new();
        let mut n = w - s.len() as i32;
        while n > 0 {
            res += " ";
            n -= 1;
        }
        return format!("{}{}", res, s);
    }
    fn snakeToCamel(s: &mut &'static str) -> &'static str {
        s = trimSpace(s);
        let mut out = String::new();
        let mut up = false;
        let mut i = 0;
        while i < s.len() as i32 {
            let ch = &s[i as usize..i + 1 as usize];
            if ch == "_" || ch == "-" || ch == " " || ch == "." {
                up = true;
                i += 1;
                continue;
            }
            if i == 0 {
                out += lower(ch);
                up = false;
                i += 1;
                continue;
            }
            if up {
                out += upper(ch);
                up = false;
            } else {
                out += ch;
            }
            i += 1;
        }
        return out;
    }
    fn camelToSnake(s: &mut &'static str) -> &'static str {
        s = trimSpace(s);
        let mut out = String::new();
        let mut prevUnd = false;
        let mut i = 0;
        while i < s.len() as i32 {
            let ch = &s[i as usize..i + 1 as usize];
            if ch == " " || ch == "-" || ch == "." {
                if !prevUnd && out.len() as i32 > 0 {
                    out += "_";
                    prevUnd = true;
                }
                i += 1;
                continue;
            }
            if ch == "_" {
                if !prevUnd && out.len() as i32 > 0 {
                    out += "_";
                    prevUnd = true;
                }
                i += 1;
                continue;
            }
            if isUpper(ch) {
                if i > 0 && (!prevUnd) {
                    out += "_";
                }
                out += lower(ch);
                prevUnd = false;
            } else {
                out += lower(ch);
                prevUnd = false;
            }
            i += 1;
        }
        let mut start = 0;
        while start < out.len() as i32 && &out[start as usize..start + 1 as usize] == "_" {
            start += 1;
        }
        let mut end = out.len() as i32;
        while end > start && &out[end - 1 as usize..end as usize] == "_" {
            end -= 1;
        }
        out = &out[start as usize..end as usize];
        let mut res = String::new();
        let mut j = 0;
        let mut lastUnd = false;
        while j < out.len() as i32 {
            let c = &out[j as usize..j + 1 as usize];
            if c == "_" {
                if !lastUnd {
                    res += c;
                }
                lastUnd = true;
            } else {
                res += c;
                lastUnd = false;
            }
            j += 1;
        }
        return res;
    }
    fn main() -> () {
        let samples = vec!["snakeCase", "snake_case", "snake-case", "snake case", "snake CASE", "snake.case", "variable_10_case", "variable10Case", "É›rgo rE tHis", "hurry-up-joe!", "c://my-docs/happy_Flag-Day/12.doc", " spaces "];
        println!("=== To snake_case ===");
        for s in samples {
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", padLeft(s, 34), " => "), camelToSnake(&mut s)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        }
        println!("");
        println!("=== To camelCase ===");
        for s in samples {
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", padLeft(s, 34), " => "), snakeToCamel(&mut s)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        }
    }
    main();
}
