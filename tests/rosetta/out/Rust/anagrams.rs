// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn sortRunes(s: &'static str) -> &'static str {
        let mut arr: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < s.len() as i32 {
            arr = { let mut tmp = arr.clone(); tmp.push(&s[i as usize..i + 1 as usize]); tmp };
            i += 1;
        }
        let mut n = arr.len() as i32;
        let mut m = 0;
        while m < n {
            let mut j = 0;
            while j < n - 1 {
                if arr[j as usize] > arr[j + 1 as usize] {
                    let tmp = arr[j as usize];
                    arr[j as usize] = arr[j + 1 as usize];
                    arr[j + 1 as usize] = tmp;
                }
                j += 1;
            }
            m += 1;
        }
        let mut out = String::new();
        i = 0;
        while i < n {
            out += arr[i as usize];
            i += 1;
        }
        return out;
    }
    fn sortStrings(xs: Vec<&'static str>) -> Vec<&'static str> {
        let mut res: Vec<&'static str> = vec![];
        let mut tmp = xs;
        while tmp.len() as i32 > 0 {
            let mut min = tmp[0];
            let mut idx = 0;
            let mut i = 1;
            while i < tmp.len() as i32 {
                if tmp[i as usize] < min {
                    min = tmp[i as usize];
                    idx = i;
                }
                i += 1;
            }
            res = { let mut tmp = res.clone(); tmp.push(min); tmp };
            let mut out: Vec<&'static str> = vec![];
            let mut j = 0;
            while j < tmp.len() as i32 {
                if j != idx {
                    out = { let mut tmp = out.clone(); tmp.push(tmp[j as usize]); tmp };
                }
                j += 1;
            }
            tmp = out;
        }
        return res;
    }
    fn main() -> () {
        let words = vec!["abel", "able", "bale", "bela", "elba", "alger", "glare", "lager", "large", "regal", "angel", "angle", "galen", "glean", "lange", "caret", "carte", "cater", "crate", "trace", "elan", "lane", "lean", "lena", "neal", "evil", "levi", "live", "veil", "vile"];
        let mut groups: std::collections::HashMap<&'static str, Vec<&'static str>> = { let mut m = std::collections::BTreeMap::new(); m };
        let mut maxLen = 0;
        for w in words {
            let k = sortRunes(w);
            if !(groups.contains_key(&k)) {
                groups.insert(k, vec![w]);
            } else {
                groups.insert(k, { let mut tmp = *groups.get(&k).unwrap().clone(); tmp.push(w); tmp });
            }
            if *groups.get(&k).unwrap().len() as i32 > maxLen {
                maxLen = *groups.get(&k).unwrap().len() as i32;
            }
        }
        let mut printed: std::collections::HashMap<&'static str, bool> = { let mut m = std::collections::BTreeMap::new(); m };
        for w in words {
            let k = sortRunes(w);
            if *groups.get(&k).unwrap().len() as i32 == maxLen {
                if !(printed.contains_key(&k)) {
                    let mut g = sortStrings(*groups.get(&k).unwrap());
                    let mut line = format!("{}{}", "[", g[0]);
                    let mut i = 1;
                    while i < g.len() as i32 {
                        line = format!("{}{}", format!("{}{}", line, " "), g[i as usize]);
                        i += 1;
                    }
                    line += "]";
                    println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                    printed.insert(k, true);
                }
            }
        }
    }
    main();
}
