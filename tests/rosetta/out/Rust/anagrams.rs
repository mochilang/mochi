// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:35Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn sortRunes(s: &'static str) -> &'static str {
        let mut arr: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < s.len() as i32 {
            arr = append(arr, &s[i as usize..i + 1 as usize]);
            i += 1;
        }
        let mut n = arr.len() as i32;
        let mut m = 0;
        while m < n {
            let mut j = 0;
            while j < n - 1 {
                if arr[j as usize] > arr[j + 1 as usize] {
                    let tmp = arr[j as usize];
                    arr[j as usize] = arr[j + 1 as usize];
                    arr[j + 1 as usize] = tmp;
                }
                j += 1;
            }
            m += 1;
        }
        let mut out = "";
        i = 0;
        while i < n {
            out += arr[i as usize];
            i += 1;
        }
        return out;
    }
    fn sortStrings(xs: Vec<&'static str>) -> Vec<&'static str> {
        let mut res: Vec<&'static str> = vec![];
        let mut tmp = xs;
        while tmp.len() as i32 > 0 {
            let mut min = tmp[0];
            let mut idx = 0;
            let mut i = 1;
            while i < tmp.len() as i32 {
                if tmp[i as usize] < min {
                    min = tmp[i as usize];
                    idx = i;
                }
                i += 1;
            }
            res = append(res, min);
            let mut out: Vec<&'static str> = vec![];
            let mut j = 0;
            while j < tmp.len() as i32 {
                if j != idx {
                    out = append(out, tmp[j as usize]);
                }
                j += 1;
            }
            tmp = out;
        }
        return res;
    }
    fn main() -> () {
        let words = vec!["abel", "able", "bale", "bela", "elba", "alger", "glare", "lager", "large", "regal", "angel", "angle", "galen", "glean", "lange", "caret", "carte", "cater", "crate", "trace", "elan", "lane", "lean", "lena", "neal", "evil", "levi", "live", "veil", "vile"];
        let mut groups: std::collections::HashMap<&'static str, Vec<&'static str>> = { let mut m = std::collections::BTreeMap::new(); m };
        let mut maxLen = 0;
        for w in words {
            let k = sortRunes(w);
            if !(groups.contains_key(&k)) {
                groups.insert(k, vec![w]);
            } else {
                groups.insert(k, append(groups[&k], w));
            }
            if groups[&k].len() as i32 > maxLen {
                maxLen = groups[&k].len() as i32;
            }
        }
        let mut printed: std::collections::HashMap<&'static str, bool> = { let mut m = std::collections::BTreeMap::new(); m };
        for w in words {
            let k = sortRunes(w);
            if groups[&k].len() as i32 == maxLen {
                if !(printed.contains_key(&k)) {
                    let mut g = sortStrings(groups[&k]);
                    let mut line = format!("{}{}", "[", g[0]);
                    let mut i = 1;
                    while i < g.len() as i32 {
                        line = format!("{}{}", format!("{}{}", line, " "), g[i as usize]);
                        i += 1;
                    }
                    line += "]";
                    println!("{}", line);
                    printed.insert(k, true);
                }
            }
        }
    }
    main();
}
