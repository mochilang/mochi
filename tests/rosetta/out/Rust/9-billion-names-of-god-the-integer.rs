// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:37Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn bigTrim(a: &mut Vec<i32>) -> Vec<i32> {
        let mut n = a.len() as i32;
        while n > 1 && a[n - 1 as usize] == 0 {
            a = a[0 as usize..n - 1 as usize].to_vec();
            n -= 1;
        }
        return a;
    }
    fn bigFromInt(x: i32) -> Vec<i32> {
        if x == 0 {
            return vec![0];
        }
        let mut digits: Vec<i32> = vec![];
        let mut n = x;
        while n > 0 {
            digits = append(digits, n % 10);
            n /= 10;
        }
        return digits;
    }
    fn bigAdd(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {
        let mut res: Vec<i32> = vec![];
        let mut carry = 0;
        let mut i = 0;
        while i < a.len() as i32 || i < b.len() as i32 || carry > 0 {
            let mut av = 0;
            if i < a.len() as i32 {
                av = a[i as usize];
            }
            let mut bv = 0;
            if i < b.len() as i32 {
                bv = b[i as usize];
            }
            let mut s = av + bv + carry;
            res = append(res, s % 10);
            carry = (s as f64) / (10 as f64);
            i += 1;
        }
        return bigTrim(&mut res);
    }
    fn bigSub(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {
        let mut res: Vec<i32> = vec![];
        let mut borrow = 0;
        let mut i = 0;
        while i < a.len() as i32 {
            let mut av = a[i as usize];
            let mut bv = 0;
            if i < b.len() as i32 {
                bv = b[i as usize];
            }
            let mut diff = av - bv - borrow;
            if diff < 0 {
                diff += 10;
                borrow = 1;
            } else {
                borrow = 0;
            }
            res = append(res, diff);
            i += 1;
        }
        return bigTrim(&mut res);
    }
    fn bigToString(a: Vec<i32>) -> &'static str {
        let mut s = "";
        let mut i = a.len() as i32 - 1;
        while i >= 0 {
            s += a[i as usize].to_string();
            i -= 1;
        }
        return s;
    }
    fn minInt(a: i32, b: i32) -> i32 {
        if a < b {
            return a;
        } else {
            return b;
        }
    }
    fn cumu(n: i32) -> Vec<Vec<i32>> {
        let mut cache: Vec<Vec<Vec<i32>>> = vec![vec![bigFromInt(1)]];
        let mut y = 1;
        while y <= n {
            let mut row: Vec<Vec<i32>> = vec![bigFromInt(0)];
            let mut x = 1;
            while x <= y {
                let val = cache[y - x as usize][minInt(x, y - x) as usize];
                row = append(row, bigAdd(row[row.len() as i32 - 1 as usize], val));
                x += 1;
            }
            cache = append(cache, row);
            y += 1;
        }
        return cache[n as usize];
    }
    fn row(n: i32) -> Vec<&'static str> {
        let e = cumu(n);
        let mut out: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < n {
            let diff = bigSub(e[i + 1 as usize], e[i as usize]);
            out = append(out, bigToString(diff));
            i += 1;
        }
        return out;
    }
    println!("rows:");
    let mut x = 1;
    while x < 11 {
        let r = row(x);
        let mut line = "";
        let mut i = 0;
        while i < r.len() as i32 {
            line = format!("{}{}", format!("{}{}", format!("{}{}", line, " "), r[i as usize]), " ");
            i += 1;
        }
        println!("{}", line);
        x += 1;
    }
    println!("");
    println!("sums:");
    for num in vec![23, 123, 1234] {
        let r = cumu(num);
        println!("{}", format!("{}{}", format!("{}{}", num.to_string(), " "), bigToString(r[r.len() as i32 - 1 as usize])));
    }
}
