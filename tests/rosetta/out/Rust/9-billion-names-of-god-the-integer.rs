// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    let bigTrim = move |a: &mut Vec<i32>| -> Vec<i32> {
        let mut n = (a.len() as i32);
        while n > 1 && a[(n - 1) as usize].clone() == 0 {
            a = a[(0) as usize..(n - 1) as usize].to_vec();
            n -= 1;
        }
        return a;
    };
    let bigFromInt = move |x: i32| -> Vec<i32> {
        if x == 0 {
            return vec![0];
        }
        let mut digits: Vec<i32> = vec![];
        let mut n = x;
        while n > 0 {
            digits = { let mut tmp = digits.clone(); tmp.push(n % 10); tmp };
            n /= 10;
        }
        return digits;
    };
    let bigAdd = move |a: Vec<i32>, b: Vec<i32>| -> Vec<i32> {
        let mut res: Vec<i32> = vec![];
        let mut carry = 0;
        let mut i = 0;
        while i < (a.len() as i32) || i < (b.len() as i32) || carry > 0 {
            let mut av = 0;
            if i < (a.len() as i32) {
                av = a[(i) as usize].clone();
            }
            let mut bv = 0;
            if i < (b.len() as i32) {
                bv = b[(i) as usize].clone();
            }
            let mut s = av + bv + carry;
            res = { let mut tmp = res.clone(); tmp.push(s % 10); tmp };
            carry = (s as f64) / (10 as f64);
            i += 1;
        }
        return bigTrim(&mut res);
    };
    let bigSub = move |a: Vec<i32>, b: Vec<i32>| -> Vec<i32> {
        let mut res: Vec<i32> = vec![];
        let mut borrow = 0;
        let mut i = 0;
        while i < (a.len() as i32) {
            let mut av = a[(i) as usize].clone();
            let mut bv = 0;
            if i < (b.len() as i32) {
                bv = b[(i) as usize].clone();
            }
            let mut diff = av - bv - borrow;
            if diff < 0 {
                diff += 10;
                borrow = 1;
            } else {
                borrow = 0;
            }
            res = { let mut tmp = res.clone(); tmp.push(diff); tmp };
            i += 1;
        }
        return bigTrim(&mut res);
    };
    let bigToString = move |a: Vec<i32>| -> String {
        let mut s = String::new();
        let mut i = (a.len() as i32) - 1;
        while i >= 0 {
            s = format!("{}{}", s, a[(i) as usize].clone().to_string());
            i -= 1;
        }
        return s;
    };
    let minInt = move |a: i32, b: i32| -> i32 {
        if a < b {
            return a;
        } else {
            return b;
        }
    };
    let cumu = move |n: i32| -> Vec<Vec<i32>> {
        let mut cache: Vec<Vec<Vec<i32>>> = vec![vec![bigFromInt(1)]];
        let mut y = 1;
        while y <= n {
            let mut row: Vec<Vec<i32>> = vec![bigFromInt(0)];
            let mut x = 1;
            while x <= y {
                let val = cache[(y - x) as usize].clone()[(minInt(x, y - x)) as usize].clone();
                row = append(row, bigAdd(row[((row.len() as i32) - 1) as usize].clone(), val));
                x += 1;
            }
            cache = { let mut tmp = cache.clone(); tmp.push(row); tmp };
            y += 1;
        }
        return cache[(n) as usize].clone();
    };
    let row = move |n: i32| -> Vec<String> {
        let e = cumu(n);
        let mut out: Vec<String> = vec![];
        let mut i = 0;
        while i < n {
            let diff = bigSub(e[(i + 1) as usize].clone(), e[(i) as usize].clone());
            out = { let mut tmp = out.clone(); tmp.push(bigToString(diff)); tmp };
            i += 1;
        }
        return out;
    };
    println!("rows:");
    let mut x = 1;
    while x < 11 {
        let r = row(x);
        let mut line = String::new();
        let mut i = 0;
        while i < (r.len() as i32) {
            line = format!("{}{}", format!("{}{}", format!("{}{}", line, String::from(" ")), r[(i) as usize].clone()), String::from(" "));
            i += 1;
        }
        println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        x += 1;
    }
    println!("");
    println!("sums:");
    for num in vec![23, 123, 1234] {
        let r = cumu(num);
        println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", num.to_string(), String::from(" ")), bigToString(r[((r.len() as i32) - 1) as usize].clone())))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    }
}
