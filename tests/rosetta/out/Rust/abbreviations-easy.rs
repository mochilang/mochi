// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn fields(s: &'static str) -> Vec<&'static str> {
        let mut words: Vec<&'static str> = vec![];
        let mut cur = String::new();
        let mut i = 0;
        while i < s.len() as i32 {
            let ch = &s[i as usize..i + 1 as usize];
            if ch == " " || ch == "
" || ch == "	" {
                if cur.len() as i32 > 0 {
                    words = { let mut tmp = words.clone(); tmp.push(cur); tmp };
                    cur = "";
                }
            } else {
                cur += ch;
            }
            i += 1;
        }
        if cur.len() as i32 > 0 {
            words = { let mut tmp = words.clone(); tmp.push(cur); tmp };
        }
        return words;
    }
    fn padRight(s: &'static str, width: i32) -> &'static str {
        let mut out = s;
        let mut i = s.len() as i32;
        while i < width {
            out += " ";
            i += 1;
        }
        return out;
    }
    fn join(xs: Vec<&'static str>, sep: &'static str) -> &'static str {
        let mut res = String::new();
        let mut i = 0;
        while i < xs.len() as i32 {
            if i > 0 {
                res += sep;
            }
            res += xs[i as usize];
            i += 1;
        }
        return res;
    }
    fn validate(commands: Vec<&'static str>, words: Vec<&'static str>, mins: Vec<i32>) -> Vec<&'static str> {
        let mut results: Vec<&'static str> = vec![];
        if words.len() as i32 == 0 {
            return results;
        }
        let mut wi = 0;
        while wi < words.len() as i32 {
            let w = words[wi as usize];
            let mut found = false;
            let wlen = w.len() as i32;
            let mut ci = 0;
            while ci < commands.len() as i32 {
                let cmd = commands[ci as usize];
                if mins[ci as usize] != 0 && wlen >= mins[ci as usize] && wlen <= cmd.len() as i32 {
                    let c = upper(cmd);
                    let ww = upper(w);
                    if &c[0 as usize..wlen as usize] == ww {
                        results = { let mut tmp = results.clone(); tmp.push(c); tmp };
                        found = true;
                        break;
                    }
                }
                ci += 1;
            }
            if !found {
                results = { let mut tmp = results.clone(); tmp.push("*error*"); tmp };
            }
            wi += 1;
        }
        return results;
    }
    fn main() -> () {
        let table = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy ", "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find "), "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "), " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "), "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "), "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "), "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp ");
        let commands = fields(table);
        let mut mins: Vec<i32> = vec![];
        let mut i = 0;
        while i < commands.len() as i32 {
            let mut count = 0;
            let mut j = 0;
            let cmd = commands[i as usize];
            while j < cmd.len() as i32 {
                let ch = &cmd[j as usize..j + 1 as usize];
                if ch >= "A" && ch <= "Z" {
                    count += 1;
                }
                j += 1;
            }
            mins = { let mut tmp = mins.clone(); tmp.push(count); tmp };
            i += 1;
        }
        let sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin";
        let words = fields(sentence);
        let results = validate(commands, words, mins);
        let mut out1 = String::from("user words:  ");
        let mut k = 0;
        while k < words.len() as i32 {
            out1 = format!("{}{}", format!("{}{}", out1, padRight(words[k as usize], results[k as usize].len() as i32)), " ");
            k += 1;
        }
        println!("{}", vec![format!("{}", out1)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "full words:  ", join(results, " ")))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    }
    main();
}
