// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
fn main() {
    let fields = move |s: String| -> Vec<String> {
        let mut words: Vec<String> = vec![];
        let mut cur = String::new();
        let mut i = 0;
        while i < (s.len() as i32) {
            let ch = s[(i) as usize..(i + 1) as usize].to_string();
            if ch == String::from(" ") || ch == String::from("
") || ch == String::from("	") {
                if (cur.len() as i32) > 0 {
                    words = { let mut tmp = words.clone(); tmp.push(cur); tmp };
                    cur = String::from("");
                }
            } else {
                cur = format!("{}{}", cur, ch);
            }
            i += 1;
        }
        if (cur.len() as i32) > 0 {
            words = { let mut tmp = words.clone(); tmp.push(cur); tmp };
        }
        return words;
    };
    let padRight = move |s: String, width: i32| -> String {
        let mut out = s;
        let mut i = (s.len() as i32);
        while i < width {
            out = format!("{}{}", out, String::from(" "));
            i += 1;
        }
        return out;
    };
    let join = move |xs: Vec<String>, sep: String| -> String {
        let mut res = String::new();
        let mut i = 0;
        while i < (xs.len() as i32) {
            if i > 0 {
                res = format!("{}{}", res, sep);
            }
            res = format!("{}{}", res, xs[(i) as usize].clone());
            i += 1;
        }
        return res;
    };
    let validate = move |commands: Vec<String>, words: Vec<String>, mins: Vec<i32>| -> Vec<String> {
        let mut results: Vec<String> = vec![];
        if (words.len() as i32) == 0 {
            return results;
        }
        let mut wi = 0;
        while wi < (words.len() as i32) {
            let w = words[(wi) as usize].clone();
            let mut found = false;
            let wlen = (w.len() as i32);
            let mut ci = 0;
            while ci < (commands.len() as i32) {
                let cmd = commands[(ci) as usize].clone();
                if mins[(ci) as usize].clone() != 0 && wlen >= mins[(ci) as usize].clone() && wlen <= (cmd.len() as i32) {
                    let c = upper(cmd);
                    let ww = upper(w);
                    if c[(0) as usize..(wlen) as usize].to_string() == ww {
                        results = { let mut tmp = results.clone(); tmp.push(c); tmp };
                        found = true;
                        break;
                    }
                }
                ci += 1;
            }
            if !found {
                results = { let mut tmp = results.clone(); tmp.push(String::from("*error*")); tmp };
            }
            wi += 1;
        }
        return results;
    };
    let main = move || -> () {
        let table = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", String::from("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy "), String::from("COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ")), String::from("NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ")), String::from(" Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ")), String::from("MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ")), String::from("READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ")), String::from("RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "));
        let commands = fields(table);
        let mut mins: Vec<i32> = vec![];
        let mut i = 0;
        while i < (commands.len() as i32) {
            let mut count = 0;
            let mut j = 0;
            let cmd = commands[(i) as usize].clone();
            while j < (cmd.len() as i32) {
                let ch = cmd[(j) as usize..(j + 1) as usize].to_string();
                if ch >= String::from("A") && ch <= String::from("Z") {
                    count += 1;
                }
                j += 1;
            }
            mins = { let mut tmp = mins.clone(); tmp.push(count); tmp };
            i += 1;
        }
        let sentence = String::from("riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin");
        let words = fields(sentence);
        let results = validate(commands, words, mins);
        let mut out1 = String::from("user words:  ");
        let mut k = 0;
        while k < (words.len() as i32) {
            out1 = format!("{}{}", format!("{}{}", out1, padRight(words[(k) as usize].clone(), (results[(k) as usize].clone().len() as i32))), String::from(" "));
            k += 1;
        }
        println!("{}", vec![format!("{}", out1)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", String::from("full words:  "), join(results, String::from(" "))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    };
    main();
}
