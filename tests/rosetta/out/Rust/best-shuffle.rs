// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:45Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn nextRand(seed: i32) -> i32 {
        return (seed * 1664525 + 1013904223) % 2147483647;
    }
    fn shuffleChars(s: &'static str, seed: i32) -> Vec<i32> {
        let mut chars: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < s.len() as i32 {
            chars = append(chars, &s[i as usize..i + 1 as usize]);
            i += 1;
        }
        let mut sd = seed;
        let mut idx = chars.len() as i32 - 1;
        while idx > 0 {
            sd = nextRand(sd);
            let mut j = sd % (idx + 1);
            let tmp = chars[idx as usize];
            chars[idx as usize] = chars[j as usize];
            chars[j as usize] = tmp;
            idx -= 1;
        }
        let mut res = "";
        i = 0;
        while i < chars.len() as i32 {
            res += chars[i as usize];
            i += 1;
        }
        return vec![res, sd];
    }
    fn bestShuffle(s: &'static str, seed: i32) -> Vec<i32> {
        let r = shuffleChars(s, seed);
        let mut t = r[0];
        let mut sd = r[1];
        let mut arr: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < t.len() as i32 {
            arr = append(arr, &t[i as usize..i + 1 as usize]);
            i += 1;
        }
        i = 0;
        while i < arr.len() as i32 {
            let mut j = 0;
            while j < arr.len() as i32 {
                if i != j && arr[i as usize] != &s[j as usize..j + 1 as usize] && arr[j as usize] != &s[i as usize..i + 1 as usize] {
                    let tmp = arr[i as usize];
                    arr[i as usize] = arr[j as usize];
                    arr[j as usize] = tmp;
                    break;
                }
                j += 1;
            }
            i += 1;
        }
        let mut count = 0;
        i = 0;
        while i < arr.len() as i32 {
            if arr[i as usize] == &s[i as usize..i + 1 as usize] {
                count += 1;
            }
            i += 1;
        }
        let mut out = "";
        i = 0;
        while i < arr.len() as i32 {
            out += arr[i as usize];
            i += 1;
        }
        return vec![out, sd, count];
    }
    fn main() -> () {
        let ts = vec!["abracadabra", "seesaw", "elk", "grrrrrr", "up", "a"];
        let mut seed = 1;
        let mut i = 0;
        while i < ts.len() as i32 {
            let r = bestShuffle(ts[i as usize], seed);
            let shuf = r[0];
            seed = r[1];
            let cnt = r[2];
            println!("{:?}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", ts[i as usize], " -> "), shuf), " ("), cnt.to_string()), ")"));
            i += 1;
        }
    }
    main();
}
