// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn nextRand(seed: i32) -> i32 {
        return (seed * 1664525 + 1013904223) % 2147483647;
    }
    fn shuffleChars(s: &'static str, seed: i32) -> Vec<i32> {
        let mut chars: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < s.len() as i32 {
            chars = { let mut tmp = chars.clone(); tmp.push(&s[i as usize..i + 1 as usize]); tmp };
            i += 1;
        }
        let mut sd = seed;
        let mut idx = chars.len() as i32 - 1;
        while idx > 0 {
            sd = nextRand(sd);
            let mut j = sd % (idx + 1);
            let tmp = chars[idx as usize];
            chars[idx as usize] = chars[j as usize];
            chars[j as usize] = tmp;
            idx -= 1;
        }
        let mut res = String::new();
        i = 0;
        while i < chars.len() as i32 {
            res += chars[i as usize];
            i += 1;
        }
        return vec![res, sd];
    }
    fn bestShuffle(s: &'static str, seed: i32) -> Vec<i32> {
        let r = shuffleChars(s, seed);
        let mut t = r[0];
        let mut sd = r[1];
        let mut arr: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < t.len() as i32 {
            arr = { let mut tmp = arr.clone(); tmp.push(&t[i as usize..i + 1 as usize]); tmp };
            i += 1;
        }
        i = 0;
        while i < arr.len() as i32 {
            let mut j = 0;
            while j < arr.len() as i32 {
                if i != j && arr[i as usize] != &s[j as usize..j + 1 as usize] && arr[j as usize] != &s[i as usize..i + 1 as usize] {
                    let tmp = arr[i as usize];
                    arr[i as usize] = arr[j as usize];
                    arr[j as usize] = tmp;
                    break;
                }
                j += 1;
            }
            i += 1;
        }
        let mut count = 0;
        i = 0;
        while i < arr.len() as i32 {
            if arr[i as usize] == &s[i as usize..i + 1 as usize] {
                count += 1;
            }
            i += 1;
        }
        let mut out = String::new();
        i = 0;
        while i < arr.len() as i32 {
            out += arr[i as usize];
            i += 1;
        }
        return vec![out, sd, count];
    }
    fn main() -> () {
        let ts = vec!["abracadabra", "seesaw", "elk", "grrrrrr", "up", "a"];
        let mut seed = 1;
        let mut i = 0;
        while i < ts.len() as i32 {
            let r = bestShuffle(ts[i as usize], seed);
            let shuf = r[0];
            seed = r[1];
            let cnt = r[2];
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", ts[i as usize], " -> "), shuf), " ("), cnt.to_string()), ")"))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            i += 1;
        }
    }
    main();
}
