// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    let PI: f64 = 3.141592653589793;
    let TWO_PI: f64 = 6.283185307179586;
    fn sinApprox(x: f64) -> f64 {
        let mut term = x;
        let mut sum = x;
        let mut n = 1;
        while n <= 8 {
            let denom = ((2 * n) * (2 * n + 1)).parse::<f64>().unwrap();
            term = -term * x * x / denom;
            sum += term;
            n += 1;
        }
        return sum;
    }
    fn floor(x: f64) -> f64 {
        let mut i = x.parse::<i32>().unwrap();
        if (i.parse::<f64>().unwrap()) > x {
            i -= 1;
        }
        return i.parse::<f64>().unwrap();
    }
    fn absFloat(x: f64) -> f64 {
        if x < 0.0 {
            return -x;
        }
        return x;
    }
    fn absInt(n: i32) -> i32 {
        if n < 0 {
            return -n;
        }
        return n;
    }
    fn parseIntStr(str: &'static str) -> i32 {
        let mut i = 0;
        let mut neg = false;
        if str.len() as i32 > 0 && &str[0..1] == "-" {
            neg = true;
            i = 1;
        }
        let mut n = 0;
        let digits = { let mut m = std::collections::BTreeMap::new(); m.insert("0", 0); m.insert("1", 1); m.insert("2", 2); m.insert("3", 3); m.insert("4", 4); m.insert("5", 5); m.insert("6", 6); m.insert("7", 7); m.insert("8", 8); m.insert("9", 9); m };
        while i < str.len() as i32 {
            n = n * 10 + *digits.get(&&str[i as usize..i + 1 as usize]).unwrap();
            i += 1;
        }
        if neg {
            n = -n;
        }
        return n;
    }
    fn parseDate(s: &'static str) -> Vec<i32> {
        let y = parseIntStr(&s[0..4]);
        let m = parseIntStr(&s[5..7]);
        let d = parseIntStr(&s[8..10]);
        return vec![y, m, d];
    }
    fn leap(y: i32) -> bool {
        if y % 400 == 0 {
            return true;
        }
        if y % 100 == 0 {
            return false;
        }
        return y % 4 == 0;
    }
    fn daysInMonth(y: i32, m: i32) -> i32 {
        let feb = if leap(y) { 29 } else { 28 };
        let lengths = vec![31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        return lengths[m - 1 as usize];
    }
    fn addDays(y: i32, m: i32, d: i32, n: i32) -> Vec<i32> {
        let mut yy = y;
        let mut mm = m;
        let mut dd = d;
        if n >= 0 {
            let mut i = 0;
            while i < n {
                dd += 1;
                if dd > daysInMonth(yy, mm) {
                    dd = 1;
                    mm += 1;
                    if mm > 12 {
                        mm = 1;
                        yy += 1;
                    }
                }
                i += 1;
            }
        } else {
            let mut i = 0;
            while i > n {
                dd -= 1;
                if dd < 1 {
                    mm -= 1;
                    if mm < 1 {
                        mm = 12;
                        yy -= 1;
                    }
                    dd = daysInMonth(yy, mm);
                }
                i -= 1;
            }
        }
        return vec![yy, mm, dd];
    }
    fn pad2(n: i32) -> &'static str {
        if n < 10 {
            return format!("{}{}", "0", n.to_string());
        }
        return n.to_string();
    }
    fn dateString(y: i32, m: i32, d: i32) -> &'static str {
        return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", y.to_string(), "-"), pad2(m)), "-"), pad2(d));
    }
    fn day(y: i32, m: i32, d: i32) -> i32 {
        let part1 = 367 * y;
        let part2 = (((7 * ((((y as f64) as f64) + (((m + 9) as f64) / (12 as f64))).parse::<i32>().unwrap())) as f64) / (4 as f64)).parse::<i32>().unwrap();
        let part3 = (((275 * m) as f64) / (9 as f64)).parse::<i32>().unwrap();
        return part1 - part2 + part3 + d - 730530;
    }
    let biorhythms = move |birth: &'static str, target: &'static str| -> () {
        let bparts = parseDate(birth);
        let by = bparts[0];
        let bm = bparts[1];
        let bd = bparts[2];
        let tparts = parseDate(target);
        let ty = tparts[0];
        let tm = tparts[1];
        let td = tparts[2];
        let diff = absInt(day(ty, tm, td) - day(by, bm, bd));
        println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", "Born ", birth), ", Target "), target))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "Day ", diff.to_string()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        let cycles = vec!["Physical day ", "Emotional day", "Mental day   "];
        let lengths = vec![23, 28, 33];
        let quadrants = vec![vec!["up and rising", "peak"], vec!["up but falling", "transition"], vec!["down and falling", "valley"], vec!["down but rising", "transition"]];
        let mut i = 0;
        while i < 3 {
            let length = lengths[i as usize];
            let cycle = cycles[i as usize];
            let position = diff % length;
            let quadrant = ((position * 4) as f64) / (length as f64);
            let mut percent = sinApprox(2.0 * PI * (position.parse::<f64>().unwrap()) / (length.parse::<f64>().unwrap()));
            percent = floor(percent * 1000.0) / 10.0;
            let mut description = String::new();
            if percent > 95.0 {
                description = " peak";
            }
            let mut posStr = position.to_string();
            if position < 10 {
                posStr = format!("{}{}", " ", posStr);
            }
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", cycle, posStr), " : "), description))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            i += 1;
        }
        println!("");
    };
    fn main() -> () {
        let pairs = vec![vec!["1943-03-09", "1972-07-11"], vec!["1809-01-12", "1863-11-19"], vec!["1809-02-12", "1863-11-19"]];
        let mut idx = 0;
        while idx < pairs.len() as i32 {
            let p = pairs[idx as usize];
            biorhythms(p[0], p[1]);
            idx += 1;
        }
    }
    main();
}
