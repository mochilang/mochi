// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
#[derive(Default, Debug, Clone, PartialEq)]
struct Point {
        x: f64,
        y: f64,
        z: f64,
}

#[derive(Default, Debug, Clone, PartialEq)]
struct Edge {
        pn1: i32,
        pn2: i32,
        fn1: i32,
        fn2: i32,
        cp: Point,
}

#[derive(Default, Debug, Clone, PartialEq)]
struct PointEx {
        p: Point,
        n: i32,
}

fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn indexOf(s: &'static str, ch: &'static str) -> i32 {
        let mut i = 0;
        while i < s.len() as i32 {
            if &s[i as usize..i + 1 as usize] == ch {
                return i;
            }
            i += 1;
        }
        return -1;
    }
    fn fmt4(x: f64) -> &'static str {
        let mut y = x * 10000.0;
        if y >= 0 as f64 {
            y += 0.5;
        } else {
            y -= 0.5;
        }
        y = (y.parse::<i32>().unwrap()).parse::<f64>().unwrap() / 10000.0;
        let mut s = y.to_string();
        let mut dot = indexOf(s, ".");
        if dot == 0 - 1 {
            s += ".0000";
        } else {
            let mut decs = s.len() as i32 - dot - 1;
            if decs > 4 {
                s = &s[0 as usize..dot + 5 as usize];
            } else {
                while decs < 4 {
                    s += "0";
                    decs += 1;
                }
            }
        }
        if x >= 0.0 {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn fmt2(n: i32) -> &'static str {
        let s = n.to_string();
        if s.len() as i32 < 2 {
            return format!("{}{}", " ", s);
        }
        return s;
    }
    fn sumPoint(p1: Point, p2: Point) -> Point {
        return Point { x: p1.x + p2.x, y: p1.y + p2.y, z: p1.z + p2.z };
    }
    fn mulPoint(p: Point, m: f64) -> Point {
        return Point { x: p.x * m, y: p.y * m, z: p.z * m };
    }
    fn divPoint(p: Point, d: f64) -> Point {
        return mulPoint(&p.clone(), 1.0 / d);
    }
    fn centerPoint(p1: Point, p2: Point) -> Point {
        return divPoint(&sumPoint(&p1.clone(), &p2.clone()), 2.0);
    }
    fn getFacePoints(points: Vec<Point>, faces: Vec<Vec<i32>>) -> Vec<Point> {
        let mut facePoints: Vec<Point> = vec![];
        let mut i = 0;
        while i < faces.len() as i32 {
            let face = faces[i as usize];
            let mut fp = Point { x: 0.0, y: 0.0, z: 0.0 };
            for idx in face {
                fp = sumPoint(&fp.clone(), &points[idx as usize]);
            }
            fp = divPoint(&fp.clone(), (face.len() as i32.parse::<f64>().unwrap()));
            facePoints = { let mut tmp = facePoints.clone(); tmp.push(fp.clone()); tmp };
            i += 1;
        }
        return facePoints;
    }
    fn sortEdges(edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut res: Vec<Vec<i32>> = vec![];
        let mut tmp = edges;
        while tmp.len() as i32 > 0 {
            let mut min = tmp[0];
            let mut idx = 0;
            let mut j = 1;
            while j < tmp.len() as i32 {
                let e = tmp[j as usize];
                if e[0] < min[0] || (e[0] == min[0] && (e[1] < min[1] || (e[1] == min[1] && e[2] < min[2]))) {
                    min = e;
                    idx = j;
                }
                j += 1;
            }
            res = { let mut tmp = res.clone(); tmp.push(min); tmp };
            let mut out: Vec<Vec<i32>> = vec![];
            let mut k = 0;
            while k < tmp.len() as i32 {
                if k != idx {
                    out = { let mut tmp = out.clone(); tmp.push(tmp[k as usize]); tmp };
                }
                k += 1;
            }
            tmp = out;
        }
        return res;
    }
    fn getEdgesFaces(points: Vec<Point>, faces: Vec<Vec<i32>>) -> Vec<Edge> {
        let mut edges: Vec<Vec<i32>> = vec![];
        let mut fnum = 0;
        while fnum < faces.len() as i32 {
            let face = faces[fnum as usize];
            let mut numP = face.len() as i32;
            let mut pi = 0;
            while pi < numP {
                let mut pn1 = face[pi as usize];
                let mut pn2 = 0;
                if pi < numP - 1 {
                    pn2 = face[pi + 1 as usize];
                } else {
                    pn2 = face[0];
                }
                if pn1 > pn2 {
                    let mut tmpn = pn1;
                    pn1 = pn2;
                    pn2 = tmpn;
                }
                edges = { let mut tmp = edges.clone(); tmp.push(vec![pn1, pn2, fnum]); tmp };
                pi += 1;
            }
            fnum += 1;
        }
        edges = sortEdges(edges);
        let mut merged: Vec<Vec<i32>> = vec![];
        let mut idx = 0;
        while idx < edges.len() as i32 {
            let e1 = edges[idx as usize];
            if idx < edges.len() as i32 - 1 {
                let e2 = edges[idx + 1 as usize];
                if e1[0] == e2[0] && e1[1] == e2[1] {
                    merged = { let mut tmp = merged.clone(); tmp.push(vec![e1[0], e1[1], e1[2], e2[2]]); tmp };
                    idx += 2;
                    continue;
                }
            }
            merged = { let mut tmp = merged.clone(); tmp.push(vec![e1[0], e1[1], e1[2], -1]); tmp };
            idx += 1;
        }
        let mut edgesCenters: Vec<Edge> = vec![];
        for me in merged {
            let p1 = points[me[0] as usize];
            let p2 = points[me[1] as usize];
            let cp = centerPoint(&p1.clone(), &p2.clone());
            edgesCenters = { let mut tmp = edgesCenters.clone(); tmp.push(Edge { pn1: me[0], pn2: me[1], fn1: me[2], fn2: me[3], cp: cp.clone() }); tmp };
        }
        return edgesCenters;
    }
    fn getEdgePoints(points: Vec<Point>, edgesFaces: Vec<Edge>, facePoints: Vec<Point>) -> Vec<Point> {
        let mut edgePoints: Vec<Point> = vec![];
        let mut i = 0;
        while i < edgesFaces.len() as i32 {
            let edge = edgesFaces[i as usize];
            let cp = edge.cp;
            let fp1 = facePoints[edge.fn1 as usize];
            let mut fp2 = fp1.clone();
            if edge.fn2 != 0 - 1 {
                fp2 = facePoints[edge.fn2 as usize];
            }
            let cfp = centerPoint(&fp1.clone(), &fp2.clone());
            edgePoints = { let mut tmp = edgePoints.clone(); tmp.push(centerPoint(&cp.clone(), &cfp.clone())); tmp };
            i += 1;
        }
        return edgePoints;
    }
    fn getAvgFacePoints(points: Vec<Point>, faces: Vec<Vec<i32>>, facePoints: Vec<Point>) -> Vec<Point> {
        let mut numP = points.len() as i32;
        let mut temp: Vec<PointEx> = vec![];
        let mut i = 0;
        while i < numP {
            temp = { let mut tmp = temp.clone(); tmp.push(PointEx { p: Point { x: 0.0, y: 0.0, z: 0.0 }, n: 0 }); tmp };
            i += 1;
        }
        let mut fnum = 0;
        while fnum < faces.len() as i32 {
            let fp = facePoints[fnum as usize];
            for pn in faces[fnum as usize] {
                let tp = temp[pn as usize];
                temp[pn as usize] = PointEx { p: sumPoint(&tp.p, &fp.clone()), n: tp.n + 1 };
            }
            fnum += 1;
        }
        let mut avg: Vec<Point> = vec![];
        let mut j = 0;
        while j < numP {
            let tp = temp[j as usize];
            avg = append(avg, divPoint(&tp.p, tp.n.parse::<f64>().unwrap()));
            j += 1;
        }
        return avg;
    }
    fn getAvgMidEdges(points: Vec<Point>, edgesFaces: Vec<Edge>) -> Vec<Point> {
        let mut numP = points.len() as i32;
        let mut temp: Vec<PointEx> = vec![];
        let mut i = 0;
        while i < numP {
            temp = { let mut tmp = temp.clone(); tmp.push(PointEx { p: Point { x: 0.0, y: 0.0, z: 0.0 }, n: 0 }); tmp };
            i += 1;
        }
        for edge in edgesFaces {
            let cp = edge.cp;
            let mut arr = vec![edge.pn1, edge.pn2];
            for pn in arr {
                let tp = temp[pn as usize];
                temp[pn as usize] = PointEx { p: sumPoint(&tp.p, &cp.clone()), n: tp.n + 1 };
            }
        }
        let mut avg: Vec<Point> = vec![];
        let mut j = 0;
        while j < numP {
            let tp = temp[j as usize];
            avg = append(avg, divPoint(&tp.p, tp.n.parse::<f64>().unwrap()));
            j += 1;
        }
        return avg;
    }
    fn getPointsFaces(points: Vec<Point>, faces: Vec<Vec<i32>>) -> Vec<i32> {
        let mut pf: Vec<i32> = vec![];
        let mut i = 0;
        while i < points.len() as i32 {
            pf = { let mut tmp = pf.clone(); tmp.push(0); tmp };
            i += 1;
        }
        let mut fnum = 0;
        while fnum < faces.len() as i32 {
            for pn in faces[fnum as usize] {
                pf[pn as usize] = pf[pn as usize] + 1;
            }
            fnum += 1;
        }
        return pf;
    }
    fn getNewPoints(points: Vec<Point>, pf: Vec<i32>, afp: Vec<Point>, ame: Vec<Point>) -> Vec<Point> {
        let mut newPts: Vec<Point> = vec![];
        let mut i = 0;
        while i < points.len() as i32 {
            let mut n = pf[i as usize].parse::<f64>().unwrap();
            let mut m1 = (n - 3.0) / n;
            let mut m2 = 1.0 / n;
            let mut m3 = 2.0 / n;
            let old = points[i as usize];
            let p1 = mulPoint(&old.clone(), m1);
            let p2 = mulPoint(&afp[i as usize], m2);
            let p3 = mulPoint(&ame[i as usize], m3);
            newPts = { let mut tmp = newPts.clone(); tmp.push(sumPoint(&sumPoint(&p1.clone(), &p2.clone()), &p3.clone())); tmp };
            i += 1;
        }
        return newPts;
    }
    fn key(a: i32, b: i32) -> &'static str {
        if a < b {
            return format!("{}{}", format!("{}{}", a.to_string(), ","), b.to_string());
        }
        return format!("{}{}", format!("{}{}", b.to_string(), ","), a.to_string());
    }
    fn cmcSubdiv(points: Vec<Point>, faces: Vec<Vec<i32>>) -> Vec<i32> {
        let facePoints = getFacePoints(points, faces);
        let edgesFaces = getEdgesFaces(points, faces);
        let edgePoints = getEdgePoints(points, edgesFaces, facePoints);
        let avgFacePoints = getAvgFacePoints(points, faces, facePoints);
        let avgMidEdges = getAvgMidEdges(points, edgesFaces);
        let pointsFaces = getPointsFaces(points, faces);
        let mut newPoints = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges);
        let mut facePointNums: Vec<i32> = vec![];
        let mut nextPoint = newPoints.len() as i32;
        for fp in facePoints {
            newPoints = { let mut tmp = newPoints.clone(); tmp.push(fp.clone()); tmp };
            facePointNums = { let mut tmp = facePointNums.clone(); tmp.push(nextPoint); tmp };
            nextPoint += 1;
        }
        let mut edgePointNums: std::collections::HashMap<&'static str, i32> = { let mut m = std::collections::BTreeMap::new(); m };
        let mut idx = 0;
        while idx < edgesFaces.len() as i32 {
            let e = edgesFaces[idx as usize];
            newPoints = { let mut tmp = newPoints.clone(); tmp.push(edgePoints[idx as usize]); tmp };
            edgePointNums.insert(key(e.pn1, e.pn2), nextPoint);
            nextPoint += 1;
            idx += 1;
        }
        let mut newFaces: Vec<Vec<i32>> = vec![];
        let mut fnum = 0;
        while fnum < faces.len() as i32 {
            let oldFace = faces[fnum as usize];
            if oldFace.len() as i32 == 4 {
                let a = oldFace[0];
                let b = oldFace[1];
                let c = oldFace[2];
                let d = oldFace[3];
                let fpnum = facePointNums[fnum as usize];
                let ab = *edgePointNums.get(&key(a, b)).unwrap();
                let da = *edgePointNums.get(&key(d, a)).unwrap();
                let bc = *edgePointNums.get(&key(b, c)).unwrap();
                let cd = *edgePointNums.get(&key(c, d)).unwrap();
                newFaces = { let mut tmp = newFaces.clone(); tmp.push(vec![a, ab, fpnum, da]); tmp };
                newFaces = { let mut tmp = newFaces.clone(); tmp.push(vec![b, bc, fpnum, ab]); tmp };
                newFaces = { let mut tmp = newFaces.clone(); tmp.push(vec![c, cd, fpnum, bc]); tmp };
                newFaces = { let mut tmp = newFaces.clone(); tmp.push(vec![d, da, fpnum, cd]); tmp };
            }
            fnum += 1;
        }
        return vec![newPoints, newFaces];
    }
    fn formatPoint(p: Point) -> &'static str {
        return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "[", fmt4(p.x)), " "), fmt4(p.y)), " "), fmt4(p.z)), "]");
    }
    fn formatFace(f: Vec<i32>) -> &'static str {
        if f.len() as i32 == 0 {
            return "[]";
        }
        let mut s = format!("{}{}", "[", fmt2(f[0]));
        let mut i = 1;
        while i < f.len() as i32 {
            s = format!("{}{}", format!("{}{}", s, " "), fmt2(f[i as usize]));
            i += 1;
        }
        s += "]";
        return s;
    }
    fn main() -> () {
        let inputPoints = vec![Point { x: -1.0, y: 1.0, z: 1.0 }, Point { x: -1.0, y: -1.0, z: 1.0 }, Point { x: 1.0, y: -1.0, z: 1.0 }, Point { x: 1.0, y: 1.0, z: 1.0 }, Point { x: 1.0, y: -1.0, z: -1.0 }, Point { x: 1.0, y: 1.0, z: -1.0 }, Point { x: -1.0, y: -1.0, z: -1.0 }, Point { x: -1.0, y: 1.0, z: -1.0 }];
        let inputFaces = vec![vec![0, 1, 2, 3], vec![3, 2, 4, 5], vec![5, 4, 6, 7], vec![7, 0, 3, 5], vec![7, 6, 1, 0], vec![6, 1, 2, 4]];
        let mut outputPoints = inputPoints;
        let mut outputFaces = inputFaces;
        let mut i = 0;
        while i < 1 {
            let res = cmcSubdiv(outputPoints, outputFaces);
            outputPoints = res[0];
            outputFaces = res[1];
            i += 1;
        }
        for p in outputPoints {
            println!("{}", vec![format!("{}", formatPoint(&p.clone()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        }
        println!("");
        for f in outputFaces {
            println!("{}", vec![format!("{}", formatFace(f))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        }
    }
    main();
}
