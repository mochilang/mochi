// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn toUnsigned16(n: i32) -> i32 {
        let mut u = n;
        if u < 0 {
            u += 65536;
        }
        return u % 65536;
    }
    fn bin16(n: i32) -> &'static str {
        let mut u = toUnsigned16(n);
        let mut bits = String::new();
        let mut mask = 32768;
        for i in 0..16 {
            if u >= mask {
                bits += "1";
                u -= mask;
            } else {
                bits += "0";
            }
            mask = ((mask as f64) / (2 as f64)).parse::<i32>().unwrap();
        }
        return bits;
    }
    fn bit_and(a: i32, b: i32) -> i32 {
        let mut ua = toUnsigned16(a);
        let mut ub = toUnsigned16(b);
        let mut res = 0;
        let mut bit = 1;
        for i in 0..16 {
            if ua % 2 == 1 && ub % 2 == 1 {
                res += bit;
            }
            ua = ((ua as f64) / (2 as f64)).parse::<i32>().unwrap();
            ub = ((ub as f64) / (2 as f64)).parse::<i32>().unwrap();
            bit *= 2;
        }
        return res;
    }
    fn bit_or(a: i32, b: i32) -> i32 {
        let mut ua = toUnsigned16(a);
        let mut ub = toUnsigned16(b);
        let mut res = 0;
        let mut bit = 1;
        for i in 0..16 {
            if ua % 2 == 1 || ub % 2 == 1 {
                res += bit;
            }
            ua = ((ua as f64) / (2 as f64)).parse::<i32>().unwrap();
            ub = ((ub as f64) / (2 as f64)).parse::<i32>().unwrap();
            bit *= 2;
        }
        return res;
    }
    fn bit_xor(a: i32, b: i32) -> i32 {
        let mut ua = toUnsigned16(a);
        let mut ub = toUnsigned16(b);
        let mut res = 0;
        let mut bit = 1;
        for i in 0..16 {
            let abit = ua % 2;
            let bbit = ub % 2;
            if (abit == 1 && bbit == 0) || (abit == 0 && bbit == 1) {
                res += bit;
            }
            ua = ((ua as f64) / (2 as f64)).parse::<i32>().unwrap();
            ub = ((ub as f64) / (2 as f64)).parse::<i32>().unwrap();
            bit *= 2;
        }
        return res;
    }
    fn bit_not(a: i32) -> i32 {
        let mut ua = toUnsigned16(a);
        return 65535 - ua;
    }
    fn shl(a: i32, b: i32) -> i32 {
        let mut ua = toUnsigned16(a);
        let mut i = 0;
        while i < b {
            ua = (ua * 2) % 65536;
            i += 1;
        }
        return ua;
    }
    fn shr(a: i32, b: i32) -> i32 {
        let mut ua = toUnsigned16(a);
        let mut i = 0;
        while i < b {
            ua = ((ua as f64) / (2 as f64)).parse::<i32>().unwrap();
            i += 1;
        }
        return ua;
    }
    fn las(a: i32, b: i32) -> i32 {
        return shl(a, b);
    }
    fn ras(a: i32, b: i32) -> i32 {
        let mut val = a;
        let mut i = 0;
        while i < b {
            if val >= 0 {
                val = ((val as f64) / (2 as f64)).parse::<i32>().unwrap();
            } else {
                val = (((val - 1) as f64) / (2 as f64)).parse::<i32>().unwrap();
            }
            i += 1;
        }
        return toUnsigned16(val);
    }
    fn rol(a: i32, b: i32) -> i32 {
        let mut ua = toUnsigned16(a);
        let left = shl(ua, b);
        let right = shr(ua, 16 - b);
        return toUnsigned16(left + right);
    }
    fn ror(a: i32, b: i32) -> i32 {
        let mut ua = toUnsigned16(a);
        let right = shr(ua, b);
        let left = shl(ua, 16 - b);
        return toUnsigned16(left + right);
    }
    fn bitwise(a: i32, b: i32) -> () {
        println!("{}", vec![format!("{}", format!("{}{}", "a:   ", bin16(a)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "b:   ", bin16(b)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "and: ", bin16(bit_and(a, b))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "or:  ", bin16(bit_or(a, b))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "xor: ", bin16(bit_xor(a, b))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "not: ", bin16(bit_not(a))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        if b < 0 {
            println!("Right operand is negative, but all shifts require an unsigned right operand (shift distance).");
            return ();
        }
        println!("{}", vec![format!("{}", format!("{}{}", "shl: ", bin16(shl(a, b))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "shr: ", bin16(shr(a, b))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "las: ", bin16(las(a, b))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "ras: ", bin16(ras(a, b))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "rol: ", bin16(rol(a, b))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        println!("{}", vec![format!("{}", format!("{}{}", "ror: ", bin16(ror(a, b))))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    }
    bitwise(-460, 6);
}
