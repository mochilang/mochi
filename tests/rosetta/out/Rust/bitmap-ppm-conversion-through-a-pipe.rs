// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:47Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Pixel {
        R: i32,
        G: i32,
        B: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Bitmap {
        cols: i32,
        rows: i32,
        px: Vec<Vec<Pixel>>,
}

fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn pixelFromRgb(c: i32) -> Pixel {
        let r = (((c as f64) / (65536 as f64)).parse::<i32>().unwrap()) % 256;
        let g = (((c as f64) / (256 as f64)).parse::<i32>().unwrap()) % 256;
        let b = c % 256;
        return Pixel { R: r, G: g, B: b };
    }
    fn rgbFromPixel(p: Pixel) -> i32 {
        return p.R * 65536 + p.G * 256 + p.B;
    }
    fn NewBitmap(x: i32, y: i32) -> Bitmap {
        let mut data: Vec<Vec<Pixel>> = vec![];
        let mut row = 0;
        while row < y {
            let mut r: Vec<Pixel> = vec![];
            let mut col = 0;
            while col < x {
                r = append(r, Pixel { R: 0, G: 0, B: 0 });
                col += 1;
            }
            data = append(data, r);
            row += 1;
        }
        return Bitmap { cols: x, rows: y, px: data };
    }
    fn FillRgb(b: &mut Bitmap, c: i32) -> () {
        let mut y = 0;
        let p = pixelFromRgb(c);
        while y < b.rows {
            let mut x = 0;
            while x < b.cols {
                let mut px = b.px;
                let mut row = px[y as usize];
                row[x as usize] = p.clone();
                px[y as usize] = row;
                b.px = px;
                x += 1;
            }
            y += 1;
        }
    }
    fn SetPxRgb(b: &mut Bitmap, x: i32, y: i32, c: i32) -> bool {
        if x < 0 || x >= b.cols || y < 0 || y >= b.rows {
            return false;
        }
        let mut px = b.px;
        let mut row = px[y as usize];
        row[x as usize] = pixelFromRgb(c);
        px[y as usize] = row;
        b.px = px;
        return true;
    }
    fn nextRand(seed: i32) -> i32 {
        return (seed * 1664525 + 1013904223) % 2147483648;
    }
    fn main() -> () {
        let mut bm = NewBitmap(400, 300);
        FillRgb(&mut bm.clone(), 12615744);
        let mut seed = now();
        let mut i = 0;
        while i < 2000 {
            seed = nextRand(seed);
            let x = seed % 400;
            seed = nextRand(seed);
            let y = seed % 300;
            SetPxRgb(&mut bm.clone(), x, y, 8405024);
            i += 1;
        }
        let mut x = 0;
        while x < 400 {
            let mut y = 240;
            while y < 245 {
                SetPxRgb(&mut bm.clone(), x, y, 8405024);
                y += 1;
            }
            y = 260;
            while y < 265 {
                SetPxRgb(&mut bm.clone(), x, y, 8405024);
                y += 1;
            }
            x += 1;
        }
        let mut y = 0;
        while y < 300 {
            let mut x = 80;
            while x < 85 {
                SetPxRgb(&mut bm.clone(), x, y, 8405024);
                x += 1;
            }
            x = 95;
            while x < 100 {
                SetPxRgb(&mut bm.clone(), x, y, 8405024);
                x += 1;
            }
            y += 1;
        }
    }
    main();
}
