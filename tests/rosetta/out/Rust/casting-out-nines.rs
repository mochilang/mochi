// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:52Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
struct TestCase {
    base: i32,
    begin: &'static str,
    end: &'static str,
    kaprekar: Vec<&'static str>,
}

fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn parseIntBase(s: &'static str, base: i32) -> i32 {
        let digits = "0123456789abcdefghijklmnopqrstuvwxyz";
        let mut n = 0;
        let mut i = 0;
        while i < s.len() as i32 {
            let mut j = 0;
            let mut v = 0;
            while j < digits.len() as i32 {
                if &digits[j as usize..j + 1 as usize] == &s[i as usize..i + 1 as usize] {
                    v = j;
                    break;
                }
                j += 1;
            }
            n = n * base + v;
            i += 1;
        }
        return n;
    }
    fn intToBase(n: i32, base: i32) -> &'static str {
        let digits = "0123456789abcdefghijklmnopqrstuvwxyz";
        if n == 0 {
            return "0";
        }
        let mut out = "";
        let mut v = n;
        while v > 0 {
            let d = v % base;
            out = format!("{}{}", &digits[d as usize..d + 1 as usize], out);
            v /= base;
        }
        return out;
    }
    fn subset(base: i32, begin: &'static str, end: &'static str) -> Vec<&'static str> {
        let mut b = parseIntBase(begin, base);
        let mut e = parseIntBase(end, base);
        let mut out: Vec<&'static str> = vec![];
        let mut k = b;
        while k <= e {
            let ks = intToBase(k, base);
            let mod = base - 1;
            let r1 = parseIntBase(ks, base) % mod;
            let r2 = (parseIntBase(ks, base) * parseIntBase(ks, base)) % mod;
            if r1 == r2 {
                out = append(out, ks);
            }
            k += 1;
        }
        return out;
    }
    let testCases = vec![TestCase { base: 10, begin: "1", end: "100", kaprekar: vec!["1", "9", "45", "55", "99"] }, TestCase { base: 17, begin: "10", end: "gg", kaprekar: vec!["3d", "d4", "gg"] }];
    let mut idx = 0;
    while idx < testCases.len() as i32 {
        let tc = testCases[idx as usize];
        println!("{:?}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "
Test case base = ", tc.clone()["base" as usize].to_string()), ", begin = "), tc.clone()["begin" as usize]), ", end = "), tc.clone()["end" as usize]), ":"));
        let s = subset(tc.clone()["base" as usize], tc.clone()["begin" as usize], tc.clone()["end" as usize]);
        println!("{}", format!("{}{}", "Subset:  ", s.to_string()));
        println!("{}", format!("{}{}", "Kaprekar:", tc.clone()["kaprekar" as usize].to_string()));
        let mut sx = 0;
        let mut valid = true;
        let mut i = 0;
        while i < tc.clone()["kaprekar" as usize].len() as i32 {
            let k = tc.clone()["kaprekar" as usize][i as usize];
            let mut found = false;
            while sx < s.len() as i32 {
                if s[sx as usize] == k {
                    found = true;
                    sx += 1;
                    break;
                }
                sx += 1;
            }
            if !found {
                println!("{:?}", format!("{}{}", format!("{}{}", "Fail:", k), " not in subset"));
                valid = false;
                break;
            }
            i += 1;
        }
        if valid {
            println!("Valid subset.");
        }
        idx += 1;
    }
}
