// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn divisors(n: i32) -> Vec<i32> {
        let mut divs: Vec<i32> = vec![1];
        let mut divs2: Vec<i32> = vec![];
        let mut i = 2;
        while i * i <= n {
            if n % i == 0 {
                let j = ((n as f64) / (i as f64)).parse::<i32>().unwrap();
                divs = { let mut tmp = divs.clone(); tmp.push(i); tmp };
                if i != j {
                    divs2 = { let mut tmp = divs2.clone(); tmp.push(j); tmp };
                }
            }
            i += 1;
        }
        let mut j = divs2.len() as i32 - 1;
        while j >= 0 {
            divs = { let mut tmp = divs.clone(); tmp.push(divs2[j as usize]); tmp };
            j -= 1;
        }
        return divs;
    }
    fn sum(xs: Vec<i32>) -> i32 {
        let mut tot = 0;
        for v in xs {
            tot += v;
        }
        return tot;
    }
    fn sumStr(xs: Vec<i32>) -> &'static str {
        let mut s = String::new();
        let mut i = 0;
        while i < xs.len() as i32 {
            s = format!("{}{}", format!("{}{}", s, xs[i as usize].to_string()), " + ");
            i += 1;
        }
        return &s[0 as usize..s.len() as i32 - 3 as usize];
    }
    fn pad2(n: i32) -> &'static str {
        let s = n.to_string();
        if s.len() as i32 < 2 {
            return format!("{}{}", " ", s);
        }
        return s;
    }
    fn pad5(n: i32) -> &'static str {
        let mut s = n.to_string();
        while s.len() as i32 < 5 {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn abundantOdd(searchFrom: i32, countFrom: i32, countTo: i32, printOne: bool) -> i32 {
        let mut count = countFrom;
        let mut n = searchFrom;
        while count < countTo {
            let divs = divisors(n);
            let tot = divs.iter().copied().sum::<i32>();
            if tot > n as f64 {
                count += 1;
                if printOne && count < countTo {
                    n += 2;
                    continue;
                }
                let s = sumStr(divs);
                if !printOne {
                    println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", pad2(count), ". "), pad5(n)), " < "), s), " = "), tot.to_string()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                } else {
                    println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", n.to_string(), " < "), s), " = "), tot.to_string()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                }
            }
            n += 2;
        }
        return n;
    }
    fn main() -> () {
        let max = 25;
        println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", "The first ", max.to_string()), " abundant odd numbers are:"))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        let n = abundantOdd(1, 0, max, false);
        println!("\nThe one thousandth abundant odd number is:");
        abundantOdd(n, max, 1000, true);
        println!("\nThe first abundant odd number above one billion is:");
        abundantOdd(1000000001, 0, 1, true);
    }
    main();
}
