// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:39Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn sum<T>(v: &[T]) -> T where T: std::iter::Sum<T> + Copy {
    v.iter().copied().sum()
}

fn main() {
    fn divisors(n: i32) -> Vec<i32> {
        let mut divs: Vec<i32> = vec![1];
        let mut divs2: Vec<i32> = vec![];
        let mut i = 2;
        while i * i <= n {
            if n % i == 0 {
                let j = ((n as f64) / (i as f64)).parse::<i32>().unwrap();
                divs = append(divs, i);
                if i != j {
                    divs2 = append(divs2, j);
                }
            }
            i += 1;
        }
        let mut j = divs2.len() as i32 - 1;
        while j >= 0 {
            divs = append(divs, divs2[j as usize]);
            j -= 1;
        }
        return divs;
    }
    fn sum(xs: Vec<i32>) -> i32 {
        let mut tot = 0;
        for v in xs {
            tot += v;
        }
        return tot;
    }
    fn sumStr(xs: Vec<i32>) -> &'static str {
        let mut s = "";
        let mut i = 0;
        while i < xs.len() as i32 {
            s = format!("{}{}", format!("{}{}", s, xs[i as usize].to_string()), " + ");
            i += 1;
        }
        return &s[0 as usize..s.len() as i32 - 3 as usize];
    }
    fn pad2(n: i32) -> &'static str {
        let s = n.to_string();
        if s.len() as i32 < 2 {
            return format!("{}{}", " ", s);
        }
        return s;
    }
    fn pad5(n: i32) -> &'static str {
        let mut s = n.to_string();
        while s.len() as i32 < 5 {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn abundantOdd(searchFrom: i32, countFrom: i32, countTo: i32, printOne: bool) -> i32 {
        let mut count = countFrom;
        let mut n = searchFrom;
        while count < countTo {
            let divs = divisors(n);
            let tot = sum(&divs);
            if tot > n as f64 {
                count += 1;
                if printOne && count < countTo {
                    n += 2;
                    continue;
                }
                let s = sumStr(divs);
                if !printOne {
                    println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", pad2(count), ". "), pad5(n)), " < "), s), " = "), tot.to_string()));
                } else {
                    println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", n.to_string(), " < "), s), " = "), tot.to_string()));
                }
            }
            n += 2;
        }
        return n;
    }
    fn main() -> () {
        let max = 25;
        println!("{}", format!("{}{}", format!("{}{}", "The first ", max.to_string()), " abundant odd numbers are:"));
        let n = abundantOdd(1, 0, max, false);
        println!("\nThe one thousandth abundant odd number is:");
        abundantOdd(n, max, 1000, true);
        println!("\nThe first abundant odd number above one billion is:");
        abundantOdd(1000000001, 0, 1, true);
    }
    main();
}
