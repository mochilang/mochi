// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn primesUpTo(n: i32) -> Vec<i32> {
        let mut sieve: Vec<bool> = vec![];
        let mut i = 0;
        while i <= n {
            sieve = { let mut tmp = sieve.clone(); tmp.push(true); tmp };
            i += 1;
        }
        let mut p = 2;
        while p * p <= n {
            if sieve[p as usize] {
                let mut m = p * p;
                while m <= n {
                    sieve[m as usize] = false;
                    m += p;
                }
            }
            p += 1;
        }
        let mut res: Vec<i32> = vec![];
        let mut x = 2;
        while x <= n {
            if sieve[x as usize] {
                res = { let mut tmp = res.clone(); tmp.push(x); tmp };
            }
            x += 1;
        }
        return res;
    }
    fn sortInts(xs: Vec<i32>) -> Vec<i32> {
        let mut res: Vec<i32> = vec![];
        let mut tmp = xs;
        while tmp.len() as i32 > 0 {
            let mut min = tmp[0];
            let mut idx = 0;
            let mut i = 1;
            while i < tmp.len() as i32 {
                if tmp[i as usize] < min {
                    min = tmp[i as usize];
                    idx = i;
                }
                i += 1;
            }
            res = { let mut tmp = res.clone(); tmp.push(min); tmp };
            let mut out: Vec<i32> = vec![];
            let mut j = 0;
            while j < tmp.len() as i32 {
                if j != idx {
                    out = { let mut tmp = out.clone(); tmp.push(tmp[j as usize]); tmp };
                }
                j += 1;
            }
            tmp = out;
        }
        return res;
    }
    fn commatize(n: i32) -> &'static str {
        let mut s = n.to_string();
        let mut i = s.len() as i32 - 3;
        while i >= 1 {
            s = format!("{}{}", format!("{}{}", &s[0 as usize..i as usize], ","), &s[i as usize..s.len() as i32 as usize]);
            i -= 3;
        }
        return s;
    }
    let mut primes = primesUpTo(3200000);
    let getBrilliant = move |digits: i32, limit: i32, countOnly: bool| -> std::collections::HashMap<&'static str, i32> {
        let mut brilliant: Vec<i32> = vec![];
        let mut count = 0;
        let mut pow = 1;
        let mut next = 999999999999999;
        let mut k = 1;
        while k <= digits {
            let mut s: Vec<i32> = vec![];
            for p in primes {
                if p >= pow * 10 {
                    break;
                }
                if p > pow {
                    s = { let mut tmp = s.clone(); tmp.push(p); tmp };
                }
            }
            let mut i = 0;
            while i < s.len() as i32 {
                let mut j = i;
                while j < s.len() as i32 {
                    let mut prod = s[i as usize] * s[j as usize];
                    if prod < limit {
                        if countOnly {
                            count += 1;
                        } else {
                            brilliant = { let mut tmp = brilliant.clone(); tmp.push(prod); tmp };
                        }
                    } else {
                        if prod < next {
                            next = prod;
                        }
                        break;
                    }
                    j += 1;
                }
                i += 1;
            }
            pow *= 10;
            k += 1;
        }
        if countOnly {
            return { let mut m = std::collections::BTreeMap::new(); m.insert("bc", count); m.insert("next", next); m };
        }
        return { let mut m = std::collections::BTreeMap::new(); m.insert("bc", brilliant); m.insert("next", next); m };
    };
    fn main() -> () {
        println!("First 100 brilliant numbers:");
        let r = getBrilliant(2, 10000, false);
        let mut br = sortInts(*r.get(&"bc").unwrap());
        br = br[0..100].to_vec();
        let mut i = 0;
        while i < br.len() as i32 {
            println!("{}", vec![format!("{}", format!("{}{}", br[i as usize].to_string().padStart(4, " "), " ")), format!("{}", if false {1} else {0})].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            if (i + 1) % 10 == 0 {
                println!("{}", vec![format!("{}", ""), format!("{}", if true {1} else {0})].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            }
            i += 1;
        }
        println!("{}", vec![format!("{}", ""), format!("{}", if true {1} else {0})].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        let mut k = 1;
        while k <= 13 {
            let limit = pow(10, k);
            let r2 = getBrilliant(k, limit, true);
            let total = *r2.get(&"bc").unwrap();
            let next = *r2.get(&"next").unwrap();
            let climit = commatize(limit);
            let ctotal = commatize(total + 1 as f64);
            let cnext = commatize(next);
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "First >= ", climit.padStart(18, " ")), " is "), ctotal.padStart(14, " ")), " in the series: "), cnext.padStart(18, " ")))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            k += 1;
        }
    }
}
