// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:33Z
fn main() {
    fn pow10(exp: i32) -> i32 {
        let mut n = 1;
        let mut i = 0;
        while i < exp {
            n *= 10;
            i += 1;
        }
        return n;
    }
    fn totient(n: i32) -> i32 {
        let mut tot = n;
        let mut nn = n;
        let mut i = 2;
        while i * i <= nn {
            if nn % i == 0 {
                while nn % i == 0 {
                    nn /= i;
                }
                tot = (tot - tot as f64) / (i as f64);
            }
            if i == 2 {
                i = 1;
            }
            i += 2;
        }
        if nn > 1 {
            tot = (tot - tot as f64) / (nn as f64);
        }
        return tot;
    }
    let mut pps: std::collections::HashMap<i32, bool> = { let mut m = std::collections::BTreeMap::new(); m };
    fn getPerfectPowers(maxExp: i32) -> () {
        let upper = pow10(maxExp);
        let mut i = 2;
        while i * i < upper {
            let mut p = i * i;
            while true {
                p *= i;
                if p >= upper {
                    break;
                }
                pps.insert(p, true);
            }
            i += 1;
        }
    }
    let getAchilles = move |minExp: i32, maxExp: i32| -> std::collections::HashMap<i32, bool> {
        let lower = pow10(minExp);
        let upper = pow10(maxExp);
        let mut achilles: std::collections::HashMap<i32, bool> = { let mut m = std::collections::BTreeMap::new(); m };
        let mut b = 1;
        while b * b * b < upper {
            let b3 = b * b * b;
            let mut a = 1;
            while true {
                let p = b3 * a * a;
                if p >= upper {
                    break;
                }
                if p >= lower {
                    if !(pps.contains_key(&p)) {
                        achilles.insert(p, true);
                    }
                }
                a += 1;
            }
            b += 1;
        }
        return achilles;
    };
    fn sortInts(xs: Vec<i32>) -> Vec<i32> {
        let mut res: Vec<i32> = vec![];
        let mut tmp = xs;
        while tmp.len() as i32 > 0 {
            let mut min = tmp[0];
            let mut idx = 0;
            let mut i = 1;
            while i < tmp.len() as i32 {
                if tmp[i as usize] < min {
                    min = tmp[i as usize];
                    idx = i;
                }
                i += 1;
            }
            res += vec![min];
            let mut out: Vec<i32> = vec![];
            let mut j = 0;
            while j < tmp.len() as i32 {
                if j != idx {
                    out += vec![tmp[j as usize]];
                }
                j += 1;
            }
            tmp = out;
        }
        return res;
    }
    fn pad(n: i32, width: i32) -> &'static str {
        let mut s = n.to_string();
        while s.len() as i32 < width {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn main() -> () {
        let maxDigits = 15;
        getPerfectPowers(maxDigits);
        let achSet = getAchilles(1, 5);
        let mut ach: Vec<i32> = vec![];
        for k in achSet.keys().keys() {
            ach += vec![k];
        }
        ach = sortInts(ach);
        println!("First 50 Achilles numbers:");
        let mut i = 0;
        while i < 50 {
            let mut line = "";
            let mut j = 0;
            while j < 10 {
                line += pad(ach[i as usize], 4);
                if j < 9 {
                    line += " ";
                }
                i += 1;
                j += 1;
            }
            println!("{}", line);
        }
        println!("\nFirst 30 strong Achilles numbers:");
        let mut strong: Vec<i32> = vec![];
        let mut count = 0;
        let mut idx = 0;
        while count < 30 {
            let tot = totient(ach[idx as usize]);
            if achSet.contains_key(&tot) {
                strong += vec![ach[idx as usize]];
                count += 1;
            }
            idx += 1;
        }
        i = 0;
        while i < 30 {
            let mut line = "";
            let mut j = 0;
            while j < 10 {
                line += pad(strong[i as usize], 5);
                if j < 9 {
                    line += " ";
                }
                i += 1;
                j += 1;
            }
            println!("{}", line);
        }
        println!("\nNumber of Achilles numbers with:");
        let counts = vec![1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383];
        let mut d = 2;
        while d <= maxDigits {
            let c = counts[d - 2 as usize];
            println!("{}", format!("{}{}", format!("{}{}", pad(d, 2), " digits: "), c.to_string()));
            d += 1;
        }
    }
    main();
}
