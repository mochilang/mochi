// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
use std::sync::{atomic::{AtomicBool, AtomicI64, Ordering}, Once};
static INIT_NOW: Once = Once::new();
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);

fn _init_now_seed() {
    INIT_NOW.call_once(|| {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    });
}

fn _now() -> i32 {
    _init_now_seed();
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let mut n = NOW_SEED.load(Ordering::SeqCst);
        n = (n * 1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(n, Ordering::SeqCst);
        return n as i32;
    }
    use std::time::{SystemTime, UNIX_EPOCH};
    (SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64 % i64::from(i32::MAX)) as i32
}

fn main() {
    let SIZE = 4;
    let newBoard = move || -> Vec<Vec<i32>> {
        let mut b: Vec<Vec<i32>> = vec![];
        let mut y = 0;
        while y < SIZE {
            let mut row: Vec<i32> = vec![];
            let mut x = 0;
            while x < SIZE {
                row = { let mut tmp = row.clone(); tmp.push(0); tmp };
                x += 1;
            }
            b = { let mut tmp = b.clone(); tmp.push(row); tmp };
            y += 1;
        }
        return b;
    };
    let spawnTile = move |b: &mut Vec<Vec<i32>>| -> std::collections::HashMap<String, i32> {
        let mut empty: Vec<Vec<i32>> = vec![];
        let mut y = 0;
        while y < SIZE {
            let mut x = 0;
            while x < SIZE {
                if b[(y) as usize].clone()[(x) as usize].clone() == 0 {
                    empty = { let mut tmp = empty.clone(); tmp.push(vec![x, y]); tmp };
                }
                x += 1;
            }
            y += 1;
        }
        if (empty.len() as i32) == 0 {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("board"), b); m.insert(String::from("full"), true); m };
        }
        let mut idx = _now() % (empty.len() as i32);
        let cell = empty[(idx) as usize].clone();
        let mut val = 4;
        if _now() % 10 < 9 {
            val = 2;
        }
        b[(cell[1].clone()) as usize][(cell[0].clone()) as usize] = val;
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("board"), b); m.insert(String::from("full"), (empty.len() as i32) == 1); m };
    };
    let pad = move |n: i32| -> String {
        let mut s = n.to_string();
        let mut pad = 4 - (s.len() as i32);
        let mut i = 0;
        let mut out = String::new();
        while i < pad {
            out = format!("{}{}", out, String::from(" "));
            i += 1;
        }
        return format!("{}{}", out, s);
    };
    let draw = move |b: Vec<Vec<i32>>, score: i32| -> () {
        println!("{}", vec![format!("{}", format!("{}{}", String::from("Score: "), score.to_string()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        let mut y = 0;
        while y < SIZE {
            println!("+----+----+----+----+");
            let mut line = String::from("|");
            let mut x = 0;
            while x < SIZE {
                let mut v = b[(y) as usize].clone()[(x) as usize].clone();
                if v == 0 {
                    line = format!("{}{}", line, String::from("    |"));
                } else {
                    line = format!("{}{}", format!("{}{}", line, pad(v)), String::from("|"));
                }
                x += 1;
            }
            println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            y += 1;
        }
        println!("+----+----+----+----+");
        println!("W=Up S=Down A=Left D=Right Q=Quit");
    };
    let reverseRow = move |r: Vec<i32>| -> Vec<i32> {
        let mut out: Vec<i32> = vec![];
        let mut i = (r.len() as i32) - 1;
        while i >= 0 {
            out = { let mut tmp = out.clone(); tmp.push(r[(i) as usize].clone()); tmp };
            i -= 1;
        }
        return out;
    };
    let slideLeft = move |row: Vec<i32>| -> std::collections::HashMap<String, i32> {
        let mut xs: Vec<i32> = vec![];
        let mut i = 0;
        while i < (row.len() as i32) {
            if row[(i) as usize].clone() != 0 {
                xs = { let mut tmp = xs.clone(); tmp.push(row[(i) as usize].clone()); tmp };
            }
            i += 1;
        }
        let mut res: Vec<i32> = vec![];
        let mut gain = 0;
        i = 0;
        while i < (xs.len() as i32) {
            if i + 1 < (xs.len() as i32) && xs[(i) as usize].clone() == xs[(i + 1) as usize].clone() {
                let v = xs[(i) as usize].clone() * 2;
                gain += v;
                res = { let mut tmp = res.clone(); tmp.push(v); tmp };
                i += 2;
            } else {
                res = { let mut tmp = res.clone(); tmp.push(xs[(i) as usize].clone()); tmp };
                i += 1;
            }
        }
        while (res.len() as i32) < SIZE {
            res = { let mut tmp = res.clone(); tmp.push(0); tmp };
        }
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("row"), res); m.insert(String::from("gain"), gain); m };
    };
    let moveLeft = move |b: &mut Vec<Vec<i32>>, score: &mut i32| -> std::collections::HashMap<String, i32> {
        let mut moved = false;
        let mut y = 0;
        while y < SIZE {
            let r = slideLeft(b[(y) as usize].clone());
            let new = *r.get(&String::from("row")).unwrap();
            score += *r.get(&String::from("gain")).unwrap();
            let mut x = 0;
            while x < SIZE {
                if b[(y) as usize].clone()[(x) as usize].clone() != new[(x) as usize].clone() {
                    moved = true;
                }
                b[(y) as usize][(x) as usize] = new[(x) as usize].clone();
                x += 1;
            }
            y += 1;
        }
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("board"), b); m.insert(String::from("score"), score); m.insert(String::from("moved"), moved); m };
    };
    let moveRight = move |b: &mut Vec<Vec<i32>>, score: &mut i32| -> std::collections::HashMap<String, i32> {
        let mut moved = false;
        let mut y = 0;
        while y < SIZE {
            let mut rev = reverseRow(b[(y) as usize].clone());
            let r = slideLeft(rev);
            rev = *r.get(&String::from("row")).unwrap();
            score += *r.get(&String::from("gain")).unwrap();
            rev = reverseRow(rev);
            let mut x = 0;
            while x < SIZE {
                if b[(y) as usize].clone()[(x) as usize].clone() != rev[(x) as usize].clone() {
                    moved = true;
                }
                b[(y) as usize][(x) as usize] = rev[(x) as usize].clone();
                x += 1;
            }
            y += 1;
        }
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("board"), b); m.insert(String::from("score"), score); m.insert(String::from("moved"), moved); m };
    };
    let getCol = move |b: Vec<Vec<i32>>, x: i32| -> Vec<i32> {
        let mut col: Vec<i32> = vec![];
        let mut y = 0;
        while y < SIZE {
            col = { let mut tmp = col.clone(); tmp.push(b[(y) as usize].clone()[(x) as usize].clone()); tmp };
            y += 1;
        }
        return col;
    };
    let setCol = move |b: &mut Vec<Vec<i32>>, x: i32, col: Vec<i32>| -> () {
        let mut y = 0;
        while y < SIZE {
            b[(y) as usize][(x) as usize] = col[(y) as usize].clone();
            y += 1;
        }
    };
    let moveUp = move |b: &mut Vec<Vec<i32>>, score: &mut i32| -> std::collections::HashMap<String, i32> {
        let mut moved = false;
        let mut x = 0;
        while x < SIZE {
            let mut col = getCol(b, x);
            let r = slideLeft(col);
            let new = *r.get(&String::from("row")).unwrap();
            score += *r.get(&String::from("gain")).unwrap();
            let mut y = 0;
            while y < SIZE {
                if b[(y) as usize].clone()[(x) as usize].clone() != new[(y) as usize].clone() {
                    moved = true;
                }
                b[(y) as usize][(x) as usize] = new[(y) as usize].clone();
                y += 1;
            }
            x += 1;
        }
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("board"), b); m.insert(String::from("score"), score); m.insert(String::from("moved"), moved); m };
    };
    let moveDown = move |b: &mut Vec<Vec<i32>>, score: &mut i32| -> std::collections::HashMap<String, i32> {
        let mut moved = false;
        let mut x = 0;
        while x < SIZE {
            let mut col = reverseRow(getCol(b, x));
            let r = slideLeft(col);
            col = *r.get(&String::from("row")).unwrap();
            score += *r.get(&String::from("gain")).unwrap();
            col = reverseRow(col);
            let mut y = 0;
            while y < SIZE {
                if b[(y) as usize].clone()[(x) as usize].clone() != col[(y) as usize].clone() {
                    moved = true;
                }
                b[(y) as usize][(x) as usize] = col[(y) as usize].clone();
                y += 1;
            }
            x += 1;
        }
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("board"), b); m.insert(String::from("score"), score); m.insert(String::from("moved"), moved); m };
    };
    let hasMoves = move |b: Vec<Vec<i32>>| -> bool {
        let mut y = 0;
        while y < SIZE {
            let mut x = 0;
            while x < SIZE {
                if b[(y) as usize].clone()[(x) as usize].clone() == 0 {
                    return true;
                }
                if x + 1 < SIZE && b[(y) as usize].clone()[(x) as usize].clone() == b[(y) as usize].clone()[(x + 1) as usize].clone() {
                    return true;
                }
                if y + 1 < SIZE && b[(y) as usize].clone()[(x) as usize].clone() == b[(y + 1) as usize].clone()[(x) as usize].clone() {
                    return true;
                }
                x += 1;
            }
            y += 1;
        }
        return false;
    };
    let has2048 = move |b: Vec<Vec<i32>>| -> bool {
        let mut y = 0;
        while y < SIZE {
            let mut x = 0;
            while x < SIZE {
                if b[(y) as usize].clone()[(x) as usize].clone() >= 2048 {
                    return true;
                }
                x += 1;
            }
            y += 1;
        }
        return false;
    };
    let mut board = newBoard();
    let mut r = spawnTile(&mut board);
    board = *r.get(&String::from("board")).unwrap();
    let mut full = *r.get(&String::from("full")).unwrap();
    r = spawnTile(&mut board);
    board = *r.get(&String::from("board")).unwrap();
    full = *r.get(&String::from("full")).unwrap();
    let mut score = 0;
    draw(board, score);
    while true {
        println!("Move: ");
        let cmd = input();
        let mut moved = false;
        if cmd == String::from("a") || cmd == String::from("A") {
            let m = moveLeft(&mut board, &mut score);
            board = *m.get(&String::from("board")).unwrap();
            score = *m.get(&String::from("score")).unwrap();
            moved = *m.get(&String::from("moved")).unwrap();
        }
        if cmd == String::from("d") || cmd == String::from("D") {
            let m = moveRight(&mut board, &mut score);
            board = *m.get(&String::from("board")).unwrap();
            score = *m.get(&String::from("score")).unwrap();
            moved = *m.get(&String::from("moved")).unwrap();
        }
        if cmd == String::from("w") || cmd == String::from("W") {
            let m = moveUp(&mut board, &mut score);
            board = *m.get(&String::from("board")).unwrap();
            score = *m.get(&String::from("score")).unwrap();
            moved = *m.get(&String::from("moved")).unwrap();
        }
        if cmd == String::from("s") || cmd == String::from("S") {
            let m = moveDown(&mut board, &mut score);
            board = *m.get(&String::from("board")).unwrap();
            score = *m.get(&String::from("score")).unwrap();
            moved = *m.get(&String::from("moved")).unwrap();
        }
        if cmd == String::from("q") || cmd == String::from("Q") {
            break;
        }
        if moved {
            let r2 = spawnTile(&mut board);
            board = *r2.get(&String::from("board")).unwrap();
            full = *r2.get(&String::from("full")).unwrap();
            if full && (!hasMoves(board)) != Default::default() {
                draw(board, score);
                println!("Game Over");
                break;
            }
        }
        draw(board, score);
        if has2048(board) {
            println!("You win!");
            break;
        }
        if !hasMoves(board) {
            println!("Game Over");
            break;
        }
    }
}
