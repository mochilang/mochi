// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn sqrtApprox(x: f64) -> f64 {
        let mut guess = x;
        let mut i = 0;
        while i < 20 {
            guess = (guess + x / guess) / 2.0;
            i += 1;
        }
        return guess;
    }
    fn makeSym(order: i32, elements: Vec<f64>) -> std::collections::HashMap<&'static str, i32> {
        return { let mut m = std::collections::BTreeMap::new(); m.insert("order", order); m.insert("ele", elements); m };
    }
    fn unpackSym(m: std::collections::HashMap<&'static str, i32>) -> Vec<Vec<f64>> {
        let n = *m.get(&"order").unwrap();
        let ele = *m.get(&"ele").unwrap();
        let mut mat: Vec<Vec<f64>> = vec![];
        let mut idx = 0;
        let mut r = 0;
        while r < n {
            let mut row: Vec<f64> = vec![];
            let mut c = 0;
            while c <= r {
                row = { let mut tmp = row.clone(); tmp.push(ele[idx as usize]); tmp };
                idx += 1;
                c += 1;
            }
            while c < n {
                row = { let mut tmp = row.clone(); tmp.push(0.0); tmp };
                c += 1;
            }
            mat = { let mut tmp = mat.clone(); tmp.push(row); tmp };
            r += 1;
        }
        r = 0;
        while r < n {
            let mut c = r + 1;
            while c < n {
                mat[r as usize][c as usize] = mat[c as usize][r as usize];
                c += 1;
            }
            r += 1;
        }
        return mat;
    }
    fn printMat(m: Vec<Vec<f64>>) -> () {
        let mut i = 0;
        while i < m.len() as i32 {
            let mut line = String::new();
            let mut j = 0;
            while j < m[i as usize].len() as i32 {
                line += m[i as usize][j as usize].to_string();
                if j < m[i as usize].len() as i32 - 1 {
                    line += " ";
                }
                j += 1;
            }
            println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            i += 1;
        }
    }
    fn printSym(m: std::collections::HashMap<&'static str, i32>) -> () {
        printMat(unpackSym(m));
    }
    fn printLower(m: std::collections::HashMap<&'static str, i32>) -> () {
        let n = *m.get(&"order").unwrap();
        let ele = *m.get(&"ele").unwrap();
        let mut mat: Vec<Vec<f64>> = vec![];
        let mut idx = 0;
        let mut r = 0;
        while r < n {
            let mut row: Vec<f64> = vec![];
            let mut c = 0;
            while c <= r {
                row = { let mut tmp = row.clone(); tmp.push(ele[idx as usize]); tmp };
                idx += 1;
                c += 1;
            }
            while c < n {
                row = { let mut tmp = row.clone(); tmp.push(0.0); tmp };
                c += 1;
            }
            mat = { let mut tmp = mat.clone(); tmp.push(row); tmp };
            r += 1;
        }
        printMat(mat);
    }
    fn choleskyLower(a: std::collections::HashMap<&'static str, i32>) -> std::collections::HashMap<&'static str, i32> {
        let n = *a.get(&"order").unwrap();
        let ae = *a.get(&"ele").unwrap();
        let mut le: Vec<f64> = vec![];
        let mut idx = 0;
        while idx < ae.len() as i32 {
            le = { let mut tmp = le.clone(); tmp.push(0.0); tmp };
            idx += 1;
        }
        let mut row = 1;
        let mut col = 1;
        let mut dr = 0;
        let mut dc = 0;
        let mut i = 0;
        while i < ae.len() as i32 {
            let e = ae[i as usize];
            if i < dr {
                let mut d = (e - le[i as usize]) / le[dc as usize];
                le[i as usize] = d;
                let mut ci = col;
                let mut cx = dc;
                let mut j = i + 1;
                while j <= dr {
                    cx += ci;
                    ci += 1;
                    le[j as usize] = le[j as usize] + d * le[cx as usize];
                    j += 1;
                }
                col += 1;
                dc += col;
            } else {
                le[i as usize] = sqrtApprox(e - le[i as usize]);
                row += 1;
                dr += row;
                col = 1;
                dc = 0;
            }
            i += 1;
        }
        return { let mut m = std::collections::BTreeMap::new(); m.insert("order", n); m.insert("ele", le); m };
    }
    fn demo(a: std::collections::HashMap<&'static str, i32>) -> () {
        println!("A:");
        printSym(a);
        println!("L:");
        let l = choleskyLower(a);
        printLower(l);
    }
    demo(makeSym(3, vec![25.0, 15.0, 18.0, -5.0, 0.0, 11.0]));
    demo(makeSym(4, vec![18.0, 22.0, 70.0, 54.0, 86.0, 174.0, 42.0, 62.0, 134.0, 106.0]));
}
