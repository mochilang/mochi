// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    let mut adfgvx = String::from("ADFGVX");
    let mut alphabet = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
    fn shuffleStr(s: &'static str) -> &'static str {
        let mut arr: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < s.len() as i32 {
            arr += vec![s.chars().nth(i as usize).unwrap()];
            i += 1;
        }
        let mut j = arr.len() as i32 - 1;
        while j > 0 {
            let k = now() % (j + 1);
            let tmp = arr[j as usize];
            arr[j as usize] = arr[k as usize];
            arr[k as usize] = tmp;
            j -= 1;
        }
        let mut out = String::new();
        i = 0;
        while i < arr.len() as i32 {
            out += arr[i as usize];
            i += 1;
        }
        return out;
    }
    let createPolybius = move || -> Vec<&'static str> {
        let shuffled = shuffleStr(alphabet);
        println!("6 x 6 Polybius square:\n");
        println!("  | A D F G V X");
        println!("---------------");
        let mut p: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < 6 {
            let mut row = &shuffled[i * 6 as usize..(i + 1) * 6 as usize];
            p += vec![row];
            let mut line = format!("{}{}", adfgvx.chars().nth(i as usize).unwrap(), " | ");
            let mut j = 0;
            while j < 6 {
                line = format!("{}{}", format!("{}{}", line, row.chars().nth(j as usize).unwrap()), " ");
                j += 1;
            }
            println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            i += 1;
        }
        return p;
    };
    fn createKey(n: i32) -> &'static str {
        if n < 7 || n > 12 {
            println!("Key should be within 7 and 12 letters long.");
        }
        let mut pool = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
        let mut key = String::new();
        let mut i = 0;
        while i < n {
            let idx = now() % pool.len() as i32;
            key += pool.chars().nth(idx as usize).unwrap();
            pool = format!("{}{}", &pool[0 as usize..idx as usize], &pool[idx + 1 as usize..pool.len() as i32 as usize]);
            i += 1;
        }
        println!("{}", vec![format!("{}", format!("{}{}", "
The key is ", key))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        return key;
    }
    fn orderKey(key: &'static str) -> Vec<i32> {
        let mut pairs = vec![];
        let mut i = 0;
        while i < key.len() as i32 {
            pairs += vec![vec![key.chars().nth(i as usize).unwrap(), i]];
            i += 1;
        }
        let mut n = pairs.len() as i32;
        let mut m = 0;
        while m < n {
            let mut j = 0;
            while j < n - 1 {
                if pairs[j as usize][0] > pairs[j + 1 as usize][0] {
                    let tmp = pairs[j as usize];
                    pairs[j as usize] = pairs[j + 1 as usize];
                    pairs[j + 1 as usize] = tmp;
                }
                j += 1;
            }
            m += 1;
        }
        let mut res = vec![];
        i = 0;
        while i < n {
            res += vec![pairs[i as usize][1].parse::<i32>().unwrap()];
            i += 1;
        }
        return res;
    }
    let encrypt = move |polybius: Vec<&'static str>, key: &'static str, plainText: &'static str| -> &'static str {
        let mut temp = String::new();
        let mut i = 0;
        while i < plainText.len() as i32 {
            let mut r = 0;
            while r < 6 {
                let mut c = 0;
                while c < 6 {
                    if polybius[r as usize].chars().nth(c as usize).unwrap() == plainText.chars().nth(i as usize).unwrap() {
                        temp = format!("{}{}", format!("{}{}", temp, adfgvx.chars().nth(r as usize).unwrap()), adfgvx.chars().nth(c as usize).unwrap());
                    }
                    c += 1;
                }
                r += 1;
            }
            i += 1;
        }
        let mut colLen = (temp.len() as i32 as f64) / (key.len() as i32 as f64);
        if temp.len() as i32 % key.len() as i32 > 0 {
            colLen += 1;
        }
        let mut table: Vec<Vec<&'static str>> = vec![];
        let mut rIdx = 0;
        while (rIdx as f64) < colLen {
            let mut row: Vec<&'static str> = vec![];
            let mut j = 0;
            while j < key.len() as i32 {
                row += vec![""];
                j += 1;
            }
            table += vec![row];
            rIdx += 1;
        }
        let mut idx = 0;
        while idx < temp.len() as i32 {
            let row = (idx as f64) / (key.len() as i32 as f64);
            let col = idx % key.len() as i32;
            table[row as usize][col as usize] = &temp[idx as usize..idx + 1 as usize];
            idx += 1;
        }
        let order = orderKey(key);
        let mut cols: Vec<&'static str> = vec![];
        let mut ci = 0;
        while ci < key.len() as i32 {
            let mut colStr = String::new();
            let mut ri = 0;
            while (ri as f64) < colLen {
                colStr += table[ri as usize][order[ci as usize] as usize];
                ri += 1;
            }
            cols += vec![colStr];
            ci += 1;
        }
        let mut result = String::new();
        ci = 0;
        while ci < cols.len() as i32 {
            result += cols[ci as usize];
            if ci < cols.len() as i32 - 1 {
                result += " ";
            }
            ci += 1;
        }
        return result;
    };
    fn indexOf(s: &'static str, ch: &'static str) -> i32 {
        let mut i = 0;
        while i < s.len() as i32 {
            if s.chars().nth(i as usize).unwrap() == ch {
                return i;
            }
            i += 1;
        }
        return -1;
    }
    let decrypt = move |polybius: Vec<&'static str>, key: &'static str, cipherText: &'static str| -> &'static str {
        let mut colStrs: Vec<&'static str> = vec![];
        let mut start = 0;
        let mut i = 0;
        while i <= cipherText.len() as i32 {
            if i == cipherText.len() as i32 || cipherText.chars().nth(i as usize).unwrap() == " " {
                colStrs += vec![&cipherText[start as usize..i as usize]];
                start = i + 1;
            }
            i += 1;
        }
        let mut maxColLen = 0;
        i = 0;
        while i < colStrs.len() as i32 {
            if colStrs[i as usize].len() as i32 > maxColLen {
                maxColLen = colStrs[i as usize].len() as i32;
            }
            i += 1;
        }
        let mut cols: Vec<Vec<&'static str>> = vec![];
        i = 0;
        while i < colStrs.len() as i32 {
            let mut s = colStrs[i as usize];
            let mut ls: Vec<&'static str> = vec![];
            let mut j = 0;
            while j < s.len() as i32 {
                ls += vec![s.chars().nth(j as usize).unwrap()];
                j += 1;
            }
            if s.len() as i32 < maxColLen {
                let mut pad: Vec<&'static str> = vec![];
                let mut k = 0;
                while k < maxColLen {
                    if k < ls.len() as i32 {
                        pad += vec![ls[k as usize]];
                    } else {
                        pad += vec![""];
                    }
                    k += 1;
                }
                cols += vec![pad];
            } else {
                cols += vec![ls];
            }
            i += 1;
        }
        let mut table: Vec<Vec<&'static str>> = vec![];
        let mut r = 0;
        while r < maxColLen {
            let mut row: Vec<&'static str> = vec![];
            let mut c = 0;
            while c < key.len() as i32 {
                row += vec![""];
                c += 1;
            }
            table += vec![row];
            r += 1;
        }
        let order = orderKey(key);
        r = 0;
        while r < maxColLen {
            let mut c = 0;
            while c < key.len() as i32 {
                table[r as usize][order[c as usize] as usize] = cols[c as usize][r as usize];
                c += 1;
            }
            r += 1;
        }
        let mut temp = String::new();
        r = 0;
        while r < table.len() as i32 {
            let mut j = 0;
            while j < table[r as usize].len() as i32 {
                temp += table[r as usize][j as usize];
                j += 1;
            }
            r += 1;
        }
        let mut plainText = String::new();
        let mut idx = 0;
        while idx < temp.len() as i32 {
            let rIdx = indexOf(adfgvx, &temp[idx as usize..idx + 1 as usize]);
            let cIdx = indexOf(adfgvx, &temp[idx + 1 as usize..idx + 2 as usize]);
            plainText += polybius[rIdx as usize].chars().nth(cIdx as usize).unwrap();
            idx += 2;
        }
        return plainText;
    };
    fn main() -> () {
        let plainText = "ATTACKAT1200AM";
        let polybius = createPolybius();
        let key = createKey(9);
        println!("{}", vec![format!("{}", format!("{}{}", "
Plaintext : ", plainText))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        let cipherText = encrypt(polybius, key, plainText);
        println!("{}", vec![format!("{}", format!("{}{}", "
Encrypted : ", cipherText))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        let plainText2 = decrypt(polybius, key, cipherText);
        println!("{}", vec![format!("{}", format!("{}{}", "
Decrypted : ", plainText2))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    }
    main();
}
