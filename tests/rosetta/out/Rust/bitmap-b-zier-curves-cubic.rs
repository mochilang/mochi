// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:47Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Pixel {
        r: i32,
        g: i32,
        b: i32,
}

fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    let b3Seg = 30;
    fn pixelFromRgb(rgb: i32) -> Pixel {
        let r = (((rgb as f64) / (65536 as f64)) % 256).parse::<i32>().unwrap();
        let g = (((rgb as f64) / (256 as f64)) % 256).parse::<i32>().unwrap();
        let b = (rgb % 256).parse::<i32>().unwrap();
        return Pixel { r: r, g: g, b: b };
    }
    fn newBitmap(cols: i32, rows: i32) -> std::collections::HashMap<&'static str, i32> {
        let mut d: Vec<Vec<Pixel>> = vec![];
        let mut y = 0;
        while y < rows {
            let mut row: Vec<Pixel> = vec![];
            let mut x = 0;
            while x < cols {
                row = append(row, Pixel { r: 0, g: 0, b: 0 });
                x += 1;
            }
            d = append(d, row);
            y += 1;
        }
        return { let mut m = std::collections::BTreeMap::new(); m.insert("cols", cols); m.insert("rows", rows); m.insert("data", d); m };
    }
    fn setPx(b: &mut std::collections::HashMap<&'static str, i32>, x: i32, y: i32, p: Pixel) -> () {
        let cols = b[&"cols"].parse::<i32>().unwrap();
        let rows = b[&"rows"].parse::<i32>().unwrap();
        if x >= 0 && x < cols && y >= 0 && y < rows {
            b["data"][y][x] = p.clone();
        }
    }
    fn fill(b: &mut std::collections::HashMap<&'static str, i32>, p: Pixel) -> () {
        let cols = b[&"cols"].parse::<i32>().unwrap();
        let rows = b[&"rows"].parse::<i32>().unwrap();
        let mut y = 0;
        while y < rows {
            let mut x = 0;
            while x < cols {
                b["data"][y][x] = p.clone();
                x += 1;
            }
            y += 1;
        }
    }
    fn fillRgb(b: std::collections::HashMap<&'static str, i32>, rgb: i32) -> () {
        fill(&mut b, &pixelFromRgb(rgb));
    }
    fn line(b: std::collections::HashMap<&'static str, i32>, x0: &mut i32, y0: &mut i32, x1: i32, y1: i32, p: Pixel) -> () {
        let mut dx = x1 - x0;
        if dx < 0 {
            dx = -dx;
        }
        let mut dy = y1 - y0;
        if dy < 0 {
            dy = -dy;
        }
        let mut sx = -1;
        if x0 < x1 {
            sx = 1;
        }
        let mut sy = -1;
        if y0 < y1 {
            sy = 1;
        }
        let mut err = dx - dy;
        while true {
            setPx(&mut b, x0, y0, &p.clone());
            if x0 == x1 && y0 == y1 {
                break;
            }
            let e2 = 2 * err;
            if e2 > (0 - dy) {
                err -= dy;
                x0 += sx;
            }
            if e2 < dx {
                err += dx;
                y0 += sy;
            }
        }
    }
    let bezier3 = move |b: std::collections::HashMap<&'static str, i32>, x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32, p: Pixel| -> () {
        let mut px: Vec<i32> = vec![];
        let mut py: Vec<i32> = vec![];
        let mut i = 0;
        while i <= b3Seg {
            px = append(px, 0);
            py = append(py, 0);
            i += 1;
        }
        let fx1 = x1.parse::<f64>().unwrap();
        let fy1 = y1.parse::<f64>().unwrap();
        let fx2 = x2.parse::<f64>().unwrap();
        let fy2 = y2.parse::<f64>().unwrap();
        let fx3 = x3.parse::<f64>().unwrap();
        let fy3 = y3.parse::<f64>().unwrap();
        let fx4 = x4.parse::<f64>().unwrap();
        let fy4 = y4.parse::<f64>().unwrap();
        i = 0;
        while i <= b3Seg {
            let d = (i.parse::<f64>().unwrap()) / (b3Seg.parse::<f64>().unwrap());
            let mut a = 1.0 - d;
            let mut bcoef = a * a;
            let mut ccoef = d * d;
            let mut a2 = a * bcoef;
            let mut b2 = 3.0 * bcoef * d;
            let mut c2 = 3.0 * a * ccoef;
            let mut d2 = ccoef * d;
            px[i as usize] = (a2 * fx1 + b2 * fx2 + c2 * fx3 + d2 * fx4).parse::<i32>().unwrap();
            py[i as usize] = (a2 * fy1 + b2 * fy2 + c2 * fy3 + d2 * fy4).parse::<i32>().unwrap();
            i += 1;
        }
        let mut x0 = px[0];
        let mut y0 = py[0];
        i = 1;
        while i <= b3Seg {
            let x = px[i as usize];
            let y = py[i as usize];
            line(b, &mut x0, &mut y0, x, y, &p.clone());
            x0 = x;
            y0 = y;
            i += 1;
        }
    };
    let mut b = newBitmap(400, 300);
    fillRgb(b, 16773055);
    bezier3(b, 20, 200, 700, 50, -300, 50, 380, 150, &pixelFromRgb(4165615));
}
