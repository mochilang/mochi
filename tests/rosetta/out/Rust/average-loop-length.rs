// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn absf(x: f64) -> f64 {
        if x < 0.0 {
            return -x;
        }
        return x;
    }
    fn floorf(x: f64) -> f64 {
        return (x.parse::<i32>().unwrap()).parse::<f64>().unwrap();
    }
    fn indexOf(s: &'static str, ch: &'static str) -> i32 {
        let mut i = 0;
        while i < s.len() as i32 {
            if &s[i as usize..i + 1 as usize] == ch {
                return i;
            }
            i += 1;
        }
        return -1;
    }
    fn fmtF(x: f64) -> &'static str {
        let mut y = floorf(x * 10000.0 + 0.5) / 10000.0;
        let mut s = y.to_string();
        let mut dot = indexOf(s, ".");
        if dot == 0 - 1 {
            s += ".0000";
        } else {
            let mut decs = s.len() as i32 - dot - 1;
            if decs > 4 {
                s = &s[0 as usize..dot + 5 as usize];
            } else {
                while decs < 4 {
                    s += "0";
                    decs += 1;
                }
            }
        }
        return s;
    }
    fn padInt(n: i32, width: i32) -> &'static str {
        let mut s = n.to_string();
        while s.len() as i32 < width {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn padFloat(x: f64, width: i32) -> &'static str {
        let mut s = fmtF(x);
        while s.len() as i32 < width {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn avgLen(n: i32) -> f64 {
        let tests = 10000;
        let mut sum = 0;
        let mut seed = 1;
        let mut t = 0;
        while t < tests {
            let mut visited: Vec<bool> = vec![];
            let mut i = 0;
            while i < n {
                visited = { let mut tmp = visited.clone(); tmp.push(false); tmp };
                i += 1;
            }
            let mut x = 0;
            while !visited[x as usize] {
                visited[x as usize] = true;
                sum += 1;
                seed = (seed * 1664525 + 1013904223) % 2147483647;
                x = seed % n;
            }
            t += 1;
        }
        return (sum.parse::<f64>().unwrap()) / tests as f64;
    }
    fn ana(n: i32) -> f64 {
        let mut nn = n.parse::<f64>().unwrap();
        let mut term = 1.0;
        let mut sum = 1.0;
        let mut i = nn - 1.0;
        while i >= 1.0 {
            term *= (i / nn);
            sum += term;
            i -= 1.0;
        }
        return sum;
    }
    fn main() -> () {
        let nmax = 20;
        println!(" N    average    analytical    (error)");
        println!("===  =========  ============  =========");
        let mut n = 1;
        while n <= nmax {
            let a = avgLen(n);
            let b = ana(n);
            let err = absf(a - b) / b * 100.0;
            let mut line = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", padInt(n, 3), "  "), padFloat(a, 9)), "  "), padFloat(b, 12)), "  ("), padFloat(err, 6)), "%)");
            println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            n += 1;
        }
    }
    main();
}
