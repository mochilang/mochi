// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:52Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Colour {
        R: i32,
        G: i32,
        B: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Bitmap {
        width: i32,
        height: i32,
        pixels: Vec<Vec<Colour>>,
}

fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn newBitmap(w: i32, h: i32, c: Colour) -> Bitmap {
        let mut rows: Vec<Vec<Colour>> = vec![];
        let mut y = 0;
        while y < h {
            let mut row: Vec<Colour> = vec![];
            let mut x = 0;
            while x < w {
                row = append(row, c.clone());
                x += 1;
            }
            rows = append(rows, row);
            y += 1;
        }
        return Bitmap { width: w, height: h, pixels: rows };
    }
    fn setPixel(b: &mut Bitmap, x: i32, y: i32, c: Colour) -> () {
        let mut rows = b.pixels;
        let mut row = rows[y as usize];
        row[x as usize] = c.clone();
        rows[y as usize] = row;
        b.pixels = rows;
    }
    fn fillRect(b: Bitmap, x: i32, y: i32, w: i32, h: i32, c: Colour) -> () {
        let mut yy = y;
        while yy < y + h {
            let mut xx = x;
            while xx < x + w {
                setPixel(&mut b.clone(), xx, yy, &c.clone());
                xx += 1;
            }
            yy += 1;
        }
    }
    fn pad(n: i32, width: i32) -> &'static str {
        let mut s = n.to_string();
        while s.len() as i32 < width {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn writePPMP3(b: Bitmap) -> &'static str {
        let mut maxv = 0;
        let mut y = 0;
        while y < b.height {
            let mut x = 0;
            while x < b.width {
                let p = b.pixels[y as usize][x as usize];
                if p.R > maxv {
                    maxv = p.R;
                }
                if p.G > maxv {
                    maxv = p.G;
                }
                if p.B > maxv {
                    maxv = p.B;
                }
                x += 1;
            }
            y += 1;
        }
        let mut out = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "P3
# generated from Bitmap.writeppmp3
", b.width.to_string()), " "), b.height.to_string()), "
"), maxv.to_string()), "
");
        let mut numsize = maxv.to_string().len() as i32;
        y = b.height - 1;
        while y >= 0 {
            let mut line = "";
            let mut x = 0;
            while x < b.width {
                let p = b.pixels[y as usize][x as usize];
                line = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", line, "   "), pad(p.R, numsize)), " "), pad(p.G, numsize)), " "), pad(p.B, numsize));
                x += 1;
            }
            out += line;
            if y > 0 {
                out += "
";
            } else {
                out += "
";
            }
            y -= 1;
        }
        return out;
    }
    fn main() -> () {
        let black = Colour { R: 0, G: 0, B: 0 };
        let white = Colour { R: 255, G: 255, B: 255 };
        let mut bm = newBitmap(4, 4, &black.clone());
        fillRect(&bm.clone(), 1, 0, 1, 2, &white.clone());
        setPixel(&mut bm.clone(), 3, 3, &Colour { R: 127, G: 0, B: 63 });
        let ppm = writePPMP3(&bm.clone());
        println!("{}", ppm);
    }
    main();
}
