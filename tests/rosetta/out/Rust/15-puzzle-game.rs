// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
use std::sync::{atomic::{AtomicBool, AtomicI64, Ordering}, Once};
static INIT_NOW: Once = Once::new();
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);

fn _init_now_seed() {
    INIT_NOW.call_once(|| {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    });
}

fn _now() -> i32 {
    _init_now_seed();
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let mut n = NOW_SEED.load(Ordering::SeqCst);
        n = (n * 1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(n, Ordering::SeqCst);
        return n as i32;
    }
    use std::time::{SystemTime, UNIX_EPOCH};
    (SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64 % i64::from(i32::MAX)) as i32
}

fn main() {
    let mut board = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
    let solved = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
    let mut empty = 15;
    let mut moves = 0;
    let mut quit = false;
    let randMove = move || -> i32 {
        return _now() % 4;
    };
    let isSolved = move || -> bool {
        let mut i = 0;
        while i < 16 {
            if board[(i) as usize] != solved[(i) as usize] {
                return false;
            }
            i += 1;
        }
        return true;
    };
    let isValidMove = move |m: i32| -> std::collections::HashMap<String, i32> {
        if m == 0 {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx"), empty - 4); m.insert(String::from("ok"), (empty as f64) / (4 as f64) > 0); m };
        }
        if m == 1 {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx"), empty + 4); m.insert(String::from("ok"), (empty as f64) / (4 as f64) < 3); m };
        }
        if m == 2 {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx"), empty + 1); m.insert(String::from("ok"), empty % 4 < 3); m };
        }
        if m == 3 {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx"), empty - 1); m.insert(String::from("ok"), empty % 4 > 0); m };
        }
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx"), 0); m.insert(String::from("ok"), false); m };
    };
    let doMove = move |m: i32| -> bool {
        let r = isValidMove(m);
        if !*r.get(&String::from("ok")).unwrap() != Default::default() {
            return false;
        }
        let i = empty;
        let j = int(*r.get(&String::from("idx")).unwrap());
        let tmp = board[(i) as usize];
        board[(i) as usize] = board[(j) as usize];
        board[(j) as usize] = tmp;
        empty = j;
        moves += 1;
        return true;
    };
    let shuffle = move |n: i32| -> () {
        let mut i = 0;
        while i < n || isSolved() {
            if doMove(randMove()) {
                i += 1;
            }
        }
    };
    let printBoard = move || -> () {
        let mut line = String::new();
        let mut i = 0;
        while i < 16 {
            let val = board[(i) as usize];
            if val == 0 {
                line = format!("{}{}", line, String::from("  ."));
            } else {
                let s = val.to_string();
                if val < 10 {
                    line = format!("{}{}", format!("{}{}", line, String::from("  ")), s);
                } else {
                    line = format!("{}{}", format!("{}{}", line, String::from(" ")), s);
                }
            }
            if i % 4 == 3 {
                println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                line = String::from("");
            }
            i += 1;
        }
    };
    let playOneMove = move || -> () {
        while true {
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", String::from("Enter move #"), moves + 1.to_string()), String::from(" (U, D, L, R, or Q): ")))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            let s = input();
            if s == String::from("") {
                continue;
            }
            let c = &s[0..1];
            let mut m = 0;
            if c == String::from("U") || c == String::from("u") {
                m = 0;
            }
            if !doMove(m) {
                println!("That is not a valid move at the moment.");
                continue;
            }
            return ();
        }
    };
    let play = move || -> () {
        println!("Starting board:");
        while !quit && isSolved() == false {
            println!("");
            printBoard();
            playOneMove();
        }
        if isSolved() {
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", String::from("You solved the puzzle in "), moves.to_string()), String::from(" moves.")))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        }
    };
    let main = move || -> () {
        shuffle(50);
        play();
    };
    main();
}
