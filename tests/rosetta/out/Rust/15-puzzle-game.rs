// Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
fn _input() -> String {
    use std::io::{self, Read};
    let mut s = String::new();
    io::stdin().read_line(&mut s).unwrap();
    s.trim().to_string()
}

fn _now() -> i64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
}

fn main() {
    let mut board = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
    let solved = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
    let mut empty = 15;
    let mut moves = 0;
    let mut quit = false;
    let randMove = move || -> i32 {
        return _now() % 4;
    };
    let isSolved = move || -> bool {
        let mut i = 0;
        while i < 16 {
            if board[(i) as usize] != solved[(i) as usize] {
                return false;
            }
            i += 1;
        }
        return true;
    };
    let isValidMove = move |m: i32| -> std::collections::HashMap<String, i32> {
        if m == 0 {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx").to_string(), empty - 4.to_string()); m.insert(String::from("ok").to_string(), (empty as f64) / (4 as f64) > 0.to_string()); m };
        }
        if m == 1 {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx").to_string(), empty + 4.to_string()); m.insert(String::from("ok").to_string(), (empty as f64) / (4 as f64) < 3.to_string()); m };
        }
        if m == 2 {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx").to_string(), empty + 1.to_string()); m.insert(String::from("ok").to_string(), empty % 4 < 3.to_string()); m };
        }
        if m == 3 {
            return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx").to_string(), empty - 1.to_string()); m.insert(String::from("ok").to_string(), empty % 4 > 0.to_string()); m };
        }
        return { let mut m = std::collections::HashMap::new(); m.insert(String::from("idx").to_string(), 0.to_string()); m.insert(String::from("ok").to_string(), false.to_string()); m };
    };
    let doMove = move |m: i32| -> bool {
        let r = isValidMove(m);
        if !*r.get(&String::from("ok")).unwrap() != Default::default() {
            return false;
        }
        let i = empty;
        let j = int(*r.get(&String::from("idx")).unwrap());
        let tmp = board[(i) as usize];
        board[(i) as usize] = board[(j) as usize];
        board[(j) as usize] = tmp;
        empty = j;
        moves += 1;
        return true;
    };
    let shuffle = move |n: i32| -> () {
        let mut i = 0;
        while i < n || isSolved() {
            if doMove(randMove()) {
                i += 1;
            }
        }
    };
    let printBoard = move || -> () {
        let mut line = String::new();
        let mut i = 0;
        while i < 16 {
            let val = board[(i) as usize];
            if val == 0 {
                line = format!("{}{}", line, String::from("  ."));
            } else {
                let s = val.to_string();
                if val < 10 {
                    line = format!("{}{}", format!("{}{}", line, String::from("  ")), s);
                } else {
                    line = format!("{}{}", format!("{}{}", line, String::from(" ")), s);
                }
            }
            if i % 4 == 3 {
                println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                line = String::from("");
            }
            i += 1;
        }
    };
    let playOneMove = move || -> () {
        while true {
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", String::from("Enter move #"), moves + 1.to_string()), String::from(" (U, D, L, R, or Q): ")))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            let s = _input();
            if s == String::from("") {
                continue;
            }
            let c = &s[0..1];
            let mut m = 0;
            if c == String::from("U") || c == String::from("u") {
                m = 0;
            }
            if !doMove(m) {
                println!("That is not a valid move at the moment.");
                continue;
            }
            return ();
        }
    };
    let play = move || -> () {
        println!("Starting board:");
        while !quit && isSolved() == false {
            println!("");
            printBoard();
            playOneMove();
        }
        if isSolved() {
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", String::from("You solved the puzzle in "), moves.to_string()), String::from(" moves.")))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        }
    };
    let main = move || -> () {
        shuffle(50);
        play();
    };
    main();
}
