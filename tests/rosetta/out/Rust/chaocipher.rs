// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:53Z
fn main() {
    fn indexOf(s: &'static str, ch: &'static str) -> i32 {
        let mut i = 0;
        while i < s.len() as i32 {
            if &s[i as usize..i + 1 as usize] == ch {
                return i;
            }
            i += 1;
        }
        return -1;
    }
    fn rotate(s: &'static str, n: i32) -> &'static str {
        return format!("{}{}", &s[n as usize..s.len() as usize], &s[0 as usize..n as usize]);
    }
    fn scrambleLeft(s: &'static str) -> &'static str {
        return format!("{}{}", format!("{}{}", format!("{}{}", &s[0..1], &s[2..14]), &s[1..2]), &s[14 as usize..s.len() as usize]);
    }
    fn scrambleRight(s: &'static str) -> &'static str {
        return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", &s[1..3], &s[4..15]), &s[3..4]), &s[15 as usize..s.len() as usize]), &s[0..1]);
    }
    fn chao(text: &'static str, encode: bool) -> &'static str {
        let mut left = "HXUCZVAMDSLKPEFJRIGTWOBNYQ";
        let mut right = "PTLNBQDEOYSFAVZKGJRIHWXUMC";
        let mut out = "";
        let mut i = 0;
        while i < text.len() as i32 {
            let ch = &text[i as usize..i + 1 as usize];
            let mut idx = 0;
            if encode {
                idx = indexOf(right, ch);
                out += &left[idx as usize..idx + 1 as usize];
            } else {
                idx = indexOf(left, ch);
                out += &right[idx as usize..idx + 1 as usize];
            }
            left = rotate(left, idx);
            right = rotate(right, idx);
            left = scrambleLeft(left);
            right = scrambleRight(right);
            i += 1;
        }
        return out;
    }
    fn main() -> () {
        let plain = "WELLDONEISBETTERTHANWELLSAID";
        let cipher = chao(plain, true);
        println!("{}", plain);
        println!("{}", cipher);
        println!("{}", chao(cipher, false));
    }
    main();
}
