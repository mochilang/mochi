// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    let PI = 3.141592653589793;
    fn sinApprox(x: f64) -> f64 {
        let mut term = x;
        let mut sum = x;
        let mut n = 1;
        while n <= 10 {
            let denom = ((2 * n) * (2 * n + 1)).parse::<f64>().unwrap();
            term = -term * x * x / denom;
            sum += term;
            n += 1;
        }
        return sum;
    }
    fn cosApprox(x: f64) -> f64 {
        let mut term = 1.0;
        let mut sum = 1.0;
        let mut n = 1;
        while n <= 10 {
            let denom = ((2 * n - 1) * (2 * n)).parse::<f64>().unwrap();
            term = -term * x * x / denom;
            sum += term;
            n += 1;
        }
        return sum;
    }
    let degreesIncr = 0.1 * PI / 180.0;
    let turns = 2.0;
    let stop = 360.0 * turns * 10.0 * degreesIncr;
    let width = 600.0;
    let centre = width / 2.0;
    let a = 1.0;
    let b = 20.0;
    let mut theta = 0.0;
    let mut count = 0;
    while theta < stop {
        let r = a + b * theta;
        let x = r * cosApprox(theta);
        let y = r * sinApprox(theta);
        if count % 100 == 0 {
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", centre + x.to_string(), ","), centre - y.to_string()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        }
        theta += degreesIncr;
        count += 1;
    }
}
