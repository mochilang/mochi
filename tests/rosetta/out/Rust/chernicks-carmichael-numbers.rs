// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn isPrime(n: i32) -> bool {
        if n < 2 {
            return false;
        }
        if n % 2 == 0 {
            return n == 2;
        }
        if n % 3 == 0 {
            return n == 3;
        }
        let mut d = 5;
        while d * d <= n {
            if n % d == 0 {
                return false;
            }
            d += 2;
            if n % d == 0 {
                return false;
            }
            d += 4;
        }
        return true;
    }
    fn bigTrim(a: &mut Vec<i32>) -> Vec<i32> {
        let mut n = a.len() as i32;
        while n > 1 && a[n - 1 as usize] == 0 {
            a = a[0 as usize..n - 1 as usize].to_vec();
            n -= 1;
        }
        return a;
    }
    fn bigFromInt(x: i32) -> Vec<i32> {
        if x == 0 {
            return vec![0];
        }
        let mut digits: Vec<i32> = vec![];
        let mut n = x;
        while n > 0 {
            digits = { let mut tmp = digits.clone(); tmp.push(n % 10); tmp };
            n /= 10;
        }
        return digits;
    }
    fn bigMulSmall(a: Vec<i32>, m: i32) -> Vec<i32> {
        if m == 0 {
            return vec![0];
        }
        let mut res: Vec<i32> = vec![];
        let mut carry = 0;
        let mut i = 0;
        while i < a.len() as i32 {
            let mut prod = a[i as usize] * m + carry;
            res = { let mut tmp = res.clone(); tmp.push(prod % 10); tmp };
            carry = (prod as f64) / (10 as f64);
            i += 1;
        }
        while carry > 0 {
            res = { let mut tmp = res.clone(); tmp.push(carry % 10); tmp };
            carry /= 10;
        }
        return bigTrim(&mut res);
    }
    fn bigToString(a: Vec<i32>) -> &'static str {
        let mut s = String::new();
        let mut i = a.len() as i32 - 1;
        while i >= 0 {
            s += a[i as usize].to_string();
            i -= 1;
        }
        return s;
    }
    fn pow2(k: i32) -> i32 {
        let mut r = 1;
        let mut i = 0;
        while i < k {
            r *= 2;
            i += 1;
        }
        return r;
    }
    fn ccFactors(n: i32, m: i32) -> Vec<i32> {
        let mut p = 6 * m + 1;
        if !isPrime(p) {
            return vec![];
        }
        let mut prod = bigFromInt(p);
        p = 12 * m + 1;
        if !isPrime(p) {
            return vec![];
        }
        prod = bigMulSmall(prod, p);
        let mut i = 1;
        while i <= n - 2 {
            p = (pow2(i) * 9 * m) + 1;
            if !isPrime(p) {
                return vec![];
            }
            prod = bigMulSmall(prod, p);
            i += 1;
        }
        return prod;
    }
    fn ccNumbers(start: i32, end: i32) -> () {
        let mut n = start;
        while n <= end {
            let mut m = 1;
            if n > 4 {
                m = pow2(n - 4);
            }
            while true {
                let num = ccFactors(n, m);
                if num.len() as i32 > 0 {
                    println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", "a(", n.to_string()), ") = "), bigToString(num)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
                    break;
                }
                if n <= 4 {
                    m += 1;
                } else {
                    m += pow2(n - 4);
                }
            }
            n += 1;
        }
    }
    ccNumbers(3, 9);
}
