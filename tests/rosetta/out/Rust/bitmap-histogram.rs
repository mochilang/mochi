// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:51Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn image() -> Vec<Vec<i32>> {
        return vec![vec![0, 0, 10000], vec![65535, 65535, 65535], vec![65535, 65535, 65535]];
    }
    fn histogram(g: Vec<Vec<i32>>, bins: &mut i32) -> Vec<i32> {
        if bins <= 0 {
            bins = g[0].len() as i32;
        }
        let mut h: Vec<i32> = vec![];
        let mut i = 0;
        while i < bins {
            h = append(h, 0);
            i += 1;
        }
        let mut y = 0;
        while y < g.len() as i32 {
            let mut row = g[y as usize];
            let mut x = 0;
            while x < row.len() as i32 {
                let mut p = row[x as usize];
                let mut idx = (((p * (bins - 1)) as f64) / (65535 as f64)).parse::<i32>().unwrap();
                h[idx as usize] = h[idx as usize] + 1;
                x += 1;
            }
            y += 1;
        }
        return h;
    }
    fn medianThreshold(h: Vec<i32>) -> i32 {
        let mut lb = 0;
        let mut ub = h.len() as i32 - 1;
        let mut lSum = 0;
        let mut uSum = 0;
        while lb <= ub {
            if lSum + h[lb as usize] < uSum + h[ub as usize] {
                lSum += h[lb as usize];
                lb += 1;
            } else {
                uSum += h[ub as usize];
                ub -= 1;
            }
        }
        return (((ub * 65535) as f64) / (h.len() as i32 as f64)).parse::<i32>().unwrap();
    }
    fn threshold(g: Vec<Vec<i32>>, t: i32) -> Vec<Vec<i32>> {
        let mut out: Vec<Vec<i32>> = vec![];
        let mut y = 0;
        while y < g.len() as i32 {
            let mut row = g[y as usize];
            let mut newRow: Vec<i32> = vec![];
            let mut x = 0;
            while x < row.len() as i32 {
                if row[x as usize] < t {
                    newRow = append(newRow, 0);
                } else {
                    newRow = append(newRow, 65535);
                }
                x += 1;
            }
            out = append(out, newRow);
            y += 1;
        }
        return out;
    }
    fn printImage(g: Vec<Vec<i32>>) -> () {
        let mut y = 0;
        while y < g.len() as i32 {
            let mut row = g[y as usize];
            let mut line = "";
            let mut x = 0;
            while x < row.len() as i32 {
                if row[x as usize] == 0 {
                    line += "0";
                } else {
                    line += "1";
                }
                x += 1;
            }
            println!("{}", line);
            y += 1;
        }
    }
    fn main() -> () {
        let img = image();
        let h = histogram(img, &mut 0);
        println!("{}", format!("{}{}", "Histogram: ", h.to_string()));
        let t = medianThreshold(h);
        println!("{}", format!("{}{}", "Threshold: ", t.to_string()));
        let bw = threshold(img, t);
        printImage(bw);
    }
    main();
}
