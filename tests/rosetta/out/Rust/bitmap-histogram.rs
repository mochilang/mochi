// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn image() -> Vec<Vec<i32>> {
        return vec![vec![0, 0, 10000], vec![65535, 65535, 65535], vec![65535, 65535, 65535]];
    }
    fn histogram(g: Vec<Vec<i32>>, bins: &mut i32) -> Vec<i32> {
        if bins <= 0 {
            bins = g[0].len() as i32;
        }
        let mut h: Vec<i32> = vec![];
        let mut i = 0;
        while i < bins {
            h = { let mut tmp = h.clone(); tmp.push(0); tmp };
            i += 1;
        }
        let mut y = 0;
        while y < g.len() as i32 {
            let mut row = g[y as usize];
            let mut x = 0;
            while x < row.len() as i32 {
                let mut p = row[x as usize];
                let mut idx = (((p * (bins - 1)) as f64) / (65535 as f64)).parse::<i32>().unwrap();
                h[idx as usize] = h[idx as usize] + 1;
                x += 1;
            }
            y += 1;
        }
        return h;
    }
    fn medianThreshold(h: Vec<i32>) -> i32 {
        let mut lb = 0;
        let mut ub = h.len() as i32 - 1;
        let mut lSum = 0;
        let mut uSum = 0;
        while lb <= ub {
            if lSum + h[lb as usize] < uSum + h[ub as usize] {
                lSum += h[lb as usize];
                lb += 1;
            } else {
                uSum += h[ub as usize];
                ub -= 1;
            }
        }
        return (((ub * 65535) as f64) / (h.len() as i32 as f64)).parse::<i32>().unwrap();
    }
    fn threshold(g: Vec<Vec<i32>>, t: i32) -> Vec<Vec<i32>> {
        let mut out: Vec<Vec<i32>> = vec![];
        let mut y = 0;
        while y < g.len() as i32 {
            let mut row = g[y as usize];
            let mut newRow: Vec<i32> = vec![];
            let mut x = 0;
            while x < row.len() as i32 {
                if row[x as usize] < t {
                    newRow = { let mut tmp = newRow.clone(); tmp.push(0); tmp };
                } else {
                    newRow = { let mut tmp = newRow.clone(); tmp.push(65535); tmp };
                }
                x += 1;
            }
            out = { let mut tmp = out.clone(); tmp.push(newRow); tmp };
            y += 1;
        }
        return out;
    }
    fn printImage(g: Vec<Vec<i32>>) -> () {
        let mut y = 0;
        while y < g.len() as i32 {
            let mut row = g[y as usize];
            let mut line = String::new();
            let mut x = 0;
            while x < row.len() as i32 {
                if row[x as usize] == 0 {
                    line += "0";
                } else {
                    line += "1";
                }
                x += 1;
            }
            println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            y += 1;
        }
    }
    fn main() -> () {
        let img = image();
        let h = histogram(img, &mut 0);
        println!("{}", vec![format!("{}", format!("{}{}", "Histogram: ", h.to_string()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        let t = medianThreshold(h);
        println!("{}", vec![format!("{}", format!("{}{}", "Threshold: ", t.to_string()))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        let bw = threshold(img, t);
        printImage(bw);
    }
    main();
}
