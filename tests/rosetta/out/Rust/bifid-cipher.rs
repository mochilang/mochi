// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:50Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn square_to_maps(square: Vec<Vec<&'static str>>) -> std::collections::HashMap<&'static str, i32> {
        let mut emap: std::collections::HashMap<&'static str, Vec<i32>> = { let mut m = std::collections::BTreeMap::new(); m };
        let mut dmap: std::collections::HashMap<&'static str, &'static str> = { let mut m = std::collections::BTreeMap::new(); m };
        let mut x = 0;
        while x < square.len() as i32 {
            let row = square[x as usize];
            let mut y = 0;
            while y < row.len() as i32 {
                let ch = row[y as usize];
                emap.insert(ch, vec![x, y]);
                dmap.insert(format!("{}{}", format!("{}{}", x.to_string(), ","), y.to_string()), ch);
                y += 1;
            }
            x += 1;
        }
        return { let mut m = std::collections::BTreeMap::new(); m.insert("e", emap); m.insert("d", dmap); m };
    }
    fn remove_space(text: &'static str, emap: std::collections::HashMap<&'static str, Vec<i32>>) -> &'static str {
        let s = upper(text);
        let mut out = "";
        let mut i = 0;
        while i < s.len() as i32 {
            let ch = &s[i as usize..i + 1 as usize];
            if emap.contains_key(&ch != " " && ch) {
                out += ch;
            }
            i += 1;
        }
        return out;
    }
    fn encrypt(text: &mut &'static str, emap: std::collections::HashMap<&'static str, Vec<i32>>, dmap: std::collections::HashMap<&'static str, &'static str>) -> &'static str {
        text = remove_space(text, emap);
        let mut row0: Vec<i32> = vec![];
        let mut row1: Vec<i32> = vec![];
        let mut i = 0;
        while i < text.len() as i32 {
            let ch = &text[i as usize..i + 1 as usize];
            let xy = emap[&ch];
            row0 = append(row0, xy[0]);
            row1 = append(row1, xy[1]);
            i += 1;
        }
        for v in row1 {
            row0 = append(row0, v);
        }
        let mut res = "";
        let mut j = 0;
        while j < row0.len() as i32 {
            let key = format!("{}{}", format!("{}{}", row0[j as usize].to_string(), ","), row0[j + 1 as usize].to_string());
            res += dmap[&key];
            j += 2;
        }
        return res;
    }
    fn decrypt(text: &mut &'static str, emap: std::collections::HashMap<&'static str, Vec<i32>>, dmap: std::collections::HashMap<&'static str, &'static str>) -> &'static str {
        text = remove_space(text, emap);
        let mut coords: Vec<i32> = vec![];
        let mut i = 0;
        while i < text.len() as i32 {
            let ch = &text[i as usize..i + 1 as usize];
            let xy = emap[&ch];
            coords = append(coords, xy[0]);
            coords = append(coords, xy[1]);
            i += 1;
        }
        let mut half = (coords.len() as i32 as f64) / (2 as f64);
        let mut k1: Vec<i32> = vec![];
        let mut k2: Vec<i32> = vec![];
        let mut idx = 0;
        while (idx as f64) < half {
            k1 = append(k1, coords[idx as usize]);
            idx += 1;
        }
        while idx < coords.len() as i32 {
            k2 = append(k2, coords[idx as usize]);
            idx += 1;
        }
        let mut res = "";
        let mut j = 0;
        while (j as f64) < half {
            let key = format!("{}{}", format!("{}{}", k1[j as usize].to_string(), ","), k2[j as usize].to_string());
            res += dmap[&key];
            j += 1;
        }
        return res;
    }
    fn main() -> () {
        let squareRosetta = vec![vec!["A", "B", "C", "D", "E"], vec!["F", "G", "H", "I", "K"], vec!["L", "M", "N", "O", "P"], vec!["Q", "R", "S", "T", "U"], vec!["V", "W", "X", "Y", "Z"], vec!["J", "1", "2", "3", "4"]];
        let squareWikipedia = vec![vec!["B", "G", "W", "K", "Z"], vec!["Q", "P", "N", "D", "S"], vec!["I", "O", "A", "X", "E"], vec!["F", "C", "L", "U", "M"], vec!["T", "H", "Y", "V", "R"], vec!["J", "1", "2", "3", "4"]];
        let textRosetta = "0ATTACKATDAWN";
        let textWikipedia = "FLEEATONCE";
        let textTest = "The invasion will start on the first of January";
        let mut maps = square_to_maps(squareRosetta);
        let mut emap = maps[&"e"];
        let mut dmap = maps[&"d"];
        println!("from Rosettacode");
        println!("{}", format!("{}{}", "original:	 ", textRosetta));
        let mut s = encrypt(&mut textRosetta, emap, dmap);
        println!("{}", format!("{}{}", "codiert:	 ", s));
        s = decrypt(&mut s, emap, dmap);
        println!("{}", format!("{}{}", "and back:	 ", s));
        maps = square_to_maps(squareWikipedia);
        emap = maps[&"e"];
        dmap = maps[&"d"];
        println!("from Wikipedia");
        println!("{}", format!("{}{}", "original:	 ", textWikipedia));
        s = encrypt(&mut textWikipedia, emap, dmap);
        println!("{}", format!("{}{}", "codiert:	 ", s));
        s = decrypt(&mut s, emap, dmap);
        println!("{}", format!("{}{}", "and back:	 ", s));
        maps = square_to_maps(squareWikipedia);
        emap = maps[&"e"];
        dmap = maps[&"d"];
        println!("from Rosettacode long part");
        println!("{}", format!("{}{}", "original:	 ", textTest));
        s = encrypt(&mut textTest, emap, dmap);
        println!("{}", format!("{}{}", "codiert:	 ", s));
        s = decrypt(&mut s, emap, dmap);
        println!("{}", format!("{}{}", "and back:	 ", s));
    }
    main();
}
