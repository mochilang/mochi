// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn square_to_maps(square: Vec<Vec<&'static str>>) -> std::collections::HashMap<&'static str, i32> {
        let mut emap: std::collections::HashMap<&'static str, Vec<i32>> = { let mut m = std::collections::BTreeMap::new(); m };
        let mut dmap: std::collections::HashMap<&'static str, &'static str> = { let mut m = std::collections::BTreeMap::new(); m };
        let mut x = 0;
        while x < square.len() as i32 {
            let row = square[x as usize];
            let mut y = 0;
            while y < row.len() as i32 {
                let ch = row[y as usize];
                emap.insert(ch, vec![x, y]);
                dmap.insert(format!("{}{}", format!("{}{}", x.to_string(), ","), y.to_string()), ch);
                y += 1;
            }
            x += 1;
        }
        return { let mut m = std::collections::BTreeMap::new(); m.insert("e", emap); m.insert("d", dmap); m };
    }
    fn remove_space(text: &'static str, emap: std::collections::HashMap<&'static str, Vec<i32>>) -> &'static str {
        let s = upper(text);
        let mut out = String::new();
        let mut i = 0;
        while i < s.len() as i32 {
            let ch = &s[i as usize..i + 1 as usize];
            if emap.contains_key(&ch != " " && ch) {
                out += ch;
            }
            i += 1;
        }
        return out;
    }
    fn encrypt(text: &mut &'static str, emap: std::collections::HashMap<&'static str, Vec<i32>>, dmap: std::collections::HashMap<&'static str, &'static str>) -> &'static str {
        text = remove_space(text, emap);
        let mut row0: Vec<i32> = vec![];
        let mut row1: Vec<i32> = vec![];
        let mut i = 0;
        while i < text.len() as i32 {
            let ch = &text[i as usize..i + 1 as usize];
            let xy = *emap.get(&ch).unwrap();
            row0 = { let mut tmp = row0.clone(); tmp.push(xy[0]); tmp };
            row1 = { let mut tmp = row1.clone(); tmp.push(xy[1]); tmp };
            i += 1;
        }
        for v in row1 {
            row0 = { let mut tmp = row0.clone(); tmp.push(v); tmp };
        }
        let mut res = String::new();
        let mut j = 0;
        while j < row0.len() as i32 {
            let key = format!("{}{}", format!("{}{}", row0[j as usize].to_string(), ","), row0[j + 1 as usize].to_string());
            res += *dmap.get(&key).unwrap();
            j += 2;
        }
        return res;
    }
    fn decrypt(text: &mut &'static str, emap: std::collections::HashMap<&'static str, Vec<i32>>, dmap: std::collections::HashMap<&'static str, &'static str>) -> &'static str {
        text = remove_space(text, emap);
        let mut coords: Vec<i32> = vec![];
        let mut i = 0;
        while i < text.len() as i32 {
            let ch = &text[i as usize..i + 1 as usize];
            let xy = *emap.get(&ch).unwrap();
            coords = { let mut tmp = coords.clone(); tmp.push(xy[0]); tmp };
            coords = { let mut tmp = coords.clone(); tmp.push(xy[1]); tmp };
            i += 1;
        }
        let mut half = (coords.len() as i32 as f64) / (2 as f64);
        let mut k1: Vec<i32> = vec![];
        let mut k2: Vec<i32> = vec![];
        let mut idx = 0;
        while (idx as f64) < half {
            k1 = { let mut tmp = k1.clone(); tmp.push(coords[idx as usize]); tmp };
            idx += 1;
        }
        while idx < coords.len() as i32 {
            k2 = { let mut tmp = k2.clone(); tmp.push(coords[idx as usize]); tmp };
            idx += 1;
        }
        let mut res = String::new();
        let mut j = 0;
        while (j as f64) < half {
            let key = format!("{}{}", format!("{}{}", k1[j as usize].to_string(), ","), k2[j as usize].to_string());
            res += *dmap.get(&key).unwrap();
            j += 1;
        }
        return res;
    }
    fn main() -> () {
        let squareRosetta = vec![vec!["A", "B", "C", "D", "E"], vec!["F", "G", "H", "I", "K"], vec!["L", "M", "N", "O", "P"], vec!["Q", "R", "S", "T", "U"], vec!["V", "W", "X", "Y", "Z"], vec!["J", "1", "2", "3", "4"]];
        let squareWikipedia = vec![vec!["B", "G", "W", "K", "Z"], vec!["Q", "P", "N", "D", "S"], vec!["I", "O", "A", "X", "E"], vec!["F", "C", "L", "U", "M"], vec!["T", "H", "Y", "V", "R"], vec!["J", "1", "2", "3", "4"]];
        let textRosetta = "0ATTACKATDAWN";
        let textWikipedia = "FLEEATONCE";
        let textTest = "The invasion will start on the first of January";
        let mut maps = square_to_maps(squareRosetta);
        let mut emap = *maps.get(&"e").unwrap();
        let mut dmap = *maps.get(&"d").unwrap();
        println!("from Rosettacode");
        println!("{}", vec![format!("{}", format!("{}{}", "original:	 ", textRosetta))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        let mut s = encrypt(&mut textRosetta, emap, dmap);
        println!("{}", vec![format!("{}", format!("{}{}", "codiert:	 ", s))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        s = decrypt(&mut s, emap, dmap);
        println!("{}", vec![format!("{}", format!("{}{}", "and back:	 ", s))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        maps = square_to_maps(squareWikipedia);
        emap = *maps.get(&"e").unwrap();
        dmap = *maps.get(&"d").unwrap();
        println!("from Wikipedia");
        println!("{}", vec![format!("{}", format!("{}{}", "original:	 ", textWikipedia))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        s = encrypt(&mut textWikipedia, emap, dmap);
        println!("{}", vec![format!("{}", format!("{}{}", "codiert:	 ", s))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        s = decrypt(&mut s, emap, dmap);
        println!("{}", vec![format!("{}", format!("{}{}", "and back:	 ", s))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        maps = square_to_maps(squareWikipedia);
        emap = *maps.get(&"e").unwrap();
        dmap = *maps.get(&"d").unwrap();
        println!("from Rosettacode long part");
        println!("{}", vec![format!("{}", format!("{}{}", "original:	 ", textTest))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        s = encrypt(&mut textTest, emap, dmap);
        println!("{}", vec![format!("{}", format!("{}{}", "codiert:	 ", s))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        s = decrypt(&mut s, emap, dmap);
        println!("{}", vec![format!("{}", format!("{}{}", "and back:	 ", s))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    }
    main();
}
