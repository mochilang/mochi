// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:46Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn padLeft(s: &'static str, w: i32) -> &'static str {
        let mut res = "";
        let mut n = w - s.len() as i32;
        while n > 0 {
            res += " ";
            n -= 1;
        }
        return format!("{}{}", res, s);
    }
    fn indexOfFrom(s: &'static str, ch: &'static str, start: i32) -> i32 {
        let mut i = start;
        while i < s.len() as i32 {
            if &s[i as usize..i + 1 as usize] == ch {
                return i;
            }
            i += 1;
        }
        return -1;
    }
    fn containsStr(s: &'static str, sub: &'static str) -> bool {
        let mut i = 0;
        let sl = s.len() as i32;
        let subl = sub.len() as i32;
        while i <= sl - subl {
            if &s[i as usize..i + subl as usize] == sub {
                return true;
            }
            i += 1;
        }
        return false;
    }
    fn distinct(slist: Vec<&'static str>) -> Vec<&'static str> {
        let mut res: Vec<&'static str> = vec![];
        for s in slist {
            let mut found = false;
            for r in res {
                if r == s {
                    found = true;
                    break;
                }
            }
            if !found {
                res = append(res, s);
            }
        }
        return res;
    }
    fn permutations(xs: Vec<&'static str>) -> Vec<Vec<&'static str>> {
        if xs.len() as i32 <= 1 {
            return vec![xs];
        }
        let mut res: Vec<Vec<&'static str>> = vec![];
        let mut i = 0;
        while i < xs.len() as i32 {
            let mut rest: Vec<&'static str> = vec![];
            let mut j = 0;
            while j < xs.len() as i32 {
                if j != i {
                    rest = append(rest, xs[j as usize]);
                }
                j += 1;
            }
            let subs = permutations(rest);
            for p in subs {
                let mut perm: Vec<&'static str> = vec![xs[i as usize]];
                let mut k = 0;
                while k < p.len() as i32 {
                    perm = append(perm, p[k as usize]);
                    k += 1;
                }
                res = append(res, perm);
            }
            i += 1;
        }
        return res;
    }
    fn headTailOverlap(s1: &'static str, s2: &'static str) -> i32 {
        let mut start = 0;
        while true {
            let ix = indexOfFrom(s1, &s2[0..1], start);
            if ix == 0 - 1 {
                return 0;
            }
            start = ix;
            if &s2[0 as usize..s1.len() as i32 - start as usize] == &s1[start as usize..s1.len() as i32 as usize] {
                return s1.len() as i32 - start;
            }
            start += 1;
        }
    }
    fn deduplicate(slist: Vec<&'static str>) -> Vec<&'static str> {
        let arr = distinct(slist);
        let mut filtered: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < arr.len() as i32 {
            let s1 = arr[i as usize];
            let mut within = false;
            let mut j = 0;
            while j < arr.len() as i32 {
                if j != i && containsStr(arr[j as usize], s1) {
                    within = true;
                    break;
                }
                j += 1;
            }
            if !within {
                filtered = append(filtered, s1);
            }
            i += 1;
        }
        return filtered;
    }
    fn joinAll(ss: Vec<&'static str>) -> &'static str {
        let mut out = "";
        for s in ss {
            out += s;
        }
        return out;
    }
    fn shortestCommonSuperstring(slist: Vec<&'static str>) -> &'static str {
        let ss = deduplicate(slist);
        let mut shortest = joinAll(ss);
        let perms = permutations(ss);
        let mut idx = 0;
        while idx < perms.len() as i32 {
            let perm = perms[idx as usize];
            let mut sup = perm[0];
            let mut i = 0;
            while i < ss.len() as i32 - 1 {
                let ov = headTailOverlap(perm[i as usize], perm[i + 1 as usize]);
                sup += &perm[i + 1 as usize][ov as usize..perm[i + 1 as usize].len() as i32 as usize];
                i += 1;
            }
            if sup.len() as i32 < shortest.len() as i32 {
                shortest = sup;
            }
            idx += 1;
        }
        return shortest;
    }
    fn printCounts(seq: &'static str) -> () {
        let mut a = 0;
        let mut c = 0;
        let mut g = 0;
        let mut t = 0;
        let mut i = 0;
        while i < seq.len() as i32 {
            let ch = &seq[i as usize..i + 1 as usize];
            if ch == "A" {
                a += 1;
            } else {
                if ch == "C" {
                    c += 1;
                } else {
                    if ch == "G" {
                        g += 1;
                    } else {
                        if ch == "T" {
                            t += 1;
                        }
                    }
                }
            }
            i += 1;
        }
        let total = seq.len() as i32;
        println!("{}", format!("{}{}", format!("{}{}", "
Nucleotide counts for ", seq), ":
"));
        println!("{}", format!("{}{}", padLeft("A", 10), padLeft(a.to_string(), 12)));
        println!("{}", format!("{}{}", padLeft("C", 10), padLeft(c.to_string(), 12)));
        println!("{}", format!("{}{}", padLeft("G", 10), padLeft(g.to_string(), 12)));
        println!("{}", format!("{}{}", padLeft("T", 10), padLeft(t.to_string(), 12)));
        println!("{}", format!("{}{}", padLeft("Other", 10), padLeft(total - (a + c + g + t).to_string(), 12)));
        println!("  ____________________");
        println!("{}", format!("{}{}", padLeft("Total length", 14), padLeft(total.to_string(), 8)));
    }
    fn main() -> () {
        let tests: Vec<Vec<&'static str>> = vec![vec!["TA", "AAG", "TA", "GAA", "TA"], vec!["CATTAGGG", "ATTAG", "GGG", "TA"], vec!["AAGAUGGA", "GGAGCGCAUC", "AUCGCAAUAAGGA"], vec!["ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT", "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT", "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC", "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC", "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT", "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"]];
        for seqs in tests {
            let scs = shortestCommonSuperstring(seqs);
            printCounts(scs);
        }
    }
    main();
}
