// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    let epsilon = 1e-15;
    fn absf(x: f64) -> f64 {
        if x < 0.0 {
            return -x;
        }
        return x;
    }
    fn pow10(n: i32) -> f64 {
        let mut r: f64 = 1.0;
        let mut i = 0;
        while i < n {
            r *= 10.0;
            i += 1;
        }
        return r;
    }
    fn formatFloat(f: f64, prec: i32) -> &'static str {
        let scale = pow10(prec);
        let scaled = (f * scale) + 0.5;
        let mut n = (scaled.parse::<i32>().unwrap());
        let mut digits = n.to_string();
        while digits.len() as i32 <= prec {
            digits = format!("{}{}", "0", digits);
        }
        let intPart = &digits[0 as usize..digits.len() as i32 - prec as usize];
        let fracPart = &digits[digits.len() as i32 - prec as usize..digits.len() as i32 as usize];
        return format!("{}{}", format!("{}{}", intPart, "."), fracPart);
    }
    let mut factval = 1;
    let mut e: f64 = 2.0;
    let mut n = 2;
    let mut term: f64 = 1.0;
    while true {
        factval *= n;
        n += 1;
        term = 1.0 / (factval.parse::<f64>().unwrap());
        e += term;
        if absf(term) < epsilon {
            break;
        }
    }
    println!("{}", vec![format!("{}", format!("{}{}", "e = ", formatFloat(e, 15)))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
}
