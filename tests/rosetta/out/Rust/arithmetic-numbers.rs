// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn sieve(limit: i32) -> Vec<i32> {
        let mut spf: Vec<i32> = vec![];
        let mut i = 0;
        while i <= limit {
            spf = { let mut tmp = spf.clone(); tmp.push(0); tmp };
            i += 1;
        }
        i = 2;
        while i <= limit {
            if spf[i as usize] == 0 {
                spf[i as usize] = i;
                if i * i <= limit {
                    let mut j = i * i;
                    while j <= limit {
                        if spf[j as usize] == 0 {
                            spf[j as usize] = i;
                        }
                        j += i;
                    }
                }
            }
            i += 1;
        }
        return spf;
    }
    fn primesFrom(spf: Vec<i32>, limit: i32) -> Vec<i32> {
        let mut primes: Vec<i32> = vec![];
        let mut i = 3;
        while i <= limit {
            if spf[i as usize] == i {
                primes = { let mut tmp = primes.clone(); tmp.push(i); tmp };
            }
            i += 1;
        }
        return primes;
    }
    fn pad3(n: i32) -> &'static str {
        let mut s = n.to_string();
        while s.len() as i32 < 3 {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn commatize(n: i32) -> &'static str {
        let mut s = n.to_string();
        let mut out = String::new();
        let mut i = s.len() as i32 - 1;
        let mut c = 0;
        while i >= 0 {
            out = format!("{}{}", &s[i as usize..i + 1 as usize], out);
            c += 1;
            if c % 3 == 0 && i > 0 {
                out = format!("{}{}", ",", out);
            }
            i -= 1;
        }
        return out;
    }
    fn primeCount(primes: Vec<i32>, last: i32, spf: Vec<i32>) -> i32 {
        let mut lo = 0;
        let mut hi = primes.len() as i32;
        while lo < hi {
            let mut mid = (((lo + hi) as f64) / (2 as f64)).parse::<i32>().unwrap();
            if primes[mid as usize] < last {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        let mut count = lo + 1;
        if spf[last as usize] != last {
            count -= 1;
        }
        return count;
    }
    fn arithmeticNumbers(limit: i32, spf: Vec<i32>) -> Vec<i32> {
        let mut arr: Vec<i32> = vec![1];
        let mut n = 3;
        while arr.len() as i32 < limit {
            if spf[n as usize] == n {
                arr = { let mut tmp = arr.clone(); tmp.push(n); tmp };
            } else {
                let mut x = n;
                let mut sigma = 1;
                let mut tau = 1;
                while x > 1 {
                    let mut p = spf[x as usize];
                    if p == 0 {
                        p = x;
                    }
                    let mut cnt = 0;
                    let mut power = p;
                    let mut sum = 1;
                    while x % p == 0 {
                        x /= p;
                        cnt += 1;
                        sum += power;
                        power *= p;
                    }
                    sigma *= sum;
                    tau *= (cnt + 1);
                }
                if sigma % tau == 0 {
                    arr = { let mut tmp = arr.clone(); tmp.push(n); tmp };
                }
            }
            n += 1;
        }
        return arr;
    }
    fn main() -> () {
        let limit = 1228663;
        let spf = sieve(limit);
        let primes = primesFrom(spf, limit);
        let arr = arithmeticNumbers(1000000, spf);
        println!("The first 100 arithmetic numbers are:");
        let mut i = 0;
        while i < 100 {
            let mut line = String::new();
            let mut j = 0;
            while j < 10 {
                line += pad3(arr[i + j as usize]);
                if j < 9 {
                    line += " ";
                }
                j += 1;
            }
            println!("{}", vec![format!("{}", line)].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            i += 10;
        }
        for x in vec![1000, 10000, 100000, 1000000] {
            let last = arr[(x as f64) - 1 as f64 as usize];
            let lastc = commatize(last);
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", "
The ", commatize(x)), "th arithmetic number is: "), lastc))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
            let pc = primeCount(primes, last, spf);
            let comp = (x as f64) - pc as f64 - 1;
            println!("{}", vec![format!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "The count of such numbers <= ", lastc), " which are composite is "), commatize(comp)), "."))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
        }
    }
    main();
}
