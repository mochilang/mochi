// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:56Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn split(s: &'static str, sep: &'static str) -> Vec<&'static str> {
        let mut parts: Vec<&'static str> = vec![];
        let mut cur = "";
        let mut i = 0;
        while i < s.len() as i32 {
            if sep.len() as i32 > 0 && i + sep.len() as i32 <= s.len() as i32 && &s[i as usize..i + sep.len() as i32 as usize] == sep {
                parts = append(parts, cur);
                cur = "";
                i += sep.len() as i32;
            } else {
                cur += &s[i as usize..i + 1 as usize];
                i += 1;
            }
        }
        parts = append(parts, cur);
        return parts;
    }
    fn join(xs: Vec<&'static str>, sep: &'static str) -> &'static str {
        let mut res = "";
        let mut i = 0;
        while i < xs.len() as i32 {
            if i > 0 {
                res += sep;
            }
            res += xs[i as usize];
            i += 1;
        }
        return res;
    }
    fn repeat(ch: &'static str, n: i32) -> &'static str {
        let mut out = "";
        let mut i = 0;
        while i < n {
            out += ch;
            i += 1;
        }
        return out;
    }
    fn parseIntStr(str: &'static str) -> i32 {
        let mut i = 0;
        let mut neg = false;
        if str.len() as i32 > 0 && &str[0..1] == "-" {
            neg = true;
            i = 1;
        }
        let mut n = 0;
        let digits = { let mut m = std::collections::BTreeMap::new(); m.insert("0", 0); m.insert("1", 1); m.insert("2", 2); m.insert("3", 3); m.insert("4", 4); m.insert("5", 5); m.insert("6", 6); m.insert("7", 7); m.insert("8", 8); m.insert("9", 9); m };
        while i < str.len() as i32 {
            n = n * 10 + digits[&&str[i as usize..i + 1 as usize]];
            i += 1;
        }
        if neg {
            n = -n;
        }
        return n;
    }
    fn toBinary(n: i32, bits: i32) -> &'static str {
        let mut b = "";
        let mut val = n;
        let mut i = 0;
        while i < bits {
            b = format!("{}{}", val % 2.to_string(), b);
            val = ((val as f64) / (2 as f64)).parse::<i32>().unwrap();
            i += 1;
        }
        return b;
    }
    fn binToInt(bits: &'static str) -> i32 {
        let mut n = 0;
        let mut i = 0;
        while i < bits.len() as i32 {
            n = n * 2 + parseIntStr(&bits[i as usize..i + 1 as usize]);
            i += 1;
        }
        return n;
    }
    fn padRight(s: &'static str, width: i32) -> &'static str {
        let mut out = s;
        while out.len() as i32 < width {
            out += " ";
        }
        return out;
    }
    fn canonicalize(cidr: &'static str) -> &'static str {
        let parts = split(cidr, "/");
        let dotted = parts[0];
        let size = parseIntStr(parts[1]);
        let mut binParts: Vec<&'static str> = vec![];
        for p in split(dotted, ".") {
            binParts = append(binParts, toBinary(parseIntStr(p), 8));
        }
        let mut binary = join(binParts, "");
        binary = format!("{}{}", &binary[0 as usize..size as usize], repeat("0", 32 - size));
        let mut canonParts: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < binary.len() as i32 {
            canonParts = append(canonParts, binToInt(&binary[i as usize..i + 8 as usize]).to_string());
            i += 8;
        }
        return format!("{}{}", format!("{}{}", join(canonParts, "."), "/"), parts[1]);
    }
    let tests = vec!["87.70.141.1/22", "36.18.154.103/12", "62.62.197.11/29", "67.137.119.181/4", "161.214.74.21/24", "184.232.176.184/18"];
    for t in tests {
        println!("{}", format!("{}{}", format!("{}{}", padRight(t, 18), " -> "), canonicalize(t)));
    }
}
