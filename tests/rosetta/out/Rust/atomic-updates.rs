// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:36:42Z
fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn randOrder(seed: i32, n: i32) -> Vec<i32> {
        let next = (seed * 1664525 + 1013904223) % 2147483647;
        return vec![next, next % n];
    }
    fn randChaos(seed: i32, n: i32) -> Vec<i32> {
        let next = (seed * 1103515245 + 12345) % 2147483647;
        return vec![next, next % n];
    }
    fn main() -> () {
        let nBuckets = 10;
        let initialSum = 1000;
        let mut buckets: Vec<i32> = vec![];
        for i in 0..nBuckets {
            buckets = append(buckets, 0);
        }
        let mut i = nBuckets;
        let mut dist = initialSum;
        while i > 0 {
            let v = (dist as f64) / (i as f64);
            i -= 1;
            buckets[i as usize] = v;
            dist -= v;
        }
        let mut tc0 = 0;
        let mut tc1 = 0;
        let mut total = 0;
        let mut nTicks = 0;
        let mut seedOrder = 1;
        let mut seedChaos = 2;
        println!("sum  ---updates---    mean  buckets");
        let mut t = 0;
        while t < 5 {
            let mut r = randOrder(seedOrder, nBuckets);
            seedOrder = r[0];
            let mut b1 = r[1];
            let mut b2 = (b1 + 1) % nBuckets;
            let v1 = buckets[b1 as usize];
            let v2 = buckets[b2 as usize];
            if v1 > v2 {
                let mut a = (((v1 - v2) as f64) / (2 as f64)).parse::<i32>().unwrap();
                if a > buckets[b1 as usize] {
                    a = buckets[b1 as usize];
                }
                buckets[b1 as usize] = buckets[b1 as usize] - a;
                buckets[b2 as usize] = buckets[b2 as usize] + a;
            } else {
                let mut a = (((v2 - v1) as f64) / (2 as f64)).parse::<i32>().unwrap();
                if a > buckets[b2 as usize] {
                    a = buckets[b2 as usize];
                }
                buckets[b2 as usize] = buckets[b2 as usize] - a;
                buckets[b1 as usize] = buckets[b1 as usize] + a;
            }
            tc0 += 1;
            r = randChaos(seedChaos, nBuckets);
            seedChaos = r[0];
            b1 = r[1];
            b2 = (b1 + 1) % nBuckets;
            r = randChaos(seedChaos, buckets[b1 as usize] + 1);
            seedChaos = r[0];
            let mut amt = r[1];
            if amt > buckets[b1 as usize] {
                amt = buckets[b1 as usize];
            }
            buckets[b1 as usize] = buckets[b1 as usize] - amt;
            buckets[b2 as usize] = buckets[b2 as usize] + amt;
            tc1 += 1;
            let mut sum = 0;
            let mut idx = 0;
            while idx < nBuckets {
                sum += buckets[idx as usize];
                idx += 1;
            }
            total = total + tc0 + tc1;
            nTicks += 1;
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", sum.to_string(), " "), tc0.to_string()), " "), tc1.to_string()), " "), (total as f64) / (nTicks as f64).to_string()), "  "), buckets.to_string()));
            tc0 = 0;
            tc1 = 0;
            t += 1;
        }
    }
    main();
}
