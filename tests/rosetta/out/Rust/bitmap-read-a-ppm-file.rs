// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:39:52Z
#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Pixel {
        R: i32,
        G: i32,
        B: i32,
}

#[derive(Default, Debug, Clone, PartialEq, Eq, Hash)]
struct Bitmap {
        w: i32,
        h: i32,
        max: i32,
        data: Vec<Vec<Pixel>>,
}

fn append<T: Clone>(mut v: Vec<T>, item: T) -> Vec<T> {
    v.push(item);
    v
}

fn main() {
    fn newBitmap(w: i32, h: i32, max: i32) -> Bitmap {
        let mut rows: Vec<Vec<Pixel>> = vec![];
        let mut y = 0;
        while y < h {
            let mut row: Vec<Pixel> = vec![];
            let mut x = 0;
            while x < w {
                row = append(row, Pixel { R: 0, G: 0, B: 0 });
                x += 1;
            }
            rows = append(rows, row);
            y += 1;
        }
        return Bitmap { w: w, h: h, max: max, data: rows };
    }
    fn setPx(b: &mut Bitmap, x: i32, y: i32, p: Pixel) -> () {
        let mut rows = b.data;
        let mut row = rows[y as usize];
        row[x as usize] = p.clone();
        rows[y as usize] = row;
        b.data = rows;
    }
    fn getPx(b: Bitmap, x: i32, y: i32) -> Pixel {
        return b.data[y as usize][x as usize];
    }
    fn splitLines(s: &'static str) -> Vec<&'static str> {
        let mut out: Vec<&'static str> = vec![];
        let mut cur = "";
        let mut i = 0;
        while i < s.len() as i32 {
            let ch = substr(s, i, i + 1);
            if ch == "
" {
                out = append(out, cur);
                cur = "";
            } else {
                cur += ch;
            }
            i += 1;
        }
        out = append(out, cur);
        return out;
    }
    fn splitWS(s: &'static str) -> Vec<&'static str> {
        let mut out: Vec<&'static str> = vec![];
        let mut cur = "";
        let mut i = 0;
        while i < s.len() as i32 {
            let ch = substr(s, i, i + 1);
            if ch == " " || ch == "	" || ch == "" || ch == "
" {
                if cur.len() as i32 > 0 {
                    out = append(out, cur);
                    cur = "";
                }
            } else {
                cur += ch;
            }
            i += 1;
        }
        if cur.len() as i32 > 0 {
            out = append(out, cur);
        }
        return out;
    }
    fn parseIntStr(str: &'static str) -> i32 {
        let mut i = 0;
        let mut neg = false;
        if str.len() as i32 > 0 && &str[0..1] == "-" {
            neg = true;
            i = 1;
        }
        let mut n = 0;
        let digits = { let mut m = std::collections::BTreeMap::new(); m.insert("0", 0); m.insert("1", 1); m.insert("2", 2); m.insert("3", 3); m.insert("4", 4); m.insert("5", 5); m.insert("6", 6); m.insert("7", 7); m.insert("8", 8); m.insert("9", 9); m };
        while i < str.len() as i32 {
            n = n * 10 + digits[&&str[i as usize..i + 1 as usize]];
            i += 1;
        }
        if neg {
            n = -n;
        }
        return n;
    }
    fn tokenize(s: &'static str) -> Vec<&'static str> {
        let lines = splitLines(s);
        let mut toks: Vec<&'static str> = vec![];
        let mut i = 0;
        while i < lines.len() as i32 {
            let line = lines[i as usize];
            if line.len() as i32 > 0 && substr(line, 0, 1) == "#" {
                i += 1;
                continue;
            }
            let parts = splitWS(line);
            let mut j = 0;
            while j < parts.len() as i32 {
                toks = append(toks, parts[j as usize]);
                j += 1;
            }
            i += 1;
        }
        return toks;
    }
    fn readP3(text: &'static str) -> Bitmap {
        let toks = tokenize(text);
        if toks.len() as i32 < 4 {
            return newBitmap(0, 0, 0);
        }
        if toks[0] != "P3" {
            return newBitmap(0, 0, 0);
        }
        let w: i32 = parseIntStr(toks[1]);
        let h: i32 = parseIntStr(toks[2]);
        let maxv: i32 = parseIntStr(toks[3]);
        let mut idx = 4;
        let mut bm = newBitmap(w, h, maxv);
        let mut y = h - 1;
        while y >= 0 {
            let mut x = 0;
            while x < w {
                let r: i32 = parseIntStr(toks[idx as usize]);
                let g: i32 = parseIntStr(toks[idx + 1 as usize]);
                let b: i32 = parseIntStr(toks[idx + 2 as usize]);
                setPx(&mut bm.clone(), x, y, &Pixel { R: r, G: g, B: b });
                idx += 3;
                x += 1;
            }
            y -= 1;
        }
        return bm.clone();
    }
    fn toGrey(b: &mut Bitmap) -> () {
        let h: i32 = b.h;
        let w: i32 = b.w;
        let mut m = 0;
        let mut y = 0;
        while y < h {
            let mut x = 0;
            while x < w {
                let p = getPx(&b.clone(), x, y);
                let mut l = ((p.R * 2126 + p.G * 7152 + p.B * 722) as f64) / (10000 as f64);
                if l > b.max as f64 {
                    l = b.max;
                }
                setPx(&mut b.clone(), x, y, &Pixel { R: l, G: l, B: l });
                if l > m as f64 {
                    m = l;
                }
                x += 1;
            }
            y += 1;
        }
        b.max = m;
    }
    fn pad(n: i32, w: i32) -> &'static str {
        let mut s = n.to_string();
        while s.len() as i32 < w {
            s = format!("{}{}", " ", s);
        }
        return s;
    }
    fn writeP3(b: Bitmap) -> &'static str {
        let h: i32 = b.h;
        let w: i32 = b.w;
        let mut max = b.max;
        let digits = max.to_string().len() as i32;
        let mut out = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "P3
# generated from Bitmap.writeppmp3
", w.to_string()), " "), h.to_string()), "
"), max.to_string()), "
");
        let mut y = h - 1;
        while y >= 0 {
            let mut line = "";
            let mut x = 0;
            while x < w {
                let p = getPx(&b.clone(), x, y);
                line = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", line, "   "), pad(p.R, digits)), " "), pad(p.G, digits)), " "), pad(p.B, digits));
                x += 1;
            }
            out = format!("{}{}", format!("{}{}", out, line), "
");
            y -= 1;
        }
        return out;
    }
    let mut ppmtxt = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "P3
", "# feep.ppm
"), "4 4
"), "15
"), " 0  0  0    0  0  0    0  0  0   15  0 15
"), " 0  0  0    0 15  7    0  0  0    0  0  0
"), " 0  0  0    0  0  0    0 15  7    0  0  0
"), "15  0 15    0  0  0    0  0  0    0  0  0
");
    println!("Original Colour PPM file");
    println!("{}", ppmtxt);
    let mut bm = readP3(ppmtxt);
    println!("Grey PPM:");
    toGrey(&mut bm.clone());
    let out = writeP3(&bm.clone());
    println!("{}", out);
}
