// Generated by Mochi compiler v0.10.28 on 2006-01-02T15:04:05Z
fn main() {
    fn validComb(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32) -> bool {
        let square1 = a + b;
        let square2 = b + c + d;
        let square3 = d + e + f;
        let square4 = f + g;
        return square1 == square2 && square2 == square3 && square3 == square4;
    }
    fn isUnique(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32) -> bool {
        let mut nums = vec![a, b, c, d, e, f, g];
        let mut i = 0;
        while i < nums.len() as i32 {
            let mut j = i + 1;
            while j < nums.len() as i32 {
                if nums[i as usize] == nums[j as usize] {
                    return false;
                }
                j += 1;
            }
            i += 1;
        }
        return true;
    }
    fn getCombs(low: i32, high: i32, unique: bool) -> std::collections::HashMap<&'static str, i32> {
        let mut valid = vec![];
        let mut count = 0;
        for b in low..(high + 1) {
            for c in low..(high + 1) {
                for d in low..(high + 1) {
                    let s = b + c + d;
                    for e in low..(high + 1) {
                        for f in low..(high + 1) {
                            let a = s - b;
                            let g = s - f;
                            if a < low || a > high {
                                continue;
                            }
                            if g < low || g > high {
                                continue;
                            }
                            if d + e + f != s {
                                continue;
                            }
                            if f + g != s {
                                continue;
                            }
                            if !unique || isUnique(a, b, c, d, e, f, g) {
                                valid = { let mut tmp = valid.clone(); tmp.push(vec![a, b, c, d, e, f, g]); tmp };
                                count += 1;
                            }
                        }
                    }
                }
            }
        }
        return { let mut m = std::collections::BTreeMap::new(); m.insert("count", count); m.insert("list", valid); m };
    }
    let r1 = getCombs(1, 7, true);
    println!("{}", vec![format!("{}", format!("{}{}", *r1.get(&"count").unwrap().to_string(), " unique solutions in 1 to 7"))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    println!("{}", vec![format!("{}", *r1.get(&"list").unwrap())].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    let r2 = getCombs(3, 9, true);
    println!("{}", vec![format!("{}", format!("{}{}", *r2.get(&"count").unwrap().to_string(), " unique solutions in 3 to 9"))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    println!("{}", vec![format!("{}", *r2.get(&"list").unwrap())].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
    let r3 = getCombs(0, 9, false);
    println!("{}", vec![format!("{}", format!("{}{}", *r3.get(&"count").unwrap().to_string(), " non-unique solutions in 0 to 9"))].into_iter().filter(|s| !s.is_empty()).collect::<Vec<_>>().join(" ") );
}
