// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:34:26Z
Map<String, any> square_to_maps(List<List<String>> square) {
  Map<String, List<int>> emap = {};
  Map<String, String> dmap = {};
  num x = 0;
  while ((x as num) < square.length) {
    var row = square[x];
    num y = 0;
    while ((y as num) < row.length) {
      var ch = row[y];
      emap[ch] = [x, y];
      dmap[x.toString() + ',' + y.toString()] = ch;
      y = (y as num) + 1;
    }
    x = (x as num) + 1;
  }
  return {'e': emap, 'd': dmap};
}

String remove_space(String text, Map<String, List<int>> emap) {
  var s = upper(text);
  var out = '';
  num i = 0;
  while ((i as num) < s.length) {
    var ch = ((s is String) ? s.substring(i, (i as num) + 1) : (s as List).sublist(i, (i as num) + 1));
    if (ch != ' ' && emap.containsKey(ch)) {
      out = (out as num) + (ch as num);
    }
    i = (i as num) + 1;
  }
  return out;
}

String encrypt(String text, Map<String, List<int>> emap, Map<String, String> dmap) {
  text = remove_space(text, emap);
  List<int> row0 = [];
  List<int> row1 = [];
  num i = 0;
  while ((i as num) < text.length) {
    var ch = text.substring(i, (i as num) + 1);
    var xy = (emap as Map)[ch];
    row0 = List.from(row0)..add(xy[0]);
    row1 = List.from(row1)..add(xy[1]);
    i = (i as num) + 1;
  }
  var _iter0 = row1;
  for (var v in (_iter0 is Map ? (_iter0 as Map).keys : _iter0) as Iterable) {
    row0 = List.from(row0)..add(v);
  }
  var res = '';
  num j = 0;
  while ((j as num) < row0.length) {
    var key = row0[j].toString() + ',' + row0[(j as num) + 1].toString();
    res = res + (dmap as Map)[key];
    j = (j as num) + 2;
  }
  return res;
}

String decrypt(String text, Map<String, List<int>> emap, Map<String, String> dmap) {
  text = remove_space(text, emap);
  List<int> coords = [];
  num i = 0;
  while ((i as num) < text.length) {
    var ch = text.substring(i, (i as num) + 1);
    var xy = (emap as Map)[ch];
    coords = List.from(coords)..add(xy[0]);
    coords = List.from(coords)..add(xy[1]);
    i = (i as num) + 1;
  }
  var half = coords.length ~/ 2;
  List<int> k1 = [];
  List<int> k2 = [];
  num idx = 0;
  while ((idx as num) < (half as num)) {
    k1 = List.from(k1)..add(coords[idx]);
    idx = (idx as num) + 1;
  }
  while ((idx as num) < coords.length) {
    k2 = List.from(k2)..add(coords[idx]);
    idx = (idx as num) + 1;
  }
  var res = '';
  num j = 0;
  while ((j as num) < (half as num)) {
    var key = k1[j].toString() + ',' + k2[j].toString();
    res = res + (dmap as Map)[key];
    j = (j as num) + 1;
  }
  return res;
}

void _main() {
  var squareRosetta = [
    [
    'A',
    'B',
    'C',
    'D',
    'E',
  ],
    [
    'F',
    'G',
    'H',
    'I',
    'K',
  ],
    [
    'L',
    'M',
    'N',
    'O',
    'P',
  ],
    [
    'Q',
    'R',
    'S',
    'T',
    'U',
  ],
    [
    'V',
    'W',
    'X',
    'Y',
    'Z',
  ],
    [
    'J',
    '1',
    '2',
    '3',
    '4',
  ],
  ];
  var squareWikipedia = [
    [
    'B',
    'G',
    'W',
    'K',
    'Z',
  ],
    [
    'Q',
    'P',
    'N',
    'D',
    'S',
  ],
    [
    'I',
    'O',
    'A',
    'X',
    'E',
  ],
    [
    'F',
    'C',
    'L',
    'U',
    'M',
  ],
    [
    'T',
    'H',
    'Y',
    'V',
    'R',
  ],
    [
    'J',
    '1',
    '2',
    '3',
    '4',
  ],
  ];
  var textRosetta = '0ATTACKATDAWN';
  var textWikipedia = 'FLEEATONCE';
  var textTest = 'The invasion will start on the first of January';
  var maps = square_to_maps(squareRosetta);
  var emap = maps['e'];
  var dmap = maps['d'];
  print('from Rosettacode');
  print('original:   ' + textRosetta);
  var s = encrypt(textRosetta, emap, dmap);
  print('codiert:   ' + s);
  s = decrypt(s, emap, dmap);
  print('and back:   ' + s);
  maps = square_to_maps(squareWikipedia);
  emap = maps['e'];
  dmap = maps['d'];
  print('from Wikipedia');
  print('original:   ' + textWikipedia);
  s = encrypt(textWikipedia, emap, dmap);
  print('codiert:   ' + s);
  s = decrypt(s, emap, dmap);
  print('and back:   ' + s);
  maps = square_to_maps(squareWikipedia);
  emap = maps['e'];
  dmap = maps['d'];
  print('from Rosettacode long part');
  print('original:   ' + textTest);
  s = encrypt(textTest, emap, dmap);
  print('codiert:   ' + s);
  s = decrypt(s, emap, dmap);
  print('and back:   ' + s);
}

void main() {
  _main();
}
