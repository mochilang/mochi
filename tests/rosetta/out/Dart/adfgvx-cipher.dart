// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:33:40Z
var adfgvx = 'ADFGVX';

var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

String shuffleStr(String s) {
  List<String> arr = [];
  num i = 0;
  while ((i as num) < s.length) {
    arr = (arr as num) + ([
      s[i],
    ] as num);
    i = (i as num) + 1;
  }
  var j = arr.length - 1;
  while ((j as num) > 0) {
    var k = DateTime.now().microsecondsSinceEpoch % (((j as num) + 1) as num);
    var tmp = arr[j];
    arr[j] = arr[k];
    arr[k] = tmp;
    j = (j as num) - 1;
  }
  var out = '';
  i = 0;
  while ((i as num) < arr.length) {
    out = (out as num) + (arr[i] as num);
    i = (i as num) + 1;
  }
  return out;
}

List<String> createPolybius() {
  var shuffled = shuffleStr(alphabet);
  print('6 x 6 Polybius square:\n');
  print('  | A D F G V X');
  print('---------------');
  List<String> p = [];
  num i = 0;
  while ((i as num) < 6) {
    var row = ((shuffled is String) ? shuffled.substring((i as num) * 6, (((i as num) + 1) as num) * 6) : (shuffled as List).sublist((i as num) * 6, (((i as num) + 1) as num) * 6));
    p = (p as num) + ([row] as num);
    var line = adfgvx[i] + ' | ';
    num j = 0;
    while ((j as num) < 6) {
      line = (line as num) + (row[j] as num) + ' ';
      j = (j as num) + 1;
    }
    print(line);
    i = (i as num) + 1;
  }
  return p;
}

String createKey(int n) {
  if (n < 7 || n > 12) {
    print('Key should be within 7 and 12 letters long.');
  }
  var pool = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  var key = '';
  num i = 0;
  while ((i as num) < n) {
    var idx = DateTime.now().microsecondsSinceEpoch % pool.length;
    key = (key as num) + (pool[idx] as num);
    pool = (((pool is String) ? pool.substring(0, idx) : (pool as List).sublist(0, idx)) as num) + (((pool is String) ? pool.substring((idx as num) + 1, pool.length) : (pool as List).sublist((idx as num) + 1, pool.length)) as num);
    i = (i as num) + 1;
  }
  print('\nThe key is ' + key);
  return key;
}

List<int> orderKey(String key) {
  var pairs = [];
  num i = 0;
  while ((i as num) < key.length) {
    pairs = (pairs as num) + ([
      [
      key[i],
      i,
    ],
    ] as num);
    i = (i as num) + 1;
  }
  var n = pairs.length;
  num m = 0;
  while ((m as num) < (n as num)) {
    num j = 0;
    while ((j as num) < ((n as num) - 1 as num)) {
      if ((pairs[j][0] as num) > (pairs[(j as num) + 1][0] as num)) {
        var tmp = pairs[j];
        pairs[j] = pairs[(j as num) + 1];
        pairs[(j as num) + 1] = tmp;
      }
      j = (j as num) + 1;
    }
    m = (m as num) + 1;
  }
  var res = [];
  i = 0;
  while ((i as num) < (n as num)) {
    res = (res as num) + ([
      int.parse(pairs[i][1]),
    ] as num);
    i = (i as num) + 1;
  }
  return res;
}

String encrypt(List<String> polybius, String key, String plainText) {
  var temp = '';
  num i = 0;
  while ((i as num) < plainText.length) {
    num r = 0;
    while ((r as num) < 6) {
      num c = 0;
      while ((c as num) < 6) {
        if (polybius[r][c] == plainText[i]) {
          temp = temp + adfgvx[r] + adfgvx[c];
        }
        c = (c as num) + 1;
      }
      r = (r as num) + 1;
    }
    i = (i as num) + 1;
  }
  var colLen = temp.length ~/ key.length;
  if (temp.length % key.length > 0) {
    colLen = (colLen as num) + 1;
  }
  List<List<String>> table = [];
  num rIdx = 0;
  while ((rIdx as num) < (colLen as num)) {
    List<String> row = [];
    num j = 0;
    while ((j as num) < key.length) {
      row = (row as num) + ([''] as num);
      j = (j as num) + 1;
    }
    table = (table as num) + ([row] as num);
    rIdx = (rIdx as num) + 1;
  }
  num idx = 0;
  while ((idx as num) < temp.length) {
    var row = (idx as num) / key.length;
    var col = (idx as num) % key.length;
    table[row][col] = ((temp is String) ? temp.substring(idx, (idx as num) + 1) : (temp as List).sublist(idx, (idx as num) + 1));
    idx = (idx as num) + 1;
  }
  var order = orderKey(key);
  List<String> cols = [];
  num ci = 0;
  while ((ci as num) < key.length) {
    var colStr = '';
    num ri = 0;
    while ((ri as num) < (colLen as num)) {
      colStr = (colStr as num) + (table[ri][order[ci]] as num);
      ri = (ri as num) + 1;
    }
    cols = (cols as num) + ([colStr] as num);
    ci = (ci as num) + 1;
  }
  var result = '';
  ci = 0;
  while ((ci as num) < cols.length) {
    result = (result as num) + (cols[ci] as num);
    if ((ci as num) < cols.length - 1) {
      result = result + ' ';
    }
    ci = (ci as num) + 1;
  }
  return result;
}

int indexOf(String s, String ch) {
  num i = 0;
  while ((i as num) < s.length) {
    if (s[i] == ch) {
      return i;
    }
    i = (i as num) + 1;
  }
  return -1;
}

String decrypt(List<String> polybius, String key, String cipherText) {
  List<String> colStrs = [];
  num start = 0;
  num i = 0;
  while ((i as num) <= cipherText.length) {
    if (i == cipherText.length || cipherText[i] == ' ') {
      colStrs = (colStrs as num) + ([
        cipherText.substring(start, i),
      ] as num);
      start = (i as num) + 1;
    }
    i = (i as num) + 1;
  }
  num maxColLen = 0;
  i = 0;
  while ((i as num) < colStrs.length) {
    if (colStrs[i].length > (maxColLen as num)) {
      maxColLen = colStrs[i].length;
    }
    i = (i as num) + 1;
  }
  List<List<String>> cols = [];
  i = 0;
  while ((i as num) < colStrs.length) {
    var s = colStrs[i];
    List<String> ls = [];
    num j = 0;
    while ((j as num) < s.length) {
      ls = (ls as num) + ([
        s[j],
      ] as num);
      j = (j as num) + 1;
    }
    if (s.length < (maxColLen as num)) {
      List<String> pad = [];
      num k = 0;
      while ((k as num) < (maxColLen as num)) {
        if ((k as num) < ls.length) {
          pad = (pad as num) + ([
            ls[k],
          ] as num);
        }
        else {
          pad = (pad as num) + ([''] as num);
        }
        k = (k as num) + 1;
      }
      cols = (cols as num) + ([pad] as num);
    }
    else {
      cols = (cols as num) + ([ls] as num);
    }
    i = (i as num) + 1;
  }
  List<List<String>> table = [];
  num r = 0;
  while ((r as num) < (maxColLen as num)) {
    List<String> row = [];
    num c = 0;
    while ((c as num) < key.length) {
      row = (row as num) + ([''] as num);
      c = (c as num) + 1;
    }
    table = (table as num) + ([row] as num);
    r = (r as num) + 1;
  }
  var order = orderKey(key);
  r = 0;
  while ((r as num) < (maxColLen as num)) {
    num c = 0;
    while ((c as num) < key.length) {
      table[r][order[c]] = cols[c][r];
      c = (c as num) + 1;
    }
    r = (r as num) + 1;
  }
  var temp = '';
  r = 0;
  while ((r as num) < table.length) {
    num j = 0;
    while ((j as num) < table[r].length) {
      temp = (temp as num) + (table[r][j] as num);
      j = (j as num) + 1;
    }
    r = (r as num) + 1;
  }
  var plainText = '';
  num idx = 0;
  while ((idx as num) < temp.length) {
    var rIdx = indexOf(adfgvx, ((temp is String) ? temp.substring(idx, (idx as num) + 1) : (temp as List).sublist(idx, (idx as num) + 1)));
    var cIdx = indexOf(adfgvx, ((temp is String) ? temp.substring((idx as num) + 1, (idx as num) + 2) : (temp as List).sublist((idx as num) + 1, (idx as num) + 2)));
    plainText = plainText + polybius[rIdx][cIdx];
    idx = (idx as num) + 2;
  }
  return plainText;
}

void _main() {
  var plainText = 'ATTACKAT1200AM';
  var polybius = createPolybius();
  var key = createKey(9);
  print('\nPlaintext : ' + plainText);
  var cipherText = encrypt(polybius, key, plainText);
  print('\nEncrypted : ' + cipherText);
  var plainText2 = decrypt(polybius, key, cipherText);
  print('\nDecrypted : ' + plainText2);
}

void main() {
  _main();
}
