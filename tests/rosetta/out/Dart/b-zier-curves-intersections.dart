// Generated by Mochi compiler v0.10.26 on 2025-07-16T11:59:13Z
import 'dart:io';
import 'dart:convert';

double absf(double x) {
  if (x < 0) {
    return -x;
  }
  return x;
}

double maxf(double a, double b) {
  if (a > b) {
    return a;
  }
  return b;
}

double minf(double a, double b) {
  if (a < b) {
    return a;
  }
  return b;
}

double max3(double a, double b, double c) {
  var m = a;
  if (b > m) {
    m = b;
  }
  if (c > m) {
    m = c;
  }
  return m;
}

double min3(double a, double b, double c) {
  var m = a;
  if (b < m) {
    m = b;
  }
  if (c < m) {
    m = c;
  }
  return m;
}

class Point {
  double x;
  double y;
  Point(this.x, this.y);
}

class QuadSpline {
  double c0;
  double c1;
  double c2;
  QuadSpline(this.c0, this.c1, this.c2);
}

class QuadCurve {
  QuadSpline x;
  QuadSpline y;
  QuadCurve(this.x, this.y);
}

List<QuadSpline> subdivideQuadSpline(QuadSpline q, double t) {
  var s = 1 - t;
  var u = QuadSpline(q.c0, 0, 0);
  var v = QuadSpline(0, 0, q.c2);
  u.c1 = s * q.c0 + t * q.c1;
  v.c1 = s * q.c1 + t * q.c2;
  u.c2 = s * u['c1'] + t * v['c1'];
  v.c0 = u['c2'];
  return [u, v];
}

List<QuadCurve> subdivideQuadCurve(QuadCurve q, double t) {
  var xs = subdivideQuadSpline(q.x, t);
  var ys = subdivideQuadSpline(q.y, t);
  var u = QuadCurve(xs[0], ys[0]);
  var v = QuadCurve(xs[1], ys[1]);
  return [u, v];
}

bool rectsOverlap(double xa0, double ya0, double xa1, double ya1, double xb0, double yb0, double xb1, double yb1) {
  return xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1;
}

Map<String, any> testIntersect(QuadCurve p, QuadCurve q, double tol) {
  var pxmin = min3(p.x.c0, p.x.c1, p.x.c2);
  var pymin = min3(p.y.c0, p.y.c1, p.y.c2);
  var pxmax = max3(p.x.c0, p.x.c1, p.x.c2);
  var pymax = max3(p.y.c0, p.y.c1, p.y.c2);
  var qxmin = min3(q.x.c0, q.x.c1, q.x.c2);
  var qymin = min3(q.y.c0, q.y.c1, q.y.c2);
  var qxmax = max3(q.x.c0, q.x.c1, q.x.c2);
  var qymax = max3(q.y.c0, q.y.c1, q.y.c2);
  var exclude = true;
  var accept = false;
  var inter = Point(0, 0);
  if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
    exclude = false;
    var xmin = maxf(pxmin, qxmin);
    var xmax = minf(pxmax, qxmax);
    if (xmax - xmin <= tol) {
      var ymin = maxf(pymin, qymin);
      var ymax = minf(pymax, qymax);
      if (ymax - ymin <= tol) {
        accept = true;
        inter.x = 0.5 * (xmin + xmax);
        inter.y = 0.5 * (ymin + ymax);
      }
    }
  }
  return {'exclude': exclude, 'accept': accept, 'intersect': inter};
}

bool seemsToBeDuplicate(List<Point> pts, Point xy, double spacing) {
  var i = 0;
  while (i < pts.length) {
    var pt = pts[i];
    if (absf(pt['x'] - xy.x) < spacing && absf(pt['y'] - xy.y) < spacing) {
      return true;
    }
    i = i + 1;
  }
  return false;
}

List<Point> findIntersects(QuadCurve p, QuadCurve q, double tol, double spacing) {
  List<Point> inters = [];
  List<Map<String, QuadCurve>> workload = [{'p': p, 'q': q}];
  while (workload.length > 0) {
    var idx = workload.length - 1;
    var work = workload[idx];
    workload = ((workload is String) ? workload.substring(0, idx) : (workload as List).sublist(0, idx));
    var res = testIntersect(work['p'], work['q'], tol);
    var excl = res['exclude'];
    var acc = res['accept'];
    var inter = Point((res['intersect']['x'] as double), (res['intersect']['y'] as double));
    if (acc != null) {
      if (!seemsToBeDuplicate(inters, inter, spacing)) {
        inters = List.from(inters)..add(inter);
      }
    }
    else 
    if (!excl != null) {
      var ps = subdivideQuadCurve(work['p'], 0.5);
      var qs = subdivideQuadCurve(work['q'], 0.5);
      var p0 = ps[0];
      var p1 = ps[1];
      var q0 = qs[0];
      var q1 = qs[1];
      workload = List.from(workload)..add({'p': p0, 'q': q0});
      workload = List.from(workload)..add({'p': p0, 'q': q1});
      workload = List.from(workload)..add({'p': p1, 'q': q0});
      workload = List.from(workload)..add({'p': p1, 'q': q1});
    }
  }
  return inters;
}

void main() {
  var p = QuadCurve(QuadSpline(-1, 0, 1), QuadSpline(0, 10, 0));
  var q = QuadCurve(QuadSpline(2, -8, 2), QuadSpline(1, 2, 3));
  var tol = 1e-07;
  var spacing = tol * 10;
  var inters = findIntersects(p, q, tol, spacing);
  var i = 0;
  while (i < inters.length) {
    var pt = inters[i];
    print('(' + pt['x'].toString() + ', ' + pt['y'].toString() + ')');
    i = i + 1;
  }
}

void main() {
  main();
}

bool _equal(dynamic a, dynamic b) {
    if (a is List && b is List) {
        if (a.length != b.length) return false;
        for (var i = 0; i < a.length; i++) { if (!_equal(a[i], b[i])) return false; }
        return true;
    }
    if (a is Map && b is Map) {
        if (a.length != b.length) return false;
        for (var k in a.keys) { if (!b.containsKey(k) || !_equal(a[k], b[k])) return false; }
        return true;
    }
    return a == b;
}

String _formatDuration(Duration d) {
    if (d.inMicroseconds < 1000) return '${d.inMicroseconds}Âµs';
    if (d.inMilliseconds < 1000) return '${d.inMilliseconds}ms';
    return '${(d.inMilliseconds/1000).toStringAsFixed(2)}s';
}

void _json(dynamic v) {
    print(jsonEncode(v));
}


dynamic _min(dynamic v) {
    List<dynamic>? list;
    if (v is List) list = v;
    else if (v is Map && v['items'] is List) list = (v['items'] as List);
    else if (v is Map && v['Items'] is List) list = (v['Items'] as List);
    else { try { var it = (v as dynamic).items; if (it is List) list = it; } catch (_) {} }
    if (list == null || list.isEmpty) return 0;
    var m = list[0];
    for (var n in list) { if ((n as Comparable).compareTo(m) < 0) m = n; }
    return m;
}

num _sum(dynamic v) {
    Iterable<dynamic>? list;
    if (v is Iterable) list = v;
    else if (v is Map && v['items'] is Iterable) list = (v['items'] as Iterable);
    else if (v is Map && v['Items'] is Iterable) list = (v['Items'] as Iterable);
    else { try { var it = (v as dynamic).items; if (it is Iterable) list = it; } catch (_) {} }
    if (list == null) return 0;
    num s = 0;
    for (var n in list) s += (n as num);
    return s;
}

bool _runTest(String name, void Function() f) {
    stdout.write('   test $name ...');
    var start = DateTime.now();
    try {
        f();
        var d = DateTime.now().difference(start);
        stdout.writeln(' ok (${_formatDuration(d)})');
        return true;
    } catch (e) {
        var d = DateTime.now().difference(start);
        stdout.writeln(' fail $e (${_formatDuration(d)})');
        return false;
    }
}
