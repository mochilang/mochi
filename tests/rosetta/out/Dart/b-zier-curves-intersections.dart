// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:34:19Z
double absf(double x) {
  if (x < 0) {
    return -(x as num);
  }
  return x;
}

double maxf(double a, double b) {
  if (a > b) {
    return a;
  }
  return b;
}

double minf(double a, double b) {
  if (a < b) {
    return a;
  }
  return b;
}

double max3(double a, double b, double c) {
  var m = a;
  if (b > (m as num)) {
    m = b;
  }
  if (c > (m as num)) {
    m = c;
  }
  return m;
}

double min3(double a, double b, double c) {
  var m = a;
  if (b < (m as num)) {
    m = b;
  }
  if (c < (m as num)) {
    m = c;
  }
  return m;
}

class Point {
  double x;
  double y;
  Point(this.x, this.y);
}

class QuadSpline {
  double c0;
  double c1;
  double c2;
  QuadSpline(this.c0, this.c1, this.c2);
}

class QuadCurve {
  QuadSpline x;
  QuadSpline y;
  QuadCurve(this.x, this.y);
}

List<QuadSpline> subdivideQuadSpline(QuadSpline q, double t) {
  var s = 1 - t;
  var u = QuadSpline(q.c0, 0, 0);
  var v = QuadSpline(0, 0, q.c2);
  u.c1 = ((s as num) * q.c0 as num) + t * q.c1;
  v.c1 = ((s as num) * q.c1 as num) + t * q.c2;
  u.c2 = ((s as num) * (u['c1'] as num) as num) + (t * (v['c1'] as num) as num);
  v.c0 = u['c2'];
  return [u, v];
}

List<QuadCurve> subdivideQuadCurve(QuadCurve q, double t) {
  var xs = subdivideQuadSpline(q.x, t);
  var ys = subdivideQuadSpline(q.y, t);
  var u = QuadCurve(xs[0], ys[0]);
  var v = QuadCurve(xs[1], ys[1]);
  return [u, v];
}

bool rectsOverlap(double xa0, double ya0, double xa1, double ya1, double xb0, double yb0, double xb1, double yb1) {
  return xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1;
}

Map<String, any> testIntersect(QuadCurve p, QuadCurve q, double tol) {
  var pxmin = min3(p.x.c0, p.x.c1, p.x.c2);
  var pymin = min3(p.y.c0, p.y.c1, p.y.c2);
  var pxmax = max3(p.x.c0, p.x.c1, p.x.c2);
  var pymax = max3(p.y.c0, p.y.c1, p.y.c2);
  var qxmin = min3(q.x.c0, q.x.c1, q.x.c2);
  var qymin = min3(q.y.c0, q.y.c1, q.y.c2);
  var qxmax = max3(q.x.c0, q.x.c1, q.x.c2);
  var qymax = max3(q.y.c0, q.y.c1, q.y.c2);
  var exclude = true;
  var accept = false;
  var inter = Point(0, 0);
  if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
    exclude = false;
    var xmin = maxf(pxmin, qxmin);
    var xmax = minf(pxmax, qxmax);
    if (((xmax as num) - (xmin as num) as num) <= tol) {
      var ymin = maxf(pymin, qymin);
      var ymax = minf(pymax, qymax);
      if (((ymax as num) - (ymin as num) as num) <= tol) {
        accept = true;
        inter.x = 0.5 * (((xmin as num) + (xmax as num)) as num);
        inter.y = 0.5 * (((ymin as num) + (ymax as num)) as num);
      }
    }
  }
  return {'exclude': exclude, 'accept': accept, 'intersect': inter};
}

bool seemsToBeDuplicate(List<Point> pts, Point xy, double spacing) {
  num i = 0;
  while ((i as num) < pts.length) {
    var pt = pts[i];
    if (absf((pt['x'] as num) - xy.x) < spacing && absf((pt['y'] as num) - xy.y) < spacing) {
      return true;
    }
    i = (i as num) + 1;
  }
  return false;
}

List<Point> findIntersects(QuadCurve p, QuadCurve q, double tol, double spacing) {
  List<Point> inters = [];
  List<Map<String, QuadCurve>> workload = [
    {'p': p, 'q': q},
  ];
  while (workload.length > 0) {
    var idx = workload.length - 1;
    var work = workload[idx];
    workload = ((workload is String) ? workload.substring(0, idx) : (workload as List).sublist(0, idx));
    var res = testIntersect(work['p'], work['q'], tol);
    var excl = res['exclude'];
    var acc = res['accept'];
    var inter = Point((res['intersect']['x'] as double), (res['intersect']['y'] as double));
    if (acc != null) {
      if (!seemsToBeDuplicate(inters, inter, spacing)) {
        inters = List.from(inters)..add(inter);
      }
    }
    else 
    if (!excl != null) {
      var ps = subdivideQuadCurve(work['p'], 0.5);
      var qs = subdivideQuadCurve(work['q'], 0.5);
      var p0 = ps[0];
      var p1 = ps[1];
      var q0 = qs[0];
      var q1 = qs[1];
      workload = List.from(workload)..add({'p': p0, 'q': q0});
      workload = List.from(workload)..add({'p': p0, 'q': q1});
      workload = List.from(workload)..add({'p': p1, 'q': q0});
      workload = List.from(workload)..add({'p': p1, 'q': q1});
    }
  }
  return inters;
}

void _main() {
  var p = QuadCurve(QuadSpline(-1, 0, 1), QuadSpline(0, 10, 0));
  var q = QuadCurve(QuadSpline(2, -8, 2), QuadSpline(1, 2, 3));
  var tol = 1e-07;
  var spacing = (tol as num) * 10;
  var inters = findIntersects(p, q, tol, spacing);
  num i = 0;
  while ((i as num) < inters.length) {
    var pt = inters[i];
    print('(' + pt['x'].toString() + ', ' + pt['y'].toString() + ')');
    i = (i as num) + 1;
  }
}

void main() {
  _main();
}
