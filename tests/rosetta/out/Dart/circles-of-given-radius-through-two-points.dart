// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:35:21Z
class Point {
  double x;
  double y;
  Point(this.x, this.y);
}

double sqrtApprox(double x) {
  var g = x;
  num i = 0;
  while ((i as num) < 40) {
    g = (((g as num) + (x / (g as num) as num)) as num) / 2;
    i = (i as num) + 1;
  }
  return g;
}

double hypot(double x, double y) {
  return sqrtApprox(x * x + y * y);
}

var Two = 'Two circles.';

var R0 = 'R==0.0 does not describe circles.';

var Co = 'Coincident points describe an infinite number of circles.';

var CoR0 = 'Coincident points with r==0.0 describe a degenerate circle.';

var Diam = 'Points form a diameter and describe only a single circle.';

var Far = 'Points too far apart to form circles.';

List<any> circles(Point p1, Point p2, double r) {
  if (p1.x == p2.x && p1.y == p2.y) {
    if (r == 0) {
      return [
        p1,
        p1,
        'Coincident points with r==0.0 describe a degenerate circle.',
      ];
    }
    return [
      p1,
      p2,
      'Coincident points describe an infinite number of circles.',
    ];
  }
  if (r == 0) {
    return [
      p1,
      p2,
      'R==0.0 does not describe circles.',
    ];
  }
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  var q = hypot(dx, dy);
  if ((q as num) > 2 * r) {
    return [
      p1,
      p2,
      'Points too far apart to form circles.',
    ];
  }
  var m = Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
  if (q == 2 * r) {
    return [
      m,
      m,
      'Points form a diameter and describe only a single circle.',
    ];
  }
  var d = sqrtApprox(r * r - (((q as num) * (q as num) as num) / 4 as num));
  var ox = ((d as num) * (dx as num) as num) / (q as num);
  var oy = ((d as num) * (dy as num) as num) / (q as num);
  return [
    Point((m['x'] as num) - (oy as num), (m['y'] as num) + (ox as num)),
    Point((m['x'] as num) + (oy as num), (m['y'] as num) - (ox as num)),
    'Two circles.',
  ];
}

var td = [
  [
  Point(0.1234, 0.9876),
  Point(0.8765, 0.2345),
  2,
],
  [Point(0, 2), Point(0, 0), 1],
  [
  Point(0.1234, 0.9876),
  Point(0.1234, 0.9876),
  2,
],
  [
  Point(0.1234, 0.9876),
  Point(0.8765, 0.2345),
  0.5,
],
  [
  Point(0.1234, 0.9876),
  Point(0.1234, 0.9876),
  0,
],
];

void main() {
  for (var tc in td) {
    var p1 = tc[0];
    var p2 = tc[1];
    var r = tc[2];
    print('p1:  {' + p1['x'].toString() + ' ' + p1['y'].toString() + '}');
    print('p2:  {' + p2['x'].toString() + ' ' + p2['y'].toString() + '}');
    print('r:  ' + r.toString());
    var res = circles(p1, p2, r);
    var c1 = res[0];
    var c2 = res[1];
    var caseStr = res[2];
    print('   ' + caseStr);
    if (caseStr == 'Points form a diameter and describe only a single circle.' || caseStr == 'Coincident points with r==0.0 describe a degenerate circle.') {
      print('   Center:  {' + c1['x'].toString() + ' ' + c1['y'].toString() + '}');
    }
    else {
      if (caseStr == 'Two circles.') {
        print('   Center 1:  {' + c1['x'].toString() + ' ' + c1['y'].toString() + '}');
        print('   Center 2:  {' + c2['x'].toString() + ' ' + c2['y'].toString() + '}');
      }
    }
    print('');
  }
}
