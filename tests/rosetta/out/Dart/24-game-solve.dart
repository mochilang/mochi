// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:33:23Z
num OP_NUM = 0;

var OP_ADD = 1;

var OP_SUB = 2;

var OP_MUL = 3;

var OP_DIV = 4;

Map<String, any> newNum(int n) {
  return {
    'op': OP_NUM,
    'value': {'num': n, 'denom': 1},
  };
}

Map<String, int> exprEval(Map<String, any> x) {
  if ((x as Map)['op'] == OP_NUM) {
    return (x as Map)['value'];
  }
  var l = exprEval((x as Map)['left']);
  var r = exprEval((x as Map)['right']);
  if ((x as Map)['op'] == OP_ADD) {
    return {
      'num': ((l['num'] as num) * (r['denom'] as num) as num) + ((l['denom'] as num) * (r['num'] as num) as num),
      'denom': (l['denom'] as num) * (r['denom'] as num),
    };
  }
  if ((x as Map)['op'] == OP_SUB) {
    return {
      'num': ((l['num'] as num) * (r['denom'] as num) as num) - ((l['denom'] as num) * (r['num'] as num) as num),
      'denom': (l['denom'] as num) * (r['denom'] as num),
    };
  }
  if ((x as Map)['op'] == OP_MUL) {
    return {
      'num': (l['num'] as num) * (r['num'] as num),
      'denom': (l['denom'] as num) * (r['denom'] as num),
    };
  }
  return {
    'num': (l['num'] as num) * (r['denom'] as num),
    'denom': (l['denom'] as num) * (r['num'] as num),
  };
}

String exprString(Map<String, any> x) {
  if ((x as Map)['op'] == OP_NUM) {
    return (x as Map)['value']['num'].toString();
  }
  var ls = exprString((x as Map)['left']);
  var rs = exprString((x as Map)['right']);
  var opstr = '';
  if ((x as Map)['op'] == OP_ADD) {
    opstr = ' + ';
  }
  else 
  if ((x as Map)['op'] == OP_SUB) {
    opstr = ' - ';
  }
  else 
  if ((x as Map)['op'] == OP_MUL) {
    opstr = ' * ';
  }
  else {
    opstr = ' / ';
  }
  return '(' + ls + opstr + rs + ')';
}

var n_cards = 4;

var goal = 24;

var digit_range = 9;

bool solve(List<Map<String, any>> xs) {
  if (xs.length == 1) {
    var f = exprEval(xs[0]);
    if (f['denom'] != 0 && f['num'] == (f['denom'] as num) * goal) {
      print(exprString(xs[0]));
      return true;
    }
    return false;
  }
  num i = 0;
  while ((i as num) < xs.length) {
    var j = (i as num) + 1;
    while ((j as num) < xs.length) {
      List<Map<String, any>> rest = [];
      num k = 0;
      while ((k as num) < xs.length) {
        if (k != i && k != j) {
          rest = List.from(rest)..add(xs[k]);
        }
        k = (k as num) + 1;
      }
      var a = xs[i];
      var b = xs[j];
      for (var op in [
        OP_ADD,
        OP_SUB,
        OP_MUL,
        OP_DIV,
      ]) {
        var node = {'op': op, 'left': a, 'right': b};
        if (solve(List.from(rest)..add(node))) {
          return true;
        }
      }
      var node = {'op': OP_SUB, 'left': b, 'right': a};
      if (solve(List.from(rest)..add(node))) {
        return true;
      }
      node = {'op': OP_DIV, 'left': b, 'right': a};
      if (solve(List.from(rest)..add(node))) {
        return true;
      }
      j = (j as num) + 1;
    }
    i = (i as num) + 1;
  }
  return false;
}

void _main() {
  num iter = 0;
  while ((iter as num) < 10) {
    List<Map<String, any>> cards = [];
    num i = 0;
    while ((i as num) < n_cards) {
      var n = (DateTime.now().microsecondsSinceEpoch % (digit_range - 1)) + 1;
      cards = List.from(cards)..add(newNum(n));
      print(' ' + n.toString());
      i = (i as num) + 1;
    }
    print(':  ');
    if (!solve(cards)) {
      print('No solution');
    }
    iter = (iter as num) + 1;
  }
}

void main() {
  _main();
}
