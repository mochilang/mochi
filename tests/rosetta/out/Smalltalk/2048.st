" Generated by Mochi compiler v0.10.30 on 2025-07-18T17:36:01Z
"
| SIZE newBoard b y row x spawnTile empty idx cell val pad s i out draw line v reverseRow slideLeft xs res gain moveLeft moved r new moveRight rev getCol col setCol moveUp moveDown hasMoves has2048 board full score cmd m r2 |
Object subclass: #BreakSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!.
SIZE := 4.
newBoard := [ b := {}.
y := 0.
[(y < SIZE)] whileTrue: [.
row := {}.
x := 0.
[(x < SIZE)] whileTrue: [.
row := row copyWith: 0.
x := (x + 1).
].
.
b := b copyWith: row.
y := (y + 1).
].
.
b. ].
spawnTile := [:b | empty := {}.
y := 0.
[(y < SIZE)] whileTrue: [.
x := 0.
[(x < SIZE)] whileTrue: [.
(((b at: y at: x) = 0)) ifTrue: [
empty := empty copyWith: {x. y}.
] .
x := (x + 1).
].
.
y := (y + 1).
].
.
((((empty size)) = 0)) ifTrue: [
Dictionary from:{'board'->b. 'full'->true}.
] .
idx := ((now value) % ((empty size))).
cell := empty at: idx.
val := 4.
(((((now value) % 10)) < 9)) ifTrue: [
val := 2.
] .
b at: cell at: 1 at: cell at: 0 put: val.
Dictionary from:{'board'->b. 'full'->((((empty size)) = 1))}. ].
pad := [:n | s := (n asString).
pad := (4 - ((s size))).
i := 0.
out := ''.
[(i < pad)] whileTrue: [.
out := (out + (' ')).
i := (i + 1).
].
.
(out + s). ].
draw := [:b :score | Transcript show: ((('Score: ') + ((score asString)))) printString; cr.
y := 0.
[(y < SIZE)] whileTrue: [.
Transcript show: '+----+----+----+----+'; cr.
line := '|'.
x := 0.
[(x < SIZE)] whileTrue: [.
v := b at: y at: x.
((v = 0)) ifTrue: [
line := (line + ('    |')).
] ifFalse: [
line := (((line + (pad value: v))) + '|').
].
x := (x + 1).
].
.
Transcript show: (line) printString; cr.
y := (y + 1).
].
.
Transcript show: '+----+----+----+----+'; cr.
Transcript show: 'W=Up S=Down A=Left D=Right Q=Quit'; cr. ].
reverseRow := [:r | out := {}.
i := (((r size)) - 1).
[(i >= 0)] whileTrue: [.
out := out copyWith: r at: i.
i := (i - 1).
].
.
out. ].
slideLeft := [:row | xs := {}.
i := 0.
[(i < ((row size)))] whileTrue: [.
(((row at: i) ~= 0)) ifTrue: [
xs := xs copyWith: row at: i.
] .
i := (i + 1).
].
.
res := {}.
gain := 0.
i := 0.
[(i < ((xs size)))] whileTrue: [.
((((((i + 1)) < ((xs size)))) and: [(((xs at: i) = (xs at: (i + 1))))])) ifTrue: [
v := ((xs at: i) * 2).
gain := (gain + v).
res := res copyWith: v.
i := (i + 2).
] ifFalse: [
res := res copyWith: xs at: i.
i := (i + 1).
].
].
.
[(((res size)) < SIZE)] whileTrue: [.
res := res copyWith: 0.
].
.
Dictionary from:{'row'->res. 'gain'->gain}. ].
moveLeft := [:b :score | moved := false.
y := 0.
[(y < SIZE)] whileTrue: [.
r := slideLeft value: b at: y.
new := r at: 'row'.
score := (score + (r at: 'gain')).
x := 0.
[(x < SIZE)] whileTrue: [.
(((b at: y at: x) ~= (new at: x))) ifTrue: [
moved := true.
] .
b at: y at: x put: new at: x.
x := (x + 1).
].
.
y := (y + 1).
].
.
Dictionary from:{'board'->b. 'score'->score. 'moved'->moved}. ].
moveRight := [:b :score | moved := false.
y := 0.
[(y < SIZE)] whileTrue: [.
rev := reverseRow value: b at: y.
r := slideLeft value: rev.
rev := r at: 'row'.
score := (score + (r at: 'gain')).
rev := reverseRow value: rev.
x := 0.
[(x < SIZE)] whileTrue: [.
(((b at: y at: x) ~= (rev at: x))) ifTrue: [
moved := true.
] .
b at: y at: x put: rev at: x.
x := (x + 1).
].
.
y := (y + 1).
].
.
Dictionary from:{'board'->b. 'score'->score. 'moved'->moved}. ].
getCol := [:b :x | col := {}.
y := 0.
[(y < SIZE)] whileTrue: [.
col := col copyWith: b at: y at: x.
y := (y + 1).
].
.
col. ].
setCol := [:b :x :col | y := 0.
[(y < SIZE)] whileTrue: [.
b at: y at: x put: col at: y.
y := (y + 1).
].
. ].
moveUp := [:b :score | moved := false.
x := 0.
[(x < SIZE)] whileTrue: [.
col := getCol value: b value: x.
r := slideLeft value: col.
new := r at: 'row'.
score := (score + (r at: 'gain')).
y := 0.
[(y < SIZE)] whileTrue: [.
(((b at: y at: x) ~= (new at: y))) ifTrue: [
moved := true.
] .
b at: y at: x put: new at: y.
y := (y + 1).
].
.
x := (x + 1).
].
.
Dictionary from:{'board'->b. 'score'->score. 'moved'->moved}. ].
moveDown := [:b :score | moved := false.
x := 0.
[(x < SIZE)] whileTrue: [.
col := reverseRow value: getCol value: b value: x.
r := slideLeft value: col.
col := r at: 'row'.
score := (score + (r at: 'gain')).
col := reverseRow value: col.
y := 0.
[(y < SIZE)] whileTrue: [.
(((b at: y at: x) ~= (col at: y))) ifTrue: [
moved := true.
] .
b at: y at: x put: col at: y.
y := (y + 1).
].
.
x := (x + 1).
].
.
Dictionary from:{'board'->b. 'score'->score. 'moved'->moved}. ].
hasMoves := [:b | y := 0.
[(y < SIZE)] whileTrue: [.
x := 0.
[(x < SIZE)] whileTrue: [.
(((b at: y at: x) = 0)) ifTrue: [
true.
] .
((((((x + 1)) < SIZE)) and: [(((b at: y at: x) = (b at: y at: (x + 1))))])) ifTrue: [
true.
] .
((((((y + 1)) < SIZE)) and: [(((b at: y at: x) = (b at: (y + 1) at: x)))])) ifTrue: [
true.
] .
x := (x + 1).
].
.
y := (y + 1).
].
.
false. ].
has2048 := [:b | y := 0.
[(y < SIZE)] whileTrue: [.
x := 0.
[(x < SIZE)] whileTrue: [.
(((b at: y at: x) >= 2048)) ifTrue: [
true.
] .
x := (x + 1).
].
.
y := (y + 1).
].
.
false. ].
board := newBoard value.
r := spawnTile value: board.
board := r at: 'board'.
full := r at: 'full'.
r := spawnTile value: board.
board := r at: 'board'.
full := r at: 'full'.
score := 0.
draw value: board value: score.
[.
[true] whileTrue: [.
Transcript show: 'Move: '; cr.
cmd := input value.
moved := false.
((((cmd = 'a')) or: [((cmd = 'A'))])) ifTrue: [
m := moveLeft value: board value: score.
board := m at: 'board'.
score := m at: 'score'.
moved := m at: 'moved'.
] .
((((cmd = 'd')) or: [((cmd = 'D'))])) ifTrue: [
m := moveRight value: board value: score.
board := m at: 'board'.
score := m at: 'score'.
moved := m at: 'moved'.
] .
((((cmd = 'w')) or: [((cmd = 'W'))])) ifTrue: [
m := moveUp value: board value: score.
board := m at: 'board'.
score := m at: 'score'.
moved := m at: 'moved'.
] .
((((cmd = 's')) or: [((cmd = 'S'))])) ifTrue: [
m := moveDown value: board value: score.
board := m at: 'board'.
score := m at: 'score'.
moved := m at: 'moved'.
] .
((((cmd = 'q')) or: [((cmd = 'Q'))])) ifTrue: [
BreakSignal signal.
] .
(moved) ifTrue: [
r2 := spawnTile value: board.
board := r2 at: 'board'.
full := r2 at: 'full'.
((full and: [(hasMoves value: board not)])) ifTrue: [
draw value: board value: score.
Transcript show: 'Game Over'; cr.
BreakSignal signal.
] .
] .
draw value: board value: score.
(has2048 value: board) ifTrue: [
Transcript show: 'You win!'; cr.
BreakSignal signal.
] .
(hasMoves value: board not) ifTrue: [
Transcript show: 'Game Over'; cr.
BreakSignal signal.
] .
].
] on: BreakSignal do: [:ex | ].
