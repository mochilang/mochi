" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| newBitmap rows y row x setPx getPx splitLines out cur i ch splitWS parseIntStr neg n digits tokenize lines toks line parts j readP3 w h maxv idx bm r g b toGrey m p l pad s writeP3 max ppmtxt |
Object subclass: #ContinueSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!.
newBitmap := [:w :h :max | rows := {}.
y := 0.
[(y < h)] whileTrue: [.
row := {}.
x := 0.
[(x < w)] whileTrue: [.
row := row copyWith: Dictionary from:{'R'->0. 'G'->0. 'B'->0}.
x := (x + 1).
].
.
rows := rows copyWith: row.
y := (y + 1).
].
.
Dictionary from:{'w'->w. 'h'->h. 'max'->max. 'data'->rows}. ].
setPx := [:b :x :y :p | rows := b at: 'data'.
row := rows at: y.
row at: x put: p.
rows at: y put: row.
b at: 'data' put: rows. ].
getPx := [:b :x :y | b at: 'data' at: y at: x. ].
splitLines := [:s | out := {}.
cur := ''.
i := 0.
[(i < ((s size)))] whileTrue: [.
ch := (s copyFrom: i to: (i + 1)).
((ch = '
')) ifTrue: [
out := out copyWith: cur.
cur := ''.
] ifFalse: [
cur := (cur + ch).
].
i := (i + 1).
].
.
out := out copyWith: cur.
out. ].
splitWS := [:s | out := {}.
cur := ''.
i := 0.
[(i < ((s size)))] whileTrue: [.
ch := (s copyFrom: i to: (i + 1)).
((((((((ch = (' '))) or: [((ch = '	'))])) or: [((ch = ''))])) or: [((ch = '
'))])) ifTrue: [
((0 > 0)) ifTrue: [
out := out copyWith: cur.
cur := ''.
] .
] ifFalse: [
cur := (cur + ch).
].
i := (i + 1).
].
.
((((cur size)) > 0)) ifTrue: [
out := out copyWith: cur.
] .
out. ].
parseIntStr := [:str | i := 0.
neg := false.
((((((str size)) > 0)) and: [(((str copyFrom: (0 + 1) to: 1) = '-'))])) ifTrue: [
neg := true.
i := 1.
] .
n := 0.
digits := Dictionary from:{'0'->0. '1'->1. '2'->2. '3'->3. '4'->4. '5'->5. '6'->6. '7'->7. '8'->8. '9'->9}.
[(i < ((str size)))] whileTrue: [.
n := (((n * 10)) + (digits at: str copyFrom: (i + 1) to: (i + 1))).
i := (i + 1).
].
.
(neg) ifTrue: [
n := -n.
] .
n. ].
tokenize := [:s | lines := splitLines value: s.
toks := {}.
i := 0.
[.
[(i < ((lines size)))] whileTrue: [.
[.
line := lines at: i.
((((((line size)) > 0)) and: [((((line copyFrom: 0 to: 1)) = '#'))])) ifTrue: [
i := (i + 1).
ContinueSignal signal.
] .
parts := splitWS value: line.
j := 0.
[(j < ((parts size)))] whileTrue: [.
toks := toks copyWith: parts at: j.
j := (j + 1).
].
.
i := (i + 1).
] on: ContinueSignal do: [:ex | ].
].
] on: BreakSignal do: [:ex | ].
toks. ].
readP3 := [:text | toks := tokenize value: text.
((((toks size)) < 4)) ifTrue: [
newBitmap value: 0 value: 0 value: 0.
] .
(((toks at: 0) ~= 'P3')) ifTrue: [
newBitmap value: 0 value: 0 value: 0.
] .
w := parseIntStr value: toks at: 1.
h := parseIntStr value: toks at: 2.
maxv := parseIntStr value: toks at: 3.
idx := 4.
bm := newBitmap value: w value: h value: maxv.
y := (h - 1).
[(y >= 0)] whileTrue: [.
x := 0.
[(x < w)] whileTrue: [.
r := parseIntStr value: toks at: idx.
g := parseIntStr value: toks at: (idx + 1).
b := parseIntStr value: toks at: (idx + 2).
setPx value: bm value: x value: y value: Dictionary from:{'R'->r. 'G'->g. 'B'->b}.
idx := (idx + 3).
x := (x + 1).
].
.
y := (y - 1).
].
.
bm. ].
toGrey := [:b | h := b at: 'h'.
w := b at: 'w'.
m := 0.
y := 0.
[(y < h)] whileTrue: [.
x := 0.
[(x < w)] whileTrue: [.
p := getPx value: b value: x value: y.
l := (((((((p.R * 2126)) + ((p.G * 7152)))) + ((p.B * 722)))) / 10000).
((l > (b at: 'max'))) ifTrue: [
l := b at: 'max'.
] .
setPx value: b value: x value: y value: Dictionary from:{'R'->l. 'G'->l. 'B'->l}.
((l > m)) ifTrue: [
m := l.
] .
x := (x + 1).
].
.
y := (y + 1).
].
.
b at: 'max' put: m. ].
pad := [:n :w | s := (n asString).
[(((s size)) < w)] whileTrue: [.
s := ((' ') + s).
].
.
s. ].
writeP3 := [:b | h := b at: 'h'.
w := b at: 'w'.
max := b at: 'max'.
digits := ((max asString) size).
out := (((((((((((('P3
# generated from Bitmap.writeppmp3
') + ((w asString)))) + (' '))) + ((h asString)))) + '
')) + ((max asString)))) + '
').
y := (h - 1).
[(y >= 0)] whileTrue: [.
line := ''.
x := 0.
[(x < w)] whileTrue: [.
p := getPx value: b value: x value: y.
line := (((((((((((line + ('   '))) + (pad value: p.R value: digits))) + (' '))) + (pad value: p.G value: digits))) + (' '))) + (pad value: p.B value: digits)).
x := (x + 1).
].
.
out := (((out + line)) + '
').
y := (y - 1).
].
.
out. ].
ppmtxt := ((((((((((((('P3
' + ('# feep.ppm
'))) + ('4 4
'))) + '15
')) + (' 0  0  0    0  0  0    0  0  0   15  0 15
'))) + (' 0  0  0    0 15  7    0  0  0    0  0  0
'))) + (' 0  0  0    0  0  0    0 15  7    0  0  0
'))) + ('15  0 15    0  0  0    0  0  0    0  0  0
')).
Transcript show: 'Original Colour PPM file'; cr.
Transcript show: (ppmtxt) printString; cr.
bm := readP3 value: ppmtxt.
Transcript show: 'Grey PPM:'; cr.
toGrey value: bm.
out := writeP3 value: bm.
Transcript show: (out) printString; cr.
