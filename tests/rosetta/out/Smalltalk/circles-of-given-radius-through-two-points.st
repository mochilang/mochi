" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| sqrtApprox g i hypot Two R0 Co CoR0 Diam Far circles dx dy q m d ox oy td tc p1 p2 r res c1 c2 caseStr |
sqrtApprox := [:x | g := x.
i := 0.
[(i < 40)] whileTrue: [.
g := (((g + ((x / g)))) / 2).
i := (i + 1).
].
.
g. ].
hypot := [:x :y | sqrtApprox value: (((x * x)) + ((y * y))). ].
Two := 'Two circles.'.
R0 := 'R==0.0 does not describe circles.'.
Co := 'Coincident points describe an infinite number of circles.'.
CoR0 := 'Coincident points with r==0.0 describe a degenerate circle.'.
Diam := 'Points form a diameter and describe only a single circle.'.
Far := 'Points too far apart to form circles.'.
circles := [:p1 :p2 :r | (((((p1 at: 'x') = (p2 at: 'x'))) and: [(((p1 at: 'y') = (p2 at: 'y')))])) ifTrue: [
((r = 0)) ifTrue: [
{p1. p1. 'Coincident points with r==0.0 describe a degenerate circle.'}.
] .
{p1. p2. 'Coincident points describe an infinite number of circles.'}.
] .
((r = 0)) ifTrue: [
{p1. p2. 'R==0.0 does not describe circles.'}.
] .
dx := ((p2 at: 'x') - (p1 at: 'x')).
dy := ((p2 at: 'y') - (p1 at: 'y')).
q := hypot value: dx value: dy.
((q > ((2 * r)))) ifTrue: [
{p1. p2. 'Points too far apart to form circles.'}.
] .
m := Dictionary from:{'x'->((((p1 at: 'x') + (p2 at: 'x'))) / 2). 'y'->((((p1 at: 'y') + (p2 at: 'y'))) / 2)}.
((q = ((2 * r)))) ifTrue: [
{m. m. 'Points form a diameter and describe only a single circle.'}.
] .
d := sqrtApprox value: (((r * r)) - ((((q * q)) / 4))).
ox := (((d * dx)) / q).
oy := (((d * dy)) / q).
{Dictionary from:{'x'->(m.x - oy). 'y'->(m.y + ox)}. Dictionary from:{'x'->(m.x + oy). 'y'->(m.y - ox)}. 'Two circles.'}. ].
td := {{Dictionary from:{'x'->0.1234. 'y'->0.9876}. Dictionary from:{'x'->0.8765. 'y'->0.2345}. 2}. {Dictionary from:{'x'->0. 'y'->2}. Dictionary from:{'x'->0. 'y'->0}. 1}. {Dictionary from:{'x'->0.1234. 'y'->0.9876}. Dictionary from:{'x'->0.1234. 'y'->0.9876}. 2}. {Dictionary from:{'x'->0.1234. 'y'->0.9876}. Dictionary from:{'x'->0.8765. 'y'->0.2345}. 0.5}. {Dictionary from:{'x'->0.1234. 'y'->0.9876}. Dictionary from:{'x'->0.1234. 'y'->0.9876}. 0}}.
td do: [:tc |.
p1 := tc at: 0.
p2 := tc at: 1.
r := tc at: 2.
Transcript show: ((((((((('p1:  {') + ((p1 at: 'x' asString)))) + (' '))) + ((p1 at: 'y' asString)))) + '}')) printString; cr.
Transcript show: ((((((((('p2:  {') + ((p2 at: 'x' asString)))) + (' '))) + ((p2 at: 'y' asString)))) + '}')) printString; cr.
Transcript show: ((('r:  ') + ((r asString)))) printString; cr.
res := circles value: p1 value: p2 value: r.
c1 := res at: 0.
c2 := res at: 1.
caseStr := res at: 2.
Transcript show: ((('   ') + caseStr)) printString; cr.
((((caseStr = ('Points form a diameter and describe only a single circle.'))) or: [((caseStr = ('Coincident points with r==0.0 describe a degenerate circle.')))])) ifTrue: [
Transcript show: ((((((((('   Center:  {') + ((c1 at: 'x' asString)))) + (' '))) + ((c1 at: 'y' asString)))) + '}')) printString; cr.
] ifFalse: [
((caseStr = ('Two circles.'))) ifTrue: [
Transcript show: ((((((((('   Center 1:  {') + ((c1 at: 'x' asString)))) + (' '))) + ((c1 at: 'y' asString)))) + '}')) printString; cr.
Transcript show: ((((((((('   Center 2:  {') + ((c2 at: 'x' asString)))) + (' '))) + ((c2 at: 'y' asString)))) + '}')) printString; cr.
] .
].
Transcript show: ''; cr.
].
.
