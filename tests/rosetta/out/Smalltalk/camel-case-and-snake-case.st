" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| trimSpace start end isUpper padLeft res n snakeToCamel out up i ch camelToSnake prevUnd j lastUnd c main samples s |
Object subclass: #ContinueSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!.
trimSpace := [:s | start := 0.
[(((start < ((s size)))) and: [(((s copyFrom: (start + 1) to: (start + 1)) = (' ')))])] whileTrue: [.
start := (start + 1).
].
.
end := (s size).
[(((end > start)) and: [(((s copyFrom: ((end - 1) + 1) to: end) = (' ')))])] whileTrue: [.
end := (end - 1).
].
.
s copyFrom: (start + 1) to: end. ].
isUpper := [:ch | (((ch >= 'A')) and: [((ch <= 'Z'))]). ].
padLeft := [:s :w | res := ''.
n := (w - ((s size))).
[(n > 0)] whileTrue: [.
res := (res + (' ')).
n := (n - 1).
].
.
(res + s). ].
snakeToCamel := [:s | s := trimSpace value: s.
out := ''.
up := false.
i := 0.
[.
[(i < ((s size)))] whileTrue: [.
[.
ch := s copyFrom: (i + 1) to: (i + 1).
((((((((ch = '_')) or: [((ch = '-'))])) or: [((ch = (' ')))])) or: [((ch = '.'))])) ifTrue: [
up := true.
i := (i + 1).
ContinueSignal signal.
] .
((i = 0)) ifTrue: [
out := (out + (lower value: ch)).
up := false.
i := (i + 1).
ContinueSignal signal.
] .
(up) ifTrue: [
out := (out + (upper value: ch)).
up := false.
] ifFalse: [
out := (out + ch).
].
i := (i + 1).
] on: ContinueSignal do: [:ex | ].
].
] on: BreakSignal do: [:ex | ].
out. ].
camelToSnake := [:s | s := trimSpace value: s.
out := ''.
prevUnd := false.
i := 0.
[.
[(i < ((s size)))] whileTrue: [.
[.
ch := s copyFrom: (i + 1) to: (i + 1).
((((((ch = (' '))) or: [((ch = '-'))])) or: [((ch = '.'))])) ifTrue: [
(((prevUnd not) and: [((0 > 0))])) ifTrue: [
out := (out + '_').
prevUnd := true.
] .
i := (i + 1).
ContinueSignal signal.
] .
((ch = '_')) ifTrue: [
(((prevUnd not) and: [((((out size)) > 0))])) ifTrue: [
out := (out + '_').
prevUnd := true.
] .
i := (i + 1).
ContinueSignal signal.
] .
(isUpper value: ch) ifTrue: [
((((i > 0)) and: [(prevUnd not)])) ifTrue: [
out := (out + '_').
] .
out := (out + (lower value: ch)).
prevUnd := false.
] ifFalse: [
out := (out + (lower value: ch)).
prevUnd := false.
].
i := (i + 1).
] on: ContinueSignal do: [:ex | ].
].
] on: BreakSignal do: [:ex | ].
start := 0.
[(((start < ((out size)))) and: [(((out copyFrom: (start + 1) to: (start + 1)) = '_'))])] whileTrue: [.
start := (start + 1).
].
.
end := (out size).
[(((end > start)) and: [(((out copyFrom: ((end - 1) + 1) to: end) = '_'))])] whileTrue: [.
end := (end - 1).
].
.
out := out copyFrom: (start + 1) to: end.
res := ''.
j := 0.
lastUnd := false.
[(j < ((out size)))] whileTrue: [.
c := out copyFrom: (j + 1) to: (j + 1).
((c = '_')) ifTrue: [
(lastUnd not) ifTrue: [
res := (res + c).
] .
lastUnd := true.
] ifFalse: [
res := (res + c).
lastUnd := false.
].
j := (j + 1).
].
.
res. ].
main := [ samples := {'snakeCase'. 'snake_case'. 'snake-case'. 'snake case'. 'snake CASE'. 'snake.case'. 'variable_10_case'. 'variable10Case'. 'É›rgo rE tHis'. 'hurry-up-joe!'. 'c://my-docs/happy_Flag-Day/12.doc'. ' spaces '}.
Transcript show: '=== To snake_case ==='; cr.
samples do: [:s |.
Transcript show: (((((padLeft value: s value: 34) + (' => '))) + (camelToSnake value: s))) printString; cr.
].
.
Transcript show: ''; cr.
Transcript show: '=== To camelCase ==='; cr.
samples do: [:s |.
Transcript show: (((((padLeft value: s value: 34) + (' => '))) + (snakeToCamel value: s))) printString; cr.
].
. ].
main value.
