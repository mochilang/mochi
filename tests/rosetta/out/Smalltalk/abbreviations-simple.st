" Generated by Mochi compiler v0.10.26 on 2025-07-16T09:48:35Z
"
| c ch ci cmd cmds commands cur digits fields found i isDigits join k main minlen mins n neg num out out1 padRight parseIntStr readTable res results sentence table tbl toks validate w wi wlen words ww |
Object subclass: #BreakSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!
fields := [:s | words := {}.
cur := ''.
i := 0.
[(i < (s size))] whileTrue: [
  ch := (s copyFrom: i to: (i + 1)).
  ((((ch = ' ') or: [(ch = '
')]) or: [(ch = '	')])) ifTrue: [
    (((cur size) > 0)) ifTrue: [
      words := words copyWith: cur.
      cur := ''.
    ] .
  ] ifFalse: [
    cur := (cur + ch).
  ].
  i := (i + 1).
]
.
(((cur size) > 0)) ifTrue: [
  words := words copyWith: cur.
] .
words ].
padRight := [:s :width | out := s.
i := (s size).
[(i < width)] whileTrue: [
  out := (out + ' ').
  i := (i + 1).
]
.
out ].
join := [:xs :sep | res := ''.
i := 0.
[(i < (xs size))] whileTrue: [
  ((i > 0)) ifTrue: [
    res := (res + sep).
  ] .
  res := (res + xs at: i).
  i := (i + 1).
]
.
res ].
parseIntStr := [:str | i := 0.
neg := false.
((((str size) > 0) and: [(str at: 0 = '-')])) ifTrue: [
  neg := true.
  i := 1.
] .
n := 0.
digits := Dictionary from: {'0' -> 0. '1' -> 1. '2' -> 2. '3' -> 3. '4' -> 4. '5' -> 5. '6' -> 6. '7' -> 7. '8' -> 8. '9' -> 9}.
[(i < (str size))] whileTrue: [
  n := ((n * 10) + digits at: str at: i).
  i := (i + 1).
]
.
(neg) ifTrue: [
  n := -n.
] .
n ].
isDigits := [:s | (((s size) = 0)) ifTrue: [
  false
] .
i := 0.
[(i < (s size))] whileTrue: [
  ch := (s copyFrom: i to: (i + 1)).
  (((ch < '0') or: [(ch > '9')])) ifTrue: [
    false
  ] .
  i := (i + 1).
]
.
true ].
readTable := [:table | toks := fields value: table.
cmds := {}.
mins := {}.
i := 0.
[(i < (toks size))] whileTrue: [
  cmd := toks at: i.
  minlen := (cmd size).
  i := (i + 1).
  (((i < (toks size)) and: [isDigits value: toks at: i])) ifTrue: [
    num := parseIntStr value: toks at: i.
    (((num >= 1) and: [(num < (cmd size))])) ifTrue: [
      minlen := num.
      i := (i + 1).
    ] .
  ] .
  cmds := cmds copyWith: cmd.
  mins := mins copyWith: minlen.
]
.
Dictionary from: {'commands' -> cmds. 'mins' -> mins} ].
validate := [:commands :mins :words | results := {}.
wi := 0.
[
  [(wi < (words size))] whileTrue: [
    w := words at: wi.
    found := false.
    wlen := (w size).
    ci := 0.
    [
      [(ci < (commands size))] whileTrue: [
        cmd := commands at: ci.
        ((((mins at: ci ~= 0) and: [(wlen >= mins at: ci)]) and: [(wlen <= (cmd size))])) ifTrue: [
          c := upper value: cmd.
          ww := upper value: w.
          (((c copyFrom: 0 to: wlen) = ww)) ifTrue: [
            results := results copyWith: c.
            found := true.
            BreakSignal signal
          ] .
        ] .
        ci := (ci + 1).
      ]
    ] on: BreakSignal do: [:ex | ].
    (found not) ifTrue: [
      results := results copyWith: '*error*'.
    ] .
    wi := (wi + 1).
  ]
] on: BreakSignal do: [:ex | ].
results ].
main := [ | table := (((((((('' + 'add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ') + 'compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ') + '3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ') + 'forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ') + 'locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ') + 'msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ') + 'refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ') + '2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ').
sentence := 'riG   rePEAT copies  put mo   rest    types   fup.    6
poweRin'.
tbl := readTable value: table.
commands := tbl at: 'commands'.
mins := tbl at: 'mins'.
words := fields value: sentence.
results := validate value: commands value: mins value: words.
out1 := 'user words:'.
k := 0.
[(k < (words size))] whileTrue: [
  out1 := (out1 + ' ').
  ((k < ((words size) - 1))) ifTrue: [
    out1 := (out1 + padRight value: words at: k value: (results at: k size)).
  ] ifFalse: [
    out1 := (out1 + words at: k).
  ].
  k := (k + 1).
]
.
Transcript show: (out1) printString; cr.
Transcript show: (('full words: ' + join value: results value: ' ')) printString; cr. ].
main value.
