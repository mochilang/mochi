" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| parseIntDigits n i digits ch parseDC neg dollars cents seenDot centDigits d val parseRate whole frac dcString c cstr extend tax padLeft out main hp mp rate totalBeforeTax t total |
Object subclass: #ContinueSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!.
parseIntDigits := [:s | n := 0.
i := 0.
digits := Dictionary from:{'0'->0. '1'->1. '2'->2. '3'->3. '4'->4. '5'->5. '6'->6. '7'->7. '8'->8. '9'->9}.
[(i < ((s size)))] whileTrue: [.
ch := s copyFrom: (i + 1) to: (i + 1).
((digits includes: ch) not) ifTrue: [
0.
] .
n := (((n * 10)) + (digits at: ch)).
i := (i + 1).
].
.
n. ].
parseDC := [:s | neg := false.
((((((s size)) > 0)) and: [(((s copyFrom: (0 + 1) to: 1) = '-'))])) ifTrue: [
neg := true.
s := (s copyFrom: 1 to: (s size)).
] .
dollars := 0.
cents := 0.
i := 0.
seenDot := false.
centDigits := 0.
[.
[(i < ((s size)))] whileTrue: [.
[.
ch := s copyFrom: (i + 1) to: (i + 1).
((ch = '.')) ifTrue: [
seenDot := true.
i := (i + 1).
ContinueSignal signal.
] .
d := parseIntDigits value: ch.
(seenDot) ifTrue: [
((centDigits < 2)) ifTrue: [
cents := (((cents * 10)) + d).
centDigits := (centDigits + 1).
] .
] ifFalse: [
dollars := (((dollars * 10)) + d).
].
i := (i + 1).
] on: ContinueSignal do: [:ex | ].
].
] on: BreakSignal do: [:ex | ].
((centDigits = 1)) ifTrue: [
cents := (cents * 10).
] .
val := (((dollars * 100)) + cents).
(neg) ifTrue: [
val := -val.
] .
val. ].
parseRate := [:s | neg := false.
((((((s size)) > 0)) and: [(((s copyFrom: (0 + 1) to: 1) = '-'))])) ifTrue: [
neg := true.
s := (s copyFrom: 1 to: (s size)).
] .
whole := 0.
frac := 0.
digits := 0.
seenDot := false.
i := 0.
[.
[(i < ((s size)))] whileTrue: [.
[.
ch := s copyFrom: (i + 1) to: (i + 1).
((ch = '.')) ifTrue: [
seenDot := true.
i := (i + 1).
ContinueSignal signal.
] .
d := parseIntDigits value: ch.
(seenDot) ifTrue: [
((digits < 4)) ifTrue: [
frac := (((frac * 10)) + d).
digits := (digits + 1).
] .
] ifFalse: [
whole := (((whole * 10)) + d).
].
i := (i + 1).
] on: ContinueSignal do: [:ex | ].
].
] on: BreakSignal do: [:ex | ].
[(digits < 4)] whileTrue: [.
frac := (frac * 10).
digits := (digits + 1).
].
.
val := (((whole * 10000)) + frac).
(neg) ifTrue: [
val := -val.
] .
val. ].
dcString := [:dc | d := (dc / 100).
n := dc.
((n < 0)) ifTrue: [
n := -n.
] .
c := (n % 100).
cstr := (c asString).
((((cstr size)) = 1)) ifTrue: [
cstr := ('0' + cstr).
] .
(((((d asString)) + '.')) + cstr). ].
extend := [:dc :n | (dc * n). ].
tax := [:total :rate | (((((total * rate)) + 5000)) / 10000) asInteger. ].
padLeft := [:s :n | out := s.
[(((out size)) < n)] whileTrue: [.
out := ((' ') + out).
].
.
out. ].
main := [ hp := parseDC value: '5.50'.
mp := parseDC value: '2.86'.
rate := parseRate value: '0.0765'.
totalBeforeTax := ((extend value: hp value: 4000000000000000) + (extend value: mp value: 2)).
t := tax value: totalBeforeTax value: rate.
total := (totalBeforeTax + t).
Transcript show: ((('Total before tax: ') + (padLeft value: dcString value: totalBeforeTax value: 22))) printString; cr.
Transcript show: ((('             Tax: ') + (padLeft value: dcString value: t value: 22))) printString; cr.
Transcript show: ((('           Total: ') + (padLeft value: dcString value: total value: 22))) printString; cr. ].
main value.
