" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| indexOf i fmt4 y s dot decs fmt2 sumPoint mulPoint divPoint centerPoint getFacePoints facePoints face fp idx sortEdges res tmp min j e out k getEdgesFaces edges fnum numP pi pn1 pn2 tmpn merged e1 e2 edgesCenters me p1 p2 cp getEdgePoints edgePoints edge fp1 fp2 cfp getAvgFacePoints temp pn tp avg getAvgMidEdges arr getPointsFaces pf getNewPoints newPts n m1 m2 m3 old p3 key cmcSubdiv edgesFaces avgFacePoints avgMidEdges pointsFaces newPoints facePointNums nextPoint edgePointNums newFaces oldFace a b c d fpnum ab da bc cd formatPoint formatFace main inputPoints inputFaces outputPoints outputFaces p f |
Object subclass: #ContinueSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!.
indexOf := [:s :ch | i := 0.
[(i < ((s size)))] whileTrue: [.
((((s copyFrom: i to: (i + 1))) = ch)) ifTrue: [
i.
] .
i := (i + 1).
].
.
-1. ].
fmt4 := [:x | y := (x * 10000).
((y >= 0)) ifTrue: [
y := (y + 0.5).
] ifFalse: [
y := (y - 0.5).
].
y := ((y asInteger asFloat) / 10000).
s := (y asString).
dot := indexOf value: s value: '.'.
((dot = ((0 - 1)))) ifTrue: [
s := (s + '.0000').
] ifFalse: [
decs := (((((s size)) - dot)) - 1).
((decs > 4)) ifTrue: [
s := (s copyFrom: 0 to: (dot + 5)).
] ifFalse: [
[(decs < 4)] whileTrue: [.
s := (s + '0').
decs := (decs + 1).
].
.
].
].
((x >= 0)) ifTrue: [
s := ((' ') + s).
] .
s. ].
fmt2 := [:n | s := (n asString).
((((s size)) < 2)) ifTrue: [
((' ') + s).
] .
s. ].
sumPoint := [:p1 :p2 | Dictionary from:{'x'->((p1 at: 'x') + (p2 at: 'x')). 'y'->((p1 at: 'y') + (p2 at: 'y')). 'z'->((p1 at: 'z') + (p2 at: 'z'))}. ].
mulPoint := [:p :m | Dictionary from:{'x'->((p at: 'x') * m). 'y'->((p at: 'y') * m). 'z'->((p at: 'z') * m)}. ].
divPoint := [:p :d | mulPoint value: p value: (1 / d). ].
centerPoint := [:p1 :p2 | divPoint value: sumPoint value: p1 value: p2 value: 2. ].
getFacePoints := [:points :faces | facePoints := {}.
i := 0.
[(i < ((faces size)))] whileTrue: [.
face := faces at: i.
fp := Dictionary from:{'x'->0. 'y'->0. 'z'->0}.
face do: [:idx |.
fp := sumPoint value: fp value: points at: idx.
].
.
fp := divPoint value: fp value: (face size) asFloat.
facePoints := facePoints copyWith: fp.
i := (i + 1).
].
.
facePoints. ].
sortEdges := [:edges | res := {}.
tmp := edges.
[(((tmp size)) > 0)] whileTrue: [.
min := tmp at: 0.
idx := 0.
j := 1.
[(j < ((tmp size)))] whileTrue: [.
e := tmp at: j.
(((((e at: 0) < (min at: 0))) or: [(((((e at: 0) = (min at: 0))) and: [(((((e at: 1) < (min at: 1))) or: [(((((e at: 1) = (min at: 1))) and: [(((e at: 2) < (min at: 2)))]))]))]))])) ifTrue: [
min := e.
idx := j.
] .
j := (j + 1).
].
.
res := res copyWith: min.
out := {}.
k := 0.
[(k < ((tmp size)))] whileTrue: [.
((k ~= idx)) ifTrue: [
out := out copyWith: tmp at: k.
] .
k := (k + 1).
].
.
tmp := out.
].
.
res. ].
getEdgesFaces := [:points :faces | edges := {}.
fnum := 0.
[(fnum < ((faces size)))] whileTrue: [.
face := faces at: fnum.
numP := (face size).
pi := 0.
[(pi < numP)] whileTrue: [.
pn1 := face at: pi.
pn2 := 0.
((pi < ((numP - 1)))) ifTrue: [
pn2 := face at: (pi + 1).
] ifFalse: [
pn2 := face at: 0.
].
((pn1 > pn2)) ifTrue: [
tmpn := pn1.
pn1 := pn2.
pn2 := tmpn.
] .
edges := edges copyWith: {pn1. pn2. fnum}.
pi := (pi + 1).
].
.
fnum := (fnum + 1).
].
.
edges := sortEdges value: edges.
merged := {}.
idx := 0.
[.
[(idx < ((edges size)))] whileTrue: [.
[.
e1 := edges at: idx.
((idx < ((((edges size)) - 1)))) ifTrue: [
e2 := edges at: (idx + 1).
(((((e1 at: 0) = (e2 at: 0))) and: [(((e1 at: 1) = (e2 at: 1)))])) ifTrue: [
merged := merged copyWith: {e1 at: 0. e1 at: 1. e1 at: 2. e2 at: 2}.
idx := (idx + 2).
ContinueSignal signal.
] .
] .
merged := merged copyWith: {e1 at: 0. e1 at: 1. e1 at: 2. -1}.
idx := (idx + 1).
] on: ContinueSignal do: [:ex | ].
].
] on: BreakSignal do: [:ex | ].
edgesCenters := {}.
merged do: [:me |.
p1 := points at: me at: 0.
p2 := points at: me at: 1.
cp := centerPoint value: p1 value: p2.
edgesCenters := edgesCenters copyWith: Dictionary from:{'pn1'->me at: 0. 'pn2'->me at: 1. 'fn1'->me at: 2. 'fn2'->me at: 3. 'cp'->cp}.
].
.
edgesCenters. ].
getEdgePoints := [:points :edgesFaces :facePoints | edgePoints := {}.
i := 0.
[(i < ((edgesFaces size)))] whileTrue: [.
edge := edgesFaces at: i.
cp := edge.cp.
fp1 := facePoints at: edge.fn1.
fp2 := fp1.
((edge.fn2 ~= ((0 - 1)))) ifTrue: [
fp2 := facePoints at: edge.fn2.
] .
cfp := centerPoint value: fp1 value: fp2.
edgePoints := edgePoints copyWith: centerPoint value: cp value: cfp.
i := (i + 1).
].
.
edgePoints. ].
getAvgFacePoints := [:points :faces :facePoints | numP := (points size).
temp := {}.
i := 0.
[(i < numP)] whileTrue: [.
temp := temp copyWith: Dictionary from:{'p'->Dictionary from:{'x'->0. 'y'->0. 'z'->0}. 'n'->0}.
i := (i + 1).
].
.
fnum := 0.
[(fnum < ((faces size)))] whileTrue: [.
fp := facePoints at: fnum.
faces at: fnum do: [:pn |.
tp := temp at: pn.
temp at: pn put: Dictionary from:{'p'->sumPoint value: tp.p value: fp. 'n'->(tp.n + 1)}.
].
.
fnum := (fnum + 1).
].
.
avg := {}.
j := 0.
[(j < numP)] whileTrue: [.
tp := temp at: j.
avg := avg copyWith: divPoint value: tp.p value: tp.n asFloat.
j := (j + 1).
].
.
avg. ].
getAvgMidEdges := [:points :edgesFaces | numP := (points size).
temp := {}.
i := 0.
[(i < numP)] whileTrue: [.
temp := temp copyWith: Dictionary from:{'p'->Dictionary from:{'x'->0. 'y'->0. 'z'->0}. 'n'->0}.
i := (i + 1).
].
.
edgesFaces do: [:edge |.
cp := edge.cp.
arr := {edge.pn1. edge.pn2}.
arr do: [:pn |.
tp := temp at: pn.
temp at: pn put: Dictionary from:{'p'->sumPoint value: tp.p value: cp. 'n'->(tp.n + 1)}.
].
.
].
.
avg := {}.
j := 0.
[(j < numP)] whileTrue: [.
tp := temp at: j.
avg := avg copyWith: divPoint value: tp.p value: tp.n asFloat.
j := (j + 1).
].
.
avg. ].
getPointsFaces := [:points :faces | pf := {}.
i := 0.
[(i < ((points size)))] whileTrue: [.
pf := pf copyWith: 0.
i := (i + 1).
].
.
fnum := 0.
[(fnum < ((faces size)))] whileTrue: [.
faces at: fnum do: [:pn |.
pf at: pn put: ((pf at: pn) + 1).
].
.
fnum := (fnum + 1).
].
.
pf. ].
getNewPoints := [:points :pf :afp :ame | newPts := {}.
i := 0.
[(i < ((points size)))] whileTrue: [.
n := pf at: i asFloat.
m1 := (((n - 3)) / n).
m2 := (1 / n).
m3 := (2 / n).
old := points at: i.
p1 := mulPoint value: old value: m1.
p2 := mulPoint value: afp at: i value: m2.
p3 := mulPoint value: ame at: i value: m3.
newPts := newPts copyWith: sumPoint value: sumPoint value: p1 value: p2 value: p3.
i := (i + 1).
].
.
newPts. ].
key := [:a :b | ((a < b)) ifTrue: [
(((((a asString)) + ',')) + ((b asString))).
] .
(((((b asString)) + ',')) + ((a asString))). ].
cmcSubdiv := [:points :faces | facePoints := getFacePoints value: points value: faces.
edgesFaces := getEdgesFaces value: points value: faces.
edgePoints := getEdgePoints value: points value: edgesFaces value: facePoints.
avgFacePoints := getAvgFacePoints value: points value: faces value: facePoints.
avgMidEdges := getAvgMidEdges value: points value: edgesFaces.
pointsFaces := getPointsFaces value: points value: faces.
newPoints := getNewPoints value: points value: pointsFaces value: avgFacePoints value: avgMidEdges.
facePointNums := {}.
nextPoint := (newPoints size).
facePoints do: [:fp |.
newPoints := newPoints copyWith: fp.
facePointNums := facePointNums copyWith: nextPoint.
nextPoint := (nextPoint + 1).
].
.
edgePointNums := Dictionary from:{}.
idx := 0.
[(idx < ((edgesFaces size)))] whileTrue: [.
e := edgesFaces at: idx.
newPoints := newPoints copyWith: edgePoints at: idx.
edgePointNums at: key value: e.pn1 value: e.pn2 put: nextPoint.
nextPoint := (nextPoint + 1).
idx := (idx + 1).
].
.
newFaces := {}.
fnum := 0.
[(fnum < ((faces size)))] whileTrue: [.
oldFace := faces at: fnum.
((((oldFace size)) = 4)) ifTrue: [
a := oldFace at: 0.
b := oldFace at: 1.
c := oldFace at: 2.
d := oldFace at: 3.
fpnum := facePointNums at: fnum.
ab := edgePointNums at: key value: a value: b.
da := edgePointNums at: key value: d value: a.
bc := edgePointNums at: key value: b value: c.
cd := edgePointNums at: key value: c value: d.
newFaces := newFaces copyWith: {a. ab. fpnum. da}.
newFaces := newFaces copyWith: {b. bc. fpnum. ab}.
newFaces := newFaces copyWith: {c. cd. fpnum. bc}.
newFaces := newFaces copyWith: {d. da. fpnum. cd}.
] .
fnum := (fnum + 1).
].
.
{newPoints. newFaces}. ].
formatPoint := [:p | ((((((((((('[' + (fmt4 value: p at: 'x'))) + (' '))) + (fmt4 value: p at: 'y'))) + (' '))) + (fmt4 value: p at: 'z'))) + ']'). ].
formatFace := [:f | ((((f size)) = 0)) ifTrue: [
'[]'.
] .
s := ('[' + (fmt2 value: f at: 0)).
i := 1.
[(i < ((f size)))] whileTrue: [.
s := (((s + (' '))) + (fmt2 value: f at: i)).
i := (i + 1).
].
.
s := (s + ']').
s. ].
main := [ inputPoints := {Dictionary from:{'x'->-1. 'y'->1. 'z'->1}. Dictionary from:{'x'->-1. 'y'->-1. 'z'->1}. Dictionary from:{'x'->1. 'y'->-1. 'z'->1}. Dictionary from:{'x'->1. 'y'->1. 'z'->1}. Dictionary from:{'x'->1. 'y'->-1. 'z'->-1}. Dictionary from:{'x'->1. 'y'->1. 'z'->-1}. Dictionary from:{'x'->-1. 'y'->-1. 'z'->-1}. Dictionary from:{'x'->-1. 'y'->1. 'z'->-1}}.
inputFaces := {{0. 1. 2. 3}. {3. 2. 4. 5}. {5. 4. 6. 7}. {7. 0. 3. 5}. {7. 6. 1. 0}. {6. 1. 2. 4}}.
outputPoints := inputPoints.
outputFaces := inputFaces.
i := 0.
[(i < 1)] whileTrue: [.
res := cmcSubdiv value: outputPoints value: outputFaces.
outputPoints := res at: 0.
outputFaces := res at: 1.
i := (i + 1).
].
.
outputPoints do: [:p |.
Transcript show: (formatPoint value: p) printString; cr.
].
.
Transcript show: ''; cr.
outputFaces do: [:f |.
Transcript show: (formatFace value: f) printString; cr.
].
. ].
main value.
