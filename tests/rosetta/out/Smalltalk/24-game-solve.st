" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| OP_NUM OP_ADD OP_SUB OP_MUL OP_DIV newNum exprEval l r exprString ls rs opstr n_cards goal digit_range solve f i j rest k a b op node main iter cards n |
OP_NUM := 0.
OP_ADD := 1.
OP_SUB := 2.
OP_MUL := 3.
OP_DIV := 4.
newNum := [:n | Dictionary from:{'op'->OP_NUM. 'value'->(Dictionary from:{'num'->n. 'denom'->1})}. ].
exprEval := [:x | (((x at: 'op') = OP_NUM)) ifTrue: [
x at: 'value'.
] .
l := exprEval value: x at: 'left'.
r := exprEval value: x at: 'right'.
(((x at: 'op') = OP_ADD)) ifTrue: [
Dictionary from:{'num'->(((((l at: 'num') * (r at: 'denom'))) + (((l at: 'denom') * (r at: 'num'))))). 'denom'->(((l at: 'denom') * (r at: 'denom')))}.
] .
(((x at: 'op') = OP_SUB)) ifTrue: [
Dictionary from:{'num'->(((((l at: 'num') * (r at: 'denom'))) - (((l at: 'denom') * (r at: 'num'))))). 'denom'->(((l at: 'denom') * (r at: 'denom')))}.
] .
(((x at: 'op') = OP_MUL)) ifTrue: [
Dictionary from:{'num'->(((l at: 'num') * (r at: 'num'))). 'denom'->(((l at: 'denom') * (r at: 'denom')))}.
] .
Dictionary from:{'num'->(((l at: 'num') * (r at: 'denom'))). 'denom'->(((l at: 'denom') * (r at: 'num')))}. ].
exprString := [:x | (((x at: 'op') = OP_NUM)) ifTrue: [
(x at: 'value' at: 'num' asString).
] .
ls := exprString value: x at: 'left'.
rs := exprString value: x at: 'right'.
opstr := ''.
(((x at: 'op') = OP_ADD)) ifTrue: [
opstr := ' + '.
] ifFalse: [
(((x at: 'op') = OP_SUB)) ifTrue: [
opstr := ' - '.
] ifFalse: [
(((x at: 'op') = OP_MUL)) ifTrue: [
opstr := ' * '.
] ifFalse: [
opstr := ' / '.
].
].
].
((((((('(' + ls)) + opstr)) + rs)) + ')'). ].
n_cards := 4.
goal := 24.
digit_range := 9.
solve := [:xs | ((((xs size)) = 1)) ifTrue: [
f := exprEval value: xs at: 0.
(((((f at: 'denom') ~= 0)) and: [(((f at: 'num') = (((f at: 'denom') * goal))))])) ifTrue: [
Transcript show: (exprString value: xs at: 0) printString; cr.
true.
] .
false.
] .
i := 0.
[(i < ((xs size)))] whileTrue: [.
j := (i + 1).
[(j < ((xs size)))] whileTrue: [.
rest := {}.
k := 0.
[(k < ((xs size)))] whileTrue: [.
((((k ~= i)) and: [((k ~= j))])) ifTrue: [
rest := rest copyWith: xs at: k.
] .
k := (k + 1).
].
.
a := xs at: i.
b := xs at: j.
{OP_ADD. OP_SUB. OP_MUL. OP_DIV} do: [:op |.
node := Dictionary from:{'op'->op. 'left'->a. 'right'->b}.
(solve value: rest copyWith: node) ifTrue: [
true.
] .
].
.
node := Dictionary from:{'op'->OP_SUB. 'left'->b. 'right'->a}.
(solve value: rest copyWith: node) ifTrue: [
true.
] .
node := Dictionary from:{'op'->OP_DIV. 'left'->b. 'right'->a}.
(solve value: rest copyWith: node) ifTrue: [
true.
] .
j := (j + 1).
].
.
i := (i + 1).
].
.
false. ].
main := [ iter := 0.
[(iter < 10)] whileTrue: [.
cards := {}.
i := 0.
[(i < n_cards)] whileTrue: [.
n := ((((now value) % ((digit_range - 1)))) + 1).
cards := cards copyWith: newNum value: n.
Transcript show: (((' ') + ((n asString)))) printString; cr.
i := (i + 1).
].
.
Transcript show: ':  '; cr.
(solve value: cards not) ifTrue: [
Transcript show: 'No solution'; cr.
] .
iter := (iter + 1).
].
. ].
main value.
