" Generated by Mochi compiler v0.10.26 on 2025-07-16T09:48:35Z
"
| a count g getCombs i isUnique j nums r1 r2 r3 s square1 square2 square3 square4 valid validComb |
Object subclass: #ContinueSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!
validComb := [:a :b :c :d :e :f :g | square1 := (a + b).
square2 := ((b + c) + d).
square3 := ((d + e) + f).
square4 := (f + g).
(((square1 = square2) and: [(square2 = square3)]) and: [(square3 = square4)]) ].
isUnique := [:a :b :c :d :e :f :g | nums := {a. b. c. d. e. f. g}.
i := 0.
[(i < (nums size))] whileTrue: [
  j := (i + 1).
  [(j < (nums size))] whileTrue: [
    ((nums at: i = nums at: j)) ifTrue: [
      false
    ] .
    j := (j + 1).
  ]
  .
  i := (i + 1).
]
.
true ].
getCombs := [:low :high :unique | valid := {}.
count := 0.
[
  low to: (high + 1) do: [:b |
    [
      [
        low to: (high + 1) do: [:c |
          [
            [
              low to: (high + 1) do: [:d |
                [
                  s := ((b + c) + d).
                  [
                    low to: (high + 1) do: [:e |
                      [
                        [
                          low to: (high + 1) do: [:f |
                            [
                              a := (s - b).
                              g := (s - f).
                              (((a < low) or: [(a > high)])) ifTrue: [
                                ContinueSignal signal
                              ] .
                              (((g < low) or: [(g > high)])) ifTrue: [
                                ContinueSignal signal
                              ] .
                              ((((d + e) + f) ~= s)) ifTrue: [
                                ContinueSignal signal
                              ] .
                              (((f + g) ~= s)) ifTrue: [
                                ContinueSignal signal
                              ] .
                              ((unique not or: [isUnique value: a value: b value: c value: d value: e value: f value: g])) ifTrue: [
                                valid := valid copyWith: {a. b. c. d. e. f. g}.
                                count := (count + 1).
                              ] .
                            ] on: ContinueSignal do: [:ex | ]
                          ]
                        ] on: BreakSignal do: [:ex | ].
                      ] on: ContinueSignal do: [:ex | ]
                    ]
                  ] on: BreakSignal do: [:ex | ].
                ] on: ContinueSignal do: [:ex | ]
              ]
            ] on: BreakSignal do: [:ex | ].
          ] on: ContinueSignal do: [:ex | ]
        ]
      ] on: BreakSignal do: [:ex | ].
    ] on: ContinueSignal do: [:ex | ]
  ]
] on: BreakSignal do: [:ex | ].
Dictionary from: {'count' -> count. 'list' -> valid} ].
r1 := getCombs value: 1 value: 7 value: true.
Transcript show: (((r1 at: 'count' asString) + ' unique solutions in 1 to 7')) printString; cr.
Transcript show: (r1 at: 'list') printString; cr.
r2 := getCombs value: 3 value: 9 value: true.
Transcript show: (((r2 at: 'count' asString) + ' unique solutions in 3 to 9')) printString; cr.
Transcript show: (r2 at: 'list') printString; cr.
r3 := getCombs value: 0 value: 9 value: false.
Transcript show: (((r3 at: 'count' asString) + ' non-unique solutions in 0 to 9')) printString; cr.
