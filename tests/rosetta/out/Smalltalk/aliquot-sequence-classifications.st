" Generated by Mochi compiler v0.10.26 on 2025-07-16T09:48:35Z
"
| THRESHOLD aliquot big classifySequence contains i indexOf intSqrt joinWithCommas k last main maxOf n padLeft padRight r res s seq sqrt sum sumProperDivisors val x y |
THRESHOLD := 140737488355328.
indexOf := [:xs :value | i := 0.
[(i < (xs size))] whileTrue: [
  ((xs at: i = value)) ifTrue: [
    i
  ] .
  i := (i + 1).
]
.
(0 - 1) ].
contains := [:xs :value | (indexOf value: xs value: value ~= (0 - 1)) ].
maxOf := [:a :b | ((a > b)) ifTrue: [
  a
] ifFalse: [
  b
]. ].
intSqrt := [:n | ((n = 0)) ifTrue: [
  0
] .
x := n.
y := ((x + 1) / 2).
[(y < x)] whileTrue: [
  x := y.
  y := ((x + (n / x)) / 2).
]
.
x ].
sumProperDivisors := [:n | ((n < 2)) ifTrue: [
  0
] .
sqrt := intSqrt value: n.
sum := 1.
i := 2.
[(i <= sqrt)] whileTrue: [
  (((n % i) = 0)) ifTrue: [
    sum := ((sum + i) + (n / i)).
  ] .
  i := (i + 1).
]
.
(((sqrt * sqrt) = n)) ifTrue: [
  sum := (sum - sqrt).
] .
sum ].
classifySequence := [:k | last := k.
seq := {k}.
[true] whileTrue: [
  last := sumProperDivisors value: last.
  seq := seq copyWith: last.
  n := (seq size).
  aliquot := ''.
  ((last = 0)) ifTrue: [
    aliquot := 'Terminating'.
  ] ifFalse: [
    (((n = 2) and: [(last = k)])) ifTrue: [
      aliquot := 'Perfect'.
    ] ifFalse: [
      (((n = 3) and: [(last = k)])) ifTrue: [
        aliquot := 'Amicable'.
      ] ifFalse: [
        (((n >= 4) and: [(last = k)])) ifTrue: [
          aliquot := (('Sociable[' + ((n - 1) asString)) + ']').
        ] ifFalse: [
          ((last = seq at: (n - 2))) ifTrue: [
            aliquot := 'Aspiring'.
          ] ifFalse: [
            (contains value: seq at: 1 value: last) ifTrue: [
              idx := indexOf value: seq value: last.
              aliquot := (('Cyclic[' + (((n - 1) - idx) asString)) + ']').
            ] ifFalse: [
              (((n = 16) or: [(last > THRESHOLD)])) ifTrue: [
                aliquot := 'Non-Terminating'.
              ] .
            ].
          ].
        ].
      ].
    ].
  ].
  ((aliquot ~= '')) ifTrue: [
    Dictionary from: {'seq' -> seq. 'aliquot' -> aliquot}
  ] .
]
.
Dictionary from: {'seq' -> seq. 'aliquot' -> ''} ].
padLeft := [:n :w | s := (n asString).
[((s size) < w)] whileTrue: [
  s := (' ' + s).
]
.
s ].
padRight := [:s :w | r := s.
[((r size) < w)] whileTrue: [
  r := (r + ' ').
]
.
r ].
joinWithCommas := [:seq | s := '['.
i := 0.
[(i < (seq size))] whileTrue: [
  s := (s + (seq at: i asString)).
  ((i < ((seq size) - 1))) ifTrue: [
    s := (s + ', ').
  ] .
  i := (i + 1).
]
.
s := (s + ']').
s ].
main := [ | Transcript show: 'Aliquot classifications - periods for Sociable/Cyclic in square brackets:
'; cr.
k := 1.
[(k <= 10)] whileTrue: [
  res := classifySequence value: k.
  Transcript show: (((((padLeft value: k value: 2 + ': ') + padRight value: res at: 'aliquot' asString value: 15) + ' ') + joinWithCommas value: res at: 'seq')) printString; cr.
  k := (k + 1).
]
.
Transcript show: ''; cr.
s := {11. 12. 28. 496. 220. 1184. 12496. 1264460. 790. 909. 562. 1064. 1488}.
i := 0.
[(i < (s size))] whileTrue: [
  val := s at: i.
  res := classifySequence value: val.
  Transcript show: (((((padLeft value: val value: 7 + ': ') + padRight value: res at: 'aliquot' asString value: 15) + ' ') + joinWithCommas value: res at: 'seq')) printString; cr.
  i := (i + 1).
]
.
Transcript show: ''; cr.
big := 15355717786080.
r := classifySequence value: big.
Transcript show: ((((((big asString) + ': ') + padRight value: r at: 'aliquot' asString value: 15) + ' ') + joinWithCommas value: r at: 'seq')) printString; cr. ].
main value.
