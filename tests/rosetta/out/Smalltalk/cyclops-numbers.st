" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| digits rev x out i commatize s isPrime d split parts cur parseIntStr neg n reverseStr pad findFirst main ranges cyclops r start end numDigits center ds count idx fi primes fp bpcyclops ppcyclops p ps splitp noMiddle fb fpp |
digits := [:n | ((n = 0)) ifTrue: [
{0}.
] .
rev := {}.
x := n.
[(x > 0)] whileTrue: [.
rev := rev copyWith: (x % 10).
x := (x / 10) asInteger.
].
.
out := {}.
i := (((rev size)) - 1).
[(i >= 0)] whileTrue: [.
out := out copyWith: rev at: i.
i := (i - 1).
].
.
out. ].
commatize := [:n | s := (n asString).
out := ''.
i := (s size).
[(i > 3)] whileTrue: [.
out := (((',' + (s copyFrom: ((i - 3) + 1) to: i))) + out).
i := (i - 3).
].
.
out := ((s copyFrom: (0 + 1) to: i) + out).
out. ].
isPrime := [:n | ((n < 2)) ifTrue: [
false.
] .
((((n % 2)) = 0)) ifTrue: [
(n = 2).
] .
((((n % 3)) = 0)) ifTrue: [
(n = 3).
] .
d := 5.
[(((d * d)) <= n)] whileTrue: [.
((((n % d)) = 0)) ifTrue: [
false.
] .
d := (d + 2).
((((n % d)) = 0)) ifTrue: [
false.
] .
d := (d + 4).
].
.
true. ].
split := [:s :sep | parts := {}.
cur := ''.
i := 0.
[(i < ((s size)))] whileTrue: [.
((((((i + ((sep size)))) <= ((s size)))) and: [((((s copyFrom: i to: (i + ((sep size))))) = sep))])) ifTrue: [
parts := parts copyWith: cur.
cur := ''.
i := (i + ((sep size))).
] ifFalse: [
cur := (cur + (s copyFrom: (i + 1) to: (i + 1))).
i := (i + 1).
].
].
.
parts := parts copyWith: cur.
parts. ].
parseIntStr := [:str | i := 0.
neg := false.
((((((str size)) > 0)) and: [(((str copyFrom: (0 + 1) to: 1) = '-'))])) ifTrue: [
neg := true.
i := 1.
] .
n := 0.
digits := Dictionary from:{'0'->0. '1'->1. '2'->2. '3'->3. '4'->4. '5'->5. '6'->6. '7'->7. '8'->8. '9'->9}.
[(i < ((str size)))] whileTrue: [.
n := (((n * 10)) + (digits at: str copyFrom: (i + 1) to: (i + 1))).
i := (i + 1).
].
.
(neg) ifTrue: [
n := -n.
] .
n. ].
reverseStr := [:s | out := ''.
i := (((s size)) - 1).
[(i >= 0)] whileTrue: [.
out := (out + (s copyFrom: (i + 1) to: (i + 1))).
i := (i - 1).
].
.
out. ].
pad := [:s :w | out := s.
[(((out size)) < w)] whileTrue: [.
out := ((' ') + out).
].
.
out. ].
findFirst := [:list | i := 0.
[(i < ((list size)))] whileTrue: [.
(((list at: i) > 10000000)) ifTrue: [
{list at: i. i}.
] .
i := (i + 1).
].
.
{-1. -1}. ].
main := [ ranges := {{0. 0}. {101. 909}. {11011. 99099}. {1110111. 9990999}. {111101111. 119101111}}.
cyclops := {}.
ranges do: [:r |.
start := r at: 0.
end := r at: 1.
numDigits := ((start asString) size).
center := (numDigits / 2).
i := start.
[(i <= end)] whileTrue: [.
ds := digits value: i.
(((ds at: center) = 0)) ifTrue: [
count := 0.
ds do: [:d |.
((d = 0)) ifTrue: [
count := (count + 1).
] .
].
.
((count = 1)) ifTrue: [
cyclops := cyclops copyWith: i.
] .
] .
i := (i + 1).
].
.
].
.
Transcript show: 'The first 50 cyclops numbers are:'; cr.
idx := 0.
[(idx < 50)] whileTrue: [.
Transcript show: (((pad value: commatize value: cyclops at: idx value: 6) + (' '))) printString; cr.
idx := (idx + 1).
((((idx % 10)) = 0)) ifTrue: [
Transcript show: '
'; cr.
] .
].
.
fi := findFirst value: cyclops.
Transcript show: ((((((('
First such number > 10 million is ') + (commatize value: fi at: 0))) + (' at zero-based index '))) + (commatize value: fi at: 1))) printString; cr.
primes := {}.
cyclops do: [:n |.
(isPrime value: n) ifTrue: [
primes := primes copyWith: n.
] .
].
.
Transcript show: '

The first 50 prime cyclops numbers are:'; cr.
idx := 0.
[(idx < 50)] whileTrue: [.
Transcript show: (((pad value: commatize value: primes at: idx value: 6) + (' '))) printString; cr.
idx := (idx + 1).
((((idx % 10)) = 0)) ifTrue: [
Transcript show: '
'; cr.
] .
].
.
fp := findFirst value: primes.
Transcript show: ((((((('
First such number > 10 million is ') + (commatize value: fp at: 0))) + (' at zero-based index '))) + (commatize value: fp at: 1))) printString; cr.
bpcyclops := {}.
ppcyclops := {}.
primes do: [:p |.
ps := (p asString).
splitp := split value: ps value: '0'.
noMiddle := parseIntStr value: ((splitp at: 0) + (splitp at: 1)).
(isPrime value: noMiddle) ifTrue: [
bpcyclops := bpcyclops copyWith: p.
] .
((ps = (reverseStr value: ps))) ifTrue: [
ppcyclops := ppcyclops copyWith: p.
] .
].
.
Transcript show: '

The first 50 blind prime cyclops numbers are:'; cr.
idx := 0.
[(idx < 50)] whileTrue: [.
Transcript show: (((pad value: commatize value: bpcyclops at: idx value: 6) + (' '))) printString; cr.
idx := (idx + 1).
((((idx % 10)) = 0)) ifTrue: [
Transcript show: '
'; cr.
] .
].
.
fb := findFirst value: bpcyclops.
Transcript show: ((((((('
First such number > 10 million is ') + (commatize value: fb at: 0))) + (' at zero-based index '))) + (commatize value: fb at: 1))) printString; cr.
Transcript show: '

The first 50 palindromic prime cyclops numbers are:'; cr.
idx := 0.
[(idx < 50)] whileTrue: [.
Transcript show: (((pad value: commatize value: ppcyclops at: idx value: 9) + (' '))) printString; cr.
idx := (idx + 1).
((((idx % 8)) = 0)) ifTrue: [
Transcript show: '
'; cr.
] .
].
.
fpp := findFirst value: ppcyclops.
Transcript show: ((((((('

First such number > 10 million is ') + (commatize value: fpp at: 0))) + (' at zero-based index '))) + (commatize value: fpp at: 1))) printString; cr. ].
