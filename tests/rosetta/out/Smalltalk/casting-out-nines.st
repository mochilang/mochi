" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| parseIntBase digits n i j v intToBase out d subset b e k ks mod r1 r2 testCases idx tc s sx valid found |
Object subclass: #BreakSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!.
parseIntBase := [:s :base | digits := '0123456789abcdefghijklmnopqrstuvwxyz'.
n := 0.
i := 0.
[.
[(i < ((s size)))] whileTrue: [.
j := 0.
v := 0.
[.
[(j < 36)] whileTrue: [.
((((digits copyFrom: j to: (j + 1))) = (s copyFrom: (i + 1) to: (i + 1)))) ifTrue: [
v := j.
BreakSignal signal.
] .
j := (j + 1).
].
] on: BreakSignal do: [:ex | ].
n := (((n * base)) + v).
i := (i + 1).
].
] on: BreakSignal do: [:ex | ].
n. ].
intToBase := [:n :base | digits := '0123456789abcdefghijklmnopqrstuvwxyz'.
((n = 0)) ifTrue: [
'0'.
] .
out := ''.
v := n.
[(v > 0)] whileTrue: [.
d := (v % base).
out := ((digits copyFrom: (d + 1) to: (d + 1)) + out).
v := (v / base).
].
.
out. ].
subset := [:base :begin :end | b := parseIntBase value: begin value: base.
e := parseIntBase value: end value: base.
out := {}.
k := b.
[(k <= e)] whileTrue: [.
ks := intToBase value: k value: base.
mod := (base - 1).
r1 := ((parseIntBase value: ks value: base) % mod).
r2 := ((((parseIntBase value: ks value: base) * (parseIntBase value: ks value: base))) % mod).
((r1 = r2)) ifTrue: [
out := out copyWith: ks.
] .
k := (k + 1).
].
.
out. ].
testCases := {Dictionary from:{'base'->10. 'begin'->'1'. 'end'->'100'. 'kaprekar'->({'1'. '9'. '45'. '55'. '99'})}. Dictionary from:{'base'->17. 'begin'->'10'. 'end'->'gg'. 'kaprekar'->({'3d'. 'd4'. 'gg'})}}.
idx := 0.
[.
[(idx < 2)] whileTrue: [.
tc := testCases at: idx.
Transcript show: ((((((((((((('
Test case base = ') + ((tc at: 'base' asString)))) + (', begin = '))) + (tc at: 'begin'))) + (', end = '))) + (tc at: 'end'))) + (':'))) printString; cr.
s := subset value: tc at: 'base' value: tc at: 'begin' value: tc at: 'end'.
Transcript show: ((('Subset:  ') + ((s asString)))) printString; cr.
Transcript show: ((('Kaprekar:') + ((tc at: 'kaprekar' asString)))) printString; cr.
sx := 0.
valid := true.
i := 0.
[.
[(i < ((tc at: 'kaprekar' size)))] whileTrue: [.
k := tc at: 'kaprekar' at: i.
found := false.
[.
[(sx < ((s size)))] whileTrue: [.
(((s at: sx) = k)) ifTrue: [
found := true.
sx := (sx + 1).
BreakSignal signal.
] .
sx := (sx + 1).
].
] on: BreakSignal do: [:ex | ].
(found not) ifTrue: [
Transcript show: ((((('Fail:') + k)) + (' not in subset'))) printString; cr.
valid := false.
BreakSignal signal.
] .
i := (i + 1).
].
] on: BreakSignal do: [:ex | ].
(valid) ifTrue: [
Transcript show: 'Valid subset.'; cr.
] .
idx := (idx + 1).
].
] on: BreakSignal do: [:ex | ].
