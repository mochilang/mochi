" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| pow2 v i lshift rshift NewWriter writeBitsLSB b writeBitsMSB WriteBits CloseWriter NewReader readBitsLSB mask out readBitsMSB ReadBits toBinary val bytesToBits bytesToHex digits hi lo ord upper lower idx chr bytesOfStr bs bytesToDec Example message msgBytes bw br result r |
Object subclass: #BreakSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!.
pow2 := [:n | v := 1.
i := 0.
[(i < n)] whileTrue: [.
v := (v * 2).
i := (i + 1).
].
.
v. ].
lshift := [:x :n | (x * (pow2 value: n)). ].
rshift := [:x :n | (x / (pow2 value: n)). ].
NewWriter := [:order | Dictionary from:{'order'->order. 'bits'->0. 'nbits'->0. 'data'->{}}. ].
writeBitsLSB := [:w :c :width | w at: 'bits' put: ((w at: 'bits') + (lshift value: c value: w at: 'nbits')).
w at: 'nbits' put: ((w at: 'nbits') + width).
[((w at: 'nbits') >= 8)] whileTrue: [.
b := ((w at: 'bits') % 256).
w at: 'data' put: w at: 'data' copyWith: b.
w at: 'bits' put: rshift value: w at: 'bits' value: 8.
w at: 'nbits' put: ((w at: 'nbits') - 8).
].
.
w. ].
writeBitsMSB := [:w :c :width | w at: 'bits' put: ((w at: 'bits') + (lshift value: c value: (((32 - width)) - (w at: 'nbits')))).
w at: 'nbits' put: ((w at: 'nbits') + width).
[((w at: 'nbits') >= 8)] whileTrue: [.
b := ((rshift value: w at: 'bits' value: 24) % 256).
w at: 'data' put: w at: 'data' copyWith: b.
w at: 'bits' put: ((((w at: 'bits') % (pow2 value: 24))) * 256).
w at: 'nbits' put: ((w at: 'nbits') - 8).
].
.
w. ].
WriteBits := [:w :c :width | (((w at: 'order') = 'LSB')) ifTrue: [
writeBitsLSB value: w value: c value: width.
] .
writeBitsMSB value: w value: c value: width. ].
CloseWriter := [:w | (((w at: 'nbits') > 0)) ifTrue: [
(((w at: 'order') = 'MSB')) ifTrue: [
w at: 'bits' put: rshift value: w at: 'bits' value: 24.
] .
w at: 'data' put: w at: 'data' copyWith: ((w at: 'bits') % 256).
] .
w at: 'bits' put: 0.
w at: 'nbits' put: 0.
w. ].
NewReader := [:data :order | Dictionary from:{'order'->order. 'data'->data. 'idx'->0. 'bits'->0. 'nbits'->0}. ].
readBitsLSB := [:r :width | [((r at: 'nbits') < width)] whileTrue: [.
(((r at: 'idx') >= ((r at: 'data' size)))) ifTrue: [
Dictionary from:{'val'->0. 'eof'->true}.
] .
b := r at: 'data' at: r at: 'idx'.
r at: 'idx' put: ((r at: 'idx') + 1).
r at: 'bits' put: ((r at: 'bits') + (lshift value: b value: r at: 'nbits')).
r at: 'nbits' put: ((r at: 'nbits') + 8).
].
.
mask := ((pow2 value: width) - 1).
out := ((r at: 'bits') % ((mask + 1))).
r at: 'bits' put: rshift value: r at: 'bits' value: width.
r at: 'nbits' put: ((r at: 'nbits') - width).
Dictionary from:{'val'->out. 'eof'->false}. ].
readBitsMSB := [:r :width | [((r at: 'nbits') < width)] whileTrue: [.
(((r at: 'idx') >= ((r at: 'data' size)))) ifTrue: [
Dictionary from:{'val'->0. 'eof'->true}.
] .
b := r at: 'data' at: r at: 'idx'.
r at: 'idx' put: ((r at: 'idx') + 1).
r at: 'bits' put: ((r at: 'bits') + (lshift value: b value: (24 - (r at: 'nbits')))).
r at: 'nbits' put: ((r at: 'nbits') + 8).
].
.
out := rshift value: r at: 'bits' value: (32 - width).
r at: 'bits' put: ((((r at: 'bits') * (pow2 value: width))) % (pow2 value: 32)).
r at: 'nbits' put: ((r at: 'nbits') - width).
Dictionary from:{'val'->out. 'eof'->false}. ].
ReadBits := [:r :width | (((r at: 'order') = 'LSB')) ifTrue: [
readBitsLSB value: r value: width.
] .
readBitsMSB value: r value: width. ].
toBinary := [:n :bits | b := ''.
val := n.
i := 0.
[(i < bits)] whileTrue: [.
b := ((((val % 2) asString)) + b).
val := (val / 2).
i := (i + 1).
].
.
b. ].
bytesToBits := [:bs | out := '['.
i := 0.
[(i < ((bs size)))] whileTrue: [.
out := (out + (toBinary value: bs at: i value: 8)).
((((i + 1)) < ((bs size)))) ifTrue: [
out := (out + (' ')).
] .
i := (i + 1).
].
.
out := (out + ']').
out. ].
bytesToHex := [:bs | digits := '0123456789ABCDEF'.
out := ''.
i := 0.
[(i < ((bs size)))] whileTrue: [.
b := bs at: i.
hi := (b / 16).
lo := (b % 16).
out := (((out + (digits copyFrom: (hi + 1) to: (hi + 1)))) + (digits copyFrom: (lo + 1) to: (lo + 1))).
((((i + 1)) < ((bs size)))) ifTrue: [
out := (out + (' ')).
] .
i := (i + 1).
].
.
out. ].
ord := [:ch | upper := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.
lower := 'abcdefghijklmnopqrstuvwxyz'.
idx := indexOf value: upper value: ch.
((idx >= 0)) ifTrue: [
(65 + idx).
] .
idx := indexOf value: lower value: ch.
((idx >= 0)) ifTrue: [
(97 + idx).
] .
((((ch >= '0')) and: [((ch <= '9'))])) ifTrue: [
(48 + (parseIntStr value: ch)).
] .
((ch = (' '))) ifTrue: [
32.
] .
((ch = '.')) ifTrue: [
46.
] .
0. ].
chr := [:n | upper := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.
lower := 'abcdefghijklmnopqrstuvwxyz'.
((((n >= 65)) and: [((n < 91))])) ifTrue: [
upper copyFrom: ((n - 65) + 1) to: (n - 64).
] .
((((n >= 97)) and: [((n < 123))])) ifTrue: [
lower copyFrom: ((n - 97) + 1) to: (n - 96).
] .
((((n >= 48)) and: [((n < 58))])) ifTrue: [
digits := '0123456789'.
digits copyFrom: ((n - 48) + 1) to: (n - 47).
] .
((n = 32)) ifTrue: [
' '.
] .
((n = 46)) ifTrue: [
'.'.
] .
'?'. ].
bytesOfStr := [:s | bs := {}.
i := 0.
[(i < ((s size)))] whileTrue: [.
bs := bs copyWith: ord value: s copyFrom: (i + 1) to: (i + 1).
i := (i + 1).
].
.
bs. ].
bytesToDec := [:bs | out := ''.
i := 0.
[(i < ((bs size)))] whileTrue: [.
out := (out + ((bs at: i asString))).
((((i + 1)) < ((bs size)))) ifTrue: [
out := (out + (' ')).
] .
i := (i + 1).
].
.
out. ].
Example := [ message := 'This is a test.'.
msgBytes := bytesOfStr value: message.
Transcript show: (((((('"' + message)) + ('" as bytes: '))) + (bytesToDec value: msgBytes))) printString; cr.
Transcript show: ((('    original bits: ') + (bytesToBits value: msgBytes))) printString; cr.
bw := NewWriter value: 'MSB'.
i := 0.
[(i < ((msgBytes size)))] whileTrue: [.
bw := WriteBits value: bw value: msgBytes at: i value: 7.
i := (i + 1).
].
.
bw := CloseWriter value: bw.
Transcript show: ((('Written bitstream: ') + (bytesToBits value: bw.data))) printString; cr.
Transcript show: ((('Written bytes: ') + (bytesToHex value: bw.data))) printString; cr.
br := NewReader value: bw.data value: 'MSB'.
result := ''.
[.
[true] whileTrue: [.
r := ReadBits value: br value: 7.
(r at: 'eof') ifTrue: [
BreakSignal signal.
] .
v := r at: 'val' asInteger.
((v ~= 0)) ifTrue: [
result := (result + (chr value: v)).
] .
].
] on: BreakSignal do: [:ex | ].
Transcript show: ((((('Read back as "') + result)) + '"')) printString; cr. ].
Example value.
