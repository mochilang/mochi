" Generated by Mochi compiler v0.10.26 on 2025-07-16T09:48:35Z
"
| a ach achSet achilles b b3 c count counts d getAchilles getPerfectPowers i idx j line lower main maxDigits min n nn out p pad pow10 pps res s sortInts strong tmp tot totient upper |
Object subclass: #BreakSignal instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: nil!
pow10 := [:exp | n := 1.
i := 0.
[(i < exp)] whileTrue: [
  n := (n * 10).
  i := (i + 1).
]
.
n ].
totient := [:n | tot := n.
nn := n.
i := 2.
[((i * i) <= nn)] whileTrue: [
  (((nn % i) = 0)) ifTrue: [
    [((nn % i) = 0)] whileTrue: [
      nn := (nn / i).
    ]
    .
    tot := (tot - (tot / i)).
  ] .
  ((i = 2)) ifTrue: [
    i := 1.
  ] .
  i := (i + 2).
]
.
((nn > 1)) ifTrue: [
  tot := (tot - (tot / nn)).
] .
tot ].
pps := Dictionary from: {}.
getPerfectPowers := [:maxExp | upper := pow10 value: maxExp.
i := 2.
[
  [((i * i) < upper)] whileTrue: [
    p := (i * i).
    [
      [true] whileTrue: [
        p := (p * i).
        ((p >= upper)) ifTrue: [
          BreakSignal signal
        ] .
        pps at: p put: true.
      ]
    ] on: BreakSignal do: [:ex | ].
    i := (i + 1).
  ]
] on: BreakSignal do: [:ex | ]. ].
getAchilles := [:minExp :maxExp | lower := pow10 value: minExp.
upper := pow10 value: maxExp.
achilles := Dictionary from: {}.
b := 1.
[
  [(((b * b) * b) < upper)] whileTrue: [
    b3 := ((b * b) * b).
    a := 1.
    [
      [true] whileTrue: [
        p := ((b3 * a) * a).
        ((p >= upper)) ifTrue: [
          BreakSignal signal
        ] .
        ((p >= lower)) ifTrue: [
          ((p in pps) not) ifTrue: [
            achilles at: p put: true.
          ] .
        ] .
        a := (a + 1).
      ]
    ] on: BreakSignal do: [:ex | ].
    b := (b + 1).
  ]
] on: BreakSignal do: [:ex | ].
achilles ].
sortInts := [:xs | res := {}.
tmp := xs.
[((tmp size) > 0)] whileTrue: [
  min := tmp at: 0.
  idx := 0.
  i := 1.
  [(i < (tmp size))] whileTrue: [
    ((tmp at: i < min)) ifTrue: [
      min := tmp at: i.
      idx := i.
    ] .
    i := (i + 1).
  ]
  .
  res := (res + {min}).
  out := {}.
  j := 0.
  [(j < (tmp size))] whileTrue: [
    ((j ~= idx)) ifTrue: [
      out := (out + {tmp at: j}).
    ] .
    j := (j + 1).
  ]
  .
  tmp := out.
]
.
res ].
pad := [:n :width | s := (n asString).
[((s size) < width)] whileTrue: [
  s := (' ' + s).
]
.
s ].
main := [ | maxDigits := 15.
getPerfectPowers value: maxDigits.
achSet := getAchilles value: 1 value: 5.
ach := {}.
achSet.keys value do: [:k |
  ach := (ach + {k}).
]
.
ach := sortInts value: ach.
Transcript show: 'First 50 Achilles numbers:'; cr.
i := 0.
[(i < 50)] whileTrue: [
  line := ''.
  j := 0.
  [(j < 10)] whileTrue: [
    line := (line + pad value: ach at: i value: 4).
    ((j < 9)) ifTrue: [
      line := (line + ' ').
    ] .
    i := (i + 1).
    j := (j + 1).
  ]
  .
  Transcript show: (line) printString; cr.
]
.
Transcript show: '
First 30 strong Achilles numbers:'; cr.
strong := {}.
count := 0.
idx := 0.
[(count < 30)] whileTrue: [
  tot := totient value: ach at: idx.
  ((tot in achSet)) ifTrue: [
    strong := (strong + {ach at: idx}).
    count := (count + 1).
  ] .
  idx := (idx + 1).
]
.
i := 0.
[(i < 30)] whileTrue: [
  line := ''.
  j := 0.
  [(j < 10)] whileTrue: [
    line := (line + pad value: strong at: i value: 5).
    ((j < 9)) ifTrue: [
      line := (line + ' ').
    ] .
    i := (i + 1).
    j := (j + 1).
  ]
  .
  Transcript show: (line) printString; cr.
]
.
Transcript show: '
Number of Achilles numbers with:'; cr.
counts := {1. 12. 47. 192. 664. 2242. 7395. 24008. 77330. 247449. 788855. 2508051. 7960336. 25235383}.
d := 2.
[(d <= maxDigits)] whileTrue: [
  c := counts at: (d - 2).
  Transcript show: (((pad value: d value: 2 + ' digits: ') + (c asString))) printString; cr.
  d := (d + 1).
]
. ].
main value.
