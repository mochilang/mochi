" Generated by Mochi compiler v0.10.26 on 2025-07-16T09:50:28Z
"
| abit bbit bin16 bit bit_and bit_not bit_or bit_xor bits bitwise i las left mask ras res right rol ror shl shr toUnsigned16 u ua ub val |
toUnsigned16 := [:n | u := n.
((u < 0)) ifTrue: [
  u := (u + 65536).
] .
(u % 65536) ].
bin16 := [:n | u := toUnsigned16 value: n.
bits := ''.
mask := 32768.
0 to: 16 do: [:i |
  ((u >= mask)) ifTrue: [
    bits := (bits + '1').
    u := (u - mask).
  ] ifFalse: [
    bits := (bits + '0').
  ].
  mask := (mask / 2) asInteger.
]
.
bits ].
bit_and := [:a :b | ua := toUnsigned16 value: a.
ub := toUnsigned16 value: b.
res := 0.
bit := 1.
0 to: 16 do: [:i |
  ((((ua % 2) = 1) and: [((ub % 2) = 1)])) ifTrue: [
    res := (res + bit).
  ] .
  ua := (ua / 2) asInteger.
  ub := (ub / 2) asInteger.
  bit := (bit * 2).
]
.
res ].
bit_or := [:a :b | ua := toUnsigned16 value: a.
ub := toUnsigned16 value: b.
res := 0.
bit := 1.
0 to: 16 do: [:i |
  ((((ua % 2) = 1) or: [((ub % 2) = 1)])) ifTrue: [
    res := (res + bit).
  ] .
  ua := (ua / 2) asInteger.
  ub := (ub / 2) asInteger.
  bit := (bit * 2).
]
.
res ].
bit_xor := [:a :b | ua := toUnsigned16 value: a.
ub := toUnsigned16 value: b.
res := 0.
bit := 1.
0 to: 16 do: [:i |
  abit := (ua % 2).
  bbit := (ub % 2).
  ((((abit = 1) and: [(bbit = 0)]) or: [((abit = 0) and: [(bbit = 1)])])) ifTrue: [
    res := (res + bit).
  ] .
  ua := (ua / 2) asInteger.
  ub := (ub / 2) asInteger.
  bit := (bit * 2).
]
.
res ].
bit_not := [:a | ua := toUnsigned16 value: a.
(65535 - ua) ].
shl := [:a :b | ua := toUnsigned16 value: a.
i := 0.
[(i < b)] whileTrue: [
  ua := ((ua * 2) % 65536).
  i := (i + 1).
]
.
ua ].
shr := [:a :b | ua := toUnsigned16 value: a.
i := 0.
[(i < b)] whileTrue: [
  ua := (ua / 2) asInteger.
  i := (i + 1).
]
.
ua ].
las := [:a :b | shl value: a value: b ].
ras := [:a :b | val := a.
i := 0.
[(i < b)] whileTrue: [
  ((val >= 0)) ifTrue: [
    val := (val / 2) asInteger.
  ] ifFalse: [
    val := ((val - 1) / 2) asInteger.
  ].
  i := (i + 1).
]
.
toUnsigned16 value: val ].
rol := [:a :b | ua := toUnsigned16 value: a.
left := shl value: ua value: b.
right := shr value: ua value: (16 - b).
toUnsigned16 value: (left + right) ].
ror := [:a :b | ua := toUnsigned16 value: a.
right := shr value: ua value: b.
left := shl value: ua value: (16 - b).
toUnsigned16 value: (left + right) ].
bitwise := [:a :b | Transcript show: (('a:   ' + bin16 value: a)) printString; cr.
Transcript show: (('b:   ' + bin16 value: b)) printString; cr.
Transcript show: (('and: ' + bin16 value: bit_and value: a value: b)) printString; cr.
Transcript show: (('or:  ' + bin16 value: bit_or value: a value: b)) printString; cr.
Transcript show: (('xor: ' + bin16 value: bit_xor value: a value: b)) printString; cr.
Transcript show: (('not: ' + bin16 value: bit_not value: a)) printString; cr.
((b < 0)) ifTrue: [
  Transcript show: 'Right operand is negative, but all shifts require an unsigned right operand (shift distance).'; cr.
  nil
] .
Transcript show: (('shl: ' + bin16 value: shl value: a value: b)) printString; cr.
Transcript show: (('shr: ' + bin16 value: shr value: a value: b)) printString; cr.
Transcript show: (('las: ' + bin16 value: las value: a value: b)) printString; cr.
Transcript show: (('ras: ' + bin16 value: ras value: a value: b)) printString; cr.
Transcript show: (('rol: ' + bin16 value: rol value: a value: b)) printString; cr.
Transcript show: (('ror: ' + bin16 value: ror value: a value: b)) printString; cr. ].
bitwise value: -460 value: 6.
