" Generated by Mochi compiler v0.10.30 on 2006-01-02T15:04:05Z
"
| adfgvx alphabet shuffleStr arr i j k tmp out createPolybius shuffled labels li p row line createKey pool key idx orderKey pairs n m res encrypt temp r c colLen table rIdx col order cols ci colStr ri result indexOf decrypt colStrs start maxColLen s ls pad plainText cIdx main polybius cipherText plainText2 |
adfgvx := 'ADFGVX'.
alphabet := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.
shuffleStr := [:s | arr := {}.
i := 0.
[(i < ((s size)))] whileTrue: [.
arr := arr copyWith: s copyFrom: (i + 1) to: (i + 1).
i := (i + 1).
].
.
j := (((arr size)) - 1).
[(j > 0)] whileTrue: [.
k := ((now value) % ((j + 1))).
tmp := arr at: j.
arr at: j put: arr at: k.
arr at: k put: tmp.
j := (j - 1).
].
.
out := ''.
i := 0.
[(i < ((arr size)))] whileTrue: [.
out := (out + (arr at: i)).
i := (i + 1).
].
.
out. ].
createPolybius := [ shuffled := shuffleStr value: alphabet.
labels := {}.
li := 0.
[(li < ((adfgvx size)))] whileTrue: [.
labels := labels copyWith: adfgvx copyFrom: (li + 1) to: (li + 1).
li := (li + 1).
].
.
Transcript show: '6 x 6 Polybius square:
'; cr.
Transcript show: '  | A D F G V X'; cr.
Transcript show: '---------------'; cr.
p := {}.
i := 0.
[(i < 6)] whileTrue: [.
row := shuffled copyFrom: ((i * 6) + 1) to: (((i + 1)) * 6).
p := p copyWith: row.
line := ((labels copyFrom: (i + 1) to: (i + 1)) + (' | ')).
j := 0.
[(j < 6)] whileTrue: [.
line := (((line + (row copyFrom: (j + 1) to: (j + 1)))) + (' ')).
j := (j + 1).
].
.
Transcript show: (line) printString; cr.
i := (i + 1).
].
.
p. ].
createKey := [:n | ((((n < 7)) or: [((n > 12))])) ifTrue: [
Transcript show: 'Key should be within 7 and 12 letters long.'; cr.
] .
pool := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.
key := ''.
i := 0.
[(i < n)] whileTrue: [.
idx := ((now value) % 36).
key := (key + (pool at: idx)).
pool := ((pool copyFrom: 1 to: idx) + (pool copyFrom: ((idx + 1) + 1) to: (pool size))).
i := (i + 1).
].
.
Transcript show: ((('
The key is ') + key)) printString; cr.
key. ].
orderKey := [:key | pairs := {}.
i := 0.
[(i < ((key size)))] whileTrue: [.
pairs := pairs copyWith: {key copyFrom: (i + 1) to: (i + 1). i}.
i := (i + 1).
].
.
n := (pairs size).
m := 0.
[(m < n)] whileTrue: [.
j := 0.
[(j < ((n - 1)))] whileTrue: [.
(((pairs at: j at: 0) > (pairs at: (j + 1) at: 0))) ifTrue: [
tmp := pairs at: j.
pairs at: j put: pairs at: (j + 1).
pairs at: (j + 1) put: tmp.
] .
j := (j + 1).
].
.
m := (m + 1).
].
.
res := {}.
i := 0.
[(i < n)] whileTrue: [.
res := res copyWith: pairs at: i at: 1 asInteger.
i := (i + 1).
].
.
res. ].
encrypt := [:polybius :key :plainText | labels := {}.
li := 0.
[(li < ((adfgvx size)))] whileTrue: [.
labels := labels copyWith: adfgvx copyFrom: (li + 1) to: (li + 1).
li := (li + 1).
].
.
temp := ''.
i := 0.
[(i < ((plainText size)))] whileTrue: [.
r := 0.
[(r < 6)] whileTrue: [.
c := 0.
[(c < 6)] whileTrue: [.
(((polybius at: r copyFrom: (c + 1) to: (c + 1)) = (plainText copyFrom: (i + 1) to: (i + 1)))) ifTrue: [
temp := (((temp + (labels copyFrom: (r + 1) to: (r + 1)))) + (labels copyFrom: (c + 1) to: (c + 1))).
] .
c := (c + 1).
].
.
r := (r + 1).
].
.
i := (i + 1).
].
.
colLen := (((temp size)) / ((key size))).
((((((temp size)) % ((key size)))) > 0)) ifTrue: [
colLen := (colLen + 1).
] .
table := {}.
rIdx := 0.
[(rIdx < colLen)] whileTrue: [.
row := {}.
j := 0.
[(j < ((key size)))] whileTrue: [.
row := row copyWith: ''.
j := (j + 1).
].
.
table := table copyWith: row.
rIdx := (rIdx + 1).
].
.
idx := 0.
[(idx < ((temp size)))] whileTrue: [.
row := (idx / ((key size))).
col := (idx % ((key size))).
table at: row at: col put: temp copyFrom: (idx + 1) to: (idx + 1).
idx := (idx + 1).
].
.
order := orderKey value: key.
cols := {}.
ci := 0.
[(ci < ((key size)))] whileTrue: [.
colStr := ''.
ri := 0.
[(ri < colLen)] whileTrue: [.
colStr := (colStr + (table at: ri at: order at: ci)).
ri := (ri + 1).
].
.
cols := cols copyWith: colStr.
ci := (ci + 1).
].
.
result := ''.
ci := 0.
[(ci < ((cols size)))] whileTrue: [.
result := (result + (cols at: ci)).
((ci < ((((cols size)) - 1)))) ifTrue: [
result := (result + (' ')).
] .
ci := (ci + 1).
].
.
result. ].
indexOf := [:s :ch | i := 0.
[(i < ((s size)))] whileTrue: [.
(((s copyFrom: (i + 1) to: (i + 1)) = ch)) ifTrue: [
i.
] .
i := (i + 1).
].
.
-1. ].
decrypt := [:polybius :key :cipherText | colStrs := {}.
start := 0.
i := 0.
[(i <= ((cipherText size)))] whileTrue: [.
((((i = ((cipherText size)))) or: [(((cipherText at: i) = (' ')))])) ifTrue: [
colStrs := colStrs copyWith: cipherText copyFrom: (start + 1) to: i.
start := (i + 1).
] .
i := (i + 1).
].
.
maxColLen := 0.
i := 0.
[(i < ((colStrs size)))] whileTrue: [.
((((colStrs at: i size)) > maxColLen)) ifTrue: [
maxColLen := (colStrs at: i size).
] .
i := (i + 1).
].
.
cols := {}.
i := 0.
[(i < ((colStrs size)))] whileTrue: [.
s := colStrs at: i.
ls := {}.
j := 0.
[(j < ((s size)))] whileTrue: [.
ls := ls copyWith: s copyFrom: (j + 1) to: (j + 1).
j := (j + 1).
].
.
((((s size)) < maxColLen)) ifTrue: [
pad := {}.
k := 0.
[(k < maxColLen)] whileTrue: [.
((k < ((ls size)))) ifTrue: [
pad := pad copyWith: ls at: k.
] ifFalse: [
pad := pad copyWith: ''.
].
k := (k + 1).
].
.
cols := cols copyWith: pad.
] ifFalse: [
cols := cols copyWith: ls.
].
i := (i + 1).
].
.
table := {}.
r := 0.
[(r < maxColLen)] whileTrue: [.
row := {}.
c := 0.
[(c < ((key size)))] whileTrue: [.
row := row copyWith: ''.
c := (c + 1).
].
.
table := table copyWith: row.
r := (r + 1).
].
.
order := orderKey value: key.
r := 0.
[(r < maxColLen)] whileTrue: [.
c := 0.
[(c < ((key size)))] whileTrue: [.
table at: r at: order at: c put: cols at: c at: r.
c := (c + 1).
].
.
r := (r + 1).
].
.
temp := ''.
r := 0.
[(r < ((table size)))] whileTrue: [.
j := 0.
[(j < ((table at: r size)))] whileTrue: [.
temp := (temp + (table at: r at: j)).
j := (j + 1).
].
.
r := (r + 1).
].
.
plainText := ''.
idx := 0.
[(idx < ((temp size)))] whileTrue: [.
rIdx := indexOf value: adfgvx value: temp copyFrom: (idx + 1) to: (idx + 1).
cIdx := indexOf value: adfgvx value: temp copyFrom: ((idx + 1) + 1) to: (idx + 2).
plainText := (plainText + (polybius at: rIdx at: cIdx)).
idx := (idx + 2).
].
.
plainText. ].
main := [ plainText := 'ATTACKAT1200AM'.
polybius := createPolybius value.
key := createKey value: 9.
Transcript show: ((('
Plaintext : ') + plainText)) printString; cr.
cipherText := encrypt value: polybius value: key value: plainText.
Transcript show: ((('
Encrypted : ') + cipherText)) printString; cr.
plainText2 := decrypt value: polybius value: key value: cipherText.
Transcript show: ((('
Decrypted : ') + plainText2)) printString; cr. ].
main value.
