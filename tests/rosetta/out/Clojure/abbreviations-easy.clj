; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function fields takes [s: string] and returns list of string
(defn fields [s]
  (try
    (def fields_words []) ;; list of string
    (def fields_cur "") ;; string
    (def fields_i 0) ;; int
    (loop []
      (when (< fields_i (count s))
        (let [r (try
          (def fields_ch (.substring s fields_i (+ fields_i 1))) ;; string
          (if (or (or (= fields_ch " ") (= fields_ch "\n")) (= fields_ch "\t"))
            (do
              (when (> (count fields_cur) 0)
                (def fields_words (conj fields_words fields_cur)) ;; list of string
                (def fields_cur "") ;; string
              )
            )

          (do
            (def fields_cur (str fields_cur fields_ch)) ;; string
          )
          )
          (def fields_i (+ fields_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(when (> (count fields_cur) 0)
  (def fields_words (conj fields_words fields_cur)) ;; list of string
)
(throw (ex-info "return" {:value fields_words}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function padRight takes [s: string, width: int] and returns string
(defn padRight [s width]
(try
(def padRight_out s) ;; string
(def padRight_i (count s)) ;; int
(loop []
  (when (< padRight_i width)
    (let [r (try
      (def padRight_out (str padRight_out " ")) ;; string
      (def padRight_i (+ padRight_i 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value padRight_out}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function join takes [xs: list of string, sep: string] and returns string
(defn join [xs sep]
(try
(def join_res "") ;; string
(def join_i 0) ;; int
(loop []
(when (< join_i (count xs))
(let [r (try
  (when (> join_i 0)
    (def join_res (str join_res sep)) ;; string
  )
  (def join_res (str join_res (_indexList xs join_i))) ;; string
  (def join_i (+ join_i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value join_res}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function validate takes [commands: list of string, words: list of string, mins: list of int] and returns list of string
(defn validate [commands words mins]
(try
(def validate_results []) ;; list of string
(when (= (count words) 0)
(throw (ex-info "return" {:value validate_results}))
)
(def validate_wi 0) ;; int
(loop []
(when (< validate_wi (count words))
(let [r (try
(def validate_w (_indexList words validate_wi)) ;; string
(def validate_found false) ;; bool
(def validate_wlen (count validate_w)) ;; int
(def validate_ci 0) ;; int
(loop []
(when (< validate_ci (count commands))
  (let [r (try
    (def validate_cmd (_indexList commands validate_ci)) ;; string
    (when (and (and (not (= (_indexList mins validate_ci) 0)) (>= validate_wlen (_indexList mins validate_ci))) (<= validate_wlen (count validate_cmd)))
      (def validate_c (clojure.string/upper-case validate_cmd)) ;; string
      (def validate_ww (clojure.string/upper-case validate_w)) ;; string
      (when (= (.substring validate_c 0 validate_wlen) validate_ww)
        (def validate_results (conj validate_results validate_c)) ;; list of string
        (def validate_found true) ;; bool
        (throw (ex-info "break" {}))
      )
    )
    (def validate_ci (+ validate_ci 1)) ;; int
    :next
  (catch clojure.lang.ExceptionInfo e
    (cond
      (= (.getMessage e) "continue") :next
      (= (.getMessage e) "break") :break
      :else (throw e))
    )
  )]
(cond
  (= r :break) nil
  (= r :next) (recur)
)
)
)
)
(when (not validate_found)
(def validate_results (conj validate_results "*error*")) ;; list of string
)
(def validate_wi (+ validate_wi 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value validate_results}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def main_table (str (str (str (str (str (str "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ") "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ") " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ") "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ") "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ") "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp ")) ;; string
(def main_commands (fields main_table)) ;; list of string
(def main_mins []) ;; list of int
(def main_i 0) ;; int
(loop []
(when (< main_i (count main_commands))
(let [r (try
(def main_count 0) ;; int
(def main_j 0) ;; int
(def main_cmd (_indexList main_commands main_i)) ;; string
(loop []
(when (< main_j (count main_cmd))
(let [r (try
(def main_ch (.substring main_cmd main_j (+ main_j 1))) ;; string
(when (and (>= (compare main_ch "A") 0) (<= (compare main_ch "Z") 0))
(def main_count (+ main_count 1)) ;; int
)
(def main_j (+ main_j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def main_mins (conj main_mins main_count)) ;; list of int
(def main_i (+ main_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def main_sentence "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin") ;; string
(def main_words (fields main_sentence)) ;; list of string
(def main_results (validate main_commands main_words main_mins)) ;; list of string
(def main_out1 "user words:  ") ;; string
(def main_k 0) ;; int
(loop []
(when (< main_k (count main_words))
(let [r (try
(def main_out1 (str (str main_out1 (padRight (_indexList main_words main_k) (count (_indexList main_results main_k)))) " ")) ;; string
(def main_k (+ main_k 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print main_out1)
(_print (str "full words:  " (join main_results " ")))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
