; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _equal [a b]
  (cond
    (and (sequential? a) (sequential? b))
      (and (= (count a) (count b)) (every? true? (map _equal a b)))
    (and (map? a) (map? b))
      (and (= (count a) (count b))
           (every? (fn [k] (_equal (get a k) (get b k))) (keys a)))
    (and (number? a) (number? b))
      (= (double a) (double b))
    :else
      (= a b)))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare OP_NUM OP_ADD OP_SUB OP_MUL OP_DIV n_cards goal digit_range)

;; Function newNum takes [n: int] and returns map of string to any
(defn newNum [n]
  (try
    (throw (ex-info "return" {:value {"op" OP_NUM "value" {"num" n "denom" 1}}}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)

;; Function exprEval takes [x: map of string to any] and returns map of string to int
(defn exprEval [x]
  (try
    (when (_equal (get x "op") OP_NUM)
      (throw (ex-info "return" {:value (get x "value")}))
    )
    (def exprEval_l (exprEval (get x "left"))) ;; map of string to int
    (def exprEval_r (exprEval (get x "right"))) ;; map of string to int
    (when (_equal (get x "op") OP_ADD)
      (throw (ex-info "return" {:value {"num" (+ (* (get exprEval_l "num") (get exprEval_r "denom")) (* (get exprEval_l "denom") (get exprEval_r "num"))) "denom" (* (get exprEval_l "denom") (get exprEval_r "denom"))}}))
    )
    (when (_equal (get x "op") OP_SUB)
      (throw (ex-info "return" {:value {"num" (- (* (get exprEval_l "num") (get exprEval_r "denom")) (* (get exprEval_l "denom") (get exprEval_r "num"))) "denom" (* (get exprEval_l "denom") (get exprEval_r "denom"))}}))
    )
    (when (_equal (get x "op") OP_MUL)
      (throw (ex-info "return" {:value {"num" (* (get exprEval_l "num") (get exprEval_r "num")) "denom" (* (get exprEval_l "denom") (get exprEval_r "denom"))}}))
    )
    (throw (ex-info "return" {:value {"num" (* (get exprEval_l "num") (get exprEval_r "denom")) "denom" (* (get exprEval_l "denom") (get exprEval_r "num"))}}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)

;; Function exprString takes [x: map of string to any] and returns string
(defn exprString [x]
  (try
    (when (_equal (get x "op") OP_NUM)
      (throw (ex-info "return" {:value (str (get (get x "value") "num"))}))
    )
    (def exprString_ls (exprString (get x "left"))) ;; string
    (def exprString_rs (exprString (get x "right"))) ;; string
    (def exprString_opstr "") ;; string
    (if (_equal (get x "op") OP_ADD)
      (do
        (def exprString_opstr " + ") ;; string
      )

    (if (_equal (get x "op") OP_SUB)
      (do
        (def exprString_opstr " - ") ;; string
      )

    (if (_equal (get x "op") OP_MUL)
      (do
        (def exprString_opstr " * ") ;; string
      )

    (do
      (def exprString_opstr " / ") ;; string
    )
    )
    )
    )
    (throw (ex-info "return" {:value (str (str (str (str "(" exprString_ls) exprString_opstr) exprString_rs) ")")}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)

;; Function solve takes [xs: list of map of string to any] and returns bool
(defn solve [xs]
  (try
    (when (= (count xs) 1)
      (def solve_f (exprEval (_indexList xs 0))) ;; map of string to int
      (when (and (not (= (get solve_f "denom") 0)) (= (get solve_f "num") (* (get solve_f "denom") goal)))
        (_print (exprString (_indexList xs 0)))
        (throw (ex-info "return" {:value true}))
      )
      (throw (ex-info "return" {:value false}))
    )
    (def solve_i 0) ;; int
    (loop []
      (when (< solve_i (count xs))
        (let [r (try
          (def solve_j (+ solve_i 1)) ;; int
          (loop []
            (when (< solve_j (count xs))
              (let [r (try
                (def solve_rest []) ;; list of map of string to any
                (def solve_k 0) ;; int
                (loop []
                  (when (< solve_k (count xs))
                    (let [r (try
                      (when (and (not (= solve_k solve_i)) (not (= solve_k solve_j)))
                        (def solve_rest (conj solve_rest (_indexList xs solve_k))) ;; list of map of string to any
                      )
                      (def solve_k (+ solve_k 1)) ;; int
                      :next
                    (catch clojure.lang.ExceptionInfo e
                      (cond
                        (= (.getMessage e) "continue") :next
                        (= (.getMessage e) "break") :break
                        :else (throw e))
                      )
                    )]
                  (cond
                    (= r :break) nil
                    (= r :next) (recur)
                  )
                )
              )
            )
            (def solve_a (_indexList xs solve_i)) ;; map of string to any
            (def solve_b (_indexList xs solve_j)) ;; map of string to any
            (loop [_tmp0 (seq [OP_ADD OP_SUB OP_MUL OP_DIV])]
              (when _tmp0
                (let [solve_op (clojure.core/first _tmp0)]
                  (let [r (try
                    (def solve_node {"op" solve_op "left" solve_a "right" solve_b}) ;; map of string to any
                    (when (solve (conj solve_rest solve_node))
                      (throw (ex-info "return" {:value true}))
                    )
                    :next
                  (catch clojure.lang.ExceptionInfo e
                    (cond
                      (= (.getMessage e) "continue") :next
                      (= (.getMessage e) "break") :break
                      :else (throw e))
                    )
                  )]
                (cond
                  (= r :break) nil
                  :else (recur (next _tmp0))
                )
              )
            )
          )
        )
        (def solve_node {"op" OP_SUB "left" solve_b "right" solve_a}) ;; map of string to any
        (when (solve (conj solve_rest solve_node))
          (throw (ex-info "return" {:value true}))
        )
        (def solve_node {"op" OP_DIV "left" solve_b "right" solve_a}) ;; map of string to any
        (when (solve (conj solve_rest solve_node))
          (throw (ex-info "return" {:value true}))
        )
        (def solve_j (+ solve_j 1)) ;; int
        :next
      (catch clojure.lang.ExceptionInfo e
        (cond
          (= (.getMessage e) "continue") :next
          (= (.getMessage e) "break") :break
          :else (throw e))
        )
      )]
    (cond
      (= r :break) nil
      (= r :next) (recur)
    )
  )
)
)
(def solve_i (+ solve_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value false}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def main_iter 0) ;; int
(loop []
(when (< main_iter 10)
(let [r (try
(def main_cards []) ;; list of map of string to any
(def main_i 0) ;; int
(loop []
(when (< main_i n_cards)
(let [r (try
(def main_n (+ (mod (System/nanoTime) (- digit_range 1)) 1)) ;; int
(def main_cards (conj main_cards (newNum main_n))) ;; list of map of string to any
(_print (str " " (str main_n)))
(def main_i (+ main_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print ":  ")
(when (not (solve main_cards))
(_print "No solution")
)
(def main_iter (+ main_iter 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def OP_NUM 0) ;; int
(def OP_ADD 1) ;; int
(def OP_SUB 2) ;; int
(def OP_MUL 3) ;; int
(def OP_DIV 4) ;; int
(def n_cards 4) ;; int
(def goal 24) ;; int
(def digit_range 9) ;; int
(main )
)

(-main)
