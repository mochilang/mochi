; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare x)

;; Function bigTrim takes [a: list of int] and returns list of int
(defn bigTrim [a]
  (try
    (def bigTrim_n (count a)) ;; int
    (loop []
      (when (and (> bigTrim_n 1) (= (_indexList a (- bigTrim_n 1)) 0))
        (let [r (try
          (def a (subvec a 0 (- bigTrim_n 1))) ;; list of int
          (def bigTrim_n (- bigTrim_n 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(throw (ex-info "return" {:value a}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function bigFromInt takes [x: int] and returns list of int
(defn bigFromInt [x]
(try
(when (= x 0)
  (throw (ex-info "return" {:value [0]}))
)
(def bigFromInt_digits []) ;; list of int
(def bigFromInt_n x) ;; int
(loop []
  (when (> bigFromInt_n 0)
    (let [r (try
      (def bigFromInt_digits (conj bigFromInt_digits (mod bigFromInt_n 10))) ;; list of int
      (def bigFromInt_n (quot bigFromInt_n 10)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value bigFromInt_digits}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function bigAdd takes [a: list of int, b: list of int] and returns list of int
(defn bigAdd [a b]
(try
(def bigAdd_res []) ;; list of int
(def bigAdd_carry 0) ;; int
(def bigAdd_i 0) ;; int
(loop []
(when (or (or (< bigAdd_i (count a)) (< bigAdd_i (count b))) (> bigAdd_carry 0))
(let [r (try
  (def bigAdd_av 0) ;; int
  (when (< bigAdd_i (count a))
    (def bigAdd_av (_indexList a bigAdd_i)) ;; int
  )
  (def bigAdd_bv 0) ;; int
  (when (< bigAdd_i (count b))
    (def bigAdd_bv (_indexList b bigAdd_i)) ;; int
  )
  (def bigAdd_s (+ (+ bigAdd_av bigAdd_bv) bigAdd_carry)) ;; int
  (def bigAdd_res (conj bigAdd_res (mod bigAdd_s 10))) ;; list of int
  (def bigAdd_carry (quot bigAdd_s 10)) ;; int
  (def bigAdd_i (+ bigAdd_i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value (bigTrim bigAdd_res)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function bigSub takes [a: list of int, b: list of int] and returns list of int
(defn bigSub [a b]
(try
(def bigSub_res []) ;; list of int
(def bigSub_borrow 0) ;; int
(def bigSub_i 0) ;; int
(loop []
(when (< bigSub_i (count a))
(let [r (try
(def bigSub_av (_indexList a bigSub_i)) ;; int
(def bigSub_bv 0) ;; int
(when (< bigSub_i (count b))
(def bigSub_bv (_indexList b bigSub_i)) ;; int
)
(def bigSub_diff (- (- bigSub_av bigSub_bv) bigSub_borrow)) ;; int
(if (< bigSub_diff 0)
(do
  (def bigSub_diff (+ bigSub_diff 10)) ;; int
  (def bigSub_borrow 1) ;; int
)

(do
(def bigSub_borrow 0) ;; int
)
)
(def bigSub_res (conj bigSub_res bigSub_diff)) ;; list of int
(def bigSub_i (+ bigSub_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value (bigTrim bigSub_res)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function bigToString takes [a: list of int] and returns string
(defn bigToString [a]
(try
(def bigToString_s "") ;; string
(def bigToString_i (- (count a) 1)) ;; int
(loop []
(when (>= bigToString_i 0)
(let [r (try
(def bigToString_s (str bigToString_s (str (_indexList a bigToString_i)))) ;; string
(def bigToString_i (- bigToString_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value bigToString_s}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function minInt takes [a: int, b: int] and returns int
(defn minInt [a b]
(try
(if (< a b)
(do
(throw (ex-info "return" {:value a}))
)

(do
(throw (ex-info "return" {:value b}))
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function cumu takes [n: int] and returns list of list of int
(defn cumu [n]
(try
(def cumu_cache [[(bigFromInt 1)]]) ;; list of list of list of int
(def cumu_y 1) ;; int
(loop []
(when (<= cumu_y n)
(let [r (try
(def cumu_row [(bigFromInt 0)]) ;; list of list of int
(def x 1) ;; int
(loop []
(when (<= x cumu_y)
(let [r (try
(def cumu_val (_indexList (_indexList cumu_cache (- cumu_y x)) (minInt x (- cumu_y x)))) ;; list of int
(def cumu_row (conj cumu_row (bigAdd (_indexList cumu_row (- (count cumu_row) 1)) cumu_val))) ;; list of list of int
(def x (+ x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def cumu_cache (conj cumu_cache cumu_row)) ;; list of list of list of int
(def cumu_y (+ cumu_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value (_indexList cumu_cache n)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function row takes [n: int] and returns list of string
(defn row [n]
(try
(def row_e (cumu n)) ;; list of list of int
(def row_out []) ;; list of string
(def row_i 0) ;; int
(loop []
(when (< row_i n)
(let [r (try
(def row_diff (bigSub (_indexList row_e (+ row_i 1)) (_indexList row_e row_i))) ;; list of int
(def row_out (conj row_out (bigToString row_diff))) ;; list of string
(def row_i (+ row_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value row_out}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(_print "rows:")
(def x 1) ;; int
(loop []
(when (< x 11)
(let [r (try
(def r (row x)) ;; list of string
(def line "") ;; string
(def i 0) ;; int
(loop []
(when (< i (count r))
(let [r (try
(def line (str (str (str line " ") (_indexList r i)) " ")) ;; string
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print line)
(def x (+ x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print "")
(_print "sums:")
(loop [_tmp0 (seq [23 123 1234])]
(when _tmp0
(let [num (clojure.core/first _tmp0)]
(let [r (try
(def r (cumu num)) ;; list of list of int
(_print (str (str (str num) " ") (bigToString (_indexList r (- (count r) 1)))))
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp0))
)
)
)
)
)
)

(-main)
