; Generated by Mochi compiler v0.10.26 on 2025-07-16T09:56:42Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(declare doors)

(defn -main []
  (def doors []) ;; list of any
  (loop [i 0]
    (when (< i 100)
      (let [r (try
        (def doors (conj doors false)) ;; list of any
        :next
      (catch clojure.lang.ExceptionInfo e
        (cond
          (= (.getMessage e) "continue") :next
          (= (.getMessage e) "break") :break
          :else (throw e))
        )
      )]
    (cond
      (= r :break) nil
      :else (recur (inc i))
    )
  )
)
)
(loop [pass 1]
(when (< pass 101)
  (let [r (try
    (def idx (- pass 1)) ;; any
    (loop []
      (when (< idx 100)
        (let [r (try
          (def doors (assoc doors idx (not (_indexList doors idx)))) ;; any
          (def idx (+ idx pass)) ;; any
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (inc pass))
)
)
)
)
(loop [row 0]
(when (< row 10)
(let [r (try
(def line "") ;; string
(loop [col 0]
(when (< col 10)
(let [r (try
  (def idx (+ (* row 10) col)) ;; any
  (if (_indexList doors idx)
    (do
      (def line (str line "1")) ;; string
    )

  (do
    (def line (str line "0")) ;; string
  )
  )
  (when (< col 9)
    (def line (str line " ")) ;; string
  )
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
:else (recur (inc col))
)
)
)
)
(println line)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (inc row))
)
)
)
)
)

(-main)
