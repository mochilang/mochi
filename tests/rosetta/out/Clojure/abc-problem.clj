; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function fields takes [s: string] and returns list of string
(defn fields [s]
  (try
    (def fields_res []) ;; list of string
    (def fields_cur "") ;; string
    (def fields_i 0) ;; int
    (loop []
      (when (< fields_i (count s))
        (let [r (try
          (def fields_c (subs s fields_i (+ fields_i 1))) ;; string
          (if (= fields_c " ")
            (do
              (when (> (count fields_cur) 0)
                (def fields_res (conj fields_res fields_cur)) ;; list of string
                (def fields_cur "") ;; string
              )
            )

          (do
            (def fields_cur (str fields_cur fields_c)) ;; string
          )
          )
          (def fields_i (+ fields_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(when (> (count fields_cur) 0)
  (def fields_res (conj fields_res fields_cur)) ;; list of string
)
(throw (ex-info "return" {:value fields_res}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function canSpell takes [word: string, blks: list of string] and returns bool
(defn canSpell [word blks]
(try
(when (= (count word) 0)
  (throw (ex-info "return" {:value true}))
)
(def canSpell_c (clojure.string/lower-case (subs word 0 1))) ;; string
(def canSpell_i 0) ;; int
(loop []
  (when (< canSpell_i (count blks))
    (let [r (try
      (def canSpell_b (_indexList blks canSpell_i)) ;; string
      (when (or (= canSpell_c (clojure.string/lower-case (subs canSpell_b 0 1))) (= canSpell_c (clojure.string/lower-case (subs canSpell_b 1 2))))
        (def canSpell_rest []) ;; list of string
        (def canSpell_j 0) ;; int
        (loop []
          (when (< canSpell_j (count blks))
            (let [r (try
              (when (not (= canSpell_j canSpell_i))
                (def canSpell_rest (conj canSpell_rest (_indexList blks canSpell_j))) ;; list of string
              )
              (def canSpell_j (+ canSpell_j 1)) ;; int
              :next
            (catch clojure.lang.ExceptionInfo e
              (cond
                (= (.getMessage e) "continue") :next
                (= (.getMessage e) "break") :break
                :else (throw e))
              )
            )]
          (cond
            (= r :break) nil
            (= r :next) (recur)
          )
        )
      )
    )
    (when (canSpell (subs word 1 ) canSpell_rest)
      (throw (ex-info "return" {:value true}))
    )
  )
  (def canSpell_i (+ canSpell_i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value false}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function newSpeller takes [blocks: string] and returns function
(defn newSpeller [blocks]
(try
(def newSpeller_bl (fields blocks)) ;; list of string
(throw (ex-info "return" {:value (fn [w]
  (try
    (throw (ex-info "return" {:value (canSpell w newSpellerf0_bl)}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def main_sp (newSpeller "BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM")) ;; function
(loop [_tmp0 (seq ["A" "BARK" "BOOK" "TREAT" "COMMON" "SQUAD" "CONFUSE"])]
(when _tmp0
(let [main_word (clojure.core/first _tmp0)]
(let [r (try
(_print (str (str main_word " ") (str (sp main_word))))
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp0))
)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
