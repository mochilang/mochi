; Generated by Mochi compiler v0.10.28 on 1970-01-01T00:00:00Z
(ns main)

(defn _input []
  (let [s (read-line)]
    (if s
      (clojure.string/trim s)
      "")))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function parseIntStr takes [str: string] and returns int
(defn parseIntStr [str]
  (try
    (def i 0) ;; int
    (def neg false) ;; bool
    (when (and (> (count str) 0) (= (subs str 0 1) "-"))
      (def neg true) ;; bool
      (def i 1) ;; int
    )
    (def n 0) ;; int
    (def digits {"0" 0 "1" 1 "2" 2 "3" 3 "4" 4 "5" 5 "6" 6 "7" 7 "8" 8 "9" 9}) ;; map of string to int
    (loop []
      (when (< i (count str))
        (let [r (try
          (def n (+ (* n 10) (get digits (subs str i (+ i 1))))) ;; int
          (def i (+ i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(when neg
  (def n (- n)) ;; int
)
(throw (ex-info "return" {:value n}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def total 0) ;; int
(def computer (= (mod (System/nanoTime) 2) 0)) ;; bool
(_print "Enter q to quit at any time\n")
(if computer
  (do
    (_print "The computer will choose first")
  )

(do
  (_print "You will choose first")
)
)
(_print "\n\nRunning total is now 0\n\n")
(def round 1) ;; int
(def done false) ;; bool
(loop []
  (when (not done)
    (let [r (try
      (_print (str (str "ROUND " (str round)) ":\n\n"))
      (def i 0) ;; int
      (loop []
        (when (and (< i 2) (not done))
          (let [r (try
            (if computer
              (do
                (def choice 0) ;; int
                (if (< total 18)
                  (do
                    (def choice (+ (mod (System/nanoTime) 3) 1)) ;; int
                  )

                (do
                  (def choice (- 21 total)) ;; int
                )
                )
                (def total (+ total choice)) ;; int
                (_print (str "The computer chooses " (str choice)))
                (_print (str "Running total is now " (str total)))
                (when (= total 21)
                  (_print "\nSo, commiserations, the computer has won!")
                  (def done true) ;; bool
                )
              )

            (do
              (loop []
                (when true
                  (let [r (try
                    (_print "Your choice 1 to 3 : ")
                    (def line (_input)) ;; string
                    (when (or (= line "q") (= line "Q"))
                      (_print "OK, quitting the game")
                      (def done true) ;; bool
                      (throw (ex-info "break" {}))
                    )
                    (def num (parseIntStr line)) ;; int
                    (when (or (< num 1) (> num 3))
                      (if (> (+ total num) 21)
                        (do
                          (_print "Too big, try again")
                        )

                      (do
                        (_print "Out of range, try again")
                      )
                      )
                      (throw (ex-info "continue" {}))
                    )
                    (when (> (+ total num) 21)
                      (_print "Too big, try again")
                      (throw (ex-info "continue" {}))
                    )
                    (def total (+ total num)) ;; int
                    (_print (str "Running total is now " (str total)))
                    (throw (ex-info "break" {}))
                    :next
                  (catch clojure.lang.ExceptionInfo e
                    (cond
                      (= (.getMessage e) "continue") :next
                      (= (.getMessage e) "break") :break
                      :else (throw e))
                    )
                  )]
                (cond
                  (= r :break) nil
                  (= r :next) (recur)
                )
              )
            )
          )
          (when (= total 21)
            (_print "\nSo, congratulations, you've won!")
            (def done true) ;; bool
          )
        )
        )
        (_print "\n")
        (def computer (not computer)) ;; bool
        (def i (+ i 1)) ;; int
        :next
      (catch clojure.lang.ExceptionInfo e
        (cond
          (= (.getMessage e) "continue") :next
          (= (.getMessage e) "break") :break
          :else (throw e))
        )
      )]
    (cond
      (= r :break) nil
      (= r :next) (recur)
    )
  )
)
)
(def round (+ round 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
