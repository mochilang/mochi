; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _input []
  (let [s (read-line)]
    (if s
      (clojure.string/trim s)
      "")))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(def ^:dynamic _now_seeded (atom false))
  (def ^:dynamic _now_seed (atom 0))
  (defn _now []
    (when-not @_now_seeded
      (let [s (System/getenv "MOCHI_NOW_SEED")]
        (when (and s (re-matches #"\d+" s))
          (reset! _now_seed (Long/parseLong s))
          (reset! _now_seeded true))))
    (if @_now_seeded
      (do
        (swap! _now_seed #(mod (+ (* % 1664525) 1013904223) 2147483647))
        @_now_seed)
      (System/nanoTime)))
;; Function parseIntStr takes [str: string] and returns int
(defn parseIntStr [str]
  (try
    (def parseIntStr_i 0) ;; int
    (def parseIntStr_neg false) ;; bool
    (when (and (> (count str) 0) (= (subs str 0 1) "-"))
      (def parseIntStr_neg true) ;; bool
      (def parseIntStr_i 1) ;; int
    )
    (def parseIntStr_n 0) ;; int
    (def parseIntStr_digits {"0" 0 "1" 1 "2" 2 "3" 3 "4" 4 "5" 5 "6" 6 "7" 7 "8" 8 "9" 9}) ;; map of string to int
    (loop []
      (when (< parseIntStr_i (count str))
        (let [r (try
          (def parseIntStr_n (+ (* parseIntStr_n 10) (get parseIntStr_digits (subs str parseIntStr_i (+ parseIntStr_i 1))))) ;; int
          (def parseIntStr_i (+ parseIntStr_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(when parseIntStr_neg
  (def parseIntStr_n (- parseIntStr_n)) ;; int
)
(throw (ex-info "return" {:value parseIntStr_n}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def main_total 0) ;; int
(def main_computer (= (mod (_now) 2) 0)) ;; bool
(_print "Enter q to quit at any time\n")
(if main_computer
  (do
    (_print "The computer will choose first")
  )

(do
  (_print "You will choose first")
)
)
(_print "\n\nRunning total is now 0\n\n")
(def main_round 1) ;; int
(def main_done false) ;; bool
(loop []
  (when (not main_done)
    (let [r (try
      (_print (str (str "ROUND " (str main_round)) ":\n\n"))
      (def main_i 0) ;; int
      (loop []
        (when (and (< main_i 2) (not main_done))
          (let [r (try
            (if main_computer
              (do
                (def main_choice 0) ;; int
                (if (< main_total 18)
                  (do
                    (def main_choice (+ (mod (_now) 3) 1)) ;; int
                  )

                (do
                  (def main_choice (- 21 main_total)) ;; int
                )
                )
                (def main_total (+ main_total main_choice)) ;; int
                (_print (str "The computer chooses " (str main_choice)))
                (_print (str "Running total is now " (str main_total)))
                (when (= main_total 21)
                  (_print "\nSo, commiserations, the computer has won!")
                  (def main_done true) ;; bool
                )
              )

            (do
              (loop []
                (when true
                  (let [r (try
                    (_print "Your choice 1 to 3 : ")
                    (def main_line (_input)) ;; string
                    (when (or (= main_line "q") (= main_line "Q"))
                      (_print "OK, quitting the game")
                      (def main_done true) ;; bool
                      (throw (ex-info "break" {}))
                    )
                    (def main_num (parseIntStr main_line)) ;; int
                    (when (or (< main_num 1) (> main_num 3))
                      (if (> (+ main_total main_num) 21)
                        (do
                          (_print "Too big, try again")
                        )

                      (do
                        (_print "Out of range, try again")
                      )
                      )
                      (throw (ex-info "continue" {}))
                    )
                    (when (> (+ main_total main_num) 21)
                      (_print "Too big, try again")
                      (throw (ex-info "continue" {}))
                    )
                    (def main_total (+ main_total main_num)) ;; int
                    (_print (str "Running total is now " (str main_total)))
                    (throw (ex-info "break" {}))
                    :next
                  (catch clojure.lang.ExceptionInfo e
                    (cond
                      (= (.getMessage e) "continue") :next
                      (= (.getMessage e) "break") :break
                      :else (throw e))
                    )
                  )]
                (cond
                  (= r :break) nil
                  (= r :next) (recur)
                )
              )
            )
          )
          (when (= main_total 21)
            (_print "\nSo, congratulations, you've won!")
            (def main_done true) ;; bool
          )
        )
        )
        (_print "\n")
        (def main_computer (not main_computer)) ;; bool
        (def main_i (+ main_i 1)) ;; int
        :next
      (catch clojure.lang.ExceptionInfo e
        (cond
          (= (.getMessage e) "continue") :next
          (= (.getMessage e) "break") :break
          :else (throw e))
        )
      )]
    (cond
      (= r :break) nil
      (= r :next) (recur)
    )
  )
)
)
(def main_round (+ main_round 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
