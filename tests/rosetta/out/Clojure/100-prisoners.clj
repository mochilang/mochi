; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(def ^:dynamic _now_seeded (atom false))
  (def ^:dynamic _now_seed (atom 0))
  (defn _now []
    (when-not @_now_seeded
      (let [s (System/getenv "MOCHI_NOW_SEED")]
        (when (and s (re-matches #"\d+" s))
          (reset! _now_seed (Long/parseLong s))
          (reset! _now_seeded true))))
    (if @_now_seeded
      (do
        (swap! _now_seed #(mod (+ (* % 1664525) 1013904223) 2147483647))
        @_now_seed)
      (System/nanoTime)))
;; Function shuffle takes [xs: list of int] and returns list of int
(defn shuffle [xs]
  (try
    (def shuffle_arr xs) ;; list of int
    (def shuffle_i 99) ;; int
    (loop []
      (when (> shuffle_i 0)
        (let [r (try
          (def shuffle_j (mod (_now) (+ shuffle_i 1))) ;; int
          (def shuffle_tmp (_indexList shuffle_arr shuffle_i)) ;; int
          (def shuffle_arr (assoc shuffle_arr shuffle_i (_indexList shuffle_arr shuffle_j))) ;; int
          (def shuffle_arr (assoc shuffle_arr shuffle_j shuffle_tmp)) ;; int
          (def shuffle_i (- shuffle_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(throw (ex-info "return" {:value shuffle_arr}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function doTrials takes [trials: int, np: int, strategy: string] and returns any
(defn doTrials [trials np strategy]
(try
(def doTrials_pardoned 0) ;; int
(def doTrials_t 0) ;; int
(loop []
  (when (< doTrials_t trials)
    (let [r (try
      (def doTrials_drawers []) ;; list of int
      (def doTrials_i 0) ;; int
      (loop []
        (when (< doTrials_i 100)
          (let [r (try
            (def doTrials_drawers (conj doTrials_drawers doTrials_i)) ;; list of int
            (def doTrials_i (+ doTrials_i 1)) ;; int
            :next
          (catch clojure.lang.ExceptionInfo e
            (cond
              (= (.getMessage e) "continue") :next
              (= (.getMessage e) "break") :break
              :else (throw e))
            )
          )]
        (cond
          (= r :break) nil
          (= r :next) (recur)
        )
      )
    )
  )
  (def doTrials_drawers (shuffle doTrials_drawers)) ;; list of int
  (def doTrials_p 0) ;; int
  (def doTrials_success true) ;; bool
  (loop []
    (when (< doTrials_p np)
      (let [r (try
        (def doTrials_found false) ;; bool
        (if (= strategy "optimal")
          (do
            (def doTrials_prev doTrials_p) ;; int
            (def doTrials_d 0) ;; int
            (loop []
              (when (< doTrials_d 50)
                (let [r (try
                  (def doTrials_this (_indexList doTrials_drawers doTrials_prev)) ;; int
                  (when (= doTrials_this doTrials_p)
                    (def doTrials_found true) ;; bool
                    (throw (ex-info "break" {}))
                  )
                  (def doTrials_prev doTrials_this) ;; int
                  (def doTrials_d (+ doTrials_d 1)) ;; int
                  :next
                (catch clojure.lang.ExceptionInfo e
                  (cond
                    (= (.getMessage e) "continue") :next
                    (= (.getMessage e) "break") :break
                    :else (throw e))
                  )
                )]
              (cond
                (= r :break) nil
                (= r :next) (recur)
              )
            )
          )
        )
      )

    (do
      (def doTrials_opened []) ;; list of bool
      (def doTrials_k 0) ;; int
      (loop []
        (when (< doTrials_k 100)
          (let [r (try
            (def doTrials_opened (conj doTrials_opened false)) ;; list of bool
            (def doTrials_k (+ doTrials_k 1)) ;; int
            :next
          (catch clojure.lang.ExceptionInfo e
            (cond
              (= (.getMessage e) "continue") :next
              (= (.getMessage e) "break") :break
              :else (throw e))
            )
          )]
        (cond
          (= r :break) nil
          (= r :next) (recur)
        )
      )
    )
  )
  (def doTrials_d 0) ;; int
  (loop []
    (when (< doTrials_d 50)
      (let [r (try
        (def doTrials_n (mod (_now) 100)) ;; int
        (loop []
          (when (_indexList doTrials_opened doTrials_n)
            (let [r (try
              (def doTrials_n (mod (_now) 100)) ;; int
              :next
            (catch clojure.lang.ExceptionInfo e
              (cond
                (= (.getMessage e) "continue") :next
                (= (.getMessage e) "break") :break
                :else (throw e))
              )
            )]
          (cond
            (= r :break) nil
            (= r :next) (recur)
          )
        )
      )
    )
    (def doTrials_opened (assoc doTrials_opened doTrials_n true)) ;; bool
    (when (= (_indexList doTrials_drawers doTrials_n) doTrials_p)
      (def doTrials_found true) ;; bool
      (throw (ex-info "break" {}))
    )
    (def doTrials_d (+ doTrials_d 1)) ;; int
    :next
  (catch clojure.lang.ExceptionInfo e
    (cond
      (= (.getMessage e) "continue") :next
      (= (.getMessage e) "break") :break
      :else (throw e))
    )
  )]
(cond
  (= r :break) nil
  (= r :next) (recur)
)
)
)
)
)
)
(when (not doTrials_found)
(def doTrials_success false) ;; bool
(throw (ex-info "break" {}))
)
(def doTrials_p (+ doTrials_p 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when doTrials_success
(def doTrials_pardoned (+ doTrials_pardoned 1)) ;; int
)
(def doTrials_t (+ doTrials_t 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def doTrials_rf (* (/ (double doTrials_pardoned) (double trials)) 100.0)) ;; float
(_print (str (str (str (str (str (str "  strategy = " strategy) "  pardoned = ") (str doTrials_pardoned)) " relative frequency = ") (str doTrials_rf)) "%"))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def main_trials 1000) ;; int
(loop [_tmp0 (seq [10 100])]
(when _tmp0
(let [main_np (clojure.core/first _tmp0)]
(let [r (try
(_print (str (str (str (str "Results from " (str main_trials)) " trials with ") (str main_np)) " prisoners:\n"))
(loop [_tmp1 (seq ["random" "optimal"])]
(when _tmp1
(let [main_strat (clojure.core/first _tmp1)]
(let [r (try
(doTrials main_trials main_np main_strat)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp1))
)
)
)
)
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp0))
)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
