; Generated by Mochi compiler v0.10.28 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function shuffle takes [xs: list of int] and returns list of int
(defn shuffle [xs]
  (try
    (def arr xs) ;; list of int
    (def i 99) ;; int
    (loop []
      (when (> i 0)
        (let [r (try
          (def j (mod (System/nanoTime) (+ i 1))) ;; int
          (def tmp (_indexList arr i)) ;; int
          (def arr (assoc arr i (_indexList arr j))) ;; int
          (def arr (assoc arr j tmp)) ;; int
          (def i (- i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(throw (ex-info "return" {:value arr}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function doTrials takes [trials: int, np: int, strategy: string] and returns any
(defn doTrials [trials np strategy]
(try
(def pardoned 0) ;; int
(def t 0) ;; int
(loop []
  (when (< t trials)
    (let [r (try
      (def drawers []) ;; list of int
      (def i 0) ;; int
      (loop []
        (when (< i 100)
          (let [r (try
            (def drawers (conj drawers i)) ;; list of int
            (def i (+ i 1)) ;; int
            :next
          (catch clojure.lang.ExceptionInfo e
            (cond
              (= (.getMessage e) "continue") :next
              (= (.getMessage e) "break") :break
              :else (throw e))
            )
          )]
        (cond
          (= r :break) nil
          (= r :next) (recur)
        )
      )
    )
  )
  (def drawers (shuffle drawers)) ;; list of int
  (def p 0) ;; int
  (def success true) ;; bool
  (loop []
    (when (< p np)
      (let [r (try
        (def found false) ;; bool
        (if (= strategy "optimal")
          (do
            (def prev p) ;; int
            (def d 0) ;; int
            (loop []
              (when (< d 50)
                (let [r (try
                  (def this (_indexList drawers prev)) ;; int
                  (when (= this p)
                    (def found true) ;; bool
                    (throw (ex-info "break" {}))
                  )
                  (def prev this) ;; int
                  (def d (+ d 1)) ;; int
                  :next
                (catch clojure.lang.ExceptionInfo e
                  (cond
                    (= (.getMessage e) "continue") :next
                    (= (.getMessage e) "break") :break
                    :else (throw e))
                  )
                )]
              (cond
                (= r :break) nil
                (= r :next) (recur)
              )
            )
          )
        )
      )

    (do
      (def opened []) ;; list of bool
      (def k 0) ;; int
      (loop []
        (when (< k 100)
          (let [r (try
            (def opened (conj opened false)) ;; list of bool
            (def k (+ k 1)) ;; int
            :next
          (catch clojure.lang.ExceptionInfo e
            (cond
              (= (.getMessage e) "continue") :next
              (= (.getMessage e) "break") :break
              :else (throw e))
            )
          )]
        (cond
          (= r :break) nil
          (= r :next) (recur)
        )
      )
    )
  )
  (def d 0) ;; int
  (loop []
    (when (< d 50)
      (let [r (try
        (def n (mod (System/nanoTime) 100)) ;; int
        (loop []
          (when (_indexList opened n)
            (let [r (try
              (def n (mod (System/nanoTime) 100)) ;; int
              :next
            (catch clojure.lang.ExceptionInfo e
              (cond
                (= (.getMessage e) "continue") :next
                (= (.getMessage e) "break") :break
                :else (throw e))
              )
            )]
          (cond
            (= r :break) nil
            (= r :next) (recur)
          )
        )
      )
    )
    (def opened (assoc opened n true)) ;; bool
    (when (= (_indexList drawers n) p)
      (def found true) ;; bool
      (throw (ex-info "break" {}))
    )
    (def d (+ d 1)) ;; int
    :next
  (catch clojure.lang.ExceptionInfo e
    (cond
      (= (.getMessage e) "continue") :next
      (= (.getMessage e) "break") :break
      :else (throw e))
    )
  )]
(cond
  (= r :break) nil
  (= r :next) (recur)
)
)
)
)
)
)
(when (not found)
(def success false) ;; bool
(throw (ex-info "break" {}))
)
(def p (+ p 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when success
(def pardoned (+ pardoned 1)) ;; int
)
(def t (+ t 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def rf (* (/ (double pardoned) (double trials)) 100.0)) ;; float
(_print (str (str (str (str (str (str "  strategy = " strategy) "  pardoned = ") (str pardoned)) " relative frequency = ") (str rf)) "%"))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def trials 1000) ;; int
(loop [_tmp0 (seq [10 100])]
(when _tmp0
(let [np (clojure.core/first _tmp0)]
(let [r (try
(_print (str (str (str (str "Results from " (str trials)) " trials with ") (str np)) " prisoners:\n"))
(loop [_tmp1 (seq ["random" "optimal"])]
(when _tmp1
(let [strat (clojure.core/first _tmp1)]
(let [r (try
(doTrials trials np strat)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp1))
)
)
)
)
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp0))
)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
