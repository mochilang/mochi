; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare PI degreesIncr turns stop width centre a b theta count)

;; Function sinApprox takes [x: float] and returns float
(defn sinApprox [x]
  (try
    (def term x) ;; float
    (def sum x) ;; float
    (def n 1) ;; int
    (loop []
      (when (<= n 10)
        (let [r (try
          (def denom (double (* (* 2 n) (+ (* 2 n) 1)))) ;; float
          (def term (/ (* (* (- term) x) x) denom)) ;; float
          (def sum (+ sum term)) ;; float
          (def n (+ n 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(throw (ex-info "return" {:value sum}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function cosApprox takes [x: float] and returns float
(defn cosApprox [x]
(try
(def term 1.0) ;; float
(def sum 1.0) ;; float
(def n 1) ;; int
(loop []
  (when (<= n 10)
    (let [r (try
      (def denom (double (* (- (* 2 n) 1) (* 2 n)))) ;; float
      (def term (/ (* (* (- term) x) x) denom)) ;; float
      (def sum (+ sum term)) ;; float
      (def n (+ n 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value sum}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def PI 3.141592653589793) ;; float
(def degreesIncr (/ (* 0.1 PI) 180.0)) ;; float
(def turns 2.0) ;; float
(def stop (* (* (* 360.0 turns) 10.0) degreesIncr)) ;; float
(def width 600.0) ;; float
(def centre (/ width 2.0)) ;; float
(def a 1.0) ;; float
(def b 20.0) ;; float
(def theta 0.0) ;; float
(def count 0) ;; int
(loop []
(when (< theta stop)
(let [r (try
(def r (+ a (* b theta))) ;; float
(def x (* r (cosApprox theta))) ;; float
(def y (* r (sinApprox theta))) ;; float
(when (= (mod count 100) 0)
  (_print (str (str (str (+ centre x)) ",") (str (- centre y))))
)
(def theta (+ theta degreesIncr)) ;; float
(def count (+ count 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
)

(-main)
