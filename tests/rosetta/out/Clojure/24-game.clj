; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _input []
  (let [s (read-line)]
    (if s
      (clojure.string/trim s)
      "")))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(def ^:dynamic _now_seeded (atom false))
  (def ^:dynamic _now_seed (atom 0))
  (defn _now []
    (when-not @_now_seeded
      (let [s (System/getenv "MOCHI_NOW_SEED")]
        (when (and s (re-matches #"\d+" s))
          (reset! _now_seed (Long/parseLong s))
          (reset! _now_seeded true))))
    (if @_now_seeded
      (do
        (swap! _now_seed #(mod (+ (* % 1664525) 1013904223) 2147483647))
        @_now_seed)
      (System/nanoTime)))
;; Function randDigit returns int
(defn randDigit []
  (try
    (throw (ex-info "return" {:value (+ (mod (_now) 9) 1)}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)

;; Function main returns any
(defn main []
  (try
    (def main_digits []) ;; list of any
    (loop [main_i 0]
      (when (< main_i 4)
        (let [r (try
          (def main_digits (conj main_digits (randDigit ))) ;; list of int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        :else (recur (inc main_i))
      )
    )
  )
)
(def main_numstr "") ;; string
(loop [main_i 0]
  (when (< main_i 4)
    (let [r (try
      (def main_numstr (str main_numstr (str (_indexList main_digits main_i)))) ;; string
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    :else (recur (inc main_i))
  )
)
)
)
(_print (str (str "Your numbers: " main_numstr) "\n"))
(_print "Enter RPN: ")
(def main_expr (_input)) ;; string
(when (not (= (count main_expr) 7))
(_print "invalid. expression length must be 7. (4 numbers, 3 operators, no spaces)")
(throw (ex-info "return" {:value nil}))
)
(def main_stack []) ;; list of any
(def main_i 0) ;; int
(def main_valid true) ;; bool
(loop []
(when (< main_i (count main_expr))
(let [r (try
  (def main_ch (.substring main_expr main_i (+ main_i 1))) ;; string
  (if (and (>= (compare main_ch "0") 0) (<= (compare main_ch "9") 0))
    (do
      (when (= (count main_digits) 0)
        (_print "too many numbers.")
        (throw (ex-info "return" {:value nil}))
      )
      (def main_j 0) ;; int
      (loop []
        (when (not (= (_indexList main_digits main_j) (- (int main_ch) (Integer/parseInt "0"))))
          (let [r (try
            (def main_j (+ main_j 1)) ;; int
            (when (= main_j (count main_digits))
              (_print "wrong numbers.")
              (throw (ex-info "return" {:value nil}))
            )
            :next
          (catch clojure.lang.ExceptionInfo e
            (cond
              (= (.getMessage e) "continue") :next
              (= (.getMessage e) "break") :break
              :else (throw e))
            )
          )]
        (cond
          (= r :break) nil
          (= r :next) (recur)
        )
      )
    )
  )
  (def main_digits (vec (concat (subvec main_digits  main_j) (subvec main_digits (+ main_j 1) )))) ;; list of int
  (def main_stack (conj main_stack (float (- (int main_ch) (Integer/parseInt "0"))))) ;; list of any
)

(do
(when (< (count main_stack) 2)
  (_print "invalid expression syntax.")
  (def main_valid false) ;; bool
  (throw (ex-info "break" {}))
)
(def main_b (_indexList main_stack (- (count main_stack) 1))) ;; any
(def main_a (_indexList main_stack (- (count main_stack) 2))) ;; any
(if (= main_ch "+")
  (do
    (def main_stack (assoc main_stack (- (count main_stack) 2) (+ main_a main_b))) ;; any
  )

(if (= main_ch "-")
  (do
    (def main_stack (assoc main_stack (- (count main_stack) 2) (- main_a main_b))) ;; any
  )

(if (= main_ch "*")
  (do
    (def main_stack (assoc main_stack (- (count main_stack) 2) (* main_a main_b))) ;; any
  )

(if (= main_ch "/")
  (do
    (def main_stack (assoc main_stack (- (count main_stack) 2) (/ main_a main_b))) ;; any
  )

(do
  (_print (str main_ch " invalid."))
  (def main_valid false) ;; bool
  (throw (ex-info "break" {}))
)
)
)
)
)
(def main_stack (subvec main_stack  (- (count main_stack) 1))) ;; list of any
)
)
(def main_i (+ main_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when main_valid
(if (> (abs (- (_indexList main_stack 0) 24.0)) 0.000001)
(do
(_print (str (str "incorrect. " (str (_indexList main_stack 0))) " != 24"))
)

(do
(_print "correct.")
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
