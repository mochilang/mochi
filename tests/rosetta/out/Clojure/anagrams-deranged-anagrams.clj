; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function sortRunes takes [s: string] and returns string
(defn sortRunes [s]
  (try
    (def arr []) ;; list of string
    (def i 0) ;; int
    (loop []
      (when (< i (count s))
        (let [r (try
          (def arr (conj arr (subs s i (+ i 1)))) ;; list of string
          (def i (+ i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(def n (count arr)) ;; int
(def m 0) ;; int
(loop []
  (when (< m n)
    (let [r (try
      (def j 0) ;; int
      (loop []
        (when (< j (- n 1))
          (let [r (try
            (when (> (compare (_indexList arr j) (_indexList arr (+ j 1))) 0)
              (def tmp (_indexList arr j)) ;; string
              (def arr (assoc arr j (_indexList arr (+ j 1)))) ;; string
              (def arr (assoc arr (+ j 1) tmp)) ;; string
            )
            (def j (+ j 1)) ;; int
            :next
          (catch clojure.lang.ExceptionInfo e
            (cond
              (= (.getMessage e) "continue") :next
              (= (.getMessage e) "break") :break
              :else (throw e))
            )
          )]
        (cond
          (= r :break) nil
          (= r :next) (recur)
        )
      )
    )
  )
  (def m (+ m 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def out "") ;; string
(def i 0) ;; int
(loop []
(when (< i n)
(let [r (try
(def out (str out (_indexList arr i))) ;; string
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value out}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function deranged takes [a: string, b: string] and returns bool
(defn deranged [a b]
(try
(when (not (= (count a) (count b)))
(throw (ex-info "return" {:value false}))
)
(def i 0) ;; int
(loop []
(when (< i (count a))
(let [r (try
(when (= (subs a i (+ i 1)) (subs b i (+ i 1)))
(throw (ex-info "return" {:value false}))
)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def words ["constitutionalism" "misconstitutional"]) ;; list of string
(def m {}) ;; map of string to list of string
(def bestLen 0) ;; int
(def w1 "") ;; string
(def w2 "") ;; string
(loop [_tmp0 (seq words)]
(when _tmp0
(let [w (clojure.core/first _tmp0)]
(let [r (try
(when (<= (count w) bestLen)
(throw (ex-info "continue" {}))
)
(def k (sortRunes w)) ;; string
(when (not (contains? m k))
(def m (assoc m k [w])) ;; list of any
(throw (ex-info "continue" {}))
)
(loop [_tmp1 (seq (get m k))]
(when _tmp1
(let [c (clojure.core/first _tmp1)]
(let [r (try
(when (deranged w c)
  (def bestLen (count w)) ;; int
  (def w1 c) ;; any
  (def w2 w) ;; any
  (throw (ex-info "break" {}))
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp1))
)
)
)
)
)
(def m (assoc m k (conj (get m k) w))) ;; list of any
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp0))
)
)
)
)
)
(_print (str (str (str (str w1 " ") w2) " : Length ") (str bestLen)))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
