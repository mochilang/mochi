; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function sortRunes takes [s: string] and returns string
(defn sortRunes [s]
  (try
    (def sortRunes_arr []) ;; list of string
    (def sortRunes_i 0) ;; int
    (loop []
      (when (< sortRunes_i (count s))
        (let [r (try
          (def sortRunes_arr (conj sortRunes_arr (subs s sortRunes_i (+ sortRunes_i 1)))) ;; list of string
          (def sortRunes_i (+ sortRunes_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(def sortRunes_n (count sortRunes_arr)) ;; int
(def sortRunes_m 0) ;; int
(loop []
  (when (< sortRunes_m sortRunes_n)
    (let [r (try
      (def sortRunes_j 0) ;; int
      (loop []
        (when (< sortRunes_j (- sortRunes_n 1))
          (let [r (try
            (when (> (compare (_indexList sortRunes_arr sortRunes_j) (_indexList sortRunes_arr (+ sortRunes_j 1))) 0)
              (def sortRunes_tmp (_indexList sortRunes_arr sortRunes_j)) ;; string
              (def sortRunes_arr (assoc sortRunes_arr sortRunes_j (_indexList sortRunes_arr (+ sortRunes_j 1)))) ;; string
              (def sortRunes_arr (assoc sortRunes_arr (+ sortRunes_j 1) sortRunes_tmp)) ;; string
            )
            (def sortRunes_j (+ sortRunes_j 1)) ;; int
            :next
          (catch clojure.lang.ExceptionInfo e
            (cond
              (= (.getMessage e) "continue") :next
              (= (.getMessage e) "break") :break
              :else (throw e))
            )
          )]
        (cond
          (= r :break) nil
          (= r :next) (recur)
        )
      )
    )
  )
  (def sortRunes_m (+ sortRunes_m 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def sortRunes_out "") ;; string
(def sortRunes_i 0) ;; int
(loop []
(when (< sortRunes_i sortRunes_n)
(let [r (try
(def sortRunes_out (str sortRunes_out (_indexList sortRunes_arr sortRunes_i))) ;; string
(def sortRunes_i (+ sortRunes_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value sortRunes_out}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function deranged takes [a: string, b: string] and returns bool
(defn deranged [a b]
(try
(when (not (= (count a) (count b)))
(throw (ex-info "return" {:value false}))
)
(def deranged_i 0) ;; int
(loop []
(when (< deranged_i (count a))
(let [r (try
(when (= (subs a deranged_i (+ deranged_i 1)) (subs b deranged_i (+ deranged_i 1)))
(throw (ex-info "return" {:value false}))
)
(def deranged_i (+ deranged_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def main_words ["constitutionalism" "misconstitutional"]) ;; list of string
(def main_m {}) ;; map of string to list of string
(def main_bestLen 0) ;; int
(def main_w1 "") ;; string
(def main_w2 "") ;; string
(loop [_tmp0 (seq main_words)]
(when _tmp0
(let [main_w (clojure.core/first _tmp0)]
(let [r (try
(when (<= (count main_w) main_bestLen)
(throw (ex-info "continue" {}))
)
(def main_k (sortRunes main_w)) ;; string
(when (not (contains? main_m main_k))
(def main_m (assoc main_m main_k [main_w])) ;; list of any
(throw (ex-info "continue" {}))
)
(loop [_tmp1 (seq (get main_m main_k))]
(when _tmp1
(let [main_c (clojure.core/first _tmp1)]
(let [r (try
(when (deranged main_w main_c)
  (def main_bestLen (count main_w)) ;; int
  (def main_w1 main_c) ;; any
  (def main_w2 main_w) ;; any
  (throw (ex-info "break" {}))
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp1))
)
)
)
)
)
(def main_m (assoc main_m main_k (conj (get main_m main_k) main_w))) ;; list of any
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (next _tmp0))
)
)
)
)
)
(_print (str (str (str (str main_w1 " ") main_w2) " : Length ") (str main_bestLen)))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
