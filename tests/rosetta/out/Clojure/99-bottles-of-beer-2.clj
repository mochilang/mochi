; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function fields takes [s: string] and returns list of string
(defn fields [s]
  (try
    (def words []) ;; list of string
    (def cur "") ;; string
    (def i 0) ;; int
    (loop []
      (when (< i (count s))
        (let [r (try
          (def ch (.substring s i (+ i 1))) ;; string
          (if (or (or (= ch " ") (= ch "\n")) (= ch "\t"))
            (do
              (when (> (count cur) 0)
                (def words (conj words cur)) ;; list of string
                (def cur "") ;; string
              )
            )

          (do
            (def cur (str cur ch)) ;; string
          )
          )
          (def i (+ i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(when (> (count cur) 0)
  (def words (conj words cur)) ;; list of string
)
(throw (ex-info "return" {:value words}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function join takes [xs: list of string, sep: string] and returns string
(defn join [xs sep]
(try
(def res "") ;; string
(def i 0) ;; int
(loop []
  (when (< i (count xs))
    (let [r (try
      (when (> i 0)
        (def res (str res sep)) ;; string
      )
      (def res (str res (_indexList xs i))) ;; string
      (def i (+ i 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value res}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function numberName takes [n: int] and returns string
(defn numberName [n]
(try
(def small ["no" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"]) ;; list of string
(def tens ["ones" "ten" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"]) ;; list of string
(when (< n 0)
(throw (ex-info "return" {:value ""}))
)
(when (< n 20)
(throw (ex-info "return" {:value (_indexList small n)}))
)
(when (< n 100)
(def t (_indexList tens (int (quot n 10)))) ;; string
(def s (mod n 10)) ;; int
(when (> s 0)
(def t (str (str t " ") (_indexList small s))) ;; string
)
(throw (ex-info "return" {:value t}))
)
(throw (ex-info "return" {:value ""}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function pluralizeFirst takes [s: string, n: int] and returns string
(defn pluralizeFirst [s n]
(try
(when (= n 1)
(throw (ex-info "return" {:value s}))
)
(def w (fields s)) ;; list of string
(when (> (count w) 0)
(def w (assoc w 0 (str (_indexList w 0) "s"))) ;; string
)
(throw (ex-info "return" {:value (join w " ")}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function randInt takes [seed: int, n: int] and returns int
(defn randInt [seed n]
(try
(def next (mod (+ (* seed 1664525) 1013904223) 2147483647)) ;; int
(throw (ex-info "return" {:value (mod next n)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function slur takes [p: string, d: int] and returns string
(defn slur [p d]
(try
(when (<= (count p) 2)
(throw (ex-info "return" {:value p}))
)
(def a []) ;; list of string
(def i 1) ;; int
(loop []
(when (< i (- (count p) 1))
(let [r (try
  (def a (conj a (.substring p i (+ i 1)))) ;; list of string
  (def i (+ i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def idx (- (count a) 1)) ;; int
(def seed d) ;; int
(loop []
(when (>= idx 1)
(let [r (try
(def seed (mod (+ (* seed 1664525) 1013904223) 2147483647)) ;; int
(when (>= (mod seed 100) d)
(def j (mod seed (+ idx 1))) ;; int
(def tmp (_indexList a idx)) ;; string
(def a (assoc a idx (_indexList a j))) ;; string
(def a (assoc a j tmp)) ;; string
)
(def idx (- idx 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def s (.substring p 0 1)) ;; string
(def k 0) ;; int
(loop []
(when (< k (count a))
(let [r (try
(def s (str s (_indexList a k))) ;; string
(def k (+ k 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def s (str s (.substring p (- (count p) 1) (count p)))) ;; string
(def w (fields s)) ;; list of string
(throw (ex-info "return" {:value (join w " ")}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def i 99) ;; int
(loop []
(when (> i 0)
(let [r (try
(_print (str (str (str (str (slur (numberName i) i) " ") (pluralizeFirst (slur "bottle of" i) i)) " ") (slur "beer on the wall" i)))
(_print (str (str (str (str (slur (numberName i) i) " ") (pluralizeFirst (slur "bottle of" i) i)) " ") (slur "beer" i)))
(_print (str (str (str (str (slur "take one" i) " ") (slur "down" i)) " ") (slur "pass it around" i)))
(_print (str (str (str (str (slur (numberName (- i 1)) i) " ") (pluralizeFirst (slur "bottle of" i) (- i 1))) " ") (slur "beer on the wall" i)))
(def i (- i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
