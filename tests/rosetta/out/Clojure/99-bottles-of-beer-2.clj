; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function fields takes [s: string] and returns list of string
(defn fields [s]
  (try
    (def fields_words []) ;; list of string
    (def fields_cur "") ;; string
    (def fields_i 0) ;; int
    (loop []
      (when (< fields_i (count s))
        (let [r (try
          (def fields_ch (.substring s fields_i (+ fields_i 1))) ;; string
          (if (or (or (= fields_ch " ") (= fields_ch "\n")) (= fields_ch "\t"))
            (do
              (when (> (count fields_cur) 0)
                (def fields_words (conj fields_words fields_cur)) ;; list of string
                (def fields_cur "") ;; string
              )
            )

          (do
            (def fields_cur (str fields_cur fields_ch)) ;; string
          )
          )
          (def fields_i (+ fields_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(when (> (count fields_cur) 0)
  (def fields_words (conj fields_words fields_cur)) ;; list of string
)
(throw (ex-info "return" {:value fields_words}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function join takes [xs: list of string, sep: string] and returns string
(defn join [xs sep]
(try
(def join_res "") ;; string
(def join_i 0) ;; int
(loop []
  (when (< join_i (count xs))
    (let [r (try
      (when (> join_i 0)
        (def join_res (str join_res sep)) ;; string
      )
      (def join_res (str join_res (_indexList xs join_i))) ;; string
      (def join_i (+ join_i 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value join_res}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function numberName takes [n: int] and returns string
(defn numberName [n]
(try
(def numberName_small ["no" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"]) ;; list of string
(def numberName_tens ["ones" "ten" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"]) ;; list of string
(when (< n 0)
(throw (ex-info "return" {:value ""}))
)
(when (< n 20)
(throw (ex-info "return" {:value (_indexList numberName_small n)}))
)
(when (< n 100)
(def numberName_t (_indexList numberName_tens (int (quot n 10)))) ;; string
(def numberName_s (mod n 10)) ;; int
(when (> numberName_s 0)
(def numberName_t (str (str numberName_t " ") (_indexList numberName_small numberName_s))) ;; string
)
(throw (ex-info "return" {:value numberName_t}))
)
(throw (ex-info "return" {:value ""}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function pluralizeFirst takes [s: string, n: int] and returns string
(defn pluralizeFirst [s n]
(try
(when (= n 1)
(throw (ex-info "return" {:value s}))
)
(def pluralizeFirst_w (fields s)) ;; list of string
(when (> (count pluralizeFirst_w) 0)
(def pluralizeFirst_w (assoc pluralizeFirst_w 0 (str (_indexList pluralizeFirst_w 0) "s"))) ;; string
)
(throw (ex-info "return" {:value (join pluralizeFirst_w " ")}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function randInt takes [seed: int, n: int] and returns int
(defn randInt [seed n]
(try
(def randInt_next (mod (+ (* seed 1664525) 1013904223) 2147483647)) ;; int
(throw (ex-info "return" {:value (mod randInt_next n)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function slur takes [p: string, d: int] and returns string
(defn slur [p d]
(try
(when (<= (count p) 2)
(throw (ex-info "return" {:value p}))
)
(def slur_a []) ;; list of string
(def slur_i 1) ;; int
(loop []
(when (< slur_i (- (count p) 1))
(let [r (try
  (def slur_a (conj slur_a (.substring p slur_i (+ slur_i 1)))) ;; list of string
  (def slur_i (+ slur_i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def slur_idx (- (count slur_a) 1)) ;; int
(def slur_seed d) ;; int
(loop []
(when (>= slur_idx 1)
(let [r (try
(def slur_seed (mod (+ (* slur_seed 1664525) 1013904223) 2147483647)) ;; int
(when (>= (mod slur_seed 100) d)
(def slur_j (mod slur_seed (+ slur_idx 1))) ;; int
(def slur_tmp (_indexList slur_a slur_idx)) ;; string
(def slur_a (assoc slur_a slur_idx (_indexList slur_a slur_j))) ;; string
(def slur_a (assoc slur_a slur_j slur_tmp)) ;; string
)
(def slur_idx (- slur_idx 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def slur_s (.substring p 0 1)) ;; string
(def slur_k 0) ;; int
(loop []
(when (< slur_k (count slur_a))
(let [r (try
(def slur_s (str slur_s (_indexList slur_a slur_k))) ;; string
(def slur_k (+ slur_k 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def slur_s (str slur_s (.substring p (- (count p) 1) (count p)))) ;; string
(def slur_w (fields slur_s)) ;; list of string
(throw (ex-info "return" {:value (join slur_w " ")}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def main_i 99) ;; int
(loop []
(when (> main_i 0)
(let [r (try
(_print (str (str (str (str (slur (numberName main_i) main_i) " ") (pluralizeFirst (slur "bottle of" main_i) main_i)) " ") (slur "beer on the wall" main_i)))
(_print (str (str (str (str (slur (numberName main_i) main_i) " ") (pluralizeFirst (slur "bottle of" main_i) main_i)) " ") (slur "beer" main_i)))
(_print (str (str (str (str (slur "take one" main_i) " ") (slur "down" main_i)) " ") (slur "pass it around" main_i)))
(_print (str (str (str (str (slur (numberName (- main_i 1)) main_i) " ") (pluralizeFirst (slur "bottle of" main_i) (- main_i 1))) " ") (slur "beer on the wall" main_i)))
(def main_i (- main_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
