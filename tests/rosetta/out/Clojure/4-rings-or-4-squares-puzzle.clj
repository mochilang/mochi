; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _equal [a b]
  (cond
    (and (sequential? a) (sequential? b))
      (and (= (count a) (count b)) (every? true? (map _equal a b)))
    (and (map? a) (map? b))
      (and (= (count a) (count b))
           (every? (fn [k] (_equal (get a k) (get b k))) (keys a)))
    (and (number? a) (number? b))
      (= (double a) (double b))
    :else
      (= a b)))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare r1 r2 r3)

;; Function validComb takes [a: int, b: int, c: int, d: int, e: int, f: int, g: int] and returns bool
(defn validComb [a b c d e f g]
  (try
    (def square1 (+ a b)) ;; int
    (def square2 (+ (+ b c) d)) ;; int
    (def square3 (+ (+ d e) f)) ;; int
    (def square4 (+ f g)) ;; int
    (throw (ex-info "return" {:value (and (and (= square1 square2) (= square2 square3)) (= square3 square4))}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)

;; Function isUnique takes [a: int, b: int, c: int, d: int, e: int, f: int, g: int] and returns bool
(defn isUnique [a b c d e f g]
  (try
    (def nums [a b c d e f g]) ;; list of int
    (def i 0) ;; int
    (loop []
      (when (< i (count nums))
        (let [r (try
          (def j (+ i 1)) ;; int
          (loop []
            (when (< j (count nums))
              (let [r (try
                (when (= (_indexList nums i) (_indexList nums j))
                  (throw (ex-info "return" {:value false}))
                )
                (def j (+ j 1)) ;; int
                :next
              (catch clojure.lang.ExceptionInfo e
                (cond
                  (= (.getMessage e) "continue") :next
                  (= (.getMessage e) "break") :break
                  :else (throw e))
                )
              )]
            (cond
              (= r :break) nil
              (= r :next) (recur)
            )
          )
        )
      )
      (def i (+ i 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function getCombs takes [low: int, high: int, unique: bool] and returns map of string to any
(defn getCombs [low high unique]
(try
(def valid []) ;; list of any
(def count 0) ;; int
(loop [b low]
(when (< b (+ high 1))
(let [r (try
  (loop [c low]
    (when (< c (+ high 1))
      (let [r (try
        (loop [d low]
          (when (< d (+ high 1))
            (let [r (try
              (def s (+ (+ b c) d)) ;; any
              (loop [e low]
                (when (< e (+ high 1))
                  (let [r (try
                    (loop [f low]
                      (when (< f (+ high 1))
                        (let [r (try
                          (def a (- s b)) ;; any
                          (def g (- s f)) ;; any
                          (when (or (< a low) (> a high))
                            (throw (ex-info "continue" {}))
                          )
                          (when (or (< g low) (> g high))
                            (throw (ex-info "continue" {}))
                          )
                          (when (not (_equal (+ (+ d e) f) s))
                            (throw (ex-info "continue" {}))
                          )
                          (when (not (_equal (+ f g) s))
                            (throw (ex-info "continue" {}))
                          )
                          (when (or (not unique) (isUnique a b c d e f g))
                            (def valid (conj valid [a b c d e f g])) ;; list of any
                            (def count (+ count 1)) ;; int
                          )
                          :next
                        (catch clojure.lang.ExceptionInfo e
                          (cond
                            (= (.getMessage e) "continue") :next
                            (= (.getMessage e) "break") :break
                            :else (throw e))
                          )
                        )]
                      (cond
                        (= r :break) nil
                        :else (recur (inc f))
                      )
                    )
                  )
                )
                :next
              (catch clojure.lang.ExceptionInfo e
                (cond
                  (= (.getMessage e) "continue") :next
                  (= (.getMessage e) "break") :break
                  :else (throw e))
                )
              )]
            (cond
              (= r :break) nil
              :else (recur (inc e))
            )
          )
        )
      )
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    :else (recur (inc d))
  )
)
)
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (inc c))
)
)
)
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (inc b))
)
)
)
)
(throw (ex-info "return" {:value {"count" count "list" valid}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def r1 (getCombs 1 7 true)) ;; map of string to any
(_print (str (str (get r1 "count")) " unique solutions in 1 to 7"))
(_print (get r1 "list"))
(def r2 (getCombs 3 9 true)) ;; map of string to any
(_print (str (str (get r2 "count")) " unique solutions in 3 to 9"))
(_print (get r2 "list"))
(def r3 (getCombs 0 9 false)) ;; map of string to any
(_print (str (str (get r3 "count")) " non-unique solutions in 0 to 9"))
)

(-main)
