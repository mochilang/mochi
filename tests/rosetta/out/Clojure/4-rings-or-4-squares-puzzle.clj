; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _equal [a b]
  (cond
    (and (sequential? a) (sequential? b))
      (and (= (count a) (count b)) (every? true? (map _equal a b)))
    (and (map? a) (map? b))
      (and (= (count a) (count b))
           (every? (fn [k] (_equal (get a k) (get b k))) (keys a)))
    (and (number? a) (number? b))
      (= (double a) (double b))
    :else
      (= a b)))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare r1 r2 r3)

;; Function validComb takes [a: int, b: int, c: int, d: int, e: int, f: int, g: int] and returns bool
(defn validComb [a b c d e f g]
  (try
    (def validComb_square1 (+ a b)) ;; int
    (def validComb_square2 (+ (+ b c) d)) ;; int
    (def validComb_square3 (+ (+ d e) f)) ;; int
    (def validComb_square4 (+ f g)) ;; int
    (throw (ex-info "return" {:value (and (and (= validComb_square1 validComb_square2) (= validComb_square2 validComb_square3)) (= validComb_square3 validComb_square4))}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)

;; Function isUnique takes [a: int, b: int, c: int, d: int, e: int, f: int, g: int] and returns bool
(defn isUnique [a b c d e f g]
  (try
    (def isUnique_nums [a b c d e f g]) ;; list of int
    (def isUnique_i 0) ;; int
    (loop []
      (when (< isUnique_i (count isUnique_nums))
        (let [r (try
          (def isUnique_j (+ isUnique_i 1)) ;; int
          (loop []
            (when (< isUnique_j (count isUnique_nums))
              (let [r (try
                (when (= (_indexList isUnique_nums isUnique_i) (_indexList isUnique_nums isUnique_j))
                  (throw (ex-info "return" {:value false}))
                )
                (def isUnique_j (+ isUnique_j 1)) ;; int
                :next
              (catch clojure.lang.ExceptionInfo e
                (cond
                  (= (.getMessage e) "continue") :next
                  (= (.getMessage e) "break") :break
                  :else (throw e))
                )
              )]
            (cond
              (= r :break) nil
              (= r :next) (recur)
            )
          )
        )
      )
      (def isUnique_i (+ isUnique_i 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function getCombs takes [low: int, high: int, unique: bool] and returns map of string to any
(defn getCombs [low high unique]
(try
(def getCombs_valid []) ;; list of any
(def getCombs_count 0) ;; int
(loop [getCombs_b low]
(when (< getCombs_b (+ high 1))
(let [r (try
  (loop [getCombs_c low]
    (when (< getCombs_c (+ high 1))
      (let [r (try
        (loop [getCombs_d low]
          (when (< getCombs_d (+ high 1))
            (let [r (try
              (def getCombs_s (+ (+ getCombs_b getCombs_c) getCombs_d)) ;; any
              (loop [getCombs_e low]
                (when (< getCombs_e (+ high 1))
                  (let [r (try
                    (loop [getCombs_f low]
                      (when (< getCombs_f (+ high 1))
                        (let [r (try
                          (def getCombs_a (- getCombs_s getCombs_b)) ;; any
                          (def getCombs_g (- getCombs_s getCombs_f)) ;; any
                          (when (or (< getCombs_a low) (> getCombs_a high))
                            (throw (ex-info "continue" {}))
                          )
                          (when (or (< getCombs_g low) (> getCombs_g high))
                            (throw (ex-info "continue" {}))
                          )
                          (when (not (_equal (+ (+ getCombs_d getCombs_e) getCombs_f) getCombs_s))
                            (throw (ex-info "continue" {}))
                          )
                          (when (not (_equal (+ getCombs_f getCombs_g) getCombs_s))
                            (throw (ex-info "continue" {}))
                          )
                          (when (or (not unique) (isUnique getCombs_a getCombs_b getCombs_c getCombs_d getCombs_e getCombs_f getCombs_g))
                            (def getCombs_valid (conj getCombs_valid [getCombs_a getCombs_b getCombs_c getCombs_d getCombs_e getCombs_f getCombs_g])) ;; list of list of any
                            (def getCombs_count (+ getCombs_count 1)) ;; int
                          )
                          :next
                        (catch clojure.lang.ExceptionInfo e
                          (cond
                            (= (.getMessage e) "continue") :next
                            (= (.getMessage e) "break") :break
                            :else (throw e))
                          )
                        )]
                      (cond
                        (= r :break) nil
                        :else (recur (inc getCombs_f))
                      )
                    )
                  )
                )
                :next
              (catch clojure.lang.ExceptionInfo e
                (cond
                  (= (.getMessage e) "continue") :next
                  (= (.getMessage e) "break") :break
                  :else (throw e))
                )
              )]
            (cond
              (= r :break) nil
              :else (recur (inc getCombs_e))
            )
          )
        )
      )
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    :else (recur (inc getCombs_d))
  )
)
)
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (inc getCombs_c))
)
)
)
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
:else (recur (inc getCombs_b))
)
)
)
)
(throw (ex-info "return" {:value {"count" getCombs_count "list" getCombs_valid}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def r1 (getCombs 1 7 true)) ;; map of string to any
(_print (str (str (get r1 "count")) " unique solutions in 1 to 7"))
(_print (get r1 "list"))
(def r2 (getCombs 3 9 true)) ;; map of string to any
(_print (str (str (get r2 "count")) " unique solutions in 3 to 9"))
(_print (get r2 "list"))
(def r3 (getCombs 0 9 false)) ;; map of string to any
(_print (str (str (get r3 "count")) " non-unique solutions in 0 to 9"))
)

(-main)
