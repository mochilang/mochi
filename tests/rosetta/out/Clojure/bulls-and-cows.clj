; Generated by Mochi compiler v0.10.28 on 2025-07-18T11:25:09Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _input []
  (let [s (read-line)]
    (if s
      (clojure.string/trim s)
      "")))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function indexOf takes [s: string, ch: string] and returns int
(defn indexOf [s ch]
  (try
    (def i 0) ;; int
    (loop []
      (when (< i (count s))
        (let [r (try
          (when (= (.substring s i (+ i 1)) ch)
            (throw (ex-info "return" {:value i}))
          )
          (def i (+ i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(throw (ex-info "return" {:value (- 1)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function shuffle takes [xs: list of string] and returns list of string
(defn shuffle [xs]
(try
(def arr xs) ;; list of string
(def i (- (count arr) 1)) ;; int
(loop []
  (when (> i 0)
    (let [r (try
      (def j (mod (System/nanoTime) (+ i 1))) ;; int
      (def tmp (_indexList arr i)) ;; string
      (def arr (assoc arr i (_indexList arr j))) ;; string
      (def arr (assoc arr j tmp)) ;; string
      (def i (- i 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value arr}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(_print "Cows and Bulls")
(_print "Guess four digit number of unique digits in the range 1 to 9.")
(_print "A correct digit but not in the correct place is a cow.")
(_print "A correct digit in the correct place is a bull.")
(def digits ["1" "2" "3" "4" "5" "6" "7" "8" "9"]) ;; list of string
(def digits (shuffle digits)) ;; list of string
(def pat (str (str (str (_indexList digits 0) (_indexList digits 1)) (_indexList digits 2)) (_indexList digits 3))) ;; string
(def valid "123456789") ;; string
(loop []
(when true
(let [r (try
  (_print "Guess: ")
  (def guess (_input)) ;; string
  (when (not (= (count guess) 4))
    (_print "Please guess a four digit number.")
    (throw (ex-info "continue" {}))
  )
  (def cows 0) ;; int
  (def bulls 0) ;; int
  (def seen "") ;; string
  (def i 0) ;; int
  (def malformed false) ;; bool
  (loop []
    (when (< i 4)
      (let [r (try
        (def cg (.substring guess i (+ i 1))) ;; string
        (when (not (= (indexOf seen cg) (- 1)))
          (_print (str "Repeated digit: " cg))
          (def malformed true) ;; bool
          (throw (ex-info "break" {}))
        )
        (def seen (str seen cg)) ;; string
        (def pos (indexOf pat cg)) ;; int
        (if (= pos (- 1))
          (do
            (when (= (indexOf valid cg) (- 1))
              (_print (str "Invalid digit: " cg))
              (def malformed true) ;; bool
              (throw (ex-info "break" {}))
            )
          )

        (do
          (if (= pos i)
            (do
              (def bulls (+ bulls 1)) ;; int
            )

          (do
            (def cows (+ cows 1)) ;; int
          )
          )
        )
        )
        (def i (+ i 1)) ;; int
        :next
      (catch clojure.lang.ExceptionInfo e
        (cond
          (= (.getMessage e) "continue") :next
          (= (.getMessage e) "break") :break
          :else (throw e))
        )
      )]
    (cond
      (= r :break) nil
      (= r :next) (recur)
    )
  )
)
)
(when malformed
(throw (ex-info "continue" {}))
)
(_print (str (str (str "Cows: " (str cows)) ", bulls: ") (str bulls)))
(when (= bulls 4)
(_print "You got it.")
(throw (ex-info "break" {}))
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)

