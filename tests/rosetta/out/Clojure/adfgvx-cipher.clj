; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexString [s i]
  (let [r (vec (seq s))
        i (if (neg? i) (+ i (count r)) i)]
    (if (or (< i 0) (>= i (count r)))
      (throw (ex-info "index out of range" {}))
      (str (nth r i)))))

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare adfgvx alphabet)

;; Function shuffleStr takes [s: string] and returns string
(defn shuffleStr [s]
  (try
    (def arr []) ;; list of string
    (def i 0) ;; int
    (loop []
      (when (< i (count s))
        (let [r (try
          (def arr (conj arr (subs s i (+ i 1)))) ;; list of string
          (def i (+ i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(def j (- (count arr) 1)) ;; int
(loop []
  (when (> j 0)
    (let [r (try
      (def k (mod (System/nanoTime) (+ j 1))) ;; int
      (def tmp (_indexList arr j)) ;; string
      (def arr (assoc arr j (_indexList arr k))) ;; string
      (def arr (assoc arr k tmp)) ;; string
      (def j (- j 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(def out "") ;; string
(def i 0) ;; int
(loop []
(when (< i (count arr))
(let [r (try
  (def out (str out (_indexList arr i))) ;; string
  (def i (+ i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value out}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function createPolybius returns list of string
(defn createPolybius []
(try
(def shuffled (shuffleStr alphabet)) ;; string
(def labels []) ;; list of string
(def li 0) ;; int
(loop []
(when (< li (count adfgvx))
(let [r (try
(def labels (conj labels (subs adfgvx li (+ li 1)))) ;; list of string
(def li (+ li 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print "6 x 6 Polybius square:\n")
(_print "  | A D F G V X")
(_print "---------------")
(def p []) ;; list of string
(def i 0) ;; int
(loop []
(when (< i 6)
(let [r (try
(def row (subs shuffled (* i 6) (* (+ i 1) 6))) ;; string
(def p (conj p row)) ;; list of string
(def line (str (subvec labels i (+ i 1)) " | ")) ;; list of any
(def j 0) ;; int
(loop []
(when (< j 6)
(let [r (try
(def line (str (str line (subs row j (+ j 1))) " ")) ;; list of any
(def j (+ j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print line)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value p}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function createKey takes [n: int] and returns string
(defn createKey [n]
(try
(when (or (< n 7) (> n 12))
(_print "Key should be within 7 and 12 letters long.")
)
(def pool "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") ;; string
(def key "") ;; string
(def i 0) ;; int
(loop []
(when (< i n)
(let [r (try
(def idx (mod (System/nanoTime) (count pool))) ;; int
(def key (str key (_indexString pool idx))) ;; string
(def pool (str (subs pool  idx) (subs pool (+ idx 1) (count pool)))) ;; string
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print (str "\nThe key is " key))
(throw (ex-info "return" {:value key}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function orderKey takes [key: string] and returns list of int
(defn orderKey [key]
(try
(def pairs []) ;; list of any
(def i 0) ;; int
(loop []
(when (< i (count key))
(let [r (try
(def pairs (conj pairs [(subs key i (+ i 1)) i])) ;; list of any
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def n (count pairs)) ;; int
(def m 0) ;; int
(loop []
(when (< m n)
(let [r (try
(def j 0) ;; int
(loop []
(when (< j (- n 1))
(let [r (try
(when (> (get (_indexList pairs j) 0) (get (_indexList pairs (+ j 1)) 0))
(def tmp (_indexList pairs j)) ;; any
(def pairs (assoc pairs j (_indexList pairs (+ j 1)))) ;; any
(def pairs (assoc pairs (+ j 1) tmp)) ;; any
)
(def j (+ j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def m (+ m 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def res []) ;; list of any
(def i 0) ;; int
(loop []
(when (< i n)
(let [r (try
(def res (conj res (int (get (_indexList pairs i) 1)))) ;; list of any
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value res}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function encrypt takes [polybius: list of string, key: string, plainText: string] and returns string
(defn encrypt [polybius key plainText]
(try
(def labels []) ;; list of string
(def li 0) ;; int
(loop []
(when (< li (count adfgvx))
(let [r (try
(def labels (conj labels (subs adfgvx li (+ li 1)))) ;; list of string
(def li (+ li 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def temp "") ;; string
(def i 0) ;; int
(loop []
(when (< i (count plainText))
(let [r (try
(def r 0) ;; int
(loop []
(when (< r 6)
(let [r (try
(def c 0) ;; int
(loop []
(when (< c 6)
(let [r (try
(when (= (subs (_indexList polybius r) c (+ c 1)) (subs plainText i (+ i 1)))
(def temp (str (str temp (subvec labels r (+ r 1))) (subvec labels c (+ c 1)))) ;; any
)
(def c (+ c 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def r (+ r 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def colLen (quot (count temp) (count key))) ;; int
(when (> (mod (count temp) (count key)) 0)
(def colLen (+ colLen 1)) ;; int
)
(def table []) ;; list of list of string
(def rIdx 0) ;; int
(loop []
(when (< rIdx colLen)
(let [r (try
(def row []) ;; list of string
(def j 0) ;; int
(loop []
(when (< j (count key))
(let [r (try
(def row (conj row "")) ;; list of string
(def j (+ j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def table (conj table row)) ;; list of list of string
(def rIdx (+ rIdx 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def idx 0) ;; int
(loop []
(when (< idx (count temp))
(let [r (try
(def row (quot idx (count key))) ;; int
(def col (mod idx (count key))) ;; int
(def table (assoc-in table [row col] (subs temp idx (+ idx 1)))) ;; any
(def idx (+ idx 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def order (orderKey key)) ;; list of int
(def cols []) ;; list of string
(def ci 0) ;; int
(loop []
(when (< ci (count key))
(let [r (try
(def colStr "") ;; string
(def ri 0) ;; int
(loop []
(when (< ri colLen)
(let [r (try
(def colStr (str colStr (_indexList (_indexList table ri) (_indexList order ci)))) ;; string
(def ri (+ ri 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def cols (conj cols colStr)) ;; list of string
(def ci (+ ci 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def result "") ;; string
(def ci 0) ;; int
(loop []
(when (< ci (count cols))
(let [r (try
(def result (str result (_indexList cols ci))) ;; string
(when (< ci (- (count cols) 1))
(def result (str result " ")) ;; string
)
(def ci (+ ci 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value result}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function indexOf takes [s: string, ch: string] and returns int
(defn indexOf [s ch]
(try
(def i 0) ;; int
(loop []
(when (< i (count s))
(let [r (try
(when (= (subs s i (+ i 1)) ch)
(throw (ex-info "return" {:value i}))
)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value (- 1)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function decrypt takes [polybius: list of string, key: string, cipherText: string] and returns string
(defn decrypt [polybius key cipherText]
(try
(def colStrs []) ;; list of string
(def start 0) ;; int
(def i 0) ;; int
(loop []
(when (<= i (count cipherText))
(let [r (try
(when (or (= i (count cipherText)) (= (_indexString cipherText i) " "))
(def colStrs (conj colStrs (subs cipherText start i))) ;; list of string
(def start (+ i 1)) ;; int
)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def maxColLen 0) ;; int
(def i 0) ;; int
(loop []
(when (< i (count colStrs))
(let [r (try
(when (> (count (_indexList colStrs i)) maxColLen)
(def maxColLen (count (_indexList colStrs i))) ;; int
)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def cols []) ;; list of list of string
(def i 0) ;; int
(loop []
(when (< i (count colStrs))
(let [r (try
(def s (_indexList colStrs i)) ;; string
(def ls []) ;; list of string
(def j 0) ;; int
(loop []
(when (< j (count s))
(let [r (try
(def ls (conj ls (subs s j (+ j 1)))) ;; list of string
(def j (+ j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(if (< (count s) maxColLen)
(do
(def pad []) ;; list of string
(def k 0) ;; int
(loop []
(when (< k maxColLen)
(let [r (try
(if (< k (count ls))
(do
(def pad (conj pad (_indexList ls k))) ;; list of string
)

(do
(def pad (conj pad "")) ;; list of string
)
)
(def k (+ k 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def cols (conj cols pad)) ;; list of list of string
)

(do
(def cols (conj cols ls)) ;; list of list of string
)
)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def table []) ;; list of list of string
(def r 0) ;; int
(loop []
(when (< r maxColLen)
(let [r (try
(def row []) ;; list of string
(def c 0) ;; int
(loop []
(when (< c (count key))
(let [r (try
(def row (conj row "")) ;; list of string
(def c (+ c 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def table (conj table row)) ;; list of list of string
(def r (+ r 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def order (orderKey key)) ;; list of int
(def r 0) ;; int
(loop []
(when (< r maxColLen)
(let [r (try
(def c 0) ;; int
(loop []
(when (< c (count key))
(let [r (try
(def table (assoc-in table [r (_indexList order c)] (_indexList (_indexList cols c) r))) ;; string
(def c (+ c 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def r (+ r 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def temp "") ;; string
(def r 0) ;; int
(loop []
(when (< r (count table))
(let [r (try
(def j 0) ;; int
(loop []
(when (< j (count (_indexList table r)))
(let [r (try
(def temp (str temp (_indexList (_indexList table r) j))) ;; string
(def j (+ j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def r (+ r 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def plainText "") ;; string
(def idx 0) ;; int
(loop []
(when (< idx (count temp))
(let [r (try
(def rIdx (indexOf adfgvx (subs temp idx (+ idx 1)))) ;; int
(def cIdx (indexOf adfgvx (subs temp (+ idx 1) (+ idx 2)))) ;; int
(def plainText (str plainText (_indexString (_indexList polybius rIdx) cIdx))) ;; string
(def idx (+ idx 2)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value plainText}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def plainText "ATTACKAT1200AM") ;; string
(def polybius (createPolybius )) ;; list of string
(def key (createKey 9)) ;; string
(_print (str "\nPlaintext : " plainText))
(def cipherText (encrypt polybius key plainText)) ;; string
(_print (str "\nEncrypted : " cipherText))
(def plainText2 (decrypt polybius key cipherText)) ;; string
(_print (str "\nDecrypted : " plainText2))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def adfgvx "ADFGVX") ;; string
(def alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") ;; string
(main )
)

(-main)
