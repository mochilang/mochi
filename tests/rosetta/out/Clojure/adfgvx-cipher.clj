; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexString [s i]
  (let [r (vec (seq s))
        i (if (neg? i) (+ i (count r)) i)]
    (if (or (< i 0) (>= i (count r)))
      (throw (ex-info "index out of range" {}))
      (str (nth r i)))))

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare adfgvx alphabet)

;; Function shuffleStr takes [s: string] and returns string
(defn shuffleStr [s]
  (try
    (def shuffleStr_arr []) ;; list of string
    (def shuffleStr_i 0) ;; int
    (loop []
      (when (< shuffleStr_i (count s))
        (let [r (try
          (def shuffleStr_arr (conj shuffleStr_arr (subs s shuffleStr_i (+ shuffleStr_i 1)))) ;; list of string
          (def shuffleStr_i (+ shuffleStr_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(def shuffleStr_j (- (count shuffleStr_arr) 1)) ;; int
(loop []
  (when (> shuffleStr_j 0)
    (let [r (try
      (def shuffleStr_k (mod (System/nanoTime) (+ shuffleStr_j 1))) ;; int
      (def shuffleStr_tmp (_indexList shuffleStr_arr shuffleStr_j)) ;; string
      (def shuffleStr_arr (assoc shuffleStr_arr shuffleStr_j (_indexList shuffleStr_arr shuffleStr_k))) ;; string
      (def shuffleStr_arr (assoc shuffleStr_arr shuffleStr_k shuffleStr_tmp)) ;; string
      (def shuffleStr_j (- shuffleStr_j 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(def shuffleStr_out "") ;; string
(def shuffleStr_i 0) ;; int
(loop []
(when (< shuffleStr_i (count shuffleStr_arr))
(let [r (try
  (def shuffleStr_out (str shuffleStr_out (_indexList shuffleStr_arr shuffleStr_i))) ;; string
  (def shuffleStr_i (+ shuffleStr_i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value shuffleStr_out}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function createPolybius returns list of string
(defn createPolybius []
(try
(def createPolybius_shuffled (shuffleStr alphabet)) ;; string
(def createPolybius_labels []) ;; list of string
(def createPolybius_li 0) ;; int
(loop []
(when (< createPolybius_li (count adfgvx))
(let [r (try
(def createPolybius_labels (conj createPolybius_labels (subs adfgvx createPolybius_li (+ createPolybius_li 1)))) ;; list of string
(def createPolybius_li (+ createPolybius_li 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print "6 x 6 Polybius square:\n")
(_print "  | A D F G V X")
(_print "---------------")
(def createPolybius_p []) ;; list of string
(def createPolybius_i 0) ;; int
(loop []
(when (< createPolybius_i 6)
(let [r (try
(def createPolybius_row (subs createPolybius_shuffled (* createPolybius_i 6) (* (+ createPolybius_i 1) 6))) ;; string
(def createPolybius_p (conj createPolybius_p createPolybius_row)) ;; list of string
(def createPolybius_line (str (subvec createPolybius_labels createPolybius_i (+ createPolybius_i 1)) " | ")) ;; list of any
(def createPolybius_j 0) ;; int
(loop []
(when (< createPolybius_j 6)
(let [r (try
(def createPolybius_line (str (str createPolybius_line (subs createPolybius_row createPolybius_j (+ createPolybius_j 1))) " ")) ;; list of any
(def createPolybius_j (+ createPolybius_j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print createPolybius_line)
(def createPolybius_i (+ createPolybius_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value createPolybius_p}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function createKey takes [n: int] and returns string
(defn createKey [n]
(try
(when (or (< n 7) (> n 12))
(_print "Key should be within 7 and 12 letters long.")
)
(def createKey_pool "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") ;; string
(def createKey_key "") ;; string
(def createKey_i 0) ;; int
(loop []
(when (< createKey_i n)
(let [r (try
(def createKey_idx (mod (System/nanoTime) (count createKey_pool))) ;; int
(def createKey_key (str createKey_key (_indexString createKey_pool createKey_idx))) ;; string
(def createKey_pool (str (subs createKey_pool  createKey_idx) (subs createKey_pool (+ createKey_idx 1) (count createKey_pool)))) ;; string
(def createKey_i (+ createKey_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print (str "\nThe key is " createKey_key))
(throw (ex-info "return" {:value createKey_key}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function orderKey takes [key: string] and returns list of int
(defn orderKey [key]
(try
(def orderKey_pairs []) ;; list of any
(def orderKey_i 0) ;; int
(loop []
(when (< orderKey_i (count key))
(let [r (try
(def orderKey_pairs (conj orderKey_pairs [(subs key orderKey_i (+ orderKey_i 1)) orderKey_i])) ;; list of any
(def orderKey_i (+ orderKey_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def orderKey_n (count orderKey_pairs)) ;; int
(def orderKey_m 0) ;; int
(loop []
(when (< orderKey_m orderKey_n)
(let [r (try
(def orderKey_j 0) ;; int
(loop []
(when (< orderKey_j (- orderKey_n 1))
(let [r (try
(when (> (get (_indexList orderKey_pairs orderKey_j) 0) (get (_indexList orderKey_pairs (+ orderKey_j 1)) 0))
(def orderKey_tmp (_indexList orderKey_pairs orderKey_j)) ;; any
(def orderKey_pairs (assoc orderKey_pairs orderKey_j (_indexList orderKey_pairs (+ orderKey_j 1)))) ;; any
(def orderKey_pairs (assoc orderKey_pairs (+ orderKey_j 1) orderKey_tmp)) ;; any
)
(def orderKey_j (+ orderKey_j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def orderKey_m (+ orderKey_m 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def orderKey_res []) ;; list of any
(def orderKey_i 0) ;; int
(loop []
(when (< orderKey_i orderKey_n)
(let [r (try
(def orderKey_res (conj orderKey_res (int (get (_indexList orderKey_pairs orderKey_i) 1)))) ;; list of any
(def orderKey_i (+ orderKey_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value orderKey_res}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function encrypt takes [polybius: list of string, key: string, plainText: string] and returns string
(defn encrypt [polybius key plainText]
(try
(def encrypt_labels []) ;; list of string
(def encrypt_li 0) ;; int
(loop []
(when (< encrypt_li (count adfgvx))
(let [r (try
(def encrypt_labels (conj encrypt_labels (subs adfgvx encrypt_li (+ encrypt_li 1)))) ;; list of string
(def encrypt_li (+ encrypt_li 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def encrypt_temp "") ;; string
(def encrypt_i 0) ;; int
(loop []
(when (< encrypt_i (count plainText))
(let [r (try
(def encrypt_r 0) ;; int
(loop []
(when (< encrypt_r 6)
(let [r (try
(def encrypt_c 0) ;; int
(loop []
(when (< encrypt_c 6)
(let [r (try
(when (= (subs (_indexList polybius encrypt_r) encrypt_c (+ encrypt_c 1)) (subs plainText encrypt_i (+ encrypt_i 1)))
(def encrypt_temp (str (str encrypt_temp (subvec encrypt_labels encrypt_r (+ encrypt_r 1))) (subvec encrypt_labels encrypt_c (+ encrypt_c 1)))) ;; any
)
(def encrypt_c (+ encrypt_c 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def encrypt_r (+ encrypt_r 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def encrypt_i (+ encrypt_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def encrypt_colLen (quot (count encrypt_temp) (count key))) ;; int
(when (> (mod (count encrypt_temp) (count key)) 0)
(def encrypt_colLen (+ encrypt_colLen 1)) ;; int
)
(def encrypt_table []) ;; list of list of string
(def encrypt_rIdx 0) ;; int
(loop []
(when (< encrypt_rIdx encrypt_colLen)
(let [r (try
(def encrypt_row []) ;; list of string
(def encrypt_j 0) ;; int
(loop []
(when (< encrypt_j (count key))
(let [r (try
(def encrypt_row (conj encrypt_row "")) ;; list of string
(def encrypt_j (+ encrypt_j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def encrypt_table (conj encrypt_table encrypt_row)) ;; list of list of string
(def encrypt_rIdx (+ encrypt_rIdx 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def encrypt_idx 0) ;; int
(loop []
(when (< encrypt_idx (count encrypt_temp))
(let [r (try
(def encrypt_row (quot encrypt_idx (count key))) ;; int
(def encrypt_col (mod encrypt_idx (count key))) ;; int
(def encrypt_table (assoc-in encrypt_table [encrypt_row encrypt_col] (subs encrypt_temp encrypt_idx (+ encrypt_idx 1)))) ;; any
(def encrypt_idx (+ encrypt_idx 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def encrypt_order (orderKey key)) ;; list of int
(def encrypt_cols []) ;; list of string
(def encrypt_ci 0) ;; int
(loop []
(when (< encrypt_ci (count key))
(let [r (try
(def encrypt_colStr "") ;; string
(def encrypt_ri 0) ;; int
(loop []
(when (< encrypt_ri encrypt_colLen)
(let [r (try
(def encrypt_colStr (str encrypt_colStr (_indexList (_indexList encrypt_table encrypt_ri) (_indexList encrypt_order encrypt_ci)))) ;; string
(def encrypt_ri (+ encrypt_ri 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def encrypt_cols (conj encrypt_cols encrypt_colStr)) ;; list of string
(def encrypt_ci (+ encrypt_ci 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def encrypt_result "") ;; string
(def encrypt_ci 0) ;; int
(loop []
(when (< encrypt_ci (count encrypt_cols))
(let [r (try
(def encrypt_result (str encrypt_result (_indexList encrypt_cols encrypt_ci))) ;; string
(when (< encrypt_ci (- (count encrypt_cols) 1))
(def encrypt_result (str encrypt_result " ")) ;; string
)
(def encrypt_ci (+ encrypt_ci 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value encrypt_result}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function indexOf takes [s: string, ch: string] and returns int
(defn indexOf [s ch]
(try
(def indexOf_i 0) ;; int
(loop []
(when (< indexOf_i (count s))
(let [r (try
(when (= (subs s indexOf_i (+ indexOf_i 1)) ch)
(throw (ex-info "return" {:value indexOf_i}))
)
(def indexOf_i (+ indexOf_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value (- 1)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function decrypt takes [polybius: list of string, key: string, cipherText: string] and returns string
(defn decrypt [polybius key cipherText]
(try
(def decrypt_colStrs []) ;; list of string
(def decrypt_start 0) ;; int
(def decrypt_i 0) ;; int
(loop []
(when (<= decrypt_i (count cipherText))
(let [r (try
(when (or (= decrypt_i (count cipherText)) (= (_indexString cipherText decrypt_i) " "))
(def decrypt_colStrs (conj decrypt_colStrs (subs cipherText decrypt_start decrypt_i))) ;; list of string
(def decrypt_start (+ decrypt_i 1)) ;; int
)
(def decrypt_i (+ decrypt_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_maxColLen 0) ;; int
(def decrypt_i 0) ;; int
(loop []
(when (< decrypt_i (count decrypt_colStrs))
(let [r (try
(when (> (count (_indexList decrypt_colStrs decrypt_i)) decrypt_maxColLen)
(def decrypt_maxColLen (count (_indexList decrypt_colStrs decrypt_i))) ;; int
)
(def decrypt_i (+ decrypt_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_cols []) ;; list of list of string
(def decrypt_i 0) ;; int
(loop []
(when (< decrypt_i (count decrypt_colStrs))
(let [r (try
(def decrypt_s (_indexList decrypt_colStrs decrypt_i)) ;; string
(def decrypt_ls []) ;; list of string
(def decrypt_j 0) ;; int
(loop []
(when (< decrypt_j (count decrypt_s))
(let [r (try
(def decrypt_ls (conj decrypt_ls (subs decrypt_s decrypt_j (+ decrypt_j 1)))) ;; list of string
(def decrypt_j (+ decrypt_j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(if (< (count decrypt_s) decrypt_maxColLen)
(do
(def decrypt_pad []) ;; list of string
(def decrypt_k 0) ;; int
(loop []
(when (< decrypt_k decrypt_maxColLen)
(let [r (try
(if (< decrypt_k (count decrypt_ls))
(do
(def decrypt_pad (conj decrypt_pad (_indexList decrypt_ls decrypt_k))) ;; list of string
)

(do
(def decrypt_pad (conj decrypt_pad "")) ;; list of string
)
)
(def decrypt_k (+ decrypt_k 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_cols (conj decrypt_cols decrypt_pad)) ;; list of list of string
)

(do
(def decrypt_cols (conj decrypt_cols decrypt_ls)) ;; list of list of string
)
)
(def decrypt_i (+ decrypt_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_table []) ;; list of list of string
(def decrypt_r 0) ;; int
(loop []
(when (< decrypt_r decrypt_maxColLen)
(let [r (try
(def decrypt_row []) ;; list of string
(def decrypt_c 0) ;; int
(loop []
(when (< decrypt_c (count key))
(let [r (try
(def decrypt_row (conj decrypt_row "")) ;; list of string
(def decrypt_c (+ decrypt_c 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_table (conj decrypt_table decrypt_row)) ;; list of list of string
(def decrypt_r (+ decrypt_r 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_order (orderKey key)) ;; list of int
(def decrypt_r 0) ;; int
(loop []
(when (< decrypt_r decrypt_maxColLen)
(let [r (try
(def decrypt_c 0) ;; int
(loop []
(when (< decrypt_c (count key))
(let [r (try
(def decrypt_table (assoc-in decrypt_table [decrypt_r (_indexList decrypt_order decrypt_c)] (_indexList (_indexList decrypt_cols decrypt_c) decrypt_r))) ;; string
(def decrypt_c (+ decrypt_c 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_r (+ decrypt_r 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_temp "") ;; string
(def decrypt_r 0) ;; int
(loop []
(when (< decrypt_r (count decrypt_table))
(let [r (try
(def decrypt_j 0) ;; int
(loop []
(when (< decrypt_j (count (_indexList decrypt_table decrypt_r)))
(let [r (try
(def decrypt_temp (str decrypt_temp (_indexList (_indexList decrypt_table decrypt_r) decrypt_j))) ;; string
(def decrypt_j (+ decrypt_j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_r (+ decrypt_r 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def decrypt_plainText "") ;; string
(def decrypt_idx 0) ;; int
(loop []
(when (< decrypt_idx (count decrypt_temp))
(let [r (try
(def decrypt_rIdx (indexOf adfgvx (subs decrypt_temp decrypt_idx (+ decrypt_idx 1)))) ;; int
(def decrypt_cIdx (indexOf adfgvx (subs decrypt_temp (+ decrypt_idx 1) (+ decrypt_idx 2)))) ;; int
(def decrypt_plainText (str decrypt_plainText (_indexString (_indexList polybius decrypt_rIdx) decrypt_cIdx))) ;; string
(def decrypt_idx (+ decrypt_idx 2)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value decrypt_plainText}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def main_plainText "ATTACKAT1200AM") ;; string
(def main_polybius (createPolybius )) ;; list of string
(def main_key (createKey 9)) ;; string
(_print (str "\nPlaintext : " main_plainText))
(def main_cipherText (encrypt main_polybius main_key main_plainText)) ;; string
(_print (str "\nEncrypted : " main_cipherText))
(def main_plainText2 (decrypt main_polybius main_key main_cipherText)) ;; string
(_print (str "\nDecrypted : " main_plainText2))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def adfgvx "ADFGVX") ;; string
(def alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") ;; string
(main )
)

(-main)
