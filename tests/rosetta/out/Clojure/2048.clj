; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _input []
  (let [s (read-line)]
    (if s
      (clojure.string/trim s)
      "")))

(defn _equal [a b]
  (cond
    (and (sequential? a) (sequential? b))
      (and (= (count a) (count b)) (every? true? (map _equal a b)))
    (and (map? a) (map? b))
      (and (= (count a) (count b))
           (every? (fn [k] (_equal (get a k) (get b k))) (keys a)))
    (and (number? a) (number? b))
      (= (double a) (double b))
    :else
      (= a b)))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare SIZE board r full score)

;; Function newBoard returns list of list of int
(defn newBoard []
  (try
    (def newBoard_b []) ;; list of list of int
    (def newBoard_y 0) ;; int
    (loop []
      (when (< newBoard_y SIZE)
        (let [r (try
          (def newBoard_row []) ;; list of int
          (def newBoard_x 0) ;; int
          (loop []
            (when (< newBoard_x SIZE)
              (let [r (try
                (def newBoard_row (conj newBoard_row 0)) ;; list of int
                (def newBoard_x (+ newBoard_x 1)) ;; int
                :next
              (catch clojure.lang.ExceptionInfo e
                (cond
                  (= (.getMessage e) "continue") :next
                  (= (.getMessage e) "break") :break
                  :else (throw e))
                )
              )]
            (cond
              (= r :break) nil
              (= r :next) (recur)
            )
          )
        )
      )
      (def newBoard_b (conj newBoard_b newBoard_row)) ;; list of list of int
      (def newBoard_y (+ newBoard_y 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value newBoard_b}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function spawnTile takes [b: list of list of int] and returns map of string to any
(defn spawnTile [b]
(try
(def spawnTile_empty []) ;; list of list of int
(def spawnTile_y 0) ;; int
(loop []
(when (< spawnTile_y SIZE)
(let [r (try
  (def spawnTile_x 0) ;; int
  (loop []
    (when (< spawnTile_x SIZE)
      (let [r (try
        (when (= (_indexList (_indexList b spawnTile_y) spawnTile_x) 0)
          (def spawnTile_empty (conj spawnTile_empty [spawnTile_x spawnTile_y])) ;; list of list of int
        )
        (def spawnTile_x (+ spawnTile_x 1)) ;; int
        :next
      (catch clojure.lang.ExceptionInfo e
        (cond
          (= (.getMessage e) "continue") :next
          (= (.getMessage e) "break") :break
          :else (throw e))
        )
      )]
    (cond
      (= r :break) nil
      (= r :next) (recur)
    )
  )
)
)
(def spawnTile_y (+ spawnTile_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when (= (count spawnTile_empty) 0)
(throw (ex-info "return" {:value {"board" b "full" true}}))
)
(def spawnTile_idx (mod (System/nanoTime) (count spawnTile_empty))) ;; int
(def spawnTile_cell (_indexList spawnTile_empty spawnTile_idx)) ;; list of int
(def spawnTile_val 4) ;; int
(when (< (mod (System/nanoTime) 10) 9)
(def spawnTile_val 2) ;; int
)
(def b (assoc-in b [(_indexList spawnTile_cell 1) (_indexList spawnTile_cell 0)] spawnTile_val)) ;; int
(throw (ex-info "return" {:value {"board" b "full" (= (count spawnTile_empty) 1)}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function pad takes [n: int] and returns string
(defn pad [n]
(try
(def pad_s (str n)) ;; string
(def pad_pad (- 4 (count pad_s))) ;; int
(def pad_i 0) ;; int
(def pad_out "") ;; string
(loop []
(when (< pad_i pad_pad)
(let [r (try
(def pad_out (str pad_out " ")) ;; string
(def pad_i (+ pad_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value (str pad_out pad_s)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function draw takes [b: list of list of int, score: int] and returns any
(defn draw [b score]
(try
(_print (str "Score: " (str score)))
(def draw_y 0) ;; int
(loop []
(when (< draw_y SIZE)
(let [r (try
(_print "+----+----+----+----+")
(def draw_line "|") ;; string
(def draw_x 0) ;; int
(loop []
(when (< draw_x SIZE)
(let [r (try
(def draw_v (_indexList (_indexList b draw_y) draw_x)) ;; int
(if (= draw_v 0)
(do
(def draw_line (str draw_line "    |")) ;; string
)

(do
(def draw_line (str (str draw_line (pad draw_v)) "|")) ;; string
)
)
(def draw_x (+ draw_x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print draw_line)
(def draw_y (+ draw_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print "+----+----+----+----+")
(_print "W=Up S=Down A=Left D=Right Q=Quit")
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function reverseRow takes [r: list of int] and returns list of int
(defn reverseRow [r]
(try
(def reverseRow_out []) ;; list of int
(def reverseRow_i (- (count r) 1)) ;; int
(loop []
(when (>= reverseRow_i 0)
(let [r (try
(def reverseRow_out (conj reverseRow_out (_indexList r reverseRow_i))) ;; list of int
(def reverseRow_i (- reverseRow_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value reverseRow_out}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function slideLeft takes [row: list of int] and returns map of string to any
(defn slideLeft [row]
(try
(def slideLeft_xs []) ;; list of int
(def slideLeft_i 0) ;; int
(loop []
(when (< slideLeft_i (count row))
(let [r (try
(when (not (= (_indexList row slideLeft_i) 0))
(def slideLeft_xs (conj slideLeft_xs (_indexList row slideLeft_i))) ;; list of int
)
(def slideLeft_i (+ slideLeft_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def slideLeft_res []) ;; list of int
(def slideLeft_gain 0) ;; int
(def slideLeft_i 0) ;; int
(loop []
(when (< slideLeft_i (count slideLeft_xs))
(let [r (try
(if (and (< (+ slideLeft_i 1) (count slideLeft_xs)) (= (_indexList slideLeft_xs slideLeft_i) (_indexList slideLeft_xs (+ slideLeft_i 1))))
(do
(def slideLeft_v (* (_indexList slideLeft_xs slideLeft_i) 2)) ;; int
(def slideLeft_gain (+ slideLeft_gain slideLeft_v)) ;; int
(def slideLeft_res (conj slideLeft_res slideLeft_v)) ;; list of int
(def slideLeft_i (+ slideLeft_i 2)) ;; int
)

(do
(def slideLeft_res (conj slideLeft_res (_indexList slideLeft_xs slideLeft_i))) ;; list of int
(def slideLeft_i (+ slideLeft_i 1)) ;; int
)
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(loop []
(when (< (count slideLeft_res) SIZE)
(let [r (try
(def slideLeft_res (conj slideLeft_res 0)) ;; list of int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"row" slideLeft_res "gain" slideLeft_gain}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function moveLeft takes [b: list of list of int, score: int] and returns map of string to any
(defn moveLeft [b score]
(try
(def moveLeft_moved false) ;; bool
(def moveLeft_y 0) ;; int
(loop []
(when (< moveLeft_y SIZE)
(let [r (try
(def r (slideLeft (_indexList b moveLeft_y))) ;; map of string to any
(def moveLeft_new (get r "row")) ;; any
(def score (+ score (get r "gain"))) ;; any
(def moveLeft_x 0) ;; int
(loop []
(when (< moveLeft_x SIZE)
(let [r (try
(when (not (_equal (_indexList (_indexList b moveLeft_y) moveLeft_x) (get moveLeft_new moveLeft_x)))
(def moveLeft_moved true) ;; bool
)
(def b (assoc-in b [moveLeft_y moveLeft_x] (get moveLeft_new moveLeft_x))) ;; any
(def moveLeft_x (+ moveLeft_x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def moveLeft_y (+ moveLeft_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"board" b "score" score "moved" moveLeft_moved}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function moveRight takes [b: list of list of int, score: int] and returns map of string to any
(defn moveRight [b score]
(try
(def moveRight_moved false) ;; bool
(def moveRight_y 0) ;; int
(loop []
(when (< moveRight_y SIZE)
(let [r (try
(def moveRight_rev (reverseRow (_indexList b moveRight_y))) ;; list of int
(def r (slideLeft moveRight_rev)) ;; map of string to any
(def moveRight_rev (get r "row")) ;; any
(def score (+ score (get r "gain"))) ;; any
(def moveRight_rev (reverseRow moveRight_rev)) ;; list of int
(def moveRight_x 0) ;; int
(loop []
(when (< moveRight_x SIZE)
(let [r (try
(when (not (= (_indexList (_indexList b moveRight_y) moveRight_x) (_indexList moveRight_rev moveRight_x)))
(def moveRight_moved true) ;; bool
)
(def b (assoc-in b [moveRight_y moveRight_x] (_indexList moveRight_rev moveRight_x))) ;; int
(def moveRight_x (+ moveRight_x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def moveRight_y (+ moveRight_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"board" b "score" score "moved" moveRight_moved}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function getCol takes [b: list of list of int, x: int] and returns list of int
(defn getCol [b x]
(try
(def getCol_col []) ;; list of int
(def getCol_y 0) ;; int
(loop []
(when (< getCol_y SIZE)
(let [r (try
(def getCol_col (conj getCol_col (_indexList (_indexList b getCol_y) x))) ;; list of int
(def getCol_y (+ getCol_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value getCol_col}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function setCol takes [b: list of list of int, x: int, col: list of int] and returns any
(defn setCol [b x col]
(try
(def setCol_y 0) ;; int
(loop []
(when (< setCol_y SIZE)
(let [r (try
(def b (assoc-in b [setCol_y x] (_indexList col setCol_y))) ;; int
(def setCol_y (+ setCol_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function moveUp takes [b: list of list of int, score: int] and returns map of string to any
(defn moveUp [b score]
(try
(def moveUp_moved false) ;; bool
(def moveUp_x 0) ;; int
(loop []
(when (< moveUp_x SIZE)
(let [r (try
(def moveUp_col (getCol b moveUp_x)) ;; list of int
(def r (slideLeft moveUp_col)) ;; map of string to any
(def moveUp_new (get r "row")) ;; any
(def score (+ score (get r "gain"))) ;; any
(def moveUp_y 0) ;; int
(loop []
(when (< moveUp_y SIZE)
(let [r (try
(when (not (_equal (_indexList (_indexList b moveUp_y) moveUp_x) (get moveUp_new moveUp_y)))
(def moveUp_moved true) ;; bool
)
(def b (assoc-in b [moveUp_y moveUp_x] (get moveUp_new moveUp_y))) ;; any
(def moveUp_y (+ moveUp_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def moveUp_x (+ moveUp_x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"board" b "score" score "moved" moveUp_moved}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function moveDown takes [b: list of list of int, score: int] and returns map of string to any
(defn moveDown [b score]
(try
(def moveDown_moved false) ;; bool
(def moveDown_x 0) ;; int
(loop []
(when (< moveDown_x SIZE)
(let [r (try
(def moveDown_col (reverseRow (getCol b moveDown_x))) ;; list of int
(def r (slideLeft moveDown_col)) ;; map of string to any
(def moveDown_col (get r "row")) ;; any
(def score (+ score (get r "gain"))) ;; any
(def moveDown_col (reverseRow moveDown_col)) ;; list of int
(def moveDown_y 0) ;; int
(loop []
(when (< moveDown_y SIZE)
(let [r (try
(when (not (= (_indexList (_indexList b moveDown_y) moveDown_x) (_indexList moveDown_col moveDown_y)))
(def moveDown_moved true) ;; bool
)
(def b (assoc-in b [moveDown_y moveDown_x] (_indexList moveDown_col moveDown_y))) ;; int
(def moveDown_y (+ moveDown_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def moveDown_x (+ moveDown_x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"board" b "score" score "moved" moveDown_moved}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function hasMoves takes [b: list of list of int] and returns bool
(defn hasMoves [b]
(try
(def hasMoves_y 0) ;; int
(loop []
(when (< hasMoves_y SIZE)
(let [r (try
(def hasMoves_x 0) ;; int
(loop []
(when (< hasMoves_x SIZE)
(let [r (try
(when (= (_indexList (_indexList b hasMoves_y) hasMoves_x) 0)
(throw (ex-info "return" {:value true}))
)
(when (and (< (+ hasMoves_x 1) SIZE) (= (_indexList (_indexList b hasMoves_y) hasMoves_x) (_indexList (_indexList b hasMoves_y) (+ hasMoves_x 1))))
(throw (ex-info "return" {:value true}))
)
(when (and (< (+ hasMoves_y 1) SIZE) (= (_indexList (_indexList b hasMoves_y) hasMoves_x) (_indexList (_indexList b (+ hasMoves_y 1)) hasMoves_x)))
(throw (ex-info "return" {:value true}))
)
(def hasMoves_x (+ hasMoves_x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def hasMoves_y (+ hasMoves_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value false}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function has2048 takes [b: list of list of int] and returns bool
(defn has2048 [b]
(try
(def has2048_y 0) ;; int
(loop []
(when (< has2048_y SIZE)
(let [r (try
(def has2048_x 0) ;; int
(loop []
(when (< has2048_x SIZE)
(let [r (try
(when (>= (_indexList (_indexList b has2048_y) has2048_x) 2048)
(throw (ex-info "return" {:value true}))
)
(def has2048_x (+ has2048_x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def has2048_y (+ has2048_y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value false}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def SIZE 4) ;; int
(def board (newBoard )) ;; list of list of int
(def r (spawnTile board)) ;; map of string to any
(def board (get r "board")) ;; any
(def full (get r "full")) ;; any
(def r (spawnTile board)) ;; map of string to any
(def board (get r "board")) ;; any
(def full (get r "full")) ;; any
(def score 0) ;; int
(draw board score)
(loop []
(when true
(let [r (try
(_print "Move: ")
(def cmd (_input)) ;; string
(def moved false) ;; bool
(when (or (= cmd "a") (= cmd "A"))
(def m (moveLeft board score)) ;; map of string to any
(def board (get m "board")) ;; any
(def score (get m "score")) ;; any
(def moved (get m "moved")) ;; any
)
(when (or (= cmd "d") (= cmd "D"))
(def m (moveRight board score)) ;; map of string to any
(def board (get m "board")) ;; any
(def score (get m "score")) ;; any
(def moved (get m "moved")) ;; any
)
(when (or (= cmd "w") (= cmd "W"))
(def m (moveUp board score)) ;; map of string to any
(def board (get m "board")) ;; any
(def score (get m "score")) ;; any
(def moved (get m "moved")) ;; any
)
(when (or (= cmd "s") (= cmd "S"))
(def m (moveDown board score)) ;; map of string to any
(def board (get m "board")) ;; any
(def score (get m "score")) ;; any
(def moved (get m "moved")) ;; any
)
(when (or (= cmd "q") (= cmd "Q"))
(throw (ex-info "break" {}))
)
(when moved
(def r2 (spawnTile board)) ;; map of string to any
(def board (get r2 "board")) ;; any
(def full (get r2 "full")) ;; any
(when (and full (not (hasMoves board)))
(draw board score)
(_print "Game Over")
(throw (ex-info "break" {}))
)
)
(draw board score)
(when (has2048 board)
(_print "You win!")
(throw (ex-info "break" {}))
)
(when (not (hasMoves board))
(_print "Game Over")
(throw (ex-info "break" {}))
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
)

(-main)
