; Generated by Mochi compiler v0.10.28 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _input []
  (let [s (read-line)]
    (if s
      (clojure.string/trim s)
      "")))

(defn _equal [a b]
  (cond
    (and (sequential? a) (sequential? b))
      (and (= (count a) (count b)) (every? true? (map _equal a b)))
    (and (map? a) (map? b))
      (and (= (count a) (count b))
           (every? (fn [k] (_equal (get a k) (get b k))) (keys a)))
    (and (number? a) (number? b))
      (= (double a) (double b))
    :else
      (= a b)))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare SIZE board r full score)

;; Function newBoard returns list of list of int
(defn newBoard []
  (try
    (def b []) ;; list of list of int
    (def y 0) ;; int
    (loop []
      (when (< y SIZE)
        (let [r (try
          (def row []) ;; list of int
          (def x 0) ;; int
          (loop []
            (when (< x SIZE)
              (let [r (try
                (def row (conj row 0)) ;; list of int
                (def x (+ x 1)) ;; int
                :next
              (catch clojure.lang.ExceptionInfo e
                (cond
                  (= (.getMessage e) "continue") :next
                  (= (.getMessage e) "break") :break
                  :else (throw e))
                )
              )]
            (cond
              (= r :break) nil
              (= r :next) (recur)
            )
          )
        )
      )
      (def b (conj b row)) ;; list of list of int
      (def y (+ y 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value b}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function spawnTile takes [b: list of list of int] and returns map of string to any
(defn spawnTile [b]
(try
(def empty []) ;; list of list of int
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
  (def x 0) ;; int
  (loop []
    (when (< x SIZE)
      (let [r (try
        (when (= (_indexList (_indexList b y) x) 0)
          (def empty (conj empty [x y])) ;; list of list of int
        )
        (def x (+ x 1)) ;; int
        :next
      (catch clojure.lang.ExceptionInfo e
        (cond
          (= (.getMessage e) "continue") :next
          (= (.getMessage e) "break") :break
          :else (throw e))
        )
      )]
    (cond
      (= r :break) nil
      (= r :next) (recur)
    )
  )
)
)
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when (= (count empty) 0)
(throw (ex-info "return" {:value {"board" b "full" true}}))
)
(def idx (mod (System/nanoTime) (count empty))) ;; int
(def cell (_indexList empty idx)) ;; list of int
(def val 4) ;; int
(when (< (mod (System/nanoTime) 10) 9)
(def val 2) ;; int
)
(def b (assoc-in b [(_indexList cell 1) (_indexList cell 0)] val)) ;; int
(throw (ex-info "return" {:value {"board" b "full" (= (count empty) 1)}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function pad takes [n: int] and returns string
(defn pad [n]
(try
(def s (str n)) ;; string
(def pad (- 4 (count s))) ;; int
(def i 0) ;; int
(def out "") ;; string
(loop []
(when (< i pad)
(let [r (try
(def out (str out " ")) ;; string
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value (str out s)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function draw takes [b: list of list of int, score: int] and returns any
(defn draw [b score]
(try
(_print (str "Score: " (str score)))
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
(_print "+----+----+----+----+")
(def line "|") ;; string
(def x 0) ;; int
(loop []
(when (< x SIZE)
(let [r (try
(def v (_indexList (_indexList b y) x)) ;; int
(if (= v 0)
(do
(def line (str line "    |")) ;; string
)

(do
(def line (str (str line (pad v)) "|")) ;; string
)
)
(def x (+ x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print line)
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print "+----+----+----+----+")
(_print "W=Up S=Down A=Left D=Right Q=Quit")
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function reverseRow takes [r: list of int] and returns list of int
(defn reverseRow [r]
(try
(def out []) ;; list of int
(def i (- (count r) 1)) ;; int
(loop []
(when (>= i 0)
(let [r (try
(def out (conj out (_indexList r i))) ;; list of int
(def i (- i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value out}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function slideLeft takes [row: list of int] and returns map of string to any
(defn slideLeft [row]
(try
(def xs []) ;; list of int
(def i 0) ;; int
(loop []
(when (< i (count row))
(let [r (try
(when (not (= (_indexList row i) 0))
(def xs (conj xs (_indexList row i))) ;; list of int
)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def res []) ;; list of int
(def gain 0) ;; int
(def i 0) ;; int
(loop []
(when (< i (count xs))
(let [r (try
(if (and (< (+ i 1) (count xs)) (= (_indexList xs i) (_indexList xs (+ i 1))))
(do
(def v (* (_indexList xs i) 2)) ;; int
(def gain (+ gain v)) ;; int
(def res (conj res v)) ;; list of int
(def i (+ i 2)) ;; int
)

(do
(def res (conj res (_indexList xs i))) ;; list of int
(def i (+ i 1)) ;; int
)
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(loop []
(when (< (count res) SIZE)
(let [r (try
(def res (conj res 0)) ;; list of int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"row" res "gain" gain}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function moveLeft takes [b: list of list of int, score: int] and returns map of string to any
(defn moveLeft [b score]
(try
(def moved false) ;; bool
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
(def r (slideLeft (_indexList b y))) ;; map of string to any
(def new (get r "row")) ;; any
(def score (+ score (get r "gain"))) ;; any
(def x 0) ;; int
(loop []
(when (< x SIZE)
(let [r (try
(when (not (_equal (_indexList (_indexList b y) x) (get new x)))
(def moved true) ;; bool
)
(def b (assoc-in b [y x] (get new x))) ;; any
(def x (+ x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"board" b "score" score "moved" moved}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function moveRight takes [b: list of list of int, score: int] and returns map of string to any
(defn moveRight [b score]
(try
(def moved false) ;; bool
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
(def rev (reverseRow (_indexList b y))) ;; list of int
(def r (slideLeft rev)) ;; map of string to any
(def rev (get r "row")) ;; any
(def score (+ score (get r "gain"))) ;; any
(def rev (reverseRow rev)) ;; list of int
(def x 0) ;; int
(loop []
(when (< x SIZE)
(let [r (try
(when (not (= (_indexList (_indexList b y) x) (_indexList rev x)))
(def moved true) ;; bool
)
(def b (assoc-in b [y x] (_indexList rev x))) ;; int
(def x (+ x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"board" b "score" score "moved" moved}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function getCol takes [b: list of list of int, x: int] and returns list of int
(defn getCol [b x]
(try
(def col []) ;; list of int
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
(def col (conj col (_indexList (_indexList b y) x))) ;; list of int
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value col}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function setCol takes [b: list of list of int, x: int, col: list of int] and returns any
(defn setCol [b x col]
(try
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
(def b (assoc-in b [y x] (_indexList col y))) ;; int
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function moveUp takes [b: list of list of int, score: int] and returns map of string to any
(defn moveUp [b score]
(try
(def moved false) ;; bool
(def x 0) ;; int
(loop []
(when (< x SIZE)
(let [r (try
(def col (getCol b x)) ;; list of int
(def r (slideLeft col)) ;; map of string to any
(def new (get r "row")) ;; any
(def score (+ score (get r "gain"))) ;; any
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
(when (not (_equal (_indexList (_indexList b y) x) (get new y)))
(def moved true) ;; bool
)
(def b (assoc-in b [y x] (get new y))) ;; any
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def x (+ x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"board" b "score" score "moved" moved}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function moveDown takes [b: list of list of int, score: int] and returns map of string to any
(defn moveDown [b score]
(try
(def moved false) ;; bool
(def x 0) ;; int
(loop []
(when (< x SIZE)
(let [r (try
(def col (reverseRow (getCol b x))) ;; list of int
(def r (slideLeft col)) ;; map of string to any
(def col (get r "row")) ;; any
(def score (+ score (get r "gain"))) ;; any
(def col (reverseRow col)) ;; list of int
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
(when (not (= (_indexList (_indexList b y) x) (_indexList col y)))
(def moved true) ;; bool
)
(def b (assoc-in b [y x] (_indexList col y))) ;; int
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def x (+ x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"board" b "score" score "moved" moved}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function hasMoves takes [b: list of list of int] and returns bool
(defn hasMoves [b]
(try
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
(def x 0) ;; int
(loop []
(when (< x SIZE)
(let [r (try
(when (= (_indexList (_indexList b y) x) 0)
(throw (ex-info "return" {:value true}))
)
(when (and (< (+ x 1) SIZE) (= (_indexList (_indexList b y) x) (_indexList (_indexList b y) (+ x 1))))
(throw (ex-info "return" {:value true}))
)
(when (and (< (+ y 1) SIZE) (= (_indexList (_indexList b y) x) (_indexList (_indexList b (+ y 1)) x)))
(throw (ex-info "return" {:value true}))
)
(def x (+ x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value false}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function has2048 takes [b: list of list of int] and returns bool
(defn has2048 [b]
(try
(def y 0) ;; int
(loop []
(when (< y SIZE)
(let [r (try
(def x 0) ;; int
(loop []
(when (< x SIZE)
(let [r (try
(when (>= (_indexList (_indexList b y) x) 2048)
(throw (ex-info "return" {:value true}))
)
(def x (+ x 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def y (+ y 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value false}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def SIZE 4) ;; int
(def board (newBoard )) ;; list of list of int
(def r (spawnTile board)) ;; map of string to any
(def board (get r "board")) ;; any
(def full (get r "full")) ;; any
(def r (spawnTile board)) ;; map of string to any
(def board (get r "board")) ;; any
(def full (get r "full")) ;; any
(def score 0) ;; int
(draw board score)
(loop []
(when true
(let [r (try
(_print "Move: ")
(def cmd (_input)) ;; string
(def moved false) ;; bool
(when (or (= cmd "a") (= cmd "A"))
(def m (moveLeft board score)) ;; map of string to any
(def board (get m "board")) ;; any
(def score (get m "score")) ;; any
(def moved (get m "moved")) ;; any
)
(when (or (= cmd "d") (= cmd "D"))
(def m (moveRight board score)) ;; map of string to any
(def board (get m "board")) ;; any
(def score (get m "score")) ;; any
(def moved (get m "moved")) ;; any
)
(when (or (= cmd "w") (= cmd "W"))
(def m (moveUp board score)) ;; map of string to any
(def board (get m "board")) ;; any
(def score (get m "score")) ;; any
(def moved (get m "moved")) ;; any
)
(when (or (= cmd "s") (= cmd "S"))
(def m (moveDown board score)) ;; map of string to any
(def board (get m "board")) ;; any
(def score (get m "score")) ;; any
(def moved (get m "moved")) ;; any
)
(when (or (= cmd "q") (= cmd "Q"))
(throw (ex-info "break" {}))
)
(when moved
(def r2 (spawnTile board)) ;; map of string to any
(def board (get r2 "board")) ;; any
(def full (get r2 "full")) ;; any
(when (and full (not (hasMoves board)))
(draw board score)
(_print "Game Over")
(throw (ex-info "break" {}))
)
)
(draw board score)
(when (has2048 board)
(_print "You win!")
(throw (ex-info "break" {}))
)
(when (not (hasMoves board))
(_print "Game Over")
(throw (ex-info "break" {}))
)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
)

(-main)
