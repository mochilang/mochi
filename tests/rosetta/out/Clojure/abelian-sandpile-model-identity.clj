; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(declare s4 s1 s2 s3_a s3_b s3 s3_id s4b s5)

;; Function neighborsList returns list of list of int
(defn neighborsList []
  (try
    (throw (ex-info "return" {:value [[1 3] [0 2 4] [1 5] [0 4 6] [1 3 5 7] [2 4 8] [3 7] [4 6 8] [5 7]]}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)

;; Function plus takes [a: list of int, b: list of int] and returns list of int
(defn plus [a b]
  (try
    (def plus_res []) ;; list of int
    (def plus_i 0) ;; int
    (loop []
      (when (< plus_i (count a))
        (let [r (try
          (def plus_res (conj plus_res (+ (_indexList a plus_i) (_indexList b plus_i)))) ;; list of int
          (def plus_i (+ plus_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(throw (ex-info "return" {:value plus_res}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function isStable takes [p: list of int] and returns bool
(defn isStable [p]
(try
(loop [_tmp0 (seq p)]
  (when _tmp0
    (let [isStable_v (clojure.core/first _tmp0)]
      (let [r (try
        (when (> isStable_v 3)
          (throw (ex-info "return" {:value false}))
        )
        :next
      (catch clojure.lang.ExceptionInfo e
        (cond
          (= (.getMessage e) "continue") :next
          (= (.getMessage e) "break") :break
          :else (throw e))
        )
      )]
    (cond
      (= r :break) nil
      :else (recur (next _tmp0))
    )
  )
)
)
)
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function topple takes [p: list of int] and returns int
(defn topple [p]
(try
(def topple_neighbors (neighborsList )) ;; list of list of int
(def topple_i 0) ;; int
(loop []
(when (< topple_i (count p))
(let [r (try
  (when (> (_indexList p topple_i) 3)
    (def p (assoc p topple_i (- (_indexList p topple_i) 4))) ;; int
    (def topple_nbs (_indexList topple_neighbors topple_i)) ;; list of int
    (loop [_tmp1 (seq topple_nbs)]
      (when _tmp1
        (let [topple_j (clojure.core/first _tmp1)]
          (let [r (try
            (def p (assoc p topple_j (+ (_indexList p topple_j) 1))) ;; int
            :next
          (catch clojure.lang.ExceptionInfo e
            (cond
              (= (.getMessage e) "continue") :next
              (= (.getMessage e) "break") :break
              :else (throw e))
            )
          )]
        (cond
          (= r :break) nil
          :else (recur (next _tmp1))
        )
      )
    )
  )
)
(throw (ex-info "return" {:value 0}))
)
(def topple_i (+ topple_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value 0}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function pileString takes [p: list of int] and returns string
(defn pileString [p]
(try
(def pileString_s "") ;; string
(def pileString_r 0) ;; int
(loop []
(when (< pileString_r 3)
(let [r (try
(def pileString_c 0) ;; int
(loop []
(when (< pileString_c 3)
(let [r (try
(def pileString_s (str (str pileString_s (str (_indexList p (+ (* 3 pileString_r) pileString_c)))) " ")) ;; string
(def pileString_c (+ pileString_c 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def pileString_s (str pileString_s "\n")) ;; string
(def pileString_r (+ pileString_r 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value pileString_s}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(_print "Avalanche of topplings:\n")
(def s4 [4 3 3 3 1 2 0 2 3]) ;; list of int
(_print (pileString s4))
(loop []
(when (not (isStable s4))
(let [r (try
(topple s4)
(_print (pileString s4))
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print "Commutative additions:\n")
(def s1 [1 2 0 2 1 1 0 1 3]) ;; list of int
(def s2 [2 1 3 1 0 1 0 1 0]) ;; list of int
(def s3_a (plus s1 s2)) ;; list of int
(loop []
(when (not (isStable s3_a))
(let [r (try
(topple s3_a)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def s3_b (plus s2 s1)) ;; list of int
(loop []
(when (not (isStable s3_b))
(let [r (try
(topple s3_b)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print (str (str (str (str (pileString s1) "\nplus\n\n") (pileString s2)) "\nequals\n\n") (pileString s3_a)))
(_print (str (str (str (str (str "and\n\n" (pileString s2)) "\nplus\n\n") (pileString s1)) "\nalso equals\n\n") (pileString s3_b)))
(_print "Addition of identity sandpile:\n")
(def s3 [3 3 3 3 3 3 3 3 3]) ;; list of int
(def s3_id [2 1 2 1 0 1 2 1 2]) ;; list of int
(def s4b (plus s3 s3_id)) ;; list of int
(loop []
(when (not (isStable s4b))
(let [r (try
(topple s4b)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print (str (str (str (str (pileString s3) "\nplus\n\n") (pileString s3_id)) "\nequals\n\n") (pileString s4b)))
(_print "Addition of identities:\n")
(def s5 (plus s3_id s3_id)) ;; list of int
(loop []
(when (not (isStable s5))
(let [r (try
(topple s5)
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print (str (str (str (str (pileString s3_id) "\nplus\n\n") (pileString s3_id)) "\nequals\n\n") (pileString s5)))
)

(-main)
