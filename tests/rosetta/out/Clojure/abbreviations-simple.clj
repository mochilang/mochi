; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function fields takes [s: string] and returns list of string
(defn fields [s]
  (try
    (def fields_words []) ;; list of string
    (def fields_cur "") ;; string
    (def fields_i 0) ;; int
    (loop []
      (when (< fields_i (count s))
        (let [r (try
          (def fields_ch (.substring s fields_i (+ fields_i 1))) ;; string
          (if (or (or (= fields_ch " ") (= fields_ch "\n")) (= fields_ch "\t"))
            (do
              (when (> (count fields_cur) 0)
                (def fields_words (conj fields_words fields_cur)) ;; list of string
                (def fields_cur "") ;; string
              )
            )

          (do
            (def fields_cur (str fields_cur fields_ch)) ;; string
          )
          )
          (def fields_i (+ fields_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(when (> (count fields_cur) 0)
  (def fields_words (conj fields_words fields_cur)) ;; list of string
)
(throw (ex-info "return" {:value fields_words}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function padRight takes [s: string, width: int] and returns string
(defn padRight [s width]
(try
(def padRight_out s) ;; string
(def padRight_i (count s)) ;; int
(loop []
  (when (< padRight_i width)
    (let [r (try
      (def padRight_out (str padRight_out " ")) ;; string
      (def padRight_i (+ padRight_i 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(throw (ex-info "return" {:value padRight_out}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function join takes [xs: list of string, sep: string] and returns string
(defn join [xs sep]
(try
(def join_res "") ;; string
(def join_i 0) ;; int
(loop []
(when (< join_i (count xs))
(let [r (try
  (when (> join_i 0)
    (def join_res (str join_res sep)) ;; string
  )
  (def join_res (str join_res (_indexList xs join_i))) ;; string
  (def join_i (+ join_i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value join_res}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function parseIntStr takes [str: string] and returns int
(defn parseIntStr [str]
(try
(def parseIntStr_i 0) ;; int
(def parseIntStr_neg false) ;; bool
(when (and (> (count str) 0) (= (subs str 0 1) "-"))
(def parseIntStr_neg true) ;; bool
(def parseIntStr_i 1) ;; int
)
(def parseIntStr_n 0) ;; int
(def parseIntStr_digits {"0" 0 "1" 1 "2" 2 "3" 3 "4" 4 "5" 5 "6" 6 "7" 7 "8" 8 "9" 9}) ;; map of string to int
(loop []
(when (< parseIntStr_i (count str))
(let [r (try
(def parseIntStr_n (+ (* parseIntStr_n 10) (get parseIntStr_digits (subs str parseIntStr_i (+ parseIntStr_i 1))))) ;; int
(def parseIntStr_i (+ parseIntStr_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when parseIntStr_neg
(def parseIntStr_n (- parseIntStr_n)) ;; int
)
(throw (ex-info "return" {:value parseIntStr_n}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function isDigits takes [s: string] and returns bool
(defn isDigits [s]
(try
(when (= (count s) 0)
(throw (ex-info "return" {:value false}))
)
(def isDigits_i 0) ;; int
(loop []
(when (< isDigits_i (count s))
(let [r (try
(def isDigits_ch (.substring s isDigits_i (+ isDigits_i 1))) ;; string
(when (or (< (compare isDigits_ch "0") 0) (> (compare isDigits_ch "9") 0))
(throw (ex-info "return" {:value false}))
)
(def isDigits_i (+ isDigits_i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function readTable takes [table: string] and returns map of string to any
(defn readTable [table]
(try
(def readTable_toks (fields table)) ;; list of string
(def readTable_cmds []) ;; list of string
(def readTable_mins []) ;; list of int
(def readTable_i 0) ;; int
(loop []
(when (< readTable_i (count readTable_toks))
(let [r (try
(def readTable_cmd (_indexList readTable_toks readTable_i)) ;; string
(def readTable_minlen (count readTable_cmd)) ;; int
(def readTable_i (+ readTable_i 1)) ;; int
(when (and (< readTable_i (count readTable_toks)) (isDigits (_indexList readTable_toks readTable_i)))
(def readTable_num (parseIntStr (_indexList readTable_toks readTable_i))) ;; int
(when (and (>= readTable_num 1) (< readTable_num (count readTable_cmd)))
(def readTable_minlen readTable_num) ;; int
(def readTable_i (+ readTable_i 1)) ;; int
)
)
(def readTable_cmds (conj readTable_cmds readTable_cmd)) ;; list of string
(def readTable_mins (conj readTable_mins readTable_minlen)) ;; list of int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value {"commands" readTable_cmds "mins" readTable_mins}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function validate takes [commands: list of string, mins: list of int, words: list of string] and returns list of string
(defn validate [commands mins words]
(try
(def validate_results []) ;; list of string
(def validate_wi 0) ;; int
(loop []
(when (< validate_wi (count words))
(let [r (try
(def validate_w (_indexList words validate_wi)) ;; string
(def validate_found false) ;; bool
(def validate_wlen (count validate_w)) ;; int
(def validate_ci 0) ;; int
(loop []
(when (< validate_ci (count commands))
(let [r (try
(def validate_cmd (_indexList commands validate_ci)) ;; string
(when (and (and (not (= (_indexList mins validate_ci) 0)) (>= validate_wlen (_indexList mins validate_ci))) (<= validate_wlen (count validate_cmd)))
(def validate_c (clojure.string/upper-case validate_cmd)) ;; string
(def validate_ww (clojure.string/upper-case validate_w)) ;; string
(when (= (.substring validate_c 0 validate_wlen) validate_ww)
(def validate_results (conj validate_results validate_c)) ;; list of string
(def validate_found true) ;; bool
(throw (ex-info "break" {}))
)
)
(def validate_ci (+ validate_ci 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when (not validate_found)
(def validate_results (conj validate_results "*error*")) ;; list of string
)
(def validate_wi (+ validate_wi 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value validate_results}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(def main_table (str (str (str (str (str (str (str (str "" "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ") "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ") "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ") "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ") "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ") "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ") "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ") "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ")) ;; string
(def main_sentence "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin") ;; string
(def main_tbl (readTable main_table)) ;; map of string to any
(def main_commands (get main_tbl "commands")) ;; list of string
(def main_mins (get main_tbl "mins")) ;; list of int
(def main_words (fields main_sentence)) ;; list of string
(def main_results (validate main_commands main_mins main_words)) ;; list of string
(def main_out1 "user words:") ;; string
(def main_k 0) ;; int
(loop []
(when (< main_k (count main_words))
(let [r (try
(def main_out1 (str main_out1 " ")) ;; string
(if (< main_k (- (count main_words) 1))
(do
(def main_out1 (str main_out1 (padRight (_indexList main_words main_k) (count (_indexList main_results main_k))))) ;; string
)

(do
(def main_out1 (str main_out1 (_indexList main_words main_k))) ;; string
)
)
(def main_k (+ main_k 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(_print main_out1)
(_print (str "full words: " (join main_results " ")))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)
