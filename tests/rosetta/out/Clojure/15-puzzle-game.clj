; Generated by Mochi compiler v0.10.30 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _input []
  (let [s (read-line)]
    (if s
      (clojure.string/trim s)
      "")))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
(def ^:dynamic _now_seeded (atom false))
  (def ^:dynamic _now_seed (atom 0))
  (defn _now []
    (when-not @_now_seeded
      (let [s (System/getenv "MOCHI_NOW_SEED")]
        (when (and s (re-matches #"\d+" s))
          (reset! _now_seed (Long/parseLong s))
          (reset! _now_seeded true))))
    (if @_now_seeded
      (do
        (swap! _now_seed #(mod (+ (* % 1664525) 1013904223) 2147483647))
        @_now_seed)
      (System/nanoTime)))
(declare board solved empty moves quit)

;; Function randMove returns int
(defn randMove []
  (try
    (throw (ex-info "return" {:value (mod (_now) 4)}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)

;; Function isSolved returns bool
(defn isSolved []
  (try
    (def isSolved_i 0) ;; int
    (loop []
      (when (< isSolved_i 16)
        (let [r (try
          (when (not (= (_indexList board isSolved_i) (_indexList solved isSolved_i)))
            (throw (ex-info "return" {:value false}))
          )
          (def isSolved_i (+ isSolved_i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function isValidMove takes [m: int] and returns map of string to any
(defn isValidMove [m]
(try
(when (= m 0)
  (throw (ex-info "return" {:value {"idx" (- empty 4) "ok" (> (quot empty 4) 0)}}))
)
(when (= m 1)
  (throw (ex-info "return" {:value {"idx" (+ empty 4) "ok" (< (quot empty 4) 3)}}))
)
(when (= m 2)
  (throw (ex-info "return" {:value {"idx" (+ empty 1) "ok" (< (mod empty 4) 3)}}))
)
(when (= m 3)
  (throw (ex-info "return" {:value {"idx" (- empty 1) "ok" (> (mod empty 4) 0)}}))
)
(throw (ex-info "return" {:value {"idx" 0 "ok" false}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function doMove takes [m: int] and returns bool
(defn doMove [m]
(try
(def doMove_r (isValidMove m)) ;; map of string to any
(when (not (get doMove_r "ok"))
  (throw (ex-info "return" {:value false}))
)
(def doMove_i empty) ;; int
(def doMove_j (int (get doMove_r "idx"))) ;; int
(def doMove_tmp (_indexList board doMove_i)) ;; int
(def board (assoc board doMove_i (_indexList board doMove_j))) ;; int
(def board (assoc board doMove_j doMove_tmp)) ;; int
(def empty doMove_j) ;; int
(def moves (+ moves 1)) ;; int
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function shuffle takes [n: int] and returns any
(defn shuffle [n]
(try
(def shuffle_i 0) ;; int
(loop []
  (when (or (< shuffle_i n) (isSolved ))
    (let [r (try
      (when (doMove (randMove ))
        (def shuffle_i (+ shuffle_i 1)) ;; int
      )
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function printBoard returns any
(defn printBoard []
(try
(def printBoard_line "") ;; string
(def printBoard_i 0) ;; int
(loop []
(when (< printBoard_i 16)
(let [r (try
  (def printBoard_val (_indexList board printBoard_i)) ;; int
  (if (= printBoard_val 0)
    (do
      (def printBoard_line (str printBoard_line "  .")) ;; string
    )

  (do
    (def printBoard_s (str printBoard_val)) ;; string
    (if (< printBoard_val 10)
      (do
        (def printBoard_line (str (str printBoard_line "  ") printBoard_s)) ;; string
      )

    (do
      (def printBoard_line (str (str printBoard_line " ") printBoard_s)) ;; string
    )
    )
  )
  )
  (when (= (mod printBoard_i 4) 3)
    (_print printBoard_line)
    (def printBoard_line "") ;; string
  )
  (def printBoard_i (+ printBoard_i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function playOneMove returns any
(defn playOneMove []
(try
(loop []
(when true
(let [r (try
(_print (str (str "Enter move #" (str (+ moves 1))) " (U, D, L, R, or Q): "))
(def playOneMove_s (_input)) ;; string
(when (= playOneMove_s "")
(throw (ex-info "continue" {}))
)
(def playOneMove_c (subs playOneMove_s 0 1)) ;; string
(def playOneMove_m 0) ;; int
(if (or (= playOneMove_c "U") (= playOneMove_c "u"))
(do
  (def playOneMove_m 0) ;; int
)

(if (or (= playOneMove_c "D") (= playOneMove_c "d"))
(do
  (def playOneMove_m 1) ;; int
)

(if (or (= playOneMove_c "R") (= playOneMove_c "r"))
(do
  (def playOneMove_m 2) ;; int
)

(if (or (= playOneMove_c "L") (= playOneMove_c "l"))
(do
  (def playOneMove_m 3) ;; int
)

(if (or (= playOneMove_c "Q") (= playOneMove_c "q"))
(do
  (_print (str (str "Quiting after " (str moves)) " moves."))
  (def quit true) ;; bool
  (throw (ex-info "return" {:value nil}))
)

(do
(_print (str (str (str "Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" "up, down, left, or right. You can also enter \"Q\" to quit.\n") "Upper or lowercase is accepted and only the first non-blank\n") "character is important (i.e. you may enter \"up\" if you like)."))
(throw (ex-info "continue" {}))
)
)
)
)
)
)
(when (not (doMove playOneMove_m))
(_print "That is not a valid move at the moment.")
(throw (ex-info "continue" {}))
)
(throw (ex-info "return" {:value nil}))
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function play returns any
(defn play []
(try
(_print "Starting board:")
(loop []
(when (and (not quit) (= (isSolved ) false))
(let [r (try
(_print "")
(printBoard )
(playOneMove )
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when (isSolved )
(_print (str (str "You solved the puzzle in " (str moves)) " moves."))
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(shuffle 50)
(play )
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def board [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0]) ;; list of int
(def solved [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0]) ;; list of int
(def empty 15) ;; int
(def moves 0) ;; int
(def quit false) ;; bool
(main )
)

(-main)
