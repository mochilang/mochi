; Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _input []
  (let [s (read-line)]
    (if s
      (clojure.string/trim s)
      "")))

(defn _equal [a b]
  (cond
    (and (sequential? a) (sequential? b))
      (and (= (count a) (count b)) (every? true? (map _equal a b)))
    (and (map? a) (map? b))
      (and (= (count a) (count b))
           (every? (fn [k] (_equal (get a k) (get b k))) (keys a)))
    (and (number? a) (number? b))
      (= (double a) (double b))
    :else
      (= a b)))

(declare board solved empty moves quit)

;; Function randMove returns int
(defn randMove []
  (try
    (throw (ex-info "return" {:value (mod (System/nanoTime) 4)}))
  (catch clojure.lang.ExceptionInfo e
    (if (= (.getMessage e) "return")
      (:value (ex-data e))
    (throw e)))
  )
)

;; Function isSolved returns bool
(defn isSolved []
  (try
    (def i 0) ;; int
    (loop []
      (when (< i 16)
        (let [r (try
          (when (not (_equal (_indexList board i) (_indexList solved i)))
            (throw (ex-info "return" {:value false}))
          )
          (def i (+ i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function isValidMove takes [m: int] and returns map of string to any
(defn isValidMove [m]
(try
(when (_equal m 0)
  (throw (ex-info "return" {:value {"idx" (- empty 4) "ok" (> (quot empty 4) 0)}}))
)
(when (_equal m 1)
  (throw (ex-info "return" {:value {"idx" (+ empty 4) "ok" (< (quot empty 4) 3)}}))
)
(when (_equal m 2)
  (throw (ex-info "return" {:value {"idx" (+ empty 1) "ok" (< (mod empty 4) 3)}}))
)
(when (_equal m 3)
  (throw (ex-info "return" {:value {"idx" (- empty 1) "ok" (> (mod empty 4) 0)}}))
)
(throw (ex-info "return" {:value {"idx" 0 "ok" false}}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function doMove takes [m: int] and returns bool
(defn doMove [m]
(try
(def r (isValidMove m)) ;; map of string to any
(when (not (get r "ok"))
  (throw (ex-info "return" {:value false}))
)
(def i empty) ;; int
(def j (int (get r "idx"))) ;; int
(def tmp (_indexList board i)) ;; int
(def board (assoc board i (_indexList board j))) ;; int
(def board (assoc board j tmp)) ;; int
(def empty j) ;; int
(def moves (+ moves 1)) ;; int
(throw (ex-info "return" {:value true}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function shuffle takes [n: int] and returns any
(defn shuffle [n]
(try
(def i 0) ;; int
(loop []
  (when (or (< i n) (isSolved ))
    (let [r (try
      (when (doMove (randMove ))
        (def i (+ i 1)) ;; int
      )
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function printBoard returns any
(defn printBoard []
(try
(def line "") ;; string
(def i 0) ;; int
(loop []
(when (< i 16)
(let [r (try
  (def val (_indexList board i)) ;; int
  (if (_equal val 0)
    (do
      (def line (str line "  .")) ;; string
    )

  (do
    (def s (str val)) ;; string
    (if (< val 10)
      (do
        (def line (str (str line "  ") s)) ;; string
      )

    (do
      (def line (str (str line " ") s)) ;; string
    )
    )
  )
  )
  (when (_equal (mod i 4) 3)
    (println line)
    (def line "") ;; string
  )
  (def i (+ i 1)) ;; int
  :next
(catch clojure.lang.ExceptionInfo e
  (cond
    (= (.getMessage e) "continue") :next
    (= (.getMessage e) "break") :break
    :else (throw e))
  )
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function playOneMove returns any
(defn playOneMove []
(try
(loop []
(when true
(let [r (try
(println (str (str "Enter move #" (str (+ moves 1))) " (U, D, L, R, or Q): "))
(def s (_input)) ;; string
(when (_equal s "")
(throw (ex-info "continue" {}))
)
(def c (subs s 0 1)) ;; string
(def m 0) ;; int
(if (or (_equal c "U") (_equal c "u"))
(do
  (def m 0) ;; int
)

(if (or (_equal c "D") (_equal c "d"))
(do
  (def m 1) ;; int
)

(if (or (_equal c "R") (_equal c "r"))
(do
  (def m 2) ;; int
)

(if (or (_equal c "L") (_equal c "l"))
(do
  (def m 3) ;; int
)

(if (or (_equal c "Q") (_equal c "q"))
(do
  (println (str (str "Quiting after " (str moves)) " moves."))
  (def quit true) ;; bool
  (throw (ex-info "return" {:value nil}))
)

(do
(println (str (str (str "Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" "up, down, left, or right. You can also enter \"Q\" to quit.\n") "Upper or lowercase is accepted and only the first non-blank\n") "character is important (i.e. you may enter \"up\" if you like)."))
(throw (ex-info "continue" {}))
)
)
)
)
)
)
(when (not (doMove m))
(println "That is not a valid move at the moment.")
(throw (ex-info "continue" {}))
)
(throw (ex-info "return" {:value nil}))
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function play returns any
(defn play []
(try
(println "Starting board:")
(loop []
(when (not quit)
(let [r (try
(when (isSolved )
(throw (ex-info "break" {}))
)
(println "")
(printBoard )
(playOneMove )
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when (isSolved )
(println (str (str "You solved the puzzle in " (str moves)) " moves."))
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(shuffle 50)
(play )
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(def board [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0]) ;; list of int
(def solved [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0]) ;; list of int
(def empty 15) ;; int
(def moves 0) ;; int
(def quit false) ;; bool
(main )
)

(-main)
