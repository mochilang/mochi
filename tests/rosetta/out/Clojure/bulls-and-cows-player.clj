; Generated by Mochi compiler v0.10.28 on 2025-07-18T11:30:03Z
(ns main)

(defn _indexList [xs i]
  (let [idx (if (neg? i) (+ i (count xs)) i)]
    (if (or (< idx 0) (>= idx (count xs)))
      (throw (ex-info "index out of range" {}))
      (nth xs idx))))

(defn _input []
  (let [s (read-line)]
    (if s
      (clojure.string/trim s)
      "")))

(defn _print [& args]
  (letfn [(pv [v]
            (cond
              (true? v) (print 1)
              (false? v) (print 0)
              (sequential? v) (doseq [[i x] (map-indexed vector v)]
                                (when (> i 0) (print " "))
                                (pv x))
              :else (print v)))]
    (doseq [[i a] (map-indexed vector args)]
      (when (> i 0) (print " "))
      (pv a))
    (println)))
;; Function indexOf takes [s: string, ch: string] and returns int
(defn indexOf [s ch]
  (try
    (def i 0) ;; int
    (loop []
      (when (< i (count s))
        (let [r (try
          (when (= (.substring s i (+ i 1)) ch)
            (throw (ex-info "return" {:value i}))
          )
          (def i (+ i 1)) ;; int
          :next
        (catch clojure.lang.ExceptionInfo e
          (cond
            (= (.getMessage e) "continue") :next
            (= (.getMessage e) "break") :break
            :else (throw e))
          )
        )]
      (cond
        (= r :break) nil
        (= r :next) (recur)
      )
    )
  )
)
(throw (ex-info "return" {:value (- 1)}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
  (:value (ex-data e))
(throw e)))
)
)

;; Function fields takes [s: string] and returns list of string
(defn fields [s]
(try
(def words []) ;; list of string
(def cur "") ;; string
(def i 0) ;; int
(loop []
  (when (< i (count s))
    (let [r (try
      (def ch (.substring s i (+ i 1))) ;; string
      (if (or (or (= ch " ") (= ch "\t")) (= ch "\n"))
        (do
          (when (> (count cur) 0)
            (def words (conj words cur)) ;; list of string
            (def cur "") ;; string
          )
        )

      (do
        (def cur (str cur ch)) ;; string
      )
      )
      (def i (+ i 1)) ;; int
      :next
    (catch clojure.lang.ExceptionInfo e
      (cond
        (= (.getMessage e) "continue") :next
        (= (.getMessage e) "break") :break
        :else (throw e))
      )
    )]
  (cond
    (= r :break) nil
    (= r :next) (recur)
  )
)
)
)
(when (> (count cur) 0)
(def words (conj words cur)) ;; list of string
)
(throw (ex-info "return" {:value words}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function makePatterns returns list of string
(defn makePatterns []
(try
(def digits ["1" "2" "3" "4" "5" "6" "7" "8" "9"]) ;; list of string
(def pats []) ;; list of string
(def i 0) ;; int
(loop []
(when (< i (count digits))
(let [r (try
  (def j 0) ;; int
  (loop []
    (when (< j (count digits))
      (let [r (try
        (when (not (= j i))
          (def k 0) ;; int
          (loop []
            (when (< k (count digits))
              (let [r (try
                (when (and (not (= k i)) (not (= k j)))
                  (def l 0) ;; int
                  (loop []
                    (when (< l (count digits))
                      (let [r (try
                        (when (and (and (not (= l i)) (not (= l j))) (not (= l k)))
                          (def pats (conj pats (str (str (str (_indexList digits i) (_indexList digits j)) (_indexList digits k)) (_indexList digits l)))) ;; list of string
                        )
                        (def l (+ l 1)) ;; int
                        :next
                      (catch clojure.lang.ExceptionInfo e
                        (cond
                          (= (.getMessage e) "continue") :next
                          (= (.getMessage e) "break") :break
                          :else (throw e))
                        )
                      )]
                    (cond
                      (= r :break) nil
                      (= r :next) (recur)
                    )
                  )
                )
              )
            )
            (def k (+ k 1)) ;; int
            :next
          (catch clojure.lang.ExceptionInfo e
            (cond
              (= (.getMessage e) "continue") :next
              (= (.getMessage e) "break") :break
              :else (throw e))
            )
          )]
        (cond
          (= r :break) nil
          (= r :next) (recur)
        )
      )
    )
  )
)
(def j (+ j 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
  (= (.getMessage e) "continue") :next
  (= (.getMessage e) "break") :break
  :else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(throw (ex-info "return" {:value pats}))
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

;; Function main returns any
(defn main []
(try
(_print (str (str (str (str (str "Cows and bulls/player\n" "You think of four digit number of unique digits in the range 1 to 9.\n") "I guess.  You score my guess:\n") "    A correct digit but not in the correct place is a cow.\n") "    A correct digit in the correct place is a bull.\n") "You give my score as two numbers separated with a space."))
(def patterns (makePatterns )) ;; list of string
(loop []
(when true
(let [r (try
(when (= (count patterns) 0)
(_print "Oops, check scoring.")
(throw (ex-info "return" {:value nil}))
)
(def guess (_indexList patterns 0)) ;; string
(def patterns (subvec patterns 1 )) ;; list of string
(def cows 0) ;; int
(def bulls 0) ;; int
(loop []
(when true
(let [r (try
(_print (str (str "My guess: " guess) ".  Score? (c b) "))
(def line (_input)) ;; string
(def toks (fields line)) ;; list of string
(when (= (count toks) 2)
(def c (int (_indexList toks 0))) ;; int
(def b (int (_indexList toks 1))) ;; int
(when (and (and (and (and (>= c 0) (<= c 4)) (>= b 0)) (<= b 4)) (<= (+ c b) 4))
(def cows c) ;; int
(def bulls b) ;; int
(throw (ex-info "break" {}))
)
)
(_print "Score guess as two numbers: cows bulls")
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when (= bulls 4)
(_print "I did it. :)")
(throw (ex-info "return" {:value nil}))
)
(def next []) ;; list of string
(def idx 0) ;; int
(loop []
(when (< idx (count patterns))
(let [r (try
(def pat (_indexList patterns idx)) ;; string
(def c 0) ;; int
(def b 0) ;; int
(def i 0) ;; int
(loop []
(when (< i 4)
(let [r (try
(def cg (.substring guess i (+ i 1))) ;; string
(def cp (.substring pat i (+ i 1))) ;; string
(if (= cg cp)
(do
(def b (+ b 1)) ;; int
)

(when (>= (indexOf pat cg) 0)
(def c (+ c 1)) ;; int
)
)
(def i (+ i 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(when (and (= c cows) (= b bulls))
(def next (conj next pat)) ;; list of string
)
(def idx (+ idx 1)) ;; int
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(def patterns next) ;; list of string
:next
(catch clojure.lang.ExceptionInfo e
(cond
(= (.getMessage e) "continue") :next
(= (.getMessage e) "break") :break
:else (throw e))
)
)]
(cond
(= r :break) nil
(= r :next) (recur)
)
)
)
)
(catch clojure.lang.ExceptionInfo e
(if (= (.getMessage e) "return")
(:value (ex-data e))
(throw e)))
)
)

(defn -main []
(main )
)

(-main)

