-- Generated by Mochi compiler v0.10.26 on 2025-07-16T09:31:21Z
-- Code generated by Mochi compiler; DO NOT EDIT.
{-# LANGUAGE DeriveGeneric #-}

module Main where

import qualified Data.Map as Map
import Data.Maybe (fromMaybe)

data AnyValue = VInt Int | VDouble Double | VString String | VBool Bool deriving (Show)

_asInt :: AnyValue -> Int
_asInt (VInt n) = n
_asInt v = error ("expected int, got " ++ show v)

_asDouble :: AnyValue -> Double
_asDouble (VDouble d) = d
_asDouble v = error ("expected double, got " ++ show v)

_asString :: AnyValue -> String
_asString (VString s) = s
_asString v = error ("expected string, got " ++ show v)

_asBool :: AnyValue -> Bool
_asBool (VBool b) = b
_asBool v = error ("expected bool, got " ++ show v)

_showAny :: AnyValue -> String
_showAny (VInt n) = show n
_showAny (VDouble d) = show d
_showAny (VString s) = s
_showAny (VBool b) = if b then "true" else "false"

poolPut :: [Int] -> Int -> [Int]
poolPut p x = (p ++ [x])

poolGet :: [Int] -> Map.Map String ()
poolGet p = fromMaybe (()) $
  case if (length p == 0) then case (let _ = putStrLn ("pool empty") in Nothing) of Just v -> Just v; Nothing -> Just (Map.fromList [("pool", p), ("val", VInt (0))]) else Nothing of Just v -> Just v; Nothing -> (let idx = (length p - 1) in (let v = (p !! idx) in (let p = take (idx - 0) (drop 0 p) in Just (Map.fromList [("pool", p), ("val", v)]))))

clearPool :: [Int] -> [Int]
clearPool p = []

main :: ()
main =
  fromMaybe (()) $
    (let pool = [] in (let i = 1 in (let j = 2 in case (let _ = putStrLn (show (i + j)) in Nothing) of Just v -> Just v; Nothing -> (let pool = poolPut pool i in (let pool = poolPut pool j in (let i = 0 in (let j = 0 in (let res1 = poolGet pool in (let pool = (res1 !! "pool") in (let i = (read (res1 !! "val") :: Int) in (let res2 = poolGet pool in (let pool = (res2 !! "pool") in (let j = (read (res2 !! "val") :: Int) in (let i = 4 in (let j = 5 in case (let _ = putStrLn (show (i + j)) in Nothing) of Just v -> Just v; Nothing -> (let pool = poolPut pool i in (let pool = poolPut pool j in (let i = 0 in (let j = 0 in (let pool = clearPool pool in (let res3 = poolGet pool in (let pool = (res3 !! "pool") in (let i = (read (res3 !! "val") :: Int) in (let res4 = poolGet pool in (let pool = (res4 !! "pool") in (let j = (read (res4 !! "val") :: Int) in (let i = 7 in (let j = 8 in (let _ = putStrLn (show (i + j)) in Nothing)))))))))))))))))))))))))))))

main :: IO ()
main = do
  main
