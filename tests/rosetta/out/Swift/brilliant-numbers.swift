// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:55:41Z
func primesUpTo(_ n: Int) -> [Int] {
    var sieve: [Bool] = [Any]()
    var i = 0
    while i <= n {
        sieve = sieve + [true]
        i = i + 1
    }
    var p = 2
    while p * p <= n {
        if sieve[p] {
            var m = p * p
            while m <= n {
                sieve[m] = false
                m = m + p
            }
        }
        p = p + 1
    }
    var res: [Int] = [Any]()
    var x = 2
    while x <= n {
        if sieve[x] {
            res = res + [x]
        }
        x = x + 1
    }
    return res
}
func sortInts(_ xs: [Int]) -> [Int] {
    var res: [Int] = [Any]()
    var tmp = xs
    while tmp.count > 0 {
        var min = tmp[0]
        var idx = 0
        var i = 1
        while i < tmp.count {
            if tmp[i] < min {
                min = tmp[i]
                idx = i
            }
            i = i + 1
        }
        res = res + [min]
        var out: [Int] = [Any]()
        var j = 0
        while j < tmp.count {
            if j != idx {
                out = out + [tmp[j]]
            }
            j = j + 1
        }
        tmp = out
    }
    return res
}
func commatize(_ n: Int) -> String {
    var s = String(n)
    var i = s.count - 3
    while i >= 1 {
        s = Array(s[0..<i]) + "," + Array(s[i..<s.count])
        i = i - 3
    }
    return s
}
var primes = primesUpTo(3200000)
func getBrilliant(_ digits: Int, _ limit: Int, _ countOnly: Bool) -> [String: any] {
    var brilliant: [Int] = [Any]()
    var count = 0
    var pow = 1
    var next = 999999999999999
    var k = 1
    while k <= digits {
        var s: [Int] = [Any]()
        for p in primes {
            if p >= pow * 10 {
                break
            }
            if p > pow {
                s = s + [p]
            }
        }
        var i = 0
        while i < s.count {
            var j = i
            while j < s.count {
                var prod = s[i] * s[j]
                if prod < limit {
                    if countOnly {
                        count = count + 1
                    }
                    else {
                        brilliant = brilliant + [prod]
                    }
                }
                else {
                    if prod < next {
                        next = prod
                    }
                    break
                }
                j = j + 1
            }
            i = i + 1
        }
        pow = pow * 10
        k = k + 1
    }
    if countOnly {
        return ["bc": count, "next": next]
    }
    return ["bc": brilliant, "next": next]
}
func main() {
    print("First 100 brilliant numbers:")
    let r = getBrilliant(2, 10000, false)
    var br = sortInts(r["bc"])
    br = Array(br[0..<100])
    var i = 0
    while i < br.count {
        print(String(br[i]).padStart(4, " ") + " ", false)
        if (i + 1) % 10 == 0 {
            print("", true)
        }
        i = i + 1
    }
    print("", true)
    var k = 1
    while k <= 13 {
        let limit = pow(10, k)
        let r2 = getBrilliant(k, limit, true)
        let total = r2["bc"]
        let next = r2["next"]
        let climit = commatize(limit)
        let ctotal = commatize(total + 1)
        let cnext = commatize(next)
        print("First >= " + climit.padStart(18, " ") + " is " + ctotal.padStart(14, " ") + " in the series: " + cnext.padStart(18, " "))
        k = k + 1
    }
}
