// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:55:22Z
func square_to_maps(_ square: [[String]]) -> [String: any] {
    var emap: [String: [Int]] = []
    var dmap: [String: String] = []
    var x = 0
    while x < square.count {
        let row = square[x]
        var y = 0
        while y < row.count {
            let ch = row[y]
            emap[ch] = [x, y]
            dmap[String(x) + "," + String(y)] = ch
            y = y + 1
        }
        x = x + 1
    }
    return ["e": emap, "d": dmap]
}
func remove_space(_ text: String, _ emap: [String: [Int]]) -> String {
    let s = upper(text)
    var out = ""
    var i = 0
    while i < s.count {
        let ch = Array(s[i..<i + 1])
        if emap.keys.contains(ch != " " && ch) {
            out = out + ch
        }
        i = i + 1
    }
    return out
}
func encrypt(_ text: String, _ emap: [String: [Int]], _ dmap: [String: String]) -> String {
    text = remove_space(text, emap)
    var row0: [Int] = [Any]()
    var row1: [Int] = [Any]()
    var i = 0
    while i < text.count {
        let ch = Array(text[i..<i + 1])
        let xy = emap[ch]!
        row0 = row0 + [xy[0]]
        row1 = row1 + [xy[1]]
        i = i + 1
    }
    for v in row1 {
        row0 = row0 + [v]
    }
    var res = ""
    var j = 0
    while j < row0.count {
        let key = String(row0[j]) + "," + String(row0[j + 1])
        res = res + dmap[key]!
        j = j + 2
    }
    return res
}
func decrypt(_ text: String, _ emap: [String: [Int]], _ dmap: [String: String]) -> String {
    text = remove_space(text, emap)
    var coords: [Int] = [Any]()
    var i = 0
    while i < text.count {
        let ch = Array(text[i..<i + 1])
        let xy = emap[ch]!
        coords = coords + [xy[0]]
        coords = coords + [xy[1]]
        i = i + 1
    }
    var half = coords.count / 2
    var k1: [Int] = [Any]()
    var k2: [Int] = [Any]()
    var idx = 0
    while idx < half {
        k1 = k1 + [coords[idx]]
        idx = idx + 1
    }
    while idx < coords.count {
        k2 = k2 + [coords[idx]]
        idx = idx + 1
    }
    var res = ""
    var j = 0
    while j < half {
        let key = String(k1[j]) + "," + String(k2[j])
        res = res + dmap[key]!
        j = j + 1
    }
    return res
}
func main() {
    var squareRosetta = [["A", "B", "C", "D", "E"], ["F", "G", "H", "I", "K"], ["L", "M", "N", "O", "P"], ["Q", "R", "S", "T", "U"], ["V", "W", "X", "Y", "Z"], ["J", "1", "2", "3", "4"]]
    var squareWikipedia = [["B", "G", "W", "K", "Z"], ["Q", "P", "N", "D", "S"], ["I", "O", "A", "X", "E"], ["F", "C", "L", "U", "M"], ["T", "H", "Y", "V", "R"], ["J", "1", "2", "3", "4"]]
    let textRosetta = "0ATTACKATDAWN"
    let textWikipedia = "FLEEATONCE"
    let textTest = "The invasion will start on the first of January"
    var maps = square_to_maps(squareRosetta)
    var emap = maps["e"]
    var dmap = maps["d"]
    print("from Rosettacode")
    print("original:\t " + textRosetta)
    var s = encrypt(textRosetta, emap, dmap)
    print("codiert:\t " + s)
    s = decrypt(s, emap, dmap)
    print("and back:\t " + s)
    maps = square_to_maps(squareWikipedia)
    emap = maps["e"]
    dmap = maps["d"]
    print("from Wikipedia")
    print("original:\t " + textWikipedia)
    s = encrypt(textWikipedia, emap, dmap)
    print("codiert:\t " + s)
    s = decrypt(s, emap, dmap)
    print("and back:\t " + s)
    maps = square_to_maps(squareWikipedia)
    emap = maps["e"]
    dmap = maps["d"]
    print("from Rosettacode long part")
    print("original:\t " + textTest)
    s = encrypt(textTest, emap, dmap)
    print("codiert:\t " + s)
    s = decrypt(s, emap, dmap)
    print("and back:\t " + s)
}
main()
