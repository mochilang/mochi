// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:56:34Z
struct Point: Equatable {
    var x: Double
    var y: Double
    var z: Double
}
struct Edge: Equatable {
    var pn1: Int
    var pn2: Int
    var fn1: Int
    var fn2: Int
    var cp: Point
}
struct PointEx: Equatable {
    var p: Point
    var n: Int
}
func indexOf(_ s: String, _ ch: String) -> Int {
    var i = 0
    while i < s.count {
        if String(s[s.index(s.startIndex, offsetBy: i)..<s.index(s.startIndex, offsetBy: i + 1)]) == ch {
            return i
        }
        i = i + 1
    }
    return -1
}
func fmt4(_ x: Double) -> String {
    var y = x * 10000.0
    if y >= 0 {
        y = y + 0.5
    }
    else {
        y = y - 0.5
    }
    y = Double((Int(y))) / 10000.0
    var s = String(y)
    var dot = indexOf(s, ".")
    if dot == 0 - 1 {
        s = s + ".0000"
    }
    else {
        var decs = s.count - dot - 1
        if decs > 4 {
            s = String(s[s.index(s.startIndex, offsetBy: 0)..<s.index(s.startIndex, offsetBy: dot + 5)])
        }
        else {
            while decs < 4 {
                s = s + "0"
                decs = decs + 1
            }
        }
    }
    if x >= 0.0 {
        s = " " + s
    }
    return s
}
func fmt2(_ n: Int) -> String {
    let s = String(n)
    if s.count < 2 {
        return " " + s
    }
    return s
}
func sumPoint(_ p1: inout Point, _ p2: inout Point) -> Point {
    return Point(x: p1.x + p2.x, y: p1.y + p2.y, z: p1.z + p2.z)
}
func mulPoint(_ p: inout Point, _ m: Double) -> Point {
    return Point(x: p.x * m, y: p.y * m, z: p.z * m)
}
func divPoint(_ p: inout Point, _ d: Double) -> Point {
    return mulPoint(&p, 1.0 / d)
}
func centerPoint(_ p1: inout Point, _ p2: inout Point) -> Point {
    return divPoint(&sumPoint(&p1, &p2), 2.0)
}
func getFacePoints(_ points: [Point], _ faces: [[Int]]) -> [Point] {
    var facePoints: [Point] = [Any]()
    var i = 0
    while i < faces.count {
        let face = faces[i]
        var fp = Point(x: 0.0, y: 0.0, z: 0.0)
        for idx in face {
            fp = sumPoint(&fp, &points[idx])
        }
        fp = divPoint(&fp, (Double(face.count)))
        facePoints = facePoints + [fp]
        i = i + 1
    }
    return facePoints
}
func sortEdges(_ edges: [[Int]]) -> [[Int]] {
    var res: [[Int]] = [Any]()
    var tmp = edges
    while tmp.count > 0 {
        var min = tmp[0]
        var idx = 0
        var j = 1
        while j < tmp.count {
            let e = tmp[j]
            if e[0] < min[0] || (e[0] == min[0] && (e[1] < min[1] || (e[1] == min[1] && e[2] < min[2]))) {
                min = e
                idx = j
            }
            j = j + 1
        }
        res = res + [min]
        var out: [[Int]] = [Any]()
        var k = 0
        while k < tmp.count {
            if k != idx {
                out = out + [tmp[k]]
            }
            k = k + 1
        }
        tmp = out
    }
    return res
}
func getEdgesFaces(_ points: [Point], _ faces: [[Int]]) -> [Edge] {
    var edges: [[Int]] = [Any]()
    var fnum = 0
    while fnum < faces.count {
        let face = faces[fnum]
        var numP = face.count
        var pi = 0
        while pi < numP {
            var pn1 = face[pi]
            var pn2 = 0
            if pi < numP - 1 {
                pn2 = face[pi + 1]
            }
            else {
                pn2 = face[0]
            }
            if pn1 > pn2 {
                var tmpn = pn1
                pn1 = pn2
                pn2 = tmpn
            }
            edges = edges + [[pn1, pn2, fnum]]
            pi = pi + 1
        }
        fnum = fnum + 1
    }
    edges = sortEdges(edges)
    var merged: [[Int]] = [Any]()
    var idx = 0
    while idx < edges.count {
        let e1 = edges[idx]
        if idx < edges.count - 1 {
            let e2 = edges[idx + 1]
            if e1[0] == e2[0] && e1[1] == e2[1] {
                merged = merged + [[e1[0], e1[1], e1[2], e2[2]]]
                idx = idx + 2
                continue
            }
        }
        merged = merged + [[e1[0], e1[1], e1[2], -1]]
        idx = idx + 1
    }
    var edgesCenters: [Edge] = [Any]()
    for me in merged {
        let p1 = points[me[0]]
        let p2 = points[me[1]]
        let cp = centerPoint(&p1, &p2)
        edgesCenters = edgesCenters + [Edge(pn1: me[0], pn2: me[1], fn1: me[2], fn2: me[3], cp: cp)]
    }
    return edgesCenters
}
func getEdgePoints(_ points: [Point], _ edgesFaces: [Edge], _ facePoints: [Point]) -> [Point] {
    var edgePoints: [Point] = [Any]()
    var i = 0
    while i < edgesFaces.count {
        let edge = edgesFaces[i]
        let cp = edge.cp
        let fp1 = facePoints[edge.fn1]
        var fp2 = fp1
        if edge.fn2 != 0 - 1 {
            fp2 = facePoints[edge.fn2]
        }
        let cfp = centerPoint(&fp1, &fp2)
        edgePoints = edgePoints + [centerPoint(&cp, &cfp)]
        i = i + 1
    }
    return edgePoints
}
func getAvgFacePoints(_ points: [Point], _ faces: [[Int]], _ facePoints: [Point]) -> [Point] {
    var numP = points.count
    var temp: [PointEx] = [Any]()
    var i = 0
    while i < numP {
        temp = temp + [PointEx(p: Point(x: 0.0, y: 0.0, z: 0.0), n: 0)]
        i = i + 1
    }
    var fnum = 0
    while fnum < faces.count {
        let fp = facePoints[fnum]
        for pn in faces[fnum] {
            let tp = temp[pn]
            temp[pn] = PointEx(p: sumPoint(&tp.p, &fp), n: tp.n + 1)
        }
        fnum = fnum + 1
    }
    var avg: [Point] = [Any]()
    var j = 0
    while j < numP {
        let tp = temp[j]
        avg = avg + [divPoint(&tp.p, Double(tp.n))]
        j = j + 1
    }
    return avg
}
func getAvgMidEdges(_ points: [Point], _ edgesFaces: [Edge]) -> [Point] {
    var numP = points.count
    var temp: [PointEx] = [Any]()
    var i = 0
    while i < numP {
        temp = temp + [PointEx(p: Point(x: 0.0, y: 0.0, z: 0.0), n: 0)]
        i = i + 1
    }
    for edge in edgesFaces {
        let cp = edge.cp
        var arr = [edge.pn1, edge.pn2]
        for pn in arr {
            let tp = temp[pn]
            temp[pn] = PointEx(p: sumPoint(&tp.p, &cp), n: tp.n + 1)
        }
    }
    var avg: [Point] = [Any]()
    var j = 0
    while j < numP {
        let tp = temp[j]
        avg = avg + [divPoint(&tp.p, Double(tp.n))]
        j = j + 1
    }
    return avg
}
func getPointsFaces(_ points: [Point], _ faces: [[Int]]) -> [Int] {
    var pf: [Int] = [Any]()
    var i = 0
    while i < points.count {
        pf = pf + [0]
        i = i + 1
    }
    var fnum = 0
    while fnum < faces.count {
        for pn in faces[fnum] {
            pf[pn] = pf[pn] + 1
        }
        fnum = fnum + 1
    }
    return pf
}
func getNewPoints(_ points: [Point], _ pf: [Int], _ afp: [Point], _ ame: [Point]) -> [Point] {
    var newPts: [Point] = [Any]()
    var i = 0
    while i < points.count {
        var n = Double(pf[i])
        var m1 = (n - 3.0) / n
        var m2 = 1.0 / n
        var m3 = 2.0 / n
        let old = points[i]
        let p1 = mulPoint(&old, m1)
        let p2 = mulPoint(&afp[i], m2)
        let p3 = mulPoint(&ame[i], m3)
        newPts = newPts + [sumPoint(&sumPoint(&p1, &p2), &p3)]
        i = i + 1
    }
    return newPts
}
func key(_ a: Int, _ b: Int) -> String {
    if a < b {
        return String(a) + "," + String(b)
    }
    return String(b) + "," + String(a)
}
func cmcSubdiv(_ points: [Point], _ faces: [[Int]]) -> [any] {
    let facePoints = getFacePoints(points, faces)
    let edgesFaces = getEdgesFaces(points, faces)
    let edgePoints = getEdgePoints(points, edgesFaces, facePoints)
    let avgFacePoints = getAvgFacePoints(points, faces, facePoints)
    let avgMidEdges = getAvgMidEdges(points, edgesFaces)
    let pointsFaces = getPointsFaces(points, faces)
    var newPoints = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges)
    var facePointNums: [Int] = [Any]()
    var nextPoint = newPoints.count
    for fp in facePoints {
        newPoints = newPoints + [fp]
        facePointNums = facePointNums + [nextPoint]
        nextPoint = nextPoint + 1
    }
    var edgePointNums: [String: Int] = []
    var idx = 0
    while idx < edgesFaces.count {
        let e = edgesFaces[idx]
        newPoints = newPoints + [edgePoints[idx]]
        edgePointNums[key(e.pn1, e.pn2)] = nextPoint
        nextPoint = nextPoint + 1
        idx = idx + 1
    }
    var newFaces: [[Int]] = [Any]()
    var fnum = 0
    while fnum < faces.count {
        let oldFace = faces[fnum]
        if oldFace.count == 4 {
            let a = oldFace[0]
            let b = oldFace[1]
            let c = oldFace[2]
            let d = oldFace[3]
            let fpnum = facePointNums[fnum]
            let ab = edgePointNums[key(a, b)]!
            let da = edgePointNums[key(d, a)]!
            let bc = edgePointNums[key(b, c)]!
            let cd = edgePointNums[key(c, d)]!
            newFaces = newFaces + [[a, ab, fpnum, da]]
            newFaces = newFaces + [[b, bc, fpnum, ab]]
            newFaces = newFaces + [[c, cd, fpnum, bc]]
            newFaces = newFaces + [[d, da, fpnum, cd]]
        }
        fnum = fnum + 1
    }
    return [newPoints, newFaces]
}
func formatPoint(_ p: inout Point) -> String {
    return "[" + fmt4(p.x) + " " + fmt4(p.y) + " " + fmt4(p.z) + "]"
}
func formatFace(_ f: [Int]) -> String {
    if f.count == 0 {
        return "[]"
    }
    var s = "[" + fmt2(f[0])
    var i = 1
    while i < f.count {
        s = s + " " + fmt2(f[i])
        i = i + 1
    }
    s = s + "]"
    return s
}
func main() {
    var inputPoints = [Point(x: -1.0, y: 1.0, z: 1.0), Point(x: -1.0, y: -1.0, z: 1.0), Point(x: 1.0, y: -1.0, z: 1.0), Point(x: 1.0, y: 1.0, z: 1.0), Point(x: 1.0, y: -1.0, z: -1.0), Point(x: 1.0, y: 1.0, z: -1.0), Point(x: -1.0, y: -1.0, z: -1.0), Point(x: -1.0, y: 1.0, z: -1.0)]
    var inputFaces = [[0, 1, 2, 3], [3, 2, 4, 5], [5, 4, 6, 7], [7, 0, 3, 5], [7, 6, 1, 0], [6, 1, 2, 4]]
    var outputPoints = inputPoints
    var outputFaces = inputFaces
    var i = 0
    while i < 1 {
        let res = cmcSubdiv(outputPoints, outputFaces)
        outputPoints = res[0]
        outputFaces = res[1]
        i = i + 1
    }
    for p in outputPoints {
        print(formatPoint(&p))
    }
    print("")
    for f in outputFaces {
        print(formatFace(f))
    }
}
main()
