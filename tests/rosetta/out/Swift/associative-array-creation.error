run error: exit status 1
/tmp/TestMochiToSwiftassociative-array-creation3213559330/001/main.swift:3:30: error: use [:] to get an empty dictionary literal
 1 | // Generated by Mochi compiler v0.10.26 on 2025-07-16T09:55:07Z
 2 | func removeKey(_ m: [String: Int], _ k: String) -> [String: Int] {
 3 |     var out: [String: Int] = []
   |                              `- error: use [:] to get an empty dictionary literal
 4 |     for key in m {
 5 |         if key != k {

/tmp/TestMochiToSwiftassociative-array-creation3213559330/001/main.swift:5:16: error: binary operator '!=' cannot be applied to operands of type '(key: String, value: Int)' and 'String'
 3 |     var out: [String: Int] = []
 4 |     for key in m {
 5 |         if key != k {
   |                `- error: binary operator '!=' cannot be applied to operands of type '(key: String, value: Int)' and 'String'
 6 |             out[key] = m[key]
 7 |         }

Swift.StringProtocol:1:11: note: candidate requires that '(key: String, value: Int)' conform to 'StringProtocol' (requirement specified as 'Self' : 'StringProtocol')
1 | extension StringProtocol {
  |           `- note: candidate requires that '(key: String, value: Int)' conform to 'StringProtocol' (requirement specified as 'Self' : 'StringProtocol')
2 |     @inlinable public static func == <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol
3 |     @inlinable public static func != <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : StringProtocol

/tmp/TestMochiToSwiftassociative-array-creation3213559330/001/main.swift:6:16: error: no exact matches in call to subscript 
 4 |     for key in m {
 5 |         if key != k {
 6 |             out[key] = m[key]
   |                |- error: no exact matches in call to subscript 
   |                `- note: found candidate with type '((key: String, value: Int)) -> Dictionary<String, Int>.SubSequence' (aka '((key: String, value: Int)) -> Slice<Dictionary<String, Int>>')
 7 |         }
 8 |     }

Swift.Dictionary.subscript:2:19: note: candidate expects value of type 'String' for parameter #1 (got '(key: String, value: Int)')
1 | generic struct Dictionary {
2 | @inlinable public subscript(key: Key) -> Value? { get set }}
  |                   `- note: candidate expects value of type 'String' for parameter #1 (got '(key: String, value: Int)')
3 | 

/tmp/TestMochiToSwiftassociative-array-creation3213559330/001/main.swift:6:25: error: no exact matches in call to subscript 
 4 |     for key in m {
 5 |         if key != k {
 6 |             out[key] = m[key]
   |                         `- error: no exact matches in call to subscript 
 7 |         }
 8 |     }

Swift.Dictionary.subscript:2:19: note: candidate expects value of type 'String' for parameter #1 (got '(key: String, value: Int)')
1 | generic struct Dictionary {
2 | @inlinable public subscript(key: Key) -> Value? { get set }}
  |                   `- note: candidate expects value of type 'String' for parameter #1 (got '(key: String, value: Int)')
3 | 

Swift.Collection.subscript:2:19: note: candidate requires that '(key: String, value: Int)' conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')
1 | protocol Collection {
2 | @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }}
  |                   `- note: candidate requires that '(key: String, value: Int)' conform to 'RangeExpression' (requirement specified as 'R' : 'RangeExpression')
3 | 

/tmp/TestMochiToSwiftassociative-array-creation3213559330/001/main.swift:12:28: error: 'nil' cannot initialize specified type '[String : Int]'
10 | }
11 | func main() {
12 |     var x: [String: Int] = nil
   |            |               `- error: 'nil' cannot initialize specified type '[String : Int]'
   |            `- note: add '?' to form the optional type '[String : Int]?'
13 |     x = []
14 |     x["foo"] = 3

/tmp/TestMochiToSwiftassociative-array-creation3213559330/001/main.swift:13:9: error: use [:] to get an empty dictionary literal
11 | func main() {
12 |     var x: [String: Int] = nil
13 |     x = []
   |         `- error: use [:] to get an empty dictionary literal
14 |     x["foo"] = 3
15 |     let y1 = x["bar"]!

/tmp/TestMochiToSwiftassociative-array-creation3213559330/001/main.swift:21:21: warning: forced cast from 'Int?' to 'Int' only unwraps optionals; did you mean to use '!'?
19 |     x = removeKey(x, "foo")
20 |     x = ["foo": 2, "bar": 42, "baz": -1]
21 |     print((x["foo"] as! Int), (x["bar"] as! Int), (x["baz"] as! Int))
   |                     `- warning: forced cast from 'Int?' to 'Int' only unwraps optionals; did you mean to use '!'?
22 | }
23 | main()

/tmp/TestMochiToSwiftassociative-array-creation3213559330/001/main.swift:21:41: warning: forced cast from 'Int?' to 'Int' only unwraps optionals; did you mean to use '!'?
19 |     x = removeKey(x, "foo")
20 |     x = ["foo": 2, "bar": 42, "baz": -1]
21 |     print((x["foo"] as! Int), (x["bar"] as! Int), (x["baz"] as! Int))
   |                                         `- warning: forced cast from 'Int?' to 'Int' only unwraps optionals; did you mean to use '!'?
22 | }
23 | main()

/tmp/TestMochiToSwiftassociative-array-creation3213559330/001/main.swift:21:61: warning: forced cast from 'Int?' to 'Int' only unwraps optionals; did you mean to use '!'?
19 |     x = removeKey(x, "foo")
20 |     x = ["foo": 2, "bar": 42, "baz": -1]
21 |     print((x["foo"] as! Int), (x["bar"] as! Int), (x["baz"] as! Int))
   |                                                             `- warning: forced cast from 'Int?' to 'Int' only unwraps optionals; did you mean to use '!'?
22 | }
23 | main()
