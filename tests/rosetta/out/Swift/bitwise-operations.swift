// Generated by Mochi compiler v0.10.26 on 2025-07-16T09:55:37Z
func toUnsigned16(_ n: Int) -> Int {
    var u = n
    if u < 0 {
        u = u + 65536
    }
    return u % 65536
}
func bin16(_ n: Int) -> String {
    var u = toUnsigned16(n)
    var bits = ""
    var mask = 32768
    for i in 0..<16 {
        if u >= mask {
            bits = bits + "1"
            u = u - mask
        }
        else {
            bits = bits + "0"
        }
        mask = Int((mask / 2))
    }
    return bits
}
func bit_and(_ a: Int, _ b: Int) -> Int {
    var ua = toUnsigned16(a)
    var ub = toUnsigned16(b)
    var res = 0
    var bit = 1
    for i in 0..<16 {
        if ua % 2 == 1 && ub % 2 == 1 {
            res = res + bit
        }
        ua = Int((ua / 2))
        ub = Int((ub / 2))
        bit = bit * 2
    }
    return res
}
func bit_or(_ a: Int, _ b: Int) -> Int {
    var ua = toUnsigned16(a)
    var ub = toUnsigned16(b)
    var res = 0
    var bit = 1
    for i in 0..<16 {
        if ua % 2 == 1 || ub % 2 == 1 {
            res = res + bit
        }
        ua = Int((ua / 2))
        ub = Int((ub / 2))
        bit = bit * 2
    }
    return res
}
func bit_xor(_ a: Int, _ b: Int) -> Int {
    var ua = toUnsigned16(a)
    var ub = toUnsigned16(b)
    var res = 0
    var bit = 1
    for i in 0..<16 {
        let abit = ua % 2
        let bbit = ub % 2
        if (abit == 1 && bbit == 0) || (abit == 0 && bbit == 1) {
            res = res + bit
        }
        ua = Int((ua / 2))
        ub = Int((ub / 2))
        bit = bit * 2
    }
    return res
}
func bit_not(_ a: Int) -> Int {
    var ua = toUnsigned16(a)
    return 65535 - ua
}
func shl(_ a: Int, _ b: Int) -> Int {
    var ua = toUnsigned16(a)
    var i = 0
    while i < b {
        ua = (ua * 2) % 65536
        i = i + 1
    }
    return ua
}
func shr(_ a: Int, _ b: Int) -> Int {
    var ua = toUnsigned16(a)
    var i = 0
    while i < b {
        ua = Int((ua / 2))
        i = i + 1
    }
    return ua
}
func las(_ a: Int, _ b: Int) -> Int {
    return shl(a, b)
}
func ras(_ a: Int, _ b: Int) -> Int {
    var val = a
    var i = 0
    while i < b {
        if val >= 0 {
            val = Int((val / 2))
        }
        else {
            val = Int(((val - 1) / 2))
        }
        i = i + 1
    }
    return toUnsigned16(val)
}
func rol(_ a: Int, _ b: Int) -> Int {
    var ua = toUnsigned16(a)
    let left = shl(ua, b)
    let right = shr(ua, 16 - b)
    return toUnsigned16(left + right)
}
func ror(_ a: Int, _ b: Int) -> Int {
    var ua = toUnsigned16(a)
    let right = shr(ua, b)
    let left = shl(ua, 16 - b)
    return toUnsigned16(left + right)
}
func bitwise(_ a: Int, _ b: Int) {
    print("a:   " + bin16(a))
    print("b:   " + bin16(b))
    print("and: " + bin16(bit_and(a, b)))
    print("or:  " + bin16(bit_or(a, b)))
    print("xor: " + bin16(bit_xor(a, b)))
    print("not: " + bin16(bit_not(a)))
    if b < 0 {
        print("Right operand is negative, but all shifts require an unsigned right operand (shift distance).")
        return nil
    }
    print("shl: " + bin16(shl(a, b)))
    print("shr: " + bin16(shr(a, b)))
    print("las: " + bin16(las(a, b)))
    print("ras: " + bin16(ras(a, b)))
    print("rol: " + bin16(rol(a, b)))
    print("ror: " + bin16(ror(a, b)))
}
bitwise(-460, 6)
