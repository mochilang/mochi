// Generated by Mochi v0.10.40 on 2025-07-25 20:35:55 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.annotation.tailrec
object Main {
  class BigRat(var num: BigInt, var den: BigInt) {
    def +(o: BigRat) = BigRat(num * o.den + o.num * den, den * o.den)
    def -(o: BigRat) = BigRat(num * o.den - o.num * den, den * o.den)
    def *(o: BigRat) = BigRat(num * o.num, den * o.den)
    def /(o: BigRat) = BigRat(num * o.den, den * o.num)
  }
  object BigRat {
    def apply(n: BigInt, d: BigInt = BigInt(1)): BigRat = {
      val g = n.gcd(d); var nn = n / g; var dd = d / g; if (dd < 0) { nn = -nn; dd = -dd }
      new BigRat(nn, dd)
    }
  }
  def _bigrat(n: BigInt, d: BigInt = BigInt(1)) = BigRat(n, d)
  def num(r: BigRat): BigInt = r.num
  def denom(r: BigRat): BigInt = r.den
  
  private def _padStart(s: String, width: Int, pad: String): String = {
    var out = s
    while (out.length < width) { out = pad + out }
    out
  }
  
  def bernoulli(n: Int): BigRat = {
    var a: ArrayBuffer[BigRat] = ArrayBuffer()
    var m: Int = 0
    while (m <= n) {
      a = a :+ _bigrat(1) / _bigrat(m + 1)
      var j: Int = m
      while (j >= 1) {
        a(j - 1) = (_bigrat(j) * (a(j - 1) - a(j))).asInstanceOf[BigRat]
        j = (j - 1).asInstanceOf[Int]
      }
      m = (m + 1).asInstanceOf[Int]
    }
    return a(0)
  }
  
  def padStart(s: String, width: Int, pad: String): String = {
    var out: String = s
    while ((out).size < width) {
      out = (pad + out).toString
    }
    return out
  }
  
  def main(args: Array[String]): Unit = {
    for (i <- 0 until 61) {
      val b: BigRat = bernoulli(i.asInstanceOf[Int])
      if (num(b) != 0) {
        val numStr = String.valueOf(num(b))
        val denStr = String.valueOf(denom(b))
        println("B(" + _padStart(String.valueOf(i), 2, " ") + ") =" + _padStart(numStr, 45, " ") + "/" + denStr)
      }
    }
  }
}
