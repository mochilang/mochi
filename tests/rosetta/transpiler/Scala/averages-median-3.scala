// Generated by Mochi v0.10.39 on 2025-07-25 01:20:38 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs(System.nanoTime().toInt)
  }
}

def qsel(a: ArrayBuffer[Double], _k: Int): Double = {
  var k: Int = _k
  var arr: ArrayBuffer[Double] = a
  while ((arr).size > 1) {
    var px = Math.floorMod(_now(), (arr).size)
    var pv: Double = arr(px)
    val last: Int = (arr).size - 1
    val tmp: Double = arr(px)
    arr(px) = arr(last)
    arr(last) = tmp
    px = 0
    var i: Int = 0
    while (i < last) {
      val v: Double = arr(i)
      if (v < pv) {
        val tmp2: Double = arr(px)
        arr(px) = arr(i)
        arr(i) = tmp2
        px = (px + 1).asInstanceOf[Int]
      }
      i = (i + 1).asInstanceOf[Int]
    }
    if (px == k) {
      return pv
    }
    if (k < px) {
      arr = (arr.slice(0, px)).asInstanceOf[ArrayBuffer[Double]]
    } else {
      val tmp2: Double = arr(px)
      arr(px) = pv
      arr(last) = tmp2
      arr = (arr.slice(px + 1, (arr).size)).asInstanceOf[ArrayBuffer[Double]]
      k = (k - px + 1).asInstanceOf[Int]
    }
  }
  return arr(0)
}

def median(list: ArrayBuffer[Double]): Double = {
  var arr: ArrayBuffer[Double] = list
  val half: Int = ((arr).size / 2).asInstanceOf[Int]
  val med: Double = qsel(arr, half)
  if (Math.floorMod((arr).size, 2) == 0) {
    return (med + qsel(arr, (half - 1).asInstanceOf[Int])) / 2.0
  }
  return med
}

def main(args: Array[String]): Unit = {
  println(String.valueOf(median(ArrayBuffer(3.0, 1.0, 4.0, 1.0))))
  println(String.valueOf(median(ArrayBuffer(3.0, 1.0, 4.0, 1.0, 5.0))))
}
}
