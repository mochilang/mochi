// Generated by Mochi v0.10.40 on 2025-07-26 04:42:15 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  case class Writer(var order: String, var bits: Int, var nbits: Int, var data: ArrayBuffer[Int])
  
  case class Reader(var order: String, var data: ArrayBuffer[Int], var idx: Int, var bits: Int, var nbits: Int)
  
  def pow2(n: Int): Int = {
    var v: Int = 1
    var i: Int = 0
    while (i < n) {
      v = (v * 2).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    return v
  }
  
  def lshift(x: Int, n: Int): Int = {
    return (x * pow2(n)).asInstanceOf[Int]
  }
  
  def rshift(x: Int, n: Int): Int = {
    return (x / pow2(n)).asInstanceOf[Int]
  }
  
  def NewWriter(order: String): Writer = {
    return Writer(order, 0, 0, ArrayBuffer())
  }
  
  def writeBitsLSB(w: Writer, c: Int, width: Int): Writer = {
    w.bits = (w.bits + lshift(c, w.nbits)).asInstanceOf[Int]
    w.nbits = (w.nbits + width).asInstanceOf[Int]
    while (w.nbits >= 8) {
      val b = Math.floorMod(w.bits, 256)
      w.data = w.data :+ b
      w.bits = rshift(w.bits, 8)
      w.nbits = (w.nbits - 8).asInstanceOf[Int]
    }
    return w
  }
  
  def writeBitsMSB(w: Writer, c: Int, width: Int): Writer = {
    w.bits = (w.bits + lshift(c, (32 - width - w.nbits).asInstanceOf[Int])).asInstanceOf[Int]
    w.nbits = (w.nbits + width).asInstanceOf[Int]
    while (w.nbits >= 8) {
      val b = Math.floorMod(rshift(w.bits, 24), 256)
      w.data = w.data :+ b
      w.bits = (Math.floorMod(w.bits, pow2(24)) * 256).asInstanceOf[Int]
      w.nbits = (w.nbits - 8).asInstanceOf[Int]
    }
    return w
  }
  
  def WriteBits(w: Writer, c: Int, width: Int): Writer = {
    if (w.order == "LSB") {
      return writeBitsLSB(w, c, width)
    }
    return writeBitsMSB(w, c, width)
  }
  
  def CloseWriter(w: Writer): Writer = {
    if (w.nbits > 0) {
      if (w.order == "MSB") {
        w.bits = rshift(w.bits, 24)
      }
      w.data = w.data :+ Math.floorMod(w.bits, 256)
    }
    w.bits = 0
    w.nbits = 0
    return w
  }
  
  def NewReader(data: ArrayBuffer[Int], order: String): Reader = {
    return Reader(order, data, 0, 0, 0)
  }
  
  def readBitsLSB(r: Reader, width: Int): Map[String,Any] = {
    while (r.nbits < width) {
      if (r.idx >= (r.data).size) {
        return Map("val" -> (0), "eof" -> (true))
      }
      val b: Int = r.data(r.idx)
      r.idx = (r.idx + 1).asInstanceOf[Int]
      r.bits = (r.bits + lshift(b, r.nbits)).asInstanceOf[Int]
      r.nbits = (r.nbits + 8).asInstanceOf[Int]
    }
    val mask = pow2(width) - 1
    val out = Math.floorMod(r.bits, mask + 1)
    r.bits = rshift(r.bits, width)
    r.nbits = (r.nbits - width).asInstanceOf[Int]
    return Map("val" -> (out), "eof" -> (false))
  }
  
  def readBitsMSB(r: Reader, width: Int): Map[String,Any] = {
    while (r.nbits < width) {
      if (r.idx >= (r.data).size) {
        return Map("val" -> (0), "eof" -> (true))
      }
      val b: Int = r.data(r.idx)
      r.idx = (r.idx + 1).asInstanceOf[Int]
      r.bits = (r.bits + lshift(b, (24 - r.nbits).asInstanceOf[Int])).asInstanceOf[Int]
      r.nbits = (r.nbits + 8).asInstanceOf[Int]
    }
    val out: Int = rshift(r.bits, (32 - width).asInstanceOf[Int])
    r.bits = (Math.floorMod(r.bits * pow2(width), pow2(32))).asInstanceOf[Int]
    r.nbits = (r.nbits - width).asInstanceOf[Int]
    return Map("val" -> (out), "eof" -> (false))
  }
  
  def ReadBits(r: Reader, width: Int): Map[String,Any] = {
    if (r.order == "LSB") {
      return readBitsLSB(r, width)
    }
    return readBitsMSB(r, width)
  }
  
  def toBinary(n: Int, bits: Int): String = {
    var b: String = ""
    var `val`: Int = n
    var i: Int = 0
    while (i < bits) {
      b = (String.valueOf(Math.floorMod(`val`, 2)) + b).toString
      `val` = (`val` / 2).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    return b
  }
  
  def bytesToBits(bs: ArrayBuffer[Int]): String = {
    var out: String = "["
    var i: Int = 0
    while (i < (bs).size) {
      out = (out + toBinary(bs(i), 8)).toString
      if ((i + 1).asInstanceOf[Int] < (bs).size) {
        out = out + " "
      }
      i = (i + 1).asInstanceOf[Int]
    }
    out = out + "]"
    return out
  }
  
  def bytesToHex(bs: ArrayBuffer[Int]): String = {
    val digits: String = "0123456789ABCDEF"
    var out: String = ""
    var i: Int = 0
    while (i < (bs).size) {
      val b: Int = bs(i)
      val hi = b / 16
      val lo = Math.floorMod(b, 16)
      out = out + digits.slice(hi, hi + 1) + digits.slice(lo, lo + 1)
      if ((i + 1).asInstanceOf[Int] < (bs).size) {
        out = out + " "
      }
      i = (i + 1).asInstanceOf[Int]
    }
    return out
  }
  
  def ord(ch: String): Int = {
    val upper: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    val lower: String = "abcdefghijklmnopqrstuvwxyz"
    var idx: Int = indexOf(upper, ch)
    if (idx >= 0) {
      return (65 + idx).asInstanceOf[Int]
    }
    idx = indexOf(lower, ch)
    if (idx >= 0) {
      return (97 + idx).asInstanceOf[Int]
    }
    if ((ch >= "0" && ch <= "9").asInstanceOf[Boolean]) {
      return (48 + parseIntStr(ch)).asInstanceOf[Int]
    }
    if (ch == " ") {
      return 32
    }
    if (ch == ".") {
      return 46
    }
    return 0
  }
  
  def chr(n: Int): String = {
    val upper: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    val lower: String = "abcdefghijklmnopqrstuvwxyz"
    if ((n >= 65 && n < 91).asInstanceOf[Boolean]) {
      return upper.slice(n - 65, n - 64)
    }
    if ((n >= 97 && n < 123).asInstanceOf[Boolean]) {
      return lower.slice(n - 97, n - 96)
    }
    if ((n >= 48 && n < 58).asInstanceOf[Boolean]) {
      val digits: String = "0123456789"
      return digits.slice(n - 48, n - 47)
    }
    if (n == 32) {
      return " "
    }
    if (n == 46) {
      return "."
    }
    return "?"
  }
  
  def bytesOfStr(s: String): ArrayBuffer[Int] = {
    var bs: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = 0
    while (i < (s).size) {
      bs = bs :+ ord(s.slice(i, i + 1))
      i = (i + 1).asInstanceOf[Int]
    }
    return bs
  }
  
  def bytesToDec(bs: ArrayBuffer[Int]): String = {
    var out: String = ""
    var i: Int = 0
    while (i < (bs).size) {
      out = (out + String.valueOf(bs(i))).toString
      if ((i + 1).asInstanceOf[Int] < (bs).size) {
        out = out + " "
      }
      i = (i + 1).asInstanceOf[Int]
    }
    return out
  }
  
  def Example(): Any = {
    val message: String = "This is a test."
    val msgBytes: ArrayBuffer[Int] = bytesOfStr(message)
    println("\"" + message + "\" as bytes: " + bytesToDec(msgBytes))
    println("    original bits: " + bytesToBits(msgBytes))
    var bw: Writer = NewWriter("MSB")
    var i: Int = 0
    while (i < (msgBytes).size) {
      bw = WriteBits(bw, msgBytes(i), 7)
      i = (i + 1).asInstanceOf[Int]
    }
    bw = CloseWriter(bw)
    println("Written bitstream: " + bytesToBits(bw.data))
    println("Written bytes: " + bytesToHex(bw.data))
    var br: Reader = NewReader(bw.data, "MSB")
    var result: String = ""
    val _br11 = new Breaks
    _br11.breakable {
      while (true) {
        val r: Map[String,Any] = ReadBits(br, 7)
        if ((r.getOrElse("eof", null.asInstanceOf[Any])).asInstanceOf[Boolean]) {
          _br11.break()
        }
        val v: Int = (r.getOrElse("val", null.asInstanceOf[Any])).asInstanceOf[Int]
        if (v != 0) {
          result = (result + chr(v)).toString
        }
      }
    }
    println("Read back as \"" + result + "\"")
  }
  
  def main(args: Array[String]): Unit = {
    Example()
  }
}
