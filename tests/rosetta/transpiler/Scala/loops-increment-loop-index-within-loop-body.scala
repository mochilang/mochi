// Generated by Mochi v0.10.50 on 2025-07-31 07:52:05 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
object Main {
  def isPrime(n: BigInt): Boolean = {
    if (n < BigInt(2)) {
      return false
    }
    if (n % BigInt(2) == BigInt(0)) {
      return n == BigInt(2)
    }
    if (n % BigInt(3) == BigInt(0)) {
      return n == BigInt(3)
    }
    var d: BigInt = BigInt(5)
    while (d * d <= n) {
      if (n % d == BigInt(0)) {
        return false
      }
      d = d + BigInt(2)
      if (n % d == BigInt(0)) {
        return false
      }
      d = d + BigInt(4)
    }
    return true
  }
  
  def commatize(n: BigInt): String = {
    var s: String = String.valueOf(n)
    var i: BigInt = (s).size - BigInt(3)
    while (i >= BigInt(1)) {
      s = s.slice((BigInt(0)).toInt, (i).toInt) + "," + s.slice((i).toInt, ((s).size).toInt)
      i = i - BigInt(3)
    }
    return s
  }
  
  def padLeft(s: String, w: BigInt): String = {
    var out: String = s
    while ((out).size < w) {
      out = " " + out
    }
    return out
  }
  
  def padRight(s: String, w: BigInt): String = {
    var out: String = s
    while ((out).size < w) {
      out = out + " "
    }
    return out
  }
  
  def main(): Any = {
    var i: BigInt = limit
    var n: BigInt = BigInt(0)
    while (n < limit) {
      if (isPrime(i)) {
        n = n + BigInt(1)
        val nStr: String = padRight(String.valueOf(n), BigInt(2))
        val pStr: String = padLeft(commatize(i), BigInt(19))
        println("n = " + nStr + "  " + pStr)
        i = i + i - BigInt(1)
      }
      i = i + BigInt(1)
    }
  }
  
  val limit: BigInt = BigInt(42)
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
