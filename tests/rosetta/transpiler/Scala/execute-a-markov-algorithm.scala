// Generated by Mochi v0.10.56 on 2025-08-03 16:00:24 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  def split(s: String, sep: String): ArrayBuffer[String] = {
    var parts: ArrayBuffer[String] = ArrayBuffer()
    var cur: String = ""
    var i: BigInt = BigInt(0)
    while (i < BigInt(((s).size).toInt)) {
      if (((BigInt(((sep).size).toInt) > BigInt(0) && i + (sep).size <= BigInt(((s).size).toInt)).asInstanceOf[Boolean] && s.slice((i).toInt, (i + (sep).size).toInt) == sep).asInstanceOf[Boolean]) {
        parts = parts :+ cur
        cur = ""
        i = i + (sep).size
      } else {
        cur = cur + s.slice((i).toInt, (i + BigInt(1)).toInt)
        i = i + BigInt(1)
      }
    }
    parts = parts :+ cur
    return parts
  }
  
  def trimSpace(s: String): String = {
    var start: BigInt = BigInt(0)
    while (start < BigInt(((s).size).toInt) && (s.slice((start).toInt, (start + BigInt(1)).toInt) == " " || s.slice((start).toInt, (start + BigInt(1)).toInt) == "\t").asInstanceOf[Boolean]) {
      start = start + BigInt(1)
    }
    var end: Int = (s).size
    while (BigInt(end.toString.toDouble.toInt) > start && (s.slice((end - BigInt(1).toInt).toInt, (end).toInt) == " " || s.slice((end - BigInt(1).toInt).toInt, (end).toInt) == "\t").asInstanceOf[Boolean]) {
      end = end - BigInt(1).toInt.toInt
    }
    return s.slice((start).toInt, (end).toInt)
  }
  
  def indexOfSub(s: String, sub: String): BigInt = {
    if ((sub).size == BigInt(0)) {
      return BigInt(0)
    }
    var i: BigInt = BigInt(0)
    while (i + (sub).size <= BigInt(((s).size).toInt)) {
      if (s.slice((i).toInt, (i + (sub).size).toInt) == sub) {
        return i
      }
      i = i + BigInt(1)
    }
    return BigInt(0) - BigInt(1)
  }
  
  def parseRules(rs: String): scala.collection.mutable.Map[String,Any] = {
    var rules: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = ArrayBuffer()
    val _br4 = new Breaks
    val _ct4 = new Breaks
    _br4.breakable {
      for (line <- ArrayBuffer(rs.split("\n"): _*)) {
        _ct4.breakable {
          var ln: String = line
          val hash: BigInt = indexOfSub(ln, "#")
          if (hash >= BigInt(0)) {
            ln = ln.slice((BigInt(0)).toInt, (hash).toInt)
          }
          ln = trimSpace(ln)
          if ((ln).size == BigInt(0)) {
            _ct4.break()
          }
          var arrow: BigInt = BigInt(0) - BigInt(1)
          var j: BigInt = BigInt(0)
          val _br5 = new Breaks
          _br5.breakable {
            while (j + BigInt(2) <= BigInt(((ln).size).toInt)) {
              if (ln.slice((j).toInt, (j + BigInt(2)).toInt) == "->") {
                var pre: Boolean = j > BigInt(0) && (ln.slice((j - BigInt(1)).toInt, (j).toInt) == " " || ln.slice((j - BigInt(1)).toInt, (j).toInt) == "\t").asInstanceOf[Boolean]
                var post: Boolean = j + BigInt(2) < BigInt(((ln).size).toInt) && (ln.slice((j + BigInt(2)).toInt, (j + BigInt(3)).toInt) == " " || ln.slice((j + BigInt(2)).toInt, (j + BigInt(3)).toInt) == "\t").asInstanceOf[Boolean]
                if ((pre && post).asInstanceOf[Boolean]) {
                  arrow = j
                  _br5.break()
                }
              }
              j = j + BigInt(1)
            }
          }
          if (arrow < BigInt(0)) {
            arrow = indexOfSub(ln, "->")
          }
          if (arrow < BigInt(0)) {
            return (scala.collection.mutable.Map("ok" -> (false))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
          }
          var pat: String = trimSpace(ln.slice((BigInt(0)).toInt, (arrow).toInt))
          var rest: String = trimSpace(ln.slice((arrow + BigInt(2)).toInt, ((ln).size).toInt))
          var term: Boolean = false
          if ((BigInt(((rest).size).toInt) > BigInt(0) && rest.slice((BigInt(0)).toInt, (BigInt(1)).toInt) == ".").asInstanceOf[Boolean]) {
            term = true
            rest = rest.slice((BigInt(1)).toInt, ((rest).size).toInt)
          }
          var rep: String = rest
          rules = rules :+ (scala.collection.mutable.Map("pat" -> (pat), "rep" -> (rep), "term" -> (term))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
        }
      }
    }
    return (scala.collection.mutable.Map("ok" -> (true), "rules" -> (rules))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
  }
  
  def runRules(rules: ArrayBuffer[scala.collection.mutable.Map[String,Any]], _s: String): String = {
    var s: String = _s
    var changed: Boolean = true
    val _br6 = new Breaks
    _br6.breakable {
      while (changed) {
        changed = false
        var i: BigInt = BigInt(0)
        val _br7 = new Breaks
        _br7.breakable {
          while (i < BigInt(((rules).size).toInt)) {
            val r: scala.collection.mutable.Map[String,Any] = rules((i.toInt).toInt).asInstanceOf[scala.collection.mutable.Map[String,Any]]
            val pat: Any = r.getOrElse("pat", "").asInstanceOf[String].asInstanceOf[String]
            val rep: Any = r.getOrElse("rep", "").asInstanceOf[String].asInstanceOf[String]
            val term: Any = r.getOrElse("term", false).asInstanceOf[Boolean].asInstanceOf[Boolean]
            val idx: BigInt = indexOfSub(s, pat.toString)
            if (idx >= BigInt(0)) {
              s = s.slice((BigInt(0)).toInt, (idx).toInt) + rep + s.slice((idx + (pat.asInstanceOf[ArrayBuffer[Any]]).size).toInt, ((s).size).toInt)
              changed = true
              if (term.asInstanceOf[Boolean]) {
                return s
              }
              _br7.break()
            }
            i = i + BigInt(1)
          }
        }
      }
    }
    return s
  }
  
  def interpret(ruleset: String, input: String): scala.collection.mutable.Map[String,Any] = {
    val p: scala.collection.mutable.Map[String,Any] = parseRules(ruleset)
    if ((!(p.getOrElse("ok", null)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
      return (scala.collection.mutable.Map("ok" -> (false), "out" -> (""))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
    }
    val out: String = runRules((p.getOrElse("rules", null)).asInstanceOf[ArrayBuffer[scala.collection.mutable.Map[String,Any]]], input)
    return (scala.collection.mutable.Map("ok" -> (true), "out" -> (out))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
  }
  
  def main(): Any = {
    println("validating " + String.valueOf((testSet).size) + " test cases")
    var failures: Boolean = false
    var i: BigInt = BigInt(0)
    while (i < BigInt(((testSet).size).toInt)) {
      val tc: Map[String,String] = testSet((i.toInt).toInt)
      val res: scala.collection.mutable.Map[String,Any] = interpret(tc.getOrElse("ruleSet", "").asInstanceOf[String], tc.getOrElse("sample", "").asInstanceOf[String])
      if ((!(res.getOrElse("ok", null)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
        println("test " + String.valueOf(i + BigInt(1)) + " invalid ruleset")
        failures = true
      } else {
        if (res.getOrElse("out", null) != tc.getOrElse("output", "").asInstanceOf[String]) {
          println("test " + String.valueOf(i + BigInt(1)) + ": got " + res.getOrElse("out", null) + ", want " + tc.getOrElse("output", "").asInstanceOf[String])
          failures = true
        }
      }
      i = i + BigInt(1)
    }
    if ((!failures).asInstanceOf[Boolean]) {
      println("no failures")
    }
  }
  
  var testSet: ArrayBuffer[Map[String,String]] = ArrayBuffer(scala.collection.mutable.Map("ruleSet" -> ("# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"), "sample" -> ("I bought a B of As from T S."), "output" -> ("I bought a bag of apples from my brother.")), scala.collection.mutable.Map("ruleSet" -> ("# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"), "sample" -> ("I bought a B of As from T S."), "output" -> ("I bought a bag of apples from T shop.")), scala.collection.mutable.Map("ruleSet" -> ("# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"), "sample" -> ("I bought a B of As W my Bgage from T S."), "output" -> ("I bought a bag of apples with my money from T shop.")), scala.collection.mutable.Map("ruleSet" -> ("### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n"), "sample" -> ("_1111*11111_"), "output" -> ("11111111111111111111")), scala.collection.mutable.Map("ruleSet" -> ("# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n"), "sample" -> ("000000A000000"), "output" -> ("00011H1111000")))
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
