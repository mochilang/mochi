// Generated by Mochi v0.10.52 on 2025-08-02 02:05:52 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def split(s: String, sep: String): ArrayBuffer[String] = {
  var parts: ArrayBuffer[String] = ArrayBuffer()
  var cur: String = ""
  var i: BigInt = BigInt(0)
  while (i < (s).size) {
    if ((((sep).size > BigInt(0) && i + (sep).size <= (s).size).asInstanceOf[Boolean] && s.slice((i).toInt, (i + (sep).size).toInt) == sep).asInstanceOf[Boolean]) {
      parts = parts :+ cur
      cur = ""
      i = i + (sep).size
    } else {
      cur = cur + s.slice((i).toInt, (i + BigInt(1)).toInt)
      i = i + BigInt(1)
    }
  }
  parts = parts :+ cur
  return parts
}

def trimSpace(s: String): String = {
  var start: BigInt = BigInt(0)
  while (start < (s).size && (s.slice((start).toInt, (start + BigInt(1)).toInt) == " " || s.slice((start).toInt, (start + BigInt(1)).toInt) == "\t").asInstanceOf[Boolean]) {
    start = start + BigInt(1)
  }
  var end: Int = (s).size
  while (end > start && (s.slice((end - BigInt(1).toInt).toInt, (end).toInt) == " " || s.slice((end - BigInt(1).toInt).toInt, (end).toInt) == "\t").asInstanceOf[Boolean]) {
    end = end - BigInt(1).toInt.toInt
  }
  return s.slice((start).toInt, (end).toInt)
}

def indexOfSub(s: String, sub: String): BigInt = {
  if ((sub).size == BigInt(0)) {
    return BigInt(0)
  }
  var i: BigInt = BigInt(0)
  while (i + (sub).size <= (s).size) {
    if (s.slice((i).toInt, (i + (sub).size).toInt) == sub) {
      return i
    }
    i = i + BigInt(1)
  }
  return BigInt(0) - BigInt(1)
}

def parseRules(rs: String): scala.collection.mutable.Map[String,Any] = {
  var rules: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = ArrayBuffer()
  val _br4 = new Breaks
  val _ct4 = new Breaks
  _br4.breakable {
    for (line <- ArrayBuffer(rs.split("\n"): _*)) {
      _ct4.breakable {
        var ln: Any = line
        val hash: BigInt = indexOfSub(ln.toString, "#")
        if (hash >= BigInt(0)) {
          ln = ln.slice((BigInt(0)).toInt, (hash).toInt)
        }
        ln = trimSpace(ln.toString)
        if ((ln.toString).size == BigInt(0)) {
          _ct4.break()
        }
        var arrow: BigInt = BigInt(0) - BigInt(1)
        var j: BigInt = BigInt(0)
        val _br5 = new Breaks
        _br5.breakable {
          while (j + BigInt(2) <= (ln.toString).size) {
            if (ln.toString.slice((j).toInt, (j + BigInt(2)).toInt) == "->") {
              var pre: Boolean = j > BigInt(0) && (ln.slice((j - BigInt(1)).toInt, (j).toInt) == " " || ln.slice((j - BigInt(1)).toInt, (j).toInt) == "\t").asInstanceOf[Boolean]
              var post: Boolean = j + BigInt(2) < (ln.toString).size && (ln.slice((j + BigInt(2)).toInt, (j + BigInt(3)).toInt) == " " || ln.slice((j + BigInt(2)).toInt, (j + BigInt(3)).toInt) == "\t").asInstanceOf[Boolean]
              if ((pre && post).asInstanceOf[Boolean]) {
                arrow = j
                _br5.break()
              }
            }
            j = j + BigInt(1)
          }
        }
        if (arrow < BigInt(0)) {
          arrow = indexOfSub(ln.toString, "->")
        }
        if (arrow < BigInt(0)) {
          return (scala.collection.mutable.Map("ok" -> (false))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
        }
        var pat: String = trimSpace((ln.slice((BigInt(0)).toInt, (arrow).toInt)).toString)
        var rest: String = trimSpace((ln.slice((arrow + BigInt(2)).toInt, ((ln.toString).size).toInt)).toString)
        var term: Boolean = false
        if (((rest).size > BigInt(0) && rest.slice((BigInt(0)).toInt, (BigInt(1)).toInt) == ".").asInstanceOf[Boolean]) {
          term = true
          rest = rest.slice((BigInt(1)).toInt, ((rest).size).toInt)
        }
        var rep: String = rest
        rules = rules :+ (scala.collection.mutable.Map("pat" -> (pat), "rep" -> (rep), "term" -> (term))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
      }
    }
  }
  return (scala.collection.mutable.Map("ok" -> (true), "rules" -> (rules))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
}

def runRules(rules: ArrayBuffer[scala.collection.mutable.Map[String,Any]], _s: String): String = {
  var s: String = _s
  var changed: Boolean = true
  val _br6 = new Breaks
  _br6.breakable {
    while (changed) {
      changed = false
      var i: BigInt = BigInt(0)
      val _br7 = new Breaks
      _br7.breakable {
        while (i < (rules).size) {
          val r: scala.collection.mutable.Map[String,Any] = rules((i).toInt).asInstanceOf[scala.collection.mutable.Map[String,Any]]
          val pat = r("pat")
          val rep = r("rep")
          var term = r("term")
          val idx: BigInt = indexOfSub(s, pat.toString)
          if (idx >= BigInt(0)) {
            s = s.slice((BigInt(0)).toInt, (idx).toInt) + rep + s.slice((idx + (pat.toString).size).toInt, ((s).size).toInt)
            changed = true
            if (term.asInstanceOf[Boolean]) {
              return s
            }
            _br7.break()
          }
          i = i + BigInt(1)
        }
      }
    }
  }
  return s
}

def interpret(ruleset: String, input: String): scala.collection.mutable.Map[String,Any] = {
  val p: scala.collection.mutable.Map[String,Any] = parseRules(ruleset)
  if ((!(p("ok")).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
    return (scala.collection.mutable.Map("ok" -> (false), "out" -> (""))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
  }
  val out: String = runRules((p("rules")).asInstanceOf[ArrayBuffer[scala.collection.mutable.Map[String,Any]]], input)
  return (scala.collection.mutable.Map("ok" -> (true), "out" -> (out))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
}

def main(): Any = {
  println("validating " + String.valueOf((testSet).size) + " test cases")
  var failures: Boolean = false
  var i: BigInt = BigInt(0)
  while (i < (testSet).size) {
    val tc: Map[String,String] = testSet((i).toInt)
    val res: scala.collection.mutable.Map[String,Any] = interpret(tc("ruleSet"), tc("sample"))
    if ((!(res("ok")).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
      println("test " + String.valueOf(i + BigInt(1)) + " invalid ruleset")
      failures = true
    } else {
      if (res("out") != tc("output")) {
        println("test " + String.valueOf(i + BigInt(1)) + ": got " + res("out") + ", want " + tc("output"))
        failures = true
      }
    }
    i = i + BigInt(1)
  }
  if ((!failures).asInstanceOf[Boolean]) {
    println("no failures")
  }
}

var testSet: ArrayBuffer[Map[String,String]] = ArrayBuffer(scala.collection.mutable.Map("ruleSet" -> ("# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"), "sample" -> ("I bought a B of As from T S."), "output" -> ("I bought a bag of apples from my brother.")), scala.collection.mutable.Map("ruleSet" -> ("# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"), "sample" -> ("I bought a B of As from T S."), "output" -> ("I bought a bag of apples from T shop.")), scala.collection.mutable.Map("ruleSet" -> ("# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"), "sample" -> ("I bought a B of As W my Bgage from T S."), "output" -> ("I bought a bag of apples with my money from T shop.")), scala.collection.mutable.Map("ruleSet" -> ("### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n"), "sample" -> ("_1111*11111_"), "output" -> ("11111111111111111111")), scala.collection.mutable.Map("ruleSet" -> ("# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n"), "sample" -> ("000000A000000"), "output" -> ("00011H1111000")))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
