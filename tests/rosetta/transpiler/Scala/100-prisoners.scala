// Generated by Mochi v0.10.37 on 2025-07-23 10:18:22 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Int = 0
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed
  } else {
    Math.abs(System.nanoTime().toInt)
  }
}

def shuffle(xs: ArrayBuffer[Int]): ArrayBuffer[Int] = {
  var arr = xs
  var i: Int = 99
  while (i > 0) {
    val j = _now() % i + 1
    val tmp = arr.asInstanceOf[ArrayBuffer[Any]](i)
    arr.asInstanceOf[ArrayBuffer[Any]](i) = arr.asInstanceOf[ArrayBuffer[Any]](j)
    arr.asInstanceOf[ArrayBuffer[Any]](j) = tmp
    i = i - 1
  }
  return arr
}

def doTrials(trials: Int, np: Int, strategy: String) = {
  var pardoned: Int = 0
  var t: Int = 0
  breakable {
    while (t < trials) {
      var drawers: ArrayBuffer[Int] = ArrayBuffer()
      var i: Int = 0
      while (i < 100) {
        drawers = drawers :+ i
        i = i + 1
      }
      drawers = shuffle(drawers)
      var p: Int = 0
      var success: Boolean = true
      breakable {
        while (p < np) {
          var found: Boolean = false
          if (strategy == "optimal") {
            var prev: Int = p
            var d: Int = 0
            breakable {
              while (d < 50) {
                val `this` = drawers(prev)
                if (`this` == p) {
                  found = true
                  break
                }
                prev = `this`
                d = d + 1
              }
            }
          } else {
            var opened: ArrayBuffer[Boolean] = ArrayBuffer()
            var k: Int = 0
            while (k < 100) {
              opened = opened :+ false
              k = k + 1
            }
            var d: Int = 0
            breakable {
              while (d < 50) {
                var n = _now() % 100
                while (opened(n)) {
                  n = _now() % 100
                }
                opened(n) = true
                if (drawers(n) == p) {
                  found = true
                  break
                }
                d = d + 1
              }
            }
          }
          if ((!found).asInstanceOf[Boolean]) {
            success = false
            break
          }
          p = p + 1
        }
      }
      if (success) {
        pardoned = pardoned + 1
      }
      t = t + 1
    }
  }
  val rf: Double = pardoned.asInstanceOf[Double] / trials.asInstanceOf[Double] * 100.0
  println("  strategy = " + strategy + "  pardoned = " + String.valueOf(pardoned) + " relative frequency = " + String.valueOf(rf) + "%")
}

def main() = {
  val trials: Int = 1000
  for (np <- ArrayBuffer(10, 100)) {
    println("Results from " + String.valueOf(trials) + " trials with " + String.valueOf(np) + " prisoners:\n")
    for (strat <- ArrayBuffer("random", "optimal")) {
      doTrials(trials, np, strat)
    }
  }
}

def main(args: Array[String]): Unit = {
  main()
}
}
