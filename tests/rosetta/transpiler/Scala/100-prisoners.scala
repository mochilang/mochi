// Generated by Mochi v0.10.39 on 2025-07-25 10:15:07 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs(System.nanoTime().toInt)
  }
}

def shuffle(xs: ArrayBuffer[Int]): ArrayBuffer[Int] = {
  var arr: ArrayBuffer[Int] = xs
  var i: Int = 99
  while (i > 0) {
    val j = _now() % (i + 1)
    val tmp: Int = arr(i)
    arr(i) = arr(j)
    arr(j) = tmp
    i = (i - 1).asInstanceOf[Int]
  }
  return arr
}

def doTrials(trials: Int, np: Int, strategy: String): Unit = {
  var pardoned: Int = 0
  var t: Int = 0
  val _br1 = new Breaks
  _br1.breakable {
    while (t < trials) {
      var drawers: ArrayBuffer[Int] = ArrayBuffer()
      var i: Int = 0
      while (i < 100) {
        drawers = drawers :+ i
        i = (i + 1).asInstanceOf[Int]
      }
      drawers = shuffle(drawers)
      var p: Int = 0
      var success: Boolean = true
      val _br3 = new Breaks
      _br3.breakable {
        while (p < np) {
          var found: Boolean = false
          if (strategy == "optimal") {
            var prev: Int = p
            var d: Int = 0
            val _br4 = new Breaks
            _br4.breakable {
              while (d < 50) {
                val `this`: Int = drawers(prev)
                if (`this` == p) {
                  found = true
                  _br4.break()
                }
                prev = `this`
                d = (d + 1).asInstanceOf[Int]
              }
            }
          } else {
            var opened: ArrayBuffer[Boolean] = ArrayBuffer()
            var k: Int = 0
            while (k < 100) {
              opened = opened :+ false
              k = (k + 1).asInstanceOf[Int]
            }
            var d: Int = 0
            val _br6 = new Breaks
            _br6.breakable {
              while (d < 50) {
                var n = Math.floorMod(_now(), 100)
                while (opened(n)) {
                  n = (Math.floorMod(_now(), 100)).asInstanceOf[Int]
                }
                opened(n) = true
                if (drawers(n) == p) {
                  found = true
                  _br6.break()
                }
                d = (d + 1).asInstanceOf[Int]
              }
            }
          }
          if ((!found).asInstanceOf[Boolean]) {
            success = false
            _br3.break()
          }
          p = (p + 1).asInstanceOf[Int]
        }
      }
      if (success) {
        pardoned = (pardoned + 1).asInstanceOf[Int]
      }
      t = (t + 1).asInstanceOf[Int]
    }
  }
  val rf: Double = pardoned.toString.toDouble / trials.toString.toDouble * 100.0
  println("  strategy = " + strategy + "  pardoned = " + String.valueOf(pardoned) + " relative frequency = " + String.valueOf(rf) + "%")
}

def main(): Unit = {
  val trials: Int = 1000
  for (np <- ArrayBuffer(10, 100)) {
    println("Results from " + String.valueOf(trials) + " trials with " + String.valueOf(np) + " prisoners:\n")
    for (strat <- ArrayBuffer("random", "optimal")) {
      doTrials(trials, np.asInstanceOf[Int], strat.asInstanceOf[String])
    }
  }
}

def main(args: Array[String]): Unit = {
  main()
}
}
