// Generated by Mochi v0.10.57 on 2025-08-04 21:00:58 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private def _parseIntStr(s: String, base: BigInt): BigInt = BigInt(s, base.toInt)
  
  def isLeap(y: BigInt): Boolean = {
    if (y % 400 == 0) {
      return true
    }
    if (y % 100 == 0) {
      return false
    }
    return y % 4 == 0
  }
  
  def daysInMonth(y: BigInt, m: BigInt): BigInt = {
    val feb: BigInt = (if (isLeap(y)) 29 else 28)
    val lengths: ArrayBuffer[BigInt] = ArrayBuffer(31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
    return lengths(((m - 1).toInt).toInt)
  }
  
  def daysBeforeYear(y: BigInt): BigInt = {
    var days: BigInt = 0
    var yy: BigInt = 1970
    while (yy < y) {
      days = days + 365
      if (isLeap(yy)) {
        days = days + 1
      }
      yy = yy + 1
    }
    return days
  }
  
  def daysBeforeMonth(y: BigInt, m: BigInt): BigInt = {
    var days: BigInt = 0
    var mm: BigInt = 1
    while (mm < m) {
      days = days + daysInMonth(y, mm)
      mm = mm + 1
    }
    return days
  }
  
  def epochSeconds(y: BigInt, m: BigInt, d: BigInt, h: BigInt, mi: BigInt): BigInt = {
    val days: BigInt = daysBeforeYear(y) + daysBeforeMonth(y, m) + (d - 1)
    return days * 86400 + h * 3600 + mi * 60
  }
  
  def fromEpoch(sec: BigInt): ArrayBuffer[BigInt] = {
    var days: BigInt = sec / 86400
    var rem: BigInt = sec % 86400
    var y: BigInt = 1970
    val _br2 = new Breaks
    _br2.breakable {
      while (true) {
        val dy: BigInt = (if (isLeap(y)) 366 else 365)
        if (days >= dy) {
          days = days - dy
          y = y + 1
        } else {
          _br2.break()
        }
      }
    }
    var m: BigInt = 1
    val _br3 = new Breaks
    _br3.breakable {
      while (true) {
        val dim: BigInt = daysInMonth(y, m)
        if (days >= dim) {
          days = days - dim
          m = m + 1
        } else {
          _br3.break()
        }
      }
    }
    val d: BigInt = days + 1
    val h: BigInt = rem / 3600
    val mi: BigInt = rem % 3600 / 60
    return ArrayBuffer(y, m, d, h, mi)
  }
  
  def pad2(n: BigInt): String = {
    if (n < 10) {
      return "0" + String.valueOf(n)
    }
    return String.valueOf(n)
  }
  
  def absInt(n: BigInt): BigInt = {
    if (n < 0) {
      return 0 - n
    }
    return n
  }
  
  def formatDate(parts: ArrayBuffer[BigInt], offset: BigInt, abbr: String): String = {
    val y: BigInt = parts((0.toInt).toInt)
    val m: BigInt = parts((1.toInt).toInt)
    val d: BigInt = parts((2.toInt).toInt)
    val h: BigInt = parts((3.toInt).toInt)
    val mi: BigInt = parts((4.toInt).toInt)
    var sign: String = "+"
    if (offset < 0) {
      sign = "-"
    }
    val off: BigInt = absInt(offset) / 60
    val offh: String = pad2(off / 60)
    val offm: String = pad2(off % 60)
    return String.valueOf(y) + "-" + pad2(m) + "-" + pad2(d) + " " + pad2(h) + ":" + pad2(mi) + ":00 " + sign + offh + offm + " " + abbr
  }
  
  def parseIntStr(str: String): BigInt = {
    var i: BigInt = 0
    var neg: Boolean = false
    if ((BigInt(((str).size).toInt) > 0 && str.slice((0).toInt, (1).toInt) == "-").asInstanceOf[Boolean]) {
      neg = true
      i = 1
    }
    var n: BigInt = 0
    val digits: Map[String,BigInt] = scala.collection.mutable.Map("0" -> (0), "1" -> (1), "2" -> (2), "3" -> (3), "4" -> (4), "5" -> (5), "6" -> (6), "7" -> (7), "8" -> (8), "9" -> (9))
    while (i < BigInt(((str).size).toInt)) {
      n = n * 10 + digits.getOrElse(str.slice((i).toInt, (i + 1).toInt), null).asInstanceOf[BigInt]
      i = i + 1
    }
    if (neg) {
      n = 0 - n
    }
    return n
  }
  
  def indexOf(s: String, ch: String): BigInt = {
    var i: BigInt = 0
    while (i < BigInt(((s).size).toInt)) {
      if (s.slice((i).toInt, (i + 1).toInt) == ch) {
        return i
      }
      i = i + 1
    }
    return 0 - 1
  }
  
  def parseTime(s: String): ArrayBuffer[BigInt] = {
    val c: BigInt = BigInt(s.indexOf(":"))
    val h = _parseIntStr(s.slice((0).toInt, (c).toInt), 10)
    val mi = _parseIntStr(s.slice((c + 1).toInt, (c + 3).toInt), 10)
    val ampm: String = s.slice(((s).size - 2.toInt).toInt, ((s).size).toInt)
    var hh: BigInt = h
    if ((ampm == "pm" && h != 12).asInstanceOf[Boolean]) {
      hh = h + 12
    }
    if ((ampm == "am" && h == 12).asInstanceOf[Boolean]) {
      hh = 0
    }
    return (ArrayBuffer(hh, mi)).asInstanceOf[ArrayBuffer[BigInt]]
  }
  
  def main(): Any = {
    val input: String = "March 7 2009 7:30pm EST"
    println("Input:              " + input)
    var parts: ArrayBuffer[Any] = ArrayBuffer()
    var cur: String = ""
    var i: BigInt = 0
    while (i < BigInt(((input).size).toInt)) {
      val ch: String = input.slice((i).toInt, (i + 1).toInt)
      if (ch == " ") {
        if (BigInt(((cur).size).toInt) > 0) {
          parts = parts :+ cur.asInstanceOf[Any]
          cur = ""
        }
      } else {
        cur = cur + ch
      }
      i = i + 1
    }
    if (BigInt(((cur).size).toInt) > 0) {
      parts = parts :+ cur.asInstanceOf[Any]
    }
    val month: BigInt = months.getOrElse(parts((0.toInt).toInt).toString, null).asInstanceOf[BigInt]
    val day = _parseIntStr(parts((1.toInt).toInt).toString, 10)
    val year = _parseIntStr(parts((2.toInt).toInt).toString, 10)
    val tm: ArrayBuffer[BigInt] = parseTime((parts((3.toInt).toInt)).toString)
    val hour: BigInt = tm((0.toInt).toInt)
    val minute: BigInt = tm((1.toInt).toInt)
    val tz: Any = parts((4.toInt).toInt)
    val zoneOffsets: Map[String,BigInt] = scala.collection.mutable.Map("EST" -> (0 - 18000), "EDT" -> (0 - 14400), "MST" -> (0 - 25200))
    val local: BigInt = epochSeconds(year, month, day, hour, minute)
    val utc: BigInt = local - zoneOffsets.getOrElse(tz.toString, null).asInstanceOf[BigInt]
    val utc12: BigInt = utc + 43200
    val startDST: BigInt = epochSeconds(2009, 3, 8, 7, 0)
    var offEast: BigInt = 0 - 18000
    if (utc12 >= startDST) {
      offEast = 0 - 14400
    }
    val eastParts: ArrayBuffer[BigInt] = fromEpoch(utc12 + offEast)
    var eastAbbr: String = "EST"
    if (offEast == 0 - 14400) {
      eastAbbr = "EDT"
    }
    println("+12 hrs:            " + formatDate(eastParts, offEast, eastAbbr))
    val offAZ: BigInt = 0 - 25200
    val azParts: ArrayBuffer[BigInt] = fromEpoch(utc12 + offAZ)
    println("+12 hrs in Arizona: " + formatDate(azParts, offAZ, "MST"))
  }
  
  val months: Map[String,BigInt] = scala.collection.mutable.Map("January" -> (1), "February" -> (2), "March" -> (3), "April" -> (4), "May" -> (5), "June" -> (6), "July" -> (7), "August" -> (8), "September" -> (9), "October" -> (10), "November" -> (11), "December" -> (12))
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
