// Generated by Mochi v0.10.41 on 2025-07-27 16:19:15 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  def isPrime(n: BigInt): Boolean = {
    if (n < BigInt(2)) {
      return false
    }
    if (n % BigInt(2) == BigInt(0)) {
      return n == BigInt(2)
    }
    if (n % BigInt(3) == BigInt(0)) {
      return n == BigInt(3)
    }
    var d: BigInt = BigInt(5)
    while (d * d <= n) {
      if (n % d == BigInt(0)) {
        return false
      }
      d = (d + BigInt(2)).asInstanceOf[BigInt]
      if (n % d == BigInt(0)) {
        return false
      }
      d = (d + BigInt(4)).asInstanceOf[BigInt]
    }
    return true
  }
  
  def isCircular(n: BigInt): Boolean = {
    var nn: BigInt = n
    var pow: BigInt = BigInt(1)
    while (nn > BigInt(0)) {
      pow = (pow * BigInt(10)).asInstanceOf[BigInt]
      nn = (nn / BigInt(10)).asInstanceOf[BigInt]
    }
    nn = n
    val _br2 = new Breaks
    _br2.breakable {
      while (true) {
        nn = (nn * BigInt(10)).asInstanceOf[BigInt]
        val f = nn / pow
        nn = (nn + f * (BigInt(1) - pow)).asInstanceOf[BigInt]
        if (nn == n) {
          _br2.break()
        }
        if ((!isPrime(nn)).asInstanceOf[Boolean]) {
          return false
        }
      }
    }
    return true
  }
  
  def showList(xs: ArrayBuffer[BigInt]): String = {
    var out: String = "["
    var i: BigInt = BigInt(0)
    while (i < (xs).size) {
      out = (out + String.valueOf(xs((i).toInt))).toString
      if (i < (xs).size - BigInt(1)) {
        out = out + ", "
      }
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    return out + "]"
  }
  
  var circs: ArrayBuffer[BigInt] = ArrayBuffer()
  
  var digits: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(1), BigInt(3), BigInt(7), BigInt(9))
  
  var q: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(1), BigInt(2), BigInt(3), BigInt(5), BigInt(7), BigInt(9))
  
  var fq: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(1), BigInt(2), BigInt(3), BigInt(5), BigInt(7), BigInt(9))
  
  var count: BigInt = BigInt(0)
  
  def main(args: Array[String]): Unit = {
    println("The first 19 circular primes are:")
    val _br4 = new Breaks
    _br4.breakable {
      while (true) {
        val f: BigInt = q((BigInt(0)).toInt)
        val fd: BigInt = fq((BigInt(0)).toInt)
        if ((isPrime(f) && isCircular(f)).asInstanceOf[Boolean]) {
          circs = circs :+ f
          count = (count + BigInt(1)).asInstanceOf[BigInt]
          if (count == BigInt(19)) {
            _br4.break()
          }
        }
        q = q.slice((BigInt(1)).toInt, ((q).size).toInt)
        fq = fq.slice((BigInt(1)).toInt, ((fq).size).toInt)
        if ((f != BigInt(2) && f != BigInt(5)).asInstanceOf[Boolean]) {
          for (d <- digits) {
            q = q :+ ((f * BigInt(10)).toString.toDouble + d.toString.toDouble).asInstanceOf[BigInt]
            fq = fq :+ fd
          }
        }
      }
    }
    println(showList(circs))
    println("\nThe next 4 circular primes, in repunit format, are:")
    println("[R(19) R(23) R(317) R(1031)]")
    println("\nThe following repunits are probably circular primes:")
    for (i <- ArrayBuffer(BigInt(5003), BigInt(9887), BigInt(15073), BigInt(25031), BigInt(35317), BigInt(49081))) {
      println("R(" + String.valueOf(i) + ") : true")
    }
  }
}
