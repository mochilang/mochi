// Generated by Mochi v0.10.39 on 2025-07-25 00:49:18 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def sinApprox(x: Double): Double = {
    var term: Double = x
    var sum: Double = x
    var n: Int = 1
    while (n <= 10) {
      val denom: Double = ((2 * n).asInstanceOf[Double] * (2 * n + 1).asInstanceOf[Double]).toString.toDouble
      term = ((0 - term) * x * x / denom).asInstanceOf[Double]
      sum = (sum + term).asInstanceOf[Double]
      n = (n + 1).asInstanceOf[Int]
    }
    return sum
  }
  
  def cosApprox(x: Double): Double = {
    var term: Double = 1.0
    var sum: Double = 1.0
    var n: Int = 1
    while (n <= 10) {
      val denom: Double = ((2 * n - 1).asInstanceOf[Double] * (2 * n).asInstanceOf[Double]).toString.toDouble
      term = ((0 - term) * x * x / denom).asInstanceOf[Double]
      sum = (sum + term).asInstanceOf[Double]
      n = (n + 1).asInstanceOf[Int]
    }
    return sum
  }
  
  val PI: Double = 3.141592653589793
  
  val degreesIncr: Double = 0.1 * PI / 180.0
  
  val turns: Double = 2.0
  
  val stop: Double = 360.0 * turns * 10.0 * degreesIncr
  
  val width: Double = 600.0
  
  val centre: Double = width / 2.0
  
  val a: Double = 1.0
  
  val b: Double = 20.0
  
  var theta: Double = 0.0
  
  var count: Int = 0
  
  def main(args: Array[String]): Unit = {
    while (theta < stop) {
      val r = a + b * theta
      val x = r * cosApprox(theta)
      val y = r * sinApprox(theta)
      if (count % 100 == 0) {
        println(String.valueOf(centre + x) + "," + String.valueOf(centre - y))
      }
      theta = (theta + degreesIncr).asInstanceOf[Double]
      count = (count + 1).asInstanceOf[Int]
    }
  }
}
