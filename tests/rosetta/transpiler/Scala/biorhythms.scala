// Generated by Mochi v0.10.40 on 2025-07-26 05:11:11 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _contains[T](seq: Seq[T], v: T): Boolean = seq.contains(v)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    val PI: Double = 3.141592653589793
    val TWO_PI: Double = 6.283185307179586
    def sinApprox(x: Double): Double = {
      var term: Double = x
      var sum: Double = x
      var n: Int = 1
      while (n <= 8) {
        val denom: Double = ((2 * n).toString.toDouble * (2 * n + 1).toString.toDouble).toString.toDouble
        term = ((0 - term) * x * x / denom).toString.toDouble
        sum = (sum + term).toString.toDouble
        n = (n + 1).asInstanceOf[Int]
      }
      return sum
    }
    def floor(x: Double): Double = {
      var i: Int = x.asInstanceOf[Int]
      if (i.toString.toDouble > x) {
        i = (i - 1).asInstanceOf[Int]
      }
      return i.toString.toDouble
    }
    def absFloat(x: Double): Double = {
      if (x < 0.0) {
        return (0 - x).toString.toDouble
      }
      return x
    }
    def absInt(n: Int): Int = {
      if (n < 0) {
        return (0 - n).asInstanceOf[Int]
      }
      return n
    }
    def parseIntStr(str: String): Int = {
      var i: Int = 0
      var neg: Boolean = false
      if (((str).size > 0 && str.slice(0, 1) == "-").asInstanceOf[Boolean]) {
        neg = true
        i = 1
      }
      var n: Int = 0
      val digits: Map[String,Int] = Map("0" -> (0), "1" -> (1), "2" -> (2), "3" -> (3), "4" -> (4), "5" -> (5), "6" -> (6), "7" -> (7), "8" -> (8), "9" -> (9))
      while (i < (str).size) {
        n = (n * 10 + digits.getOrElse(str.slice(i, i + 1), null.asInstanceOf[Int])).asInstanceOf[Int]
        i = (i + 1).asInstanceOf[Int]
      }
      if (neg) {
        n = (0 - n).asInstanceOf[Int]
      }
      return n
    }
    def parseDate(s: String): ArrayBuffer[Int] = {
      val y: Int = parseIntStr(s.slice(0, 4))
      val m: Int = parseIntStr(s.slice(5, 7))
      val d: Int = parseIntStr(s.slice(8, 10))
      return (ArrayBuffer(y, m, d)).asInstanceOf[ArrayBuffer[Int]]
    }
    def leap(y: Int): Boolean = {
      if (Math.floorMod(y, 400) == 0) {
        return true
      }
      if (Math.floorMod(y, 100) == 0) {
        return false
      }
      return Math.floorMod(y, 4) == 0
    }
    def daysInMonth(y: Int, m: Int): Int = {
      val feb: Int = if (leap(y)) 29 else 28
      val lengths: ArrayBuffer[Int] = ArrayBuffer(31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
      return lengths(m - 1)
    }
    def addDays(y: Int, m: Int, d: Int, n: Int): ArrayBuffer[Int] = {
      var yy: Int = y
      var mm: Int = m
      var dd: Int = d
      if (n >= 0) {
        var i: Int = 0
        while (i < n) {
          dd = (dd + 1).asInstanceOf[Int]
          if (dd > daysInMonth(yy, mm)) {
            dd = 1
            mm = (mm + 1).asInstanceOf[Int]
            if (mm > 12) {
              mm = 1
              yy = (yy + 1).asInstanceOf[Int]
            }
          }
          i = (i + 1).asInstanceOf[Int]
        }
      } else {
        var i: Int = 0
        while (i > n) {
          dd = (dd - 1).asInstanceOf[Int]
          if (dd < 1) {
            mm = (mm - 1).asInstanceOf[Int]
            if (mm < 1) {
              mm = 12
              yy = (yy - 1).asInstanceOf[Int]
            }
            dd = daysInMonth(yy, mm)
          }
          i = (i - 1).asInstanceOf[Int]
        }
      }
      return (ArrayBuffer(yy, mm, dd)).asInstanceOf[ArrayBuffer[Int]]
    }
    def pad2(n: Int): String = {
      if (n < 10) {
        return "0" + String.valueOf(n)
      }
      return (String.valueOf(n)).toString
    }
    def dateString(y: Int, m: Int, d: Int): String = {
      return String.valueOf(y) + "-" + pad2(m) + "-" + pad2(d)
    }
    def day(y: Int, m: Int, d: Int): Int = {
      val part1 = 367 * y
      val part2: Int = (7 * (y + (m + 9) / 12).asInstanceOf[Int] / 4).asInstanceOf[Int]
      val part3: Int = (275 * m / 9).asInstanceOf[Int]
      return (part1 - part2 + part3 + d - 730530).asInstanceOf[Int]
    }
    def biorhythms(birth: String, target: String): Any = {
      val bparts: ArrayBuffer[Int] = parseDate(birth)
      val by: Int = bparts(0)
      val bm: Int = bparts(1)
      val bd: Int = bparts(2)
      val tparts: ArrayBuffer[Int] = parseDate(target)
      val ty: Int = tparts(0)
      val tm: Int = tparts(1)
      val td: Int = tparts(2)
      val diff: Int = absInt((day(ty, tm, td) - day(by, bm, bd)).asInstanceOf[Int])
      println("Born " + birth + ", Target " + target)
      println("Day " + String.valueOf(diff))
      val cycles: ArrayBuffer[String] = ArrayBuffer("Physical day ", "Emotional day", "Mental day   ")
      val lengths: ArrayBuffer[Int] = ArrayBuffer(23, 28, 33)
      val quadrants: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer(ArrayBuffer("up and rising", "peak"), ArrayBuffer("up but falling", "transition"), ArrayBuffer("down and falling", "valley"), ArrayBuffer("down but rising", "transition"))
      var i: Int = 0
      while (i < 3) {
        val length: Int = lengths(i)
        val cycle: String = cycles(i)
        val position = Math.floorMod(diff, length)
        val quadrant = position.asInstanceOf[Int] * 4 / length
        var percent: Double = sinApprox(2.0 * PI * position.toString.toDouble / length.toString.toDouble)
        percent = floor(percent * 1000.0) / 10.0
        var description: String = ""
        if (percent > 95.0) {
          description = " peak"
        } else {
          if (percent < 0 - 95.0) {
            description = " valley"
          } else {
            if (absFloat(percent) < 5.0) {
              description = " critical transition"
            } else {
              val daysToAdd: Double = ((quadrant.asInstanceOf[Int] + 1) * length / 4).toString.toDouble - position.toString.toDouble
              val res: ArrayBuffer[Int] = addDays(ty, tm, td, daysToAdd.asInstanceOf[Int])
              val ny: Int = res(0)
              val nm: Int = res(1)
              val nd: Int = res(2)
              val transition: String = dateString(ny, nm, nd)
              val trend: String = quadrants(quadrant)(0)
              val next: String = quadrants(quadrant)(1)
              var pct = String.valueOf(percent)
              if ((!(pct.contains(".")).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
                pct = pct + ".0"
              }
              description = " " + pct + "% (" + trend + ", next " + next + " " + transition + ")"
            }
          }
        }
        var posStr = String.valueOf(position)
        if (position.asInstanceOf[Int] < 10) {
          posStr = " " + posStr
        }
        println(cycle + posStr + " : " + description)
        i = (i + 1).asInstanceOf[Int]
      }
      println("")
    }
    def main(): Any = {
      val pairs: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer(ArrayBuffer("1943-03-09", "1972-07-11"), ArrayBuffer("1809-01-12", "1863-11-19"), ArrayBuffer("1809-02-12", "1863-11-19"))
      var idx: Int = 0
      while (idx < (pairs).size) {
        val p: ArrayBuffer[String] = pairs(idx)
        biorhythms(p(0), p(1))
        idx = (idx + 1).asInstanceOf[Int]
      }
    }
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
