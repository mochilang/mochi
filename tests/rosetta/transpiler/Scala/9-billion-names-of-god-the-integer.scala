// Generated by Mochi v0.10.40 on 2025-07-25 12:51:21 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def bigTrim(_a: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var a: ArrayBuffer[Int] = _a
    var n: Int = (a).size
    while (n > 1 && a(n - 1) == 0) {
      a = a.slice(0, n - 1)
      n = (n - 1).asInstanceOf[Int]
    }
    return a
  }
  
  def bigFromInt(x: Int): ArrayBuffer[Int] = {
    if (x == 0) {
      return ArrayBuffer(0)
    }
    var digits: ArrayBuffer[Int] = ArrayBuffer()
    var n: Int = x
    while (n > 0) {
      digits = digits :+ Math.floorMod(n, 10)
      n = (n / 10).asInstanceOf[Int]
    }
    return digits
  }
  
  def bigAdd(a: ArrayBuffer[Int], b: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var carry: Int = 0
    var i: Int = 0
    while ((i < (a).size || i < (b).size).asInstanceOf[Boolean] || carry > 0) {
      var av: Int = 0
      if (i < (a).size) {
        av = a(i)
      }
      var bv: Int = 0
      if (i < (b).size) {
        bv = b(i)
      }
      var s = av + bv + carry
      res = res :+ Math.floorMod(s, 10)
      carry = (s / 10).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    return bigTrim(res)
  }
  
  def bigSub(a: ArrayBuffer[Int], b: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var borrow: Int = 0
    var i: Int = 0
    while (i < (a).size) {
      var av: Int = a(i)
      var bv: Int = 0
      if (i < (b).size) {
        bv = b(i)
      }
      var diff = av - bv - borrow
      if (diff < 0) {
        diff = (diff + 10).asInstanceOf[Int]
        borrow = 1
      } else {
        borrow = 0
      }
      res = res :+ diff
      i = (i + 1).asInstanceOf[Int]
    }
    return bigTrim(res)
  }
  
  def bigToString(a: ArrayBuffer[Int]): String = {
    var s: String = ""
    var i: Int = (a).size - 1
    while (i >= 0) {
      s = (s + String.valueOf(a(i))).asInstanceOf[String]
      i = (i - 1).asInstanceOf[Int]
    }
    return s
  }
  
  def minInt(a: Int, b: Int): Int = {
    if (a < b) {
      return a
    } else {
      return b
    }
  }
  
  def cumu(n: Int): ArrayBuffer[ArrayBuffer[Int]] = {
    var cache: ArrayBuffer[ArrayBuffer[ArrayBuffer[Int]]] = ArrayBuffer(ArrayBuffer(bigFromInt(1)))
    var y: Int = 1
    while (y <= n) {
      var row: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer(bigFromInt(0))
      var x: Int = 1
      while (x <= y) {
        val `val`: ArrayBuffer[Int] = cache(y - x)(minInt(x, (y - x).asInstanceOf[Int]))
        row = row :+ bigAdd(row((row).size - 1), `val`)
        x = (x + 1).asInstanceOf[Int]
      }
      cache = cache :+ row
      y = (y + 1).asInstanceOf[Int]
    }
    return cache(n)
  }
  
  def row(n: Int): ArrayBuffer[String] = {
    val e: ArrayBuffer[ArrayBuffer[Int]] = cumu(n)
    var out: ArrayBuffer[String] = ArrayBuffer()
    var i: Int = 0
    while (i < n) {
      val diff: ArrayBuffer[Int] = bigSub(e(i + 1), e(i))
      out = out :+ bigToString(diff)
      i = (i + 1).asInstanceOf[Int]
    }
    return out
  }
  
  var x: Int = 1
  
  def main(args: Array[String]): Unit = {
    println("rows:")
    while (x < 11) {
      val r: ArrayBuffer[String] = row(x)
      var line: String = ""
      var i: Int = 0
      while (i < (r).size) {
        line = line + " " + r(i) + " "
        i = (i + 1).asInstanceOf[Int]
      }
      println(line)
      x = (x + 1).asInstanceOf[Int]
    }
    println("")
    println("sums:")
    for (num <- ArrayBuffer(23, 123, 1234)) {
      val r: ArrayBuffer[ArrayBuffer[Int]] = cumu(num.asInstanceOf[Int])
      println(String.valueOf(num) + " " + bigToString(r((r).size - 1)))
    }
  }
}
