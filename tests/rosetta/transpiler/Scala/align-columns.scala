// Generated by Mochi v0.10.40 on 2025-07-25 12:56:32 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  def split(s: String, sep: String): ArrayBuffer[String] = {
    var parts: ArrayBuffer[String] = ArrayBuffer()
    var cur: String = ""
    var i: Int = 0
    while (i < (s).size) {
      if ((((sep).size > 0 && (i + (sep).size).asInstanceOf[Int] <= (s).size).asInstanceOf[Boolean] && s.substring(i, i + (sep).size) == sep).asInstanceOf[Boolean]) {
        parts = parts :+ cur
        cur = ""
        i = (i + (sep).size).asInstanceOf[Int]
      } else {
        cur = cur + s.substring(i, i + 1)
        i = (i + 1).asInstanceOf[Int]
      }
    }
    parts = parts :+ cur
    return parts
  }
  
  def rstripEmpty(words: ArrayBuffer[String]): ArrayBuffer[String] = {
    var n: Int = (words).size
    while (n > 0 && words(n - 1) == "") {
      n = (n - 1).asInstanceOf[Int]
    }
    return words.slice(0, n)
  }
  
  def spaces(n: Int): String = {
    var out: String = ""
    var i: Int = 0
    while (i < n) {
      out = out + " "
      i = (i + 1).asInstanceOf[Int]
    }
    return out
  }
  
  def pad(word: String, width: Int, align: Int): String = {
    val diff = width - (word).size
    if (align == 0) {
      return (word + spaces(diff)).asInstanceOf[String]
    }
    if (align == 2) {
      return (spaces(diff) + word).asInstanceOf[String]
    }
    var left: Int = (diff / 2).asInstanceOf[Int]
    var right = diff - left
    return (spaces(left) + word + spaces(right)).asInstanceOf[String]
  }
  
  def newFormatter(text: String): Map[String,Any] = {
    var lines: ArrayBuffer[String] = split(text, "\n")
    var fmtLines: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer()
    var width: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = 0
    val _ct3 = new Breaks
    while (i < (lines).size) {
      _ct3.breakable {
        if ((lines(i)).size == 0) {
          i = (i + 1).asInstanceOf[Int]
          _ct3.break()
        }
        var words: ArrayBuffer[String] = rstripEmpty(split(lines(i), "$"))
        fmtLines = fmtLines :+ words
        var j: Int = 0
        while (j < (words).size) {
          val wlen: Int = (words(j)).size
          if (j == (width).size) {
            width = width :+ wlen
          } else {
            if (wlen > width(j)) {
              width(j) = wlen
            }
          }
          j = (j + 1).asInstanceOf[Int]
        }
        i = (i + 1).asInstanceOf[Int]
      }
    }
    return Map("text" -> (fmtLines), "width" -> (width))
  }
  
  def printFmt(f: Map[String,Any], align: Int): Unit = {
    val lines: ArrayBuffer[ArrayBuffer[String]] = (f.getOrElse("text", null.asInstanceOf[Any])).asInstanceOf[ArrayBuffer[ArrayBuffer[String]]]
    val width: ArrayBuffer[Int] = (f.getOrElse("width", null.asInstanceOf[Any])).asInstanceOf[ArrayBuffer[Int]]
    var i: Int = 0
    while (i < (lines).size) {
      val words: ArrayBuffer[String] = lines(i)
      var line: String = ""
      var j: Int = 0
      while (j < (words).size) {
        line = line + pad(words(j), width(j), align) + " "
        j = (j + 1).asInstanceOf[Int]
      }
      println(line)
      i = (i + 1).asInstanceOf[Int]
    }
    println("")
  }
  
  val text: String = "Given$a$text$file$of$many$lines,$where$fields$within$a$line\n" + "are$delineated$by$a$single$'dollar'$character,$write$a$program\n" + "that$aligns$each$column$of$fields$by$ensuring$that$words$in$each\n" + "column$are$separated$by$at$least$one$space.\n" + "Further,$allow$for$each$word$in$a$column$to$be$either$left\n" + "justified,$right$justified,$or$center$justified$within$its$column."
  
  val f: Map[String,Any] = newFormatter(text)
  
  def main(args: Array[String]): Unit = {
    printFmt(f, 0)
    printFmt(f, 1)
    printFmt(f, 2)
  }
}
