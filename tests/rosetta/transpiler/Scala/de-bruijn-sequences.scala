// Generated by Mochi v0.10.57 on 2025-08-04 21:02:08 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
object Main {
  private def _parseIntStr(s: String, base: BigInt): BigInt = BigInt(s, base.toInt)
  
  def dbRec(k: BigInt, n: BigInt, t: BigInt, p: BigInt, a: ArrayBuffer[BigInt], _seq: ArrayBuffer[BigInt]): ArrayBuffer[BigInt] = {
    var seq: ArrayBuffer[BigInt] = _seq
    if (t > n) {
      if (n % p == 0) {
        var j: BigInt = 1
        while (j <= p) {
          seq = seq :+ a((j.toInt).toInt)
          j = j + 1
        }
      }
    } else {
      a((t).toInt) = a(((t - p).toInt).toInt)
      seq = dbRec(k, n, t + 1, p, a, seq)
      var j: BigInt = a(((t - p).toInt).toInt) + 1
      while (j < k) {
        a((t).toInt) = j
        seq = dbRec(k, n, t + 1, t, a, seq)
        j = j + 1
      }
    }
    return seq
  }
  
  def deBruijn(k: BigInt, n: BigInt): String = {
    val digits: String = "0123456789"
    var alphabet: String = digits
    if (k < 10) {
      alphabet = digits.slice((0).toInt, (k).toInt)
    }
    var a: ArrayBuffer[BigInt] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[BigInt]]
    var i: BigInt = 0
    while (i < k * n) {
      a = a :+ BigInt(0)
      i = i + 1
    }
    var seq: ArrayBuffer[BigInt] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[BigInt]]
    seq = dbRec(k, n, 1, 1, a, seq)
    var b: String = ""
    var idx: BigInt = 0
    while (idx < BigInt(((seq).size).toInt)) {
      b = b + alphabet.slice((seq((idx.toInt).toInt).toInt).toInt, (seq((idx.toInt).toInt).toInt).toInt + 1)
      idx = idx + 1
    }
    b = b + b.slice((0).toInt, (n - 1).toInt)
    return b
  }
  
  def allDigits(s: String): Boolean = {
    var i: BigInt = 0
    while (i < BigInt(((s).size).toInt)) {
      val ch: String = s.slice((i).toInt, (i + 1).toInt)
      if ((ch < "0" || ch > "9").asInstanceOf[Boolean]) {
        return false
      }
      i = i + 1
    }
    return true
  }
  
  def parseIntStr(str: String): BigInt = {
    var n: BigInt = 0
    var i: BigInt = 0
    while (i < BigInt(((str).size).toInt)) {
      n = n * 10 + BigInt((str.slice((i).toInt, (i + 1).toInt)).charAt(0).toInt)
      i = i + 1
    }
    return n
  }
  
  def validate(db: String): Any = {
    val le: Int = (db).size
    var found: ArrayBuffer[BigInt] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[BigInt]]
    var i: BigInt = 0
    while (i < 10000) {
      found = found :+ BigInt(0)
      i = i + 1
    }
    var j: BigInt = 0
    while (j < BigInt((le - 3.toInt).toString.toDouble.toInt)) {
      val s: String = db.slice((j).toInt, (j + 4).toInt)
      if (allDigits(s)) {
        val n = _parseIntStr(s, 10)
        found((n).toInt) = found((n.toInt).toInt) + 1
      }
      j = j + 1
    }
    var errs: ArrayBuffer[String] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[String]]
    var k: BigInt = 0
    while (k < 10000) {
      if (found((k.toInt).toInt) == 0) {
        errs = errs :+ "    PIN number " + padLeft(k, 4) + " missing"
      } else {
        if (found((k.toInt).toInt) > 1) {
          errs = errs :+ "    PIN number " + padLeft(k, 4) + " occurs " + String.valueOf(found((k.toInt).toInt)) + " times"
        }
      }
      k = k + 1
    }
    val lerr: Int = (errs).size
    if (lerr == 0) {
      println("  No errors found")
    } else {
      var pl: String = "s"
      if (lerr == 1) {
        pl = ""
      }
      println("  " + String.valueOf(lerr) + " error" + pl + " found:")
      val msg: String = joinStr(errs, "\n")
      println(msg)
    }
  }
  
  def padLeft(n: BigInt, width: BigInt): String = {
    var s: String = String.valueOf(n)
    while (BigInt(((s).size).toInt) < width) {
      s = "0" + s
    }
    return s
  }
  
  def joinStr(xs: ArrayBuffer[String], sep: String): String = {
    var res: String = ""
    var i: BigInt = 0
    while (i < BigInt(((xs).size).toInt)) {
      if (i > 0) {
        res = res + sep
      }
      res = res + xs((i.toInt).toInt)
      i = i + 1
    }
    return res
  }
  
  def reverse(s: String): String = {
    var out: String = ""
    var i: Int = (s).size - 1.toInt
    while (BigInt(i.toString.toDouble.toInt) >= 0) {
      out = out + s.slice((i).toInt, (i + 1.toInt).toInt)
      i = i - 1.toInt
    }
    return out
  }
  
  def main(): Any = {
    var db: String = deBruijn(10, 4)
    val le: Int = (db).size
    println("The length of the de Bruijn sequence is " + String.valueOf(le))
    println("\nThe first 130 digits of the de Bruijn sequence are:")
    println(db.slice((0).toInt, (130).toInt))
    println("\nThe last 130 digits of the de Bruijn sequence are:")
    println(db.slice((le - 130.toInt).toInt, ((db).size).toInt))
    println("\nValidating the de Bruijn sequence:")
    validate(db)
    println("\nValidating the reversed de Bruijn sequence:")
    val dbr: String = reverse(db)
    validate(dbr)
    db = db.slice((0).toInt, (4443).toInt) + "." + db.slice((4444).toInt, ((db).size).toInt)
    println("\nValidating the overlaid de Bruijn sequence:")
    validate(db)
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
