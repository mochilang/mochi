// Generated by Mochi v0.10.56 on 2025-08-03 21:24:20 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
object Main {
  case class Complex(var re: Double, var im: Double)
  
  def sinApprox(x: Double): Double = {
    var term: Double = x
    var sum: Double = x
    var n: BigInt = BigInt(1)
    while (n <= BigInt(10)) {
      val denom: Double = (BigInt(2) * n * (BigInt(2) * n + BigInt(1))).toString.toDouble
      term = -term * x * x / denom
      sum = sum + term
      n = n + BigInt(1)
    }
    return sum
  }
  
  def cosApprox(x: Double): Double = {
    var term: Double = 1.0
    var sum: Double = 1.0
    var n: BigInt = BigInt(1)
    while (n <= BigInt(10)) {
      val denom: Double = ((BigInt(2) * n - BigInt(1)) * (BigInt(2) * n)).toString.toDouble
      term = -term * x * x / denom
      sum = sum + term
      n = n + BigInt(1)
    }
    return sum
  }
  
  def cis(x: Double): Complex = {
    return Complex(cosApprox(x), sinApprox(x))
  }
  
  def add(a: Complex, b: Complex): Complex = {
    return Complex(a.re + b.re, a.im + b.im)
  }
  
  def sub(a: Complex, b: Complex): Complex = {
    return Complex(a.re - b.re, a.im - b.im)
  }
  
  def mul(a: Complex, b: Complex): Complex = {
    return Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re)
  }
  
  def ditfft2Rec(x: ArrayBuffer[Double], y: ArrayBuffer[Complex], offX: BigInt, offY: BigInt, n: BigInt, s: BigInt): Any = {
    if (n == BigInt(1)) {
      y((offY).toInt) = Complex(x((offX.toInt).toInt), 0.0)
      return
    }
    ditfft2Rec(x, y, offX, offY, n / BigInt(2), BigInt(2) * s)
    ditfft2Rec(x, y, offX + s, offY + n / BigInt(2), n / BigInt(2), BigInt(2) * s)
    var k: BigInt = BigInt(0)
    while (k < n / BigInt(2)) {
      val angle: Double = -2.0 * PI * k.toString.toDouble / n.toString.toDouble
      val tf: Complex = mul(cis(angle), y((offY + k + n / BigInt(2).toInt).toInt))
      val a: Complex = add(y((offY + k.toInt).toInt), tf)
      val b: Complex = sub(y((offY + k.toInt).toInt), tf)
      y((offY + k).toInt) = a
      y((offY + k + n / BigInt(2)).toInt) = b
      k = k + BigInt(1)
    }
    return null
  }
  
  def ditfft2(x: ArrayBuffer[Double], y: ArrayBuffer[Complex], n: BigInt, s: BigInt): Any = {
    ditfft2Rec(x, y, BigInt(0), BigInt(0), n, s)
  }
  
  def main(): Any = {
    val x: ArrayBuffer[Double] = ArrayBuffer(1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0)
    var y: ArrayBuffer[Complex] = ArrayBuffer()
    var i: BigInt = BigInt(0)
    while (i < BigInt(((x).size).toInt)) {
      y = y :+ Complex(0.0, 0.0)
      i = i + BigInt(1)
    }
    ditfft2(x, y, BigInt(((x).size).toInt), BigInt(1))
    for (c <- y) {
      var line: String = pad(fmt((c.re).toString.toDouble), BigInt(8))
      if (BigInt((c.im).toString.toDouble.toInt) >= BigInt(0)) {
        line = line + "+" + fmt((c.im).toString.toDouble)
      } else {
        line = line + fmt((c.im).toString.toDouble)
      }
      println(line)
    }
  }
  
  def pad(s: String, w: BigInt): String = {
    var t: String = s
    while (BigInt(((t).size).toInt) < w) {
      t = " " + t
    }
    return t
  }
  
  def fmt(x: Double): String = {
    var y: Double = floorf(x * 10000.0 + 0.5) / 10000.0
    var s: String = String.valueOf(y)
    var dot: BigInt = BigInt(s.indexOf("."))
    if (dot == BigInt(0) - BigInt(1)) {
      s = s + ".0000"
    } else {
      var d: BigInt = (s).size - dot - BigInt(1)
      while (d < BigInt(4)) {
        s = s + "0"
        d = d + BigInt(1)
      }
    }
    return s
  }
  
  def floorf(x: Double): Double = {
    val y: Int = x.toInt
    return y.toString.toDouble
  }
  
  def indexOf(s: String, ch: String): BigInt = {
    var i: BigInt = BigInt(0)
    while (i < BigInt(((s).size).toInt)) {
      if (s.slice((i).toInt, (i + BigInt(1)).toInt) == ch) {
        return i
      }
      i = i + BigInt(1)
    }
    return BigInt(0) - BigInt(1)
  }
  
  val PI: Double = 3.141592653589793
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
