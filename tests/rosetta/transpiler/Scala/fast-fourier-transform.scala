// Generated by Mochi v0.10.52 on 2025-08-02 02:08:24 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Complex(var re: Double, var im: Double)

def sinApprox(x: Double): Double = {
  var term: Double = x
  var sum: Double = x
  var n: BigInt = BigInt(1)
  while (n <= BigInt(10)) {
    val denom: Double = (BigInt(2) * n * (BigInt(2) * n + BigInt(1))).toString.toDouble
    term = (-term * x * x / denom).toString.toDouble
    sum = (sum + term).toString.toDouble
    n = n + BigInt(1)
  }
  return sum
}

def cosApprox(x: Double): Double = {
  var term: Double = 1.0
  var sum: Double = 1.0
  var n: BigInt = BigInt(1)
  while (n <= BigInt(10)) {
    val denom: Double = ((BigInt(2) * n - BigInt(1)) * (BigInt(2) * n)).toString.toDouble
    term = (-term * x * x / denom).toString.toDouble
    sum = (sum + term).toString.toDouble
    n = n + BigInt(1)
  }
  return sum
}

def cis(x: Double): Complex = {
  return Complex(cosApprox(x), sinApprox(x))
}

def add(a: Complex, b: Complex): Complex = {
  return Complex(a.re + b.re, a.im + b.im)
}

def sub(a: Complex, b: Complex): Complex = {
  return Complex(a.re - b.re, a.im - b.im)
}

def mul(a: Complex, b: Complex): Complex = {
  return Complex((a.re * b.re).toString.toDouble - (a.im * b.im).toString.toDouble, (a.re * b.im).toString.toDouble + (a.im * b.re).toString.toDouble)
}

def ditfft2Rec(x: ArrayBuffer[Double], y: ArrayBuffer[Complex], offX: BigInt, offY: BigInt, n: BigInt, s: BigInt): Any = {
  if (n == BigInt(1)) {
    y((offY).toInt) = Complex(x((offX).toInt), 0.0)
    return
  }
  ditfft2Rec(x, y, offX, offY, n / BigInt(2), BigInt(2) * s)
  ditfft2Rec(x, y, offX + s, offY + n / BigInt(2), n / BigInt(2), BigInt(2) * s)
  var k: BigInt = BigInt(0)
  while (k < n / BigInt(2)) {
    val angle: Double = -2.0 * PI * k.toString.toDouble / n.toString.toDouble
    val tf: Complex = mul(cis(angle), y((offY + k + n / BigInt(2)).toInt))
    val a: Complex = add(y((offY + k).toInt), tf)
    val b: Complex = sub(y((offY + k).toInt), tf)
    y((offY.toString.toDouble + k.toString.toDouble).toInt) = a
    y((offY.toString.toDouble + k.toString.toDouble + (n / BigInt(2)).toString.toDouble).toInt) = b
    k = k + BigInt(1)
  }
  return null
}

def ditfft2(x: ArrayBuffer[Double], y: ArrayBuffer[Complex], n: BigInt, s: BigInt): Any = {
  ditfft2Rec(x, y, BigInt(0), BigInt(0), n, s)
}

def main(): Any = {
  val x: ArrayBuffer[Double] = ArrayBuffer(1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0)
  var y: ArrayBuffer[Complex] = ArrayBuffer()
  var i: BigInt = BigInt(0)
  while (i < (x).size) {
    y = y :+ Complex(0.0, 0.0)
    i = i + BigInt(1)
  }
  ditfft2(x, y, BigInt(((x).size).toInt), BigInt(1))
  for (c <- y) {
    var line: String = pad(fmt((c.re).toString.toDouble), BigInt(8))
    if (c.im >= BigInt(0)) {
      line = line + "+" + fmt((c.im).toString.toDouble)
    } else {
      line = (line + fmt((c.im).toString.toDouble)).toString
    }
    println(line)
  }
}

def pad(s: String, w: BigInt): String = {
  var t: String = s
  while ((t).size < w) {
    t = " " + t
  }
  return t
}

def fmt(x: Double): String = {
  var y: Double = floorf(x * 10000.0 + 0.5) / 10000.0
  var s: String = String.valueOf(y)
  var dot: BigInt = BigInt(s.indexOf("."))
  if (dot == BigInt(0) - BigInt(1)) {
    s = s + ".0000"
  } else {
    var d: BigInt = (s).size - dot - BigInt(1)
    while (d < BigInt(4)) {
      s = s + "0"
      d = d + BigInt(1)
    }
  }
  return s
}

def floorf(x: Double): Double = {
  var y: Int = x.toInt
  return y.toString.toDouble
}

def indexOf(s: String, ch: String): BigInt = {
  var i: BigInt = BigInt(0)
  while (i < (s).size) {
    if (s.slice((i).toInt, (i + BigInt(1)).toInt) == ch) {
      return i
    }
    i = i + BigInt(1)
  }
  return BigInt(0) - BigInt(1)
}

val PI: Double = 3.141592653589793

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
