// Generated by Mochi v0.10.40 on 2025-07-25 12:53:56 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  def pow10(exp: Int): Int = {
    var n: Int = 1
    var i: Int = 0
    while (i < exp) {
      n = (n * 10).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    return n
  }
  
  def totient(n: Int): Int = {
    var tot: Int = n
    var nn: Int = n
    var i: Int = 2
    while ((i * i).asInstanceOf[Int] <= nn) {
      if (Math.floorMod(nn, i) == 0) {
        while (Math.floorMod(nn, i) == 0) {
          nn = (nn / i).asInstanceOf[Int]
        }
        tot = (tot - tot / i).asInstanceOf[Int]
      }
      if (i == 2) {
        i = 1
      }
      i = (i + 2).asInstanceOf[Int]
    }
    if (nn > 1) {
      tot = (tot - tot / nn).asInstanceOf[Int]
    }
    return tot
  }
  
  def getPerfectPowers(maxExp: Int): Unit = {
    val upper: Int = pow10(maxExp)
    var i: Int = 2
    val _br3 = new Breaks
    _br3.breakable {
      while ((i * i).asInstanceOf[Int] < upper) {
        var p: Int = i
        val _br4 = new Breaks
        _br4.breakable {
          while (true) {
            p = (p * i).asInstanceOf[Int]
            if (p >= upper) {
              _br4.break()
            }
            pps(p) = true
          }
        }
        i = (i + 1).asInstanceOf[Int]
      }
    }
  }
  
  def getAchilles(minExp: Int, maxExp: Int): Map[Int,Boolean] = {
    val lower: Int = pow10(minExp)
    val upper: Int = pow10(maxExp)
    var achilles: Map[Int,Boolean] = Map()
    var b: Int = 1
    val _br5 = new Breaks
    _br5.breakable {
      while ((b * b * b).asInstanceOf[Int] < upper) {
        val b3 = b * b * b
        var a: Int = 1
        val _br6 = new Breaks
        _br6.breakable {
          while (true) {
            val p = b3 * a * a
            if (p >= upper) {
              _br6.break()
            }
            if (p >= lower) {
              if ((!(pps.contains(p)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
                achilles(p) = true
              }
            }
            a = (a + 1).asInstanceOf[Int]
          }
        }
        b = (b + 1).asInstanceOf[Int]
      }
    }
    return achilles
  }
  
  def sortInts(xs: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var tmp: ArrayBuffer[Int] = xs
    while ((tmp).size > 0) {
      var min: Int = tmp(0)
      var idx: Int = 0
      var i: Int = 1
      while (i < (tmp).size) {
        if (tmp(i) < min) {
          min = tmp(i)
          idx = i
        }
        i = (i + 1).asInstanceOf[Int]
      }
      res = (res ++ ArrayBuffer(min)).asInstanceOf[ArrayBuffer[Int]]
      var out: ArrayBuffer[Int] = ArrayBuffer()
      var j: Int = 0
      while (j < (tmp).size) {
        if (j != idx) {
          out = (out ++ ArrayBuffer(tmp(j))).asInstanceOf[ArrayBuffer[Int]]
        }
        j = (j + 1).asInstanceOf[Int]
      }
      tmp = out
    }
    return res
  }
  
  def pad(n: Int, width: Int): String = {
    var s = String.valueOf(n)
    while ((s).size < width) {
      s = " " + s
    }
    return s
  }
  
  def main(): Unit = {
    val maxDigits: Int = 15
    getPerfectPowers(5)
    val achSet: Map[Int,Boolean] = getAchilles(1, 5)
    var ach: ArrayBuffer[Int] = ArrayBuffer()
    for (k <- achSet.keys()) {
      ach = (ach ++ ArrayBuffer(k)).asInstanceOf[ArrayBuffer[Int]]
    }
    ach = sortInts(ach)
    println("First 50 Achilles numbers:")
    var i: Int = 0
    while (i < 50) {
      var line: String = ""
      var j: Int = 0
      while (j < 10) {
        line = (line + pad(ach(i), 4)).asInstanceOf[String]
        if (j < 9) {
          line = line + " "
        }
        i = (i + 1).asInstanceOf[Int]
        j = (j + 1).asInstanceOf[Int]
      }
      println(line)
    }
    println("\nFirst 30 strong Achilles numbers:")
    var strong: ArrayBuffer[Int] = ArrayBuffer()
    var count: Int = 0
    var idx: Int = 0
    while (count < 30) {
      val tot: Int = totient(ach(idx))
      if ((achSet.contains(tot)).asInstanceOf[Boolean]) {
        strong = (strong ++ ArrayBuffer(ach(idx))).asInstanceOf[ArrayBuffer[Int]]
        count = (count + 1).asInstanceOf[Int]
      }
      idx = (idx + 1).asInstanceOf[Int]
    }
    i = 0
    while (i < 30) {
      var line: String = ""
      var j: Int = 0
      while (j < 10) {
        line = (line + pad(strong(i), 5)).asInstanceOf[String]
        if (j < 9) {
          line = line + " "
        }
        i = (i + 1).asInstanceOf[Int]
        j = (j + 1).asInstanceOf[Int]
      }
      println(line)
    }
    println("\nNumber of Achilles numbers with:")
    val counts: ArrayBuffer[Int] = ArrayBuffer(1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383)
    var d: Int = 2
    while (d <= maxDigits) {
      val c: Int = counts(d - 2)
      println(pad(d, 2) + " digits: " + String.valueOf(c))
      d = (d + 1).asInstanceOf[Int]
    }
  }
  
  var pps: Map[Int,Boolean] = Map()
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
