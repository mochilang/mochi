// Generated by Mochi v0.10.40 on 2025-07-25 13:16:23 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    def pow10(exp: Int): Int = {
      var n: Int = 1
      var i: Int = 0
      while (i < exp) {
        n = (n * 10).asInstanceOf[Int]
        i = (i + 1).asInstanceOf[Int]
      }
      return n
    }
    def totient(n: Int): Int = {
      var tot: Int = n
      var nn: Int = n
      var i: Int = 2
      while ((i * i).asInstanceOf[Int] <= nn) {
        if (Math.floorMod(nn, i) == 0) {
          while (Math.floorMod(nn, i) == 0) {
            nn = (nn / i).asInstanceOf[Int]
          }
          tot = (tot - tot / i).asInstanceOf[Int]
        }
        if (i == 2) {
          i = 1
        }
        i = (i + 2).asInstanceOf[Int]
      }
      if (nn > 1) {
        tot = (tot - tot / nn).asInstanceOf[Int]
      }
      return tot
    }
    var pps: Map[Int,Boolean] = Map()
    def getPerfectPowers(maxExp: Int): Unit = {
      val upper: Int = pow10(maxExp)
      var i: Int = 2
      val _br3 = new Breaks
      _br3.breakable {
        while ((i * i).asInstanceOf[Int] < upper) {
          var p: Int = i
          val _br4 = new Breaks
          _br4.breakable {
            while (true) {
              p = (p * i).asInstanceOf[Int]
              if (p >= upper) {
                _br4.break()
              }
              pps(p) = true
            }
          }
          i = (i + 1).asInstanceOf[Int]
        }
      }
    }
    def getAchilles(minExp: Int, maxExp: Int): Map[Int,Boolean] = {
      val lower: Int = pow10(minExp)
      val upper: Int = pow10(maxExp)
      var achilles: Map[Int,Boolean] = Map()
      var b: Int = 1
      val _br5 = new Breaks
      _br5.breakable {
        while ((b * b * b).asInstanceOf[Int] < upper) {
          val b3 = b * b * b
          var a: Int = 1
          val _br6 = new Breaks
          _br6.breakable {
            while (true) {
              val p = b3 * a * a
              if (p >= upper) {
                _br6.break()
              }
              if (p >= lower) {
                if ((!(pps.contains(p)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
                  achilles(p) = true
                }
              }
              a = (a + 1).asInstanceOf[Int]
            }
          }
          b = (b + 1).asInstanceOf[Int]
        }
      }
      return achilles
    }
    def sortInts(xs: ArrayBuffer[Int]): ArrayBuffer[Int] = {
      var res: ArrayBuffer[Int] = ArrayBuffer()
      var tmp: ArrayBuffer[Int] = xs
      while ((tmp).size > 0) {
        var min: Int = tmp(0)
        var idx: Int = 0
        var i: Int = 1
        while (i < (tmp).size) {
          if (tmp(i) < min) {
            min = tmp(i)
            idx = i
          }
          i = (i + 1).asInstanceOf[Int]
        }
        res = (res ++ ArrayBuffer(min)).asInstanceOf[ArrayBuffer[Int]]
        var out: ArrayBuffer[Int] = ArrayBuffer()
        var j: Int = 0
        while (j < (tmp).size) {
          if (j != idx) {
            out = (out ++ ArrayBuffer(tmp(j))).asInstanceOf[ArrayBuffer[Int]]
          }
          j = (j + 1).asInstanceOf[Int]
        }
        tmp = out
      }
      return res
    }
    def pad(n: Int, width: Int): String = {
      var s = String.valueOf(n)
      while ((s).size < width) {
        s = " " + s
      }
      return s
    }
    def main(): Unit = {
      val maxDigits: Int = 15
      getPerfectPowers(5)
      val achSet: Map[Int,Boolean] = getAchilles(1, 5)
      var ach: ArrayBuffer[Int] = ArrayBuffer()
      for (k <- achSet.keys) {
        ach = (ach ++ ArrayBuffer(k)).asInstanceOf[ArrayBuffer[Int]]
      }
      ach = sortInts(ach)
      println("First 50 Achilles numbers:")
      var i: Int = 0
      while (i < 50) {
        var line: String = ""
        var j: Int = 0
        while (j < 10) {
          line = (line + pad(ach(i), 4)).asInstanceOf[String]
          if (j < 9) {
            line = line + " "
          }
          i = (i + 1).asInstanceOf[Int]
          j = (j + 1).asInstanceOf[Int]
        }
        println(line)
      }
      println("\nFirst 30 strong Achilles numbers:")
      var strong: ArrayBuffer[Int] = ArrayBuffer()
      var count: Int = 0
      var idx: Int = 0
      while (count < 30) {
        val tot: Int = totient(ach(idx))
        if ((achSet.contains(tot)).asInstanceOf[Boolean]) {
          strong = (strong ++ ArrayBuffer(ach(idx))).asInstanceOf[ArrayBuffer[Int]]
          count = (count + 1).asInstanceOf[Int]
        }
        idx = (idx + 1).asInstanceOf[Int]
      }
      i = 0
      while (i < 30) {
        var line: String = ""
        var j: Int = 0
        while (j < 10) {
          line = (line + pad(strong(i), 5)).asInstanceOf[String]
          if (j < 9) {
            line = line + " "
          }
          i = (i + 1).asInstanceOf[Int]
          j = (j + 1).asInstanceOf[Int]
        }
        println(line)
      }
      println("\nNumber of Achilles numbers with:")
      val counts: ArrayBuffer[Int] = ArrayBuffer(1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383)
      var d: Int = 2
      while (d <= maxDigits) {
        val c: Int = counts(d - 2)
        println(pad(d, 2) + " digits: " + String.valueOf(c))
        d = (d + 1).asInstanceOf[Int]
      }
    }
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
