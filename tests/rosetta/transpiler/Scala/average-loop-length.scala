// Generated by Mochi v0.10.39 on 2025-07-25 01:20:19 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def absf(x: Double): Double = {
    if (x < 0.0) {
      return (0 - x).asInstanceOf[Double]
    }
    return x
  }
  
  def floorf(x: Double): Double = {
    val y: Int = x.asInstanceOf[Int]
    return y.toString.toDouble
  }
  
  def indexOf(s: String, ch: String): Int = {
    var i: Int = 0
    while (i < (s).size) {
      if (s.substring(i, i + 1) == ch) {
        return i
      }
      i = (i + 1).asInstanceOf[Int]
    }
    return 0 - 1
  }
  
  def fmtF(x: Double): String = {
    var y: Double = floorf(x * 10000.0 + 0.5) / 10000.0
    var s = String.valueOf(y)
    var dot: Int = indexOf(s, ".")
    if (dot == 0 - 1) {
      s = s + ".0000"
    } else {
      var decs = (s).size - dot - 1
      if (decs > 4) {
        s = s.substring(0, dot + 5)
      } else {
        while (decs < 4) {
          s = s + "0"
          decs = (decs + 1).asInstanceOf[Int]
        }
      }
    }
    return s
  }
  
  def padInt(n: Int, width: Int): String = {
    var s = String.valueOf(n)
    while ((s).size < width) {
      s = " " + s
    }
    return s
  }
  
  def padFloat(x: Double, width: Int): String = {
    var s: String = fmtF(x)
    while ((s).size < width) {
      s = " " + s
    }
    return s
  }
  
  def avgLen(n: Int): Double = {
    val tests: Int = 10000
    var sum: Int = 0
    var seed: Int = 1
    var t: Int = 0
    while (t < tests) {
      var visited: ArrayBuffer[Boolean] = ArrayBuffer()
      var i: Int = 0
      while (i < n) {
        visited = visited :+ false
        i = (i + 1).asInstanceOf[Int]
      }
      var x: Int = 0
      while (!visited(x)) {
        visited(x) = true
        sum = (sum + 1).asInstanceOf[Int]
        seed = ((seed * 1664525 + 1013904223) % 2147483647).asInstanceOf[Int]
        x = (Math.floorMod(seed, n)).asInstanceOf[Int]
      }
      t = (t + 1).asInstanceOf[Int]
    }
    return sum.toString.toDouble / tests
  }
  
  def ana(n: Int): Double = {
    var nn: Double = n.toString.toDouble
    var term: Double = 1.0
    var sum: Double = 1.0
    var i: Double = nn - 1.0
    while (i >= 1.0) {
      term = (term * i / nn).asInstanceOf[Double]
      sum = (sum + term).asInstanceOf[Double]
      i = i - 1.0
    }
    return sum
  }
  
  def main() = {
    val nmax: Int = 20
    println(" N    average    analytical    (error)")
    println("===  =========  ============  =========")
    var n: Int = 1
    while (n <= nmax) {
      val a: Double = avgLen(n)
      val b: Double = ana(n)
      val err: Double = absf((a - b).asInstanceOf[Double]) / b * 100.0
      var line: String = padInt(n, 3) + "  " + padFloat(a, 9) + "  " + padFloat(b, 12) + "  (" + padFloat(err, 6) + "%)"
      println(line)
      n = (n + 1).asInstanceOf[Int]
    }
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
