// Generated by Mochi v0.10.55 on 2025-08-02 17:35:07 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  def primeFactors(n: BigInt): ArrayBuffer[BigInt] = {
    var factors: ArrayBuffer[BigInt] = ArrayBuffer()
    var x: BigInt = n
    while (x % BigInt(2) == BigInt(0)) {
      factors = factors :+ BigInt(2)
      x = x / BigInt(2)
    }
    var p: BigInt = BigInt(3)
    while (p * p <= x) {
      while (x % p == BigInt(0)) {
        factors = factors :+ p
        x = BigInt((x / p).toString)
      }
      p = p + BigInt(2)
    }
    if (x > BigInt(1)) {
      factors = factors :+ x
    }
    return factors
  }
  
  def commatize(n: BigInt): String = {
    var s: String = String.valueOf(n)
    var out: String = ""
    var i: BigInt = (s).size - BigInt(1).toInt
    var c: BigInt = BigInt(0)
    while (i >= BigInt(0)) {
      out = s.slice((i).toInt, (i + BigInt(1)).toInt) + out
      c = c + BigInt(1)
      if ((c % BigInt(3) == BigInt(0) && i > BigInt(0)).asInstanceOf[Boolean]) {
        out = "," + out
      }
      i = i - BigInt(1)
    }
    return out
  }
  
  def indexOf(s: String, sub: String): BigInt = {
    var i: BigInt = BigInt(0)
    while (i + (sub).size <= (s).size) {
      if (s.slice((i).toInt, (i + (sub).size).toInt) == sub) {
        return i
      }
      i = i + BigInt(1)
    }
    return BigInt(0) - BigInt(1)
  }
  
  def pad10(s: String): String = {
    var str: String = s
    while ((str).size < BigInt(10)) {
      str = " " + str
    }
    return str
  }
  
  def trimRightStr(s: String): String = {
    var end: Int = (s).size
    while (end > BigInt(0) && s.slice((end - BigInt(1).toInt).toInt, (end).toInt) == " ") {
      end = end - BigInt(1).toInt.toInt
    }
    return s.slice((BigInt(0)).toInt, (end).toInt)
  }
  
  def main(): Any = {
    var res: ArrayBuffer[BigInt] = ArrayBuffer()
    var count: BigInt = BigInt(0)
    var k: BigInt = BigInt(11) * BigInt(11)
    val _br7 = new Breaks
    val _ct7 = new Breaks
    _br7.breakable {
      while (count < BigInt(20)) {
        _ct7.breakable {
          if (((k % BigInt(3) == BigInt(0) || k % BigInt(5) == BigInt(0)).asInstanceOf[Boolean] || k % BigInt(7) == BigInt(0)).asInstanceOf[Boolean]) {
            k = k + BigInt(2)
            _ct7.break()
          }
          val factors: ArrayBuffer[BigInt] = primeFactors(k)
          if ((factors).size > BigInt(1)) {
            val s: String = String.valueOf(k)
            var includesAll: Boolean = true
            var prev: BigInt = BigInt(0) - BigInt(1)
            val _br8 = new Breaks
            val _ct8 = new Breaks
            _br8.breakable {
              for (f <- factors) {
                _ct8.breakable {
                  if (f == prev) {
                    _ct8.break()
                  }
                  val fs: String = String.valueOf(f)
                  if (BigInt(s.indexOf(fs)) == BigInt(0) - BigInt(1)) {
                    includesAll = false
                    _br8.break()
                  }
                  prev = f
                }
              }
            }
            if (includesAll) {
              res = res :+ k
              count = count + BigInt(1)
            }
          }
          k = k + BigInt(2)
        }
      }
    }
    var line: String = ""
    for (e <- res.slice((BigInt(0)).toInt, (BigInt(10)).toInt)) {
      line = line + pad10(commatize(e)) + " "
    }
    println(trimRightStr(line))
    line = ""
    for (e <- res.slice((BigInt(10)).toInt, (BigInt(20)).toInt)) {
      line = line + pad10(commatize(e)) + " "
    }
    println(trimRightStr(line))
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
