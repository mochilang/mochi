// Generated by Mochi v0.10.39 on 2025-07-25 01:23:24 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def Node(data: Int): Map[String,Any] = {
    return Map("Data" -> (data), "Balance" -> (0), "Link" -> (ArrayBuffer(null, null)))
  }
  
  def getLink(n: Map[String,Any], dir: Int): Any = {
    return (n.getOrElse("Link", null.asInstanceOf[Any])).asInstanceOf[ArrayBuffer[Any]](dir)
  }
  
  def setLink(n: Map[String,Any], dir: Int, v: Any): Unit = {
    var links: ArrayBuffer[Any] = (n.getOrElse("Link", null.asInstanceOf[Any])).asInstanceOf[ArrayBuffer[Any]]
    links(dir) = v
    n("Link") = links
  }
  
  def opp(dir: Int): Int = {
    return (1 - dir).asInstanceOf[Int]
  }
  
  def single(root: Map[String,Any], dir: Int): Map[String,Any] = {
    var tmp = getLink(root, opp(dir))
    setLink(root, opp(dir), getLink(tmp.asInstanceOf[Map[String,Any]], dir))
    setLink(tmp.asInstanceOf[Map[String,Any]], dir, root)
    return tmp.asInstanceOf[Map[String,Any]]
  }
  
  def double(root: Map[String,Any], dir: Int): Map[String,Any] = {
    var tmp = getLink((getLink(root, opp(dir))).asInstanceOf[Map[String,Any]], dir)
    setLink((getLink(root, opp(dir))).asInstanceOf[Map[String,Any]], dir, getLink(tmp.asInstanceOf[Map[String,Any]], opp(dir)))
    setLink(tmp.asInstanceOf[Map[String,Any]], opp(dir), getLink(root, opp(dir)))
    setLink(root, opp(dir), tmp)
    tmp = getLink(root, opp(dir))
    setLink(root, opp(dir), getLink(tmp.asInstanceOf[Map[String,Any]], dir))
    setLink(tmp.asInstanceOf[Map[String,Any]], dir, root)
    return tmp.asInstanceOf[Map[String,Any]]
  }
  
  def adjustBalance(root: Map[String,Any], dir: Int, bal: Int): Unit = {
    var n: Map[String,Any] = (getLink(root, dir)).asInstanceOf[Map[String,Any]]
    var nn: Map[String,Any] = (getLink(n, opp(dir))).asInstanceOf[Map[String,Any]]
    if (nn.getOrElse("Balance", null.asInstanceOf[Any]) == 0) {
      root("Balance") = 0
      n("Balance") = 0
    } else {
      if (nn.getOrElse("Balance", null.asInstanceOf[Any]) == bal) {
        root("Balance") = 0 - bal
        n("Balance") = 0
      } else {
        root("Balance") = 0
        n("Balance") = bal
      }
    }
    nn("Balance") = 0
  }
  
  def insertBalance(root: Map[String,Any], dir: Int): Map[String,Any] = {
    var n: Map[String,Any] = (getLink(root, dir)).asInstanceOf[Map[String,Any]]
    var bal = 2 * dir - 1
    if (n.getOrElse("Balance", null.asInstanceOf[Any]) == bal) {
      root("Balance") = 0
      n("Balance") = 0
      return single(root, opp(dir))
    }
    adjustBalance(root, dir, bal)
    return double(root, opp(dir))
  }
  
  def insertR(root: Any, data: Int): Map[String,Any] = {
    if (root == null) {
      return Map("node" -> (Node(data)), "done" -> (false))
    }
    var node: Map[String,Any] = root.asInstanceOf[Map[String,Any]]
    var dir: Int = 0
    if ((node.getOrElse("Data", null.asInstanceOf[Any])).asInstanceOf[Int] < data) {
      dir = 1
    }
    var r: Map[String,Any] = insertR(getLink(node, dir), data)
    setLink(node, dir, r.getOrElse("node", null.asInstanceOf[Any]))
    if ((r.getOrElse("done", null.asInstanceOf[Any])).asInstanceOf[Boolean]) {
      return Map("node" -> (node), "done" -> (true))
    }
    node("Balance") = (node.getOrElse("Balance", null.asInstanceOf[Any])).asInstanceOf[Int] + 2 * dir - 1
    if (node.getOrElse("Balance", null.asInstanceOf[Any]) == 0) {
      return Map("node" -> (node), "done" -> (true))
    }
    if ((node.getOrElse("Balance", null.asInstanceOf[Any]) == 1 || node.getOrElse("Balance", null.asInstanceOf[Any]) == 0 - 1).asInstanceOf[Boolean]) {
      return Map("node" -> (node), "done" -> (false))
    }
    return Map("node" -> (insertBalance(node, dir)), "done" -> (true))
  }
  
  def Insert(tree: Any, data: Int): Any = {
    val r: Map[String,Any] = insertR(tree, data)
    return r.getOrElse("node", null.asInstanceOf[Any])
  }
  
  def removeBalance(root: Map[String,Any], dir: Int): Map[String,Any] = {
    var n: Map[String,Any] = (getLink(root, opp(dir))).asInstanceOf[Map[String,Any]]
    var bal = 2 * dir - 1
    if (n.getOrElse("Balance", null.asInstanceOf[Any]) == 0 - bal) {
      root("Balance") = 0
      n("Balance") = 0
      return Map("node" -> (single(root, dir)), "done" -> (false))
    }
    if (n.getOrElse("Balance", null.asInstanceOf[Any]) == bal) {
      adjustBalance(root, opp(dir), (0 - bal).asInstanceOf[Int])
      return Map("node" -> (double(root, dir)), "done" -> (false))
    }
    root("Balance") = 0 - bal
    n("Balance") = bal
    return Map("node" -> (single(root, dir)), "done" -> (true))
  }
  
  def removeR(root: Any, _data: Int): Map[String,Any] = {
    var data: Int = _data
    if (root == null) {
      return Map("node" -> (null), "done" -> (false))
    }
    var node: Map[String,Any] = root.asInstanceOf[Map[String,Any]]
    if ((node.getOrElse("Data", null.asInstanceOf[Any])).asInstanceOf[Int] == data) {
      if (getLink(node, 0) == null) {
        return Map("node" -> (getLink(node, 1)), "done" -> (false))
      }
      if (getLink(node, 1) == null) {
        return Map("node" -> (getLink(node, 0)), "done" -> (false))
      }
      var heir = getLink(node, 0)
      while (getLink(heir.asInstanceOf[Map[String,Any]], 1) != null) {
        heir = getLink(heir.asInstanceOf[Map[String,Any]], 1)
      }
      node("Data") = heir.asInstanceOf[Map[String,Any]]("Data")
      data = (heir.asInstanceOf[Map[String,Any]]("Data")).asInstanceOf[Int]
    }
    var dir: Int = 0
    if ((node.getOrElse("Data", null.asInstanceOf[Any])).asInstanceOf[Int] < data) {
      dir = 1
    }
    var r: Map[String,Any] = removeR(getLink(node, dir), data)
    setLink(node, dir, r.getOrElse("node", null.asInstanceOf[Any]))
    if ((r.getOrElse("done", null.asInstanceOf[Any])).asInstanceOf[Boolean]) {
      return Map("node" -> (node), "done" -> (true))
    }
    node("Balance") = (node.getOrElse("Balance", null.asInstanceOf[Any])).asInstanceOf[Int] + 1 - 2 * dir
    if ((node.getOrElse("Balance", null.asInstanceOf[Any]) == 1 || node.getOrElse("Balance", null.asInstanceOf[Any]) == 0 - 1).asInstanceOf[Boolean]) {
      return Map("node" -> (node), "done" -> (true))
    }
    if (node.getOrElse("Balance", null.asInstanceOf[Any]) == 0) {
      return Map("node" -> (node), "done" -> (false))
    }
    return removeBalance(node, dir)
  }
  
  def Remove(tree: Any, data: Int): Any = {
    val r: Map[String,Any] = removeR(tree, data)
    return r.getOrElse("node", null.asInstanceOf[Any])
  }
  
  def indentStr(n: Int): String = {
    var s: String = ""
    var i: Int = 0
    while (i < n) {
      s = s + " "
      i = (i + 1).asInstanceOf[Int]
    }
    return s
  }
  
  def dumpNode(node: Any, indent: Int, comma: Boolean): Unit = {
    val sp: String = indentStr(indent)
    if (node == null) {
      var line: String = sp + "null"
      if (comma) {
        line = line + ","
      }
      println(line)
    } else {
      println(sp + "{")
      println(indentStr((indent + 3).asInstanceOf[Int]) + "\"Data\": " + String.valueOf(node.asInstanceOf[Map[String,Any]]("Data")) + ",")
      println(indentStr((indent + 3).asInstanceOf[Int]) + "\"Balance\": " + String.valueOf(node.asInstanceOf[Map[String,Any]]("Balance")) + ",")
      println(indentStr((indent + 3).asInstanceOf[Int]) + "\"Link\": [")
      dumpNode(getLink(node.asInstanceOf[Map[String,Any]], 0), (indent + 6).asInstanceOf[Int], true)
      dumpNode(getLink(node.asInstanceOf[Map[String,Any]], 1), (indent + 6).asInstanceOf[Int], false)
      println(indentStr((indent + 3).asInstanceOf[Int]) + "]")
      var end: String = sp + "}"
      if (comma) {
        end = end + ","
      }
      println(end)
    }
  }
  
  def dump(node: Any, indent: Int): Unit = {
    dumpNode(node, indent, false)
  }
  
  def main(): Unit = {
    var tree: Any = null
    println("Empty tree:")
    dump(tree, 0)
    println("")
    println("Insert test:")
    tree = Insert(tree, 3)
    tree = Insert(tree, 1)
    tree = Insert(tree, 4)
    tree = Insert(tree, 1)
    tree = Insert(tree, 5)
    dump(tree, 0)
    println("")
    println("Remove test:")
    tree = Remove(tree, 3)
    tree = Remove(tree, 1)
    var t: Map[String,Any] = tree.asInstanceOf[Map[String,Any]]
    t("Balance") = 0
    tree = t
    dump(tree, 0)
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
