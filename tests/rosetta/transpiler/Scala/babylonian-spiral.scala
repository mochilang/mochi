// Generated by Mochi v0.10.40 on 2025-07-25 20:16:38 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def push(_h: ArrayBuffer[Map[String,Int]], it: Map[String,Int]): ArrayBuffer[Map[String,Int]] = {
    var h: ArrayBuffer[Map[String,Int]] = _h
    h = h :+ it
    var i: Int = (h).size - 1
    while (i > 0 && h(i - 1).getOrElse("s", null.asInstanceOf[Int]) > h(i).getOrElse("s", null.asInstanceOf[Int])) {
      val tmp: Map[String,Int] = h(i - 1)
      h(i - 1) = h(i)
      h(i) = tmp
      i = (i - 1).asInstanceOf[Int]
    }
    return h
  }
  
  def step(_h: ArrayBuffer[Map[String,Int]], _nv: Int, dir: ArrayBuffer[Int]): Map[String,Any] = {
    var h: ArrayBuffer[Map[String,Int]] = _h
    var nv: Int = _nv
    while ((h).size == 0 || (nv * nv).asInstanceOf[Int] <= h(0).getOrElse("s", null.asInstanceOf[Int])) {
      h = push(h, (Map("s" -> (nv * nv), "a" -> (nv), "b" -> (0))).asInstanceOf[Map[String,Int]])
      nv = (nv + 1).asInstanceOf[Int]
    }
    val s: Int = h(0).getOrElse("s", null.asInstanceOf[Int])
    var v: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
    while ((h).size > 0 && h(0).getOrElse("s", null.asInstanceOf[Int]) == s) {
      val it: Map[String,Int] = h(0)
      h = h.slice(1, (h).size)
      v = v :+ ArrayBuffer(it.getOrElse("a", null.asInstanceOf[Int]), it.getOrElse("b", null.asInstanceOf[Int]))
      if (it.getOrElse("a", null.asInstanceOf[Int]) > it.getOrElse("b", null.asInstanceOf[Int])) {
        h = push(h, (Map("s" -> (it.getOrElse("a", null.asInstanceOf[Int]) * it.getOrElse("a", null.asInstanceOf[Int]) + (it.getOrElse("b", null.asInstanceOf[Int]) + 1) * (it.getOrElse("b", null.asInstanceOf[Int]) + 1)), "a" -> (it.getOrElse("a", null.asInstanceOf[Int])), "b" -> (it.getOrElse("b", null.asInstanceOf[Int]) + 1))).asInstanceOf[Map[String,Int]])
      }
    }
    var list: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
    for (p <- v) {
      list = list :+ p
    }
    var temp: ArrayBuffer[ArrayBuffer[Int]] = list
    for (p <- temp) {
      if (p(0) != p(1)) {
        list = list :+ ArrayBuffer(p(1), p(0))
      }
    }
    temp = list
    for (p <- temp) {
      if (p(1) != 0) {
        list = list :+ ArrayBuffer(p(0), 0 - p(1))
      }
    }
    temp = list
    for (p <- temp) {
      if (p(0) != 0) {
        list = list :+ ArrayBuffer(0 - p(0), p(1))
      }
    }
    var bestDot: Int = 0 - 999999999
    var best: ArrayBuffer[Int] = dir
    for (p <- list) {
      val cross: Int = p(0) * dir(1) - p(1) * dir(0)
      if (cross >= 0) {
        val dot: Int = p(0) * dir(0) + p(1) * dir(1)
        if (dot > bestDot) {
          bestDot = dot
          best = p.asInstanceOf[ArrayBuffer[Int]]
        }
      }
    }
    return Map("d" -> (best), "heap" -> (h), "n" -> (nv))
  }
  
  def positions(n: Int): ArrayBuffer[ArrayBuffer[Int]] = {
    var pos: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
    var x: Int = 0
    var y: Int = 0
    var dir: ArrayBuffer[Int] = ArrayBuffer(0, 1)
    var heap: ArrayBuffer[Map[String,Int]] = ArrayBuffer()
    var nv: Int = 1
    var i: Int = 0
    while (i < n) {
      pos = pos :+ ArrayBuffer(x, y)
      val st: Map[String,Any] = step(heap, nv, dir)
      dir = (st.getOrElse("d", null.asInstanceOf[Any])).asInstanceOf[ArrayBuffer[Int]]
      heap = (st.getOrElse("heap", null.asInstanceOf[Any])).asInstanceOf[ArrayBuffer[Map[String,Int]]]
      nv = (st.getOrElse("n", null.asInstanceOf[Any])).asInstanceOf[Int]
      x = (x + dir(0)).asInstanceOf[Int]
      y = (y + dir(1)).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    return pos
  }
  
  def pad(s: String, w: Int): String = {
    var r: String = s
    while ((r).size < w) {
      r = r + " "
    }
    return r
  }
  
  def main(): Any = {
    val pts: ArrayBuffer[ArrayBuffer[Int]] = positions(40)
    println("The first 40 Babylonian spiral points are:")
    var line: String = ""
    var i: Int = 0
    while (i < (pts).size) {
      val p: ArrayBuffer[Int] = pts(i)
      val s: String = pad("(" + String.valueOf(p(0)) + ", " + String.valueOf(p(1)) + ")", 10)
      line = (line + s).asInstanceOf[String]
      if (Math.floorMod(i + 1, 10) == 0) {
        println(line)
        line = ""
      }
      i = (i + 1).asInstanceOf[Int]
    }
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
