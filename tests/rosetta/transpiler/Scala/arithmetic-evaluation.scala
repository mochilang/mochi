// Generated by Mochi v0.10.39 on 2025-07-25 00:49:32 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  case class Parser(var expr: String, var pos: Int)
  
  case class Res(var v: Int, var p: Parser)
  
  def skipWS(p: Parser): Parser = {
    var i: Int = p.pos
    while (i < (p.expr).size && p.expr.substring(i, i + 1) == " ") {
      i = (i + 1).asInstanceOf[Int]
    }
    p.pos = i
    return p
  }
  
  def parseIntStr(str: String): Int = {
    var i: Int = 0
    var n: Int = 0
    while (i < (str).size) {
      n = (n * 10 + (str.slice(i, i + 1)).asInstanceOf[Int] - 48).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    return n
  }
  
  def parseNumber(_p: Parser): Res = {
    var p: Parser = _p
    p = skipWS(p)
    var start: Int = p.pos
    val _br2 = new Breaks
    _br2.breakable {
      while (p.pos < (p.expr).size) {
        val ch: String = p.expr.substring(p.pos, p.pos + 1)
        if ((ch >= "0" && ch <= "9").asInstanceOf[Boolean]) {
          p.pos = (p.pos + 1).asInstanceOf[Int]
        } else {
          _br2.break()
        }
      }
    }
    val token: String = p.expr.substring(start, p.pos)
    return Res(parseIntStr(token), p)
  }
  
  def parseFactor(_p: Parser): Res = {
    var p: Parser = _p
    p = skipWS(p)
    if ((p.pos < (p.expr).size && p.expr.substring(p.pos, p.pos + 1) == "(").asInstanceOf[Boolean]) {
      p.pos = (p.pos + 1).asInstanceOf[Int]
      var r: Res = parseExpr(p)
      var v: Int = r.v
      p = r.p
      p = skipWS(p)
      if ((p.pos < (p.expr).size && p.expr.substring(p.pos, p.pos + 1) == ")").asInstanceOf[Boolean]) {
        p.pos = (p.pos + 1).asInstanceOf[Int]
      }
      return Res(v, p)
    }
    if ((p.pos < (p.expr).size && p.expr.substring(p.pos, p.pos + 1) == "-").asInstanceOf[Boolean]) {
      p.pos = (p.pos + 1).asInstanceOf[Int]
      var r: Res = parseFactor(p)
      var v: Int = r.v
      p = r.p
      return Res(0 - v, p)
    }
    return parseNumber(p)
  }
  
  def powInt(base: Int, exp: Int): Int = {
    var r: Int = 1
    var b: Int = base
    var e: Int = exp
    while (e > 0) {
      if (e % 2 == 1) {
        r = (r * b).asInstanceOf[Int]
      }
      b = (b * b).asInstanceOf[Int]
      e = (e / 2.asInstanceOf[Int]).asInstanceOf[Int]
    }
    return r
  }
  
  def parsePower(_p: Parser): Res = {
    var p: Parser = _p
    var r: Res = parseFactor(p)
    var v: Int = r.v
    p = r.p
    val _br4 = new Breaks
    _br4.breakable {
      while (true) {
        p = skipWS(p)
        if ((p.pos < (p.expr).size && p.expr.substring(p.pos, p.pos + 1) == "^").asInstanceOf[Boolean]) {
          p.pos = (p.pos + 1).asInstanceOf[Int]
          var r2: Res = parseFactor(p)
          var rhs: Int = r2.v
          p = r2.p
          v = powInt(v, rhs)
        } else {
          _br4.break()
        }
      }
    }
    return Res(v, p)
  }
  
  def parseTerm(_p: Parser): Res = {
    var p: Parser = _p
    var r: Res = parsePower(p)
    var v: Int = r.v
    p = r.p
    val _br5 = new Breaks
    val _ct5 = new Breaks
    _br5.breakable {
      while (true) {
        _ct5.breakable {
          p = skipWS(p)
          if (p.pos < (p.expr).size) {
            val op: String = p.expr.substring(p.pos, p.pos + 1)
            if (op == "*") {
              p.pos = (p.pos + 1).asInstanceOf[Int]
              var r2: Res = parsePower(p)
              var rhs: Int = r2.v
              p = r2.p
              v = (v * rhs).asInstanceOf[Int]
              _ct5.break()
            }
            if (op == "/") {
              p.pos = (p.pos + 1).asInstanceOf[Int]
              var r2: Res = parsePower(p)
              var rhs: Int = r2.v
              p = r2.p
              v = (v / rhs.asInstanceOf[Int]).asInstanceOf[Int]
              _ct5.break()
            }
          }
          _br5.break()
        }
      }
    }
    return Res(v, p)
  }
  
  def parseExpr(_p: Parser): Res = {
    var p: Parser = _p
    var r: Res = parseTerm(p)
    var v: Int = r.v
    p = r.p
    val _br6 = new Breaks
    val _ct6 = new Breaks
    _br6.breakable {
      while (true) {
        _ct6.breakable {
          p = skipWS(p)
          if (p.pos < (p.expr).size) {
            val op: String = p.expr.substring(p.pos, p.pos + 1)
            if (op == "+") {
              p.pos = (p.pos + 1).asInstanceOf[Int]
              var r2: Res = parseTerm(p)
              var rhs: Int = r2.v
              p = r2.p
              v = (v + rhs).asInstanceOf[Int]
              _ct6.break()
            }
            if (op == "-") {
              p.pos = (p.pos + 1).asInstanceOf[Int]
              var r2: Res = parseTerm(p)
              var rhs: Int = r2.v
              p = r2.p
              v = (v - rhs).asInstanceOf[Int]
              _ct6.break()
            }
          }
          _br6.break()
        }
      }
    }
    return Res(v, p)
  }
  
  def evalExpr(expr: String): Int = {
    var p: Parser = Parser(expr, 0)
    val r: Res = parseExpr(p)
    return r.v
  }
  
  def main() = {
    val expr: String = "2*(3-1)+2*5"
    println(expr + " = " + String.valueOf(evalExpr(expr)))
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
