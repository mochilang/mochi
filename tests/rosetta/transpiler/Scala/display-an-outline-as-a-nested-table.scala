// Generated by Mochi v0.10.57 on 2025-08-05 00:50:32 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
object Main {
  def split(s: String, sep: String): ArrayBuffer[String] = {
    var out: ArrayBuffer[String] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[String]]
    var cur: String = ""
    var i: BigInt = 0
    while (i < BigInt((s).size)) {
      if ((i + BigInt((sep).size) <= BigInt((s).size) && s.slice((i).toInt, (i + BigInt((sep).size)).toInt) == sep).asInstanceOf[Boolean]) {
        out = out :+ cur
        cur = ""
        i = i + BigInt((sep).size)
      } else {
        cur = cur + s.slice((i).toInt, (i + 1).toInt)
        i = i + 1
      }
    }
    out = out :+ cur
    return out
  }
  
  def join(xs: ArrayBuffer[String], sep: String): String = {
    var res: String = ""
    var i: BigInt = 0
    while (i < BigInt((xs).size)) {
      if (i > 0) {
        res = res + sep
      }
      res = res + xs((i.toInt).toInt)
      i = i + 1
    }
    return res
  }
  
  def trimLeftSpaces(s: String): String = {
    var i: BigInt = 0
    while (i < BigInt((s).size) && s.slice((i).toInt, (i + 1).toInt) == " ") {
      i = i + 1
    }
    return s.slice((i).toInt, (BigInt((s).size)).toInt)
  }
  
  def makeIndent(outline: String, tab: BigInt): ArrayBuffer[scala.collection.mutable.Map[String,Any]] = {
    val lines = ArrayBuffer(outline.split("\n"): _*)
    var nodes: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[scala.collection.mutable.Map[String,Any]]]
    for (line <- lines) {
      val line2: String = trimLeftSpaces(line)
      val level: BigInt = (BigInt((line).size) - BigInt((line2).size)) / tab
      nodes = nodes :+ (scala.collection.mutable.Map("level" -> (BigInt(level.toString.toDouble.toInt)), "name" -> (line2))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
    }
    return nodes
  }
  
  def toNest(nodes: ArrayBuffer[scala.collection.mutable.Map[String,Any]], start: BigInt, level: BigInt, n: scala.collection.mutable.Map[String,Any]): Any = {
    if (level == 0) {
      n.update("name", nodes((0.toInt).toInt).asInstanceOf[scala.collection.mutable.Map[String,Any]].getOrElse("name", null))
    }
    var i: BigInt = start + 1
    while (i < BigInt((nodes).size)) {
      val node: scala.collection.mutable.Map[String,Any] = nodes((i.toInt).toInt).asInstanceOf[scala.collection.mutable.Map[String,Any]]
      val lev: BigInt = node.getOrElse("level", null).asInstanceOf[BigInt].asInstanceOf[BigInt].toInt
      if (lev == level + 1) {
        var child: Map[String,Any] = scala.collection.mutable.Map("name" -> (node.getOrElse("name", "").asInstanceOf[String].asInstanceOf[String]), "children" -> (ArrayBuffer()))
        toNest(nodes, i, level + 1, child.asInstanceOf[scala.collection.mutable.Map[String,Any]])
        var cs: ArrayBuffer[Any] = (n.getOrElse("children", null)).asInstanceOf[ArrayBuffer[Any]]
        cs = cs :+ child.asInstanceOf[Any]
        n.update("children", cs)
      } else {
        if (lev <= level) {
          return
        }
      }
      i = i + 1
    }
    return null
  }
  
  def countLeaves(n: scala.collection.mutable.Map[String,Any]): BigInt = {
    val kids: ArrayBuffer[Any] = (n.getOrElse("children", null)).asInstanceOf[ArrayBuffer[Any]]
    if (BigInt((kids).size) == 0) {
      return 1
    }
    var total: BigInt = 0
    for (k <- kids) {
      total = total + countLeaves((k.asInstanceOf[scala.collection.mutable.Map[String,Any]]).asInstanceOf[scala.collection.mutable.Map[String,Any]])
    }
    return total
  }
  
  def nodesByDepth(root: scala.collection.mutable.Map[String,Any], depth: BigInt): ArrayBuffer[ArrayBuffer[scala.collection.mutable.Map[String,Any]]] = {
    var levels: ArrayBuffer[ArrayBuffer[scala.collection.mutable.Map[String,Any]]] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[ArrayBuffer[scala.collection.mutable.Map[String,Any]]]]
    var current: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = ArrayBuffer(root)
    var d: BigInt = 0
    while (d < depth) {
      levels = levels :+ current
      var next: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[scala.collection.mutable.Map[String,Any]]]
      for (n <- current) {
        val kids: ArrayBuffer[Any] = (n.getOrElse("children", null)).asInstanceOf[ArrayBuffer[Any]]
        for (k <- kids) {
          next = next :+ (k.asInstanceOf[scala.collection.mutable.Map[String,Any]]).asInstanceOf[scala.collection.mutable.Map[String,Any]]
        }
      }
      current = next
      d = d + 1
    }
    return levels
  }
  
  def toMarkup(n: scala.collection.mutable.Map[String,Any], cols: ArrayBuffer[String], depth: BigInt): String = {
    var lines: ArrayBuffer[String] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[String]]
    lines = lines :+ "{| class=\"wikitable\" style=\"text-align: center;\""
    val l1: String = "|-"
    lines = lines :+ l1
    var span: BigInt = countLeaves(n)
    lines = lines :+ "| style=\"background: " + cols((0.toInt).toInt) + " \" colSpan=" + String.valueOf(span) + " | " + (n.getOrElse("name", null)).toString
    lines = lines :+ l1
    val lvls: ArrayBuffer[ArrayBuffer[scala.collection.mutable.Map[String,Any]]] = nodesByDepth(n, depth)
    var lvl: BigInt = 1
    while (lvl < depth) {
      val nodes: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = lvls((lvl.toInt).toInt)
      if (BigInt((nodes).size) == 0) {
        lines = lines :+ "|  |"
      } else {
        var idx: BigInt = 0
        while (idx < BigInt((nodes).size)) {
          val node: scala.collection.mutable.Map[String,Any] = nodes((idx.toInt).toInt).asInstanceOf[scala.collection.mutable.Map[String,Any]]
          span = countLeaves(node)
          var col: BigInt = lvl
          if (lvl == 1) {
            col = idx + 1
          }
          if (col >= BigInt((cols).size)) {
            col = BigInt((cols).size) - 1
          }
          val cell: String = "| style=\"background: " + cols((col.toInt).toInt) + " \" colspan=" + String.valueOf(span) + " | " + (node.getOrElse("name", "").asInstanceOf[String].asInstanceOf[String]).toString
          lines = lines :+ cell
          idx = idx + 1
        }
      }
      if (lvl < depth - 1) {
        lines = lines :+ l1
      }
      lvl = lvl + 1
    }
    lines = lines :+ "|}"
    return join(lines, "\n")
  }
  
  def main(): Any = {
    val outline: String = "Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n" + "        measuring the indent of each line,\n" + "        translating the indentation to a nested structure,\n" + "        and padding the tree to even depth.\n" + "    count the leaves descending from each node,\n" + "        defining the width of a leaf as 1,\n" + "        and the width of a parent node as a sum.\n" + "            (The sum of the widths of its children)\n" + "    and write out a table with 'colspan' values\n" + "        either as a wiki table,\n" + "        or as HTML."
    val yellow: String = "#ffffe6;"
    val orange: String = "#ffebd2;"
    val green: String = "#f0fff0;"
    val blue: String = "#e6ffff;"
    val pink: String = "#ffeeff;"
    val cols: ArrayBuffer[String] = ArrayBuffer(yellow, orange, green, blue, pink)
    val nodes: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = makeIndent(outline, 4)
    var n: Map[String,Any] = scala.collection.mutable.Map("name" -> (""), "children" -> (ArrayBuffer()))
    toNest(nodes, 0, 0, n.asInstanceOf[scala.collection.mutable.Map[String,Any]])
    println(toMarkup(n.asInstanceOf[scala.collection.mutable.Map[String,Any]], cols, 4))
    println("\n")
    val outline2: String = "Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n" + "        measuring the indent of each line,\n" + "        translating the indentation to a nested structure,\n" + "        and padding the tree to even depth.\n" + "    count the leaves descending from each node,\n" + "        defining the width of a leaf as 1,\n" + "        and the width of a parent node as a sum.\n" + "            (The sum of the widths of its children)\n" + "            Propagating the sums upward as necessary.\n" + "    and write out a table with 'colspan' values\n" + "        either as a wiki table,\n" + "        or as HTML.\n" + "    Optionally add color to the nodes."
    val cols2: ArrayBuffer[String] = ArrayBuffer(blue, yellow, orange, green, pink)
    val nodes2: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = makeIndent(outline2, 4)
    var n2: Map[String,Any] = scala.collection.mutable.Map("name" -> (""), "children" -> (ArrayBuffer()))
    toNest(nodes2, 0, 0, n2.asInstanceOf[scala.collection.mutable.Map[String,Any]])
    println(toMarkup(n2.asInstanceOf[scala.collection.mutable.Map[String,Any]], cols2, 4))
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
