// Generated by Mochi v0.10.52 on 2025-08-01 19:08:55 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Point3(var x: Double, var y: Double, var z: Double)

case class Point2(var x: BigInt, var y: BigInt)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    val PI: Double = 3.141592653589793
    val TWO_PI: Double = 6.283185307179586
    def _mod(x: Double, m: Double): Double = {
      return x - (BigInt((x / m).toInt)).toString.toDouble * m
    }
    def _sin(x: Double): Double = {
      val y = _mod((x + PI).toString.toDouble, TWO_PI) - PI
      val y2 = y * y
      val y3 = y2 * y
      val y5 = y3 * y2
      val y7 = y5 * y2
      return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0
    }
    def _cos(x: Double): Double = {
      val y = _mod((x + PI).toString.toDouble, TWO_PI) - PI
      val y2 = y * y
      val y4 = y2 * y2
      val y6 = y4 * y2
      return 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0
    }
    val nodes: ArrayBuffer[Point3] = ArrayBuffer(Point3(-1.0, -1.0, -1.0), Point3(-1.0, -1.0, 1.0), Point3(-1.0, 1.0, -1.0), Point3(-1.0, 1.0, 1.0), Point3(1.0, -1.0, -1.0), Point3(1.0, -1.0, 1.0), Point3(1.0, 1.0, -1.0), Point3(1.0, 1.0, 1.0))
    val edges: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(0), BigInt(1)), ArrayBuffer(BigInt(1), BigInt(3)), ArrayBuffer(BigInt(3), BigInt(2)), ArrayBuffer(BigInt(2), BigInt(0)), ArrayBuffer(BigInt(4), BigInt(5)), ArrayBuffer(BigInt(5), BigInt(7)), ArrayBuffer(BigInt(7), BigInt(6)), ArrayBuffer(BigInt(6), BigInt(4)), ArrayBuffer(BigInt(0), BigInt(4)), ArrayBuffer(BigInt(1), BigInt(5)), ArrayBuffer(BigInt(2), BigInt(6)), ArrayBuffer(BigInt(3), BigInt(7)))
    def rotate(p: Point3, ax: Double, ay: Double): Point3 = {
      val sinx: Double = _sin(ax)
      val cosx: Double = _cos(ax)
      val siny: Double = _sin(ay)
      val cosy: Double = _cos(ay)
      val x1: Double = p.x
      val y1: Double = (p.y * cosx).toString.toDouble - (p.z * sinx).toString.toDouble
      val z1: Double = (p.y * sinx).toString.toDouble + (p.z * cosx).toString.toDouble
      val x2: Double = (x1 * cosy).toString.toDouble + (z1 * siny).toString.toDouble
      val z2: Double = (-x1 * siny).toString.toDouble + (z1 * cosy).toString.toDouble
      return Point3(x2, y1, z2)
    }
    val width: BigInt = BigInt(40)
    val height: BigInt = BigInt(20)
    val distance: Double = 3.0
    val scale: Double = 8.0
    def project(p: Point3): Point2 = {
      val factor = scale / (p.z + distance)
      val x: BigInt = BigInt((p.x * factor).toInt) + width / BigInt(2)
      val y: BigInt = BigInt((-p.y * factor).toInt) + height / BigInt(2)
      return Point2(x, y)
    }
    def clearGrid(): ArrayBuffer[ArrayBuffer[String]] = {
      var g: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer()
      var y: BigInt = BigInt(0)
      while (y < height) {
        var row: ArrayBuffer[String] = ArrayBuffer()
        var x: BigInt = BigInt(0)
        while (x < width) {
          row = row :+ " "
          x = x + BigInt(1)
        }
        g = g :+ row
        y = y + BigInt(1)
      }
      return g
    }
    def drawPoint(g: ArrayBuffer[ArrayBuffer[String]], x: BigInt, y: BigInt, ch: String): Any = {
      if ((((x >= BigInt(0) && x < width).asInstanceOf[Boolean] && y >= BigInt(0)).asInstanceOf[Boolean] && y < height).asInstanceOf[Boolean]) {
        var row: ArrayBuffer[String] = g((y).toInt)
        row((x).toInt) = ch
        g((y).toInt) = row
      }
    }
    def bresenham(_x0: BigInt, _y0: BigInt, x1: BigInt, y1: BigInt, g: ArrayBuffer[ArrayBuffer[String]], ch: String): Any = {
      var x0: BigInt = _x0
      var y0: BigInt = _y0
      var dx: BigInt = x1 - x0
      if (dx < BigInt(0)) {
        dx = BigInt(0) - dx
      }
      var dy: BigInt = y1 - y0
      if (dy < BigInt(0)) {
        dy = BigInt(0) - dy
      }
      var sx: BigInt = BigInt(0) - BigInt(1)
      if (x0 < x1) {
        sx = BigInt(1)
      }
      var sy: BigInt = BigInt(0) - BigInt(1)
      if (y0 < y1) {
        sy = BigInt(1)
      }
      var err: BigInt = dx - dy
      val _br2 = new Breaks
      _br2.breakable {
        while (true) {
          drawPoint(g, x0, y0, ch)
          if ((x0 == x1 && y0 == y1).asInstanceOf[Boolean]) {
            _br2.break()
          }
          var e2: BigInt = BigInt(2) * err
          if (e2 > BigInt(0) - dy) {
            err = err - dy
            x0 = x0 + sx
          }
          if (e2 < dx) {
            err = err + dx
            y0 = y0 + sy
          }
        }
      }
    }
    def render(g: ArrayBuffer[ArrayBuffer[String]]): String = {
      var out: String = ""
      var y: BigInt = BigInt(0)
      while (y < height) {
        var line: String = ""
        var x: BigInt = BigInt(0)
        while (x < width) {
          line = line + g((y).toInt)((x).toInt)
          x = x + BigInt(1)
        }
        out = out + line + "\n"
        y = y + BigInt(1)
      }
      return out
    }
    def main(): Any = {
      var f: BigInt = BigInt(0)
      while (f < BigInt(10)) {
        var grid: ArrayBuffer[ArrayBuffer[String]] = clearGrid()
        var rot: ArrayBuffer[Point2] = ArrayBuffer()
        var i: BigInt = BigInt(0)
        var ay: Double = PI / 4.0 + f.toString.toDouble * PI / 10.0
        while (i < (nodes).size) {
          val p: Point3 = rotate(nodes((i).toInt), PI / 4.0, ay)
          val pp: Point2 = project(p)
          rot = rot :+ pp
          i = i + BigInt(1)
        }
        var e: BigInt = BigInt(0)
        while (e < (edges).size) {
          val a: BigInt = edges((e).toInt)((BigInt(0)).toInt)
          val b: BigInt = edges((e).toInt)((BigInt(1)).toInt)
          val p1: Point2 = rot((a).toInt)
          val p2: Point2 = rot((b).toInt)
          bresenham((p1.x).asInstanceOf[BigInt], (p1.y).asInstanceOf[BigInt], (p2.x).asInstanceOf[BigInt], (p2.y).asInstanceOf[BigInt], grid, "#")
          e = e + BigInt(1)
        }
        println(render(grid))
        f = f + BigInt(1)
      }
    }
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
