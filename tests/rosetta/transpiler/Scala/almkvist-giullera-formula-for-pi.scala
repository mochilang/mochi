// Generated by Mochi v0.10.40 on 2025-07-25 12:56:40 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  def bigTrim(_a: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var a: ArrayBuffer[Int] = _a
    var n: Int = (a).size
    while (n > 1 && a(n - 1) == 0) {
      a = a.slice(0, n - 1)
      n = (n - 1).asInstanceOf[Int]
    }
    return a
  }
  
  def bigFromInt(x: Int): ArrayBuffer[Int] = {
    if (x == 0) {
      return ArrayBuffer(0)
    }
    var digits: ArrayBuffer[Int] = ArrayBuffer()
    var n: Int = x
    while (n > 0) {
      digits = digits :+ Math.floorMod(n, 10)
      n = (n / 10).asInstanceOf[Int]
    }
    return digits
  }
  
  def bigCmp(a: ArrayBuffer[Int], b: ArrayBuffer[Int]): Int = {
    if ((a).size > (b).size) {
      return 1
    }
    if ((a).size < (b).size) {
      return 0 - 1
    }
    var i: Int = (a).size - 1
    while (i >= 0) {
      if (a(i) > b(i)) {
        return 1
      }
      if (a(i) < b(i)) {
        return 0 - 1
      }
      i = (i - 1).asInstanceOf[Int]
    }
    return 0
  }
  
  def bigAdd(a: ArrayBuffer[Int], b: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var carry: Int = 0
    var i: Int = 0
    while ((i < (a).size || i < (b).size).asInstanceOf[Boolean] || carry > 0) {
      var av: Int = 0
      if (i < (a).size) {
        av = a(i)
      }
      var bv: Int = 0
      if (i < (b).size) {
        bv = b(i)
      }
      var s = av + bv + carry
      res = res :+ Math.floorMod(s, 10)
      carry = (s / 10).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    return bigTrim(res)
  }
  
  def bigSub(a: ArrayBuffer[Int], b: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var borrow: Int = 0
    var i: Int = 0
    while (i < (a).size) {
      var av: Int = a(i)
      var bv: Int = 0
      if (i < (b).size) {
        bv = b(i)
      }
      var diff = av - bv - borrow
      if (diff < 0) {
        diff = (diff + 10).asInstanceOf[Int]
        borrow = 1
      } else {
        borrow = 0
      }
      res = res :+ diff
      i = (i + 1).asInstanceOf[Int]
    }
    return bigTrim(res)
  }
  
  def bigMulSmall(a: ArrayBuffer[Int], m: Int): ArrayBuffer[Int] = {
    if (m == 0) {
      return ArrayBuffer(0)
    }
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var carry: Int = 0
    var i: Int = 0
    while (i < (a).size) {
      var prod = a(i) * m + carry
      res = res :+ Math.floorMod(prod, 10)
      carry = (prod / 10).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    while (carry > 0) {
      res = res :+ Math.floorMod(carry, 10)
      carry = (carry / 10).asInstanceOf[Int]
    }
    return bigTrim(res)
  }
  
  def bigMulBig(a: ArrayBuffer[Int], b: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = 0
    while (i < (a).size + (b).size) {
      res = res :+ 0
      i = (i + 1).asInstanceOf[Int]
    }
    i = 0
    while (i < (a).size) {
      var carry: Int = 0
      var j: Int = 0
      while (j < (b).size) {
        var idx = i + j
        var prod = res(idx) + a(i) * b(j) + carry
        res(idx) = (Math.floorMod(prod.asInstanceOf[Int], 10)).asInstanceOf[Int]
        carry = prod.asInstanceOf[Int] / 10
        j = (j + 1).asInstanceOf[Int]
      }
      var idx = i + (b).size
      while (carry > 0) {
        var prod = res(idx) + carry
        res(idx) = (Math.floorMod(prod.asInstanceOf[Int], 10)).asInstanceOf[Int]
        carry = prod.asInstanceOf[Int] / 10
        idx = (idx + 1).asInstanceOf[Int]
      }
      i = (i + 1).asInstanceOf[Int]
    }
    return bigTrim(res)
  }
  
  def bigMulPow10(_a: ArrayBuffer[Int], k: Int): ArrayBuffer[Int] = {
    var a: ArrayBuffer[Int] = _a
    var i: Int = 0
    while (i < k) {
      a = (ArrayBuffer(0) ++ a).asInstanceOf[ArrayBuffer[Int]]
      i = (i + 1).asInstanceOf[Int]
    }
    return a
  }
  
  def bigDivSmall(a: ArrayBuffer[Int], m: Int): ArrayBuffer[Int] = {
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var rem: Int = 0
    var i: Int = (a).size - 1
    while (i >= 0) {
      var cur = rem * 10 + a(i)
      var q = cur / m
      rem = (Math.floorMod(cur, m)).asInstanceOf[Int]
      res = (ArrayBuffer(q) ++ res).asInstanceOf[ArrayBuffer[Int]]
      i = (i - 1).asInstanceOf[Int]
    }
    return bigTrim(res)
  }
  
  def bigToString(a: ArrayBuffer[Int]): String = {
    var s: String = ""
    var i: Int = (a).size - 1
    while (i >= 0) {
      s = (s + String.valueOf(a(i))).asInstanceOf[String]
      i = (i - 1).asInstanceOf[Int]
    }
    return s
  }
  
  def repeat(ch: String, n: Int): String = {
    var s: String = ""
    var i: Int = 0
    while (i < n) {
      s = (s + ch).asInstanceOf[String]
      i = (i + 1).asInstanceOf[Int]
    }
    return s
  }
  
  def sortInts(xs: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var tmp: ArrayBuffer[Int] = xs
    while ((tmp).size > 0) {
      var min: Int = tmp(0)
      var idx: Int = 0
      var i: Int = 1
      while (i < (tmp).size) {
        if (tmp(i) < min) {
          min = tmp(i)
          idx = i
        }
        i = (i + 1).asInstanceOf[Int]
      }
      res = (res ++ ArrayBuffer(min)).asInstanceOf[ArrayBuffer[Int]]
      var out: ArrayBuffer[Int] = ArrayBuffer()
      var j: Int = 0
      while (j < (tmp).size) {
        if (j != idx) {
          out = (out ++ ArrayBuffer(tmp(j))).asInstanceOf[ArrayBuffer[Int]]
        }
        j = (j + 1).asInstanceOf[Int]
      }
      tmp = out
    }
    return res
  }
  
  def primesUpTo(n: Int): ArrayBuffer[Int] = {
    var sieve: ArrayBuffer[Boolean] = ArrayBuffer()
    var i: Int = 0
    while (i <= n) {
      sieve = sieve :+ true
      i = (i + 1).asInstanceOf[Int]
    }
    var p: Int = 2
    while ((p * p).asInstanceOf[Int] <= n) {
      if (sieve(p)) {
        var m = p * p
        while (m <= n) {
          sieve(m) = false
          m = (m + p).asInstanceOf[Int]
        }
      }
      p = (p + 1).asInstanceOf[Int]
    }
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var x: Int = 2
    while (x <= n) {
      if (sieve(x)) {
        res = res :+ x
      }
      x = (x + 1).asInstanceOf[Int]
    }
    return res
  }
  
  def factorialExp(n: Int, primes: ArrayBuffer[Int]): Map[String,Int] = {
    var m: Map[String,Int] = Map()
    val _br22 = new Breaks
    _br22.breakable {
      for (p <- primes) {
        if (p.asInstanceOf[Int] > n) {
          _br22.break()
        }
        var t: Int = n
        var e: Int = 0
        while (t > 0) {
          t = (t / p).asInstanceOf[Int]
          e = (e + t).asInstanceOf[Int]
        }
        m(String.valueOf(p)) = e
      }
    }
    return m
  }
  
  def factorSmall(x: Int, primes: ArrayBuffer[Int]): Map[String,Int] = {
    var f: Map[String,Int] = Map()
    var n: Int = x
    val _br24 = new Breaks
    _br24.breakable {
      for (p <- primes) {
        if (p.asInstanceOf[Int] * p.asInstanceOf[Int] > n) {
          _br24.break()
        }
        var c: Int = 0
        while (Math.floorMod(n, p) == 0) {
          c = (c + 1).asInstanceOf[Int]
          n = (n / p).asInstanceOf[Int]
        }
        if (c > 0) {
          f(String.valueOf(p)) = c
        }
      }
    }
    if (n > 1) {
      f(String.valueOf(n)) = (f.getOrElse(String.valueOf(n), 0) + 1).asInstanceOf[Int]
    }
    return f
  }
  
  def computeIP(n: Int, primes: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var exps: Map[String,Int] = factorialExp((6 * n).asInstanceOf[Int], primes)
    val fn: Map[String,Int] = factorialExp(n, primes)
    for (k <- fn.keys) {
      exps(k) = (exps.getOrElse(k, 0) - 6 * fn.getOrElse(k, null.asInstanceOf[Int])).asInstanceOf[Int]
    }
    exps("2") = (exps.getOrElse("2", 0) + 5).asInstanceOf[Int]
    val t2: Int = (532 * n * n).asInstanceOf[Int] + (126 * n).asInstanceOf[Int] + 9
    val ft2: Map[String,Int] = factorSmall(t2, primes)
    for (k <- ft2.keys) {
      exps(k) = (exps.getOrElse(k, 0) + ft2.getOrElse(k, null.asInstanceOf[Int])).asInstanceOf[Int]
    }
    exps("3") = (exps.getOrElse("3", 0) - 1).asInstanceOf[Int]
    var keys: ArrayBuffer[Int] = ArrayBuffer()
    for (k <- exps.keys) {
      keys = keys :+ k.toString().toInt
    }
    keys = sortInts(keys)
    var res: ArrayBuffer[Int] = bigFromInt(1)
    for (p <- keys) {
      var e: Int = exps.getOrElse(String.valueOf(p), null.asInstanceOf[Int])
      var i: Int = 0
      while (i < e) {
        res = bigMulSmall(res, p.asInstanceOf[Int])
        i = (i + 1).asInstanceOf[Int]
      }
    }
    return res
  }
  
  def formatTerm(ip: ArrayBuffer[Int], pw: Int): String = {
    var s: String = bigToString(ip)
    if (pw >= (s).size) {
      var frac = repeat("0", (pw - (s).size).asInstanceOf[Int]) + s
      if ((frac).size < 33) {
        frac = (frac + repeat("0", 33 - (frac).size)).asInstanceOf[String]
      }
      return "0." + frac.substring(0, 33)
    }
    var intpart: String = s.substring(0, (s).size - pw)
    var frac: String = s.substring((s).size - pw, (s).size)
    if ((frac).size < 33) {
      frac = (frac + repeat("0", 33 - (frac).size)).asInstanceOf[String]
    }
    return intpart + "." + frac.substring(0, 33)
  }
  
  def bigAbsDiff(a: ArrayBuffer[Int], b: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    if (bigCmp(a, b) >= 0) {
      return bigSub(a, b)
    }
    return bigSub(b, a)
  }
  
  def main(): Unit = {
    val primes: ArrayBuffer[Int] = primesUpTo(2000)
    println("N                               Integer Portion  Pow  Nth Term (33 dp)")
    val line: String = repeat("-", 89)
    println(line)
    var sum: ArrayBuffer[Int] = bigFromInt(0)
    var prev: ArrayBuffer[Int] = bigFromInt(0)
    var denomPow: Int = 0
    var n: Int = 0
    val _br31 = new Breaks
    _br31.breakable {
      while (true) {
        val ip: ArrayBuffer[Int] = computeIP(n, primes)
        val pw = 6 * n + 3
        if (pw > denomPow) {
          sum = bigMulPow10(sum, (pw - denomPow).asInstanceOf[Int])
          prev = bigMulPow10(prev, (pw - denomPow).asInstanceOf[Int])
          denomPow = pw
        }
        if (n < 10) {
          val termStr: String = formatTerm(ip, pw)
          var ipStr: String = bigToString(ip)
          while ((ipStr).size < 44) {
            ipStr = " " + ipStr
          }
          var pwStr = String.valueOf(0 - pw)
          while ((pwStr).size < 3) {
            pwStr = " " + pwStr
          }
          var padTerm: String = termStr
          while ((padTerm).size < 35) {
            padTerm = padTerm + " "
          }
          println(String.valueOf(n) + "  " + ipStr + "  " + pwStr + "  " + padTerm)
        }
        sum = bigAdd(sum, ip)
        val diff: ArrayBuffer[Int] = bigAbsDiff(sum, prev)
        if ((denomPow >= 70 && bigCmp(diff, bigMulPow10(bigFromInt(1), (denomPow - 70).asInstanceOf[Int])) < 0).asInstanceOf[Boolean]) {
          _br31.break()
        }
        prev = sum
        n = (n + 1).asInstanceOf[Int]
      }
    }
    val precision: Int = 70
    val target: ArrayBuffer[Int] = bigMulPow10(bigFromInt(1), (denomPow + 2 * precision).asInstanceOf[Int])
    var low: ArrayBuffer[Int] = bigFromInt(0)
    var high: ArrayBuffer[Int] = bigMulPow10(bigFromInt(1), (precision + 1).asInstanceOf[Int])
    while (bigCmp(low, bigSub(high, bigFromInt(1))) < 0) {
      var mid: ArrayBuffer[Int] = bigDivSmall(bigAdd(low, high), 2)
      var prod: ArrayBuffer[Int] = bigMulBig(bigMulBig(mid, mid), sum)
      if (bigCmp(prod, target) <= 0) {
        low = mid
      } else {
        high = bigSub(mid, bigFromInt(1))
      }
    }
    var piInt: ArrayBuffer[Int] = low
    var piStr: String = bigToString(piInt)
    if ((piStr).size <= precision) {
      piStr = (repeat("0", (precision - (piStr).size + 1).asInstanceOf[Int]) + piStr).asInstanceOf[String]
    }
    var out: String = piStr.substring(0, (piStr).size - precision) + "." + piStr.substring((piStr).size - precision, (piStr).size)
    println("")
    println("Pi to 70 decimal places is:")
    println(out)
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
