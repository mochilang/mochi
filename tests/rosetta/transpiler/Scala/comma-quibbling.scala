// Generated by Mochi v0.10.41 on 2025-07-27 16:19:19 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  def quibble(items: ArrayBuffer[String]): String = {
    val n: Int = (items).size
    if (n == BigInt(0)) {
      return "{}"
    } else {
      if (n == BigInt(1)) {
        return "{" + items((BigInt(0)).toInt) + "}"
      } else {
        if (n == BigInt(2)) {
          return "{" + items((BigInt(0)).toInt) + " and " + items((BigInt(1)).toInt) + "}"
        } else {
          var prefix: String = ""
          val _br0 = new Breaks
          _br0.breakable {
            for (i <- BigInt(0) until n - BigInt(1)) {
              if (i == n - BigInt(1)) {
                _br0.break()
              }
              if (i > BigInt(0)) {
                prefix = prefix + ", "
              }
              prefix = (prefix + items((i).toInt)).toString
            }
          }
          return "{" + prefix + " and " + items((n - BigInt(1)).toInt) + "}"
        }
      }
    }
    return ""
  }
  
  def main(): Any = {
    println(quibble((ArrayBuffer()).asInstanceOf[ArrayBuffer[String]]))
    println(quibble(ArrayBuffer("ABC")))
    println(quibble(ArrayBuffer("ABC", "DEF")))
    println(quibble(ArrayBuffer("ABC", "DEF", "G", "H")))
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
