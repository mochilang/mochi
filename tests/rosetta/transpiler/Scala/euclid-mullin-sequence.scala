// Generated by Mochi v0.10.55 on 2025-08-03 09:50:11 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def gcd(a: BigInt, b: BigInt): BigInt = {
  var x: BigInt = a
  var y: BigInt = b
  while (y != zero) {
    var t: BigInt = x % y
    x = y
    y = t
  }
  return x
}

def absBig(x: BigInt): BigInt = {
  if (x < zero) {
    return zero - x
  }
  return x
}

def pollardRho(n: BigInt, c: BigInt): BigInt = {
  def g(x: BigInt, y: BigInt): BigInt = {
    var x2: BigInt = x * x
    x2 = x2 + c
    return x2 % y
  }
  var x: BigInt = BigInt(2)
  var y: BigInt = BigInt(2)
  var z: BigInt = BigInt(1)
  var d: BigInt = BigInt(0)
  var count: BigInt = BigInt(0)
  val _br1 = new Breaks
  _br1.breakable {
    while (true) {
      x = BigInt((g(x, n)).toString.toDouble.toInt)
      y = BigInt((g(g(y, n), n)).toString.toDouble.toInt)
      d = absBig(x - y)
      d = d % n
      z = z * d
      count = count + BigInt(1)
      if (count == BigInt(100)) {
        d = gcd(z, n)
        if (d != one) {
          _br1.break()
        }
        z = one
        count = BigInt(0)
      }
    }
  }
  if (d == n) {
    return zero
  }
  return d
}

def smallestPrimeFactorWheel(n: BigInt, max: BigInt): BigInt = {
  if (n % two == zero) {
    return two
  }
  if (n % three == zero) {
    return three
  }
  if (n % five == zero) {
    return five
  }
  var k: BigInt = BigInt(7)
  val inc: ArrayBuffer[BigInt] = ArrayBuffer(four, two, four, two, four, six, two, six)
  var i: BigInt = BigInt(0)
  val _br2 = new Breaks
  _br2.breakable {
    while (k * k <= n) {
      if (n % k == zero) {
        return k
      }
      k = k + inc((i.toInt).toInt)
      if (k > max) {
        _br2.break()
      }
      i = (i + BigInt(1)) % BigInt(8)
    }
  }
  return zero
}

def smallestPrimeFactor(n: BigInt): BigInt = {
  var s: BigInt = smallestPrimeFactorWheel(n, k100)
  if (s != zero) {
    return s
  }
  var c: BigInt = BigInt(1)
  while (true) {
    val d: BigInt = pollardRho(n, c)
    if (d == zero) {
      if (c == ten) {
        return n
      }
      c = c + one
    } else {
      val factor: BigInt = smallestPrimeFactorWheel(d, d)
      val s2: BigInt = smallestPrimeFactorWheel(n / d, factor)
      if (s2 != zero) {
        if (s2 < factor) {
          return s2
        } else {
          return factor
        }
      }
      return factor
    }
  }
  return null
}

def main(): Any = {
  val k: BigInt = BigInt(19)
  println("First " + String.valueOf(k) + " terms of the Euclid\u2013Mullin sequence:")
  println(BigInt(2))
  var prod: BigInt = BigInt(2)
  var count: BigInt = BigInt(1)
  while (count < k) {
    val z: BigInt = prod + one
    val t: BigInt = smallestPrimeFactor(z)
    println(t)
    prod = prod * t
    count = count + BigInt(1)
  }
}

var zero: BigInt = BigInt(0)

var one: BigInt = BigInt(1)

var two: BigInt = BigInt(2)

var three: BigInt = BigInt(3)

var four: BigInt = BigInt(4)

var five: BigInt = BigInt(5)

var six: BigInt = BigInt(6)

var ten: BigInt = BigInt(10)

var k100: BigInt = BigInt(100000)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
