// Generated by Mochi v0.10.40 on 2025-07-26 09:48:21 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Point(var x: Double, var y: Double, var z: Double)

case class Edge(var pn1: BigInt, var pn2: BigInt, var fn1: BigInt, var fn2: BigInt, var cp: Point)

case class PointEx(var p: Point, var n: BigInt)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    def indexOf(s: String, ch: String): BigInt = {
      var i: BigInt = BigInt(0)
      while (i < (s).size) {
        if (s.slice(i, (i + BigInt(1)).toInt) == ch) {
          return i
        }
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      return (BigInt(0) - BigInt(1)).asInstanceOf[BigInt]
    }
    def fmt4(x: Double): String = {
      var y: Double = x * 10000.0
      if (y >= BigInt(0)) {
        y = y + 0.5
      } else {
        y = y - 0.5
      }
      y = (BigInt(y)).toString.toDouble / 10000.0
      var s = String.valueOf(y)
      var dot: BigInt = indexOf(s, ".")
      if (dot == BigInt(0) - BigInt(1)) {
        s = s + ".0000"
      } else {
        var decs = (s).size - dot - BigInt(1)
        if (decs > BigInt(4)) {
          s = s.slice((BigInt(0)).toInt, (dot + BigInt(5)).toInt)
        } else {
          while (decs < BigInt(4)) {
            s = s + "0"
            decs = (decs + BigInt(1)).asInstanceOf[BigInt]
          }
        }
      }
      if (x >= 0.0) {
        s = " " + s
      }
      return s
    }
    def fmt2(n: BigInt): String = {
      val s = String.valueOf(n)
      if ((s).size < BigInt(2)) {
        return " " + s
      }
      return s
    }
    def sumPoint(p1: Point, p2: Point): Point = {
      return Point(p1.x + p2.x, p1.y + p2.y, p1.z + p2.z)
    }
    def mulPoint(p: Point, m: Double): Point = {
      return Point(p.x * m, p.y * m, p.z * m)
    }
    def divPoint(p: Point, d: Double): Point = {
      return mulPoint(p, 1.0 / d)
    }
    def centerPoint(p1: Point, p2: Point): Point = {
      return divPoint(sumPoint(p1, p2), 2.0)
    }
    def getFacePoints(points: ArrayBuffer[Point], faces: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[Point] = {
      var facePoints: ArrayBuffer[Point] = ArrayBuffer()
      var i: BigInt = BigInt(0)
      while (i < (faces).size) {
        val face: ArrayBuffer[BigInt] = faces((i).toInt)
        var fp: Point = Point(0.0, 0.0, 0.0)
        for (idx <- face) {
          fp = sumPoint(fp, points((idx).toInt))
        }
        fp = divPoint(fp, ((face).size).toString.toDouble)
        facePoints = facePoints :+ fp
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      return facePoints
    }
    def sortEdges(edges: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[ArrayBuffer[BigInt]] = {
      var res: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
      var tmp: ArrayBuffer[ArrayBuffer[BigInt]] = edges
      while ((tmp).size > BigInt(0)) {
        var min: ArrayBuffer[BigInt] = tmp((BigInt(0)).toInt)
        var idx: BigInt = BigInt(0)
        var j: BigInt = BigInt(1)
        while (j < (tmp).size) {
          val e: ArrayBuffer[BigInt] = tmp((j).toInt)
          if ((e((BigInt(0)).toInt) < min((BigInt(0)).toInt) || (e((BigInt(0)).toInt) == min((BigInt(0)).toInt) && (e((BigInt(1)).toInt) < min((BigInt(1)).toInt) || (e((BigInt(1)).toInt) == min((BigInt(1)).toInt) && e((BigInt(2)).toInt) < min((BigInt(2)).toInt)).asInstanceOf[Boolean]).asInstanceOf[Boolean]).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
            min = e
            idx = j
          }
          j = (j + BigInt(1)).asInstanceOf[BigInt]
        }
        res = res :+ min
        var out: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
        var k: BigInt = BigInt(0)
        while (k < (tmp).size) {
          if (k != idx) {
            out = out :+ tmp((k).toInt)
          }
          k = (k + BigInt(1)).asInstanceOf[BigInt]
        }
        tmp = out
      }
      return res
    }
    def getEdgesFaces(points: ArrayBuffer[Point], faces: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[Edge] = {
      var edges: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
      var fnum: BigInt = BigInt(0)
      while (fnum < (faces).size) {
        val face: ArrayBuffer[BigInt] = faces((fnum).toInt)
        var numP: Int = (face).size
        var pi: BigInt = BigInt(0)
        while (pi < numP) {
          var pn1: BigInt = face((pi).toInt)
          var pn2: BigInt = BigInt(0)
          if (pi < numP - BigInt(1)) {
            pn2 = face((pi + BigInt(1)).toInt)
          } else {
            pn2 = face((BigInt(0)).toInt)
          }
          if (pn1 > pn2) {
            var tmpn: BigInt = pn1
            pn1 = pn2
            pn2 = tmpn
          }
          edges = edges :+ (ArrayBuffer(pn1, pn2, fnum)).asInstanceOf[ArrayBuffer[BigInt]]
          pi = (pi + BigInt(1)).asInstanceOf[BigInt]
        }
        fnum = (fnum + BigInt(1)).asInstanceOf[BigInt]
      }
      edges = sortEdges(edges)
      var merged: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
      var idx: BigInt = BigInt(0)
      val _ct9 = new Breaks
      while (idx < (edges).size) {
        _ct9.breakable {
          val e1: ArrayBuffer[BigInt] = edges((idx).toInt)
          if (idx < (edges).size - BigInt(1)) {
            val e2: ArrayBuffer[BigInt] = edges((idx + BigInt(1)).toInt)
            if ((e1((BigInt(0)).toInt) == e2((BigInt(0)).toInt) && e1((BigInt(1)).toInt) == e2((BigInt(1)).toInt)).asInstanceOf[Boolean]) {
              merged = merged :+ (ArrayBuffer(e1((BigInt(0)).toInt), e1((BigInt(1)).toInt), e1((BigInt(2)).toInt), e2((BigInt(2)).toInt))).asInstanceOf[ArrayBuffer[BigInt]]
              idx = (idx + BigInt(2)).asInstanceOf[BigInt]
              _ct9.break()
            }
          }
          merged = merged :+ (ArrayBuffer(e1((BigInt(0)).toInt), e1((BigInt(1)).toInt), e1((BigInt(2)).toInt), BigInt(0) - BigInt(1))).asInstanceOf[ArrayBuffer[BigInt]]
          idx = (idx + BigInt(1)).asInstanceOf[BigInt]
        }
      }
      var edgesCenters: ArrayBuffer[Edge] = ArrayBuffer()
      for (me <- merged) {
        val p1: Point = points((me(BigInt(0))).toInt)
        val p2: Point = points((me(BigInt(1))).toInt)
        val cp: Point = centerPoint(p1, p2)
        edgesCenters = edgesCenters :+ Edge(me(BigInt(0)), me(BigInt(1)), me(BigInt(2)), me(BigInt(3)), cp)
      }
      return edgesCenters
    }
    def getEdgePoints(points: ArrayBuffer[Point], edgesFaces: ArrayBuffer[Edge], facePoints: ArrayBuffer[Point]): ArrayBuffer[Point] = {
      var edgePoints: ArrayBuffer[Point] = ArrayBuffer()
      var i: BigInt = BigInt(0)
      while (i < (edgesFaces).size) {
        val edge: Edge = edgesFaces((i).toInt)
        val cp: Point = edge.cp
        val fp1: Point = facePoints((edge.fn1).toInt)
        var fp2: Point = fp1
        if (edge.fn2 != BigInt(0) - BigInt(1)) {
          fp2 = facePoints((edge.fn2).toInt)
        }
        val cfp: Point = centerPoint(fp1, fp2)
        edgePoints = edgePoints :+ centerPoint(cp, cfp)
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      return edgePoints
    }
    def getAvgFacePoints(points: ArrayBuffer[Point], faces: ArrayBuffer[ArrayBuffer[BigInt]], facePoints: ArrayBuffer[Point]): ArrayBuffer[Point] = {
      var numP: Int = (points).size
      var temp: ArrayBuffer[PointEx] = ArrayBuffer()
      var i: BigInt = BigInt(0)
      while (i < numP) {
        temp = temp :+ PointEx(Point(0.0, 0.0, 0.0), BigInt(0))
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      var fnum: BigInt = BigInt(0)
      while (fnum < (faces).size) {
        val fp: Point = facePoints((fnum).toInt)
        for (pn <- faces((fnum).toInt)) {
          val tp: PointEx = temp((pn).toInt)
          temp((pn).toInt) = PointEx(sumPoint((tp.p).asInstanceOf[Point], fp), tp.n + BigInt(1))
        }
        fnum = (fnum + BigInt(1)).asInstanceOf[BigInt]
      }
      var avg: ArrayBuffer[Point] = ArrayBuffer()
      var j: BigInt = BigInt(0)
      while (j < numP) {
        val tp: PointEx = temp((j).toInt)
        avg = avg :+ divPoint((tp.p).asInstanceOf[Point], (tp.n).toString.toDouble)
        j = (j + BigInt(1)).asInstanceOf[BigInt]
      }
      return avg
    }
    def getAvgMidEdges(points: ArrayBuffer[Point], edgesFaces: ArrayBuffer[Edge]): ArrayBuffer[Point] = {
      var numP: Int = (points).size
      var temp: ArrayBuffer[PointEx] = ArrayBuffer()
      var i: BigInt = BigInt(0)
      while (i < numP) {
        temp = temp :+ PointEx(Point(0.0, 0.0, 0.0), BigInt(0))
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      for (edge <- edgesFaces) {
        val cp = edge.cp
        var arr = ArrayBuffer(edge.pn1, edge.pn2)
        for (pn <- arr) {
          val tp: PointEx = temp((pn).toInt)
          temp((pn).toInt) = PointEx(sumPoint((tp.p).asInstanceOf[Point], cp.asInstanceOf[Point]), tp.n + BigInt(1))
        }
      }
      var avg: ArrayBuffer[Point] = ArrayBuffer()
      var j: BigInt = BigInt(0)
      while (j < numP) {
        val tp: PointEx = temp((j).toInt)
        avg = avg :+ divPoint((tp.p).asInstanceOf[Point], (tp.n).toString.toDouble)
        j = (j + BigInt(1)).asInstanceOf[BigInt]
      }
      return avg
    }
    def getPointsFaces(points: ArrayBuffer[Point], faces: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[BigInt] = {
      var pf: ArrayBuffer[BigInt] = ArrayBuffer()
      var i: BigInt = BigInt(0)
      while (i < (points).size) {
        pf = pf :+ BigInt(0)
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      var fnum: BigInt = BigInt(0)
      while (fnum < (faces).size) {
        for (pn <- faces((fnum).toInt)) {
          pf((pn).toInt) = pf((pn).toInt) + BigInt(1)
        }
        fnum = (fnum + BigInt(1)).asInstanceOf[BigInt]
      }
      return pf
    }
    def getNewPoints(points: ArrayBuffer[Point], pf: ArrayBuffer[BigInt], afp: ArrayBuffer[Point], ame: ArrayBuffer[Point]): ArrayBuffer[Point] = {
      var newPts: ArrayBuffer[Point] = ArrayBuffer()
      var i: BigInt = BigInt(0)
      while (i < (points).size) {
        var n: Double = (pf((i).toInt)).toString.toDouble
        var m1: Double = (n - 3.0) / n
        var m2: Double = 1.0 / n
        var m3: Double = 2.0 / n
        val old: Point = points((i).toInt)
        val p1: Point = mulPoint(old, m1)
        val p2: Point = mulPoint(afp((i).toInt), m2)
        val p3: Point = mulPoint(ame((i).toInt), m3)
        newPts = newPts :+ sumPoint(sumPoint(p1, p2), p3)
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      return newPts
    }
    def key(a: BigInt, b: BigInt): String = {
      if (a < b) {
        return String.valueOf(a) + "," + String.valueOf(b)
      }
      return String.valueOf(b) + "," + String.valueOf(a)
    }
    def cmcSubdiv(points: ArrayBuffer[Point], faces: ArrayBuffer[ArrayBuffer[BigInt]]): ArrayBuffer[Any] = {
      val facePoints: ArrayBuffer[Point] = getFacePoints(points, faces)
      val edgesFaces: ArrayBuffer[Edge] = getEdgesFaces(points, faces)
      val edgePoints: ArrayBuffer[Point] = getEdgePoints(points, edgesFaces, facePoints)
      val avgFacePoints: ArrayBuffer[Point] = getAvgFacePoints(points, faces, facePoints)
      val avgMidEdges: ArrayBuffer[Point] = getAvgMidEdges(points, edgesFaces)
      val pointsFaces: ArrayBuffer[BigInt] = getPointsFaces(points, faces)
      var newPoints: ArrayBuffer[Point] = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges)
      var facePointNums: ArrayBuffer[BigInt] = ArrayBuffer()
      var nextPoint: Int = (newPoints).size
      for (fp <- facePoints) {
        newPoints = newPoints :+ fp.asInstanceOf[Point]
        facePointNums = facePointNums :+ nextPoint.asInstanceOf[BigInt]
        nextPoint = (nextPoint + BigInt(1)).asInstanceOf[Int]
      }
      var edgePointNums: scala.collection.mutable.Map[String,BigInt] = scala.collection.mutable.Map()
      var idx: BigInt = BigInt(0)
      while (idx < (edgesFaces).size) {
        val e: Edge = edgesFaces((idx).toInt)
        newPoints = newPoints :+ edgePoints((idx).toInt)
        edgePointNums.update(key(e.pn1, e.pn2), nextPoint)
        nextPoint = (nextPoint + BigInt(1)).asInstanceOf[Int]
        idx = (idx + BigInt(1)).asInstanceOf[BigInt]
      }
      var newFaces: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
      var fnum: BigInt = BigInt(0)
      while (fnum < (faces).size) {
        val oldFace: ArrayBuffer[BigInt] = faces((fnum).toInt)
        if ((oldFace).size == BigInt(4)) {
          val a: BigInt = oldFace((BigInt(0)).toInt)
          val b: BigInt = oldFace((BigInt(1)).toInt)
          val c: BigInt = oldFace((BigInt(2)).toInt)
          val d: BigInt = oldFace((BigInt(3)).toInt)
          val fpnum: BigInt = facePointNums((fnum).toInt)
          val ab: BigInt = edgePointNums.getOrElse(key(a, b), null.asInstanceOf[BigInt])
          val da: BigInt = edgePointNums.getOrElse(key(d, a), null.asInstanceOf[BigInt])
          val bc: BigInt = edgePointNums.getOrElse(key(b, c), null.asInstanceOf[BigInt])
          val cd: BigInt = edgePointNums.getOrElse(key(c, d), null.asInstanceOf[BigInt])
          newFaces = newFaces :+ (ArrayBuffer(a, ab, fpnum, da)).asInstanceOf[ArrayBuffer[BigInt]]
          newFaces = newFaces :+ (ArrayBuffer(b, bc, fpnum, ab)).asInstanceOf[ArrayBuffer[BigInt]]
          newFaces = newFaces :+ (ArrayBuffer(c, cd, fpnum, bc)).asInstanceOf[ArrayBuffer[BigInt]]
          newFaces = newFaces :+ (ArrayBuffer(d, da, fpnum, cd)).asInstanceOf[ArrayBuffer[BigInt]]
        }
        fnum = (fnum + BigInt(1)).asInstanceOf[BigInt]
      }
      return ArrayBuffer(newPoints, newFaces)
    }
    def formatPoint(p: Point): String = {
      return "[" + fmt4(p.x) + " " + fmt4(p.y) + " " + fmt4(p.z) + "]"
    }
    def formatFace(f: ArrayBuffer[BigInt]): String = {
      if ((f).size == BigInt(0)) {
        return "[]"
      }
      var s: String = "[" + fmt2(f((BigInt(0)).toInt))
      var i: BigInt = BigInt(1)
      while (i < (f).size) {
        s = s + " " + fmt2(f((i).toInt))
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      s = s + "]"
      return s
    }
    def main(): Any = {
      val inputPoints: ArrayBuffer[Point] = ArrayBuffer(Point(BigInt(0) - 1.0, 1.0, 1.0), Point(BigInt(0) - 1.0, BigInt(0) - 1.0, 1.0), Point(1.0, BigInt(0) - 1.0, 1.0), Point(1.0, 1.0, 1.0), Point(1.0, BigInt(0) - 1.0, BigInt(0) - 1.0), Point(1.0, 1.0, BigInt(0) - 1.0), Point(BigInt(0) - 1.0, BigInt(0) - 1.0, BigInt(0) - 1.0), Point(BigInt(0) - 1.0, 1.0, BigInt(0) - 1.0))
      val inputFaces: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer(ArrayBuffer(BigInt(0), BigInt(1), BigInt(2), BigInt(3)), ArrayBuffer(BigInt(3), BigInt(2), BigInt(4), BigInt(5)), ArrayBuffer(BigInt(5), BigInt(4), BigInt(6), BigInt(7)), ArrayBuffer(BigInt(7), BigInt(0), BigInt(3), BigInt(5)), ArrayBuffer(BigInt(7), BigInt(6), BigInt(1), BigInt(0)), ArrayBuffer(BigInt(6), BigInt(1), BigInt(2), BigInt(4)))
      var outputPoints: ArrayBuffer[Point] = inputPoints
      var outputFaces: ArrayBuffer[ArrayBuffer[BigInt]] = inputFaces
      var i: BigInt = BigInt(0)
      while (i < BigInt(1)) {
        val res: ArrayBuffer[Any] = cmcSubdiv(outputPoints, outputFaces)
        outputPoints = (res((BigInt(0)).toInt)).asInstanceOf[ArrayBuffer[Point]]
        outputFaces = (res((BigInt(1)).toInt)).asInstanceOf[ArrayBuffer[ArrayBuffer[BigInt]]]
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      for (p <- outputPoints) {
        println(formatPoint(p.asInstanceOf[Point]))
      }
      println("")
      for (f <- outputFaces) {
        println(formatFace(f.asInstanceOf[ArrayBuffer[BigInt]]))
      }
    }
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
