// Generated by Mochi v0.10.40 on 2025-07-26 04:48:57 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  case class Pixel(var r: Int, var g: Int, var b: Int)
  
  def pixelFromRgb(rgb: Int): Pixel = {
    val r: Int = (Math.floorMod(rgb / 65536, 256)).asInstanceOf[Int]
    val g: Int = (Math.floorMod(rgb / 256, 256)).asInstanceOf[Int]
    val b: Int = (Math.floorMod(rgb, 256)).asInstanceOf[Int]
    return Pixel(r, g, b)
  }
  
  def newBitmap(cols: Int, rows: Int): Map[String,Any] = {
    var d: ArrayBuffer[ArrayBuffer[Pixel]] = ArrayBuffer()
    var y: Int = 0
    while (y < rows) {
      var row: ArrayBuffer[Pixel] = ArrayBuffer()
      var x: Int = 0
      while (x < cols) {
        row = row :+ Pixel(0, 0, 0)
        x = (x + 1).asInstanceOf[Int]
      }
      d = d :+ row
      y = (y + 1).asInstanceOf[Int]
    }
    return Map("cols" -> (cols), "rows" -> (rows), "data" -> (d))
  }
  
  def setPx(b: Map[String,Any], x: Int, y: Int, p: Pixel): Any = {
    val cols: Int = (b.getOrElse("cols", null.asInstanceOf[Any])).asInstanceOf[Int]
    val rows: Int = (b.getOrElse("rows", null.asInstanceOf[Any])).asInstanceOf[Int]
    if ((((x >= 0 && x < cols).asInstanceOf[Boolean] && y >= 0).asInstanceOf[Boolean] && y < rows).asInstanceOf[Boolean]) {
      b.getOrElse("data", null.asInstanceOf[Any])(y)(x) = p
    }
  }
  
  def fill(b: Map[String,Any], p: Pixel): Any = {
    val cols: Int = (b.getOrElse("cols", null.asInstanceOf[Any])).asInstanceOf[Int]
    val rows: Int = (b.getOrElse("rows", null.asInstanceOf[Any])).asInstanceOf[Int]
    var y: Int = 0
    while (y < rows) {
      var x: Int = 0
      while (x < cols) {
        b.getOrElse("data", null.asInstanceOf[Any])(y)(x) = p
        x = (x + 1).asInstanceOf[Int]
      }
      y = (y + 1).asInstanceOf[Int]
    }
  }
  
  def fillRgb(b: Map[String,Any], rgb: Int): Any = {
    fill(b, pixelFromRgb(rgb))
  }
  
  def line(b: Map[String,Any], _x0: Int, _y0: Int, x1: Int, y1: Int, p: Pixel): Any = {
    var x0: Int = _x0
    var y0: Int = _y0
    var dx = x1 - x0
    if (dx < 0) {
      dx = (0 - dx).asInstanceOf[Int]
    }
    var dy = y1 - y0
    if (dy < 0) {
      dy = (0 - dy).asInstanceOf[Int]
    }
    var sx: Int = 0 - 1
    if (x0 < x1) {
      sx = 1
    }
    var sy: Int = 0 - 1
    if (y0 < y1) {
      sy = 1
    }
    var err = dx - dy
    val _br4 = new Breaks
    _br4.breakable {
      while (true) {
        setPx(b, x0, y0, p)
        if ((x0 == x1 && y0 == y1).asInstanceOf[Boolean]) {
          _br4.break()
        }
        val e2 = 2 * err
        if (e2 > (0 - dy).asInstanceOf[Int]) {
          err = (err - dy).asInstanceOf[Int]
          x0 = (x0 + sx).asInstanceOf[Int]
        }
        if (e2 < dx) {
          err = (err + dx).asInstanceOf[Int]
          y0 = (y0 + sy).asInstanceOf[Int]
        }
      }
    }
  }
  
  def bezier3(b: Map[String,Any], x1: Int, y1: Int, x2: Int, y2: Int, x3: Int, y3: Int, x4: Int, y4: Int, p: Pixel): Any = {
    var px: ArrayBuffer[Int] = ArrayBuffer()
    var py: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = 0
    while (i <= b3Seg) {
      px = px :+ 0
      py = py :+ 0
      i = (i + 1).asInstanceOf[Int]
    }
    val fx1: Double = x1.toString.toDouble
    val fy1: Double = y1.toString.toDouble
    val fx2: Double = x2.toString.toDouble
    val fy2: Double = y2.toString.toDouble
    val fx3: Double = x3.toString.toDouble
    val fy3: Double = y3.toString.toDouble
    val fx4: Double = x4.toString.toDouble
    val fy4: Double = y4.toString.toDouble
    i = 0
    while (i <= b3Seg) {
      val d: Double = i.toString.toDouble / b3Seg.toString.toDouble
      var a: Double = 1.0 - d
      var bcoef = a * a
      var ccoef = d * d
      var a2 = a * bcoef
      var b2: Double = 3.0 * bcoef * d
      var c2: Double = 3.0 * a * ccoef
      var d2 = ccoef * d
      px(i) = ((a2 * fx1).toString.toDouble + (b2 * fx2).toString.toDouble + c2 * fx3 + d2 * fx4).asInstanceOf[Int]
      py(i) = ((a2 * fy1).toString.toDouble + (b2 * fy2).toString.toDouble + c2 * fy3 + d2 * fy4).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    var x0: Int = px(0)
    var y0: Int = py(0)
    i = 1
    while (i <= b3Seg) {
      val x: Int = px(i)
      val y: Int = py(i)
      line(b, x0, y0, x, y, p)
      x0 = x
      y0 = y
      i = (i + 1).asInstanceOf[Int]
    }
  }
  
  val b3Seg: Int = 30
  
  var b: Map[String,Any] = newBitmap(400, 300)
  
  def main(args: Array[String]): Unit = {
    fillRgb(b, 16773055)
    bezier3(b, 20, 200, 700, 50, 0 - 300, 50, 380, 150, pixelFromRgb(4165615))
  }
}
