// Generated by Mochi v0.10.55 on 2025-08-02 17:07:10 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _parseIntStr(s: String, base: BigInt): BigInt = BigInt(s, base.toInt)

def parseIntStr(str: String): BigInt = {
  var i: BigInt = BigInt(0)
  var neg: Boolean = false
  if (((str).size > BigInt(0) && str.slice((BigInt(0)).toInt, (BigInt(1)).toInt) == "-").asInstanceOf[Boolean]) {
    neg = true
    i = BigInt(1)
  }
  var n: BigInt = BigInt(0)
  val digits: Map[String,BigInt] = scala.collection.mutable.Map("0" -> (BigInt(0)), "1" -> (BigInt(1)), "2" -> (BigInt(2)), "3" -> (BigInt(3)), "4" -> (BigInt(4)), "5" -> (BigInt(5)), "6" -> (BigInt(6)), "7" -> (BigInt(7)), "8" -> (BigInt(8)), "9" -> (BigInt(9)))
  while (i < (str).size) {
    n = n * BigInt(10) + digits(str.slice((i).toInt, (i + BigInt(1)).toInt)).asInstanceOf[BigInt]
    i = i + BigInt(1)
  }
  if (neg) {
    n = BigInt(0) - n
  }
  return n
}

def fields(s: String): ArrayBuffer[String] = {
  var words: ArrayBuffer[String] = ArrayBuffer()
  var cur: String = ""
  var i: BigInt = BigInt(0)
  while (i < (s).size) {
    val ch: String = s.slice((i).toInt, (i + BigInt(1)).toInt)
    if (((ch == " " || ch == "\t").asInstanceOf[Boolean] || ch == "\n").asInstanceOf[Boolean]) {
      if ((cur).size > BigInt(0)) {
        words = words :+ cur
        cur = ""
      }
    } else {
      cur = (cur + ch).toString
    }
    i = i + BigInt(1)
  }
  if ((cur).size > BigInt(0)) {
    words = words :+ cur
  }
  return words
}

def unescape(s: String): String = {
  var out: String = ""
  var i: BigInt = BigInt(0)
  val _ct2 = new Breaks
  while (i < (s).size) {
    _ct2.breakable {
      if ((s.slice((i).toInt, (i + BigInt(1)).toInt) == "\\" && i + BigInt(1) < (s).size).asInstanceOf[Boolean]) {
        val c: String = s.slice((i + BigInt(1)).toInt, (i + BigInt(2)).toInt)
        if (c == "n") {
          out = out + "\n"
          i = i + BigInt(2)
          _ct2.break()
        } else {
          if (c == "\\") {
            out = out + "\\"
            i = i + BigInt(2)
            _ct2.break()
          }
        }
      }
      out = out + s.slice((i).toInt, (i + BigInt(1)).toInt)
      i = i + BigInt(1)
    }
  }
  return out
}

def parseProgram(src: String): scala.collection.mutable.Map[String,Any] = {
  val lines = ArrayBuffer(src.split("\n"): _*)
  val header: ArrayBuffer[String] = fields(lines((BigInt(0).toInt).toInt))
  val dataSize = _parseIntStr(header((BigInt(1).toInt).toInt), BigInt(10))
  val nStrings = _parseIntStr(header((BigInt(3).toInt).toInt), BigInt(10))
  var stringPool: ArrayBuffer[String] = ArrayBuffer()
  var i: BigInt = BigInt(1)
  while (i <= nStrings) {
    val s: String = lines((i.toInt).toInt)
    if ((s).size > BigInt(0)) {
      stringPool = stringPool :+ unescape(s.slice((BigInt(1)).toInt, ((s).size - BigInt(1).toInt).toInt))
    }
    i = i + BigInt(1)
  }
  var code: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = ArrayBuffer()
  var addrMap: scala.collection.mutable.Map[BigInt,BigInt] = scala.collection.mutable.Map()
  val _br4 = new Breaks
  _br4.breakable {
    while (i < (lines).size) {
      val line: String = trim(lines((i.toInt).toInt))
      if ((line).size == BigInt(0)) {
        _br4.break()
      }
      val parts: ArrayBuffer[String] = fields(line)
      val addr = _parseIntStr(parts((BigInt(0).toInt).toInt), BigInt(10))
      val op: String = parts((BigInt(1).toInt).toInt)
      var arg: BigInt = BigInt(0)
      if (op == "push") {
        arg = BigInt((_parseIntStr(parts((BigInt(2).toInt).toInt), BigInt(10))).toString)
      } else {
        if ((op == "fetch" || op == "store").asInstanceOf[Boolean]) {
          arg = BigInt((_parseIntStr(parts((BigInt(2).toInt).toInt).slice((BigInt(1)).toInt, ((parts((BigInt(2).toInt).toInt)).size - BigInt(1).toInt).toInt), BigInt(10))).toString)
        } else {
          if ((op == "jmp" || op == "jz").asInstanceOf[Boolean]) {
            arg = BigInt((_parseIntStr(parts((BigInt(3).toInt).toInt), BigInt(10))).toString)
          }
        }
      }
      code = code :+ (scala.collection.mutable.Map("addr" -> (addr), "op" -> (op), "arg" -> (arg))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
      addrMap.update(addr, (code).size - BigInt(1).toInt)
      i = i + BigInt(1)
    }
  }
  return (scala.collection.mutable.Map("dataSize" -> (dataSize), "strings" -> (stringPool), "code" -> (code), "addrMap" -> (addrMap))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
}

def runVM(prog: scala.collection.mutable.Map[String,Any]): Any = {
  var data: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = BigInt(0)
  while (i < BigInt((prog("dataSize")).toString)) {
    data = data :+ BigInt(0)
    i = i + BigInt(1)
  }
  var stack: ArrayBuffer[BigInt] = ArrayBuffer()
  var pc: BigInt = BigInt(0)
  val code = prog("code")
  val addrMap: scala.collection.mutable.Map[Any,Any] = (prog("addrMap")).asInstanceOf[scala.collection.mutable.Map[Any,Any]]
  val pool = prog("strings")
  var line: String = ""
  val _br6 = new Breaks
  val _ct6 = new Breaks
  _br6.breakable {
    while (pc < (code.asInstanceOf[ArrayBuffer[Any]]).size) {
      _ct6.breakable {
        val inst = code.asInstanceOf[ArrayBuffer[Any]]((pc.toInt).toInt)
        val op = inst.asInstanceOf[Map[String,String]]("op").asInstanceOf[String]
        val arg = inst.asInstanceOf[Map[String,BigInt]]("arg").asInstanceOf[BigInt]
        if (op == "push") {
          stack = stack :+ BigInt(arg.toString)
          pc = pc + BigInt(1)
          _ct6.break()
        }
        if (op == "store") {
          data((arg).toInt) = stack(((stack).size - BigInt(1).toInt.toInt).toInt)
          stack = (stack.slice((BigInt(0)).toInt, ((stack).size - BigInt(1).toInt).toInt)).asInstanceOf[ArrayBuffer[BigInt]]
          pc = pc + BigInt(1)
          _ct6.break()
        }
        if (op == "fetch") {
          stack = stack :+ data((arg.toInt).toInt)
          pc = pc + BigInt(1)
          _ct6.break()
        }
        if (op == "add") {
          stack(((stack).size - BigInt(2).toInt).toInt) = stack(((stack).size - BigInt(2).toInt.toInt).toInt) + stack(((stack).size - BigInt(1).toInt.toInt).toInt)
          stack = (stack.slice((BigInt(0)).toInt, ((stack).size - BigInt(1).toInt).toInt)).asInstanceOf[ArrayBuffer[BigInt]]
          pc = pc + BigInt(1)
          _ct6.break()
        }
        if (op == "lt") {
          var v: BigInt = BigInt(0)
          if (stack(((stack).size - BigInt(2).toInt.toInt).toInt) < stack(((stack).size - BigInt(1).toInt.toInt).toInt)) {
            v = BigInt(1)
          }
          stack(((stack).size - BigInt(2).toInt).toInt) = v
          stack = (stack.slice((BigInt(0)).toInt, ((stack).size - BigInt(1).toInt).toInt)).asInstanceOf[ArrayBuffer[BigInt]]
          pc = pc + BigInt(1)
          _ct6.break()
        }
        if (op == "jz") {
          val v: BigInt = stack(((stack).size - BigInt(1).toInt.toInt).toInt)
          stack = (stack.slice((BigInt(0)).toInt, ((stack).size - BigInt(1).toInt).toInt)).asInstanceOf[ArrayBuffer[BigInt]]
          if (v == BigInt(0)) {
            pc = BigInt((addrMap(arg.toInt)).toString)
          } else {
            pc = pc + BigInt(1)
          }
          _ct6.break()
        }
        if (op == "jmp") {
          pc = BigInt((addrMap(arg.toInt)).toString)
          _ct6.break()
        }
        if (op == "prts") {
          val s = pool.asInstanceOf[ArrayBuffer[Any]]((stack(((stack).size - BigInt(1).toInt.toInt).toInt).toInt).toInt)
          stack = (stack.slice((BigInt(0)).toInt, ((stack).size - BigInt(1).toInt).toInt)).asInstanceOf[ArrayBuffer[BigInt]]
          if (s != "\n") {
            line = (line + s).toString
          }
          pc = pc + BigInt(1)
          _ct6.break()
        }
        if (op == "prti") {
          line = line + String.valueOf(stack(((stack).size - BigInt(1).toInt.toInt).toInt))
          println(line)
          line = ""
          stack = (stack.slice((BigInt(0)).toInt, ((stack).size - BigInt(1).toInt).toInt)).asInstanceOf[ArrayBuffer[BigInt]]
          pc = pc + BigInt(1)
          _ct6.break()
        }
        if (op == "halt") {
          _br6.break()
        }
        pc = pc + BigInt(1)
      }
    }
  }
}

def trim(s: String): String = {
  var start: BigInt = BigInt(0)
  while (start < (s).size && (s.slice((start).toInt, (start + BigInt(1)).toInt) == " " || s.slice((start).toInt, (start + BigInt(1)).toInt) == "\t").asInstanceOf[Boolean]) {
    start = start + BigInt(1)
  }
  var end: Int = (s).size
  while (end > start && (s.slice((end - BigInt(1).toInt).toInt, (end).toInt) == " " || s.slice((end - BigInt(1).toInt).toInt, (end).toInt) == "\t").asInstanceOf[Boolean]) {
    end = end - BigInt(1).toInt.toInt
  }
  return s.slice((start).toInt, (end).toInt)
}

def split(s: String, sep: String): ArrayBuffer[String] = {
  var parts: ArrayBuffer[String] = ArrayBuffer()
  var cur: String = ""
  var i: BigInt = BigInt(0)
  while (i < (s).size) {
    if ((((sep).size > BigInt(0) && i + (sep).size <= (s).size).asInstanceOf[Boolean] && s.slice((i).toInt, (i + (sep).size).toInt) == sep).asInstanceOf[Boolean]) {
      parts = parts :+ cur
      cur = ""
      i = i + (sep).size
    } else {
      cur = cur + s.slice((i).toInt, (i + BigInt(1)).toInt)
      i = i + BigInt(1)
    }
  }
  parts = parts :+ cur
  return parts
}

def main(): Any = {
  val programText: String = "Datasize: 1 Strings: 2\n" + "\"count is: \"\n" + "\"\\n\"\n" + "    0 push  1\n" + "    5 store [0]\n" + "   10 fetch [0]\n" + "   15 push  10\n" + "   20 lt\n" + "   21 jz     (43) 65\n" + "   26 push  0\n" + "   31 prts\n" + "   32 fetch [0]\n" + "   37 prti\n" + "   38 push  1\n" + "   43 prts\n" + "   44 fetch [0]\n" + "   49 push  1\n" + "   54 add\n" + "   55 store [0]\n" + "   60 jmp    (-51) 10\n" + "   65 halt\n"
  val prog: scala.collection.mutable.Map[String,Any] = parseProgram(programText)
  runVM(prog)
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
