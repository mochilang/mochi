// Generated by Mochi v0.10.41 on 2025-07-27 16:19:23 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private def _parseIntStr(s: String, base: BigInt): BigInt = BigInt(s, base.toInt)
  
  def parseIntStr(str: String): BigInt = {
    var i: BigInt = BigInt(0)
    var neg: Boolean = false
    if (((str).size > BigInt(0) && str.slice((BigInt(0)).toInt, (BigInt(1)).toInt) == "-").asInstanceOf[Boolean]) {
      neg = true
      i = BigInt(1)
    }
    var n: BigInt = BigInt(0)
    val digits: Map[String,BigInt] = scala.collection.mutable.Map("0" -> (BigInt(0)), "1" -> (BigInt(1)), "2" -> (BigInt(2)), "3" -> (BigInt(3)), "4" -> (BigInt(4)), "5" -> (BigInt(5)), "6" -> (BigInt(6)), "7" -> (BigInt(7)), "8" -> (BigInt(8)), "9" -> (BigInt(9)))
    while (i < (str).size) {
      n = (n * BigInt(10) + digits.getOrElse(str.slice((i).toInt, (i + BigInt(1)).toInt), null.asInstanceOf[BigInt])).asInstanceOf[BigInt]
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    if (neg) {
      n = (BigInt(0) - n).asInstanceOf[BigInt]
    }
    return n
  }
  
  def fields(s: String): ArrayBuffer[String] = {
    var words: ArrayBuffer[String] = ArrayBuffer()
    var cur: String = ""
    var i: BigInt = BigInt(0)
    while (i < (s).size) {
      val ch: String = s.slice((i).toInt, (i + BigInt(1)).toInt)
      if (((ch == " " || ch == "\t").asInstanceOf[Boolean] || ch == "\n").asInstanceOf[Boolean]) {
        if ((cur).size > BigInt(0)) {
          words = words :+ cur
          cur = ""
        }
      } else {
        cur = (cur + ch).toString
      }
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    if ((cur).size > BigInt(0)) {
      words = words :+ cur
    }
    return words
  }
  
  def unescape(s: String): String = {
    var out: String = ""
    var i: BigInt = BigInt(0)
    val _ct2 = new Breaks
    while (i < (s).size) {
      _ct2.breakable {
        if ((s.slice((i).toInt, (i + BigInt(1)).toInt) == "\\" && (i + BigInt(1)).asInstanceOf[Int] < (s).size).asInstanceOf[Boolean]) {
          val c: String = s.slice((i + BigInt(1)).toInt, (i + BigInt(2)).toInt)
          if (c == "n") {
            out = out + "\n"
            i = (i + BigInt(2)).asInstanceOf[BigInt]
            _ct2.break()
          } else {
            if (c == "\\") {
              out = out + "\\"
              i = (i + BigInt(2)).asInstanceOf[BigInt]
              _ct2.break()
            }
          }
        }
        out = out + s.slice((i).toInt, (i + BigInt(1)).toInt)
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
    }
    return out
  }
  
  def parseProgram(src: String): scala.collection.mutable.Map[String,Any] = {
    val lines: ArrayBuffer[String] = split(src, "\n")
    val header: ArrayBuffer[String] = fields(lines((BigInt(0)).toInt))
    val dataSize = _parseIntStr(header((BigInt(1)).toInt), BigInt(10))
    val nStrings = _parseIntStr(header((BigInt(3)).toInt), BigInt(10))
    var stringPool: ArrayBuffer[String] = ArrayBuffer()
    var i: BigInt = BigInt(1)
    while (i <= nStrings) {
      val s: String = lines((i).toInt)
      if ((s).size > BigInt(0)) {
        stringPool = stringPool :+ unescape(s.slice((BigInt(1)).toInt, ((s).size - BigInt(1)).toInt))
      }
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    var code: ArrayBuffer[scala.collection.mutable.Map[String,Any]] = ArrayBuffer()
    var addrMap: scala.collection.mutable.Map[BigInt,BigInt] = scala.collection.mutable.Map()
    val _br4 = new Breaks
    _br4.breakable {
      while (i < (lines).size) {
        val line: String = trim(lines((i).toInt))
        if ((line).size == BigInt(0)) {
          _br4.break()
        }
        val parts: ArrayBuffer[String] = fields(line)
        val addr = _parseIntStr(parts((BigInt(0)).toInt), BigInt(10))
        val op: String = parts((BigInt(1)).toInt)
        var arg: BigInt = BigInt(0)
        if (op == "push") {
          arg = (_parseIntStr(parts((BigInt(2)).toInt), BigInt(10))).asInstanceOf[BigInt]
        } else {
          if ((op == "fetch" || op == "store").asInstanceOf[Boolean]) {
            arg = (_parseIntStr(parts((BigInt(2)).toInt).slice((BigInt(1)).toInt, ((parts((BigInt(2)).toInt)).size - BigInt(1)).toInt), BigInt(10))).asInstanceOf[BigInt]
          } else {
            if ((op == "jmp" || op == "jz").asInstanceOf[Boolean]) {
              arg = (_parseIntStr(parts((BigInt(3)).toInt), BigInt(10))).asInstanceOf[BigInt]
            }
          }
        }
        code = code :+ (scala.collection.mutable.Map("addr" -> (addr), "op" -> (op), "arg" -> (arg))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
        addrMap.update(addr, (code).size - BigInt(1))
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
    }
    return (scala.collection.mutable.Map("dataSize" -> (dataSize), "strings" -> (stringPool), "code" -> (code), "addrMap" -> (addrMap))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
  }
  
  def runVM(prog: scala.collection.mutable.Map[String,Any]): Any = {
    var data: ArrayBuffer[BigInt] = ArrayBuffer()
    var i: BigInt = BigInt(0)
    while (i < prog.getOrElse("dataSize", null.asInstanceOf[Any])) {
      data = data :+ BigInt(0)
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    var stack: ArrayBuffer[BigInt] = ArrayBuffer()
    var pc: BigInt = BigInt(0)
    val code = prog.getOrElse("code", null.asInstanceOf[Any])
    val addrMap = prog.getOrElse("addrMap", null.asInstanceOf[Any])
    val pool = prog.getOrElse("strings", null.asInstanceOf[Any])
    var line: String = ""
    val _br6 = new Breaks
    val _ct6 = new Breaks
    _br6.breakable {
      while (pc < (code.toString).size) {
        _ct6.breakable {
          val inst = code.asInstanceOf[ArrayBuffer[Any]](pc)
          val op = inst.asInstanceOf[Map[String,Any]]("op")
          val arg = inst.asInstanceOf[Map[String,Any]]("arg")
          if (op == "push") {
            stack = stack :+ arg.asInstanceOf[BigInt]
            pc = (pc + BigInt(1)).asInstanceOf[BigInt]
            _ct6.break()
          }
          if (op == "store") {
            data((arg).toInt) = stack(((stack).size - BigInt(1)).toInt)
            stack = (slice(stack, BigInt(0), (stack).size - BigInt(1))).asInstanceOf[ArrayBuffer[BigInt]]
            pc = (pc + BigInt(1)).asInstanceOf[BigInt]
            _ct6.break()
          }
          if (op == "fetch") {
            stack = stack :+ data((arg).toInt)
            pc = (pc + BigInt(1)).asInstanceOf[BigInt]
            _ct6.break()
          }
          if (op == "add") {
            stack(((stack).size - BigInt(2)).toInt) = stack(((stack).size - BigInt(2)).toInt) + stack(((stack).size - BigInt(1)).toInt)
            stack = (slice(stack, BigInt(0), (stack).size - BigInt(1))).asInstanceOf[ArrayBuffer[BigInt]]
            pc = (pc + BigInt(1)).asInstanceOf[BigInt]
            _ct6.break()
          }
          if (op == "lt") {
            var v: BigInt = BigInt(0)
            if (stack(((stack).size - BigInt(2)).toInt) < stack(((stack).size - BigInt(1)).toInt)) {
              v = BigInt(1)
            }
            stack(((stack).size - BigInt(2)).toInt) = v
            stack = (slice(stack, BigInt(0), (stack).size - BigInt(1))).asInstanceOf[ArrayBuffer[BigInt]]
            pc = (pc + BigInt(1)).asInstanceOf[BigInt]
            _ct6.break()
          }
          if (op == "jz") {
            val v: BigInt = stack(((stack).size - BigInt(1)).toInt)
            stack = (slice(stack, BigInt(0), (stack).size - BigInt(1))).asInstanceOf[ArrayBuffer[BigInt]]
            if (v == BigInt(0)) {
              pc = (addrMap.asInstanceOf[ArrayBuffer[Any]](arg)).asInstanceOf[BigInt]
            } else {
              pc = (pc + BigInt(1)).asInstanceOf[BigInt]
            }
            _ct6.break()
          }
          if (op == "jmp") {
            pc = (addrMap.asInstanceOf[ArrayBuffer[Any]](arg)).asInstanceOf[BigInt]
            _ct6.break()
          }
          if (op == "prts") {
            val s = pool.asInstanceOf[ArrayBuffer[Any]](stack(((stack).size - BigInt(1)).toInt))
            stack = (slice(stack, BigInt(0), (stack).size - BigInt(1))).asInstanceOf[ArrayBuffer[BigInt]]
            if (s != "\n") {
              line = line + s.toString
            }
            pc = (pc + BigInt(1)).asInstanceOf[BigInt]
            _ct6.break()
          }
          if (op == "prti") {
            line = (line + String.valueOf(stack(((stack).size - BigInt(1)).toInt))).toString
            println(line)
            line = ""
            stack = (slice(stack, BigInt(0), (stack).size - BigInt(1))).asInstanceOf[ArrayBuffer[BigInt]]
            pc = (pc + BigInt(1)).asInstanceOf[BigInt]
            _ct6.break()
          }
          if (op == "halt") {
            _br6.break()
          }
          pc = (pc + BigInt(1)).asInstanceOf[BigInt]
        }
      }
    }
  }
  
  def trim(s: String): String = {
    var start: BigInt = BigInt(0)
    while (start < (s).size && (s.slice((start).toInt, (start + BigInt(1)).toInt) == " " || s.slice((start).toInt, (start + BigInt(1)).toInt) == "\t").asInstanceOf[Boolean]) {
      start = (start + BigInt(1)).asInstanceOf[BigInt]
    }
    var end: Int = (s).size
    while (end > start && (s.slice((end - BigInt(1)).toInt, (end).toInt) == " " || s.slice((end - BigInt(1)).toInt, (end).toInt) == "\t").asInstanceOf[Boolean]) {
      end = (end - BigInt(1)).asInstanceOf[Int]
    }
    return s.slice((start).toInt, (end).toInt)
  }
  
  def split(s: String, sep: String): ArrayBuffer[String] = {
    var parts: ArrayBuffer[String] = ArrayBuffer()
    var cur: String = ""
    var i: BigInt = BigInt(0)
    while (i < (s).size) {
      if ((((sep).size > BigInt(0) && (i + (sep).size).asInstanceOf[Int] <= (s).size).asInstanceOf[Boolean] && s.slice((i).toInt, (i + (sep).size).toInt) == sep).asInstanceOf[Boolean]) {
        parts = parts :+ cur
        cur = ""
        i = (i + (sep).size).asInstanceOf[BigInt]
      } else {
        cur = cur + s.slice((i).toInt, (i + BigInt(1)).toInt)
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
    }
    parts = parts :+ cur
    return parts
  }
  
  def main(): Any = {
    val programText: String = "Datasize: 1 Strings: 2\n" + "\"count is: \"\n" + "\"\\n\"\n" + "    0 push  1\n" + "    5 store [0]\n" + "   10 fetch [0]\n" + "   15 push  10\n" + "   20 lt\n" + "   21 jz     (43) 65\n" + "   26 push  0\n" + "   31 prts\n" + "   32 fetch [0]\n" + "   37 prti\n" + "   38 push  1\n" + "   43 prts\n" + "   44 fetch [0]\n" + "   49 push  1\n" + "   54 add\n" + "   55 store [0]\n" + "   60 jmp    (-51) 10\n" + "   65 halt\n"
    val prog: scala.collection.mutable.Map[String,Any] = parseProgram(programText)
    runVM(prog)
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
