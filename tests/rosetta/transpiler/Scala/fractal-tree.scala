// Generated by Mochi v0.10.50 on 2025-07-31 01:08:19 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    val PI: Double = 3.141592653589793
    def _mod(x: Double, m: Double): Double = {
      return x - (BigInt((x / m).toInt)).toString.toDouble * m
    }
    def _sin(x: Double): Double = {
      val y = _mod((x + PI).toString.toDouble, 2.0 * PI) - PI
      val y2 = y * y
      val y3 = y2 * y
      val y5 = y3 * y2
      val y7 = y5 * y2
      return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0
    }
    def _cos(x: Double): Double = {
      val y = _mod((x + PI).toString.toDouble, 2.0 * PI) - PI
      val y2 = y * y
      val y4 = y2 * y2
      val y6 = y4 * y2
      return 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0
    }
    val width: BigInt = BigInt(80)
    val height: BigInt = BigInt(40)
    val depth: BigInt = BigInt(6)
    val angle: Double = 12.0
    val length: Double = 12.0
    val frac: Double = 0.8
    def clearGrid(): ArrayBuffer[ArrayBuffer[String]] = {
      var g: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer()
      var y: BigInt = BigInt(0)
      while (y < height) {
        var row: ArrayBuffer[String] = ArrayBuffer()
        var x: BigInt = BigInt(0)
        while (x < width) {
          row = row :+ " "
          x = x + BigInt(1)
        }
        g = g :+ row
        y = y + BigInt(1)
      }
      return g
    }
    def drawPoint(g: ArrayBuffer[ArrayBuffer[String]], x: BigInt, y: BigInt): Any = {
      if ((((x >= BigInt(0) && x < width).asInstanceOf[Boolean] && y >= BigInt(0)).asInstanceOf[Boolean] && y < height).asInstanceOf[Boolean]) {
        var row: ArrayBuffer[String] = g((y).toInt)
        row((x).toInt) = "#"
        g((y).toInt) = row
      }
    }
    def bresenham(_x0: BigInt, _y0: BigInt, x1: BigInt, y1: BigInt, g: ArrayBuffer[ArrayBuffer[String]]): Any = {
      var x0: BigInt = _x0
      var y0: BigInt = _y0
      var dx: BigInt = x1 - x0
      if (dx < BigInt(0)) {
        dx = BigInt(0) - dx
      }
      var dy: BigInt = y1 - y0
      if (dy < BigInt(0)) {
        dy = BigInt(0) - dy
      }
      var sx: BigInt = BigInt(0) - BigInt(1)
      if (x0 < x1) {
        sx = BigInt(1)
      }
      var sy: BigInt = BigInt(0) - BigInt(1)
      if (y0 < y1) {
        sy = BigInt(1)
      }
      var err: BigInt = dx - dy
      val _br2 = new Breaks
      _br2.breakable {
        while (true) {
          drawPoint(g, x0, y0)
          if ((x0 == x1 && y0 == y1).asInstanceOf[Boolean]) {
            _br2.break()
          }
          var e2: BigInt = BigInt(2) * err
          if (e2 > BigInt(0) - dy) {
            err = err - dy
            x0 = x0 + sx
          }
          if (e2 < dx) {
            err = err + dx
            y0 = y0 + sy
          }
        }
      }
    }
    def ftree(g: ArrayBuffer[ArrayBuffer[String]], x: Double, y: Double, dist: Double, dir: Double, d: BigInt): Any = {
      val rad: Double = dir * PI / 180.0
      val x2 = x + dist * _sin(rad)
      val y2 = y - dist * _cos(rad)
      bresenham(BigInt(x.toInt), BigInt(y.toInt), BigInt(x2.toInt), BigInt(y2.toInt), g)
      if (d > BigInt(0)) {
        ftree(g, x2, y2, (dist * frac).toString.toDouble, (dir - angle).toString.toDouble, d - BigInt(1))
        ftree(g, x2, y2, (dist * frac).toString.toDouble, (dir + angle).toString.toDouble, d - BigInt(1))
      }
    }
    def render(g: ArrayBuffer[ArrayBuffer[String]]): String = {
      var out: String = ""
      var y: BigInt = BigInt(0)
      while (y < height) {
        var line: String = ""
        var x: BigInt = BigInt(0)
        while (x < width) {
          line = (line + g((y).toInt)((x).toInt)).toString
          x = x + BigInt(1)
        }
        out = (out + line).toString
        if (y < height - BigInt(1)) {
          out = out + "\n"
        }
        y = y + BigInt(1)
      }
      return out
    }
    def main(): Any = {
      var grid: ArrayBuffer[ArrayBuffer[String]] = clearGrid()
      ftree(grid, (width / BigInt(2)).toString.toDouble, (height - BigInt(1)).toString.toDouble, length, 0.0, depth)
      println(render(grid))
    }
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
