// Generated by Mochi v0.10.40 on 2025-07-25 12:56:22 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def shuffleStr(s: String): String = {
  var arr: ArrayBuffer[String] = ArrayBuffer()
  var i: Int = 0
  while (i < (s).size) {
    arr = arr :+ s.slice(i, i + 1)
    i = (i + 1).asInstanceOf[Int]
  }
  var j: Int = (arr).size - 1
  while (j > 0) {
    val k = Math.floorMod(_now(), j + 1)
    val tmp: String = arr(j)
    arr(j) = arr(k)
    arr(k) = tmp
    j = (j - 1).asInstanceOf[Int]
  }
  var out: String = ""
  i = 0
  while (i < (arr).size) {
    out = (out + arr(i)).asInstanceOf[String]
    i = (i + 1).asInstanceOf[Int]
  }
  return out
}

def createPolybius(): ArrayBuffer[String] = {
  val shuffled: String = shuffleStr(alphabet)
  var labels: ArrayBuffer[String] = ArrayBuffer()
  var li: Int = 0
  while (li < (adfgvx).size) {
    labels = labels :+ adfgvx.slice(li, li + 1)
    li = (li + 1).asInstanceOf[Int]
  }
  println("6 x 6 Polybius square:\n")
  println("  | A D F G V X")
  println("---------------")
  var p: ArrayBuffer[String] = ArrayBuffer()
  var i: Int = 0
  while (i < 6) {
    var row: String = shuffled.slice(i * 6, (i + 1) * 6)
    p = p :+ row
    var line: String = labels(i) + " | "
    var j: Int = 0
    while (j < 6) {
      line = line + row.slice(j, j + 1) + " "
      j = (j + 1).asInstanceOf[Int]
    }
    println(line)
    i = (i + 1).asInstanceOf[Int]
  }
  return p
}

def createKey(n: Int): String = {
  if ((n < 7 || n > 12).asInstanceOf[Boolean]) {
    println("Key should be within 7 and 12 letters long.")
  }
  var pool: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  var key: String = ""
  var i: Int = 0
  while (i < n) {
    val idx = Math.floorMod(_now(), (pool).size)
    key = (key + pool(idx)).asInstanceOf[String]
    pool = pool.slice(0, idx) + pool.slice(idx + 1, (pool).size)
    i = (i + 1).asInstanceOf[Int]
  }
  println("\nThe key is " + key)
  return key
}

def orderKey(key: String): ArrayBuffer[Int] = {
  var pairs: ArrayBuffer[Any] = ArrayBuffer()
  var i: Int = 0
  while (i < (key).size) {
    pairs = pairs :+ ArrayBuffer(key.slice(i, i + 1), i)
    i = (i + 1).asInstanceOf[Int]
  }
  var n: Int = (pairs).size
  var m: Int = 0
  while (m < n) {
    var j: Int = 0
    while (j < (n - 1).asInstanceOf[Int]) {
      if ((pairs(j).asInstanceOf[ArrayBuffer[Any]](0)).asInstanceOf[Int] > (pairs(j + 1).asInstanceOf[ArrayBuffer[Any]](0)).asInstanceOf[Int]) {
        val tmp = pairs(j)
        pairs(j) = pairs(j + 1)
        pairs(j + 1) = tmp
      }
      j = (j + 1).asInstanceOf[Int]
    }
    m = (m + 1).asInstanceOf[Int]
  }
  var res: ArrayBuffer[Any] = ArrayBuffer()
  i = 0
  while (i < n) {
    res = res :+ (pairs(i).asInstanceOf[ArrayBuffer[Any]](1)).asInstanceOf[Int]
    i = (i + 1).asInstanceOf[Int]
  }
  return res.asInstanceOf[ArrayBuffer[Int]]
}

def encrypt(polybius: ArrayBuffer[String], key: String, plainText: String): String = {
  var labels: ArrayBuffer[String] = ArrayBuffer()
  var li: Int = 0
  while (li < (adfgvx).size) {
    labels = labels :+ adfgvx.slice(li, li + 1)
    li = (li + 1).asInstanceOf[Int]
  }
  var temp: String = ""
  var i: Int = 0
  while (i < (plainText).size) {
    var r: Int = 0
    while (r < 6) {
      var c: Int = 0
      while (c < 6) {
        if (polybius(r).slice(c, c + 1) == plainText.slice(i, i + 1)) {
          temp = (temp ++ labels.slice(r, r + 1) ++ labels.slice(c, c + 1)).asInstanceOf[String]
        }
        c = (c + 1).asInstanceOf[Int]
      }
      r = (r + 1).asInstanceOf[Int]
    }
    i = (i + 1).asInstanceOf[Int]
  }
  var colLen: Int = (temp).size / (key).size
  if ((Math.floorMod((temp).size, (key).size)).asInstanceOf[Int] > 0) {
    colLen = (colLen + 1).asInstanceOf[Int]
  }
  var table: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer()
  var rIdx: Int = 0
  while (rIdx < colLen) {
    var row: ArrayBuffer[String] = ArrayBuffer()
    var j: Int = 0
    while (j < (key).size) {
      row = row :+ ""
      j = (j + 1).asInstanceOf[Int]
    }
    table = table :+ row
    rIdx = (rIdx + 1).asInstanceOf[Int]
  }
  var idx: Int = 0
  while (idx < (temp).size) {
    val row = idx / (key).size
    val col = Math.floorMod(idx, (key).size)
    table(row)(col) = temp.slice(idx, idx + 1)
    idx = (idx + 1).asInstanceOf[Int]
  }
  val order: ArrayBuffer[Int] = orderKey(key)
  var cols: ArrayBuffer[String] = ArrayBuffer()
  var ci: Int = 0
  while (ci < (key).size) {
    var colStr: String = ""
    var ri: Int = 0
    while (ri < colLen) {
      colStr = (colStr + table(ri)(order(ci))).asInstanceOf[String]
      ri = (ri + 1).asInstanceOf[Int]
    }
    cols = cols :+ colStr
    ci = (ci + 1).asInstanceOf[Int]
  }
  var result: String = ""
  ci = 0
  while (ci < (cols).size) {
    result = (result + cols(ci)).asInstanceOf[String]
    if (ci < (cols).size - 1) {
      result = result + " "
    }
    ci = (ci + 1).asInstanceOf[Int]
  }
  return result
}

def indexOf(s: String, ch: String): Int = {
  var i: Int = 0
  while (i < (s).size) {
    if (s.slice(i, i + 1) == ch) {
      return i
    }
    i = (i + 1).asInstanceOf[Int]
  }
  return 0 - 1
}

def decrypt(polybius: ArrayBuffer[String], key: String, cipherText: String): String = {
  var colStrs: ArrayBuffer[String] = ArrayBuffer()
  var start: Int = 0
  var i: Int = 0
  while (i <= (cipherText).size) {
    if ((i == (cipherText).size || cipherText(i) == " ").asInstanceOf[Boolean]) {
      colStrs = colStrs :+ cipherText.slice(start, i)
      start = (i + 1).asInstanceOf[Int]
    }
    i = (i + 1).asInstanceOf[Int]
  }
  var maxColLen: Int = 0
  i = 0
  while (i < (colStrs).size) {
    if ((colStrs(i)).size > maxColLen) {
      maxColLen = (colStrs(i)).size
    }
    i = (i + 1).asInstanceOf[Int]
  }
  var cols: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer()
  i = 0
  while (i < (colStrs).size) {
    var s: String = colStrs(i)
    var ls: ArrayBuffer[String] = ArrayBuffer()
    var j: Int = 0
    while (j < (s).size) {
      ls = ls :+ s.slice(j, j + 1)
      j = (j + 1).asInstanceOf[Int]
    }
    if ((s).size < maxColLen) {
      var pad: ArrayBuffer[String] = ArrayBuffer()
      var k: Int = 0
      while (k < maxColLen) {
        if (k < (ls).size) {
          pad = pad :+ ls(k)
        } else {
          pad = pad :+ ""
        }
        k = (k + 1).asInstanceOf[Int]
      }
      cols = cols :+ pad
    } else {
      cols = cols :+ ls
    }
    i = (i + 1).asInstanceOf[Int]
  }
  var table: ArrayBuffer[ArrayBuffer[String]] = ArrayBuffer()
  var r: Int = 0
  while (r < maxColLen) {
    var row: ArrayBuffer[String] = ArrayBuffer()
    var c: Int = 0
    while (c < (key).size) {
      row = row :+ ""
      c = (c + 1).asInstanceOf[Int]
    }
    table = table :+ row
    r = (r + 1).asInstanceOf[Int]
  }
  val order: ArrayBuffer[Int] = orderKey(key)
  r = 0
  while (r < maxColLen) {
    var c: Int = 0
    while (c < (key).size) {
      table(r)(order(c)) = cols(c)(r)
      c = (c + 1).asInstanceOf[Int]
    }
    r = (r + 1).asInstanceOf[Int]
  }
  var temp: String = ""
  r = 0
  while (r < (table).size) {
    var j: Int = 0
    while (j < (table(r)).size) {
      temp = (temp + table(r)(j)).asInstanceOf[String]
      j = (j + 1).asInstanceOf[Int]
    }
    r = (r + 1).asInstanceOf[Int]
  }
  var plainText: String = ""
  var idx: Int = 0
  while (idx < (temp).size) {
    val rIdx: Int = indexOf(adfgvx, temp.slice(idx, idx + 1))
    val cIdx: Int = indexOf(adfgvx, temp.slice(idx + 1, idx + 2))
    plainText = (plainText + polybius(rIdx)(cIdx)).asInstanceOf[String]
    idx = (idx + 2).asInstanceOf[Int]
  }
  return plainText
}

def main(): Unit = {
  val plainText: String = "ATTACKAT1200AM"
  val polybius: ArrayBuffer[String] = createPolybius()
  val key: String = createKey(9)
  println("\nPlaintext : " + plainText)
  val cipherText: String = encrypt(polybius, key, plainText)
  println("\nEncrypted : " + cipherText)
  val plainText2: String = decrypt(polybius, key, cipherText)
  println("\nDecrypted : " + plainText2)
}

var adfgvx: String = "ADFGVX"

var alphabet: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

def main(args: Array[String]): Unit = {
  main()
}
}
