// Generated by Mochi v0.10.38 on 2025-07-23 23:59:09 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs(System.nanoTime().toInt)
  }
}

case class MoveResult(idx: Int, ok: Boolean)

def randMove(): Int = {
  return (_now() % 4).asInstanceOf[Int]
}

def isSolved(): Boolean = {
  var i: Int = 0
  while (i < 16) {
    if (board(i).asInstanceOf[Int] != solved(i).asInstanceOf[Int]) {
      return false
    }
    i = (i + 1).asInstanceOf[Int]
  }
  return true
}

def isValidMove(m: Int): MoveResult = {
  if (m == 0) {
    return MoveResult(empty - 4, empty / 4 > 0)
  }
  if (m == 1) {
    return MoveResult(empty + 4, empty / 4 < 3)
  }
  if (m == 2) {
    return MoveResult(empty + 1, empty % 4 < 3)
  }
  if (m == 3) {
    return MoveResult(empty - 1, empty % 4 > 0)
  }
  return MoveResult(0, false)
}

def doMove(m: Int): Boolean = {
  val r = isValidMove(m)
  if ((!r.ok).asInstanceOf[Boolean]) {
    return false
  }
  val i: Int = empty
  val j: Int = r.idx
  val tmp: Int = board(i).asInstanceOf[Int]
  board(i) = board(j).asInstanceOf[Int]
  board(j) = tmp
  empty = j
  moves = (moves + 1).asInstanceOf[Int]
  return true
}

def shuffle(n: Int) = {
  var i: Int = 0
  while (i < n || (isSolved()).asInstanceOf[Boolean]) {
    if ((doMove(randMove())).asInstanceOf[Boolean]) {
      i = (i + 1).asInstanceOf[Int]
    }
  }
}

def printBoard() = {
  var line: String = ""
  var i: Int = 0
  while (i < 16) {
    val `val`: Int = board(i).asInstanceOf[Int]
    if (`val` == 0) {
      line = (line + "  .").asInstanceOf[String]
    } else {
      val s = String.valueOf(`val`)
      if (`val` < 10) {
        line = (line + "  " + s).asInstanceOf[String]
      } else {
        line = (line + " " + s).asInstanceOf[String]
      }
    }
    if (i % 4 == 3) {
      println(line)
      line = ""
    }
    i = (i + 1).asInstanceOf[Int]
  }
}

def playOneMove(): Unit = {
  val _ct3 = new Breaks
  while (true) {
    _ct3.breakable {
      println("Enter move #" + String.valueOf(moves + 1) + " (U, D, L, R, or Q): ")
      val s = Option(scala.io.StdIn.readLine()).getOrElse("q")
      if (s == "") {
        _ct3.break()
      }
      val c = s.slice(0, 1)
      var m: Int = 0
      if ((c == "U" || c == "u").asInstanceOf[Boolean]) {
        m = 0
      } else {
        if ((c == "D" || c == "d").asInstanceOf[Boolean]) {
          m = 1
        } else {
          if ((c == "R" || c == "r").asInstanceOf[Boolean]) {
            m = 2
          } else {
            if ((c == "L" || c == "l").asInstanceOf[Boolean]) {
              m = 3
            } else {
              if ((c == "Q" || c == "q").asInstanceOf[Boolean]) {
                println("Quiting after " + String.valueOf(moves) + " moves.")
                quit = true
                return
              } else {
                println("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" + "up, down, left, or right. You can also enter \"Q\" to quit.\n" + "Upper or lowercase is accepted and only the first non-blank\n" + "character is important (i.e. you may enter \"up\" if you like).")
                _ct3.break()
              }
            }
          }
        }
      }
      if ((!(doMove(m)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
        println("That is not a valid move at the moment.")
        _ct3.break()
      }
      return
    }
  }
}

def play() = {
  println("Starting board:")
  while ((!quit).asInstanceOf[Boolean] && isSolved() == false) {
    println("")
    printBoard()
    playOneMove()
  }
  if ((isSolved()).asInstanceOf[Boolean]) {
    println("You solved the puzzle in " + String.valueOf(moves) + " moves.")
  }
}

def main() = {
  shuffle(50)
  play()
}

var board: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0)

val solved: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0)

var empty: Int = 15

var moves: Int = 0

var quit: Boolean = false

def main(args: Array[String]): Unit = {
  main()
}
}
