// Generated by Mochi v0.10.40 on 2025-07-25 10:49:53 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class MoveResult(var idx: Int, var ok: Boolean)

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    var board: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0)
    val solved: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0)
    var empty: Int = 15
    var moves: Int = 0
    var quit: Boolean = false
    def randMove(): Int = {
      return (Math.floorMod(_now(), 4)).asInstanceOf[Int]
    }
    def isSolved(): Boolean = {
      var i: Int = 0
      while (i < 16) {
        if (board(i) != solved(i)) {
          return false
        }
        i = (i + 1).asInstanceOf[Int]
      }
      return true
    }
    def isValidMove(m: Int): MoveResult = {
      if (m == 0) {
        return MoveResult(empty - 4, (empty / 4).asInstanceOf[Int] > 0)
      }
      if (m == 1) {
        return MoveResult(empty + 4, (empty / 4).asInstanceOf[Int] < 3)
      }
      if (m == 2) {
        return MoveResult(empty + 1, (Math.floorMod(empty, 4)).asInstanceOf[Int] < 3)
      }
      if (m == 3) {
        return MoveResult(empty - 1, (Math.floorMod(empty, 4)).asInstanceOf[Int] > 0)
      }
      return MoveResult(0, false)
    }
    def doMove(m: Int): Boolean = {
      val r: MoveResult = isValidMove(m)
      if ((!r.ok).asInstanceOf[Boolean]) {
        return false
      }
      val i: Int = empty
      val j: Int = r.idx
      val tmp: Int = board(i)
      board(i) = board(j)
      board(j) = tmp
      empty = j
      moves = (moves + 1).asInstanceOf[Int]
      return true
    }
    def shuffle(n: Int): Unit = {
      var i: Int = 0
      while (i < n || isSolved()) {
        if (doMove(randMove())) {
          i = (i + 1).asInstanceOf[Int]
        }
      }
    }
    def printBoard(): Unit = {
      var line: String = ""
      var i: Int = 0
      while (i < 16) {
        val `val`: Int = board(i)
        if (`val` == 0) {
          line = line + "  ."
        } else {
          val s = String.valueOf(`val`)
          if (`val` < 10) {
            line = line + "  " + s
          } else {
            line = line + " " + s
          }
        }
        if (Math.floorMod(i, 4) == 3) {
          println(line)
          line = ""
        }
        i = (i + 1).asInstanceOf[Int]
      }
    }
    def playOneMove(): Unit = {
      val _ct3 = new Breaks
      while (true) {
        _ct3.breakable {
          println("Enter move #" + String.valueOf(moves + 1) + " (U, D, L, R, or Q): ")
          val s = Option(scala.io.StdIn.readLine()).getOrElse("q")
          if (s == "") {
            _ct3.break()
          }
          val c = s.slice(0, 1)
          var m: Int = 0
          if ((c == "U" || c == "u").asInstanceOf[Boolean]) {
            m = 0
          } else {
            if ((c == "D" || c == "d").asInstanceOf[Boolean]) {
              m = 1
            } else {
              if ((c == "R" || c == "r").asInstanceOf[Boolean]) {
                m = 2
              } else {
                if ((c == "L" || c == "l").asInstanceOf[Boolean]) {
                  m = 3
                } else {
                  if ((c == "Q" || c == "q").asInstanceOf[Boolean]) {
                    println("Quiting after " + String.valueOf(moves) + " moves.")
                    quit = true
                    return
                  } else {
                    println("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" + "up, down, left, or right. You can also enter \"Q\" to quit.\n" + "Upper or lowercase is accepted and only the first non-blank\n" + "character is important (i.e. you may enter \"up\" if you like).")
                    _ct3.break()
                  }
                }
              }
            }
          }
          if ((!doMove(m)).asInstanceOf[Boolean]) {
            println("That is not a valid move at the moment.")
            _ct3.break()
          }
          return
        }
      }
    }
    def play(): Unit = {
      println("Starting board:")
      while ((!quit).asInstanceOf[Boolean] && isSolved() == false) {
        println("")
        printBoard()
        playOneMove()
      }
      if (isSolved()) {
        println("You solved the puzzle in " + String.valueOf(moves) + " moves.")
      }
    }
    def main(): Unit = {
      shuffle(50)
      play()
    }
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
