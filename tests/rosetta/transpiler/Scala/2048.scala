// Generated by Mochi v0.10.37 on 2025-07-23 10:26:04 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Int = 0
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed
  } else {
    Math.abs(System.nanoTime().toInt)
  }
}

def newBoard(): ArrayBuffer[ArrayBuffer[Int]] = {
  var b: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
  var y: Int = 0
  while (y < SIZE) {
    var row: ArrayBuffer[Int] = ArrayBuffer()
    var x: Int = 0
    while (x < SIZE) {
      row = row :+ 0
      x = (x + 1).asInstanceOf[Int]
    }
    b = b :+ row
    y = (y + 1).asInstanceOf[Int]
  }
  return b
}

def spawnTile(b: ArrayBuffer[ArrayBuffer[Int]]): Map[String,Any] = {
  var empty: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
  var y: Int = 0
  while (y < SIZE) {
    var x: Int = 0
    while (x < SIZE) {
      if (b(y).asInstanceOf[ArrayBuffer[Any]](x) == 0) {
        empty = empty :+ ArrayBuffer(x, y)
      }
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  if ((empty).size == 0) {
    return Map("board" -> (b), "full" -> (true))
  }
  var idx = _now() % (empty).size
  val cell = empty(idx)
  var `val`: Int = 4
  if (_now() % 10 < 9) {
    `val` = 2
  }
  b(cell(1)).asInstanceOf[ArrayBuffer[Any]](cell(0)) = `val`
  return Map("board" -> (b), "full" -> ((empty).size == 1))
}

def pad(n: Int): String = {
  var s = String.valueOf(n)
  var pad: Int = 4 - (s).size
  var i: Int = 0
  var out: String = ""
  while (i < pad) {
    out = (out + " ").asInstanceOf[String]
    i = (i + 1).asInstanceOf[Int]
  }
  return out + s
}

def draw(b: ArrayBuffer[ArrayBuffer[Int]], score: Int) = {
  println("Score: " + String.valueOf(score))
  var y: Int = 0
  while (y < SIZE) {
    println("+----+----+----+----+")
    var line: String = "|"
    var x: Int = 0
    while (x < SIZE) {
      var v = b(y).asInstanceOf[ArrayBuffer[Any]](x)
      if (v == 0) {
        line = (line + "    |").asInstanceOf[String]
      } else {
        line = (line + pad(v) + "|").asInstanceOf[String]
      }
      x = (x + 1).asInstanceOf[Int]
    }
    println(line)
    y = (y + 1).asInstanceOf[Int]
  }
  println("+----+----+----+----+")
  println("W=Up S=Down A=Left D=Right Q=Quit")
}

def reverseRow(r: ArrayBuffer[Int]): ArrayBuffer[Int] = {
  var out: ArrayBuffer[Int] = ArrayBuffer()
  var i: Int = (r).size - 1
  while (i >= 0) {
    out = out :+ r(i)
    i = (i - 1).asInstanceOf[Int]
  }
  return out
}

def slideLeft(row: ArrayBuffer[Int]): Map[String,Any] = {
  var xs: ArrayBuffer[Int] = ArrayBuffer()
  var i: Int = 0
  while (i < (row).size) {
    if (row(i) != 0) {
      xs = xs :+ row(i)
    }
    i = (i + 1).asInstanceOf[Int]
  }
  var res: ArrayBuffer[Int] = ArrayBuffer()
  var gain: Int = 0
  i = 0
  while (i < (xs).size) {
    if ((i + 1 < (xs).size && xs(i) == xs(i + 1)).asInstanceOf[Boolean]) {
      val v: Int = (xs(i)).asInstanceOf[Int] * 2
      gain = (gain + v).asInstanceOf[Int]
      res = res :+ v
      i = (i + 2).asInstanceOf[Int]
    } else {
      res = res :+ xs(i)
      i = (i + 1).asInstanceOf[Int]
    }
  }
  while ((res).size < SIZE) {
    res = res :+ 0
  }
  return Map("row" -> (res), "gain" -> (gain))
}

def moveLeft(b: ArrayBuffer[ArrayBuffer[Int]], _score: Int): Map[String,Any] = {
  var score: Int = _score
  var moved: Boolean = false
  var y: Int = 0
  while (y < SIZE) {
    val r = slideLeft(b(y))
    val `new` = r("row")
    score = (score + (r("gain")).asInstanceOf[Int]).asInstanceOf[Int]
    var x: Int = 0
    while (x < SIZE) {
      if (b(y).asInstanceOf[ArrayBuffer[Any]](x) != `new`.asInstanceOf[ArrayBuffer[Any]](x)) {
        moved = true
      }
      b(y).asInstanceOf[ArrayBuffer[Any]](x) = `new`.asInstanceOf[ArrayBuffer[Any]](x)
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  return Map("board" -> (b), "score" -> (score), "moved" -> (moved))
}

def moveRight(b: ArrayBuffer[ArrayBuffer[Int]], _score: Int): Map[String,Any] = {
  var score: Int = _score
  var moved: Boolean = false
  var y: Int = 0
  while (y < SIZE) {
    var rev = reverseRow(b(y))
    val r = slideLeft(rev)
    rev = (r("row")).asInstanceOf[ArrayBuffer[Int]]
    score = (score + (r("gain")).asInstanceOf[Int]).asInstanceOf[Int]
    rev = (reverseRow(rev)).asInstanceOf[ArrayBuffer[Int]]
    var x: Int = 0
    while (x < SIZE) {
      if (b(y).asInstanceOf[ArrayBuffer[Any]](x) != rev(x)) {
        moved = true
      }
      b(y).asInstanceOf[ArrayBuffer[Any]](x) = rev(x)
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  return Map("board" -> (b), "score" -> (score), "moved" -> (moved))
}

def getCol(b: ArrayBuffer[ArrayBuffer[Int]], x: Int): ArrayBuffer[Int] = {
  var col: ArrayBuffer[Int] = ArrayBuffer()
  var y: Int = 0
  while (y < SIZE) {
    col = col :+ b(y).asInstanceOf[ArrayBuffer[Any]](x)
    y = (y + 1).asInstanceOf[Int]
  }
  return col
}

def setCol(b: ArrayBuffer[ArrayBuffer[Int]], x: Int, col: ArrayBuffer[Int]) = {
  var y: Int = 0
  while (y < SIZE) {
    b(y).asInstanceOf[ArrayBuffer[Any]](x) = col(y)
    y = (y + 1).asInstanceOf[Int]
  }
}

def moveUp(b: ArrayBuffer[ArrayBuffer[Int]], _score: Int): Map[String,Any] = {
  var score: Int = _score
  var moved: Boolean = false
  var x: Int = 0
  while (x < SIZE) {
    var col = getCol(b, x)
    val r = slideLeft(col)
    val `new` = r("row")
    score = (score + (r("gain")).asInstanceOf[Int]).asInstanceOf[Int]
    var y: Int = 0
    while (y < SIZE) {
      if (b(y).asInstanceOf[ArrayBuffer[Any]](x) != `new`.asInstanceOf[ArrayBuffer[Any]](y)) {
        moved = true
      }
      b(y).asInstanceOf[ArrayBuffer[Any]](x) = `new`.asInstanceOf[ArrayBuffer[Any]](y)
      y = (y + 1).asInstanceOf[Int]
    }
    x = (x + 1).asInstanceOf[Int]
  }
  return Map("board" -> (b), "score" -> (score), "moved" -> (moved))
}

def moveDown(b: ArrayBuffer[ArrayBuffer[Int]], _score: Int): Map[String,Any] = {
  var score: Int = _score
  var moved: Boolean = false
  var x: Int = 0
  while (x < SIZE) {
    var col = reverseRow(getCol(b, x))
    val r = slideLeft(col)
    col = (r("row")).asInstanceOf[ArrayBuffer[Int]]
    score = (score + (r("gain")).asInstanceOf[Int]).asInstanceOf[Int]
    col = (reverseRow(col)).asInstanceOf[ArrayBuffer[Int]]
    var y: Int = 0
    while (y < SIZE) {
      if (b(y).asInstanceOf[ArrayBuffer[Any]](x) != col(y)) {
        moved = true
      }
      b(y).asInstanceOf[ArrayBuffer[Any]](x) = col(y)
      y = (y + 1).asInstanceOf[Int]
    }
    x = (x + 1).asInstanceOf[Int]
  }
  return Map("board" -> (b), "score" -> (score), "moved" -> (moved))
}

def hasMoves(b: ArrayBuffer[ArrayBuffer[Int]]): Boolean = {
  var y: Int = 0
  while (y < SIZE) {
    var x: Int = 0
    while (x < SIZE) {
      if (b(y).asInstanceOf[ArrayBuffer[Any]](x) == 0) {
        return true
      }
      if ((x + 1 < SIZE && b(y).asInstanceOf[ArrayBuffer[Any]](x) == b(y).asInstanceOf[ArrayBuffer[Any]](x + 1)).asInstanceOf[Boolean]) {
        return true
      }
      if ((y + 1 < SIZE && b(y).asInstanceOf[ArrayBuffer[Any]](x) == b(y + 1).asInstanceOf[ArrayBuffer[Any]](x)).asInstanceOf[Boolean]) {
        return true
      }
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  return false
}

def has2048(b: ArrayBuffer[ArrayBuffer[Int]]): Boolean = {
  var y: Int = 0
  while (y < SIZE) {
    var x: Int = 0
    while (x < SIZE) {
      if (b(y).asInstanceOf[ArrayBuffer[Any]](x) >= 2048) {
        return true
      }
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  return false
}

val SIZE: Int = 4

def main(args: Array[String]): Unit = {
  var board = newBoard()
  var r = spawnTile(board)
  board = (r("board")).asInstanceOf[ArrayBuffer[ArrayBuffer[Int]]]
  var full = r("full")
  r = (spawnTile(board)).asInstanceOf[Map[String,Any]]
  board = (r("board")).asInstanceOf[ArrayBuffer[ArrayBuffer[Int]]]
  full = r("full")
  var score: Int = 0
  draw(board, score)
  breakable {
    while (true) {
      println("Move: ")
      val cmd = Option(scala.io.StdIn.readLine()).getOrElse("q")
      var moved: Boolean = false
      if ((cmd == "a" || cmd == "A").asInstanceOf[Boolean]) {
        val m = moveLeft(board, score)
        board = (m("board")).asInstanceOf[ArrayBuffer[ArrayBuffer[Int]]]
        score = (m("score")).asInstanceOf[Int]
        moved = (m("moved")).asInstanceOf[Boolean]
      }
      if ((cmd == "d" || cmd == "D").asInstanceOf[Boolean]) {
        val m = moveRight(board, score)
        board = (m("board")).asInstanceOf[ArrayBuffer[ArrayBuffer[Int]]]
        score = (m("score")).asInstanceOf[Int]
        moved = (m("moved")).asInstanceOf[Boolean]
      }
      if ((cmd == "w" || cmd == "W").asInstanceOf[Boolean]) {
        val m = moveUp(board, score)
        board = (m("board")).asInstanceOf[ArrayBuffer[ArrayBuffer[Int]]]
        score = (m("score")).asInstanceOf[Int]
        moved = (m("moved")).asInstanceOf[Boolean]
      }
      if ((cmd == "s" || cmd == "S").asInstanceOf[Boolean]) {
        val m = moveDown(board, score)
        board = (m("board")).asInstanceOf[ArrayBuffer[ArrayBuffer[Int]]]
        score = (m("score")).asInstanceOf[Int]
        moved = (m("moved")).asInstanceOf[Boolean]
      }
      if ((cmd == "q" || cmd == "Q").asInstanceOf[Boolean]) {
        break
      }
      if (moved) {
        val r2 = spawnTile(board)
        board = (r2("board")).asInstanceOf[ArrayBuffer[ArrayBuffer[Int]]]
        full = r2("full")
        if ((full && !(hasMoves(board)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
          draw(board, score)
          println("Game Over")
          break
        }
      }
      draw(board, score)
      if ((has2048(board)).asInstanceOf[Boolean]) {
        println("You win!")
        break
      }
      if ((!(hasMoves(board)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
        println("Game Over")
        break
      }
    }
  }
}
}
