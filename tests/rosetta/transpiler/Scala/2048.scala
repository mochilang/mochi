// Generated by Mochi v0.10.37 on 2025-07-22 20:22:59 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks._
object Main {
  def newBoard(): ArrayBuffer[ArrayBuffer[Int]] = {
    var b: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
    var y: Int = 0
    while (y < SIZE) {
      var row: ArrayBuffer[Int] = ArrayBuffer()
      var x: Int = 0
      while (x < SIZE) {
        row = row :+ 0
        x = x + 1
      }
      b = b :+ row
      y = y + 1
    }
    return b
  }
  
  def spawnTile(b: ArrayBuffer[ArrayBuffer[Int]]): Map[String,any] = {
    var empty: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
    var y: Int = 0
    while (y < SIZE) {
      var x: Int = 0
      while (x < SIZE) {
        if (b(y)(x) == 0) {
          empty = empty :+ ArrayBuffer(x, y)
        }
        x = x + 1
      }
      y = y + 1
    }
    if ((empty).size == 0) {
      return Map("board" -> b, "full" -> true)
    }
    var idx = now() % (empty).size
    val cell: Any = empty(idx)
    var `val`: Int = 4
    if (now() % 10 < 9) {
      `val` = 2
    }
    b(cell(1))(cell(0)) = `val`
    return Map("board" -> b, "full" -> (empty).size == 1)
  }
  
  def pad(n: Int): String = {
    var s = String.valueOf(n)
    var pad: Int = 4 - (s).size
    var i: Int = 0
    var out: String = ""
    while (i < pad) {
      out = out + " "
      i = i + 1
    }
    return out + s
  }
  
  def draw(b: ArrayBuffer[ArrayBuffer[Int]], score: Int) = {
    println("Score: " + String.valueOf(score))
    var y: Int = 0
    while (y < SIZE) {
      println("+----+----+----+----+")
      var line: String = "|"
      var x: Int = 0
      while (x < SIZE) {
        var v: Any = b(y)(x)
        if (v == 0) {
          line = line + "    |"
        } else {
          line = line + pad(v) + "|"
        }
        x = x + 1
      }
      println(line)
      y = y + 1
    }
    println("+----+----+----+----+")
    println("W=Up S=Down A=Left D=Right Q=Quit")
  }
  
  def reverseRow(r: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var out: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = (r).size - 1
    while (i >= 0) {
      out = out :+ r(i)
      i = i - 1
    }
    return out
  }
  
  def slideLeft(row: ArrayBuffer[Int]): Map[String,any] = {
    var xs: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = 0
    while (i < (row).size) {
      if (row(i) != 0) {
        xs = xs :+ row(i)
      }
      i = i + 1
    }
    var res: ArrayBuffer[Int] = ArrayBuffer()
    var gain: Int = 0
    i = 0
    while (i < (xs).size) {
      if (i + 1 < (xs).size && xs(i) == xs(i + 1)) {
        val v: Int = xs(i) * 2
        gain = gain + v
        res = res :+ v
        i = i + 2
      } else {
        res = res :+ xs(i)
        i = i + 1
      }
    }
    while ((res).size < SIZE) {
      res = res :+ 0
    }
    return Map("row" -> res, "gain" -> gain)
  }
  
  def moveLeft(b: ArrayBuffer[ArrayBuffer[Int]], score: Int): Map[String,any] = {
    var moved: Boolean = false
    var y: Int = 0
    while (y < SIZE) {
      val r = slideLeft(b(y))
      val new: Any = r("row")
      score = score + r("gain")
      var x: Int = 0
      while (x < SIZE) {
        if (b(y)(x) != new(x)) {
          moved = true
        }
        b(y)(x) = new(x)
        x = x + 1
      }
      y = y + 1
    }
    return Map("board" -> b, "score" -> score, "moved" -> moved)
  }
  
  def moveRight(b: ArrayBuffer[ArrayBuffer[Int]], score: Int): Map[String,any] = {
    var moved: Boolean = false
    var y: Int = 0
    while (y < SIZE) {
      var rev = reverseRow(b(y))
      val r = slideLeft(rev)
      rev = r("row")
      score = score + r("gain")
      rev = reverseRow(rev)
      var x: Int = 0
      while (x < SIZE) {
        if (b(y)(x) != rev(x)) {
          moved = true
        }
        b(y)(x) = rev(x)
        x = x + 1
      }
      y = y + 1
    }
    return Map("board" -> b, "score" -> score, "moved" -> moved)
  }
  
  def getCol(b: ArrayBuffer[ArrayBuffer[Int]], x: Int): ArrayBuffer[Int] = {
    var col: ArrayBuffer[Int] = ArrayBuffer()
    var y: Int = 0
    while (y < SIZE) {
      col = col :+ b(y)(x)
      y = y + 1
    }
    return col
  }
  
  def setCol(b: ArrayBuffer[ArrayBuffer[Int]], x: Int, col: ArrayBuffer[Int]) = {
    var y: Int = 0
    while (y < SIZE) {
      b(y)(x) = col(y)
      y = y + 1
    }
  }
  
  def moveUp(b: ArrayBuffer[ArrayBuffer[Int]], score: Int): Map[String,any] = {
    var moved: Boolean = false
    var x: Int = 0
    while (x < SIZE) {
      var col = getCol(b, x)
      val r = slideLeft(col)
      val new: Any = r("row")
      score = score + r("gain")
      var y: Int = 0
      while (y < SIZE) {
        if (b(y)(x) != new(y)) {
          moved = true
        }
        b(y)(x) = new(y)
        y = y + 1
      }
      x = x + 1
    }
    return Map("board" -> b, "score" -> score, "moved" -> moved)
  }
  
  def moveDown(b: ArrayBuffer[ArrayBuffer[Int]], score: Int): Map[String,any] = {
    var moved: Boolean = false
    var x: Int = 0
    while (x < SIZE) {
      var col = reverseRow(getCol(b, x))
      val r = slideLeft(col)
      col = r("row")
      score = score + r("gain")
      col = reverseRow(col)
      var y: Int = 0
      while (y < SIZE) {
        if (b(y)(x) != col(y)) {
          moved = true
        }
        b(y)(x) = col(y)
        y = y + 1
      }
      x = x + 1
    }
    return Map("board" -> b, "score" -> score, "moved" -> moved)
  }
  
  def hasMoves(b: ArrayBuffer[ArrayBuffer[Int]]): Boolean = {
    var y: Int = 0
    while (y < SIZE) {
      var x: Int = 0
      while (x < SIZE) {
        if (b(y)(x) == 0) {
          return true
        }
        if (x + 1 < SIZE && b(y)(x) == b(y)(x + 1)) {
          return true
        }
        if (y + 1 < SIZE && b(y)(x) == b(y + 1)(x)) {
          return true
        }
        x = x + 1
      }
      y = y + 1
    }
    return false
  }
  
  def has2048(b: ArrayBuffer[ArrayBuffer[Int]]): Boolean = {
    var y: Int = 0
    while (y < SIZE) {
      var x: Int = 0
      while (x < SIZE) {
        if (b(y)(x) >= 2048) {
          return true
        }
        x = x + 1
      }
      y = y + 1
    }
    return false
  }
  
  val SIZE: Int = 4
  
  def main(args: Array[String]): Unit = {
    var board = newBoard()
    var r = spawnTile(board)
    board = r("board")
    var full: Any = r("full")
    r = spawnTile(board)
    board = r("board")
    full = r("full")
    var score: Int = 0
    draw(board, score)
    while (true) {
      println("Move: ")
      val cmd = input()
      var moved: Boolean = false
      if (cmd == "a" || cmd == "A") {
        val m = moveLeft(board, score)
        board = m("board")
        score = m("score")
        moved = m("moved")
      }
      if (cmd == "d" || cmd == "D") {
        val m = moveRight(board, score)
        board = m("board")
        score = m("score")
        moved = m("moved")
      }
      if (cmd == "w" || cmd == "W") {
        val m = moveUp(board, score)
        board = m("board")
        score = m("score")
        moved = m("moved")
      }
      if (cmd == "s" || cmd == "S") {
        val m = moveDown(board, score)
        board = m("board")
        score = m("score")
        moved = m("moved")
      }
      if (cmd == "q" || cmd == "Q") {
        break
      }
      if (moved) {
        val r2 = spawnTile(board)
        board = r2("board")
        full = r2("full")
        if (full && !hasMoves(board)) {
          draw(board, score)
          println("Game Over")
          break
        }
      }
      draw(board, score)
      if (has2048(board)) {
        println("You win!")
        break
      }
      if (!hasMoves(board)) {
        println("Game Over")
        break
      }
    }
  }
}
