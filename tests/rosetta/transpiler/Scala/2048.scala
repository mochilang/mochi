// Generated by Mochi v0.10.38 on 2025-07-24 07:22:35 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs(System.nanoTime().toInt)
  }
}

case class Board(var cells: ArrayBuffer[ArrayBuffer[Int]])

case class SpawnResult(var board: Board, var full: Boolean)

case class SlideResult(var row: ArrayBuffer[Int], var gain: Int)

case class MoveResult(var board: Board, var score: Int, var moved: Boolean)

def newBoard(): Board = {
  var b: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
  var y: Int = 0
  while (y < SIZE) {
    var row: ArrayBuffer[Int] = ArrayBuffer()
    var x: Int = 0
    while (x < SIZE) {
      row = row :+ 0
      x = (x + 1).asInstanceOf[Int]
    }
    b = b :+ row
    y = (y + 1).asInstanceOf[Int]
  }
  return Board(b)
}

def spawnTile(b: Board): SpawnResult = {
  var grid: ArrayBuffer[ArrayBuffer[Int]] = b.cells
  var empty: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
  var y: Int = 0
  while (y < SIZE) {
    var x: Int = 0
    while (x < SIZE) {
      if (grid(y)(x) == 0) {
        empty = empty :+ ArrayBuffer(x, y)
      }
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  if ((empty).size == 0) {
    return SpawnResult(b, true)
  }
  var idx = _now() % (empty).size
  val cell: ArrayBuffer[Int] = empty(idx)
  var `val`: Int = 4
  if (_now() % 10 < 9) {
    `val` = 2
  }
  grid(cell(1))(cell(0)) = `val`
  return SpawnResult(Board(grid), (empty).size == 1)
}

def pad(n: Int): String = {
  var s = String.valueOf(n)
  var pad: Int = 4 - (s).size
  var i: Int = 0
  var out: String = ""
  while (i < pad) {
    out = (out + " ").asInstanceOf[String]
    i = (i + 1).asInstanceOf[Int]
  }
  return (out + s).asInstanceOf[String]
}

def draw(b: Board, score: Int) = {
  println("Score: " + String.valueOf(score))
  var y: Int = 0
  while (y < SIZE) {
    println("+----+----+----+----+")
    var line: String = "|"
    var x: Int = 0
    while (x < SIZE) {
      var v: Int = b.cells(y)(x)
      if (v == 0) {
        line = (line + "    |").asInstanceOf[String]
      } else {
        line = (line + pad(v) + "|").asInstanceOf[String]
      }
      x = (x + 1).asInstanceOf[Int]
    }
    println(line)
    y = (y + 1).asInstanceOf[Int]
  }
  println("+----+----+----+----+")
  println("W=Up S=Down A=Left D=Right Q=Quit")
}

def reverseRow(r: ArrayBuffer[Int]): ArrayBuffer[Int] = {
  var out: ArrayBuffer[Int] = ArrayBuffer()
  var i: Int = (r).size - 1
  while (i >= 0) {
    out = out :+ r(i)
    i = (i - 1).asInstanceOf[Int]
  }
  return out
}

def slideLeft(row: ArrayBuffer[Int]): SlideResult = {
  var xs: ArrayBuffer[Int] = ArrayBuffer()
  var i: Int = 0
  while (i < (row).size) {
    if (row(i) != 0) {
      xs = xs :+ row(i)
    }
    i = (i + 1).asInstanceOf[Int]
  }
  var res: ArrayBuffer[Int] = ArrayBuffer()
  var gain: Int = 0
  i = 0
  while (i < (xs).size) {
    if ((i + 1 < (xs).size && xs(i) == xs(i + 1)).asInstanceOf[Boolean]) {
      val v: Int = xs(i) * 2
      gain = (gain + v).asInstanceOf[Int]
      res = res :+ v
      i = (i + 2).asInstanceOf[Int]
    } else {
      res = res :+ xs(i)
      i = (i + 1).asInstanceOf[Int]
    }
  }
  while ((res).size < SIZE) {
    res = res :+ 0
  }
  return SlideResult(res, gain)
}

def moveLeft(b: Board, _score: Int): MoveResult = {
  var score: Int = _score
  var grid: ArrayBuffer[ArrayBuffer[Int]] = b.cells
  var moved: Boolean = false
  var y: Int = 0
  while (y < SIZE) {
    val r: SlideResult = slideLeft(grid(y))
    val `new`: ArrayBuffer[Int] = r.row
    score = (score + r.gain).asInstanceOf[Int]
    var x: Int = 0
    while (x < SIZE) {
      if (grid(y)(x) != `new`(x)) {
        moved = true
      }
      grid(y)(x) = `new`(x)
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  return MoveResult(Board(grid), score, moved)
}

def moveRight(b: Board, _score: Int): MoveResult = {
  var score: Int = _score
  var grid: ArrayBuffer[ArrayBuffer[Int]] = b.cells
  var moved: Boolean = false
  var y: Int = 0
  while (y < SIZE) {
    var rev: ArrayBuffer[Int] = reverseRow(grid(y))
    val r: SlideResult = slideLeft(rev)
    rev = r.row
    score = (score + r.gain).asInstanceOf[Int]
    rev = reverseRow(rev)
    var x: Int = 0
    while (x < SIZE) {
      if (grid(y)(x) != rev(x)) {
        moved = true
      }
      grid(y)(x) = rev(x)
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  return MoveResult(Board(grid), score, moved)
}

def getCol(b: Board, x: Int): ArrayBuffer[Int] = {
  var col: ArrayBuffer[Int] = ArrayBuffer()
  var y: Int = 0
  while (y < SIZE) {
    col = col :+ b.cells(y)(x)
    y = (y + 1).asInstanceOf[Int]
  }
  return col
}

def setCol(b: Board, x: Int, col: ArrayBuffer[Int]) = {
  var rows: ArrayBuffer[ArrayBuffer[Int]] = b.cells
  var y: Int = 0
  while (y < SIZE) {
    var row: ArrayBuffer[Int] = rows(y)
    row(x) = col(y)
    rows(y) = row
    y = (y + 1).asInstanceOf[Int]
  }
  b.cells = rows
}

def moveUp(b: Board, _score: Int): MoveResult = {
  var score: Int = _score
  var grid: ArrayBuffer[ArrayBuffer[Int]] = b.cells
  var moved: Boolean = false
  var x: Int = 0
  while (x < SIZE) {
    var col: ArrayBuffer[Int] = getCol(b, x)
    val r: SlideResult = slideLeft(col)
    val `new`: ArrayBuffer[Int] = r.row
    score = (score + r.gain).asInstanceOf[Int]
    var y: Int = 0
    while (y < SIZE) {
      if (grid(y)(x) != `new`(y)) {
        moved = true
      }
      grid(y)(x) = `new`(y)
      y = (y + 1).asInstanceOf[Int]
    }
    x = (x + 1).asInstanceOf[Int]
  }
  return MoveResult(Board(grid), score, moved)
}

def moveDown(b: Board, _score: Int): MoveResult = {
  var score: Int = _score
  var grid: ArrayBuffer[ArrayBuffer[Int]] = b.cells
  var moved: Boolean = false
  var x: Int = 0
  while (x < SIZE) {
    var col: ArrayBuffer[Int] = reverseRow(getCol(b, x))
    val r: SlideResult = slideLeft(col)
    col = r.row
    score = (score + r.gain).asInstanceOf[Int]
    col = reverseRow(col)
    var y: Int = 0
    while (y < SIZE) {
      if (grid(y)(x) != col(y)) {
        moved = true
      }
      grid(y)(x) = col(y)
      y = (y + 1).asInstanceOf[Int]
    }
    x = (x + 1).asInstanceOf[Int]
  }
  return MoveResult(Board(grid), score, moved)
}

def hasMoves(b: Board): Boolean = {
  var y: Int = 0
  while (y < SIZE) {
    var x: Int = 0
    while (x < SIZE) {
      if (b.cells(y)(x) == 0) {
        return true
      }
      if ((x + 1 < SIZE && b.cells(y)(x) == b.cells(y)(x + 1)).asInstanceOf[Boolean]) {
        return true
      }
      if ((y + 1 < SIZE && b.cells(y)(x) == b.cells(y + 1)(x)).asInstanceOf[Boolean]) {
        return true
      }
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  return false
}

def has2048(b: Board): Boolean = {
  var y: Int = 0
  while (y < SIZE) {
    var x: Int = 0
    while (x < SIZE) {
      if (b.cells(y)(x) >= 2048) {
        return true
      }
      x = (x + 1).asInstanceOf[Int]
    }
    y = (y + 1).asInstanceOf[Int]
  }
  return false
}

val SIZE: Int = 4

var board: Board = newBoard()

var r: SpawnResult = spawnTile(board)

var full: Boolean = r.full

var score: Int = 0

def main(args: Array[String]): Unit = {
  board = r.board
  r = spawnTile(board)
  board = r.board
  full = r.full
  draw(board, score)
  val _br25 = new Breaks
  _br25.breakable {
    while (true) {
      println("Move: ")
      val cmd = Option(scala.io.StdIn.readLine()).getOrElse("q")
      var moved: Boolean = false
      if ((cmd == "a" || cmd == "A").asInstanceOf[Boolean]) {
        val m: MoveResult = moveLeft(board, score)
        board = m.board
        score = m.score
        moved = m.moved
      }
      if ((cmd == "d" || cmd == "D").asInstanceOf[Boolean]) {
        val m: MoveResult = moveRight(board, score)
        board = m.board
        score = m.score
        moved = m.moved
      }
      if ((cmd == "w" || cmd == "W").asInstanceOf[Boolean]) {
        val m: MoveResult = moveUp(board, score)
        board = m.board
        score = m.score
        moved = m.moved
      }
      if ((cmd == "s" || cmd == "S").asInstanceOf[Boolean]) {
        val m: MoveResult = moveDown(board, score)
        board = m.board
        score = m.score
        moved = m.moved
      }
      if ((cmd == "q" || cmd == "Q").asInstanceOf[Boolean]) {
        _br25.break()
      }
      if (moved) {
        val r2: SpawnResult = spawnTile(board)
        board = r2.board
        full = r2.full
        if ((full && (!hasMoves(board)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
          draw(board, score)
          println("Game Over")
          _br25.break()
        }
      }
      draw(board, score)
      if (has2048(board)) {
        println("You win!")
        _br25.break()
      }
      if ((!hasMoves(board)).asInstanceOf[Boolean]) {
        println("Game Over")
        _br25.break()
      }
    }
  }
}
}
