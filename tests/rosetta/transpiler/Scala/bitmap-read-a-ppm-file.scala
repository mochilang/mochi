// Generated by Mochi v0.10.40 on 2025-07-26 04:42:07 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  case class Pixel(var R: Int, var G: Int, var B: Int)
  
  case class Bitmap(var w: Int, var h: Int, var max: Int, var data: ArrayBuffer[ArrayBuffer[Pixel]])
  
  def newBitmap(w: Int, h: Int, max: Int): Bitmap = {
    var rows: ArrayBuffer[ArrayBuffer[Pixel]] = ArrayBuffer()
    var y: Int = 0
    while (y < h) {
      var row: ArrayBuffer[Pixel] = ArrayBuffer()
      var x: Int = 0
      while (x < w) {
        row = row :+ Pixel(0, 0, 0)
        x = (x + 1).asInstanceOf[Int]
      }
      rows = rows :+ row
      y = (y + 1).asInstanceOf[Int]
    }
    return Bitmap(w, h, max, rows)
  }
  
  def setPx(b: Bitmap, x: Int, y: Int, p: Pixel): Any = {
    var rows: ArrayBuffer[ArrayBuffer[Pixel]] = b.data
    var row: ArrayBuffer[Pixel] = rows(y)
    row(x) = p
    rows(y) = row
    b.data = rows
  }
  
  def getPx(b: Bitmap, x: Int, y: Int): Pixel = {
    return b.data(y)(x)
  }
  
  def splitLines(s: String): ArrayBuffer[String] = {
    var out: ArrayBuffer[String] = ArrayBuffer()
    var cur: String = ""
    var i: Int = 0
    while (i < (s).size) {
      val ch: String = substr(s, i, i + 1)
      if (ch == "\n") {
        out = out :+ cur
        cur = ""
      } else {
        cur = (cur + ch).toString
      }
      i = (i + 1).asInstanceOf[Int]
    }
    out = out :+ cur
    return out
  }
  
  def splitWS(s: String): ArrayBuffer[String] = {
    var out: ArrayBuffer[String] = ArrayBuffer()
    var cur: String = ""
    var i: Int = 0
    while (i < (s).size) {
      val ch: String = substr(s, i, i + 1)
      if ((((ch == " " || ch == "\t").asInstanceOf[Boolean] || ch == "\r").asInstanceOf[Boolean] || ch == "\n").asInstanceOf[Boolean]) {
        if ((cur).size > 0) {
          out = out :+ cur
          cur = ""
        }
      } else {
        cur = (cur + ch).toString
      }
      i = (i + 1).asInstanceOf[Int]
    }
    if ((cur).size > 0) {
      out = out :+ cur
    }
    return out
  }
  
  def parseIntStr(str: String): Int = {
    var i: Int = 0
    var neg: Boolean = false
    if (((str).size > 0 && str.slice(0, 1) == "-").asInstanceOf[Boolean]) {
      neg = true
      i = 1
    }
    var n: Int = 0
    val digits: Map[String,Int] = Map("0" -> (0), "1" -> (1), "2" -> (2), "3" -> (3), "4" -> (4), "5" -> (5), "6" -> (6), "7" -> (7), "8" -> (8), "9" -> (9))
    while (i < (str).size) {
      n = (n * 10 + digits.getOrElse(str.slice(i, i + 1), null.asInstanceOf[Int])).asInstanceOf[Int]
      i = (i + 1).asInstanceOf[Int]
    }
    if (neg) {
      n = (0 - n).asInstanceOf[Int]
    }
    return n
  }
  
  def tokenize(s: String): ArrayBuffer[String] = {
    val lines: ArrayBuffer[String] = splitLines(s)
    var toks: ArrayBuffer[String] = ArrayBuffer()
    var i: Int = 0
    val _ct5 = new Breaks
    while (i < (lines).size) {
      _ct5.breakable {
        val line: String = lines(i)
        if (((line).size > 0 && substr(line, 0, 1) == "#").asInstanceOf[Boolean]) {
          i = (i + 1).asInstanceOf[Int]
          _ct5.break()
        }
        val parts: ArrayBuffer[String] = splitWS(line)
        var j: Int = 0
        while (j < (parts).size) {
          toks = toks :+ parts(j)
          j = (j + 1).asInstanceOf[Int]
        }
        i = (i + 1).asInstanceOf[Int]
      }
    }
    return toks
  }
  
  def readP3(text: String): Bitmap = {
    val toks: ArrayBuffer[String] = tokenize(text)
    if ((toks).size < 4) {
      return newBitmap(0, 0, 0)
    }
    if (toks(0) != "P3") {
      return newBitmap(0, 0, 0)
    }
    val w: Int = parseIntStr(toks(1))
    val h: Int = parseIntStr(toks(2))
    val maxv: Int = parseIntStr(toks(3))
    var idx: Int = 4
    var bm: Bitmap = newBitmap(w, h, maxv)
    var y = h - 1
    while (y >= 0) {
      var x: Int = 0
      while (x < w) {
        val r: Int = parseIntStr(toks(idx))
        val g: Int = parseIntStr(toks(idx + 1))
        val b: Int = parseIntStr(toks(idx + 2))
        setPx(bm, x, y, Pixel(r, g, b))
        idx = (idx + 3).asInstanceOf[Int]
        x = (x + 1).asInstanceOf[Int]
      }
      y = (y - 1).asInstanceOf[Int]
    }
    return bm
  }
  
  def toGrey(b: Bitmap): Any = {
    val h: Int = b.h
    val w: Int = b.w
    var m: Int = 0
    var y: Int = 0
    while (y < h) {
      var x: Int = 0
      while (x < w) {
        val p: Pixel = getPx(b, x, y)
        var l: Double = ((p.R * 2126).toString.toDouble + (p.G * 7152).toString.toDouble + p.B * 722) / 10000
        if (l > b.max) {
          l = b.max
        }
        setPx(b, x, y, Pixel(l, l, l))
        if (l > m) {
          m = l
        }
        x = (x + 1).asInstanceOf[Int]
      }
      y = (y + 1).asInstanceOf[Int]
    }
    b.max = m
  }
  
  def pad(n: Int, w: Int): String = {
    var s = String.valueOf(n)
    while ((s).size < w) {
      s = " " + s
    }
    return s
  }
  
  def writeP3(b: Bitmap): String = {
    val h: Int = b.h
    val w: Int = b.w
    var max: Int = b.max
    val digits: Int = (String.valueOf(max)).size
    var out: String = "P3\n# generated from Bitmap.writeppmp3\n" + String.valueOf(w) + " " + String.valueOf(h) + "\n" + String.valueOf(max) + "\n"
    var y = h - 1
    while (y >= 0) {
      var line: String = ""
      var x: Int = 0
      while (x < w) {
        val p: Pixel = getPx(b, x, y)
        line = line + "   " + pad(p.R, digits) + " " + pad(p.G, digits) + " " + pad(p.B, digits)
        x = (x + 1).asInstanceOf[Int]
      }
      out = out + line + "\n"
      y = (y - 1).asInstanceOf[Int]
    }
    return out
  }
  
  var ppmtxt: String = "P3\n" + "# feep.ppm\n" + "4 4\n" + "15\n" + " 0  0  0    0  0  0    0  0  0   15  0 15\n" + " 0  0  0    0 15  7    0  0  0    0  0  0\n" + " 0  0  0    0  0  0    0 15  7    0  0  0\n" + "15  0 15    0  0  0    0  0  0    0  0  0\n"
  
  var bm: Bitmap = readP3(ppmtxt)
  
  val out: String = writeP3(bm)
  
  def main(args: Array[String]): Unit = {
    println("Original Colour PPM file")
    println(ppmtxt)
    println("Grey PPM:")
    toGrey(bm)
    println(out)
  }
}
