// Generated by Mochi v0.10.41 on 2025-07-26 17:29:26 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
object Main {
  def sqrtApprox(x: Double): Double = {
    var guess: Double = x
    var i: BigInt = BigInt(0)
    while (i < BigInt(20)) {
      guess = (guess + x / guess) / 2.0
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    return guess
  }
  
  def makeSym(order: BigInt, elements: ArrayBuffer[Double]): scala.collection.mutable.Map[String,Any] = {
    return (scala.collection.mutable.Map("order" -> (order), "ele" -> (elements))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
  }
  
  def unpackSym(m: scala.collection.mutable.Map[String,Any]): ArrayBuffer[ArrayBuffer[Double]] = {
    val n = m.getOrElse("order", null.asInstanceOf[Any])
    val ele = m.getOrElse("ele", null.asInstanceOf[Any])
    var mat: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer()
    var idx: BigInt = BigInt(0)
    var r: BigInt = BigInt(0)
    while (r < n) {
      var row: ArrayBuffer[Double] = ArrayBuffer()
      var c: BigInt = BigInt(0)
      while (c <= r) {
        row = row :+ (ele.asInstanceOf[ArrayBuffer[Any]](idx)).toString.toDouble
        idx = (idx + BigInt(1)).asInstanceOf[BigInt]
        c = (c + BigInt(1)).asInstanceOf[BigInt]
      }
      while (c < n) {
        row = row :+ 0.0
        c = (c + BigInt(1)).asInstanceOf[BigInt]
      }
      mat = mat :+ row
      r = (r + BigInt(1)).asInstanceOf[BigInt]
    }
    r = BigInt(0)
    while (r < n) {
      var c = r + BigInt(1)
      while (c < n) {
        mat((r).toInt)((c).toInt) = mat((c).toInt)((r).toInt)
        c = (c + BigInt(1)).asInstanceOf[BigInt]
      }
      r = (r + BigInt(1)).asInstanceOf[BigInt]
    }
    return mat
  }
  
  def printMat(m: ArrayBuffer[ArrayBuffer[Double]]): Any = {
    var i: BigInt = BigInt(0)
    while (i < (m).size) {
      var line: String = ""
      var j: BigInt = BigInt(0)
      while (j < (m((i).toInt)).size) {
        line = (line + String.valueOf(m((i).toInt)((j).toInt))).toString
        if (j < (m((i).toInt)).size - BigInt(1)) {
          line = line + " "
        }
        j = (j + BigInt(1)).asInstanceOf[BigInt]
      }
      println(line)
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
  }
  
  def printSym(m: scala.collection.mutable.Map[String,Any]): Any = {
    printMat(unpackSym(m))
  }
  
  def printLower(m: scala.collection.mutable.Map[String,Any]): Any = {
    val n = m.getOrElse("order", null.asInstanceOf[Any])
    val ele = m.getOrElse("ele", null.asInstanceOf[Any])
    var mat: ArrayBuffer[ArrayBuffer[Double]] = ArrayBuffer()
    var idx: BigInt = BigInt(0)
    var r: BigInt = BigInt(0)
    while (r < n) {
      var row: ArrayBuffer[Double] = ArrayBuffer()
      var c: BigInt = BigInt(0)
      while (c <= r) {
        row = row :+ (ele.asInstanceOf[ArrayBuffer[Any]](idx)).toString.toDouble
        idx = (idx + BigInt(1)).asInstanceOf[BigInt]
        c = (c + BigInt(1)).asInstanceOf[BigInt]
      }
      while (c < n) {
        row = row :+ 0.0
        c = (c + BigInt(1)).asInstanceOf[BigInt]
      }
      mat = mat :+ row
      r = (r + BigInt(1)).asInstanceOf[BigInt]
    }
    printMat(mat)
  }
  
  def choleskyLower(a: scala.collection.mutable.Map[String,Any]): scala.collection.mutable.Map[String,Any] = {
    val n = a.getOrElse("order", null.asInstanceOf[Any])
    val ae = a.getOrElse("ele", null.asInstanceOf[Any])
    var le: ArrayBuffer[Double] = ArrayBuffer()
    var idx: BigInt = BigInt(0)
    while (idx < (ae.toString).size) {
      le = le :+ 0.0
      idx = (idx + BigInt(1)).asInstanceOf[BigInt]
    }
    var row: BigInt = BigInt(1)
    var col: BigInt = BigInt(1)
    var dr: BigInt = BigInt(0)
    var dc: BigInt = BigInt(0)
    var i: BigInt = BigInt(0)
    while (i < (ae.toString).size) {
      val e = ae.asInstanceOf[ArrayBuffer[Any]](i)
      if (i < dr) {
        var d: Double = (e.toString.toDouble - le((i).toInt)) / le((dc).toInt)
        le((i).toInt) = d
        var ci: BigInt = col
        var cx: BigInt = dc
        var j = i + BigInt(1)
        while (j <= dr) {
          cx = (cx + ci).asInstanceOf[BigInt]
          ci = (ci + BigInt(1)).asInstanceOf[BigInt]
          le((j).toInt) = (le((j).toInt) + d * le((cx).toInt)).toString.toDouble
          j = (j + BigInt(1)).asInstanceOf[BigInt]
        }
        col = (col + BigInt(1)).asInstanceOf[BigInt]
        dc = (dc + col).asInstanceOf[BigInt]
      } else {
        le((i).toInt) = sqrtApprox(e.toString.toDouble - le((i).toInt))
        row = (row + BigInt(1)).asInstanceOf[BigInt]
        dr = (dr + row).asInstanceOf[BigInt]
        col = BigInt(1)
        dc = BigInt(0)
      }
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    return (scala.collection.mutable.Map("order" -> (n), "ele" -> (le))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
  }
  
  def demo(a: scala.collection.mutable.Map[String,Any]): Any = {
    println("A:")
    printSym(a)
    println("L:")
    val l: scala.collection.mutable.Map[String,Any] = choleskyLower(a)
    printLower(l)
  }
  
  def main(args: Array[String]): Unit = {
    demo(makeSym(BigInt(3), ArrayBuffer(25.0, 15.0, 18.0, BigInt(0) - 5.0, 0.0, 11.0)))
    demo(makeSym(BigInt(4), ArrayBuffer(18.0, 22.0, 70.0, 54.0, 86.0, 174.0, 42.0, 62.0, 134.0, 106.0)))
  }
}
