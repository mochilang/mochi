// Generated by Mochi v0.10.56 on 2025-08-04 00:21:39 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Fps(var coeffs: ArrayBuffer[Double], var compute: (BigInt) => Double)

case class Pair(var sin: Fps, var cos: Fps)

def newFps(fn: (BigInt) => Double): Fps = {
  return Fps(ArrayBuffer(), fn)
}

def extract(f: Fps, n: BigInt): Double = {
  while (BigInt(((f.coeffs).size).toInt) <= n) {
    val idx: Int = (f.coeffs).size
    val v = f.compute(idx)
    f.coeffs = f.coeffs :+ v
  }
  return f.coeffs((n.toInt).toInt)
}

def one(): Fps = {
  return newFps(((i: BigInt) => (if (i == BigInt(0)) 1.0 else 0.0)))
}

def add(a: Fps, b: Fps): Fps = {
  return newFps((((n: BigInt) => extract(a, n) + extract(b, n))).asInstanceOf[(BigInt) => Double])
}

def sub(a: Fps, b: Fps): Fps = {
  return newFps((((n: BigInt) => extract(a, n) - extract(b, n))).asInstanceOf[(BigInt) => Double])
}

def mul(a: Fps, b: Fps): Fps = {
  return newFps((((n: BigInt) => {var s: Double = 0.0; var k: BigInt = BigInt(0); while (k <= n) {
    s = s + extract(a, k) * extract(b, n - k)
    k = k + BigInt(1)
  }; s })).asInstanceOf[(BigInt) => Double])
}

def div(a: Fps, b: Fps): Fps = {
  var q: Fps = newFps(((n: BigInt) => 0.0))
  q.compute = ((n: BigInt) => {val b0: Double = extract(b, BigInt(0)); if (b0 == 0.0) {
    0.0 / 0.0
  }; var s: Double = extract(a, n); var k: BigInt = BigInt(1); while (k <= n) {
    s = s - extract(b, k) * extract(q, n - k)
    k = k + BigInt(1)
  }; s / b0 })
  return q
}

def differentiate(a: Fps): Fps = {
  return newFps(((n: BigInt) => (n + BigInt(1)).toString.toDouble * extract(a, n + BigInt(1))))
}

def integrate(a: Fps): Fps = {
  return newFps(((n: BigInt) => (if (n == BigInt(0)) 0.0 else extract(a, n - BigInt(1)) / n.toString.toDouble)))
}

def sinCos(): Pair = {
  var sin: Fps = newFps(((n: BigInt) => 0.0))
  var cos: Fps = sub(one(), integrate(sin))
  sin.compute = ((n: BigInt) => (if (n == BigInt(0)) 0.0 else extract(cos, n - BigInt(1)) / n.toString.toDouble))
  return Pair(sin, cos)
}

def floorf(x: Double): Double = {
  val y: Int = x.toInt
  return y.toString.toDouble
}

def fmtF5(x: Double): String = {
  var y: Double = floorf(x * 100000.0 + 0.5) / 100000.0
  var s: String = String.valueOf(y)
  var dot: BigInt = BigInt(s.indexOf("."))
  if (dot == BigInt(0) - BigInt(1)) {
    s = s + ".00000"
  } else {
    var decs: BigInt = (s).size - dot - BigInt(1)
    if (decs > BigInt(5)) {
      s = s.slice((BigInt(0)).toInt, (dot + BigInt(6)).toInt)
    } else {
      while (decs < BigInt(5)) {
        s = s + "0"
        decs = decs + BigInt(1)
      }
    }
  }
  return s
}

def padFloat5(x: Double, width: BigInt): String = {
  var s: String = fmtF5(x)
  while (BigInt(((s).size).toInt) < width) {
    s = " " + s
  }
  return s
}

def partialSeries(f: Fps): String = {
  var out: String = ""
  var i: BigInt = BigInt(0)
  while (i < BigInt(6)) {
    out = out + " " + padFloat5(extract(f, i), BigInt(8)) + " "
    i = i + BigInt(1)
  }
  return out
}

def main(): Any = {
  val p: Pair = sinCos()
  println("sin:" + partialSeries(p.sin))
  println("cos:" + partialSeries(p.cos))
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
