// Generated by Mochi v0.10.54 on 2025-08-02 11:57:47 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
object Main {
  case class Fps(var coeffs: ArrayBuffer[Double], var compute: (BigInt) => Double)
  
  case class Pair(var sin: Fps, var cos: Fps)
  
  def newFps(fn: (BigInt) => Double): Fps = {
    return Fps(ArrayBuffer(), fn)
  }
  
  def extract(f: Fps, n: BigInt): Double = {
    while ((f.coeffs).size <= n) {
      val idx: Int = (f.coeffs).size
      val v = f.compute(idx)
      f.coeffs = f.coeffs :+ v
    }
    return f.coeffs((n.toInt).toInt)
  }
  
  def one(): Fps = {
    return newFps(((i: BigInt) => if (i == BigInt(0)) 1.0 else 0.0))
  }
  
  def add(a: Fps, b: Fps): Fps = {
    return newFps((((n: BigInt) => extract(a, n) + extract(b, n))).asInstanceOf[(BigInt) => Double])
  }
  
  def sub(a: Fps, b: Fps): Fps = {
    return newFps((((n: BigInt) => extract(a, n) - extract(b, n))).asInstanceOf[(BigInt) => Double])
  }
  
  def mul(a: Fps, b: Fps): Fps = {
    return newFps((((n: BigInt) => {var s: Double = 0.0; var k: BigInt = BigInt(0); while (k <= n) {
      s = (s + extract(a, k) * extract(b, n - k)).toString.toDouble
      k = k + BigInt(1)
    }; s })).asInstanceOf[(BigInt) => Double])
  }
  
  def div(a: Fps, b: Fps): Fps = {
    var q: Fps = newFps(((n: BigInt) => 0.0))
    q.compute = ((n: BigInt) => {val b0: Double = extract(b, BigInt(0)); if (b0 == 0.0) {
      0.0 / 0.0
    }; var s: Double = extract(a, n); var k: BigInt = BigInt(1); while (k <= n) {
      s = (s - extract(b, k) * extract(q, n - k)).toString.toDouble
      k = k + BigInt(1)
    }; (s / b0).toString.toDouble })
    return q
  }
  
  def differentiate(a: Fps): Fps = {
    return newFps(((n: BigInt) => (n + BigInt(1)).toString.toDouble * extract(a, n + BigInt(1))))
  }
  
  def integrate(a: Fps): Fps = {
    return newFps(((n: BigInt) => if (n == BigInt(0)) 0.0 else extract(a, n - BigInt(1)) / n.toString.toDouble))
  }
  
  def sinCos(): Pair = {
    var sin: Fps = newFps(((n: BigInt) => 0.0))
    var cos: Fps = sub(one(), integrate(sin))
    sin.compute = ((n: BigInt) => if (n == BigInt(0)) 0.0 else extract(cos, n - BigInt(1)) / n.toString.toDouble)
    return Pair(sin, cos)
  }
  
  def floorf(x: Double): Double = {
    val y: Int = x.toInt
    return y.toString.toDouble
  }
  
  def fmtF5(x: Double): String = {
    var y: Double = floorf(x * 100000.0 + 0.5) / 100000.0
    var s: String = String.valueOf(y)
    var dot: BigInt = BigInt(s.indexOf("."))
    if (dot == BigInt(0) - BigInt(1)) {
      s = s + ".00000"
    } else {
      var decs: BigInt = (s).size - dot - BigInt(1)
      if (decs > BigInt(5)) {
        s = s.slice((BigInt(0)).toInt, (dot + BigInt(6)).toInt)
      } else {
        while (decs < BigInt(5)) {
          s = s + "0"
          decs = decs + BigInt(1)
        }
      }
    }
    return s
  }
  
  def padFloat5(x: Double, width: BigInt): String = {
    var s: String = fmtF5(x)
    while ((s).size < width) {
      s = " " + s
    }
    return s
  }
  
  def partialSeries(f: Fps): String = {
    var out: String = ""
    var i: BigInt = BigInt(0)
    while (i < BigInt(6)) {
      out = out + " " + padFloat5(extract(f, i), BigInt(8)) + " "
      i = i + BigInt(1)
    }
    return out
  }
  
  def main(): Any = {
    val p: Pair = sinCos()
    println("sin:" + partialSeries(p.sin))
    println("cos:" + partialSeries(p.cos))
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
