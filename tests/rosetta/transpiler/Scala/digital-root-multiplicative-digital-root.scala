// Generated by Mochi v0.10.42 on 2025-07-28 10:32:41 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
object Main {
  case class MDRResult(var mp: BigInt, var mdr: BigInt)
  
  def pad(s: String, width: BigInt): String = {
    var out: String = s
    while ((out).size < width) {
      out = " " + out
    }
    return out
  }
  
  def mult(n: BigInt, base: BigInt): BigInt = {
    var m: BigInt = BigInt(1)
    var x: BigInt = n
    val b: BigInt = (base).asInstanceOf[BigInt]
    while (x > BigInt(0)) {
      m = (m * (x % b)).asInstanceOf[BigInt]
      x = (x / b).asInstanceOf[BigInt]
    }
    return m
  }
  
  def multDigitalRoot(n: BigInt, base: BigInt): MDRResult = {
    var m: BigInt = n
    var mp: BigInt = BigInt(0)
    val b: BigInt = (base).asInstanceOf[BigInt]
    while (m >= b) {
      m = mult(m, base)
      mp = (mp + BigInt(1)).asInstanceOf[BigInt]
    }
    return MDRResult(mp, (m).asInstanceOf[BigInt])
  }
  
  def main(): Any = {
    val base: BigInt = BigInt(10)
    val size: BigInt = BigInt(5)
    println(pad("Number", BigInt(20)) + " " + pad("MDR", BigInt(3)) + " " + pad("MP", BigInt(3)))
    val nums: ArrayBuffer[BigInt] = ArrayBuffer(BigInt(123321), BigInt(7739), BigInt(893), BigInt(899998), BigInt("3778888999"), BigInt("277777788888899"))
    var i: BigInt = BigInt(0)
    while (i < (nums).size) {
      val n: BigInt = nums((i).toInt)
      val r: MDRResult = multDigitalRoot(n, base)
      println(pad((String.valueOf(n)).toString, BigInt(20)) + " " + pad((String.valueOf(r.mdr)).toString, BigInt(3)) + " " + pad((String.valueOf(r.mp)).toString, BigInt(3)))
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    println("")
    var list: ArrayBuffer[ArrayBuffer[BigInt]] = ArrayBuffer()
    var idx: BigInt = BigInt(0)
    while (idx < base) {
      list = list :+ (ArrayBuffer()).asInstanceOf[ArrayBuffer[BigInt]]
      idx = (idx + BigInt(1)).asInstanceOf[BigInt]
    }
    var cnt = size * base
    var n: BigInt = BigInt(0)
    val b: BigInt = (base).asInstanceOf[BigInt]
    while (cnt > BigInt(0)) {
      val r: MDRResult = multDigitalRoot(n, base)
      val mdr: BigInt = r.mdr
      if ((list((mdr).toInt)).size < size) {
        list((mdr).toInt) = list((mdr).toInt) :+ (n).asInstanceOf[BigInt]
        cnt = (cnt - BigInt(1)).asInstanceOf[BigInt]
      }
      n = (n + BigInt(1)).asInstanceOf[BigInt]
    }
    println("MDR: First")
    var j: BigInt = BigInt(0)
    while (j < base) {
      println(pad((String.valueOf(j)).toString, BigInt(3)) + ": " + String.valueOf(list((j).toInt)))
      j = (j + BigInt(1)).asInstanceOf[BigInt]
    }
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
