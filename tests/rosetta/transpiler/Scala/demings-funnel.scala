// Generated by Mochi v0.10.57 on 2025-08-04 21:30:48 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def sqrtApprox(x: Double): Double = {
  if (x <= 0.0) {
    return 0.0
  }
  var g: Double = x
  var i: BigInt = 0
  while (i < 20) {
    g = (g + x / g) / 2.0
    i = i + 1
  }
  return g
}

def funnel(fa: ArrayBuffer[Double], r: (Double, Double) => Double): ArrayBuffer[Double] = {
  var x: Double = 0.0
  var result: ArrayBuffer[Any] = ArrayBuffer()
  var i: BigInt = 0
  while (i < BigInt(((fa).size))) {
    val f: Double = fa((i.toInt).toInt)
    result = result :+ (x + f).asInstanceOf[Any]
    x = r(x, f)
    i = i + 1
  }
  return result.asInstanceOf[ArrayBuffer[Double]]
}

def mean(fa: ArrayBuffer[Double]): Double = {
  var sum: Double = 0.0
  var i: BigInt = 0
  while (i < BigInt(((fa).size))) {
    sum = sum + fa((i.toInt).toInt)
    i = i + 1
  }
  return sum / ((fa).size).toString.toDouble
}

def stdDev(fa: ArrayBuffer[Double]): Double = {
  val m: Double = mean(fa)
  var sum: Double = 0.0
  var i: BigInt = 0
  while (i < BigInt(((fa).size))) {
    val d: Double = fa((i.toInt).toInt) - m
    sum = sum + d * d
    i = i + 1
  }
  val r: Double = sqrtApprox(sum / ((fa).size).toString.toDouble)
  return r
}

def experiment(label: String, r: (Double, Double) => Double): Any = {
  val rxs: ArrayBuffer[Double] = funnel(dxs, r)
  val rys: ArrayBuffer[Double] = funnel(dys, r)
  println(label + "  :      x        y")
  println("Mean    :  " + String.valueOf(mean(rxs)) + ", " + String.valueOf(mean(rys)))
  println("Std Dev :  " + String.valueOf(stdDev(rxs)) + ", " + String.valueOf(stdDev(rys)))
  println("")
}

def main(): Any = {
  experiment("Rule 1", ((x: Double, y: Double) => 0.0))
  experiment("Rule 2", (((x: Double, dz: Double) => -dz)).asInstanceOf[(Double, Double) => Double])
  experiment("Rule 3", (((z: Double, dz: Double) => -z + dz)).asInstanceOf[(Double, Double) => Double])
  experiment("Rule 4", (((z: Double, dz: Double) => z + dz)).asInstanceOf[(Double, Double) => Double])
}

var dxs: ArrayBuffer[Double] = (ArrayBuffer(-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915, 2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, 0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423, -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, 0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106, 0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, 0.087)).asInstanceOf[ArrayBuffer[Double]]

var dys: ArrayBuffer[Double] = (ArrayBuffer(0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, 0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, 0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032)).asInstanceOf[ArrayBuffer[Double]]

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
