// Generated by Mochi v0.10.39 on 2025-07-25 00:49:47 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def sieve(limit: Int): ArrayBuffer[Int] = {
    var spf: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = 0
    while (i <= limit) {
      spf = spf :+ 0
      i = (i + 1).asInstanceOf[Int]
    }
    i = 2
    while (i <= limit) {
      if (spf(i) == 0) {
        spf(i) = i
        if ((i * i).asInstanceOf[Int] <= limit) {
          var j = i * i
          while (j <= limit) {
            if (spf(j) == 0) {
              spf(j) = i
            }
            j = (j + i).asInstanceOf[Int]
          }
        }
      }
      i = (i + 1).asInstanceOf[Int]
    }
    return spf
  }
  
  def primesFrom(spf: ArrayBuffer[Int], limit: Int): ArrayBuffer[Int] = {
    var primes: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = 3
    while (i <= limit) {
      if (spf(i) == i) {
        primes = primes :+ i
      }
      i = (i + 1).asInstanceOf[Int]
    }
    return primes
  }
  
  def pad3(n: Int): String = {
    var s = String.valueOf(n)
    while ((s).size < 3) {
      s = " " + s
    }
    return s
  }
  
  def commatize(n: Int): String = {
    var s = String.valueOf(n)
    var out: String = ""
    var i: Int = (s).size - 1
    var c: Int = 0
    while (i >= 0) {
      out = s.substring(i, i + 1) + out
      c = (c + 1).asInstanceOf[Int]
      if ((c % 3 == 0 && i > 0).asInstanceOf[Boolean]) {
        out = "," + out
      }
      i = (i - 1).asInstanceOf[Int]
    }
    return out
  }
  
  def primeCount(primes: ArrayBuffer[Int], last: Int, spf: ArrayBuffer[Int]): Int = {
    var lo: Int = 0
    var hi: Int = (primes).size
    while (lo < hi) {
      var mid: Int = ((lo + hi) / 2).asInstanceOf[Int]
      if (primes(mid) < last) {
        lo = (mid + 1).asInstanceOf[Int]
      } else {
        hi = mid
      }
    }
    var count = lo + 1
    if (spf(last) != last) {
      count = (count - 1).asInstanceOf[Int]
    }
    return count
  }
  
  def arithmeticNumbers(limit: Int, spf: ArrayBuffer[Int]): ArrayBuffer[Int] = {
    var arr: ArrayBuffer[Int] = ArrayBuffer(1)
    var n: Int = 3
    while ((arr).size < limit) {
      if (spf(n) == n) {
        arr = arr :+ n
      } else {
        var x: Int = n
        var sigma: Int = 1
        var tau: Int = 1
        while (x > 1) {
          var p: Int = spf(x)
          if (p == 0) {
            p = x
          }
          var cnt: Int = 0
          var power: Int = p
          var sum: Int = 1
          while (x % p == 0) {
            x = (x / p).asInstanceOf[Int]
            cnt = (cnt + 1).asInstanceOf[Int]
            sum = (sum + power).asInstanceOf[Int]
            power = (power * p).asInstanceOf[Int]
          }
          sigma = (sigma * sum).asInstanceOf[Int]
          tau = (tau * (cnt + 1)).asInstanceOf[Int]
        }
        if (sigma % tau == 0) {
          arr = arr :+ n
        }
      }
      n = (n + 1).asInstanceOf[Int]
    }
    return arr
  }
  
  def main() = {
    val limit: Int = 1228663
    val spf: ArrayBuffer[Int] = sieve(limit)
    val primes: ArrayBuffer[Int] = primesFrom(spf, limit)
    val arr: ArrayBuffer[Int] = arithmeticNumbers(1000000, spf)
    println("The first 100 arithmetic numbers are:")
    var i: Int = 0
    while (i < 100) {
      var line: String = ""
      var j: Int = 0
      while (j < 10) {
        line = (line + pad3(arr(i + j))).asInstanceOf[String]
        if (j < 9) {
          line = line + " "
        }
        j = (j + 1).asInstanceOf[Int]
      }
      println(line)
      i = (i + 10).asInstanceOf[Int]
    }
    for (x <- ArrayBuffer(1000, 10000, 100000, 1000000)) {
      val last: Int = arr(x - 1)
      val lastc: String = commatize(last)
      println("\nThe " + commatize(x.asInstanceOf[Int]) + "th arithmetic number is: " + lastc)
      val pc: Int = primeCount(primes, last, spf)
      val comp = x - pc - 1
      println("The count of such numbers <= " + lastc + " which are composite is " + commatize(comp.asInstanceOf[Int]) + ".")
    }
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
