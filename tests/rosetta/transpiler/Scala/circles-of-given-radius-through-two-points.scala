// Generated by Mochi v0.10.41 on 2025-07-27 16:19:12 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
object Main {
  case class Point(var x: Double, var y: Double)
  
  def sqrtApprox(x: Double): Double = {
    var g: Double = x
    var i: BigInt = BigInt(0)
    while (i < BigInt(40)) {
      g = (g + x / g) / 2.0
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    return g
  }
  
  def hypot(x: Double, y: Double): Double = {
    return sqrtApprox((x * x).toString.toDouble + (y * y).toString.toDouble)
  }
  
  def circles(p1: Point, p2: Point, r: Double): ArrayBuffer[Any] = {
    if ((p1.x == p2.x && p1.y == p2.y).asInstanceOf[Boolean]) {
      if (r == 0.0) {
        return ArrayBuffer(p1, p1, "Coincident points with r==0.0 describe a degenerate circle.")
      }
      return ArrayBuffer(p1, p2, "Coincident points describe an infinite number of circles.")
    }
    if (r == 0.0) {
      return ArrayBuffer(p1, p2, "R==0.0 does not describe circles.")
    }
    val dx = p2.x - p1.x
    val dy = p2.y - p1.y
    val q: Double = hypot(dx, dy)
    if (q > 2.0 * r) {
      return ArrayBuffer(p1, p2, "Points too far apart to form circles.")
    }
    val m: Point = Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0)
    if (q == 2.0 * r) {
      return ArrayBuffer(m, m, "Points form a diameter and describe only a single circle.")
    }
    val d: Double = sqrtApprox(r * r - q * q / 4.0)
    val ox = d * dx / q
    val oy = d * dy / q
    return ArrayBuffer(Point(m.x - oy, m.y + ox), Point(m.x + oy, m.y - ox), "Two circles.")
  }
  
  val Two: String = "Two circles."
  
  val R0: String = "R==0.0 does not describe circles."
  
  val Co: String = "Coincident points describe an infinite number of circles."
  
  val CoR0: String = "Coincident points with r==0.0 describe a degenerate circle."
  
  val Diam: String = "Points form a diameter and describe only a single circle."
  
  val Far: String = "Points too far apart to form circles."
  
  var td: ArrayBuffer[ArrayBuffer[Any]] = ArrayBuffer(ArrayBuffer(Point(0.1234, 0.9876), Point(0.8765, 0.2345), 2.0), ArrayBuffer(Point(0.0, 2.0), Point(0.0, 0.0), 1.0), ArrayBuffer(Point(0.1234, 0.9876), Point(0.1234, 0.9876), 2.0), ArrayBuffer(Point(0.1234, 0.9876), Point(0.8765, 0.2345), 0.5), ArrayBuffer(Point(0.1234, 0.9876), Point(0.1234, 0.9876), 0.0))
  
  def main(args: Array[String]): Unit = {
    for (tc <- td) {
      val p1 = tc(BigInt(0))
      val p2 = tc(BigInt(1))
      val r = tc(BigInt(2))
      println("p1:  {" + String.valueOf(p1.x) + " " + String.valueOf(p1.y) + "}")
      println("p2:  {" + String.valueOf(p2.x) + " " + String.valueOf(p2.y) + "}")
      println("r:  " + String.valueOf(r))
      val res: ArrayBuffer[Any] = circles(p1.asInstanceOf[Point], p2.asInstanceOf[Point], r.toString.toDouble)
      val c1 = res((BigInt(0)).toInt)
      val c2 = res((BigInt(1)).toInt)
      val caseStr = res((BigInt(2)).toInt)
      println("   " + caseStr.toString)
      if ((caseStr == "Points form a diameter and describe only a single circle." || caseStr == "Coincident points with r==0.0 describe a degenerate circle.").asInstanceOf[Boolean]) {
        println("   Center:  {" + String.valueOf(c1.x) + " " + String.valueOf(c1.y) + "}")
      } else {
        if (caseStr == "Two circles.") {
          println("   Center 1:  {" + String.valueOf(c1.x) + " " + String.valueOf(c1.y) + "}")
          println("   Center 2:  {" + String.valueOf(c2.x) + " " + String.valueOf(c2.y) + "}")
        }
      }
      println("")
    }
  }
}
