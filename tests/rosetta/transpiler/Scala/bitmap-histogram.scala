// Generated by Mochi v0.10.40 on 2025-07-26 04:50:11 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    def image(): ArrayBuffer[ArrayBuffer[Int]] = {
      return ArrayBuffer(ArrayBuffer(0, 0, 10000), ArrayBuffer(65535, 65535, 65535), ArrayBuffer(65535, 65535, 65535))
    }
    def histogram(g: ArrayBuffer[ArrayBuffer[Int]], _bins: Int): ArrayBuffer[Int] = {
      var bins: Int = _bins
      if (bins <= 0) {
        bins = (g(0)).size
      }
      var h: ArrayBuffer[Int] = ArrayBuffer()
      var i: Int = 0
      while (i < bins) {
        h = h :+ 0
        i = (i + 1).asInstanceOf[Int]
      }
      var y: Int = 0
      while (y < (g).size) {
        var row: ArrayBuffer[Int] = g(y)
        var x: Int = 0
        while (x < (row).size) {
          var p: Int = row(x)
          var idx: Int = (p * (bins - 1) / 65535).asInstanceOf[Int]
          h(idx) = h(idx) + 1
          x = (x + 1).asInstanceOf[Int]
        }
        y = (y + 1).asInstanceOf[Int]
      }
      return h
    }
    def medianThreshold(h: ArrayBuffer[Int]): Int = {
      var lb: Int = 0
      var ub: Int = (h).size - 1
      var lSum: Int = 0
      var uSum: Int = 0
      while (lb <= ub) {
        if ((lSum + h(lb)).toString < (uSum + h(ub)).toString) {
          lSum = (lSum + h(lb)).asInstanceOf[Int]
          lb = (lb + 1).asInstanceOf[Int]
        } else {
          uSum = (uSum + h(ub)).asInstanceOf[Int]
          ub = (ub - 1).asInstanceOf[Int]
        }
      }
      return (ub * 65535 / (h).size).asInstanceOf[Int]
    }
    def threshold(g: ArrayBuffer[ArrayBuffer[Int]], t: Int): ArrayBuffer[ArrayBuffer[Int]] = {
      var out: ArrayBuffer[ArrayBuffer[Int]] = ArrayBuffer()
      var y: Int = 0
      while (y < (g).size) {
        var row: ArrayBuffer[Int] = g(y)
        var newRow: ArrayBuffer[Int] = ArrayBuffer()
        var x: Int = 0
        while (x < (row).size) {
          if (row(x) < t) {
            newRow = newRow :+ 0
          } else {
            newRow = newRow :+ 65535
          }
          x = (x + 1).asInstanceOf[Int]
        }
        out = out :+ newRow
        y = (y + 1).asInstanceOf[Int]
      }
      return out
    }
    def printImage(g: ArrayBuffer[ArrayBuffer[Int]]): Any = {
      var y: Int = 0
      while (y < (g).size) {
        var row: ArrayBuffer[Int] = g(y)
        var line: String = ""
        var x: Int = 0
        while (x < (row).size) {
          if (row(x) == 0) {
            line = line + "0"
          } else {
            line = line + "1"
          }
          x = (x + 1).asInstanceOf[Int]
        }
        println(line)
        y = (y + 1).asInstanceOf[Int]
      }
    }
    def main(): Any = {
      val img: ArrayBuffer[ArrayBuffer[Int]] = image()
      val h: ArrayBuffer[Int] = histogram(img, 0)
      println("Histogram: " + String.valueOf(h))
      val t: Int = medianThreshold(h)
      println("Threshold: " + String.valueOf(t))
      val bw: ArrayBuffer[ArrayBuffer[Int]] = threshold(img, t)
      printImage(bw)
    }
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
