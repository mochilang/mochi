// Generated by Mochi v0.10.39 on 2025-07-25 09:42:06 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  def fields(s: String): ArrayBuffer[String] = {
    var words: ArrayBuffer[String] = ArrayBuffer()
    var cur: String = ""
    var i: Int = 0
    while (i < (s).size) {
      val ch: String = s.substring(i, i + 1)
      if (ch == " " || ch == "\n" || ch == "\t") {
        if ((cur).size > 0) {
          words = words :+ cur
          cur = ""
        }
      } else {
        cur = cur + ch
      }
      i = i + 1
    }
    if ((cur).size > 0) {
      words = words :+ cur
    }
    return words
  }
  
  def padRight(s: String, width: Int): String = {
    var out: String = s
    var i: Int = (s).size
    while (i < width) {
      out = out + " "
      i = i + 1
    }
    return out
  }
  
  def join(xs: ArrayBuffer[String], sep: String): String = {
    var res: String = ""
    var i: Int = 0
    while (i < (xs).size) {
      if (i > 0) {
        res = res + sep
      }
      res = res + xs(i)
      i = i + 1
    }
    return res
  }
  
  def validate(commands: ArrayBuffer[String], words: ArrayBuffer[String], mins: ArrayBuffer[Int]): ArrayBuffer[String] = {
    var results: ArrayBuffer[String] = ArrayBuffer()
    if ((words).size == 0) {
      return results
    }
    var wi: Int = 0
    val _br3 = new Breaks
    _br3.breakable {
      while (wi < (words).size) {
        val w: String = words(wi)
        var found: Boolean = false
        val wlen: Int = (w).size
        var ci: Int = 0
        val _br4 = new Breaks
        _br4.breakable {
          while (ci < (commands).size) {
            val cmd: String = commands(ci)
            if (mins(ci) != 0 && wlen >= mins(ci) && wlen <= (cmd).size) {
              val c = cmd.toUpperCase()
              val ww = w.toUpperCase()
              if (c.substring(0, wlen) == ww) {
                results = results :+ c
                found = true
                _br4.break()
              }
            }
            ci = ci + 1
          }
        }
        if ((!found).asInstanceOf[Boolean]) {
          results = results :+ "*error*"
        }
        wi = wi + 1
      }
    }
    return results
  }
  
  def main(): Unit = {
    val table: String = "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " + "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find " + "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput " + " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO " + "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT " + "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT " + "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "
    val commands: ArrayBuffer[String] = fields(table)
    var mins: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = 0
    while (i < (commands).size) {
      var count: Int = 0
      var j: Int = 0
      val cmd: String = commands(i)
      while (j < (cmd).size) {
        val ch: String = cmd.substring(j, j + 1)
        if (ch >= "A" && ch <= "Z") {
          count = count + 1
        }
        j = j + 1
      }
      mins = mins :+ count
      i = i + 1
    }
    val sentence: String = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"
    val words: ArrayBuffer[String] = fields(sentence)
    val results: ArrayBuffer[String] = validate(commands, words, mins)
    var out1: String = "user words:  "
    var k: Int = 0
    while (k < (words).size) {
      out1 = out1 + padRight(words(k), (results(k)).size) + " "
      k = k + 1
    }
    println(out1)
    println("full words:  " + join(results, " "))
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
