// Generated by Mochi v0.10.37 on 2025-07-22 20:23:25 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def fields(s: String): ArrayBuffer[String] = {
    var words: ArrayBuffer[String] = ArrayBuffer()
    var cur: String = ""
    var i: Int = 0
    while (i < (s).size) {
      val ch: String = s.substring(i, i + 1)
      if (ch == " " || ch == "\n" || ch == "\t") {
        if ((cur).size > 0) {
          words = words :+ cur
          cur = ""
        }
      } else {
        cur = cur + ch
      }
      i = i + 1
    }
    if ((cur).size > 0) {
      words = words :+ cur
    }
    return words
  }
  
  def padRight(s: String, width: Int): String = {
    var out = s
    var i: Int = (s).size
    while (i < width) {
      out = out + " "
      i = i + 1
    }
    return out
  }
  
  def join(xs: ArrayBuffer[String], sep: String): String = {
    var res: String = ""
    var i: Int = 0
    while (i < (xs).size) {
      if (i > 0) {
        res = res + sep
      }
      res = res + xs(i)
      i = i + 1
    }
    return res
  }
  
  def validate(commands: ArrayBuffer[String], words: ArrayBuffer[String], mins: ArrayBuffer[Int]): ArrayBuffer[String] = {
    var results: ArrayBuffer[String] = ArrayBuffer()
    if ((words).size == 0) {
      return results
    }
    var wi: Int = 0
    while (wi < (words).size) {
      val w: Any = words(wi)
      var found: Boolean = false
      val wlen: Int = (w).size
      var ci: Int = 0
      while (ci < (commands).size) {
        val cmd: Any = commands(ci)
        if (mins(ci) != 0 && wlen >= mins(ci) && wlen <= (cmd).size) {
          val c = upper(cmd)
          val ww = upper(w)
          if (c.substring(0, wlen) == ww) {
            results = results :+ c
            found = true
            break
          }
        }
        ci = ci + 1
      }
      if (!found) {
        results = results :+ "*error*"
      }
      wi = wi + 1
    }
    return results
  }
  
  def main() = {
    val table: Int = "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " + "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find " + "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput " + " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO " + "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT " + "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT " + "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "
    val commands = fields(table)
    var mins: ArrayBuffer[Int] = ArrayBuffer()
    var i: Int = 0
    while (i < (commands).size) {
      var count: Int = 0
      var j: Int = 0
      val cmd: Any = commands(i)
      while (j < (cmd).size) {
        val ch: String = cmd.substring(j, j + 1)
        if (ch >= "A" && ch <= "Z") {
          count = count + 1
        }
        j = j + 1
      }
      mins = mins :+ count
      i = i + 1
    }
    val sentence: String = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"
    val words = fields(sentence)
    val results = validate(commands, words, mins)
    var out1: String = "user words:  "
    var k: Int = 0
    while (k < (words).size) {
      out1 = out1 + padRight(words(k), (results(k)).size) + " "
      k = k + 1
    }
    println(out1)
    println("full words:  " + join(results, " "))
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
