// Generated by Mochi v0.10.39 on 2025-07-25 01:20:27 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def sinApprox(x: Double): Double = {
    var term: Double = x
    var sum: Double = x
    var n: Int = 1
    while (n <= 8) {
      val denom: Double = ((2 * n).asInstanceOf[Double] * (2 * n + 1).asInstanceOf[Double]).toString.toDouble
      term = ((0 - term) * x * x / denom).asInstanceOf[Double]
      sum = (sum + term).asInstanceOf[Double]
      n = (n + 1).asInstanceOf[Int]
    }
    return sum
  }
  
  def cosApprox(x: Double): Double = {
    var term: Double = 1.0
    var sum: Double = 1.0
    var n: Int = 1
    while (n <= 8) {
      val denom: Double = ((2 * n - 1).asInstanceOf[Double] * (2 * n).asInstanceOf[Double]).toString.toDouble
      term = ((0 - term) * x * x / denom).asInstanceOf[Double]
      sum = (sum + term).asInstanceOf[Double]
      n = (n + 1).asInstanceOf[Int]
    }
    return sum
  }
  
  def atanApprox(x: Double): Double = {
    if (x > 1.0) {
      return PI / 2.0 - x / (x * x + 0.28)
    }
    if (x < 0 - 1.0) {
      return (0 - PI) / 2.0 - x / (x * x + 0.28)
    }
    return x / (1.0 + 0.28 * x * x)
  }
  
  def atan2Approx(y: Double, x: Double): Double = {
    if (x > 0.0) {
      return atanApprox((y / x).asInstanceOf[Double])
    }
    if (x < 0.0) {
      if (y >= 0.0) {
        return (atanApprox((y / x).asInstanceOf[Double]) + PI).asInstanceOf[Double]
      }
      return (atanApprox((y / x).asInstanceOf[Double]) - PI).asInstanceOf[Double]
    }
    if (y > 0.0) {
      return PI / 2.0
    }
    if (y < 0.0) {
      return (0 - PI) / 2.0
    }
    return 0.0
  }
  
  def digit(ch: String): Int = {
    val digits: String = "0123456789"
    var i: Int = 0
    while (i < (digits).size) {
      if (digits.substring(i, i + 1) == ch) {
        return i
      }
      i = (i + 1).asInstanceOf[Int]
    }
    return 0
  }
  
  def parseTwo(s: String, idx: Int): Int = {
    return (digit(s.substring(idx, idx + 1)) * 10 + digit(s.substring(idx + 1, idx + 2))).asInstanceOf[Int]
  }
  
  def parseSec(s: String): Double = {
    val h: Int = parseTwo(s, 0)
    val m: Int = parseTwo(s, 3)
    val sec: Int = parseTwo(s, 6)
    val tmp = (h * 60 + m) * 60 + sec
    return tmp.toString.toDouble
  }
  
  def pad(n: Int): String = {
    if (n < 10) {
      return "0" + String.valueOf(n)
    }
    return (String.valueOf(n)).asInstanceOf[String]
  }
  
  def meanTime(times: ArrayBuffer[String]): String = {
    var ssum: Double = 0.0
    var csum: Double = 0.0
    var i: Int = 0
    while (i < (times).size) {
      val sec: Double = parseSec(times(i))
      val ang: Double = sec * 2.0 * PI / 86400.0
      ssum = (ssum + sinApprox(ang)).asInstanceOf[Double]
      csum = (csum + cosApprox(ang)).asInstanceOf[Double]
      i = (i + 1).asInstanceOf[Int]
    }
    var theta: Double = atan2Approx(ssum, csum)
    var frac: Double = theta / 2.0 * PI
    while (frac < 0.0) {
      frac = frac + 1.0
    }
    val total: Double = frac * 86400.0
    val si: Int = total.asInstanceOf[Int]
    val h: Int = (si / 3600).asInstanceOf[Int]
    val m: Int = (Math.floorMod(si, 3600) / 60).asInstanceOf[Int]
    val s: Int = (Math.floorMod(si, 60)).asInstanceOf[Int]
    return pad(h) + ":" + pad(m) + ":" + pad(s)
  }
  
  def main() = {
    val inputs: ArrayBuffer[String] = ArrayBuffer("23:00:17", "23:40:20", "00:12:45", "00:17:19")
    println(meanTime(inputs))
  }
  
  val PI: Double = 3.141592653589793
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
