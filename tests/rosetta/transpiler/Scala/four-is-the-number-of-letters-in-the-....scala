// Generated by Mochi v0.10.50 on 2025-07-31 01:08:14 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    val small: ArrayBuffer[String] = ArrayBuffer("zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen")
    val tens: ArrayBuffer[String] = ArrayBuffer("", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety")
    val smallOrd: ArrayBuffer[String] = ArrayBuffer("zeroth", "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth", "seventeenth", "eighteenth", "nineteenth")
    val tensOrd: ArrayBuffer[String] = ArrayBuffer("", "", "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth", "seventieth", "eightieth", "ninetieth")
    def say(n: BigInt): String = {
      if (n < BigInt(20)) {
        return small((n).toInt)
      }
      if (n < BigInt(100)) {
        var res: String = tens((n / BigInt(10)).toInt)
        val m: BigInt = n % BigInt(10)
        if (m != BigInt(0)) {
          res = res + "-" + small((m).toInt)
        }
        return res
      }
      if (n < BigInt(1000)) {
        var res: String = say(n / BigInt(100)) + " hundred"
        val m: BigInt = n % BigInt(100)
        if (m != BigInt(0)) {
          res = res + " " + say(m)
        }
        return res
      }
      if (n < BigInt(1000000)) {
        var res: String = say(n / BigInt(1000)) + " thousand"
        val m: BigInt = n % BigInt(1000)
        if (m != BigInt(0)) {
          res = res + " " + say(m)
        }
        return res
      }
      var res: String = say(n / BigInt(1000000)) + " million"
      val m: BigInt = n % BigInt(1000000)
      if (m != BigInt(0)) {
        res = res + " " + say(m)
      }
      return res
    }
    def sayOrdinal(n: BigInt): String = {
      if (n < BigInt(20)) {
        return smallOrd((n).toInt)
      }
      if (n < BigInt(100)) {
        if (n % BigInt(10) == BigInt(0)) {
          return tensOrd((n / BigInt(10)).toInt)
        }
        return say(n - n % BigInt(10)) + "-" + smallOrd((n % BigInt(10)).toInt)
      }
      if (n < BigInt(1000)) {
        if (n % BigInt(100) == BigInt(0)) {
          return say(n / BigInt(100)) + " hundredth"
        }
        return say(n / BigInt(100)) + " hundred " + sayOrdinal(n % BigInt(100))
      }
      if (n < BigInt(1000000)) {
        if (n % BigInt(1000) == BigInt(0)) {
          return say(n / BigInt(1000)) + " thousandth"
        }
        return say(n / BigInt(1000)) + " thousand " + sayOrdinal(n % BigInt(1000))
      }
      if (n % BigInt(1000000) == BigInt(0)) {
        return say(n / BigInt(1000000)) + " millionth"
      }
      return say(n / BigInt(1000000)) + " million " + sayOrdinal(n % BigInt(1000000))
    }
    def split(s: String, sep: String): ArrayBuffer[String] = {
      var parts: ArrayBuffer[String] = ArrayBuffer()
      var cur: String = ""
      var i: BigInt = BigInt(0)
      while (i < (s).size) {
        if ((((sep).size > BigInt(0) && i + (sep).size <= (s).size).asInstanceOf[Boolean] && s.slice((i).toInt, (i + (sep).size).toInt) == sep).asInstanceOf[Boolean]) {
          parts = parts :+ cur
          cur = ""
          i = i + (sep).size
        } else {
          cur = cur + s.slice((i).toInt, (i + BigInt(1)).toInt)
          i = i + BigInt(1)
        }
      }
      parts = parts :+ cur
      return parts
    }
    def countLetters(s: String): BigInt = {
      var cnt: BigInt = BigInt(0)
      var i: BigInt = BigInt(0)
      while (i < (s).size) {
        val ch: String = s.slice((i).toInt, (i + BigInt(1)).toInt)
        if (((ch >= "A" && ch <= "Z").asInstanceOf[Boolean] || (ch >= "a" && ch <= "z").asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
          cnt = cnt + BigInt(1)
        }
        i = i + BigInt(1)
      }
      return cnt
    }
    var words: ArrayBuffer[String] = ArrayBuffer("Four", "is", "the", "number", "of", "letters", "in", "the", "first", "word", "of", "this", "sentence,")
    var idx: BigInt = BigInt(0)
    def wordLen(w: BigInt): ArrayBuffer[Any] = {
      while ((words).size < w) {
        idx = idx + BigInt(1)
        val n: BigInt = countLetters(words((idx).toInt))
        var parts = ArrayBuffer(say(n).split(" "): _*)
        var j: BigInt = BigInt(0)
        while (j < (parts).size) {
          words = words :+ parts((j).toInt)
          j = j + BigInt(1)
        }
        words = words :+ "in"
        words = words :+ "the"
        parts = (ArrayBuffer(sayOrdinal(idx + BigInt(1)) + ",".split(" "): _*)).asInstanceOf[ArrayBuffer[String]]
        j = BigInt(0)
        while (j < (parts).size) {
          words = words :+ parts((j).toInt)
          j = j + BigInt(1)
        }
      }
      val word: String = words((w - BigInt(1)).toInt)
      return ArrayBuffer(word, countLetters(word))
    }
    def totalLength(): BigInt = {
      var tot: BigInt = BigInt(0)
      var i: BigInt = BigInt(0)
      while (i < (words).size) {
        tot = tot + (words((i).toInt)).size
        if (i < (words).size - BigInt(1)) {
          tot = tot + BigInt(1)
        }
        i = i + BigInt(1)
      }
      return tot
    }
    def pad(n: BigInt, width: BigInt): String = {
      var s: String = String.valueOf(n)
      while ((s).size < width) {
        s = " " + s
      }
      return s
    }
    def main(): Any = {
      println("The lengths of the first 201 words are:")
      var line: String = ""
      var i: BigInt = BigInt(1)
      while (i <= BigInt(201)) {
        if (i % BigInt(25) == BigInt(1)) {
          if (i != BigInt(1)) {
            println(line)
          }
          line = pad(i, BigInt(3)) + ":"
        }
        val r: ArrayBuffer[Any] = wordLen(i)
        val n = r((BigInt(1)).toInt)
        line = line + " " + pad(n.asInstanceOf[BigInt], BigInt(2))
        i = i + BigInt(1)
      }
      println(line)
      println("Length of sentence so far: " + String.valueOf(totalLength()))
      for (n <- ArrayBuffer(BigInt(1000), BigInt(10000), BigInt(100000), BigInt(1000000), BigInt(10000000))) {
        val r: ArrayBuffer[Any] = wordLen(n)
        val w = r((BigInt(0)).toInt)
        val l = r((BigInt(1)).toInt)
        println("Word " + pad(n, BigInt(8)) + " is \"" + w + "\", with " + String.valueOf(l) + " letters.  Length of sentence so far: " + String.valueOf(totalLength()))
      }
    }
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
