// Generated by Mochi v0.10.39 on 2025-07-25 01:20:10 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def randOrder(seed: Int, n: Int): ArrayBuffer[Int] = {
    val next = (seed * 1664525 + 1013904223) % 2147483647
    return (ArrayBuffer(next, Math.floorMod(next, n))).asInstanceOf[ArrayBuffer[Int]]
  }
  
  def randChaos(seed: Int, n: Int): ArrayBuffer[Int] = {
    val next = (seed * 1103515245 + 12345) % 2147483647
    return (ArrayBuffer(next, Math.floorMod(next, n))).asInstanceOf[ArrayBuffer[Int]]
  }
  
  def main() = {
    val nBuckets: Int = 10
    val initialSum: Int = 1000
    var buckets: ArrayBuffer[Int] = ArrayBuffer()
    for (i <- 0 until nBuckets) {
      buckets = buckets :+ 0
    }
    var i: Int = nBuckets
    var dist: Int = initialSum
    while (i > 0) {
      val v = dist / i
      i = (i - 1).asInstanceOf[Int]
      buckets(i) = v
      dist = (dist - v).asInstanceOf[Int]
    }
    var tc0: Int = 0
    var tc1: Int = 0
    var total: Int = 0
    var nTicks: Int = 0
    var seedOrder: Int = 1
    var seedChaos: Int = 2
    println("sum  ---updates---    mean  buckets")
    var t: Int = 0
    while (t < 5) {
      var r: ArrayBuffer[Int] = randOrder(seedOrder, nBuckets)
      seedOrder = r(0)
      var b1: Int = r(1)
      var b2 = (b1 + 1) % nBuckets
      val v1: Int = buckets(b1)
      val v2: Int = buckets(b2)
      if (v1 > v2) {
        var a: Int = ((v1 - v2) / 2).asInstanceOf[Int]
        if (a > buckets(b1)) {
          a = buckets(b1)
        }
        buckets(b1) = (buckets(b1) - a).asInstanceOf[Int]
        buckets(b2) = (buckets(b2) + a).asInstanceOf[Int]
      } else {
        var a: Int = ((v2 - v1) / 2).asInstanceOf[Int]
        if (a > buckets(b2)) {
          a = buckets(b2)
        }
        buckets(b2) = (buckets(b2) - a).asInstanceOf[Int]
        buckets(b1) = (buckets(b1) + a).asInstanceOf[Int]
      }
      tc0 = (tc0 + 1).asInstanceOf[Int]
      r = randChaos(seedChaos, nBuckets)
      seedChaos = r(0)
      b1 = r(1)
      b2 = ((b1 + 1) % nBuckets).asInstanceOf[Int]
      r = randChaos(seedChaos, buckets(b1) + 1)
      seedChaos = r(0)
      var amt: Int = r(1)
      if (amt > buckets(b1)) {
        amt = buckets(b1)
      }
      buckets(b1) = (buckets(b1) - amt).asInstanceOf[Int]
      buckets(b2) = (buckets(b2) + amt).asInstanceOf[Int]
      tc1 = (tc1 + 1).asInstanceOf[Int]
      var sum: Int = 0
      var idx: Int = 0
      while (idx < nBuckets) {
        sum = (sum + buckets(idx)).asInstanceOf[Int]
        idx = (idx + 1).asInstanceOf[Int]
      }
      total = (total + tc0 + tc1).asInstanceOf[Int]
      nTicks = (nTicks + 1).asInstanceOf[Int]
      println(String.valueOf(sum) + " " + String.valueOf(tc0) + " " + String.valueOf(tc1) + " " + String.valueOf(total / nTicks) + "  " + String.valueOf(buckets))
      tc0 = 0
      tc1 = 0
      t = (t + 1).asInstanceOf[Int]
    }
  }
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
