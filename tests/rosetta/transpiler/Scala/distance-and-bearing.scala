// Generated by Mochi v0.10.57 on 2025-08-05 01:28:28 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Airport(var name: String, var country: String, var icao: String, var lat: Double, var lon: Double)

def sinApprox(x: Double): Double = {
  var term: Double = x
  var sum: Double = x
  var n: BigInt = 1
  while (n <= 8) {
    val denom: Double = (2 * n * (2 * n + 1)).toString.toDouble
    term = -term * x * x / denom
    sum = sum + term
    n = n + 1
  }
  return sum
}

def cosApprox(x: Double): Double = {
  var term: Double = 1.0
  var sum: Double = 1.0
  var n: BigInt = 1
  while (n <= 8) {
    val denom: Double = ((2 * n - 1) * (2 * n)).toString.toDouble
    term = -term * x * x / denom
    sum = sum + term
    n = n + 1
  }
  return sum
}

def atanApprox(x: Double): Double = {
  if (x > 1.0) {
    return PI / 2.0 - x / (x * x + 0.28)
  }
  if (x < -1.0) {
    return -PI / 2.0 - x / (x * x + 0.28)
  }
  return x / (1.0 + 0.28 * x * x)
}

def atan2Approx(y: Double, x: Double): Double = {
  if (x > 0.0) {
    val r: Double = atanApprox(y / x)
    return r
  }
  if (x < 0.0) {
    if (y >= 0.0) {
      return atanApprox(y / x) + PI
    }
    return atanApprox(y / x) - PI
  }
  if (y > 0.0) {
    return PI / 2.0
  }
  if (y < 0.0) {
    return -PI / 2.0
  }
  return 0.0
}

def sqrtApprox(x: Double): Double = {
  var guess: Double = x
  var i: BigInt = 0
  while (i < 10) {
    guess = (guess + x / guess) / 2.0
    i = i + 1
  }
  return guess
}

def rad(x: Double): Double = {
  return x * PI / 180.0
}

def deg(x: Double): Double = {
  return x * 180.0 / PI
}

def distance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double = {
  val phi1: Double = rad(lat1)
  val phi2: Double = rad(lat2)
  val dphi: Double = rad(lat2 - lat1)
  val dlambda: Double = rad(lon2 - lon1)
  val sdphi: Double = sinApprox(dphi / 2.toString.toDouble)
  val sdlambda: Double = sinApprox(dlambda / 2.toString.toDouble)
  val a: Double = sdphi * sdphi + cosApprox(phi1) * cosApprox(phi2) * sdlambda * sdlambda
  val c: Double = 2.toString.toDouble * atan2Approx(sqrtApprox(a), sqrtApprox(1.toString.toDouble - a))
  return 6371.0 / 1.852 * c
}

def bearing(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double = {
  val phi1: Double = rad(lat1)
  val phi2: Double = rad(lat2)
  val dl: Double = rad(lon2 - lon1)
  val y: Double = sinApprox(dl) * cosApprox(phi2)
  val x: Double = cosApprox(phi1) * sinApprox(phi2) - sinApprox(phi1) * cosApprox(phi2) * cosApprox(dl)
  var br: Double = deg(atan2Approx(y, x))
  if (br < 0.toString.toDouble) {
    br = br + 360.toString.toDouble
  }
  return br
}

def floor(x: Double): Double = {
  var i: Int = x.toInt
  if (i.toString.toDouble > x) {
    i = i - 1.toInt
  }
  return i.toString.toDouble
}

def pow10(n: BigInt): Double = {
  var p: Double = 1.0
  var i: BigInt = 0
  while (i < n) {
    p = p * 10.0
    i = i + 1
  }
  return p
}

def round(x: Double, n: BigInt): Double = {
  val m: Double = pow10(n)
  return floor(x * m + 0.5) / m
}

def sortByDistance(xs: ArrayBuffer[ArrayBuffer[Any]]): ArrayBuffer[ArrayBuffer[Any]] = {
  var arr: ArrayBuffer[ArrayBuffer[Any]] = xs
  var i: BigInt = 1
  while (i < BigInt((arr).size)) {
    var j: BigInt = i
    while (j > 0 && (arr(((j - 1).toInt).toInt)((0.toInt).toInt)).toString > (arr((j.toInt).toInt)((0.toInt).toInt)).toString) {
      val tmp: ArrayBuffer[Any] = arr(((j - 1).toInt).toInt)
      arr((j - 1).toInt) = arr((j.toInt).toInt)
      arr((j).toInt) = tmp
      j = j - 1
    }
    i = i + 1
  }
  return arr
}

def main(): Any = {
  val planeLat: Double = 51.514669
  val planeLon: Double = 2.198581
  var results: ArrayBuffer[ArrayBuffer[Any]] = (ArrayBuffer()).asInstanceOf[ArrayBuffer[ArrayBuffer[Any]]]
  for (ap <- airports) {
    val d: Double = distance(planeLat, planeLon, ap.asInstanceOf[Airport].lat, ap.asInstanceOf[Airport].lon)
    val b: Double = bearing(planeLat, planeLon, ap.asInstanceOf[Airport].lat, ap.asInstanceOf[Airport].lon)
    results = results :+ (ArrayBuffer(d, b, ap)).asInstanceOf[ArrayBuffer[Any]]
  }
  results = sortByDistance(results)
  println("Distance Bearing ICAO Country               Airport")
  println("--------------------------------------------------------------")
  var i: BigInt = 0
  while (i < BigInt((results).size)) {
    val r: ArrayBuffer[Any] = results((i.toInt).toInt)
    val ap: Any = r((2.toInt).toInt)
    val dist: Any = r((0.toInt).toInt)
    val bear: Any = r((1.toInt).toInt)
    val line: String = String.valueOf(round(dist.toString.toDouble, 1)) + "\t" + String.valueOf(round(bear.toString.toDouble, 0)) + "\t" + ap.asInstanceOf[Airport].icao + "\t" + ap.asInstanceOf[Airport].country + " " + ap.asInstanceOf[Airport].name
    println(line)
    i = i + 1
  }
}

val PI: Double = 3.141592653589793

val airports: ArrayBuffer[Airport] = ArrayBuffer(Airport("Koksijde Air Base", "Belgium", "EBFN", 51.090301513671875, 2.652780055999756), Airport("Ostend-Bruges International Airport", "Belgium", "EBOS", 51.198898315399994, 2.8622200489), Airport("Kent International Airport", "United Kingdom", "EGMH", 51.342201, 1.34611), Airport("Calais-Dunkerque Airport", "France", "LFAC", 50.962100982666016, 1.954759955406189), Airport("Westkapelle heliport", "Belgium", "EBKW", 51.32222366333, 3.2930560112), Airport("Lympne Airport", "United Kingdom", "EGMK", 51.08, 1.013), Airport("Ursel Air Base", "Belgium", "EBUL", 51.14419937133789, 3.475559949874878), Airport("Southend Airport", "United Kingdom", "EGMC", 51.5713996887207, 0.6955559849739075), Airport("Merville-Calonne Airport", "France", "LFQT", 50.61840057373047, 2.642240047454834), Airport("Wevelgem Airport", "Belgium", "EBKT", 50.817199707, 3.20472002029), Airport("Midden-Zeeland Airport", "Netherlands", "EHMZ", 51.5121994019, 3.73111009598), Airport("Lydd Airport", "United Kingdom", "EGMD", 50.95610046386719, 0.9391670227050781), Airport("RAF Wattisham", "United Kingdom", "EGUW", 52.1273002625, 0.956264019012), Airport("Beccles Airport", "United Kingdom", "EGSM", 52.435298919699996, 1.6183300018300002), Airport("Lille/Marcq-en-Baroeul Airport", "France", "LFQO", 50.687198638916016, 3.0755600929260254), Airport("Lashenden (Headcorn) Airfield", "United Kingdom", "EGKH", 51.156898, 0.641667), Airport("Le Touquet-C\u00f4te d'Opale Airport", "France", "LFAT", 50.517398834228516, 1.6205899715423584), Airport("Rochester Airport", "United Kingdom", "EGTO", 51.351898193359375, 0.5033329725265503), Airport("Lille-Lesquin Airport", "France", "LFQQ", 50.563332, 3.086886), Airport("Thurrock Airfield", "United Kingdom", "EGMT", 51.537505, 0.367634))

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
