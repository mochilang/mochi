// Generated by Mochi v0.10.42 on 2025-07-28 10:35:17 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
object Main {
  def addEdge(u: String, v: String, w: BigInt): Any = {
    if ((!(graph.contains(u)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
      graph.update(u, scala.collection.mutable.Map())
    }
    graph.getOrElse(u, scala.collection.mutable.Map[String,BigInt]()).update(v, w)
    if ((!(graph.contains(v)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
      graph.update(v, scala.collection.mutable.Map())
    }
  }
  
  def removeAt(xs: ArrayBuffer[String], idx: BigInt): ArrayBuffer[String] = {
    var out: ArrayBuffer[String] = ArrayBuffer()
    var i: BigInt = BigInt(0)
    for (x <- xs) {
      if (i != idx) {
        out = out :+ x
      }
      i = (i + BigInt(1)).asInstanceOf[BigInt]
    }
    return out
  }
  
  def dijkstra(source: String): scala.collection.mutable.Map[String,Any] = {
    var dist: scala.collection.mutable.Map[String,BigInt] = scala.collection.mutable.Map()
    var prev: scala.collection.mutable.Map[String,String] = scala.collection.mutable.Map()
    for (v <- graph.keys) {
      dist.update(v, INF)
      prev.update(v, "")
    }
    dist.update(source, BigInt(0))
    var q: ArrayBuffer[String] = ArrayBuffer()
    for (v <- graph.keys) {
      q = q :+ v.toString
    }
    while ((q).size > BigInt(0)) {
      var bestIdx: BigInt = BigInt(0)
      var u: String = q((BigInt(0)).toInt)
      var i: BigInt = BigInt(1)
      while (i < (q).size) {
        val v: String = q((i).toInt)
        if (dist.getOrElse(v, BigInt(0)) < dist.getOrElse(u, BigInt(0))) {
          u = v
          bestIdx = i
        }
        i = (i + BigInt(1)).asInstanceOf[BigInt]
      }
      q = removeAt(q, bestIdx)
      for (v <- graph.getOrElse(u, scala.collection.mutable.Map[String,BigInt]())) {
        val alt: Int = dist.getOrElse(u, BigInt(0)) + graph.getOrElse(u, scala.collection.mutable.Map[String,BigInt]()).getOrElse(v, BigInt(0))
        if (alt < dist.getOrElse(v, BigInt(0))) {
          dist.update(v, alt)
          prev.update(v, u)
        }
      }
    }
    return (scala.collection.mutable.Map("dist" -> (dist), "prev" -> (prev))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
  }
  
  def path(prev: scala.collection.mutable.Map[String,String], v: String): String = {
    var s: String = v
    var cur: String = v
    while (prev.getOrElse(cur, null.asInstanceOf[String]) != "") {
      cur = prev.getOrElse(cur, null.asInstanceOf[String])
      s = (cur + s).toString
    }
    return s
  }
  
  def main(): Any = {
    addEdge("a", "b", BigInt(7))
    addEdge("a", "c", BigInt(9))
    addEdge("a", "f", BigInt(14))
    addEdge("b", "c", BigInt(10))
    addEdge("b", "d", BigInt(15))
    addEdge("c", "d", BigInt(11))
    addEdge("c", "f", BigInt(2))
    addEdge("d", "e", BigInt(6))
    addEdge("e", "f", BigInt(9))
    val res: scala.collection.mutable.Map[String,Any] = dijkstra("a")
    val dist: scala.collection.mutable.Map[String,BigInt] = (res.getOrElse("dist", null.asInstanceOf[Any])).asInstanceOf[scala.collection.mutable.Map[String,BigInt]]
    val prev: scala.collection.mutable.Map[String,String] = (res.getOrElse("prev", null.asInstanceOf[Any])).asInstanceOf[scala.collection.mutable.Map[String,String]]
    println("Distance to e: " + String.valueOf(dist.getOrElse("e", BigInt(0))) + ", Path: " + path(prev, "e"))
    println("Distance to f: " + String.valueOf(dist.getOrElse("f", BigInt(0))) + ", Path: " + path(prev, "f"))
  }
  
  val INF: BigInt = BigInt(1000000000)
  
  var graph: scala.collection.mutable.Map[String,scala.collection.mutable.Map[String,BigInt]] = scala.collection.mutable.Map()
  
  def main(args: Array[String]): Unit = {
    main()
  }
}
