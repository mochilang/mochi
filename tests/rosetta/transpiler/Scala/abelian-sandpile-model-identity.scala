// Generated by Mochi v0.10.40 on 2025-07-25 13:05:32 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    def neighborsList(): ArrayBuffer[ArrayBuffer[Int]] = {
      return ArrayBuffer(ArrayBuffer(1, 3), ArrayBuffer(0, 2, 4), ArrayBuffer(1, 5), ArrayBuffer(0, 4, 6), ArrayBuffer(1, 3, 5, 7), ArrayBuffer(2, 4, 8), ArrayBuffer(3, 7), ArrayBuffer(4, 6, 8), ArrayBuffer(5, 7))
    }
    def plus(a: ArrayBuffer[Int], b: ArrayBuffer[Int]): ArrayBuffer[Int] = {
      var res: ArrayBuffer[Int] = ArrayBuffer()
      var i: Int = 0
      while (i < (a).size) {
        res = res :+ a(i) + b(i)
        i = (i + 1).asInstanceOf[Int]
      }
      return res
    }
    def isStable(p: ArrayBuffer[Int]): Boolean = {
      for (v <- p) {
        if (v.asInstanceOf[Int] > 3) {
          return false
        }
      }
      return true
    }
    def topple(p: ArrayBuffer[Int]): Int = {
      val neighbors: ArrayBuffer[ArrayBuffer[Int]] = neighborsList()
      var i: Int = 0
      while (i < (p).size) {
        if (p(i) > 3) {
          p(i) = p(i) - 4
          val nbs: ArrayBuffer[Int] = neighbors(i)
          for (j <- nbs) {
            p(j) = p(j) + 1
          }
          return 0
        }
        i = (i + 1).asInstanceOf[Int]
      }
      return 0
    }
    def pileString(p: ArrayBuffer[Int]): String = {
      var s: String = ""
      var r: Int = 0
      while (r < 3) {
        var c: Int = 0
        while (c < 3) {
          s = s + String.valueOf(p(3 * r + c)) + " "
          c = (c + 1).asInstanceOf[Int]
        }
        s = s + "\n"
        r = (r + 1).asInstanceOf[Int]
      }
      return s
    }
    println("Avalanche of topplings:\n")
    var s4: ArrayBuffer[Int] = ArrayBuffer(4, 3, 3, 3, 1, 2, 0, 2, 3)
    println(pileString(s4))
    while (!isStable(s4)) {
      topple(s4)
      println(pileString(s4))
    }
    println("Commutative additions:\n")
    var s1: ArrayBuffer[Int] = ArrayBuffer(1, 2, 0, 2, 1, 1, 0, 1, 3)
    var s2: ArrayBuffer[Int] = ArrayBuffer(2, 1, 3, 1, 0, 1, 0, 1, 0)
    var s3_a: ArrayBuffer[Int] = plus(s1, s2)
    while (!isStable(s3_a)) {
      topple(s3_a)
    }
    var s3_b: ArrayBuffer[Int] = plus(s2, s1)
    while (!isStable(s3_b)) {
      topple(s3_b)
    }
    println(pileString(s1) + "\nplus\n\n" + pileString(s2) + "\nequals\n\n" + pileString(s3_a))
    println("and\n\n" + pileString(s2) + "\nplus\n\n" + pileString(s1) + "\nalso equals\n\n" + pileString(s3_b))
    println("Addition of identity sandpile:\n")
    var s3: ArrayBuffer[Int] = ArrayBuffer(3, 3, 3, 3, 3, 3, 3, 3, 3)
    var s3_id: ArrayBuffer[Int] = ArrayBuffer(2, 1, 2, 1, 0, 1, 2, 1, 2)
    var s4b: ArrayBuffer[Int] = plus(s3, s3_id)
    while (!isStable(s4b)) {
      topple(s4b)
    }
    println(pileString(s3) + "\nplus\n\n" + pileString(s3_id) + "\nequals\n\n" + pileString(s4b))
    println("Addition of identities:\n")
    var s5: ArrayBuffer[Int] = plus(s3_id, s3_id)
    while (!isStable(s5)) {
      topple(s5)
    }
    println(pileString(s3_id) + "\nplus\n\n" + pileString(s3_id) + "\nequals\n\n" + pileString(s5))
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
