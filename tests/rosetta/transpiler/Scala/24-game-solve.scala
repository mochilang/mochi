// Generated by Mochi v0.10.39 on 2025-07-25 09:30:22 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs(System.nanoTime().toInt)
  }
}

case class Rational(var num: Int, var denom: Int)

sealed trait Expr
case class Num(var value: Rational) extends Expr
case class Bin(var op: Int, var left: Expr, var right: Expr) extends Expr


def binEval(op: Int, l: Expr, r: Expr): Rational = {
  val lv: Rational = exprEval(l)
  val rv: Rational = exprEval(r)
  if (op == OP_ADD) {
    return Rational(lv.num * rv.denom + lv.denom * rv.num, lv.denom * rv.denom)
  }
  if (op == OP_SUB) {
    return Rational(lv.num * rv.denom - lv.denom * rv.num, lv.denom * rv.denom)
  }
  if (op == OP_MUL) {
    return Rational(lv.num * rv.num, lv.denom * rv.denom)
  }
  return Rational(lv.num * rv.denom, lv.denom * rv.num)
}

def binString(op: Int, l: Expr, r: Expr): String = {
  val ls: String = exprString(l)
  val rs: String = exprString(r)
  var opstr: String = ""
  if (op == OP_ADD) {
    opstr = " + "
  } else {
    if (op == OP_SUB) {
      opstr = " - "
    } else {
      if (op == OP_MUL) {
        opstr = " * "
      } else {
        opstr = " / "
      }
    }
  }
  return "(" + ls + opstr + rs + ")"
}

def newNum(n: Int): Expr = {
  return (Num(Rational(n, 1))).asInstanceOf[Expr]
}

def exprEval(x: Expr): Rational = {
  return (x match { case Num(v) => v case Bin(op, l, r) => binEval(op.asInstanceOf[Int], l.asInstanceOf[Expr], r.asInstanceOf[Expr]) }).asInstanceOf[Rational]
}

def exprString(x: Expr): String = {
  return (x match { case Num(v) => String.valueOf(v.num) case Bin(op, l, r) => binString(op.asInstanceOf[Int], l.asInstanceOf[Expr], r.asInstanceOf[Expr]) }).asInstanceOf[String]
}

def solve(xs: ArrayBuffer[Expr]): Boolean = {
  if ((xs).size == 1) {
    val f: Rational = exprEval(xs(0))
    if (f.denom != 0 && f.num == f.denom * goal) {
      println(exprString(xs(0)))
      return true
    }
    return false
  }
  var i: Int = 0
  while (i < (xs).size) {
    var j: Int = i + 1
    while (j < (xs).size) {
      var rest: ArrayBuffer[Expr] = ArrayBuffer()
      var k: Int = 0
      while (k < (xs).size) {
        if (k != i && k != j) {
          rest = rest :+ xs(k)
        }
        k = k + 1
      }
      val a: Expr = xs(i)
      val b: Expr = xs(j)
      var node: Bin = Bin(OP_ADD, a, b)
      for (op <- ArrayBuffer(OP_ADD, OP_SUB, OP_MUL, OP_DIV)) {
        node = Bin(op, a, b)
        if (solve((rest :+ node).asInstanceOf[ArrayBuffer[Expr]])) {
          return true
        }
      }
      node = Bin(OP_SUB, b, a)
      if (solve((rest :+ node).asInstanceOf[ArrayBuffer[Expr]])) {
        return true
      }
      node = Bin(OP_DIV, b, a)
      if (solve((rest :+ node).asInstanceOf[ArrayBuffer[Expr]])) {
        return true
      }
      j = j + 1
    }
    i = i + 1
  }
  return false
}

def main(): Unit = {
  var iter: Int = 0
  while (iter < 10) {
    var cards: ArrayBuffer[Expr] = ArrayBuffer()
    var i: Int = 0
    while (i < n_cards) {
      val n = Math.floorMod(_now(), digit_range - 1) + 1
      cards = cards :+ newNum(n)
      println(" " + String.valueOf(n))
      i = i + 1
    }
    println(":  ")
    if ((!solve(cards)).asInstanceOf[Boolean]) {
      println("No solution")
    }
    iter = iter + 1
  }
}

val OP_ADD: Int = 1

val OP_SUB: Int = 2

val OP_MUL: Int = 3

val OP_DIV: Int = 4

val n_cards: Int = 4

val goal: Int = 24

val digit_range: Int = 9

def main(args: Array[String]): Unit = {
  main()
}
}
