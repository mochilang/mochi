// Generated by Mochi v0.10.37 on 2025-07-22 20:23:03 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  def newNum(n: Int): Map[String,any] = {
    return Map("op" -> OP_NUM, "value" -> Map("num" -> n, "denom" -> 1))
  }
  
  def exprEval(x: Map[String,any]): Map[String,Int] = {
    if (x("op") == OP_NUM) {
      return x("value")
    }
    val l = exprEval(x("left"))
    val r = exprEval(x("right"))
    if (x("op") == OP_ADD) {
      return Map("num" -> l("num") * r("denom") + l("denom") * r("num"), "denom" -> l("denom") * r("denom"))
    }
    if (x("op") == OP_SUB) {
      return Map("num" -> l("num") * r("denom") - l("denom") * r("num"), "denom" -> l("denom") * r("denom"))
    }
    if (x("op") == OP_MUL) {
      return Map("num" -> l("num") * r("num"), "denom" -> l("denom") * r("denom"))
    }
    return Map("num" -> l("num") * r("denom"), "denom" -> l("denom") * r("num"))
  }
  
  def exprString(x: Map[String,any]): String = {
    if (x("op") == OP_NUM) {
      return String.valueOf(x("value")("num"))
    }
    val ls = exprString(x("left"))
    val rs = exprString(x("right"))
    var opstr: String = ""
    if (x("op") == OP_ADD) {
      opstr = " + "
    } else {
      if (x("op") == OP_SUB) {
        opstr = " - "
      } else {
        if (x("op") == OP_MUL) {
          opstr = " * "
        } else {
          opstr = " / "
        }
      }
    }
    return "(" + ls + opstr + rs + ")"
  }
  
  def solve(xs: ArrayBuffer[Map[String,any]]): Boolean = {
    if ((xs).size == 1) {
      val f = exprEval(xs(0))
      if (f("denom") != 0 && f("num") == f("denom") * goal) {
        println(exprString(xs(0)))
        return true
      }
      return false
    }
    var i: Int = 0
    while (i < (xs).size) {
      var j = i + 1
      while (j < (xs).size) {
        var rest: ArrayBuffer[Map[String,any]] = ArrayBuffer()
        var k: Int = 0
        while (k < (xs).size) {
          if (k != i && k != j) {
            rest = rest :+ xs(k)
          }
          k = k + 1
        }
        val a: Any = xs(i)
        val b: Any = xs(j)
        for (op <- ArrayBuffer(OP_ADD, OP_SUB, OP_MUL, OP_DIV)) {
          var node: Map[String,Any] = Map("op" -> op, "left" -> a, "right" -> b)
          if (solve(rest :+ node)) {
            return true
          }
        }
        var node: Map[String,Any] = Map("op" -> OP_SUB, "left" -> b, "right" -> a)
        if (solve(rest :+ node)) {
          return true
        }
        node = Map("op" -> OP_DIV, "left" -> b, "right" -> a)
        if (solve(rest :+ node)) {
          return true
        }
        j = j + 1
      }
      i = i + 1
    }
    return false
  }
  
  def main() = {
    var iter: Int = 0
    while (iter < 10) {
      var cards: ArrayBuffer[Map[String,any]] = ArrayBuffer()
      var i: Int = 0
      while (i < n_cards) {
        val n = now() % digit_range - 1 + 1
        cards = cards :+ newNum(n)
        println(" " + String.valueOf(n))
        i = i + 1
      }
      println(":  ")
      if (!solve(cards)) {
        println("No solution")
      }
      iter = iter + 1
    }
  }
  
  val OP_NUM: Int = 0
  
  val OP_ADD: Int = 1
  
  val OP_SUB: Int = 2
  
  val OP_MUL: Int = 3
  
  val OP_DIV: Int = 4
  
  def main(args: Array[String]): Unit = {
    val n_cards: Int = 4
    val goal: Int = 24
    val digit_range: Int = 9
    main()
  }
}
