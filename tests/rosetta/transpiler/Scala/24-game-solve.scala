// Generated by Mochi v0.10.37 on 2025-07-23 13:07:01 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs(System.nanoTime().toInt)
  }
}

def newNum(n: Int): Map[String,Any] = {
  return Map("op" -> (OP_NUM), "value" -> (Map("num" -> (n), "denom" -> (1))))
}

def exprEval(x: Map[String,Any]): Map[String,Int] = {
  if (x("op") == OP_NUM) {
    return (x("value")).asInstanceOf[Map[String,Int]]
  }
  val l = exprEval(x("left").asInstanceOf[Map[String,Any]])
  val r = exprEval(x("right").asInstanceOf[Map[String,Any]])
  if (x("op") == OP_ADD) {
    return Map("num" -> (l("num").asInstanceOf[Int] * r("denom").asInstanceOf[Int] + l("denom").asInstanceOf[Int] * r("num").asInstanceOf[Int]), "denom" -> (l("denom").asInstanceOf[Int] * r("denom").asInstanceOf[Int]))
  }
  if (x("op") == OP_SUB) {
    return Map("num" -> (l("num").asInstanceOf[Int] * r("denom").asInstanceOf[Int] - l("denom").asInstanceOf[Int] * r("num").asInstanceOf[Int]), "denom" -> (l("denom").asInstanceOf[Int] * r("denom").asInstanceOf[Int]))
  }
  if (x("op") == OP_MUL) {
    return Map("num" -> (l("num").asInstanceOf[Int] * r("num").asInstanceOf[Int]), "denom" -> (l("denom").asInstanceOf[Int] * r("denom").asInstanceOf[Int]))
  }
  return Map("num" -> (l("num").asInstanceOf[Int] * r("denom").asInstanceOf[Int]), "denom" -> (l("denom").asInstanceOf[Int] * r("num").asInstanceOf[Int]))
}

def exprString(x: Map[String,Any]): String = {
  if (x("op") == OP_NUM) {
    return (String.valueOf(x("value").asInstanceOf[Map[String,Any]]("num"))).asInstanceOf[String]
  }
  val ls = exprString(x("left").asInstanceOf[Map[String,Any]])
  val rs = exprString(x("right").asInstanceOf[Map[String,Any]])
  var opstr: String = ""
  if (x("op") == OP_ADD) {
    opstr = " + "
  } else {
    if (x("op") == OP_SUB) {
      opstr = " - "
    } else {
      if (x("op") == OP_MUL) {
        opstr = " * "
      } else {
        opstr = " / "
      }
    }
  }
  return ("(" + ls + opstr + rs + ")").asInstanceOf[String]
}

def solve(xs: ArrayBuffer[Map[String,Any]]): Boolean = {
  if ((xs).size == 1) {
    val f = exprEval(xs(0))
    if ((f("denom").asInstanceOf[Int] != 0 && f("num").asInstanceOf[Int] == f("denom").asInstanceOf[Int] * goal).asInstanceOf[Boolean]) {
      println(exprString(xs(0)))
      return true
    }
    return false
  }
  var i: Int = 0
  while (i < (xs).size) {
    var j = i + 1
    while (j < (xs).size) {
      var rest: ArrayBuffer[Map[String,Any]] = ArrayBuffer()
      var k: Int = 0
      while (k < (xs).size) {
        if ((k != i && k != j).asInstanceOf[Boolean]) {
          rest = rest :+ xs(k)
        }
        k = (k + 1).asInstanceOf[Int]
      }
      val a: Map[String,Any] = xs(i)
      val b: Map[String,Any] = xs(j)
      for (op <- ArrayBuffer(OP_ADD, OP_SUB, OP_MUL, OP_DIV)) {
        var node: Map[String,Any] = Map("op" -> (op), "left" -> (a), "right" -> (b))
        if ((solve(rest :+ node)).asInstanceOf[Boolean]) {
          return true
        }
      }
      var node: Map[String,Any] = Map("op" -> (OP_SUB), "left" -> (b), "right" -> (a))
      if ((solve(rest :+ node)).asInstanceOf[Boolean]) {
        return true
      }
      node = Map("op" -> (OP_DIV), "left" -> (b), "right" -> (a))
      if ((solve(rest :+ node)).asInstanceOf[Boolean]) {
        return true
      }
      j = (j + 1).asInstanceOf[Int]
    }
    i = (i + 1).asInstanceOf[Int]
  }
  return false
}

def main() = {
  var iter: Int = 0
  while (iter < 10) {
    var cards: ArrayBuffer[Map[String,Any]] = ArrayBuffer()
    var i: Int = 0
    while (i < n_cards) {
      val n = _now() % digit_range - 1 + 1
      cards = cards :+ newNum(n)
      println(" " + String.valueOf(n))
      i = (i + 1).asInstanceOf[Int]
    }
    println(":  ")
    if ((!(solve(cards)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
      println("No solution")
    }
    iter = (iter + 1).asInstanceOf[Int]
  }
}

val OP_NUM: Int = 0

val OP_ADD: Int = 1

val OP_SUB: Int = 2

val OP_MUL: Int = 3

val OP_DIV: Int = 4

val n_cards: Int = 4

val goal: Int = 24

val digit_range: Int = 9

def main(args: Array[String]): Unit = {
  main()
}
}
