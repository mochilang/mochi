// Generated by Mochi v0.10.40 on 2025-07-25 10:50:20 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.collection.immutable.ListMap
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

case class Rational(var num: Int, var denom: Int)

sealed trait Expr
case class Num(var value: Rational) extends Expr
case class Bin(var op: Int, var left: Expr, var right: Expr) extends Expr


def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    val OP_ADD: Int = 1
    val OP_SUB: Int = 2
    val OP_MUL: Int = 3
    val OP_DIV: Int = 4
    def binEval(op: Int, l: Expr, r: Expr): Rational = {
      val lv: Rational = exprEval(l)
      val rv: Rational = exprEval(r)
      if (op == OP_ADD) {
        return Rational((lv.num * rv.denom).asInstanceOf[Int] + (lv.denom * rv.num).asInstanceOf[Int], lv.denom * rv.denom)
      }
      if (op == OP_SUB) {
        return Rational((lv.num * rv.denom).asInstanceOf[Int] - (lv.denom * rv.num).asInstanceOf[Int], lv.denom * rv.denom)
      }
      if (op == OP_MUL) {
        return Rational(lv.num * rv.num, lv.denom * rv.denom)
      }
      return Rational(lv.num * rv.denom, lv.denom * rv.num)
    }
    def binString(op: Int, l: Expr, r: Expr): String = {
      val ls: String = exprString(l)
      val rs: String = exprString(r)
      var opstr: String = ""
      if (op == OP_ADD) {
        opstr = " + "
      } else {
        if (op == OP_SUB) {
          opstr = " - "
        } else {
          if (op == OP_MUL) {
            opstr = " * "
          } else {
            opstr = " / "
          }
        }
      }
      return "(" + ls + opstr + rs + ")"
    }
    def newNum(n: Int): Expr = {
      return (Num(Rational(n, 1))).asInstanceOf[Expr]
    }
    def exprEval(x: Expr): Rational = {
      return (x match { case Num(v) => v case Bin(op, l, r) => binEval(op.asInstanceOf[Int], l.asInstanceOf[Expr], r.asInstanceOf[Expr]) }).asInstanceOf[Rational]
    }
    def exprString(x: Expr): String = {
      return (x match { case Num(v) => String.valueOf(v.num) case Bin(op, l, r) => binString(op.asInstanceOf[Int], l.asInstanceOf[Expr], r.asInstanceOf[Expr]) }).asInstanceOf[String]
    }
    val n_cards: Int = 4
    val goal: Int = 24
    val digit_range: Int = 9
    def solve(xs: ArrayBuffer[Expr]): Boolean = {
      if ((xs).size == 1) {
        val f: Rational = exprEval(xs(0))
        if ((f.denom != 0 && f.num == f.denom * goal).asInstanceOf[Boolean]) {
          println(exprString(xs(0)))
          return true
        }
        return false
      }
      var i: Int = 0
      while (i < (xs).size) {
        var j = i + 1
        while (j < (xs).size) {
          var rest: ArrayBuffer[Expr] = ArrayBuffer()
          var k: Int = 0
          while (k < (xs).size) {
            if ((k != i && k != j).asInstanceOf[Boolean]) {
              rest = rest :+ xs(k)
            }
            k = (k + 1).asInstanceOf[Int]
          }
          val a: Expr = xs(i)
          val b: Expr = xs(j)
          var node: Bin = Bin(OP_ADD, a, b)
          for (op <- ArrayBuffer(OP_ADD, OP_SUB, OP_MUL, OP_DIV)) {
            node = Bin(op, a, b)
            if (solve((rest :+ node).asInstanceOf[ArrayBuffer[Expr]])) {
              return true
            }
          }
          node = Bin(OP_SUB, b, a)
          if (solve((rest :+ node).asInstanceOf[ArrayBuffer[Expr]])) {
            return true
          }
          node = Bin(OP_DIV, b, a)
          if (solve((rest :+ node).asInstanceOf[ArrayBuffer[Expr]])) {
            return true
          }
          j = (j + 1).asInstanceOf[Int]
        }
        i = (i + 1).asInstanceOf[Int]
      }
      return false
    }
    def main(): Unit = {
      var iter: Int = 0
      while (iter < 10) {
        var cards: ArrayBuffer[Expr] = ArrayBuffer()
        var i: Int = 0
        while (i < n_cards) {
          val n = _now() % (digit_range - 1) + 1
          cards = cards :+ newNum(n)
          println(" " + String.valueOf(n))
          i = (i + 1).asInstanceOf[Int]
        }
        println(":  ")
        if ((!solve(cards)).asInstanceOf[Boolean]) {
          println("No solution")
        }
        iter = (iter + 1).asInstanceOf[Int]
      }
    }
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
