// Generated by Mochi v0.10.52 on 2025-08-02 02:06:04 GMT+7
import scala.collection.mutable.{ArrayBuffer, Map}
import scala.math.BigInt
import scala.collection.immutable.ListMap
import scala.util.control.Breaks
import scala.util.control.Breaks._
object Main {
  private var _nowSeed: Long = 0L
  private var _nowSeeded: Boolean = false
  private def _now(): Int = {
    if (!_nowSeeded) {
      sys.env.get("MOCHI_NOW_SEED").foreach { s =>
      try { _nowSeed = s.toInt; _nowSeeded = true } catch { case _ : NumberFormatException => () }
    }
  }
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
    _nowSeed.toInt
  } else {
    Math.abs((System.nanoTime() / 1000).toInt)
  }
}

def toJson(value: Any, indent: Int = 0): String = value match {
  case m: scala.collection.Map[_, _] =>
  val items = ListMap(m.toSeq.sortBy(_._1.toString): _*).toSeq.map{ case (k,v) => "  "*(indent+1)+"\""+k.toString+"\": "+toJson(v, indent+1) }
  "{\n"+items.mkString(",\n")+"\n"+"  "*indent+"}"
  case s: Seq[_] =>
  val items = s.map(x => "  "*(indent+1)+toJson(x, indent+1))
  "[\n"+items.mkString(",\n")+"\n"+"  "*indent+"]"
  case s: String => "\""+s+"\""
  case other => other.toString
}

private def _parseIntStr(s: String, base: BigInt): BigInt = BigInt(s, base.toInt)

case class Instruction(var Label: String, var Opcode: String, var Arg: String)

def trim(s: String): String = {
  var start: BigInt = BigInt(0)
  while (start < (s).size && (s.slice((start).toInt, (start + BigInt(1)).toInt) == " " || s.slice((start).toInt, (start + BigInt(1)).toInt) == "\t").asInstanceOf[Boolean]) {
    start = start + BigInt(1)
  }
  var end: Int = (s).size
  while (end > start && (s.slice((end - BigInt(1).toInt).toInt, (end).toInt) == " " || s.slice((end - BigInt(1).toInt).toInt, (end).toInt) == "\t").asInstanceOf[Boolean]) {
    end = end - BigInt(1).toInt.toInt
  }
  return s.slice((start).toInt, (end).toInt)
}

def split(s: String, sep: String): ArrayBuffer[String] = {
  var parts: ArrayBuffer[String] = ArrayBuffer()
  var cur: String = ""
  var i: BigInt = BigInt(0)
  while (i < (s).size) {
    if ((((sep).size > BigInt(0) && i + (sep).size <= (s).size).asInstanceOf[Boolean] && s.slice((i).toInt, (i + (sep).size).toInt) == sep).asInstanceOf[Boolean]) {
      parts = parts :+ cur
      cur = ""
      i = i + (sep).size
    } else {
      cur = cur + s.slice((i).toInt, (i + BigInt(1)).toInt)
      i = i + BigInt(1)
    }
  }
  parts = parts :+ cur
  return parts
}

def splitWS(s: String): ArrayBuffer[String] = {
  var out: ArrayBuffer[String] = ArrayBuffer()
  var cur: String = ""
  var i: BigInt = BigInt(0)
  while (i < (s).size) {
    val ch: String = s.slice((i).toInt, (i + BigInt(1)).toInt)
    if ((ch == " " || ch == "\t").asInstanceOf[Boolean]) {
      if ((cur).size > BigInt(0)) {
        out = out :+ cur
        cur = ""
      }
    } else {
      cur = (cur + ch).toString
    }
    i = i + BigInt(1)
  }
  if ((cur).size > BigInt(0)) {
    out = out :+ cur
  }
  return out
}

def indexOf(s: String, ch: String): BigInt = {
  var i: BigInt = BigInt(0)
  while (i < (s).size) {
    if (s.slice((i).toInt, (i + BigInt(1)).toInt) == ch) {
      return i
    }
    i = i + BigInt(1)
  }
  return BigInt(0) - BigInt(1)
}

def parseIntStr(str: String): BigInt = {
  var i: BigInt = BigInt(0)
  var neg: Boolean = false
  if (((str).size > BigInt(0) && str.slice((BigInt(0)).toInt, (BigInt(1)).toInt) == "-").asInstanceOf[Boolean]) {
    neg = true
    i = BigInt(1)
  }
  var n: BigInt = BigInt(0)
  val digits: Map[String,BigInt] = scala.collection.mutable.Map("0" -> (BigInt(0)), "1" -> (BigInt(1)), "2" -> (BigInt(2)), "3" -> (BigInt(3)), "4" -> (BigInt(4)), "5" -> (BigInt(5)), "6" -> (BigInt(6)), "7" -> (BigInt(7)), "8" -> (BigInt(8)), "9" -> (BigInt(9)))
  while (i < (str).size) {
    n = n * BigInt(10) + digits(str.slice((i).toInt, (i + BigInt(1)).toInt))
    i = i + BigInt(1)
  }
  if (neg) {
    n = BigInt(0) - n
  }
  return n
}

def parseAsm(asm: String): scala.collection.mutable.Map[String,Any] = {
  val lines = ArrayBuffer(asm.split("\n"): _*)
  var instrs: ArrayBuffer[Instruction] = ArrayBuffer()
  var labels: scala.collection.mutable.Map[String,BigInt] = scala.collection.mutable.Map()
  var lineNum: BigInt = BigInt(0)
  var i: BigInt = BigInt(0)
  while (i < (lines).size) {
    var line: String = lines((i).toInt)
    if (BigInt(line.indexOf(";")) != BigInt(0) - BigInt(1)) {
      line = line.slice((BigInt(0)).toInt, (BigInt(line.indexOf(";"))).toInt)
    }
    line = trim(line)
    var label: String = ""
    if (BigInt(line.indexOf(":")) != BigInt(0) - BigInt(1)) {
      val idx = BigInt(line.indexOf(":"))
      label = trim(line.slice((BigInt(0)).toInt, (idx).toInt))
      line = trim(line.slice((idx + BigInt(1)).toInt, ((line).size).toInt))
    }
    var opcode: String = ""
    var arg: String = ""
    if ((line).size > BigInt(0)) {
      var parts: ArrayBuffer[String] = splitWS(line)
      if ((parts).size > BigInt(0)) {
        opcode = parts((BigInt(0)).toInt)
      }
      if ((parts).size > BigInt(1)) {
        arg = parts((BigInt(1)).toInt)
      } else {
        val ops: Map[String,BigInt] = scala.collection.mutable.Map("NOP" -> (BigInt(0)), "LDA" -> (BigInt(1)), "STA" -> (BigInt(2)), "ADD" -> (BigInt(3)), "SUB" -> (BigInt(4)), "BRZ" -> (BigInt(5)), "JMP" -> (BigInt(6)), "STP" -> (BigInt(7)))
        if ((!(ops.contains(opcode)).asInstanceOf[Boolean]).asInstanceOf[Boolean]) {
          arg = opcode
          opcode = ""
        }
      }
    }
    if (label != "") {
      labels.update(label, lineNum)
    }
    instrs = instrs :+ Instruction(label, opcode, arg)
    lineNum = lineNum + BigInt(1)
    i = i + BigInt(1)
  }
  return (scala.collection.mutable.Map("instructions" -> (instrs), "labels" -> (labels))).asInstanceOf[scala.collection.mutable.Map[String,Any]]
}

def compile(p: scala.collection.mutable.Map[String,Any]): ArrayBuffer[BigInt] = {
  var instrs: ArrayBuffer[Instruction] = (p("instructions")).asInstanceOf[ArrayBuffer[Instruction]]
  var labels: scala.collection.mutable.Map[String,BigInt] = (p("labels")).asInstanceOf[scala.collection.mutable.Map[String,BigInt]]
  var bytecode: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = BigInt(0)
  val opcodes: Map[String,BigInt] = scala.collection.mutable.Map("NOP" -> (BigInt(0)), "LDA" -> (BigInt(1)), "STA" -> (BigInt(2)), "ADD" -> (BigInt(3)), "SUB" -> (BigInt(4)), "BRZ" -> (BigInt(5)), "JMP" -> (BigInt(6)), "STP" -> (BigInt(7)))
  while (i < (instrs).size) {
    val ins: Instruction = instrs((i).toInt)
    var arg: BigInt = BigInt(0)
    if (ins.Arg != "") {
      if ((labels.contains(ins.Arg)).asInstanceOf[Boolean]) {
        arg = labels(ins.Arg)
      } else {
        arg = BigInt((_parseIntStr(ins.Arg, BigInt(10))).toInt)
      }
    }
    var code: BigInt = BigInt(0)
    if (ins.Opcode != "") {
      code = opcodes(ins.Opcode)
    }
    bytecode = bytecode :+ code * BigInt(32) + arg
    i = i + BigInt(1)
  }
  while ((bytecode).size < BigInt(32)) {
    bytecode = bytecode :+ BigInt(0)
  }
  return bytecode
}

def floorMod(a: BigInt, b: BigInt): BigInt = {
  var r: BigInt = a % b
  if (r < BigInt(0)) {
    r = r + b
  }
  return r
}

def run(bytecode: ArrayBuffer[BigInt]): BigInt = {
  var acc: BigInt = BigInt(0)
  var pc: BigInt = BigInt(0)
  var mem: ArrayBuffer[BigInt] = ArrayBuffer()
  var i: BigInt = BigInt(0)
  while (i < (bytecode).size) {
    mem = mem :+ bytecode((i).toInt)
    i = i + BigInt(1)
  }
  val _br10 = new Breaks
  val _ct10 = new Breaks
  _br10.breakable {
    while (pc < BigInt(32)) {
      _ct10.breakable {
        val op: BigInt = mem((pc).toInt) / BigInt(32)
        var arg: BigInt = mem((pc).toInt) % BigInt(32)
        pc = pc + BigInt(1)
        if (op == BigInt(0)) {
          _ct10.break()
        } else {
          if (op == BigInt(1)) {
            acc = mem((arg).toInt)
          } else {
            if (op == BigInt(2)) {
              mem((arg).toInt) = acc
            } else {
              if (op == BigInt(3)) {
                acc = floorMod(acc + mem((arg).toInt), BigInt(256))
              } else {
                if (op == BigInt(4)) {
                  acc = floorMod(acc - mem((arg).toInt), BigInt(256))
                } else {
                  if (op == BigInt(5)) {
                    if (acc == BigInt(0)) {
                      pc = arg
                    }
                  } else {
                    if (op == BigInt(6)) {
                      pc = arg
                    } else {
                      if (op == BigInt(7)) {
                        _br10.break()
                      } else {
                        _br10.break()
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return acc
}

def execute(asm: String): BigInt = {
  val parsed: scala.collection.mutable.Map[String,Any] = parseAsm(asm)
  val bc: ArrayBuffer[BigInt] = compile(parsed)
  return run(bc)
}

def main(): Any = {
  val examples: ArrayBuffer[String] = ArrayBuffer("LDA   x\n" + "ADD   y       ; accumulator = x + y\n" + "STP\n" + "x:            2\n" + "y:            2", "loop:   LDA   prodt\n" + "        ADD   x\n" + "        STA   prodt\n" + "        LDA   y\n" + "        SUB   one\n" + "        STA   y\n" + "        BRZ   done\n" + "        JMP   loop\n" + "done:   LDA   prodt   ; to display it\n" + "        STP\n" + "x:            8\n" + "y:            7\n" + "prodt:        0\n" + "one:          1", "loop:   LDA   n\n" + "        STA   temp\n" + "        ADD   m\n" + "        STA   n\n" + "        LDA   temp\n" + "        STA   m\n" + "        LDA   count\n" + "        SUB   one\n" + "        BRZ   done\n" + "        STA   count\n" + "        JMP   loop\n" + "done:   LDA   n       ; to display it\n" + "        STP\n" + "m:            1\n" + "n:            1\n" + "temp:         0\n" + "count:        8       ; valid range: 1-11\n" + "one:          1", "start:  LDA   load\n" + "ADD   car     ; head of list\n" + "STA   ldcar\n" + "ADD   one\n" + "STA   ldcdr   ; next CONS cell\n" + "ldcar:  NOP\n" + "STA   value\n" + "ldcdr:  NOP\n" + "BRZ   done    ; 0 stands for NIL\n" + "STA   car\n" + "JMP   start\n" + "done:   LDA   value   ; CAR of last CONS\n" + "STP\n" + "load:   LDA   0\n" + "value:        0\n" + "car:          28\n" + "one:          1\n" + "                        ; order of CONS cells\n" + "                        ; in memory\n" + "                        ; does not matter\n" + "        6\n" + "        0       ; 0 stands for NIL\n" + "        2       ; (CADR ls)\n" + "        26      ; (CDDR ls) -- etc.\n" + "        5\n" + "        20\n" + "        3\n" + "        30\n" + "        1       ; value of (CAR ls)\n" + "        22      ; points to (CDR ls)\n" + "        4\n" + "        24", "LDA  3\n" + "SUB  4\n" + "STP  0\n" + "         0\n" + "         255", "LDA  3\n" + "SUB  4\n" + "STP  0\n" + "                0\n" + "                1", "LDA  3\n" + "ADD  4\n" + "STP  0\n" + "                1\n" + "                255")
  var i: BigInt = BigInt(0)
  while (i < (examples).size) {
    val res: BigInt = execute(examples((i).toInt))
    println(String.valueOf(res))
    i = i + BigInt(1)
  }
}

def main(args: Array[String]): Unit = {
  {
    System.gc()
    val _startMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _start = _now()
    main()
    val _end = _now()
    System.gc()
    val _endMem = Runtime.getRuntime.totalMemory() - Runtime.getRuntime.freeMemory()
    val _durUs = (_end - _start) / 1000
    var _memDiff = _endMem - _startMem
    if (_memDiff <= 0) _memDiff = _endMem
    println(toJson(scala.collection.immutable.Map("duration_us" -> _durUs, "memory_bytes" -> _memDiff, "name" -> "main")))
  }
}
}
