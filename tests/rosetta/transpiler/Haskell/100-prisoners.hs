{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
-- Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:18 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
shuffle xs = do
    arr <- newIORef (xs)
    i <- newIORef (99)
    let
        loop = do
            if (deref i) > 0 then do
                j = now `mod` ((deref i) + 1)
                tmp = ((deref arr) !! (deref i))
                writeIORef arr $! (take (deref i) (deref arr) ++ [((deref arr) !! j)] ++ drop ((deref i) + 1) (deref arr))
                writeIORef arr $! (take j (deref arr) ++ [tmp] ++ drop (j + 1) (deref arr))
                writeIORef i $! ((deref i) - 1)
                loop
            else return ()
    loop
    return ((deref arr))


doTrials trials np strategy = do
    pardoned <- newIORef (0)
    t <- newIORef (0)
    let
        loop = do
            if (deref t) < trials then do
                drawers <- newIORef ([])
                i <- newIORef (0)
                let
                    loop = do
                        if (deref i) < 100 then do
                            writeIORef drawers $! ((deref drawers) ++ [(deref i)])
                            writeIORef i $! ((deref i) + 1)
                            loop
                        else return ()
                loop
                writeIORef drawers $! (shuffle (deref drawers))
                p <- newIORef (0)
                success <- newIORef (True)
                let
                    loop = do
                        if (deref p) < np then do
                            found <- newIORef (False)
                            if strategy == "optimal" then do
                                prev <- newIORef ((deref p))
                                d <- newIORef (0)
                                let
                                    loop = do
                                        if (deref d) < 50 then do
                                            this = ((deref drawers) !! (deref prev))
                                            if this == (deref p) then do
                                                writeIORef found $! (True)
                                                return ()
                                            else return ()

                                            writeIORef prev $! (this)
                                            writeIORef d $! ((deref d) + 1)
                                            loop
                                        else return ()
                                loop
                            else do
                                opened <- newIORef ([])
                                k <- newIORef (0)
                                let
                                    loop = do
                                        if (deref k) < 100 then do
                                            writeIORef opened $! ((deref opened) ++ [False])
                                            writeIORef k $! ((deref k) + 1)
                                            loop
                                        else return ()
                                loop
                                d <- newIORef (0)
                                let
                                    loop = do
                                        if (deref d) < 50 then do
                                            n <- newIORef (now `mod` 100)
                                            let
                                                loop = do
                                                    if ((deref opened) !! (deref n)) then do
                                                        writeIORef n $! (now `mod` 100)
                                                        loop
                                                    else return ()
                                            loop
                                            writeIORef opened $! (take (deref n) (deref opened) ++ [True] ++ drop ((deref n) + 1) (deref opened))
                                            if ((deref drawers) !! (deref n)) == (deref p) then do
                                                writeIORef found $! (True)
                                                return ()
                                            else return ()

                                            writeIORef d $! ((deref d) + 1)
                                            loop
                                        else return ()
                                loop

                            if not (deref found) then do
                                writeIORef success $! (False)
                                return ()
                            else return ()

                            writeIORef p $! ((deref p) + 1)
                            loop
                        else return ()
                loop
                if (deref success) then do
                    writeIORef pardoned $! ((deref pardoned) + 1)
                else return ()

                writeIORef t $! ((deref t) + 1)
                loop
            else return ()
    loop
    rf = (fromIntegral (deref pardoned)) / (fromIntegral trials) * 100
    putStrLn ("  strategy = " ++ strategy ++ "  pardoned = " ++ show (deref pardoned) ++ " relative frequency = " ++ show rf ++ "%")


main = do
    trials = 1000
    mapM_ (\np -> do
        putStrLn ("Results from " ++ show trials ++ " trials with " ++ show np ++ " prisoners:\n")
        mapM_ (\strat -> do
            doTrials trials np strat
            ) ["random", "optimal"]
        ) [10, 100]


main :: IO ()
main = do
    main
