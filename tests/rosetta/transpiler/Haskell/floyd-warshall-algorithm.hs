{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
-- Generated by Mochi transpiler v0.10.52 on 2025-08-01 15:22 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
int :: String -> Int
int = read
float :: Int -> Double
float n = fromIntegral n
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
powInt :: Int -> Int -> Int
powInt b e = go 1 b e where
    go r b e | e > 0 = go (if e `mod` 2 == 1 then r*b else r) (b*b) (e `div` 2)
              | otherwise = r
main = do
    let iNF = 1000000000
    let n = 4
    dist <- newIORef ([])
    next <- newIORef ([])
    i <- newIORef (0 :: Int)
    let
        loop = do
            if (deref i) < n then do
                row <- newIORef ([])
                nrow <- newIORef ([])
                j <- newIORef (0 :: Int)
                let
                    loop = do
                        if (deref j) < n then do
                            if (deref i) == (deref j) then do
                                writeIORef row $! ((deref row) ++ [0])
                            else do
                                writeIORef row $! ((deref row) ++ [iNF])

                            writeIORef nrow $! ((deref nrow) ++ [0 - 1])
                            writeIORef j $! ((deref j) + 1)
                            loop
                        else return ()
                loop
                writeIORef dist $! ((deref dist) ++ [(deref row)])
                writeIORef next $! ((deref next) ++ [(deref nrow)])
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    writeIORef dist $! (take 0 (deref dist) ++ [take 2 (((deref dist) !! 0)) ++ [-2] ++ drop (2 + 1) (((deref dist) !! 0))] ++ drop (0 + 1) (deref dist))
    writeIORef next $! (take 0 (deref next) ++ [take 2 (((deref next) !! 0)) ++ [2] ++ drop (2 + 1) (((deref next) !! 0))] ++ drop (0 + 1) (deref next))
    writeIORef dist $! (take 2 (deref dist) ++ [take 3 (((deref dist) !! 2)) ++ [2] ++ drop (3 + 1) (((deref dist) !! 2))] ++ drop (2 + 1) (deref dist))
    writeIORef next $! (take 2 (deref next) ++ [take 3 (((deref next) !! 2)) ++ [3] ++ drop (3 + 1) (((deref next) !! 2))] ++ drop (2 + 1) (deref next))
    writeIORef dist $! (take 3 (deref dist) ++ [take 1 (((deref dist) !! 3)) ++ [-1] ++ drop (1 + 1) (((deref dist) !! 3))] ++ drop (3 + 1) (deref dist))
    writeIORef next $! (take 3 (deref next) ++ [take 1 (((deref next) !! 3)) ++ [1] ++ drop (1 + 1) (((deref next) !! 3))] ++ drop (3 + 1) (deref next))
    writeIORef dist $! (take 1 (deref dist) ++ [take 0 (((deref dist) !! 1)) ++ [4] ++ drop (0 + 1) (((deref dist) !! 1))] ++ drop (1 + 1) (deref dist))
    writeIORef next $! (take 1 (deref next) ++ [take 0 (((deref next) !! 1)) ++ [0] ++ drop (0 + 1) (((deref next) !! 1))] ++ drop (1 + 1) (deref next))
    writeIORef dist $! (take 1 (deref dist) ++ [take 2 (((deref dist) !! 1)) ++ [3] ++ drop (2 + 1) (((deref dist) !! 1))] ++ drop (1 + 1) (deref dist))
    writeIORef next $! (take 1 (deref next) ++ [take 2 (((deref next) !! 1)) ++ [2] ++ drop (2 + 1) (((deref next) !! 1))] ++ drop (1 + 1) (deref next))
    k <- newIORef (0 :: Int)
    let
        loop = do
            if (deref k) < n then do
                i <- newIORef (0 :: Int)
                let
                    loop = do
                        if (deref i) < n then do
                            j <- newIORef (0 :: Int)
                            let
                                loop = do
                                    if (deref j) < n then do
                                        if (((deref dist) !! (deref i)) !! (deref k)) < iNF && (((deref dist) !! (deref k)) !! (deref j)) < iNF then do
                                            let alt = (((deref dist) !! (deref i)) !! (deref k)) + (((deref dist) !! (deref k)) !! (deref j))
                                            if alt < (((deref dist) !! (deref i)) !! (deref j)) then do
                                                writeIORef dist $! (take (deref i) (deref dist) ++ [take (deref j) (((deref dist) !! (deref i))) ++ [alt] ++ drop ((deref j) + 1) (((deref dist) !! (deref i)))] ++ drop ((deref i) + 1) (deref dist))
                                                writeIORef next $! (take (deref i) (deref next) ++ [take (deref j) (((deref next) !! (deref i))) ++ [(((deref next) !! (deref i)) !! (deref k))] ++ drop ((deref j) + 1) (((deref next) !! (deref i)))] ++ drop ((deref i) + 1) (deref next))
                                            else return ()

                                        else return ()

                                        writeIORef j $! ((deref j) + 1)
                                        loop
                                    else return ()
                            loop
                            writeIORef i $! ((deref i) + 1)
                            loop
                        else return ()
                loop
                writeIORef k $! ((deref k) + 1)
                loop
            else return ()
    loop
    let path = \u v -> do
        let ui = u - 1
        let vi = v - 1
        if ((next !! ui) !! vi) == 0 - 1 then do
            return ([])
        else do
            p <- newIORef ([u])
            cur <- newIORef (ui)
            let
                loop = do
                    if (deref cur) /= vi then do
                        writeIORef cur $! (((next !! (deref cur)) !! vi))
                        writeIORef p $! ((deref p) ++ [(deref cur) + 1])
                        loop
                    else return ()
            loop
            return ((deref p))


    let pathStr = \p -> do
        s <- newIORef ("")
        first <- newIORef (True :: Bool)
        idx <- newIORef (0 :: Int)
        let
            loop = do
                if (deref idx) < length p then do
                    let x = (p !! (deref idx))
                    if not (deref first) then do
                        writeIORef s $! ((deref s) ++ " -> ")
                    else return ()

                    writeIORef s $! ((deref s) ++ show x)
                    writeIORef first $! (False)
                    writeIORef idx $! ((deref idx) + 1)
                    loop
                else return ()
        loop
        return ((deref s))

    putStrLn ("pair\tdist\tpath")
    a <- newIORef (0 :: Int)
    let
        loop = do
            if (deref a) < n then do
                b <- newIORef (0 :: Int)
                let
                    loop = do
                        if (deref b) < n then do
                            if (deref a) /= (deref b) then do
                                putStrLn (show ((deref a) + 1) ++ " -> " ++ show ((deref b) + 1) ++ "\t" ++ show ((((deref dist) !! (deref a)) !! (deref b))) ++ "\t" ++ pathStr (path ((deref a) + 1) ((deref b) + 1)))
                            else return ()

                            writeIORef b $! ((deref b) + 1)
                            loop
                        else return ()
                loop
                writeIORef a $! ((deref a) + 1)
                loop
            else return ()
    loop


