{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
-- Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:18 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
data GenType1 = GenType1
  { 0 :: Int,
    1 :: Int,
    2 :: Int,
    3 :: Int,
    4 :: Int,
    5 :: Int,
    6 :: Int,
    7 :: Int,
    8 :: Int,
    9 :: Int
  } deriving (Show, Eq)


parseIntStr str = do
    i <- newIORef (0)
    neg <- newIORef (False)
    if length str > 0 && take (1 - 0) (drop 0 str) == "-" then do
        writeIORef neg $! (True)
        writeIORef i $! (1)
    else return ()

    n <- newIORef (0)
    digits = GenType1 {0 = 0, 1 = 1, 2 = 2, 3 = 3, 4 = 4, 5 = 5, 6 = 6, 7 = 7, 8 = 8, 9 = 9}
    let
        loop = do
            if (deref i) < length str then do
                writeIORef n $! ((deref n) * 10 + (digits !! take ((deref i) + 1 - (deref i)) (drop (deref i) str)))
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    if (deref neg) then do
        writeIORef n $! (-(deref n))
    else return ()

    return ((deref n))


main = do
    total <- newIORef (0)
    computer <- newIORef (now `mod` 2 == 0)
    putStrLn ("Enter q to quit at any time\n")
    if (deref computer) then do
        putStrLn ("The computer will choose first")
    else do
        putStrLn ("You will choose first")

    putStrLn ("\n\nRunning total is now 0\n\n")
    round <- newIORef (1)
    done <- newIORef (False)
    let
        loop = do
            if not (deref done) then do
                putStrLn ("ROUND " ++ show (deref round) ++ ":\n\n")
                i <- newIORef (0)
                let
                    loop = do
                        if (deref i) < 2 && (not (deref done)) then do
                            if (deref computer) then do
                                choice <- newIORef (0)
                                if (deref total) < 18 then do
                                    writeIORef choice $! (now `mod` 3 + 1)
                                else do
                                    writeIORef choice $! (21 - (deref total))

                                writeIORef total $! ((deref total) + (deref choice))
                                putStrLn ("The computer chooses " ++ show (deref choice))
                                putStrLn ("Running total is now " ++ show (deref total))
                                if (deref total) == 21 then do
                                    putStrLn ("\nSo, commiserations, the computer has won!")
                                    writeIORef done $! (True)
                                else return ()

                            else do
                                let
                                    loop = do
                                        if True then do
                                            putStrLn ("Your choice 1 to 3 : ")
                                            line = input
                                            if line == "q" || line == "Q" then do
                                                putStrLn ("OK, quitting the game")
                                                writeIORef done $! (True)
                                                return ()
                                            else return ()

                                            num = parseIntStr line
                                            if num < 1 || num > 3 then do
                                                if (deref total) + num > 21 then do
                                                    putStrLn ("Too big, try again")
                                                else do
                                                    putStrLn ("Out of range, try again")

                                                 xs
                                            else return ()

                                            if (deref total) + num > 21 then do
                                                putStrLn ("Too big, try again")
                                                 xs
                                            else return ()

                                            writeIORef total $! ((deref total) + num)
                                            putStrLn ("Running total is now " ++ show (deref total))
                                            return ()
                                            loop
                                        else return ()
                                loop
                                if (deref total) == 21 then do
                                    putStrLn ("\nSo, congratulations, you've won!")
                                    writeIORef done $! (True)
                                else return ()


                            putStrLn ("\n")
                            writeIORef computer $! (not (deref computer))
                            writeIORef i $! ((deref i) + 1)
                            loop
                        else return ()
                loop
                writeIORef round $! ((deref round) + 1)
                loop
            else return ()
    loop


main :: IO ()
main = do
    main
