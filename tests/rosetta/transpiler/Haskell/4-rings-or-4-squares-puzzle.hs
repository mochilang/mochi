{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (count, list)
-- Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:18 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
data GenType1 = GenType1
  { count :: Int,
    list :: [String]
  } deriving (Show, Eq)


validComb a b c d e f g = do
    square1 = a + b
    square2 = b + c + d
    square3 = d + e + f
    square4 = f + g
    return (square1 == square2 && square2 == square3 && square3 == square4)


isUnique a b c d e f g = do
    nums = [a, b, c, d, e, f, g]
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < length nums then do
                j <- newIORef ((deref i) + 1)
                let
                    loop = do
                        if (deref j) < length nums then do
                            if (nums !! (deref i)) == (nums !! (deref j)) then do
                                return (False)
                            else return ()

                            writeIORef j $! ((deref j) + 1)
                            loop
                        else return ()
                loop
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return (True)


getCombs low high unique = do
    valid <- newIORef ([])
    count <- newIORef (0)
    let
        loop [] = return ()
        loop (b:xs) = do
            let
                loop [] = return ()
                loop (c:xs) = do
                    let
                        loop [] = return ()
                        loop (d:xs) = do
                            s = b + c + d
                            let
                                loop [] = return ()
                                loop (e:xs) = do
                                    let
                                        loop [] = return ()
                                        loop (f:xs) | a < low || a > high = loop xs
                                            | g < low || g > high = loop xs
                                            | d + e + f != s = loop xs
                                            | f + g != s = loop xs
                                            | otherwise = do
                                            a = s - b
                                            g = s - f
                                            if not unique || isUnique a b c d e f g then do
                                                writeIORef valid $! ((deref valid) ++ [[a, b, c, d, e, f, g]])
                                                writeIORef count $! ((deref count) + 1)
                                            else return ()

                                            loop xs
                                    loop [low .. ((high + 1) - 1)]
                                    loop xs
                            loop [low .. ((high + 1) - 1)]
                            loop xs
                    loop [low .. ((high + 1) - 1)]
                    loop xs
            loop [low .. ((high + 1) - 1)]
            loop xs
    loop [low .. ((high + 1) - 1)]
    return (GenType1 {count = (deref count), list = (deref valid)})


r1 = getCombs 1 7 (True)

r2 = getCombs 3 9 (True)

r3 = getCombs 0 9 (False)

main :: IO ()
main = do
    putStrLn (show ((r1 !! "count")) ++ " unique solutions in 1 to 7")
    print ((r1 !! "list"))
    putStrLn (show ((r2 !! "count")) ++ " unique solutions in 3 to 9")
    print ((r2 !! "list"))
    putStrLn (show ((r3 !! "count")) ++ " non-unique solutions in 0 to 9")
