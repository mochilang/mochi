{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (powInt)
-- Generated by Mochi transpiler v0.10.42 on 2025-07-28 11:14 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
int :: String -> Int
int = read
float :: Int -> Double
float n = fromIntegral n
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
powInt :: Int -> Int -> Int
powInt b e = go 1 b e where
    go r b e | e > 0 = go (if e `mod` 2 == 1 then r*b else r) (b*b) (e `div` 2)
              | otherwise = r
minInt x y = if x < y then x else y

throwDie nSides nDice s counts = do
    if nDice == 0 then do
        writeIORef counts $! (take s (deref counts) ++ [((deref counts) !! s) + 1] ++ drop (s + 1) (deref counts))
        return ()
    else do
        i <- newIORef (1 :: Int)
        let
            loop = do
                if (deref i) <= nSides then do
                    throwDie nSides (nDice - 1) (s + (deref i)) counts
                    writeIORef i $! ((deref i) + 1)
                    loop
                else return ()
        loop



beatingProbability nSides1 nDice1 nSides2 nDice2 = do
    let len1 = (nSides1 + 1) * nDice1
    c1 <- newIORef ([])
    i <- newIORef (0 :: Int)
    let
        loop = do
            if (deref i) < len1 then do
                writeIORef c1 $! ((deref c1) ++ [0])
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    throwDie nSides1 nDice1 0 c1
    let len2 = (nSides2 + 1) * nDice2
    c2 <- newIORef ([])
    j <- newIORef (0 :: Int)
    let
        loop = do
            if (deref j) < len2 then do
                writeIORef c2 $! ((deref c2) ++ [0])
                writeIORef j $! ((deref j) + 1)
                loop
            else return ()
    loop
    throwDie nSides2 nDice2 0 c2
    let p12 = (fromIntegral (powInt nSides1 nDice1)) * (fromIntegral (powInt nSides2 nDice2))
    tot <- newIORef (0 :: Double)
    writeIORef i $! (0)
    let
        loop = do
            if (deref i) < len1 then do
                writeIORef j $! (0)
                let m = minInt (deref i) len2
                let
                    loop = do
                        if (deref j) < m then do
                            writeIORef tot $! ((deref tot) + (((deref c1) !! (deref i)) * fromIntegral (((deref c2) !! (deref j)))) / p12)
                            writeIORef j $! ((deref j) + 1)
                            loop
                        else return ()
                loop
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return ((deref tot))


main :: IO ()
main = do
    putStrLn (show (unsafePerformIO (beatingProbability 4 9 6 6)))
    putStrLn (show (unsafePerformIO (beatingProbability 10 5 7 6)))
