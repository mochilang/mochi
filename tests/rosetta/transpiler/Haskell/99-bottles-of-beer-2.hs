{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
-- Generated by Mochi transpiler v0.10.39 on 2025-07-24 18:53 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
int :: String -> Int
int = read
float :: Int -> Double
float n = fromIntegral n
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
fields s = do
    words <- newIORef ([])
    cur <- newIORef ("")
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < length s then do
                let ch = take ((deref i) + 1 - (deref i)) (drop (deref i) s)
                if ch == " " || ch == "\n" || ch == "\t" then do
                    if length (deref cur) > 0 then do
                        writeIORef words $! ((deref words) ++ [(deref cur)])
                        writeIORef cur $! ("")
                    else return ()

                else do
                    writeIORef cur $! ((deref cur) ++ ch)

                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    if length (deref cur) > 0 then do
        writeIORef words $! ((deref words) ++ [(deref cur)])
    else return ()

    return ((deref words))


join xs sep = do
    res <- newIORef ("")
    i <- newIORef (0)
    (let {
        loop = do
            if (deref i) < length xs then do
                if (deref i) > 0 then do
                    writeIORef res $! ((deref res) ++ sep)
                else return ()

                writeIORef res $! ((deref res) ++ (xs !! (deref i)))
                writeIORef i $! ((deref i) + 1)
                loop
            else return ((deref res))
    } in loop)


numberName n = do
    let small = ["no", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"]
    let tens = ["ones", "ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"]
    if n < 0 then do
        return ("")
    else do
        if n < 20 then do
            return ((small !! n))
        else do
            if n < 100 then do
                t <- newIORef ((tens !! round ((n / fromIntegral 10))))
                let s = n `mod` 10
                if s > 0 then do
                    writeIORef t $! ((deref t) ++ " " ++ (small !! s))
                else return ()

                return ((deref t))
            else do
                return ("")





pluralizeFirst s n = do
    if n == 1 then do
        return (s)
    else do
        w <- newIORef (unsafePerformIO (fields s))
        if length (deref w) > 0 then do
            writeIORef w $! (take 0 (deref w) ++ [((deref w) !! 0) ++ "s"] ++ drop (0 + 1) (deref w))
        else return ()

        return (unsafePerformIO (join (deref w) " "))



randInt seed n = let next = (seed * 1664525 + 1013904223) `mod` 2147483647 in next `mod` n

slur p d = do
    if length p <= 2 then do
        return (p)
    else do
        a <- newIORef ([])
        i <- newIORef (1)
        let
            loop = do
                if (deref i) < length p - 1 then do
                    writeIORef a $! ((deref a) ++ [take ((deref i) + 1 - (deref i)) (drop (deref i) p)])
                    writeIORef i $! ((deref i) + 1)
                    loop
                else return ()
        loop
        idx <- newIORef (length (deref a) - 1)
        seed <- newIORef (d)
        let
            loop = do
                if (deref idx) >= 1 then do
                    writeIORef seed $! (((deref seed) * 1664525 + 1013904223) `mod` 2147483647)
                    if (deref seed) `mod` 100 >= d then do
                        let j = (deref seed) `mod` ((deref idx) + 1)
                        let tmp = ((deref a) !! (deref idx))
                        writeIORef a $! (take (deref idx) (deref a) ++ [((deref a) !! j)] ++ drop ((deref idx) + 1) (deref a))
                        writeIORef a $! (take j (deref a) ++ [tmp] ++ drop (j + 1) (deref a))
                    else return ()

                    writeIORef idx $! ((deref idx) - 1)
                    loop
                else return ()
        loop
        s <- newIORef (take (1 - 0) (drop 0 p))
        k <- newIORef (0)
        let
            loop = do
                if (deref k) < length (deref a) then do
                    writeIORef s $! ((deref s) ++ ((deref a) !! (deref k)))
                    writeIORef k $! ((deref k) + 1)
                    loop
                else return ()
        loop
        writeIORef s $! ((deref s) ++ take (length p - length p - 1) (drop (length p - 1) p))
        let w = unsafePerformIO (fields (deref s))
        return (unsafePerformIO (join w " "))



main = do
    i <- newIORef (99)
    let
        loop = do
            if (deref i) > 0 then do
                putStrLn (unsafePerformIO (slur (unsafePerformIO (numberName (deref i))) (deref i)) ++ " " ++ unsafePerformIO (pluralizeFirst (unsafePerformIO (slur "bottle of" (deref i))) (deref i)) ++ " " ++ unsafePerformIO (slur "beer on the wall" (deref i)))
                putStrLn (unsafePerformIO (slur (unsafePerformIO (numberName (deref i))) (deref i)) ++ " " ++ unsafePerformIO (pluralizeFirst (unsafePerformIO (slur "bottle of" (deref i))) (deref i)) ++ " " ++ unsafePerformIO (slur "beer" (deref i)))
                putStrLn (unsafePerformIO (slur "take one" (deref i)) ++ " " ++ unsafePerformIO (slur "down" (deref i)) ++ " " ++ unsafePerformIO (slur "pass it around" (deref i)))
                putStrLn (unsafePerformIO (slur (unsafePerformIO (numberName ((deref i) - 1))) (deref i)) ++ " " ++ unsafePerformIO (pluralizeFirst (unsafePerformIO (slur "bottle of" (deref i))) ((deref i) - 1)) ++ " " ++ unsafePerformIO (slur "beer on the wall" (deref i)))
                writeIORef i $! ((deref i) - 1)
                loop
            else return ()
    loop


