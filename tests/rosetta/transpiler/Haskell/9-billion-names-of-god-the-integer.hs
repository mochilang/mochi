{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
-- Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:18 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
bigTrim a = do
    n <- newIORef (length (deref a))
    let
        loop = do
            if (deref n) > fromIntegral 1 && ((deref a) !! (deref n) - fromIntegral 1) == 0 then do
                writeIORef a $! (take ((deref n) - fromIntegral 1 - 0) (drop 0 (deref a)))
                writeIORef n $! ((deref n) - fromIntegral 1)
                loop
            else return ()
    loop
    return ((deref a))


bigFromInt x = do
    if (deref x) == 0 then do
        return ([0])
    else return ()

    digits <- newIORef ([])
    n <- newIORef ((deref x))
    let
        loop = do
            if (deref n) > fromIntegral 0 then do
                writeIORef digits $! ((deref digits) ++ [(deref n) `mod` fromIntegral 10])
                writeIORef n $! ((deref n) / fromIntegral 10)
                loop
            else return ()
    loop
    return ((deref digits))


bigAdd a b = do
    res <- newIORef ([])
    carry <- newIORef (0)
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < length (deref a) || (deref i) < length b || (deref carry) > fromIntegral 0 then do
                av <- newIORef (0)
                if (deref i) < length (deref a) then do
                    writeIORef av $! (((deref a) !! (deref i)))
                else return ()

                bv <- newIORef (0)
                if (deref i) < length b then do
                    writeIORef bv $! ((b !! (deref i)))
                else return ()

                s <- newIORef ((deref av) + (deref bv) + (deref carry))
                writeIORef res $! ((deref res) ++ [(deref s) `mod` 10])
                writeIORef carry $! ((deref s) / fromIntegral 10)
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return (bigTrim (deref res))


bigSub a b = do
    res <- newIORef ([])
    borrow <- newIORef (0)
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < length (deref a) then do
                av <- newIORef (((deref a) !! (deref i)))
                bv <- newIORef (0)
                if (deref i) < length b then do
                    writeIORef bv $! ((b !! (deref i)))
                else return ()

                diff <- newIORef ((deref av) - (deref bv) - (deref borrow))
                if (deref diff) < 0 then do
                    writeIORef diff $! ((deref diff) + 10)
                    writeIORef borrow $! (1)
                else do
                    writeIORef borrow $! (0)

                writeIORef res $! ((deref res) ++ [(deref diff)])
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return (bigTrim (deref res))


bigToString a = do
    s <- newIORef ("")
    i <- newIORef (length (deref a) - 1)
    let
        loop = do
            if (deref i) >= 0 then do
                writeIORef s $! ((deref s) ++ show (((deref a) !! (deref i))))
                writeIORef i $! ((deref i) - 1)
                loop
            else return ()
    loop
    return ((deref s))


minInt a b = do
    if (deref a) < b then do
        return ((deref a))
    else do
        return (b)



cumu n = do
    cache <- newIORef ([[bigFromInt 1]])
    y <- newIORef (1)
    let
        loop = do
            if fromIntegral (deref y) <= (deref n) then do
                row <- newIORef ([bigFromInt 0])
                x <- newIORef (1)
                let
                    loop = do
                        if (deref x) <= (deref y) then do
                            val = (((deref cache) !! (deref y) - (deref x)) !! minInt (deref x) ((deref y) - (deref x)))
                            writeIORef row $! ((deref row) ++ [bigAdd (((deref row) !! length (deref row) - 1)) val])
                            writeIORef x $! ((deref x) + 1)
                            loop
                        else return ()
                loop
                writeIORef cache $! ((deref cache) ++ [(deref row)])
                writeIORef y $! ((deref y) + 1)
                loop
            else return ()
    loop
    return (((deref cache) !! (deref n)))


row n = do
    e = cumu (deref n)
    out <- newIORef ([])
    i <- newIORef (0)
    let
        loop = do
            if fromIntegral (deref i) < (deref n) then do
                diff <- newIORef (bigSub ((e !! (deref i) + 1)) ((e !! (deref i))))
                writeIORef out $! ((deref out) ++ [bigToString (deref diff)])
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return ((deref out))


main :: IO ()
main = do
    x <- newIORef (1)
    putStrLn ("rows:")
    let
        loop = do
            if (deref x) < 11 then do
                r = (deref row) (deref x)
                line <- newIORef ("")
                i <- newIORef (0)
                let
                    loop = do
                        if (deref i) < length r then do
                            writeIORef line $! ((deref line) ++ " " ++ (r !! (deref i)) ++ " ")
                            writeIORef i $! ((deref i) + 1)
                            loop
                        else return ()
                loop
                putStrLn ((deref line))
                writeIORef x $! ((deref x) + 1)
                loop
            else return ()
    loop
    putStrLn ("")
    putStrLn ("sums:")
    mapM_ (\num -> do
        r = cumu num
        putStrLn (show num ++ " " ++ bigToString ((r !! length r - 1)))
        ) [23, 123, 1234]
