{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (bigAbsDiff, bigAdd, bigCmp, bigDivSmall, bigFromInt, bigMulBig, bigMulPow10, bigMulSmall, bigSub, bigToString, bigTrim, computeIP, factorSmall, factorialExp, formatTerm, main, primesUpTo, repeat, sortInts)
-- Generated by Mochi transpiler v0.10.54 on 2025-08-02 11:20 GMT+7
import qualified Data.Map as Map
import Text.Printf (printf)
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.Environment (lookupEnv)
import Data.Time.Clock.POSIX (getPOSIXTime)
import Data.Char (isDigit)
import GHC.Stats (getRTSStats, max_mem_in_use_bytes)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
int :: String -> Int
int = read
float :: Int -> Double
float n = fromIntegral n
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
powInt :: Int -> Int -> Int
powInt b e = go 1 b e where
    go r b e | e > 0 = go (if e `mod` 2 == 1 then r*b else r) (b*b) (e `div` 2)
              | otherwise = r
_nowSeed :: IORef Int
_nowSeed = unsafePerformIO (newIORef 0)
{-# NOINLINE _nowSeed #-}
_nowSeeded :: IORef Bool
_nowSeeded = unsafePerformIO (newIORef False)
{-# NOINLINE _nowSeeded #-}
_now :: IO Int
_now = do
    seeded <- readIORef _nowSeeded
    if not seeded then do
        m <- lookupEnv "MOCHI_NOW_SEED"
        case m of
            Just s | all isDigit s -> do writeIORef _nowSeed (read s); writeIORef _nowSeeded True
            _ -> return ()
     else return ()
    seeded2 <- readIORef _nowSeeded
    if seeded2 then do
        modifyIORef' _nowSeed (\x -> (x * 1664525 + 1013904223) `mod` 2147483647)
        readIORef _nowSeed
    else do
        t <- getPOSIXTime
        return (floor (t * 1000000000))
_mem :: IO Int
_mem = fmap (fromIntegral . max_mem_in_use_bytes) getRTSStats
bigTrim a = do
    n <- newIORef (length (deref a))
    let
        loop = do
            if (deref n) > 1 && ((deref a) !! (deref n) - 1) == 0 then do
                writeIORef a $! (take ((deref n) - 1 - 0) (drop 0 (deref a)))
                writeIORef n $! ((deref n) - 1)
                loop
            else return ()
    loop
    return ((deref a))


bigFromInt x = do
    if x == 0 then do
        return ([0])
    else do
        digits <- newIORef ([])
        n <- newIORef (x)
        let
            loop = do
                if (deref n) > 0 then do
                    writeIORef digits $! ((deref digits) ++ [(deref n) `mod` 10])
                    writeIORef n $! ((deref n) `div` 10)
                    loop
                else return ()
        loop
        return ((deref digits))



bigCmp a b = do
    if length a > length b then do
        return (1)
    else do
        if length a < length b then do
            return (-1)
        else do
            i <- newIORef (length a - 1)
            let
                loop = do
                    if (deref i) >= 0 then do
                        if (a !! (deref i)) > (b !! (deref i)) then do
                            return (1)
                        else do
                            if (a !! (deref i)) < (b !! (deref i)) then do
                                return (-1)
                            else do
                                writeIORef i $! ((deref i) - 1)


                        loop
                    else return ()
            loop
            return (0)




bigAdd a b = do
    res <- newIORef ([])
    carry <- newIORef (0 :: Int)
    i <- newIORef (0 :: Int)
    let
        loop = do
            if (deref i) < length a || (deref i) < length b || (deref carry) > fromIntegral 0 then do
                av <- newIORef (0 :: Int)
                if (deref i) < length a then do
                    writeIORef av $! ((a !! (deref i)))
                else return ()

                bv <- newIORef (0 :: Int)
                if (deref i) < length b then do
                    writeIORef bv $! ((b !! (deref i)))
                else return ()

                let s = (deref av) + (deref bv) + (deref carry)
                writeIORef res $! ((deref res) ++ [s `mod` 10])
                writeIORef carry $! (s / 10)
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return (unsafePerformIO (bigTrim res))


bigSub a b = do
    res <- newIORef ([])
    borrow <- newIORef (0 :: Int)
    i <- newIORef (0 :: Int)
    let
        loop = do
            if (deref i) < length a then do
                let av = (a !! (deref i))
                bv <- newIORef (0 :: Int)
                if (deref i) < length b then do
                    writeIORef bv $! ((b !! (deref i)))
                else return ()

                diff <- newIORef (av - (deref bv) - (deref borrow))
                if (deref diff) < 0 then do
                    writeIORef diff $! ((deref diff) + 10)
                    writeIORef borrow $! (1)
                else do
                    writeIORef borrow $! (0)

                writeIORef res $! ((deref res) ++ [(deref diff)])
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return (unsafePerformIO (bigTrim res))


bigMulSmall a m = do
    if m == 0 then do
        return ([0])
    else do
        res <- newIORef ([])
        carry <- newIORef (0 :: Int)
        i <- newIORef (0 :: Int)
        let
            loop = do
                if (deref i) < length a then do
                    let prod = (a !! (deref i)) * m + (deref carry)
                    writeIORef res $! ((deref res) ++ [prod `mod` 10])
                    writeIORef carry $! (prod / 10)
                    writeIORef i $! ((deref i) + 1)
                    loop
                else return ()
        loop
        let
            loop = do
                if (deref carry) > fromIntegral 0 then do
                    writeIORef res $! ((deref res) ++ [(deref carry) `mod` fromIntegral 10])
                    writeIORef carry $! ((deref carry) / fromIntegral 10)
                    loop
                else return ()
        loop
        return (unsafePerformIO (bigTrim res))



bigMulBig a b = do
    res <- newIORef ([])
    i <- newIORef (0 :: Int)
    let
        loop = do
            if (deref i) < length a + length b then do
                writeIORef res $! ((deref res) ++ [0])
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    writeIORef i $! (0)
    let
        loop = do
            if (deref i) < length a then do
                carry <- newIORef (0 :: Int)
                j <- newIORef (0 :: Int)
                let
                    loop = do
                        if (deref j) < length b then do
                            idx <- newIORef ((deref i) + (deref j))
                            let prod = ((deref res) !! (deref idx)) + (a !! (deref i)) * (b !! (deref j)) + (deref carry)
                            writeIORef res $! (take (deref idx) (deref res) ++ [prod `mod` 10] ++ drop ((deref idx) + 1) (deref res))
                            writeIORef carry $! (prod / 10)
                            writeIORef j $! ((deref j) + 1)
                            loop
                        else return ()
                loop
                idx <- newIORef ((deref i) + length b)
                let
                    loop = do
                        if (deref carry) > fromIntegral 0 then do
                            let prod = ((deref res) !! (deref idx)) + (deref carry)
                            writeIORef res $! (take (deref idx) (deref res) ++ [prod `mod` 10] ++ drop ((deref idx) + 1) (deref res))
                            writeIORef carry $! (prod / 10)
                            writeIORef idx $! ((deref idx) + 1)
                            loop
                        else return ()
                loop
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return (unsafePerformIO (bigTrim res))


bigMulPow10 a k = do
    i <- newIORef (0 :: Int)
    let
        loop = do
            if (deref i) < k then do
                writeIORef a $! ([0] ++ (deref a))
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return ((deref a))


bigDivSmall a m = do
    res <- newIORef ([])
    rem <- newIORef (0 :: Int)
    i <- newIORef (length a - 1)
    let
        loop = do
            if (deref i) >= 0 then do
                let cur = (deref rem) * 10 + (a !! (deref i))
                let q = cur / m
                writeIORef rem $! (cur `mod` m)
                writeIORef res $! ([q] ++ (deref res))
                writeIORef i $! ((deref i) - 1)
                loop
            else return ()
    loop
    return (unsafePerformIO (bigTrim res))


bigToString a = do
    s <- newIORef ("")
    i <- newIORef (length a - 1)
    let
        loop = do
            if (deref i) >= 0 then do
                writeIORef s $! ((deref s) ++ show ((a !! (deref i))))
                writeIORef i $! ((deref i) - 1)
                loop
            else return ()
    loop
    return ((deref s))


repeat ch n = do
    s <- newIORef ("")
    i <- newIORef (0 :: Int)
    let
        loop = do
            if (deref i) < n then do
                writeIORef s $! ((deref s) ++ ch)
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return ((deref s))


sortInts xs = do
    res <- newIORef ([])
    tmp <- newIORef (xs)
    let
        loop = do
            if length (deref tmp) > 0 then do
                min <- newIORef (((deref tmp) !! 0))
                idx <- newIORef (0 :: Int)
                i <- newIORef (1 :: Int)
                let
                    loop = do
                        if (deref i) < length (deref tmp) then do
                            if ((deref tmp) !! (deref i)) < (deref min) then do
                                writeIORef min $! (((deref tmp) !! (deref i)))
                                writeIORef idx $! ((deref i))
                            else return ()

                            writeIORef i $! ((deref i) + 1)
                            loop
                        else return ()
                loop
                writeIORef res $! ((deref res) ++ [(deref min)])
                out <- newIORef ([])
                j <- newIORef (0 :: Int)
                let
                    loop = do
                        if (deref j) < length (deref tmp) then do
                            if (deref j) /= (deref idx) then do
                                writeIORef out $! ((deref out) ++ [((deref tmp) !! (deref j))])
                            else return ()

                            writeIORef j $! ((deref j) + 1)
                            loop
                        else return ()
                loop
                writeIORef tmp $! ((deref out))
                loop
            else return ()
    loop
    return ((deref res))


primesUpTo n = do
    sieve <- newIORef ([])
    i <- newIORef (0 :: Int)
    let
        loop = do
            if (deref i) <= n then do
                writeIORef sieve $! ((deref sieve) ++ [True])
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    p <- newIORef (2 :: Int)
    let
        loop = do
            if (deref p) * (deref p) <= n then do
                if ((deref sieve) !! (deref p)) then do
                    m <- newIORef ((deref p) * (deref p))
                    let
                        loop = do
                            if (deref m) <= n then do
                                writeIORef sieve $! (take (deref m) (deref sieve) ++ [False] ++ drop ((deref m) + 1) (deref sieve))
                                writeIORef m $! ((deref m) + (deref p))
                                loop
                            else return ()
                    loop
                else return ()

                writeIORef p $! ((deref p) + 1)
                loop
            else return ()
    loop
    res <- newIORef ([])
    x <- newIORef (2 :: Int)
    let
        loop = do
            if (deref x) <= n then do
                if ((deref sieve) !! (deref x)) then do
                    writeIORef res $! ((deref res) ++ [(deref x)])
                else return ()

                writeIORef x $! ((deref x) + 1)
                loop
            else return ()
    loop
    return ((deref res))


factorialExp n primes = do
    m <- newIORef (Map.fromList [])
    (let
        loop [] = return ((deref m))
        loop (p:xs) = do
            if p > n then do
                return ()
            else return ()

            t <- newIORef (n)
            e <- newIORef (0 :: Int)
            let
                loop = do
                    if (deref t) > fromIntegral 0 then do
                        writeIORef t $! ((deref t) / fromIntegral p)
                        writeIORef e $! (fromIntegral (deref e) + (deref t))
                        loop
                    else return ()
            loop
            writeIORef m $! (Map.insert (show p) (deref e) (deref m))
            loop xs
        in loop primes)


factorSmall x primes = do
    f <- newIORef (Map.fromList [])
    n <- newIORef (x)
    let
        loop [] = return ()
        loop (p:xs) | p * p > (deref n) = return ()
            | otherwise = do
            c <- newIORef (0 :: Int)
            let
                loop = do
                    if (deref n) `mod` p == 0 then do
                        writeIORef c $! ((deref c) + 1)
                        writeIORef n $! ((deref n) `div` p)
                        loop
                    else return ()
            loop
            if (deref c) > 0 then do
                writeIORef f $! (Map.insert (show p) (deref c) (deref f))
            else return ()

            loop xs
    loop primes
    if (deref n) > 1 then do
        writeIORef f $! (Map.insert (show (deref n)) ((deref f) Map.! "get" (show (deref n)) 0 + 1) (deref f))
    else return ()

    return ((deref f))


computeIP n primes = do
    exps <- newIORef (unsafePerformIO (factorialExp (6 * n) primes))
    let fn = unsafePerformIO (factorialExp n primes)
    mapM_ (\k -> do
        writeIORef exps $! (take k (deref exps) ++ [(deref exps).get k 0 - 6 * (fn !! k)] ++ drop (k + 1) (deref exps))
        ) fn
    writeIORef exps $! (take "2" (deref exps) ++ [(deref exps).get "2" 0 + 5] ++ drop ("2" ++ 1) (deref exps))
    let t2 = 532 * n * n + 126 * n + 9
    let ft2 = unsafePerformIO (factorSmall t2 primes)
    mapM_ (\k -> do
        writeIORef exps $! (take k (deref exps) ++ [(deref exps).get k 0 + (ft2 !! k)] ++ drop (k + 1) (deref exps))
        ) ft2
    writeIORef exps $! (take "3" (deref exps) ++ [(deref exps).get "3" 0 - 1] ++ drop ("3" ++ 1) (deref exps))
    keys <- newIORef ([])
    mapM_ (\k -> do
        writeIORef keys $! ((deref keys) ++ [unsafePerformIO (int k)])
        ) (deref exps)
    writeIORef keys $! (unsafePerformIO (sortInts (deref keys)))
    res <- newIORef (unsafePerformIO (bigFromInt 1))
    (let
        loop [] = return ((deref res))
        loop (p:xs) = do
            let e = ((deref exps) !! show p)
            i <- newIORef (0 :: Int)
            let
                loop = do
                    if (deref i) < e then do
                        writeIORef res $! (unsafePerformIO (bigMulSmall (deref res) p))
                        writeIORef i $! ((deref i) + 1)
                        loop
                    else return ()
            loop
            loop xs
        in loop (deref keys))


formatTerm ip pw = do
    let s = unsafePerformIO (bigToString ip)
    if pw >= length s then do
        frac <- newIORef (unsafePerformIO (repeat "0" (pw - length s)) ++ s)
        if length (deref frac) < 33 then do
            writeIORef frac $! ((deref frac) ++ unsafePerformIO (repeat "0" (33 - length (deref frac))))
        else return ()

        return ("0." ++ take (33 - 0) (drop 0 (deref frac)))
    else do
        let intpart = take (length s - pw - 0) (drop 0 s)
        frac <- newIORef (unsafePerformIO (take (length s - length s - pw) (drop (length s - pw) s)))
        if length (deref frac) < 33 then do
            writeIORef frac $! ((deref frac) ++ unsafePerformIO (repeat "0" (33 - length (deref frac))))
        else return ()

        return (intpart ++ "." ++ take (33 - 0) (drop 0 (deref frac)))



bigAbsDiff a b = do
    if unsafePerformIO (bigCmp a b) >= 0 then do
        return (unsafePerformIO (bigSub a b))
    else do
        return (unsafePerformIO (bigSub b a))



mainEntry = do
    let primes = unsafePerformIO (primesUpTo 2000)
    putStrLn ("N                               Integer Portion  Pow  Nth Term (33 dp)")
    let line = unsafePerformIO (repeat "-" 89)
    print (line)
    sum <- newIORef (unsafePerformIO (bigFromInt 0))
    prev <- newIORef (unsafePerformIO (bigFromInt 0))
    denomPow <- newIORef (0 :: Int)
    n <- newIORef (0 :: Int)
    let
        loop = do
            if True then do
                let ip = unsafePerformIO (computeIP (deref n) primes)
                let pw = 6 * (deref n) + 3
                if pw > (deref denomPow) then do
                    writeIORef sum $! (unsafePerformIO (bigMulPow10 sum (pw - (deref denomPow))))
                    writeIORef prev $! (unsafePerformIO (bigMulPow10 prev (pw - (deref denomPow))))
                    writeIORef denomPow $! (pw)
                else return ()

                if (deref n) < 10 then do
                    let termStr = unsafePerformIO (formatTerm ip pw)
                    ipStr <- newIORef (unsafePerformIO (bigToString ip))
                    let
                        loop = do
                            if length (deref ipStr) < 44 then do
                                writeIORef ipStr $! (" " ++ (deref ipStr))
                                loop
                            else return ()
                    loop
                    pwStr <- newIORef (unsafePerformIO (show (-pw)))
                    let
                        loop = do
                            if length (deref pwStr) < 3 then do
                                writeIORef pwStr $! (" " ++ (deref pwStr))
                                loop
                            else return ()
                    loop
                    padTerm <- newIORef (termStr)
                    let
                        loop = do
                            if length (deref padTerm) < 35 then do
                                writeIORef padTerm $! ((deref padTerm) ++ " ")
                                loop
                            else return ()
                    loop
                    putStrLn (show (deref n) ++ "  " ++ (deref ipStr) ++ "  " ++ (deref pwStr) ++ "  " ++ (deref padTerm))
                else return ()

                writeIORef sum $! (unsafePerformIO (bigAdd (deref sum) ip))
                let diff = unsafePerformIO (bigAbsDiff (deref sum) (deref prev))
                if (deref denomPow) >= 70 && unsafePerformIO (bigCmp diff (unsafePerformIO (bigMulPow10 (unsafePerformIO (bigFromInt 1)) ((deref denomPow) - 70)))) < 0 then do
                    return ()
                else return ()

                writeIORef prev $! ((deref sum))
                writeIORef n $! ((deref n) + 1)
                loop
            else return ()
    loop
    let precision = 70
    let target = unsafePerformIO (bigMulPow10 (unsafePerformIO (bigFromInt 1)) ((deref denomPow) + 2 * precision))
    low <- newIORef (unsafePerformIO (bigFromInt 0))
    high <- newIORef (unsafePerformIO (bigMulPow10 (unsafePerformIO (bigFromInt 1)) (precision + 1)))
    let
        loop = do
            if unsafePerformIO (bigCmp (deref low) (unsafePerformIO (bigSub (deref high) (unsafePerformIO (bigFromInt 1))))) < 0 then do
                let mid = unsafePerformIO (bigDivSmall (unsafePerformIO (bigAdd (deref low) (deref high))) 2)
                let prod = unsafePerformIO (bigMulBig (unsafePerformIO (bigMulBig mid mid)) (deref sum))
                if unsafePerformIO (bigCmp prod target) <= 0 then do
                    writeIORef low $! (mid)
                else do
                    writeIORef high $! (unsafePerformIO (bigSub mid (unsafePerformIO (bigFromInt 1))))

                loop
            else return ()
    loop
    let piInt = (deref low)
    piStr <- newIORef (unsafePerformIO (bigToString piInt))
    if length (deref piStr) <= precision then do
        writeIORef piStr $! (unsafePerformIO (repeat "0" (precision - length (deref piStr) + 1)) + (deref piStr))
    else return ()

    let out = take (length (deref piStr) - precision - 0) (drop 0 (deref piStr)) ++ "." ++ take (length (deref piStr) - length (deref piStr) - precision) (drop (length (deref piStr) - precision) (deref piStr))
    putStrLn ("")
    putStrLn ("Pi to 70 decimal places is:")
    putStrLn (out)


main = do
    do
        start <- _now
        mainEntry
        end <- _now
        memEnd <- _mem
        printf "{\"duration_us\":%d,\"memory_bytes\":%d,\"name\":\"main\"}\n" ((end - start) `div` 1000) memEnd



