{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (denom, left, num, op, right, value)
-- Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:18 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
data GenType8 = GenType8
  { op :: Int,
    left :: String,
    right :: String
  } deriving (Show, Eq)


data GenType9 = GenType9
  { op :: Int,
    left :: String,
    right :: String
  } deriving (Show, Eq)


data GenType1 = GenType1
  { num :: String,
    denom :: Int
  } deriving (Show, Eq)


data GenType5 = GenType5
  { num :: String,
    denom :: String
  } deriving (Show, Eq)


data GenType6 = GenType6
  { num :: String,
    denom :: String
  } deriving (Show, Eq)


data GenType2 = GenType2
  { op :: Int,
    value :: String
  } deriving (Show, Eq)


data GenType3 = GenType3
  { num :: String,
    denom :: String
  } deriving (Show, Eq)


data GenType4 = GenType4
  { num :: String,
    denom :: String
  } deriving (Show, Eq)


data GenType7 = GenType7
  { op :: String,
    left :: String,
    right :: String
  } deriving (Show, Eq)


newNum n = GenType2 {op = OP_NUM, value = GenType1 {num = n, denom = 1}}

exprEval x = do
    if (x !! "op") == OP_NUM then do
        return ((x !! "value"))
    else return ()

    l = exprEval ((x !! "left"))
    r = exprEval ((x !! "right"))
    if (x !! "op") == OP_ADD then do
        return (GenType3 {num = (l !! "num") * (r !! "denom") + (l !! "denom") * (r !! "num"), denom = (l !! "denom") * (r !! "denom")})
    else return ()

    if (x !! "op") == OP_SUB then do
        return (GenType4 {num = (l !! "num") * (r !! "denom") - (l !! "denom") * (r !! "num"), denom = (l !! "denom") * (r !! "denom")})
    else return ()

    if (x !! "op") == OP_MUL then do
        return (GenType5 {num = (l !! "num") * (r !! "num"), denom = (l !! "denom") * (r !! "denom")})
    else return ()

    return (GenType6 {num = (l !! "num") * (r !! "denom"), denom = (l !! "denom") * (r !! "num")})


exprString x = do
    if (x !! "op") == OP_NUM then do
        return (show (((x !! "value") !! "num")))
    else return ()

    ls = exprString ((x !! "left"))
    rs = exprString ((x !! "right"))
    opstr <- newIORef ("")
    if (x !! "op") == OP_ADD then do
        writeIORef opstr $! (" + ")
    else do
        if (x !! "op") == OP_SUB then do
            writeIORef opstr $! (" - ")
        else do
            if (x !! "op") == OP_MUL then do
                writeIORef opstr $! (" * ")
            else do
                writeIORef opstr $! (" / ")



    return ("(" ++ ls ++ (deref opstr) ++ rs ++ ")")


solve xs = do
    if length xs == 1 then do
        f = exprEval ((xs !! 0))
        if (f !! "denom") != 0 && (f !! "num") == (f !! "denom") * goal then do
            print (exprString ((xs !! 0)))
            return (True)
        else return ()

        return (False)
    else return ()

    i <- newIORef (0)
    let
        loop = do
            if (deref i) < length xs then do
                j <- newIORef ((deref i) + 1)
                let
                    loop = do
                        if (deref j) < length xs then do
                            rest <- newIORef ([])
                            k <- newIORef (0)
                            let
                                loop = do
                                    if (deref k) < length xs then do
                                        if (deref k) != (deref i) && (deref k) != (deref j) then do
                                            writeIORef rest $! ((deref rest) ++ [(xs !! (deref k))])
                                        else return ()

                                        writeIORef k $! ((deref k) + 1)
                                        loop
                                    else return ()
                            loop
                            a = (xs !! (deref i))
                            b = (xs !! (deref j))
                            mapM_ (\op -> do
                                node <- newIORef (GenType7 {op = op, left = a, right = b})
                                if solve ((deref rest) ++ [(deref node)]) then do
                                    return (True)
                                else return ()

                                ) [OP_ADD, OP_SUB, OP_MUL, OP_DIV]
                            node <- newIORef (GenType8 {op = OP_SUB, left = b, right = a})
                            if solve ((deref rest) ++ [(deref node)]) then do
                                return (True)
                            else return ()

                            writeIORef node $! (GenType9 {op = OP_DIV, left = b, right = a})
                            if solve ((deref rest) ++ [(deref node)]) then do
                                return (True)
                            else return ()

                            writeIORef j $! ((deref j) + 1)
                            loop
                        else return ()
                loop
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return (False)


main = do
    iter <- newIORef (0)
    let
        loop = do
            if (deref iter) < 10 then do
                cards <- newIORef ([])
                i <- newIORef (0)
                let
                    loop = do
                        if (deref i) < n_cards then do
                            n = (now `mod` (digit_range - 1)) + 1
                            writeIORef cards $! ((deref cards) ++ [newNum n])
                            putStrLn (" " ++ show n)
                            writeIORef i $! ((deref i) + 1)
                            loop
                        else return ()
                loop
                putStrLn (":  ")
                if not (solve (deref cards)) then do
                    putStrLn ("No solution")
                else return ()

                writeIORef iter $! ((deref iter) + 1)
                loop
            else return ()
    loop


OP_ADD = 1

OP_DIV = 4

OP_MUL = 3

OP_NUM = 0

OP_SUB = 2

digit_range = 9

goal = 24

n_cards = 4

main :: IO ()
main = do
    main
