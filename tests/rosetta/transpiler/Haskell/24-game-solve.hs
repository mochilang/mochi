{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (Expr, Rational, denom, left, num, op, right, value)
-- Generated by Mochi transpiler v0.10.38 on 2025-07-24 07:48 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.Environment (lookupEnv)
import Data.Time.Clock.POSIX (getPOSIXTime)
import Data.Char (isDigit)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
_nowSeed :: IORef Int
_nowSeed = unsafePerformIO (newIORef 0)
{-# NOINLINE _nowSeed #-}
_nowSeeded :: IORef Bool
_nowSeeded = unsafePerformIO (newIORef False)
{-# NOINLINE _nowSeeded #-}
_now :: IO Int
_now = do
    seeded <- readIORef _nowSeeded
    if not seeded then do
        m <- lookupEnv "MOCHI_NOW_SEED"
        case m of
            Just s | all isDigit s -> do writeIORef _nowSeed (read s); writeIORef _nowSeeded True
            _ -> return ()
     else return ()
    seeded2 <- readIORef _nowSeeded
    if seeded2 then do
        modifyIORef' _nowSeed (\x -> (x * 1664525 + 1013904223) `mod` 2147483647)
        readIORef _nowSeed
    else do
        t <- getPOSIXTime
        return (floor (t * 1000000000))
data Rational = Rational
  { num :: Int,
    denom :: Int
  } deriving (Show, Eq)


data Expr = Num {value :: Rational} | Bin {op :: Int, left :: Expr, right :: Expr}
  deriving (Show, Eq)


binEval op l r = let lv = exprEval l in let rv = exprEval r in if op == oP_ADD then Rational {num = lv.num * rv.denom + lv.denom * rv.num, denom = lv.denom * rv.denom} else if op == oP_SUB then Rational {num = lv.num * rv.denom - lv.denom * rv.num, denom = lv.denom * rv.denom} else if op == oP_MUL then Rational {num = lv.num * rv.num, denom = lv.denom * rv.denom} else Rational {num = lv.num * rv.denom, denom = lv.denom * rv.num}

binString op l r = do
    let ls = exprString l
    let rs = exprString r
    opstr <- newIORef ("")
    if op == oP_ADD then do
        writeIORef opstr $! (" + ")
    else do
        if op == oP_SUB then do
            writeIORef opstr $! (" - ")
        else do
            if op == oP_MUL then do
                writeIORef opstr $! (" * ")
            else do
                writeIORef opstr $! (" / ")



    return ("(" ++ ls ++ (deref opstr) ++ rs ++ ")")


newNum n = Num {value = Rational {num = n, denom = 1}}

exprEval x = (case x of Num {value = v} -> v; Bin {op = op, left = l, right = r} -> binEval op l r; )

exprString x = (case x of Num {value = v} -> show (v.num); Bin {op = op, left = l, right = r} -> binString op l r; )

solve xs = do
    if length xs == 1 then do
        let f = exprEval ((xs !! 0))
        if f.denom /= 0 && f.num == f.denom * goal then do
            print (exprString ((xs !! 0)))
            return (True)
        else do
            return (False)

    else do
        i <- newIORef (0)
        (let {
            loop = do
                if (deref i) < length xs then do
                    j <- newIORef ((deref i) + 1)
                    let
                        loop = do
                            if (deref j) < length xs then do
                                rest <- newIORef ([])
                                k <- newIORef (0)
                                let
                                    loop = do
                                        if (deref k) < length xs then do
                                            if (deref k) /= (deref i) && (deref k) /= (deref j) then do
                                                writeIORef rest $! ((deref rest) ++ [(xs !! (deref k))])
                                            else return ()

                                            writeIORef k $! ((deref k) + 1)
                                            loop
                                        else return ()
                                loop
                                let a = (xs !! (deref i))
                                let b = (xs !! (deref j))
                                mapM_ (\op -> do
                                    node <- newIORef (Bin {op = op, left = a, right = b})
                                    if solve ((deref rest) ++ [(deref node)]) then do
                                        return (True)
                                    else return ()

                                    ) [oP_ADD, oP_SUB, oP_MUL, oP_DIV]
                                node <- newIORef (Bin {op = oP_SUB, left = b, right = a})
                                writeIORef j $! ((deref j) + 1)
                                loop
                            else return ()
                    loop
                    writeIORef i $! ((deref i) + 1)
                    loop
                else return (False)
        } in loop)



main = do
    iter <- newIORef (0)
    let
        loop = do
            if (deref iter) < 10 then do
                cards <- newIORef ([])
                i <- newIORef (0)
                let
                    loop = do
                        if (deref i) < n_cards then do
                            let n = (unsafePerformIO (_now) `mod` (digit_range - 1)) + 1
                            writeIORef cards $! ((deref cards) ++ [newNum n])
                            putStrLn (" " ++ show n)
                            writeIORef i $! ((deref i) + 1)
                            loop
                        else return ()
                loop
                putStrLn (":  ")
                if not (solve (deref cards)) then do
                    putStrLn ("No solution")
                else return ()

                writeIORef iter $! ((deref iter) + 1)
                loop
            else return ()
    loop


digit_range = 9

goal = 24

n_cards = 4

oP_ADD = 1

oP_DIV = 4

oP_MUL = 3

oP_SUB = 2

