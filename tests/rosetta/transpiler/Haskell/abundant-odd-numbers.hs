{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
{-# LANGUAGE OverloadedStrings #-}
-- Generated by Mochi transpiler v0.10.41 on 2025-07-26 17:25 GMT+7
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Encode.Pretty as Pretty
import qualified Data.ByteString.Lazy.Char8 as BSL
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.Environment (lookupEnv)
import Data.Time.Clock.POSIX (getPOSIXTime)
import Data.Char (isDigit)
import GHC.Stats (getRTSStats, max_mem_in_use_bytes)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
int :: String -> Int
int = read
float :: Int -> Double
float n = fromIntegral n
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
_nowSeed :: IORef Int
_nowSeed = unsafePerformIO (newIORef 0)
{-# NOINLINE _nowSeed #-}
_nowSeeded :: IORef Bool
_nowSeeded = unsafePerformIO (newIORef False)
{-# NOINLINE _nowSeeded #-}
_now :: IO Int
_now = do
    seeded <- readIORef _nowSeeded
    if not seeded then do
        m <- lookupEnv "MOCHI_NOW_SEED"
        case m of
            Just s | all isDigit s -> do writeIORef _nowSeed (read s); writeIORef _nowSeeded True
            _ -> return ()
     else return ()
    seeded2 <- readIORef _nowSeeded
    if seeded2 then do
        modifyIORef' _nowSeed (\x -> (x * 1664525 + 1013904223) `mod` 2147483647)
        readIORef _nowSeed
    else do
        t <- getPOSIXTime
        return (floor (t * 1000000000))
_mem :: IO Int
_mem = fmap (fromIntegral . max_mem_in_use_bytes) getRTSStats
divisors n = do
    divs <- newIORef ([1])
    divs2 <- newIORef ([])
    i <- newIORef (2)
    let
        loop = do
            if (deref i) * (deref i) <= n then do
                if n `mod` (deref i) == 0 then do
                    j <- newIORef (div n (deref i))
                    writeIORef divs $! ((deref divs) ++ [(deref i)])
                    if (deref i) /= (deref j) then do
                        writeIORef divs2 $! ((deref divs2) ++ [(deref j)])
                    else return ()

                else return ()

                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    j <- newIORef (length (deref divs2) - 1)
    (let {
        loop = do
            if (deref j) >= 0 then do
                writeIORef divs $! ((deref divs) ++ [((deref divs2) !! (deref j))])
                writeIORef j $! ((deref j) - 1)
                loop
            else return ((deref divs))
    } in loop)


sum xs = do
    tot <- newIORef (0)
    (let
        loop [] = return ((deref tot))
        loop (v:xs) = do
            writeIORef tot $! ((deref tot) + v)
            loop xs
        in loop xs)


sumStr xs = do
    s <- newIORef ("")
    i <- newIORef (0)
    (let {
        loop = do
            if (deref i) < length xs then do
                writeIORef s $! ((deref s) ++ show ((xs !! (deref i))) ++ " + ")
                writeIORef i $! ((deref i) + 1)
                loop
            else return (take (length (deref s) - 3 - 0) (drop 0 (deref s)))
    } in loop)


pad2 n = do
    let s = show n
    if length s < 2 then do
        return (" " ++ s)
    else do
        return (s)



pad5 n = do
    s <- newIORef (show n)
    (let {
        loop = do
            if length (deref s) < 5 then do
                writeIORef s $! (" " ++ (deref s))
                loop
            else return ((deref s))
    } in loop)


abundantOdd searchFrom countFrom countTo printOne = do
    count <- newIORef (countFrom)
    n <- newIORef (searchFrom)
    (let {
        loop = do
            if (deref count) < countTo then do
                let divs = divisors (deref n)
                let tot = sum divs
                if tot > (deref n) then do
                    writeIORef count $! ((deref count) + 1)
                    if printOne && (deref count) < countTo then do
                        writeIORef n $! ((deref n) + 2)
                        loop
                    else return ()

                    let s = sumStr divs
                    if not printOne then do
                        putStrLn (pad2 (deref count) ++ ". " ++ pad5 (deref n) ++ " < " ++ s ++ " = " ++ show tot)
                    else do
                        putStrLn (show (deref n) ++ " < " ++ s ++ " = " ++ show tot)

                else return ()

                writeIORef n $! ((deref n) + 2)
                loop
            else return ((deref n))
    } in loop)


mainEntry = do
    let max = 25
    putStrLn ("The first " ++ show max ++ " abundant odd numbers are:")
    let n = abundantOdd 1 0 max (False)
    putStrLn ("\nThe one thousandth abundant odd number is:")
    abundantOdd n max 1000 (True)
    putStrLn ("\nThe first abundant odd number above one billion is:")
    abundantOdd 1000000001 0 1 (True)


main = do
    do
        start <- _now
        mainEntry
        end <- _now
        memEnd <- _mem
        let benchData = Aeson.object ["duration_us" Aeson..= ((end - start) `div` 1000), "memory_bytes" Aeson..= memEnd, "name" Aeson..= ("main" :: String)]
        BSL.putStrLn (Pretty.encodePretty' Pretty.defConfig{Pretty.confIndent = Pretty.Spaces 2} benchData)



