{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
{-# LANGUAGE OverloadedStrings #-}
-- Generated by Mochi transpiler v0.10.40 on 2025-07-26 09:51 GMT+7
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Encode.Pretty as Pretty
import qualified Data.ByteString.Lazy.Char8 as BSL
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.Environment (lookupEnv)
import Data.Time.Clock.POSIX (getPOSIXTime)
import Data.Char (isDigit)
import GHC.Stats (getRTSStats, max_mem_in_use_bytes)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
int :: String -> Int
int = read
float :: Int -> Double
float n = fromIntegral n
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
_nowSeed :: IORef Int
_nowSeed = unsafePerformIO (newIORef 0)
{-# NOINLINE _nowSeed #-}
_nowSeeded :: IORef Bool
_nowSeeded = unsafePerformIO (newIORef False)
{-# NOINLINE _nowSeeded #-}
_now :: IO Int
_now = do
    seeded <- readIORef _nowSeeded
    if not seeded then do
        m <- lookupEnv "MOCHI_NOW_SEED"
        case m of
            Just s | all isDigit s -> do writeIORef _nowSeed (read s); writeIORef _nowSeeded True
            _ -> return ()
     else return ()
    seeded2 <- readIORef _nowSeeded
    if seeded2 then do
        modifyIORef' _nowSeed (\x -> (x * 1664525 + 1013904223) `mod` 2147483647)
        readIORef _nowSeed
    else do
        t <- getPOSIXTime
        return (floor (t * 1000000000))
_mem :: IO Int
_mem = fmap (fromIntegral . max_mem_in_use_bytes) getRTSStats
newPile d = do
    b <- newIORef ([])
    y <- newIORef (0)
    (let {
        loop = do
            if (deref y) < d then do
                row <- newIORef ([])
                x <- newIORef (0)
                let
                    loop = do
                        if (deref x) < d then do
                            writeIORef row $! ((deref row) ++ [0])
                            writeIORef x $! ((deref x) + 1)
                            loop
                        else return ()
                loop
                writeIORef b $! ((deref b) ++ [(deref row)])
                writeIORef y $! ((deref y) + 1)
                loop
            else return ((deref b))
    } in loop)


handlePile pile x y = do
    if (((deref pile) !! y) !! x) >= 4 then do
        writeIORef pile $! (take y (deref pile) ++ [take x (((deref pile) !! y)) ++ [(((deref pile) !! y) !! x) - 4] ++ drop (x + 1) (((deref pile) !! y))] ++ drop (y + 1) (deref pile))
        if y > 0 then do
            writeIORef pile $! (take (y - 1) (deref pile) ++ [take x (((deref pile) !! y - 1)) ++ [(((deref pile) !! y - 1) !! x) + 1] ++ drop (x + 1) (((deref pile) !! y - 1))] ++ drop (y - 1 + 1) (deref pile))
            if (((deref pile) !! y - 1) !! x) >= 4 then do
                writeIORef pile $! (handlePile (deref pile) x (y - 1))
            else return ()

        else return ()

        if x > 0 then do
            writeIORef pile $! (take y (deref pile) ++ [take (x - 1) (((deref pile) !! y)) ++ [(((deref pile) !! y) !! x - 1) + 1] ++ drop (x - 1 + 1) (((deref pile) !! y))] ++ drop (y + 1) (deref pile))
            if (((deref pile) !! y) !! x - 1) >= 4 then do
                writeIORef pile $! (handlePile (deref pile) (x - 1) y)
            else return ()

        else return ()

        if y < dim - 1 then do
            writeIORef pile $! (take (y + 1) (deref pile) ++ [take x (((deref pile) !! y + 1)) ++ [(((deref pile) !! y + 1) !! x) + 1] ++ drop (x + 1) (((deref pile) !! y + 1))] ++ drop (y + 1 + 1) (deref pile))
            if (((deref pile) !! y + 1) !! x) >= 4 then do
                writeIORef pile $! (handlePile (deref pile) x (y + 1))
            else return ()

        else return ()

        if x < dim - 1 then do
            writeIORef pile $! (take y (deref pile) ++ [take (x + 1) (((deref pile) !! y)) ++ [(((deref pile) !! y) !! x + 1) + 1] ++ drop (x + 1 + 1) (((deref pile) !! y))] ++ drop (y + 1) (deref pile))
            if (((deref pile) !! y) !! x + 1) >= 4 then do
                writeIORef pile $! (handlePile (deref pile) (x + 1) y)
            else return ()

        else return ()

        writeIORef pile $! (handlePile (deref pile) x y)
    else return ()

    return ((deref pile))


drawPile pile d = do
    let chars = [" ", "░", "▓", "█"]
    row <- newIORef (0)
    let
        loop = do
            if (deref row) < d then do
                line <- newIORef ("")
                col <- newIORef (0)
                let
                    loop = do
                        if (deref col) < d then do
                            v <- newIORef (((pile !! (deref row)) !! (deref col)))
                            if (deref v) > 3 then do
                                writeIORef v $! (3)
                            else return ()

                            writeIORef line $! ((deref line) ++ (chars !! (deref v)))
                            writeIORef col $! ((deref col) + 1)
                            loop
                        else return ()
                loop
                putStrLn ((deref line))
                writeIORef row $! ((deref row) + 1)
                loop
            else return ()
    loop


mainEntry = do
    pile <- newIORef (newPile 16)
    let hdim = 7
    writeIORef pile $! (take hdim (deref pile) ++ [take hdim (((deref pile) !! hdim)) ++ [16] ++ drop (hdim + 1) (((deref pile) !! hdim))] ++ drop (hdim + 1) (deref pile))
    writeIORef pile $! (handlePile (deref pile) hdim hdim)
    drawPile (deref pile) 16


main = do
    do
        start <- _now
        mainEntry
        end <- _now
        memEnd <- _mem
        let benchData = Aeson.object ["duration_us" Aeson..= ((end - start) `div` 1000), "memory_bytes" Aeson..= memEnd, "name" Aeson..= ("main" :: String)]
        BSL.putStrLn (Pretty.encodePretty' Pretty.defConfig{Pretty.confIndent = Pretty.Spaces 2} benchData)



dim = 16

