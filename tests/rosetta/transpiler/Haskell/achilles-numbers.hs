{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
{-# LANGUAGE OverloadedStrings #-}
-- Generated by Mochi transpiler v0.10.41 on 2025-07-26 17:25 GMT+7
import Data.List (intercalate, isInfixOf, union, intersect, nub, sortOn, (\\))
import qualified Data.Map as Map
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Encode.Pretty as Pretty
import qualified Data.ByteString.Lazy.Char8 as BSL
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.Environment (lookupEnv)
import Data.Time.Clock.POSIX (getPOSIXTime)
import Data.Char (isDigit)
import GHC.Stats (getRTSStats, max_mem_in_use_bytes)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
int :: String -> Int
int = read
float :: Int -> Double
float n = fromIntegral n
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
_nowSeed :: IORef Int
_nowSeed = unsafePerformIO (newIORef 0)
{-# NOINLINE _nowSeed #-}
_nowSeeded :: IORef Bool
_nowSeeded = unsafePerformIO (newIORef False)
{-# NOINLINE _nowSeeded #-}
_now :: IO Int
_now = do
    seeded <- readIORef _nowSeeded
    if not seeded then do
        m <- lookupEnv "MOCHI_NOW_SEED"
        case m of
            Just s | all isDigit s -> do writeIORef _nowSeed (read s); writeIORef _nowSeeded True
            _ -> return ()
     else return ()
    seeded2 <- readIORef _nowSeeded
    if seeded2 then do
        modifyIORef' _nowSeed (\x -> (x * 1664525 + 1013904223) `mod` 2147483647)
        readIORef _nowSeed
    else do
        t <- getPOSIXTime
        return (floor (t * 1000000000))
_mem :: IO Int
_mem = fmap (fromIntegral . max_mem_in_use_bytes) getRTSStats
pow10 exp = do
    n <- newIORef (1)
    i <- newIORef (0)
    (let {
        loop = do
            if (deref i) < exp then do
                writeIORef n $! ((deref n) * 10)
                writeIORef i $! ((deref i) + 1)
                loop
            else return ((deref n))
    } in loop)


totient n = do
    tot <- newIORef (n)
    nn <- newIORef (n)
    i <- newIORef (2)
    let
        loop = do
            if (deref i) * (deref i) <= (deref nn) then do
                if (deref nn) `mod` fromIntegral (deref i) == 0 then do
                    let
                        loop = do
                            if (deref nn) `mod` fromIntegral (deref i) == 0 then do
                                writeIORef nn $! ((deref nn) / fromIntegral (deref i))
                                loop
                            else return ()
                    loop
                    writeIORef tot $! ((deref tot) - (deref tot) / fromIntegral (deref i))
                else return ()

                if (deref i) == 2 then do
                    writeIORef i $! (1)
                else return ()

                writeIORef i $! ((deref i) + 2)
                loop
            else return ()
    loop
    if (deref nn) > fromIntegral 1 then do
        writeIORef tot $! ((deref tot) - (deref tot) / (deref nn))
    else return ()

    return ((deref tot))


getPerfectPowers maxExp = do
    let upper = pow10 maxExp
    i <- newIORef (2)
    let
        loop = do
            if (deref i) * (deref i) < upper then do
                p <- newIORef ((deref i))
                let
                    loop = do
                        if True then do
                            writeIORef p $! ((deref p) * (deref i))
                            if (deref p) >= upper then do
                                return ()
                            else return ()

                            writeIORef pps $! (Map.insert (deref p) (True) (deref pps))
                            loop
                        else return ()
                loop
                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop


getAchilles minExp maxExp = do
    let lower = pow10 minExp
    let upper = pow10 maxExp
    achilles <- newIORef (Map.fromList [])
    b <- newIORef (1)
    (let {
        loop = do
            if (deref b) * (deref b) * (deref b) < upper then do
                let b3 = (deref b) * (deref b) * (deref b)
                a <- newIORef (1)
                let
                    loop = do
                        if True then do
                            let p = b3 * (deref a) * (deref a)
                            if p >= upper then do
                                return ()
                            else return ()

                            if p >= lower then do
                                if not ((p `Map.member` (deref pps))) then do
                                    writeIORef achilles $! (Map.insert p (True) (deref achilles))
                                else return ()

                            else return ()

                            writeIORef a $! ((deref a) + 1)
                            loop
                        else return ()
                loop
                writeIORef b $! ((deref b) + 1)
                loop
            else return ((deref achilles))
    } in loop)


sortInts xs = do
    res <- newIORef ([])
    tmp <- newIORef (xs)
    (let {
        loop = do
            if length (deref tmp) > 0 then do
                min <- newIORef (((deref tmp) !! 0))
                idx <- newIORef (0)
                i <- newIORef (1)
                let
                    loop = do
                        if (deref i) < length (deref tmp) then do
                            if ((deref tmp) !! (deref i)) < (deref min) then do
                                writeIORef min $! (((deref tmp) !! (deref i)))
                                writeIORef idx $! ((deref i))
                            else return ()

                            writeIORef i $! ((deref i) + 1)
                            loop
                        else return ()
                loop
                writeIORef res $! ((deref res) ++ [(deref min)])
                out <- newIORef ([])
                j <- newIORef (0)
                let
                    loop = do
                        if (deref j) < length (deref tmp) then do
                            if (deref j) /= (deref idx) then do
                                writeIORef out $! ((deref out) ++ [((deref tmp) !! (deref j))])
                            else return ()

                            writeIORef j $! ((deref j) + 1)
                            loop
                        else return ()
                loop
                writeIORef tmp $! ((deref out))
                loop
            else return ((deref res))
    } in loop)


pad n width = do
    s <- newIORef (show n)
    (let {
        loop = do
            if length (deref s) < width then do
                writeIORef s $! (" " ++ (deref s))
                loop
            else return ((deref s))
    } in loop)


mainEntry = do
    let maxDigits = 15
    getPerfectPowers 5
    let achSet = getAchilles 1 5
    ach <- newIORef ([])
    mapM_ (\k -> do
        writeIORef ach $! ((deref ach) ++ [k])
        ) achSet.keys
    writeIORef ach $! (sortInts (deref ach))
    putStrLn ("First 50 Achilles numbers:")
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < 50 then do
                line <- newIORef ("")
                j <- newIORef (0)
                let
                    loop = do
                        if (deref j) < 10 then do
                            writeIORef line $! ((deref line) ++ pad (((deref ach) !! (deref i))) 4)
                            if (deref j) < 9 then do
                                writeIORef line $! ((deref line) ++ " ")
                            else return ()

                            writeIORef i $! ((deref i) + 1)
                            writeIORef j $! ((deref j) + 1)
                            loop
                        else return ()
                loop
                putStrLn ((deref line))
                loop
            else return ()
    loop
    putStrLn ("\nFirst 30 strong Achilles numbers:")
    strong <- newIORef ([])
    count <- newIORef (0)
    idx <- newIORef (0)
    let
        loop = do
            if (deref count) < 30 then do
                let tot = totient (((deref ach) !! (deref idx)))
                if tot `elem` achSet then do
                    writeIORef strong $! ((deref strong) ++ [((deref ach) !! (deref idx))])
                    writeIORef count $! ((deref count) + 1)
                else return ()

                writeIORef idx $! ((deref idx) + 1)
                loop
            else return ()
    loop
    writeIORef i $! (0)
    let
        loop = do
            if (deref i) < 30 then do
                line <- newIORef ("")
                j <- newIORef (0)
                let
                    loop = do
                        if (deref j) < 10 then do
                            writeIORef line $! ((deref line) ++ pad (((deref strong) !! (deref i))) 5)
                            if (deref j) < 9 then do
                                writeIORef line $! ((deref line) ++ " ")
                            else return ()

                            writeIORef i $! ((deref i) + 1)
                            writeIORef j $! ((deref j) + 1)
                            loop
                        else return ()
                loop
                putStrLn ((deref line))
                loop
            else return ()
    loop
    putStrLn ("\nNumber of Achilles numbers with:")
    let counts = [1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383]
    d <- newIORef (2)
    let
        loop = do
            if (deref d) <= maxDigits then do
                let c = (counts !! (deref d) - 2)
                putStrLn (pad (deref d) 2 ++ " digits: " ++ show c)
                writeIORef d $! ((deref d) + 1)
                loop
            else return ()
    loop


main = do
    do
        start <- _now
        mainEntry
        end <- _now
        memEnd <- _mem
        let benchData = Aeson.object ["duration_us" Aeson..= ((end - start) `div` 1000), "memory_bytes" Aeson..= memEnd, "name" Aeson..= ("main" :: String)]
        BSL.putStrLn (Pretty.encodePretty' Pretty.defConfig{Pretty.confIndent = Pretty.Spaces 2} benchData)



pps = unsafePerformIO (newIORef (Map.fromList []))
{-# NOINLINE pps #-}
