{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (base, groupFilter, host, port)
-- Generated by Mochi transpiler v0.10.42 on 2025-07-27 22:05 GMT+7
import qualified Data.Map as Map
import Text.Printf (printf)
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.Environment (lookupEnv)
import Data.Time.Clock.POSIX (getPOSIXTime)
import Data.Char (isDigit)
import GHC.Stats (getRTSStats, max_mem_in_use_bytes)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
int :: String -> Int
int = read
float :: Int -> Double
float n = fromIntegral n
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
_nowSeed :: IORef Int
_nowSeed = unsafePerformIO (newIORef 0)
{-# NOINLINE _nowSeed #-}
_nowSeeded :: IORef Bool
_nowSeeded = unsafePerformIO (newIORef False)
{-# NOINLINE _nowSeeded #-}
_now :: IO Int
_now = do
    seeded <- readIORef _nowSeeded
    if not seeded then do
        m <- lookupEnv "MOCHI_NOW_SEED"
        case m of
            Just s | all isDigit s -> do writeIORef _nowSeed (read s); writeIORef _nowSeeded True
            _ -> return ()
     else return ()
    seeded2 <- readIORef _nowSeeded
    if seeded2 then do
        modifyIORef' _nowSeed (\x -> (x * 1664525 + 1013904223) `mod` 2147483647)
        readIORef _nowSeed
    else do
        t <- getPOSIXTime
        return (floor (t * 1000000000))
_mem :: IO Int
_mem = fmap (fromIntegral . max_mem_in_use_bytes) getRTSStats
data GenType1 = GenType1
  { base :: String,
    host :: String,
    port :: Int,
    groupFilter :: String
  } deriving (Show, Eq)


search_user directory username = (directory Map.! username)

mainEntry = do
    let client = GenType1 {base = "dc=example,dc=com", host = "ldap.example.com", port = 389, groupFilter = "(memberUid=%s)"}
    let directory = Map.fromList [("username", ["admins", "users"]), ("john", ["users"])]
    let groups = search_user directory "username"
    if length groups > 0 then do
        out <- newIORef ("Groups: [")
        i <- newIORef (0 :: Int)
        let
            loop = do
                if (deref i) < length groups then do
                    writeIORef out $! ((deref out) ++ "\"" ++ (groups !! (deref i)) ++ "\"")
                    if (deref i) < length groups - 1 then do
                        writeIORef out $! ((deref out) ++ ", ")
                    else return ()

                    writeIORef i $! ((deref i) + 1)
                    loop
                else return ()
        loop
        writeIORef out $! ((deref out) ++ "]")
        putStrLn ((deref out))
    else do
        putStrLn ("User not found")



main = do
    do
        start <- _now
        mainEntry
        end <- _now
        memEnd <- _mem
        printf "{\"duration_us\":%d,\"memory_bytes\":%d,\"name\":\"main\"}\n" ((end - start) `div` 1000) memEnd



