{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
-- Generated by Mochi transpiler v0.10.39 on 2025-07-24 14:25 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.Environment (lookupEnv)
import Data.Time.Clock.POSIX (getPOSIXTime)
import Data.Char (isDigit)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
int :: String -> Int
int = read
float :: Int -> Double
float n = fromIntegral n
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
_nowSeed :: IORef Int
_nowSeed = unsafePerformIO (newIORef 0)
{-# NOINLINE _nowSeed #-}
_nowSeeded :: IORef Bool
_nowSeeded = unsafePerformIO (newIORef False)
{-# NOINLINE _nowSeeded #-}
_now :: IO Int
_now = do
    seeded <- readIORef _nowSeeded
    if not seeded then do
        m <- lookupEnv "MOCHI_NOW_SEED"
        case m of
            Just s | all isDigit s -> do writeIORef _nowSeed (read s); writeIORef _nowSeeded True
            _ -> return ()
     else return ()
    seeded2 <- readIORef _nowSeeded
    if seeded2 then do
        modifyIORef' _nowSeed (\x -> (x * 1664525 + 1013904223) `mod` 2147483647)
        readIORef _nowSeed
    else do
        t <- getPOSIXTime
        return (floor (t * 1000000000))
randDigit = (unsafePerformIO (_now) `mod` 9) + 1

main = do
    digits <- newIORef ([])
    mapM_ (\i -> do
        writeIORef digits $! ((deref digits) ++ [randDigit])
        ) [0 .. (4 - 1)]
    numstr <- newIORef ("")
    mapM_ (\i -> do
        writeIORef numstr $! ((deref numstr) ++ show (((deref digits) !! i)))
        ) [0 .. (4 - 1)]
    putStrLn ("Your numbers: " ++ (deref numstr) ++ "\n")
    putStrLn ("Enter RPN: ")
    expr <- input
    if length expr /= 7 then do
        putStrLn ("invalid. expression length must be 7. (4 numbers, 3 operators, no spaces)")
        return ()
    else do
        stack <- newIORef ([])
        i <- newIORef (0)
        valid <- newIORef (True)
        let
            loop = do
                if (deref i) < length expr then do
                    let ch = take ((deref i) + 1 - (deref i)) (drop (deref i) expr)
                    if ch >= "0" && ch <= "9" then do
                        if length (deref digits) == 0 then do
                            putStrLn ("too many numbers.")
                            return ()
                        else do
                            j <- newIORef (0)
                            let
                                loop = do
                                    if ((deref digits) !! (deref j)) /= int ch - int "0" then do
                                        writeIORef j $! ((deref j) + 1)
                                        if (deref j) == length (deref digits) then do
                                            putStrLn ("wrong numbers.")
                                            return ()
                                        else return ()

                                        loop
                                    else return ()
                            loop
                            writeIORef digits $! (take ((deref j) - 0) (drop 0 (deref digits)) ++ take (length (deref digits) - (deref j) + 1) (drop ((deref j) + 1) (deref digits)))
                            writeIORef stack $! ((deref stack) ++ [float (int ch - int "0")])

                    else do
                        if length (deref stack) < 2 then do
                            putStrLn ("invalid expression syntax.")
                            writeIORef valid $! (False)
                            return ()
                        else return ()

                        let b = ((deref stack) !! length (deref stack) - 1)
                        let a = ((deref stack) !! length (deref stack) - 2)
                        if ch == "+" then do
                            writeIORef stack $! (take (length (deref stack) - 2) (deref stack) ++ [a + b] ++ drop (length (deref stack) - 2 + 1) (deref stack))
                        else do
                            if ch == "-" then do
                                writeIORef stack $! (take (length (deref stack) - 2) (deref stack) ++ [a - b] ++ drop (length (deref stack) - 2 + 1) (deref stack))
                            else do
                                if ch == "*" then do
                                    writeIORef stack $! (take (length (deref stack) - 2) (deref stack) ++ [a * b] ++ drop (length (deref stack) - 2 + 1) (deref stack))
                                else do
                                    if ch == "/" then do
                                        writeIORef stack $! (take (length (deref stack) - 2) (deref stack) ++ [a / b] ++ drop (length (deref stack) - 2 + 1) (deref stack))
                                    else do
                                        putStrLn (ch ++ " invalid.")
                                        writeIORef valid $! (False)
                                        return ()




                        writeIORef stack $! (take (length (deref stack) - 1 - 0) (drop 0 (deref stack)))

                    writeIORef i $! ((deref i) + 1)
                    loop
                else return ()
        loop
        if (deref valid) then do
            if abs (((deref stack) !! 0) - 24) > 1e-06 then do
                putStrLn ("incorrect. " ++ show (((deref stack) !! 0)) ++ " != 24")
            else do
                putStrLn ("correct.")

        else return ()




