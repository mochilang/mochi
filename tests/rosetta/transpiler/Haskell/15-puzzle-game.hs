{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (idx, ok)
-- Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:18 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
data GenType2 = GenType2
  { idx :: Int,
    ok :: Double
  } deriving (Show, Eq)


data GenType3 = GenType3
  { idx :: Int,
    ok :: String
  } deriving (Show, Eq)


data GenType4 = GenType4
  { idx :: Int,
    ok :: String
  } deriving (Show, Eq)


data GenType5 = GenType5
  { idx :: Int,
    ok :: Bool
  } deriving (Show, Eq)


data GenType1 = GenType1
  { idx :: Int,
    ok :: Double
  } deriving (Show, Eq)


randMove = now `mod` 4

isSolved = do
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < 16 then do
                if ((deref board) !! (deref i)) != (solved !! (deref i)) then do
                    return (False)
                else return ()

                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop
    return (True)


isValidMove m = do
    if (deref m) == 0 then do
        return (GenType1 {idx = (deref empty) - 4, ok = fromIntegral (deref empty) / fromIntegral 4 > 0})
    else return ()

    if (deref m) == 1 then do
        return (GenType2 {idx = (deref empty) + 4, ok = fromIntegral (deref empty) / fromIntegral 4 < 3})
    else return ()

    if (deref m) == 2 then do
        return (GenType3 {idx = (deref empty) + 1, ok = (deref empty) `mod` 4 < 3})
    else return ()

    if (deref m) == 3 then do
        return (GenType4 {idx = (deref empty) - 1, ok = (deref empty) `mod` 4 > 0})
    else return ()

    return (GenType5 {idx = 0, ok = False})


doMove m = do
    r = isValidMove (deref m)
    if not ((r !! "ok")) then do
        return (False)
    else return ()

    i <- newIORef ((deref empty))
    j = int ((r !! "idx"))
    tmp = ((deref board) !! (deref i))
    writeIORef board $! (take (deref i) (deref board) ++ [((deref board) !! j)] ++ drop ((deref i) + 1) (deref board))
    writeIORef board $! (take j (deref board) ++ [tmp] ++ drop (j + 1) (deref board))
    writeIORef empty $! (j)
    writeIORef moves $! ((deref moves) + 1)
    return (True)


shuffle n = do
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < n || isSolved then do
                if doMove (randMove) then do
                    writeIORef i $! ((deref i) + 1)
                else return ()

                loop
            else return ()
    loop


printBoard = do
    line <- newIORef ("")
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < 16 then do
                val = ((deref board) !! (deref i))
                if val == 0 then do
                    writeIORef line $! ((deref line) ++ "  .")
                else do
                    s = show val
                    if val < 10 then do
                        writeIORef line $! ((deref line) ++ "  " ++ s)
                    else do
                        writeIORef line $! ((deref line) ++ " " ++ s)


                if (deref i) `mod` 4 == 3 then do
                    putStrLn ((deref line))
                    writeIORef line $! ("")
                else return ()

                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop


playOneMove = do
    let
        loop = do
            if True then do
                putStrLn ("Enter move #" ++ show ((deref moves) + 1) ++ " (U, D, L, R, or Q): ")
                s = input
                if s == "" then do
                     xs
                else return ()

                c = take (1 - 0) (drop 0 s)
                m <- newIORef (0)
                if c == "U" || c == "u" then do
                    writeIORef m $! (0)
                else do
                    if c == "D" || c == "d" then do
                        writeIORef m $! (1)
                    else do
                        if c == "R" || c == "r" then do
                            writeIORef m $! (2)
                        else do
                            if c == "L" || c == "l" then do
                                writeIORef m $! (3)
                            else do
                                if c == "Q" || c == "q" then do
                                    putStrLn ("Quiting after " ++ show (deref moves) ++ " moves.")
                                    writeIORef quit $! (True)
                                    return (0)
                                else do
                                    putStrLn ("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" ++ "up, down, left, or right. You can also enter \"Q\" to quit.\n" ++ "Upper or lowercase is accepted and only the first non-blank\n" ++ "character is important (i.e. you may enter \"up\" if you like).")
                                     xs





                if not (doMove (deref m)) then do
                    putStrLn ("That is not a valid move at the moment.")
                     xs
                else return ()

                return (0)
                loop
            else return ()
    loop


play = do
    putStrLn ("Starting board:")
    let
        loop = do
            if not (deref quit) && isSolved == False then do
                putStrLn ("")
                printBoard
                playOneMove
                loop
            else return ()
    loop
    if isSolved then do
        putStrLn ("You solved the puzzle in " ++ show (deref moves) ++ " moves.")
    else return ()



main = do
    shuffle 50
    play


solved = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

main :: IO ()
main = do
    board <- newIORef ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0])
    empty <- newIORef (15)
    moves <- newIORef (0)
    quit <- newIORef (False)
    main
