{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NoFieldSelectors #-}
import Prelude hiding (idx, ok)
-- Generated by Mochi transpiler v0.10.38 on 2025-07-24 00:10 GMT+7
import Data.IORef
import System.IO.Unsafe (unsafePerformIO)
import System.Environment (lookupEnv)
import Data.Time.Clock.POSIX (getPOSIXTime)
import Data.Char (isDigit)
import System.IO (isEOF)
input :: IO String
input = do
    eof <- isEOF
    if eof then return "" else getLine
deref :: IORef a -> a
{-# NOINLINE deref #-}
deref r = unsafePerformIO (atomicModifyIORef' r (\x -> (x, x)))
_nowSeed :: IORef Int
_nowSeed = unsafePerformIO (newIORef 0)
{-# NOINLINE _nowSeed #-}
_nowSeeded :: IORef Bool
_nowSeeded = unsafePerformIO (newIORef False)
{-# NOINLINE _nowSeeded #-}
_now :: IO Int
_now = do
    seeded <- readIORef _nowSeeded
    if not seeded then do
        m <- lookupEnv "MOCHI_NOW_SEED"
        case m of
            Just s | all isDigit s -> do writeIORef _nowSeed (read s); writeIORef _nowSeeded True
            _ -> return ()
     else return ()
    seeded2 <- readIORef _nowSeeded
    if seeded2 then do
        modifyIORef' _nowSeed (\x -> (x * 1664525 + 1013904223) `mod` 2147483647)
        readIORef _nowSeed
    else do
        t <- getPOSIXTime
        return (floor (t * 1000000000))
data MoveResult = MoveResult
  { idx :: Int,
    ok :: Bool
  } deriving (Show, Eq)


randMove = unsafePerformIO (_now) `mod` 4

isSolved = do
    i <- newIORef (0)
    return ((let
        loop = do
            if (deref i) < 16 then do
                writeIORef i $! ((deref i) + 1)
                loop
            else return (True)
    loop))


isValidMove m = do
    if m == 0 then do
        return (MoveResult {idx = (deref empty) - 4, ok = fromIntegral (deref empty) / fromIntegral 4 > 0})
    else do
        if m == 1 then do
            return (MoveResult {idx = (deref empty) + 4, ok = fromIntegral (deref empty) / fromIntegral 4 < 3})
        else do
            if m == 2 then do
                return (MoveResult {idx = (deref empty) + 1, ok = (deref empty) `mod` 4 < 3})
            else do
                if m == 3 then do
                    return (MoveResult {idx = (deref empty) - 1, ok = (deref empty) `mod` 4 > 0})
                else do
                    return (MoveResult {idx = 0, ok = False})






doMove m = do
    let r = isValidMove m
    if not (r.ok) then do
        return (False)
    else do
        let i = (deref empty)
        let j = r.idx
        let tmp = ((deref board) !! i)
        writeIORef board $! (take i (deref board) ++ [((deref board) !! j)] ++ drop (i + 1) (deref board))
        writeIORef board $! (take j (deref board) ++ [tmp] ++ drop (j + 1) (deref board))
        writeIORef empty $! (j)
        writeIORef moves $! ((deref moves) + 1)
        return (True)



shuffle n = do
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < n || unsafePerformIO (isSolved) then do
                if unsafePerformIO (doMove (unsafePerformIO (newIORef (randMove)))) then do
                    writeIORef i $! ((deref i) + 1)
                else return ()

                loop
            else return ()
    loop


printBoard = do
    line <- newIORef ("")
    i <- newIORef (0)
    let
        loop = do
            if (deref i) < 16 then do
                let val = ((deref board) !! (deref i))
                if val == 0 then do
                    writeIORef line $! ((deref line) ++ "  .")
                else do
                    let s = show val
                    if val < 10 then do
                        writeIORef line $! ((deref line) ++ "  " ++ s)
                    else do
                        writeIORef line $! ((deref line) ++ " " ++ s)


                if (deref i) `mod` 4 == 3 then do
                    putStrLn ((deref line))
                    writeIORef line $! ("")
                else return ()

                writeIORef i $! ((deref i) + 1)
                loop
            else return ()
    loop


playOneMove = do
    let
        loop = do
            if True then do
                putStrLn ("Enter move #" ++ show ((deref moves) + 1) ++ " (U, D, L, R, or Q): ")
                s <- input
                if s == "" then do
                    loop
                else return ()

                let c = take (1 - 0) (drop 0 s)
                m <- newIORef (0)
                if c == "U" || c == "u" then do
                    writeIORef m $! (0)
                else do
                    if c == "D" || c == "d" then do
                        writeIORef m $! (1)
                    else do
                        if c == "R" || c == "r" then do
                            writeIORef m $! (2)
                        else do
                            if c == "L" || c == "l" then do
                                writeIORef m $! (3)
                            else do
                                if c == "Q" || c == "q" then do
                                    putStrLn ("Quiting after " ++ show (deref moves) ++ " moves.")
                                    writeIORef quit $! (True)
                                    return (0)
                                else do
                                    putStrLn ("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" ++ "up, down, left, or right. You can also enter \"Q\" to quit.\n" ++ "Upper or lowercase is accepted and only the first non-blank\n" ++ "character is important (i.e. you may enter \"up\" if you like).")
                                    loop





                if not (unsafePerformIO (doMove (unsafePerformIO (newIORef (deref m))))) then do
                    putStrLn ("That is not a valid move at the moment.")
                    loop
                else return ()

                return (0)
                loop
            else return ()
    loop


play = do
    putStrLn ("Starting board:")
    let
        loop = do
            if not (deref quit) && unsafePerformIO (isSolved) == False then do
                putStrLn ("")
                printBoard
                playOneMove
                loop
            else return ()
    loop
    if unsafePerformIO (isSolved) then do
        putStrLn ("You solved the puzzle in " ++ show (deref moves) ++ " moves.")
    else return ()



main = do
    shuffle 50
    play


solved = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

board = unsafePerformIO (newIORef ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]))
{-# NOINLINE board #-}
empty = unsafePerformIO (newIORef (15))
{-# NOINLINE empty #-}
moves = unsafePerformIO (newIORef (0))
{-# NOINLINE moves #-}
quit = unsafePerformIO (newIORef (False))
{-# NOINLINE quit #-}
