-- Generated by Mochi v0.10.40 on 2025-07-25 12:29 GMT+7
function input()
  return io.read('*l')
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _padStart(s, len, ch)
if ch == nil or ch == '' then ch = ' ' end
if #s >= len then return s end
local fill = string.sub(ch, 1, 1)
return string.rep(fill, len - #s) .. s
end

local function _gcd(a, b)
a = math.abs(a)
b = math.abs(b)
while b ~= 0 do
  a, b = b, a % b
end
return a
end
local function _bigrat(n, d)
if type(n) == 'table' and n.num ~= nil and n.den ~= nil and d == nil then
  return n
end
if d == nil then d = 1 end
if d < 0 then n, d = -n, -d end
local g = _gcd(n, d)
return {num = n // g, den = d // g}
end
local function _add(a, b)
return _bigrat(a.num * b.den + b.num * a.den, a.den * b.den)
end
local function _sub(a, b)
return _bigrat(a.num * b.den - b.num * a.den, a.den * b.den)
end
local function _mul(a, b)
return _bigrat(a.num * b.num, a.den * b.den)
end
local function _div(a, b)
return _bigrat(a.num * b.den, a.den * b.num)
end
function num(x)
  if type(x) == 'table' and x.num ~= nil then return x.num end
  return x
end
function denom(x)
  if type(x) == 'table' and x.den ~= nil then return x.den end
  return 1
end

local function _sha256(bs)
local tmp = os.tmpname()
local f = assert(io.open(tmp, 'wb'))
for i = 1, #bs do
  f:write(string.char(bs[i]))
end
f:close()
local p = io.popen('sha256sum ' .. tmp)
local out = p:read('*l') or ''
p:close()
os.remove(tmp)
local hex = string.sub(out, 1, 64)
local res = {}
for i = 1, #hex, 2 do
  res[#res+1] = tonumber(string.sub(hex, i, i+1), 16)
end
return res
end

local function _indexOf(s, ch)
for i = 1, #s do
  if string.sub(s, i, i) == ch then
    return i - 1
  end
end
return -1
end

local function _parseIntStr(str)
local n = tonumber(str, 10)
if n == nil then return 0 end
return math.floor(n)
end

local function slice(lst, s, e)
if s < 0 then s = #lst + s end
if e == nil then e = #lst end
local r = {}
for i = s + 1, e do
  r[#r+1] = lst[i]
end
return r
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = _now()
  board = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0}
  solved = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0}
  empty = 15
  moves = 0
  quit = false
  function randMove()
    return (_now() % 4)
  end
  function isSolved()
    local i = 0
    while (i < 16) do
      if (board[i + 1] ~= solved[i + 1]) then
        return false
      end
      i = (i + 1)
    end
    return true
  end
  function isValidMove(m)
    if (m == 0) then
      return {idx = (empty - 4), ok = ((empty // 4) > 0)}
    end
    if (m == 1) then
      return {idx = (empty + 4), ok = ((empty // 4) < 3)}
    end
    if (m == 2) then
      return {idx = (empty + 1), ok = ((empty % 4) < 3)}
    end
    if (m == 3) then
      return {idx = (empty - 1), ok = ((empty % 4) > 0)}
    end
    return {idx = 0, ok = false}
  end
  function doMove(m)
    local r = isValidMove(m)
    if (not r.ok) then
      return false
    end
    local i = empty
    local j = r.idx
    local tmp = board[i + 1]
    board[i + 1] = board[j + 1]
    board[j + 1] = tmp
    empty = j
    moves = (moves + 1)
    return true
  end
  function shuffle(n)
    local i = 0
    while ((i < n) or isSolved()) do
      if doMove(randMove()) then
        i = (i + 1)
      end
    end
  end
  function printBoard()
    local line = ""
    local i = 0
    while (i < 16) do
      local val = board[i + 1]
      if (val == 0) then
        line = (line .. "  .")
      else
        local s = tostring(val)
        if (val < 10) then
          line = ((line .. "  ") .. s)
        else
          line = ((line .. " ") .. s)
        end
      end
      if ((i % 4) == 3) then
        print(line)
        line = ""
      end
      i = (i + 1)
    end
  end
  function playOneMove()
    while true do
      ::__cont_1::
      print((("Enter move #" .. tostring((moves + 1))) .. " (U, D, L, R, or Q): "))
      local s = input()
      if (s == "") then
        goto __cont_1
      end
      local c = string.sub(s, (0 + 1), 1)
      local m = 0
      if ((c == "U") or (c == "u")) then
        m = 0
      else
        if ((c == "D") or (c == "d")) then
          m = 1
        else
          if ((c == "R") or (c == "r")) then
            m = 2
          else
            if ((c == "L") or (c == "l")) then
              m = 3
            else
              if ((c == "Q") or (c == "q")) then
                print((("Quiting after " .. tostring(moves)) .. " moves."))
                quit = true
                return
              else
                print(((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" .. "up, down, left, or right. You can also enter \"Q\" to quit.\n") .. "Upper or lowercase is accepted and only the first non-blank\n") .. "character is important (i.e. you may enter \"up\" if you like)."))
                goto __cont_1
              end
            end
          end
        end
      end
      if (not doMove(m)) then
        print("That is not a valid move at the moment.")
        goto __cont_1
      end
      return
    end
  end
  function play()
    print("Starting board:")
    while ((not quit) and (isSolved() == false)) do
      print("")
      printBoard()
      playOneMove()
    end
    if isSolved() then
      print((("You solved the puzzle in " .. tostring(moves)) .. " moves."))
    end
  end
  function main()
    shuffle(50)
    play()
  end
  main()
  local _bench_end = _now()
  collectgarbage()
  local _bench_end_mem = collectgarbage('count') * 1024
  local _bench_duration_us = math.floor((_bench_end - _bench_start) / 1000)
  local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
  print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
end;
