-- Generated by Mochi v0.10.40 on 2025-07-25 17:59 GMT+7
function input()
  return io.read('*l')
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = _now()
  function toUnsigned16(n)
    local u = n
    if (u < 0) then
      u = (u + 65536)
    end
    return (u % 65536)
  end
  function bin16(n)
    local u = toUnsigned16(n)
    local bits = ""
    local mask = 32768
    for i = 0, 16 - 1 do
      if (u >= mask) then
        bits = (bits .. "1")
        u = (u - mask)
      else
        bits = (bits .. "0")
      end
      mask = math.floor((mask // 2))
    end
    return bits
  end
  function bit_and(a, b)
    local ua = toUnsigned16(a)
    local ub = toUnsigned16(b)
    local res = 0
    local bit = 1
    for i = 0, 16 - 1 do
      if (((ua % 2) == 1) and ((ub % 2) == 1)) then
        res = (res + bit)
      end
      ua = math.floor((ua // 2))
      ub = math.floor((ub // 2))
      bit = (bit * 2)
    end
    return res
  end
  function bit_or(a, b)
    local ua = toUnsigned16(a)
    local ub = toUnsigned16(b)
    local res = 0
    local bit = 1
    for i = 0, 16 - 1 do
      if (((ua % 2) == 1) or ((ub % 2) == 1)) then
        res = (res + bit)
      end
      ua = math.floor((ua // 2))
      ub = math.floor((ub // 2))
      bit = (bit * 2)
    end
    return res
  end
  function bit_xor(a, b)
    local ua = toUnsigned16(a)
    local ub = toUnsigned16(b)
    local res = 0
    local bit = 1
    for i = 0, 16 - 1 do
      local abit = (ua % 2)
      local bbit = (ub % 2)
      if (((abit == 1) and (bbit == 0)) or ((abit == 0) and (bbit == 1))) then
        res = (res + bit)
      end
      ua = math.floor((ua // 2))
      ub = math.floor((ub // 2))
      bit = (bit * 2)
    end
    return res
  end
  function bit_not(a)
    local ua = toUnsigned16(a)
    return (65535 - ua)
  end
  function shl(a, b)
    local ua = toUnsigned16(a)
    local i = 0
    while (i < b) do
      ua = ((ua * 2) % 65536)
      i = (i + 1)
    end
    return ua
  end
  function shr(a, b)
    local ua = toUnsigned16(a)
    local i = 0
    while (i < b) do
      ua = math.floor((ua // 2))
      i = (i + 1)
    end
    return ua
  end
  function las(a, b)
    return shl(a, b)
  end
  function ras(a, b)
    local val = a
    local i = 0
    while (i < b) do
      if (val >= 0) then
        val = math.floor((val // 2))
      else
        val = math.floor(((val - 1) // 2))
      end
      i = (i + 1)
    end
    return toUnsigned16(val)
  end
  function rol(a, b)
    local ua = toUnsigned16(a)
    local left = shl(ua, b)
    local right = shr(ua, (16 - b))
    return toUnsigned16((left + right))
  end
  function ror(a, b)
    local ua = toUnsigned16(a)
    local right = shr(ua, b)
    local left = shl(ua, (16 - b))
    return toUnsigned16((left + right))
  end
  function bitwise(a, b)
    print(("a:   " .. bin16(a)))
    print(("b:   " .. bin16(b)))
    print(("and: " .. bin16(bit_and(a, b))))
    print(("or:  " .. bin16(bit_or(a, b))))
    print(("xor: " .. bin16(bit_xor(a, b))))
    print(("not: " .. bin16(bit_not(a))))
    if (b < 0) then
      print("Right operand is negative, but all shifts require an unsigned right operand (shift distance).")
      return _nil
    end
    print(("shl: " .. bin16(shl(a, b))))
    print(("shr: " .. bin16(shr(a, b))))
    print(("las: " .. bin16(las(a, b))))
    print(("ras: " .. bin16(ras(a, b))))
    print(("rol: " .. bin16(rol(a, b))))
    print(("ror: " .. bin16(ror(a, b))))
  end
  bitwise((-460), 6)
  local _bench_end = _now()
  collectgarbage()
  local _bench_end_mem = collectgarbage('count') * 1024
  local _bench_duration_us = math.floor((_bench_end - _bench_start) / 1000)
  local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
  print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
end;
