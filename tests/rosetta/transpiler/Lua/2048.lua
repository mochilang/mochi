-- Generated by Mochi v0.10.38 on 2025-07-24 00:44 GMT+7
function input()
  return io.read('*l')
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
  return _now_seed
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _padStart(s, len, ch)
if ch == nil or ch == '' then ch = ' ' end
if #s >= len then return s end
local fill = string.sub(ch, 1, 1)
return string.rep(fill, len - #s) .. s
end
SIZE = 4;

function newBoard()
  local b = {}
  local y = 0
  while (y < SIZE) do
    local row = {}
    local x = 0
    while (x < SIZE) do
      row = (function(lst, item)
      local res = {table.unpack(lst)}
      table.insert(res, item)
      return res
    end)(row, 0)
    x = (x + 1)
  end
  b = (function(lst, item)
  local res = {table.unpack(lst)}
  table.insert(res, item)
  return res
end)(b, row)
y = (y + 1)
end
return {cells = b}
end;

function spawnTile(b)
  local grid = b.cells
  local empty = {}
  local y = 0
  while (y < SIZE) do
    local x = 0
    while (x < SIZE) do
      if (grid[y + 1][x + 1] == 0) then
        empty = (function(lst, item)
        local res = {table.unpack(lst)}
        table.insert(res, item)
        return res
      end)(empty, {x, y})
    end
    x = (x + 1)
  end
  y = (y + 1)
end
if ((function(v)
if type(v) == 'table' and v.items ~= nil then
  return #v.items
elseif type(v) == 'table' and (v[1] == nil) then
    local c = 0
    for _ in pairs(v) do c = c + 1 end
    return c
  elseif type(v) == 'string' or type(v) == 'table' then
      return #v
    else
      return 0
    end
  end)(empty) == 0) then
    return {board = b, full = true}
  end
  local idx = (_now() % (function(v)
  if type(v) == 'table' and v.items ~= nil then
    return #v.items
  elseif type(v) == 'table' and (v[1] == nil) then
      local c = 0
      for _ in pairs(v) do c = c + 1 end
      return c
    elseif type(v) == 'string' or type(v) == 'table' then
        return #v
      else
        return 0
      end
    end)(empty))
    local cell = empty[idx + 1]
    local val = 4
    if ((_now() % 10) < 9) then
      val = 2
    end
    grid[cell[1 + 1] + 1][cell[0 + 1] + 1] = val
    return {board = {cells = grid}, full = ((function(v)
    if type(v) == 'table' and v.items ~= nil then
      return #v.items
    elseif type(v) == 'table' and (v[1] == nil) then
        local c = 0
        for _ in pairs(v) do c = c + 1 end
        return c
      elseif type(v) == 'string' or type(v) == 'table' then
          return #v
        else
          return 0
        end
      end)(empty) == 1)}
    end;
    
    function pad(n)
      local s = tostring(n)
      local pad = (4 - (function(v)
      if type(v) == 'table' and v.items ~= nil then
        return #v.items
      elseif type(v) == 'table' and (v[1] == nil) then
          local c = 0
          for _ in pairs(v) do c = c + 1 end
          return c
        elseif type(v) == 'string' or type(v) == 'table' then
            return #v
          else
            return 0
          end
        end)(s))
        local i = 0
        local out = ""
        while (i < pad) do
          out = (out .. " ")
          i = (i + 1)
        end
        return (out .. s)
      end;
      
      function draw(b, score)
        print(("Score: " .. tostring(score)))
        local y = 0
        while (y < SIZE) do
          print("+----+----+----+----+")
          local line = "|"
          local x = 0
          while (x < SIZE) do
            local v = b.cells[y + 1][x + 1]
            if (v == 0) then
              line = (line .. "    |")
            else
              line = ((line .. pad(v)) .. "|")
            end
            x = (x + 1)
          end
          print(line)
          y = (y + 1)
        end
        print("+----+----+----+----+")
        print("W=Up S=Down A=Left D=Right Q=Quit")
      end;
      
      function reverseRow(r)
        local out = {}
        local i = ((function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(r) - 1)
          while (i >= 0) do
            out = (function(lst, item)
            local res = {table.unpack(lst)}
            table.insert(res, item)
            return res
          end)(out, r[i + 1])
          i = (i - 1)
        end
        return out
      end;
      
      function slideLeft(row)
        local xs = {}
        local i = 0
        while (i < (function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(row)) do
            if (row[i + 1] ~= 0) then
              xs = (function(lst, item)
              local res = {table.unpack(lst)}
              table.insert(res, item)
              return res
            end)(xs, row[i + 1])
          end
          i = (i + 1)
        end
        local res = {}
        local gain = 0
        i = 0
        while (i < (function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(xs)) do
            if (((i + 1) < (function(v)
            if type(v) == 'table' and v.items ~= nil then
              return #v.items
            elseif type(v) == 'table' and (v[1] == nil) then
                local c = 0
                for _ in pairs(v) do c = c + 1 end
                return c
              elseif type(v) == 'string' or type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(xs)) and (xs[i + 1] == xs[(i + 1) + 1])) then
                local v = (xs[i + 1] * 2)
                gain = (gain + v)
                res = (function(lst, item)
                local res = {table.unpack(lst)}
                table.insert(res, item)
                return res
              end)(res, v)
              i = (i + 2)
            else
              res = (function(lst, item)
              local res = {table.unpack(lst)}
              table.insert(res, item)
              return res
            end)(res, xs[i + 1])
            i = (i + 1)
          end
        end
        while ((function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(res) < SIZE) do
            res = (function(lst, item)
            local res = {table.unpack(lst)}
            table.insert(res, item)
            return res
          end)(res, 0)
        end
        return {row = res, gain = gain}
      end;
      
      function moveLeft(b, score)
        local grid = b.cells
        local moved = false
        local y = 0
        while (y < SIZE) do
          local r = slideLeft(grid[y + 1])
          local new = r.row
          score = (score + r.gain)
          local x = 0
          while (x < SIZE) do
            if (grid[y + 1][x + 1] ~= new[x + 1]) then
              moved = true
            end
            grid[y + 1][x + 1] = new[x + 1]
            x = (x + 1)
          end
          y = (y + 1)
        end
        return {board = {cells = grid}, score = score, moved = moved}
      end;
      
      function moveRight(b, score)
        local grid = b.cells
        local moved = false
        local y = 0
        while (y < SIZE) do
          local rev = reverseRow(grid[y + 1])
          local r = slideLeft(rev)
          rev = r.row
          score = (score + r.gain)
          rev = reverseRow(rev)
          local x = 0
          while (x < SIZE) do
            if (grid[y + 1][x + 1] ~= rev[x + 1]) then
              moved = true
            end
            grid[y + 1][x + 1] = rev[x + 1]
            x = (x + 1)
          end
          y = (y + 1)
        end
        return {board = {cells = grid}, score = score, moved = moved}
      end;
      
      function getCol(b, x)
        local col = {}
        local y = 0
        while (y < SIZE) do
          col = (function(lst, item)
          local res = {table.unpack(lst)}
          table.insert(res, item)
          return res
        end)(col, b.cells[y + 1][x + 1])
        y = (y + 1)
      end
      return col
    end;
    
    function setCol(b, x, col)
      local rows = b.cells
      local y = 0
      while (y < SIZE) do
        local row = rows[y + 1]
        row[x + 1] = col[y + 1]
        rows[y + 1] = row
        y = (y + 1)
      end
      b.cells = rows
    end;
    
    function moveUp(b, score)
      local grid = b.cells
      local moved = false
      local x = 0
      while (x < SIZE) do
        local col = getCol((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(b), x)
        local r = slideLeft(col)
        local new = r.row
        score = (score + r.gain)
        local y = 0
        while (y < SIZE) do
          if (grid[y + 1][x + 1] ~= new[y + 1]) then
            moved = true
          end
          grid[y + 1][x + 1] = new[y + 1]
          y = (y + 1)
        end
        x = (x + 1)
      end
      return {board = {cells = grid}, score = score, moved = moved}
    end;
    
    function moveDown(b, score)
      local grid = b.cells
      local moved = false
      local x = 0
      while (x < SIZE) do
        local col = reverseRow(getCol((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(b), x))
        local r = slideLeft(col)
        col = r.row
        score = (score + r.gain)
        col = reverseRow(col)
        local y = 0
        while (y < SIZE) do
          if (grid[y + 1][x + 1] ~= col[y + 1]) then
            moved = true
          end
          grid[y + 1][x + 1] = col[y + 1]
          y = (y + 1)
        end
        x = (x + 1)
      end
      return {board = {cells = grid}, score = score, moved = moved}
    end;
    
    function hasMoves(b)
      local y = 0
      while (y < SIZE) do
        local x = 0
        while (x < SIZE) do
          if (b.cells[y + 1][x + 1] == 0) then
            return true
          end
          if (((x + 1) < SIZE) and (b.cells[y + 1][x + 1] == b.cells[y + 1][(x + 1) + 1])) then
            return true
          end
          if (((y + 1) < SIZE) and (b.cells[y + 1][x + 1] == b.cells[(y + 1) + 1][x + 1])) then
            return true
          end
          x = (x + 1)
        end
        y = (y + 1)
      end
      return false
    end;
    
    function has2048(b)
      local y = 0
      while (y < SIZE) do
        local x = 0
        while (x < SIZE) do
          if (b.cells[y + 1][x + 1] >= 2048) then
            return true
          end
          x = (x + 1)
        end
        y = (y + 1)
      end
      return false
    end;
    
    board = newBoard();
    
    r = spawnTile((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board));
    
    board = r.board;
    
    full = r.full;
    
    r = spawnTile((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board));
    
    board = r.board;
    
    full = r.full;
    
    score = 0;
    
    draw((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board), score);
    
    while true do
      print("Move: ")
      cmd = input()
      moved = false
      if ((cmd == "a") or (cmd == "A")) then
        m = moveLeft((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board), score)
        board = m.board
        score = m.score
        moved = m.moved
      end
      if ((cmd == "d") or (cmd == "D")) then
        m = moveRight((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board), score)
        board = m.board
        score = m.score
        moved = m.moved
      end
      if ((cmd == "w") or (cmd == "W")) then
        m = moveUp((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board), score)
        board = m.board
        score = m.score
        moved = m.moved
      end
      if ((cmd == "s") or (cmd == "S")) then
        m = moveDown((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board), score)
        board = m.board
        score = m.score
        moved = m.moved
      end
      if ((cmd == "q") or (cmd == "Q")) then
        break
      end
      if moved then
        r2 = spawnTile((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board))
        board = r2.board
        full = r2.full
        if (full and (not hasMoves((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board)))) then
          draw((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board), score)
          print("Game Over")
          break
        end
      end
      draw((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board), score)
      if has2048((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board)) then
        print("You win!")
        break
      end
      if (not hasMoves((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(board))) then
        print("Game Over")
        break
      end
    end;
