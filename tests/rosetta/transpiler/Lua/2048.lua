-- Generated by Mochi v0.10.40 on 2025-07-25 12:29 GMT+7
function input()
  return io.read('*l')
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _padStart(s, len, ch)
if ch == nil or ch == '' then ch = ' ' end
if #s >= len then return s end
local fill = string.sub(ch, 1, 1)
return string.rep(fill, len - #s) .. s
end

local function _gcd(a, b)
a = math.abs(a)
b = math.abs(b)
while b ~= 0 do
  a, b = b, a % b
end
return a
end
local function _bigrat(n, d)
if type(n) == 'table' and n.num ~= nil and n.den ~= nil and d == nil then
  return n
end
if d == nil then d = 1 end
if d < 0 then n, d = -n, -d end
local g = _gcd(n, d)
return {num = n // g, den = d // g}
end
local function _add(a, b)
return _bigrat(a.num * b.den + b.num * a.den, a.den * b.den)
end
local function _sub(a, b)
return _bigrat(a.num * b.den - b.num * a.den, a.den * b.den)
end
local function _mul(a, b)
return _bigrat(a.num * b.num, a.den * b.den)
end
local function _div(a, b)
return _bigrat(a.num * b.den, a.den * b.num)
end
function num(x)
  if type(x) == 'table' and x.num ~= nil then return x.num end
  return x
end
function denom(x)
  if type(x) == 'table' and x.den ~= nil then return x.den end
  return 1
end

local function _sha256(bs)
local tmp = os.tmpname()
local f = assert(io.open(tmp, 'wb'))
for i = 1, #bs do
  f:write(string.char(bs[i]))
end
f:close()
local p = io.popen('sha256sum ' .. tmp)
local out = p:read('*l') or ''
p:close()
os.remove(tmp)
local hex = string.sub(out, 1, 64)
local res = {}
for i = 1, #hex, 2 do
  res[#res+1] = tonumber(string.sub(hex, i, i+1), 16)
end
return res
end

local function _indexOf(s, ch)
for i = 1, #s do
  if string.sub(s, i, i) == ch then
    return i - 1
  end
end
return -1
end

local function _parseIntStr(str)
local n = tonumber(str, 10)
if n == nil then return 0 end
return math.floor(n)
end

local function slice(lst, s, e)
if s < 0 then s = #lst + s end
if e == nil then e = #lst end
local r = {}
for i = s + 1, e do
  r[#r+1] = lst[i]
end
return r
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = _now()
  SIZE = 4
  function newBoard()
    local b = {}
    local y = 0
    while (y < SIZE) do
      local row = {}
      local x = 0
      while (x < SIZE) do
        row = (function(lst, item)
        local res = {table.unpack(lst)}
        table.insert(res, item)
        return res
      end)(row, 0)
      x = (x + 1)
    end
    b = (function(lst, item)
    local res = {table.unpack(lst)}
    table.insert(res, item)
    return res
  end)(b, row)
  y = (y + 1)
end
return {cells = b}
end
function spawnTile(b)
  local grid = b.cells
  local empty = {}
  local y = 0
  while (y < SIZE) do
    local x = 0
    while (x < SIZE) do
      if (grid[y + 1][x + 1] == 0) then
        empty = (function(lst, item)
        local res = {table.unpack(lst)}
        table.insert(res, item)
        return res
      end)(empty, {x, y})
    end
    x = (x + 1)
  end
  y = (y + 1)
end
if ((function(v)
if type(v) == 'table' and v.items ~= nil then
  return #v.items
elseif type(v) == 'table' and (v[1] == nil) then
    local c = 0
    for _ in pairs(v) do c = c + 1 end
    return c
  elseif type(v) == 'string' or type(v) == 'table' then
      return #v
    else
      return 0
    end
  end)(empty) == 0) then
    return {board = b, full = true}
  end
  local idx = (_now() % (function(v)
  if type(v) == 'table' and v.items ~= nil then
    return #v.items
  elseif type(v) == 'table' and (v[1] == nil) then
      local c = 0
      for _ in pairs(v) do c = c + 1 end
      return c
    elseif type(v) == 'string' or type(v) == 'table' then
        return #v
      else
        return 0
      end
    end)(empty))
    local cell = empty[idx + 1]
    local val = 4
    if ((_now() % 10) < 9) then
      val = 2
    end
    grid[cell[1 + 1] + 1][cell[0 + 1] + 1] = val
    return {board = {cells = grid}, full = ((function(v)
    if type(v) == 'table' and v.items ~= nil then
      return #v.items
    elseif type(v) == 'table' and (v[1] == nil) then
        local c = 0
        for _ in pairs(v) do c = c + 1 end
        return c
      elseif type(v) == 'string' or type(v) == 'table' then
          return #v
        else
          return 0
        end
      end)(empty) == 1)}
    end
    function pad(n)
      local s = tostring(n)
      local pad = (4 - (function(v)
      if type(v) == 'table' and v.items ~= nil then
        return #v.items
      elseif type(v) == 'table' and (v[1] == nil) then
          local c = 0
          for _ in pairs(v) do c = c + 1 end
          return c
        elseif type(v) == 'string' or type(v) == 'table' then
            return #v
          else
            return 0
          end
        end)(s))
        local i = 0
        local out = ""
        while (i < pad) do
          out = (out .. " ")
          i = (i + 1)
        end
        return (out .. s)
      end
      function draw(b, score)
        print(("Score: " .. tostring(score)))
        local y = 0
        while (y < SIZE) do
          print("+----+----+----+----+")
          local line = "|"
          local x = 0
          while (x < SIZE) do
            local v = b.cells[y + 1][x + 1]
            if (v == 0) then
              line = (line .. "    |")
            else
              line = ((line .. pad(v)) .. "|")
            end
            x = (x + 1)
          end
          print(line)
          y = (y + 1)
        end
        print("+----+----+----+----+")
        print("W=Up S=Down A=Left D=Right Q=Quit")
      end
      function reverseRow(r)
        local out = {}
        local i = ((function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(r) - 1)
          while (i >= 0) do
            out = (function(lst, item)
            local res = {table.unpack(lst)}
            table.insert(res, item)
            return res
          end)(out, r[i + 1])
          i = (i - 1)
        end
        return out
      end
      function slideLeft(row)
        local xs = {}
        local i = 0
        while (i < (function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(row)) do
            if (row[i + 1] ~= 0) then
              xs = (function(lst, item)
              local res = {table.unpack(lst)}
              table.insert(res, item)
              return res
            end)(xs, row[i + 1])
          end
          i = (i + 1)
        end
        local res = {}
        local gain = 0
        i = 0
        while (i < (function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(xs)) do
            if (((i + 1) < (function(v)
            if type(v) == 'table' and v.items ~= nil then
              return #v.items
            elseif type(v) == 'table' and (v[1] == nil) then
                local c = 0
                for _ in pairs(v) do c = c + 1 end
                return c
              elseif type(v) == 'string' or type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(xs)) and (xs[i + 1] == xs[(i + 1) + 1])) then
                local v = (xs[i + 1] * 2)
                gain = (gain + v)
                res = (function(lst, item)
                local res = {table.unpack(lst)}
                table.insert(res, item)
                return res
              end)(res, v)
              i = (i + 2)
            else
              res = (function(lst, item)
              local res = {table.unpack(lst)}
              table.insert(res, item)
              return res
            end)(res, xs[i + 1])
            i = (i + 1)
          end
        end
        while ((function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(res) < SIZE) do
            res = (function(lst, item)
            local res = {table.unpack(lst)}
            table.insert(res, item)
            return res
          end)(res, 0)
        end
        return {row = res, gain = gain}
      end
      function moveLeft(b, score)
        local grid = b.cells
        local moved = false
        local y = 0
        while (y < SIZE) do
          local r = slideLeft(grid[y + 1])
          local new = r.row
          score = (score + r.gain)
          local x = 0
          while (x < SIZE) do
            if (grid[y + 1][x + 1] ~= new[x + 1]) then
              moved = true
            end
            grid[y + 1][x + 1] = new[x + 1]
            x = (x + 1)
          end
          y = (y + 1)
        end
        return {board = {cells = grid}, score = score, moved = moved}
      end
      function moveRight(b, score)
        local grid = b.cells
        local moved = false
        local y = 0
        while (y < SIZE) do
          local rev = reverseRow(grid[y + 1])
          local r = slideLeft(rev)
          rev = r.row
          score = (score + r.gain)
          rev = reverseRow(rev)
          local x = 0
          while (x < SIZE) do
            if (grid[y + 1][x + 1] ~= rev[x + 1]) then
              moved = true
            end
            grid[y + 1][x + 1] = rev[x + 1]
            x = (x + 1)
          end
          y = (y + 1)
        end
        return {board = {cells = grid}, score = score, moved = moved}
      end
      function getCol(b, x)
        local col = {}
        local y = 0
        while (y < SIZE) do
          col = (function(lst, item)
          local res = {table.unpack(lst)}
          table.insert(res, item)
          return res
        end)(col, b.cells[y + 1][x + 1])
        y = (y + 1)
      end
      return col
    end
    function setCol(b, x, col)
      local rows = b.cells
      local y = 0
      while (y < SIZE) do
        local row = rows[y + 1]
        row[x + 1] = col[y + 1]
        rows[y + 1] = row
        y = (y + 1)
      end
      b.cells = rows
    end
    function moveUp(b, score)
      local grid = b.cells
      local moved = false
      local x = 0
      while (x < SIZE) do
        local col = getCol(b, x)
        local r = slideLeft(col)
        local new = r.row
        score = (score + r.gain)
        local y = 0
        while (y < SIZE) do
          if (grid[y + 1][x + 1] ~= new[y + 1]) then
            moved = true
          end
          grid[y + 1][x + 1] = new[y + 1]
          y = (y + 1)
        end
        x = (x + 1)
      end
      return {board = {cells = grid}, score = score, moved = moved}
    end
    function moveDown(b, score)
      local grid = b.cells
      local moved = false
      local x = 0
      while (x < SIZE) do
        local col = reverseRow(getCol(b, x))
        local r = slideLeft(col)
        col = r.row
        score = (score + r.gain)
        col = reverseRow(col)
        local y = 0
        while (y < SIZE) do
          if (grid[y + 1][x + 1] ~= col[y + 1]) then
            moved = true
          end
          grid[y + 1][x + 1] = col[y + 1]
          y = (y + 1)
        end
        x = (x + 1)
      end
      return {board = {cells = grid}, score = score, moved = moved}
    end
    function hasMoves(b)
      local y = 0
      while (y < SIZE) do
        local x = 0
        while (x < SIZE) do
          if (b.cells[y + 1][x + 1] == 0) then
            return true
          end
          if (((x + 1) < SIZE) and (b.cells[y + 1][x + 1] == b.cells[y + 1][(x + 1) + 1])) then
            return true
          end
          if (((y + 1) < SIZE) and (b.cells[y + 1][x + 1] == b.cells[(y + 1) + 1][x + 1])) then
            return true
          end
          x = (x + 1)
        end
        y = (y + 1)
      end
      return false
    end
    function has2048(b)
      local y = 0
      while (y < SIZE) do
        local x = 0
        while (x < SIZE) do
          if (b.cells[y + 1][x + 1] >= 2048) then
            return true
          end
          x = (x + 1)
        end
        y = (y + 1)
      end
      return false
    end
    board = newBoard()
    r = spawnTile(board)
    board = r.board
    full = r.full
    r = spawnTile(board)
    board = r.board
    full = r.full
    score = 0
    draw(board, score)
    while true do
      print("Move: ")
      cmd = input()
      moved = false
      if ((cmd == "a") or (cmd == "A")) then
        m = moveLeft(board, score)
        board = m.board
        score = m.score
        moved = m.moved
      end
      if ((cmd == "d") or (cmd == "D")) then
        m = moveRight(board, score)
        board = m.board
        score = m.score
        moved = m.moved
      end
      if ((cmd == "w") or (cmd == "W")) then
        m = moveUp(board, score)
        board = m.board
        score = m.score
        moved = m.moved
      end
      if ((cmd == "s") or (cmd == "S")) then
        m = moveDown(board, score)
        board = m.board
        score = m.score
        moved = m.moved
      end
      if ((cmd == "q") or (cmd == "Q")) then
        break
      end
      if moved then
        r2 = spawnTile(board)
        board = r2.board
        full = r2.full
        if (full and (not hasMoves(board))) then
          draw(board, score)
          print("Game Over")
          break
        end
      end
      draw(board, score)
      if has2048(board) then
        print("You win!")
        break
      end
      if (not hasMoves(board)) then
        print("Game Over")
        break
      end
    end
    local _bench_end = _now()
    collectgarbage()
    local _bench_end_mem = collectgarbage('count') * 1024
    local _bench_duration_us = math.floor((_bench_end - _bench_start) / 1000)
    local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
    print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
  end;
