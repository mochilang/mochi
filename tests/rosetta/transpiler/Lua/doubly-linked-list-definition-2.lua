-- Generated by Mochi v0.10.41 on 2025-07-26 20:02 GMT+7
function input()
  return io.read('*l')
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = _now()
  function newList()
    return {__name = "GenType1", __order = {"nodes", "head", "tail", "nextID"}, nodes = {}, head = 0, tail = 0, nextID = 1}
  end
  function newNode(l, v)
    local id = math.floor(l.nextID)
    l.nextID = (id + 1)
    local nodes = l.nodes
    local n = {__name = "GenType2", __order = {"id", "value", "next", "prev"}, id = id, value = v, next = 0, prev = 0}
    nodes[id] = n
    l.nodes = nodes
    return n
  end
  function pushFront(l, v)
    local n = newNode(l, v)
    n.next = l.head
    if (math.floor(l.head) ~= 0) then
      local nodes = l.nodes
      local h = nodes[math.floor(l.head)]
      h.prev = n.id
      nodes[math.floor(h.id)] = h
      l.nodes = nodes
    else
      l.tail = n.id
    end
    l.head = n.id
    local nodes2 = l.nodes
    nodes2[math.floor(n.id)] = n
    l.nodes = nodes2
    return n
  end
  function pushBack(l, v)
    local n = newNode(l, v)
    n.prev = l.tail
    if (math.floor(l.tail) ~= 0) then
      local nodes = l.nodes
      local t = nodes[math.floor(l.tail)]
      t.next = n.id
      nodes[math.floor(t.id)] = t
      l.nodes = nodes
    else
      l.head = n.id
    end
    l.tail = n.id
    local nodes2 = l.nodes
    nodes2[math.floor(n.id)] = n
    l.nodes = nodes2
    return n
  end
  function insertBefore(l, refID, v)
    if (refID == 0) then
      return pushFront(l, v)
    end
    local nodes = l.nodes
    local ref = nodes[refID]
    local n = newNode(l, v)
    n.prev = ref.prev
    n.next = ref.id
    if (math.floor(ref.prev) ~= 0) then
      local p = nodes[math.floor(ref.prev)]
      p.next = n.id
      nodes[math.floor(p.id)] = p
    else
      l.head = n.id
    end
    ref.prev = n.id
    nodes[refID] = ref
    nodes[math.floor(n.id)] = n
    l.nodes = nodes
    return n
  end
  function insertAfter(l, refID, v)
    if (refID == 0) then
      return pushBack(l, v)
    end
    local nodes = l.nodes
    local ref = nodes[refID]
    local n = newNode(l, v)
    n.next = ref.next
    n.prev = ref.id
    if (math.floor(ref.next) ~= 0) then
      local nx = nodes[math.floor(ref.next)]
      nx.prev = n.id
      nodes[math.floor(nx.id)] = nx
    else
      l.tail = n.id
    end
    ref.next = n.id
    nodes[refID] = ref
    nodes[math.floor(n.id)] = n
    l.nodes = nodes
    return n
  end
  function main()
    local l = newList()
    local e4 = pushBack(l, 4)
    local e1 = pushFront(l, 1)
    insertBefore(l, math.floor(e4.id), 3)
    insertAfter(l, math.floor(e1.id), "two")
    local id = math.floor(l.head)
    local nodes = l.nodes
    while (id ~= 0) do
      local node = nodes[id]
      print(tostring(node.value))
      id = math.floor(node.next)
    end
  end
  main()
  local _bench_end = _now()
  collectgarbage()
  local _bench_end_mem = collectgarbage('count') * 1024
  local _bench_duration_us = math.floor((_bench_end - _bench_start) / 1000)
  local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
  print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
end;
