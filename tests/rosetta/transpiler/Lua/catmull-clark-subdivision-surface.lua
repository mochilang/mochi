-- Generated by Mochi v0.10.40 on 2025-07-25 20:06 GMT+7
function input()
  return io.read('*l')
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  -- keep the seed within safe integer range for Lua (53 bits)
  _now_seed = (_now_seed * 1664525 + 1013904223) % 9007199254740991
  return _now_seed % 1000000000
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end

local function _indexOf(s, ch)
if type(s) == 'string' then
  for i = 1, #s do
    if string.sub(s, i, i) == ch then
      return i - 1
    end
  end
elseif type(s) == 'table' then
    for i, v in ipairs(s) do
      if v == ch then
        return i - 1
      end
    end
  end
  return -1
end
do
  collectgarbage()
  local _bench_start_mem = collectgarbage('count') * 1024
  local _bench_start = _now()
  function indexOf(s, ch)
    local i = 0
    while (i < (function(v)
    if type(v) == 'table' and v.items ~= nil then
      return #v.items
    elseif type(v) == 'table' and (v[1] == nil) then
        local c = 0
        for _ in pairs(v) do c = c + 1 end
        return c
      elseif type(v) == 'string' or type(v) == 'table' then
          return #v
        else
          return 0
        end
      end)(s)) do
        if (string.sub(s, i + 1, (i + 1)) == ch) then
          return i
        end
        i = (i + 1)
      end
      return (-1)
    end
    function fmt4(x)
      local y = (x * 10000)
      if (y >= 0) then
        y = (y + 0.5)
      else
        y = (y - 0.5)
      end
      y = (math.floor(y) / 10000)
      local s = tostring(y)
      local dot = _indexOf(s, ".")
      if (dot == (0 - 1)) then
        s = (s .. ".0000")
      else
        local decs = (((function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(s) - dot) - 1)
          if (decs > 4) then
            s = string.sub(s, 0 + 1, (dot + 5))
          else
            while (decs < 4) do
              s = (s .. "0")
              decs = (decs + 1)
            end
          end
        end
        if (x >= 0) then
          s = (" " .. s)
        end
        return s
      end
      function fmt2(n)
        local s = tostring(n)
        if ((function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(s) < 2) then
            return (" " .. s)
          end
          return s
        end
        function sumPoint(p1, p2)
          return {x = (p1.x + p2.x), y = (p1.y + p2.y), z = (p1.z + p2.z)}
        end
        function mulPoint(p, m)
          return {x = (p.x * m), y = (p.y * m), z = (p.z * m)}
        end
        function divPoint(p, d)
          return mulPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(p), (1 / d))
        end
        function centerPoint(p1, p2)
          return divPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(sumPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(p1), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(p2))), 2)
        end
        function getFacePoints(points, faces)
          local facePoints = {}
          local i = 0
          while (i < (function(v)
          if type(v) == 'table' and v.items ~= nil then
            return #v.items
          elseif type(v) == 'table' and (v[1] == nil) then
              local c = 0
              for _ in pairs(v) do c = c + 1 end
              return c
            elseif type(v) == 'string' or type(v) == 'table' then
                return #v
              else
                return 0
              end
            end)(faces)) do
              local face = faces[i + 1]
              local fp = {x = 0, y = 0, z = 0}
              for _, idx in ipairs(face) do
                fp = sumPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(fp), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(points[idx + 1]))
              end
              fp = divPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(fp), (function(v)
              if type(v) == 'table' and v.items ~= nil then
                return #v.items
              elseif type(v) == 'table' and (v[1] == nil) then
                  local c = 0
                  for _ in pairs(v) do c = c + 1 end
                  return c
                elseif type(v) == 'string' or type(v) == 'table' then
                    return #v
                  else
                    return 0
                  end
                end)(face))
                facePoints = (function(lst, item)
                local res = {table.unpack(lst)}
                table.insert(res, item)
                return res
              end)(facePoints, fp)
              i = (i + 1)
            end
            return facePoints
          end
          function sortEdges(edges)
            local res = {}
            local tmp = edges
            while ((function(v)
            if type(v) == 'table' and v.items ~= nil then
              return #v.items
            elseif type(v) == 'table' and (v[1] == nil) then
                local c = 0
                for _ in pairs(v) do c = c + 1 end
                return c
              elseif type(v) == 'string' or type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(tmp) > 0) do
                local min = tmp[0 + 1]
                local idx = 0
                local j = 1
                while (j < (function(v)
                if type(v) == 'table' and v.items ~= nil then
                  return #v.items
                elseif type(v) == 'table' and (v[1] == nil) then
                    local c = 0
                    for _ in pairs(v) do c = c + 1 end
                    return c
                  elseif type(v) == 'string' or type(v) == 'table' then
                      return #v
                    else
                      return 0
                    end
                  end)(tmp)) do
                    local e = tmp[j + 1]
                    if ((e[0 + 1] < min[0 + 1]) or ((e[0 + 1] == min[0 + 1]) and ((e[1 + 1] < min[1 + 1]) or ((e[1 + 1] == min[1 + 1]) and (e[2 + 1] < min[2 + 1]))))) then
                      min = e
                      idx = j
                    end
                    j = (j + 1)
                  end
                  res = (function(lst, item)
                  local res = {table.unpack(lst)}
                  table.insert(res, item)
                  return res
                end)(res, min)
                local out = {}
                local k = 0
                while (k < (function(v)
                if type(v) == 'table' and v.items ~= nil then
                  return #v.items
                elseif type(v) == 'table' and (v[1] == nil) then
                    local c = 0
                    for _ in pairs(v) do c = c + 1 end
                    return c
                  elseif type(v) == 'string' or type(v) == 'table' then
                      return #v
                    else
                      return 0
                    end
                  end)(tmp)) do
                    if (k ~= idx) then
                      out = (function(lst, item)
                      local res = {table.unpack(lst)}
                      table.insert(res, item)
                      return res
                    end)(out, tmp[k + 1])
                  end
                  k = (k + 1)
                end
                tmp = out
              end
              return res
            end
            function getEdgesFaces(points, faces)
              local edges = {}
              local fnum = 0
              while (fnum < (function(v)
              if type(v) == 'table' and v.items ~= nil then
                return #v.items
              elseif type(v) == 'table' and (v[1] == nil) then
                  local c = 0
                  for _ in pairs(v) do c = c + 1 end
                  return c
                elseif type(v) == 'string' or type(v) == 'table' then
                    return #v
                  else
                    return 0
                  end
                end)(faces)) do
                  local face = faces[fnum + 1]
                  local numP = (function(v)
                  if type(v) == 'table' and v.items ~= nil then
                    return #v.items
                  elseif type(v) == 'table' and (v[1] == nil) then
                      local c = 0
                      for _ in pairs(v) do c = c + 1 end
                      return c
                    elseif type(v) == 'string' or type(v) == 'table' then
                        return #v
                      else
                        return 0
                      end
                    end)(face)
                    local pi = 0
                    while (pi < numP) do
                      local pn1 = face[pi + 1]
                      local pn2 = 0
                      if (pi < (numP - 1)) then
                        pn2 = face[(pi + 1) + 1]
                      else
                        pn2 = face[0 + 1]
                      end
                      if (pn1 > pn2) then
                        local tmpn = pn1
                        pn1 = pn2
                        pn2 = tmpn
                      end
                      edges = (function(lst, item)
                      local res = {table.unpack(lst)}
                      table.insert(res, item)
                      return res
                    end)(edges, {pn1, pn2, fnum})
                    pi = (pi + 1)
                  end
                  fnum = (fnum + 1)
                end
                edges = sortEdges(edges)
                local merged = {}
                local idx = 0
                while (idx < (function(v)
                if type(v) == 'table' and v.items ~= nil then
                  return #v.items
                elseif type(v) == 'table' and (v[1] == nil) then
                    local c = 0
                    for _ in pairs(v) do c = c + 1 end
                    return c
                  elseif type(v) == 'string' or type(v) == 'table' then
                      return #v
                    else
                      return 0
                    end
                  end)(edges)) do
                    local e1 = edges[idx + 1]
                    if (idx < ((function(v)
                    if type(v) == 'table' and v.items ~= nil then
                      return #v.items
                    elseif type(v) == 'table' and (v[1] == nil) then
                        local c = 0
                        for _ in pairs(v) do c = c + 1 end
                        return c
                      elseif type(v) == 'string' or type(v) == 'table' then
                          return #v
                        else
                          return 0
                        end
                      end)(edges) - 1)) then
                        local e2 = edges[(idx + 1) + 1]
                        if ((e1[0 + 1] == e2[0 + 1]) and (e1[1 + 1] == e2[1 + 1])) then
                          merged = (function(lst, item)
                          local res = {table.unpack(lst)}
                          table.insert(res, item)
                          return res
                        end)(merged, {e1[0 + 1], e1[1 + 1], e1[2 + 1], e2[2 + 1]})
                        idx = (idx + 2)
                        goto __cont_1
                      end
                    end
                    merged = (function(lst, item)
                    local res = {table.unpack(lst)}
                    table.insert(res, item)
                    return res
                  end)(merged, {e1[0 + 1], e1[1 + 1], e1[2 + 1], (-1)})
                  idx = (idx + 1)
                  ::__cont_1::
                end
                local edgesCenters = {}
                for _, me in ipairs(merged) do
                  local p1 = points[me[0 + 1] + 1]
                  local p2 = points[me[1 + 1] + 1]
                  local cp = centerPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(p1), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(p2))
                  edgesCenters = (function(lst, item)
                  local res = {table.unpack(lst)}
                  table.insert(res, item)
                  return res
                end)(edgesCenters, {pn1 = me[0 + 1], pn2 = me[1 + 1], fn1 = me[2 + 1], fn2 = me[3 + 1], cp = cp})
              end
              return edgesCenters
            end
            function getEdgePoints(points, edgesFaces, facePoints)
              local edgePoints = {}
              local i = 0
              while (i < (function(v)
              if type(v) == 'table' and v.items ~= nil then
                return #v.items
              elseif type(v) == 'table' and (v[1] == nil) then
                  local c = 0
                  for _ in pairs(v) do c = c + 1 end
                  return c
                elseif type(v) == 'string' or type(v) == 'table' then
                    return #v
                  else
                    return 0
                  end
                end)(edgesFaces)) do
                  local edge = edgesFaces[i + 1]
                  local cp = edge.cp
                  local fp1 = facePoints[edge.fn1 + 1]
                  local fp2 = fp1
                  if (edge.fn2 ~= (0 - 1)) then
                    fp2 = facePoints[edge.fn2 + 1]
                  end
                  local cfp = centerPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(fp1), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(fp2))
                  edgePoints = (function(lst, item)
                  local res = {table.unpack(lst)}
                  table.insert(res, item)
                  return res
                end)(edgePoints, centerPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(cp), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(cfp)))
                i = (i + 1)
              end
              return edgePoints
            end
            function getAvgFacePoints(points, faces, facePoints)
              local numP = (function(v)
              if type(v) == 'table' and v.items ~= nil then
                return #v.items
              elseif type(v) == 'table' and (v[1] == nil) then
                  local c = 0
                  for _ in pairs(v) do c = c + 1 end
                  return c
                elseif type(v) == 'string' or type(v) == 'table' then
                    return #v
                  else
                    return 0
                  end
                end)(points)
                local temp = {}
                local i = 0
                while (i < numP) do
                  temp = (function(lst, item)
                  local res = {table.unpack(lst)}
                  table.insert(res, item)
                  return res
                end)(temp, {p = {x = 0, y = 0, z = 0}, n = 0})
                i = (i + 1)
              end
              local fnum = 0
              while (fnum < (function(v)
              if type(v) == 'table' and v.items ~= nil then
                return #v.items
              elseif type(v) == 'table' and (v[1] == nil) then
                  local c = 0
                  for _ in pairs(v) do c = c + 1 end
                  return c
                elseif type(v) == 'string' or type(v) == 'table' then
                    return #v
                  else
                    return 0
                  end
                end)(faces)) do
                  local fp = facePoints[fnum + 1]
                  for _, pn in ipairs(faces[fnum + 1]) do
                    local tp = temp[pn + 1]
                    temp[pn + 1] = {p = sumPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(tp.p), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(fp)), n = (tp.n + 1)}
                  end
                  fnum = (fnum + 1)
                end
                local avg = {}
                local j = 0
                while (j < numP) do
                  local tp = temp[j + 1]
                  avg = (function(lst, item)
                  local res = {table.unpack(lst)}
                  table.insert(res, item)
                  return res
                end)(avg, divPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(tp.p), tp.n))
                j = (j + 1)
              end
              return avg
            end
            function getAvgMidEdges(points, edgesFaces)
              local numP = (function(v)
              if type(v) == 'table' and v.items ~= nil then
                return #v.items
              elseif type(v) == 'table' and (v[1] == nil) then
                  local c = 0
                  for _ in pairs(v) do c = c + 1 end
                  return c
                elseif type(v) == 'string' or type(v) == 'table' then
                    return #v
                  else
                    return 0
                  end
                end)(points)
                local temp = {}
                local i = 0
                while (i < numP) do
                  temp = (function(lst, item)
                  local res = {table.unpack(lst)}
                  table.insert(res, item)
                  return res
                end)(temp, {p = {x = 0, y = 0, z = 0}, n = 0})
                i = (i + 1)
              end
              for _, edge in ipairs(edgesFaces) do
                local cp = edge.cp
                local arr = {edge.pn1, edge.pn2}
                for _, pn in ipairs(arr) do
                  local tp = temp[pn + 1]
                  temp[pn + 1] = {p = sumPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(tp.p), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(cp)), n = (tp.n + 1)}
                end
              end
              local avg = {}
              local j = 0
              while (j < numP) do
                local tp = temp[j + 1]
                avg = (function(lst, item)
                local res = {table.unpack(lst)}
                table.insert(res, item)
                return res
              end)(avg, divPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(tp.p), tp.n))
              j = (j + 1)
            end
            return avg
          end
          function getPointsFaces(points, faces)
            local pf = {}
            local i = 0
            while (i < (function(v)
            if type(v) == 'table' and v.items ~= nil then
              return #v.items
            elseif type(v) == 'table' and (v[1] == nil) then
                local c = 0
                for _ in pairs(v) do c = c + 1 end
                return c
              elseif type(v) == 'string' or type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(points)) do
                pf = (function(lst, item)
                local res = {table.unpack(lst)}
                table.insert(res, item)
                return res
              end)(pf, 0)
              i = (i + 1)
            end
            local fnum = 0
            while (fnum < (function(v)
            if type(v) == 'table' and v.items ~= nil then
              return #v.items
            elseif type(v) == 'table' and (v[1] == nil) then
                local c = 0
                for _ in pairs(v) do c = c + 1 end
                return c
              elseif type(v) == 'string' or type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(faces)) do
                for _, pn in ipairs(faces[fnum + 1]) do
                  pf[pn + 1] = (pf[pn + 1] + 1)
                end
                fnum = (fnum + 1)
              end
              return pf
            end
            function getNewPoints(points, pf, afp, ame)
              local newPts = {}
              local i = 0
              while (i < (function(v)
              if type(v) == 'table' and v.items ~= nil then
                return #v.items
              elseif type(v) == 'table' and (v[1] == nil) then
                  local c = 0
                  for _ in pairs(v) do c = c + 1 end
                  return c
                elseif type(v) == 'string' or type(v) == 'table' then
                    return #v
                  else
                    return 0
                  end
                end)(points)) do
                  local n = pf[i + 1]
                  local m1 = ((n - 3) / n)
                  local m2 = (1 / n)
                  local m3 = (2 / n)
                  local old = points[i + 1]
                  local p1 = mulPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(old), m1)
                  local p2 = mulPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(afp[i + 1]), m2)
                  local p3 = mulPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(ame[i + 1]), m3)
                  newPts = (function(lst, item)
                  local res = {table.unpack(lst)}
                  table.insert(res, item)
                  return res
                end)(newPts, sumPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(sumPoint((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(p1), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(p2))), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(p3)))
                i = (i + 1)
              end
              return newPts
            end
            function key(a, b)
              if (a < b) then
                return ((tostring(a) .. ",") .. tostring(b))
              end
              return ((tostring(b) .. ",") .. tostring(a))
            end
            function cmcSubdiv(points, faces)
              local facePoints = getFacePoints(points, faces)
              local edgesFaces = getEdgesFaces(points, faces)
              local edgePoints = getEdgePoints(points, edgesFaces, facePoints)
              local avgFacePoints = getAvgFacePoints(points, faces, facePoints)
              local avgMidEdges = getAvgMidEdges(points, edgesFaces)
              local pointsFaces = getPointsFaces(points, faces)
              local newPoints = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges)
              local facePointNums = {}
              local nextPoint = (function(v)
              if type(v) == 'table' and v.items ~= nil then
                return #v.items
              elseif type(v) == 'table' and (v[1] == nil) then
                  local c = 0
                  for _ in pairs(v) do c = c + 1 end
                  return c
                elseif type(v) == 'string' or type(v) == 'table' then
                    return #v
                  else
                    return 0
                  end
                end)(newPoints)
                for _, fp in ipairs(facePoints) do
                  newPoints = (function(lst, item)
                  local res = {table.unpack(lst)}
                  table.insert(res, item)
                  return res
                end)(newPoints, fp)
                facePointNums = (function(lst, item)
                local res = {table.unpack(lst)}
                table.insert(res, item)
                return res
              end)(facePointNums, nextPoint)
              nextPoint = (nextPoint + 1)
            end
            local edgePointNums = {}
            local idx = 0
            while (idx < (function(v)
            if type(v) == 'table' and v.items ~= nil then
              return #v.items
            elseif type(v) == 'table' and (v[1] == nil) then
                local c = 0
                for _ in pairs(v) do c = c + 1 end
                return c
              elseif type(v) == 'string' or type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(edgesFaces)) do
                local e = edgesFaces[idx + 1]
                newPoints = (function(lst, item)
                local res = {table.unpack(lst)}
                table.insert(res, item)
                return res
              end)(newPoints, edgePoints[idx + 1])
              edgePointNums[key(e.pn1, e.pn2)] = nextPoint
              nextPoint = (nextPoint + 1)
              idx = (idx + 1)
            end
            local newFaces = {}
            local fnum = 0
            while (fnum < (function(v)
            if type(v) == 'table' and v.items ~= nil then
              return #v.items
            elseif type(v) == 'table' and (v[1] == nil) then
                local c = 0
                for _ in pairs(v) do c = c + 1 end
                return c
              elseif type(v) == 'string' or type(v) == 'table' then
                  return #v
                else
                  return 0
                end
              end)(faces)) do
                local oldFace = faces[fnum + 1]
                if ((function(v)
                if type(v) == 'table' and v.items ~= nil then
                  return #v.items
                elseif type(v) == 'table' and (v[1] == nil) then
                    local c = 0
                    for _ in pairs(v) do c = c + 1 end
                    return c
                  elseif type(v) == 'string' or type(v) == 'table' then
                      return #v
                    else
                      return 0
                    end
                  end)(oldFace) == 4) then
                    local a = oldFace[0 + 1]
                    local b = oldFace[1 + 1]
                    local c = oldFace[2 + 1]
                    local d = oldFace[3 + 1]
                    local fpnum = facePointNums[fnum + 1]
                    local ab = edgePointNums[key(a, b)]
                    local da = edgePointNums[key(d, a)]
                    local bc = edgePointNums[key(b, c)]
                    local cd = edgePointNums[key(c, d)]
                    newFaces = (function(lst, item)
                    local res = {table.unpack(lst)}
                    table.insert(res, item)
                    return res
                  end)(newFaces, {a, ab, fpnum, da})
                  newFaces = (function(lst, item)
                  local res = {table.unpack(lst)}
                  table.insert(res, item)
                  return res
                end)(newFaces, {b, bc, fpnum, ab})
                newFaces = (function(lst, item)
                local res = {table.unpack(lst)}
                table.insert(res, item)
                return res
              end)(newFaces, {c, cd, fpnum, bc})
              newFaces = (function(lst, item)
              local res = {table.unpack(lst)}
              table.insert(res, item)
              return res
            end)(newFaces, {d, da, fpnum, cd})
          end
          fnum = (fnum + 1)
        end
        return {newPoints, newFaces}
      end
      function formatPoint(p)
        return (((((("[" .. fmt4(p.x)) .. " ") .. fmt4(p.y)) .. " ") .. fmt4(p.z)) .. "]")
      end
      function formatFace(f)
        if ((function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(f) == 0) then
            return "[]"
          end
          local s = ("[" .. fmt2(f[0 + 1]))
          local i = 1
          while (i < (function(v)
          if type(v) == 'table' and v.items ~= nil then
            return #v.items
          elseif type(v) == 'table' and (v[1] == nil) then
              local c = 0
              for _ in pairs(v) do c = c + 1 end
              return c
            elseif type(v) == 'string' or type(v) == 'table' then
                return #v
              else
                return 0
              end
            end)(f)) do
              s = ((s .. " ") .. fmt2(f[i + 1]))
              i = (i + 1)
            end
            s = (s .. "]")
            return s
          end
          function main()
            local inputPoints = {{x = (-1), y = 1, z = 1}, {x = (-1), y = (-1), z = 1}, {x = 1, y = (-1), z = 1}, {x = 1, y = 1, z = 1}, {x = 1, y = (-1), z = (-1)}, {x = 1, y = 1, z = (-1)}, {x = (-1), y = (-1), z = (-1)}, {x = (-1), y = 1, z = (-1)}}
            local inputFaces = {{0, 1, 2, 3}, {3, 2, 4, 5}, {5, 4, 6, 7}, {7, 0, 3, 5}, {7, 6, 1, 0}, {6, 1, 2, 4}}
            local outputPoints = inputPoints
            local outputFaces = inputFaces
            local i = 0
            while (i < 1) do
              local res = cmcSubdiv(outputPoints, outputFaces)
              outputPoints = res[0 + 1]
              outputFaces = res[1 + 1]
              i = (i + 1)
            end
            for _, p in ipairs(outputPoints) do
              print(formatPoint(p))
            end
            print("")
            for _, f in ipairs(outputFaces) do
              print(formatFace(f))
            end
          end
          main()
          local _bench_end = _now()
          collectgarbage()
          local _bench_end_mem = collectgarbage('count') * 1024
          local _bench_duration_us = math.floor((_bench_end - _bench_start) / 1000)
          local _bench_mem = math.floor(math.max(0, _bench_end_mem - _bench_start_mem))
          print('{\n  "duration_us": ' .. _bench_duration_us .. ',\n  "memory_bytes": ' .. _bench_mem .. ',\n  "name": "main"\n}')
        end;
