-- Generated by Mochi v0.10.37 on 2025-07-23 14:12 GMT+7
function input()
  return io.read('*l')
end
local _nil = {}

local _now_seed = 0
local _now_seeded = false
do
  local s = os.getenv("MOCHI_NOW_SEED")
  if s and s ~= "" then
    local v = tonumber(s)
    if v then
      _now_seed = v
      _now_seeded = true
    end
  end
end
local function _now()
if _now_seeded then
  _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
  return _now_seed
end
return os.time() * 1000000000 + math.floor(os.clock() * 1000000000)
end
function absf(x)
  if (x < 0) then
    return (0 - x)
  end
  return x
end;

function maxf(a, b)
  if (a > b) then
    return a
  end
  return b
end;

function minf(a, b)
  if (a < b) then
    return a
  end
  return b
end;

function max3(a, b, c)
  local m = a
  if (b > m) then
    m = b
  end
  if (c > m) then
    m = c
  end
  return m
end;

function min3(a, b, c)
  local m = a
  if (b < m) then
    m = b
  end
  if (c < m) then
    m = c
  end
  return m
end;

function subdivideQuadSpline(q, t)
  local s = (1 - t)
  local u = {c0 = q.c0, c1 = 0, c2 = 0}
  local v = {c0 = 0, c1 = 0, c2 = q.c2}
  u.c1 = ((s * q.c0) + (t * q.c1))
  v.c1 = ((s * q.c1) + (t * q.c2))
  u.c2 = ((s * u.c1) + (t * v.c1))
  v.c0 = u.c2
  return {u, v}
end;

function subdivideQuadCurve(q, t)
  local xs = subdivideQuadSpline((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(q.x), t)
  local ys = subdivideQuadSpline((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(q.y), t)
  local u = {x = xs[0 + 1], y = ys[0 + 1]}
  local v = {x = xs[1 + 1], y = ys[1 + 1]}
  return {u, v}
end;

function rectsOverlap(xa0, ya0, xa1, ya1, xb0, yb0, xb1, yb1)
  return ((((xb0 <= xa1) and (xa0 <= xb1)) and (yb0 <= ya1)) and (ya0 <= yb1))
end;

function testIntersect(p, q, tol)
  local pxmin = min3(p.x.c0, p.x.c1, p.x.c2)
  local pymin = min3(p.y.c0, p.y.c1, p.y.c2)
  local pxmax = max3(p.x.c0, p.x.c1, p.x.c2)
  local pymax = max3(p.y.c0, p.y.c1, p.y.c2)
  local qxmin = min3(q.x.c0, q.x.c1, q.x.c2)
  local qymin = min3(q.y.c0, q.y.c1, q.y.c2)
  local qxmax = max3(q.x.c0, q.x.c1, q.x.c2)
  local qymax = max3(q.y.c0, q.y.c1, q.y.c2)
  local exclude = true
  local accept = false
  local inter = {x = 0, y = 0}
  if rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax) then
    exclude = false
    local xmin = maxf(pxmin, qxmin)
    local xmax = minf(pxmax, qxmax)
    if ((xmax - xmin) <= tol) then
      local ymin = maxf(pymin, qymin)
      local ymax = minf(pymax, qymax)
      if ((ymax - ymin) <= tol) then
        accept = true
        inter.x = (0.5 * (xmin + xmax))
        inter.y = (0.5 * (ymin + ymax))
      end
    end
  end
  return {__name = "GenType1", __order = {"exclude", "accept", "intersect"}, exclude = exclude, accept = accept, intersect = inter}
end;

function seemsToBeDuplicate(pts, xy, spacing)
  local i = 0
  while (i < (function(v)
  if type(v) == 'table' and v.items ~= nil then
    return #v.items
  elseif type(v) == 'table' and (v[1] == nil) then
      local c = 0
      for _ in pairs(v) do c = c + 1 end
      return c
    elseif type(v) == 'string' or type(v) == 'table' then
        return #v
      else
        return 0
      end
    end)(pts)) do
      local pt = pts[i + 1]
      if ((absf((pt.x - xy.x)) < spacing) and (absf((pt.y - xy.y)) < spacing)) then
        return true
      end
      i = (i + 1)
    end
    return false
  end;
  
  function findIntersects(p, q, tol, spacing)
    local inters = {}
    local workload = {{__name = "GenType2", __order = {"p", "q"}, p = p, q = q}}
    while ((function(v)
    if type(v) == 'table' and v.items ~= nil then
      return #v.items
    elseif type(v) == 'table' and (v[1] == nil) then
        local c = 0
        for _ in pairs(v) do c = c + 1 end
        return c
      elseif type(v) == 'string' or type(v) == 'table' then
          return #v
        else
          return 0
        end
      end)(workload) > 0) do
        local idx = ((function(v)
        if type(v) == 'table' and v.items ~= nil then
          return #v.items
        elseif type(v) == 'table' and (v[1] == nil) then
            local c = 0
            for _ in pairs(v) do c = c + 1 end
            return c
          elseif type(v) == 'string' or type(v) == 'table' then
              return #v
            else
              return 0
            end
          end)(workload) - 1)
          local work = workload[idx + 1]
          workload = (function(lst,s,e)
          local r={}
          for i=s+1,e do
            r[#r+1]=lst[i]
          end
          return r
        end)(workload, 0, idx)
        local res = testIntersect((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(work.p), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(work.q), tol)
        local excl = res.exclude
        local acc = res.accept
        local inter = res.intersect
        if acc then
          if (not seemsToBeDuplicate(inters, (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(inter), spacing)) then
            inters = (function(lst, item)
            local res = {table.unpack(lst)}
            table.insert(res, item)
            return res
          end)(inters, inter)
        end
      else
        if (not excl) then
          local ps = subdivideQuadCurve((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(work.p), 0.5)
          local qs = subdivideQuadCurve((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(work.q), 0.5)
          local p0 = ps[0 + 1]
          local p1 = ps[1 + 1]
          local q0 = qs[0 + 1]
          local q1 = qs[1 + 1]
          workload = (function(lst, item)
          local res = {table.unpack(lst)}
          table.insert(res, item)
          return res
        end)(workload, {__name = "GenType3", __order = {"p", "q"}, p = p0, q = q0})
        workload = (function(lst, item)
        local res = {table.unpack(lst)}
        table.insert(res, item)
        return res
      end)(workload, {__name = "GenType4", __order = {"p", "q"}, p = p0, q = q1})
      workload = (function(lst, item)
      local res = {table.unpack(lst)}
      table.insert(res, item)
      return res
    end)(workload, {__name = "GenType5", __order = {"p", "q"}, p = p1, q = q0})
    workload = (function(lst, item)
    local res = {table.unpack(lst)}
    table.insert(res, item)
    return res
  end)(workload, {__name = "GenType6", __order = {"p", "q"}, p = p1, q = q1})
end
end
end
return inters
end;

function main()
  local p = {x = {c0 = (0 - 1), c1 = 0, c2 = 1}, y = {c0 = 0, c1 = 10, c2 = 0}}
  local q = {x = {c0 = 2, c1 = (0 - 8), c2 = 2}, y = {c0 = 1, c1 = 2, c2 = 3}}
  local tol = 1e-07
  local spacing = (tol * 10)
  local inters = findIntersects((function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(p), (function(_t) local _c={} for k,v in pairs(_t) do _c[k]=v end return _c end)(q), tol, spacing)
  local i = 0
  while (i < (function(v)
  if type(v) == 'table' and v.items ~= nil then
    return #v.items
  elseif type(v) == 'table' and (v[1] == nil) then
      local c = 0
      for _ in pairs(v) do c = c + 1 end
      return c
    elseif type(v) == 'string' or type(v) == 'table' then
        return #v
      else
        return 0
      end
    end)(inters)) do
      local pt = inters[i + 1]
      print((((("(" ..
      (function(v)
      local function encode(x)
      if type(x) == "table" then
        if x.__name and x.__order then
          local parts = {x.__name, " {"}
          for i, k in ipairs(x.__order) do
            if i > 1 then parts[#parts+1] = ", " end
            parts[#parts+1] = k .. " = " .. encode(x[k])
          end
          parts[#parts+1] = "}"
          return table.concat(parts)
        elseif #x > 0 then
            local allTables = true
            for _, v in ipairs(x) do
              if type(v) ~= "table" then allTables = false break end
            end
            local parts = {}
            if not allTables then parts[#parts+1] = "[" end
            for i, val in ipairs(x) do
              parts[#parts+1] = encode(val)
              if i < #x then parts[#parts+1] = " " end
            end
            if not allTables then parts[#parts+1] = "]" end
            return table.concat(parts)
          else
            local keys = {}
            for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
            table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
            local parts = {"{"}
            for i, k in ipairs(keys) do
              parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
              if i < #keys then parts[#parts+1] = ", " end
            end
            parts[#parts+1] = "}"
            return table.concat(parts)
          end
        elseif type(x) == "string" then
            return '"' .. x .. '"'
          else
            return tostring(x)
          end
        end
        return encode(v)
      end)(pt.x)) .. ", ") ..
      (function(v)
      local function encode(x)
      if type(x) == "table" then
        if x.__name and x.__order then
          local parts = {x.__name, " {"}
          for i, k in ipairs(x.__order) do
            if i > 1 then parts[#parts+1] = ", " end
            parts[#parts+1] = k .. " = " .. encode(x[k])
          end
          parts[#parts+1] = "}"
          return table.concat(parts)
        elseif #x > 0 then
            local allTables = true
            for _, v in ipairs(x) do
              if type(v) ~= "table" then allTables = false break end
            end
            local parts = {}
            if not allTables then parts[#parts+1] = "[" end
            for i, val in ipairs(x) do
              parts[#parts+1] = encode(val)
              if i < #x then parts[#parts+1] = " " end
            end
            if not allTables then parts[#parts+1] = "]" end
            return table.concat(parts)
          else
            local keys = {}
            for k in pairs(x) do if k ~= "__name" and k ~= "__order" then table.insert(keys, k) end end
            table.sort(keys, function(a,b) return tostring(a) > tostring(b) end)
            local parts = {"{"}
            for i, k in ipairs(keys) do
              parts[#parts+1] = "'" .. tostring(k) .. "': " .. encode(x[k])
              if i < #keys then parts[#parts+1] = ", " end
            end
            parts[#parts+1] = "}"
            return table.concat(parts)
          end
        elseif type(x) == "string" then
            return '"' .. x .. '"'
          else
            return tostring(x)
          end
        end
        return encode(v)
      end)(pt.y)) .. ")"))
      i = (i + 1)
    end
  end;
  
  main();
