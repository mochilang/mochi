-- Generated by Mochi v0.10.41 on 2025-07-27 15:57 GMT+7
function input()
  return io.read('*l')
end
local _nil = {}
function egyptianDivide(dividend, divisor)
  if ((dividend < 0) or (divisor <= 0)) then
    panic("Invalid argument(s)")
  end
  if (dividend < divisor) then
    return {q = 0, r = dividend}
  end
  local powers = {1}
  local doublings = {divisor}
  local doubling = (divisor * 2)
  while (doubling <= dividend) do
    powers = (function(lst, item)
    local res = {table.unpack(lst)}
    table.insert(res, item)
    return res
  end)(powers, (powers[((function(v)
  if type(v) == 'table' and v.items ~= nil then
    return #v.items
  elseif type(v) == 'table' and (v[1] == nil) then
      local c = 0
      for _ in pairs(v) do c = c + 1 end
      return c
    elseif type(v) == 'string' or type(v) == 'table' then
        return #v
      else
        return 0
      end
    end)(powers) - 1) + 1] * 2))
    doublings = (function(lst, item)
    local res = {table.unpack(lst)}
    table.insert(res, item)
    return res
  end)(doublings, doubling)
  doubling = (doubling * 2)
end
local ans = 0
local accum = 0
local i = ((function(v)
if type(v) == 'table' and v.items ~= nil then
  return #v.items
elseif type(v) == 'table' and (v[1] == nil) then
    local c = 0
    for _ in pairs(v) do c = c + 1 end
    return c
  elseif type(v) == 'string' or type(v) == 'table' then
      return #v
    else
      return 0
    end
  end)(doublings) - 1)
  while (i >= 0) do
    if ((accum + doublings[i + 1]) <= dividend) then
      accum = (accum + doublings[i + 1])
      ans = (ans + powers[i + 1])
      if (accum == dividend) then
        break
      end
    end
    i = (i - 1)
  end
  return {q = ans, r = (dividend - accum)}
end;

function main()
  local dividend = 580
  local divisor = 34
  local res = egyptianDivide(dividend, divisor)
  print(((((((tostring(dividend) .. " divided by ") .. tostring(divisor)) .. " is ") .. tostring(res.q)) .. " with remainder ") .. tostring(res.r)))
end;

main();
