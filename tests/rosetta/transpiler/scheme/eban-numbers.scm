;; Generated on 2025-08-03 10:21 +0700
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(import (srfi 1))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (exact (floor (* (current-second) 1000000000))))
)
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(let ((start26 (now))) (begin (define vals (_list 0 2 4 6 30 32 34 36 40 42 44 46 50 52 54 56 60 62 64 66)) (define billions (_list 0 2 4 6)) (define (ebanNumbers start stop) (call/cc (lambda (ret1) (let ((nums (_list))) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((b (car xs))) (begin (call/cc (lambda (break5) (letrec ((loop4 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((m (car xs))) (begin (call/cc (lambda (break7) (letrec ((loop6 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((t (car xs))) (begin (call/cc (lambda (break9) (letrec ((loop8 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((r (car xs))) (begin (let ((n (_add (_add (_add (* b 1000000000) (* m 1000000)) (* t 1000)) r))) (begin (if (and (_ge n start) (_le n stop)) (begin (set! nums (append nums (_list n)))) (quote ())))))) (loop8 (cdr xs))))))) (loop8 vals)))))) (loop6 (cdr xs))))))) (loop6 vals)))))) (loop4 (cdr xs))))))) (loop4 vals)))))) (loop2 (cdr xs))))))) (loop2 billions)))) (ret1 nums)))))) (define (countEban start stop) (call/cc (lambda (ret10) (let ((count 0)) (begin (call/cc (lambda (break12) (letrec ((loop11 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((b (car xs))) (begin (call/cc (lambda (break14) (letrec ((loop13 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((m (car xs))) (begin (call/cc (lambda (break16) (letrec ((loop15 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((t (car xs))) (begin (call/cc (lambda (break18) (letrec ((loop17 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((r (car xs))) (begin (let ((n (_add (_add (_add (* b 1000000000) (* m 1000000)) (* t 1000)) r))) (begin (if (and (_ge n start) (_le n stop)) (begin (set! count (+ count 1))) (quote ())))))) (loop17 (cdr xs))))))) (loop17 vals)))))) (loop15 (cdr xs))))))) (loop15 vals)))))) (loop13 (cdr xs))))))) (loop13 vals)))))) (loop11 (cdr xs))))))) (loop11 billions)))) (ret10 count)))))) (define (main) (call/cc (lambda (ret19) (let ((ranges (_list (_list 2 1000 #t) (_list 1000 4000 #t) (_list 2 10000 #f) (_list 2 100000 #f) (_list 2 1000000 #f) (_list 2 10000000 #f) (_list 2 100000000 #f) (_list 2 1000000000 #f)))) (begin (call/cc (lambda (break21) (letrec ((loop20 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((rg (car xs))) (begin (let ((start (let ((v22 (cond ((string? rg) (_substring rg 0 (+ 0 1))) ((hash-table? rg) (hash-table-ref rg 0)) (else (list-ref rg 0))))) (cond ((string? v22) (inexact->exact (floor (string->number v22)))) ((boolean? v22) (if v22 1 0)) (else (inexact->exact (floor v22))))))) (begin (let ((stop (let ((v23 (cond ((string? rg) (_substring rg 1 (+ 1 1))) ((hash-table? rg) (hash-table-ref rg 1)) (else (list-ref rg 1))))) (cond ((string? v23) (inexact->exact (floor (string->number v23)))) ((boolean? v23) (if v23 1 0)) (else (inexact->exact (floor v23))))))) (begin (let ((show (cond ((string? rg) (_substring rg 2 (+ 2 1))) ((hash-table? rg) (hash-table-ref rg 2)) (else (list-ref rg 2))))) (begin (if (equal? start 2) (begin (_display (to-str (string-append (string-append "eban numbers up to and including " (to-str stop)) ":"))) (newline)) (begin (_display (to-str (string-append (string-append (string-append (string-append "eban numbers between " (to-str start)) " and ") (to-str stop)) " (inclusive):"))) (newline))) (if show (begin (let ((nums (ebanNumbers start stop))) (begin (let ((line "")) (begin (let ((i 0)) (begin (call/cc (lambda (break25) (letrec ((loop24 (lambda () (if (< i (cond ((string? nums) (string-length nums)) ((hash-table? nums) (hash-table-size nums)) (else (length nums)))) (begin (set! line (string-append (string-append line (to-str (cond ((string? nums) (_substring nums i (+ i 1))) ((hash-table? nums) (hash-table-ref nums i)) (else (list-ref nums i))))) " ")) (set! i (+ i 1)) (loop24)) (quote ()))))) (loop24)))) (if (> (cond ((string? line) (string-length line)) ((hash-table? line) (hash-table-size line)) (else (length line))) 0) (begin (_display (to-str (_substring line 0 (- (cond ((string? line) (string-length line)) ((hash-table? line) (hash-table-size line)) (else (length line))) 1)))) (newline)) (quote ()))))))))) (quote ())) (let ((c (countEban start stop))) (begin (_display (to-str (string-append (string-append "count = " (to-str c)) "\n"))) (newline))))))))))) (loop20 (cdr xs))))))) (loop20 ranges))))))))) (main) (let ((end27 (now))) (let ((dur28 (quotient (- end27 start26) 1000))) (begin (_display (string-append "{\n  \"duration_us\": " (number->string dur28) ",\n  \"memory_bytes\": " (number->string (_mem)) ",\n  \"name\": \"main\"\n}")) (newline))))))
