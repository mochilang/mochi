;; Generated on 2025-08-04 17:04 +0700
(import (scheme base))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(import (srfi 1))
(define _list list)
(import (chibi io))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (exact (floor (* (current-second) 1000000000))))
)
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(define (_len x)
  (cond ((string? x) (string-length x))
        ((hash-table? x) (hash-table-size x))
        (else (length x))))
(define (_input)
  (let ((l (read-line)))
    (if (eof-object? l) "" l)))
(define (parseInt str) (call/cc (lambda (ret1) (let ((i 0)) (begin (let ((neg #f)) (begin (if (and (> (_len str) 0) (string=? (_substring str 0 1) "-")) (begin (set! neg #t) (set! i 1)) (quote ())) (let ((n 0)) (begin (let ((digits (alist->hash-table (_list (cons "0" 0) (cons "1" 1) (cons "2" 2) (cons "3" 3) (cons "4" 4) (cons "5" 5) (cons "6" 6) (cons "7" 7) (cons "8" 8) (cons "9" 9))))) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda () (if (< i (_len str)) (begin (set! n (+ (* n 10) (cond ((string? digits) (_substring digits (_substring str i (+ i 1)) (+ (_substring str i (+ i 1)) 1))) ((hash-table? digits) (hash-table-ref digits (_substring str i (+ i 1)))) (else (list-ref digits (_substring str i (+ i 1))))))) (set! i (+ i 1)) (loop2)) (quote ()))))) (loop2)))) (if neg (begin (set! n (- n))) (quote ())) (ret1 n))))))))))))
(define (rand10000) (call/cc (lambda (ret4) (ret4 (modulo (now) 10000)))))
(let ((value 0)) (begin (_display (to-str "Value:")) (_display " ") (_display (to-str value)) (newline) (let ((done #f)) (begin (call/cc (lambda (break6) (letrec ((loop5 (lambda () (if (not done) (begin (_display (to-str "i=increment, r=random, s num=set, q=quit:")) (newline) (let ((line (_input))) (begin (if (string=? line "i") (begin (set! value (+ value 1)) (_display (to-str "Value:")) (_display " ") (_display (to-str value)) (newline)) (if (string=? line "r") (begin (_display (to-str "Set random value? (y/n)")) (newline) (let ((ans (_input))) (begin (if (string=? ans "y") (begin (set! value (rand10000)) (_display (to-str "Value:")) (_display " ") (_display (to-str value)) (newline)) (quote ()))))) (if (and (> (_len line) 2) (string=? (_substring line 0 2) "s ")) (begin (set! value (parseInt (_substring line 2 (_len line)))) (_display (to-str "Value:")) (_display " ") (_display (to-str value)) (newline)) (if (string=? line "q") (begin (set! done #t)) (begin (_display (to-str "Unknown command")) (newline)))))))) (loop5)) (quote ()))))) (loop5))))))))
