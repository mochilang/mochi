;; Generated on 2025-07-25 19:59 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (pow10 exp)
 (call/cc (lambda (ret1)
 (let ((n 1)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i exp)
 (begin (set! n (* n 10)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (ret1 n)
)
)
)
)
)
)
)
(define (totient n)
 (call/cc (lambda (ret4)
 (let ((tot n)
)
 (begin (let ((nn n)
)
 (begin (let ((i 2)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (<= (* i i)
 nn)
 (begin (if (equal? (modulo nn i)
 0)
 (begin (call/cc (lambda (break8)
 (letrec ((loop7 (lambda ()
 (if (equal? (modulo nn i)
 0)
 (begin (set! nn (quotient nn i)
)
 (loop7)
)
 (quote ()
)
)
)
)
)
 (loop7)
)
)
)
 (set! tot (- tot (quotient tot i)
)
)
)
 (quote ()
)
)
 (if (equal? i 2)
 (begin (set! i 1)
)
 (quote ()
)
)
 (set! i (+ i 2)
)
 (loop5)
)
 (quote ()
)
)
)
)
)
 (loop5)
)
)
)
 (if (> nn 1)
 (begin (set! tot (- tot (quotient tot nn)
)
)
)
 (quote ()
)
)
 (ret4 tot)
)
)
)
)
)
)
)
)
)
(define pps (alist->hash-table (list)
)
)
(define (getPerfectPowers maxExp)
 (call/cc (lambda (ret9)
 (let ((upper (pow10 maxExp)
)
)
 (begin (let ((i 2)
)
 (begin (call/cc (lambda (break11)
 (letrec ((loop10 (lambda ()
 (if (< (* i i)
 upper)
 (begin (let ((p i)
)
 (begin (call/cc (lambda (break13)
 (letrec ((loop12 (lambda ()
 (if #t (begin (set! p (* p i)
)
 (if (>= p upper)
 (begin (break13 (quote ()
)
)
)
 (quote ()
)
)
 (hash-table-set! pps p #t)
 (loop12)
)
 (quote ()
)
)
)
)
)
 (loop12)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop10)
)
 (quote ()
)
)
)
)
)
 (loop10)
)
)
)
)
)
)
)
)
)
)
(define (getAchilles minExp maxExp)
 (call/cc (lambda (ret14)
 (let ((lower (pow10 minExp)
)
)
 (begin (let ((upper (pow10 maxExp)
)
)
 (begin (let ((achilles (alist->hash-table (list)
)
)
)
 (begin (let ((b 1)
)
 (begin (call/cc (lambda (break16)
 (letrec ((loop15 (lambda ()
 (if (< (* (* b b)
 b)
 upper)
 (begin (let ((b3 (* (* b b)
 b)
)
)
 (begin (let ((a 1)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if #t (begin (let ((p (* (* b3 a)
 a)
)
)
 (begin (if (>= p upper)
 (begin (break18 (quote ()
)
)
)
 (quote ()
)
)
 (if (>= p lower)
 (begin (if (not (cond ((string? pps)
 (if (string-contains pps p)
 #t #f)
)
 ((hash-table? pps)
 (if (hash-table-exists? pps p)
 #t #f)
)
 (else (if (member p pps)
 #t #f)
)
)
)
 (begin (hash-table-set! achilles p #t)
)
 (quote ()
)
)
)
 (quote ()
)
)
 (set! a (+ a 1)
)
)
)
 (loop17)
)
 (quote ()
)
)
)
)
)
 (loop17)
)
)
)
 (set! b (+ b 1)
)
)
)
)
)
 (loop15)
)
 (quote ()
)
)
)
)
)
 (loop15)
)
)
)
 (ret14 achilles)
)
)
)
)
)
)
)
)
)
)
)
(define (sortInts xs)
 (call/cc (lambda (ret19)
 (let ((res (list)
)
)
 (begin (let ((tmp xs)
)
 (begin (call/cc (lambda (break21)
 (letrec ((loop20 (lambda ()
 (if (> (cond ((string? tmp)
 (string-length tmp)
)
 ((hash-table? tmp)
 (hash-table-size tmp)
)
 (else (length tmp)
)
)
 0)
 (begin (let ((min (list-ref tmp 0)
)
)
 (begin (let ((idx 0)
)
 (begin (let ((i 1)
)
 (begin (call/cc (lambda (break23)
 (letrec ((loop22 (lambda ()
 (if (< i (cond ((string? tmp)
 (string-length tmp)
)
 ((hash-table? tmp)
 (hash-table-size tmp)
)
 (else (length tmp)
)
)
)
 (begin (if (< (list-ref tmp i)
 min)
 (begin (set! min (list-ref tmp i)
)
 (set! idx i)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop22)
)
 (quote ()
)
)
)
)
)
 (loop22)
)
)
)
 (set! res (append res (list min)
)
)
 (let ((out (list)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break25)
 (letrec ((loop24 (lambda ()
 (if (< j (cond ((string? tmp)
 (string-length tmp)
)
 ((hash-table? tmp)
 (hash-table-size tmp)
)
 (else (length tmp)
)
)
)
 (begin (if (not (equal? j idx)
)
 (begin (set! out (append out (list (list-ref tmp j)
)
)
)
)
 (quote ()
)
)
 (set! j (+ j 1)
)
 (loop24)
)
 (quote ()
)
)
)
)
)
 (loop24)
)
)
)
 (set! tmp out)
)
)
)
)
)
)
)
)
)
)
 (loop20)
)
 (quote ()
)
)
)
)
)
 (loop20)
)
)
)
 (ret19 res)
)
)
)
)
)
)
)
(define (pad n width)
 (call/cc (lambda (ret26)
 (let ((s (to-str n)
)
)
 (begin (call/cc (lambda (break28)
 (letrec ((loop27 (lambda ()
 (if (< (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 width)
 (begin (set! s (string-append " " s)
)
 (loop27)
)
 (quote ()
)
)
)
)
)
 (loop27)
)
)
)
 (ret26 s)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret29)
 (let ((maxDigits 15)
)
 (begin (getPerfectPowers 5)
 (let ((achSet (getAchilles 1 5)
)
)
 (begin (let ((ach (list)
)
)
 (begin (call/cc (lambda (break31)
 (letrec ((loop30 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((k (car xs)
)
)
 (begin (set! ach (append ach (list k)
)
)
)
)
 (loop30 (cdr xs)
)
)
)
)
)
)
 (loop30 (hash-table-keys achSet)
)
)
)
)
 (set! ach (sortInts ach)
)
 (display (to-str "First 50 Achilles numbers:")
)
 (newline)
 (let ((i 0)
)
 (begin (call/cc (lambda (break33)
 (letrec ((loop32 (lambda ()
 (if (< i 50)
 (begin (let ((line "")
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break35)
 (letrec ((loop34 (lambda ()
 (if (< j 10)
 (begin (set! line (string-append line (pad (list-ref ach i)
 4)
)
)
 (if (< j 9)
 (begin (set! line (string-append line " ")
)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (set! j (+ j 1)
)
 (loop34)
)
 (quote ()
)
)
)
)
)
 (loop34)
)
)
)
 (display (to-str line)
)
 (newline)
)
)
)
)
 (loop32)
)
 (quote ()
)
)
)
)
)
 (loop32)
)
)
)
 (display (to-str "\nFirst 30 strong Achilles numbers:")
)
 (newline)
 (let ((strong (list)
)
)
 (begin (let ((count 0)
)
 (begin (let ((idx 0)
)
 (begin (call/cc (lambda (break37)
 (letrec ((loop36 (lambda ()
 (if (< count 30)
 (begin (let ((tot (totient (list-ref ach idx)
)
)
)
 (begin (if (cond ((string? achSet)
 (if (string-contains achSet tot)
 #t #f)
)
 ((hash-table? achSet)
 (if (hash-table-exists? achSet tot)
 #t #f)
)
 (else (if (member tot achSet)
 #t #f)
)
)
 (begin (set! strong (append strong (list (list-ref ach idx)
)
)
)
 (set! count (+ count 1)
)
)
 (quote ()
)
)
 (set! idx (+ idx 1)
)
)
)
 (loop36)
)
 (quote ()
)
)
)
)
)
 (loop36)
)
)
)
 (set! i 0)
 (call/cc (lambda (break39)
 (letrec ((loop38 (lambda ()
 (if (< i 30)
 (begin (let ((line "")
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break41)
 (letrec ((loop40 (lambda ()
 (if (< j 10)
 (begin (set! line (string-append line (pad (list-ref strong i)
 5)
)
)
 (if (< j 9)
 (begin (set! line (string-append line " ")
)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (set! j (+ j 1)
)
 (loop40)
)
 (quote ()
)
)
)
)
)
 (loop40)
)
)
)
 (display (to-str line)
)
 (newline)
)
)
)
)
 (loop38)
)
 (quote ()
)
)
)
)
)
 (loop38)
)
)
)
 (display (to-str "\nNumber of Achilles numbers with:")
)
 (newline)
 (let ((counts (list 1 12 47 192 664 2242 7395 24008 77330 247449 788855 2508051 7960336 25235383)
)
)
 (begin (let ((d 2)
)
 (begin (call/cc (lambda (break43)
 (letrec ((loop42 (lambda ()
 (if (<= d maxDigits)
 (begin (let ((c (list-ref counts (- d 2)
)
)
)
 (begin (display (to-str (string-append (string-append (pad d 2)
 " digits: ")
 (to-str c)
)
)
)
 (newline)
 (set! d (+ d 1)
)
)
)
 (loop42)
)
 (quote ()
)
)
)
)
)
 (loop42)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
