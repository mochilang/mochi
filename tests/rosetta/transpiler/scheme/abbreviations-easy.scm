;; Generated on 2025-07-25 08:58 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))(import (chibi time))
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(let ((start22 (now)
)
)
 (begin (define (fields s)
 (call/cc (lambda (ret1)
 (let ((words (list)
)
)
 (begin (let ((cur "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (let ((ch (substring s i (+ i 1)
)
)
)
 (begin (if (or (or (string=? ch " ")
 (string=? ch "\n")
)
 (string=? ch "\t")
)
 (begin (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! words (append words (list cur)
)
)
 (set! cur "")
)
 (quote nil)
)
)
 (begin (set! cur (string-append cur ch)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! words (append words (list cur)
)
)
)
 (quote nil)
)
 (ret1 words)
)
)
)
)
)
)
)
)
)
 (define (padRight s width)
 (call/cc (lambda (ret4)
 (let ((out s)
)
 (begin (let ((i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (< i width)
 (begin (set! out (string-append out " ")
)
 (set! i (+ i 1)
)
 (loop5)
)
 (quote nil)
)
)
)
)
 (loop5)
)
)
)
 (ret4 out)
)
)
)
)
)
)
)
 (define (join xs sep)
 (call/cc (lambda (ret7)
 (let ((res "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (< i (cond ((string? xs)
 (string-length xs)
)
 ((hash-table? xs)
 (hash-table-size xs)
)
 (else (length xs)
)
)
)
 (begin (if (> i 0)
 (begin (set! res (string-append res sep)
)
)
 (quote nil)
)
 (set! res (string-append res (list-ref xs i)
)
)
 (set! i (+ i 1)
)
 (loop8)
)
 (quote nil)
)
)
)
)
 (loop8)
)
)
)
 (ret7 res)
)
)
)
)
)
)
)
 (define (validate commands words mins)
 (call/cc (lambda (ret10)
 (let ((results (list)
)
)
 (begin (if (equal? (cond ((string? words)
 (string-length words)
)
 ((hash-table? words)
 (hash-table-size words)
)
 (else (length words)
)
)
 0)
 (begin (ret10 results)
)
 (quote nil)
)
 (let ((wi 0)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (< wi (cond ((string? words)
 (string-length words)
)
 ((hash-table? words)
 (hash-table-size words)
)
 (else (length words)
)
)
)
 (begin (let ((w (list-ref words wi)
)
)
 (begin (let ((found #f)
)
 (begin (let ((wlen (cond ((string? w)
 (string-length w)
)
 ((hash-table? w)
 (hash-table-size w)
)
 (else (length w)
)
)
)
)
 (begin (let ((ci 0)
)
 (begin (call/cc (lambda (break14)
 (letrec ((loop13 (lambda ()
 (if (< ci (cond ((string? commands)
 (string-length commands)
)
 ((hash-table? commands)
 (hash-table-size commands)
)
 (else (length commands)
)
)
)
 (begin (let ((cmd (list-ref commands ci)
)
)
 (begin (if (and (and (not (equal? (list-ref mins ci)
 0)
)
 (>= wlen (list-ref mins ci)
)
)
 (<= wlen (cond ((string? cmd)
 (string-length cmd)
)
 ((hash-table? cmd)
 (hash-table-size cmd)
)
 (else (length cmd)
)
)
)
)
 (begin (let ((c (upper cmd)
)
)
 (begin (let ((ww (upper w)
)
)
 (begin (if (string=? (substring c 0 wlen)
 ww)
 (begin (set! results (append results (list c)
)
)
 (set! found #t)
 (break14 (quote nil)
)
)
 (quote nil)
)
)
)
)
)
)
 (quote nil)
)
 (set! ci (+ ci 1)
)
)
)
 (loop13)
)
 (quote nil)
)
)
)
)
 (loop13)
)
)
)
 (if (not found)
 (begin (set! results (append results (list "*error*")
)
)
)
 (quote nil)
)
 (set! wi (+ wi 1)
)
)
)
)
)
)
)
)
)
 (loop11)
)
 (quote nil)
)
)
)
)
 (loop11)
)
)
)
 (ret10 results)
)
)
)
)
)
)
)
 (define (main)
 (call/cc (lambda (ret15)
 (let ((table (string-append (string-append (string-append (string-append (string-append (string-append "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ")
 "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ")
 " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ")
 "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ")
 "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ")
 "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp ")
)
)
 (begin (let ((commands (fields table)
)
)
 (begin (let ((mins (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break17)
 (letrec ((loop16 (lambda ()
 (if (< i (cond ((string? commands)
 (string-length commands)
)
 ((hash-table? commands)
 (hash-table-size commands)
)
 (else (length commands)
)
)
)
 (begin (let ((count 0)
)
 (begin (let ((j 0)
)
 (begin (let ((cmd (list-ref commands i)
)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda ()
 (if (< j (cond ((string? cmd)
 (string-length cmd)
)
 ((hash-table? cmd)
 (hash-table-size cmd)
)
 (else (length cmd)
)
)
)
 (begin (let ((ch (substring cmd j (+ j 1)
)
)
)
 (begin (if (and (string>=? ch "A")
 (string<=? ch "Z")
)
 (begin (set! count (+ count 1)
)
)
 (quote nil)
)
 (set! j (+ j 1)
)
)
)
 (loop18)
)
 (quote nil)
)
)
)
)
 (loop18)
)
)
)
 (set! mins (append mins (list count)
)
)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop16)
)
 (quote nil)
)
)
)
)
 (loop16)
)
)
)
 (let ((sentence "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin")
)
 (begin (let ((words (fields sentence)
)
)
 (begin (let ((results (validate commands words mins)
)
)
 (begin (let ((out1 "user words:  ")
)
 (begin (let ((k 0)
)
 (begin (call/cc (lambda (break21)
 (letrec ((loop20 (lambda ()
 (if (< k (cond ((string? words)
 (string-length words)
)
 ((hash-table? words)
 (hash-table-size words)
)
 (else (length words)
)
)
)
 (begin (set! out1 (string-append (string-append out1 (padRight (list-ref words k)
 (cond ((string? (list-ref results k)
)
 (string-length (list-ref results k)
)
)
 ((hash-table? (list-ref results k)
)
 (hash-table-size (list-ref results k)
)
)
 (else (length (list-ref results k)
)
)
)
)
)
 " ")
)
 (set! k (+ k 1)
)
 (loop20)
)
 (quote nil)
)
)
)
)
 (loop20)
)
)
)
 (display (to-str out1)
)
 (newline)
 (display (to-str (string-append "full words:  " (join results " ")
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (main)
 (let ((end23 (now)
)
)
 (let ((dur24 (quotient (- end23 start22)
 1000)
)
)
 (begin (display (string-append "{\n  \"duration_us\": " (number->string dur24)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
