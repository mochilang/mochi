;; Generated on 2025-07-27 17:19 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (chibi io))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_input)
  (let ((l (read-line)))
    (if (eof-object? l) "" l)))
(define (indexOf s ch)
 (call/cc (lambda (ret1)
 (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (if (string=? (substring s i (+ i 1)
)
 ch)
 (begin (ret1 i)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (ret1 (- 1)
)
)
)
)
)
)
(define (fields s)
 (call/cc (lambda (ret4)
 (let ((words (_list)
)
)
 (begin (let ((cur "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (let ((ch (substring s i (+ i 1)
)
)
)
 (begin (if (or (or (string=? ch " ")
 (string=? ch "\t")
)
 (string=? ch "\n")
)
 (begin (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! words (append words (_list cur)
)
)
 (set! cur "")
)
 (quote ()
)
)
)
 (begin (set! cur (string-append cur ch)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop5)
)
 (quote ()
)
)
)
)
)
 (loop5)
)
)
)
 (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! words (append words (_list cur)
)
)
)
 (quote ()
)
)
 (ret4 words)
)
)
)
)
)
)
)
)
)
(define (makePatterns)
 (call/cc (lambda (ret7)
 (let ((digits (_list "1" "2" "3" "4" "5" "6" "7" "8" "9")
)
)
 (begin (let ((pats (_list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (< i (cond ((string? digits)
 (string-length digits)
)
 ((hash-table? digits)
 (hash-table-size digits)
)
 (else (length digits)
)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break11)
 (letrec ((loop10 (lambda ()
 (if (< j (cond ((string? digits)
 (string-length digits)
)
 ((hash-table? digits)
 (hash-table-size digits)
)
 (else (length digits)
)
)
)
 (begin (if (not (equal? j i)
)
 (begin (let ((k 0)
)
 (begin (call/cc (lambda (break13)
 (letrec ((loop12 (lambda ()
 (if (< k (cond ((string? digits)
 (string-length digits)
)
 ((hash-table? digits)
 (hash-table-size digits)
)
 (else (length digits)
)
)
)
 (begin (if (and (not (equal? k i)
)
 (not (equal? k j)
)
)
 (begin (let ((l 0)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if (< l (cond ((string? digits)
 (string-length digits)
)
 ((hash-table? digits)
 (hash-table-size digits)
)
 (else (length digits)
)
)
)
 (begin (if (and (and (not (equal? l i)
)
 (not (equal? l j)
)
)
 (not (equal? l k)
)
)
 (begin (set! pats (append pats (_list (string-append (string-append (string-append (list-ref digits i)
 (list-ref digits j)
)
 (list-ref digits k)
)
 (list-ref digits l)
)
)
)
)
)
 (quote ()
)
)
 (set! l (+ l 1)
)
 (loop14)
)
 (quote ()
)
)
)
)
)
 (loop14)
)
)
)
)
)
)
 (quote ()
)
)
 (set! k (+ k 1)
)
 (loop12)
)
 (quote ()
)
)
)
)
)
 (loop12)
)
)
)
)
)
)
 (quote ()
)
)
 (set! j (+ j 1)
)
 (loop10)
)
 (quote ()
)
)
)
)
)
 (loop10)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop8)
)
 (quote ()
)
)
)
)
)
 (loop8)
)
)
)
 (ret7 pats)
)
)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret16)
 (begin (_display (to-str (string-append (string-append (string-append (string-append (string-append "Cows and bulls/player\n" "You think of four digit number of unique digits in the range 1 to 9.\n")
 "I guess.  You score my guess:\n")
 "    A correct digit but not in the correct place is a cow.\n")
 "    A correct digit in the correct place is a bull.\n")
 "You give my score as two numbers separated with a space.")
)
)
 (newline)
 (let ((patterns (makePatterns)
)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if #t (begin (if (equal? (cond ((string? patterns)
 (string-length patterns)
)
 ((hash-table? patterns)
 (hash-table-size patterns)
)
 (else (length patterns)
)
)
 0)
 (begin (_display (to-str "Oops, check scoring.")
)
 (newline)
 (ret16 (quote ()
)
)
)
 (quote ()
)
)
 (let ((guess (cond ((string? patterns)
 (substring patterns 0 (+ 0 1)
)
)
 ((hash-table? patterns)
 (hash-table-ref patterns 0)
)
 (else (list-ref patterns 0)
)
)
)
)
 (begin (set! patterns (if (string? patterns)
 (substring patterns 1 (cond ((string? patterns)
 (string-length patterns)
)
 ((hash-table? patterns)
 (hash-table-size patterns)
)
 (else (length patterns)
)
)
)
 (take (drop patterns 1)
 (- (cond ((string? patterns)
 (string-length patterns)
)
 ((hash-table? patterns)
 (hash-table-size patterns)
)
 (else (length patterns)
)
)
 1)
)
)
)
 (let ((cows 0)
)
 (begin (let ((bulls 0)
)
 (begin (call/cc (lambda (break20)
 (letrec ((loop19 (lambda ()
 (if #t (begin (_display (to-str (string-append (string-append "My guess: " guess)
 ".  Score? (c b)
 ")
)
)
 (newline)
 (let ((line (_input)
)
)
 (begin (let ((toks (fields line)
)
)
 (begin (if (equal? (cond ((string? toks)
 (string-length toks)
)
 ((hash-table? toks)
 (hash-table-size toks)
)
 (else (length toks)
)
)
 2)
 (begin (let ((c (let ((v21 (cond ((string? toks)
 (substring toks 0 (+ 0 1)
)
)
 ((hash-table? toks)
 (hash-table-ref toks 0)
)
 (else (list-ref toks 0)
)
)
)
)
 (cond ((string? v21)
 (inexact->exact (floor (string->number v21)
)
)
)
 ((boolean? v21)
 (if v21 1 0)
)
 (else (inexact->exact (floor v21)
)
)
)
)
)
)
 (begin (let ((b (let ((v22 (cond ((string? toks)
 (substring toks 1 (+ 1 1)
)
)
 ((hash-table? toks)
 (hash-table-ref toks 1)
)
 (else (list-ref toks 1)
)
)
)
)
 (cond ((string? v22)
 (inexact->exact (floor (string->number v22)
)
)
)
 ((boolean? v22)
 (if v22 1 0)
)
 (else (inexact->exact (floor v22)
)
)
)
)
)
)
 (begin (if (and (and (and (and (>= c 0)
 (<= c 4)
)
 (>= b 0)
)
 (<= b 4)
)
 (_le (+ c b)
 4)
)
 (begin (set! cows c)
 (set! bulls b)
 (break20 (quote ()
)
)
)
 (quote ()
)
)
)
)
)
)
)
 (quote ()
)
)
 (_display (to-str "Score guess as two numbers: cows bulls")
)
 (newline)
)
)
)
)
 (loop19)
)
 (quote ()
)
)
)
)
)
 (loop19)
)
)
)
 (if (equal? bulls 4)
 (begin (_display (to-str "I did it. :)
")
)
 (newline)
 (ret16 (quote ()
)
)
)
 (quote ()
)
)
 (let ((next (_list)
)
)
 (begin (let ((idx 0)
)
 (begin (call/cc (lambda (break24)
 (letrec ((loop23 (lambda ()
 (if (< idx (cond ((string? patterns)
 (string-length patterns)
)
 ((hash-table? patterns)
 (hash-table-size patterns)
)
 (else (length patterns)
)
)
)
 (begin (let ((pat (cond ((string? patterns)
 (substring patterns idx (+ idx 1)
)
)
 ((hash-table? patterns)
 (hash-table-ref patterns idx)
)
 (else (list-ref patterns idx)
)
)
)
)
 (begin (let ((c 0)
)
 (begin (let ((b 0)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (< i 4)
 (begin (let ((cg (substring guess i (+ i 1)
)
)
)
 (begin (let ((cp (substring pat i (+ i 1)
)
)
)
 (begin (if (string=? cg cp)
 (begin (set! b (+ b 1)
)
)
 (if (_ge (indexOf pat cg)
 0)
 (begin (set! c (+ c 1)
)
)
 (quote ()
)
)
)
 (set! i (+ i 1)
)
)
)
)
)
 (loop25)
)
 (quote ()
)
)
)
)
)
 (loop25)
)
)
)
 (if (and (equal? c cows)
 (equal? b bulls)
)
 (begin (set! next (append next (_list pat)
)
)
)
 (quote ()
)
)
 (set! idx (+ idx 1)
)
)
)
)
)
)
)
)
)
 (loop23)
)
 (quote ()
)
)
)
)
)
 (loop23)
)
)
)
 (set! patterns next)
)
)
)
)
)
)
)
)
)
)
 (loop17)
)
 (quote ()
)
)
)
)
)
 (loop17)
)
)
)
)
)
)
)
)
)
(main)
