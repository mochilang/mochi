;; Generated on 2025-08-02 18:09 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(import (srfi 1))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(define (indexOf s ch) (call/cc (lambda (ret1) (let ((i 0)) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda () (if (< i (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))) (begin (if (string=? (_substring s i (+ i 1)) ch) (begin (ret1 i)) (quote ())) (set! i (+ i 1)) (loop2)) (quote ()))))) (loop2)))) (ret1 (- 1)))))))
(define (fmt4 x) (call/cc (lambda (ret4) (let ((y (* x 10000.0))) (begin (if (>= y 0) (begin (set! y (+ y 0.5))) (begin (set! y (- y 0.5)))) (set! y (/ (+ 0.0 (let ((v5 y)) (cond ((string? v5) (inexact->exact (floor (string->number v5)))) ((boolean? v5) (if v5 1 0)) (else (inexact->exact (floor v5)))))) 10000.0)) (let ((s (to-str y))) (begin (let ((dot (indexOf s "."))) (begin (if (equal? dot (- 0 1)) (begin (set! s (string-append s ".0000"))) (begin (let ((decs (- (- (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))) dot) 1))) (begin (if (_gt decs 4) (begin (set! s (_substring s 0 (_add dot 5)))) (begin (call/cc (lambda (break7) (letrec ((loop6 (lambda () (if (_lt decs 4) (begin (set! s (string-append s "0")) (set! decs (_add decs 1)) (loop6)) (quote ()))))) (loop6)))))))))) (if (>= x 0.0) (begin (set! s (string-append " " s))) (quote ())) (ret4 s))))))))))
(define (fmt2 n) (call/cc (lambda (ret8) (let ((s (to-str n))) (begin (if (< (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))) 2) (begin (ret8 (string-append " " s))) (quote ())) (ret8 s))))))
(define (sumPoint p1 p2) (call/cc (lambda (ret9) (ret9 (alist->hash-table (_list (cons "x" (+ (hash-table-ref p1 "x") (hash-table-ref p2 "x"))) (cons "y" (+ (hash-table-ref p1 "y") (hash-table-ref p2 "y"))) (cons "z" (+ (hash-table-ref p1 "z") (hash-table-ref p2 "z")))))))))
(define (mulPoint p m) (call/cc (lambda (ret10) (ret10 (alist->hash-table (_list (cons "x" (* (hash-table-ref p "x") m)) (cons "y" (* (hash-table-ref p "y") m)) (cons "z" (* (hash-table-ref p "z") m))))))))
(define (divPoint p d) (call/cc (lambda (ret11) (ret11 (mulPoint p (/ 1.0 d))))))
(define (centerPoint p1 p2) (call/cc (lambda (ret12) (ret12 (divPoint (sumPoint p1 p2) 2.0)))))
(define (getFacePoints points faces) (call/cc (lambda (ret13) (let ((facePoints (_list))) (begin (let ((i 0)) (begin (call/cc (lambda (break15) (letrec ((loop14 (lambda () (if (< i (cond ((string? faces) (string-length faces)) ((hash-table? faces) (hash-table-size faces)) (else (length faces)))) (begin (let ((face (list-ref faces i))) (begin (let ((fp (alist->hash-table (_list (cons "x" 0.0) (cons "y" 0.0) (cons "z" 0.0))))) (begin (call/cc (lambda (break17) (letrec ((loop16 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((idx (car xs))) (begin (set! fp (sumPoint fp (list-ref points idx))))) (loop16 (cdr xs))))))) (loop16 face)))) (set! fp (divPoint fp (+ 0.0 (cond ((string? face) (string-length face)) ((hash-table? face) (hash-table-size face)) (else (length face)))))) (set! facePoints (append facePoints (_list fp))) (set! i (+ i 1)))))) (loop14)) (quote ()))))) (loop14)))) (ret13 facePoints))))))))
(define (sortEdges edges) (call/cc (lambda (ret18) (let ((res (_list))) (begin (let ((tmp edges)) (begin (call/cc (lambda (break20) (letrec ((loop19 (lambda () (if (> (cond ((string? tmp) (string-length tmp)) ((hash-table? tmp) (hash-table-size tmp)) (else (length tmp))) 0) (begin (let ((min (list-ref tmp 0))) (begin (let ((idx 0)) (begin (let ((j 1)) (begin (call/cc (lambda (break22) (letrec ((loop21 (lambda () (if (< j (cond ((string? tmp) (string-length tmp)) ((hash-table? tmp) (hash-table-size tmp)) (else (length tmp)))) (begin (let ((e (list-ref tmp j))) (begin (if (or (< (list-ref e 0) (list-ref min 0)) (and (equal? (list-ref e 0) (list-ref min 0)) (or (< (list-ref e 1) (list-ref min 1)) (and (equal? (list-ref e 1) (list-ref min 1)) (< (list-ref e 2) (list-ref min 2)))))) (begin (set! min e) (set! idx j)) (quote ())) (set! j (+ j 1)))) (loop21)) (quote ()))))) (loop21)))) (set! res (append res (_list min))) (let ((out (_list))) (begin (let ((k 0)) (begin (call/cc (lambda (break24) (letrec ((loop23 (lambda () (if (< k (cond ((string? tmp) (string-length tmp)) ((hash-table? tmp) (hash-table-size tmp)) (else (length tmp)))) (begin (if (not (equal? k idx)) (begin (set! out (append out (_list (list-ref tmp k))))) (quote ())) (set! k (+ k 1)) (loop23)) (quote ()))))) (loop23)))) (set! tmp out))))))))))) (loop19)) (quote ()))))) (loop19)))) (ret18 res))))))))
(define (getEdgesFaces points faces) (call/cc (lambda (ret25) (let ((edges (_list))) (begin (let ((fnum 0)) (begin (call/cc (lambda (break27) (letrec ((loop26 (lambda () (if (< fnum (cond ((string? faces) (string-length faces)) ((hash-table? faces) (hash-table-size faces)) (else (length faces)))) (begin (let ((face (list-ref faces fnum))) (begin (let ((numP (cond ((string? face) (string-length face)) ((hash-table? face) (hash-table-size face)) (else (length face))))) (begin (let ((pi 0)) (begin (call/cc (lambda (break29) (letrec ((loop28 (lambda () (if (< pi numP) (begin (let ((pn1 (list-ref face pi))) (begin (let ((pn2 0)) (begin (if (_lt pi (- numP 1)) (begin (set! pn2 (list-ref face (+ pi 1)))) (begin (set! pn2 (list-ref face 0)))) (if (> pn1 pn2) (begin (let ((tmpn pn1)) (begin (set! pn1 pn2) (set! pn2 tmpn)))) (quote ())) (set! edges (append edges (_list (_list pn1 pn2 fnum)))) (set! pi (+ pi 1)))))) (loop28)) (quote ()))))) (loop28)))) (set! fnum (+ fnum 1)))))))) (loop26)) (quote ()))))) (loop26)))) (set! edges (sortEdges edges)) (let ((merged (_list))) (begin (let ((idx 0)) (begin (call/cc (lambda (break31) (letrec ((loop30 (lambda () (if (< idx (cond ((string? edges) (string-length edges)) ((hash-table? edges) (hash-table-size edges)) (else (length edges)))) (begin (let ((e1 (list-ref edges idx))) (begin (if (_lt idx (- (cond ((string? edges) (string-length edges)) ((hash-table? edges) (hash-table-size edges)) (else (length edges))) 1)) (begin (let ((e2 (list-ref edges (+ idx 1)))) (begin (if (and (equal? (list-ref e1 0) (list-ref e2 0)) (equal? (list-ref e1 1) (list-ref e2 1))) (begin (set! merged (append merged (_list (_list (list-ref e1 0) (list-ref e1 1) (list-ref e1 2) (list-ref e2 2))))) (set! idx (+ idx 2)) (loop30)) (quote ()))))) (quote ())) (set! merged (append merged (_list (_list (list-ref e1 0) (list-ref e1 1) (list-ref e1 2) (- 1))))) (set! idx (+ idx 1)))) (loop30)) (quote ()))))) (loop30)))) (let ((edgesCenters (_list))) (begin (call/cc (lambda (break33) (letrec ((loop32 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((me (car xs))) (begin (let ((p1 (list-ref points (cond ((string? me) (_substring me 0 (+ 0 1))) ((hash-table? me) (hash-table-ref me 0)) (else (list-ref me 0)))))) (begin (let ((p2 (list-ref points (cond ((string? me) (_substring me 1 (+ 1 1))) ((hash-table? me) (hash-table-ref me 1)) (else (list-ref me 1)))))) (begin (let ((cp (centerPoint p1 p2))) (begin (set! edgesCenters (append edgesCenters (_list (alist->hash-table (_list (cons "pn1" (cond ((string? me) (_substring me 0 (+ 0 1))) ((hash-table? me) (hash-table-ref me 0)) (else (list-ref me 0)))) (cons "pn2" (cond ((string? me) (_substring me 1 (+ 1 1))) ((hash-table? me) (hash-table-ref me 1)) (else (list-ref me 1)))) (cons "fn1" (cond ((string? me) (_substring me 2 (+ 2 1))) ((hash-table? me) (hash-table-ref me 2)) (else (list-ref me 2)))) (cons "fn2" (cond ((string? me) (_substring me 3 (+ 3 1))) ((hash-table? me) (hash-table-ref me 3)) (else (list-ref me 3)))) (cons "cp" cp)))))))))))))) (loop32 (cdr xs))))))) (loop32 merged)))) (ret25 edgesCenters))))))))))))))
(define (getEdgePoints points edgesFaces facePoints) (call/cc (lambda (ret34) (let ((edgePoints (_list))) (begin (let ((i 0)) (begin (call/cc (lambda (break36) (letrec ((loop35 (lambda () (if (< i (cond ((string? edgesFaces) (string-length edgesFaces)) ((hash-table? edgesFaces) (hash-table-size edgesFaces)) (else (length edgesFaces)))) (begin (let ((edge (list-ref edgesFaces i))) (begin (let ((cp (hash-table-ref edge "cp"))) (begin (let ((fp1 (list-ref facePoints (hash-table-ref edge "fn1")))) (begin (let ((fp2 fp1)) (begin (if (not (equal? (hash-table-ref edge "fn2") (- 0 1))) (begin (set! fp2 (list-ref facePoints (hash-table-ref edge "fn2")))) (quote ())) (let ((cfp (centerPoint fp1 fp2))) (begin (set! edgePoints (append edgePoints (_list (centerPoint cp cfp)))) (set! i (+ i 1)))))))))))) (loop35)) (quote ()))))) (loop35)))) (ret34 edgePoints))))))))
(define (getAvgFacePoints points faces facePoints) (call/cc (lambda (ret37) (let ((numP (cond ((string? points) (string-length points)) ((hash-table? points) (hash-table-size points)) (else (length points))))) (begin (let ((temp (_list))) (begin (let ((i 0)) (begin (call/cc (lambda (break39) (letrec ((loop38 (lambda () (if (< i numP) (begin (set! temp (append temp (_list (alist->hash-table (_list (cons "p" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 0.0) (cons "z" 0.0)))) (cons "n" 0)))))) (set! i (+ i 1)) (loop38)) (quote ()))))) (loop38)))) (let ((fnum 0)) (begin (call/cc (lambda (break41) (letrec ((loop40 (lambda () (if (< fnum (cond ((string? faces) (string-length faces)) ((hash-table? faces) (hash-table-size faces)) (else (length faces)))) (begin (let ((fp (list-ref facePoints fnum))) (begin (call/cc (lambda (break43) (letrec ((loop42 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((pn (car xs))) (begin (let ((tp (list-ref temp pn))) (begin (list-set! temp pn (alist->hash-table (_list (cons "p" (sumPoint (hash-table-ref tp "p") fp)) (cons "n" (+ (hash-table-ref tp "n") 1))))))))) (loop42 (cdr xs))))))) (loop42 (list-ref faces fnum))))) (set! fnum (+ fnum 1)))) (loop40)) (quote ()))))) (loop40)))) (let ((avg (_list))) (begin (let ((j 0)) (begin (call/cc (lambda (break45) (letrec ((loop44 (lambda () (if (< j numP) (begin (let ((tp (list-ref temp j))) (begin (set! avg (append avg (_list (divPoint (hash-table-ref tp "p") (+ 0.0 (hash-table-ref tp "n")))))) (set! j (+ j 1)))) (loop44)) (quote ()))))) (loop44)))) (ret37 avg))))))))))))))))
(define (getAvgMidEdges points edgesFaces) (call/cc (lambda (ret46) (let ((numP (cond ((string? points) (string-length points)) ((hash-table? points) (hash-table-size points)) (else (length points))))) (begin (let ((temp (_list))) (begin (let ((i 0)) (begin (call/cc (lambda (break48) (letrec ((loop47 (lambda () (if (< i numP) (begin (set! temp (append temp (_list (alist->hash-table (_list (cons "p" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 0.0) (cons "z" 0.0)))) (cons "n" 0)))))) (set! i (+ i 1)) (loop47)) (quote ()))))) (loop47)))) (call/cc (lambda (break50) (letrec ((loop49 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((edge (car xs))) (begin (let ((cp (hash-table-ref edge "cp"))) (begin (let ((arr (_list (hash-table-ref edge "pn1") (hash-table-ref edge "pn2")))) (begin (call/cc (lambda (break52) (letrec ((loop51 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((pn (car xs))) (begin (let ((tp (list-ref temp pn))) (begin (list-set! temp pn (alist->hash-table (_list (cons "p" (sumPoint (hash-table-ref tp "p") cp)) (cons "n" (+ (hash-table-ref tp "n") 1))))))))) (loop51 (cdr xs))))))) (loop51 arr)))))))))) (loop49 (cdr xs))))))) (loop49 edgesFaces)))) (let ((avg (_list))) (begin (let ((j 0)) (begin (call/cc (lambda (break54) (letrec ((loop53 (lambda () (if (< j numP) (begin (let ((tp (list-ref temp j))) (begin (set! avg (append avg (_list (divPoint (hash-table-ref tp "p") (+ 0.0 (hash-table-ref tp "n")))))) (set! j (+ j 1)))) (loop53)) (quote ()))))) (loop53)))) (ret46 avg))))))))))))))
(define (getPointsFaces points faces) (call/cc (lambda (ret55) (let ((pf (_list))) (begin (let ((i 0)) (begin (call/cc (lambda (break57) (letrec ((loop56 (lambda () (if (< i (cond ((string? points) (string-length points)) ((hash-table? points) (hash-table-size points)) (else (length points)))) (begin (set! pf (append pf (_list 0))) (set! i (+ i 1)) (loop56)) (quote ()))))) (loop56)))) (let ((fnum 0)) (begin (call/cc (lambda (break59) (letrec ((loop58 (lambda () (if (< fnum (cond ((string? faces) (string-length faces)) ((hash-table? faces) (hash-table-size faces)) (else (length faces)))) (begin (call/cc (lambda (break61) (letrec ((loop60 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((pn (car xs))) (begin (list-set! pf pn (+ (list-ref pf pn) 1)))) (loop60 (cdr xs))))))) (loop60 (list-ref faces fnum))))) (set! fnum (+ fnum 1)) (loop58)) (quote ()))))) (loop58)))) (ret55 pf))))))))))
(define (getNewPoints points pf afp ame) (call/cc (lambda (ret62) (let ((newPts (_list))) (begin (let ((i 0)) (begin (call/cc (lambda (break64) (letrec ((loop63 (lambda () (if (< i (cond ((string? points) (string-length points)) ((hash-table? points) (hash-table-size points)) (else (length points)))) (begin (let ((n (+ 0.0 (list-ref pf i)))) (begin (let ((m1 (/ (- n 3.0) n))) (begin (let ((m2 (/ 1.0 n))) (begin (let ((m3 (/ 2.0 n))) (begin (let ((old (list-ref points i))) (begin (let ((p1 (mulPoint old m1))) (begin (let ((p2 (mulPoint (list-ref afp i) m2))) (begin (let ((p3 (mulPoint (list-ref ame i) m3))) (begin (set! newPts (append newPts (_list (sumPoint (sumPoint p1 p2) p3)))) (set! i (+ i 1)))))))))))))))))) (loop63)) (quote ()))))) (loop63)))) (ret62 newPts))))))))
(define (key a b) (call/cc (lambda (ret65) (begin (if (< a b) (begin (ret65 (string-append (string-append (to-str a) ",") (to-str b)))) (quote ())) (ret65 (string-append (string-append (to-str b) ",") (to-str a)))))))
(define (cmcSubdiv points faces) (call/cc (lambda (ret66) (let ((facePoints (getFacePoints points faces))) (begin (let ((edgesFaces (getEdgesFaces points faces))) (begin (let ((edgePoints (getEdgePoints points edgesFaces facePoints))) (begin (let ((avgFacePoints (getAvgFacePoints points faces facePoints))) (begin (let ((avgMidEdges (getAvgMidEdges points edgesFaces))) (begin (let ((pointsFaces (getPointsFaces points faces))) (begin (let ((newPoints (getNewPoints points pointsFaces avgFacePoints avgMidEdges))) (begin (let ((facePointNums (_list))) (begin (let ((nextPoint (cond ((string? newPoints) (string-length newPoints)) ((hash-table? newPoints) (hash-table-size newPoints)) (else (length newPoints))))) (begin (call/cc (lambda (break68) (letrec ((loop67 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((fp (car xs))) (begin (set! newPoints (append newPoints (_list fp))) (set! facePointNums (append facePointNums (_list nextPoint))) (set! nextPoint (+ nextPoint 1)))) (loop67 (cdr xs))))))) (loop67 facePoints)))) (let ((edgePointNums (alist->hash-table (_list)))) (begin (let ((idx 0)) (begin (call/cc (lambda (break70) (letrec ((loop69 (lambda () (if (< idx (cond ((string? edgesFaces) (string-length edgesFaces)) ((hash-table? edgesFaces) (hash-table-size edgesFaces)) (else (length edgesFaces)))) (begin (let ((e (cond ((string? edgesFaces) (_substring edgesFaces idx (+ idx 1))) ((hash-table? edgesFaces) (hash-table-ref edgesFaces idx)) (else (list-ref edgesFaces idx))))) (begin (set! newPoints (append newPoints (_list (cond ((string? edgePoints) (_substring edgePoints idx (+ idx 1))) ((hash-table? edgePoints) (hash-table-ref edgePoints idx)) (else (list-ref edgePoints idx)))))) (hash-table-set! edgePointNums (key (hash-table-ref e "pn1") (hash-table-ref e "pn2")) nextPoint) (set! nextPoint (+ nextPoint 1)) (set! idx (+ idx 1)))) (loop69)) (quote ()))))) (loop69)))) (let ((newFaces (_list))) (begin (let ((fnum 0)) (begin (call/cc (lambda (break72) (letrec ((loop71 (lambda () (if (< fnum (cond ((string? faces) (string-length faces)) ((hash-table? faces) (hash-table-size faces)) (else (length faces)))) (begin (let ((oldFace (list-ref faces fnum))) (begin (if (equal? (cond ((string? oldFace) (string-length oldFace)) ((hash-table? oldFace) (hash-table-size oldFace)) (else (length oldFace))) 4) (begin (let ((a (list-ref oldFace 0))) (begin (let ((b (list-ref oldFace 1))) (begin (let ((c (list-ref oldFace 2))) (begin (let ((d (list-ref oldFace 3))) (begin (let ((fpnum (list-ref facePointNums fnum))) (begin (let ((ab (hash-table-ref/default edgePointNums (key a b) (quote ())))) (begin (let ((da (hash-table-ref/default edgePointNums (key d a) (quote ())))) (begin (let ((bc (hash-table-ref/default edgePointNums (key b c) (quote ())))) (begin (let ((cd (hash-table-ref/default edgePointNums (key c d) (quote ())))) (begin (set! newFaces (append newFaces (_list (_list a ab fpnum da)))) (set! newFaces (append newFaces (_list (_list b bc fpnum ab)))) (set! newFaces (append newFaces (_list (_list c cd fpnum bc)))) (set! newFaces (append newFaces (_list (_list d da fpnum cd))))))))))))))))))))))) (quote ())) (set! fnum (+ fnum 1)))) (loop71)) (quote ()))))) (loop71)))) (ret66 (_list newPoints newFaces)))))))))))))))))))))))))))))))
(define (formatPoint p) (call/cc (lambda (ret73) (ret73 (string-append (string-append (string-append (string-append (string-append (string-append "[" (fmt4 (hash-table-ref p "x"))) " ") (fmt4 (hash-table-ref p "y"))) " ") (fmt4 (hash-table-ref p "z"))) "]")))))
(define (formatFace f) (call/cc (lambda (ret74) (begin (if (equal? (cond ((string? f) (string-length f)) ((hash-table? f) (hash-table-size f)) (else (length f))) 0) (begin (ret74 "[]")) (quote ())) (let ((s (string-append "[" (fmt2 (list-ref f 0))))) (begin (let ((i 1)) (begin (call/cc (lambda (break76) (letrec ((loop75 (lambda () (if (< i (cond ((string? f) (string-length f)) ((hash-table? f) (hash-table-size f)) (else (length f)))) (begin (set! s (string-append (string-append s " ") (fmt2 (list-ref f i)))) (set! i (+ i 1)) (loop75)) (quote ()))))) (loop75)))) (set! s (string-append s "]")) (ret74 s)))))))))
(define (main) (call/cc (lambda (ret77) (let ((inputPoints (_list (alist->hash-table (_list (cons "x" (- 1.0)) (cons "y" 1.0) (cons "z" 1.0))) (alist->hash-table (_list (cons "x" (- 1.0)) (cons "y" (- 1.0)) (cons "z" 1.0))) (alist->hash-table (_list (cons "x" 1.0) (cons "y" (- 1.0)) (cons "z" 1.0))) (alist->hash-table (_list (cons "x" 1.0) (cons "y" 1.0) (cons "z" 1.0))) (alist->hash-table (_list (cons "x" 1.0) (cons "y" (- 1.0)) (cons "z" (- 1.0)))) (alist->hash-table (_list (cons "x" 1.0) (cons "y" 1.0) (cons "z" (- 1.0)))) (alist->hash-table (_list (cons "x" (- 1.0)) (cons "y" (- 1.0)) (cons "z" (- 1.0)))) (alist->hash-table (_list (cons "x" (- 1.0)) (cons "y" 1.0) (cons "z" (- 1.0))))))) (begin (let ((inputFaces (_list (_list 0 1 2 3) (_list 3 2 4 5) (_list 5 4 6 7) (_list 7 0 3 5) (_list 7 6 1 0) (_list 6 1 2 4)))) (begin (let ((outputPoints inputPoints)) (begin (let ((outputFaces inputFaces)) (begin (let ((i 0)) (begin (call/cc (lambda (break79) (letrec ((loop78 (lambda () (if (< i 1) (begin (let ((res (cmcSubdiv outputPoints outputFaces))) (begin (set! outputPoints (cond ((string? res) (_substring res 0 (+ 0 1))) ((hash-table? res) (hash-table-ref res 0)) (else (list-ref res 0)))) (set! outputFaces (cond ((string? res) (_substring res 1 (+ 1 1))) ((hash-table? res) (hash-table-ref res 1)) (else (list-ref res 1)))) (set! i (+ i 1)))) (loop78)) (quote ()))))) (loop78)))) (call/cc (lambda (break81) (letrec ((loop80 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((p (car xs))) (begin (_display (to-str (formatPoint p))) (newline))) (loop80 (cdr xs))))))) (loop80 outputPoints)))) (_display (to-str "")) (newline) (call/cc (lambda (break83) (letrec ((loop82 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((f (car xs))) (begin (_display (to-str (formatFace f))) (newline))) (loop82 (cdr xs))))))) (loop82 outputFaces)))))))))))))))))
(main)
