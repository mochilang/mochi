;; Generated on 2025-07-25 21:06 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (randInt s n)
 (call/cc (lambda (ret1)
 (let ((next (modulo (+ (* s 1664525)
 1013904223)
 2147483647)
)
)
 (begin (ret1 (_list next (modulo next n)
)
)
)
)
)
)
)
(define (padLeft s w)
 (call/cc (lambda (ret2)
 (let ((res "")
)
 (begin (let ((n (- w (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
)
)
 (begin (call/cc (lambda (break4)
 (letrec ((loop3 (lambda ()
 (if (> n 0)
 (begin (set! res (string-append res " ")
)
 (set! n (- n 1)
)
 (loop3)
)
 (quote ()
)
)
)
)
)
 (loop3)
)
)
)
 (ret2 (string-append res s)
)
)
)
)
)
)
)
)
(define (makeSeq s le)
 (call/cc (lambda (ret5)
 (let ((bases "ACGT")
)
 (begin (let ((out "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break7)
 (letrec ((loop6 (lambda ()
 (if (< i le)
 (begin (let ((r (randInt s 4)
)
)
 (begin (set! s (cond ((string? r)
 (substring r 0 (+ 0 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 0)
)
 (else (list-ref r 0)
)
)
)
 (let ((idx (let ((v8 (cond ((string? r)
 (substring r 1 (+ 1 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 1)
)
 (else (list-ref r 1)
)
)
)
)
 (cond ((string? v8)
 (inexact->exact (string->number v8)
)
)
 ((boolean? v8)
 (if v8 1 0)
)
 (else (inexact->exact v8)
)
)
)
)
)
 (begin (set! out (string-append out (substring bases idx (+ idx 1)
)
)
)
 (set! i (+ i 1)
)
)
)
)
)
 (loop6)
)
 (quote ()
)
)
)
)
)
 (loop6)
)
)
)
 (ret5 (_list s out)
)
)
)
)
)
)
)
)
)
)
(define (mutate s dna w)
 (call/cc (lambda (ret9)
 (let ((bases "ACGT")
)
 (begin (let ((le (cond ((string? dna)
 (string-length dna)
)
 ((hash-table? dna)
 (hash-table-size dna)
)
 (else (length dna)
)
)
)
)
 (begin (let ((r (randInt s le)
)
)
 (begin (set! s (cond ((string? r)
 (substring r 0 (+ 0 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 0)
)
 (else (list-ref r 0)
)
)
)
 (let ((p (let ((v10 (cond ((string? r)
 (substring r 1 (+ 1 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 1)
)
 (else (list-ref r 1)
)
)
)
)
 (cond ((string? v10)
 (inexact->exact (string->number v10)
)
)
 ((boolean? v10)
 (if v10 1 0)
)
 (else (inexact->exact v10)
)
)
)
)
)
 (begin (set! r (randInt s 300)
)
 (set! s (cond ((string? r)
 (substring r 0 (+ 0 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 0)
)
 (else (list-ref r 0)
)
)
)
 (let ((x (let ((v11 (cond ((string? r)
 (substring r 1 (+ 1 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 1)
)
 (else (list-ref r 1)
)
)
)
)
 (cond ((string? v11)
 (inexact->exact (string->number v11)
)
)
 ((boolean? v11)
 (if v11 1 0)
)
 (else (inexact->exact v11)
)
)
)
)
)
 (begin (let ((arr (_list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break13)
 (letrec ((loop12 (lambda ()
 (if (< i le)
 (begin (set! arr (append arr (_list (substring dna i (+ i 1)
)
)
)
)
 (set! i (+ i 1)
)
 (loop12)
)
 (quote ()
)
)
)
)
)
 (loop12)
)
)
)
 (if (< x (list-ref w 0)
)
 (begin (set! r (randInt s 4)
)
 (set! s (cond ((string? r)
 (substring r 0 (+ 0 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 0)
)
 (else (list-ref r 0)
)
)
)
 (let ((idx (let ((v14 (cond ((string? r)
 (substring r 1 (+ 1 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 1)
)
 (else (list-ref r 1)
)
)
)
)
 (cond ((string? v14)
 (inexact->exact (string->number v14)
)
)
 ((boolean? v14)
 (if v14 1 0)
)
 (else (inexact->exact v14)
)
)
)
)
)
 (begin (let ((b (substring bases idx (+ idx 1)
)
)
)
 (begin (display (to-str (string-append (string-append (string-append (string-append (string-append (string-append "  Change @" (padLeft (to-str p)
 3)
)
 " '")
 (list-ref arr p)
)
 "' to '")
 b)
 "'")
)
)
 (newline)
 (list-set! arr p b)
)
)
)
)
)
 (if (< x (+ (list-ref w 0)
 (list-ref w 1)
)
)
 (begin (display (to-str (string-append (string-append (string-append (string-append "  Delete @" (padLeft (to-str p)
 3)
)
 " '")
 (list-ref arr p)
)
 "'")
)
)
 (newline)
 (let ((j p)
)
 (begin (call/cc (lambda (break16)
 (letrec ((loop15 (lambda ()
 (if (< j (- (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
 1)
)
 (begin (list-set! arr j (list-ref arr (+ j 1)
)
)
 (set! j (+ j 1)
)
 (loop15)
)
 (quote ()
)
)
)
)
)
 (loop15)
)
)
)
 (set! arr (take (drop arr 0)
 (- (- (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
 1)
 0)
)
)
)
)
)
 (begin (set! r (randInt s 4)
)
 (set! s (cond ((string? r)
 (substring r 0 (+ 0 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 0)
)
 (else (list-ref r 0)
)
)
)
 (let ((idx2 (let ((v17 (cond ((string? r)
 (substring r 1 (+ 1 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 1)
)
 (else (list-ref r 1)
)
)
)
)
 (cond ((string? v17)
 (inexact->exact (string->number v17)
)
)
 ((boolean? v17)
 (if v17 1 0)
)
 (else (inexact->exact v17)
)
)
)
)
)
 (begin (let ((b (substring bases idx2 (+ idx2 1)
)
)
)
 (begin (set! arr (append arr (_list "")
)
)
 (let ((j (- (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
 1)
)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda ()
 (if (> j p)
 (begin (list-set! arr j (list-ref arr (- j 1)
)
)
 (set! j (- j 1)
)
 (loop18)
)
 (quote ()
)
)
)
)
)
 (loop18)
)
)
)
 (display (to-str (string-append (string-append (string-append (string-append "  Insert @" (padLeft (to-str p)
 3)
)
 " '")
 b)
 "'")
)
)
 (newline)
 (list-set! arr p b)
)
)
)
)
)
)
)
)
)
 (let ((out "")
)
 (begin (set! i 0)
 (call/cc (lambda (break21)
 (letrec ((loop20 (lambda ()
 (if (< i (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
)
 (begin (set! out (string-append out (list-ref arr i)
)
)
 (set! i (+ i 1)
)
 (loop20)
)
 (quote ()
)
)
)
)
)
 (loop20)
)
)
)
 (ret9 (_list s out)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (prettyPrint dna rowLen)
 (call/cc (lambda (ret22)
 (begin (display (to-str "SEQUENCE:")
)
 (newline)
 (let ((le (cond ((string? dna)
 (string-length dna)
)
 ((hash-table? dna)
 (hash-table-size dna)
)
 (else (length dna)
)
)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break24)
 (letrec ((loop23 (lambda ()
 (if (< i le)
 (begin (let ((k (+ i rowLen)
)
)
 (begin (if (> k le)
 (begin (set! k le)
)
 (quote ()
)
)
 (display (to-str (string-append (string-append (padLeft (to-str i)
 5)
 ": ")
 (substring dna i k)
)
)
)
 (newline)
 (set! i (+ i rowLen)
)
)
)
 (loop23)
)
 (quote ()
)
)
)
)
)
 (loop23)
)
)
)
 (let ((a 0)
)
 (begin (let ((c 0)
)
 (begin (let ((g 0)
)
 (begin (let ((t 0)
)
 (begin (let ((idx 0)
)
 (begin (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (< idx le)
 (begin (let ((ch (substring dna idx (+ idx 1)
)
)
)
 (begin (if (string=? ch "A")
 (begin (set! a (+ a 1)
)
)
 (begin (if (string=? ch "C")
 (begin (set! c (+ c 1)
)
)
 (begin (if (string=? ch "G")
 (begin (set! g (+ g 1)
)
)
 (begin (if (string=? ch "T")
 (begin (set! t (+ t 1)
)
)
 (quote ()
)
)
)
)
)
)
)
)
 (set! idx (+ idx 1)
)
)
)
 (loop25)
)
 (quote ()
)
)
)
)
)
 (loop25)
)
)
)
 (display (to-str "")
)
 (newline)
 (display (to-str "BASE COUNT:")
)
 (newline)
 (display (to-str (string-append "    A: " (padLeft (to-str a)
 3)
)
)
)
 (newline)
 (display (to-str (string-append "    C: " (padLeft (to-str c)
 3)
)
)
)
 (newline)
 (display (to-str (string-append "    G: " (padLeft (to-str g)
 3)
)
)
)
 (newline)
 (display (to-str (string-append "    T: " (padLeft (to-str t)
 3)
)
)
)
 (newline)
 (display (to-str "    ------")
)
 (newline)
 (display (to-str (string-append "    Î£: " (to-str le)
)
)
)
 (newline)
 (display (to-str "    ======")
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (wstring w)
 (call/cc (lambda (ret27)
 (ret27 (string-append (string-append (string-append (string-append (string-append (string-append "  Change: " (to-str (list-ref w 0)
)
)
 "\n  Delete: ")
 (to-str (list-ref w 1)
)
)
 "\n  Insert: ")
 (to-str (list-ref w 2)
)
)
 "\n")
)
)
)
)
(define (main)
 (call/cc (lambda (ret28)
 (let ((seed 1)
)
 (begin (let ((res (makeSeq seed 250)
)
)
 (begin (set! seed (cond ((string? res)
 (substring res 0 (+ 0 1)
)
)
 ((hash-table? res)
 (hash-table-ref res 0)
)
 (else (list-ref res 0)
)
)
)
 (let ((dna (number->string (cond ((string? res)
 (substring res 1 (+ 1 1)
)
)
 ((hash-table? res)
 (hash-table-ref res 1)
)
 (else (list-ref res 1)
)
)
)
)
)
 (begin (prettyPrint dna 50)
 (let ((muts 10)
)
 (begin (let ((w (_list 100 100 100)
)
)
 (begin (display (to-str "\nWEIGHTS (ex 300)
:")
)
 (newline)
 (display (to-str (wstring w)
)
)
 (newline)
 (display (to-str (string-append (string-append "MUTATIONS (" (to-str muts)
)
 ")
:")
)
)
 (newline)
 (let ((i 0)
)
 (begin (call/cc (lambda (break30)
 (letrec ((loop29 (lambda ()
 (if (< i muts)
 (begin (set! res (mutate seed dna w)
)
 (set! seed (cond ((string? res)
 (substring res 0 (+ 0 1)
)
)
 ((hash-table? res)
 (hash-table-ref res 0)
)
 (else (list-ref res 0)
)
)
)
 (set! dna (number->string (cond ((string? res)
 (substring res 1 (+ 1 1)
)
)
 ((hash-table? res)
 (hash-table-ref res 1)
)
 (else (list-ref res 1)
)
)
)
)
 (set! i (+ i 1)
)
 (loop29)
)
 (quote ()
)
)
)
)
)
 (loop29)
)
)
)
 (display (to-str "")
)
 (newline)
 (prettyPrint dna 50)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
