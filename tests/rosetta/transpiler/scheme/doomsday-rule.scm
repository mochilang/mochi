;; Generated on 2025-07-28 10:03 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (exact (floor (* (current-second) 1000000000))))
)
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(let ((start9 (now)
)
)
 (begin (define (parseIntStr str)
 (call/cc (lambda (ret1)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote ()
)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (_list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
)
 (begin (set! n (_add (* n 10)
 (cond ((string? digits)
 (substring digits (substring str i (+ i 1)
)
 (+ (substring str i (+ i 1)
)
 1)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote ()
)
)
 (ret1 n)
)
)
)
)
)
)
)
)
)
)
)
 (define days (_list "Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday")
)
 (define (anchorDay y)
 (call/cc (lambda (ret4)
 (ret4 (modulo (_add (_add (_add 2 (* 5 (modulo y 4)
)
)
 (* 4 (modulo y 100)
)
)
 (* 6 (modulo y 400)
)
)
 7)
)
)
)
)
 (define (isLeapYear y)
 (call/cc (lambda (ret5)
 (ret5 (and (equal? (modulo y 4)
 0)
 (or (not (equal? (modulo y 100)
 0)
)
 (equal? (modulo y 400)
 0)
)
)
)
)
)
)
 (define firstDaysCommon (_list 3 7 7 4 2 6 4 1 5 3 7 5)
)
 (define firstDaysLeap (_list 4 1 7 4 2 6 4 1 5 3 7 5)
)
 (define (main)
 (call/cc (lambda (ret6)
 (let ((dates (_list "1800-01-06" "1875-03-29" "1915-12-07" "1970-12-23" "2043-05-14" "2077-02-12" "2101-04-02")
)
)
 (begin (_display (to-str "Days of week given by Doomsday rule:")
)
 (newline)
 (call/cc (lambda (break8)
 (letrec ((loop7 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((date (car xs)
)
)
 (begin (let ((y (_parseIntStr (if (string? date)
 (substring date 0 4)
 (take (drop date 0)
 (- 4 0)
)
)
 10)
)
)
 (begin (let ((m (- (_parseIntStr (if (string? date)
 (substring date 5 7)
 (take (drop date 5)
 (- 7 5)
)
)
 10)
 1)
)
)
 (begin (let ((d (_parseIntStr (if (string? date)
 (substring date 8 10)
 (take (drop date 8)
 (- 10 8)
)
)
 10)
)
)
 (begin (let ((a (anchorDay y)
)
)
 (begin (let ((f (list-ref firstDaysCommon m)
)
)
 (begin (if (isLeapYear y)
 (begin (set! f (list-ref firstDaysLeap m)
)
)
 (quote ()
)
)
 (let ((w (- d f)
)
)
 (begin (if (_lt w 0)
 (begin (set! w (_add 7 w)
)
)
 (quote ()
)
)
 (let ((dow (modulo (_add a w)
 7)
)
)
 (begin (_display (to-str (string-append (string-append date " -> ")
 (list-ref days dow)
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (loop7 (cdr xs)
)
)
)
)
)
)
 (loop7 dates)
)
)
)
)
)
)
)
)
 (main)
 (let ((end10 (now)
)
)
 (let ((dur11 (quotient (- end10 start9)
 1000)
)
)
 (begin (_display (string-append "{\n  \"duration_us\": " (number->string dur11)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
