;; Generated on 2025-07-22 21:48 +0700
(import (only (scheme base) call/cc list-ref list-set! list))
(import (scheme time))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (shuffle xs)
 (let ((arr xs)
 (i 99)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if (> i 0)
 (begin (let ((j (modulo (current-jiffy)
 (+ i 1)
)
)
 (tmp (list-ref arr i)
)
)
 (begin (list-set! arr i (list-ref arr j)
)
 (list-set! arr j tmp)
 (set! i (- i 1)
)
)
)
 (loop17)
)
 (quote nil)
)
)
)
)
 (loop17)
)
)
)
 arr)
)
)
(define (doTrials trials np strategy)
 (let ((pardoned 0)
 (t 0)
)
 (begin (call/cc (lambda (break20)
 (letrec ((loop19 (lambda ()
 (if (< t trials)
 (begin (let ((drawers (list)
)
 (i 0)
)
 (begin (call/cc (lambda (break22)
 (letrec ((loop21 (lambda ()
 (if (< i 100)
 (begin (set! drawers (append drawers (list i)
)
)
 (set! i (+ i 1)
)
 (loop21)
)
 (quote nil)
)
)
)
)
 (loop21)
)
)
)
 (set! drawers (shuffle drawers)
)
 (define p 0)
 (define success #t)
 (call/cc (lambda (break24)
 (letrec ((loop23 (lambda ()
 (if (< p np)
 (begin (let ((found #f)
)
 (begin (if (string=? strategy "optimal")
 (begin (let ((prev p)
 (d 0)
)
 (begin (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (< d 50)
 (begin (let ((this (list-ref drawers prev)
)
)
 (begin (if (= this p)
 (begin (set! found #t)
 (break26 (quote nil)
)
)
 (quote nil)
)
 (set! prev this)
 (set! d (+ d 1)
)
)
)
 (loop25)
)
 (quote nil)
)
)
)
)
 (loop25)
)
)
)
)
)
)
 (begin (let ((opened (list)
)
 (k 0)
)
 (begin (call/cc (lambda (break28)
 (letrec ((loop27 (lambda ()
 (if (< k 100)
 (begin (set! opened (append opened (list #f)
)
)
 (set! k (+ k 1)
)
 (loop27)
)
 (quote nil)
)
)
)
)
 (loop27)
)
)
)
 (define d 0)
 (call/cc (lambda (break30)
 (letrec ((loop29 (lambda ()
 (if (< d 50)
 (begin (let ((n (modulo (current-jiffy)
 100)
)
)
 (begin (call/cc (lambda (break32)
 (letrec ((loop31 (lambda ()
 (if (list-ref opened n)
 (begin (set! n (modulo (current-jiffy)
 100)
)
 (loop31)
)
 (quote nil)
)
)
)
)
 (loop31)
)
)
)
 (list-set! opened n #t)
 (if (= (list-ref drawers n)
 p)
 (begin (set! found #t)
 (break30 (quote nil)
)
)
 (quote nil)
)
 (set! d (+ d 1)
)
)
)
 (loop29)
)
 (quote nil)
)
)
)
)
 (loop29)
)
)
)
)
)
)
)
 (if (not found)
 (begin (set! success #f)
 (break24 (quote nil)
)
)
 (quote nil)
)
 (set! p (+ p 1)
)
)
)
 (loop23)
)
 (quote nil)
)
)
)
)
 (loop23)
)
)
)
 (if success (begin (set! pardoned (+ pardoned 1)
)
)
 (quote nil)
)
 (set! t (+ t 1)
)
)
)
 (loop19)
)
 (quote nil)
)
)
)
)
 (loop19)
)
)
)
 (define rf (* (quotient pardoned trials)
 100.0)
)
 (display (to-str (string-append (string-append (string-append (string-append (string-append (string-append "  strategy = " strategy)
 "  pardoned = ")
 (number->string pardoned)
)
 " relative frequency = ")
 (number->string rf)
)
 "%")
)
)
 (newline)
)
)
)
(define (main)
 (let ((trials 1000)
)
 (begin (call/cc (lambda (break34)
 (letrec ((loop33 (lambda (xs)
 (if (null? xs)
 (quote nil)
 (begin (let ((np (car xs)
)
)
 (begin (display (to-str (string-append (string-append (string-append (string-append "Results from " (number->string trials)
)
 " trials with ")
 (number->string np)
)
 " prisoners:\n")
)
)
 (newline)
 (call/cc (lambda (break36)
 (letrec ((loop35 (lambda (xs)
 (if (null? xs)
 (quote nil)
 (begin (let ((strat (car xs)
)
)
 (begin (doTrials trials np strat)
)
)
 (loop35 (cdr xs)
)
)
)
)
)
)
 (loop35 (list "random" "optimal")
)
)
)
)
)
)
 (loop33 (cdr xs)
)
)
)
)
)
)
 (loop33 (list 10 100)
)
)
)
)
)
)
)
(main)
