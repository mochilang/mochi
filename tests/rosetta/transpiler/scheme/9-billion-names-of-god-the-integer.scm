;; Generated on 2025-07-23 13:04 +0700
(import (only (scheme base) call/cc list-ref list-set! list))
(import (scheme time))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (bigTrim a)
 (call/cc (lambda (ret1)
 (let ((n (length a)
)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (and (> n 1)
 (= (list-ref a (- n 1)
)
 0)
)
 (begin (set! a (take (drop a 0)
 (- (- n 1)
 0)
)
)
 (set! n (- n 1)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (ret1 a)
)
)
)
)
)
(define (bigFromInt x)
 (call/cc (lambda (ret4)
 (begin (if (= x 0)
 (begin (ret4 (list 0)
)
)
 (quote nil)
)
 (let ((digits (list)
)
)
 (begin (let ((n x)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (> n 0)
 (begin (set! digits (append digits (list (modulo n 10)
)
)
)
 (set! n (quotient n 10)
)
 (loop5)
)
 (quote nil)
)
)
)
)
 (loop5)
)
)
)
 (ret4 digits)
)
)
)
)
)
)
)
)
(define (bigAdd a b)
 (call/cc (lambda (ret7)
 (let ((res (list)
)
)
 (begin (let ((carry 0)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (or (or (< i (length a)
)
 (< i (length b)
)
)
 (> carry 0)
)
 (begin (let ((av 0)
)
 (begin (if (< i (length a)
)
 (begin (set! av (list-ref a i)
)
)
 (quote nil)
)
 (let ((bv 0)
)
 (begin (if (< i (length b)
)
 (begin (set! bv (list-ref b i)
)
)
 (quote nil)
)
 (let ((s (+ (+ av bv)
 carry)
)
)
 (begin (set! res (append res (list (modulo s 10)
)
)
)
 (set! carry (quotient s 10)
)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop8)
)
 (quote nil)
)
)
)
)
 (loop8)
)
)
)
 (ret7 (bigTrim res)
)
)
)
)
)
)
)
)
)
)
(define (bigSub a b)
 (call/cc (lambda (ret10)
 (let ((res (list)
)
)
 (begin (let ((borrow 0)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (< i (length a)
)
 (begin (let ((av (list-ref a i)
)
)
 (begin (let ((bv 0)
)
 (begin (if (< i (length b)
)
 (begin (set! bv (list-ref b i)
)
)
 (quote nil)
)
 (let ((diff (- (- av bv)
 borrow)
)
)
 (begin (if (< diff 0)
 (begin (set! diff (+ diff 10)
)
 (set! borrow 1)
)
 (begin (set! borrow 0)
)
)
 (set! res (append res (list diff)
)
)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop11)
)
 (quote nil)
)
)
)
)
 (loop11)
)
)
)
 (ret10 (bigTrim res)
)
)
)
)
)
)
)
)
)
)
(define (bigToString a)
 (call/cc (lambda (ret13)
 (let ((s "")
)
 (begin (let ((i (- (length a)
 1)
)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if (>= i 0)
 (begin (set! s (string-append s (number->string (list-ref a i)
)
)
)
 (set! i (- i 1)
)
 (loop14)
)
 (quote nil)
)
)
)
)
 (loop14)
)
)
)
 (ret13 s)
)
)
)
)
)
)
)
(define (minInt a b)
 (call/cc (lambda (ret16)
 (if (< a b)
 (begin (ret16 a)
)
 (begin (ret16 b)
)
)
)
)
)
(define (cumu n)
 (call/cc (lambda (ret17)
 (let ((cache (list (list (bigFromInt 1)
)
)
)
)
 (begin (let ((y 1)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda ()
 (if (<= y n)
 (begin (let ((row (list (bigFromInt 0)
)
)
)
 (begin (let ((x 1)
)
 (begin (call/cc (lambda (break21)
 (letrec ((loop20 (lambda ()
 (if (<= x y)
 (begin (let ((val (cond ((string? (list-ref cache (- y x)
)
)
 (string-ref (list-ref cache (- y x)
)
 (minInt x (- y x)
)
)
)
 ((hash-table? (list-ref cache (- y x)
)
)
 (hash-table-ref (list-ref cache (- y x)
)
 (minInt x (- y x)
)
)
)
 (else (list-ref (list-ref cache (- y x)
)
 (minInt x (- y x)
)
)
)
)
)
)
 (begin (set! row (append row (list (bigAdd (list-ref row (- (length row)
 1)
)
 val)
)
)
)
 (set! x (+ x 1)
)
)
)
 (loop20)
)
 (quote nil)
)
)
)
)
 (loop20)
)
)
)
 (set! cache (append cache (list row)
)
)
 (set! y (+ y 1)
)
)
)
)
)
 (loop18)
)
 (quote nil)
)
)
)
)
 (loop18)
)
)
)
 (ret17 (list-ref cache n)
)
)
)
)
)
)
)
)
(define (row n)
 (call/cc (lambda (ret22)
 (let ((e (cumu n)
)
)
 (begin (let ((out (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break24)
 (letrec ((loop23 (lambda ()
 (if (< i n)
 (begin (let ((diff (bigSub (list-ref e (+ i 1)
)
 (list-ref e i)
)
)
)
 (begin (set! out (append out (list (bigToString diff)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop23)
)
 (quote nil)
)
)
)
)
 (loop23)
)
)
)
 (ret22 out)
)
)
)
)
)
)
)
)
)
(display (to-str "rows:")
)
(newline)
(define x 1)
(call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (< x 11)
 (begin (let ((r (row x)
)
)
 (begin (let ((line "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break28)
 (letrec ((loop27 (lambda ()
 (if (< i (length r)
)
 (begin (set! line (string-append (string-append (string-append line " ")
 (list-ref r i)
)
 " ")
)
 (set! i (+ i 1)
)
 (loop27)
)
 (quote nil)
)
)
)
)
 (loop27)
)
)
)
 (display (to-str line)
)
 (newline)
 (set! x (+ x 1)
)
)
)
)
)
)
)
 (loop25)
)
 (quote nil)
)
)
)
)
 (loop25)
)
)
)
(display (to-str "")
)
(newline)
(display (to-str "sums:")
)
(newline)
(call/cc (lambda (break30)
 (letrec ((loop29 (lambda (xs)
 (if (null? xs)
 (quote nil)
 (begin (let ((num (car xs)
)
)
 (begin (let ((r (cumu num)
)
)
 (begin (display (to-str (string-append (string-append (number->string num)
 " ")
 (bigToString (list-ref r (- (length r)
 1)
)
)
)
)
)
 (newline)
)
)
)
)
 (loop29 (cdr xs)
)
)
)
)
)
)
 (loop29 (list 23 123 1234)
)
)
)
)
