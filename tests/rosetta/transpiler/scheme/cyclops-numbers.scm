;; Generated on 2025-07-28 11:25 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((idx (string-contains r del)))
            (if idx
                (loop (substring r (+ idx (string-length del)))
                      (cons (substring r 0 idx) acc))
                (reverse (cons r acc)))))))))
(define (digits n)
 (call/cc (lambda (ret1)
 (begin (if (equal? n 0)
 (begin (ret1 (_list 0)
)
)
 (quote ()
)
)
 (let ((rev (_list)
)
)
 (begin (let ((x n)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (> x 0)
 (begin (set! rev (append rev (_list (modulo x 10)
)
)
)
 (set! x (let ((v4 (quotient x 10)
)
)
 (cond ((string? v4)
 (inexact->exact (floor (string->number v4)
)
)
)
 ((boolean? v4)
 (if v4 1 0)
)
 (else (inexact->exact (floor v4)
)
)
)
)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (let ((out (_list)
)
)
 (begin (let ((i (- (cond ((string? rev)
 (string-length rev)
)
 ((hash-table? rev)
 (hash-table-size rev)
)
 (else (length rev)
)
)
 1)
)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (>= i 0)
 (begin (set! out (append out (_list (list-ref rev i)
)
)
)
 (set! i (- i 1)
)
 (loop5)
)
 (quote ()
)
)
)
)
)
 (loop5)
)
)
)
 (ret1 out)
)
)
)
)
)
)
)
)
)
)
)
)
(define (commatize n)
 (call/cc (lambda (ret7)
 (let ((s (to-str n)
)
)
 (begin (let ((out "")
)
 (begin (let ((i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (> i 3)
 (begin (set! out (string-append (string-append "," (substring s (- i 3)
 i)
)
 out)
)
 (set! i (- i 3)
)
 (loop8)
)
 (quote ()
)
)
)
)
)
 (loop8)
)
)
)
 (set! out (string-append (substring s 0 i)
 out)
)
 (ret7 out)
)
)
)
)
)
)
)
)
)
(define (isPrime n)
 (call/cc (lambda (ret10)
 (begin (if (< n 2)
 (begin (ret10 #f)
)
 (quote ()
)
)
 (if (equal? (modulo n 2)
 0)
 (begin (ret10 (equal? n 2)
)
)
 (quote ()
)
)
 (if (equal? (modulo n 3)
 0)
 (begin (ret10 (equal? n 3)
)
)
 (quote ()
)
)
 (let ((d 5)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (_le (* d d)
 n)
 (begin (if (equal? (modulo n d)
 0)
 (begin (ret10 #f)
)
 (quote ()
)
)
 (set! d (+ d 2)
)
 (if (equal? (modulo n d)
 0)
 (begin (ret10 #f)
)
 (quote ()
)
)
 (set! d (+ d 4)
)
 (loop11)
)
 (quote ()
)
)
)
)
)
 (loop11)
)
)
)
 (ret10 #t)
)
)
)
)
)
)
(define (split s sep)
 (call/cc (lambda (ret13)
 (let ((parts (_list)
)
)
 (begin (let ((cur "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (if (and (_le (+ i (cond ((string? sep)
 (string-length sep)
)
 ((hash-table? sep)
 (hash-table-size sep)
)
 (else (length sep)
)
)
)
 (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (string=? (substring s i (+ i (cond ((string? sep)
 (string-length sep)
)
 ((hash-table? sep)
 (hash-table-size sep)
)
 (else (length sep)
)
)
)
)
 sep)
)
 (begin (set! parts (append parts (_list cur)
)
)
 (set! cur "")
 (set! i (+ i (cond ((string? sep)
 (string-length sep)
)
 ((hash-table? sep)
 (hash-table-size sep)
)
 (else (length sep)
)
)
)
)
)
 (begin (set! cur (string-append cur (substring s i (+ i 1)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop14)
)
 (quote ()
)
)
)
)
)
 (loop14)
)
)
)
 (set! parts (append parts (_list cur)
)
)
 (ret13 parts)
)
)
)
)
)
)
)
)
)
(define (parseIntStr str)
 (call/cc (lambda (ret16)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote ()
)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (_list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if (< i (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
)
 (begin (set! n (_add (* n 10)
 (cond ((string? digits)
 (substring digits (substring str i (+ i 1)
)
 (+ (substring str i (+ i 1)
)
 1)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop17)
)
 (quote ()
)
)
)
)
)
 (loop17)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote ()
)
)
 (ret16 n)
)
)
)
)
)
)
)
)
)
)
)
(define (reverseStr s)
 (call/cc (lambda (ret19)
 (let ((out "")
)
 (begin (let ((i (- (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 1)
)
)
 (begin (call/cc (lambda (break21)
 (letrec ((loop20 (lambda ()
 (if (>= i 0)
 (begin (set! out (string-append out (substring s i (+ i 1)
)
)
)
 (set! i (- i 1)
)
 (loop20)
)
 (quote ()
)
)
)
)
)
 (loop20)
)
)
)
 (ret19 out)
)
)
)
)
)
)
)
(define (pad s w)
 (call/cc (lambda (ret22)
 (let ((out s)
)
 (begin (call/cc (lambda (break24)
 (letrec ((loop23 (lambda ()
 (if (< (cond ((string? out)
 (string-length out)
)
 ((hash-table? out)
 (hash-table-size out)
)
 (else (length out)
)
)
 w)
 (begin (set! out (string-append " " out)
)
 (loop23)
)
 (quote ()
)
)
)
)
)
 (loop23)
)
)
)
 (ret22 out)
)
)
)
)
)
(define (findFirst list)
 (call/cc (lambda (ret25)
 (let ((i 0)
)
 (begin (call/cc (lambda (break27)
 (letrec ((loop26 (lambda ()
 (if (< i (cond ((string? list)
 (string-length list)
)
 ((hash-table? list)
 (hash-table-size list)
)
 (else (length list)
)
)
)
 (begin (if (> (list-ref list i)
 10000000)
 (begin (ret25 (_list (list-ref list i)
 i)
)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop26)
)
 (quote ()
)
)
)
)
)
 (loop26)
)
)
)
 (ret25 (_list (- 1)
 (- 1)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret28)
 (let ((ranges (_list (_list 0 0)
 (_list 101 909)
 (_list 11011 99099)
 (_list 1110111 9990999)
 (_list 111101111 119101111)
)
)
)
 (begin (let ((cyclops (_list)
)
)
 (begin (call/cc (lambda (break30)
 (letrec ((loop29 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((r (car xs)
)
)
 (begin (let ((start (cond ((string? r)
 (substring r 0 (+ 0 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 0)
)
 (else (list-ref r 0)
)
)
)
)
 (begin (let ((end (cond ((string? r)
 (substring r 1 (+ 1 1)
)
)
 ((hash-table? r)
 (hash-table-ref r 1)
)
 (else (list-ref r 1)
)
)
)
)
 (begin (let ((numDigits (cond ((string? (to-str start)
)
 (string-length (to-str start)
)
)
 ((hash-table? (to-str start)
)
 (hash-table-size (to-str start)
)
)
 (else (length (to-str start)
)
)
)
)
)
 (begin (let ((center (quotient numDigits 2)
)
)
 (begin (let ((i start)
)
 (begin (call/cc (lambda (break32)
 (letrec ((loop31 (lambda ()
 (if (_le i end)
 (begin (let ((ds (digits i)
)
)
 (begin (if (equal? (cond ((string? ds)
 (substring ds center (+ center 1)
)
)
 ((hash-table? ds)
 (hash-table-ref ds center)
)
 (else (list-ref ds center)
)
)
 0)
 (begin (let ((count 0)
)
 (begin (call/cc (lambda (break34)
 (letrec ((loop33 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((d (car xs)
)
)
 (begin (if (equal? d 0)
 (begin (set! count (+ count 1)
)
)
 (quote ()
)
)
)
)
 (loop33 (cdr xs)
)
)
)
)
)
)
 (loop33 ds)
)
)
)
 (if (equal? count 1)
 (begin (set! cyclops (append cyclops (_list i)
)
)
)
 (quote ()
)
)
)
)
)
 (quote ()
)
)
 (set! i (_add i 1)
)
)
)
 (loop31)
)
 (quote ()
)
)
)
)
)
 (loop31)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (loop29 (cdr xs)
)
)
)
)
)
)
 (loop29 ranges)
)
)
)
 (_display (to-str "The first 50 cyclops numbers are:")
)
 (newline)
 (let ((idx 0)
)
 (begin (call/cc (lambda (break36)
 (letrec ((loop35 (lambda ()
 (if (< idx 50)
 (begin (_display (to-str (string-append (pad (commatize (list-ref cyclops idx)
)
 6)
 " ")
)
)
 (newline)
 (set! idx (+ idx 1)
)
 (if (equal? (modulo idx 10)
 0)
 (begin (_display (to-str "\n")
)
 (newline)
)
 (quote ()
)
)
 (loop35)
)
 (quote ()
)
)
)
)
)
 (loop35)
)
)
)
 (let ((fi (findFirst cyclops)
)
)
 (begin (_display (to-str (string-append (string-append (string-append "\nFirst such number > 10 million is " (commatize (cond ((string? fi)
 (substring fi 0 (+ 0 1)
)
)
 ((hash-table? fi)
 (hash-table-ref fi 0)
)
 (else (list-ref fi 0)
)
)
)
)
 " at zero-based index ")
 (commatize (cond ((string? fi)
 (substring fi 1 (+ 1 1)
)
)
 ((hash-table? fi)
 (hash-table-ref fi 1)
)
 (else (list-ref fi 1)
)
)
)
)
)
)
 (newline)
 (let ((primes (_list)
)
)
 (begin (call/cc (lambda (break38)
 (letrec ((loop37 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((n (car xs)
)
)
 (begin (if (isPrime n)
 (begin (set! primes (append primes (_list n)
)
)
)
 (quote ()
)
)
)
)
 (loop37 (cdr xs)
)
)
)
)
)
)
 (loop37 cyclops)
)
)
)
 (_display (to-str "\n\nThe first 50 prime cyclops numbers are:")
)
 (newline)
 (set! idx 0)
 (call/cc (lambda (break40)
 (letrec ((loop39 (lambda ()
 (if (< idx 50)
 (begin (_display (to-str (string-append (pad (commatize (list-ref primes idx)
)
 6)
 " ")
)
)
 (newline)
 (set! idx (+ idx 1)
)
 (if (equal? (modulo idx 10)
 0)
 (begin (_display (to-str "\n")
)
 (newline)
)
 (quote ()
)
)
 (loop39)
)
 (quote ()
)
)
)
)
)
 (loop39)
)
)
)
 (let ((fp (findFirst primes)
)
)
 (begin (_display (to-str (string-append (string-append (string-append "\nFirst such number > 10 million is " (commatize (cond ((string? fp)
 (substring fp 0 (+ 0 1)
)
)
 ((hash-table? fp)
 (hash-table-ref fp 0)
)
 (else (list-ref fp 0)
)
)
)
)
 " at zero-based index ")
 (commatize (cond ((string? fp)
 (substring fp 1 (+ 1 1)
)
)
 ((hash-table? fp)
 (hash-table-ref fp 1)
)
 (else (list-ref fp 1)
)
)
)
)
)
)
 (newline)
 (let ((bpcyclops (_list)
)
)
 (begin (let ((ppcyclops (_list)
)
)
 (begin (call/cc (lambda (break42)
 (letrec ((loop41 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((p (car xs)
)
)
 (begin (let ((ps (to-str p)
)
)
 (begin (let ((splitp (_split ps "0")
)
)
 (begin (let ((noMiddle (_parseIntStr (_add (cond ((string? splitp)
 (substring splitp 0 (+ 0 1)
)
)
 ((hash-table? splitp)
 (hash-table-ref splitp 0)
)
 (else (list-ref splitp 0)
)
)
 (cond ((string? splitp)
 (substring splitp 1 (+ 1 1)
)
)
 ((hash-table? splitp)
 (hash-table-ref splitp 1)
)
 (else (list-ref splitp 1)
)
)
)
 10)
)
)
 (begin (if (isPrime noMiddle)
 (begin (set! bpcyclops (append bpcyclops (_list p)
)
)
)
 (quote ()
)
)
 (if (string=? ps (reverseStr ps)
)
 (begin (set! ppcyclops (append ppcyclops (_list p)
)
)
)
 (quote ()
)
)
)
)
)
)
)
)
)
)
 (loop41 (cdr xs)
)
)
)
)
)
)
 (loop41 primes)
)
)
)
 (_display (to-str "\n\nThe first 50 blind prime cyclops numbers are:")
)
 (newline)
 (set! idx 0)
 (call/cc (lambda (break44)
 (letrec ((loop43 (lambda ()
 (if (< idx 50)
 (begin (_display (to-str (string-append (pad (commatize (list-ref bpcyclops idx)
)
 6)
 " ")
)
)
 (newline)
 (set! idx (+ idx 1)
)
 (if (equal? (modulo idx 10)
 0)
 (begin (_display (to-str "\n")
)
 (newline)
)
 (quote ()
)
)
 (loop43)
)
 (quote ()
)
)
)
)
)
 (loop43)
)
)
)
 (let ((fb (findFirst bpcyclops)
)
)
 (begin (_display (to-str (string-append (string-append (string-append "\nFirst such number > 10 million is " (commatize (cond ((string? fb)
 (substring fb 0 (+ 0 1)
)
)
 ((hash-table? fb)
 (hash-table-ref fb 0)
)
 (else (list-ref fb 0)
)
)
)
)
 " at zero-based index ")
 (commatize (cond ((string? fb)
 (substring fb 1 (+ 1 1)
)
)
 ((hash-table? fb)
 (hash-table-ref fb 1)
)
 (else (list-ref fb 1)
)
)
)
)
)
)
 (newline)
 (_display (to-str "\n\nThe first 50 palindromic prime cyclops numbers are:")
)
 (newline)
 (set! idx 0)
 (call/cc (lambda (break46)
 (letrec ((loop45 (lambda ()
 (if (< idx 50)
 (begin (_display (to-str (string-append (pad (commatize (list-ref ppcyclops idx)
)
 9)
 " ")
)
)
 (newline)
 (set! idx (+ idx 1)
)
 (if (equal? (modulo idx 8)
 0)
 (begin (_display (to-str "\n")
)
 (newline)
)
 (quote ()
)
)
 (loop45)
)
 (quote ()
)
)
)
)
)
 (loop45)
)
)
)
 (let ((fpp (findFirst ppcyclops)
)
)
 (begin (_display (to-str (string-append (string-append (string-append "\n\nFirst such number > 10 million is " (commatize (cond ((string? fpp)
 (substring fpp 0 (+ 0 1)
)
)
 ((hash-table? fpp)
 (hash-table-ref fpp 0)
)
 (else (list-ref fpp 0)
)
)
)
)
 " at zero-based index ")
 (commatize (cond ((string? fpp)
 (substring fpp 1 (+ 1 1)
)
)
 ((hash-table? fpp)
 (hash-table-ref fpp 1)
)
 (else (list-ref fpp 1)
)
)
)
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
