;; Generated on 2025-07-23 12:44 +0700
(import (only (scheme base) call/cc list-ref list-set! list))
(import (scheme time))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define OP_NUM 0)
(define OP_ADD 1)
(define OP_SUB 2)
(define OP_MUL 3)
(define OP_DIV 4)
(define (newNum n)
 (call/cc (lambda (ret1)
 (ret1 (alist->hash-table (list (cons "op" OP_NUM)
 (cons "value" (alist->hash-table (list (cons "num" n)
 (cons "denom" 1)
)
)
)
)
)
)
)
)
)
(define (exprEval x)
 (call/cc (lambda (ret2)
 (begin (if (= (hash-table-ref x "op")
 OP_NUM)
 (begin (ret2 (hash-table-ref x "value")
)
)
 (quote nil)
)
 (let ((l (exprEval (hash-table-ref x "left")
)
)
)
 (begin (let ((r (exprEval (hash-table-ref x "right")
)
)
)
 (begin (if (= (hash-table-ref x "op")
 OP_ADD)
 (begin (ret2 (alist->hash-table (list (cons "num" (+ (* (hash-table-ref l "num")
 (hash-table-ref r "denom")
)
 (* (hash-table-ref l "denom")
 (hash-table-ref r "num")
)
)
)
 (cons "denom" (* (hash-table-ref l "denom")
 (hash-table-ref r "denom")
)
)
)
)
)
)
 (quote nil)
)
 (if (= (hash-table-ref x "op")
 OP_SUB)
 (begin (ret2 (alist->hash-table (list (cons "num" (- (* (hash-table-ref l "num")
 (hash-table-ref r "denom")
)
 (* (hash-table-ref l "denom")
 (hash-table-ref r "num")
)
)
)
 (cons "denom" (* (hash-table-ref l "denom")
 (hash-table-ref r "denom")
)
)
)
)
)
)
 (quote nil)
)
 (if (= (hash-table-ref x "op")
 OP_MUL)
 (begin (ret2 (alist->hash-table (list (cons "num" (* (hash-table-ref l "num")
 (hash-table-ref r "num")
)
)
 (cons "denom" (* (hash-table-ref l "denom")
 (hash-table-ref r "denom")
)
)
)
)
)
)
 (quote nil)
)
 (ret2 (alist->hash-table (list (cons "num" (* (hash-table-ref l "num")
 (hash-table-ref r "denom")
)
)
 (cons "denom" (* (hash-table-ref l "denom")
 (hash-table-ref r "num")
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (exprString x)
 (call/cc (lambda (ret3)
 (begin (if (= (hash-table-ref x "op")
 OP_NUM)
 (begin (ret3 (number->string (cond ((string? (hash-table-ref x "value")
)
 (string-ref (hash-table-ref x "value")
 "num")
)
 ((hash-table? (hash-table-ref x "value")
)
 (hash-table-ref (hash-table-ref x "value")
 "num")
)
 (else (list-ref (hash-table-ref x "value")
 "num")
)
)
)
)
)
 (quote nil)
)
 (let ((ls (exprString (hash-table-ref x "left")
)
)
)
 (begin (let ((rs (exprString (hash-table-ref x "right")
)
)
)
 (begin (let ((opstr "")
)
 (begin (if (= (hash-table-ref x "op")
 OP_ADD)
 (begin (set! opstr " + ")
)
 (if (= (hash-table-ref x "op")
 OP_SUB)
 (begin (set! opstr " - ")
)
 (if (= (hash-table-ref x "op")
 OP_MUL)
 (begin (set! opstr " * ")
)
 (begin (set! opstr " / ")
)
)
)
)
 (ret3 (string-append (string-append (string-append (string-append "(" ls)
 opstr)
 rs)
 ")
")
)
)
)
)
)
)
)
)
)
)
)
(define n_cards 4)
(define goal 24)
(define digit_range 9)
(define (solve xs)
 (call/cc (lambda (ret4)
 (begin (if (= (length xs)
 1)
 (begin (let ((f (exprEval (list-ref xs 0)
)
)
)
 (begin (if (and (not (= (hash-table-ref f "denom")
 0)
)
 (= (hash-table-ref f "num")
 (* (hash-table-ref f "denom")
 goal)
)
)
 (begin (display (to-str (exprString (list-ref xs 0)
)
)
)
 (newline)
 (ret4 #t)
)
 (quote nil)
)
 (ret4 #f)
)
)
)
 (quote nil)
)
 (let ((i 0)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (< i (length xs)
)
 (begin (let ((j (+ i 1)
)
)
 (begin (call/cc (lambda (break8)
 (letrec ((loop7 (lambda ()
 (if (< j (length xs)
)
 (begin (let ((rest (list)
)
)
 (begin (let ((k 0)
)
 (begin (call/cc (lambda (break10)
 (letrec ((loop9 (lambda ()
 (if (< k (length xs)
)
 (begin (if (and (not (= k i)
)
 (not (= k j)
)
)
 (begin (set! rest (append rest (list (list-ref xs k)
)
)
)
)
 (quote nil)
)
 (set! k (+ k 1)
)
 (loop9)
)
 (quote nil)
)
)
)
)
 (loop9)
)
)
)
 (let ((a (list-ref xs i)
)
)
 (begin (let ((b (list-ref xs j)
)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda (xs)
 (if (null? xs)
 (quote nil)
 (begin (let ((op (car xs)
)
)
 (begin (let ((node (alist->hash-table (list (cons "op" op)
 (cons "left" a)
 (cons "right" b)
)
)
)
)
 (begin (if (solve (append rest (list node)
)
)
 (begin (ret4 #t)
)
 (quote nil)
)
)
)
)
)
 (loop11 (cdr xs)
)
)
)
)
)
)
 (loop11 (list OP_ADD OP_SUB OP_MUL OP_DIV)
)
)
)
)
 (let ((node (alist->hash-table (list (cons "op" OP_SUB)
 (cons "left" b)
 (cons "right" a)
)
)
)
)
 (begin (if (solve (append rest (list node)
)
)
 (begin (ret4 #t)
)
 (quote nil)
)
 (set! node (alist->hash-table (list (cons "op" OP_DIV)
 (cons "left" b)
 (cons "right" a)
)
)
)
 (if (solve (append rest (list node)
)
)
 (begin (ret4 #t)
)
 (quote nil)
)
 (set! j (+ j 1)
)
)
)
)
)
)
)
)
)
)
)
 (loop7)
)
 (quote nil)
)
)
)
)
 (loop7)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop5)
)
 (quote nil)
)
)
)
)
 (loop5)
)
)
)
 (ret4 #f)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret13)
 (let ((iter 0)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if (< iter 10)
 (begin (let ((cards (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break17)
 (letrec ((loop16 (lambda ()
 (if (< i n_cards)
 (begin (let ((n (+ (modulo (current-jiffy)
 (- digit_range 1)
)
 1)
)
)
 (begin (set! cards (append cards (list (newNum n)
)
)
)
 (display (to-str (string-append " " (number->string n)
)
)
)
 (newline)
 (set! i (+ i 1)
)
)
)
 (loop16)
)
 (quote nil)
)
)
)
)
 (loop16)
)
)
)
 (display (to-str ":  ")
)
 (newline)
 (if (not (solve cards)
)
 (begin (display (to-str "No solution")
)
 (newline)
)
 (quote nil)
)
 (set! iter (+ iter 1)
)
)
)
)
)
 (loop14)
)
 (quote nil)
)
)
)
)
 (loop14)
)
)
)
)
)
)
)
)
(main)
