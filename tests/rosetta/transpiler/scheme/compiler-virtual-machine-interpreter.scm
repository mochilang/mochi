;; Generated on 2025-08-01 18:55 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(import (srfi 1))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (exact (floor (* (current-second) 1000000000))))
)
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(let ((start29 (now))) (begin (define (parseIntStr str) (call/cc (lambda (ret1) (let ((i 0)) (begin (let ((neg #f)) (begin (if (and (> (cond ((string? str) (string-length str)) ((hash-table? str) (hash-table-size str)) (else (length str))) 0) (string=? (_substring str 0 1) "-")) (begin (set! neg #t) (set! i 1)) (quote ())) (let ((n 0)) (begin (let ((digits (alist->hash-table (_list (cons "0" 0) (cons "1" 1) (cons "2" 2) (cons "3" 3) (cons "4" 4) (cons "5" 5) (cons "6" 6) (cons "7" 7) (cons "8" 8) (cons "9" 9))))) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda () (if (< i (cond ((string? str) (string-length str)) ((hash-table? str) (hash-table-size str)) (else (length str)))) (begin (set! n (_add (* n 10) (cond ((string? digits) (_substring digits (_substring str i (+ i 1)) (+ (_substring str i (+ i 1)) 1))) ((hash-table? digits) (hash-table-ref digits (_substring str i (+ i 1)))) (else (list-ref digits (_substring str i (+ i 1))))))) (set! i (+ i 1)) (loop2)) (quote ()))))) (loop2)))) (if neg (begin (set! n (- n))) (quote ())) (ret1 n)))))))))))) (define (fields s) (call/cc (lambda (ret4) (let ((words (_list))) (begin (let ((cur "")) (begin (let ((i 0)) (begin (call/cc (lambda (break6) (letrec ((loop5 (lambda () (if (< i (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))) (begin (let ((ch (_substring s i (+ i 1)))) (begin (if (or (or (string=? ch " ") (string=? ch "\t")) (string=? ch "\n")) (begin (if (> (cond ((string? cur) (string-length cur)) ((hash-table? cur) (hash-table-size cur)) (else (length cur))) 0) (begin (set! words (append words (_list cur))) (set! cur "")) (quote ()))) (begin (set! cur (string-append cur ch)))) (set! i (+ i 1)))) (loop5)) (quote ()))))) (loop5)))) (if (> (cond ((string? cur) (string-length cur)) ((hash-table? cur) (hash-table-size cur)) (else (length cur))) 0) (begin (set! words (append words (_list cur)))) (quote ())) (ret4 words)))))))))) (define (unescape s) (call/cc (lambda (ret7) (let ((out "")) (begin (let ((i 0)) (begin (call/cc (lambda (break9) (letrec ((loop8 (lambda () (if (< i (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))) (begin (if (and (string=? (_substring s i (+ i 1)) "\\") (_lt (+ i 1) (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))))) (begin (let ((c (_substring s (+ i 1) (+ i 2)))) (begin (if (string=? c "n") (begin (set! out (string-append out "\n")) (set! i (+ i 2)) (loop8)) (if (string=? c "\\") (begin (set! out (string-append out "\\")) (set! i (+ i 2)) (loop8)) (quote ())))))) (quote ())) (set! out (string-append out (_substring s i (+ i 1)))) (set! i (+ i 1)) (loop8)) (quote ()))))) (loop8)))) (ret7 out)))))))) (define (parseProgram src) (call/cc (lambda (ret10) (let ((lines (split src "\n"))) (begin (let ((header (fields (list-ref lines 0)))) (begin (let ((dataSize (parseIntStr (cond ((string? header) (_substring header 1 (+ 1 1))) ((hash-table? header) (hash-table-ref header 1)) (else (list-ref header 1)))))) (begin (let ((nStrings (parseIntStr (cond ((string? header) (_substring header 3 (+ 3 1))) ((hash-table? header) (hash-table-ref header 3)) (else (list-ref header 3)))))) (begin (let ((stringPool (_list))) (begin (let ((i 1)) (begin (call/cc (lambda (break12) (letrec ((loop11 (lambda () (if (_le i nStrings) (begin (let ((s (list-ref lines i))) (begin (if (> (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))) 0) (begin (set! stringPool (append stringPool (_list (unescape (_substring s 1 (- (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))) 1))))))) (quote ())) (set! i (+ i 1)))) (loop11)) (quote ()))))) (loop11)))) (let ((code (_list))) (begin (let ((addrMap (alist->hash-table (_list)))) (begin (call/cc (lambda (break14) (letrec ((loop13 (lambda () (if (< i (cond ((string? lines) (string-length lines)) ((hash-table? lines) (hash-table-size lines)) (else (length lines)))) (begin (let ((line (trim (list-ref lines i)))) (begin (if (equal? (cond ((string? line) (string-length line)) ((hash-table? line) (hash-table-size line)) (else (length line))) 0) (begin (break14 (quote ()))) (quote ())) (let ((parts (fields line))) (begin (let ((addr (parseIntStr (cond ((string? parts) (_substring parts 0 (+ 0 1))) ((hash-table? parts) (hash-table-ref parts 0)) (else (list-ref parts 0)))))) (begin (let ((op (cond ((string? parts) (_substring parts 1 (+ 1 1))) ((hash-table? parts) (hash-table-ref parts 1)) (else (list-ref parts 1))))) (begin (let ((arg 0)) (begin (if (string=? op "push") (begin (set! arg (parseIntStr (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2)))))) (if (or (string=? op "fetch") (string=? op "store")) (begin (set! arg (parseIntStr (if (string? (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2)))) (_substring (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2))) 1 (- (cond ((string? (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2)))) (string-length (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2))))) ((hash-table? (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2)))) (hash-table-size (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2))))) (else (length (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2)))))) 1)) (take (drop (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2))) 1) (- (- (cond ((string? (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2)))) (string-length (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2))))) ((hash-table? (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2)))) (hash-table-size (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2))))) (else (length (cond ((string? parts) (_substring parts 2 (+ 2 1))) ((hash-table? parts) (hash-table-ref parts 2)) (else (list-ref parts 2)))))) 1) 1)))))) (if (or (string=? op "jmp") (string=? op "jz")) (begin (set! arg (parseIntStr (cond ((string? parts) (_substring parts 3 (+ 3 1))) ((hash-table? parts) (hash-table-ref parts 3)) (else (list-ref parts 3)))))) (quote ())))) (set! code (append code (_list (alist->hash-table (_list (cons "addr" addr) (cons "op" op) (cons "arg" arg)))))) (hash-table-set! addrMap addr (- (cond ((string? code) (string-length code)) ((hash-table? code) (hash-table-size code)) (else (length code))) 1)) (set! i (+ i 1)))))))))))) (loop13)) (quote ()))))) (loop13)))) (ret10 (alist->hash-table (_list (cons "dataSize" dataSize) (cons "strings" stringPool) (cons "code" code) (cons "addrMap" addrMap))))))))))))))))))))))) (define (runVM prog) (call/cc (lambda (ret15) (let ((data (_list))) (begin (let ((i 0)) (begin (call/cc (lambda (break17) (letrec ((loop16 (lambda () (if (_lt i (hash-table-ref/default prog "dataSize" (quote ()))) (begin (set! data (append data (_list 0))) (set! i (+ i 1)) (loop16)) (quote ()))))) (loop16)))) (let ((stack (_list))) (begin (let ((pc 0)) (begin (let ((code (hash-table-ref/default prog "code" (quote ())))) (begin (let ((addrMap (hash-table-ref/default prog "addrMap" (quote ())))) (begin (let ((pool (hash-table-ref/default prog "strings" (quote ())))) (begin (let ((line "")) (begin (call/cc (lambda (break19) (letrec ((loop18 (lambda () (if (< pc (cond ((string? code) (string-length code)) ((hash-table? code) (hash-table-size code)) (else (length code)))) (begin (let ((inst (cond ((string? code) (_substring code pc (+ pc 1))) ((hash-table? code) (hash-table-ref code pc)) (else (list-ref code pc))))) (begin (let ((op (cond ((string? inst) (_substring inst "op" (+ "op" 1))) ((hash-table? inst) (hash-table-ref inst "op")) (else (list-ref inst "op"))))) (begin (let ((arg (cond ((string? inst) (_substring inst "arg" (+ "arg" 1))) ((hash-table? inst) (hash-table-ref inst "arg")) (else (list-ref inst "arg"))))) (begin (if (string=? op "push") (begin (set! stack (append stack (_list arg))) (set! pc (+ pc 1)) (loop18)) (quote ())) (if (string=? op "store") (begin (list-set! data arg (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))) (set! stack (slice stack 0 (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))) (set! pc (+ pc 1)) (loop18)) (quote ())) (if (string=? op "fetch") (begin (set! stack (append stack (_list (list-ref data arg)))) (set! pc (+ pc 1)) (loop18)) (quote ())) (if (string=? op "add") (begin (list-set! stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 2) (+ (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 2)) (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1)))) (set! stack (slice stack 0 (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))) (set! pc (+ pc 1)) (loop18)) (quote ())) (if (string=? op "lt") (begin (let ((v 0)) (begin (if (< (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 2)) (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))) (begin (set! v 1)) (quote ())) (list-set! stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 2) v) (set! stack (slice stack 0 (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))) (set! pc (+ pc 1)) (loop18)))) (quote ())) (if (string=? op "jz") (begin (let ((v (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1)))) (begin (set! stack (slice stack 0 (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))) (if (equal? v 0) (begin (set! pc (cond ((string? addrMap) (_substring addrMap arg (+ arg 1))) ((hash-table? addrMap) (hash-table-ref addrMap arg)) (else (list-ref addrMap arg))))) (begin (set! pc (+ pc 1)))) (loop18)))) (quote ())) (if (string=? op "jmp") (begin (set! pc (cond ((string? addrMap) (_substring addrMap arg (+ arg 1))) ((hash-table? addrMap) (hash-table-ref addrMap arg)) (else (list-ref addrMap arg)))) (loop18)) (quote ())) (if (string=? op "prts") (begin (let ((s (cond ((string? pool) (_substring pool (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1)) (+ (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1)) 1))) ((hash-table? pool) (hash-table-ref pool (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1)))) (else (list-ref pool (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))))))) (begin (set! stack (slice stack 0 (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))) (if (not (string=? s "\n")) (begin (set! line (string-append line s))) (quote ())) (set! pc (+ pc 1)) (loop18)))) (quote ())) (if (string=? op "prti") (begin (set! line (string-append line (to-str (list-ref stack (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))))) (_display (to-str line)) (newline) (set! line "") (set! stack (slice stack 0 (- (cond ((string? stack) (string-length stack)) ((hash-table? stack) (hash-table-size stack)) (else (length stack))) 1))) (set! pc (+ pc 1)) (loop18)) (quote ())) (if (string=? op "halt") (begin (break19 (quote ()))) (quote ())) (set! pc (+ pc 1)))))))) (loop18)) (quote ()))))) (loop18))))))))))))))))))))))) (define (trim s) (call/cc (lambda (ret20) (let ((start 0)) (begin (call/cc (lambda (break22) (letrec ((loop21 (lambda () (if (and (< start (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))) (or (string=? (_substring s start (+ start 1)) " ") (string=? (_substring s start (+ start 1)) "\t"))) (begin (set! start (+ start 1)) (loop21)) (quote ()))))) (loop21)))) (let ((end (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))))) (begin (call/cc (lambda (break24) (letrec ((loop23 (lambda () (if (and (> end start) (or (string=? (_substring s (- end 1) end) " ") (string=? (_substring s (- end 1) end) "\t"))) (begin (set! end (- end 1)) (loop23)) (quote ()))))) (loop23)))) (ret20 (_substring s start end))))))))) (define (split s sep) (call/cc (lambda (ret25) (let ((parts (_list))) (begin (let ((cur "")) (begin (let ((i 0)) (begin (call/cc (lambda (break27) (letrec ((loop26 (lambda () (if (< i (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))) (begin (if (and (and (> (cond ((string? sep) (string-length sep)) ((hash-table? sep) (hash-table-size sep)) (else (length sep))) 0) (_le (+ i (cond ((string? sep) (string-length sep)) ((hash-table? sep) (hash-table-size sep)) (else (length sep)))) (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))))) (string=? (_substring s i (+ i (cond ((string? sep) (string-length sep)) ((hash-table? sep) (hash-table-size sep)) (else (length sep))))) sep)) (begin (set! parts (append parts (_list cur))) (set! cur "") (set! i (+ i (cond ((string? sep) (string-length sep)) ((hash-table? sep) (hash-table-size sep)) (else (length sep)))))) (begin (set! cur (string-append cur (_substring s i (+ i 1)))) (set! i (+ i 1)))) (loop26)) (quote ()))))) (loop26)))) (set! parts (append parts (_list cur))) (ret25 parts)))))))))) (define (main) (call/cc (lambda (ret28) (let ((programText "Datasize: 1 Strings: 2\n\"count is: \"\n\"\\n\"\n    0 push  1\n    5 store [0]\n   10 fetch [0]\n   15 push  10\n   20 lt\n   21 jz     (43) 65\n   26 push  0\n   31 prts\n   32 fetch [0]\n   37 prti\n   38 push  1\n   43 prts\n   44 fetch [0]\n   49 push  1\n   54 add\n   55 store [0]\n   60 jmp    (-51) 10\n   65 halt\n")) (begin (let ((prog (parseProgram programText))) (begin (runVM prog)))))))) (main) (let ((end30 (now))) (let ((dur31 (quotient (- end30 start29) 1000))) (begin (_display (string-append "{\n  \"duration_us\": " (number->string dur31) ",\n  \"memory_bytes\": " (number->string (_mem)) ",\n  \"name\": \"main\"\n}")) (newline))))))
