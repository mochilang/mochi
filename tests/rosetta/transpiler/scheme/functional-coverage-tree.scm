;; Generated on 2025-08-04 16:05 +0700
(import (scheme base))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(import (srfi 1))
(define _list list)
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(define (_len x)
  (cond ((string? x) (string-length x))
        ((hash-table? x) (hash-table-size x))
        (else (length x))))
(define (pow10 n) (call/cc (lambda (ret1) (let ((r 1.0)) (begin (let ((i 0)) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda () (if (< i n) (begin (set! r (* r 10.0)) (set! i (+ i 1)) (loop2)) (quote ()))))) (loop2)))) (ret1 r))))))))
(define (formatFloat f prec) (call/cc (lambda (ret4) (let ((scale (pow10 prec))) (begin (let ((scaled (_add (* f scale) 0.5))) (begin (let ((n (let ((v5 scaled)) (cond ((string? v5) (inexact->exact (floor (string->number v5)))) ((boolean? v5) (if v5 1 0)) (else (inexact->exact (floor v5))))))) (begin (let ((digits (to-str n))) (begin (call/cc (lambda (break7) (letrec ((loop6 (lambda () (if (<= (_len digits) prec) (begin (set! digits (string-append "0" digits)) (loop6)) (quote ()))))) (loop6)))) (let ((intPart (_substring digits 0 (- (_len digits) prec)))) (begin (let ((fracPart (_substring digits (- (_len digits) prec) (_len digits)))) (begin (ret4 (string-append (string-append intPart ".") fracPart)))))))))))))))))
(define (padLeft s w) (call/cc (lambda (ret8) (let ((res "")) (begin (let ((n (- w (_len s)))) (begin (call/cc (lambda (break10) (letrec ((loop9 (lambda () (if (> n 0) (begin (set! res (string-append res " ")) (set! n (- n 1)) (loop9)) (quote ()))))) (loop9)))) (ret8 (string-append res s)))))))))
(define (repeat ch n) (call/cc (lambda (ret11) (let ((s "")) (begin (let ((i 0)) (begin (call/cc (lambda (break13) (letrec ((loop12 (lambda () (if (< i n) (begin (set! s (string-append s ch)) (set! i (+ i 1)) (loop12)) (quote ()))))) (loop12)))) (ret11 s))))))))
(define (toFloat i) (call/cc (lambda (ret14) (ret14 (+ 0.0 i)))))
(define (newNode name weight coverage) (call/cc (lambda (ret15) (ret15 (alist->hash-table (_list (cons "name" name) (cons "weight" weight) (cons "coverage" coverage) (cons "children" (_list))))))))
(define (addChildren n nodes) (call/cc (lambda (ret16) (let ((cs (hash-table-ref/default n "children" (quote ())))) (begin (call/cc (lambda (break18) (letrec ((loop17 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((node (car xs))) (begin (set! cs (append cs (_list node))))) (loop17 (cdr xs))))))) (loop17 nodes)))) (hash-table-set! n "children" cs))))))
(define (setCoverage n value) (call/cc (lambda (ret19) (hash-table-set! n "coverage" value))))
(define (computeCoverage n) (call/cc (lambda (ret20) (let ((cs (hash-table-ref/default n "children" (quote ())))) (begin (if (equal? (_len cs) 0) (begin (ret20 (+ 0.0 (hash-table-ref/default n "coverage" (quote ()))))) (quote ())) (let ((v1 0.0)) (begin (let ((v2 0)) (begin (call/cc (lambda (break22) (letrec ((loop21 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((node (car xs))) (begin (let ((m node)) (begin (let ((c (computeCoverage m))) (begin (set! v1 (_add v1 (* (toFloat (let ((v23 (hash-table-ref/default m "weight" (quote ())))) (cond ((string? v23) (inexact->exact (floor (string->number v23)))) ((boolean? v23) (if v23 1 0)) (else (inexact->exact (floor v23)))))) c))) (set! v2 (+ v2 (let ((v24 (hash-table-ref/default m "weight" (quote ())))) (cond ((string? v24) (inexact->exact (floor (string->number v24)))) ((boolean? v24) (if v24 1 0)) (else (inexact->exact (floor v24))))))))))))) (loop21 (cdr xs))))))) (loop21 cs)))) (ret20 (/ v1 (toFloat v2))))))))))))
(define (spaces n) (call/cc (lambda (ret25) (ret25 (repeat " " n)))))
(define (show n level) (call/cc (lambda (ret26) (let ((indent (* level 4))) (begin (let ((name (to-str (hash-table-ref/default n "name" (quote ()))))) (begin (let ((nl (+ (_len name) indent))) (begin (let ((line (string-append (spaces indent) name))) (begin (set! line (string-append (_add line (spaces (- 32 nl))) "|  ")) (set! line (string-append (_add line (padLeft (to-str (let ((v27 (hash-table-ref/default n "weight" (quote ())))) (cond ((string? v27) (inexact->exact (floor (string->number v27)))) ((boolean? v27) (if v27 1 0)) (else (inexact->exact (floor v27)))))) 3)) "   | ")) (set! line (string-append (_add line (formatFloat (computeCoverage n) 6)) " |")) (_display (to-str line)) (newline) (let ((cs (hash-table-ref/default n "children" (quote ())))) (begin (call/cc (lambda (break29) (letrec ((loop28 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((child (car xs))) (begin (show child (+ level 1)))) (loop28 (cdr xs))))))) (loop28 cs)))))))))))))))))
(let ((house1 (newNode "house1" 40 0.0))) (begin (let ((house2 (newNode "house2" 60 0.0))) (begin (let ((h1_bedrooms (newNode "bedrooms" 1 0.25))) (begin (let ((h1_bathrooms (newNode "bathrooms" 1 0.0))) (begin (let ((h1_attic (newNode "attic" 1 0.75))) (begin (let ((h1_kitchen (newNode "kitchen" 1 0.1))) (begin (let ((h1_living_rooms (newNode "living_rooms" 1 0.0))) (begin (let ((h1_basement (newNode "basement" 1 0.0))) (begin (let ((h1_garage (newNode "garage" 1 0.0))) (begin (let ((h1_garden (newNode "garden" 1 0.8))) (begin (let ((h2_upstairs (newNode "upstairs" 1 0.0))) (begin (let ((h2_groundfloor (newNode "groundfloor" 1 0.0))) (begin (let ((h2_basement (newNode "basement" 1 0.0))) (begin (let ((h1_bathroom1 (newNode "bathroom1" 1 0.5))) (begin (let ((h1_bathroom2 (newNode "bathroom2" 1 0.0))) (begin (let ((h1_outside (newNode "outside_lavatory" 1 1.0))) (begin (let ((h1_lounge (newNode "lounge" 1 0.0))) (begin (let ((h1_dining (newNode "dining_room" 1 0.0))) (begin (let ((h1_conservatory (newNode "conservatory" 1 0.0))) (begin (let ((h1_playroom (newNode "playroom" 1 1.0))) (begin (let ((h2_bedrooms (newNode "bedrooms" 1 0.0))) (begin (let ((h2_bathroom (newNode "bathroom" 1 0.0))) (begin (let ((h2_toilet (newNode "toilet" 1 0.0))) (begin (let ((h2_attics (newNode "attics" 1 0.6))) (begin (let ((h2_kitchen (newNode "kitchen" 1 0.0))) (begin (let ((h2_living_rooms (newNode "living_rooms" 1 0.0))) (begin (let ((h2_wet_room (newNode "wet_room_&_toilet" 1 0.0))) (begin (let ((h2_garage (newNode "garage" 1 0.0))) (begin (let ((h2_garden (newNode "garden" 1 0.9))) (begin (let ((h2_hot_tub (newNode "hot_tub_suite" 1 1.0))) (begin (let ((h2_cellars (newNode "cellars" 1 1.0))) (begin (let ((h2_wine_cellar (newNode "wine_cellar" 1 1.0))) (begin (let ((h2_cinema (newNode "cinema" 1 0.75))) (begin (let ((h2_suite1 (newNode "suite_1" 1 0.0))) (begin (let ((h2_suite2 (newNode "suite_2" 1 0.0))) (begin (let ((h2_bedroom3 (newNode "bedroom_3" 1 0.0))) (begin (let ((h2_bedroom4 (newNode "bedroom_4" 1 0.0))) (begin (let ((h2_lounge (newNode "lounge" 1 0.0))) (begin (let ((h2_dining (newNode "dining_room" 1 0.0))) (begin (let ((h2_conservatory (newNode "conservatory" 1 0.0))) (begin (let ((h2_playroom (newNode "playroom" 1 0.0))) (begin (define (main) (call/cc (lambda (ret30) (let ((cleaning (newNode "cleaning" 1 0.0))) (begin (addChildren h1_bathrooms (_list h1_bathroom1 h1_bathroom2 h1_outside)) (addChildren h1_living_rooms (_list h1_lounge h1_dining h1_conservatory h1_playroom)) (addChildren house1 (_list h1_bedrooms h1_bathrooms h1_attic h1_kitchen h1_living_rooms h1_basement h1_garage h1_garden)) (addChildren h2_bedrooms (_list h2_suite1 h2_suite2 h2_bedroom3 h2_bedroom4)) (addChildren h2_upstairs (_list h2_bedrooms h2_bathroom h2_toilet h2_attics)) (addChildren h2_living_rooms (_list h2_lounge h2_dining h2_conservatory h2_playroom)) (addChildren h2_groundfloor (_list h2_kitchen h2_living_rooms h2_wet_room h2_garage h2_garden h2_hot_tub)) (addChildren h2_basement (_list h2_cellars h2_wine_cellar h2_cinema)) (addChildren house2 (_list h2_upstairs h2_groundfloor h2_basement)) (addChildren cleaning (_list house1 house2)) (let ((topCoverage (computeCoverage cleaning))) (begin (_display (to-str (string-append "TOP COVERAGE = " (formatFloat topCoverage 6)))) (newline) (_display (to-str "")) (newline) (_display (to-str "NAME HIERARCHY                 | WEIGHT | COVERAGE |")) (newline) (show cleaning 0) (setCoverage h2_cinema 1.0) (let ((diff (- (computeCoverage cleaning) topCoverage))) (begin (_display (to-str "")) (newline) (_display (to-str "If the coverage of the Cinema node were increased from 0.75 to 1")) (newline) (_display (to-str (string-append (string-append (string-append "the top level coverage would increase by " (formatFloat diff 6)) " to ") (formatFloat (_add topCoverage diff) 6)))) (newline) (setCoverage h2_cinema 0.75)))))))))) (main)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
