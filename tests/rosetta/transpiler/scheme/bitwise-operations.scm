;; Generated on 2025-07-27 16:25 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (inexact->exact (* (current-second) 1000000000))))(import (chibi time))
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(let ((start38 (now)
)
)
 (begin (define (toUnsigned16 n)
 (call/cc (lambda (ret1)
 (let ((u n)
)
 (begin (if (< u 0)
 (begin (set! u (+ u 65536)
)
)
 (quote ()
)
)
 (ret1 (modulo u 65536)
)
)
)
)
)
)
 (define (bin16 n)
 (call/cc (lambda (ret2)
 (let ((u (toUnsigned16 n)
)
)
 (begin (let ((bits "")
)
 (begin (let ((mask 32768)
)
 (begin (call/cc (lambda (break4)
 (letrec ((loop3 (lambda (i)
 (if (< i 16)
 (begin (begin (if (_ge u mask)
 (begin (set! bits (string-append bits "1")
)
 (set! u (- u mask)
)
)
 (begin (set! bits (string-append bits "0")
)
)
)
 (set! mask (let ((v5 (quotient mask 2)
)
)
 (cond ((string? v5)
 (inexact->exact (floor (string->number v5)
)
)
)
 ((boolean? v5)
 (if v5 1 0)
)
 (else (inexact->exact (floor v5)
)
)
)
)
)
)
 (loop3 (+ i 1)
)
)
 (quote ()
)
)
)
)
)
 (loop3 0)
)
)
)
 (ret2 bits)
)
)
)
)
)
)
)
)
)
 (define (bit_and a b)
 (call/cc (lambda (ret6)
 (let ((ua (toUnsigned16 a)
)
)
 (begin (let ((ub (toUnsigned16 b)
)
)
 (begin (let ((res 0)
)
 (begin (let ((bit 1)
)
 (begin (call/cc (lambda (break8)
 (letrec ((loop7 (lambda (i)
 (if (< i 16)
 (begin (begin (if (and (equal? (modulo ua 2)
 1)
 (equal? (modulo ub 2)
 1)
)
 (begin (set! res (+ res bit)
)
)
 (quote ()
)
)
 (set! ua (let ((v9 (quotient ua 2)
)
)
 (cond ((string? v9)
 (inexact->exact (floor (string->number v9)
)
)
)
 ((boolean? v9)
 (if v9 1 0)
)
 (else (inexact->exact (floor v9)
)
)
)
)
)
 (set! ub (let ((v10 (quotient ub 2)
)
)
 (cond ((string? v10)
 (inexact->exact (floor (string->number v10)
)
)
)
 ((boolean? v10)
 (if v10 1 0)
)
 (else (inexact->exact (floor v10)
)
)
)
)
)
 (set! bit (* bit 2)
)
)
 (loop7 (+ i 1)
)
)
 (quote ()
)
)
)
)
)
 (loop7 0)
)
)
)
 (ret6 res)
)
)
)
)
)
)
)
)
)
)
)
 (define (bit_or a b)
 (call/cc (lambda (ret11)
 (let ((ua (toUnsigned16 a)
)
)
 (begin (let ((ub (toUnsigned16 b)
)
)
 (begin (let ((res 0)
)
 (begin (let ((bit 1)
)
 (begin (call/cc (lambda (break13)
 (letrec ((loop12 (lambda (i)
 (if (< i 16)
 (begin (begin (if (or (equal? (modulo ua 2)
 1)
 (equal? (modulo ub 2)
 1)
)
 (begin (set! res (+ res bit)
)
)
 (quote ()
)
)
 (set! ua (let ((v14 (quotient ua 2)
)
)
 (cond ((string? v14)
 (inexact->exact (floor (string->number v14)
)
)
)
 ((boolean? v14)
 (if v14 1 0)
)
 (else (inexact->exact (floor v14)
)
)
)
)
)
 (set! ub (let ((v15 (quotient ub 2)
)
)
 (cond ((string? v15)
 (inexact->exact (floor (string->number v15)
)
)
)
 ((boolean? v15)
 (if v15 1 0)
)
 (else (inexact->exact (floor v15)
)
)
)
)
)
 (set! bit (* bit 2)
)
)
 (loop12 (+ i 1)
)
)
 (quote ()
)
)
)
)
)
 (loop12 0)
)
)
)
 (ret11 res)
)
)
)
)
)
)
)
)
)
)
)
 (define (bit_xor a b)
 (call/cc (lambda (ret16)
 (let ((ua (toUnsigned16 a)
)
)
 (begin (let ((ub (toUnsigned16 b)
)
)
 (begin (let ((res 0)
)
 (begin (let ((bit 1)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda (i)
 (if (< i 16)
 (begin (begin (let ((abit (modulo ua 2)
)
)
 (begin (let ((bbit (modulo ub 2)
)
)
 (begin (if (or (and (equal? abit 1)
 (equal? bbit 0)
)
 (and (equal? abit 0)
 (equal? bbit 1)
)
)
 (begin (set! res (+ res bit)
)
)
 (quote ()
)
)
 (set! ua (let ((v19 (quotient ua 2)
)
)
 (cond ((string? v19)
 (inexact->exact (floor (string->number v19)
)
)
)
 ((boolean? v19)
 (if v19 1 0)
)
 (else (inexact->exact (floor v19)
)
)
)
)
)
 (set! ub (let ((v20 (quotient ub 2)
)
)
 (cond ((string? v20)
 (inexact->exact (floor (string->number v20)
)
)
)
 ((boolean? v20)
 (if v20 1 0)
)
 (else (inexact->exact (floor v20)
)
)
)
)
)
 (set! bit (* bit 2)
)
)
)
)
)
)
 (loop17 (+ i 1)
)
)
 (quote ()
)
)
)
)
)
 (loop17 0)
)
)
)
 (ret16 res)
)
)
)
)
)
)
)
)
)
)
)
 (define (bit_not a)
 (call/cc (lambda (ret21)
 (let ((ua (toUnsigned16 a)
)
)
 (begin (ret21 (- 65535 ua)
)
)
)
)
)
)
 (define (shl a b)
 (call/cc (lambda (ret22)
 (let ((ua (toUnsigned16 a)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break24)
 (letrec ((loop23 (lambda ()
 (if (< i b)
 (begin (set! ua (modulo (* ua 2)
 65536)
)
 (set! i (+ i 1)
)
 (loop23)
)
 (quote ()
)
)
)
)
)
 (loop23)
)
)
)
 (ret22 ua)
)
)
)
)
)
)
)
 (define (shr a b)
 (call/cc (lambda (ret25)
 (let ((ua (toUnsigned16 a)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break27)
 (letrec ((loop26 (lambda ()
 (if (< i b)
 (begin (set! ua (let ((v28 (quotient ua 2)
)
)
 (cond ((string? v28)
 (inexact->exact (floor (string->number v28)
)
)
)
 ((boolean? v28)
 (if v28 1 0)
)
 (else (inexact->exact (floor v28)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop26)
)
 (quote ()
)
)
)
)
)
 (loop26)
)
)
)
 (ret25 ua)
)
)
)
)
)
)
)
 (define (las a b)
 (call/cc (lambda (ret29)
 (ret29 (shl a b)
)
)
)
)
 (define (ras a b)
 (call/cc (lambda (ret30)
 (let ((val a)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break32)
 (letrec ((loop31 (lambda ()
 (if (< i b)
 (begin (if (>= val 0)
 (begin (set! val (let ((v33 (quotient val 2)
)
)
 (cond ((string? v33)
 (inexact->exact (floor (string->number v33)
)
)
)
 ((boolean? v33)
 (if v33 1 0)
)
 (else (inexact->exact (floor v33)
)
)
)
)
)
)
 (begin (set! val (let ((v34 (quotient (- val 1)
 2)
)
)
 (cond ((string? v34)
 (inexact->exact (floor (string->number v34)
)
)
)
 ((boolean? v34)
 (if v34 1 0)
)
 (else (inexact->exact (floor v34)
)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop31)
)
 (quote ()
)
)
)
)
)
 (loop31)
)
)
)
 (ret30 (toUnsigned16 val)
)
)
)
)
)
)
)
)
 (define (rol a b)
 (call/cc (lambda (ret35)
 (let ((ua (toUnsigned16 a)
)
)
 (begin (let ((left (shl ua b)
)
)
 (begin (let ((right (shr ua (- 16 b)
)
)
)
 (begin (ret35 (toUnsigned16 (+ left right)
)
)
)
)
)
)
)
)
)
)
)
 (define (ror a b)
 (call/cc (lambda (ret36)
 (let ((ua (toUnsigned16 a)
)
)
 (begin (let ((right (shr ua b)
)
)
 (begin (let ((left (shl ua (- 16 b)
)
)
)
 (begin (ret36 (toUnsigned16 (+ left right)
)
)
)
)
)
)
)
)
)
)
)
 (define (bitwise a b)
 (call/cc (lambda (ret37)
 (begin (_display (to-str (string-append "a:   " (bin16 a)
)
)
)
 (newline)
 (_display (to-str (string-append "b:   " (bin16 b)
)
)
)
 (newline)
 (_display (to-str (string-append "and: " (bin16 (bit_and a b)
)
)
)
)
 (newline)
 (_display (to-str (string-append "or:  " (bin16 (bit_or a b)
)
)
)
)
 (newline)
 (_display (to-str (string-append "xor: " (bin16 (bit_xor a b)
)
)
)
)
 (newline)
 (_display (to-str (string-append "not: " (bin16 (bit_not a)
)
)
)
)
 (newline)
 (if (< b 0)
 (begin (_display (to-str "Right operand is negative, but all shifts require an unsigned right operand (shift distance)
.")
)
 (newline)
 (ret37 (quote ()
)
)
)
 (quote ()
)
)
 (_display (to-str (string-append "shl: " (bin16 (shl a b)
)
)
)
)
 (newline)
 (_display (to-str (string-append "shr: " (bin16 (shr a b)
)
)
)
)
 (newline)
 (_display (to-str (string-append "las: " (bin16 (las a b)
)
)
)
)
 (newline)
 (_display (to-str (string-append "ras: " (bin16 (ras a b)
)
)
)
)
 (newline)
 (_display (to-str (string-append "rol: " (bin16 (rol a b)
)
)
)
)
 (newline)
 (_display (to-str (string-append "ror: " (bin16 (ror a b)
)
)
)
)
 (newline)
)
)
)
)
 (bitwise (- 460)
 6)
 (let ((end39 (now)
)
)
 (let ((dur40 (quotient (- end39 start38)
 1000)
)
)
 (begin (_display (string-append "{\n  \"duration_us\": " (number->string dur40)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
