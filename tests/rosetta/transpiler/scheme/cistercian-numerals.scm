;; Generated on 2025-08-02 23:03 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(import (srfi 1))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(define n (_list))
(define (initN) (call/cc (lambda (ret1) (let ((i 0)) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda () (if (< i 15) (begin (let ((row (_list))) (begin (let ((j 0)) (begin (call/cc (lambda (break5) (letrec ((loop4 (lambda () (if (< j 11) (begin (set! row (append row (_list " "))) (set! j (+ j 1)) (loop4)) (quote ()))))) (loop4)))) (list-set! row 5 "x") (set! n (append n (_list row))) (set! i (+ i 1)))))) (loop2)) (quote ()))))) (loop2)))))))))
(define (horiz c1 c2 r) (call/cc (lambda (ret6) (let ((c c1)) (begin (call/cc (lambda (break8) (letrec ((loop7 (lambda () (if (<= c c2) (begin (list-set! (list-ref n r) c "x") (set! c (+ c 1)) (loop7)) (quote ()))))) (loop7)))))))))
(define (verti r1 r2 c) (call/cc (lambda (ret9) (let ((r r1)) (begin (call/cc (lambda (break11) (letrec ((loop10 (lambda () (if (<= r r2) (begin (list-set! (list-ref n r) c "x") (set! r (+ r 1)) (loop10)) (quote ()))))) (loop10)))))))))
(define (diagd c1 c2 r) (call/cc (lambda (ret12) (let ((c c1)) (begin (call/cc (lambda (break14) (letrec ((loop13 (lambda () (if (<= c c2) (begin (list-set! (list-ref n (- (+ r c) c1)) c "x") (set! c (+ c 1)) (loop13)) (quote ()))))) (loop13)))))))))
(define (diagu c1 c2 r) (call/cc (lambda (ret15) (let ((c c1)) (begin (call/cc (lambda (break17) (letrec ((loop16 (lambda () (if (<= c c2) (begin (list-set! (list-ref n (_add (- r c) c1)) c "x") (set! c (+ c 1)) (loop16)) (quote ()))))) (loop16)))))))))
(define draw (alist->hash-table (_list)))
(define (initDraw) (call/cc (lambda (ret18) (begin (hash-table-set! draw 1 (lambda () (call/cc (lambda (ret19) (horiz 6 10 0))))) (hash-table-set! draw 2 (lambda () (call/cc (lambda (ret20) (horiz 6 10 4))))) (hash-table-set! draw 3 (lambda () (call/cc (lambda (ret21) (diagd 6 10 0))))) (hash-table-set! draw 4 (lambda () (call/cc (lambda (ret22) (diagu 6 10 4))))) (hash-table-set! draw 5 (lambda () (call/cc (lambda (ret23) (begin ((hash-table-ref/default draw 1 (quote ()))) ((hash-table-ref/default draw 4 (quote ())))))))) (hash-table-set! draw 6 (lambda () (call/cc (lambda (ret24) (verti 0 4 10))))) (hash-table-set! draw 7 (lambda () (call/cc (lambda (ret25) (begin ((hash-table-ref/default draw 1 (quote ()))) ((hash-table-ref/default draw 6 (quote ())))))))) (hash-table-set! draw 8 (lambda () (call/cc (lambda (ret26) (begin ((hash-table-ref/default draw 2 (quote ()))) ((hash-table-ref/default draw 6 (quote ())))))))) (hash-table-set! draw 9 (lambda () (call/cc (lambda (ret27) (begin ((hash-table-ref/default draw 1 (quote ()))) ((hash-table-ref/default draw 8 (quote ())))))))) (hash-table-set! draw 10 (lambda () (call/cc (lambda (ret28) (horiz 0 4 0))))) (hash-table-set! draw 20 (lambda () (call/cc (lambda (ret29) (horiz 0 4 4))))) (hash-table-set! draw 30 (lambda () (call/cc (lambda (ret30) (diagu 0 4 4))))) (hash-table-set! draw 40 (lambda () (call/cc (lambda (ret31) (diagd 0 4 0))))) (hash-table-set! draw 50 (lambda () (call/cc (lambda (ret32) (begin ((hash-table-ref/default draw 10 (quote ()))) ((hash-table-ref/default draw 40 (quote ())))))))) (hash-table-set! draw 60 (lambda () (call/cc (lambda (ret33) (verti 0 4 0))))) (hash-table-set! draw 70 (lambda () (call/cc (lambda (ret34) (begin ((hash-table-ref/default draw 10 (quote ()))) ((hash-table-ref/default draw 60 (quote ())))))))) (hash-table-set! draw 80 (lambda () (call/cc (lambda (ret35) (begin ((hash-table-ref/default draw 20 (quote ()))) ((hash-table-ref/default draw 60 (quote ())))))))) (hash-table-set! draw 90 (lambda () (call/cc (lambda (ret36) (begin ((hash-table-ref/default draw 10 (quote ()))) ((hash-table-ref/default draw 80 (quote ())))))))) (hash-table-set! draw 100 (lambda () (call/cc (lambda (ret37) (horiz 6 10 14))))) (hash-table-set! draw 200 (lambda () (call/cc (lambda (ret38) (horiz 6 10 10))))) (hash-table-set! draw 300 (lambda () (call/cc (lambda (ret39) (diagu 6 10 14))))) (hash-table-set! draw 400 (lambda () (call/cc (lambda (ret40) (diagd 6 10 10))))) (hash-table-set! draw 500 (lambda () (call/cc (lambda (ret41) (begin ((hash-table-ref/default draw 100 (quote ()))) ((hash-table-ref/default draw 400 (quote ())))))))) (hash-table-set! draw 600 (lambda () (call/cc (lambda (ret42) (verti 10 14 10))))) (hash-table-set! draw 700 (lambda () (call/cc (lambda (ret43) (begin ((hash-table-ref/default draw 100 (quote ()))) ((hash-table-ref/default draw 600 (quote ())))))))) (hash-table-set! draw 800 (lambda () (call/cc (lambda (ret44) (begin ((hash-table-ref/default draw 200 (quote ()))) ((hash-table-ref/default draw 600 (quote ())))))))) (hash-table-set! draw 900 (lambda () (call/cc (lambda (ret45) (begin ((hash-table-ref/default draw 100 (quote ()))) ((hash-table-ref/default draw 800 (quote ())))))))) (hash-table-set! draw 1000 (lambda () (call/cc (lambda (ret46) (horiz 0 4 14))))) (hash-table-set! draw 2000 (lambda () (call/cc (lambda (ret47) (horiz 0 4 10))))) (hash-table-set! draw 3000 (lambda () (call/cc (lambda (ret48) (diagd 0 4 10))))) (hash-table-set! draw 4000 (lambda () (call/cc (lambda (ret49) (diagu 0 4 14))))) (hash-table-set! draw 5000 (lambda () (call/cc (lambda (ret50) (begin ((hash-table-ref/default draw 1000 (quote ()))) ((hash-table-ref/default draw 4000 (quote ())))))))) (hash-table-set! draw 6000 (lambda () (call/cc (lambda (ret51) (verti 10 14 0))))) (hash-table-set! draw 7000 (lambda () (call/cc (lambda (ret52) (begin ((hash-table-ref/default draw 1000 (quote ()))) ((hash-table-ref/default draw 6000 (quote ())))))))) (hash-table-set! draw 8000 (lambda () (call/cc (lambda (ret53) (begin ((hash-table-ref/default draw 2000 (quote ()))) ((hash-table-ref/default draw 6000 (quote ())))))))) (hash-table-set! draw 9000 (lambda () (call/cc (lambda (ret54) (begin ((hash-table-ref/default draw 1000 (quote ()))) ((hash-table-ref/default draw 8000 (quote ()))))))))))))
(define (printNumeral) (call/cc (lambda (ret55) (let ((i 0)) (begin (call/cc (lambda (break57) (letrec ((loop56 (lambda () (if (< i 15) (begin (let ((line "")) (begin (let ((j 0)) (begin (call/cc (lambda (break59) (letrec ((loop58 (lambda () (if (< j 11) (begin (set! line (string-append (string-append line (cond ((string? (list-ref n i)) (_substring (list-ref n i) j (+ j 1))) ((hash-table? (list-ref n i)) (hash-table-ref (list-ref n i) j)) (else (list-ref (list-ref n i) j)))) " ")) (set! j (+ j 1)) (loop58)) (quote ()))))) (loop58)))) (_display (to-str line)) (newline) (set! i (+ i 1)))))) (loop56)) (quote ()))))) (loop56)))) (_display (to-str "")) (newline))))))
(initDraw)
(define numbers (_list 0 1 20 300 4000 5555 6789 9999))
(call/cc (lambda (break61) (letrec ((loop60 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((number (car xs))) (begin (initN) (_display (to-str (string-append (to-str number) ":"))) (newline) (let ((num number)) (begin (let ((thousands (quotient num 1000))) (begin (set! num (modulo num 1000)) (let ((hundreds (quotient num 100))) (begin (set! num (modulo num 100)) (let ((tens (quotient num 10))) (begin (let ((ones (modulo num 10))) (begin (if (_gt thousands 0) (begin ((hash-table-ref/default draw (* thousands 1000) (quote ())))) (quote ())) (if (_gt hundreds 0) (begin ((hash-table-ref/default draw (* hundreds 100) (quote ())))) (quote ())) (if (_gt tens 0) (begin ((hash-table-ref/default draw (* tens 10) (quote ())))) (quote ())) (if (_gt ones 0) (begin ((hash-table-ref/default draw ones (quote ())))) (quote ())) (printNumeral))))))))))))) (loop60 (cdr xs))))))) (loop60 numbers))))
