;; Generated on 2025-07-25 01:11 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define adfgvx "ADFGVX")
(define alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
(define (shuffleStr s)
 (call/cc (lambda (ret1)
 (let ((arr (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (set! arr (append arr (list (substring s i (+ i 1)
)
)
)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (let ((j (- (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
 1)
)
)
 (begin (call/cc (lambda (break5)
 (letrec ((loop4 (lambda ()
 (if (> j 0)
 (begin (let ((k (modulo (now)
 (+ j 1)
)
)
)
 (begin (let ((tmp (list-ref arr j)
)
)
 (begin (list-set! arr j (list-ref arr k)
)
 (list-set! arr k tmp)
 (set! j (- j 1)
)
)
)
)
)
 (loop4)
)
 (quote nil)
)
)
)
)
 (loop4)
)
)
)
 (let ((out "")
)
 (begin (set! i 0)
 (call/cc (lambda (break7)
 (letrec ((loop6 (lambda ()
 (if (< i (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
)
 (begin (set! out (string-append out (list-ref arr i)
)
)
 (set! i (+ i 1)
)
 (loop6)
)
 (quote nil)
)
)
)
)
 (loop6)
)
)
)
 (ret1 out)
)
)
)
)
)
)
)
)
)
)
)
(define (createPolybius)
 (call/cc (lambda (ret8)
 (let ((shuffled (shuffleStr alphabet)
)
)
 (begin (let ((labels (list)
)
)
 (begin (let ((li 0)
)
 (begin (call/cc (lambda (break10)
 (letrec ((loop9 (lambda ()
 (if (< li (cond ((string? adfgvx)
 (string-length adfgvx)
)
 ((hash-table? adfgvx)
 (hash-table-size adfgvx)
)
 (else (length adfgvx)
)
)
)
 (begin (set! labels (append labels (list (substring adfgvx li (+ li 1)
)
)
)
)
 (set! li (+ li 1)
)
 (loop9)
)
 (quote nil)
)
)
)
)
 (loop9)
)
)
)
 (display (to-str "6 x 6 Polybius square:\n")
)
 (newline)
 (display (to-str "  | A D F G V X")
)
 (newline)
 (display (to-str "---------------")
)
 (newline)
 (let ((p (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (< i 6)
 (begin (let ((row (substring shuffled (* i 6)
 (* (+ i 1)
 6)
)
)
)
 (begin (set! p (append p (list row)
)
)
 (let ((line (string-append (list-ref labels i)
 " | ")
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break14)
 (letrec ((loop13 (lambda ()
 (if (< j 6)
 (begin (set! line (string-append (string-append line (substring row j (+ j 1)
)
)
 " ")
)
 (set! j (+ j 1)
)
 (loop13)
)
 (quote nil)
)
)
)
)
 (loop13)
)
)
)
 (display (to-str line)
)
 (newline)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop11)
)
 (quote nil)
)
)
)
)
 (loop11)
)
)
)
 (ret8 p)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (createKey n)
 (call/cc (lambda (ret15)
 (begin (if (or (< n 7)
 (> n 12)
)
 (begin (display (to-str "Key should be within 7 and 12 letters long.")
)
 (newline)
)
 (quote nil)
)
 (let ((pool "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
)
 (begin (let ((key "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break17)
 (letrec ((loop16 (lambda ()
 (if (< i n)
 (begin (let ((idx (modulo (now)
 (cond ((string? pool)
 (string-length pool)
)
 ((hash-table? pool)
 (hash-table-size pool)
)
 (else (length pool)
)
)
)
)
)
 (begin (set! key (string-append key (string-ref pool idx)
)
)
 (set! pool (string-append (substring pool 0 idx)
 (substring pool (+ idx 1)
 (cond ((string? pool)
 (string-length pool)
)
 ((hash-table? pool)
 (hash-table-size pool)
)
 (else (length pool)
)
)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop16)
)
 (quote nil)
)
)
)
)
 (loop16)
)
)
)
 (display (to-str (string-append "\nThe key is " key)
)
)
 (newline)
 (ret15 key)
)
)
)
)
)
)
)
)
)
)
(define (orderKey key)
 (call/cc (lambda (ret18)
 (let ((pairs (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break20)
 (letrec ((loop19 (lambda ()
 (if (< i (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (set! pairs (append pairs (list (list (substring key i (+ i 1)
)
 i)
)
)
)
 (set! i (+ i 1)
)
 (loop19)
)
 (quote nil)
)
)
)
)
 (loop19)
)
)
)
 (let ((n (cond ((string? pairs)
 (string-length pairs)
)
 ((hash-table? pairs)
 (hash-table-size pairs)
)
 (else (length pairs)
)
)
)
)
 (begin (let ((m 0)
)
 (begin (call/cc (lambda (break22)
 (letrec ((loop21 (lambda ()
 (if (< m n)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break24)
 (letrec ((loop23 (lambda ()
 (if (< j (- n 1)
)
 (begin (if (> (cond ((string? (list-ref pairs j)
)
 (string-ref (list-ref pairs j)
 0)
)
 ((hash-table? (list-ref pairs j)
)
 (hash-table-ref (list-ref pairs j)
 0)
)
 (else (list-ref (list-ref pairs j)
 0)
)
)
 (cond ((string? (list-ref pairs (+ j 1)
)
)
 (string-ref (list-ref pairs (+ j 1)
)
 0)
)
 ((hash-table? (list-ref pairs (+ j 1)
)
)
 (hash-table-ref (list-ref pairs (+ j 1)
)
 0)
)
 (else (list-ref (list-ref pairs (+ j 1)
)
 0)
)
)
)
 (begin (let ((tmp (list-ref pairs j)
)
)
 (begin (list-set! pairs j (list-ref pairs (+ j 1)
)
)
 (list-set! pairs (+ j 1)
 tmp)
)
)
)
 (quote nil)
)
 (set! j (+ j 1)
)
 (loop23)
)
 (quote nil)
)
)
)
)
 (loop23)
)
)
)
 (set! m (+ m 1)
)
)
)
 (loop21)
)
 (quote nil)
)
)
)
)
 (loop21)
)
)
)
 (let ((res (list)
)
)
 (begin (set! i 0)
 (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (< i n)
 (begin (set! res (append res (list (inexact->exact (cond ((string? (list-ref pairs i)
)
 (string-ref (list-ref pairs i)
 1)
)
 ((hash-table? (list-ref pairs i)
)
 (hash-table-ref (list-ref pairs i)
 1)
)
 (else (list-ref (list-ref pairs i)
 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop25)
)
 (quote nil)
)
)
)
)
 (loop25)
)
)
)
 (ret18 res)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (encrypt polybius key plainText)
 (call/cc (lambda (ret27)
 (let ((labels (list)
)
)
 (begin (let ((li 0)
)
 (begin (call/cc (lambda (break29)
 (letrec ((loop28 (lambda ()
 (if (< li (cond ((string? adfgvx)
 (string-length adfgvx)
)
 ((hash-table? adfgvx)
 (hash-table-size adfgvx)
)
 (else (length adfgvx)
)
)
)
 (begin (set! labels (append labels (list (substring adfgvx li (+ li 1)
)
)
)
)
 (set! li (+ li 1)
)
 (loop28)
)
 (quote nil)
)
)
)
)
 (loop28)
)
)
)
 (let ((temp "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break31)
 (letrec ((loop30 (lambda ()
 (if (< i (cond ((string? plainText)
 (string-length plainText)
)
 ((hash-table? plainText)
 (hash-table-size plainText)
)
 (else (length plainText)
)
)
)
 (begin (let ((r 0)
)
 (begin (call/cc (lambda (break33)
 (letrec ((loop32 (lambda ()
 (if (< r 6)
 (begin (let ((c 0)
)
 (begin (call/cc (lambda (break35)
 (letrec ((loop34 (lambda ()
 (if (< c 6)
 (begin (if (string=? (if (string? (list-ref polybius r)
)
 (substring (list-ref polybius r)
 c (+ c 1)
)
 (take (drop (list-ref polybius r)
 c)
 (- (+ c 1)
 c)
)
)
 (substring plainText i (+ i 1)
)
)
 (begin (set! temp (+ (string-append temp (take (drop labels r)
 (- (+ r 1)
 r)
)
)
 (take (drop labels c)
 (- (+ c 1)
 c)
)
)
)
)
 (quote nil)
)
 (set! c (+ c 1)
)
 (loop34)
)
 (quote nil)
)
)
)
)
 (loop34)
)
)
)
 (set! r (+ r 1)
)
)
)
 (loop32)
)
 (quote nil)
)
)
)
)
 (loop32)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop30)
)
 (quote nil)
)
)
)
)
 (loop30)
)
)
)
 (let ((colLen (quotient (cond ((string? temp)
 (string-length temp)
)
 ((hash-table? temp)
 (hash-table-size temp)
)
 (else (length temp)
)
)
 (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
)
)
 (begin (if (> (modulo (cond ((string? temp)
 (string-length temp)
)
 ((hash-table? temp)
 (hash-table-size temp)
)
 (else (length temp)
)
)
 (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 0)
 (begin (set! colLen (+ colLen 1)
)
)
 (quote nil)
)
 (let ((table (list)
)
)
 (begin (let ((rIdx 0)
)
 (begin (call/cc (lambda (break37)
 (letrec ((loop36 (lambda ()
 (if (< rIdx colLen)
 (begin (let ((row (list)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break39)
 (letrec ((loop38 (lambda ()
 (if (< j (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (set! row (append row (list "")
)
)
 (set! j (+ j 1)
)
 (loop38)
)
 (quote nil)
)
)
)
)
 (loop38)
)
)
)
 (set! table (append table (list row)
)
)
 (set! rIdx (+ rIdx 1)
)
)
)
)
)
 (loop36)
)
 (quote nil)
)
)
)
)
 (loop36)
)
)
)
 (let ((idx 0)
)
 (begin (call/cc (lambda (break41)
 (letrec ((loop40 (lambda ()
 (if (< idx (cond ((string? temp)
 (string-length temp)
)
 ((hash-table? temp)
 (hash-table-size temp)
)
 (else (length temp)
)
)
)
 (begin (let ((row (quotient idx (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
)
)
 (begin (let ((col (modulo idx (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
)
)
 (begin (list-set! (list-ref table row)
 col (substring temp idx (+ idx 1)
)
)
 (set! idx (+ idx 1)
)
)
)
)
)
 (loop40)
)
 (quote nil)
)
)
)
)
 (loop40)
)
)
)
 (let ((order (orderKey key)
)
)
 (begin (let ((cols (list)
)
)
 (begin (let ((ci 0)
)
 (begin (call/cc (lambda (break43)
 (letrec ((loop42 (lambda ()
 (if (< ci (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (let ((colStr "")
)
 (begin (let ((ri 0)
)
 (begin (call/cc (lambda (break45)
 (letrec ((loop44 (lambda ()
 (if (< ri colLen)
 (begin (set! colStr (string-append colStr (cond ((string? (list-ref table ri)
)
 (string-ref (list-ref table ri)
 (list-ref order ci)
)
)
 ((hash-table? (list-ref table ri)
)
 (hash-table-ref (list-ref table ri)
 (list-ref order ci)
)
)
 (else (list-ref (list-ref table ri)
 (list-ref order ci)
)
)
)
)
)
 (set! ri (+ ri 1)
)
 (loop44)
)
 (quote nil)
)
)
)
)
 (loop44)
)
)
)
 (set! cols (append cols (list colStr)
)
)
 (set! ci (+ ci 1)
)
)
)
)
)
 (loop42)
)
 (quote nil)
)
)
)
)
 (loop42)
)
)
)
 (let ((result "")
)
 (begin (set! ci 0)
 (call/cc (lambda (break47)
 (letrec ((loop46 (lambda ()
 (if (< ci (cond ((string? cols)
 (string-length cols)
)
 ((hash-table? cols)
 (hash-table-size cols)
)
 (else (length cols)
)
)
)
 (begin (set! result (string-append result (list-ref cols ci)
)
)
 (if (< ci (- (cond ((string? cols)
 (string-length cols)
)
 ((hash-table? cols)
 (hash-table-size cols)
)
 (else (length cols)
)
)
 1)
)
 (begin (set! result (string-append result " ")
)
)
 (quote nil)
)
 (set! ci (+ ci 1)
)
 (loop46)
)
 (quote nil)
)
)
)
)
 (loop46)
)
)
)
 (ret27 result)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (indexOf s ch)
 (call/cc (lambda (ret48)
 (let ((i 0)
)
 (begin (call/cc (lambda (break50)
 (letrec ((loop49 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (if (string=? (substring s i (+ i 1)
)
 ch)
 (begin (ret48 i)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop49)
)
 (quote nil)
)
)
)
)
 (loop49)
)
)
)
 (ret48 (- 1)
)
)
)
)
)
)
(define (decrypt polybius key cipherText)
 (call/cc (lambda (ret51)
 (let ((colStrs (list)
)
)
 (begin (let ((start 0)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break53)
 (letrec ((loop52 (lambda ()
 (if (<= i (cond ((string? cipherText)
 (string-length cipherText)
)
 ((hash-table? cipherText)
 (hash-table-size cipherText)
)
 (else (length cipherText)
)
)
)
 (begin (if (or (equal? i (cond ((string? cipherText)
 (string-length cipherText)
)
 ((hash-table? cipherText)
 (hash-table-size cipherText)
)
 (else (length cipherText)
)
)
)
 (string=? (string-ref cipherText i)
 " ")
)
 (begin (set! colStrs (append colStrs (list (substring cipherText start i)
)
)
)
 (set! start (+ i 1)
)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop52)
)
 (quote nil)
)
)
)
)
 (loop52)
)
)
)
 (let ((maxColLen 0)
)
 (begin (set! i 0)
 (call/cc (lambda (break55)
 (letrec ((loop54 (lambda ()
 (if (< i (cond ((string? colStrs)
 (string-length colStrs)
)
 ((hash-table? colStrs)
 (hash-table-size colStrs)
)
 (else (length colStrs)
)
)
)
 (begin (if (> (cond ((string? (list-ref colStrs i)
)
 (string-length (list-ref colStrs i)
)
)
 ((hash-table? (list-ref colStrs i)
)
 (hash-table-size (list-ref colStrs i)
)
)
 (else (length (list-ref colStrs i)
)
)
)
 maxColLen)
 (begin (set! maxColLen (cond ((string? (list-ref colStrs i)
)
 (string-length (list-ref colStrs i)
)
)
 ((hash-table? (list-ref colStrs i)
)
 (hash-table-size (list-ref colStrs i)
)
)
 (else (length (list-ref colStrs i)
)
)
)
)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop54)
)
 (quote nil)
)
)
)
)
 (loop54)
)
)
)
 (let ((cols (list)
)
)
 (begin (set! i 0)
 (call/cc (lambda (break57)
 (letrec ((loop56 (lambda ()
 (if (< i (cond ((string? colStrs)
 (string-length colStrs)
)
 ((hash-table? colStrs)
 (hash-table-size colStrs)
)
 (else (length colStrs)
)
)
)
 (begin (let ((s (list-ref colStrs i)
)
)
 (begin (let ((ls (list)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break59)
 (letrec ((loop58 (lambda ()
 (if (< j (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (set! ls (append ls (list (substring s j (+ j 1)
)
)
)
)
 (set! j (+ j 1)
)
 (loop58)
)
 (quote nil)
)
)
)
)
 (loop58)
)
)
)
 (if (< (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 maxColLen)
 (begin (let ((pad (list)
)
)
 (begin (let ((k 0)
)
 (begin (call/cc (lambda (break61)
 (letrec ((loop60 (lambda ()
 (if (< k maxColLen)
 (begin (if (< k (cond ((string? ls)
 (string-length ls)
)
 ((hash-table? ls)
 (hash-table-size ls)
)
 (else (length ls)
)
)
)
 (begin (set! pad (append pad (list (list-ref ls k)
)
)
)
)
 (begin (set! pad (append pad (list "")
)
)
)
)
 (set! k (+ k 1)
)
 (loop60)
)
 (quote nil)
)
)
)
)
 (loop60)
)
)
)
 (set! cols (append cols (list pad)
)
)
)
)
)
)
)
 (begin (set! cols (append cols (list ls)
)
)
)
)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop56)
)
 (quote nil)
)
)
)
)
 (loop56)
)
)
)
 (let ((table (list)
)
)
 (begin (let ((r 0)
)
 (begin (call/cc (lambda (break63)
 (letrec ((loop62 (lambda ()
 (if (< r maxColLen)
 (begin (let ((row (list)
)
)
 (begin (let ((c 0)
)
 (begin (call/cc (lambda (break65)
 (letrec ((loop64 (lambda ()
 (if (< c (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (set! row (append row (list "")
)
)
 (set! c (+ c 1)
)
 (loop64)
)
 (quote nil)
)
)
)
)
 (loop64)
)
)
)
 (set! table (append table (list row)
)
)
 (set! r (+ r 1)
)
)
)
)
)
 (loop62)
)
 (quote nil)
)
)
)
)
 (loop62)
)
)
)
 (let ((order (orderKey key)
)
)
 (begin (set! r 0)
 (call/cc (lambda (break67)
 (letrec ((loop66 (lambda ()
 (if (< r maxColLen)
 (begin (let ((c 0)
)
 (begin (call/cc (lambda (break69)
 (letrec ((loop68 (lambda ()
 (if (< c (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (list-set! (list-ref table r)
 (list-ref order c)
 (cond ((string? (list-ref cols c)
)
 (string-ref (list-ref cols c)
 r)
)
 ((hash-table? (list-ref cols c)
)
 (hash-table-ref (list-ref cols c)
 r)
)
 (else (list-ref (list-ref cols c)
 r)
)
)
)
 (set! c (+ c 1)
)
 (loop68)
)
 (quote nil)
)
)
)
)
 (loop68)
)
)
)
 (set! r (+ r 1)
)
)
)
 (loop66)
)
 (quote nil)
)
)
)
)
 (loop66)
)
)
)
 (let ((temp "")
)
 (begin (set! r 0)
 (call/cc (lambda (break71)
 (letrec ((loop70 (lambda ()
 (if (< r (cond ((string? table)
 (string-length table)
)
 ((hash-table? table)
 (hash-table-size table)
)
 (else (length table)
)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break73)
 (letrec ((loop72 (lambda ()
 (if (< j (cond ((string? (list-ref table r)
)
 (string-length (list-ref table r)
)
)
 ((hash-table? (list-ref table r)
)
 (hash-table-size (list-ref table r)
)
)
 (else (length (list-ref table r)
)
)
)
)
 (begin (set! temp (string-append temp (cond ((string? (list-ref table r)
)
 (string-ref (list-ref table r)
 j)
)
 ((hash-table? (list-ref table r)
)
 (hash-table-ref (list-ref table r)
 j)
)
 (else (list-ref (list-ref table r)
 j)
)
)
)
)
 (set! j (+ j 1)
)
 (loop72)
)
 (quote nil)
)
)
)
)
 (loop72)
)
)
)
 (set! r (+ r 1)
)
)
)
 (loop70)
)
 (quote nil)
)
)
)
)
 (loop70)
)
)
)
 (let ((plainText "")
)
 (begin (let ((idx 0)
)
 (begin (call/cc (lambda (break75)
 (letrec ((loop74 (lambda ()
 (if (< idx (cond ((string? temp)
 (string-length temp)
)
 ((hash-table? temp)
 (hash-table-size temp)
)
 (else (length temp)
)
)
)
 (begin (let ((rIdx (indexOf adfgvx (substring temp idx (+ idx 1)
)
)
)
)
 (begin (let ((cIdx (indexOf adfgvx (substring temp (+ idx 1)
 (+ idx 2)
)
)
)
)
 (begin (set! plainText (string-append plainText (cond ((string? (list-ref polybius rIdx)
)
 (string-ref (list-ref polybius rIdx)
 cIdx)
)
 ((hash-table? (list-ref polybius rIdx)
)
 (hash-table-ref (list-ref polybius rIdx)
 cIdx)
)
 (else (list-ref (list-ref polybius rIdx)
 cIdx)
)
)
)
)
 (set! idx (+ idx 2)
)
)
)
)
)
 (loop74)
)
 (quote nil)
)
)
)
)
 (loop74)
)
)
)
 (ret51 plainText)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret76)
 (let ((plainText "ATTACKAT1200AM")
)
 (begin (let ((polybius (createPolybius)
)
)
 (begin (let ((key (createKey 9)
)
)
 (begin (display (to-str (string-append "\nPlaintext : " plainText)
)
)
 (newline)
 (let ((cipherText (encrypt polybius key plainText)
)
)
 (begin (display (to-str (string-append "\nEncrypted : " cipherText)
)
)
 (newline)
 (let ((plainText2 (decrypt polybius key cipherText)
)
)
 (begin (display (to-str (string-append "\nDecrypted : " plainText2)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
