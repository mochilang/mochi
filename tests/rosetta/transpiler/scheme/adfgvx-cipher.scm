;; Generated on 2025-07-25 20:10 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (inexact->exact (* (current-second) 1000000000))))(import (chibi time))
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(let ((start78 (now)
)
)
 (begin (define adfgvx "ADFGVX")
 (define alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
 (define (shuffleStr s)
 (call/cc (lambda (ret1)
 (let ((arr (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (set! arr (append arr (list (substring s i (+ i 1)
)
)
)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (let ((j (- (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
 1)
)
)
 (begin (call/cc (lambda (break5)
 (letrec ((loop4 (lambda ()
 (if (> j 0)
 (begin (let ((k (modulo (now)
 (+ j 1)
)
)
)
 (begin (let ((tmp (list-ref arr j)
)
)
 (begin (list-set! arr j (list-ref arr k)
)
 (list-set! arr k tmp)
 (set! j (- j 1)
)
)
)
)
)
 (loop4)
)
 (quote ()
)
)
)
)
)
 (loop4)
)
)
)
 (let ((out "")
)
 (begin (set! i 0)
 (call/cc (lambda (break7)
 (letrec ((loop6 (lambda ()
 (if (< i (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
)
 (begin (set! out (string-append out (list-ref arr i)
)
)
 (set! i (+ i 1)
)
 (loop6)
)
 (quote ()
)
)
)
)
)
 (loop6)
)
)
)
 (ret1 out)
)
)
)
)
)
)
)
)
)
)
)
 (define (createPolybius)
 (call/cc (lambda (ret8)
 (let ((shuffled (shuffleStr alphabet)
)
)
 (begin (let ((labels (list)
)
)
 (begin (let ((li 0)
)
 (begin (call/cc (lambda (break10)
 (letrec ((loop9 (lambda ()
 (if (< li (cond ((string? adfgvx)
 (string-length adfgvx)
)
 ((hash-table? adfgvx)
 (hash-table-size adfgvx)
)
 (else (length adfgvx)
)
)
)
 (begin (set! labels (append labels (list (substring adfgvx li (+ li 1)
)
)
)
)
 (set! li (+ li 1)
)
 (loop9)
)
 (quote ()
)
)
)
)
)
 (loop9)
)
)
)
 (display (to-str "6 x 6 Polybius square:\n")
)
 (newline)
 (display (to-str "  | A D F G V X")
)
 (newline)
 (display (to-str "---------------")
)
 (newline)
 (let ((p (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (< i 6)
 (begin (let ((row (if (string? shuffled)
 (substring shuffled (* i 6)
 (* (+ i 1)
 6)
)
 (take (drop shuffled (* i 6)
)
 (- (* (+ i 1)
 6)
 (* i 6)
)
)
)
)
)
 (begin (set! p (append p (list row)
)
)
 (let ((line (string-append (list-ref labels i)
 " | ")
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break14)
 (letrec ((loop13 (lambda ()
 (if (< j 6)
 (begin (set! line (string-append (string-append line (if (string? row)
 (substring row j (+ j 1)
)
 (take (drop row j)
 (- (+ j 1)
 j)
)
)
)
 " ")
)
 (set! j (+ j 1)
)
 (loop13)
)
 (quote ()
)
)
)
)
)
 (loop13)
)
)
)
 (display (to-str line)
)
 (newline)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop11)
)
 (quote ()
)
)
)
)
)
 (loop11)
)
)
)
 (ret8 p)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (createKey n)
 (call/cc (lambda (ret15)
 (begin (if (or (< n 7)
 (> n 12)
)
 (begin (display (to-str "Key should be within 7 and 12 letters long.")
)
 (newline)
)
 (quote ()
)
)
 (let ((pool "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
)
 (begin (let ((key "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break17)
 (letrec ((loop16 (lambda ()
 (if (< i n)
 (begin (let ((idx (modulo (now)
 (cond ((string? pool)
 (string-length pool)
)
 ((hash-table? pool)
 (hash-table-size pool)
)
 (else (length pool)
)
)
)
)
)
 (begin (set! key (string-append key (substring pool idx (+ idx 1)
)
)
)
 (set! pool (string-append (substring pool 0 idx)
 (substring pool (+ idx 1)
 (cond ((string? pool)
 (string-length pool)
)
 ((hash-table? pool)
 (hash-table-size pool)
)
 (else (length pool)
)
)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop16)
)
 (quote ()
)
)
)
)
)
 (loop16)
)
)
)
 (display (to-str (string-append "\nThe key is " key)
)
)
 (newline)
 (ret15 key)
)
)
)
)
)
)
)
)
)
)
 (define (orderKey key)
 (call/cc (lambda (ret18)
 (let ((pairs (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break20)
 (letrec ((loop19 (lambda ()
 (if (< i (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (set! pairs (append pairs (list (list (substring key i (+ i 1)
)
 i)
)
)
)
 (set! i (+ i 1)
)
 (loop19)
)
 (quote ()
)
)
)
)
)
 (loop19)
)
)
)
 (let ((n (cond ((string? pairs)
 (string-length pairs)
)
 ((hash-table? pairs)
 (hash-table-size pairs)
)
 (else (length pairs)
)
)
)
)
 (begin (let ((m 0)
)
 (begin (call/cc (lambda (break22)
 (letrec ((loop21 (lambda ()
 (if (< m n)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break24)
 (letrec ((loop23 (lambda ()
 (if (< j (- n 1)
)
 (begin (if (> (cond ((string? (list-ref pairs j)
)
 (substring (list-ref pairs j)
 0 (+ 0 1)
)
)
 ((hash-table? (list-ref pairs j)
)
 (hash-table-ref (list-ref pairs j)
 0)
)
 (else (list-ref (list-ref pairs j)
 0)
)
)
 (cond ((string? (list-ref pairs (+ j 1)
)
)
 (substring (list-ref pairs (+ j 1)
)
 0 (+ 0 1)
)
)
 ((hash-table? (list-ref pairs (+ j 1)
)
)
 (hash-table-ref (list-ref pairs (+ j 1)
)
 0)
)
 (else (list-ref (list-ref pairs (+ j 1)
)
 0)
)
)
)
 (begin (let ((tmp (list-ref pairs j)
)
)
 (begin (list-set! pairs j (list-ref pairs (+ j 1)
)
)
 (list-set! pairs (+ j 1)
 tmp)
)
)
)
 (quote ()
)
)
 (set! j (+ j 1)
)
 (loop23)
)
 (quote ()
)
)
)
)
)
 (loop23)
)
)
)
 (set! m (+ m 1)
)
)
)
 (loop21)
)
 (quote ()
)
)
)
)
)
 (loop21)
)
)
)
 (let ((res (list)
)
)
 (begin (set! i 0)
 (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (< i n)
 (begin (set! res (append res (list (let ((v27 (cond ((string? (list-ref pairs i)
)
 (substring (list-ref pairs i)
 1 (+ 1 1)
)
)
 ((hash-table? (list-ref pairs i)
)
 (hash-table-ref (list-ref pairs i)
 1)
)
 (else (list-ref (list-ref pairs i)
 1)
)
)
)
)
 (cond ((string? v27)
 (inexact->exact (string->number v27)
)
)
 ((boolean? v27)
 (if v27 1 0)
)
 (else (inexact->exact v27)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop25)
)
 (quote ()
)
)
)
)
)
 (loop25)
)
)
)
 (ret18 res)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (encrypt polybius key plainText)
 (call/cc (lambda (ret28)
 (let ((labels (list)
)
)
 (begin (let ((li 0)
)
 (begin (call/cc (lambda (break30)
 (letrec ((loop29 (lambda ()
 (if (< li (cond ((string? adfgvx)
 (string-length adfgvx)
)
 ((hash-table? adfgvx)
 (hash-table-size adfgvx)
)
 (else (length adfgvx)
)
)
)
 (begin (set! labels (append labels (list (substring adfgvx li (+ li 1)
)
)
)
)
 (set! li (+ li 1)
)
 (loop29)
)
 (quote ()
)
)
)
)
)
 (loop29)
)
)
)
 (let ((temp "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break32)
 (letrec ((loop31 (lambda ()
 (if (< i (cond ((string? plainText)
 (string-length plainText)
)
 ((hash-table? plainText)
 (hash-table-size plainText)
)
 (else (length plainText)
)
)
)
 (begin (let ((r 0)
)
 (begin (call/cc (lambda (break34)
 (letrec ((loop33 (lambda ()
 (if (< r 6)
 (begin (let ((c 0)
)
 (begin (call/cc (lambda (break36)
 (letrec ((loop35 (lambda ()
 (if (< c 6)
 (begin (if (string=? (if (string? (list-ref polybius r)
)
 (substring (list-ref polybius r)
 c (+ c 1)
)
 (take (drop (list-ref polybius r)
 c)
 (- (+ c 1)
 c)
)
)
 (substring plainText i (+ i 1)
)
)
 (begin (set! temp (string-append (string-append temp (list-ref labels r)
)
 (list-ref labels c)
)
)
)
 (quote ()
)
)
 (set! c (+ c 1)
)
 (loop35)
)
 (quote ()
)
)
)
)
)
 (loop35)
)
)
)
 (set! r (+ r 1)
)
)
)
 (loop33)
)
 (quote ()
)
)
)
)
)
 (loop33)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop31)
)
 (quote ()
)
)
)
)
)
 (loop31)
)
)
)
 (let ((colLen (quotient (cond ((string? temp)
 (string-length temp)
)
 ((hash-table? temp)
 (hash-table-size temp)
)
 (else (length temp)
)
)
 (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
)
)
 (begin (if (> (modulo (cond ((string? temp)
 (string-length temp)
)
 ((hash-table? temp)
 (hash-table-size temp)
)
 (else (length temp)
)
)
 (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 0)
 (begin (set! colLen (+ colLen 1)
)
)
 (quote ()
)
)
 (let ((table (list)
)
)
 (begin (let ((rIdx 0)
)
 (begin (call/cc (lambda (break38)
 (letrec ((loop37 (lambda ()
 (if (< rIdx colLen)
 (begin (let ((row (list)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break40)
 (letrec ((loop39 (lambda ()
 (if (< j (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (set! row (append row (list "")
)
)
 (set! j (+ j 1)
)
 (loop39)
)
 (quote ()
)
)
)
)
)
 (loop39)
)
)
)
 (set! table (append table (list row)
)
)
 (set! rIdx (+ rIdx 1)
)
)
)
)
)
 (loop37)
)
 (quote ()
)
)
)
)
)
 (loop37)
)
)
)
 (let ((idx 0)
)
 (begin (call/cc (lambda (break42)
 (letrec ((loop41 (lambda ()
 (if (< idx (cond ((string? temp)
 (string-length temp)
)
 ((hash-table? temp)
 (hash-table-size temp)
)
 (else (length temp)
)
)
)
 (begin (let ((row (quotient idx (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
)
)
 (begin (let ((col (modulo idx (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
)
)
 (begin (list-set! (list-ref table row)
 col (substring temp idx (+ idx 1)
)
)
 (set! idx (+ idx 1)
)
)
)
)
)
 (loop41)
)
 (quote ()
)
)
)
)
)
 (loop41)
)
)
)
 (let ((order (orderKey key)
)
)
 (begin (let ((cols (list)
)
)
 (begin (let ((ci 0)
)
 (begin (call/cc (lambda (break44)
 (letrec ((loop43 (lambda ()
 (if (< ci (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (let ((colStr "")
)
 (begin (let ((ri 0)
)
 (begin (call/cc (lambda (break46)
 (letrec ((loop45 (lambda ()
 (if (< ri colLen)
 (begin (set! colStr (string-append colStr (cond ((string? (list-ref table ri)
)
 (substring (list-ref table ri)
 (cond ((string? order)
 (substring order ci (+ ci 1)
)
)
 ((hash-table? order)
 (hash-table-ref order ci)
)
 (else (list-ref order ci)
)
)
 (+ (cond ((string? order)
 (substring order ci (+ ci 1)
)
)
 ((hash-table? order)
 (hash-table-ref order ci)
)
 (else (list-ref order ci)
)
)
 1)
)
)
 ((hash-table? (list-ref table ri)
)
 (hash-table-ref (list-ref table ri)
 (cond ((string? order)
 (substring order ci (+ ci 1)
)
)
 ((hash-table? order)
 (hash-table-ref order ci)
)
 (else (list-ref order ci)
)
)
)
)
 (else (list-ref (list-ref table ri)
 (cond ((string? order)
 (substring order ci (+ ci 1)
)
)
 ((hash-table? order)
 (hash-table-ref order ci)
)
 (else (list-ref order ci)
)
)
)
)
)
)
)
 (set! ri (+ ri 1)
)
 (loop45)
)
 (quote ()
)
)
)
)
)
 (loop45)
)
)
)
 (set! cols (append cols (list colStr)
)
)
 (set! ci (+ ci 1)
)
)
)
)
)
 (loop43)
)
 (quote ()
)
)
)
)
)
 (loop43)
)
)
)
 (let ((result "")
)
 (begin (set! ci 0)
 (call/cc (lambda (break48)
 (letrec ((loop47 (lambda ()
 (if (< ci (cond ((string? cols)
 (string-length cols)
)
 ((hash-table? cols)
 (hash-table-size cols)
)
 (else (length cols)
)
)
)
 (begin (set! result (string-append result (list-ref cols ci)
)
)
 (if (< ci (- (cond ((string? cols)
 (string-length cols)
)
 ((hash-table? cols)
 (hash-table-size cols)
)
 (else (length cols)
)
)
 1)
)
 (begin (set! result (string-append result " ")
)
)
 (quote ()
)
)
 (set! ci (+ ci 1)
)
 (loop47)
)
 (quote ()
)
)
)
)
)
 (loop47)
)
)
)
 (ret28 result)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (indexOf s ch)
 (call/cc (lambda (ret49)
 (let ((i 0)
)
 (begin (call/cc (lambda (break51)
 (letrec ((loop50 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (if (string=? (substring s i (+ i 1)
)
 ch)
 (begin (ret49 i)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop50)
)
 (quote ()
)
)
)
)
)
 (loop50)
)
)
)
 (ret49 (- 1)
)
)
)
)
)
)
 (define (decrypt polybius key cipherText)
 (call/cc (lambda (ret52)
 (let ((colStrs (list)
)
)
 (begin (let ((start 0)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break54)
 (letrec ((loop53 (lambda ()
 (if (<= i (cond ((string? cipherText)
 (string-length cipherText)
)
 ((hash-table? cipherText)
 (hash-table-size cipherText)
)
 (else (length cipherText)
)
)
)
 (begin (if (or (equal? i (cond ((string? cipherText)
 (string-length cipherText)
)
 ((hash-table? cipherText)
 (hash-table-size cipherText)
)
 (else (length cipherText)
)
)
)
 (string=? (substring cipherText i (+ i 1)
)
 " ")
)
 (begin (set! colStrs (append colStrs (list (substring cipherText start i)
)
)
)
 (set! start (+ i 1)
)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop53)
)
 (quote ()
)
)
)
)
)
 (loop53)
)
)
)
 (let ((maxColLen 0)
)
 (begin (set! i 0)
 (call/cc (lambda (break56)
 (letrec ((loop55 (lambda ()
 (if (< i (cond ((string? colStrs)
 (string-length colStrs)
)
 ((hash-table? colStrs)
 (hash-table-size colStrs)
)
 (else (length colStrs)
)
)
)
 (begin (if (> (cond ((string? (list-ref colStrs i)
)
 (string-length (list-ref colStrs i)
)
)
 ((hash-table? (list-ref colStrs i)
)
 (hash-table-size (list-ref colStrs i)
)
)
 (else (length (list-ref colStrs i)
)
)
)
 maxColLen)
 (begin (set! maxColLen (cond ((string? (list-ref colStrs i)
)
 (string-length (list-ref colStrs i)
)
)
 ((hash-table? (list-ref colStrs i)
)
 (hash-table-size (list-ref colStrs i)
)
)
 (else (length (list-ref colStrs i)
)
)
)
)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop55)
)
 (quote ()
)
)
)
)
)
 (loop55)
)
)
)
 (let ((cols (list)
)
)
 (begin (set! i 0)
 (call/cc (lambda (break58)
 (letrec ((loop57 (lambda ()
 (if (< i (cond ((string? colStrs)
 (string-length colStrs)
)
 ((hash-table? colStrs)
 (hash-table-size colStrs)
)
 (else (length colStrs)
)
)
)
 (begin (let ((s (list-ref colStrs i)
)
)
 (begin (let ((ls (list)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break60)
 (letrec ((loop59 (lambda ()
 (if (< j (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (set! ls (append ls (list (substring s j (+ j 1)
)
)
)
)
 (set! j (+ j 1)
)
 (loop59)
)
 (quote ()
)
)
)
)
)
 (loop59)
)
)
)
 (if (< (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 maxColLen)
 (begin (let ((pad (list)
)
)
 (begin (let ((k 0)
)
 (begin (call/cc (lambda (break62)
 (letrec ((loop61 (lambda ()
 (if (< k maxColLen)
 (begin (if (< k (cond ((string? ls)
 (string-length ls)
)
 ((hash-table? ls)
 (hash-table-size ls)
)
 (else (length ls)
)
)
)
 (begin (set! pad (append pad (list (list-ref ls k)
)
)
)
)
 (begin (set! pad (append pad (list "")
)
)
)
)
 (set! k (+ k 1)
)
 (loop61)
)
 (quote ()
)
)
)
)
)
 (loop61)
)
)
)
 (set! cols (append cols (list pad)
)
)
)
)
)
)
)
 (begin (set! cols (append cols (list ls)
)
)
)
)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop57)
)
 (quote ()
)
)
)
)
)
 (loop57)
)
)
)
 (let ((table (list)
)
)
 (begin (let ((r 0)
)
 (begin (call/cc (lambda (break64)
 (letrec ((loop63 (lambda ()
 (if (< r maxColLen)
 (begin (let ((row (list)
)
)
 (begin (let ((c 0)
)
 (begin (call/cc (lambda (break66)
 (letrec ((loop65 (lambda ()
 (if (< c (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (set! row (append row (list "")
)
)
 (set! c (+ c 1)
)
 (loop65)
)
 (quote ()
)
)
)
)
)
 (loop65)
)
)
)
 (set! table (append table (list row)
)
)
 (set! r (+ r 1)
)
)
)
)
)
 (loop63)
)
 (quote ()
)
)
)
)
)
 (loop63)
)
)
)
 (let ((order (orderKey key)
)
)
 (begin (set! r 0)
 (call/cc (lambda (break68)
 (letrec ((loop67 (lambda ()
 (if (< r maxColLen)
 (begin (let ((c 0)
)
 (begin (call/cc (lambda (break70)
 (letrec ((loop69 (lambda ()
 (if (< c (cond ((string? key)
 (string-length key)
)
 ((hash-table? key)
 (hash-table-size key)
)
 (else (length key)
)
)
)
 (begin (list-set! (list-ref table r)
 (cond ((string? order)
 (substring order c (+ c 1)
)
)
 ((hash-table? order)
 (hash-table-ref order c)
)
 (else (list-ref order c)
)
)
 (cond ((string? (list-ref cols c)
)
 (substring (list-ref cols c)
 r (+ r 1)
)
)
 ((hash-table? (list-ref cols c)
)
 (hash-table-ref (list-ref cols c)
 r)
)
 (else (list-ref (list-ref cols c)
 r)
)
)
)
 (set! c (+ c 1)
)
 (loop69)
)
 (quote ()
)
)
)
)
)
 (loop69)
)
)
)
 (set! r (+ r 1)
)
)
)
 (loop67)
)
 (quote ()
)
)
)
)
)
 (loop67)
)
)
)
 (let ((temp "")
)
 (begin (set! r 0)
 (call/cc (lambda (break72)
 (letrec ((loop71 (lambda ()
 (if (< r (cond ((string? table)
 (string-length table)
)
 ((hash-table? table)
 (hash-table-size table)
)
 (else (length table)
)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break74)
 (letrec ((loop73 (lambda ()
 (if (< j (cond ((string? (list-ref table r)
)
 (string-length (list-ref table r)
)
)
 ((hash-table? (list-ref table r)
)
 (hash-table-size (list-ref table r)
)
)
 (else (length (list-ref table r)
)
)
)
)
 (begin (set! temp (string-append temp (cond ((string? (list-ref table r)
)
 (substring (list-ref table r)
 j (+ j 1)
)
)
 ((hash-table? (list-ref table r)
)
 (hash-table-ref (list-ref table r)
 j)
)
 (else (list-ref (list-ref table r)
 j)
)
)
)
)
 (set! j (+ j 1)
)
 (loop73)
)
 (quote ()
)
)
)
)
)
 (loop73)
)
)
)
 (set! r (+ r 1)
)
)
)
 (loop71)
)
 (quote ()
)
)
)
)
)
 (loop71)
)
)
)
 (let ((plainText "")
)
 (begin (let ((idx 0)
)
 (begin (call/cc (lambda (break76)
 (letrec ((loop75 (lambda ()
 (if (< idx (cond ((string? temp)
 (string-length temp)
)
 ((hash-table? temp)
 (hash-table-size temp)
)
 (else (length temp)
)
)
)
 (begin (let ((rIdx (indexOf adfgvx (substring temp idx (+ idx 1)
)
)
)
)
 (begin (let ((cIdx (indexOf adfgvx (substring temp (+ idx 1)
 (+ idx 2)
)
)
)
)
 (begin (set! plainText (string-append plainText (cond ((string? (list-ref polybius rIdx)
)
 (substring (list-ref polybius rIdx)
 cIdx (+ cIdx 1)
)
)
 ((hash-table? (list-ref polybius rIdx)
)
 (hash-table-ref (list-ref polybius rIdx)
 cIdx)
)
 (else (list-ref (list-ref polybius rIdx)
 cIdx)
)
)
)
)
 (set! idx (+ idx 2)
)
)
)
)
)
 (loop75)
)
 (quote ()
)
)
)
)
)
 (loop75)
)
)
)
 (ret52 plainText)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (main)
 (call/cc (lambda (ret77)
 (let ((plainText "ATTACKAT1200AM")
)
 (begin (let ((polybius (createPolybius)
)
)
 (begin (let ((key (createKey 9)
)
)
 (begin (display (to-str (string-append "\nPlaintext : " plainText)
)
)
 (newline)
 (let ((cipherText (encrypt polybius key plainText)
)
)
 (begin (display (to-str (string-append "\nEncrypted : " cipherText)
)
)
 (newline)
 (let ((plainText2 (decrypt polybius key cipherText)
)
)
 (begin (display (to-str (string-append "\nDecrypted : " plainText2)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (main)
 (let ((end79 (now)
)
)
 (let ((dur80 (quotient (- end79 start78)
 1000)
)
)
 (begin (display (string-append "{\n  \"duration_us\": " (number->string dur80)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
