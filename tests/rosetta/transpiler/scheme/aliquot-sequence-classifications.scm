;; Generated on 2025-07-25 01:11 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define THRESHOLD 140737488355328)
(define (indexOf xs value)
 (call/cc (lambda (ret1)
 (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? xs)
 (string-length xs)
)
 ((hash-table? xs)
 (hash-table-size xs)
)
 (else (length xs)
)
)
)
 (begin (if (equal? (list-ref xs i)
 value)
 (begin (ret1 i)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (ret1 (- 0 1)
)
)
)
)
)
)
(define (contains xs value)
 (call/cc (lambda (ret4)
 (ret4 (not (equal? (indexOf xs value)
 (- 0 1)
)
)
)
)
)
)
(define (maxOf a b)
 (call/cc (lambda (ret5)
 (if (> a b)
 (begin (ret5 a)
)
 (begin (ret5 b)
)
)
)
)
)
(define (intSqrt n)
 (call/cc (lambda (ret6)
 (begin (if (equal? n 0)
 (begin (ret6 0)
)
 (quote nil)
)
 (let ((x n)
)
 (begin (let ((y (quotient (+ x 1)
 2)
)
)
 (begin (call/cc (lambda (break8)
 (letrec ((loop7 (lambda ()
 (if (< y x)
 (begin (set! x y)
 (set! y (quotient (+ x (quotient n x)
)
 2)
)
 (loop7)
)
 (quote nil)
)
)
)
)
 (loop7)
)
)
)
 (ret6 x)
)
)
)
)
)
)
)
)
(define (sumProperDivisors n)
 (call/cc (lambda (ret9)
 (begin (if (< n 2)
 (begin (ret9 0)
)
 (quote nil)
)
 (let ((sqrt (intSqrt n)
)
)
 (begin (let ((sum 1)
)
 (begin (let ((i 2)
)
 (begin (call/cc (lambda (break11)
 (letrec ((loop10 (lambda ()
 (if (<= i sqrt)
 (begin (if (equal? (modulo n i)
 0)
 (begin (set! sum (+ (+ sum i)
 (quotient n i)
)
)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop10)
)
 (quote nil)
)
)
)
)
 (loop10)
)
)
)
 (if (equal? (* sqrt sqrt)
 n)
 (begin (set! sum (- sum sqrt)
)
)
 (quote nil)
)
 (ret9 sum)
)
)
)
)
)
)
)
)
)
)
(define (classifySequence k)
 (call/cc (lambda (ret12)
 (let ((last k)
)
 (begin (let ((seq (list k)
)
)
 (begin (call/cc (lambda (break14)
 (letrec ((loop13 (lambda ()
 (if #t (begin (set! last (sumProperDivisors last)
)
 (set! seq (append seq (list last)
)
)
 (let ((n (cond ((string? seq)
 (string-length seq)
)
 ((hash-table? seq)
 (hash-table-size seq)
)
 (else (length seq)
)
)
)
)
 (begin (let ((aliquot "")
)
 (begin (if (equal? last 0)
 (begin (set! aliquot "Terminating")
)
 (if (and (equal? n 2)
 (equal? last k)
)
 (begin (set! aliquot "Perfect")
)
 (if (and (equal? n 3)
 (equal? last k)
)
 (begin (set! aliquot "Amicable")
)
 (if (and (>= n 4)
 (equal? last k)
)
 (begin (set! aliquot (string-append (string-append "Sociable[" (to-str (- n 1)
)
)
 "]")
)
)
 (if (equal? last (list-ref seq (- n 2)
)
)
 (begin (set! aliquot "Aspiring")
)
 (if (contains (take (drop seq 1)
 (- (maxOf 1 (- n 2)
)
 1)
)
 last)
 (begin (let ((idx (indexOf seq last)
)
)
 (begin (set! aliquot (string-append (string-append "Cyclic[" (to-str (- (- n 1)
 idx)
)
)
 "]")
)
)
)
)
 (if (or (equal? n 16)
 (> last THRESHOLD)
)
 (begin (set! aliquot "Non-Terminating")
)
 (quote nil)
)
)
)
)
)
)
)
 (if (not (string=? aliquot "")
)
 (begin (ret12 (alist->hash-table (list (cons "seq" seq)
 (cons "aliquot" aliquot)
)
)
)
)
 (quote nil)
)
)
)
)
)
 (loop13)
)
 (quote nil)
)
)
)
)
 (loop13)
)
)
)
 (ret12 (alist->hash-table (list (cons "seq" seq)
 (cons "aliquot" "")
)
)
)
)
)
)
)
)
)
)
(define (padLeft n w)
 (call/cc (lambda (ret15)
 (let ((s (to-str n)
)
)
 (begin (call/cc (lambda (break17)
 (letrec ((loop16 (lambda ()
 (if (< (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 w)
 (begin (set! s (string-append " " s)
)
 (loop16)
)
 (quote nil)
)
)
)
)
 (loop16)
)
)
)
 (ret15 s)
)
)
)
)
)
(define (padRight s w)
 (call/cc (lambda (ret18)
 (let ((r s)
)
 (begin (call/cc (lambda (break20)
 (letrec ((loop19 (lambda ()
 (if (< (cond ((string? r)
 (string-length r)
)
 ((hash-table? r)
 (hash-table-size r)
)
 (else (length r)
)
)
 w)
 (begin (set! r (string-append r " ")
)
 (loop19)
)
 (quote nil)
)
)
)
)
 (loop19)
)
)
)
 (ret18 r)
)
)
)
)
)
(define (joinWithCommas seq)
 (call/cc (lambda (ret21)
 (let ((s "[")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break23)
 (letrec ((loop22 (lambda ()
 (if (< i (cond ((string? seq)
 (string-length seq)
)
 ((hash-table? seq)
 (hash-table-size seq)
)
 (else (length seq)
)
)
)
 (begin (set! s (string-append s (to-str (list-ref seq i)
)
)
)
 (if (< i (- (cond ((string? seq)
 (string-length seq)
)
 ((hash-table? seq)
 (hash-table-size seq)
)
 (else (length seq)
)
)
 1)
)
 (begin (set! s (string-append s ", ")
)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop22)
)
 (quote nil)
)
)
)
)
 (loop22)
)
)
)
 (set! s (string-append s "]")
)
 (ret21 s)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret24)
 (begin (display (to-str "Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n")
)
 (newline)
 (let ((k 1)
)
 (begin (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (<= k 10)
 (begin (let ((res (classifySequence k)
)
)
 (begin (display (to-str (string-append (string-append (string-append (string-append (padLeft k 2)
 ": ")
 (padRight (number->string (hash-table-ref res "aliquot")
)
 15)
)
 " ")
 (joinWithCommas (hash-table-ref res "seq")
)
)
)
)
 (newline)
 (set! k (+ k 1)
)
)
)
 (loop25)
)
 (quote nil)
)
)
)
)
 (loop25)
)
)
)
 (display (to-str "")
)
 (newline)
 (let ((s (list 11 12 28 496 220 1184 12496 1264460 790 909 562 1064 1488)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break28)
 (letrec ((loop27 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (let ((val (list-ref s i)
)
)
 (begin (let ((res (classifySequence val)
)
)
 (begin (display (to-str (string-append (string-append (string-append (string-append (padLeft val 7)
 ": ")
 (padRight (number->string (hash-table-ref res "aliquot")
)
 15)
)
 " ")
 (joinWithCommas (hash-table-ref res "seq")
)
)
)
)
 (newline)
 (set! i (+ i 1)
)
)
)
)
)
 (loop27)
)
 (quote nil)
)
)
)
)
 (loop27)
)
)
)
 (display (to-str "")
)
 (newline)
 (let ((big 15355717786080)
)
 (begin (let ((r (classifySequence big)
)
)
 (begin (display (to-str (string-append (string-append (string-append (string-append (to-str big)
 ": ")
 (padRight (number->string (hash-table-ref r "aliquot")
)
 15)
)
 " ")
 (joinWithCommas (hash-table-ref r "seq")
)
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
