;; Generated on 2025-07-27 23:58 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (split s sep)
 (call/cc (lambda (ret1)
 (let ((parts (_list)
)
)
 (begin (let ((cur "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (if (and (and (> (cond ((string? sep)
 (string-length sep)
)
 ((hash-table? sep)
 (hash-table-size sep)
)
 (else (length sep)
)
)
 0)
 (_le (+ i (cond ((string? sep)
 (string-length sep)
)
 ((hash-table? sep)
 (hash-table-size sep)
)
 (else (length sep)
)
)
)
 (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
)
 (string=? (substring s i (+ i (cond ((string? sep)
 (string-length sep)
)
 ((hash-table? sep)
 (hash-table-size sep)
)
 (else (length sep)
)
)
)
)
 sep)
)
 (begin (set! parts (append parts (_list cur)
)
)
 (set! cur "")
 (set! i (+ i (cond ((string? sep)
 (string-length sep)
)
 ((hash-table? sep)
 (hash-table-size sep)
)
 (else (length sep)
)
)
)
)
)
 (begin (set! cur (string-append cur (substring s i (+ i 1)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (set! parts (append parts (_list cur)
)
)
 (ret1 parts)
)
)
)
)
)
)
)
)
)
(define (join xs sep)
 (call/cc (lambda (ret4)
 (let ((res "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (< i (cond ((string? xs)
 (string-length xs)
)
 ((hash-table? xs)
 (hash-table-size xs)
)
 (else (length xs)
)
)
)
 (begin (if (> i 0)
 (begin (set! res (string-append res sep)
)
)
 (quote ()
)
)
 (set! res (string-append res (list-ref xs i)
)
)
 (set! i (+ i 1)
)
 (loop5)
)
 (quote ()
)
)
)
)
)
 (loop5)
)
)
)
 (ret4 res)
)
)
)
)
)
)
)
(define (repeat ch n)
 (call/cc (lambda (ret7)
 (let ((out "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (< i n)
 (begin (set! out (string-append out ch)
)
 (set! i (+ i 1)
)
 (loop8)
)
 (quote ()
)
)
)
)
)
 (loop8)
)
)
)
 (ret7 out)
)
)
)
)
)
)
)
(define (parseIntStr str)
 (call/cc (lambda (ret10)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote ()
)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (_list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (< i (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
)
 (begin (set! n (_add (* n 10)
 (cond ((string? digits)
 (substring digits (substring str i (+ i 1)
)
 (+ (substring str i (+ i 1)
)
 1)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop11)
)
 (quote ()
)
)
)
)
)
 (loop11)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote ()
)
)
 (ret10 n)
)
)
)
)
)
)
)
)
)
)
)
(define (toBinary n bits)
 (call/cc (lambda (ret13)
 (let ((b "")
)
 (begin (let ((val n)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if (< i bits)
 (begin (set! b (string-append (to-str (modulo val 2)
)
 b)
)
 (set! val (let ((v16 (quotient val 2)
)
)
 (cond ((string? v16)
 (exact (floor (string->number v16)
)
)
)
 ((boolean? v16)
 (if v16 1 0)
)
 (else (exact (floor v16)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop14)
)
 (quote ()
)
)
)
)
)
 (loop14)
)
)
)
 (ret13 b)
)
)
)
)
)
)
)
)
)
(define (binToInt bits)
 (call/cc (lambda (ret17)
 (let ((n 0)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda ()
 (if (< i (cond ((string? bits)
 (string-length bits)
)
 ((hash-table? bits)
 (hash-table-size bits)
)
 (else (length bits)
)
)
)
 (begin (set! n (_add (* n 2)
 (_parseIntStr (substring bits i (+ i 1)
)
 10)
)
)
 (set! i (+ i 1)
)
 (loop18)
)
 (quote ()
)
)
)
)
)
 (loop18)
)
)
)
 (ret17 n)
)
)
)
)
)
)
)
(define (padRight s width)
 (call/cc (lambda (ret20)
 (let ((out s)
)
 (begin (call/cc (lambda (break22)
 (letrec ((loop21 (lambda ()
 (if (< (cond ((string? out)
 (string-length out)
)
 ((hash-table? out)
 (hash-table-size out)
)
 (else (length out)
)
)
 width)
 (begin (set! out (string-append out " ")
)
 (loop21)
)
 (quote ()
)
)
)
)
)
 (loop21)
)
)
)
 (ret20 out)
)
)
)
)
)
(define (canonicalize cidr)
 (call/cc (lambda (ret23)
 (let ((parts (split cidr "/")
)
)
 (begin (let ((dotted (cond ((string? parts)
 (substring parts 0 (+ 0 1)
)
)
 ((hash-table? parts)
 (hash-table-ref parts 0)
)
 (else (list-ref parts 0)
)
)
)
)
 (begin (let ((size (_parseIntStr (cond ((string? parts)
 (substring parts 1 (+ 1 1)
)
)
 ((hash-table? parts)
 (hash-table-ref parts 1)
)
 (else (list-ref parts 1)
)
)
 10)
)
)
 (begin (let ((binParts (_list)
)
)
 (begin (call/cc (lambda (break25)
 (letrec ((loop24 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((p (car xs)
)
)
 (begin (set! binParts (append binParts (_list (toBinary (_parseIntStr p 10)
 8)
)
)
)
)
)
 (loop24 (cdr xs)
)
)
)
)
)
)
 (loop24 (split dotted ".")
)
)
)
)
 (let ((binary (join binParts "")
)
)
 (begin (set! binary (_add (if (string? binary)
 (substring binary 0 size)
 (take (drop binary 0)
 (- size 0)
)
)
 (_repeat "0" (- 32 size)
)
)
)
 (let ((canonParts (_list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break27)
 (letrec ((loop26 (lambda ()
 (if (< i (cond ((string? binary)
 (string-length binary)
)
 ((hash-table? binary)
 (hash-table-size binary)
)
 (else (length binary)
)
)
)
 (begin (set! canonParts (append canonParts (_list (to-str (binToInt (if (string? binary)
 (substring binary i (+ i 8)
)
 (take (drop binary i)
 (- (+ i 8)
 i)
)
)
)
)
)
)
)
 (set! i (+ i 8)
)
 (loop26)
)
 (quote ()
)
)
)
)
)
 (loop26)
)
)
)
 (ret23 (string-append (string-append (join canonParts ".")
 "/")
 (cond ((string? parts)
 (substring parts 1 (+ 1 1)
)
)
 ((hash-table? parts)
 (hash-table-ref parts 1)
)
 (else (list-ref parts 1)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define tests (_list "87.70.141.1/22" "36.18.154.103/12" "62.62.197.11/29" "67.137.119.181/4" "161.214.74.21/24" "184.232.176.184/18")
)
(call/cc (lambda (break29)
 (letrec ((loop28 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((t (car xs)
)
)
 (begin (_display (to-str (string-append (string-append (padRight t 18)
 " -> ")
 (canonicalize t)
)
)
)
 (newline)
)
)
 (loop28 (cdr xs)
)
)
)
)
)
)
 (loop28 tests)
)
)
)
