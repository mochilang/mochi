;; Generated on 2025-07-25 01:11 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fields s)
 (call/cc (lambda (ret1)
 (let ((words (list)
)
)
 (begin (let ((cur "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (string-length s)
)
 (begin (let ((ch (substring s i (+ i 1)
)
)
)
 (begin (if (or (or (string=? ch " ")
 (string=? ch "\n")
)
 (string=? ch "\t")
)
 (begin (if (> (string-length cur)
 0)
 (begin (set! words (append words (list cur)
)
)
 (set! cur "")
)
 (quote nil)
)
)
 (begin (set! cur (string-append cur ch)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (if (> (string-length cur)
 0)
 (begin (set! words (append words (list cur)
)
)
)
 (quote nil)
)
 (ret1 words)
)
)
)
)
)
)
)
)
)
(define (padRight s width)
 (call/cc (lambda (ret4)
 (let ((out s)
)
 (begin (let ((i (string-length s)
)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (< i width)
 (begin (set! out (string-append out " ")
)
 (set! i (+ i 1)
)
 (loop5)
)
 (quote nil)
)
)
)
)
 (loop5)
)
)
)
 (ret4 out)
)
)
)
)
)
)
)
(define (join xs sep)
 (call/cc (lambda (ret7)
 (let ((res "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (< i (length xs)
)
 (begin (if (> i 0)
 (begin (set! res (string-append res sep)
)
)
 (quote nil)
)
 (set! res (string-append res (list-ref xs i)
)
)
 (set! i (+ i 1)
)
 (loop8)
)
 (quote nil)
)
)
)
)
 (loop8)
)
)
)
 (ret7 res)
)
)
)
)
)
)
)
(define (parseIntStr str)
 (call/cc (lambda (ret10)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (string-length str)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote nil)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (< i (string-length str)
)
 (begin (set! n (+ (* n 10)
 (cond ((string? digits)
 (string-ref digits (substring str i (+ i 1)
)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop11)
)
 (quote nil)
)
)
)
)
 (loop11)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote nil)
)
 (ret10 n)
)
)
)
)
)
)
)
)
)
)
)
(define (isDigits s)
 (call/cc (lambda (ret13)
 (begin (if (equal? (string-length s)
 0)
 (begin (ret13 #f)
)
 (quote nil)
)
 (let ((i 0)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if (< i (string-length s)
)
 (begin (let ((ch (substring s i (+ i 1)
)
)
)
 (begin (if (or (string<? ch "0")
 (string>? ch "9")
)
 (begin (ret13 #f)
)
 (quote nil)
)
 (set! i (+ i 1)
)
)
)
 (loop14)
)
 (quote nil)
)
)
)
)
 (loop14)
)
)
)
 (ret13 #t)
)
)
)
)
)
)
(define (readTable table)
 (call/cc (lambda (ret16)
 (let ((toks (fields table)
)
)
 (begin (let ((cmds (list)
)
)
 (begin (let ((mins (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if (< i (length toks)
)
 (begin (let ((cmd (list-ref toks i)
)
)
 (begin (let ((minlen (string-length cmd)
)
)
 (begin (set! i (+ i 1)
)
 (if (and (< i (length toks)
)
 (isDigits (list-ref toks i)
)
)
 (begin (let ((num (parseIntStr (list-ref toks i)
)
)
)
 (begin (if (and (>= num 1)
 (< num (string-length cmd)
)
)
 (begin (set! minlen num)
 (set! i (+ i 1)
)
)
 (quote nil)
)
)
)
)
 (quote nil)
)
 (set! cmds (append cmds (list cmd)
)
)
 (set! mins (append mins (list minlen)
)
)
)
)
)
)
 (loop17)
)
 (quote nil)
)
)
)
)
 (loop17)
)
)
)
 (ret16 (alist->hash-table (list (cons "commands" cmds)
 (cons "mins" mins)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (validate commands mins words)
 (call/cc (lambda (ret19)
 (let ((results (list)
)
)
 (begin (let ((wi 0)
)
 (begin (call/cc (lambda (break21)
 (letrec ((loop20 (lambda ()
 (if (< wi (length words)
)
 (begin (let ((w (list-ref words wi)
)
)
 (begin (let ((found #f)
)
 (begin (let ((wlen (string-length w)
)
)
 (begin (let ((ci 0)
)
 (begin (call/cc (lambda (break23)
 (letrec ((loop22 (lambda ()
 (if (< ci (length commands)
)
 (begin (let ((cmd (list-ref commands ci)
)
)
 (begin (if (and (and (not (equal? (list-ref mins ci)
 0)
)
 (>= wlen (list-ref mins ci)
)
)
 (<= wlen (string-length cmd)
)
)
 (begin (let ((c (upper cmd)
)
)
 (begin (let ((ww (upper w)
)
)
 (begin (if (string=? (substring c 0 wlen)
 ww)
 (begin (set! results (append results (list c)
)
)
 (set! found #t)
 (break23 (quote nil)
)
)
 (quote nil)
)
)
)
)
)
)
 (quote nil)
)
 (set! ci (+ ci 1)
)
)
)
 (loop22)
)
 (quote nil)
)
)
)
)
 (loop22)
)
)
)
 (if (not found)
 (begin (set! results (append results (list "*error*")
)
)
)
 (quote nil)
)
 (set! wi (+ wi 1)
)
)
)
)
)
)
)
)
)
 (loop20)
)
 (quote nil)
)
)
)
)
 (loop20)
)
)
)
 (ret19 results)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret24)
 (let ((table (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append "" "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ")
 "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ")
 "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ")
 "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ")
 "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ")
 "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ")
 "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ")
 "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ")
)
)
 (begin (let ((sentence "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin")
)
 (begin (let ((tbl (readTable table)
)
)
 (begin (let ((commands (hash-table-ref tbl "commands")
)
)
 (begin (let ((mins (hash-table-ref tbl "mins")
)
)
 (begin (let ((words (fields sentence)
)
)
 (begin (let ((results (validate commands mins words)
)
)
 (begin (let ((out1 "user words:")
)
 (begin (let ((k 0)
)
 (begin (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (< k (length words)
)
 (begin (set! out1 (string-append out1 " ")
)
 (if (< k (- (length words)
 1)
)
 (begin (set! out1 (string-append out1 (padRight (list-ref words k)
 (string-length (list-ref results k)
)
)
)
)
)
 (begin (set! out1 (string-append out1 (list-ref words k)
)
)
)
)
 (set! k (+ k 1)
)
 (loop25)
)
 (quote nil)
)
)
)
)
 (loop25)
)
)
)
 (display (to-str out1)
)
 (newline)
 (display (to-str (string-append "full words: " (join results " ")
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
