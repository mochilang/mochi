;; Generated on 2025-07-25 08:58 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))(import (chibi time))
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(let ((start27 (now)
)
)
 (begin (define (fields s)
 (call/cc (lambda (ret1)
 (let ((words (list)
)
)
 (begin (let ((cur "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (let ((ch (substring s i (+ i 1)
)
)
)
 (begin (if (or (or (string=? ch " ")
 (string=? ch "\n")
)
 (string=? ch "\t")
)
 (begin (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! words (append words (list cur)
)
)
 (set! cur "")
)
 (quote nil)
)
)
 (begin (set! cur (string-append cur ch)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! words (append words (list cur)
)
)
)
 (quote nil)
)
 (ret1 words)
)
)
)
)
)
)
)
)
)
 (define (padRight s width)
 (call/cc (lambda (ret4)
 (let ((out s)
)
 (begin (let ((i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (< i width)
 (begin (set! out (string-append out " ")
)
 (set! i (+ i 1)
)
 (loop5)
)
 (quote nil)
)
)
)
)
 (loop5)
)
)
)
 (ret4 out)
)
)
)
)
)
)
)
 (define (join xs sep)
 (call/cc (lambda (ret7)
 (let ((res "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (< i (cond ((string? xs)
 (string-length xs)
)
 ((hash-table? xs)
 (hash-table-size xs)
)
 (else (length xs)
)
)
)
 (begin (if (> i 0)
 (begin (set! res (string-append res sep)
)
)
 (quote nil)
)
 (set! res (string-append res (list-ref xs i)
)
)
 (set! i (+ i 1)
)
 (loop8)
)
 (quote nil)
)
)
)
)
 (loop8)
)
)
)
 (ret7 res)
)
)
)
)
)
)
)
 (define (parseIntStr str)
 (call/cc (lambda (ret10)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote nil)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (< i (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
)
 (begin (set! n (+ (* n 10)
 (cond ((string? digits)
 (string-ref digits (substring str i (+ i 1)
)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop11)
)
 (quote nil)
)
)
)
)
 (loop11)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote nil)
)
 (ret10 n)
)
)
)
)
)
)
)
)
)
)
)
 (define (isDigits s)
 (call/cc (lambda (ret13)
 (begin (if (equal? (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 0)
 (begin (ret13 #f)
)
 (quote nil)
)
 (let ((i 0)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (let ((ch (substring s i (+ i 1)
)
)
)
 (begin (if (or (string<? ch "0")
 (string>? ch "9")
)
 (begin (ret13 #f)
)
 (quote nil)
)
 (set! i (+ i 1)
)
)
)
 (loop14)
)
 (quote nil)
)
)
)
)
 (loop14)
)
)
)
 (ret13 #t)
)
)
)
)
)
)
 (define (readTable table)
 (call/cc (lambda (ret16)
 (let ((toks (fields table)
)
)
 (begin (let ((cmds (list)
)
)
 (begin (let ((mins (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if (< i (cond ((string? toks)
 (string-length toks)
)
 ((hash-table? toks)
 (hash-table-size toks)
)
 (else (length toks)
)
)
)
 (begin (let ((cmd (list-ref toks i)
)
)
 (begin (let ((minlen (cond ((string? cmd)
 (string-length cmd)
)
 ((hash-table? cmd)
 (hash-table-size cmd)
)
 (else (length cmd)
)
)
)
)
 (begin (set! i (+ i 1)
)
 (if (and (< i (cond ((string? toks)
 (string-length toks)
)
 ((hash-table? toks)
 (hash-table-size toks)
)
 (else (length toks)
)
)
)
 (isDigits (list-ref toks i)
)
)
 (begin (let ((num (parseIntStr (list-ref toks i)
)
)
)
 (begin (if (and (>= num 1)
 (< num (cond ((string? cmd)
 (string-length cmd)
)
 ((hash-table? cmd)
 (hash-table-size cmd)
)
 (else (length cmd)
)
)
)
)
 (begin (set! minlen num)
 (set! i (+ i 1)
)
)
 (quote nil)
)
)
)
)
 (quote nil)
)
 (set! cmds (append cmds (list cmd)
)
)
 (set! mins (append mins (list minlen)
)
)
)
)
)
)
 (loop17)
)
 (quote nil)
)
)
)
)
 (loop17)
)
)
)
 (ret16 (alist->hash-table (list (cons "commands" cmds)
 (cons "mins" mins)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (validate commands mins words)
 (call/cc (lambda (ret19)
 (let ((results (list)
)
)
 (begin (let ((wi 0)
)
 (begin (call/cc (lambda (break21)
 (letrec ((loop20 (lambda ()
 (if (< wi (cond ((string? words)
 (string-length words)
)
 ((hash-table? words)
 (hash-table-size words)
)
 (else (length words)
)
)
)
 (begin (let ((w (list-ref words wi)
)
)
 (begin (let ((found #f)
)
 (begin (let ((wlen (cond ((string? w)
 (string-length w)
)
 ((hash-table? w)
 (hash-table-size w)
)
 (else (length w)
)
)
)
)
 (begin (let ((ci 0)
)
 (begin (call/cc (lambda (break23)
 (letrec ((loop22 (lambda ()
 (if (< ci (cond ((string? commands)
 (string-length commands)
)
 ((hash-table? commands)
 (hash-table-size commands)
)
 (else (length commands)
)
)
)
 (begin (let ((cmd (list-ref commands ci)
)
)
 (begin (if (and (and (not (equal? (list-ref mins ci)
 0)
)
 (>= wlen (list-ref mins ci)
)
)
 (<= wlen (cond ((string? cmd)
 (string-length cmd)
)
 ((hash-table? cmd)
 (hash-table-size cmd)
)
 (else (length cmd)
)
)
)
)
 (begin (let ((c (upper cmd)
)
)
 (begin (let ((ww (upper w)
)
)
 (begin (if (string=? (substring c 0 wlen)
 ww)
 (begin (set! results (append results (list c)
)
)
 (set! found #t)
 (break23 (quote nil)
)
)
 (quote nil)
)
)
)
)
)
)
 (quote nil)
)
 (set! ci (+ ci 1)
)
)
)
 (loop22)
)
 (quote nil)
)
)
)
)
 (loop22)
)
)
)
 (if (not found)
 (begin (set! results (append results (list "*error*")
)
)
)
 (quote nil)
)
 (set! wi (+ wi 1)
)
)
)
)
)
)
)
)
)
 (loop20)
)
 (quote nil)
)
)
)
)
 (loop20)
)
)
)
 (ret19 results)
)
)
)
)
)
)
)
 (define (main)
 (call/cc (lambda (ret24)
 (let ((table (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append "" "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ")
 "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ")
 "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ")
 "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ")
 "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ")
 "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ")
 "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ")
 "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ")
)
)
 (begin (let ((sentence "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin")
)
 (begin (let ((tbl (readTable table)
)
)
 (begin (let ((commands (hash-table-ref tbl "commands")
)
)
 (begin (let ((mins (hash-table-ref tbl "mins")
)
)
 (begin (let ((words (fields sentence)
)
)
 (begin (let ((results (validate commands mins words)
)
)
 (begin (let ((out1 "user words:")
)
 (begin (let ((k 0)
)
 (begin (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (< k (cond ((string? words)
 (string-length words)
)
 ((hash-table? words)
 (hash-table-size words)
)
 (else (length words)
)
)
)
 (begin (set! out1 (string-append out1 " ")
)
 (if (< k (- (cond ((string? words)
 (string-length words)
)
 ((hash-table? words)
 (hash-table-size words)
)
 (else (length words)
)
)
 1)
)
 (begin (set! out1 (string-append out1 (padRight (list-ref words k)
 (cond ((string? (list-ref results k)
)
 (string-length (list-ref results k)
)
)
 ((hash-table? (list-ref results k)
)
 (hash-table-size (list-ref results k)
)
)
 (else (length (list-ref results k)
)
)
)
)
)
)
)
 (begin (set! out1 (string-append out1 (list-ref words k)
)
)
)
)
 (set! k (+ k 1)
)
 (loop25)
)
 (quote nil)
)
)
)
)
 (loop25)
)
)
)
 (display (to-str out1)
)
 (newline)
 (display (to-str (string-append "full words: " (join results " ")
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (main)
 (let ((end28 (now)
)
)
 (let ((dur29 (quotient (- end28 start27)
 1000)
)
)
 (begin (display (string-append "{\n  \"duration_us\": " (number->string dur29)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
