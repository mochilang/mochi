;; Generated on 2025-07-25 08:58 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))(import (chibi time))
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(let ((start24 (now)
)
)
 (begin (define (sortRunes s)
 (call/cc (lambda (ret1)
 (let ((arr (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (set! arr (append arr (list (substring s i (+ i 1)
)
)
)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (let ((n (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
)
)
 (begin (let ((m 0)
)
 (begin (call/cc (lambda (break5)
 (letrec ((loop4 (lambda ()
 (if (< m n)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break7)
 (letrec ((loop6 (lambda ()
 (if (< j (- n 1)
)
 (begin (if (string>? (list-ref arr j)
 (list-ref arr (+ j 1)
)
)
 (begin (let ((tmp (list-ref arr j)
)
)
 (begin (list-set! arr j (list-ref arr (+ j 1)
)
)
 (list-set! arr (+ j 1)
 tmp)
)
)
)
 (quote nil)
)
 (set! j (+ j 1)
)
 (loop6)
)
 (quote nil)
)
)
)
)
 (loop6)
)
)
)
 (set! m (+ m 1)
)
)
)
 (loop4)
)
 (quote nil)
)
)
)
)
 (loop4)
)
)
)
 (let ((out "")
)
 (begin (set! i 0)
 (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (< i n)
 (begin (set! out (string-append out (list-ref arr i)
)
)
 (set! i (+ i 1)
)
 (loop8)
)
 (quote nil)
)
)
)
)
 (loop8)
)
)
)
 (ret1 out)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (sortStrings xs)
 (call/cc (lambda (ret10)
 (let ((res (list)
)
)
 (begin (let ((tmp xs)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (> (cond ((string? tmp)
 (string-length tmp)
)
 ((hash-table? tmp)
 (hash-table-size tmp)
)
 (else (length tmp)
)
)
 0)
 (begin (let ((min (list-ref tmp 0)
)
)
 (begin (let ((idx 0)
)
 (begin (let ((i 1)
)
 (begin (call/cc (lambda (break14)
 (letrec ((loop13 (lambda ()
 (if (< i (cond ((string? tmp)
 (string-length tmp)
)
 ((hash-table? tmp)
 (hash-table-size tmp)
)
 (else (length tmp)
)
)
)
 (begin (if (string<? (list-ref tmp i)
 min)
 (begin (set! min (list-ref tmp i)
)
 (set! idx i)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop13)
)
 (quote nil)
)
)
)
)
 (loop13)
)
)
)
 (set! res (append res (list min)
)
)
 (let ((out (list)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break16)
 (letrec ((loop15 (lambda ()
 (if (< j (cond ((string? tmp)
 (string-length tmp)
)
 ((hash-table? tmp)
 (hash-table-size tmp)
)
 (else (length tmp)
)
)
)
 (begin (if (not (equal? j idx)
)
 (begin (set! out (append out (list (list-ref tmp j)
)
)
)
)
 (quote nil)
)
 (set! j (+ j 1)
)
 (loop15)
)
 (quote nil)
)
)
)
)
 (loop15)
)
)
)
 (set! tmp out)
)
)
)
)
)
)
)
)
)
)
 (loop11)
)
 (quote nil)
)
)
)
)
 (loop11)
)
)
)
 (ret10 res)
)
)
)
)
)
)
)
 (define (main)
 (call/cc (lambda (ret17)
 (let ((words (list "abel" "able" "bale" "bela" "elba" "alger" "glare" "lager" "large" "regal" "angel" "angle" "galen" "glean" "lange" "caret" "carte" "cater" "crate" "trace" "elan" "lane" "lean" "lena" "neal" "evil" "levi" "live" "veil" "vile")
)
)
 (begin (let ((groups (alist->hash-table (list)
)
)
)
 (begin (let ((maxLen 0)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda (xs)
 (if (null? xs)
 (quote nil)
 (begin (let ((w (car xs)
)
)
 (begin (let ((k (sortRunes w)
)
)
 (begin (if (not (cond ((string? groups)
 (if (string-contains groups k)
 #t #f)
)
 ((hash-table? groups)
 (if (hash-table-exists? groups k)
 #t #f)
)
 (else (if (member k groups)
 #t #f)
)
)
)
 (begin (hash-table-set! groups k (list w)
)
)
 (begin (hash-table-set! groups k (append (hash-table-ref groups k)
 (list w)
)
)
)
)
 (if (> (cond ((string? (hash-table-ref groups k)
)
 (string-length (hash-table-ref groups k)
)
)
 ((hash-table? (hash-table-ref groups k)
)
 (hash-table-size (hash-table-ref groups k)
)
)
 (else (length (hash-table-ref groups k)
)
)
)
 maxLen)
 (begin (set! maxLen (cond ((string? (hash-table-ref groups k)
)
 (string-length (hash-table-ref groups k)
)
)
 ((hash-table? (hash-table-ref groups k)
)
 (hash-table-size (hash-table-ref groups k)
)
)
 (else (length (hash-table-ref groups k)
)
)
)
)
)
 (quote nil)
)
)
)
)
)
 (loop18 (cdr xs)
)
)
)
)
)
)
 (loop18 words)
)
)
)
 (let ((printed (alist->hash-table (list)
)
)
)
 (begin (call/cc (lambda (break21)
 (letrec ((loop20 (lambda (xs)
 (if (null? xs)
 (quote nil)
 (begin (let ((w (car xs)
)
)
 (begin (let ((k (sortRunes w)
)
)
 (begin (if (equal? (cond ((string? (hash-table-ref groups k)
)
 (string-length (hash-table-ref groups k)
)
)
 ((hash-table? (hash-table-ref groups k)
)
 (hash-table-size (hash-table-ref groups k)
)
)
 (else (length (hash-table-ref groups k)
)
)
)
 maxLen)
 (begin (if (not (cond ((string? printed)
 (if (string-contains printed k)
 #t #f)
)
 ((hash-table? printed)
 (if (hash-table-exists? printed k)
 #t #f)
)
 (else (if (member k printed)
 #t #f)
)
)
)
 (begin (let ((g (sortStrings (hash-table-ref groups k)
)
)
)
 (begin (let ((line (string-append "[" (list-ref g 0)
)
)
)
 (begin (let ((i 1)
)
 (begin (call/cc (lambda (break23)
 (letrec ((loop22 (lambda ()
 (if (< i (cond ((string? g)
 (string-length g)
)
 ((hash-table? g)
 (hash-table-size g)
)
 (else (length g)
)
)
)
 (begin (set! line (string-append (string-append line " ")
 (list-ref g i)
)
)
 (set! i (+ i 1)
)
 (loop22)
)
 (quote nil)
)
)
)
)
 (loop22)
)
)
)
 (set! line (string-append line "]")
)
 (display (to-str line)
)
 (newline)
 (hash-table-set! printed k #t)
)
)
)
)
)
)
)
 (quote nil)
)
)
 (quote nil)
)
)
)
)
)
 (loop20 (cdr xs)
)
)
)
)
)
)
 (loop20 words)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (main)
 (let ((end25 (now)
)
)
 (let ((dur26 (quotient (- end25 start24)
 1000)
)
)
 (begin (display (string-append "{\n  \"duration_us\": " (number->string dur26)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
