;; Generated on 2025-07-28 11:25 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((idx (string-contains r del)))
            (if idx
                (loop (substring r (+ idx (string-length del)))
                      (cons (substring r 0 idx) acc))
                (reverse (cons r acc)))))))))
(define months (alist->hash-table (_list (cons "January" 1)
 (cons "February" 2)
 (cons "March" 3)
 (cons "April" 4)
 (cons "May" 5)
 (cons "June" 6)
 (cons "July" 7)
 (cons "August" 8)
 (cons "September" 9)
 (cons "October" 10)
 (cons "November" 11)
 (cons "December" 12)
)
)
)
(define (isLeap y)
 (call/cc (lambda (ret1)
 (begin (if (equal? (modulo y 400)
 0)
 (begin (ret1 #t)
)
 (quote ()
)
)
 (if (equal? (modulo y 100)
 0)
 (begin (ret1 #f)
)
 (quote ()
)
)
 (ret1 (equal? (modulo y 4)
 0)
)
)
)
)
)
(define (daysInMonth y m)
 (call/cc (lambda (ret2)
 (let ((feb (if (isLeap y)
 29 28)
)
)
 (begin (let ((lengths (_list 31 feb 31 30 31 30 31 31 30 31 30 31)
)
)
 (begin (ret2 (list-ref lengths (- m 1)
)
)
)
)
)
)
)
)
)
(define (daysBeforeYear y)
 (call/cc (lambda (ret3)
 (let ((days 0)
)
 (begin (let ((yy 1970)
)
 (begin (call/cc (lambda (break5)
 (letrec ((loop4 (lambda ()
 (if (< yy y)
 (begin (set! days (+ days 365)
)
 (if (isLeap yy)
 (begin (set! days (+ days 1)
)
)
 (quote ()
)
)
 (set! yy (+ yy 1)
)
 (loop4)
)
 (quote ()
)
)
)
)
)
 (loop4)
)
)
)
 (ret3 days)
)
)
)
)
)
)
)
(define (daysBeforeMonth y m)
 (call/cc (lambda (ret6)
 (let ((days 0)
)
 (begin (let ((mm 1)
)
 (begin (call/cc (lambda (break8)
 (letrec ((loop7 (lambda ()
 (if (< mm m)
 (begin (set! days (_add days (daysInMonth y mm)
)
)
 (set! mm (+ mm 1)
)
 (loop7)
)
 (quote ()
)
)
)
)
)
 (loop7)
)
)
)
 (ret6 days)
)
)
)
)
)
)
)
(define (epochSeconds y m d h mi)
 (call/cc (lambda (ret9)
 (let ((days (_add (_add (daysBeforeYear y)
 (daysBeforeMonth y m)
)
 (- d 1)
)
)
)
 (begin (ret9 (_add (_add (* days 86400)
 (* h 3600)
)
 (* mi 60)
)
)
)
)
)
)
)
(define (fromEpoch sec)
 (call/cc (lambda (ret10)
 (let ((days (quotient sec 86400)
)
)
 (begin (let ((rem (modulo sec 86400)
)
)
 (begin (let ((y 1970)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if #t (begin (let ((dy (if (isLeap y)
 366 365)
)
)
 (begin (if (>= days dy)
 (begin (set! days (- days dy)
)
 (set! y (+ y 1)
)
)
 (begin (break12 (quote ()
)
)
)
)
)
)
 (loop11)
)
 (quote ()
)
)
)
)
)
 (loop11)
)
)
)
 (let ((m 1)
)
 (begin (call/cc (lambda (break14)
 (letrec ((loop13 (lambda ()
 (if #t (begin (let ((dim (daysInMonth y m)
)
)
 (begin (if (_ge days dim)
 (begin (set! days (- days dim)
)
 (set! m (+ m 1)
)
)
 (begin (break14 (quote ()
)
)
)
)
)
)
 (loop13)
)
 (quote ()
)
)
)
)
)
 (loop13)
)
)
)
 (let ((d (+ days 1)
)
)
 (begin (let ((h (quotient rem 3600)
)
)
 (begin (let ((mi (quotient (modulo rem 3600)
 60)
)
)
 (begin (ret10 (_list y m d h mi)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (pad2 n)
 (call/cc (lambda (ret15)
 (begin (if (< n 10)
 (begin (ret15 (string-append "0" (to-str n)
)
)
)
 (quote ()
)
)
 (ret15 (to-str n)
)
)
)
)
)
(define (absInt n)
 (call/cc (lambda (ret16)
 (begin (if (< n 0)
 (begin (ret16 (- n)
)
)
 (quote ()
)
)
 (ret16 n)
)
)
)
)
(define (formatDate parts offset abbr)
 (call/cc (lambda (ret17)
 (let ((y (list-ref parts 0)
)
)
 (begin (let ((m (list-ref parts 1)
)
)
 (begin (let ((d (list-ref parts 2)
)
)
 (begin (let ((h (list-ref parts 3)
)
)
 (begin (let ((mi (list-ref parts 4)
)
)
 (begin (let ((sign "+")
)
 (begin (if (< offset 0)
 (begin (set! sign "-")
)
 (quote ()
)
)
 (let ((off (/ (absInt offset)
 60)
)
)
 (begin (let ((offh (pad2 (/ off 60)
)
)
)
 (begin (let ((offm (pad2 (fmod off 60)
)
)
)
 (begin (ret17 (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (to-str y)
 "-")
 (pad2 m)
)
 "-")
 (pad2 d)
)
 " ")
 (pad2 h)
)
 ":")
 (pad2 mi)
)
 ":00 ")
 sign)
 offh)
 offm)
 " ")
 abbr)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (parseIntStr str)
 (call/cc (lambda (ret18)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote ()
)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (_list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break20)
 (letrec ((loop19 (lambda ()
 (if (< i (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
)
 (begin (set! n (_add (* n 10)
 (cond ((string? digits)
 (substring digits (substring str i (+ i 1)
)
 (+ (substring str i (+ i 1)
)
 1)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop19)
)
 (quote ()
)
)
)
)
)
 (loop19)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote ()
)
)
 (ret18 n)
)
)
)
)
)
)
)
)
)
)
)
(define (indexOf s ch)
 (call/cc (lambda (ret21)
 (let ((i 0)
)
 (begin (call/cc (lambda (break23)
 (letrec ((loop22 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (if (string=? (substring s i (+ i 1)
)
 ch)
 (begin (ret21 i)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop22)
)
 (quote ()
)
)
)
)
)
 (loop22)
)
)
)
 (ret21 (- 1)
)
)
)
)
)
)
(define (parseTime s)
 (call/cc (lambda (ret24)
 (let ((c (indexOf s ":")
)
)
 (begin (let ((h (_parseIntStr (substring s 0 c)
 10)
)
)
 (begin (let ((mi (_parseIntStr (substring s (_add c 1)
 (_add c 3)
)
 10)
)
)
 (begin (let ((ampm (substring s (- (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 2)
 (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
)
)
 (begin (let ((hh h)
)
 (begin (if (and (string=? ampm "pm")
 (not (equal? h 12)
)
)
 (begin (set! hh (_add h 12)
)
)
 (quote ()
)
)
 (if (and (string=? ampm "am")
 (equal? h 12)
)
 (begin (set! hh 0)
)
 (quote ()
)
)
 (ret24 (_list hh mi)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret25)
 (let ((input "March 7 2009 7:30pm EST")
)
 (begin (_display (to-str (string-append "Input:              " input)
)
)
 (newline)
 (let ((parts (_list)
)
)
 (begin (let ((cur "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break27)
 (letrec ((loop26 (lambda ()
 (if (< i (cond ((string? input)
 (string-length input)
)
 ((hash-table? input)
 (hash-table-size input)
)
 (else (length input)
)
)
)
 (begin (let ((ch (substring input i (+ i 1)
)
)
)
 (begin (if (string=? ch " ")
 (begin (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! parts (append parts (_list cur)
)
)
 (set! cur "")
)
 (quote ()
)
)
)
 (begin (set! cur (string-append cur ch)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop26)
)
 (quote ()
)
)
)
)
)
 (loop26)
)
)
)
 (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! parts (append parts (_list cur)
)
)
)
 (quote ()
)
)
 (let ((month (cond ((string? months)
 (substring months (list-ref parts 0)
 (+ (list-ref parts 0)
 1)
)
)
 ((hash-table? months)
 (hash-table-ref months (list-ref parts 0)
)
)
 (else (list-ref months (list-ref parts 0)
)
)
)
)
)
 (begin (let ((day (_parseIntStr (list-ref parts 1)
 10)
)
)
 (begin (let ((year (_parseIntStr (list-ref parts 2)
 10)
)
)
 (begin (let ((tm (parseTime (list-ref parts 3)
)
)
)
 (begin (let ((hour (cond ((string? tm)
 (substring tm 0 (+ 0 1)
)
)
 ((hash-table? tm)
 (hash-table-ref tm 0)
)
 (else (list-ref tm 0)
)
)
)
)
 (begin (let ((minute (cond ((string? tm)
 (substring tm 1 (+ 1 1)
)
)
 ((hash-table? tm)
 (hash-table-ref tm 1)
)
 (else (list-ref tm 1)
)
)
)
)
 (begin (let ((tz (list-ref parts 4)
)
)
 (begin (let ((zoneOffsets (alist->hash-table (_list (cons "EST" (- 18000)
)
 (cons "EDT" (- 14400)
)
 (cons "MST" (- 25200)
)
)
)
)
)
 (begin (let ((local (epochSeconds year month day hour minute)
)
)
 (begin (let ((utc (- local (cond ((string? zoneOffsets)
 (substring zoneOffsets tz (+ tz 1)
)
)
 ((hash-table? zoneOffsets)
 (hash-table-ref zoneOffsets tz)
)
 (else (list-ref zoneOffsets tz)
)
)
)
)
)
 (begin (let ((utc12 (_add utc 43200)
)
)
 (begin (let ((startDST (epochSeconds 2009 3 8 7 0)
)
)
 (begin (let ((offEast (- 18000)
)
)
 (begin (if (_ge utc12 startDST)
 (begin (set! offEast (- 14400)
)
)
 (quote ()
)
)
 (let ((eastParts (fromEpoch (_add utc12 offEast)
)
)
)
 (begin (let ((eastAbbr "EST")
)
 (begin (if (equal? offEast (- 14400)
)
 (begin (set! eastAbbr "EDT")
)
 (quote ()
)
)
 (_display (to-str (string-append "+12 hrs:            " (formatDate eastParts offEast eastAbbr)
)
)
)
 (newline)
 (let ((offAZ (- 25200)
)
)
 (begin (let ((azParts (fromEpoch (_add utc12 offAZ)
)
)
)
 (begin (_display (to-str (string-append "+12 hrs in Arizona: " (formatDate azParts offAZ "MST")
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
