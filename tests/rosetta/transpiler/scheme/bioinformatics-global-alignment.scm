;; Generated on 2025-07-25 21:06 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (padLeft s w)
 (call/cc (lambda (ret1)
 (let ((res "")
)
 (begin (let ((n (- w (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (> n 0)
 (begin (set! res (string-append res " ")
)
 (set! n (- n 1)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (ret1 (string-append res s)
)
)
)
)
)
)
)
)
(define (indexOfFrom s ch start)
 (call/cc (lambda (ret4)
 (let ((i start)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (if (string=? (substring s i (+ i 1)
)
 ch)
 (begin (ret4 i)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop5)
)
 (quote ()
)
)
)
)
)
 (loop5)
)
)
)
 (ret4 (- 1)
)
)
)
)
)
)
(define (containsStr s sub)
 (call/cc (lambda (ret7)
 (let ((i 0)
)
 (begin (let ((sl (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
)
 (begin (let ((subl (cond ((string? sub)
 (string-length sub)
)
 ((hash-table? sub)
 (hash-table-size sub)
)
 (else (length sub)
)
)
)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (<= i (- sl subl)
)
 (begin (if (string=? (substring s i (+ i subl)
)
 sub)
 (begin (ret7 #t)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop8)
)
 (quote ()
)
)
)
)
)
 (loop8)
)
)
)
 (ret7 #f)
)
)
)
)
)
)
)
)
)
(define (distinct slist)
 (call/cc (lambda (ret10)
 (let ((res (_list)
)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((s (car xs)
)
)
 (begin (let ((found #f)
)
 (begin (call/cc (lambda (break14)
 (letrec ((loop13 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((r (car xs)
)
)
 (begin (if (equal? r s)
 (begin (set! found #t)
 (break14 (quote ()
)
)
)
 (quote ()
)
)
)
)
 (loop13 (cdr xs)
)
)
)
)
)
)
 (loop13 res)
)
)
)
 (if (not found)
 (begin (set! res (append res (_list s)
)
)
)
 (quote ()
)
)
)
)
)
)
 (loop11 (cdr xs)
)
)
)
)
)
)
 (loop11 slist)
)
)
)
 (ret10 res)
)
)
)
)
)
(define (permutations xs)
 (call/cc (lambda (ret15)
 (begin (if (<= (cond ((string? xs)
 (string-length xs)
)
 ((hash-table? xs)
 (hash-table-size xs)
)
 (else (length xs)
)
)
 1)
 (begin (ret15 (_list xs)
)
)
 (quote ()
)
)
 (let ((res (_list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break17)
 (letrec ((loop16 (lambda ()
 (if (< i (cond ((string? xs)
 (string-length xs)
)
 ((hash-table? xs)
 (hash-table-size xs)
)
 (else (length xs)
)
)
)
 (begin (let ((rest (_list)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda ()
 (if (< j (cond ((string? xs)
 (string-length xs)
)
 ((hash-table? xs)
 (hash-table-size xs)
)
 (else (length xs)
)
)
)
 (begin (if (not (equal? j i)
)
 (begin (set! rest (append rest (_list (list-ref xs j)
)
)
)
)
 (quote ()
)
)
 (set! j (+ j 1)
)
 (loop18)
)
 (quote ()
)
)
)
)
)
 (loop18)
)
)
)
 (let ((subs (permutations rest)
)
)
 (begin (call/cc (lambda (break21)
 (letrec ((loop20 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((p (car xs)
)
)
 (begin (let ((perm (_list (list-ref xs i)
)
)
)
 (begin (let ((k 0)
)
 (begin (call/cc (lambda (break23)
 (letrec ((loop22 (lambda ()
 (if (< k (cond ((string? p)
 (string-length p)
)
 ((hash-table? p)
 (hash-table-size p)
)
 (else (length p)
)
)
)
 (begin (set! perm (append perm (_list (cond ((string? p)
 (substring p k (+ k 1)
)
)
 ((hash-table? p)
 (hash-table-ref p k)
)
 (else (list-ref p k)
)
)
)
)
)
 (set! k (+ k 1)
)
 (loop22)
)
 (quote ()
)
)
)
)
)
 (loop22)
)
)
)
 (set! res (append res (_list perm)
)
)
)
)
)
)
)
)
 (loop20 (cdr xs)
)
)
)
)
)
)
 (loop20 subs)
)
)
)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop16)
)
 (quote ()
)
)
)
)
)
 (loop16)
)
)
)
 (ret15 res)
)
)
)
)
)
)
)
)
(define (headTailOverlap s1 s2)
 (call/cc (lambda (ret24)
 (let ((start 0)
)
 (begin (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if #t (begin (let ((ix (indexOfFrom s1 (substring s2 0 1)
 start)
)
)
 (begin (if (equal? ix (- 0 1)
)
 (begin (ret24 0)
)
 (quote ()
)
)
 (set! start ix)
 (if (string=? (substring s2 0 (- (cond ((string? s1)
 (string-length s1)
)
 ((hash-table? s1)
 (hash-table-size s1)
)
 (else (length s1)
)
)
 start)
)
 (substring s1 start (cond ((string? s1)
 (string-length s1)
)
 ((hash-table? s1)
 (hash-table-size s1)
)
 (else (length s1)
)
)
)
)
 (begin (ret24 (- (cond ((string? s1)
 (string-length s1)
)
 ((hash-table? s1)
 (hash-table-size s1)
)
 (else (length s1)
)
)
 start)
)
)
 (quote ()
)
)
 (set! start (+ start 1)
)
)
)
 (loop25)
)
 (quote ()
)
)
)
)
)
 (loop25)
)
)
)
)
)
)
)
)
(define (deduplicate slist)
 (call/cc (lambda (ret27)
 (let ((arr (distinct slist)
)
)
 (begin (let ((filtered (_list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break29)
 (letrec ((loop28 (lambda ()
 (if (< i (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
)
 (begin (let ((s1 (cond ((string? arr)
 (substring arr i (+ i 1)
)
)
 ((hash-table? arr)
 (hash-table-ref arr i)
)
 (else (list-ref arr i)
)
)
)
)
 (begin (let ((within #f)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break31)
 (letrec ((loop30 (lambda ()
 (if (< j (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
)
 (begin (if (and (not (equal? j i)
)
 (containsStr (cond ((string? arr)
 (substring arr j (+ j 1)
)
)
 ((hash-table? arr)
 (hash-table-ref arr j)
)
 (else (list-ref arr j)
)
)
 s1)
)
 (begin (set! within #t)
 (break31 (quote ()
)
)
)
 (quote ()
)
)
 (set! j (+ j 1)
)
 (loop30)
)
 (quote ()
)
)
)
)
)
 (loop30)
)
)
)
 (if (not within)
 (begin (set! filtered (append filtered (_list s1)
)
)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop28)
)
 (quote ()
)
)
)
)
)
 (loop28)
)
)
)
 (ret27 filtered)
)
)
)
)
)
)
)
)
)
(define (joinAll ss)
 (call/cc (lambda (ret32)
 (let ((out "")
)
 (begin (call/cc (lambda (break34)
 (letrec ((loop33 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((s (car xs)
)
)
 (begin (set! out (string-append out s)
)
)
)
 (loop33 (cdr xs)
)
)
)
)
)
)
 (loop33 ss)
)
)
)
 (ret32 out)
)
)
)
)
)
(define (shortestCommonSuperstring slist)
 (call/cc (lambda (ret35)
 (let ((ss (deduplicate slist)
)
)
 (begin (let ((shortest (joinAll ss)
)
)
 (begin (let ((perms (permutations ss)
)
)
 (begin (let ((idx 0)
)
 (begin (call/cc (lambda (break37)
 (letrec ((loop36 (lambda ()
 (if (< idx (cond ((string? perms)
 (string-length perms)
)
 ((hash-table? perms)
 (hash-table-size perms)
)
 (else (length perms)
)
)
)
 (begin (let ((perm (cond ((string? perms)
 (substring perms idx (+ idx 1)
)
)
 ((hash-table? perms)
 (hash-table-ref perms idx)
)
 (else (list-ref perms idx)
)
)
)
)
 (begin (let ((sup (cond ((string? perm)
 (substring perm 0 (+ 0 1)
)
)
 ((hash-table? perm)
 (hash-table-ref perm 0)
)
 (else (list-ref perm 0)
)
)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break39)
 (letrec ((loop38 (lambda ()
 (if (< i (- (cond ((string? ss)
 (string-length ss)
)
 ((hash-table? ss)
 (hash-table-size ss)
)
 (else (length ss)
)
)
 1)
)
 (begin (let ((ov (headTailOverlap (cond ((string? perm)
 (substring perm i (+ i 1)
)
)
 ((hash-table? perm)
 (hash-table-ref perm i)
)
 (else (list-ref perm i)
)
)
 (cond ((string? perm)
 (substring perm (+ i 1)
 (+ (+ i 1)
 1)
)
)
 ((hash-table? perm)
 (hash-table-ref perm (+ i 1)
)
)
 (else (list-ref perm (+ i 1)
)
)
)
)
)
)
 (begin (set! sup (string-append sup (substring (cond ((string? perm)
 (substring perm (+ i 1)
 (+ (+ i 1)
 1)
)
)
 ((hash-table? perm)
 (hash-table-ref perm (+ i 1)
)
)
 (else (list-ref perm (+ i 1)
)
)
)
 ov (cond ((string? (cond ((string? perm)
 (substring perm (+ i 1)
 (+ (+ i 1)
 1)
)
)
 ((hash-table? perm)
 (hash-table-ref perm (+ i 1)
)
)
 (else (list-ref perm (+ i 1)
)
)
)
)
 (string-length (cond ((string? perm)
 (substring perm (+ i 1)
 (+ (+ i 1)
 1)
)
)
 ((hash-table? perm)
 (hash-table-ref perm (+ i 1)
)
)
 (else (list-ref perm (+ i 1)
)
)
)
)
)
 ((hash-table? (cond ((string? perm)
 (substring perm (+ i 1)
 (+ (+ i 1)
 1)
)
)
 ((hash-table? perm)
 (hash-table-ref perm (+ i 1)
)
)
 (else (list-ref perm (+ i 1)
)
)
)
)
 (hash-table-size (cond ((string? perm)
 (substring perm (+ i 1)
 (+ (+ i 1)
 1)
)
)
 ((hash-table? perm)
 (hash-table-ref perm (+ i 1)
)
)
 (else (list-ref perm (+ i 1)
)
)
)
)
)
 (else (length (cond ((string? perm)
 (substring perm (+ i 1)
 (+ (+ i 1)
 1)
)
)
 ((hash-table? perm)
 (hash-table-ref perm (+ i 1)
)
)
 (else (list-ref perm (+ i 1)
)
)
)
)
)
)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop38)
)
 (quote ()
)
)
)
)
)
 (loop38)
)
)
)
 (if (< (cond ((string? sup)
 (string-length sup)
)
 ((hash-table? sup)
 (hash-table-size sup)
)
 (else (length sup)
)
)
 (cond ((string? shortest)
 (string-length shortest)
)
 ((hash-table? shortest)
 (hash-table-size shortest)
)
 (else (length shortest)
)
)
)
 (begin (set! shortest sup)
)
 (quote ()
)
)
 (set! idx (+ idx 1)
)
)
)
)
)
)
)
 (loop36)
)
 (quote ()
)
)
)
)
)
 (loop36)
)
)
)
 (ret35 shortest)
)
)
)
)
)
)
)
)
)
)
)
(define (printCounts seq)
 (call/cc (lambda (ret40)
 (let ((a 0)
)
 (begin (let ((c 0)
)
 (begin (let ((g 0)
)
 (begin (let ((t 0)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break42)
 (letrec ((loop41 (lambda ()
 (if (< i (cond ((string? seq)
 (string-length seq)
)
 ((hash-table? seq)
 (hash-table-size seq)
)
 (else (length seq)
)
)
)
 (begin (let ((ch (substring seq i (+ i 1)
)
)
)
 (begin (if (string=? ch "A")
 (begin (set! a (+ a 1)
)
)
 (begin (if (string=? ch "C")
 (begin (set! c (+ c 1)
)
)
 (begin (if (string=? ch "G")
 (begin (set! g (+ g 1)
)
)
 (begin (if (string=? ch "T")
 (begin (set! t (+ t 1)
)
)
 (quote ()
)
)
)
)
)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop41)
)
 (quote ()
)
)
)
)
)
 (loop41)
)
)
)
 (let ((total (cond ((string? seq)
 (string-length seq)
)
 ((hash-table? seq)
 (hash-table-size seq)
)
 (else (length seq)
)
)
)
)
 (begin (display (to-str (string-append (string-append "\nNucleotide counts for " seq)
 ":\n")
)
)
 (newline)
 (display (to-str (+ (padLeft "A" 10)
 (padLeft (to-str a)
 12)
)
)
)
 (newline)
 (display (to-str (+ (padLeft "C" 10)
 (padLeft (to-str c)
 12)
)
)
)
 (newline)
 (display (to-str (+ (padLeft "G" 10)
 (padLeft (to-str g)
 12)
)
)
)
 (newline)
 (display (to-str (+ (padLeft "T" 10)
 (padLeft (to-str t)
 12)
)
)
)
 (newline)
 (display (to-str (+ (padLeft "Other" 10)
 (padLeft (to-str (- total (+ (+ (+ a c)
 g)
 t)
)
)
 12)
)
)
)
 (newline)
 (display (to-str "  ____________________")
)
 (newline)
 (display (to-str (+ (padLeft "Total length" 14)
 (padLeft (to-str total)
 8)
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret43)
 (let ((tests (_list (_list "TA" "AAG" "TA" "GAA" "TA")
 (_list "CATTAGGG" "ATTAG" "GGG" "TA")
 (_list "AAGAUGGA" "GGAGCGCAUC" "AUCGCAAUAAGGA")
 (_list "ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT" "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT" "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA" "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC" "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT" "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC" "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT" "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC" "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC" "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT" "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC" "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA" "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA")
)
)
)
 (begin (call/cc (lambda (break45)
 (letrec ((loop44 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((seqs (car xs)
)
)
 (begin (let ((scs (shortestCommonSuperstring seqs)
)
)
 (begin (printCounts scs)
)
)
)
)
 (loop44 (cdr xs)
)
)
)
)
)
)
 (loop44 tests)
)
)
)
)
)
)
)
)
(main)
