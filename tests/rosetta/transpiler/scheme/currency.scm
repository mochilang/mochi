;; Generated on 2025-08-03 09:40 +0700
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(import (srfi 1))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (exact (floor (* (current-second) 1000000000))))
)
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(let ((start20 (now))) (begin (define (parseIntDigits s) (call/cc (lambda (ret1) (let ((n 0)) (begin (let ((i 0)) (begin (let ((digits (alist->hash-table (_list (cons "0" 0) (cons "1" 1) (cons "2" 2) (cons "3" 3) (cons "4" 4) (cons "5" 5) (cons "6" 6) (cons "7" 7) (cons "8" 8) (cons "9" 9))))) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda () (if (< i (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))) (begin (let ((ch (_substring s i (+ i 1)))) (begin (if (not (cond ((string? digits) (if (string-contains digits ch) #t #f)) ((hash-table? digits) (if (hash-table-exists? digits ch) #t #f)) (else (if (member ch digits) #t #f)))) (begin (ret1 0)) (quote ())) (set! n (_add (* n 10) (cond ((string? digits) (_substring digits ch (+ ch 1))) ((hash-table? digits) (hash-table-ref digits ch)) (else (list-ref digits ch))))) (set! i (+ i 1)))) (loop2)) (quote ()))))) (loop2)))) (ret1 n)))))))))) (define (parseDC s) (call/cc (lambda (ret4) (let ((neg #f)) (begin (if (and (> (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))) 0) (string=? (_substring s 0 1) "-")) (begin (set! neg #t) (set! s (_substring s 1 (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))))) (quote ())) (let ((dollars 0)) (begin (let ((cents 0)) (begin (let ((i 0)) (begin (let ((seenDot #f)) (begin (let ((centDigits 0)) (begin (call/cc (lambda (break6) (letrec ((loop5 (lambda () (if (< i (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))) (begin (let ((ch (_substring s i (+ i 1)))) (begin (if (string=? ch ".") (begin (set! seenDot #t) (set! i (+ i 1)) (loop5)) (quote ())) (let ((d (parseIntDigits ch))) (begin (if seenDot (begin (if (< centDigits 2) (begin (set! cents (_add (* cents 10) d)) (set! centDigits (+ centDigits 1))) (quote ()))) (begin (set! dollars (_add (* dollars 10) d)))) (set! i (+ i 1)))))) (loop5)) (quote ()))))) (loop5)))) (if (equal? centDigits 1) (begin (set! cents (* cents 10))) (quote ())) (let ((val (_add (* dollars 100) cents))) (begin (if neg (begin (set! val (- val))) (quote ())) (ret4 val)))))))))))))))))) (define (parseRate s) (call/cc (lambda (ret7) (let ((neg #f)) (begin (if (and (> (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))) 0) (string=? (_substring s 0 1) "-")) (begin (set! neg #t) (set! s (_substring s 1 (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))))) (quote ())) (let ((whole 0)) (begin (let ((frac 0)) (begin (let ((digits 0)) (begin (let ((seenDot #f)) (begin (let ((i 0)) (begin (call/cc (lambda (break9) (letrec ((loop8 (lambda () (if (< i (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s)))) (begin (let ((ch (_substring s i (+ i 1)))) (begin (if (string=? ch ".") (begin (set! seenDot #t) (set! i (+ i 1)) (loop8)) (quote ())) (let ((d (parseIntDigits ch))) (begin (if seenDot (begin (if (< digits 4) (begin (set! frac (_add (* frac 10) d)) (set! digits (+ digits 1))) (quote ()))) (begin (set! whole (_add (* whole 10) d)))) (set! i (+ i 1)))))) (loop8)) (quote ()))))) (loop8)))) (call/cc (lambda (break11) (letrec ((loop10 (lambda () (if (< digits 4) (begin (set! frac (* frac 10)) (set! digits (+ digits 1)) (loop10)) (quote ()))))) (loop10)))) (let ((val (_add (* whole 10000) frac))) (begin (if neg (begin (set! val (- val))) (quote ())) (ret7 val)))))))))))))))))) (define (dcString dc) (call/cc (lambda (ret12) (let ((d (quotient dc 100))) (begin (let ((n dc)) (begin (if (< n 0) (begin (set! n (- n))) (quote ())) (let ((c (modulo n 100))) (begin (let ((cstr (to-str c))) (begin (if (equal? (cond ((string? cstr) (string-length cstr)) ((hash-table? cstr) (hash-table-size cstr)) (else (length cstr))) 1) (begin (set! cstr (string-append "0" cstr))) (quote ())) (ret12 (string-append (string-append (to-str d) ".") cstr))))))))))))) (define (extend dc n) (call/cc (lambda (ret13) (ret13 (* dc n))))) (define (tax total rate) (call/cc (lambda (ret14) (ret14 (let ((v15 (quotient (_add (* total rate) 5000) 10000))) (cond ((string? v15) (inexact->exact (floor (string->number v15)))) ((boolean? v15) (if v15 1 0)) (else (inexact->exact (floor v15))))))))) (define (padLeft s n) (call/cc (lambda (ret16) (let ((out s)) (begin (call/cc (lambda (break18) (letrec ((loop17 (lambda () (if (< (cond ((string? out) (string-length out)) ((hash-table? out) (hash-table-size out)) (else (length out))) n) (begin (set! out (string-append " " out)) (loop17)) (quote ()))))) (loop17)))) (ret16 out)))))) (define (main) (call/cc (lambda (ret19) (let ((hp (parseDC "5.50"))) (begin (let ((mp (parseDC "2.86"))) (begin (let ((rate (parseRate "0.0765"))) (begin (let ((totalBeforeTax (_add (extend hp 4000000000000000) (extend mp 2)))) (begin (let ((t (tax totalBeforeTax rate))) (begin (let ((total (_add totalBeforeTax t))) (begin (_display (to-str (string-append "Total before tax: " (padLeft (dcString totalBeforeTax) 22)))) (newline) (_display (to-str (string-append "             Tax: " (padLeft (dcString t) 22)))) (newline) (_display (to-str (string-append "           Total: " (padLeft (dcString total) 22)))) (newline)))))))))))))))) (main) (let ((end21 (now))) (let ((dur22 (quotient (- end21 start20) 1000))) (begin (_display (string-append "{\n  \"duration_us\": " (number->string dur22) ",\n  \"memory_bytes\": " (number->string (_mem)) ",\n  \"name\": \"main\"\n}")) (newline))))))
