;; Generated on 2025-07-23 13:01 +0700
(import (only (scheme base) call/cc list-ref list-set! list))
(import (scheme time))
(import (srfi 69))
(import (chibi io))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (_input)
  (let ((l (read-line)))
    (if (eof-object? l) "" l)))
(define board (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0)
)
(define solved (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0)
)
(define empty 15)
(define moves 0)
(define quit #f)
(define (randMove)
 (call/cc (lambda (ret1)
 (ret1 (modulo (current-jiffy)
 4)
)
)
)
)
(define (isSolved)
 (call/cc (lambda (ret2)
 (let ((i 0)
)
 (begin (call/cc (lambda (break4)
 (letrec ((loop3 (lambda ()
 (if (< i 16)
 (begin (if (not (= (list-ref board i)
 (list-ref solved i)
)
)
 (begin (ret2 #f)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop3)
)
 (quote nil)
)
)
)
)
 (loop3)
)
)
)
 (ret2 #t)
)
)
)
)
)
(define (isValidMove m)
 (call/cc (lambda (ret5)
 (begin (if (= m 0)
 (begin (ret5 (alist->hash-table (list (cons "idx" (- empty 4)
)
 (cons "ok" (> (quotient empty 4)
 0)
)
)
)
)
)
 (quote nil)
)
 (if (= m 1)
 (begin (ret5 (alist->hash-table (list (cons "idx" (+ empty 4)
)
 (cons "ok" (< (quotient empty 4)
 3)
)
)
)
)
)
 (quote nil)
)
 (if (= m 2)
 (begin (ret5 (alist->hash-table (list (cons "idx" (+ empty 1)
)
 (cons "ok" (< (modulo empty 4)
 3)
)
)
)
)
)
 (quote nil)
)
 (if (= m 3)
 (begin (ret5 (alist->hash-table (list (cons "idx" (- empty 1)
)
 (cons "ok" (> (modulo empty 4)
 0)
)
)
)
)
)
 (quote nil)
)
 (ret5 (alist->hash-table (list (cons "idx" 0)
 (cons "ok" #f)
)
)
)
)
)
)
)
(define (doMove m)
 (call/cc (lambda (ret6)
 (let ((r (isValidMove m)
)
)
 (begin (if (not (hash-table-ref r "ok")
)
 (begin (ret6 #f)
)
 (quote nil)
)
 (let ((i empty)
)
 (begin (let ((j (cond ((string? (hash-table-ref r "idx")
)
 (inexact->exact (string->number (hash-table-ref r "idx")
)
)
)
 ((boolean? (hash-table-ref r "idx")
)
 (if (hash-table-ref r "idx")
 1 0)
)
 (else (inexact->exact (hash-table-ref r "idx")
)
)
)
)
)
 (begin (let ((tmp (list-ref board i)
)
)
 (begin (list-set! board i (list-ref board j)
)
 (list-set! board j tmp)
 (set! empty j)
 (set! moves (+ moves 1)
)
 (ret6 #t)
)
)
)
)
)
)
)
)
)
)
)
(define (shuffle n)
 (call/cc (lambda (ret7)
 (let ((i 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (or (< i n)
 (isSolved)
)
 (begin (if (doMove (randMove)
)
 (begin (set! i (+ i 1)
)
)
 (quote nil)
)
 (loop8)
)
 (quote nil)
)
)
)
)
 (loop8)
)
)
)
)
)
)
)
)
(define (printBoard)
 (call/cc (lambda (ret10)
 (let ((line "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (< i 16)
 (begin (let ((val (list-ref board i)
)
)
 (begin (if (= val 0)
 (begin (set! line (string-append line "  .")
)
)
 (begin (let ((s (number->string val)
)
)
 (begin (if (< val 10)
 (begin (set! line (string-append (string-append line "  ")
 s)
)
)
 (begin (set! line (string-append (string-append line " ")
 s)
)
)
)
)
)
)
)
 (if (= (modulo i 4)
 3)
 (begin (display (to-str line)
)
 (newline)
 (set! line "")
)
 (quote nil)
)
 (set! i (+ i 1)
)
)
)
 (loop11)
)
 (quote nil)
)
)
)
)
 (loop11)
)
)
)
)
)
)
)
)
)
)
(define (playOneMove)
 (call/cc (lambda (ret13)
 (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if #t (begin (display (to-str (string-append (string-append "Enter move #" (number->string (+ moves 1)
)
)
 " (U, D, L, R, or Q)
: ")
)
)
 (newline)
 (let ((s (_input)
)
)
 (begin (if (string=? s "")
 (begin (loop14)
)
 (quote nil)
)
 (let ((c (substring s 0 1)
)
)
 (begin (let ((m 0)
)
 (begin (if (or (string=? c "U")
 (string=? c "u")
)
 (begin (set! m 0)
)
 (if (or (string=? c "D")
 (string=? c "d")
)
 (begin (set! m 1)
)
 (if (or (string=? c "R")
 (string=? c "r")
)
 (begin (set! m 2)
)
 (if (or (string=? c "L")
 (string=? c "l")
)
 (begin (set! m 3)
)
 (if (or (string=? c "Q")
 (string=? c "q")
)
 (begin (display (to-str (string-append (string-append "Quiting after " (number->string moves)
)
 " moves.")
)
)
 (newline)
 (set! quit #t)
 (ret13 (quote nil)
)
)
 (begin (display (to-str (string-append (string-append (string-append "Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" "up, down, left, or right. You can also enter \"Q\" to quit.\n")
 "Upper or lowercase is accepted and only the first non-blank\n")
 "character is important (i.e. you may enter \"up\" if you like)
.")
)
)
 (newline)
 (loop14)
)
)
)
)
)
)
 (if (not (doMove m)
)
 (begin (display (to-str "That is not a valid move at the moment.")
)
 (newline)
 (loop14)
)
 (quote nil)
)
 (ret13 (quote nil)
)
)
)
)
)
)
)
 (loop14)
)
 (quote nil)
)
)
)
)
 (loop14)
)
)
)
)
)
)
(define (play)
 (call/cc (lambda (ret16)
 (begin (display (to-str "Starting board:")
)
 (newline)
 (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if (and (not quit)
 (eq? (isSolved)
 #f)
)
 (begin (display (to-str "")
)
 (newline)
 (printBoard)
 (playOneMove)
 (loop17)
)
 (quote nil)
)
)
)
)
 (loop17)
)
)
)
 (if (isSolved)
 (begin (display (to-str (string-append (string-append "You solved the puzzle in " (number->string moves)
)
 " moves.")
)
)
 (newline)
)
 (quote nil)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret19)
 (begin (shuffle 50)
 (play)
)
)
)
)
(main)
