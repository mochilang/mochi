;; Generated on 2025-07-23 13:04 +0700
(import (only (scheme base) call/cc list-ref list-set! list))
(import (scheme time))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (validComb a b c d e f g)
 (call/cc (lambda (ret1)
 (let ((square1 (+ a b)
)
)
 (begin (let ((square2 (+ (+ b c)
 d)
)
)
 (begin (let ((square3 (+ (+ d e)
 f)
)
)
 (begin (let ((square4 (+ f g)
)
)
 (begin (ret1 (and (and (= square1 square2)
 (= square2 square3)
)
 (= square3 square4)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (isUnique a b c d e f g)
 (call/cc (lambda (ret2)
 (let ((nums (list a b c d e f g)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break4)
 (letrec ((loop3 (lambda ()
 (if (< i (length nums)
)
 (begin (let ((j (+ i 1)
)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (< j (length nums)
)
 (begin (if (= (list-ref nums i)
 (list-ref nums j)
)
 (begin (ret2 #f)
)
 (quote nil)
)
 (set! j (+ j 1)
)
 (loop5)
)
 (quote nil)
)
)
)
)
 (loop5)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop3)
)
 (quote nil)
)
)
)
)
 (loop3)
)
)
)
 (ret2 #t)
)
)
)
)
)
)
)
(define (getCombs low high unique)
 (call/cc (lambda (ret7)
 (let ((valid (list)
)
)
 (begin (let ((count 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda (b)
 (if (< b (+ high 1)
)
 (begin (begin (call/cc (lambda (break11)
 (letrec ((loop10 (lambda (c)
 (if (< c (+ high 1)
)
 (begin (begin (call/cc (lambda (break13)
 (letrec ((loop12 (lambda (d)
 (if (< d (+ high 1)
)
 (begin (begin (let ((s (+ (+ b c)
 d)
)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda (e)
 (if (< e (+ high 1)
)
 (begin (begin (call/cc (lambda (break17)
 (letrec ((loop16 (lambda (f)
 (if (< f (+ high 1)
)
 (begin (begin (let ((a (- s b)
)
)
 (begin (let ((g (- s f)
)
)
 (begin (if (or (< a low)
 (> a high)
)
 (begin (loop16 (+ f 1)
)
)
 (quote nil)
)
 (if (or (< g low)
 (> g high)
)
 (begin (loop16 (+ f 1)
)
)
 (quote nil)
)
 (if (not (= (+ (+ d e)
 f)
 s)
)
 (begin (loop16 (+ f 1)
)
)
 (quote nil)
)
 (if (not (= (+ f g)
 s)
)
 (begin (loop16 (+ f 1)
)
)
 (quote nil)
)
 (if (or (not unique)
 (isUnique a b c d e f g)
)
 (begin (set! valid (append valid (list (list a b c d e f g)
)
)
)
 (set! count (+ count 1)
)
)
 (quote nil)
)
)
)
)
)
)
 (loop16 (+ f 1)
)
)
 (quote nil)
)
)
)
)
 (loop16 low)
)
)
)
)
 (loop14 (+ e 1)
)
)
 (quote nil)
)
)
)
)
 (loop14 low)
)
)
)
)
)
)
 (loop12 (+ d 1)
)
)
 (quote nil)
)
)
)
)
 (loop12 low)
)
)
)
)
 (loop10 (+ c 1)
)
)
 (quote nil)
)
)
)
)
 (loop10 low)
)
)
)
)
 (loop8 (+ b 1)
)
)
 (quote nil)
)
)
)
)
 (loop8 low)
)
)
)
 (ret7 (alist->hash-table (list (cons "count" count)
 (cons "list" valid)
)
)
)
)
)
)
)
)
)
)
(define r1 (getCombs 1 7 #t)
)
(display (to-str (string-append (number->string (hash-table-ref r1 "count")
)
 " unique solutions in 1 to 7")
)
)
(newline)
(display (to-str (hash-table-ref r1 "list")
)
)
(newline)
(define r2 (getCombs 3 9 #t)
)
(display (to-str (string-append (number->string (hash-table-ref r2 "count")
)
 " unique solutions in 3 to 9")
)
)
(newline)
(display (to-str (hash-table-ref r2 "list")
)
)
(newline)
(define r3 (getCombs 0 9 #f)
)
(display (to-str (string-append (number->string (hash-table-ref r3 "count")
)
 " non-unique solutions in 0 to 9")
)
)
(newline)
