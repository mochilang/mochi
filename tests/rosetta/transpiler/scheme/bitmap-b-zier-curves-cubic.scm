;; Generated on 2025-07-25 21:06 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define b3Seg 30)
(define (pixelFromRgb rgb)
 (call/cc (lambda (ret1)
 (let ((r (let ((v2 (modulo (quotient rgb 65536)
 256)
)
)
 (cond ((string? v2)
 (inexact->exact (string->number v2)
)
)
 ((boolean? v2)
 (if v2 1 0)
)
 (else (inexact->exact v2)
)
)
)
)
)
 (begin (let ((g (let ((v3 (modulo (quotient rgb 256)
 256)
)
)
 (cond ((string? v3)
 (inexact->exact (string->number v3)
)
)
 ((boolean? v3)
 (if v3 1 0)
)
 (else (inexact->exact v3)
)
)
)
)
)
 (begin (let ((b (let ((v4 (modulo rgb 256)
)
)
 (cond ((string? v4)
 (inexact->exact (string->number v4)
)
)
 ((boolean? v4)
 (if v4 1 0)
)
 (else (inexact->exact v4)
)
)
)
)
)
 (begin (ret1 (alist->hash-table (_list (cons "r" r)
 (cons "g" g)
 (cons "b" b)
)
)
)
)
)
)
)
)
)
)
)
)
(define (newBitmap cols rows)
 (call/cc (lambda (ret5)
 (let ((d (_list)
)
)
 (begin (let ((y 0)
)
 (begin (call/cc (lambda (break7)
 (letrec ((loop6 (lambda ()
 (if (< y rows)
 (begin (let ((row (_list)
)
)
 (begin (let ((x 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (< x cols)
 (begin (set! row (append row (_list (alist->hash-table (_list (cons "r" 0)
 (cons "g" 0)
 (cons "b" 0)
)
)
)
)
)
 (set! x (+ x 1)
)
 (loop8)
)
 (quote ()
)
)
)
)
)
 (loop8)
)
)
)
 (set! d (append d (_list row)
)
)
 (set! y (+ y 1)
)
)
)
)
)
 (loop6)
)
 (quote ()
)
)
)
)
)
 (loop6)
)
)
)
 (ret5 (alist->hash-table (_list (cons "cols" cols)
 (cons "rows" rows)
 (cons "data" d)
)
)
)
)
)
)
)
)
)
)
(define (setPx b x y p)
 (call/cc (lambda (ret10)
 (let ((cols (let ((v11 (hash-table-ref/default b "cols" (quote ()
)
)
)
)
 (cond ((string? v11)
 (inexact->exact (string->number v11)
)
)
 ((boolean? v11)
 (if v11 1 0)
)
 (else (inexact->exact v11)
)
)
)
)
)
 (begin (let ((rows (let ((v12 (hash-table-ref/default b "rows" (quote ()
)
)
)
)
 (cond ((string? v12)
 (inexact->exact (string->number v12)
)
)
 ((boolean? v12)
 (if v12 1 0)
)
 (else (inexact->exact v12)
)
)
)
)
)
 (begin (if (and (and (and (>= x 0)
 (< x cols)
)
 (>= y 0)
)
 (< y rows)
)
 (begin (hash-table-set! (hash-table-ref/default (hash-table-ref/default b "data" (quote ()
)
)
 y (quote ()
)
)
 x p)
)
 (quote ()
)
)
)
)
)
)
)
)
)
(define (fill b p)
 (call/cc (lambda (ret13)
 (let ((cols (let ((v14 (hash-table-ref/default b "cols" (quote ()
)
)
)
)
 (cond ((string? v14)
 (inexact->exact (string->number v14)
)
)
 ((boolean? v14)
 (if v14 1 0)
)
 (else (inexact->exact v14)
)
)
)
)
)
 (begin (let ((rows (let ((v15 (hash-table-ref/default b "rows" (quote ()
)
)
)
)
 (cond ((string? v15)
 (inexact->exact (string->number v15)
)
)
 ((boolean? v15)
 (if v15 1 0)
)
 (else (inexact->exact v15)
)
)
)
)
)
 (begin (let ((y 0)
)
 (begin (call/cc (lambda (break17)
 (letrec ((loop16 (lambda ()
 (if (< y rows)
 (begin (let ((x 0)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda ()
 (if (< x cols)
 (begin (hash-table-set! (hash-table-ref/default (hash-table-ref/default b "data" (quote ()
)
)
 y (quote ()
)
)
 x p)
 (set! x (+ x 1)
)
 (loop18)
)
 (quote ()
)
)
)
)
)
 (loop18)
)
)
)
 (set! y (+ y 1)
)
)
)
 (loop16)
)
 (quote ()
)
)
)
)
)
 (loop16)
)
)
)
)
)
)
)
)
)
)
)
)
(define (fillRgb b rgb)
 (call/cc (lambda (ret20)
 (fill b (pixelFromRgb rgb)
)
)
)
)
(define (line b x0 y0 x1 y1 p)
 (call/cc (lambda (ret21)
 (let ((dx (- x1 x0)
)
)
 (begin (if (< dx 0)
 (begin (set! dx (- dx)
)
)
 (quote ()
)
)
 (let ((dy (- y1 y0)
)
)
 (begin (if (< dy 0)
 (begin (set! dy (- dy)
)
)
 (quote ()
)
)
 (let ((sx (- 1)
)
)
 (begin (if (< x0 x1)
 (begin (set! sx 1)
)
 (quote ()
)
)
 (let ((sy (- 1)
)
)
 (begin (if (< y0 y1)
 (begin (set! sy 1)
)
 (quote ()
)
)
 (let ((err (- dx dy)
)
)
 (begin (call/cc (lambda (break23)
 (letrec ((loop22 (lambda ()
 (if #t (begin (setPx b x0 y0 p)
 (if (and (equal? x0 x1)
 (equal? y0 y1)
)
 (begin (break23 (quote ()
)
)
)
 (quote ()
)
)
 (let ((e2 (* 2 err)
)
)
 (begin (if (> e2 (- 0 dy)
)
 (begin (set! err (- err dy)
)
 (set! x0 (+ x0 sx)
)
)
 (quote ()
)
)
 (if (< e2 dx)
 (begin (set! err (+ err dx)
)
 (set! y0 (+ y0 sy)
)
)
 (quote ()
)
)
)
)
 (loop22)
)
 (quote ()
)
)
)
)
)
 (loop22)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (bezier3 b x1 y1 x2 y2 x3 y3 x4 y4 p)
 (call/cc (lambda (ret24)
 (let ((px (_list)
)
)
 (begin (let ((py (_list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (<= i b3Seg)
 (begin (set! px (append px (_list 0)
)
)
 (set! py (append py (_list 0)
)
)
 (set! i (+ i 1)
)
 (loop25)
)
 (quote ()
)
)
)
)
)
 (loop25)
)
)
)
 (let ((fx1 x1)
)
 (begin (let ((fy1 y1)
)
 (begin (let ((fx2 x2)
)
 (begin (let ((fy2 y2)
)
 (begin (let ((fx3 x3)
)
 (begin (let ((fy3 y3)
)
 (begin (let ((fx4 x4)
)
 (begin (let ((fy4 y4)
)
 (begin (set! i 0)
 (call/cc (lambda (break28)
 (letrec ((loop27 (lambda ()
 (if (<= i b3Seg)
 (begin (let ((d (/ i b3Seg)
)
)
 (begin (let ((a (- 1.0 d)
)
)
 (begin (let ((bcoef (* a a)
)
)
 (begin (let ((ccoef (* d d)
)
)
 (begin (let ((a2 (* a bcoef)
)
)
 (begin (let ((b2 (* (* 3.0 bcoef)
 d)
)
)
 (begin (let ((c2 (* (* 3.0 a)
 ccoef)
)
)
 (begin (let ((d2 (* ccoef d)
)
)
 (begin (list-set! px i (let ((v29 (+ (+ (+ (* a2 fx1)
 (* b2 fx2)
)
 (* c2 fx3)
)
 (* d2 fx4)
)
)
)
 (cond ((string? v29)
 (inexact->exact (string->number v29)
)
)
 ((boolean? v29)
 (if v29 1 0)
)
 (else (inexact->exact v29)
)
)
)
)
 (list-set! py i (let ((v30 (+ (+ (+ (* a2 fy1)
 (* b2 fy2)
)
 (* c2 fy3)
)
 (* d2 fy4)
)
)
)
 (cond ((string? v30)
 (inexact->exact (string->number v30)
)
)
 ((boolean? v30)
 (if v30 1 0)
)
 (else (inexact->exact v30)
)
)
)
)
 (set! i (+ i 1)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (loop27)
)
 (quote ()
)
)
)
)
)
 (loop27)
)
)
)
 (let ((x0 (list-ref px 0)
)
)
 (begin (let ((y0 (list-ref py 0)
)
)
 (begin (set! i 1)
 (call/cc (lambda (break32)
 (letrec ((loop31 (lambda ()
 (if (<= i b3Seg)
 (begin (let ((x (list-ref px i)
)
)
 (begin (let ((y (list-ref py i)
)
)
 (begin (line b x0 y0 x y p)
 (set! x0 x)
 (set! y0 y)
 (set! i (+ i 1)
)
)
)
)
)
 (loop31)
)
 (quote ()
)
)
)
)
)
 (loop31)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define b (newBitmap 400 300)
)
(fillRgb b 16773055)
(bezier3 b 20 200 700 50 (- 300)
 50 380 150 (pixelFromRgb 4165615)
)
