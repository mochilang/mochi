;; Generated on 2025-08-04 09:21 +0700
(import (scheme base))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(import (srfi 1))
(define _list list)
(import (chibi time))
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(define (_len x)
  (cond ((string? x) (string-length x))
        ((hash-table? x) (hash-table-size x))
        (else (length x))))
(let ((start36 (current-jiffy)) (jps39 (jiffies-per-second))) (begin (define (trim s) (call/cc (lambda (ret1) (let ((start 0)) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda () (if (and (< start (_len s)) (or (string=? (_substring s start (+ start 1)) " ") (string=? (_substring s start (+ start 1)) "\t"))) (begin (set! start (+ start 1)) (loop2)) (quote ()))))) (loop2)))) (let ((end (_len s))) (begin (call/cc (lambda (break5) (letrec ((loop4 (lambda () (if (and (> end start) (or (string=? (_substring s (- end 1) end) " ") (string=? (_substring s (- end 1) end) "\t"))) (begin (set! end (- end 1)) (loop4)) (quote ()))))) (loop4)))) (ret1 (_substring s start end))))))))) (define (split s sep) (call/cc (lambda (ret6) (let ((parts (_list))) (begin (let ((cur "")) (begin (let ((i 0)) (begin (call/cc (lambda (break8) (letrec ((loop7 (lambda () (if (< i (_len s)) (begin (if (and (and (> (_len sep) 0) (_le (+ i (_len sep)) (_len s))) (string=? (_substring s i (+ i (_len sep))) sep)) (begin (set! parts (append parts (_list cur))) (set! cur "") (set! i (+ i (_len sep)))) (begin (set! cur (string-append cur (_substring s i (+ i 1)))) (set! i (+ i 1)))) (loop7)) (quote ()))))) (loop7)))) (set! parts (append parts (_list cur))) (ret6 parts)))))))))) (define (splitWS s) (call/cc (lambda (ret9) (let ((out (_list))) (begin (let ((cur "")) (begin (let ((i 0)) (begin (call/cc (lambda (break11) (letrec ((loop10 (lambda () (if (< i (_len s)) (begin (let ((ch (_substring s i (+ i 1)))) (begin (if (or (string=? ch " ") (string=? ch "\t")) (begin (if (> (_len cur) 0) (begin (set! out (append out (_list cur))) (set! cur "")) (quote ()))) (begin (set! cur (string-append cur ch)))) (set! i (+ i 1)))) (loop10)) (quote ()))))) (loop10)))) (if (> (_len cur) 0) (begin (set! out (append out (_list cur)))) (quote ())) (ret9 out)))))))))) (define (indexOf s ch) (call/cc (lambda (ret12) (let ((i 0)) (begin (call/cc (lambda (break14) (letrec ((loop13 (lambda () (if (< i (_len s)) (begin (if (string=? (_substring s i (+ i 1)) ch) (begin (ret12 i)) (quote ())) (set! i (+ i 1)) (loop13)) (quote ()))))) (loop13)))) (ret12 (- 1))))))) (define (parseIntStr str) (call/cc (lambda (ret15) (let ((i 0)) (begin (let ((neg #f)) (begin (if (and (> (_len str) 0) (string=? (_substring str 0 1) "-")) (begin (set! neg #t) (set! i 1)) (quote ())) (let ((n 0)) (begin (let ((digits (alist->hash-table (_list (cons "0" 0) (cons "1" 1) (cons "2" 2) (cons "3" 3) (cons "4" 4) (cons "5" 5) (cons "6" 6) (cons "7" 7) (cons "8" 8) (cons "9" 9))))) (begin (call/cc (lambda (break17) (letrec ((loop16 (lambda () (if (< i (_len str)) (begin (set! n (_add (* n 10) (cond ((string? digits) (_substring digits (_substring str i (+ i 1)) (+ (_substring str i (+ i 1)) 1))) ((hash-table? digits) (hash-table-ref digits (_substring str i (+ i 1)))) (else (list-ref digits (_substring str i (+ i 1))))))) (set! i (+ i 1)) (loop16)) (quote ()))))) (loop16)))) (if neg (begin (set! n (- n))) (quote ())) (ret15 n)))))))))))) (define (parseAsm asm) (call/cc (lambda (ret18) (let ((lines (split asm "\n"))) (begin (let ((instrs (_list))) (begin (let ((labels (alist->hash-table (_list)))) (begin (let ((lineNum 0)) (begin (let ((i 0)) (begin (call/cc (lambda (break20) (letrec ((loop19 (lambda () (if (< i (_len lines)) (begin (let ((line (cond ((string? lines) (_substring lines i (+ i 1))) ((hash-table? lines) (hash-table-ref lines i)) (else (list-ref lines i))))) (begin (if (not (equal? (indexOf line ";") (- 1))) (begin (set! line (_substring line 0 (indexOf line ";")))) (quote ())) (set! line (trim line)) (let ((label "")) (begin (if (not (equal? (indexOf line ":") (- 1))) (begin (let ((idx (indexOf line ":"))) (begin (set! label (trim (_substring line 0 idx))) (set! line (trim (_substring line (_add idx 1) (_len line))))))) (quote ())) (let ((opcode "")) (begin (let ((arg "")) (begin (if (> (_len line) 0) (begin (let ((parts (splitWS line))) (begin (if (> (_len parts) 0) (begin (set! opcode (cond ((string? parts) (_substring parts 0 (+ 0 1))) ((hash-table? parts) (hash-table-ref parts 0)) (else (list-ref parts 0))))) (quote ())) (if (> (_len parts) 1) (begin (set! arg (cond ((string? parts) (_substring parts 1 (+ 1 1))) ((hash-table? parts) (hash-table-ref parts 1)) (else (list-ref parts 1))))) (begin (let ((ops (alist->hash-table (_list (cons "NOP" 0) (cons "LDA" 1) (cons "STA" 2) (cons "ADD" 3) (cons "SUB" 4) (cons "BRZ" 5) (cons "JMP" 6) (cons "STP" 7))))) (begin (if (not (cond ((string? ops) (if (string-contains ops opcode) #t #f)) ((hash-table? ops) (if (hash-table-exists? ops opcode) #t #f)) (else (if (member opcode ops) #t #f)))) (begin (set! arg opcode) (set! opcode "")) (quote ()))))))))) (quote ())) (if (not (string=? label "")) (begin (hash-table-set! labels label lineNum)) (quote ())) (set! instrs (append instrs (_list (alist->hash-table (_list (cons "Label" label) (cons "Opcode" opcode) (cons "Arg" arg)))))) (set! lineNum (+ lineNum 1)) (set! i (+ i 1)))))))))) (loop19)) (quote ()))))) (loop19)))) (ret18 (alist->hash-table (_list (cons "instructions" instrs) (cons "labels" labels))))))))))))))))) (define (compile p) (call/cc (lambda (ret21) (let ((instrs (hash-table-ref/default p "instructions" (quote ())))) (begin (let ((labels (hash-table-ref/default p "labels" (quote ())))) (begin (let ((bytecode (_list))) (begin (let ((i 0)) (begin (let ((opcodes (alist->hash-table (_list (cons "NOP" 0) (cons "LDA" 1) (cons "STA" 2) (cons "ADD" 3) (cons "SUB" 4) (cons "BRZ" 5) (cons "JMP" 6) (cons "STP" 7))))) (begin (call/cc (lambda (break23) (letrec ((loop22 (lambda () (if (< i (_len instrs)) (begin (let ((ins (list-ref instrs i))) (begin (let ((arg 0)) (begin (if (not (string=? (hash-table-ref ins "Arg") "")) (begin (if (cond ((string? labels) (if (string-contains labels (hash-table-ref ins "Arg")) #t #f)) ((hash-table? labels) (if (hash-table-exists? labels (hash-table-ref ins "Arg")) #t #f)) (else (if (member (hash-table-ref ins "Arg") labels) #t #f))) (begin (set! arg (hash-table-ref/default labels (hash-table-ref ins "Arg") (quote ())))) (begin (set! arg (parseIntStr (hash-table-ref ins "Arg")))))) (quote ())) (let ((code 0)) (begin (if (not (string=? (hash-table-ref ins "Opcode") "")) (begin (set! code (cond ((string? opcodes) (_substring opcodes (hash-table-ref ins "Opcode") (+ (hash-table-ref ins "Opcode") 1))) ((hash-table? opcodes) (hash-table-ref opcodes (hash-table-ref ins "Opcode"))) (else (list-ref opcodes (hash-table-ref ins "Opcode")))))) (quote ())) (set! bytecode (append bytecode (_list (_add (* code 32) arg)))) (set! i (+ i 1)))))))) (loop22)) (quote ()))))) (loop22)))) (call/cc (lambda (break25) (letrec ((loop24 (lambda () (if (< (_len bytecode) 32) (begin (set! bytecode (append bytecode (_list 0))) (loop24)) (quote ()))))) (loop24)))) (ret21 bytecode)))))))))))))) (define (floorMod a b) (call/cc (lambda (ret26) (let ((r (modulo a b))) (begin (if (< r 0) (begin (set! r (+ r b))) (quote ())) (ret26 r)))))) (define (run bytecode) (call/cc (lambda (ret27) (let ((acc 0)) (begin (let ((pc 0)) (begin (let ((mem (_list))) (begin (let ((i 0)) (begin (call/cc (lambda (break29) (letrec ((loop28 (lambda () (if (< i (_len bytecode)) (begin (set! mem (append mem (_list (list-ref bytecode i)))) (set! i (+ i 1)) (loop28)) (quote ()))))) (loop28)))) (call/cc (lambda (break31) (letrec ((loop30 (lambda () (if (< pc 32) (begin (let ((op (quotient (list-ref mem pc) 32))) (begin (let ((arg (modulo (list-ref mem pc) 32))) (begin (set! pc (+ pc 1)) (if (equal? op 0) (begin (loop30)) (if (equal? op 1) (begin (set! acc (list-ref mem arg))) (if (equal? op 2) (begin (list-set! mem arg acc)) (if (equal? op 3) (begin (set! acc (floorMod (+ acc (list-ref mem arg)) 256))) (if (equal? op 4) (begin (set! acc (floorMod (- acc (list-ref mem arg)) 256))) (if (equal? op 5) (begin (if (equal? acc 0) (begin (set! pc arg)) (quote ()))) (if (equal? op 6) (begin (set! pc arg)) (if (equal? op 7) (begin (break31 (quote ()))) (begin (break31 (quote ()))))))))))))))) (loop30)) (quote ()))))) (loop30)))) (ret27 acc)))))))))))) (define (execute asm) (call/cc (lambda (ret32) (let ((parsed (parseAsm asm))) (begin (let ((bc (compile parsed))) (begin (ret32 (run bc))))))))) (define (main) (call/cc (lambda (ret33) (let ((examples (_list "LDA   x\nADD   y       ; accumulator = x + y\nSTP\nx:            2\ny:            2" "loop:   LDA   prodt\n        ADD   x\n        STA   prodt\n        LDA   y\n        SUB   one\n        STA   y\n        BRZ   done\n        JMP   loop\ndone:   LDA   prodt   ; to display it\n        STP\nx:            8\ny:            7\nprodt:        0\none:          1" "loop:   LDA   n\n        STA   temp\n        ADD   m\n        STA   n\n        LDA   temp\n        STA   m\n        LDA   count\n        SUB   one\n        BRZ   done\n        STA   count\n        JMP   loop\ndone:   LDA   n       ; to display it\n        STP\nm:            1\nn:            1\ntemp:         0\ncount:        8       ; valid range: 1-11\none:          1" "start:  LDA   load\nADD   car     ; head of list\nSTA   ldcar\nADD   one\nSTA   ldcdr   ; next CONS cell\nldcar:  NOP\nSTA   value\nldcdr:  NOP\nBRZ   done    ; 0 stands for NIL\nSTA   car\nJMP   start\ndone:   LDA   value   ; CAR of last CONS\nSTP\nload:   LDA   0\nvalue:        0\ncar:          28\none:          1\n                        ; order of CONS cells\n                        ; in memory\n                        ; does not matter\n        6\n        0       ; 0 stands for NIL\n        2       ; (CADR ls)\n        26      ; (CDDR ls) -- etc.\n        5\n        20\n        3\n        30\n        1       ; value of (CAR ls)\n        22      ; points to (CDR ls)\n        4\n        24" "LDA  3\nSUB  4\nSTP  0\n         0\n         255" "LDA  3\nSUB  4\nSTP  0\n                0\n                1" "LDA  3\nADD  4\nSTP  0\n                1\n                255"))) (begin (let ((i 0)) (begin (call/cc (lambda (break35) (letrec ((loop34 (lambda () (if (< i (_len examples)) (begin (let ((res (execute (list-ref examples i)))) (begin (_display (to-str (to-str res))) (newline) (set! i (+ i 1)))) (loop34)) (quote ()))))) (loop34))))))))))) (main) (let ((end37 (current-jiffy))) (let ((dur38 (quotient (* (- end37 start36) 1000000) jps39))) (begin (_display (string-append "{\n  \"duration_us\": " (number->string dur38) ",\n  \"memory_bytes\": " (number->string (_mem)) ",\n  \"name\": \"main\"\n}")) (newline))))))
