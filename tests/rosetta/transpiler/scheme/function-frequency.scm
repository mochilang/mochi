;; Generated on 2025-08-04 16:05 +0700
(import (scheme base))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(import (srfi 1))
(define _list list)
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(define (_len x)
  (cond ((string? x) (string-length x))
        ((hash-table? x) (hash-table-size x))
        (else (length x))))
(define (join xs sep) (call/cc (lambda (ret1) (let ((res "")) (begin (let ((i 0)) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda () (if (< i (_len xs)) (begin (if (> i 0) (begin (set! res (string-append res sep))) (quote ())) (set! res (string-append res (list-ref xs i))) (set! i (+ i 1)) (loop2)) (quote ()))))) (loop2)))) (ret1 res))))))))
(define (sortPairs xs) (call/cc (lambda (ret4) (let ((arr xs)) (begin (let ((i 1)) (begin (call/cc (lambda (break6) (letrec ((loop5 (lambda () (if (< i (_len arr)) (begin (let ((j i)) (begin (call/cc (lambda (break10) (letrec ((loop9 (lambda () (if (and (> j 0) (< (let ((v7 (cond ((string? (list-ref arr (- j 1))) (_substring (list-ref arr (- j 1)) "count" (+ "count" 1))) ((hash-table? (list-ref arr (- j 1))) (hash-table-ref (list-ref arr (- j 1)) "count")) (else (list-ref (list-ref arr (- j 1)) "count"))))) (cond ((string? v7) (inexact->exact (floor (string->number v7)))) ((boolean? v7) (if v7 1 0)) (else (inexact->exact (floor v7))))) (let ((v8 (cond ((string? (list-ref arr j)) (_substring (list-ref arr j) "count" (+ "count" 1))) ((hash-table? (list-ref arr j)) (hash-table-ref (list-ref arr j) "count")) (else (list-ref (list-ref arr j) "count"))))) (cond ((string? v8) (inexact->exact (floor (string->number v8)))) ((boolean? v8) (if v8 1 0)) (else (inexact->exact (floor v8))))))) (begin (let ((tmp (list-ref arr (- j 1)))) (begin (list-set! arr (- j 1) (list-ref arr j)) (list-set! arr j tmp) (set! j (- j 1)))) (loop9)) (quote ()))))) (loop9)))) (set! i (+ i 1)))) (loop5)) (quote ()))))) (loop5)))) (ret4 arr))))))))
(define (isAlphaNumDot ch) (call/cc (lambda (ret11) (ret11 (or (or (or (or (and (string>=? ch "A") (string<=? ch "Z")) (and (string>=? ch "a") (string<=? ch "z"))) (and (string>=? ch "0") (string<=? ch "9"))) (string=? ch "_")) (string=? ch "."))))))
(define (main) (call/cc (lambda (ret12) (let ((srcLines (_list "package main" "" "import (" "    \"fmt\"" "    \"go/ast\"" "    \"go/parser\"" "    \"go/token\"" "    \"io/ioutil\"" "    \"os\"" "    \"sort\"" ")" "" "func main() {" "    if len(os.Args) != 2 {" "        fmt.Println(\"usage ff <go source filename>\")" "        return" "    }" "    src, err := ioutil.ReadFile(os.Args[1])" "    if err != nil {" "        fmt.Println(err)" "        return" "    }" "    fs := token.NewFileSet()" "    a, err := parser.ParseFile(fs, os.Args[1], src, 0)" "    if err != nil {" "        fmt.Println(err)" "        return" "    }" "    f := fs.File(a.Pos())" "    m := make(map[string]int)" "    ast.Inspect(a, func(n ast.Node) bool {" "        if ce, ok := n.(*ast.CallExpr); ok {" "            start := f.Offset(ce.Pos())" "            end := f.Offset(ce.Lparen)" "            m[string(src[start:end])]++" "        }" "        return true" "    })" "    cs := make(calls, 0, len(m))" "    for k, v := range m {" "        cs = append(cs, &call{k, v})" "    }" "    sort.Sort(cs)" "    for i, c := range cs {" "        fmt.Printf(\"%-20s %4d\\n\", c.expr, c.count)" "        if i == 9 {" "            break" "        }" "    }" "}" "" "type call struct {" "    expr  string" "    count int" "}" "type calls []*call" "" "func (c calls) Len() int           { return len(c) }" "func (c calls) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }" "func (c calls) Less(i, j int) bool { return c[i].count > c[j].count }"))) (begin (let ((src (join srcLines "\n"))) (begin (let ((freq (alist->hash-table (_list)))) (begin (let ((i 0)) (begin (let ((order (_list))) (begin (call/cc (lambda (break14) (letrec ((loop13 (lambda () (if (< i (_len src)) (begin (let ((ch (_substring src i (+ i 1)))) (begin (if (or (or (and (string>=? ch "A") (string<=? ch "Z")) (and (string>=? ch "a") (string<=? ch "z"))) (string=? ch "_")) (begin (let ((j (+ i 1))) (begin (call/cc (lambda (break16) (letrec ((loop15 (lambda () (if (and (< j (_len src)) (isAlphaNumDot (_substring src j (+ j 1)))) (begin (set! j (+ j 1)) (loop15)) (quote ()))))) (loop15)))) (let ((token (_substring src i j))) (begin (let ((k j)) (begin (call/cc (lambda (break18) (letrec ((loop17 (lambda () (if (< k (_len src)) (begin (let ((cc (_substring src k (+ k 1)))) (begin (if (or (or (or (string=? cc " ") (string=? cc "\t")) (string=? cc "\n")) (string=? cc "\r")) (begin (set! k (+ k 1))) (begin (break18 (quote ())))))) (loop17)) (quote ()))))) (loop17)))) (if (and (< k (_len src)) (string=? (_substring src k (+ k 1)) "(")) (begin (let ((p (- i 1))) (begin (call/cc (lambda (break20) (letrec ((loop19 (lambda () (if (and (>= p 0) (or (string=? (_substring src p (+ p 1)) " ") (string=? (_substring src p (+ p 1)) "\t"))) (begin (set! p (- p 1)) (loop19)) (quote ()))))) (loop19)))) (let ((skip #f)) (begin (if (>= p 3) (begin (let ((before (_substring src (- p 3) (+ p 1)))) (begin (if (string=? before "func") (begin (set! skip #t)) (quote ()))))) (quote ())) (if (not skip) (begin (if (cond ((string? freq) (if (string-contains freq token) #t #f)) ((hash-table? freq) (if (hash-table-exists? freq token) #t #f)) (else (if (member token freq) #t #f))) (begin (hash-table-set! freq token (+ (hash-table-ref/default freq token (quote ())) 1))) (begin (hash-table-set! freq token 1) (set! order (append order (_list token)))))) (quote ()))))))) (quote ())) (set! i j)))))))) (begin (set! i (+ i 1)))))) (loop13)) (quote ()))))) (loop13)))) (let ((pairs (_list))) (begin (call/cc (lambda (break22) (letrec ((loop21 (lambda (xs) (if (null? xs) (quote ()) (begin (let ((t (car xs))) (begin (set! pairs (append pairs (_list (alist->hash-table (_list (cons "expr" t) (cons "count" (hash-table-ref/default freq t (quote ())))))))))) (loop21 (cdr xs))))))) (loop21 order)))) (set! pairs (sortPairs pairs)) (let ((idx 0)) (begin (call/cc (lambda (break24) (letrec ((loop23 (lambda () (if (and (< idx (_len pairs)) (< idx 10)) (begin (let ((p (list-ref pairs idx))) (begin (_display (to-str (string-append (string-append (hash-table-ref/default p "expr" (quote ())) " ") (to-str (hash-table-ref/default p "count" (quote ())))))) (newline) (set! idx (+ idx 1)))) (loop23)) (quote ()))))) (loop23)))))))))))))))))))))
(main)
