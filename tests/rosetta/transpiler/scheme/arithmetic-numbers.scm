;; Generated on 2025-07-25 01:31 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (sieve limit)
 (call/cc (lambda (ret1)
 (let ((spf (list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (<= i limit)
 (begin (set! spf (append spf (list 0)
)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (set! i 2)
 (call/cc (lambda (break5)
 (letrec ((loop4 (lambda ()
 (if (<= i limit)
 (begin (if (equal? (list-ref spf i)
 0)
 (begin (list-set! spf i i)
 (if (<= (* i i)
 limit)
 (begin (let ((j (* i i)
)
)
 (begin (call/cc (lambda (break7)
 (letrec ((loop6 (lambda ()
 (if (<= j limit)
 (begin (if (equal? (list-ref spf j)
 0)
 (begin (list-set! spf j i)
)
 (quote nil)
)
 (set! j (+ j i)
)
 (loop6)
)
 (quote nil)
)
)
)
)
 (loop6)
)
)
)
)
)
)
 (quote nil)
)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop4)
)
 (quote nil)
)
)
)
)
 (loop4)
)
)
)
 (ret1 spf)
)
)
)
)
)
)
)
(define (primesFrom spf limit)
 (call/cc (lambda (ret8)
 (let ((primes (list)
)
)
 (begin (let ((i 3)
)
 (begin (call/cc (lambda (break10)
 (letrec ((loop9 (lambda ()
 (if (<= i limit)
 (begin (if (equal? (list-ref spf i)
 i)
 (begin (set! primes (append primes (list i)
)
)
)
 (quote nil)
)
 (set! i (+ i 1)
)
 (loop9)
)
 (quote nil)
)
)
)
)
 (loop9)
)
)
)
 (ret8 primes)
)
)
)
)
)
)
)
(define (pad3 n)
 (call/cc (lambda (ret11)
 (let ((s (to-str n)
)
)
 (begin (call/cc (lambda (break13)
 (letrec ((loop12 (lambda ()
 (if (< (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 3)
 (begin (set! s (string-append " " s)
)
 (loop12)
)
 (quote nil)
)
)
)
)
 (loop12)
)
)
)
 (ret11 s)
)
)
)
)
)
(define (commatize n)
 (call/cc (lambda (ret14)
 (let ((s (to-str n)
)
)
 (begin (let ((out "")
)
 (begin (let ((i (- (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 1)
)
)
 (begin (let ((c 0)
)
 (begin (call/cc (lambda (break16)
 (letrec ((loop15 (lambda ()
 (if (>= i 0)
 (begin (set! out (string-append (substring s i (+ i 1)
)
 out)
)
 (set! c (+ c 1)
)
 (if (and (equal? (modulo c 3)
 0)
 (> i 0)
)
 (begin (set! out (string-append "," out)
)
)
 (quote nil)
)
 (set! i (- i 1)
)
 (loop15)
)
 (quote nil)
)
)
)
)
 (loop15)
)
)
)
 (ret14 out)
)
)
)
)
)
)
)
)
)
)
)
(define (primeCount primes last spf)
 (call/cc (lambda (ret17)
 (let ((lo 0)
)
 (begin (let ((hi (cond ((string? primes)
 (string-length primes)
)
 ((hash-table? primes)
 (hash-table-size primes)
)
 (else (length primes)
)
)
)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda ()
 (if (< lo hi)
 (begin (let ((mid (let ((v20 (quotient (+ lo hi)
 2)
)
)
 (cond ((string? v20)
 (inexact->exact (string->number v20)
)
)
 ((boolean? v20)
 (if v20 1 0)
)
 (else (inexact->exact v20)
)
)
)
)
)
 (begin (if (< (list-ref primes mid)
 last)
 (begin (set! lo (+ mid 1)
)
)
 (begin (set! hi mid)
)
)
)
)
 (loop18)
)
 (quote nil)
)
)
)
)
 (loop18)
)
)
)
 (let ((count (+ lo 1)
)
)
 (begin (if (not (equal? (list-ref spf last)
 last)
)
 (begin (set! count (- count 1)
)
)
 (quote nil)
)
 (ret17 count)
)
)
)
)
)
)
)
)
)
(define (arithmeticNumbers limit spf)
 (call/cc (lambda (ret21)
 (let ((arr (list 1)
)
)
 (begin (let ((n 3)
)
 (begin (call/cc (lambda (break23)
 (letrec ((loop22 (lambda ()
 (if (< (cond ((string? arr)
 (string-length arr)
)
 ((hash-table? arr)
 (hash-table-size arr)
)
 (else (length arr)
)
)
 limit)
 (begin (if (equal? (list-ref spf n)
 n)
 (begin (set! arr (append arr (list n)
)
)
)
 (begin (let ((x n)
)
 (begin (let ((sigma 1)
)
 (begin (let ((tau 1)
)
 (begin (call/cc (lambda (break25)
 (letrec ((loop24 (lambda ()
 (if (> x 1)
 (begin (let ((p (list-ref spf x)
)
)
 (begin (if (equal? p 0)
 (begin (set! p x)
)
 (quote nil)
)
 (let ((cnt 0)
)
 (begin (let ((power p)
)
 (begin (let ((sum 1)
)
 (begin (call/cc (lambda (break27)
 (letrec ((loop26 (lambda ()
 (if (equal? (modulo x p)
 0)
 (begin (set! x (quotient x p)
)
 (set! cnt (+ cnt 1)
)
 (set! sum (+ sum power)
)
 (set! power (* power p)
)
 (loop26)
)
 (quote nil)
)
)
)
)
 (loop26)
)
)
)
 (set! sigma (* sigma sum)
)
 (set! tau (* tau (+ cnt 1)
)
)
)
)
)
)
)
)
)
)
 (loop24)
)
 (quote nil)
)
)
)
)
 (loop24)
)
)
)
 (if (equal? (modulo sigma tau)
 0)
 (begin (set! arr (append arr (list n)
)
)
)
 (quote nil)
)
)
)
)
)
)
)
)
)
 (set! n (+ n 1)
)
 (loop22)
)
 (quote nil)
)
)
)
)
 (loop22)
)
)
)
 (ret21 arr)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret28)
 (let ((limit 1228663)
)
 (begin (let ((spf (sieve limit)
)
)
 (begin (let ((primes (primesFrom spf limit)
)
)
 (begin (let ((arr (arithmeticNumbers 1000000 spf)
)
)
 (begin (display (to-str "The first 100 arithmetic numbers are:")
)
 (newline)
 (let ((i 0)
)
 (begin (call/cc (lambda (break30)
 (letrec ((loop29 (lambda ()
 (if (< i 100)
 (begin (let ((line "")
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break32)
 (letrec ((loop31 (lambda ()
 (if (< j 10)
 (begin (set! line (string-append line (pad3 (list-ref arr (+ i j)
)
)
)
)
 (if (< j 9)
 (begin (set! line (string-append line " ")
)
)
 (quote nil)
)
 (set! j (+ j 1)
)
 (loop31)
)
 (quote nil)
)
)
)
)
 (loop31)
)
)
)
 (display (to-str line)
)
 (newline)
 (set! i (+ i 10)
)
)
)
)
)
 (loop29)
)
 (quote nil)
)
)
)
)
 (loop29)
)
)
)
 (call/cc (lambda (break34)
 (letrec ((loop33 (lambda (xs)
 (if (null? xs)
 (quote nil)
 (begin (let ((x (car xs)
)
)
 (begin (let ((last (list-ref arr (- x 1)
)
)
)
 (begin (let ((lastc (commatize last)
)
)
 (begin (display (to-str (string-append (string-append (string-append "\nThe " (commatize x)
)
 "th arithmetic number is: ")
 lastc)
)
)
 (newline)
 (let ((pc (primeCount primes last spf)
)
)
 (begin (let ((comp (- (- x pc)
 1)
)
)
 (begin (display (to-str (string-append (string-append (string-append (string-append "The count of such numbers <= " lastc)
 " which are composite is ")
 (commatize comp)
)
 ".")
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
 (loop33 (cdr xs)
)
)
)
)
)
)
 (loop33 (list 1000 10000 100000 1000000)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
