;; Generated on 2025-07-28 10:03 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (exact (floor (* (current-second) 1000000000))))
)
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(let ((start20 (now)
)
)
 (begin (define INF 1000000000)
 (define graph (alist->hash-table (_list)
)
)
 (define (addEdge u v w)
 (call/cc (lambda (ret1)
 (begin (if (not (cond ((string? graph)
 (if (string-contains graph u)
 #t #f)
)
 ((hash-table? graph)
 (if (hash-table-exists? graph u)
 #t #f)
)
 (else (if (member u graph)
 #t #f)
)
)
)
 (begin (hash-table-set! graph u (alist->hash-table (_list)
)
)
)
 (quote ()
)
)
 (hash-table-set! (hash-table-ref/default graph u (quote ()
)
)
 v w)
 (if (not (cond ((string? graph)
 (if (string-contains graph v)
 #t #f)
)
 ((hash-table? graph)
 (if (hash-table-exists? graph v)
 #t #f)
)
 (else (if (member v graph)
 #t #f)
)
)
)
 (begin (hash-table-set! graph v (alist->hash-table (_list)
)
)
)
 (quote ()
)
)
)
)
)
)
 (define (removeAt xs idx)
 (call/cc (lambda (ret2)
 (let ((out (_list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break4)
 (letrec ((loop3 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((x (car xs)
)
)
 (begin (if (not (equal? i idx)
)
 (begin (set! out (append out (_list x)
)
)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
)
)
 (loop3 (cdr xs)
)
)
)
)
)
)
 (loop3 xs)
)
)
)
 (ret2 out)
)
)
)
)
)
)
)
 (define (dijkstra source)
 (call/cc (lambda (ret5)
 (let ((dist (alist->hash-table (_list)
)
)
)
 (begin (let ((prev (alist->hash-table (_list)
)
)
)
 (begin (call/cc (lambda (break7)
 (letrec ((loop6 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((v (car xs)
)
)
 (begin (hash-table-set! dist v INF)
 (hash-table-set! prev v "")
)
)
 (loop6 (cdr xs)
)
)
)
)
)
)
 (loop6 (hash-table-keys graph)
)
)
)
)
 (hash-table-set! dist source 0)
 (let ((q (_list)
)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((v (car xs)
)
)
 (begin (set! q (append q (_list v)
)
)
)
)
 (loop8 (cdr xs)
)
)
)
)
)
)
 (loop8 (hash-table-keys graph)
)
)
)
)
 (call/cc (lambda (break11)
 (letrec ((loop10 (lambda ()
 (if (> (cond ((string? q)
 (string-length q)
)
 ((hash-table? q)
 (hash-table-size q)
)
 (else (length q)
)
)
 0)
 (begin (let ((bestIdx 0)
)
 (begin (let ((u (list-ref q 0)
)
)
 (begin (let ((i 1)
)
 (begin (call/cc (lambda (break13)
 (letrec ((loop12 (lambda ()
 (if (< i (cond ((string? q)
 (string-length q)
)
 ((hash-table? q)
 (hash-table-size q)
)
 (else (length q)
)
)
)
 (begin (let ((v (list-ref q i)
)
)
 (begin (if (< (hash-table-ref/default dist v (quote ()
)
)
 (hash-table-ref/default dist u (quote ()
)
)
)
 (begin (set! u v)
 (set! bestIdx i)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
)
)
 (loop12)
)
 (quote ()
)
)
)
)
)
 (loop12)
)
)
)
 (set! q (removeAt q bestIdx)
)
 (call/cc (lambda (break15)
 (letrec ((loop14 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((v (car xs)
)
)
 (begin (let ((alt (+ (hash-table-ref/default dist u (quote ()
)
)
 (cond ((string? (hash-table-ref/default graph u (quote ()
)
)
)
 (substring (hash-table-ref/default graph u (quote ()
)
)
 v (+ v 1)
)
)
 ((hash-table? (hash-table-ref/default graph u (quote ()
)
)
)
 (hash-table-ref (hash-table-ref/default graph u (quote ()
)
)
 v)
)
 (else (list-ref (hash-table-ref/default graph u (quote ()
)
)
 v)
)
)
)
)
)
 (begin (if (< alt (hash-table-ref/default dist v (quote ()
)
)
)
 (begin (hash-table-set! dist v alt)
 (hash-table-set! prev v u)
)
 (quote ()
)
)
)
)
)
)
 (loop14 (cdr xs)
)
)
)
)
)
)
 (loop14 (hash-table-keys (hash-table-ref/default graph u (quote ()
)
)
)
)
)
)
)
)
)
)
)
)
)
 (loop10)
)
 (quote ()
)
)
)
)
)
 (loop10)
)
)
)
 (ret5 (alist->hash-table (_list (cons "dist" dist)
 (cons "prev" prev)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (path prev v)
 (call/cc (lambda (ret16)
 (let ((s v)
)
 (begin (let ((cur v)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if (not (string=? (hash-table-ref/default prev cur (quote ()
)
)
 "")
)
 (begin (set! cur (hash-table-ref/default prev cur (quote ()
)
)
)
 (set! s (string-append cur s)
)
 (loop17)
)
 (quote ()
)
)
)
)
)
 (loop17)
)
)
)
 (ret16 s)
)
)
)
)
)
)
)
 (define (main)
 (call/cc (lambda (ret19)
 (begin (addEdge "a" "b" 7)
 (addEdge "a" "c" 9)
 (addEdge "a" "f" 14)
 (addEdge "b" "c" 10)
 (addEdge "b" "d" 15)
 (addEdge "c" "d" 11)
 (addEdge "c" "f" 2)
 (addEdge "d" "e" 6)
 (addEdge "e" "f" 9)
 (let ((res (dijkstra "a")
)
)
 (begin (let ((dist (cond ((string? res)
 (substring res "dist" (+ "dist" 1)
)
)
 ((hash-table? res)
 (hash-table-ref res "dist")
)
 (else (list-ref res "dist")
)
)
)
)
 (begin (let ((prev (cond ((string? res)
 (substring res "prev" (+ "prev" 1)
)
)
 ((hash-table? res)
 (hash-table-ref res "prev")
)
 (else (list-ref res "prev")
)
)
)
)
 (begin (_display (to-str (string-append (string-append (string-append "Distance to e: " (to-str (hash-table-ref/default dist "e" (quote ()
)
)
)
)
 ", Path: ")
 (path prev "e")
)
)
)
 (newline)
 (_display (to-str (string-append (string-append (string-append "Distance to f: " (to-str (hash-table-ref/default dist "f" (quote ()
)
)
)
)
 ", Path: ")
 (path prev "f")
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
 (main)
 (let ((end21 (now)
)
)
 (let ((dur22 (quotient (- end21 start20)
 1000)
)
)
 (begin (_display (string-append "{\n  \"duration_us\": " (number->string dur22)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
