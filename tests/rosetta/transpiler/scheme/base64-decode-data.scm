;; Generated on 2025-07-25 21:06 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (indexOf s ch)
 (call/cc (lambda (ret1)
 (let ((i 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (if (string=? (substring s i (+ i 1)
)
 ch)
 (begin (ret1 i)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (ret1 (- 1)
)
)
)
)
)
)
(define (parseIntStr str)
 (call/cc (lambda (ret4)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
 0)
 (string=? (substring str 0 (+ 0 1)
)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote ()
)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (_list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (< i (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
)
 (begin (set! n (+ (* n 10)
 (cond ((string? digits)
 (substring digits (substring str i (+ i 1)
)
 (+ (substring str i (+ i 1)
)
 1)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop5)
)
 (quote ()
)
)
)
)
)
 (loop5)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote ()
)
)
 (ret4 n)
)
)
)
)
)
)
)
)
)
)
)
(define (ord ch)
 (call/cc (lambda (ret7)
 (let ((upper "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
)
 (begin (let ((lower "abcdefghijklmnopqrstuvwxyz")
)
 (begin (let ((idx (indexOf upper ch)
)
)
 (begin (if (>= idx 0)
 (begin (ret7 (+ 65 idx)
)
)
 (quote ()
)
)
 (set! idx (indexOf lower ch)
)
 (if (>= idx 0)
 (begin (ret7 (+ 97 idx)
)
)
 (quote ()
)
)
 (if (and (string>=? ch "0")
 (string<=? ch "9")
)
 (begin (ret7 (+ 48 (parseIntStr ch)
)
)
)
 (quote ()
)
)
 (if (string=? ch "+")
 (begin (ret7 43)
)
 (quote ()
)
)
 (if (string=? ch "/")
 (begin (ret7 47)
)
 (quote ()
)
)
 (if (string=? ch " ")
 (begin (ret7 32)
)
 (quote ()
)
)
 (if (string=? ch "=")
 (begin (ret7 61)
)
 (quote ()
)
)
 (ret7 0)
)
)
)
)
)
)
)
)
)
(define (chr n)
 (call/cc (lambda (ret8)
 (let ((upper "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
)
 (begin (let ((lower "abcdefghijklmnopqrstuvwxyz")
)
 (begin (if (and (>= n 65)
 (< n 91)
)
 (begin (ret8 (substring upper (- n 65)
 (- n 64)
)
)
)
 (quote ()
)
)
 (if (and (>= n 97)
 (< n 123)
)
 (begin (ret8 (substring lower (- n 97)
 (- n 96)
)
)
)
 (quote ()
)
)
 (if (and (>= n 48)
 (< n 58)
)
 (begin (let ((digits "0123456789")
)
 (begin (ret8 (substring digits (- n 48)
 (- n 47)
)
)
)
)
)
 (quote ()
)
)
 (if (equal? n 43)
 (begin (ret8 "+")
)
 (quote ()
)
)
 (if (equal? n 47)
 (begin (ret8 "/")
)
 (quote ()
)
)
 (if (equal? n 32)
 (begin (ret8 " ")
)
 (quote ()
)
)
 (if (equal? n 61)
 (begin (ret8 "=")
)
 (quote ()
)
)
 (ret8 "?")
)
)
)
)
)
)
)
(define (toBinary n bits)
 (call/cc (lambda (ret9)
 (let ((b "")
)
 (begin (let ((val n)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break11)
 (letrec ((loop10 (lambda ()
 (if (< i bits)
 (begin (set! b (string-append (to-str (modulo val 2)
)
 b)
)
 (set! val (let ((v12 (quotient val 2)
)
)
 (cond ((string? v12)
 (inexact->exact (string->number v12)
)
)
 ((boolean? v12)
 (if v12 1 0)
)
 (else (inexact->exact v12)
)
)
)
)
 (set! i (+ i 1)
)
 (loop10)
)
 (quote ()
)
)
)
)
)
 (loop10)
)
)
)
 (ret9 b)
)
)
)
)
)
)
)
)
)
(define (binToInt bits)
 (call/cc (lambda (ret13)
 (let ((n 0)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if (< i (cond ((string? bits)
 (string-length bits)
)
 ((hash-table? bits)
 (hash-table-size bits)
)
 (else (length bits)
)
)
)
 (begin (set! n (+ (* n 2)
 (parseIntStr (substring bits i (+ i 1)
)
)
)
)
 (set! i (+ i 1)
)
 (loop14)
)
 (quote ()
)
)
)
)
)
 (loop14)
)
)
)
 (ret13 n)
)
)
)
)
)
)
)
(define (base64Encode text)
 (call/cc (lambda (ret16)
 (let ((alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
)
 (begin (let ((bin "")
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((ch (car xs)
)
)
 (begin (set! bin (string-append bin (toBinary (ord ch)
 8)
)
)
)
)
 (loop17 (cdr xs)
)
)
)
)
)
)
 (loop17 text)
)
)
)
 (call/cc (lambda (break20)
 (letrec ((loop19 (lambda ()
 (if (not (equal? (modulo (cond ((string? bin)
 (string-length bin)
)
 ((hash-table? bin)
 (hash-table-size bin)
)
 (else (length bin)
)
)
 6)
 0)
)
 (begin (set! bin (string-append bin "0")
)
 (loop19)
)
 (quote ()
)
)
)
)
)
 (loop19)
)
)
)
 (let ((out "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break22)
 (letrec ((loop21 (lambda ()
 (if (< i (cond ((string? bin)
 (string-length bin)
)
 ((hash-table? bin)
 (hash-table-size bin)
)
 (else (length bin)
)
)
)
 (begin (let ((chunk (substring bin i (+ i 6)
)
)
)
 (begin (let ((val (binToInt chunk)
)
)
 (begin (set! out (string-append out (substring alphabet val (+ val 1)
)
)
)
 (set! i (+ i 6)
)
)
)
)
)
 (loop21)
)
 (quote ()
)
)
)
)
)
 (loop21)
)
)
)
 (let ((pad (modulo (- 3 (modulo (cond ((string? text)
 (string-length text)
)
 ((hash-table? text)
 (hash-table-size text)
)
 (else (length text)
)
)
 3)
)
 3)
)
)
 (begin (if (equal? pad 1)
 (begin (set! out (string-append (substring out 0 (- (cond ((string? out)
 (string-length out)
)
 ((hash-table? out)
 (hash-table-size out)
)
 (else (length out)
)
)
 1)
)
 "=")
)
)
 (quote ()
)
)
 (if (equal? pad 2)
 (begin (set! out (string-append (substring out 0 (- (cond ((string? out)
 (string-length out)
)
 ((hash-table? out)
 (hash-table-size out)
)
 (else (length out)
)
)
 2)
)
 "==")
)
)
 (quote ()
)
)
 (ret16 out)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (base64Decode enc)
 (call/cc (lambda (ret23)
 (let ((alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
)
 (begin (let ((bin "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break25)
 (letrec ((loop24 (lambda ()
 (if (< i (cond ((string? enc)
 (string-length enc)
)
 ((hash-table? enc)
 (hash-table-size enc)
)
 (else (length enc)
)
)
)
 (begin (let ((ch (substring enc i (+ i 1)
)
)
)
 (begin (if (string=? ch "=")
 (begin (break25 (quote ()
)
)
)
 (quote ()
)
)
 (let ((idx (indexOf alphabet ch)
)
)
 (begin (set! bin (string-append bin (toBinary idx 6)
)
)
 (set! i (+ i 1)
)
)
)
)
)
 (loop24)
)
 (quote ()
)
)
)
)
)
 (loop24)
)
)
)
 (let ((out "")
)
 (begin (set! i 0)
 (call/cc (lambda (break27)
 (letrec ((loop26 (lambda ()
 (if (<= (+ i 8)
 (cond ((string? bin)
 (string-length bin)
)
 ((hash-table? bin)
 (hash-table-size bin)
)
 (else (length bin)
)
)
)
 (begin (let ((chunk (substring bin i (+ i 8)
)
)
)
 (begin (let ((val (binToInt chunk)
)
)
 (begin (set! out (string-append out (chr val)
)
)
 (set! i (+ i 8)
)
)
)
)
)
 (loop26)
)
 (quote ()
)
)
)
)
)
 (loop26)
)
)
)
 (ret23 out)
)
)
)
)
)
)
)
)
)
)
)
(define msg "Rosetta Code Base64 decode data task")
(display (to-str (string-append "Original : " msg)
)
)
(newline)
(define enc (base64Encode msg)
)
(display (to-str (string-append "\nEncoded  : " enc)
)
)
(newline)
(define dec (base64Decode enc)
)
(display (to-str (string-append "\nDecoded  : " dec)
)
)
(newline)
