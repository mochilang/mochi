;; Generated on 2025-07-23 12:44 +0700
(import (only (scheme base) call/cc list-ref list-set! list))
(import (scheme time))
(import (srfi 69))
(import (chibi io))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (_input)
  (let ((l (read-line)))
    (if (eof-object? l) "" l)))
(define (parseIntStr str)
 (call/cc (lambda (ret1)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (string-length str)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote nil)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (string-length str)
)
 (begin (set! n (+ (* n 10)
 (cond ((string? digits)
 (string-ref digits (substring str i (+ i 1)
)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote nil)
)
 (ret1 n)
)
)
)
)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret4)
 (let ((total 0)
)
 (begin (let ((computer (= (modulo (current-jiffy)
 2)
 0)
)
)
 (begin (display (to-str "Enter q to quit at any time\n")
)
 (newline)
 (if computer (begin (display (to-str "The computer will choose first")
)
 (newline)
)
 (begin (display (to-str "You will choose first")
)
 (newline)
)
)
 (display (to-str "\n\nRunning total is now 0\n\n")
)
 (newline)
 (let ((round 1)
)
 (begin (let ((done #f)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (not done)
 (begin (display (to-str (string-append (string-append "ROUND " (number->string round)
)
 ":\n\n")
)
)
 (newline)
 (let ((i 0)
)
 (begin (call/cc (lambda (break8)
 (letrec ((loop7 (lambda ()
 (if (and (< i 2)
 (not done)
)
 (begin (if computer (begin (let ((choice 0)
)
 (begin (if (< total 18)
 (begin (set! choice (+ (modulo (current-jiffy)
 3)
 1)
)
)
 (begin (set! choice (- 21 total)
)
)
)
 (set! total (+ total choice)
)
 (display (to-str (string-append "The computer chooses " (number->string choice)
)
)
)
 (newline)
 (display (to-str (string-append "Running total is now " (number->string total)
)
)
)
 (newline)
 (if (= total 21)
 (begin (display (to-str "\nSo, commiserations, the computer has won!")
)
 (newline)
 (set! done #t)
)
 (quote nil)
)
)
)
)
 (begin (call/cc (lambda (break10)
 (letrec ((loop9 (lambda ()
 (if #t (begin (display (to-str "Your choice 1 to 3 : ")
)
 (newline)
 (let ((line (_input)
)
)
 (begin (if (or (string=? line "q")
 (string=? line "Q")
)
 (begin (display (to-str "OK, quitting the game")
)
 (newline)
 (set! done #t)
 (break10 (quote nil)
)
)
 (quote nil)
)
 (let ((num (parseIntStr line)
)
)
 (begin (if (or (< num 1)
 (> num 3)
)
 (begin (if (> (+ total num)
 21)
 (begin (display (to-str "Too big, try again")
)
 (newline)
)
 (begin (display (to-str "Out of range, try again")
)
 (newline)
)
)
 (loop9)
)
 (quote nil)
)
 (if (> (+ total num)
 21)
 (begin (display (to-str "Too big, try again")
)
 (newline)
 (loop9)
)
 (quote nil)
)
 (set! total (+ total num)
)
 (display (to-str (string-append "Running total is now " (number->string total)
)
)
)
 (newline)
 (break10 (quote nil)
)
)
)
)
)
 (loop9)
)
 (quote nil)
)
)
)
)
 (loop9)
)
)
)
 (if (= total 21)
 (begin (display (to-str "\nSo, congratulations, you've won!")
)
 (newline)
 (set! done #t)
)
 (quote nil)
)
)
)
 (display (to-str "\n")
)
 (newline)
 (set! computer (not computer)
)
 (set! i (+ i 1)
)
 (loop7)
)
 (quote nil)
)
)
)
)
 (loop7)
)
)
)
 (set! round (+ round 1)
)
)
)
 (loop5)
)
 (quote nil)
)
)
)
)
 (loop5)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
