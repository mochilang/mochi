;; Generated on 2025-07-25 08:58 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(import (chibi io))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (* (current-seconds) 1000000000)))(import (chibi time))
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_input)
  (let ((l (read-line)))
    (if (eof-object? l) "" l)))
(let ((start11 (now)
)
)
 (begin (define (parseIntStr str)
 (call/cc (lambda (ret1)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote nil)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< i (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
)
 (begin (set! n (+ (* n 10)
 (cond ((string? digits)
 (string-ref digits (substring str i (+ i 1)
)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop2)
)
 (quote nil)
)
)
)
)
 (loop2)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote nil)
)
 (ret1 n)
)
)
)
)
)
)
)
)
)
)
)
 (define (main)
 (call/cc (lambda (ret4)
 (let ((total 0)
)
 (begin (let ((computer (equal? (modulo (now)
 2)
 0)
)
)
 (begin (display (to-str "Enter q to quit at any time\n")
)
 (newline)
 (if computer (begin (display (to-str "The computer will choose first")
)
 (newline)
)
 (begin (display (to-str "You will choose first")
)
 (newline)
)
)
 (display (to-str "\n\nRunning total is now 0\n\n")
)
 (newline)
 (let ((round 1)
)
 (begin (let ((done #f)
)
 (begin (call/cc (lambda (break6)
 (letrec ((loop5 (lambda ()
 (if (not done)
 (begin (display (to-str (string-append (string-append "ROUND " (to-str round)
)
 ":\n\n")
)
)
 (newline)
 (let ((i 0)
)
 (begin (call/cc (lambda (break8)
 (letrec ((loop7 (lambda ()
 (if (and (< i 2)
 (not done)
)
 (begin (if computer (begin (let ((choice 0)
)
 (begin (if (< total 18)
 (begin (set! choice (+ (modulo (now)
 3)
 1)
)
)
 (begin (set! choice (- 21 total)
)
)
)
 (set! total (+ total choice)
)
 (display (to-str (string-append "The computer chooses " (to-str choice)
)
)
)
 (newline)
 (display (to-str (string-append "Running total is now " (to-str total)
)
)
)
 (newline)
 (if (equal? total 21)
 (begin (display (to-str "\nSo, commiserations, the computer has won!")
)
 (newline)
 (set! done #t)
)
 (quote nil)
)
)
)
)
 (begin (call/cc (lambda (break10)
 (letrec ((loop9 (lambda ()
 (if #t (begin (display (to-str "Your choice 1 to 3 : ")
)
 (newline)
 (let ((line (_input)
)
)
 (begin (if (or (string=? line "q")
 (string=? line "Q")
)
 (begin (display (to-str "OK, quitting the game")
)
 (newline)
 (set! done #t)
 (break10 (quote nil)
)
)
 (quote nil)
)
 (let ((num (parseIntStr line)
)
)
 (begin (if (or (< num 1)
 (> num 3)
)
 (begin (if (> (+ total num)
 21)
 (begin (display (to-str "Too big, try again")
)
 (newline)
)
 (begin (display (to-str "Out of range, try again")
)
 (newline)
)
)
 (loop9)
)
 (quote nil)
)
 (if (> (+ total num)
 21)
 (begin (display (to-str "Too big, try again")
)
 (newline)
 (loop9)
)
 (quote nil)
)
 (set! total (+ total num)
)
 (display (to-str (string-append "Running total is now " (to-str total)
)
)
)
 (newline)
 (break10 (quote nil)
)
)
)
)
)
 (loop9)
)
 (quote nil)
)
)
)
)
 (loop9)
)
)
)
 (if (equal? total 21)
 (begin (display (to-str "\nSo, congratulations, you've won!")
)
 (newline)
 (set! done #t)
)
 (quote nil)
)
)
)
 (display (to-str "\n")
)
 (newline)
 (set! computer (not computer)
)
 (set! i (+ i 1)
)
 (loop7)
)
 (quote nil)
)
)
)
)
 (loop7)
)
)
)
 (set! round (+ round 1)
)
)
)
 (loop5)
)
 (quote nil)
)
)
)
)
 (loop5)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (main)
 (let ((end12 (now)
)
)
 (let ((dur13 (quotient (- end12 start11)
 1000)
)
)
 (begin (display (string-append "{\n  \"duration_us\": " (number->string dur13)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
