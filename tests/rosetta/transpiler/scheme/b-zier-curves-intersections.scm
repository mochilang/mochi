;; Generated on 2025-07-25 21:06 +0700
(import (only (scheme base) call/cc when list-ref list-set! list))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (inexact->exact (* (current-second) 1000000000))))(import (chibi time))
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(let ((start19 (now)
)
)
 (begin (define (absf x)
 (call/cc (lambda (ret1)
 (begin (if (< x 0.0)
 (begin (ret1 (- x)
)
)
 (quote ()
)
)
 (ret1 x)
)
)
)
)
 (define (maxf a b)
 (call/cc (lambda (ret2)
 (begin (if (> a b)
 (begin (ret2 a)
)
 (quote ()
)
)
 (ret2 b)
)
)
)
)
 (define (minf a b)
 (call/cc (lambda (ret3)
 (begin (if (< a b)
 (begin (ret3 a)
)
 (quote ()
)
)
 (ret3 b)
)
)
)
)
 (define (max3 a b c)
 (call/cc (lambda (ret4)
 (let ((m a)
)
 (begin (if (> b m)
 (begin (set! m b)
)
 (quote ()
)
)
 (if (> c m)
 (begin (set! m c)
)
 (quote ()
)
)
 (ret4 m)
)
)
)
)
)
 (define (min3 a b c)
 (call/cc (lambda (ret5)
 (let ((m a)
)
 (begin (if (< b m)
 (begin (set! m b)
)
 (quote ()
)
)
 (if (< c m)
 (begin (set! m c)
)
 (quote ()
)
)
 (ret5 m)
)
)
)
)
)
 (define (subdivideQuadSpline q t)
 (call/cc (lambda (ret6)
 (let ((s (- 1.0 t)
)
)
 (begin (let ((u (alist->hash-table (list (cons "c0" (hash-table-ref q "c0")
)
 (cons "c1" 0.0)
 (cons "c2" 0.0)
)
)
)
)
 (begin (let ((v (alist->hash-table (list (cons "c0" 0.0)
 (cons "c1" 0.0)
 (cons "c2" (hash-table-ref q "c2")
)
)
)
)
)
 (begin (hash-table-set! u "c1" (+ (* s (hash-table-ref q "c0")
)
 (* t (hash-table-ref q "c1")
)
)
)
 (hash-table-set! v "c1" (+ (* s (hash-table-ref q "c1")
)
 (* t (hash-table-ref q "c2")
)
)
)
 (hash-table-set! u "c2" (+ (* s (hash-table-ref u "c1")
)
 (* t (hash-table-ref v "c1")
)
)
)
 (hash-table-set! v "c0" (hash-table-ref u "c2")
)
 (ret6 (list u v)
)
)
)
)
)
)
)
)
)
)
 (define (subdivideQuadCurve q t)
 (call/cc (lambda (ret7)
 (let ((xs (subdivideQuadSpline (hash-table-ref q "x")
 t)
)
)
 (begin (let ((ys (subdivideQuadSpline (hash-table-ref q "y")
 t)
)
)
 (begin (let ((u (alist->hash-table (list (cons "x" (cond ((string? xs)
 (substring xs 0 (+ 0 1)
)
)
 ((hash-table? xs)
 (hash-table-ref xs 0)
)
 (else (list-ref xs 0)
)
)
)
 (cons "y" (cond ((string? ys)
 (substring ys 0 (+ 0 1)
)
)
 ((hash-table? ys)
 (hash-table-ref ys 0)
)
 (else (list-ref ys 0)
)
)
)
)
)
)
)
 (begin (let ((v (alist->hash-table (list (cons "x" (cond ((string? xs)
 (substring xs 1 (+ 1 1)
)
)
 ((hash-table? xs)
 (hash-table-ref xs 1)
)
 (else (list-ref xs 1)
)
)
)
 (cons "y" (cond ((string? ys)
 (substring ys 1 (+ 1 1)
)
)
 ((hash-table? ys)
 (hash-table-ref ys 1)
)
 (else (list-ref ys 1)
)
)
)
)
)
)
)
 (begin (ret7 (list u v)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (rectsOverlap xa0 ya0 xa1 ya1 xb0 yb0 xb1 yb1)
 (call/cc (lambda (ret8)
 (ret8 (and (and (and (<= xb0 xa1)
 (<= xa0 xb1)
)
 (<= yb0 ya1)
)
 (<= ya0 yb1)
)
)
)
)
)
 (define (testIntersect p q tol)
 (call/cc (lambda (ret9)
 (let ((pxmin (min3 (hash-table-ref (hash-table-ref p "x")
 "c0")
 (hash-table-ref (hash-table-ref p "x")
 "c1")
 (hash-table-ref (hash-table-ref p "x")
 "c2")
)
)
)
 (begin (let ((pymin (min3 (hash-table-ref (hash-table-ref p "y")
 "c0")
 (hash-table-ref (hash-table-ref p "y")
 "c1")
 (hash-table-ref (hash-table-ref p "y")
 "c2")
)
)
)
 (begin (let ((pxmax (max3 (hash-table-ref (hash-table-ref p "x")
 "c0")
 (hash-table-ref (hash-table-ref p "x")
 "c1")
 (hash-table-ref (hash-table-ref p "x")
 "c2")
)
)
)
 (begin (let ((pymax (max3 (hash-table-ref (hash-table-ref p "y")
 "c0")
 (hash-table-ref (hash-table-ref p "y")
 "c1")
 (hash-table-ref (hash-table-ref p "y")
 "c2")
)
)
)
 (begin (let ((qxmin (min3 (hash-table-ref (hash-table-ref q "x")
 "c0")
 (hash-table-ref (hash-table-ref q "x")
 "c1")
 (hash-table-ref (hash-table-ref q "x")
 "c2")
)
)
)
 (begin (let ((qymin (min3 (hash-table-ref (hash-table-ref q "y")
 "c0")
 (hash-table-ref (hash-table-ref q "y")
 "c1")
 (hash-table-ref (hash-table-ref q "y")
 "c2")
)
)
)
 (begin (let ((qxmax (max3 (hash-table-ref (hash-table-ref q "x")
 "c0")
 (hash-table-ref (hash-table-ref q "x")
 "c1")
 (hash-table-ref (hash-table-ref q "x")
 "c2")
)
)
)
 (begin (let ((qymax (max3 (hash-table-ref (hash-table-ref q "y")
 "c0")
 (hash-table-ref (hash-table-ref q "y")
 "c1")
 (hash-table-ref (hash-table-ref q "y")
 "c2")
)
)
)
 (begin (let ((exclude #t)
)
 (begin (let ((accept #f)
)
 (begin (let ((inter (alist->hash-table (list (cons "x" 0.0)
 (cons "y" 0.0)
)
)
)
)
 (begin (if (rectsOverlap pxmin pymin pxmax pymax qxmin qymin qxmax qymax)
 (begin (set! exclude #f)
 (let ((xmin (maxf pxmin qxmin)
)
)
 (begin (let ((xmax (minf pxmax qxmax)
)
)
 (begin (if (<= (- xmax xmin)
 tol)
 (begin (let ((ymin (maxf pymin qymin)
)
)
 (begin (let ((ymax (minf pymax qymax)
)
)
 (begin (if (<= (- ymax ymin)
 tol)
 (begin (set! accept #t)
 (hash-table-set! inter "x" (* 0.5 (+ xmin xmax)
)
)
 (hash-table-set! inter "y" (* 0.5 (+ ymin ymax)
)
)
)
 (quote ()
)
)
)
)
)
)
)
 (quote ()
)
)
)
)
)
)
)
 (quote ()
)
)
 (ret9 (alist->hash-table (list (cons "exclude" exclude)
 (cons "accept" accept)
 (cons "intersect" inter)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (seemsToBeDuplicate pts xy spacing)
 (call/cc (lambda (ret10)
 (let ((i 0)
)
 (begin (call/cc (lambda (break12)
 (letrec ((loop11 (lambda ()
 (if (< i (cond ((string? pts)
 (string-length pts)
)
 ((hash-table? pts)
 (hash-table-size pts)
)
 (else (length pts)
)
)
)
 (begin (let ((pt (list-ref pts i)
)
)
 (begin (if (and (< (absf (- (hash-table-ref pt "x")
 (hash-table-ref xy "x")
)
)
 spacing)
 (< (absf (- (hash-table-ref pt "y")
 (hash-table-ref xy "y")
)
)
 spacing)
)
 (begin (ret10 #t)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
)
)
 (loop11)
)
 (quote ()
)
)
)
)
)
 (loop11)
)
)
)
 (ret10 #f)
)
)
)
)
)
 (define (findIntersects p q tol spacing)
 (call/cc (lambda (ret13)
 (let ((inters (list)
)
)
 (begin (let ((workload (list (alist->hash-table (list (cons "p" p)
 (cons "q" q)
)
)
)
)
)
 (begin (call/cc (lambda (break15)
 (letrec ((loop14 (lambda ()
 (if (> (cond ((string? workload)
 (string-length workload)
)
 ((hash-table? workload)
 (hash-table-size workload)
)
 (else (length workload)
)
)
 0)
 (begin (let ((idx (- (cond ((string? workload)
 (string-length workload)
)
 ((hash-table? workload)
 (hash-table-size workload)
)
 (else (length workload)
)
)
 1)
)
)
 (begin (let ((work (list-ref workload idx)
)
)
 (begin (set! workload (take (drop workload 0)
 (- idx 0)
)
)
 (let ((res (testIntersect (hash-table-ref/default work "p" (quote ()
)
)
 (hash-table-ref/default work "q" (quote ()
)
)
 tol)
)
)
 (begin (let ((excl (cond ((string? res)
 (substring res "exclude" (+ "exclude" 1)
)
)
 ((hash-table? res)
 (hash-table-ref res "exclude")
)
 (else (list-ref res "exclude")
)
)
)
)
 (begin (let ((acc (cond ((string? res)
 (substring res "accept" (+ "accept" 1)
)
)
 ((hash-table? res)
 (hash-table-ref res "accept")
)
 (else (list-ref res "accept")
)
)
)
)
 (begin (let ((inter (cond ((string? res)
 (substring res "intersect" (+ "intersect" 1)
)
)
 ((hash-table? res)
 (hash-table-ref res "intersect")
)
 (else (list-ref res "intersect")
)
)
)
)
 (begin (if acc (begin (if (not (seemsToBeDuplicate inters inter spacing)
)
 (begin (set! inters (append inters (list inter)
)
)
)
 (quote ()
)
)
)
 (if (not excl)
 (begin (let ((ps (subdivideQuadCurve (hash-table-ref/default work "p" (quote ()
)
)
 0.5)
)
)
 (begin (let ((qs (subdivideQuadCurve (hash-table-ref/default work "q" (quote ()
)
)
 0.5)
)
)
 (begin (let ((p0 (cond ((string? ps)
 (substring ps 0 (+ 0 1)
)
)
 ((hash-table? ps)
 (hash-table-ref ps 0)
)
 (else (list-ref ps 0)
)
)
)
)
 (begin (let ((p1 (cond ((string? ps)
 (substring ps 1 (+ 1 1)
)
)
 ((hash-table? ps)
 (hash-table-ref ps 1)
)
 (else (list-ref ps 1)
)
)
)
)
 (begin (let ((q0 (cond ((string? qs)
 (substring qs 0 (+ 0 1)
)
)
 ((hash-table? qs)
 (hash-table-ref qs 0)
)
 (else (list-ref qs 0)
)
)
)
)
 (begin (let ((q1 (cond ((string? qs)
 (substring qs 1 (+ 1 1)
)
)
 ((hash-table? qs)
 (hash-table-ref qs 1)
)
 (else (list-ref qs 1)
)
)
)
)
 (begin (set! workload (append workload (list (alist->hash-table (list (cons "p" p0)
 (cons "q" q0)
)
)
)
)
)
 (set! workload (append workload (list (alist->hash-table (list (cons "p" p0)
 (cons "q" q1)
)
)
)
)
)
 (set! workload (append workload (list (alist->hash-table (list (cons "p" p1)
 (cons "q" q0)
)
)
)
)
)
 (set! workload (append workload (list (alist->hash-table (list (cons "p" p1)
 (cons "q" q1)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (quote ()
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (loop14)
)
 (quote ()
)
)
)
)
)
 (loop14)
)
)
)
 (ret13 inters)
)
)
)
)
)
)
)
 (define (main)
 (call/cc (lambda (ret16)
 (let ((p (alist->hash-table (list (cons "x" (alist->hash-table (list (cons "c0" (- 1.0)
)
 (cons "c1" 0.0)
 (cons "c2" 1.0)
)
)
)
 (cons "y" (alist->hash-table (list (cons "c0" 0.0)
 (cons "c1" 10.0)
 (cons "c2" 0.0)
)
)
)
)
)
)
)
 (begin (let ((q (alist->hash-table (list (cons "x" (alist->hash-table (list (cons "c0" 2.0)
 (cons "c1" (- 8.0)
)
 (cons "c2" 2.0)
)
)
)
 (cons "y" (alist->hash-table (list (cons "c0" 1.0)
 (cons "c1" 2.0)
 (cons "c2" 3.0)
)
)
)
)
)
)
)
 (begin (let ((tol 1e-07)
)
 (begin (let ((spacing (* tol 10.0)
)
)
 (begin (let ((inters (findIntersects p q tol spacing)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if (< i (cond ((string? inters)
 (string-length inters)
)
 ((hash-table? inters)
 (hash-table-size inters)
)
 (else (length inters)
)
)
)
 (begin (let ((pt (cond ((string? inters)
 (substring inters i (+ i 1)
)
)
 ((hash-table? inters)
 (hash-table-ref inters i)
)
 (else (list-ref inters i)
)
)
)
)
 (begin (display (to-str (string-append (string-append (string-append (string-append "(" (to-str (hash-table-ref pt "x")
)
)
 ", ")
 (to-str (hash-table-ref pt "y")
)
)
 ")
")
)
)
 (newline)
 (set! i (+ i 1)
)
)
)
 (loop17)
)
 (quote ()
)
)
)
)
)
 (loop17)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (main)
 (let ((end20 (now)
)
)
 (let ((dur21 (quotient (- end20 start19)
 1000)
)
)
 (begin (display (string-append "{\n  \"duration_us\": " (number->string dur21)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
