;; Generated on 2025-08-03 10:04 +0700
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(import (srfi 1))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (exact (floor (* (current-second) 1000000000))))
)
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_substring s start end)
  (let* ((len (string-length s))
         (s0 (max 0 (min len start)))
         (e0 (max s0 (min len end))))
    (substring s s0 e0)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (slice seq start end)
  (let* ((len (if (string? seq) (string-length seq) (length seq)))
         (s (if (< start 0) (+ len start) start))
         (e (if (< end 0) (+ len end) end)))
    (set! s (max 0 (min len s)))
    (set! e (max 0 (min len e)))
    (when (< e s) (set! e s))
    (if (string? seq)
        (_substring seq s e)
        (take (drop seq s) (- e s)))))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((cur (string-contains r del)))
            (if cur
                (let ((idx (string-cursor->index r cur)))
                  (loop (_substring r (+ idx (string-length del)) (string-length r))
                        (cons (_substring r 0 idx) acc)))
                (reverse (cons r acc)))))))))
(let ((start16 (now))) (begin (define (fmt1 f) (call/cc (lambda (ret1) (let ((s (to-str f))) (begin (let ((idx (indexOf s "."))) (begin (if (< idx 0) (begin (set! s (string-append s ".0"))) (begin (let ((need (+ idx 2))) (begin (if (> (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))) need) (begin (set! s (_substring s 0 need))) (begin (call/cc (lambda (break3) (letrec ((loop2 (lambda () (if (< (cond ((string? s) (string-length s)) ((hash-table? s) (hash-table-size s)) (else (length s))) need) (begin (set! s (string-append s "0")) (loop2)) (quote ()))))) (loop2)))))))))) (ret1 s)))))))) (define (pointStr p) (call/cc (lambda (ret4) (ret4 (string-append (string-append (string-append (string-append "(" (fmt1 (hash-table-ref p "x"))) ", ") (fmt1 (hash-table-ref p "y"))) ")"))))) (define (triangleStr t) (call/cc (lambda (ret5) (ret5 (string-append (string-append (string-append (string-append (string-append "Triangle " (pointStr (hash-table-ref t "p1"))) ", ") (pointStr (hash-table-ref t "p2"))) ", ") (pointStr (hash-table-ref t "p3"))))))) (define (orient a b c) (call/cc (lambda (ret6) (ret6 (- (* (- (hash-table-ref b "x") (hash-table-ref a "x")) (- (hash-table-ref c "y") (hash-table-ref a "y"))) (* (- (hash-table-ref b "y") (hash-table-ref a "y")) (- (hash-table-ref c "x") (hash-table-ref a "x")))))))) (define (pointInTri p t onBoundary) (call/cc (lambda (ret7) (let ((d1 (orient p (hash-table-ref t "p1") (hash-table-ref t "p2")))) (begin (let ((d2 (orient p (hash-table-ref t "p2") (hash-table-ref t "p3")))) (begin (let ((d3 (orient p (hash-table-ref t "p3") (hash-table-ref t "p1")))) (begin (let ((hasNeg (or (or (_lt d1 0.0) (_lt d2 0.0)) (_lt d3 0.0)))) (begin (let ((hasPos (or (or (_gt d1 0.0) (_gt d2 0.0)) (_gt d3 0.0)))) (begin (if onBoundary (begin (ret7 (not (and hasNeg hasPos)))) (quote ())) (ret7 (and (and (and (not (and hasNeg hasPos)) (not (equal? d1 0.0))) (not (equal? d2 0.0))) (not (equal? d3 0.0))))))))))))))))) (define (edgeCheck a0 a1 bs onBoundary) (call/cc (lambda (ret8) (let ((d0 (orient a0 a1 (list-ref bs 0)))) (begin (let ((d1 (orient a0 a1 (list-ref bs 1)))) (begin (let ((d2 (orient a0 a1 (list-ref bs 2)))) (begin (if onBoundary (begin (ret8 (and (and (_le d0 0.0) (_le d1 0.0)) (_le d2 0.0)))) (quote ())) (ret8 (and (and (_lt d0 0.0) (_lt d1 0.0)) (_lt d2 0.0)))))))))))) (define (triTri2D t1 t2 onBoundary) (call/cc (lambda (ret9) (let ((a (_list (hash-table-ref t1 "p1") (hash-table-ref t1 "p2") (hash-table-ref t1 "p3")))) (begin (let ((b (_list (hash-table-ref t2 "p1") (hash-table-ref t2 "p2") (hash-table-ref t2 "p3")))) (begin (let ((i 0)) (begin (call/cc (lambda (break11) (letrec ((loop10 (lambda () (if (< i 3) (begin (let ((j (modulo (+ i 1) 3))) (begin (if (edgeCheck (list-ref a i) (list-ref a j) b onBoundary) (begin (ret9 #f)) (quote ())) (set! i (+ i 1)))) (loop10)) (quote ()))))) (loop10)))) (set! i 0) (call/cc (lambda (break13) (letrec ((loop12 (lambda () (if (< i 3) (begin (let ((j (modulo (+ i 1) 3))) (begin (if (edgeCheck (list-ref b i) (list-ref b j) a onBoundary) (begin (ret9 #f)) (quote ())) (set! i (+ i 1)))) (loop12)) (quote ()))))) (loop12)))) (ret9 #t)))))))))) (define (iff cond a b) (call/cc (lambda (ret14) (if cond (begin (ret14 a)) (begin (ret14 b)))))) (define (main) (call/cc (lambda (ret15) (let ((t1 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 0.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 5.0) (cons "y" 0.0)))) (cons "p3" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 5.0)))))))) (begin (let ((t2 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 0.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 5.0) (cons "y" 0.0)))) (cons "p3" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 6.0)))))))) (begin (_display (to-str (string-append (triangleStr t1) " and"))) (newline) (_display (to-str (triangleStr t2))) (newline) (let ((overlapping (triTri2D t1 t2 #t))) (begin (_display (to-str (iff overlapping "overlap" "do not overlap"))) (newline) (_display (to-str "")) (newline) (set! t1 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 0.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 5.0)))) (cons "p3" (alist->hash-table (_list (cons "x" 5.0) (cons "y" 0.0))))))) (set! t2 t1) (_display (to-str (string-append (triangleStr t1) " and"))) (newline) (_display (to-str (triangleStr t2))) (newline) (set! overlapping (triTri2D t1 t2 #t)) (_display (to-str (iff overlapping "overlap (reversed)" "do not overlap"))) (newline) (_display (to-str "")) (newline) (set! t1 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 0.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 5.0) (cons "y" 0.0)))) (cons "p3" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 5.0))))))) (set! t2 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" (- 10.0)) (cons "y" 0.0)))) (cons "p2" (alist->hash-table (_list (cons "x" (- 5.0)) (cons "y" 0.0)))) (cons "p3" (alist->hash-table (_list (cons "x" (- 1.0)) (cons "y" 6.0))))))) (_display (to-str (string-append (triangleStr t1) " and"))) (newline) (_display (to-str (triangleStr t2))) (newline) (set! overlapping (triTri2D t1 t2 #t)) (_display (to-str (iff overlapping "overlap" "do not overlap"))) (newline) (_display (to-str "")) (newline) (hash-table-set! t1 "p3" (alist->hash-table (_list (cons "x" 2.5) (cons "y" 5.0)))) (set! t2 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 4.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 2.5) (cons "y" (- 1.0))))) (cons "p3" (alist->hash-table (_list (cons "x" 5.0) (cons "y" 4.0))))))) (_display (to-str (string-append (triangleStr t1) " and"))) (newline) (_display (to-str (triangleStr t2))) (newline) (set! overlapping (triTri2D t1 t2 #t)) (_display (to-str (iff overlapping "overlap" "do not overlap"))) (newline) (_display (to-str "")) (newline) (set! t1 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 0.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 1.0) (cons "y" 1.0)))) (cons "p3" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 2.0))))))) (set! t2 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 2.0) (cons "y" 1.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 3.0) (cons "y" 0.0)))) (cons "p3" (alist->hash-table (_list (cons "x" 3.0) (cons "y" 2.0))))))) (_display (to-str (string-append (triangleStr t1) " and"))) (newline) (_display (to-str (triangleStr t2))) (newline) (set! overlapping (triTri2D t1 t2 #t)) (_display (to-str (iff overlapping "overlap" "do not overlap"))) (newline) (_display (to-str "")) (newline) (set! t2 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 2.0) (cons "y" 1.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 3.0) (cons "y" (- 2.0))))) (cons "p3" (alist->hash-table (_list (cons "x" 3.0) (cons "y" 4.0))))))) (_display (to-str (string-append (triangleStr t1) " and"))) (newline) (_display (to-str (triangleStr t2))) (newline) (set! overlapping (triTri2D t1 t2 #t)) (_display (to-str (iff overlapping "overlap" "do not overlap"))) (newline) (_display (to-str "")) (newline) (set! t1 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 0.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 1.0) (cons "y" 0.0)))) (cons "p3" (alist->hash-table (_list (cons "x" 0.0) (cons "y" 1.0))))))) (set! t2 (alist->hash-table (_list (cons "p1" (alist->hash-table (_list (cons "x" 1.0) (cons "y" 0.0)))) (cons "p2" (alist->hash-table (_list (cons "x" 2.0) (cons "y" 0.0)))) (cons "p3" (alist->hash-table (_list (cons "x" 1.0) (cons "y" 1.1))))))) (_display (to-str (string-append (triangleStr t1) " and"))) (newline) (_display (to-str (triangleStr t2))) (newline) (_display (to-str "which have only a single corner in contact, if boundary points collide")) (newline) (set! overlapping (triTri2D t1 t2 #t)) (_display (to-str (iff overlapping "overlap" "do not overlap"))) (newline) (_display (to-str "")) (newline) (_display (to-str (string-append (triangleStr t1) " and"))) (newline) (_display (to-str (triangleStr t2))) (newline) (_display (to-str "which have only a single corner in contact, if boundary points do not collide")) (newline) (set! overlapping (triTri2D t1 t2 #f)) (_display (to-str (iff overlapping "overlap" "do not overlap"))) (newline)))))))))) (main) (let ((end17 (now))) (let ((dur18 (quotient (- end17 start16) 1000))) (begin (_display (string-append "{\n  \"duration_us\": " (number->string dur18) ",\n  \"memory_bytes\": " (number->string (_mem)) ",\n  \"name\": \"main\"\n}")) (newline))))))
