;; Generated on 2025-07-25 21:06 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define PI 3.141592653589793)
(define TWO_PI 6.283185307179586)
(define (sinApprox x)
 (call/cc (lambda (ret1)
 (let ((term x)
)
 (begin (let ((sum x)
)
 (begin (let ((n 1)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (<= n 8)
 (begin (let ((denom (* (* 2 n)
 (+ (* 2 n)
 1)
)
)
)
 (begin (set! term (/ (* (* (- term)
 x)
 x)
 denom)
)
 (set! sum (+ sum term)
)
 (set! n (+ n 1)
)
)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (ret1 sum)
)
)
)
)
)
)
)
)
)
(define (floor x)
 (call/cc (lambda (ret4)
 (let ((i (let ((v5 x)
)
 (cond ((string? v5)
 (inexact->exact (string->number v5)
)
)
 ((boolean? v5)
 (if v5 1 0)
)
 (else (inexact->exact v5)
)
)
)
)
)
 (begin (if (> i x)
 (begin (set! i (- i 1)
)
)
 (quote ()
)
)
 (ret4 i)
)
)
)
)
)
(define (absFloat x)
 (call/cc (lambda (ret6)
 (begin (if (< x 0.0)
 (begin (ret6 (- x)
)
)
 (quote ()
)
)
 (ret6 x)
)
)
)
)
(define (absInt n)
 (call/cc (lambda (ret7)
 (begin (if (< n 0)
 (begin (ret7 (- n)
)
)
 (quote ()
)
)
 (ret7 n)
)
)
)
)
(define (parseIntStr str)
 (call/cc (lambda (ret8)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote ()
)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (_list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break10)
 (letrec ((loop9 (lambda ()
 (if (< i (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
)
 (begin (set! n (+ (* n 10)
 (cond ((string? digits)
 (substring digits (substring str i (+ i 1)
)
 (+ (substring str i (+ i 1)
)
 1)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop9)
)
 (quote ()
)
)
)
)
)
 (loop9)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote ()
)
)
 (ret8 n)
)
)
)
)
)
)
)
)
)
)
)
(define (parseDate s)
 (call/cc (lambda (ret11)
 (let ((y (parseIntStr (substring s 0 4)
)
)
)
 (begin (let ((m (parseIntStr (substring s 5 7)
)
)
)
 (begin (let ((d (parseIntStr (substring s 8 10)
)
)
)
 (begin (ret11 (_list y m d)
)
)
)
)
)
)
)
)
)
)
(define (leap y)
 (call/cc (lambda (ret12)
 (begin (if (equal? (modulo y 400)
 0)
 (begin (ret12 #t)
)
 (quote ()
)
)
 (if (equal? (modulo y 100)
 0)
 (begin (ret12 #f)
)
 (quote ()
)
)
 (ret12 (equal? (modulo y 4)
 0)
)
)
)
)
)
(define (daysInMonth y m)
 (call/cc (lambda (ret13)
 (let ((feb (if (leap y)
 29 28)
)
)
 (begin (let ((lengths (_list 31 feb 31 30 31 30 31 31 30 31 30 31)
)
)
 (begin (ret13 (list-ref lengths (- m 1)
)
)
)
)
)
)
)
)
)
(define (addDays y m d n)
 (call/cc (lambda (ret14)
 (let ((yy y)
)
 (begin (let ((mm m)
)
 (begin (let ((dd d)
)
 (begin (if (>= n 0)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break16)
 (letrec ((loop15 (lambda ()
 (if (< i n)
 (begin (set! dd (+ dd 1)
)
 (if (> dd (daysInMonth yy mm)
)
 (begin (set! dd 1)
 (set! mm (+ mm 1)
)
 (if (> mm 12)
 (begin (set! mm 1)
 (set! yy (+ yy 1)
)
)
 (quote ()
)
)
)
 (quote ()
)
)
 (set! i (+ i 1)
)
 (loop15)
)
 (quote ()
)
)
)
)
)
 (loop15)
)
)
)
)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break18)
 (letrec ((loop17 (lambda ()
 (if (> i n)
 (begin (set! dd (- dd 1)
)
 (if (< dd 1)
 (begin (set! mm (- mm 1)
)
 (if (< mm 1)
 (begin (set! mm 12)
 (set! yy (- yy 1)
)
)
 (quote ()
)
)
 (set! dd (daysInMonth yy mm)
)
)
 (quote ()
)
)
 (set! i (- i 1)
)
 (loop17)
)
 (quote ()
)
)
)
)
)
 (loop17)
)
)
)
)
)
)
)
 (ret14 (_list yy mm dd)
)
)
)
)
)
)
)
)
)
)
(define (pad2 n)
 (call/cc (lambda (ret19)
 (begin (if (< n 10)
 (begin (ret19 (string-append "0" (to-str n)
)
)
)
 (quote ()
)
)
 (ret19 (to-str n)
)
)
)
)
)
(define (dateString y m d)
 (call/cc (lambda (ret20)
 (ret20 (string-append (string-append (string-append (string-append (to-str y)
 "-")
 (pad2 m)
)
 "-")
 (pad2 d)
)
)
)
)
)
(define (day y m d)
 (call/cc (lambda (ret21)
 (let ((part1 (* 367 y)
)
)
 (begin (let ((part2 (let ((v23 (quotient (* 7 (let ((v22 (+ y (quotient (+ m 9)
 12)
)
)
)
 (cond ((string? v22)
 (inexact->exact (string->number v22)
)
)
 ((boolean? v22)
 (if v22 1 0)
)
 (else (inexact->exact v22)
)
)
)
)
 4)
)
)
 (cond ((string? v23)
 (inexact->exact (string->number v23)
)
)
 ((boolean? v23)
 (if v23 1 0)
)
 (else (inexact->exact v23)
)
)
)
)
)
 (begin (let ((part3 (let ((v24 (quotient (* 275 m)
 9)
)
)
 (cond ((string? v24)
 (inexact->exact (string->number v24)
)
)
 ((boolean? v24)
 (if v24 1 0)
)
 (else (inexact->exact v24)
)
)
)
)
)
 (begin (ret21 (- (+ (+ (- part1 part2)
 part3)
 d)
 730530)
)
)
)
)
)
)
)
)
)
)
(define (biorhythms birth target)
 (call/cc (lambda (ret25)
 (let ((bparts (parseDate birth)
)
)
 (begin (let ((by (cond ((string? bparts)
 (substring bparts 0 (+ 0 1)
)
)
 ((hash-table? bparts)
 (hash-table-ref bparts 0)
)
 (else (list-ref bparts 0)
)
)
)
)
 (begin (let ((bm (cond ((string? bparts)
 (substring bparts 1 (+ 1 1)
)
)
 ((hash-table? bparts)
 (hash-table-ref bparts 1)
)
 (else (list-ref bparts 1)
)
)
)
)
 (begin (let ((bd (cond ((string? bparts)
 (substring bparts 2 (+ 2 1)
)
)
 ((hash-table? bparts)
 (hash-table-ref bparts 2)
)
 (else (list-ref bparts 2)
)
)
)
)
 (begin (let ((tparts (parseDate target)
)
)
 (begin (let ((ty (cond ((string? tparts)
 (substring tparts 0 (+ 0 1)
)
)
 ((hash-table? tparts)
 (hash-table-ref tparts 0)
)
 (else (list-ref tparts 0)
)
)
)
)
 (begin (let ((tm (cond ((string? tparts)
 (substring tparts 1 (+ 1 1)
)
)
 ((hash-table? tparts)
 (hash-table-ref tparts 1)
)
 (else (list-ref tparts 1)
)
)
)
)
 (begin (let ((td (cond ((string? tparts)
 (substring tparts 2 (+ 2 1)
)
)
 ((hash-table? tparts)
 (hash-table-ref tparts 2)
)
 (else (list-ref tparts 2)
)
)
)
)
 (begin (let ((diff (absInt (- (day ty tm td)
 (day by bm bd)
)
)
)
)
 (begin (display (to-str (string-append (string-append (string-append "Born " birth)
 ", Target ")
 target)
)
)
 (newline)
 (display (to-str (string-append "Day " (to-str diff)
)
)
)
 (newline)
 (let ((cycles (_list "Physical day " "Emotional day" "Mental day   ")
)
)
 (begin (let ((lengths (_list 23 28 33)
)
)
 (begin (let ((quadrants (_list (_list "up and rising" "peak")
 (_list "up but falling" "transition")
 (_list "down and falling" "valley")
 (_list "down but rising" "transition")
)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break27)
 (letrec ((loop26 (lambda ()
 (if (< i 3)
 (begin (let ((length (list-ref lengths i)
)
)
 (begin (let ((cycle (list-ref cycles i)
)
)
 (begin (let ((position (modulo diff length)
)
)
 (begin (let ((quadrant (quotient (* position 4)
 length)
)
)
 (begin (let ((percent (sinApprox (/ (* (* 2.0 PI)
 position)
 length)
)
)
)
 (begin (set! percent (/ (floor (* percent 1000.0)
)
 10.0)
)
 (let ((description "")
)
 (begin (if (> percent 95.0)
 (begin (set! description " peak")
)
 (if (< percent (- 95.0)
)
 (begin (set! description " valley")
)
 (if (< (absFloat percent)
 5.0)
 (begin (set! description " critical transition")
)
 (begin (let ((daysToAdd (- (quotient (* (+ quadrant 1)
 length)
 4)
 position)
)
)
 (begin (let ((res (addDays ty tm td daysToAdd)
)
)
 (begin (let ((ny (cond ((string? res)
 (substring res 0 (+ 0 1)
)
)
 ((hash-table? res)
 (hash-table-ref res 0)
)
 (else (list-ref res 0)
)
)
)
)
 (begin (let ((nm (cond ((string? res)
 (substring res 1 (+ 1 1)
)
)
 ((hash-table? res)
 (hash-table-ref res 1)
)
 (else (list-ref res 1)
)
)
)
)
 (begin (let ((nd (cond ((string? res)
 (substring res 2 (+ 2 1)
)
)
 ((hash-table? res)
 (hash-table-ref res 2)
)
 (else (list-ref res 2)
)
)
)
)
 (begin (let ((transition (dateString ny nm nd)
)
)
 (begin (let ((trend (cond ((string? (list-ref quadrants quadrant)
)
 (substring (list-ref quadrants quadrant)
 0 (+ 0 1)
)
)
 ((hash-table? (list-ref quadrants quadrant)
)
 (hash-table-ref (list-ref quadrants quadrant)
 0)
)
 (else (list-ref (list-ref quadrants quadrant)
 0)
)
)
)
)
 (begin (let ((next (cond ((string? (list-ref quadrants quadrant)
)
 (substring (list-ref quadrants quadrant)
 1 (+ 1 1)
)
)
 ((hash-table? (list-ref quadrants quadrant)
)
 (hash-table-ref (list-ref quadrants quadrant)
 1)
)
 (else (list-ref (list-ref quadrants quadrant)
 1)
)
)
)
)
 (begin (let ((pct (to-str percent)
)
)
 (begin (if (not (contains pct ".")
)
 (begin (set! pct (string-append pct ".0")
)
)
 (quote ()
)
)
 (set! description (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append " " pct)
 "% (")
 trend)
 ", next ")
 next)
 " ")
 transition)
 ")
")
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (let ((posStr (to-str position)
)
)
 (begin (if (< position 10)
 (begin (set! posStr (string-append " " posStr)
)
)
 (quote ()
)
)
 (display (to-str (string-append (string-append (string-append cycle posStr)
 " : ")
 description)
)
)
 (newline)
 (set! i (+ i 1)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (loop26)
)
 (quote ()
)
)
)
)
)
 (loop26)
)
)
)
 (display (to-str "")
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret28)
 (let ((pairs (_list (_list "1943-03-09" "1972-07-11")
 (_list "1809-01-12" "1863-11-19")
 (_list "1809-02-12" "1863-11-19")
)
)
)
 (begin (let ((idx 0)
)
 (begin (call/cc (lambda (break30)
 (letrec ((loop29 (lambda ()
 (if (< idx (cond ((string? pairs)
 (string-length pairs)
)
 ((hash-table? pairs)
 (hash-table-size pairs)
)
 (else (length pairs)
)
)
)
 (begin (let ((p (list-ref pairs idx)
)
)
 (begin (biorhythms (list-ref p 0)
 (list-ref p 1)
)
 (set! idx (+ idx 1)
)
)
)
 (loop29)
)
 (quote ()
)
)
)
)
)
 (loop29)
)
)
)
)
)
)
)
)
)
)
(main)
