;; Generated on 2025-07-28 11:25 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (scheme write))
(import (srfi 69))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (_add a b)
  (cond ((and (number? a) (number? b)) (+ a b))
        ((string? a) (string-append a (to-str b)))
        ((string? b) (string-append (to-str a) b))
        ((and (list? a) (list? b)) (append a b))
        (else (+ a b))))
(define (indexOf s sub) (let ((cur (string-contains s sub)))   (if cur (string-cursor->index s cur) -1)))
(define (_display . args) (apply display args))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(define (_repeat s n)
  (let loop ((i 0) (out ""))
    (if (< i n)
        (loop (+ i 1) (string-append out s))
        out)))
(define (_parseIntStr s base)
  (let* ((b (if (number? base) base 10))
         (n (string->number (if (list? s) (list->string s) s) b)))
    (if n (inexact->exact (truncate n)) 0)))
(define (_split s sep)
  (let* ((str (if (string? s) s (list->string s)))
         (del (cond ((char? sep) sep)
                     ((string? sep) (if (= (string-length sep) 1)
                                       (string-ref sep 0)
                                       sep))
                     (else sep))))
    (cond
     ((and (string? del) (string=? del ""))
      (map string (string->list str)))
     ((char? del)
      (string-split str del))
     (else
        (let loop ((r str) (acc '()))
          (let ((idx (string-contains r del)))
            (if idx
                (loop (substring r (+ idx (string-length del)))
                      (cons (substring r 0 idx) acc))
                (reverse (cons r acc)))))))))
(define (modPow base exp m)
 (call/cc (lambda (ret1)
 (let ((result (modulo 1 m)
)
)
 (begin (let ((b (modulo base m)
)
)
 (begin (let ((e exp)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (> e 0)
 (begin (if (equal? (modulo e 2)
 1)
 (begin (set! result (modulo (* result b)
 m)
)
)
 (quote ()
)
)
 (set! b (modulo (* b b)
 m)
)
 (set! e (let ((v4 (quotient e 2)
)
)
 (cond ((string? v4)
 (inexact->exact (floor (string->number v4)
)
)
)
 ((boolean? v4)
 (if v4 1 0)
)
 (else (inexact->exact (floor v4)
)
)
)
)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (ret1 result)
)
)
)
)
)
)
)
)
)
(define (isPrime n)
 (call/cc (lambda (ret5)
 (begin (if (< n 2)
 (begin (ret5 #f)
)
 (quote ()
)
)
 (call/cc (lambda (break7)
 (letrec ((loop6 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((p (car xs)
)
)
 (begin (if (equal? (fmod n p)
 0)
 (begin (ret5 (equal? n p)
)
)
 (quote ()
)
)
)
)
 (loop6 (cdr xs)
)
)
)
)
)
)
 (loop6 (_list 2 3 5 7 11 13 17 19 23 29)
)
)
)
)
 (let ((d (- n 1)
)
)
 (begin (let ((s 0)
)
 (begin (call/cc (lambda (break9)
 (letrec ((loop8 (lambda ()
 (if (equal? (modulo d 2)
 0)
 (begin (set! d (quotient d 2)
)
 (set! s (+ s 1)
)
 (loop8)
)
 (quote ()
)
)
)
)
)
 (loop8)
)
)
)
 (call/cc (lambda (break11)
 (letrec ((loop10 (lambda (xs)
 (if (null? xs)
 (quote ()
)
 (begin (let ((a (car xs)
)
)
 (begin (if (equal? (fmod a n)
 0)
 (begin (ret5 #t)
)
 (quote ()
)
)
 (let ((x (modPow a d n)
)
)
 (begin (if (or (equal? x 1)
 (equal? x (- n 1)
)
)
 (begin (loop10 (cdr xs)
)
)
 (quote ()
)
)
 (let ((r 1)
)
 (begin (let ((passed #f)
)
 (begin (call/cc (lambda (break13)
 (letrec ((loop12 (lambda ()
 (if (< r s)
 (begin (set! x (fmod (* x x)
 n)
)
 (if (equal? x (- n 1)
)
 (begin (set! passed #t)
 (break13 (quote ()
)
)
)
 (quote ()
)
)
 (set! r (+ r 1)
)
 (loop12)
)
 (quote ()
)
)
)
)
)
 (loop12)
)
)
)
 (if (not passed)
 (begin (ret5 #f)
)
 (quote ()
)
)
)
)
)
)
)
)
)
)
 (loop10 (cdr xs)
)
)
)
)
)
)
 (loop10 (_list 2 325 9375 28178 450775 9780504 1795265022)
)
)
)
)
 (ret5 #t)
)
)
)
)
)
)
)
)
(define (commatize n)
 (call/cc (lambda (ret14)
 (let ((s (to-str n)
)
)
 (begin (let ((i (- (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 3)
)
)
 (begin (call/cc (lambda (break16)
 (letrec ((loop15 (lambda ()
 (if (> i 0)
 (begin (set! s (string-append (string-append (substring s 0 i)
 ",")
 (substring s i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
)
)
 (set! i (- i 3)
)
 (loop15)
)
 (quote ()
)
)
)
)
)
 (loop15)
)
)
)
 (ret14 s)
)
)
)
)
)
)
)
(define (pad s width)
 (call/cc (lambda (ret17)
 (let ((out s)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda ()
 (if (< (cond ((string? out)
 (string-length out)
)
 ((hash-table? out)
 (hash-table-size out)
)
 (else (length out)
)
)
 width)
 (begin (set! out (string-append " " out)
)
 (loop18)
)
 (quote ()
)
)
)
)
)
 (loop18)
)
)
)
 (ret17 out)
)
)
)
)
)
(define (join xs sep)
 (call/cc (lambda (ret20)
 (let ((res "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break22)
 (letrec ((loop21 (lambda ()
 (if (< i (cond ((string? xs)
 (string-length xs)
)
 ((hash-table? xs)
 (hash-table-size xs)
)
 (else (length xs)
)
)
)
 (begin (if (> i 0)
 (begin (set! res (string-append res sep)
)
)
 (quote ()
)
)
 (set! res (string-append res (list-ref xs i)
)
)
 (set! i (+ i 1)
)
 (loop21)
)
 (quote ()
)
)
)
)
)
 (loop21)
)
)
)
 (ret20 res)
)
)
)
)
)
)
)
(define (formatRow row)
 (call/cc (lambda (ret23)
 (let ((padded (_list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break25)
 (letrec ((loop24 (lambda ()
 (if (< i (cond ((string? row)
 (string-length row)
)
 ((hash-table? row)
 (hash-table-size row)
)
 (else (length row)
)
)
)
 (begin (set! padded (append padded (_list (pad (list-ref row i)
 9)
)
)
)
 (set! i (+ i 1)
)
 (loop24)
)
 (quote ()
)
)
)
)
)
 (loop24)
)
)
)
 (ret23 (string-append (string-append "[" (join padded " ")
)
 "]")
)
)
)
)
)
)
)
)
(define (main)
 (call/cc (lambda (ret26)
 (let ((cubans (_list)
)
)
 (begin (let ((cube1 1)
)
 (begin (let ((count 0)
)
 (begin (let ((cube100k 0)
)
 (begin (let ((i 1)
)
 (begin (call/cc (lambda (break28)
 (letrec ((loop27 (lambda ()
 (if #t (begin (let ((j (+ i 1)
)
)
 (begin (let ((cube2 (* (* j j)
 j)
)
)
 (begin (let ((diff (- cube2 cube1)
)
)
 (begin (if (isPrime diff)
 (begin (if (< count 200)
 (begin (set! cubans (append cubans (_list (commatize diff)
)
)
)
)
 (quote ()
)
)
 (set! count (+ count 1)
)
 (if (equal? count 100000)
 (begin (set! cube100k diff)
 (break28 (quote ()
)
)
)
 (quote ()
)
)
)
 (quote ()
)
)
 (set! cube1 cube2)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop27)
)
 (quote ()
)
)
)
)
)
 (loop27)
)
)
)
 (_display (to-str "The first 200 cuban primes are:-")
)
 (newline)
 (let ((row 0)
)
 (begin (call/cc (lambda (break30)
 (letrec ((loop29 (lambda ()
 (if (< row 20)
 (begin (let ((slice (_list)
)
)
 (begin (let ((k 0)
)
 (begin (call/cc (lambda (break32)
 (letrec ((loop31 (lambda ()
 (if (< k 10)
 (begin (set! slice (append slice (_list (list-ref cubans (_add (* row 10)
 k)
)
)
)
)
 (set! k (+ k 1)
)
 (loop31)
)
 (quote ()
)
)
)
)
)
 (loop31)
)
)
)
 (_display (to-str (formatRow slice)
)
)
 (newline)
 (set! row (+ row 1)
)
)
)
)
)
 (loop29)
)
 (quote ()
)
)
)
)
)
 (loop29)
)
)
)
 (_display (to-str (string-append "\nThe 100,000th cuban prime is " (commatize cube100k)
)
)
)
 (newline)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
(main)
