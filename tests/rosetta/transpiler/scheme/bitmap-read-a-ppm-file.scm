;; Generated on 2025-07-27 01:08 +0700
(import (only (scheme base) call/cc when list-ref list-set!))
(import (rename (scheme base) (list _list)))
(import (scheme time))
(import (chibi string))
(import (only (scheme char) string-upcase string-downcase))
(import (srfi 69))
(import (chibi time) (srfi 98))
(define _now_seeded #f)
(define _now_seed 0)
(define (now)
  (when (not _now_seeded)
    (let ((s (get-environment-variable "MOCHI_NOW_SEED")))
      (when (and s (string->number s))
        (set! _now_seed (string->number s))
        (set! _now_seeded #t))))
  (if _now_seeded
      (begin
        (set! _now_seed (modulo (+ (* _now_seed 1664525) 1013904223) 2147483647))
        _now_seed)
      (inexact->exact (* (current-second) 1000000000))))(import (chibi time))
(define (_mem) (* 1024 (resource-usage-max-rss (get-resource-usage resource-usage/self))))
(import (chibi json))
(define (to-str x)
  (cond ((pair? x)
         (string-append "[" (string-join (map to-str x) ", ") "]"))
        ((hash-table? x)
         (let* ((ks (hash-table-keys x))
                (pairs (map (lambda (k)
                              (string-append (to-str k) ":" (to-str (hash-table-ref x k))))
                            ks)))
           (string-append "{" (string-join pairs ", ") "}")))
        ((null? x) "")
        ((string? x) x)
        ((boolean? x) (if x "1" "0"))
        (else (number->string x))))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (fmod a b) (- a (* (floor (/ a b)) b)))
(define (_gt a b) (cond ((and (number? a) (number? b)) (> a b)) ((and (string? a) (string? b)) (string>? a b)) (else (> a b))))
(define (_lt a b) (cond ((and (number? a) (number? b)) (< a b)) ((and (string? a) (string? b)) (string<? a b)) (else (< a b))))
(define (_ge a b) (cond ((and (number? a) (number? b)) (>= a b)) ((and (string? a) (string? b)) (string>=? a b)) (else (>= a b))))
(define (_le a b) (cond ((and (number? a) (number? b)) (<= a b)) ((and (string? a) (string? b)) (string<=? a b)) (else (<= a b))))
(define (padStart s width pad)
  (let loop ((out s))
    (if (< (string-length out) width)
        (loop (string-append pad out))
        out)))
(let ((start40 (now)
)
)
 (begin (define (newBitmap w h max)
 (call/cc (lambda (ret1)
 (let ((rows (_list)
)
)
 (begin (let ((y 0)
)
 (begin (call/cc (lambda (break3)
 (letrec ((loop2 (lambda ()
 (if (< y h)
 (begin (let ((row (_list)
)
)
 (begin (let ((x 0)
)
 (begin (call/cc (lambda (break5)
 (letrec ((loop4 (lambda ()
 (if (< x w)
 (begin (set! row (append row (_list (alist->hash-table (_list (cons "R" 0)
 (cons "G" 0)
 (cons "B" 0)
)
)
)
)
)
 (set! x (+ x 1)
)
 (loop4)
)
 (quote ()
)
)
)
)
)
 (loop4)
)
)
)
 (set! rows (append rows (_list row)
)
)
 (set! y (+ y 1)
)
)
)
)
)
 (loop2)
)
 (quote ()
)
)
)
)
)
 (loop2)
)
)
)
 (ret1 (alist->hash-table (_list (cons "w" w)
 (cons "h" h)
 (cons "max" max)
 (cons "data" rows)
)
)
)
)
)
)
)
)
)
)
 (define (setPx b x y p)
 (call/cc (lambda (ret6)
 (let ((rows (hash-table-ref b "data")
)
)
 (begin (let ((row (list-ref rows y)
)
)
 (begin (list-set! row x p)
 (list-set! rows y row)
 (hash-table-set! b "data" rows)
)
)
)
)
)
)
)
 (define (getPx b x y)
 (call/cc (lambda (ret7)
 (ret7 (cond ((string? (list-ref (hash-table-ref b "data")
 y)
)
 (substring (list-ref (hash-table-ref b "data")
 y)
 x (+ x 1)
)
)
 ((hash-table? (list-ref (hash-table-ref b "data")
 y)
)
 (hash-table-ref (list-ref (hash-table-ref b "data")
 y)
 x)
)
 (else (list-ref (list-ref (hash-table-ref b "data")
 y)
 x)
)
)
)
)
)
)
 (define (splitLines s)
 (call/cc (lambda (ret8)
 (let ((out (_list)
)
)
 (begin (let ((cur "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break10)
 (letrec ((loop9 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (let ((ch (substring s i (+ i 1)
)
)
)
 (begin (if (string=? ch "\n")
 (begin (set! out (append out (_list cur)
)
)
 (set! cur "")
)
 (begin (set! cur (string-append cur ch)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop9)
)
 (quote ()
)
)
)
)
)
 (loop9)
)
)
)
 (set! out (append out (_list cur)
)
)
 (ret8 out)
)
)
)
)
)
)
)
)
)
 (define (splitWS s)
 (call/cc (lambda (ret11)
 (let ((out (_list)
)
)
 (begin (let ((cur "")
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break13)
 (letrec ((loop12 (lambda ()
 (if (< i (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
)
 (begin (let ((ch (substring s i (+ i 1)
)
)
)
 (begin (if (or (or (or (string=? ch " ")
 (string=? ch "\t")
)
 (string=? ch "\r")
)
 (string=? ch "\n")
)
 (begin (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! out (append out (_list cur)
)
)
 (set! cur "")
)
 (quote ()
)
)
)
 (begin (set! cur (string-append cur ch)
)
)
)
 (set! i (+ i 1)
)
)
)
 (loop12)
)
 (quote ()
)
)
)
)
)
 (loop12)
)
)
)
 (if (> (cond ((string? cur)
 (string-length cur)
)
 ((hash-table? cur)
 (hash-table-size cur)
)
 (else (length cur)
)
)
 0)
 (begin (set! out (append out (_list cur)
)
)
)
 (quote ()
)
)
 (ret11 out)
)
)
)
)
)
)
)
)
)
 (define (parseIntStr str)
 (call/cc (lambda (ret14)
 (let ((i 0)
)
 (begin (let ((neg #f)
)
 (begin (if (and (> (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
 0)
 (string=? (substring str 0 1)
 "-")
)
 (begin (set! neg #t)
 (set! i 1)
)
 (quote ()
)
)
 (let ((n 0)
)
 (begin (let ((digits (alist->hash-table (_list (cons "0" 0)
 (cons "1" 1)
 (cons "2" 2)
 (cons "3" 3)
 (cons "4" 4)
 (cons "5" 5)
 (cons "6" 6)
 (cons "7" 7)
 (cons "8" 8)
 (cons "9" 9)
)
)
)
)
 (begin (call/cc (lambda (break16)
 (letrec ((loop15 (lambda ()
 (if (< i (cond ((string? str)
 (string-length str)
)
 ((hash-table? str)
 (hash-table-size str)
)
 (else (length str)
)
)
)
 (begin (set! n (+ (* n 10)
 (cond ((string? digits)
 (substring digits (substring str i (+ i 1)
)
 (+ (substring str i (+ i 1)
)
 1)
)
)
 ((hash-table? digits)
 (hash-table-ref digits (substring str i (+ i 1)
)
)
)
 (else (list-ref digits (substring str i (+ i 1)
)
)
)
)
)
)
 (set! i (+ i 1)
)
 (loop15)
)
 (quote ()
)
)
)
)
)
 (loop15)
)
)
)
 (if neg (begin (set! n (- n)
)
)
 (quote ()
)
)
 (ret14 n)
)
)
)
)
)
)
)
)
)
)
)
 (define (tokenize s)
 (call/cc (lambda (ret17)
 (let ((lines (splitLines s)
)
)
 (begin (let ((toks (_list)
)
)
 (begin (let ((i 0)
)
 (begin (call/cc (lambda (break19)
 (letrec ((loop18 (lambda ()
 (if (< i (cond ((string? lines)
 (string-length lines)
)
 ((hash-table? lines)
 (hash-table-size lines)
)
 (else (length lines)
)
)
)
 (begin (let ((line (cond ((string? lines)
 (substring lines i (+ i 1)
)
)
 ((hash-table? lines)
 (hash-table-ref lines i)
)
 (else (list-ref lines i)
)
)
)
)
 (begin (if (and (> (cond ((string? line)
 (string-length line)
)
 ((hash-table? line)
 (hash-table-size line)
)
 (else (length line)
)
)
 0)
 (string=? (substring line 0 1)
 "#")
)
 (begin (set! i (+ i 1)
)
 (loop18)
)
 (quote ()
)
)
 (let ((parts (splitWS line)
)
)
 (begin (let ((j 0)
)
 (begin (call/cc (lambda (break21)
 (letrec ((loop20 (lambda ()
 (if (< j (cond ((string? parts)
 (string-length parts)
)
 ((hash-table? parts)
 (hash-table-size parts)
)
 (else (length parts)
)
)
)
 (begin (set! toks (append toks (_list (cond ((string? parts)
 (substring parts j (+ j 1)
)
)
 ((hash-table? parts)
 (hash-table-ref parts j)
)
 (else (list-ref parts j)
)
)
)
)
)
 (set! j (+ j 1)
)
 (loop20)
)
 (quote ()
)
)
)
)
)
 (loop20)
)
)
)
 (set! i (+ i 1)
)
)
)
)
)
)
)
 (loop18)
)
 (quote ()
)
)
)
)
)
 (loop18)
)
)
)
 (ret17 toks)
)
)
)
)
)
)
)
)
)
 (define (readP3 text)
 (call/cc (lambda (ret22)
 (let ((toks (tokenize text)
)
)
 (begin (if (< (cond ((string? toks)
 (string-length toks)
)
 ((hash-table? toks)
 (hash-table-size toks)
)
 (else (length toks)
)
)
 4)
 (begin (ret22 (newBitmap 0 0 0)
)
)
 (quote ()
)
)
 (if (not (string=? (cond ((string? toks)
 (substring toks 0 (+ 0 1)
)
)
 ((hash-table? toks)
 (hash-table-ref toks 0)
)
 (else (list-ref toks 0)
)
)
 "P3")
)
 (begin (ret22 (newBitmap 0 0 0)
)
)
 (quote ()
)
)
 (let ((w (parseIntStr (cond ((string? toks)
 (substring toks 1 (+ 1 1)
)
)
 ((hash-table? toks)
 (hash-table-ref toks 1)
)
 (else (list-ref toks 1)
)
)
)
)
)
 (begin (let ((h (parseIntStr (cond ((string? toks)
 (substring toks 2 (+ 2 1)
)
)
 ((hash-table? toks)
 (hash-table-ref toks 2)
)
 (else (list-ref toks 2)
)
)
)
)
)
 (begin (let ((maxv (parseIntStr (cond ((string? toks)
 (substring toks 3 (+ 3 1)
)
)
 ((hash-table? toks)
 (hash-table-ref toks 3)
)
 (else (list-ref toks 3)
)
)
)
)
)
 (begin (let ((idx 4)
)
 (begin (let ((bm (newBitmap w h maxv)
)
)
 (begin (let ((y (- h 1)
)
)
 (begin (call/cc (lambda (break24)
 (letrec ((loop23 (lambda ()
 (if (>= y 0)
 (begin (let ((x 0)
)
 (begin (call/cc (lambda (break26)
 (letrec ((loop25 (lambda ()
 (if (< x w)
 (begin (let ((r (parseIntStr (cond ((string? toks)
 (substring toks idx (+ idx 1)
)
)
 ((hash-table? toks)
 (hash-table-ref toks idx)
)
 (else (list-ref toks idx)
)
)
)
)
)
 (begin (let ((g (parseIntStr (cond ((string? toks)
 (substring toks (+ idx 1)
 (+ (+ idx 1)
 1)
)
)
 ((hash-table? toks)
 (hash-table-ref toks (+ idx 1)
)
)
 (else (list-ref toks (+ idx 1)
)
)
)
)
)
)
 (begin (let ((b (parseIntStr (cond ((string? toks)
 (substring toks (+ idx 2)
 (+ (+ idx 2)
 1)
)
)
 ((hash-table? toks)
 (hash-table-ref toks (+ idx 2)
)
)
 (else (list-ref toks (+ idx 2)
)
)
)
)
)
)
 (begin (setPx bm x y (alist->hash-table (_list (cons "R" r)
 (cons "G" g)
 (cons "B" b)
)
)
)
 (set! idx (+ idx 3)
)
 (set! x (+ x 1)
)
)
)
)
)
)
)
 (loop25)
)
 (quote ()
)
)
)
)
)
 (loop25)
)
)
)
 (set! y (- y 1)
)
)
)
 (loop23)
)
 (quote ()
)
)
)
)
)
 (loop23)
)
)
)
 (ret22 bm)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (define (toGrey b)
 (call/cc (lambda (ret27)
 (let ((h (hash-table-ref b "h")
)
)
 (begin (let ((w (hash-table-ref b "w")
)
)
 (begin (let ((m 0)
)
 (begin (let ((y 0)
)
 (begin (call/cc (lambda (break29)
 (letrec ((loop28 (lambda ()
 (if (< y h)
 (begin (let ((x 0)
)
 (begin (call/cc (lambda (break31)
 (letrec ((loop30 (lambda ()
 (if (< x w)
 (begin (let ((p (getPx b x y)
)
)
 (begin (let ((l (/ (+ (+ (* (hash-table-ref p "R")
 2126)
 (* (hash-table-ref p "G")
 7152)
)
 (* (hash-table-ref p "B")
 722)
)
 10000)
)
)
 (begin (if (_gt l (hash-table-ref b "max")
)
 (begin (set! l (hash-table-ref b "max")
)
)
 (quote ()
)
)
 (setPx b x y (alist->hash-table (_list (cons "R" l)
 (cons "G" l)
 (cons "B" l)
)
)
)
 (if (_gt l m)
 (begin (set! m l)
)
 (quote ()
)
)
 (set! x (+ x 1)
)
)
)
)
)
 (loop30)
)
 (quote ()
)
)
)
)
)
 (loop30)
)
)
)
 (set! y (+ y 1)
)
)
)
 (loop28)
)
 (quote ()
)
)
)
)
)
 (loop28)
)
)
)
 (hash-table-set! b "max" m)
)
)
)
)
)
)
)
)
)
)
)
 (define (pad n w)
 (call/cc (lambda (ret32)
 (let ((s (to-str n)
)
)
 (begin (call/cc (lambda (break34)
 (letrec ((loop33 (lambda ()
 (if (< (cond ((string? s)
 (string-length s)
)
 ((hash-table? s)
 (hash-table-size s)
)
 (else (length s)
)
)
 w)
 (begin (set! s (string-append " " s)
)
 (loop33)
)
 (quote ()
)
)
)
)
)
 (loop33)
)
)
)
 (ret32 s)
)
)
)
)
)
 (define (writeP3 b)
 (call/cc (lambda (ret35)
 (let ((h (hash-table-ref b "h")
)
)
 (begin (let ((w (hash-table-ref b "w")
)
)
 (begin (let ((max (hash-table-ref b "max")
)
)
 (begin (let ((digits (cond ((string? (to-str max)
)
 (string-length (to-str max)
)
)
 ((hash-table? (to-str max)
)
 (hash-table-size (to-str max)
)
)
 (else (length (to-str max)
)
)
)
)
)
 (begin (let ((out (string-append (string-append (string-append (string-append (string-append (string-append "P3\n# generated from Bitmap.writeppmp3\n" (to-str w)
)
 " ")
 (to-str h)
)
 "\n")
 (to-str max)
)
 "\n")
)
)
 (begin (let ((y (- h 1)
)
)
 (begin (call/cc (lambda (break37)
 (letrec ((loop36 (lambda ()
 (if (>= y 0)
 (begin (let ((line "")
)
 (begin (let ((x 0)
)
 (begin (call/cc (lambda (break39)
 (letrec ((loop38 (lambda ()
 (if (< x w)
 (begin (let ((p (getPx b x y)
)
)
 (begin (set! line (string-append (string-append (string-append (string-append (string-append (string-append line "   ")
 (pad (hash-table-ref p "R")
 digits)
)
 " ")
 (pad (hash-table-ref p "G")
 digits)
)
 " ")
 (pad (hash-table-ref p "B")
 digits)
)
)
 (set! x (+ x 1)
)
)
)
 (loop38)
)
 (quote ()
)
)
)
)
)
 (loop38)
)
)
)
 (set! out (string-append (string-append out line)
 "\n")
)
 (set! y (- y 1)
)
)
)
)
)
 (loop36)
)
 (quote ()
)
)
)
)
)
 (loop36)
)
)
)
 (ret35 out)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
)
 (define ppmtxt (string-append (string-append (string-append (string-append (string-append (string-append (string-append "P3\n" "# feep.ppm\n")
 "4 4\n")
 "15\n")
 " 0  0  0    0  0  0    0  0  0   15  0 15\n")
 " 0  0  0    0 15  7    0  0  0    0  0  0\n")
 " 0  0  0    0  0  0    0 15  7    0  0  0\n")
 "15  0 15    0  0  0    0  0  0    0  0  0\n")
)
 (display (to-str "Original Colour PPM file")
)
 (newline)
 (display (to-str ppmtxt)
)
 (newline)
 (define bm (readP3 ppmtxt)
)
 (display (to-str "Grey PPM:")
)
 (newline)
 (toGrey bm)
 (define out (writeP3 bm)
)
 (display (to-str out)
)
 (newline)
 (let ((end41 (now)
)
)
 (let ((dur42 (quotient (- end41 start40)
 1000)
)
)
 (begin (display (string-append "{\n  \"duration_us\": " (number->string dur42)
 ",\n  \"memory_bytes\": " (number->string (_mem)
)
 ",\n  \"name\": \"main\"\n}")
)
 (newline)
)
)
)
)
)
