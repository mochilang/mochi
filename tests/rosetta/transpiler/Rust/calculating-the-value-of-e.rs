// Generated by Mochi transpiler v0.10.57 on 2025-08-04 15:16 +0700
static mut g_epsilon: f64 = 0.0;
static mut g_factval: i64 = 0;
static mut g_e: f64 = 0.0;
static mut g_n: i64 = 0;
static mut g_term: f64 = 0.0;
unsafe fn absf(mut x: f64) -> f64 {
    if (x < 0.0) {
        return -x
    }
    return x
}

unsafe fn pow10(mut n: i64) -> f64 {
    let mut r: f64 = 1.0;
    let mut i: i64 = 0;
    while (i < n) {
        r = (r * 10.0);
        i = (i + 1);
    }
    return r
}

unsafe fn formatFloat(mut f: f64, mut prec: i64) -> String {
    let mut scale: f64 = pow10(prec);
    let mut scaled: f64 = ((f * scale) + 0.5);
    let mut n: i64 = (scaled as i64);
    let mut digits = n.to_string();
    while ((digits.len() as i64) <= prec) {
        digits = format!("{}{}", "0", digits);
    }
    let mut intPart: String = { let tmp = &digits; tmp.chars().skip(0 as usize).take((((digits.len() as i64) - prec) - 0) as usize).collect::<String>() }.clone();
    let mut fracPart: String = { let tmp = &digits; tmp.chars().skip(((digits.len() as i64) - prec) as usize).take(((digits.len() as i64) - ((digits.len() as i64) - prec)) as usize).collect::<String>() }.clone();
    return format!("{}{}", format!("{}{}", intPart, "."), fracPart).clone()
}

fn main() {
    unsafe {
        g_epsilon = 0.000000000000001;
        g_factval = 1;
        g_e = 2.0;
        g_n = 2;
        g_term = 1.0;
        loop {
            g_factval = (g_factval * g_n);
            g_n = (g_n + 1);
            g_term = (1.0 / (g_factval as f64));
            g_e = (g_e + g_term);
            if (absf(g_term) < g_epsilon) {
                break
            }
        }
        println!("{}", format!("{}{}", "e = ", formatFloat(g_e, 15)));
    }
}
