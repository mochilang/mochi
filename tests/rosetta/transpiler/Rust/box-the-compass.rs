// Generated by Mochi transpiler v0.10.56 on 2025-08-04 06:52 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_compassPoint: Vec<String> = Vec::new();
static mut g_headings: Vec<f64> = Vec::new();
static mut g_i: i64 = 0;
fn main() {
    unsafe {
        g_compassPoint = vec![String::from("North"), String::from("North by east"), String::from("North-northeast"), String::from("Northeast by north"), String::from("Northeast"), String::from("Northeast by east"), String::from("East-northeast"), String::from("East by north"), String::from("East"), String::from("East by south"), String::from("East-southeast"), String::from("Southeast by east"), String::from("Southeast"), String::from("Southeast by south"), String::from("South-southeast"), String::from("South by east"), String::from("South"), String::from("South by west"), String::from("South-southwest"), String::from("Southwest by south"), String::from("Southwest"), String::from("Southwest by west"), String::from("West-southwest"), String::from("West by south"), String::from("West"), String::from("West by north"), String::from("West-northwest"), String::from("Northwest by west"), String::from("Northwest"), String::from("Northwest by north"), String::from("North-northwest"), String::from("North by west")];
        g_headings = vec![0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38];
        g_i = 0;
                let _start: i64 = _now();
        unsafe fn padLeft(s: &str, mut w: i64) -> String {
    let mut res: String = String::from("").clone();
    let mut n: i64 = (w - (s.len() as i64));
    while (n > 0) {
        res = format!("{}{}", res, " ");
        n = (n - 1);
    }
    return format!("{}{}", res, s).clone()
};
        unsafe fn padRight(s: &str, mut w: i64) -> String {
    let mut out: String = s.to_string().clone();
    let mut i = (s.len() as i64);
    while (i < w) {
        out = format!("{}{}", out, " ");
        i = (i + 1);
    }
    return out.clone()
};
        unsafe fn indexOf(mut s: String, ch: &str) -> i64 {
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            return i
        }
        i = (i + 1);
    }
    return -1
};
        unsafe fn format2(mut f: f64) -> String {
    let mut s = f.to_string();
    let mut idx = { let s = s.clone(); let p = ".".clone(); match s.find(&p) { Some(v) => v as i64, None => -1 } };
    if (idx < 0) {
        s = format!("{}{}", s, ".00");
    } else {
        let mut need: i64 = (idx + 3);
        if ((s.len() as i64) > need) {
            let mut s: String = { let tmp = &s; tmp.chars().skip(0 as usize).take((need - 0) as usize).collect::<String>() };
        } else {
            while ((s.len() as i64) < need) {
                s = format!("{}{}", s, "0");
            }
        }
    }
    return s.clone()
};
        unsafe fn cpx(mut h: f64) -> i64 {
    let mut x: i64 = (((h / 11.25) + 0.5) as i64);
    x = (x % 32);
    if (x < 0) {
        x = (x + 32);
    }
    return x
};
        static mut g_compassPoint: Vec<String> = Vec::new();;
        unsafe fn degrees2compasspoint(mut h: f64) -> String {
    return g_compassPoint.clone()[cpx(h) as usize].clone().clone()
};
        static mut g_headings: Vec<f64> = Vec::new();;
        println!("{}", "Index  Compass point         Degree");
        static mut g_i: i64 = 0;;
        while (g_i < (g_headings.clone().len() as i64)) {
            let mut h: f64 = g_headings.clone()[g_i as usize];
            let mut idx: i64 = ((g_i % 32) + 1);
            let mut cp: String = degrees2compasspoint(h).clone();
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", padLeft(&idx.to_string(), 4), "   "), padRight(&cp, 19)), " "), format2(h)), "Â°"));
            g_i = (g_i + 1);
        }
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
