// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:12 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Map {
    length: i64,
    edges: HashMap<i64, i64>,
    suffix: i64,
}
impl std::fmt::Display for Map {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"length\": {}", self.length)?;
        write!(f, ", ")?;
        write!(f, "\"edges\": {:?}", self.edges)?;
        write!(f, ", ")?;
        write!(f, "\"suffix\": {}", self.suffix)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Map1 {
    length: i64,
    suffix: i64,
    edges: HashMap<i64, i64>,
}
impl std::fmt::Display for Map1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"length\": {}", self.length)?;
        write!(f, ", ")?;
        write!(f, "\"suffix\": {}", self.suffix)?;
        write!(f, ", ")?;
        write!(f, "\"edges\": {:?}", self.edges)?;
        write!(f, "}}")
    }
}

static mut g_EVEN_ROOT: i64 = 0;
static mut g_ODD_ROOT: i64 = 0;
fn main() {
    unsafe {
        g_EVEN_ROOT = 0;
        g_ODD_ROOT = 1;
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        static mut g_EVEN_ROOT: i64 = 0;;
        static mut g_ODD_ROOT: i64 = 0;;
        unsafe fn newNode(mut len: i64) -> Map {
    return Map {length: len, edges: HashMap::from([]), suffix: 0}
};
        unsafe fn eertree(s: &str) -> Vec<Map> {
    let mut tree: Vec<HashMap<String, f64>> = vec![];
    tree = { let mut _v = tree.clone(); _v.push(Map1 {length: 0, suffix: g_ODD_ROOT, edges: HashMap::from([])}); _v };
    tree = { let mut _v = tree.clone(); _v.push(Map1 {length: -1, suffix: g_ODD_ROOT, edges: HashMap::from([])}); _v };
    let mut suffix: i64 = g_ODD_ROOT;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut c: String = s[i as usize..(i + 1) as usize].to_string().clone();
        let mut n: i64 = suffix;
        let mut k: i64 = 0;
        loop {
            k = tree[n as usize].clone()["length".as_str()];
            let mut b: i64 = ((i - k) - 1);
            if ((b >= 0) && (s[b as usize..(b + 1) as usize].to_string().as_str() == c.as_str())) {
                break
            }
            n = tree[n as usize].clone()["suffix".as_str()];
        }
        let mut edges: HashMap<i64, i64> = tree[n as usize].clone()["edges".as_str()];
        if edges.contains_key(&c) {
            suffix = edges[c.as_str()];
            i = (i + 1);
            continue
        }
        suffix = (tree.len() as i64);
        tree = { let mut _v = tree.clone(); _v.push(newNode((k + 2))); _v };
        edges.insert(c.clone(), suffix);
        tree[n as usize]["edges"] = edges;
        if (tree[suffix as usize].clone()["length".as_str()] == 1) {
            tree[suffix as usize]["suffix"] = 0;
            i = (i + 1);
            continue
        }
        loop {
            n = tree[n as usize].clone()["suffix".as_str()];
            let mut b: i64 = ((i - tree[n as usize].clone()["length".as_str()]) - 1);
            if ((b >= 0) && (s[b as usize..(b + 1) as usize].to_string().as_str() == c.as_str())) {
                break
            }
        }
        let mut en: HashMap<i64, i64> = tree[n as usize].clone()["edges".as_str()];
        tree[suffix as usize]["suffix"] = en[c.as_str()];
        i = (i + 1);
    }
    return tree
};
        unsafe fn child(mut tree: Vec<HashMap<String, f64>>, mut idx: i64, p: &str, mut acc: Vec<String>) -> Vec<String> {
    let mut edges: f64 = tree[idx as usize].clone()["edges".as_str()];
    for ch in edges {
        let mut nxt: i64 = edges[ch];
        let mut pal: i64 = ((ch + p) + ch);
        acc = { let mut _v = acc.clone(); _v.push(pal.to_string()); _v };
        acc = child(tree.clone(), nxt, &pal, acc.clone());
    }
    return acc
};
        unsafe fn subPalindromes(mut tree: Vec<HashMap<String, f64>>) -> Vec<String> {
    let mut res: Vec<String> = vec![];
    res = child(tree.clone(), g_EVEN_ROOT, &"", res.clone());
    let mut oEdges: f64 = tree[g_ODD_ROOT as usize].clone()["edges".as_str()];
    for ch in oEdges {
        res = { let mut _v = res.clone(); _v.push(ch.to_string()); _v };
        res = child(tree.clone(), oEdges[ch], &ch, res.clone());
    }
    return res
};
        unsafe fn mochi_main() {
    let mut tree: Vec<Map> = eertree(&"eertree");
    let mut subs: Vec<String> = subPalindromes(tree.clone());
    println!("{}", format!("{:?}", subs));
};
        mochi_main();
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = (_end_mem - _start_mem);
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
