// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:12 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_source: String = String::new();
fn main() {
    unsafe {
        g_source = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "// Mochi translation of the Rosetta \"Entropy-Narcissist\" task\n", "// Simplified to compute the entropy of this source string\n\n"), "fun log2(x: float): float {\n"), "  var k = 0.0\n"), "  var v = x\n"), "  while v >= 2.0 {\n"), "    v = v / 2.0\n"), "    k = k + 1.0\n"), "  }\n"), "  while v < 1.0 {\n"), "    v = v * 2.0\n"), "    k = k - 1.0\n"), "  }\n"), "  let z = (v - 1.0) / (v + 1.0)\n"), "  var zpow = z\n"), "  var sum = z\n"), "  var i = 3\n"), "  while i <= 9 {\n"), "    zpow = zpow * z * z\n"), "    sum = sum + zpow / (i as float)\n"), "    i = i + 2\n"), "  }\n"), "  let ln2 = 0.6931471805599453\n"), "  return k + 2.0 * sum / ln2\n"), "}\n\n"), "fun entropy(data: string): float {\n"), "  if data == \"\" { return 0.0 }\n"), "  var counts: map<string,int> = {}\n"), "  var i = 0\n"), "  while i < len(data) {\n"), "    let ch = substring(data, i, i+1)\n"), "    if ch in counts {\n"), "      counts[ch] = counts[ch] + 1\n"), "    } else {\n"), "      counts[ch] = 1\n"), "    }\n"), "    i = i + 1\n"), "  }\n"), "  var e = 0.0\n"), "  let l = len(data) as float\n"), "  for ch in counts {\n"), "    let px = (counts[ch] as float) / l\n"), "    if px > 0.0 {\n"), "      e = e - px * log2(px)\n"), "    }\n"), "  }\n"), "  return e\n"), "}\n\n"), "// Store the program source as a string constant\n"), "let source = ... // truncated in actual source\n"), "\nfun main() {\n"), "  print(\"Source file entropy: \" + str(entropy(source)))\n"), "}\n\n"), "main()\n").clone();
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        unsafe fn log2(mut x: f64) -> f64 {
    let mut k: f64 = 0.0;
    let mut v: f64 = x;
    while (v >= 2.0) {
        v = (v / 2.0);
        k = (k + 1.0);
    }
    while (v < 1.0) {
        v = (v * 2.0);
        k = (k - 1.0);
    }
    let mut z: f64 = ((v - 1.0) / (v + 1.0));
    let mut zpow: f64 = z;
    let mut sum: f64 = z;
    let mut i: i64 = 3;
    while (i <= 9) {
        zpow = ((zpow * z) * z);
        sum = (sum + (zpow / (i as f64)));
        i = (i + 2);
    }
    let mut ln2: f64 = 0.6931471805599453;
    return (k + ((2.0 * sum) / ln2))
};
        unsafe fn entropy(data: &str) -> f64 {
    if (data == "") {
        return 0.0
    }
    let mut counts: HashMap<String, i64> = HashMap::from([]);
    let mut i: i64 = 0;
    while (i < (data.len() as i64)) {
        let mut ch: String = { let tmp = &data; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if counts.contains_key(&ch) {
            counts.insert(ch.clone(), (counts[ch.as_str()] + 1));
        } else {
            counts.insert(ch.clone(), 1);
        }
        i = (i + 1);
    }
    let mut e: f64 = 0.0;
    let mut l: f64 = ((data.len() as i64) as f64);
    for ch in counts.keys() {
        let mut px: f64 = ((counts[ch.as_str()] as f64) / l);
        if (px > 0.0) {
            e = (e - (px * log2(px)));
        }
    }
    return e
};
        static mut g_source: String = String::new();;
        unsafe fn mochi_main() {
    println!("{}", format!("{}{}", "Source file entropy: ", entropy(&g_source).to_string()));
};
        mochi_main();
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = (_end_mem - _start_mem);
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
