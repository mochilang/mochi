// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:12 +0700
use std::collections::HashMap;
use std::sync::LazyLock;
use std::sync::Mutex;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static g_nodes: LazyLock<Mutex<HashMap<i64, HashMap<String, f64>>>> = LazyLock::new(|| Mutex::new(HashMap::new()));
static mut g_head: i64 = 0;
static mut g_tail: i64 = 0;
static mut g_out: String = String::new();
static mut g_id: i64 = 0;
fn main() {
    unsafe {
        g_head = (0 - 1);
        g_tail = (0 - 1);
        g_out = String::from("From tail:");
        g_id = g_tail;
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        static g_nodes: LazyLock<Mutex<HashMap<i64, HashMap<String, f64>>>> = LazyLock::new(|| Mutex::new(HashMap::new()));;
        static mut g_head: i64 = 0;;
        static mut g_tail: i64 = 0;;
        unsafe fn listString() -> String {
    if (g_head == (0 - 1)) {
        return String::from("<nil>")
    }
    let mut r: String = format!("{}{}", "[", g_nodes.lock().unwrap()[&g_head].clone()["value".as_str()]).clone();
    let mut id: i64 = (g_nodes.lock().unwrap()[&g_head].clone()["next".as_str()] as i64);
    while (id != (0 - 1)) {
        r = format!("{}{}", format!("{}{}", r, " "), g_nodes.lock().unwrap()[&id].clone()["value".as_str()]);
        id = (g_nodes.lock().unwrap()[&id].clone()["next".as_str()] as i64);
    }
    r = format!("{}{}", r, "]");
    return r.clone()
};
        println!("{}", listString());
        { let mut _map = g_nodes.lock().unwrap(); let _val = HashMap::from([(String::from("value"), "A"), (String::from("next"), (0 - 1)), (String::from("prev"), (0 - 1))]); _map.insert(0.clone(), _val); };
        g_head = 0;
        g_tail = 0;
        { let mut _map = g_nodes.lock().unwrap(); let _val = HashMap::from([(String::from("value"), "B"), (String::from("next"), (0 - 1)), (String::from("prev"), 0)]); _map.insert(1.clone(), _val); };
        g_nodes.lock().unwrap()[&0].insert("next".clone(), 1);
        g_tail = 1;
        println!("{}", listString());
        { let mut _map = g_nodes.lock().unwrap(); let _val = HashMap::from([(String::from("value"), "C"), (String::from("next"), 1), (String::from("prev"), 0)]); _map.insert(2.clone(), _val); };
        g_nodes.lock().unwrap()[&1].insert("prev".clone(), 2);
        g_nodes.lock().unwrap()[&0].insert("next".clone(), 2);
        println!("{}", listString());
        static mut g_out: String = String::new();;
        static mut g_id: i64 = 0;;
        while (g_id != (0 - 1)) {
            g_out = format!("{}{}", format!("{}{}", g_out, " "), g_nodes.lock().unwrap()[&g_id].clone()["value".as_str()]);
            g_id = (g_nodes.lock().unwrap()[&g_id].clone()["prev".as_str()] as i64);
        }
        println!("{}", g_out);
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = (_end_mem - _start_mem);
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
