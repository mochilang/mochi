// Generated by Mochi transpiler v0.10.57 on 2025-08-04 21:43 +0700
use std::collections::HashMap;
#[derive(Debug, Clone, Default)]
struct TestCasesItem {
    base: i64,
    begin: String,
    end: String,
    kaprekar: Vec<String>,
}
impl std::fmt::Display for TestCasesItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"base\": {}", self.base)?;
        write!(f, ", ")?;
        write!(f, "\"begin\": \"{}\"", self.begin)?;
        write!(f, ", ")?;
        write!(f, "\"end\": \"{}\"", self.end)?;
        write!(f, ", ")?;
        write!(f, "\"kaprekar\": {:?}", self.kaprekar)?;
        write!(f, "}}")
    }
}

static mut g_testCases: Vec<TestCasesItem> = Vec::new();
static mut g_idx: i64 = 0;
unsafe fn parseIntBase(mut s: String, mut base: i64) -> i64 {
    let mut digits: String = String::from("0123456789abcdefghijklmnopqrstuvwxyz").clone();
    let mut n: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut j: i64 = 0;
        let mut v: i64 = 0;
        while (j < (digits.len() as i64)) {
            if ({ let tmp = &digits; tmp.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>() }.as_str() == s.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().as_str()) {
                v = j;
                break
            }
            j = (j + 1);
        }
        n = ((n * base) + v);
        i = (i + 1);
    }
    return n
}

unsafe fn intToBase(mut n: i64, mut base: i64) -> String {
    let mut digits: String = String::from("0123456789abcdefghijklmnopqrstuvwxyz").clone();
    if (n == 0) {
        return String::from("0")
    }
    let mut out: String = String::from("").clone();
    let mut v: i64 = n;
    while (v > 0) {
        let mut d: i64 = (v % base);
        out = format!("{}{}", digits.chars().skip(d as usize).take(((d + 1) - d) as usize).collect::<String>(), out);
        v = (v / base);
    }
    return out.clone()
}

unsafe fn subset(mut base: i64, begin: &str, end: &str) -> Vec<String> {
    let mut b: i64 = parseIntBase(begin.to_string(), base);
    let mut e: i64 = parseIntBase(end.to_string(), base);
    let mut out: Vec<String> = vec![];
    let mut k: i64 = b;
    while (k <= e) {
        let mut ks: String = intToBase(k, base).clone();
        let mut r#mod: i64 = (base - 1);
        let mut r1: i64 = (parseIntBase(ks.clone(), base) % r#mod);
        let mut r2: i64 = ((parseIntBase(ks.clone(), base) * parseIntBase(ks.clone(), base)) % r#mod);
        if (r1 == r2) {
            out = { let mut _v = out.clone(); _v.push(ks.clone()); _v };
        }
        k = (k + 1);
    }
    return out
}

fn main() {
    unsafe {
        g_testCases = vec![TestCasesItem {base: 10, begin: String::from("1"), end: String::from("100"), kaprekar: vec![String::from("1"), String::from("9"), String::from("45"), String::from("55"), String::from("99")]}, TestCasesItem {base: 17, begin: String::from("10"), end: String::from("gg"), kaprekar: vec![String::from("3d"), String::from("d4"), String::from("gg")]}];
        g_idx = 0;
        while (g_idx < (g_testCases.clone().len() as i64)) {
            let mut tc: TestCasesItem = g_testCases.clone()[g_idx as usize].clone();
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "\nTest case base = ", tc.base.to_string()), ", begin = "), tc.begin), ", end = "), tc.end), ":"));
            let mut s: Vec<String> = subset(tc.base, &tc.begin, &tc.end);
            println!("{}", format!("{}{}", "Subset:  ", format!("{:?}", s)));
            println!("{}", format!("{}{}", "Kaprekar:", format!("{:?}", tc.kaprekar)));
            let mut sx: i64 = 0;
            let mut valid: bool = true;
            let mut i: i64 = 0;
            while (i < (tc.kaprekar.len() as i64)) {
                let mut k: String = tc.kaprekar[i as usize].clone().clone();
                let mut found: bool = false;
                while (sx < (s.len() as i64)) {
                    if (s[sx as usize].clone().as_str() == k.as_str()) {
                        found = true;
                        sx = (sx + 1);
                        break
                    }
                    sx = (sx + 1);
                }
                if !found {
                    println!("{}", format!("{}{}", format!("{}{}", "Fail:", k), " not in subset"));
                    valid = false;
                    break
                }
                i = (i + 1);
            }
            if valid {
                println!("{}", "Valid subset.");
            }
            g_idx = (g_idx + 1);
        }
    }
}
