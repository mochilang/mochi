// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:12 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Map {
    nodes: HashMap<i64, i64>,
    head: i64,
    tail: i64,
    nextID: i64,
}
impl std::fmt::Display for Map {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"nodes\": {:?}", self.nodes)?;
        write!(f, ", ")?;
        write!(f, "\"head\": {}", self.head)?;
        write!(f, ", ")?;
        write!(f, "\"tail\": {}", self.tail)?;
        write!(f, ", ")?;
        write!(f, "\"nextID\": {}", self.nextID)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Map1 {
    id: i64,
    value: f64,
    next: i64,
    prev: i64,
}
impl std::fmt::Display for Map1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"id\": {}", self.id)?;
        write!(f, ", ")?;
        write!(f, "\"value\": {}", self.value)?;
        write!(f, ", ")?;
        write!(f, "\"next\": {}", self.next)?;
        write!(f, ", ")?;
        write!(f, "\"prev\": {}", self.prev)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start_mem: i64 = _mem();
    let _start: i64 = _now();
    fn newList() -> Map {
    return Map {nodes: HashMap::from([]), head: 0, tail: 0, nextID: 1}
};
    fn newNode(mut l: HashMap<String, f64>, mut v: f64) -> Map1 {
    let mut id: i64 = (l["nextID".as_str()] as i64);
    l.insert("nextID".clone(), (id + 1));
    let mut nodes: f64 = l["nodes".as_str()];
    let mut n: Map1 = Map1 {id: id, value: v, next: 0, prev: 0};
    nodes[id] = n;
    l.insert("nodes".clone(), nodes);
    return n
};
    fn pushFront(mut l: HashMap<String, f64>, mut v: f64) -> Map1 {
    let mut n: Map1 = newNode(l.clone(), v);
    n["next"] = l["head".as_str()];
    if ((l["head".as_str()] as i64) != 0) {
        let mut nodes: f64 = l["nodes".as_str()];
        let mut h: i64 = nodes[(l["head".as_str()] as i64)];
        h["prev"] = n.id;
        nodes[h["id".as_str()]] = h;
        l.insert("nodes".clone(), nodes);
    } else {
        l.insert("tail".clone(), n.id);
    }
    l.insert("head".clone(), n.id);
    let mut nodes2: f64 = l["nodes".as_str()];
    nodes2[n.id] = n;
    l.insert("nodes".clone(), nodes2);
    return n
};
    fn pushBack(mut l: HashMap<String, f64>, mut v: f64) -> Map1 {
    let mut n: Map1 = newNode(l.clone(), v);
    n["prev"] = l["tail".as_str()];
    if ((l["tail".as_str()] as i64) != 0) {
        let mut nodes: f64 = l["nodes".as_str()];
        let mut t: i64 = nodes[(l["tail".as_str()] as i64)];
        t["next"] = n.id;
        nodes[t["id".as_str()]] = t;
        l.insert("nodes".clone(), nodes);
    } else {
        l.insert("head".clone(), n.id);
    }
    l.insert("tail".clone(), n.id);
    let mut nodes2: f64 = l["nodes".as_str()];
    nodes2[n.id] = n;
    l.insert("nodes".clone(), nodes2);
    return n
};
    fn insertBefore(mut l: HashMap<String, f64>, mut refID: i64, mut v: f64) -> Map1 {
    if (refID == 0) {
        return pushFront(l.clone(), v)
    }
    let mut nodes: f64 = l["nodes".as_str()];
    let mut r#ref: i64 = nodes[refID];
    let mut n: Map1 = newNode(l.clone(), v);
    n["prev"] = r#ref["prev".as_str()];
    n["next"] = r#ref["id".as_str()];
    if (r#ref["prev".as_str()] != 0) {
        let mut p: i64 = nodes[r#ref["prev".as_str()]];
        p["next"] = n.id;
        nodes[p["id".as_str()]] = p;
    } else {
        l.insert("head".clone(), n.id);
    }
    r#ref["prev"] = n.id;
    nodes[refID] = r#ref;
    nodes[n.id] = n;
    l.insert("nodes".clone(), nodes);
    return n
};
    fn insertAfter(mut l: HashMap<String, f64>, mut refID: i64, mut v: f64) -> Map1 {
    if (refID == 0) {
        return pushBack(l.clone(), v)
    }
    let mut nodes: f64 = l["nodes".as_str()];
    let mut r#ref: i64 = nodes[refID];
    let mut n: Map1 = newNode(l.clone(), v);
    n["next"] = r#ref["next".as_str()];
    n["prev"] = r#ref["id".as_str()];
    if (r#ref["next".as_str()] != 0) {
        let mut nx: i64 = nodes[r#ref["next".as_str()]];
        nx["prev"] = n.id;
        nodes[nx["id".as_str()]] = nx;
    } else {
        l.insert("tail".clone(), n.id);
    }
    r#ref["next"] = n.id;
    nodes[refID] = r#ref;
    nodes[n.id] = n;
    l.insert("nodes".clone(), nodes);
    return n
};
    fn mochi_main() {
    let mut l: Map = newList();
    let mut e4: Map1 = pushBack(l.clone(), (4 as f64));
    let mut e1: Map1 = pushFront(l.clone(), (1 as f64));
    insertBefore(l.clone(), e4.id, (3 as f64));
    insertAfter(l.clone(), e1.id, "two");
    let mut id: i64 = l.head;
    let mut nodes: HashMap<i64, i64> = l.nodes;
    while (id != 0) {
        let mut node: i64 = nodes[&id];
        println!("{}", node["value".as_str()].to_string());
        id = node["next".as_str()];
    }
};
    mochi_main();
    let _end: i64 = _now();
    let _end_mem: i64 = _mem();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = (_end_mem - _start_mem);
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
