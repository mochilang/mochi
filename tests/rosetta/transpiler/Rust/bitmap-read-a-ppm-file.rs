// Generated by Mochi transpiler v0.10.56 on 2025-08-03 17:38 +0700
use std::collections::HashMap;
#[derive(Debug, Clone, Default)]
struct Pixel {
    R: i64,
    G: i64,
    B: i64,
}
impl std::fmt::Display for Pixel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"R\": {}", self.R)?;
        write!(f, ", ")?;
        write!(f, "\"G\": {}", self.G)?;
        write!(f, ", ")?;
        write!(f, "\"B\": {}", self.B)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Bitmap {
    w: i64,
    h: i64,
    max: i64,
    data: Vec<Vec<Pixel>>,
}
impl std::fmt::Display for Bitmap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"w\": {}", self.w)?;
        write!(f, ", ")?;
        write!(f, "\"h\": {}", self.h)?;
        write!(f, ", ")?;
        write!(f, "\"max\": {}", self.max)?;
        write!(f, ", ")?;
        write!(f, "\"data\": {:?}", self.data)?;
        write!(f, "}}")
    }
}

static mut g_ppmtxt: String = String::new();
static mut g_bm: Bitmap = Bitmap { w: 0, h: 0, max: 0, data: Vec::new() };
unsafe fn newBitmap(mut w: i64, mut h: i64, mut max: i64) -> Bitmap {
    let mut rows: Vec<Vec<Pixel>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<Pixel> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            row = { let mut _v = row.clone(); _v.push(Pixel {R: 0, G: 0, B: 0}); _v };
            x = (x + 1);
        }
        rows = { let mut _v = rows.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return Bitmap {w: w, h: h, max: max, data: rows}
}

unsafe fn setPx(b: &mut Bitmap, mut x: i64, mut y: i64, p: &Pixel) {
    let mut rows: Vec<Vec<Pixel>> = b.data.clone();
    let mut row: Vec<Pixel> = rows[y as usize].clone();
    row[x as usize] = p.clone();
    rows[y as usize] = row.clone();
    (*b).data = rows.clone();
}

unsafe fn getPx(b: &Bitmap, mut x: i64, mut y: i64) -> Pixel {
    return b.data.clone()[y as usize].clone()[x as usize].clone()
}

unsafe fn splitLines(mut s: String) -> Vec<String> {
    let mut out: Vec<String> = vec![];
    let mut cur: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut ch: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (ch.as_str() == "\n") {
            out = { let mut _v = out.clone(); _v.push(cur.clone()); _v };
            cur = String::from("");
        } else {
            cur = format!("{}{}", cur, ch);
        }
        i = (i + 1);
    }
    out = { let mut _v = out.clone(); _v.push(cur.clone()); _v };
    return out
}

unsafe fn splitWS(mut s: String) -> Vec<String> {
    let mut out: Vec<String> = vec![];
    let mut cur: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut ch: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if ((((ch.as_str() == " ") || (ch.as_str() == "\t")) || (ch.as_str() == "\r")) || (ch.as_str() == "\n")) {
            if ((cur.len() as i64) > 0) {
                out = { let mut _v = out.clone(); _v.push(cur.clone()); _v };
                cur = String::from("");
            }
        } else {
            cur = format!("{}{}", cur, ch);
        }
        i = (i + 1);
    }
    if ((cur.len() as i64) > 0) {
        out = { let mut _v = out.clone(); _v.push(cur.clone()); _v };
    }
    return out
}

unsafe fn parseIntStr(mut str: String) -> i64 {
    let mut i: i64 = 0;
    let mut neg: bool = false;
    if (((str.len() as i64) > 0) && (str[0 as usize..1 as usize].to_string().as_str() == "-")) {
        neg = true;
        i = 1;
    }
    let mut n: i64 = 0;
    let mut digits = HashMap::from([(String::from("0"), 0), (String::from("1"), 1), (String::from("2"), 2), (String::from("3"), 3), (String::from("4"), 4), (String::from("5"), 5), (String::from("6"), 6), (String::from("7"), 7), (String::from("8"), 8), (String::from("9"), 9)]);
    while (i < (str.len() as i64)) {
        n = ((n * 10) + digits.get(str[i as usize..(i + 1) as usize].to_string().as_str()).cloned().unwrap_or_default());
        i = (i + 1);
    }
    if neg {
        n = -n;
    }
    return n
}

unsafe fn tokenize(s: &str) -> Vec<String> {
    let mut lines: Vec<String> = splitLines(s.to_string());
    let mut toks: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (lines.len() as i64)) {
        let mut line: String = lines[i as usize].clone().clone();
        if (((line.len() as i64) > 0) && ({ let tmp = &line; tmp.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>() }.as_str() == "#")) {
            i = (i + 1);
            continue
        }
        let mut parts: Vec<String> = splitWS(line.clone());
        let mut j: i64 = 0;
        while (j < (parts.len() as i64)) {
            toks = { let mut _v = toks.clone(); _v.push(parts[j as usize].clone()); _v };
            j = (j + 1);
        }
        i = (i + 1);
    }
    return toks
}

unsafe fn readP3(text: &str) -> Bitmap {
    let mut toks: Vec<String> = tokenize(text);
    if ((toks.len() as i64) < 4) {
        return newBitmap(0, 0, 0)
    }
    if (toks[0 as usize].clone().as_str() != "P3") {
        return newBitmap(0, 0, 0)
    }
    let mut w: i64 = parseIntStr(toks[1 as usize].clone());
    let mut h: i64 = parseIntStr(toks[2 as usize].clone());
    let mut maxv: i64 = parseIntStr(toks[3 as usize].clone());
    let mut idx: i64 = 4;
    let mut bm: Bitmap = newBitmap(w, h, maxv);
    let mut y: i64 = (h - 1);
    while (y >= 0) {
        let mut x: i64 = 0;
        while (x < w) {
            let mut r: i64 = parseIntStr(toks[idx as usize].clone());
            let mut g: i64 = parseIntStr(toks[(idx + 1) as usize].clone());
            let mut b: i64 = parseIntStr(toks[(idx + 2) as usize].clone());
            setPx(&mut bm, x, y, &Pixel {R: r, G: g, B: b});
            idx = (idx + 3);
            x = (x + 1);
        }
        y = (y - 1);
    }
    return bm
}

unsafe fn toGrey(b: &mut Bitmap) {
    let mut h: i64 = b.h;
    let mut w: i64 = b.w;
    let mut m: i64 = 0;
    let mut y: i64 = 0;
    while (y < h) {
        let mut x: i64 = 0;
        while (x < w) {
            let mut p: Pixel = getPx(b, x, y);
            let mut l: i64 = ((((p.R * 2126) + (p.G * 7152)) + (p.B * 722)) / 10000);
            if (l > b.max) {
                l = b.max;
            }
            setPx(b, x, y, &Pixel {R: l, G: l, B: l});
            if (l > m) {
                m = l;
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    (*b).max = m;
}

unsafe fn pad(mut n: i64, mut w: i64) -> String {
    let mut s = n.to_string();
    while ((s.len() as i64) < w) {
        s = format!("{}{}", " ", s);
    }
    return s.clone()
}

unsafe fn writeP3(b: &Bitmap) -> String {
    let mut h: i64 = b.h;
    let mut w: i64 = b.w;
    let mut max: i64 = b.max;
    let mut digits = (max.to_string().len() as i64);
    let mut out: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "P3\n# generated from Bitmap.writeppmp3\n", w.to_string()), " "), h.to_string()), "\n"), max.to_string()), "\n").clone();
    let mut y: i64 = (h - 1);
    while (y >= 0) {
        let mut line: String = String::from("").clone();
        let mut x: i64 = 0;
        while (x < w) {
            let mut p: Pixel = getPx(b, x, y);
            line = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", line, "   "), pad(p.R, digits)), " "), pad(p.G, digits)), " "), pad(p.B, digits));
            x = (x + 1);
        }
        out = format!("{}{}", format!("{}{}", out, line), "\n");
        y = (y - 1);
    }
    return out.clone()
}

fn main() {
    unsafe {
        g_ppmtxt = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "P3\n", "# feep.ppm\n"), "4 4\n"), "15\n"), " 0  0  0    0  0  0    0  0  0   15  0 15\n"), " 0  0  0    0 15  7    0  0  0    0  0  0\n"), " 0  0  0    0  0  0    0 15  7    0  0  0\n"), "15  0 15    0  0  0    0  0  0    0  0  0\n").clone();
        g_bm = readP3(&g_ppmtxt);
        println!("{}", "Original Colour PPM file");
        println!("{}", g_ppmtxt);
        println!("{}", "Grey PPM:");
        unsafe { toGrey(&mut g_bm); }
        let mut out: String = writeP3(&g_bm).clone();
        println!("{}", out);
    }
}
