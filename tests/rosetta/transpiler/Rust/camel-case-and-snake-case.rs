// Generated by Mochi transpiler v0.10.57 on 2025-08-04 21:25 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn trimSpace(mut s: String) -> String {
    let mut start: i64 = 0;
    while ((start < (s.len() as i64)) && (s.chars().skip(start as usize).take(((start + 1) - start) as usize).collect::<String>().as_str() == " ")) {
        start = (start + 1);
    }
    let mut end = (s.len() as i64);
    while ((end > start) && (s.chars().skip((end - 1) as usize).take((end - (end - 1)) as usize).collect::<String>().as_str() == " ")) {
        end = (end - 1);
    }
    return s.chars().skip(start as usize).take((end - start) as usize).collect::<String>().clone()
};
    fn isUpper(ch: &str) -> bool {
    return ((ch >= "A") && (ch <= "Z"))
};
    fn padLeft(s: &str, mut w: i64) -> String {
    let mut res: String = String::from("").clone();
    let mut n: i64 = (w - (s.len() as i64));
    while (n > 0) {
        res = format!("{}{}", res, " ");
        n = (n - 1);
    }
    return format!("{}{}", res, s).clone()
};
    fn snakeToCamel(mut s: String) -> String {
    s = trimSpace(s.clone());
    let mut out: String = String::from("").clone();
    let mut up: bool = false;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut ch: String = s.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().clone();
        if ((((ch.as_str() == "_") || (ch.as_str() == "-")) || (ch.as_str() == " ")) || (ch.as_str() == ".")) {
            up = true;
            i = (i + 1);
            continue
        }
        if (i == 0) {
            out = format!("{}{}", out, (ch.to_lowercase()));
            up = false;
            i = (i + 1);
            continue
        }
        if up {
            out = format!("{}{}", out, (ch.to_uppercase()));
            up = false;
        } else {
            out = format!("{}{}", out, ch);
        }
        i = (i + 1);
    }
    return out.clone()
};
    fn camelToSnake(mut s: String) -> String {
    s = trimSpace(s.clone());
    let mut out: String = String::from("").clone();
    let mut prevUnd: bool = false;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut ch: String = s.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().clone();
        if (((ch.as_str() == " ") || (ch.as_str() == "-")) || (ch.as_str() == ".")) {
            if (!prevUnd && ((out.len() as i64) > 0)) {
                out = format!("{}{}", out, "_");
                prevUnd = true;
            }
            i = (i + 1);
            continue
        }
        if (ch.as_str() == "_") {
            if (!prevUnd && ((out.len() as i64) > 0)) {
                out = format!("{}{}", out, "_");
                prevUnd = true;
            }
            i = (i + 1);
            continue
        }
        if isUpper(&ch) {
            if ((i > 0) && !prevUnd) {
                out = format!("{}{}", out, "_");
            }
            out = format!("{}{}", out, (ch.to_lowercase()));
            prevUnd = false;
        } else {
            out = format!("{}{}", out, (ch.to_lowercase()));
            prevUnd = false;
        }
        i = (i + 1);
    }
    let mut start: i64 = 0;
    while ((start < (out.len() as i64)) && (out.chars().skip(start as usize).take(((start + 1) - start) as usize).collect::<String>().as_str() == "_")) {
        start = (start + 1);
    }
    let mut end = (out.len() as i64);
    while ((end > start) && (out.chars().skip((end - 1) as usize).take((end - (end - 1)) as usize).collect::<String>().as_str() == "_")) {
        end = (end - 1);
    }
    out = out.chars().skip(start as usize).take((end - start) as usize).collect::<String>();
    let mut res: String = String::from("").clone();
    let mut j: i64 = 0;
    let mut lastUnd: bool = false;
    while (j < (out.len() as i64)) {
        let mut c: String = out.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>().clone();
        if (c.as_str() == "_") {
            if !lastUnd {
                res = format!("{}{}", res, c);
            }
            lastUnd = true;
        } else {
            res = format!("{}{}", res, c);
            lastUnd = false;
        }
        j = (j + 1);
    }
    return res.clone()
};
    fn mochi_main() {
    let mut samples: Vec<String> = vec![String::from("snakeCase"), String::from("snake_case"), String::from("snake-case"), String::from("snake case"), String::from("snake CASE"), String::from("snake.case"), String::from("variable_10_case"), String::from("variable10Case"), String::from("É›rgo rE tHis"), String::from("hurry-up-joe!"), String::from("c://my-docs/happy_Flag-Day/12.doc"), String::from(" spaces ")];
    println!("{}", "=== To snake_case ===");
    for s in samples.iter().cloned() {
        println!("{}", format!("{}{}", format!("{}{}", padLeft(&s, 34), " => "), camelToSnake(s.clone())));
    }
    println!("{}", "");
    println!("{}", "=== To camelCase ===");
    for s in samples.iter().cloned() {
        println!("{}", format!("{}{}", format!("{}{}", padLeft(&s, 34), " => "), snakeToCamel(s.clone())));
    }
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
