// Generated by Mochi transpiler v0.10.50 on 2025-07-30 21:05 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Fps {
    coeffs: Vec<f64>,
    compute: i64,
}
impl std::fmt::Display for Fps {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"coeffs\": {:?}", self.coeffs)?;
        write!(f, ", ")?;
        write!(f, "\"compute\": {}", self.compute)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Pair {
    sin: Fps,
    cos: Fps,
}
impl std::fmt::Display for Pair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"sin\": {}", self.sin)?;
        write!(f, ", ")?;
        write!(f, "\"cos\": {}", self.cos)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start_mem: i64 = _mem();
    let _start: i64 = _now();
    fn newFps(fn: &mut impl FnMut(i64) -> f64) -> Fps {
    return Fps {coeffs: vec![], compute: r#fn}
};
    fn extract(mut f: Fps, mut n: i64) -> f64 {
    while ((f.coeffs.len() as i64) <= n) {
        let mut idx = (f.coeffs.len() as i64);
        let mut v = f.compute(idx);
        f.coeffs = { let mut _v = f.coeffs.clone(); _v.push(v); _v };
    }
    return f.coeffs[n as usize]
};
    fn one() -> Fps {
    return newFps(&mut move |i: i64| -> f64 {
    if (i == 0) {
        return 1.0
    }
    return 0.0
})
};
    fn add(a: &Fps, b: &Fps) -> Fps {
    return newFps(&mut move |n: i64| -> f64 {
    return (extract(a, n) + extract(b, n))
})
};
    fn sub(a: &Fps, b: &Fps) -> Fps {
    return newFps(&mut move |n: i64| -> f64 {
    return (extract(a, n) - extract(b, n))
})
};
    fn mul(a: &Fps, b: &Fps) -> Fps {
    return newFps(&mut move |n: i64| -> f64 {
    let mut s: f64 = 0.0;
    let mut k: i64 = 0;
    while (k <= n) {
        s = (s + (extract(a, k) * extract(b, (n - k))));
        k = (k + 1);
    }
    return s
})
};
    fn div(a: &Fps, b: &Fps) -> Fps {
    let mut q: Fps = newFps(&mut move |n: i64| -> f64 {
    return 0.0
});
    q.compute = move |n: i64| -> f64 {
    let mut b0: f64 = extract(b, 0);
    if (b0 == 0.0) {
        return (0.0 / 0.0)
    }
    let mut s: f64 = extract(a, n);
    let mut k: i64 = 1;
    while (k <= n) {
        s = (s - (extract(b, k) * extract(q, (n - k))));
        k = (k + 1);
    }
    return (s / b0)
};
    return q
};
    fn differentiate(a: &Fps) -> Fps {
    return newFps(&mut move |n: i64| -> f64 {
    return (((n + 1) as f64) * extract(a, (n + 1)))
})
};
    fn integrate(a: &Fps) -> Fps {
    return newFps(&mut move |n: i64| -> f64 {
    if (n == 0) {
        return 0.0
    }
    return (extract(a, (n - 1)) / (n as f64))
})
};
    fn sinCos() -> Pair {
    let mut sin: Fps = newFps(&mut move |n: i64| -> f64 {
    return 0.0
});
    let mut cos: Fps = sub(&one(), &integrate(&sin));
    sin.compute = move |n: i64| -> f64 {
    if (n == 0) {
        return 0.0
    }
    return (extract(cos, (n - 1)) / (n as f64))
};
    return Pair {sin: sin, cos: cos}
};
    fn floorf(mut x: f64) -> f64 {
    let mut y: i64 = (x as i64);
    return (y as f64)
};
    fn fmtF5(mut x: f64) -> String {
    let mut y: f64 = (floorf(((x * 100000.0) + 0.5)) / 100000.0);
    let mut s = y.to_string();
    let mut dot = indexOf(s, ".");
    if (dot == (0 - 1)) {
        s = format!("{}{}", s, ".00000");
    } else {
        let mut decs = (((s.len() as i64) - dot) - 1);
        if (decs > 5) {
            s = { let tmp = &s; tmp.chars().skip(0 as usize).take(((dot + 6) - 0) as usize).collect::<String>() };
        } else {
            while (decs < 5) {
                s = format!("{}{}", s, "0");
                decs = (decs + 1);
            }
        }
    }
    return s.clone()
};
    fn padFloat5(mut x: f64, mut width: i64) -> String {
    let mut s: String = fmtF5(x).clone();
    while ((s.len() as i64) < width) {
        s = format!("{}{}", " ", s);
    }
    return s.clone()
};
    fn partialSeries(f: &Fps) -> String {
    let mut out = String::from("");
    let mut i: i64 = 0;
    while (i < 6) {
        out = format!("{}{}", format!("{}{}", format!("{}{}", out, " "), padFloat5(extract(f, i), 8)), " ");
        i = (i + 1);
    }
    return out.clone()
};
    fn mochi_main() {
    let mut p: Pair = sinCos();
    println!("{}", format!("{}{}", "sin:", partialSeries(&p.sin)));
    println!("{}", format!("{}{}", "cos:", partialSeries(&p.cos)));
};
    mochi_main();
    let _end: i64 = _now();
    let _end_mem: i64 = _mem();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = (_end_mem - _start_mem);
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
