// Generated by Mochi transpiler v0.10.42 on 2025-07-27 17:23 +0700
use std::collections::HashMap;
use std::sync::LazyLock;
use std::sync::Mutex;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Pixel {
    r: i64,
    g: i64,
    b: i64,
}
impl std::fmt::Display for Pixel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"r\": {}", self.r)?;
        write!(f, ", ")?;
        write!(f, "\"g\": {}", self.g)?;
        write!(f, ", ")?;
        write!(f, "\"b\": {}", self.b)?;
        write!(f, "}}")
    }
}

static mut g_b3Seg: i64 = 0;
static g_b: LazyLock<Mutex<HashMap<&str, i64>>> = LazyLock::new(|| Mutex::new(HashMap::new()));
fn main() {
    unsafe {
        g_b3Seg = 30;
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        static mut g_b3Seg: i64 = 0;;
        unsafe fn pixelFromRgb(mut rgb: i64) -> Pixel {
    let r: i64 = ((rgb / 65536) % 256);
    let g: i64 = ((rgb / 256) % 256);
    let b: i64 = (rgb % 256);
    return Pixel {r: r, g: g, b: b}
};
        unsafe fn newBitmap(mut cols: i64, mut rows: i64) -> HashMap<&str, i64> {
    let mut d: Vec<Vec<Pixel>> = vec![];
    let mut y: i64 = 0;
    while (y < rows) {
        let mut row: Vec<Pixel> = vec![];
        let mut x: i64 = 0;
        while (x < cols) {
            row = { let mut _v = row.clone(); _v.push(Pixel {r: 0, g: 0, b: 0}); _v };
            x = (x + 1);
        }
        d = { let mut _v = d.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return HashMap::from([(String::from("cols"), cols), (String::from("rows"), rows), (String::from("data"), d)])
};
        unsafe fn setPx(mut b: HashMap<String, f64>, mut x: i64, mut y: i64, p: &Pixel) {
    let cols: i64 = (b.lock().unwrap()["cols".as_str()] as i64);
    let rows: i64 = (b.lock().unwrap()["rows".as_str()] as i64);
    if ((((x >= 0) && (x < cols)) && (y >= 0)) && (y < rows)) {
        b.lock().unwrap()["data".as_str()][y][x] = p;
    }
};
        unsafe fn fill(mut b: HashMap<String, f64>, p: &Pixel) {
    let cols: i64 = (b.lock().unwrap()["cols".as_str()] as i64);
    let rows: i64 = (b.lock().unwrap()["rows".as_str()] as i64);
    let mut y: i64 = 0;
    while (y < rows) {
        let mut x: i64 = 0;
        while (x < cols) {
            b.lock().unwrap()["data".as_str()][y][x] = p;
            x = (x + 1);
        }
        y = (y + 1);
    }
};
        unsafe fn fillRgb(b: &HashMap<String, f64>, mut rgb: i64) {
    fill(b.clone(), &pixelFromRgb(rgb));
};
        unsafe fn line(b: &HashMap<String, f64>, mut x0: i64, mut y0: i64, mut x1: i64, mut y1: i64, p: &Pixel) {
    let mut dx: i64 = (x1 - x0);
    if (dx < 0) {
        dx = -dx;
    }
    let mut dy: i64 = (y1 - y0);
    if (dy < 0) {
        dy = -dy;
    }
    let mut sx: i64 = -1;
    if (x0 < x1) {
        sx = 1;
    }
    let mut sy: i64 = -1;
    if (y0 < y1) {
        sy = 1;
    }
    let mut err: i64 = (dx - dy);
    while true {
        setPx(b.clone(), x0, y0, p);
        if ((x0 == x1) && (y0 == y1)) {
            break
        }
        let e2: i64 = (2 * err);
        if (e2 > (0 - dy)) {
            err = (err - dy);
            x0 = (x0 + sx);
        }
        if (e2 < dx) {
            err = (err + dx);
            y0 = (y0 + sy);
        }
    }
};
        unsafe fn bezier3(b: &HashMap<String, f64>, mut x1: i64, mut y1: i64, mut x2: i64, mut y2: i64, mut x3: i64, mut y3: i64, mut x4: i64, mut y4: i64, p: &Pixel) {
    let mut px: Vec<i64> = vec![];
    let mut py: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i <= g_b3Seg) {
        px = { let mut _v = px.clone(); _v.push(0); _v };
        py = { let mut _v = py.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    let fx1: f64 = (x1 as f64);
    let fy1: f64 = (y1 as f64);
    let fx2: f64 = (x2 as f64);
    let fy2: f64 = (y2 as f64);
    let fx3: f64 = (x3 as f64);
    let fy3: f64 = (y3 as f64);
    let fx4: f64 = (x4 as f64);
    let fy4: f64 = (y4 as f64);
    i = 0;
    while (i <= g_b3Seg) {
        let d: f64 = ((i as f64) / (g_b3Seg as f64));
        let mut a: f64 = (1.0 - d);
        let mut bcoef: f64 = (a * a);
        let mut ccoef: f64 = (d * d);
        let mut a2: f64 = (a * bcoef);
        let mut b2: f64 = ((3.0 * bcoef) * d);
        let mut c2: f64 = ((3.0 * a) * ccoef);
        let mut d2: f64 = (ccoef * d);
        px[i as usize] = (((((a2 * fx1) + (b2 * fx2)) + (c2 * fx3)) + (d2 * fx4)) as i64);
        py[i as usize] = (((((a2 * fy1) + (b2 * fy2)) + (c2 * fy3)) + (d2 * fy4)) as i64);
        i = (i + 1);
    }
    let mut x0: i64 = px[0 as usize];
    let mut y0: i64 = py[0 as usize];
    i = 1;
    while (i <= g_b3Seg) {
        let x: i64 = px[i as usize];
        let y: i64 = py[i as usize];
        line(b, x0, y0, x, y, p);
        x0 = x;
        y0 = y;
        i = (i + 1);
    }
};
        static g_b: LazyLock<Mutex<HashMap<&str, i64>>> = LazyLock::new(|| Mutex::new(HashMap::new()));;
        fillRgb(&g_b, 16773055);
        bezier3(&g_b, 20, 200, 700, 50, -300, 50, 380, 150, &pixelFromRgb(4165615));
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = (_end_mem - _start_mem);
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
