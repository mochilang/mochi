// Generated by Mochi transpiler v0.10.42 on 2025-07-27 17:23 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_msg: String = String::new();
static mut g_enc: String = String::new();
static mut g_dec: String = String::new();
fn main() {
    unsafe {
        g_msg = String::from("Rosetta Code Base64 decode data task");
        g_enc = base64Encode(g_msg).clone();
        g_dec = base64Decode(g_enc).clone();
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        unsafe fn indexOf(mut s: String, mut ch: String) -> i64 {
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if (s.chars().nth(i as usize).unwrap() == ch) {
            return i
        }
        i = (i + 1);
    }
    return -1
};
        unsafe fn parseIntStr(mut str: String) -> i64 {
    let mut i: i64 = 0;
    let mut neg: bool = false;
    if (((str.len() as i64) > 0) && (str.chars().nth(0 as usize).unwrap() == "-")) {
        neg = true;
        i = 1;
    }
    let mut n: i64 = 0;
    let digits = HashMap::from([(String::from("0"), 0), (String::from("1"), 1), (String::from("2"), 2), (String::from("3"), 3), (String::from("4"), 4), (String::from("5"), 5), (String::from("6"), 6), (String::from("7"), 7), (String::from("8"), 8), (String::from("9"), 9)]);
    while (i < (str.len() as i64)) {
        n = ((n * 10) + digits[str.chars().nth(i as usize).unwrap()]);
        i = (i + 1);
    }
    if neg {
        n = -n;
    }
    return n
};
        unsafe fn ord(mut ch: String) -> i64 {
    let upper: i64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let lower: i64 = "abcdefghijklmnopqrstuvwxyz";
    let mut idx: i64 = indexOf(upper.to_string(), ch);
    if (idx >= 0) {
        return (65 + idx)
    }
    idx = indexOf(lower.to_string(), ch);
    if (idx >= 0) {
        return (97 + idx)
    }
    if ((ch.as_str() >= "0") && (ch.as_str() <= "9")) {
        return (48 + parseIntStr(ch))
    }
    if (ch.as_str() == "+") {
        return 43
    }
    if (ch.as_str() == "/") {
        return 47
    }
    if (ch.as_str() == " ") {
        return 32
    }
    if (ch.as_str() == "=") {
        return 61
    }
    return 0
};
        unsafe fn chr(mut n: i64) -> String {
    let upper: i64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let lower: i64 = "abcdefghijklmnopqrstuvwxyz";
    if ((n >= 65) && (n < 91)) {
        return upper[(n - 65)..(n - 64)].to_vec().to_string()
    }
    if ((n >= 97) && (n < 123)) {
        return lower[(n - 97)..(n - 96)].to_vec().to_string()
    }
    if ((n >= 48) && (n < 58)) {
        let digits = String::from("0123456789");
        return digits[(n - 48) as usize..(n - 47) as usize].to_string()
    }
    if (n == 43) {
        return String::from("+")
    }
    if (n == 47) {
        return String::from("/")
    }
    if (n == 32) {
        return String::from(" ")
    }
    if (n == 61) {
        return String::from("=")
    }
    return String::from("?").clone()
};
        unsafe fn toBinary(mut n: i64, mut bits: i64) -> String {
    let mut b = String::from("");
    let mut val: i64 = n;
    let mut i: i64 = 0;
    while (i < bits) {
        b = format!("{}{}", (val % 2).to_string(), b);
        val = (val / 2);
        i = (i + 1);
    }
    return b.clone()
};
        unsafe fn binToInt(mut bits: String) -> i64 {
    let mut n: i64 = 0;
    let mut i: i64 = 0;
    while (i < (bits.len() as i64)) {
        n = ((n * 2) + parseIntStr(bits[i as usize..(i + 1) as usize].to_string()));
        i = (i + 1);
    }
    return n
};
        unsafe fn base64Encode(mut text: String) -> String {
    let alphabet = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    let mut bin = String::from("");
    for ch in text {
        bin = format!("{}{}", bin, toBinary(ord(ch.to_string()), 8));
    }
    while (((bin.len() as i64) % 6) != 0) {
        bin = format!("{}{}", bin, "0");
    }
    let mut out = String::from("");
    let mut i: i64 = 0;
    while (i < (bin.len() as i64)) {
        let chunk: String = bin[i as usize..(i + 6) as usize].to_string().clone();
        let val: i64 = binToInt(chunk);
        out = format!("{}{}", out, alphabet[val as usize..(val + 1) as usize].to_string());
        i = (i + 6);
    }
    let pad: i64 = ((3 - ((text.len() as i64) % 3)) % 3);
    if (pad == 1) {
        out = format!("{}{}", out[0 as usize..((out.len() as i64) - 1) as usize].to_string(), "=");
    }
    if (pad == 2) {
        out = format!("{}{}", out[0 as usize..((out.len() as i64) - 2) as usize].to_string(), "==");
    }
    return out.clone()
};
        unsafe fn base64Decode(mut enc: String) -> String {
    let alphabet = String::from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    let mut bin = String::from("");
    let mut i: i64 = 0;
    while (i < (enc.len() as i64)) {
        let ch = enc.chars().nth(i as usize).unwrap();
        if (ch == "=") {
            break
        }
        let idx: i64 = indexOf(alphabet, ch.to_string());
        bin = format!("{}{}", bin, toBinary(idx, 6));
        i = (i + 1);
    }
    let mut out = String::from("");
    i = 0;
    while ((i + 8) <= (bin.len() as i64)) {
        let chunk: String = bin[i as usize..(i + 8) as usize].to_string().clone();
        let val: i64 = binToInt(chunk);
        out = format!("{}{}", out, chr(val));
        i = (i + 8);
    }
    return out.clone()
};
        static mut g_msg: String = String::new();;
        println!("{}", format!("{}{}", "Original : ", g_msg));
        static mut g_enc: String = String::new();;
        println!("{}", format!("{}{}", "\nEncoded  : ", g_enc));
        static mut g_dec: String = String::new();;
        println!("{}", format!("{}{}", "\nDecoded  : ", g_dec));
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = (_end_mem - _start_mem);
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
