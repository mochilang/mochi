// Generated by Mochi transpiler v0.10.55 on 2025-08-02 23:08 +0700
fn absf(mut x: f64) -> f64 {
    if (x < 0.0) {
        return -x
    }
    return x
}

fn floorf(mut x: f64) -> f64 {
    let mut y: i64 = (x as i64);
    return (y as f64)
}

fn indexOf(mut s: String, ch: &str) -> i64 {
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() } == ch) {
            return i
        }
        i = (i + 1);
    }
    return -1
}

fn fmtF(mut x: f64) -> String {
    let mut y: f64 = (floorf(((x * 10000.0) + 0.5)) / 10000.0);
    let mut s = y.to_string();
    let mut dot: i64 = indexOf(s.clone(), &".");
    if (dot == (0 - 1)) {
        s = format!("{}{}", s, ".0000");
    } else {
        let mut decs = (((s.len() as i64) - dot) - 1);
        if (decs > 4) {
            let mut s: String = { let tmp = &s; tmp.chars().skip(0 as usize).take(((dot + 5) - 0) as usize).collect::<String>() };
        } else {
            while (decs < 4) {
                s = format!("{}{}", s, "0");
                decs = (decs + 1);
            }
        }
    }
    return s.clone()
}

fn padInt(mut n: i64, mut width: i64) -> String {
    let mut s = n.to_string();
    while ((s.len() as i64) < width) {
        s = format!("{}{}", " ", s);
    }
    return s.clone()
}

fn padFloat(mut x: f64, mut width: i64) -> String {
    let mut s: String = fmtF(x).clone();
    while ((s.len() as i64) < width) {
        s = format!("{}{}", " ", s);
    }
    return s.clone()
}

fn avgLen(mut n: i64) -> f64 {
    let mut tests: i64 = 10000;
    let mut sum: i64 = 0;
    let mut seed: i64 = 1;
    let mut t: i64 = 0;
    while (t < tests) {
        let mut visited: Vec<bool> = vec![];
        let mut i: i64 = 0;
        while (i < n) {
            visited = { let mut _v = visited.clone(); _v.push(false); _v };
            i = (i + 1);
        }
        let mut x: i64 = 0;
        while !visited[x as usize] {
            visited[x as usize] = true;
            sum = (sum + 1);
            seed = (((seed * 1664525) + 1013904223) % 2147483647);
            x = (seed % n);
        }
        t = (t + 1);
    }
    return ((sum as f64) / (tests as f64))
}

fn ana(mut n: i64) -> f64 {
    let mut nn: f64 = (n as f64);
    let mut term: f64 = 1.0;
    let mut sum: f64 = 1.0;
    let mut i: f64 = (nn - 1.0);
    while (i >= 1.0) {
        term = (term * (i / nn));
        sum = (sum + term);
        i = (i - 1.0);
    }
    return sum
}

fn mochi_main() {
    let mut nmax: i64 = 20;
    println!("{}", " N    average    analytical    (error)");
    println!("{}", "===  =========  ============  =========");
    let mut n: i64 = 1;
    while (n <= nmax) {
        let mut a: f64 = avgLen(n);
        let mut b: f64 = ana(n);
        let mut err: f64 = ((absf((a - b)) / b) * 100.0);
        let mut line: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", padInt(n, 3), "  "), padFloat(a, 9)), "  "), padFloat(b, 12)), "  ("), padFloat(err, 6)), "%)").clone();
        println!("{}", line);
        n = (n + 1);
    }
}

fn main() {
    mochi_main();
}
