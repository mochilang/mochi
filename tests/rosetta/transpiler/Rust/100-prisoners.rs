// Generated by Mochi transpiler v0.10.37 on 2025-07-23 10:09 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn shuffle(xs: Vec<i64>) -> Vec<i64> {
    let mut arr: Vec<i64> = xs;
    let mut i: i64 = 99;
    while (i > 0) {
        let j = (_now() % (i + 1));
        let tmp: i64 = arr[i as usize];
        arr[i as usize] = arr[j as usize];
        arr[j as usize] = tmp;
        i = (i - 1);
    }
    return arr
}

fn doTrials(trials: i64, np: i64, strategy: String) {
    let mut pardoned: i64 = 0;
    let mut t: i64 = 0;
    while (t < trials) {
        let mut drawers: Vec<i64> = vec![];
        let mut i: i64 = 0;
        while (i < 100) {
            drawers = { let mut v = drawers.clone(); v.push(i); v };
            i = (i + 1);
        }
        drawers = shuffle(drawers);
        let mut p: i64 = 0;
        let mut success: bool = true;
        while (p < np) {
            let mut found: bool = false;
            if (strategy == "optimal") {
                let mut prev: i64 = p;
                let mut d: i64 = 0;
                while (d < 50) {
                    let this: i64 = drawers[prev as usize];
                    if (this == p) {
                        found = true;
                        break
                    }
                    prev = this;
                    d = (d + 1);
                }
            } else {
                let mut opened: Vec<bool> = vec![];
                let mut k: i64 = 0;
                while (k < 100) {
                    opened = { let mut v = opened.clone(); v.push(false); v };
                    k = (k + 1);
                }
                let mut d: i64 = 0;
                while (d < 50) {
                    let mut n = (_now() % 100);
                    while opened[n as usize] {
                        n = (_now() % 100);
                    }
                    opened[n as usize] = true;
                    if (drawers[n as usize] == p) {
                        found = true;
                        break
                    }
                    d = (d + 1);
                }
            }
            if !found {
                success = false;
                break
            }
            p = (p + 1);
        }
        if success {
            pardoned = (pardoned + 1);
        }
        t = (t + 1);
    }
    let rf: f64 = ((pardoned / trials) as f64 * 100.0);
    println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "  strategy = ", strategy), "  pardoned = "), pardoned.to_string()), " relative frequency = "), rf.to_string()), "%"));
}

fn mochi_main() {
    let trials: i64 = 1000;
    for np in vec![10, 100] {
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Results from ", trials.to_string()), " trials with "), np.to_string()), " prisoners:\n"));
        for strat in &vec!["random", "optimal"] {
            doTrials(trials, np, strat.to_string());
        }
    }
}

fn main() {
    mochi_main();
}
