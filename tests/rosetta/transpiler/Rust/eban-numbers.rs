// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:12 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_vals: Vec<i64> = Vec::new();
static mut g_billions: Vec<i64> = Vec::new();
fn main() {
    unsafe {
        g_vals = vec![0, 2, 4, 6, 30, 32, 34, 36, 40, 42, 44, 46, 50, 52, 54, 56, 60, 62, 64, 66];
        g_billions = vec![0, 2, 4, 6];
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        static mut g_vals: Vec<i64> = Vec::new();;
        static mut g_billions: Vec<i64> = Vec::new();;
        unsafe fn ebanNumbers(mut start: i64, mut stop: i64) -> Vec<i64> {
    let mut nums: Vec<i64> = vec![];
    for b in g_billions.clone().clone() {
        for m in g_vals.clone().clone() {
            for t in g_vals.clone().clone() {
                for r in g_vals.clone().clone() {
                    let mut n: i64 = ((((b * 1000000000) + (m * 1000000)) + (t * 1000)) + r);
                    if ((n >= start) && (n <= stop)) {
                        nums = { let mut _v = nums.clone(); _v.push(n); _v };
                    }
                }
            }
        }
    }
    return nums
};
        unsafe fn countEban(mut start: i64, mut stop: i64) -> i64 {
    let mut count: i64 = 0;
    for b in g_billions.clone().clone() {
        for m in g_vals.clone().clone() {
            for t in g_vals.clone().clone() {
                for r in g_vals.clone().clone() {
                    let mut n: i64 = ((((b * 1000000000) + (m * 1000000)) + (t * 1000)) + r);
                    if ((n >= start) && (n <= stop)) {
                        count = (count + 1);
                    }
                }
            }
        }
    }
    return count
};
        unsafe fn mochi_main() {
    let mut ranges: Vec<Vec<i64>> = vec![vec![2, 1000, true], vec![1000, 4000, true], vec![2, 10000, false], vec![2, 100000, false], vec![2, 1000000, false], vec![2, 10000000, false], vec![2, 100000000, false], vec![2, 1000000000, false]];
    for rg in &ranges {
        let mut start: i64 = rg[0 as usize];
        let mut stop: i64 = rg[1 as usize];
        let mut show: i64 = rg[2 as usize];
        if (start == 2) {
            println!("{}", format!("{}{}", format!("{}{}", "eban numbers up to and including ", stop.to_string()), ":"));
        } else {
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "eban numbers between ", start.to_string()), " and "), stop.to_string()), " (inclusive):"));
        }
        if show.is_some() {
            let mut nums: Vec<i64> = ebanNumbers(start, stop);
            let mut line = String::from("");
            let mut i: i64 = 0;
            while (i < (nums.len() as i64)) {
                line = format!("{}{}", format!("{}{}", line, nums[i as usize].to_string()), " ");
                i = (i + 1);
            }
            if ((line.len() as i64) > 0) {
                println!("{}", { let tmp = &line; tmp.chars().skip(0 as usize).take((((line.len() as i64) - 1) - 0) as usize).collect::<String>() });
            }
        }
        let mut c: i64 = countEban(start, stop);
        println!("{}", format!("{}{}", format!("{}{}", "count = ", c.to_string()), "\n"));
    }
};
        mochi_main();
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = (_end_mem - _start_mem);
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
