// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:12 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Airport {
    name: String,
    country: String,
    icao: String,
    lat: f64,
    lon: f64,
}
impl std::fmt::Display for Airport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"name\": \"{}\"", self.name)?;
        write!(f, ", ")?;
        write!(f, "\"country\": \"{}\"", self.country)?;
        write!(f, ", ")?;
        write!(f, "\"icao\": \"{}\"", self.icao)?;
        write!(f, ", ")?;
        write!(f, "\"lat\": {}", self.lat)?;
        write!(f, ", ")?;
        write!(f, "\"lon\": {}", self.lon)?;
        write!(f, "}}")
    }
}

static mut g_PI: f64 = 0.0;
static mut g_airports: Vec<Airport> = Vec::new();
fn main() {
    unsafe {
        g_PI = 3.141592653589793;
        g_airports = vec![Airport {name: String::from("Koksijde Air Base"), country: String::from("Belgium"), icao: String::from("EBFN"), lat: 51.090301513671875, lon: 2.652780055999756}, Airport {name: String::from("Ostend-Bruges International Airport"), country: String::from("Belgium"), icao: String::from("EBOS"), lat: 51.198898315399994, lon: 2.8622200489}, Airport {name: String::from("Kent International Airport"), country: String::from("United Kingdom"), icao: String::from("EGMH"), lat: 51.342201, lon: 1.34611}, Airport {name: String::from("Calais-Dunkerque Airport"), country: String::from("France"), icao: String::from("LFAC"), lat: 50.962100982666016, lon: 1.954759955406189}, Airport {name: String::from("Westkapelle heliport"), country: String::from("Belgium"), icao: String::from("EBKW"), lat: 51.32222366333, lon: 3.2930560112}, Airport {name: String::from("Lympne Airport"), country: String::from("United Kingdom"), icao: String::from("EGMK"), lat: 51.08, lon: 1.013}, Airport {name: String::from("Ursel Air Base"), country: String::from("Belgium"), icao: String::from("EBUL"), lat: 51.14419937133789, lon: 3.475559949874878}, Airport {name: String::from("Southend Airport"), country: String::from("United Kingdom"), icao: String::from("EGMC"), lat: 51.5713996887207, lon: 0.6955559849739075}, Airport {name: String::from("Merville-Calonne Airport"), country: String::from("France"), icao: String::from("LFQT"), lat: 50.61840057373047, lon: 2.642240047454834}, Airport {name: String::from("Wevelgem Airport"), country: String::from("Belgium"), icao: String::from("EBKT"), lat: 50.817199707, lon: 3.20472002029}, Airport {name: String::from("Midden-Zeeland Airport"), country: String::from("Netherlands"), icao: String::from("EHMZ"), lat: 51.5121994019, lon: 3.73111009598}, Airport {name: String::from("Lydd Airport"), country: String::from("United Kingdom"), icao: String::from("EGMD"), lat: 50.95610046386719, lon: 0.9391670227050781}, Airport {name: String::from("RAF Wattisham"), country: String::from("United Kingdom"), icao: String::from("EGUW"), lat: 52.1273002625, lon: 0.956264019012}, Airport {name: String::from("Beccles Airport"), country: String::from("United Kingdom"), icao: String::from("EGSM"), lat: 52.435298919699996, lon: 1.6183300018300002}, Airport {name: String::from("Lille/Marcq-en-Baroeul Airport"), country: String::from("France"), icao: String::from("LFQO"), lat: 50.687198638916016, lon: 3.0755600929260254}, Airport {name: String::from("Lashenden (Headcorn) Airfield"), country: String::from("United Kingdom"), icao: String::from("EGKH"), lat: 51.156898, lon: 0.641667}, Airport {name: String::from("Le Touquet-CÃ´te d'Opale Airport"), country: String::from("France"), icao: String::from("LFAT"), lat: 50.517398834228516, lon: 1.6205899715423584}, Airport {name: String::from("Rochester Airport"), country: String::from("United Kingdom"), icao: String::from("EGTO"), lat: 51.351898193359375, lon: 0.5033329725265503}, Airport {name: String::from("Lille-Lesquin Airport"), country: String::from("France"), icao: String::from("LFQQ"), lat: 50.563332, lon: 3.086886}, Airport {name: String::from("Thurrock Airfield"), country: String::from("United Kingdom"), icao: String::from("EGMT"), lat: 51.537505, lon: 0.367634}];
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        static mut g_PI: f64 = 0.0;;
        unsafe fn sinApprox(mut x: f64) -> f64 {
    let mut term: f64 = x;
    let mut sum: f64 = x;
    let mut n: i64 = 1;
    while (n <= 8) {
        let mut denom: f64 = (((2 * n) * ((2 * n) + 1)) as f64);
        term = (((-term * x) * x) / denom);
        sum = (sum + term);
        n = (n + 1);
    }
    return sum
};
        unsafe fn cosApprox(mut x: f64) -> f64 {
    let mut term: f64 = 1.0;
    let mut sum: f64 = 1.0;
    let mut n: i64 = 1;
    while (n <= 8) {
        let mut denom: f64 = ((((2 * n) - 1) * (2 * n)) as f64);
        term = (((-term * x) * x) / denom);
        sum = (sum + term);
        n = (n + 1);
    }
    return sum
};
        unsafe fn atanApprox(mut x: f64) -> f64 {
    if (x > 1.0) {
        return ((g_PI / 2.0) - (x / ((x * x) + 0.28)))
    }
    if (x < -1.0) {
        return ((-g_PI / 2.0) - (x / ((x * x) + 0.28)))
    }
    return (x / (1.0 + ((0.28 * x) * x)))
};
        unsafe fn atan2Approx(mut y: f64, mut x: f64) -> f64 {
    if (x > 0.0) {
        let mut r: f64 = atanApprox((y / x));
        return r
    }
    if (x < 0.0) {
        if (y >= 0.0) {
            return (atanApprox((y / x)) + g_PI)
        }
        return (atanApprox((y / x)) - g_PI)
    }
    if (y > 0.0) {
        return (g_PI / 2.0)
    }
    if (y < 0.0) {
        return (-g_PI / 2.0)
    }
    return 0.0
};
        unsafe fn sqrtApprox(mut x: f64) -> f64 {
    let mut guess: f64 = x;
    let mut i: i64 = 0;
    while (i < 10) {
        guess = ((guess + (x / guess)) / 2.0);
        i = (i + 1);
    }
    return guess
};
        unsafe fn rad(mut x: f64) -> f64 {
    return ((x * g_PI) / 180.0)
};
        unsafe fn deg(mut x: f64) -> f64 {
    return ((x * 180.0) / g_PI)
};
        unsafe fn distance(mut lat1: f64, mut lon1: f64, mut lat2: f64, mut lon2: f64) -> f64 {
    let mut phi1: f64 = rad(lat1);
    let mut phi2: f64 = rad(lat2);
    let mut dphi: f64 = rad((lat2 - lat1));
    let mut dlambda: f64 = rad((lon2 - lon1));
    let mut sdphi: f64 = sinApprox((dphi / (2 as f64)));
    let mut sdlambda: f64 = sinApprox((dlambda / (2 as f64)));
    let mut a: f64 = ((sdphi * sdphi) + (((cosApprox(phi1) * cosApprox(phi2)) * sdlambda) * sdlambda));
    let mut c: i64 = ((2 as f64) * atan2Approx(sqrtApprox(a), sqrtApprox((((1 as f64) - a) as f64))));
    return ((6371.0 / 1.852) * (c as f64))
};
        unsafe fn bearing(mut lat1: f64, mut lon1: f64, mut lat2: f64, mut lon2: f64) -> f64 {
    let mut phi1: f64 = rad(lat1);
    let mut phi2: f64 = rad(lat2);
    let mut dl: f64 = rad((lon2 - lon1));
    let mut y: f64 = (sinApprox(dl) * cosApprox(phi2));
    let mut x: f64 = ((cosApprox(phi1) * sinApprox(phi2)) - ((sinApprox(phi1) * cosApprox(phi2)) * cosApprox(dl)));
    let mut br: f64 = deg(atan2Approx(y, x));
    if (br < (0 as f64)) {
        br = (br + (360 as f64));
    }
    return br
};
        static mut g_airports: Vec<Airport> = Vec::new();;
        unsafe fn floor(mut x: f64) -> f64 {
    let mut i: i64 = (x as i64);
    if ((i as f64) > x) {
        i = (i - 1);
    }
    return (i as f64)
};
        unsafe fn pow10(mut n: i64) -> f64 {
    let mut p: f64 = 1.0;
    let mut i: i64 = 0;
    while (i < n) {
        p = (p * 10.0);
        i = (i + 1);
    }
    return p
};
        unsafe fn round(mut x: f64, mut n: i64) -> f64 {
    let mut m: f64 = pow10(n);
    return (floor(((x * m) + 0.5)) / m)
};
        unsafe fn sortByDistance(mut xs: Vec<Vec<f64>>) -> Vec<Vec<f64>> {
    let mut arr: Vec<Vec<f64>> = xs;
    let mut i: i64 = 1;
    while (i < (arr.len() as i64)) {
        let mut j: i64 = i;
        while ((j > 0) && (arr[(j - 1) as usize].clone()[0 as usize] > arr[j as usize].clone()[0 as usize])) {
            let mut tmp: Vec<f64> = arr[(j - 1) as usize].clone();
            arr[(j - 1) as usize] = arr[j as usize].clone();
            arr[j as usize] = tmp;
            j = (j - 1);
        }
        i = (i + 1);
    }
    return arr
};
        unsafe fn mochi_main() {
    let mut planeLat: f64 = 51.514669;
    let mut planeLon: f64 = 2.198581;
    let mut results: Vec<Vec<f64>> = vec![];
    for ap in &g_airports.clone() {
        let mut d: f64 = distance(planeLat, planeLon, ap.lat, ap.lon);
        let mut b: f64 = bearing(planeLat, planeLon, ap.lat, ap.lon);
        results = { let mut _v = results.clone(); _v.push(vec![d, b, ap]); _v };
    }
    results = sortByDistance(results.clone());
    println!("{}", "Distance Bearing ICAO Country               Airport");
    println!("{}", "--------------------------------------------------------------");
    let mut i: i64 = 0;
    while (i < (results.len() as i64)) {
        let mut r: Vec<f64> = results[i as usize].clone();
        let mut ap: f64 = r[2 as usize];
        let mut dist: f64 = r[0 as usize];
        let mut bear: f64 = r[1 as usize];
        let mut line = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", round(dist, 1).to_string(), "\t"), round(bear, 0).to_string()), "\t"), ap.icao), "\t"), ap.country), " "), ap.name);
        println!("{}", line);
        i = (i + 1);
    }
};
        mochi_main();
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = (_end_mem - _start_mem);
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
