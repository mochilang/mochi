// Generated by Mochi transpiler v0.10.54 on 2025-08-02 14:06 +0700
use std::collections::HashMap;
use std::sync::LazyLock;
use std::sync::Mutex;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static g_pps: LazyLock<Mutex<HashMap<i64, bool>>> = LazyLock::new(|| Mutex::new(HashMap::from([])));
fn main() {
    unsafe {
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        unsafe fn pow10(mut exp: i64) -> i64 {
    let mut n: i64 = 1;
    let mut i: i64 = 0;
    while (i < exp) {
        n = (n * 10);
        i = (i + 1);
    }
    return n
};
        unsafe fn totient(mut n: i64) -> i64 {
    let mut tot: i64 = n;
    let mut nn: i64 = n;
    let mut i: i64 = 2;
    while ((i * i) <= nn) {
        if ((nn % i) == 0) {
            while ((nn % i) == 0) {
                nn = (nn / i);
            }
            tot = (tot - (tot / i));
        }
        if (i == 2) {
            i = 1;
        }
        i = (i + 2);
    }
    if (nn > 1) {
        tot = (tot - (tot / nn));
    }
    return tot
};
        static g_pps: LazyLock<Mutex<HashMap<i64, bool>>> = LazyLock::new(|| Mutex::new(HashMap::from([])));;
        unsafe fn getPerfectPowers(mut maxExp: i64) {
    let mut upper: i64 = pow10(maxExp);
    let mut i: i64 = 2;
    while ((i * i) < upper) {
        let mut p: i64 = i;
        loop {
            p = (p * i);
            if (p >= upper) {
                break
            }
            { let mut _map = g_pps.lock().unwrap(); let _val = true; _map.insert(p.clone(), _val); };
        }
        i = (i + 1);
    }
};
        unsafe fn getAchilles(mut minExp: i64, mut maxExp: i64) -> HashMap<i64, bool> {
    let mut lower: i64 = pow10(minExp);
    let mut upper: i64 = pow10(maxExp);
    let mut achilles: HashMap<i64, bool> = HashMap::from([]);
    let mut b: i64 = 1;
    while (((b * b) * b) < upper) {
        let mut b3: i64 = ((b * b) * b);
        let mut a: i64 = 1;
        loop {
            let mut p: i64 = ((b3 * a) * a);
            if (p >= upper) {
                break
            }
            if (p >= lower) {
                if !g_pps.lock().unwrap().contains_key(&p) {
                    achilles.insert(p.clone(), true);
                }
            }
            a = (a + 1);
        }
        b = (b + 1);
    }
    return achilles
};
        unsafe fn sortInts(mut xs: Vec<i64>) -> Vec<i64> {
    let mut res: Vec<i64> = vec![];
    let mut tmp: Vec<i64> = xs;
    while ((tmp.len() as i64) > 0) {
        let mut min: i64 = tmp[0 as usize];
        let mut idx: i64 = 0;
        let mut i: i64 = 1;
        while (i < (tmp.len() as i64)) {
            if (tmp[i as usize] < min) {
                min = tmp[i as usize];
                idx = i;
            }
            i = (i + 1);
        }
        res = { let mut v = res.clone(); v.extend(vec![min]); v };
        let mut out: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < (tmp.len() as i64)) {
            if (j != idx) {
                out = { let mut v = out.clone(); v.extend(vec![tmp[j as usize]]); v };
            }
            j = (j + 1);
        }
        tmp = out.clone();
    }
    return res
};
        unsafe fn pad(mut n: i64, mut width: i64) -> String {
    let mut s = n.to_string();
    while ((s.len() as i64) < width) {
        s = format!("{}{}", " ", s);
    }
    return s.clone()
};
        unsafe fn mochi_main() {
    let mut maxDigits: i64 = 15;
    getPerfectPowers(5);
    let mut achSet: HashMap<i64, bool> = getAchilles(1, 5);
    let mut ach: Vec<i64> = vec![];
    for k in achSet.keys() {
        ach = { let mut v = ach.clone(); v.extend(vec![k]); v };
    }
    ach = sortInts(ach.clone());
    println!("{}", "First 50 Achilles numbers:");
    let mut i: i64 = 0;
    while (i < 50) {
        let mut line: String = String::from("").clone();
        let mut j: i64 = 0;
        while (j < 10) {
            line = format!("{}{}", line, pad(ach[i as usize], 4));
            if (j < 9) {
                line = format!("{}{}", line, " ");
            }
            i = (i + 1);
            j = (j + 1);
        }
        println!("{}", line);
    }
    println!("{}", "\nFirst 30 strong Achilles numbers:");
    let mut strong: Vec<i64> = vec![];
    let mut count: i64 = 0;
    let mut idx: i64 = 0;
    while (count < 30) {
        let mut tot: i64 = totient(ach[idx as usize]);
        if achSet.contains_key(&tot) {
            strong = { let mut v = strong.clone(); v.extend(vec![ach[idx as usize]]); v };
            count = (count + 1);
        }
        idx = (idx + 1);
    }
    i = 0;
    while (i < 30) {
        let mut line: String = String::from("").clone();
        let mut j: i64 = 0;
        while (j < 10) {
            line = format!("{}{}", line, pad(strong[i as usize], 5));
            if (j < 9) {
                line = format!("{}{}", line, " ");
            }
            i = (i + 1);
            j = (j + 1);
        }
        println!("{}", line);
    }
    println!("{}", "\nNumber of Achilles numbers with:");
    let mut counts: Vec<i64> = vec![1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383];
    let mut d: i64 = 2;
    while (d <= maxDigits) {
        let mut c: i64 = counts[(d - 2) as usize];
        println!("{}", format!("{}{}", format!("{}{}", pad(d, 2), " digits: "), c.to_string()));
        d = (d + 1);
    }
};
        mochi_main();
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = (_end_mem - _start_mem);
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
