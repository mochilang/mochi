// Generated by Mochi transpiler v0.10.55 on 2025-08-02 18:10 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn int(x: i64) -> i64 { x }
fn main() {
        let _start_mem: i64 = _mem();
    let _start: i64 = _now();
    fn bigTrim(mut a: Vec<i64>) -> Vec<i64> {
    let mut n = (a.len() as i64);
    while ((n > 1) && (a[(n - 1) as usize] == 0)) {
        a = a[0 as usize..(n - 1) as usize].to_vec();
        n = (n - 1);
    }
    return a
};
    fn bigFromInt(mut x: i64) -> Vec<i64> {
    if (x == 0) {
        return vec![0]
    }
    let mut digits: Vec<i64> = vec![];
    let mut n: i64 = x;
    while (n > 0) {
        digits = { let mut _v = digits.clone(); _v.push((n % 10)); _v };
        n = (n / 10);
    }
    return digits
};
    fn bigCmp(a: &mut Vec<i64>, b: &mut Vec<i64>) -> i64 {
    if ((a.len() as i64) > (b.len() as i64)) {
        return 1
    }
    if ((a.len() as i64) < (b.len() as i64)) {
        return -1
    }
    let mut i = ((a.len() as i64) - 1);
    while (i >= 0) {
        if (a[i as usize] > b[i as usize]) {
            return 1
        }
        if (a[i as usize] < b[i as usize]) {
            return -1
        }
        i = (i - 1);
    }
    return 0
};
    fn bigAdd(mut a: Vec<i64>, mut b: Vec<i64>) -> Vec<i64> {
    let mut res: Vec<i64> = vec![];
    let mut carry: i64 = 0;
    let mut i: i64 = 0;
    while (((i < (a.len() as i64)) || (i < (b.len() as i64))) || (carry > 0)) {
        let mut av: i64 = 0;
        if (i < (a.len() as i64)) {
            av = a[i as usize];
        }
        let mut bv: i64 = 0;
        if (i < (b.len() as i64)) {
            bv = b[i as usize];
        }
        let mut s: i64 = ((av + bv) + carry);
        res = { let mut _v = res.clone(); _v.push((s % 10)); _v };
        carry = (s / 10);
        i = (i + 1);
    }
    return bigTrim(res.clone())
};
    fn bigSub(mut a: Vec<i64>, mut b: Vec<i64>) -> Vec<i64> {
    let mut res: Vec<i64> = vec![];
    let mut borrow: i64 = 0;
    let mut i: i64 = 0;
    while (i < (a.len() as i64)) {
        let mut av: i64 = a[i as usize];
        let mut bv: i64 = 0;
        if (i < (b.len() as i64)) {
            bv = b[i as usize];
        }
        let mut diff: i64 = ((av - bv) - borrow);
        if (diff < 0) {
            diff = (diff + 10);
            borrow = 1;
        } else {
            borrow = 0;
        }
        res = { let mut _v = res.clone(); _v.push(diff); _v };
        i = (i + 1);
    }
    return bigTrim(res.clone())
};
    fn bigMulSmall(mut a: Vec<i64>, mut m: i64) -> Vec<i64> {
    if (m == 0) {
        return vec![0]
    }
    let mut res: Vec<i64> = vec![];
    let mut carry: i64 = 0;
    let mut i: i64 = 0;
    while (i < (a.len() as i64)) {
        let mut prod: i64 = ((a[i as usize] * m) + carry);
        res = { let mut _v = res.clone(); _v.push((prod % 10)); _v };
        carry = (prod / 10);
        i = (i + 1);
    }
    while (carry > 0) {
        res = { let mut _v = res.clone(); _v.push((carry % 10)); _v };
        carry = (carry / 10);
    }
    return bigTrim(res.clone())
};
    fn bigMulBig(mut a: Vec<i64>, mut b: Vec<i64>) -> Vec<i64> {
    let mut res: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < ((a.len() as i64) + (b.len() as i64))) {
        res = { let mut _v = res.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    i = 0;
    while (i < (a.len() as i64)) {
        let mut carry: i64 = 0;
        let mut j: i64 = 0;
        while (j < (b.len() as i64)) {
            let mut idx: i64 = (i + j);
            let mut prod: i64 = ((res[idx as usize] + (a[i as usize] * b[j as usize])) + carry);
            res[idx as usize] = (prod % 10);
            carry = (prod / 10);
            j = (j + 1);
        }
        let mut idx: i64 = (i + (b.len() as i64));
        while (carry > 0) {
            let mut prod: i64 = (res[idx as usize] + carry);
            res[idx as usize] = (prod % 10);
            carry = (prod / 10);
            idx = (idx + 1);
        }
        i = (i + 1);
    }
    return bigTrim(res.clone())
};
    fn bigMulPow10(mut a: Vec<i64>, mut k: i64) -> Vec<i64> {
    let mut i: i64 = 0;
    while (i < k) {
        a = { let mut v = vec![0].clone(); v.extend(a); v };
        i = (i + 1);
    }
    return a
};
    fn bigDivSmall(mut a: Vec<i64>, mut m: i64) -> Vec<i64> {
    let mut res: Vec<i64> = vec![];
    let mut rem: i64 = 0;
    let mut i = ((a.len() as i64) - 1);
    while (i >= 0) {
        let mut cur: i64 = ((rem * 10) + a[i as usize]);
        let mut q: i64 = (cur / m);
        rem = (cur % m);
        res = { let mut v = vec![q].clone(); v.extend(res); v };
        i = (i - 1);
    }
    return bigTrim(res.clone())
};
    fn bigToString(mut a: Vec<i64>) -> String {
    let mut s: String = String::from("").clone();
    let mut i = ((a.len() as i64) - 1);
    while (i >= 0) {
        s = format!("{}{}", s, a[i as usize].to_string());
        i = (i - 1);
    }
    return s.clone()
};
    fn repeat(ch: &str, mut n: i64) -> String {
    let mut s: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < n) {
        s = format!("{}{}", s, ch);
        i = (i + 1);
    }
    return s.clone()
};
    fn sortInts(mut xs: Vec<i64>) -> Vec<i64> {
    let mut res: Vec<i64> = vec![];
    let mut tmp: Vec<i64> = xs;
    while ((tmp.len() as i64) > 0) {
        let mut min: i64 = tmp[0 as usize];
        let mut idx: i64 = 0;
        let mut i: i64 = 1;
        while (i < (tmp.len() as i64)) {
            if (tmp[i as usize] < min) {
                min = tmp[i as usize];
                idx = i;
            }
            i = (i + 1);
        }
        res = { let mut v = res.clone(); v.extend(vec![min]); v };
        let mut out: Vec<i64> = vec![];
        let mut j: i64 = 0;
        while (j < (tmp.len() as i64)) {
            if (j != idx) {
                out = { let mut v = out.clone(); v.extend(vec![tmp[j as usize]]); v };
            }
            j = (j + 1);
        }
        tmp = out.clone();
    }
    return res
};
    fn primesUpTo(mut n: i64) -> Vec<i64> {
    let mut sieve: Vec<bool> = vec![];
    let mut i: i64 = 0;
    while (i <= n) {
        sieve = { let mut _v = sieve.clone(); _v.push(true); _v };
        i = (i + 1);
    }
    let mut p: i64 = 2;
    while ((p * p) <= n) {
        if sieve[p as usize] {
            let mut m: i64 = (p * p);
            while (m <= n) {
                sieve[m as usize] = false;
                m = (m + p);
            }
        }
        p = (p + 1);
    }
    let mut res: Vec<i64> = vec![];
    let mut x: i64 = 2;
    while (x <= n) {
        if sieve[x as usize] {
            res = { let mut _v = res.clone(); _v.push(x); _v };
        }
        x = (x + 1);
    }
    return res
};
    fn factorialExp(mut n: i64, mut primes: Vec<i64>) -> HashMap<String, i64> {
    let mut m: HashMap<String, i64> = HashMap::new();
    for p in primes.clone() {
        if (p > n) {
            break
        }
        let mut t: i64 = n;
        let mut e: i64 = 0;
        while (t > 0) {
            t = (t / p);
            e = (e + t);
        }
        m.insert(p.to_string().clone(), e);
    }
    return m
};
    fn factorSmall(mut x: i64, mut primes: Vec<i64>) -> HashMap<String, i64> {
    let mut f: HashMap<String, i64> = HashMap::new();
    let mut n: i64 = x;
    for p in primes.clone() {
        if ((p * p) > n) {
            break
        }
        let mut c: i64 = 0;
        while ((n % p) == 0) {
            c = (c + 1);
            n = (n / p);
        }
        if (c > 0) {
            f.insert(p.to_string().clone(), c);
        }
    }
    if (n > 1) {
        f.insert(n.to_string().clone(), ({ f.get(&n.to_string()).cloned().unwrap_or(0) } + 1));
    }
    return f
};
    fn computeIP(mut n: i64, mut primes: Vec<i64>) -> Vec<i64> {
    let mut exps: HashMap<String, i64> = factorialExp((6 * n), primes.clone());
    let mut r#fn: HashMap<String, i64> = factorialExp(n, primes.clone());
    for k in r#fn.keys() {
        exps.insert(k.clone(), ({ exps.get(k.as_str()).cloned().unwrap_or(0) } - (6 * r#fn[k.as_str()])));
    }
    exps.insert(String::from("2"), ({ exps.get("2").cloned().unwrap_or(0) } + 5));
    let mut t2: i64 = ((((532 * n) * n) + (126 * n)) + 9);
    let mut ft2: HashMap<String, i64> = factorSmall(t2, primes.clone());
    for k in ft2.keys() {
        exps.insert(k.clone(), ({ exps.get(k.as_str()).cloned().unwrap_or(0) } + ft2[k.as_str()]));
    }
    exps.insert(String::from("3"), ({ exps.get("3").cloned().unwrap_or(0) } - 1));
    let mut keys: Vec<i64> = vec![];
    for k in exps.keys() {
        keys = { let mut _v = keys.clone(); _v.push({ let n: i64 = k.parse().unwrap(); n }); _v };
    }
    keys = sortInts(keys.clone());
    let mut res: Vec<i64> = bigFromInt(1);
    for p in keys.clone() {
        let mut e: i64 = exps.get(p.to_string().as_str()).cloned().unwrap_or_default();
        let mut i: i64 = 0;
        while (i < e) {
            res = bigMulSmall(res.clone(), p);
            i = (i + 1);
        }
    }
    return res
};
    fn formatTerm(mut ip: Vec<i64>, mut pw: i64) -> String {
    let mut s: String = bigToString(ip.clone()).clone();
    if (pw >= (s.len() as i64)) {
        let mut frac: String = format!("{}{}", repeat(&"0", (pw - (s.len() as i64))), s).clone();
        if ((frac.len() as i64) < 33) {
            frac = format!("{}{}", frac, repeat(&"0", (33 - (frac.len() as i64))));
        }
        return format!("{}{}", "0.", { let tmp = &frac; tmp.chars().skip(0 as usize).take((33 - 0) as usize).collect::<String>() })
    }
    let mut intpart: String = { let tmp = &s; tmp.chars().skip(0 as usize).take((((s.len() as i64) - pw) - 0) as usize).collect::<String>() }.clone();
    let mut frac: String = { let tmp = &s; tmp.chars().skip(((s.len() as i64) - pw) as usize).take(((s.len() as i64) - ((s.len() as i64) - pw)) as usize).collect::<String>() }.clone();
    if ((frac.len() as i64) < 33) {
        frac = format!("{}{}", frac, repeat(&"0", (33 - (frac.len() as i64))));
    }
    return format!("{}{}", format!("{}{}", intpart, "."), { let tmp = &frac; tmp.chars().skip(0 as usize).take((33 - 0) as usize).collect::<String>() }).clone()
};
    fn bigAbsDiff(mut a: Vec<i64>, mut b: Vec<i64>) -> Vec<i64> {
    if (bigCmp(&mut a, &mut b) >= 0) {
        return bigSub(a.clone(), b.clone())
    }
    return bigSub(b.clone(), a.clone())
};
    fn mochi_main() {
    let mut primes: Vec<i64> = primesUpTo(2000);
    println!("{}", "N                               Integer Portion  Pow  Nth Term (33 dp)");
    let mut line: String = repeat(&"-", 89).clone();
    println!("{}", line);
    let mut sum: Vec<i64> = bigFromInt(0);
    let mut prev: Vec<i64> = bigFromInt(0);
    let mut denomPow: i64 = 0;
    let mut n: i64 = 0;
    loop {
        let mut ip: Vec<i64> = computeIP(n, primes.clone());
        let mut pw: i64 = ((6 * n) + 3);
        if (pw > denomPow) {
            sum = bigMulPow10(sum.clone(), (pw - denomPow));
            prev = bigMulPow10(prev.clone(), (pw - denomPow));
            denomPow = pw;
        }
        if (n < 10) {
            let mut termStr: String = formatTerm(ip.clone(), pw).clone();
            let mut ipStr: String = bigToString(ip.clone()).clone();
            while ((ipStr.len() as i64) < 44) {
                ipStr = format!("{}{}", " ", ipStr);
            }
            let mut pwStr = (-pw).to_string();
            while ((pwStr.len() as i64) < 3) {
                pwStr = format!("{}{}", " ", pwStr);
            }
            let mut padTerm: String = termStr.clone();
            while ((padTerm.len() as i64) < 35) {
                padTerm = format!("{}{}", padTerm, " ");
            }
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", n.to_string(), "  "), ipStr), "  "), pwStr), "  "), padTerm));
        }
        sum = bigAdd(sum.clone(), ip.clone());
        let mut diff: Vec<i64> = bigAbsDiff(sum.clone(), prev.clone());
        if ((denomPow >= 70) && (bigCmp(&mut diff, &mut bigMulPow10(bigFromInt(1), (denomPow - 70))) < 0)) {
            break
        }
        prev = sum.clone();
        n = (n + 1);
    }
    let mut precision: i64 = 70;
    let mut target: Vec<i64> = bigMulPow10(bigFromInt(1), (denomPow + (2 * precision)));
    let mut low: Vec<i64> = bigFromInt(0);
    let mut high: Vec<i64> = bigMulPow10(bigFromInt(1), (precision + 1));
    while (bigCmp(&mut low, &mut bigSub(high.clone(), bigFromInt(1))) < 0) {
        let mut mid: Vec<i64> = bigDivSmall(bigAdd(low.clone(), high.clone()), 2);
        let mut prod: Vec<i64> = bigMulBig(bigMulBig(mid.clone(), mid.clone()), sum.clone());
        if (bigCmp(&mut prod, &mut target) <= 0) {
            low = mid.clone();
        } else {
            high = bigSub(mid.clone(), bigFromInt(1));
        }
    }
    let mut piInt: Vec<i64> = low;
    let mut piStr: String = bigToString(piInt.clone()).clone();
    if ((piStr.len() as i64) <= precision) {
        piStr = format!("{}{}", repeat(&"0", ((precision - (piStr.len() as i64)) + 1)), piStr);
    }
    let mut out: String = format!("{}{}", format!("{}{}", { let tmp = &piStr; tmp.chars().skip(0 as usize).take((((piStr.len() as i64) - precision) - 0) as usize).collect::<String>() }, "."), { let tmp = &piStr; tmp.chars().skip(((piStr.len() as i64) - precision) as usize).take(((piStr.len() as i64) - ((piStr.len() as i64) - precision)) as usize).collect::<String>() }).clone();
    println!("{}", "");
    println!("{}", "Pi to 70 decimal places is:");
    println!("{}", out);
};
    mochi_main();
    let _end: i64 = _now();
    let _end_mem: i64 = _mem();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = (_end_mem - _start_mem);
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
