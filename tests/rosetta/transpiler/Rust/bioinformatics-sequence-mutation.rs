// Generated by Mochi transpiler v0.10.42 on 2025-07-27 17:23 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start_mem: i64 = _mem();
    let _start: i64 = _now();
    fn randInt(mut s: i64, mut n: i64) -> Vec<i64> {
    let next: i64 = (((s * 1664525) + 1013904223) % 2147483647);
    return vec![next, (next % n)]
};
    fn padLeft(mut s: String, mut w: i64) -> String {
    let mut res = String::from("");
    let mut n: i64 = (w - (s.len() as i64));
    while (n > 0) {
        res = format!("{}{}", res, " ");
        n = (n - 1);
    }
    return format!("{}{}", res, s).clone()
};
    fn makeSeq(mut s: i64, mut le: i64) -> Vec<f64> {
    let bases = String::from("ACGT");
    let mut out = String::from("");
    let mut i: i64 = 0;
    while (i < le) {
        let mut r: Vec<i64> = randInt(s, 4);
        s = r[0 as usize];
        let idx: i64 = r[1 as usize];
        out = format!("{}{}", out, { let tmp = &bases; tmp.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>() });
        i = (i + 1);
    }
    return vec![s, out]
};
    fn mutate(mut s: i64, mut dna: String, mut w: Vec<i64>) -> Vec<f64> {
    let bases = String::from("ACGT");
    let le = (dna.len() as i64);
    let mut r: Vec<i64> = randInt(s, le);
    s = r[0 as usize];
    let p: i64 = r[1 as usize];
    r = randInt(s, 300);
    s = r[0 as usize];
    let x: i64 = r[1 as usize];
    let mut arr: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < le) {
        arr = { let mut _v = arr.clone(); _v.push({ let tmp = &dna; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.to_string()); _v };
        i = (i + 1);
    }
    if (x < w[0 as usize]) {
        r = randInt(s, 4);
        s = r[0 as usize];
        let idx: i64 = r[1 as usize];
        let b: String = { let tmp = &bases; tmp.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>() }.clone();
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "  Change @", padLeft(p.to_string().to_string(), 3)), " '"), arr[p as usize].clone()), "' to '"), b), "'"));
        arr[p as usize] = b;
    } else if (x < (w[0 as usize] + w[1 as usize])) {
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "  Delete @", padLeft(p.to_string().to_string(), 3)), " '"), arr[p as usize].clone()), "'"));
        let mut j: i64 = p;
        while (j < ((arr.len() as i64) - 1)) {
            arr[j as usize] = arr[(j + 1) as usize].clone();
            j = (j + 1);
        }
        arr = arr[0 as usize..((arr.len() as i64) - 1) as usize].to_vec();
    } else {
        r = randInt(s, 4);
        s = r[0 as usize];
        let idx2: i64 = r[1 as usize];
        let b: String = { let tmp = &bases; tmp.chars().skip(idx2 as usize).take(((idx2 + 1) - idx2) as usize).collect::<String>() }.clone();
        arr = { let mut _v = arr.clone(); _v.push("".to_string()); _v };
        let mut j = ((arr.len() as i64) - 1);
        while (j > p) {
            arr[j as usize] = arr[(j - 1) as usize].clone();
            j = (j - 1);
        }
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "  Insert @", padLeft(p.to_string().to_string(), 3)), " '"), b), "'"));
        arr[p as usize] = b;
    }
    let mut out = String::from("");
    i = 0;
    while (i < (arr.len() as i64)) {
        out = format!("{}{}", out, arr[i as usize].clone());
        i = (i + 1);
    }
    return vec![s, out]
};
    fn prettyPrint(mut dna: String, mut rowLen: i64) {
    println!("{}", "SEQUENCE:");
    let le = (dna.len() as i64);
    let mut i: i64 = 0;
    while (i < le) {
        let mut k: i64 = (i + rowLen);
        if (k > le) {
            k = le;
        }
        println!("{}", format!("{}{}", format!("{}{}", padLeft(i.to_string().to_string(), 5), ": "), dna[i as usize..k as usize].to_string()));
        i = (i + rowLen);
    }
    let mut a: i64 = 0;
    let mut c: i64 = 0;
    let mut g: i64 = 0;
    let mut t: i64 = 0;
    let mut idx: i64 = 0;
    while (idx < le) {
        let ch: String = { let tmp = &dna; tmp.chars().skip(idx as usize).take(((idx + 1) - idx) as usize).collect::<String>() }.clone();
        if (ch.as_str() == "A") {
            a = (a + 1);
        } else {
            if (ch.as_str() == "C") {
                c = (c + 1);
            } else {
                if (ch.as_str() == "G") {
                    g = (g + 1);
                } else {
                    if (ch.as_str() == "T") {
                        t = (t + 1);
                    }
                }
            }
        }
        idx = (idx + 1);
    }
    println!("{}", "");
    println!("{}", "BASE COUNT:");
    println!("{}", format!("{}{}", "    A: ", padLeft(a.to_string().to_string(), 3)));
    println!("{}", format!("{}{}", "    C: ", padLeft(c.to_string().to_string(), 3)));
    println!("{}", format!("{}{}", "    G: ", padLeft(g.to_string().to_string(), 3)));
    println!("{}", format!("{}{}", "    T: ", padLeft(t.to_string().to_string(), 3)));
    println!("{}", "    ------");
    println!("{}", format!("{}{}", "    Î£: ", le.to_string()));
    println!("{}", "    ======");
};
    fn wstring(mut w: Vec<i64>) -> String {
    return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "  Change: ", w[0 as usize].to_string()), "\n  Delete: "), w[1 as usize].to_string()), "\n  Insert: "), w[2 as usize].to_string()), "\n").clone()
};
    fn mochi_main() {
    let mut seed: i64 = 1;
    let mut res: Vec<f64> = makeSeq(seed, 250);
    seed = res[0 as usize];
    let mut dna: String = res[1 as usize].to_string().clone();
    prettyPrint(dna, 50);
    let muts: i64 = 10;
    let mut w: Vec<i64> = vec![100, 100, 100];
    println!("{}", "\nWEIGHTS (ex 300):");
    println!("{}", wstring(w.clone()));
    println!("{}", format!("{}{}", format!("{}{}", "MUTATIONS (", muts.to_string()), "):"));
    let mut i: i64 = 0;
    while (i < muts) {
        res = mutate(seed, dna, w.clone());
        seed = res[0 as usize];
        dna = res[1 as usize].to_string();
        i = (i + 1);
    }
    println!("{}", "");
    prettyPrint(dna, 50);
};
    mochi_main();
    let _end: i64 = _now();
    let _end_mem: i64 = _mem();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = (_end_mem - _start_mem);
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
