// Generated by Mochi transpiler v0.10.56 on 2025-08-04 06:52 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start: i64 = _now();
    fn toUnsigned16(mut n: i64) -> i64 {
    let mut u: i64 = n;
    if (u < 0) {
        u = (u + 65536);
    }
    return (u % 65536)
};
    fn bin16(mut n: i64) -> String {
    let mut u: i64 = toUnsigned16(n);
    let mut bits: String = String::from("").clone();
    let mut mask: i64 = 32768;
    for i in 0..16 {
        if (u >= mask) {
            bits = format!("{}{}", bits, "1");
            u = (u - mask);
        } else {
            bits = format!("{}{}", bits, "0");
        }
        mask = (mask / 2);
    }
    return bits.clone()
};
    fn bit_and(mut a: i64, mut b: i64) -> i64 {
    let mut ua: i64 = toUnsigned16(a);
    let mut ub: i64 = toUnsigned16(b);
    let mut res: i64 = 0;
    let mut bit: i64 = 1;
    for i in 0..16 {
        if (((ua % 2) == 1) && ((ub % 2) == 1)) {
            res = (res + bit);
        }
        ua = (ua / 2);
        ub = (ub / 2);
        bit = (bit * 2);
    }
    return res
};
    fn bit_or(mut a: i64, mut b: i64) -> i64 {
    let mut ua: i64 = toUnsigned16(a);
    let mut ub: i64 = toUnsigned16(b);
    let mut res: i64 = 0;
    let mut bit: i64 = 1;
    for i in 0..16 {
        if (((ua % 2) == 1) || ((ub % 2) == 1)) {
            res = (res + bit);
        }
        ua = (ua / 2);
        ub = (ub / 2);
        bit = (bit * 2);
    }
    return res
};
    fn bit_xor(mut a: i64, mut b: i64) -> i64 {
    let mut ua: i64 = toUnsigned16(a);
    let mut ub: i64 = toUnsigned16(b);
    let mut res: i64 = 0;
    let mut bit: i64 = 1;
    for i in 0..16 {
        let mut abit: i64 = (ua % 2);
        let mut bbit: i64 = (ub % 2);
        if (((abit == 1) && (bbit == 0)) || ((abit == 0) && (bbit == 1))) {
            res = (res + bit);
        }
        ua = (ua / 2);
        ub = (ub / 2);
        bit = (bit * 2);
    }
    return res
};
    fn bit_not(mut a: i64) -> i64 {
    let mut ua: i64 = toUnsigned16(a);
    return (65535 - ua)
};
    fn shl(mut a: i64, mut b: i64) -> i64 {
    let mut ua: i64 = toUnsigned16(a);
    let mut i: i64 = 0;
    while (i < b) {
        ua = ((ua * 2) % 65536);
        i = (i + 1);
    }
    return ua
};
    fn shr(mut a: i64, mut b: i64) -> i64 {
    let mut ua: i64 = toUnsigned16(a);
    let mut i: i64 = 0;
    while (i < b) {
        ua = (ua / 2);
        i = (i + 1);
    }
    return ua
};
    fn las(mut a: i64, mut b: i64) -> i64 {
    return shl(a, b)
};
    fn ras(mut a: i64, mut b: i64) -> i64 {
    let mut val: i64 = a;
    let mut i: i64 = 0;
    while (i < b) {
        if (val >= 0) {
            val = (val / 2);
        } else {
            val = ((val - 1) / 2);
        }
        i = (i + 1);
    }
    return toUnsigned16(val)
};
    fn rol(mut a: i64, mut b: i64) -> i64 {
    let mut ua: i64 = toUnsigned16(a);
    let mut left: i64 = shl(ua, b);
    let mut right: i64 = shr(ua, (16 - b));
    return toUnsigned16((left + right))
};
    fn ror(mut a: i64, mut b: i64) -> i64 {
    let mut ua: i64 = toUnsigned16(a);
    let mut right: i64 = shr(ua, b);
    let mut left: i64 = shl(ua, (16 - b));
    return toUnsigned16((left + right))
};
    fn bitwise(mut a: i64, mut b: i64) {
    println!("{}", format!("{}{}", "a:   ", bin16(a)));
    println!("{}", format!("{}{}", "b:   ", bin16(b)));
    println!("{}", format!("{}{}", "and: ", bin16(bit_and(a, b))));
    println!("{}", format!("{}{}", "or:  ", bin16(bit_or(a, b))));
    println!("{}", format!("{}{}", "xor: ", bin16(bit_xor(a, b))));
    println!("{}", format!("{}{}", "not: ", bin16(bit_not(a))));
    if (b < 0) {
        println!("{}", "Right operand is negative, but all shifts require an unsigned right operand (shift distance).");
        return Default::default()
    }
    println!("{}", format!("{}{}", "shl: ", bin16(shl(a, b))));
    println!("{}", format!("{}{}", "shr: ", bin16(shr(a, b))));
    println!("{}", format!("{}{}", "las: ", bin16(las(a, b))));
    println!("{}", format!("{}{}", "ras: ", bin16(ras(a, b))));
    println!("{}", format!("{}{}", "rol: ", bin16(rol(a, b))));
    println!("{}", format!("{}{}", "ror: ", bin16(ror(a, b))));
};
    bitwise(-460, 6);
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
