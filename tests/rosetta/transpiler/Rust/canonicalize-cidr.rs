// Generated by Mochi transpiler v0.10.57 on 2025-08-04 21:43 +0700
use std::collections::HashMap;
static mut g_tests: Vec<String> = Vec::new();
unsafe fn split(mut s: String, mut sep: String) -> Vec<String> {
    let mut parts: Vec<String> = vec![];
    let mut cur: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if ((((sep.len() as i64) > 0) && ((i + (sep.len() as i64)) <= (s.len() as i64))) && ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + (sep.len() as i64)) - i) as usize).collect::<String>() }.as_str() == sep.as_str())) {
            parts = { let mut _v = parts.clone(); _v.push(cur.clone()); _v };
            cur = String::from("");
            i = (i + (sep.len() as i64));
        } else {
            cur = format!("{}{}", cur, s.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>());
            i = (i + 1);
        }
    }
    parts = { let mut _v = parts.clone(); _v.push(cur.clone()); _v };
    return parts
}

unsafe fn join(xs: &mut Vec<String>, sep: &str) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        if (i > 0) {
            res = format!("{}{}", res, sep);
        }
        res = format!("{}{}", res, xs[i as usize].clone());
        i = (i + 1);
    }
    return res.clone()
}

unsafe fn repeat(ch: &str, mut n: i64) -> String {
    let mut out: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < n) {
        out = format!("{}{}", out, ch);
        i = (i + 1);
    }
    return out.clone()
}

unsafe fn parseIntStr(mut str: String) -> i64 {
    let mut i: i64 = 0;
    let mut neg: bool = false;
    if (((str.len() as i64) > 0) && (str.chars().skip(0 as usize).take((1 - 0) as usize).collect::<String>().as_str() == "-")) {
        neg = true;
        i = 1;
    }
    let mut n: i64 = 0;
    let mut digits = HashMap::from([(String::from("0"), 0), (String::from("1"), 1), (String::from("2"), 2), (String::from("3"), 3), (String::from("4"), 4), (String::from("5"), 5), (String::from("6"), 6), (String::from("7"), 7), (String::from("8"), 8), (String::from("9"), 9)]);
    while (i < (str.len() as i64)) {
        n = ((n * 10) + digits.get(str.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>().as_str()).cloned().unwrap_or_default());
        i = (i + 1);
    }
    if neg {
        n = -n;
    }
    return n
}

unsafe fn toBinary(mut n: i64, mut bits: i64) -> String {
    let mut b: String = String::from("").clone();
    let mut val: i64 = n;
    let mut i: i64 = 0;
    while (i < bits) {
        b = format!("{}{}", (val % 2).to_string(), b).to_string();
        val = (val / 2);
        i = (i + 1);
    }
    return b.clone()
}

unsafe fn binToInt(mut bits: String) -> i64 {
    let mut n: i64 = 0;
    let mut i: i64 = 0;
    while (i < (bits.len() as i64)) {
        n = ((n * 2) + { let s = bits.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>(); i64::from_str_radix(&s, 10 as u32).unwrap_or(0) });
        i = (i + 1);
    }
    return n
}

unsafe fn padRight(s: &str, mut width: i64) -> String {
    let mut out: String = s.to_string().clone();
    while ((out.len() as i64) < width) {
        out = format!("{}{}", out, " ");
    }
    return out.clone()
}

unsafe fn canonicalize(cidr: &str) -> String {
    let mut parts: Vec<String> = cidr.split("/").map(|x| x.to_string()).collect::<Vec<String>>();
    let mut dotted: String = parts[0 as usize].clone().clone();
    let mut size = { let s = parts[1 as usize].clone(); i64::from_str_radix(&s, 10 as u32).unwrap_or(0) };
    let mut binParts: Vec<String> = vec![];
    for p in dotted.split(".").map(|x| x.to_string()).collect::<Vec<String>>() {
        binParts = { let mut _v = binParts.clone(); _v.push(toBinary({ let s = p; i64::from_str_radix(&s, 10 as u32).unwrap_or(0) }, 8)); _v };
    }
    let mut binary: String = join(&mut binParts, &"").clone();
    binary = format!("{}{}", binary.chars().skip(0 as usize).take((size - 0) as usize).collect::<String>(), repeat(&"0", (32 - size)));
    let mut canonParts: Vec<String> = vec![];
    let mut i: i64 = 0;
    while (i < (binary.len() as i64)) {
        canonParts = { let mut _v = canonParts.clone(); _v.push(binToInt(binary.chars().skip(i as usize).take(((i + 8) - i) as usize).collect::<String>()).to_string().to_string()); _v };
        i = (i + 8);
    }
    return format!("{}{}", format!("{}{}", join(&mut canonParts, &"."), "/"), parts[1 as usize].clone()).clone()
}

fn main() {
    unsafe {
        g_tests = vec![String::from("87.70.141.1/22"), String::from("36.18.154.103/12"), String::from("62.62.197.11/29"), String::from("67.137.119.181/4"), String::from("161.214.74.21/24"), String::from("184.232.176.184/18")];
        for t in g_tests.clone().iter().cloned() {
            println!("{}", format!("{}{}", format!("{}{}", padRight(&t, 18), " -> "), canonicalize(&t)));
        }
    }
}
