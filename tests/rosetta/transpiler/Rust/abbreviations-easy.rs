// Generated by Mochi transpiler v0.10.40 on 2025-07-26 00:08 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start_mem: i64 = _mem();
    let _start: i64 = _now();
    fn fields(mut s: String) -> Vec<String> {
    let mut words: Vec<String> = vec![];
    let mut cur = String::from("");
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let ch: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (((ch.as_str() == " ") || (ch.as_str() == "\n")) || (ch.as_str() == "\t")) {
            if ((cur.len() as i64) > 0) {
                words = { let mut v = words.clone(); v.push(String::from(cur)); v };
                cur = String::from("");
            }
        } else {
            cur = format!("{}{}", cur, ch);
        }
        i = (i + 1);
    }
    if ((cur.len() as i64) > 0) {
        words = { let mut v = words.clone(); v.push(String::from(cur)); v };
    }
    return words
};
    fn padRight(mut s: String, mut width: i64) -> String {
    let mut out: String = s.clone();
    let mut i = (s.len() as i64);
    while (i < width) {
        out = format!("{}{}", out, " ");
        i = (i + 1);
    }
    return out.clone()
};
    fn join(mut xs: Vec<String>, mut sep: String) -> String {
    let mut res = String::from("");
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        if (i > 0) {
            res = format!("{}{}", res, sep);
        }
        res = format!("{}{}", res, xs[i as usize].clone());
        i = (i + 1);
    }
    return res.clone()
};
    fn validate(mut commands: Vec<String>, mut words: Vec<String>, mut mins: Vec<i64>) -> Vec<String> {
    let mut results: Vec<String> = vec![];
    if ((words.len() as i64) == 0) {
        return results
    }
    let mut wi: i64 = 0;
    while (wi < (words.len() as i64)) {
        let w: String = words[wi as usize].clone().clone();
        let mut found: bool = false;
        let wlen = (w.len() as i64);
        let mut ci: i64 = 0;
        while (ci < (commands.len() as i64)) {
            let cmd: String = commands[ci as usize].clone().clone();
            if (((mins[ci as usize] != 0) && (wlen >= mins[ci as usize])) && (wlen <= (cmd.len() as i64))) {
                let c: String = (cmd.to_uppercase()).clone();
                let ww: String = (w.to_uppercase()).clone();
                if ({ let tmp = &c; tmp.chars().skip(0 as usize).take((wlen - 0) as usize).collect::<String>() }.as_str() == ww) {
                    results = { let mut v = results.clone(); v.push(String::from(c)); v };
                    found = true;
                    break
                }
            }
            ci = (ci + 1);
        }
        if !found {
            results = { let mut v = results.clone(); v.push(String::from("*error*")); v };
        }
        wi = (wi + 1);
    }
    return results
};
    fn mochi_main() {
    let table: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy ", "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find "), "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "), " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "), "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "), "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "), "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp ").clone();
    let mut commands: Vec<String> = fields(table);
    let mut mins: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (commands.len() as i64)) {
        let mut count: i64 = 0;
        let mut j: i64 = 0;
        let cmd: String = commands[i as usize].clone().clone();
        while (j < (cmd.len() as i64)) {
            let ch: String = { let tmp = &cmd; tmp.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>() }.clone();
            if ((ch.as_str() >= "A") && (ch.as_str() <= "Z")) {
                count = (count + 1);
            }
            j = (j + 1);
        }
        mins = { let mut v = mins.clone(); v.push(count); v };
        i = (i + 1);
    }
    let sentence = String::from("riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin");
    let mut words: Vec<String> = fields(sentence);
    let mut results: Vec<String> = validate(commands.clone(), words.clone(), mins.clone());
    let mut out1 = String::from("user words:  ");
    let mut k: i64 = 0;
    while (k < (words.len() as i64)) {
        out1 = format!("{}{}", format!("{}{}", out1, padRight(words[k as usize].clone(), (results[k as usize].clone().len() as i64))), " ");
        k = (k + 1);
    }
    println!("{}", out1);
    println!("{}", format!("{}{}", "full words:  ", join(results.clone(), String::from(" "))));
};
    mochi_main();
    let _end: i64 = _now();
    let _end_mem: i64 = _mem();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _end_mem;
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
