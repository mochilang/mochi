// Generated by Mochi transpiler v0.10.55 on 2025-08-03 10:22 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Point {
    x: f64,
    y: f64,
}
impl std::fmt::Display for Point {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"x\": {}", self.x)?;
        write!(f, ", ")?;
        write!(f, "\"y\": {}", self.y)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct QuadSpline {
    c0: f64,
    c1: f64,
    c2: f64,
}
impl std::fmt::Display for QuadSpline {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"c0\": {}", self.c0)?;
        write!(f, ", ")?;
        write!(f, "\"c1\": {}", self.c1)?;
        write!(f, ", ")?;
        write!(f, "\"c2\": {}", self.c2)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct QuadCurve {
    x: QuadSpline,
    y: QuadSpline,
}
impl std::fmt::Display for QuadCurve {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"x\": {}", self.x)?;
        write!(f, ", ")?;
        write!(f, "\"y\": {}", self.y)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct TestRes {
    exclude: bool,
    accept: bool,
    intersect: Point,
}
impl std::fmt::Display for TestRes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"exclude\": {}", self.exclude)?;
        write!(f, ", ")?;
        write!(f, "\"accept\": {}", self.accept)?;
        write!(f, ", ")?;
        write!(f, "\"intersect\": {}", self.intersect)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct WorkloadItem {
    p: i64,
    q: i64,
}
impl std::fmt::Display for WorkloadItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"p\": {}", self.p)?;
        write!(f, ", ")?;
        write!(f, "\"q\": {}", self.q)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    let _mem_start: i64 = _mem();
    fn absf(mut x: f64) -> f64 {
    if (x < 0.0) {
        return -x
    }
    return x
};
    fn maxf(mut a: f64, mut b: f64) -> f64 {
    if (a > b) {
        return a
    }
    return b
};
    fn minf(mut a: f64, mut b: f64) -> f64 {
    if (a < b) {
        return a
    }
    return b
};
    fn max3(mut a: f64, mut b: f64, mut c: f64) -> f64 {
    let mut m: f64 = a;
    if (b > m) {
        m = b;
    }
    if (c > m) {
        m = c;
    }
    return m
};
    fn min3(mut a: f64, mut b: f64, mut c: f64) -> f64 {
    let mut m: f64 = a;
    if (b < m) {
        m = b;
    }
    if (c < m) {
        m = c;
    }
    return m
};
    fn subdivideQuadSpline(q: &QuadSpline, mut t: f64) -> Vec<QuadSpline> {
    let mut s: f64 = (1.0 - t);
    let mut u: QuadSpline = QuadSpline {c0: q.c0, c1: 0.0, c2: 0.0};
    let mut v: QuadSpline = QuadSpline {c0: 0.0, c1: 0.0, c2: q.c2};
    u.c1 = ((s * q.c0) + (t * q.c1));
    v.c1 = ((s * q.c1) + (t * q.c2));
    u.c2 = ((s * u.c1) + (t * v.c1));
    v.c0 = u.c2;
    return vec![u, v]
};
    fn subdivideQuadCurve(q: &QuadCurve, mut t: f64) -> Vec<QuadCurve> {
    let mut xs: Vec<QuadSpline> = subdivideQuadSpline(&q.x.clone(), t);
    let mut ys: Vec<QuadSpline> = subdivideQuadSpline(&q.y.clone(), t);
    let mut u: QuadCurve = QuadCurve {x: xs[0 as usize].clone(), y: ys[0 as usize].clone()};
    let mut v: QuadCurve = QuadCurve {x: xs[1 as usize].clone(), y: ys[1 as usize].clone()};
    return vec![u, v]
};
    fn rectsOverlap(mut xa0: f64, mut ya0: f64, mut xa1: f64, mut ya1: f64, mut xb0: f64, mut yb0: f64, mut xb1: f64, mut yb1: f64) -> bool {
    return ((((xb0 <= xa1) && (xa0 <= xb1)) && (yb0 <= ya1)) && (ya0 <= yb1))
};
    fn testIntersect(p: &QuadCurve, q: &QuadCurve, mut tol: f64) -> TestRes {
    let mut pxmin: f64 = min3(p.x.clone().c0, p.x.clone().c1, p.x.clone().c2);
    let mut pymin: f64 = min3(p.y.clone().c0, p.y.clone().c1, p.y.clone().c2);
    let mut pxmax: f64 = max3(p.x.clone().c0, p.x.clone().c1, p.x.clone().c2);
    let mut pymax: f64 = max3(p.y.clone().c0, p.y.clone().c1, p.y.clone().c2);
    let mut qxmin: f64 = min3(q.x.clone().c0, q.x.clone().c1, q.x.clone().c2);
    let mut qymin: f64 = min3(q.y.clone().c0, q.y.clone().c1, q.y.clone().c2);
    let mut qxmax: f64 = max3(q.x.clone().c0, q.x.clone().c1, q.x.clone().c2);
    let mut qymax: f64 = max3(q.y.clone().c0, q.y.clone().c1, q.y.clone().c2);
    let mut res: TestRes = TestRes {exclude: true, accept: false, intersect: Point {x: 0.0, y: 0.0}};
    if rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax) {
        res.exclude = false;
        let mut xmin: f64 = maxf(pxmin, qxmin);
        let mut xmax: f64 = minf(pxmax, qxmax);
        if ((xmax - xmin) <= tol) {
            let mut ymin: f64 = maxf(pymin, qymin);
            let mut ymax: f64 = minf(pymax, qymax);
            if ((ymax - ymin) <= tol) {
                res.accept = true;
                res.intersect.x = (0.5 * (xmin + xmax));
                res.intersect.y = (0.5 * (ymin + ymax));
            }
        }
    }
    return res
};
    fn seemsToBeDuplicate(pts: &mut Vec<Point>, xy: &Point, mut spacing: f64) -> bool {
    let mut i: i64 = 0;
    while (i < (pts.len() as i64)) {
        let mut pt: Point = pts[i as usize].clone();
        if ((absf((pt.x - xy.x)) < spacing) && (absf((pt.y - xy.y)) < spacing)) {
            return true
        }
        i = (i + 1);
    }
    return false
};
    fn findIntersects(p: &QuadCurve, q: &QuadCurve, mut tol: f64, mut spacing: f64) -> Vec<Point> {
    let mut inters: Vec<Point> = vec![];
    let mut workload: Vec<HashMap<String, QuadCurve>> = vec![HashMap::from([(String::from("p"), p.clone()), (String::from("q"), q.clone())])];
    while ((workload.len() as i64) > 0) {
        let mut idx = ((workload.len() as i64) - 1);
        let mut work: HashMap<String, QuadCurve> = workload[idx as usize].clone();
        workload = workload[0 as usize..idx as usize].to_vec();
        let mut res: TestRes = testIntersect(&work.get("p").cloned().unwrap_or_default(), &work.get("q").cloned().unwrap_or_default(), tol);
        let mut excl: bool = res.exclude;
        let mut acc: bool = res.accept;
        let mut inter: Point = res.intersect;
        if acc {
            if !seemsToBeDuplicate(&mut inters, &inter, spacing) {
                inters = { let mut _v = inters.clone(); _v.push(inter.clone()); _v };
            }
        } else if !excl {
            let mut ps: Vec<QuadCurve> = subdivideQuadCurve(&work.get("p").cloned().unwrap_or_default(), 0.5);
            let mut qs: Vec<QuadCurve> = subdivideQuadCurve(&work.get("q").cloned().unwrap_or_default(), 0.5);
            let mut p0: QuadCurve = ps[0 as usize].clone();
            let mut p1: QuadCurve = ps[1 as usize].clone();
            let mut q0: QuadCurve = qs[0 as usize].clone();
            let mut q1: QuadCurve = qs[1 as usize].clone();
            let mut p0a: QuadCurve = p0.clone();
            let mut q0a: QuadCurve = q0.clone();
            let mut p1a: QuadCurve = p1.clone();
            let mut q1a: QuadCurve = q1.clone();
            workload = { let mut _v = workload.clone(); _v.push(HashMap::from([(String::from("p"), p0a), (String::from("q"), q0a)])); _v };
            workload = { let mut _v = workload.clone(); _v.push(HashMap::from([(String::from("p"), p0), (String::from("q"), q1a)])); _v };
            workload = { let mut _v = workload.clone(); _v.push(HashMap::from([(String::from("p"), p1a), (String::from("q"), q0)])); _v };
            workload = { let mut _v = workload.clone(); _v.push(HashMap::from([(String::from("p"), p1), (String::from("q"), q1)])); _v };
        }
    }
    return inters
};
    fn mochi_main() {
    let mut p: QuadCurve = QuadCurve {x: QuadSpline {c0: -1.0, c1: 0.0, c2: 1.0}, y: QuadSpline {c0: 0.0, c1: 10.0, c2: 0.0}};
    let mut q: QuadCurve = QuadCurve {x: QuadSpline {c0: 2.0, c1: -8.0, c2: 2.0}, y: QuadSpline {c0: 1.0, c1: 2.0, c2: 3.0}};
    let mut tol: f64 = 0.0000001;
    let mut spacing: f64 = (tol * 10.0);
    let mut inters: Vec<Point> = findIntersects(&p, &q, tol, spacing);
    let mut i: i64 = 0;
    while (i < (inters.len() as i64)) {
        let mut pt: Point = inters[i as usize].clone();
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "(", pt.x.to_string()), ", "), pt.y.to_string()), ")"));
        i = (i + 1);
    }
};
    mochi_main();
    let _end: i64 = _now();
    let _mem_end: i64 = _mem();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = if ((_mem_end - _mem_start) < 0) { -(_mem_end - _mem_start) } else { (_mem_end - _mem_start) };
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
