// Generated by Mochi transpiler v0.10.42 on 2025-07-27 16:50 +0700
use std::collections::HashMap;
#[derive(Debug, Clone, Default)]
struct Point {
    x: f64,
    y: f64,
}
impl std::fmt::Display for Point {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"x\": {}", self.x)?;
        write!(f, ", ")?;
        write!(f, "\"y\": {}", self.y)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct QuadSpline {
    c0: f64,
    c1: f64,
    c2: f64,
}
impl std::fmt::Display for QuadSpline {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"c0\": {}", self.c0)?;
        write!(f, ", ")?;
        write!(f, "\"c1\": {}", self.c1)?;
        write!(f, ", ")?;
        write!(f, "\"c2\": {}", self.c2)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct QuadCurve {
    x: QuadSpline,
    y: QuadSpline,
}
impl std::fmt::Display for QuadCurve {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"x\": {}", self.x)?;
        write!(f, ", ")?;
        write!(f, "\"y\": {}", self.y)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct WorkloadItem {
    p: i64,
    q: i64,
}
impl std::fmt::Display for WorkloadItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"p\": {}", self.p)?;
        write!(f, ", ")?;
        write!(f, "\"q\": {}", self.q)?;
        write!(f, "}}")
    }
}

fn absf(mut x: f64) -> f64 {
    if (x < 0.0) {
        return -x
    }
    return x
}

fn maxf(mut a: f64, mut b: f64) -> f64 {
    if (a > b) {
        return a
    }
    return b
}

fn minf(mut a: f64, mut b: f64) -> f64 {
    if (a < b) {
        return a
    }
    return b
}

fn max3(mut a: f64, mut b: f64, mut c: f64) -> f64 {
    let mut m: f64 = a;
    if (b > m) {
        m = b;
    }
    if (c > m) {
        m = c;
    }
    return m
}

fn min3(mut a: f64, mut b: f64, mut c: f64) -> f64 {
    let mut m: f64 = a;
    if (b < m) {
        m = b;
    }
    if (c < m) {
        m = c;
    }
    return m
}

fn subdivideQuadSpline(q: &QuadSpline, mut t: f64) -> Vec<QuadSpline> {
    let s: f64 = (1.0 - t);
    let mut u: QuadSpline = QuadSpline {c0: q.c0, c1: 0.0, c2: 0.0};
    let mut v: QuadSpline = QuadSpline {c0: 0.0, c1: 0.0, c2: q.c2};
    u.c1 = ((s * q.c0) + (t * q.c1));
    v.c1 = ((s * q.c1) + (t * q.c2));
    u.c2 = ((s * u.c1) + (t * v.c1));
    v.c0 = u.c2;
    return vec![u, v]
}

fn subdivideQuadCurve(q: &QuadCurve, mut t: f64) -> Vec<QuadCurve> {
    let mut xs: Vec<QuadSpline> = subdivideQuadSpline(&q.x, t);
    let mut ys: Vec<QuadSpline> = subdivideQuadSpline(&q.y, t);
    let mut u: QuadCurve = QuadCurve {x: xs[0 as usize].clone(), y: ys[0 as usize].clone()};
    let mut v: QuadCurve = QuadCurve {x: xs[1 as usize].clone(), y: ys[1 as usize].clone()};
    return vec![u, v]
}

fn rectsOverlap(mut xa0: f64, mut ya0: f64, mut xa1: f64, mut ya1: f64, mut xb0: f64, mut yb0: f64, mut xb1: f64, mut yb1: f64) -> bool {
    return ((((xb0 <= xa1) && (xa0 <= xb1)) && (yb0 <= ya1)) && (ya0 <= yb1))
}

fn testIntersect(p: &QuadCurve, q: &QuadCurve, mut tol: f64) -> HashMap<&str, bool> {
    let pxmin: f64 = min3(p.x.c0, p.x.c1, p.x.c2);
    let pymin: f64 = min3(p.y.c0, p.y.c1, p.y.c2);
    let pxmax: f64 = max3(p.x.c0, p.x.c1, p.x.c2);
    let pymax: f64 = max3(p.y.c0, p.y.c1, p.y.c2);
    let qxmin: f64 = min3(q.x.c0, q.x.c1, q.x.c2);
    let qymin: f64 = min3(q.y.c0, q.y.c1, q.y.c2);
    let qxmax: f64 = max3(q.x.c0, q.x.c1, q.x.c2);
    let qymax: f64 = max3(q.y.c0, q.y.c1, q.y.c2);
    let mut exclude: bool = true;
    let mut accept: bool = false;
    let mut inter: Point = Point {x: 0.0, y: 0.0};
    if rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax) {
        exclude = false;
        let xmin: f64 = maxf(pxmin, qxmin);
        let xmax: f64 = minf(pxmax, qxmax);
        if ((xmax - xmin) <= tol) {
            let ymin: f64 = maxf(pymin, qymin);
            let ymax: f64 = minf(pymax, qymax);
            if ((ymax - ymin) <= tol) {
                accept = true;
                inter.x = (0.5 * (xmin + xmax));
                inter.y = (0.5 * (ymin + ymax));
            }
        }
    }
    return HashMap::from([(String::from("exclude"), exclude), (String::from("accept"), accept), (String::from("intersect"), inter)])
}

fn seemsToBeDuplicate(mut pts: Vec<Point>, xy: &Point, mut spacing: f64) -> bool {
    let mut i: i64 = 0;
    while (i < (pts.len() as i64)) {
        let pt: Point = pts[i as usize].clone();
        if ((absf((pt.x - xy.x)) < spacing) && (absf((pt.y - xy.y)) < spacing)) {
            return true
        }
        i = (i + 1);
    }
    return false
}

fn findIntersects(p: &QuadCurve, q: &QuadCurve, mut tol: f64, mut spacing: f64) -> Vec<Point> {
    let mut inters: Vec<Point> = vec![];
    let mut workload: Vec<HashMap<String, QuadCurve>> = vec![HashMap::from([(String::from("p"), p), (String::from("q"), q)])];
    while ((workload.len() as i64) > 0) {
        let idx = ((workload.len() as i64) - 1);
        let mut work: HashMap<String, QuadCurve> = workload[idx as usize].clone();
        workload = workload[0..idx as usize].to_vec();
        let mut res: HashMap<&str, bool> = testIntersect(&work["p".as_str()].clone(), &work["q".as_str()].clone(), tol);
        let excl: bool = res["exclude".as_str()];
        let acc: bool = res["accept".as_str()];
        let inter: bool = res["intersect".as_str()];
        if acc {
            if !seemsToBeDuplicate(inters.clone(), &inter, spacing) {
                inters = { let mut _v = inters.clone(); _v.push(inter); _v };
            }
        } else if !excl {
            let mut ps: Vec<QuadCurve> = subdivideQuadCurve(&work["p".as_str()].clone(), 0.5);
            let mut qs: Vec<QuadCurve> = subdivideQuadCurve(&work["q".as_str()].clone(), 0.5);
            let p0: QuadCurve = ps[0 as usize].clone();
            let p1: QuadCurve = ps[1 as usize].clone();
            let q0: QuadCurve = qs[0 as usize].clone();
            let q1: QuadCurve = qs[1 as usize].clone();
            workload = { let mut _v = workload.clone(); _v.push(HashMap::from([(String::from("p"), p0), (String::from("q"), q0)])); _v };
            workload = { let mut _v = workload.clone(); _v.push(HashMap::from([(String::from("p"), p0), (String::from("q"), q1)])); _v };
            workload = { let mut _v = workload.clone(); _v.push(HashMap::from([(String::from("p"), p1), (String::from("q"), q0)])); _v };
            workload = { let mut _v = workload.clone(); _v.push(HashMap::from([(String::from("p"), p1), (String::from("q"), q1)])); _v };
        }
    }
    return inters
}

fn mochi_main() {
    let p: QuadCurve = QuadCurve {x: QuadSpline {c0: -1.0, c1: 0.0, c2: 1.0}, y: QuadSpline {c0: 0.0, c1: 10.0, c2: 0.0}};
    let q: QuadCurve = QuadCurve {x: QuadSpline {c0: 2.0, c1: -8.0, c2: 2.0}, y: QuadSpline {c0: 1.0, c1: 2.0, c2: 3.0}};
    let tol: f64 = 0.0000001;
    let spacing: f64 = (tol * 10.0);
    let mut inters: Vec<Point> = findIntersects(&p, &q, tol, spacing);
    let mut i: i64 = 0;
    while (i < (inters.len() as i64)) {
        let pt: Point = inters[i as usize].clone();
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "(", pt.x.to_string()), ", "), pt.y.to_string()), ")"));
        i = (i + 1);
    }
}

fn main() {
    mochi_main();
}
