// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:12 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Map {
    name: f64,
    children: Vec<i64>,
}
impl std::fmt::Display for Map {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"name\": {}", self.name)?;
        write!(f, ", ")?;
        write!(f, "\"children\": {:?}", self.children)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Map1 {
    name: String,
    children: Vec<i64>,
}
impl std::fmt::Display for Map1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"name\": \"{}\"", self.name)?;
        write!(f, ", ")?;
        write!(f, "\"children\": {:?}", self.children)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start_mem: i64 = _mem();
    let _start: i64 = _now();
    fn split(s: &str, sep: &str) -> Vec<String> {
    let mut out: Vec<String> = vec![];
    let mut cur = String::from("");
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if (((i + (sep.len() as i64)) <= (s.len() as i64)) && ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + (sep.len() as i64)) - i) as usize).collect::<String>() } == sep)) {
            out = { let mut _v = out.clone(); _v.push(cur.to_string()); _v };
            cur = String::from("");
            i = (i + (sep.len() as i64));
        } else {
            cur = format!("{}{}", cur, { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() });
            i = (i + 1);
        }
    }
    out = { let mut _v = out.clone(); _v.push(cur.to_string()); _v };
    return out
};
    fn join(mut xs: Vec<String>, sep: &str) -> String {
    let mut res = String::from("");
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        if (i > 0) {
            res = format!("{}{}", res, sep);
        }
        res = format!("{}{}", res, xs[i as usize].clone());
        i = (i + 1);
    }
    return res.clone()
};
    fn trimLeftSpaces(s: &str) -> String {
    let mut i: i64 = 0;
    while ((i < (s.len() as i64)) && (s[i as usize..(i + 1) as usize].to_string().as_str() == " ")) {
        i = (i + 1);
    }
    return s[i as usize..(s.len() as i64) as usize].to_string().clone()
};
    fn makeIndent(outline: &str, mut tab: i64) -> Vec<HashMap<&str, i64>> {
    let mut lines: Vec<String> = split(outline, &"\n");
    let mut nodes: Vec<HashMap<String, f64>> = vec![];
    for line in lines.clone() {
        let mut line2: String = trimLeftSpaces(&line).clone();
        let mut level = (((line.len() as i64) - (line2.len() as i64)) / tab);
        nodes = { let mut _v = nodes.clone(); _v.push(HashMap::from([(String::from("level"), level), (String::from("name"), line2)])); _v };
    }
    return nodes
};
    fn toNest(mut nodes: Vec<HashMap<String, f64>>, mut start: i64, mut level: i64, mut n: HashMap<String, f64>) {
    if (level == 0) {
        n.insert("name".clone(), nodes[0 as usize]["name".as_str()]);
    }
    let mut i: i64 = (start + 1);
    while (i < (nodes.len() as i64)) {
        let mut node: HashMap<String, f64> = nodes[i as usize].clone();
        let mut lev: i64 = (node["level".as_str()] as i64);
        if (lev == (level + 1)) {
            let mut child: Map = Map {name: node["name".as_str()], children: vec![]};
            toNest(nodes.clone(), i, (level + 1), child.clone());
            let mut cs: f64 = n["children".as_str()];
            cs = { let mut _v = cs.clone(); _v.push(child.clone()); _v };
            n.insert("children".clone(), cs);
        } else if (lev <= level) {
            return
        }
        i = (i + 1);
    }
};
    fn countLeaves(n: &HashMap<String, f64>) -> i64 {
    let mut kids: f64 = n["children".as_str()];
    if ((kids.len() as i64) == 0) {
        return 1
    }
    let mut total: i64 = 0;
    for k in kids {
        total = (total + countLeaves(&k));
    }
    return total
};
    fn nodesByDepth(root: &HashMap<String, f64>, mut depth: i64) -> Vec<Vec<HashMap<String, f64>>> {
    let mut levels: Vec<Vec<HashMap<String, f64>>> = vec![];
    let mut current: Vec<HashMap<String, f64>> = vec![root];
    let mut d: i64 = 0;
    while (d < depth) {
        levels = { let mut _v = levels.clone(); _v.push(current.clone()); _v };
        let mut next: Vec<HashMap<String, f64>> = vec![];
        for n in &current {
            let mut kids: i64 = (n["children".as_str()] as i64);
            for k in kids {
                next = { let mut _v = next.clone(); _v.push(k); _v };
            }
        }
        current = next.clone();
        d = (d + 1);
    }
    return levels
};
    fn toMarkup(n: &HashMap<String, f64>, mut cols: Vec<String>, mut depth: i64) -> String {
    let mut lines: Vec<String> = vec![];
    lines = { let mut _v = lines.clone(); _v.push("{| class=\"wikitable\" style=\"text-align: center;\"".to_string()); _v };
    let mut l1 = String::from("|-");
    lines = { let mut _v = lines.clone(); _v.push(l1.to_string()); _v };
    let mut span: i64 = countLeaves(n);
    lines = { let mut _v = lines.clone(); _v.push(format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "| style=\"background: ", cols[0 as usize].clone()), " \" colSpan="), span.to_string()), " | "), n["name".as_str()].to_string()).to_string()); _v };
    lines = { let mut _v = lines.clone(); _v.push(l1.to_string()); _v };
    let mut lvls: Vec<Vec<HashMap<String, f64>>> = nodesByDepth(n, depth);
    let mut lvl: i64 = 1;
    while (lvl < depth) {
        let mut nodes: Vec<HashMap<String, f64>> = lvls[lvl as usize].clone();
        if ((nodes.len() as i64) == 0) {
            lines = { let mut _v = lines.clone(); _v.push("|  |".to_string()); _v };
        } else {
            let mut idx: i64 = 0;
            while (idx < (nodes.len() as i64)) {
                let mut node: HashMap<String, f64> = nodes[idx as usize].clone();
                span = countLeaves(&node);
                let mut col: i64 = lvl;
                if (lvl == 1) {
                    col = (idx + 1);
                }
                if (col >= (cols.len() as i64)) {
                    col = ((cols.len() as i64) - 1);
                }
                let mut cell: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "| style=\"background: ", cols[col as usize].clone()), " \" colspan="), span.to_string()), " | "), node["name".as_str()].to_string()).clone();
                lines = { let mut _v = lines.clone(); _v.push(cell.to_string()); _v };
                idx = (idx + 1);
            }
        }
        if (lvl < (depth - 1)) {
            lines = { let mut _v = lines.clone(); _v.push(l1.to_string()); _v };
        }
        lvl = (lvl + 1);
    }
    lines = { let mut _v = lines.clone(); _v.push("|}".to_string()); _v };
    return join(lines.clone(), &"\n").clone()
};
    fn mochi_main() {
    let mut outline: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Display an outline as a nested table.\n", "    Parse the outline to a tree,\n"), "        measuring the indent of each line,\n"), "        translating the indentation to a nested structure,\n"), "        and padding the tree to even depth.\n"), "    count the leaves descending from each node,\n"), "        defining the width of a leaf as 1,\n"), "        and the width of a parent node as a sum.\n"), "            (The sum of the widths of its children)\n"), "    and write out a table with 'colspan' values\n"), "        either as a wiki table,\n"), "        or as HTML.").clone();
    let mut yellow = String::from("#ffffe6;");
    let mut orange = String::from("#ffebd2;");
    let mut green = String::from("#f0fff0;");
    let mut blue = String::from("#e6ffff;");
    let mut pink = String::from("#ffeeff;");
    let mut cols: Vec<String> = vec![yellow, orange, green, blue, pink];
    let mut nodes: Vec<HashMap<&str, i64>> = makeIndent(&outline, 4);
    let mut n: Map1 = Map1 {name: String::from(""), children: vec![]};
    toNest(nodes.clone(), 0, 0, n.clone());
    println!("{}", toMarkup(&n, cols.clone(), 4));
    println!("{}", "\n");
    let mut outline2: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Display an outline as a nested table.\n", "    Parse the outline to a tree,\n"), "        measuring the indent of each line,\n"), "        translating the indentation to a nested structure,\n"), "        and padding the tree to even depth.\n"), "    count the leaves descending from each node,\n"), "        defining the width of a leaf as 1,\n"), "        and the width of a parent node as a sum.\n"), "            (The sum of the widths of its children)\n"), "            Propagating the sums upward as necessary.\n"), "    and write out a table with 'colspan' values\n"), "        either as a wiki table,\n"), "        or as HTML.\n"), "    Optionally add color to the nodes.").clone();
    let mut cols2: Vec<String> = vec![blue, yellow, orange, green, pink];
    let mut nodes2: Vec<HashMap<&str, i64>> = makeIndent(&outline2, 4);
    let mut n2: Map1 = Map1 {name: String::from(""), children: vec![]};
    toNest(nodes2.clone(), 0, 0, n2.clone());
    println!("{}", toMarkup(&n2, cols2.clone(), 4));
};
    mochi_main();
    let _end: i64 = _now();
    let _end_mem: i64 = _mem();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = (_end_mem - _start_mem);
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
