// Generated by Mochi transpiler v0.10.57 on 2025-08-05 01:46 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Field {
    s: Vec<Vec<bool>>,
    w: i64,
    h: i64,
}
impl std::fmt::Display for Field {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"s\": {:?}", self.s)?;
        write!(f, ", ")?;
        write!(f, "\"w\": {}", self.w)?;
        write!(f, ", ")?;
        write!(f, "\"h\": {}", self.h)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Life {
    a: Field,
    b: Field,
    w: i64,
    h: i64,
}
impl std::fmt::Display for Life {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"a\": {}", self.a)?;
        write!(f, ", ")?;
        write!(f, "\"b\": {}", self.b)?;
        write!(f, ", ")?;
        write!(f, "\"w\": {}", self.w)?;
        write!(f, ", ")?;
        write!(f, "\"h\": {}", self.h)?;
        write!(f, "}}")
    }
}

static mut g_seed: i64 = 0;
fn main() {
    unsafe {
        g_seed = 1;
                let _start: i64 = _now();
        unsafe fn randN(mut n: i64) -> i64 {
    g_seed = (((g_seed * 1664525) + 1013904223) % 2147483647);
    return (g_seed % n)
};
        unsafe fn newField(mut w: i64, mut h: i64) -> Field {
    let mut rows: Vec<Vec<bool>> = vec![];
    let mut y: i64 = 0;
    while (y < h) {
        let mut row: Vec<bool> = vec![];
        let mut x: i64 = 0;
        while (x < w) {
            row = { let mut _v = row.clone(); _v.push(false); _v };
            x = (x + 1);
        }
        rows = { let mut _v = rows.clone(); _v.push(row.clone()); _v };
        y = (y + 1);
    }
    return Field {s: rows, w: w, h: h}
};
        unsafe fn setCell(f: &mut Field, mut x: i64, mut y: i64, mut b: bool) {
    let mut rows: Vec<Vec<bool>> = f.s.clone();
    let mut row: Vec<bool> = rows[y as usize].clone();
    row[x as usize] = b;
    rows[y as usize] = row.clone();
    (*f).s = rows.clone();
};
        unsafe fn state(f: &Field, mut x: i64, mut y: i64) -> bool {
    while (y < 0) {
        y = (y + f.h);
    }
    while (x < 0) {
        x = (x + f.w);
    }
    return f.s.clone()[(y % f.h) as usize].clone()[(x % f.w) as usize]
};
        unsafe fn nextState(f: &mut Field, mut x: i64, mut y: i64) -> bool {
    let mut count: i64 = 0;
    let mut dy: i64 = -1;
    while (dy <= 1) {
        let mut dx: i64 = -1;
        while (dx <= 1) {
            if (!((dx == 0) && (dy == 0)) && state(f, (x + dx), (y + dy))) {
                count = (count + 1);
            }
            dx = (dx + 1);
        }
        dy = (dy + 1);
    }
    return ((count == 3) || ((count == 2) && state(f, x, y)))
};
        unsafe fn newLife(mut w: i64, mut h: i64) -> Life {
    let mut a: Field = newField(w, h);
    let mut i: i64 = 0;
    while (i < ((w * h) / 2)) {
        setCell(&mut a, randN(w), randN(h), true);
        i = (i + 1);
    }
    return Life {a: a, b: newField(w, h), w: w, h: h}
};
        unsafe fn step(l: &mut Life) {
    let mut y: i64 = 0;
    while (y < l.h) {
        let mut x: i64 = 0;
        while (x < l.w) {
            setCell(&mut l.b.clone(), x, y, nextState(&mut l.a.clone(), x, y));
            x = (x + 1);
        }
        y = (y + 1);
    }
    let mut tmp: Field = l.a.clone();
    (*l).a = l.b.clone();
    (*l).b = tmp.clone();
};
        unsafe fn lifeString(l: &Life) -> String {
    let mut out: String = String::from("").clone();
    let mut y: i64 = 0;
    while (y < l.h) {
        let mut x: i64 = 0;
        while (x < l.w) {
            if state(&l.a.clone(), x, y) {
                out = format!("{}{}", out, "*");
            } else {
                out = format!("{}{}", out, " ");
            }
            x = (x + 1);
        }
        out = format!("{}{}", out, "\n");
        y = (y + 1);
    }
    return out.clone()
};
        unsafe fn mochi_main() {
    let mut l: Life = newLife(80, 15);
    let mut i: i64 = 0;
    while (i < 300) {
        step(&mut l);
        println!("{}", "\u{000c}");
        println!("{}", lifeString(&l));
        i = (i + 1);
    }
};
        mochi_main();
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
