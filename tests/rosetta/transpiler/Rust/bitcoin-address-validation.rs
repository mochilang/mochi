// Generated by Mochi transpiler v0.10.42 on 2025-07-27 23:19 +0700
use std::process::{Command, Stdio};
use std::io::Write;
fn _sha256(bs: Vec<i64>) -> Vec<i64> {
    let mut child = Command::new("sha256sum")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn().unwrap();
    {
        let mut stdin = child.stdin.take().unwrap();
        for b in bs.iter() { stdin.write_all(&[*b as u8]).unwrap(); }
    }
    let out = child.wait_with_output().unwrap();
    let hex = String::from_utf8_lossy(&out.stdout);
    let mut bytes = Vec::new();
    if let Some(part) = hex.split_whitespace().next() {
        for i in 0..32 {
            let byte = u8::from_str_radix(&part[i*2..i*2+2], 16).unwrap();
            bytes.push(byte as i64);
        }
    }
    bytes
}
fn indexOf(s: &str, ch: &str) -> i64 {
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if (s[i as usize..(i + 1) as usize].to_string() == ch) {
            return i
        }
        i = (i + 1);
    }
    return -1
}

fn set58(addr: &str) -> Vec<i64> {
    let mut tmpl = String::from("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    let mut a: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < 25) {
        a = { let mut _v = a.clone(); _v.push(0); _v };
        i = (i + 1);
    }
    let mut idx: i64 = 0;
    while (idx < (addr.len() as i64)) {
        let mut ch: String = addr[idx as usize..(idx + 1) as usize].to_string().clone();
        let mut c: i64 = indexOf(&tmpl, &ch);
        if (c < 0) {
            return vec![]
        }
        let mut j: i64 = 24;
        while (j >= 0) {
            c = (c + (58 * a[j as usize]));
            a[j as usize] = (c % 256);
            c = (c / 256);
            j = (j - 1);
        }
        if (c > 0) {
            return vec![]
        }
        idx = (idx + 1);
    }
    return a
}

fn doubleSHA256(mut bs: Vec<i64>) -> Vec<i64> {
    let mut first: Vec<i64> = _sha256(bs);
    return _sha256(first)
}

fn computeChecksum(mut a: Vec<i64>) -> Vec<i64> {
    let mut hash: Vec<i64> = doubleSHA256(a[0 as usize..21 as usize].to_vec());
    return hash[0 as usize..4 as usize].to_vec()
}

fn validA58(addr: &str) -> bool {
    let mut a: Vec<i64> = set58(addr);
    if ((a.len() as i64) != 25) {
        return false
    }
    if (a[0 as usize] != 0) {
        return false
    }
    let mut sum: Vec<i64> = computeChecksum(a.clone());
    let mut i: i64 = 0;
    while (i < 4) {
        if (a[(21 + i) as usize] != sum[i as usize]) {
            return false
        }
        i = (i + 1);
    }
    return true
}

fn main() {
    println!("{}", validA58(&"1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i").to_string());
    println!("{}", validA58(&"17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j").to_string());
}
