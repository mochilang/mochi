// Generated by Mochi transpiler v0.10.40 on 2025-07-25 19:38 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
use std::io::{self, Read};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn input() -> String {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).unwrap();
    s.trim_end().to_string()
}
#[derive(Debug, Clone, Default)]
struct MoveResult {
    idx: i64,
    ok: bool,
}
impl std::fmt::Display for MoveResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"idx\": {}", self.idx)?;
        write!(f, ", ")?;
        write!(f, "\"ok\": {}", self.ok)?;
        write!(f, "}}")
    }
}

static mut g_board: Vec<i64> = Vec::new();
static mut g_solved: Vec<i64> = Vec::new();
static mut g_empty: i64 = 0;
static mut g_moves: i64 = 0;
static mut g_quit: bool = false;
fn main() {
    unsafe {
        g_board = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
        g_solved = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];
        g_empty = 15;
        g_moves = 0;
        g_quit = false;
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        static mut g_board: Vec<i64> = Vec::new();;
        static mut g_solved: Vec<i64> = Vec::new();;
        static mut g_empty: i64 = 0;;
        static mut g_moves: i64 = 0;;
        static mut g_quit: bool = false;;
        unsafe fn randMove() -> i64 {
    return (_now() % 4)
};
        unsafe fn isSolved() -> bool {
    let mut i: i64 = 0;
    while (i < 16) {
        if (g_board.clone()[i as usize] != g_solved.clone()[i as usize]) {
            return false
        }
        i = (i + 1);
    }
    return true
};
        unsafe fn isValidMove(mut m: i64) -> MoveResult {
    if (m == 0) {
        return MoveResult {idx: (g_empty - 4), ok: ((g_empty / 4) > 0)}
    }
    if (m == 1) {
        return MoveResult {idx: (g_empty + 4), ok: ((g_empty / 4) < 3)}
    }
    if (m == 2) {
        return MoveResult {idx: (g_empty + 1), ok: ((g_empty % 4) < 3)}
    }
    if (m == 3) {
        return MoveResult {idx: (g_empty - 1), ok: ((g_empty % 4) > 0)}
    }
    return MoveResult {idx: 0, ok: false}
};
        unsafe fn doMove(mut m: i64) -> bool {
    let r: MoveResult = isValidMove(m);
    if !r.ok {
        return false
    }
    let i: i64 = g_empty;
    let j: i64 = r.idx;
    let tmp: i64 = g_board.clone()[i as usize];
    g_board.clone()[i as usize] = g_board.clone()[j as usize];
    g_board.clone()[j as usize] = tmp;
    g_empty = j;
    g_moves = (g_moves + 1);
    return true
};
        unsafe fn shuffle(mut n: i64) {
    let mut i: i64 = 0;
    while ((i < n) || isSolved()) {
        if doMove(randMove()) {
            i = (i + 1);
        }
    }
};
        unsafe fn printBoard() {
    let mut line = String::from("");
    let mut i: i64 = 0;
    while (i < 16) {
        let val: i64 = g_board.clone()[i as usize];
        if (val == 0) {
            line = format!("{}{}", line, "  .");
        } else {
            let s = val.to_string();
            if (val < 10) {
                line = format!("{}{}", format!("{}{}", line, "  "), s);
            } else {
                line = format!("{}{}", format!("{}{}", line, " "), s);
            }
        }
        if ((i % 4) == 3) {
            println!("{}", line);
            line = String::from("");
        }
        i = (i + 1);
    }
};
        unsafe fn playOneMove() {
    while true {
        println!("{}", format!("{}{}", format!("{}{}", "Enter move #", (g_moves + 1).to_string()), " (U, D, L, R, or Q): "));
        let s: String = input().clone();
        if (s.as_str() == "") {
            continue
        }
        let c: String = s[0 as usize..1 as usize].to_string().clone();
        let mut m: i64 = 0;
        if ((c.as_str() == "U") || (c.as_str() == "u")) {
            m = 0;
        } else if ((c.as_str() == "D") || (c.as_str() == "d")) {
            m = 1;
        } else if ((c.as_str() == "R") || (c.as_str() == "r")) {
            m = 2;
        } else if ((c.as_str() == "L") || (c.as_str() == "l")) {
            m = 3;
        } else if ((c.as_str() == "Q") || (c.as_str() == "q")) {
            println!("{}", format!("{}{}", format!("{}{}", "Quiting after ", g_moves.to_string()), " moves."));
            g_quit = true;
            return
        } else {
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", "Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n", "up, down, left, or right. You can also enter \"Q\" to quit.\n"), "Upper or lowercase is accepted and only the first non-blank\n"), "character is important (i.e. you may enter \"up\" if you like)."));
            continue
        }
        if !doMove(m) {
            println!("{}", "That is not a valid move at the moment.");
            continue
        }
        return
    }
};
        unsafe fn play() {
    println!("{}", "Starting board:");
    while (!g_quit && (isSolved() == false)) {
        println!("{}", "");
        printBoard();
        playOneMove();
    }
    if isSolved() {
        println!("{}", format!("{}{}", format!("{}{}", "You solved the puzzle in ", g_moves.to_string()), " moves."));
    }
};
        unsafe fn mochi_main() {
    shuffle(50);
    play();
};
        mochi_main();
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _end_mem;
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
