// Generated by Mochi transpiler v0.10.37 on 2025-07-23 09:04 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
use std::io::{self, Read};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn input() -> String {
    let mut s = String::new();
    std::io::stdin().read_line(&mut s).unwrap();
    s.trim_end().to_string()
}
fn int(x: i64) -> i64 { x }
#[derive(Debug, Clone)]
struct Map {
    idx: i64,
    ok: bool,
}
impl std::fmt::Display for Map {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"idx\": {}", self.idx)?;
        write!(f, ", ")?;
        write!(f, "\"ok\": {}", self.ok)?;
        write!(f, "}}")
    }
}

static mut board: Vec<i64> = Vec::new();
static mut solved: Vec<i64> = Vec::new();
static mut empty: i64 = 0;
static mut moves: i64 = 0;
static mut quit: bool = false;
unsafe fn randMove() -> i64 {
    return (_now() % 4)
}

unsafe fn isSolved() -> bool {
    let mut i: i64 = 0;
    while (i < 16) {
        if (board[i as usize] != solved[i as usize]) {
            return false
        }
        i = (i + 1);
    }
    return true
}

unsafe fn isValidMove(m: i64) -> Map {
    if (m == 0) {
        return Map {idx: (empty - 4), ok: ((empty / 4) > 0)}
    }
    if (m == 1) {
        return Map {idx: (empty + 4), ok: ((empty / 4) < 3)}
    }
    if (m == 2) {
        return Map {idx: (empty + 1), ok: ((empty % 4) < 3)}
    }
    if (m == 3) {
        return Map {idx: (empty - 1), ok: ((empty % 4) > 0)}
    }
    return Map {idx: 0, ok: false}
}

unsafe fn doMove(m: i64) -> bool {
    let r: Map = isValidMove(m);
    if !r.ok {
        return false
    }
    let i: i64 = empty;
    let j: i64 = int(r.idx);
    let tmp: i64 = board[i as usize];
    board[i as usize] = board[j as usize];
    board[j as usize] = tmp;
    empty = j;
    moves = (moves + 1);
    return true
}

unsafe fn shuffle(n: i64) {
    let mut i: i64 = 0;
    while ((i < n) || isSolved()) {
        if doMove(randMove()) {
            i = (i + 1);
        }
    }
}

unsafe fn printBoard() {
    let mut line = String::from("");
    let mut i: i64 = 0;
    while (i < 16) {
        let val: i64 = board[i as usize];
        if (val == 0) {
            line = format!("{}{}", line, "  .");
        } else {
            let s = val.to_string();
            if (val < 10) {
                line = format!("{}{}", format!("{}{}", line, "  "), s);
            } else {
                line = format!("{}{}", format!("{}{}", line, " "), s);
            }
        }
        if ((i % 4) == 3) {
            println!("{}", line);
            line = String::from("");
        }
        i = (i + 1);
    }
}

unsafe fn playOneMove() {
    while true {
        println!("{}", format!("{}{}", format!("{}{}", "Enter move #", (moves + 1).to_string()), " (U, D, L, R, or Q): "));
        let s: String = input().clone();
        if (s == "") {
            continue
        }
        let c: String = s[0..1].to_string().clone();
        let mut m: i64 = 0;
        if ((c == "U") || (c == "u")) {
            m = 0;
        } else if ((c == "D") || (c == "d")) {
            m = 1;
        } else if ((c == "R") || (c == "r")) {
            m = 2;
        } else if ((c == "L") || (c == "l")) {
            m = 3;
        } else if ((c == "Q") || (c == "q")) {
            println!("{}", format!("{}{}", format!("{}{}", "Quiting after ", moves.to_string()), " moves."));
            quit = true;
            return
        } else {
            println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", "Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n", "up, down, left, or right. You can also enter \"Q\" to quit.\n"), "Upper or lowercase is accepted and only the first non-blank\n"), "character is important (i.e. you may enter \"up\" if you like)."));
            continue
        }
        if !doMove(m) {
            println!("{}", "That is not a valid move at the moment.");
            continue
        }
        return
    }
}

unsafe fn play() {
    println!("{}", "Starting board:");
    while (!quit && (isSolved() == false)) {
        println!("{}", "");
        printBoard();
        playOneMove();
    }
    if isSolved() {
        println!("{}", format!("{}{}", format!("{}{}", "You solved the puzzle in ", moves.to_string()), " moves."));
    }
}

unsafe fn mochi_main() {
    shuffle(50);
    play();
}

fn main() {
    unsafe { board = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]; }
    unsafe { solved = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]; }
    unsafe { empty = 15; }
    unsafe { moves = 0; }
    unsafe { quit = false; }
    unsafe { mochi_main(); }
}
