// Generated by Mochi transpiler v0.10.42 on 2025-07-27 17:23 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start_mem: i64 = _mem();
    let _start: i64 = _now();
    fn square_to_maps(mut square: Vec<Vec<String>>) -> HashMap<&str, HashMap<String, Vec<i64>>> {
    let mut emap: HashMap<String, Vec<i64>> = HashMap::from([]);
    let mut dmap: HashMap<String, String> = HashMap::from([]);
    let mut x: i64 = 0;
    while (x < (square.len() as i64)) {
        let mut row: Vec<String> = square[x as usize].clone();
        let mut y: i64 = 0;
        while (y < (row.len() as i64)) {
            let ch: String = row[y as usize].clone().clone();
            emap.insert(ch.clone(), vec![x, y]);
            dmap.insert(format!("{}{}", format!("{}{}", x.to_string(), ","), y.to_string()).clone(), ch);
            y = (y + 1);
        }
        x = (x + 1);
    }
    return HashMap::from([(String::from("e"), emap), (String::from("d"), dmap)])
};
    fn remove_space(mut text: String, emap: &HashMap<String, Vec<i64>>) -> String {
    let s: String = (text.to_uppercase()).clone();
    let mut out = String::from("");
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let ch: String = s[i as usize..(i + 1) as usize].to_string().clone();
        if ((ch.as_str() != " ") && emap.contains_key(&ch)) {
            out = format!("{}{}", out, ch);
        }
        i = (i + 1);
    }
    return out.clone()
};
    fn encrypt(mut text: String, emap: &HashMap<String, Vec<i64>>, dmap: &HashMap<String, String>) -> String {
    text = remove_space(text, emap);
    let mut row0: Vec<i64> = vec![];
    let mut row1: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (text.len() as i64)) {
        let ch: String = text[i as usize..(i + 1) as usize].to_string().clone();
        let mut xy: Vec<i64> = emap[ch.as_str()].clone();
        row0 = { let mut _v = row0.clone(); _v.push(xy[0 as usize]); _v };
        row1 = { let mut _v = row1.clone(); _v.push(xy[1 as usize]); _v };
        i = (i + 1);
    }
    for v in row1.clone() {
        row0 = { let mut _v = row0.clone(); _v.push(v); _v };
    }
    let mut res = String::from("");
    let mut j: i64 = 0;
    while (j < (row0.len() as i64)) {
        let key = format!("{}{}", format!("{}{}", row0[j as usize].to_string(), ","), row0[(j + 1) as usize].to_string());
        res = format!("{}{}", res, dmap[&key].clone());
        j = (j + 2);
    }
    return res.clone()
};
    fn decrypt(mut text: String, emap: &HashMap<String, Vec<i64>>, dmap: &HashMap<String, String>) -> String {
    text = remove_space(text, emap);
    let mut coords: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while (i < (text.len() as i64)) {
        let ch: String = text[i as usize..(i + 1) as usize].to_string().clone();
        let mut xy: Vec<i64> = emap[ch.as_str()].clone();
        coords = { let mut _v = coords.clone(); _v.push(xy[0 as usize]); _v };
        coords = { let mut _v = coords.clone(); _v.push(xy[1 as usize]); _v };
        i = (i + 1);
    }
    let mut half = ((coords.len() as i64) / 2);
    let mut k1: Vec<i64> = vec![];
    let mut k2: Vec<i64> = vec![];
    let mut idx: i64 = 0;
    while (idx < half) {
        k1 = { let mut _v = k1.clone(); _v.push(coords[idx as usize]); _v };
        idx = (idx + 1);
    }
    while (idx < (coords.len() as i64)) {
        k2 = { let mut _v = k2.clone(); _v.push(coords[idx as usize]); _v };
        idx = (idx + 1);
    }
    let mut res = String::from("");
    let mut j: i64 = 0;
    while (j < half) {
        let key = format!("{}{}", format!("{}{}", k1[j as usize].to_string(), ","), k2[j as usize].to_string());
        res = format!("{}{}", res, dmap[&key].clone());
        j = (j + 1);
    }
    return res.clone()
};
    fn mochi_main() {
    let mut squareRosetta: Vec<Vec<String>> = vec![vec![String::from("A"), String::from("B"), String::from("C"), String::from("D"), String::from("E")], vec![String::from("F"), String::from("G"), String::from("H"), String::from("I"), String::from("K")], vec![String::from("L"), String::from("M"), String::from("N"), String::from("O"), String::from("P")], vec![String::from("Q"), String::from("R"), String::from("S"), String::from("T"), String::from("U")], vec![String::from("V"), String::from("W"), String::from("X"), String::from("Y"), String::from("Z")], vec![String::from("J"), String::from("1"), String::from("2"), String::from("3"), String::from("4")]];
    let mut squareWikipedia: Vec<Vec<String>> = vec![vec![String::from("B"), String::from("G"), String::from("W"), String::from("K"), String::from("Z")], vec![String::from("Q"), String::from("P"), String::from("N"), String::from("D"), String::from("S")], vec![String::from("I"), String::from("O"), String::from("A"), String::from("X"), String::from("E")], vec![String::from("F"), String::from("C"), String::from("L"), String::from("U"), String::from("M")], vec![String::from("T"), String::from("H"), String::from("Y"), String::from("V"), String::from("R")], vec![String::from("J"), String::from("1"), String::from("2"), String::from("3"), String::from("4")]];
    let textRosetta = String::from("0ATTACKATDAWN");
    let textWikipedia = String::from("FLEEATONCE");
    let textTest = String::from("The invasion will start on the first of January");
    let mut maps: HashMap<&str, HashMap<String, Vec<i64>>> = square_to_maps(squareRosetta.clone());
    let mut emap: HashMap<String, Vec<i64>> = maps["e".as_str()].clone();
    let mut dmap: HashMap<String, Vec<i64>> = maps["d".as_str()].clone();
    println!("{}", "from Rosettacode");
    println!("{}", format!("{}{}", "original:\t ", textRosetta));
    let mut s: String = encrypt(textRosetta, &emap, &dmap).clone();
    println!("{}", format!("{}{}", "codiert:\t ", s));
    s = decrypt(s, &emap, &dmap);
    println!("{}", format!("{}{}", "and back:\t ", s));
    maps = square_to_maps(squareWikipedia.clone());
    emap = maps["e".as_str()].clone();
    dmap = maps["d".as_str()].clone();
    println!("{}", "from Wikipedia");
    println!("{}", format!("{}{}", "original:\t ", textWikipedia));
    s = encrypt(textWikipedia, &emap, &dmap);
    println!("{}", format!("{}{}", "codiert:\t ", s));
    s = decrypt(s, &emap, &dmap);
    println!("{}", format!("{}{}", "and back:\t ", s));
    maps = square_to_maps(squareWikipedia.clone());
    emap = maps["e".as_str()].clone();
    dmap = maps["d".as_str()].clone();
    println!("{}", "from Rosettacode long part");
    println!("{}", format!("{}{}", "original:\t ", textTest));
    s = encrypt(textTest, &emap, &dmap);
    println!("{}", format!("{}{}", "codiert:\t ", s));
    s = decrypt(s, &emap, &dmap);
    println!("{}", format!("{}{}", "and back:\t ", s));
};
    mochi_main();
    let _end: i64 = _now();
    let _end_mem: i64 = _mem();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = (_end_mem - _start_mem);
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
