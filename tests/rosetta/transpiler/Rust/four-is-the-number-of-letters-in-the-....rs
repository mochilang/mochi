// Generated by Mochi transpiler v0.10.52 on 2025-08-01 18:59 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_small: Vec<String> = Vec::new();
static mut g_tens: Vec<String> = Vec::new();
static mut g_smallOrd: Vec<String> = Vec::new();
static mut g_tensOrd: Vec<String> = Vec::new();
static mut g_words: Vec<String> = Vec::new();
static mut g_idx: i64 = 0;
fn main() {
    unsafe {
        g_small = vec![String::from("zero"), String::from("one"), String::from("two"), String::from("three"), String::from("four"), String::from("five"), String::from("six"), String::from("seven"), String::from("eight"), String::from("nine"), String::from("ten"), String::from("eleven"), String::from("twelve"), String::from("thirteen"), String::from("fourteen"), String::from("fifteen"), String::from("sixteen"), String::from("seventeen"), String::from("eighteen"), String::from("nineteen")];
        g_tens = vec![String::from(""), String::from(""), String::from("twenty"), String::from("thirty"), String::from("forty"), String::from("fifty"), String::from("sixty"), String::from("seventy"), String::from("eighty"), String::from("ninety")];
        g_smallOrd = vec![String::from("zeroth"), String::from("first"), String::from("second"), String::from("third"), String::from("fourth"), String::from("fifth"), String::from("sixth"), String::from("seventh"), String::from("eighth"), String::from("ninth"), String::from("tenth"), String::from("eleventh"), String::from("twelfth"), String::from("thirteenth"), String::from("fourteenth"), String::from("fifteenth"), String::from("sixteenth"), String::from("seventeenth"), String::from("eighteenth"), String::from("nineteenth")];
        g_tensOrd = vec![String::from(""), String::from(""), String::from("twentieth"), String::from("thirtieth"), String::from("fortieth"), String::from("fiftieth"), String::from("sixtieth"), String::from("seventieth"), String::from("eightieth"), String::from("ninetieth")];
        g_words = vec![String::from("Four"), String::from("is"), String::from("the"), String::from("number"), String::from("of"), String::from("letters"), String::from("in"), String::from("the"), String::from("first"), String::from("word"), String::from("of"), String::from("this"), String::from("sentence,")];
        g_idx = 0;
                let _start_mem: i64 = _mem();
        let _start: i64 = _now();
        static mut g_small: Vec<String> = Vec::new();;
        static mut g_tens: Vec<String> = Vec::new();;
        static mut g_smallOrd: Vec<String> = Vec::new();;
        static mut g_tensOrd: Vec<String> = Vec::new();;
        unsafe fn say(mut n: i64) -> String {
    if (n < 20) {
        return g_small.clone()[n as usize].clone()
    }
    if (n < 100) {
        let mut res: String = g_tens.clone()[(n / 10) as usize].clone().clone();
        let mut m: i64 = (n % 10);
        if (m != 0) {
            res = format!("{}{}", format!("{}{}", res, "-"), g_small.clone()[m as usize].clone());
        }
        return res
    }
    if (n < 1000) {
        let mut res: String = format!("{}{}", say((n / 100)), " hundred").clone();
        let mut m: i64 = (n % 100);
        if (m != 0) {
            res = format!("{}{}", format!("{}{}", res, " "), say(m));
        }
        return res
    }
    if (n < 1000000) {
        let mut res: String = format!("{}{}", say((n / 1000)), " thousand").clone();
        let mut m: i64 = (n % 1000);
        if (m != 0) {
            res = format!("{}{}", format!("{}{}", res, " "), say(m));
        }
        return res
    }
    let mut res: String = format!("{}{}", say((n / 1000000)), " million").clone();
    let mut m: i64 = (n % 1000000);
    if (m != 0) {
        res = format!("{}{}", format!("{}{}", res, " "), say(m));
    }
    return res.clone()
};
        unsafe fn sayOrdinal(mut n: i64) -> String {
    if (n < 20) {
        return g_smallOrd.clone()[n as usize].clone()
    }
    if (n < 100) {
        if ((n % 10) == 0) {
            return g_tensOrd.clone()[(n / 10) as usize].clone()
        }
        return format!("{}{}", format!("{}{}", say((n - (n % 10))), "-"), g_smallOrd.clone()[(n % 10) as usize].clone())
    }
    if (n < 1000) {
        if ((n % 100) == 0) {
            return format!("{}{}", say((n / 100)), " hundredth")
        }
        return format!("{}{}", format!("{}{}", say((n / 100)), " hundred "), sayOrdinal((n % 100)))
    }
    if (n < 1000000) {
        if ((n % 1000) == 0) {
            return format!("{}{}", say((n / 1000)), " thousandth")
        }
        return format!("{}{}", format!("{}{}", say((n / 1000)), " thousand "), sayOrdinal((n % 1000)))
    }
    if ((n % 1000000) == 0) {
        return format!("{}{}", say((n / 1000000)), " millionth")
    }
    return format!("{}{}", format!("{}{}", say((n / 1000000)), " million "), sayOrdinal((n % 1000000))).clone()
};
        unsafe fn split(s: &str, sep: &str) -> Vec<String> {
    let mut parts: Vec<String> = vec![];
    let mut cur: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        if ((((sep.len() as i64) > 0) && ((i + (sep.len() as i64)) <= (s.len() as i64))) && ({ let tmp = &s; tmp.chars().skip(i as usize).take(((i + (sep.len() as i64)) - i) as usize).collect::<String>() } == sep)) {
            parts = { let mut _v = parts.clone(); _v.push(cur.clone()); _v };
            cur = String::from("");
            i = (i + (sep.len() as i64));
        } else {
            cur = format!("{}{}", cur, { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() });
            i = (i + 1);
        }
    }
    parts = { let mut _v = parts.clone(); _v.push(cur.clone()); _v };
    return parts
};
        unsafe fn countLetters(s: &str) -> i64 {
    let mut cnt: i64 = 0;
    let mut i: i64 = 0;
    while (i < (s.len() as i64)) {
        let mut ch: String = { let tmp = &s; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if (((ch.as_str() >= "A") && (ch.as_str() <= "Z")) || ((ch.as_str() >= "a") && (ch.as_str() <= "z"))) {
            cnt = (cnt + 1);
        }
        i = (i + 1);
    }
    return cnt
};
        static mut g_words: Vec<String> = Vec::new();;
        static mut g_idx: i64 = 0;;
        unsafe fn wordLen(mut w: i64) -> Vec<i64> {
    while ((g_words.clone().len() as i64) < w) {
        g_idx = (g_idx + 1);
        let mut n: i64 = countLetters(&g_words[g_idx as usize].clone());
        let mut parts = say(n).split(" ").map(|x| x.to_string()).collect::<Vec<String>>();
        let mut j: i64 = 0;
        while (j < (parts.len() as i64)) {
            g_words = { let mut _v = g_words.clone().clone(); _v.push(parts[j as usize].to_string()); _v };
            j = (j + 1);
        }
        g_words = { let mut _v = g_words.clone().clone(); _v.push("in".to_string()); _v };
        g_words = { let mut _v = g_words.clone().clone(); _v.push("the".to_string()); _v };
        parts = format!("{}{}", sayOrdinal((g_idx + 1)), ",").split(" ").map(|x| x.to_string()).collect::<Vec<String>>();
        j = 0;
        while (j < (parts.len() as i64)) {
            g_words = { let mut _v = g_words.clone().clone(); _v.push(parts[j as usize].to_string()); _v };
            j = (j + 1);
        }
    }
    let mut word: i64 = g_words.clone()[(w - 1) as usize];
    return vec![word, countLetters(&word)]
};
        unsafe fn totalLength() -> i64 {
    let mut tot: i64 = 0;
    let mut i: i64 = 0;
    while (i < (g_words.clone().len() as i64)) {
        tot = (tot + (g_words.clone()[i as usize].clone().len() as i64));
        if (i < ((g_words.clone().len() as i64) - 1)) {
            tot = (tot + 1);
        }
        i = (i + 1);
    }
    return tot
};
        unsafe fn pad(mut n: i64, mut width: i64) -> String {
    let mut s = n.to_string();
    while ((s.len() as i64) < width) {
        s = format!("{}{}", " ", s);
    }
    return s.clone()
};
        unsafe fn mochi_main() {
    println!("{}", "The lengths of the first 201 words are:");
    let mut line: String = String::from("").clone();
    let mut i: i64 = 1;
    while (i <= 201) {
        if ((i % 25) == 1) {
            if (i != 1) {
                println!("{}", line);
            }
            line = format!("{}{}", pad(i, 3), ":");
        }
        let mut r: Vec<i64> = wordLen(i);
        let mut n: i64 = r[1 as usize];
        line = format!("{}{}", format!("{}{}", line, " "), pad(n, 2));
        i = (i + 1);
    }
    println!("{}", line);
    println!("{}", format!("{}{}", "Length of sentence so far: ", totalLength().to_string()));
    for n in vec![1000, 10000, 100000, 1000000, 10000000] {
        let mut r: Vec<i64> = wordLen(n);
        let mut w: i64 = r[0 as usize];
        let mut l: i64 = r[1 as usize];
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Word ", pad(n, 8)), " is \""), w), "\", with "), l.to_string()), " letters.  Length of sentence so far: "), totalLength().to_string()));
    }
};
        mochi_main();
        let _end: i64 = _now();
        let _end_mem: i64 = _mem();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = (_end_mem - _start_mem);
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
