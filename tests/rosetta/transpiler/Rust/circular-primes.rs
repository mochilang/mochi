// Generated by Mochi transpiler v0.10.57 on 2025-08-05 01:38 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_circs: Vec<i64> = Vec::new();
static mut g_digits: Vec<i64> = Vec::new();
static mut g_q: Vec<i64> = Vec::new();
static mut g_fq: Vec<i64> = Vec::new();
static mut g_count: i64 = 0;
fn main() {
    unsafe {
        g_circs = vec![];
        g_digits = vec![1, 3, 7, 9];
        g_q = vec![1, 2, 3, 5, 7, 9];
        g_fq = vec![1, 2, 3, 5, 7, 9];
        g_count = 0;
                let _start: i64 = _now();
        unsafe fn isPrime(mut n: i64) -> bool {
    if (n < 2) {
        return false
    }
    if ((n % 2) == 0) {
        return (n == 2)
    }
    if ((n % 3) == 0) {
        return (n == 3)
    }
    let mut d: i64 = 5;
    while ((d * d) <= n) {
        if ((n % d) == 0) {
            return false
        }
        d = (d + 2);
        if ((n % d) == 0) {
            return false
        }
        d = (d + 4);
    }
    return true
};
        unsafe fn isCircular(mut n: i64) -> bool {
    let mut nn: i64 = n;
    let mut pow: i64 = 1;
    while (nn > 0) {
        pow = (pow * 10);
        nn = (nn / 10);
    }
    nn = n;
    loop {
        nn = (nn * 10);
        let mut f: i64 = (nn / pow);
        nn = (nn + (f * (1 - pow)));
        if (nn == n) {
            break
        }
        if !isPrime(nn) {
            return false
        }
    }
    return true
};
        println!("{}", "The first 19 circular primes are:");
        loop {
            let mut f: i64 = g_q.clone()[0 as usize];
            let mut fd: i64 = g_fq.clone()[0 as usize];
            if (isPrime(f) && isCircular(f)) {
                g_circs = { let mut _v = g_circs.clone().clone(); _v.push(f); _v };
                g_count = (g_count + 1);
                if (g_count == 19) {
                    break
                }
            }
            g_q = g_q.clone()[1 as usize..].to_vec();
            g_fq = g_fq.clone()[1 as usize..].to_vec();
            if ((f != 2) && (f != 5)) {
                for d in g_digits.clone().iter().cloned() {
                    g_q = { let mut _v = g_q.clone().clone(); _v.push(((f * 10) + d)); _v };
                    g_fq = { let mut _v = g_fq.clone().clone(); _v.push(fd); _v };
                }
            }
        }
        unsafe fn showList(mut xs: Vec<i64>) -> String {
    let mut out: String = String::from("[").clone();
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        out = format!("{}{}", out, xs[i as usize].to_string());
        if (i < ((xs.len() as i64) - 1)) {
            out = format!("{}{}", out, ", ");
        }
        i = (i + 1);
    }
    return format!("{}{}", out, "]").clone()
};
        println!("{}", showList(g_circs.clone().clone()));
        println!("{}", "\nThe next 4 circular primes, in repunit format, are:");
        println!("{}", "[R(19) R(23) R(317) R(1031)]");
        println!("{}", "\nThe following repunits are probably circular primes:");
        for i in vec![5003, 9887, 15073, 25031, 35317, 49081].iter().cloned() {
            println!("{}", format!("{}{}", format!("{}{}", "R(", i.to_string()), ") : true"));
        }
        let _end: i64 = _now();
        let duration_us: i64 = ((_end - _start) / 1000);
        let memory_bytes: i64 = _mem();
        println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

    }
}
