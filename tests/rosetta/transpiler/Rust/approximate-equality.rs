// Generated by Mochi transpiler v0.10.41 on 2025-07-27 01:00 +0700
fn abs(mut x: f64) -> f64 {
    if (x < 0.0) {
        return -x
    }
    return x
}

fn maxf(mut a: f64, mut b: f64) -> f64 {
    if (a > b) {
        return a
    }
    return b
}

fn isClose(mut a: f64, mut b: f64) -> bool {
    let relTol: f64 = 0.000000001;
    let t: f64 = abs((a - b));
    let u: f64 = (relTol * maxf(abs(a), abs(b)));
    return (t <= u)
}

fn sqrtApprox(mut x: f64) -> f64 {
    let mut guess: f64 = x;
    let mut i: i64 = 0;
    while (i < 10) {
        guess = ((guess + (x / guess)) / 2.0);
        i = (i + 1);
    }
    return guess
}

fn mochi_main() {
    let root2: f64 = sqrtApprox(2.0);
    let mut pairs: Vec<Vec<f64>> = vec![vec![100000000000000.02, 100000000000000.02], vec![100.01, 100.011], vec![(10000000000000.002 / 10000.0), 1000000000.0000001], vec![0.001, 0.0010000001], vec![0.000000000000000000000101, 0.0], vec![(root2 * root2), 2.0], vec![(-root2 * root2), -2.0], vec![100000000000000000.0, 100000000000000000.0], vec![3.141592653589793, 3.141592653589793]];
    for pair in &pairs {
        let a: i64 = (pair[0] as i64);
        let b: i64 = (pair[1] as i64);
        let s = if isClose((a as f64), (b as f64)) { "≈" } else { "≉" };
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", a.to_string(), " "), s), " "), b.to_string()));
    }
}

fn main() {
    mochi_main();
}
