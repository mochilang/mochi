// Generated by Mochi transpiler v0.10.56 on 2025-08-03 23:23 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
#[derive(Debug, Clone, Default)]
struct Pixel {
    R: i64,
    G: i64,
    B: i64,
}
impl std::fmt::Display for Pixel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"R\": {}", self.R)?;
        write!(f, ", ")?;
        write!(f, "\"G\": {}", self.G)?;
        write!(f, ", ")?;
        write!(f, "\"B\": {}", self.B)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Bitmap {
    cols: i64,
    rows: i64,
    px: Vec<Vec<Pixel>>,
}
impl std::fmt::Display for Bitmap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"cols\": {}", self.cols)?;
        write!(f, ", ")?;
        write!(f, "\"rows\": {}", self.rows)?;
        write!(f, ", ")?;
        write!(f, "\"px\": {:?}", self.px)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Map {
    ok: bool,
    pixel: Pixel,
}
impl std::fmt::Display for Map {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"ok\": {}", self.ok)?;
        write!(f, ", ")?;
        write!(f, "\"pixel\": {}", self.pixel)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Map1 {
    ok: bool,
    rgb: i64,
}
impl std::fmt::Display for Map1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"ok\": {}", self.ok)?;
        write!(f, ", ")?;
        write!(f, "\"rgb\": {}", self.rgb)?;
        write!(f, "}}")
    }
}

fn main() {
        let _start: i64 = _now();
    fn pixelFromRgb(mut c: i64) -> Pixel {
    let mut r: i64 = ((c / 65536) % 256);
    let mut g: i64 = ((c / 256) % 256);
    let mut b: i64 = (c % 256);
    return Pixel {R: r, G: g, B: b}
};
    fn rgbFromPixel(p: &Pixel) -> i64 {
    return (((p.R * 65536) + (p.G * 256)) + p.B)
};
    fn NewBitmap(mut x: i64, mut y: i64) -> Bitmap {
    let mut data: Vec<Vec<Pixel>> = vec![];
    let mut row: i64 = 0;
    while (row < y) {
        let mut r: Vec<Pixel> = vec![];
        let mut col: i64 = 0;
        while (col < x) {
            r = { let mut _v = r.clone(); _v.push(Pixel {R: 0, G: 0, B: 0}); _v };
            col = (col + 1);
        }
        data = { let mut _v = data.clone(); _v.push(r.clone()); _v };
        row = (row + 1);
    }
    return Bitmap {cols: x, rows: y, px: data}
};
    fn Extent(b: &Bitmap) -> HashMap<String, i64> {
    return HashMap::from([(String::from("cols"), b.cols), (String::from("rows"), b.rows)])
};
    fn Fill(b: &mut Bitmap, p: &Pixel) {
    let mut y: i64 = 0;
    while (y < b.rows) {
        let mut x: i64 = 0;
        while (x < b.cols) {
            let mut px: Vec<Vec<Pixel>> = b.px.clone();
            let mut row: Vec<Pixel> = px[y as usize].clone();
            row[x as usize] = p.clone();
            px[y as usize] = row.clone();
            (*b).px = px.clone();
            x = (x + 1);
        }
        y = (y + 1);
    }
};
    fn FillRgb(b: &mut Bitmap, mut c: i64) {
    Fill(b, &pixelFromRgb(c));
};
    fn SetPx(b: &mut Bitmap, mut x: i64, mut y: i64, p: &Pixel) -> bool {
    if ((((x < 0) || (x >= b.cols)) || (y < 0)) || (y >= b.rows)) {
        return false
    }
    let mut px: Vec<Vec<Pixel>> = b.px.clone();
    let mut row: Vec<Pixel> = px[y as usize].clone();
    row[x as usize] = p.clone();
    px[y as usize] = row.clone();
    (*b).px = px.clone();
    return true
};
    fn SetPxRgb(b: &mut Bitmap, mut x: i64, mut y: i64, mut c: i64) -> bool {
    return SetPx(b, x, y, &pixelFromRgb(c))
};
    fn GetPx(b: &Bitmap, mut x: i64, mut y: i64) -> Map {
    if ((((x < 0) || (x >= b.cols)) || (y < 0)) || (y >= b.rows)) {
        return Map {ok: false, pixel: Default::default()}
    }
    let mut row: Vec<Pixel> = b.px.clone()[y as usize].clone();
    return Map {ok: true, pixel: row[x as usize].clone()}
};
    fn GetPxRgb(b: &Bitmap, mut x: i64, mut y: i64) -> Map1 {
    let mut r: Map = GetPx(b, x, y);
    if !r.ok {
        return Map1 {ok: false, rgb: Default::default()}
    }
    return Map1 {ok: true, rgb: rgbFromPixel(&r.pixel)}
};
    fn ppmSize(b: &Bitmap) -> i64 {
    let mut header: String = format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "P6\n# Creator: Rosetta Code http://rosettacode.org/\n", b.cols.to_string()), " "), b.rows.to_string()), "\n255\n").clone();
    return ((header.len() as i64) + ((3 * b.cols) * b.rows))
};
    fn pixelStr(p: &Pixel) -> String {
    return format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "{", p.R.to_string()), " "), p.G.to_string()), " "), p.B.to_string()), "}").clone()
};
    fn mochi_main() {
    let mut bm: Bitmap = NewBitmap(300, 240);
    FillRgb(&mut bm, 16711680);
    SetPxRgb(&mut bm, 10, 20, 255);
    SetPxRgb(&mut bm, 20, 30, 0);
    SetPxRgb(&mut bm, 30, 40, 1056816);
    let mut c1: Map = GetPx(&bm, 0, 0);
    let mut c2: Map = GetPx(&bm, 10, 20);
    let mut c3: Map = GetPx(&bm, 30, 40);
    println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", "Image size: ", bm.cols.to_string()), " Ã— "), bm.rows.to_string()));
    println!("{}", format!("{}{}", ppmSize(&bm).to_string(), " bytes when encoded as PPM."));
    if c1.ok {
        println!("{}", format!("{}{}", "Pixel at (0,0) is ", pixelStr(&c1.pixel)));
    }
    if c2.ok {
        println!("{}", format!("{}{}", "Pixel at (10,20) is ", pixelStr(&c2.pixel)));
    }
    if c3.ok {
        let mut p: Pixel = c3.pixel;
        let mut r16: i64 = (p.R * 257);
        let mut g16: i64 = (p.G * 257);
        let mut b16: i64 = (p.B * 257);
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", format!("{}{}", "Pixel at (30,40) has R=", r16.to_string()), ", G="), g16.to_string()), ", B="), b16.to_string()));
    }
};
    mochi_main();
    let _end: i64 = _now();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = _mem();
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
