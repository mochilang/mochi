// Generated by Mochi transpiler v0.10.52 on 2025-08-01 22:47 +0700
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(p) = s.split_whitespace().next() {
                if let Ok(v) = p.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
fn main() {
        let _start_mem: i64 = _mem();
    let _start: i64 = _now();
    fn join(xs: &mut Vec<String>, sep: &str) -> String {
    let mut res: String = String::from("").clone();
    let mut i: i64 = 0;
    while (i < (xs.len() as i64)) {
        if (i > 0) {
            res = format!("{}{}", res, sep);
        }
        res = format!("{}{}", res, xs[i as usize].clone());
        i = (i + 1);
    }
    return res.clone()
};
    fn sortPairs(mut xs: Vec<HashMap<String, String>>) -> Vec<HashMap<String, String>> {
    let mut arr: Vec<HashMap<String, String>> = xs;
    let mut i: i64 = 1;
    while (i < (arr.len() as i64)) {
        let mut j: i64 = i;
        while ((j > 0) && ({ let n: i64 = arr[(j - 1) as usize].clone()["count"].clone().clone().parse().unwrap(); n } < { let n: i64 = arr[j as usize].clone()["count"].clone().clone().parse().unwrap(); n })) {
            let mut tmp: HashMap<String, String> = arr[(j - 1) as usize].clone();
            arr[(j - 1) as usize] = arr[j as usize].clone();
            arr[j as usize] = tmp;
            j = (j - 1);
        }
        i = (i + 1);
    }
    return arr
};
    fn isAlphaNumDot(ch: &str) -> bool {
    return ((((((ch >= "A") && (ch <= "Z")) || ((ch >= "a") && (ch <= "z"))) || ((ch >= "0") && (ch <= "9"))) || (ch == "_")) || (ch == "."))
};
    fn mochi_main() {
    let mut srcLines: Vec<String> = vec![String::from("package main"), String::from(""), String::from("import ("), String::from("    \"fmt\""), String::from("    \"go/ast\""), String::from("    \"go/parser\""), String::from("    \"go/token\""), String::from("    \"io/ioutil\""), String::from("    \"os\""), String::from("    \"sort\""), String::from(")"), String::from(""), String::from("func main() {"), String::from("    if len(os.Args) != 2 {"), String::from("        fmt.Println(\"usage ff <go source filename>\")"), String::from("        return"), String::from("    }"), String::from("    src, err := ioutil.ReadFile(os.Args[1])"), String::from("    if err != nil {"), String::from("        fmt.Println(err)"), String::from("        return"), String::from("    }"), String::from("    fs := token.NewFileSet()"), String::from("    a, err := parser.ParseFile(fs, os.Args[1], src, 0)"), String::from("    if err != nil {"), String::from("        fmt.Println(err)"), String::from("        return"), String::from("    }"), String::from("    f := fs.File(a.Pos())"), String::from("    m := make(map[string]int)"), String::from("    ast.Inspect(a, func(n ast.Node) bool {"), String::from("        if ce, ok := n.(*ast.CallExpr); ok {"), String::from("            start := f.Offset(ce.Pos())"), String::from("            end := f.Offset(ce.Lparen)"), String::from("            m[string(src[start:end])]++"), String::from("        }"), String::from("        return true"), String::from("    })"), String::from("    cs := make(calls, 0, len(m))"), String::from("    for k, v := range m {"), String::from("        cs = append(cs, &call{k, v})"), String::from("    }"), String::from("    sort.Sort(cs)"), String::from("    for i, c := range cs {"), String::from("        fmt.Printf(\"%-20s %4d\\n\", c.expr, c.count)"), String::from("        if i == 9 {"), String::from("            break"), String::from("        }"), String::from("    }"), String::from("}"), String::from(""), String::from("type call struct {"), String::from("    expr  string"), String::from("    count int"), String::from("}"), String::from("type calls []*call"), String::from(""), String::from("func (c calls) Len() int           { return len(c) }"), String::from("func (c calls) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }"), String::from("func (c calls) Less(i, j int) bool { return c[i].count > c[j].count }")];
    let mut src: String = join(&mut srcLines, &"\n").clone();
    let mut freq: HashMap<String, i64> = HashMap::from([]);
    let mut i: i64 = 0;
    let mut order: Vec<String> = vec![];
    while (i < (src.len() as i64)) {
        let mut ch: String = { let tmp = &src; tmp.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>() }.clone();
        if ((((ch.as_str() >= "A") && (ch.as_str() <= "Z")) || ((ch.as_str() >= "a") && (ch.as_str() <= "z"))) || (ch.as_str() == "_")) {
            let mut j: i64 = (i + 1);
            while ((j < (src.len() as i64)) && isAlphaNumDot(&{ let tmp = &src; tmp.chars().skip(j as usize).take(((j + 1) - j) as usize).collect::<String>() })) {
                j = (j + 1);
            }
            let mut token: String = { let tmp = &src; tmp.chars().skip(i as usize).take((j - i) as usize).collect::<String>() }.clone();
            let mut k: i64 = j;
            while (k < (src.len() as i64)) {
                let mut cc: String = { let tmp = &src; tmp.chars().skip(k as usize).take(((k + 1) - k) as usize).collect::<String>() }.clone();
                if ((((cc.as_str() == " ") || (cc.as_str() == "\t")) || (cc.as_str() == "\n")) || (cc.as_str() == "\r")) {
                    k = (k + 1);
                } else {
                    break
                }
            }
            if ((k < (src.len() as i64)) && ({ let tmp = &src; tmp.chars().skip(k as usize).take(((k + 1) - k) as usize).collect::<String>() }.as_str() == "(")) {
                let mut p: i64 = (i - 1);
                while ((p >= 0) && (({ let tmp = &src; tmp.chars().skip(p as usize).take(((p + 1) - p) as usize).collect::<String>() }.as_str() == " ") || ({ let tmp = &src; tmp.chars().skip(p as usize).take(((p + 1) - p) as usize).collect::<String>() }.as_str() == "\t"))) {
                    p = (p - 1);
                }
                let mut skip: bool = false;
                if (p >= 3) {
                    let mut before: String = { let tmp = &src; tmp.chars().skip((p - 3) as usize).take(((p + 1) - (p - 3)) as usize).collect::<String>() }.clone();
                    if (before.as_str() == "func") {
                        skip = true;
                    }
                }
                if !skip {
                    if freq.contains_key(&token) {
                        freq.insert(token.clone(), (freq[token.as_str()] + 1));
                    } else {
                        freq.insert(token.clone(), 1);
                        order = { let mut _v = order.clone(); _v.push(token.clone()); _v };
                    }
                }
            }
            i = j;
        } else {
            i = (i + 1);
        }
    }
    let mut pairs: Vec<HashMap<String, String>> = vec![];
    for t in order.clone() {
        pairs = { let mut _v = pairs.clone(); _v.push(HashMap::from([(String::from("expr"), String::from(t.clone())), (String::from("count"), format!("{}", freq[t.as_str()]))])); _v };
    }
    pairs = sortPairs(pairs.clone());
    let mut idx: i64 = 0;
    while ((idx < (pairs.len() as i64)) && (idx < 10)) {
        let mut p: HashMap<String, String> = pairs[idx as usize].clone();
        println!("{}", format!("{}{}", format!("{}{}", p["expr"].clone(), " "), p["count"].clone().to_string()));
        idx = (idx + 1);
    }
};
    mochi_main();
    let _end: i64 = _now();
    let _end_mem: i64 = _mem();
    let duration_us: i64 = ((_end - _start) / 1000);
    let memory_bytes: i64 = (_end_mem - _start_mem);
    println!("{{\n  \"duration_us\": {},\n  \"memory_bytes\": {},\n  \"name\": \"{}\"\n}}", duration_us, memory_bytes, "main");

}
