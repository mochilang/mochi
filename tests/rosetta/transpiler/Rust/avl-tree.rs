// Generated by Mochi transpiler v0.10.42 on 2025-07-27 16:50 +0700
use std::collections::HashMap;
#[derive(Debug, Clone, Default)]
struct Map {
    Data: i64,
    Balance: i64,
    Link: Vec<i64>,
}
impl std::fmt::Display for Map {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"Data\": {}", self.Data)?;
        write!(f, ", ")?;
        write!(f, "\"Balance\": {}", self.Balance)?;
        write!(f, ", ")?;
        write!(f, "\"Link\": {:?}", self.Link)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Map1 {
    node: HashMap<String, i64>,
    done: bool,
}
impl std::fmt::Display for Map1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"node\": {:?}", self.node)?;
        write!(f, ", ")?;
        write!(f, "\"done\": {}", self.done)?;
        write!(f, "}}")
    }
}

#[derive(Debug, Clone, Default)]
struct Map2 {
    node: f64,
    done: bool,
}
impl std::fmt::Display for Map2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{")?;
        write!(f, "\"node\": {}", self.node)?;
        write!(f, ", ")?;
        write!(f, "\"done\": {}", self.done)?;
        write!(f, "}}")
    }
}

fn Node(mut data: i64) -> Map {
    return Map {Data: data, Balance: 0, Link: vec![Default::default(), Default::default()]}
}

fn getLink(n: &HashMap<String, f64>, mut dir: i64) -> f64 {
    return n["Link".as_str()][dir]
}

fn setLink(mut n: HashMap<String, f64>, mut dir: i64, mut v: f64) {
    let mut links: f64 = n["Link".as_str()];
    links[dir] = v;
    n.insert("Link".clone(), links);
}

fn opp(mut dir: i64) -> i64 {
    return (1 - dir)
}

fn single(root: &HashMap<String, f64>, mut dir: i64) -> f64 {
    let mut tmp: f64 = getLink(root, opp(dir));
    setLink(root.clone(), opp(dir), getLink(&tmp, dir));
    setLink(tmp.clone(), dir, root);
    return tmp
}

fn double(root: &HashMap<String, f64>, mut dir: i64) -> f64 {
    let mut tmp: f64 = getLink(&getLink(root, opp(dir)), dir);
    setLink(getLink(root, opp(dir)), dir, getLink(&tmp, opp(dir)));
    setLink(tmp.clone(), opp(dir), getLink(root, opp(dir)));
    setLink(root.clone(), opp(dir), tmp);
    tmp = getLink(root, opp(dir));
    setLink(root.clone(), opp(dir), getLink(&tmp, dir));
    setLink(tmp.clone(), dir, root);
    return tmp
}

fn adjustBalance(mut root: HashMap<String, f64>, mut dir: i64, mut bal: i64) {
    let mut n: f64 = getLink(&root, dir);
    let mut nn: f64 = getLink(&n, opp(dir));
    if (nn["Balance".as_str()] == 0) {
        root.insert("Balance".clone(), 0);
        n["Balance"] = 0;
    } else if (nn["Balance".as_str()] == bal) {
        root.insert("Balance".clone(), -bal);
        n["Balance"] = 0;
    } else {
        root.insert("Balance".clone(), 0);
        n["Balance"] = bal;
    }
    nn["Balance"] = 0;
}

fn insertBalance(mut root: HashMap<String, f64>, mut dir: i64) -> f64 {
    let mut n: f64 = getLink(&root, dir);
    let mut bal: i64 = ((2 * dir) - 1);
    if (n["Balance".as_str()] == bal) {
        root.insert("Balance".clone(), 0);
        n["Balance"] = 0;
        return single(&root, opp(dir))
    }
    adjustBalance(root.clone(), dir, bal);
    return double(&root, opp(dir))
}

fn insertR(mut root: f64, mut data: i64) -> Map1 {
    if (root == Default::default()) {
        return Map1 {node: Node(data), done: false}
    }
    let mut node: f64 = root;
    let mut dir: i64 = 0;
    if (node["Data".as_str()] < data) {
        dir = 1;
    }
    let mut r: HashMap<String, f64> = insertR(getLink(&node, dir), data);
    setLink(node.clone(), dir, r["node".as_str()]);
    if true {
        return Map2 {node: node, done: true}
    }
    node["Balance"] = (node["Balance".as_str()] + ((2 * dir) - 1));
    if (node["Balance".as_str()] == 0) {
        return Map2 {node: node, done: true}
    }
    if ((node["Balance".as_str()] == 1) || (node["Balance".as_str()] == -1)) {
        return Map2 {node: node, done: false}
    }
    return Map1 {node: insertBalance(node.clone(), dir), done: true}
}

fn Insert(mut tree: f64, mut data: i64) -> f64 {
    let r: Map1 = insertR(tree, data);
    return r.node
}

fn removeBalance(mut root: HashMap<String, f64>, mut dir: i64) -> Map1 {
    let mut n: f64 = getLink(&root, opp(dir));
    let mut bal: i64 = ((2 * dir) - 1);
    if (n["Balance".as_str()] == -bal) {
        root.insert("Balance".clone(), 0);
        n["Balance"] = 0;
        return Map1 {node: single(&root, dir), done: false}
    }
    if (n["Balance".as_str()] == bal) {
        adjustBalance(root.clone(), opp(dir), -bal);
        return Map1 {node: double(&root, dir), done: false}
    }
    root.insert("Balance".clone(), -bal);
    n["Balance"] = bal;
    return Map1 {node: single(&root, dir), done: true}
}

fn removeR(mut root: f64, mut data: i64) -> Map1 {
    if (root == Default::default()) {
        return Map2 {node: Default::default(), done: false}
    }
    let mut node: f64 = root;
    if (node["Data".as_str()] == data) {
        if (getLink(&node, 0) == Default::default()) {
            return Map2 {node: getLink(&node, 1), done: false}
        }
        if (getLink(&node, 1) == Default::default()) {
            return Map2 {node: getLink(&node, 0), done: false}
        }
        let mut heir: f64 = getLink(&node, 0);
        while (getLink(&heir, 1) != Default::default()) {
            heir = getLink(&heir, 1);
        }
        node["Data"] = heir["Data".as_str()];
        data = heir["Data".as_str()];
    }
    let mut dir: i64 = 0;
    if (node["Data".as_str()] < data) {
        dir = 1;
    }
    let mut r: HashMap<String, f64> = removeR(getLink(&node, dir), data);
    setLink(node.clone(), dir, r["node".as_str()]);
    if true {
        return Map2 {node: node, done: true}
    }
    node["Balance"] = ((node["Balance".as_str()] + 1) - (2 * dir));
    if ((node["Balance".as_str()] == 1) || (node["Balance".as_str()] == -1)) {
        return Map2 {node: node, done: true}
    }
    if (node["Balance".as_str()] == 0) {
        return Map2 {node: node, done: false}
    }
    return removeBalance(node.clone(), dir)
}

fn Remove(mut tree: f64, mut data: i64) -> f64 {
    let r: Map1 = removeR(tree, data);
    return r.node
}

fn indentStr(mut n: i64) -> String {
    let mut s = String::from("");
    let mut i: i64 = 0;
    while (i < n) {
        s = format!("{}{}", s, " ");
        i = (i + 1);
    }
    return s.clone()
}

fn dumpNode(mut node: f64, mut indent: i64, mut comma: bool) {
    let sp: String = indentStr(indent).clone();
    if (node == Default::default()) {
        let mut line: String = format!("{}{}", sp, "null").clone();
        if comma {
            line = format!("{}{}", line, ",");
        }
        println!("{}", line);
    } else {
        println!("{}", format!("{}{}", sp, "{"));
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", indentStr((indent + 3)), "\"Data\": "), node["Data".as_str()].to_string()), ","));
        println!("{}", format!("{}{}", format!("{}{}", format!("{}{}", indentStr((indent + 3)), "\"Balance\": "), node["Balance".as_str()].to_string()), ","));
        println!("{}", format!("{}{}", indentStr((indent + 3)), "\"Link\": ["));
        dumpNode(getLink(&node, 0), (indent + 6), true);
        dumpNode(getLink(&node, 1), (indent + 6), false);
        println!("{}", format!("{}{}", indentStr((indent + 3)), "]"));
        let mut end: String = format!("{}{}", sp, "}").clone();
        if comma {
            end = format!("{}{}", end, ",");
        }
        println!("{}", end);
    }
}

fn dump(mut node: f64, mut indent: i64) {
    dumpNode(node, indent, false);
}

fn mochi_main() {
    let mut tree = Default::default();
    println!("{}", "Empty tree:");
    dump(tree, 0);
    println!("{}", "");
    println!("{}", "Insert test:");
    tree = Insert(tree, 3);
    tree = Insert(tree, 1);
    tree = Insert(tree, 4);
    tree = Insert(tree, 1);
    tree = Insert(tree, 5);
    dump(tree, 0);
    println!("{}", "");
    println!("{}", "Remove test:");
    tree = Remove(tree, 3);
    tree = Remove(tree, 1);
    let mut t: f64 = tree;
    t["Balance"] = 0;
    tree = t;
    dump(tree, 0);
}

fn main() {
    mochi_main();
}
