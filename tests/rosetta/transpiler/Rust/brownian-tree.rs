// Generated by Mochi transpiler v0.10.56 on 2025-08-04 07:49 +0700
use std::sync::atomic::{AtomicBool, AtomicI64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
static NOW_SEEDED: AtomicBool = AtomicBool::new(false);
static NOW_SEED: AtomicI64 = AtomicI64::new(0);
fn _now() -> i64 {
    if !NOW_SEEDED.load(Ordering::SeqCst) {
        if let Ok(s) = std::env::var("MOCHI_NOW_SEED") {
            if let Ok(v) = s.parse::<i64>() {
                NOW_SEED.store(v, Ordering::SeqCst);
                NOW_SEEDED.store(true, Ordering::SeqCst);
            }
        }
    }
    if NOW_SEEDED.load(Ordering::SeqCst) {
        let seed = (NOW_SEED.load(Ordering::SeqCst)*1664525 + 1013904223) % 2147483647;
        NOW_SEED.store(seed, Ordering::SeqCst);
        seed
    } else {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as i64
    }
}
fn _mem() -> i64 {
    if let Ok(mut f) = std::fs::File::open("/proc/self/statm") {
        let mut s = String::new();
        use std::io::Read;
        if f.read_to_string(&mut s).is_ok() {
            if let Some(rss) = s.split_whitespace().nth(1) {
                if let Ok(v) = rss.parse::<i64>() {
                    return v * 4096;
                }
            }
        }
    }
    0
}
static mut g_w: i64 = 0;
static mut g_h: i64 = 0;
static mut g_n: i64 = 0;
static mut g_frost: i64 = 0;
static mut g_grid: Vec<Vec<i64>> = Vec::new();
static mut g_y: i64 = 0;
static mut g_a: i64 = 0;
unsafe fn inBounds(mut x: i64, mut y: i64) -> bool {
    return ((((x >= 0) && (x < g_w)) && (y >= 0)) && (y < g_h))
}

unsafe fn hasNeighbor(mut x: i64, mut y: i64) -> bool {
    let mut dy: i64 = -1;
    while (dy <= 1) {
        let mut dx: i64 = -1;
        while (dx <= 1) {
            if !((dx == 0) && (dy == 0)) {
                let mut nx: i64 = (x + dx);
                let mut ny: i64 = (y + dy);
                if (inBounds(nx, ny) && (g_grid.clone()[ny as usize].clone()[nx as usize] == g_frost)) {
                    return true
                }
            }
            dx = (dx + 1);
        }
        dy = (dy + 1);
    }
    return false
}

fn main() {
    unsafe {
        g_w = 400;
        g_h = 300;
        g_n = 15000;
        g_frost = 255;
        g_grid = vec![];
        g_y = 0;
        g_a = 0;
        while (g_y < g_h) {
            let mut row: Vec<i64> = vec![];
            let mut x: i64 = 0;
            while (x < g_w) {
                row = { let mut _v = row.clone(); _v.push(0); _v };
                x = (x + 1);
            }
            g_grid = { let mut _v = g_grid.clone().clone(); _v.push(row.clone()); _v };
            g_y = (g_y + 1);
        }
        g_grid[(g_h / 3) as usize][(g_w / 3) as usize] = g_frost;
        while (g_a < g_n) {
            let mut px = (_now() % g_w);
            let mut py = (_now() % g_h);
            if (g_grid.clone()[py as usize].clone()[px as usize] == g_frost) {
                let mut lost: bool = false;
                loop {
                    px = ((px + (_now() % 3)) - 1);
                    py = ((py + (_now() % 3)) - 1);
                    if !inBounds(px, py) {
                        lost = true;
                        break
                    }
                    if (g_grid.clone()[py as usize].clone()[px as usize] != g_frost) {
                        break
                    }
                }
                if lost {
                    continue
                }
            } else {
                let mut lost: bool = false;
                while !hasNeighbor(px, py) {
                    px = ((px + (_now() % 3)) - 1);
                    py = ((py + (_now() % 3)) - 1);
                    if !inBounds(px, py) {
                        lost = true;
                        break
                    }
                }
                if lost {
                    continue
                }
            }
            g_grid[py as usize][px as usize] = g_frost;
            g_a = (g_a + 1);
        }
    }
}
