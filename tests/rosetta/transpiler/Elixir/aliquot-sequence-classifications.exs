# Code generated by Mochi transpiler 2025-07-25 21:06 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) -> String.slice(base, start, len)
      len == 1 -> Enum.at(base, start)
      true -> Enum.slice(base, start, len)
    end
  end
  def indexOf(xs, value) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < length(xs) do
          if Enum.at(xs, i) == value do
            throw {:return, i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          :break -> i
        end

      throw {:return, 0 - 1}
    catch
      {:return, val} -> val
    end
  end
  def contains(xs, value) do
    try do
      throw {:return, indexOf(xs, value) != 0 - 1}
    catch
      {:return, val} -> val
    end
  end
  def maxOf(a, b) do
    try do
      if a > b do
        throw {:return, a}
      else
        throw {:return, b}
      end
    catch
      {:return, val} -> val
    end
  end
  def intSqrt(n) do
    try do
      if n == 0 do
        throw {:return, 0}
      end
      x = n
      y = div((x + 1), 2)
      while_fun_2 = fn while_fun_2, x, y ->
        if y < x do
          x = y
          y = div((x + div(n, x)), 2)
          while_fun_2.(while_fun_2, x, y)
        else
          {x, y}
        end
      end
      {x, y} = try do
          while_fun_2.(while_fun_2, x, y)
        catch
          :break -> {x, y}
        end

      throw {:return, x}
    catch
      {:return, val} -> val
    end
  end
  def sumProperDivisors(n) do
    try do
      if n < 2 do
        throw {:return, 0}
      end
      sqrt = intSqrt(n)
      sum = 1
      i = 2
      while_fun_3 = fn while_fun_3, i, sum ->
        if i <= sqrt do
          if rem(n, i) == 0 do
            sum = sum + i + div(n, i)
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, sum)
        else
          {i, sum}
        end
      end
      {i, sum} = try do
          while_fun_3.(while_fun_3, i, sum)
        catch
          :break -> {i, sum}
        end

      if sqrt * sqrt == n do
        sum = sum - sqrt
      end
      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def classifySequence(k) do
    try do
      last = k
      seq = [k]
      while_fun_4 = fn while_fun_4, last, seq ->
        if true do
          last = sumProperDivisors(last)
          seq = (seq ++ [last])
          n = length(seq)
          aliquot = ""
          {aliquot} = if last == 0 do
            aliquot = "Terminating"
            {aliquot}
          else
            {aliquot} = if n == 2 && last == k do
              aliquot = "Perfect"
              {aliquot}
            else
              {aliquot} = if n == 3 && last == k do
                aliquot = "Amicable"
                {aliquot}
              else
                {aliquot} = if n >= 4 && last == k do
                  aliquot = (("Sociable[" <> to_string(n - 1)) <> "]")
                  {aliquot}
                else
                  {aliquot} = if last == Enum.at(seq, n - 2) do
                    aliquot = "Aspiring"
                    {aliquot}
                  else
                    {aliquot} = if contains(_slice(seq, 1, maxOf(1, n - 2) - 1), last) do
                      idx = indexOf(seq, last)
                      aliquot = (("Cyclic[" <> to_string(n - 1 - idx)) <> "]")
                      {aliquot}
                    else
                      {aliquot} = if n == 16 || last > Process.get(:threshold) do
                        aliquot = "Non-Terminating"
                        {aliquot}
                      else
                        {aliquot}
                      end
                      {aliquot}
                    end
                    {aliquot}
                  end
                  {aliquot}
                end
                {aliquot}
              end
              {aliquot}
            end
            {aliquot}
          end
          if aliquot != "" do
            throw {:return, %{"seq" => seq, "aliquot" => aliquot}}
          end
          while_fun_4.(while_fun_4, last, seq)
        else
          {last, seq}
        end
      end
      {last, seq} = try do
          while_fun_4.(while_fun_4, last, seq)
        catch
          :break -> {last, seq}
        end

      throw {:return, %{"seq" => seq, "aliquot" => ""}}
    catch
      {:return, val} -> val
    end
  end
  def padLeft(n, w) do
    try do
      s = to_string(n)
      while_fun_5 = fn while_fun_5, s ->
        if String.length(s) < w do
          s = (" " <> s)
          while_fun_5.(while_fun_5, s)
        else
          s
        end
      end
      s = try do
          while_fun_5.(while_fun_5, s)
        catch
          :break -> s
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def padRight(s, w) do
    try do
      r = s
      while_fun_6 = fn while_fun_6, r ->
        if String.length(r) < w do
          r = (r <> " ")
          while_fun_6.(while_fun_6, r)
        else
          r
        end
      end
      r = try do
          while_fun_6.(while_fun_6, r)
        catch
          :break -> r
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def joinWithCommas(seq) do
    try do
      s = "["
      i = 0
      while_fun_7 = fn while_fun_7, i, s ->
        if i < length(seq) do
          s = (s <> to_string(Enum.at(seq, i)))
          if i < length(seq) - 1 do
            s = (s <> ", ")
          end
          i = i + 1
          while_fun_7.(while_fun_7, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_7.(while_fun_7, i, s)
        catch
          :break -> {i, s}
        end

      s = (s <> "]")
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts("Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n")
      k = 1
      while_fun_8 = fn while_fun_8, k ->
        if k <= 10 do
          res = classifySequence(k)
          IO.puts(Kernel.to_string(((((padLeft(k, 2) <> ": ") <> padRight(res["aliquot"], 15)) <> " ") <> joinWithCommas(res["seq"]))))
          k = k + 1
          while_fun_8.(while_fun_8, k)
        else
          k
        end
      end
      k = try do
          while_fun_8.(while_fun_8, k)
        catch
          :break -> k
        end

      IO.puts("")
      s = [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]
      i = 0
      while_fun_9 = fn while_fun_9, i ->
        if i < length(s) do
          val = Enum.at(s, i)
          res = classifySequence(val)
          IO.puts(Kernel.to_string(((((padLeft(val, 7) <> ": ") <> padRight(res["aliquot"], 15)) <> " ") <> joinWithCommas(res["seq"]))))
          i = i + 1
          while_fun_9.(while_fun_9, i)
        else
          i
        end
      end
      i = try do
          while_fun_9.(while_fun_9, i)
        catch
          :break -> i
        end

      IO.puts("")
      big = 15355717786080
      r = classifySequence(big)
      IO.puts(((((to_string(big) <> ": ") <> padRight(r["aliquot"], 15)) <> " ") <> joinWithCommas(r["seq"])))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:threshold, 140737488355328)
  def bench_main() do
    Process.put(:threshold, 140737488355328)
    mem_start = _mem()
    t_start = _now()
    main()
    duration_us = div(_now() - t_start, 1000)
    mem_diff = abs(_mem() - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
