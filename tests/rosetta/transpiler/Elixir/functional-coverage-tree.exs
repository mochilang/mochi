# Code generated by Mochi transpiler 2025-08-05 00:37 +0700
defmodule Main do
  def _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      System.unique_integer([:positive, :monotonic])
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    n = trunc(n)
    d = trunc(d)
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  defp _sha256(bs) do
    bin = :erlang.list_to_binary(bs)
    :crypto.hash(:sha256, bin) |> :erlang.binary_to_list()
  end
  defp _getenv(name) do
    System.get_env(name)
  end
  defp _environ() do
    System.get_env() |> Enum.map(fn {k, v} -> "#{k}=#{v}" end)
  end
  defp _getoutput(cmd) do
    {out, 0} = System.cmd("sh", ["-c", cmd])
    String.trim(out)
  end
  def pow10(n) do
    try do
      r = 1.0
      i = 0
      while_fun = fn while_fun, i, r ->
        if i < n do
          r = r * 10.0
          i = i + 1
          while_fun.(while_fun, i, r)
        else
          {i, r}
        end
      end
      {i, r} = try do
          while_fun.(while_fun, i, r)
        catch
          {:break, {i, r}} -> {i, r}
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def formatFloat(f, prec) do
    try do
      scale = pow10(prec)
      scaled = (f * scale) + 0.5
      n = ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(scaled))
      digits = Kernel.to_string(n)
      while_fun_2 = fn while_fun_2, digits ->
        if _len(digits) <= prec do
          digits = ("0" <> digits)
          while_fun_2.(while_fun_2, digits)
        else
          digits
        end
      end
      digits = try do
          while_fun_2.(while_fun_2, digits)
        catch
          {:break, {digits}} -> digits
        end

      intPart = _slice(digits, 0, _len(digits) - prec - (0))
      fracPart = _slice(digits, _len(digits) - prec, _len(digits) - (_len(digits) - prec))
      throw {:return, ((intPart <> ".") <> fracPart)}
    catch
      {:return, val} -> val
    end
  end
  def padLeft(s, w) do
    try do
      res = ""
      n = w - _len(s)
      while_fun_3 = fn while_fun_3, n, res ->
        if n > 0 do
          res = (res <> " ")
          n = n - 1
          while_fun_3.(while_fun_3, n, res)
        else
          {n, res}
        end
      end
      {n, res} = try do
          while_fun_3.(while_fun_3, n, res)
        catch
          {:break, {n, res}} -> {n, res}
        end

      throw {:return, (res <> s)}
    catch
      {:return, val} -> val
    end
  end
  def repeat(ch, n) do
    try do
      s = ""
      i = 0
      while_fun_4 = fn while_fun_4, i, s ->
        if i < n do
          s = (s <> ch)
          i = i + 1
          while_fun_4.(while_fun_4, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_4.(while_fun_4, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def toFloat(i) do
    try do
      throw {:return, i}
    catch
      {:return, val} -> val
    end
  end
  def newNode(name, weight, coverage) do
    try do
      throw {:return, %{"name" => name, "weight" => weight, "coverage" => coverage, "children" => []}}
    catch
      {:return, val} -> val
    end
  end
  def addChildren(n, nodes) do
    try do
      cs = n["children"]
      {cs} = Enum.reduce(nodes, {cs}, fn node_, {cs} ->
        cs = (cs ++ [node_])
        {cs}
      end)
      n = Map.put(n, "children", cs)
    catch
      {:return, val} -> val
    end
  end
  def setCoverage(n, value) do
    try do
      n = Map.put(n, "coverage", value)
    catch
      {:return, val} -> val
    end
  end
  def computeCoverage(n) do
    try do
      cs = n["children"]
      if _len(cs) == 0 do
        throw {:return, n["coverage"]}
      end
      v1 = 0.0
      v2 = 0
      {v1, v2} = Enum.reduce(cs, {v1, v2}, fn node_, {v1, v2} ->
        m = node_
        c = computeCoverage(m)
        v1 = v1 + toFloat((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(m["weight"])) * c
        v2 = v2 + ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(m["weight"]))
        {v1, v2}
      end)
      throw {:return, v1 / toFloat(v2)}
    catch
      {:return, val} -> val
    end
  end
  def spaces(n) do
    try do
      throw {:return, repeat(" ", n)}
    catch
      {:return, val} -> val
    end
  end
  def show(n, level) do
    try do
      indent = level * 4
      name = n["name"]
      nl = _len(name) + indent
      line = (spaces(indent) <> name)
      line = ((line <> spaces(32 - nl)) <> "|  ")
      line = ((line <> padLeft(Kernel.to_string((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(n["weight"])), 3)) <> "   | ")
      line = ((line <> formatFloat(computeCoverage(n), 6)) <> " |")
      IO.puts(line)
      cs = n["children"]
      Enum.each(cs, fn child ->
        show(child, level + 1)
      end)
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      cleaning = newNode("cleaning", 1, 0.0)
      addChildren(Process.get(:h1_bathrooms), [Process.get(:h1_bathroom1), Process.get(:h1_bathroom2), Process.get(:h1_outside)])
      addChildren(Process.get(:h1_living_rooms), [Process.get(:h1_lounge), Process.get(:h1_dining), Process.get(:h1_conservatory), Process.get(:h1_playroom)])
      addChildren(Process.get(:house1), [Process.get(:h1_bedrooms), Process.get(:h1_bathrooms), Process.get(:h1_attic), Process.get(:h1_kitchen), Process.get(:h1_living_rooms), Process.get(:h1_basement), Process.get(:h1_garage), Process.get(:h1_garden)])
      addChildren(Process.get(:h2_bedrooms), [Process.get(:h2_suite1), Process.get(:h2_suite2), Process.get(:h2_bedroom3), Process.get(:h2_bedroom4)])
      addChildren(Process.get(:h2_upstairs), [Process.get(:h2_bedrooms), Process.get(:h2_bathroom), Process.get(:h2_toilet), Process.get(:h2_attics)])
      addChildren(Process.get(:h2_living_rooms), [Process.get(:h2_lounge), Process.get(:h2_dining), Process.get(:h2_conservatory), Process.get(:h2_playroom)])
      addChildren(Process.get(:h2_groundfloor), [Process.get(:h2_kitchen), Process.get(:h2_living_rooms), Process.get(:h2_wet_room), Process.get(:h2_garage), Process.get(:h2_garden), Process.get(:h2_hot_tub)])
      addChildren(Process.get(:h2_basement), [Process.get(:h2_cellars), Process.get(:h2_wine_cellar), Process.get(:h2_cinema)])
      addChildren(Process.get(:house2), [Process.get(:h2_upstairs), Process.get(:h2_groundfloor), Process.get(:h2_basement)])
      addChildren(cleaning, [Process.get(:house1), Process.get(:house2)])
      topCoverage = computeCoverage(cleaning)
      IO.puts(("TOP COVERAGE = " <> formatFloat(topCoverage, 6)))
      IO.puts("")
      IO.puts("NAME HIERARCHY                 | WEIGHT | COVERAGE |")
      show(cleaning, 0)
      setCoverage(Process.get(:h2_cinema), 1.0)
      diff = computeCoverage(cleaning) - topCoverage
      IO.puts("")
      IO.puts("If the coverage of the Cinema node were increased from 0.75 to 1")
      IO.puts(((("the top level coverage would increase by " <> formatFloat(diff, 6)) <> " to ") <> formatFloat(topCoverage + diff, 6)))
      setCoverage(Process.get(:h2_cinema), 0.75)
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Process.put(:house1, Main.newNode("house1", 40, 0.0))
Process.put(:house2, Main.newNode("house2", 60, 0.0))
Process.put(:h1_bedrooms, Main.newNode("bedrooms", 1, 0.25))
Process.put(:h1_bathrooms, Main.newNode("bathrooms", 1, 0.0))
Process.put(:h1_attic, Main.newNode("attic", 1, 0.75))
Process.put(:h1_kitchen, Main.newNode("kitchen", 1, 0.1))
Process.put(:h1_living_rooms, Main.newNode("living_rooms", 1, 0.0))
Process.put(:h1_basement, Main.newNode("basement", 1, 0.0))
Process.put(:h1_garage, Main.newNode("garage", 1, 0.0))
Process.put(:h1_garden, Main.newNode("garden", 1, 0.8))
Process.put(:h2_upstairs, Main.newNode("upstairs", 1, 0.0))
Process.put(:h2_groundfloor, Main.newNode("groundfloor", 1, 0.0))
Process.put(:h2_basement, Main.newNode("basement", 1, 0.0))
Process.put(:h1_bathroom1, Main.newNode("bathroom1", 1, 0.5))
Process.put(:h1_bathroom2, Main.newNode("bathroom2", 1, 0.0))
Process.put(:h1_outside, Main.newNode("outside_lavatory", 1, 1.0))
Process.put(:h1_lounge, Main.newNode("lounge", 1, 0.0))
Process.put(:h1_dining, Main.newNode("dining_room", 1, 0.0))
Process.put(:h1_conservatory, Main.newNode("conservatory", 1, 0.0))
Process.put(:h1_playroom, Main.newNode("playroom", 1, 1.0))
Process.put(:h2_bedrooms, Main.newNode("bedrooms", 1, 0.0))
Process.put(:h2_bathroom, Main.newNode("bathroom", 1, 0.0))
Process.put(:h2_toilet, Main.newNode("toilet", 1, 0.0))
Process.put(:h2_attics, Main.newNode("attics", 1, 0.6))
Process.put(:h2_kitchen, Main.newNode("kitchen", 1, 0.0))
Process.put(:h2_living_rooms, Main.newNode("living_rooms", 1, 0.0))
Process.put(:h2_wet_room, Main.newNode("wet_room_&_toilet", 1, 0.0))
Process.put(:h2_garage, Main.newNode("garage", 1, 0.0))
Process.put(:h2_garden, Main.newNode("garden", 1, 0.9))
Process.put(:h2_hot_tub, Main.newNode("hot_tub_suite", 1, 1.0))
Process.put(:h2_cellars, Main.newNode("cellars", 1, 1.0))
Process.put(:h2_wine_cellar, Main.newNode("wine_cellar", 1, 1.0))
Process.put(:h2_cinema, Main.newNode("cinema", 1, 0.75))
Process.put(:h2_suite1, Main.newNode("suite_1", 1, 0.0))
Process.put(:h2_suite2, Main.newNode("suite_2", 1, 0.0))
Process.put(:h2_bedroom3, Main.newNode("bedroom_3", 1, 0.0))
Process.put(:h2_bedroom4, Main.newNode("bedroom_4", 1, 0.0))
Process.put(:h2_lounge, Main.newNode("lounge", 1, 0.0))
Process.put(:h2_dining, Main.newNode("dining_room", 1, 0.0))
Process.put(:h2_conservatory, Main.newNode("conservatory", 1, 0.0))
Process.put(:h2_playroom, Main.newNode("playroom", 1, 0.0))
Main.bench_main()
