# Code generated by Mochi transpiler 2025-07-26 19:45 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) -> String.slice(base, start, len)
      len == 1 -> Enum.slice(base, start, len)
      true -> Enum.slice(base, start, len)
    end
  end
  def skipWS(p) do
    try do
      i = p.pos
      while_fun = fn while_fun, i ->
        if i < String.length(Map.get(p, :expr, "")) && String.slice(p.expr, i, i + 1 - (i)) == " " do
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          :break -> i
        end

      p = Map.put(p, :pos, i)
      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def parseIntStr(str) do
    try do
      i = 0
      n = 0
      while_fun_2 = fn while_fun_2, i, n ->
        if i < String.length(str) do
          n = n * 10 + (trunc(String.slice(str, i, i + 1 - i))) - 48
          i = i + 1
          while_fun_2.(while_fun_2, i, n)
        else
          {i, n}
        end
      end
      {i, n} = try do
          while_fun_2.(while_fun_2, i, n)
        catch
          :break -> {i, n}
        end

      throw {:return, n}
    catch
      {:return, val} -> val
    end
  end
  def parseNumber(p) do
    try do
      p = Main.skipWS(p)
      start = p.pos
      while_fun_3 = fn while_fun_3, p ->
        if p.pos < String.length(Map.get(p, :expr, "")) do
          try do
            ch = String.slice(p.expr, p.pos, p.pos + 1 - (p.pos))
            if ch >= "0" && ch <= "9" do
              p = Map.put(p, :pos, p.pos + 1)
            else
              throw :break
            end
          catch
            :continue -> nil
          end
          while_fun_3.(while_fun_3, p)
        else
          p
        end
      end
      p = try do
          while_fun_3.(while_fun_3, p)
        catch
          :break -> p
        end

      token = String.slice(p.expr, start, p.pos - (start))
      throw {:return, %{v: Main.parseIntStr(token), p: p}}
    catch
      {:return, val} -> val
    end
  end
  def parseFactor(p) do
    try do
      p = Main.skipWS(p)
      {p} = if p.pos < String.length(Map.get(p, :expr, "")) && String.slice(p.expr, p.pos, p.pos + 1 - (p.pos)) == "(" do
        p = Map.put(p, :pos, p.pos + 1)
        r = Main.parseExpr(p)
        v = r.v
        p = r.p
        p = Main.skipWS(p)
        {p} = if p.pos < String.length(Map.get(p, :expr, "")) && String.slice(p.expr, p.pos, p.pos + 1 - (p.pos)) == ")" do
          p = Map.put(p, :pos, p.pos + 1)
          {p}
        else
          {p}
        end
        throw {:return, %{v: v, p: p}}
        {p}
      else
        {p}
      end
      {p} = if p.pos < String.length(Map.get(p, :expr, "")) && String.slice(p.expr, p.pos, p.pos + 1 - (p.pos)) == "-" do
        p = Map.put(p, :pos, p.pos + 1)
        r = Main.parseFactor(p)
        v = r.v
        p = r.p
        throw {:return, %{v: -v, p: p}}
        {p}
      else
        {p}
      end
      throw {:return, Main.parseNumber(p)}
    catch
      {:return, val} -> val
    end
  end
  def powInt(base, exp) do
    try do
      r = 1
      b = base
      e = exp
      while_fun_4 = fn while_fun_4, b, e, r ->
        if e > 0 do
          if rem(e, 2) == 1 do
            r = r * b
          end
          b = b * b
          e = div(e, trunc(2))
          while_fun_4.(while_fun_4, b, e, r)
        else
          {b, e, r}
        end
      end
      {b, e, r} = try do
          while_fun_4.(while_fun_4, b, e, r)
        catch
          :break -> {b, e, r}
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def parsePower(p) do
    try do
      r = Main.parseFactor(p)
      v = r.v
      p = r.p
      while_fun_5 = fn while_fun_5, p, v ->
        if true do
          try do
            p = Main.skipWS(p)
            if p.pos < String.length(Map.get(p, :expr, "")) && String.slice(p.expr, p.pos, p.pos + 1 - (p.pos)) == "^" do
              p = Map.put(p, :pos, p.pos + 1)
              r2 = Main.parseFactor(p)
              rhs = r2.v
              p = r2.p
              v = Main.powInt(v, rhs)
            else
              throw :break
            end
          catch
            :continue -> nil
          end
          while_fun_5.(while_fun_5, p, v)
        else
          {p, v}
        end
      end
      {p, v} = try do
          while_fun_5.(while_fun_5, p, v)
        catch
          :break -> {p, v}
        end

      throw {:return, %{v: v, p: p}}
    catch
      {:return, val} -> val
    end
  end
  def parseTerm(p) do
    try do
      r = Main.parsePower(p)
      v = r.v
      p = r.p
      while_fun_6 = fn while_fun_6, p, v ->
        if true do
          try do
            p = Main.skipWS(p)
            if p.pos < String.length(Map.get(p, :expr, "")) do
              op = String.slice(p.expr, p.pos, p.pos + 1 - (p.pos))
              if op == "*" do
                p = Map.put(p, :pos, p.pos + 1)
                r2 = Main.parsePower(p)
                rhs = r2.v
                p = r2.p
                v = v * rhs
                throw :continue
              end
              if op == "/" do
                p = Map.put(p, :pos, p.pos + 1)
                r2 = Main.parsePower(p)
                rhs = r2.v
                p = r2.p
                v = v / trunc(rhs)
                throw :continue
              end
            end
            throw :break
          catch
            :continue -> nil
          end
          while_fun_6.(while_fun_6, p, v)
        else
          {p, v}
        end
      end
      {p, v} = try do
          while_fun_6.(while_fun_6, p, v)
        catch
          :break -> {p, v}
        end

      throw {:return, %{v: v, p: p}}
    catch
      {:return, val} -> val
    end
  end
  def parseExpr(p) do
    try do
      r = Main.parseTerm(p)
      v = r.v
      p = r.p
      while_fun_7 = fn while_fun_7, p, v ->
        if true do
          try do
            p = Main.skipWS(p)
            if p.pos < String.length(Map.get(p, :expr, "")) do
              op = String.slice(p.expr, p.pos, p.pos + 1 - (p.pos))
              if op == "+" do
                p = Map.put(p, :pos, p.pos + 1)
                r2 = Main.parseTerm(p)
                rhs = r2.v
                p = r2.p
                v = v + rhs
                throw :continue
              end
              if op == "-" do
                p = Map.put(p, :pos, p.pos + 1)
                r2 = Main.parseTerm(p)
                rhs = r2.v
                p = r2.p
                v = v - rhs
                throw :continue
              end
            end
            throw :break
          catch
            :continue -> nil
          end
          while_fun_7.(while_fun_7, p, v)
        else
          {p, v}
        end
      end
      {p, v} = try do
          while_fun_7.(while_fun_7, p, v)
        catch
          :break -> {p, v}
        end

      throw {:return, %{v: v, p: p}}
    catch
      {:return, val} -> val
    end
  end
  def evalExpr(expr) do
    try do
      p = %{expr: expr, pos: 0}
      r = Main.parseExpr(p)
      throw {:return, r.v}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      expr = "2*(3-1)+2*5"
      IO.puts(((expr <> " = ") <> to_string(Main.evalExpr(expr))))
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
