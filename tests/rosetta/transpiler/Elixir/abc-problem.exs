# Code generated by Mochi transpiler 2025-07-25 01:20 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  def fields(s) do
    try do
      res = []
      cur = ""
      i = 0
      while_fun = fn while_fun, cur, i, res ->
        if i < String.length(s) do
          c = String.slice(s, i, i + 1 - i)
          if c == " " do
            if String.length(cur) > 0 do
              res = (res ++ [cur])
              cur = ""
            end
          else
            cur = (cur <> c)
          end
          i = i + 1
          while_fun.(while_fun, cur, i, res)
        else
          {cur, i, res}
        end
      end
      {cur, i, res} = try do
          while_fun.(while_fun, cur, i, res)
        catch
          :break -> {cur, i, res}
        end

      {res} = if String.length(cur) > 0 do
        res = (res ++ [cur])
        {res}
      else
        {res}
      end
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def canSpell(word, blks) do
    try do
      if String.length(word) == 0 do
        throw {:return, true}
      end
      c = String.downcase(String.slice(word, 0, 1 - 0))
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < length(blks) do
          b = Enum.at(blks, i)
          if c == String.downcase(String.slice(b, 0, 1 - 0)) || c == String.downcase(String.slice(b, 1, 2 - 1)) do
            rest = []
            j = 0
            while_fun_3 = fn while_fun_3, j, rest ->
              if j < length(blks) do
                if j != i do
                  rest = (rest ++ [Enum.at(blks, j)])
                end
                j = j + 1
                while_fun_3.(while_fun_3, j, rest)
              else
                {j, rest}
              end
            end
            {j, rest} = try do
                while_fun_3.(while_fun_3, j, rest)
              catch
                :break -> {j, rest}
              end

            if canSpell(String.slice(word, 1, String.length(word) - 1), rest) do
              throw {:return, true}
            end
          end
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          :break -> i
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def newSpeller(blocks) do
    try do
      bl = fields(blocks)
      throw {:return, fn w -> canSpell(w, bl) end}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      sp = newSpeller("BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM")
      Enum.each(["A", "BARK", "BOOK", "TREAT", "COMMON", "SQUAD", "CONFUSE"], fn word ->
        IO.puts(Kernel.to_string(((word <> " ") <> to_string(sp.(word)))))
      end)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
