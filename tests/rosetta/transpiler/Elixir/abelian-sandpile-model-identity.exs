# Code generated by Mochi transpiler 2025-07-25 00:31 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  def neighborsList() do
    try do
      throw {:return, [[1, 3], [0, 2, 4], [1, 5], [0, 4, 6], [1, 3, 5, 7], [2, 4, 8], [3, 7], [4, 6, 8], [5, 7]]}
    catch
      {:return, val} -> val
    end
  end
  def plus(a, b) do
    try do
      res = []
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < length(a) do
          res = (res ++ [Enum.at(a, i) + Enum.at(b, i)])
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          :break -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def isStable(p) do
    try do
      Enum.each(p, fn v ->
        if v > 3 do
          throw {:return, false}
        end
      end)
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def topple(p) do
    try do
      neighbors = neighborsList()
      i = 0
      while_fun_2 = fn while_fun_2, i, p ->
        if i < length(p) do
          if Enum.at(p, i) > 3 do
            p = List.replace_at(p, i, Enum.at(p, i) - 4)
            nbs = Enum.at(neighbors, i)
            Enum.each(nbs, fn j ->
              p = List.replace_at(p, j, Enum.at(p, j) + 1)
            end)
            throw {:return, 0}
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, p)
        else
          {i, p}
        end
      end
      {i, p} = try do
          while_fun_2.(while_fun_2, i, p)
        catch
          :break -> {i, p}
        end

      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def pileString(p) do
    try do
      s = ""
      r = 0
      while_fun_3 = fn while_fun_3, r, s ->
        if r < 3 do
          c = 0
          while_fun_4 = fn while_fun_4, c, s ->
            if c < 3 do
              s = ((s <> to_string(Enum.at(p, 3 * r + c))) <> " ")
              c = c + 1
              while_fun_4.(while_fun_4, c, s)
            else
              {c, s}
            end
          end
          {c, s} = try do
              while_fun_4.(while_fun_4, c, s)
            catch
              :break -> {c, s}
            end

          s = (s <> "\n")
          r = r + 1
          while_fun_3.(while_fun_3, r, s)
        else
          {r, s}
        end
      end
      {r, s} = try do
          while_fun_3.(while_fun_3, r, s)
        catch
          :break -> {r, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    IO.puts("Avalanche of topplings:\n")
    s4 = [4, 3, 3, 3, 1, 2, 0, 2, 3]
    IO.puts(Kernel.to_string(pileString(Process.get(:s4))))
    while_fun_5 = fn while_fun_5 ->
      if !isStable(Process.get(:s4)) do
        topple(Process.get(:s4))
        IO.puts(Kernel.to_string(pileString(Process.get(:s4))))
        while_fun_5.(while_fun_5)
      else
        nil
      end
    end
    try do
      while_fun_5.(while_fun_5)
    catch
      :break -> nil
    end

    IO.puts("Commutative additions:\n")
    s1 = [1, 2, 0, 2, 1, 1, 0, 1, 3]
    s2 = [2, 1, 3, 1, 0, 1, 0, 1, 0]
    s3_a = plus(Process.get(:s1), Process.get(:s2))
    while_fun_6 = fn while_fun_6 ->
      if !isStable(Process.get(:s3_a)) do
        topple(Process.get(:s3_a))
        while_fun_6.(while_fun_6)
      else
        nil
      end
    end
    try do
      while_fun_6.(while_fun_6)
    catch
      :break -> nil
    end

    s3_b = plus(Process.get(:s2), Process.get(:s1))
    while_fun_7 = fn while_fun_7 ->
      if !isStable(Process.get(:s3_b)) do
        topple(Process.get(:s3_b))
        while_fun_7.(while_fun_7)
      else
        nil
      end
    end
    try do
      while_fun_7.(while_fun_7)
    catch
      :break -> nil
    end

    IO.puts(Kernel.to_string(((((pileString(Process.get(:s1)) <> "\nplus\n\n") <> pileString(Process.get(:s2))) <> "\nequals\n\n") <> pileString(Process.get(:s3_a)))))
    IO.puts(((((("and\n\n" <> pileString(Process.get(:s2))) <> "\nplus\n\n") <> pileString(Process.get(:s1))) <> "\nalso equals\n\n") <> pileString(Process.get(:s3_b))))
    IO.puts("Addition of identity sandpile:\n")
    s3 = [3, 3, 3, 3, 3, 3, 3, 3, 3]
    s3_id = [2, 1, 2, 1, 0, 1, 2, 1, 2]
    s4b = plus(Process.get(:s3), Process.get(:s3_id))
    while_fun_8 = fn while_fun_8 ->
      if !isStable(Process.get(:s4b)) do
        topple(Process.get(:s4b))
        while_fun_8.(while_fun_8)
      else
        nil
      end
    end
    try do
      while_fun_8.(while_fun_8)
    catch
      :break -> nil
    end

    IO.puts(Kernel.to_string(((((pileString(Process.get(:s3)) <> "\nplus\n\n") <> pileString(Process.get(:s3_id))) <> "\nequals\n\n") <> pileString(Process.get(:s4b)))))
    IO.puts("Addition of identities:\n")
    s5 = plus(Process.get(:s3_id), Process.get(:s3_id))
    while_fun_9 = fn while_fun_9 ->
      if !isStable(Process.get(:s5)) do
        topple(Process.get(:s5))
        while_fun_9.(while_fun_9)
      else
        nil
      end
    end
    try do
      while_fun_9.(while_fun_9)
    catch
      :break -> nil
    end

    IO.puts(Kernel.to_string(((((pileString(Process.get(:s3_id)) <> "\nplus\n\n") <> pileString(Process.get(:s3_id))) <> "\nequals\n\n") <> pileString(Process.get(:s5)))))
  end
end
Main.main()
