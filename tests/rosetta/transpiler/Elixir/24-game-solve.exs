# Code generated by Mochi transpiler 2025-07-22 17:27 +0700
defmodule Main do
  @OP_NUM 0
  @OP_ADD 1
  @OP_SUB 2
  @OP_MUL 3
  @OP_DIV 4
  def newNum(n) do
    try do
      throw {:return, %{"op" => @OP_NUM, "value" => %{"num" => n, "denom" => 1}}}
    catch
      {:return, val} -> val
    end
  end
  def exprEval(x) do
    try do
      if Enum.at(x, "op") == @OP_NUM do
        throw {:return, Enum.at(x, "value")}
      end
      l = exprEval(Enum.at(x, "left"))
      r = exprEval(Enum.at(x, "right"))
      if Enum.at(x, "op") == @OP_ADD do
        throw {:return, %{"num" => Enum.at(l, "num") * Enum.at(r, "denom") + Enum.at(l, "denom") * Enum.at(r, "num"), "denom" => Enum.at(l, "denom") * Enum.at(r, "denom")}}
      end
      if Enum.at(x, "op") == @OP_SUB do
        throw {:return, %{"num" => Enum.at(l, "num") * Enum.at(r, "denom") - Enum.at(l, "denom") * Enum.at(r, "num"), "denom" => Enum.at(l, "denom") * Enum.at(r, "denom")}}
      end
      if Enum.at(x, "op") == @OP_MUL do
        throw {:return, %{"num" => Enum.at(l, "num") * Enum.at(r, "num"), "denom" => Enum.at(l, "denom") * Enum.at(r, "denom")}}
      end
      throw {:return, %{"num" => Enum.at(l, "num") * Enum.at(r, "denom"), "denom" => Enum.at(l, "denom") * Enum.at(r, "num")}}
    catch
      {:return, val} -> val
    end
  end
  def exprString(x) do
    try do
      if Enum.at(x, "op") == @OP_NUM do
        throw {:return, to_string(Enum.at(Enum.at(x, "value"), "num"))}
      end
      ls = exprString(Enum.at(x, "left"))
      rs = exprString(Enum.at(x, "right"))
      opstr = ""
      if Enum.at(x, "op") == @OP_ADD do
        opstr = " + "
      else
        if Enum.at(x, "op") == @OP_SUB do
          opstr = " - "
        else
          if Enum.at(x, "op") == @OP_MUL do
            opstr = " * "
          else
            opstr = " / "
          end
        end
      end
      throw {:return, (("(" <> ls) + opstr + rs <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def solve(xs) do
    try do
      if length(xs) == 1 do
        f = exprEval(Enum.at(xs, 0))
        if Enum.at(f, "denom") != 0 && Enum.at(f, "num") == Enum.at(f, "denom") * goal do
          IO.inspect(exprString(Enum.at(xs, 0)))
          throw {:return, true}
        end
        throw {:return, false}
      end
      i = 0
      while_fun = fn while_fun ->
        if i < length(xs) do
          j = i + 1
          while_fun = fn while_fun ->
            if j < length(xs) do
              rest = []
              k = 0
              while_fun = fn while_fun ->
                if k < length(xs) do
                  if k != i && k != j do
                    rest = (rest ++ [Enum.at(xs, k)])
                  end
                  k = k + 1
                  while_fun.(while_fun)
                else
                  nil
                end
              end
              while_fun.(while_fun)
              a = Enum.at(xs, i)
              b = Enum.at(xs, j)
              Enum.each([@OP_ADD, @OP_SUB, @OP_MUL, @OP_DIV], fn op ->
                node = %{"op" => op, "left" => a, "right" => b}
                if solve((rest ++ [node])) do
                  throw {:return, true}
                end
              end)
              node = %{"op" => @OP_SUB, "left" => b, "right" => a}
              if solve((rest ++ [node])) do
                throw {:return, true}
              end
              node = %{"op" => @OP_DIV, "left" => b, "right" => a}
              if solve((rest ++ [node])) do
                throw {:return, true}
              end
              j = j + 1
              while_fun.(while_fun)
            else
              nil
            end
          end
          while_fun.(while_fun)
          i = i + 1
          while_fun.(while_fun)
        else
          nil
        end
      end
      while_fun.(while_fun)
      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      iter = 0
      while_fun = fn while_fun ->
        if iter < 10 do
          cards = []
          i = 0
          while_fun = fn while_fun ->
            if i < n_cards do
              n = (rem(now.(), (digit_range - 1))) + 1
              cards = (cards ++ [newNum(n)])
              IO.puts((" " <> to_string(n)))
              i = i + 1
              while_fun.(while_fun)
            else
              nil
            end
          end
          while_fun.(while_fun)
          IO.puts(":  ")
          if !solve(cards) do
            IO.puts("No solution")
          end
          iter = iter + 1
          while_fun.(while_fun)
        else
          nil
        end
      end
      while_fun.(while_fun)
    catch
      {:return, val} -> val
    end
  end
  def main() do
    n_cards = 4
    goal = 24
    digit_range = 9
    main()
  end
end
Main.main()
