# Code generated by Mochi transpiler 2025-07-27 01:41 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      abs(System.os_time(:nanosecond))
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) -> String.slice(base, start, len)
      len == 1 -> Enum.slice(base, start, len)
      true -> Enum.slice(base, start, len)
    end
  end
  def push(h, it) do
    try do
      h = (h ++ [it])
      i = length(h) - 1
      while_fun = fn while_fun, h, i ->
        if i > 0 && Enum.at(h, i - 1)["s"] > Enum.at(h, i)["s"] do
          tmp = Enum.at(h, i - 1)
          h = List.replace_at(h, i - 1, Enum.at(h, i))
          h = List.replace_at(h, i, tmp)
          i = i - 1
          while_fun.(while_fun, h, i)
        else
          {h, i}
        end
      end
      {h, i} = try do
          while_fun.(while_fun, h, i)
        catch
          :break -> {h, i}
        end

      throw {:return, h}
    catch
      {:return, val} -> val
    end
  end
  def step(h, nv, dir) do
    try do
      while_fun_2 = fn while_fun_2, h, nv ->
        if length(h) == 0 || nv * nv <= Enum.at(h, 0)["s"] do
          h = Main.push(h, %{"s" => nv * nv, "a" => nv, "b" => 0})
          nv = nv + 1
          while_fun_2.(while_fun_2, h, nv)
        else
          {h, nv}
        end
      end
      {h, nv} = try do
          while_fun_2.(while_fun_2, h, nv)
        catch
          :break -> {h, nv}
        end

      s = Enum.at(h, 0)["s"]
      v = []
      while_fun_3 = fn while_fun_3, h, v ->
        if length(h) > 0 && Enum.at(h, 0)["s"] == s do
          it = Enum.at(h, 0)
          h = _slice(h, 1, length(h) - 1)
          v = (v ++ [[it["a"], it["b"]]])
          {h} = if it["a"] > it["b"] do
            h = Main.push(h, %{"s" => it["a"] * it["a"] + (it["b"] + 1) * (it["b"] + 1), "a" => it["a"], "b" => it["b"] + 1})
            {h}
          else
            {h}
          end
          while_fun_3.(while_fun_3, h, v)
        else
          {h, v}
        end
      end
      {h, v} = try do
          while_fun_3.(while_fun_3, h, v)
        catch
          :break -> {h, v}
        end

      list = []
      {list} = Enum.reduce(v, {list}, fn p, {list} ->
        list = (list ++ [p])
        {list}
      end)
      temp = list
      {list} = Enum.reduce(temp, {list}, fn p, {list} ->
        {list} = if Enum.at(p, 0) != Enum.at(p, 1) do
          list = (list ++ [[Enum.at(p, 1), Enum.at(p, 0)]])
          {list}
        else
          {list}
        end
        {list}
      end)
      temp = list
      {list} = Enum.reduce(temp, {list}, fn p, {list} ->
        {list} = if Enum.at(p, 1) != 0 do
          list = (list ++ [[Enum.at(p, 0), -Enum.at(p, 1)]])
          {list}
        else
          {list}
        end
        {list}
      end)
      temp = list
      {list} = Enum.reduce(temp, {list}, fn p, {list} ->
        {list} = if Enum.at(p, 0) != 0 do
          list = (list ++ [[-Enum.at(p, 0), Enum.at(p, 1)]])
          {list}
        else
          {list}
        end
        {list}
      end)
      bestDot = -999999999
      best = dir
      {best, bestDot} = Enum.reduce(list, {best, bestDot}, fn p, {best, bestDot} ->
        cross = Enum.at(p, 0) * Enum.at(dir, 1) - Enum.at(p, 1) * Enum.at(dir, 0)
        {best, bestDot} = if cross >= 0 do
          dot = Enum.at(p, 0) * Enum.at(dir, 0) + Enum.at(p, 1) * Enum.at(dir, 1)
          {best, bestDot} = if dot > bestDot do
            bestDot = dot
            best = p
            {best, bestDot}
          else
            {best, bestDot}
          end
          {best, bestDot}
        else
          {best, bestDot}
        end
        {best, bestDot}
      end)
      throw {:return, %{"d" => best, "heap" => h, "n" => nv}}
    catch
      {:return, val} -> val
    end
  end
  def positions(n) do
    try do
      pos = []
      x = 0
      y = 0
      dir = [0, 1]
      heap = []
      nv = 1
      i = 0
      while_fun_4 = fn while_fun_4, dir, heap, i, nv, pos, x, y ->
        if i < n do
          pos = (pos ++ [[x, y]])
          st = Main.step(heap, nv, dir)
          dir = st["d"]
          heap = st["heap"]
          nv = trunc(st["n"])
          x = x + Enum.at(dir, 0)
          y = y + Enum.at(dir, 1)
          i = i + 1
          while_fun_4.(while_fun_4, dir, heap, i, nv, pos, x, y)
        else
          {dir, heap, i, nv, pos, x, y}
        end
      end
      {dir, heap, i, nv, pos, x, y} = try do
          while_fun_4.(while_fun_4, dir, heap, i, nv, pos, x, y)
        catch
          :break -> {dir, heap, i, nv, pos, x, y}
        end

      throw {:return, pos}
    catch
      {:return, val} -> val
    end
  end
  def pad(s, w) do
    try do
      r = s
      while_fun_5 = fn while_fun_5, r ->
        if String.length(r) < w do
          r = (r <> " ")
          while_fun_5.(while_fun_5, r)
        else
          r
        end
      end
      r = try do
          while_fun_5.(while_fun_5, r)
        catch
          :break -> r
        end

      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      pts = Main.positions(40)
      IO.puts("The first 40 Babylonian spiral points are:")
      line = ""
      i = 0
      while_fun_6 = fn while_fun_6, i, line ->
        if i < length(pts) do
          p = Enum.at(pts, i)
          s = Main.pad((((("(" <> Kernel.inspect(Enum.at(p, 0))) <> ", ") <> Kernel.inspect(Enum.at(p, 1))) <> ")"), 10)
          line = (line <> s)
          {line} = if rem((i + 1), 10) == 0 do
            IO.puts(line)
            line = ""
            {line}
          else
            {line}
          end
          i = i + 1
          while_fun_6.(while_fun_6, i, line)
        else
          {i, line}
        end
      end
      {i, line} = try do
          while_fun_6.(while_fun_6, i, line)
        catch
          :break -> {i, line}
        end

    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    mem_start = _mem()
    t_start = _now()
    main()
    duration_us = div(_now() - t_start, 1000)
    mem_diff = abs(_mem() - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
