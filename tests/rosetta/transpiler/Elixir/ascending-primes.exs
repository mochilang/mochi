# Code generated by Mochi transpiler 2025-07-26 19:45 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) -> String.slice(base, start, len)
      len == 1 -> Enum.slice(base, start, len)
      true -> Enum.slice(base, start, len)
    end
  end
  def isPrime(n) do
    try do
      if n < 2 do
        throw {:return, false}
      end
      if rem(n, 2) == 0 do
        throw {:return, n == 2}
      end
      if rem(n, 3) == 0 do
        throw {:return, n == 3}
      end
      d = 5
      while_fun = fn while_fun, d ->
        if d * d <= n do
          if rem(n, d) == 0 do
            throw {:return, false}
          end
          d = d + 2
          if rem(n, d) == 0 do
            throw {:return, false}
          end
          d = d + 4
          while_fun.(while_fun, d)
        else
          d
        end
      end
      d = try do
          while_fun.(while_fun, d)
        catch
          :break -> d
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def gen(first, cand, digits) do
    try do
      if digits == 0 do
        if Main.isPrime(cand) do
          Process.put(:asc, Process.get(:asc) + [cand])
        end
        throw {:return, nil}
      end
      i = first
      while_fun_2 = fn while_fun_2, i ->
        if i < 10 do
          Main.gen(i + 1, cand * 10 + i, digits - 1)
          i = i + 1
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          :break -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def pad(n, width) do
    try do
      s = to_string(n)
      while_fun_3 = fn while_fun_3, s ->
        if String.length(s) < width do
          s = (" " <> s)
          while_fun_3.(while_fun_3, s)
        else
          s
        end
      end
      s = try do
          while_fun_3.(while_fun_3, s)
        catch
          :break -> s
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      digits = 1
      while_fun_4 = fn while_fun_4, digits ->
        if digits < 10 do
          Main.gen(1, 0, digits)
          digits = digits + 1
          while_fun_4.(while_fun_4, digits)
        else
          digits
        end
      end
      digits = try do
          while_fun_4.(while_fun_4, digits)
        catch
          :break -> digits
        end

      IO.puts((("There are " <> to_string(length(Process.get(:asc)))) <> " ascending primes, namely:"))
      i = 0
      line = ""
      while_fun_5 = fn while_fun_5, i, line ->
        if i < length(Process.get(:asc)) do
          line = ((line <> Main.pad(Enum.at(Process.get(:asc), i), 8)) <> " ")
          if rem((i + 1), 10) == 0 do
            IO.puts(Kernel.to_string(String.slice(line, 0, String.length(line) - 1 - (0))))
            line = ""
          end
          i = i + 1
          while_fun_5.(while_fun_5, i, line)
        else
          {i, line}
        end
      end
      {i, line} = try do
          while_fun_5.(while_fun_5, i, line)
        catch
          :break -> {i, line}
        end

      if String.length(line) > 0 do
        IO.puts(Kernel.to_string(String.slice(line, 0, String.length(line) - 1 - (0))))
      end
    catch
      {:return, val} -> val
    end
  end
  Process.put(:asc, [])
end
Main.main()
