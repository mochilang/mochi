# Code generated by Mochi transpiler 2025-07-25 00:31 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  def divisors(n) do
    try do
      divs = [1]
      divs2 = []
      i = 2
      while_fun = fn while_fun, divs, divs2, i ->
        if i * i <= n do
          if rem(n, i) == 0 do
            j = (div(n, i))
            divs = (divs ++ [i])
            if i != j do
              divs2 = (divs2 ++ [j])
            end
          end
          i = i + 1
          while_fun.(while_fun, divs, divs2, i)
        else
          {divs, divs2, i}
        end
      end
      {divs, divs2, i} = try do
          while_fun.(while_fun, divs, divs2, i)
        catch
          :break -> {divs, divs2, i}
        end

      j = length(divs2) - 1
      while_fun_2 = fn while_fun_2, divs, j ->
        if j >= 0 do
          divs = (divs ++ [Enum.at(divs2, j)])
          j = j - 1
          while_fun_2.(while_fun_2, divs, j)
        else
          {divs, j}
        end
      end
      {divs, j} = try do
          while_fun_2.(while_fun_2, divs, j)
        catch
          :break -> {divs, j}
        end

      throw {:return, divs}
    catch
      {:return, val} -> val
    end
  end
  def sum(xs) do
    try do
      tot = 0
      Enum.each(xs, fn v ->
        tot = tot + v
      end)
      throw {:return, tot}
    catch
      {:return, val} -> val
    end
  end
  def sumStr(xs) do
    try do
      s = ""
      i = 0
      while_fun_3 = fn while_fun_3, i, s ->
        if i < length(xs) do
          s = ((s <> to_string(Enum.at(xs, i))) <> " + ")
          i = i + 1
          while_fun_3.(while_fun_3, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_3.(while_fun_3, i, s)
        catch
          :break -> {i, s}
        end

      throw {:return, String.slice(s, 0, String.length(s) - 3 - (0))}
    catch
      {:return, val} -> val
    end
  end
  def pad2(n) do
    try do
      s = to_string(n)
      if length(s) < 2 do
        throw {:return, (" " <> s)}
      end
      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def pad5(n) do
    try do
      s = to_string(n)
      while_fun_4 = fn while_fun_4, s ->
        if length(s) < 5 do
          s = (" " <> s)
          while_fun_4.(while_fun_4, s)
        else
          s
        end
      end
      s = try do
          while_fun_4.(while_fun_4, s)
        catch
          :break -> s
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def abundantOdd(searchFrom, countFrom, countTo, printOne) do
    try do
      count = countFrom
      n = searchFrom
      while_fun_5 = fn while_fun_5, count, n ->
        if count < countTo do
          try do
            divs = divisors(n)
            tot = Enum.sum(divs)
            if tot > n do
              count = count + 1
              if printOne && count < countTo do
                n = n + 2
                throw :continue
              end
              s = sumStr(divs)
              if !printOne do
                IO.puts(Kernel.to_string(((((((pad2(count) <> ". ") <> pad5(n)) <> " < ") <> s) <> " = ") <> to_string(tot))))
              else
                IO.puts(Kernel.to_string(((((to_string(n) <> " < ") <> s) <> " = ") <> to_string(tot))))
              end
            end
            n = n + 2
          catch
            :continue -> nil
          end
          while_fun_5.(while_fun_5, count, n)
        else
          {count, n}
        end
      end
      {count, n} = try do
          while_fun_5.(while_fun_5, count, n)
        catch
          :break -> {count, n}
        end

      throw {:return, n}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      max = 25
      IO.puts((("The first " <> to_string(max)) <> " abundant odd numbers are:"))
      n = abundantOdd(1, 0, max, false)
      IO.puts("\nThe one thousandth abundant odd number is:")
      abundantOdd(n, max, 1000, true)
      IO.puts("\nThe first abundant odd number above one billion is:")
      abundantOdd(1000000001, 0, 1, true)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
