# Code generated by Mochi transpiler 2025-07-25 18:29 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) -> String.slice(base, start, len)
      len == 1 -> Enum.at(base, start)
      true -> Enum.slice(base, start, len)
    end
  end
  def shuffleStr(s) do
    try do
      arr = []
      i = 0
      while_fun = fn while_fun, arr, i ->
        if i < String.length(s) do
          arr = (arr ++ [String.slice(s, i, i + 1 - i)])
          i = i + 1
          while_fun.(while_fun, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun.(while_fun, arr, i)
        catch
          :break -> {arr, i}
        end

      j = length(arr) - 1
      while_fun_2 = fn while_fun_2, arr, j ->
        if j > 0 do
          k = rem(_now(), (j + 1))
          tmp = Enum.at(arr, j)
          arr = List.replace_at(arr, j, Enum.at(arr, k))
          arr = List.replace_at(arr, k, tmp)
          j = j - 1
          while_fun_2.(while_fun_2, arr, j)
        else
          {arr, j}
        end
      end
      {arr, j} = try do
          while_fun_2.(while_fun_2, arr, j)
        catch
          :break -> {arr, j}
        end

      out = ""
      i = 0
      while_fun_3 = fn while_fun_3, i, out ->
        if i < length(arr) do
          out = (out <> Enum.at(arr, i))
          i = i + 1
          while_fun_3.(while_fun_3, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_3.(while_fun_3, i, out)
        catch
          :break -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def createPolybius() do
    try do
      shuffled = shuffleStr(Process.get(:alphabet))
      labels = []
      li = 0
      while_fun_4 = fn while_fun_4, labels, li ->
        if li < String.length(Process.get(:adfgvx)) do
          labels = (labels ++ [String.slice(Process.get(:adfgvx), li, li + 1 - li)])
          li = li + 1
          while_fun_4.(while_fun_4, labels, li)
        else
          {labels, li}
        end
      end
      {labels, li} = try do
          while_fun_4.(while_fun_4, labels, li)
        catch
          :break -> {labels, li}
        end

      IO.puts("6 x 6 Polybius square:\n")
      IO.puts("  | A D F G V X")
      IO.puts("---------------")
      p = []
      i = 0
      while_fun_5 = fn while_fun_5, i, p ->
        if i < 6 do
          row = _slice(shuffled, i * 6, (i + 1) * 6 - i * 6)
          p = (p ++ [row])
          line = (Enum.at(labels, i) <> " | ")
          j = 0
          while_fun_6 = fn while_fun_6, j, line ->
            if j < 6 do
              line = ((line <> _slice(row, j, j + 1 - j)) <> " ")
              j = j + 1
              while_fun_6.(while_fun_6, j, line)
            else
              {j, line}
            end
          end
          {j, line} = try do
              while_fun_6.(while_fun_6, j, line)
            catch
              :break -> {j, line}
            end

          IO.puts(line)
          i = i + 1
          while_fun_5.(while_fun_5, i, p)
        else
          {i, p}
        end
      end
      {i, p} = try do
          while_fun_5.(while_fun_5, i, p)
        catch
          :break -> {i, p}
        end

      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def createKey(n) do
    try do
      if n < 7 || n > 12 do
        IO.puts("Key should be within 7 and 12 letters long.")
      end
      pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
      key = ""
      i = 0
      while_fun_7 = fn while_fun_7, i, key, pool ->
        if i < n do
          idx = rem(_now(), String.length(pool))
          key = (key <> String.at(pool, idx))
          pool = (String.slice(pool, 0, idx - 0) <> String.slice(pool, idx + 1, String.length(pool) - idx + 1))
          i = i + 1
          while_fun_7.(while_fun_7, i, key, pool)
        else
          {i, key, pool}
        end
      end
      {i, key, pool} = try do
          while_fun_7.(while_fun_7, i, key, pool)
        catch
          :break -> {i, key, pool}
        end

      IO.puts(("\nThe key is " <> key))
      throw {:return, key}
    catch
      {:return, val} -> val
    end
  end
  def orderKey(key) do
    try do
      pairs = []
      i = 0
      while_fun_8 = fn while_fun_8, i, pairs ->
        if i < String.length(key) do
          pairs = (pairs ++ [[String.slice(key, i, i + 1 - i), i]])
          i = i + 1
          while_fun_8.(while_fun_8, i, pairs)
        else
          {i, pairs}
        end
      end
      {i, pairs} = try do
          while_fun_8.(while_fun_8, i, pairs)
        catch
          :break -> {i, pairs}
        end

      n = length(pairs)
      m = 0
      while_fun_9 = fn while_fun_9, m, pairs ->
        if m < n do
          j = 0
          while_fun_10 = fn while_fun_10, j, pairs ->
            if j < n - 1 do
              if Enum.at(Enum.at(pairs, j), 0) > Enum.at(Enum.at(pairs, j + 1), 0) do
                tmp = Enum.at(pairs, j)
                pairs = List.replace_at(pairs, j, Enum.at(pairs, j + 1))
                pairs = List.replace_at(pairs, j + 1, tmp)
              end
              j = j + 1
              while_fun_10.(while_fun_10, j, pairs)
            else
              {j, pairs}
            end
          end
          {j, pairs} = try do
              while_fun_10.(while_fun_10, j, pairs)
            catch
              :break -> {j, pairs}
            end

          m = m + 1
          while_fun_9.(while_fun_9, m, pairs)
        else
          {m, pairs}
        end
      end
      {m, pairs} = try do
          while_fun_9.(while_fun_9, m, pairs)
        catch
          :break -> {m, pairs}
        end

      res = []
      i = 0
      while_fun_11 = fn while_fun_11, i, res ->
        if i < n do
          res = (res ++ [trunc(Enum.at(Enum.at(pairs, i), 1))])
          i = i + 1
          while_fun_11.(while_fun_11, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_11.(while_fun_11, i, res)
        catch
          :break -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def encrypt(polybius, key, plainText) do
    try do
      labels = []
      li = 0
      while_fun_12 = fn while_fun_12, labels, li ->
        if li < String.length(Process.get(:adfgvx)) do
          labels = (labels ++ [String.slice(Process.get(:adfgvx), li, li + 1 - li)])
          li = li + 1
          while_fun_12.(while_fun_12, labels, li)
        else
          {labels, li}
        end
      end
      {labels, li} = try do
          while_fun_12.(while_fun_12, labels, li)
        catch
          :break -> {labels, li}
        end

      temp = ""
      i = 0
      while_fun_13 = fn while_fun_13, i, temp ->
        if i < String.length(plainText) do
          r = 0
          while_fun_14 = fn while_fun_14, r, temp ->
            if r < 6 do
              c = 0
              while_fun_15 = fn while_fun_15, c, temp ->
                if c < 6 do
                  if String.slice(Enum.at(polybius, r), c, c + 1 - c) == String.slice(plainText, i, i + 1 - i) do
                    temp = ((temp <> _slice(labels, r, r + 1 - r)) <> _slice(labels, c, c + 1 - c))
                  end
                  c = c + 1
                  while_fun_15.(while_fun_15, c, temp)
                else
                  {c, temp}
                end
              end
              {c, temp} = try do
                  while_fun_15.(while_fun_15, c, temp)
                catch
                  :break -> {c, temp}
                end

              r = r + 1
              while_fun_14.(while_fun_14, r, temp)
            else
              {r, temp}
            end
          end
          {r, temp} = try do
              while_fun_14.(while_fun_14, r, temp)
            catch
              :break -> {r, temp}
            end

          i = i + 1
          while_fun_13.(while_fun_13, i, temp)
        else
          {i, temp}
        end
      end
      {i, temp} = try do
          while_fun_13.(while_fun_13, i, temp)
        catch
          :break -> {i, temp}
        end

      colLen = div(String.length(temp), String.length(key))
      {colLen} = if rem(String.length(temp), String.length(key)) > 0 do
        colLen = colLen + 1
        {colLen}
      else
        {colLen}
      end
      table = []
      rIdx = 0
      while_fun_16 = fn while_fun_16, rIdx, table ->
        if rIdx < colLen do
          row = []
          j = 0
          while_fun_17 = fn while_fun_17, j, row ->
            if j < String.length(key) do
              row = (row ++ [""])
              j = j + 1
              while_fun_17.(while_fun_17, j, row)
            else
              {j, row}
            end
          end
          {j, row} = try do
              while_fun_17.(while_fun_17, j, row)
            catch
              :break -> {j, row}
            end

          table = (table ++ [row])
          rIdx = rIdx + 1
          while_fun_16.(while_fun_16, rIdx, table)
        else
          {rIdx, table}
        end
      end
      {rIdx, table} = try do
          while_fun_16.(while_fun_16, rIdx, table)
        catch
          :break -> {rIdx, table}
        end

      idx = 0
      while_fun_18 = fn while_fun_18, idx, table ->
        if idx < String.length(temp) do
          row = div(idx, String.length(key))
          col = rem(idx, String.length(key))
          table = List.replace_at(table, row, List.replace_at(Enum.at(table, row), col, String.slice(temp, idx, idx + 1 - idx)))
          idx = idx + 1
          while_fun_18.(while_fun_18, idx, table)
        else
          {idx, table}
        end
      end
      {idx, table} = try do
          while_fun_18.(while_fun_18, idx, table)
        catch
          :break -> {idx, table}
        end

      order = orderKey(key)
      cols = []
      ci = 0
      while_fun_19 = fn while_fun_19, ci, cols ->
        if ci < String.length(key) do
          colStr = ""
          ri = 0
          while_fun_20 = fn while_fun_20, colStr, ri ->
            if ri < colLen do
              colStr = (colStr <> Enum.at(Enum.at(table, ri), Enum.at(order, ci)))
              ri = ri + 1
              while_fun_20.(while_fun_20, colStr, ri)
            else
              {colStr, ri}
            end
          end
          {colStr, ri} = try do
              while_fun_20.(while_fun_20, colStr, ri)
            catch
              :break -> {colStr, ri}
            end

          cols = (cols ++ [colStr])
          ci = ci + 1
          while_fun_19.(while_fun_19, ci, cols)
        else
          {ci, cols}
        end
      end
      {ci, cols} = try do
          while_fun_19.(while_fun_19, ci, cols)
        catch
          :break -> {ci, cols}
        end

      result = ""
      ci = 0
      while_fun_21 = fn while_fun_21, ci, result ->
        if ci < length(cols) do
          result = (result <> Enum.at(cols, ci))
          if ci < length(cols) - 1 do
            result = (result <> " ")
          end
          ci = ci + 1
          while_fun_21.(while_fun_21, ci, result)
        else
          {ci, result}
        end
      end
      {ci, result} = try do
          while_fun_21.(while_fun_21, ci, result)
        catch
          :break -> {ci, result}
        end

      throw {:return, result}
    catch
      {:return, val} -> val
    end
  end
  def indexOf(s, ch) do
    try do
      i = 0
      while_fun_22 = fn while_fun_22, i ->
        if i < String.length(s) do
          if String.slice(s, i, i + 1 - i) == ch do
            throw {:return, i}
          end
          i = i + 1
          while_fun_22.(while_fun_22, i)
        else
          i
        end
      end
      i = try do
          while_fun_22.(while_fun_22, i)
        catch
          :break -> i
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def decrypt(polybius, key, cipherText) do
    try do
      colStrs = []
      start = 0
      i = 0
      while_fun_23 = fn while_fun_23, colStrs, i, start ->
        if i <= String.length(cipherText) do
          if i == String.length(cipherText) || String.at(cipherText, i) == " " do
            colStrs = (colStrs ++ [String.slice(cipherText, start, i - start)])
            start = i + 1
          end
          i = i + 1
          while_fun_23.(while_fun_23, colStrs, i, start)
        else
          {colStrs, i, start}
        end
      end
      {colStrs, i, start} = try do
          while_fun_23.(while_fun_23, colStrs, i, start)
        catch
          :break -> {colStrs, i, start}
        end

      maxColLen = 0
      i = 0
      while_fun_24 = fn while_fun_24, i, maxColLen ->
        if i < length(colStrs) do
          if String.length(Enum.at(colStrs, i)) > maxColLen do
            maxColLen = String.length(Enum.at(colStrs, i))
          end
          i = i + 1
          while_fun_24.(while_fun_24, i, maxColLen)
        else
          {i, maxColLen}
        end
      end
      {i, maxColLen} = try do
          while_fun_24.(while_fun_24, i, maxColLen)
        catch
          :break -> {i, maxColLen}
        end

      cols = []
      i = 0
      while_fun_25 = fn while_fun_25, cols, i ->
        if i < length(colStrs) do
          s = Enum.at(colStrs, i)
          ls = []
          j = 0
          while_fun_26 = fn while_fun_26, j, ls ->
            if j < String.length(s) do
              ls = (ls ++ [String.slice(s, j, j + 1 - j)])
              j = j + 1
              while_fun_26.(while_fun_26, j, ls)
            else
              {j, ls}
            end
          end
          {j, ls} = try do
              while_fun_26.(while_fun_26, j, ls)
            catch
              :break -> {j, ls}
            end

          if String.length(s) < maxColLen do
            pad = []
            k = 0
            while_fun_27 = fn while_fun_27, k, pad ->
              if k < maxColLen do
                pad = if k < length(ls), do: (pad ++ [Enum.at(ls, k)]), else: (pad ++ [""])
                k = k + 1
                while_fun_27.(while_fun_27, k, pad)
              else
                {k, pad}
              end
            end
            {k, pad} = try do
                while_fun_27.(while_fun_27, k, pad)
              catch
                :break -> {k, pad}
              end

            cols = (cols ++ [pad])
          else
            cols = (cols ++ [ls])
          end
          i = i + 1
          while_fun_25.(while_fun_25, cols, i)
        else
          {cols, i}
        end
      end
      {cols, i} = try do
          while_fun_25.(while_fun_25, cols, i)
        catch
          :break -> {cols, i}
        end

      table = []
      r = 0
      while_fun_28 = fn while_fun_28, r, table ->
        if r < maxColLen do
          row = []
          c = 0
          while_fun_29 = fn while_fun_29, c, row ->
            if c < String.length(key) do
              row = (row ++ [""])
              c = c + 1
              while_fun_29.(while_fun_29, c, row)
            else
              {c, row}
            end
          end
          {c, row} = try do
              while_fun_29.(while_fun_29, c, row)
            catch
              :break -> {c, row}
            end

          table = (table ++ [row])
          r = r + 1
          while_fun_28.(while_fun_28, r, table)
        else
          {r, table}
        end
      end
      {r, table} = try do
          while_fun_28.(while_fun_28, r, table)
        catch
          :break -> {r, table}
        end

      order = orderKey(key)
      r = 0
      while_fun_30 = fn while_fun_30, r, table ->
        if r < maxColLen do
          c = 0
          while_fun_31 = fn while_fun_31, c, table ->
            if c < String.length(key) do
              table = List.replace_at(table, r, List.replace_at(Enum.at(table, r), Enum.at(order, c), Enum.at(Enum.at(cols, c), r)))
              c = c + 1
              while_fun_31.(while_fun_31, c, table)
            else
              {c, table}
            end
          end
          {c, table} = try do
              while_fun_31.(while_fun_31, c, table)
            catch
              :break -> {c, table}
            end

          r = r + 1
          while_fun_30.(while_fun_30, r, table)
        else
          {r, table}
        end
      end
      {r, table} = try do
          while_fun_30.(while_fun_30, r, table)
        catch
          :break -> {r, table}
        end

      temp = ""
      r = 0
      while_fun_32 = fn while_fun_32, r, temp ->
        if r < length(table) do
          j = 0
          while_fun_33 = fn while_fun_33, j, temp ->
            if j < length(Enum.at(table, r)) do
              temp = (temp <> Enum.at(Enum.at(table, r), j))
              j = j + 1
              while_fun_33.(while_fun_33, j, temp)
            else
              {j, temp}
            end
          end
          {j, temp} = try do
              while_fun_33.(while_fun_33, j, temp)
            catch
              :break -> {j, temp}
            end

          r = r + 1
          while_fun_32.(while_fun_32, r, temp)
        else
          {r, temp}
        end
      end
      {r, temp} = try do
          while_fun_32.(while_fun_32, r, temp)
        catch
          :break -> {r, temp}
        end

      plainText = ""
      idx = 0
      while_fun_34 = fn while_fun_34, idx, plainText ->
        if idx < String.length(temp) do
          rIdx = indexOf(Process.get(:adfgvx), String.slice(temp, idx, idx + 1 - idx))
          cIdx = indexOf(Process.get(:adfgvx), String.slice(temp, idx + 1, idx + 2 - idx + 1))
          plainText = (plainText <> String.at(Enum.at(polybius, rIdx), cIdx))
          idx = idx + 2
          while_fun_34.(while_fun_34, idx, plainText)
        else
          {idx, plainText}
        end
      end
      {idx, plainText} = try do
          while_fun_34.(while_fun_34, idx, plainText)
        catch
          :break -> {idx, plainText}
        end

      throw {:return, plainText}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      plainText = "ATTACKAT1200AM"
      polybius = createPolybius()
      key = createKey(9)
      IO.puts(("\nPlaintext : " <> plainText))
      cipherText = encrypt(polybius, key, plainText)
      IO.puts(("\nEncrypted : " <> cipherText))
      plainText2 = decrypt(polybius, key, cipherText)
      IO.puts(("\nDecrypted : " <> plainText2))
    catch
      {:return, val} -> val
    end
  end
  Process.put(:adfgvx, "ADFGVX")
  Process.put(:alphabet, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
  def bench_main() do
    Process.put(:adfgvx, "ADFGVX")
    Process.put(:alphabet, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
    mem_start = _mem()
    t_start = _now()
    main()
    duration_us = div(_now() - t_start, 1000)
    mem_diff = abs(_mem() - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
