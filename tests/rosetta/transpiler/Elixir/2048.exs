# Code generated by Mochi transpiler 2025-07-25 12:29 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  Process.put(:size, 4)
  def newBoard() do
    try do
      b = []
      y = 0
      while_fun = fn while_fun, b, y ->
        if y < Process.get(:size) do
          row = []
          x = 0
          while_fun_2 = fn while_fun_2, row, x ->
            if x < Process.get(:size) do
              row = (row ++ [0])
              x = x + 1
              while_fun_2.(while_fun_2, row, x)
            else
              {row, x}
            end
          end
          {row, x} = try do
              while_fun_2.(while_fun_2, row, x)
            catch
              :break -> {row, x}
            end

          b = (b ++ [row])
          y = y + 1
          while_fun.(while_fun, b, y)
        else
          {b, y}
        end
      end
      {b, y} = try do
          while_fun.(while_fun, b, y)
        catch
          :break -> {b, y}
        end

      throw {:return, %{cells: b}}
    catch
      {:return, val} -> val
    end
  end
  def spawnTile(b) do
    try do
      grid = b.cells
      empty = []
      y = 0
      while_fun_3 = fn while_fun_3, empty, y ->
        if y < Process.get(:size) do
          x = 0
          while_fun_4 = fn while_fun_4, empty, x ->
            if x < Process.get(:size) do
              if Enum.at(Enum.at(grid, y), x) == 0 do
                empty = (empty ++ [[x, y]])
              end
              x = x + 1
              while_fun_4.(while_fun_4, empty, x)
            else
              {empty, x}
            end
          end
          {empty, x} = try do
              while_fun_4.(while_fun_4, empty, x)
            catch
              :break -> {empty, x}
            end

          y = y + 1
          while_fun_3.(while_fun_3, empty, y)
        else
          {empty, y}
        end
      end
      {empty, y} = try do
          while_fun_3.(while_fun_3, empty, y)
        catch
          :break -> {empty, y}
        end

      if length(empty) == 0 do
        throw {:return, %{board: b, full: true}}
      end
      idx = rem(_now(), length(empty))
      cell = Enum.at(empty, idx)
      val = 4
      {val} = if rem(_now(), 10) < 9 do
        val = 2
        {val}
      else
        {val}
      end
      grid = List.replace_at(grid, Enum.at(cell, 1), List.replace_at(Enum.at(grid, Enum.at(cell, 1)), Enum.at(cell, 0), val))
      throw {:return, %{board: %{cells: grid}, full: length(empty) == 1}}
    catch
      {:return, val} -> val
    end
  end
  def pad(n) do
    try do
      s = to_string(n)
      pad = 4 - String.length(s)
      i = 0
      out = ""
      while_fun_5 = fn while_fun_5, i, out ->
        if i < pad do
          out = (out <> " ")
          i = i + 1
          while_fun_5.(while_fun_5, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_5.(while_fun_5, i, out)
        catch
          :break -> {i, out}
        end

      throw {:return, (out <> s)}
    catch
      {:return, val} -> val
    end
  end
  def draw(b, score) do
    try do
      IO.puts(("Score: " <> to_string(score)))
      y = 0
      while_fun_6 = fn while_fun_6, y ->
        if y < Process.get(:size) do
          IO.puts("+----+----+----+----+")
          line = "|"
          x = 0
          while_fun_7 = fn while_fun_7, line, x ->
            if x < Process.get(:size) do
              v = Enum.at(Enum.at(b.cells, y), x)
              line = if v == 0, do: (line <> "    |"), else: ((line <> pad(v)) <> "|")
              x = x + 1
              while_fun_7.(while_fun_7, line, x)
            else
              {line, x}
            end
          end
          {line, x} = try do
              while_fun_7.(while_fun_7, line, x)
            catch
              :break -> {line, x}
            end

          IO.puts(line)
          y = y + 1
          while_fun_6.(while_fun_6, y)
        else
          y
        end
      end
      y = try do
          while_fun_6.(while_fun_6, y)
        catch
          :break -> y
        end

      IO.puts("+----+----+----+----+")
      IO.puts("W=Up S=Down A=Left D=Right Q=Quit")
    catch
      {:return, val} -> val
    end
  end
  def reverseRow(r) do
    try do
      out = []
      i = length(r) - 1
      while_fun_8 = fn while_fun_8, i, out ->
        if i >= 0 do
          out = (out ++ [Enum.at(r, i)])
          i = i - 1
          while_fun_8.(while_fun_8, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_8.(while_fun_8, i, out)
        catch
          :break -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def slideLeft(row) do
    try do
      xs = []
      i = 0
      while_fun_9 = fn while_fun_9, i, xs ->
        if i < length(row) do
          if Enum.at(row, i) != 0 do
            xs = (xs ++ [Enum.at(row, i)])
          end
          i = i + 1
          while_fun_9.(while_fun_9, i, xs)
        else
          {i, xs}
        end
      end
      {i, xs} = try do
          while_fun_9.(while_fun_9, i, xs)
        catch
          :break -> {i, xs}
        end

      res = []
      gain = 0
      i = 0
      while_fun_10 = fn while_fun_10, gain, i, res ->
        if i < length(xs) do
          if i + 1 < length(xs) && Enum.at(xs, i) == Enum.at(xs, i + 1) do
            v = Enum.at(xs, i) * 2
            gain = gain + v
            res = (res ++ [v])
            i = i + 2
          else
            res = (res ++ [Enum.at(xs, i)])
            i = i + 1
          end
          while_fun_10.(while_fun_10, gain, i, res)
        else
          {gain, i, res}
        end
      end
      {gain, i, res} = try do
          while_fun_10.(while_fun_10, gain, i, res)
        catch
          :break -> {gain, i, res}
        end

      while_fun_11 = fn while_fun_11, res ->
        if length(res) < Process.get(:size) do
          res = (res ++ [0])
          while_fun_11.(while_fun_11, res)
        else
          res
        end
      end
      res = try do
          while_fun_11.(while_fun_11, res)
        catch
          :break -> res
        end

      throw {:return, %{row: res, gain: gain}}
    catch
      {:return, val} -> val
    end
  end
  def moveLeft(b, score) do
    try do
      grid = b.cells
      moved = false
      y = 0
      while_fun_12 = fn while_fun_12, grid, moved, score, y ->
        if y < Process.get(:size) do
          r = slideLeft(Enum.at(grid, y))
          new = r.row
          score = score + r.gain
          x = 0
          while_fun_13 = fn while_fun_13, grid, moved, x ->
            if x < Process.get(:size) do
              if Enum.at(Enum.at(grid, y), x) != Enum.at(new, x) do
                moved = true
              end
              grid = List.replace_at(grid, y, List.replace_at(Enum.at(grid, y), x, Enum.at(new, x)))
              x = x + 1
              while_fun_13.(while_fun_13, grid, moved, x)
            else
              {grid, moved, x}
            end
          end
          {grid, moved, x} = try do
              while_fun_13.(while_fun_13, grid, moved, x)
            catch
              :break -> {grid, moved, x}
            end

          y = y + 1
          while_fun_12.(while_fun_12, grid, moved, score, y)
        else
          {grid, moved, score, y}
        end
      end
      {grid, moved, score, y} = try do
          while_fun_12.(while_fun_12, grid, moved, score, y)
        catch
          :break -> {grid, moved, score, y}
        end

      throw {:return, %{board: %{cells: grid}, score: score, moved: moved}}
    catch
      {:return, val} -> val
    end
  end
  def moveRight(b, score) do
    try do
      grid = b.cells
      moved = false
      y = 0
      while_fun_14 = fn while_fun_14, grid, moved, score, y ->
        if y < Process.get(:size) do
          rev = reverseRow(Enum.at(grid, y))
          r = slideLeft(rev)
          rev = r.row
          score = score + r.gain
          rev = reverseRow(rev)
          x = 0
          while_fun_15 = fn while_fun_15, grid, moved, x ->
            if x < Process.get(:size) do
              if Enum.at(Enum.at(grid, y), x) != Enum.at(rev, x) do
                moved = true
              end
              grid = List.replace_at(grid, y, List.replace_at(Enum.at(grid, y), x, Enum.at(rev, x)))
              x = x + 1
              while_fun_15.(while_fun_15, grid, moved, x)
            else
              {grid, moved, x}
            end
          end
          {grid, moved, x} = try do
              while_fun_15.(while_fun_15, grid, moved, x)
            catch
              :break -> {grid, moved, x}
            end

          y = y + 1
          while_fun_14.(while_fun_14, grid, moved, score, y)
        else
          {grid, moved, score, y}
        end
      end
      {grid, moved, score, y} = try do
          while_fun_14.(while_fun_14, grid, moved, score, y)
        catch
          :break -> {grid, moved, score, y}
        end

      throw {:return, %{board: %{cells: grid}, score: score, moved: moved}}
    catch
      {:return, val} -> val
    end
  end
  def getCol(b, x) do
    try do
      col = []
      y = 0
      while_fun_16 = fn while_fun_16, col, y ->
        if y < Process.get(:size) do
          col = (col ++ [Enum.at(Enum.at(b.cells, y), x)])
          y = y + 1
          while_fun_16.(while_fun_16, col, y)
        else
          {col, y}
        end
      end
      {col, y} = try do
          while_fun_16.(while_fun_16, col, y)
        catch
          :break -> {col, y}
        end

      throw {:return, col}
    catch
      {:return, val} -> val
    end
  end
  def setCol(b, x, col) do
    try do
      rows = b.cells
      y = 0
      while_fun_17 = fn while_fun_17, rows, y ->
        if y < Process.get(:size) do
          row = Enum.at(rows, y)
          row = List.replace_at(row, x, Enum.at(col, y))
          rows = List.replace_at(rows, y, row)
          y = y + 1
          while_fun_17.(while_fun_17, rows, y)
        else
          {rows, y}
        end
      end
      {rows, y} = try do
          while_fun_17.(while_fun_17, rows, y)
        catch
          :break -> {rows, y}
        end

      b = Map.put(b, :cells, rows)
    catch
      {:return, val} -> val
    end
  end
  def moveUp(b, score) do
    try do
      grid = b.cells
      moved = false
      x = 0
      while_fun_18 = fn while_fun_18, grid, moved, score, x ->
        if x < Process.get(:size) do
          col = getCol(b, x)
          r = slideLeft(col)
          new = r.row
          score = score + r.gain
          y = 0
          while_fun_19 = fn while_fun_19, grid, moved, y ->
            if y < Process.get(:size) do
              if Enum.at(Enum.at(grid, y), x) != Enum.at(new, y) do
                moved = true
              end
              grid = List.replace_at(grid, y, List.replace_at(Enum.at(grid, y), x, Enum.at(new, y)))
              y = y + 1
              while_fun_19.(while_fun_19, grid, moved, y)
            else
              {grid, moved, y}
            end
          end
          {grid, moved, y} = try do
              while_fun_19.(while_fun_19, grid, moved, y)
            catch
              :break -> {grid, moved, y}
            end

          x = x + 1
          while_fun_18.(while_fun_18, grid, moved, score, x)
        else
          {grid, moved, score, x}
        end
      end
      {grid, moved, score, x} = try do
          while_fun_18.(while_fun_18, grid, moved, score, x)
        catch
          :break -> {grid, moved, score, x}
        end

      throw {:return, %{board: %{cells: grid}, score: score, moved: moved}}
    catch
      {:return, val} -> val
    end
  end
  def moveDown(b, score) do
    try do
      grid = b.cells
      moved = false
      x = 0
      while_fun_20 = fn while_fun_20, grid, moved, score, x ->
        if x < Process.get(:size) do
          col = reverseRow(getCol(b, x))
          r = slideLeft(col)
          col = r.row
          score = score + r.gain
          col = reverseRow(col)
          y = 0
          while_fun_21 = fn while_fun_21, grid, moved, y ->
            if y < Process.get(:size) do
              if Enum.at(Enum.at(grid, y), x) != Enum.at(col, y) do
                moved = true
              end
              grid = List.replace_at(grid, y, List.replace_at(Enum.at(grid, y), x, Enum.at(col, y)))
              y = y + 1
              while_fun_21.(while_fun_21, grid, moved, y)
            else
              {grid, moved, y}
            end
          end
          {grid, moved, y} = try do
              while_fun_21.(while_fun_21, grid, moved, y)
            catch
              :break -> {grid, moved, y}
            end

          x = x + 1
          while_fun_20.(while_fun_20, grid, moved, score, x)
        else
          {grid, moved, score, x}
        end
      end
      {grid, moved, score, x} = try do
          while_fun_20.(while_fun_20, grid, moved, score, x)
        catch
          :break -> {grid, moved, score, x}
        end

      throw {:return, %{board: %{cells: grid}, score: score, moved: moved}}
    catch
      {:return, val} -> val
    end
  end
  def hasMoves(b) do
    try do
      y = 0
      while_fun_22 = fn while_fun_22, y ->
        if y < Process.get(:size) do
          x = 0
          while_fun_23 = fn while_fun_23, x ->
            if x < Process.get(:size) do
              if Enum.at(Enum.at(b.cells, y), x) == 0 do
                throw {:return, true}
              end
              if x + 1 < Process.get(:size) && Enum.at(Enum.at(b.cells, y), x) == Enum.at(Enum.at(b.cells, y), x + 1) do
                throw {:return, true}
              end
              if y + 1 < Process.get(:size) && Enum.at(Enum.at(b.cells, y), x) == Enum.at(Enum.at(b.cells, y + 1), x) do
                throw {:return, true}
              end
              x = x + 1
              while_fun_23.(while_fun_23, x)
            else
              x
            end
          end
          x = try do
              while_fun_23.(while_fun_23, x)
            catch
              :break -> x
            end

          y = y + 1
          while_fun_22.(while_fun_22, y)
        else
          y
        end
      end
      y = try do
          while_fun_22.(while_fun_22, y)
        catch
          :break -> y
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def has2048(b) do
    try do
      y = 0
      while_fun_24 = fn while_fun_24, y ->
        if y < Process.get(:size) do
          x = 0
          while_fun_25 = fn while_fun_25, x ->
            if x < Process.get(:size) do
              if Enum.at(Enum.at(b.cells, y), x) >= 2048 do
                throw {:return, true}
              end
              x = x + 1
              while_fun_25.(while_fun_25, x)
            else
              x
            end
          end
          x = try do
              while_fun_25.(while_fun_25, x)
            catch
              :break -> x
            end

          y = y + 1
          while_fun_24.(while_fun_24, y)
        else
          y
        end
      end
      y = try do
          while_fun_24.(while_fun_24, y)
        catch
          :break -> y
        end

      throw {:return, false}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    mem_start = _mem()
    t_start = _now()
    board = newBoard()
    r = spawnTile(board)
    board = r.board
    full = r.full
    r = spawnTile(board)
    board = r.board
    full = r.full
    score = 0
    draw(board, score)
    while_fun_26 = fn while_fun_26, board, full, score ->
      if true do
        try do
          IO.puts("Move: ")
          cmd = case IO.gets("") do
  nil -> ""
  :eof -> ""
  line -> String.trim(line)
end
          moved = false
          {moved} = if cmd == "a" || cmd == "A" do
            m = moveLeft(board, score)
            board = m.board
            score = m.score
            moved = m.moved
            {moved}
          else
            {moved}
          end
          {moved} = if cmd == "d" || cmd == "D" do
            m = moveRight(board, score)
            board = m.board
            score = m.score
            moved = m.moved
            {moved}
          else
            {moved}
          end
          {moved} = if cmd == "w" || cmd == "W" do
            m = moveUp(board, score)
            board = m.board
            score = m.score
            moved = m.moved
            {moved}
          else
            {moved}
          end
          {moved} = if cmd == "s" || cmd == "S" do
            m = moveDown(board, score)
            board = m.board
            score = m.score
            moved = m.moved
            {moved}
          else
            {moved}
          end
          if cmd == "q" || cmd == "Q" do
            throw :break
          end
          if moved do
            r2 = spawnTile(board)
            board = r2.board
            full = r2.full
            if full && (!hasMoves(board)) do
              draw(board, score)
              IO.puts("Game Over")
              throw :break
            end
          end
          draw(board, score)
          if has2048(board) do
            IO.puts("You win!")
            throw :break
          end
          if !hasMoves(board) do
            IO.puts("Game Over")
            throw :break
          end
        catch
          :continue -> nil
        end
        while_fun_26.(while_fun_26, board, full, score)
      else
        {board, full, score}
      end
    end
    {board, full, score} = try do
        while_fun_26.(while_fun_26, board, full, score)
      catch
        :break -> {board, full, score}
      end

    duration_us = div(_now() - t_start, 1000)
    mem_diff = abs(_mem() - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
