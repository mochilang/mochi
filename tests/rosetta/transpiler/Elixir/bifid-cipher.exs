# Code generated by Mochi transpiler 2025-07-27 12:23 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      abs(System.os_time(:nanosecond))
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) -> String.slice(base, start, len)
      len == 1 -> Enum.slice(base, start, len)
      true -> Enum.slice(base, start, len)
    end
  end
  defp _len(x) do
    (if is_binary(x), do: String.length(x), else: length(x))
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  def square_to_maps(square) do
    try do
      emap = %{}
      dmap = %{}
      x = 0
      while_fun = fn while_fun, dmap, emap, x ->
        if x < _len(square) do
          row = Enum.at(square, x)
          y = 0
          while_fun_2 = fn while_fun_2, dmap, emap, y ->
            if y < _len(row) do
              ch = Enum.at(row, y)
              emap = Map.put(emap, ch, [x, y])
              dmap = Map.put(dmap, ((Kernel.to_string(x) <> ",") <> Kernel.to_string(y)), ch)
              y = y + 1
              while_fun_2.(while_fun_2, dmap, emap, y)
            else
              {dmap, emap, y}
            end
          end
          {dmap, emap, y} = try do
              while_fun_2.(while_fun_2, dmap, emap, y)
            catch
              :break -> {dmap, emap, y}
            end

          x = x + 1
          while_fun.(while_fun, dmap, emap, x)
        else
          {dmap, emap, x}
        end
      end
      {dmap, emap, x} = try do
          while_fun.(while_fun, dmap, emap, x)
        catch
          :break -> {dmap, emap, x}
        end

      throw {:return, %{"e" => emap, "d" => dmap}}
    catch
      {:return, val} -> val
    end
  end
  def remove_space(text, emap) do
    try do
      s = String.upcase(text)
      out = ""
      i = 0
      while_fun_3 = fn while_fun_3, i, out ->
        if i < String.length(s) do
          ch = String.slice(s, i, (i + 1) - i)
          {out} = if ch != " " && (Map.has_key?(emap, ch)) do
            out = (out <> ch)
            {out}
          else
            {out}
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, out)
        else
          {i, out}
        end
      end
      {i, out} = try do
          while_fun_3.(while_fun_3, i, out)
        catch
          :break -> {i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def encrypt(text, emap, dmap) do
    try do
      text = Main.remove_space(text, emap)
      row0 = []
      row1 = []
      i = 0
      while_fun_4 = fn while_fun_4, i, row0, row1 ->
        if i < String.length(text) do
          ch = String.slice(text, i, (i + 1) - i)
          xy = emap[ch]
          row0 = (row0 ++ [Enum.at(xy, 0)])
          row1 = (row1 ++ [Enum.at(xy, 1)])
          i = i + 1
          while_fun_4.(while_fun_4, i, row0, row1)
        else
          {i, row0, row1}
        end
      end
      {i, row0, row1} = try do
          while_fun_4.(while_fun_4, i, row0, row1)
        catch
          :break -> {i, row0, row1}
        end

      {row0} = Enum.reduce(row1, {row0}, fn v, {row0} ->
        row0 = (row0 ++ [v])
        {row0}
      end)
      res = ""
      j = 0
      while_fun_5 = fn while_fun_5, j, res ->
        if j < _len(row0) do
          key = ((Kernel.to_string(Enum.at(row0, j)) <> ",") <> Kernel.to_string(Enum.at(row0, j + 1)))
          res = (res <> dmap[key])
          j = j + 2
          while_fun_5.(while_fun_5, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_5.(while_fun_5, j, res)
        catch
          :break -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def decrypt(text, emap, dmap) do
    try do
      text = Main.remove_space(text, emap)
      coords = []
      i = 0
      while_fun_6 = fn while_fun_6, coords, i ->
        if i < String.length(text) do
          ch = String.slice(text, i, (i + 1) - i)
          xy = emap[ch]
          coords = (coords ++ [Enum.at(xy, 0)])
          coords = (coords ++ [Enum.at(xy, 1)])
          i = i + 1
          while_fun_6.(while_fun_6, coords, i)
        else
          {coords, i}
        end
      end
      {coords, i} = try do
          while_fun_6.(while_fun_6, coords, i)
        catch
          :break -> {coords, i}
        end

      half = div(_len(coords), 2)
      k1 = []
      k2 = []
      idx = 0
      while_fun_7 = fn while_fun_7, idx, k1 ->
        if idx < half do
          k1 = (k1 ++ [Enum.at(coords, idx)])
          idx = idx + 1
          while_fun_7.(while_fun_7, idx, k1)
        else
          {idx, k1}
        end
      end
      {idx, k1} = try do
          while_fun_7.(while_fun_7, idx, k1)
        catch
          :break -> {idx, k1}
        end

      while_fun_8 = fn while_fun_8, idx, k2 ->
        if idx < _len(coords) do
          k2 = (k2 ++ [Enum.at(coords, idx)])
          idx = idx + 1
          while_fun_8.(while_fun_8, idx, k2)
        else
          {idx, k2}
        end
      end
      {idx, k2} = try do
          while_fun_8.(while_fun_8, idx, k2)
        catch
          :break -> {idx, k2}
        end

      res = ""
      j = 0
      while_fun_9 = fn while_fun_9, j, res ->
        if j < half do
          key = ((Kernel.to_string(Enum.at(k1, j)) <> ",") <> Kernel.to_string(Enum.at(k2, j)))
          res = (res <> dmap[key])
          j = j + 1
          while_fun_9.(while_fun_9, j, res)
        else
          {j, res}
        end
      end
      {j, res} = try do
          while_fun_9.(while_fun_9, j, res)
        catch
          :break -> {j, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      squareRosetta = [["A", "B", "C", "D", "E"], ["F", "G", "H", "I", "K"], ["L", "M", "N", "O", "P"], ["Q", "R", "S", "T", "U"], ["V", "W", "X", "Y", "Z"], ["J", "1", "2", "3", "4"]]
      squareWikipedia = [["B", "G", "W", "K", "Z"], ["Q", "P", "N", "D", "S"], ["I", "O", "A", "X", "E"], ["F", "C", "L", "U", "M"], ["T", "H", "Y", "V", "R"], ["J", "1", "2", "3", "4"]]
      textRosetta = "0ATTACKATDAWN"
      textWikipedia = "FLEEATONCE"
      textTest = "The invasion will start on the first of January"
      maps = Main.square_to_maps(squareRosetta)
      emap = maps["e"]
      dmap = maps["d"]
      IO.puts("from Rosettacode")
      IO.puts(("original:\t " <> textRosetta))
      s = Main.encrypt(textRosetta, emap, dmap)
      IO.puts(("codiert:\t " <> s))
      s = Main.decrypt(s, emap, dmap)
      IO.puts(("and back:\t " <> s))
      maps = Main.square_to_maps(squareWikipedia)
      emap = maps["e"]
      dmap = maps["d"]
      IO.puts("from Wikipedia")
      IO.puts(("original:\t " <> textWikipedia))
      s = Main.encrypt(textWikipedia, emap, dmap)
      IO.puts(("codiert:\t " <> s))
      s = Main.decrypt(s, emap, dmap)
      IO.puts(("and back:\t " <> s))
      maps = Main.square_to_maps(squareWikipedia)
      emap = maps["e"]
      dmap = maps["d"]
      IO.puts("from Rosettacode long part")
      IO.puts(("original:\t " <> textTest))
      s = Main.encrypt(textTest, emap, dmap)
      IO.puts(("codiert:\t " <> s))
      s = Main.decrypt(s, emap, dmap)
      IO.puts(("and back:\t " <> s))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    mem_start = _mem()
    t_start = _now()
    main()
    duration_us = div(_now() - t_start, 1000)
    mem_diff = abs(_mem() - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
