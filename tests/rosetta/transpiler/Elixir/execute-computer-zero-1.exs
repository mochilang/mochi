# Code generated by Mochi transpiler 2025-08-04 21:17 +0700
defmodule Main do
  def _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      System.unique_integer([:positive, :monotonic])
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    n = trunc(n)
    d = trunc(d)
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  defp _sha256(bs) do
    bin = :erlang.list_to_binary(bs)
    :crypto.hash(:sha256, bin) |> :erlang.binary_to_list()
  end
  defp _getenv(name) do
    System.get_env(name)
  end
  defp _environ() do
    System.get_env() |> Enum.map(fn {k, v} -> "#{k}=#{v}" end)
  end
  def trim(s) do
    try do
      start = 0
      while_fun = fn while_fun, start ->
        if start < _len(s) && (_slice(s, start, (start + 1) - start) == " " || _slice(s, start, (start + 1) - start) == "\t") do
          start = start + 1
          while_fun.(while_fun, start)
        else
          start
        end
      end
      start = try do
          while_fun.(while_fun, start)
        catch
          {:break, {start}} -> start
        end

      end_ = _len(s)
      while_fun_2 = fn while_fun_2, end_ ->
        if end_ > start && (_slice(s, end_ - 1, end_ - (end_ - 1)) == " " || _slice(s, end_ - 1, end_ - (end_ - 1)) == "\t") do
          end_ = end_ - 1
          while_fun_2.(while_fun_2, end_)
        else
          end_
        end
      end
      end_ = try do
          while_fun_2.(while_fun_2, end_)
        catch
          {:break, {end_}} -> end_
        end

      throw {:return, _slice(s, start, end_ - (start))}
    catch
      {:return, val} -> val
    end
  end
  def split(s, sep) do
    try do
      parts = []
      cur = ""
      i = 0
      while_fun_3 = fn while_fun_3, cur, i, parts ->
        if i < _len(s) do
          {cur, i, parts} = if _len(sep) > 0 && i + _len(sep) <= _len(s) && _slice(s, i, i + _len(sep) - (i)) == sep do
            parts = (parts ++ [cur])
            cur = ""
            i = i + _len(sep)
            {cur, i, parts}
          else
            cur = (cur <> _slice(s, i, i + 1 - (i)))
            i = i + 1
            {cur, i, parts}
          end
          while_fun_3.(while_fun_3, cur, i, parts)
        else
          {cur, i, parts}
        end
      end
      {cur, i, parts} = try do
          while_fun_3.(while_fun_3, cur, i, parts)
        catch
          {:break, {cur, i, parts}} -> {cur, i, parts}
        end

      parts = (parts ++ [cur])
      throw {:return, parts}
    catch
      {:return, val} -> val
    end
  end
  def splitWS(s) do
    try do
      out = []
      cur = ""
      i = 0
      while_fun_4 = fn while_fun_4, cur, i, out ->
        if i < _len(s) do
          ch = _slice(s, i, i + 1 - (i))
          {cur, out} = if ch == " " || ch == "\t" do
            {cur, out} = if _len(cur) > 0 do
              out = (out ++ [cur])
              cur = ""
              {cur, out}
            else
              {cur, out}
            end
            {cur, out}
          else
            cur = (cur <> ch)
            {cur, out}
          end
          i = i + 1
          while_fun_4.(while_fun_4, cur, i, out)
        else
          {cur, i, out}
        end
      end
      {cur, i, out} = try do
          while_fun_4.(while_fun_4, cur, i, out)
        catch
          {:break, {cur, i, out}} -> {cur, i, out}
        end

      {out} = if _len(cur) > 0 do
        out = (out ++ [cur])
        {out}
      else
        {out}
      end
      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def indexOf(s, ch) do
    try do
      i = 0
      while_fun_5 = fn while_fun_5, i ->
        if i < _len(s) do
          if _slice(s, i, i + 1 - (i)) == ch do
            throw {:return, i}
          end
          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      i = try do
          while_fun_5.(while_fun_5, i)
        catch
          {:break, {i}} -> i
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def parseIntStr(str) do
    try do
      i = 0
      neg = false
      {i, neg} = if _len(str) > 0 && _slice(str, 0, 1 - 0) == "-" do
        neg = true
        i = 1
        {i, neg}
      else
        {i, neg}
      end
      n = 0
      digits = %{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
      while_fun_6 = fn while_fun_6, i, n ->
        if i < _len(str) do
          n = n * 10 + digits[_slice(str, i, (i + 1) - i)]
          i = i + 1
          while_fun_6.(while_fun_6, i, n)
        else
          {i, n}
        end
      end
      {i, n} = try do
          while_fun_6.(while_fun_6, i, n)
        catch
          {:break, {i, n}} -> {i, n}
        end

      {n} = if neg do
        n = -n
        {n}
      else
        {n}
      end
      throw {:return, n}
    catch
      {:return, val} -> val
    end
  end
  def parseAsm(asm) do
    try do
      lines = split(asm, "\n")
      instrs = []
      labels = %{}
      lineNum = 0
      i = 0
      while_fun_7 = fn while_fun_7, i, instrs, labels, lineNum ->
        if i < _len(lines) do
          line = Enum.at(lines, i)
          {line} = if indexOf(line, ";") != (-1) do
            line = _slice(line, 0, indexOf(line, ";") - (0))
            {line}
          else
            {line}
          end
          line = trim(line)
          label = ""
          {label, line} = if indexOf(line, ":") != (-1) do
            idx = indexOf(line, ":")
            label = trim(_slice(line, 0, idx - (0)))
            line = trim(_slice(line, idx + 1, _len(line) - (idx + 1)))
            {label, line}
          else
            {label, line}
          end
          opcode = ""
          arg = ""
          {arg, opcode} = if _len(line) > 0 do
            parts = splitWS(line)
            {opcode} = if _len(parts) > 0 do
              opcode = Enum.at(parts, 0)
              {opcode}
            else
              {opcode}
            end
            {arg, opcode} = if _len(parts) > 1 do
              arg = Enum.at(parts, 1)
              {arg, opcode}
            else
              ops = %{"NOP" => 0, "LDA" => 1, "STA" => 2, "ADD" => 3, "SUB" => 4, "BRZ" => 5, "JMP" => 6, "STP" => 7}
              {arg, opcode} = if !(opcode in ops) do
                arg = opcode
                opcode = ""
                {arg, opcode}
              else
                {arg, opcode}
              end
              {arg, opcode}
            end
            {arg, opcode}
          else
            {arg, opcode}
          end
          {labels} = if label != "" do
            labels = Map.put(labels, label, lineNum)
            {labels}
          else
            {labels}
          end
          instrs = (instrs ++ [%{Label: label, Opcode: opcode, Arg: arg}])
          lineNum = lineNum + 1
          i = i + 1
          while_fun_7.(while_fun_7, i, instrs, labels, lineNum)
        else
          {i, instrs, labels, lineNum}
        end
      end
      {i, instrs, labels, lineNum} = try do
          while_fun_7.(while_fun_7, i, instrs, labels, lineNum)
        catch
          {:break, {i, instrs, labels, lineNum}} -> {i, instrs, labels, lineNum}
        end

      throw {:return, %{"instructions" => instrs, "labels" => labels}}
    catch
      {:return, val} -> val
    end
  end
  def compile(p) do
    try do
      instrs = p["instructions"]
      labels = p["labels"]
      bytecode = []
      i = 0
      opcodes = %{"NOP" => 0, "LDA" => 1, "STA" => 2, "ADD" => 3, "SUB" => 4, "BRZ" => 5, "JMP" => 6, "STP" => 7}
      while_fun_8 = fn while_fun_8, bytecode, i ->
        if i < _len(instrs) do
          ins = Enum.at(instrs, i)
          arg = 0
          {arg} = if ins[:Arg] != "" do
            arg = (if Map.has_key?(labels, ins[:Arg]), do: labels[ins[:Arg]], else: parseIntStr(ins[:Arg]))
            {arg}
          else
            {arg}
          end
          code = 0
          {code} = if ins[:Opcode] != "" do
            code = opcodes[ins[:Opcode]]
            {code}
          else
            {code}
          end
          bytecode = (bytecode ++ [code * 32 + arg])
          i = i + 1
          while_fun_8.(while_fun_8, bytecode, i)
        else
          {bytecode, i}
        end
      end
      {bytecode, i} = try do
          while_fun_8.(while_fun_8, bytecode, i)
        catch
          {:break, {bytecode, i}} -> {bytecode, i}
        end

      while_fun_9 = fn while_fun_9, bytecode ->
        if _len(bytecode) < 32 do
          bytecode = (bytecode ++ [0])
          while_fun_9.(while_fun_9, bytecode)
        else
          bytecode
        end
      end
      bytecode = try do
          while_fun_9.(while_fun_9, bytecode)
        catch
          {:break, {bytecode}} -> bytecode
        end

      throw {:return, bytecode}
    catch
      {:return, val} -> val
    end
  end
  def floorMod(a, b) do
    try do
      r = rem(a, b)
      {r} = if r < 0 do
        r = r + b
        {r}
      else
        {r}
      end
      throw {:return, r}
    catch
      {:return, val} -> val
    end
  end
  def run(bytecode) do
    try do
      acc = 0
      pc = 0
      mem = []
      i = 0
      while_fun_10 = fn while_fun_10, i, mem ->
        if i < _len(bytecode) do
          mem = (mem ++ [Enum.at(bytecode, i)])
          i = i + 1
          while_fun_10.(while_fun_10, i, mem)
        else
          {i, mem}
        end
      end
      {i, mem} = try do
          while_fun_10.(while_fun_10, i, mem)
        catch
          {:break, {i, mem}} -> {i, mem}
        end

      while_fun_11 = fn while_fun_11, acc, mem, pc ->
        if pc < 32 do
          try do
            op = div(Enum.at(mem, pc), 32)
            arg = rem(Enum.at(mem, pc), 32)
            pc = pc + 1
            {acc, mem, pc} = if op == 0 do
              throw :continue
              {acc, mem, pc}
            else
              {acc, mem, pc} = if op == 1 do
                acc = Enum.at(mem, arg)
                {acc, mem, pc}
              else
                {acc, mem, pc} = if op == 2 do
                  mem = List.replace_at(mem, arg, acc)
                  {acc, mem, pc}
                else
                  {acc, pc} = if op == 3 do
                    acc = floorMod(acc + Enum.at(mem, arg), 256)
                    {acc, pc}
                  else
                    {acc, pc} = if op == 4 do
                      acc = floorMod(acc - Enum.at(mem, arg), 256)
                      {acc, pc}
                    else
                      {pc} = if op == 5 do
                        {pc} = if acc == 0 do
                          pc = arg
                          {pc}
                        else
                          {pc}
                        end
                        {pc}
                      else
                        {pc} = if op == 6 do
                          pc = arg
                          {pc}
                        else
                          if op == 7 do
                            throw {:break, {acc, mem, pc}}
                          else
                            throw {:break, {acc, mem, pc}}
                          end
                          {pc}
                        end
                        {pc}
                      end
                      {acc, pc}
                    end
                    {acc, pc}
                  end
                  {acc, mem, pc}
                end
                {acc, mem, pc}
              end
              {acc, mem, pc}
            end
          catch
            :continue -> nil
          end
          while_fun_11.(while_fun_11, acc, mem, pc)
        else
          {acc, mem, pc}
        end
      end
      {acc, mem, pc} = try do
          while_fun_11.(while_fun_11, acc, mem, pc)
        catch
          {:break, {acc, mem, pc}} -> {acc, mem, pc}
        end

      throw {:return, acc}
    catch
      {:return, val} -> val
    end
  end
  def execute(asm) do
    try do
      parsed = parseAsm(asm)
      bc = compile(parsed)
      throw {:return, run(bc)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      examples = [(((("LDA   x\n" <> "ADD   y       ; accumulator = x + y\n") <> "STP\n") <> "x:            2\n") <> "y:            2"), ((((((((((((("loop:   LDA   prodt\n" <> "        ADD   x\n") <> "        STA   prodt\n") <> "        LDA   y\n") <> "        SUB   one\n") <> "        STA   y\n") <> "        BRZ   done\n") <> "        JMP   loop\n") <> "done:   LDA   prodt   ; to display it\n") <> "        STP\n") <> "x:            8\n") <> "y:            7\n") <> "prodt:        0\n") <> "one:          1"), ((((((((((((((((("loop:   LDA   n\n" <> "        STA   temp\n") <> "        ADD   m\n") <> "        STA   n\n") <> "        LDA   temp\n") <> "        STA   m\n") <> "        LDA   count\n") <> "        SUB   one\n") <> "        BRZ   done\n") <> "        STA   count\n") <> "        JMP   loop\n") <> "done:   LDA   n       ; to display it\n") <> "        STP\n") <> "m:            1\n") <> "n:            1\n") <> "temp:         0\n") <> "count:        8       ; valid range: 1-11\n") <> "one:          1"), ((((((((((((((((((((((((((((((("start:  LDA   load\n" <> "ADD   car     ; head of list\n") <> "STA   ldcar\n") <> "ADD   one\n") <> "STA   ldcdr   ; next CONS cell\n") <> "ldcar:  NOP\n") <> "STA   value\n") <> "ldcdr:  NOP\n") <> "BRZ   done    ; 0 stands for NIL\n") <> "STA   car\n") <> "JMP   start\n") <> "done:   LDA   value   ; CAR of last CONS\n") <> "STP\n") <> "load:   LDA   0\n") <> "value:        0\n") <> "car:          28\n") <> "one:          1\n") <> "                        ; order of CONS cells\n") <> "                        ; in memory\n") <> "                        ; does not matter\n") <> "        6\n") <> "        0       ; 0 stands for NIL\n") <> "        2       ; (CADR ls)\n") <> "        26      ; (CDDR ls) -- etc.\n") <> "        5\n") <> "        20\n") <> "        3\n") <> "        30\n") <> "        1       ; value of (CAR ls)\n") <> "        22      ; points to (CDR ls)\n") <> "        4\n") <> "        24"), (((("LDA  3\n" <> "SUB  4\n") <> "STP  0\n") <> "         0\n") <> "         255"), (((("LDA  3\n" <> "SUB  4\n") <> "STP  0\n") <> "                0\n") <> "                1"), (((("LDA  3\n" <> "ADD  4\n") <> "STP  0\n") <> "                1\n") <> "                255")]
      i = 0
      while_fun_12 = fn while_fun_12, i ->
        if i < _len(examples) do
          res = execute(Enum.at(examples, i))
          IO.puts(Kernel.to_string(res))
          i = i + 1
          while_fun_12.(while_fun_12, i)
        else
          i
        end
      end
      i = try do
          while_fun_12.(while_fun_12, i)
        catch
          {:break, {i}} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
