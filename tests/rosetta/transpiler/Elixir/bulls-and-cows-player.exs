# Code generated by Mochi transpiler 2025-07-27 23:55 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      abs(System.os_time(:nanosecond))
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  defp _sha256(bs) do
    bin = :erlang.list_to_binary(bs)
    :crypto.hash(:sha256, bin) |> :erlang.binary_to_list()
  end
  def indexOf(s, ch) do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < _len(s) do
          if _slice(s, i, i + 1 - (i)) == ch do
            throw {:return, i}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          {:break, i} -> i
        end

      throw {:return, -1}
    catch
      {:return, val} -> val
    end
  end
  def fields(s) do
    try do
      words = []
      cur = ""
      i = 0
      while_fun_2 = fn while_fun_2, cur, i, words ->
        if i < _len(s) do
          ch = _slice(s, i, i + 1 - (i))
          {cur, words} = if ch == " " || ch == "\t" || ch == "\n" do
            {cur, words} = if _len(cur) > 0 do
              words = (words ++ [cur])
              cur = ""
              {cur, words}
            else
              {cur, words}
            end
            {cur, words}
          else
            cur = (cur <> ch)
            {cur, words}
          end
          i = i + 1
          while_fun_2.(while_fun_2, cur, i, words)
        else
          {cur, i, words}
        end
      end
      {cur, i, words} = try do
          while_fun_2.(while_fun_2, cur, i, words)
        catch
          {:break, {cur, i, words}} -> {cur, i, words}
        end

      {words} = if _len(cur) > 0 do
        words = (words ++ [cur])
        {words}
      else
        {words}
      end
      throw {:return, words}
    catch
      {:return, val} -> val
    end
  end
  def makePatterns() do
    try do
      digits = ["1", "2", "3", "4", "5", "6", "7", "8", "9"]
      pats = []
      i = 0
      while_fun_3 = fn while_fun_3, i, pats ->
        if i < _len(digits) do
          j = 0
          while_fun_4 = fn while_fun_4, j, pats ->
            if j < _len(digits) do
              {pats} = if j != i do
                k = 0
                while_fun_5 = fn while_fun_5, k, pats ->
                  if k < _len(digits) do
                    {pats} = if k != i && k != j do
                      l = 0
                      while_fun_6 = fn while_fun_6, l, pats ->
                        if l < _len(digits) do
                          {pats} = if l != i && l != j && l != k do
                            pats = (pats ++ [(((Enum.at(digits, i) <> Enum.at(digits, j)) <> Enum.at(digits, k)) <> Enum.at(digits, l))])
                            {pats}
                          else
                            {pats}
                          end
                          l = l + 1
                          while_fun_6.(while_fun_6, l, pats)
                        else
                          {l, pats}
                        end
                      end
                      {l, pats} = try do
                          while_fun_6.(while_fun_6, l, pats)
                        catch
                          {:break, {l, pats}} -> {l, pats}
                        end

                      {pats}
                    else
                      {pats}
                    end
                    k = k + 1
                    while_fun_5.(while_fun_5, k, pats)
                  else
                    {k, pats}
                  end
                end
                {k, pats} = try do
                    while_fun_5.(while_fun_5, k, pats)
                  catch
                    {:break, {k, pats}} -> {k, pats}
                  end

                {pats}
              else
                {pats}
              end
              j = j + 1
              while_fun_4.(while_fun_4, j, pats)
            else
              {j, pats}
            end
          end
          {j, pats} = try do
              while_fun_4.(while_fun_4, j, pats)
            catch
              {:break, {j, pats}} -> {j, pats}
            end

          i = i + 1
          while_fun_3.(while_fun_3, i, pats)
        else
          {i, pats}
        end
      end
      {i, pats} = try do
          while_fun_3.(while_fun_3, i, pats)
        catch
          {:break, {i, pats}} -> {i, pats}
        end

      throw {:return, pats}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts(((((("Cows and bulls/player\n" <> "You think of four digit number of unique digits in the range 1 to 9.\n") <> "I guess.  You score my guess:\n") <> "    A correct digit but not in the correct place is a cow.\n") <> "    A correct digit in the correct place is a bull.\n") <> "You give my score as two numbers separated with a space."))
      patterns = Main.makePatterns()
      while_fun_7 = fn while_fun_7, patterns ->
        if true do
          if _len(patterns) == 0 do
            IO.puts("Oops, check scoring.")
            throw {:return, nil}
          end
          guess = Enum.at(patterns, 0)
          patterns = _slice(patterns, 1, _len(patterns) - 1)
          cows = 0
          bulls = 0
          while_fun_8 = fn while_fun_8, bulls, cows ->
            if true do
              IO.puts((("My guess: " <> guess) <> ".  Score? (c b) "))
              line = case IO.gets("") do
  nil -> ""
  :eof -> ""
  line -> String.trim(line)
end
              toks = Main.fields(line)
              {bulls, cows} = if _len(toks) == 2 do
                c = String.to_integer(Enum.at(toks, 0))
                b = String.to_integer(Enum.at(toks, 1))
                {bulls, cows} = if c >= 0 && c <= 4 && b >= 0 && b <= 4 && c + b <= 4 do
                  cows = c
                  bulls = b
                  throw {:break, {bulls, cows}}
                  {bulls, cows}
                else
                  {bulls, cows}
                end
                {bulls, cows}
              else
                {bulls, cows}
              end
              IO.puts("Score guess as two numbers: cows bulls")
              while_fun_8.(while_fun_8, bulls, cows)
            else
              {bulls, cows}
            end
          end
          {bulls, cows} = try do
              while_fun_8.(while_fun_8, bulls, cows)
            catch
              {:break, {bulls, cows}} -> {bulls, cows}
            end

          if bulls == 4 do
            IO.puts("I did it. :)")
            throw {:return, nil}
          end
          next = []
          idx = 0
          while_fun_9 = fn while_fun_9, idx, next ->
            if idx < _len(patterns) do
              pat = Enum.at(patterns, idx)
              c = 0
              b = 0
              i = 0
              while_fun_10 = fn while_fun_10, b, c, i ->
                if i < 4 do
                  cg = _slice(guess, i, i + 1 - (i))
                  cp = _slice(pat, i, i + 1 - (i))
                  {b, c} = if cg == cp do
                    b = b + 1
                    {b, c}
                  else
                    {c} = if Main.indexOf(pat, cg) >= 0 do
                      c = c + 1
                      {c}
                    else
                      {c}
                    end
                    {b, c}
                  end
                  i = i + 1
                  while_fun_10.(while_fun_10, b, c, i)
                else
                  {b, c, i}
                end
              end
              {b, c, i} = try do
                  while_fun_10.(while_fun_10, b, c, i)
                catch
                  {:break, {b, c, i}} -> {b, c, i}
                end

              {next} = if c == cows && b == bulls do
                next = (next ++ [pat])
                {next}
              else
                {next}
              end
              idx = idx + 1
              while_fun_9.(while_fun_9, idx, next)
            else
              {idx, next}
            end
          end
          {idx, next} = try do
              while_fun_9.(while_fun_9, idx, next)
            catch
              {:break, {idx, next}} -> {idx, next}
            end

          patterns = next
          while_fun_7.(while_fun_7, patterns)
        else
          patterns
        end
      end
      patterns = try do
          while_fun_7.(while_fun_7, patterns)
        catch
          {:break, patterns} -> patterns
        end

    catch
      {:return, val} -> val
    end
  end
end
Main.main()
