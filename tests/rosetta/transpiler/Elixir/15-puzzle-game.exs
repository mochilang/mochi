# Code generated by Mochi transpiler 2025-07-22 17:27 +0700
defmodule Main do
  @board [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
  @solved [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
  @empty 15
  @moves 0
  @quit false
  def randMove() do
    try do
      throw {:return, rem(now.(), 4)}
    catch
      {:return, val} -> val
    end
  end
  def isSolved() do
    try do
      i = 0
      while_fun = fn while_fun ->
        if i < 16 do
          if Enum.at(@board, i) != Enum.at(@solved, i) do
            throw {:return, false}
          end
          i = i + 1
          while_fun.(while_fun)
        else
          nil
        end
      end
      while_fun.(while_fun)
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def isValidMove(m) do
    try do
      if m == 0 do
        throw {:return, %{"idx" => @empty - 4, "ok" => @empty / 4 > 0}}
      end
      if m == 1 do
        throw {:return, %{"idx" => @empty + 4, "ok" => @empty / 4 < 3}}
      end
      if m == 2 do
        throw {:return, %{"idx" => @empty + 1, "ok" => rem(@empty, 4) < 3}}
      end
      if m == 3 do
        throw {:return, %{"idx" => @empty - 1, "ok" => rem(@empty, 4) > 0}}
      end
      throw {:return, %{"idx" => 0, "ok" => false}}
    catch
      {:return, val} -> val
    end
  end
  def doMove(m) do
    try do
      r = isValidMove(m)
      if !Enum.at(r, "ok") do
        throw {:return, false}
      end
      i = @empty
      j = int.(Enum.at(r, "idx"))
      tmp = Enum.at(@board, i)
      board = List.replace_at(@board, i, Enum.at(@board, j))
      board = List.replace_at(@board, j, tmp)
      empty = j
      moves = @moves + 1
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def shuffle(n) do
    try do
      i = 0
      while_fun = fn while_fun ->
        if i < n || isSolved() do
          if doMove(randMove()) do
            i = i + 1
          end
          while_fun.(while_fun)
        else
          nil
        end
      end
      while_fun.(while_fun)
    catch
      {:return, val} -> val
    end
  end
  def printBoard() do
    try do
      line = ""
      i = 0
      while_fun = fn while_fun ->
        if i < 16 do
          val = Enum.at(@board, i)
          if val == 0 do
            line = (line <> "  .")
          else
            s = to_string(val)
            if val < 10 do
              line = (line <> "  ") + s
            else
              line = (line <> " ") + s
            end
          end
          if rem(i, 4) == 3 do
            IO.inspect(line)
            line = ""
          end
          i = i + 1
          while_fun.(while_fun)
        else
          nil
        end
      end
      while_fun.(while_fun)
    catch
      {:return, val} -> val
    end
  end
  def playOneMove() do
    try do
      while_fun = fn while_fun, quit ->
        if true do
          try do
            IO.puts((("Enter move #" <> to_string(@moves + 1)) <> " (U, D, L, R, or Q): "))
            s = input.()
            if s == "" do
              throw :continue
            end
            c = Enum.slice(s, 0, 1 - 0)
            m = 0
            if c == "U" || c == "u" do
              m = 0
            else
              if c == "D" || c == "d" do
                m = 1
              else
                if c == "R" || c == "r" do
                  m = 2
                else
                  if c == "L" || c == "l" do
                    m = 3
                  else
                    if c == "Q" || c == "q" do
                      IO.puts((("Quiting after " <> to_string(@moves)) <> " moves."))
                      quit = true
                      throw {:return, nil}
                    else
                      IO.puts(((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" <> "up, down, left, or right. You can also enter \"Q\" to quit.\n") <> "Upper or lowercase is accepted and only the first non-blank\n") <> "character is important (i.e. you may enter \"up\" if you like)."))
                      throw :continue
                    end
                  end
                end
              end
            end
            if !doMove(m) do
              IO.puts("That is not a valid move at the moment.")
              throw :continue
            end
            throw {:return, nil}
          catch
            :continue -> nil
          end
          while_fun.(while_fun, quit)
        else
          quit
        end
      end
      quit = while_fun.(while_fun, quit)
    catch
      {:return, val} -> val
    end
  end
  def play() do
    try do
      IO.puts("Starting board:")
      while_fun = fn while_fun ->
        if !@quit && isSolved() == false do
          IO.puts("")
          printBoard()
          playOneMove()
          while_fun.(while_fun)
        else
          nil
        end
      end
      while_fun.(while_fun)
      if isSolved() do
        IO.puts((("You solved the puzzle in " <> to_string(@moves)) <> " moves."))
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      shuffle(50)
      play()
    catch
      {:return, val} -> val
    end
  end
  def main() do
    main()
  end
end
Main.main()
