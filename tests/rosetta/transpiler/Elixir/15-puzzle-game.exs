# Code generated by Mochi transpiler 2025-07-23 23:30 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  Process.put(:board, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0])
  Process.put(:solved, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0])
  Process.put(:empty, 15)
  Process.put(:moves, 0)
  Process.put(:quit, false)
  def randMove() do
    try do
      throw {:return, rem(_now(), 4)}
    catch
      {:return, val} -> val
    end
  end
  def isSolved() do
    try do
      i = 0
      while_fun = fn while_fun, i ->
        if i < 16 do
          if Enum.at(Process.get(:board), i) != Enum.at(Process.get(:solved), i) do
            throw {:return, false}
          end
          i = i + 1
          while_fun.(while_fun, i)
        else
          i
        end
      end
      i = try do
          while_fun.(while_fun, i)
        catch
          :break -> i
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def isValidMove(m) do
    try do
      if m == 0 do
        throw {:return, %{idx: Process.get(:empty) - 4, ok: Process.get(:empty) / 4 > 0}}
      end
      if m == 1 do
        throw {:return, %{idx: Process.get(:empty) + 4, ok: Process.get(:empty) / 4 < 3}}
      end
      if m == 2 do
        throw {:return, %{idx: Process.get(:empty) + 1, ok: rem(Process.get(:empty), 4) < 3}}
      end
      if m == 3 do
        throw {:return, %{idx: Process.get(:empty) - 1, ok: rem(Process.get(:empty), 4) > 0}}
      end
      throw {:return, %{idx: 0, ok: false}}
    catch
      {:return, val} -> val
    end
  end
  def doMove(m) do
    try do
      r = isValidMove(m)
      if !r.ok do
        throw {:return, false}
      end
      i = Process.get(:empty)
      j = r.idx
      tmp = Enum.at(Process.get(:board), i)
      Process.put(:board, List.replace_at(Process.get(:board), i, Enum.at(Process.get(:board), j)))
      Process.put(:board, List.replace_at(Process.get(:board), j, tmp))
      Process.put(:empty, j)
      Process.put(:moves, Process.get(:moves) + 1)
      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def shuffle(n) do
    try do
      i = 0
      while_fun_2 = fn while_fun_2, i ->
        if i < n || isSolved() do
          if doMove(randMove()) do
            i = i + 1
          end
          while_fun_2.(while_fun_2, i)
        else
          i
        end
      end
      i = try do
          while_fun_2.(while_fun_2, i)
        catch
          :break -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def printBoard() do
    try do
      line = ""
      i = 0
      while_fun_3 = fn while_fun_3, i, line ->
        if i < 16 do
          val = Enum.at(Process.get(:board), i)
          if val == 0 do
            line = (line <> "  .")
          else
            s = to_string(val)
            line = if val < 10, do: ((line <> "  ") <> s), else: ((line <> " ") <> s)
          end
          if rem(i, 4) == 3 do
            IO.puts(line)
            line = ""
          end
          i = i + 1
          while_fun_3.(while_fun_3, i, line)
        else
          {i, line}
        end
      end
      {i, line} = try do
          while_fun_3.(while_fun_3, i, line)
        catch
          :break -> {i, line}
        end

    catch
      {:return, val} -> val
    end
  end
  def playOneMove() do
    try do
      while_fun_4 = fn while_fun_4 ->
        if true do
          try do
            IO.puts((("Enter move #" <> to_string(Process.get(:moves) + 1)) <> " (U, D, L, R, or Q): "))
            s = String.trim(IO.gets(""))
            if s == "" do
              throw :continue
            end
            c = Enum.slice(s, 0, 1 - 0)
            m = 0
            {m} = if c == "U" || c == "u" do
              m = 0
              {m}
            else
              {m} = if c == "D" || c == "d" do
                m = 1
                {m}
              else
                {m} = if c == "R" || c == "r" do
                  m = 2
                  {m}
                else
                  {m} = if c == "L" || c == "l" do
                    m = 3
                    {m}
                  else
                    if c == "Q" || c == "q" do
                      IO.puts((("Quiting after " <> to_string(Process.get(:moves))) <> " moves."))
                      Process.put(:quit, true)
                      throw {:return, nil}
                    else
                      IO.puts(((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" <> "up, down, left, or right. You can also enter \"Q\" to quit.\n") <> "Upper or lowercase is accepted and only the first non-blank\n") <> "character is important (i.e. you may enter \"up\" if you like)."))
                      throw :continue
                    end
                    {m}
                  end
                  {m}
                end
                {m}
              end
              {m}
            end
            if !doMove(m) do
              IO.puts("That is not a valid move at the moment.")
              throw :continue
            end
            throw {:return, nil}
          catch
            :continue -> nil
          end
          while_fun_4.(while_fun_4)
        else
          nil
        end
      end
      try do
        while_fun_4.(while_fun_4)
      catch
        :break -> nil
      end

    catch
      {:return, val} -> val
    end
  end
  def play() do
    try do
      IO.puts("Starting board:")
      while_fun_5 = fn while_fun_5 ->
        if !Process.get(:quit) && isSolved() == false do
          IO.puts("")
          printBoard()
          playOneMove()
          while_fun_5.(while_fun_5)
        else
          nil
        end
      end
      try do
        while_fun_5.(while_fun_5)
      catch
        :break -> nil
      end

      if isSolved() do
        IO.puts((("You solved the puzzle in " <> to_string(Process.get(:moves))) <> " moves."))
      end
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      shuffle(50)
      play()
    catch
      {:return, val} -> val
    end
  end
  def main() do
  end
end
Main.main()
