# Code generated by Mochi transpiler 2025-07-25 18:42 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) -> String.slice(base, start, len)
      len == 1 -> Enum.at(base, start)
      true -> Enum.slice(base, start, len)
    end
  end
  def node(cl, le, aa, ri) do
    try do
      throw {:return, %{"cl" => cl, "le" => le, "aa" => aa, "ri" => ri}}
    catch
      {:return, val} -> val
    end
  end
  def treeString(t) do
    try do
      if t == nil do
        throw {:return, "E"}
      end
      m = t
      throw {:return, (((((((("T(" <> m["cl"]) <> ", ") <> treeString(m["le"])) <> ", ") <> to_string(m["aa"])) <> ", ") <> treeString(m["ri"])) <> ")")}
    catch
      {:return, val} -> val
    end
  end
  def balance(t) do
    try do
      if t == nil do
        throw {:return, t}
      end
      m = t
      if m["cl"] != "B" do
        throw {:return, t}
      end
      le = m["le"]
      ri = m["ri"]
      if le != nil do
        leMap = le
        if leMap["cl"] == "R" do
          lele = leMap["le"]
          if lele != nil do
            leleMap = lele
            if leleMap["cl"] == "R" do
              throw {:return, node("R", node("B", leleMap["le"], leleMap["aa"], leleMap["ri"]), leMap["aa"], node("B", leMap["ri"], m["aa"], ri))}
            end
          end
          leri = leMap["ri"]
          if leri != nil do
            leriMap = leri
            if leriMap["cl"] == "R" do
              throw {:return, node("R", node("B", leMap["le"], leMap["aa"], leriMap["le"]), leriMap["aa"], node("B", leriMap["ri"], m["aa"], ri))}
            end
          end
        end
      end
      if ri != nil do
        riMap = ri
        if riMap["cl"] == "R" do
          rile = riMap["le"]
          if rile != nil do
            rileMap = rile
            if rileMap["cl"] == "R" do
              throw {:return, node("R", node("B", m["le"], m["aa"], rileMap["le"]), rileMap["aa"], node("B", rileMap["ri"], riMap["aa"], riMap["ri"]))}
            end
          end
          riri = riMap["ri"]
          if riri != nil do
            ririMap = riri
            if ririMap["cl"] == "R" do
              throw {:return, node("R", node("B", m["le"], m["aa"], riMap["le"]), riMap["aa"], node("B", ririMap["le"], ririMap["aa"], ririMap["ri"]))}
            end
          end
        end
      end
      throw {:return, t}
    catch
      {:return, val} -> val
    end
  end
  def ins(tr, x) do
    try do
      if tr == nil do
        throw {:return, node("R", nil, x, nil)}
      end
      if x < tr["aa"] do
        throw {:return, balance(node(tr["cl"], ins(tr["le"], x), tr["aa"], tr["ri"]))}
      end
      if x > tr["aa"] do
        throw {:return, balance(node(tr["cl"], tr["le"], tr["aa"], ins(tr["ri"], x)))}
      end
      throw {:return, tr}
    catch
      {:return, val} -> val
    end
  end
  def insert(tr, x) do
    try do
      t = ins(tr, x)
      if t == nil do
        throw {:return, nil}
      end
      m = t
      throw {:return, node("B", m["le"], m["aa"], m["ri"])}
    catch
      {:return, val} -> val
    end
  end
  Process.put(:tr, nil)
  Process.put(:i, 1)
  def main() do
    mem_start = _mem()
    t_start = _now()
    while_fun = fn while_fun ->
      if Process.get(:i) <= 16 do
        Process.put(:tr, insert(Process.get(:tr), Process.get(:i)))
        Process.put(:i, Process.get(:i) + 1)
        while_fun.(while_fun)
      else
        nil
      end
    end
    try do
      while_fun.(while_fun)
    catch
      :break -> nil
    end

    IO.puts(Kernel.to_string(treeString(Process.get(:tr))))
    duration_us = div(_now() - t_start, 1000)
    mem_diff = abs(_mem() - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.main()
