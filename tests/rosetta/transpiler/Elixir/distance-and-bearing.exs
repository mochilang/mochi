# Code generated by Mochi transpiler 2025-08-04 15:00 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      System.unique_integer([:positive, :monotonic])
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    n = trunc(n)
    d = trunc(d)
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  defp _sha256(bs) do
    bin = :erlang.list_to_binary(bs)
    :crypto.hash(:sha256, bin) |> :erlang.binary_to_list()
  end
  defp _getenv(name) do
    System.get_env(name)
  end
  defp _environ() do
    System.get_env() |> Enum.map(fn {k, v} -> "#{k}=#{v}" end)
  end
  def sinApprox(x) do
    try do
      term = x
      sum = x
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n <= 8 do
          denom = ((2 * n) * (2 * n + 1))
          term = -term * x * x / denom
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def cosApprox(x) do
    try do
      term = 1.0
      sum = 1.0
      n = 1
      while_fun_2 = fn while_fun_2, n, sum, term ->
        if n <= 8 do
          denom = ((2 * n - 1) * (2 * n))
          term = -term * x * x / denom
          sum = sum + term
          n = n + 1
          while_fun_2.(while_fun_2, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun_2.(while_fun_2, n, sum, term)
        catch
          {:break, {n, sum, term}} -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def atanApprox(x) do
    try do
      if x > 1.0 do
        throw {:return, Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      if x < (-1.0) do
        throw {:return, -Process.get(:pi) / 2.0 - x / (x * x + 0.28)}
      end
      throw {:return, x / (1.0 + 0.28 * x * x)}
    catch
      {:return, val} -> val
    end
  end
  def atan2Approx(y, x) do
    try do
      if x > 0.0 do
        r = atanApprox(y / x)
        throw {:return, r}
      end
      if x < 0.0 do
        if y >= 0.0 do
          throw {:return, atanApprox(y / x) + Process.get(:pi)}
        end
        throw {:return, atanApprox(y / x) - Process.get(:pi)}
      end
      if y > 0.0 do
        throw {:return, Process.get(:pi) / 2.0}
      end
      if y < 0.0 do
        throw {:return, -Process.get(:pi) / 2.0}
      end
      throw {:return, 0.0}
    catch
      {:return, val} -> val
    end
  end
  def sqrtApprox(x) do
    try do
      guess = x
      i = 0
      while_fun_3 = fn while_fun_3, guess, i ->
        if i < 10 do
          guess = (guess + x / guess) / 2.0
          i = i + 1
          while_fun_3.(while_fun_3, guess, i)
        else
          {guess, i}
        end
      end
      {guess, i} = try do
          while_fun_3.(while_fun_3, guess, i)
        catch
          {:break, {guess, i}} -> {guess, i}
        end

      throw {:return, guess}
    catch
      {:return, val} -> val
    end
  end
  def rad(x) do
    try do
      throw {:return, x * Process.get(:pi) / 180.0}
    catch
      {:return, val} -> val
    end
  end
  def deg(x) do
    try do
      throw {:return, x * 180.0 / Process.get(:pi)}
    catch
      {:return, val} -> val
    end
  end
  def distance(lat1, lon1, lat2, lon2) do
    try do
      phi1 = rad(lat1)
      phi2 = rad(lat2)
      dphi = rad(lat2 - lat1)
      dlambda = rad(lon2 - lon1)
      sdphi = sinApprox(dphi / 2)
      sdlambda = sinApprox(dlambda / 2)
      a = sdphi * sdphi + cosApprox(phi1) * cosApprox(phi2) * sdlambda * sdlambda
      c = 2 * atan2Approx(sqrtApprox(a), sqrtApprox(1 - a))
      throw {:return, (6371.0 / 1.852) * c}
    catch
      {:return, val} -> val
    end
  end
  def bearing(lat1, lon1, lat2, lon2) do
    try do
      phi1 = rad(lat1)
      phi2 = rad(lat2)
      dl = rad(lon2 - lon1)
      y = sinApprox(dl) * cosApprox(phi2)
      x = cosApprox(phi1) * sinApprox(phi2) - sinApprox(phi1) * cosApprox(phi2) * cosApprox(dl)
      br = deg(atan2Approx(y, x))
      {br} = if br < 0 do
        br = br + 360
        {br}
      else
        {br}
      end
      throw {:return, br}
    catch
      {:return, val} -> val
    end
  end
  def floor(x) do
    try do
      i = trunc(x)
      {i} = if (i) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, i}
    catch
      {:return, val} -> val
    end
  end
  def pow10(n) do
    try do
      p = 1.0
      i = 0
      while_fun_4 = fn while_fun_4, i, p ->
        if i < n do
          p = p * 10.0
          i = i + 1
          while_fun_4.(while_fun_4, i, p)
        else
          {i, p}
        end
      end
      {i, p} = try do
          while_fun_4.(while_fun_4, i, p)
        catch
          {:break, {i, p}} -> {i, p}
        end

      throw {:return, p}
    catch
      {:return, val} -> val
    end
  end
  def round(x, n) do
    try do
      m = pow10(n)
      throw {:return, floor(x * m + 0.5) / m}
    catch
      {:return, val} -> val
    end
  end
  def sortByDistance(xs) do
    try do
      arr = xs
      i = 1
      while_fun_5 = fn while_fun_5, arr, i ->
        if i < _len(arr) do
          j = i
          while_fun_6 = fn while_fun_6, arr, j ->
            if j > 0 && Enum.at(Enum.at(arr, j - 1), 0) > Enum.at(Enum.at(arr, j), 0) do
              tmp = Enum.at(arr, j - 1)
              arr = List.replace_at(arr, j - 1, Enum.at(arr, j))
              arr = List.replace_at(arr, j, tmp)
              j = j - 1
              while_fun_6.(while_fun_6, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_6.(while_fun_6, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          i = i + 1
          while_fun_5.(while_fun_5, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_5.(while_fun_5, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      planeLat = 51.514669
      planeLon = 2.198581
      results = []
      {results} = Enum.reduce(Process.get(:airports), {results}, fn ap, {results} ->
        d = distance(planeLat, planeLon, ap.lat, ap.lon)
        b = bearing(planeLat, planeLon, ap.lat, ap.lon)
        results = (results ++ [[d, b, ap]])
        {results}
      end)
      results = sortByDistance(results)
      IO.puts("Distance Bearing ICAO Country               Airport")
      IO.puts("--------------------------------------------------------------")
      i = 0
      while_fun_7 = fn while_fun_7, i ->
        if i < _len(results) do
          r = Enum.at(results, i)
          ap = Enum.at(r, 2)
          dist = Enum.at(r, 0)
          bear = Enum.at(r, 1)
          line = ((((((((Kernel.inspect(round(dist, 1)) <> "\t") <> Kernel.inspect(round(bear, 0))) <> "\t") <> ap.icao) <> "\t") <> ap.country) <> " ") <> ap.name)
          IO.puts(Kernel.inspect(line))
          i = i + 1
          while_fun_7.(while_fun_7, i)
        else
          i
        end
      end
      i = try do
          while_fun_7.(while_fun_7, i)
        catch
          {:break, i} -> i
        end

    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:airports, [%{name: "Koksijde Air Base", country: "Belgium", icao: "EBFN", lat: 51.090301513671875, lon: 2.652780055999756}, %{name: "Ostend-Bruges International Airport", country: "Belgium", icao: "EBOS", lat: 51.198898315399994, lon: 2.8622200489}, %{name: "Kent International Airport", country: "United Kingdom", icao: "EGMH", lat: 51.342201, lon: 1.34611}, %{name: "Calais-Dunkerque Airport", country: "France", icao: "LFAC", lat: 50.962100982666016, lon: 1.954759955406189}, %{name: "Westkapelle heliport", country: "Belgium", icao: "EBKW", lat: 51.32222366333, lon: 3.2930560112}, %{name: "Lympne Airport", country: "United Kingdom", icao: "EGMK", lat: 51.08, lon: 1.013}, %{name: "Ursel Air Base", country: "Belgium", icao: "EBUL", lat: 51.14419937133789, lon: 3.475559949874878}, %{name: "Southend Airport", country: "United Kingdom", icao: "EGMC", lat: 51.5713996887207, lon: 0.6955559849739075}, %{name: "Merville-Calonne Airport", country: "France", icao: "LFQT", lat: 50.61840057373047, lon: 2.642240047454834}, %{name: "Wevelgem Airport", country: "Belgium", icao: "EBKT", lat: 50.817199707, lon: 3.20472002029}, %{name: "Midden-Zeeland Airport", country: "Netherlands", icao: "EHMZ", lat: 51.5121994019, lon: 3.73111009598}, %{name: "Lydd Airport", country: "United Kingdom", icao: "EGMD", lat: 50.95610046386719, lon: 0.9391670227050781}, %{name: "RAF Wattisham", country: "United Kingdom", icao: "EGUW", lat: 52.1273002625, lon: 0.956264019012}, %{name: "Beccles Airport", country: "United Kingdom", icao: "EGSM", lat: 52.435298919699996, lon: 1.6183300018300002}, %{name: "Lille/Marcq-en-Baroeul Airport", country: "France", icao: "LFQO", lat: 50.687198638916016, lon: 3.0755600929260254}, %{name: "Lashenden (Headcorn) Airfield", country: "United Kingdom", icao: "EGKH", lat: 51.156898, lon: 0.641667}, %{name: "Le Touquet-Côte d'Opale Airport", country: "France", icao: "LFAT", lat: 50.517398834228516, lon: 1.6205899715423584}, %{name: "Rochester Airport", country: "United Kingdom", icao: "EGTO", lat: 51.351898193359375, lon: 0.5033329725265503}, %{name: "Lille-Lesquin Airport", country: "France", icao: "LFQQ", lat: 50.563332, lon: 3.086886}, %{name: "Thurrock Airfield", country: "United Kingdom", icao: "EGMT", lat: 51.537505, lon: 0.367634}])
  def bench_main() do
    Process.put(:pi, 3.141592653589793)
    Process.put(:airports, [%{name: "Koksijde Air Base", country: "Belgium", icao: "EBFN", lat: 51.090301513671875, lon: 2.652780055999756}, %{name: "Ostend-Bruges International Airport", country: "Belgium", icao: "EBOS", lat: 51.198898315399994, lon: 2.8622200489}, %{name: "Kent International Airport", country: "United Kingdom", icao: "EGMH", lat: 51.342201, lon: 1.34611}, %{name: "Calais-Dunkerque Airport", country: "France", icao: "LFAC", lat: 50.962100982666016, lon: 1.954759955406189}, %{name: "Westkapelle heliport", country: "Belgium", icao: "EBKW", lat: 51.32222366333, lon: 3.2930560112}, %{name: "Lympne Airport", country: "United Kingdom", icao: "EGMK", lat: 51.08, lon: 1.013}, %{name: "Ursel Air Base", country: "Belgium", icao: "EBUL", lat: 51.14419937133789, lon: 3.475559949874878}, %{name: "Southend Airport", country: "United Kingdom", icao: "EGMC", lat: 51.5713996887207, lon: 0.6955559849739075}, %{name: "Merville-Calonne Airport", country: "France", icao: "LFQT", lat: 50.61840057373047, lon: 2.642240047454834}, %{name: "Wevelgem Airport", country: "Belgium", icao: "EBKT", lat: 50.817199707, lon: 3.20472002029}, %{name: "Midden-Zeeland Airport", country: "Netherlands", icao: "EHMZ", lat: 51.5121994019, lon: 3.73111009598}, %{name: "Lydd Airport", country: "United Kingdom", icao: "EGMD", lat: 50.95610046386719, lon: 0.9391670227050781}, %{name: "RAF Wattisham", country: "United Kingdom", icao: "EGUW", lat: 52.1273002625, lon: 0.956264019012}, %{name: "Beccles Airport", country: "United Kingdom", icao: "EGSM", lat: 52.435298919699996, lon: 1.6183300018300002}, %{name: "Lille/Marcq-en-Baroeul Airport", country: "France", icao: "LFQO", lat: 50.687198638916016, lon: 3.0755600929260254}, %{name: "Lashenden (Headcorn) Airfield", country: "United Kingdom", icao: "EGKH", lat: 51.156898, lon: 0.641667}, %{name: "Le Touquet-Côte d'Opale Airport", country: "France", icao: "LFAT", lat: 50.517398834228516, lon: 1.6205899715423584}, %{name: "Rochester Airport", country: "United Kingdom", icao: "EGTO", lat: 51.351898193359375, lon: 0.5033329725265503}, %{name: "Lille-Lesquin Airport", country: "France", icao: "LFQQ", lat: 50.563332, lon: 3.086886}, %{name: "Thurrock Airfield", country: "United Kingdom", icao: "EGMT", lat: 51.537505, lon: 0.367634}])
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
