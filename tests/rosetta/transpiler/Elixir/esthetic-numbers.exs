# Code generated by Mochi transpiler 2025-07-31 00:20 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      abs(System.os_time(:nanosecond))
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    n = trunc(n)
    d = trunc(d)
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  defp _sha256(bs) do
    bin = :erlang.list_to_binary(bs)
    :crypto.hash(:sha256, bin) |> :erlang.binary_to_list()
  end
  defp _getenv(name) do
    System.get_env(name)
  end
  defp _environ() do
    System.get_env() |> Enum.map(fn {k, v} -> "#{k}=#{v}" end)
  end
  def toBase(n, b) do
    try do
      if n == 0 do
        throw {:return, "0"}
      end
      v = n
      out = ""
      while_fun = fn while_fun, out, v ->
        if v > 0 do
          d = rem(v, b)
          out = (_slice(Process.get(:digits), d, (d + 1) - d) <> out)
          v = div(v, b)
          while_fun.(while_fun, out, v)
        else
          {out, v}
        end
      end
      {out, v} = try do
          while_fun.(while_fun, out, v)
        catch
          {:break, {out, v}} -> {out, v}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def uabs(a, b) do
    try do
      throw {:return, ((if a > b, do: a - b, else: b - a))}
    catch
      {:return, val} -> val
    end
  end
  def isEsthetic(n, b) do
    try do
      if n == 0 do
        throw {:return, false}
      end
      i = rem(n, b)
      n = div(n, b)
      while_fun_2 = fn while_fun_2, i, n ->
        if n > 0 do
          j = rem(n, b)
          if Main.uabs(i, j) != 1 do
            throw {:return, false}
          end
          n = div(n, b)
          i = j
          while_fun_2.(while_fun_2, i, n)
        else
          {i, n}
        end
      end
      {i, n} = try do
          while_fun_2.(while_fun_2, i, n)
        catch
          {:break, {i, n}} -> {i, n}
        end

      throw {:return, true}
    catch
      {:return, val} -> val
    end
  end
  def dfs(n, m, i) do
    try do
      if i >= n && i <= m do
        Process.put(:esths, (Process.get(:esths) ++ [i]))
      end
      if i == 0 || i > m do
        throw {:return, nil}
      end
      d = rem(i, 10)
      i1 = i * 10 + d - 1
      i2 = i1 + 2
      if d == 0 do
        Main.dfs(n, m, i2)
      else
        if d == 9 do
          Main.dfs(n, m, i1)
        else
          Main.dfs(n, m, i1)
          Main.dfs(n, m, i2)
        end
      end
    catch
      {:return, val} -> val
    end
  end
  def commatize(n) do
    try do
      s = Kernel.to_string(n)
      i = _len(s) - 3
      while_fun_3 = fn while_fun_3, i, s ->
        if i >= 1 do
          s = ((_slice(s, 0, i - 0) <> ",") <> _slice(s, i, _len(s) - i))
          i = i - 3
          while_fun_3.(while_fun_3, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_3.(while_fun_3, i, s)
        catch
          {:break, {i, s}} -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def listEsths(n, n2, m, m2, perLine, showAll) do
    try do
      Process.put(:esths, [])
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i < 10 do
          Main.dfs(n2, m2, i)
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, i} -> i
        end

      le = _len(Process.get(:esths))
      IO.puts((((((("Base 10: " <> Main.commatize(le)) <> " esthetic numbers between ") <> Main.commatize(n)) <> " and ") <> Main.commatize(m)) <> ":"))
      if showAll do
        c = 0
        line = ""
        {c, line} = Enum.reduce(Process.get(:esths), {c, line}, fn v, {c, line} ->
          {line} = if _len(line) > 0 do
            line = (line <> " ")
            {line}
          else
            {line}
          end
          line = (line <> Kernel.to_string(v))
          c = c + 1
          {line} = if rem(c, perLine) == 0 do
            IO.puts(line)
            line = ""
            {line}
          else
            {line}
          end
          {c, line}
        end)
        if _len(line) > 0 do
          IO.puts(line)
        end
      else
        line = ""
        idx = 0
        while_fun_5 = fn while_fun_5, idx, line ->
          if idx < perLine do
            {line} = if _len(line) > 0 do
              line = (line <> " ")
              {line}
            else
              {line}
            end
            line = (line <> Kernel.to_string(Enum.at(Process.get(:esths), idx)))
            idx = idx + 1
            while_fun_5.(while_fun_5, idx, line)
          else
            {idx, line}
          end
        end
        {idx, line} = try do
            while_fun_5.(while_fun_5, idx, line)
          catch
            {:break, {idx, line}} -> {idx, line}
          end

        IO.puts(line)
        IO.puts("............")
        line = ""
        idx = le - perLine
        while_fun_6 = fn while_fun_6, idx, line ->
          if idx < le do
            {line} = if _len(line) > 0 do
              line = (line <> " ")
              {line}
            else
              {line}
            end
            line = (line <> Kernel.to_string(Enum.at(Process.get(:esths), idx)))
            idx = idx + 1
            while_fun_6.(while_fun_6, idx, line)
          else
            {idx, line}
          end
        end
        {idx, line} = try do
            while_fun_6.(while_fun_6, idx, line)
          catch
            {:break, {idx, line}} -> {idx, line}
          end

        IO.puts(line)
      end
      IO.puts("")
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      b = 2
      while_fun_7 = fn while_fun_7, b ->
        if b <= 16 do
          start = 4 * b
          stop = 6 * b
          IO.puts((((((("Base " <> Kernel.to_string(b)) <> ": ") <> Kernel.to_string(start)) <> "th to ") <> Kernel.to_string(stop)) <> "th esthetic numbers:"))
          n = 1
          c = 0
          line = ""
          while_fun_8 = fn while_fun_8, c, line, n ->
            if c < stop do
              {c, line} = if Main.isEsthetic(n, b) do
                c = c + 1
                {line} = if c >= start do
                  {line} = if _len(line) > 0 do
                    line = (line <> " ")
                    {line}
                  else
                    {line}
                  end
                  line = (line <> Main.toBase(n, b))
                  {line}
                else
                  {line}
                end
                {c, line}
              else
                {c, line}
              end
              n = n + 1
              while_fun_8.(while_fun_8, c, line, n)
            else
              {c, line, n}
            end
          end
          {c, line, n} = try do
              while_fun_8.(while_fun_8, c, line, n)
            catch
              {:break, {c, line, n}} -> {c, line, n}
            end

          IO.puts(line)
          IO.puts("")
          b = b + 1
          while_fun_7.(while_fun_7, b)
        else
          b
        end
      end
      b = try do
          while_fun_7.(while_fun_7, b)
        catch
          {:break, b} -> b
        end

      Main.listEsths(1000, 1010, 9999, 9898, 16, true)
      Main.listEsths(100000000, 101010101, 130000000, 123456789, 9, true)
      Main.listEsths(100000000000, 101010101010, 130000000000, 123456789898, 7, false)
      Main.listEsths(100000000000000, 101010101010101, 130000000000000, 123456789898989, 5, false)
      Main.listEsths(100000000000000000, 101010101010101010, 130000000000000000, 123456789898989898, 4, false)
    catch
      {:return, val} -> val
    end
  end
  Process.put(:digits, "0123456789abcdef")
  Process.put(:esths, [])
end
Main.main()
