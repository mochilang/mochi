# Code generated by Mochi transpiler 2025-07-27 16:31 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      abs(System.os_time(:nanosecond))
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  def sinApprox(x) do
    try do
      term = x
      sum = x
      n = 1
      while_fun = fn while_fun, n, sum, term ->
        if n <= 8 do
          denom = ((2 * n) * (2 * n + 1))
          term = -term * x * x / denom
          sum = sum + term
          n = n + 1
          while_fun.(while_fun, n, sum, term)
        else
          {n, sum, term}
        end
      end
      {n, sum, term} = try do
          while_fun.(while_fun, n, sum, term)
        catch
          :break -> {n, sum, term}
        end

      throw {:return, sum}
    catch
      {:return, val} -> val
    end
  end
  def floor(x) do
    try do
      i = trunc(x)
      {i} = if (i) > x do
        i = i - 1
        {i}
      else
        {i}
      end
      throw {:return, i}
    catch
      {:return, val} -> val
    end
  end
  def absFloat(x) do
    try do
      throw {:return, ((if x < 0.0, do: -x, else: x))}
    catch
      {:return, val} -> val
    end
  end
  def absInt(n) do
    try do
      throw {:return, ((if n < 0, do: -n, else: n))}
    catch
      {:return, val} -> val
    end
  end
  def parseIntStr(str) do
    try do
      i = 0
      neg = false
      {i, neg} = if _len(str) > 0 && _slice(str, 0, 1 - 0) == "-" do
        neg = true
        i = 1
        {i, neg}
      else
        {i, neg}
      end
      n = 0
      digits = %{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
      while_fun_2 = fn while_fun_2, i, n ->
        if i < _len(str) do
          n = n * 10 + digits[_slice(str, i, (i + 1) - i)]
          i = i + 1
          while_fun_2.(while_fun_2, i, n)
        else
          {i, n}
        end
      end
      {i, n} = try do
          while_fun_2.(while_fun_2, i, n)
        catch
          :break -> {i, n}
        end

      {n} = if neg do
        n = -n
        {n}
      else
        {n}
      end
      throw {:return, n}
    catch
      {:return, val} -> val
    end
  end
  def parseDate(s) do
    try do
      y = Main.parseIntStr(_slice(s, 0, 4 - 0))
      m = Main.parseIntStr(_slice(s, 5, 7 - 5))
      d = Main.parseIntStr(_slice(s, 8, 10 - 8))
      throw {:return, [y, m, d]}
    catch
      {:return, val} -> val
    end
  end
  def leap(y) do
    try do
      if rem(y, 400) == 0 do
        throw {:return, true}
      end
      if rem(y, 100) == 0 do
        throw {:return, false}
      end
      throw {:return, rem(y, 4) == 0}
    catch
      {:return, val} -> val
    end
  end
  def daysInMonth(y, m) do
    try do
      feb = (if Main.leap(y), do: 29, else: 28)
      lengths = [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
      throw {:return, Enum.at(lengths, m - 1)}
    catch
      {:return, val} -> val
    end
  end
  def addDays(y, m, d, n) do
    try do
      yy = y
      mm = m
      dd = d
      {dd, mm, yy} = if n >= 0 do
        i = 0
        while_fun_3 = fn while_fun_3, dd, i, mm, yy ->
          if i < n do
            dd = dd + 1
            {dd, mm, yy} = if dd > Main.daysInMonth(yy, mm) do
              dd = 1
              mm = mm + 1
              {mm, yy} = if mm > 12 do
                mm = 1
                yy = yy + 1
                {mm, yy}
              else
                {mm, yy}
              end
              {dd, mm, yy}
            else
              {dd, mm, yy}
            end
            i = i + 1
            while_fun_3.(while_fun_3, dd, i, mm, yy)
          else
            {dd, i, mm, yy}
          end
        end
        {dd, i, mm, yy} = try do
            while_fun_3.(while_fun_3, dd, i, mm, yy)
          catch
            :break -> {dd, i, mm, yy}
          end

        {dd, mm, yy}
      else
        i = 0
        while_fun_4 = fn while_fun_4, dd, i, mm, yy ->
          if i > n do
            dd = dd - 1
            {dd, mm, yy} = if dd < 1 do
              mm = mm - 1
              {mm, yy} = if mm < 1 do
                mm = 12
                yy = yy - 1
                {mm, yy}
              else
                {mm, yy}
              end
              dd = Main.daysInMonth(yy, mm)
              {dd, mm, yy}
            else
              {dd, mm, yy}
            end
            i = i - 1
            while_fun_4.(while_fun_4, dd, i, mm, yy)
          else
            {dd, i, mm, yy}
          end
        end
        {dd, i, mm, yy} = try do
            while_fun_4.(while_fun_4, dd, i, mm, yy)
          catch
            :break -> {dd, i, mm, yy}
          end

        {dd, mm, yy}
      end
      throw {:return, [yy, mm, dd]}
    catch
      {:return, val} -> val
    end
  end
  def pad2(n) do
    try do
      throw {:return, ((if n < 10, do: ("0" <> Kernel.to_string(n)), else: Kernel.to_string(n)))}
    catch
      {:return, val} -> val
    end
  end
  def dateString(y, m, d) do
    try do
      throw {:return, ((((Kernel.to_string(y) <> "-") <> Main.pad2(m)) <> "-") <> Main.pad2(d))}
    catch
      {:return, val} -> val
    end
  end
  def day(y, m, d) do
    try do
      part1 = 367 * y
      part2 = trunc((div((7 * (trunc((y + (div((m + 9), 12)))))), 4)))
      part3 = trunc((div((275 * m), 9)))
      throw {:return, part1 - part2 + part3 + d - 730530}
    catch
      {:return, val} -> val
    end
  end
  def biorhythms(birth, target) do
    try do
      bparts = Main.parseDate(birth)
      by = Enum.at(bparts, 0)
      bm = Enum.at(bparts, 1)
      bd = Enum.at(bparts, 2)
      tparts = Main.parseDate(target)
      ty = Enum.at(tparts, 0)
      tm = Enum.at(tparts, 1)
      td = Enum.at(tparts, 2)
      diff = Main.absInt(Main.day(ty, tm, td) - Main.day(by, bm, bd))
      IO.puts(((("Born " <> birth) <> ", Target ") <> target))
      IO.puts(("Day " <> Kernel.to_string(diff)))
      cycles = ["Physical day ", "Emotional day", "Mental day   "]
      lengths = [23, 28, 33]
      quadrants = [["up and rising", "peak"], ["up but falling", "transition"], ["down and falling", "valley"], ["down but rising", "transition"]]
      i = 0
      while_fun_5 = fn while_fun_5, i ->
        if i < 3 do
          length = Enum.at(lengths, i)
          cycle = Enum.at(cycles, i)
          position = rem(diff, length)
          quadrant = div((position * 4), length)
          percent = Main.sinApprox(2.0 * Process.get(:pi) * (position) / (length))
          percent = Main.floor(percent * 1000.0) / 10.0
          description = ""
          {description} = if percent > 95.0 do
            description = " peak"
            {description}
          else
            {description} = if percent < (-95.0) do
              description = " valley"
              {description}
            else
              {description} = if Main.absFloat(percent) < 5.0 do
                description = " critical transition"
                {description}
              else
                daysToAdd = (quadrant + 1) * length / 4 - position
                res = Main.addDays(ty, tm, td, daysToAdd)
                ny = Enum.at(res, 0)
                nm = Enum.at(res, 1)
                nd = Enum.at(res, 2)
                transition = Main.dateString(ny, nm, nd)
                trend = Enum.at(Enum.at(quadrants, quadrant), 0)
                next = Enum.at(Enum.at(quadrants, quadrant), 1)
                pct = Kernel.to_string(percent)
                {pct} = if !String.contains?(pct, ".") do
                  pct = (pct <> ".0")
                  {pct}
                else
                  {pct}
                end
                description = ((((((((" " <> pct) <> "% (") <> trend) <> ", next ") <> next) <> " ") <> transition) <> ")")
                {description}
              end
              {description}
            end
            {description}
          end
          posStr = Kernel.to_string(position)
          {posStr} = if position < 10 do
            posStr = (" " <> posStr)
            {posStr}
          else
            {posStr}
          end
          IO.puts((((cycle <> posStr) <> " : ") <> description))
          i = i + 1
          while_fun_5.(while_fun_5, i)
        else
          i
        end
      end
      i = try do
          while_fun_5.(while_fun_5, i)
        catch
          :break -> i
        end

      IO.puts("")
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      pairs = [["1943-03-09", "1972-07-11"], ["1809-01-12", "1863-11-19"], ["1809-02-12", "1863-11-19"]]
      idx = 0
      while_fun_6 = fn while_fun_6, idx ->
        if idx < _len(pairs) do
          p = Enum.at(pairs, idx)
          Main.biorhythms(Enum.at(p, 0), Enum.at(p, 1))
          idx = idx + 1
          while_fun_6.(while_fun_6, idx)
        else
          idx
        end
      end
      idx = try do
          while_fun_6.(while_fun_6, idx)
        catch
          :break -> idx
        end

    catch
      {:return, val} -> val
    end
  end
  Process.put(:pi, 3.141592653589793)
  Process.put(:two_pi, 6.283185307179586)
end
Main.main()
