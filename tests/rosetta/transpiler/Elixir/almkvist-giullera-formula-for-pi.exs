# Code generated by Mochi transpiler 2025-07-25 21:12 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) -> String.slice(base, start, len)
      len == 1 -> Enum.at(base, start)
      true -> Enum.slice(base, start, len)
    end
  end
  def bigTrim(a) do
    try do
      n = Enum.count(a)
      while_fun = fn while_fun, a, n ->
        if n > 1 && Enum.at(a, n - 1) == 0 do
          a = _slice(a, 0, n - 1 - 0)
          n = n - 1
          while_fun.(while_fun, a, n)
        else
          {a, n}
        end
      end
      {a, n} = try do
          while_fun.(while_fun, a, n)
        catch
          :break -> {a, n}
        end

      throw {:return, a}
    catch
      {:return, val} -> val
    end
  end
  def bigFromInt(x) do
    try do
      if x == 0 do
        throw {:return, [0]}
      end
      digits = []
      n = x
      while_fun_2 = fn while_fun_2, digits, n ->
        if n > 0 do
          digits = (digits ++ [rem(n, 10)])
          n = div(n, 10)
          while_fun_2.(while_fun_2, digits, n)
        else
          {digits, n}
        end
      end
      {digits, n} = try do
          while_fun_2.(while_fun_2, digits, n)
        catch
          :break -> {digits, n}
        end

      throw {:return, digits}
    catch
      {:return, val} -> val
    end
  end
  def bigCmp(a, b) do
    try do
      if Enum.count(a) > Enum.count(b) do
        throw {:return, 1}
      end
      if Enum.count(a) < Enum.count(b) do
        throw {:return, -1}
      end
      i = Enum.count(a) - 1
      while_fun_3 = fn while_fun_3, i ->
        if i >= 0 do
          if Enum.at(a, i) > Enum.at(b, i) do
            throw {:return, 1}
          end
          if Enum.at(a, i) < Enum.at(b, i) do
            throw {:return, -1}
          end
          i = i - 1
          while_fun_3.(while_fun_3, i)
        else
          i
        end
      end
      i = try do
          while_fun_3.(while_fun_3, i)
        catch
          :break -> i
        end

      throw {:return, 0}
    catch
      {:return, val} -> val
    end
  end
  def bigAdd(a, b) do
    try do
      res = []
      carry = 0
      i = 0
      while_fun_4 = fn while_fun_4, carry, i, res ->
        if i < Enum.count(a) || i < Enum.count(b) || carry > 0 do
          av = 0
          {av} = if i < Enum.count(a) do
            av = Enum.at(a, i)
            {av}
          else
            {av}
          end
          bv = 0
          {bv} = if i < Enum.count(b) do
            bv = Enum.at(b, i)
            {bv}
          else
            {bv}
          end
          s = av + bv + carry
          res = (res ++ [rem(s, 10)])
          carry = div(s, 10)
          i = i + 1
          while_fun_4.(while_fun_4, carry, i, res)
        else
          {carry, i, res}
        end
      end
      {carry, i, res} = try do
          while_fun_4.(while_fun_4, carry, i, res)
        catch
          :break -> {carry, i, res}
        end

      throw {:return, bigTrim(res)}
    catch
      {:return, val} -> val
    end
  end
  def bigSub(a, b) do
    try do
      res = []
      borrow = 0
      i = 0
      while_fun_5 = fn while_fun_5, borrow, i, res ->
        if i < Enum.count(a) do
          av = Enum.at(a, i)
          bv = 0
          {bv} = if i < Enum.count(b) do
            bv = Enum.at(b, i)
            {bv}
          else
            {bv}
          end
          diff = av - bv - borrow
          {diff} = if diff < 0 do
            diff = diff + 10
            borrow = 1
            {diff}
          else
            borrow = 0
            {diff}
          end
          res = (res ++ [diff])
          i = i + 1
          while_fun_5.(while_fun_5, borrow, i, res)
        else
          {borrow, i, res}
        end
      end
      {borrow, i, res} = try do
          while_fun_5.(while_fun_5, borrow, i, res)
        catch
          :break -> {borrow, i, res}
        end

      throw {:return, bigTrim(res)}
    catch
      {:return, val} -> val
    end
  end
  def bigMulSmall(a, m) do
    try do
      if m == 0 do
        throw {:return, [0]}
      end
      res = []
      carry = 0
      i = 0
      while_fun_6 = fn while_fun_6, carry, i, res ->
        if i < Enum.count(a) do
          prod = Enum.at(a, i) * m + carry
          res = (res ++ [rem(prod, 10)])
          carry = div(prod, 10)
          i = i + 1
          while_fun_6.(while_fun_6, carry, i, res)
        else
          {carry, i, res}
        end
      end
      {carry, i, res} = try do
          while_fun_6.(while_fun_6, carry, i, res)
        catch
          :break -> {carry, i, res}
        end

      while_fun_7 = fn while_fun_7, carry, res ->
        if carry > 0 do
          res = (res ++ [rem(carry, 10)])
          carry = div(carry, 10)
          while_fun_7.(while_fun_7, carry, res)
        else
          {carry, res}
        end
      end
      {carry, res} = try do
          while_fun_7.(while_fun_7, carry, res)
        catch
          :break -> {carry, res}
        end

      throw {:return, bigTrim(res)}
    catch
      {:return, val} -> val
    end
  end
  def bigMulBig(a, b) do
    try do
      res = []
      i = 0
      while_fun_8 = fn while_fun_8, i, res ->
        if i < Enum.count(a) + Enum.count(b) do
          res = (res ++ [0])
          i = i + 1
          while_fun_8.(while_fun_8, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_8.(while_fun_8, i, res)
        catch
          :break -> {i, res}
        end

      i = 0
      while_fun_9 = fn while_fun_9, i, res ->
        if i < Enum.count(a) do
          carry = 0
          j = 0
          while_fun_10 = fn while_fun_10, carry, j, res ->
            if j < Enum.count(b) do
              idx = i + j
              prod = Enum.at(res, idx) + Enum.at(a, i) * Enum.at(b, j) + carry
              res = List.replace_at(res, idx, rem(prod, 10))
              carry = div(prod, 10)
              j = j + 1
              while_fun_10.(while_fun_10, carry, j, res)
            else
              {carry, j, res}
            end
          end
          {carry, j, res} = try do
              while_fun_10.(while_fun_10, carry, j, res)
            catch
              :break -> {carry, j, res}
            end

          idx = i + Enum.count(b)
          while_fun_11 = fn while_fun_11, carry, idx, res ->
            if carry > 0 do
              prod = Enum.at(res, idx) + carry
              res = List.replace_at(res, idx, rem(prod, 10))
              carry = div(prod, 10)
              idx = idx + 1
              while_fun_11.(while_fun_11, carry, idx, res)
            else
              {carry, idx, res}
            end
          end
          {carry, idx, res} = try do
              while_fun_11.(while_fun_11, carry, idx, res)
            catch
              :break -> {carry, idx, res}
            end

          i = i + 1
          while_fun_9.(while_fun_9, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun_9.(while_fun_9, i, res)
        catch
          :break -> {i, res}
        end

      throw {:return, bigTrim(res)}
    catch
      {:return, val} -> val
    end
  end
  def bigMulPow10(a, k) do
    try do
      i = 0
      while_fun_12 = fn while_fun_12, a, i ->
        if i < k do
          a = [0] + a
          i = i + 1
          while_fun_12.(while_fun_12, a, i)
        else
          {a, i}
        end
      end
      {a, i} = try do
          while_fun_12.(while_fun_12, a, i)
        catch
          :break -> {a, i}
        end

      throw {:return, a}
    catch
      {:return, val} -> val
    end
  end
  def bigDivSmall(a, m) do
    try do
      res = []
      rem = 0
      i = Enum.count(a) - 1
      while_fun_13 = fn while_fun_13, i, rem, res ->
        if i >= 0 do
          cur = rem * 10 + Enum.at(a, i)
          q = div(cur, m)
          rem = rem(cur, m)
          res = [q] + res
          i = i - 1
          while_fun_13.(while_fun_13, i, rem, res)
        else
          {i, rem, res}
        end
      end
      {i, rem, res} = try do
          while_fun_13.(while_fun_13, i, rem, res)
        catch
          :break -> {i, rem, res}
        end

      throw {:return, bigTrim(res)}
    catch
      {:return, val} -> val
    end
  end
  def bigToString(a) do
    try do
      s = ""
      i = Enum.count(a) - 1
      while_fun_14 = fn while_fun_14, i, s ->
        if i >= 0 do
          s = (s <> to_string(Enum.at(a, i)))
          i = i - 1
          while_fun_14.(while_fun_14, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_14.(while_fun_14, i, s)
        catch
          :break -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def repeat(ch, n) do
    try do
      s = ""
      i = 0
      while_fun_15 = fn while_fun_15, i, s ->
        if i < n do
          s = (s <> ch)
          i = i + 1
          while_fun_15.(while_fun_15, i, s)
        else
          {i, s}
        end
      end
      {i, s} = try do
          while_fun_15.(while_fun_15, i, s)
        catch
          :break -> {i, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def sortInts(xs) do
    try do
      res = []
      tmp = xs
      while_fun_16 = fn while_fun_16, res, tmp ->
        if Enum.count(tmp) > 0 do
          min = Enum.at(tmp, 0)
          idx = 0
          i = 1
          while_fun_17 = fn while_fun_17, i, idx, min ->
            if i < Enum.count(tmp) do
              if Enum.at(tmp, i) < min do
                min = Enum.at(tmp, i)
                idx = i
              end
              i = i + 1
              while_fun_17.(while_fun_17, i, idx, min)
            else
              {i, idx, min}
            end
          end
          {i, idx, min} = try do
              while_fun_17.(while_fun_17, i, idx, min)
            catch
              :break -> {i, idx, min}
            end

          res = res + [min]
          out = []
          j = 0
          while_fun_18 = fn while_fun_18, j, out ->
            if j < Enum.count(tmp) do
              if j != idx do
                out = out + [Enum.at(tmp, j)]
              end
              j = j + 1
              while_fun_18.(while_fun_18, j, out)
            else
              {j, out}
            end
          end
          {j, out} = try do
              while_fun_18.(while_fun_18, j, out)
            catch
              :break -> {j, out}
            end

          tmp = out
          while_fun_16.(while_fun_16, res, tmp)
        else
          {res, tmp}
        end
      end
      {res, tmp} = try do
          while_fun_16.(while_fun_16, res, tmp)
        catch
          :break -> {res, tmp}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def primesUpTo(n) do
    try do
      sieve = []
      i = 0
      while_fun_19 = fn while_fun_19, i, sieve ->
        if i <= n do
          sieve = (sieve ++ [true])
          i = i + 1
          while_fun_19.(while_fun_19, i, sieve)
        else
          {i, sieve}
        end
      end
      {i, sieve} = try do
          while_fun_19.(while_fun_19, i, sieve)
        catch
          :break -> {i, sieve}
        end

      p = 2
      while_fun_20 = fn while_fun_20, p, sieve ->
        if p * p <= n do
          if Enum.at(sieve, p) do
            m = p * p
            while_fun_21 = fn while_fun_21, m, sieve ->
              if m <= n do
                sieve = List.replace_at(sieve, m, false)
                m = m + p
                while_fun_21.(while_fun_21, m, sieve)
              else
                {m, sieve}
              end
            end
            {m, sieve} = try do
                while_fun_21.(while_fun_21, m, sieve)
              catch
                :break -> {m, sieve}
              end

          end
          p = p + 1
          while_fun_20.(while_fun_20, p, sieve)
        else
          {p, sieve}
        end
      end
      {p, sieve} = try do
          while_fun_20.(while_fun_20, p, sieve)
        catch
          :break -> {p, sieve}
        end

      res = []
      x = 2
      while_fun_22 = fn while_fun_22, res, x ->
        if x <= n do
          if Enum.at(sieve, x) do
            res = (res ++ [x])
          end
          x = x + 1
          while_fun_22.(while_fun_22, res, x)
        else
          {res, x}
        end
      end
      {res, x} = try do
          while_fun_22.(while_fun_22, res, x)
        catch
          :break -> {res, x}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def factorialExp(n, primes) do
    try do
      m = %{}
      try do
        for p <- primes do
          try do
            if p > n do
              throw :break
            end
            t = n
            e = 0
            while_fun_23 = fn while_fun_23, e, t ->
              if t > 0 do
                t = t / p
                e = e + t
                while_fun_23.(while_fun_23, e, t)
              else
                {e, t}
              end
            end
            {e, t} = try do
                while_fun_23.(while_fun_23, e, t)
              catch
                :break -> {e, t}
              end

            m = Map.put(m, to_string(p), e)
          catch
            :continue -> nil
          end
        end
      catch
        :break -> nil
      end
      throw {:return, m}
    catch
      {:return, val} -> val
    end
  end
  def factorSmall(x, primes) do
    try do
      f = %{}
      n = x
      try do
        for p <- primes do
          try do
            if p * p > n do
              throw :break
            end
            c = 0
            while_fun_24 = fn while_fun_24, c, n ->
              if rem(n, p) == 0 do
                c = c + 1
                n = n / p
                while_fun_24.(while_fun_24, c, n)
              else
                {c, n}
              end
            end
            {c, n} = try do
                while_fun_24.(while_fun_24, c, n)
              catch
                :break -> {c, n}
              end

            if c > 0 do
              f = Map.put(f, to_string(p), c)
            end
          catch
            :continue -> nil
          end
        end
      catch
        :break -> nil
      end
      {f} = if n > 1 do
        f = Map.put(f, to_string(n), Map.get(f, to_string(n), 0) + 1)
        {f}
      else
        {f}
      end
      throw {:return, f}
    catch
      {:return, val} -> val
    end
  end
  def computeIP(n, primes) do
    try do
      exps = factorialExp(6 * n, primes)
      fn_ = factorialExp(n, primes)
      Enum.each(fn_, fn k ->
        exps = List.replace_at(exps, k, Map.get(exps, k, 0) - 6 * Enum.at(fn_, k))
      end)
      exps = List.replace_at(exps, "2", Map.get(exps, "2", 0) + 5)
      t2 = 532 * n * n + 126 * n + 9
      ft2 = factorSmall(t2, primes)
      Enum.each(ft2, fn k ->
        exps = List.replace_at(exps, k, Map.get(exps, k, 0) + Enum.at(ft2, k))
      end)
      exps = List.replace_at(exps, "3", Map.get(exps, "3", 0) - 1)
      keys = []
      Enum.each(exps, fn k ->
        keys = (keys ++ [Kernel.trunc(k)])
      end)
      keys = sortInts(keys)
      res = bigFromInt(1)
      Enum.each(keys, fn p ->
        e = exps[to_string(p)]
        i = 0
        while_fun_25 = fn while_fun_25, i, res ->
          if i < e do
            res = bigMulSmall(res, p)
            i = i + 1
            while_fun_25.(while_fun_25, i, res)
          else
            {i, res}
          end
        end
        {i, res} = try do
            while_fun_25.(while_fun_25, i, res)
          catch
            :break -> {i, res}
          end

      end)
      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def formatTerm(ip, pw) do
    try do
      s = bigToString(ip)
      if pw >= length(s) do
        frac = (repeat("0", pw - length(s)) <> s)
        {frac} = if length(frac) < 33 do
          frac = (frac <> repeat("0", 33 - length(frac)))
          {frac}
        else
          {frac}
        end
        throw {:return, ("0." <> String.slice(frac, 0, 33 - (0)))}
      end
      intpart = String.slice(s, 0, length(s) - pw - (0))
      frac = String.slice(s, length(s) - pw, length(s) - (length(s) - pw))
      {frac} = if length(frac) < 33 do
        frac = (frac <> repeat("0", 33 - length(frac)))
        {frac}
      else
        {frac}
      end
      throw {:return, ((intpart <> ".") <> String.slice(frac, 0, 33 - (0)))}
    catch
      {:return, val} -> val
    end
  end
  def bigAbsDiff(a, b) do
    try do
      throw {:return, if bigCmp(a, b) >= 0, do: bigSub(a, b), else: bigSub(b, a)}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      primes = primesUpTo(2000)
      IO.puts("N                               Integer Portion  Pow  Nth Term (33 dp)")
      line = repeat("-", 89)
      IO.puts(Kernel.to_string(line))
      sum = bigFromInt(0)
      prev = bigFromInt(0)
      denomPow = 0
      n = 0
      while_fun_26 = fn while_fun_26, denomPow, n, prev, sum ->
        if true do
          try do
            ip = computeIP(n, primes)
            pw = 6 * n + 3
            if pw > denomPow do
              sum = bigMulPow10(sum, pw - denomPow)
              prev = bigMulPow10(prev, pw - denomPow)
              denomPow = pw
            end
            if n < 10 do
              termStr = formatTerm(ip, pw)
              ipStr = bigToString(ip)
              while_fun_27 = fn while_fun_27, ipStr ->
                if length(ipStr) < 44 do
                  ipStr = (" " <> ipStr)
                  while_fun_27.(while_fun_27, ipStr)
                else
                  ipStr
                end
              end
              ipStr = try do
                  while_fun_27.(while_fun_27, ipStr)
                catch
                  :break -> ipStr
                end

              pwStr = to_string(-pw)
              while_fun_28 = fn while_fun_28, pwStr ->
                if String.length(pwStr) < 3 do
                  pwStr = (" " <> pwStr)
                  while_fun_28.(while_fun_28, pwStr)
                else
                  pwStr
                end
              end
              pwStr = try do
                  while_fun_28.(while_fun_28, pwStr)
                catch
                  :break -> pwStr
                end

              padTerm = termStr
              while_fun_29 = fn while_fun_29, padTerm ->
                if length(padTerm) < 35 do
                  padTerm = (padTerm <> " ")
                  while_fun_29.(while_fun_29, padTerm)
                else
                  padTerm
                end
              end
              padTerm = try do
                  while_fun_29.(while_fun_29, padTerm)
                catch
                  :break -> padTerm
                end

              IO.puts(((((((to_string(n) <> "  ") <> ipStr) <> "  ") <> pwStr) <> "  ") <> padTerm))
            end
            sum = bigAdd(sum, ip)
            diff = bigAbsDiff(sum, prev)
            if denomPow >= 70 && bigCmp(diff, bigMulPow10(bigFromInt(1), denomPow - 70)) < 0 do
              throw :break
            end
            prev = sum
            n = n + 1
          catch
            :continue -> nil
          end
          while_fun_26.(while_fun_26, denomPow, n, prev, sum)
        else
          {denomPow, n, prev, sum}
        end
      end
      {denomPow, n, prev, sum} = try do
          while_fun_26.(while_fun_26, denomPow, n, prev, sum)
        catch
          :break -> {denomPow, n, prev, sum}
        end

      precision = 70
      target = bigMulPow10(bigFromInt(1), denomPow + 2 * precision)
      low = bigFromInt(0)
      high = bigMulPow10(bigFromInt(1), precision + 1)
      while_fun_30 = fn while_fun_30, high, low ->
        if bigCmp(low, bigSub(high, bigFromInt(1))) < 0 do
          mid = bigDivSmall(bigAdd(low, high), 2)
          prod = bigMulBig(bigMulBig(mid, mid), sum)
          if bigCmp(prod, target) <= 0 do
            low = mid
          else
            high = bigSub(mid, bigFromInt(1))
          end
          while_fun_30.(while_fun_30, high, low)
        else
          {high, low}
        end
      end
      {high, low} = try do
          while_fun_30.(while_fun_30, high, low)
        catch
          :break -> {high, low}
        end

      piInt = low
      piStr = bigToString(piInt)
      {piStr} = if length(piStr) <= precision do
        piStr = (repeat("0", precision - length(piStr) + 1) <> piStr)
        {piStr}
      else
        {piStr}
      end
      out = ((String.slice(piStr, 0, length(piStr) - precision - (0)) <> ".") <> String.slice(piStr, length(piStr) - precision, length(piStr) - (length(piStr) - precision)))
      IO.puts("")
      IO.puts("Pi to 70 decimal places is:")
      IO.puts(Kernel.to_string(out))
    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    mem_start = _mem()
    t_start = _now()
    main()
    duration_us = div(_now() - t_start, 1000)
    mem_diff = abs(_mem() - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
