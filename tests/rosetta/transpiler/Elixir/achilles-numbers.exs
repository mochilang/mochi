# Code generated by Mochi transpiler 2025-07-25 17:50 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  def pow10(exp) do
    try do
      n = 1
      i = 0
      while_fun = fn while_fun, i, n ->
        if i < exp do
          n = n * 10
          i = i + 1
          while_fun.(while_fun, i, n)
        else
          {i, n}
        end
      end
      {i, n} = try do
          while_fun.(while_fun, i, n)
        catch
          :break -> {i, n}
        end

      throw {:return, n}
    catch
      {:return, val} -> val
    end
  end
  def totient(n) do
    try do
      tot = n
      nn = n
      i = 2
      while_fun_2 = fn while_fun_2, i, nn, tot ->
        if i * i <= nn do
          if rem(nn, i) == 0 do
            while_fun_3 = fn while_fun_3, nn ->
              if rem(nn, i) == 0 do
                nn = div(nn, i)
                while_fun_3.(while_fun_3, nn)
              else
                nn
              end
            end
            nn = try do
                while_fun_3.(while_fun_3, nn)
              catch
                :break -> nn
              end

            tot = tot - div(tot, i)
          end
          if i == 2 do
            i = 1
          end
          i = i + 2
          while_fun_2.(while_fun_2, i, nn, tot)
        else
          {i, nn, tot}
        end
      end
      {i, nn, tot} = try do
          while_fun_2.(while_fun_2, i, nn, tot)
        catch
          :break -> {i, nn, tot}
        end

      {tot} = if nn > 1 do
        tot = tot - div(tot, nn)
        {tot}
      else
        {tot}
      end
      throw {:return, tot}
    catch
      {:return, val} -> val
    end
  end
  def getPerfectPowers(maxExp) do
    try do
      upper = pow10(maxExp)
      i = 2
      while_fun_4 = fn while_fun_4, i ->
        if i * i < upper do
          try do
            p = i
            while_fun_5 = fn while_fun_5, p ->
              if true do
                try do
                  p = p * i
                  if p >= upper do
                    throw :break
                  end
                  Process.put(:pps, Map.put(Process.get(:pps), p, true))
                catch
                  :continue -> nil
                end
                while_fun_5.(while_fun_5, p)
              else
                p
              end
            end
            p = try do
                while_fun_5.(while_fun_5, p)
              catch
                :break -> p
              end

            i = i + 1
          catch
            :continue -> nil
          end
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          :break -> i
        end

    catch
      {:return, val} -> val
    end
  end
  def getAchilles(minExp, maxExp) do
    try do
      lower = pow10(minExp)
      upper = pow10(maxExp)
      achilles = %{}
      b = 1
      while_fun_6 = fn while_fun_6, achilles, b ->
        if b * b * b < upper do
          try do
            b3 = b * b * b
            a = 1
            while_fun_7 = fn while_fun_7, a, achilles ->
              if true do
                try do
                  p = b3 * a * a
                  if p >= upper do
                    throw :break
                  end
                  if p >= lower do
                    if !(Map.has_key?(Process.get(:pps), p)) do
                      achilles = Map.put(achilles, p, true)
                    end
                  end
                  a = a + 1
                catch
                  :continue -> nil
                end
                while_fun_7.(while_fun_7, a, achilles)
              else
                {a, achilles}
              end
            end
            {a, achilles} = try do
                while_fun_7.(while_fun_7, a, achilles)
              catch
                :break -> {a, achilles}
              end

            b = b + 1
          catch
            :continue -> nil
          end
          while_fun_6.(while_fun_6, achilles, b)
        else
          {achilles, b}
        end
      end
      {achilles, b} = try do
          while_fun_6.(while_fun_6, achilles, b)
        catch
          :break -> {achilles, b}
        end

      throw {:return, achilles}
    catch
      {:return, val} -> val
    end
  end
  def sortInts(xs) do
    try do
      res = []
      tmp = xs
      while_fun_8 = fn while_fun_8, res, tmp ->
        if length(tmp) > 0 do
          min = Enum.at(tmp, 0)
          idx = 0
          i = 1
          while_fun_9 = fn while_fun_9, i, idx, min ->
            if i < length(tmp) do
              if Enum.at(tmp, i) < min do
                min = Enum.at(tmp, i)
                idx = i
              end
              i = i + 1
              while_fun_9.(while_fun_9, i, idx, min)
            else
              {i, idx, min}
            end
          end
          {i, idx, min} = try do
              while_fun_9.(while_fun_9, i, idx, min)
            catch
              :break -> {i, idx, min}
            end

          res = res + [min]
          out = []
          j = 0
          while_fun_10 = fn while_fun_10, j, out ->
            if j < length(tmp) do
              if j != idx do
                out = out + [Enum.at(tmp, j)]
              end
              j = j + 1
              while_fun_10.(while_fun_10, j, out)
            else
              {j, out}
            end
          end
          {j, out} = try do
              while_fun_10.(while_fun_10, j, out)
            catch
              :break -> {j, out}
            end

          tmp = out
          while_fun_8.(while_fun_8, res, tmp)
        else
          {res, tmp}
        end
      end
      {res, tmp} = try do
          while_fun_8.(while_fun_8, res, tmp)
        catch
          :break -> {res, tmp}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def pad(n, width) do
    try do
      s = to_string(n)
      while_fun_11 = fn while_fun_11, s ->
        if String.length(s) < width do
          s = (" " <> s)
          while_fun_11.(while_fun_11, s)
        else
          s
        end
      end
      s = try do
          while_fun_11.(while_fun_11, s)
        catch
          :break -> s
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      maxDigits = 15
      getPerfectPowers(5)
      achSet = getAchilles(1, 5)
      ach = []
      Enum.each(achSet.keys(), fn k ->
        ach = ach + [k]
      end)
      ach = sortInts(ach)
      IO.puts("First 50 Achilles numbers:")
      i = 0
      while_fun_12 = fn while_fun_12, i ->
        if i < 50 do
          line = ""
          j = 0
          while_fun_13 = fn while_fun_13, i, j, line ->
            if j < 10 do
              line = (line <> pad(Enum.at(ach, i), 4))
              if j < 9 do
                line = (line <> " ")
              end
              i = i + 1
              j = j + 1
              while_fun_13.(while_fun_13, i, j, line)
            else
              {i, j, line}
            end
          end
          {i, j, line} = try do
              while_fun_13.(while_fun_13, i, j, line)
            catch
              :break -> {i, j, line}
            end

          IO.puts(line)
          while_fun_12.(while_fun_12, i)
        else
          i
        end
      end
      i = try do
          while_fun_12.(while_fun_12, i)
        catch
          :break -> i
        end

      IO.puts("\nFirst 30 strong Achilles numbers:")
      strong = []
      count = 0
      idx = 0
      while_fun_14 = fn while_fun_14, count, idx, strong ->
        if count < 30 do
          tot = totient(Enum.at(ach, idx))
          if tot in achSet do
            strong = strong + [Enum.at(ach, idx)]
            count = count + 1
          end
          idx = idx + 1
          while_fun_14.(while_fun_14, count, idx, strong)
        else
          {count, idx, strong}
        end
      end
      {count, idx, strong} = try do
          while_fun_14.(while_fun_14, count, idx, strong)
        catch
          :break -> {count, idx, strong}
        end

      i = 0
      while_fun_15 = fn while_fun_15, i ->
        if i < 30 do
          line = ""
          j = 0
          while_fun_16 = fn while_fun_16, i, j, line ->
            if j < 10 do
              line = (line <> pad(Enum.at(strong, i), 5))
              if j < 9 do
                line = (line <> " ")
              end
              i = i + 1
              j = j + 1
              while_fun_16.(while_fun_16, i, j, line)
            else
              {i, j, line}
            end
          end
          {i, j, line} = try do
              while_fun_16.(while_fun_16, i, j, line)
            catch
              :break -> {i, j, line}
            end

          IO.puts(line)
          while_fun_15.(while_fun_15, i)
        else
          i
        end
      end
      i = try do
          while_fun_15.(while_fun_15, i)
        catch
          :break -> i
        end

      IO.puts("\nNumber of Achilles numbers with:")
      counts = [1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383]
      d = 2
      while_fun_17 = fn while_fun_17, d ->
        if d <= maxDigits do
          c = Enum.at(counts, d - 2)
          IO.puts(Kernel.to_string(((pad(d, 2) <> " digits: ") <> to_string(c))))
          d = d + 1
          while_fun_17.(while_fun_17, d)
        else
          d
        end
      end
      d = try do
          while_fun_17.(while_fun_17, d)
        catch
          :break -> d
        end

    catch
      {:return, val} -> val
    end
  end
  Process.put(:pps, %{})
  def bench_main() do
    Process.put(:pps, %{})
    mem_start = _mem()
    t_start = _now()
    main()
    duration_us = div(_now() - t_start, 1000)
    mem_diff = abs(_mem() - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
