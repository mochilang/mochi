# Code generated by Mochi transpiler 2025-07-31 00:20 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      abs(System.os_time(:nanosecond))
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    n = trunc(n)
    d = trunc(d)
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  defp _sha256(bs) do
    bin = :erlang.list_to_binary(bs)
    :crypto.hash(:sha256, bin) |> :erlang.binary_to_list()
  end
  defp _getenv(name) do
    System.get_env(name)
  end
  defp _environ() do
    System.get_env() |> Enum.map(fn {k, v} -> "#{k}=#{v}" end)
  end
  def split(s, sep) do
    try do
      parts = []
      cur = ""
      i = 0
      while_fun = fn while_fun, cur, i, parts ->
        if i < _len(s) do
          {cur, i, parts} = if _len(sep) > 0 && i + _len(sep) <= _len(s) && _slice(s, i, i + _len(sep) - (i)) == sep do
            parts = (parts ++ [cur])
            cur = ""
            i = i + _len(sep)
            {cur, i, parts}
          else
            cur = (cur <> _slice(s, i, i + 1 - (i)))
            i = i + 1
            {cur, i, parts}
          end
          while_fun.(while_fun, cur, i, parts)
        else
          {cur, i, parts}
        end
      end
      {cur, i, parts} = try do
          while_fun.(while_fun, cur, i, parts)
        catch
          {:break, {cur, i, parts}} -> {cur, i, parts}
        end

      parts = (parts ++ [cur])
      throw {:return, parts}
    catch
      {:return, val} -> val
    end
  end
  def trimSpace(s) do
    try do
      start = 0
      while_fun_2 = fn while_fun_2, start ->
        if start < _len(s) && (_slice(s, start, (start + 1) - start) == " " || _slice(s, start, (start + 1) - start) == "\t") do
          start = start + 1
          while_fun_2.(while_fun_2, start)
        else
          start
        end
      end
      start = try do
          while_fun_2.(while_fun_2, start)
        catch
          {:break, start} -> start
        end

      end_ = _len(s)
      while_fun_3 = fn while_fun_3, end ->
        if end_ > start && (_slice(s, end_ - 1, end_ - (end_ - 1)) == " " || _slice(s, end_ - 1, end_ - (end_ - 1)) == "\t") do
          end_ = end_ - 1
          while_fun_3.(while_fun_3, end)
        else
          end
        end
      end
      end = try do
          while_fun_3.(while_fun_3, end)
        catch
          {:break, end} -> end
        end

      throw {:return, _slice(s, start, end_ - start)}
    catch
      {:return, val} -> val
    end
  end
  def indexOfSub(s, sub) do
    try do
      if _len(sub) == 0 do
        throw {:return, 0}
      end
      i = 0
      while_fun_4 = fn while_fun_4, i ->
        if i + _len(sub) <= _len(s) do
          if _slice(s, i, i + _len(sub) - (i)) == sub do
            throw {:return, i}
          end
          i = i + 1
          while_fun_4.(while_fun_4, i)
        else
          i
        end
      end
      i = try do
          while_fun_4.(while_fun_4, i)
        catch
          {:break, i} -> i
        end

      throw {:return, 0 - 1}
    catch
      {:return, val} -> val
    end
  end
  def parseRules(rs) do
    try do
      rules = []
      {rules} = Enum.reduce(Main.split(rs, "\n"), {rules}, fn line, {rules} ->
        try do
          ln = line
          hash = Main.indexOfSub(ln, "#")
          {ln} = if hash >= 0 do
            ln = _slice(ln, 0, hash - 0)
            {ln}
          else
            {ln}
          end
          ln = Main.trimSpace(ln)
          if _len(ln) == 0 do
            throw :continue
          end
          arrow = 0 - 1
          j = 0
          while_fun_5 = fn while_fun_5, arrow, j ->
            if j + 2 <= _len(ln) do
              {arrow} = if _slice(ln, j, j + 2 - (j)) == "->" do
                pre = j > 0 && (_slice(ln, j - 1, j - (j - 1)) == " " || _slice(ln, j - 1, j - (j - 1)) == "\t")
                post = j + 2 < _len(ln) && (_slice(ln, j + 2, (j + 3) - (j + 2)) == " " || _slice(ln, j + 2, (j + 3) - (j + 2)) == "\t")
                {arrow} = if pre && post do
                  arrow = j
                  throw {:break, {arrow, j}}
                  {arrow}
                else
                  {arrow}
                end
                {arrow}
              else
                {arrow}
              end
              j = j + 1
              while_fun_5.(while_fun_5, arrow, j)
            else
              {arrow, j}
            end
          end
          {arrow, j} = try do
              while_fun_5.(while_fun_5, arrow, j)
            catch
              {:break, {arrow, j}} -> {arrow, j}
            end

          {arrow} = if arrow < 0 do
            arrow = Main.indexOfSub(ln, "->")
            {arrow}
          else
            {arrow}
          end
          if arrow < 0 do
            throw {:return, %{"ok" => false}}
          end
          pat = Main.trimSpace(_slice(ln, 0, arrow - 0))
          rest = Main.trimSpace(_slice(ln, arrow + 2, _len(ln) - (arrow + 2)))
          term = false
          {rest, term} = if _len(rest) > 0 && _slice(rest, 0, 1 - 0) == "." do
            term = true
            rest = _slice(rest, 1, _len(rest) - 1)
            {rest, term}
          else
            {rest, term}
          end
          rep = rest
          rules = (rules ++ [%{"pat" => pat, "rep" => rep, "term" => term}])
        catch
          :continue -> {rules}
        end
        {rules}
      end)
      throw {:return, %{"ok" => true, "rules" => rules}}
    catch
      {:return, val} -> val
    end
  end
  def runRules(rules, s) do
    try do
      changed = true
      while_fun_6 = fn while_fun_6, changed, s ->
        if changed do
          changed = false
          i = 0
          while_fun_7 = fn while_fun_7, changed, i, s ->
            if i < _len(rules) do
              r = Enum.at(rules, i)
              pat = r["pat"]
              rep = r["rep"]
              term = r["term"]
              idx = Main.indexOfSub(s, pat)
              {changed, s} = if idx >= 0 do
                s = ((_slice(s, 0, idx - 0) <> rep) <> _slice(s, idx + _len(pat), _len(s) - idx + _len(pat)))
                changed = true
                if term do
                  throw {:return, s}
                end
                throw {:break, {changed, i, s}}
                {changed, s}
              else
                {changed, s}
              end
              i = i + 1
              while_fun_7.(while_fun_7, changed, i, s)
            else
              {changed, i, s}
            end
          end
          {changed, i, s} = try do
              while_fun_7.(while_fun_7, changed, i, s)
            catch
              {:break, {changed, i, s}} -> {changed, i, s}
            end

          while_fun_6.(while_fun_6, changed, s)
        else
          {changed, s}
        end
      end
      {changed, s} = try do
          while_fun_6.(while_fun_6, changed, s)
        catch
          {:break, {changed, s}} -> {changed, s}
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def interpret(ruleset, input) do
    try do
      p = Main.parseRules(ruleset)
      if !p["ok"] do
        throw {:return, %{"ok" => false, "out" => ""}}
      end
      out = Main.runRules(p["rules"], input)
      throw {:return, %{"ok" => true, "out" => out}}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      IO.puts((("validating " <> Kernel.inspect(_len(Process.get(:testSet)))) <> " test cases"))
      failures = false
      i = 0
      while_fun_8 = fn while_fun_8, failures, i ->
        if i < _len(Process.get(:testSet)) do
          tc = Enum.at(Process.get(:testSet), i)
          res = Main.interpret(tc["ruleSet"], tc["sample"])
          {failures} = if !res["ok"] do
            IO.puts((("test " <> Kernel.to_string(i + 1)) <> " invalid ruleset"))
            failures = true
            {failures}
          else
            {failures} = if res["out"] != tc["output"] do
              IO.puts(((((("test " <> Kernel.to_string(i + 1)) <> ": got ") <> res["out"]) <> ", want ") <> tc["output"]))
              failures = true
              {failures}
            else
              {failures}
            end
            {failures}
          end
          i = i + 1
          while_fun_8.(while_fun_8, failures, i)
        else
          {failures, i}
        end
      end
      {failures, i} = try do
          while_fun_8.(while_fun_8, failures, i)
        catch
          {:break, {failures, i}} -> {failures, i}
        end

      if !failures do
        IO.puts("no failures")
      end
    catch
      {:return, val} -> val
    end
  end
  Process.put(:testSet, [%{"ruleSet" => "# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample" => "I bought a B of As from T S.", "output" => "I bought a bag of apples from my brother."}, %{"ruleSet" => "# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample" => "I bought a B of As from T S.", "output" => "I bought a bag of apples from T shop."}, %{"ruleSet" => "# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample" => "I bought a B of As W my Bgage from T S.", "output" => "I bought a bag of apples with my money from T shop."}, %{"ruleSet" => "### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n", "sample" => "_1111*11111_", "output" => "11111111111111111111"}, %{"ruleSet" => "# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n", "sample" => "000000A000000", "output" => "00011H1111000"}])
end
Main.main()
