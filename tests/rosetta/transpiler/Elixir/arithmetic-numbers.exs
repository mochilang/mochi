# Code generated by Mochi transpiler 2025-07-26 19:45 +0700
defmodule Main do
  defp _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      seed
    else
      System.os_time(:nanosecond)
    end
  end
  defp _mem() do
    :erlang.memory(:total)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) -> String.slice(base, start, len)
      len == 1 -> Enum.slice(base, start, len)
      true -> Enum.slice(base, start, len)
    end
  end
  def sieve(limit) do
    try do
      spf = []
      i = 0
      while_fun = fn while_fun, i, spf ->
        if i <= limit do
          spf = (spf ++ [0])
          i = i + 1
          while_fun.(while_fun, i, spf)
        else
          {i, spf}
        end
      end
      {i, spf} = try do
          while_fun.(while_fun, i, spf)
        catch
          :break -> {i, spf}
        end

      i = 2
      while_fun_2 = fn while_fun_2, i, spf ->
        if i <= limit do
          if Enum.at(spf, i) == 0 do
            spf = List.replace_at(spf, i, i)
            if i * i <= limit do
              j = i * i
              while_fun_3 = fn while_fun_3, j, spf ->
                if j <= limit do
                  if Enum.at(spf, j) == 0 do
                    spf = List.replace_at(spf, j, i)
                  end
                  j = j + i
                  while_fun_3.(while_fun_3, j, spf)
                else
                  {j, spf}
                end
              end
              {j, spf} = try do
                  while_fun_3.(while_fun_3, j, spf)
                catch
                  :break -> {j, spf}
                end

            end
          end
          i = i + 1
          while_fun_2.(while_fun_2, i, spf)
        else
          {i, spf}
        end
      end
      {i, spf} = try do
          while_fun_2.(while_fun_2, i, spf)
        catch
          :break -> {i, spf}
        end

      throw {:return, spf}
    catch
      {:return, val} -> val
    end
  end
  def primesFrom(spf, limit) do
    try do
      primes = []
      i = 3
      while_fun_4 = fn while_fun_4, i, primes ->
        if i <= limit do
          if Enum.at(spf, i) == i do
            primes = (primes ++ [i])
          end
          i = i + 1
          while_fun_4.(while_fun_4, i, primes)
        else
          {i, primes}
        end
      end
      {i, primes} = try do
          while_fun_4.(while_fun_4, i, primes)
        catch
          :break -> {i, primes}
        end

      throw {:return, primes}
    catch
      {:return, val} -> val
    end
  end
  def pad3(n) do
    try do
      s = to_string(n)
      while_fun_5 = fn while_fun_5, s ->
        if String.length(s) < 3 do
          s = (" " <> s)
          while_fun_5.(while_fun_5, s)
        else
          s
        end
      end
      s = try do
          while_fun_5.(while_fun_5, s)
        catch
          :break -> s
        end

      throw {:return, s}
    catch
      {:return, val} -> val
    end
  end
  def commatize(n) do
    try do
      s = to_string(n)
      out = ""
      i = String.length(s) - 1
      c = 0
      while_fun_6 = fn while_fun_6, c, i, out ->
        if i >= 0 do
          out = (String.slice(s, i, i + 1 - (i)) <> out)
          c = c + 1
          if rem(c, 3) == 0 && i > 0 do
            out = ("," <> out)
          end
          i = i - 1
          while_fun_6.(while_fun_6, c, i, out)
        else
          {c, i, out}
        end
      end
      {c, i, out} = try do
          while_fun_6.(while_fun_6, c, i, out)
        catch
          :break -> {c, i, out}
        end

      throw {:return, out}
    catch
      {:return, val} -> val
    end
  end
  def primeCount(primes, last, spf) do
    try do
      lo = 0
      hi = length(primes)
      while_fun_7 = fn while_fun_7, hi, lo ->
        if lo < hi do
          mid = trunc(((lo + hi) / 2))
          if Enum.at(primes, mid) < last do
            lo = mid + 1
          else
            hi = mid
          end
          while_fun_7.(while_fun_7, hi, lo)
        else
          {hi, lo}
        end
      end
      {hi, lo} = try do
          while_fun_7.(while_fun_7, hi, lo)
        catch
          :break -> {hi, lo}
        end

      count = lo + 1
      if Enum.at(spf, last) != last do
        count = count - 1
      end
      throw {:return, count}
    catch
      {:return, val} -> val
    end
  end
  def arithmeticNumbers(limit, spf) do
    try do
      arr = [1]
      n = 3
      while_fun_8 = fn while_fun_8, arr, n ->
        if length(arr) < limit do
          if Enum.at(spf, n) == n do
            arr = (arr ++ [n])
          else
            x = n
            sigma = 1
            tau = 1
            while_fun_9 = fn while_fun_9, sigma, tau, x ->
              if x > 1 do
                p = Enum.at(spf, x)
                {p} = if p == 0 do
                  p = x
                  {p}
                else
                  {p}
                end
                cnt = 0
                power = p
                sum = 1
                while_fun_10 = fn while_fun_10, cnt, power, sum, x ->
                  if rem(x, p) == 0 do
                    x = div(x, p)
                    cnt = cnt + 1
                    sum = sum + power
                    power = power * p
                    while_fun_10.(while_fun_10, cnt, power, sum, x)
                  else
                    {cnt, power, sum, x}
                  end
                end
                {cnt, power, sum, x} = try do
                    while_fun_10.(while_fun_10, cnt, power, sum, x)
                  catch
                    :break -> {cnt, power, sum, x}
                  end

                sigma = sigma * sum
                tau = tau * (cnt + 1)
                while_fun_9.(while_fun_9, sigma, tau, x)
              else
                {sigma, tau, x}
              end
            end
            {sigma, tau, x} = try do
                while_fun_9.(while_fun_9, sigma, tau, x)
              catch
                :break -> {sigma, tau, x}
              end

            if rem(sigma, tau) == 0 do
              arr = (arr ++ [n])
            end
          end
          n = n + 1
          while_fun_8.(while_fun_8, arr, n)
        else
          {arr, n}
        end
      end
      {arr, n} = try do
          while_fun_8.(while_fun_8, arr, n)
        catch
          :break -> {arr, n}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      limit = 1228663
      spf = Main.sieve(limit)
      primes = Main.primesFrom(spf, limit)
      arr = Main.arithmeticNumbers(1000000, spf)
      IO.puts("The first 100 arithmetic numbers are:")
      i = 0
      while_fun_11 = fn while_fun_11, i ->
        if i < 100 do
          line = ""
          j = 0
          while_fun_12 = fn while_fun_12, j, line ->
            if j < 10 do
              line = (line <> Main.pad3(Enum.at(arr, i + j)))
              if j < 9 do
                line = (line <> " ")
              end
              j = j + 1
              while_fun_12.(while_fun_12, j, line)
            else
              {j, line}
            end
          end
          {j, line} = try do
              while_fun_12.(while_fun_12, j, line)
            catch
              :break -> {j, line}
            end

          IO.puts(line)
          i = i + 10
          while_fun_11.(while_fun_11, i)
        else
          i
        end
      end
      i = try do
          while_fun_11.(while_fun_11, i)
        catch
          :break -> i
        end

      Enum.each([1000, 10000, 100000, 1000000], fn x ->
        last = Enum.at(arr, x - 1)
        lastc = Main.commatize(last)
        IO.puts(((("\nThe " <> Main.commatize(x)) <> "th arithmetic number is: ") <> lastc))
        pc = Main.primeCount(primes, last, spf)
        comp = x - pc - 1
        IO.puts((((("The count of such numbers <= " <> lastc) <> " which are composite is ") <> Main.commatize(comp)) <> "."))
      end)
    catch
      {:return, val} -> val
    end
  end
end
Main.main()
