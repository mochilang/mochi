# Code generated by Mochi transpiler 2025-08-04 22:33 +0700
defmodule Main do
  def _now() do
    seeded = Process.get(:_now_seeded, false)
    seed = Process.get(:_now_seed, 0)
    if !seeded do
      case System.get_env("MOCHI_NOW_SEED") do
        nil -> :ok
        s ->
          case Integer.parse(s) do
            {v, ""} ->
              Process.put(:_now_seed, v)
              Process.put(:_now_seeded, true)
              seed = v
              seeded = true
            _ -> :ok
          end
      end
    end
    if seeded do
      seed = rem(seed * 1664525 + 1013904223, 2147483647)
      Process.put(:_now_seed, seed)
      abs(seed)
    else
      System.unique_integer([:positive, :monotonic])
    end
  end
  defp _bench_now() do
    System.monotonic_time(:microsecond)
  end
  defp _mem() do
    :erlang.process_info(self(), :memory) |> elem(1)
  end
  defp _lookup_host(host) do
    case :inet.gethostbyname(String.to_charlist(host)) do
      {:ok, {:hostent, _, _, _, _, addrs}} ->
        ips = Enum.map(addrs, &:inet.ntoa/1)
        [ips, nil]
      {:error, reason} ->
        [nil, reason]
    end
  end
  defp _clamp_slice(n, start, stop) do
    start = if start < 0, do: start + n, else: start
    stop = if stop < 0, do: stop + n, else: stop
    start = max(min(start, n), 0)
    stop = min(max(stop, start), n)
    {start, stop}
  end
  defp _slice(base, start, len) do
    cond do
      is_binary(base) ->
        chars = String.graphemes(base)
        n = length(chars)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(chars, s, e - s) |> Enum.join("")
      true ->
        n = length(base)
        {s, e} = _clamp_slice(n, start, start + len)
        Enum.slice(base, s, e - s)
    end
  end
  defp _len(x) do
    cond do
      x == nil -> 0
      is_binary(x) -> String.length(x)
      true -> length(x)
    end
  end
  defp _bigrat(v) do
    _bigrat(v, 1)
  end
  defp _bigrat(n, d) do
    n = trunc(n)
    d = trunc(d)
    g = Integer.gcd(n, d)
    n = div(n, g)
    d = div(d, g)
    if d < 0 do
      {-n, -d}
    else
      {n, d}
    end
  end
  defp _bigrat_add(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd + ad * bn, ad * bd)
  end
  defp _bigrat_sub(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd - ad * bn, ad * bd)
  end
  defp _bigrat_mul(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bn, ad * bd)
  end
  defp _bigrat_div(a, b) do
    {an, ad} = a
    {bn, bd} = b
    _bigrat(an * bd, ad * bn)
  end
  defp _bigrat_neg(a) do
    {n, d} = a
    {-n, d}
  end
  defp _sha256(bs) do
    bin = :erlang.list_to_binary(bs)
    :crypto.hash(:sha256, bin) |> :erlang.binary_to_list()
  end
  defp _getenv(name) do
    System.get_env(name)
  end
  defp _environ() do
    System.get_env() |> Enum.map(fn {k, v} -> "#{k}=#{v}" end)
  end
  defp _getoutput(cmd) do
    {out, 0} = System.cmd("sh", ["-c", cmd])
    String.trim(out)
  end
  def join(xs, sep) do
    try do
      res = ""
      i = 0
      while_fun = fn while_fun, i, res ->
        if i < _len(xs) do
          {res} = if i > 0 do
            res = (res <> sep)
            {res}
          else
            {res}
          end
          res = (res <> Enum.at(xs, i))
          i = i + 1
          while_fun.(while_fun, i, res)
        else
          {i, res}
        end
      end
      {i, res} = try do
          while_fun.(while_fun, i, res)
        catch
          {:break, {i, res}} -> {i, res}
        end

      throw {:return, res}
    catch
      {:return, val} -> val
    end
  end
  def sortPairs(xs) do
    try do
      arr = xs
      i = 1
      while_fun_2 = fn while_fun_2, arr, i ->
        if i < _len(arr) do
          j = i
          while_fun_3 = fn while_fun_3, arr, j ->
            if j > 0 && ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Enum.at(arr, j - 1)["count"])) < ((fn v -> if is_binary(v), do: String.to_integer(v), else: trunc(v) end).(Enum.at(arr, j)["count"])) do
              tmp = Enum.at(arr, j - 1)
              arr = List.replace_at(arr, j - 1, Enum.at(arr, j))
              arr = List.replace_at(arr, j, tmp)
              j = j - 1
              while_fun_3.(while_fun_3, arr, j)
            else
              {arr, j}
            end
          end
          {arr, j} = try do
              while_fun_3.(while_fun_3, arr, j)
            catch
              {:break, {arr, j}} -> {arr, j}
            end

          i = i + 1
          while_fun_2.(while_fun_2, arr, i)
        else
          {arr, i}
        end
      end
      {arr, i} = try do
          while_fun_2.(while_fun_2, arr, i)
        catch
          {:break, {arr, i}} -> {arr, i}
        end

      throw {:return, arr}
    catch
      {:return, val} -> val
    end
  end
  def isAlphaNumDot(ch) do
    try do
      throw {:return, (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z") || (ch >= "0" && ch <= "9") || ch == "_" || ch == "."}
    catch
      {:return, val} -> val
    end
  end
  def main() do
    try do
      srcLines = ["package main", "", "import (", "    \"fmt\"", "    \"go/ast\"", "    \"go/parser\"", "    \"go/token\"", "    \"io/ioutil\"", "    \"os\"", "    \"sort\"", ")", "", "func main() {", "    if len(os.Args) != 2 {", "        fmt.Println(\"usage ff <go source filename>\")", "        return", "    }", "    src, err := ioutil.ReadFile(os.Args[1])", "    if err != nil {", "        fmt.Println(err)", "        return", "    }", "    fs := token.NewFileSet()", "    a, err := parser.ParseFile(fs, os.Args[1], src, 0)", "    if err != nil {", "        fmt.Println(err)", "        return", "    }", "    f := fs.File(a.Pos())", "    m := make(map[string]int)", "    ast.Inspect(a, func(n ast.Node) bool {", "        if ce, ok := n.(*ast.CallExpr); ok {", "            start := f.Offset(ce.Pos())", "            end := f.Offset(ce.Lparen)", "            m[string(src[start:end])]++", "        }", "        return true", "    })", "    cs := make(calls, 0, len(m))", "    for k, v := range m {", "        cs = append(cs, &call{k, v})", "    }", "    sort.Sort(cs)", "    for i, c := range cs {", "        fmt.Printf(\"%-20s %4d\\n\", c.expr, c.count)", "        if i == 9 {", "            break", "        }", "    }", "}", "", "type call struct {", "    expr  string", "    count int", "}", "type calls []*call", "", "func (c calls) Len() int           { return len(c) }", "func (c calls) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }", "func (c calls) Less(i, j int) bool { return c[i].count > c[j].count }"]
      src = join(srcLines, "\n")
      freq = %{}
      i = 0
      order = []
      while_fun_4 = fn while_fun_4, freq, i, order ->
        if i < _len(src) do
          ch = _slice(src, i, i + 1 - (i))
          {freq, i, order} = if (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z") || ch == "_" do
            j = i + 1
            while_fun_5 = fn while_fun_5, j ->
              if j < _len(src) && isAlphaNumDot(_slice(src, j, j + 1 - (j))) do
                j = j + 1
                while_fun_5.(while_fun_5, j)
              else
                j
              end
            end
            j = try do
                while_fun_5.(while_fun_5, j)
              catch
                {:break, {j}} -> j
              end

            token = _slice(src, i, j - (i))
            k = j
            while_fun_6 = fn while_fun_6, k ->
              if k < _len(src) do
                cc = _slice(src, k, k + 1 - (k))
                {k} = if cc == " " || cc == "\t" || cc == "\n" || cc == "\r" do
                  k = k + 1
                  {k}
                else
                  throw {:break, {k}}
                  {k}
                end
                while_fun_6.(while_fun_6, k)
              else
                k
              end
            end
            k = try do
                while_fun_6.(while_fun_6, k)
              catch
                {:break, {k}} -> k
              end

            {freq, order} = if k < _len(src) && _slice(src, k, k + 1 - (k)) == "(" do
              p = i - 1
              while_fun_7 = fn while_fun_7, p ->
                if p >= 0 && (_slice(src, p, p + 1 - (p)) == " " || _slice(src, p, p + 1 - (p)) == "\t") do
                  p = p - 1
                  while_fun_7.(while_fun_7, p)
                else
                  p
                end
              end
              p = try do
                  while_fun_7.(while_fun_7, p)
                catch
                  {:break, {p}} -> p
                end

              skip = false
              {skip} = if p >= 3 do
                before = _slice(src, p - 3, p + 1 - (p - 3))
                {skip} = if before == "func" do
                  skip = true
                  {skip}
                else
                  {skip}
                end
                {skip}
              else
                {skip}
              end
              {freq, order} = if !skip do
                {freq, order} = if Map.has_key?(freq, token) do
                  freq = Map.put(freq, token, freq[token] + 1)
                  {freq, order}
                else
                  freq = Map.put(freq, token, 1)
                  order = (order ++ [token])
                  {freq, order}
                end
                {freq, order}
              else
                {freq, order}
              end
              {freq, order}
            else
              {freq, order}
            end
            i = j
            {freq, i, order}
          else
            i = i + 1
            {freq, i, order}
          end
          while_fun_4.(while_fun_4, freq, i, order)
        else
          {freq, i, order}
        end
      end
      {freq, i, order} = try do
          while_fun_4.(while_fun_4, freq, i, order)
        catch
          {:break, {freq, i, order}} -> {freq, i, order}
        end

      pairs = []
      {pairs} = Enum.reduce(order, {pairs}, fn t, {pairs} ->
        pairs = (pairs ++ [%{"expr" => t, "count" => freq[t]}])
        {pairs}
      end)
      pairs = sortPairs(pairs)
      idx = 0
      while_fun_8 = fn while_fun_8, idx ->
        if idx < _len(pairs) && idx < 10 do
          p = Enum.at(pairs, idx)
          IO.puts(Kernel.inspect(((p["expr"] <> " ") <> Kernel.inspect(p["count"]))))
          idx = idx + 1
          while_fun_8.(while_fun_8, idx)
        else
          idx
        end
      end
      idx = try do
          while_fun_8.(while_fun_8, idx)
        catch
          {:break, {idx}} -> idx
        end

    catch
      {:return, val} -> val
    end
  end
  def bench_main() do
    :erlang.garbage_collect()
    mem_start = _mem()
    t_start = _bench_now()
    main()
    mem_end = _mem()
    duration_us = max(_bench_now() - t_start, 1)
    :erlang.garbage_collect()
    mem_diff = abs(mem_end - mem_start)
    IO.puts("{\n  \"duration_us\": #{duration_us},\n  \"memory_bytes\": #{mem_diff},\n  \"name\": \"main\"\n}")
  end
end
Main.bench_main()
