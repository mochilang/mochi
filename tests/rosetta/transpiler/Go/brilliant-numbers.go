//go:build ignore

// Generated by Mochi v0.10.56 on 2025-08-03 17:57:10 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _padStart(s string, l int, ch string) string {
	if len(ch) == 0 {
		ch = " "
	}
	if len(s) >= l {
		return s
	}
	fill := ch[:1]
	return strings.Repeat(fill, l-len(s)) + s
}

func primesUpTo(n int) []int {
	var sieve []bool = []bool{}
	_ = sieve
	var i int = 0
	_ = i
	for i <= n {
		sieve = append(sieve, true)
		i = (i + 1)
	}
	var p int = 2
	_ = p
	for (p * p) <= n {
		if sieve[p] {
			var m int = (p * p)
			_ = m
			for m <= n {
				sieve[m] = false
				m = (m + p)
			}
		}
		p = (p + 1)
	}
	var res []int = []int{}
	_ = res
	var x int = 2
	_ = x
	for x <= n {
		if sieve[x] {
			res = append(res, x)
		}
		x = (x + 1)
	}
	return res
}

func sortInts(xs []int) []int {
	var res []int = []int{}
	_ = res
	var tmp []int = xs
	_ = tmp
	for len(tmp) > 0 {
		var min int = tmp[0]
		_ = min
		var idx int = 0
		_ = idx
		var i int = 1
		_ = i
		for i < len(tmp) {
			if tmp[i] < min {
				min = tmp[i]
				idx = i
			}
			i = (i + 1)
		}
		res = append(res, min)
		var out []int = []int{}
		_ = out
		var j int = 0
		_ = j
		for j < len(tmp) {
			if j != idx {
				out = append(out, tmp[j])
			}
			j = (j + 1)
		}
		tmp = out
	}
	return res
}

func commatize(n int) string {
	var s string = fmt.Sprint(n)
	_ = s
	var i int = (len(s) - 3)
	_ = i
	for i >= 1 {
		s = ((string([]rune(s)[0:i]) + ",") + string([]rune(s)[i:len(s)]))
		i = (i - 3)
	}
	return s
}

var primes []int

func getBrilliant(digits int, limit int, countOnly bool) map[string]any {
	var brilliant []int = []int{}
	_ = brilliant
	var count int = 0
	_ = count
	var pow int = 1
	_ = pow
	var next int = 999999999999999
	_ = next
	var k int = 1
	_ = k
	for k <= digits {
		var s []int = []int{}
		_ = s
		for _, p := range primes {
			if p >= (pow * 10) {
				break
			}
			if p > pow {
				s = append(s, p)
			}
		}
		var i int = 0
		_ = i
		for i < len(s) {
			var j int = i
			_ = j
			for j < len(s) {
				var prod int = (s[i] * s[j])
				_ = prod
				if prod < limit {
					if countOnly {
						count = (count + 1)
					} else {
						brilliant = append(brilliant, prod)
					}
				} else {
					if prod < next {
						next = prod
					}
					break
				}
				j = (j + 1)
			}
			i = (i + 1)
		}
		pow = (pow * 10)
		k = (k + 1)
	}
	if countOnly {
		return func(v any) map[string]any {
			if v == nil {
				return nil
			}
			if vv, ok := v.(map[string]any); ok {
				return vv
			}
			return nil
		}(map[string]any{"bc": count, "next": next})
	}
	return func(v any) map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.(map[string]any); ok {
			return vv
		}
		return nil
	}(map[string]any{"bc": brilliant, "next": next})
}

func mochiMain() {
	fmt.Println("First 100 brilliant numbers:")
	var r map[string]any = getBrilliant(2, 10000, false)
	_ = r
	var br []int = sortInts(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(r["bc"].(int))))
	_ = br
	br = br[0:100]
	var i int = 0
	_ = i
	for i < len(br) {
		fmt.Println((fmt.Sprint(_padStart(fmt.Sprint(br[i]), 4, " ")) + " "), false)
		if ((i + 1) % 10) == 0 {
			fmt.Println("", true)
		}
		i = (i + 1)
	}
	fmt.Println("", true)
	var k int = 1
	_ = k
	for k <= 13 {
		var limit int = int(math.Pow(float64(10), float64(k)))
		_ = limit
		var r2 map[string]any = getBrilliant(k, limit, true)
		_ = r2
		var total int = r2["bc"].(int)
		_ = total
		var next int = r2["next"].(int)
		_ = next
		var climit string = commatize(limit)
		_ = climit
		var ctotal string = commatize((total + 1))
		_ = ctotal
		var cnext string = commatize(next)
		_ = cnext
		fmt.Println(((((("First >= " + fmt.Sprint(_padStart(climit, 18, " "))) + " is ") + fmt.Sprint(_padStart(ctotal, 14, " "))) + " in the series: ") + fmt.Sprint(_padStart(cnext, 18, " "))))
		k = (k + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		primes = primesUpTo(3200000)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
