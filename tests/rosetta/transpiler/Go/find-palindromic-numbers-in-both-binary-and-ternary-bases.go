//go:build ignore

// Generated by Mochi v0.10.50 on 2025-07-31 00:28:59 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _parseIntStr(s string, base int) int { v, _ := strconv.ParseInt(s, base, 64); return int(v) }

func toBase(n int, b int) string {
	if n == 0 {
		return "0"
	}
	var s string = ""
	_ = s
	var x int = n
	_ = x
	for x > 0 {
		s = (fmt.Sprint((x % b)) + s)
		x = int((x / b))
	}
	return s
}

func parseIntStr(str string) int {
	var i int = 0
	_ = i
	var neg bool = false
	_ = neg
	if (len(str) > 0) && (string([]rune(str)[0]) == "-") {
		neg = true
		i = 1
	}
	var n int = 0
	_ = n
	for i < len(str) {
		n = (((n * 10) + func() int { n, _ := strconv.Atoi(string([]rune(str)[i:(i + 1)])); return n }()) - func() int { n, _ := strconv.Atoi("0"); return n }())
		i = (i + 1)
	}
	if neg {
		n = (0 - n)
	}
	return n
}

func parseIntBase(s string, b int) int {
	var n int = 0
	_ = n
	var i int = 0
	_ = i
	for i < len(s) {
		n = ((n * b) + _parseIntStr(string([]rune(s)[i:(i+1)]), 10))
		i = (i + 1)
	}
	return n
}

func reverseStr(s string) string {
	var out string = ""
	_ = out
	var i int = (len(s) - 1)
	_ = i
	for i >= 0 {
		out = (out + string([]rune(s)[i:(i+1)]))
		i = (i - 1)
	}
	return out
}

func isPalindrome(s string) bool {
	return (s == reverseStr(s))
}

func isPalindromeBin(n int) bool {
	var b string = toBase(n, 2)
	_ = b
	_ = b
	return isPalindrome(b)
}

func myMin(a int, b int) int {
	if a < b {
		return a
	}
	return b
}

func myMax(a int, b int) int {
	if a > b {
		return a
	}
	return b
}

func reverse3(n int) int {
	var x int = 0
	_ = x
	var y int = n
	_ = y
	for y != 0 {
		x = ((x * 3) + (y % 3))
		y = int((y / 3))
	}
	return x
}

func show(n int) {
	fmt.Println(("Decimal : " + fmt.Sprint(n)))
	fmt.Println(("Binary  : " + toBase(n, 2)))
	fmt.Println(("Ternary : " + toBase(n, 3)))
	fmt.Println("")
}

func mochiMain() {
	fmt.Println("The first 6 numbers which are palindromic in both binary and ternary are :\n")
	show(0)
	var count int = 1
	_ = count
	var lo int = 0
	_ = lo
	var hi int = 1
	_ = hi
	var pow2 int = 1
	_ = pow2
	var pow3 int = 1
	_ = pow3
	for {
		var i int = lo
		_ = i
		for i < hi {
			var n int = ((((i * 3) + 1) * pow3) + reverse3(i))
			_ = n
			if isPalindromeBin(n) {
				show(n)
				count = (count + 1)
				if count >= 6 {
					return
				}
			}
			i = (i + 1)
		}
		if i == pow3 {
			pow3 = (pow3 * 3)
		} else {
			pow2 = (pow2 * 4)
		}
		for {
			for pow2 <= pow3 {
				pow2 = (pow2 * 4)
			}
			var lo2 int = int((((pow2 / pow3) - 1) / 3))
			_ = lo2
			var hi2 int = (int(((((pow2 * 2) / pow3) - 1) / 3)) + 1)
			_ = hi2
			var lo3 int = int((pow3 / 3))
			_ = lo3
			var hi3 int = pow3
			_ = hi3
			if lo2 >= hi3 {
				pow3 = (pow3 * 3)
			} else {
				if lo3 >= hi2 {
					pow2 = (pow2 * 4)
				} else {
					lo = myMax(lo2, lo3)
					hi = myMin(hi2, hi3)
					break
				}
			}
		}
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
