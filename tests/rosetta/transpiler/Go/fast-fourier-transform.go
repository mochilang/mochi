//go:build ignore

// Generated by Mochi v0.10.55 on 2025-08-02 17:45:44 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

var PI float64

type Complex struct {
	Re float64 `json:"re"`
	Im float64 `json:"im"`
}

func sinApprox(x float64) float64 {
	var term float64 = x
	_ = term
	var sum float64 = x
	_ = sum
	var n int = 1
	_ = n
	for n <= 10 {
		var denom float64 = float64(((2 * n) * ((2 * n) + 1)))
		_ = denom
		term = ((((0 - term) * x) * x) / denom)
		sum = (sum + term)
		n = (n + 1)
	}
	return sum
}

func cosApprox(x float64) float64 {
	var term float64 = 1.0
	_ = term
	var sum float64 = 1.0
	_ = sum
	var n int = 1
	_ = n
	for n <= 10 {
		var denom float64 = float64((((2 * n) - 1) * (2 * n)))
		_ = denom
		term = ((((0 - term) * x) * x) / denom)
		sum = (sum + term)
		n = (n + 1)
	}
	return sum
}

func cis(x float64) Complex {
	return Complex{
		Re: cosApprox(x),
		Im: sinApprox(x),
	}
}

func add(a Complex, b Complex) Complex {
	return Complex{
		Re: (a.Re + b.Re),
		Im: (a.Im + b.Im),
	}
}

func sub(a Complex, b Complex) Complex {
	return Complex{
		Re: (a.Re - b.Re),
		Im: (a.Im - b.Im),
	}
}

func mul(a Complex, b Complex) Complex {
	return Complex{
		Re: ((a.Re * b.Re) - (a.Im * b.Im)),
		Im: ((a.Re * b.Im) + (a.Im * b.Re)),
	}
}

func ditfft2Rec(x []float64, y []Complex, offX int, offY int, n int, s int) {
	if n == 1 {
		y[offY] = Complex{
			Re: x[offX],
			Im: 0.0,
		}
		return
	}
	ditfft2Rec(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(x), func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(y), offX, offY, (n / 2), (2 * s))
	ditfft2Rec(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(x), func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(y), (offX + s), (offY + (n / 2)), (n / 2), (2 * s))
	var k int = 0
	_ = k
	for k < (n / 2) {
		var angle float64 = ((((0 - 2.0) * PI) * float64(k)) / float64(n))
		_ = angle
		var tf Complex = mul(cis(angle), y[((offY+k)+(n/2))])
		_ = tf
		var a Complex = add(y[(offY+k)], tf)
		_ = a
		var b Complex = sub(y[(offY+k)], tf)
		_ = b
		y[(offY + k)] = a
		y[((offY + k) + (n / 2))] = b
		k = (k + 1)
	}
}

func ditfft2(x []float64, y []Complex, n int, s int) {
	ditfft2Rec(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(x), func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(y), 0, 0, n, s)
}

func mochiMain() {
	var x []float64 = []float64{1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0}
	_ = x
	var y []Complex = []Complex{}
	_ = y
	var i int = 0
	_ = i
	for i < len(x) {
		y = append(y, Complex{
			Re: 0.0,
			Im: 0.0,
		})
		i = (i + 1)
	}
	ditfft2(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(x), func(v any) []Complex {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Complex); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Complex{}
			}
			out := make([]Complex, len(arr))
			for i, x := range arr {
				out[i] = x.(Complex)
			}
			return out
		}
		return v.([]Complex)
	}(y), len(x), 1)
	for _, c := range y {
		var line string = pad(fmt_(c.Re), 8)
		_ = line
		if c.Im >= float64(0) {
			line = ((line + "+") + fmt_(c.Im))
		} else {
			line = (line + fmt_(c.Im))
		}
		fmt.Println(line)
	}
}

func pad(s string, w int) string {
	var t string = s
	_ = t
	for len(t) < w {
		t = (" " + t)
	}
	return t
}

func fmt_(x float64) string {
	var y float64 = (floorf(((x * 10000.0) + 0.5)) / 10000.0)
	_ = y
	var s string = fmt.Sprint(y)
	_ = s
	var dot int = strings.Index(s, ".")
	_ = dot
	if dot == (0 - 1) {
		s = (s + ".0000")
	} else {
		var d int = ((len(s) - dot) - 1)
		_ = d
		for d < 4 {
			s = (s + "0")
			d = (d + 1)
		}
	}
	return s
}

func floorf(x float64) float64 {
	var y int = int(x)
	_ = y
	_ = y
	return float64(y)
}

func indexOf(s string, ch string) int {
	var i int = 0
	_ = i
	for i < len(s) {
		if _substr(s, i, (i+1)) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		PI = 3.141592653589793
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
