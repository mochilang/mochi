//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 17:10:38 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func ord(ch string) int {
	if ch == "5" {
		return 53
	}
	if ch == "T" {
		return 84
	}
	if ch == " " {
		return 32
	}
	if ch == "é" {
		return 233
	}
	if ch == "🐺" {
		return 128058
	}
	return 0
}

func hex(n int) string {
	var digits string = "0123456789abcdef"
	if n == 0 {
		return "0x0"
	}
	var m int = n
	var out string = ""
	for m > 0 {
		var d int = (m % 16)
		out = (_substr(digits, d, (d+1)) + out)
		m = (m / 16)
	}
	return ("0x" + out)
}

func quote(s string) string {
	return (("'" + s) + "'")
}

func analyze(s string) {
	var le int = len(s)
	fmt.Println((((("Analyzing " + quote(s)) + " which has a length of ") + fmt.Sprint(le)) + ":"))
	if le > 1 {
		var i int = 1
		for i < le {
			var cur string = _substr(s, i, (i + 1))
			var prev string = _substr(s, (i - 1), i)
			if cur != prev {
				fmt.Println("  Not all characters in the string are the same.")
				fmt.Println((((((("  " + quote(cur)) + " (") + hex(ord(cur))) + ") is different at position ") + fmt.Sprint((i + 1))) + "."))
				fmt.Println("")
				return
			}
			i = (i + 1)
		}
	}
	fmt.Println("  All characters in the string are the same.")
	fmt.Println("")
}

func mochiMain() {
	var strings []string = []string{"", "   ", "2", "333", ".55", "tttTTT", "4444 444k", "pépé", "🐶🐶🐺🐶", "🎄🎄🎄🎄"}
	var i int = 0
	for i < len(strings) {
		analyze(strings[i])
		i = (i + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
