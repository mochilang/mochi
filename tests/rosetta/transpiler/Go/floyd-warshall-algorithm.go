//go:build ignore

// Generated by Mochi v0.10.52 on 2025-08-01 17:34:04 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func mochiMain() {
	var INF int = 1000000000
	_ = INF
	var n int = 4
	_ = n
	var dist [][]int = [][]int{}
	_ = dist
	var next [][]int = [][]int{}
	_ = next
	var i int = 0
	_ = i
	for i < n {
		var row []int = []int{}
		_ = row
		var nrow []int = []int{}
		_ = nrow
		var j int = 0
		_ = j
		for j < n {
			if i == j {
				row = append(row, 0)
			} else {
				row = append(row, INF)
			}
			nrow = append(nrow, (0 - 1))
			j = (j + 1)
		}
		dist = append(dist, row)
		next = append(next, nrow)
		i = (i + 1)
	}
	dist[0][2] = (0 - 2)
	next[0][2] = 2
	dist[2][3] = 2
	next[2][3] = 3
	dist[3][1] = (0 - 1)
	next[3][1] = 1
	dist[1][0] = 4
	next[1][0] = 0
	dist[1][2] = 3
	next[1][2] = 2
	var k int = 0
	_ = k
	for k < n {
		var i int = 0
		_ = i
		for i < n {
			var j int = 0
			_ = j
			for j < n {
				if (dist[i][k] < INF) && (dist[k][j] < INF) {
					var alt int = (dist[i][k] + dist[k][j])
					_ = alt
					if alt < dist[i][j] {
						dist[i][j] = alt
						next[i][j] = next[i][k]
					}
				}
				j = (j + 1)
			}
			i = (i + 1)
		}
		k = (k + 1)
	}
	var path func(int, int) []int
	_ = path
	path = func(u int, v int) []int {
		var ui int = (u - 1)
		_ = ui
		var vi int = (v - 1)
		_ = vi
		if next[ui][vi] == (0 - 1) {
			return func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}([]any{})
		}
		var p []int = []int{u}
		_ = p
		var cur int = ui
		_ = cur
		for cur != vi {
			cur = next[cur][vi]
			p = append(p, (cur + 1))
		}
		return p
	}
	var pathStr func([]int) string
	_ = pathStr
	pathStr = func(p []int) string {
		var s string = ""
		_ = s
		var first bool = true
		_ = first
		var idx int = 0
		_ = idx
		for idx < len(p) {
			var x int = p[idx]
			_ = x
			if !first {
				s = (s + " -> ")
			}
			s = (s + fmt.Sprint(x))
			first = false
			idx = (idx + 1)
		}
		return s
	}
	fmt.Println("pair\tdist\tpath")
	var a int = 0
	_ = a
	for a < n {
		var b int = 0
		_ = b
		for b < n {
			if a != b {
				fmt.Println(((((((fmt.Sprint((a + 1)) + " -> ") + fmt.Sprint((b + 1))) + "\t") + fmt.Sprint(dist[a][b])) + "\t") + pathStr(func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(path((a+1), (b+1))))))
			}
			b = (b + 1)
		}
		a = (a + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
