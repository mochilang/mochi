//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 17:10:19 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

type V3 struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
	Z float64 `json:"z"`
}

type Sphere struct {
	Cx float64 `json:"cx"`
	Cy float64 `json:"cy"`
	Cz float64 `json:"cz"`
	R  float64 `json:"r"`
}

func sqrtApprox(x float64) float64 {
	if x <= 0.0 {
		return 0.0
	}
	var guess float64 = x
	var i int = 0
	for i < 20 {
		guess = ((guess + (x / guess)) / 2.0)
		i = (i + 1)
	}
	return guess
}

func powf(base float64, exp int) float64 {
	var result float64 = 1.0
	var i int = 0
	for i < exp {
		result = (result * base)
		i = (i + 1)
	}
	return result
}

func normalize(v V3) V3 {
	var len float64 = sqrtApprox((((v.X * v.X) + (v.Y * v.Y)) + (v.Z * v.Z)))
	return V3{
		X: (v.X / len),
		Y: (v.Y / len),
		Z: (v.Z / len),
	}
}

func dot(a V3, b V3) float64 {
	var d float64 = (((a.X * b.X) + (a.Y * b.Y)) + (a.Z * b.Z))
	if d < 0.0 {
		return (0 - d)
	}
	return 0.0
}

func hitSphere(s Sphere, x float64, y float64) map[string]any {
	var dx float64 = (x - s.Cx)
	var dy float64 = (y - s.Cy)
	var zsq float64 = ((s.R * s.R) - ((dx * dx) + (dy * dy)))
	if zsq < 0.0 {
		return map[string]any{"hit": false}
	}
	var z float64 = sqrtApprox(zsq)
	return map[string]any{"hit": true, "z1": (s.Cz - z), "z2": (s.Cz + z)}
}

func mochiMain() {
	var shades string = ".:!*oe&#%@"
	var light V3 = normalize(V3{
		X: (0 - 50.0),
		Y: 30.0,
		Z: 50.0,
	})
	var pos Sphere = Sphere{
		Cx: 20.0,
		Cy: 20.0,
		Cz: 0.0,
		R:  20.0,
	}
	var neg Sphere = Sphere{
		Cx: 1.0,
		Cy: 1.0,
		Cz: (0 - 6.0),
		R:  20.0,
	}
	var yi int = 0
	for yi <= 40 {
		var y float64 = (float64(yi) + 0.5)
		var line string = ""
		var xi int = (0 - 20)
		for xi <= 60 {
			var x float64 = ((((float64(xi) - pos.Cx) / 2.0) + 0.5) + pos.Cx)
			var hb map[string]any = hitSphere(pos, x, y)
			if !hb["hit"].(bool) {
				line = (line + " ")
				xi = (xi + 1)
				continue
			}
			var zb1 float64 = hb["z1"].(float64)
			var zb2 float64 = hb["z2"].(float64)
			var hs map[string]any = hitSphere(neg, x, y)
			var hitRes int = 1
			if !hs["hit"].(bool) {
				hitRes = 1
			} else {
				if hs["z1"].(float64) > zb1 {
					hitRes = 1
				} else {
					if hs["z2"].(float64) > zb2 {
						hitRes = 0
					} else {
						if hs["z2"].(float64) > zb1 {
							hitRes = 2
						} else {
							hitRes = 1
						}
					}
				}
			}
			if hitRes == 0 {
				line = (line + " ")
				xi = (xi + 1)
				continue
			}
			var vec V3
			if hitRes == 1 {
				vec = V3{
					X: (x - pos.Cx),
					Y: (y - pos.Cy),
					Z: (zb1 - pos.Cz),
				}
			} else {
				vec = V3{
					X: (neg.Cx - x),
					Y: (neg.Cy - y),
					Z: (neg.Cz - hs["z2"].(float64)),
				}
			}
			vec = normalize(vec)
			var b float64 = (powf(dot(light, vec), 2) + 0.5)
			var intensity int = int(((1.0 - b) * float64(len(shades))))
			if intensity < 0 {
				intensity = 0
			}
			if intensity >= len(shades) {
				intensity = (len(shades) - 1)
			}
			line = (line + _substr(shades, intensity, (intensity+1)))
			xi = (xi + 1)
		}
		fmt.Println(line)
		yi = (yi + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
