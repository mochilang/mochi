//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 22:46:42 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

var vals []int

var billions []int

func ebanNumbers(start int, stop int) []int {
	var nums []int = []int{}
	_ = nums
	for _, b := range billions {
		for _, m := range vals {
			for _, t := range vals {
				for _, r := range vals {
					var n int = ((((b * 1000000000) + (m * 1000000)) + (t * 1000)) + r)
					_ = n
					if (n >= start) && (n <= stop) {
						nums = append(nums, n)
					}
				}
			}
		}
	}
	return nums
}

func countEban(start int, stop int) int {
	var count int = 0
	_ = count
	for _, b := range billions {
		for _, m := range vals {
			for _, t := range vals {
				for _, r := range vals {
					var n int = ((((b * 1000000000) + (m * 1000000)) + (t * 1000)) + r)
					_ = n
					if (n >= start) && (n <= stop) {
						count = (count + 1)
					}
				}
			}
		}
	}
	return count
}

func mochiMain() {
	var ranges [][]any = [][]any{[]any{2, 1000, true}, []any{1000, 4000, true}, []any{2, 10000, false}, []any{2, 100000, false}, []any{2, 1000000, false}, []any{2, 10000000, false}, []any{2, 100000000, false}, []any{2, 1000000000, false}}
	_ = ranges
	for _, rg := range ranges {
		var start int = rg[0].(int)
		_ = start
		var stop int = rg[1].(int)
		_ = stop
		var show bool = rg[2].(bool)
		_ = show
		if start == 2 {
			fmt.Println((("eban numbers up to and including " + fmt.Sprint(stop)) + ":"))
		} else {
			fmt.Println((((("eban numbers between " + fmt.Sprint(start)) + " and ") + fmt.Sprint(stop)) + " (inclusive):"))
		}
		if show {
			var nums []int = ebanNumbers(start, stop)
			_ = nums
			var line string = ""
			_ = line
			var i int = 0
			_ = i
			for i < len(nums) {
				line = ((line + fmt.Sprint(nums[i])) + " ")
				i = (i + 1)
			}
			if len(line) > 0 {
				fmt.Println(_substr(line, 0, (len(line) - 1)))
			}
		}
		var c int = countEban(start, stop)
		_ = c
		fmt.Println((("count = " + fmt.Sprint(c)) + "\n"))
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		vals = []int{0, 2, 4, 6, 30, 32, 34, 36, 40, 42, 44, 46, 50, 52, 54, 56, 60, 62, 64, 66}
		billions = []int{0, 2, 4, 6}
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
