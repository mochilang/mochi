//go:build ignore

// Generated by Mochi v0.10.57 on 2025-08-04 15:33:53 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func isPrime(n int) bool {
	if n < 2 {
		return false
	}
	if (n % 2) == 0 {
		return (n == 2)
	}
	if (n % 3) == 0 {
		return (n == 3)
	}
	var d int = 5
	_ = d
	for (d * d) <= n {
		if (n % d) == 0 {
			return false
		}
		d = (d + 2)
		if (n % d) == 0 {
			return false
		}
		d = (d + 4)
	}
	return true
}

func bigTrim(a []int) []int {
	var n int = len(a)
	_ = n
	for (n > 1) && (a[(n-1)] == 0) {
		a = a[0:(n - 1)]
		n = (n - 1)
	}
	return a
}

func bigFromInt(x int) []int {
	if x == 0 {
		return []int{0}
	}
	var digits []int = []int{}
	_ = digits
	var n int = x
	_ = n
	for n > 0 {
		digits = append(digits, (n % 10))
		n = (n / 10)
	}
	return digits
}

func bigMulSmall(a []int, m int) []int {
	if m == 0 {
		return []int{0}
	}
	var res []int = []int{}
	_ = res
	var carry int = 0
	_ = carry
	var i int = 0
	_ = i
	for i < len(a) {
		var prod int = ((a[i] * m) + carry)
		_ = prod
		res = append(res, (prod % 10))
		carry = (prod / 10)
		i = (i + 1)
	}
	for carry > 0 {
		res = append(res, (carry % 10))
		carry = (carry / 10)
	}
	return bigTrim(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(res))
}

func bigToString(a []int) string {
	var s string = ""
	_ = s
	var i int = (len(a) - 1)
	_ = i
	for i >= 0 {
		s = (s + fmt.Sprint(a[i]))
		i = (i - 1)
	}
	return s
}

func pow2(k int) int {
	var r int = 1
	_ = r
	var i int = 0
	_ = i
	for i < k {
		r = (r * 2)
		i = (i + 1)
	}
	return r
}

func ccFactors(n int, m int) []int {
	var p int = ((6 * m) + 1)
	_ = p
	if !isPrime(p) {
		return func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]any{})
	}
	var prod []int = bigFromInt(p)
	_ = prod
	p = ((12 * m) + 1)
	if !isPrime(p) {
		return func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}([]any{})
	}
	prod = bigMulSmall(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(prod), p)
	var i int = 1
	_ = i
	for i <= (n - 2) {
		p = (((pow2(i) * 9) * m) + 1)
		if !isPrime(p) {
			return func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}([]any{})
		}
		prod = bigMulSmall(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(prod), p)
		i = (i + 1)
	}
	return prod
}

func ccNumbers(start int, end int) {
	var n int = start
	_ = n
	for n <= end {
		var m int = 1
		_ = m
		if n > 4 {
			m = pow2((n - 4))
		}
		for {
			var num []int = ccFactors(n, m)
			_ = num
			if len(num) > 0 {
				fmt.Println(((("a(" + fmt.Sprint(n)) + ") = ") + bigToString(func(v any) []int {
					if v == nil {
						return nil
					}
					if vv, ok := v.([]int); ok {
						return vv
					}
					if arr, ok := v.([]any); ok {
						if len(arr) == 0 {
							return []int{}
						}
						out := make([]int, len(arr))
						for i, x := range arr {
							out[i] = x.(int)
						}
						return out
					}
					return v.([]int)
				}(num))))
				break
			}
			if n <= 4 {
				m = (m + 1)
			} else {
				m = (m + pow2((n - 4)))
			}
		}
		n = (n + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		ccNumbers(3, 9)
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
