//go:build ignore

// Generated by Mochi v0.10.50 on 2025-07-31 00:29:28 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func qsel(a []float64, k int) float64 {
	var arr []float64 = a
	_ = arr
	for len(arr) > 1 {
		var px int = (_now() % len(arr))
		_ = px
		var pv float64 = arr[px]
		_ = pv
		var last int = (len(arr) - 1)
		_ = last
		var tmp float64 = arr[px]
		_ = tmp
		arr[px] = arr[last]
		arr[last] = tmp
		px = 0
		var i int = 0
		_ = i
		for i < last {
			var v float64 = arr[i]
			_ = v
			if v < pv {
				var t float64 = arr[px]
				_ = t
				arr[px] = arr[i]
				arr[i] = t
				px = (px + 1)
			}
			i = (i + 1)
		}
		arr[px] = pv
		if px == k {
			return pv
		}
		if k < px {
			arr = arr[0:px]
		} else {
			arr = arr[(px + 1):]
			k = (k - (px + 1))
		}
	}
	return arr[0]
}

func fivenum(a []float64) []float64 {
	var last int = (len(a) - 1)
	_ = last
	var m int = (last / 2)
	_ = m
	var n5 []float64 = []float64{}
	_ = n5
	n5 = append(n5, qsel(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(a[0:m]), 0))
	n5 = append(n5, qsel(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(a[0:m]), (len(a)/4)))
	n5 = append(n5, qsel(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(a), m))
	var arr2 []float64 = a[m:]
	_ = arr2
	var q3 int = ((last - m) - (len(a) / 4))
	_ = q3
	n5 = append(n5, qsel(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(arr2), q3))
	arr2 = arr2[q3:]
	n5 = append(n5, qsel(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(arr2), (len(arr2)-1)))
	return n5
}

var x1 []float64

var x2 []float64

var x3 []float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		x1 = []float64{36.0, 40.0, 7.0, 39.0, 41.0, 15.0}
		x2 = []float64{15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0}
		x3 = []float64{0.14082834, 0.0974879, 1.73131507, 0.87636009, (0 - 1.95059594), 0.73438555, (0 - 0.03035726), 1.4667597, (0 - 0.74621349), (0 - 0.72588772), 0.6390516, 0.61501527, (0 - 0.9898378), (0 - 1.00447874), (0 - 0.62759469), 0.66206163, 1.04312009, (0 - 0.10305385), 0.75775634, 0.32566578}
		fmt.Println(fmt.Sprint(fivenum(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(x1))))
		fmt.Println(fmt.Sprint(fivenum(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(x2))))
		fmt.Println(fmt.Sprint(fivenum(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(x3))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
