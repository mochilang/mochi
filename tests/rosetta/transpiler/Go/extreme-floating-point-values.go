//go:build ignore

// Generated by Mochi v0.10.55 on 2025-08-02 17:38:22 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func makeInf() float64 {
	var x float64 = 1.0
	_ = x
	var i int = 0
	_ = i
	for i < 400 {
		x = (x * 10.0)
		i = (i + 1)
	}
	return x
}

func makeMax() float64 {
	var x float64 = 1.0
	_ = x
	var i int = 0
	_ = i
	for i < 308 {
		x = (x * 10.0)
		i = (i + 1)
	}
	return x
}

func isNaN(x float64) bool {
	return (x != x)
}

func validateNaN(n float64, op string) {
	if isNaN(n) {
		fmt.Println((op + " -> NaN"))
	} else {
		fmt.Println("!!! Expected NaN from", op, " Found", func() string {
			f := float64(n)
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
	}
}

func validateZero(n float64, op string) {
	if n == float64(0) {
		fmt.Println((op + " -> 0"))
	} else {
		fmt.Println("!!! Expected 0 from", op, " Found", func() string {
			f := float64(n)
			if f == 0 && math.Signbit(f) {
				return "-0"
			}
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
	}
}

func validateGT(a float64, b float64, op string) {
	if a > b {
		fmt.Println(op)
	} else {
		fmt.Println("!!! Expected", op, " Found not true.")
	}
}

func validateNE(a float64, b float64, op string) {
	if a == b {
		fmt.Println("!!! Expected", op, " Found not true.")
	} else {
		fmt.Println(op)
	}
}

func validateEQ(a float64, b float64, op string) {
	if a == b {
		fmt.Println(op)
	} else {
		fmt.Println("!!! Expected", op, " Found not true.")
	}
}

func mochiMain() {
	var negZero float64 = math.Copysign(0.0, -1.0)
	_ = negZero
	var posInf float64 = makeInf()
	_ = posInf
	var negInf float64 = (0 - posInf)
	_ = negInf
	var nan float64 = (posInf / posInf)
	_ = nan
	var maxVal float64 = makeMax()
	_ = maxVal
	fmt.Println(func() string {
		f := float64(negZero)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(posInf)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(negInf)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(nan)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(negZero)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(posInf)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(negInf)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(nan)
		if f == 0 && math.Signbit(f) {
			return "-0"
		}
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println("")
	validateNaN((negInf + posInf), "-Inf + Inf")
	validateNaN((0.0 * posInf), "0 * Inf")
	validateNaN((posInf / posInf), "Inf / Inf")
	validateNaN(math.Mod(posInf, 1.0), "Inf % 1")
	validateNaN((1.0 + nan), "1 + NaN")
	validateZero((1.0 / posInf), "1 / Inf")
	validateGT(posInf, maxVal, "Inf > max value")
	validateGT((0 - maxVal), negInf, "-Inf < max neg value")
	validateNE(nan, nan, "NaN != NaN")
	validateEQ(negZero, 0.0, "-0 == 0")
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
