//go:build ignore

// Generated by Mochi v0.10.52 on 2025-08-01 19:12:21 GMT+7
package main

import (
	"fmt"
	math "math"
)

func makeInf() float64 {
	var x float64 = 1.0
	_ = x
	var i int = 0
	_ = i
	for i < 400 {
		x = (x * 10.0)
		i = (i + 1)
	}
	return x
}

func makeMax() float64 {
	var x float64 = 1.0
	_ = x
	var i int = 0
	_ = i
	for i < 308 {
		x = (x * 10.0)
		i = (i + 1)
	}
	return x
}

func isNaN(x float64) bool {
	return (x != x)
}

func validateNaN(n float64, op string) {
	if isNaN(n) {
		fmt.Println((op + " -> NaN"))
	} else {
		fmt.Println("!!! Expected NaN from", op, " Found", func() string {
			f := float64(n)
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
	}
}

func validateZero(n float64, op string) {
	if n == float64(0) {
		fmt.Println((op + " -> 0"))
	} else {
		fmt.Println("!!! Expected 0 from", op, " Found", func() string {
			f := float64(n)
			if f == float64(int(f)) {
				return fmt.Sprintf("%.1f", f)
			}
			return fmt.Sprint(f)
		}())
	}
}

func validateGT(a float64, b float64, op string) {
	if a > b {
		fmt.Println(op)
	} else {
		fmt.Println("!!! Expected", op, " Found not true.")
	}
}

func validateNE(a float64, b float64, op string) {
	if a == b {
		fmt.Println("!!! Expected", op, " Found not true.")
	} else {
		fmt.Println(op)
	}
}

func validateEQ(a float64, b float64, op string) {
	if a == b {
		fmt.Println(op)
	} else {
		fmt.Println("!!! Expected", op, " Found not true.")
	}
}

func mochiMain() {
	var negZero float64 = (0 - 0.0)
	_ = negZero
	var posInf float64 = makeInf()
	_ = posInf
	var negInf float64 = (0 - posInf)
	_ = negInf
	var nan float64 = (posInf / posInf)
	_ = nan
	var maxVal float64 = makeMax()
	_ = maxVal
	fmt.Println(func() string {
		f := float64(negZero)
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(posInf)
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(negInf)
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(nan)
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println(func() string {
		f := float64(negZero)
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(posInf)
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(negInf)
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}(), func() string {
		f := float64(nan)
		if f == float64(int(f)) {
			return fmt.Sprintf("%.1f", f)
		}
		return fmt.Sprint(f)
	}())
	fmt.Println("")
	validateNaN((negInf + posInf), "-Inf + Inf")
	validateNaN((0.0 * posInf), "0 * Inf")
	validateNaN((posInf / posInf), "Inf / Inf")
	validateNaN(math.Mod(posInf, 1.0), "Inf % 1")
	validateNaN((1.0 + nan), "1 + NaN")
	validateZero((1.0 / posInf), "1 / Inf")
	validateGT(posInf, maxVal, "Inf > max value")
	validateGT((0 - maxVal), negInf, "-Inf < max neg value")
	validateNE(nan, nan, "NaN != NaN")
	validateEQ(negZero, 0.0, "-0 == 0")
}

func main() {
	mochiMain()
}
