//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 17:10:49 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

type Point struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
}

type Triangle struct {
	P1 Point `json:"p1"`
	P2 Point `json:"p2"`
	P3 Point `json:"p3"`
}

func fmt1(f float64) string {
	var s string = fmt.Sprint(f)
	var idx int = strings.Index(s, ".")
	if idx < 0 {
		s = (s + ".0")
	} else {
		var need int = (idx + 2)
		if len(s) > need {
			s = _substr(s, 0, need)
		} else {
			for len(s) < need {
				s = (s + "0")
			}
		}
	}
	return s
}

func pointStr(p Point) string {
	return (((("(" + fmt1(p.X)) + ", ") + fmt1(p.Y)) + ")")
}

func triangleStr(t Triangle) string {
	return ((((("Triangle " + pointStr(t.P1)) + ", ") + pointStr(t.P2)) + ", ") + pointStr(t.P3))
}

func orient(a Point, b Point, c Point) float64 {
	return (((b.X - a.X) * (c.Y - a.Y)) - ((b.Y - a.Y) * (c.X - a.X)))
}

func pointInTri(p Point, t Triangle, onBoundary bool) bool {
	var d1 float64 = orient(p, t.P1, t.P2)
	var d2 float64 = orient(p, t.P2, t.P3)
	var d3 float64 = orient(p, t.P3, t.P1)
	var hasNeg bool = (((d1 < 0.0) || (d2 < 0.0)) || (d3 < 0.0))
	var hasPos bool = (((d1 > 0.0) || (d2 > 0.0)) || (d3 > 0.0))
	if onBoundary {
		return !(hasNeg && hasPos)
	}
	return (((!(hasNeg && hasPos) && (d1 != 0.0)) && (d2 != 0.0)) && (d3 != 0.0))
}

func edgeCheck(a0 Point, a1 Point, bs []Point, onBoundary bool) bool {
	var d0 float64 = orient(a0, a1, bs[0])
	var d1 float64 = orient(a0, a1, bs[1])
	var d2 float64 = orient(a0, a1, bs[2])
	if onBoundary {
		return (((d0 <= 0.0) && (d1 <= 0.0)) && (d2 <= 0.0))
	}
	return (((d0 < 0.0) && (d1 < 0.0)) && (d2 < 0.0))
}

func triTri2D(t1 Triangle, t2 Triangle, onBoundary bool) bool {
	var a []Point = []Point{t1.P1, t1.P2, t1.P3}
	var b []Point = []Point{t2.P1, t2.P2, t2.P3}
	var i int = 0
	for i < 3 {
		var j int = ((i + 1) % 3)
		if edgeCheck(a[i], a[j], func(v any) []Point {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Point); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Point{}
				}
				out := make([]Point, len(arr))
				for i, x := range arr {
					out[i] = x.(Point)
				}
				return out
			}
			return v.([]Point)
		}(b), onBoundary) {
			return false
		}
		i = (i + 1)
	}
	i = 0
	for i < 3 {
		var j int = ((i + 1) % 3)
		if edgeCheck(b[i], b[j], func(v any) []Point {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Point); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Point{}
				}
				out := make([]Point, len(arr))
				for i, x := range arr {
					out[i] = x.(Point)
				}
				return out
			}
			return v.([]Point)
		}(a), onBoundary) {
			return false
		}
		i = (i + 1)
	}
	return true
}

func iff(cond bool, a string, b string) string {
	if cond {
		return a
	} else {
		return b
	}
}

func mochiMain() {
	var t1 Triangle = Triangle{
		P1: Point{
			X: 0.0,
			Y: 0.0,
		},
		P2: Point{
			X: 5.0,
			Y: 0.0,
		},
		P3: Point{
			X: 0.0,
			Y: 5.0,
		},
	}
	var t2 Triangle = Triangle{
		P1: Point{
			X: 0.0,
			Y: 0.0,
		},
		P2: Point{
			X: 5.0,
			Y: 0.0,
		},
		P3: Point{
			X: 0.0,
			Y: 6.0,
		},
	}
	fmt.Println((triangleStr(t1) + " and"))
	fmt.Println(triangleStr(t2))
	var overlapping bool = triTri2D(t1, t2, true)
	fmt.Println(iff(overlapping, "overlap", "do not overlap"))
	fmt.Println("")
	t1 = Triangle{
		P1: Point{
			X: 0.0,
			Y: 0.0,
		},
		P2: Point{
			X: 0.0,
			Y: 5.0,
		},
		P3: Point{
			X: 5.0,
			Y: 0.0,
		},
	}
	t2 = t1
	fmt.Println((triangleStr(t1) + " and"))
	fmt.Println(triangleStr(t2))
	overlapping = triTri2D(t1, t2, true)
	fmt.Println(iff(overlapping, "overlap (reversed)", "do not overlap"))
	fmt.Println("")
	t1 = Triangle{
		P1: Point{
			X: 0.0,
			Y: 0.0,
		},
		P2: Point{
			X: 5.0,
			Y: 0.0,
		},
		P3: Point{
			X: 0.0,
			Y: 5.0,
		},
	}
	t2 = Triangle{
		P1: Point{
			X: (0 - 10.0),
			Y: 0.0,
		},
		P2: Point{
			X: (0 - 5.0),
			Y: 0.0,
		},
		P3: Point{
			X: (0 - 1.0),
			Y: 6.0,
		},
	}
	fmt.Println((triangleStr(t1) + " and"))
	fmt.Println(triangleStr(t2))
	overlapping = triTri2D(t1, t2, true)
	fmt.Println(iff(overlapping, "overlap", "do not overlap"))
	fmt.Println("")
	t1.P3 = Point{
		X: 2.5,
		Y: 5.0,
	}
	t2 = Triangle{
		P1: Point{
			X: 0.0,
			Y: 4.0,
		},
		P2: Point{
			X: 2.5,
			Y: (0 - 1.0),
		},
		P3: Point{
			X: 5.0,
			Y: 4.0,
		},
	}
	fmt.Println((triangleStr(t1) + " and"))
	fmt.Println(triangleStr(t2))
	overlapping = triTri2D(t1, t2, true)
	fmt.Println(iff(overlapping, "overlap", "do not overlap"))
	fmt.Println("")
	t1 = Triangle{
		P1: Point{
			X: 0.0,
			Y: 0.0,
		},
		P2: Point{
			X: 1.0,
			Y: 1.0,
		},
		P3: Point{
			X: 0.0,
			Y: 2.0,
		},
	}
	t2 = Triangle{
		P1: Point{
			X: 2.0,
			Y: 1.0,
		},
		P2: Point{
			X: 3.0,
			Y: 0.0,
		},
		P3: Point{
			X: 3.0,
			Y: 2.0,
		},
	}
	fmt.Println((triangleStr(t1) + " and"))
	fmt.Println(triangleStr(t2))
	overlapping = triTri2D(t1, t2, true)
	fmt.Println(iff(overlapping, "overlap", "do not overlap"))
	fmt.Println("")
	t2 = Triangle{
		P1: Point{
			X: 2.0,
			Y: 1.0,
		},
		P2: Point{
			X: 3.0,
			Y: (0 - 2.0),
		},
		P3: Point{
			X: 3.0,
			Y: 4.0,
		},
	}
	fmt.Println((triangleStr(t1) + " and"))
	fmt.Println(triangleStr(t2))
	overlapping = triTri2D(t1, t2, true)
	fmt.Println(iff(overlapping, "overlap", "do not overlap"))
	fmt.Println("")
	t1 = Triangle{
		P1: Point{
			X: 0.0,
			Y: 0.0,
		},
		P2: Point{
			X: 1.0,
			Y: 0.0,
		},
		P3: Point{
			X: 0.0,
			Y: 1.0,
		},
	}
	t2 = Triangle{
		P1: Point{
			X: 1.0,
			Y: 0.0,
		},
		P2: Point{
			X: 2.0,
			Y: 0.0,
		},
		P3: Point{
			X: 1.0,
			Y: 1.1,
		},
	}
	fmt.Println((triangleStr(t1) + " and"))
	fmt.Println(triangleStr(t2))
	fmt.Println("which have only a single corner in contact, if boundary points collide")
	overlapping = triTri2D(t1, t2, true)
	fmt.Println(iff(overlapping, "overlap", "do not overlap"))
	fmt.Println("")
	fmt.Println((triangleStr(t1) + " and"))
	fmt.Println(triangleStr(t2))
	fmt.Println("which have only a single corner in contact, if boundary points do not collide")
	overlapping = triTri2D(t1, t2, false)
	fmt.Println(iff(overlapping, "overlap", "do not overlap"))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
