//go:build ignore

// Generated by Mochi v0.10.37 on 2025-07-23 11:44:29 GMT+7
package main

import (
	"fmt"
	"os"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var OP_NUM int = 0

var OP_ADD int = 1

var OP_SUB int = 2

var OP_MUL int = 3

var OP_DIV int = 4

func newNum(n int) map[string]any {
	return map[string]any{"op": OP_NUM, "value": map[string]int{"num": n, "denom": 1}}
}

func exprEval(x map[string]any) map[string]int {
	if x["op"].(int) == OP_NUM {
		return x["value"].(map[string]int)
	}
	var l map[string]int = exprEval(x["left"].(map[string]any))
	var r map[string]int = exprEval(x["right"].(map[string]any))
	if x["op"].(int) == OP_ADD {
		return map[string]int{"num": ((l["num"] * r["denom"]) + (l["denom"] * r["num"])), "denom": (l["denom"] * r["denom"])}
	}
	if x["op"].(int) == OP_SUB {
		return map[string]int{"num": ((l["num"] * r["denom"]) - (l["denom"] * r["num"])), "denom": (l["denom"] * r["denom"])}
	}
	if x["op"].(int) == OP_MUL {
		return map[string]int{"num": (l["num"] * r["num"]), "denom": (l["denom"] * r["denom"])}
	}
	return map[string]int{"num": (l["num"] * r["denom"]), "denom": (l["denom"] * r["num"])}
}

func exprString(x map[string]any) string {
	if x["op"].(int) == OP_NUM {
		return fmt.Sprint(x["value"].(map[string]int)["num"])
	}
	var ls string = exprString(x["left"].(map[string]any))
	var rs string = exprString(x["right"].(map[string]any))
	var opstr string = ""
	if x["op"].(int) == OP_ADD {
		opstr = " + "
	} else {
		if x["op"].(int) == OP_SUB {
			opstr = " - "
		} else {
			if x["op"].(int) == OP_MUL {
				opstr = " * "
			} else {
				opstr = " / "
			}
		}
	}
	return (((("(" + ls) + opstr) + rs) + ")")
}

var n_cards int = 4

var goal int = 24

var digit_range int = 9

func solve(xs []map[string]any) bool {
	if len(xs) == 1 {
		var f map[string]int = exprEval(xs[0])
		if (f["denom"] != 0) && (f["num"] == (f["denom"] * goal)) {
			fmt.Println(exprString(xs[0]))
			return true
		}
		return false
	}
	var i int = 0
	for i < len(xs) {
		var j int = (i + 1)
		for j < len(xs) {
			var rest []map[string]any = []map[string]any{}
			var k int = 0
			for k < len(xs) {
				if (k != i) && (k != j) {
					rest = append(rest, xs[k])
				}
				k = (k + 1)
			}
			var a map[string]any = xs[i]
			var b map[string]any = xs[j]
			for _, op := range []int{OP_ADD, OP_SUB, OP_MUL, OP_DIV} {
				node := map[string]any{"op": op, "left": a, "right": b}
				if solve(append(rest, node)) {
					return true
				}
			}
			node := map[string]any{"op": OP_SUB, "left": b, "right": a}
			if solve(append(rest, node)) {
				return true
			}
			node = map[string]any{"op": OP_DIV, "left": b, "right": a}
			if solve(append(rest, node)) {
				return true
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return false
}

func mochiMain() {
	var iter int = 0
	for iter < 10 {
		var cards []map[string]any = []map[string]any{}
		var i int = 0
		for i < n_cards {
			var n int = ((_now() % (digit_range - 1)) + 1)
			cards = append(cards, newNum(n))
			fmt.Println((" " + fmt.Sprint(n)))
			i = (i + 1)
		}
		fmt.Println(":  ")
		if !solve(cards) {
			fmt.Println("No solution")
		}
		iter = (iter + 1)
	}
}

func main() {
	mochiMain()
}
