//go:build ignore

// Generated by Mochi v0.10.38 on 2025-07-24 08:09:31 GMT+7
package main

import (
	"fmt"
	"os"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Rational struct {
	Num   int `json:"num"`
	Denom int `json:"denom"`
}

var OP_ADD int

var OP_SUB int

var OP_MUL int

var OP_DIV int

type Expr interface{ isExpr() }
type Num struct {
	Value Rational `json:"value"`
}

func (Num) isExpr() {}

type Bin struct {
	Op    int `json:"op"`
	Left  any `json:"left"`
	Right any `json:"right"`
}

func (Bin) isExpr() {}

func binEval(op int, l any, r any) Rational {
	var lv Rational = exprEval(l)
	_ = lv
	var rv Rational = exprEval(r)
	_ = rv
	if op == OP_ADD {
		return Rational{
			Num:   ((lv.Num * rv.Denom) + (lv.Denom * rv.Num)),
			Denom: (lv.Denom * rv.Denom),
		}
	}
	if op == OP_SUB {
		return Rational{
			Num:   ((lv.Num * rv.Denom) - (lv.Denom * rv.Num)),
			Denom: (lv.Denom * rv.Denom),
		}
	}
	if op == OP_MUL {
		return Rational{
			Num:   (lv.Num * rv.Num),
			Denom: (lv.Denom * rv.Denom),
		}
	}
	return Rational{
		Num:   (lv.Num * rv.Denom),
		Denom: (lv.Denom * rv.Num),
	}
}

func binString(op int, l any, r any) string {
	var ls string = exprString(l)
	_ = ls
	var rs string = exprString(r)
	_ = rs
	var opstr string = ""
	_ = opstr
	if op == OP_ADD {
		opstr = " + "
	} else {
		if op == OP_SUB {
			opstr = " - "
		} else {
			if op == OP_MUL {
				opstr = " * "
			} else {
				opstr = " / "
			}
		}
	}
	return (((("(" + ls) + opstr) + rs) + ")")
}

func newNum(n int) any {
	return Num{
		Value: Rational{
			Num:   n,
			Denom: 1,
		},
	}
}

func exprEval(x any) Rational {
	return func() Rational {
		switch uv := x.(type) {
		case Num:
			v := uv.Value
			return v
		case Bin:
			op := uv.Op
			l := uv.Left
			r := uv.Right
			return binEval(op, l, r)
		default:
			var z Rational
			return z
		}
	}()
}

func exprString(x any) string {
	return func() string {
		switch uv := x.(type) {
		case Num:
			v := uv.Value
			return fmt.Sprint(v.Num)
		case Bin:
			op := uv.Op
			l := uv.Left
			r := uv.Right
			return binString(op, l, r)
		default:
			var z string
			return z
		}
	}()
}

var n_cards int

var goal int

var digit_range int

func solve(xs []any) bool {
	if len(xs) == 1 {
		var f Rational = exprEval(xs[0])
		_ = f
		if (f.Denom != 0) && (f.Num == (f.Denom * goal)) {
			fmt.Println(exprString(xs[0]))
			return true
		}
		return false
	}
	var i int = 0
	_ = i
	for i < len(xs) {
		var j int = (i + 1)
		_ = j
		for j < len(xs) {
			var rest []any = []any{}
			_ = rest
			var k int = 0
			_ = k
			for k < len(xs) {
				if (k != i) && (k != j) {
					rest = append(rest, xs[k])
				}
				k = (k + 1)
			}
			var a any = xs[i]
			_ = a
			var b any = xs[j]
			_ = b
			var node Bin = Bin{
				Op:    OP_ADD,
				Left:  a,
				Right: b,
			}
			_ = node
			for _, op := range []int{OP_ADD, OP_SUB, OP_MUL, OP_DIV} {
				node = Bin{
					Op:    op,
					Left:  a,
					Right: b,
				}
				if solve(append(rest, node)) {
					return true
				}
			}
			node = Bin{
				Op:    OP_SUB,
				Left:  b,
				Right: a,
			}
			if solve(append(rest, node)) {
				return true
			}
			node = Bin{
				Op:    OP_DIV,
				Left:  b,
				Right: a,
			}
			if solve(append(rest, node)) {
				return true
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return false
}

func mochiMain() {
	var iter int = 0
	_ = iter
	for iter < 10 {
		var cards []any = []any{}
		_ = cards
		var i int = 0
		_ = i
		for i < n_cards {
			var n int = ((_now() % (digit_range - 1)) + 1)
			_ = n
			cards = append(cards, newNum(n))
			fmt.Println((" " + fmt.Sprint(n)))
			i = (i + 1)
		}
		fmt.Println(":  ")
		if !solve(cards) {
			fmt.Println("No solution")
		}
		iter = (iter + 1)
	}
}

func main() {
	OP_ADD = 1
	OP_SUB = 2
	OP_MUL = 3
	OP_DIV = 4
	n_cards = 4
	goal = 24
	digit_range = 9
	mochiMain()
}
