//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 23:54:28 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _split(s, sep string) []string {
	if sep == "" {
		sep = " "
	}
	return strings.Split(s, sep)
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

func split(s string, sep string) []string {
	var parts []string = []string{}
	_ = parts
	var cur string = ""
	_ = cur
	var i int = 0
	_ = i
	for i < len(s) {
		if ((len(sep) > 0) && ((i + len(sep)) <= len(s))) && (_substr(s, i, (i+len(sep))) == sep) {
			parts = append(parts, cur)
			cur = ""
			i = (i + len(sep))
		} else {
			cur = (cur + _substr(s, i, (i+1)))
			i = (i + 1)
		}
	}
	parts = append(parts, cur)
	return parts
}

func trimSpace(s string) string {
	var start int = 0
	_ = start
	for (start < len(s)) && ((string([]rune(s)[start:(start+1)]) == " ") || (string([]rune(s)[start:(start+1)]) == "\t")) {
		start = (start + 1)
	}
	var end int = len(s)
	_ = end
	for (end > start) && ((string([]rune(s)[(end-1):end]) == " ") || (string([]rune(s)[(end-1):end]) == "\t")) {
		end = (end - 1)
	}
	return string([]rune(s)[start:end])
}

func indexOfSub(s string, sub string) int {
	if len(sub) == 0 {
		return 0
	}
	var i int = 0
	_ = i
	for (i + len(sub)) <= len(s) {
		if _substr(s, i, (i+len(sub))) == sub {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func parseRules(rs string) map[string]any {
	var rules []map[string]any = []map[string]any{}
	_ = rules
	for _, _ch := range _split(rs, "\n") {
		line := string(_ch)
		var ln string = line
		_ = ln
		var hash int = indexOfSub(ln, "#")
		_ = hash
		if hash >= 0 {
			ln = string([]rune(ln)[:hash])
		}
		ln = trimSpace(ln)
		if len(ln) == 0 {
			continue
		}
		var arrow int = (0 - 1)
		_ = arrow
		var j int = 0
		_ = j
		for (j + 2) <= len(ln) {
			if _substr(ln, j, (j+2)) == "->" {
				var pre bool = ((j > 0) && ((string([]rune(ln)[(j-1):j]) == " ") || (string([]rune(ln)[(j-1):j]) == "\t")))
				_ = pre
				var post bool = (((j + 2) < len(ln)) && ((string([]rune(ln)[(j+2):(j+3)]) == " ") || (string([]rune(ln)[(j+2):(j+3)]) == "\t")))
				_ = post
				if pre && post {
					arrow = j
					break
				}
			}
			j = (j + 1)
		}
		if arrow < 0 {
			arrow = indexOfSub(ln, "->")
		}
		if arrow < 0 {
			return map[string]any{"ok": false}
		}
		var pat string = trimSpace(string([]rune(ln)[:arrow]))
		_ = pat
		var rest string = trimSpace(string([]rune(ln)[(arrow + 2):len(ln)]))
		_ = rest
		var term bool = false
		_ = term
		if (len(rest) > 0) && (string([]rune(rest)[0:1]) == ".") {
			term = true
			rest = string([]rune(rest)[1:len(rest)])
		}
		var rep string = rest
		_ = rep
		rules = append(rules, map[string]any{"pat": pat, "rep": rep, "term": term})
	}
	return map[string]any{"ok": true, "rules": rules}
}

func runRules(rules []map[string]any, s string) string {
	var changed bool = true
	_ = changed
	for changed {
		changed = false
		var i int = 0
		_ = i
		for i < len(rules) {
			var r map[string]any = rules[i]
			_ = r
			var pat string = r["pat"].(string)
			_ = pat
			var rep string = r["rep"].(string)
			_ = rep
			var term bool = r["term"].(bool)
			_ = term
			var idx int = indexOfSub(s, pat)
			_ = idx
			if idx >= 0 {
				s = ((string([]rune(s)[:idx]) + rep) + string([]rune(s)[(idx+len(pat)):]))
				changed = true
				if term {
					return s
				}
				break
			}
			i = (i + 1)
		}
	}
	return s
}

func interpret(ruleset string, input string) map[string]any {
	var p map[string]any = parseRules(ruleset)
	_ = p
	if !p["ok"].(bool) {
		return map[string]any{"ok": false, "out": ""}
	}
	var out string = runRules(func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}(func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}(func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}(p["rules"]))), input)
	_ = out
	_ = out
	return map[string]any{"ok": true, "out": out}
}

var testSet []map[string]string

func mochiMain() {
	fmt.Println((("validating " + fmt.Sprint(len(testSet))) + " test cases"))
	var failures bool = false
	_ = failures
	var i int = 0
	_ = i
	for i < len(testSet) {
		var tc map[string]string = testSet[i]
		_ = tc
		var res map[string]any = interpret(tc["ruleSet"], tc["sample"])
		_ = res
		if !res["ok"].(bool) {
			fmt.Println((("test " + fmt.Sprint((i + 1))) + " invalid ruleset"))
			failures = true
		} else {
			if _toFloat(res["out"].(string)) != tc["output"] {
				fmt.Println(((fmt.Sprint(((("test " + fmt.Sprint((i + 1))) + ": got ") + fmt.Sprint(res["out"].(string)))) + ", want ") + tc["output"]))
				failures = true
			}
		}
		i = (i + 1)
	}
	if !failures {
		fmt.Println("no failures")
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		testSet = []map[string]string{map[string]string{"ruleSet": "# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As from T S.", "output": "I bought a bag of apples from my brother."}, map[string]string{"ruleSet": "# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As from T S.", "output": "I bought a bag of apples from T shop."}, map[string]string{"ruleSet": "# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As W my Bgage from T S.", "output": "I bought a bag of apples with my money from T shop."}, map[string]string{"ruleSet": "### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n", "sample": "_1111*11111_", "output": "11111111111111111111"}, map[string]string{"ruleSet": "# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n", "sample": "000000A000000", "output": "00011H1111000"}}
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
