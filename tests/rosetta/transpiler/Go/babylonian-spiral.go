//go:build ignore

// Generated by Mochi v0.10.52 on 2025-08-02 01:03:40 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func push(h []map[string]int, it map[string]int) []map[string]int {
	h = append(h, it)
	var i int = (len(h) - 1)
	_ = i
	for (i > 0) && (h[(i - 1)]["s"] > h[i]["s"]) {
		var tmp map[string]int = h[(i - 1)]
		_ = tmp
		h[(i - 1)] = h[i]
		h[i] = tmp
		i = (i - 1)
	}
	return h
}

func step(h []map[string]int, nv int, dir []int) map[string]any {
	for (len(h) == 0) || ((nv * nv) <= h[0]["s"]) {
		h = push(func(v any) []map[string]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]map[string]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []map[string]int{}
				}
				out := make([]map[string]int, len(arr))
				for i, x := range arr {
					out[i] = x.(map[string]int)
				}
				return out
			}
			return v.([]map[string]int)
		}(h), map[string]int{"s": (nv * nv), "a": nv, "b": 0})
		nv = (nv + 1)
	}
	var s int = h[0]["s"]
	_ = s
	var v [][]int = [][]int{}
	_ = v
	for (len(h) > 0) && (h[0]["s"] == s) {
		var it map[string]int = h[0]
		_ = it
		h = h[1:]
		v = append(v, []int{it["a"], it["b"]})
		if it["a"] > it["b"] {
			h = push(func(v any) []map[string]int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]map[string]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []map[string]int{}
					}
					out := make([]map[string]int, len(arr))
					for i, x := range arr {
						out[i] = x.(map[string]int)
					}
					return out
				}
				return v.([]map[string]int)
			}(h), map[string]int{"s": ((it["a"] * it["a"]) + ((it["b"] + 1) * (it["b"] + 1))), "a": it["a"], "b": (it["b"] + 1)})
		}
	}
	var list [][]int = [][]int{}
	_ = list
	for _, p := range v {
		list = append(list, p)
	}
	var temp [][]int = list
	_ = temp
	for _, p := range temp {
		if p[0] != p[1] {
			list = append(list, []int{p[1], p[0]})
		}
	}
	temp = list
	for _, p := range temp {
		if p[1] != 0 {
			list = append(list, []int{p[0], (0 - p[1])})
		}
	}
	temp = list
	for _, p := range temp {
		if p[0] != 0 {
			list = append(list, []int{(0 - p[0]), p[1]})
		}
	}
	var bestDot int = (0 - 999999999)
	_ = bestDot
	var best []int = dir
	_ = best
	for _, p := range list {
		var cross int = ((p[0] * dir[1]) - (p[1] * dir[0]))
		_ = cross
		if cross >= 0 {
			var dot int = ((p[0] * dir[0]) + (p[1] * dir[1]))
			_ = dot
			if dot > bestDot {
				bestDot = dot
				best = p
			}
		}
	}
	return func(v any) map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.(map[string]any); ok {
			return vv
		}
		return nil
	}(map[string]any{"d": best, "heap": h, "n": nv})
}

func positions(n int) [][]int {
	var pos [][]int = [][]int{}
	_ = pos
	var x int = 0
	_ = x
	var y int = 0
	_ = y
	var dir []int = []int{0, 1}
	_ = dir
	var heap []map[string]int = []map[string]int{}
	_ = heap
	var nv int = 1
	_ = nv
	var i int = 0
	_ = i
	for i < n {
		pos = append(pos, []int{x, y})
		var st map[string]any = step(func(v any) []map[string]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]map[string]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []map[string]int{}
				}
				out := make([]map[string]int, len(arr))
				for i, x := range arr {
					out[i] = x.(map[string]int)
				}
				return out
			}
			return v.([]map[string]int)
		}(heap), nv, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(dir))
		_ = st
		dir = func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(st["d"])
		heap = func(v any) []map[string]int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]map[string]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []map[string]int{}
				}
				out := make([]map[string]int, len(arr))
				for i, x := range arr {
					out[i] = x.(map[string]int)
				}
				return out
			}
			return v.([]map[string]int)
		}(st["heap"])
		nv = st["n"].(int)
		x = (x + dir[0])
		y = (y + dir[1])
		i = (i + 1)
	}
	return pos
}

func pad(s string, w int) string {
	var r string = s
	_ = r
	for len(r) < w {
		r = (r + " ")
	}
	return r
}

func mochiMain() {
	var pts [][]int = positions(40)
	_ = pts
	fmt.Println("The first 40 Babylonian spiral points are:")
	var line string = ""
	_ = line
	var i int = 0
	_ = i
	for i < len(pts) {
		var p []int = pts[i]
		_ = p
		var s string = pad((((("(" + fmt.Sprint(p[0])) + ", ") + fmt.Sprint(p[1])) + ")"), 10)
		_ = s
		line = (line + s)
		if ((i + 1) % 10) == 0 {
			fmt.Println(line)
			line = ""
		}
		i = (i + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
