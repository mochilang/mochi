//go:build ignore

// Generated by Mochi v0.10.39 on 2025-07-24 15:21:17 GMT+7
package main

import (
	"fmt"
)

func push(h []map[string]int, it map[string]int) []map[string]int {
	h = append(h, it)
	var i int = (len(h) - 1)
	_ = i
	for (i > 0) && (h[(i - 1)]["s"] > h[i]["s"]) {
		var tmp map[string]int = h[(i - 1)]
		_ = tmp
		h[(i - 1)] = h[i]
		h[i] = tmp
		i = (i - 1)
	}
	return h
}

func step(h []map[string]int, nv int, dir []int) map[string]any {
	for (len(h) == 0) || ((nv * nv) <= h[0]["s"]) {
		h = push(h, map[string]int{"s": (nv * nv), "a": nv, "b": 0})
		nv = (nv + 1)
	}
	var s int = h[0]["s"]
	_ = s
	var v [][]int = [][]int{}
	_ = v
	for (len(h) > 0) && (h[0]["s"] == s) {
		var it map[string]int = h[0]
		_ = it
		h = h[1:]
		v = append(v, []int{it["a"], it["b"]})
		if it["a"] > it["b"] {
			h = push(h, map[string]int{"s": ((it["a"] * it["a"]) + ((it["b"] + 1) * (it["b"] + 1))), "a": it["a"], "b": (it["b"] + 1)})
		}
	}
	var list [][]int = [][]int{}
	_ = list
	for _, p := range v {
		list = append(list, p)
	}
	var temp [][]int = list
	_ = temp
	for _, p := range temp {
		if p[0] != p[1] {
			list = append(list, []int{p[1], p[0]})
		}
	}
	temp = list
	for _, p := range temp {
		if p[1] != 0 {
			list = append(list, []int{p[0], (0 - p[1])})
		}
	}
	temp = list
	for _, p := range temp {
		if p[0] != 0 {
			list = append(list, []int{(0 - p[0]), p[1]})
		}
	}
	var bestDot int = (0 - 999999999)
	_ = bestDot
	var best []int = dir
	_ = best
	for _, p := range list {
		var cross int = ((p[0] * dir[1]) - (p[1] * dir[0]))
		_ = cross
		if cross >= 0 {
			var dot int = ((p[0] * dir[0]) + (p[1] * dir[1]))
			_ = dot
			if dot > bestDot {
				bestDot = dot
				best = p
			}
		}
	}
	return map[string]any{"d": best, "heap": h, "n": nv}
}

func positions(n int) [][]int {
	var pos [][]int = [][]int{}
	_ = pos
	var x int = 0
	_ = x
	var y int = 0
	_ = y
	var dir []int = []int{0, 1}
	_ = dir
	var heap []map[string]int = []map[string]int{}
	_ = heap
	var nv int = 1
	_ = nv
	var i int = 0
	_ = i
	for i < n {
		pos = append(pos, []int{x, y})
		var st map[string]any = step(heap, nv, dir)
		_ = st
		dir = st["d"].([]int)
		heap = st["heap"].([]map[string]int)
		nv = st["n"].(int)
		x = (x + dir[0])
		y = (y + dir[1])
		i = (i + 1)
	}
	return pos
}

func pad(s string, w int) string {
	var r string = s
	_ = r
	for len(r) < w {
		r = (r + " ")
	}
	return r
}

func mochiMain() {
	var pts [][]int = positions(40)
	_ = pts
	fmt.Println("The first 40 Babylonian spiral points are:")
	var line string = ""
	_ = line
	var i int = 0
	_ = i
	for i < len(pts) {
		var p []int = pts[i]
		_ = p
		var s string = pad((((("(" + fmt.Sprint(p[0])) + ", ") + fmt.Sprint(p[1])) + ")"), 10)
		_ = s
		line = (line + s)
		if ((i + 1) % 10) == 0 {
			fmt.Println(line)
			line = ""
		}
		i = (i + 1)
	}
}

func main() {
	mochiMain()
}
