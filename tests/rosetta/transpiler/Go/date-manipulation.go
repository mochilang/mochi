//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 16:25:37 GMT+7
package main

import (
	"fmt"
	"strconv"
	"strings"
)

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _toFloat(v any) float64 {
	switch t := v.(type) {
	case int:
		return float64(t)
	case int64:
		return float64(t)
	case float64:
		return t
	default:
		return 0
	}
}

func _parseIntStr(s string, base int) int { v, _ := strconv.ParseInt(s, base, 64); return int(v) }

var months map[string]int

func isLeap(y int) bool {
	if (y % 400) == 0 {
		return true
	}
	if (y % 100) == 0 {
		return false
	}
	return ((y % 4) == 0)
}

func daysInMonth(y int, m int) int {
	var feb int = func() int {
		if isLeap(y) {
			return 29
		} else {
			return 28
		}
	}()
	var lengths []int = []int{31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
	return lengths[(m - 1)]
}

func daysBeforeYear(y int) int {
	var days int = 0
	var yy int = 1970
	for yy < y {
		days = (days + 365)
		if isLeap(yy) {
			days = (days + 1)
		}
		yy = (yy + 1)
	}
	return days
}

func daysBeforeMonth(y int, m int) int {
	var days int = 0
	var mm int = 1
	for mm < m {
		days = (days + daysInMonth(y, mm))
		mm = (mm + 1)
	}
	return days
}

func epochSeconds(y int, m int, d int, h int, mi int) int {
	var days int = ((daysBeforeYear(y) + daysBeforeMonth(y, m)) + (d - 1))
	return (((days * 86400) + (h * 3600)) + (mi * 60))
}

func fromEpoch(sec int) []int {
	var days int = (sec / 86400)
	var rem int = (sec % 86400)
	var y int = 1970
	for {
		var dy int = func() int {
			if isLeap(y) {
				return 366
			} else {
				return 365
			}
		}()
		if days >= dy {
			days = (days - dy)
			y = (y + 1)
		} else {
			break
		}
	}
	var m int = 1
	for {
		var dim int = daysInMonth(y, m)
		if days >= dim {
			days = (days - dim)
			m = (m + 1)
		} else {
			break
		}
	}
	var d int = (days + 1)
	var h int = (rem / 3600)
	var mi int = ((rem % 3600) / 60)
	return []int{y, m, d, h, mi}
}

func pad2(n int) string {
	if n < 10 {
		return ("0" + fmt.Sprint(n))
	}
	return fmt.Sprint(n)
}

func absInt(n int) int {
	if n < 0 {
		return (0 - n)
	}
	return n
}

func formatDate(parts []int, offset int, abbr string) string {
	var y int = parts[0]
	var m int = parts[1]
	var d int = parts[2]
	var h int = parts[3]
	var mi int = parts[4]
	var sign string = "+"
	if offset < 0 {
		sign = "-"
	}
	var off int = (absInt(offset) / 60)
	var offh string = pad2((off / 60))
	var offm string = pad2((off % 60))
	return ((((((((((((((fmt.Sprint(y) + "-") + pad2(m)) + "-") + pad2(d)) + " ") + pad2(h)) + ":") + pad2(mi)) + ":00 ") + sign) + offh) + offm) + " ") + abbr)
}

func parseIntStr(str string) int {
	var i int = 0
	var neg bool = false
	if (len(str) > 0) && (_substr(str, 0, 1) == "-") {
		neg = true
		i = 1
	}
	var n int = 0
	var digits map[string]int = map[string]int{"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
	for i < len(str) {
		n = ((n * 10) + digits[_substr(str, i, (i+1))])
		i = (i + 1)
	}
	if neg {
		n = (0 - n)
	}
	return n
}

func indexOf(s string, ch string) int {
	var i int = 0
	for i < len(s) {
		if _substr(s, i, (i+1)) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func parseTime(s string) []int {
	var c int = strings.Index(s, ":")
	var h int = _parseIntStr(_substr(s, 0, c), 10)
	var mi int = _parseIntStr(_substr(s, (c+1), (c+3)), 10)
	var ampm string = _substr(s, (len(s) - 2), len(s))
	var hh int = h
	if (ampm == "pm") && (h != 12) {
		hh = (h + 12)
	}
	if (ampm == "am") && (h == 12) {
		hh = 0
	}
	return []int{hh, mi}
}

func mochiMain() {
	var input string = "March 7 2009 7:30pm EST"
	fmt.Println(("Input:              " + input))
	var parts []any = []any{}
	var cur string = ""
	var i int = 0
	for i < len(input) {
		var ch string = _substr(input, i, (i + 1))
		if ch == " " {
			if len(cur) > 0 {
				parts = append(parts, cur)
				cur = ""
			}
		} else {
			cur = (cur + ch)
		}
		i = (i + 1)
	}
	if len(cur) > 0 {
		parts = append(parts, cur)
	}
	var month int = months[parts[0].(string)]
	var day int = _parseIntStr(parts[1].(string), 10)
	var year int = _parseIntStr(parts[2].(string), 10)
	var tm []int = parseTime(parts[3].(string))
	var hour int = tm[0]
	var minute int = tm[1]
	tz := parts[4]
	zoneOffsets := map[string]int{"EST": (0 - 18000), "EDT": (0 - 14400), "MST": (0 - 25200)}
	var local int = epochSeconds(year, month, day, hour, minute)
	var utc int = (local - _toFloat(zoneOffsets[tz]))
	var utc12 int = (utc + 43200)
	var startDST int = epochSeconds(2009, 3, 8, 7, 0)
	var offEast int = (0 - 18000)
	if utc12 >= startDST {
		offEast = (0 - 14400)
	}
	var eastParts []int = fromEpoch((utc12 + offEast))
	var eastAbbr string = "EST"
	if offEast == (0 - 14400) {
		eastAbbr = "EDT"
	}
	fmt.Println(("+12 hrs:            " + formatDate(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(eastParts), offEast, eastAbbr)))
	var offAZ int = (0 - 25200)
	var azParts []int = fromEpoch((utc12 + offAZ))
	fmt.Println(("+12 hrs in Arizona: " + formatDate(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(azParts), offAZ, "MST")))
}

func main() {
	months = map[string]int{"January": 1, "February": 2, "March": 3, "April": 4, "May": 5, "June": 6, "July": 7, "August": 8, "September": 9, "October": 10, "November": 11, "December": 12}
	mochiMain()
}
