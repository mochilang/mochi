//go:build ignore

// Generated by Mochi v0.10.40 on 2025-07-25 19:43:18 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func sieve(limit int) []int {
	var spf []int = []int{}
	_ = spf
	var i int = 0
	_ = i
	for i <= limit {
		spf = append(spf, 0)
		i = (i + 1)
	}
	i = 2
	for i <= limit {
		if spf[i] == 0 {
			spf[i] = i
			if (i * i) <= limit {
				var j int = (i * i)
				_ = j
				for j <= limit {
					if spf[j] == 0 {
						spf[j] = i
					}
					j = (j + i)
				}
			}
		}
		i = (i + 1)
	}
	return spf
}

func primesFrom(spf []int, limit int) []int {
	var primes []int = []int{}
	_ = primes
	var i int = 3
	_ = i
	for i <= limit {
		if spf[i] == i {
			primes = append(primes, i)
		}
		i = (i + 1)
	}
	return primes
}

func pad3(n int) string {
	var s string = fmt.Sprint(n)
	_ = s
	for len(s) < 3 {
		s = (" " + s)
	}
	return s
}

func commatize(n int) string {
	var s string = fmt.Sprint(n)
	_ = s
	var out string = ""
	_ = out
	var i int = (len(s) - 1)
	_ = i
	var c int = 0
	_ = c
	for i >= 0 {
		out = (_substr(s, i, (i+1)) + out)
		c = (c + 1)
		if ((c % 3) == 0) && (i > 0) {
			out = ("," + out)
		}
		i = (i - 1)
	}
	return out
}

func primeCount(primes []int, last int, spf []int) int {
	var lo int = 0
	_ = lo
	var hi int = len(primes)
	_ = hi
	for lo < hi {
		var mid int = int(((lo + hi) / 2))
		_ = mid
		if primes[mid] < last {
			lo = (mid + 1)
		} else {
			hi = mid
		}
	}
	var count int = (lo + 1)
	_ = count
	if spf[last] != last {
		count = (count - 1)
	}
	return count
}

func arithmeticNumbers(limit int, spf []int) []int {
	var arr []int = []int{1}
	_ = arr
	var n int = 3
	_ = n
	for len(arr) < limit {
		if spf[n] == n {
			arr = append(arr, n)
		} else {
			var x int = n
			_ = x
			var sigma int = 1
			_ = sigma
			var tau int = 1
			_ = tau
			for x > 1 {
				var p int = spf[x]
				_ = p
				if p == 0 {
					p = x
				}
				var cnt int = 0
				_ = cnt
				var power int = p
				_ = power
				var sum int = 1
				_ = sum
				for (x % p) == 0 {
					x = (x / p)
					cnt = (cnt + 1)
					sum = (sum + power)
					power = (power * p)
				}
				sigma = (sigma * sum)
				tau = (tau * (cnt + 1))
			}
			if (sigma % tau) == 0 {
				arr = append(arr, n)
			}
		}
		n = (n + 1)
	}
	return arr
}

func mochiMain() {
	var limit int = 1228663
	_ = limit
	var spf []int = sieve(limit)
	_ = spf
	var primes []int = primesFrom(spf, limit)
	_ = primes
	var arr []int = arithmeticNumbers(1000000, spf)
	_ = arr
	fmt.Println("The first 100 arithmetic numbers are:")
	var i int = 0
	_ = i
	for i < 100 {
		var line string = ""
		_ = line
		var j int = 0
		_ = j
		for j < 10 {
			line = (line + pad3(arr[(i+j)]))
			if j < 9 {
				line = (line + " ")
			}
			j = (j + 1)
		}
		fmt.Println(line)
		i = (i + 10)
	}
	for _, x := range []int{1000, 10000, 100000, 1000000} {
		var last int = arr[(x - 1)]
		_ = last
		var lastc string = commatize(last)
		_ = lastc
		fmt.Println(((("\nThe " + commatize(x)) + "th arithmetic number is: ") + lastc))
		var pc int = primeCount(primes, last, spf)
		_ = pc
		var comp int = ((x - pc) - 1)
		_ = comp
		fmt.Println((((("The count of such numbers <= " + lastc) + " which are composite is ") + commatize(comp)) + "."))
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		start := _now()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		end := _now()
		data := map[string]any{"name": "main", "duration_us": (end - start) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
