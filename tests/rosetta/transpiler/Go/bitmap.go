//go:build ignore

// Generated by Mochi v0.10.52 on 2025-08-02 01:04:16 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Pixel struct {
	R int `json:"R"`
	G int `json:"G"`
	B int `json:"B"`
}

func pixelFromRgb(c int) Pixel {
	var r int = (int((c / 65536)) % 256)
	_ = r
	_ = r
	var g int = (int((c / 256)) % 256)
	_ = g
	_ = g
	var b int = (c % 256)
	_ = b
	_ = b
	return Pixel{
		R: r,
		G: g,
		B: b,
	}
}

func rgbFromPixel(p Pixel) int {
	return (((p.R * 65536) + (p.G * 256)) + p.B)
}

type Bitmap struct {
	Cols int       `json:"cols"`
	Rows int       `json:"rows"`
	Px   [][]Pixel `json:"px"`
}

func NewBitmap(x int, y int) Bitmap {
	var data [][]Pixel = [][]Pixel{}
	_ = data
	var row int = 0
	_ = row
	for row < y {
		var r []Pixel = []Pixel{}
		_ = r
		var col int = 0
		_ = col
		for col < x {
			r = append(r, Pixel{
				R: 0,
				G: 0,
				B: 0,
			})
			col = (col + 1)
		}
		data = append(data, r)
		row = (row + 1)
	}
	return Bitmap{
		Cols: x,
		Rows: y,
		Px:   data,
	}
}

func Extent(b Bitmap) map[string]int {
	return func(v any) map[string]int {
		if v == nil {
			return map[string]int{}
		}
		if vv, ok := v.(map[string]int); ok {
			return vv
		}
		out := make(map[string]int)
		if m, ok := v.(map[string]any); ok {
			for k, vv := range m {
				if vi, ok2 := vv.(int); ok2 {
					out[k] = vi
				}
			}
		}
		return out
	}(map[string]int{"cols": b.Cols, "rows": b.Rows})
}

func Fill(b Bitmap, p Pixel) {
	var y int = 0
	_ = y
	for y < b.Rows {
		var x int = 0
		_ = x
		for x < b.Cols {
			var px [][]Pixel = b.Px
			_ = px
			var row []Pixel = px[y]
			_ = row
			row[x] = p
			px[y] = row
			b.Px = px
			x = (x + 1)
		}
		y = (y + 1)
	}
}

func FillRgb(b Bitmap, c int) {
	Fill(b, pixelFromRgb(c))
}

func SetPx(b Bitmap, x int, y int, p Pixel) bool {
	if (((x < 0) || (x >= b.Cols)) || (y < 0)) || (y >= b.Rows) {
		return false
	}
	var px [][]Pixel = b.Px
	_ = px
	var row []Pixel = px[y]
	_ = row
	row[x] = p
	px[y] = row
	b.Px = px
	return true
}

func SetPxRgb(b Bitmap, x int, y int, c int) bool {
	return SetPx(b, x, y, pixelFromRgb(c))
}

func GetPx(b Bitmap, x int, y int) map[string]any {
	if (((x < 0) || (x >= b.Cols)) || (y < 0)) || (y >= b.Rows) {
		return func(v any) map[string]any {
			if v == nil {
				return nil
			}
			if vv, ok := v.(map[string]any); ok {
				return vv
			}
			return nil
		}(map[string]any{"ok": false})
	}
	var row []Pixel = b.Px[y]
	_ = row
	_ = row
	return func(v any) map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.(map[string]any); ok {
			return vv
		}
		return nil
	}(map[string]any{"ok": true, "pixel": row[x]})
}

func GetPxRgb(b Bitmap, x int, y int) map[string]any {
	var r map[string]any = GetPx(b, x, y)
	_ = r
	if !r["ok"].(bool) {
		return func(v any) map[string]any {
			if v == nil {
				return nil
			}
			if vv, ok := v.(map[string]any); ok {
				return vv
			}
			return nil
		}(map[string]any{"ok": false})
	}
	return func(v any) map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.(map[string]any); ok {
			return vv
		}
		return nil
	}(map[string]any{"ok": true, "rgb": rgbFromPixel(r["pixel"].(Pixel))})
}

func ppmSize(b Bitmap) int {
	var header string = (((("P6\n# Creator: Rosetta Code http://rosettacode.org/\n" + fmt.Sprint(b.Cols)) + " ") + fmt.Sprint(b.Rows)) + "\n255\n")
	_ = header
	_ = header
	return (len(header) + ((3 * b.Cols) * b.Rows))
}

func pixelStr(p Pixel) string {
	return (((((("{" + fmt.Sprint(p.R)) + " ") + fmt.Sprint(p.G)) + " ") + fmt.Sprint(p.B)) + "}")
}

func mochiMain() {
	var bm Bitmap = NewBitmap(300, 240)
	_ = bm
	FillRgb(bm, 16711680)
	SetPxRgb(bm, 10, 20, 255)
	SetPxRgb(bm, 20, 30, 0)
	SetPxRgb(bm, 30, 40, 1056816)
	var c1 map[string]any = GetPx(bm, 0, 0)
	_ = c1
	var c2 map[string]any = GetPx(bm, 10, 20)
	_ = c2
	var c3 map[string]any = GetPx(bm, 30, 40)
	_ = c3
	fmt.Println(((("Image size: " + fmt.Sprint(bm.Cols)) + " Ã— ") + fmt.Sprint(bm.Rows)))
	fmt.Println((fmt.Sprint(ppmSize(bm)) + " bytes when encoded as PPM."))
	if c1["ok"].(bool) {
		fmt.Println(("Pixel at (0,0) is " + pixelStr(c1["pixel"].(Pixel))))
	}
	if c2["ok"].(bool) {
		fmt.Println(("Pixel at (10,20) is " + pixelStr(c2["pixel"].(Pixel))))
	}
	if c3["ok"].(bool) {
		var p Pixel = c3["pixel"].(Pixel)
		_ = p
		var r16 int = (p.R * 257)
		_ = r16
		var g16 int = (p.G * 257)
		_ = g16
		var b16 int = (p.B * 257)
		_ = b16
		fmt.Println(((((("Pixel at (30,40) has R=" + fmt.Sprint(r16)) + ", G=") + fmt.Sprint(g16)) + ", B=") + fmt.Sprint(b16)))
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
