//go:build ignore

// Generated by Mochi v0.10.40 on 2025-07-25 20:01:28 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func randOrder(seed int, n int) []int {
	var next int = (((seed * 1664525) + 1013904223) % 2147483647)
	_ = next
	return []int{next, (next % n)}
}

func randChaos(seed int, n int) []int {
	var next int = (((seed * 1103515245) + 12345) % 2147483647)
	_ = next
	return []int{next, (next % n)}
}

func mochiMain() {
	var nBuckets int = 10
	_ = nBuckets
	var initialSum int = 1000
	_ = initialSum
	var buckets []int = []int{}
	_ = buckets
	for i := 0; i < nBuckets; i++ {
		buckets = append(buckets, 0)
	}
	var i int = nBuckets
	_ = i
	var dist int = initialSum
	_ = dist
	for i > 0 {
		var v int = (dist / i)
		_ = v
		i = (i - 1)
		buckets[i] = v
		dist = (dist - v)
	}
	var tc0 int = 0
	_ = tc0
	var tc1 int = 0
	_ = tc1
	var total int = 0
	_ = total
	var nTicks int = 0
	_ = nTicks
	var seedOrder int = 1
	_ = seedOrder
	var seedChaos int = 2
	_ = seedChaos
	fmt.Println("sum  ---updates---    mean  buckets")
	var t int = 0
	_ = t
	for t < 5 {
		var r []int = randOrder(seedOrder, nBuckets)
		_ = r
		seedOrder = r[0]
		var b1 int = r[1]
		_ = b1
		var b2 int = ((b1 + 1) % nBuckets)
		_ = b2
		var v1 int = buckets[b1]
		_ = v1
		var v2 int = buckets[b2]
		_ = v2
		if v1 > v2 {
			var a int = int(((v1 - v2) / 2))
			_ = a
			if a > buckets[b1] {
				a = buckets[b1]
			}
			buckets[b1] = (buckets[b1] - a)
			buckets[b2] = (buckets[b2] + a)
		} else {
			var a int = int(((v2 - v1) / 2))
			_ = a
			if a > buckets[b2] {
				a = buckets[b2]
			}
			buckets[b2] = (buckets[b2] - a)
			buckets[b1] = (buckets[b1] + a)
		}
		tc0 = (tc0 + 1)
		r = randChaos(seedChaos, nBuckets)
		seedChaos = r[0]
		b1 = r[1]
		b2 = ((b1 + 1) % nBuckets)
		r = randChaos(seedChaos, (buckets[b1] + 1))
		seedChaos = r[0]
		var amt int = r[1]
		_ = amt
		if amt > buckets[b1] {
			amt = buckets[b1]
		}
		buckets[b1] = (buckets[b1] - amt)
		buckets[b2] = (buckets[b2] + amt)
		tc1 = (tc1 + 1)
		var sum int = 0
		_ = sum
		var idx int = 0
		_ = idx
		for idx < nBuckets {
			sum = (sum + buckets[idx])
			idx = (idx + 1)
		}
		total = ((total + tc0) + tc1)
		nTicks = (nTicks + 1)
		fmt.Println(((((((((fmt.Sprint(sum) + " ") + fmt.Sprint(tc0)) + " ") + fmt.Sprint(tc1)) + " ") + fmt.Sprint((total / nTicks))) + "  ") + fmt.Sprint(buckets)))
		tc0 = 0
		tc1 = 0
		t = (t + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		start := _now()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		end := _now()
		data := map[string]any{"name": "main", "duration_us": (end - start) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
