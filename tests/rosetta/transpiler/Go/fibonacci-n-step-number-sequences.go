//go:build ignore

// Generated by Mochi v0.10.52 on 2025-08-01 19:07:50 GMT+7
package main

import (
	"fmt"
)

func _slice[T any](s []T, start, end int) []T {
	if start < 0 {
		start = 0
	}
	if end > len(s) {
		end = len(s)
	}
	if start > len(s) {
		start = len(s)
	}
	if end < start {
		end = start
	}
	return s[start:end]
}

func show(xs []int) string {
	var s string = ""
	_ = s
	var i int = 0
	_ = i
	for i < len(xs) {
		s = (s + fmt.Sprint(xs[i]))
		if i < (len(xs) - 1) {
			s = (s + " ")
		}
		i = (i + 1)
	}
	return s
}

func gen(init []int, n int) []int {
	var b []int = init
	_ = b
	var res []int = []int{}
	_ = res
	var sum int = 0
	_ = sum
	for _, x := range b {
		res = append(res, x)
		sum = (sum + x)
	}
	for len(res) < n {
		var next int = sum
		_ = next
		res = append(res, next)
		sum = ((sum + next) - b[0])
		b = append(_slice(b, 1, len(b)), next)
	}
	return res
}

func mochiMain() {
	var n int = 10
	_ = n
	fmt.Println((" Fibonacci: " + show(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(gen(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{1, 1}), n)))))
	fmt.Println(("Tribonacci: " + show(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(gen(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{1, 1, 2}), n)))))
	fmt.Println(("Tetranacci: " + show(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(gen(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{1, 1, 2, 4}), n)))))
	fmt.Println(("     Lucas: " + show(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(gen(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}([]int{2, 1}), n)))))
}

func main() {
	mochiMain()
}
