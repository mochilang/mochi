//go:build ignore

// Generated by Mochi v0.10.39 on 2025-07-24 13:25:03 GMT+7
package main

import (
	"fmt"
)

func Node(data int) map[string]any {
	return map[string]any{"Data": data, "Balance": 0, "Link": []any{nil, nil}}
}

func getLink(n map[string]any, dir int) any {
	return n["Link"].([]any)[dir]
}

func setLink(n map[string]any, dir int, v any) {
	var links []any = n["Link"]
	_ = links
	links[dir] = v
	n["Link"] = links
}

func opp(dir int) int {
	return (1 - dir)
}

func single(root map[string]any, dir int) map[string]any {
	tmp := getLink(root, opp(dir))
	_ = tmp
	setLink(root, opp(dir), getLink(tmp.(map[string]any), dir))
	setLink(tmp.(map[string]any), dir, root)
	return tmp.(map[string]any)
}

func double(root map[string]any, dir int) map[string]any {
	tmp := getLink(getLink(root, opp(dir)).(map[string]any), dir)
	_ = tmp
	setLink(getLink(root, opp(dir)).(map[string]any), dir, getLink(tmp.(map[string]any), opp(dir)))
	setLink(tmp.(map[string]any), opp(dir), getLink(root, opp(dir)))
	setLink(root, opp(dir), tmp)
	tmp = getLink(root, opp(dir))
	setLink(root, opp(dir), getLink(tmp.(map[string]any), dir))
	setLink(tmp.(map[string]any), dir, root)
	return tmp.(map[string]any)
}

func adjustBalance(root map[string]any, dir int, bal int) {
	var n map[string]any = getLink(root, dir).(map[string]any)
	_ = n
	var nn map[string]any = getLink(n, opp(dir)).(map[string]any)
	_ = nn
	if nn["Balance"].(int) == 0 {
		root["Balance"] = 0
		n["Balance"] = 0
	} else {
		if nn["Balance"].(int) == bal {
			root["Balance"] = (0 - bal)
			n["Balance"] = 0
		} else {
			root["Balance"] = 0
			n["Balance"] = bal
		}
	}
	nn["Balance"] = 0
}

func insertBalance(root map[string]any, dir int) map[string]any {
	var n map[string]any = getLink(root, dir).(map[string]any)
	_ = n
	var bal int = ((2 * dir) - 1)
	_ = bal
	if n["Balance"].(int) == bal {
		root["Balance"] = 0
		n["Balance"] = 0
		return single(root, opp(dir))
	}
	adjustBalance(root, dir, bal)
	return double(root, opp(dir))
}

func insertR(root any, data int) map[string]any {
	if root == nil {
		return map[string]any{"node": Node(data), "done": false}
	}
	var node map[string]any = root.(map[string]any)
	_ = node
	var dir int = 0
	_ = dir
	if node["Data"] < data {
		dir = 1
	}
	var r map[string]any = insertR(getLink(node, dir), data)
	_ = r
	setLink(node, dir, r["node"])
	if r["done"].(bool) {
		return map[string]any{"node": node, "done": true}
	}
	node["Balance"] = (node["Balance"] + ((2 * dir) - 1))
	if node["Balance"].(int) == 0 {
		return map[string]any{"node": node, "done": true}
	}
	if (node["Balance"].(int) == 1) || (node["Balance"].(int) == (0 - 1)) {
		return map[string]any{"node": node, "done": false}
	}
	return map[string]any{"node": insertBalance(node, dir), "done": true}
}

func Insert(tree any, data int) any {
	var r map[string]any = insertR(tree, data)
	_ = r
	return r["node"]
}

func removeBalance(root map[string]any, dir int) map[string]any {
	var n map[string]any = getLink(root, opp(dir)).(map[string]any)
	_ = n
	var bal int = ((2 * dir) - 1)
	_ = bal
	if n["Balance"].(int) == (0 - bal) {
		root["Balance"] = 0
		n["Balance"] = 0
		return map[string]any{"node": single(root, dir), "done": false}
	}
	if n["Balance"].(int) == bal {
		adjustBalance(root, opp(dir), (0 - bal))
		return map[string]any{"node": double(root, dir), "done": false}
	}
	root["Balance"] = (0 - bal)
	n["Balance"] = bal
	return map[string]any{"node": single(root, dir), "done": true}
}

func removeR(root any, data int) map[string]any {
	if root == nil {
		return map[string]any{"node": nil, "done": false}
	}
	var node map[string]any = root.(map[string]any)
	_ = node
	if node["Data"] == data {
		if getLink(node, 0) == nil {
			return map[string]any{"node": getLink(node, 1), "done": false}
		}
		if getLink(node, 1) == nil {
			return map[string]any{"node": getLink(node, 0), "done": false}
		}
		heir := getLink(node, 0)
		_ = heir
		for getLink(heir.(map[string]any), 1) != nil {
			heir = getLink(heir.(map[string]any), 1)
		}
		node["Data"] = heir.(map[string]any)["Data"].(int)
		data = heir.(map[string]any)["Data"].(int)
	}
	var dir int = 0
	_ = dir
	if node["Data"] < data {
		dir = 1
	}
	var r map[string]any = removeR(getLink(node, dir), data)
	_ = r
	setLink(node, dir, r["node"])
	if r["done"].(bool) {
		return map[string]any{"node": node, "done": true}
	}
	node["Balance"] = ((node["Balance"] + 1) - (2 * dir))
	if (node["Balance"].(int) == 1) || (node["Balance"].(int) == (0 - 1)) {
		return map[string]any{"node": node, "done": true}
	}
	if node["Balance"].(int) == 0 {
		return map[string]any{"node": node, "done": false}
	}
	return removeBalance(node, dir)
}

func Remove(tree any, data int) any {
	var r map[string]any = removeR(tree, data)
	_ = r
	return r["node"]
}

func indentStr(n int) string {
	var s string = ""
	_ = s
	var i int = 0
	_ = i
	for i < n {
		s = (s + " ")
		i = (i + 1)
	}
	return s
}

func dumpNode(node any, indent int, comma bool) {
	var sp string = indentStr(indent)
	_ = sp
	if node == nil {
		var line string = (sp + "null")
		_ = line
		if comma {
			line = (line + ",")
		}
		fmt.Println(line)
	} else {
		fmt.Println((sp + "{"))
		fmt.Println((((indentStr((indent + 3)) + "\"Data\": ") + fmt.Sprint(node.(map[string]any)["Data"].(int))) + ","))
		fmt.Println((((indentStr((indent + 3)) + "\"Balance\": ") + fmt.Sprint(node.(map[string]any)["Balance"].(int))) + ","))
		fmt.Println((indentStr((indent + 3)) + "\"Link\": ["))
		dumpNode(getLink(node.(map[string]any), 0), (indent + 6), true)
		dumpNode(getLink(node.(map[string]any), 1), (indent + 6), false)
		fmt.Println((indentStr((indent + 3)) + "]"))
		var end string = (sp + "}")
		_ = end
		if comma {
			end = (end + ",")
		}
		fmt.Println(end)
	}
}

func dump(node any, indent int) {
	dumpNode(node, indent, false)
}

func mochiMain() {
	var tree any = nil
	_ = tree
	fmt.Println("Empty tree:")
	dump(tree, 0)
	fmt.Println("")
	fmt.Println("Insert test:")
	tree = Insert(tree, 3)
	tree = Insert(tree, 1)
	tree = Insert(tree, 4)
	tree = Insert(tree, 1)
	tree = Insert(tree, 5)
	dump(tree, 0)
	fmt.Println("")
	fmt.Println("Remove test:")
	tree = Remove(tree, 3)
	tree = Remove(tree, 1)
	var t map[string]any = tree.(map[string]any)
	_ = t
	t["Balance"] = 0
	tree = t
	dump(tree, 0)
}

func main() {
	mochiMain()
}
