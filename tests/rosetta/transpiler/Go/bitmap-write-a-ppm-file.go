//go:build ignore

// Generated by Mochi v0.10.40 on 2025-07-25 21:14:56 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Colour struct {
	R int `json:"R"`
	G int `json:"G"`
	B int `json:"B"`
}

type Bitmap struct {
	Width  int        `json:"width"`
	Height int        `json:"height"`
	Pixels [][]Colour `json:"pixels"`
}

func newBitmap(w int, h int, c Colour) Bitmap {
	var rows [][]Colour = [][]Colour{}
	_ = rows
	var y int = 0
	_ = y
	for y < h {
		var row []Colour = []Colour{}
		_ = row
		var x int = 0
		_ = x
		for x < w {
			row = append(row, c)
			x = (x + 1)
		}
		rows = append(rows, row)
		y = (y + 1)
	}
	return Bitmap{
		Width:  w,
		Height: h,
		Pixels: rows,
	}
}

func setPixel(b Bitmap, x int, y int, c Colour) {
	var rows [][]Colour = b.Pixels
	_ = rows
	var row []Colour = rows[y]
	_ = row
	row[x] = c
	rows[y] = row
	b.Pixels = rows
}

func fillRect(b Bitmap, x int, y int, w int, h int, c Colour) {
	var yy int = y
	_ = yy
	for yy < (y + h) {
		var xx int = x
		_ = xx
		for xx < (x + w) {
			setPixel(b, xx, yy, c)
			xx = (xx + 1)
		}
		yy = (yy + 1)
	}
}

func pad(n int, width int) string {
	var s string = fmt.Sprint(n)
	_ = s
	for len(s) < width {
		s = (" " + s)
	}
	return s
}

func writePPMP3(b Bitmap) string {
	var maxv int = 0
	_ = maxv
	var y int = 0
	_ = y
	for y < b.Height {
		var x int = 0
		_ = x
		for x < b.Width {
			var p Colour = b.Pixels[y][x]
			_ = p
			if p.R > maxv {
				maxv = p.R
			}
			if p.G > maxv {
				maxv = p.G
			}
			if p.B > maxv {
				maxv = p.B
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	var out string = (((((("P3\n# generated from Bitmap.writeppmp3\n" + fmt.Sprint(b.Width)) + " ") + fmt.Sprint(b.Height)) + "\n") + fmt.Sprint(maxv)) + "\n")
	_ = out
	var numsize int = len(fmt.Sprint(maxv))
	_ = numsize
	y = (b.Height - 1)
	for y >= 0 {
		var line string = ""
		_ = line
		var x int = 0
		_ = x
		for x < b.Width {
			var p Colour = b.Pixels[y][x]
			_ = p
			line = ((((((line + "   ") + pad(p.R, numsize)) + " ") + pad(p.G, numsize)) + " ") + pad(p.B, numsize))
			x = (x + 1)
		}
		out = (out + line)
		if y > 0 {
			out = (out + "\n")
		} else {
			out = (out + "\n")
		}
		y = (y - 1)
	}
	return out
}

func mochiMain() {
	var black Colour = Colour{
		R: 0,
		G: 0,
		B: 0,
	}
	_ = black
	var white Colour = Colour{
		R: 255,
		G: 255,
		B: 255,
	}
	_ = white
	var bm Bitmap = newBitmap(4, 4, black)
	_ = bm
	fillRect(bm, 1, 0, 1, 2, white)
	setPixel(bm, 3, 3, Colour{
		R: 127,
		G: 0,
		B: 63,
	})
	var ppm string = writePPMP3(bm)
	_ = ppm
	fmt.Println(ppm)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		start := _now()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		end := _now()
		data := map[string]any{"name": "main", "duration_us": (end - start) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
