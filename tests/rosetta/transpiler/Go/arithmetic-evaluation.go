//go:build ignore

// Generated by Mochi v0.10.40 on 2025-07-25 19:42:44 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

type Parser struct {
	Expr string `json:"expr"`
	Pos  int    `json:"pos"`
}

type Res struct {
	V int    `json:"v"`
	P Parser `json:"p"`
}

func skipWS(p Parser) Parser {
	var i int = p.Pos
	_ = i
	for (i < len(p.Expr)) && (_substr(p.Expr, i, (i+1)) == " ") {
		i = (i + 1)
	}
	p.Pos = i
	return p
}

func parseIntStr(str string) int {
	var i int = 0
	_ = i
	var n int = 0
	_ = n
	for i < len(str) {
		n = (((n * 10) + func() int { n, _ := strconv.Atoi(string([]rune(str)[i:(i + 1)])); return n }()) - 48)
		i = (i + 1)
	}
	return n
}

func parseNumber(p Parser) Res {
	p = skipWS(p)
	var start int = p.Pos
	_ = start
	for p.Pos < len(p.Expr) {
		var ch string = _substr(p.Expr, p.Pos, (p.Pos + 1))
		_ = ch
		if (ch >= "0") && (ch <= "9") {
			p.Pos = (p.Pos + 1)
		} else {
			break
		}
	}
	var token string = _substr(p.Expr, start, p.Pos)
	_ = token
	return Res{
		V: parseIntStr(token),
		P: p,
	}
}

func parseFactor(p Parser) Res {
	p = skipWS(p)
	if (p.Pos < len(p.Expr)) && (_substr(p.Expr, p.Pos, (p.Pos+1)) == "(") {
		p.Pos = (p.Pos + 1)
		var r Res = parseExpr(p)
		_ = r
		var v int = r.V
		_ = v
		p = r.P
		p = skipWS(p)
		if (p.Pos < len(p.Expr)) && (_substr(p.Expr, p.Pos, (p.Pos+1)) == ")") {
			p.Pos = (p.Pos + 1)
		}
		return Res{
			V: v,
			P: p,
		}
	}
	if (p.Pos < len(p.Expr)) && (_substr(p.Expr, p.Pos, (p.Pos+1)) == "-") {
		p.Pos = (p.Pos + 1)
		var r Res = parseFactor(p)
		_ = r
		var v int = r.V
		_ = v
		p = r.P
		return Res{
			V: (0 - v),
			P: p,
		}
	}
	return parseNumber(p)
}

func powInt(base int, exp int) int {
	var r int = 1
	_ = r
	var b int = base
	_ = b
	var e int = exp
	_ = e
	for e > 0 {
		if (e % 2) == 1 {
			r = (r * b)
		}
		b = (b * b)
		e = (e / int(2))
	}
	return r
}

func parsePower(p Parser) Res {
	var r Res = parseFactor(p)
	_ = r
	var v int = r.V
	_ = v
	p = r.P
	for {
		p = skipWS(p)
		if (p.Pos < len(p.Expr)) && (_substr(p.Expr, p.Pos, (p.Pos+1)) == "^") {
			p.Pos = (p.Pos + 1)
			var r2 Res = parseFactor(p)
			_ = r2
			var rhs int = r2.V
			_ = rhs
			p = r2.P
			v = powInt(v, rhs)
		} else {
			break
		}
	}
	return Res{
		V: v,
		P: p,
	}
}

func parseTerm(p Parser) Res {
	var r Res = parsePower(p)
	_ = r
	var v int = r.V
	_ = v
	p = r.P
	for {
		p = skipWS(p)
		if p.Pos < len(p.Expr) {
			var op string = _substr(p.Expr, p.Pos, (p.Pos + 1))
			_ = op
			if op == "*" {
				p.Pos = (p.Pos + 1)
				var r2 Res = parsePower(p)
				_ = r2
				var rhs int = r2.V
				_ = rhs
				p = r2.P
				v = (v * rhs)
				continue
			}
			if op == "/" {
				p.Pos = (p.Pos + 1)
				var r2 Res = parsePower(p)
				_ = r2
				var rhs int = r2.V
				_ = rhs
				p = r2.P
				v = (v / int(rhs))
				continue
			}
		}
		break
	}
	return Res{
		V: v,
		P: p,
	}
}

func parseExpr(p Parser) Res {
	var r Res = parseTerm(p)
	_ = r
	var v int = r.V
	_ = v
	p = r.P
	for {
		p = skipWS(p)
		if p.Pos < len(p.Expr) {
			var op string = _substr(p.Expr, p.Pos, (p.Pos + 1))
			_ = op
			if op == "+" {
				p.Pos = (p.Pos + 1)
				var r2 Res = parseTerm(p)
				_ = r2
				var rhs int = r2.V
				_ = rhs
				p = r2.P
				v = (v + rhs)
				continue
			}
			if op == "-" {
				p.Pos = (p.Pos + 1)
				var r2 Res = parseTerm(p)
				_ = r2
				var rhs int = r2.V
				_ = rhs
				p = r2.P
				v = (v - rhs)
				continue
			}
		}
		break
	}
	return Res{
		V: v,
		P: p,
	}
}

func evalExpr(expr string) int {
	var p Parser = Parser{
		Expr: expr,
		Pos:  0,
	}
	_ = p
	var r Res = parseExpr(p)
	_ = r
	return r.V
}

func mochiMain() {
	var expr string = "2*(3-1)+2*5"
	_ = expr
	fmt.Println(((expr + " = ") + fmt.Sprint(evalExpr(expr))))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		start := _now()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		end := _now()
		data := map[string]any{"name": "main", "duration_us": (end - start) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
