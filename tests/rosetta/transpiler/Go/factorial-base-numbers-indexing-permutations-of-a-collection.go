//go:build ignore

// Generated by Mochi v0.10.52 on 2025-08-01 19:11:52 GMT+7
package main

import (
	"fmt"
	"strconv"
	"strings"
)

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _split(s, sep string) []string {
	if sep == "" {
		sep = " "
	}
	return strings.Split(s, sep)
}

func _len(v any) int {
	switch t := v.(type) {
	case string:
		return len([]rune(t))
	case []any:
		return len(t)
	case []string:
		return len(t)
	case []int:
		return len(t)
	case []float64:
		return len(t)
	case map[string]any:
		return len(t)
	case map[int]any:
		return len(t)
	case map[any]any:
		return len(t)
	default:
		return 0
	}
}

func _parseIntStr(s string, base int) int { v, _ := strconv.ParseInt(s, base, 64); return int(v) }

func split(s string, sep string) []string {
	var parts []string = []string{}
	_ = parts
	var cur string = ""
	_ = cur
	var i int = 0
	_ = i
	for i < len(s) {
		if ((len(sep) > 0) && ((i + len(sep)) <= len(s))) && (_substr(s, i, (i+len(sep))) == sep) {
			parts = append(parts, cur)
			cur = ""
			i = (i + len(sep))
		} else {
			cur = (cur + _substr(s, i, (i+1)))
			i = (i + 1)
		}
	}
	parts = append(parts, cur)
	return parts
}

func parseIntStr(str string) int {
	var i int = 0
	_ = i
	var neg bool = false
	_ = neg
	if (len(str) > 0) && (string([]rune(str)[0:1]) == "-") {
		neg = true
		i = 1
	}
	var n int = 0
	_ = n
	var digits map[string]int = map[string]int{"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
	_ = digits
	for i < len(str) {
		n = ((n * 10) + digits[string([]rune(str)[i:(i+1)])])
		i = (i + 1)
	}
	if neg {
		n = (0 - n)
	}
	return n
}

func joinInts(nums []int, sep string) string {
	var s string = ""
	_ = s
	var i int = 0
	_ = i
	for i < len(nums) {
		if i > 0 {
			s = (s + sep)
		}
		s = (s + fmt.Sprint(nums[i]))
		i = (i + 1)
	}
	return s
}

func undot(s string) []int {
	var parts []string = _split(s, ".")
	_ = parts
	var nums []int = []int{}
	_ = nums
	for _, p := range parts {
		nums = append(nums, _parseIntStr(p, 10))
	}
	return nums
}

func factorial(n int) int {
	var f int = 1
	_ = f
	var i int = 2
	_ = i
	for i <= n {
		f = (f * i)
		i = (i + 1)
	}
	return f
}

func genFactBaseNums(size int, countOnly bool) []any {
	var results [][]int = [][]int{}
	_ = results
	var count int = 0
	_ = count
	var n int = 0
	_ = n
	for {
		var radix int = 2
		_ = radix
		var res []int = []int{}
		_ = res
		if !countOnly {
			var z int = 0
			_ = z
			for z < size {
				res = append(res, 0)
				z = (z + 1)
			}
		}
		var k int = n
		_ = k
		for k > 0 {
			var div int = (k / radix)
			_ = div
			var rem int = (k % radix)
			_ = rem
			if !countOnly && (radix <= (size + 1)) {
				res[((size - radix) + 1)] = rem
			}
			k = div
			radix = (radix + 1)
		}
		if radix > (size + 2) {
			break
		}
		count = (count + 1)
		if !countOnly {
			results = append(results, res)
		}
		n = (n + 1)
	}
	return []any{results, count}
}

func mapToPerms(factNums [][]int) [][]int {
	var perms [][]int = [][]int{}
	_ = perms
	var psize int = (len(factNums[0]) + 1)
	_ = psize
	var start []int = []int{}
	_ = start
	var i int = 0
	_ = i
	for i < psize {
		start = append(start, i)
		i = (i + 1)
	}
	for _, fn := range factNums {
		var perm []int = []int{}
		_ = perm
		var j int = 0
		_ = j
		for j < len(start) {
			perm = append(perm, start[j])
			j = (j + 1)
		}
		var m int = 0
		_ = m
		for m < len(fn) {
			var g int = fn[m]
			_ = g
			if g != 0 {
				var first int = m
				_ = first
				var last int = (m + g)
				_ = last
				var t int = 1
				_ = t
				for t <= g {
					var temp int = perm[first]
					_ = temp
					var x int = (first + 1)
					_ = x
					for x <= last {
						perm[(x - 1)] = perm[x]
						x = (x + 1)
					}
					perm[last] = temp
					t = (t + 1)
				}
			}
			m = (m + 1)
		}
		perms = append(perms, perm)
	}
	return perms
}

var seed int

func randInt(n int) int {
	seed = (((seed * 1664525) + 1013904223) % 2147483647)
	return (seed % n)
}

func mochiMain() {
	var g []any = genFactBaseNums(3, false)
	_ = g
	factNums := g[0]
	_ = factNums
	var perms [][]int = mapToPerms(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = x.([]int)
			}
			return out
		}
		return v.([][]int)
	}(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = x.([]int)
			}
			return out
		}
		return v.([][]int)
	}(factNums)))
	_ = perms
	var i int = 0
	_ = i
	for i < _len(factNums) {
		fmt.Println(((joinInts(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(func(v any) []any {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]any); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []any{}
				}
				out := make([]any, len(arr))
				for i, x := range arr {
					out[i] = x.(any)
				}
				return out
			}
			return v.([]any)
		}(factNums)[i])), ".") + " -> ") + joinInts(func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(perms[i]), "")))
		i = (i + 1)
	}
	var count2 int = factorial(11)
	_ = count2
	fmt.Println(("\nPermutations generated = " + fmt.Sprint(count2)))
	fmt.Println(("compared to 11! which  = " + fmt.Sprint(factorial(11))))
	fmt.Println("")
	var fbn51s []string = []string{"39.49.7.47.29.30.2.12.10.3.29.37.33.17.12.31.29.34.17.25.2.4.25.4.1.14.20.6.21.18.1.1.1.4.0.5.15.12.4.3.10.10.9.1.6.5.5.3.0.0.0", "51.48.16.22.3.0.19.34.29.1.36.30.12.32.12.29.30.26.14.21.8.12.1.3.10.4.7.17.6.21.8.12.15.15.13.15.7.3.12.11.9.5.5.6.6.3.4.0.3.2.1"}
	_ = fbn51s
	factNums = [][]int{undot(fbn51s[0]), undot(fbn51s[1])}
	perms = mapToPerms(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = x.([]int)
			}
			return out
		}
		return v.([][]int)
	}(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = x.([]int)
			}
			return out
		}
		return v.([][]int)
	}(factNums)))
	var shoe string = "A♠K♠Q♠J♠T♠9♠8♠7♠6♠5♠4♠3♠2♠A♥K♥Q♥J♥T♥9♥8♥7♥6♥5♥4♥3♥2♥A♦K♦Q♦J♦T♦9♦8♦7♦6♦5♦4♦3♦2♦A♣K♣Q♣J♣T♣9♣8♣7♣6♣5♣4♣3♣2♣"
	_ = shoe
	var cards []string = []string{}
	_ = cards
	i = 0
	for i < 52 {
		var card string = _substr(shoe, (2 * i), ((2 * i) + 2))
		_ = card
		if string([]rune(card)[0:1]) == "T" {
			card = ("10" + string([]rune(card)[1:2]))
		}
		cards = append(cards, card)
		i = (i + 1)
	}
	i = 0
	for i < len(fbn51s) {
		fmt.Println(fbn51s[i])
		var perm []int = perms[i]
		_ = perm
		var j int = 0
		_ = j
		var line string = ""
		_ = line
		for j < len(perm) {
			line = (line + cards[perm[j]])
			j = (j + 1)
		}
		fmt.Println((line + "\n"))
		i = (i + 1)
	}
	var fbn51 []int = []int{}
	_ = fbn51
	i = 0
	for i < 51 {
		fbn51 = append(fbn51, randInt((52 - i)))
		i = (i + 1)
	}
	fmt.Println(joinInts(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(fbn51), "."))
	perms = mapToPerms(func(v any) [][]int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([][]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return [][]int{}
			}
			out := make([][]int, len(arr))
			for i, x := range arr {
				out[i] = x.([]int)
			}
			return out
		}
		return v.([][]int)
	}([][]int{fbn51}))
	var line string = ""
	_ = line
	i = 0
	for i < len(perms[0]) {
		line = (line + cards[perms[0][i]])
		i = (i + 1)
	}
	fmt.Println(line)
}

func main() {
	seed = 1
	mochiMain()
}
