//go:build ignore

// Generated by Mochi v0.10.40 on 2025-07-25 19:42:33 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Complex struct {
	Re float64 `json:"re"`
	Im float64 `json:"im"`
}

func add(a Complex, b Complex) Complex {
	return Complex{
		Re: (a.Re + b.Re),
		Im: (a.Im + b.Im),
	}
}

func mul(a Complex, b Complex) Complex {
	return Complex{
		Re: ((a.Re * b.Re) - (a.Im * b.Im)),
		Im: ((a.Re * b.Im) + (a.Im * b.Re)),
	}
}

func neg(a Complex) Complex {
	return Complex{
		Re: (0 - a.Re),
		Im: (0 - a.Im),
	}
}

func inv(a Complex) Complex {
	var denom float64 = ((a.Re * a.Re) + (a.Im * a.Im))
	_ = denom
	return Complex{
		Re: (a.Re / denom),
		Im: ((0 - a.Im) / denom),
	}
}

func conj(a Complex) Complex {
	return Complex{
		Re: a.Re,
		Im: (0 - a.Im),
	}
}

func cstr(a Complex) string {
	var s string = ("(" + fmt.Sprint(a.Re))
	_ = s
	if a.Im >= 0 {
		s = (((s + "+") + fmt.Sprint(a.Im)) + "i)")
	} else {
		s = ((s + fmt.Sprint(a.Im)) + "i)")
	}
	return s
}

var a Complex

var b Complex

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		start := _now()
		a = Complex{
			Re: 1.0,
			Im: 1.0,
		}
		b = Complex{
			Re: 3.14159,
			Im: 1.25,
		}
		fmt.Println(("a:       " + cstr(a)))
		fmt.Println(("b:       " + cstr(b)))
		fmt.Println(("a + b:   " + cstr(add(a, b))))
		fmt.Println(("a * b:   " + cstr(mul(a, b))))
		fmt.Println(("-a:      " + cstr(neg(a))))
		fmt.Println(("1 / a:   " + cstr(inv(a))))
		fmt.Println(("aÌ…:       " + cstr(conj(a))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		end := _now()
		data := map[string]any{"name": "main", "duration_us": (end - start) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
