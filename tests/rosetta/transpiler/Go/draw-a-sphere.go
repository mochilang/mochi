//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 22:41:05 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

type V3 struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
	Z float64 `json:"z"`
}

func sqrtApprox(x float64) float64 {
	if x <= 0.0 {
		return 0.0
	}
	var guess float64 = x
	_ = guess
	var i int = 0
	_ = i
	for i < 20 {
		guess = ((guess + (x / guess)) / 2.0)
		i = (i + 1)
	}
	return guess
}

func powf(base float64, exp int) float64 {
	var result float64 = 1.0
	_ = result
	var i int = 0
	_ = i
	for i < exp {
		result = (result * base)
		i = (i + 1)
	}
	return result
}

func normalize(v V3) V3 {
	var len float64 = sqrtApprox((((v.X * v.X) + (v.Y * v.Y)) + (v.Z * v.Z)))
	_ = len
	_ = len
	return V3{
		X: (v.X / len),
		Y: (v.Y / len),
		Z: (v.Z / len),
	}
}

func dot(a V3, b V3) float64 {
	var d float64 = (((a.X * b.X) + (a.Y * b.Y)) + (a.Z * b.Z))
	_ = d
	if d < 0.0 {
		return (0 - d)
	}
	return 0.0
}

func drawSphere(r int, k int, ambient float64, light V3, shades string) {
	var i int = (0 - r)
	_ = i
	for i <= r {
		var x float64 = (float64(i) + 0.5)
		_ = x
		var line string = ""
		_ = line
		var j int = (0 - (2 * r))
		_ = j
		for j <= (2 * r) {
			var y float64 = ((float64(j) / 2.0) + 0.5)
			_ = y
			if ((x * x) + (y * y)) <= (float64(r) * float64(r)) {
				var zsq float64 = (((float64(r) * float64(r)) - (x * x)) - (y * y))
				_ = zsq
				var vec V3 = normalize(V3{
					X: x,
					Y: y,
					Z: sqrtApprox(zsq),
				})
				_ = vec
				var b float64 = (powf(dot(light, vec), k) + ambient)
				_ = b
				_ = b
				var intensity int = int(((1.0 - b) * (float64(len(shades)) - 1.0)))
				_ = intensity
				if intensity < 0 {
					intensity = 0
				}
				if intensity >= len(shades) {
					intensity = (len(shades) - 1)
				}
				line = (line + _substr(shades, intensity, (intensity+1)))
			} else {
				line = (line + " ")
			}
			j = (j + 1)
		}
		fmt.Println(line)
		i = (i + 1)
	}
}

func mochiMain() {
	var shades string = ".:!*oe&#%@"
	_ = shades
	var light V3 = normalize(V3{
		X: 30.0,
		Y: 30.0,
		Z: (0 - 50.0),
	})
	_ = light
	drawSphere(20, 4, 0.1, light, shades)
	drawSphere(10, 2, 0.4, light, shades)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
