//go:build ignore

// Generated by Mochi v0.10.55 on 2025-08-02 17:45:42 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Frac struct {
	Num int `json:"num"`
	Den int `json:"den"`
}

func fracStr(f Frac) string {
	return ((fmt.Sprint(f.Num) + "/") + fmt.Sprint(f.Den))
}

func gen(l Frac, r Frac, n int, acc []Frac) []Frac {
	var m Frac = Frac{
		Num: (l.Num + r.Num),
		Den: (l.Den + r.Den),
	}
	_ = m
	if m.Den <= n {
		acc = gen(l, m, n, func(v any) []Frac {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Frac); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Frac{}
				}
				out := make([]Frac, len(arr))
				for i, x := range arr {
					out[i] = x.(Frac)
				}
				return out
			}
			return v.([]Frac)
		}(acc))
		acc = append(acc, m)
		acc = gen(m, r, n, func(v any) []Frac {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Frac); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Frac{}
				}
				out := make([]Frac, len(arr))
				for i, x := range arr {
					out[i] = x.(Frac)
				}
				return out
			}
			return v.([]Frac)
		}(acc))
	}
	return acc
}

func totient(n int) int {
	var tot int = n
	_ = tot
	var nn int = n
	_ = nn
	var p int = 2
	_ = p
	for (p * p) <= nn {
		if (nn % p) == 0 {
			for (nn % p) == 0 {
				nn = (nn / p)
			}
			tot = (tot - (tot / p))
		}
		if p == 2 {
			p = 1
		}
		p = (p + 2)
	}
	if nn > 1 {
		tot = (tot - (tot / nn))
	}
	return tot
}

func mochiMain() {
	var n int = 1
	_ = n
	for n <= 11 {
		var l Frac = Frac{
			Num: 0,
			Den: 1,
		}
		_ = l
		var r Frac = Frac{
			Num: 1,
			Den: 1,
		}
		_ = r
		var seq []Frac = gen(l, r, n, func(v any) []Frac {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]Frac); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []Frac{}
				}
				out := make([]Frac, len(arr))
				for i, x := range arr {
					out[i] = x.(Frac)
				}
				return out
			}
			return v.([]Frac)
		}([]Frac{}))
		_ = seq
		var line string = ((("F(" + fmt.Sprint(n)) + "): ") + fracStr(l))
		_ = line
		for _, f := range seq {
			line = ((line + " ") + fracStr(f))
		}
		line = ((line + " ") + fracStr(r))
		fmt.Println(line)
		n = (n + 1)
	}
	var sum int = 1
	_ = sum
	var i int = 1
	_ = i
	var next int = 100
	_ = next
	for i <= 1000 {
		sum = (sum + totient(i))
		if i == next {
			fmt.Println(((("|F(" + fmt.Sprint(i)) + ")|: ") + fmt.Sprint(sum)))
			next = (next + 100)
		}
		i = (i + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
