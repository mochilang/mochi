//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 22:14:33 GMT+7
package main

import (
	"fmt"
	"strconv"
)

func _toMapIntMapStringAny(v any) map[int]map[string]any {
	if v == nil {
		return nil
	}
	if m, ok := v.(map[int]map[string]any); ok {
		return m
	}
	out := make(map[int]map[string]any)
	if m, ok := v.(map[string]any); ok {
		for k, vv := range m {
			if id, err := strconv.Atoi(k); err == nil {
				if sub, ok := vv.(map[string]any); ok {
					out[id] = sub
				}
			}
		}
	}
	return out
}

func newList() map[string]any {
	return map[string]any{"nodes": map[string]any{}, "head": 0, "tail": 0, "nextID": 1}
}

func newNode(l map[string]any, v any) map[string]any {
	var id int = l["nextID"].(int)
	l["nextID"] = (id + 1)
	var nodes map[int]map[string]any = _toMapIntMapStringAny(l["nodes"])
	n := map[string]any{"id": id, "value": v, "next": 0, "prev": 0}
	nodes[id] = n
	l["nodes"] = nodes
	return n
}

func pushFront(l map[string]any, v any) map[string]any {
	var n map[string]any = newNode(l, v)
	n["next"] = l["head"].(int)
	if l["head"].(int) != 0 {
		var nodes map[int]map[string]any = _toMapIntMapStringAny(l["nodes"])
		var h map[string]any = nodes[l["head"].(int)]
		h["prev"] = n["id"].(int)
		nodes[h["id"].(int)] = h
		l["nodes"] = nodes
	} else {
		l["tail"] = n["id"].(int)
	}
	l["head"] = n["id"].(int)
	var nodes2 map[int]map[string]any = _toMapIntMapStringAny(l["nodes"])
	nodes2[n["id"].(int)] = n
	l["nodes"] = nodes2
	return n
}

func pushBack(l map[string]any, v any) map[string]any {
	var n map[string]any = newNode(l, v)
	n["prev"] = l["tail"].(int)
	if l["tail"].(int) != 0 {
		var nodes map[int]map[string]any = _toMapIntMapStringAny(l["nodes"])
		var t map[string]any = nodes[l["tail"].(int)]
		t["next"] = n["id"].(int)
		nodes[t["id"].(int)] = t
		l["nodes"] = nodes
	} else {
		l["head"] = n["id"].(int)
	}
	l["tail"] = n["id"].(int)
	var nodes2 map[int]map[string]any = _toMapIntMapStringAny(l["nodes"])
	nodes2[n["id"].(int)] = n
	l["nodes"] = nodes2
	return n
}

func insertBefore(l map[string]any, refID int, v any) map[string]any {
	if refID == 0 {
		return pushFront(l, v)
	}
	var nodes map[int]map[string]any = _toMapIntMapStringAny(l["nodes"])
	var ref map[string]any = nodes[refID]
	var n map[string]any = newNode(l, v)
	n["prev"] = ref["prev"].(int)
	n["next"] = ref["id"].(int)
	if ref["prev"].(int) != 0 {
		var p map[string]any = nodes[ref["prev"].(int)]
		p["next"] = n["id"].(int)
		nodes[p["id"].(int)] = p
	} else {
		l["head"] = n["id"].(int)
	}
	ref["prev"] = n["id"].(int)
	nodes[refID] = ref
	nodes[n["id"].(int)] = n
	l["nodes"] = nodes
	return n
}

func insertAfter(l map[string]any, refID int, v any) map[string]any {
	if refID == 0 {
		return pushBack(l, v)
	}
	var nodes map[int]map[string]any = _toMapIntMapStringAny(l["nodes"])
	var ref map[string]any = nodes[refID]
	var n map[string]any = newNode(l, v)
	n["next"] = ref["next"].(int)
	n["prev"] = ref["id"].(int)
	if ref["next"].(int) != 0 {
		var nx map[string]any = nodes[ref["next"].(int)]
		nx["prev"] = n["id"].(int)
		nodes[nx["id"].(int)] = nx
	} else {
		l["tail"] = n["id"].(int)
	}
	ref["next"] = n["id"].(int)
	nodes[refID] = ref
	nodes[n["id"].(int)] = n
	l["nodes"] = nodes
	return n
}

func mochiMain() {
	var l map[string]any = newList()
	var e4 map[string]any = pushBack(l, 4)
	var e1 map[string]any = pushFront(l, 1)
	insertBefore(l, e4["id"].(int), 3)
	insertAfter(l, e1["id"].(int), "two")
	var id int = l["head"].(int)
	var nodes map[int]map[string]any = _toMapIntMapStringAny(l["nodes"])
	for id != 0 {
		var node map[string]any = nodes[id]
		fmt.Println(fmt.Sprint(node["value"]))
		id = node["next"].(int)
	}
}

func main() {
	mochiMain()
}
