//go:build ignore

// Generated by Mochi v0.10.50 on 2025-07-31 00:29:30 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func sortFloat(xs []float64) []float64 {
	var arr []float64 = xs
	_ = arr
	var n int = len(arr)
	_ = n
	var i int = 0
	_ = i
	for i < n {
		var j int = 0
		_ = j
		for j < (n - 1) {
			if arr[j] > arr[(j+1)] {
				var t float64 = arr[j]
				_ = t
				arr[j] = arr[(j + 1)]
				arr[(j + 1)] = t
			}
			j = (j + 1)
		}
		i = (i + 1)
	}
	return arr
}

func ceilf(x float64) int {
	var i int = int(x)
	_ = i
	if x > float64(i) {
		return (i + 1)
	}
	return i
}

func fivenum(a []float64) []float64 {
	var arr []float64 = sortFloat(func(v any) []float64 {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]float64); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []float64{}
			}
			out := make([]float64, len(arr))
			for i, x := range arr {
				out[i] = x.(float64)
			}
			return out
		}
		return v.([]float64)
	}(a))
	_ = arr
	var n int = len(arr)
	_ = n
	var half int = ((n + 3) - ((n + 3) % 2))
	_ = half
	var n4 float64 = (float64((half / 2)) / 2.0)
	_ = n4
	var nf float64 = float64(n)
	_ = nf
	var d []float64 = []float64{1.0, n4, ((nf + 1.0) / 2.0), ((nf + 1.0) - n4), nf}
	_ = d
	var result []float64 = []float64{}
	_ = result
	var idx int = 0
	_ = idx
	for idx < len(d) {
		var de float64 = d[idx]
		_ = de
		var fl int = int((de - 1.0))
		_ = fl
		var cl int = ceilf((de - 1.0))
		_ = cl
		result = append(result, (0.5 * (arr[fl] + arr[cl])))
		idx = (idx + 1)
	}
	return result
}

var x1 []float64

var x2 []float64

var x3 []float64

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		x1 = []float64{36.0, 40.0, 7.0, 39.0, 41.0, 15.0}
		x2 = []float64{15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0}
		x3 = []float64{0.14082834, 0.0974879, 1.73131507, 0.87636009, (0 - 1.95059594), 0.73438555, (0 - 0.03035726), 1.4667597, (0 - 0.74621349), (0 - 0.72588772), 0.6390516, 0.61501527, (0 - 0.9898378), (0 - 1.00447874), (0 - 0.62759469), 0.66206163, 1.04312009, (0 - 0.10305385), 0.75775634, 0.32566578}
		fmt.Println(fmt.Sprint(fivenum(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(x1))))
		fmt.Println(fmt.Sprint(fivenum(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(x2))))
		fmt.Println(fmt.Sprint(fivenum(func(v any) []float64 {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]float64); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []float64{}
				}
				out := make([]float64, len(arr))
				for i, x := range arr {
					out[i] = x.(float64)
				}
				return out
			}
			return v.([]float64)
		}(x3))))
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
