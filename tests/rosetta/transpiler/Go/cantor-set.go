//go:build ignore

// Generated by Mochi v0.10.40 on 2025-07-26 11:11:41 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

var width int

var height int

var lines []string

func setChar(s string, idx int, ch string) string {
	return ((_substr(s, 0, idx) + ch) + _substr(s, (idx+1), len(s)))
}

var stack []map[string]int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		width = 81
		height = 5
		lines = []string{}
		for i := 0; i < height; i++ {
			var row string = ""
			_ = row
			var j int = 0
			_ = j
			for j < width {
				row = (row + "*")
				j = (j + 1)
			}
			lines = append(lines, row)
		}
		stack = []map[string]int{map[string]int{"start": 0, "len": width, "index": 1}}
		for len(stack) > 0 {
			var frame map[string]int = stack[(len(stack) - 1)]
			_ = frame
			stack = stack[:(len(stack) - 1)]
			var start int = frame["start"]
			_ = start
			var lenSeg int = frame["len"]
			_ = lenSeg
			var index int = frame["index"]
			_ = index
			var seg int = int((lenSeg / 3))
			_ = seg
			if seg == 0 {
				continue
			}
			var i int = index
			_ = i
			for i < height {
				var j int = (start + seg)
				_ = j
				for j < (start + (2 * seg)) {
					lines[i] = setChar(lines[i], j, " ")
					j = (j + 1)
				}
				i = (i + 1)
			}
			stack = append(stack, map[string]int{"start": start, "len": seg, "index": (index + 1)})
			stack = append(stack, map[string]int{"start": (start + (seg * 2)), "len": seg, "index": (index + 1)})
		}
		for _, _ch := range lines {
			line := string(_ch)
			fmt.Println(line)
		}
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
