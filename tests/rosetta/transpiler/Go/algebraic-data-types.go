//go:build ignore

// Generated by Mochi v0.10.39 on 2025-07-25 09:02:08 GMT+7
package main

import (
	"fmt"
)

func node(cl string, le any, aa int, ri any) map[string]any {
	return map[string]any{"cl": cl, "le": le, "aa": aa, "ri": ri}
}

func treeString(t any) string {
	if t == nil {
		return "E"
	}
	var m map[string]any = t.(map[string]any)
	_ = m
	return (((((((fmt.Sprint(("T(" + fmt.Sprint(m["cl"].(string)))) + ", ") + treeString(m["le"])) + ", ") + fmt.Sprint(m["aa"].(int))) + ", ") + treeString(m["ri"])) + ")").(string)
}

func balance(t any) any {
	if t == nil {
		return t
	}
	var m map[string]any = t.(map[string]any)
	_ = m
	if m["cl"].(string) != "B" {
		return t
	}
	le := m["le"]
	_ = le
	ri := m["ri"]
	_ = ri
	if le != nil {
		var leMap map[string]any = le.(map[string]any)
		_ = leMap
		if leMap["cl"].(string) == "R" {
			lele := leMap["le"]
			_ = lele
			if lele != nil {
				var leleMap map[string]any = lele.(map[string]any)
				_ = leleMap
				if leleMap["cl"].(string) == "R" {
					return node("R", node("B", leleMap["le"], leleMap["aa"].(int), leleMap["ri"]), leMap["aa"].(int), node("B", leMap["ri"], m["aa"].(int), ri))
				}
			}
			leri := leMap["ri"]
			_ = leri
			if leri != nil {
				var leriMap map[string]any = leri.(map[string]any)
				_ = leriMap
				if leriMap["cl"].(string) == "R" {
					return node("R", node("B", leMap["le"], leMap["aa"].(int), leriMap["le"]), leriMap["aa"].(int), node("B", leriMap["ri"], m["aa"].(int), ri))
				}
			}
		}
	}
	if ri != nil {
		var riMap map[string]any = ri.(map[string]any)
		_ = riMap
		if riMap["cl"].(string) == "R" {
			rile := riMap["le"]
			_ = rile
			if rile != nil {
				var rileMap map[string]any = rile.(map[string]any)
				_ = rileMap
				if rileMap["cl"].(string) == "R" {
					return node("R", node("B", m["le"], m["aa"].(int), rileMap["le"]), rileMap["aa"].(int), node("B", rileMap["ri"], riMap["aa"].(int), riMap["ri"]))
				}
			}
			riri := riMap["ri"]
			_ = riri
			if riri != nil {
				var ririMap map[string]any = riri.(map[string]any)
				_ = ririMap
				if ririMap["cl"].(string) == "R" {
					return node("R", node("B", m["le"], m["aa"].(int), riMap["le"]), riMap["aa"].(int), node("B", ririMap["le"], ririMap["aa"].(int), ririMap["ri"]))
				}
			}
		}
	}
	return t
}

func ins(tr any, x int) any {
	if tr == nil {
		return node("R", nil, x, nil)
	}
	if x < tr.(map[string]any)["aa"].(int) {
		return balance(node(tr.(map[string]any)["cl"].(string), ins(tr.(map[string]any)["le"], x), tr.(map[string]any)["aa"].(int), tr.(map[string]any)["ri"]))
	}
	if x > tr.(map[string]any)["aa"].(int) {
		return balance(node(tr.(map[string]any)["cl"].(string), tr.(map[string]any)["le"], tr.(map[string]any)["aa"].(int), ins(tr.(map[string]any)["ri"], x)))
	}
	return tr
}

func insert(tr any, x int) any {
	t := ins(tr, x)
	_ = t
	if t == nil {
		return nil
	}
	var m map[string]any = t.(map[string]any)
	_ = m
	return node("B", m["le"], m["aa"].(int), m["ri"])
}

var tr any

var i int

func main() {
	tr = nil
	i = 1
	for i <= 16 {
		tr = insert(tr, i)
		i = (i + 1)
	}
	fmt.Println(treeString(tr))
}
