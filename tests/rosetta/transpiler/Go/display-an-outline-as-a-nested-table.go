//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 21:52:41 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _split(s, sep string) []string {
	if sep == "" {
		sep = " "
	}
	return strings.Split(s, sep)
}

func split(s string, sep string) []string {
	var out []string = []string{}
	var cur string = ""
	var i int = 0
	for i < len(s) {
		if ((i + len(sep)) <= len(s)) && (_substr(s, i, (i+len(sep))) == sep) {
			out = append(out, cur)
			cur = ""
			i = (i + len(sep))
		} else {
			cur = (cur + _substr(s, i, (i+1)))
			i = (i + 1)
		}
	}
	out = append(out, cur)
	return out
}

func join(xs []string, sep string) string {
	var res string = ""
	var i int = 0
	for i < len(xs) {
		if i > 0 {
			res = (res + sep)
		}
		res = (res + xs[i])
		i = (i + 1)
	}
	return res
}

func trimLeftSpaces(s string) string {
	var i int = 0
	for (i < len(s)) && (string([]rune(s)[i:(i+1)]) == " ") {
		i = (i + 1)
	}
	return string([]rune(s)[i:len(s)])
}

func makeIndent(outline string, tab int) []map[string]any {
	var lines []string = _split(outline, "\n")
	var nodes []map[string]any = []map[string]any{}
	for _, _ch := range lines {
		line := string(_ch)
		var line2 string = trimLeftSpaces(line)
		var level int = ((len(line) - len(line2)) / tab)
		nodes = append(nodes, map[string]any{"level": level, "name": line2})
	}
	return nodes
}

func toNest(nodes []map[string]any, start int, level int, n map[string]any) {
	if level == 0 {
		n["name"] = nodes[0]["name"].(string)
	}
	var i int = (start + 1)
	for i < len(nodes) {
		var node map[string]any = nodes[i]
		var lev int = node["level"].(int)
		if lev == (level + 1) {
			child := map[string]any{"name": node["name"].(string), "children": []any{}}
			toNest(func(v any) []map[string]any {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]map[string]any); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []map[string]any{}
					}
					out := make([]map[string]any, len(arr))
					for i, x := range arr {
						out[i] = x.(map[string]any)
					}
					return out
				}
				return v.([]map[string]any)
			}(nodes), i, (level + 1), child)
			var cs []any = func(v any) []any {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]any); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []any{}
					}
					out := make([]any, len(arr))
					for i, x := range arr {
						out[i] = x.(any)
					}
					return out
				}
				return v.([]any)
			}(n["children"])
			cs = append(cs, child)
			n["children"] = cs
		} else {
			if lev <= level {
				return
			}
		}
		i = (i + 1)
	}
}

func countLeaves(n map[string]any) int {
	var kids []any = func(v any) []any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []any{}
			}
			out := make([]any, len(arr))
			for i, x := range arr {
				out[i] = x.(any)
			}
			return out
		}
		return v.([]any)
	}(n["children"])
	if len(kids) == 0 {
		return 1
	}
	var total int = 0
	for _, k := range kids {
		total = (total + countLeaves(k.(map[string]any)))
	}
	return total
}

func nodesByDepth(root map[string]any, depth int) [][]map[string]any {
	var levels [][]map[string]any = [][]map[string]any{}
	var current []map[string]any = []map[string]any{root}
	var d int = 0
	for d < depth {
		levels = append(levels, current)
		var next []map[string]any = []map[string]any{}
		for _, n := range current {
			var kids []any = func(v any) []any {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]any); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []any{}
					}
					out := make([]any, len(arr))
					for i, x := range arr {
						out[i] = x.(any)
					}
					return out
				}
				return v.([]any)
			}(n["children"])
			for _, k := range kids {
				next = append(next, k.(map[string]any))
			}
		}
		current = next
		d = (d + 1)
	}
	return levels
}

func toMarkup(n map[string]any, cols []string, depth int) string {
	var lines []string = []string{}
	lines = append(lines, "{| class=\"wikitable\" style=\"text-align: center;\"")
	var l1 string = "|-"
	lines = append(lines, l1)
	var span int = countLeaves(n)
	lines = append(lines, ((((("| style=\"background: " + cols[0]) + " \" colSpan=") + fmt.Sprint(span)) + " | ") + n["name"].(string)))
	lines = append(lines, l1)
	var lvls [][]map[string]any = nodesByDepth(n, depth)
	var lvl int = 1
	for lvl < depth {
		var nodes []map[string]any = lvls[lvl]
		if len(nodes) == 0 {
			lines = append(lines, "|  |")
		} else {
			var idx int = 0
			for idx < len(nodes) {
				var node map[string]any = nodes[idx]
				span = countLeaves(node)
				var col int = lvl
				if lvl == 1 {
					col = (idx + 1)
				}
				if col >= len(cols) {
					col = (len(cols) - 1)
				}
				var cell string = ((((("| style=\"background: " + cols[col]) + " \" colspan=") + fmt.Sprint(span)) + " | ") + node["name"].(string))
				lines = append(lines, cell)
				idx = (idx + 1)
			}
		}
		if lvl < (depth - 1) {
			lines = append(lines, l1)
		}
		lvl = (lvl + 1)
	}
	lines = append(lines, "|}")
	return join(func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(lines), "\n")
}

func mochiMain() {
	var outline string = ((((((((((("Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n") + "        measuring the indent of each line,\n") + "        translating the indentation to a nested structure,\n") + "        and padding the tree to even depth.\n") + "    count the leaves descending from each node,\n") + "        defining the width of a leaf as 1,\n") + "        and the width of a parent node as a sum.\n") + "            (The sum of the widths of its children)\n") + "    and write out a table with 'colspan' values\n") + "        either as a wiki table,\n") + "        or as HTML.")
	var yellow string = "#ffffe6;"
	var orange string = "#ffebd2;"
	var green string = "#f0fff0;"
	var blue string = "#e6ffff;"
	var pink string = "#ffeeff;"
	var cols []string = []string{yellow, orange, green, blue, pink}
	var nodes []map[string]any = makeIndent(outline, 4)
	n := map[string]any{"name": "", "children": []any{}}
	toNest(func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}(nodes), 0, 0, n)
	fmt.Println(toMarkup(n, func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(cols), 4))
	fmt.Println("\n")
	var outline2 string = ((((((((((((("Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n") + "        measuring the indent of each line,\n") + "        translating the indentation to a nested structure,\n") + "        and padding the tree to even depth.\n") + "    count the leaves descending from each node,\n") + "        defining the width of a leaf as 1,\n") + "        and the width of a parent node as a sum.\n") + "            (The sum of the widths of its children)\n") + "            Propagating the sums upward as necessary.\n") + "    and write out a table with 'colspan' values\n") + "        either as a wiki table,\n") + "        or as HTML.\n") + "    Optionally add color to the nodes.")
	var cols2 []string = []string{blue, yellow, orange, green, pink}
	var nodes2 []map[string]any = makeIndent(outline2, 4)
	n2 := map[string]any{"name": "", "children": []any{}}
	toNest(func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}(nodes2), 0, 0, n2)
	fmt.Println(toMarkup(n2, func(v any) []string {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []string{}
			}
			out := make([]string, len(arr))
			for i, x := range arr {
				out[i] = x.(string)
			}
			return out
		}
		return v.([]string)
	}(cols2), 4))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
