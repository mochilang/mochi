//go:build ignore

// Generated by Mochi v0.10.39 on 2025-07-25 09:02:09 GMT+7
package main

import (
	"fmt"
)

var THRESHOLD int

func indexOf(xs []int, value int) int {
	var i int = 0
	_ = i
	for i < len(xs) {
		if xs[i] == value {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func contains(xs []int, value int) bool {
	return (indexOf(xs, value) != (0 - 1))
}

func maxOf(a int, b int) int {
	if a > b {
		return a
	} else {
		return b
	}
}

func intSqrt(n int) int {
	if n == 0 {
		return 0
	}
	var x int = n
	_ = x
	var y int = ((x + 1) / 2)
	_ = y
	for y < x {
		x = y
		y = ((x + (n / x)) / 2)
	}
	return x
}

func sumProperDivisors(n int) int {
	if n < 2 {
		return 0
	}
	var sqrt int = intSqrt(n)
	_ = sqrt
	var sum int = 1
	_ = sum
	var i int = 2
	_ = i
	for i <= sqrt {
		if (n % i) == 0 {
			sum = ((sum + i) + (n / i))
		}
		i = (i + 1)
	}
	if (sqrt * sqrt) == n {
		sum = (sum - sqrt)
	}
	return sum
}

func classifySequence(k int) map[string]any {
	var last int = k
	_ = last
	var seq []int = []int{k}
	_ = seq
	for {
		last = sumProperDivisors(last)
		seq = append(seq, last)
		var n int = len(seq)
		_ = n
		var aliquot string = ""
		_ = aliquot
		if last == 0 {
			aliquot = "Terminating"
		} else {
			if (n == 2) && (last == k) {
				aliquot = "Perfect"
			} else {
				if (n == 3) && (last == k) {
					aliquot = "Amicable"
				} else {
					if (n >= 4) && (last == k) {
						aliquot = (("Sociable[" + fmt.Sprint((n - 1))) + "]")
					} else {
						if last == seq[(n-2)] {
							aliquot = "Aspiring"
						} else {
							if func() bool {
								for _, v := range seq[1:maxOf(1, (n-2))] {
									if v == last {
										return true
									}
								}
								return false
							}() {
								var idx int = indexOf(seq, last)
								_ = idx
								aliquot = (("Cyclic[" + fmt.Sprint(((n - 1) - idx))) + "]")
							} else {
								if (n == 16) || (last > THRESHOLD) {
									aliquot = "Non-Terminating"
								}
							}
						}
					}
				}
			}
		}
		if aliquot != "" {
			return map[string]any{"seq": seq, "aliquot": aliquot}
		}
	}
	return map[string]any{"seq": seq, "aliquot": ""}
}

func padLeft(n int, w int) string {
	var s string = fmt.Sprint(n)
	_ = s
	for len(s) < w {
		s = (" " + s)
	}
	return s
}

func padRight(s string, w int) string {
	var r string = s
	_ = r
	for len(r) < w {
		r = (r + " ")
	}
	return r
}

func joinWithCommas(seq []int) string {
	var s string = "["
	_ = s
	var i int = 0
	_ = i
	for i < len(seq) {
		s = (s + fmt.Sprint(seq[i]))
		if i < (len(seq) - 1) {
			s = (s + ", ")
		}
		i = (i + 1)
	}
	s = (s + "]")
	return s
}

func mochiMain() {
	fmt.Println("Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n")
	var k int = 1
	_ = k
	for k <= 10 {
		var res map[string]any = classifySequence(k)
		_ = res
		fmt.Println(((((padLeft(k, 2) + ": ") + padRight(res["aliquot"].(string), 15)) + " ") + joinWithCommas(res["seq"].([]int))))
		k = (k + 1)
	}
	fmt.Println("")
	var s []int = []int{11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488}
	_ = s
	var i int = 0
	_ = i
	for i < len(s) {
		var val int = s[i]
		_ = val
		var res map[string]any = classifySequence(val)
		_ = res
		fmt.Println(((((padLeft(val, 7) + ": ") + padRight(res["aliquot"].(string), 15)) + " ") + joinWithCommas(res["seq"].([]int))))
		i = (i + 1)
	}
	fmt.Println("")
	var big int = 15355717786080
	_ = big
	var r map[string]any = classifySequence(big)
	_ = r
	fmt.Println(((((fmt.Sprint(big) + ": ") + padRight(r["aliquot"].(string), 15)) + " ") + joinWithCommas(r["seq"].([]int))))
}

func main() {
	THRESHOLD = 140737488355328
	mochiMain()
}
