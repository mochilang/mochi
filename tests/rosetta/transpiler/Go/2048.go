//go:build ignore

// Generated by Mochi v0.10.39 on 2025-07-25 09:21:48 GMT+7
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var _scanner = bufio.NewScanner(os.Stdin)

func _input() string {
	if !_scanner.Scan() {
		return ""
	}
	return _scanner.Text()
}

var SIZE int

type Board struct {
	Cells [][]int `json:"cells"`
}

type SpawnResult struct {
	Board Board `json:"board"`
	Full  bool  `json:"full"`
}

type SlideResult struct {
	Row  []int `json:"row"`
	Gain int   `json:"gain"`
}

type MoveResult struct {
	Board Board `json:"board"`
	Score int   `json:"score"`
	Moved bool  `json:"moved"`
}

func newBoard() Board {
	var b [][]int = [][]int{}
	_ = b
	var y int = 0
	_ = y
	for y < SIZE {
		var row []int = []int{}
		_ = row
		var x int = 0
		_ = x
		for x < SIZE {
			row = append(row, 0)
			x = (x + 1)
		}
		b = append(b, row)
		y = (y + 1)
	}
	return Board{
		Cells: b,
	}
}

func spawnTile(b Board) SpawnResult {
	var grid [][]int = b.Cells
	_ = grid
	var empty [][]int = [][]int{}
	_ = empty
	var y int = 0
	_ = y
	for y < SIZE {
		var x int = 0
		_ = x
		for x < SIZE {
			if grid[y][x] == 0 {
				empty = append(empty, []int{x, y})
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	if len(empty) == 0 {
		return SpawnResult{
			Board: b,
			Full:  true,
		}
	}
	var idx int = (_now() % len(empty))
	_ = idx
	var cell []int = empty[idx]
	_ = cell
	var val int = 4
	_ = val
	if (_now() % 10) < 9 {
		val = 2
	}
	grid[cell[1]][cell[0]] = val
	return SpawnResult{
		Board: Board{
			Cells: grid,
		},
		Full: (len(empty) == 1),
	}
}

func pad(n int) string {
	var s string = fmt.Sprint(n)
	_ = s
	var pad int = (4 - len(s))
	_ = pad
	var i int = 0
	_ = i
	var out string = ""
	_ = out
	for i < pad {
		out = (out + " ")
		i = (i + 1)
	}
	return (out + s)
}

func draw(b Board, score int) {
	fmt.Println(("Score: " + fmt.Sprint(score)))
	var y int = 0
	_ = y
	for y < SIZE {
		fmt.Println("+----+----+----+----+")
		var line string = "|"
		_ = line
		var x int = 0
		_ = x
		for x < SIZE {
			var v int = b.Cells[y][x]
			_ = v
			if v == 0 {
				line = (line + "    |")
			} else {
				line = ((line + pad(v)) + "|")
			}
			x = (x + 1)
		}
		fmt.Println(line)
		y = (y + 1)
	}
	fmt.Println("+----+----+----+----+")
	fmt.Println("W=Up S=Down A=Left D=Right Q=Quit")
}

func reverseRow(r []int) []int {
	var out []int = []int{}
	_ = out
	var i int = (len(r) - 1)
	_ = i
	for i >= 0 {
		out = append(out, r[i])
		i = (i - 1)
	}
	return out
}

func slideLeft(row []int) SlideResult {
	var xs []int = []int{}
	_ = xs
	var i int = 0
	_ = i
	for i < len(row) {
		if row[i] != 0 {
			xs = append(xs, row[i])
		}
		i = (i + 1)
	}
	var res []int = []int{}
	_ = res
	var gain int = 0
	_ = gain
	i = 0
	for i < len(xs) {
		if ((i + 1) < len(xs)) && (xs[i] == xs[(i+1)]) {
			var v int = (xs[i] * 2)
			_ = v
			gain = (gain + v)
			res = append(res, v)
			i = (i + 2)
		} else {
			res = append(res, xs[i])
			i = (i + 1)
		}
	}
	for len(res) < SIZE {
		res = append(res, 0)
	}
	return SlideResult{
		Row:  res,
		Gain: gain,
	}
}

func moveLeft(b Board, score int) MoveResult {
	var grid [][]int = b.Cells
	_ = grid
	var moved bool = false
	_ = moved
	var y int = 0
	_ = y
	for y < SIZE {
		var r SlideResult = slideLeft(grid[y])
		_ = r
		var new []int = r.Row
		_ = new
		score = (score + r.Gain)
		var x int = 0
		_ = x
		for x < SIZE {
			if grid[y][x] != new[x] {
				moved = true
			}
			grid[y][x] = new[x]
			x = (x + 1)
		}
		y = (y + 1)
	}
	return MoveResult{
		Board: Board{
			Cells: grid,
		},
		Score: score,
		Moved: moved,
	}
}

func moveRight(b Board, score int) MoveResult {
	var grid [][]int = b.Cells
	_ = grid
	var moved bool = false
	_ = moved
	var y int = 0
	_ = y
	for y < SIZE {
		var rev []int = reverseRow(grid[y])
		_ = rev
		var r SlideResult = slideLeft(rev)
		_ = r
		rev = r.Row
		score = (score + r.Gain)
		rev = reverseRow(rev)
		var x int = 0
		_ = x
		for x < SIZE {
			if grid[y][x] != rev[x] {
				moved = true
			}
			grid[y][x] = rev[x]
			x = (x + 1)
		}
		y = (y + 1)
	}
	return MoveResult{
		Board: Board{
			Cells: grid,
		},
		Score: score,
		Moved: moved,
	}
}

func getCol(b Board, x int) []int {
	var col []int = []int{}
	_ = col
	var y int = 0
	_ = y
	for y < SIZE {
		col = append(col, b.Cells[y][x])
		y = (y + 1)
	}
	return col
}

func setCol(b Board, x int, col []int) {
	var rows [][]int = b.Cells
	_ = rows
	var y int = 0
	_ = y
	for y < SIZE {
		var row []int = rows[y]
		_ = row
		row[x] = col[y]
		rows[y] = row
		y = (y + 1)
	}
	b.Cells = rows
}

func moveUp(b Board, score int) MoveResult {
	var grid [][]int = b.Cells
	_ = grid
	var moved bool = false
	_ = moved
	var x int = 0
	_ = x
	for x < SIZE {
		var col []int = getCol(b, x)
		_ = col
		var r SlideResult = slideLeft(col)
		_ = r
		var new []int = r.Row
		_ = new
		score = (score + r.Gain)
		var y int = 0
		_ = y
		for y < SIZE {
			if grid[y][x] != new[y] {
				moved = true
			}
			grid[y][x] = new[y]
			y = (y + 1)
		}
		x = (x + 1)
	}
	return MoveResult{
		Board: Board{
			Cells: grid,
		},
		Score: score,
		Moved: moved,
	}
}

func moveDown(b Board, score int) MoveResult {
	var grid [][]int = b.Cells
	_ = grid
	var moved bool = false
	_ = moved
	var x int = 0
	_ = x
	for x < SIZE {
		var col []int = reverseRow(getCol(b, x))
		_ = col
		var r SlideResult = slideLeft(col)
		_ = r
		col = r.Row
		score = (score + r.Gain)
		col = reverseRow(col)
		var y int = 0
		_ = y
		for y < SIZE {
			if grid[y][x] != col[y] {
				moved = true
			}
			grid[y][x] = col[y]
			y = (y + 1)
		}
		x = (x + 1)
	}
	return MoveResult{
		Board: Board{
			Cells: grid,
		},
		Score: score,
		Moved: moved,
	}
}

func hasMoves(b Board) bool {
	var y int = 0
	_ = y
	for y < SIZE {
		var x int = 0
		_ = x
		for x < SIZE {
			if b.Cells[y][x] == 0 {
				return true
			}
			if ((x + 1) < SIZE) && (b.Cells[y][x] == b.Cells[y][(x+1)]) {
				return true
			}
			if ((y + 1) < SIZE) && (b.Cells[y][x] == b.Cells[(y + 1)][x]) {
				return true
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return false
}

func has2048(b Board) bool {
	var y int = 0
	_ = y
	for y < SIZE {
		var x int = 0
		_ = x
		for x < SIZE {
			if b.Cells[y][x] >= 2048 {
				return true
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return false
}

var board Board

var r SpawnResult

var full bool

var score int

func main() {
	SIZE = 4
	board = newBoard()
	r = spawnTile(board)
	board = r.Board
	full = r.Full
	r = spawnTile(board)
	board = r.Board
	full = r.Full
	score = 0
	draw(board, score)
	for {
		fmt.Println("Move: ")
		var cmd string = _input()
		_ = cmd
		var moved bool = false
		_ = moved
		if (cmd == "a") || (cmd == "A") {
			var m MoveResult = moveLeft(board, score)
			_ = m
			board = m.Board
			score = m.Score
			moved = m.Moved
		}
		if (cmd == "d") || (cmd == "D") {
			var m MoveResult = moveRight(board, score)
			_ = m
			board = m.Board
			score = m.Score
			moved = m.Moved
		}
		if (cmd == "w") || (cmd == "W") {
			var m MoveResult = moveUp(board, score)
			_ = m
			board = m.Board
			score = m.Score
			moved = m.Moved
		}
		if (cmd == "s") || (cmd == "S") {
			var m MoveResult = moveDown(board, score)
			_ = m
			board = m.Board
			score = m.Score
			moved = m.Moved
		}
		if (cmd == "q") || (cmd == "Q") {
			break
		}
		if moved {
			var r2 SpawnResult = spawnTile(board)
			_ = r2
			board = r2.Board
			full = r2.Full
			if full && !hasMoves(board) {
				draw(board, score)
				fmt.Println("Game Over")
				break
			}
		}
		draw(board, score)
		if has2048(board) {
			fmt.Println("You win!")
			break
		}
		if !hasMoves(board) {
			fmt.Println("Game Over")
			break
		}
	}
}
