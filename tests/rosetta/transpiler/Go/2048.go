//go:build ignore

// Generated by Mochi v0.10.37 on 2025-07-23 09:48:10 GMT+7
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var _scanner = bufio.NewScanner(os.Stdin)

func _input() string {
	if !_scanner.Scan() {
		return ""
	}
	return _scanner.Text()
}

var SIZE int = 4

func newBoard() [][]int {
	var b [][]int = [][]int{}
	var y int = 0
	for y < SIZE {
		var row []int = []int{}
		var x int = 0
		for x < SIZE {
			row = append(row, 0)
			x = (x + 1)
		}
		b = append(b, row)
		y = (y + 1)
	}
	return b
}

func spawnTile(b [][]int) map[string]any {
	var empty [][]int = [][]int{}
	var y int = 0
	for y < SIZE {
		var x int = 0
		for x < SIZE {
			if b[y][x] == 0 {
				empty = append(empty, []int{x, y})
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	if len(empty) == 0 {
		return map[string]any{"board": b, "full": true}
	}
	var idx int = (_now() % len(empty))
	var cell []int = empty[idx]
	var val int = 4
	if (_now() % 10) < 9 {
		val = 2
	}
	b[cell[1]][cell[0]] = val
	return map[string]any{"board": b, "full": (len(empty) == 1)}
}

func pad(n int) string {
	var s string = fmt.Sprint(n)
	var pad int = (4 - len(s))
	var i int = 0
	var out string = ""
	for i < pad {
		out = (out + " ")
		i = (i + 1)
	}
	return (out + s)
}

func draw(b [][]int, score int) {
	fmt.Println(("Score: " + fmt.Sprint(score)))
	var y int = 0
	for y < SIZE {
		fmt.Println("+----+----+----+----+")
		var line string = "|"
		var x int = 0
		for x < SIZE {
			var v int = b[y][x]
			if v == 0 {
				line = (line + "    |")
			} else {
				line = ((line + pad(v)) + "|")
			}
			x = (x + 1)
		}
		fmt.Println(line)
		y = (y + 1)
	}
	fmt.Println("+----+----+----+----+")
	fmt.Println("W=Up S=Down A=Left D=Right Q=Quit")
}

func reverseRow(r []int) []int {
	var out []int = []int{}
	var i int = (len(r) - 1)
	for i >= 0 {
		out = append(out, r[i])
		i = (i - 1)
	}
	return out
}

func slideLeft(row []int) map[string]any {
	var xs []int = []int{}
	var i int = 0
	for i < len(row) {
		if row[i] != 0 {
			xs = append(xs, row[i])
		}
		i = (i + 1)
	}
	var res []int = []int{}
	var gain int = 0
	i = 0
	for i < len(xs) {
		if ((i + 1) < len(xs)) && (xs[i] == xs[(i+1)]) {
			var v int = (xs[i] * 2)
			gain = (gain + v)
			res = append(res, v)
			i = (i + 2)
		} else {
			res = append(res, xs[i])
			i = (i + 1)
		}
	}
	for len(res) < SIZE {
		res = append(res, 0)
	}
	return map[string]any{"row": res, "gain": gain}
}

func moveLeft(b [][]int, score int) map[string]any {
	var moved bool = false
	var y int = 0
	for y < SIZE {
		var r map[string]any = slideLeft(b[y])
		new := r["row"].([]int)
		score = (score + r["gain"].(int))
		var x int = 0
		for x < SIZE {
			if b[y][x] != new[x] {
				moved = true
			}
			b[y][x] = new[x]
			x = (x + 1)
		}
		y = (y + 1)
	}
	return map[string]any{"board": b, "score": score, "moved": moved}
}

func moveRight(b [][]int, score int) map[string]any {
	var moved bool = false
	var y int = 0
	for y < SIZE {
		var rev []int = reverseRow(b[y])
		var r map[string]any = slideLeft(rev)
		rev = r["row"].([]int)
		score = (score + r["gain"].(int))
		rev = reverseRow(rev)
		var x int = 0
		for x < SIZE {
			if b[y][x] != rev[x] {
				moved = true
			}
			b[y][x] = rev[x]
			x = (x + 1)
		}
		y = (y + 1)
	}
	return map[string]any{"board": b, "score": score, "moved": moved}
}

func getCol(b [][]int, x int) []int {
	var col []int = []int{}
	var y int = 0
	for y < SIZE {
		col = append(col, b[y][x])
		y = (y + 1)
	}
	return col
}

func setCol(b [][]int, x int, col []int) {
	var y int = 0
	for y < SIZE {
		b[y][x] = col[y]
		y = (y + 1)
	}
}

func moveUp(b [][]int, score int) map[string]any {
	var moved bool = false
	var x int = 0
	for x < SIZE {
		var col []int = getCol(b, x)
		var r map[string]any = slideLeft(col)
		new := r["row"].([]int)
		score = (score + r["gain"].(int))
		var y int = 0
		for y < SIZE {
			if b[y][x] != new[y] {
				moved = true
			}
			b[y][x] = new[y]
			y = (y + 1)
		}
		x = (x + 1)
	}
	return map[string]any{"board": b, "score": score, "moved": moved}
}

func moveDown(b [][]int, score int) map[string]any {
	var moved bool = false
	var x int = 0
	for x < SIZE {
		var col []int = reverseRow(getCol(b, x))
		var r map[string]any = slideLeft(col)
		col = r["row"].([]int)
		score = (score + r["gain"].(int))
		col = reverseRow(col)
		var y int = 0
		for y < SIZE {
			if b[y][x] != col[y] {
				moved = true
			}
			b[y][x] = col[y]
			y = (y + 1)
		}
		x = (x + 1)
	}
	return map[string]any{"board": b, "score": score, "moved": moved}
}

func hasMoves(b [][]int) bool {
	var y int = 0
	for y < SIZE {
		var x int = 0
		for x < SIZE {
			if b[y][x] == 0 {
				return true
			}
			if ((x + 1) < SIZE) && (b[y][x] == b[y][(x+1)]) {
				return true
			}
			if ((y + 1) < SIZE) && (b[y][x] == b[(y + 1)][x]) {
				return true
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return false
}

func has2048(b [][]int) bool {
	var y int = 0
	for y < SIZE {
		var x int = 0
		for x < SIZE {
			if b[y][x] >= 2048 {
				return true
			}
			x = (x + 1)
		}
		y = (y + 1)
	}
	return false
}

var board [][]int = newBoard()

var r map[string]any = spawnTile(board)

var full = r["full"].(bool)

var score int = 0

func main() {
	board = r["board"].([][]int)
	r = spawnTile(board)
	board = r["board"].([][]int)
	full = r["full"].(bool)
	draw(board, score)
	for true {
		fmt.Println("Move: ")
		var cmd string = _input()
		var moved bool = false
		if (cmd == "a") || (cmd == "A") {
			var m map[string]any = moveLeft(board, score)
			board = m["board"].([][]int)
			score = m["score"].(int)
			moved = m["moved"].(bool)
		}
		if (cmd == "d") || (cmd == "D") {
			var m map[string]any = moveRight(board, score)
			board = m["board"].([][]int)
			score = m["score"].(int)
			moved = m["moved"].(bool)
		}
		if (cmd == "w") || (cmd == "W") {
			var m map[string]any = moveUp(board, score)
			board = m["board"].([][]int)
			score = m["score"].(int)
			moved = m["moved"].(bool)
		}
		if (cmd == "s") || (cmd == "S") {
			var m map[string]any = moveDown(board, score)
			board = m["board"].([][]int)
			score = m["score"].(int)
			moved = m["moved"].(bool)
		}
		if (cmd == "q") || (cmd == "Q") {
			break
		}
		if moved {
			var r2 map[string]any = spawnTile(board)
			board = r2["board"].([][]int)
			full = r2["full"].(bool)
			if full && !hasMoves(board) {
				draw(board, score)
				fmt.Println("Game Over")
				break
			}
		}
		draw(board, score)
		if has2048(board) {
			fmt.Println("You win!")
			break
		}
		if !hasMoves(board) {
			fmt.Println("Game Over")
			break
		}
	}
}
