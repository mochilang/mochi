//go:build ignore

// Generated by Mochi v0.10.40 on 2025-07-25 21:27:45 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _parseIntStr(s string, base int) int { v, _ := strconv.ParseInt(s, base, 64); return int(v) }

func pow2(n int) int {
	var v int = 1
	_ = v
	var i int = 0
	_ = i
	for i < n {
		v = (v * 2)
		i = (i + 1)
	}
	return v
}

func lshift(x int, n int) int {
	return (x * pow2(n))
}

func rshift(x int, n int) int {
	return (x / pow2(n))
}

type Writer struct {
	Order string `json:"order"`
	Bits  int    `json:"bits"`
	Nbits int    `json:"nbits"`
	Data  []int  `json:"data"`
}

func NewWriter(order string) Writer {
	return Writer{
		Order: order,
		Bits:  0,
		Nbits: 0,
		Data:  []int{},
	}
}

func writeBitsLSB(w Writer, c int, width int) Writer {
	w.Bits = (w.Bits + lshift(c, w.Nbits))
	w.Nbits = (w.Nbits + width)
	for w.Nbits >= 8 {
		var b int = (w.Bits % 256)
		_ = b
		w.Data = append(w.Data, b)
		w.Bits = rshift(w.Bits, 8)
		w.Nbits = (w.Nbits - 8)
	}
	return w
}

func writeBitsMSB(w Writer, c int, width int) Writer {
	w.Bits = (w.Bits + lshift(c, ((32-width)-w.Nbits)))
	w.Nbits = (w.Nbits + width)
	for w.Nbits >= 8 {
		var b int = (rshift(w.Bits, 24) % 256)
		_ = b
		w.Data = append(w.Data, b)
		w.Bits = ((w.Bits % pow2(24)) * 256)
		w.Nbits = (w.Nbits - 8)
	}
	return w
}

func WriteBits(w Writer, c int, width int) Writer {
	if w.Order == "LSB" {
		return writeBitsLSB(w, c, width)
	}
	return writeBitsMSB(w, c, width)
}

func CloseWriter(w Writer) Writer {
	if w.Nbits > 0 {
		if w.Order == "MSB" {
			w.Bits = rshift(w.Bits, 24)
		}
		w.Data = append(w.Data, (w.Bits % 256))
	}
	w.Bits = 0
	w.Nbits = 0
	return w
}

type Reader struct {
	Order string `json:"order"`
	Data  []int  `json:"data"`
	IDx   int    `json:"idx"`
	Bits  int    `json:"bits"`
	Nbits int    `json:"nbits"`
}

func NewReader(data []int, order string) Reader {
	return Reader{
		Order: order,
		Data:  data,
		IDx:   0,
		Bits:  0,
		Nbits: 0,
	}
}

func readBitsLSB(r Reader, width int) map[string]any {
	for r.Nbits < width {
		if r.IDx >= len(r.Data) {
			return map[string]any{"val": 0, "eof": true}
		}
		var b int = r.Data[r.IDx]
		_ = b
		r.IDx = (r.IDx + 1)
		r.Bits = (r.Bits + lshift(b, r.Nbits))
		r.Nbits = (r.Nbits + 8)
	}
	var mask int = (pow2(width) - 1)
	_ = mask
	var out int = (r.Bits % (mask + 1))
	_ = out
	r.Bits = rshift(r.Bits, width)
	r.Nbits = (r.Nbits - width)
	return map[string]any{"val": out, "eof": false}
}

func readBitsMSB(r Reader, width int) map[string]any {
	for r.Nbits < width {
		if r.IDx >= len(r.Data) {
			return map[string]any{"val": 0, "eof": true}
		}
		var b int = r.Data[r.IDx]
		_ = b
		r.IDx = (r.IDx + 1)
		r.Bits = (r.Bits + lshift(b, (24-r.Nbits)))
		r.Nbits = (r.Nbits + 8)
	}
	var out int = rshift(r.Bits, (32 - width))
	_ = out
	r.Bits = ((r.Bits * pow2(width)) % pow2(32))
	r.Nbits = (r.Nbits - width)
	return map[string]any{"val": out, "eof": false}
}

func ReadBits(r Reader, width int) map[string]any {
	if r.Order == "LSB" {
		return readBitsLSB(r, width)
	}
	return readBitsMSB(r, width)
}

func toBinary(n int, bits int) string {
	var b string = ""
	_ = b
	var val int = n
	_ = val
	var i int = 0
	_ = i
	for i < bits {
		b = (fmt.Sprint((val % 2)) + b)
		val = (val / 2)
		i = (i + 1)
	}
	return b
}

func bytesToBits(bs []int) string {
	var out string = "["
	_ = out
	var i int = 0
	_ = i
	for i < len(bs) {
		out = (out + toBinary(bs[i], 8))
		if (i + 1) < len(bs) {
			out = (out + " ")
		}
		i = (i + 1)
	}
	out = (out + "]")
	return out
}

func bytesToHex(bs []int) string {
	var digits string = "0123456789ABCDEF"
	_ = digits
	var out string = ""
	_ = out
	var i int = 0
	_ = i
	for i < len(bs) {
		var b int = bs[i]
		_ = b
		var hi int = (b / 16)
		_ = hi
		var lo int = (b % 16)
		_ = lo
		out = ((out + string([]rune(digits)[hi:(hi+1)])) + string([]rune(digits)[lo:(lo+1)]))
		if (i + 1) < len(bs) {
			out = (out + " ")
		}
		i = (i + 1)
	}
	return out
}

func ord(ch string) int {
	var upper string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	_ = upper
	var lower string = "abcdefghijklmnopqrstuvwxyz"
	_ = lower
	var idx int = strings.Index(upper, ch)
	_ = idx
	if idx >= 0 {
		return (65 + idx)
	}
	idx = strings.Index(lower, ch)
	if idx >= 0 {
		return (97 + idx)
	}
	if (ch >= "0") && (ch <= "9") {
		return (48 + _parseIntStr(ch, 10)).(int)
	}
	if ch == " " {
		return 32
	}
	if ch == "." {
		return 46
	}
	return 0
}

func chr(n int) string {
	var upper string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	_ = upper
	var lower string = "abcdefghijklmnopqrstuvwxyz"
	_ = lower
	if (n >= 65) && (n < 91) {
		return string([]rune(upper)[(n - 65):(n - 64)])
	}
	if (n >= 97) && (n < 123) {
		return string([]rune(lower)[(n - 97):(n - 96)])
	}
	if (n >= 48) && (n < 58) {
		var digits string = "0123456789"
		_ = digits
		return string([]rune(digits)[(n - 48):(n - 47)])
	}
	if n == 32 {
		return " "
	}
	if n == 46 {
		return "."
	}
	return "?"
}

func bytesOfStr(s string) []int {
	var bs []int = []int{}
	_ = bs
	var i int = 0
	_ = i
	for i < len(s) {
		bs = append(bs, ord(string([]rune(s)[i:(i+1)])))
		i = (i + 1)
	}
	return bs
}

func bytesToDec(bs []int) string {
	var out string = ""
	_ = out
	var i int = 0
	_ = i
	for i < len(bs) {
		out = (out + fmt.Sprint(bs[i]))
		if (i + 1) < len(bs) {
			out = (out + " ")
		}
		i = (i + 1)
	}
	return out
}

func Example() {
	var message string = "This is a test."
	_ = message
	var msgBytes []int = bytesOfStr(message)
	_ = msgBytes
	fmt.Println(((("\"" + message) + "\" as bytes: ") + bytesToDec(msgBytes)))
	fmt.Println(("    original bits: " + bytesToBits(msgBytes)))
	var bw Writer = NewWriter("MSB")
	_ = bw
	var i int = 0
	_ = i
	for i < len(msgBytes) {
		bw = WriteBits(bw, msgBytes[i], 7)
		i = (i + 1)
	}
	bw = CloseWriter(bw)
	fmt.Println(("Written bitstream: " + bytesToBits(bw.Data)))
	fmt.Println(("Written bytes: " + bytesToHex(bw.Data)))
	var br Reader = NewReader(bw.Data, "MSB")
	_ = br
	var result string = ""
	_ = result
	for {
		var r map[string]any = ReadBits(br, 7)
		_ = r
		if r["eof"].(bool) {
			break
		}
		var v int = r["val"].(int)
		_ = v
		if v != 0 {
			result = (result + chr(v))
		}
	}
	fmt.Println((("Read back as \"" + result) + "\""))
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		start := _now()
		Example()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		end := _now()
		data := map[string]any{"name": "main", "duration_us": (end - start) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
