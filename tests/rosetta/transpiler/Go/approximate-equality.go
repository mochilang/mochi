//go:build ignore

// Generated by Mochi v0.10.40 on 2025-07-25 19:42:04 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	math "math"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func abs(x float64) float64 {
	if x < 0.0 {
		return (0 - x)
	}
	return x
}

func maxf(a float64, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

func isClose(a float64, b float64) bool {
	var relTol float64 = 1e-09
	_ = relTol
	var t float64 = math.Abs((a - b))
	_ = t
	var u float64 = (relTol * maxf(math.Abs(a), math.Abs(b)))
	_ = u
	return (t <= u)
}

func sqrtApprox(x float64) float64 {
	var guess float64 = x
	_ = guess
	var i int = 0
	_ = i
	for i < 10 {
		guess = ((guess + (x / guess)) / 2.0)
		i = (i + 1)
	}
	return guess
}

func mochiMain() {
	var root2 float64 = sqrtApprox(2.0)
	_ = root2
	var pairs [][]float64 = [][]float64{[]float64{1.0000000000000002e+14, 1.0000000000000002e+14}, []float64{100.01, 100.011}, []float64{(1.0000000000000002e+13 / 10000.0), 1.0000000000000001e+09}, []float64{0.001, 0.0010000001}, []float64{1.01e-22, 0.0}, []float64{(root2 * root2), 2.0}, []float64{((0 - root2) * root2), (0 - 2.0)}, []float64{100000000000000000.0, 100000000000000000.0}, []float64{3.141592653589793, 3.141592653589793}}
	_ = pairs
	for _, pair := range pairs {
		var a float64 = pair[0]
		_ = a
		var b float64 = pair[1]
		_ = b
		var s string = func() string {
			if isClose(a, b) {
				return "≈"
			} else {
				return "≉"
			}
		}()
		_ = s
		fmt.Println(((((fmt.Sprint(a) + " ") + s) + " ") + fmt.Sprint(b)))
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		start := _now()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		end := _now()
		data := map[string]any{"name": "main", "duration_us": (end - start) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
