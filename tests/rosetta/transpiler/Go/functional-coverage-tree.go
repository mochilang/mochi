//go:build ignore

// Generated by Mochi v0.10.55 on 2025-08-02 18:07:03 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _repeat(s string, n int) string {
	if n <= 0 {
		return ""
	}
	return strings.Repeat(s, n)
}

func pow10(n int) float64 {
	var r float64 = 1.0
	_ = r
	var i int = 0
	_ = i
	for i < n {
		r = (r * 10.0)
		i = (i + 1)
	}
	return r
}

func formatFloat(f float64, prec int) string {
	var scale float64 = pow10(prec)
	_ = scale
	var scaled float64 = ((f * scale) + 0.5)
	_ = scaled
	_ = scaled
	var n int = int(scaled)
	_ = n
	var digits string = fmt.Sprint(n)
	_ = digits
	for len(digits) <= prec {
		digits = ("0" + digits)
	}
	var intPart string = _substr(digits, 0, (len(digits) - prec))
	_ = intPart
	_ = intPart
	var fracPart string = _substr(digits, (len(digits) - prec), len(digits))
	_ = fracPart
	_ = fracPart
	return ((intPart + ".") + fracPart)
}

func padLeft(s string, w int) string {
	var res string = ""
	_ = res
	var n int = (w - len(s))
	_ = n
	for n > 0 {
		res = (res + " ")
		n = (n - 1)
	}
	return (res + s)
}

func repeat(ch string, n int) string {
	var s string = ""
	_ = s
	var i int = 0
	_ = i
	for i < n {
		s = (s + ch)
		i = (i + 1)
	}
	return s
}

func toFloat(i int) float64 {
	return float64(i)
}

func newNode(name string, weight int, coverage float64) map[string]any {
	return func(v any) map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.(map[string]any); ok {
			return vv
		}
		return nil
	}(map[string]any{"name": name, "weight": weight, "coverage": coverage, "children": []any{}})
}

func addChildren(n map[string]any, nodes []map[string]any) {
	var cs []any = func(v any) []any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []any{}
			}
			out := make([]any, len(arr))
			for i, x := range arr {
				out[i] = x.(any)
			}
			return out
		}
		return v.([]any)
	}(n["children"])
	_ = cs
	for _, node := range nodes {
		cs = append(cs, node)
	}
	n["children"] = cs
}

func setCoverage(n map[string]any, value float64) {
	n["coverage"] = value
}

func computeCoverage(n map[string]any) float64 {
	var cs []any = func(v any) []any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []any{}
			}
			out := make([]any, len(arr))
			for i, x := range arr {
				out[i] = x.(any)
			}
			return out
		}
		return v.([]any)
	}(n["children"])
	_ = cs
	if len(cs) == 0 {
		return n["coverage"].(float64)
	}
	var v1 float64 = 0.0
	_ = v1
	var v2 int = 0
	_ = v2
	for _, node := range cs {
		var m map[string]any = func(v any) map[string]any {
			if v == nil {
				return nil
			}
			if vv, ok := v.(map[string]any); ok {
				return vv
			}
			return nil
		}(node)
		_ = m
		var c float64 = computeCoverage(m)
		_ = c
		v1 = (v1 + (toFloat(m["weight"].(int)) * c))
		v2 = (v2 + m["weight"].(int))
	}
	return (v1 / toFloat(v2))
}

func spaces(n int) string {
	return _repeat(" ", n)
}

func show(n map[string]any, level int) {
	var indent int = (level * 4)
	_ = indent
	var name string = n["name"].(string)
	_ = name
	var nl int = (len(name) + indent)
	_ = nl
	var line string = (spaces(indent) + name)
	_ = line
	line = ((line + spaces((32 - nl))) + "|  ")
	line = ((line + padLeft(fmt.Sprint(n["weight"].(int)), 3)) + "   | ")
	line = ((line + formatFloat(computeCoverage(n), 6)) + " |")
	fmt.Println(line)
	var cs []any = func(v any) []any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []any{}
			}
			out := make([]any, len(arr))
			for i, x := range arr {
				out[i] = x.(any)
			}
			return out
		}
		return v.([]any)
	}(n["children"])
	_ = cs
	for _, child := range cs {
		show(func(v any) map[string]any {
			if v == nil {
				return nil
			}
			if vv, ok := v.(map[string]any); ok {
				return vv
			}
			return nil
		}(child), (level + 1))
	}
}

var house1 map[string]any

var house2 map[string]any

var h1_bedrooms map[string]any

var h1_bathrooms map[string]any

var h1_attic map[string]any

var h1_kitchen map[string]any

var h1_living_rooms map[string]any

var h1_basement map[string]any

var h1_garage map[string]any

var h1_garden map[string]any

var h2_upstairs map[string]any

var h2_groundfloor map[string]any

var h2_basement map[string]any

var h1_bathroom1 map[string]any

var h1_bathroom2 map[string]any

var h1_outside map[string]any

var h1_lounge map[string]any

var h1_dining map[string]any

var h1_conservatory map[string]any

var h1_playroom map[string]any

var h2_bedrooms map[string]any

var h2_bathroom map[string]any

var h2_toilet map[string]any

var h2_attics map[string]any

var h2_kitchen map[string]any

var h2_living_rooms map[string]any

var h2_wet_room map[string]any

var h2_garage map[string]any

var h2_garden map[string]any

var h2_hot_tub map[string]any

var h2_cellars map[string]any

var h2_wine_cellar map[string]any

var h2_cinema map[string]any

var h2_suite1 map[string]any

var h2_suite2 map[string]any

var h2_bedroom3 map[string]any

var h2_bedroom4 map[string]any

var h2_lounge map[string]any

var h2_dining map[string]any

var h2_conservatory map[string]any

var h2_playroom map[string]any

func mochiMain() {
	var cleaning map[string]any = newNode("cleaning", 1, 0.0)
	_ = cleaning
	addChildren(h1_bathrooms, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{h1_bathroom1, h1_bathroom2, h1_outside}))
	addChildren(h1_living_rooms, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{h1_lounge, h1_dining, h1_conservatory, h1_playroom}))
	addChildren(house1, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{h1_bedrooms, h1_bathrooms, h1_attic, h1_kitchen, h1_living_rooms, h1_basement, h1_garage, h1_garden}))
	addChildren(h2_bedrooms, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{h2_suite1, h2_suite2, h2_bedroom3, h2_bedroom4}))
	addChildren(h2_upstairs, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{h2_bedrooms, h2_bathroom, h2_toilet, h2_attics}))
	addChildren(h2_living_rooms, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{h2_lounge, h2_dining, h2_conservatory, h2_playroom}))
	addChildren(h2_groundfloor, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{h2_kitchen, h2_living_rooms, h2_wet_room, h2_garage, h2_garden, h2_hot_tub}))
	addChildren(h2_basement, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{h2_cellars, h2_wine_cellar, h2_cinema}))
	addChildren(house2, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{h2_upstairs, h2_groundfloor, h2_basement}))
	addChildren(cleaning, func(v any) []map[string]any {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []map[string]any{}
			}
			out := make([]map[string]any, len(arr))
			for i, x := range arr {
				out[i] = x.(map[string]any)
			}
			return out
		}
		return v.([]map[string]any)
	}([]any{house1, house2}))
	var topCoverage float64 = computeCoverage(cleaning)
	_ = topCoverage
	fmt.Println(("TOP COVERAGE = " + formatFloat(topCoverage, 6)))
	fmt.Println("")
	fmt.Println("NAME HIERARCHY                 | WEIGHT | COVERAGE |")
	show(cleaning, 0)
	setCoverage(h2_cinema, 1.0)
	var diff float64 = (computeCoverage(cleaning) - topCoverage)
	_ = diff
	fmt.Println("")
	fmt.Println("If the coverage of the Cinema node were increased from 0.75 to 1")
	fmt.Println(((("the top level coverage would increase by " + formatFloat(diff, 6)) + " to ") + formatFloat((topCoverage+diff), 6)))
	setCoverage(h2_cinema, 0.75)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		house1 = newNode("house1", 40, 0.0)
		house2 = newNode("house2", 60, 0.0)
		h1_bedrooms = newNode("bedrooms", 1, 0.25)
		h1_bathrooms = newNode("bathrooms", 1, 0.0)
		h1_attic = newNode("attic", 1, 0.75)
		h1_kitchen = newNode("kitchen", 1, 0.1)
		h1_living_rooms = newNode("living_rooms", 1, 0.0)
		h1_basement = newNode("basement", 1, 0.0)
		h1_garage = newNode("garage", 1, 0.0)
		h1_garden = newNode("garden", 1, 0.8)
		h2_upstairs = newNode("upstairs", 1, 0.0)
		h2_groundfloor = newNode("groundfloor", 1, 0.0)
		h2_basement = newNode("basement", 1, 0.0)
		h1_bathroom1 = newNode("bathroom1", 1, 0.5)
		h1_bathroom2 = newNode("bathroom2", 1, 0.0)
		h1_outside = newNode("outside_lavatory", 1, 1.0)
		h1_lounge = newNode("lounge", 1, 0.0)
		h1_dining = newNode("dining_room", 1, 0.0)
		h1_conservatory = newNode("conservatory", 1, 0.0)
		h1_playroom = newNode("playroom", 1, 1.0)
		h2_bedrooms = newNode("bedrooms", 1, 0.0)
		h2_bathroom = newNode("bathroom", 1, 0.0)
		h2_toilet = newNode("toilet", 1, 0.0)
		h2_attics = newNode("attics", 1, 0.6)
		h2_kitchen = newNode("kitchen", 1, 0.0)
		h2_living_rooms = newNode("living_rooms", 1, 0.0)
		h2_wet_room = newNode("wet_room_&_toilet", 1, 0.0)
		h2_garage = newNode("garage", 1, 0.0)
		h2_garden = newNode("garden", 1, 0.9)
		h2_hot_tub = newNode("hot_tub_suite", 1, 1.0)
		h2_cellars = newNode("cellars", 1, 1.0)
		h2_wine_cellar = newNode("wine_cellar", 1, 1.0)
		h2_cinema = newNode("cinema", 1, 0.75)
		h2_suite1 = newNode("suite_1", 1, 0.0)
		h2_suite2 = newNode("suite_2", 1, 0.0)
		h2_bedroom3 = newNode("bedroom_3", 1, 0.0)
		h2_bedroom4 = newNode("bedroom_4", 1, 0.0)
		h2_lounge = newNode("lounge", 1, 0.0)
		h2_dining = newNode("dining_room", 1, 0.0)
		h2_conservatory = newNode("conservatory", 1, 0.0)
		h2_playroom = newNode("playroom", 1, 0.0)
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
