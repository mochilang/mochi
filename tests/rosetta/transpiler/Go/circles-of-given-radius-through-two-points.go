//go:build ignore

// Generated by Mochi v0.10.54 on 2025-08-02 14:30:41 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

type Point struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
}

func sqrtApprox(x float64) float64 {
	var g float64 = x
	_ = g
	var i int = 0
	_ = i
	for i < 40 {
		g = ((g + (x / g)) / 2.0)
		i = (i + 1)
	}
	return g
}

func hypot(x float64, y float64) float64 {
	return sqrtApprox(((x * x) + (y * y)))
}

var Two string

var R0 string

var Co string

var CoR0 string

var Diam string

var Far string

func circles(p1 Point, p2 Point, r float64) []any {
	if (p1.X == p2.X) && (p1.Y == p2.Y) {
		if r == 0.0 {
			return []any{p1, p1, "Coincident points with r==0.0 describe a degenerate circle."}
		}
		return []any{p1, p2, "Coincident points describe an infinite number of circles."}
	}
	if r == 0.0 {
		return []any{p1, p2, "R==0.0 does not describe circles."}
	}
	var dx float64 = (p2.X - p1.X)
	_ = dx
	var dy float64 = (p2.Y - p1.Y)
	_ = dy
	var q float64 = hypot(dx, dy)
	_ = q
	if q > (2.0 * r) {
		return []any{p1, p2, "Points too far apart to form circles."}
	}
	var m Point = Point{
		X: ((p1.X + p2.X) / 2.0),
		Y: ((p1.Y + p2.Y) / 2.0),
	}
	_ = m
	_ = m
	if q == (2.0 * r) {
		return []any{m, m, "Points form a diameter and describe only a single circle."}
	}
	var d float64 = sqrtApprox(((r * r) - ((q * q) / 4.0)))
	_ = d
	var ox float64 = ((d * dx) / q)
	_ = ox
	_ = ox
	var oy float64 = ((d * dy) / q)
	_ = oy
	_ = oy
	return []any{Point{
		X: (m.X - oy),
		Y: (m.Y + ox),
	}, Point{
		X: (m.X + oy),
		Y: (m.Y - ox),
	}, "Two circles."}
}

var td [][]any

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		Two = "Two circles."
		R0 = "R==0.0 does not describe circles."
		Co = "Coincident points describe an infinite number of circles."
		CoR0 = "Coincident points with r==0.0 describe a degenerate circle."
		Diam = "Points form a diameter and describe only a single circle."
		Far = "Points too far apart to form circles."
		td = [][]any{[]any{Point{
			X: 0.1234,
			Y: 0.9876,
		}, Point{
			X: 0.8765,
			Y: 0.2345,
		}, 2.0}, []any{Point{
			X: 0.0,
			Y: 2.0,
		}, Point{
			X: 0.0,
			Y: 0.0,
		}, 1.0}, []any{Point{
			X: 0.1234,
			Y: 0.9876,
		}, Point{
			X: 0.1234,
			Y: 0.9876,
		}, 2.0}, []any{Point{
			X: 0.1234,
			Y: 0.9876,
		}, Point{
			X: 0.8765,
			Y: 0.2345,
		}, 0.5}, []any{Point{
			X: 0.1234,
			Y: 0.9876,
		}, Point{
			X: 0.1234,
			Y: 0.9876,
		}, 0.0}}
		for _, tc := range td {
			p1 := tc[0]
			_ = p1
			p2 := tc[1]
			_ = p2
			r := tc[2]
			_ = r
			fmt.Println((((("p1:  {" + fmt.Sprint(p1.(Point).X)) + " ") + fmt.Sprint(p1.(Point).Y)) + "}"))
			fmt.Println((((("p2:  {" + fmt.Sprint(p2.(Point).X)) + " ") + fmt.Sprint(p2.(Point).Y)) + "}"))
			fmt.Println(("r:  " + fmt.Sprint(r)))
			var res []any = circles(p1.(Point), p2.(Point), r.(float64))
			_ = res
			c1 := res[0]
			_ = c1
			c2 := res[1]
			_ = c2
			caseStr := res[2]
			_ = caseStr
			fmt.Println(("   " + fmt.Sprint(caseStr)))
			if (fmt.Sprint(caseStr) == "Points form a diameter and describe only a single circle.") || (fmt.Sprint(caseStr) == "Coincident points with r==0.0 describe a degenerate circle.") {
				fmt.Println((((("   Center:  {" + fmt.Sprint(c1.(Point).X)) + " ") + fmt.Sprint(c1.(Point).Y)) + "}"))
			} else {
				if fmt.Sprint(caseStr) == "Two circles." {
					fmt.Println((((("   Center 1:  {" + fmt.Sprint(c1.(Point).X)) + " ") + fmt.Sprint(c1.(Point).Y)) + "}"))
					fmt.Println((((("   Center 2:  {" + fmt.Sprint(c2.(Point).X)) + " ") + fmt.Sprint(c2.(Point).Y)) + "}"))
				}
			}
			fmt.Println("")
		}
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
