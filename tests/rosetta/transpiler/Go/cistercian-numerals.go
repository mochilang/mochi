//go:build ignore

// Generated by Mochi v0.10.54 on 2025-08-02 14:39:53 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var n [][]string

func initN() {
	var i int = 0
	_ = i
	for i < 15 {
		var row []string = []string{}
		_ = row
		var j int = 0
		_ = j
		for j < 11 {
			row = append(row, " ")
			j = (j + 1)
		}
		row[5] = "x"
		n = append(n, row)
		i = (i + 1)
	}
}

func horiz(c1 int, c2 int, r int) {
	var c int = c1
	_ = c
	for c <= c2 {
		n[r][c] = "x"
		c = (c + 1)
	}
}

func verti(r1 int, r2 int, c int) {
	var r int = r1
	_ = r
	for r <= r2 {
		n[r][c] = "x"
		r = (r + 1)
	}
}

func diagd(c1 int, c2 int, r int) {
	var c int = c1
	_ = c
	for c <= c2 {
		n[((r + c) - c1)][c] = "x"
		c = (c + 1)
	}
}

func diagu(c1 int, c2 int, r int) {
	var c int = c1
	_ = c
	for c <= c2 {
		n[((r - c) + c1)][c] = "x"
		c = (c + 1)
	}
}

var draw map[int]func()

func initDraw() {
	draw[1] = func() {
		horiz(6, 10, 0)
	}
	draw[2] = func() {
		horiz(6, 10, 4)
	}
	draw[3] = func() {
		diagd(6, 10, 0)
	}
	draw[4] = func() {
		diagu(6, 10, 4)
	}
	draw[5] = func() {
		draw[1]()
		draw[4]()
	}
	draw[6] = func() {
		verti(0, 4, 10)
	}
	draw[7] = func() {
		draw[1]()
		draw[6]()
	}
	draw[8] = func() {
		draw[2]()
		draw[6]()
	}
	draw[9] = func() {
		draw[1]()
		draw[8]()
	}
	draw[10] = func() {
		horiz(0, 4, 0)
	}
	draw[20] = func() {
		horiz(0, 4, 4)
	}
	draw[30] = func() {
		diagu(0, 4, 4)
	}
	draw[40] = func() {
		diagd(0, 4, 0)
	}
	draw[50] = func() {
		draw[10]()
		draw[40]()
	}
	draw[60] = func() {
		verti(0, 4, 0)
	}
	draw[70] = func() {
		draw[10]()
		draw[60]()
	}
	draw[80] = func() {
		draw[20]()
		draw[60]()
	}
	draw[90] = func() {
		draw[10]()
		draw[80]()
	}
	draw[100] = func() {
		horiz(6, 10, 14)
	}
	draw[200] = func() {
		horiz(6, 10, 10)
	}
	draw[300] = func() {
		diagu(6, 10, 14)
	}
	draw[400] = func() {
		diagd(6, 10, 10)
	}
	draw[500] = func() {
		draw[100]()
		draw[400]()
	}
	draw[600] = func() {
		verti(10, 14, 10)
	}
	draw[700] = func() {
		draw[100]()
		draw[600]()
	}
	draw[800] = func() {
		draw[200]()
		draw[600]()
	}
	draw[900] = func() {
		draw[100]()
		draw[800]()
	}
	draw[1000] = func() {
		horiz(0, 4, 14)
	}
	draw[2000] = func() {
		horiz(0, 4, 10)
	}
	draw[3000] = func() {
		diagd(0, 4, 10)
	}
	draw[4000] = func() {
		diagu(0, 4, 14)
	}
	draw[5000] = func() {
		draw[1000]()
		draw[4000]()
	}
	draw[6000] = func() {
		verti(10, 14, 0)
	}
	draw[7000] = func() {
		draw[1000]()
		draw[6000]()
	}
	draw[8000] = func() {
		draw[2000]()
		draw[6000]()
	}
	draw[9000] = func() {
		draw[1000]()
		draw[8000]()
	}
}

func printNumeral() {
	var i int = 0
	_ = i
	for i < 15 {
		var line string = ""
		_ = line
		var j int = 0
		_ = j
		for j < 11 {
			line = ((line + n[i][j]) + " ")
			j = (j + 1)
		}
		fmt.Println(line)
		i = (i + 1)
	}
	fmt.Println("")
}

var numbers []int

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		n = [][]string{}
		draw = map[int]func(){}
		initDraw()
		numbers = []int{0, 1, 20, 300, 4000, 5555, 6789, 9999}
		for _, number := range numbers {
			initN()
			fmt.Println((fmt.Sprint(number) + ":"))
			var num int = number
			_ = num
			var thousands int = (num / 1000)
			_ = thousands
			num = (num % 1000)
			var hundreds int = (num / 100)
			_ = hundreds
			num = (num % 100)
			var tens int = (num / 10)
			_ = tens
			var ones int = (num % 10)
			_ = ones
			if thousands > 0 {
				draw[(thousands * 1000)]()
			}
			if hundreds > 0 {
				draw[(hundreds * 100)]()
			}
			if tens > 0 {
				draw[(tens * 10)]()
			}
			if ones > 0 {
				draw[ones]()
			}
			printNumeral()
		}
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
