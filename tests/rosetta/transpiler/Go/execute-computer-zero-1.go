//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 23:54:32 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _split(s, sep string) []string {
	if sep == "" {
		sep = " "
	}
	return strings.Split(s, sep)
}

func _parseIntStr(s string, base int) int { v, _ := strconv.ParseInt(s, base, 64); return int(v) }

type Instruction struct {
	Label  string `json:"Label"`
	Opcode string `json:"Opcode"`
	Arg    string `json:"Arg"`
}

func trim(s string) string {
	var start int = 0
	_ = start
	for (start < len(s)) && ((string([]rune(s)[start:(start+1)]) == " ") || (string([]rune(s)[start:(start+1)]) == "\t")) {
		start = (start + 1)
	}
	var end int = len(s)
	_ = end
	for (end > start) && ((string([]rune(s)[(end-1):end]) == " ") || (string([]rune(s)[(end-1):end]) == "\t")) {
		end = (end - 1)
	}
	return _substr(s, start, end)
}

func split(s string, sep string) []string {
	var parts []string = []string{}
	_ = parts
	var cur string = ""
	_ = cur
	var i int = 0
	_ = i
	for i < len(s) {
		if ((len(sep) > 0) && ((i + len(sep)) <= len(s))) && (_substr(s, i, (i+len(sep))) == sep) {
			parts = append(parts, cur)
			cur = ""
			i = (i + len(sep))
		} else {
			cur = (cur + _substr(s, i, (i+1)))
			i = (i + 1)
		}
	}
	parts = append(parts, cur)
	return parts
}

func splitWS(s string) []string {
	var out []string = []string{}
	_ = out
	var cur string = ""
	_ = cur
	var i int = 0
	_ = i
	for i < len(s) {
		var ch string = _substr(s, i, (i + 1))
		_ = ch
		if (ch == " ") || (ch == "\t") {
			if len(cur) > 0 {
				out = append(out, cur)
				cur = ""
			}
		} else {
			cur = (cur + ch)
		}
		i = (i + 1)
	}
	if len(cur) > 0 {
		out = append(out, cur)
	}
	return out
}

func indexOf(s string, ch string) int {
	var i int = 0
	_ = i
	for i < len(s) {
		if _substr(s, i, (i+1)) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func parseIntStr(str string) int {
	var i int = 0
	_ = i
	var neg bool = false
	_ = neg
	if (len(str) > 0) && (string([]rune(str)[0:1]) == "-") {
		neg = true
		i = 1
	}
	var n int = 0
	_ = n
	var digits map[string]int = map[string]int{"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
	_ = digits
	for i < len(str) {
		n = ((n * 10) + digits[string([]rune(str)[i:(i+1)])])
		i = (i + 1)
	}
	if neg {
		n = (0 - n)
	}
	return n
}

func parseAsm(asm string) map[string]any {
	var lines []string = _split(asm, "\n")
	_ = lines
	var instrs []Instruction = []Instruction{}
	_ = instrs
	var labels map[string]int = map[string]int{}
	_ = labels
	var lineNum int = 0
	_ = lineNum
	var i int = 0
	_ = i
	for i < len(lines) {
		var line string = lines[i]
		_ = line
		if strings.Index(line, ";") != (0 - 1) {
			line = _substr(line, 0, strings.Index(line, ";"))
		}
		line = trim(line)
		var label string = ""
		_ = label
		if strings.Index(line, ":") != (0 - 1) {
			var idx int = strings.Index(line, ":")
			_ = idx
			label = trim(_substr(line, 0, idx))
			line = trim(_substr(line, (idx + 1), len(line)))
		}
		var opcode string = ""
		_ = opcode
		var arg string = ""
		_ = arg
		if len(line) > 0 {
			var parts []string = splitWS(line)
			_ = parts
			if len(parts) > 0 {
				opcode = parts[0]
			}
			if len(parts) > 1 {
				arg = parts[1]
			} else {
				ops := map[string]int{"NOP": 0, "LDA": 1, "STA": 2, "ADD": 3, "SUB": 4, "BRZ": 5, "JMP": 6, "STP": 7}
				_ = ops
				_ = ops
				if !func() bool {
					for _, v := range ops {
						if v == opcode {
							return true
						}
					}
					return false
				}().(bool) {
					arg = opcode
					opcode = ""
				}
			}
		}
		if label != "" {
			labels[label] = lineNum
		}
		instrs = append(instrs, Instruction{
			Label:  label,
			Opcode: opcode,
			Arg:    arg,
		})
		lineNum = (lineNum + 1)
		i = (i + 1)
	}
	return map[string]any{"instructions": instrs, "labels": labels}
}

func compile(p map[string]any) []int {
	var instrs []Instruction = func(v any) []Instruction {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]Instruction); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []Instruction{}
			}
			out := make([]Instruction, len(arr))
			for i, x := range arr {
				out[i] = x.(Instruction)
			}
			return out
		}
		return v.([]Instruction)
	}(p["instructions"])
	_ = instrs
	var labels map[string]int = func(v any) map[string]int {
		if v == nil {
			return map[string]int{}
		}
		if vv, ok := v.(map[string]int); ok {
			return vv
		}
		out := make(map[string]int)
		if m, ok := v.(map[string]any); ok {
			for k, vv := range m {
				if vi, ok2 := vv.(int); ok2 {
					out[k] = vi
				}
			}
		}
		return out
	}(p["labels"])
	_ = labels
	var bytecode []int = []int{}
	_ = bytecode
	var i int = 0
	_ = i
	opcodes := map[string]int{"NOP": 0, "LDA": 1, "STA": 2, "ADD": 3, "SUB": 4, "BRZ": 5, "JMP": 6, "STP": 7}
	_ = opcodes
	for i < len(instrs) {
		var ins Instruction = instrs[i]
		_ = ins
		var arg int = 0
		_ = arg
		if ins.Arg != "" {
			if func() bool { _, ok := labels[ins.Arg]; return ok }() {
				arg = labels[ins.Arg]
			} else {
				arg = _parseIntStr(ins.Arg, 10)
			}
		}
		var code int = 0
		_ = code
		if ins.Opcode != "" {
			code = opcodes[ins.Opcode]
		}
		bytecode = append(bytecode, ((code * 32) + arg))
		i = (i + 1)
	}
	for len(bytecode) < 32 {
		bytecode = append(bytecode, 0)
	}
	return bytecode
}

func floorMod(a int, b int) int {
	var r int = (a % b)
	_ = r
	if r < 0 {
		r = (r + b)
	}
	return r
}

func run(bytecode []int) int {
	var acc int = 0
	_ = acc
	var pc int = 0
	_ = pc
	var mem []int = []int{}
	_ = mem
	var i int = 0
	_ = i
	for i < len(bytecode) {
		mem = append(mem, bytecode[i])
		i = (i + 1)
	}
	for pc < 32 {
		var op int = (mem[pc] / 32)
		_ = op
		var arg int = (mem[pc] % 32)
		_ = arg
		pc = (pc + 1)
		if op == 0 {
			continue
		} else {
			if op == 1 {
				acc = mem[arg]
			} else {
				if op == 2 {
					mem[arg] = acc
				} else {
					if op == 3 {
						acc = floorMod((acc + mem[arg]), 256)
					} else {
						if op == 4 {
							acc = floorMod((acc - mem[arg]), 256)
						} else {
							if op == 5 {
								if acc == 0 {
									pc = arg
								}
							} else {
								if op == 6 {
									pc = arg
								} else {
									if op == 7 {
										break
									} else {
										break
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return acc
}

func execute(asm string) int {
	var parsed map[string]any = parseAsm(asm)
	_ = parsed
	var bc []int = compile(parsed)
	_ = bc
	_ = bc
	return run(func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(bc))
}

func mochiMain() {
	var examples []string = []string{(((("LDA   x\n" + "ADD   y       ; accumulator = x + y\n") + "STP\n") + "x:            2\n") + "y:            2"), ((((((((((((("loop:   LDA   prodt\n" + "        ADD   x\n") + "        STA   prodt\n") + "        LDA   y\n") + "        SUB   one\n") + "        STA   y\n") + "        BRZ   done\n") + "        JMP   loop\n") + "done:   LDA   prodt   ; to display it\n") + "        STP\n") + "x:            8\n") + "y:            7\n") + "prodt:        0\n") + "one:          1"), ((((((((((((((((("loop:   LDA   n\n" + "        STA   temp\n") + "        ADD   m\n") + "        STA   n\n") + "        LDA   temp\n") + "        STA   m\n") + "        LDA   count\n") + "        SUB   one\n") + "        BRZ   done\n") + "        STA   count\n") + "        JMP   loop\n") + "done:   LDA   n       ; to display it\n") + "        STP\n") + "m:            1\n") + "n:            1\n") + "temp:         0\n") + "count:        8       ; valid range: 1-11\n") + "one:          1"), ((((((((((((((((((((((((((((((("start:  LDA   load\n" + "ADD   car     ; head of list\n") + "STA   ldcar\n") + "ADD   one\n") + "STA   ldcdr   ; next CONS cell\n") + "ldcar:  NOP\n") + "STA   value\n") + "ldcdr:  NOP\n") + "BRZ   done    ; 0 stands for NIL\n") + "STA   car\n") + "JMP   start\n") + "done:   LDA   value   ; CAR of last CONS\n") + "STP\n") + "load:   LDA   0\n") + "value:        0\n") + "car:          28\n") + "one:          1\n") + "                        ; order of CONS cells\n") + "                        ; in memory\n") + "                        ; does not matter\n") + "        6\n") + "        0       ; 0 stands for NIL\n") + "        2       ; (CADR ls)\n") + "        26      ; (CDDR ls) -- etc.\n") + "        5\n") + "        20\n") + "        3\n") + "        30\n") + "        1       ; value of (CAR ls)\n") + "        22      ; points to (CDR ls)\n") + "        4\n") + "        24"), (((("LDA  3\n" + "SUB  4\n") + "STP  0\n") + "         0\n") + "         255"), (((("LDA  3\n" + "SUB  4\n") + "STP  0\n") + "                0\n") + "                1"), (((("LDA  3\n" + "ADD  4\n") + "STP  0\n") + "                1\n") + "                255")}
	_ = examples
	var i int = 0
	_ = i
	for i < len(examples) {
		var res int = execute(examples[i])
		_ = res
		fmt.Println(fmt.Sprint(res))
		i = (i + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
