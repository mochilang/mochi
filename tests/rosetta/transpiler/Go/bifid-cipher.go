//go:build ignore

// Generated by Mochi v0.10.39 on 2025-07-24 17:33:48 GMT+7
package main

import (
	"fmt"
	"strings"
)

func square_to_maps(square [][]string) map[string]any {
	var emap map[string][]int = map[string][]int{}
	_ = emap
	var dmap map[string]string = map[string]string{}
	_ = dmap
	var x int = 0
	_ = x
	for x < len(square) {
		var row []string = square[x]
		_ = row
		var y int = 0
		_ = y
		for y < len(row) {
			var ch string = row[y]
			_ = ch
			emap[ch] = []int{x, y}
			dmap[((fmt.Sprint(x) + ",") + fmt.Sprint(y))] = ch
			y = (y + 1)
		}
		x = (x + 1)
	}
	return map[string]any{"e": emap, "d": dmap}
}

func remove_space(text string, emap map[string][]int) string {
	var s string = strings.ToUpper(text)
	_ = s
	var out string = ""
	_ = out
	var i int = 0
	_ = i
	for i < len(s) {
		var ch string = string([]rune(s)[i:(i + 1)])
		_ = ch
		if (ch != " ") && func() bool { _, ok := emap[ch]; return ok }() {
			out = (out + ch)
		}
		i = (i + 1)
	}
	return out
}

func encrypt(text string, emap map[string][]int, dmap map[string]string) string {
	text = remove_space(text, emap)
	var row0 []int = []int{}
	_ = row0
	var row1 []int = []int{}
	_ = row1
	var i int = 0
	_ = i
	for i < len(text) {
		var ch string = string([]rune(text)[i:(i + 1)])
		_ = ch
		var xy []int = emap[ch]
		_ = xy
		row0 = append(row0, xy[0])
		row1 = append(row1, xy[1])
		i = (i + 1)
	}
	for _, v := range row1 {
		row0 = append(row0, v)
	}
	var res string = ""
	_ = res
	var j int = 0
	_ = j
	for j < len(row0) {
		var key string = ((fmt.Sprint(row0[j]) + ",") + fmt.Sprint(row0[(j+1)]))
		_ = key
		res = (res + dmap[key])
		j = (j + 2)
	}
	return res
}

func decrypt(text string, emap map[string][]int, dmap map[string]string) string {
	text = remove_space(text, emap)
	var coords []int = []int{}
	_ = coords
	var i int = 0
	_ = i
	for i < len(text) {
		var ch string = string([]rune(text)[i:(i + 1)])
		_ = ch
		var xy []int = emap[ch]
		_ = xy
		coords = append(coords, xy[0])
		coords = append(coords, xy[1])
		i = (i + 1)
	}
	var half int = (len(coords) / 2)
	_ = half
	var k1 []int = []int{}
	_ = k1
	var k2 []int = []int{}
	_ = k2
	var idx int = 0
	_ = idx
	for idx < half {
		k1 = append(k1, coords[idx])
		idx = (idx + 1)
	}
	for idx < len(coords) {
		k2 = append(k2, coords[idx])
		idx = (idx + 1)
	}
	var res string = ""
	_ = res
	var j int = 0
	_ = j
	for j < half {
		var key string = ((fmt.Sprint(k1[j]) + ",") + fmt.Sprint(k2[j]))
		_ = key
		res = (res + dmap[key])
		j = (j + 1)
	}
	return res
}

func mochiMain() {
	var squareRosetta [][]string = [][]string{[]string{"A", "B", "C", "D", "E"}, []string{"F", "G", "H", "I", "K"}, []string{"L", "M", "N", "O", "P"}, []string{"Q", "R", "S", "T", "U"}, []string{"V", "W", "X", "Y", "Z"}, []string{"J", "1", "2", "3", "4"}}
	_ = squareRosetta
	var squareWikipedia [][]string = [][]string{[]string{"B", "G", "W", "K", "Z"}, []string{"Q", "P", "N", "D", "S"}, []string{"I", "O", "A", "X", "E"}, []string{"F", "C", "L", "U", "M"}, []string{"T", "H", "Y", "V", "R"}, []string{"J", "1", "2", "3", "4"}}
	_ = squareWikipedia
	var textRosetta string = "0ATTACKATDAWN"
	_ = textRosetta
	var textWikipedia string = "FLEEATONCE"
	_ = textWikipedia
	var textTest string = "The invasion will start on the first of January"
	_ = textTest
	var maps map[string]any = square_to_maps(squareRosetta)
	_ = maps
	var emap map[string][]int = maps["e"].(map[string][]int)
	_ = emap
	var dmap map[string]string = maps["d"].(map[string]string)
	_ = dmap
	fmt.Println("from Rosettacode")
	fmt.Println(("original:\t " + textRosetta))
	var s string = encrypt(textRosetta, emap, dmap)
	_ = s
	fmt.Println(("codiert:\t " + s))
	s = decrypt(s, emap, dmap)
	fmt.Println(("and back:\t " + s))
	maps = square_to_maps(squareWikipedia)
	emap = maps["e"].(map[string][]int)
	dmap = maps["d"].(map[string]string)
	fmt.Println("from Wikipedia")
	fmt.Println(("original:\t " + textWikipedia))
	s = encrypt(textWikipedia, emap, dmap)
	fmt.Println(("codiert:\t " + s))
	s = decrypt(s, emap, dmap)
	fmt.Println(("and back:\t " + s))
	maps = square_to_maps(squareWikipedia)
	emap = maps["e"].(map[string][]int)
	dmap = maps["d"].(map[string]string)
	fmt.Println("from Rosettacode long part")
	fmt.Println(("original:\t " + textTest))
	s = encrypt(textTest, emap, dmap)
	fmt.Println(("codiert:\t " + s))
	s = decrypt(s, emap, dmap)
	fmt.Println(("and back:\t " + s))
}

func main() {
	mochiMain()
}
