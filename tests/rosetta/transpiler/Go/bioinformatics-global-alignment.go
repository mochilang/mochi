//go:build ignore

// Generated by Mochi v0.10.39 on 2025-07-24 19:02:05 GMT+7
package main

import (
	"fmt"
)

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func padLeft(s string, w int) string {
	var res string = ""
	_ = res
	var n int = (w - len(s))
	_ = n
	for n > 0 {
		res = (res + " ")
		n = (n - 1)
	}
	return (res + s)
}

func indexOfFrom(s string, ch string, start int) int {
	var i int = start
	_ = i
	for i < len(s) {
		if _substr(s, i, (i+1)) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func containsStr(s string, sub string) bool {
	var i int = 0
	_ = i
	var sl int = len(s)
	_ = sl
	var subl int = len(sub)
	_ = subl
	for i <= (sl - subl) {
		if _substr(s, i, (i+subl)) == sub {
			return true
		}
		i = (i + 1)
	}
	return false
}

func distinct(slist []string) []string {
	var res []string = []string{}
	_ = res
	for _, _ch := range slist {
		s := string(_ch)
		var found bool = false
		_ = found
		for _, _ch := range res {
			r := string(_ch)
			if r == s {
				found = true
				break
			}
		}
		if !found {
			res = append(res, s)
		}
	}
	return res
}

func permutations(xs []string) [][]string {
	if len(xs) <= 1 {
		return [][]string{xs}
	}
	var res [][]string = [][]string{}
	_ = res
	var i int = 0
	_ = i
	for i < len(xs) {
		var rest []string = []string{}
		_ = rest
		var j int = 0
		_ = j
		for j < len(xs) {
			if j != i {
				rest = append(rest, xs[j])
			}
			j = (j + 1)
		}
		var subs [][]string = permutations(rest)
		_ = subs
		for _, p := range subs {
			var perm []string = []string{xs[i]}
			_ = perm
			var k int = 0
			_ = k
			for k < len(p) {
				perm = append(perm, p[k])
				k = (k + 1)
			}
			res = append(res, perm)
		}
		i = (i + 1)
	}
	return res
}

func headTailOverlap(s1 string, s2 string) int {
	var start int = 0
	_ = start
	for {
		var ix int = indexOfFrom(s1, string([]rune(s2)[0:1]), start)
		_ = ix
		if ix == (0 - 1) {
			return 0
		}
		start = ix
		if _substr(s2, 0, (len(s1)-start)) == _substr(s1, start, len(s1)) {
			return (len(s1) - start)
		}
		start = (start + 1)
	}
}

func deduplicate(slist []string) []string {
	var arr []string = distinct(slist)
	_ = arr
	var filtered []string = []string{}
	_ = filtered
	var i int = 0
	_ = i
	for i < len(arr) {
		var s1 string = arr[i]
		_ = s1
		var within bool = false
		_ = within
		var j int = 0
		_ = j
		for j < len(arr) {
			if (j != i) && containsStr(arr[j], s1) {
				within = true
				break
			}
			j = (j + 1)
		}
		if !within {
			filtered = append(filtered, s1)
		}
		i = (i + 1)
	}
	return filtered
}

func joinAll(ss []string) string {
	var out string = ""
	_ = out
	for _, _ch := range ss {
		s := string(_ch)
		out = (out + s)
	}
	return out
}

func shortestCommonSuperstring(slist []string) string {
	var ss []string = deduplicate(slist)
	_ = ss
	var shortest string = joinAll(ss)
	_ = shortest
	var perms [][]string = permutations(ss)
	_ = perms
	var idx int = 0
	_ = idx
	for idx < len(perms) {
		var perm []string = perms[idx]
		_ = perm
		var sup string = perm[0]
		_ = sup
		var i int = 0
		_ = i
		for i < (len(ss) - 1) {
			var ov int = headTailOverlap(perm[i], perm[(i+1)])
			_ = ov
			sup = (sup + _substr(perm[(i+1)], ov, len(perm[(i+1)])))
			i = (i + 1)
		}
		if len(sup) < len(shortest) {
			shortest = sup
		}
		idx = (idx + 1)
	}
	return shortest
}

func printCounts(seq string) {
	var a int = 0
	_ = a
	var c int = 0
	_ = c
	var g int = 0
	_ = g
	var t int = 0
	_ = t
	var i int = 0
	_ = i
	for i < len(seq) {
		var ch string = _substr(seq, i, (i + 1))
		_ = ch
		if ch == "A" {
			a = (a + 1)
		} else {
			if ch == "C" {
				c = (c + 1)
			} else {
				if ch == "G" {
					g = (g + 1)
				} else {
					if ch == "T" {
						t = (t + 1)
					}
				}
			}
		}
		i = (i + 1)
	}
	var total int = len(seq)
	_ = total
	fmt.Println((("\nNucleotide counts for " + seq) + ":\n"))
	fmt.Println((padLeft("A", 10) + padLeft(fmt.Sprint(a), 12)))
	fmt.Println((padLeft("C", 10) + padLeft(fmt.Sprint(c), 12)))
	fmt.Println((padLeft("G", 10) + padLeft(fmt.Sprint(g), 12)))
	fmt.Println((padLeft("T", 10) + padLeft(fmt.Sprint(t), 12)))
	fmt.Println((padLeft("Other", 10) + padLeft(fmt.Sprint((total-(((a+c)+g)+t))), 12)))
	fmt.Println("  ____________________")
	fmt.Println((padLeft("Total length", 14) + padLeft(fmt.Sprint(total), 8)))
}

func mochiMain() {
	var tests [][]string = [][]string{[]string{"TA", "AAG", "TA", "GAA", "TA"}, []string{"CATTAGGG", "ATTAG", "GGG", "TA"}, []string{"AAGAUGGA", "GGAGCGCAUC", "AUCGCAAUAAGGA"}, []string{"ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT", "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT", "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC", "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC", "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT", "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"}}
	_ = tests
	for _, seqs := range tests {
		var scs string = shortestCommonSuperstring(seqs)
		_ = scs
		printCounts(scs)
	}
}

func main() {
	mochiMain()
}
