//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 16:36:24 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _parseIntStr(s string, base int) int { v, _ := strconv.ParseInt(s, base, 64); return int(v) }

func dbRec(k int, n int, t int, p int, a []int, seq []int) []int {
	if t > n {
		if (n % p) == 0 {
			var j int = 1
			for j <= p {
				seq = append(seq, a[j])
				j = (j + 1)
			}
		}
	} else {
		a[t] = a[(t - p)]
		seq = dbRec(k, n, (t + 1), p, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(a), func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(seq))
		var j int = (a[(t-p)] + 1)
		for j < k {
			a[t] = j
			seq = dbRec(k, n, (t + 1), t, func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(a), func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(seq))
			j = (j + 1)
		}
	}
	return seq
}

func deBruijn(k int, n int) string {
	var digits string = "0123456789"
	var alphabet string = digits
	if k < 10 {
		alphabet = string([]rune(digits)[0:k])
	}
	var a []int = []int{}
	var i int = 0
	for i < (k * n) {
		a = append(a, 0)
		i = (i + 1)
	}
	var seq []int = []int{}
	seq = dbRec(k, n, 1, 1, func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(a), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(seq))
	var b string = ""
	var idx int = 0
	for idx < len(seq) {
		b = (b + string([]rune(alphabet)[seq[idx]]))
		idx = (idx + 1)
	}
	b = (b + string([]rune(b)[0:(n-1)]))
	return b
}

func allDigits(s string) bool {
	var i int = 0
	for i < len(s) {
		var ch string = string([]rune(s)[i:(i + 1)])
		if (ch < "0") || (ch > "9") {
			return false
		}
		i = (i + 1)
	}
	return true
}

func parseIntStr(str string) int {
	var n int = 0
	var i int = 0
	for i < len(str) {
		n = ((n * 10) + func() int { n, _ := strconv.Atoi(string([]rune(str)[i:(i + 1)])); return n }())
		i = (i + 1)
	}
	return n
}

func validate(db string) {
	var le int = len(db)
	var found []int = []int{}
	var i int = 0
	for i < 10000 {
		found = append(found, 0)
		i = (i + 1)
	}
	var j int = 0
	for j < (le - 3) {
		var s string = string([]rune(db)[j:(j + 4)])
		if allDigits(s) {
			var n int = _parseIntStr(s, 10)
			found[n] = (found[n] + 1)
		}
		j = (j + 1)
	}
	var errs []string = []string{}
	var k int = 0
	for k < 10000 {
		if found[k] == 0 {
			errs = append(errs, (("    PIN number " + padLeft(k, 4)) + " missing"))
		} else {
			if found[k] > 1 {
				errs = append(errs, (((("    PIN number " + padLeft(k, 4)) + " occurs ") + fmt.Sprint(found[k])) + " times"))
			}
		}
		k = (k + 1)
	}
	var lerr int = len(errs)
	if lerr == 0 {
		fmt.Println("  No errors found")
	} else {
		var pl string = "s"
		if lerr == 1 {
			pl = ""
		}
		fmt.Println((((("  " + fmt.Sprint(lerr)) + " error") + pl) + " found:"))
		var msg string = joinStr(func(v any) []string {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]string); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []string{}
				}
				out := make([]string, len(arr))
				for i, x := range arr {
					out[i] = x.(string)
				}
				return out
			}
			return v.([]string)
		}(errs), "\n")
		fmt.Println(msg)
	}
}

func padLeft(n int, width int) string {
	var s string = fmt.Sprint(n)
	for len(s) < width {
		s = ("0" + s)
	}
	return s
}

func joinStr(xs []string, sep string) string {
	var res string = ""
	var i int = 0
	for i < len(xs) {
		if i > 0 {
			res = (res + sep)
		}
		res = (res + xs[i])
		i = (i + 1)
	}
	return res
}

func reverse(s string) string {
	var out string = ""
	var i int = (len(s) - 1)
	for i >= 0 {
		out = (out + string([]rune(s)[i:(i+1)]))
		i = (i - 1)
	}
	return out
}

func mochiMain() {
	var db string = deBruijn(10, 4)
	var le int = len(db)
	fmt.Println(("The length of the de Bruijn sequence is " + fmt.Sprint(le)))
	fmt.Println("\nThe first 130 digits of the de Bruijn sequence are:")
	fmt.Println(string([]rune(db)[0:130]))
	fmt.Println("\nThe last 130 digits of the de Bruijn sequence are:")
	fmt.Println(string([]rune(db)[(le - 130):]))
	fmt.Println("\nValidating the de Bruijn sequence:")
	validate(db)
	fmt.Println("\nValidating the reversed de Bruijn sequence:")
	var dbr string = reverse(db)
	validate(dbr)
	db = ((string([]rune(db)[0:4443]) + ".") + string([]rune(db)[4444:len(db)]))
	fmt.Println("\nValidating the overlaid de Bruijn sequence:")
	validate(db)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
