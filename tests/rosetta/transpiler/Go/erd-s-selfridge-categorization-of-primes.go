//go:build ignore

// Generated by Mochi v0.10.42 on 2025-07-27 23:49:03 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func generatePrimes(n int) []int {
	var primes []int = []int{2}
	_ = primes
	var cand int = 3
	_ = cand
	for len(primes) < n {
		var isP bool = true
		_ = isP
		var i int = 0
		_ = i
		for i < len(primes) {
			var p int = primes[i]
			_ = p
			if (p * p) > cand {
				break
			}
			if (cand % p) == 0 {
				isP = false
				break
			}
			i = (i + 1)
		}
		if isP {
			primes = append(primes, cand)
		}
		cand = (cand + 2)
	}
	return primes
}

func primeFactors(n int, primes []int) []int {
	var factors []int = []int{}
	_ = factors
	var num int = n
	_ = num
	var i int = 0
	_ = i
	for (i < len(primes)) && ((primes[i] * primes[i]) <= num) {
		var p int = primes[i]
		_ = p
		for (num % p) == 0 {
			factors = append(factors, p)
			num = (num / p)
		}
		i = (i + 1)
	}
	if num > 1 {
		factors = append(factors, num)
	}
	return factors
}

var prevCats map[int]int

func cat(p int, primes []int) int {
	if func() bool { _, ok := prevCats[p]; return ok }() {
		return prevCats[p]
	}
	var pf []int = primeFactors((p + 1), func(v any) []int {
		if v == nil {
			return nil
		}
		if vv, ok := v.([]int); ok {
			return vv
		}
		if arr, ok := v.([]any); ok {
			if len(arr) == 0 {
				return []int{}
			}
			out := make([]int, len(arr))
			for i, x := range arr {
				out[i] = x.(int)
			}
			return out
		}
		return v.([]int)
	}(primes))
	_ = pf
	var all23 bool = true
	_ = all23
	for _, f := range pf {
		if (f != 2) && (f != 3) {
			all23 = false
			break
		}
	}
	if all23 {
		prevCats[p] = 1
		return 1
	}
	if p > 2 {
		var unique []int = []int{}
		_ = unique
		var last int = (0 - 1)
		_ = last
		for _, f := range pf {
			if f != last {
				unique = append(unique, f)
				last = f
			}
		}
		pf = unique
	}
	var c int = 2
	_ = c
	for c <= 11 {
		var ok bool = true
		_ = ok
		for _, f := range pf {
			if cat(f, func(v any) []int {
				if v == nil {
					return nil
				}
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok {
					if len(arr) == 0 {
						return []int{}
					}
					out := make([]int, len(arr))
					for i, x := range arr {
						out[i] = x.(int)
					}
					return out
				}
				return v.([]int)
			}(primes)) >= c {
				ok = false
				break
			}
		}
		if ok {
			prevCats[p] = c
			return c
		}
		c = (c + 1)
	}
	prevCats[p] = 12
	return 12
}

func padLeft(n int, width int) string {
	var s string = fmt.Sprint(n)
	_ = s
	for len(s) < width {
		s = (" " + s)
	}
	return s
}

func mochiMain() {
	var primes []int = generatePrimes(1000)
	_ = primes
	var es [][]int = [][]int{}
	_ = es
	for _i := 0; _i < 12; _i++ {
		es = append(es, []int{})
	}
	fmt.Println("First 200 primes:\n")
	var idx int = 0
	_ = idx
	for idx < 200 {
		var p int = primes[idx]
		_ = p
		var c int = cat(p, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(primes))
		_ = c
		es[(c - 1)] = append(es[(c-1)], p)
		idx = (idx + 1)
	}
	var c int = 1
	_ = c
	for c <= 6 {
		if len(es[(c-1)]) > 0 {
			fmt.Println((("Category " + fmt.Sprint(c)) + ":"))
			fmt.Println(fmt.Sprint(es[(c - 1)]))
			fmt.Println("")
		}
		c = (c + 1)
	}
	fmt.Println("First thousand primes:\n")
	for idx < 1000 {
		var p int = primes[idx]
		_ = p
		var cv int = cat(p, func(v any) []int {
			if v == nil {
				return nil
			}
			if vv, ok := v.([]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok {
				if len(arr) == 0 {
					return []int{}
				}
				out := make([]int, len(arr))
				for i, x := range arr {
					out[i] = x.(int)
				}
				return out
			}
			return v.([]int)
		}(primes))
		_ = cv
		es[(cv - 1)] = append(es[(cv-1)], p)
		idx = (idx + 1)
	}
	c = 1
	for c <= 12 {
		var e []int = es[(c - 1)]
		_ = e
		if len(e) > 0 {
			var line string = ((((((("Category " + padLeft(c, 2)) + ": First = ") + padLeft(e[0], 7)) + "  Last = ") + padLeft(e[(len(e)-1)], 8)) + "  Count = ") + padLeft(len(e), 6))
			_ = line
			fmt.Println(line)
		}
		c = (c + 1)
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		prevCats = map[int]int{}
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
