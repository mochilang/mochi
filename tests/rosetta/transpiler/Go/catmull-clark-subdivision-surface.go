//go:build ignore

// Generated by Mochi v0.10.40 on 2025-07-26 12:08:32 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

type Point struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
	Z float64 `json:"z"`
}

type Edge struct {
	Pn1 int   `json:"pn1"`
	Pn2 int   `json:"pn2"`
	Fn1 int   `json:"fn1"`
	Fn2 int   `json:"fn2"`
	Cp  Point `json:"cp"`
}

type PointEx struct {
	P Point `json:"p"`
	N int   `json:"n"`
}

func indexOf(s string, ch string) int {
	var i int = 0
	_ = i
	for i < len(s) {
		if _substr(s, i, (i+1)) == ch {
			return i
		}
		i = (i + 1)
	}
	return (0 - 1)
}

func fmt4(x float64) string {
	var y float64 = (x * 10000.0)
	_ = y
	if y >= 0 {
		y = (y + 0.5)
	} else {
		y = (y - 0.5)
	}
	y = (float64(int(y)) / 10000.0)
	var s string = fmt.Sprint(y)
	_ = s
	var dot int = strings.Index(s, ".")
	_ = dot
	if dot == (0 - 1) {
		s = (s + ".0000")
	} else {
		var decs int = ((len(s) - dot) - 1)
		_ = decs
		if decs > 4 {
			s = _substr(s, 0, (dot + 5))
		} else {
			for decs < 4 {
				s = (s + "0")
				decs = (decs + 1)
			}
		}
	}
	if x >= 0.0 {
		s = (" " + s)
	}
	return s
}

func fmt2(n int) string {
	var s string = fmt.Sprint(n)
	_ = s
	if len(s) < 2 {
		return (" " + s)
	}
	return s
}

func sumPoint(p1 Point, p2 Point) Point {
	return Point{
		X: (p1.X + p2.X),
		Y: (p1.Y + p2.Y),
		Z: (p1.Z + p2.Z),
	}
}

func mulPoint(p Point, m float64) Point {
	return Point{
		X: (p.X * m),
		Y: (p.Y * m),
		Z: (p.Z * m),
	}
}

func divPoint(p Point, d float64) Point {
	return mulPoint(p, (1.0 / d))
}

func centerPoint(p1 Point, p2 Point) Point {
	return divPoint(sumPoint(p1, p2), 2.0)
}

func getFacePoints(points []Point, faces [][]int) []Point {
	var facePoints []Point = []Point{}
	_ = facePoints
	var i int = 0
	_ = i
	for i < len(faces) {
		var face []int = faces[i]
		_ = face
		var fp Point = Point{
			X: 0.0,
			Y: 0.0,
			Z: 0.0,
		}
		_ = fp
		for _, idx := range face {
			fp = sumPoint(fp, points[idx])
		}
		fp = divPoint(fp, float64(len(face)))
		facePoints = append(facePoints, fp)
		i = (i + 1)
	}
	return facePoints
}

func sortEdges(edges [][]int) [][]int {
	var res [][]int = [][]int{}
	_ = res
	var tmp [][]int = edges
	_ = tmp
	for len(tmp) > 0 {
		var min []int = tmp[0]
		_ = min
		var idx int = 0
		_ = idx
		var j int = 1
		_ = j
		for j < len(tmp) {
			var e []int = tmp[j]
			_ = e
			if (e[0] < min[0]) || ((e[0] == min[0]) && ((e[1] < min[1]) || ((e[1] == min[1]) && (e[2] < min[2])))) {
				min = e
				idx = j
			}
			j = (j + 1)
		}
		res = append(res, min)
		var out [][]int = [][]int{}
		_ = out
		var k int = 0
		_ = k
		for k < len(tmp) {
			if k != idx {
				out = append(out, tmp[k])
			}
			k = (k + 1)
		}
		tmp = out
	}
	return res
}

func getEdgesFaces(points []Point, faces [][]int) []Edge {
	var edges [][]int = [][]int{}
	_ = edges
	var fnum int = 0
	_ = fnum
	for fnum < len(faces) {
		var face []int = faces[fnum]
		_ = face
		var numP int = len(face)
		_ = numP
		var pi int = 0
		_ = pi
		for pi < numP {
			var pn1 int = face[pi]
			_ = pn1
			var pn2 int = 0
			_ = pn2
			if pi < (numP - 1) {
				pn2 = face[(pi + 1)]
			} else {
				pn2 = face[0]
			}
			if pn1 > pn2 {
				var tmpn int = pn1
				_ = tmpn
				pn1 = pn2
				pn2 = tmpn
			}
			edges = append(edges, []int{pn1, pn2, fnum})
			pi = (pi + 1)
		}
		fnum = (fnum + 1)
	}
	edges = sortEdges(edges)
	var merged [][]int = [][]int{}
	_ = merged
	var idx int = 0
	_ = idx
	for idx < len(edges) {
		var e1 []int = edges[idx]
		_ = e1
		if idx < (len(edges) - 1) {
			var e2 []int = edges[(idx + 1)]
			_ = e2
			if (e1[0] == e2[0]) && (e1[1] == e2[1]) {
				merged = append(merged, []int{e1[0], e1[1], e1[2], e2[2]})
				idx = (idx + 2)
				continue
			}
		}
		merged = append(merged, []int{e1[0], e1[1], e1[2], (0 - 1)})
		idx = (idx + 1)
	}
	var edgesCenters []Edge = []Edge{}
	_ = edgesCenters
	for _, me := range merged {
		var p1 Point = points[me[0]]
		_ = p1
		var p2 Point = points[me[1]]
		_ = p2
		var cp Point = centerPoint(p1, p2)
		_ = cp
		edgesCenters = append(edgesCenters, Edge{
			Pn1: me[0],
			Pn2: me[1],
			Fn1: me[2],
			Fn2: me[3],
			Cp:  cp,
		})
	}
	return edgesCenters
}

func getEdgePoints(points []Point, edgesFaces []Edge, facePoints []Point) []Point {
	var edgePoints []Point = []Point{}
	_ = edgePoints
	var i int = 0
	_ = i
	for i < len(edgesFaces) {
		var edge Edge = edgesFaces[i]
		_ = edge
		var cp Point = edge.Cp
		_ = cp
		var fp1 Point = facePoints[edge.Fn1]
		_ = fp1
		var fp2 Point = fp1
		_ = fp2
		if edge.Fn2 != (0 - 1) {
			fp2 = facePoints[edge.Fn2]
		}
		var cfp Point = centerPoint(fp1, fp2)
		_ = cfp
		edgePoints = append(edgePoints, centerPoint(cp, cfp))
		i = (i + 1)
	}
	return edgePoints
}

func getAvgFacePoints(points []Point, faces [][]int, facePoints []Point) []Point {
	var numP int = len(points)
	_ = numP
	var temp []PointEx = []PointEx{}
	_ = temp
	var i int = 0
	_ = i
	for i < numP {
		temp = append(temp, PointEx{
			P: Point{
				X: 0.0,
				Y: 0.0,
				Z: 0.0,
			},
			N: 0,
		})
		i = (i + 1)
	}
	var fnum int = 0
	_ = fnum
	for fnum < len(faces) {
		var fp Point = facePoints[fnum]
		_ = fp
		for _, pn := range faces[fnum] {
			var tp PointEx = temp[pn]
			_ = tp
			temp[pn] = PointEx{
				P: sumPoint(tp.P, fp),
				N: (tp.N + 1),
			}
		}
		fnum = (fnum + 1)
	}
	var avg []Point = []Point{}
	_ = avg
	var j int = 0
	_ = j
	for j < numP {
		var tp PointEx = temp[j]
		_ = tp
		avg = append(avg, divPoint(tp.P, float64(tp.N)))
		j = (j + 1)
	}
	return avg
}

func getAvgMidEdges(points []Point, edgesFaces []Edge) []Point {
	var numP int = len(points)
	_ = numP
	var temp []PointEx = []PointEx{}
	_ = temp
	var i int = 0
	_ = i
	for i < numP {
		temp = append(temp, PointEx{
			P: Point{
				X: 0.0,
				Y: 0.0,
				Z: 0.0,
			},
			N: 0,
		})
		i = (i + 1)
	}
	for _, edge := range edgesFaces {
		var cp Point = edge.Cp
		_ = cp
		var arr []int = []int{edge.Pn1, edge.Pn2}
		_ = arr
		for _, pn := range arr {
			var tp PointEx = temp[pn]
			_ = tp
			temp[pn] = PointEx{
				P: sumPoint(tp.P, cp),
				N: (tp.N + 1),
			}
		}
	}
	var avg []Point = []Point{}
	_ = avg
	var j int = 0
	_ = j
	for j < numP {
		var tp PointEx = temp[j]
		_ = tp
		avg = append(avg, divPoint(tp.P, float64(tp.N)))
		j = (j + 1)
	}
	return avg
}

func getPointsFaces(points []Point, faces [][]int) []int {
	var pf []int = []int{}
	_ = pf
	var i int = 0
	_ = i
	for i < len(points) {
		pf = append(pf, 0)
		i = (i + 1)
	}
	var fnum int = 0
	_ = fnum
	for fnum < len(faces) {
		for _, pn := range faces[fnum] {
			pf[pn] = (pf[pn] + 1)
		}
		fnum = (fnum + 1)
	}
	return pf
}

func getNewPoints(points []Point, pf []int, afp []Point, ame []Point) []Point {
	var newPts []Point = []Point{}
	_ = newPts
	var i int = 0
	_ = i
	for i < len(points) {
		var n float64 = float64(pf[i])
		_ = n
		var m1 float64 = ((n - 3.0) / n)
		_ = m1
		var m2 float64 = (1.0 / n)
		_ = m2
		var m3 float64 = (2.0 / n)
		_ = m3
		var old Point = points[i]
		_ = old
		var p1 Point = mulPoint(old, m1)
		_ = p1
		var p2 Point = mulPoint(afp[i], m2)
		_ = p2
		var p3 Point = mulPoint(ame[i], m3)
		_ = p3
		newPts = append(newPts, sumPoint(sumPoint(p1, p2), p3))
		i = (i + 1)
	}
	return newPts
}

func key(a int, b int) string {
	if a < b {
		return ((fmt.Sprint(a) + ",") + fmt.Sprint(b))
	}
	return ((fmt.Sprint(b) + ",") + fmt.Sprint(a))
}

func cmcSubdiv(points []Point, faces [][]int) []any {
	var facePoints []Point = getFacePoints(points, faces)
	_ = facePoints
	var edgesFaces []Edge = getEdgesFaces(points, faces)
	_ = edgesFaces
	var edgePoints []Point = getEdgePoints(points, edgesFaces, facePoints)
	_ = edgePoints
	var avgFacePoints []Point = getAvgFacePoints(points, faces, facePoints)
	_ = avgFacePoints
	var avgMidEdges []Point = getAvgMidEdges(points, edgesFaces)
	_ = avgMidEdges
	var pointsFaces []int = getPointsFaces(points, faces)
	_ = pointsFaces
	var newPoints []Point = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges)
	_ = newPoints
	var facePointNums []int = []int{}
	_ = facePointNums
	var nextPoint int = len(newPoints)
	_ = nextPoint
	for _, fp := range facePoints {
		newPoints = append(newPoints, fp)
		facePointNums = append(facePointNums, nextPoint)
		nextPoint = (nextPoint + 1)
	}
	var edgePointNums map[string]int = map[string]int{}
	_ = edgePointNums
	var idx int = 0
	_ = idx
	for idx < len(edgesFaces) {
		var e Edge = edgesFaces[idx]
		_ = e
		newPoints = append(newPoints, edgePoints[idx])
		edgePointNums[key(e.Pn1, e.Pn2)] = nextPoint
		nextPoint = (nextPoint + 1)
		idx = (idx + 1)
	}
	var newFaces [][]int = [][]int{}
	_ = newFaces
	var fnum int = 0
	_ = fnum
	for fnum < len(faces) {
		var oldFace []int = faces[fnum]
		_ = oldFace
		if len(oldFace) == 4 {
			var a int = oldFace[0]
			_ = a
			var b int = oldFace[1]
			_ = b
			var c int = oldFace[2]
			_ = c
			var d int = oldFace[3]
			_ = d
			var fpnum int = facePointNums[fnum]
			_ = fpnum
			var ab int = edgePointNums[key(a, b)]
			_ = ab
			var da int = edgePointNums[key(d, a)]
			_ = da
			var bc int = edgePointNums[key(b, c)]
			_ = bc
			var cd int = edgePointNums[key(c, d)]
			_ = cd
			newFaces = append(newFaces, []int{a, ab, fpnum, da})
			newFaces = append(newFaces, []int{b, bc, fpnum, ab})
			newFaces = append(newFaces, []int{c, cd, fpnum, bc})
			newFaces = append(newFaces, []int{d, da, fpnum, cd})
		}
		fnum = (fnum + 1)
	}
	return []any{newPoints, newFaces}
}

func formatPoint(p Point) string {
	return (((((("[" + fmt4(p.X)) + " ") + fmt4(p.Y)) + " ") + fmt4(p.Z)) + "]")
}

func formatFace(f []int) string {
	if len(f) == 0 {
		return "[]"
	}
	var s string = ("[" + fmt2(f[0]))
	_ = s
	var i int = 1
	_ = i
	for i < len(f) {
		s = ((s + " ") + fmt2(f[i]))
		i = (i + 1)
	}
	s = (s + "]")
	return s
}

func mochiMain() {
	var inputPoints []Point = []Point{Point{
		X: (0 - 1.0),
		Y: 1.0,
		Z: 1.0,
	}, Point{
		X: (0 - 1.0),
		Y: (0 - 1.0),
		Z: 1.0,
	}, Point{
		X: 1.0,
		Y: (0 - 1.0),
		Z: 1.0,
	}, Point{
		X: 1.0,
		Y: 1.0,
		Z: 1.0,
	}, Point{
		X: 1.0,
		Y: (0 - 1.0),
		Z: (0 - 1.0),
	}, Point{
		X: 1.0,
		Y: 1.0,
		Z: (0 - 1.0),
	}, Point{
		X: (0 - 1.0),
		Y: (0 - 1.0),
		Z: (0 - 1.0),
	}, Point{
		X: (0 - 1.0),
		Y: 1.0,
		Z: (0 - 1.0),
	}}
	_ = inputPoints
	var inputFaces [][]int = [][]int{[]int{0, 1, 2, 3}, []int{3, 2, 4, 5}, []int{5, 4, 6, 7}, []int{7, 0, 3, 5}, []int{7, 6, 1, 0}, []int{6, 1, 2, 4}}
	_ = inputFaces
	var outputPoints []Point = inputPoints
	_ = outputPoints
	var outputFaces [][]int = inputFaces
	_ = outputFaces
	var i int = 0
	_ = i
	for i < 1 {
		var res []any = cmcSubdiv(outputPoints, outputFaces)
		_ = res
		outputPoints = func(v any) []Point {
			if vv, ok := v.([]Point); ok {
				return vv
			}
			if arr, ok := v.([]any); ok && len(arr) == 0 {
				return []Point{}
			}
			return v.([]Point)
		}(res[0])
		outputFaces = func(v any) [][]int {
			if vv, ok := v.([][]int); ok {
				return vv
			}
			if arr, ok := v.([]any); ok && len(arr) == 0 {
				return [][]int{}
			}
			return v.([][]int)
		}(res[1])
		i = (i + 1)
	}
	for _, p := range outputPoints {
		fmt.Println(formatPoint(p))
	}
	fmt.Println("")
	for _, f := range outputFaces {
		fmt.Println(formatFace(f))
	}
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
