//go:build ignore

// Generated by Mochi v0.10.41 on 2025-07-26 23:55:41 GMT+7
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

func _substr(s string, start, end int) string {
	r := []rune(s)
	if start < 0 {
		start = 0
	}
	if end > len(r) {
		end = len(r)
	}
	if start > len(r) {
		start = len(r)
	}
	if end < start {
		end = start
	}
	return string(r[start:end])
}

func _slice[T any](s []T, start, end int) []T {
	if start < 0 {
		start = 0
	}
	if end > len(s) {
		end = len(s)
	}
	if start > len(s) {
		start = len(s)
	}
	if end < start {
		end = start
	}
	return s[start:end]
}

func _parseIntStr(s string, base int) int { v, _ := strconv.ParseInt(s, base, 64); return int(v) }

func parseIntStr(str string) int {
	var i int = 0
	_ = i
	var neg bool = false
	_ = neg
	if (len(str) > 0) && (string([]rune(str)[0:1]) == "-") {
		neg = true
		i = 1
	}
	var n int = 0
	_ = n
	var digits map[string]int = map[string]int{"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
	_ = digits
	for i < len(str) {
		n = ((n * 10) + digits[string([]rune(str)[i:(i+1)])])
		i = (i + 1)
	}
	if neg {
		n = (0 - n)
	}
	return n
}

func fields(s string) []string {
	var words []string = []string{}
	_ = words
	var cur string = ""
	_ = cur
	var i int = 0
	_ = i
	for i < len(s) {
		var ch string = _substr(s, i, (i + 1))
		_ = ch
		if ((ch == " ") || (ch == "\t")) || (ch == "\n") {
			if len(cur) > 0 {
				words = append(words, cur)
				cur = ""
			}
		} else {
			cur = (cur + ch)
		}
		i = (i + 1)
	}
	if len(cur) > 0 {
		words = append(words, cur)
	}
	return words
}

func unescape(s string) string {
	var out string = ""
	_ = out
	var i int = 0
	_ = i
	for i < len(s) {
		if (string([]rune(s)[i:(i+1)]) == "\\") && ((i + 1) < len(s)) {
			var c string = string([]rune(s)[(i + 1):(i + 2)])
			_ = c
			if c == "n" {
				out = (out + "\n")
				i = (i + 2)
				continue
			} else {
				if c == "\\" {
					out = (out + "\\")
					i = (i + 2)
					continue
				}
			}
		}
		out = (out + string([]rune(s)[i:(i+1)]))
		i = (i + 1)
	}
	return out
}

func parseProgram(src string) map[string]any {
	var lines []string = split(src, "\n")
	_ = lines
	var header []string = fields(lines[0])
	_ = header
	var dataSize int = _parseIntStr(header[1], 10)
	_ = dataSize
	var nStrings int = _parseIntStr(header[3], 10)
	_ = nStrings
	var stringPool []string = []string{}
	_ = stringPool
	var i int = 1
	_ = i
	for i <= nStrings {
		var s string = lines[i]
		_ = s
		if len(s) > 0 {
			stringPool = append(stringPool, unescape(string([]rune(s)[1:(len(s)-1)])))
		}
		i = (i + 1)
	}
	var code []map[string]any = []map[string]any{}
	_ = code
	var addrMap map[int]int = map[int]int{}
	_ = addrMap
	for i < len(lines) {
		var line string = trim(lines[i])
		_ = line
		if len(line) == 0 {
			break
		}
		var parts []string = fields(line)
		_ = parts
		var addr int = _parseIntStr(parts[0], 10)
		_ = addr
		var op string = parts[1]
		_ = op
		var arg int = 0
		_ = arg
		if op == "push" {
			arg = _parseIntStr(parts[2], 10)
		} else {
			if (op == "fetch") || (op == "store") {
				arg = _parseIntStr(string([]rune(parts[2])[1:(len(parts[2])-1)]), 10)
			} else {
				if (op == "jmp") || (op == "jz") {
					arg = _parseIntStr(parts[3], 10)
				}
			}
		}
		code = append(code, map[string]any{"addr": addr, "op": op, "arg": arg})
		addrMap[addr] = (len(code) - 1)
		i = (i + 1)
	}
	return map[string]any{"dataSize": dataSize, "strings": stringPool, "code": code, "addrMap": addrMap}
}

func runVM(prog map[string]any) {
	var data []int = []int{}
	_ = data
	var i int = 0
	_ = i
	for i < prog["dataSize"].(int) {
		data = append(data, 0)
		i = (i + 1)
	}
	var stack []int = []int{}
	_ = stack
	var pc int = 0
	_ = pc
	var code []map[string]any = func(v any) []map[string]any {
		if vv, ok := v.([]map[string]any); ok {
			return vv
		}
		if arr, ok := v.([]any); ok && len(arr) == 0 {
			return []map[string]any{}
		}
		return v.([]map[string]any)
	}(prog["code"])
	_ = code
	var addrMap map[int]int = prog["addrMap"].(map[int]int)
	_ = addrMap
	var pool []string = func(v any) []string {
		if vv, ok := v.([]string); ok {
			return vv
		}
		if arr, ok := v.([]any); ok && len(arr) == 0 {
			return []string{}
		}
		return v.([]string)
	}(prog["strings"])
	_ = pool
	var line string = ""
	_ = line
	for pc < len(code) {
		var inst map[string]any = code[pc]
		_ = inst
		var op string = inst["op"].(string)
		_ = op
		var arg int = inst["arg"].(int)
		_ = arg
		if op == "push" {
			stack = append(stack, arg)
			pc = (pc + 1)
			continue
		}
		if op == "store" {
			data[arg] = stack[(len(stack) - 1)]
			stack = func(v any) []int {
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok && len(arr) == 0 {
					return []int{}
				}
				return v.([]int)
			}(_slice(stack, 0, (len(stack) - 1)))
			pc = (pc + 1)
			continue
		}
		if op == "fetch" {
			stack = append(stack, data[arg])
			pc = (pc + 1)
			continue
		}
		if op == "add" {
			stack[(len(stack) - 2)] = (stack[(len(stack)-2)] + stack[(len(stack)-1)])
			stack = func(v any) []int {
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok && len(arr) == 0 {
					return []int{}
				}
				return v.([]int)
			}(_slice(stack, 0, (len(stack) - 1)))
			pc = (pc + 1)
			continue
		}
		if op == "lt" {
			var v int = 0
			_ = v
			if stack[(len(stack)-2)] < stack[(len(stack)-1)] {
				v = 1
			}
			stack[(len(stack) - 2)] = v
			stack = func(v any) []int {
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok && len(arr) == 0 {
					return []int{}
				}
				return v.([]int)
			}(_slice(stack, 0, (len(stack) - 1)))
			pc = (pc + 1)
			continue
		}
		if op == "jz" {
			var v int = stack[(len(stack) - 1)]
			_ = v
			stack = func(v any) []int {
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok && len(arr) == 0 {
					return []int{}
				}
				return v.([]int)
			}(_slice(stack, 0, (len(stack) - 1)))
			if v == 0 {
				pc = addrMap[arg]
			} else {
				pc = (pc + 1)
			}
			continue
		}
		if op == "jmp" {
			pc = addrMap[arg]
			continue
		}
		if op == "prts" {
			var s string = pool[stack[(len(stack)-1)]]
			_ = s
			stack = func(v any) []int {
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok && len(arr) == 0 {
					return []int{}
				}
				return v.([]int)
			}(_slice(stack, 0, (len(stack) - 1)))
			if s != "\n" {
				line = (line + s)
			}
			pc = (pc + 1)
			continue
		}
		if op == "prti" {
			line = (line + fmt.Sprint(stack[(len(stack)-1)]))
			fmt.Println(line)
			line = ""
			stack = func(v any) []int {
				if vv, ok := v.([]int); ok {
					return vv
				}
				if arr, ok := v.([]any); ok && len(arr) == 0 {
					return []int{}
				}
				return v.([]int)
			}(_slice(stack, 0, (len(stack) - 1)))
			pc = (pc + 1)
			continue
		}
		if op == "halt" {
			break
		}
		pc = (pc + 1)
	}
}

func trim(s string) string {
	var start int = 0
	_ = start
	for (start < len(s)) && ((string([]rune(s)[start:(start+1)]) == " ") || (string([]rune(s)[start:(start+1)]) == "\t")) {
		start = (start + 1)
	}
	var end int = len(s)
	_ = end
	for (end > start) && ((string([]rune(s)[(end-1):end]) == " ") || (string([]rune(s)[(end-1):end]) == "\t")) {
		end = (end - 1)
	}
	return _substr(s, start, end)
}

func split(s string, sep string) []string {
	var parts []string = []string{}
	_ = parts
	var cur string = ""
	_ = cur
	var i int = 0
	_ = i
	for i < len(s) {
		if ((len(sep) > 0) && ((i + len(sep)) <= len(s))) && (_substr(s, i, (i+len(sep))) == sep) {
			parts = append(parts, cur)
			cur = ""
			i = (i + len(sep))
		} else {
			cur = (cur + _substr(s, i, (i+1)))
			i = (i + 1)
		}
	}
	parts = append(parts, cur)
	return parts
}

func mochiMain() {
	var programText string = (((((((((((((((((((("Datasize: 1 Strings: 2\n" + "\"count is: \"\n") + "\"\\n\"\n") + "    0 push  1\n") + "    5 store [0]\n") + "   10 fetch [0]\n") + "   15 push  10\n") + "   20 lt\n") + "   21 jz     (43) 65\n") + "   26 push  0\n") + "   31 prts\n") + "   32 fetch [0]\n") + "   37 prti\n") + "   38 push  1\n") + "   43 prts\n") + "   44 fetch [0]\n") + "   49 push  1\n") + "   54 add\n") + "   55 store [0]\n") + "   60 jmp    (-51) 10\n") + "   65 halt\n")
	_ = programText
	var prog map[string]any = parseProgram(programText)
	_ = prog
	runVM(prog)
}

func main() {
	func() {
		var ms runtime.MemStats
		runtime.ReadMemStats(&ms)
		startMem := ms.Alloc
		benchStart := time.Now().UnixNano()
		mochiMain()
		runtime.ReadMemStats(&ms)
		endMem := ms.Alloc
		benchEnd := time.Now().UnixNano()
		data := map[string]any{"name": "main", "duration_us": (benchEnd - benchStart) / 1000, "memory_bytes": endMem - startMem}
		out, _ := json.MarshalIndent(data, "", "  ")
		fmt.Println(string(out))
	}()
}
