//go:build ignore

// Generated by Mochi v0.10.39 on 2025-07-25 09:00:26 GMT+7
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var _scanner = bufio.NewScanner(os.Stdin)

func _input() string {
	if !_scanner.Scan() {
		return ""
	}
	return _scanner.Text()
}

var board []int

var solved []int

var empty int

var moves int

var quit bool

func randMove() int {
	return (_now() % 4)
}

func isSolved() bool {
	var i int = 0
	_ = i
	for i < 16 {
		if board[i] != solved[i] {
			return false
		}
		i = (i + 1)
	}
	return true
}

type MoveResult struct {
	IDx int  `json:"idx"`
	Ok  bool `json:"ok"`
}

func isValidMove(m int) MoveResult {
	if m == 0 {
		return MoveResult{
			IDx: (empty - 4),
			Ok:  ((empty / 4) > 0),
		}
	}
	if m == 1 {
		return MoveResult{
			IDx: (empty + 4),
			Ok:  ((empty / 4) < 3),
		}
	}
	if m == 2 {
		return MoveResult{
			IDx: (empty + 1),
			Ok:  ((empty % 4) < 3),
		}
	}
	if m == 3 {
		return MoveResult{
			IDx: (empty - 1),
			Ok:  ((empty % 4) > 0),
		}
	}
	return MoveResult{
		IDx: 0,
		Ok:  false,
	}
}

func doMove(m int) bool {
	var r MoveResult = isValidMove(m)
	_ = r
	if !r.Ok {
		return false
	}
	var i int = empty
	_ = i
	var j int = r.IDx
	_ = j
	var tmp int = board[i]
	_ = tmp
	board[i] = board[j]
	board[j] = tmp
	empty = j
	moves = (moves + 1)
	return true
}

func shuffle(n int) {
	var i int = 0
	_ = i
	for (i < n) || isSolved() {
		if doMove(randMove()) {
			i = (i + 1)
		}
	}
}

func printBoard() {
	var line string = ""
	_ = line
	var i int = 0
	_ = i
	for i < 16 {
		var val int = board[i]
		_ = val
		if val == 0 {
			line = (line + "  .")
		} else {
			var s string = fmt.Sprint(val)
			_ = s
			if val < 10 {
				line = ((line + "  ") + s)
			} else {
				line = ((line + " ") + s)
			}
		}
		if (i % 4) == 3 {
			fmt.Println(line)
			line = ""
		}
		i = (i + 1)
	}
}

func playOneMove() {
	for {
		fmt.Println((("Enter move #" + fmt.Sprint((moves + 1))) + " (U, D, L, R, or Q): "))
		var s string = _input()
		_ = s
		if s == "" {
			continue
		}
		var c string = string([]rune(s)[0:1])
		_ = c
		var m int = 0
		_ = m
		if (c == "U") || (c == "u") {
			m = 0
		} else {
			if (c == "D") || (c == "d") {
				m = 1
			} else {
				if (c == "R") || (c == "r") {
					m = 2
				} else {
					if (c == "L") || (c == "l") {
						m = 3
					} else {
						if (c == "Q") || (c == "q") {
							fmt.Println((("Quiting after " + fmt.Sprint(moves)) + " moves."))
							quit = true
							return
						} else {
							fmt.Println(((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" + "up, down, left, or right. You can also enter \"Q\" to quit.\n") + "Upper or lowercase is accepted and only the first non-blank\n") + "character is important (i.e. you may enter \"up\" if you like)."))
							continue
						}
					}
				}
			}
		}
		if !doMove(m) {
			fmt.Println("That is not a valid move at the moment.")
			continue
		}
		return
	}
}

func play() {
	fmt.Println("Starting board:")
	for !quit && (isSolved() == false) {
		fmt.Println("")
		printBoard()
		playOneMove()
	}
	if isSolved() {
		fmt.Println((("You solved the puzzle in " + fmt.Sprint(moves)) + " moves."))
	}
}

func mochiMain() {
	shuffle(50)
	play()
}

func main() {
	board = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0}
	solved = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0}
	empty = 15
	moves = 0
	quit = false
	mochiMain()
}
