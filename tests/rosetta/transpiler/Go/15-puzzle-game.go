//go:build ignore

// Generated by Mochi v0.10.37 on 2025-07-22 23:40:29 GMT+7
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"time"
)

var seededNow bool
var nowSeed int64

func init() {
	if s := os.Getenv("MOCHI_NOW_SEED"); s != "" {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			nowSeed = v
			seededNow = true
		}
	}
}
func _now() int {
	if seededNow {
		nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647
		return int(nowSeed)
	}
	return int(time.Now().UnixNano())
}

var _scanner = bufio.NewScanner(os.Stdin)

func _input() string {
	if !_scanner.Scan() {
		return ""
	}
	return _scanner.Text()
}

var board []int = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0}

var solved []int = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0}

var empty int = 15

var moves int = 0

var quit bool = false

func randMove() int {
	return (_now() % 4)
}

func isSolved() bool {
	var i int = 0
	for i < 16 {
		if board[i] != solved[i] {
			return false
		}
		i = (i + 1)
	}
	return true
}

func isValidMove(m int) map[string]any {
	if m == 0 {
		return map[string]any{"idx": (empty - 4), "ok": ((empty / 4) > 0)}
	}
	if m == 1 {
		return map[string]any{"idx": (empty + 4), "ok": ((empty / 4) < 3)}
	}
	if m == 2 {
		return map[string]any{"idx": (empty + 1), "ok": ((empty % 4) < 3)}
	}
	if m == 3 {
		return map[string]any{"idx": (empty - 1), "ok": ((empty % 4) > 0)}
	}
	return map[string]any{"idx": 0, "ok": false}
}

func doMove(m int) bool {
	var r map[string]any = isValidMove(m)
	if !r["ok"].(bool) {
		return false
	}
	var i int = empty
	var j int = int(r["idx"].(int))
	var tmp int = board[i]
	board[i] = board[j]
	board[j] = tmp
	empty = j
	moves = (moves + 1)
	return true
}

func shuffle(n int) {
	var i int = 0
	for (i < n) || isSolved() {
		if doMove(randMove()) {
			i = (i + 1)
		}
	}
}

func printBoard() {
	var line string = ""
	var i int = 0
	for i < 16 {
		var val int = board[i]
		if val == 0 {
			line = (line + "  .")
		} else {
			var s string = fmt.Sprint(val)
			if val < 10 {
				line = ((line + "  ") + s)
			} else {
				line = ((line + " ") + s)
			}
		}
		if (i % 4) == 3 {
			fmt.Println(line)
			line = ""
		}
		i = (i + 1)
	}
}

func playOneMove() {
	for true {
		fmt.Println((("Enter move #" + fmt.Sprint((moves + 1))) + " (U, D, L, R, or Q): "))
		var s string = _input()
		if s == "" {
			continue
		}
		var c string = string([]rune(s)[0:1])
		var m int = 0
		if (c == "U") || (c == "u") {
			m = 0
		} else {
			if (c == "D") || (c == "d") {
				m = 1
			} else {
				if (c == "R") || (c == "r") {
					m = 2
				} else {
					if (c == "L") || (c == "l") {
						m = 3
					} else {
						if (c == "Q") || (c == "q") {
							fmt.Println((("Quiting after " + fmt.Sprint(moves)) + " moves."))
							quit = true
							return
						} else {
							fmt.Println(((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" + "up, down, left, or right. You can also enter \"Q\" to quit.\n") + "Upper or lowercase is accepted and only the first non-blank\n") + "character is important (i.e. you may enter \"up\" if you like)."))
							continue
						}
					}
				}
			}
		}
		if !doMove(m) {
			fmt.Println("That is not a valid move at the moment.")
			continue
		}
		return
	}
}

func play() {
	fmt.Println("Starting board:")
	for !quit && (isSolved() == false) {
		fmt.Println("")
		printBoard()
		playOneMove()
	}
	if isSolved() {
		fmt.Println((("You solved the puzzle in " + fmt.Sprint(moves)) + " moves."))
	}
}

func mochiMain() {
	shuffle(50)
	play()
}

func main() {
	mochiMain()
}
