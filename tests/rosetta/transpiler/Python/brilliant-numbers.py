# Code generated by Mochi transpiler.
# Version 0.10.56, generated on 2025-08-03 16:17 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

def primesUpTo(n):
    sieve = []
    i = 0
    while i <= n:
        sieve = sieve + [True]
        i = i + 1
    p = 2
    while p * p <= n:
        if sieve[p]:
            m = p * p
            while m <= n:
                sieve[m] = False
                m = m + p
        p = p + 1
    res = []
    x = 2
    while x <= n:
        if sieve[x]:
            res = res + [x]
        x = x + 1
    return res
def sortInts(xs):
    res = []
    tmp = xs
    while len(tmp) > 0:
        min = tmp[0]
        idx = 0
        i = 1
        while i < len(tmp):
            if tmp[i] < min:
                min = tmp[i]
                idx = i
            i = i + 1
        res = res + [min]
        out = []
        j = 0
        while j < len(tmp):
            if j != idx:
                out = out + [tmp[j]]
            j = j + 1
        tmp = out
    return res
def commatize(n):
    s = str(n)
    i = len(s) - 3
    while i >= 1:
        s = s[0:i] + "," + s[i:len(s)]
        i = i - 3
    return s
primes = primesUpTo(3200000)
def getBrilliant(digits, limit, countOnly):
    brilliant = []
    count = 0
    pow = 1
    next = 999999999999999
    k = 1
    while k <= digits:
        s = []
        for p in primes:
            if p >= pow * 10:
                break
            if p > pow:
                s = s + [p]
        i = 0
        while i < len(s):
            j = i
            while j < len(s):
                prod = s[i] * s[j]
                if prod < limit:
                    if countOnly:
                        count = count + 1
                    else:
                        brilliant = brilliant + [prod]
                else:
                    if prod < next:
                        next = prod
                    break
                j = j + 1
            i = i + 1
        pow = pow * 10
        k = k + 1
    if countOnly:
        return {"bc": count, "next": next}
    return {"bc": brilliant, "next": next}
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    try:
        print("First 100 brilliant numbers:")
        r = getBrilliant(2, 10000, False)
        br = sortInts(r.get("bc"))
        br = br[0:100]
        i = 0
        while i < len(br):
            print(str(br[i]).rjust(4, " ") + " ", ("True" if False else "False"))
            if (i + 1) % 10 == 0:
                print("", ("True" if True else "False"))
            i = i + 1
        print("", ("True" if True else "False"))
        k = 1
        while k <= 13:
            limit = pow(10, k)
            r2 = getBrilliant(k, limit, True)
            total = r2.get("bc")
            next = r2.get("next")
            climit = commatize(limit)
            ctotal = commatize(total + 1)
            cnext = commatize(next)
            print("First >= " + str(climit).rjust(18, " ") + " is " + str(ctotal).rjust(14, " ") + " in the series: " + str(cnext).rjust(18, " "))
            k = k + 1
    finally:
        _bench_end = _now()
        _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
