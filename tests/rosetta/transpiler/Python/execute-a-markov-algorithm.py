# Code generated by Mochi transpiler.
# Version 0.10.41, generated on 2025-07-27 12:53 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

def split(s, sep):
    parts = []
    cur = ""
    i = 0
    while i < len(s):
        if len(sep) > 0 and i + len(sep) <= len(s) and s[i:i + len(sep)] == sep:
            parts = parts + [cur]
            cur = ""
            i = i + len(sep)
        else:
            cur = cur + "".join(s[i:i + 1])
            i = i + 1
    parts = parts + [cur]
    sys.exit(parts)
def trimSpace(s):
    start = 0
    while start < len(s) and (s[start:start + 1] == " " or s[start:start + 1] == "\t"):
        start = start + 1
    end = len(s)
    while end > start and (s[end - 1:end] == " " or s[end - 1:end] == "\t"):
        end = end - 1
    sys.exit(s[start:end])
def indexOfSub(s, sub):
    if len(sub) == 0:
        sys.exit(0)
    i = 0
    while i + len(sub) <= len(s):
        if s[i:i + len(sub)] == sub:
            sys.exit(i)
        i = i + 1
    sys.exit(0 - 1)
def parseRules(rs):
    rules = []
    for line in rs.split("\n"):
        ln = line
        hash = indexOfSub(ln, "#")
        if hash >= 0:
            ln = ln[:hash]
        ln = trimSpace(ln)
        if len(ln) == 0:
            continue
        arrow = 0 - 1
        j = 0
        while j + 2 <= len(ln):
            if ln[j:j + 2] == "->":
                pre = j > 0 and (ln[j - 1:j] == " " or ln[j - 1:j] == "\t")
                post = j + 2 < len(ln) and (ln[j + 2:j + 3] == " " or ln[j + 2:j + 3] == "\t")
                if pre and post:
                    arrow = j
                    break
            j = j + 1
        if arrow < 0:
            arrow = indexOfSub(ln, "->")
        if arrow < 0:
            sys.exit({"ok": False})
        pat = trimSpace(ln[:arrow])
        rest = trimSpace(ln[arrow + 2:len(ln)])
        term = False
        if len(rest) > 0 and rest[0:1] == ".":
            term = True
            rest = rest[1:len(rest)]
        rep = rest
        rules = rules + [{"pat": pat, "rep": rep, "term": term}]
    sys.exit({"ok": True, "rules": rules})
def runRules(rules, s):
    changed = True
    while changed:
        changed = False
        i = 0
        while i < len(rules):
            r = rules[i]
            pat = r.get("pat")
            rep = r.get("rep")
            term = r.get("term")
            idx = indexOfSub(s, pat)
            if idx >= 0:
                s = "".join(s[:idx]) + rep + "".join(s[idx + len(pat):])
                changed = True
                if term:
                    sys.exit(s)
                break
            i = i + 1
    sys.exit(s)
def interpret(ruleset, input):
    p = parseRules(ruleset)
    if not p.get("ok"):
        sys.exit({"ok": False, "out": ""})
    out = runRules(p.get("rules"), input)
    sys.exit({"ok": True, "out": out})
testSet = [{"ruleSet": "# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As from T S.", "output": "I bought a bag of apples from my brother."}, {"ruleSet": "# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As from T S.", "output": "I bought a bag of apples from T shop."}, {"ruleSet": "# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As W my Bgage from T S.", "output": "I bought a bag of apples with my money from T shop."}, {"ruleSet": "### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n", "sample": "_1111*11111_", "output": "11111111111111111111"}, {"ruleSet": "# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n", "sample": "000000A000000", "output": "00011H1111000"}]
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    print("validating " + str(len(testSet)) + " test cases")
    failures = False
    i = 0
    while i < len(testSet):
        tc = testSet[i]
        res = interpret(tc.get("ruleSet"), tc.get("sample"))
        if not res.get("ok"):
            print("test " + str(i + 1) + " invalid ruleset")
            failures = True
        else:
            if res.get("out") != tc.get("output"):
                print("test " + str(i + 1) + ": got " + res.get("out") + ", want " + tc.get("output"))
                failures = True
        i = i + 1
    if not failures:
        print("no failures")
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
