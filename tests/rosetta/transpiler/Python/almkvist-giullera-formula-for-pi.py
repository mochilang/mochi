# Code generated by Mochi transpiler.
# Version 0.10.37, generated on 2025-07-23 12:25 +0700
import sys
sys.set_int_max_str_digits(0)

def bigTrim(a):
    n = len(a)
    while n > 1 and a[n - 1] == 0:
        a = a[0:n - 1]
        n = n - 1
    return a
def bigFromInt(x):
    if x == 0:
        return [0]
    digits = []
    n = x
    while n > 0:
        digits = digits + [n % 10]
        n = n // 10
    return digits
def bigCmp(a, b):
    if len(a) > len(b):
        return 1
    if len(a) < len(b):
        return -1
    i = len(a) - 1
    while i >= 0:
        if a[i] > b[i]:
            return 1
        if a[i] < b[i]:
            return -1
        i = i - 1
    return 0
def bigAdd(a, b):
    res = []
    carry = 0
    i = 0
    while i < len(a) or i < len(b) or carry > 0:
        av = 0
        if i < len(a):
            av = a[i]
        bv = 0
        if i < len(b):
            bv = b[i]
        s = av + bv + carry
        res = res + [s % 10]
        carry = s // 10
        i = i + 1
    return bigTrim(res)
def bigSub(a, b):
    res = []
    borrow = 0
    i = 0
    while i < len(a):
        av = a[i]
        bv = 0
        if i < len(b):
            bv = b[i]
        diff = av - bv - borrow
        if diff < 0:
            diff = diff + 10
            borrow = 1
        else:
            borrow = 0
        res = res + [diff]
        i = i + 1
    return bigTrim(res)
def bigMulSmall(a, m):
    if m == 0:
        return [0]
    res = []
    carry = 0
    i = 0
    while i < len(a):
        prod = a[i] * m + carry
        res = res + [prod % 10]
        carry = prod // 10
        i = i + 1
    while carry > 0:
        res = res + [carry % 10]
        carry = carry // 10
    return bigTrim(res)
def bigMulBig(a, b):
    res = []
    i = 0
    while i < len(a) + len(b):
        res = res + [0]
        i = i + 1
    i = 0
    while i < len(a):
        carry = 0
        j = 0
        while j < len(b):
            idx = i + j
            prod = res[idx] + a[i] * b[j] + carry
            res[idx] = prod % 10
            carry = prod // 10
            j = j + 1
        idx = i + len(b)
        while carry > 0:
            prod = res[idx] + carry
            res[idx] = prod % 10
            carry = prod // 10
            idx = idx + 1
        i = i + 1
    return bigTrim(res)
def bigMulPow10(a, k):
    i = 0
    while i < k:
        a = [0] + a
        i = i + 1
    return a
def bigDivSmall(a, m):
    res = []
    rem = 0
    i = len(a) - 1
    while i >= 0:
        cur = rem * 10 + a[i]
        q = cur // m
        rem = cur % m
        res = [q] + res
        i = i - 1
    return bigTrim(res)
def bigToString(a):
    s = ""
    i = len(a) - 1
    while i >= 0:
        s = s + str(a[i])
        i = i - 1
    return s
def repeat(ch, n):
    s = ""
    i = 0
    while i < n:
        s = s + ch
        i = i + 1
    return s
def sortInts(xs):
    res = []
    tmp = xs
    while len(tmp) > 0:
        min = tmp[0]
        idx = 0
        i = 1
        while i < len(tmp):
            if tmp[i] < min:
                min = tmp[i]
                idx = i
            i = i + 1
        res = res + [min]
        out = []
        j = 0
        while j < len(tmp):
            if j != idx:
                out = out + [tmp[j]]
            j = j + 1
        tmp = out
    return res
def primesUpTo(n):
    sieve = []
    i = 0
    while i <= n:
        sieve = sieve + [True]
        i = i + 1
    p = 2
    while p * p <= n:
        if sieve[p]:
            m = p * p
            while m <= n:
                sieve[m] = False
                m = m + p
        p = p + 1
    res = []
    x = 2
    while x <= n:
        if sieve[x]:
            res = res + [x]
        x = x + 1
    return res
def factorialExp(n, primes):
    m = {}
    for p in primes:
        if p > n:
            break
        t = n
        e = 0
        while t > 0:
            t = t // p
            e = e + t
        m[str(p)] = e
    return m
def factorSmall(x, primes):
    f = {}
    n = x
    for p in primes:
        if p * p > n:
            break
        c = 0
        while n % p == 0:
            c = c + 1
            n = n // p
        if c > 0:
            f[str(p)] = c
    if n > 1:
        f[str(n)] = f.get(str(n), 0) + 1
    return f
def computeIP(n, primes):
    exps = factorialExp(6 * n, primes)
    fn = factorialExp(n, primes)
    for k in fn:
        exps[k] = exps.get(k, 0) - 6 * fn[k]
    exps["2"] = exps.get("2", 0) + 5
    t2 = 532 * n * n + 126 * n + 9
    ft2 = factorSmall(t2, primes)
    for k in ft2:
        exps[k] = exps.get(k, 0) + ft2[k]
    exps["3"] = exps.get("3", 0) - 1
    keys = []
    for k in exps:
        keys = keys + [int(k)]
    keys = sortInts(keys)
    res = bigFromInt(1)
    for p in keys:
        e = exps[str(p)]
        i = 0
        while i < e:
            res = bigMulSmall(res, p)
            i = i + 1
    return res
def formatTerm(ip, pw):
    s = bigToString(ip)
    if pw >= len(s):
        frac = repeat("0", pw - len(s)) + s
        if len(frac) < 33:
            frac = frac + repeat("0", 33 - len(frac))
        return "0." + "".join(frac[0:33])
    intpart = s[0:len(s) - pw]
    frac = s[len(s) - pw:len(s)]
    if len(frac) < 33:
        frac = frac + repeat("0", 33 - len(frac))
    return intpart + "." + "".join(frac[0:33])
def bigAbsDiff(a, b):
    if bigCmp(a, b) >= 0:
        return bigSub(a, b)
    return bigSub(b, a)
def main():
    primes = primesUpTo(2000)
    print("N                               Integer Portion  Pow  Nth Term (33 dp)")
    line = repeat("-", 89)
    print(line)
    sum = bigFromInt(0)
    prev = bigFromInt(0)
    denomPow = 0
    n = 0
    while True:
        ip = computeIP(n, primes)
        pw = 6 * n + 3
        if pw > denomPow:
            sum = bigMulPow10(sum, pw - denomPow)
            prev = bigMulPow10(prev, pw - denomPow)
            denomPow = pw
        if n < 10:
            termStr = formatTerm(ip, pw)
            ipStr = bigToString(ip)
            while len(ipStr) < 44:
                ipStr = " " + ipStr
            pwStr = str(-pw)
            while len(pwStr) < 3:
                pwStr = " " + pwStr
            padTerm = termStr
            while len(padTerm) < 35:
                padTerm = padTerm + " "
            print(str(n) + "  " + ipStr + "  " + pwStr + "  " + padTerm)
        sum = bigAdd(sum, ip)
        diff = bigAbsDiff(sum, prev)
        if denomPow >= 70 and bigCmp(diff, bigMulPow10(bigFromInt(1), denomPow - 70)) < 0:
            break
        prev = sum
        n = n + 1
    precision = 70
    target = bigMulPow10(bigFromInt(1), denomPow + 2 * precision)
    low = bigFromInt(0)
    high = bigMulPow10(bigFromInt(1), precision + 1)
    while bigCmp(low, bigSub(high, bigFromInt(1))) < 0:
        mid = bigDivSmall(bigAdd(low, high), 2)
        prod = bigMulBig(bigMulBig(mid, mid), sum)
        if bigCmp(prod, target) <= 0:
            low = mid
        else:
            high = bigSub(mid, bigFromInt(1))
    piInt = low
    piStr = bigToString(piInt)
    if len(piStr) <= precision:
        piStr = repeat("0", precision - len(piStr) + 1) + piStr
    out = "".join(piStr[0:len(piStr) - precision]) + "." + "".join(piStr[len(piStr) - precision:len(piStr)])
    print("")
    print("Pi to 70 decimal places is:")
    print(out)
main()
