# Code generated by Mochi transpiler.
# Version 0.10.40, generated on 2025-07-25 17:27 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)

def absf(x):
    if x < 0.0:
        return -x
    return x
def maxf(a, b):
    if a > b:
        return a
    return b
def minf(a, b):
    if a < b:
        return a
    return b
def max3(a, b, c):
    m = a
    if b > m:
        m = b
    if c > m:
        m = c
    return m
def min3(a, b, c):
    m = a
    if b < m:
        m = b
    if c < m:
        m = c
    return m
@dataclass
class Point:
    x: float
    y: float

@dataclass
class QuadSpline:
    c0: float
    c1: float
    c2: float

@dataclass
class QuadCurve:
    x: QuadSpline
    y: QuadSpline

def subdivideQuadSpline(q, t):
    s = 1.0 - t
    u = QuadSpline(c0=q.c0, c1=0.0, c2=0.0)
    v = QuadSpline(c0=0.0, c1=0.0, c2=q.c2)
    u = dataclasses.replace(u, c1=s * q.c0 + t * q.c1)
    v = dataclasses.replace(v, c1=s * q.c1 + t * q.c2)
    u = dataclasses.replace(u, c2=s * u.c1 + t * v.c1)
    v = dataclasses.replace(v, c0=u.c2)
    return [u, v]
def subdivideQuadCurve(q, t):
    xs = subdivideQuadSpline(q.x, t)
    ys = subdivideQuadSpline(q.y, t)
    u = QuadCurve(x=xs[0], y=ys[0])
    v = QuadCurve(x=xs[1], y=ys[1])
    return [u, v]
def rectsOverlap(xa0, ya0, xa1, ya1, xb0, yb0, xb1, yb1):
    return xb0 <= xa1 and xa0 <= xb1 and yb0 <= ya1 and ya0 <= yb1
def testIntersect(p, q, tol):
    pxmin = min3(p.x.c0, p.x.c1, p.x.c2)
    pymin = min3(p.y.c0, p.y.c1, p.y.c2)
    pxmax = max3(p.x.c0, p.x.c1, p.x.c2)
    pymax = max3(p.y.c0, p.y.c1, p.y.c2)
    qxmin = min3(q.x.c0, q.x.c1, q.x.c2)
    qymin = min3(q.y.c0, q.y.c1, q.y.c2)
    qxmax = max3(q.x.c0, q.x.c1, q.x.c2)
    qymax = max3(q.y.c0, q.y.c1, q.y.c2)
    exclude = True
    accept = False
    inter = Point(x=0.0, y=0.0)
    if rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax):
        exclude = False
        xmin = maxf(pxmin, qxmin)
        xmax = minf(pxmax, qxmax)
        if xmax - xmin <= tol:
            ymin = maxf(pymin, qymin)
            ymax = minf(pymax, qymax)
            if ymax - ymin <= tol:
                accept = True
                inter = dataclasses.replace(inter, x=0.5 * (xmin + xmax))
                inter = dataclasses.replace(inter, y=0.5 * (ymin + ymax))
    return {"exclude": exclude, "accept": accept, "intersect": inter}
def seemsToBeDuplicate(pts, xy, spacing):
    i = 0
    while i < len(pts):
        pt = pts[i]
        if absf(pt.x - xy.x) < spacing and absf(pt.y - xy.y) < spacing:
            return True
        i = i + 1
    return False
def findIntersects(p, q, tol, spacing):
    inters = []
    workload = [{"p": p, "q": q}]
    while len(workload) > 0:
        idx = len(workload) - 1
        work = workload[idx]
        workload = workload[:idx]
        res = testIntersect(work.get("p"), work.get("q"), tol)
        excl = res.get("exclude")
        acc = res.get("accept")
        inter = res.get("intersect")
        if acc:
            if not seemsToBeDuplicate(inters, inter, spacing):
                inters = inters + [inter]
        else:
            if not excl:
                ps = subdivideQuadCurve(work.get("p"), 0.5)
                qs = subdivideQuadCurve(work.get("q"), 0.5)
                p0 = ps[0]
                p1 = ps[1]
                q0 = qs[0]
                q1 = qs[1]
                workload = workload + [{"p": p0, "q": q0}]
                workload = workload + [{"p": p0, "q": q1}]
                workload = workload + [{"p": p1, "q": q0}]
                workload = workload + [{"p": p1, "q": q1}]
    return inters
def main():
    p = QuadCurve(x=QuadSpline(c0=-1.0, c1=0.0, c2=1.0), y=QuadSpline(c0=0.0, c1=10.0, c2=0.0))
    q = QuadCurve(x=QuadSpline(c0=2.0, c1=-8.0, c2=2.0), y=QuadSpline(c0=1.0, c1=2.0, c2=3.0))
    tol = 1e-07
    spacing = tol * 10.0
    inters = findIntersects(p, q, tol, spacing)
    i = 0
    while i < len(inters):
        pt = inters[i]
        print("(" + str(pt.x) + ", " + str(pt.y) + ")")
        i = i + 1
main()
