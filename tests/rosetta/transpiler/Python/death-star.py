# Code generated by Mochi transpiler.
# Version 0.10.40, generated on 2025-07-25 21:35 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

@dataclass
class V3:
    x: float
    y: float
    z: float

@dataclass
class Sphere:
    cx: float
    cy: float
    cz: float
    r: float

def sqrtApprox(x):
    if x <= 0.0:
        return 0.0
    guess = x
    i = 0
    while i < 20:
        guess = (guess + x // guess) / 2.0
        i = i + 1
    return guess
def powf(base, exp):
    result = 1.0
    i = 0
    while i < exp:
        result = result * base
        i = i + 1
    return result
def normalize(v):
    len = sqrtApprox(v.x * v.x + v.y * v.y + v.z * v.z)
    return V3(x=v.x / len, y=v.y / len, z=v.z / len)
def dot(a, b):
    d = a.x * b.x + a.y * b.y + a.z * b.z
    if d < 0.0:
        return -d
    return 0.0
def hitSphere(s, x, y):
    dx = x - s.cx
    dy = y - s.cy
    zsq = s.r * s.r - (dx * dx + dy * dy)
    if zsq < 0.0:
        return {"hit": False}
    z = sqrtApprox(zsq)
    return {"hit": True, "z1": s.cz - z, "z2": s.cz + z}
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    shades = ".:!*oe&#%@"
    light = normalize(V3(x=-50.0, y=30.0, z=50.0))
    pos = Sphere(cx=20.0, cy=20.0, cz=0.0, r=20.0)
    neg = Sphere(cx=1.0, cy=1.0, cz=-6.0, r=20.0)
    yi = 0
    while yi <= 40:
        y = (float(yi)) + 0.5
        line = ""
        xi = -20
        while xi <= 60:
            x = ((float(xi)) - pos.cx) / 2.0 + 0.5 + pos.cx
            hb = hitSphere(pos, x, y)
            if not hb["hit"]:
                line = line + " "
                xi = xi + 1
                continue
            zb1 = hb["z1"]
            zb2 = hb["z2"]
            hs = hitSphere(neg, x, y)
            hitRes = 1
            if not hs["hit"]:
                hitRes = 1
            else:
                if hs["z1"] > zb1:
                    hitRes = 1
                else:
                    if hs["z2"] > zb2:
                        hitRes = 0
                    else:
                        if hs["z2"] > zb1:
                            hitRes = 2
                        else:
                            hitRes = 1
            if hitRes == 0:
                line = line + " "
                xi = xi + 1
                continue
            vec = {}
            if hitRes == 1:
                vec = V3(x=x - pos.cx, y=y - pos.cy, z=zb1 - pos.cz)
            else:
                vec = V3(x=neg.cx - x, y=neg.cy - y, z=neg.cz - hs["z2"])
            vec = normalize(vec)
            b = powf(dot(light, vec), 2) + 0.5
            intensity = int(((1.0 - b) * (float(len(shades)))))
            if intensity < 0:
                intensity = 0
            if intensity >= len(shades):
                intensity = len(shades) - 1
            line = line + "".join(shades[intensity:intensity + 1])
            xi = xi + 1
        print(line)
        yi = yi + 1
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
