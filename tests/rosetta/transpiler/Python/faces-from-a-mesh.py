# Code generated by Mochi transpiler.
# Version 0.10.41, generated on 2025-07-27 12:53 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
@dataclass
class Edge:
    a: int
    b: int
def contains(xs, v):
    for x in xs:
        if x == v:
            return True
    return False
def sliceEqual(a, b):
    i = 0
    while i < len(a):
        if a[i] != b[i]:
            return False
        i = i + 1
    return True
def reverse(xs):
    i = 0
    j = len(xs) - 1
    while i < j:
        t = xs[i]
        xs[i] = xs[j]
        xs[j] = t
        i = i + 1
        j = j - 1
def copyInts(xs):
    out = []
    for v in xs:
        out = out + [v]
    return out
def perimEqual(p1, p2):
    if len(p1) != len(p2):
        return False
    for v in p1:
        if not v in p2:
            return False
    c = copyInts(p1)
    r = 0
    while r < 2:
        i = 0
        while i < len(p1):
            if sliceEqual(c, p2):
                return True
            t = c[len(c) - 1]
            j = len(c) - 1
            while j > 0:
                c[j] = c[j - 1]
                j = j - 1
            c[0] = t
            i = i + 1
        reverse(c)
        r = r + 1
    return False
def sortEdges(es):
    arr = es
    n = len(arr)
    i = 0
    while i < n:
        j = 0
        while j < n - 1:
            a = arr[j]
            b = arr[j + 1]
            if a.a > b.a or (a.a == b.a and a.b > b.b):
                arr[j] = b
                arr[j + 1] = a
            j = j + 1
        i = i + 1
    return arr
def concat(a, b):
    out = []
    for x in a:
        out = out + [x]
    for x in b:
        out = out + [x]
    return out
def faceToPerim(face):
    le = len(face)
    if le == 0:
        return None
    edges = []
    i = 0
    while i < le:
        e = face[i]
        if e.b <= e.a:
            return None
        edges = edges + [e]
        i = i + 1
    edges = sortEdges(edges)
    firstEdge = edges[0]
    perim = [firstEdge.a, firstEdge.b]
    first = firstEdge.a
    last = firstEdge.b
    edges = edges[1:len(edges)]
    le = len(edges)
    done = False
    while le > 0 and (not done):
        idx = 0
        found = False
        while idx < le:
            e = edges[idx]
            if e.a == last:
                perim = perim + [e.b]
                last = e.b
                found = True
            else:
                if e.b == last:
                    perim = perim + [e.a]
                    last = e.a
                    found = True
            if found:
                edges = concat(edges[:idx], edges[idx + 1:len(edges)])
                le = le - 1
                if last == first:
                    if le == 0:
                        done = True
                    else:
                        return None
                break
            idx = idx + 1
        if not found:
            return None
    return perim[:len(perim) - 1]
def listStr(xs):
    s = "["
    i = 0
    while i < len(xs):
        s = s + str(xs[i])
        if i < len(xs) - 1:
            s = s + " "
        i = i + 1
    s = s + "]"
    return s
print("Perimeter format equality checks:")
print("  Q == R is " + str(perimEqual([8, 1, 3], [1, 3, 8])))
print("  U == V is " + str(perimEqual([18, 8, 14, 10, 12, 17, 19], [8, 14, 10, 12, 17, 19, 18])))
e = [Edge(a=7, b=11), Edge(a=1, b=11), Edge(a=1, b=7)]
f = [Edge(a=11, b=23), Edge(a=1, b=17), Edge(a=17, b=23), Edge(a=1, b=11)]
g = [Edge(a=8, b=14), Edge(a=17, b=19), Edge(a=10, b=12), Edge(a=10, b=14), Edge(a=12, b=17), Edge(a=8, b=18), Edge(a=18, b=19)]
h = [Edge(a=1, b=3), Edge(a=9, b=11), Edge(a=3, b=11), Edge(a=1, b=11)]
print("\nEdge to perimeter format translations:")
faces = [e, f, g, h]
names = ["E", "F", "G", "H"]
idx2 = 0
while idx2 < len(faces):
    per = faceToPerim(faces[idx2])
    if per == None:
        print("  " + names[idx2] + " => Invalid edge format")
    else:
        print("  " + names[idx2] + " => " + listStr(per))
    idx2 = idx2 + 1
_bench_end = _now()
_bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
