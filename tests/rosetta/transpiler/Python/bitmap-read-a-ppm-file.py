# Code generated by Mochi transpiler.
# Version 0.10.40, generated on 2025-07-25 17:48 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())


def _substr(s, start, end):
    return s[start:end]

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
@dataclass
class Pixel:
    R: int
    G: int
    B: int
@dataclass
class Bitmap:
    w: int
    h: int
    max: int
    data: [[Pixel]]
def newBitmap(w, h, max):
    rows = []
    y = 0
    while y < h:
        row = []
        x = 0
        while x < w:
            row = row + [Pixel(R=0, G=0, B=0)]
            x = x + 1
        rows = rows + [row]
        y = y + 1
    return Bitmap(w=w, h=h, max=max, data=rows)
def setPx(b, x, y, p):
    rows = b.data
    row = rows[y]
    row[x] = p
    rows[y] = row
    b = dataclasses.replace(b, data=rows)
def getPx(b, x, y):
    return b.data[y][x]
def splitLines(s):
    out = []
    cur = ""
    i = 0
    while i < len(s):
        ch = _substr(s, i, i + 1)
        if ch == "\n":
            out = out + [cur]
            cur = ""
        else:
            cur = cur + ch
        i = i + 1
    out = out + [cur]
    return out
def splitWS(s):
    out = []
    cur = ""
    i = 0
    while i < len(s):
        ch = _substr(s, i, i + 1)
        if ch == " " or ch == "\t" or ch == "\r" or ch == "\n":
            if len(cur) > 0:
                out = out + [cur]
                cur = ""
        else:
            cur = cur + ch
        i = i + 1
    if len(cur) > 0:
        out = out + [cur]
    return out
def parseIntStr(str):
    i = 0
    neg = False
    if len(str) > 0 and str[0:1] == "-":
        neg = True
        i = 1
    n = 0
    digits = {"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
    while i < len(str):
        n = n * 10 + digits[str[i:i + 1]]
        i = i + 1
    if neg:
        n = -n
    return n
def tokenize(s):
    lines = splitLines(s)
    toks = []
    i = 0
    while i < len(lines):
        line = lines[i]
        if len(line) > 0 and _substr(line, 0, 1) == "#":
            i = i + 1
            continue
        parts = splitWS(line)
        j = 0
        while j < len(parts):
            toks = toks + [parts[j]]
            j = j + 1
        i = i + 1
    return toks
def readP3(text):
    toks = tokenize(text)
    if len(toks) < 4:
        return newBitmap(0, 0, 0)
    if toks[0] != "P3":
        return newBitmap(0, 0, 0)
    w = parseIntStr(toks[1])
    h = parseIntStr(toks[2])
    maxv = parseIntStr(toks[3])
    idx = 4
    bm = newBitmap(w, h, maxv)
    y = h - 1
    while y >= 0:
        x = 0
        while x < w:
            r = parseIntStr(toks[idx])
            g = parseIntStr(toks[idx + 1])
            b = parseIntStr(toks[idx + 2])
            setPx(bm, x, y, Pixel(R=r, G=g, B=b))
            idx = idx + 3
            x = x + 1
        y = y - 1
    return bm
def toGrey(b):
    h = b.h
    w = b.w
    m = 0
    y = 0
    while y < h:
        x = 0
        while x < w:
            p = getPx(b, x, y)
            l = (p.R * 2126 + p.G * 7152 + p.B * 722) / 10000
            if l > b.max:
                l = b.max
            setPx(b, x, y, Pixel(R=l, G=l, B=l))
            if l > m:
                m = l
            x = x + 1
        y = y + 1
    b = dataclasses.replace(b, max=m)
def pad(n, w):
    s = str(n)
    while len(s) < w:
        s = " " + s
    return s
def writeP3(b):
    h = b.h
    w = b.w
    max = b.max
    digits = len(str(max))
    out = "P3\n# generated from Bitmap.writeppmp3\n" + str(w) + " " + str(h) + "\n" + str(max) + "\n"
    y = h - 1
    while y >= 0:
        line = ""
        x = 0
        while x < w:
            p = getPx(b, x, y)
            line = line + "   " + pad(p.R, digits) + " " + pad(p.G, digits) + " " + pad(p.B, digits)
            x = x + 1
        out = out + line + "\n"
        y = y - 1
    return out
ppmtxt = "P3\n" + "# feep.ppm\n" + "4 4\n" + "15\n" + " 0  0  0    0  0  0    0  0  0   15  0 15\n" + " 0  0  0    0 15  7    0  0  0    0  0  0\n" + " 0  0  0    0  0  0    0 15  7    0  0  0\n" + "15  0 15    0  0  0    0  0  0    0  0  0\n"
print("Original Colour PPM file")
print(ppmtxt)
bm = readP3(ppmtxt)
print("Grey PPM:")
toGrey(bm)
out = writeP3(bm)
print(out)
_bench_end = _now()
_bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
