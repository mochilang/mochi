# Code generated by Mochi transpiler.
# Version 0.10.39, generated on 2025-07-24 11:14 +0000
import sys
sys.set_int_max_str_digits(0)

def parseIntStr(str):
    i = 0
    neg = False
    if len(str) > 0 and str[0:1] == "-":
        neg = True
        i = 1
    n = 0
    digits = {"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
    while i < len(str):
        n = n * 10 + digits[str[i:i + 1]]
        i = i + 1
    if neg:
        n = -n
    return n
def fields(s):
    words = []
    cur = ""
    i = 0
    while i < len(s):
        ch = s[i:i + 1]
        if ch == " " or ch == "\t" or ch == "\n":
            if len(cur) > 0:
                words = words + [cur]
                cur = ""
        else:
            cur = cur + ch
        i = i + 1
    if len(cur) > 0:
        words = words + [cur]
    return words
def unescape(s):
    out = ""
    i = 0
    while i < len(s):
        if s[i:i + 1] == "\\" and i + 1 < len(s):
            c = s[i + 1:i + 2]
            if c == "n":
                out = out + "\n"
                i = i + 2
                continue
            else:
                if c == "\\":
                    out = out + "\\"
                    i = i + 2
                    continue
        out = out + "".join(s[i:i + 1])
        i = i + 1
    return out
def parseProgram(src):
    lines = split(src, "\n")
    header = fields(lines[0])
    dataSize = parseIntStr(header[1])
    nStrings = parseIntStr(header[3])
    stringPool = []
    i = 1
    while i <= nStrings:
        s = lines[i]
        if len(s) > 0:
            stringPool = stringPool + [unescape(s[1:len(s) - 1])]
        i = i + 1
    code = []
    addrMap = {}
    while i < len(lines):
        line = trim(lines[i])
        if len(line) == 0:
            break
        parts = fields(line)
        addr = parseIntStr(parts[0])
        op = parts[1]
        arg = 0
        if op == "push":
            arg = parseIntStr(parts[2])
        else:
            if op == "fetch" or op == "store":
                arg = parseIntStr(parts[2][1:len(parts[2]) - 1])
            else:
                if op == "jmp" or op == "jz":
                    arg = parseIntStr(parts[3])
        code = code + [{"addr": addr, "op": op, "arg": arg}]
        addrMap[addr] = len(code) - 1
        i = i + 1
    return {"dataSize": dataSize, "strings": stringPool, "code": code, "addrMap": addrMap}
def runVM(prog):
    data = []
    i = 0
    while i < prog["dataSize"]:
        data = data + [0]
        i = i + 1
    stack = []
    pc = 0
    code = prog["code"]
    addrMap = prog["addrMap"]
    pool = prog["strings"]
    while pc < len(code):
        inst = code[pc]
        op = inst["op"]
        arg = inst["arg"]
        if op == "push":
            stack = stack + [arg]
            pc = pc + 1
            continue
        if op == "store":
            data[arg] = stack[len(stack) - 1]
            stack = slice(stack, 0, len(stack) - 1)
            pc = pc + 1
            continue
        if op == "fetch":
            stack = stack + [data[arg]]
            pc = pc + 1
            continue
        if op == "add":
            stack[len(stack) - 2] = stack[len(stack) - 2] + stack[len(stack) - 1]
            stack = slice(stack, 0, len(stack) - 1)
            pc = pc + 1
            continue
        if op == "lt":
            v = 0
            if stack[len(stack) - 2] < stack[len(stack) - 1]:
                v = 1
            stack[len(stack) - 2] = v
            stack = slice(stack, 0, len(stack) - 1)
            pc = pc + 1
            continue
        if op == "jz":
            v = stack[len(stack) - 1]
            stack = slice(stack, 0, len(stack) - 1)
            if v == 0:
                pc = addrMap[arg]
            else:
                pc = pc + 1
            continue
        if op == "jmp":
            pc = addrMap[arg]
            continue
        if op == "prts":
            print(pool[stack[len(stack) - 1]])
            stack = slice(stack, 0, len(stack) - 1)
            pc = pc + 1
            continue
        if op == "prti":
            print(str(stack[len(stack) - 1]))
            stack = slice(stack, 0, len(stack) - 1)
            pc = pc + 1
            continue
        if op == "halt":
            break
        pc = pc + 1
def trim(s):
    start = 0
    while start < len(s) and (s[start:start + 1] == " " or s[start:start + 1] == "\t"):
        start = start + 1
    end = len(s)
    while end > start and (s[end - 1:end] == " " or s[end - 1:end] == "\t"):
        end = end - 1
    return s[start:end]
def split(s, sep):
    parts = []
    cur = ""
    i = 0
    while i < len(s):
        if len(sep) > 0 and i + len(sep) <= len(s) and s[i:i + len(sep)] == sep:
            parts = parts + [cur]
            cur = ""
            i = i + len(sep)
        else:
            cur = cur + "".join(s[i:i + 1])
            i = i + 1
    parts = parts + [cur]
    return parts
def main():
    programText = "Datasize: 1 Strings: 2\n" + "\"count is: \"\n" + "\"\\n\"\n" + "    0 push  1\n" + "    5 store [0]\n" + "   10 fetch [0]\n" + "   15 push  10\n" + "   20 lt\n" + "   21 jz     (43) 65\n" + "   26 push  0\n" + "   31 prts\n" + "   32 fetch [0]\n" + "   37 prti\n" + "   38 push  1\n" + "   43 prts\n" + "   44 fetch [0]\n" + "   49 push  1\n" + "   54 add\n" + "   55 store [0]\n" + "   60 jmp    (-51) 10\n" + "   65 halt\n"
    prog = parseProgram(programText)
    runVM(prog)
main()
