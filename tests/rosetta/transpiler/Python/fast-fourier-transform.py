# Code generated by Mochi transpiler.
# Version 0.10.42, generated on 2025-07-27 16:50 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)

PI = 3.141592653589793
@dataclass
class Complex:
    re: float
    im: float

def sinApprox(x):
    term = x
    sum = x
    n = 1
    while n <= 10:
        denom = float(((2 * n) * (2 * n + 1)))
        term = -term * x * x / denom
        sum = sum + term
        n = n + 1
    return sum
def cosApprox(x):
    term = 1.0
    sum = 1.0
    n = 1
    while n <= 10:
        denom = float(((2 * n - 1) * (2 * n)))
        term = -term * x * x / denom
        sum = sum + term
        n = n + 1
    return sum
def cis(x):
    return Complex(re=cosApprox(x), im=sinApprox(x))
def add(a, b):
    return Complex(re=a.re + b.re, im=a.im + b.im)
def sub(a, b):
    return Complex(re=a.re - b.re, im=a.im - b.im)
def mul(a, b):
    return Complex(re=a.re * b.re - a.im * b.im, im=a.re * b.im + a.im * b.re)
def ditfft2Rec(x, y, offX, offY, n, s):
    if n == 1:
        y[offY] = Complex(re=x[offX], im=0.0)
        return
    ditfft2Rec(x, y, offX, offY, n // 2, 2 * s)
    ditfft2Rec(x, y, offX + s, offY + (n // 2), n // 2, 2 * s)
    k = 0
    while k < (n // 2):
        angle = -2.0 * PI * (float(k)) / (float(n))
        tf = mul(cis(angle), y[offY + k + (n // 2)])
        a = add(y[offY + k], tf)
        b = sub(y[offY + k], tf)
        y[offY + k] = a
        y[offY + k + (n // 2)] = b
        k = k + 1
def ditfft2(x, y, n, s):
    ditfft2Rec(x, y, 0, 0, n, s)
def main():
    x = [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]
    y = []
    i = 0
    while i < len(x):
        y = y + [Complex(re=0.0, im=0.0)]
        i = i + 1
    ditfft2(x, y, len(x), 1)
    for c in y:
        line = pad(fmt(c.re), 8)
        if c.im >= 0:
            line = line + "+" + fmt(c.im)
        else:
            line = line + fmt(c.im)
        print(line)
def pad(s, w):
    t = s
    while len(t) < w:
        t = " " + t
    return t
def fmt(x):
    y = floorf(x * 10000.0 + 0.5) / 10000.0
    s = str(y)
    dot = s.find(".")
    if dot == 0 - 1:
        s = s + ".0000"
    else:
        d = len(s) - dot - 1
        while d < 4:
            s = s + "0"
            d = d + 1
    return s
def floorf(x):
    y = int(x)
    return float(y)
def indexOf(s, ch):
    i = 0
    while i < len(s):
        if s[i:i + 1] == ch:
            return i
        i = i + 1
    return 0 - 1
main()
