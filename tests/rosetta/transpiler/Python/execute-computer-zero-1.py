# Code generated by Mochi transpiler.
# Version 0.10.50, generated on 2025-07-31 00:24 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))

@dataclass
class Instruction:
    Label: str
    Opcode: str
    Arg: str

def trim(s):
    start = 0
    while start < len(s) and (s[start:start + 1] == " " or s[start:start + 1] == "\t"):
        start = start + 1
    end = len(s)
    while end > start and (s[end - 1:end] == " " or s[end - 1:end] == "\t"):
        end = end - 1
    return s[start:end]
def split(s, sep):
    parts = []
    cur = ""
    i = 0
    while i < len(s):
        if len(sep) > 0 and i + len(sep) <= len(s) and s[i:i + len(sep)] == sep:
            parts = parts + [cur]
            cur = ""
            i = i + len(sep)
        else:
            cur = cur + "".join(s[i:i + 1])
            i = i + 1
    parts = parts + [cur]
    return parts
def splitWS(s):
    out = []
    cur = ""
    i = 0
    while i < len(s):
        ch = s[i:i + 1]
        if ch == " " or ch == "\t":
            if len(cur) > 0:
                out = out + [cur]
                cur = ""
        else:
            cur = cur + ch
        i = i + 1
    if len(cur) > 0:
        out = out + [cur]
    return out
def indexOf(s, ch):
    i = 0
    while i < len(s):
        if s[i:i + 1] == ch:
            return i
        i = i + 1
    return -1
def parseIntStr(str):
    i = 0
    neg = False
    if len(str) > 0 and str[0:1] == "-":
        neg = True
        i = 1
    n = 0
    digits = {"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9}
    while i < len(str):
        n = n * 10 + digits[str[i:i + 1]]
        i = i + 1
    if neg:
        n = -n
    return n
def parseAsm(asm):
    lines = asm.split("\n")
    instrs = []
    labels = {}
    lineNum = 0
    i = 0
    while i < len(lines):
        line = lines[i]
        if line.find(";") != (-1):
            line = line[0:line.find(";")]
        line = trim(line)
        label = ""
        if line.find(":") != (-1):
            idx = line.find(":")
            label = trim(line[0:idx])
            line = trim(line[idx + 1:len(line)])
        opcode = ""
        arg = ""
        if len(line) > 0:
            parts = splitWS(line)
            if len(parts) > 0:
                opcode = parts[0]
            if len(parts) > 1:
                arg = parts[1]
            else:
                ops = {"NOP": 0, "LDA": 1, "STA": 2, "ADD": 3, "SUB": 4, "BRZ": 5, "JMP": 6, "STP": 7}
                if not (opcode in ops):
                    arg = opcode
                    opcode = ""
        if label != "":
            labels[label] = lineNum
        instrs = instrs + [Instruction(Label=label, Opcode=opcode, Arg=arg)]
        lineNum = lineNum + 1
        i = i + 1
    return {"instructions": instrs, "labels": labels}
def compile(p):
    instrs = p.get("instructions")
    labels = p.get("labels")
    bytecode = []
    i = 0
    opcodes = {"NOP": 0, "LDA": 1, "STA": 2, "ADD": 3, "SUB": 4, "BRZ": 5, "JMP": 6, "STP": 7}
    while i < len(instrs):
        ins = instrs[i]
        arg = 0
        if ins.Arg != "":
            if ins.Arg in labels:
                arg = labels[ins.Arg]
            else:
                arg = parseIntStr(ins.Arg)
        code = 0
        if ins.Opcode != "":
            code = opcodes[ins.Opcode]
        bytecode = bytecode + [code * 32 + arg]
        i = i + 1
    while len(bytecode) < 32:
        bytecode = bytecode + [0]
    return bytecode
def floorMod(a, b):
    r = a % b
    if r < 0:
        r = r + b
    return r
def run(bytecode):
    acc = 0
    pc = 0
    mem = []
    i = 0
    while i < len(bytecode):
        mem = mem + [bytecode[i]]
        i = i + 1
    while pc < 32:
        op = mem[pc] / 32
        arg = mem[pc] % 32
        pc = pc + 1
        if op == 0:
            continue
        else:
            if op == 1:
                acc = mem[arg]
            else:
                if op == 2:
                    mem[arg] = acc
                else:
                    if op == 3:
                        acc = floorMod(acc + mem[arg], 256)
                    else:
                        if op == 4:
                            acc = floorMod(acc - mem[arg], 256)
                        else:
                            if op == 5:
                                if acc == 0:
                                    pc = arg
                            else:
                                if op == 6:
                                    pc = arg
                                else:
                                    if op == 7:
                                        break
                                    else:
                                        break
    return acc
def execute(asm):
    parsed = parseAsm(asm)
    bc = compile(parsed)
    return run(bc)
def main():
    examples = ["LDA   x\n" + "ADD   y       ; accumulator = x + y\n" + "STP\n" + "x:            2\n" + "y:            2", "loop:   LDA   prodt\n" + "        ADD   x\n" + "        STA   prodt\n" + "        LDA   y\n" + "        SUB   one\n" + "        STA   y\n" + "        BRZ   done\n" + "        JMP   loop\n" + "done:   LDA   prodt   ; to display it\n" + "        STP\n" + "x:            8\n" + "y:            7\n" + "prodt:        0\n" + "one:          1", "loop:   LDA   n\n" + "        STA   temp\n" + "        ADD   m\n" + "        STA   n\n" + "        LDA   temp\n" + "        STA   m\n" + "        LDA   count\n" + "        SUB   one\n" + "        BRZ   done\n" + "        STA   count\n" + "        JMP   loop\n" + "done:   LDA   n       ; to display it\n" + "        STP\n" + "m:            1\n" + "n:            1\n" + "temp:         0\n" + "count:        8       ; valid range: 1-11\n" + "one:          1", "start:  LDA   load\n" + "ADD   car     ; head of list\n" + "STA   ldcar\n" + "ADD   one\n" + "STA   ldcdr   ; next CONS cell\n" + "ldcar:  NOP\n" + "STA   value\n" + "ldcdr:  NOP\n" + "BRZ   done    ; 0 stands for NIL\n" + "STA   car\n" + "JMP   start\n" + "done:   LDA   value   ; CAR of last CONS\n" + "STP\n" + "load:   LDA   0\n" + "value:        0\n" + "car:          28\n" + "one:          1\n" + "                        ; order of CONS cells\n" + "                        ; in memory\n" + "                        ; does not matter\n" + "        6\n" + "        0       ; 0 stands for NIL\n" + "        2       ; (CADR ls)\n" + "        26      ; (CDDR ls) -- etc.\n" + "        5\n" + "        20\n" + "        3\n" + "        30\n" + "        1       ; value of (CAR ls)\n" + "        22      ; points to (CDR ls)\n" + "        4\n" + "        24", "LDA  3\n" + "SUB  4\n" + "STP  0\n" + "         0\n" + "         255", "LDA  3\n" + "SUB  4\n" + "STP  0\n" + "                0\n" + "                1", "LDA  3\n" + "ADD  4\n" + "STP  0\n" + "                1\n" + "                255"]
    i = 0
    while i < len(examples):
        res = execute(examples[i])
        print(str(res))
        i = i + 1
main()
