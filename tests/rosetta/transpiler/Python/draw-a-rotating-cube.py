# Code generated by Mochi transpiler.
# Version 0.10.41, generated on 2025-07-26 19:54 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses

import sys
sys.set_int_max_str_digits(0)

PI = 3.141592653589793
TWO_PI = 6.283185307179586
def _mod(x, m):
    return x - (float(int((x // m)))) * m
def _sin(x):
    y = _mod(x + PI, TWO_PI) - PI
    y2 = y * y
    y3 = y2 * y
    y5 = y3 * y2
    y7 = y5 * y2
    return y - y3 / 6.0 + y5 / 120.0 - y7 / 5040.0
def _cos(x):
    y = _mod(x + PI, TWO_PI) - PI
    y2 = y * y
    y4 = y2 * y2
    y6 = y4 * y2
    return 1.0 - y2 / 2.0 + y4 / 24.0 - y6 / 720.0
@dataclass
class Point3:
    x: float
    y: float
    z: float

@dataclass
class Point2:
    x: int
    y: int

nodes = [Point3(x=-1.0, y=-1.0, z=-1.0), Point3(x=-1.0, y=-1.0, z=1.0), Point3(x=-1.0, y=1.0, z=-1.0), Point3(x=-1.0, y=1.0, z=1.0), Point3(x=1.0, y=-1.0, z=-1.0), Point3(x=1.0, y=-1.0, z=1.0), Point3(x=1.0, y=1.0, z=-1.0), Point3(x=1.0, y=1.0, z=1.0)]
edges = [[0, 1], [1, 3], [3, 2], [2, 0], [4, 5], [5, 7], [7, 6], [6, 4], [0, 4], [1, 5], [2, 6], [3, 7]]
def rotate(p, ax, ay):
    sinx = _sin(ax)
    cosx = _cos(ax)
    siny = _sin(ay)
    cosy = _cos(ay)
    x1 = p.x
    y1 = p.y * cosx - p.z * sinx
    z1 = p.y * sinx + p.z * cosx
    x2 = x1 * cosy + z1 * siny
    z2 = -x1 * siny + z1 * cosy
    return Point3(x=x2, y=y1, z=z2)
width = 40
height = 20
distance = 3.0
scale = 8.0
def project(p):
    factor = scale / (p.z + distance)
    x = int((p.x * factor)) + (width // 2)
    y = int((-p.y * factor)) + (height // 2)
    return Point2(x=x, y=y)
def clearGrid():
    g = []
    y = 0
    while y < height:
        row = []
        x = 0
        while x < width:
            row = row + [" "]
            x = x + 1
        g = g + [row]
        y = y + 1
    return g
def drawPoint(g, x, y, ch):
    if x >= 0 and x < width and y >= 0 and y < height:
        row = g[y]
        row[x] = ch
        g[y] = row
def bresenham(x0, y0, x1, y1, g, ch):
    dx = x1 - x0
    if dx < 0:
        dx = -dx
    dy = y1 - y0
    if dy < 0:
        dy = -dy
    sx = -1
    if x0 < x1:
        sx = 1
    sy = -1
    if y0 < y1:
        sy = 1
    err = dx - dy
    while True:
        drawPoint(g, x0, y0, ch)
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > (-dy):
            err = err - dy
            x0 = x0 + sx
        if e2 < dx:
            err = err + dx
            y0 = y0 + sy
def render(g):
    out = ""
    y = 0
    while y < height:
        line = ""
        x = 0
        while x < width:
            line = line + g[y][x]
            x = x + 1
        out = out + line + "\n"
        y = y + 1
    return out
def main():
    f = 0
    while f < 10:
        grid = clearGrid()
        rot = []
        i = 0
        ay = (PI / 4.0) + (float(f)) * PI / 10.0
        while i < len(nodes):
            p = rotate(nodes[i], PI / 4.0, ay)
            pp = project(p)
            rot = rot + [pp]
            i = i + 1
        e = 0
        while e < len(edges):
            a = edges[e][0]
            b = edges[e][1]
            p1 = rot[a]
            p2 = rot[b]
            bresenham(p1.x, p1.y, p2.x, p2.y, grid, "#")
            e = e + 1
        print(render(grid))
        f = f + 1
main()
