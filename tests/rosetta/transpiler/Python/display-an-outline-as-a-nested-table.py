# Code generated by Mochi transpiler.
# Version 0.10.57, generated on 2025-08-04 16:02 +0700
import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))

def split(s, sep):
    out = []
    cur = ""
    i = 0
    while i < len(s):
        if i + len(sep) <= len(s) and s[i:i + len(sep)] == sep:
            out = out + [cur]
            cur = ""
            i = i + len(sep)
        else:
            cur = cur + s[i:i + 1]
            i = i + 1
    out = out + [cur]
    return out
def join(xs, sep):
    res = ""
    i = 0
    while i < len(xs):
        if i > 0:
            res = res + sep
        res = res + xs[i]
        i = i + 1
    return res
def trimLeftSpaces(s):
    i = 0
    while i < len(s) and s[i:i + 1] == " ":
        i = i + 1
    return s[i:len(s)]
def makeIndent(outline, tab):
    lines = outline.split("\n")
    nodes = []
    for line in lines:
        line2 = trimLeftSpaces(line)
        level = (len(line) - len(line2)) / tab
        nodes = nodes + [{"level": level, "name": line2}]
    return nodes
def toNest(nodes, start, level, n):
    if level == 0:
        n["name"] = nodes[0].get("name")
    i = start + 1
    while i < len(nodes):
        node = nodes[i]
        lev = int(node.get("level"))
        if lev == level + 1:
            child = {"name": node.get("name"), "children": []}
            toNest(nodes, i, level + 1, child)
            cs = n.get("children")
            cs = cs + [child]
            n["children"] = cs
        else:
            if lev <= level:
                return
        i = i + 1
def countLeaves(n):
    kids = n.get("children")
    if len(kids) == 0:
        return 1
    total = 0
    for k in kids:
        total = total + countLeaves(k)
    return total
def nodesByDepth(root, depth):
    levels = []
    current = [root]
    d = 0
    while d < depth:
        levels = levels + [current]
        next = []
        for n in current:
            kids = n.get("children")
            for k in kids:
                next = next + [k]
        current = next
        d = d + 1
    return levels
def toMarkup(n, cols, depth):
    lines = []
    lines = lines + ["{| class=\"wikitable\" style=\"text-align: center;\""]
    l1 = "|-"
    lines = lines + [l1]
    span = countLeaves(n)
    lines = lines + ["| style=\"background: " + cols[0] + " \" colSpan=" + str(span) + " | " + (str(n.get("name")))]
    lines = lines + [l1]
    lvls = nodesByDepth(n, depth)
    lvl = 1
    while lvl < depth:
        nodes = lvls[lvl]
        if len(nodes) == 0:
            lines = lines + ["|  |"]
        else:
            idx = 0
            while idx < len(nodes):
                node = nodes[idx]
                span = countLeaves(node)
                col = lvl
                if lvl == 1:
                    col = idx + 1
                if col >= len(cols):
                    col = len(cols) - 1
                cell = "| style=\"background: " + cols[col] + " \" colspan=" + str(span) + " | " + (str(node.get("name")))
                lines = lines + [cell]
                idx = idx + 1
        if lvl < depth - 1:
            lines = lines + [l1]
        lvl = lvl + 1
    lines = lines + ["|}"]
    return join(lines, "\n")
def main():
    outline = "Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n" + "        measuring the indent of each line,\n" + "        translating the indentation to a nested structure,\n" + "        and padding the tree to even depth.\n" + "    count the leaves descending from each node,\n" + "        defining the width of a leaf as 1,\n" + "        and the width of a parent node as a sum.\n" + "            (The sum of the widths of its children)\n" + "    and write out a table with 'colspan' values\n" + "        either as a wiki table,\n" + "        or as HTML."
    yellow = "#ffffe6;"
    orange = "#ffebd2;"
    green = "#f0fff0;"
    blue = "#e6ffff;"
    pink = "#ffeeff;"
    cols = [yellow, orange, green, blue, pink]
    nodes = makeIndent(outline, 4)
    n = {"name": "", "children": []}
    toNest(nodes, 0, 0, n)
    print(toMarkup(n, cols, 4))
    print("\n")
    outline2 = "Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n" + "        measuring the indent of each line,\n" + "        translating the indentation to a nested structure,\n" + "        and padding the tree to even depth.\n" + "    count the leaves descending from each node,\n" + "        defining the width of a leaf as 1,\n" + "        and the width of a parent node as a sum.\n" + "            (The sum of the widths of its children)\n" + "            Propagating the sums upward as necessary.\n" + "    and write out a table with 'colspan' values\n" + "        either as a wiki table,\n" + "        or as HTML.\n" + "    Optionally add color to the nodes."
    cols2 = [blue, yellow, orange, green, pink]
    nodes2 = makeIndent(outline2, 4)
    n2 = {"name": "", "children": []}
    toNest(nodes2, 0, 0, n2)
    print(toMarkup(n2, cols2, 4))
main()
