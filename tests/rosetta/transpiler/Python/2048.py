# Code generated by Mochi transpiler.
# Version 0.10.40, generated on 2025-07-25 13:13 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import os
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

SIZE = 4
@dataclass
class Board:
    cells: [[int]]

@dataclass
class SpawnResult:
    board: Board
    full: bool

@dataclass
class SlideResult:
    row: [int]
    gain: int

@dataclass
class MoveResult:
    board: Board
    score: int
    moved: bool

def newBoard():
    b = []
    y = 0
    while y < SIZE:
        row = []
        x = 0
        while x < SIZE:
            row = row + [0]
            x = x + 1
        b = b + [row]
        y = y + 1
    return Board(cells=b)
def spawnTile(b):
    grid = b.cells
    empty = []
    y = 0
    while y < SIZE:
        x = 0
        while x < SIZE:
            if grid[y][x] == 0:
                empty = empty + [[x, y]]
            x = x + 1
        y = y + 1
    if len(empty) == 0:
        return SpawnResult(board=b, full=True)
    idx = _now() % len(empty)
    cell = empty[idx]
    val = 4
    if _now() % 10 < 9:
        val = 2
    grid[cell[1]][cell[0]] = val
    return SpawnResult(board=Board(cells=grid), full=len(empty) == 1)
def pad(n):
    s = str(n)
    pad = 4 - len(s)
    i = 0
    out = ""
    while i < pad:
        out = out + " "
        i = i + 1
    return out + s
def draw(b, score):
    print("Score: " + str(score))
    y = 0
    while y < SIZE:
        print("+----+----+----+----+")
        line = "|"
        x = 0
        while x < SIZE:
            v = b.cells[y][x]
            if v == 0:
                line = line + "    |"
            else:
                line = line + pad(v) + "|"
            x = x + 1
        print(line)
        y = y + 1
    print("+----+----+----+----+")
    print("W=Up S=Down A=Left D=Right Q=Quit")
def reverseRow(r):
    out = []
    i = len(r) - 1
    while i >= 0:
        out = out + [r[i]]
        i = i - 1
    return out
def slideLeft(row):
    xs = []
    i = 0
    while i < len(row):
        if row[i] != 0:
            xs = xs + [row[i]]
        i = i + 1
    res = []
    gain = 0
    i = 0
    while i < len(xs):
        if i + 1 < len(xs) and xs[i] == xs[i + 1]:
            v = xs[i] * 2
            gain = gain + v
            res = res + [v]
            i = i + 2
        else:
            res = res + [xs[i]]
            i = i + 1
    while len(res) < SIZE:
        res = res + [0]
    return SlideResult(row=res, gain=gain)
def moveLeft(b, score):
    grid = b.cells
    moved = False
    y = 0
    while y < SIZE:
        r = slideLeft(grid[y])
        new = r.row
        score = score + r.gain
        x = 0
        while x < SIZE:
            if grid[y][x] != new[x]:
                moved = True
            grid[y][x] = new[x]
            x = x + 1
        y = y + 1
    return MoveResult(board=Board(cells=grid), score=score, moved=moved)
def moveRight(b, score):
    grid = b.cells
    moved = False
    y = 0
    while y < SIZE:
        rev = reverseRow(grid[y])
        r = slideLeft(rev)
        rev = r.row
        score = score + r.gain
        rev = reverseRow(rev)
        x = 0
        while x < SIZE:
            if grid[y][x] != rev[x]:
                moved = True
            grid[y][x] = rev[x]
            x = x + 1
        y = y + 1
    return MoveResult(board=Board(cells=grid), score=score, moved=moved)
def getCol(b, x):
    col = []
    y = 0
    while y < SIZE:
        col = col + [b.cells[y][x]]
        y = y + 1
    return col
def setCol(b, x, col):
    rows = b.cells
    y = 0
    while y < SIZE:
        row = rows[y]
        row[x] = col[y]
        rows[y] = row
        y = y + 1
    b = dataclasses.replace(b, cells=rows)
def moveUp(b, score):
    grid = b.cells
    moved = False
    x = 0
    while x < SIZE:
        col = getCol(b, x)
        r = slideLeft(col)
        new = r.row
        score = score + r.gain
        y = 0
        while y < SIZE:
            if grid[y][x] != new[y]:
                moved = True
            grid[y][x] = new[y]
            y = y + 1
        x = x + 1
    return MoveResult(board=Board(cells=grid), score=score, moved=moved)
def moveDown(b, score):
    grid = b.cells
    moved = False
    x = 0
    while x < SIZE:
        col = reverseRow(getCol(b, x))
        r = slideLeft(col)
        col = r.row
        score = score + r.gain
        col = reverseRow(col)
        y = 0
        while y < SIZE:
            if grid[y][x] != col[y]:
                moved = True
            grid[y][x] = col[y]
            y = y + 1
        x = x + 1
    return MoveResult(board=Board(cells=grid), score=score, moved=moved)
def hasMoves(b):
    y = 0
    while y < SIZE:
        x = 0
        while x < SIZE:
            if b.cells[y][x] == 0:
                return True
            if x + 1 < SIZE and b.cells[y][x] == b.cells[y][x + 1]:
                return True
            if y + 1 < SIZE and b.cells[y][x] == b.cells[y + 1][x]:
                return True
            x = x + 1
        y = y + 1
    return False
def has2048(b):
    y = 0
    while y < SIZE:
        x = 0
        while x < SIZE:
            if b.cells[y][x] >= 2048:
                return True
            x = x + 1
        y = y + 1
    return False
board = newBoard()
r = spawnTile(board)
board = r.board
full = r.full
r = spawnTile(board)
board = r.board
full = r.full
score = 0
draw(board, score)
while True:
    print("Move: ")
    cmd = input()
    moved = False
    if cmd == "a" or cmd == "A":
        m = moveLeft(board, score)
        board = m.board
        score = m.score
        moved = m.moved
    if cmd == "d" or cmd == "D":
        m = moveRight(board, score)
        board = m.board
        score = m.score
        moved = m.moved
    if cmd == "w" or cmd == "W":
        m = moveUp(board, score)
        board = m.board
        score = m.score
        moved = m.moved
    if cmd == "s" or cmd == "S":
        m = moveDown(board, score)
        board = m.board
        score = m.score
        moved = m.moved
    if cmd == "q" or cmd == "Q":
        break
    if moved:
        r2 = spawnTile(board)
        board = r2.board
        full = r2.full
        if full and (not hasMoves(board)):
            draw(board, score)
            print("Game Over")
            break
    draw(board, score)
    if has2048(board):
        print("You win!")
        break
    if not hasMoves(board):
        print("Game Over")
        break
