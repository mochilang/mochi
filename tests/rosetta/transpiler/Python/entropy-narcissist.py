# Code generated by Mochi transpiler.
# Version 0.10.41, generated on 2025-07-27 10:59 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

def log2(x):
    k = 0.0
    v = x
    while v >= 2.0:
        v = v / 2.0
        k = k + 1.0
    while v < 1.0:
        v = v * 2.0
        k = k - 1.0
    z = (v - 1.0) / (v + 1.0)
    zpow = z
    sum = z
    i = 3
    while i <= 9:
        zpow = zpow * z * z
        sum = sum + zpow / (float(i))
        i = i + 2
    ln2 = 0.6931471805599453
    return k + 2.0 * sum / ln2
def entropy(data):
    if data == "":
        return 0.0
    counts = {}
    i = 0
    while i < len(data):
        ch = data[i:i + 1]
        if ch in counts:
            counts[ch] = counts[ch] + 1
        else:
            counts[ch] = 1
        i = i + 1
    e = 0.0
    l = float(len(data))
    for ch in counts:
        px = (float(counts[ch])) / l
        if px > 0.0:
            e = e - px * log2(px)
    return e
source = "// Mochi translation of the Rosetta \"Entropy-Narcissist\" task\n" + "// Simplified to compute the entropy of this source string\n\n" + "fun log2(x: float): float {\n" + "  var k = 0.0\n" + "  var v = x\n" + "  while v >= 2.0 {\n" + "    v = v / 2.0\n" + "    k = k + 1.0\n" + "  }\n" + "  while v < 1.0 {\n" + "    v = v * 2.0\n" + "    k = k - 1.0\n" + "  }\n" + "  let z = (v - 1.0) / (v + 1.0)\n" + "  var zpow = z\n" + "  var sum = z\n" + "  var i = 3\n" + "  while i <= 9 {\n" + "    zpow = zpow * z * z\n" + "    sum = sum + zpow / (i as float)\n" + "    i = i + 2\n" + "  }\n" + "  let ln2 = 0.6931471805599453\n" + "  return k + 2.0 * sum / ln2\n" + "}\n\n" + "fun entropy(data: string): float {\n" + "  if data == \"\" { return 0.0 }\n" + "  var counts: map<string,int> = {}\n" + "  var i = 0\n" + "  while i < len(data) {\n" + "    let ch = substring(data, i, i+1)\n" + "    if ch in counts {\n" + "      counts[ch] = counts[ch] + 1\n" + "    } else {\n" + "      counts[ch] = 1\n" + "    }\n" + "    i = i + 1\n" + "  }\n" + "  var e = 0.0\n" + "  let l = len(data) as float\n" + "  for ch in counts {\n" + "    let px = (counts[ch] as float) / l\n" + "    if px > 0.0 {\n" + "      e = e - px * log2(px)\n" + "    }\n" + "  }\n" + "  return e\n" + "}\n\n" + "// Store the program source as a string constant\n" + "let source = ... // truncated in actual source\n" + "\nfun main() {\n" + "  print(\"Source file entropy: \" + str(entropy(source)))\n" + "}\n\n" + "main()\n"
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    print("Source file entropy: " + str(entropy(source)))
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
