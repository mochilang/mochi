# Code generated by Mochi transpiler.
# Version 0.10.40, generated on 2025-07-25 16:52 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

PI = 3.141592653589793
def sinApprox(x):
    term = x
    sum = x
    n = 1
    while n <= 8:
        denom = float(((2 * n) * (2 * n + 1)))
        term = -term * x * x / denom
        sum = sum + term
        n = n + 1
    return sum
def cosApprox(x):
    term = 1.0
    sum = 1.0
    n = 1
    while n <= 8:
        denom = float(((2 * n - 1) * (2 * n)))
        term = -term * x * x / denom
        sum = sum + term
        n = n + 1
    return sum
def atanApprox(x):
    if x > 1.0:
        return PI / 2.0 - x / (x * x + 0.28)
    if x < (-1.0):
        return -PI / 2.0 - x / (x * x + 0.28)
    return x / (1.0 + 0.28 * x * x)
def atan2Approx(y, x):
    if x > 0.0:
        return atanApprox(y / x)
    if x < 0.0:
        if y >= 0.0:
            return atanApprox(y / x) + PI
        return atanApprox(y / x) - PI
    if y > 0.0:
        return PI / 2.0
    if y < 0.0:
        return -PI / 2.0
    return 0.0
def digit(ch):
    digits = "0123456789"
    i = 0
    while i < len(digits):
        if digits[i:i + 1] == ch:
            return i
        i = i + 1
    return 0
def parseTwo(s, idx):
    return digit(s[idx:idx + 1]) * 10 + digit(s[idx + 1:idx + 2])
def parseSec(s):
    h = parseTwo(s, 0)
    m = parseTwo(s, 3)
    sec = parseTwo(s, 6)
    tmp = (h * 60 + m) * 60 + sec
    return float(tmp)
def pad(n):
    if n < 10:
        return "0" + str(n)
    return str(n)
def meanTime(times):
    ssum = 0.0
    csum = 0.0
    i = 0
    while i < len(times):
        sec = parseSec(times[i])
        ang = sec * 2.0 * PI / 86400.0
        ssum = ssum + sinApprox(ang)
        csum = csum + cosApprox(ang)
        i = i + 1
    theta = atan2Approx(ssum, csum)
    frac = theta / (2.0 * PI)
    while frac < 0.0:
        frac = frac + 1.0
    total = frac * 86400.0
    si = int(total)
    h = int((si / 3600))
    m = int(((si % 3600) / 60))
    s = int((si % 60))
    return pad(h) + ":" + pad(m) + ":" + pad(s)
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    inputs = ["23:00:17", "23:40:20", "00:12:45", "00:17:19"]
    print(meanTime(inputs))
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
