# Code generated by Mochi transpiler.
# Version 0.10.40, generated on 2025-07-25 19:37 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

@dataclass
class Point:
    x: float
    y: float
    z: float

@dataclass
class Edge:
    pn1: int
    pn2: int
    fn1: int
    fn2: int
    cp: Point

@dataclass
class PointEx:
    p: Point
    n: int

def indexOf(s, ch):
    i = 0
    while i < len(s):
        if s[i:i + 1] == ch:
            return i
        i = i + 1
    return -1
def fmt4(x):
    y = x * 10000.0
    if y >= 0:
        y = y + 0.5
    else:
        y = y - 0.5
    y = float((int(y))) / 10000.0
    s = str(y)
    dot = s.find(".")
    if dot == 0 - 1:
        s = s + ".0000"
    else:
        decs = len(s) - dot - 1
        if decs > 4:
            s = s[0:dot + 5]
        else:
            while decs < 4:
                s = s + "0"
                decs = decs + 1
    if x >= 0.0:
        s = " " + s
    return s
def fmt2(n):
    s = str(n)
    if len(s) < 2:
        return " " + s
    return s
def sumPoint(p1, p2):
    return Point(x=p1.x + p2.x, y=p1.y + p2.y, z=p1.z + p2.z)
def mulPoint(p, m):
    return Point(x=p.x * m, y=p.y * m, z=p.z * m)
def divPoint(p, d):
    return mulPoint(p, 1.0 / d)
def centerPoint(p1, p2):
    return divPoint(sumPoint(p1, p2), 2.0)
def getFacePoints(points, faces):
    facePoints = []
    i = 0
    while i < len(faces):
        face = faces[i]
        fp = Point(x=0.0, y=0.0, z=0.0)
        for idx in face:
            fp = sumPoint(fp, points[idx])
        fp = divPoint(fp, (float(len(face))))
        facePoints = facePoints + [fp]
        i = i + 1
    return facePoints
def sortEdges(edges):
    res = []
    tmp = edges
    while len(tmp) > 0:
        min = tmp[0]
        idx = 0
        j = 1
        while j < len(tmp):
            e = tmp[j]
            if e[0] < min[0] or (e[0] == min[0] and (e[1] < min[1] or (e[1] == min[1] and e[2] < min[2]))):
                min = e
                idx = j
            j = j + 1
        res = res + [min]
        out = []
        k = 0
        while k < len(tmp):
            if k != idx:
                out = out + [tmp[k]]
            k = k + 1
        tmp = out
    return res
def getEdgesFaces(points, faces):
    edges = []
    fnum = 0
    while fnum < len(faces):
        face = faces[fnum]
        numP = len(face)
        pi = 0
        while pi < numP:
            pn1 = face[pi]
            pn2 = 0
            if pi < numP - 1:
                pn2 = face[pi + 1]
            else:
                pn2 = face[0]
            if pn1 > pn2:
                tmpn = pn1
                pn1 = pn2
                pn2 = tmpn
            edges = edges + [[pn1, pn2, fnum]]
            pi = pi + 1
        fnum = fnum + 1
    edges = sortEdges(edges)
    merged = []
    idx = 0
    while idx < len(edges):
        e1 = edges[idx]
        if idx < len(edges) - 1:
            e2 = edges[idx + 1]
            if e1[0] == e2[0] and e1[1] == e2[1]:
                merged = merged + [[e1[0], e1[1], e1[2], e2[2]]]
                idx = idx + 2
                continue
        merged = merged + [[e1[0], e1[1], e1[2], -1]]
        idx = idx + 1
    edgesCenters = []
    for me in merged:
        p1 = points[me[0]]
        p2 = points[me[1]]
        cp = centerPoint(p1, p2)
        edgesCenters = edgesCenters + [Edge(pn1=me[0], pn2=me[1], fn1=me[2], fn2=me[3], cp=cp)]
    return edgesCenters
def getEdgePoints(points, edgesFaces, facePoints):
    edgePoints = []
    i = 0
    while i < len(edgesFaces):
        edge = edgesFaces[i]
        cp = edge.cp
        fp1 = facePoints[edge.fn1]
        fp2 = fp1
        if edge.fn2 != 0 - 1:
            fp2 = facePoints[edge.fn2]
        cfp = centerPoint(fp1, fp2)
        edgePoints = edgePoints + [centerPoint(cp, cfp)]
        i = i + 1
    return edgePoints
def getAvgFacePoints(points, faces, facePoints):
    numP = len(points)
    temp = []
    i = 0
    while i < numP:
        temp = temp + [PointEx(p=Point(x=0.0, y=0.0, z=0.0), n=0)]
        i = i + 1
    fnum = 0
    while fnum < len(faces):
        fp = facePoints[fnum]
        for pn in faces[fnum]:
            tp = temp[pn]
            temp[pn] = PointEx(p=sumPoint(tp.p, fp), n=tp.n + 1)
        fnum = fnum + 1
    avg = []
    j = 0
    while j < numP:
        tp = temp[j]
        avg = avg + [divPoint(tp.p, float(tp.n))]
        j = j + 1
    return avg
def getAvgMidEdges(points, edgesFaces):
    numP = len(points)
    temp = []
    i = 0
    while i < numP:
        temp = temp + [PointEx(p=Point(x=0.0, y=0.0, z=0.0), n=0)]
        i = i + 1
    for edge in edgesFaces:
        cp = edge.cp
        arr = [edge.pn1, edge.pn2]
        for pn in arr:
            tp = temp[pn]
            temp[pn] = PointEx(p=sumPoint(tp.p, cp), n=tp.n + 1)
    avg = []
    j = 0
    while j < numP:
        tp = temp[j]
        avg = avg + [divPoint(tp.p, float(tp.n))]
        j = j + 1
    return avg
def getPointsFaces(points, faces):
    pf = []
    i = 0
    while i < len(points):
        pf = pf + [0]
        i = i + 1
    fnum = 0
    while fnum < len(faces):
        for pn in faces[fnum]:
            pf[pn] = pf[pn] + 1
        fnum = fnum + 1
    return pf
def getNewPoints(points, pf, afp, ame):
    newPts = []
    i = 0
    while i < len(points):
        n = float(pf[i])
        m1 = (n - 3.0) / n
        m2 = 1.0 / n
        m3 = 2.0 / n
        old = points[i]
        p1 = mulPoint(old, m1)
        p2 = mulPoint(afp[i], m2)
        p3 = mulPoint(ame[i], m3)
        newPts = newPts + [sumPoint(sumPoint(p1, p2), p3)]
        i = i + 1
    return newPts
def key(a, b):
    if a < b:
        return str(a) + "," + str(b)
    return str(b) + "," + str(a)
def cmcSubdiv(points, faces):
    facePoints = getFacePoints(points, faces)
    edgesFaces = getEdgesFaces(points, faces)
    edgePoints = getEdgePoints(points, edgesFaces, facePoints)
    avgFacePoints = getAvgFacePoints(points, faces, facePoints)
    avgMidEdges = getAvgMidEdges(points, edgesFaces)
    pointsFaces = getPointsFaces(points, faces)
    newPoints = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges)
    facePointNums = []
    nextPoint = len(newPoints)
    for fp in facePoints:
        newPoints = newPoints + [fp]
        facePointNums = facePointNums + [nextPoint]
        nextPoint = nextPoint + 1
    edgePointNums = {}
    idx = 0
    while idx < len(edgesFaces):
        e = edgesFaces[idx]
        newPoints = newPoints + [edgePoints[idx]]
        edgePointNums[key(e.pn1, e.pn2)] = nextPoint
        nextPoint = nextPoint + 1
        idx = idx + 1
    newFaces = []
    fnum = 0
    while fnum < len(faces):
        oldFace = faces[fnum]
        if len(oldFace) == 4:
            a = oldFace[0]
            b = oldFace[1]
            c = oldFace[2]
            d = oldFace[3]
            fpnum = facePointNums[fnum]
            ab = edgePointNums[key(a, b)]
            da = edgePointNums[key(d, a)]
            bc = edgePointNums[key(b, c)]
            cd = edgePointNums[key(c, d)]
            newFaces = newFaces + [[a, ab, fpnum, da]]
            newFaces = newFaces + [[b, bc, fpnum, ab]]
            newFaces = newFaces + [[c, cd, fpnum, bc]]
            newFaces = newFaces + [[d, da, fpnum, cd]]
        fnum = fnum + 1
    return [newPoints, newFaces]
def formatPoint(p):
    return "[" + fmt4(p.x) + " " + fmt4(p.y) + " " + fmt4(p.z) + "]"
def formatFace(f):
    if len(f) == 0:
        return "[]"
    s = "[" + fmt2(f[0])
    i = 1
    while i < len(f):
        s = s + " " + fmt2(f[i])
        i = i + 1
    s = s + "]"
    return s
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    inputPoints = [Point(x=-1.0, y=1.0, z=1.0), Point(x=-1.0, y=-1.0, z=1.0), Point(x=1.0, y=-1.0, z=1.0), Point(x=1.0, y=1.0, z=1.0), Point(x=1.0, y=-1.0, z=-1.0), Point(x=1.0, y=1.0, z=-1.0), Point(x=-1.0, y=-1.0, z=-1.0), Point(x=-1.0, y=1.0, z=-1.0)]
    inputFaces = [[0, 1, 2, 3], [3, 2, 4, 5], [5, 4, 6, 7], [7, 0, 3, 5], [7, 6, 1, 0], [6, 1, 2, 4]]
    outputPoints = inputPoints
    outputFaces = inputFaces
    i = 0
    while i < 1:
        res = cmcSubdiv(outputPoints, outputFaces)
        outputPoints = res[0]
        outputFaces = res[1]
        i = i + 1
    for p in outputPoints:
        print(formatPoint(p))
    print("")
    for f in outputFaces:
        print(formatFace(f))
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
