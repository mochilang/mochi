# Code generated by Mochi transpiler.
# Version 0.10.39, generated on 2025-07-25 10:11 +0700
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

THRESHOLD = 140737488355328
def indexOf(xs, value):
    i = 0
    while i < len(xs):
        if xs[i] == value:
            return i
        i = i + 1
    return 0 - 1
def contains(xs, value):
    return indexOf(xs, value) != 0 - 1
def maxOf(a, b):
    if a > b:
        return a
    else:
        return b
def intSqrt(n):
    if n == 0:
        return 0
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + (n // x)) // 2
    return x
def sumProperDivisors(n):
    if n < 2:
        return 0
    sqrt = intSqrt(n)
    sum = 1
    i = 2
    while i <= sqrt:
        if n % i == 0:
            sum = sum + i + (n // i)
        i = i + 1
    if sqrt * sqrt == n:
        sum = sum - sqrt
    return sum
def classifySequence(k):
    last = k
    seq = [k]
    while True:
        last = sumProperDivisors(last)
        seq = seq + [last]
        n = len(seq)
        aliquot = ""
        if last == 0:
            aliquot = "Terminating"
        else:
            if n == 2 and last == k:
                aliquot = "Perfect"
            else:
                if n == 3 and last == k:
                    aliquot = "Amicable"
                else:
                    if n >= 4 and last == k:
                        aliquot = "Sociable[" + str(n - 1) + "]"
                    else:
                        if last == seq[n - 2]:
                            aliquot = "Aspiring"
                        else:
                            if contains(seq[1:maxOf(1, n - 2)], last):
                                idx = indexOf(seq, last)
                                aliquot = "Cyclic[" + str(n - 1 - idx) + "]"
                            else:
                                if n == 16 or last > THRESHOLD:
                                    aliquot = "Non-Terminating"
        if aliquot != "":
            return {"seq": seq, "aliquot": aliquot}
    return {"seq": seq, "aliquot": ""}
def padLeft(n, w):
    s = str(n)
    while len(s) < w:
        s = " " + s
    return s
def padRight(s, w):
    r = s
    while len(r) < w:
        r = r + " "
    return r
def joinWithCommas(seq):
    s = "["
    i = 0
    while i < len(seq):
        s = s + str(seq[i])
        if i < len(seq) - 1:
            s = s + ", "
        i = i + 1
    s = s + "]"
    return s
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    print("Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n")
    k = 1
    while k <= 10:
        res = classifySequence(k)
        print(padLeft(k, 2) + ": " + padRight(str(res["aliquot"]), 15) + " " + joinWithCommas(res["seq"]))
        k = k + 1
    print("")
    s = [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]
    i = 0
    while i < len(s):
        val = s[i]
        res = classifySequence(val)
        print(padLeft(val, 7) + ": " + padRight(str(res["aliquot"]), 15) + " " + joinWithCommas(res["seq"]))
        i = i + 1
    print("")
    big = 15355717786080
    r = classifySequence(big)
    print(str(big) + ": " + padRight(str(r["aliquot"]), 15) + " " + joinWithCommas(r["seq"]))
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
