# Code generated by Mochi transpiler.
# Version 0.10.42, generated on 2025-07-28 10:08 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
INF = 1000000
@dataclass
class FWResult:
    dist: [[int]]
    next: [[int]]
def floydWarshall(graph):
    n = len(graph)
    dist = []
    next = []
    i = 0
    while i < n:
        drow = []
        nrow = []
        j = 0
        while j < n:
            drow = drow + [graph[i][j]]
            if graph[i][j] < INF and i != j:
                nrow = nrow + [j]
            else:
                nrow = nrow + [-1]
            j = j + 1
        dist = dist + [drow]
        next = next + [nrow]
        i = i + 1
    k = 0
    while k < n:
        i = 0
        while i < n:
            j = 0
            while j < n:
                if dist[i][k] < INF and dist[k][j] < INF:
                    alt = dist[i][k] + dist[k][j]
                    if alt < dist[i][j]:
                        dist[i][j] = alt
                        next[i][j] = next[i][k]
                j = j + 1
            i = i + 1
        k = k + 1
    return FWResult(dist=dist, next=next)
def path(u, v, next):
    if next[u][v] < 0:
        return []
    p = [u]
    x = u
    while x != v:
        x = next[x][v]
        p = p + [x]
    return p
def pathStr(p):
    s = ""
    i = 0
    while i < len(p):
        s = s + str(p[i] + 1)
        if i < len(p) - 1:
            s = s + " -> "
        i = i + 1
    return s
n = 4
g = []
for i in range(0, n):
    row = []
    for j in range(0, n):
        if i == j:
            row = row + [0]
        else:
            row = row + [INF]
    g = g + [row]
g[0][2] = -2
g[2][3] = 2
g[3][1] = -1
g[1][0] = 4
g[1][2] = 3
res = floydWarshall(g)
print("pair\tdist\tpath")
i = 0
while i < n:
    j = 0
    while j < n:
        if i != j:
            p = path(i, j, res.next)
            print(str(i + 1) + " -> " + str(j + 1) + "\t" + str(res.dist[i][j]) + "\t" + pathStr(p))
        j = j + 1
    i = i + 1
_bench_end = _now()
_bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
