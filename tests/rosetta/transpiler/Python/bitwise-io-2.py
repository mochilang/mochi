# Code generated by Mochi transpiler.
# Version 0.10.40, generated on 2025-07-25 17:48 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
def pow2(n):
    v = 1
    i = 0
    while i < n:
        v = v * 2
        i = i + 1
    return v
def lshift(x, n):
    return x * pow2(n)
def rshift(x, n):
    return x / pow2(n)
@dataclass
class Writer:
    order: str
    bits: int
    nbits: int
    data: [int]
def NewWriter(order):
    return Writer(order=order, bits=0, nbits=0, data=[])
def writeBitsLSB(w, c, width):
    w = dataclasses.replace(w, bits=w.bits + lshift(c, w.nbits))
    w = dataclasses.replace(w, nbits=w.nbits + width)
    while w.nbits >= 8:
        b = w.bits % 256
        w = dataclasses.replace(w, data=w.data + [b])
        w = dataclasses.replace(w, bits=rshift(w.bits, 8))
        w = dataclasses.replace(w, nbits=w.nbits - 8)
    return w
def writeBitsMSB(w, c, width):
    w = dataclasses.replace(w, bits=w.bits + lshift(c, 32 - width - w.nbits))
    w = dataclasses.replace(w, nbits=w.nbits + width)
    while w.nbits >= 8:
        b = rshift(w.bits, 24) % 256
        w = dataclasses.replace(w, data=w.data + [b])
        w = dataclasses.replace(w, bits=(w.bits % pow2(24)) * 256)
        w = dataclasses.replace(w, nbits=w.nbits - 8)
    return w
def WriteBits(w, c, width):
    if w.order == "LSB":
        return writeBitsLSB(w, c, width)
    return writeBitsMSB(w, c, width)
def CloseWriter(w):
    if w.nbits > 0:
        if w.order == "MSB":
            w = dataclasses.replace(w, bits=rshift(w.bits, 24))
        w = dataclasses.replace(w, data=w.data + [w.bits % 256])
    w = dataclasses.replace(w, bits=0)
    w = dataclasses.replace(w, nbits=0)
    return w
@dataclass
class Reader:
    order: str
    data: [int]
    idx: int
    bits: int
    nbits: int
def NewReader(data, order):
    return Reader(order=order, data=data, idx=0, bits=0, nbits=0)
def readBitsLSB(r, width):
    while r.nbits < width:
        if r.idx >= len(r.data):
            return {"val": 0, "eof": True}
        b = r.data[r.idx]
        r = dataclasses.replace(r, idx=r.idx + 1)
        r = dataclasses.replace(r, bits=r.bits + lshift(b, r.nbits))
        r = dataclasses.replace(r, nbits=r.nbits + 8)
    mask = pow2(width) - 1
    out = r.bits % (mask + 1)
    r = dataclasses.replace(r, bits=rshift(r.bits, width))
    r = dataclasses.replace(r, nbits=r.nbits - width)
    return {"val": out, "eof": False}
def readBitsMSB(r, width):
    while r.nbits < width:
        if r.idx >= len(r.data):
            return {"val": 0, "eof": True}
        b = r.data[r.idx]
        r = dataclasses.replace(r, idx=r.idx + 1)
        r = dataclasses.replace(r, bits=r.bits + lshift(b, 24 - r.nbits))
        r = dataclasses.replace(r, nbits=r.nbits + 8)
    out = rshift(r.bits, 32 - width)
    r = dataclasses.replace(r, bits=(r.bits * pow2(width)) % pow2(32))
    r = dataclasses.replace(r, nbits=r.nbits - width)
    return {"val": out, "eof": False}
def ReadBits(r, width):
    if r.order == "LSB":
        return readBitsLSB(r, width)
    return readBitsMSB(r, width)
def toBinary(n, bits):
    b = ""
    val = n
    i = 0
    while i < bits:
        b = str(val % 2) + b
        val = val // 2
        i = i + 1
    return b
def bytesToBits(bs):
    out = "["
    i = 0
    while i < len(bs):
        out = out + toBinary(bs[i], 8)
        if i + 1 < len(bs):
            out = out + " "
        i = i + 1
    out = out + "]"
    return out
def bytesToHex(bs):
    digits = "0123456789ABCDEF"
    out = ""
    i = 0
    while i < len(bs):
        b = bs[i]
        hi = b // 16
        lo = b % 16
        out = out + "".join(digits[hi:hi + 1]) + "".join(digits[lo:lo + 1])
        if i + 1 < len(bs):
            out = out + " "
        i = i + 1
    return out
def ord(ch):
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    idx = upper.find(ch)
    if idx >= 0:
        return 65 + idx
    idx = lower.find(ch)
    if idx >= 0:
        return 97 + idx
    if ch >= "0" and ch <= "9":
        return 48 + parseIntStr(ch)
    if ch == " ":
        return 32
    if ch == ".":
        return 46
    return 0
def chr(n):
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lower = "abcdefghijklmnopqrstuvwxyz"
    if n >= 65 and n < 91:
        return upper[n - 65:n - 64]
    if n >= 97 and n < 123:
        return lower[n - 97:n - 96]
    if n >= 48 and n < 58:
        digits = "0123456789"
        return digits[n - 48:n - 47]
    if n == 32:
        return " "
    if n == 46:
        return "."
    return "?"
def bytesOfStr(s):
    bs = []
    i = 0
    while i < len(s):
        bs = bs + [ord(s[i:i + 1])]
        i = i + 1
    return bs
def bytesToDec(bs):
    out = ""
    i = 0
    while i < len(bs):
        out = out + str(bs[i])
        if i + 1 < len(bs):
            out = out + " "
        i = i + 1
    return out
def Example():
    message = "This is a test."
    msgBytes = bytesOfStr(message)
    print("\"" + message + "\" as bytes: " + bytesToDec(msgBytes))
    print("    original bits: " + bytesToBits(msgBytes))
    bw = NewWriter("MSB")
    i = 0
    while i < len(msgBytes):
        bw = WriteBits(bw, msgBytes[i], 7)
        i = i + 1
    bw = CloseWriter(bw)
    print("Written bitstream: " + bytesToBits(bw.data))
    print("Written bytes: " + bytesToHex(bw.data))
    br = NewReader(bw.data, "MSB")
    result = ""
    while True:
        r = ReadBits(br, 7)
        if r.get("eof"):
            break
        v = int(r.get("val"))
        if v != 0:
            result = result + chr(v)
    print("Read back as \"" + result + "\"")
Example()
_bench_end = _now()
_bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
