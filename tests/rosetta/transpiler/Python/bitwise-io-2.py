# Code generated by Mochi transpiler.
# Version 0.10.56, generated on 2025-08-03 15:40 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)
import os
if os.path.dirname(__file__) in sys.path:
    sys.path.remove(os.path.dirname(__file__))


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

_bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
_bench_start = _now()
try:
    def pow2(n):
        v = 1
        i = 0
        while i < n:
            v = v * 2
            i = i + 1
        return v
    def lshift(x, n):
        return x * pow2(n)
    def rshift(x, n):
        return x // pow2(n)
    @dataclass
    class Writer:
        order: str
        bits: int
        nbits: int
        data: [int]
    def NewWriter(order):
        return Writer(order=order, bits=0, nbits=0, data=[])
    def writeBitsLSB(w, c, width):
        w.bits = w.bits + lshift(c, w.nbits)
        w.nbits = w.nbits + width
        while w.nbits >= 8:
            b = w.bits % 256
            w.data = w.data + [b]
            w.bits = rshift(w.bits, 8)
            w.nbits = w.nbits - 8
        return w
    def writeBitsMSB(w, c, width):
        w.bits = w.bits + lshift(c, 32 - width - w.nbits)
        w.nbits = w.nbits + width
        while w.nbits >= 8:
            b = rshift(w.bits, 24) % 256
            w.data = w.data + [b]
            w.bits = (w.bits % pow2(24)) * 256
            w.nbits = w.nbits - 8
        return w
    def WriteBits(w, c, width):
        if w.order == "LSB":
            return writeBitsLSB(w, c, width)
        return writeBitsMSB(w, c, width)
    def CloseWriter(w):
        if w.nbits > 0:
            if w.order == "MSB":
                w.bits = rshift(w.bits, 24)
            w.data = w.data + [w.bits % 256]
        w.bits = 0
        w.nbits = 0
        return w
    @dataclass
    class Reader:
        order: str
        data: [int]
        idx: int
        bits: int
        nbits: int
    def NewReader(data, order):
        return Reader(order=order, data=data, idx=0, bits=0, nbits=0)
    def readBitsLSB(r, width):
        while r.nbits < width:
            if r.idx >= len(r.data):
                return {"val": 0, "eof": True}
            b = r.data[r.idx]
            r.idx = r.idx + 1
            r.bits = r.bits + lshift(b, r.nbits)
            r.nbits = r.nbits + 8
        mask = pow2(width) - 1
        out = r.bits % (mask + 1)
        r.bits = rshift(r.bits, width)
        r.nbits = r.nbits - width
        return {"val": out, "eof": False}
    def readBitsMSB(r, width):
        while r.nbits < width:
            if r.idx >= len(r.data):
                return {"val": 0, "eof": True}
            b = r.data[r.idx]
            r.idx = r.idx + 1
            r.bits = r.bits + lshift(b, 24 - r.nbits)
            r.nbits = r.nbits + 8
        out = rshift(r.bits, 32 - width)
        r.bits = (r.bits * pow2(width)) % pow2(32)
        r.nbits = r.nbits - width
        return {"val": out, "eof": False}
    def ReadBits(r, width):
        if r.order == "LSB":
            return readBitsLSB(r, width)
        return readBitsMSB(r, width)
    def toBinary(n, bits):
        b = ""
        val = n
        i = 0
        while i < bits:
            b = str(val % 2) + b
            val = val // 2
            i = i + 1
        return b
    def bytesToBits(bs):
        out = "["
        i = 0
        while i < len(bs):
            out = out + toBinary(bs[i], 8)
            if i + 1 < len(bs):
                out = out + " "
            i = i + 1
        out = out + "]"
        return out
    def bytesToHex(bs):
        digits = "0123456789ABCDEF"
        out = ""
        i = 0
        while i < len(bs):
            b = bs[i]
            hi = b // 16
            lo = b % 16
            out = out + digits[hi:hi + 1] + digits[lo:lo + 1]
            if i + 1 < len(bs):
                out = out + " "
            i = i + 1
        return out
    def ord(ch):
        upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        lower = "abcdefghijklmnopqrstuvwxyz"
        idx = upper.find(ch)
        if idx >= 0:
            return 65 + idx
        idx = lower.find(ch)
        if idx >= 0:
            return 97 + idx
        if ch >= "0" and ch <= "9":
            return 48 + parseIntStr(ch)
        if ch == " ":
            return 32
        if ch == ".":
            return 46
        return 0
    def chr(n):
        upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        lower = "abcdefghijklmnopqrstuvwxyz"
        if n >= 65 and n < 91:
            return upper[n - 65:n - 64]
        if n >= 97 and n < 123:
            return lower[n - 97:n - 96]
        if n >= 48 and n < 58:
            digits = "0123456789"
            return digits[n - 48:n - 47]
        if n == 32:
            return " "
        if n == 46:
            return "."
        return "?"
    def bytesOfStr(s):
        bs = []
        i = 0
        while i < len(s):
            bs = bs + [ord(s[i:i + 1])]
            i = i + 1
        return bs
    def bytesToDec(bs):
        out = ""
        i = 0
        while i < len(bs):
            out = out + str(bs[i])
            if i + 1 < len(bs):
                out = out + " "
            i = i + 1
        return out
    def Example():
        message = "This is a test."
        msgBytes = bytesOfStr(message)
        print("\"" + message + "\" as bytes: " + bytesToDec(msgBytes))
        print("    original bits: " + bytesToBits(msgBytes))
        bw = NewWriter("MSB")
        i = 0
        while i < len(msgBytes):
            bw = WriteBits(bw, msgBytes[i], 7)
            i = i + 1
        bw = CloseWriter(bw)
        print("Written bitstream: " + bytesToBits(bw.data))
        print("Written bytes: " + bytesToHex(bw.data))
        br = NewReader(bw.data, "MSB")
        result = ""
        while True:
            r = ReadBits(br, 7)
            if r.get("eof"):
                break
            v = int(r.get("val"))
            if v != 0:
                result = result + chr(v)
        print("Read back as \"" + result + "\"")
    Example()
finally:
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
