# Code generated by Mochi transpiler.
# Version 0.10.42, generated on 2025-07-28 10:14 +0700
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict
import dataclasses
import json
import os
import resource
import time

import sys
sys.set_int_max_str_digits(0)


_now_seed = 0
_now_seeded = False
s = os.getenv("MOCHI_NOW_SEED")
if s and s != "":
    try:
        _now_seed = int(s)
        _now_seeded = True
    except Exception:
        pass

def _now():
    global _now_seed
    if _now_seeded:
        _now_seed = (_now_seed * 1664525 + 1013904223) % 2147483647
        return _now_seed
    return int(time.time_ns())

board = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
solved = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
empty = 15
moves = 0
quit = False
def randMove():
    return _now() % 4
def isSolved():
    i = 0
    while i < 16:
        if board[i] != solved[i]:
            return False
        i = i + 1
    return True
@dataclass
class MoveResult:
    idx: int
    ok: bool

def isValidMove(m):
    if m == 0:
        return MoveResult(idx=empty - 4, ok=(empty // 4) > 0)
    if m == 1:
        return MoveResult(idx=empty + 4, ok=(empty // 4) < 3)
    if m == 2:
        return MoveResult(idx=empty + 1, ok=empty % 4 < 3)
    if m == 3:
        return MoveResult(idx=empty - 1, ok=empty % 4 > 0)
    return MoveResult(idx=0, ok=False)
def doMove(m):
    global empty, moves
    r = isValidMove(m)
    if not r.ok:
        return False
    i = empty
    j = r.idx
    tmp = board[i]
    board[i] = board[j]
    board[j] = tmp
    empty = j
    moves = moves + 1
    return True
def shuffle(n):
    i = 0
    while i < n or isSolved():
        if doMove(randMove()):
            i = i + 1
def printBoard():
    line = ""
    i = 0
    while i < 16:
        val = board[i]
        if val == 0:
            line = line + "  ."
        else:
            s = str(val)
            if val < 10:
                line = line + "  " + s
            else:
                line = line + " " + s
        if i % 4 == 3:
            print(line)
            line = ""
        i = i + 1
def playOneMove():
    global quit
    while True:
        print("Enter move #" + str(moves + 1) + " (U, D, L, R, or Q): ")
        s = input()
        if s == "":
            continue
        c = s[0:1]
        m = 0
        if c == "U" or c == "u":
            m = 0
        else:
            if c == "D" or c == "d":
                m = 1
            else:
                if c == "R" or c == "r":
                    m = 2
                else:
                    if c == "L" or c == "l":
                        m = 3
                    else:
                        if c == "Q" or c == "q":
                            print("Quiting after " + str(moves) + " moves.")
                            quit = True
                            return
                        else:
                            print("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" + "up, down, left, or right. You can also enter \"Q\" to quit.\n" + "Upper or lowercase is accepted and only the first non-blank\n" + "character is important (i.e. you may enter \"up\" if you like).")
                            continue
        if not doMove(m):
            print("That is not a valid move at the moment.")
            continue
        return
def play():
    print("Starting board:")
    while not quit and isSolved() == False:
        print("")
        printBoard()
        playOneMove()
    if isSolved():
        print("You solved the puzzle in " + str(moves) + " moves.")
def main():
    _bench_mem_start = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    _bench_start = _now()
    shuffle(50)
    play()
    _bench_end = _now()
    _bench_mem_end = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
    print(json.dumps({"duration_us": (_bench_end - _bench_start)//1000, "memory_bytes": _bench_mem_end*1024, "name": "main"}, indent=2))
main()
