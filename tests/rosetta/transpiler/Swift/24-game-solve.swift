// Generated by Mochi transpiler v0.10.39 on 2025-07-25 09:13:34 GMT+7
import Foundation

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
struct Rational {
    var num: Int
    var denom: Int
}
let OP_ADD = 1
let OP_SUB = 2
let OP_MUL = 3
let OP_DIV = 4
indirect enum Expr {
    case Num(value: Rational)
    case Bin(op: Int, left: Expr, right: Expr)
}
func binEval(_ op: Int, _ l: Expr, _ r: Expr) -> Rational {
    let lv = exprEval((l as! Expr))
    let rv = exprEval((r as! Expr))
    if (op == OP_ADD) {
        return (Rational(num: ((lv.num * rv.denom) + (lv.denom * rv.num)), denom: (lv.denom * rv.denom)) as! Rational)
    }
    if (op == OP_SUB) {
        return (Rational(num: ((lv.num * rv.denom) - (lv.denom * rv.num)), denom: (lv.denom * rv.denom)) as! Rational)
    }
    if (op == OP_MUL) {
        return (Rational(num: (lv.num * rv.num), denom: (lv.denom * rv.denom)) as! Rational)
    }
    return (Rational(num: (lv.num * rv.denom), denom: (lv.denom * rv.num)) as! Rational)
}
func binString(_ op: Int, _ l: Expr, _ r: Expr) -> String {
    let ls = String(describing: exprString((l as! Expr)))
    let rs = String(describing: exprString((r as! Expr)))
    var opstr = ""
    if (op == OP_ADD) {
        opstr = " + "
    } else if (op == OP_SUB) {
        opstr = " - "
    } else if (op == OP_MUL) {
        opstr = " * "
    } else {
        opstr = " / "
    }
    
    
    return ((((("(" + ls) + opstr) + rs) + ")") as! String)
}
func newNum(_ n: Int) -> Expr {
    return (Expr.Num(value: Rational(num: n, denom: 1)) as! Expr)
}
func exprEval(_ x: Expr) -> Rational {
    return ({ () -> Any in
    switch x {
        case let .Num(v):
        return v
        case let .Bin(op, l, r):
        return binEval((op as! Int), (l as! Expr), (r as! Expr))
        default:
        var z: Any
        return z
    }
}() as! Rational)
}
func exprString(_ x: Expr) -> String {
    return String(describing: { () -> String in
    switch x {
        case let .Num(v):
        return String(describing: v.num)
        case let .Bin(op, l, r):
        return String(describing: binString((op as! Int), (l as! Expr), (r as! Expr)))
        default:
        var z: String
        return z
    }
}())
}
let n_cards = 4
let goal = 24
let digit_range = 9
func solve(_ xs: [Expr]) -> Bool {
    if (Int(((xs).count)) == 1) {
        let f = exprEval((xs[0] as! Expr))
        if ((f.denom != 0) && (f.num == (f.denom * goal))) {
            print(String(describing: exprString((xs[0] as! Expr))))
            return true
        }
        return false
    }
    var i = 0
    while (i < Int(((xs).count))) {
        var j = ((i + 1) as! Int)
        while (j < Int(((xs).count))) {
            var rest: [Expr] = ([] as! [Expr])
            var k = 0
            while (k < Int(((xs).count))) {
                if ((k != i) && (k != j)) {
                    rest = ((rest + [xs[k]]) as! [Expr])
                }
                k = ((k + 1) as! Int)
            }
            let a = xs[i]
            let b = xs[j]
            var node = (Expr.Bin(op: OP_ADD, left: a, right: b) as! Expr)
            for op in ([OP_ADD, OP_SUB, OP_MUL, OP_DIV] as! [Int]) {
                node = (Expr.Bin(op: op, left: a, right: b) as! Expr)
                if Bool(solve(((rest + [node]) as! [Expr]))) {
                    return true
                }
            }
            node = (Expr.Bin(op: OP_SUB, left: b, right: a) as! Expr)
            if Bool(solve(((rest + [node]) as! [Expr]))) {
                return true
            }
            node = (Expr.Bin(op: OP_DIV, left: b, right: a) as! Expr)
            if Bool(solve(((rest + [node]) as! [Expr]))) {
                return true
            }
            j = ((j + 1) as! Int)
        }
        i = ((i + 1) as! Int)
    }
    return false
}
func main() {
    var iter = 0
    while (iter < 10) {
        var cards: [Expr] = ([] as! [Expr])
        var i = 0
        while (i < n_cards) {
            let n = (Int((Int(_now()) % Int((digit_range - 1)))) + 1)
            cards = ((cards + [newNum((n as! Int))]) as! [Expr])
            print((" " + String(describing: n)))
            i = ((i + 1) as! Int)
        }
        print(":  ")
        if (!Bool(solve((cards as! [Expr])))) {
            print("No solution")
        }
        iter = ((iter + 1) as! Int)
    }
}
_ = main()
