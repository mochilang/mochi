// Generated by Mochi transpiler v0.10.37 on 2025-07-23 13:55:23 GMT+7
import Foundation

let OP_NUM = 0
let OP_ADD = 1
let OP_SUB = 2
let OP_MUL = 3
let OP_DIV = 4
func newNum(_ n: Int) -> [String: Any] {
    var n = n
    return (["op": Int(OP_NUM), "value": ["num": Int(n), "denom": 1] as [String: Any]] as [String: Any] as! [String: Any])
}
func exprEval(_ x: [String: Any]) -> [String: Int] {
    var x = x
    if (((x as! [String: Any])["op"]! as! Int) == Int(OP_NUM)) {
        return ((x as! [String: Any])["value"]! as! [String: Int])
    }
    let l = (exprEval(((x as! [String: Any])["left"]! as! [String: Any])) as! [String: Int])
    let r = (exprEval(((x as! [String: Any])["right"]! as! [String: Any])) as! [String: Int])
    if (((x as! [String: Any])["op"]! as! Int) == Int(OP_ADD)) {
        return (["num": ((Int(l["num"]!) * Int(r["denom"]!)) + (Int(l["denom"]!) * Int(r["num"]!))), "denom": (Int(l["denom"]!) * Int(r["denom"]!))] as [String: Any] as! [String: Int])
    }
    if (((x as! [String: Any])["op"]! as! Int) == Int(OP_SUB)) {
        return (["num": ((Int(l["num"]!) * Int(r["denom"]!)) - (Int(l["denom"]!) * Int(r["num"]!))), "denom": (Int(l["denom"]!) * Int(r["denom"]!))] as [String: Any] as! [String: Int])
    }
    if (((x as! [String: Any])["op"]! as! Int) == Int(OP_MUL)) {
        return (["num": (Int(l["num"]!) * Int(r["num"]!)), "denom": (Int(l["denom"]!) * Int(r["denom"]!))] as [String: Any] as! [String: Int])
    }
    return (["num": (Int(l["num"]!) * Int(r["denom"]!)), "denom": (Int(l["denom"]!) * Int(r["num"]!))] as [String: Any] as! [String: Int])
}
func exprString(_ x: [String: Any]) -> String {
    var x = x
    if (((x as! [String: Any])["op"]! as! Int) == Int(OP_NUM)) {
        return String(String(describing: ((x as! [String: Any])["value"]! as! [String: Any])["num"]))
    }
    let ls = String(exprString(((x as! [String: Any])["left"]! as! [String: Any])))
    let rs = String(exprString(((x as! [String: Any])["right"]! as! [String: Any])))
    var opstr = ""
    if (((x as! [String: Any])["op"]! as! Int) == Int(OP_ADD)) {
        opstr = " + "
    } else if (((x as! [String: Any])["op"]! as! Int) == Int(OP_SUB)) {
        opstr = " - "
    } else if (((x as! [String: Any])["op"]! as! Int) == Int(OP_MUL)) {
        opstr = " * "
    } else {
        opstr = " / "
    }
    
    
    return ((((("(" + String(ls)) + String(opstr)) + String(rs)) + ")") as! String)
}
let n_cards = 4
let goal = 24
let digit_range = 9
func solve(_ xs: [[String: Any]]) -> Bool {
    var xs = xs
    if (Int((((xs as! [[String: Any]])).count)) == 1) {
        let f = (exprEval((xs[0] as! [String: Any])) as! [String: Int])
        if ((Int(f["denom"]!) != 0) && (Int(f["num"]!) == (Int(f["denom"]!) * Int(goal)))) {
            print(String(exprString((xs[0] as! [String: Any]))))
            return true
        }
        return false
    }
    var i = 0
    while (Int(i) < Int((((xs as! [[String: Any]])).count))) {
        var j = ((Int(i) + 1) as! Int)
        while (Int(j) < Int((((xs as! [[String: Any]])).count))) {
            var rest: [[String: Any]] = ([] as! [[String: Any]])
            var k = 0
            while (Int(k) < Int((((xs as! [[String: Any]])).count))) {
                if ((Int(k) != Int(i)) && (Int(k) != Int(j))) {
                    rest = (((rest as! [[String: Any]]) + [(xs[Int(k)] as! [String: Any])]) as! [[String: Any]])
                }
                k = ((Int(k) + 1) as! Int)
            }
            let a = (xs[Int(i)] as! [String: Any])
            let b = (xs[Int(j)] as! [String: Any])
            for op in ([Int(OP_ADD), Int(OP_SUB), Int(OP_MUL), Int(OP_DIV)] as! [Int]) {
                var node = ["op": op, "left": (a as! [String: Any]), "right": (b as! [String: Any])] as [String: Any]
                if (solve((((((rest as! [[String: Any]]) + [node]) as! [[String: Any]]) as! [Any]) as! [[String: Any]])) as! Bool) {
                    return true
                }
            }
            var node = ["op": Int(OP_SUB), "left": (b as! [String: Any]), "right": (a as! [String: Any])] as [String: Any]
            if (solve((((((rest as! [[String: Any]]) + [node]) as! [[String: Any]]) as! [Any]) as! [[String: Any]])) as! Bool) {
                return true
            }
            node = ["op": Int(OP_DIV), "left": (b as! [String: Any]), "right": (a as! [String: Any])] as [String: Any]
            if (solve((((((rest as! [[String: Any]]) + [node]) as! [[String: Any]]) as! [Any]) as! [[String: Any]])) as! Bool) {
                return true
            }
            j = ((Int(j) + 1) as! Int)
        }
        i = ((Int(i) + 1) as! Int)
    }
    return false
}
func main() {
    var iter = 0
    while (Int(iter) < 10) {
        var cards: [[String: Any]] = ([] as! [[String: Any]])
        var i = 0
        while (Int(i) < Int(n_cards)) {
            let n = (Int((Int(Int.random(in: 0..<Int.max)) % Int((Int(digit_range) - 1)))) + 1)
            cards = (((cards as! [[String: Any]]) + [(newNum(Int(n)) as! [String: Any])]) as! [[String: Any]])
            print((" " + String(String(describing: Int(n)))))
            i = ((Int(i) + 1) as! Int)
        }
        print(":  ")
        if (!(solve((cards as! [[String: Any]])) as! Bool)) {
            print("No solution")
        }
        iter = ((Int(iter) + 1) as! Int)
    }
}
main()
