// Generated by Mochi transpiler v0.10.38 on 2025-07-24 07:51:56 GMT+7
import Foundation

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
struct Rational {
    var num: Int
    var denom: Int
}
let OP_ADD = 1
let OP_SUB = 2
let OP_MUL = 3
let OP_DIV = 4
indirect enum Expr {
    case Num(value: Rational)
    case Bin(op: Int, left: Expr, right: Expr)
}
func binEval(_ op: Int, _ l: Expr, _ r: Expr) -> Rational {
    var op = op
    var l = l
    var r = r
    let lv = exprEval((l as! Expr))
    let rv = exprEval((r as! Expr))
    if (Int(op) == Int(OP_ADD)) {
        return (Rational(num: ((lv.num * rv.denom) + (lv.denom * rv.num)), denom: (lv.denom * rv.denom)) as! Rational)
    }
    if (Int(op) == Int(OP_SUB)) {
        return (Rational(num: ((lv.num * rv.denom) - (lv.denom * rv.num)), denom: (lv.denom * rv.denom)) as! Rational)
    }
    if (Int(op) == Int(OP_MUL)) {
        return (Rational(num: (lv.num * rv.num), denom: (lv.denom * rv.denom)) as! Rational)
    }
    return (Rational(num: (lv.num * rv.denom), denom: (lv.denom * rv.num)) as! Rational)
}
func binString(_ op: Int, _ l: Expr, _ r: Expr) -> String {
    var op = op
    var l = l
    var r = r
    let ls = String(exprString((l as! Expr)))
    let rs = String(exprString((r as! Expr)))
    var opstr = ""
    if (Int(op) == Int(OP_ADD)) {
        opstr = " + "
    } else if (Int(op) == Int(OP_SUB)) {
        opstr = " - "
    } else if (Int(op) == Int(OP_MUL)) {
        opstr = " * "
    } else {
        opstr = " / "
    }
    
    
    return ((((("(" + String(ls)) + String(opstr)) + String(rs)) + ")") as! String)
}
func newNum(_ n: Int) -> Expr {
    var n = n
    return (Expr.Num(value: Rational(num: Int(n), denom: 1)) as! Expr)
}
func exprEval(_ x: Expr) -> Rational {
    var x = x
    return ({ () -> Any in
    switch x {
        case let .Num(v):
        return v
        case let .Bin(op, l, r):
        return binEval((op as! Int), (l as! Expr), (r as! Expr))
        default:
        var z: Any
        return z
    }
}() as! Rational)
}
func exprString(_ x: Expr) -> String {
    var x = x
    return String({ () -> String in
    switch x {
        case let .Num(v):
        return String(String(describing: v.num))
        case let .Bin(op, l, r):
        return String(binString((op as! Int), (l as! Expr), (r as! Expr)))
        default:
        var z: String
        return z
    }
}())
}
let n_cards = 4
let goal = 24
let digit_range = 9
func solve(_ xs: [Expr]) -> Bool {
    var xs = xs
    if (Int((((xs as! [Expr])).count)) == 1) {
        let f = exprEval((xs[0] as! Expr))
        if ((f.denom != 0) && (f.num == (f.denom * Int(goal)))) {
            print(String(exprString((xs[0] as! Expr))))
            return true
        }
        return false
    }
    var i = 0
    while (Int(i) < Int((((xs as! [Expr])).count))) {
        var j = ((Int(i) + 1) as! Int)
        while (Int(j) < Int((((xs as! [Expr])).count))) {
            var rest: [Expr] = ([] as! [Expr])
            var k = 0
            while (Int(k) < Int((((xs as! [Expr])).count))) {
                if ((Int(k) != Int(i)) && (Int(k) != Int(j))) {
                    rest = (((rest as! [Expr]) + [xs[Int(k)]]) as! [Expr])
                }
                k = ((Int(k) + 1) as! Int)
            }
            let a = xs[Int(i)]
            let b = xs[Int(j)]
            for op in ([Int(OP_ADD), Int(OP_SUB), Int(OP_MUL), Int(OP_DIV)] as! [Int]) {
                var node = (Expr.Bin(op: op, left: a, right: b) as! Expr)
                if (solve((((rest as! [Expr]) + [node]) as! [Expr])) as! Bool) {
                    return true
                }
            }
            var node = (Expr.Bin(op: Int(OP_SUB), left: b, right: a) as! Expr)
            if (solve((((rest as! [Expr]) + [node]) as! [Expr])) as! Bool) {
                return true
            }
            node = (Expr.Bin(op: Int(OP_DIV), left: b, right: a) as! Expr)
            if (solve((((rest as! [Expr]) + [node]) as! [Expr])) as! Bool) {
                return true
            }
            j = ((Int(j) + 1) as! Int)
        }
        i = ((Int(i) + 1) as! Int)
    }
    return false
}
func main() {
    var iter = 0
    while (Int(iter) < 10) {
        var cards: [Expr] = ([] as! [Expr])
        var i = 0
        while (Int(i) < Int(n_cards)) {
            let n = (Int((Int(_now()) % Int((Int(digit_range) - 1)))) + 1)
            cards = (((cards as! [Expr]) + [newNum(Int(n))]) as! [Expr])
            print((" " + String(String(describing: Int(n)))))
            i = ((Int(i) + 1) as! Int)
        }
        print(":  ")
        if (!(solve((cards as! [Expr])) as! Bool)) {
            print("No solution")
        }
        iter = ((Int(iter) + 1) as! Int)
    }
}
main()
