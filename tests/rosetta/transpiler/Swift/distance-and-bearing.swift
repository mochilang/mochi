// Generated by Mochi transpiler v0.10.41 on 2025-07-26 19:37:32 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

let PI = 3.141592653589793
func sinApprox(_ x: Double) -> Double {
    var term: Double = x
    var sum: Double = x
    var n: Int = 1
    while (n <= 8) {
        let denom = Double((Int((2 * n)) * Int(((2 * n) + 1))))
        term = Double((((-term * x) * x) / denom))
        sum = Double((sum + term))
        n = Int((n + 1))
    }
    return Double(sum)
}
func cosApprox(_ x: Double) -> Double {
    var term: Double = 1.0
    var sum: Double = 1.0
    var n: Int = 1
    while (n <= 8) {
        let denom = Double((Int(((2 * n) - 1)) * Int((2 * n))))
        term = Double((((-term * x) * x) / denom))
        sum = Double((sum + term))
        n = Int((n + 1))
    }
    return Double(sum)
}
func atanApprox(_ x: Double) -> Double {
    if (x > 1.0) {
        return Double(((PI / 2.0) - (x / Double(((x * x) + 0.28)))))
    }
    if (x < Double(-1.0)) {
        return Double(((-PI / 2.0) - (x / Double(((x * x) + 0.28)))))
    }
    return Double((x / Double((1.0 + ((0.28 * x) * x)))))
}
func atan2Approx(_ y: Double, _ x: Double) -> Double {
    if (x > 0.0) {
        let r = Double(atanApprox(Double((y / x))))
        return Double(r)
    }
    if (x < 0.0) {
        if (y >= 0.0) {
            return Double((Double(atanApprox(Double((y / x)))) + PI))
        }
        return Double((Double(atanApprox(Double((y / x)))) - PI))
    }
    if (y > 0.0) {
        return Double((PI / 2.0))
    }
    if (y < 0.0) {
        return Double((-PI / 2.0))
    }
    return 0.0
}
func sqrtApprox(_ x: Double) -> Double {
    var guess: Double = x
    var i: Int = 0
    while (i < 10) {
        guess = Double((Double((guess + (x / guess))) / 2.0))
        i = Int((i + 1))
    }
    return Double(guess)
}
func rad(_ x: Double) -> Double {
    return Double(((x * PI) / 180.0))
}
func deg(_ x: Double) -> Double {
    return Double(((x * 180.0) / PI))
}
func distance(_ lat1: Double, _ lon1: Double, _ lat2: Double, _ lon2: Double) -> Double {
    let phi1 = Double(rad(Double(lat1)))
    let phi2 = Double(rad(Double(lat2)))
    let dphi = Double(rad(Double((lat2 - lat1))))
    let dlambda = Double(rad(Double((lon2 - lon1))))
    let sdphi = Double(sinApprox(Double((dphi / 2))))
    let sdlambda = Double(sinApprox(Double((dlambda / 2))))
    let a = ((sdphi * sdphi) + (((Double(cosApprox(Double(phi1))) * Double(cosApprox(Double(phi2)))) * sdlambda) * sdlambda))
    let c = (2 * Double(atan2Approx(Double(sqrtApprox(Double(a))), Double(sqrtApprox(Double((1 - a)))))))
    return Double((Double((6371.0 / 1.852)) * c))
}
func bearing(_ lat1: Double, _ lon1: Double, _ lat2: Double, _ lon2: Double) -> Double {
    let phi1 = Double(rad(Double(lat1)))
    let phi2 = Double(rad(Double(lat2)))
    let dl = Double(rad(Double((lon2 - lon1))))
    let y = (Double(sinApprox(Double(dl))) * Double(cosApprox(Double(phi2))))
    let x = ((Double(cosApprox(Double(phi1))) * Double(sinApprox(Double(phi2)))) - ((Double(sinApprox(Double(phi1))) * Double(cosApprox(Double(phi2)))) * Double(cosApprox(Double(dl)))))
    var br = Double(deg(Double(atan2Approx(Double(y), Double(x)))))
    if (br < 0) {
        br = Double((br + 360))
    }
    return Double(br)
}
struct Airport {
    var name: String
    var country: String
    var icao: String
    var lat: Double
    var lon: Double
}
let airports = ([Airport(name: "Koksijde Air Base", country: "Belgium", icao: "EBFN", lat: 51.090301513671875, lon: 2.652780055999756), Airport(name: "Ostend-Bruges International Airport", country: "Belgium", icao: "EBOS", lat: 51.198898315399994, lon: 2.8622200489), Airport(name: "Kent International Airport", country: "United Kingdom", icao: "EGMH", lat: 51.342201, lon: 1.34611), Airport(name: "Calais-Dunkerque Airport", country: "France", icao: "LFAC", lat: 50.962100982666016, lon: 1.954759955406189), Airport(name: "Westkapelle heliport", country: "Belgium", icao: "EBKW", lat: 51.32222366333, lon: 3.2930560112), Airport(name: "Lympne Airport", country: "United Kingdom", icao: "EGMK", lat: 51.08, lon: 1.013), Airport(name: "Ursel Air Base", country: "Belgium", icao: "EBUL", lat: 51.14419937133789, lon: 3.475559949874878), Airport(name: "Southend Airport", country: "United Kingdom", icao: "EGMC", lat: 51.5713996887207, lon: 0.6955559849739075), Airport(name: "Merville-Calonne Airport", country: "France", icao: "LFQT", lat: 50.61840057373047, lon: 2.642240047454834), Airport(name: "Wevelgem Airport", country: "Belgium", icao: "EBKT", lat: 50.817199707, lon: 3.20472002029), Airport(name: "Midden-Zeeland Airport", country: "Netherlands", icao: "EHMZ", lat: 51.5121994019, lon: 3.73111009598), Airport(name: "Lydd Airport", country: "United Kingdom", icao: "EGMD", lat: 50.95610046386719, lon: 0.9391670227050781), Airport(name: "RAF Wattisham", country: "United Kingdom", icao: "EGUW", lat: 52.1273002625, lon: 0.956264019012), Airport(name: "Beccles Airport", country: "United Kingdom", icao: "EGSM", lat: 52.435298919699996, lon: 1.6183300018300002), Airport(name: "Lille/Marcq-en-Baroeul Airport", country: "France", icao: "LFQO", lat: 50.687198638916016, lon: 3.0755600929260254), Airport(name: "Lashenden (Headcorn) Airfield", country: "United Kingdom", icao: "EGKH", lat: 51.156898, lon: 0.641667), Airport(name: "Le Touquet-CÃ´te d'Opale Airport", country: "France", icao: "LFAT", lat: 50.517398834228516, lon: 1.6205899715423584), Airport(name: "Rochester Airport", country: "United Kingdom", icao: "EGTO", lat: 51.351898193359375, lon: 0.5033329725265503), Airport(name: "Lille-Lesquin Airport", country: "France", icao: "LFQQ", lat: 50.563332, lon: 3.086886), Airport(name: "Thurrock Airfield", country: "United Kingdom", icao: "EGMT", lat: 51.537505, lon: 0.367634)] as! [Airport])
func floor(_ x: Double) -> Double {
    var i: Int = Int(x)
    if (Double(i) > x) {
        i = Int((i - 1))
    }
    return Double(i)
}
func pow10(_ n: Int) -> Double {
    var p: Double = 1.0
    var i: Int = 0
    while (i < n) {
        p = Double((p * 10.0))
        i = Int((i + 1))
    }
    return Double(p)
}
func round(_ x: Double, _ n: Int) -> Double {
    let m = Double(pow10(Int(n)))
    return Double((Double(floor(Double(((x * m) + 0.5)))) / m))
}
func sortByDistance(_ xs: [[Any]]) -> [[Any]] {
    var arr: [[Any]] = xs
    var i: Int = 1
    while (i < Int(((arr).count))) {
        var j: Int = i
        while ((j > 0) && (String(describing: ((arr[(j - 1)] as! [Any])[0] as! Any))
        > String(describing: ((arr[j] as! [Any])[0] as! Any))
        )) {
            let tmp = (arr[(j - 1)] as! [Any])
            arr[(j - 1)] = (arr[j] as! [Any])
            arr[j] = (tmp as! [Any])
            j = Int((j - 1))
        }
        i = Int((i + 1))
    }
    return (arr as! [[Any]])
}
func main() {
    let planeLat = 51.514669
    let planeLon = 2.198581
    var results: [[Any]] = ([] as! [[Any]])
    for ap in airports {
        let d = Double(distance(Double(planeLat), Double(planeLon), Double(ap.lat), Double(ap.lon)))
        let b = Double(bearing(Double(planeLat), Double(planeLon), Double(ap.lat), Double(ap.lon)))
        results = ((results + [[d, b, ap]]) as! [[Any]])
    }
    results = (sortByDistance((results as! [[Any]])) as! [[Any]])
    print(_p("Distance Bearing ICAO Country               Airport"))
    print(_p("--------------------------------------------------------------"))
    var i: Int = 0
    while (i < Int(((results).count))) {
        let r = (results[i] as! [Any])
        let ap = ((r as! [Any])[2] as! Any)
        let dist = ((r as! [Any])[0] as! Any)
        let bear = ((r as! [Any])[1] as! Any)
        let line = ((((((((_p(Double(round(Double(dist), 1))) + "\t") + _p(Double(round(Double(bear), 0)))) + "\t") + String(describing: ap.icao)) + "\t") + String(describing: ap.country)) + " ") + String(describing: ap.name))
        print(_p(line))
        i = Int((i + 1))
    }
}
_ = main()
