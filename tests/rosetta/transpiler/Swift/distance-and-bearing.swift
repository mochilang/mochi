// Generated by Mochi transpiler v0.10.54 on 2025-08-02 14:14:23 GMT+7
import Foundation

let stdout = FileHandle.standardOutput
extension FileHandle {
    func write(_ string: String) {
        if let data = string.data(using: .utf8) {
            self.write(data)
        }
    }
}

func _p(_ v: Any?) -> String {
    if let val = v {
        if let d = val as? Double {
            if d.rounded(.towardZero) == d {
                return String(Int64(d))
            }
        }
        return String(describing: val)
    }
    return "<nil>"
}

extension Double { init(_ v: Any) { if let d = v as? Double { self = d } else if let i = v as? Int { self = Double(i) } else if let i = v as? Int64 { self = Double(i) } else if let s = v as? String { self = Double(s) ?? 0 } else { self = 0 } } }
func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
let PI = 3.141592653589793
func sinApprox(_ x: Double) -> Double {
    var term: Double = x
    var sum: Double = x
    var n: Int = 1
    while (n <= 8) {
        let denom = Double((Int((2 &* n)) &* Int(((2 &* n) &+ 1))))
        term = Double((((-term * x) * x) / denom))
        sum = Double((sum + term))
        n = Int((n &+ 1))
    }
    return sum
}
func cosApprox(_ x: Double) -> Double {
    var term: Double = 1.0
    var sum: Double = 1.0
    var n: Int = 1
    while (n <= 8) {
        let denom = Double((Int(((2 &* n) &- 1)) &* Int((2 &* n))))
        term = Double((((-term * x) * x) / denom))
        sum = Double((sum + term))
        n = Int((n &+ 1))
    }
    return sum
}
func atanApprox(_ x: Double) -> Double {
    if (x > 1.0) {
        return ((PI / 2.0) - (x / Double(((x * x) + 0.28))))
    }
    if (x < Double(-1.0)) {
        return ((-PI / 2.0) - (x / Double(((x * x) + 0.28))))
    }
    return (x / Double((1.0 + ((0.28 * x) * x))))
}
func atan2Approx(_ y: Double, _ x: Double) -> Double {
    if (x > 0.0) {
        let r = Double(atanApprox(Double((y / x))))
        return r
    }
    if (x < 0.0) {
        if (y >= 0.0) {
            return (Double(atanApprox(Double((y / x)))) + PI)
        }
        return (Double(atanApprox(Double((y / x)))) - PI)
    }
    if (y > 0.0) {
        return (PI / 2.0)
    }
    if (y < 0.0) {
        return (-PI / 2.0)
    }
    return 0.0
}
func sqrtApprox(_ x: Double) -> Double {
    var guess: Double = x
    var i: Int = 0
    while (i < 10) {
        guess = Double((Double((guess + (x / guess))) / 2.0))
        i = Int((i &+ 1))
    }
    return guess
}
func rad(_ x: Double) -> Double {
    return ((x * PI) / 180.0)
}
func deg(_ x: Double) -> Double {
    return ((x * 180.0) / PI)
}
func distance(_ lat1: Double, _ lon1: Double, _ lat2: Double, _ lon2: Double) -> Double {
    let phi1 = Double(rad(Double(lat1)))
    let phi2 = Double(rad(Double(lat2)))
    let dphi = Double(rad(Double((lat2 - lat1))))
    let dlambda = Double(rad(Double((lon2 - lon1))))
    let sdphi = Double(sinApprox(Double((dphi / 2))))
    let sdlambda = Double(sinApprox(Double((dlambda / 2))))
    let a = ((sdphi * sdphi) + (((Double(cosApprox(Double(phi1))) * Double(cosApprox(Double(phi2)))) * sdlambda) * sdlambda))
    let c = (2 * Double(atan2Approx(Double(sqrtApprox(Double(a))), Double(sqrtApprox(Double((1 - a)))))))
    return (Double((6371.0 / 1.852)) * c)
}
func bearing(_ lat1: Double, _ lon1: Double, _ lat2: Double, _ lon2: Double) -> Double {
    let phi1 = Double(rad(Double(lat1)))
    let phi2 = Double(rad(Double(lat2)))
    let dl = Double(rad(Double((lon2 - lon1))))
    let y = (Double(sinApprox(Double(dl))) * Double(cosApprox(Double(phi2))))
    let x = ((Double(cosApprox(Double(phi1))) * Double(sinApprox(Double(phi2)))) - ((Double(sinApprox(Double(phi1))) * Double(cosApprox(Double(phi2)))) * Double(cosApprox(Double(dl)))))
    var br = Double(deg(Double(atan2Approx(Double(y), Double(x)))))
    if (br < 0) {
        br = Double((br + 360))
    }
    return br
}
struct Airport {
    var name: String
    var country: String
    var icao: String
    var lat: Double
    var lon: Double
}
let airports: [Airport] = ([Airport(name: "Koksijde Air Base", country: "Belgium", icao: "EBFN", lat: 51.090301513671875, lon: 2.652780055999756), Airport(name: "Ostend-Bruges International Airport", country: "Belgium", icao: "EBOS", lat: 51.198898315399994, lon: 2.8622200489), Airport(name: "Kent International Airport", country: "United Kingdom", icao: "EGMH", lat: 51.342201, lon: 1.34611), Airport(name: "Calais-Dunkerque Airport", country: "France", icao: "LFAC", lat: 50.962100982666016, lon: 1.954759955406189), Airport(name: "Westkapelle heliport", country: "Belgium", icao: "EBKW", lat: 51.32222366333, lon: 3.2930560112), Airport(name: "Lympne Airport", country: "United Kingdom", icao: "EGMK", lat: 51.08, lon: 1.013), Airport(name: "Ursel Air Base", country: "Belgium", icao: "EBUL", lat: 51.14419937133789, lon: 3.475559949874878), Airport(name: "Southend Airport", country: "United Kingdom", icao: "EGMC", lat: 51.5713996887207, lon: 0.6955559849739075), Airport(name: "Merville-Calonne Airport", country: "France", icao: "LFQT", lat: 50.61840057373047, lon: 2.642240047454834), Airport(name: "Wevelgem Airport", country: "Belgium", icao: "EBKT", lat: 50.817199707, lon: 3.20472002029), Airport(name: "Midden-Zeeland Airport", country: "Netherlands", icao: "EHMZ", lat: 51.5121994019, lon: 3.73111009598), Airport(name: "Lydd Airport", country: "United Kingdom", icao: "EGMD", lat: 50.95610046386719, lon: 0.9391670227050781), Airport(name: "RAF Wattisham", country: "United Kingdom", icao: "EGUW", lat: 52.1273002625, lon: 0.956264019012), Airport(name: "Beccles Airport", country: "United Kingdom", icao: "EGSM", lat: 52.435298919699996, lon: 1.6183300018300002), Airport(name: "Lille/Marcq-en-Baroeul Airport", country: "France", icao: "LFQO", lat: 50.687198638916016, lon: 3.0755600929260254), Airport(name: "Lashenden (Headcorn) Airfield", country: "United Kingdom", icao: "EGKH", lat: 51.156898, lon: 0.641667), Airport(name: "Le Touquet-CÃ´te d'Opale Airport", country: "France", icao: "LFAT", lat: 50.517398834228516, lon: 1.6205899715423584), Airport(name: "Rochester Airport", country: "United Kingdom", icao: "EGTO", lat: 51.351898193359375, lon: 0.5033329725265503), Airport(name: "Lille-Lesquin Airport", country: "France", icao: "LFQQ", lat: 50.563332, lon: 3.086886), Airport(name: "Thurrock Airfield", country: "United Kingdom", icao: "EGMT", lat: 51.537505, lon: 0.367634)] as! [Airport])
func floor(_ x: Double) -> Double {
    var i: Int = Int(x)
    if (Double(i) > x) {
        i = Int((i &- 1))
    }
    return Double(i)
}
func pow10(_ n: Int) -> Double {
    var p: Double = 1.0
    var i: Int = 0
    while (i < n) {
        p = Double((p * 10.0))
        i = Int((i &+ 1))
    }
    return p
}
func round(_ x: Double, _ n: Int) -> Double {
    let m = Double(pow10((n as! Int)))
    return (Double(floor(Double(((x * m) + 0.5)))) / m)
}
func sortByDistance(_ xs: [[Any?]]) -> [[Any?]] {
    var arr: [[Any?]] = xs
    var i: Int = 1
    while (i < Int(((arr).count))) {
        var j: Int = i
        while ((j > 0) && (String(describing: arr[(j &- 1)][0])
        > String(describing: arr[j][0])
        )) {
            let tmp: [Any?] = (arr[(j &- 1)] as! [Any?])
            arr[(j &- 1)] = (arr[j] as! [Any?])
            arr[j] = (tmp as! [Any?])
            j = Int((j &- 1))
        }
        i = Int((i &+ 1))
    }
    return arr
}
func main() {
    let planeLat = 51.514669
    let planeLon = 2.198581
    var results: [[Any?]] = ([] as! [[Any?]])
    for ap in airports {
        let d = Double(distance(Double(planeLat), Double(planeLon), Double(ap.lat), Double(ap.lon)))
        let b = Double(bearing(Double(planeLat), Double(planeLon), Double(ap.lat), Double(ap.lon)))
        results = (_append(results, [d, b, ap]) as! [[Any?]])
    }
    results = (sortByDistance((results as! [[Any?]])) as! [[Any?]])
    print(_p("Distance Bearing ICAO Country               Airport"))
    print(_p("--------------------------------------------------------------"))
    var i: Int = 0
    while (i < Int(((results).count))) {
        let r: [Any?] = (results[i] as! [Any?])
        let ap = r[2]
        let dist = r[0]
        let bear = r[1]
        let line = ((((((((_p(Double(round(Double(dist), 1))) + "\t") + _p(Double(round(Double(bear), 0)))) + "\t") + String(describing: (ap as! Airport).icao)) + "\t") + String(describing: (ap as! Airport).country)) + " ") + String(describing: (ap as! Airport).name))
        print(_p(line))
        i = Int((i &+ 1))
    }
}
_ = main()
