// Generated by Mochi transpiler v0.10.57 on 2025-08-04 16:36:08 GMT+7
import Foundation
import Dispatch

let stdout = FileHandle.standardOutput
extension FileHandle {
    func write(_ string: String) {
        if let data = string.data(using: .utf8) {
            self.write(data)
        }
    }
}

func _p(_ v: Any?) -> String {
    if let val = v {
        if let d = val as? Double {
            if d.rounded(.towardZero) == d {
                return String(Int64(d))
            }
        }
        return String(describing: val)
    }
    return "<nil>"
}

extension Double { init(_ v: Any) { if let d = v as? Double { self = d } else if let i = v as? Int { self = Double(i) } else if let i = v as? Int64 { self = Double(i) } else if let s = v as? String { self = Double(s) ?? 0 } else { self = 0 } } }
func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
class Fps {
    var coeffs: [Double]
    var compute: (Int) -> Double
    init() {
        self.coeffs = []
        self.compute = { (_ arg0: Int) -> Double in 0 }
    }
    init(coeffs: [Double], compute: @escaping (Int) -> Double) {
        self.coeffs = coeffs
        self.compute = compute
    }
}
func newFps(_ fn: @escaping (Int) -> Double) -> Fps {
    return Fps(coeffs: [], compute: fn)
}
func extract(_ f: Fps, _ n: Int) -> Double {
    var f = f
    while (Int(((f.coeffs).count)) <= n) {
        let idx = Int(((f.coeffs).count))
        let v = Double(f.compute(idx))
        f.coeffs = (_append(f.coeffs, v) as! [Double])
    }
    return Double(f.coeffs[n])
}
func one() -> Fps {
    return newFps(({ (i: Int) -> Double in
    if (i == 0) {
        return 1.0
    }
    return 0.0
} as! (Int) -> Double))
}
func add(_ a: Fps, _ b: Fps) -> Fps {
    return newFps(({ (n: Int) -> Double in
    return (Double(extract((a as! Fps), n)) + Double(extract((b as! Fps), n)))
} as! (Int) -> Double))
}
func sub(_ a: Fps, _ b: Fps) -> Fps {
    return newFps(({ (n: Int) -> Double in
    return (Double(extract((a as! Fps), n)) - Double(extract((b as! Fps), n)))
} as! (Int) -> Double))
}
func mul(_ a: Fps, _ b: Fps) -> Fps {
    return newFps(({ (n: Int) -> Double in
    var s: Double = 0.0
    var k: Int = 0
    while (k <= n) {
        s = Double((s + (Double(extract((a as! Fps), k)) * Double(extract((b as! Fps), (n &- k))))))
        k = Int((k &+ 1))
    }
    return s
} as! (Int) -> Double))
}
func div(_ a: Fps, _ b: Fps) -> Fps {
    var q: Fps = newFps(({ (n: Int) -> Double in
    return 0.0
} as! (Int) -> Double))
q.compute = ({ (n: Int) -> Double in
let b0 = Double(extract((b as! Fps), 0))
if (b0 == 0.0) {
    return Double((0.0 / 0.0))
}
var s: Double = Double(extract((a as! Fps), n))
var k: Int = 1
while (k <= n) {
    s = Double((s - (Double(extract((b as! Fps), k)) * Double(extract((q as! Fps), (n &- k))))))
    k = Int((k &+ 1))
}
return (s / b0)
} as! (Int) -> Double)
return q
}
func differentiate(_ a: Fps) -> Fps {
    return newFps(({ (n: Int) -> Double in
    return (Double((n &+ 1)) * Double(extract((a as! Fps), (n &+ 1))))
} as! (Int) -> Double))
}
func integrate(_ a: Fps) -> Fps {
    return newFps(({ (n: Int) -> Double in
    if (n == 0) {
        return 0.0
    }
    return (Double(extract((a as! Fps), (n &- 1))) / Double(n))
} as! (Int) -> Double))
}
struct Pair {
    var sin: Fps
    var cos: Fps
    init() {
        self.sin = Fps()
        self.cos = Fps()
    }
    init(sin: Fps, cos: Fps) {
        self.sin = sin
        self.cos = cos
    }
}
func sinCos() -> Pair {
    var sin: Fps = newFps(({ (n: Int) -> Double in
    return 0.0
} as! (Int) -> Double))
var cos: Fps = sub((one() as! Fps), (integrate((sin as! Fps)) as! Fps))
sin.compute = ({ (n: Int) -> Double in
if (n == 0) {
    return 0.0
}
return (Double(extract((cos as! Fps), (n &- 1))) / Double(n))
} as! (Int) -> Double)
return Pair(sin: sin, cos: cos)
}
func floorf(_ x: Double) -> Double {
    let y = Int(x)
    return Double(y)
}
func fmtF5(_ x: Double) -> String {
    var y: Double = (Double(floorf(Double(((x * 100000.0) + 0.5)))) / 100000.0)
    var s: String = String(describing: y)
    var dot: Int = Int((String(describing: (s as! String)).range(of: String(describing: "."))?.lowerBound.utf16Offset(in: String(describing: (s as! String))) ?? -1))
    if (dot == (0 &- 1)) {
        s = ((s + ".00000") as! String)
    } else {
        var decs: Int = ((Int(((s).count)) &- dot) &- 1)
        if (decs > 5) {
            s = String(describing: String(Array(String(describing: (s as! String)))[0..<(dot &+ 6)]))
        } else {
            while (decs < 5) {
                s = ((s + "0") as! String)
                decs = Int((decs &+ 1))
            }
        }
    }
    return s
}
func padFloat5(_ x: Double, _ width: Int) -> String {
    var s: String = String(describing: fmtF5(Double(x)))
    while (Int(((s).count)) < width) {
        s = ((" " + s) as! String)
    }
    return s
}
func partialSeries(_ f: Fps) -> String {
    var out: String = ""
    var i: Int = 0
    while (i < 6) {
        out = ((((out + " ") + String(describing: padFloat5(Double(extract((f as! Fps), i)), 8))) + " ") as! String)
        i = Int((i &+ 1))
    }
    return out
}
func main() {
    let p = sinCos()
    print(_p(("sin:" + String(describing: partialSeries((p.sin as! Fps))))))
    print(_p(("cos:" + String(describing: partialSeries((p.cos as! Fps))))))
}
_ = main()
