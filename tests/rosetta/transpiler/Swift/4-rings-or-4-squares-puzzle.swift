// Generated by Mochi transpiler v0.10.38 on 2025-07-24 08:24:43 GMT+7
import Foundation

func validComb(_ a: Int, _ b: Int, _ c: Int, _ d: Int, _ e: Int, _ f: Int, _ g: Int) -> Bool {
    var a = a
    var b = b
    var c = c
    var d = d
    var e = e
    var f = f
    var g = g
    let square1 = (Int(a) + Int(b))
    let square2 = ((Int(b) + Int(c)) + Int(d))
    let square3 = ((Int(d) + Int(e)) + Int(f))
    let square4 = (Int(f) + Int(g))
    return ((((Int(square1) == Int(square2)) && (Int(square2) == Int(square3))) && (Int(square3) == Int(square4))) as! Bool)
}
func isUnique(_ a: Int, _ b: Int, _ c: Int, _ d: Int, _ e: Int, _ f: Int, _ g: Int) -> Bool {
    var a = a
    var b = b
    var c = c
    var d = d
    var e = e
    var f = f
    var g = g
    var nums = ([Int(a), Int(b), Int(c), Int(d), Int(e), Int(f), Int(g)] as! [Int])
    var i = 0
    while (Int(i) < Int((((nums as! [Int])).count))) {
        var j = ((Int(i) + 1) as! Int)
        while (Int(j) < Int((((nums as! [Int])).count))) {
            if (Int(nums[Int(i)]) == Int(nums[Int(j)])) {
                return false
            }
            j = ((Int(j) + 1) as! Int)
        }
        i = ((Int(i) + 1) as! Int)
    }
    return true
}
func getCombs(_ low: Int, _ high: Int, _ unique: Bool) -> [String: Any] {
    var low = low
    var high = high
    var unique = unique
    var valid: [Any] = ([] as! [Any])
    var count = 0
    for b in Int(low)..<Int((Int(high) + 1)) {
        for c in Int(low)..<Int((Int(high) + 1)) {
            for d in Int(low)..<Int((Int(high) + 1)) {
                let s = (((b as! Int) + (c as! Int)) + (d as! Int))
                for e in Int(low)..<Int((Int(high) + 1)) {
                    for f in Int(low)..<Int((Int(high) + 1)) {
                        let a = ((s as! Int) - (b as! Int))
                        let g = ((s as! Int) - (f as! Int))
                        if (((a as! Int) < Int(low)) || ((a as! Int) > Int(high))) {
                            continue
                        }
                        if (((g as! Int) < Int(low)) || ((g as! Int) > Int(high))) {
                            continue
                        }
                        if ((((d as! Int) + (e as! Int)) + (f as! Int)) != (s as! Int)) {
                            continue
                        }
                        if (((f as! Int) + (g as! Int)) != (s as! Int)) {
                            continue
                        }
                        if ((!(unique as! Bool)) || (isUnique((a as! Int), (b as! Int), (c as! Int), (d as! Int), (e as! Int), (f as! Int), (g as! Int)) as! Bool)) {
                            valid = (((((valid as! [Any]) + [([a, b, c, d, e, f, g] as! [Any])]) as! [Any]) as! [[Any]]) as! [Any])
                            count = ((Int(count) + 1) as! Int)
                        }
                    }
                }
            }
        }
    }
    return (["count": Int(count), "list": (valid as! [Any])] as [String: Any] as! [String: Any])
}
let r1 = (getCombs(1, 7, true) as! [String: Any])
print((String(String(describing: (r1 as! [String: Any])["count"]!)) + " unique solutions in 1 to 7"))
print((r1 as! [String: Any])["list"]!)
let r2 = (getCombs(3, 9, true) as! [String: Any])
print((String(String(describing: (r2 as! [String: Any])["count"]!)) + " unique solutions in 3 to 9"))
print((r2 as! [String: Any])["list"]!)
let r3 = (getCombs(0, 9, false) as! [String: Any])
print((String(String(describing: (r3 as! [String: Any])["count"]!)) + " non-unique solutions in 0 to 9"))
