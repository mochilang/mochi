// Generated by Mochi transpiler v0.10.52 on 2025-08-01 22:11:34 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
struct Field {
    var s: [[Bool]]
    var w: Int
    var h: Int
}
struct Life {
    var a: Field
    var b: Field
    var w: Int
    var h: Int
}
var seed: Int = 1
func randN(_ n: Int) -> Int {
    seed = ((Int(((seed * 1664525) + 1013904223)) % 2147483647) as! Int)
    return (seed % n)
}
func newField(_ w: Int, _ h: Int) -> Field {
    var rows: [[Bool]] = ([] as! [[Bool]])
    var y: Int = 0
    while (y < h) {
        var row: [Bool] = ([] as! [Bool])
        var x: Int = 0
        while (x < w) {
            row = (_append(row, false) as! [Bool])
            x = ((x + 1) as! Int)
        }
        rows = (_append(rows, row) as! [[Bool]])
        y = ((y + 1) as! Int)
    }
    return Field(s: rows, w: w, h: h)
}
func setCell(_ f: inout Field, _ x: Int, _ y: Int, _ b: Bool) {
    var rows: [[Bool]] = f.s
    var row: [Bool] = (rows[y] as! [Bool])
    row[x] = (b as! Bool)
    rows[y] = (row as! [Bool])
    f.s = (rows as! [[Bool]])
}
func state(_ f: Field, _ x: Int, _ y: Int) -> Bool {
    var x = x
    var y = y
    while (y < 0) {
        y = ((y + f.h) as! Int)
    }
    while (x < 0) {
        x = ((x + f.w) as! Int)
    }
    return (f.s[(y % f.h)][(x % f.w)] as! Bool)
}
func nextState(_ f: Field, _ x: Int, _ y: Int) -> Bool {
    var x = x
    var y = y
    var count: Int = 0
    var dy: Int = -1
    while (dy <= 1) {
        var dx: Int = -1
        while (dx <= 1) {
            if ((!((dx == 0) && (dy == 0))) && state((f as! Field), ((x + dx) as! Int), ((y + dy) as! Int))) {
                count = ((count + 1) as! Int)
            }
            dx = ((dx + 1) as! Int)
        }
        dy = ((dy + 1) as! Int)
    }
    return ((count == 3) || ((count == 2) && state((f as! Field), (x as! Int), (y as! Int))))
}
func newLife(_ w: Int, _ h: Int) -> Life {
    var a: Field = newField((w as! Int), (h as! Int))
    var i: Int = 0
    while (i < Int(((w * h) / 2))) {
        _ = setCell(&a, Int(randN((w as! Int))), Int(randN((h as! Int))), true)
        i = ((i + 1) as! Int)
    }
    return Life(a: a, b: newField((w as! Int), (h as! Int)), w: w, h: h)
}
func step(_ l: inout Life) {
    var y: Int = 0
    while (y < l.h) {
        var x: Int = 0
        while (x < l.w) {
            _ = setCell(&l.b, (x as! Int), (y as! Int), nextState((l.a as! Field), (x as! Int), (y as! Int)))
            x = ((x + 1) as! Int)
        }
        y = ((y + 1) as! Int)
    }
    var tmp: Field = l.a
    l.a = (l.b as! Field)
    l.b = (tmp as! Field)
}
func lifeString(_ l: Life) -> String {
    var out: String = ""
    var y: Int = 0
    while (y < l.h) {
        var x: Int = 0
        while (x < l.w) {
            if state((l.a as! Field), (x as! Int), (y as! Int)) {
                out = ((out + "*") as! String)
            } else {
                out = ((out + " ") as! String)
            }
            x = ((x + 1) as! Int)
        }
        out = ((out + "\n") as! String)
        y = ((y + 1) as! Int)
    }
    return out
}
func main() {
    var l: Life = newLife(80, 15)
    var i: Int = 0
    while (i < 300) {
        _ = step(&l)
        print(_p("\f"))
        print(_p(String(describing: lifeString((l as! Life)))))
        i = ((i + 1) as! Int)
    }
}
_ = main()
