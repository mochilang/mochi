// Generated by Mochi transpiler v0.10.55 on 2025-08-02 21:12:52 GMT+7
import Foundation

let stdout = FileHandle.standardOutput
extension FileHandle {
    func write(_ string: String) {
        if let data = string.data(using: .utf8) {
            self.write(data)
        }
    }
}

func _p(_ v: Any?) -> String {
    if let val = v {
        if let d = val as? Double {
            if d.rounded(.towardZero) == d {
                return String(Int64(d))
            }
        }
        return String(describing: val)
    }
    return "<nil>"
}

extension Double { init(_ v: Any) { if let d = v as? Double { self = d } else if let i = v as? Int { self = Double(i) } else if let i = v as? Int64 { self = Double(i) } else if let s = v as? String { self = Double(s) ?? 0 } else { self = 0 } } }
func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
struct Field {
    var s: [[Bool]]
    var w: Int
    var h: Int
}
struct Life {
    var a: Field
    var b: Field
    var w: Int
    var h: Int
}
var seed: Int = 1
func randN(_ n: Int) -> Int {
    seed = Int((Int(((seed &* 1664525) &+ 1013904223)) % 2147483647))
    return (seed % n)
}
func newField(_ w: Int, _ h: Int) -> Field {
    var rows: [[Bool]] = ([] as! [[Bool]])
    var y: Int = 0
    while (y < h) {
        var row: [Bool] = ([] as! [Bool])
        var x: Int = 0
        while (x < w) {
            row = (_append(row, false) as! [Bool])
            x = Int((x &+ 1))
        }
        rows = (_append(rows, row) as! [[Bool]])
        y = Int((y &+ 1))
    }
    return Field(s: rows, w: w, h: h)
}
func setCell(_ f: inout Field, _ x: Int, _ y: Int, _ b: Bool) {
    var rows: [[Bool]] = f.s
    var row: [Bool] = (rows[y] as! [Bool])
    row[x] = (b as! Bool)
    rows[y] = (row as! [Bool])
    f.s = (rows as! [[Bool]])
}
func state(_ f: Field, _ x: Int, _ y: Int) -> Bool {
    var x = x
    var y = y
    while (y < 0) {
        y = Int((y &+ f.h))
    }
    while (x < 0) {
        x = Int((x &+ f.w))
    }
    return (f.s[(y % f.h)][(x % f.w)] as! Bool)
}
func nextState(_ f: Field, _ x: Int, _ y: Int) -> Bool {
    var x = x
    var y = y
    var count: Int = 0
    var dy: Int = -1
    while (dy <= 1) {
        var dx: Int = -1
        while (dx <= 1) {
            if ((!((dx == 0) && (dy == 0))) && state((f as! Field), Int((x &+ dx)), Int((y &+ dy)))) {
                count = Int((count &+ 1))
            }
            dx = Int((dx &+ 1))
        }
        dy = Int((dy &+ 1))
    }
    return ((count == 3) || ((count == 2) && state((f as! Field), (x as! Int), (y as! Int))))
}
func newLife(_ w: Int, _ h: Int) -> Life {
    var a: Field = newField((w as! Int), (h as! Int))
    var i: Int = 0
    while (i < Int(((w &* h) / 2))) {
        _ = setCell(&a, Int(randN((w as! Int))), Int(randN((h as! Int))), true)
        i = Int((i &+ 1))
    }
    return Life(a: a, b: newField((w as! Int), (h as! Int)), w: w, h: h)
}
func step(_ l: inout Life) {
    var y: Int = 0
    while (y < l.h) {
        var x: Int = 0
        while (x < l.w) {
            _ = setCell(&l.b, (x as! Int), (y as! Int), nextState((l.a as! Field), (x as! Int), (y as! Int)))
            x = Int((x &+ 1))
        }
        y = Int((y &+ 1))
    }
    var tmp: Field = l.a
    l.a = (l.b as! Field)
    l.b = (tmp as! Field)
}
func lifeString(_ l: Life) -> String {
    var out: String = ""
    var y: Int = 0
    while (y < l.h) {
        var x: Int = 0
        while (x < l.w) {
            if state((l.a as! Field), (x as! Int), (y as! Int)) {
                out = ((out + "*") as! String)
            } else {
                out = ((out + " ") as! String)
            }
            x = Int((x &+ 1))
        }
        out = ((out + "\n") as! String)
        y = Int((y &+ 1))
    }
    return out
}
func main() {
    var l: Life = newLife(80, 15)
    var i: Int = 0
    while (i < 300) {
        _ = step(&l)
        print(_p("\u{000C}"))
        print(_p(String(describing: lifeString((l as! Life)))))
        i = Int((i &+ 1))
    }
}
_ = main()
