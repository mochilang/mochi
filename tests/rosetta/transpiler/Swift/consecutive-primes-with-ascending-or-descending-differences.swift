// Generated by Mochi transpiler v0.10.52 on 2025-08-01 22:07:42 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
func primesUpTo(_ n: Int) -> [Int] {
    var sieve: [Bool] = ([] as! [Bool])
    var i: Int = 0
    while (i <= n) {
        sieve = (_append(sieve, true) as! [Bool])
        i = ((i + 1) as! Int)
    }
    var p: Int = 2
    while ((p * p) <= n) {
        if (sieve[p] as! Bool) {
            var m: Int = (p * p)
            while (m <= n) {
                sieve[m] = false
                m = ((m + p) as! Int)
            }
        }
        p = ((p + 1) as! Int)
    }
    var res: [Int] = ([] as! [Int])
    var x: Int = 2
    while (x <= n) {
        if (sieve[x] as! Bool) {
            res = (_append(res, x) as! [Int])
        }
        x = ((x + 1) as! Int)
    }
    return res
}
let LIMIT = 999999
let primes: [Int] = (primesUpTo((LIMIT as! Int)) as! [Int])
func longestSeq(_ dir: String) {
    var pd: Int = 0
    var longSeqs: [[Int]] = ([(([(2 as! Any)] as! [Int]) as! Any)] as! [[Int]])
    var currSeq: [Int] = ([(2 as! Any)] as! [Int])
    var i: Int = 1
    while (i < Int(((primes).count))) {
        let d = ((primes[i] as! Int) - (primes[(i - 1)] as! Int))
        if (((dir == "ascending") && (d <= pd)) || ((dir == "descending") && (d >= pd))) {
            if (Int(((currSeq).count)) > Int((((longSeqs[0] as! [Int])).count))) {
                longSeqs = ([(currSeq as! Any)] as! [[Int]])
            } else if (Int(((currSeq).count)) == Int((((longSeqs[0] as! [Int])).count))) {
                longSeqs = (_append(longSeqs, currSeq) as! [[Int]])
            }
            
            currSeq = ([((primes[(i - 1)] as! Int) as! Any), ((primes[i] as! Int) as! Any)] as! [Int])
        } else {
            currSeq = (_append(currSeq, (primes[i] as! Int)) as! [Int])
        }
        pd = (d as! Int)
        i = ((i + 1) as! Int)
    }
    if (Int(((currSeq).count)) > Int((((longSeqs[0] as! [Int])).count))) {
        longSeqs = ([(currSeq as! Any)] as! [[Int]])
    } else if (Int(((currSeq).count)) == Int((((longSeqs[0] as! [Int])).count))) {
        longSeqs = (_append(longSeqs, currSeq) as! [[Int]])
    }
    
    print(_p((((("Longest run(s) of primes with " + dir) + " differences is ") + _p(Int((((longSeqs[0] as! [Int])).count)))) + " :")))
    for ls in longSeqs {
        var diffs: [Int] = ([] as! [Int])
        var j: Int = 1
        while (j < Int(((ls).count))) {
            diffs = (_append(diffs, ((ls[j] as! Int) - (ls[(j - 1)] as! Int))) as! [Int])
            j = ((j + 1) as! Int)
        }
        var k: Int = 0
        while (k < (Int(((ls).count)) - 1)) {
            print(_p((((_p((ls[k] as! Int)) + " (") + _p((diffs[k] as! Int))) + ") ")), _p(false))
            k = ((k + 1) as! Int)
        }
        print(_p(_p((ls[(Int(((ls).count)) - 1)] as! Int))))
    }
    print(_p(""))
}
func main() {
    print(_p("For primes < 1 million:\n"))
    for dir in ([("ascending" as! Any), ("descending" as! Any)] as! [String]) {
        _ = longestSeq((dir as! String))
    }
}
_ = main()
