// Generated by Mochi transpiler v0.10.39 on 2025-07-24 13:19:28 GMT+7
import Foundation

func divisors(_ n: Int) -> [Int] {
    var n = n
    var divs: [Int] = ([1] as! [Int])
    var divs2: [Int] = ([] as! [Int])
    var i = 2
    while ((Int(i) * Int(i)) <= Int(n)) {
        if ((Int(n) % Int(i)) == 0) {
            let j = Int((Int(n) / Int(i)))
            divs = (((divs as! [Int]) + [Int(i)]) as! [Int])
            if (Int(i) != Int(j)) {
                divs2 = (((divs2 as! [Int]) + [Int(j)]) as! [Int])
            }
        }
        i = ((Int(i) + 1) as! Int)
    }
    var j = ((Int((((divs2 as! [Int])).count)) - 1) as! Int)
    while (Int(j) >= 0) {
        divs = (((divs as! [Int]) + [Int(divs2[Int(j)])]) as! [Int])
        j = ((Int(j) - 1) as! Int)
    }
    return (divs as! [Int])
}
func sum(_ xs: [Int]) -> Int {
    var xs = xs
    var tot = 0
    for v in (xs as! [Int]) {
        tot = ((Int(tot) + (v as! Int)) as! Int)
    }
    return Int(tot)
}
func sumStr(_ xs: [Int]) -> String {
    var xs = xs
    var s = ""
    var i = 0
    while (Int(i) < Int((((xs as! [Int])).count))) {
        s = (((String(s) + String(String(describing: Int(xs[Int(i)])))) + " + ") as! String)
        i = ((Int(i) + 1) as! Int)
    }
    return String(String(Array(String(s))[0..<((Int(((String(s)).count)) - 3) as! Int)]))
}
func pad2(_ n: Int) -> String {
    var n = n
    let s = String(String(describing: Int(n)))
    if (Int(((String(s)).count)) < 2) {
        return ((" " + String(s)) as! String)
    }
    return String(s)
}
func pad5(_ n: Int) -> String {
    var n = n
    var s = String(String(describing: Int(n)))
    while (Int(((String(s)).count)) < 5) {
        s = ((" " + String(s)) as! String)
    }
    return String(s)
}
func abundantOdd(_ searchFrom: Int, _ countFrom: Int, _ countTo: Int, _ printOne: Bool) -> Int {
    var searchFrom = searchFrom
    var countFrom = countFrom
    var countTo = countTo
    var printOne = printOne
    var count = Int(countFrom)
    var n = Int(searchFrom)
    while (Int(count) < Int(countTo)) {
        let divs = (divisors(Int(n)) as! [Int])
        let tot = Int((((divs as! [Int])).reduce(0) { s, v in s + ((v as? Double) ?? Double(v as? Int ?? 0)) }))
        if (Int(tot) > Int(n)) {
            count = ((Int(count) + 1) as! Int)
            if ((printOne as! Bool) && (Int(count) < Int(countTo))) {
                n = ((Int(n) + 2) as! Int)
                continue
            }
            let s = String(sumStr((divs as! [Int])))
            if (!(printOne as! Bool)) {
                print(((((((String(pad2(Int(count))) + ". ") + String(pad5(Int(n)))) + " < ") + String(s)) + " = ") + String(String(describing: Int(tot)))))
            } else {
                print(((((String(String(describing: Int(n))) + " < ") + String(s)) + " = ") + String(String(describing: Int(tot)))))
            }
        }
        n = ((Int(n) + 2) as! Int)
    }
    return Int(n)
}
func main() {
    let max = 25
    print((("The first " + String(String(describing: Int(max)))) + " abundant odd numbers are:"))
    let n = Int(abundantOdd(1, 0, Int(max), false))
    print("\nThe one thousandth abundant odd number is:")
    Int(abundantOdd(Int(n), Int(max), 1000, true))
    print("\nThe first abundant odd number above one billion is:")
    Int(abundantOdd(1000000001, 0, 1, true))
}
main()
