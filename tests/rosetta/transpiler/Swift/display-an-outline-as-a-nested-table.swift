// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:32:44 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    func split(_ s: String, _ sep: String) -> [String] {
        var out: [String] = ([] as! [String])
        var cur: String = ""
        var i: Int = 0
        while (i < Int(((s).count))) {
            if (((i + Int(((sep).count))) <= Int(((s).count))) && (String(describing: String(Array(String(describing: String(describing: s)))[Int(i)..<Int((i + Int(((sep).count))))])) == sep)) {
                out = (_append(out, cur) as! [String])
                cur = ""
                i = Int((i + Int(((sep).count))))
            } else {
                cur = String(describing: (cur + String(describing: String(Array(String(describing: String(describing: s)))[Int(i)..<Int((i + 1))]))))
                i = Int((i + 1))
            }
        }
        out = (_append(out, cur) as! [String])
        return (out as! [String])
    }
    func join(_ xs: [String], _ sep: String) -> String {
        var res: String = ""
        var i: Int = 0
        while (i < Int(((xs).count))) {
            if (i > 0) {
                res = String(describing: (res + sep))
            }
            res = String(describing: (res + String(describing: xs[i])))
            i = Int((i + 1))
        }
        return String(describing: res)
    }
    func trimLeftSpaces(_ s: String) -> String {
        var i: Int = 0
        while ((i < Int(((s).count))) && (String(Array(s)[i..<(i + 1)]) == " ")) {
            i = Int((i + 1))
        }
        return String(describing: String(Array(s)[i..<Int(((s).count))]))
    }
    func makeIndent(_ outline: String, _ tab: Int) -> [[String: Any]] {
        let lines = (split(String(describing: outline), "\n") as! [String])
        var nodes: [[String: Any]] = ([] as! [[String: Any]])
        for line in lines {
            let line2 = String(describing: trimLeftSpaces(String(describing: line)))
            let level = (Int((Int(((line).count)) - Int(((line2).count)))) / tab)
            nodes = ((_append(nodes, ["level": level, "name": line2]) as! [Any]) as! [[String: Any]])
        }
        return (nodes as! [[String: Any]])
    }
    func toNest(_ nodes: [[String: Any]], _ start: Int, _ level: Int, _ n: inout [String: Any]) {
        if (level == 0) {
            n["name"] = ((nodes[0] as! [String: Any])["name"] as! Any)
        }
        var i: Int = (start + 1)
        while (i < Int(((nodes).count))) {
            let node = (nodes[i] as! [String: Any])
            let lev = (node["level"]! as! Int)
            if (lev == (level + 1)) {
                var child: Any = ["name": node["name"]!, "children": [] as [Any]]
                _ = toNest((nodes as! [[String: Any]]), Int(i), Int((level + 1)), &child)
                var cs: [Any] = (n["children"]! as! [Any])
                cs = (_append(cs, child) as! [Any])
                n["children"] = cs
            } else if (lev <= level) {
                return
            }
            
            i = Int((i + 1))
        }
    }
    func countLeaves(_ n: [String: Any]) -> Int {
        let kids = (n["children"]! as! [Any])
        if (Int(((kids).count)) == 0) {
            return 1
        }
        var total: Int = 0
        for k in kids {
            total = Int((total + Int(countLeaves((k as! [String: Any])))))
        }
        return Int(total)
    }
    func nodesByDepth(_ root: [String: Any], _ depth: Int) -> [[[String: Any]]] {
        var levels: [[[String: Any]]] = ([] as! [[[String: Any]]])
        var current: [[String: Any]] = ([root] as! [[String: Any]])
        var d: Int = 0
        while (d < depth) {
            levels = (_append(levels, current) as! [[[String: Any]]])
            var next: [[String: Any]] = ([] as! [[String: Any]])
            for _item in current as! [[String: Any]] {
                let n = _item as! [String: Any]
                let kids = (n["children"]! as! [Any])
                for k in kids {
                    next = (_append(next, (k as! [String: Any])) as! [[String: Any]])
                }
            }
            current = (next as! [[String: Any]])
            d = Int((d + 1))
        }
        return (levels as! [[[String: Any]]])
    }
    func toMarkup(_ n: [String: Any], _ cols: [String], _ depth: Int) -> String {
        var lines: [String] = ([] as! [String])
        lines = (_append(lines, "{| class=\"wikitable\" style=\"text-align: center;\"") as! [String])
        let l1 = "|-"
        lines = (_append(lines, l1) as! [String])
        var span = Int(countLeaves((n as! [String: Any])))
        lines = (_append(lines, ((((("| style=\"background: " + String(describing: cols[0])) + " \" colSpan=") + _p(span)) + " | ") + String(describing: n["name"]!))) as! [String])
        lines = (_append(lines, l1) as! [String])
        let lvls = (nodesByDepth((n as! [String: Any]), Int(depth)) as! [[[String: Any]]])
        var lvl: Int = 1
        while (lvl < depth) {
            let nodes = (lvls[lvl] as! [[String: Any]])
            if (Int(((nodes).count)) == 0) {
                lines = (_append(lines, "|  |") as! [String])
            } else {
                var idx: Int = 0
                while (idx < Int(((nodes).count))) {
                    let node = (nodes[idx] as! [String: Any])
                    span = Int(countLeaves((node as! [String: Any])))
                    var col: Int = lvl
                    if (lvl == 1) {
                        col = Int((idx + 1))
                    }
                    if (col >= Int(((cols).count))) {
                        col = Int((Int(((cols).count)) - 1))
                    }
                    let cell = ((((("| style=\"background: " + String(describing: cols[col])) + " \" colspan=") + _p(span)) + " | ") + String(describing: node["name"]!))
                    lines = (_append(lines, cell) as! [String])
                    idx = Int((idx + 1))
                }
            }
            if (lvl < (depth - 1)) {
                lines = (_append(lines, l1) as! [String])
            }
            lvl = Int((lvl + 1))
        }
        lines = (_append(lines, "|}") as! [String])
        return String(describing: join((lines as! [String]), "\n"))
    }
    func main() {
        let outline = ((((((((((("Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n") + "        measuring the indent of each line,\n") + "        translating the indentation to a nested structure,\n") + "        and padding the tree to even depth.\n") + "    count the leaves descending from each node,\n") + "        defining the width of a leaf as 1,\n") + "        and the width of a parent node as a sum.\n") + "            (The sum of the widths of its children)\n") + "    and write out a table with 'colspan' values\n") + "        either as a wiki table,\n") + "        or as HTML.")
        let yellow = "#ffffe6;"
        let orange = "#ffebd2;"
        let green = "#f0fff0;"
        let blue = "#e6ffff;"
        let pink = "#ffeeff;"
        let cols = ([yellow, orange, green, blue, pink] as! [String])
        let nodes = (makeIndent(String(describing: outline), 4) as! [[String: Any]])
        var n: Any = ["name": "", "children": [] as [Any]]
        _ = toNest((nodes as! [[String: Any]]), 0, 0, &n)
        print(_p(String(describing: toMarkup((n as! [String: Any]), (cols as! [String]), 4))))
        print(_p("\n"))
        let outline2 = ((((((((((((("Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n") + "        measuring the indent of each line,\n") + "        translating the indentation to a nested structure,\n") + "        and padding the tree to even depth.\n") + "    count the leaves descending from each node,\n") + "        defining the width of a leaf as 1,\n") + "        and the width of a parent node as a sum.\n") + "            (The sum of the widths of its children)\n") + "            Propagating the sums upward as necessary.\n") + "    and write out a table with 'colspan' values\n") + "        either as a wiki table,\n") + "        or as HTML.\n") + "    Optionally add color to the nodes.")
        let cols2 = ([blue, yellow, orange, green, pink] as! [String])
        let nodes2 = (makeIndent(String(describing: outline2), 4) as! [[String: Any]])
        var n2: Any = ["name": "", "children": [] as [Any]]
        _ = toNest((nodes2 as! [[String: Any]]), 0, 0, &n2)
        print(_p(String(describing: toMarkup((n2 as! [String: Any]), (cols2 as! [String]), 4))))
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
