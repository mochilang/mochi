// Generated by Mochi transpiler v0.10.41 on 2025-07-26 19:36:43 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

func split(_ s: String, _ sep: String) -> [String] {
    var out: [String] = ([] as! [String])
    var cur: String = ""
    var i: Int = 0
    while (i < Int(((s).count))) {
        if (((i + Int(((sep).count))) <= Int(((s).count))) && (String(describing: String(Array(String(s))[Int(i)..<Int((i + Int(((sep).count))))])) == sep)) {
            out = ((out + [cur]) as! [String])
            cur = ""
            i = Int((i + Int(((sep).count))))
        } else {
            cur = String((cur + String(describing: String(Array(String(s))[Int(i)..<Int((i + 1))]))))
            i = Int((i + 1))
        }
    }
    out = ((out + [cur]) as! [String])
    return (out as! [String])
}
func join(_ xs: [String], _ sep: String) -> String {
    var res: String = ""
    var i: Int = 0
    while (i < Int(((xs).count))) {
        if (i > 0) {
            res = String((res + sep))
        }
        res = String((res + (xs[i] as! String)))
        i = Int((i + 1))
    }
    return String(res)
}
func trimLeftSpaces(_ s: String) -> String {
    var i: Int = 0
    while ((i < Int(((s).count))) && (String(Array(s)[i..<(i + 1)]) == " ")) {
        i = Int((i + 1))
    }
    return String(String(Array(s)[i..<Int(((s).count))]))
}
func makeIndent(_ outline: String, _ tab: Int) -> [[String: Any]] {
    let lines = (split(String(outline), "\n") as! [String])
    var nodes: [[String: Any]] = ([] as! [[String: Any]])
    for line in lines {
        let line2 = String(describing: trimLeftSpaces(String(line)))
        let level = (Int((Int(((line).count)) - Int(((line2).count)))) / tab)
        nodes = ((((nodes + [["level": level, "name": line2]]) as! [[String: Any]]) as! [Any]) as! [[String: Any]])
    }
    return (nodes as! [[String: Any]])
}
func toNest(_ nodes: [[String: Any]], _ start: Int, _ level: Int, _ n: inout [String: Any]) {
    if (level == 0) {
        n["name"] = ((nodes[0] as! [String: Any])["name"] as! Any)
    }
    var i: Int = (start + 1)
    while (i < Int(((nodes).count))) {
        let node = (nodes[i] as! [String: Any])
        let lev = (node["level"]! as! Int)
        if (lev == (level + 1)) {
            var child: Any = ["name": node["name"]!, "children": [] as [Any]]
            _ = toNest((nodes as! [[String: Any]]), Int(i), Int((level + 1)), &child)
            var cs: [Any] = (n["children"]! as! [Any])
            cs = ((cs + [child]) as! [Any])
            n["children"] = cs
        } else if (lev <= level) {
            return
        }
        
        i = Int((i + 1))
    }
}
func countLeaves(_ n: [String: Any]) -> Int {
    let kids = (n["children"]! as! [Any])
    if (Int(((kids).count)) == 0) {
        return 1
    }
    var total: Int = 0
    for k in kids {
        total = Int((total + Int(countLeaves((k as! [String: Any])))))
    }
    return Int(total)
}
func nodesByDepth(_ root: [String: Any], _ depth: Int) -> [[[String: Any]]] {
    var levels: [[[String: Any]]] = ([] as! [[[String: Any]]])
    var current: [[String: Any]] = ([root] as! [[String: Any]])
    var d: Int = 0
    while (d < depth) {
        levels = ((levels + [current]) as! [[[String: Any]]])
        var next: [[String: Any]] = ([] as! [[String: Any]])
        for _item in current as! [[String: Any]] {
            let n = _item as! [String: Any]
            let kids = (n["children"]! as! [Any])
            for k in kids {
                next = ((next + [(k as! [String: Any])]) as! [[String: Any]])
            }
        }
        current = (next as! [[String: Any]])
        d = Int((d + 1))
    }
    return (levels as! [[[String: Any]]])
}
func toMarkup(_ n: [String: Any], _ cols: [String], _ depth: Int) -> String {
    var lines: [String] = ([] as! [String])
    lines = ((lines + ["{| class=\"wikitable\" style=\"text-align: center;\""]) as! [String])
    let l1 = "|-"
    lines = ((lines + [l1]) as! [String])
    var span = Int(countLeaves((n as! [String: Any])))
    lines = ((lines + [((((("| style=\"background: " + (cols[0] as! String)) + " \" colSpan=") + _p(span)) + " | ") + (n["name"]! as! String))]) as! [String])
    lines = ((lines + [l1]) as! [String])
    let lvls = (nodesByDepth((n as! [String: Any]), Int(depth)) as! [[[String: Any]]])
    var lvl: Int = 1
    while (lvl < depth) {
        let nodes = (lvls[lvl] as! [[String: Any]])
        if (Int(((nodes).count)) == 0) {
            lines = ((lines + ["|  |"]) as! [String])
        } else {
            var idx: Int = 0
            while (idx < Int(((nodes).count))) {
                let node = (nodes[idx] as! [String: Any])
                span = Int(countLeaves((node as! [String: Any])))
                var col: Int = lvl
                if (lvl == 1) {
                    col = Int((idx + 1))
                }
                if (col >= Int(((cols).count))) {
                    col = Int((Int(((cols).count)) - 1))
                }
                let cell = ((((("| style=\"background: " + (cols[col] as! String)) + " \" colspan=") + _p(span)) + " | ") + (node["name"]! as! String))
                lines = ((lines + [cell]) as! [String])
                idx = Int((idx + 1))
            }
        }
        if (lvl < (depth - 1)) {
            lines = ((lines + [l1]) as! [String])
        }
        lvl = Int((lvl + 1))
    }
    lines = ((lines + ["|}"]) as! [String])
    return String(describing: join((lines as! [String]), "\n"))
}
func main() {
    let outline = ((((((((((("Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n") + "        measuring the indent of each line,\n") + "        translating the indentation to a nested structure,\n") + "        and padding the tree to even depth.\n") + "    count the leaves descending from each node,\n") + "        defining the width of a leaf as 1,\n") + "        and the width of a parent node as a sum.\n") + "            (The sum of the widths of its children)\n") + "    and write out a table with 'colspan' values\n") + "        either as a wiki table,\n") + "        or as HTML.")
    let yellow = "#ffffe6;"
    let orange = "#ffebd2;"
    let green = "#f0fff0;"
    let blue = "#e6ffff;"
    let pink = "#ffeeff;"
    let cols = ([yellow, orange, green, blue, pink] as! [String])
    let nodes = (makeIndent(String(outline), 4) as! [[String: Any]])
    var n: Any = ["name": "", "children": [] as [Any]]
    _ = toNest((nodes as! [[String: Any]]), 0, 0, &n)
    print(_p(String(describing: toMarkup((n as! [String: Any]), (cols as! [String]), 4))))
    print(_p("\n"))
    let outline2 = ((((((((((((("Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n") + "        measuring the indent of each line,\n") + "        translating the indentation to a nested structure,\n") + "        and padding the tree to even depth.\n") + "    count the leaves descending from each node,\n") + "        defining the width of a leaf as 1,\n") + "        and the width of a parent node as a sum.\n") + "            (The sum of the widths of its children)\n") + "            Propagating the sums upward as necessary.\n") + "    and write out a table with 'colspan' values\n") + "        either as a wiki table,\n") + "        or as HTML.\n") + "    Optionally add color to the nodes.")
    let cols2 = ([blue, yellow, orange, green, pink] as! [String])
    let nodes2 = (makeIndent(String(outline2), 4) as! [[String: Any]])
    var n2: Any = ["name": "", "children": [] as [Any]]
    _ = toNest((nodes2 as! [[String: Any]]), 0, 0, &n2)
    print(_p(String(describing: toMarkup((n2 as! [String: Any]), (cols2 as! [String]), 4))))
}
_ = main()
