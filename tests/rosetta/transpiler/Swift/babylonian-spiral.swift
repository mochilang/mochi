// Generated by Mochi transpiler v0.10.41 on 2025-07-26 20:36:55 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    func push(_ h: inout [[String: Int]], _ it: [String: Int]) -> [[String: Int]] {
        h = ((h + [it]) as! [[String: Int]])
        var i: Int = (Int(((h).count)) - 1)
        while ((i > 0) && ((h[(i - 1)]["s"] as! Int) > (h[i]["s"] as! Int))) {
            let tmp = (h[(i - 1)] as! [String: Int])
            h[(i - 1)] = (h[i] as! [String: Int])
            h[i] = (tmp as! [String: Int])
            i = Int((i - 1))
        }
        return (h as! [[String: Int]])
    }
    func step(_ h: inout [[String: Int]], _ nv: Int, _ dir: [Int]) -> [String: Any] {
        var nv = nv
        while ((Int(((h).count)) == 0) || ((nv * nv) <= (h[0]["s"] as! Int))) {
            h = (push(&h, (["s": (nv * nv), "a": nv, "b": 0] as! [String: Int])) as! [[String: Int]])
            nv = Int((nv + 1))
        }
        let s = (h[0]["s"] as! Int)
        var v: [[Int]] = ([] as! [[Int]])
        while ((Int(((h).count)) > 0) && ((h[0]["s"] as! Int) == s)) {
            let it = (h[0] as! [String: Int])
            h = (Array(h[1..<h.count]) as! [[String: Int]])
            v = ((v + [([it["a"]!, it["b"]!] as! [Int])]) as! [[Int]])
            if (it["a"]! > it["b"]!) {
                h = (push(&h, (["s": ((it["a"]! * it["a"]!) + (Int((it["b"]! + 1)) * Int((it["b"]! + 1)))), "a": it["a"]!, "b": (it["b"]! + 1)] as! [String: Int])) as! [[String: Int]])
            }
        }
        var list: [[Int]] = ([] as! [[Int]])
        for p in v {
            list = ((list + [p]) as! [[Int]])
        }
        var temp: [[Int]] = list
        for p in temp {
            if ((p[0] as! Int) != (p[1] as! Int)) {
                list = ((list + [([(p[1] as! Int), (p[0] as! Int)] as! [Int])]) as! [[Int]])
            }
        }
        temp = (list as! [[Int]])
        for p in temp {
            if ((p[1] as! Int) != 0) {
                list = ((list + [([(p[0] as! Int), -(p[1] as! Int)] as! [Int])]) as! [[Int]])
            }
        }
        temp = (list as! [[Int]])
        for p in temp {
            if ((p[0] as! Int) != 0) {
                list = ((list + [([-(p[0] as! Int), (p[1] as! Int)] as! [Int])]) as! [[Int]])
            }
        }
        var bestDot: Int = -999999999
        var best: [Int] = dir
        for p in list {
            let cross = (((p[0] as! Int) * (dir[1] as! Int)) - ((p[1] as! Int) * (dir[0] as! Int)))
            if (cross >= 0) {
                let dot = (((p[0] as! Int) * (dir[0] as! Int)) + ((p[1] as! Int) * (dir[1] as! Int)))
                if (dot > bestDot) {
                    bestDot = Int(dot)
                    best = (p as! [Int])
                }
            }
        }
        return (["d": best, "heap": h, "n": nv] as! [String: Any])
    }
    func positions(_ n: Int) -> [[Int]] {
        var pos: [[Int]] = ([] as! [[Int]])
        var x: Int = 0
        var y: Int = 0
        var dir: [Int] = ([0, 1] as! [Int])
        var heap: [[String: Int]] = ([] as! [[String: Int]])
        var nv: Int = 1
        var i: Int = 0
        while (i < n) {
            pos = ((pos + [([x, y] as! [Int])]) as! [[Int]])
            let st = (step(&heap, Int(nv), (dir as! [Int])) as! [String: Any])
            dir = (st["d"]! as! [Int])
            heap = (st["heap"]! as! [[String: Int]])
            nv = (st["n"]! as! Int)
            x = Int((x + (dir[0] as! Int)))
            y = Int((y + (dir[1] as! Int)))
            i = Int((i + 1))
        }
        return (pos as! [[Int]])
    }
    func pad(_ s: String, _ w: Int) -> String {
        var r: String = s
        while (Int(((r).count)) < w) {
            r = String((r + " "))
        }
        return String(r)
    }
    func main() {
        let pts = (positions(40) as! [[Int]])
        print(_p("The first 40 Babylonian spiral points are:"))
        var line: String = ""
        var i: Int = 0
        while (i < Int(((pts).count))) {
            let p = (pts[i] as! [Int])
            let s = String(describing: pad(String((((("(" + _p((p[0] as! Int))) + ", ") + _p((p[1] as! Int))) + ")")), 10))
            line = String((line + s))
            if ((Int((i + 1)) % 10) == 0) {
                print(_p(line))
                line = ""
            }
            i = Int((i + 1))
        }
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
