// Generated by Mochi transpiler v0.10.41 on 2025-07-26 20:36:18 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    func absf(_ x: Double) -> Double {
        if (x < 0.0) {
            return Double(-x)
        }
        return Double(x)
    }
    func maxf(_ a: Double, _ b: Double) -> Double {
        if (a > b) {
            return Double(a)
        }
        return Double(b)
    }
    func minf(_ a: Double, _ b: Double) -> Double {
        if (a < b) {
            return Double(a)
        }
        return Double(b)
    }
    func max3(_ a: Double, _ b: Double, _ c: Double) -> Double {
        var m: Double = a
        if (b > m) {
            m = Double(b)
        }
        if (c > m) {
            m = Double(c)
        }
        return Double(m)
    }
    func min3(_ a: Double, _ b: Double, _ c: Double) -> Double {
        var m: Double = a
        if (b < m) {
            m = Double(b)
        }
        if (c < m) {
            m = Double(c)
        }
        return Double(m)
    }
    struct Point {
        var x: Double
        var y: Double
    }
    struct QuadSpline {
        var c0: Double
        var c1: Double
        var c2: Double
    }
    struct QuadCurve {
        var x: QuadSpline
        var y: QuadSpline
    }
    func subdivideQuadSpline(_ q: QuadSpline, _ t: Double) -> [QuadSpline] {
        let s = (1.0 - t)
        var u: QuadSpline = QuadSpline(c0: q.c0, c1: 0.0, c2: 0.0)
        var v: QuadSpline = QuadSpline(c0: 0.0, c1: 0.0, c2: q.c2)
        u.c1 = Double(((s * q.c0) + (t * q.c1)))
        v.c1 = Double(((s * q.c1) + (t * q.c2)))
        u.c2 = Double(((s * u.c1) + (t * v.c1)))
        v.c0 = Double(u.c2)
        return ([u, v] as! [QuadSpline])
    }
    func subdivideQuadCurve(_ q: QuadCurve, _ t: Double) -> [QuadCurve] {
        let xs = (subdivideQuadSpline((q.x as! QuadSpline), Double(t)) as! [QuadSpline])
        let ys = (subdivideQuadSpline((q.y as! QuadSpline), Double(t)) as! [QuadSpline])
        var u: QuadCurve = QuadCurve(x: (xs[0] as! QuadSpline), y: (ys[0] as! QuadSpline))
        var v: QuadCurve = QuadCurve(x: (xs[1] as! QuadSpline), y: (ys[1] as! QuadSpline))
        return ([u, v] as! [QuadCurve])
    }
    func rectsOverlap(_ xa0: Double, _ ya0: Double, _ xa1: Double, _ ya1: Double, _ xb0: Double, _ yb0: Double, _ xb1: Double, _ yb1: Double) -> Bool {
        return (((((xb0 <= xa1) && (xa0 <= xb1)) && (yb0 <= ya1)) && (ya0 <= yb1)) as! Bool)
    }
    func testIntersect(_ p: QuadCurve, _ q: QuadCurve, _ tol: Double) -> [String: Any] {
        let pxmin = Double(min3(Double(p.x.c0), Double(p.x.c1), Double(p.x.c2)))
        let pymin = Double(min3(Double(p.y.c0), Double(p.y.c1), Double(p.y.c2)))
        let pxmax = Double(max3(Double(p.x.c0), Double(p.x.c1), Double(p.x.c2)))
        let pymax = Double(max3(Double(p.y.c0), Double(p.y.c1), Double(p.y.c2)))
        let qxmin = Double(min3(Double(q.x.c0), Double(q.x.c1), Double(q.x.c2)))
        let qymin = Double(min3(Double(q.y.c0), Double(q.y.c1), Double(q.y.c2)))
        let qxmax = Double(max3(Double(q.x.c0), Double(q.x.c1), Double(q.x.c2)))
        let qymax = Double(max3(Double(q.y.c0), Double(q.y.c1), Double(q.y.c2)))
        var exclude: Bool = true
        var accept: Bool = false
        var inter: Point = Point(x: 0.0, y: 0.0)
        if (rectsOverlap(Double(pxmin), Double(pymin), Double(pxmax), Double(pymax), Double(qxmin), Double(qymin), Double(qxmax), Double(qymax)) as! Bool) {
            exclude = false
            let xmin = Double(maxf(Double(pxmin), Double(qxmin)))
            let xmax = Double(minf(Double(pxmax), Double(qxmax)))
            if ((xmax - xmin) <= tol) {
                let ymin = Double(maxf(Double(pymin), Double(qymin)))
                let ymax = Double(minf(Double(pymax), Double(qymax)))
                if ((ymax - ymin) <= tol) {
                    accept = true
                    inter.x = Double((0.5 * Double((xmin + xmax))))
                    inter.y = Double((0.5 * Double((ymin + ymax))))
                }
            }
        }
        return (["exclude": exclude, "accept": accept, "intersect": inter] as! [String: Any])
    }
    func seemsToBeDuplicate(_ pts: [Point], _ xy: Point, _ spacing: Double) -> Bool {
        var i: Int = 0
        while (i < Int(((pts).count))) {
            let pt = (pts[i] as! Point)
            if ((Double(absf(Double((pt.x - xy.x)))) < spacing) && (Double(absf(Double((pt.y - xy.y)))) < spacing)) {
                return true
            }
            i = Int((i + 1))
        }
        return false
    }
    func findIntersects(_ p: QuadCurve, _ q: QuadCurve, _ tol: Double, _ spacing: Double) -> [Point] {
        var inters: [Point] = ([] as! [Point])
        var workload: [[String: QuadCurve]] = (([["p": p, "q": q]] as! [Any]) as! [[String: QuadCurve]])
        while (Int(((workload).count)) > 0) {
            let idx = (Int(((workload).count)) - 1)
            let work = (workload[idx] as! [String: QuadCurve])
            workload = (Array(workload[0..<idx]) as! [[String: QuadCurve]])
            let res = (testIntersect((work["p"]! as! QuadCurve), (work["q"]! as! QuadCurve), Double(tol)) as! [String: Any])
            let excl = res["exclude"]!
            let acc = res["accept"]!
            let inter = (res["intersect"]! as! Point)
            if (acc as! Bool) {
                if (!(seemsToBeDuplicate((inters as! [Point]), (inter as! Point), Double(spacing)) as! Bool)) {
                    inters = ((inters + [inter]) as! [Point])
                }
            } else if (!(excl as! Bool)) {
                let ps = (subdivideQuadCurve((work["p"]! as! QuadCurve), 0.5) as! [QuadCurve])
                let qs = (subdivideQuadCurve((work["q"]! as! QuadCurve), 0.5) as! [QuadCurve])
                let p0 = (ps[0] as! QuadCurve)
                let p1 = (ps[1] as! QuadCurve)
                let q0 = (qs[0] as! QuadCurve)
                let q1 = (qs[1] as! QuadCurve)
                workload = ((((workload + [["p": p0, "q": q0]]) as! [[String: QuadCurve]]) as! [Any]) as! [[String: QuadCurve]])
                workload = ((((workload + [["p": p0, "q": q1]]) as! [[String: QuadCurve]]) as! [Any]) as! [[String: QuadCurve]])
                workload = ((((workload + [["p": p1, "q": q0]]) as! [[String: QuadCurve]]) as! [Any]) as! [[String: QuadCurve]])
                workload = ((((workload + [["p": p1, "q": q1]]) as! [[String: QuadCurve]]) as! [Any]) as! [[String: QuadCurve]])
            }
            
        }
        return (inters as! [Point])
    }
    func main() {
        let p = QuadCurve(x: QuadSpline(c0: -1.0, c1: 0.0, c2: 1.0), y: QuadSpline(c0: 0.0, c1: 10.0, c2: 0.0))
        let q = QuadCurve(x: QuadSpline(c0: 2.0, c1: -8.0, c2: 2.0), y: QuadSpline(c0: 1.0, c1: 2.0, c2: 3.0))
        let tol = 0.0000001
        let spacing = (tol * 10.0)
        let inters = (findIntersects((p as! QuadCurve), (q as! QuadCurve), Double(tol), Double(spacing)) as! [Point])
        var i: Int = 0
        while (i < Int(((inters).count))) {
            let pt = (inters[i] as! Point)
            print(_p((((("(" + _p(pt.x)) + ", ") + _p(pt.y)) + ")")))
            i = Int((i + 1))
        }
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
