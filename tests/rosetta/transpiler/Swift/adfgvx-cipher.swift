// Generated by Mochi transpiler v0.10.39 on 2025-07-24 13:19:57 GMT+7
import Foundation

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
var adfgvx = "ADFGVX"
var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
func shuffleStr(_ s: String) -> String {
    var s = s
    var arr: [String] = ([] as! [String])
    var i = 0
    while (Int(i) < Int(((String(s)).count))) {
        arr = (((arr as! [String]) + [String(String(Array(s)[Int(i)..<(Int(i) + 1)]))]) as! [String])
        i = ((Int(i) + 1) as! Int)
    }
    var j = ((Int((((arr as! [String])).count)) - 1) as! Int)
    while (Int(j) > 0) {
        let k = (Int(_now()) % Int((Int(j) + 1)))
        let tmp = String(arr[Int(j)])
        arr[Int(j)] = String(arr[Int(k)])
        arr[Int(k)] = String(tmp)
        j = ((Int(j) - 1) as! Int)
    }
    var out = ""
    i = 0
    while (Int(i) < Int((((arr as! [String])).count))) {
        out = ((String(out) + String(arr[Int(i)])) as! String)
        i = ((Int(i) + 1) as! Int)
    }
    return String(out)
}
func createPolybius() -> [String] {
    let shuffled = String(shuffleStr(String(alphabet)))
    var labels: [String] = ([] as! [String])
    var li = 0
    while (Int(li) < Int(((String(adfgvx)).count))) {
        labels = (((labels as! [String]) + [String(String(Array(adfgvx)[Int(li)..<(Int(li) + 1)]))]) as! [String])
        li = ((Int(li) + 1) as! Int)
    }
    print("6 x 6 Polybius square:\n")
    print("  | A D F G V X")
    print("---------------")
    var p: [String] = ([] as! [String])
    var i = 0
    while (Int(i) < 6) {
        var row = String(String(Array(shuffled)[(Int(i) * 6)..<(Int((Int(i) + 1)) * 6)]))
        p = (((p as! [String]) + [String(row)]) as! [String])
        var line = ((String(labels[Int(i)]) + " | ") as! String)
        var j = 0
        while (Int(j) < 6) {
            line = (((String(line) + String(String(Array(row)[Int(j)..<(Int(j) + 1)]))) + " ") as! String)
            j = ((Int(j) + 1) as! Int)
        }
        print(String(line))
        i = ((Int(i) + 1) as! Int)
    }
    return (p as! [String])
}
func createKey(_ n: Int) -> String {
    var n = n
    if ((Int(n) < 7) || (Int(n) > 12)) {
        print("Key should be within 7 and 12 letters long.")
    }
    var pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    var key = ""
    var i = 0
    while (Int(i) < Int(n)) {
        let idx = (Int(_now()) % Int(((String(pool)).count)))
        key = ((String(key) + String(String(Array(pool)[Int(idx)]))) as! String)
        pool = ((String(String(Array(pool)[0..<Int(idx)])) + String(String(Array(pool)[(Int(idx) + 1)..<Int(((String(pool)).count))]))) as! String)
        i = ((Int(i) + 1) as! Int)
    }
    print(("\nThe key is " + String(key)))
    return String(key)
}
func orderKey(_ key: String) -> [Int] {
    var key = key
    var pairs: [Any] = ([] as! [Any])
    var i = 0
    while (Int(i) < Int(((String(key)).count))) {
        pairs = (((((pairs as! [Any]) + [([String(String(Array(key)[Int(i)..<(Int(i) + 1)])), Int(i)] as! [Any])]) as! [Any]) as! [[Any]]) as! [Any])
        i = ((Int(i) + 1) as! Int)
    }
    var n = Int((((pairs as! [Any])).count))
    var m = 0
    while (Int(m) < Int(n)) {
        var j = 0
        while (Int(j) < (Int(n) - 1)) {
            if (String(describing: ((pairs as! [Any])[Int(j)] as! [Any])[0])
            > String(describing: ((pairs as! [Any])[(Int(j) + 1)] as! [Any])[0])
            ) {
                let tmp = (pairs as! [Any])[Int(j)]
                pairs[Int(j)] = (pairs as! [Any])[(Int(j) + 1)]
                pairs[(Int(j) + 1)] = tmp
            }
            j = ((Int(j) + 1) as! Int)
        }
        m = ((Int(m) + 1) as! Int)
    }
    var res: [Any] = ([] as! [Any])
    i = 0
    while (Int(i) < Int(n)) {
        res = (((((res as! [Any]) + [Int(((pairs as! [Any])[Int(i)] as! [Any])[1])]) as! [Any]) as! [Int]) as! [Any])
        i = ((Int(i) + 1) as! Int)
    }
    return ((res as! [Any]) as! [Int])
}
func encrypt(_ polybius: [String], _ key: String, _ plainText: String) -> String {
    var polybius = polybius
    var key = key
    var plainText = plainText
    var labels: [String] = ([] as! [String])
    var li = 0
    while (Int(li) < Int(((String(adfgvx)).count))) {
        labels = (((labels as! [String]) + [String(String(Array(adfgvx)[Int(li)..<(Int(li) + 1)]))]) as! [String])
        li = ((Int(li) + 1) as! Int)
    }
    var temp = ""
    var i = 0
    while (Int(i) < Int(((String(plainText)).count))) {
        var r = 0
        while (Int(r) < 6) {
            var c = 0
            while (Int(c) < 6) {
                if (String(Array(polybius[Int(r)][Int(c)..<(Int(c) + 1)])) == String(String(Array(plainText)[Int(i)..<(Int(i) + 1)]))) {
                    temp = (((String(temp) + (Array(labels[Int(r)..<(Int(r) + 1)]) as! [String])) + (Array(labels[Int(c)..<(Int(c) + 1)]) as! [String])) as! String)
                }
                c = ((Int(c) + 1) as! Int)
            }
            r = ((Int(r) + 1) as! Int)
        }
        i = ((Int(i) + 1) as! Int)
    }
    var colLen = ((Int(((String(temp)).count)) / Int(((String(key)).count))) as! Int)
    if ((Int(((String(temp)).count)) % Int(((String(key)).count))) > 0) {
        colLen = ((Int(colLen) + 1) as! Int)
    }
    var table: [[String]] = ([] as! [[String]])
    var rIdx = 0
    while (Int(rIdx) < Int(colLen)) {
        var row: [String] = ([] as! [String])
        var j = 0
        while (Int(j) < Int(((String(key)).count))) {
            row = (((row as! [String]) + [""]) as! [String])
            j = ((Int(j) + 1) as! Int)
        }
        table = (((table as! [[String]]) + [(row as! [String])]) as! [[String]])
        rIdx = ((Int(rIdx) + 1) as! Int)
    }
    var idx = 0
    while (Int(idx) < Int(((String(temp)).count))) {
        let row = (Int(idx) / Int(((String(key)).count)))
        let col = (Int(idx) % Int(((String(key)).count)))
        table[Int(row)][Int(col)] = String(String(Array(temp)[Int(idx)..<(Int(idx) + 1)]))
        idx = ((Int(idx) + 1) as! Int)
    }
    let order = (orderKey(String(key)) as! [Int])
    var cols: [String] = ([] as! [String])
    var ci = 0
    while (Int(ci) < Int(((String(key)).count))) {
        var colStr = ""
        var ri = 0
        while (Int(ri) < Int(colLen)) {
            colStr = ((String(colStr) + String(String(Array(table[Int(ri)])[Int(order[Int(ci)])]))) as! String)
            ri = ((Int(ri) + 1) as! Int)
        }
        cols = (((cols as! [String]) + [String(colStr)]) as! [String])
        ci = ((Int(ci) + 1) as! Int)
    }
    var result = ""
    ci = 0
    while (Int(ci) < Int((((cols as! [String])).count))) {
        result = ((String(result) + String(cols[Int(ci)])) as! String)
        if (Int(ci) < (Int((((cols as! [String])).count)) - 1)) {
            result = ((String(result) + " ") as! String)
        }
        ci = ((Int(ci) + 1) as! Int)
    }
    return String(result)
}
func indexOf(_ s: String, _ ch: String) -> Int {
    var s = s
    var ch = ch
    var i = 0
    while (Int(i) < Int(((String(s)).count))) {
        if (String(String(Array(s)[Int(i)..<(Int(i) + 1)])) == String(ch)) {
            return Int(i)
        }
        i = ((Int(i) + 1) as! Int)
    }
    return (-1 as! Int)
}
func decrypt(_ polybius: [String], _ key: String, _ cipherText: String) -> String {
    var polybius = polybius
    var key = key
    var cipherText = cipherText
    var colStrs: [String] = ([] as! [String])
    var start = 0
    var i = 0
    while (Int(i) <= Int(((String(cipherText)).count))) {
        if ((Int(i) == Int(((String(cipherText)).count))) || (String(String(Array(cipherText)[Int(i)])) == " ")) {
            colStrs = (((colStrs as! [String]) + [String(String(Array(cipherText)[Int(start)..<Int(i)]))]) as! [String])
            start = ((Int(i) + 1) as! Int)
        }
        i = ((Int(i) + 1) as! Int)
    }
    var maxColLen = 0
    i = 0
    while (Int(i) < Int((((colStrs as! [String])).count))) {
        if (Int(((String(colStrs[Int(i)])).count)) > Int(maxColLen)) {
            maxColLen = Int(((String(colStrs[Int(i)])).count))
        }
        i = ((Int(i) + 1) as! Int)
    }
    var cols: [[String]] = ([] as! [[String]])
    i = 0
    while (Int(i) < Int((((colStrs as! [String])).count))) {
        var s = String(colStrs[Int(i)])
        var ls: [String] = ([] as! [String])
        var j = 0
        while (Int(j) < Int(((String(s)).count))) {
            ls = (((ls as! [String]) + [String(String(Array(s)[Int(j)..<(Int(j) + 1)]))]) as! [String])
            j = ((Int(j) + 1) as! Int)
        }
        if (Int(((String(s)).count)) < Int(maxColLen)) {
            var pad: [String] = ([] as! [String])
            var k = 0
            while (Int(k) < Int(maxColLen)) {
                if (Int(k) < Int((((ls as! [String])).count))) {
                    pad = (((pad as! [String]) + [String(ls[Int(k)])]) as! [String])
                } else {
                    pad = (((pad as! [String]) + [""]) as! [String])
                }
                k = ((Int(k) + 1) as! Int)
            }
            cols = (((cols as! [[String]]) + [(pad as! [String])]) as! [[String]])
        } else {
            cols = (((cols as! [[String]]) + [(ls as! [String])]) as! [[String]])
        }
        i = ((Int(i) + 1) as! Int)
    }
    var table: [[String]] = ([] as! [[String]])
    var r = 0
    while (Int(r) < Int(maxColLen)) {
        var row: [String] = ([] as! [String])
        var c = 0
        while (Int(c) < Int(((String(key)).count))) {
            row = (((row as! [String]) + [""]) as! [String])
            c = ((Int(c) + 1) as! Int)
        }
        table = (((table as! [[String]]) + [(row as! [String])]) as! [[String]])
        r = ((Int(r) + 1) as! Int)
    }
    let order = (orderKey(String(key)) as! [Int])
    r = 0
    while (Int(r) < Int(maxColLen)) {
        var c = 0
        while (Int(c) < Int(((String(key)).count))) {
            table[Int(r)][Int(order[Int(c)])] = String(String(Array(cols[Int(c)])[Int(r)]))
            c = ((Int(c) + 1) as! Int)
        }
        r = ((Int(r) + 1) as! Int)
    }
    var temp = ""
    r = 0
    while (Int(r) < Int((((table as! [[String]])).count))) {
        var j = 0
        while (Int(j) < Int((((table[Int(r)] as! [String])).count))) {
            temp = ((String(temp) + String(String(Array(table[Int(r)])[Int(j)]))) as! String)
            j = ((Int(j) + 1) as! Int)
        }
        r = ((Int(r) + 1) as! Int)
    }
    var plainText = ""
    var idx = 0
    while (Int(idx) < Int(((String(temp)).count))) {
        let rIdx = Int(indexOf(String(adfgvx), String(String(Array(temp)[Int(idx)..<(Int(idx) + 1)]))))
        let cIdx = Int(indexOf(String(adfgvx), String(String(Array(temp)[(Int(idx) + 1)..<(Int(idx) + 2)]))))
        plainText = ((String(plainText) + String((polybius[Int(rIdx)] as! [Any])[Int(cIdx)])) as! String)
        idx = ((Int(idx) + 2) as! Int)
    }
    return String(plainText)
}
func main() {
    let plainText = "ATTACKAT1200AM"
    let polybius = (createPolybius() as! [String])
    let key = String(createKey(9))
    print(("\nPlaintext : " + String(plainText)))
    let cipherText = String(encrypt((polybius as! [String]), String(key), String(plainText)))
    print(("\nEncrypted : " + String(cipherText)))
    let plainText2 = String(decrypt((polybius as! [String]), String(key), String(cipherText)))
    print(("\nDecrypted : " + String(plainText2)))
}
main()
