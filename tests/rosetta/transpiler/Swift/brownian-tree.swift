// Generated by Mochi transpiler v0.10.42 on 2025-07-27 17:30:17 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
let w: Int = 400
let h: Int = 300
let n: Int = 15000
let frost: Int = 255
var grid: [[Int]] = ([] as! [[Int]])
var y: Int = 0
while (y < h) {
    var row: [Int] = ([] as! [Int])
    var x: Int = 0
    while (x < w) {
        row = ((row + [0]) as! [Int])
        x = Int((x + 1))
    }
    grid = ((grid + [row]) as! [[Int]])
    y = Int((y + 1))
}
grid[(h / 3)][(w / 3)] = Int(frost)
func inBounds(_ x: Int, _ y: Int) -> Bool {
    return ((((x >= 0) && (x < w)) && (y >= 0)) && (y < h))
}
func hasNeighbor(_ x: Int, _ y: Int) -> Bool {
    var dy: Int = -1
    while (dy <= 1) {
        var dx: Int = -1
        while (dx <= 1) {
            if (!((dx == 0) && (dy == 0))) {
                let nx = (x + dx)
                let ny = (y + dy)
                if (inBounds(Int(nx), Int(ny)) && ((grid[ny][nx] as! Int) == frost)) {
                    return true
                }
            }
            dx = Int((dx + 1))
        }
        dy = Int((dy + 1))
    }
    return false
}
var a: Int = 0
while (a < n) {
    var px: Int = (Int(_now()) % w)
    var py: Int = (Int(_now()) % h)
    if ((grid[py][px] as! Int) == frost) {
        var lost: Bool = false
        while true {
            px = Int(((px + Int((Int(_now()) % 3))) - 1))
            py = Int(((py + Int((Int(_now()) % 3))) - 1))
            if (!inBounds(Int(px), Int(py))) {
                lost = true
                break
            }
            if ((grid[py][px] as! Int) != frost) {
                break
            }
        }
        if lost {
            continue
        }
    } else {
        var lost: Bool = false
        while (!hasNeighbor(Int(px), Int(py))) {
            px = Int(((px + Int((Int(_now()) % 3))) - 1))
            py = Int(((py + Int((Int(_now()) % 3))) - 1))
            if (!inBounds(Int(px), Int(py))) {
                lost = true
                break
            }
        }
        if lost {
            continue
        }
    }
    grid[py][px] = Int(frost)
    a = Int((a + 1))
}
