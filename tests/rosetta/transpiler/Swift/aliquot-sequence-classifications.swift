// Generated by Mochi transpiler v0.10.39 on 2025-07-24 21:15:38 GMT+7
import Foundation

let THRESHOLD = 140737488355328
func indexOf(_ xs: [Int], _ value: Int) -> Int {
    var i = 0
    while (Int(i) < Int((((xs as! [Int])).count))) {
        if (Int(xs[Int(i)]) == Int(value)) {
            return Int(i)
        }
        i = ((Int(i) + 1) as! Int)
    }
    return ((0 - 1) as! Int)
}
func contains(_ xs: [Int], _ value: Int) -> Bool {
    return ((Int(indexOf((xs as! [Int]), Int(value))) != (0 - 1)) as! Bool)
}
func maxOf(_ a: Int, _ b: Int) -> Int {
    if (Int(a) > Int(b)) {
        return Int(a)
    } else {
        return Int(b)
    }
}
func intSqrt(_ n: Int) -> Int {
    if (Int(n) == 0) {
        return 0
    }
    var x = Int(n)
    var y = ((Int((Int(x) + 1)) / 2) as! Int)
    while (Int(y) < Int(x)) {
        x = Int(y)
        y = ((Int((Int(x) + (Int(n) / Int(x)))) / 2) as! Int)
    }
    return Int(x)
}
func sumProperDivisors(_ n: Int) -> Int {
    if (Int(n) < 2) {
        return 0
    }
    let sqrt = Int(intSqrt(Int(n)))
    var sum = 1
    var i = 2
    while (Int(i) <= Int(sqrt)) {
        if ((Int(n) % Int(i)) == 0) {
            sum = (((Int(sum) + Int(i)) + (Int(n) / Int(i))) as! Int)
        }
        i = ((Int(i) + 1) as! Int)
    }
    if ((Int(sqrt) * Int(sqrt)) == Int(n)) {
        sum = ((Int(sum) - Int(sqrt)) as! Int)
    }
    return Int(sum)
}
func classifySequence(_ k: Int) -> [String: Any] {
    var last = Int(k)
    var seq: [Int] = ([Int(k)] as! [Int])
    while true {
        last = Int(sumProperDivisors(Int(last)))
        seq = (((seq as! [Int]) + [Int(last)]) as! [Int])
        let n = Int((((seq as! [Int])).count))
        var aliquot = ""
        if (Int(last) == 0) {
            aliquot = "Terminating"
        } else if ((Int(n) == 2) && (Int(last) == Int(k))) {
            aliquot = "Perfect"
        } else if ((Int(n) == 3) && (Int(last) == Int(k))) {
            aliquot = "Amicable"
        } else if ((Int(n) >= 4) && (Int(last) == Int(k))) {
            aliquot = ((("Sociable[" + String(describing: String(describing: (Int(n) - 1)))) + "]") as! String)
        } else if (Int(last) == Int(seq[(Int(n) - 2)])) {
            aliquot = "Aspiring"
        } else if Bool(contains((Array(seq[1..<Int(maxOf(1, ((Int(n) - 2) as! Int)))]) as! [Int]), Int(last))) {
            let idx = Int(indexOf((seq as! [Int]), Int(last)))
            aliquot = ((("Cyclic[" + String(describing: String(describing: ((Int(n) - 1) - Int(idx))))) + "]") as! String)
        } else if ((Int(n) == 16) || (Int(last) > Int(THRESHOLD))) {
            aliquot = "Non-Terminating"
        }
        
        
        
        
        
        
        if (String(describing: aliquot) != "") {
            return (["seq": (seq as! [Int]), "aliquot": String(describing: aliquot)] as [String: Any] as! [String: Any])
        }
    }
    return (["seq": (seq as! [Int]), "aliquot": ""] as [String: Any] as! [String: Any])
}
func padLeft(_ n: Int, _ w: Int) -> String {
    var s = String(describing: String(describing: Int(n)))
    while (Int(((String(describing: s)).count)) < Int(w)) {
        s = ((" " + String(describing: s)) as! String)
    }
    return String(describing: s)
}
func padRight(_ s: String, _ w: Int) -> String {
    var r = String(describing: s)
    while (Int(((String(describing: r)).count)) < Int(w)) {
        r = ((String(describing: r) + " ") as! String)
    }
    return String(describing: r)
}
func joinWithCommas(_ seq: [Int]) -> String {
    var s = "["
    var i = 0
    while (Int(i) < Int((((seq as! [Int])).count))) {
        s = ((String(describing: s) + String(describing: String(describing: Int(seq[Int(i)])))) as! String)
        if (Int(i) < (Int((((seq as! [Int])).count)) - 1)) {
            s = ((String(describing: s) + ", ") as! String)
        }
        i = ((Int(i) + 1) as! Int)
    }
    s = ((String(describing: s) + "]") as! String)
    return String(describing: s)
}
func main() {
    print("Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n")
    var k = 1
    while (Int(k) <= 10) {
        let res = (classifySequence(Int(k)) as! [String: Any])
        print(((((String(describing: padLeft(Int(k), 2)) + ": ") + String(describing: padRight(String(describing: (res as! [String: Any])["aliquot"]!), 15))) + " ") + String(describing: joinWithCommas(((res as! [String: Any])["seq"]! as! [Int])))))
        k = ((Int(k) + 1) as! Int)
    }
    print("")
    let s = ([11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488] as! [Int])
    var i = 0
    while (Int(i) < Int((((s as! [Int])).count))) {
        let val = Int(s[Int(i)])
        let res = (classifySequence(Int(val)) as! [String: Any])
        print(((((String(describing: padLeft(Int(val), 7)) + ": ") + String(describing: padRight(String(describing: (res as! [String: Any])["aliquot"]!), 15))) + " ") + String(describing: joinWithCommas(((res as! [String: Any])["seq"]! as! [Int])))))
        i = ((Int(i) + 1) as! Int)
    }
    print("")
    let big = 15355717786080
    let r = (classifySequence(Int(big)) as! [String: Any])
    print(((((String(describing: String(describing: Int(big))) + ": ") + String(describing: padRight(String(describing: (r as! [String: Any])["aliquot"]!), 15))) + " ") + String(describing: joinWithCommas(((r as! [String: Any])["seq"]! as! [Int])))))
}
_ = main()
