// Generated by Mochi transpiler v0.10.40 on 2025-07-26 10:32:38 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    let PI = 3.141592653589793
    func sinApprox(_ x: Double) -> Double {
        var term = x
        var sum = x
        var n = 1
        while (n <= 8) {
            let denom = Double((Int((2 * n)) * Int(((2 * n) + 1))))
            term = Double((((-term * x) * x) / denom))
            sum = Double((sum + term))
            n = Int((n + 1))
        }
        return Double(sum)
    }
    func cosApprox(_ x: Double) -> Double {
        var term = 1.0
        var sum = 1.0
        var n = 1
        while (n <= 8) {
            let denom = Double((Int(((2 * n) - 1)) * Int((2 * n))))
            term = Double((((-term * x) * x) / denom))
            sum = Double((sum + term))
            n = Int((n + 1))
        }
        return Double(sum)
    }
    func atanApprox(_ x: Double) -> Double {
        if (x > 1.0) {
            return Double(((PI / 2.0) - (x / Double(((x * x) + 0.28)))))
        }
        if (x < Double(-1.0)) {
            return Double(((-PI / 2.0) - (x / Double(((x * x) + 0.28)))))
        }
        return Double((x / Double((1.0 + ((0.28 * x) * x)))))
    }
    func atan2Approx(_ y: Double, _ x: Double) -> Double {
        if (x > 0.0) {
            return Double(atanApprox(Double((y / x))))
        }
        if (x < 0.0) {
            if (y >= 0.0) {
                return Double((Double(atanApprox(Double((y / x)))) + PI))
            }
            return Double((Double(atanApprox(Double((y / x)))) - PI))
        }
        if (y > 0.0) {
            return Double((PI / 2.0))
        }
        if (y < 0.0) {
            return Double((-PI / 2.0))
        }
        return 0.0
    }
    func digit(_ ch: String) -> Int {
        let digits = "0123456789"
        var i = 0
        while (i < Int(((digits).count))) {
            if (String(describing: String(Array(String(digits))[Int(i)..<Int((i + 1))])) == ch) {
                return Int(i)
            }
            i = Int((i + 1))
        }
        return 0
    }
    func parseTwo(_ s: String, _ idx: Int) -> Int {
        return Int(((Int(digit(String(describing: String(Array(String(s))[Int(idx)..<Int((idx + 1))])))) * 10) + Int(digit(String(describing: String(Array(String(s))[Int((idx + 1))..<Int((idx + 2))]))))))
    }
    func parseSec(_ s: String) -> Double {
        let h = Int(parseTwo(String(s), 0))
        let m = Int(parseTwo(String(s), 3))
        let sec = Int(parseTwo(String(s), 6))
        let tmp = ((Int(((h * 60) + m)) * 60) + sec)
        return Double(tmp)
    }
    func pad(_ n: Int) -> String {
        if (n < 10) {
            return String(("0" + _p(n)))
        }
        return String(_p(n))
    }
    func meanTime(_ times: [String]) -> String {
        var ssum = 0.0
        var csum = 0.0
        var i = 0
        while (i < Int(((times).count))) {
            let sec = Double(parseSec((times[i] as! String)))
            let ang = (((sec * 2.0) * PI) / 86400.0)
            ssum = Double((ssum + Double(sinApprox(Double(ang)))))
            csum = Double((csum + Double(cosApprox(Double(ang)))))
            i = Int((i + 1))
        }
        var theta = Double(atan2Approx(Double(ssum), Double(csum)))
        var frac = (theta / Double((2.0 * PI)))
        while (frac < 0.0) {
            frac = Double((frac + 1.0))
        }
        let total = (frac * 86400.0)
        let si = Int(total)
        let h = Int((si / 3600))
        let m = Int((Int((si % 3600)) / 60))
        let s = Int((si % 60))
        return String(((((String(describing: pad(Int(h))) + ":") + String(describing: pad(Int(m)))) + ":") + String(describing: pad(Int(s)))))
    }
    func main() {
        let inputs = (["23:00:17", "23:40:20", "00:12:45", "00:17:19"] as! [String])
        print(_p(String(describing: meanTime((inputs as! [String])))))
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
