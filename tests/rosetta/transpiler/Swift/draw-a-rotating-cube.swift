// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:33:15 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    let PI: Double = 3.141592653589793
    let TWO_PI: Double = 6.283185307179586
    func _mod(_ x: Double, _ m: Double) -> Double {
        return Double((x - (Double(Int((x / m))) * m)))
    }
    func _sin(_ x: Double) -> Double {
        let y = (Double(_mod(Double((x + PI)), Double(TWO_PI))) - PI)
        let y2 = (y * y)
        let y3 = (y2 * y)
        let y5 = (y3 * y2)
        let y7 = (y5 * y2)
        return Double((((y - (y3 / 6.0)) + (y5 / 120.0)) - (y7 / 5040.0)))
    }
    func _cos(_ x: Double) -> Double {
        let y = (Double(_mod(Double((x + PI)), Double(TWO_PI))) - PI)
        let y2 = (y * y)
        let y4 = (y2 * y2)
        let y6 = (y4 * y2)
        return Double((((1.0 - (y2 / 2.0)) + (y4 / 24.0)) - (y6 / 720.0)))
    }
    struct Point3 {
        var x: Double
        var y: Double
        var z: Double
    }
    struct Point2 {
        var x: Int
        var y: Int
    }
    let nodes: [Point3] = ([Point3(x: -1.0, y: -1.0, z: -1.0), Point3(x: -1.0, y: -1.0, z: 1.0), Point3(x: -1.0, y: 1.0, z: -1.0), Point3(x: -1.0, y: 1.0, z: 1.0), Point3(x: 1.0, y: -1.0, z: -1.0), Point3(x: 1.0, y: -1.0, z: 1.0), Point3(x: 1.0, y: 1.0, z: -1.0), Point3(x: 1.0, y: 1.0, z: 1.0)] as! [Point3])
    let edges: [[Int]] = ([([0, 1] as! [Int]), ([1, 3] as! [Int]), ([3, 2] as! [Int]), ([2, 0] as! [Int]), ([4, 5] as! [Int]), ([5, 7] as! [Int]), ([7, 6] as! [Int]), ([6, 4] as! [Int]), ([0, 4] as! [Int]), ([1, 5] as! [Int]), ([2, 6] as! [Int]), ([3, 7] as! [Int])] as! [[Int]])
    func rotate(_ p: Point3, _ ax: Double, _ ay: Double) -> Point3 {
        let sinx = Double(_sin(Double(ax)))
        let cosx = Double(_cos(Double(ax)))
        let siny = Double(_sin(Double(ay)))
        let cosy = Double(_cos(Double(ay)))
        let x1 = p.x
        let y1 = ((p.y * cosx) - (p.z * sinx))
        let z1 = ((p.y * sinx) + (p.z * cosx))
        let x2 = ((x1 * cosy) + (z1 * siny))
        let z2 = ((-x1 * siny) + (z1 * cosy))
        return (Point3(x: x2, y: y1, z: z2) as! Point3)
    }
    let width = 40
    let height = 20
    let distance = 3.0
    let scale = 8.0
    func project(_ p: Point3) -> Point2 {
        let factor = (scale / Double((p.z + distance)))
        let x = (Int((p.x * factor)) + (width / 2))
        let y = (Int((-p.y * factor)) + (height / 2))
        return (Point2(x: x, y: y) as! Point2)
    }
    func clearGrid() -> [[String]] {
        var g: [[String]] = ([] as! [[String]])
        var y: Int = 0
        while (y < height) {
            var row: [String] = ([] as! [String])
            var x: Int = 0
            while (x < width) {
                row = (_append(row, " ") as! [String])
                x = Int((x + 1))
            }
            g = (_append(g, row) as! [[String]])
            y = Int((y + 1))
        }
        return (g as! [[String]])
    }
    func drawPoint(_ g: inout [[String]], _ x: Int, _ y: Int, _ ch: String) {
        if ((((x >= 0) && (x < width)) && (y >= 0)) && (y < height)) {
            var row: [String] = (g[y] as! [String])
            row[x] = String(describing: ch)
            g[y] = (row as! [String])
        }
    }
    func bresenham(_ x0: Int, _ y0: Int, _ x1: Int, _ y1: Int, _ g: inout [[String]], _ ch: String) {
        var x0 = x0
        var y0 = y0
        var dx: Int = (x1 - x0)
        if (dx < 0) {
            dx = Int(-dx)
        }
        var dy: Int = (y1 - y0)
        if (dy < 0) {
            dy = Int(-dy)
        }
        var sx: Int = -1
        if (x0 < x1) {
            sx = 1
        }
        var sy: Int = -1
        if (y0 < y1) {
            sy = 1
        }
        var err: Int = (dx - dy)
        while true {
            _ = drawPoint(&g, Int(x0), Int(y0), String(describing: ch))
            if ((x0 == x1) && (y0 == y1)) {
                break
            }
            var e2: Int = (2 * err)
            if (e2 > Int(-dy)) {
                err = Int((err - dy))
                x0 = Int((x0 + sx))
            }
            if (e2 < dx) {
                err = Int((err + dx))
                y0 = Int((y0 + sy))
            }
        }
    }
    func render(_ g: [[String]]) -> String {
        var out: String = ""
        var y: Int = 0
        while (y < height) {
            var line: String = ""
            var x: Int = 0
            while (x < width) {
                line = String(describing: (line + String(describing: g[y][x])))
                x = Int((x + 1))
            }
            out = String(describing: ((out + line) + "\n"))
            y = Int((y + 1))
        }
        return String(describing: out)
    }
    func main() {
        var f: Int = 0
        while (f < 10) {
            var grid: [[String]] = (clearGrid() as! [[String]])
            var rot: [Point2] = ([] as! [Point2])
            var i: Int = 0
            var ay: Double = (Double((PI / 4.0)) + ((Double(f) * PI) / 10.0))
            while (i < Int(((nodes).count))) {
                let p = rotate((nodes[i] as! Point3), Double((PI / 4.0)), Double(ay))
                let pp = project((p as! Point3))
                rot = (_append(rot, pp) as! [Point2])
                i = Int((i + 1))
            }
            var e: Int = 0
            while (e < Int(((edges).count))) {
                let a = (edges[e][0] as! Int)
                let b = (edges[e][1] as! Int)
                var p1 = (rot[a] as! Point2)
                let p2 = (rot[b] as! Point2)
                _ = bresenham(Int(p1.x), Int(p1.y), Int(p2.x), Int(p2.y), &grid, "#")
                e = Int((e + 1))
            }
            print(_p(String(describing: render((grid as! [[String]])))))
            f = Int((f + 1))
        }
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
