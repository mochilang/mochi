// Generated by Mochi transpiler v0.10.39 on 2025-07-24 13:20:06 GMT+7
import Foundation

func bigTrim(_ a: [Int]) -> [Int] {
    var a = a
    var n = Int((((a as! [Int])).count))
    while ((Int(n) > 1) && (Int(a[(Int(n) - 1)]) == 0)) {
        a = (Array(a[0..<(Int(n) - 1)]) as! [Int])
        n = ((Int(n) - 1) as! Int)
    }
    return (a as! [Int])
}
func bigFromInt(_ x: Int) -> [Int] {
    var x = x
    if (Int(x) == 0) {
        return ([0] as! [Int])
    }
    var digits: [Int] = ([] as! [Int])
    var n = Int(x)
    while (Int(n) > 0) {
        digits = (((digits as! [Int]) + [(Int(n) % 10)]) as! [Int])
        n = ((Int(n) / 10) as! Int)
    }
    return (digits as! [Int])
}
func bigCmp(_ a: [Int], _ b: [Int]) -> Int {
    var a = a
    var b = b
    if (Int((((a as! [Int])).count)) > Int((((b as! [Int])).count))) {
        return 1
    }
    if (Int((((a as! [Int])).count)) < Int((((b as! [Int])).count))) {
        return (-1 as! Int)
    }
    var i = ((Int((((a as! [Int])).count)) - 1) as! Int)
    while (Int(i) >= 0) {
        if (Int(a[Int(i)]) > Int(b[Int(i)])) {
            return 1
        }
        if (Int(a[Int(i)]) < Int(b[Int(i)])) {
            return (-1 as! Int)
        }
        i = ((Int(i) - 1) as! Int)
    }
    return 0
}
func bigAdd(_ a: [Int], _ b: [Int]) -> [Int] {
    var a = a
    var b = b
    var res: [Int] = ([] as! [Int])
    var carry = 0
    var i = 0
    while (((Int(i) < Int((((a as! [Int])).count))) || (Int(i) < Int((((b as! [Int])).count)))) || (Int(carry) > 0)) {
        var av = 0
        if (Int(i) < Int((((a as! [Int])).count))) {
            av = Int(a[Int(i)])
        }
        var bv = 0
        if (Int(i) < Int((((b as! [Int])).count))) {
            bv = Int(b[Int(i)])
        }
        var s = (((Int(av) + Int(bv)) + Int(carry)) as! Int)
        res = (((res as! [Int]) + [(Int(s) % 10)]) as! [Int])
        carry = ((Int(s) / 10) as! Int)
        i = ((Int(i) + 1) as! Int)
    }
    return (bigTrim((res as! [Int])) as! [Int])
}
func bigSub(_ a: [Int], _ b: [Int]) -> [Int] {
    var a = a
    var b = b
    var res: [Int] = ([] as! [Int])
    var borrow = 0
    var i = 0
    while (Int(i) < Int((((a as! [Int])).count))) {
        var av = Int(a[Int(i)])
        var bv = 0
        if (Int(i) < Int((((b as! [Int])).count))) {
            bv = Int(b[Int(i)])
        }
        var diff = (((Int(av) - Int(bv)) - Int(borrow)) as! Int)
        if (Int(diff) < 0) {
            diff = ((Int(diff) + 10) as! Int)
            borrow = 1
        } else {
            borrow = 0
        }
        res = (((res as! [Int]) + [Int(diff)]) as! [Int])
        i = ((Int(i) + 1) as! Int)
    }
    return (bigTrim((res as! [Int])) as! [Int])
}
func bigMulSmall(_ a: [Int], _ m: Int) -> [Int] {
    var a = a
    var m = m
    if (Int(m) == 0) {
        return ([0] as! [Int])
    }
    var res: [Int] = ([] as! [Int])
    var carry = 0
    var i = 0
    while (Int(i) < Int((((a as! [Int])).count))) {
        var prod = (((Int(a[Int(i)]) * Int(m)) + Int(carry)) as! Int)
        res = (((res as! [Int]) + [(Int(prod) % 10)]) as! [Int])
        carry = ((Int(prod) / 10) as! Int)
        i = ((Int(i) + 1) as! Int)
    }
    while (Int(carry) > 0) {
        res = (((res as! [Int]) + [(Int(carry) % 10)]) as! [Int])
        carry = ((Int(carry) / 10) as! Int)
    }
    return (bigTrim((res as! [Int])) as! [Int])
}
func bigMulBig(_ a: [Int], _ b: [Int]) -> [Int] {
    var a = a
    var b = b
    var res: [Int] = ([] as! [Int])
    var i = 0
    while (Int(i) < (Int((((a as! [Int])).count)) + Int((((b as! [Int])).count)))) {
        res = (((res as! [Int]) + [0]) as! [Int])
        i = ((Int(i) + 1) as! Int)
    }
    i = 0
    while (Int(i) < Int((((a as! [Int])).count))) {
        var carry = 0
        var j = 0
        while (Int(j) < Int((((b as! [Int])).count))) {
            var idx = ((Int(i) + Int(j)) as! Int)
            var prod = (((Int(res[Int(idx)]) + (Int(a[Int(i)]) * Int(b[Int(j)]))) + Int(carry)) as! Int)
            res[Int(idx)] = ((Int(prod) % 10) as! Int)
            carry = ((Int(prod) / 10) as! Int)
            j = ((Int(j) + 1) as! Int)
        }
        var idx = ((Int(i) + Int((((b as! [Int])).count))) as! Int)
        while (Int(carry) > 0) {
            var prod = ((Int(res[Int(idx)]) + Int(carry)) as! Int)
            res[Int(idx)] = ((Int(prod) % 10) as! Int)
            carry = ((Int(prod) / 10) as! Int)
            idx = ((Int(idx) + 1) as! Int)
        }
        i = ((Int(i) + 1) as! Int)
    }
    return (bigTrim((res as! [Int])) as! [Int])
}
func bigMulPow10(_ a: [Int], _ k: Int) -> [Int] {
    var a = a
    var k = k
    var i = 0
    while (Int(i) < Int(k)) {
        a = ((([0] as! [Int]) + (a as! [Int])) as! [Int])
        i = ((Int(i) + 1) as! Int)
    }
    return (a as! [Int])
}
func bigDivSmall(_ a: [Int], _ m: Int) -> [Int] {
    var a = a
    var m = m
    var res: [Int] = ([] as! [Int])
    var rem = 0
    var i = ((Int((((a as! [Int])).count)) - 1) as! Int)
    while (Int(i) >= 0) {
        var cur = (((Int(rem) * 10) + Int(a[Int(i)])) as! Int)
        var q = ((Int(cur) / Int(m)) as! Int)
        rem = ((Int(cur) % Int(m)) as! Int)
        res = ((([Int(q)] as! [Int]) + (res as! [Int])) as! [Int])
        i = ((Int(i) - 1) as! Int)
    }
    return (bigTrim((res as! [Int])) as! [Int])
}
func bigToString(_ a: [Int]) -> String {
    var a = a
    var s = ""
    var i = ((Int((((a as! [Int])).count)) - 1) as! Int)
    while (Int(i) >= 0) {
        s = ((String(s) + String(String(describing: Int(a[Int(i)])))) as! String)
        i = ((Int(i) - 1) as! Int)
    }
    return String(s)
}
func repeat(_ ch: String, _ n: Int) -> String {
    var ch = ch
    var n = n
    var s = ""
    var i = 0
    while (Int(i) < Int(n)) {
        s = ((String(s) + String(ch)) as! String)
        i = ((Int(i) + 1) as! Int)
    }
    return String(s)
}
func sortInts(_ xs: [Int]) -> [Int] {
    var xs = xs
    var res: [Int] = ([] as! [Int])
    var tmp = (xs as! [Int])
    while (Int((((tmp as! [Int])).count)) > 0) {
        var min = Int(tmp[0])
        var idx = 0
        var i = 1
        while (Int(i) < Int((((tmp as! [Int])).count))) {
            if (Int(tmp[Int(i)]) < Int(min)) {
                min = Int(tmp[Int(i)])
                idx = Int(i)
            }
            i = ((Int(i) + 1) as! Int)
        }
        res = (((res as! [Int]) + ([Int(min)] as! [Int])) as! [Int])
        var out: [Int] = ([] as! [Int])
        var j = 0
        while (Int(j) < Int((((tmp as! [Int])).count))) {
            if (Int(j) != Int(idx)) {
                out = (((out as! [Int]) + ([Int(tmp[Int(j)])] as! [Int])) as! [Int])
            }
            j = ((Int(j) + 1) as! Int)
        }
        tmp = (out as! [Int])
    }
    return (res as! [Int])
}
func primesUpTo(_ n: Int) -> [Int] {
    var n = n
    var sieve: [Bool] = ([] as! [Bool])
    var i = 0
    while (Int(i) <= Int(n)) {
        sieve = (((sieve as! [Bool]) + [true]) as! [Bool])
        i = ((Int(i) + 1) as! Int)
    }
    var p = 2
    while ((Int(p) * Int(p)) <= Int(n)) {
        if (sieve[Int(p)] as! Bool) {
            var m = ((Int(p) * Int(p)) as! Int)
            while (Int(m) <= Int(n)) {
                sieve[Int(m)] = false
                m = ((Int(m) + Int(p)) as! Int)
            }
        }
        p = ((Int(p) + 1) as! Int)
    }
    var res: [Int] = ([] as! [Int])
    var x = 2
    while (Int(x) <= Int(n)) {
        if (sieve[Int(x)] as! Bool) {
            res = (((res as! [Int]) + [Int(x)]) as! [Int])
        }
        x = ((Int(x) + 1) as! Int)
    }
    return (res as! [Int])
}
func factorialExp(_ n: Int, _ primes: [Int]) -> [String: Int] {
    var n = n
    var primes = primes
    var m: [String: Int] = ([] as [String: Any] as! [String: Int])
    for p in (primes as! [Int]) {
        if ((p as! Int) > Int(n)) {
            break
        }
        var t = Int(n)
        var e = 0
        while (Int(t) > 0) {
            t = ((Int(t) / (p as! Int)) as! Int)
            e = ((Int(e) + Int(t)) as! Int)
        }
        m[String(String(describing: p))] = Int(e)
    }
    return (m as! [String: Int])
}
func factorSmall(_ x: Int, _ primes: [Int]) -> [String: Int] {
    var x = x
    var primes = primes
    var f: [String: Int] = ([] as [String: Any] as! [String: Int])
    var n = Int(x)
    for p in (primes as! [Int]) {
        if (((p as! Int) * (p as! Int)) > Int(n)) {
            break
        }
        var c = 0
        while ((Int(n) % (p as! Int)) == 0) {
            c = ((Int(c) + 1) as! Int)
            n = ((Int(n) / (p as! Int)) as! Int)
        }
        if (Int(c) > 0) {
            f[String(String(describing: p))] = Int(c)
        }
    }
    if (Int(n) > 1) {
        f[String(String(describing: Int(n)))] = (((f["get"]!(String(String(describing: Int(n))), 0) as! Int) + 1) as! Int)
    }
    return (f as! [String: Int])
}
func computeIP(_ n: Int, _ primes: [Int]) -> [Int] {
    var n = n
    var primes = primes
    var exps = (factorialExp(((6 * Int(n)) as! Int), (primes as! [Int])) as! [String: Int])
    let fn = (factorialExp(Int(n), (primes as! [Int])) as! [String: Int])
    for k in (fn as! [String: Int]).keys.sorted() {
        exps[k] = (((exps["get"]!(k, 0) as! Int) - (6 * Int(fn[k]!))) as! Int)
    }
    exps["2"] = (((exps["get"]!("2", 0) as! Int) + 5) as! Int)
    let t2 = ((((532 * Int(n)) * Int(n)) + (126 * Int(n))) + 9)
    let ft2 = (factorSmall(Int(t2), (primes as! [Int])) as! [String: Int])
    for k in (ft2 as! [String: Int]).keys.sorted() {
        exps[k] = (((exps["get"]!(k, 0) as! Int) + Int(ft2[k]!)) as! Int)
    }
    exps["3"] = (((exps["get"]!("3", 0) as! Int) - 1) as! Int)
    var keys: [Int] = ([] as! [Int])
    for k in (exps as! [String: Int]).keys.sorted() {
        keys = (((keys as! [Int]) + [Int(k)!]) as! [Int])
    }
    keys = (sortInts((keys as! [Int])) as! [Int])
    var res = (bigFromInt(1) as! [Int])
    for p in (keys as! [Int]) {
        var e = Int(exps[String(String(describing: p))]!)
        var i = 0
        while (Int(i) < Int(e)) {
            res = (bigMulSmall((res as! [Int]), (p as! Int)) as! [Int])
            i = ((Int(i) + 1) as! Int)
        }
    }
    return (res as! [Int])
}
func formatTerm(_ ip: [Int], _ pw: Int) -> String {
    var ip = ip
    var pw = pw
    var s = String(bigToString((ip as! [Int])))
    if (Int(pw) >= Int(((String(s)).count))) {
        var frac = ((String(repeat("0", ((Int(pw) - Int(((String(s)).count))) as! Int))) + String(s)) as! String)
        if (Int(((String(frac)).count)) < 33) {
            frac = ((String(frac) + String(repeat("0", ((33 - Int(((String(frac)).count))) as! Int)))) as! String)
        }
        return (("0." + String(String(Array(String(frac))[0..<33]))) as! String)
    }
    var intpart = String(String(Array(String(s))[0..<((Int(((String(s)).count)) - Int(pw)) as! Int)]))
    var frac = String(String(Array(String(s))[((Int(((String(s)).count)) - Int(pw)) as! Int)..<Int(((String(s)).count))]))
    if (Int(((String(frac)).count)) < 33) {
        frac = ((String(frac) + String(repeat("0", ((33 - Int(((String(frac)).count))) as! Int)))) as! String)
    }
    return (((String(intpart) + ".") + String(String(Array(String(frac))[0..<33]))) as! String)
}
func bigAbsDiff(_ a: [Int], _ b: [Int]) -> [Int] {
    var a = a
    var b = b
    if (Int(bigCmp((a as! [Int]), (b as! [Int]))) >= 0) {
        return (bigSub((a as! [Int]), (b as! [Int])) as! [Int])
    }
    return (bigSub((b as! [Int]), (a as! [Int])) as! [Int])
}
func main() {
    let primes = (primesUpTo(2000) as! [Int])
    print("N                               Integer Portion  Pow  Nth Term (33 dp)")
    let line = String(repeat("-", 89))
    print(String(line))
    var sum = (bigFromInt(0) as! [Int])
    var prev = (bigFromInt(0) as! [Int])
    var denomPow = 0
    var n = 0
    while true {
        let ip = (computeIP(Int(n), (primes as! [Int])) as! [Int])
        let pw = ((6 * Int(n)) + 3)
        if (Int(pw) > Int(denomPow)) {
            sum = (bigMulPow10((sum as! [Int]), ((Int(pw) - Int(denomPow)) as! Int)) as! [Int])
            prev = (bigMulPow10((prev as! [Int]), ((Int(pw) - Int(denomPow)) as! Int)) as! [Int])
            denomPow = Int(pw)
        }
        if (Int(n) < 10) {
            let termStr = String(formatTerm((ip as! [Int]), Int(pw)))
            var ipStr = String(bigToString((ip as! [Int])))
            while (Int(((String(ipStr)).count)) < 44) {
                ipStr = ((" " + String(ipStr)) as! String)
            }
            var pwStr = String(String(describing: -Int(pw)))
            while (Int(((String(pwStr)).count)) < 3) {
                pwStr = ((" " + String(pwStr)) as! String)
            }
            var padTerm = String(termStr)
            while (Int(((String(padTerm)).count)) < 35) {
                padTerm = ((String(padTerm) + " ") as! String)
            }
            print(((((((String(String(describing: Int(n))) + "  ") + String(ipStr)) + "  ") + String(pwStr)) + "  ") + String(padTerm)))
        }
        sum = (bigAdd((sum as! [Int]), (ip as! [Int])) as! [Int])
        let diff = (bigAbsDiff((sum as! [Int]), (prev as! [Int])) as! [Int])
        if ((Int(denomPow) >= 70) && (Int(bigCmp((diff as! [Int]), (bigMulPow10((bigFromInt(1) as! [Int]), ((Int(denomPow) - 70) as! Int)) as! [Int]))) < 0)) {
            break
        }
        prev = (sum as! [Int])
        n = ((Int(n) + 1) as! Int)
    }
    let precision = 70
    let target = (bigMulPow10((bigFromInt(1) as! [Int]), ((Int(denomPow) + (2 * Int(precision))) as! Int)) as! [Int])
    var low = (bigFromInt(0) as! [Int])
    var high = (bigMulPow10((bigFromInt(1) as! [Int]), ((Int(precision) + 1) as! Int)) as! [Int])
    while (Int(bigCmp((low as! [Int]), (bigSub((high as! [Int]), (bigFromInt(1) as! [Int])) as! [Int]))) < 0) {
        var mid = (bigDivSmall((bigAdd((low as! [Int]), (high as! [Int])) as! [Int]), 2) as! [Int])
        var prod = (bigMulBig((bigMulBig((mid as! [Int]), (mid as! [Int])) as! [Int]), (sum as! [Int])) as! [Int])
        if (Int(bigCmp((prod as! [Int]), (target as! [Int]))) <= 0) {
            low = (mid as! [Int])
        } else {
            high = (bigSub((mid as! [Int]), (bigFromInt(1) as! [Int])) as! [Int])
        }
    }
    var piInt = (low as! [Int])
    var piStr = String(bigToString((piInt as! [Int])))
    if (Int(((String(piStr)).count)) <= Int(precision)) {
        piStr = ((String(repeat("0", (((Int(precision) - Int(((String(piStr)).count))) + 1) as! Int))) + String(piStr)) as! String)
    }
    var out = (((String(String(Array(String(piStr))[0..<((Int(((String(piStr)).count)) - Int(precision)) as! Int)])) + ".") + String(String(Array(String(piStr))[((Int(((String(piStr)).count)) - Int(precision)) as! Int)..<Int(((String(piStr)).count))]))) as! String)
    print("")
    print("Pi to 70 decimal places is:")
    print(String(out))
}
main()
