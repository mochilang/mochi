// Generated by Mochi transpiler v0.10.40 on 2025-07-26 00:33:52 GMT+7
import Foundation

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _int(_ v: Any) -> Int {
    if let s = v as? String { return Int(s) ?? 0 }
    if let i = v as? Int { return i }
    if let i = v as? Int64 { return Int(i) }
    if let d = v as? Double { return Int(d) }
    return 0
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    func bigTrim(_ a: inout [Int]) -> [Int] {
        var n = Int(((a).count))
        while ((n > 1) && (Int(a[(n - 1)]) == 0)) {
            a = (Array(a[0..<(n - 1)]) as! [Int])
            n = ((n - 1) as! Int)
        }
        return (a as! [Int])
    }
    func bigFromInt(_ x: Int) -> [Int] {
        if (x == 0) {
            return ([0] as! [Int])
        }
        var digits: [Int] = ([] as! [Int])
        var n = (x as! Int)
        while (n > 0) {
            digits = ((digits + [(n % 10)]) as! [Int])
            n = ((n / 10) as! Int)
        }
        return (digits as! [Int])
    }
    func bigCmp(_ a: [Int], _ b: [Int]) -> Int {
        if (Int(((a).count)) > Int(((b).count))) {
            return 1
        }
        if (Int(((a).count)) < Int(((b).count))) {
            return (-1 as! Int)
        }
        var i = ((Int(((a).count)) - 1) as! Int)
        while (i >= 0) {
            if (Int(a[i]) > Int(b[i])) {
                return 1
            }
            if (Int(a[i]) < Int(b[i])) {
                return (-1 as! Int)
            }
            i = ((i - 1) as! Int)
        }
        return 0
    }
    func bigAdd(_ a: [Int], _ b: [Int]) -> [Int] {
        var res: [Int] = ([] as! [Int])
        var carry = 0
        var i = 0
        while (((i < Int(((a).count))) || (i < Int(((b).count)))) || (carry > 0)) {
            var av = 0
            if (i < Int(((a).count))) {
                av = Int(a[i])
            }
            var bv = 0
            if (i < Int(((b).count))) {
                bv = Int(b[i])
            }
            var s = (((av + bv) + carry) as! Int)
            res = ((res + [(s % 10)]) as! [Int])
            carry = ((s / 10) as! Int)
            i = ((i + 1) as! Int)
        }
        return (bigTrim(&res) as! [Int])
    }
    func bigSub(_ a: [Int], _ b: [Int]) -> [Int] {
        var res: [Int] = ([] as! [Int])
        var borrow = 0
        var i = 0
        while (i < Int(((a).count))) {
            var av = Int(a[i])
            var bv = 0
            if (i < Int(((b).count))) {
                bv = Int(b[i])
            }
            var diff = (((av - bv) - borrow) as! Int)
            if (diff < 0) {
                diff = ((diff + 10) as! Int)
                borrow = 1
            } else {
                borrow = 0
            }
            res = ((res + [diff]) as! [Int])
            i = ((i + 1) as! Int)
        }
        return (bigTrim(&res) as! [Int])
    }
    func bigMulSmall(_ a: [Int], _ m: Int) -> [Int] {
        if (m == 0) {
            return ([0] as! [Int])
        }
        var res: [Int] = ([] as! [Int])
        var carry = 0
        var i = 0
        while (i < Int(((a).count))) {
            var prod = (((Int(a[i]) * m) + carry) as! Int)
            res = ((res + [(prod % 10)]) as! [Int])
            carry = ((prod / 10) as! Int)
            i = ((i + 1) as! Int)
        }
        while (carry > 0) {
            res = ((res + [(carry % 10)]) as! [Int])
            carry = ((carry / 10) as! Int)
        }
        return (bigTrim(&res) as! [Int])
    }
    func bigMulBig(_ a: [Int], _ b: [Int]) -> [Int] {
        var res: [Int] = ([] as! [Int])
        var i = 0
        while (i < (Int(((a).count)) + Int(((b).count)))) {
            res = ((res + [0]) as! [Int])
            i = ((i + 1) as! Int)
        }
        i = 0
        while (i < Int(((a).count))) {
            var carry = 0
            var j = 0
            while (j < Int(((b).count))) {
                var idx = ((i + j) as! Int)
                var prod = (((Int(res[idx]) + (Int(a[i]) * Int(b[j]))) + carry) as! Int)
                res[idx] = ((prod % 10) as! Int)
                carry = ((prod / 10) as! Int)
                j = ((j + 1) as! Int)
            }
            var idx = ((i + Int(((b).count))) as! Int)
            while (carry > 0) {
                var prod = ((Int(res[idx]) + carry) as! Int)
                res[idx] = ((prod % 10) as! Int)
                carry = ((prod / 10) as! Int)
                idx = ((idx + 1) as! Int)
            }
            i = ((i + 1) as! Int)
        }
        return (bigTrim(&res) as! [Int])
    }
    func bigMulPow10(_ a: inout [Int], _ k: Int) -> [Int] {
        var i = 0
        while (i < k) {
            a = ((([0] as! [Int]) + a) as! [Int])
            i = ((i + 1) as! Int)
        }
        return (a as! [Int])
    }
    func bigDivSmall(_ a: [Int], _ m: Int) -> [Int] {
        var res: [Int] = ([] as! [Int])
        var rem = 0
        var i = ((Int(((a).count)) - 1) as! Int)
        while (i >= 0) {
            var cur = (((rem * 10) + Int(a[i])) as! Int)
            var q = ((cur / m) as! Int)
            rem = ((cur % m) as! Int)
            res = ((([q] as! [Int]) + res) as! [Int])
            i = ((i - 1) as! Int)
        }
        return (bigTrim(&res) as! [Int])
    }
    func bigToString(_ a: [Int]) -> String {
        var s = ""
        var i = ((Int(((a).count)) - 1) as! Int)
        while (i >= 0) {
            s = ((s + String(describing: Int(a[i]))) as! String)
            i = ((i - 1) as! Int)
        }
        return (s as! String)
    }
    func `repeat`(_ ch: String, _ n: Int) -> String {
        var s = ""
        var i = 0
        while (i < n) {
            s = ((s + ch) as! String)
            i = ((i + 1) as! Int)
        }
        return (s as! String)
    }
    func sortInts(_ xs: [Int]) -> [Int] {
        var res: [Int] = ([] as! [Int])
        var tmp = (xs as! [Int])
        while (Int(((tmp).count)) > 0) {
            var min = Int(tmp[0])
            var idx = 0
            var i = 1
            while (i < Int(((tmp).count))) {
                if (Int(tmp[i]) < min) {
                    min = Int(tmp[i])
                    idx = (i as! Int)
                }
                i = ((i + 1) as! Int)
            }
            res = ((res + ([min] as! [Int])) as! [Int])
            var out: [Int] = ([] as! [Int])
            var j = 0
            while (j < Int(((tmp).count))) {
                if (j != idx) {
                    out = ((out + ([Int(tmp[j])] as! [Int])) as! [Int])
                }
                j = ((j + 1) as! Int)
            }
            tmp = (out as! [Int])
        }
        return (res as! [Int])
    }
    func primesUpTo(_ n: Int) -> [Int] {
        var sieve: [Bool] = ([] as! [Bool])
        var i = 0
        while (i <= n) {
            sieve = ((sieve + [true]) as! [Bool])
            i = ((i + 1) as! Int)
        }
        var p = 2
        while ((p * p) <= n) {
            if (sieve[p] as! Bool) {
                var m = ((p * p) as! Int)
                while (m <= n) {
                    sieve[m] = false
                    m = ((m + p) as! Int)
                }
            }
            p = ((p + 1) as! Int)
        }
        var res: [Int] = ([] as! [Int])
        var x = 2
        while (x <= n) {
            if (sieve[x] as! Bool) {
                res = ((res + [x]) as! [Int])
            }
            x = ((x + 1) as! Int)
        }
        return (res as! [Int])
    }
    func factorialExp(_ n: Int, _ primes: [Int]) -> [String: Int] {
        var m: [String: Int] = ([:] as! [String: Int])
        for p in primes {
            if (p > n) {
                break
            }
            var t = (n as! Int)
            var e = 0
            while (t > 0) {
                t = ((t / p) as! Int)
                e = ((e + t) as! Int)
            }
            m[String(describing: p)] = (e as! Int)
        }
        return (m as! [String: Int])
    }
    func factorSmall(_ x: Int, _ primes: [Int]) -> [String: Int] {
        var f: [String: Int] = ([:] as! [String: Int])
        var n = (x as! Int)
        for p in primes {
            if ((p * p) > n) {
                break
            }
            var c = 0
            while ((n % p) == 0) {
                c = ((c + 1) as! Int)
                n = ((n / p) as! Int)
            }
            if (c > 0) {
                f[String(describing: p)] = (c as! Int)
            }
        }
        if (n > 1) {
            f[String(describing: n)] = (((f[String(describing: n)] ?? 0 as! Int) + 1) as! Int)
        }
        return (f as! [String: Int])
    }
    func computeIP(_ n: Int, _ primes: [Int]) -> [Int] {
        var exps = (factorialExp(((6 * n) as! Int), (primes as! [Int])) as! [String: Int])
        let fn = (factorialExp((n as! Int), (primes as! [Int])) as! [String: Int])
        for k in fn.keys.sorted() {
            exps[k] = (((exps[k] ?? 0 as! Int) - (6 * Int(fn[k]!))) as! Int)
        }
        exps["2"] = (((exps["2"] ?? 0 as! Int) + 5) as! Int)
        let t2 = ((((532 * n) * n) + (126 * n)) + 9)
        let ft2 = (factorSmall((t2 as! Int), (primes as! [Int])) as! [String: Int])
        for k in ft2.keys.sorted() {
            exps[k] = (((exps[k] ?? 0 as! Int) + Int(ft2[k]!)) as! Int)
        }
        exps["3"] = (((exps["3"] ?? 0 as! Int) - 1) as! Int)
        var keys: [Int] = ([] as! [Int])
        for k in exps.keys.sorted() {
            keys = ((keys + [Int(_int(k))]) as! [Int])
        }
        keys = (sortInts((keys as! [Int])) as! [Int])
        var res = (bigFromInt(1) as! [Int])
        for p in keys {
            var e = Int(exps[String(describing: p)]!)
            var i = 0
            while (i < e) {
                res = (bigMulSmall((res as! [Int]), (p as! Int)) as! [Int])
                i = ((i + 1) as! Int)
            }
        }
        return (res as! [Int])
    }
    func formatTerm(_ ip: [Int], _ pw: Int) -> String {
        var s = String(describing: bigToString((ip as! [Int])))
        if (pw >= Int(((s).count))) {
            var frac = ((String(describing: `repeat`("0", ((pw - Int(((s).count))) as! Int))) + s) as! String)
            if (Int(((frac).count)) < 33) {
                frac = ((frac + String(describing: `repeat`("0", ((33 - Int(((frac).count))) as! Int)))) as! String)
            }
            return (("0." + String(describing: String(Array((frac as! String))[0..<33]))) as! String)
        }
        var intpart = String(describing: String(Array((s as! String))[0..<((Int(((s).count)) - pw) as! Int)]))
        var frac = String(describing: String(Array((s as! String))[((Int(((s).count)) - pw) as! Int)..<Int(((s).count))]))
        if (Int(((frac).count)) < 33) {
            frac = ((frac + String(describing: `repeat`("0", ((33 - Int(((frac).count))) as! Int)))) as! String)
        }
        return (((intpart + ".") + String(describing: String(Array((frac as! String))[0..<33]))) as! String)
    }
    func bigAbsDiff(_ a: [Int], _ b: [Int]) -> [Int] {
        if (Int(bigCmp((a as! [Int]), (b as! [Int]))) >= 0) {
            return (bigSub((a as! [Int]), (b as! [Int])) as! [Int])
        }
        return (bigSub((b as! [Int]), (a as! [Int])) as! [Int])
    }
    func main() {
        let primes = (primesUpTo(2000) as! [Int])
        print("N                               Integer Portion  Pow  Nth Term (33 dp)")
        let line = String(describing: `repeat`("-", 89))
        print(line)
        var sum = (bigFromInt(0) as! [Int])
        var prev = (bigFromInt(0) as! [Int])
        var denomPow = 0
        var n = 0
        while true {
            let ip = (computeIP((n as! Int), (primes as! [Int])) as! [Int])
            let pw = ((6 * n) + 3)
            if (pw > denomPow) {
                sum = (bigMulPow10(&sum, ((pw - denomPow) as! Int)) as! [Int])
                prev = (bigMulPow10(&prev, ((pw - denomPow) as! Int)) as! [Int])
                denomPow = (pw as! Int)
            }
            if (n < 10) {
                let termStr = String(describing: formatTerm((ip as! [Int]), (pw as! Int)))
                var ipStr = String(describing: bigToString((ip as! [Int])))
                while (Int(((ipStr).count)) < 44) {
                    ipStr = ((" " + ipStr) as! String)
                }
                var pwStr = String(describing: -pw)
                while (Int(((pwStr).count)) < 3) {
                    pwStr = ((" " + pwStr) as! String)
                }
                var padTerm = (termStr as! String)
                while (Int(((padTerm).count)) < 35) {
                    padTerm = ((padTerm + " ") as! String)
                }
                print(((((((String(describing: n) + "  ") + ipStr) + "  ") + pwStr) + "  ") + padTerm))
            }
            sum = (bigAdd((sum as! [Int]), (ip as! [Int])) as! [Int])
            let diff = (bigAbsDiff((sum as! [Int]), (prev as! [Int])) as! [Int])
            if ((denomPow >= 70) && (Int(bigCmp((diff as! [Int]), ({ () -> Any in
            var _tmp0 = bigFromInt(1)
            return bigMulPow10(&_tmp0, ((denomPow - 70) as! Int))
        }() as! [Int]))) < 0)) {
            break
        }
        prev = (sum as! [Int])
        n = ((n + 1) as! Int)
    }
    let precision = 70
    let target = ({ () -> Any in
    var _tmp0 = bigFromInt(1)
    return bigMulPow10(&_tmp0, ((denomPow + (2 * precision)) as! Int))
}() as! [Int])
var low = (bigFromInt(0) as! [Int])
var high = ({ () -> Any in
var _tmp0 = bigFromInt(1)
return bigMulPow10(&_tmp0, ((precision + 1) as! Int))
}() as! [Int])
while (Int(bigCmp((low as! [Int]), (bigSub((high as! [Int]), (bigFromInt(1) as! [Int])) as! [Int]))) < 0) {
    var mid = (bigDivSmall((bigAdd((low as! [Int]), (high as! [Int])) as! [Int]), 2) as! [Int])
    var prod = (bigMulBig((bigMulBig((mid as! [Int]), (mid as! [Int])) as! [Int]), (sum as! [Int])) as! [Int])
    if (Int(bigCmp((prod as! [Int]), (target as! [Int]))) <= 0) {
        low = (mid as! [Int])
    } else {
        high = (bigSub((mid as! [Int]), (bigFromInt(1) as! [Int])) as! [Int])
    }
}
var piInt = (low as! [Int])
var piStr = String(describing: bigToString((piInt as! [Int])))
if (Int(((piStr).count)) <= precision) {
    piStr = ((String(describing: `repeat`("0", (((precision - Int(((piStr).count))) + 1) as! Int))) + piStr) as! String)
}
var out = (((String(describing: String(Array((piStr as! String))[0..<((Int(((piStr).count)) - precision) as! Int)])) + ".") + String(describing: String(Array((piStr as! String))[((Int(((piStr).count)) - precision) as! Int)..<Int(((piStr).count))]))) as! String)
print("")
print("Pi to 70 decimal places is:")
print(out)
}
_ = main()
let _benchEnd = _now()
let _benchMemEnd = _mem()
print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
