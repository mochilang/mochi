// Generated by Mochi transpiler v0.10.40 on 2025-07-25 10:51:08 GMT+7
import Foundation

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    var board = ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0] as! [Int])
    let solved = ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0] as! [Int])
    var empty = 15
    var moves = 0
    var quit = false
    func randMove() -> Int {
        return ((Int(_now()) % 4) as! Int)
    }
    func isSolved() -> Bool {
        var i = 0
        while (i < 16) {
            if (Int(board[i]) != Int(solved[i])) {
                return false
            }
            i = ((i + 1) as! Int)
        }
        return true
    }
    struct MoveResult {
        var idx: Int
        var ok: Bool
    }
    func isValidMove(_ m: Int) -> MoveResult {
        if (m == 0) {
            return (MoveResult(idx: (empty - 4), ok: ((empty / 4) > 0)) as! MoveResult)
        }
        if (m == 1) {
            return (MoveResult(idx: (empty + 4), ok: ((empty / 4) < 3)) as! MoveResult)
        }
        if (m == 2) {
            return (MoveResult(idx: (empty + 1), ok: ((empty % 4) < 3)) as! MoveResult)
        }
        if (m == 3) {
            return (MoveResult(idx: (empty - 1), ok: ((empty % 4) > 0)) as! MoveResult)
        }
        return (MoveResult(idx: 0, ok: false) as! MoveResult)
    }
    func doMove(_ m: Int) -> Bool {
        let r = isValidMove((m as! Int))
        if (!r.ok) {
            return false
        }
        let i = empty
        let j = r.idx
        let tmp = Int(board[i])
        board[i] = Int(board[j])
        board[j] = (tmp as! Int)
        empty = (j as! Int)
        moves = ((moves + 1) as! Int)
        return true
    }
    func shuffle(_ n: Int) {
        var i = 0
        while ((i < n) || Bool(isSolved())) {
            if Bool(doMove(Int(randMove()))) {
                i = ((i + 1) as! Int)
            }
        }
    }
    func printBoard() {
        var line = ""
        var i = 0
        while (i < 16) {
            let val = Int(board[i])
            if (val == 0) {
                line = ((line + "  .") as! String)
            } else {
                let s = String(describing: val)
                if (val < 10) {
                    line = (((line + "  ") + s) as! String)
                } else {
                    line = (((line + " ") + s) as! String)
                }
            }
            if ((i % 4) == 3) {
                print(line)
                line = ""
            }
            i = ((i + 1) as! Int)
        }
    }
    func playOneMove() {
        while true {
            print((("Enter move #" + String(describing: (moves + 1))) + " (U, D, L, R, or Q): "))
            let s = (readLine() ?? "")
            if (s == "") {
                continue
            }
            let c = String(Array(s)[0..<1])
            var m = 0
            if ((c == "U") || (c == "u")) {
                m = 0
            } else if ((c == "D") || (c == "d")) {
                m = 1
            } else if ((c == "R") || (c == "r")) {
                m = 2
            } else if ((c == "L") || (c == "l")) {
                m = 3
            } else if ((c == "Q") || (c == "q")) {
                print((("Quiting after " + String(describing: moves)) + " moves."))
                quit = true
                return
            } else {
                print(((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" + "up, down, left, or right. You can also enter \"Q\" to quit.\n") + "Upper or lowercase is accepted and only the first non-blank\n") + "character is important (i.e. you may enter \"up\" if you like)."))
                continue
            }
            
            
            
            
            if (!Bool(doMove((m as! Int)))) {
                print("That is not a valid move at the moment.")
                continue
            }
            return
        }
    }
    func play() {
        print("Starting board:")
        while ((!quit) && (Bool(isSolved()) == false)) {
            print("")
            _ = printBoard()
            _ = playOneMove()
        }
        if Bool(isSolved()) {
            print((("You solved the puzzle in " + String(describing: moves)) + " moves."))
        }
    }
    func main() {
        _ = shuffle(50)
        _ = play()
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
