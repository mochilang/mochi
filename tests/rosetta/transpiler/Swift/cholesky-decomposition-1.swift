// Generated by Mochi transpiler v0.10.47 on 2025-07-28 11:55:44 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
func _len(_ v: Any) -> Int {
    if let s = v as? String { return Array(s).count }
    if let a = v as? [Any] { return a.count }
    if let a = v as? [Double] { return a.count }
    if let a = v as? [Int] { return a.count }
    if let m = v as? [AnyHashable: Any] { return m.count }
    return 0
}
func sqrtApprox(_ x: Double) -> Double {
    var guess: Double = x
    var i: Int = 0
    while (i < 20) {
        guess = ((Double((guess + (x / guess))) / 2.0) as! Double)
        i = ((i + 1) as! Int)
    }
    return (guess as! Double)
}
func makeSym(_ order: Int, _ elements: [Double]) -> [String: Any] {
    return (["order": order, "ele": elements] as! [String: Any])
}
func unpackSym(_ m: [String: Any]) -> [[Double]] {
    let n = m["order"]!
    let ele = m["ele"]!
    var mat: [[Double]] = ([] as! [[Double]])
    var idx: Int = 0
    var r: Int = 0
    while (r < (n as! Int)) {
        var row: [Double] = ([] as! [Double])
        var c: Int = 0
        while (c <= r) {
            row = ((_append(row, ((ele as! [Any])[idx] as! Any)) as! [Any]) as! [Double])
            idx = ((idx + 1) as! Int)
            c = ((c + 1) as! Int)
        }
        while (c < (n as! Int)) {
            row = (_append(row, 0.0) as! [Double])
            c = ((c + 1) as! Int)
        }
        mat = (_append(mat, row) as! [[Double]])
        r = ((r + 1) as! Int)
    }
    r = 0
    while (r < (n as! Int)) {
        var c: Int = (r + 1)
        while (c < (n as! Int)) {
            mat[r][c] = (mat[c][r] as! Double)
            c = ((c + 1) as! Int)
        }
        r = ((r + 1) as! Int)
    }
    return (mat as! [[Double]])
}
func printMat(_ m: [[Double]]) {
    var i: Int = 0
    while (i < Int(((m).count))) {
        var line: String = ""
        var j: Int = 0
        while (j < Int((((m[i] as! [Double])).count))) {
            line = ((line + _p((m[i][j] as! Double))) as! String)
            if (j < (Int((((m[i] as! [Double])).count)) - 1)) {
                line = ((line + " ") as! String)
            }
            j = ((j + 1) as! Int)
        }
        print(_p(line))
        i = ((i + 1) as! Int)
    }
}
func printSym(_ m: [String: Any]) {
    _ = printMat((unpackSym((m as! [String: Any])) as! [[Double]]))
}
func printLower(_ m: [String: Any]) {
    let n = m["order"]!
    let ele = m["ele"]!
    var mat: [[Double]] = ([] as! [[Double]])
    var idx: Int = 0
    var r: Int = 0
    while (r < (n as! Int)) {
        var row: [Double] = ([] as! [Double])
        var c: Int = 0
        while (c <= r) {
            row = ((_append(row, ((ele as! [Any])[idx] as! Any)) as! [Any]) as! [Double])
            idx = ((idx + 1) as! Int)
            c = ((c + 1) as! Int)
        }
        while (c < (n as! Int)) {
            row = (_append(row, 0.0) as! [Double])
            c = ((c + 1) as! Int)
        }
        mat = (_append(mat, row) as! [[Double]])
        r = ((r + 1) as! Int)
    }
    _ = printMat((mat as! [[Double]]))
}
func choleskyLower(_ a: [String: Any]) -> [String: Any] {
    let n = a["order"]!
    let ae = a["ele"]!
    var le: [Double] = ([] as! [Double])
    var idx: Int = 0
    while (idx < Int(_len(ae))) {
        le = (_append(le, 0.0) as! [Double])
        idx = ((idx + 1) as! Int)
    }
    var row: Int = 1
    var col: Int = 1
    var dr: Int = 0
    var dc: Int = 0
    var i: Int = 0
    while (i < Int(_len(ae))) {
        let e = ((ae as! [Any])[i] as! Any)
        if (i < dr) {
            var d: Any = ((((e as! Double) - (le[i] as! Double)) as! Double) / (le[dc] as! Double))
            le[i] = (d as! Double)
            var ci: Int = col
            var cx: Int = dc
            var j: Int = (i + 1)
            while (j <= dr) {
                cx = ((cx + ci) as! Int)
                ci = ((ci + 1) as! Int)
                le[j] = (((le[j] as! Double) + ((d as! Double) * (le[cx] as! Double))) as! Double)
                j = ((j + 1) as! Int)
            }
            col = ((col + 1) as! Int)
            dc = ((dc + col) as! Int)
        } else {
            le[i] = Double(sqrtApprox((((e as! Double) - (le[i] as! Double)) as! Double)))
            row = ((row + 1) as! Int)
            dr = ((dr + row) as! Int)
            col = 1
            dc = 0
        }
        i = ((i + 1) as! Int)
    }
    return (["order": n, "ele": le] as! [String: Any])
}
func demo(_ a: [String: Any]) {
    print(_p("A:"))
    _ = printSym((a as! [String: Any]))
    print(_p("L:"))
    let l = (choleskyLower((a as! [String: Any])) as! [String: Any])
    _ = printLower((l as! [String: Any]))
}
_ = demo((makeSym(3, ([25.0, 15.0, 18.0, -5.0, 0.0, 11.0] as! [Double])) as! [String: Any]))
_ = demo((makeSym(4, ([18.0, 22.0, 70.0, 54.0, 86.0, 174.0, 42.0, 62.0, 134.0, 106.0] as! [Double])) as! [String: Any]))
