// Generated by Mochi transpiler v0.10.52 on 2025-08-01 22:16:54 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

struct Point {
    var x: Double
    var y: Double
}
func sqrtApprox(_ x: Double) -> Double {
    var g: Double = x
    var i: Int = 0
    while (i < 40) {
        g = Double((Double((g + (x / g))) / 2.0))
        i = ((i + 1) as! Int)
    }
    return g
}
func hypot(_ x: Double, _ y: Double) -> Double {
    return Double(sqrtApprox(Double(((x * x) + (y * y)))))
}
let Two = "Two circles."
let R0 = "R==0.0 does not describe circles."
let Co = "Coincident points describe an infinite number of circles."
let CoR0 = "Coincident points with r==0.0 describe a degenerate circle."
let Diam = "Points form a diameter and describe only a single circle."
let Far = "Points too far apart to form circles."
func circles(_ p1: Point, _ p2: Point, _ r: Double) -> [Any?] {
    if ((p1.x == p2.x) && (p1.y == p2.y)) {
        if (r == 0.0) {
            return [(p1 as! Any), (p1 as! Any), ("Coincident points with r==0.0 describe a degenerate circle." as! Any)]
        }
        return [(p1 as! Any), (p2 as! Any), ("Coincident points describe an infinite number of circles." as! Any)]
    }
    if (r == 0.0) {
        return [(p1 as! Any), (p2 as! Any), ("R==0.0 does not describe circles." as! Any)]
    }
    let dx = (p2.x - p1.x)
    let dy = (p2.y - p1.y)
    let q = Double(hypot((dx as! Double), (dy as! Double)))
    if (q > (2.0 * r)) {
        return [(p1 as! Any), (p2 as! Any), ("Points too far apart to form circles." as! Any)]
    }
    let m = Point(x: (Double((p1.x + p2.x)) / 2.0), y: (Double((p1.y + p2.y)) / 2.0))
    if (q == (2.0 * r)) {
        return [(m as! Any), (m as! Any), ("Points form a diameter and describe only a single circle." as! Any)]
    }
    let d = Double(sqrtApprox(Double(((r * r) - ((q * q) / 4.0)))))
    let ox = ((d * dx) / q)
    let oy = ((d * dy) / q)
    return [(Point(x: (m.x - oy), y: (m.y + ox)) as! Any), (Point(x: (m.x + oy), y: (m.y - ox)) as! Any), ("Two circles." as! Any)]
}
var td: [[Any?]] = ([([(Point(x: 0.1234, y: 0.9876) as! Any), (Point(x: 0.8765, y: 0.2345) as! Any), (2.0 as! Any)] as! Any), ([(Point(x: 0.0, y: 2.0) as! Any), (Point(x: 0.0, y: 0.0) as! Any), (1.0 as! Any)] as! Any), ([(Point(x: 0.1234, y: 0.9876) as! Any), (Point(x: 0.1234, y: 0.9876) as! Any), (2.0 as! Any)] as! Any), ([(Point(x: 0.1234, y: 0.9876) as! Any), (Point(x: 0.8765, y: 0.2345) as! Any), (0.5 as! Any)] as! Any), ([(Point(x: 0.1234, y: 0.9876) as! Any), (Point(x: 0.1234, y: 0.9876) as! Any), (0.0 as! Any)] as! Any)] as! [[Any?]])
for tc in td {
    let p1 = (tc[0] as! Any?)
    let p2 = (tc[1] as! Any?)
    let r = (tc[2] as! Any?)
    print(_p((((("p1:  {" + _p((p1 as! Point).x)) + " ") + _p((p1 as! Point).y)) + "}")))
    print(_p((((("p2:  {" + _p((p2 as! Point).x)) + " ") + _p((p2 as! Point).y)) + "}")))
    print(_p(("r:  " + _p(r))))
    let res: [Any?] = (circles((p1 as! Point), (p2 as! Point), (r as! Double)) as! [Any?])
    let c1 = (res[0] as! Any?)
    let c2 = (res[1] as! Any?)
    let caseStr = (res[2] as! Any?)
    print(_p(("   " + String(describing: caseStr))))
    if ((String(describing: caseStr) == "Points form a diameter and describe only a single circle.") || (String(describing: caseStr) == "Coincident points with r==0.0 describe a degenerate circle.")) {
        print(_p((((("   Center:  {" + _p((c1 as! Point).x)) + " ") + _p((c1 as! Point).y)) + "}")))
    } else {
        if (String(describing: caseStr) == "Two circles.") {
            print(_p((((("   Center 1:  {" + _p((c1 as! Point).x)) + " ") + _p((c1 as! Point).y)) + "}")))
            print(_p((((("   Center 2:  {" + _p((c2 as! Point).x)) + " ") + _p((c2 as! Point).y)) + "}")))
        }
    }
    print(_p(""))
}
