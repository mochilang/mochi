// Generated by Mochi transpiler v0.10.47 on 2025-07-28 12:11:20 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
func parseIntBase(_ s: String, _ base: Int) -> Int {
    let digits = "0123456789abcdefghijklmnopqrstuvwxyz"
    var n: Int = 0
    var i: Int = 0
    while (i < Int(((s).count))) {
        var j: Int = 0
        var v: Int = 0
        while (j < Int(((digits).count))) {
            if (String(describing: String(Array(String(describing: (digits as! String)))[(j as! Int)..<((j + 1) as! Int)])) == String(Array(s)[i..<(i + 1)])) {
                v = (j as! Int)
                break
            }
            j = ((j + 1) as! Int)
        }
        n = (((n * base) + v) as! Int)
        i = ((i + 1) as! Int)
    }
    return (n as! Int)
}
func intToBase(_ n: Int, _ base: Int) -> String {
    let digits = "0123456789abcdefghijklmnopqrstuvwxyz"
    if (n == 0) {
        return "0"
    }
    var out: String = ""
    var v: Int = n
    while (v > 0) {
        let d = (v % base)
        out = ((String(Array(digits)[d..<(d + 1)]) + out) as! String)
        v = ((v / base) as! Int)
    }
    return (out as! String)
}
func subset(_ base: Int, _ begin: String, _ end: String) -> [String] {
    var b: Int = Int(parseIntBase((begin as! String), (base as! Int)))
    var e: Int = Int(parseIntBase((end as! String), (base as! Int)))
    var out: [String] = ([] as! [String])
    var k: Int = b
    while (k <= e) {
        let ks = String(describing: intToBase((k as! Int), (base as! Int)))
        let mod = (base - 1)
        let r1 = (Int(parseIntBase((ks as! String), (base as! Int))) % mod)
        let r2 = (Int((Int(parseIntBase((ks as! String), (base as! Int))) * Int(parseIntBase((ks as! String), (base as! Int))))) % mod)
        if (r1 == r2) {
            out = (_append(out, ks) as! [String])
        }
        k = ((k + 1) as! Int)
    }
    return (out as! [String])
}
let testCases: [Any] = ([["base": 10, "begin": "1", "end": "100", "kaprekar": (["1", "9", "45", "55", "99"] as! [String])], ["base": 17, "begin": "10", "end": "gg", "kaprekar": (["3d", "d4", "gg"] as! [String])]] as! [Any])
var idx: Int = 0
while (idx < Int(((testCases).count))) {
    let tc = (testCases[idx] as! Any)
    print(_p((((((("\nTest case base = " + _p((tc["base"] as! Int))) + ", begin = ") + (tc["begin"] as! String)) + ", end = ") + (tc["end"] as! String)) + ":")))
    let s: [String] = (subset((tc["base"] as! Int), (tc["begin"] as! String), (tc["end"] as! String)) as! [String])
    print(_p(("Subset:  " + _p(s))))
    print(_p(("Kaprekar:" + _p((tc["kaprekar"] as! [String])))))
    var sx: Int = 0
    var valid: Bool = true
    var i: Int = 0
    while (i < Int((((tc["kaprekar"] as! [String])).count))) {
        let k = (tc["kaprekar"][i] as! String)
        var found: Bool = false
        while (sx < Int(((s).count))) {
            if ((s[sx] as! String) == k) {
                found = true
                sx = ((sx + 1) as! Int)
                break
            }
            sx = ((sx + 1) as! Int)
        }
        if (!found) {
            print(_p((("Fail:" + k) + " not in subset")))
            valid = false
            break
        }
        i = ((i + 1) as! Int)
    }
    if valid {
        print(_p("Valid subset."))
    }
    idx = ((idx + 1) as! Int)
}
