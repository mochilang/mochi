// Generated by Mochi transpiler v0.10.40 on 2025-07-26 05:27:23 GMT+7
import Foundation

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _int(_ v: Any) -> Int {
    if let s = v as? String { return Int(s) ?? 0 }
    if let i = v as? Int { return i }
    if let i = v as? Int64 { return Int(i) }
    if let d = v as? Double { return Int(d) }
    return 0
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
func _slice(_ s: String, _ start: Int, _ end: Int) -> String {
    let startIdx = s.index(s.startIndex, offsetBy: start)
    let endIdx = s.index(s.startIndex, offsetBy: end)
    return String(s[startIdx..<endIdx])
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    struct Parser {
        var expr: String
        var pos: Int
    }
    struct Res {
        var v: Int
        var p: Parser
    }
    func skipWS(_ p: inout Parser) -> Parser {
        var i = p.pos
        while ((i < _int(((p.expr).count))) && (String(describing: String(Array(String(describing: p.expr))[Int(i)..<Int((i + 1))])) == " ")) {
            i = Int((i + 1))
        }
        p.pos = Int(i)
        return (p as! Parser)
    }
    func parseIntStr(_ str: String) -> Int {
        var i = 0
        var n = 0
        while (i < _int(((str).count))) {
            n = Int((((n * 10) + _int(_slice(str, i, (i + 1)))) - 48))
            i = Int((i + 1))
        }
        return Int(n)
    }
    func parseNumber(_ p: inout Parser) -> Res {
        p = (skipWS(&p) as! Parser)
        var start = p.pos
        while (p.pos < _int(((p.expr).count))) {
            let ch = String(describing: String(Array(String(describing: p.expr))[Int(p.pos)..<Int((p.pos + 1))]))
            if ((ch >= "0") && (ch <= "9")) {
                p.pos = Int((p.pos + 1))
            } else {
                break
            }
        }
        let token = String(describing: String(Array(String(describing: p.expr))[Int(start)..<Int(p.pos)]))
        return (Res(v: _int(parseIntStr(String(describing: token))), p: p) as! Res)
    }
    func parseFactor(_ p: inout Parser) -> Res {
        p = (skipWS(&p) as! Parser)
        if ((p.pos < _int(((p.expr).count))) && (String(describing: String(Array(String(describing: p.expr))[Int(p.pos)..<Int((p.pos + 1))])) == "(")) {
            p.pos = Int((p.pos + 1))
            var r = parseExpr(&p)
            var v = r.v
            p = (r.p as! Parser)
            p = (skipWS(&p) as! Parser)
            if ((p.pos < _int(((p.expr).count))) && (String(describing: String(Array(String(describing: p.expr))[Int(p.pos)..<Int((p.pos + 1))])) == ")")) {
                p.pos = Int((p.pos + 1))
            }
            return (Res(v: v, p: p) as! Res)
        }
        if ((p.pos < _int(((p.expr).count))) && (String(describing: String(Array(String(describing: p.expr))[Int(p.pos)..<Int((p.pos + 1))])) == "-")) {
            p.pos = Int((p.pos + 1))
            var r = parseFactor(&p)
            var v = r.v
            p = (r.p as! Parser)
            return (Res(v: -v, p: p) as! Res)
        }
        return (parseNumber(&p) as! Res)
    }
    func powInt(_ base: Int, _ exp: Int) -> Int {
        var r = 1
        var b = base
        var e = exp
        while (e > 0) {
            if ((e % 2) == 1) {
                r = Int((r * b))
            }
            b = Int((b * b))
            e = Int((e / 2))
        }
        return Int(r)
    }
    func parsePower(_ p: inout Parser) -> Res {
        var r = parseFactor(&p)
        var v = r.v
        p = (r.p as! Parser)
        while true {
            p = (skipWS(&p) as! Parser)
            if ((p.pos < _int(((p.expr).count))) && (String(describing: String(Array(String(describing: p.expr))[Int(p.pos)..<Int((p.pos + 1))])) == "^")) {
                p.pos = Int((p.pos + 1))
                var r2 = parseFactor(&p)
                var rhs = r2.v
                p = (r2.p as! Parser)
                v = _int(powInt(Int(v), Int(rhs)))
            } else {
                break
            }
        }
        return (Res(v: v, p: p) as! Res)
    }
    func parseTerm(_ p: inout Parser) -> Res {
        var r = parsePower(&p)
        var v = r.v
        p = (r.p as! Parser)
        while true {
            p = (skipWS(&p) as! Parser)
            if (p.pos < _int(((p.expr).count))) {
                let op = String(describing: String(Array(String(describing: p.expr))[Int(p.pos)..<Int((p.pos + 1))]))
                if (op == "*") {
                    p.pos = Int((p.pos + 1))
                    var r2 = parsePower(&p)
                    var rhs = r2.v
                    p = (r2.p as! Parser)
                    v = Int((v * rhs))
                    continue
                }
                if (op == "/") {
                    p.pos = Int((p.pos + 1))
                    var r2 = parsePower(&p)
                    var rhs = r2.v
                    p = (r2.p as! Parser)
                    v = Int((v / _int(rhs)))
                    continue
                }
            }
            break
        }
        return (Res(v: v, p: p) as! Res)
    }
    func parseExpr(_ p: inout Parser) -> Res {
        var r = parseTerm(&p)
        var v = r.v
        p = (r.p as! Parser)
        while true {
            p = (skipWS(&p) as! Parser)
            if (p.pos < _int(((p.expr).count))) {
                let op = String(describing: String(Array(String(describing: p.expr))[Int(p.pos)..<Int((p.pos + 1))]))
                if (op == "+") {
                    p.pos = Int((p.pos + 1))
                    var r2 = parseTerm(&p)
                    var rhs = r2.v
                    p = (r2.p as! Parser)
                    v = Int((v + rhs))
                    continue
                }
                if (op == "-") {
                    p.pos = Int((p.pos + 1))
                    var r2 = parseTerm(&p)
                    var rhs = r2.v
                    p = (r2.p as! Parser)
                    v = Int((v - rhs))
                    continue
                }
            }
            break
        }
        return (Res(v: v, p: p) as! Res)
    }
    func evalExpr(_ expr: String) -> Int {
        var p = Parser(expr: expr, pos: 0)
        let r = parseExpr(&p)
        return Int(r.v)
    }
    func main() {
        let expr = "2*(3-1)+2*5"
        print(((expr + " = ") + String(describing: _int(evalExpr(String(describing: expr))))))
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
