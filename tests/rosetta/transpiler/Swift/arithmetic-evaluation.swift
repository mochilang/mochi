// Generated by Mochi transpiler v0.10.40 on 2025-07-26 05:32:19 GMT+7
import Foundation

func _int(_ v: Any) -> Int {
    if let s = v as? String {
        if s.count == 1 { return Int(s.unicodeScalars.first!.value) }
        return Int(s) ?? 0
    }
    if let i = v as? Int { return i }
    if let i = v as? Int64 { return Int(i) }
    if let d = v as? Double { return Int(d) }
    return 0
}
struct Parser {
    var expr: String
    var pos: Int
}
struct Res {
    var v: Int
    var p: Parser
}
func skipWS(_ p: inout Parser) -> Parser {
    var i = p.pos
    while ((i < ((p.expr).count)) && (String(Array((p.expr as! String))[(i as! Int)..<((i + 1) as! Int)]) == " ")) {
        i = ((i + 1) as! Int)
    }
    p.pos = (i as! Int)
    return (p as! Parser)
}
func parseIntStr(_ str: String) -> Int {
    var i = 0
    var n = 0
    while (i < ((str).count)) {
        n = ((((n * 10) + _int(String(Array(str)[i..<(i + 1)]))) - 48) as! Int)
        i = ((i + 1) as! Int)
    }
    return (n as! Int)
}
func parseNumber(_ p: inout Parser) -> Res {
    p = (skipWS(&p) as! Parser)
    var start = p.pos
    while (p.pos < ((p.expr).count)) {
        let ch = String(Array((p.expr as! String))[(p.pos as! Int)..<((p.pos + 1) as! Int)])
        if ((ch >= "0") && (ch <= "9")) {
            p.pos = ((p.pos + 1) as! Int)
        } else {
            break
        }
    }
    let token = String(Array((p.expr as! String))[(start as! Int)..<(p.pos as! Int)])
    return (Res(v: parseIntStr((token as! String)), p: p) as! Res)
}
func parseFactor(_ p: inout Parser) -> Res {
    p = (skipWS(&p) as! Parser)
    if ((p.pos < ((p.expr).count)) && (String(Array((p.expr as! String))[(p.pos as! Int)..<((p.pos + 1) as! Int)]) == "(")) {
        p.pos = ((p.pos + 1) as! Int)
        var r = parseExpr(&p)
        var v = r.v
        p = (r.p as! Parser)
        p = (skipWS(&p) as! Parser)
        if ((p.pos < ((p.expr).count)) && (String(Array((p.expr as! String))[(p.pos as! Int)..<((p.pos + 1) as! Int)]) == ")")) {
            p.pos = ((p.pos + 1) as! Int)
        }
        return (Res(v: v, p: p) as! Res)
    }
    if ((p.pos < ((p.expr).count)) && (String(Array((p.expr as! String))[(p.pos as! Int)..<((p.pos + 1) as! Int)]) == "-")) {
        p.pos = ((p.pos + 1) as! Int)
        var r = parseFactor(&p)
        var v = r.v
        p = (r.p as! Parser)
        return (Res(v: -v, p: p) as! Res)
    }
    return (parseNumber(&p) as! Res)
}
func powInt(_ base: Int, _ exp: Int) -> Int {
    var r = 1
    var b = base
    var e = exp
    while (e > 0) {
        if ((e % 2) == 1) {
            r = ((r * b) as! Int)
        }
        b = ((b * b) as! Int)
        e = ((e / 2) as! Int)
    }
    return (r as! Int)
}
func parsePower(_ p: inout Parser) -> Res {
    var r = parseFactor(&p)
    var v = r.v
    p = (r.p as! Parser)
    while true {
        p = (skipWS(&p) as! Parser)
        if ((p.pos < ((p.expr).count)) && (String(Array((p.expr as! String))[(p.pos as! Int)..<((p.pos + 1) as! Int)]) == "^")) {
            p.pos = ((p.pos + 1) as! Int)
            var r2 = parseFactor(&p)
            var rhs = r2.v
            p = (r2.p as! Parser)
            v = (powInt((v as! Int), (rhs as! Int)) as! Int)
        } else {
            break
        }
    }
    return (Res(v: v, p: p) as! Res)
}
func parseTerm(_ p: inout Parser) -> Res {
    var r = parsePower(&p)
    var v = r.v
    p = (r.p as! Parser)
    while true {
        p = (skipWS(&p) as! Parser)
        if (p.pos < ((p.expr).count)) {
            let op = String(Array((p.expr as! String))[(p.pos as! Int)..<((p.pos + 1) as! Int)])
            if (op == "*") {
                p.pos = ((p.pos + 1) as! Int)
                var r2 = parsePower(&p)
                var rhs = r2.v
                p = (r2.p as! Parser)
                v = ((v * rhs) as! Int)
                continue
            }
            if (op == "/") {
                p.pos = ((p.pos + 1) as! Int)
                var r2 = parsePower(&p)
                var rhs = r2.v
                p = (r2.p as! Parser)
                v = ((v / _int(rhs)) as! Int)
                continue
            }
        }
        break
    }
    return (Res(v: v, p: p) as! Res)
}
func parseExpr(_ p: inout Parser) -> Res {
    var r = parseTerm(&p)
    var v = r.v
    p = (r.p as! Parser)
    while true {
        p = (skipWS(&p) as! Parser)
        if (p.pos < ((p.expr).count)) {
            let op = String(Array((p.expr as! String))[(p.pos as! Int)..<((p.pos + 1) as! Int)])
            if (op == "+") {
                p.pos = ((p.pos + 1) as! Int)
                var r2 = parseTerm(&p)
                var rhs = r2.v
                p = (r2.p as! Parser)
                v = ((v + rhs) as! Int)
                continue
            }
            if (op == "-") {
                p.pos = ((p.pos + 1) as! Int)
                var r2 = parseTerm(&p)
                var rhs = r2.v
                p = (r2.p as! Parser)
                v = ((v - rhs) as! Int)
                continue
            }
        }
        break
    }
    return (Res(v: v, p: p) as! Res)
}
func evalExpr(_ expr: String) -> Int {
    var p = Parser(expr: expr, pos: 0)
    let r = parseExpr(&p)
    return (r.v as! Int)
}
func main() {
    let expr = "2*(3-1)+2*5"
    print(((expr + " = ") + String(describing: evalExpr((expr as! String)))))
}
_ = main()
