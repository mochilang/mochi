// Generated by Mochi transpiler v0.10.50 on 2025-07-31 08:16:33 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    struct Point {
        var x: Double
        var y: Double
        var z: Double
    }
    struct Edge {
        var pn1: Int
        var pn2: Int
        var fn1: Int
        var fn2: Int
        var cp: Point
    }
    struct PointEx {
        var p: Point
        var n: Int
    }
    func indexOf(_ s: String, _ ch: String) -> Int {
        var i: Int = 0
        while (i < Int(((s).count))) {
            if (String(describing: String(Array(String(describing: (s as! String)))[(i as! Int)..<((i + 1) as! Int)])) == ch) {
                return (i as! Int)
            }
            i = ((i + 1) as! Int)
        }
        return (-1 as! Int)
    }
    func fmt4(_ x: Double) -> String {
        var y: Double = (x * 10000.0)
        if (y >= 0) {
            y = Double((y + 0.5))
        } else {
            y = Double((y - 0.5))
        }
        y = Double((Double(Int(y)) / 10000.0))
        var s: String = _p(y)
        var dot: Int = Int((String(describing: (s as! String)).firstIndex(of: Character(String(describing: ".")))?.utf16Offset(in: String(describing: (s as! String)) ) ?? -1))
        if (dot == (0 - 1)) {
            s = ((s + ".0000") as! String)
        } else {
            var decs: Int = ((Int(((s).count)) - dot) - 1)
            if (decs > 4) {
                s = String(describing: String(Array(String(describing: (s as! String)))[0..<((dot + 5) as! Int)]))
            } else {
                while (decs < 4) {
                    s = ((s + "0") as! String)
                    decs = ((decs + 1) as! Int)
                }
            }
        }
        if (x >= 0.0) {
            s = ((" " + s) as! String)
        }
        return (s as! String)
    }
    func fmt2(_ n: Int) -> String {
        let s = _p(n)
        if (Int(((s).count)) < 2) {
            return ((" " + s) as! String)
        }
        return (s as! String)
    }
    func sumPoint(_ p1: Point, _ p2: Point) -> Point {
        return (Point(x: (p1.x + p2.x), y: (p1.y + p2.y), z: (p1.z + p2.z)) as! Point)
    }
    func mulPoint(_ p: Point, _ m: Double) -> Point {
        return (Point(x: (p.x * m), y: (p.y * m), z: (p.z * m)) as! Point)
    }
    func divPoint(_ p: Point, _ d: Double) -> Point {
        return (mulPoint((p as! Point), Double((1.0 / d))) as! Point)
    }
    func centerPoint(_ p1: Point, _ p2: Point) -> Point {
        return (divPoint((sumPoint((p1 as! Point), (p2 as! Point)) as! Point), 2.0) as! Point)
    }
    func getFacePoints(_ points: [Point], _ faces: [[Int]]) -> [Point] {
        var facePoints: [Point] = ([] as! [Point])
        var i: Int = 0
        while (i < Int(((faces).count))) {
            let face: [Int] = (faces[i] as! [Int])
            var fp: Point = Point(x: 0.0, y: 0.0, z: 0.0)
            for idx in face {
                fp = (sumPoint((fp as! Point), (points[idx] as! Point)) as! Point)
            }
            fp = (divPoint((fp as! Point), Double(((face).count))) as! Point)
            facePoints = (_append(facePoints, fp) as! [Point])
            i = ((i + 1) as! Int)
        }
        return (facePoints as! [Point])
    }
    func sortEdges(_ edges: [[Int]]) -> [[Int]] {
        var res: [[Int]] = ([] as! [[Int]])
        var tmp: [[Int]] = edges
        while (Int(((tmp).count)) > 0) {
            var min: [Int] = (tmp[0] as! [Int])
            var idx: Int = 0
            var j: Int = 1
            while (j < Int(((tmp).count))) {
                let e: [Int] = (tmp[j] as! [Int])
                if (((e[0] as! Int) < (min[0] as! Int)) || (((e[0] as! Int) == (min[0] as! Int)) && (((e[1] as! Int) < (min[1] as! Int)) || (((e[1] as! Int) == (min[1] as! Int)) && ((e[2] as! Int) < (min[2] as! Int)))))) {
                    min = (e as! [Int])
                    idx = (j as! Int)
                }
                j = ((j + 1) as! Int)
            }
            res = (_append(res, min) as! [[Int]])
            var out: [[Int]] = ([] as! [[Int]])
            var k: Int = 0
            while (k < Int(((tmp).count))) {
                if (k != idx) {
                    out = (_append(out, (tmp[k] as! [Int])) as! [[Int]])
                }
                k = ((k + 1) as! Int)
            }
            tmp = (out as! [[Int]])
        }
        return (res as! [[Int]])
    }
    func getEdgesFaces(_ points: [Point], _ faces: [[Int]]) -> [Edge] {
        var edges: [[Int]] = ([] as! [[Int]])
        var fnum: Int = 0
        while (fnum < Int(((faces).count))) {
            let face: [Int] = (faces[fnum] as! [Int])
            var numP: Int = Int(((face).count))
            var pi: Int = 0
            while (pi < numP) {
                var pn1: Int = (face[pi] as! Int)
                var pn2: Int = 0
                if (pi < (numP - 1)) {
                    pn2 = (face[(pi + 1)] as! Int)
                } else {
                    pn2 = (face[0] as! Int)
                }
                if (pn1 > pn2) {
                    var tmpn: Int = pn1
                    pn1 = (pn2 as! Int)
                    pn2 = (tmpn as! Int)
                }
                edges = (_append(edges, ([(pn1 as! Any), (pn2 as! Any), (fnum as! Any)] as! [Int])) as! [[Int]])
                pi = ((pi + 1) as! Int)
            }
            fnum = ((fnum + 1) as! Int)
        }
        edges = (sortEdges((edges as! [[Int]])) as! [[Int]])
        var merged: [[Int]] = ([] as! [[Int]])
        var idx: Int = 0
        while (idx < Int(((edges).count))) {
            let e1: [Int] = (edges[idx] as! [Int])
            if (idx < (Int(((edges).count)) - 1)) {
                let e2: [Int] = (edges[(idx + 1)] as! [Int])
                if (((e1[0] as! Int) == (e2[0] as! Int)) && ((e1[1] as! Int) == (e2[1] as! Int))) {
                    merged = (_append(merged, ([((e1[0] as! Int) as! Any), ((e1[1] as! Int) as! Any), ((e1[2] as! Int) as! Any), ((e2[2] as! Int) as! Any)] as! [Int])) as! [[Int]])
                    idx = ((idx + 2) as! Int)
                    continue
                }
            }
            merged = (_append(merged, ([((e1[0] as! Int) as! Any), ((e1[1] as! Int) as! Any), ((e1[2] as! Int) as! Any), (-1 as! Any)] as! [Int])) as! [[Int]])
            idx = ((idx + 1) as! Int)
        }
        var edgesCenters: [Edge] = ([] as! [Edge])
        for me in merged {
            let p1 = (points[(me[0] as! Int)] as! Point)
            let p2 = (points[(me[1] as! Int)] as! Point)
            let cp = centerPoint((p1 as! Point), (p2 as! Point))
            edgesCenters = (_append(edgesCenters, Edge(pn1: (me[0] as! Int), pn2: (me[1] as! Int), fn1: (me[2] as! Int), fn2: (me[3] as! Int), cp: cp)) as! [Edge])
        }
        return (edgesCenters as! [Edge])
    }
    func getEdgePoints(_ points: [Point], _ edgesFaces: [Edge], _ facePoints: [Point]) -> [Point] {
        var edgePoints: [Point] = ([] as! [Point])
        var i: Int = 0
        while (i < Int(((edgesFaces).count))) {
            let edge = (edgesFaces[i] as! Edge)
            let cp = edge.cp
            let fp1 = (facePoints[edge.fn1] as! Point)
            var fp2: Point = fp1
            if (edge.fn2 != (0 - 1)) {
                fp2 = (facePoints[edge.fn2] as! Point)
            }
            let cfp = centerPoint((fp1 as! Point), (fp2 as! Point))
            edgePoints = (_append(edgePoints, centerPoint((cp as! Point), (cfp as! Point))) as! [Point])
            i = ((i + 1) as! Int)
        }
        return (edgePoints as! [Point])
    }
    func getAvgFacePoints(_ points: [Point], _ faces: [[Int]], _ facePoints: [Point]) -> [Point] {
        var numP: Int = Int(((points).count))
        var temp: [PointEx] = ([] as! [PointEx])
        var i: Int = 0
        while (i < numP) {
            temp = (_append(temp, PointEx(p: Point(x: 0.0, y: 0.0, z: 0.0), n: 0)) as! [PointEx])
            i = ((i + 1) as! Int)
        }
        var fnum: Int = 0
        while (fnum < Int(((faces).count))) {
            let fp = (facePoints[fnum] as! Point)
            for pn in (faces[fnum] as! [Int]) {
                let tp = (temp[pn] as! PointEx)
                temp[pn] = (PointEx(p: sumPoint((tp.p as! Point), (fp as! Point)), n: (tp.n + 1)) as! PointEx)
            }
            fnum = ((fnum + 1) as! Int)
        }
        var avg: [Point] = ([] as! [Point])
        var j: Int = 0
        while (j < numP) {
            let tp = (temp[j] as! PointEx)
            avg = (_append(avg, divPoint((tp.p as! Point), (tp.n as! Double))) as! [Point])
            j = ((j + 1) as! Int)
        }
        return (avg as! [Point])
    }
    func getAvgMidEdges(_ points: [Point], _ edgesFaces: [Edge]) -> [Point] {
        var numP: Int = Int(((points).count))
        var temp: [PointEx] = ([] as! [PointEx])
        var i: Int = 0
        while (i < numP) {
            temp = (_append(temp, PointEx(p: Point(x: 0.0, y: 0.0, z: 0.0), n: 0)) as! [PointEx])
            i = ((i + 1) as! Int)
        }
        for edge in edgesFaces {
            let cp = edge.cp
            var arr: [Int] = ([(edge.pn1 as! Any), (edge.pn2 as! Any)] as! [Int])
            for pn in arr {
                let tp = (temp[pn] as! PointEx)
                temp[pn] = (PointEx(p: sumPoint((tp.p as! Point), (cp as! Point)), n: (tp.n + 1)) as! PointEx)
            }
        }
        var avg: [Point] = ([] as! [Point])
        var j: Int = 0
        while (j < numP) {
            let tp = (temp[j] as! PointEx)
            avg = (_append(avg, divPoint((tp.p as! Point), (tp.n as! Double))) as! [Point])
            j = ((j + 1) as! Int)
        }
        return (avg as! [Point])
    }
    func getPointsFaces(_ points: [Point], _ faces: [[Int]]) -> [Int] {
        var pf: [Int] = ([] as! [Int])
        var i: Int = 0
        while (i < Int(((points).count))) {
            pf = (_append(pf, 0) as! [Int])
            i = ((i + 1) as! Int)
        }
        var fnum: Int = 0
        while (fnum < Int(((faces).count))) {
            for pn in (faces[fnum] as! [Int]) {
                pf[pn] = (((pf[pn] as! Int) + 1) as! Int)
            }
            fnum = ((fnum + 1) as! Int)
        }
        return (pf as! [Int])
    }
    func getNewPoints(_ points: [Point], _ pf: [Int], _ afp: [Point], _ ame: [Point]) -> [Point] {
        var newPts: [Point] = ([] as! [Point])
        var i: Int = 0
        while (i < Int(((points).count))) {
            var n: Double = (pf[i] as! Double)
            var m1: Double = (Double((n - 3.0)) / n)
            var m2: Double = (1.0 / n)
            var m3: Double = (2.0 / n)
            let old = (points[i] as! Point)
            let p1 = mulPoint((old as! Point), (m1 as! Double))
            let p2 = mulPoint((afp[i] as! Point), (m2 as! Double))
            let p3 = mulPoint((ame[i] as! Point), (m3 as! Double))
            newPts = (_append(newPts, sumPoint((sumPoint((p1 as! Point), (p2 as! Point)) as! Point), (p3 as! Point))) as! [Point])
            i = ((i + 1) as! Int)
        }
        return (newPts as! [Point])
    }
    func key(_ a: Int, _ b: Int) -> String {
        if (a < b) {
            return (((_p(a) + ",") + _p(b)) as! String)
        }
        return (((_p(b) + ",") + _p(a)) as! String)
    }
    func cmcSubdiv(_ points: [Point], _ faces: [[Int]]) -> [Any?] {
        let facePoints: [Point] = (getFacePoints((points as! [Point]), (faces as! [[Int]])) as! [Point])
        let edgesFaces: [Edge] = (getEdgesFaces((points as! [Point]), (faces as! [[Int]])) as! [Edge])
        let edgePoints: [Point] = (getEdgePoints((points as! [Point]), (edgesFaces as! [Edge]), (facePoints as! [Point])) as! [Point])
        let avgFacePoints: [Point] = (getAvgFacePoints((points as! [Point]), (faces as! [[Int]]), (facePoints as! [Point])) as! [Point])
        let avgMidEdges: [Point] = (getAvgMidEdges((points as! [Point]), (edgesFaces as! [Edge])) as! [Point])
        let pointsFaces: [Int] = (getPointsFaces((points as! [Point]), (faces as! [[Int]])) as! [Int])
        var newPoints: [Point] = (getNewPoints((points as! [Point]), (pointsFaces as! [Int]), (avgFacePoints as! [Point]), (avgMidEdges as! [Point])) as! [Point])
        var facePointNums: [Int] = ([] as! [Int])
        var nextPoint: Int = Int(((newPoints).count))
        for fp in facePoints {
            newPoints = (_append(newPoints, fp) as! [Point])
            facePointNums = (_append(facePointNums, nextPoint) as! [Int])
            nextPoint = ((nextPoint + 1) as! Int)
        }
        var edgePointNums: [String: Int] = ([:] as! [String: Int])
        var idx: Int = 0
        while (idx < Int(((edgesFaces).count))) {
            let e = (edgesFaces[idx] as! Edge)
            newPoints = (_append(newPoints, (edgePoints[idx] as! Point)) as! [Point])
            edgePointNums[String(describing: key((e.pn1 as! Int), (e.pn2 as! Int)))] = (nextPoint as! Int)
            nextPoint = ((nextPoint + 1) as! Int)
            idx = ((idx + 1) as! Int)
        }
        var newFaces: [[Int]] = ([] as! [[Int]])
        var fnum: Int = 0
        while (fnum < Int(((faces).count))) {
            let oldFace: [Int] = (faces[fnum] as! [Int])
            if (Int(((oldFace).count)) == 4) {
                let a = (oldFace[0] as! Int)
                let b = (oldFace[1] as! Int)
                let c = (oldFace[2] as! Int)
                let d = (oldFace[3] as! Int)
                let fpnum = (facePointNums[fnum] as! Int)
                let ab = edgePointNums[String(describing: key((a as! Int), (b as! Int)))]!
                let da = edgePointNums[String(describing: key((d as! Int), (a as! Int)))]!
                let bc = edgePointNums[String(describing: key((b as! Int), (c as! Int)))]!
                let cd = edgePointNums[String(describing: key((c as! Int), (d as! Int)))]!
                newFaces = (_append(newFaces, ([(a as! Any), (ab as! Any), (fpnum as! Any), (da as! Any)] as! [Int])) as! [[Int]])
                newFaces = (_append(newFaces, ([(b as! Any), (bc as! Any), (fpnum as! Any), (ab as! Any)] as! [Int])) as! [[Int]])
                newFaces = (_append(newFaces, ([(c as! Any), (cd as! Any), (fpnum as! Any), (bc as! Any)] as! [Int])) as! [[Int]])
                newFaces = (_append(newFaces, ([(d as! Any), (da as! Any), (fpnum as! Any), (cd as! Any)] as! [Int])) as! [[Int]])
            }
            fnum = ((fnum + 1) as! Int)
        }
        return ([(newPoints as! Any), (newFaces as! Any)] as! [Any])
    }
    func formatPoint(_ p: Point) -> String {
        return ((((((("[" + String(describing: fmt4((p.x as! Double)))) + " ") + String(describing: fmt4((p.y as! Double)))) + " ") + String(describing: fmt4((p.z as! Double)))) + "]") as! String)
    }
    func formatFace(_ f: [Int]) -> String {
        if (Int(((f).count)) == 0) {
            return "[]"
        }
        var s: String = ("[" + String(describing: fmt2((f[0] as! Int))))
        var i: Int = 1
        while (i < Int(((f).count))) {
            s = (((s + " ") + String(describing: fmt2((f[i] as! Int)))) as! String)
            i = ((i + 1) as! Int)
        }
        s = ((s + "]") as! String)
        return (s as! String)
    }
    func main() {
        let inputPoints: [Point] = ([(Point(x: -1.0, y: 1.0, z: 1.0) as! Any), (Point(x: -1.0, y: -1.0, z: 1.0) as! Any), (Point(x: 1.0, y: -1.0, z: 1.0) as! Any), (Point(x: 1.0, y: 1.0, z: 1.0) as! Any), (Point(x: 1.0, y: -1.0, z: -1.0) as! Any), (Point(x: 1.0, y: 1.0, z: -1.0) as! Any), (Point(x: -1.0, y: -1.0, z: -1.0) as! Any), (Point(x: -1.0, y: 1.0, z: -1.0) as! Any)] as! [Point])
        let inputFaces: [[Int]] = ([(([(0 as! Any), (1 as! Any), (2 as! Any), (3 as! Any)] as! [Int]) as! Any), (([(3 as! Any), (2 as! Any), (4 as! Any), (5 as! Any)] as! [Int]) as! Any), (([(5 as! Any), (4 as! Any), (6 as! Any), (7 as! Any)] as! [Int]) as! Any), (([(7 as! Any), (0 as! Any), (3 as! Any), (5 as! Any)] as! [Int]) as! Any), (([(7 as! Any), (6 as! Any), (1 as! Any), (0 as! Any)] as! [Int]) as! Any), (([(6 as! Any), (1 as! Any), (2 as! Any), (4 as! Any)] as! [Int]) as! Any)] as! [[Int]])
        var outputPoints: [Point] = inputPoints
        var outputFaces: [[Int]] = inputFaces
        var i: Int = 0
        while (i < 1) {
            let res: [Any] = (cmcSubdiv((outputPoints as! [Point]), (outputFaces as! [[Int]])) as! [Any])
            outputPoints = ((res[0] as! Any) as! [Point])
            outputFaces = ((res[1] as! Any) as! [[Int]])
            i = ((i + 1) as! Int)
        }
        for p in outputPoints {
            print(_p(String(describing: formatPoint((p as! Point)))))
        }
        print(_p(""))
        for f in outputFaces {
            print(_p(String(describing: formatFace((f as! [Int])))))
        }
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
