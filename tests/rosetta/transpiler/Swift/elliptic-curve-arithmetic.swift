// Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:33:49 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    struct Pt {
        var x: Double
        var y: Double
        var inf: Bool
    }
    let bCoeff = 7.0
    func zero() -> Pt {
        return (Pt(x: 0.0, y: 0.0, inf: true) as! Pt)
    }
    func isZero(_ p: Pt) -> Bool {
        return (p.inf as! Bool)
    }
    func neg(_ p: Pt) -> Pt {
        return (Pt(x: p.x, y: -p.y, inf: p.inf) as! Pt)
    }
    func dbl(_ p: Pt) -> Pt {
        if isZero((p as! Pt)) {
            return (p as! Pt)
        }
        let L = (Double(((3.0 * p.x) * p.x)) / Double((2.0 * p.y)))
        let x = ((L * L) - (2.0 * p.x))
        return (Pt(x: x, y: ((L * Double((p.x - x))) - p.y), inf: false) as! Pt)
    }
    func add(_ p: Pt, _ q: Pt) -> Pt {
        if isZero((p as! Pt)) {
            return (q as! Pt)
        }
        if isZero((q as! Pt)) {
            return (p as! Pt)
        }
        if (p.x == q.x) {
            if (p.y == q.y) {
                return (dbl((p as! Pt)) as! Pt)
            }
            return (zero() as! Pt)
        }
        let L = (Double((q.y - p.y)) / Double((q.x - p.x)))
        let x = (((L * L) - p.x) - q.x)
        return (Pt(x: x, y: ((L * Double((p.x - x))) - p.y), inf: false) as! Pt)
    }
    func mul(_ p: Pt, _ n: Int) -> Pt {
        var r: Pt = zero()
        var q: Pt = p
        var k: Int = n
        while (k > 0) {
            if ((k % 2) == 1) {
                r = (add((r as! Pt), (q as! Pt)) as! Pt)
            }
            q = (dbl((q as! Pt)) as! Pt)
            k = Int((k / 2))
        }
        return (r as! Pt)
    }
    func cbrtApprox(_ x: Double) -> Double {
        var guess: Double = x
        var i: Int = 0
        while (i < 40) {
            guess = Double((Double(((2.0 * guess) + (x / Double((guess * guess))))) / 3.0))
            i = Int((i + 1))
        }
        return Double(guess)
    }
    func fromY(_ y: Double) -> Pt {
        return (Pt(x: Double(cbrtApprox(Double(((y * y) - bCoeff)))), y: y, inf: false) as! Pt)
    }
    func show(_ s: String, _ p: Pt) {
        if isZero((p as! Pt)) {
            print(_p((s + "Zero")))
        } else {
            print(_p((((((s + "(") + _p(p.x)) + ", ") + _p(p.y)) + ")")))
        }
    }
    func main() {
        let a = fromY(1.0)
        let b = fromY(2.0)
        _ = show("a = ", (a as! Pt))
        _ = show("b = ", (b as! Pt))
        let c = add((a as! Pt), (b as! Pt))
        _ = show("c = a + b = ", (c as! Pt))
        let d = neg((c as! Pt))
        _ = show("d = -c = ", (d as! Pt))
        _ = show("c + d = ", (add((c as! Pt), (d as! Pt)) as! Pt))
        _ = show("a + b + d = ", (add((a as! Pt), (add((b as! Pt), (d as! Pt)) as! Pt)) as! Pt))
        _ = show("a * 12345 = ", (mul((a as! Pt), 12345) as! Pt))
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
