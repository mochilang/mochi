// Generated by Mochi transpiler v0.10.57 on 2025-08-04 21:31:59 GMT+7
import Foundation
import Dispatch
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

let stdout = FileHandle.standardOutput
extension FileHandle {
    func write(_ string: String) {
        if let data = string.data(using: .utf8) {
            self.write(data)
        }
    }
}

func _p(_ v: Any?) -> String {
    if let val = v {
        if let d = val as? Double {
            if d.rounded(.towardZero) == d {
                return String(Int64(d))
            }
        }
        return String(describing: val)
    }
    return "<nil>"
}

extension Double { init(_ v: Any) { if let d = v as? Double { self = d } else if let i = v as? Int { self = Double(i) } else if let i = v as? Int64 { self = Double(i) } else if let s = v as? String { self = Double(s) ?? 0 } else { self = 0 } } }
struct testpkg {
    static func Add(_ a: Int, _ b: Int) -> Int { return a + b }
    static let Pi = 3.14
    static let Answer = 42
    static func FifteenPuzzleExample() -> String { return "Solution found in 52 moves: rrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd" }
    static func ECDSAExample() -> (D: Any?, X: Any?, Y: Any?, Hash: Any?, R: Any?, S: Any?, Valid: Any?) { return (nil, nil, nil, nil, nil, nil, nil) }
    static func MD5Hex(_ s: String) -> String {
        var msg = [UInt8](s.utf8)
        let bitLen = UInt64(msg.count) * 8
        msg.append(0x80)
        while (msg.count % 64) != 56 { msg.append(0) }
        for i in 0..<8 { msg.append(UInt8((bitLen >> (8 * UInt64(i))) & 0xff)) }
        var a0: UInt32 = 0x67452301
        var b0: UInt32 = 0xefcdab89
        var c0: UInt32 = 0x98badcfe
        var d0: UInt32 = 0x10325476
        let s: [UInt32] = [7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21]
        let K: [UInt32] = (0..<64).map { UInt32(abs(sin(Double($0+1))) * 4294967296.0) }
        func leftrotate(_ x: UInt32, _ c: UInt32) -> UInt32 { return (x << c) | (x >> (32 - c)) }
        for chunkOffset in stride(from: 0, to: msg.count, by: 64) {
            var M = [UInt32](repeating: 0, count: 16)
            for i in 0..<16 {
                let j = chunkOffset + i*4
                M[i] = UInt32(msg[j]) | UInt32(msg[j+1])<<8 | UInt32(msg[j+2])<<16 | UInt32(msg[j+3])<<24
            }
            var A = a0
            var B = b0
            var C = c0
            var D = d0
            for i in 0..<64 {
                var F: UInt32 = 0
                var g = 0
                if i < 16 {
                    F = (B & C) | ((~B) & D)
                    g = i
                } else if i < 32 {
                    F = (D & B) | ((~D) & C)
                    g = (5*i + 1) % 16
                } else if i < 48 {
                    F = B ^ C ^ D
                    g = (3*i + 5) % 16
                } else {
                    F = C ^ (B | (~D))
                    g = (7*i) % 16
                }
                let temp = D
                D = C
                C = B
                B = B &+ leftrotate(A &+ F &+ K[i] &+ M[g], s[i])
                A = temp
            }
            a0 = a0 &+ A
            b0 = b0 &+ B
            c0 = c0 &+ C
            d0 = d0 &+ D
        }
        func toBytes(_ v: UInt32) -> [UInt8] { return [UInt8(v & 0xff), UInt8((v >> 8) & 0xff), UInt8((v >> 16) & 0xff), UInt8((v >> 24) & 0xff)] }
        let digest = toBytes(a0) + toBytes(b0) + toBytes(c0) + toBytes(d0)
        return digest.map { String(format: "%02x", $0) }.joined()
    }
}
for pair in ([(["d41d8cd98f00b204e9800998ecf8427e", ""] as! [String]), (["0cc175b9c0f1b6a831c399e269772661", "a"] as! [String]), (["900150983cd24fb0d6963f7d28e17f72", "abc"] as! [String]), (["f96b697d7cb7938d525a2f31aaf161d0", "message digest"] as! [String]), (["c3fcd3d76192e4007dfb496cca67e13b", "abcdefghijklmnopqrstuvwxyz"] as! [String]), (["d174ab98d277d9f5a5611c2c9f419d9f", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"] as! [String]), (["57edf4a22be3c955ac49da2e2107b67a", ("12345678901234567890" + "123456789012345678901234567890123456789012345678901234567890")] as! [String]), (["e38ca1d920c4b8b8d3946b2c72f01680", "The quick brown fox jumped over the lazy dog's back"] as! [String])] as! [[String]]) {
    let sum = testpkg.MD5Hex((pair[1] as! String))
    if (String(describing: sum) != (pair[0] as! String)) {
        print(_p("MD5 fail"))
        print(_p("  for string,"), _p((pair[1] as! String)))
        print(_p("  expected:  "), _p((pair[0] as! String)))
        print(_p("  got:       "), _p(sum))
    }
}
