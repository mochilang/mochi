// Generated by Mochi transpiler v0.10.54 on 2025-08-02 12:12:15 GMT+7
import Foundation

let stdout = FileHandle.standardOutput
extension FileHandle {
    func write(_ string: String) {
        if let data = string.data(using: .utf8) {
            self.write(data)
        }
    }
}

func _p(_ v: Any?) -> String {
    if let val = v {
        if let d = val as? Double {
            if d.rounded(.towardZero) == d {
                return String(Int64(d))
            }
        }
        return String(describing: val)
    }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    struct Point {
        var x: Double
        var y: Double
    }
    struct Triangle {
        var p1: Point
        var p2: Point
        var p3: Point
    }
    func fmt1(_ f: Double) -> String {
        var s: String = _p(f)
        let idx = Int((String(describing: (s as! String)).firstIndex(of: Character(String(describing: ".")))?.utf16Offset(in: String(describing: (s as! String)) ) ?? -1))
        if (idx < 0) {
            s = ((s + ".0") as! String)
        } else {
            var need: Int = (idx &+ 2)
            if (Int(((s).count)) > need) {
                s = String(describing: String(Array(String(describing: (s as! String)))[0..<Int(need)]))
            } else {
                while (Int(((s).count)) < need) {
                    s = ((s + "0") as! String)
                }
            }
        }
        return s
    }
    func pointStr(_ p: Point) -> String {
        return (((("(" + String(describing: fmt1((p.x as! Double)))) + ", ") + String(describing: fmt1((p.y as! Double)))) + ")")
    }
    func triangleStr(_ t: Triangle) -> String {
        return ((((("Triangle " + String(describing: pointStr((t.p1 as! Point)))) + ", ") + String(describing: pointStr((t.p2 as! Point)))) + ", ") + String(describing: pointStr((t.p3 as! Point))))
    }
    func orient(_ a: Point, _ b: Point, _ c: Point) -> Double {
        return ((Double((b.x - a.x)) * Double((c.y - a.y))) - (Double((b.y - a.y)) * Double((c.x - a.x))))
    }
    func pointInTri(_ p: Point, _ t: Triangle, _ onBoundary: Bool) -> Bool {
        let d1 = Double(orient((p as! Point), (t.p1 as! Point), (t.p2 as! Point)))
        let d2 = Double(orient((p as! Point), (t.p2 as! Point), (t.p3 as! Point)))
        let d3 = Double(orient((p as! Point), (t.p3 as! Point), (t.p1 as! Point)))
        var hasNeg: Bool = (((d1 < 0.0) || (d2 < 0.0)) || (d3 < 0.0))
        var hasPos: Bool = (((d1 > 0.0) || (d2 > 0.0)) || (d3 > 0.0))
        if onBoundary {
            return (!(hasNeg && hasPos))
        }
        return ((((!(hasNeg && hasPos)) && (d1 != 0.0)) && (d2 != 0.0)) && (d3 != 0.0))
    }
    func edgeCheck(_ a0: Point, _ a1: Point, _ bs: [Point], _ onBoundary: Bool) -> Bool {
        let d0 = Double(orient((a0 as! Point), (a1 as! Point), (bs[0] as! Point)))
        let d1 = Double(orient((a0 as! Point), (a1 as! Point), (bs[1] as! Point)))
        let d2 = Double(orient((a0 as! Point), (a1 as! Point), (bs[2] as! Point)))
        if onBoundary {
            return (((d0 <= 0.0) && (d1 <= 0.0)) && (d2 <= 0.0))
        }
        return (((d0 < 0.0) && (d1 < 0.0)) && (d2 < 0.0))
    }
    func triTri2D(_ t1: Triangle, _ t2: Triangle, _ onBoundary: Bool) -> Bool {
        let a: [Point] = ([t1.p1, t1.p2, t1.p3] as! [Point])
        let b: [Point] = ([t2.p1, t2.p2, t2.p3] as! [Point])
        var i: Int = 0
        while (i < 3) {
            let j = (Int((i &+ 1)) % 3)
            if edgeCheck((a[i] as! Point), (a[j] as! Point), (b as! [Point]), (onBoundary as! Bool)) {
                return false
            }
            i = Int((i &+ 1))
        }
        i = 0
        while (i < 3) {
            let j = (Int((i &+ 1)) % 3)
            if edgeCheck((b[i] as! Point), (b[j] as! Point), (a as! [Point]), (onBoundary as! Bool)) {
                return false
            }
            i = Int((i &+ 1))
        }
        return true
    }
    func iff(_ cond: Bool, _ a: String, _ b: String) -> String {
        if cond {
            return a
        } else {
            return b
        }
    }
    func main() {
        var t1: Triangle = Triangle(p1: Point(x: 0.0, y: 0.0), p2: Point(x: 5.0, y: 0.0), p3: Point(x: 0.0, y: 5.0))
        var t2: Triangle = Triangle(p1: Point(x: 0.0, y: 0.0), p2: Point(x: 5.0, y: 0.0), p3: Point(x: 0.0, y: 6.0))
        print(_p((String(describing: triangleStr((t1 as! Triangle))) + " and")))
        print(_p(String(describing: triangleStr((t2 as! Triangle)))))
        var overlapping: Bool = triTri2D((t1 as! Triangle), (t2 as! Triangle), true)
        print(_p(String(describing: iff((overlapping as! Bool), "overlap", "do not overlap"))))
        print(_p(""))
        t1 = (Triangle(p1: Point(x: 0.0, y: 0.0), p2: Point(x: 0.0, y: 5.0), p3: Point(x: 5.0, y: 0.0)) as! Triangle)
        t2 = (t1 as! Triangle)
        print(_p((String(describing: triangleStr((t1 as! Triangle))) + " and")))
        print(_p(String(describing: triangleStr((t2 as! Triangle)))))
        overlapping = triTri2D((t1 as! Triangle), (t2 as! Triangle), true)
        print(_p(String(describing: iff((overlapping as! Bool), "overlap (reversed)", "do not overlap"))))
        print(_p(""))
        t1 = (Triangle(p1: Point(x: 0.0, y: 0.0), p2: Point(x: 5.0, y: 0.0), p3: Point(x: 0.0, y: 5.0)) as! Triangle)
        t2 = (Triangle(p1: Point(x: -10.0, y: 0.0), p2: Point(x: -5.0, y: 0.0), p3: Point(x: -1.0, y: 6.0)) as! Triangle)
        print(_p((String(describing: triangleStr((t1 as! Triangle))) + " and")))
        print(_p(String(describing: triangleStr((t2 as! Triangle)))))
        overlapping = triTri2D((t1 as! Triangle), (t2 as! Triangle), true)
        print(_p(String(describing: iff((overlapping as! Bool), "overlap", "do not overlap"))))
        print(_p(""))
        t1.p3 = (Point(x: 2.5, y: 5.0) as! Point)
        t2 = (Triangle(p1: Point(x: 0.0, y: 4.0), p2: Point(x: 2.5, y: -1.0), p3: Point(x: 5.0, y: 4.0)) as! Triangle)
        print(_p((String(describing: triangleStr((t1 as! Triangle))) + " and")))
        print(_p(String(describing: triangleStr((t2 as! Triangle)))))
        overlapping = triTri2D((t1 as! Triangle), (t2 as! Triangle), true)
        print(_p(String(describing: iff((overlapping as! Bool), "overlap", "do not overlap"))))
        print(_p(""))
        t1 = (Triangle(p1: Point(x: 0.0, y: 0.0), p2: Point(x: 1.0, y: 1.0), p3: Point(x: 0.0, y: 2.0)) as! Triangle)
        t2 = (Triangle(p1: Point(x: 2.0, y: 1.0), p2: Point(x: 3.0, y: 0.0), p3: Point(x: 3.0, y: 2.0)) as! Triangle)
        print(_p((String(describing: triangleStr((t1 as! Triangle))) + " and")))
        print(_p(String(describing: triangleStr((t2 as! Triangle)))))
        overlapping = triTri2D((t1 as! Triangle), (t2 as! Triangle), true)
        print(_p(String(describing: iff((overlapping as! Bool), "overlap", "do not overlap"))))
        print(_p(""))
        t2 = (Triangle(p1: Point(x: 2.0, y: 1.0), p2: Point(x: 3.0, y: -2.0), p3: Point(x: 3.0, y: 4.0)) as! Triangle)
        print(_p((String(describing: triangleStr((t1 as! Triangle))) + " and")))
        print(_p(String(describing: triangleStr((t2 as! Triangle)))))
        overlapping = triTri2D((t1 as! Triangle), (t2 as! Triangle), true)
        print(_p(String(describing: iff((overlapping as! Bool), "overlap", "do not overlap"))))
        print(_p(""))
        t1 = (Triangle(p1: Point(x: 0.0, y: 0.0), p2: Point(x: 1.0, y: 0.0), p3: Point(x: 0.0, y: 1.0)) as! Triangle)
        t2 = (Triangle(p1: Point(x: 1.0, y: 0.0), p2: Point(x: 2.0, y: 0.0), p3: Point(x: 1.0, y: 1.1)) as! Triangle)
        print(_p((String(describing: triangleStr((t1 as! Triangle))) + " and")))
        print(_p(String(describing: triangleStr((t2 as! Triangle)))))
        print(_p("which have only a single corner in contact, if boundary points collide"))
        overlapping = triTri2D((t1 as! Triangle), (t2 as! Triangle), true)
        print(_p(String(describing: iff((overlapping as! Bool), "overlap", "do not overlap"))))
        print(_p(""))
        print(_p((String(describing: triangleStr((t1 as! Triangle))) + " and")))
        print(_p(String(describing: triangleStr((t2 as! Triangle)))))
        print(_p("which have only a single corner in contact, if boundary points do not collide"))
        overlapping = triTri2D((t1 as! Triangle), (t2 as! Triangle), false)
        print(_p(String(describing: iff((overlapping as! Bool), "overlap", "do not overlap"))))
    }
    _ = main()
    let _benchEnd = _now()
    let _benchMemEnd = _mem()
    print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
