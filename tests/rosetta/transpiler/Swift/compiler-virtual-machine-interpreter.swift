// Generated by Mochi transpiler v0.10.55 on 2025-08-02 18:03:41 GMT+7
import Foundation

let stdout = FileHandle.standardOutput
extension FileHandle {
    func write(_ string: String) {
        if let data = string.data(using: .utf8) {
            self.write(data)
        }
    }
}

func _p(_ v: Any?) -> String {
    if let val = v {
        if let d = val as? Double {
            if d.rounded(.towardZero) == d {
                return String(Int64(d))
            }
        }
        return String(describing: val)
    }
    return "<nil>"
}

extension Double { init(_ v: Any) { if let d = v as? Double { self = d } else if let i = v as? Int { self = Double(i) } else if let i = v as? Int64 { self = Double(i) } else if let s = v as? String { self = Double(s) ?? 0 } else { self = 0 } } }
func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
func _len(_ v: Any) -> Int {
    if let s = v as? String { return Array(s).count }
    if let a = v as? [Any] { return a.count }
    if let a = v as? [Double] { return a.count }
    if let a = v as? [Int] { return a.count }
    if let m = v as? [AnyHashable: Any] { return m.count }
    return 0
}
func _split(_ s: String, _ sep: String) -> [String] {
    let d = sep.isEmpty ? " " : sep
    return s.components(separatedBy: d)
}
func parseIntStr(_ str: String) -> Int {
    var i: Int = 0
    var neg: Bool = false
    if ((Int(((str).count)) > 0) && (String(Array(str)[0..<1]) == "-")) {
        neg = true
        i = 1
    }
    var n: Int = 0
    let digits = ["0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9]
    while (i < Int(((str).count))) {
        n = Int(((n &* 10) + digits[String(Array(str)[i..<(i &+ 1)])]!))
        i = Int((i &+ 1))
    }
    if neg {
        n = Int(-n)
    }
    return n
}
func fields(_ s: String) -> [String] {
    var words: [String] = ([] as! [String])
    var cur: String = ""
    var i: Int = 0
    while (i < Int(((s).count))) {
        let ch = String(describing: String(Array(String(describing: (s as! String)))[(i as! Int)..<Int((i &+ 1))]))
        if (((ch == " ") || (ch == "\t")) || (ch == "\n")) {
            if (Int(((cur).count)) > 0) {
                words = (_append(words, cur) as! [String])
                cur = ""
            }
        } else {
            cur = ((cur + ch) as! String)
        }
        i = Int((i &+ 1))
    }
    if (Int(((cur).count)) > 0) {
        words = (_append(words, cur) as! [String])
    }
    return words
}
func unescape(_ s: String) -> String {
    var out: String = ""
    var i: Int = 0
    while (i < Int(((s).count))) {
        if ((String(Array(s)[i..<(i &+ 1)]) == "\\") && ((i &+ 1) < Int(((s).count)))) {
            let c = String(Array(s)[(i &+ 1)..<(i &+ 2)])
            if (c == "n") {
                out = ((out + "\n") as! String)
                i = Int((i &+ 2))
                continue
            } else if (c == "\\") {
                out = ((out + "\\") as! String)
                i = Int((i &+ 2))
                continue
            }
            
        }
        out = ((out + String(Array(s)[i..<(i &+ 1)])) as! String)
        i = Int((i &+ 1))
    }
    return out
}
func parseProgram(_ src: String) -> [String: Any?] {
    let lines: [String] = (_split(src, "\n") as! [String])
    let header: [String] = (fields((lines[0] as! String)) as! [String])
    let dataSize = Int(Int(String(describing: (header[1] as! String)))!)
    let nStrings = Int(Int(String(describing: (header[3] as! String)))!)
    var stringPool: [String] = ([] as! [String])
    var i: Int = 1
    while (i <= nStrings) {
        let s = (lines[i] as! String)
        if (Int(((s).count)) > 0) {
            stringPool = (_append(stringPool, String(describing: unescape((String(Array(s)[1..<(Int(((s).count)) &- 1)]) as! String)))) as! [String])
        }
        i = Int((i &+ 1))
    }
    var code: [[String: Any?]] = ([] as! [[String: Any?]])
    var addrMap: [Int: Int] = ([:] as! [Int: Int])
    while (i < Int(((lines).count))) {
        let line = String(describing: trim((lines[i] as! String)))
        if (Int(((line).count)) == 0) {
            break
        }
        let parts: [String] = (fields((line as! String)) as! [String])
        let addr = Int(Int(String(describing: (parts[0] as! String)))!)
        let op = (parts[1] as! String)
        var arg: Int = 0
        if (op == "push") {
            arg = Int(Int(String(describing: (parts[2] as! String)))!)
        } else if ((op == "fetch") || (op == "store")) {
            arg = Int(Int(String(describing: String(describing: String(Array(parts[2])[1..<(Int((((parts[2] as! String)).count)) &- 1)]))))!)
        } else if ((op == "jmp") || (op == "jz")) {
            arg = Int(Int(String(describing: (parts[3] as! String)))!)
        }
        
        
        code = ((_append(code, ["addr": addr, "op": op, "arg": arg]) as! [Any?]) as! [[String: Any?]])
        addrMap[addr] = Int((Int(((code).count)) &- 1))
        i = Int((i &+ 1))
    }
    return (["dataSize": dataSize, "strings": stringPool, "code": code, "addrMap": addrMap] as! [String: Any?])
}
func runVM(_ prog: [String: Any?]) {
    var data: [Int] = ([] as! [Int])
    var i: Int = 0
    while (i < (prog[String("dataSize")]! as! Int)) {
        data = (_append(data, 0) as! [Int])
        i = Int((i &+ 1))
    }
    var stack: [Int] = ([] as! [Int])
    var pc: Int = 0
    let code = prog[String("code")]!
    let addrMap = prog[String("addrMap")]!
    let pool = prog[String("strings")]!
    var line: String = ""
    while (pc < Int(_len(code))) {
        let inst = (code as! [Any])[pc]
        let op = (inst as! [String: Any])["op"]
        let arg = (inst as! [String: Any])["arg"]
        if (String(describing: op) == "push") {
            stack = ((_append(stack, arg) as! [Any?]) as! [Int])
            pc = Int((pc &+ 1))
            continue
        }
        if (String(describing: op) == "store") {
            data[(arg as! Int)] = (stack[(Int(((stack).count)) &- 1)] as! Int)
            stack = (Array(stack[0..<(Int(((stack).count)) &- 1)]) as! [Int])
            pc = Int((pc &+ 1))
            continue
        }
        if (String(describing: op) == "fetch") {
            stack = (_append(stack, (data[(arg as! Int)] as! Int)) as! [Int])
            pc = Int((pc &+ 1))
            continue
        }
        if (String(describing: op) == "add") {
            stack[(Int(((stack).count)) &- 2)] = Int(((stack[(Int(((stack).count)) &- 2)] as! Int) &+ (stack[(Int(((stack).count)) &- 1)] as! Int)))
            stack = (Array(stack[0..<(Int(((stack).count)) &- 1)]) as! [Int])
            pc = Int((pc &+ 1))
            continue
        }
        if (String(describing: op) == "lt") {
            var v: Int = 0
            if ((stack[(Int(((stack).count)) &- 2)] as! Int) < (stack[(Int(((stack).count)) &- 1)] as! Int)) {
                v = 1
            }
            stack[(Int(((stack).count)) &- 2)] = (v as! Int)
            stack = (Array(stack[0..<(Int(((stack).count)) &- 1)]) as! [Int])
            pc = Int((pc &+ 1))
            continue
        }
        if (String(describing: op) == "jz") {
            let v = (stack[(Int(((stack).count)) &- 1)] as! Int)
            stack = (Array(stack[0..<(Int(((stack).count)) &- 1)]) as! [Int])
            if (v == 0) {
                pc = ((addrMap as! [Any])[(arg as! Int)] as! Int)
            } else {
                pc = Int((pc &+ 1))
            }
            continue
        }
        if (String(describing: op) == "jmp") {
            pc = ((addrMap as! [Any])[(arg as! Int)] as! Int)
            continue
        }
        if (String(describing: op) == "prts") {
            let s = (pool as! [Any])[(stack[(Int(((stack).count)) &- 1)] as! Int)]
            stack = (Array(stack[0..<(Int(((stack).count)) &- 1)]) as! [Int])
            if (String(describing: s) != "\n") {
                line = ((line + String(describing: s)) as! String)
            }
            pc = Int((pc &+ 1))
            continue
        }
        if (String(describing: op) == "prti") {
            line = ((line + _p((stack[(Int(((stack).count)) &- 1)] as! Int))) as! String)
            print(_p(line))
            line = ""
            stack = (Array(stack[0..<(Int(((stack).count)) &- 1)]) as! [Int])
            pc = Int((pc &+ 1))
            continue
        }
        if (String(describing: op) == "halt") {
            break
        }
        pc = Int((pc &+ 1))
    }
}
func trim(_ s: String) -> String {
    var start: Int = 0
    while ((start < Int(((s).count))) && ((String(Array(s)[start..<(start &+ 1)]) == " ") || (String(Array(s)[start..<(start &+ 1)]) == "\t"))) {
        start = Int((start &+ 1))
    }
    var end: Int = Int(((s).count))
    while ((end > start) && ((String(Array(s)[(end &- 1)..<end]) == " ") || (String(Array(s)[(end &- 1)..<end]) == "\t"))) {
        end = Int((end &- 1))
    }
    return String(describing: String(Array(String(describing: (s as! String)))[(start as! Int)..<(end as! Int)]))
}
func split(_ s: String, _ sep: String) -> [String] {
    var parts: [String] = ([] as! [String])
    var cur: String = ""
    var i: Int = 0
    while (i < Int(((s).count))) {
        if (((Int(((sep).count)) > 0) && ((i &+ Int(((sep).count))) <= Int(((s).count)))) && (String(describing: String(Array(String(describing: (s as! String)))[(i as! Int)..<Int((i &+ Int(((sep).count))))])) == sep)) {
            parts = (_append(parts, cur) as! [String])
            cur = ""
            i = Int((i &+ Int(((sep).count))))
        } else {
            cur = ((cur + String(describing: String(Array(String(describing: (s as! String)))[(i as! Int)..<Int((i &+ 1))]))) as! String)
            i = Int((i &+ 1))
        }
    }
    parts = (_append(parts, cur) as! [String])
    return parts
}
func main() {
    let programText = (((((((((((((((((((("Datasize: 1 Strings: 2\n" + "\"count is: \"\n") + "\"\\n\"\n") + "    0 push  1\n") + "    5 store [0]\n") + "   10 fetch [0]\n") + "   15 push  10\n") + "   20 lt\n") + "   21 jz     (43) 65\n") + "   26 push  0\n") + "   31 prts\n") + "   32 fetch [0]\n") + "   37 prti\n") + "   38 push  1\n") + "   43 prts\n") + "   44 fetch [0]\n") + "   49 push  1\n") + "   54 add\n") + "   55 store [0]\n") + "   60 jmp    (-51) 10\n") + "   65 halt\n")
    let prog: [String: Any?] = (parseProgram((programText as! String)) as! [String: Any?])
    _ = runVM((prog as! [String: Any?]))
}
_ = main()
