// Generated by Mochi transpiler v0.10.50 on 2025-07-31 00:25:50 GMT+7
import Foundation

func _p(_ v: Any?) -> String {
    if let val = v { return String(describing: val) }
    return "<nil>"
}

var _nowSeed = 0
var _nowSeeded = false
func _now() -> Int {
    if !_nowSeeded {
        if let s = ProcessInfo.processInfo.environment["MOCHI_NOW_SEED"], let v = Int(s) {
            _nowSeed = v
            _nowSeeded = true
        }
    }
    if _nowSeeded {
        _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647
        return _nowSeed
    }
    return Int(Date().timeIntervalSince1970 * 1_000_000_000)
}
func _mem() -> Int {
    if let status = try? String(contentsOfFile: "/proc/self/status") {
        for line in status.split(separator: "\n") {
            if line.hasPrefix("VmRSS:") {
                let parts = line.split(whereSeparator: { $0 == " " || $0 == "\t" })
                if parts.count >= 2, let kb = Int(parts[1]) {
                    return kb * 1024
                }
            }
        }
    }
    return 0
}
func _append<T>(_ xs: [T], _ v: T) -> [T] {
    var out = xs
    out.append(v)
    return out
}
do {
    let _benchMemStart = _mem()
    let _benchStart = _now()
    func randInt(_ seed: Int, _ n: Int) -> [Int] {
        let next = (Int(((seed * 1664525) + 1013904223)) % 2147483647)
        return ([next, (next % n)] as! [Int])
    }
    func newBoard(_ n: Int, _ seed: Int) -> [Any?] {
        var board: [[Int]] = ([] as! [[Int]])
        var s: Int = seed
        var i: Int = 0
        while (i < n) {
            var row: [Int] = ([] as! [Int])
            var j: Int = 0
            while (j < n) {
                var r: [Int] = (randInt((s as! Int), 2) as! [Int])
                s = (r[0] as! Int)
                row = (_append(row, (r[1] as! Int)) as! [Int])
                j = ((j + 1) as! Int)
            }
            board = (_append(board, row) as! [[Int]])
            i = ((i + 1) as! Int)
        }
        return ([board, s] as! [Any])
    }
    func copyBoard(_ b: [[Int]]) -> [[Int]] {
        var nb: [[Int]] = ([] as! [[Int]])
        var i: Int = 0
        while (i < Int(((b).count))) {
            var row: [Int] = ([] as! [Int])
            var j: Int = 0
            while (j < Int((((b[i] as! [Int])).count))) {
                row = (_append(row, (b[i][j] as! Int)) as! [Int])
                j = ((j + 1) as! Int)
            }
            nb = (_append(nb, row) as! [[Int]])
            i = ((i + 1) as! Int)
        }
        return (nb as! [[Int]])
    }
    func flipRow(_ b: inout [[Int]], _ r: Int) -> [[Int]] {
        var j: Int = 0
        while (j < Int((((b[r] as! [Int])).count))) {
            b[r][j] = ((1 - (b[r][j] as! Int)) as! Int)
            j = ((j + 1) as! Int)
        }
        return (b as! [[Int]])
    }
    func flipCol(_ b: inout [[Int]], _ c: Int) -> [[Int]] {
        var i: Int = 0
        while (i < Int(((b).count))) {
            b[i][c] = ((1 - (b[i][c] as! Int)) as! Int)
            i = ((i + 1) as! Int)
        }
        return (b as! [[Int]])
    }
    func boardsEqual(_ a: [[Int]], _ b: [[Int]]) -> Bool {
        var i: Int = 0
        while (i < Int(((a).count))) {
            var j: Int = 0
            while (j < Int((((a[i] as! [Int])).count))) {
                if ((a[i][j] as! Int) != (b[i][j] as! Int)) {
                    return false
                }
                j = ((j + 1) as! Int)
            }
            i = ((i + 1) as! Int)
        }
        return true
    }
    func shuffleBoard(_ b: inout [[Int]], _ seed: Int) -> [Any?] {
        var s: Int = seed
        var n: Int = Int(((b).count))
        var k: Int = 0
        while (k < (2 * n)) {
            var r: [Int] = (randInt((s as! Int), (n as! Int)) as! [Int])
            s = (r[0] as! Int)
            let idx = (r[1] as! Int)
            if ((k % 2) == 0) {
                b = (flipRow(&b, (idx as! Int)) as! [[Int]])
            } else {
                b = (flipCol(&b, (idx as! Int)) as! [[Int]])
            }
            k = ((k + 1) as! Int)
        }
        return ([b, s] as! [Any])
    }
    func solve(_ board: [[Int]], _ target: [[Int]]) -> [String: [Int]] {
        let n = Int(((board).count))
        var row: [Int] = ([] as! [Int])
        var col: [Int] = ([] as! [Int])
        var i: Int = 0
        while (i < n) {
            let diff = Int((((board[i][0] as! Int) != (target[i][0] as! Int)) ? 1 : 0))
            row = (_append(row, diff) as! [Int])
            i = ((i + 1) as! Int)
        }
        var j: Int = 0
        while (j < n) {
            let diff = Int((((board[0][j] as! Int) != (target[0][j] as! Int)) ? 1 : 0))
            let val = (Int((diff + (row[0] as! Int))) % 2)
            col = (_append(col, val) as! [Int])
            j = ((j + 1) as! Int)
        }
        return (["row": row, "col": col] as! [String: [Int]])
    }
    func applySolution(_ b: [[Int]], _ sol: [String: [Int]]) -> [Any?] {
        var board: [[Int]] = b
        var moves: Int = 0
        var i: Int = 0
        while (i < Int(((sol["row"]!).count))) {
            if ((sol["row"]![i] as! Int) == 1) {
                board = (flipRow(&board, (i as! Int)) as! [[Int]])
                moves = ((moves + 1) as! Int)
            }
            i = ((i + 1) as! Int)
        }
        var j: Int = 0
        while (j < Int(((sol["col"]!).count))) {
            if ((sol["col"]![j] as! Int) == 1) {
                board = (flipCol(&board, (j as! Int)) as! [[Int]])
                moves = ((moves + 1) as! Int)
            }
            j = ((j + 1) as! Int)
        }
        return ([board, moves] as! [Any])
    }
    func printBoard(_ b: [[Int]]) {
        var i: Int = 0
        while (i < Int(((b).count))) {
            var line: String = ""
            var j: Int = 0
            while (j < Int((((b[i] as! [Int])).count))) {
                line = ((line + _p((b[i][j] as! Int))) as! String)
                if (j < (Int((((b[i] as! [Int])).count)) - 1)) {
                    line = ((line + " ") as! String)
                }
                j = ((j + 1) as! Int)
            }
            print(_p(line))
            i = ((i + 1) as! Int)
        }
    }
    func main() {
        let n = 3
        var seed: Int = 1
        var res: [Any] = (newBoard((n as! Int), (seed as! Int)) as! [Any])
        var target: [[Int]] = (res[0] as! [[Int]])
        seed = (res[1] as! Int)
        var board: [[Int]] = (copyBoard((target as! [[Int]])) as! [[Int]])
        while true {
            var sres: [Any] = ({ () -> Any in
            var _tmp0 = copyBoard((board as! [[Int]]))
            return shuffleBoard(&_tmp0, (seed as! Int))
        }() as! [Any])
        board = (sres[0] as! [[Int]])
        seed = (sres[1] as! Int)
        if (!boardsEqual((board as! [[Int]]), (target as! [[Int]]))) {
            break
        }
    }
    print(_p("Target:"))
    _ = printBoard((target as! [[Int]]))
    print(_p("Board:"))
    _ = printBoard((board as! [[Int]]))
    let sol: [String: [Int]] = (solve((board as! [[Int]]), (target as! [[Int]])) as! [String: [Int]])
    var ares: [Any] = (applySolution((board as! [[Int]]), (sol as! [String: [Int]])) as! [Any])
    board = (ares[0] as! [[Int]])
    let moves = (ares[1] as! Int)
    print(_p("Solved:"))
    _ = printBoard((board as! [[Int]]))
    print(_p(("Moves: " + _p(moves))))
}
_ = main()
let _benchEnd = _now()
let _benchMemEnd = _mem()
print("{\n  \"duration_us\": \((_benchEnd - _benchStart) / 1000),\n  \"memory_bytes\": \(_benchMemEnd - _benchMemStart),\n  \"name\": \"main\"\n}")
}
