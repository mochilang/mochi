// Generated by Mochi transpiler v0.10.38 on 2025-07-23 23:37:35 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <type_traits>
#include <iomanip>
#include <optional>
#include <cstdlib>
#include <chrono>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}


struct MoveResult {
    int idx;
    bool ok;
    auto operator<=>(const MoveResult&) const = default;
};

std::ostream& operator<<(std::ostream& os, const MoveResult& v) {
    os << '{' << "'idx': "<< v.idx
 << ", " << "'ok': "<< v.ok
 << '}';
    return os;
}

int randMove();
bool isSolved();
MoveResult isValidMove(int m);
bool doMove(int m);
void shuffle(int n);
void printBoard();
void playOneMove();
void play();
int main();

std::vector<int> board = std::vector{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};
std::vector<int> solved = std::vector{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};
int empty = 15;
int moves = 0;
bool quit = false;

int randMove() {
    return (_now() % 4);
}

bool isSolved() {
    int i = 0;
    while ((i < 16)) {
        if ((board[i] != solved[i])) {
            return false;
        }
        i = (i + 1);
    }
    return true;
}

MoveResult isValidMove(int m) {
    if ((m == 0)) {
        return MoveResult{.idx = (empty - 4), .ok = ((empty / 4) > 0)};
    }
    if ((m == 1)) {
        return MoveResult{.idx = (empty + 4), .ok = ((empty / 4) < 3)};
    }
    if ((m == 2)) {
        return MoveResult{.idx = (empty + 1), .ok = ((empty % 4) < 3)};
    }
    if ((m == 3)) {
        return MoveResult{.idx = (empty - 1), .ok = ((empty % 4) > 0)};
    }
    return MoveResult{.idx = 0, .ok = false};
}

bool doMove(int m) {
    MoveResult r = isValidMove(m);
    if (!r.ok) {
        return false;
    }
    int i = empty;
    int j = r.idx;
    int tmp = board[i];
    board[i] = board[j];
    board[j] = tmp;
    empty = j;
    moves = (moves + 1);
    return true;
}

void shuffle(int n) {
    int i = 0;
    while (((i < n) || isSolved())) {
        if (doMove(randMove())) {
            i = (i + 1);
        }
    }
}

void printBoard() {
    std::string line = std::string("");
    int i = 0;
    while ((i < 16)) {
        int val = board[i];
        if ((val == 0)) {
            line = (line + std::string("  ."));
        } else {
            std::string s = ([&]{ std::ostringstream ss; ss<<val; return ss.str(); }());
            if ((val < 10)) {
                line = ((line + std::string("  ")) + s);
            } else {
                line = ((line + std::string(" ")) + s);
            }
        }
        if (((i % 4) == 3)) {
            std::cout << line;
            std::cout << std::endl;
            line = std::string("");
        }
        i = (i + 1);
    }
}

void playOneMove() {
    while (true) {
        std::cout << ((std::string("Enter move #") + ([&]{ std::ostringstream ss; ss<<(moves + 1); return ss.str(); }())) + std::string(" (U, D, L, R, or Q): "));
        std::cout << std::endl;
        std::string s = ([&]{ std::string __line; std::getline(std::cin, __line); return __line; }());
        if ((s == std::string(""))) {
            continue;
        }
        std::string c = ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(0, 1 - 0); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+0, c.begin()+1); })(s);
        int m = 0;
        if (((c == std::string("U")) || (c == std::string("u")))) {
            m = 0;
        } else         if (((c == std::string("D")) || (c == std::string("d")))) {
            m = 1;
        } else         if (((c == std::string("R")) || (c == std::string("r")))) {
            m = 2;
        } else         if (((c == std::string("L")) || (c == std::string("l")))) {
            m = 3;
        } else         if (((c == std::string("Q")) || (c == std::string("q")))) {
            std::cout << ((std::string("Quiting after ") + ([&]{ std::ostringstream ss; ss<<moves; return ss.str(); }())) + std::string(" moves."));
            std::cout << std::endl;
            quit = true;
            return;
        } else {
            std::cout << (((std::string("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n") + std::string("up, down, left, or right. You can also enter \"Q\" to quit.\n")) + std::string("Upper or lowercase is accepted and only the first non-blank\n")) + std::string("character is important (i.e. you may enter \"up\" if you like)."));
            std::cout << std::endl;
            continue;
        }




        if (!doMove(m)) {
            std::cout << std::string("That is not a valid move at the moment.");
            std::cout << std::endl;
            continue;
        }
        return;
    }
}

void play() {
    std::cout << std::string("Starting board:");
    std::cout << std::endl;
    while ((!quit && (isSolved() == false))) {
        std::cout << std::string("");
        std::cout << std::endl;
        printBoard();
        playOneMove();
    }
    if (isSolved()) {
        std::cout << ((std::string("You solved the puzzle in ") + ([&]{ std::ostringstream ss; ss<<moves; return ss.str(); }())) + std::string(" moves."));
        std::cout << std::endl;
    }
}

int main() {
    shuffle(50);
    play();
    return 0;
}
