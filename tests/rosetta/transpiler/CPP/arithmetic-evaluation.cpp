// Generated by Mochi transpiler v0.10.40 on 2025-07-25 21:22:40 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <type_traits>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <optional>
#include <cstdlib>
#include <chrono>
#include <sys/resource.h>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}
static long _mem() {
    struct rusage usage{};
    getrusage(RUSAGE_SELF, &usage);
#ifdef __APPLE__
    return usage.ru_maxrss;
#else
    return usage.ru_maxrss * 1024;
#endif
}
template<typename T> std::string _to_string(const T& v) {
    std::ostringstream ss;
    ss << std::boolalpha << v;
    return ss.str();
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ", "; os << vec[i]; }
    os << "]";
    return os;
}



struct Parser {
    std::string expr;
    int pos;
    auto operator<=>(const Parser&) const = default;
};

struct Res {
    int v;
    Parser p;
    auto operator<=>(const Res&) const = default;
};

std::ostream& operator<<(std::ostream& os, const Parser& v) {
    os << '{' << "'expr': "<< "'" << v.expr << "'"
 << ", " << "'pos': "<< v.pos
 << '}';
    return os;
}

std::ostream& operator<<(std::ostream& os, const Res& v) {
    os << '{' << "'v': "<< v.v
 << ", " << "'p': "<< v.p
 << '}';
    return os;
}

Parser skipWS(Parser p);
int parseIntStr(std::string str);
Res parseNumber(Parser p);
Res parseFactor(Parser p);
int powInt(int base, int exp);
Res parsePower(Parser p);
Res parseTerm(Parser p);
Res parseExpr(Parser p);
int evalExpr(std::string expr);
int main();

Parser skipWS(Parser p) {
    int i = p.pos;
    while (((i < p.expr.size()) && (p.expr.substr(i, (i + 1) - i) == std::string(" ")))) {
        i = (i + 1);
    }
    p.pos = i;
    return p;
}

int parseIntStr(std::string str) {
    int i = 0;
    int n = 0;
    while ((i < str.size())) {
        n = (((n * 10) + std::stoi(([&](const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__v)>, std::string>) return __v.substr(i, (i + 1) - i); else return std::vector<typename std::decay_t<decltype(__v)>::value_type>(__v.begin()+i, __v.begin()+(i + 1)); })(str))) - 48);
        i = (i + 1);
    }
    return n;
}

Res parseNumber(Parser p) {
    p = skipWS(p);
    int start = p.pos;
    while ((p.pos < p.expr.size())) {
        std::string ch = p.expr.substr(p.pos, (p.pos + 1) - p.pos);
        if (((ch >= std::string("0")) && (ch <= std::string("9")))) {
            p.pos = (p.pos + 1);
        } else {
            break;
        }
    }
    std::string token = p.expr.substr(start, p.pos - start);
    return Res{parseIntStr(token), p};
}

Res parseFactor(Parser p) {
    p = skipWS(p);
    if (((p.pos < p.expr.size()) && (p.expr.substr(p.pos, (p.pos + 1) - p.pos) == std::string("(")))) {
        p.pos = (p.pos + 1);
        Res r = parseExpr(p);
        int v = r.v;
        p = r.p;
        p = skipWS(p);
        if (((p.pos < p.expr.size()) && (p.expr.substr(p.pos, (p.pos + 1) - p.pos) == std::string(")")))) {
            p.pos = (p.pos + 1);
        }
        return Res{v, p};
    }
    if (((p.pos < p.expr.size()) && (p.expr.substr(p.pos, (p.pos + 1) - p.pos) == std::string("-")))) {
        p.pos = (p.pos + 1);
        Res r = parseFactor(p);
        int v = r.v;
        p = r.p;
        return Res{-v, p};
    }
    return parseNumber(p);
}

int powInt(int base, int exp) {
    int r = 1;
    int b = base;
    int e = exp;
    while ((e > 0)) {
        if (((e % 2) == 1)) {
            r = (r * b);
        }
        b = (b * b);
        e = (e / (int)(2));
    }
    return r;
}

Res parsePower(Parser p) {
    Res r = parseFactor(p);
    int v = r.v;
    p = r.p;
    while (true) {
        p = skipWS(p);
        if (((p.pos < p.expr.size()) && (p.expr.substr(p.pos, (p.pos + 1) - p.pos) == std::string("^")))) {
            p.pos = (p.pos + 1);
            Res r2 = parseFactor(p);
            int rhs = r2.v;
            p = r2.p;
            v = powInt(v, rhs);
        } else {
            break;
        }
    }
    return Res{v, p};
}

Res parseTerm(Parser p) {
    Res r = parsePower(p);
    int v = r.v;
    p = r.p;
    while (true) {
        p = skipWS(p);
        if ((p.pos < p.expr.size())) {
            std::string op = p.expr.substr(p.pos, (p.pos + 1) - p.pos);
            if ((op == std::string("*"))) {
                p.pos = (p.pos + 1);
                Res r2 = parsePower(p);
                int rhs = r2.v;
                p = r2.p;
                v = (v * rhs);
                continue;
            }
            if ((op == std::string("/"))) {
                p.pos = (p.pos + 1);
                Res r2 = parsePower(p);
                int rhs = r2.v;
                p = r2.p;
                v = (v / (int)(rhs));
                continue;
            }
        }
        break;
    }
    return Res{v, p};
}

Res parseExpr(Parser p) {
    Res r = parseTerm(p);
    int v = r.v;
    p = r.p;
    while (true) {
        p = skipWS(p);
        if ((p.pos < p.expr.size())) {
            std::string op = p.expr.substr(p.pos, (p.pos + 1) - p.pos);
            if ((op == std::string("+"))) {
                p.pos = (p.pos + 1);
                Res r2 = parseTerm(p);
                int rhs = r2.v;
                p = r2.p;
                v = (v + rhs);
                continue;
            }
            if ((op == std::string("-"))) {
                p.pos = (p.pos + 1);
                Res r2 = parseTerm(p);
                int rhs = r2.v;
                p = r2.p;
                v = (v - rhs);
                continue;
            }
        }
        break;
    }
    return Res{v, p};
}

int evalExpr(std::string expr) {
    Parser p = Parser{expr, 0};
    Res r = parseExpr(p);
    return r.v;
}

int main() {
    {
        auto __bench_start = _now();
        auto __bench_mem_start = _mem();
        std::string expr = std::string("2*(3-1)+2*5");
        std::cout << ((expr + std::string(" = ")) + ([&]{ std::ostringstream ss; ss << std::boolalpha << evalExpr(expr); return ss.str(); }()));
        std::cout << std::endl;
        auto __bench_end = _now();
        auto __bench_mem_end = _mem();
        auto __bench_dur = __bench_end - __bench_start;
        auto __bench_mem = __bench_mem_end;
        std::cout << "{\n  \"duration_us\": " << __bench_dur << ",\n  \"memory_bytes\": " << __bench_mem << ",\n  \"name\": \"main\"\n}" << std::endl;
    }
    return 0;
}
