// Generated by Mochi transpiler v0.10.56 on 2025-08-04 10:47:46 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <any>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <optional>
#include <type_traits>
#include <map>


static void any_to_stream(std::ostream& os, const std::any& val) {
    if(val.type() == typeid(int)) os << std::any_cast<int>(val);
    else if(val.type() == typeid(int64_t)) os << std::any_cast<int64_t>(val);
    else if(val.type() == typeid(double)) os << std::any_cast<double>(val);
    else if(val.type() == typeid(bool)) os << (std::any_cast<bool>(val) ? "true" : "false");
    else if(val.type() == typeid(std::string)) os << std::any_cast<std::string>(val);
    else if(val.type() == typeid(std::vector<int64_t>)) { const auto& v = std::any_cast<const std::vector<int64_t>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::vector<int64_t>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int64_t>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; any_to_stream(os, v[i]); } os << ']'; }
    else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
    else os << "<any>";
}
static double any_to_double(const std::any& v) {
    if(v.type() == typeid(int)) return (double)std::any_cast<int>(v);
    if(v.type() == typeid(double)) return std::any_cast<double>(v);
    return 0;
}
static std::string any_to_string(const std::any& v) {
    if(v.type() == typeid(std::string)) return std::any_cast<std::string>(v);
    if(v.type() == typeid(int)) return std::to_string(std::any_cast<int>(v));
    if(v.type() == typeid(int64_t)) return std::to_string(std::any_cast<int64_t>(v));
    if(v.type() == typeid(double)) { std::ostringstream ss; ss << std::any_cast<double>(v); return ss.str(); }
    if(v.type() == typeid(bool)) return std::any_cast<bool>(v) ? "true" : "false";
    return std::string();
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ", "; if constexpr(std::is_same_v<T, std::any>) any_to_stream(os, vec[i]); else os << vec[i]; }
    os << "]";
    return os;
}


template<typename T> std::string _to_string(const T& v) {
    std::ostringstream ss;
    ss << std::boolalpha << v;
    return ss.str();
}
struct Airport;

std::ostream& operator<<(std::ostream&, const Airport&);


struct Airport {
    std::string name;
    std::string country;
    std::string icao;
    double lat;
    double lon;
    auto operator<=>(const Airport&) const = default;
};

std::ostream& operator<<(std::ostream& os, const Airport& v) {
    os << '{' << "'name': "<< "'" << v.name << "'"
 << ", " << "'country': "<< "'" << v.country << "'"
 << ", " << "'icao': "<< "'" << v.icao << "'"
 << ", " << "'lat': "<< std::fixed << std::setprecision(1) << v.lat
 << ", " << "'lon': "<< std::fixed << std::setprecision(1) << v.lon
 << '}';
    return os;
}

double sinApprox(double x);
double cosApprox(double x);
double atanApprox(double x);
double atan2Approx(double y, double x);
double sqrtApprox(double x);
double rad(double x);
double deg(double x);
double distance(double lat1, double lon1, double lat2, double lon2);
double bearing(double lat1, double lon1, double lat2, double lon2);
double floor(double x);
double pow10(int64_t n);
double round(double x, int64_t n);
std::vector<std::vector<std::any>> sortByDistance(const std::vector<std::vector<std::any>>& xs);
int main();

double PI = 3.141592653589793;
std::vector<Airport> airports = std::vector<Airport>{Airport{.name = std::string("Koksijde Air Base"), .country = std::string("Belgium"), .icao = std::string("EBFN"), .lat = 51.090301513671875, .lon = 2.652780055999756}, Airport{.name = std::string("Ostend-Bruges International Airport"), .country = std::string("Belgium"), .icao = std::string("EBOS"), .lat = 51.198898315399994, .lon = 2.8622200489}, Airport{.name = std::string("Kent International Airport"), .country = std::string("United Kingdom"), .icao = std::string("EGMH"), .lat = 51.342201, .lon = 1.34611}, Airport{.name = std::string("Calais-Dunkerque Airport"), .country = std::string("France"), .icao = std::string("LFAC"), .lat = 50.962100982666016, .lon = 1.954759955406189}, Airport{.name = std::string("Westkapelle heliport"), .country = std::string("Belgium"), .icao = std::string("EBKW"), .lat = 51.32222366333, .lon = 3.2930560112}, Airport{.name = std::string("Lympne Airport"), .country = std::string("United Kingdom"), .icao = std::string("EGMK"), .lat = 51.08, .lon = 1.013}, Airport{.name = std::string("Ursel Air Base"), .country = std::string("Belgium"), .icao = std::string("EBUL"), .lat = 51.14419937133789, .lon = 3.475559949874878}, Airport{.name = std::string("Southend Airport"), .country = std::string("United Kingdom"), .icao = std::string("EGMC"), .lat = 51.5713996887207, .lon = 0.6955559849739075}, Airport{.name = std::string("Merville-Calonne Airport"), .country = std::string("France"), .icao = std::string("LFQT"), .lat = 50.61840057373047, .lon = 2.642240047454834}, Airport{.name = std::string("Wevelgem Airport"), .country = std::string("Belgium"), .icao = std::string("EBKT"), .lat = 50.817199707, .lon = 3.20472002029}, Airport{.name = std::string("Midden-Zeeland Airport"), .country = std::string("Netherlands"), .icao = std::string("EHMZ"), .lat = 51.5121994019, .lon = 3.73111009598}, Airport{.name = std::string("Lydd Airport"), .country = std::string("United Kingdom"), .icao = std::string("EGMD"), .lat = 50.95610046386719, .lon = 0.9391670227050781}, Airport{.name = std::string("RAF Wattisham"), .country = std::string("United Kingdom"), .icao = std::string("EGUW"), .lat = 52.1273002625, .lon = 0.956264019012}, Airport{.name = std::string("Beccles Airport"), .country = std::string("United Kingdom"), .icao = std::string("EGSM"), .lat = 52.435298919699996, .lon = 1.6183300018300002}, Airport{.name = std::string("Lille/Marcq-en-Baroeul Airport"), .country = std::string("France"), .icao = std::string("LFQO"), .lat = 50.687198638916016, .lon = 3.0755600929260254}, Airport{.name = std::string("Lashenden (Headcorn) Airfield"), .country = std::string("United Kingdom"), .icao = std::string("EGKH"), .lat = 51.156898, .lon = 0.641667}, Airport{.name = std::string("Le Touquet-CÃ´te d'Opale Airport"), .country = std::string("France"), .icao = std::string("LFAT"), .lat = 50.517398834228516, .lon = 1.6205899715423584}, Airport{.name = std::string("Rochester Airport"), .country = std::string("United Kingdom"), .icao = std::string("EGTO"), .lat = 51.351898193359375, .lon = 0.5033329725265503}, Airport{.name = std::string("Lille-Lesquin Airport"), .country = std::string("France"), .icao = std::string("LFQQ"), .lat = 50.563332, .lon = 3.086886}, Airport{.name = std::string("Thurrock Airfield"), .country = std::string("United Kingdom"), .icao = std::string("EGMT"), .lat = 51.537505, .lon = 0.367634}};

double sinApprox(double x) {
    double term = x;
    double sum = x;
    int64_t n = int64_t(1);
    while ((n <= int64_t(8))) {
        double denom = (double)(((int64_t(2) * n) * ((int64_t(2) * n) + int64_t(1))));
        term = ((double)(((-term * x) * x)) / (denom));
        sum = (sum + term);
        n = (n + int64_t(1));
    }
    return sum;
}

double cosApprox(double x) {
    double term = 1.0;
    double sum = 1.0;
    int64_t n = int64_t(1);
    while ((n <= int64_t(8))) {
        double denom = (double)((((int64_t(2) * n) - int64_t(1)) * (int64_t(2) * n)));
        term = ((double)(((-term * x) * x)) / (denom));
        sum = (sum + term);
        n = (n + int64_t(1));
    }
    return sum;
}

double atanApprox(double x) {
    if ((x > 1.0)) {
        return (((double)(PI) / (2.0)) - ((double)(x) / (((x * x) + 0.28))));
    }
    if ((x < -1.0)) {
        return (((double)(-PI) / (2.0)) - ((double)(x) / (((x * x) + 0.28))));
    }
    return ((double)(x) / ((1.0 + ((0.28 * x) * x))));
}

double atan2Approx(double y, double x) {
    if ((x > 0.0)) {
        double r = atanApprox(((double)(y) / (x)));
        return r;
    }
    if ((x < 0.0)) {
        if ((y >= 0.0)) {
            return (atanApprox(((double)(y) / (x))) + PI);
        }
        return (atanApprox(((double)(y) / (x))) - PI);
    }
    if ((y > 0.0)) {
        return ((double)(PI) / (2.0));
    }
    if ((y < 0.0)) {
        return ((double)(-PI) / (2.0));
    }
    return 0.0;
}

double sqrtApprox(double x) {
    double guess = x;
    int64_t i = int64_t(0);
    while ((i < int64_t(10))) {
        guess = ((double)((guess + ((double)(x) / (guess)))) / (2.0));
        i = (i + int64_t(1));
    }
    return guess;
}

double rad(double x) {
    return ((double)((x * PI)) / (180.0));
}

double deg(double x) {
    return ((double)((x * 180.0)) / (PI));
}

double distance(double lat1, double lon1, double lat2, double lon2) {
    double phi1 = rad(lat1);
    double phi2 = rad(lat2);
    double dphi = rad((lat2 - lat1));
    double dlambda = rad((lon2 - lon1));
    double sdphi = sinApprox(((double)(dphi) / (int64_t(2))));
    double sdlambda = sinApprox(((double)(dlambda) / (int64_t(2))));
    double a = ((sdphi * sdphi) + (((cosApprox(phi1) * cosApprox(phi2)) * sdlambda) * sdlambda));
    double c = (int64_t(2) * atan2Approx(sqrtApprox(a), sqrtApprox((int64_t(1) - a))));
    return (((double)(6371.0) / (1.852)) * c);
}

double bearing(double lat1, double lon1, double lat2, double lon2) {
    double phi1 = rad(lat1);
    double phi2 = rad(lat2);
    double dl = rad((lon2 - lon1));
    double y = (sinApprox(dl) * cosApprox(phi2));
    double x = ((cosApprox(phi1) * sinApprox(phi2)) - ((sinApprox(phi1) * cosApprox(phi2)) * cosApprox(dl)));
    double br = deg(atan2Approx(y, x));
    if ((br < int64_t(0))) {
        br = (br + int64_t(360));
    }
    return br;
}

double floor(double x) {
    int64_t i = (int64_t)(x);
    if (((double)(i) > x)) {
        i = (i - int64_t(1));
    }
    return (double)(i);
}

double pow10(int64_t n) {
    double p = 1.0;
    int64_t i = int64_t(0);
    while ((i < n)) {
        p = (p * 10.0);
        i = (i + int64_t(1));
    }
    return p;
}

double round(double x, int64_t n) {
    double m = pow10(n);
    return ((double)(floor(((x * m) + 0.5))) / (m));
}

std::vector<std::vector<std::any>> sortByDistance(const std::vector<std::vector<std::any>>& xs) {
    std::vector<std::vector<std::any>> arr = xs;
    int64_t i = int64_t(1);
    while ((i < static_cast<int64_t>(arr.size()))) {
        int64_t j = i;
        while (((j > int64_t(0)) && (any_to_double(arr[(j - int64_t(1))][int64_t(0)]) > any_to_double(arr[j][int64_t(0)])))) {
            std::vector<std::any> tmp = arr[(j - int64_t(1))];
            arr[(j - int64_t(1))] = arr[j];
            arr[j] = tmp;
            j = (j - int64_t(1));
        }
        i = (i + int64_t(1));
    }
    return arr;
}

int main() {
    double planeLat = 51.514669;
    double planeLon = 2.198581;
    std::vector<std::vector<std::any>> results = {};
    for (Airport ap : airports) {
        double d = distance(planeLat, planeLon, ap.lat, ap.lon);
        double b = bearing(planeLat, planeLon, ap.lat, ap.lon);
        results = ([&]{ auto __tmp = results; __tmp.push_back(std::vector<std::any>{std::any(d), std::any(b), std::any(ap)}); return __tmp; }());
    }
    results = sortByDistance(results);
    std::cout << std::string("Distance Bearing ICAO Country               Airport");
    std::cout << std::endl;
    std::cout << std::string("--------------------------------------------------------------");
    std::cout << std::endl;
    int64_t i = int64_t(0);
    while ((i < static_cast<int64_t>(results.size()))) {
        std::vector<std::any> r = results[i];
        std::any ap = r[int64_t(2)];
        std::any dist = r[int64_t(0)];
        std::any bear = r[int64_t(1)];
        std::string line = ((((((((([&]{ std::ostringstream ss; ss << std::boolalpha << round(std::any_cast<double>(dist), int64_t(1)); return ss.str(); }()) + std::string("\t")) + ([&]{ std::ostringstream ss; ss << std::boolalpha << round(std::any_cast<double>(bear), int64_t(0)); return ss.str(); }())) + std::string("\t")) + std::any_cast<Airport>(ap).icao) + std::string("\t")) + std::any_cast<Airport>(ap).country) + std::string(" ")) + std::any_cast<Airport>(ap).name);
        std::cout << line;
        std::cout << std::endl;
        i = (i + int64_t(1));
    }
    return 0;
}
