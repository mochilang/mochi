// Generated by Mochi transpiler v0.10.39 on 2025-07-24 19:20:11 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <type_traits>
#include <sstream>
#include <any>
#include <iomanip>
#include <cmath>
#include <optional>
#include <cstdlib>
#include <chrono>
#include <map>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}
static void any_to_stream(std::ostream& os, const std::any& val) {
    if(val.type() == typeid(int)) os << std::any_cast<int>(val);
    else if(val.type() == typeid(double)) os << std::any_cast<double>(val);
    else if(val.type() == typeid(bool)) os << (std::any_cast<bool>(val) ? "true" : "false");
    else if(val.type() == typeid(std::string)) os << std::any_cast<std::string>(val);
    else if(val.type() == typeid(std::vector<int>)) { const auto& v = std::any_cast<const std::vector<int>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::vector<int>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; any_to_stream(os, v[i]); } os << ']'; }
    else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
    else os << "<any>";
}
static double any_to_double(const std::any& v) {
    if(v.type() == typeid(int)) return (double)std::any_cast<int>(v);
    if(v.type() == typeid(double)) return std::any_cast<double>(v);
    return 0;
}

std::string shuffleStr(std::string s);
std::vector<std::string> createPolybius();
std::string createKey(int n);
std::vector<int> orderKey(std::string key);
std::string encrypt(std::vector<std::string>& polybius, std::string key, std::string plainText);
int indexOf(std::string s, std::string ch);
std::string decrypt(std::vector<std::string>& polybius, std::string key, std::string cipherText);
int main();

std::string adfgvx = std::string("ADFGVX");
std::string alphabet = std::string("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");

std::string shuffleStr(std::string s) {
    std::vector<std::string> arr = {};
    int i = 0;
    while ((i < s.size())) {
        arr = ([&]{ auto __tmp = arr; __tmp.push_back(([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(i, (i + 1) - i); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+i, c.begin()+(i + 1)); })(s)); return __tmp; }());
        i = (i + 1);
    }
    int j = (arr.size() - 1);
    while ((j > 0)) {
        auto k = (_now() % (j + 1));
        std::string tmp = arr[j];
        arr[j] = arr[k];
        arr[k] = tmp;
        j = (j - 1);
    }
    std::string out = std::string("");
    i = 0;
    while ((i < arr.size())) {
        out = (out + arr[i]);
        i = (i + 1);
    }
    return out;
}

std::vector<std::string> createPolybius() {
    std::string shuffled = shuffleStr(alphabet);
    std::vector<std::string> labels = {};
    int li = 0;
    while ((li < adfgvx.size())) {
        labels = ([&]{ auto __tmp = labels; __tmp.push_back(([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(li, (li + 1) - li); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+li, c.begin()+(li + 1)); })(adfgvx)); return __tmp; }());
        li = (li + 1);
    }
    std::cout << std::string("6 x 6 Polybius square:\n");
    std::cout << std::endl;
    std::cout << std::string("  | A D F G V X");
    std::cout << std::endl;
    std::cout << std::string("---------------");
    std::cout << std::endl;
    std::vector<std::string> p = {};
    int i = 0;
    while ((i < 6)) {
        std::string row = ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr((i * 6), ((i + 1) * 6) - (i * 6)); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+(i * 6), c.begin()+((i + 1) * 6)); })(shuffled);
        p = ([&]{ auto __tmp = p; __tmp.push_back(row); return __tmp; }());
        std::string line = (labels[i] + std::string(" | "));
        int j = 0;
        while ((j < 6)) {
            line = ((line + ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(j, (j + 1) - j); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+j, c.begin()+(j + 1)); })(row)) + std::string(" "));
            j = (j + 1);
        }
        std::cout << line;
        std::cout << std::endl;
        i = (i + 1);
    }
    return p;
}

std::string createKey(int n) {
    if (((n < 7) || (n > 12))) {
        std::cout << std::string("Key should be within 7 and 12 letters long.");
        std::cout << std::endl;
    }
    std::string pool = std::string("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
    std::string key = std::string("");
    int i = 0;
    while ((i < n)) {
        int idx = (_now() % pool.size());
        key = (key + pool[idx]);
        pool = (([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(0, idx - 0); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+0, c.begin()+idx); })(pool) + ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr((idx + 1), pool.size() - (idx + 1)); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+(idx + 1), c.begin()+pool.size()); })(pool));
        i = (i + 1);
    }
    std::cout << (std::string("\nThe key is ") + key);
    std::cout << std::endl;
    return key;
}

std::vector<int> orderKey(std::string key) {
    std::vector<std::vector<int>> pairs = {};
    int i = 0;
    while ((i < key.size())) {
        pairs = ([&]{ auto __tmp = pairs; __tmp.push_back((std::vector<int>)std::vector<std::any>{([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(i, (i + 1) - i); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+i, c.begin()+(i + 1)); })(key), i}); return __tmp; }());
        i = (i + 1);
    }
    int n = pairs.size();
    int m = 0;
    while ((m < n)) {
        int j = 0;
        while ((j < (n - 1))) {
            if ((pairs[j][0] > pairs[(j + 1)][0])) {
                std::vector<int> tmp = pairs[j];
                pairs[j] = pairs[(j + 1)];
                pairs[(j + 1)] = tmp;
            }
            j = (j + 1);
        }
        m = (m + 1);
    }
    std::vector<int> res = {};
    i = 0;
    while ((i < n)) {
        res = ([&]{ auto __tmp = res; __tmp.push_back((int)(pairs[i][1])); return __tmp; }());
        i = (i + 1);
    }
    return res;
}

std::string encrypt(std::vector<std::string>& polybius, std::string key, std::string plainText) {
    std::vector<std::string> labels = {};
    int li = 0;
    while ((li < adfgvx.size())) {
        labels = ([&]{ auto __tmp = labels; __tmp.push_back(([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(li, (li + 1) - li); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+li, c.begin()+(li + 1)); })(adfgvx)); return __tmp; }());
        li = (li + 1);
    }
    std::string temp = std::string("");
    int i = 0;
    while ((i < plainText.size())) {
        int r = 0;
        while ((r < 6)) {
            int c = 0;
            while ((c < 6)) {
                if ((([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(c, (c + 1) - c); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+c, c.begin()+(c + 1)); })(polybius[r]) == ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(i, (i + 1) - i); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+i, c.begin()+(i + 1)); })(plainText))) {
                    temp = (([&]{ std::string __res = temp; const auto& __vec = ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(r, (r + 1) - r); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+r, c.begin()+(r + 1)); })(labels); for(const auto& __e : __vec){ __res += __e; } return __res; }()) + ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(c, (c + 1) - c); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+c, c.begin()+(c + 1)); })(labels));
                }
                c = (c + 1);
            }
            r = (r + 1);
        }
        i = (i + 1);
    }
    int colLen = (temp.size() / key.size());
    if (((temp.size() % key.size()) > 0)) {
        colLen = (colLen + 1);
    }
    std::vector<std::vector<std::string>> table = {};
    int rIdx = 0;
    while ((rIdx < colLen)) {
        std::vector<std::string> row = {};
        int j = 0;
        while ((j < key.size())) {
            row = ([&]{ auto __tmp = row; __tmp.push_back(std::string("")); return __tmp; }());
            j = (j + 1);
        }
        table = ([&]{ auto __tmp = table; __tmp.push_back(row); return __tmp; }());
        rIdx = (rIdx + 1);
    }
    int idx = 0;
    while ((idx < temp.size())) {
        int row = (idx / key.size());
        int col = (idx % key.size());
        table[row][col] = ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(idx, (idx + 1) - idx); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+idx, c.begin()+(idx + 1)); })(temp);
        idx = (idx + 1);
    }
    std::vector<int> order = orderKey(key);
    std::vector<std::string> cols = {};
    int ci = 0;
    while ((ci < key.size())) {
        std::string colStr = std::string("");
        int ri = 0;
        while ((ri < colLen)) {
            colStr = (colStr + table[ri][order[ci]]);
            ri = (ri + 1);
        }
        cols = ([&]{ auto __tmp = cols; __tmp.push_back(colStr); return __tmp; }());
        ci = (ci + 1);
    }
    std::string result = std::string("");
    ci = 0;
    while ((ci < cols.size())) {
        result = (result + cols[ci]);
        if ((ci < (cols.size() - 1))) {
            result = (result + std::string(" "));
        }
        ci = (ci + 1);
    }
    return result;
}

int indexOf(std::string s, std::string ch) {
    int i = 0;
    while ((i < s.size())) {
        if ((([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(i, (i + 1) - i); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+i, c.begin()+(i + 1)); })(s) == ch)) {
            return i;
        }
        i = (i + 1);
    }
    return -1;
}

std::string decrypt(std::vector<std::string>& polybius, std::string key, std::string cipherText) {
    std::vector<std::string> colStrs = {};
    int start = 0;
    int i = 0;
    while ((i <= cipherText.size())) {
        if (((i == cipherText.size()) || (cipherText[i] == std::string(" ")))) {
            colStrs = ([&]{ auto __tmp = colStrs; __tmp.push_back(([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(start, i - start); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+start, c.begin()+i); })(cipherText)); return __tmp; }());
            start = (i + 1);
        }
        i = (i + 1);
    }
    int maxColLen = 0;
    i = 0;
    while ((i < colStrs.size())) {
        if ((colStrs[i].size() > maxColLen)) {
            maxColLen = colStrs[i].size();
        }
        i = (i + 1);
    }
    std::vector<std::vector<std::string>> cols = {};
    i = 0;
    while ((i < colStrs.size())) {
        std::string s = colStrs[i];
        std::vector<std::string> ls = {};
        int j = 0;
        while ((j < s.size())) {
            ls = ([&]{ auto __tmp = ls; __tmp.push_back(([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(j, (j + 1) - j); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+j, c.begin()+(j + 1)); })(s)); return __tmp; }());
            j = (j + 1);
        }
        if ((s.size() < maxColLen)) {
            std::vector<std::string> pad = {};
            int k = 0;
            while ((k < maxColLen)) {
                if ((k < ls.size())) {
                    pad = ([&]{ auto __tmp = pad; __tmp.push_back(ls[k]); return __tmp; }());
                } else {
                    pad = ([&]{ auto __tmp = pad; __tmp.push_back(std::string("")); return __tmp; }());
                }
                k = (k + 1);
            }
            cols = ([&]{ auto __tmp = cols; __tmp.push_back(pad); return __tmp; }());
        } else {
            cols = ([&]{ auto __tmp = cols; __tmp.push_back(ls); return __tmp; }());
        }
        i = (i + 1);
    }
    std::vector<std::vector<std::string>> table = {};
    int r = 0;
    while ((r < maxColLen)) {
        std::vector<std::string> row = {};
        int c = 0;
        while ((c < key.size())) {
            row = ([&]{ auto __tmp = row; __tmp.push_back(std::string("")); return __tmp; }());
            c = (c + 1);
        }
        table = ([&]{ auto __tmp = table; __tmp.push_back(row); return __tmp; }());
        r = (r + 1);
    }
    std::vector<int> order = orderKey(key);
    r = 0;
    while ((r < maxColLen)) {
        int c = 0;
        while ((c < key.size())) {
            table[r][order[c]] = cols[c][r];
            c = (c + 1);
        }
        r = (r + 1);
    }
    std::string temp = std::string("");
    r = 0;
    while ((r < table.size())) {
        int j = 0;
        while ((j < table[r].size())) {
            temp = (temp + table[r][j]);
            j = (j + 1);
        }
        r = (r + 1);
    }
    std::string plainText = std::string("");
    int idx = 0;
    while ((idx < temp.size())) {
        int rIdx = indexOf(adfgvx, ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr(idx, (idx + 1) - idx); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+idx, c.begin()+(idx + 1)); })(temp));
        int cIdx = indexOf(adfgvx, ([&](const auto& c){ if constexpr(std::is_same_v<std::decay_t<decltype(c)>, std::string>) return c.substr((idx + 1), (idx + 2) - (idx + 1)); else return std::vector<typename std::decay_t<decltype(c)>::value_type>(c.begin()+(idx + 1), c.begin()+(idx + 2)); })(temp));
        plainText = (plainText + polybius[rIdx][cIdx]);
        idx = (idx + 2);
    }
    return plainText;
}

int main() {
    std::string plainText = std::string("ATTACKAT1200AM");
    std::vector<std::string> polybius = createPolybius();
    std::string key = createKey(9);
    std::cout << (std::string("\nPlaintext : ") + plainText);
    std::cout << std::endl;
    std::string cipherText = encrypt(polybius, key, plainText);
    std::cout << (std::string("\nEncrypted : ") + cipherText);
    std::cout << std::endl;
    std::string plainText2 = decrypt(polybius, key, cipherText);
    std::cout << (std::string("\nDecrypted : ") + plainText2);
    std::cout << std::endl;
    return 0;
}
