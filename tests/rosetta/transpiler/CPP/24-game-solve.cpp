// Generated by Mochi transpiler v0.10.37 on 2025-07-23 13:36:30 GMT+7
#include <iostream>
#include <string>
#include <any>
#include <map>
#include <sstream>
#include <vector>
#include <iomanip>
#include <optional>
#include <cstdlib>
#include <chrono>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}

std::map<std::string, std::any> newNum(int n);
std::map<std::string, int> exprEval(std::map<std::string, std::any> x);
std::string exprString(std::map<std::string, std::any> x);
bool solve(std::vector<std::map<std::string, std::any>> xs);
int main();

int OP_NUM = 0;
int OP_ADD = 1;
int OP_SUB = 2;
int OP_MUL = 3;
int OP_DIV = 4;
int n_cards = 4;
int goal = 24;
int digit_range = 9;

std::map<std::string, std::any> newNum(int n) {
    return std::map<std::string, std::any>{{"op", std::any(OP_NUM)}, {"value", std::any(std::map<std::string, std::any>{{"num", std::any(n)}, {"denom", std::any(1)}})}};
}

std::map<std::string, int> exprEval(std::map<std::string, std::any> x) {
    if ((std::any_cast<int>(x[std::string("op")]) == OP_NUM)) {
        return std::any_cast<std::map<std::string, int>>(x[std::string("value")]);
    }
    std::map<std::string, int> l = exprEval(std::any_cast<std::map<std::string, std::any>>(x[std::string("left")]));
    std::map<std::string, int> r = exprEval(std::any_cast<std::map<std::string, std::any>>(x[std::string("right")]));
    if ((std::any_cast<int>(x[std::string("op")]) == OP_ADD)) {
        return std::map<std::string, int>{{"num", ((l[std::string("num")] * r[std::string("denom")]) + (l[std::string("denom")] * r[std::string("num")]))}, {"denom", (l[std::string("denom")] * r[std::string("denom")])}};
    }
    if ((std::any_cast<int>(x[std::string("op")]) == OP_SUB)) {
        return std::map<std::string, int>{{"num", ((l[std::string("num")] * r[std::string("denom")]) - (l[std::string("denom")] * r[std::string("num")]))}, {"denom", (l[std::string("denom")] * r[std::string("denom")])}};
    }
    if ((std::any_cast<int>(x[std::string("op")]) == OP_MUL)) {
        return std::map<std::string, int>{{"num", (l[std::string("num")] * r[std::string("num")])}, {"denom", (l[std::string("denom")] * r[std::string("denom")])}};
    }
    return std::map<std::string, int>{{"num", (l[std::string("num")] * r[std::string("denom")])}, {"denom", (l[std::string("denom")] * r[std::string("num")])}};
}

std::string exprString(std::map<std::string, std::any> x) {
    if ((std::any_cast<int>(x[std::string("op")]) == OP_NUM)) {
        return ([&]{ std::ostringstream ss; ss<<std::any_cast<int>(std::any_cast<std::map<std::string, std::any>>(x[std::string("value")])[std::string("num")]); return ss.str(); }());
    }
    std::string ls = exprString(std::any_cast<std::map<std::string, std::any>>(x[std::string("left")]));
    std::string rs = exprString(std::any_cast<std::map<std::string, std::any>>(x[std::string("right")]));
    std::string opstr = std::string("");
    if ((std::any_cast<int>(x[std::string("op")]) == OP_ADD)) {
        opstr = std::string(" + ");
    } else     if ((std::any_cast<int>(x[std::string("op")]) == OP_SUB)) {
        opstr = std::string(" - ");
    } else     if ((std::any_cast<int>(x[std::string("op")]) == OP_MUL)) {
        opstr = std::string(" * ");
    } else {
        opstr = std::string(" / ");
    }


    return ((((std::string("(") + ls) + opstr) + rs) + std::string(")"));
}

bool solve(std::vector<std::map<std::string, std::any>> xs) {
    if ((xs.size() == 1)) {
        std::map<std::string, int> f = exprEval(xs[0]);
        if (((f[std::string("denom")] != 0) && (f[std::string("num")] == (f[std::string("denom")] * goal)))) {
            std::cout << exprString(xs[0]);
            std::cout << std::endl;
            return true;
        }
        return false;
    }
    int i = 0;
    while ((i < xs.size())) {
        int j = (i + 1);
        while ((j < xs.size())) {
            std::vector<std::map<std::string, std::any>> rest = {};
            int k = 0;
            while ((k < xs.size())) {
                if (((k != i) && (k != j))) {
                    rest = ([&]{ auto __tmp = rest; __tmp.push_back(xs[k]); return __tmp; }());
                }
                k = (k + 1);
            }
            std::map<std::string, std::any> a = xs[i];
            std::map<std::string, std::any> b = xs[j];
            for (int op : std::vector{OP_ADD, OP_SUB, OP_MUL, OP_DIV}) {
                std::map<std::string, std::any> node = std::map<std::string, std::any>{{"op", std::any(op)}, {"left", std::any(a)}, {"right", std::any(b)}};
                if (solve((std::vector<std::map<std::string, std::any>>)(([&]{ auto __tmp = rest; __tmp.push_back(node); return __tmp; }())))) {
                    return true;
                }
            }
            std::map<std::string, std::any> node = std::map<std::string, std::any>{{"op", std::any(OP_SUB)}, {"left", std::any(b)}, {"right", std::any(a)}};
            if (solve((std::vector<std::map<std::string, std::any>>)(([&]{ auto __tmp = rest; __tmp.push_back(node); return __tmp; }())))) {
                return true;
            }
            node = std::map<std::string, std::any>{{"op", std::any(OP_DIV)}, {"left", std::any(b)}, {"right", std::any(a)}};
            if (solve((std::vector<std::map<std::string, std::any>>)(([&]{ auto __tmp = rest; __tmp.push_back(node); return __tmp; }())))) {
                return true;
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return false;
}

int main() {
    int iter = 0;
    while ((iter < 10)) {
        std::vector<std::map<std::string, std::any>> cards = {};
        int i = 0;
        while ((i < n_cards)) {
            int n = ((_now() % (digit_range - 1)) + 1);
            cards = ([&]{ auto __tmp = cards; __tmp.push_back((std::map<std::string, std::any>)newNum(n)); return __tmp; }());
            std::cout << (std::string(" ") + ([&]{ std::ostringstream ss; ss<<n; return ss.str(); }()));
            std::cout << std::endl;
            i = (i + 1);
        }
        std::cout << std::string(":  ");
        std::cout << std::endl;
        if (!solve(cards)) {
            std::cout << std::string("No solution");
            std::cout << std::endl;
        }
        iter = (iter + 1);
    }
    return 0;
}
