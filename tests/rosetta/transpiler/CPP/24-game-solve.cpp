// Generated by Mochi transpiler v0.10.40 on 2025-07-25 12:39:15 GMT+7
#include <iostream>
#include <string>
#include <memory>
#include <sstream>
#include <vector>
#include <iomanip>
#include <cmath>
#include <optional>
#include <cstdlib>
#include <chrono>
#include <sys/resource.h>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}
static long _mem() {
    struct rusage usage{};
    getrusage(RUSAGE_SELF, &usage);
#ifdef __APPLE__
    return usage.ru_maxrss;
#else
    return usage.ru_maxrss * 1024;
#endif
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ", "; os << vec[i]; }
    os << "]";
    return os;
}

struct Expr;


struct Rational {
    int num;
    int denom;
    auto operator<=>(const Rational&) const = default;
};

struct Expr {
    virtual ~Expr() = default;
};

struct Num : Expr {
    Rational value;
    Num(Rational value_) : value(value_) {}
    auto operator<=>(const Num&) const = default;
};

struct Bin : Expr {
    int op;
    std::shared_ptr<Expr> left;
    std::shared_ptr<Expr> right;
    Bin(int op_, std::shared_ptr<Expr> left_, std::shared_ptr<Expr> right_) : op(op_), left(std::move(left_)), right(std::move(right_)) {}
    auto operator<=>(const Bin&) const = default;
};

std::ostream& operator<<(std::ostream& os, const Rational& v) {
    os << '{' << "'num': "<< v.num
 << ", " << "'denom': "<< v.denom
 << '}';
    return os;
}

std::ostream& operator<<(std::ostream& os, const Num& v) {
    os << '{' << "'value': "<< v.value
 << '}';
    return os;
}

std::ostream& operator<<(std::ostream& os, const Bin& v) {
    os << '{' << "'op': "<< v.op
 << ", " << "'left': "<< v.left
 << ", " << "'right': "<< v.right
 << '}';
    return os;
}

Rational binEval(int op, Expr* l, Expr* r);
std::string binString(int op, Expr* l, Expr* r);
std::shared_ptr<Expr> newNum(int n);
Rational exprEval(Expr* x);
std::string exprString(Expr* x);
bool solve(const std::vector<std::shared_ptr<Expr>>& xs);
int main();

int OP_ADD = 1;
int OP_SUB = 2;
int OP_MUL = 3;
int OP_DIV = 4;
int n_cards = 4;
int goal = 24;
int digit_range = 9;

Rational binEval(int op, Expr* l, Expr* r) {
    Rational lv = exprEval((Expr*)(l));
    Rational rv = exprEval((Expr*)(r));
    if ((op == OP_ADD)) {
        return Rational{((lv.num * rv.denom) + (lv.denom * rv.num)), (lv.denom * rv.denom)};
    }
    if ((op == OP_SUB)) {
        return Rational{((lv.num * rv.denom) - (lv.denom * rv.num)), (lv.denom * rv.denom)};
    }
    if ((op == OP_MUL)) {
        return Rational{(lv.num * rv.num), (lv.denom * rv.denom)};
    }
    return Rational{(lv.num * rv.denom), (lv.denom * rv.num)};
}

std::string binString(int op, Expr* l, Expr* r) {
    std::string ls = exprString((Expr*)(l));
    std::string rs = exprString((Expr*)(r));
    std::string opstr = std::string("");
    if ((op == OP_ADD)) {
        opstr = std::string(" + ");
    } else     if ((op == OP_SUB)) {
        opstr = std::string(" - ");
    } else     if ((op == OP_MUL)) {
        opstr = std::string(" * ");
    } else {
        opstr = std::string(" / ");
    }


    return ((((std::string("(") + ls) + opstr) + rs) + std::string(")"));
}

std::shared_ptr<Expr> newNum(int n) {
    return std::make_shared<Num>(Rational{n, 1});
}

Rational exprEval(Expr* x) {
    return ([=]{
    const Num* __num = dynamic_cast<const Num*>(x);
    if (__num) {
        Rational v = __num->value;
        return v;
    }
    const Bin* __bin = dynamic_cast<const Bin*>(x);
    if (__bin) {
        int op = __bin->op;
        Expr* l = __bin->left.get();
        Expr* r = __bin->right.get();
        return binEval(op, l, r);
    }
    return Rational{};
}());
}

std::string exprString(Expr* x) {
    return ([=]{
    const Num* __num = dynamic_cast<const Num*>(x);
    if (__num) {
        Rational v = __num->value;
        return ([&]{ std::ostringstream ss; ss << std::boolalpha << v.num; return ss.str(); }());
    }
    const Bin* __bin = dynamic_cast<const Bin*>(x);
    if (__bin) {
        int op = __bin->op;
        Expr* l = __bin->left.get();
        Expr* r = __bin->right.get();
        return binString(op, l, r);
    }
    return std::string{};
}());
}

bool solve(const std::vector<std::shared_ptr<Expr>>& xs) {
    if ((xs.size() == 1)) {
        Rational f = exprEval(xs[0].get());
        if (((f.denom != 0) && (f.num == (f.denom * goal)))) {
            std::cout << exprString(xs[0].get());
            std::cout << std::endl;
            return true;
        }
        return false;
    }
    int i = 0;
    while ((i < xs.size())) {
        int j = (i + 1);
        while ((j < xs.size())) {
            std::vector<std::shared_ptr<Expr>> rest = {};
            int k = 0;
            while ((k < xs.size())) {
                if (((k != i) && (k != j))) {
                    rest = ([&]{ auto __tmp = rest; __tmp.push_back(xs[k]); return __tmp; }());
                }
                k = (k + 1);
            }
            std::shared_ptr<Expr> a = xs[i];
            std::shared_ptr<Expr> b = xs[j];
            std::shared_ptr<Expr> node = std::make_shared<Bin>(OP_ADD, a, b);
            for (int op : std::vector<int>{OP_ADD, OP_SUB, OP_MUL, OP_DIV}) {
                node = std::make_shared<Bin>(op, a, b);
                if (solve((std::vector<std::shared_ptr<Expr>>)(([&]{ auto __tmp = rest; __tmp.push_back(node); return __tmp; }())))) {
                    return true;
                }
            }
            node = std::make_shared<Bin>(OP_SUB, b, a);
            if (solve((std::vector<std::shared_ptr<Expr>>)(([&]{ auto __tmp = rest; __tmp.push_back(node); return __tmp; }())))) {
                return true;
            }
            node = std::make_shared<Bin>(OP_DIV, b, a);
            if (solve((std::vector<std::shared_ptr<Expr>>)(([&]{ auto __tmp = rest; __tmp.push_back(node); return __tmp; }())))) {
                return true;
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return false;
}

int main() {
    {
        auto __bench_start = _now();
        auto __bench_mem_start = _mem();
        int iter = 0;
        while ((iter < 10)) {
            std::vector<std::shared_ptr<Expr>> cards = {};
            int i = 0;
            while ((i < n_cards)) {
                int n = ((_now() % (digit_range - 1)) + 1);
                cards = ([&]{ auto __tmp = cards; __tmp.push_back(newNum(n)); return __tmp; }());
                std::cout << (std::string(" ") + ([&]{ std::ostringstream ss; ss << std::boolalpha << n; return ss.str(); }()));
                std::cout << std::endl;
                i = (i + 1);
            }
            std::cout << std::string(":  ");
            std::cout << std::endl;
            if (!solve(cards)) {
                std::cout << std::string("No solution");
                std::cout << std::endl;
            }
            iter = (iter + 1);
        }
        auto __bench_end = _now();
        auto __bench_mem_end = _mem();
        auto __bench_dur = __bench_end - __bench_start;
        auto __bench_mem = __bench_mem_end;
        std::cout << "{\n  \"duration_us\": " << __bench_dur << ",\n  \"memory_bytes\": " << __bench_mem << ",\n  \"name\": \"main\"\n}" << std::endl;
    }
    return 0;
}
