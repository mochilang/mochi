// Generated by Mochi transpiler v0.10.47 on 2025-07-28 11:47:29 GMT+7
#include <iostream>
#include <string>
#include <any>
#include <map>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <optional>
#include <vector>
#include <type_traits>


static void any_to_stream(std::ostream& os, const std::any& val) {
    if(val.type() == typeid(int)) os << std::any_cast<int>(val);
    else if(val.type() == typeid(int64_t)) os << std::any_cast<int64_t>(val);
    else if(val.type() == typeid(double)) os << std::any_cast<double>(val);
    else if(val.type() == typeid(bool)) os << (std::any_cast<bool>(val) ? "true" : "false");
    else if(val.type() == typeid(std::string)) os << std::any_cast<std::string>(val);
    else if(val.type() == typeid(std::vector<int64_t>)) { const auto& v = std::any_cast<const std::vector<int64_t>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::vector<int64_t>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int64_t>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; any_to_stream(os, v[i]); } os << ']'; }
    else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
    else os << "<any>";
}
static double any_to_double(const std::any& v) {
    if(v.type() == typeid(int)) return (double)std::any_cast<int>(v);
    if(v.type() == typeid(double)) return std::any_cast<double>(v);
    return 0;
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ", "; if constexpr(std::is_same_v<T, std::any>) any_to_stream(os, vec[i]); else os << vec[i]; }
    os << "]";
    return os;
}


template<typename T> std::string _to_string(const T& v) {
    std::ostringstream ss;
    ss << std::boolalpha << v;
    return ss.str();
}


struct V3 {
    double x;
    double y;
    double z;
    auto operator<=>(const V3&) const = default;
};

struct Sphere {
    double cx;
    double cy;
    double cz;
    double r;
    auto operator<=>(const Sphere&) const = default;
};

std::ostream& operator<<(std::ostream& os, const V3& v) {
    os << '{' << "'x': "<< std::fixed << std::setprecision(1) << v.x
 << ", " << "'y': "<< std::fixed << std::setprecision(1) << v.y
 << ", " << "'z': "<< std::fixed << std::setprecision(1) << v.z
 << '}';
    return os;
}

std::ostream& operator<<(std::ostream& os, const Sphere& v) {
    os << '{' << "'cx': "<< std::fixed << std::setprecision(1) << v.cx
 << ", " << "'cy': "<< std::fixed << std::setprecision(1) << v.cy
 << ", " << "'cz': "<< std::fixed << std::setprecision(1) << v.cz
 << ", " << "'r': "<< std::fixed << std::setprecision(1) << v.r
 << '}';
    return os;
}

double sqrtApprox(double x);
double powf(double base, int64_t exp);
V3 normalize(const V3& v);
double dot(const V3& a, const V3& b);
std::map<std::string, std::any> hitSphere(const Sphere& s, double x, double y);
int main();

double sqrtApprox(double x) {
    if ((x <= 0.0)) {
        return 0.0;
    }
    double guess = x;
    int64_t i = int64_t(0);
    while ((i < int64_t(20))) {
        guess = ((double)((guess + ((double)(x) / (guess)))) / (2.0));
        i = (i + int64_t(1));
    }
    return guess;
}

double powf(double base, int64_t exp) {
    double result = 1.0;
    int64_t i = int64_t(0);
    while ((i < exp)) {
        result = (result * base);
        i = (i + int64_t(1));
    }
    return result;
}

V3 normalize(const V3& v) {
    double len = sqrtApprox((((v.x * v.x) + (v.y * v.y)) + (v.z * v.z)));
    return V3{.x = ((double)(v.x) / (len)), .y = ((double)(v.y) / (len)), .z = ((double)(v.z) / (len))};
}

double dot(const V3& a, const V3& b) {
    double d = (((a.x * b.x) + (a.y * b.y)) + (a.z * b.z));
    if ((d < 0.0)) {
        return -d;
    }
    return 0.0;
}

std::map<std::string, std::any> hitSphere(const Sphere& s, double x, double y) {
    double dx = (x - s.cx);
    double dy = (y - s.cy);
    double zsq = ((s.r * s.r) - ((dx * dx) + (dy * dy)));
    if ((zsq < 0.0)) {
        return std::map<std::string, std::any>{{"hit", std::any(false)}};
    }
    double z = sqrtApprox(zsq);
    return std::map<std::string, std::any>{{"hit", std::any(true)}, {"z1", std::any((s.cz - z))}, {"z2", std::any((s.cz + z))}};
}

int main() {
    std::string shades = std::string(".:!*oe&#%@");
    V3 light = normalize(V3{.x = -50.0, .y = 30.0, .z = 50.0});
    Sphere pos = Sphere{.cx = 20.0, .cy = 20.0, .cz = 0.0, .r = 20.0};
    Sphere neg = Sphere{.cx = 1.0, .cy = 1.0, .cz = -6.0, .r = 20.0};
    int64_t yi = int64_t(0);
    while ((yi <= int64_t(40))) {
        double y = ((double)(yi) + 0.5);
        std::string line = std::string("");
        int64_t xi = -int64_t(20);
        while ((xi <= int64_t(60))) {
            double x = ((((double)(((double)(xi) - pos.cx)) / (2.0)) + 0.5) + pos.cx);
            std::map<std::string, std::any> hb = hitSphere(pos, x, y);
            if (!hb["hit"]) {
                line = (line + std::string(" "));
                xi = (xi + int64_t(1));
                continue;
            }
            auto zb1 = hb["z1"];
            auto zb2 = hb["z2"];
            std::map<std::string, std::any> hs = hitSphere(neg, x, y);
            int64_t hitRes = int64_t(1);
            if (!hs["hit"]) {
                hitRes = int64_t(1);
            } else             if (((double)(hs["z1"]) > (double)(zb1))) {
                hitRes = int64_t(1);
            } else             if (((double)(hs["z2"]) > (double)(zb2))) {
                hitRes = int64_t(0);
            } else             if (((double)(hs["z2"]) > (double)(zb1))) {
                hitRes = int64_t(2);
            } else {
                hitRes = int64_t(1);
            }



            if ((hitRes == int64_t(0))) {
                line = (line + std::string(" "));
                xi = (xi + int64_t(1));
                continue;
            }
            V3 vec = {};
            if ((hitRes == int64_t(1))) {
                vec = V3{.x = (x - pos.cx), .y = (y - pos.cy), .z = (zb1 - pos.cz)};
            } else {
                vec = V3{.x = (neg.cx - x), .y = (neg.cy - y), .z = (neg.cz - hs["z2"])};
            }
            vec = normalize(vec);
            double b = (powf(dot(light, vec), int64_t(2)) + 0.5);
            int64_t intensity = (int64_t)(((1.0 - b) * (double)(shades.size())));
            if ((intensity < int64_t(0))) {
                intensity = int64_t(0);
            }
            if ((intensity >= shades.size())) {
                intensity = (shades.size() - int64_t(1));
            }
            line = (line + shades.substr(intensity, (intensity + int64_t(1)) - intensity));
            xi = (xi + int64_t(1));
        }
        std::cout << line;
        std::cout << std::endl;
        yi = (yi + int64_t(1));
    }
    return 0;
}
