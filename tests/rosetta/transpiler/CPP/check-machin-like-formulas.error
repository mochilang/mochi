compile: exit status 1
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:37:181: warning: multi-character character constant [-Wmultichar]
   37 |     else if(val.type() == typeid(std::vector<int64_t>)) { const auto& v = std::any_cast<const std::vector<int64_t>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
      |                                                                                                                                                                                     ^~~~
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:38:209: warning: multi-character character constant [-Wmultichar]
   38 |     else if(val.type() == typeid(std::vector<std::vector<int64_t>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int64_t>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
      |                                                                                                                                                                                                                 ^~~~
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:38:295: warning: multi-character character constant [-Wmultichar]
   38 |     else if(val.type() == typeid(std::vector<std::vector<int64_t>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int64_t>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
      |                                                                                                                                                                                                                                                                                                       ^~~~
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:39:189: warning: multi-character character constant [-Wmultichar]
   39 |     else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
      |                                                                                                                                                                                             ^~~~
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:40:183: warning: multi-character character constant [-Wmultichar]
   40 |     else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; any_to_stream(os, v[i]); } os << ']'; }
      |                                                                                                                                                                                       ^~~~
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:41:215: warning: multi-character character constant [-Wmultichar]
   41 |     else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
      |                                                                                                                                                                                                                       ^~~~
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:41:251: warning: multi-character character constant [-Wmultichar]
   41 |     else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
      |                                                                                                                                                                                                                                                           ^~~~
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp: In function ‘BigRat tanEval(int64_t, const BigRat&)’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:98:16: error: no match for ‘operator-’ (operand type is ‘BigRat’)
   98 |         return -_bigrat(tanEval(-coef, f));
      |                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:22:12: note: candidate: ‘BigRat BigRat::operator-(const BigRat&) const’
   22 |     BigRat operator-(const BigRat& o) const { return BigRat(num*o.den - o.num*den, den*o.den); }
      |            ^~~~~~~~
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:22:12: note:   candidate expects 1 argument, 0 provided
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp: In instantiation of ‘BigRat _bigrat(A) [with A = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: error: no matching function for call to ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >::number(BigRat&)’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
In file included from /usr/include/boost/multiprecision/cpp_int.hpp:19,
                 from /workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:4:
/usr/include/boost/multiprecision/number.hpp:463:50: note: candidate: ‘template<class Other, boost::multiprecision::expression_template_option ET> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(boost::multiprecision::number<Other, ET>&&, typename std::enable_if<(std::is_convertible<_Iter, _Iterator>::value && (! boost::multiprecision::detail::is_restricted_conversion<Other, Backend>::value))>::type*) [with boost::multiprecision::expression_template_option ET = Other; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  463 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(number<Other, ET>&& val,
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:463:50: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘boost::multiprecision::number<Backend, ExpressionTemplates>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:443:38: note: candidate: ‘template<class tag, class Arg1, class Arg2, class Arg3, class Arg4> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, typename std::enable_if<((! std::is_convertible<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value) && boost::multiprecision::detail::is_explicitly_convertible<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value)>::type*) [with Arg1 = tag; Arg2 = Arg1; Arg3 = Arg2; Arg4 = Arg3; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  443 |    explicit BOOST_MP_CXX14_CONSTEXPR number(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e,
      |                                      ^~~~~~
/usr/include/boost/multiprecision/number.hpp:443:38: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:435:29: note: candidate: ‘template<class tag, class Arg1, class Arg2, class Arg3, class Arg4> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>&, typename std::enable_if<std::is_convertible<typename boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value>::type*) [with Arg1 = tag; Arg2 = Arg1; Arg3 = Arg2; Arg4 = Arg3; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  435 |    BOOST_MP_CXX14_CONSTEXPR number(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, typename std::enable_if<std::is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>::value>::type* = nullptr)
      |                             ^~~~~~
/usr/include/boost/multiprecision/number.hpp:435:29: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const boost::multiprecision::detail::expression<tag, Arg1, Arg2, Arg3, Arg4>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:284:50: note: candidate: ‘template<class Other, boost::multiprecision::expression_template_option ET> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const boost::multiprecision::number<Other, ET>&, const boost::multiprecision::number<Other, ET>&, typename std::enable_if<(std::is_convertible<_Iter, _Iterator>::value && ((! std::is_constructible<Backend, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const boost::multiprecision::number<Other, ET>&>()))>::type>::type, Backend>::type&, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const boost::multiprecision::number<Other, ET>&>()))>::type>::type, Backend>::type&>::value) || boost::multiprecision::detail::is_variable_precision<Backend>::value))>::type*) [with boost::multiprecision::expression_template_option ET = Other; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  284 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:284:50: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:279:59: note: candidate: ‘template<class V, class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, const U&, unsigned int, typename std::enable_if<((((std::is_constructible<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, V>::value || std::is_convertible<V, std::__cxx11::basic_string<char> >::value) && (std::is_constructible<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, U>::value || std::is_convertible<U, std::__cxx11::basic_string<char> >::value)) && (! std::is_same<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value)) && (!(std::is_convertible<V, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value && std::is_convertible<U, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value)))>::type*) [with U = V; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  279 |    BOOST_MP_FORCEINLINE explicit BOOST_MP_CXX14_CONSTEXPR number(const V& v1, const U& v2, unsigned digits10,
      |                                                           ^~~~~~
/usr/include/boost/multiprecision/number.hpp:279:59: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 4 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:274:50: note: candidate: ‘template<class V, class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, const U&, unsigned int, typename std::enable_if<((std::is_convertible<V, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value && std::is_convertible<U, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value) && (! std::is_same<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value))>::type*) [with U = V; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  274 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(const V& v1, const U& v2, unsigned digits10,
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:274:50: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 4 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:262:59: note: candidate: ‘template<class Traits> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const std::basic_string_view<char, Traits>&, unsigned int) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  262 |    explicit BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(const std::basic_string_view<char, Traits>& v, unsigned digits10)
      |                                                           ^~~~~~
/usr/include/boost/multiprecision/number.hpp:262:59: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const std::basic_string_view<char, Traits>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:256:45: note: candidate: ‘template<class Traits> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const std::basic_string_view<char, Traits>&, const std::basic_string_view<char, Traits>&) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  256 |    explicit inline BOOST_MP_CXX14_CONSTEXPR number(const std::basic_string_view<char, Traits>& view_x, const std::basic_string_view<char, Traits>& view_y)
      |                                             ^~~~~~
/usr/include/boost/multiprecision/number.hpp:256:45: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const std::basic_string_view<char, Traits>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:250:45: note: candidate: ‘template<class Traits> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const std::basic_string_view<char, Traits>&) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  250 |    explicit inline BOOST_MP_CXX14_CONSTEXPR number(const std::basic_string_view<char, Traits>& view)
      |                                             ^~~~~~
/usr/include/boost/multiprecision/number.hpp:250:45: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const std::basic_string_view<char, Traits>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:233:59: note: candidate: ‘template<class V, class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, const U&, typename std::enable_if<(((((std::is_constructible<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, V>::value || std::is_convertible<V, std::__cxx11::basic_string<char> >::value) && (std::is_constructible<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, U>::value || std::is_convertible<U, std::__cxx11::basic_string<char> >::value)) && (! std::is_same<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value)) && (! std::is_same<V, boost::multiprecision::number<Backend, ExpressionTemplates> >::value)) && (!(std::is_convertible<V, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value && std::is_convertible<U, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value)))>::type*) [with U = V; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  233 |    BOOST_MP_FORCEINLINE explicit BOOST_MP_CXX14_CONSTEXPR number(const V& v1, const U& v2,
      |                                                           ^~~~~~
/usr/include/boost/multiprecision/number.hpp:233:59: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 3 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:216:50: note: candidate: ‘template<class V, class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, const U&, typename std::enable_if<(((std::is_convertible<V, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value && std::is_convertible<U, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value) && (! std::is_same<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value)) && ((! std::is_constructible<Backend, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const V&>()))>::type>::type, Backend>::type&, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const U&>()))>::type>::type, Backend>::type&>::value) || boost::multiprecision::detail::is_variable_precision<Backend>::value))>::type*) [with U = V; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  216 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(const V& v1, const U& v2,
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:216:50: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 3 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:205:50: note: candidate: ‘template<class V, class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(V&&, U&&, typename std::enable_if<((((std::is_convertible<V, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value && std::is_convertible<U, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value) && (! std::is_same<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value)) && std::is_constructible<Backend, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const V&>()))>::type>::type, Backend>::type&, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const U&>()))>::type>::type, Backend>::type&>::value) && (! boost::multiprecision::detail::is_variable_precision<Backend>::value))>::type*) [with U = V; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  205 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(V&& v1, U&& v2,
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:205:50: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 3 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:194:50: note: candidate: ‘template<class V, class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, U&&, typename std::enable_if<((((std::is_convertible<V, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value && std::is_convertible<U, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value) && (! std::is_same<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value)) && std::is_constructible<Backend, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const V&>()))>::type>::type, Backend>::type&, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const U&>()))>::type>::type, Backend>::type&>::value) && (! boost::multiprecision::detail::is_variable_precision<Backend>::value))>::type*) [with U = V; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  194 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(const V& v1, U&& v2,
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:194:50: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 3 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:183:50: note: candidate: ‘template<class V, class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(V&&, const U&, typename std::enable_if<((((std::is_convertible<V, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value && std::is_convertible<U, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value) && (! std::is_same<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value)) && std::is_constructible<Backend, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const V&>()))>::type>::type, Backend>::type&, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const U&>()))>::type>::type, Backend>::type&>::value) && (! boost::multiprecision::detail::is_variable_precision<Backend>::value))>::type*) [with U = V; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  183 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(V&& v1, const U& v2,
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:183:50: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 3 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:172:50: note: candidate: ‘template<class V, class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, const U&, typename std::enable_if<((((std::is_convertible<V, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value && std::is_convertible<U, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value) && (! std::is_same<typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type, boost::multiprecision::number<Backend, ExpressionTemplates> >::value)) && std::is_constructible<Backend, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const V&>()))>::type>::type, Backend>::type&, const typename boost::multiprecision::detail::canonical<typename std::remove_cv<typename std::remove_reference<decltype (boost::multiprecision::detail::evaluate_if_expression(declval<const U&>()))>::type>::type, Backend>::type&>::value) && (! boost::multiprecision::detail::is_variable_precision<Backend>::value))>::type*) [with U = V; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  172 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(const V& v1, const U& v2,
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:172:50: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 3 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:167:59: note: candidate: ‘template<class Other, boost::multiprecision::expression_template_option ET> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const boost::multiprecision::number<Other, ET>&, typename std::enable_if<(boost::multiprecision::detail::is_explicitly_convertible<Other, Backend>::value && (boost::multiprecision::detail::is_restricted_conversion<Other, Backend>::value || (! std::is_convertible<_Iter, _Iterator>::value)))>::type*) [with boost::multiprecision::expression_template_option ET = Other; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  167 |    explicit BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(const number<Other, ET>& val, typename std::enable_if<
      |                                                           ^~~~~~
/usr/include/boost/multiprecision/number.hpp:167:59: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:145:38: note: candidate: ‘template<class Other, boost::multiprecision::expression_template_option ET> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const boost::multiprecision::number<Other, ET>&, typename std::enable_if<(! boost::multiprecision::detail::is_explicitly_convertible<Other, Backend>::value)>::type*) [with boost::multiprecision::expression_template_option ET = Other; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  145 |    explicit BOOST_MP_CXX14_CONSTEXPR number(const number<Other, ET>& val, typename std::enable_if<
      |                                      ^~~~~~
/usr/include/boost/multiprecision/number.hpp:145:38: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:139:50: note: candidate: ‘template<class Other, boost::multiprecision::expression_template_option ET> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const boost::multiprecision::number<Other, ET>&, typename std::enable_if<(std::is_convertible<_Iter, _Iterator>::value && (! boost::multiprecision::detail::is_restricted_conversion<Other, Backend>::value))>::type*) [with boost::multiprecision::expression_template_option ET = Other; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  139 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(const number<Other, ET>& val,
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:139:50: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const boost::multiprecision::number<Backend, ExpressionTemplates>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:135:35: note: candidate: ‘template<boost::multiprecision::expression_template_option ET> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const boost::multiprecision::number<Backend, ET>&) [with boost::multiprecision::expression_template_option ET = ET; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  135 |    BOOST_MP_FORCEINLINE constexpr number(const number<Backend, ET>& val)
      |                                   ^~~~~~
/usr/include/boost/multiprecision/number.hpp:135:35: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   ‘BigRat’ is not derived from ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<>, ET>’
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:131:44: note: candidate: ‘template<class V> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, unsigned int, typename std::enable_if<(((((boost::multiprecision::detail::is_arithmetic<V>::value || std::is_same<std::__cxx11::basic_string<char>, V>::value) || std::is_convertible<V, const char*>::value) && boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value) && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_complex)) && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_rational))>::type*) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  131 |    explicit BOOST_MP_FORCEINLINE constexpr number(const V& v, unsigned digits10, typename std::enable_if<(boost::multiprecision::detail::is_arithmetic<V>::value || std::is_same<std::string, V>::value || std::is_convertible<V, const char*>::value) && detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_complex) && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_rational)>::type* = nullptr)
      |                                            ^~~~~~
/usr/include/boost/multiprecision/number.hpp:131:44: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 3 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:126:44: note: candidate: ‘template<class V> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, typename std::enable_if<(boost::multiprecision::detail::is_explicitly_convertible<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value && (boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value || (! std::is_convertible<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value)))>::type*) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  126 |    explicit BOOST_MP_FORCEINLINE constexpr number(const V& v, typename std::enable_if<
      |                                            ^~~~~~
/usr/include/boost/multiprecision/number.hpp:126:44: note:   template argument deduction/substitution failed:
/usr/include/boost/multiprecision/number.hpp: In substitution of ‘template<class V> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >::number(const V&, typename std::enable_if<(boost::multiprecision::detail::is_explicitly_convertible<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value && (boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value || (! std::is_convertible<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value))), void>::type*) [with V = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57:   required from ‘BigRat _bigrat(A) [with A = BigRat]’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:126:44: error: no type named ‘type’ in ‘struct std::enable_if<false, void>’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp: In instantiation of ‘BigRat _bigrat(A) [with A = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:119:59: note: candidate: ‘template<class V> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, typename std::enable_if<((((boost::multiprecision::detail::is_arithmetic<V>::value || std::is_same<std::__cxx11::basic_string<char>, V>::value) || std::is_convertible<V, const char*>::value) && (! boost::multiprecision::detail::is_explicitly_convertible<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value)) && boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value)>::type*) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  119 |    explicit BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(const V& v, typename std::enable_if<
      |                                                           ^~~~~~
/usr/include/boost/multiprecision/number.hpp:119:59: note:   template argument deduction/substitution failed:
/usr/include/boost/multiprecision/number.hpp: In substitution of ‘template<class V> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >::number(const V&, typename std::enable_if<((((boost::multiprecision::detail::is_arithmetic<T>::value || std::is_same<std::__cxx11::basic_string<char>, V>::value) || std::is_convertible<_Iter, const char*>::value) && (! boost::multiprecision::detail::is_explicitly_convertible<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value)) && boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value), void>::type*) [with V = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57:   required from ‘BigRat _bigrat(A) [with A = BigRat]’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:119:59: error: no type named ‘type’ in ‘struct std::enable_if<false, void>’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp: In instantiation of ‘BigRat _bigrat(A) [with A = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:115:35: note: candidate: ‘template<class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const boost::multiprecision::number<Backend, ExpressionTemplates>&, U, typename std::enable_if<((std::is_constructible<Backend, const Backend&, unsigned int>::value && std::is_integral<U>::value) && (std::numeric_limits<Type>::digits <= std::numeric_limits<unsigned int>::digits))>::type*) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  115 |    BOOST_MP_FORCEINLINE constexpr number(const number& e, U digits10, typename std::enable_if<std::is_constructible<Backend, const Backend&, unsigned>::value && std::is_integral<U>::value && (std::numeric_limits<U>::digits <= std::numeric_limits<unsigned>::digits)>::type* = nullptr)
      |                                   ^~~~~~
/usr/include/boost/multiprecision/number.hpp:115:35: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 3 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:109:8: note: candidate: ‘template<class V> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, typename std::enable_if<(((std::is_enum<V>::value && (! std::is_convertible<V, int>::value)) && (! std::is_convertible<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value)) && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value))>::type*) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  109 |        number(const V& v, typename std::enable_if<
      |        ^~~~~~
/usr/include/boost/multiprecision/number.hpp:109:8: note:   template argument deduction/substitution failed:
/usr/include/boost/multiprecision/number.hpp: In substitution of ‘template<class V> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >::number(const V&, typename std::enable_if<(((std::is_enum<_Tp>::value && (! std::is_convertible<V, int>::value)) && (! std::is_convertible<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value)) && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value)), void>::type*) [with V = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57:   required from ‘BigRat _bigrat(A) [with A = BigRat]’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:109:8: error: no type named ‘type’ in ‘struct std::enable_if<false, void>’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp: In instantiation of ‘BigRat _bigrat(A) [with A = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:97:7: note: candidate: ‘template<class V> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, typename std::enable_if<(((std::is_enum<V>::value && std::is_convertible<V, int>::value) && (! std::is_convertible<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value)) && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value))>::type*) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
   97 |       number(const V& v, typename std::enable_if<
      |       ^~~~~~
/usr/include/boost/multiprecision/number.hpp:97:7: note:   template argument deduction/substitution failed:
/usr/include/boost/multiprecision/number.hpp: In substitution of ‘template<class V> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >::number(const V&, typename std::enable_if<(((std::is_enum<_Tp>::value && std::is_convertible<V, int>::value) && (! std::is_convertible<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value)) && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value)), void>::type*) [with V = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57:   required from ‘BigRat _bigrat(A) [with A = BigRat]’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:97:7: error: no type named ‘type’ in ‘struct std::enable_if<false, void>’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp: In instantiation of ‘BigRat _bigrat(A) [with A = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:75:35: note: candidate: ‘template<class V, class U> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, U, typename std::enable_if<(((((((((boost::multiprecision::detail::is_convertible_arithmetic<V, Backend>::value || std::is_same<std::__cxx11::basic_string<char>, V>::value) || std::is_convertible<V, const char*>::value) && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value)) && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_complex)) && (boost::multiprecision::number_category<Backend>::value != boost::multiprecision::number_kind_rational)) && std::is_same<boost::multiprecision::number<Backend, ExpressionTemplates>, typename boost::multiprecision::component_type<boost::multiprecision::number<Backend, ExpressionTemplates> >::type>::value) && std::is_integral<U>::value) && (std::numeric_limits<U>::digits <= std::numeric_limits<unsigned int>::digits)) && std::is_constructible<Backend, const typename boost::multiprecision::detail::canonical<V, Backend>::type&, unsigned int>::value)>::type*) [with U = V; Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
   75 |    BOOST_MP_FORCEINLINE constexpr number(const V& v, U digits10,
      |                                   ^~~~~~
/usr/include/boost/multiprecision/number.hpp:75:35: note:   template argument deduction/substitution failed:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57: note:   candidate expects 3 arguments, 1 provided
   26 | template<typename A> BigRat _bigrat(A a){ return BigRat(cpp_int(a), cpp_int(1)); }
      |                                                         ^~~~~~~~~~
/usr/include/boost/multiprecision/number.hpp:67:35: note: candidate: ‘template<class V> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, typename std::enable_if<(std::is_convertible<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value))>::type*) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
   67 |    BOOST_MP_FORCEINLINE constexpr number(const V& v, typename std::enable_if<
      |                                   ^~~~~~
/usr/include/boost/multiprecision/number.hpp:67:35: note:   template argument deduction/substitution failed:
/usr/include/boost/multiprecision/number.hpp: In substitution of ‘template<class V> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >::number(const V&, typename std::enable_if<(std::is_convertible<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value)), void>::type*) [with V = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57:   required from ‘BigRat _bigrat(A) [with A = BigRat]’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:67:35: error: no type named ‘type’ in ‘struct std::enable_if<false, void>’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp: In instantiation of ‘BigRat _bigrat(A) [with A = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:56:50: note: candidate: ‘template<class V> constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const V&, typename std::enable_if<((((boost::multiprecision::detail::is_convertible_arithmetic<V, Backend>::value || std::is_same<std::__cxx11::basic_string<char>, V>::value) || std::is_convertible<V, const char*>::value) && (! std::is_convertible<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value)) && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, Backend>::type, Backend>::value))>::type*) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
   56 |    BOOST_MP_FORCEINLINE BOOST_MP_CXX14_CONSTEXPR number(const V& v,
      |                                                  ^~~~~~
/usr/include/boost/multiprecision/number.hpp:56:50: note:   template argument deduction/substitution failed:
/usr/include/boost/multiprecision/number.hpp: In substitution of ‘template<class V> constexpr boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >::number(const V&, typename std::enable_if<((((boost::multiprecision::detail::is_convertible_arithmetic<V, boost::multiprecision::backends::cpp_int_backend<> >::value || std::is_same<std::__cxx11::basic_string<char>, V>::value) || std::is_convertible<_Iter, const char*>::value) && (! std::is_convertible<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value)) && (! boost::multiprecision::detail::is_restricted_conversion<typename boost::multiprecision::detail::canonical<V, boost::multiprecision::backends::cpp_int_backend<> >::type, boost::multiprecision::backends::cpp_int_backend<> >::value)), void>::type*) [with V = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:26:57:   required from ‘BigRat _bigrat(A) [with A = BigRat]’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:56:50: error: no type named ‘type’ in ‘struct std::enable_if<false, void>’
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp: In instantiation of ‘BigRat _bigrat(A) [with A = BigRat]’:
/workspace/mochi/tests/rosetta/transpiler/CPP/check-machin-like-formulas.cpp:73:33:   required from here
/usr/include/boost/multiprecision/number.hpp:453:35: note: candidate: ‘constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(boost::multiprecision::number<Backend, ExpressionTemplates>&&) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
  453 |    BOOST_MP_FORCEINLINE constexpr number(number&& r)
      |                                   ^~~~~~
/usr/include/boost/multiprecision/number.hpp:453:51: note:   no known conversion for argument 1 from ‘BigRat’ to ‘boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >&&’
  453 |    BOOST_MP_FORCEINLINE constexpr number(number&& r)
      |                                          ~~~~~~~~~^
/usr/include/boost/multiprecision/number.hpp:54:35: note: candidate: ‘constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number(const boost::multiprecision::number<Backend, ExpressionTemplates>&) [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
   54 |    BOOST_MP_FORCEINLINE constexpr number(const number& e) noexcept(noexcept(Backend(std::declval<Backend const&>()))) : m_backend(e.m_backend) {}
      |                                   ^~~~~~
/usr/include/boost/multiprecision/number.hpp:54:56: note:   no known conversion for argument 1 from ‘BigRat’ to ‘const boost::multiprecision::number<boost::multiprecision::backends::cpp_int_backend<> >&’
   54 |    BOOST_MP_FORCEINLINE constexpr number(const number& e) noexcept(noexcept(Backend(std::declval<Backend const&>()))) : m_backend(e.m_backend) {}
      |                                          ~~~~~~~~~~~~~~^
/usr/include/boost/multiprecision/number.hpp:53:35: note: candidate: ‘constexpr boost::multiprecision::number<Backend, ExpressionTemplates>::number() [with Backend = boost::multiprecision::backends::cpp_int_backend<>; boost::multiprecision::expression_template_option ExpressionTemplates = boost::multiprecision::et_on]’
   53 |    BOOST_MP_FORCEINLINE constexpr number() noexcept(noexcept(Backend())) {}
      |                                   ^~~~~~
/usr/include/boost/multiprecision/number.hpp:53:35: note:   candidate expects 0 arguments, 1 provided
