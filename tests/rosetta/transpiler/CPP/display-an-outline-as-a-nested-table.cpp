// Generated by Mochi transpiler v0.10.56 on 2025-08-04 10:47:04 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <type_traits>
#include <any>
#include <map>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <optional>


static std::vector<std::string> _split(const std::string& s, const std::string& sep) {
    std::vector<std::string> out; size_t pos = 0, prev = 0;
    while((pos = s.find(sep, prev)) != std::string::npos){ out.push_back(s.substr(prev, pos - prev)); prev = pos + sep.size(); }
    out.push_back(s.substr(prev));
    return out;
}
static void any_to_stream(std::ostream& os, const std::any& val) {
    if(val.type() == typeid(int)) os << std::any_cast<int>(val);
    else if(val.type() == typeid(int64_t)) os << std::any_cast<int64_t>(val);
    else if(val.type() == typeid(double)) os << std::any_cast<double>(val);
    else if(val.type() == typeid(bool)) os << (std::any_cast<bool>(val) ? "true" : "false");
    else if(val.type() == typeid(std::string)) os << std::any_cast<std::string>(val);
    else if(val.type() == typeid(std::vector<int64_t>)) { const auto& v = std::any_cast<const std::vector<int64_t>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::vector<int64_t>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int64_t>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; any_to_stream(os, v[i]); } os << ']'; }
    else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
    else os << "<any>";
}
static double any_to_double(const std::any& v) {
    if(v.type() == typeid(int)) return (double)std::any_cast<int>(v);
    if(v.type() == typeid(double)) return std::any_cast<double>(v);
    return 0;
}
static std::string any_to_string(const std::any& v) {
    if(v.type() == typeid(std::string)) return std::any_cast<std::string>(v);
    if(v.type() == typeid(int)) return std::to_string(std::any_cast<int>(v));
    if(v.type() == typeid(int64_t)) return std::to_string(std::any_cast<int64_t>(v));
    if(v.type() == typeid(double)) { std::ostringstream ss; ss << std::any_cast<double>(v); return ss.str(); }
    if(v.type() == typeid(bool)) return std::any_cast<bool>(v) ? "true" : "false";
    return std::string();
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ", "; if constexpr(std::is_same_v<T, std::any>) any_to_stream(os, vec[i]); else os << vec[i]; }
    os << "]";
    return os;
}


template<typename T> std::string _to_string(const T& v) {
    std::ostringstream ss;
    ss << std::boolalpha << v;
    return ss.str();
}

std::vector<std::string> split(std::string s, std::string sep);
std::string join(const std::vector<std::string>& xs, std::string sep);
std::string trimLeftSpaces(std::string s);
std::vector<std::map<std::string, std::any>> makeIndent(std::string outline, int64_t tab);
void toNest(const std::vector<std::map<std::string, std::any>>& nodes, int64_t start, int64_t level, std::map<std::string, std::any> n);
int64_t countLeaves(const std::map<std::string, std::any>& n);
std::vector<std::vector<std::map<std::string, std::any>>> nodesByDepth(const std::map<std::string, std::any>& root, int64_t depth);
std::string toMarkup(const std::map<std::string, std::any>& n, const std::vector<std::string>& cols, int64_t depth);
int main();

std::vector<std::string> split(std::string s, std::string sep) {
    std::vector<std::string> out = {};
    std::string cur = std::string("");
    int64_t i = int64_t(0);
    while ((i < static_cast<int64_t>(s.size()))) {
        if ((((i + static_cast<int64_t>(sep.size())) <= static_cast<int64_t>(s.size())) && (s.substr(i, (i + static_cast<int64_t>(sep.size())) - i) == sep))) {
            out = ([&]{ auto __tmp = out; __tmp.push_back(cur); return __tmp; }());
            cur = std::string("");
            i = (i + static_cast<int64_t>(sep.size()));
        } else {
            cur = (cur + s.substr(i, (i + int64_t(1)) - i));
            i = (i + int64_t(1));
        }
    }
    out = ([&]{ auto __tmp = out; __tmp.push_back(cur); return __tmp; }());
    return out;
}

std::string join(const std::vector<std::string>& xs, std::string sep) {
    std::string res = std::string("");
    int64_t i = int64_t(0);
    while ((i < static_cast<int64_t>(xs.size()))) {
        if ((i > int64_t(0))) {
            res = (res + sep);
        }
        res = (res + xs[i]);
        i = (i + int64_t(1));
    }
    return res;
}

std::string trimLeftSpaces(std::string s) {
    int64_t i = int64_t(0);
    while (((i < static_cast<int64_t>(s.size())) && (([&](const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__v)>, std::string>) return __v.substr(i, (i + int64_t(1)) - i); else return std::vector<typename std::decay_t<decltype(__v)>::value_type>(__v.begin()+i, __v.begin()+(i + int64_t(1))); })(s) == std::string(" ")))) {
        i = (i + int64_t(1));
    }
    return ([&](const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__v)>, std::string>) return __v.substr(i, static_cast<int64_t>(s.size()) - i); else return std::vector<typename std::decay_t<decltype(__v)>::value_type>(__v.begin()+i, __v.begin()+static_cast<int64_t>(s.size())); })(s);
}

std::vector<std::map<std::string, std::any>> makeIndent(std::string outline, int64_t tab) {
    std::vector<std::string> lines = _split(outline, std::string("\n"));
    std::vector<std::map<std::string, std::any>> nodes = {};
    for (std::string line : lines) {
        std::string line2 = trimLeftSpaces(line);
        auto level = ((static_cast<int64_t>(line.size()) - static_cast<int64_t>(line2.size())) / tab);
        nodes = ([&]{ auto __tmp = nodes; __tmp.push_back(std::map<std::string, std::any>{{"level", std::any(level)}, {"name", std::any(line2)}}); return __tmp; }());
    }
    return nodes;
}

void toNest(const std::vector<std::map<std::string, std::any>>& nodes, int64_t start, int64_t level, std::map<std::string, std::any> n) {
    if ((level == int64_t(0))) {
        n[std::string("name")] = ([&](const auto& __m){ auto __it = __m.find(std::string("name")); return __it != __m.end() ? __it->second : std::any{}; })(nodes[int64_t(0)]);
    }
    int64_t i = (start + int64_t(1));
    while ((i < static_cast<int64_t>(nodes.size()))) {
        std::map<std::string, std::any> node = nodes[i];
        int64_t lev = std::any_cast<int64_t>(([&](const auto& __m){ auto __it = __m.find(std::string("level")); return __it != __m.end() ? __it->second : std::any{}; })(node));
        if ((lev == (level + int64_t(1)))) {
            std::map<std::string, std::any> child = std::map<std::string, std::any>{{"name", std::any(([&](const auto& __m){ auto __it = __m.find(std::string("name")); return __it != __m.end() ? __it->second : std::any{}; })(node))}, {"children", std::any(std::vector<std::any>{})}};
            toNest(nodes, i, (level + int64_t(1)), child);
            std::vector<std::any> cs = std::any_cast<std::vector<std::any>>(([&](const auto& __m){ auto __it = __m.find(std::string("children")); return __it != __m.end() ? __it->second : std::any{}; })(n));
            cs = ([&]{ auto __tmp = cs; __tmp.push_back((std::any)child); return __tmp; }());
            n[std::string("children")] = cs;
        } else         if ((lev <= level)) {
            return;
        }

        i = (i + int64_t(1));
    }
}

int64_t countLeaves(const std::map<std::string, std::any>& n) {
    std::vector<std::any> kids = std::any_cast<std::vector<std::any>>(([&](const auto& __m){ auto __it = __m.find(std::string("children")); return __it != __m.end() ? __it->second : std::any{}; })(n));
    if ((static_cast<int64_t>(kids.size()) == int64_t(0))) {
        return int64_t(1);
    }
    int64_t total = int64_t(0);
    for (std::any k : kids) {
        total = (total + countLeaves(std::any_cast<std::map<std::string, std::any>>(k)));
    }
    return total;
}

std::vector<std::vector<std::map<std::string, std::any>>> nodesByDepth(const std::map<std::string, std::any>& root, int64_t depth) {
    std::vector<std::vector<std::map<std::string, std::any>>> levels = {};
    std::vector<std::map<std::string, std::any>> current = std::vector<std::map<std::string, std::any>>{root};
    int64_t d = int64_t(0);
    while ((d < depth)) {
        levels = ([&]{ auto __tmp = levels; __tmp.push_back(current); return __tmp; }());
        std::vector<std::map<std::string, std::any>> next = {};
        for (std::map<std::string, std::any> n : current) {
            std::vector<std::any> kids = std::any_cast<std::vector<std::any>>(([&](const auto& __m){ auto __it = __m.find(std::string("children")); return __it != __m.end() ? __it->second : std::any{}; })(n));
            for (std::any k : kids) {
                next = ([&]{ auto __tmp = next; __tmp.push_back(std::any_cast<std::map<std::string, std::any>>(k)); return __tmp; }());
            }
        }
        current = next;
        d = (d + int64_t(1));
    }
    return levels;
}

std::string toMarkup(const std::map<std::string, std::any>& n, const std::vector<std::string>& cols, int64_t depth) {
    std::vector<std::string> lines = {};
    lines = ([&]{ auto __tmp = lines; __tmp.push_back(std::string("{| class=\"wikitable\" style=\"text-align: center;\"")); return __tmp; }());
    std::string l1 = std::string("|-");
    lines = ([&]{ auto __tmp = lines; __tmp.push_back(l1); return __tmp; }());
    int64_t span = countLeaves(n);
    lines = ([&]{ auto __tmp = lines; __tmp.push_back((((((std::string("| style=\"background: ") + cols[int64_t(0)]) + std::string(" \" colSpan=")) + ([&]{ std::ostringstream ss; ss << std::boolalpha << span; return ss.str(); }())) + std::string(" | ")) + std::any_cast<std::string>(([&](const auto& __m){ auto __it = __m.find(std::string("name")); return __it != __m.end() ? __it->second : std::any{}; })(n)))); return __tmp; }());
    lines = ([&]{ auto __tmp = lines; __tmp.push_back(l1); return __tmp; }());
    std::vector<std::vector<std::map<std::string, std::any>>> lvls = nodesByDepth(n, depth);
    int64_t lvl = int64_t(1);
    while ((lvl < depth)) {
        std::vector<std::map<std::string, std::any>> nodes = lvls[lvl];
        if ((static_cast<int64_t>(nodes.size()) == int64_t(0))) {
            lines = ([&]{ auto __tmp = lines; __tmp.push_back(std::string("|  |")); return __tmp; }());
        } else {
            int64_t idx = int64_t(0);
            while ((idx < static_cast<int64_t>(nodes.size()))) {
                std::map<std::string, std::any> node = nodes[idx];
                span = countLeaves(node);
                int64_t col = lvl;
                if ((lvl == int64_t(1))) {
                    col = (idx + int64_t(1));
                }
                if ((col >= static_cast<int64_t>(cols.size()))) {
                    col = (static_cast<int64_t>(cols.size()) - int64_t(1));
                }
                std::string cell = (((((std::string("| style=\"background: ") + cols[col]) + std::string(" \" colspan=")) + ([&]{ std::ostringstream ss; ss << std::boolalpha << span; return ss.str(); }())) + std::string(" | ")) + std::any_cast<std::string>(([&](const auto& __m){ auto __it = __m.find(std::string("name")); return __it != __m.end() ? __it->second : std::any{}; })(node)));
                lines = ([&]{ auto __tmp = lines; __tmp.push_back(cell); return __tmp; }());
                idx = (idx + int64_t(1));
            }
        }
        if ((lvl < (depth - int64_t(1)))) {
            lines = ([&]{ auto __tmp = lines; __tmp.push_back(l1); return __tmp; }());
        }
        lvl = (lvl + int64_t(1));
    }
    lines = ([&]{ auto __tmp = lines; __tmp.push_back(std::string("|}")); return __tmp; }());
    return join(lines, std::string("\n"));
}

int main() {
    std::string outline = (((((((((((std::string("Display an outline as a nested table.\n") + std::string("    Parse the outline to a tree,\n")) + std::string("        measuring the indent of each line,\n")) + std::string("        translating the indentation to a nested structure,\n")) + std::string("        and padding the tree to even depth.\n")) + std::string("    count the leaves descending from each node,\n")) + std::string("        defining the width of a leaf as 1,\n")) + std::string("        and the width of a parent node as a sum.\n")) + std::string("            (The sum of the widths of its children)\n")) + std::string("    and write out a table with 'colspan' values\n")) + std::string("        either as a wiki table,\n")) + std::string("        or as HTML."));
    std::string yellow = std::string("#ffffe6;");
    std::string orange = std::string("#ffebd2;");
    std::string green = std::string("#f0fff0;");
    std::string blue = std::string("#e6ffff;");
    std::string pink = std::string("#ffeeff;");
    std::vector<std::string> cols = std::vector<std::string>{yellow, orange, green, blue, pink};
    std::vector<std::map<std::string, std::any>> nodes = makeIndent(outline, int64_t(4));
    std::map<std::string, std::any> n = std::map<std::string, std::any>{{"name", std::any(std::string(""))}, {"children", std::any(std::vector<std::any>{})}};
    toNest(nodes, int64_t(0), int64_t(0), n);
    std::cout << toMarkup(n, cols, int64_t(4));
    std::cout << std::endl;
    std::cout << std::string("\n");
    std::cout << std::endl;
    std::string outline2 = (((((((((((((std::string("Display an outline as a nested table.\n") + std::string("    Parse the outline to a tree,\n")) + std::string("        measuring the indent of each line,\n")) + std::string("        translating the indentation to a nested structure,\n")) + std::string("        and padding the tree to even depth.\n")) + std::string("    count the leaves descending from each node,\n")) + std::string("        defining the width of a leaf as 1,\n")) + std::string("        and the width of a parent node as a sum.\n")) + std::string("            (The sum of the widths of its children)\n")) + std::string("            Propagating the sums upward as necessary.\n")) + std::string("    and write out a table with 'colspan' values\n")) + std::string("        either as a wiki table,\n")) + std::string("        or as HTML.\n")) + std::string("    Optionally add color to the nodes."));
    std::vector<std::string> cols2 = std::vector<std::string>{blue, yellow, orange, green, pink};
    std::vector<std::map<std::string, std::any>> nodes2 = makeIndent(outline2, int64_t(4));
    std::map<std::string, std::any> n2 = std::map<std::string, std::any>{{"name", std::any(std::string(""))}, {"children", std::any(std::vector<std::any>{})}};
    toNest(nodes2, int64_t(0), int64_t(0), n2);
    std::cout << toMarkup(n2, cols2, int64_t(4));
    std::cout << std::endl;
    return 0;
}
