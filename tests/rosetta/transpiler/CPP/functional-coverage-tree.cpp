// Generated by Mochi transpiler v0.10.57 on 2025-08-04 22:12:36 GMT+7
#include <iostream>
#include <string>
#include <sstream>
#include <any>
#include <map>
#include <vector>
#include <iomanip>
#include <cmath>
#include <optional>
#include <type_traits>


static std::string _repeat(const std::string& s, int64_t n) {
    std::string out; out.reserve(s.size()*n);
    for(int64_t i=0;i<n;i++) out += s;
    return out;
}
static void any_to_stream(std::ostream& os, const std::any& val) {
    if(val.type() == typeid(int)) os << std::any_cast<int>(val);
    else if(val.type() == typeid(int64_t)) os << std::any_cast<int64_t>(val);
    else if(val.type() == typeid(double)) os << std::any_cast<double>(val);
    else if(val.type() == typeid(bool)) os << (std::any_cast<bool>(val) ? "true" : "false");
    else if(val.type() == typeid(std::string)) os << std::any_cast<std::string>(val);
    else if(val.type() == typeid(std::vector<int64_t>)) { const auto& v = std::any_cast<const std::vector<int64_t>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::vector<int64_t>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int64_t>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; any_to_stream(os, v[i]); } os << ']'; }
    else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
    else os << "<any>";
}
static double any_to_double(const std::any& v) {
    if(v.type() == typeid(int)) return (double)std::any_cast<int>(v);
    if(v.type() == typeid(double)) return std::any_cast<double>(v);
    return 0;
}
static std::string any_to_string(const std::any& v) {
    if(v.type() == typeid(std::string)) return std::any_cast<std::string>(v);
    if(v.type() == typeid(int)) return std::to_string(std::any_cast<int>(v));
    if(v.type() == typeid(int64_t)) return std::to_string(std::any_cast<int64_t>(v));
    if(v.type() == typeid(double)) { std::ostringstream ss; ss << std::any_cast<double>(v); return ss.str(); }
    if(v.type() == typeid(bool)) return std::any_cast<bool>(v) ? "true" : "false";
    return std::string();
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ", "; if constexpr(std::is_same_v<T, std::any>) any_to_stream(os, vec[i]); else os << vec[i]; }
    os << "]";
    return os;
}


template<typename T> std::string _to_string(const T& v) {
    std::ostringstream ss;
    ss << std::boolalpha << v;
    return ss.str();
}

double pow10(int64_t n);
std::string formatFloat(double f, int64_t prec);
std::string padLeft(std::string s, int64_t w);
std::string repeat(std::string ch, int64_t n);
double toFloat(int64_t i);
std::map<std::string, std::any> newNode(std::string name, int64_t weight, double coverage);
void addChildren(std::map<std::string, std::any> n, const std::vector<std::map<std::string, std::any>>& nodes);
void setCoverage(std::map<std::string, std::any> n, double value);
double computeCoverage(const std::map<std::string, std::any>& n);
std::string spaces(int64_t n);
void show(const std::map<std::string, std::any>& n, int64_t level);
int main();

std::map<std::string, std::any> house1 = newNode(std::string("house1"), int64_t(40), 0.0);
std::map<std::string, std::any> house2 = newNode(std::string("house2"), int64_t(60), 0.0);
std::map<std::string, std::any> h1_bedrooms = newNode(std::string("bedrooms"), int64_t(1), 0.25);
std::map<std::string, std::any> h1_bathrooms = newNode(std::string("bathrooms"), int64_t(1), 0.0);
std::map<std::string, std::any> h1_attic = newNode(std::string("attic"), int64_t(1), 0.75);
std::map<std::string, std::any> h1_kitchen = newNode(std::string("kitchen"), int64_t(1), 0.1);
std::map<std::string, std::any> h1_living_rooms = newNode(std::string("living_rooms"), int64_t(1), 0.0);
std::map<std::string, std::any> h1_basement = newNode(std::string("basement"), int64_t(1), 0.0);
std::map<std::string, std::any> h1_garage = newNode(std::string("garage"), int64_t(1), 0.0);
std::map<std::string, std::any> h1_garden = newNode(std::string("garden"), int64_t(1), 0.8);
std::map<std::string, std::any> h2_upstairs = newNode(std::string("upstairs"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_groundfloor = newNode(std::string("groundfloor"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_basement = newNode(std::string("basement"), int64_t(1), 0.0);
std::map<std::string, std::any> h1_bathroom1 = newNode(std::string("bathroom1"), int64_t(1), 0.5);
std::map<std::string, std::any> h1_bathroom2 = newNode(std::string("bathroom2"), int64_t(1), 0.0);
std::map<std::string, std::any> h1_outside = newNode(std::string("outside_lavatory"), int64_t(1), 1.0);
std::map<std::string, std::any> h1_lounge = newNode(std::string("lounge"), int64_t(1), 0.0);
std::map<std::string, std::any> h1_dining = newNode(std::string("dining_room"), int64_t(1), 0.0);
std::map<std::string, std::any> h1_conservatory = newNode(std::string("conservatory"), int64_t(1), 0.0);
std::map<std::string, std::any> h1_playroom = newNode(std::string("playroom"), int64_t(1), 1.0);
std::map<std::string, std::any> h2_bedrooms = newNode(std::string("bedrooms"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_bathroom = newNode(std::string("bathroom"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_toilet = newNode(std::string("toilet"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_attics = newNode(std::string("attics"), int64_t(1), 0.6);
std::map<std::string, std::any> h2_kitchen = newNode(std::string("kitchen"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_living_rooms = newNode(std::string("living_rooms"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_wet_room = newNode(std::string("wet_room_&_toilet"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_garage = newNode(std::string("garage"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_garden = newNode(std::string("garden"), int64_t(1), 0.9);
std::map<std::string, std::any> h2_hot_tub = newNode(std::string("hot_tub_suite"), int64_t(1), 1.0);
std::map<std::string, std::any> h2_cellars = newNode(std::string("cellars"), int64_t(1), 1.0);
std::map<std::string, std::any> h2_wine_cellar = newNode(std::string("wine_cellar"), int64_t(1), 1.0);
std::map<std::string, std::any> h2_cinema = newNode(std::string("cinema"), int64_t(1), 0.75);
std::map<std::string, std::any> h2_suite1 = newNode(std::string("suite_1"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_suite2 = newNode(std::string("suite_2"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_bedroom3 = newNode(std::string("bedroom_3"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_bedroom4 = newNode(std::string("bedroom_4"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_lounge = newNode(std::string("lounge"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_dining = newNode(std::string("dining_room"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_conservatory = newNode(std::string("conservatory"), int64_t(1), 0.0);
std::map<std::string, std::any> h2_playroom = newNode(std::string("playroom"), int64_t(1), 0.0);

double pow10(int64_t n) {
    double r = 1.0;
    int64_t i = int64_t(0);
    while ((i < n)) {
        r = (r * 10.0);
        i = (i + int64_t(1));
    }
    return r;
}

std::string formatFloat(double f, int64_t prec) {
    double scale = pow10(prec);
    double scaled = ((f * scale) + 0.5);
    int64_t n = (int64_t)(scaled);
    std::string digits = ([&]{ std::ostringstream ss; ss << std::boolalpha << n; return ss.str(); }());
    while ((digits.size() <= prec)) {
        digits = (std::string("0") + digits);
    }
    std::string intPart = digits.substr(int64_t(0), (digits.size() - prec) - int64_t(0));
    std::string fracPart = digits.substr((digits.size() - prec), digits.size() - (digits.size() - prec));
    return ((intPart + std::string(".")) + fracPart);
}

std::string padLeft(std::string s, int64_t w) {
    std::string res = std::string("");
    int64_t n = (w - s.size());
    while ((n > int64_t(0))) {
        res = (res + std::string(" "));
        n = (n - int64_t(1));
    }
    return (res + s);
}

std::string repeat(std::string ch, int64_t n) {
    std::string s = std::string("");
    int64_t i = int64_t(0);
    while ((i < n)) {
        s = (s + ch);
        i = (i + int64_t(1));
    }
    return s;
}

double toFloat(int64_t i) {
    return (double)(i);
}

std::map<std::string, std::any> newNode(std::string name, int64_t weight, double coverage) {
    return std::map<std::string, std::any>{{"name", std::any(name)}, {"weight", std::any(weight)}, {"coverage", std::any(coverage)}, {"children", std::any(std::vector<int64_t>{})}};
}

void addChildren(std::map<std::string, std::any> n, const std::vector<std::map<std::string, std::any>>& nodes) {
    std::vector<std::any> cs = std::any_cast<std::vector<std::any>>(([&](const auto& __m){ auto __it = __m.find(std::string("children")); return __it != __m.end() ? __it->second : std::any{}; })(n));
    for (std::map<std::string, std::any> node : nodes) {
        cs = ([&]{ auto __tmp = cs; __tmp.push_back((std::any)node); return __tmp; }());
    }
    n[std::string("children")] = cs;
}

void setCoverage(std::map<std::string, std::any> n, double value) {
    n[std::string("coverage")] = value;
}

double computeCoverage(const std::map<std::string, std::any>& n) {
    std::vector<std::any> cs = std::any_cast<std::vector<std::any>>(([&](const auto& __m){ auto __it = __m.find(std::string("children")); return __it != __m.end() ? __it->second : std::any{}; })(n));
    if ((cs.size() == int64_t(0))) {
        return std::any_cast<double>(([&](const auto& __m){ auto __it = __m.find(std::string("coverage")); return __it != __m.end() ? __it->second : std::any{}; })(n));
    }
    double v1 = 0.0;
    int64_t v2 = int64_t(0);
    for (std::any node : cs) {
        std::map<std::string, std::any> m = std::any_cast<std::map<std::string, std::any>>(node);
        double c = computeCoverage(m);
        v1 = (v1 + (toFloat(std::any_cast<int64_t>(([&](const auto& __m){ auto __it = __m.find(std::string("weight")); return __it != __m.end() ? __it->second : std::any{}; })(m))) * c));
        v2 = (v2 + std::any_cast<int64_t>(([&](const auto& __m){ auto __it = __m.find(std::string("weight")); return __it != __m.end() ? __it->second : std::any{}; })(m)));
    }
    return ((double)(v1) / (toFloat(v2)));
}

std::string spaces(int64_t n) {
    return _repeat(std::string(" "), n);
}

void show(const std::map<std::string, std::any>& n, int64_t level) {
    int64_t indent = (level * int64_t(4));
    std::string name = std::any_cast<std::string>(([&](const auto& __m){ auto __it = __m.find(std::string("name")); return __it != __m.end() ? __it->second : std::any{}; })(n));
    int64_t nl = (name.size() + indent);
    std::string line = (spaces(indent) + name);
    line = ((line + spaces((int64_t(32) - nl))) + std::string("|  "));
    line = ((line + padLeft(([&]{ std::ostringstream ss; ss << std::boolalpha << std::any_cast<int64_t>(([&](const auto& __m){ auto __it = __m.find(std::string("weight")); return __it != __m.end() ? __it->second : std::any{}; })(n)); return ss.str(); }()), int64_t(3))) + std::string("   | "));
    line = ((line + formatFloat(computeCoverage(n), int64_t(6))) + std::string(" |"));
    std::cout << line;
    std::cout << std::endl;
    std::vector<std::any> cs = std::any_cast<std::vector<std::any>>(([&](const auto& __m){ auto __it = __m.find(std::string("children")); return __it != __m.end() ? __it->second : std::any{}; })(n));
    for (std::any child : cs) {
        show(std::any_cast<std::map<std::string, std::any>>(child), (level + int64_t(1)));
    }
}

int main() {
    std::map<std::string, std::any> cleaning = newNode(std::string("cleaning"), int64_t(1), 0.0);
    addChildren(h1_bathrooms, std::vector<std::map<std::string, std::any>>{h1_bathroom1, h1_bathroom2, h1_outside});
    addChildren(h1_living_rooms, std::vector<std::map<std::string, std::any>>{h1_lounge, h1_dining, h1_conservatory, h1_playroom});
    addChildren(house1, std::vector<std::map<std::string, std::any>>{h1_bedrooms, h1_bathrooms, h1_attic, h1_kitchen, h1_living_rooms, h1_basement, h1_garage, h1_garden});
    addChildren(h2_bedrooms, std::vector<std::map<std::string, std::any>>{h2_suite1, h2_suite2, h2_bedroom3, h2_bedroom4});
    addChildren(h2_upstairs, std::vector<std::map<std::string, std::any>>{h2_bedrooms, h2_bathroom, h2_toilet, h2_attics});
    addChildren(h2_living_rooms, std::vector<std::map<std::string, std::any>>{h2_lounge, h2_dining, h2_conservatory, h2_playroom});
    addChildren(h2_groundfloor, std::vector<std::map<std::string, std::any>>{h2_kitchen, h2_living_rooms, h2_wet_room, h2_garage, h2_garden, h2_hot_tub});
    addChildren(h2_basement, std::vector<std::map<std::string, std::any>>{h2_cellars, h2_wine_cellar, h2_cinema});
    addChildren(house2, std::vector<std::map<std::string, std::any>>{h2_upstairs, h2_groundfloor, h2_basement});
    addChildren(cleaning, std::vector<std::map<std::string, std::any>>{house1, house2});
    double topCoverage = computeCoverage(cleaning);
    std::cout << (std::string("TOP COVERAGE = ") + formatFloat(topCoverage, int64_t(6)));
    std::cout << std::endl;
    std::cout << std::string("");
    std::cout << std::endl;
    std::cout << std::string("NAME HIERARCHY                 | WEIGHT | COVERAGE |");
    std::cout << std::endl;
    show(cleaning, int64_t(0));
    setCoverage(h2_cinema, 1.0);
    double diff = (computeCoverage(cleaning) - topCoverage);
    std::cout << std::string("");
    std::cout << std::endl;
    std::cout << std::string("If the coverage of the Cinema node were increased from 0.75 to 1");
    std::cout << std::endl;
    std::cout << (((std::string("the top level coverage would increase by ") + formatFloat(diff, int64_t(6))) + std::string(" to ")) + formatFloat((topCoverage + diff), int64_t(6)));
    std::cout << std::endl;
    setCoverage(h2_cinema, 0.75);
    return 0;
}
