// Generated by Mochi transpiler v0.10.56 on 2025-08-03 17:54:09 GMT+7
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <optional>
#include <any>
#include <type_traits>


static long _index_of(const std::string& s, const std::string& sub) {
    auto pos = s.find(sub);
    return pos == std::string::npos ? -1 : static_cast<long>(pos);
}
template<typename T> long _index_of(const std::vector<T>& xs, const T& v) {
    for(size_t i=0;i<xs.size();++i){ if(xs[i]==v) return i; }
    return -1;
}
static long _parse_int_str(const std::string& s, long base) {
    return std::stol(s, nullptr, base);
}
static void any_to_stream(std::ostream& os, const std::any& val) {
    if(val.type() == typeid(int)) os << std::any_cast<int>(val);
    else if(val.type() == typeid(int64_t)) os << std::any_cast<int64_t>(val);
    else if(val.type() == typeid(double)) os << std::any_cast<double>(val);
    else if(val.type() == typeid(bool)) os << (std::any_cast<bool>(val) ? "true" : "false");
    else if(val.type() == typeid(std::string)) os << std::any_cast<std::string>(val);
    else if(val.type() == typeid(std::vector<int64_t>)) { const auto& v = std::any_cast<const std::vector<int64_t>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::vector<int64_t>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int64_t>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; any_to_stream(os, v[i]); } os << ']'; }
    else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
    else os << "<any>";
}
static double any_to_double(const std::any& v) {
    if(v.type() == typeid(int)) return (double)std::any_cast<int>(v);
    if(v.type() == typeid(double)) return std::any_cast<double>(v);
    return 0;
}
static std::string any_to_string(const std::any& v) {
    if(v.type() == typeid(std::string)) return std::any_cast<std::string>(v);
    if(v.type() == typeid(int)) return std::to_string(std::any_cast<int>(v));
    if(v.type() == typeid(int64_t)) return std::to_string(std::any_cast<int64_t>(v));
    if(v.type() == typeid(double)) { std::ostringstream ss; ss << std::any_cast<double>(v); return ss.str(); }
    if(v.type() == typeid(bool)) return std::any_cast<bool>(v) ? "true" : "false";
    return std::string();
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ", "; if constexpr(std::is_same_v<T, std::any>) any_to_stream(os, vec[i]); else os << vec[i]; }
    os << "]";
    return os;
}


template<typename T> std::string _to_string(const T& v) {
    std::ostringstream ss;
    ss << std::boolalpha << v;
    return ss.str();
}

bool isLeap(int64_t y);
int64_t daysInMonth(int64_t y, int64_t m);
int64_t daysBeforeYear(int64_t y);
int64_t daysBeforeMonth(int64_t y, int64_t m);
int64_t epochSeconds(int64_t y, int64_t m, int64_t d, int64_t h, int64_t mi);
std::vector<int64_t> fromEpoch(int64_t sec);
std::string pad2(int64_t n);
int64_t absInt(int64_t n);
std::string formatDate(const std::vector<int64_t>& parts, int64_t offset, std::string abbr);
int64_t parseIntStr(std::string str);
int64_t indexOf(std::string s, std::string ch);
std::vector<int64_t> parseTime(std::string s);
int main();

std::map<std::string, int64_t> months = std::map<std::string, int64_t>{{"January", int64_t(1)}, {"February", int64_t(2)}, {"March", int64_t(3)}, {"April", int64_t(4)}, {"May", int64_t(5)}, {"June", int64_t(6)}, {"July", int64_t(7)}, {"August", int64_t(8)}, {"September", int64_t(9)}, {"October", int64_t(10)}, {"November", int64_t(11)}, {"December", int64_t(12)}};

bool isLeap(int64_t y) {
    if (((y % int64_t(400)) == int64_t(0))) {
        return true;
    }
    if (((y % int64_t(100)) == int64_t(0))) {
        return false;
    }
    return ((y % int64_t(4)) == int64_t(0));
}

int64_t daysInMonth(int64_t y, int64_t m) {
    int64_t feb = (isLeap(y) ? int64_t(29) : int64_t(28));
    std::vector<int64_t> lengths = std::vector<int64_t>{int64_t(31), feb, int64_t(31), int64_t(30), int64_t(31), int64_t(30), int64_t(31), int64_t(31), int64_t(30), int64_t(31), int64_t(30), int64_t(31)};
    return lengths[(m - int64_t(1))];
}

int64_t daysBeforeYear(int64_t y) {
    int64_t days = int64_t(0);
    int64_t yy = int64_t(1970);
    while ((yy < y)) {
        days = (days + int64_t(365));
        if (isLeap(yy)) {
            days = (days + int64_t(1));
        }
        yy = (yy + int64_t(1));
    }
    return days;
}

int64_t daysBeforeMonth(int64_t y, int64_t m) {
    int64_t days = int64_t(0);
    int64_t mm = int64_t(1);
    while ((mm < m)) {
        days = (days + daysInMonth(y, mm));
        mm = (mm + int64_t(1));
    }
    return days;
}

int64_t epochSeconds(int64_t y, int64_t m, int64_t d, int64_t h, int64_t mi) {
    int64_t days = ((daysBeforeYear(y) + daysBeforeMonth(y, m)) + (d - int64_t(1)));
    return (((days * int64_t(86400)) + (h * int64_t(3600))) + (mi * int64_t(60)));
}

std::vector<int64_t> fromEpoch(int64_t sec) {
    int64_t days = (sec / int64_t(86400));
    int64_t rem = (sec % int64_t(86400));
    int64_t y = int64_t(1970);
    while (true) {
        int64_t dy = (isLeap(y) ? int64_t(366) : int64_t(365));
        if ((days >= dy)) {
            days = (days - dy);
            y = (y + int64_t(1));
        } else {
            break;
        }
    }
    int64_t m = int64_t(1);
    while (true) {
        int64_t dim = daysInMonth(y, m);
        if ((days >= dim)) {
            days = (days - dim);
            m = (m + int64_t(1));
        } else {
            break;
        }
    }
    int64_t d = (days + int64_t(1));
    int64_t h = (rem / int64_t(3600));
    int64_t mi = ((rem % int64_t(3600)) / int64_t(60));
    return std::vector<int64_t>{y, m, d, h, mi};
}

std::string pad2(int64_t n) {
    if ((n < int64_t(10))) {
        return (std::string("0") + ([&]{ std::ostringstream ss; ss << std::boolalpha << n; return ss.str(); }()));
    }
    return ([&]{ std::ostringstream ss; ss << std::boolalpha << n; return ss.str(); }());
}

int64_t absInt(int64_t n) {
    if ((n < int64_t(0))) {
        return -n;
    }
    return n;
}

std::string formatDate(const std::vector<int64_t>& parts, int64_t offset, std::string abbr) {
    int64_t y = parts[int64_t(0)];
    int64_t m = parts[int64_t(1)];
    int64_t d = parts[int64_t(2)];
    int64_t h = parts[int64_t(3)];
    int64_t mi = parts[int64_t(4)];
    std::string sign = std::string("+");
    if ((offset < int64_t(0))) {
        sign = std::string("-");
    }
    int64_t off = (absInt(offset) / int64_t(60));
    std::string offh = pad2((off / int64_t(60)));
    std::string offm = pad2((off % int64_t(60)));
    return ((((((((((((((([&]{ std::ostringstream ss; ss << std::boolalpha << y; return ss.str(); }()) + std::string("-")) + pad2(m)) + std::string("-")) + pad2(d)) + std::string(" ")) + pad2(h)) + std::string(":")) + pad2(mi)) + std::string(":00 ")) + sign) + offh) + offm) + std::string(" ")) + abbr);
}

int64_t parseIntStr(std::string str) {
    int64_t i = int64_t(0);
    bool neg = false;
    if (((str.size() > int64_t(0)) && (str.substr(int64_t(0), int64_t(1) - int64_t(0)) == std::string("-")))) {
        neg = true;
        i = int64_t(1);
    }
    int64_t n = int64_t(0);
    std::map<std::string, int64_t> digits = std::map<std::string, int64_t>{{"0", int64_t(0)}, {"1", int64_t(1)}, {"2", int64_t(2)}, {"3", int64_t(3)}, {"4", int64_t(4)}, {"5", int64_t(5)}, {"6", int64_t(6)}, {"7", int64_t(7)}, {"8", int64_t(8)}, {"9", int64_t(9)}};
    while ((i < str.size())) {
        n = ((n * int64_t(10)) + ([&](auto& __m){ auto __it = __m.find(str.substr(i, (i + int64_t(1)) - i)); return __it != __m.end() ? __it->second : 0; })(digits));
        i = (i + int64_t(1));
    }
    if (neg) {
        n = -n;
    }
    return n;
}

int64_t indexOf(std::string s, std::string ch) {
    int64_t i = int64_t(0);
    while ((i < s.size())) {
        if ((s.substr(i, (i + int64_t(1)) - i) == ch)) {
            return i;
        }
        i = (i + int64_t(1));
    }
    return -int64_t(1);
}

std::vector<int64_t> parseTime(std::string s) {
    int64_t c = _index_of(s, std::string(":"));
    int64_t h = _parse_int_str(s.substr(int64_t(0), c - int64_t(0)), int64_t(10));
    int64_t mi = _parse_int_str(s.substr((c + int64_t(1)), (c + int64_t(3)) - (c + int64_t(1))), int64_t(10));
    std::string ampm = s.substr((s.size() - int64_t(2)), s.size() - (s.size() - int64_t(2)));
    int64_t hh = h;
    if (((ampm == std::string("pm")) && (h != int64_t(12)))) {
        hh = (h + int64_t(12));
    }
    if (((ampm == std::string("am")) && (h == int64_t(12)))) {
        hh = int64_t(0);
    }
    return std::vector<int64_t>{hh, mi};
}

int main() {
    std::string input = std::string("March 7 2009 7:30pm EST");
    std::cout << (std::string("Input:              ") + input);
    std::cout << std::endl;
    std::vector<int64_t> parts = {};
    std::string cur = std::string("");
    int64_t i = int64_t(0);
    while ((i < input.size())) {
        std::string ch = input.substr(i, (i + int64_t(1)) - i);
        if ((ch == std::string(" "))) {
            if ((cur.size() > int64_t(0))) {
                parts = ([&]{ auto __tmp = parts; __tmp.push_back((int64_t)cur); return __tmp; }());
                cur = std::string("");
            }
        } else {
            cur = (cur + ch);
        }
        i = (i + int64_t(1));
    }
    if ((cur.size() > int64_t(0))) {
        parts = ([&]{ auto __tmp = parts; __tmp.push_back((int64_t)cur); return __tmp; }());
    }
    int64_t month = ([&](auto& __m){ auto __it = __m.find(parts[int64_t(0)]); return __it != __m.end() ? __it->second : 0; })(months);
    int64_t day = _parse_int_str(parts[int64_t(1)], int64_t(10));
    int64_t year = _parse_int_str(parts[int64_t(2)], int64_t(10));
    std::vector<int64_t> tm = parseTime(std::string(1, parts[int64_t(3)]));
    int64_t hour = tm[int64_t(0)];
    int64_t minute = tm[int64_t(1)];
    int64_t tz = parts[int64_t(4)];
    std::map<std::string, int64_t> zoneOffsets = std::map<std::string, int64_t>{{"EST", -int64_t(18000)}, {"EDT", -int64_t(14400)}, {"MST", -int64_t(25200)}};
    int64_t local = epochSeconds(year, month, day, hour, minute);
    int64_t utc = (local - ([&](auto& __m){ auto __it = __m.find(tz); return __it != __m.end() ? __it->second : 0; })(zoneOffsets));
    int64_t utc12 = (utc + int64_t(43200));
    int64_t startDST = epochSeconds(int64_t(2009), int64_t(3), int64_t(8), int64_t(7), int64_t(0));
    int64_t offEast = -int64_t(18000);
    if ((utc12 >= startDST)) {
        offEast = -int64_t(14400);
    }
    std::vector<int64_t> eastParts = fromEpoch((utc12 + offEast));
    std::string eastAbbr = std::string("EST");
    if ((offEast == -int64_t(14400))) {
        eastAbbr = std::string("EDT");
    }
    std::cout << (std::string("+12 hrs:            ") + formatDate(eastParts, offEast, eastAbbr));
    std::cout << std::endl;
    int64_t offAZ = -int64_t(25200);
    std::vector<int64_t> azParts = fromEpoch((utc12 + offAZ));
    std::cout << (std::string("+12 hrs in Arizona: ") + formatDate(azParts, offAZ, std::string("MST")));
    std::cout << std::endl;
    return 0;
}
