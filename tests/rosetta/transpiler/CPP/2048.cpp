// Generated by Mochi transpiler v0.10.37 on 2025-07-23 10:42:23 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <any>
#include <map>
#include <sstream>
#include <iomanip>
#include <optional>
#include <cstdlib>
#include <chrono>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}

std::vector<std::vector<int>> newBoard();
std::map<std::string, std::any> spawnTile(std::vector<std::vector<int>> b);
std::string pad(int n);
void draw(std::vector<std::vector<int>> b, int score);
std::vector<int> reverseRow(std::vector<int> r);
std::map<std::string, std::any> slideLeft(std::vector<int> row);
std::map<std::string, std::any> moveLeft(std::vector<std::vector<int>> b, int score);
std::map<std::string, std::any> moveRight(std::vector<std::vector<int>> b, int score);
std::vector<int> getCol(std::vector<std::vector<int>> b, int x);
void setCol(std::vector<std::vector<int>> b, int x, std::vector<int> col);
std::map<std::string, std::any> moveUp(std::vector<std::vector<int>> b, int score);
std::map<std::string, std::any> moveDown(std::vector<std::vector<int>> b, int score);
bool hasMoves(std::vector<std::vector<int>> b);
bool has2048(std::vector<std::vector<int>> b);
int main();

int SIZE = 4;
auto board = newBoard();
auto r = spawnTile(board);
std::any full = r[std::string("full")];
int score = 0;

std::vector<std::vector<int>> newBoard() {
    std::vector<std::vector<int>> b = {};
    int y = 0;
    while ((y < SIZE)) {
        std::vector<int> row = {};
        int x = 0;
        while ((x < SIZE)) {
            row = ([&]{ auto __tmp = row; __tmp.push_back(0); return __tmp; }());
            x = (x + 1);
        }
        b = ([&]{ auto __tmp = b; __tmp.push_back(row); return __tmp; }());
        y = (y + 1);
    }
    return b;
}

std::map<std::string, std::any> spawnTile(std::vector<std::vector<int>> b) {
    std::vector<std::vector<int>> empty = {};
    int y = 0;
    while ((y < SIZE)) {
        int x = 0;
        while ((x < SIZE)) {
            if ((b[y][x] == 0)) {
                empty = ([&]{ auto __tmp = empty; __tmp.push_back(std::vector{x, y}); return __tmp; }());
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    if ((empty.size() == 0)) {
        return std::map<std::string, std::any>{{"board", std::any(b)}, {"full", std::any(true)}};
    }
    int idx = (_now() % empty.size());
    std::vector<int> cell = empty[idx];
    int val = 4;
    if (((_now() % 10) < 9)) {
        val = 2;
    }
    b[cell[1]][cell[0]] = val;
    return std::map<std::string, std::any>{{"board", std::any(b)}, {"full", std::any((empty.size() == 1))}};
}

std::string pad(int n) {
    std::string s = ([&]{ std::ostringstream ss; ss<<n; return ss.str(); }());
    int pad = (4 - s.size());
    int i = 0;
    std::string out = std::string("");
    while ((i < pad)) {
        out = (out + std::string(" "));
        i = (i + 1);
    }
    return (out + s);
}

void draw(std::vector<std::vector<int>> b, int score) {
    std::cout << (std::string("Score: ") + ([&]{ std::ostringstream ss; ss<<score; return ss.str(); }()));
    std::cout << std::endl;
    int y = 0;
    while ((y < SIZE)) {
        std::cout << std::string("+----+----+----+----+");
        std::cout << std::endl;
        std::string line = std::string("|");
        int x = 0;
        while ((x < SIZE)) {
            int v = b[y][x];
            if ((v == 0)) {
                line = (line + std::string("    |"));
            } else {
                line = ((line + pad(v)) + std::string("|"));
            }
            x = (x + 1);
        }
        std::cout << line;
        std::cout << std::endl;
        y = (y + 1);
    }
    std::cout << std::string("+----+----+----+----+");
    std::cout << std::endl;
    std::cout << std::string("W=Up S=Down A=Left D=Right Q=Quit");
    std::cout << std::endl;
}

std::vector<int> reverseRow(std::vector<int> r) {
    std::vector<int> out = {};
    int i = (r.size() - 1);
    while ((i >= 0)) {
        out = ([&]{ auto __tmp = out; __tmp.push_back(r[i]); return __tmp; }());
        i = (i - 1);
    }
    return out;
}

std::map<std::string, std::any> slideLeft(std::vector<int> row) {
    std::vector<int> xs = {};
    int i = 0;
    while ((i < row.size())) {
        if ((row[i] != 0)) {
            xs = ([&]{ auto __tmp = xs; __tmp.push_back(row[i]); return __tmp; }());
        }
        i = (i + 1);
    }
    std::vector<int> res = {};
    int gain = 0;
    i = 0;
    while ((i < xs.size())) {
        if ((((i + 1) < xs.size()) && (xs[i] == xs[(i + 1)]))) {
            int v = (xs[i] * 2);
            gain = (gain + v);
            res = ([&]{ auto __tmp = res; __tmp.push_back(v); return __tmp; }());
            i = (i + 2);
        } else {
            res = ([&]{ auto __tmp = res; __tmp.push_back(xs[i]); return __tmp; }());
            i = (i + 1);
        }
    }
    while ((res.size() < SIZE)) {
        res = ([&]{ auto __tmp = res; __tmp.push_back(0); return __tmp; }());
    }
    return std::map<std::string, std::any>{{"row", std::any(res)}, {"gain", std::any(gain)}};
}

std::map<std::string, std::any> moveLeft(std::vector<std::vector<int>> b, int score) {
    bool moved = false;
    int y = 0;
    while ((y < SIZE)) {
        std::map<std::string, std::any> r = slideLeft(b[y]);
        std::any _new = r[std::string("row")];
        score = (score + std::any_cast<int>(r[std::string("gain")]));
        int x = 0;
        while ((x < SIZE)) {
            if ((b[y][x] != _new[x])) {
                moved = true;
            }
            b[y][x] = _new[x];
            x = (x + 1);
        }
        y = (y + 1);
    }
    return std::map<std::string, std::any>{{"board", std::any(b)}, {"score", std::any(score)}, {"moved", std::any(moved)}};
}

std::map<std::string, std::any> moveRight(std::vector<std::vector<int>> b, int score) {
    bool moved = false;
    int y = 0;
    while ((y < SIZE)) {
        std::vector<int> rev = reverseRow(b[y]);
        std::map<std::string, std::any> r = slideLeft(rev);
        rev = r[std::string("row")];
        score = (score + std::any_cast<int>(r[std::string("gain")]));
        rev = reverseRow(rev);
        int x = 0;
        while ((x < SIZE)) {
            if ((b[y][x] != rev[x])) {
                moved = true;
            }
            b[y][x] = rev[x];
            x = (x + 1);
        }
        y = (y + 1);
    }
    return std::map<std::string, std::any>{{"board", std::any(b)}, {"score", std::any(score)}, {"moved", std::any(moved)}};
}

std::vector<int> getCol(std::vector<std::vector<int>> b, int x) {
    std::vector<int> col = {};
    int y = 0;
    while ((y < SIZE)) {
        col = ([&]{ auto __tmp = col; __tmp.push_back(b[y][x]); return __tmp; }());
        y = (y + 1);
    }
    return col;
}

void setCol(std::vector<std::vector<int>> b, int x, std::vector<int> col) {
    int y = 0;
    while ((y < SIZE)) {
        b[y][x] = col[y];
        y = (y + 1);
    }
}

std::map<std::string, std::any> moveUp(std::vector<std::vector<int>> b, int score) {
    bool moved = false;
    int x = 0;
    while ((x < SIZE)) {
        std::vector<int> col = getCol(b, x);
        std::map<std::string, std::any> r = slideLeft(col);
        std::any _new = r[std::string("row")];
        score = (score + std::any_cast<int>(r[std::string("gain")]));
        int y = 0;
        while ((y < SIZE)) {
            if ((b[y][x] != _new[y])) {
                moved = true;
            }
            b[y][x] = _new[y];
            y = (y + 1);
        }
        x = (x + 1);
    }
    return std::map<std::string, std::any>{{"board", std::any(b)}, {"score", std::any(score)}, {"moved", std::any(moved)}};
}

std::map<std::string, std::any> moveDown(std::vector<std::vector<int>> b, int score) {
    bool moved = false;
    int x = 0;
    while ((x < SIZE)) {
        std::vector<int> col = reverseRow(getCol(b, x));
        std::map<std::string, std::any> r = slideLeft(col);
        col = r[std::string("row")];
        score = (score + std::any_cast<int>(r[std::string("gain")]));
        col = reverseRow(col);
        int y = 0;
        while ((y < SIZE)) {
            if ((b[y][x] != col[y])) {
                moved = true;
            }
            b[y][x] = col[y];
            y = (y + 1);
        }
        x = (x + 1);
    }
    return std::map<std::string, std::any>{{"board", std::any(b)}, {"score", std::any(score)}, {"moved", std::any(moved)}};
}

bool hasMoves(std::vector<std::vector<int>> b) {
    int y = 0;
    while ((y < SIZE)) {
        int x = 0;
        while ((x < SIZE)) {
            if ((b[y][x] == 0)) {
                return true;
            }
            if ((((x + 1) < SIZE) && (b[y][x] == b[y][(x + 1)]))) {
                return true;
            }
            if ((((y + 1) < SIZE) && (b[y][x] == b[(y + 1)][x]))) {
                return true;
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    return false;
}

bool has2048(std::vector<std::vector<int>> b) {
    int y = 0;
    while ((y < SIZE)) {
        int x = 0;
        while ((x < SIZE)) {
            if ((b[y][x] >= 2048)) {
                return true;
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    return false;
}

int main() {
    board = r[std::string("board")];
    r = spawnTile(board);
    board = r[std::string("board")];
    full = r[std::string("full")];
    draw(board, score);
    while (true) {
        std::cout << std::string("Move: ");
        std::cout << std::endl;
        std::string cmd = ([&]{ std::string __line; std::getline(std::cin, __line); return __line; }());
        bool moved = false;
        if (((cmd == std::string("a")) || (cmd == std::string("A")))) {
            std::map<std::string, std::any> m = moveLeft(board, score);
            board = m[std::string("board")];
            score = m[std::string("score")];
            moved = m[std::string("moved")];
        }
        if (((cmd == std::string("d")) || (cmd == std::string("D")))) {
            std::map<std::string, std::any> m = moveRight(board, score);
            board = m[std::string("board")];
            score = m[std::string("score")];
            moved = m[std::string("moved")];
        }
        if (((cmd == std::string("w")) || (cmd == std::string("W")))) {
            std::map<std::string, std::any> m = moveUp(board, score);
            board = m[std::string("board")];
            score = m[std::string("score")];
            moved = m[std::string("moved")];
        }
        if (((cmd == std::string("s")) || (cmd == std::string("S")))) {
            std::map<std::string, std::any> m = moveDown(board, score);
            board = m[std::string("board")];
            score = m[std::string("score")];
            moved = m[std::string("moved")];
        }
        if (((cmd == std::string("q")) || (cmd == std::string("Q")))) {
            break;
        }
        if (moved) {
            std::map<std::string, std::any> r2 = spawnTile(board);
            board = r2[std::string("board")];
            full = r2[std::string("full")];
            if ((std::any_cast<bool>(full) && !hasMoves(board))) {
                draw(board, score);
                std::cout << std::string("Game Over");
                std::cout << std::endl;
                break;
            }
        }
        draw(board, score);
        if (has2048(board)) {
            std::cout << std::string("You win!");
            std::cout << std::endl;
            break;
        }
        if (!hasMoves(board)) {
            std::cout << std::string("Game Over");
            std::cout << std::endl;
            break;
        }
    }
    return 0;
}
