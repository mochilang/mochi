// Generated by Mochi transpiler v0.10.38 on 2025-07-24 00:52:04 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <iomanip>
#include <optional>
#include <cstdlib>
#include <chrono>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ", "; os << vec[i]; }
    os << "]";
    return os;
}



struct Board {
    std::vector<std::vector<int>> cells;
    auto operator<=>(const Board&) const = default;
};

struct SpawnResult {
    Board board;
    bool full;
    auto operator<=>(const SpawnResult&) const = default;
};

struct SlideResult {
    std::vector<int> row;
    int gain;
    auto operator<=>(const SlideResult&) const = default;
};

struct MoveResult {
    Board board;
    int score;
    bool moved;
    auto operator<=>(const MoveResult&) const = default;
};

std::ostream& operator<<(std::ostream& os, const Board& v) {
    os << '{' << "'cells': "<< "["; for(size_t i=0;i<v.cells.size();++i){ if(i>0) os << ", "; os << v.cells[i]; } os << "]"
 << '}';
    return os;
}

std::ostream& operator<<(std::ostream& os, const SpawnResult& v) {
    os << '{' << "'board': "<< v.board
 << ", " << "'full': "<< v.full
 << '}';
    return os;
}

std::ostream& operator<<(std::ostream& os, const SlideResult& v) {
    os << '{' << "'row': "<< "["; for(size_t i=0;i<v.row.size();++i){ if(i>0) os << ", "; os << v.row[i]; } os << "]"
 << ", " << "'gain': "<< v.gain
 << '}';
    return os;
}

std::ostream& operator<<(std::ostream& os, const MoveResult& v) {
    os << '{' << "'board': "<< v.board
 << ", " << "'score': "<< v.score
 << ", " << "'moved': "<< v.moved
 << '}';
    return os;
}

Board newBoard();
SpawnResult spawnTile(Board b);
std::string pad(int n);
void draw(Board b, int score);
std::vector<int> reverseRow(std::vector<int> r);
SlideResult slideLeft(std::vector<int> row);
MoveResult moveLeft(Board b, int score);
MoveResult moveRight(Board b, int score);
std::vector<int> getCol(Board b, int x);
void setCol(Board b, int x, std::vector<int> col);
MoveResult moveUp(Board b, int score);
MoveResult moveDown(Board b, int score);
bool hasMoves(Board b);
bool has2048(Board b);
int main();

int SIZE = 4;
Board board = newBoard();
SpawnResult r = spawnTile(board);
bool full = r.full;
int score = 0;

Board newBoard() {
    std::vector<std::vector<int>> b = {};
    int y = 0;
    while ((y < SIZE)) {
        std::vector<int> row = {};
        int x = 0;
        while ((x < SIZE)) {
            row = ([&]{ auto __tmp = row; __tmp.push_back(0); return __tmp; }());
            x = (x + 1);
        }
        b = ([&]{ auto __tmp = b; __tmp.push_back(row); return __tmp; }());
        y = (y + 1);
    }
    return Board{.cells = b};
}

SpawnResult spawnTile(Board b) {
    std::vector<std::vector<int>> grid = b.cells;
    std::vector<std::vector<int>> empty = {};
    int y = 0;
    while ((y < SIZE)) {
        int x = 0;
        while ((x < SIZE)) {
            if ((grid[y][x] == 0)) {
                empty = ([&]{ auto __tmp = empty; __tmp.push_back(std::vector{x, y}); return __tmp; }());
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    if ((empty.size() == 0)) {
        return SpawnResult{.board = b, .full = true};
    }
    int idx = (_now() % empty.size());
    std::vector<int> cell = empty[idx];
    int val = 4;
    if (((_now() % 10) < 9)) {
        val = 2;
    }
    grid[cell[1]][cell[0]] = val;
    return SpawnResult{.board = Board{.cells = grid}, .full = (empty.size() == 1)};
}

std::string pad(int n) {
    std::string s = ([&]{ std::ostringstream ss; ss<<n; return ss.str(); }());
    int pad = (4 - s.size());
    int i = 0;
    std::string out = std::string("");
    while ((i < pad)) {
        out = (out + std::string(" "));
        i = (i + 1);
    }
    return (out + s);
}

void draw(Board b, int score) {
    std::cout << (std::string("Score: ") + ([&]{ std::ostringstream ss; ss<<score; return ss.str(); }()));
    std::cout << std::endl;
    int y = 0;
    while ((y < SIZE)) {
        std::cout << std::string("+----+----+----+----+");
        std::cout << std::endl;
        std::string line = std::string("|");
        int x = 0;
        while ((x < SIZE)) {
            int v = b.cells[y][x];
            if ((v == 0)) {
                line = (line + std::string("    |"));
            } else {
                line = ((line + pad(v)) + std::string("|"));
            }
            x = (x + 1);
        }
        std::cout << line;
        std::cout << std::endl;
        y = (y + 1);
    }
    std::cout << std::string("+----+----+----+----+");
    std::cout << std::endl;
    std::cout << std::string("W=Up S=Down A=Left D=Right Q=Quit");
    std::cout << std::endl;
}

std::vector<int> reverseRow(std::vector<int> r) {
    std::vector<int> out = {};
    int i = (r.size() - 1);
    while ((i >= 0)) {
        out = ([&]{ auto __tmp = out; __tmp.push_back(r[i]); return __tmp; }());
        i = (i - 1);
    }
    return out;
}

SlideResult slideLeft(std::vector<int> row) {
    std::vector<int> xs = {};
    int i = 0;
    while ((i < row.size())) {
        if ((row[i] != 0)) {
            xs = ([&]{ auto __tmp = xs; __tmp.push_back(row[i]); return __tmp; }());
        }
        i = (i + 1);
    }
    std::vector<int> res = {};
    int gain = 0;
    i = 0;
    while ((i < xs.size())) {
        if ((((i + 1) < xs.size()) && (xs[i] == xs[(i + 1)]))) {
            int v = (xs[i] * 2);
            gain = (gain + v);
            res = ([&]{ auto __tmp = res; __tmp.push_back(v); return __tmp; }());
            i = (i + 2);
        } else {
            res = ([&]{ auto __tmp = res; __tmp.push_back(xs[i]); return __tmp; }());
            i = (i + 1);
        }
    }
    while ((res.size() < SIZE)) {
        res = ([&]{ auto __tmp = res; __tmp.push_back(0); return __tmp; }());
    }
    return SlideResult{.row = res, .gain = gain};
}

MoveResult moveLeft(Board b, int score) {
    std::vector<std::vector<int>> grid = b.cells;
    bool moved = false;
    int y = 0;
    while ((y < SIZE)) {
        SlideResult r = slideLeft(grid[y]);
        auto _new = r.row;
        score = (score + r.gain);
        int x = 0;
        while ((x < SIZE)) {
            if ((grid[y][x] != _new[x])) {
                moved = true;
            }
            grid[y][x] = _new[x];
            x = (x + 1);
        }
        y = (y + 1);
    }
    return MoveResult{.board = Board{.cells = grid}, .score = score, .moved = moved};
}

MoveResult moveRight(Board b, int score) {
    std::vector<std::vector<int>> grid = b.cells;
    bool moved = false;
    int y = 0;
    while ((y < SIZE)) {
        std::vector<int> rev = reverseRow(grid[y]);
        SlideResult r = slideLeft(rev);
        rev = r.row;
        score = (score + r.gain);
        rev = reverseRow(rev);
        int x = 0;
        while ((x < SIZE)) {
            if ((grid[y][x] != rev[x])) {
                moved = true;
            }
            grid[y][x] = rev[x];
            x = (x + 1);
        }
        y = (y + 1);
    }
    return MoveResult{.board = Board{.cells = grid}, .score = score, .moved = moved};
}

std::vector<int> getCol(Board b, int x) {
    std::vector<int> col = {};
    int y = 0;
    while ((y < SIZE)) {
        col = ([&]{ auto __tmp = col; __tmp.push_back(b.cells[y][x]); return __tmp; }());
        y = (y + 1);
    }
    return col;
}

void setCol(Board b, int x, std::vector<int> col) {
    std::vector<std::vector<int>> rows = b.cells;
    int y = 0;
    while ((y < SIZE)) {
        std::vector<int> row = rows[y];
        row[x] = col[y];
        rows[y] = row;
        y = (y + 1);
    }
    b.cells = rows;
}

MoveResult moveUp(Board b, int score) {
    std::vector<std::vector<int>> grid = b.cells;
    bool moved = false;
    int x = 0;
    while ((x < SIZE)) {
        std::vector<int> col = getCol(b, x);
        SlideResult r = slideLeft(col);
        auto _new = r.row;
        score = (score + r.gain);
        int y = 0;
        while ((y < SIZE)) {
            if ((grid[y][x] != _new[y])) {
                moved = true;
            }
            grid[y][x] = _new[y];
            y = (y + 1);
        }
        x = (x + 1);
    }
    return MoveResult{.board = Board{.cells = grid}, .score = score, .moved = moved};
}

MoveResult moveDown(Board b, int score) {
    std::vector<std::vector<int>> grid = b.cells;
    bool moved = false;
    int x = 0;
    while ((x < SIZE)) {
        std::vector<int> col = reverseRow(getCol(b, x));
        SlideResult r = slideLeft(col);
        col = r.row;
        score = (score + r.gain);
        col = reverseRow(col);
        int y = 0;
        while ((y < SIZE)) {
            if ((grid[y][x] != col[y])) {
                moved = true;
            }
            grid[y][x] = col[y];
            y = (y + 1);
        }
        x = (x + 1);
    }
    return MoveResult{.board = Board{.cells = grid}, .score = score, .moved = moved};
}

bool hasMoves(Board b) {
    int y = 0;
    while ((y < SIZE)) {
        int x = 0;
        while ((x < SIZE)) {
            if ((b.cells[y][x] == 0)) {
                return true;
            }
            if ((((x + 1) < SIZE) && (b.cells[y][x] == b.cells[y][(x + 1)]))) {
                return true;
            }
            if ((((y + 1) < SIZE) && (b.cells[y][x] == b.cells[(y + 1)][x]))) {
                return true;
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    return false;
}

bool has2048(Board b) {
    int y = 0;
    while ((y < SIZE)) {
        int x = 0;
        while ((x < SIZE)) {
            if ((b.cells[y][x] >= 2048)) {
                return true;
            }
            x = (x + 1);
        }
        y = (y + 1);
    }
    return false;
}

int main() {
    board = r.board;
    r = spawnTile(board);
    board = r.board;
    full = r.full;
    draw(board, score);
    while (true) {
        std::cout << std::string("Move: ");
        std::cout << std::endl;
        std::string cmd = ([&]{ std::string __line; std::getline(std::cin, __line); return __line; }());
        bool moved = false;
        if (((cmd == std::string("a")) || (cmd == std::string("A")))) {
            MoveResult m = moveLeft(board, score);
            board = m.board;
            score = m.score;
            moved = m.moved;
        }
        if (((cmd == std::string("d")) || (cmd == std::string("D")))) {
            MoveResult m = moveRight(board, score);
            board = m.board;
            score = m.score;
            moved = m.moved;
        }
        if (((cmd == std::string("w")) || (cmd == std::string("W")))) {
            MoveResult m = moveUp(board, score);
            board = m.board;
            score = m.score;
            moved = m.moved;
        }
        if (((cmd == std::string("s")) || (cmd == std::string("S")))) {
            MoveResult m = moveDown(board, score);
            board = m.board;
            score = m.score;
            moved = m.moved;
        }
        if (((cmd == std::string("q")) || (cmd == std::string("Q")))) {
            break;
        }
        if (moved) {
            SpawnResult r2 = spawnTile(board);
            board = r2.board;
            full = r2.full;
            if ((full && !hasMoves(board))) {
                draw(board, score);
                std::cout << std::string("Game Over");
                std::cout << std::endl;
                break;
            }
        }
        draw(board, score);
        if (has2048(board)) {
            std::cout << std::string("You win!");
            std::cout << std::endl;
            break;
        }
        if (!hasMoves(board)) {
            std::cout << std::string("Game Over");
            std::cout << std::endl;
            break;
        }
    }
    return 0;
}
