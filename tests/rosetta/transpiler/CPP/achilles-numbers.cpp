// Generated by Mochi transpiler v0.10.40 on 2025-07-25 19:13:36 GMT+7
#include <iostream>
#include <string>
#include <map>
#include <algorithm>
#include <type_traits>
#include <vector>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <optional>
#include <cstdlib>
#include <chrono>
#include <sys/resource.h>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}
static long _mem() {
    struct rusage usage{};
    getrusage(RUSAGE_SELF, &usage);
#ifdef __APPLE__
    return usage.ru_maxrss;
#else
    return usage.ru_maxrss * 1024;
#endif
}

int pow10(int exp);
int totient(int n);
void getPerfectPowers(int maxExp);
std::map<int, bool> getAchilles(int minExp, int maxExp);
std::vector<int> sortInts(const std::vector<int>& xs);
std::string pad(int n, int width);
int main();

std::map<int, bool> pps = {};

int pow10(int exp) {
    int n = 1;
    int i = 0;
    while ((i < exp)) {
        n = (n * 10);
        i = (i + 1);
    }
    return n;
}

int totient(int n) {
    int tot = n;
    int nn = n;
    int i = 2;
    while (((i * i) <= nn)) {
        if (((nn % i) == 0)) {
            while (((nn % i) == 0)) {
                nn = (nn / i);
            }
            tot = (tot - (tot / i));
        }
        if ((i == 2)) {
            i = 1;
        }
        i = (i + 2);
    }
    if ((nn > 1)) {
        tot = (tot - (tot / nn));
    }
    return tot;
}

void getPerfectPowers(int maxExp) {
    int upper = pow10(maxExp);
    int i = 2;
    while (((i * i) < upper)) {
        int p = i;
        while (true) {
            p = (p * i);
            if ((p >= upper)) {
                break;
            }
            pps[p] = true;
        }
        i = (i + 1);
    }
}

std::map<int, bool> getAchilles(int minExp, int maxExp) {
    int lower = pow10(minExp);
    int upper = pow10(maxExp);
    std::map<int, bool> achilles = {};
    int b = 1;
    while ((((b * b) * b) < upper)) {
        int b3 = ((b * b) * b);
        int a = 1;
        while (true) {
            int p = ((b3 * a) * a);
            if ((p >= upper)) {
                break;
            }
            if ((p >= lower)) {
                if (!([&](const auto& __c, const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__c)>, std::string>) { return __c.find(__v) != std::string::npos; } else if constexpr(requires { __c.find(__v); }) { return __c.find(__v) != __c.end(); } else { return std::find(__c.begin(), __c.end(), __v) != __c.end(); } })(pps, p)) {
                    achilles[p] = true;
                }
            }
            a = (a + 1);
        }
        b = (b + 1);
    }
    return achilles;
}

std::vector<int> sortInts(const std::vector<int>& xs) {
    std::vector<int> res = {};
    std::vector<int> tmp = xs;
    while ((tmp.size() > 0)) {
        int min = tmp[0];
        int idx = 0;
        int i = 1;
        while ((i < tmp.size())) {
            if ((tmp[i] < min)) {
                min = tmp[i];
                idx = i;
            }
            i = (i + 1);
        }
        res = ([&]{ auto __lhs = res; auto __rhs = std::vector<int>{min}; __lhs.insert(__lhs.end(), __rhs.begin(), __rhs.end()); return __lhs; }());
        std::vector<int> out = {};
        int j = 0;
        while ((j < tmp.size())) {
            if ((j != idx)) {
                out = ([&]{ auto __lhs = out; auto __rhs = std::vector<int>{tmp[j]}; __lhs.insert(__lhs.end(), __rhs.begin(), __rhs.end()); return __lhs; }());
            }
            j = (j + 1);
        }
        tmp = out;
    }
    return res;
}

std::string pad(int n, int width) {
    std::string s = ([&]{ std::ostringstream ss; ss << std::boolalpha << n; return ss.str(); }());
    while ((s.size() < width)) {
        s = (std::string(" ") + s);
    }
    return s;
}

int main() {
    {
        auto __bench_start = _now();
        auto __bench_mem_start = _mem();
        int maxDigits = 15;
        getPerfectPowers(5);
        std::map<int, bool> achSet = getAchilles(1, 5);
        std::vector<int> ach = {};
        for (int k : ([&]{ std::vector<std::decay_t<decltype(achSet.begin()->first)>> keys; for(const auto& __p : achSet) keys.push_back(__p.first); return keys; }())) {
            ach = ([&]{ auto __lhs = ach; auto __rhs = std::vector<int>{k}; __lhs.insert(__lhs.end(), __rhs.begin(), __rhs.end()); return __lhs; }());
        }
        ach = sortInts(ach);
        std::cout << std::string("First 50 Achilles numbers:");
        std::cout << std::endl;
        int i = 0;
        while ((i < 50)) {
            std::string line = std::string("");
            int j = 0;
            while ((j < 10)) {
                line = (line + pad(ach[i], 4));
                if ((j < 9)) {
                    line = (line + std::string(" "));
                }
                i = (i + 1);
                j = (j + 1);
            }
            std::cout << line;
            std::cout << std::endl;
        }
        std::cout << std::string("\nFirst 30 strong Achilles numbers:");
        std::cout << std::endl;
        std::vector<int> strong = {};
        int count = 0;
        int idx = 0;
        while ((count < 30)) {
            int tot = totient(ach[idx]);
            if (([&](const auto& __c, const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__c)>, std::string>) { return __c.find(__v) != std::string::npos; } else if constexpr(requires { __c.find(__v); }) { return __c.find(__v) != __c.end(); } else { return std::find(__c.begin(), __c.end(), __v) != __c.end(); } })(achSet, tot)) {
                strong = ([&]{ auto __lhs = strong; auto __rhs = std::vector<int>{ach[idx]}; __lhs.insert(__lhs.end(), __rhs.begin(), __rhs.end()); return __lhs; }());
                count = (count + 1);
            }
            idx = (idx + 1);
        }
        i = 0;
        while ((i < 30)) {
            std::string line = std::string("");
            int j = 0;
            while ((j < 10)) {
                line = (line + pad(strong[i], 5));
                if ((j < 9)) {
                    line = (line + std::string(" "));
                }
                i = (i + 1);
                j = (j + 1);
            }
            std::cout << line;
            std::cout << std::endl;
        }
        std::cout << std::string("\nNumber of Achilles numbers with:");
        std::cout << std::endl;
        std::vector<int> counts = std::vector<int>{1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383};
        int d = 2;
        while ((d <= maxDigits)) {
            int c = counts[(d - 2)];
            std::cout << ((pad(d, 2) + std::string(" digits: ")) + ([&]{ std::ostringstream ss; ss << std::boolalpha << c; return ss.str(); }()));
            std::cout << std::endl;
            d = (d + 1);
        }
        auto __bench_end = _now();
        auto __bench_mem_end = _mem();
        auto __bench_dur = __bench_end - __bench_start;
        auto __bench_mem = __bench_mem_end;
        std::cout << "{\n  \"duration_us\": " << __bench_dur << ",\n  \"memory_bytes\": " << __bench_mem << ",\n  \"name\": \"main\"\n}" << std::endl;
    }
    return 0;
}
