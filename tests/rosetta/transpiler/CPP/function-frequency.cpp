// Generated by Mochi transpiler v0.10.57 on 2025-08-04 22:12:31 GMT+7
#include <iostream>
#include <string>
#include <any>
#include <vector>
#include <map>
#include <algorithm>
#include <type_traits>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <optional>


static void any_to_stream(std::ostream& os, const std::any& val) {
    if(val.type() == typeid(int)) os << std::any_cast<int>(val);
    else if(val.type() == typeid(int64_t)) os << std::any_cast<int64_t>(val);
    else if(val.type() == typeid(double)) os << std::any_cast<double>(val);
    else if(val.type() == typeid(bool)) os << (std::any_cast<bool>(val) ? "true" : "false");
    else if(val.type() == typeid(std::string)) os << std::any_cast<std::string>(val);
    else if(val.type() == typeid(std::vector<int64_t>)) { const auto& v = std::any_cast<const std::vector<int64_t>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::vector<int64_t>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int64_t>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; any_to_stream(os, v[i]); } os << ']'; }
    else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
    else os << "<any>";
}
static double any_to_double(const std::any& v) {
    if(v.type() == typeid(int)) return (double)std::any_cast<int>(v);
    if(v.type() == typeid(double)) return std::any_cast<double>(v);
    return 0;
}
static std::string any_to_string(const std::any& v) {
    if(v.type() == typeid(std::string)) return std::any_cast<std::string>(v);
    if(v.type() == typeid(int)) return std::to_string(std::any_cast<int>(v));
    if(v.type() == typeid(int64_t)) return std::to_string(std::any_cast<int64_t>(v));
    if(v.type() == typeid(double)) { std::ostringstream ss; ss << std::any_cast<double>(v); return ss.str(); }
    if(v.type() == typeid(bool)) return std::any_cast<bool>(v) ? "true" : "false";
    return std::string();
}
template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {
    os << "[";
    for(size_t i=0;i<vec.size();++i){ if(i>0) os << ", "; if constexpr(std::is_same_v<T, std::any>) any_to_stream(os, vec[i]); else os << vec[i]; }
    os << "]";
    return os;
}


template<typename T> std::string _to_string(const T& v) {
    std::ostringstream ss;
    ss << std::boolalpha << v;
    return ss.str();
}

std::string join(const std::vector<std::string>& xs, std::string sep);
std::vector<std::map<std::string, std::any>> sortPairs(const std::vector<std::map<std::string, std::any>>& xs);
bool isAlphaNumDot(std::string ch);
int main();

std::string join(const std::vector<std::string>& xs, std::string sep) {
    std::string res = std::string("");
    int64_t i = int64_t(0);
    while ((i < xs.size())) {
        if ((i > int64_t(0))) {
            res = (res + sep);
        }
        res = (res + xs[i]);
        i = (i + int64_t(1));
    }
    return res;
}

std::vector<std::map<std::string, std::any>> sortPairs(const std::vector<std::map<std::string, std::any>>& xs) {
    std::vector<std::map<std::string, std::any>> arr = xs;
    int64_t i = int64_t(1);
    while ((i < arr.size())) {
        int64_t j = i;
        while (((j > int64_t(0)) && (std::any_cast<int64_t>(([&](const auto& __m){ auto __it = __m.find(std::string("count")); return __it != __m.end() ? __it->second : std::any{}; })(arr[(j - int64_t(1))])) < std::any_cast<int64_t>(([&](const auto& __m){ auto __it = __m.find(std::string("count")); return __it != __m.end() ? __it->second : std::any{}; })(arr[j]))))) {
            std::map<std::string, std::any> tmp = arr[(j - int64_t(1))];
            arr[(j - int64_t(1))] = arr[j];
            arr[j] = tmp;
            j = (j - int64_t(1));
        }
        i = (i + int64_t(1));
    }
    return arr;
}

bool isAlphaNumDot(std::string ch) {
    return ((((((ch >= std::string("A")) && (ch <= std::string("Z"))) || ((ch >= std::string("a")) && (ch <= std::string("z")))) || ((ch >= std::string("0")) && (ch <= std::string("9")))) || (ch == std::string("_"))) || (ch == std::string(".")));
}

int main() {
    std::vector<std::string> srcLines = std::vector<std::string>{std::string("package main"), std::string(""), std::string("import ("), std::string("    \"fmt\""), std::string("    \"go/ast\""), std::string("    \"go/parser\""), std::string("    \"go/token\""), std::string("    \"io/ioutil\""), std::string("    \"os\""), std::string("    \"sort\""), std::string(")"), std::string(""), std::string("func main() {"), std::string("    if len(os.Args) != 2 {"), std::string("        fmt.Println(\"usage ff <go source filename>\")"), std::string("        return"), std::string("    }"), std::string("    src, err := ioutil.ReadFile(os.Args[1])"), std::string("    if err != nil {"), std::string("        fmt.Println(err)"), std::string("        return"), std::string("    }"), std::string("    fs := token.NewFileSet()"), std::string("    a, err := parser.ParseFile(fs, os.Args[1], src, 0)"), std::string("    if err != nil {"), std::string("        fmt.Println(err)"), std::string("        return"), std::string("    }"), std::string("    f := fs.File(a.Pos())"), std::string("    m := make(map[string]int)"), std::string("    ast.Inspect(a, func(n ast.Node) bool {"), std::string("        if ce, ok := n.(*ast.CallExpr); ok {"), std::string("            start := f.Offset(ce.Pos())"), std::string("            end := f.Offset(ce.Lparen)"), std::string("            m[string(src[start:end])]++"), std::string("        }"), std::string("        return true"), std::string("    })"), std::string("    cs := make(calls, 0, len(m))"), std::string("    for k, v := range m {"), std::string("        cs = append(cs, &call{k, v})"), std::string("    }"), std::string("    sort.Sort(cs)"), std::string("    for i, c := range cs {"), std::string("        fmt.Printf(\"%-20s %4d\\n\", c.expr, c.count)"), std::string("        if i == 9 {"), std::string("            break"), std::string("        }"), std::string("    }"), std::string("}"), std::string(""), std::string("type call struct {"), std::string("    expr  string"), std::string("    count int"), std::string("}"), std::string("type calls []*call"), std::string(""), std::string("func (c calls) Len() int           { return len(c) }"), std::string("func (c calls) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }"), std::string("func (c calls) Less(i, j int) bool { return c[i].count > c[j].count }")};
    std::string src = join(srcLines, std::string("\n"));
    std::map<std::string, int64_t> freq = std::map<std::string, int64_t>{};
    int64_t i = int64_t(0);
    std::vector<std::string> order = {};
    while ((i < src.size())) {
        std::string ch = src.substr(i, (i + int64_t(1)) - i);
        if (((((ch >= std::string("A")) && (ch <= std::string("Z"))) || ((ch >= std::string("a")) && (ch <= std::string("z")))) || (ch == std::string("_")))) {
            int64_t j = (i + int64_t(1));
            while (((j < src.size()) && isAlphaNumDot(src.substr(j, (j + int64_t(1)) - j)))) {
                j = (j + int64_t(1));
            }
            std::string token = src.substr(i, j - i);
            int64_t k = j;
            while ((k < src.size())) {
                std::string cc = src.substr(k, (k + int64_t(1)) - k);
                if (((((cc == std::string(" ")) || (cc == std::string("\t"))) || (cc == std::string("\n"))) || (cc == std::string("\r")))) {
                    k = (k + int64_t(1));
                } else {
                    break;
                }
            }
            if (((k < src.size()) && (src.substr(k, (k + int64_t(1)) - k) == std::string("(")))) {
                int64_t p = (i - int64_t(1));
                while (((p >= int64_t(0)) && ((src.substr(p, (p + int64_t(1)) - p) == std::string(" ")) || (src.substr(p, (p + int64_t(1)) - p) == std::string("\t"))))) {
                    p = (p - int64_t(1));
                }
                bool skip = false;
                if ((p >= int64_t(3))) {
                    std::string before = src.substr((p - int64_t(3)), (p + int64_t(1)) - (p - int64_t(3)));
                    if ((before == std::string("func"))) {
                        skip = true;
                    }
                }
                if (!skip) {
                    if (([&](const auto& __c, const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__c)>, std::string>) { return __c.find(__v) != std::string::npos; } else if constexpr(requires { __c.find(__v); }) { return __c.find(__v) != __c.end(); } else { return std::find(__c.begin(), __c.end(), __v) != __c.end(); } })(freq, token)) {
                        freq[token] = (([&](const auto& __m){ auto __it = __m.find(token); return __it != __m.end() ? __it->second : 0; })(freq) + int64_t(1));
                    } else {
                        freq[token] = int64_t(1);
                        order = ([&]{ auto __tmp = order; __tmp.push_back(token); return __tmp; }());
                    }
                }
            }
            i = j;
        } else {
            i = (i + int64_t(1));
        }
    }
    std::vector<std::map<std::string, std::any>> pairs = {};
    for (std::string t : order) {
        pairs = ([&]{ auto __tmp = pairs; __tmp.push_back(std::map<std::string, std::any>{{"expr", std::any(t)}, {"count", std::any(([&](const auto& __m){ auto __it = __m.find(t); return __it != __m.end() ? __it->second : 0; })(freq))}}); return __tmp; }());
    }
    pairs = sortPairs(pairs);
    int64_t idx = int64_t(0);
    while (((idx < pairs.size()) && (idx < int64_t(10)))) {
        std::map<std::string, std::any> p = pairs[idx];
        std::cout << ((([&]{ std::ostringstream ss; any_to_stream(ss, ([&](const auto& __m){ auto __it = __m.find(std::string("expr")); return __it != __m.end() ? __it->second : std::any{}; })(p));
 return ss.str(); }()) + std::string(" ")) + ([&]{ std::ostringstream ss; any_to_stream(ss, ([&](const auto& __m){ auto __it = __m.find(std::string("count")); return __it != __m.end() ? __it->second : std::any{}; })(p));
 return ss.str(); }()));
        std::cout << std::endl;
        idx = (idx + int64_t(1));
    }
    return 0;
}
