// Generated by Mochi transpiler v0.10.40 on 2025-07-25 18:45:12 GMT+7
#include <iostream>
#include <string>
#include <vector>
#include <type_traits>
#include <map>
#include <any>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <optional>
#include <cstdlib>
#include <chrono>
#include <sys/resource.h>


static int _now() {
    static long long seed = 0;
    static bool seeded = false;
    if (!seeded) {
        const char* s = std::getenv("MOCHI_NOW_SEED");
        if (s && *s) { seed = std::atoll(s); seeded = true; }
    }
    if (seeded) {
        seed = (seed * 1664525 + 1013904223) % 2147483647;
        return static_cast<int>(seed);
    }
    return (int)(std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % 2147483647);
}
static long _mem() {
    struct rusage usage{};
    getrusage(RUSAGE_SELF, &usage);
#ifdef __APPLE__
    return usage.ru_maxrss;
#else
    return usage.ru_maxrss * 1024;
#endif
}
static void any_to_stream(std::ostream& os, const std::any& val) {
    if(val.type() == typeid(int)) os << std::any_cast<int>(val);
    else if(val.type() == typeid(double)) os << std::any_cast<double>(val);
    else if(val.type() == typeid(bool)) os << (std::any_cast<bool>(val) ? "true" : "false");
    else if(val.type() == typeid(std::string)) os << std::any_cast<std::string>(val);
    else if(val.type() == typeid(std::vector<int>)) { const auto& v = std::any_cast<const std::vector<int>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::vector<int>>)) { const auto& vv = std::any_cast<const std::vector<std::vector<int>>&>(val); os << '['; for(size_t i=0;i<vv.size();++i){ if(i>0) os << ', '; const auto& v = vv[i]; os << '['; for(size_t j=0;j<v.size();++j){ if(j>0) os << ', '; os << v[j]; } os << ']'; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::string>)) { const auto& v = std::any_cast<const std::vector<std::string>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; os << v[i]; } os << ']'; }
    else if(val.type() == typeid(std::vector<std::any>)) { const auto& v = std::any_cast<const std::vector<std::any>&>(val); os << '['; for(size_t i=0;i<v.size();++i){ if(i>0) os << ', '; any_to_stream(os, v[i]); } os << ']'; }
    else if(val.type() == typeid(std::map<std::string, std::any>)) { const auto& m = std::any_cast<const std::map<std::string, std::any>&>(val); os << '{'; bool first=true; for(const auto& p : m){ if(!first) os << ', '; first=false; os << p.first << ': '; any_to_stream(os, p.second); } os << '}'; }
    else os << "<any>";
}
static double any_to_double(const std::any& v) {
    if(v.type() == typeid(int)) return (double)std::any_cast<int>(v);
    if(v.type() == typeid(double)) return std::any_cast<double>(v);
    return 0;
}

std::vector<std::string> fields(std::string s);
std::string padRight(std::string s, int width);
std::string join(const std::vector<std::string>& xs, std::string sep);
int parseIntStr(std::string str);
bool isDigits(std::string s);
std::map<std::string, std::any> readTable(std::string table);
std::vector<std::string> validate(const std::vector<std::string>& commands, const std::vector<int>& mins, const std::vector<std::string>& words);
int main();

std::vector<std::string> fields(std::string s) {
    std::vector<std::string> words = {};
    std::string cur = std::string("");
    int i = 0;
    while ((i < s.size())) {
        std::string ch = s.substr(i, (i + 1) - i);
        if ((((ch == std::string(" ")) || (ch == std::string("\n"))) || (ch == std::string("\t")))) {
            if ((cur.size() > 0)) {
                words = ([&]{ auto __tmp = words; __tmp.push_back(cur); return __tmp; }());
                cur = std::string("");
            }
        } else {
            cur = (cur + ch);
        }
        i = (i + 1);
    }
    if ((cur.size() > 0)) {
        words = ([&]{ auto __tmp = words; __tmp.push_back(cur); return __tmp; }());
    }
    return words;
}

std::string padRight(std::string s, int width) {
    std::string out = s;
    int i = s.size();
    while ((i < width)) {
        out = (out + std::string(" "));
        i = (i + 1);
    }
    return out;
}

std::string join(const std::vector<std::string>& xs, std::string sep) {
    std::string res = std::string("");
    int i = 0;
    while ((i < xs.size())) {
        if ((i > 0)) {
            res = (res + sep);
        }
        res = (res + xs[i]);
        i = (i + 1);
    }
    return res;
}

int parseIntStr(std::string str) {
    int i = 0;
    bool neg = false;
    if (((str.size() > 0) && (([&](const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__v)>, std::string>) return __v.substr(0, 1 - 0); else return std::vector<typename std::decay_t<decltype(__v)>::value_type>(__v.begin()+0, __v.begin()+1); })(str) == std::string("-")))) {
        neg = true;
        i = 1;
    }
    int n = 0;
    std::map<std::string, int> digits = std::map<std::string, int>{{"0", 0}, {"1", 1}, {"2", 2}, {"3", 3}, {"4", 4}, {"5", 5}, {"6", 6}, {"7", 7}, {"8", 8}, {"9", 9}};
    while ((i < str.size())) {
        n = ((n * 10) + digits[([&](const auto& __v){ if constexpr(std::is_same_v<std::decay_t<decltype(__v)>, std::string>) return __v.substr(i, (i + 1) - i); else return std::vector<typename std::decay_t<decltype(__v)>::value_type>(__v.begin()+i, __v.begin()+(i + 1)); })(str)]);
        i = (i + 1);
    }
    if (neg) {
        n = -n;
    }
    return n;
}

bool isDigits(std::string s) {
    if ((s.size() == 0)) {
        return false;
    }
    int i = 0;
    while ((i < s.size())) {
        std::string ch = s.substr(i, (i + 1) - i);
        if (((ch < std::string("0")) || (ch > std::string("9")))) {
            return false;
        }
        i = (i + 1);
    }
    return true;
}

std::map<std::string, std::any> readTable(std::string table) {
    std::vector<std::string> toks = fields(table);
    std::vector<std::string> cmds = {};
    std::vector<int> mins = {};
    int i = 0;
    while ((i < toks.size())) {
        std::string cmd = toks[i];
        int minlen = cmd.size();
        i = (i + 1);
        if (((i < toks.size()) && isDigits(toks[i]))) {
            int num = parseIntStr(toks[i]);
            if (((num >= 1) && (num < cmd.size()))) {
                minlen = num;
                i = (i + 1);
            }
        }
        cmds = ([&]{ auto __tmp = cmds; __tmp.push_back(cmd); return __tmp; }());
        mins = ([&]{ auto __tmp = mins; __tmp.push_back(minlen); return __tmp; }());
    }
    return std::map<std::string, std::any>{{"commands", std::any(cmds)}, {"mins", std::any(mins)}};
}

std::vector<std::string> validate(const std::vector<std::string>& commands, const std::vector<int>& mins, const std::vector<std::string>& words) {
    std::vector<std::string> results = {};
    int wi = 0;
    while ((wi < words.size())) {
        std::string w = words[wi];
        bool found = false;
        int wlen = w.size();
        int ci = 0;
        while ((ci < commands.size())) {
            std::string cmd = commands[ci];
            if ((((mins[ci] != 0) && (wlen >= mins[ci])) && (wlen <= cmd.size()))) {
                std::string c = ([&]{ std::string __s = cmd; for(auto &__c : __s){ __c = std::toupper(static_cast<unsigned char>(__c)); } return __s; }());
                std::string ww = ([&]{ std::string __s = w; for(auto &__c : __s){ __c = std::toupper(static_cast<unsigned char>(__c)); } return __s; }());
                if ((c.substr(0, wlen - 0) == ww)) {
                    results = ([&]{ auto __tmp = results; __tmp.push_back(c); return __tmp; }());
                    found = true;
                    break;
                }
            }
            ci = (ci + 1);
        }
        if (!found) {
            results = ([&]{ auto __tmp = results; __tmp.push_back(std::string("*error*")); return __tmp; }());
        }
        wi = (wi + 1);
    }
    return results;
}

int main() {
    {
        auto __bench_start = _now();
        auto __bench_mem_start = _mem();
        std::string table = ((((((((std::string("") + std::string("add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ")) + std::string("compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ")) + std::string("3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ")) + std::string("forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ")) + std::string("locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ")) + std::string("msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ")) + std::string("refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ")) + std::string("2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 "));
        std::string sentence = std::string("riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin");
        std::map<std::string, std::any> tbl = readTable(table);
        std::vector<std::string> commands = std::any_cast<std::vector<std::string>>(tbl[std::string("commands")]);
        std::vector<int> mins = std::any_cast<std::vector<int>>(tbl[std::string("mins")]);
        std::vector<std::string> words = fields(sentence);
        std::vector<std::string> results = validate(commands, mins, words);
        std::string out1 = std::string("user words:");
        int k = 0;
        while ((k < words.size())) {
            out1 = (out1 + std::string(" "));
            if ((k < (words.size() - 1))) {
                out1 = (out1 + padRight(words[k], results[k].size()));
            } else {
                out1 = (out1 + words[k]);
            }
            k = (k + 1);
        }
        std::cout << out1;
        std::cout << std::endl;
        std::cout << (std::string("full words: ") + join(results, std::string(" ")));
        std::cout << std::endl;
        auto __bench_end = _now();
        auto __bench_mem_end = _mem();
        auto __bench_dur = __bench_end - __bench_start;
        auto __bench_mem = __bench_mem_end;
        std::cout << "{\n  \"duration_us\": " << __bench_dur << ",\n  \"memory_bytes\": " << __bench_mem << ",\n  \"name\": \"main\"\n}" << std::endl;
    }
    return 0;
}
