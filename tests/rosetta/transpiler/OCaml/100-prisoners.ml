(* Generated by Mochi transpiler v0.10.37 on 2025-07-22 21:01 +0700 *)


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)

exception Break
exception Continue

let rec shuffle xs =
  let arr = ref xs in
  let i = ref 99 in
  (try while (!i > 0) do
    try
  let j = (_now () mod (!i + 1)) in
  let tmp = List.nth (!arr) !i in
  arr := (List.mapi (fun __i __x -> if __i = !i then List.nth (!arr) j else __x) (!arr));
  arr := (List.mapi (fun __i __x -> if __i = j then tmp else __x) (!arr));
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  !arr

let rec doTrials trials np strategy =
  let pardoned = ref 0 in
  let t = ref 0 in
  (try while (!t < trials) do
    try
  let drawers = ref [] in
  let i = ref 0 in
  (try while (!i < 100) do
    try
  drawers := List.append !drawers [!i];
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  drawers := shuffle (!drawers);
  let p = ref 0 in
  let success = ref true in
  (try while (!p < np) do
    try
  let found = ref false in
  if (strategy == "optimal") then (
  let prev = ref !p in
  let d = ref 0 in
  (try while (!d < 50) do
    try
  let this = List.nth (!drawers) !prev in
  if (this == !p) then (
  found := true;
  raise Break;
  );
  prev := this;
  d := (!d + 1);
    with Continue -> ()
  done with Break -> ());
  ) else (
  let opened = ref [] in
  let k = ref 0 in
  (try while (!k < 100) do
    try
  opened := List.append !opened [false];
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  let d = ref 0 in
  (try while (!d < 50) do
    try
  let n = ref (_now () mod 100) in
  (try while List.nth (!opened) !n do
    try
  n := (_now () mod 100);
    with Continue -> ()
  done with Break -> ());
  opened := (List.mapi (fun __i __x -> if __i = !n then true else __x) (!opened));
  if (List.nth (!drawers) !n == !p) then (
  found := true;
  raise Break;
  );
  d := (!d + 1);
    with Continue -> ()
  done with Break -> ());
  );
  if not (!found) then (
  success := false;
  raise Break;
  );
  p := (!p + 1);
    with Continue -> ()
  done with Break -> ());
  if !success then (
  pardoned := (!pardoned + 1);
  );
  t := (!t + 1);
    with Continue -> ()
  done with Break -> ());
  let rf = (float_of_int ((!pardoned / trials)) *. 100.0) in
  print_endline (((((("  strategy = " ^ strategy) ^ "  pardoned = ") ^ string_of_int !pardoned) ^ " relative frequency = ") ^ string_of_float rf) ^ "%");
  ()

let rec main () =
  let trials = 1000 in
  (try List.iter (fun np ->
    try
  print_endline (((("Results from " ^ string_of_int trials) ^ " trials with ") ^ string_of_int np) ^ " prisoners:\n");
  (try List.iter (fun strat ->
    try
  doTrials (trials) (np) (strat)
    with Continue -> ()) ["random"; "optimal"] with Break -> ());
    with Continue -> ()) [10; 100] with Break -> ());
  ()

let () =
  main ()
