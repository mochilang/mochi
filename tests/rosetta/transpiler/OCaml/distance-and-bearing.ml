(* Generated by Mochi transpiler v0.10.55 on 2025-08-02 18:27 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let _pi = 3.141592653589793
let rec sinApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let term = ref (x) in
  let sum = ref (x) in
  let n = ref (1) in
  (try while (!n <= 8) do
    try
  let denom = float_of_int (((2 * !n) * ((2 * !n) + 1))) in
  term := ((((-.(!term)) *. x) *. x) /. denom);
  sum := (!sum +. !term);
  n := (!n + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : float); raise Return
  with Return -> !__ret)

and cosApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let term = ref (1.0) in
  let sum = ref (1.0) in
  let n = ref (1) in
  (try while (!n <= 8) do
    try
  let denom = float_of_int ((((2 * !n) - 1) * (2 * !n))) in
  term := ((((-.(!term)) *. x) *. x) /. denom);
  sum := (!sum +. !term);
  n := (!n + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!sum) : float); raise Return
  with Return -> !__ret)

and atanApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  if (x > 1.0) then (
  __ret := (Obj.magic (((_pi /. 2.0) -. (x /. ((x *. x) +. 0.28)))) : float); raise Return
  );
  if (x < (-.(1.0))) then (
  __ret := (Obj.magic ((((-.(_pi)) /. 2.0) -. (x /. ((x *. x) +. 0.28)))) : float); raise Return
  );
  __ret := (Obj.magic ((x /. (1.0 +. ((0.28 *. x) *. x)))) : float); raise Return
  with Return -> !__ret)

and atan2Approx y x =
  let __ret = ref 0.0 in
  (try
  let y = (Obj.magic y : float) in
  let x = (Obj.magic x : float) in
  if (x > 0.0) then (
  let r = atanApprox (Obj.repr ((y /. x))) in
  __ret := (Obj.magic (r) : float); raise Return
  );
  if (x < 0.0) then (
  if (y >= 0.0) then (
  __ret := (Obj.magic ((atanApprox (Obj.repr ((y /. x))) +. _pi)) : float); raise Return
  );
  __ret := (Obj.magic ((atanApprox (Obj.repr ((y /. x))) -. _pi)) : float); raise Return
  );
  if (y > 0.0) then (
  __ret := (Obj.magic ((_pi /. 2.0)) : float); raise Return
  );
  if (y < 0.0) then (
  __ret := (Obj.magic (((-.(_pi)) /. 2.0)) : float); raise Return
  );
  __ret := (Obj.magic (0.0) : float); raise Return
  with Return -> !__ret)

and sqrtApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let guess = ref (x) in
  let i = ref (0) in
  (try while (!i < 10) do
    try
  guess := ((!guess +. (x /. !guess)) /. 2.0);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!guess) : float); raise Return
  with Return -> !__ret)

and rad x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  __ret := (Obj.magic (((x *. _pi) /. 180.0)) : float); raise Return
  with Return -> !__ret)

and deg x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  __ret := (Obj.magic (((x *. 180.0) /. _pi)) : float); raise Return
  with Return -> !__ret)

and distance lat1 lon1 lat2 lon2 =
  let __ret = ref 0.0 in
  (try
  let lat1 = (Obj.magic lat1 : float) in
  let lon1 = (Obj.magic lon1 : float) in
  let lat2 = (Obj.magic lat2 : float) in
  let lon2 = (Obj.magic lon2 : float) in
  let phi1 = rad (Obj.repr (lat1)) in
  let phi2 = rad (Obj.repr (lat2)) in
  let dphi = rad (Obj.repr ((lat2 -. lat1))) in
  let dlambda = rad (Obj.repr ((lon2 -. lon1))) in
  let sdphi = sinApprox (Obj.repr ((dphi /. float_of_int (2)))) in
  let sdlambda = sinApprox (Obj.repr ((dlambda /. float_of_int (2)))) in
  let a = ((sdphi *. sdphi) +. (((cosApprox (Obj.repr (phi1)) *. cosApprox (Obj.repr (phi2))) *. sdlambda) *. sdlambda)) in
  let c = (float_of_int (2) *. atan2Approx (Obj.repr (sqrtApprox (Obj.repr (a)))) (Obj.repr (sqrtApprox (Obj.repr ((float_of_int (1) -. a)))))) in
  __ret := (Obj.magic (((6371.0 /. 1.852) *. c)) : float); raise Return
  with Return -> !__ret)

and bearing lat1 lon1 lat2 lon2 =
  let __ret = ref 0.0 in
  (try
  let lat1 = (Obj.magic lat1 : float) in
  let lon1 = (Obj.magic lon1 : float) in
  let lat2 = (Obj.magic lat2 : float) in
  let lon2 = (Obj.magic lon2 : float) in
  let phi1 = rad (Obj.repr (lat1)) in
  let phi2 = rad (Obj.repr (lat2)) in
  let dl = rad (Obj.repr ((lon2 -. lon1))) in
  let y = (sinApprox (Obj.repr (dl)) *. cosApprox (Obj.repr (phi2))) in
  let x = ((cosApprox (Obj.repr (phi1)) *. sinApprox (Obj.repr (phi2))) -. ((sinApprox (Obj.repr (phi1)) *. cosApprox (Obj.repr (phi2))) *. cosApprox (Obj.repr (dl)))) in
  let br = ref (deg (Obj.repr (atan2Approx (Obj.repr (y)) (Obj.repr (x))))) in
  if (!br < float_of_int (0)) then (
  br := (!br +. float_of_int (360));
  );
  __ret := (Obj.magic (!br) : float); raise Return
  with Return -> !__ret)


let airports = ref ([[("name", Obj.repr ("Koksijde Air Base")); ("country", Obj.repr ("Belgium")); ("icao", Obj.repr ("EBFN")); ("lat", Obj.repr (51.090301513671875)); ("lon", Obj.repr (2.652780055999756))]; [("name", Obj.repr ("Ostend-Bruges International Airport")); ("country", Obj.repr ("Belgium")); ("icao", Obj.repr ("EBOS")); ("lat", Obj.repr (51.198898315399994)); ("lon", Obj.repr (2.8622200489))]; [("name", Obj.repr ("Kent International Airport")); ("country", Obj.repr ("United Kingdom")); ("icao", Obj.repr ("EGMH")); ("lat", Obj.repr (51.342201)); ("lon", Obj.repr (1.34611))]; [("name", Obj.repr ("Calais-Dunkerque Airport")); ("country", Obj.repr ("France")); ("icao", Obj.repr ("LFAC")); ("lat", Obj.repr (50.962100982666016)); ("lon", Obj.repr (1.954759955406189))]; [("name", Obj.repr ("Westkapelle heliport")); ("country", Obj.repr ("Belgium")); ("icao", Obj.repr ("EBKW")); ("lat", Obj.repr (51.32222366333)); ("lon", Obj.repr (3.2930560112))]; [("name", Obj.repr ("Lympne Airport")); ("country", Obj.repr ("United Kingdom")); ("icao", Obj.repr ("EGMK")); ("lat", Obj.repr (51.08)); ("lon", Obj.repr (1.013))]; [("name", Obj.repr ("Ursel Air Base")); ("country", Obj.repr ("Belgium")); ("icao", Obj.repr ("EBUL")); ("lat", Obj.repr (51.14419937133789)); ("lon", Obj.repr (3.475559949874878))]; [("name", Obj.repr ("Southend Airport")); ("country", Obj.repr ("United Kingdom")); ("icao", Obj.repr ("EGMC")); ("lat", Obj.repr (51.5713996887207)); ("lon", Obj.repr (0.6955559849739075))]; [("name", Obj.repr ("Merville-Calonne Airport")); ("country", Obj.repr ("France")); ("icao", Obj.repr ("LFQT")); ("lat", Obj.repr (50.61840057373047)); ("lon", Obj.repr (2.642240047454834))]; [("name", Obj.repr ("Wevelgem Airport")); ("country", Obj.repr ("Belgium")); ("icao", Obj.repr ("EBKT")); ("lat", Obj.repr (50.817199707)); ("lon", Obj.repr (3.20472002029))]; [("name", Obj.repr ("Midden-Zeeland Airport")); ("country", Obj.repr ("Netherlands")); ("icao", Obj.repr ("EHMZ")); ("lat", Obj.repr (51.5121994019)); ("lon", Obj.repr (3.73111009598))]; [("name", Obj.repr ("Lydd Airport")); ("country", Obj.repr ("United Kingdom")); ("icao", Obj.repr ("EGMD")); ("lat", Obj.repr (50.95610046386719)); ("lon", Obj.repr (0.9391670227050781))]; [("name", Obj.repr ("RAF Wattisham")); ("country", Obj.repr ("United Kingdom")); ("icao", Obj.repr ("EGUW")); ("lat", Obj.repr (52.1273002625)); ("lon", Obj.repr (0.956264019012))]; [("name", Obj.repr ("Beccles Airport")); ("country", Obj.repr ("United Kingdom")); ("icao", Obj.repr ("EGSM")); ("lat", Obj.repr (52.435298919699996)); ("lon", Obj.repr (1.6183300018300002))]; [("name", Obj.repr ("Lille/Marcq-en-Baroeul Airport")); ("country", Obj.repr ("France")); ("icao", Obj.repr ("LFQO")); ("lat", Obj.repr (50.687198638916016)); ("lon", Obj.repr (3.0755600929260254))]; [("name", Obj.repr ("Lashenden (Headcorn) Airfield")); ("country", Obj.repr ("United Kingdom")); ("icao", Obj.repr ("EGKH")); ("lat", Obj.repr (51.156898)); ("lon", Obj.repr (0.641667))]; [("name", Obj.repr ("Le Touquet-CÃ´te d'Opale Airport")); ("country", Obj.repr ("France")); ("icao", Obj.repr ("LFAT")); ("lat", Obj.repr (50.517398834228516)); ("lon", Obj.repr (1.6205899715423584))]; [("name", Obj.repr ("Rochester Airport")); ("country", Obj.repr ("United Kingdom")); ("icao", Obj.repr ("EGTO")); ("lat", Obj.repr (51.351898193359375)); ("lon", Obj.repr (0.5033329725265503))]; [("name", Obj.repr ("Lille-Lesquin Airport")); ("country", Obj.repr ("France")); ("icao", Obj.repr ("LFQQ")); ("lat", Obj.repr (50.563332)); ("lon", Obj.repr (3.086886))]; [("name", Obj.repr ("Thurrock Airfield")); ("country", Obj.repr ("United Kingdom")); ("icao", Obj.repr ("EGMT")); ("lat", Obj.repr (51.537505)); ("lon", Obj.repr (0.367634))]])
let rec floor x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let i = ref ((Obj.magic x : int)) in
  if (float_of_int (!i) > x) then (
  i := (!i - 1);
  );
  __ret := (Obj.magic (float_of_int (!i)) : float); raise Return
  with Return -> !__ret)

and pow10 n =
  let __ret = ref 0.0 in
  (try
  let n = (Obj.magic n : int) in
  let p = ref (1.0) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  p := (!p *. 10.0);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!p) : float); raise Return
  with Return -> !__ret)

and round x n =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let n = (Obj.magic n : int) in
  let m = pow10 (Obj.repr (n)) in
  __ret := (Obj.magic ((floor (Obj.repr (((x *. m) +. 0.5))) /. m)) : float); raise Return
  with Return -> !__ret)

and sortByDistance xs =
  let __ret = ref ([] : Obj.t list list) in
  (try
  let arr = ref (xs) in
  let i = ref (1) in
  (try while (!i < List.length (!arr)) do
    try
  let j = ref (!i) in
  (try while ((!j > 0) && (List.nth (List.nth (!arr) ((!j - 1))) (0) > List.nth (List.nth (!arr) (!j)) (0))) do
    try
  let tmp = List.nth (!arr) ((!j - 1)) in
  arr := (List.mapi (fun __i __x -> if __i = (!j - 1) then List.nth (!arr) (!j) else __x) (!arr));
  arr := (List.mapi (fun __i __x -> if __i = !j then tmp else __x) (!arr));
  j := (!j - 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!arr) : Obj.t list list); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let planeLat = 51.514669 in
  let planeLon = 2.198581 in
  let results = ref (([] : Obj.t list list)) in
  (try List.iter (fun ap ->
    try
  let d = distance (Obj.repr (planeLat)) (Obj.repr (planeLon)) (Obj.repr ((Obj.obj (List.assoc ("lat") ap) : float))) (Obj.repr ((Obj.obj (List.assoc ("lon") ap) : float))) in
  let b = bearing (Obj.repr (planeLat)) (Obj.repr (planeLon)) (Obj.repr ((Obj.obj (List.assoc ("lat") ap) : float))) (Obj.repr ((Obj.obj (List.assoc ("lon") ap) : float))) in
  results := (List.append (!results) [(Obj.magic ([Obj.repr (d); Obj.repr (b); Obj.repr (ap)]) : Obj.t list)]);
    with Continue -> ()) (!airports) with Break -> ());
  results := sortByDistance (!results);
  print_endline ("Distance Bearing ICAO Country               Airport");
  print_endline ("--------------------------------------------------------------");
  let i = ref (0) in
  (try while (!i < List.length (!results)) do
    try
  let r = ref (List.nth (!results) (!i)) in
  let ap = List.nth (!r) (2) in
  let dist = List.nth (!r) (0) in
  let bear = List.nth (!r) (1) in
  let line = (((((((((Printf.sprintf "%.16g" (round (Obj.repr (dist)) (Obj.repr (1)))) ^ "\t") ^ (Printf.sprintf "%.16g" (round (Obj.repr (bear)) (Obj.repr (0))))) ^ "\t") ^ __show ((try List.assoc ("icao") ap with Not_found -> 0))) ^ "\t") ^ __show ((try List.assoc ("country") ap with Not_found -> 0))) ^ " ") ^ __show ((try List.assoc ("name") ap with Not_found -> 0))) in
  print_endline (__show line);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()