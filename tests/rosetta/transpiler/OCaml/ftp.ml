(* Generated by Mochi transpiler v0.10.57 on 2025-08-04 16:58 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0

exception Break
exception Continue

exception Return

let serverData = ref ([("pub", [("somefile.bin", "This is a file from the FTP server."); ("readme.txt", "Hello from ftp.")])])
let serverNames = ref ([("pub", ["somefile.bin"; "readme.txt"])])
let rec connect hostport =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  print_endline (("Connected to " ^ hostport));
  __ret := (Obj.magic ([("dir", Obj.repr ("/"))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and login conn user pass =
  let __ret = ref (Obj.magic 0) in
  (try
  print_endline (("Logged in as " ^ user));
    !__ret
  with Return -> !__ret)

and changeDir conn dir =
  let __ret = ref (Obj.magic 0) in
  (try
  conn := (("dir", Obj.repr (dir)) :: List.remove_assoc ("dir") (Obj.magic (!conn) : (string * Obj.t) list));
    !__ret
  with Return -> !__ret)

and list conn =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let names = ref (List.assoc ((Obj.obj (List.assoc ("dir") (conn) : Obj.t) : string)) (!serverNames)) in
  let dataDir = ref (List.assoc ((Obj.obj (List.assoc ("dir") (conn) : Obj.t) : string)) (!serverData)) in
  let out = ref (([] : ((string * Obj.t) list) list)) in
  (try List.iter (fun (name, _) ->
    try
  let content = ref ((Obj.obj (List.assoc (name) (!dataDir) : Obj.t) : ( string * (string * Obj.t) list ) list)) in
  out := (List.append (!out) [(Obj.magic ([("name", Obj.repr (name)); ("size", Obj.repr (List.length (!content))); ("kind", Obj.repr ("file"))]) : (string * Obj.t) list)]);
    with Continue -> ()) (!names) with Break -> ());
  __ret := (Obj.magic (!out) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and retrieve conn name =
  let __ret = ref "" in
  (try
  __ret := (Obj.magic ((Obj.obj (List.assoc (name) (List.assoc ((Obj.obj (List.assoc ("dir") (conn) : Obj.t) : string)) (!serverData)) : Obj.t) : ( string * (string * Obj.t) list ) list)) : string); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let conn = connect ("localhost:21") in
  ignore (login (conn) ("anonymous") ("anonymous"));
  ignore (changeDir (ref (conn)) ("pub"));
  print_endline (__show (Obj.obj (List.assoc ("dir") (conn) : Obj.t) : string));
  let files = ref (list (conn)) in
  (try List.iter (fun f ->
    try
  print_endline ((((Obj.obj (List.assoc ("name") (f) : Obj.t) : string) ^ " ") ^ (string_of_int ((Obj.obj (List.assoc ("size") (f) : Obj.t) : int)))));
    with Continue -> ()) (!files) with Break -> ());
  let data = retrieve (conn) ("somefile.bin") in
  print_endline ((("Wrote " ^ (string_of_int (String.length (data)))) ^ " bytes to somefile.bin"));
    !__ret
  with Return -> !__ret)


let () =
  ignore (main ());
  ()