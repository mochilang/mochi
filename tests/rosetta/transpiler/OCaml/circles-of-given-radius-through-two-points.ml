(* Generated by Mochi transpiler v0.10.52 on 2025-08-01 22:42 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let _two = "Two circles."
let _r0 = "R==0.0 does not describe circles."
let _co = "Coincident points describe an infinite number of circles."
let _cor0 = "Coincident points with r==0.0 describe a degenerate circle."
let _diam = "Points form a diameter and describe only a single circle."
let _far = "Points too far apart to form circles."
let td = ref ([[Obj.repr ([("x", Obj.repr (0.1234)); ("y", Obj.repr (0.9876))]); Obj.repr ([("x", Obj.repr (0.8765)); ("y", Obj.repr (0.2345))]); Obj.repr (2.0)]; [Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (2.0))]); Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0))]); Obj.repr (1.0)]; [Obj.repr ([("x", Obj.repr (0.1234)); ("y", Obj.repr (0.9876))]); Obj.repr ([("x", Obj.repr (0.1234)); ("y", Obj.repr (0.9876))]); Obj.repr (2.0)]; [Obj.repr ([("x", Obj.repr (0.1234)); ("y", Obj.repr (0.9876))]); Obj.repr ([("x", Obj.repr (0.8765)); ("y", Obj.repr (0.2345))]); Obj.repr (0.5)]; [Obj.repr ([("x", Obj.repr (0.1234)); ("y", Obj.repr (0.9876))]); Obj.repr ([("x", Obj.repr (0.1234)); ("y", Obj.repr (0.9876))]); Obj.repr (0.0)]])
let rec sqrtApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let g = ref (x) in
  let i = ref (0) in
  (try while (!i < 40) do
    try
  g := ((!g +. (x /. !g)) /. 2.0);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!g) : float); raise Return
  with Return -> !__ret)

and hypot x y =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  let y = (Obj.magic y : float) in
  __ret := (Obj.magic (sqrtApprox (Obj.repr (((x *. x) +. (y *. y))))) : float); raise Return
  with Return -> !__ret)

and circles p1 p2 r =
  let __ret = ref [] in
  (try
  let r = (Obj.magic r : float) in
  if (((Obj.obj (List.assoc ("x") p1) : float) = (Obj.obj (List.assoc ("x") p2) : float)) && ((Obj.obj (List.assoc ("y") p1) : float) = (Obj.obj (List.assoc ("y") p2) : float))) then (
  if (r = 0.0) then (
  __ret := (Obj.magic ([Obj.repr (p1); Obj.repr (p1); Obj.repr ("Coincident points with r==0.0 describe a degenerate circle.")]) : Obj.t list); raise Return
  );
  __ret := (Obj.magic ([Obj.repr (p1); Obj.repr (p2); Obj.repr ("Coincident points describe an infinite number of circles.")]) : Obj.t list); raise Return
  );
  if (r = 0.0) then (
  __ret := (Obj.magic ([Obj.repr (p1); Obj.repr (p2); Obj.repr ("R==0.0 does not describe circles.")]) : Obj.t list); raise Return
  );
  let dx = ((Obj.obj (List.assoc ("x") p2) : float) -. (Obj.obj (List.assoc ("x") p1) : float)) in
  let dy = ((Obj.obj (List.assoc ("y") p2) : float) -. (Obj.obj (List.assoc ("y") p1) : float)) in
  let q = hypot (Obj.repr (dx)) (Obj.repr (dy)) in
  if (q > (2.0 *. r)) then (
  __ret := (Obj.magic ([Obj.repr (p1); Obj.repr (p2); Obj.repr ("Points too far apart to form circles.")]) : Obj.t list); raise Return
  );
  let m = [("x", Obj.repr ((((Obj.obj (List.assoc ("x") p1) : float) +. (Obj.obj (List.assoc ("x") p2) : float)) /. 2.0))); ("y", Obj.repr ((((Obj.obj (List.assoc ("y") p1) : float) +. (Obj.obj (List.assoc ("y") p2) : float)) /. 2.0)))] in
  if (q = (2.0 *. r)) then (
  __ret := (Obj.magic ([Obj.repr (m); Obj.repr (m); Obj.repr ("Points form a diameter and describe only a single circle.")]) : Obj.t list); raise Return
  );
  let d = sqrtApprox (Obj.repr (((r *. r) -. ((q *. q) /. 4.0)))) in
  let ox = ((d *. dx) /. q) in
  let oy = ((d *. dy) /. q) in
  __ret := (Obj.magic ([Obj.repr ([("x", Obj.repr (((Obj.obj (List.assoc ("x") m) : float) -. oy))); ("y", Obj.repr (((Obj.obj (List.assoc ("y") m) : float) +. ox)))]); Obj.repr ([("x", Obj.repr (((Obj.obj (List.assoc ("x") m) : float) +. oy))); ("y", Obj.repr (((Obj.obj (List.assoc ("y") m) : float) -. ox)))]); Obj.repr ("Two circles.")]) : Obj.t list); raise Return
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  (try List.iter (fun tc ->
    try
  let p1 = List.nth (tc) (0) in
  let p2 = List.nth (tc) (1) in
  let r = List.nth (tc) (2) in
  print_endline ((((("p1:  {" ^ (Printf.sprintf "%.16g" ((Obj.obj (List.assoc ("x") p1) : float)))) ^ " ") ^ (Printf.sprintf "%.16g" ((Obj.obj (List.assoc ("y") p1) : float)))) ^ "}"));
  print_endline ((((("p2:  {" ^ (Printf.sprintf "%.16g" ((Obj.obj (List.assoc ("x") p2) : float)))) ^ " ") ^ (Printf.sprintf "%.16g" ((Obj.obj (List.assoc ("y") p2) : float)))) ^ "}"));
  print_endline (("r:  " ^ __show (r)));
  let res = ref (circles (p1) (p2) (Obj.repr (r))) in
  let c1 = List.nth (!res) (0) in
  let c2 = List.nth (!res) (1) in
  let caseStr = List.nth (!res) (2) in
  print_endline (("   " ^ __show (caseStr)));
  if ((caseStr = "Points form a diameter and describe only a single circle.") || (caseStr = "Coincident points with r==0.0 describe a degenerate circle.")) then (
  print_endline ((((("   Center:  {" ^ (string_of_int ((try List.assoc ("x") c1 with Not_found -> (Obj.magic 0))))) ^ " ") ^ (string_of_int ((try List.assoc ("y") c1 with Not_found -> (Obj.magic 0))))) ^ "}"));
  ) else (
  if (caseStr = "Two circles.") then (
  print_endline ((((("   Center 1:  {" ^ (string_of_int ((try List.assoc ("x") c1 with Not_found -> (Obj.magic 0))))) ^ " ") ^ (string_of_int ((try List.assoc ("y") c1 with Not_found -> (Obj.magic 0))))) ^ "}"));
  print_endline ((((("   Center 2:  {" ^ (string_of_int ((try List.assoc ("x") c2 with Not_found -> (Obj.magic 0))))) ^ " ") ^ (string_of_int ((try List.assoc ("y") c2 with Not_found -> (Obj.magic 0))))) ^ "}"));
  );
  );
  print_endline ("");
    with Continue -> ()) (!td) with Break -> ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()