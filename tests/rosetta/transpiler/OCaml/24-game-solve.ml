(* Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:42 +0700 *)


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)

exception Break
exception Continue

exception Return

let op_num = 0
let op_add = 1
let op_sub = 2
let op_mul = 3
let op_div = 4
let rec newNum n =
  let __ret = ref [] in
  let n = ref n in
  (try
  __ret := [("op", Obj.repr op_num); ("value", Obj.repr [("num", !n); ("denom", 1)])]; raise Return;
  __ret := [("op", Obj.repr op_num); ("value", Obj.repr [("num", !n); ("denom", 1)])];
    !__ret
  with Return -> !__ret)

let rec exprEval x =
  let __ret = ref [] in
  let x = ref x in
  (try
  if ((Obj.obj (List.assoc ("op") !x) : int) = op_num) then (
  __ret := (Obj.obj (List.assoc ("value") !x) : (string * int) list); raise Return;
  );
  let l = exprEval ((Obj.obj (List.assoc ("left") !x) : (string * Obj.t) list)) in
  let r = exprEval ((Obj.obj (List.assoc ("right") !x) : (string * Obj.t) list)) in
  if ((Obj.obj (List.assoc ("op") !x) : int) = op_add) then (
  __ret := [("num", (((List.assoc ("num") l) * (List.assoc ("denom") r)) + ((List.assoc ("denom") l) * (List.assoc ("num") r)))); ("denom", ((List.assoc ("denom") l) * (List.assoc ("denom") r)))]; raise Return;
  );
  if ((Obj.obj (List.assoc ("op") !x) : int) = op_sub) then (
  __ret := [("num", (((List.assoc ("num") l) * (List.assoc ("denom") r)) - ((List.assoc ("denom") l) * (List.assoc ("num") r)))); ("denom", ((List.assoc ("denom") l) * (List.assoc ("denom") r)))]; raise Return;
  );
  if ((Obj.obj (List.assoc ("op") !x) : int) = op_mul) then (
  __ret := [("num", ((List.assoc ("num") l) * (List.assoc ("num") r))); ("denom", ((List.assoc ("denom") l) * (List.assoc ("denom") r)))]; raise Return;
  );
  __ret := [("num", ((List.assoc ("num") l) * (List.assoc ("denom") r))); ("denom", ((List.assoc ("denom") l) * (List.assoc ("num") r)))]; raise Return;
  __ret := [("num", ((List.assoc ("num") l) * (List.assoc ("denom") r))); ("denom", ((List.assoc ("denom") l) * (List.assoc ("num") r)))];
    !__ret
  with Return -> !__ret)

let rec exprString x =
  let __ret = ref "" in
  let x = ref x in
  (try
  if ((Obj.obj (List.assoc ("op") !x) : int) = op_num) then (
  __ret := (string_of_int (List.assoc ("num") (Obj.obj (List.assoc ("value") !x) : (string * int) list))); raise Return;
  );
  let ls = exprString ((Obj.obj (List.assoc ("left") !x) : (string * Obj.t) list)) in
  let rs = exprString ((Obj.obj (List.assoc ("right") !x) : (string * Obj.t) list)) in
  let opstr = ref ("") in
  if ((Obj.obj (List.assoc ("op") !x) : int) = op_add) then (
  opstr := " + ";
  ) else (
  if ((Obj.obj (List.assoc ("op") !x) : int) = op_sub) then (
  opstr := " - ";
  ) else (
  if ((Obj.obj (List.assoc ("op") !x) : int) = op_mul) then (
  opstr := " * ";
  ) else (
  opstr := " / ";
  );
  );
  );
  __ret := (((("(" ^ ls) ^ !opstr) ^ rs) ^ ")"); raise Return;
  __ret := (((("(" ^ ls) ^ !opstr) ^ rs) ^ ")");
    !__ret
  with Return -> !__ret)

let n_cards = 4
let goal = 24
let digit_range = 9
let rec solve xs =
  let __ret = ref false in
  let xs = ref xs in
  (try
  if (List.length !xs = 1) then (
  let f = exprEval (List.nth (!xs) (0)) in
  if (((List.assoc ("denom") f) <> 0) && ((List.assoc ("num") f) = ((List.assoc ("denom") f) * goal))) then (
  print_endline (exprString (List.nth (!xs) (0)));
  __ret := true; raise Return;
  );
  __ret := false; raise Return;
  );
  let i = ref (0) in
  (try while (!i < List.length !xs) do
    try
  let j = ref ((!i + 1)) in
  (try while (!j < List.length !xs) do
    try
  let rest = ref ([]) in
  let k = ref (0) in
  (try while (!k < List.length !xs) do
    try
  if ((!k <> !i) && (!k <> !j)) then (
  rest := List.append !rest [List.nth (!xs) (!k)];
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  let a = List.nth (!xs) (!i) in
  let b = List.nth (!xs) (!j) in
  (try List.iter (fun op ->
    try
  let node = ref ([("op", Obj.repr op); ("left", Obj.repr a); ("right", Obj.repr b)]) in
  if solve (List.append !rest [!node]) then (
  __ret := true; raise Return;
  );
    with Continue -> ()) [op_add; op_sub; op_mul; op_div] with Break -> ());
  let node = ref ([("op", Obj.repr op_sub); ("left", Obj.repr b); ("right", Obj.repr a)]) in
  if solve (List.append !rest [!node]) then (
  __ret := true; raise Return;
  );
  node := [("op", Obj.repr op_div); ("left", Obj.repr b); ("right", Obj.repr a)];
  if solve (List.append !rest [!node]) then (
  __ret := true; raise Return;
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := false; raise Return;
  __ret := false;
    !__ret
  with Return -> !__ret)

let rec main () =
  let __ret = ref () in
  (try
  let iter = ref (0) in
  (try while (!iter < 10) do
    try
  let cards = ref ([]) in
  let i = ref (0) in
  (try while (!i < n_cards) do
    try
  let n = ((_now () mod (digit_range - 1)) + 1) in
  cards := List.append !cards [newNum (n)];
  print_endline ((" " ^ (string_of_int n)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline (":  ");
  if not (solve (!cards)) then (
  print_endline ("No solution");
  );
  iter := (!iter + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

let () =
  main ();
