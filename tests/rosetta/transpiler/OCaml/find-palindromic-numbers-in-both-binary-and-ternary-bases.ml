(* Generated by Mochi transpiler v0.10.52 on 2025-08-01 18:13 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0

exception Break
exception Continue

exception Return

let rec toBase n b =
  let __ret = ref "" in
  (try
  let n = (Obj.magic n : int) in
  let b = (Obj.magic b : int) in
  if (n = 0) then (
  __ret := (Obj.magic ("0") : string); raise Return
  );
  let s = ref ("") in
  let x = ref (n) in
  (try while (!x > 0) do
    try
  s := ((string_of_int ((!x mod b))) ^ !s);
  x := (!x / b);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and parseIntStr str =
  let __ret = ref 0 in
  (try
  let i = ref (0) in
  let neg = ref (false) in
  if ((String.length (str) > 0) && (String.make 1 (String.get (str) 0) = "-")) then (
  neg := true;
  i := 1;
  );
  let n = ref (0) in
  (try while (!i < String.length (str)) do
    try
  n := (((!n * 10) + int_of_string (String.sub (str) !i ((!i + 1) - !i))) - int_of_string ("0"));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if !neg then (
  n := -(!n);
  );
  __ret := (Obj.magic (!n) : int); raise Return
  with Return -> !__ret)

and parseIntBase s b =
  let __ret = ref 0 in
  (try
  let b = (Obj.magic b : int) in
  let n = ref (0) in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  n := ((!n * b) + parseIntStr (String.sub (s) !i ((!i + 1) - !i)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!n) : int); raise Return
  with Return -> !__ret)

and reverseStr s =
  let __ret = ref "" in
  (try
  let out = ref ("") in
  let i = ref ((String.length (s) - 1)) in
  (try while (!i >= 0) do
    try
  out := (!out ^ String.sub (s) !i ((!i + 1) - !i));
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!out) : string); raise Return
  with Return -> !__ret)

and isPalindrome s =
  let __ret = ref false in
  (try
  __ret := (Obj.magic ((s = reverseStr (s))) : bool); raise Return
  with Return -> !__ret)

and isPalindromeBin n =
  let __ret = ref false in
  (try
  let n = (Obj.magic n : int) in
  let b = toBase (n) (2) in
  __ret := (Obj.magic (isPalindrome (b)) : bool); raise Return
  with Return -> !__ret)

and myMin a b =
  let __ret = ref 0 in
  (try
  let a = (Obj.magic a : int) in
  let b = (Obj.magic b : int) in
  if (a < b) then (
  __ret := (Obj.magic (a) : int); raise Return
  );
  __ret := (Obj.magic (b) : int); raise Return
  with Return -> !__ret)

and myMax a b =
  let __ret = ref 0 in
  (try
  let a = (Obj.magic a : int) in
  let b = (Obj.magic b : int) in
  if (a > b) then (
  __ret := (Obj.magic (a) : int); raise Return
  );
  __ret := (Obj.magic (b) : int); raise Return
  with Return -> !__ret)

and reverse3 n =
  let __ret = ref 0 in
  (try
  let n = (Obj.magic n : int) in
  let x = ref (0) in
  let y = ref (n) in
  (try while (!y <> 0) do
    try
  x := ((!x * 3) + (!y mod 3));
  y := (!y / 3);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!x) : int); raise Return
  with Return -> !__ret)

and show n =
  let __ret = ref (Obj.magic 0) in
  (try
  let n = (Obj.magic n : int) in
  print_endline (("Decimal : " ^ (string_of_int (n))));
  print_endline (("Binary  : " ^ toBase (n) (2)));
  print_endline (("Ternary : " ^ toBase (n) (3)));
  print_endline ("");
    !__ret
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  print_endline ("The first 6 numbers which are palindromic in both binary and ternary are :\n");
  ignore (show (0));
  let count = ref (1) in
  let lo = ref (0) in
  let hi = ref (1) in
  let pow2 = ref (1) in
  let pow3 = ref (1) in
  (try while true do
    try
  let i = ref (!lo) in
  (try while (!i < !hi) do
    try
  let n = ref (((((!i * 3) + 1) * !pow3) + reverse3 (!i))) in
  if isPalindromeBin (!n) then (
  ignore (show (!n));
  count := (!count + 1);
  if (!count >= 6) then (
  __ret := (); raise Return
  );
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (!i = !pow3) then (
  pow3 := (!pow3 * 3);
  ) else (
  pow2 := (!pow2 * 4);
  );
  (try while true do
    try
  (try while (!pow2 <= !pow3) do
    try
  pow2 := (!pow2 * 4);
    with Continue -> ()
  done with Break -> ());
  let lo2 = ref ((((!pow2 / !pow3) - 1) / 3)) in
  let hi2 = ref ((((((!pow2 * 2) / !pow3) - 1) / 3) + 1)) in
  let lo3 = ref ((!pow3 / 3)) in
  let hi3 = ref (!pow3) in
  if (!lo2 >= !hi3) then (
  pow3 := (!pow3 * 3);
  ) else (
  if (!lo3 >= !hi2) then (
  pow2 := (!pow2 * 4);
  ) else (
  lo := myMax (!lo2) (!lo3);
  hi := myMin (!hi2) (!hi3);
  raise Break;
  );
  );
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)


let () =
  ignore (main ());
  ()