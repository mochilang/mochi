(* Generated by Mochi transpiler v0.10.42 on 2025-07-27 22:15 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec newBitmap w h max =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let w = (Obj.magic w : int) in
  let h = (Obj.magic h : int) in
  let max = (Obj.magic max : int) in
  let rows = ref ([]) in
  let y = ref (0) in
  (try while (!y < h) do
    try
  let row = ref ([]) in
  let x = ref (0) in
  (try while (!x < w) do
    try
  row := List.append !row [[("R", Obj.repr 0); ("G", Obj.repr 0); ("B", Obj.repr 0)]];
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  rows := List.append !rows [!row];
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("w", Obj.repr w); ("h", Obj.repr h); ("max", Obj.repr max); ("data", Obj.repr !rows)]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

let rec setPx b x y p =
  let __ret = ref (Obj.magic 0) in
  (try
  let x = (Obj.magic x : int) in
  let y = (Obj.magic y : int) in
  let rows = ref ((Obj.obj (List.assoc ("data") !b) : (string * Obj.t) list list list)) in
  let row = ref (List.nth (!rows) (y)) in
  row := (List.mapi (fun __i __x -> if __i = x then p else __x) (!row));
  rows := (List.mapi (fun __i __x -> if __i = y then !row else __x) (!rows));
  b := (("data", Obj.repr !rows) :: List.remove_assoc "data" (Obj.magic (!b) : (string * Obj.t) list));
    !__ret
  with Return -> !__ret)

let rec getPx b x y =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let x = (Obj.magic x : int) in
  let y = (Obj.magic y : int) in
  __ret := (Obj.magic (List.nth (List.nth ((Obj.obj (List.assoc ("data") b) : (string * Obj.t) list list list)) (y)) (x)) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

let rec splitLines s =
  let __ret = ref ([] : string list) in
  (try
  let out = ref ([]) in
  let cur = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  let ch = String.sub (s) !i ((!i + 1) - !i) in
  if (ch = "\n") then (
  out := List.append !out [!cur];
  cur := "";
  ) else (
  cur := (!cur ^ ch);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  out := List.append !out [!cur];
  __ret := (Obj.magic (!out) : string list); raise Return
  with Return -> !__ret)

let rec splitWS s =
  let __ret = ref ([] : string list) in
  (try
  let out = ref ([]) in
  let cur = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  let ch = String.sub (s) !i ((!i + 1) - !i) in
  if ((((ch = " ") || (ch = "\t")) || (ch = "\r")) || (ch = "\n")) then (
  if (String.length (!cur) > 0) then (
  out := List.append !out [!cur];
  cur := "";
  );
  ) else (
  cur := (!cur ^ ch);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (String.length (!cur) > 0) then (
  out := List.append !out [!cur];
  );
  __ret := (Obj.magic (!out) : string list); raise Return
  with Return -> !__ret)

let rec parseIntStr str =
  let __ret = ref 0 in
  (try
  let i = ref (0) in
  let neg = ref (false) in
  if ((String.length (str) > 0) && (String.sub (str) 0 (1 - 0) = "-")) then (
  neg := true;
  i := 1;
  );
  let n = ref (0) in
  let digits = ref ([("0", 0); ("1", 1); ("2", 2); ("3", 3); ("4", 4); ("5", 5); ("6", 6); ("7", 7); ("8", 8); ("9", 9)]) in
  (try while (!i < String.length (str)) do
    try
  n := ((!n * 10) + (try List.assoc (String.sub (str) !i ((!i + 1) - !i)) !digits with Not_found -> (Obj.magic 0)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if !neg then (
  n := -(!n);
  );
  __ret := (Obj.magic (!n) : int); raise Return
  with Return -> !__ret)

let rec tokenize s =
  let __ret = ref ([] : string list) in
  (try
  let lines = ref (splitLines (s)) in
  let toks = ref ([]) in
  let i = ref (0) in
  (try while (!i < List.length (!lines)) do
    try
  let line = List.nth (!lines) (!i) in
  if ((String.length (line) > 0) && (String.sub (line) 0 (1 - 0) = "#")) then (
  i := (!i + 1);
  raise Continue;
  );
  let parts = ref (splitWS (line)) in
  let j = ref (0) in
  (try while (!j < List.length (!parts)) do
    try
  toks := List.append !toks [List.nth (!parts) (!j)];
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!toks) : string list); raise Return
  with Return -> !__ret)

let rec readP3 text =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let toks = ref (tokenize (text)) in
  if (List.length (!toks) < 4) then (
  __ret := (Obj.magic (newBitmap (0) (0) (0)) : (string * Obj.t) list); raise Return
  );
  if (List.nth (!toks) (0) <> "P3") then (
  __ret := (Obj.magic (newBitmap (0) (0) (0)) : (string * Obj.t) list); raise Return
  );
  let w = parseIntStr (List.nth (!toks) (1)) in
  let h = parseIntStr (List.nth (!toks) (2)) in
  let maxv = parseIntStr (List.nth (!toks) (3)) in
  let idx = ref (4) in
  let bm = ref (newBitmap (w) (h) (maxv)) in
  let y = ref ((h - 1)) in
  (try while (!y >= 0) do
    try
  let x = ref (0) in
  (try while (!x < w) do
    try
  let r = parseIntStr (List.nth (!toks) (!idx)) in
  let g = parseIntStr (List.nth (!toks) ((!idx + 1))) in
  let b = parseIntStr (List.nth (!toks) ((!idx + 2))) in
  ignore (setPx (bm) (!x) (!y) ([("R", Obj.repr r); ("G", Obj.repr g); ("B", Obj.repr b)]));
  idx := (!idx + 3);
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!bm) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

let rec toGrey b =
  let __ret = ref (Obj.magic 0) in
  (try
  let h = (Obj.obj (List.assoc ("h") !b) : int) in
  let w = (Obj.obj (List.assoc ("w") !b) : int) in
  let m = ref (0) in
  let y = ref (0) in
  (try while (!y < h) do
    try
  let x = ref (0) in
  (try while (!x < w) do
    try
  let p = getPx (!b) (!x) (!y) in
  let l = ref ((((((Obj.obj (List.assoc ("R") p) : int) * 2126) + ((Obj.obj (List.assoc ("G") p) : int) * 7152)) + ((Obj.obj (List.assoc ("B") p) : int) * 722)) / 10000)) in
  if (!l > (Obj.obj (List.assoc ("max") !b) : int)) then (
  l := (Obj.obj (List.assoc ("max") !b) : int);
  );
  ignore (setPx (b) (!x) (!y) ([("R", Obj.repr !l); ("G", Obj.repr !l); ("B", Obj.repr !l)]));
  if (!l > !m) then (
  m := !l;
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  b := (("max", Obj.repr !m) :: List.remove_assoc "max" (Obj.magic (!b) : (string * Obj.t) list));
    !__ret
  with Return -> !__ret)

let rec pad n w =
  let __ret = ref "" in
  (try
  let n = (Obj.magic n : int) in
  let w = (Obj.magic w : int) in
  let s = ref ((string_of_int (n))) in
  (try while (String.length (!s) < w) do
    try
  s := (" " ^ !s);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

let rec writeP3 b =
  let __ret = ref "" in
  (try
  let h = (Obj.obj (List.assoc ("h") b) : int) in
  let w = (Obj.obj (List.assoc ("w") b) : int) in
  let max = ref ((Obj.obj (List.assoc ("max") b) : int)) in
  let digits = String.length ((string_of_int (!max))) in
  let out = ref ((((((("P3\n# generated from Bitmap.writeppmp3\n" ^ (string_of_int (w))) ^ " ") ^ (string_of_int (h))) ^ "\n") ^ (string_of_int (!max))) ^ "\n")) in
  let y = ref ((h - 1)) in
  (try while (!y >= 0) do
    try
  let line = ref ("") in
  let x = ref (0) in
  (try while (!x < w) do
    try
  let p = getPx (b) (!x) (!y) in
  line := ((((((!line ^ "   ") ^ pad ((Obj.obj (List.assoc ("R") p) : int)) (digits)) ^ " ") ^ pad ((Obj.obj (List.assoc ("G") p) : int)) (digits)) ^ " ") ^ pad ((Obj.obj (List.assoc ("B") p) : int)) (digits));
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  out := ((!out ^ !line) ^ "\n");
  y := (!y - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!out) : string); raise Return
  with Return -> !__ret)

let ppmtxt = ref (((((((("P3\n" ^ "# feep.ppm\n") ^ "4 4\n") ^ "15\n") ^ " 0  0  0    0  0  0    0  0  0   15  0 15\n") ^ " 0  0  0    0 15  7    0  0  0    0  0  0\n") ^ " 0  0  0    0  0  0    0 15  7    0  0  0\n") ^ "15  0 15    0  0  0    0  0  0    0  0  0\n"))
let bm = ref (readP3 (!ppmtxt))
let out = writeP3 (!bm)
let () =
  let mem_start = _mem () in
  let start = _now () in
  print_endline ("Original Colour PPM file");
  print_endline (__show !ppmtxt);
  print_endline ("Grey PPM:");
  ignore (toGrey (bm));
  print_endline (__show out);
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
