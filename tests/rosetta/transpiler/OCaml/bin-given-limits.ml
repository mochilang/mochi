(* Generated by Mochi transpiler v0.10.42 on 2025-07-27 17:23 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec getBins limits data =
  let __ret = ref ([] : int list) in
  (try
  let n = ref (List.length (limits)) in
  let bins = ref ([]) in
  let i = ref (0) in
  (try while (!i < (!n + 1)) do
    try
  bins := List.append !bins [0];
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let j = ref (0) in
  (try while (!j < List.length (data)) do
    try
  let d = List.nth (data) (!j) in
  let index = ref (0) in
  (try while (!index < List.length (limits)) do
    try
  if (d < List.nth (limits) (!index)) then (
  raise Break;
  );
  if (d = List.nth (limits) (!index)) then (
  index := (!index + 1);
  raise Break;
  );
  index := (!index + 1);
    with Continue -> ()
  done with Break -> ());
  bins := (List.mapi (fun __i __x -> if __i = !index then (List.nth (!bins) (!index) + 1) else __x) (!bins));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!bins) : int list); raise Return
  with Return -> !__ret)

let rec padLeft n width =
  let __ret = ref "" in
  (try
  let n = (Obj.magic n : int) in
  let width = (Obj.magic width : int) in
  let s = ref ((string_of_int (n))) in
  let pad = ref ((width - String.length (!s))) in
  let out = ref ("") in
  let i = ref (0) in
  (try while (!i < !pad) do
    try
  out := (!out ^ " ");
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!out ^ !s)) : string); raise Return
  with Return -> !__ret)

let rec printBins limits bins =
  let __ret = ref (Obj.magic 0) in
  (try
  let n = ref (List.length (limits)) in
  print_endline (((("           < " ^ padLeft (List.nth (limits) (0)) (3)) ^ " = ") ^ padLeft (List.nth (bins) (0)) (2)));
  let i = ref (1) in
  (try while (!i < !n) do
    try
  print_endline ((((((">= " ^ padLeft (List.nth (limits) ((!i - 1))) (3)) ^ " and < ") ^ padLeft (List.nth (limits) (!i)) (3)) ^ " = ") ^ padLeft (List.nth (bins) (!i)) (2)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline ((((">= " ^ padLeft (List.nth (limits) ((!n - 1))) (3)) ^ "           = ") ^ padLeft (List.nth (bins) (!n)) (2)));
  print_endline ("");
    !__ret
  with Return -> !__ret)

let rec main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let limitsList = ref ([[23; 37; 43; 53; 67; 83]; [14; 18; 249; 312; 389; 392; 513; 591; 634; 720]]) in
  let dataList = ref ([[95; 21; 94; 12; 99; 4; 70; 75; 83; 93; 52; 80; 57; 5; 53; 86; 65; 17; 92; 83; 71; 61; 54; 58; 47; 16; 8; 9; 32; 84; 7; 87; 46; 19; 30; 37; 96; 6; 98; 40; 79; 97; 45; 64; 60; 29; 49; 36; 43; 55]; [445; 814; 519; 697; 700; 130; 255; 889; 481; 122; 932; 77; 323; 525; 570; 219; 367; 523; 442; 933; 416; 589; 930; 373; 202; 253; 775; 47; 731; 685; 293; 126; 133; 450; 545; 100; 741; 583; 763; 306; 655; 267; 248; 477; 549; 238; 62; 678; 98; 534; 622; 907; 406; 714; 184; 391; 913; 42; 560; 247; 346; 860; 56; 138; 546; 38; 985; 948; 58; 213; 799; 319; 390; 634; 458; 945; 733; 507; 916; 123; 345; 110; 720; 917; 313; 845; 426; 9; 457; 628; 410; 723; 354; 895; 881; 953; 677; 137; 397; 97; 854; 740; 83; 216; 421; 94; 517; 479; 292; 963; 376; 981; 480; 39; 257; 272; 157; 5; 316; 395; 787; 942; 456; 242; 759; 898; 576; 67; 298; 425; 894; 435; 831; 241; 989; 614; 987; 770; 384; 692; 698; 765; 331; 487; 251; 600; 879; 342; 982; 527; 736; 795; 585; 40; 54; 901; 408; 359; 577; 237; 605; 847; 353; 968; 832; 205; 838; 427; 876; 959; 686; 646; 835; 127; 621; 892; 443; 198; 988; 791; 466; 23; 707; 467; 33; 670; 921; 180; 991; 396; 160; 436; 717; 918; 8; 374; 101; 684; 727; 749]]) in
  let i = ref (0) in
  (try while (!i < List.length (!limitsList)) do
    try
  print_endline ((("Example " ^ (string_of_int ((!i + 1)))) ^ "\n"));
  let bins = ref (getBins (List.nth (!limitsList) (!i)) (List.nth (!dataList) (!i))) in
  ignore (printBins (List.nth (!limitsList) (!i)) (!bins));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
