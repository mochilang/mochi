(* Generated by Mochi transpiler v0.10.57 on 2025-08-04 16:58 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let gregorianStr = ref (["January"; "February"; "March"; "April"; "May"; "June"; "July"; "August"; "September"; "October"; "November"; "December"])
let gregorian = ref ([31; 28; 31; 30; 31; 30; 31; 31; 30; 31; 30; 31])
let republicanStr = ref (["Vendemiaire"; "Brumaire"; "Frimaire"; "Nivose"; "Pluviose"; "Ventose"; "Germinal"; "Floreal"; "Prairial"; "Messidor"; "Thermidor"; "Fructidor"])
let sansculotidesStr = ref (["Fete de la vertu"; "Fete du genie"; "Fete du travail"; "Fete de l'opinion"; "Fete des recompenses"; "Fete de la Revolution"])
let rec greLeap year =
  let __ret = ref false in
  (try
  let year = (Obj.magic year : int) in
  let a = (year mod 4) in
  let b = (year mod 100) in
  let c = (year mod 400) in
  __ret := (Obj.magic (((a = 0) && ((b <> 0) || (c = 0)))) : bool); raise Return
  with Return -> !__ret)

and repLeap year =
  let __ret = ref false in
  (try
  let year = (Obj.magic year : int) in
  let a = ((year + 1) mod 4) in
  let b = ((year + 1) mod 100) in
  let c = ((year + 1) mod 400) in
  __ret := (Obj.magic (((a = 0) && ((b <> 0) || (c = 0)))) : bool); raise Return
  with Return -> !__ret)

and greToDay d m y =
  let __ret = ref 0 in
  (try
  let d = (Obj.magic d : int) in
  let m = (Obj.magic m : int) in
  let y = (Obj.magic y : int) in
  let yy = ref (y) in
  let mm = ref (m) in
  if (!mm < 3) then (
  yy := (!yy - 1);
  mm := (!mm + 12);
  );
  __ret := (Obj.magic ((((((((!yy * 36525) / 100) - (!yy / 100)) + (!yy / 400)) + ((306 * (!mm + 1)) / 10)) + d) - 654842)) : int); raise Return
  with Return -> !__ret)

and repToDay d m y =
  let __ret = ref 0 in
  (try
  let d = (Obj.magic d : int) in
  let m = (Obj.magic m : int) in
  let y = (Obj.magic y : int) in
  let dd = ref (d) in
  let mm = ref (m) in
  if (!mm = 13) then (
  mm := (!mm - 1);
  dd := (!dd + 30);
  );
  if repLeap (Obj.repr (y)) then (
  dd := (!dd - 1);
  );
  __ret := (Obj.magic ((((((((365 * y) + ((y + 1) / 4)) - ((y + 1) / 100)) + ((y + 1) / 400)) + (30 * !mm)) + !dd) - 395)) : int); raise Return
  with Return -> !__ret)

and dayToGre day =
  let __ret = ref ([] : (int) list) in
  (try
  let day = (Obj.magic day : int) in
  let y = ref (((day * 100) / 36525)) in
  let d = ref (((day - ((!y * 36525) / 100)) + 21)) in
  y := (!y + 1792);
  d := (((!d + (!y / 100)) - (!y / 400)) - 13);
  let m = ref (8) in
  (try while (!d > List.nth (!gregorian) (!m)) do
    try
  d := (!d - List.nth (!gregorian) (!m));
  m := (!m + 1);
  if (!m = 12) then (
  m := 0;
  y := (!y + 1);
  if greLeap (Obj.repr (!y)) then (
  gregorian := (List.mapi (fun __i __x -> if __i = 1 then 29 else __x) (!gregorian));
  ) else (
  gregorian := (List.mapi (fun __i __x -> if __i = 1 then 28 else __x) (!gregorian));
  );
  );
    with Continue -> ()
  done with Break -> ());
  m := (!m + 1);
  __ret := (Obj.magic ([!d; !m; !y]) : int list); raise Return
  with Return -> !__ret)

and dayToRep day =
  let __ret = ref ([] : (int) list) in
  (try
  let day = (Obj.magic day : int) in
  let y = ref ((((day - 1) * 100) / 36525)) in
  if repLeap (Obj.repr (!y)) then (
  y := (!y - 1);
  );
  let d = ref (((((day - (((!y + 1) * 36525) / 100)) + 365) + ((!y + 1) / 100)) - ((!y + 1) / 400))) in
  y := (!y + 1);
  let m = ref (1) in
  let sc = ref (5) in
  if repLeap (Obj.repr (!y)) then (
  sc := 6;
  );
  (try while (!d > 30) do
    try
  d := (!d - 30);
  m := (!m + 1);
  if (!m = 13) then (
  if (!d > !sc) then (
  d := (!d - !sc);
  m := 1;
  y := (!y + 1);
  sc := 5;
  if repLeap (Obj.repr (!y)) then (
  sc := 6;
  );
  );
  );
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([!d; !m; !y]) : int list); raise Return
  with Return -> !__ret)

and formatRep d m y =
  let __ret = ref "" in
  (try
  let d = (Obj.magic d : int) in
  let m = (Obj.magic m : int) in
  let y = (Obj.magic y : int) in
  if (m = 13) then (
  __ret := (Obj.magic (((List.nth (!sansculotidesStr) ((d - 1)) ^ " ") ^ (string_of_int (y)))) : string); raise Return
  );
  __ret := (Obj.magic ((((((string_of_int (d)) ^ " ") ^ List.nth (!republicanStr) ((m - 1))) ^ " ") ^ (string_of_int (y)))) : string); raise Return
  with Return -> !__ret)

and formatGre d m y =
  let __ret = ref "" in
  (try
  let d = (Obj.magic d : int) in
  let m = (Obj.magic m : int) in
  let y = (Obj.magic y : int) in
  __ret := (Obj.magic ((((((string_of_int (d)) ^ " ") ^ List.nth (!gregorianStr) ((m - 1))) ^ " ") ^ (string_of_int (y)))) : string); raise Return
  with Return -> !__ret)


let rep = ref (dayToRep (Obj.repr (greToDay (Obj.repr (20)) (Obj.repr (5)) (Obj.repr (1795)))))
let () =
  let mem_start = _mem () in
  let start = _now () in
  print_endline (__show (formatRep (Obj.repr (List.nth (!rep) (0))) (Obj.repr (List.nth (!rep) (1))) (Obj.repr (List.nth (!rep) (2)))));
  let gre = ref (dayToGre (Obj.repr (repToDay (Obj.repr (1)) (Obj.repr (9)) (Obj.repr (3))))) in
  print_endline (__show (formatGre (Obj.repr (List.nth (!gre) (0))) (Obj.repr (List.nth (!gre) (1))) (Obj.repr (List.nth (!gre) (2)))));
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()