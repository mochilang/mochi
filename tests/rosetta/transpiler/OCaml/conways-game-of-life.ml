(* Generated by Mochi transpiler v0.10.52 on 2025-08-02 00:28 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let seed = ref (1)
let rec randN n =
  let __ret = ref 0 in
  (try
  let n = (Obj.magic n : int) in
  seed := (((!seed * 1664525) + 1013904223) mod 2147483647);
  __ret := (Obj.magic ((!seed mod n)) : int); raise Return
  with Return -> !__ret)

and newField w h =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let w = (Obj.magic w : int) in
  let h = (Obj.magic h : int) in
  let rows = ref (([] : bool list list)) in
  let y = ref (0) in
  (try while (!y < h) do
    try
  let row = ref (([] : bool list)) in
  let x = ref (0) in
  (try while (!x < w) do
    try
  row := (List.append (!row) [(Obj.magic (false) : bool)]);
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  rows := (List.append (!rows) [(Obj.magic (!row) : bool list)]);
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("s", Obj.repr (!rows)); ("w", Obj.repr (w)); ("h", Obj.repr (h))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and setCell f x y b =
  let __ret = ref (Obj.magic 0) in
  (try
  let x = (Obj.magic x : int) in
  let y = (Obj.magic y : int) in
  let rows = ref ((Obj.obj (List.assoc ("s") !f) : bool list list)) in
  let row = ref (List.nth (!rows) (y)) in
  row := (List.mapi (fun __i __x -> if __i = x then b else __x) (!row));
  rows := (List.mapi (fun __i __x -> if __i = y then !row else __x) (!rows));
  f := (("s", Obj.repr (!rows)) :: List.remove_assoc ("s") (Obj.magic (!f) : (string * Obj.t) list));
    !__ret
  with Return -> !__ret)

and state f x y =
  let __ret = ref false in
  (try
  x := (Obj.magic !x : int);
  y := (Obj.magic !y : int);
  (try while (!y < 0) do
    try
  y := (!y + (Obj.obj (List.assoc ("h") f) : int));
    with Continue -> ()
  done with Break -> ());
  (try while (!x < 0) do
    try
  x := (!x + (Obj.obj (List.assoc ("w") f) : int));
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (List.nth (List.nth ((Obj.obj (List.assoc ("s") f) : bool list list)) ((!y mod (Obj.obj (List.assoc ("h") f) : int)))) ((!x mod (Obj.obj (List.assoc ("w") f) : int)))) : bool); raise Return
  with Return -> !__ret)

and nextState f x y =
  let __ret = ref false in
  (try
  let x = (Obj.magic x : int) in
  let y = (Obj.magic y : int) in
  let count = ref (0) in
  let dy = ref (-(1)) in
  (try while (!dy <= 1) do
    try
  let dx = ref (-(1)) in
  (try while (!dx <= 1) do
    try
  if (not (((!dx = 0) && (!dy = 0))) && state (f) (ref ((x + !dx))) (ref ((y + !dy)))) then (
  count := (!count + 1);
  );
  dx := (!dx + 1);
    with Continue -> ()
  done with Break -> ());
  dy := (!dy + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (((!count = 3) || ((!count = 2) && state (f) (ref (x)) (ref (y))))) : bool); raise Return
  with Return -> !__ret)

and newLife w h =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let w = (Obj.magic w : int) in
  let h = (Obj.magic h : int) in
  let a = ref (newField (Obj.repr (w)) (Obj.repr (h))) in
  let i = ref (0) in
  (try while (!i < ((w * h) / 2)) do
    try
  ignore (setCell (a) (Obj.repr (randN (Obj.repr (w)))) (Obj.repr (randN (Obj.repr (h)))) (true));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("a", Obj.repr (!a)); ("b", Obj.repr (newField (Obj.repr (w)) (Obj.repr (h)))); ("w", Obj.repr (w)); ("h", Obj.repr (h))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and step l =
  let __ret = ref (Obj.magic 0) in
  (try
  let y = ref (0) in
  (try while (!y < (Obj.obj (List.assoc ("h") !l) : int)) do
    try
  let x = ref (0) in
  (try while (!x < (Obj.obj (List.assoc ("w") !l) : int)) do
    try
  ignore (setCell (ref ((Obj.obj (List.assoc ("b") !l) : (string * Obj.t) list))) (Obj.repr (!x)) (Obj.repr (!y)) (nextState ((Obj.obj (List.assoc ("a") !l) : (string * Obj.t) list)) (Obj.repr (!x)) (Obj.repr (!y))));
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  let tmp = ref ((Obj.obj (List.assoc ("a") !l) : (string * Obj.t) list)) in
  l := (("a", Obj.repr ((Obj.obj (List.assoc ("b") !l) : (string * Obj.t) list))) :: List.remove_assoc ("a") (Obj.magic (!l) : (string * Obj.t) list));
  l := (("b", Obj.repr (!tmp)) :: List.remove_assoc ("b") (Obj.magic (!l) : (string * Obj.t) list));
    !__ret
  with Return -> !__ret)

and lifeString l =
  let __ret = ref "" in
  (try
  let out = ref ("") in
  let y = ref (0) in
  (try while (!y < (Obj.obj (List.assoc ("h") l) : int)) do
    try
  let x = ref (0) in
  (try while (!x < (Obj.obj (List.assoc ("w") l) : int)) do
    try
  if state ((Obj.obj (List.assoc ("a") l) : (string * Obj.t) list)) (x) (y) then (
  out := (!out ^ "*");
  ) else (
  out := (!out ^ " ");
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  out := (!out ^ "\n");
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!out) : string); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let l = ref (newLife (Obj.repr (80)) (Obj.repr (15))) in
  let i = ref (0) in
  (try while (!i < 300) do
    try
  ignore (step (l));
  print_endline ("\f");
  print_endline (lifeString (!l));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()