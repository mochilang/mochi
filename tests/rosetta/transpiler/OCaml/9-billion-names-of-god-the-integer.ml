(* Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:42 +0700 *)

exception Break
exception Continue

exception Return

let rec bigTrim a =
  let __ret = ref [] in
  let a = ref a in
  (try
  let n = ref (List.length !a) in
  (try while ((!n > 1) && (List.nth !a (!n - 1) = 0)) do
    try
  a := List.of_seq (Seq.take ((!n - 1) - 0) (Seq.drop 0 (List.to_seq !a)));
  n := (!n - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !a; raise Return;
  __ret := !a;
    !__ret
  with Return -> !__ret)

let rec bigFromInt x =
  let __ret = ref [] in
  let x = ref x in
  (try
  if (!x = 0) then (
  __ret := [0]; raise Return;
  );
  let digits = ref ([]) in
  let n = ref (!x) in
  (try while (!n > 0) do
    try
  digits := List.append !digits [(!n mod 10)];
  n := (!n / 10);
    with Continue -> ()
  done with Break -> ());
  __ret := !digits; raise Return;
  __ret := !digits;
    !__ret
  with Return -> !__ret)

let rec bigAdd a b =
  let __ret = ref [] in
  let a = ref a in
  let b = ref b in
  (try
  let res = ref ([]) in
  let carry = ref (0) in
  let i = ref (0) in
  (try while (((!i < List.length !a) || (!i < List.length !b)) || (!carry > 0)) do
    try
  let av = ref (0) in
  if (!i < List.length !a) then (
  av := List.nth !a !i;
  );
  let bv = ref (0) in
  if (!i < List.length !b) then (
  bv := List.nth !b !i;
  );
  let s = ref (((!av + !bv) + !carry)) in
  res := List.append !res [(!s mod 10)];
  carry := (!s / 10);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := bigTrim (!res); raise Return;
  __ret := bigTrim (!res);
    !__ret
  with Return -> !__ret)

let rec bigSub a b =
  let __ret = ref [] in
  let a = ref a in
  let b = ref b in
  (try
  let res = ref ([]) in
  let borrow = ref (0) in
  let i = ref (0) in
  (try while (!i < List.length !a) do
    try
  let av = ref (List.nth !a !i) in
  let bv = ref (0) in
  if (!i < List.length !b) then (
  bv := List.nth !b !i;
  );
  let diff = ref (((!av - !bv) - !borrow)) in
  if (!diff < 0) then (
  diff := (!diff + 10);
  borrow := 1;
  ) else (
  borrow := 0;
  );
  res := List.append !res [!diff];
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := bigTrim (!res); raise Return;
  __ret := bigTrim (!res);
    !__ret
  with Return -> !__ret)

let rec bigToString a =
  let __ret = ref "" in
  let a = ref a in
  (try
  let s = ref ("") in
  let i = ref ((List.length !a - 1)) in
  (try while (!i >= 0) do
    try
  s := (!s ^ (string_of_int (List.nth !a !i)));
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !s; raise Return;
  __ret := !s;
    !__ret
  with Return -> !__ret)

let rec minInt a b =
  let __ret = ref 0 in
  let a = ref a in
  let b = ref b in
  (try
  if (!a < !b) then (
  __ret := !a; raise Return;
  ) else (
  __ret := !b; raise Return;
  );
    !__ret
  with Return -> !__ret)

let rec cumu n =
  let __ret = ref [] in
  let n = ref n in
  (try
  let cache = ref ([[bigFromInt (1)]]) in
  let y = ref (1) in
  (try while (!y <= !n) do
    try
  let row = ref ([bigFromInt (0)]) in
  let x = ref (1) in
  (try while (!x <= !y) do
    try
  let val_ = List.nth List.nth !cache (!y - !x) minInt (!x) ((!y - !x)) in
  row := List.append !row [bigAdd (List.nth !row (List.length !row - 1)) (val_)];
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  cache := List.append !cache [!row];
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := List.nth !cache !n; raise Return;
  __ret := List.nth !cache !n;
    !__ret
  with Return -> !__ret)

let rec row n =
  let __ret = ref [] in
  let n = ref n in
  (try
  let e = cumu (!n) in
  let out = ref ([]) in
  let i = ref (0) in
  (try while (!i < !n) do
    try
  let diff = bigSub (List.nth e (!i + 1)) (List.nth e !i) in
  out := List.append !out [bigToString (diff)];
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !out; raise Return;
  __ret := !out;
    !__ret
  with Return -> !__ret)

let x = ref (1)
let () =
  print_endline ("rows:");
  (try while (!x < 11) do
    try
  let r = row (!x) in
  let line = ref ("") in
  let i = ref (0) in
  (try while (!i < List.length r) do
    try
  line := (((!line ^ " ") ^ List.nth r !i) ^ " ");
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline (!line);
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline ("");
  print_endline ("sums:");
  (try List.iter (fun num ->
    try
  let r = cumu (num) in
  print_endline ((((string_of_int (num)) ^ " ") ^ bigToString (List.nth r (List.length r - 1))));
    with Continue -> ()) [23; 123; 1234] with Break -> ());
