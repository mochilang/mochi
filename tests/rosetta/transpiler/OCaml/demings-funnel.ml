(* Generated by Mochi transpiler v0.10.52 on 2025-08-02 00:57 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec sqrtApprox x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  if (x <= 0.0) then (
  __ret := (Obj.magic (0.0) : float); raise Return
  );
  let g = ref (x) in
  let i = ref (0) in
  (try while (!i < 20) do
    try
  g := ((!g +. (x /. !g)) /. 2.0);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!g) : float); raise Return
  with Return -> !__ret)


let dxs = ref ([(-.(0.533)); 0.27; 0.859; (-.(0.043)); (-.(0.205)); (-.(0.127)); (-.(0.071)); 0.275; 1.251; (-.(0.231)); (-.(0.401)); 0.269; 0.491; 0.951; 1.15; 0.001; (-.(0.382)); 0.161; 0.915; 2.08; (-.(2.337)); 0.034; (-.(0.126)); 0.014; 0.709; 0.129; (-.(1.093)); (-.(0.483)); (-.(1.193)); 0.02; (-.(0.051)); 0.047; (-.(0.095)); 0.695; 0.34; (-.(0.182)); 0.287; 0.213; (-.(0.423)); (-.(0.021)); (-.(0.134)); 1.798; 0.021; (-.(1.099)); (-.(0.361)); 1.636; (-.(1.134)); 1.315; 0.201; 0.034; 0.097; (-.(0.17)); 0.054; (-.(0.553)); (-.(0.024)); (-.(0.181)); (-.(0.7)); (-.(0.361)); (-.(0.789)); 0.279; (-.(0.174)); (-.(0.009)); (-.(0.323)); (-.(0.658)); 0.348; (-.(0.528)); 0.881; 0.021; (-.(0.853)); 0.157; 0.648; 1.774; (-.(1.043)); 0.051; 0.021; 0.247; (-.(0.31)); 0.171; 0.0; 0.106; 0.024; (-.(0.386)); 0.962; 0.765; (-.(0.125)); (-.(0.289)); 0.521; 0.017; 0.281; (-.(0.749)); (-.(0.149)); (-.(2.436)); (-.(0.909)); 0.394; (-.(0.113)); (-.(0.598)); 0.443; (-.(0.521)); (-.(0.799)); 0.087])
let dys = ref ([0.136; 0.717; 0.459; (-.(0.225)); 1.392; 0.385; 0.121; (-.(0.395)); 0.49; (-.(0.682)); (-.(0.065)); 0.242; (-.(0.288)); 0.658; 0.459; 0.0; 0.426; 0.205; (-.(0.765)); (-.(2.188)); (-.(0.742)); (-.(0.01)); 0.089; 0.208; 0.585; 0.633; (-.(0.444)); (-.(0.351)); (-.(1.087)); 0.199; 0.701; 0.096; (-.(0.025)); (-.(0.868)); 1.051; 0.157; 0.216; 0.162; 0.249; (-.(0.007)); 0.009; 0.508; (-.(0.79)); 0.723; 0.881; (-.(0.508)); 0.393; (-.(0.226)); 0.71; 0.038; (-.(0.217)); 0.831; 0.48; 0.407; 0.447; (-.(0.295)); 1.126; 0.38; 0.549; (-.(0.445)); (-.(0.046)); 0.428; (-.(0.074)); 0.217; (-.(0.822)); 0.491; 1.347; (-.(0.141)); 1.23; (-.(0.044)); 0.079; 0.219; 0.698; 0.275; 0.056; 0.031; 0.421; 0.064; 0.721; 0.104; (-.(0.729)); 0.65; (-.(1.103)); 0.154; (-.(1.72)); 0.051; (-.(0.385)); 0.477; 1.537; (-.(0.901)); 0.939; (-.(0.411)); 0.341; (-.(0.411)); 0.106; 0.224; (-.(0.947)); (-.(1.424)); (-.(0.542)); (-.(1.032))])
let rec funnel fa r =
  let __ret = ref ([] : float list) in
  (try
  let x = ref (0.0) in
  let result = ref ([]) in
  let i = ref (0) in
  (try while (!i < List.length (fa)) do
    try
  let f = List.nth (fa) (!i) in
  result := (List.append (!result) [(Obj.magic ((!x +. f)) : float)]);
  x := r (Obj.repr (!x)) (Obj.repr (f));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!result) : float list); raise Return
  with Return -> !__ret)

and mean fa =
  let __ret = ref 0.0 in
  (try
  let sum = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (fa)) do
    try
  sum := (!sum +. List.nth (fa) (!i));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((!sum /. float_of_int (List.length (fa)))) : float); raise Return
  with Return -> !__ret)

and stdDev fa =
  let __ret = ref 0.0 in
  (try
  let m = mean (fa) in
  let sum = ref (0.0) in
  let i = ref (0) in
  (try while (!i < List.length (fa)) do
    try
  let d = (List.nth (fa) (!i) -. m) in
  sum := (!sum +. (d *. d));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let r = sqrtApprox (Obj.repr ((!sum /. float_of_int (List.length (fa))))) in
  __ret := (Obj.magic (r) : float); raise Return
  with Return -> !__ret)

and experiment label r =
  let __ret = ref (Obj.magic 0) in
  (try
  let rxs = ref (funnel (!dxs) (r)) in
  let rys = ref (funnel (!dys) (r)) in
  print_endline ((label ^ "  :      x        y"));
  print_endline (((("Mean    :  " ^ (Printf.sprintf "%.16g" (mean (!rxs)))) ^ ", ") ^ (Printf.sprintf "%.16g" (mean (!rys)))));
  print_endline (((("Std Dev :  " ^ (Printf.sprintf "%.16g" (stdDev (!rxs)))) ^ ", ") ^ (Printf.sprintf "%.16g" (stdDev (!rys)))));
  print_endline ("");
    !__ret
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  ignore (experiment ("Rule 1") ((fun x y ->
  let x = (Obj.magic x : float) in
  let y = (Obj.magic y : float) in
  0.0)));
  ignore (experiment ("Rule 2") ((fun x dz ->
  let x = (Obj.magic x : float) in
  let dz = (Obj.magic dz : float) in
  (-.(dz)))));
  ignore (experiment ("Rule 3") ((fun z dz ->
  let z = (Obj.magic z : float) in
  let dz = (Obj.magic dz : float) in
  (-.((z +. dz))))));
  ignore (experiment ("Rule 4") ((fun z dz ->
  let z = (Obj.magic z : float) in
  let dz = (Obj.magic dz : float) in
  (z +. dz))));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()