(* Generated by Mochi transpiler v0.10.55 on 2025-08-02 18:27 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0

open Str


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())


let _split s sep =
  let c = if String.length sep = 0 then ' ' else sep.[0] in
  String.split_on_char c s

exception Break
exception Continue

exception Return

let rec split s sep =
  let __ret = ref ([] : string list) in
  (try
  let out = ref (([] : string list)) in
  let cur = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if (((!i + String.length (sep)) <= String.length (s)) && (String.sub (s) !i ((!i + String.length (sep)) - !i) = sep)) then (
  out := (List.append (!out) [(Obj.magic (!cur) : string)]);
  cur := "";
  i := (!i + String.length (sep));
  ) else (
  cur := (!cur ^ String.sub (s) !i ((!i + 1) - !i));
  i := (!i + 1);
  );
    with Continue -> ()
  done with Break -> ());
  out := (List.append (!out) [(Obj.magic (!cur) : string)]);
  __ret := (Obj.magic (!out) : string list); raise Return
  with Return -> !__ret)

and join xs sep =
  let __ret = ref "" in
  (try
  let res = ref ("") in
  let i = ref (0) in
  (try while (!i < List.length (xs)) do
    try
  if (!i > 0) then (
  res := (!res ^ sep);
  );
  res := (!res ^ List.nth (xs) (!i));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : string); raise Return
  with Return -> !__ret)

and trimLeftSpaces s =
  let __ret = ref "" in
  (try
  let i = ref (0) in
  (try while ((!i < String.length (s)) && (String.sub (s) !i ((!i + 1) - !i) = " ")) do
    try
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (String.sub (s) !i (String.length (s) - !i)) : string); raise Return
  with Return -> !__ret)

and makeIndent outline tab =
  let __ret = ref ([] : (string * Obj.t) list list) in
  (try
  let tab = (Obj.magic tab : int) in
  let lines = ref (_split (outline) ("\n")) in
  let nodes = ref (([] : (string * Obj.t) list list)) in
  (try List.iter (fun line ->
    try
  let line2 = trimLeftSpaces (line) in
  let level = ((String.length (line) - String.length (line2)) / tab) in
  nodes := (List.append (!nodes) [(Obj.magic ([("level", Obj.repr (level)); ("name", Obj.repr (line2))]) : (string * Obj.t) list)]);
    with Continue -> ()) (!lines) with Break -> ());
  __ret := (Obj.magic (!nodes) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and toNest nodes start level n =
  let __ret = ref (Obj.magic 0) in
  (try
  let start = (Obj.magic start : int) in
  let level = (Obj.magic level : int) in
  if (level = 0) then (
  n := (("name", Obj.repr ((Obj.obj (List.assoc ("name") List.nth (nodes) (0)) : int))) :: List.remove_assoc ("name") (Obj.magic (!n) : (string * Obj.t) list));
  );
  let i = ref ((start + 1)) in
  (try while (!i < List.length (nodes)) do
    try
  let node = ref (List.nth (nodes) (!i)) in
  let lev = (Obj.obj (List.assoc ("level") !node) : int) in
  if (lev = (level + 1)) then (
  let child = ref ([("name", Obj.repr ((Obj.obj (List.assoc ("name") !node) : int))); ("children", Obj.repr ([]))]) in
  ignore (toNest (nodes) (Obj.repr (!i)) (Obj.repr ((level + 1))) (child));
  let cs = ref ((Obj.magic (Obj.obj (List.assoc ("children") !n) : int) : Obj.t list)) in
  cs := (List.append (!cs) [(Obj.magic (!child) : Obj.t)]);
  n := (("children", Obj.repr (!cs)) :: List.remove_assoc ("children") (Obj.magic (!n) : (string * Obj.t) list));
  ) else (
  if (lev <= level) then (
  __ret := (); raise Return
  );
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and countLeaves n =
  let __ret = ref 0 in
  (try
  let kids = ref ((Obj.magic (Obj.obj (List.assoc ("children") n) : int) : Obj.t list)) in
  if (List.length (!kids) = 0) then (
  __ret := (Obj.magic (1) : int); raise Return
  );
  let total = ref (0) in
  (try List.iter (fun k ->
    try
  total := (!total + countLeaves ((Obj.magic k : (string * Obj.t) list)));
    with Continue -> ()) (!kids) with Break -> ());
  __ret := (Obj.magic (!total) : int); raise Return
  with Return -> !__ret)

and nodesByDepth root depth =
  let __ret = ref ([] : (string * Obj.t) list list list) in
  (try
  let depth = (Obj.magic depth : int) in
  let levels = ref (([] : (string * Obj.t) list list list)) in
  let current = ref ([root]) in
  let d = ref (0) in
  (try while (!d < depth) do
    try
  levels := (List.append (!levels) [(Obj.magic (!current) : (string * Obj.t) list list)]);
  let next = ref (([] : (string * Obj.t) list list)) in
  (try List.iter (fun n ->
    try
  let kids = ref ((Obj.magic (try List.assoc ("children") n with Not_found -> 0) : Obj.t list)) in
  (try List.iter (fun k ->
    try
  next := (List.append (!next) [(Obj.magic ((Obj.magic k : (string * Obj.t) list)) : (string * Obj.t) list)]);
    with Continue -> ()) (!kids) with Break -> ());
    with Continue -> ()) (!current) with Break -> ());
  current := !next;
  d := (!d + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!levels) : (string * Obj.t) list list list); raise Return
  with Return -> !__ret)

and toMarkup n cols depth =
  let __ret = ref "" in
  (try
  let depth = (Obj.magic depth : int) in
  let lines = ref (([] : string list)) in
  lines := (List.append (!lines) [(Obj.magic ("{| class=\"wikitable\" style=\"text-align: center;\"") : string)]);
  let l1 = "|-" in
  lines := (List.append (!lines) [(Obj.magic (l1) : string)]);
  let span = ref (countLeaves (n)) in
  lines := (List.append (!lines) [(Obj.magic (((((("| style=\"background: " ^ List.nth (cols) (0)) ^ " \" colSpan=") ^ (string_of_int (!span))) ^ " | ") ^ (Obj.magic (Obj.obj (List.assoc ("name") n) : int) : string))) : string)]);
  lines := (List.append (!lines) [(Obj.magic (l1) : string)]);
  let lvls = ref (nodesByDepth (n) (Obj.repr (depth))) in
  let lvl = ref (1) in
  (try while (!lvl < depth) do
    try
  let nodes = ref (List.nth (!lvls) (!lvl)) in
  if (List.length (!nodes) = 0) then (
  lines := (List.append (!lines) [(Obj.magic ("|  |") : string)]);
  ) else (
  let idx = ref (0) in
  (try while (!idx < List.length (!nodes)) do
    try
  let node = ref (List.nth (!nodes) (!idx)) in
  span := countLeaves (!node);
  let col = ref (!lvl) in
  if (!lvl = 1) then (
  col := (!idx + 1);
  );
  if (!col >= List.length (cols)) then (
  col := (List.length (cols) - 1);
  );
  let cell = ((((("| style=\"background: " ^ List.nth (cols) (!col)) ^ " \" colspan=") ^ (string_of_int (!span))) ^ " | ") ^ (Obj.magic (try List.assoc ("name") !node with Not_found -> 0) : string)) in
  lines := (List.append (!lines) [(Obj.magic (cell) : string)]);
  idx := (!idx + 1);
    with Continue -> ()
  done with Break -> ());
  );
  if (!lvl < (depth - 1)) then (
  lines := (List.append (!lines) [(Obj.magic (l1) : string)]);
  );
  lvl := (!lvl + 1);
    with Continue -> ()
  done with Break -> ());
  lines := (List.append (!lines) [(Obj.magic ("|}") : string)]);
  __ret := (Obj.magic (join (!lines) ("\n")) : string); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let outline = ((((((((((("Display an outline as a nested table.\n" ^ "    Parse the outline to a tree,\n") ^ "        measuring the indent of each line,\n") ^ "        translating the indentation to a nested structure,\n") ^ "        and padding the tree to even depth.\n") ^ "    count the leaves descending from each node,\n") ^ "        defining the width of a leaf as 1,\n") ^ "        and the width of a parent node as a sum.\n") ^ "            (The sum of the widths of its children)\n") ^ "    and write out a table with 'colspan' values\n") ^ "        either as a wiki table,\n") ^ "        or as HTML.") in
  let yellow = "#ffffe6;" in
  let orange = "#ffebd2;" in
  let green = "#f0fff0;" in
  let blue = "#e6ffff;" in
  let pink = "#ffeeff;" in
  let cols = ref ([yellow; orange; green; blue; pink]) in
  let nodes = ref (makeIndent (outline) (Obj.repr (4))) in
  let n = ref ([("name", Obj.repr ("")); ("children", Obj.repr ([]))]) in
  ignore (toNest (!nodes) (Obj.repr (0)) (Obj.repr (0)) (n));
  print_endline (toMarkup (!n) (!cols) (Obj.repr (4)));
  print_endline ("\n");
  let outline2 = ((((((((((((("Display an outline as a nested table.\n" ^ "    Parse the outline to a tree,\n") ^ "        measuring the indent of each line,\n") ^ "        translating the indentation to a nested structure,\n") ^ "        and padding the tree to even depth.\n") ^ "    count the leaves descending from each node,\n") ^ "        defining the width of a leaf as 1,\n") ^ "        and the width of a parent node as a sum.\n") ^ "            (The sum of the widths of its children)\n") ^ "            Propagating the sums upward as necessary.\n") ^ "    and write out a table with 'colspan' values\n") ^ "        either as a wiki table,\n") ^ "        or as HTML.\n") ^ "    Optionally add color to the nodes.") in
  let cols2 = ref ([blue; yellow; orange; green; pink]) in
  let nodes2 = ref (makeIndent (outline2) (Obj.repr (4))) in
  let n2 = ref ([("name", Obj.repr ("")); ("children", Obj.repr ([]))]) in
  ignore (toNest (!nodes2) (Obj.repr (0)) (Obj.repr (0)) (n2));
  print_endline (toMarkup (!n2) (!cols2) (Obj.repr (4)));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()