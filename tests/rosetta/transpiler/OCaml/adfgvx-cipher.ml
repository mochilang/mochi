(* Generated by Mochi transpiler v0.10.40 on 2025-07-25 05:42 UTC *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let adfgvx = ref ("ADFGVX")
let alphabet = ref ("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
let rec shuffleStr s =
  let __ret = ref "" in
  (try
  let arr = ref ([]) in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  arr := List.append !arr [String.sub (s) !i ((!i + 1) - !i)];
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let j = ref ((List.length (!arr) - 1)) in
  (try while (!j > 0) do
    try
  let k = (_now () mod (!j + 1)) in
  let tmp = List.nth (!arr) (!j) in
  arr := (List.mapi (fun __i __x -> if __i = !j then List.nth (!arr) (k) else __x) (!arr));
  arr := (List.mapi (fun __i __x -> if __i = k then tmp else __x) (!arr));
  j := (!j - 1);
    with Continue -> ()
  done with Break -> ());
  let out = ref ("") in
  i := 0;
  (try while (!i < List.length (!arr)) do
    try
  out := (!out ^ List.nth (!arr) (!i));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !out; raise Return
  with Return -> !__ret)

let rec createPolybius () =
  let __ret = ref [] in
  (try
  let shuffled = shuffleStr (!alphabet) in
  let labels = ref ([]) in
  let li = ref (0) in
  (try while (!li < String.length (!adfgvx)) do
    try
  labels := List.append !labels [String.sub (!adfgvx) !li ((!li + 1) - !li)];
  li := (!li + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline ("6 x 6 Polybius square:\n");
  print_endline ("  | A D F G V X");
  print_endline ("---------------");
  let p = ref ([]) in
  let i = ref (0) in
  (try while (!i < 6) do
    try
  let row = ref (String.sub (shuffled) (!i * 6) (((!i + 1) * 6) - (!i * 6))) in
  p := List.append !p [!row];
  let line = ref ((List.nth (!labels) (!i) ^ " | ")) in
  let j = ref (0) in
  (try while (!j < 6) do
    try
  line := ((!line ^ String.sub (!row) !j ((!j + 1) - !j)) ^ " ");
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline (__show !line);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !p; raise Return
  with Return -> !__ret)

let rec createKey n =
  let __ret = ref "" in
  (try
  if ((n < 7) || (n > 12)) then (
  print_endline ("Key should be within 7 and 12 letters long.");
  );
  let pool = ref ("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") in
  let key = ref ("") in
  let i = ref (0) in
  (try while (!i < n) do
    try
  let idx = (_now () mod String.length (!pool)) in
  key := (!key ^ String.make 1 (String.get (!pool) idx));
  pool := (String.sub (!pool) 0 (idx - 0) ^ String.sub (!pool) (idx + 1) (String.length (!pool) - (idx + 1)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline (("\nThe key is " ^ !key));
  __ret := !key; raise Return
  with Return -> !__ret)

let rec orderKey key =
  let __ret = ref [] in
  (try
  let pairs = ref ([]) in
  let i = ref (0) in
  (try while (!i < String.length (key)) do
    try
  pairs := List.append !pairs [[Obj.repr (String.sub (key) !i ((!i + 1) - !i)); Obj.repr (!i)]];
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let n = ref (List.length (!pairs)) in
  let m = ref (0) in
  (try while (!m < !n) do
    try
  let j = ref (0) in
  (try while (!j < (!n - 1)) do
    try
  if (List.nth (List.nth (!pairs) (!j)) (0) > List.nth (List.nth (!pairs) ((!j + 1))) (0)) then (
  let tmp = ref (List.nth (!pairs) (!j)) in
  pairs := (List.mapi (fun __i __x -> if __i = !j then List.nth (!pairs) ((!j + 1)) else __x) (!pairs));
  pairs := (List.mapi (fun __i __x -> if __i = (!j + 1) then !tmp else __x) (!pairs));
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  m := (!m + 1);
    with Continue -> ()
  done with Break -> ());
  let res = ref ([]) in
  i := 0;
  (try while (!i < !n) do
    try
  res := List.append !res [List.nth (List.nth (!pairs) (!i)) (1)];
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !res; raise Return
  with Return -> !__ret)

let rec encrypt polybius key plainText =
  let __ret = ref "" in
  (try
  let labels = ref ([]) in
  let li = ref (0) in
  (try while (!li < String.length (!adfgvx)) do
    try
  labels := List.append !labels [String.sub (!adfgvx) !li ((!li + 1) - !li)];
  li := (!li + 1);
    with Continue -> ()
  done with Break -> ());
  let temp = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (plainText)) do
    try
  let r = ref (0) in
  (try while (!r < 6) do
    try
  let c = ref (0) in
  (try while (!c < 6) do
    try
  if (String.sub (List.nth (polybius) (!r)) !c ((!c + 1) - !c) = String.sub (plainText) !i ((!i + 1) - !i)) then (
  temp := ((!temp ^ String.concat "" (List.of_seq (Seq.take ((!r + 1) - !r) (Seq.drop !r (List.to_seq !labels))))) ^ String.concat "" (List.of_seq (Seq.take ((!c + 1) - !c) (Seq.drop !c (List.to_seq !labels)))));
  );
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let colLen = ref ((String.length (!temp) / String.length (key))) in
  if ((String.length (!temp) mod String.length (key)) > 0) then (
  colLen := (!colLen + 1);
  );
  let table = ref ([]) in
  let rIdx = ref (0) in
  (try while (!rIdx < !colLen) do
    try
  let row = ref ([]) in
  let j = ref (0) in
  (try while (!j < String.length (key)) do
    try
  row := List.append !row [""];
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  table := List.append !table [!row];
  rIdx := (!rIdx + 1);
    with Continue -> ()
  done with Break -> ());
  let idx = ref (0) in
  (try while (!idx < String.length (!temp)) do
    try
  let row = (!idx / String.length (key)) in
  let col = (!idx mod String.length (key)) in
  table := (List.mapi (fun __i __x -> if __i = row then (List.mapi (fun __i __x -> if __i = col then String.sub (!temp) !idx ((!idx + 1) - !idx) else __x) (List.nth (!table) (row))) else __x) (!table));
  idx := (!idx + 1);
    with Continue -> ()
  done with Break -> ());
  let order = ref (orderKey (key)) in
  let cols = ref ([]) in
  let ci = ref (0) in
  (try while (!ci < String.length (key)) do
    try
  let colStr = ref ("") in
  let ri = ref (0) in
  (try while (!ri < !colLen) do
    try
  colStr := (!colStr ^ List.nth (List.nth (!table) (!ri)) (List.nth (!order) (!ci)));
  ri := (!ri + 1);
    with Continue -> ()
  done with Break -> ());
  cols := List.append !cols [!colStr];
  ci := (!ci + 1);
    with Continue -> ()
  done with Break -> ());
  let result = ref ("") in
  ci := 0;
  (try while (!ci < List.length (!cols)) do
    try
  result := (!result ^ List.nth (!cols) (!ci));
  if (!ci < (List.length (!cols) - 1)) then (
  result := (!result ^ " ");
  );
  ci := (!ci + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !result; raise Return
  with Return -> !__ret)

let rec indexOf s ch =
  let __ret = ref 0 in
  (try
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if (String.sub (s) !i ((!i + 1) - !i) = ch) then (
  __ret := !i; raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := -(1); raise Return
  with Return -> !__ret)

let rec decrypt polybius key cipherText =
  let __ret = ref "" in
  (try
  let colStrs = ref ([]) in
  let start = ref (0) in
  let i = ref (0) in
  (try while (!i <= String.length (cipherText)) do
    try
  if ((!i = String.length (cipherText)) || (String.make 1 (String.get (cipherText) !i) = " ")) then (
  colStrs := List.append !colStrs [String.sub (cipherText) !start (!i - !start)];
  start := (!i + 1);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let maxColLen = ref (0) in
  i := 0;
  (try while (!i < List.length (!colStrs)) do
    try
  if (String.length (List.nth (!colStrs) (!i)) > !maxColLen) then (
  maxColLen := String.length (List.nth (!colStrs) (!i));
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let cols = ref ([]) in
  i := 0;
  (try while (!i < List.length (!colStrs)) do
    try
  let s = ref (List.nth (!colStrs) (!i)) in
  let ls = ref ([]) in
  let j = ref (0) in
  (try while (!j < String.length (!s)) do
    try
  ls := List.append !ls [String.sub (!s) !j ((!j + 1) - !j)];
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  if (String.length (!s) < !maxColLen) then (
  let pad = ref ([]) in
  let k = ref (0) in
  (try while (!k < !maxColLen) do
    try
  if (!k < List.length (!ls)) then (
  pad := List.append !pad [List.nth (!ls) (!k)];
  ) else (
  pad := List.append !pad [""];
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  cols := List.append !cols [!pad];
  ) else (
  cols := List.append !cols [!ls];
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let table = ref ([]) in
  let r = ref (0) in
  (try while (!r < !maxColLen) do
    try
  let row = ref ([]) in
  let c = ref (0) in
  (try while (!c < String.length (key)) do
    try
  row := List.append !row [""];
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  table := List.append !table [!row];
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  let order = ref (orderKey (key)) in
  r := 0;
  (try while (!r < !maxColLen) do
    try
  let c = ref (0) in
  (try while (!c < String.length (key)) do
    try
  table := (List.mapi (fun __i __x -> if __i = !r then (List.mapi (fun __i __x -> if __i = List.nth (!order) (!c) then List.nth (List.nth (!cols) (!c)) (!r) else __x) (List.nth (!table) (!r))) else __x) (!table));
  c := (!c + 1);
    with Continue -> ()
  done with Break -> ());
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  let temp = ref ("") in
  r := 0;
  (try while (!r < List.length (!table)) do
    try
  let j = ref (0) in
  (try while (!j < List.length (List.nth (!table) (!r))) do
    try
  temp := (!temp ^ List.nth (List.nth (!table) (!r)) (!j));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  r := (!r + 1);
    with Continue -> ()
  done with Break -> ());
  let plainText = ref ("") in
  let idx = ref (0) in
  (try while (!idx < String.length (!temp)) do
    try
  let rIdx = indexOf (!adfgvx) (String.sub (!temp) !idx ((!idx + 1) - !idx)) in
  let cIdx = indexOf (!adfgvx) (String.sub (!temp) (!idx + 1) ((!idx + 2) - (!idx + 1))) in
  plainText := (!plainText ^ String.make 1 (String.get (List.nth (polybius) (rIdx)) cIdx));
  idx := (!idx + 2);
    with Continue -> ()
  done with Break -> ());
  __ret := !plainText; raise Return
  with Return -> !__ret)

let rec main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let plainText = "ATTACKAT1200AM" in
  let polybius = ref (createPolybius ()) in
  let key = createKey (9) in
  print_endline (("\nPlaintext : " ^ plainText));
  let cipherText = encrypt (!polybius) (key) (plainText) in
  print_endline (("\nEncrypted : " ^ cipherText));
  let plainText2 = decrypt (!polybius) (key) (cipherText) in
  print_endline (("\nDecrypted : " ^ plainText2));
    !__ret
  with Return -> !__ret)

let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
