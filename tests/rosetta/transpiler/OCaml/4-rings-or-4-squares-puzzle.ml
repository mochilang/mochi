(* Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:42 +0700 *)

exception Break
exception Continue

exception Return

let rec validComb a b c d e f g =
  let __ret = ref false in
  let a = ref a in
  let b = ref b in
  let c = ref c in
  let d = ref d in
  let e = ref e in
  let f = ref f in
  let g = ref g in
  (try
  let square1 = (!a + !b) in
  let square2 = ((!b + !c) + !d) in
  let square3 = ((!d + !e) + !f) in
  let square4 = (!f + !g) in
  __ret := (((square1 = square2) && (square2 = square3)) && (square3 = square4)); raise Return;
  __ret := (((square1 = square2) && (square2 = square3)) && (square3 = square4));
    !__ret
  with Return -> !__ret)

let rec isUnique a b c d e f g =
  let __ret = ref false in
  let a = ref a in
  let b = ref b in
  let c = ref c in
  let d = ref d in
  let e = ref e in
  let f = ref f in
  let g = ref g in
  (try
  let nums = ref ([!a; !b; !c; !d; !e; !f; !g]) in
  let i = ref (0) in
  (try while (!i < List.length !nums) do
    try
  let j = ref ((!i + 1)) in
  (try while (!j < List.length !nums) do
    try
  if (List.nth (!nums) (!i) = List.nth (!nums) (!j)) then (
  __ret := false; raise Return;
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := true; raise Return;
  __ret := true;
    !__ret
  with Return -> !__ret)

let rec getCombs low high unique =
  let __ret = ref [] in
  let low = ref low in
  let high = ref high in
  let unique = ref unique in
  (try
  let valid = ref ([]) in
  let count = ref (0) in
  (try for b = !low to ((!high + 1) - 1) do
    try
  (try for c = !low to ((!high + 1) - 1) do
    try
  (try for d = !low to ((!high + 1) - 1) do
    try
  let s = ((b + c) + d) in
  (try for e = !low to ((!high + 1) - 1) do
    try
  (try for f = !low to ((!high + 1) - 1) do
    try
  let a = (s - b) in
  let g = (s - f) in
  if ((a < !low) || (a > !high)) then (
  raise Continue;
  );
  if ((g < !low) || (g > !high)) then (
  raise Continue;
  );
  if (((d + e) + f) <> s) then (
  raise Continue;
  );
  if ((f + g) <> s) then (
  raise Continue;
  );
  if (not (!unique) || isUnique (a) (b) (c) (d) (e) (f) (g)) then (
  valid := List.append !valid [[a; b; c; d; e; f; g]];
  count := (!count + 1);
  );
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
  __ret := [("count", Obj.repr !count); ("list", Obj.repr !valid)]; raise Return;
  __ret := [("count", Obj.repr !count); ("list", Obj.repr !valid)];
    !__ret
  with Return -> !__ret)

let r1 = getCombs (1) (7) (true)
let r2 = getCombs (3) (9) (true)
let r3 = getCombs (0) (9) (false)
let () =
  print_endline (((string_of_int ((Obj.obj (List.assoc ("count") r1) : int))) ^ " unique solutions in 1 to 7"));
  print_endline (string_of_int (Obj.obj (List.assoc ("list") r1) : int));
  print_endline (((string_of_int ((Obj.obj (List.assoc ("count") r2) : int))) ^ " unique solutions in 3 to 9"));
  print_endline (string_of_int (Obj.obj (List.assoc ("list") r2) : int));
  print_endline (((string_of_int ((Obj.obj (List.assoc ("count") r3) : int))) ^ " non-unique solutions in 0 to 9"));
