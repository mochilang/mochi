(* Generated by Mochi transpiler v0.10.57 on 2025-08-04 16:02 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())


let _len v =
  let r = Obj.repr v in
  if Obj.is_int r then 0 else
    match Obj.tag r with
    | 252 -> String.length (Obj.magic v : string)
    | _ -> List.length (Obj.magic v)

exception Break
exception Continue

exception Return

let rec randInt seed n =
  let __ret = ref ([] : (int) list) in
  (try
  let seed = (Obj.magic seed : int) in
  let n = (Obj.magic n : int) in
  let next = (((seed * 1664525) + 1013904223) mod 2147483647) in
  __ret := (Obj.magic ([next; (next mod n)]) : int list); raise Return
  with Return -> !__ret)

and newBoard n seed =
  let __ret = ref [] in
  (try
  let n = (Obj.magic n : int) in
  let seed = (Obj.magic seed : int) in
  let board = ref (([] : (int list) list)) in
  let s = ref (seed) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < n) do
    try
  let r = ref (randInt (Obj.repr (!s)) (Obj.repr (2))) in
  s := List.nth (!r) (0);
  row := (List.append (!row) [(Obj.magic (List.nth (!r) (1)) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  board := (List.append (!board) [(Obj.magic (!row) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([Obj.repr (!board); Obj.repr (!s)]) : Obj.t list); raise Return
  with Return -> !__ret)

and copyBoard b =
  let __ret = ref ([] : (int list) list) in
  (try
  let nb = ref (([] : (int list) list)) in
  let i = ref (0) in
  (try while (!i < List.length (b)) do
    try
  let row = ref (([] : (int) list)) in
  let j = ref (0) in
  (try while (!j < List.length (List.nth (b) (!i))) do
    try
  row := (List.append (!row) [(Obj.magic (List.nth (List.nth (b) (!i)) (!j)) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  nb := (List.append (!nb) [(Obj.magic (!row) : int list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!nb) : int list list); raise Return
  with Return -> !__ret)

and flipRow b r =
  let __ret = ref ([] : (int list) list) in
  (try
  let r = (Obj.magic r : int) in
  let j = ref (0) in
  (try while (!j < List.length (List.nth (!b) (r))) do
    try
  b := (List.mapi (fun __i __x -> if __i = r then (List.mapi (fun __i __x -> if __i = !j then (1 - List.nth (List.nth (!b) (r)) (!j)) else __x) (List.nth (!b) (r))) else __x) (!b));
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!b) : int list list); raise Return
  with Return -> !__ret)

and flipCol b c =
  let __ret = ref ([] : (int list) list) in
  (try
  let c = (Obj.magic c : int) in
  let i = ref (0) in
  (try while (!i < List.length (!b)) do
    try
  b := (List.mapi (fun __i __x -> if __i = !i then (List.mapi (fun __i __x -> if __i = c then (1 - List.nth (List.nth (!b) (!i)) (c)) else __x) (List.nth (!b) (!i))) else __x) (!b));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!b) : int list list); raise Return
  with Return -> !__ret)

and boardsEqual a b =
  let __ret = ref false in
  (try
  let i = ref (0) in
  (try while (!i < List.length (a)) do
    try
  let j = ref (0) in
  (try while (!j < List.length (List.nth (a) (!i))) do
    try
  if (List.nth (List.nth (a) (!i)) (!j) <> List.nth (List.nth (b) (!i)) (!j)) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)

and shuffleBoard b seed =
  let __ret = ref [] in
  (try
  let seed = (Obj.magic seed : int) in
  let s = ref (seed) in
  let n = ref (List.length (!b)) in
  let k = ref (0) in
  (try while (!k < (2 * !n)) do
    try
  let r = ref (randInt (Obj.repr (!s)) (Obj.repr (!n))) in
  s := List.nth (!r) (0);
  let idx = List.nth (!r) (1) in
  if ((!k mod 2) = 0) then (
  b := flipRow (b) (Obj.repr (idx));
  ) else (
  b := flipCol (b) (Obj.repr (idx));
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([Obj.repr (!b); Obj.repr (!s)]) : Obj.t list); raise Return
  with Return -> !__ret)

and solve board target =
  let __ret = ref ([] : (string * int list) list) in
  (try
  let n = List.length (board) in
  let row = ref (([] : (int) list)) in
  let col = ref (([] : (int) list)) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  let diff = if (List.nth (List.nth (board) (!i)) (0) <> List.nth (List.nth (target) (!i)) (0)) then 1 else 0 in
  row := (List.append (!row) [(Obj.magic (diff) : int)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let j = ref (0) in
  (try while (!j < n) do
    try
  let diff = if (List.nth (List.nth (board) (0)) (!j) <> List.nth (List.nth (target) (0)) (!j)) then 1 else 0 in
  let val_ = ((diff + List.nth (!row) (0)) mod 2) in
  col := (List.append (!col) [(Obj.magic (val_) : int)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("row", !row); ("col", !col)]) : (string * int list) list); raise Return
  with Return -> !__ret)

and applySolution b sol =
  let __ret = ref [] in
  (try
  let board = ref (b) in
  let moves = ref (0) in
  let i = ref (0) in
  (try while (!i < _len (List.assoc ("row") (sol))) do
    try
  if (List.nth (List.assoc ("row") (sol)) (!i) = 1) then (
  board := flipRow (board) (Obj.repr (!i));
  moves := (!moves + 1);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let j = ref (0) in
  (try while (!j < _len (List.assoc ("col") (sol))) do
    try
  if (List.nth (List.assoc ("col") (sol)) (!j) = 1) then (
  board := flipCol (board) (Obj.repr (!j));
  moves := (!moves + 1);
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([Obj.repr (!board); Obj.repr (!moves)]) : Obj.t list); raise Return
  with Return -> !__ret)

and printBoard b =
  let __ret = ref (Obj.magic 0) in
  (try
  let i = ref (0) in
  (try while (!i < List.length (b)) do
    try
  let line = ref ("") in
  let j = ref (0) in
  (try while (!j < List.length (List.nth (b) (!i))) do
    try
  line := (!line ^ (string_of_int (List.nth (List.nth (b) (!i)) (!j))));
  if (!j < (List.length (List.nth (b) (!i)) - 1)) then (
  line := (!line ^ " ");
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline (__show !line);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let n = 3 in
  let seed = ref (1) in
  let res = ref (newBoard (Obj.repr (n)) (Obj.repr (!seed))) in
  let target = ref ((Obj.magic List.nth (!res) (0) : int list list)) in
  seed := (Obj.magic List.nth (!res) (1) : int);
  let board = ref (copyBoard (!target)) in
  (try while true do
    try
  let sres = ref (shuffleBoard (ref (copyBoard (!board))) (Obj.repr (!seed))) in
  board := (Obj.magic List.nth (!sres) (0) : int list list);
  seed := (Obj.magic List.nth (!sres) (1) : int);
  if not (boardsEqual (!board) (!target)) then (
  raise Break;
  );
    with Continue -> ()
  done with Break -> ());
  print_endline ("Target:");
  ignore (printBoard (!target));
  print_endline ("Board:");
  ignore (printBoard (!board));
  let sol = ref (solve (!board) (!target)) in
  let ares = ref (applySolution (!board) ((Obj.magic !sol : (string * int list) list))) in
  board := (Obj.magic List.nth (!ares) (0) : int list list);
  let moves = (Obj.magic List.nth (!ares) (1) : int) in
  print_endline ("Solved:");
  ignore (printBoard (!board));
  print_endline (("Moves: " ^ (string_of_int (moves))));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()