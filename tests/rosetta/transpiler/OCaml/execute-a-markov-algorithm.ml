(* Generated by Mochi transpiler v0.10.56 on 2025-08-04 08:07 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0

open Str


let _len v =
  let r = Obj.repr v in
  if Obj.is_int r then 0 else
    match Obj.tag r with
    | 252 -> String.length (Obj.magic v : string)
    | _ -> List.length (Obj.magic v)


let _split s sep =
  let c = if String.length sep = 0 then ' ' else sep.[0] in
  String.split_on_char c s

exception Break
exception Continue

exception Return

let rec split s sep =
  let __ret = ref ([] : string list) in
  (try
  let parts = ref (([] : string list)) in
  let cur = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if (((String.length (sep) > 0) && ((!i + String.length (sep)) <= String.length (s))) && (String.sub s (!i) ((!i + String.length (sep)) - !i) = sep)) then (
  parts := (List.append (!parts) [(Obj.magic (!cur) : string)]);
  cur := "";
  i := (!i + String.length (sep));
  ) else (
  cur := (!cur ^ String.sub s (!i) ((!i + 1) - !i));
  i := (!i + 1);
  );
    with Continue -> ()
  done with Break -> ());
  parts := (List.append (!parts) [(Obj.magic (!cur) : string)]);
  __ret := (Obj.magic (!parts) : string list); raise Return
  with Return -> !__ret)

and trimSpace s =
  let __ret = ref "" in
  (try
  let start = ref (0) in
  (try while ((!start < String.length (s)) && ((String.sub (s) !start ((!start + 1) - !start) = " ") || (String.sub (s) !start ((!start + 1) - !start) = "\t"))) do
    try
  start := (!start + 1);
    with Continue -> ()
  done with Break -> ());
  let end_ = ref (String.length (s)) in
  (try while ((!end_ > !start) && ((String.sub (s) (!end_ - 1) (!end_ - (!end_ - 1)) = " ") || (String.sub (s) (!end_ - 1) (!end_ - (!end_ - 1)) = "\t"))) do
    try
  end_ := (!end_ - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (String.sub (s) !start (!end_ - !start)) : string); raise Return
  with Return -> !__ret)

and indexOfSub s sub =
  let __ret = ref 0 in
  (try
  if (String.length (sub) = 0) then (
  __ret := (Obj.magic (0) : int); raise Return
  );
  let i = ref (0) in
  (try while ((!i + String.length (sub)) <= String.length (s)) do
    try
  if (String.sub s (!i) ((!i + String.length (sub)) - !i) = sub) then (
  __ret := (Obj.magic (!i) : int); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ((0 - 1)) : int); raise Return
  with Return -> !__ret)

and parseRules rs =
  let __ret = ref [] in
  (try
  let rules = ref (([] : (string * Obj.t) list list)) in
  (try List.iter (fun line ->
    try
  let ln = ref (line) in
  let hash = indexOfSub (!ln) ("#") in
  if (hash >= 0) then (
  ln := String.sub (!ln) 0 (hash - 0);
  );
  ln := trimSpace (!ln);
  if (String.length (!ln) = 0) then (
  raise Continue;
  );
  let arrow = ref ((0 - 1)) in
  let j = ref (0) in
  (try while ((!j + 2) <= String.length (!ln)) do
    try
  if (String.sub !ln (!j) ((!j + 2) - !j) = "->") then (
  let pre = ref (((!j > 0) && ((String.sub (!ln) (!j - 1) (!j - (!j - 1)) = " ") || (String.sub (!ln) (!j - 1) (!j - (!j - 1)) = "\t")))) in
  let post = ref ((((!j + 2) < String.length (!ln)) && ((String.sub (!ln) (!j + 2) ((!j + 3) - (!j + 2)) = " ") || (String.sub (!ln) (!j + 2) ((!j + 3) - (!j + 2)) = "\t")))) in
  if (!pre && !post) then (
  arrow := !j;
  raise Break;
  );
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  if (!arrow < 0) then (
  arrow := indexOfSub (!ln) ("->");
  );
  if (!arrow < 0) then (
  __ret := (Obj.magic ([("ok", false)]) : (string * Obj.t) list); raise Return
  );
  let pat = ref (trimSpace (String.sub (!ln) 0 (!arrow - 0))) in
  let rest = ref (trimSpace (String.sub (!ln) (!arrow + 2) (String.length (!ln) - (!arrow + 2)))) in
  let term = ref (false) in
  if ((String.length (!rest) > 0) && (String.sub (!rest) 0 (1 - 0) = ".")) then (
  term := true;
  rest := String.sub (!rest) 1 (String.length (!rest) - 1);
  );
  let rep = ref (!rest) in
  rules := (List.append (!rules) [(Obj.magic ([("pat", Obj.repr (!pat)); ("rep", Obj.repr (!rep)); ("term", Obj.repr (!term))]) : (string * Obj.t) list)]);
    with Continue -> ()) (_split (rs) ("\n")) with Break -> ());
  __ret := (Obj.magic ([("ok", Obj.repr (true)); ("rules", Obj.repr (!rules))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and runRules rules s =
  let __ret = ref "" in
  (try
  let changed = ref (true) in
  (try while !changed do
    try
  changed := false;
  let i = ref (0) in
  (try while (!i < List.length (rules)) do
    try
  let r = ref (List.nth (rules) (!i)) in
  let pat = (Obj.obj (List.assoc ("pat") (!r) : Obj.t)) in
  let rep = (Obj.obj (List.assoc ("rep") (!r) : Obj.t)) in
  let term = (Obj.obj (List.assoc ("term") (!r) : Obj.t)) in
  let idx = indexOfSub (!s) (pat) in
  if (idx >= 0) then (
  s := ((String.sub (!s) 0 (idx - 0) ^ __show (rep)) ^ String.sub (!s) (idx + _len (pat)) (String.length (!s) - (idx + _len (pat))));
  changed := true;
  if term then (
  __ret := (Obj.magic (!s) : string); raise Return
  );
  raise Break;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and interpret ruleset input =
  let __ret = ref [] in
  (try
  let p = ref (parseRules (ruleset)) in
  if not ((Obj.obj (List.assoc ("ok") (!p) : Obj.t))) then (
  __ret := (Obj.magic ([("ok", Obj.repr (false)); ("out", Obj.repr (""))]) : (string * Obj.t) list); raise Return
  );
  let out = runRules ((Obj.obj (List.assoc ("rules") (!p) : Obj.t))) (ref (input)) in
  __ret := (Obj.magic ([("ok", Obj.repr (true)); ("out", Obj.repr (out))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)


let testSet = ref ([[("ruleSet", "# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"); ("sample", "I bought a B of As from T S."); ("output", "I bought a bag of apples from my brother.")]; [("ruleSet", "# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"); ("sample", "I bought a B of As from T S."); ("output", "I bought a bag of apples from T shop.")]; [("ruleSet", "# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"); ("sample", "I bought a B of As W my Bgage from T S."); ("output", "I bought a bag of apples with my money from T shop.")]; [("ruleSet", "### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n"); ("sample", "_1111*11111_"); ("output", "11111111111111111111")]; [("ruleSet", "# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n"); ("sample", "000000A000000"); ("output", "00011H1111000")]])
let rec main () =
  let __ret = ref (Obj.magic 0) in
  (try
  print_endline ((("validating " ^ (string_of_int (List.length (!testSet)))) ^ " test cases"));
  let failures = ref (false) in
  let i = ref (0) in
  (try while (!i < List.length (!testSet)) do
    try
  let tc = ref (List.nth (!testSet) (!i)) in
  let res = ref (interpret ((try List.assoc ("ruleSet") (!tc) with Not_found -> "")) ((try List.assoc ("sample") (!tc) with Not_found -> ""))) in
  if not ((Obj.obj (List.assoc ("ok") (!res) : Obj.t))) then (
  print_endline ((("test " ^ (string_of_int ((!i + 1)))) ^ " invalid ruleset"));
  failures := true;
  ) else (
  if ((Obj.obj (List.assoc ("out") (!res) : Obj.t)) <> (try List.assoc ("output") (!tc) with Not_found -> "")) then (
  print_endline (((((("test " ^ (string_of_int ((!i + 1)))) ^ ": got ") ^ __show ((Obj.obj (List.assoc ("out") (!res) : Obj.t)))) ^ ", want ") ^ (try List.assoc ("output") (!tc) with Not_found -> "")));
  failures := true;
  );
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if not (!failures) then (
  print_endline ("no failures");
  );
    !__ret
  with Return -> !__ret)


let () =
  ignore (main ());
  ()