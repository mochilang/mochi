(* Generated by Mochi transpiler v0.10.52 on 2025-08-02 00:57 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0

open Str


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())


let _split s sep =
  let c = if String.length sep = 0 then ' ' else sep.[0] in
  String.split_on_char c s

exception Break
exception Continue

exception Return

let rec digits n =
  let __ret = ref ([] : int list) in
  (try
  let n = (Obj.magic n : int) in
  if (n = 0) then (
  __ret := (Obj.magic ([0]) : int list); raise Return
  );
  let rev = ref (([] : int list)) in
  let x = ref (n) in
  (try while (!x > 0) do
    try
  rev := (List.append (!rev) [(Obj.magic ((!x mod 10)) : int)]);
  x := (!x / 10);
    with Continue -> ()
  done with Break -> ());
  let out = ref (([] : int list)) in
  let i = ref ((List.length (!rev) - 1)) in
  (try while (!i >= 0) do
    try
  out := (List.append (!out) [(Obj.magic (List.nth (!rev) (!i)) : int)]);
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!out) : int list); raise Return
  with Return -> !__ret)

and commatize n =
  let __ret = ref "" in
  (try
  let n = (Obj.magic n : int) in
  let s = ref ((string_of_int (n))) in
  let out = ref ("") in
  let i = ref (String.length (!s)) in
  (try while (!i > 3) do
    try
  out := (("," ^ String.sub (!s) (!i - 3) (!i - (!i - 3))) ^ !out);
  i := (!i - 3);
    with Continue -> ()
  done with Break -> ());
  out := (String.sub (!s) 0 (!i - 0) ^ !out);
  __ret := (Obj.magic (!out) : string); raise Return
  with Return -> !__ret)

and isPrime n =
  let __ret = ref false in
  (try
  let n = (Obj.magic n : int) in
  if (n < 2) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  if ((n mod 2) = 0) then (
  __ret := (Obj.magic ((n = 2)) : bool); raise Return
  );
  if ((n mod 3) = 0) then (
  __ret := (Obj.magic ((n = 3)) : bool); raise Return
  );
  let d = ref (5) in
  (try while ((!d * !d) <= n) do
    try
  if ((n mod !d) = 0) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  d := (!d + 2);
  if ((n mod !d) = 0) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  d := (!d + 4);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)

and split s sep =
  let __ret = ref ([] : string list) in
  (try
  let parts = ref (([] : string list)) in
  let cur = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if (((!i + String.length (sep)) <= String.length (s)) && (String.sub (s) !i ((!i + String.length (sep)) - !i) = sep)) then (
  parts := (List.append (!parts) [(Obj.magic (!cur) : string)]);
  cur := "";
  i := (!i + String.length (sep));
  ) else (
  cur := (!cur ^ String.sub (s) !i ((!i + 1) - !i));
  i := (!i + 1);
  );
    with Continue -> ()
  done with Break -> ());
  parts := (List.append (!parts) [(Obj.magic (!cur) : string)]);
  __ret := (Obj.magic (!parts) : string list); raise Return
  with Return -> !__ret)

and parseIntStr str =
  let __ret = ref 0 in
  (try
  let i = ref (0) in
  let neg = ref (false) in
  if ((String.length (str) > 0) && (String.sub (str) 0 (1 - 0) = "-")) then (
  neg := true;
  i := 1;
  );
  let n = ref (0) in
  let digits = ref ([("0", 0); ("1", 1); ("2", 2); ("3", 3); ("4", 4); ("5", 5); ("6", 6); ("7", 7); ("8", 8); ("9", 9)]) in
  (try while (!i < String.length (str)) do
    try
  n := ((!n * 10) + (try List.assoc (String.sub (str) !i ((!i + 1) - !i)) !digits with Not_found -> (Obj.magic 0)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if !neg then (
  n := -(!n);
  );
  __ret := (Obj.magic (!n) : int); raise Return
  with Return -> !__ret)

and reverseStr s =
  let __ret = ref "" in
  (try
  let out = ref ("") in
  let i = ref ((String.length (s) - 1)) in
  (try while (!i >= 0) do
    try
  out := (!out ^ String.sub (s) !i ((!i + 1) - !i));
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!out) : string); raise Return
  with Return -> !__ret)

and pad s w =
  let __ret = ref "" in
  (try
  let w = (Obj.magic w : int) in
  let out = ref (s) in
  (try while (String.length (!out) < w) do
    try
  out := (" " ^ !out);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!out) : string); raise Return
  with Return -> !__ret)

and findFirst list =
  let __ret = ref ([] : int list) in
  (try
  let i = ref (0) in
  (try while (!i < List.length (list)) do
    try
  if (List.nth (list) (!i) > 10000000) then (
  __ret := (Obj.magic ([List.nth (list) (!i); !i]) : int list); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([-(1); -(1)]) : int list); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let ranges = ref ([[0; 0]; [101; 909]; [11011; 99099]; [1110111; 9990999]; [111101111; 119101111]]) in
  let cyclops = ref (([] : int list)) in
  (try List.iter (fun r ->
    try
  let start = List.nth (r) (0) in
  let end_ = List.nth (r) (1) in
  let numDigits = String.length ((string_of_int (start))) in
  let center = (numDigits / 2) in
  let i = ref (start) in
  (try while (!i <= end_) do
    try
  let ds = ref (digits (Obj.repr (!i))) in
  if (List.nth (!ds) (center) = 0) then (
  let count = ref (0) in
  (try List.iter (fun d ->
    try
  if (d = 0) then (
  count := (!count + 1);
  );
    with Continue -> ()) (!ds) with Break -> ());
  if (!count = 1) then (
  cyclops := (List.append (!cyclops) [(Obj.magic (!i) : int)]);
  );
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    with Continue -> ()) (!ranges) with Break -> ());
  print_endline ("The first 50 cyclops numbers are:");
  let idx = ref (0) in
  (try while (!idx < 50) do
    try
  print_endline ((pad (commatize (Obj.repr (List.nth (!cyclops) (!idx)))) (Obj.repr (6)) ^ " "));
  idx := (!idx + 1);
  if ((!idx mod 10) = 0) then (
  print_endline ("\n");
  );
    with Continue -> ()
  done with Break -> ());
  let fi = ref (findFirst (!cyclops)) in
  print_endline (((("\nFirst such number > 10 million is " ^ commatize (Obj.repr (List.nth (!fi) (0)))) ^ " at zero-based index ") ^ commatize (Obj.repr (List.nth (!fi) (1)))));
  let primes = ref (([] : int list)) in
  (try List.iter (fun n ->
    try
  if isPrime (Obj.repr (n)) then (
  primes := (List.append (!primes) [(Obj.magic (n) : int)]);
  );
    with Continue -> ()) (!cyclops) with Break -> ());
  print_endline ("\n\nThe first 50 prime cyclops numbers are:");
  idx := 0;
  (try while (!idx < 50) do
    try
  print_endline ((pad (commatize (Obj.repr (List.nth (!primes) (!idx)))) (Obj.repr (6)) ^ " "));
  idx := (!idx + 1);
  if ((!idx mod 10) = 0) then (
  print_endline ("\n");
  );
    with Continue -> ()
  done with Break -> ());
  let fp = ref (findFirst (!primes)) in
  print_endline (((("\nFirst such number > 10 million is " ^ commatize (Obj.repr (List.nth (!fp) (0)))) ^ " at zero-based index ") ^ commatize (Obj.repr (List.nth (!fp) (1)))));
  let bpcyclops = ref (([] : int list)) in
  let ppcyclops = ref (([] : int list)) in
  (try List.iter (fun p ->
    try
  let ps = (string_of_int (p)) in
  let splitp = ref (_split (ps) ("0")) in
  let noMiddle = parseIntStr ((List.nth (!splitp) (0) ^ List.nth (!splitp) (1))) in
  if isPrime (Obj.repr (noMiddle)) then (
  bpcyclops := (List.append (!bpcyclops) [(Obj.magic (p) : int)]);
  );
  if (ps = reverseStr (ps)) then (
  ppcyclops := (List.append (!ppcyclops) [(Obj.magic (p) : int)]);
  );
    with Continue -> ()) (!primes) with Break -> ());
  print_endline ("\n\nThe first 50 blind prime cyclops numbers are:");
  idx := 0;
  (try while (!idx < 50) do
    try
  print_endline ((pad (commatize (Obj.repr (List.nth (!bpcyclops) (!idx)))) (Obj.repr (6)) ^ " "));
  idx := (!idx + 1);
  if ((!idx mod 10) = 0) then (
  print_endline ("\n");
  );
    with Continue -> ()
  done with Break -> ());
  let fb = ref (findFirst (!bpcyclops)) in
  print_endline (((("\nFirst such number > 10 million is " ^ commatize (Obj.repr (List.nth (!fb) (0)))) ^ " at zero-based index ") ^ commatize (Obj.repr (List.nth (!fb) (1)))));
  print_endline ("\n\nThe first 50 palindromic prime cyclops numbers are:");
  idx := 0;
  (try while (!idx < 50) do
    try
  print_endline ((pad (commatize (Obj.repr (List.nth (!ppcyclops) (!idx)))) (Obj.repr (9)) ^ " "));
  idx := (!idx + 1);
  if ((!idx mod 8) = 0) then (
  print_endline ("\n");
  );
    with Continue -> ()
  done with Break -> ());
  let fpp = ref (findFirst (!ppcyclops)) in
  print_endline (((("\n\nFirst such number > 10 million is " ^ commatize (Obj.repr (List.nth (!fpp) (0)))) ^ " at zero-based index ") ^ commatize (Obj.repr (List.nth (!fpp) (1)))));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()