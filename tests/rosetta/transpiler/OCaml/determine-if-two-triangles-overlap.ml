(* Generated by Mochi transpiler v0.10.52 on 2025-08-01 19:03 UTC *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec fmt1 f =
  let __ret = ref "" in
  (try
  let f = (Obj.magic f : float) in
  let s = ref ((Printf.sprintf "%.16g" (f))) in
  let idx = (try String.index (!s) '.' with Not_found -> -1) in
  if (idx < 0) then (
  s := (!s ^ ".0");
  ) else (
  let need = ref ((idx + 2)) in
  if (String.length (!s) > !need) then (
  s := String.sub (!s) 0 (!need - 0);
  ) else (
  (try while (String.length (!s) < !need) do
    try
  s := (!s ^ "0");
    with Continue -> ()
  done with Break -> ());
  );
  );
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and pointStr p =
  let __ret = ref "" in
  (try
  __ret := (Obj.magic ((((("(" ^ fmt1 (Obj.repr ((Obj.obj (List.assoc ("x") p) : float)))) ^ ", ") ^ fmt1 (Obj.repr ((Obj.obj (List.assoc ("y") p) : float)))) ^ ")")) : string); raise Return
  with Return -> !__ret)

and triangleStr t =
  let __ret = ref "" in
  (try
  __ret := (Obj.magic (((((("Triangle " ^ pointStr ((Obj.obj (List.assoc ("p1") t) : (string * Obj.t) list))) ^ ", ") ^ pointStr ((Obj.obj (List.assoc ("p2") t) : (string * Obj.t) list))) ^ ", ") ^ pointStr ((Obj.obj (List.assoc ("p3") t) : (string * Obj.t) list)))) : string); raise Return
  with Return -> !__ret)

and orient a b c =
  let __ret = ref 0.0 in
  (try
  __ret := (Obj.magic (((((Obj.obj (List.assoc ("x") b) : float) -. (Obj.obj (List.assoc ("x") a) : float)) *. ((Obj.obj (List.assoc ("y") c) : float) -. (Obj.obj (List.assoc ("y") a) : float))) -. (((Obj.obj (List.assoc ("y") b) : float) -. (Obj.obj (List.assoc ("y") a) : float)) *. ((Obj.obj (List.assoc ("x") c) : float) -. (Obj.obj (List.assoc ("x") a) : float))))) : float); raise Return
  with Return -> !__ret)

and pointInTri p t onBoundary =
  let __ret = ref false in
  (try
  let d1 = orient (p) ((Obj.obj (List.assoc ("p1") t) : (string * Obj.t) list)) ((Obj.obj (List.assoc ("p2") t) : (string * Obj.t) list)) in
  let d2 = orient (p) ((Obj.obj (List.assoc ("p2") t) : (string * Obj.t) list)) ((Obj.obj (List.assoc ("p3") t) : (string * Obj.t) list)) in
  let d3 = orient (p) ((Obj.obj (List.assoc ("p3") t) : (string * Obj.t) list)) ((Obj.obj (List.assoc ("p1") t) : (string * Obj.t) list)) in
  let hasNeg = ref ((((d1 < 0.0) || (d2 < 0.0)) || (d3 < 0.0))) in
  let hasPos = ref ((((d1 > 0.0) || (d2 > 0.0)) || (d3 > 0.0))) in
  if onBoundary then (
  __ret := (Obj.magic (not ((!hasNeg && !hasPos))) : bool); raise Return
  );
  __ret := (Obj.magic ((((not ((!hasNeg && !hasPos)) && (d1 <> 0.0)) && (d2 <> 0.0)) && (d3 <> 0.0))) : bool); raise Return
  with Return -> !__ret)

and edgeCheck a0 a1 bs onBoundary =
  let __ret = ref false in
  (try
  let d0 = orient (a0) (a1) (List.nth (bs) (0)) in
  let d1 = orient (a0) (a1) (List.nth (bs) (1)) in
  let d2 = orient (a0) (a1) (List.nth (bs) (2)) in
  if onBoundary then (
  __ret := (Obj.magic ((((d0 <= 0.0) && (d1 <= 0.0)) && (d2 <= 0.0))) : bool); raise Return
  );
  __ret := (Obj.magic ((((d0 < 0.0) && (d1 < 0.0)) && (d2 < 0.0))) : bool); raise Return
  with Return -> !__ret)

and triTri2D t1 t2 onBoundary =
  let __ret = ref false in
  (try
  let a = ref ([(Obj.obj (List.assoc ("p1") t1) : (string * Obj.t) list); (Obj.obj (List.assoc ("p2") t1) : (string * Obj.t) list); (Obj.obj (List.assoc ("p3") t1) : (string * Obj.t) list)]) in
  let b = ref ([(Obj.obj (List.assoc ("p1") t2) : (string * Obj.t) list); (Obj.obj (List.assoc ("p2") t2) : (string * Obj.t) list); (Obj.obj (List.assoc ("p3") t2) : (string * Obj.t) list)]) in
  let i = ref (0) in
  (try while (!i < 3) do
    try
  let j = ((!i + 1) mod 3) in
  if edgeCheck (List.nth (!a) (!i)) (List.nth (!a) (j)) (!b) (onBoundary) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  i := 0;
  (try while (!i < 3) do
    try
  let j = ((!i + 1) mod 3) in
  if edgeCheck (List.nth (!b) (!i)) (List.nth (!b) (j)) (!a) (onBoundary) then (
  __ret := (Obj.magic (false) : bool); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (true) : bool); raise Return
  with Return -> !__ret)

and iff cond a b =
  let __ret = ref "" in
  (try
  if cond then (
  __ret := (Obj.magic (a) : string); raise Return
  ) else (
  __ret := (Obj.magic (b) : string); raise Return
  );
    !__ret
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let t1 = ref ([("p1", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0))])); ("p2", Obj.repr ([("x", Obj.repr (5.0)); ("y", Obj.repr (0.0))])); ("p3", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (5.0))]))]) in
  let t2 = ref ([("p1", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0))])); ("p2", Obj.repr ([("x", Obj.repr (5.0)); ("y", Obj.repr (0.0))])); ("p3", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (6.0))]))]) in
  print_endline ((triangleStr (!t1) ^ " and"));
  print_endline (triangleStr (!t2));
  let overlapping = ref (triTri2D (!t1) (!t2) (true)) in
  print_endline (iff (!overlapping) ("overlap") ("do not overlap"));
  print_endline ("");
  t1 := [("p1", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0))])); ("p2", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (5.0))])); ("p3", Obj.repr ([("x", Obj.repr (5.0)); ("y", Obj.repr (0.0))]))];
  t2 := !t1;
  print_endline ((triangleStr (!t1) ^ " and"));
  print_endline (triangleStr (!t2));
  overlapping := triTri2D (!t1) (!t2) (true);
  print_endline (iff (!overlapping) ("overlap (reversed)") ("do not overlap"));
  print_endline ("");
  t1 := [("p1", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0))])); ("p2", Obj.repr ([("x", Obj.repr (5.0)); ("y", Obj.repr (0.0))])); ("p3", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (5.0))]))];
  t2 := [("p1", Obj.repr ([("x", Obj.repr ((-.(10.0)))); ("y", Obj.repr (0.0))])); ("p2", Obj.repr ([("x", Obj.repr ((-.(5.0)))); ("y", Obj.repr (0.0))])); ("p3", Obj.repr ([("x", Obj.repr ((-.(1.0)))); ("y", Obj.repr (6.0))]))];
  print_endline ((triangleStr (!t1) ^ " and"));
  print_endline (triangleStr (!t2));
  overlapping := triTri2D (!t1) (!t2) (true);
  print_endline (iff (!overlapping) ("overlap") ("do not overlap"));
  print_endline ("");
  t1 := (("p3", Obj.repr ([("x", Obj.repr (2.5)); ("y", Obj.repr (5.0))])) :: List.remove_assoc ("p3") (Obj.magic (!t1) : (string * Obj.t) list));
  t2 := [("p1", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (4.0))])); ("p2", Obj.repr ([("x", Obj.repr (2.5)); ("y", Obj.repr ((-.(1.0))))])); ("p3", Obj.repr ([("x", Obj.repr (5.0)); ("y", Obj.repr (4.0))]))];
  print_endline ((triangleStr (!t1) ^ " and"));
  print_endline (triangleStr (!t2));
  overlapping := triTri2D (!t1) (!t2) (true);
  print_endline (iff (!overlapping) ("overlap") ("do not overlap"));
  print_endline ("");
  t1 := [("p1", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0))])); ("p2", Obj.repr ([("x", Obj.repr (1.0)); ("y", Obj.repr (1.0))])); ("p3", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (2.0))]))];
  t2 := [("p1", Obj.repr ([("x", Obj.repr (2.0)); ("y", Obj.repr (1.0))])); ("p2", Obj.repr ([("x", Obj.repr (3.0)); ("y", Obj.repr (0.0))])); ("p3", Obj.repr ([("x", Obj.repr (3.0)); ("y", Obj.repr (2.0))]))];
  print_endline ((triangleStr (!t1) ^ " and"));
  print_endline (triangleStr (!t2));
  overlapping := triTri2D (!t1) (!t2) (true);
  print_endline (iff (!overlapping) ("overlap") ("do not overlap"));
  print_endline ("");
  t2 := [("p1", Obj.repr ([("x", Obj.repr (2.0)); ("y", Obj.repr (1.0))])); ("p2", Obj.repr ([("x", Obj.repr (3.0)); ("y", Obj.repr ((-.(2.0))))])); ("p3", Obj.repr ([("x", Obj.repr (3.0)); ("y", Obj.repr (4.0))]))];
  print_endline ((triangleStr (!t1) ^ " and"));
  print_endline (triangleStr (!t2));
  overlapping := triTri2D (!t1) (!t2) (true);
  print_endline (iff (!overlapping) ("overlap") ("do not overlap"));
  print_endline ("");
  t1 := [("p1", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0))])); ("p2", Obj.repr ([("x", Obj.repr (1.0)); ("y", Obj.repr (0.0))])); ("p3", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (1.0))]))];
  t2 := [("p1", Obj.repr ([("x", Obj.repr (1.0)); ("y", Obj.repr (0.0))])); ("p2", Obj.repr ([("x", Obj.repr (2.0)); ("y", Obj.repr (0.0))])); ("p3", Obj.repr ([("x", Obj.repr (1.0)); ("y", Obj.repr (1.1))]))];
  print_endline ((triangleStr (!t1) ^ " and"));
  print_endline (triangleStr (!t2));
  print_endline ("which have only a single corner in contact, if boundary points collide");
  overlapping := triTri2D (!t1) (!t2) (true);
  print_endline (iff (!overlapping) ("overlap") ("do not overlap"));
  print_endline ("");
  print_endline ((triangleStr (!t1) ^ " and"));
  print_endline (triangleStr (!t2));
  print_endline ("which have only a single corner in contact, if boundary points do not collide");
  overlapping := triTri2D (!t1) (!t2) (false);
  print_endline (iff (!overlapping) ("overlap") ("do not overlap"));
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()