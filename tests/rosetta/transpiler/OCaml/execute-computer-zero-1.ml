(* Generated by Mochi transpiler v0.10.56 on 2025-08-04 07:36 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0

open Str


let _split s sep =
  let c = if String.length sep = 0 then ' ' else sep.[0] in
  String.split_on_char c s

exception Break
exception Continue

exception Return

let rec trim s =
  let __ret = ref "" in
  (try
  let start = ref (0) in
  (try while ((!start < String.length (s)) && ((String.sub (s) !start ((!start + 1) - !start) = " ") || (String.sub (s) !start ((!start + 1) - !start) = "\t"))) do
    try
  start := (!start + 1);
    with Continue -> ()
  done with Break -> ());
  let end_ = ref (String.length (s)) in
  (try while ((!end_ > !start) && ((String.sub (s) (!end_ - 1) (!end_ - (!end_ - 1)) = " ") || (String.sub (s) (!end_ - 1) (!end_ - (!end_ - 1)) = "\t"))) do
    try
  end_ := (!end_ - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (String.sub s (!start) (!end_ - !start)) : string); raise Return
  with Return -> !__ret)

and split s sep =
  let __ret = ref ([] : string list) in
  (try
  let parts = ref (([] : string list)) in
  let cur = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if (((String.length (sep) > 0) && ((!i + String.length (sep)) <= String.length (s))) && (String.sub s (!i) ((!i + String.length (sep)) - !i) = sep)) then (
  parts := (List.append (!parts) [(Obj.magic (!cur) : string)]);
  cur := "";
  i := (!i + String.length (sep));
  ) else (
  cur := (!cur ^ String.sub s (!i) ((!i + 1) - !i));
  i := (!i + 1);
  );
    with Continue -> ()
  done with Break -> ());
  parts := (List.append (!parts) [(Obj.magic (!cur) : string)]);
  __ret := (Obj.magic (!parts) : string list); raise Return
  with Return -> !__ret)

and splitWS s =
  let __ret = ref ([] : string list) in
  (try
  let out = ref (([] : string list)) in
  let cur = ref ("") in
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  let ch = String.sub s (!i) ((!i + 1) - !i) in
  if ((ch = " ") || (ch = "\t")) then (
  if (String.length (!cur) > 0) then (
  out := (List.append (!out) [(Obj.magic (!cur) : string)]);
  cur := "";
  );
  ) else (
  cur := (!cur ^ ch);
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if (String.length (!cur) > 0) then (
  out := (List.append (!out) [(Obj.magic (!cur) : string)]);
  );
  __ret := (Obj.magic (!out) : string list); raise Return
  with Return -> !__ret)

and indexOf s ch =
  let __ret = ref 0 in
  (try
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if (String.sub s (!i) ((!i + 1) - !i) = ch) then (
  __ret := (Obj.magic (!i) : int); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (-(1)) : int); raise Return
  with Return -> !__ret)

and parseIntStr str =
  let __ret = ref 0 in
  (try
  let i = ref (0) in
  let neg = ref (false) in
  if ((String.length (str) > 0) && (String.sub (str) 0 (1 - 0) = "-")) then (
  neg := true;
  i := 1;
  );
  let n = ref (0) in
  let digits = ref ([("0", 0); ("1", 1); ("2", 2); ("3", 3); ("4", 4); ("5", 5); ("6", 6); ("7", 7); ("8", 8); ("9", 9)]) in
  (try while (!i < String.length (str)) do
    try
  n := ((!n * 10) + (try List.assoc (String.sub (str) !i ((!i + 1) - !i)) (!digits) with Not_found -> 0));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  if !neg then (
  n := -(!n);
  );
  __ret := (Obj.magic (!n) : int); raise Return
  with Return -> !__ret)

and parseAsm asm =
  let __ret = ref [] in
  (try
  let lines = ref (_split (asm) ("\n")) in
  let instrs = ref (([] : (string * Obj.t) list list)) in
  let labels = ref ([]) in
  let lineNum = ref (0) in
  let i = ref (0) in
  (try while (!i < List.length (!lines)) do
    try
  let line = ref (List.nth (!lines) (!i)) in
  if ((try String.index (!line) ';' with Not_found -> -1) <> -(1)) then (
  line := String.sub !line (0) ((try String.index (!line) ';' with Not_found -> -1) - 0);
  );
  line := trim (!line);
  let label = ref ("") in
  if ((try String.index (!line) ':' with Not_found -> -1) <> -(1)) then (
  let idx = (try String.index (!line) ':' with Not_found -> -1) in
  label := trim (String.sub !line (0) (idx - 0));
  line := trim (String.sub !line ((idx + 1)) (String.length (!line) - (idx + 1)));
  );
  let opcode = ref ("") in
  let arg = ref ("") in
  if (String.length (!line) > 0) then (
  let parts = ref (splitWS (!line)) in
  if (List.length (!parts) > 0) then (
  opcode := List.nth (!parts) (0);
  );
  if (List.length (!parts) > 1) then (
  arg := List.nth (!parts) (1);
  ) else (
  let ops = ref ([("NOP", 0); ("LDA", 1); ("STA", 2); ("ADD", 3); ("SUB", 4); ("BRZ", 5); ("JMP", 6); ("STP", 7)]) in
  if not ((List.mem_assoc !opcode !ops)) then (
  arg := !opcode;
  opcode := "";
  );
  );
  );
  if (!label <> "") then (
  labels := ((!label, !lineNum) :: List.remove_assoc (!label) !labels);
  );
  instrs := (List.append (!instrs) [(Obj.magic ([("Label", Obj.repr (!label)); ("Opcode", Obj.repr (!opcode)); ("Arg", Obj.repr (!arg))]) : (string * Obj.t) list)]);
  lineNum := (!lineNum + 1);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([("instructions", Obj.repr (!instrs)); ("labels", Obj.repr (!labels))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and compile p =
  let __ret = ref ([] : int list) in
  (try
  let instrs = ref ((Obj.magic (Obj.obj (List.assoc ("instructions") (p) : Obj.t)) : (string * Obj.t) list list)) in
  let labels = ref ((Obj.magic (Obj.obj (List.assoc ("labels") (p) : Obj.t)) : (string * int) list)) in
  let bytecode = ref (([] : int list)) in
  let i = ref (0) in
  let opcodes = ref ([("NOP", 0); ("LDA", 1); ("STA", 2); ("ADD", 3); ("SUB", 4); ("BRZ", 5); ("JMP", 6); ("STP", 7)]) in
  (try while (!i < List.length (!instrs)) do
    try
  let ins = List.nth (!instrs) (!i) in
  let arg = ref (0) in
  if ((Obj.obj (List.assoc ("Arg") (ins) : Obj.t)) <> "") then (
  if (List.mem_assoc (Obj.obj (List.assoc ("Arg") (ins) : Obj.t)) !labels) then (
  arg := (try List.assoc ((Obj.obj (List.assoc ("Arg") (ins) : Obj.t))) (!labels) with Not_found -> 0);
  ) else (
  arg := parseIntStr ((Obj.obj (List.assoc ("Arg") (ins) : Obj.t)));
  );
  );
  let code = ref (0) in
  if ((Obj.obj (List.assoc ("Opcode") (ins) : Obj.t)) <> "") then (
  code := (try List.assoc ((Obj.obj (List.assoc ("Opcode") (ins) : Obj.t))) (!opcodes) with Not_found -> 0);
  );
  bytecode := (List.append (!bytecode) [(Obj.magic (((!code * 32) + !arg)) : int)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  (try while (List.length (!bytecode) < 32) do
    try
  bytecode := (List.append (!bytecode) [(Obj.magic (0) : int)]);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!bytecode) : int list); raise Return
  with Return -> !__ret)

and floorMod a b =
  let __ret = ref 0 in
  (try
  let a = (Obj.magic a : int) in
  let b = (Obj.magic b : int) in
  let r = ref ((a mod b)) in
  if (!r < 0) then (
  r := (!r + b);
  );
  __ret := (Obj.magic (!r) : int); raise Return
  with Return -> !__ret)

and run bytecode =
  let __ret = ref 0 in
  (try
  let acc = ref (0) in
  let pc = ref (0) in
  let mem = ref (([] : int list)) in
  let i = ref (0) in
  (try while (!i < List.length (bytecode)) do
    try
  mem := (List.append (!mem) [(Obj.magic (List.nth (bytecode) (!i)) : int)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  (try while (!pc < 32) do
    try
  let op = (List.nth (!mem) (!pc) / 32) in
  let arg = (List.nth (!mem) (!pc) mod 32) in
  pc := (!pc + 1);
  if (op = 0) then (
  raise Continue;
  ) else (
  if (op = 1) then (
  acc := List.nth (!mem) (arg);
  ) else (
  if (op = 2) then (
  mem := (List.mapi (fun __i __x -> if __i = arg then !acc else __x) (!mem));
  ) else (
  if (op = 3) then (
  acc := floorMod (Obj.repr ((!acc + List.nth (!mem) (arg)))) (Obj.repr (256));
  ) else (
  if (op = 4) then (
  acc := floorMod (Obj.repr ((!acc - List.nth (!mem) (arg)))) (Obj.repr (256));
  ) else (
  if (op = 5) then (
  if (!acc = 0) then (
  pc := arg;
  );
  ) else (
  if (op = 6) then (
  pc := arg;
  ) else (
  if (op = 7) then (
  raise Break;
  ) else (
  raise Break;
  );
  );
  );
  );
  );
  );
  );
  );
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!acc) : int); raise Return
  with Return -> !__ret)

and execute asm =
  let __ret = ref 0 in
  (try
  let parsed = ref (parseAsm (asm)) in
  let bc = ref (compile (!parsed)) in
  __ret := (Obj.magic (run (!bc)) : int); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let examples = ref ([(((("LDA   x\n" ^ "ADD   y       ; accumulator = x + y\n") ^ "STP\n") ^ "x:            2\n") ^ "y:            2"); ((((((((((((("loop:   LDA   prodt\n" ^ "        ADD   x\n") ^ "        STA   prodt\n") ^ "        LDA   y\n") ^ "        SUB   one\n") ^ "        STA   y\n") ^ "        BRZ   done\n") ^ "        JMP   loop\n") ^ "done:   LDA   prodt   ; to display it\n") ^ "        STP\n") ^ "x:            8\n") ^ "y:            7\n") ^ "prodt:        0\n") ^ "one:          1"); ((((((((((((((((("loop:   LDA   n\n" ^ "        STA   temp\n") ^ "        ADD   m\n") ^ "        STA   n\n") ^ "        LDA   temp\n") ^ "        STA   m\n") ^ "        LDA   count\n") ^ "        SUB   one\n") ^ "        BRZ   done\n") ^ "        STA   count\n") ^ "        JMP   loop\n") ^ "done:   LDA   n       ; to display it\n") ^ "        STP\n") ^ "m:            1\n") ^ "n:            1\n") ^ "temp:         0\n") ^ "count:        8       ; valid range: 1-11\n") ^ "one:          1"); ((((((((((((((((((((((((((((((("start:  LDA   load\n" ^ "ADD   car     ; head of list\n") ^ "STA   ldcar\n") ^ "ADD   one\n") ^ "STA   ldcdr   ; next CONS cell\n") ^ "ldcar:  NOP\n") ^ "STA   value\n") ^ "ldcdr:  NOP\n") ^ "BRZ   done    ; 0 stands for NIL\n") ^ "STA   car\n") ^ "JMP   start\n") ^ "done:   LDA   value   ; CAR of last CONS\n") ^ "STP\n") ^ "load:   LDA   0\n") ^ "value:        0\n") ^ "car:          28\n") ^ "one:          1\n") ^ "                        ; order of CONS cells\n") ^ "                        ; in memory\n") ^ "                        ; does not matter\n") ^ "        6\n") ^ "        0       ; 0 stands for NIL\n") ^ "        2       ; (CADR ls)\n") ^ "        26      ; (CDDR ls) -- etc.\n") ^ "        5\n") ^ "        20\n") ^ "        3\n") ^ "        30\n") ^ "        1       ; value of (CAR ls)\n") ^ "        22      ; points to (CDR ls)\n") ^ "        4\n") ^ "        24"); (((("LDA  3\n" ^ "SUB  4\n") ^ "STP  0\n") ^ "         0\n") ^ "         255"); (((("LDA  3\n" ^ "SUB  4\n") ^ "STP  0\n") ^ "                0\n") ^ "                1"); (((("LDA  3\n" ^ "ADD  4\n") ^ "STP  0\n") ^ "                1\n") ^ "                255")]) in
  let i = ref (0) in
  (try while (!i < List.length (!examples)) do
    try
  let res = execute (List.nth (!examples) (!i)) in
  print_endline ((string_of_int (res)));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)


let () =
  ignore (main ());
  ()