(* Generated by Mochi transpiler v0.10.57 on 2025-08-04 19:20 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then
    let i = (magic v : int) in
    if i = 0 || i = 1 then string_of_bool (i <> 0)
    else string_of_int i
  else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec join xs sep =
  let __ret = ref "" in
  (try
  let res = ref ("") in
  let i = ref (0) in
  (try while (!i < List.length (xs)) do
    try
  if (!i > 0) then (
  res := (!res ^ sep);
  );
  res := (!res ^ List.nth (xs) (!i));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : string); raise Return
  with Return -> !__ret)

and sortPairs xs =
  let __ret = ref ([] : ((string * Obj.t) list) list) in
  (try
  let arr = ref (xs) in
  let i = ref (1) in
  (try while (!i < List.length (!arr)) do
    try
  let j = ref (!i) in
  (try while ((!j > 0) && ((Obj.obj (List.assoc ("count") (List.nth (!arr) ((!j - 1))) : Obj.t) : int) < (Obj.obj (List.assoc ("count") (List.nth (!arr) (!j)) : Obj.t) : int))) do
    try
  let tmp = ref (List.nth (!arr) ((!j - 1))) in
  arr := (List.mapi (fun __i __x -> if __i = (!j - 1) then List.nth (!arr) (!j) else __x) (!arr));
  arr := (List.mapi (fun __i __x -> if __i = !j then !tmp else __x) (!arr));
  j := (!j - 1);
    with Continue -> ()
  done with Break -> ());
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!arr) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and isAlphaNumDot ch =
  let __ret = ref false in
  (try
  __ret := (Obj.magic (((((((ch >= "A") && (ch <= "Z")) || ((ch >= "a") && (ch <= "z"))) || ((ch >= "0") && (ch <= "9"))) || (ch = "_")) || (ch = "."))) : bool); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let srcLines = ref (["package main"; ""; "import ("; "    \"fmt\""; "    \"go/ast\""; "    \"go/parser\""; "    \"go/token\""; "    \"io/ioutil\""; "    \"os\""; "    \"sort\""; ")"; ""; "func main() {"; "    if len(os.Args) != 2 {"; "        fmt.Println(\"usage ff <go source filename>\")"; "        return"; "    }"; "    src, err := ioutil.ReadFile(os.Args[1])"; "    if err != nil {"; "        fmt.Println(err)"; "        return"; "    }"; "    fs := token.NewFileSet()"; "    a, err := parser.ParseFile(fs, os.Args[1], src, 0)"; "    if err != nil {"; "        fmt.Println(err)"; "        return"; "    }"; "    f := fs.File(a.Pos())"; "    m := make(map[string]int)"; "    ast.Inspect(a, func(n ast.Node) bool {"; "        if ce, ok := n.(*ast.CallExpr); ok {"; "            start := f.Offset(ce.Pos())"; "            end := f.Offset(ce.Lparen)"; "            m[string(src[start:end])]++"; "        }"; "        return true"; "    })"; "    cs := make(calls, 0, len(m))"; "    for k, v := range m {"; "        cs = append(cs, &call{k, v})"; "    }"; "    sort.Sort(cs)"; "    for i, c := range cs {"; "        fmt.Printf(\"%-20s %4d\\n\", c.expr, c.count)"; "        if i == 9 {"; "            break"; "        }"; "    }"; "}"; ""; "type call struct {"; "    expr  string"; "    count int"; "}"; "type calls []*call"; ""; "func (c calls) Len() int           { return len(c) }"; "func (c calls) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }"; "func (c calls) Less(i, j int) bool { return c[i].count > c[j].count }"]) in
  let src = join (!srcLines) ("\n") in
  let freq = ref ([]) in
  let i = ref (0) in
  let order = ref (([] : (string) list)) in
  (try while (!i < String.length (src)) do
    try
  let ch = String.sub src (!i) ((!i + 1) - !i) in
  if ((((ch >= "A") && (ch <= "Z")) || ((ch >= "a") && (ch <= "z"))) || (ch = "_")) then (
  let j = ref ((!i + 1)) in
  (try while ((!j < String.length (src)) && isAlphaNumDot (String.sub src (!j) ((!j + 1) - !j))) do
    try
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  let token = String.sub src (!i) (!j - !i) in
  let k = ref (!j) in
  (try while (!k < String.length (src)) do
    try
  let cc = String.sub src (!k) ((!k + 1) - !k) in
  if ((((cc = " ") || (cc = "\t")) || (cc = "\n")) || (cc = "\r")) then (
  k := (!k + 1);
  ) else (
  raise Break;
  );
    with Continue -> ()
  done with Break -> ());
  if ((!k < String.length (src)) && (String.sub src (!k) ((!k + 1) - !k) = "(")) then (
  let p = ref ((!i - 1)) in
  (try while ((!p >= 0) && ((String.sub src (!p) ((!p + 1) - !p) = " ") || (String.sub src (!p) ((!p + 1) - !p) = "\t"))) do
    try
  p := (!p - 1);
    with Continue -> ()
  done with Break -> ());
  let skip = ref (false) in
  if (!p >= 3) then (
  let before = String.sub src ((!p - 3)) ((!p + 1) - (!p - 3)) in
  if (before = "func") then (
  skip := true;
  );
  );
  if not (!skip) then (
  if (List.mem_assoc token !freq) then (
  freq := ((token, (List.assoc (token) (!freq) + 1)) :: List.remove_assoc (token) !freq);
  ) else (
  freq := ((token, 1) :: List.remove_assoc (token) !freq);
  order := (List.append (!order) [(Obj.magic (token) : string)]);
  );
  );
  );
  i := !j;
  ) else (
  i := (!i + 1);
  );
    with Continue -> ()
  done with Break -> ());
  let pairs = ref (([] : ((string * Obj.t) list) list)) in
  (try List.iter (fun t ->
    try
  pairs := (List.append (!pairs) [(Obj.magic ([("expr", Obj.repr (t)); ("count", Obj.repr (List.assoc (t) (!freq)))]) : (string * Obj.t) list)]);
    with Continue -> ()) (!order) with Break -> ());
  pairs := sortPairs ((Obj.magic !pairs : (string * Obj.t) list list));
  let idx = ref (0) in
  (try while ((!idx < List.length (!pairs)) && (!idx < 10)) do
    try
  let p = ref (List.nth (!pairs) (!idx)) in
  print_endline (((__show ((Obj.obj (List.assoc ("expr") (!p) : Obj.t) : Obj.t)) ^ " ") ^ __show ((Obj.obj (List.assoc ("count") (!p) : Obj.t) : Obj.t))));
  idx := (!idx + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()