(* Generated by Mochi transpiler v0.10.52 on 2025-08-01 21:30 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)


let _mem () =
  int_of_float (Gc.allocated_bytes ())

exception Break
exception Continue

exception Return

let rec indexOf s ch =
  let __ret = ref 0 in
  (try
  let i = ref (0) in
  (try while (!i < String.length (s)) do
    try
  if (String.sub (s) !i ((!i + 1) - !i) = ch) then (
  __ret := (Obj.magic (!i) : int); raise Return
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (-(1)) : int); raise Return
  with Return -> !__ret)

and fmt4 x =
  let __ret = ref "" in
  (try
  let x = (Obj.magic x : float) in
  let y = ref ((x *. 10000.0)) in
  if (!y >= float_of_int (0)) then (
  y := (!y +. 0.5);
  ) else (
  y := (!y -. 0.5);
  );
  y := (float_of_int ((Obj.magic !y : int)) /. 10000.0);
  let s = ref ((Printf.sprintf "%.16g" (!y))) in
  let dot = ref ((try String.index (!s) '.' with Not_found -> -1)) in
  if (!dot = (0 - 1)) then (
  s := (!s ^ ".0000");
  ) else (
  let decs = ref (((String.length (!s) - !dot) - 1)) in
  if (!decs > 4) then (
  s := String.sub (!s) 0 ((!dot + 5) - 0);
  ) else (
  (try while (!decs < 4) do
    try
  s := (!s ^ "0");
  decs := (!decs + 1);
    with Continue -> ()
  done with Break -> ());
  );
  );
  if (x >= 0.0) then (
  s := (" " ^ !s);
  );
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and fmt2 n =
  let __ret = ref "" in
  (try
  let n = (Obj.magic n : int) in
  let s = (string_of_int (n)) in
  if (String.length (s) < 2) then (
  __ret := (Obj.magic ((" " ^ s)) : string); raise Return
  );
  __ret := (Obj.magic (s) : string); raise Return
  with Return -> !__ret)

and sumPoint p1 p2 =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  __ret := (Obj.magic ([("x", Obj.repr (((Obj.obj (List.assoc ("x") p1) : float) +. (Obj.obj (List.assoc ("x") p2) : float)))); ("y", Obj.repr (((Obj.obj (List.assoc ("y") p1) : float) +. (Obj.obj (List.assoc ("y") p2) : float)))); ("z", Obj.repr (((Obj.obj (List.assoc ("z") p1) : float) +. (Obj.obj (List.assoc ("z") p2) : float))))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and mulPoint p m =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let m = (Obj.magic m : float) in
  __ret := (Obj.magic ([("x", Obj.repr (((Obj.obj (List.assoc ("x") p) : float) *. m))); ("y", Obj.repr (((Obj.obj (List.assoc ("y") p) : float) *. m))); ("z", Obj.repr (((Obj.obj (List.assoc ("z") p) : float) *. m)))]) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and divPoint p d =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  let d = (Obj.magic d : float) in
  __ret := (Obj.magic (mulPoint (p) (Obj.repr ((1.0 /. d)))) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and centerPoint p1 p2 =
  let __ret = ref ([] : (string * Obj.t) list) in
  (try
  __ret := (Obj.magic (divPoint (sumPoint (p1) (p2)) (Obj.repr (2.0))) : (string * Obj.t) list); raise Return
  with Return -> !__ret)

and getFacePoints points faces =
  let __ret = ref ([] : (string * Obj.t) list list) in
  (try
  let facePoints = ref (([] : (string * Obj.t) list list)) in
  let i = ref (0) in
  (try while (!i < List.length (faces)) do
    try
  let face = ref (List.nth (faces) (!i)) in
  let fp = ref ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0)); ("z", Obj.repr (0.0))]) in
  (try List.iter (fun idx ->
    try
  fp := sumPoint (!fp) (List.nth (points) (idx));
    with Continue -> ()) (!face) with Break -> ());
  fp := divPoint (!fp) (Obj.repr (float_of_int (List.length (!face))));
  facePoints := (List.append (!facePoints) [(Obj.magic (!fp) : (string * Obj.t) list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!facePoints) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and sortEdges edges =
  let __ret = ref ([] : int list list) in
  (try
  let res = ref (([] : int list list)) in
  let tmp = ref (edges) in
  (try while (List.length (!tmp) > 0) do
    try
  let min = ref (List.nth (!tmp) (0)) in
  let idx = ref (0) in
  let j = ref (1) in
  (try while (!j < List.length (!tmp)) do
    try
  let e = ref (List.nth (!tmp) (!j)) in
  if ((List.nth (!e) (0) < List.nth (!min) (0)) || ((List.nth (!e) (0) = List.nth (!min) (0)) && ((List.nth (!e) (1) < List.nth (!min) (1)) || ((List.nth (!e) (1) = List.nth (!min) (1)) && (List.nth (!e) (2) < List.nth (!min) (2)))))) then (
  min := !e;
  idx := !j;
  );
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  res := (List.append (!res) [(Obj.magic (!min) : int list)]);
  let out = ref (([] : int list list)) in
  let k = ref (0) in
  (try while (!k < List.length (!tmp)) do
    try
  if (!k <> !idx) then (
  out := (List.append (!out) [(Obj.magic (List.nth (!tmp) (!k)) : int list)]);
  );
  k := (!k + 1);
    with Continue -> ()
  done with Break -> ());
  tmp := !out;
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!res) : int list list); raise Return
  with Return -> !__ret)

and getEdgesFaces points faces =
  let __ret = ref ([] : (string * Obj.t) list list) in
  (try
  let edges = ref (([] : int list list)) in
  let fnum = ref (0) in
  (try while (!fnum < List.length (faces)) do
    try
  let face = ref (List.nth (faces) (!fnum)) in
  let numP = ref (List.length (!face)) in
  let pi = ref (0) in
  (try while (!pi < !numP) do
    try
  let pn1 = ref (List.nth (!face) (!pi)) in
  let pn2 = ref (0) in
  if (!pi < (!numP - 1)) then (
  pn2 := List.nth (!face) ((!pi + 1));
  ) else (
  pn2 := List.nth (!face) (0);
  );
  if (!pn1 > !pn2) then (
  let tmpn = ref (!pn1) in
  pn1 := !pn2;
  pn2 := !tmpn;
  );
  edges := (List.append (!edges) [(Obj.magic ([!pn1; !pn2; !fnum]) : int list)]);
  pi := (!pi + 1);
    with Continue -> ()
  done with Break -> ());
  fnum := (!fnum + 1);
    with Continue -> ()
  done with Break -> ());
  edges := sortEdges (!edges);
  let merged = ref (([] : int list list)) in
  let idx = ref (0) in
  (try while (!idx < List.length (!edges)) do
    try
  let e1 = ref (List.nth (!edges) (!idx)) in
  if (!idx < (List.length (!edges) - 1)) then (
  let e2 = ref (List.nth (!edges) ((!idx + 1))) in
  if ((List.nth (!e1) (0) = List.nth (!e2) (0)) && (List.nth (!e1) (1) = List.nth (!e2) (1))) then (
  merged := (List.append (!merged) [(Obj.magic ([List.nth (!e1) (0); List.nth (!e1) (1); List.nth (!e1) (2); List.nth (!e2) (2)]) : int list)]);
  idx := (!idx + 2);
  raise Continue;
  );
  );
  merged := (List.append (!merged) [(Obj.magic ([List.nth (!e1) (0); List.nth (!e1) (1); List.nth (!e1) (2); -(1)]) : int list)]);
  idx := (!idx + 1);
    with Continue -> ()
  done with Break -> ());
  let edgesCenters = ref (([] : (string * Obj.t) list list)) in
  (try List.iter (fun me ->
    try
  let p1 = ref (List.nth (points) (List.nth (me) (0))) in
  let p2 = ref (List.nth (points) (List.nth (me) (1))) in
  let cp = centerPoint (!p1) (!p2) in
  edgesCenters := (List.append (!edgesCenters) [(Obj.magic ([("pn1", Obj.repr (List.nth (me) (0))); ("pn2", Obj.repr (List.nth (me) (1))); ("fn1", Obj.repr (List.nth (me) (2))); ("fn2", Obj.repr (List.nth (me) (3))); ("cp", Obj.repr (cp))]) : (string * Obj.t) list)]);
    with Continue -> ()) (!merged) with Break -> ());
  __ret := (Obj.magic (!edgesCenters) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and getEdgePoints points edgesFaces facePoints =
  let __ret = ref ([] : (string * Obj.t) list list) in
  (try
  let edgePoints = ref (([] : (string * Obj.t) list list)) in
  let i = ref (0) in
  (try while (!i < List.length (edgesFaces)) do
    try
  let edge = ref (List.nth (edgesFaces) (!i)) in
  let cp = ref ((Obj.obj (List.assoc ("cp") !edge) : (string * Obj.t) list)) in
  let fp1 = ref (List.nth (facePoints) ((Obj.obj (List.assoc ("fn1") !edge) : int))) in
  let fp2 = ref (!fp1) in
  if ((Obj.obj (List.assoc ("fn2") !edge) : int) <> (0 - 1)) then (
  fp2 := List.nth (facePoints) ((Obj.obj (List.assoc ("fn2") !edge) : int));
  );
  let cfp = centerPoint (!fp1) (!fp2) in
  edgePoints := (List.append (!edgePoints) [(Obj.magic (centerPoint (!cp) (cfp)) : (string * Obj.t) list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!edgePoints) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and getAvgFacePoints points faces facePoints =
  let __ret = ref ([] : (string * Obj.t) list list) in
  (try
  let numP = ref (List.length (points)) in
  let temp = ref (([] : (string * Obj.t) list list)) in
  let i = ref (0) in
  (try while (!i < !numP) do
    try
  temp := (List.append (!temp) [(Obj.magic ([("p", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0)); ("z", Obj.repr (0.0))])); ("n", Obj.repr (0))]) : (string * Obj.t) list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let fnum = ref (0) in
  (try while (!fnum < List.length (faces)) do
    try
  let fp = ref (List.nth (facePoints) (!fnum)) in
  (try List.iter (fun pn ->
    try
  let tp = List.nth (!temp) (pn) in
  temp := (List.mapi (fun __i __x -> if __i = pn then [("p", Obj.repr (sumPoint ((Obj.obj (List.assoc ("p") tp) : (string * Obj.t) list)) (!fp))); ("n", Obj.repr (((Obj.obj (List.assoc ("n") tp) : int) + 1)))] else __x) (!temp));
    with Continue -> ()) (List.nth (faces) (!fnum)) with Break -> ());
  fnum := (!fnum + 1);
    with Continue -> ()
  done with Break -> ());
  let avg = ref (([] : (string * Obj.t) list list)) in
  let j = ref (0) in
  (try while (!j < !numP) do
    try
  let tp = List.nth (!temp) (!j) in
  avg := (List.append (!avg) [(Obj.magic (divPoint ((Obj.obj (List.assoc ("p") tp) : (string * Obj.t) list)) (Obj.repr (float_of_int ((Obj.obj (List.assoc ("n") tp) : int))))) : (string * Obj.t) list)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!avg) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and getAvgMidEdges points edgesFaces =
  let __ret = ref ([] : (string * Obj.t) list list) in
  (try
  let numP = ref (List.length (points)) in
  let temp = ref (([] : (string * Obj.t) list list)) in
  let i = ref (0) in
  (try while (!i < !numP) do
    try
  temp := (List.append (!temp) [(Obj.magic ([("p", Obj.repr ([("x", Obj.repr (0.0)); ("y", Obj.repr (0.0)); ("z", Obj.repr (0.0))])); ("n", Obj.repr (0))]) : (string * Obj.t) list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  (try List.iter (fun edge ->
    try
  let cp = ref ((Obj.obj (List.assoc ("cp") edge) : (string * Obj.t) list)) in
  let arr = ref ([(Obj.obj (List.assoc ("pn1") edge) : int); (Obj.obj (List.assoc ("pn2") edge) : int)]) in
  (try List.iter (fun pn ->
    try
  let tp = List.nth (!temp) (pn) in
  temp := (List.mapi (fun __i __x -> if __i = pn then [("p", Obj.repr (sumPoint ((Obj.obj (List.assoc ("p") tp) : (string * Obj.t) list)) (!cp))); ("n", Obj.repr (((Obj.obj (List.assoc ("n") tp) : int) + 1)))] else __x) (!temp));
    with Continue -> ()) (!arr) with Break -> ());
    with Continue -> ()) (edgesFaces) with Break -> ());
  let avg = ref (([] : (string * Obj.t) list list)) in
  let j = ref (0) in
  (try while (!j < !numP) do
    try
  let tp = List.nth (!temp) (!j) in
  avg := (List.append (!avg) [(Obj.magic (divPoint ((Obj.obj (List.assoc ("p") tp) : (string * Obj.t) list)) (Obj.repr (float_of_int ((Obj.obj (List.assoc ("n") tp) : int))))) : (string * Obj.t) list)]);
  j := (!j + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!avg) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and getPointsFaces points faces =
  let __ret = ref ([] : int list) in
  (try
  let pf = ref (([] : int list)) in
  let i = ref (0) in
  (try while (!i < List.length (points)) do
    try
  pf := (List.append (!pf) [(Obj.magic (0) : int)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let fnum = ref (0) in
  (try while (!fnum < List.length (faces)) do
    try
  (try List.iter (fun pn ->
    try
  pf := (List.mapi (fun __i __x -> if __i = pn then (List.nth (!pf) (pn) + 1) else __x) (!pf));
    with Continue -> ()) (List.nth (faces) (!fnum)) with Break -> ());
  fnum := (!fnum + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!pf) : int list); raise Return
  with Return -> !__ret)

and getNewPoints points pf afp ame =
  let __ret = ref ([] : (string * Obj.t) list list) in
  (try
  let newPts = ref (([] : (string * Obj.t) list list)) in
  let i = ref (0) in
  (try while (!i < List.length (points)) do
    try
  let n = ref (float_of_int (List.nth (pf) (!i))) in
  let m1 = ref (((!n -. 3.0) /. !n)) in
  let m2 = ref ((1.0 /. !n)) in
  let m3 = ref ((2.0 /. !n)) in
  let old = ref (List.nth (points) (!i)) in
  let p1 = mulPoint (!old) (Obj.repr (!m1)) in
  let p2 = mulPoint (List.nth (afp) (!i)) (Obj.repr (!m2)) in
  let p3 = mulPoint (List.nth (ame) (!i)) (Obj.repr (!m3)) in
  newPts := (List.append (!newPts) [(Obj.magic (sumPoint (sumPoint (p1) (p2)) (p3)) : (string * Obj.t) list)]);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!newPts) : (string * Obj.t) list list); raise Return
  with Return -> !__ret)

and key a b =
  let __ret = ref "" in
  (try
  let a = (Obj.magic a : int) in
  let b = (Obj.magic b : int) in
  if (a < b) then (
  __ret := (Obj.magic ((((string_of_int (a)) ^ ",") ^ (string_of_int (b)))) : string); raise Return
  );
  __ret := (Obj.magic ((((string_of_int (b)) ^ ",") ^ (string_of_int (a)))) : string); raise Return
  with Return -> !__ret)

and cmcSubdiv points faces =
  let __ret = ref [] in
  (try
  let facePoints = ref (getFacePoints (points) (faces)) in
  let edgesFaces = ref (getEdgesFaces (points) (faces)) in
  let edgePoints = ref (getEdgePoints (points) (!edgesFaces) (!facePoints)) in
  let avgFacePoints = ref (getAvgFacePoints (points) (faces) (!facePoints)) in
  let avgMidEdges = ref (getAvgMidEdges (points) (!edgesFaces)) in
  let pointsFaces = ref (getPointsFaces (points) (faces)) in
  let newPoints = ref (getNewPoints (points) (!pointsFaces) (!avgFacePoints) (!avgMidEdges)) in
  let facePointNums = ref (([] : int list)) in
  let nextPoint = ref (List.length (!newPoints)) in
  (try List.iter (fun fp ->
    try
  newPoints := (List.append (!newPoints) [(Obj.magic (fp) : (string * Obj.t) list)]);
  facePointNums := (List.append (!facePointNums) [(Obj.magic (!nextPoint) : int)]);
  nextPoint := (!nextPoint + 1);
    with Continue -> ()) (!facePoints) with Break -> ());
  let edgePointNums = ref ([]) in
  let idx = ref (0) in
  (try while (!idx < List.length (!edgesFaces)) do
    try
  let e = List.nth (!edgesFaces) (!idx) in
  newPoints := (List.append (!newPoints) [(Obj.magic (List.nth (!edgePoints) (!idx)) : (string * Obj.t) list)]);
  edgePointNums := ((key (Obj.repr ((Obj.obj (List.assoc ("pn1") e) : int))) (Obj.repr ((Obj.obj (List.assoc ("pn2") e) : int))), !nextPoint) :: List.remove_assoc (key (Obj.repr ((Obj.obj (List.assoc ("pn1") e) : int))) (Obj.repr ((Obj.obj (List.assoc ("pn2") e) : int)))) !edgePointNums);
  nextPoint := (!nextPoint + 1);
  idx := (!idx + 1);
    with Continue -> ()
  done with Break -> ());
  let newFaces = ref (([] : int list list)) in
  let fnum = ref (0) in
  (try while (!fnum < List.length (faces)) do
    try
  let oldFace = ref (List.nth (faces) (!fnum)) in
  if (List.length (!oldFace) = 4) then (
  let a = List.nth (!oldFace) (0) in
  let b = List.nth (!oldFace) (1) in
  let c = List.nth (!oldFace) (2) in
  let d = List.nth (!oldFace) (3) in
  let fpnum = List.nth (!facePointNums) (!fnum) in
  let ab = (try List.assoc (key (Obj.repr (a)) (Obj.repr (b))) !edgePointNums with Not_found -> (Obj.magic 0)) in
  let da = (try List.assoc (key (Obj.repr (d)) (Obj.repr (a))) !edgePointNums with Not_found -> (Obj.magic 0)) in
  let bc = (try List.assoc (key (Obj.repr (b)) (Obj.repr (c))) !edgePointNums with Not_found -> (Obj.magic 0)) in
  let cd = (try List.assoc (key (Obj.repr (c)) (Obj.repr (d))) !edgePointNums with Not_found -> (Obj.magic 0)) in
  newFaces := (List.append (!newFaces) [(Obj.magic ([a; ab; fpnum; da]) : int list)]);
  newFaces := (List.append (!newFaces) [(Obj.magic ([b; bc; fpnum; ab]) : int list)]);
  newFaces := (List.append (!newFaces) [(Obj.magic ([c; cd; fpnum; bc]) : int list)]);
  newFaces := (List.append (!newFaces) [(Obj.magic ([d; da; fpnum; cd]) : int list)]);
  );
  fnum := (!fnum + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic ([Obj.repr (!newPoints); Obj.repr (!newFaces)]) : Obj.t list); raise Return
  with Return -> !__ret)

and formatPoint p =
  let __ret = ref "" in
  (try
  __ret := (Obj.magic ((((((("[" ^ fmt4 (Obj.repr ((Obj.obj (List.assoc ("x") p) : float)))) ^ " ") ^ fmt4 (Obj.repr ((Obj.obj (List.assoc ("y") p) : float)))) ^ " ") ^ fmt4 (Obj.repr ((Obj.obj (List.assoc ("z") p) : float)))) ^ "]")) : string); raise Return
  with Return -> !__ret)

and formatFace f =
  let __ret = ref "" in
  (try
  if (List.length (f) = 0) then (
  __ret := (Obj.magic ("[]") : string); raise Return
  );
  let s = ref (("[" ^ fmt2 (Obj.repr (List.nth (f) (0))))) in
  let i = ref (1) in
  (try while (!i < List.length (f)) do
    try
  s := ((!s ^ " ") ^ fmt2 (Obj.repr (List.nth (f) (!i))));
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  s := (!s ^ "]");
  __ret := (Obj.magic (!s) : string); raise Return
  with Return -> !__ret)

and main () =
  let __ret = ref (Obj.magic 0) in
  (try
  let inputPoints = ref ([[("x", Obj.repr ((-.(1.0)))); ("y", Obj.repr (1.0)); ("z", Obj.repr (1.0))]; [("x", Obj.repr ((-.(1.0)))); ("y", Obj.repr ((-.(1.0)))); ("z", Obj.repr (1.0))]; [("x", Obj.repr (1.0)); ("y", Obj.repr ((-.(1.0)))); ("z", Obj.repr (1.0))]; [("x", Obj.repr (1.0)); ("y", Obj.repr (1.0)); ("z", Obj.repr (1.0))]; [("x", Obj.repr (1.0)); ("y", Obj.repr ((-.(1.0)))); ("z", Obj.repr ((-.(1.0))))]; [("x", Obj.repr (1.0)); ("y", Obj.repr (1.0)); ("z", Obj.repr ((-.(1.0))))]; [("x", Obj.repr ((-.(1.0)))); ("y", Obj.repr ((-.(1.0)))); ("z", Obj.repr ((-.(1.0))))]; [("x", Obj.repr ((-.(1.0)))); ("y", Obj.repr (1.0)); ("z", Obj.repr ((-.(1.0))))]]) in
  let inputFaces = ref ([[0; 1; 2; 3]; [3; 2; 4; 5]; [5; 4; 6; 7]; [7; 0; 3; 5]; [7; 6; 1; 0]; [6; 1; 2; 4]]) in
  let outputPoints = ref (!inputPoints) in
  let outputFaces = ref (!inputFaces) in
  let i = ref (0) in
  (try while (!i < 1) do
    try
  let res = ref (cmcSubdiv (!outputPoints) (!outputFaces)) in
  outputPoints := List.nth (!res) (0);
  outputFaces := List.nth (!res) (1);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  (try List.iter (fun p ->
    try
  print_endline (formatPoint (p));
    with Continue -> ()) (!outputPoints) with Break -> ());
  print_endline ("");
  (try List.iter (fun f ->
    try
  print_endline (formatFace (f));
    with Continue -> ()) (!outputFaces) with Break -> ());
    !__ret
  with Return -> !__ret)


let () =
  let mem_start = _mem () in
  let start = _now () in
  ignore (main ());
  let finish = _now () in
  let mem_end = _mem () in
  let dur = (finish - start) / 1000 in
  let mem_bytes = max 0 (mem_end - mem_start) in
  Printf.printf "{\n  \"duration_us\": %d,\n  \"memory_bytes\": %d,\n  \"name\": \"%s\"\n}\n" dur mem_bytes "main";
  ()