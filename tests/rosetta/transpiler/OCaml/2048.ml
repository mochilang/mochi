(* Generated by Mochi transpiler v0.10.37 on 2025-07-23 12:42 +0700 *)


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)

exception Break
exception Continue

exception Return

let size = 4
let rec newBoard () =
  let __ret = ref [] in
  (try
  let b = ref ([]) in
  let y = ref (0) in
  (try while (!y < size) do
    try
  let row = ref ([]) in
  let x = ref (0) in
  (try while (!x < size) do
    try
  row := List.append !row [0];
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  b := List.append !b [!row];
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !b; raise Return;
  __ret := !b;
    !__ret
  with Return -> !__ret)

let rec spawnTile b =
  let __ret = ref [] in
  let b = ref b in
  (try
  let empty = ref ([]) in
  let y = ref (0) in
  (try while (!y < size) do
    try
  let x = ref (0) in
  (try while (!x < size) do
    try
  if (List.nth (List.nth (!b) (!y)) (!x) = 0) then (
  empty := List.append !empty [[!x; !y]];
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  if (List.length !empty = 0) then (
  __ret := [("board", Obj.repr !b); ("full", Obj.repr true)]; raise Return;
  );
  let idx = ref ((_now () mod List.length !empty)) in
  let cell = List.nth (!empty) (!idx) in
  let val_ = ref (4) in
  if ((_now () mod 10) < 9) then (
  val_ := 2;
  );
  b := (List.mapi (fun __i __x -> if __i = List.nth (cell) (1) then (List.mapi (fun __i __x -> if __i = List.nth (cell) (0) then !val_ else __x) (List.nth (!b) (List.nth (cell) (1)))) else __x) (!b));
  __ret := [("board", Obj.repr !b); ("full", Obj.repr (List.length !empty = 1))]; raise Return;
  __ret := [("board", Obj.repr !b); ("full", Obj.repr (List.length !empty = 1))];
    !__ret
  with Return -> !__ret)

let rec pad n =
  let __ret = ref "" in
  let n = ref n in
  (try
  let s = ref ((string_of_int !n)) in
  let pad = ref ((4 - String.length !s)) in
  let i = ref (0) in
  let out = ref ("") in
  (try while (!i < !pad) do
    try
  out := (!out ^ " ");
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (!out ^ !s); raise Return;
  __ret := (!out ^ !s);
    !__ret
  with Return -> !__ret)

let rec draw b score =
  let __ret = ref () in
  let b = ref b in
  let score = ref score in
  (try
  print_endline (("Score: " ^ (string_of_int !score)));
  let y = ref (0) in
  (try while (!y < size) do
    try
  print_endline ("+----+----+----+----+");
  let line = ref ("|") in
  let x = ref (0) in
  (try while (!x < size) do
    try
  let v = ref (List.nth (List.nth (!b) (!y)) (!x)) in
  if (!v = 0) then (
  line := (!line ^ "    |");
  ) else (
  line := ((!line ^ pad (!v)) ^ "|");
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline (!line);
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  print_endline ("+----+----+----+----+");
  print_endline ("W=Up S=Down A=Left D=Right Q=Quit");
    !__ret
  with Return -> !__ret)

let rec reverseRow r =
  let __ret = ref [] in
  let r = ref r in
  (try
  let out = ref ([]) in
  let i = ref ((List.length !r - 1)) in
  (try while (!i >= 0) do
    try
  out := List.append !out [List.nth (!r) (!i)];
  i := (!i - 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !out; raise Return;
  __ret := !out;
    !__ret
  with Return -> !__ret)

let rec slideLeft row =
  let __ret = ref [] in
  let row = ref row in
  (try
  let xs = ref ([]) in
  let i = ref (0) in
  (try while (!i < List.length !row) do
    try
  if (List.nth (!row) (!i) <> 0) then (
  xs := List.append !xs [List.nth (!row) (!i)];
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  let res = ref ([]) in
  let gain = ref (0) in
  i := 0;
  (try while (!i < List.length !xs) do
    try
  if (((!i + 1) < List.length !xs) && (List.nth (!xs) (!i) = List.nth (!xs) ((!i + 1)))) then (
  let v = (List.nth (!xs) (!i) * 2) in
  gain := (!gain + v);
  res := List.append !res [v];
  i := (!i + 2);
  ) else (
  res := List.append !res [List.nth (!xs) (!i)];
  i := (!i + 1);
  );
    with Continue -> ()
  done with Break -> ());
  (try while (List.length !res < size) do
    try
  res := List.append !res [0];
    with Continue -> ()
  done with Break -> ());
  __ret := [("row", Obj.repr !res); ("gain", Obj.repr !gain)]; raise Return;
  __ret := [("row", Obj.repr !res); ("gain", Obj.repr !gain)];
    !__ret
  with Return -> !__ret)

let rec moveLeft b score =
  let __ret = ref [] in
  let b = ref b in
  let score = ref score in
  (try
  let moved = ref (false) in
  let y = ref (0) in
  (try while (!y < size) do
    try
  let r = slideLeft (List.nth (!b) (!y)) in
  let new_ = (Obj.obj (List.assoc ("row") r) : int list) in
  score := (!score + (Obj.obj (List.assoc ("gain") r) : int));
  let x = ref (0) in
  (try while (!x < size) do
    try
  if (List.nth (List.nth (!b) (!y)) (!x) <> List.nth (new_) (!x)) then (
  moved := true;
  );
  b := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then List.nth (new_) (!x) else __x) (List.nth (!b) (!y))) else __x) (!b));
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := [("board", Obj.repr !b); ("score", Obj.repr !score); ("moved", Obj.repr !moved)]; raise Return;
  __ret := [("board", Obj.repr !b); ("score", Obj.repr !score); ("moved", Obj.repr !moved)];
    !__ret
  with Return -> !__ret)

let rec moveRight b score =
  let __ret = ref [] in
  let b = ref b in
  let score = ref score in
  (try
  let moved = ref (false) in
  let y = ref (0) in
  (try while (!y < size) do
    try
  let rev = ref (reverseRow (List.nth (!b) (!y))) in
  let r = slideLeft (!rev) in
  rev := (Obj.obj (List.assoc ("row") r) : int list);
  score := (!score + (Obj.obj (List.assoc ("gain") r) : int));
  rev := reverseRow (!rev);
  let x = ref (0) in
  (try while (!x < size) do
    try
  if (List.nth (List.nth (!b) (!y)) (!x) <> List.nth (!rev) (!x)) then (
  moved := true;
  );
  b := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then List.nth (!rev) (!x) else __x) (List.nth (!b) (!y))) else __x) (!b));
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := [("board", Obj.repr !b); ("score", Obj.repr !score); ("moved", Obj.repr !moved)]; raise Return;
  __ret := [("board", Obj.repr !b); ("score", Obj.repr !score); ("moved", Obj.repr !moved)];
    !__ret
  with Return -> !__ret)

let rec getCol b x =
  let __ret = ref [] in
  let b = ref b in
  let x = ref x in
  (try
  let col = ref ([]) in
  let y = ref (0) in
  (try while (!y < size) do
    try
  col := List.append !col [List.nth (List.nth (!b) (!y)) (!x)];
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := !col; raise Return;
  __ret := !col;
    !__ret
  with Return -> !__ret)

let rec setCol b x col =
  let __ret = ref () in
  let b = ref b in
  let x = ref x in
  let col = ref col in
  (try
  let y = ref (0) in
  (try while (!y < size) do
    try
  b := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then List.nth (!col) (!y) else __x) (List.nth (!b) (!y))) else __x) (!b));
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

let rec moveUp b score =
  let __ret = ref [] in
  let b = ref b in
  let score = ref score in
  (try
  let moved = ref (false) in
  let x = ref (0) in
  (try while (!x < size) do
    try
  let col = ref (getCol (!b) (!x)) in
  let r = slideLeft (!col) in
  let new_ = (Obj.obj (List.assoc ("row") r) : int list) in
  score := (!score + (Obj.obj (List.assoc ("gain") r) : int));
  let y = ref (0) in
  (try while (!y < size) do
    try
  if (List.nth (List.nth (!b) (!y)) (!x) <> List.nth (new_) (!y)) then (
  moved := true;
  );
  b := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then List.nth (new_) (!y) else __x) (List.nth (!b) (!y))) else __x) (!b));
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := [("board", Obj.repr !b); ("score", Obj.repr !score); ("moved", Obj.repr !moved)]; raise Return;
  __ret := [("board", Obj.repr !b); ("score", Obj.repr !score); ("moved", Obj.repr !moved)];
    !__ret
  with Return -> !__ret)

let rec moveDown b score =
  let __ret = ref [] in
  let b = ref b in
  let score = ref score in
  (try
  let moved = ref (false) in
  let x = ref (0) in
  (try while (!x < size) do
    try
  let col = ref (reverseRow (getCol (!b) (!x))) in
  let r = slideLeft (!col) in
  col := (Obj.obj (List.assoc ("row") r) : int list);
  score := (!score + (Obj.obj (List.assoc ("gain") r) : int));
  col := reverseRow (!col);
  let y = ref (0) in
  (try while (!y < size) do
    try
  if (List.nth (List.nth (!b) (!y)) (!x) <> List.nth (!col) (!y)) then (
  moved := true;
  );
  b := (List.mapi (fun __i __x -> if __i = !y then (List.mapi (fun __i __x -> if __i = !x then List.nth (!col) (!y) else __x) (List.nth (!b) (!y))) else __x) (!b));
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := [("board", Obj.repr !b); ("score", Obj.repr !score); ("moved", Obj.repr !moved)]; raise Return;
  __ret := [("board", Obj.repr !b); ("score", Obj.repr !score); ("moved", Obj.repr !moved)];
    !__ret
  with Return -> !__ret)

let rec hasMoves b =
  let __ret = ref false in
  let b = ref b in
  (try
  let y = ref (0) in
  (try while (!y < size) do
    try
  let x = ref (0) in
  (try while (!x < size) do
    try
  if (List.nth (List.nth (!b) (!y)) (!x) = 0) then (
  __ret := true; raise Return;
  );
  if (((!x + 1) < size) && (List.nth (List.nth (!b) (!y)) (!x) = List.nth (List.nth (!b) (!y)) ((!x + 1)))) then (
  __ret := true; raise Return;
  );
  if (((!y + 1) < size) && (List.nth (List.nth (!b) (!y)) (!x) = List.nth (List.nth (!b) ((!y + 1))) (!x))) then (
  __ret := true; raise Return;
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := false; raise Return;
  __ret := false;
    !__ret
  with Return -> !__ret)

let rec has2048 b =
  let __ret = ref false in
  let b = ref b in
  (try
  let y = ref (0) in
  (try while (!y < size) do
    try
  let x = ref (0) in
  (try while (!x < size) do
    try
  if (List.nth (List.nth (!b) (!y)) (!x) >= 2048) then (
  __ret := true; raise Return;
  );
  x := (!x + 1);
    with Continue -> ()
  done with Break -> ());
  y := (!y + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := false; raise Return;
  __ret := false;
    !__ret
  with Return -> !__ret)

let board = ref (newBoard ())
let r = ref (spawnTile (!board))
let full = ref ((Obj.obj (List.assoc ("full") !r) : bool))
let score = ref (0)
let () =
  board := (Obj.obj (List.assoc ("board") !r) : int list list);
  r := spawnTile (!board);
  board := (Obj.obj (List.assoc ("board") !r) : int list list);
  full := (Obj.obj (List.assoc ("full") !r) : bool);
  draw (!board) (!score);
  (try while true do
    try
  print_endline ("Move: ");
  let cmd = (try read_line () with End_of_file -> "") in
  let moved = ref (false) in
  if ((cmd = "a") || (cmd = "A")) then (
  let m = moveLeft (!board) (!score) in
  board := (Obj.obj (List.assoc ("board") m) : int list list);
  score := (Obj.obj (List.assoc ("score") m) : int);
  moved := (Obj.obj (List.assoc ("moved") m) : bool);
  );
  if ((cmd = "d") || (cmd = "D")) then (
  let m = moveRight (!board) (!score) in
  board := (Obj.obj (List.assoc ("board") m) : int list list);
  score := (Obj.obj (List.assoc ("score") m) : int);
  moved := (Obj.obj (List.assoc ("moved") m) : bool);
  );
  if ((cmd = "w") || (cmd = "W")) then (
  let m = moveUp (!board) (!score) in
  board := (Obj.obj (List.assoc ("board") m) : int list list);
  score := (Obj.obj (List.assoc ("score") m) : int);
  moved := (Obj.obj (List.assoc ("moved") m) : bool);
  );
  if ((cmd = "s") || (cmd = "S")) then (
  let m = moveDown (!board) (!score) in
  board := (Obj.obj (List.assoc ("board") m) : int list list);
  score := (Obj.obj (List.assoc ("score") m) : int);
  moved := (Obj.obj (List.assoc ("moved") m) : bool);
  );
  if ((cmd = "q") || (cmd = "Q")) then (
  raise Break;
  );
  if !moved then (
  let r2 = spawnTile (!board) in
  board := (Obj.obj (List.assoc ("board") r2) : int list list);
  full := (Obj.obj (List.assoc ("full") r2) : bool);
  if (!full && not (hasMoves (!board))) then (
  draw (!board) (!score);
  print_endline ("Game Over");
  raise Break;
  );
  );
  draw (!board) (!score);
  if has2048 (!board) then (
  print_endline ("You win!");
  raise Break;
  );
  if not (hasMoves (!board)) then (
  print_endline ("Game Over");
  raise Break;
  );
    with Continue -> ()
  done with Break -> ());
