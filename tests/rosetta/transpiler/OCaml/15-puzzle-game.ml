(* Generated by Mochi transpiler v0.10.38 on 2025-07-24 00:17 +0700 *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let _now_seed = ref 0
let _now_seeded = ref false

let _now () =
  if not !_now_seeded then (
    match Sys.getenv_opt "MOCHI_NOW_SEED" with
    | Some s -> (try _now_seed := int_of_string s; _now_seeded := true with _ -> ())
    | None -> ()
  );
  if !_now_seeded then (
    _now_seed := (!(_now_seed) * 1664525 + 1013904223) mod 2147483647;
    !_now_seed
  ) else int_of_float (Sys.time () *. 1000000000.)

exception Break
exception Continue

exception Return

let board = ref ([1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 0])
let solved = ref ([1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 0])
let empty = ref (15)
let moves = ref (0)
let quit = ref (false)
let rec randMove () =
  let __ret = ref 0 in
  (try
  __ret := (_now () mod 4); raise Return;
  __ret := (_now () mod 4);
    !__ret
  with Return -> !__ret)

let rec isSolved () =
  let __ret = ref false in
  (try
  let i = ref (0) in
  (try while (!i < 16) do
    try
  if (List.nth (!board) (!i) <> List.nth (!solved) (!i)) then (
  __ret := false; raise Return;
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := true; raise Return;
  __ret := true;
    !__ret
  with Return -> !__ret)

let rec isValidMove m =
  let __ret = ref [("idx", Obj.repr 0); ("ok", Obj.repr false)] in
  let m = ref m in
  (try
  if (!m = 0) then (
  __ret := [("idx", Obj.repr (!empty - 4)); ("ok", Obj.repr ((!empty / 4) > 0))]; raise Return;
  );
  if (!m = 1) then (
  __ret := [("idx", Obj.repr (!empty + 4)); ("ok", Obj.repr ((!empty / 4) < 3))]; raise Return;
  );
  if (!m = 2) then (
  __ret := [("idx", Obj.repr (!empty + 1)); ("ok", Obj.repr ((!empty mod 4) < 3))]; raise Return;
  );
  if (!m = 3) then (
  __ret := [("idx", Obj.repr (!empty - 1)); ("ok", Obj.repr ((!empty mod 4) > 0))]; raise Return;
  );
  __ret := [("idx", Obj.repr 0); ("ok", Obj.repr false)]; raise Return;
  __ret := [("idx", Obj.repr 0); ("ok", Obj.repr false)];
    !__ret
  with Return -> !__ret)

let rec doMove m =
  let __ret = ref false in
  let m = ref m in
  (try
  let r = isValidMove (!m) in
  if not ((Obj.obj (List.assoc ("ok") r) : bool)) then (
  __ret := false; raise Return;
  );
  let i = !empty in
  let j = (Obj.obj (List.assoc ("idx") r) : int) in
  let tmp = List.nth (!board) (i) in
  board := (List.mapi (fun __i __x -> if __i = i then List.nth (!board) (j) else __x) (!board));
  board := (List.mapi (fun __i __x -> if __i = j then tmp else __x) (!board));
  empty := j;
  moves := (!moves + 1);
  __ret := true; raise Return;
  __ret := true;
    !__ret
  with Return -> !__ret)

let rec shuffle n =
  let __ret = ref () in
  let n = ref n in
  (try
  let i = ref (0) in
  (try while ((!i < !n) || isSolved ()) do
    try
  if doMove (randMove ()) then (
  i := (!i + 1);
  );
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

let rec printBoard () =
  let __ret = ref () in
  (try
  let line = ref ("") in
  let i = ref (0) in
  (try while (!i < 16) do
    try
  let val_ = List.nth (!board) (!i) in
  if (val_ = 0) then (
  line := (!line ^ "  .");
  ) else (
  let s = (string_of_int (val_)) in
  if (val_ < 10) then (
  line := ((!line ^ "  ") ^ s);
  ) else (
  line := ((!line ^ " ") ^ s);
  );
  );
  if ((!i mod 4) = 3) then (
  print_endline (__show !line);
  line := "";
  );
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

let rec playOneMove () =
  let __ret = ref () in
  (try
  (try while true do
    try
  print_endline ((("Enter move #" ^ (string_of_int ((!moves + 1)))) ^ " (U, D, L, R, or Q): "));
  let s = (try read_line () with End_of_file -> "") in
  if (s = "") then (
  raise Continue;
  );
  let c = String.sub s 0 (1 - 0) in
  let m = ref (0) in
  if ((c = "U") || (c = "u")) then (
  m := 0;
  ) else (
  if ((c = "D") || (c = "d")) then (
  m := 1;
  ) else (
  if ((c = "R") || (c = "r")) then (
  m := 2;
  ) else (
  if ((c = "L") || (c = "l")) then (
  m := 3;
  ) else (
  if ((c = "Q") || (c = "q")) then (
  print_endline ((("Quiting after " ^ (string_of_int (!moves))) ^ " moves."));
  quit := true;
  __ret := (); raise Return;
  ) else (
  print_endline (((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" ^ "up, down, left, or right. You can also enter \"Q\" to quit.\n") ^ "Upper or lowercase is accepted and only the first non-blank\n") ^ "character is important (i.e. you may enter \"up\" if you like)."));
  raise Continue;
  );
  );
  );
  );
  );
  if not (doMove (!m)) then (
  print_endline ("That is not a valid move at the moment.");
  raise Continue;
  );
  __ret := (); raise Return;
    with Continue -> ()
  done with Break -> ());
    !__ret
  with Return -> !__ret)

let rec play () =
  let __ret = ref () in
  (try
  print_endline ("Starting board:");
  (try while (not (!quit) && (isSolved () = false)) do
    try
  print_endline ("");
  printBoard ();
  playOneMove ();
    with Continue -> ()
  done with Break -> ());
  if isSolved () then (
  print_endline ((("You solved the puzzle in " ^ (string_of_int (!moves))) ^ " moves."));
  );
    !__ret
  with Return -> !__ret)

let rec main () =
  let __ret = ref () in
  (try
  shuffle (50);
  play ();
    !__ret
  with Return -> !__ret)

let () =
  main ();
