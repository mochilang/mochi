(* Generated by Mochi transpiler v0.10.42 on 2025-07-27 17:37 UTC *)


let rec __show v =
  let open Obj in
  let rec list_aux o =
    if is_int o && (magic (obj o) : int) = 0 then "" else
      let hd = field o 0 in
      let tl = field o 1 in
      let rest = list_aux tl in
      if rest = "" then __show (obj hd) else __show (obj hd) ^ "; " ^ rest
  in
  let r = repr v in
  if is_int r then string_of_int (magic v) else
  match tag r with
  | 0 -> if size r = 0 then "[]" else "[" ^ list_aux r ^ "]"
  | 252 -> (magic v : string)
  | 253 -> string_of_float (magic v)
  | _ -> "<value>"


let nil = Obj.repr 0

exception Break
exception Continue

exception Return

let epsilon = 0.000000000000001
let rec absf x =
  let __ret = ref 0.0 in
  (try
  let x = (Obj.magic x : float) in
  if (x < 0.0) then (
  __ret := (Obj.magic ((-.(x))) : float); raise Return
  );
  __ret := (Obj.magic (x) : float); raise Return
  with Return -> !__ret)

let rec pow10 n =
  let __ret = ref 0.0 in
  (try
  let n = (Obj.magic n : int) in
  let r = ref (1.0) in
  let i = ref (0) in
  (try while (!i < n) do
    try
  r := (!r *. 10.0);
  i := (!i + 1);
    with Continue -> ()
  done with Break -> ());
  __ret := (Obj.magic (!r) : float); raise Return
  with Return -> !__ret)

let rec formatFloat f prec =
  let __ret = ref "" in
  (try
  let f = (Obj.magic f : float) in
  let prec = (Obj.magic prec : int) in
  let scale = pow10 (prec) in
  let scaled = ((f *. scale) +. 0.5) in
  let n = ref ((Obj.magic scaled : int)) in
  let digits = ref ((string_of_int (!n))) in
  (try while (String.length (!digits) <= prec) do
    try
  digits := ("0" ^ !digits);
    with Continue -> ()
  done with Break -> ());
  let intPart = String.sub (!digits) 0 ((String.length (!digits) - prec) - 0) in
  let fracPart = String.sub (!digits) (String.length (!digits) - prec) (String.length (!digits) - (String.length (!digits) - prec)) in
  __ret := (Obj.magic (((intPart ^ ".") ^ fracPart)) : string); raise Return
  with Return -> !__ret)

let factval = ref (1)
let e = ref (2.0)
let n = ref (2)
let term = ref (1.0)
let () =
  (try while true do
    try
  factval := (!factval * !n);
  n := (!n + 1);
  term := (1.0 /. float_of_int (!factval));
  e := (!e +. !term);
  if (absf (!term) < epsilon) then (
  raise Break;
  );
    with Continue -> ()
  done with Break -> ());
  print_endline (("e = " ^ formatFloat (!e) (15)));
