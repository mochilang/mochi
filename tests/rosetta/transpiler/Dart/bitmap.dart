// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

class Pixel {
  int R;
  int G;
  int B;
  Pixel({required this.R, required this.G, required this.B});
}

class Bitmap {
  int cols;
  int rows;
  List<List<Pixel>> px;
  Bitmap({required this.cols, required this.rows, required this.px});
}

void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  Pixel pixelFromRgb(int c) {
  final int r = (c ~/ 65536 as int) % 256;
  final int g = (c ~/ 256 as int) % 256;
  final int b = c % 256;
  return Pixel(R: r, G: g, B: b);
}
  int rgbFromPixel(Pixel p) {
  return p.R * 65536 + p.G * 256 + p.B;
}
  Bitmap NewBitmap(int x, int y) {
  List<List<Pixel>> data = [];
  int row = 0;
  while (row < y) {
    List<Pixel> r = [];
    int col = 0;
    while (col < x) {
    r = [...r, Pixel(R: 0, G: 0, B: 0)];
    col = col + 1;
  }
    data = [...data, r];
    row = row + 1;
  }
  return Bitmap(cols: x, rows: y, px: data);
}
  Map<String, int> Extent(Bitmap b) {
  return {"cols": b.cols, "rows": b.rows};
}
  void Fill(Bitmap b, Pixel p) {
  int y = 0;
  while (y < b.rows) {
    int x = 0;
    while (x < b.cols) {
    List<List<Pixel>> px = b.px;
    List<Pixel> row = px[y];
    row[x] = p;
    px[y] = row;
    b.px = px;
    x = x + 1;
  }
    y = y + 1;
  }
}
  void FillRgb(Bitmap b, int c) {
  Fill(b, pixelFromRgb(c));
}
  bool SetPx(Bitmap b, int x, int y, Pixel p) {
  if (x < 0 || x >= b.cols || y < 0 || y >= b.rows) {
    return false;
  }
  List<List<Pixel>> px = b.px;
  List<Pixel> row = px[y];
  row[x] = p;
  px[y] = row;
  b.px = px;
  return true;
}
  bool SetPxRgb(Bitmap b, int x, int y, int c) {
  return SetPx(b, x, y, pixelFromRgb(c));
}
  Map<String, dynamic> GetPx(Bitmap b, int x, int y) {
  if (x < 0 || x >= b.cols || y < 0 || y >= b.rows) {
    return {"ok": false};
  }
  final List<Pixel> row = b.px[y];
  return {"ok": true, "pixel": row[x]};
}
  Map<String, dynamic> GetPxRgb(Bitmap b, int x, int y) {
  final Map<String, dynamic> r = GetPx(b, x, y);
  if (!r["ok"]) {
    return {"ok": false};
  }
  return {"ok": true, "rgb": rgbFromPixel(r["pixel"])};
}
  int ppmSize(Bitmap b) {
  final String header = "P6\n# Creator: Rosetta Code http://rosettacode.org/\n" + (b.cols).toString() + " " + (b.rows).toString() + "\n255\n";
  return header.length + 3 * b.cols * b.rows;
}
  String pixelStr(Pixel p) {
  return "{" + (p.R).toString() + " " + (p.G).toString() + " " + (p.B).toString() + "}";
}
  void main() {
  Bitmap bm = NewBitmap(300, 240);
  FillRgb(bm, 16711680);
  SetPxRgb(bm, 10, 20, 255);
  SetPxRgb(bm, 20, 30, 0);
  SetPxRgb(bm, 30, 40, 1056816);
  final Map<String, dynamic> c1 = GetPx(bm, 0, 0);
  final Map<String, dynamic> c2 = GetPx(bm, 10, 20);
  final Map<String, dynamic> c3 = GetPx(bm, 30, 40);
  print("Image size: " + (bm.cols).toString() + " Ã— " + (bm.rows).toString());
  print((ppmSize(bm)).toString() + " bytes when encoded as PPM.");
  if (c1["ok"]) {
    print("Pixel at (0,0) is " + pixelStr(c1["pixel"]));
  }
  if (c2["ok"]) {
    print("Pixel at (10,20) is " + pixelStr(c2["pixel"]));
  }
  if (c3["ok"]) {
    final p = c3["pixel"];
    num r16 = p.R * 257;
    num g16 = p.G * 257;
    num b16 = p.B * 257;
    print("Pixel at (30,40) has R=" + (r16).toString() + ", G=" + (g16).toString() + ", B=" + (b16).toString());
  }
}
  main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
