// Generated by Mochi transpiler
String _substr(String s, int start, int end) {
  var n = s.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (start > n) start = n;
  if (end < 0) end = 0;
  if (end > n) end = n;
  if (start > end) start = end;
  return s.substring(start, end);
}

String _repeat(String s, int n) => List.filled(n, s).join();

int _parseIntStr(String s, int r) => int.parse(s, radix: r);

class BigRat {
  BigInt num;
  BigInt den;
  BigRat(this.num, [BigInt? d]) : den = d ?? BigInt.one {
    if (den.isNegative) { num = -num; den = -den; }
    var g = num.gcd(den);
    num = num ~/ g;
    den = den ~/ g;
  }
  BigRat add(BigRat o) => BigRat(num * o.den + o.num * den, den * o.den);
  BigRat sub(BigRat o) => BigRat(num * o.den - o.num * den, den * o.den);
  BigRat mul(BigRat o) => BigRat(num * o.num, den * o.den);
  BigRat div(BigRat o) => BigRat(num * o.den, den * o.num);
}

BigRat _bigrat(dynamic n, [dynamic d]) {
  if (n is BigRat && d == null) return BigRat(n.num, n.den);
  BigInt numer;
  BigInt denom = d == null ? BigInt.one : (d is BigInt ? d : BigInt.from((d as num).toInt()));
  if (n is BigRat) { numer = n.num; denom = n.den; }
  else if (n is BigInt) { numer = n; }
  else if (n is int) { numer = BigInt.from(n); }
  else if (n is num) { numer = BigInt.from(n.toInt()); }
  else { numer = BigInt.zero; }
  return BigRat(numer, denom);
}
BigInt _num(BigRat r) => r.num;
BigInt _denom(BigRat r) => r.den;
BigRat _add(BigRat a, BigRat b) => a.add(b);
BigRat _sub(BigRat a, BigRat b) => a.sub(b);
BigRat _mul(BigRat a, BigRat b) => a.mul(b);
BigRat _div(BigRat a, BigRat b) => a.div(b);

BigRat bigrat(int a, int b) {
  return _div(_bigrat(a), _bigrat(b));
}

List<BigRat> calkinWilf(int n) {
  List<BigRat> seq = <BigRat>[];
  seq = [...seq, _bigrat(1, 1)];
  int i = 1;
  while (i < n) {
    BigRat prev = seq[i - 1];
    BigInt a = _num(prev);
    BigInt b = _denom(prev);
    BigInt f = a ~/ b;
    BigRat t = _bigrat(f, 1);
    t = _mul(t, _bigrat(2));
    t = _sub(t, prev);
    t = _add(t, _bigrat(1));
    t = _div(_bigrat(1), t);
    seq = [...seq, t];
    i = i + 1;
  }
  return seq;
}

List<int> toContinued(BigRat r) {
  BigInt a = _num(r);
  BigInt b = _denom(r);
  List<int> res = <int>[];
  while (true) {
    res = [...res, (a ~/ b).toInt()];
    BigInt t = a % b;
    a = b;
    b = t;
    if (a == BigInt.from(1)) {
    break;
  }
  }
  if (res.length % 2 == 0) {
    res[res.length - 1] = res[res.length - 1] - 1;
    res = [...res, 1];
  }
  return res;
}

int termNumber(List<int> cf) {
  String b = "";
  String d = "1";
  for (var n in cf) {
    b = _repeat(d, n) + b;
    if (d == "1") {
    d = "0";
  } else {
    d = "1";
  }
  }
  return _parseIntStr(b, 2);
}

String commatize(int n) {
  String s = (n).toString();
  String out = "";
  int i = 0;
  int cnt = 0;
  bool neg = false;
  if (_substr(s, 0, 1) == "-") {
    neg = true;
    s = _substr(s, 1, s.length);
  }
  i = s.length - 1;
  while (i >= 0) {
    out = _substr(s, i, i + 1) + out;
    cnt = cnt + 1;
    if (cnt == 3 && i != 0) {
    out = "," + out;
    cnt = 0;
  }
    i = i - 1;
  }
  if (neg) {
    out = "-" + out;
  }
  return out;
}

void main() {
  List<BigRat> cw = calkinWilf(20);
  print("The first 20 terms of the Calkin-Wilf sequnence are:");
  int i = 0;
  while (i < 20) {
    BigRat r = cw[i];
    String s = (_num(r)).toString();
    if (_denom(r) != BigInt.from(1)) {
    s = s + "/" + (_denom(r)).toString();
  }
    print((i + (1 as int)).toString().padLeft(2, " ") + ": " + s);
    i = i + 1;
  }
  BigRat r = _bigrat(83116, 51639);
  List<int> cf = toContinued(r);
  int tn = termNumber(cf);
  print("" + (_num(r)).toString() + "/" + (_denom(r)).toString() + " is the " + commatize(tn) + "th term of the sequence.");
}

void _start() {
  main();
}
