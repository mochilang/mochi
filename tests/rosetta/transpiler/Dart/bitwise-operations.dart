// Generated by Mochi transpiler
int toUnsigned16(int n) {
  int u = n;
  if (u < 0) {
    u = u + 65536;
  }
  return u % 65536;
}

String bin16(int n) {
  int u = toUnsigned16(n);
  String bits = "";
  int mask = 32768;
  for (int i = 0; i < 16; i++) {
    if (u >= mask) {
    bits = bits + "1";
    u = u - mask;
  } else {
    bits = bits + "0";
  }
    mask = mask ~/ 2 as int;
  }
  return bits;
}

int bit_and(int a, int b) {
  int ua = toUnsigned16(a);
  int ub = toUnsigned16(b);
  int res = 0;
  int bit = 1;
  for (int i = 0; i < 16; i++) {
    if (ua % 2 == 1 && ub % 2 == 1) {
    res = res + bit;
  }
    ua = ua ~/ 2 as int;
    ub = ub ~/ 2 as int;
    bit = bit * 2;
  }
  return res;
}

int bit_or(int a, int b) {
  int ua = toUnsigned16(a);
  int ub = toUnsigned16(b);
  int res = 0;
  int bit = 1;
  for (int i = 0; i < 16; i++) {
    if (ua % 2 == 1 || ub % 2 == 1) {
    res = res + bit;
  }
    ua = ua ~/ 2 as int;
    ub = ub ~/ 2 as int;
    bit = bit * 2;
  }
  return res;
}

int bit_xor(int a, int b) {
  int ua = toUnsigned16(a);
  int ub = toUnsigned16(b);
  int res = 0;
  int bit = 1;
  for (int i = 0; i < 16; i++) {
    final int abit = ua % 2;
    final int bbit = ub % 2;
    if (abit == 1 && bbit == 0 || abit == 0 && bbit == 1) {
    res = res + bit;
  }
    ua = ua ~/ 2 as int;
    ub = ub ~/ 2 as int;
    bit = bit * 2;
  }
  return res;
}

int bit_not(int a) {
  int ua = toUnsigned16(a);
  return 65535 - ua;
}

int shl(int a, int b) {
  int ua = toUnsigned16(a);
  int i = 0;
  while (i < b) {
    ua = ua * 2 % 65536;
    i = i + 1;
  }
  return ua;
}

int shr(int a, int b) {
  int ua = toUnsigned16(a);
  int i = 0;
  while (i < b) {
    ua = ua ~/ 2 as int;
    i = i + 1;
  }
  return ua;
}

int las(int a, int b) {
  return shl(a, b);
}

int ras(int a, int b) {
  int val = a;
  int i = 0;
  while (i < b) {
    if (val >= 0) {
    val = val ~/ 2 as int;
  } else {
    val = (val - 1) ~/ 2 as int;
  }
    i = i + 1;
  }
  return toUnsigned16(val);
}

int rol(int a, int b) {
  int ua = toUnsigned16(a);
  final int left = shl(ua, b);
  final int right = shr(ua, 16 - b);
  return toUnsigned16(left + right);
}

int ror(int a, int b) {
  int ua = toUnsigned16(a);
  final int right = shr(ua, b);
  final int left = shl(ua, 16 - b);
  return toUnsigned16(left + right);
}

void bitwise(int a, int b) {
  print("a:   " + bin16(a));
  print("b:   " + bin16(b));
  print("and: " + bin16(bit_and(a, b)));
  print("or:  " + bin16(bit_or(a, b)));
  print("xor: " + bin16(bit_xor(a, b)));
  print("not: " + bin16(bit_not(a)));
  if (b < 0) {
    print("Right operand is negative, but all shifts require an unsigned right operand (shift distance).");
    return null;
  }
  print("shl: " + bin16(shl(a, b)));
  print("shr: " + bin16(shr(a, b)));
  print("las: " + bin16(las(a, b)));
  print("ras: " + bin16(ras(a, b)));
  print("rol: " + bin16(rol(a, b)));
  print("ror: " + bin16(ror(a, b)));
}

void main() {
  bitwise(-460, 6);
}
