// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, int start, int end) {
  var n = s.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (start > n) start = n;
  if (end < 0) end = 0;
  if (end > n) end = n;
  if (start > end) start = end;
  return s.substring(start, end);
}

class Board {
  List<List<int>> cells;
  Board({required this.cells});
}

class SpawnResult {
  Board board;
  bool full;
  SpawnResult({required this.board, required this.full});
}

class SlideResult {
  List<int> row;
  int gain;
  SlideResult({required this.row, required this.gain});
}

class MoveResult {
  Board board;
  int score;
  bool moved;
  MoveResult({required this.board, required this.score, required this.moved});
}

int SIZE = 4;
Board newBoard() {
  List<List<int>> b = <List<int>>[];
  dynamic y = 0;
  while (y < SIZE) {
    List<int> row = <int>[];
    dynamic x = 0;
    while (x < SIZE) {
    row = [...row, 0];
    x = x + 1;
  }
    b = ([...b, row] as List).map((e) => (e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList()).toList();
    y = y + 1;
  }
  return Board(cells: b);
}

SpawnResult spawnTile(Board b) {
  dynamic grid = b.cells;
  List<List<int>> empty = <List<int>>[];
  dynamic y = 0;
  while (y < SIZE) {
    dynamic x = 0;
    while (x < SIZE) {
    if (grid[(y).toInt()][(x).toInt()] == 0) {
    empty = [...empty, [x, y]];
  }
    x = x + 1;
  }
    y = y + 1;
  }
  if (empty.length == 0) {
    return SpawnResult(board: b, full: true);
  }
  dynamic idx = _now() % empty.length;
  List<int> cell = empty[(idx).toInt()];
  dynamic val = 4;
  if (_now() % 10 < 9) {
    val = 2;
  }
  grid[cell[1]]![cell[0]] = val;
  return SpawnResult(board: Board(cells: grid), full: empty.length == 1);
}

String pad(int n) {
  dynamic s = (n).toString();
  dynamic pad = 4 - s.length;
  dynamic i = 0;
  dynamic out = "";
  while (i < pad) {
    out = out + " ";
    i = i + 1;
  }
  return out + s;
}

void draw(Board b, int score) {
  print("Score: " + (score).toString());
  dynamic y = 0;
  while (y < SIZE) {
    print("+----+----+----+----+");
    dynamic line = "|";
    dynamic x = 0;
    while (x < SIZE) {
    dynamic v = b.cells[(y).toInt()][(x).toInt()];
    if (v == 0) {
    line = line + "    |";
  } else {
    line = line + pad(v) + "|";
  }
    x = x + 1;
  }
    print(line);
    y = y + 1;
  }
  print("+----+----+----+----+");
  print("W=Up S=Down A=Left D=Right Q=Quit");
}

List<int> reverseRow(List<int> r) {
  List<int> out = <int>[];
  dynamic i = r.length - 1;
  while (i >= 0) {
    out = [...out, r[(i).toInt()]];
    i = i - 1;
  }
  return out;
}

SlideResult slideLeft(List<int> row) {
  List<int> xs = <int>[];
  dynamic i = 0;
  while (i < row.length) {
    if (row[(i).toInt()] != 0) {
    xs = [...xs, row[(i).toInt()]];
  }
    i = i + 1;
  }
  List<int> res = <int>[];
  dynamic gain = 0;
  i = 0;
  while (i < xs.length) {
    if (i + 1 < xs.length && xs[(i).toInt()] == xs[(i + 1).toInt()]) {
    int v = xs[(i).toInt()] * 2;
    gain = gain + v;
    res = [...res, v];
    i = i + 2;
  } else {
    res = [...res, xs[(i).toInt()]];
    i = i + 1;
  }
  }
  while (res.length < SIZE) {
    res = [...res, 0];
  }
  return SlideResult(row: res, gain: gain);
}

MoveResult moveLeft(Board b, int score) {
  dynamic grid = b.cells;
  dynamic moved = false;
  dynamic y = 0;
  while (y < SIZE) {
    SlideResult r = slideLeft(grid[(y).toInt()]);
    List<int> _new = r.row;
    score = score + r.gain;
    dynamic x = 0;
    while (x < SIZE) {
    if (grid[(y).toInt()][(x).toInt()] != _new[(x).toInt()]) {
    moved = true;
  }
    grid[(y).toInt()]![(x).toInt()] = _new[(x).toInt()];
    x = x + 1;
  }
    y = y + 1;
  }
  return MoveResult(board: Board(cells: grid), score: score, moved: moved);
}

MoveResult moveRight(Board b, int score) {
  dynamic grid = b.cells;
  dynamic moved = false;
  dynamic y = 0;
  while (y < SIZE) {
    dynamic rev = reverseRow(grid[(y).toInt()]);
    SlideResult r = slideLeft(rev);
    rev = r.row;
    score = score + r.gain;
    rev = reverseRow(rev);
    dynamic x = 0;
    while (x < SIZE) {
    if (grid[(y).toInt()][(x).toInt()] != rev[(x).toInt()]) {
    moved = true;
  }
    grid[(y).toInt()]![(x).toInt()] = rev[(x).toInt()];
    x = x + 1;
  }
    y = y + 1;
  }
  return MoveResult(board: Board(cells: grid), score: score, moved: moved);
}

List<int> getCol(Board b, int x) {
  List<int> col = <int>[];
  dynamic y = 0;
  while (y < SIZE) {
    col = [...col, b.cells[(y).toInt()][x]];
    y = y + 1;
  }
  return col;
}

void setCol(Board b, int x, List<int> col) {
  dynamic rows = b.cells;
  dynamic y = 0;
  while (y < SIZE) {
    dynamic row = rows[(y).toInt()];
    row[x] = col[(y).toInt()];
    rows[(y).toInt()] = row;
    y = y + 1;
  }
  b.cells = (rows as List).map((e) => (e as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList()).toList();
}

MoveResult moveUp(Board b, int score) {
  dynamic grid = b.cells;
  dynamic moved = false;
  dynamic x = 0;
  while (x < SIZE) {
    dynamic col = getCol(b, x);
    SlideResult r = slideLeft(col);
    List<int> _new = r.row;
    score = score + r.gain;
    dynamic y = 0;
    while (y < SIZE) {
    if (grid[(y).toInt()][(x).toInt()] != _new[(y).toInt()]) {
    moved = true;
  }
    grid[(y).toInt()]![(x).toInt()] = _new[(y).toInt()];
    y = y + 1;
  }
    x = x + 1;
  }
  return MoveResult(board: Board(cells: grid), score: score, moved: moved);
}

MoveResult moveDown(Board b, int score) {
  dynamic grid = b.cells;
  dynamic moved = false;
  dynamic x = 0;
  while (x < SIZE) {
    dynamic col = reverseRow(getCol(b, x));
    SlideResult r = slideLeft(col);
    col = r.row;
    score = score + r.gain;
    col = reverseRow(col);
    dynamic y = 0;
    while (y < SIZE) {
    if (grid[(y).toInt()][(x).toInt()] != col[(y).toInt()]) {
    moved = true;
  }
    grid[(y).toInt()]![(x).toInt()] = col[(y).toInt()];
    y = y + 1;
  }
    x = x + 1;
  }
  return MoveResult(board: Board(cells: grid), score: score, moved: moved);
}

bool hasMoves(Board b) {
  dynamic y = 0;
  while (y < SIZE) {
    dynamic x = 0;
    while (x < SIZE) {
    if (b.cells[(y).toInt()][(x).toInt()] == 0) {
    return true;
  }
    if (x + 1 < SIZE && b.cells[(y).toInt()][(x).toInt()] == b.cells[(y).toInt()][(x + 1).toInt()]) {
    return true;
  }
    if (y + 1 < SIZE && b.cells[(y).toInt()][(x).toInt()] == b.cells[(y + 1).toInt()][(x).toInt()]) {
    return true;
  }
    x = x + 1;
  }
    y = y + 1;
  }
  return false;
}

bool has2048(Board b) {
  dynamic y = 0;
  while (y < SIZE) {
    dynamic x = 0;
    while (x < SIZE) {
    if (b.cells[(y).toInt()][(x).toInt()] >= 2048) {
    return true;
  }
    x = x + 1;
  }
    y = y + 1;
  }
  return false;
}

Board board = newBoard();
SpawnResult r = spawnTile(board);
bool full = r.full;
int score = 0;
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  board = r.board;
  r = spawnTile(board);
  board = r.board;
  full = r.full;
  draw(board, score);
  while (true) {
    print("Move: ");
    dynamic cmd = stdin.readLineSync() ?? '';
    dynamic moved = false;
    if (cmd == "a" || cmd == "A") {
    dynamic m = moveLeft(board, score);
    board = m.board;
    score = m.score;
    moved = m.moved;
  }
    if (cmd == "d" || cmd == "D") {
    dynamic m = moveRight(board, score);
    board = m.board;
    score = m.score;
    moved = m.moved;
  }
    if (cmd == "w" || cmd == "W") {
    dynamic m = moveUp(board, score);
    board = m.board;
    score = m.score;
    moved = m.moved;
  }
    if (cmd == "s" || cmd == "S") {
    dynamic m = moveDown(board, score);
    board = m.board;
    score = m.score;
    moved = m.moved;
  }
    if (cmd == "q" || cmd == "Q") {
    break;
  }
    if (moved) {
    dynamic r2 = spawnTile(board);
    board = r2.board;
    full = r2.full;
    if (full && !hasMoves(board)) {
    draw(board, score);
    print("Game Over");
    break;
  };
  }
    draw(board, score);
    if (has2048(board)) {
    print("You win!");
    break;
  }
    if (!hasMoves(board)) {
    print("Game Over");
    break;
  }
  }
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
