// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

class Board {
  List<List<int>> cells;
  Board({required this.cells});
}

class SpawnResult {
  Board board;
  bool full;
  SpawnResult({required this.board, required this.full});
}

class SlideResult {
  List<int> row;
  int gain;
  SlideResult({required this.row, required this.gain});
}

class MoveResult {
  Board board;
  int score;
  bool moved;
  MoveResult({required this.board, required this.score, required this.moved});
}

void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  final int SIZE = 4;
  Board newBoard() {
  List<List<int>> b = [];
  int y = 0;
  while (y < SIZE) {
    List<int> row = [];
    int x = 0;
    while (x < SIZE) {
    row = [...row, 0];
    x = x + 1;
  }
    b = [...b, row];
    y = y + 1;
  }
  return Board(cells: b);
}
  SpawnResult spawnTile(Board b) {
  List<List<int>> grid = b.cells;
  List<List<int>> empty = [];
  int y = 0;
  while (y < SIZE) {
    int x = 0;
    while (x < SIZE) {
    if (grid[y]![x] == 0) {
    empty = [...empty, [x, y]];
  }
    x = x + 1;
  }
    y = y + 1;
  }
  if (empty.length == 0) {
    return SpawnResult(board: b, full: true);
  }
  int idx = _now() % empty.length;
  final List<int> cell = empty[idx];
  int val = 4;
  if (_now() % 10 < 9) {
    val = 2;
  }
  grid[cell[1]]![cell[0]] = val;
  return SpawnResult(board: Board(cells: grid), full: empty.length == 1);
}
  String pad(int n) {
  String s = (n).toString();
  int pad = 4 - s.length;
  int i = 0;
  String out = "";
  while (i < pad) {
    out = out + " ";
    i = i + 1;
  }
  return out + s;
}
  void draw(Board b, int score) {
  print("Score: " + (score).toString());
  int y = 0;
  while (y < SIZE) {
    print("+----+----+----+----+");
    String line = "|";
    int x = 0;
    while (x < SIZE) {
    int v = b.cells[y]![x];
    if (v == 0) {
    line = line + "    |";
  } else {
    line = line + pad(v) + "|";
  }
    x = x + 1;
  }
    print(line);
    y = y + 1;
  }
  print("+----+----+----+----+");
  print("W=Up S=Down A=Left D=Right Q=Quit");
}
  List<int> reverseRow(List<int> r) {
  List<int> out = [];
  int i = r.length - 1;
  while (i >= 0) {
    out = [...out, r[i]];
    i = i - 1;
  }
  return out;
}
  SlideResult slideLeft(List<int> row) {
  List<int> xs = [];
  int i = 0;
  while (i < row.length) {
    if (row[i] != 0) {
    xs = [...xs, row[i]];
  }
    i = i + 1;
  }
  List<int> res = [];
  int gain = 0;
  i = 0;
  while (i < xs.length) {
    if (i + 1 < xs.length && xs[i] == xs[i + 1]) {
    final int v = xs[i] * 2;
    gain = gain + v;
    res = [...res, v];
    i = i + 2;
  } else {
    res = [...res, xs[i]];
    i = i + 1;
  }
  }
  while (res.length < SIZE) {
    res = [...res, 0];
  }
  return SlideResult(row: res, gain: gain);
}
  MoveResult moveLeft(Board b, int score) {
  List<List<int>> grid = b.cells;
  bool moved = false;
  int y = 0;
  while (y < SIZE) {
    final SlideResult r = slideLeft(grid[y]);
    final List<int> _new = r.row;
    score = score + r.gain;
    int x = 0;
    while (x < SIZE) {
    if (grid[y]![x] != _new[x]) {
    moved = true;
  }
    grid[y]![x] = _new[x];
    x = x + 1;
  }
    y = y + 1;
  }
  return MoveResult(board: Board(cells: grid), score: score, moved: moved);
}
  MoveResult moveRight(Board b, int score) {
  List<List<int>> grid = b.cells;
  bool moved = false;
  int y = 0;
  while (y < SIZE) {
    List<int> rev = reverseRow(grid[y]);
    final SlideResult r = slideLeft(rev);
    rev = r.row;
    score = score + r.gain;
    rev = reverseRow(rev);
    int x = 0;
    while (x < SIZE) {
    if (grid[y]![x] != rev[x]) {
    moved = true;
  }
    grid[y]![x] = rev[x];
    x = x + 1;
  }
    y = y + 1;
  }
  return MoveResult(board: Board(cells: grid), score: score, moved: moved);
}
  List<int> getCol(Board b, int x) {
  List<int> col = [];
  int y = 0;
  while (y < SIZE) {
    col = [...col, b.cells[y]![x]];
    y = y + 1;
  }
  return col;
}
  void setCol(Board b, int x, List<int> col) {
  List<List<int>> rows = b.cells;
  int y = 0;
  while (y < SIZE) {
    List<int> row = rows[y];
    row[x] = col[y];
    rows[y] = row;
    y = y + 1;
  }
  b.cells = rows;
}
  MoveResult moveUp(Board b, int score) {
  List<List<int>> grid = b.cells;
  bool moved = false;
  int x = 0;
  while (x < SIZE) {
    List<int> col = getCol(b, x);
    final SlideResult r = slideLeft(col);
    final List<int> _new = r.row;
    score = score + r.gain;
    int y = 0;
    while (y < SIZE) {
    if (grid[y]![x] != _new[y]) {
    moved = true;
  }
    grid[y]![x] = _new[y];
    y = y + 1;
  }
    x = x + 1;
  }
  return MoveResult(board: Board(cells: grid), score: score, moved: moved);
}
  MoveResult moveDown(Board b, int score) {
  List<List<int>> grid = b.cells;
  bool moved = false;
  int x = 0;
  while (x < SIZE) {
    List<int> col = reverseRow(getCol(b, x));
    final SlideResult r = slideLeft(col);
    col = r.row;
    score = score + r.gain;
    col = reverseRow(col);
    int y = 0;
    while (y < SIZE) {
    if (grid[y]![x] != col[y]) {
    moved = true;
  }
    grid[y]![x] = col[y];
    y = y + 1;
  }
    x = x + 1;
  }
  return MoveResult(board: Board(cells: grid), score: score, moved: moved);
}
  bool hasMoves(Board b) {
  int y = 0;
  while (y < SIZE) {
    int x = 0;
    while (x < SIZE) {
    if (b.cells[y]![x] == 0) {
    return true;
  }
    if (x + 1 < SIZE && b.cells[y]![x] == b.cells[y]![x + 1]) {
    return true;
  }
    if (y + 1 < SIZE && b.cells[y]![x] == b.cells[y + 1]![x]) {
    return true;
  }
    x = x + 1;
  }
    y = y + 1;
  }
  return false;
}
  bool has2048(Board b) {
  int y = 0;
  while (y < SIZE) {
    int x = 0;
    while (x < SIZE) {
    if (b.cells[y]![x] >= 2048) {
    return true;
  }
    x = x + 1;
  }
    y = y + 1;
  }
  return false;
}
  Board board = newBoard();
  SpawnResult r = spawnTile(board);
  board = r.board;
  bool full = r.full;
  r = spawnTile(board);
  board = r.board;
  full = r.full;
  int score = 0;
  draw(board, score);
  while (true) {
    print("Move: ");
    final String cmd = stdin.readLineSync() ?? '';
    bool moved = false;
    if (cmd == "a" || cmd == "A") {
    final MoveResult m = moveLeft(board, score);
    board = m.board;
    score = m.score;
    moved = m.moved;
  }
    if (cmd == "d" || cmd == "D") {
    final MoveResult m = moveRight(board, score);
    board = m.board;
    score = m.score;
    moved = m.moved;
  }
    if (cmd == "w" || cmd == "W") {
    final MoveResult m = moveUp(board, score);
    board = m.board;
    score = m.score;
    moved = m.moved;
  }
    if (cmd == "s" || cmd == "S") {
    final MoveResult m = moveDown(board, score);
    board = m.board;
    score = m.score;
    moved = m.moved;
  }
    if (cmd == "q" || cmd == "Q") {
    break;
  }
    if (moved) {
    final SpawnResult r2 = spawnTile(board);
    board = r2.board;
    full = r2.full;
    if (full && !hasMoves(board)) {
    draw(board, score);
    print("Game Over");
    break;
  };
  }
    draw(board, score);
    if (has2048(board)) {
    print("You win!");
    break;
  }
    if (!hasMoves(board)) {
    print("Game Over");
    break;
  }
  }
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
