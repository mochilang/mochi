// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, int start, int end) {
  var n = s.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (start > n) start = n;
  if (end < 0) end = 0;
  if (end > n) end = n;
  if (start > end) start = end;
  return s.substring(start, end);
}

class Point {
  num x;
  num y;
  Point({required this.x, required this.y});
}

class QuadSpline {
  num c0;
  num c1;
  num c2;
  QuadSpline({required this.c0, required this.c1, required this.c2});
}

class QuadCurve {
  QuadSpline x;
  QuadSpline y;
  QuadCurve({required this.x, required this.y});
}

num absf(num x) {
  if (x < 0.0) {
    return -x;
  }
  return x;
}

num maxf(num a, num b) {
  if (a > b) {
    return a;
  }
  return b;
}

num minf(num a, num b) {
  if (a < b) {
    return a;
  }
  return b;
}

num max3(num a, num b, num c) {
  num m = a;
  if (b > m) {
    m = b;
  }
  if (c > m) {
    m = c;
  }
  return m;
}

num min3(num a, num b, num c) {
  num m = a;
  if (b < m) {
    m = b;
  }
  if (c < m) {
    m = c;
  }
  return m;
}

List<QuadSpline> subdivideQuadSpline(QuadSpline q, num t) {
  num s = 1.0 - t;
  QuadSpline u = QuadSpline(c0: q.c0, c1: 0.0, c2: 0.0);
  QuadSpline v = QuadSpline(c0: 0.0, c1: 0.0, c2: q.c2);
  u.c1 = s * q.c0 + t * q.c1;
  v.c1 = s * q.c1 + t * q.c2;
  u.c2 = s * u.c1 + t * v.c1;
  v.c0 = u.c2;
  return [u, v];
}

List<QuadCurve> subdivideQuadCurve(QuadCurve q, num t) {
  List<QuadSpline> xs = subdivideQuadSpline(q.x, t);
  List<QuadSpline> ys = subdivideQuadSpline(q.y, t);
  QuadCurve u = QuadCurve(x: xs[0], y: ys[0]);
  QuadCurve v = QuadCurve(x: xs[1], y: ys[1]);
  return [u, v];
}

bool rectsOverlap(num xa0, num ya0, num xa1, num ya1, num xb0, num yb0, num xb1, num yb1) {
  return xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1;
}

Map<String, dynamic> testIntersect(QuadCurve p, QuadCurve q, num tol) {
  num pxmin = min3(p.x.c0, p.x.c1, p.x.c2);
  num pymin = min3(p.y.c0, p.y.c1, p.y.c2);
  num pxmax = max3(p.x.c0, p.x.c1, p.x.c2);
  num pymax = max3(p.y.c0, p.y.c1, p.y.c2);
  num qxmin = min3(q.x.c0, q.x.c1, q.x.c2);
  num qymin = min3(q.y.c0, q.y.c1, q.y.c2);
  num qxmax = max3(q.x.c0, q.x.c1, q.x.c2);
  num qymax = max3(q.y.c0, q.y.c1, q.y.c2);
  bool exclude = true;
  bool accept = false;
  Point inter = Point(x: 0.0, y: 0.0);
  if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
    exclude = false;
    num xmin = maxf(pxmin, qxmin);
    num xmax = minf(pxmax, qxmax);
    if (xmax - xmin <= tol) {
    num ymin = maxf(pymin, qymin);
    num ymax = minf(pymax, qymax);
    if (ymax - ymin <= tol) {
    accept = true;
    inter.x = 0.5 * (xmin + xmax);
    inter.y = 0.5 * (ymin + ymax);
  };
  };
  }
  return {"exclude": exclude, "accept": accept, "intersect": inter};
}

bool seemsToBeDuplicate(List<Point> pts, Point xy, num spacing) {
  int i = 0;
  while (i < pts.length) {
    Point pt = pts[i];
    if (absf(pt.x - xy.x) < spacing && absf(pt.y - xy.y) < spacing) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

List<Point> findIntersects(QuadCurve p, QuadCurve q, num tol, num spacing) {
  List<Point> inters = <Point>[];
  List<Map<String, QuadCurve>> workload = [{"p": p, "q": q}];
  while (workload.length > 0) {
    int idx = workload.length - 1;
    Map<String, QuadCurve> work = workload[idx];
    workload = workload.sublist(0, idx);
    Map<String, dynamic> res = testIntersect(work["p"]!, work["q"]!, tol);
    dynamic excl = res["exclude"];
    dynamic acc = res["accept"];
    Point inter = res["intersect"] as Point;
    if (acc) {
    if (!seemsToBeDuplicate(inters, inter, spacing)) {
    inters = [...inters, inter];
  };
  } else {
    if (!excl) {
    List<QuadCurve> ps = subdivideQuadCurve(work["p"]!, 0.5);
    List<QuadCurve> qs = subdivideQuadCurve(work["q"]!, 0.5);
    QuadCurve p0 = ps[0];
    QuadCurve p1 = ps[1];
    QuadCurve q0 = qs[0];
    QuadCurve q1 = qs[1];
    workload = [...workload, {"p": p0, "q": q0}];
    workload = [...workload, {"p": p0, "q": q1}];
    workload = [...workload, {"p": p1, "q": q0}];
    workload = [...workload, {"p": p1, "q": q1}];
  };
  }
  }
  return inters;
}

void _main() {
  QuadCurve p = QuadCurve(x: QuadSpline(c0: -1.0, c1: 0.0, c2: 1.0), y: QuadSpline(c0: 0.0, c1: 10.0, c2: 0.0));
  QuadCurve q = QuadCurve(x: QuadSpline(c0: 2.0, c1: -8.0, c2: 2.0), y: QuadSpline(c0: 1.0, c1: 2.0, c2: 3.0));
  num tol = 0.0000001;
  num spacing = tol * 10.0;
  List<Point> inters = findIntersects(p, q, tol, spacing);
  int i = 0;
  while (i < inters.length) {
    Point pt = inters[i];
    print("(" + (pt.x).toString() + ", " + (pt.y).toString() + ")");
    i = i + 1;
  }
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
