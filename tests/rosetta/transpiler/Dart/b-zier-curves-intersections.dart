// Generated by Mochi transpiler
class Point {
  num x;
  num y;
  Point({required this.x, required this.y});
}

class QuadSpline {
  num c0;
  num c1;
  num c2;
  QuadSpline({required this.c0, required this.c1, required this.c2});
}

class QuadCurve {
  QuadSpline x;
  QuadSpline y;
  QuadCurve({required this.x, required this.y});
}

num absf(num x) {
  if (x < 0.0) {
    return -x;
  }
  return x;
}

num maxf(num a, num b) {
  if (a > b) {
    return a;
  }
  return b;
}

num minf(num a, num b) {
  if (a < b) {
    return a;
  }
  return b;
}

num max3(num a, num b, num c) {
  num m = a;
  if (b > m) {
    m = b;
  }
  if (c > m) {
    m = c;
  }
  return m;
}

num min3(num a, num b, num c) {
  num m = a;
  if (b < m) {
    m = b;
  }
  if (c < m) {
    m = c;
  }
  return m;
}

List<QuadSpline> subdivideQuadSpline(QuadSpline q, num t) {
  final num s = 1.0 - t;
  QuadSpline u = QuadSpline(c0: q.c0, c1: 0.0, c2: 0.0);
  QuadSpline v = QuadSpline(c0: 0.0, c1: 0.0, c2: q.c2);
  u.c1 = s * q.c0 + t * q.c1;
  v.c1 = s * q.c1 + t * q.c2;
  u.c2 = s * u.c1 + t * v.c1;
  v.c0 = u.c2;
  return [u, v];
}

List<QuadCurve> subdivideQuadCurve(QuadCurve q, num t) {
  final List<QuadSpline> xs = subdivideQuadSpline(q.x, t);
  final List<QuadSpline> ys = subdivideQuadSpline(q.y, t);
  QuadCurve u = QuadCurve(x: xs[0], y: ys[0]);
  QuadCurve v = QuadCurve(x: xs[1], y: ys[1]);
  return [u, v];
}

bool rectsOverlap(num xa0, num ya0, num xa1, num ya1, num xb0, num yb0, num xb1, num yb1) {
  return xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1;
}

Map<String, dynamic> testIntersect(QuadCurve p, QuadCurve q, num tol) {
  final num pxmin = min3(p.x.c0, p.x.c1, p.x.c2);
  final num pymin = min3(p.y.c0, p.y.c1, p.y.c2);
  final num pxmax = max3(p.x.c0, p.x.c1, p.x.c2);
  final num pymax = max3(p.y.c0, p.y.c1, p.y.c2);
  final num qxmin = min3(q.x.c0, q.x.c1, q.x.c2);
  final num qymin = min3(q.y.c0, q.y.c1, q.y.c2);
  final num qxmax = max3(q.x.c0, q.x.c1, q.x.c2);
  final num qymax = max3(q.y.c0, q.y.c1, q.y.c2);
  bool exclude = true;
  bool accept = false;
  Point inter = Point(x: 0.0, y: 0.0);
  if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
    exclude = false;
    final num xmin = maxf(pxmin, qxmin);
    final num xmax = minf(pxmax, qxmax);
    if (xmax - xmin <= tol) {
    final num ymin = maxf(pymin, qymin);
    final num ymax = minf(pymax, qymax);
    if (ymax - ymin <= tol) {
    accept = true;
    inter.x = 0.5 * (xmin + xmax);
    inter.y = 0.5 * (ymin + ymax);
  };
  };
  }
  return {"exclude": exclude, "accept": accept, "intersect": inter};
}

bool seemsToBeDuplicate(List<Point> pts, Point xy, num spacing) {
  int i = 0;
  while (i < pts.length) {
    final Point pt = pts[i];
    if (absf(pt.x - xy.x) < spacing && absf(pt.y - xy.y) < spacing) {
    return true;
  }
    i = i + 1;
  }
  return false;
}

List<Point> findIntersects(QuadCurve p, QuadCurve q, num tol, num spacing) {
  List<Point> inters = [];
  List<Map<String, QuadCurve>> workload = [{"p": p, "q": q}];
  while (workload.length > 0) {
    final int idx = workload.length - 1;
    final Map<String, QuadCurve> work = workload[idx];
    workload = workload.sublist(0, idx);
    final Map<String, dynamic> res = testIntersect(work["p"]!, work["q"]!, tol);
    final excl = res["exclude"]!;
    final acc = res["accept"]!;
    final Point inter = res["intersect"]!! as Point;
    if (acc) {
    if (!seemsToBeDuplicate(inters, inter, spacing)) {
    inters = [...inters, inter];
  };
  } else {
    if (!excl) {
    final List<QuadCurve> ps = subdivideQuadCurve(work["p"]!, 0.5);
    final List<QuadCurve> qs = subdivideQuadCurve(work["q"]!, 0.5);
    final QuadCurve p0 = ps[0];
    final QuadCurve p1 = ps[1];
    final QuadCurve q0 = qs[0];
    final QuadCurve q1 = qs[1];
    workload = [...workload, {"p": p0, "q": q0}];
    workload = [...workload, {"p": p0, "q": q1}];
    workload = [...workload, {"p": p1, "q": q0}];
    workload = [...workload, {"p": p1, "q": q1}];
  };
  }
  }
  return inters;
}

void main() {
  final QuadCurve p = QuadCurve(x: QuadSpline(c0: -1.0, c1: 0.0, c2: 1.0), y: QuadSpline(c0: 0.0, c1: 10.0, c2: 0.0));
  final QuadCurve q = QuadCurve(x: QuadSpline(c0: 2.0, c1: -8.0, c2: 2.0), y: QuadSpline(c0: 1.0, c1: 2.0, c2: 3.0));
  final num tol = 0.0000001;
  final num spacing = tol * 10.0;
  final List<Point> inters = findIntersects(p, q, tol, spacing);
  int i = 0;
  while (i < inters.length) {
    final Point pt = inters[i];
    print("(" + (pt.x).toString() + ", " + (pt.y).toString() + ")");
    i = i + 1;
  }
}

void _start() {
  main();
}
