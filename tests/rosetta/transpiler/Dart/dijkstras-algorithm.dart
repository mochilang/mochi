// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, int start, int end) {
  var n = s.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (start > n) start = n;
  if (end < 0) end = 0;
  if (end > n) end = n;
  if (start > end) start = end;
  return s.substring(start, end);
}

int INF = 1000000000;
Map<String, Map<String, int>> graph = <String, Map<String, int>>{};
void addEdge(String u, String v, int w) {
  if (!graph.containsKey(u)) {
    graph[u] = <String, int>{};
  }
  graph[u]![v] = w;
  if (!graph.containsKey(v)) {
    graph[v] = <String, int>{};
  }
}

List<String> removeAt(List<String> xs, int idx) {
  List<String> out = <String>[];
  int i = 0;
  for (String x in xs) {
    if (i != idx) {
    out = [...out, x];
  }
    i = i + 1;
  }
  return out;
}

Map<String, dynamic> dijkstra(String source) {
  Map<String, int> dist = <String, int>{};
  Map<String, String> prev = <String, String>{};
  for (String v in graph!.keys) {
    dist[v] = INF;
    prev[v] = "";
  }
  dist[source] = 0;
  List<String> q = <String>[];
  for (String v in graph!.keys) {
    q = [...q, v];
  }
  while (q.length > 0) {
    int bestIdx = 0;
    String u = q[0];
    int i = 1;
    while (i < q.length) {
    String v = q[i];
    if ((dist[v] ?? 0) < (dist[u] ?? 0)) {
    u = v;
    bestIdx = i;
  }
    i = i + 1;
  }
    q = removeAt(q, bestIdx);
    for (var v in graph[u]!.keys) {
    num alt = (dist[u] ?? 0) + (graph[u]![v] ?? 0);
    if (alt < (dist[v] ?? 0)) {
    dist[v] = (alt).toInt();
    prev[v] = u;
  }
  }
  }
  return {"dist": dist, "prev": prev};
}

String path(Map<String, String> prev, String v) {
  String s = v;
  String cur = v;
  while ((prev[cur] ?? "") != "") {
    cur = (prev[cur] ?? "");
    s = cur + s;
  }
  return s;
}

void _main() {
  addEdge("a", "b", 7);
  addEdge("a", "c", 9);
  addEdge("a", "f", 14);
  addEdge("b", "c", 10);
  addEdge("b", "d", 15);
  addEdge("c", "d", 11);
  addEdge("c", "f", 2);
  addEdge("d", "e", 6);
  addEdge("e", "f", 9);
  Map<String, dynamic> res = dijkstra("a");
  Map<String, int> dist = res["dist"]! as Map<String, int>;
  Map<String, String> prev = res["prev"]! as Map<String, String>;
  print("Distance to e: " + ((dist["e"] ?? 0)).toString() + ", Path: " + path(prev, "e"));
  print("Distance to f: " + ((dist["f"] ?? 0)).toString() + ", Path: " + path(prev, "f"));
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
