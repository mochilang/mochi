// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Instruction {
  String Label;
  String Opcode;
  String Arg;
  Instruction({required this.Label, required this.Opcode, required this.Arg});
}

String trim(String s) {
  int start = 0;
  while (start < s.length && (_substr(s, start, start + 1) == " " || _substr(s, start, start + 1) == "	")) {
    start = start + 1;
  }
  int end = s.length;
  while (end > start && (_substr(s, end - 1, end) == " " || _substr(s, end - 1, end) == "	")) {
    end = end - 1;
  }
  return _substr(s, start, end);
}

List<String> split(String s, String sep) {
  List<String> parts = <String>[];
  String cur = "";
  int i = 0;
  while (i < s.length) {
    if (sep.length > 0 && i + sep.length <= s.length && _substr(s, i, i + sep.length) == sep) {
    parts = [...parts, cur];
    cur = "";
    i = i + sep.length;
  } else {
    cur = cur + _substr(s, i, i + 1);
    i = i + 1;
  }
  }
  parts = [...parts, cur];
  return parts;
}

List<String> splitWS(String s) {
  List<String> out = <String>[];
  String cur = "";
  int i = 0;
  while (i < s.length) {
    String ch = _substr(s, i, i + 1);
    if (ch == " " || ch == "	") {
    if (cur.length > 0) {
    out = [...out, cur];
    cur = "";
  };
  } else {
    cur = cur + ch;
  }
    i = i + 1;
  }
  if (cur.length > 0) {
    out = [...out, cur];
  }
  return out;
}

int indexOf(String s, String ch) {
  int i = 0;
  while (i < s.length) {
    if (_substr(s, i, i + 1) == ch) {
    return i;
  }
    i = i + 1;
  }
  return -1;
}

int parseIntStr(String str) {
  int i = 0;
  bool neg = false;
  if (str.length > 0 && _substr(str, 0, 1) == "-") {
    neg = true;
    i = 1;
  }
  int n = 0;
  Map<String, int> digits = {"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9};
  while (i < str.length) {
    n = (n * 10 + digits[_substr(str, i, i + 1)]!).toInt();
    i = i + 1;
  }
  if (neg) {
    n = -n;
  }
  return n;
}

Map<String, dynamic> parseAsm(String asm) {
  dynamic lines = asm.split("\n");
  List<Instruction> instrs = <Instruction>[];
  Map<String, int> labels = <String, int>{};
  int lineNum = 0;
  int i = 0;
  while (i < lines.length) {
    dynamic line = lines[i];
    if (line.indexOf(";") != -1) {
    line = _substr(line, 0, line.indexOf(";"));
  }
    line = trim(line);
    String label = "";
    if (line.indexOf(":") != -1) {
    int idx = line.indexOf(":");
    label = trim(_substr(line, 0, idx));
    line = trim(_substr(line, idx + 1, line.length));
  }
    String opcode = "";
    String arg = "";
    if (line.length > 0) {
    List<String> parts = splitWS(line);
    if (parts.length > 0) {
    opcode = parts[0];
  };
    if (parts.length > 1) {
    arg = parts[1];
  } else {
    Map<String, int> ops = {"NOP": 0, "LDA": 1, "STA": 2, "ADD": 3, "SUB": 4, "BRZ": 5, "JMP": 6, "STP": 7};
    if (!ops.containsKey(opcode)) {
    arg = opcode;
    opcode = "";
  };
  };
  }
    if (label != "") {
    labels[label] = lineNum;
  }
    instrs = [...instrs, Instruction(Label: label, Opcode: opcode, Arg: arg)];
    lineNum = lineNum + 1;
    i = i + 1;
  }
  return {"instructions": instrs, "labels": labels};
}

List<int> compile(Map<String, dynamic> p) {
  List<Instruction> instrs = List<Instruction>.from(p["instructions"]);
  Map<String, int> labels = p["labels"] as Map<String, int>;
  List<int> bytecode = <int>[];
  int i = 0;
  Map<String, int> opcodes = {"NOP": 0, "LDA": 1, "STA": 2, "ADD": 3, "SUB": 4, "BRZ": 5, "JMP": 6, "STP": 7};
  while (i < instrs.length) {
    Instruction ins = instrs[i];
    int arg = 0;
    if (ins.Arg != "") {
    if (labels.containsKey(ins.Arg)) {
    arg = labels[ins.Arg]!;
  } else {
    arg = int.parse(ins.Arg);
  };
  }
    int code = 0;
    if (ins.Opcode != "") {
    code = opcodes[ins.Opcode]!;
  }
    bytecode = [...bytecode, code * 32 + arg];
    i = i + 1;
  }
  while (bytecode.length < 32) {
    bytecode = [...bytecode, 0];
  }
  return bytecode;
}

int floorMod(int a, int b) {
  int r = a % b;
  if (r < 0) {
    r = r + b;
  }
  return r;
}

int run(List<int> bytecode) {
  int acc = 0;
  int pc = 0;
  List<int> mem = <int>[];
  int i = 0;
  while (i < bytecode.length) {
    mem = [...mem, bytecode[i]];
    i = i + 1;
  }
  while (pc < 32) {
    int op = mem[pc] ~/ 32;
    int arg = mem[pc] % 32;
    pc = pc + 1;
    if (op == 0) {
    continue;
  } else {
    if (op == 1) {
    acc = mem[arg];
  } else {
    if (op == 2) {
    mem[arg] = acc;
  } else {
    if (op == 3) {
    acc = floorMod(acc + mem[arg], 256);
  } else {
    if (op == 4) {
    acc = floorMod(acc - mem[arg], 256);
  } else {
    if (op == 5) {
    if (acc == 0) {
    pc = arg;
  };
  } else {
    if (op == 6) {
    pc = arg;
  } else {
    if (op == 7) {
    break;
  } else {
    break;
  };
  };
  };
  };
  };
  };
  };
  }
  }
  return acc;
}

int execute(String asm) {
  Map<String, dynamic> parsed = parseAsm(asm);
  List<int> bc = compile(parsed);
  return run(bc);
}

void _main() {
  List<String> examples = ["LDA   x\n" + "ADD   y       ; accumulator = x + y\n" + "STP\n" + "x:            2\n" + "y:            2", "loop:   LDA   prodt\n" + "        ADD   x\n" + "        STA   prodt\n" + "        LDA   y\n" + "        SUB   one\n" + "        STA   y\n" + "        BRZ   done\n" + "        JMP   loop\n" + "done:   LDA   prodt   ; to display it\n" + "        STP\n" + "x:            8\n" + "y:            7\n" + "prodt:        0\n" + "one:          1", "loop:   LDA   n\n" + "        STA   temp\n" + "        ADD   m\n" + "        STA   n\n" + "        LDA   temp\n" + "        STA   m\n" + "        LDA   count\n" + "        SUB   one\n" + "        BRZ   done\n" + "        STA   count\n" + "        JMP   loop\n" + "done:   LDA   n       ; to display it\n" + "        STP\n" + "m:            1\n" + "n:            1\n" + "temp:         0\n" + "count:        8       ; valid range: 1-11\n" + "one:          1", "start:  LDA   load\n" + "ADD   car     ; head of list\n" + "STA   ldcar\n" + "ADD   one\n" + "STA   ldcdr   ; next CONS cell\n" + "ldcar:  NOP\n" + "STA   value\n" + "ldcdr:  NOP\n" + "BRZ   done    ; 0 stands for NIL\n" + "STA   car\n" + "JMP   start\n" + "done:   LDA   value   ; CAR of last CONS\n" + "STP\n" + "load:   LDA   0\n" + "value:        0\n" + "car:          28\n" + "one:          1\n" + "                        ; order of CONS cells\n" + "                        ; in memory\n" + "                        ; does not matter\n" + "        6\n" + "        0       ; 0 stands for NIL\n" + "        2       ; (CADR ls)\n" + "        26      ; (CDDR ls) -- etc.\n" + "        5\n" + "        20\n" + "        3\n" + "        30\n" + "        1       ; value of (CAR ls)\n" + "        22      ; points to (CDR ls)\n" + "        4\n" + "        24", "LDA  3\n" + "SUB  4\n" + "STP  0\n" + "         0\n" + "         255", "LDA  3\n" + "SUB  4\n" + "STP  0\n" + "                0\n" + "                1", "LDA  3\n" + "ADD  4\n" + "STP  0\n" + "                1\n" + "                255"];
  int i = 0;
  while (i < examples.length) {
    int res = execute(examples[i]);
    print((res).toString());
    i = i + 1;
  }
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
