// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, int start, int end) {
  var n = s.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (start > n) start = n;
  if (end < 0) end = 0;
  if (end > n) end = n;
  if (start > end) start = end;
  return s.substring(start, end);
}

List<String> split(String s, String sep) {
  List<String> parts = <String>[];
  String cur = "";
  int i = 0;
  while (i < s.length) {
    if (sep.length > 0 && i + sep.length <= s.length && _substr(s, i, i + sep.length) == sep) {
    parts = [...parts, cur];
    cur = "";
    i = i + sep.length;
  } else {
    cur = cur + _substr(s, i, i + 1);
    i = i + 1;
  }
  }
  parts = [...parts, cur];
  return parts;
}

String trimSpace(String s) {
  int start = 0;
  while (start < s.length && (_substr(s, start, start + 1) == " " || _substr(s, start, start + 1) == "	")) {
    start = start + 1;
  }
  int end = s.length;
  while (end > start && (_substr(s, end - 1, end) == " " || _substr(s, end - 1, end) == "	")) {
    end = end - 1;
  }
  return _substr(s, start, end);
}

int indexOfSub(String s, String sub) {
  if (sub.length == 0) {
    return 0;
  }
  int i = 0;
  while (i + sub.length <= s.length) {
    if (_substr(s, i, i + sub.length) == sub) {
    return i;
  }
    i = i + 1;
  }
  return 0 - 1;
}

Map<String, dynamic> parseRules(String rs) {
  List<Map<String, dynamic>> rules = <Map<String, dynamic>>[];
  for (var line in rs.split("\n")) {
    var ln = line;
    int hash = indexOfSub(ln, "#");
    if (hash >= 0) {
    ln = _substr(ln, 0, hash);
  }
    ln = trimSpace(ln);
    if (ln.toString().length == 0) {
    continue;
  }
    int arrow = 0 - 1;
    int j = 0;
    while (j + 2 <= ln.toString().length) {
    if (_substr(ln, j, j + 2) == "->") {
    bool pre = j > 0 && (_substr(ln, j - 1, j) == " " || _substr(ln, j - 1, j) == "	");
    bool post = j + 2 < ln.toString().length && (_substr(ln, j + 2, j + 3) == " " || _substr(ln, j + 2, j + 3) == "	");
    if (pre && post) {
    arrow = j;
    break;
  };
  }
    j = j + 1;
  }
    if (arrow < 0) {
    arrow = indexOfSub(ln, "->");
  }
    if (arrow < 0) {
    return {"ok": false};
  }
    String pat = trimSpace(_substr(ln, 0, arrow));
    String rest = trimSpace(_substr(ln, arrow + 2, ln.toString().length));
    bool term = false;
    if (rest.length > 0 && _substr(rest, 0, 1) == ".") {
    term = true;
    rest = _substr(rest, 1, rest.length);
  }
    String rep = rest;
    rules = [...rules, {"pat": pat, "rep": rep, "term": term}];
  }
  return {"ok": true, "rules": rules};
}

String runRules(List<Map<String, dynamic>> rules, String s) {
  bool changed = true;
  while (changed) {
    changed = false;
    int i = 0;
    while (i < rules.length) {
    Map<String, dynamic> r = rules[i];
    var pat = r["pat"]!!;
    var rep = r["rep"]!!;
    var term = r["term"]!!;
    int idx = indexOfSub(s, pat);
    if (idx >= 0) {
    s = _substr(s, 0, idx) + rep + _substr(s, idx + pat.toString().length, s.length);
    changed = true;
    if (term) {
    return s;
  };
    break;
  }
    i = i + 1;
  }
  }
  return s;
}

Map<String, dynamic> interpret(String ruleset, String input) {
  Map<String, dynamic> p = parseRules(ruleset);
  if (!p["ok"]!) {
    return {"ok": false, "out": ""};
  }
  String out = runRules(p["rules"]!, input);
  return {"ok": true, "out": out};
}

List<Map<String, String>> testSet = [{"ruleSet": "# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As from T S.", "output": "I bought a bag of apples from my brother."}, {"ruleSet": "# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As from T S.", "output": "I bought a bag of apples from T shop."}, {"ruleSet": "# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As W my Bgage from T S.", "output": "I bought a bag of apples with my money from T shop."}, {"ruleSet": "### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n", "sample": "_1111*11111_", "output": "11111111111111111111"}, {"ruleSet": "# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n", "sample": "000000A000000", "output": "00011H1111000"}];
void _main() {
  print("validating " + (testSet.length).toString() + " test cases");
  bool failures = false;
  int i = 0;
  while (i < testSet.length) {
    Map<String, String> tc = testSet[i];
    Map<String, dynamic> res = interpret(tc["ruleSet"]!, tc["sample"]!);
    if (!res["ok"]!) {
    print("test " + (i + 1).toString() + " invalid ruleset");
    failures = true;
  } else {
    if (res["out"]! != tc["output"]!) {
    print("test " + (i + 1).toString() + ": got " + res["out"]! + ", want " + tc["output"]!);
    failures = true;
  };
  }
    i = i + 1;
  }
  if (!failures) {
    print("no failures");
  }
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
