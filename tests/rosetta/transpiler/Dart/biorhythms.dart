// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, int start, int end) {
  var n = s.length;
  if (start < 0) start += n;
  if (end < 0) end += n;
  if (start < 0) start = 0;
  if (start > n) start = n;
  if (end < 0) end = 0;
  if (end > n) end = n;
  if (start > end) start = end;
  return s.substring(start, end);
}

num PI = 3.141592653589793;
num TWO_PI = 6.283185307179586;
num sinApprox(num x) {
  num term = x;
  num sum = x;
  int n = 1;
  while (n <= 8) {
    num denom = (2 * n * (2 * n + 1)).toDouble();
    term = -term * x * x / denom;
    sum = sum + term;
    n = n + 1;
  }
  return sum;
}

num floor(num x) {
  int i = (x).toInt();
  if (((i).toDouble()) > x) {
    i = i - 1;
  }
  return (i).toDouble();
}

num absFloat(num x) {
  if (x < 0.0) {
    return -x;
  }
  return x;
}

int absInt(int n) {
  if (n < 0) {
    return -n;
  }
  return n;
}

int parseIntStr(String str) {
  int i = 0;
  bool neg = false;
  if (str.length > 0 && _substr(str, 0, 1) == "-") {
    neg = true;
    i = 1;
  }
  int n = 0;
  Map<String, int> digits = {"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9};
  while (i < str.length) {
    n = (n * 10 + digits[_substr(str, i, i + 1)]!).toInt();
    i = i + 1;
  }
  if (neg) {
    n = -n;
  }
  return n;
}

List<int> parseDate(String s) {
  int y = int.parse(_substr(s, 0, 4));
  int m = int.parse(_substr(s, 5, 7));
  int d = int.parse(_substr(s, 8, 10));
  return [y, m, d];
}

bool leap(int y) {
  if (y % 400 == 0) {
    return true;
  }
  if (y % 100 == 0) {
    return false;
  }
  return y % 4 == 0;
}

int daysInMonth(int y, int m) {
  int feb = leap(y) ? 29 : 28;
  List<int> lengths = [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  return lengths[m - 1];
}

List<int> addDays(int y, int m, int d, int n) {
  int yy = y;
  int mm = m;
  int dd = d;
  if (n >= 0) {
    int i = 0;
    while (i < n) {
    dd = dd + 1;
    if (dd > daysInMonth(yy, mm)) {
    dd = 1;
    mm = mm + 1;
    if (mm > 12) {
    mm = 1;
    yy = yy + 1;
  };
  }
    i = i + 1;
  };
  } else {
    int i = 0;
    while (i > n) {
    dd = dd - 1;
    if (dd < 1) {
    mm = mm - 1;
    if (mm < 1) {
    mm = 12;
    yy = yy - 1;
  };
    dd = daysInMonth(yy, mm);
  }
    i = i - 1;
  };
  }
  return [yy, mm, dd];
}

String pad2(int n) {
  if (n < 10) {
    return "0" + (n).toString();
  }
  return (n).toString();
}

String dateString(int y, int m, int d) {
  return (y).toString() + "-" + pad2(m) + "-" + pad2(d);
}

int day(int y, int m, int d) {
  int part1 = 367 * y;
  int part2 = 7 * (y + (m + 9) ~/ 12 as int) ~/ 4 as int;
  int part3 = 275 * m ~/ 9 as int;
  return part1 - part2 + part3 + d - 730530;
}

void biorhythms(String birth, String target) {
  List<int> bparts = parseDate(birth);
  int by = bparts[0];
  int bm = bparts[1];
  int bd = bparts[2];
  List<int> tparts = parseDate(target);
  int ty = tparts[0];
  int tm = tparts[1];
  int td = tparts[2];
  int diff = absInt(day(ty, tm, td) - day(by, bm, bd));
  print("Born " + birth + ", Target " + target);
  print("Day " + (diff).toString());
  List<String> cycles = ["Physical day ", "Emotional day", "Mental day   "];
  List<int> lengths = [23, 28, 33];
  List<List<String>> quadrants = [["up and rising", "peak"], ["up but falling", "transition"], ["down and falling", "valley"], ["down but rising", "transition"]];
  int i = 0;
  while (i < 3) {
    int length = lengths[i];
    String cycle = cycles[i];
    int position = diff % length;
    int quadrant = position * 4 ~/ length;
    num percent = sinApprox(2.0 * PI * ((position).toDouble()) / ((length).toDouble()));
    percent = floor(percent * 1000.0) / 10.0;
    String description = "";
    if (percent > 95.0) {
    description = " peak";
  } else {
    if (percent < -95.0) {
    description = " valley";
  } else {
    if (absFloat(percent) < 5.0) {
    description = " critical transition";
  } else {
    int daysToAdd = (quadrant + 1) * length ~/ 4 - position;
    List<int> res = addDays(ty, tm, td, daysToAdd);
    int ny = res[0];
    int nm = res[1];
    int nd = res[2];
    String transition = dateString(ny, nm, nd);
    String trend = quadrants[quadrant][0];
    String next = quadrants[quadrant][1];
    String pct = (percent).toString();
    if (!pct.contains(".")) {
    pct = pct + ".0";
  };
    description = " " + pct + "% (" + trend + ", next " + next + " " + transition + ")";
  };
  };
  }
    String posStr = (position).toString();
    if (position < 10) {
    posStr = " " + posStr;
  }
    print(cycle + posStr + " : " + description);
    i = i + 1;
  }
  print("");
}

void _main() {
  List<List<String>> pairs = [["1943-03-09", "1972-07-11"], ["1809-01-12", "1863-11-19"], ["1809-02-12", "1863-11-19"]];
  int idx = 0;
  while (idx < pairs.length) {
    List<String> p = pairs[idx];
    biorhythms(p[0], p[1]);
    idx = idx + 1;
  }
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
