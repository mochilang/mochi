// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

String _repeat(String s, int n) => List.filled(n, s).join();

List<int> bigTrim(List<int> a) {
  int n = a.length;
  while (n > 1 && a[n - 1] == 0) {
    a = a.sublist(0, n - 1);
    n = n - 1;
  }
  return a;
}

List<int> bigFromInt(int x) {
  if (x == 0) {
    return [0];
  }
  List<int> digits = <int>[];
  int n = x;
  while (n > 0) {
    digits = [...digits, n % 10];
    n = n ~/ 10;
  }
  return digits;
}

int bigCmp(List<int> a, List<int> b) {
  if (a.length > b.length) {
    return 1;
  }
  if (a.length < b.length) {
    return -1;
  }
  int i = a.length - 1;
  while (i >= 0) {
    if (a[i] > b[i]) {
    return 1;
  }
    if (a[i] < b[i]) {
    return -1;
  }
    i = i - 1;
  }
  return 0;
}

List<int> bigAdd(List<int> a, List<int> b) {
  List<int> res = <int>[];
  int carry = 0;
  int i = 0;
  while (i < a.length || i < b.length || carry > 0) {
    int av = 0;
    if (i < a.length) {
    av = a[i];
  }
    int bv = 0;
    if (i < b.length) {
    bv = b[i];
  }
    int s = av + bv + carry;
    res = [...res, s % 10];
    carry = s ~/ 10;
    i = i + 1;
  }
  return bigTrim(res);
}

List<int> bigSub(List<int> a, List<int> b) {
  List<int> res = <int>[];
  int borrow = 0;
  int i = 0;
  while (i < a.length) {
    int av = a[i];
    int bv = 0;
    if (i < b.length) {
    bv = b[i];
  }
    int diff = av - bv - borrow;
    if (diff < 0) {
    diff = diff + 10;
    borrow = 1;
  } else {
    borrow = 0;
  }
    res = [...res, diff];
    i = i + 1;
  }
  return bigTrim(res);
}

List<int> bigMulSmall(List<int> a, int m) {
  if (m == 0) {
    return [0];
  }
  List<int> res = <int>[];
  int carry = 0;
  int i = 0;
  while (i < a.length) {
    int prod = a[i] * m + carry;
    res = [...res, prod % 10];
    carry = prod ~/ 10;
    i = i + 1;
  }
  while (carry > 0) {
    res = [...res, carry % 10];
    carry = carry ~/ 10;
  }
  return bigTrim(res);
}

List<int> bigMulBig(List<int> a, List<int> b) {
  List<int> res = <int>[];
  int i = 0;
  while (i < a.length + b.length) {
    res = [...res, 0];
    i = i + 1;
  }
  i = 0;
  while (i < a.length) {
    int carry = 0;
    int j = 0;
    while (j < b.length) {
    int idx = i + j;
    int prod = res[idx] + a[i] * b[j] + carry;
    res[idx] = prod % 10;
    carry = prod ~/ 10;
    j = j + 1;
  }
    int idx = i + b.length;
    while (carry > 0) {
    int prod = res[idx] + carry;
    res[idx] = prod % 10;
    carry = prod ~/ 10;
    idx = idx + 1;
  }
    i = i + 1;
  }
  return bigTrim(res);
}

List<int> bigMulPow10(List<int> a, int k) {
  int i = 0;
  while (i < k) {
    a = ([0] + a as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
    i = i + 1;
  }
  return a;
}

List<int> bigDivSmall(List<int> a, int m) {
  List<int> res = <int>[];
  int rem = 0;
  int i = a.length - 1;
  while (i >= 0) {
    int cur = rem * 10 + a[i];
    int q = cur ~/ m;
    rem = cur % m;
    res = ([q] + res as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
    i = i - 1;
  }
  return bigTrim(res);
}

String bigToString(List<int> a) {
  String s = "";
  int i = a.length - 1;
  while (i >= 0) {
    s = s + (a[i]).toString();
    i = i - 1;
  }
  return s;
}

String repeat(String ch, int n) {
  String s = "";
  int i = 0;
  while (i < n) {
    s = s + ch;
    i = i + 1;
  }
  return s;
}

List<int> sortInts(List<int> xs) {
  List<int> res = <int>[];
  List<int> tmp = xs;
  while (tmp.length > 0) {
    int min = tmp[0];
    int idx = 0;
    int i = 1;
    while (i < tmp.length) {
    if (tmp[i] < min) {
    min = tmp[i];
    idx = i;
  }
    i = i + 1;
  }
    res = (res + [min] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
    List<int> out = <int>[];
    int j = 0;
    while (j < tmp.length) {
    if (j != idx) {
    out = (out + [tmp[j]] as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList();
  }
    j = j + 1;
  }
    tmp = out;
  }
  return res;
}

List<int> primesUpTo(int n) {
  List<bool> sieve = <bool>[];
  int i = 0;
  while (i <= n) {
    sieve = [...sieve, true];
    i = i + 1;
  }
  int p = 2;
  while (p * p <= n) {
    if (sieve[p]) {
    int m = p * p;
    while (m <= n) {
    sieve[m] = false;
    m = m + p;
  };
  }
    p = p + 1;
  }
  List<int> res = <int>[];
  int x = 2;
  while (x <= n) {
    if (sieve[x]) {
    res = [...res, x];
  }
    x = x + 1;
  }
  return res;
}

Map<String, int> factorialExp(int n, List<int> primes) {
  Map<String, int> m = <String, int>{};
  for (int p in primes) {
    if (p > n) {
    break;
  }
    int t = n;
    int e = 0;
    while (t > 0) {
    t = t ~/ p;
    e = e + t;
  }
    m[(p).toString()] = e;
  }
  return m;
}

Map<String, int> factorSmall(int x, List<int> primes) {
  Map<String, int> f = <String, int>{};
  int n = x;
  for (int p in primes) {
    if (p * p > n) {
    break;
  }
    int c = 0;
    while (n % p == 0) {
    c = c + 1;
    n = n ~/ p;
  }
    if (c > 0) {
    f[(p).toString()] = c;
  }
  }
  if (n > 1) {
    f[(n).toString()] = ((f.containsKey((n).toString()) ? (f[(n).toString()] ?? 0) : 0) + 1).toInt();
  }
  return f;
}

List<int> computeIP(int n, List<int> primes) {
  Map<String, int> exps = factorialExp(6 * n, primes);
  Map<String, int> fn = factorialExp(n, primes);
  for (String k in fn.keys) {
    exps[k] = ((exps.containsKey(k) ? (exps[k] ?? 0) : 0) - 6 * fn[k]!).toInt();
  }
  exps["2"] = ((exps.containsKey("2") ? (exps["2"] ?? 0) : 0) + 5).toInt();
  int t2 = 532 * n * n + 126 * n + 9;
  Map<String, int> ft2 = factorSmall(t2, primes);
  for (String k in ft2.keys) {
    exps[k] = ((exps.containsKey(k) ? (exps[k] ?? 0) : 0) + ft2[k]!).toInt();
  }
  exps["3"] = ((exps.containsKey("3") ? (exps["3"] ?? 0) : 0) - 1).toInt();
  List<int> keys = <int>[];
  for (var k in exps.keys) {
    keys = [...keys, int.parse(k)];
  }
  keys = sortInts(keys);
  List<int> res = bigFromInt(1);
  for (int p in keys) {
    int e = exps[(p).toString()]!;
    int i = 0;
    while (i < e) {
    res = bigMulSmall(res, p);
    i = i + 1;
  }
  }
  return res;
}

String formatTerm(List<int> ip, int pw) {
  String s = bigToString(ip);
  if (pw >= s.length) {
    String frac = _repeat("0", pw - s.length) + s;
    if (frac.length < 33) {
    frac = frac + _repeat("0", 33 - frac.length);
  };
    return "0." + _substr(frac, 0, 33);
  }
  String intpart = _substr(s, 0, s.length - pw);
  String frac = _substr(s, s.length - pw, s.length);
  if (frac.length < 33) {
    frac = frac + _repeat("0", 33 - frac.length);
  }
  return intpart + "." + _substr(frac, 0, 33);
}

List<int> bigAbsDiff(List<int> a, List<int> b) {
  if (bigCmp(a, b) >= 0) {
    return bigSub(a, b);
  }
  return bigSub(b, a);
}

void _main() {
  List<int> primes = primesUpTo(2000);
  print("N                               Integer Portion  Pow  Nth Term (33 dp)");
  dynamic line = _repeat("-", 89);
  print(line);
  List<int> sum = bigFromInt(0);
  List<int> prev = bigFromInt(0);
  int denomPow = 0;
  int n = 0;
  while (true) {
    List<int> ip = computeIP(n, primes);
    int pw = 6 * n + 3;
    if (pw > denomPow) {
    sum = bigMulPow10(sum, pw - denomPow);
    prev = bigMulPow10(prev, pw - denomPow);
    denomPow = pw;
  }
    if (n < 10) {
    String termStr = formatTerm(ip, pw);
    String ipStr = bigToString(ip);
    while (ipStr.length < 44) {
    ipStr = " " + ipStr;
  };
    String pwStr = (-pw).toString();
    while (pwStr.length < 3) {
    pwStr = " " + pwStr;
  };
    String padTerm = termStr;
    while (padTerm.length < 35) {
    padTerm = padTerm + " ";
  };
    print((n).toString() + "  " + ipStr + "  " + pwStr + "  " + padTerm);
  }
    sum = bigAdd(sum, ip);
    List<int> diff = bigAbsDiff(sum, prev);
    if (denomPow >= 70 && bigCmp(diff, bigMulPow10(bigFromInt(1), denomPow - 70)) < 0) {
    break;
  }
    prev = sum;
    n = n + 1;
  }
  int precision = 70;
  List<int> target = bigMulPow10(bigFromInt(1), denomPow + 2 * precision);
  List<int> low = bigFromInt(0);
  List<int> high = bigMulPow10(bigFromInt(1), precision + 1);
  while (bigCmp(low, bigSub(high, bigFromInt(1))) < 0) {
    List<int> mid = bigDivSmall(bigAdd(low, high), 2);
    List<int> prod = bigMulBig(bigMulBig(mid, mid), sum);
    if (bigCmp(prod, target) <= 0) {
    low = mid;
  } else {
    high = bigSub(mid, bigFromInt(1));
  }
  }
  List<int> piInt = low;
  String piStr = bigToString(piInt);
  if (piStr.length <= precision) {
    piStr = _repeat("0", precision - piStr.length + 1) + piStr;
  }
  String out = _substr(piStr, 0, piStr.length - precision) + "." + _substr(piStr, piStr.length - precision, piStr.length);
  print("");
  print("Pi to 70 decimal places is:");
  print(out);
}

void _start() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _main();
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "_start"}));
}

void main() => _start();
