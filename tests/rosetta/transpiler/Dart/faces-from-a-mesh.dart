// Generated by Mochi transpiler
import 'dart:convert';
import 'dart:io';

int _nowSeed = 0;
bool _nowSeeded = false;
void _initNow() {
  var s = Platform.environment['MOCHI_NOW_SEED'];
  if (s != null && s.isNotEmpty) {
    var v = int.tryParse(s);
    if (v != null) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
int _now() {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return DateTime.now().microsecondsSinceEpoch;
}

String _substr(String s, num start, num end) {
  var n = s.length;
  int s0 = start.toInt();
  int e0 = end.toInt();
  if (s0 < 0) s0 += n;
  if (e0 < 0) e0 += n;
  if (s0 < 0) s0 = 0;
  if (s0 > n) s0 = n;
  if (e0 < 0) e0 = 0;
  if (e0 > n) e0 = n;
  if (s0 > e0) s0 = e0;
  return s.substring(s0, e0);
}

class Edge {
  int a;
  int b;
  Edge({required this.a, required this.b});
}

bool contains(List<int> xs, int v) {
  for (int x in xs) {
    if (x == v) {
    return true;
  }
  }
  return false;
}

bool sliceEqual(List<int> a, List<int> b) {
  int i = 0;
  while (i < a.length) {
    if (a[i] != b[i]) {
    return false;
  }
    i = i + 1;
  }
  return true;
}

void reverse(List<int> xs) {
  int i = 0;
  int j = xs.length - 1;
  while (i < j) {
    int t = xs[i];
    xs[i] = xs[j];
    xs[j] = t;
    i = i + 1;
    j = j - 1;
  }
}

List<int> copyInts(List<int> xs) {
  List<int> out = <int>[];
  for (int v in xs) {
    out = [...out, v];
  }
  return out;
}

bool perimEqual(List<int> p1, List<int> p2) {
  if (p1.length != p2.length) {
    return false;
  }
  for (int v in p1) {
    if (!p2.contains(v)) {
    return false;
  }
  }
  List<int> c = copyInts(p1);
  int r = 0;
  while (r < 2) {
    int i = 0;
    while (i < p1.length) {
    if (sliceEqual(c, p2)) {
    return true;
  }
    int t = c[c.length - 1];
    int j = c.length - 1;
    while (j > 0) {
    c[j] = c[j - 1];
    j = j - 1;
  }
    c[0] = t;
    i = i + 1;
  }
    reverse(c);
    r = r + 1;
  }
  return false;
}

List<Edge> sortEdges(List<Edge> es) {
  List<Edge> arr = es;
  int n = arr.length;
  int i = 0;
  while (i < n) {
    int j = 0;
    while (j < n - 1) {
    Edge a = arr[j];
    Edge b = arr[j + 1];
    if (a.a > b.a || a.a == b.a && a.b > b.b) {
    arr[j] = b;
    arr[j + 1] = a;
  }
    j = j + 1;
  }
    i = i + 1;
  }
  return arr;
}

List<Edge> concat(List<Edge> a, List<Edge> b) {
  List<Edge> out = <Edge>[];
  for (Edge x in a) {
    out = [...out, x];
  }
  for (Edge x in b) {
    out = [...out, x];
  }
  return out;
}

dynamic faceToPerim(List<Edge> face) {
  int le = face.length;
  if (le == 0) {
    return null;
  }
  List<Edge> edges = <Edge>[];
  int i = 0;
  while (i < le) {
    Edge e = face[i];
    if (e.b <= e.a) {
    return null;
  }
    edges = [...edges, e];
    i = i + 1;
  }
  edges = sortEdges(edges);
  Edge firstEdge = edges[0];
  List<int> perim = [firstEdge.a, firstEdge.b];
  int first = firstEdge.a;
  int last = firstEdge.b;
  edges = edges.sublist(1, edges.length);
  le = edges.length;
  bool done = false;
  while (le > 0 && !done) {
    int idx = 0;
    bool found = false;
    while (idx < le) {
    Edge e = edges[idx];
    if (e.a == last) {
    perim = [...perim, e.b];
    last = e.b;
    found = true;
  } else {
    if (e.b == last) {
    perim = [...perim, e.a];
    last = e.a;
    found = true;
  };
  }
    if (found) {
    edges = concat(edges.sublist(0, idx), edges.sublist(idx + 1, edges.length));
    le = le - 1;
    if (last == first) {
    if (le == 0) {
    done = true;
  } else {
    return null;
  };
  };
    break;
  }
    idx = idx + 1;
  }
    if (!found) {
    return null;
  }
  }
  return perim.sublist(0, perim.length - 1);
}

String listStr(List<int> xs) {
  String s = "[";
  int i = 0;
  while (i < xs.length) {
    s = s + (xs[i]).toString();
    if (i < xs.length - 1) {
    s = s + " ";
  }
    i = i + 1;
  }
  s = s + "]";
  return s;
}

List<Edge> e = [Edge(a: 7, b: 11), Edge(a: 1, b: 11), Edge(a: 1, b: 7)];
List<Edge> f = [Edge(a: 11, b: 23), Edge(a: 1, b: 17), Edge(a: 17, b: 23), Edge(a: 1, b: 11)];
List<Edge> g = [Edge(a: 8, b: 14), Edge(a: 17, b: 19), Edge(a: 10, b: 12), Edge(a: 10, b: 14), Edge(a: 12, b: 17), Edge(a: 8, b: 18), Edge(a: 18, b: 19)];
List<Edge> h = [Edge(a: 1, b: 3), Edge(a: 9, b: 11), Edge(a: 3, b: 11), Edge(a: 1, b: 11)];
List<List<Edge>> faces = [e, f, g, h];
List<String> names = ["E", "F", "G", "H"];
int idx2 = 0;
void main() {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  _initNow();
  {
  var _benchMem0 = ProcessInfo.currentRss;
  var _benchSw = Stopwatch()..start();
  print("Perimeter format equality checks:");
  print("  Q == R is " + (perimEqual([8, 1, 3], [1, 3, 8])).toString());
  print("  U == V is " + (perimEqual([18, 8, 14, 10, 12, 17, 19], [8, 14, 10, 12, 17, 19, 18])).toString());
  print("\nEdge to perimeter format translations:");
  while (idx2 < faces.length) {
    dynamic per = faceToPerim(faces[idx2]);
    if (per == null) {
    print("  " + names[idx2] + " => Invalid edge format");
  } else {
    print("  " + names[idx2] + " => " + listStr((per as List).map((e) => (e is BigInt ? e.toInt() : (e as int))).toList()));
  }
    idx2 = idx2 + 1;
  }
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
  _benchSw.stop();
  var _benchMem1 = ProcessInfo.currentRss;
  print(jsonEncode({"duration_us": _benchSw.elapsedMicroseconds, "memory_bytes": (_benchMem1 - _benchMem0).abs(), "name": "main"}));
}
