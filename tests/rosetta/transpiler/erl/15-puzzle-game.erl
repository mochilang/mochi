#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, randMove/0, isSolved/0, isValidMove/1, doMove/1, shuffle/1, printBoard/0, playOneMove/0, play/0, main/0]).

% Generated by Mochi transpiler v0.10.37 (f47c1ea6ed) on 2025-07-23 11:36 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

randMove() ->
    try
        (mochi_now() rem 4)
    catch {return, V} -> V end.

isSolved() ->
    try
        I = 0,
        Fun = fun Fun_loop(Board, Empty, I, Moves, Quit, Solved) ->
    case (I < 16) of
        true ->
            try
                case (lists:nth(I + 1, Board) /= lists:nth(I + 1, Solved)) of
        true -> throw({return, false});
        _ -> ok
    end,
                I2 = (I + 1),
                Fun_loop(Board, Empty, I2, Moves, Quit, Solved)
            catch
                break -> {Board, Empty, I, Moves, Quit, Solved}
            end;
        _ -> {Board, Empty, I, Moves, Quit, Solved}
    end
end,
{Board, Empty, I2, Moves, Quit, Solved} = Fun(Board, Empty, I, Moves, Quit, Solved),
        true
    catch {return, V} -> V end.

isValidMove(M) ->
    try
        case (M == 0) of
        true -> throw({return, #{"idx" => (Empty - 4), "ok" => ((Empty / 4) > 0)}});
        _ -> ok
    end,
        case (M == 1) of
        true -> throw({return, #{"idx" => (Empty + 4), "ok" => ((Empty / 4) < 3)}});
        _ -> ok
    end,
        case (M == 2) of
        true -> throw({return, #{"idx" => (Empty + 1), "ok" => ((Empty rem 4) < 3)}});
        _ -> ok
    end,
        case (M == 3) of
        true -> throw({return, #{"idx" => (Empty - 1), "ok" => ((Empty rem 4) > 0)}});
        _ -> ok
    end,
        #{"idx" => 0, "ok" => false}
    catch {return, V} -> V end.

doMove(M2) ->
    try
        R = isValidMove(M2),
        case not lists:nth("ok" + 1, R) of
        true -> throw({return, false});
        _ -> ok
    end,
        I3 = Empty,
        J = Int(lists:nth("idx" + 1, R)),
        Tmp = lists:nth(I3 + 1, Board),
        Board2 = lists:sublist(Board, I3) ++ [lists:nth(J + 1, Board)] ++ lists:nthtail(I3 + 1, Board),
        Board3 = lists:sublist(Board2, J) ++ [Tmp] ++ lists:nthtail(J + 1, Board2),
        Empty2 = J,
        Moves2 = (Moves + 1),
        true
    catch {return, V} -> V end.

shuffle(N) ->
    try
        I4 = 0,
        Fun2 = fun Fun2_loop(Board, Empty, I4, Moves, N, Quit, Solved) ->
    case ((I4 < N) orelse isSolved()) of
        true ->
            try
                case doMove(randMove()) of
        true -> I5 = (I4 + 1),
            I6 = I5;
        _ -> I6 = I4
    end,
                Fun2_loop(Board, Empty, I6, Moves, N, Quit, Solved)
            catch
                break -> {Board, Empty, I4, Moves, N, Quit, Solved}
            end;
        _ -> {Board, Empty, I4, Moves, N, Quit, Solved}
    end
end,
{Board, Empty, I6, Moves, N, Quit, Solved} = Fun2(Board, Empty, I4, Moves, N, Quit, Solved),
        nil
    catch {return, V} -> V end.

printBoard() ->
    try
        Line = "",
        I7 = 0,
        Fun3 = fun Fun3_loop(Board, Empty, I7, Line, Moves, Quit, Solved) ->
    case (I7 < 16) of
        true ->
            try
                Val = lists:nth(I7 + 1, Board),
                case (Val == 0) of
        true -> Line2 = (Line ++ "  ."),
            Line6 = Line2,
            S2 = nil;
        _ -> S = lists:flatten(io_lib:format("~p", [Val])),
            case (Val < 10) of
        true -> Line3 = ((Line ++ "  ") ++ S),
            Line5 = Line3;
        _ -> Line4 = ((Line ++ " ") ++ S),
            Line5 = Line4
    end,
            Line6 = Line5,
            S2 = S
    end,
                case ((I7 rem 4) == 3) of
        true -> io:format("~ts~n", [Line6]),
            Line7 = "",
            Line8 = Line7;
        _ -> Line8 = Line6
    end,
                I8 = (I7 + 1),
                Fun3_loop(Board, Empty, I8, Line8, Moves, Quit, Solved)
            catch
                break -> {Board, Empty, I7, Line, Moves, Quit, Solved}
            end;
        _ -> {Board, Empty, I7, Line, Moves, Quit, Solved}
    end
end,
{Board, Empty, I8, Line8, Moves, Quit, Solved} = Fun3(Board, Empty, I7, Line, Moves, Quit, Solved),
        nil
    catch {return, V} -> V end.

playOneMove() ->
    try
        Fun4 = fun Fun4_loop(Board, Empty, Moves, Quit, Solved) ->
    case true of
        true ->
            try
                io:format("~ts~n", [(("Enter move #" ++ lists:flatten(io_lib:format("~p", [(Moves + 1)]))) ++ " (U, D, L, R, or Q): ")]),
                S3 = Input(),
                case (S3 == "") of
        true -> throw(continue);
        _ -> ok
    end,
                C = lists:sublist(S3, 0 + 1, (1 - 0)),
                M3 = 0,
                case ((C == "U") orelse (C == "u")) of
        true -> M4 = 0,
            M11 = M4,
            Quit7 = Quit;
        _ -> case ((C == "D") orelse (C == "d")) of
        true -> M5 = 1,
            M10 = M5,
            Quit6 = Quit;
        _ -> case ((C == "R") orelse (C == "r")) of
        true -> M6 = 2,
            M9 = M6,
            Quit5 = Quit;
        _ -> case ((C == "L") orelse (C == "l")) of
        true -> M7 = 3,
            M8 = M7,
            Quit4 = Quit;
        _ -> case ((C == "Q") orelse (C == "q")) of
        true -> io:format("~ts~n", [(("Quiting after " ++ lists:flatten(io_lib:format("~p", [Moves]))) ++ " moves.")]),
            Quit2 = true,
            throw({return, nil}),
            Quit3 = Quit2;
        _ -> io:format("~ts~n", [((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" ++ "up, down, left, or right. You can also enter \"Q\" to quit.\n") ++ "Upper or lowercase is accepted and only the first non-blank\n") ++ "character is important (i.e. you may enter \"up\" if you like).")]),
            throw(continue),
            Quit3 = Quit
    end,
            M8 = M3,
            Quit4 = Quit3
    end,
            M9 = M8,
            Quit5 = Quit4
    end,
            M10 = M9,
            Quit6 = Quit5
    end,
            M11 = M10,
            Quit7 = Quit6
    end,
                case not doMove(M11) of
        true -> io:format("~ts~n", ["That is not a valid move at the moment."]),
            throw(continue);
        _ -> ok
    end,
                throw({return, nil}),
                Fun4_loop(Board, Empty, Moves, Quit7, Solved)
            catch
                break -> {Board, Empty, Moves, Quit, Solved}
            end;
        _ -> {Board, Empty, Moves, Quit, Solved}
    end
end,
{Board, Empty, Moves, Quit7, Solved} = Fun4(Board, Empty, Moves, Quit, Solved),
        nil
    catch {return, V} -> V end.

play() ->
    try
        io:format("~ts~n", ["Starting board:"]),
        Fun5 = fun Fun5_loop(Board, Empty, Moves, Quit, Solved) ->
    case (not Quit andalso (isSolved() == false)) of
        true ->
            try
                io:format("~ts~n", [""]),
                printBoard(),
                playOneMove(),
                Fun5_loop(Board, Empty, Moves, Quit, Solved)
            catch
                break -> {Board, Empty, Moves, Quit, Solved}
            end;
        _ -> {Board, Empty, Moves, Quit, Solved}
    end
end,
{Board, Empty, Moves, Quit, Solved} = Fun5(Board, Empty, Moves, Quit, Solved),
        case isSolved() of
        true -> io:format("~ts~n", [(("You solved the puzzle in " ++ lists:flatten(io_lib:format("~p", [Moves]))) ++ " moves.")]);
        _ -> ok
    end,
        nil
    catch {return, V} -> V end.

main() ->
    try
        shuffle(50),
        play(),
        nil
    catch {return, V} -> V end.

main(_) ->
    Board = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0],
    Solved = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0],
    Empty = 15,
    Moves = 0,
    Quit = false,
    main().
