#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, randmove/0, issolved/0, isvalidmove/1, domove/1, shuffle/1, printboard/0, playonemove/0, play/0, main/0]).

% Generated by Mochi transpiler v0.10.40 (6bb4e4bd23) on 2025-07-25 19:02 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

randmove() ->
    try
        (mochi_now() rem 4)
    catch {return, Ret} -> Ret end.

issolved() ->
    try
        I = 0,
        Fun = fun Fun_loop(I) ->
    case (I < 16) of
        true ->
            case (lists:nth(I + 1, erlang:get('board')) /= lists:nth(I + 1, erlang:get('solved'))) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(I_2);
        _ -> {I}
    end
end,
{I_2} = Fun(I),
        true
    catch {return, Ret} -> Ret end.

isvalidmove(M) ->
    try
        case (M == 0) of
        true -> throw({return, #{"idx" => (erlang:get('empty') - 4), "ok" => ((erlang:get('empty') div 4) > 0)}});
        _ -> ok
    end,
        case (M == 1) of
        true -> throw({return, #{"idx" => (erlang:get('empty') + 4), "ok" => ((erlang:get('empty') div 4) < 3)}});
        _ -> ok
    end,
        case (M == 2) of
        true -> throw({return, #{"idx" => (erlang:get('empty') + 1), "ok" => ((erlang:get('empty') rem 4) < 3)}});
        _ -> ok
    end,
        case (M == 3) of
        true -> throw({return, #{"idx" => (erlang:get('empty') - 1), "ok" => ((erlang:get('empty') rem 4) > 0)}});
        _ -> ok
    end,
        #{"idx" => 0, "ok" => false}
    catch {return, Ret} -> Ret end.

domove(M_2) ->
    try
        R = isvalidmove(M_2),
        case not maps:get("ok", R, nil) of
        true -> throw({return, false});
        _ -> ok
    end,
        I_3 = erlang:get('empty'),
        J = maps:get("idx", R, nil),
        Tmp = lists:nth(I_3 + 1, erlang:get('board')),
        Board = erlang:get('board'),
        Board_2 = lists:sublist(Board, I_3) ++ [lists:nth(J + 1, erlang:get('board'))] ++ lists:nthtail(I_3 + 1, Board),
        erlang:put('board', Board_2),
        Board_3 = erlang:get('board'),
        Board_4 = lists:sublist(Board_3, J) ++ [Tmp] ++ lists:nthtail(J + 1, Board_3),
        erlang:put('board', Board_4),
        erlang:put('empty', J),
        erlang:put('moves', (erlang:get('moves') + 1)),
        true
    catch {return, Ret} -> Ret end.

shuffle(N) ->
    try
        I_4 = 0,
        Fun_2 = fun Fun_2_loop(I_4, N) ->
    case ((I_4 < N) orelse issolved()) of
        true ->
            case (domove(randmove()) /= nil) of
        true -> I_5 = (I_4 + 1),
            I_6 = I_5;
        _ -> I_6 = I_4
    end,
            Fun_2_loop(I_6, N);
        _ -> {I_4, N}
    end
end,
{I_6, N} = Fun_2(I_4, N),
        nil
    catch {return, Ret} -> Ret end.

printboard() ->
    try
        Line = "",
        I_7 = 0,
        Fun_3 = fun Fun_3_loop(I_7, Line) ->
    case (I_7 < 16) of
        true ->
            Val = lists:nth(I_7 + 1, erlang:get('board')),
            case (Val == 0) of
        true -> Line_2 = (Line ++ "  ."),
            Line_6 = Line_2,
            S_2 = nil;
        _ -> S = lists:flatten(io_lib:format("~p", [Val])),
            case (Val < 10) of
        true -> Line_3 = ((Line ++ "  ") ++ S),
            Line_5 = Line_3;
        _ -> Line_4 = ((Line ++ " ") ++ S),
            Line_5 = Line_4
    end,
            Line_6 = Line_5,
            S_2 = S
    end,
            case ((I_7 rem 4) == 3) of
        true -> io:format("~ts~n", [Line_6]),
            Line_7 = "",
            Line_8 = Line_7;
        _ -> Line_8 = Line_6
    end,
            I_8 = (I_7 + 1),
            Fun_3_loop(I_8, Line_8);
        _ -> {I_7, Line}
    end
end,
{I_8, Line_8} = Fun_3(I_7, Line),
        nil
    catch {return, Ret} -> Ret end.

playonemove() ->
    try
        Fun_4 = fun Fun_4_loop() ->
    case true of
        true ->
            try
                io:format("~ts~n", [(("Enter move #" ++ lists:flatten(io_lib:format("~p", [(erlang:get('moves') + 1)]))) ++ " (U, D, L, R, or Q): ")]),
                S_3 = (case io:get_line("") of eof -> "q"; L -> string:trim(L) end),
                case (S_3 == "") of
        true -> throw(continue);
        _ -> ok
    end,
                C = lists:sublist(S_3, 0 + 1, (1 - 0)),
                M_3 = 0,
                case ((C == "U") orelse (C == "u")) of
        true -> M_4 = 0,
            M_11 = M_4;
        _ -> case ((C == "D") orelse (C == "d")) of
        true -> M_5 = 1,
            M_10 = M_5;
        _ -> case ((C == "R") orelse (C == "r")) of
        true -> M_6 = 2,
            M_9 = M_6;
        _ -> case ((C == "L") orelse (C == "l")) of
        true -> M_7 = 3,
            M_8 = M_7;
        _ -> case ((C == "Q") orelse (C == "q")) of
        true -> io:format("~ts~n", [(("Quiting after " ++ lists:flatten(io_lib:format("~p", [erlang:get('moves')]))) ++ " moves.")]),
            erlang:put('quit', true),
            throw({return, nil});
        _ -> io:format("~ts~n", [((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" ++ "up, down, left, or right. You can also enter \"Q\" to quit.\n") ++ "Upper or lowercase is accepted and only the first non-blank\n") ++ "character is important (i.e. you may enter \"up\" if you like).")]),
            throw(continue)
    end,
            M_8 = M_3
    end,
            M_9 = M_8
    end,
            M_10 = M_9
    end,
            M_11 = M_10
    end,
                case not domove(M_11) of
        true -> io:format("~ts~n", ["That is not a valid move at the moment."]),
            throw(continue);
        _ -> ok
    end,
                throw({return, nil}),
                Fun_4_loop()
            catch
                {continue} -> Fun_4_loop();
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun_4(),
        nil
    catch {return, Ret} -> Ret end.

play() ->
    try
        io:format("~ts~n", ["Starting board:"]),
        Fun_5 = fun Fun_5_loop() ->
    case (not erlang:get('quit') andalso (issolved() == false)) of
        true ->
            io:format("~ts~n", [""]),
            printboard(),
            playonemove(),
            Fun_5_loop();
        _ -> {}
    end
end,
{} = Fun_5(),
        case (issolved() /= nil) of
        true -> io:format("~ts~n", [(("You solved the puzzle in " ++ lists:flatten(io_lib:format("~p", [erlang:get('moves')]))) ++ " moves.")]);
        _ -> ok
    end,
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        shuffle(50),
        play(),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    erlang:put('board', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]),
    erlang:put('solved', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]),
    erlang:put('empty', 15),
    erlang:put('moves', 0),
    erlang:put('quit', false),
    main().
