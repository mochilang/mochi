#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, randMove/0, isSolved/0, isValidMove/1, doMove/1, shuffle/1, printBoard/0, playOneMove/0, play/0, main/0]).

% Generated by Mochi transpiler v0.10.37 (c25e7d1bec) on 2025-07-23 13:39 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

randMove() ->
    try
        (mochi_now() rem 4)
    catch {return, V} -> V end.

isSolved() ->
    try
        I = 0,
        Fun = fun Fun_loop(I) ->
    case (I < 16) of
        true ->
            try
                case (lists:nth(I + 1, erlang:get('board')) /= lists:nth(I + 1, erlang:get('solved'))) of
        true -> throw({return, false});
        _ -> ok
    end,
                I2 = (I + 1),
                Fun_loop(I2)
            catch
                break -> {I}
            end;
        _ -> {I}
    end
end,
{I2} = Fun(I),
        true
    catch {return, V} -> V end.

isValidMove(M) ->
    try
        case (M == 0) of
        true -> throw({return, #{"idx" => (erlang:get('empty') - 4), "ok" => ((erlang:get('empty') div 4) > 0)}});
        _ -> ok
    end,
        case (M == 1) of
        true -> throw({return, #{"idx" => (erlang:get('empty') + 4), "ok" => ((erlang:get('empty') div 4) < 3)}});
        _ -> ok
    end,
        case (M == 2) of
        true -> throw({return, #{"idx" => (erlang:get('empty') + 1), "ok" => ((erlang:get('empty') rem 4) < 3)}});
        _ -> ok
    end,
        case (M == 3) of
        true -> throw({return, #{"idx" => (erlang:get('empty') - 1), "ok" => ((erlang:get('empty') rem 4) > 0)}});
        _ -> ok
    end,
        #{"idx" => 0, "ok" => false}
    catch {return, V} -> V end.

doMove(M2) ->
    try
        R = isValidMove(M2),
        case not maps:get("ok", R) of
        true -> throw({return, false});
        _ -> ok
    end,
        I3 = erlang:get('empty'),
        J = case erlang:is_integer(maps:get("idx", R)) of true -> maps:get("idx", R); _ -> case erlang:is_float(maps:get("idx", R)) of true -> trunc(maps:get("idx", R)); _ -> list_to_integer(maps:get("idx", R)) end end,
        Tmp = lists:nth(I3 + 1, erlang:get('board')),
        Board = erlang:get('board'),
        Board2 = lists:sublist(Board, I3) ++ [lists:nth(J + 1, erlang:get('board'))] ++ lists:nthtail(I3 + 1, Board),
        erlang:put('board', Board2),
        Board3 = erlang:get('board'),
        Board4 = lists:sublist(Board3, J) ++ [Tmp] ++ lists:nthtail(J + 1, Board3),
        erlang:put('board', Board4),
        erlang:put('empty', J),
        erlang:put('moves', (erlang:get('moves') + 1)),
        true
    catch {return, V} -> V end.

shuffle(N) ->
    try
        I4 = 0,
        Fun2 = fun Fun2_loop(I4, N) ->
    case ((I4 < N) orelse isSolved()) of
        true ->
            try
                case doMove(randMove()) of
        true -> I5 = (I4 + 1),
            I6 = I5;
        _ -> I6 = I4
    end,
                Fun2_loop(I6, N)
            catch
                break -> {I4, N}
            end;
        _ -> {I4, N}
    end
end,
{I6, N} = Fun2(I4, N),
        nil
    catch {return, V} -> V end.

printBoard() ->
    try
        Line = "",
        I7 = 0,
        Fun3 = fun Fun3_loop(I7, Line) ->
    case (I7 < 16) of
        true ->
            try
                Val = lists:nth(I7 + 1, erlang:get('board')),
                case (Val == 0) of
        true -> Line2 = (Line ++ "  ."),
            Line6 = Line2,
            S2 = nil;
        _ -> S = lists:flatten(io_lib:format("~p", [Val])),
            case (Val < 10) of
        true -> Line3 = ((Line ++ "  ") ++ S),
            Line5 = Line3;
        _ -> Line4 = ((Line ++ " ") ++ S),
            Line5 = Line4
    end,
            Line6 = Line5,
            S2 = S
    end,
                case ((I7 rem 4) == 3) of
        true -> io:format("~ts~n", [Line6]),
            Line7 = "",
            Line8 = Line7;
        _ -> Line8 = Line6
    end,
                I8 = (I7 + 1),
                Fun3_loop(I8, Line8)
            catch
                break -> {I7, Line}
            end;
        _ -> {I7, Line}
    end
end,
{I8, Line8} = Fun3(I7, Line),
        nil
    catch {return, V} -> V end.

playOneMove() ->
    try
        Fun4 = fun Fun4_loop() ->
    case true of
        true ->
            try
                io:format("~ts~n", [(("Enter move #" ++ lists:flatten(io_lib:format("~p", [(erlang:get('moves') + 1)]))) ++ " (U, D, L, R, or Q): ")]),
                S3 = string:trim(io:get_line("")),
                case (S3 == "") of
        true -> throw(continue);
        _ -> ok
    end,
                C = lists:sublist(S3, 0 + 1, (1 - 0)),
                M3 = 0,
                case ((C == "U") orelse (C == "u")) of
        true -> M4 = 0,
            M11 = M4;
        _ -> case ((C == "D") orelse (C == "d")) of
        true -> M5 = 1,
            M10 = M5;
        _ -> case ((C == "R") orelse (C == "r")) of
        true -> M6 = 2,
            M9 = M6;
        _ -> case ((C == "L") orelse (C == "l")) of
        true -> M7 = 3,
            M8 = M7;
        _ -> case ((C == "Q") orelse (C == "q")) of
        true -> io:format("~ts~n", [(("Quiting after " ++ lists:flatten(io_lib:format("~p", [erlang:get('moves')]))) ++ " moves.")]),
            erlang:put('quit', true),
            throw({return, nil});
        _ -> io:format("~ts~n", [((("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" ++ "up, down, left, or right. You can also enter \"Q\" to quit.\n") ++ "Upper or lowercase is accepted and only the first non-blank\n") ++ "character is important (i.e. you may enter \"up\" if you like).")]),
            throw(continue)
    end,
            M8 = M3
    end,
            M9 = M8
    end,
            M10 = M9
    end,
            M11 = M10
    end,
                case not doMove(M11) of
        true -> io:format("~ts~n", ["That is not a valid move at the moment."]),
            throw(continue);
        _ -> ok
    end,
                throw({return, nil}),
                Fun4_loop()
            catch
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun4(),
        nil
    catch {return, V} -> V end.

play() ->
    try
        io:format("~ts~n", ["Starting board:"]),
        Fun5 = fun Fun5_loop() ->
    case (not erlang:get('quit') andalso (isSolved() == false)) of
        true ->
            try
                io:format("~ts~n", [""]),
                printBoard(),
                playOneMove(),
                Fun5_loop()
            catch
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun5(),
        case isSolved() of
        true -> io:format("~ts~n", [(("You solved the puzzle in " ++ lists:flatten(io_lib:format("~p", [erlang:get('moves')]))) ++ " moves.")]);
        _ -> ok
    end,
        nil
    catch {return, V} -> V end.

main() ->
    try
        shuffle(50),
        play(),
        nil
    catch {return, V} -> V end.

main(_) ->
    erlang:put('board', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]),
    erlang:put('solved', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]),
    erlang:put('empty', 15),
    erlang:put('moves', 0),
    erlang:put('quit', false),
    main().
