#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, step/2, main/0]).

% Generated by Mochi transpiler v0.10.55 (67b72aa5ea) on 2025-08-02 22:23 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

step(N, Program) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, N, Program) ->
    case (I < length(Program)) of
        true ->
            Num = (case erlang:is_map((case erlang:is_map(Program) of true -> maps:get(I, Program, nil); _ -> lists:nth(I + 1, Program) end)) of true -> maps:get(0, (case erlang:is_map(Program) of true -> maps:get(I, Program, nil); _ -> lists:nth(I + 1, Program) end), nil); _ -> lists:nth(0 + 1, (case erlang:is_map(Program) of true -> maps:get(I, Program, nil); _ -> lists:nth(I + 1, Program) end)) end),
            Den = (case erlang:is_map((case erlang:is_map(Program) of true -> maps:get(I, Program, nil); _ -> lists:nth(I + 1, Program) end)) of true -> maps:get(1, (case erlang:is_map(Program) of true -> maps:get(I, Program, nil); _ -> lists:nth(I + 1, Program) end), nil); _ -> lists:nth(1 + 1, (case erlang:is_map(Program) of true -> maps:get(I, Program, nil); _ -> lists:nth(I + 1, Program) end)) end),
            case ((N rem Den) == 0) of
        true -> N_2 = ((N div Den) * Num),
            throw({return, #{"n" => N_2, "ok" => true}}),
            N_3 = N_2;
        _ -> N_3 = N
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, N_3, Program);
        _ -> {I, N, Program}
    end
end,
{I_2, N_3, Program} = Fun(I, N, Program),
        #{"n" => N_3, "ok" => false}
    catch {return, Ret} -> Ret end.

main() ->
    try
        Program_2 = [[17, 91], [78, 85], [19, 51], [23, 38], [29, 33], [77, 29], [95, 23], [77, 19], [1, 17], [11, 13], [13, 11], [15, 14], [15, 2], [55, 1]],
        N_4 = 2,
        Primes = 0,
        Count = 0,
        Limit = 1000000,
        Two = 2,
        Line = "",
        Fun_3 = fun Fun_3_loop(Count, Limit, Line, N_4, Primes, Program_2, Two) ->
    case ((Primes < 20) andalso (Count < Limit)) of
        true ->
            try
                Res = step(N_4, Program_2),
                N_5 = maps:get("n", Res, nil),
                case mochi_not(maps:get("ok", Res, nil)) of
        true -> throw(break);
        _ -> ok
    end,
                M = N_5,
                Pow = 0,
                Fun_2 = fun Fun_2_loop(Count, Limit, Line, M, N_5, Pow, Primes, Program_2, Res, Two) ->
    case ((M rem Two) == 0) of
        true ->
            M_2 = (M div Two),
            Pow_2 = (Pow + 1),
            Fun_2_loop(Count, Limit, Line, M_2, N_5, Pow_2, Primes, Program_2, Res, Two);
        _ -> {Count, Limit, Line, M, N_5, Pow, Primes, Program_2, Res, Two}
    end
end,
{Count, Limit, Line, M_2, N_5, Pow_2, Primes, Program_2, Res, Two} = Fun_2(Count, Limit, Line, M, N_5, Pow, Primes, Program_2, Res, Two),
                case ((M_2 == 1) andalso (Pow_2 > 1)) of
        true -> Line_2 = ((Line ++ lists:flatten(io_lib:format("~p", [Pow_2]))) ++ " "),
            Primes_2 = (Primes + 1),
            Line_3 = Line_2,
            Primes_3 = Primes_2;
        _ -> Line_3 = Line,
            Primes_3 = Primes
    end,
                Count_2 = (Count + 1),
                Fun_3_loop(Count_2, Limit, Line_3, N_5, Primes_3, Program_2, Two)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_3_loop(C0, C1, C2, C3, C4, C5, C6);
                break -> {Count, Limit, Line, N_4, Primes, Program_2, Two}
            end;
        _ -> {Count, Limit, Line, N_4, Primes, Program_2, Two}
    end
end,
{Count_2, Limit, Line_3, N_5, Primes_3, Program_2, Two} = Fun_3(Count, Limit, Line, N_4, Primes, Program_2, Two),
        case (length(Line_3) > 0) of
        true -> io:format("~ts~n", [string:substr(Line_3, 0 + 1, ((length(Line_3) - 1) - 0))]);
        _ -> io:format("~ts~n", [""])
    end,
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
