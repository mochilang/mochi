#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (0f7fd10226) on 2025-08-02 20:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

main() ->
    try
        INF = 1000000000,
        N = 4,
        Dist = [],
        Next = [],
        I = 0,
        Fun_2 = fun Fun_2_loop(INF, Dist, I, N, Next) ->
    case (I < N) of
        true ->
            Row = [],
            Nrow = [],
            J = 0,
            Fun = fun Fun_loop(INF, Dist, I, J, N, Next, Nrow, Row) ->
    case (J < N) of
        true ->
            case (I == J) of
        true -> Row_2 = lists:append(Row, [0]),
            Row_4 = Row_2;
        _ -> Row_3 = lists:append(Row, [INF]),
            Row_4 = Row_3
    end,
            Nrow_2 = lists:append(Nrow, [(0 - 1)]),
            J_2 = (J + 1),
            Fun_loop(INF, Dist, I, J_2, N, Next, Nrow_2, Row_4);
        _ -> {INF, Dist, I, J, N, Next, Nrow, Row}
    end
end,
{INF, Dist, I, J_2, N, Next, Nrow_2, Row_4} = Fun(INF, Dist, I, J, N, Next, Nrow, Row),
            Dist_2 = lists:append(Dist, [Row_4]),
            Next_2 = lists:append(Next, [Nrow_2]),
            I_2 = (I + 1),
            Fun_2_loop(INF, Dist_2, I_2, N, Next_2);
        _ -> {INF, Dist, I, N, Next}
    end
end,
{INF, Dist_2, I_2, N, Next_2} = Fun_2(INF, Dist, I, N, Next),
        Tmp = (case erlang:is_map(Dist_2) of true -> maps:get(0, Dist_2, nil); _ -> lists:nth(0 + 1, Dist_2) end),
        Tmp_2 = lists:sublist(Tmp, 2) ++ [-2] ++ lists:nthtail(2 + 1, Tmp),
        Dist_3 = lists:sublist(Dist_2, 0) ++ [Tmp_2] ++ lists:nthtail(0 + 1, Dist_2),
        Tmp_3 = (case erlang:is_map(Next_2) of true -> maps:get(0, Next_2, nil); _ -> lists:nth(0 + 1, Next_2) end),
        Tmp_4 = lists:sublist(Tmp_3, 2) ++ [2] ++ lists:nthtail(2 + 1, Tmp_3),
        Next_3 = lists:sublist(Next_2, 0) ++ [Tmp_4] ++ lists:nthtail(0 + 1, Next_2),
        Tmp_5 = (case erlang:is_map(Dist_3) of true -> maps:get(2, Dist_3, nil); _ -> lists:nth(2 + 1, Dist_3) end),
        Tmp_6 = lists:sublist(Tmp_5, 3) ++ [2] ++ lists:nthtail(3 + 1, Tmp_5),
        Dist_4 = lists:sublist(Dist_3, 2) ++ [Tmp_6] ++ lists:nthtail(2 + 1, Dist_3),
        Tmp_7 = (case erlang:is_map(Next_3) of true -> maps:get(2, Next_3, nil); _ -> lists:nth(2 + 1, Next_3) end),
        Tmp_8 = lists:sublist(Tmp_7, 3) ++ [3] ++ lists:nthtail(3 + 1, Tmp_7),
        Next_4 = lists:sublist(Next_3, 2) ++ [Tmp_8] ++ lists:nthtail(2 + 1, Next_3),
        Tmp_9 = (case erlang:is_map(Dist_4) of true -> maps:get(3, Dist_4, nil); _ -> lists:nth(3 + 1, Dist_4) end),
        Tmp_10 = lists:sublist(Tmp_9, 1) ++ [-1] ++ lists:nthtail(1 + 1, Tmp_9),
        Dist_5 = lists:sublist(Dist_4, 3) ++ [Tmp_10] ++ lists:nthtail(3 + 1, Dist_4),
        Tmp_11 = (case erlang:is_map(Next_4) of true -> maps:get(3, Next_4, nil); _ -> lists:nth(3 + 1, Next_4) end),
        Tmp_12 = lists:sublist(Tmp_11, 1) ++ [1] ++ lists:nthtail(1 + 1, Tmp_11),
        Next_5 = lists:sublist(Next_4, 3) ++ [Tmp_12] ++ lists:nthtail(3 + 1, Next_4),
        Tmp_13 = (case erlang:is_map(Dist_5) of true -> maps:get(1, Dist_5, nil); _ -> lists:nth(1 + 1, Dist_5) end),
        Tmp_14 = lists:sublist(Tmp_13, 0) ++ [4] ++ lists:nthtail(0 + 1, Tmp_13),
        Dist_6 = lists:sublist(Dist_5, 1) ++ [Tmp_14] ++ lists:nthtail(1 + 1, Dist_5),
        Tmp_15 = (case erlang:is_map(Next_5) of true -> maps:get(1, Next_5, nil); _ -> lists:nth(1 + 1, Next_5) end),
        Tmp_16 = lists:sublist(Tmp_15, 0) ++ [0] ++ lists:nthtail(0 + 1, Tmp_15),
        Next_6 = lists:sublist(Next_5, 1) ++ [Tmp_16] ++ lists:nthtail(1 + 1, Next_5),
        Tmp_17 = (case erlang:is_map(Dist_6) of true -> maps:get(1, Dist_6, nil); _ -> lists:nth(1 + 1, Dist_6) end),
        Tmp_18 = lists:sublist(Tmp_17, 2) ++ [3] ++ lists:nthtail(2 + 1, Tmp_17),
        Dist_7 = lists:sublist(Dist_6, 1) ++ [Tmp_18] ++ lists:nthtail(1 + 1, Dist_6),
        Tmp_19 = (case erlang:is_map(Next_6) of true -> maps:get(1, Next_6, nil); _ -> lists:nth(1 + 1, Next_6) end),
        Tmp_20 = lists:sublist(Tmp_19, 2) ++ [2] ++ lists:nthtail(2 + 1, Tmp_19),
        Next_7 = lists:sublist(Next_6, 1) ++ [Tmp_20] ++ lists:nthtail(1 + 1, Next_6),
        K = 0,
        Fun_5 = fun Fun_5_loop(INF, Dist_7, I_2, K, N, Next_7, Tmp_20) ->
    case (K < N) of
        true ->
            I_3 = 0,
            Fun_4 = fun Fun_4_loop(INF, Dist_7, I_3, K, N, Next_7, Tmp_20) ->
    case (I_3 < N) of
        true ->
            J_3 = 0,
            Fun_3 = fun Fun_3_loop(INF, Dist_7, I_3, J_3, K, N, Next_7, Tmp_20) ->
    case (J_3 < N) of
        true ->
            case (((case erlang:is_map((case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end)) of true -> maps:get(K, (case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end), nil); _ -> lists:nth(K + 1, (case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end)) end) < INF) andalso ((case erlang:is_map((case erlang:is_map(Dist_7) of true -> maps:get(K, Dist_7, nil); _ -> lists:nth(K + 1, Dist_7) end)) of true -> maps:get(J_3, (case erlang:is_map(Dist_7) of true -> maps:get(K, Dist_7, nil); _ -> lists:nth(K + 1, Dist_7) end), nil); _ -> lists:nth(J_3 + 1, (case erlang:is_map(Dist_7) of true -> maps:get(K, Dist_7, nil); _ -> lists:nth(K + 1, Dist_7) end)) end) < INF)) of
        true -> Alt = ((case erlang:is_map((case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end)) of true -> maps:get(K, (case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end), nil); _ -> lists:nth(K + 1, (case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end)) end) + (case erlang:is_map((case erlang:is_map(Dist_7) of true -> maps:get(K, Dist_7, nil); _ -> lists:nth(K + 1, Dist_7) end)) of true -> maps:get(J_3, (case erlang:is_map(Dist_7) of true -> maps:get(K, Dist_7, nil); _ -> lists:nth(K + 1, Dist_7) end), nil); _ -> lists:nth(J_3 + 1, (case erlang:is_map(Dist_7) of true -> maps:get(K, Dist_7, nil); _ -> lists:nth(K + 1, Dist_7) end)) end)),
            case (Alt < (case erlang:is_map((case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end)) of true -> maps:get(J_3, (case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end), nil); _ -> lists:nth(J_3 + 1, (case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end)) end)) of
        true -> Tmp_21 = (case erlang:is_map(Dist_7) of true -> maps:get(I_3, Dist_7, nil); _ -> lists:nth(I_3 + 1, Dist_7) end),
            Tmp_22 = lists:sublist(Tmp_21, J_3) ++ [Alt] ++ lists:nthtail(J_3 + 1, Tmp_21),
            Dist_8 = lists:sublist(Dist_7, I_3) ++ [Tmp_22] ++ lists:nthtail(I_3 + 1, Dist_7),
            Tmp_23 = (case erlang:is_map(Next_7) of true -> maps:get(I_3, Next_7, nil); _ -> lists:nth(I_3 + 1, Next_7) end),
            Tmp_24 = lists:sublist(Tmp_23, J_3) ++ [(case erlang:is_map((case erlang:is_map(Next_7) of true -> maps:get(I_3, Next_7, nil); _ -> lists:nth(I_3 + 1, Next_7) end)) of true -> maps:get(K, (case erlang:is_map(Next_7) of true -> maps:get(I_3, Next_7, nil); _ -> lists:nth(I_3 + 1, Next_7) end), nil); _ -> lists:nth(K + 1, (case erlang:is_map(Next_7) of true -> maps:get(I_3, Next_7, nil); _ -> lists:nth(I_3 + 1, Next_7) end)) end)] ++ lists:nthtail(J_3 + 1, Tmp_23),
            Next_8 = lists:sublist(Next_7, I_3) ++ [Tmp_24] ++ lists:nthtail(I_3 + 1, Next_7),
            Dist_9 = Dist_8,
            Next_9 = Next_8,
            Tmp_25 = Tmp_24;
        _ -> Dist_9 = Dist_7,
            Next_9 = Next_7,
            Tmp_25 = Tmp_20
    end,
            Alt_2 = Alt,
            Dist_10 = Dist_9,
            Next_10 = Next_9,
            Tmp_26 = Tmp_25;
        _ -> Alt_2 = nil,
            Dist_10 = Dist_7,
            Next_10 = Next_7,
            Tmp_26 = Tmp_20
    end,
            J_4 = (J_3 + 1),
            Fun_3_loop(INF, Dist_10, I_3, J_4, K, N, Next_10, Tmp_26);
        _ -> {INF, Dist_7, I_3, J_3, K, N, Next_7, Tmp_20}
    end
end,
{INF, Dist_10, I_3, J_4, K, N, Next_10, Tmp_26} = Fun_3(INF, Dist_7, I_3, J_3, K, N, Next_7, Tmp_20),
            I_4 = (I_3 + 1),
            Fun_4_loop(INF, Dist_10, I_4, K, N, Next_10, Tmp_26);
        _ -> {INF, Dist_7, I_3, K, N, Next_7, Tmp_20}
    end
end,
{INF, Dist_10, I_4, K, N, Next_10, Tmp_26} = Fun_4(INF, Dist_7, I_3, K, N, Next_7, Tmp_20),
            K_2 = (K + 1),
            Fun_5_loop(INF, Dist_10, I_4, K_2, N, Next_10, Tmp_26);
        _ -> {INF, Dist_7, I_2, K, N, Next_7, Tmp_20}
    end
end,
{INF, Dist_10, I_4, K_2, N, Next_10, Tmp_26} = Fun_5(INF, Dist_7, I_2, K, N, Next_7, Tmp_20),
        Path = fun Path(U, V) ->
    try
        Ui = (U - 1),
        Vi = (V - 1),
        case ((case erlang:is_map((case erlang:is_map(Next_10) of true -> maps:get(Ui, Next_10, nil); _ -> lists:nth(Ui + 1, Next_10) end)) of true -> maps:get(Vi, (case erlang:is_map(Next_10) of true -> maps:get(Ui, Next_10, nil); _ -> lists:nth(Ui + 1, Next_10) end), nil); _ -> lists:nth(Vi + 1, (case erlang:is_map(Next_10) of true -> maps:get(Ui, Next_10, nil); _ -> lists:nth(Ui + 1, Next_10) end)) end) == (0 - 1)) of
        true -> throw({return, []});
        _ -> ok
    end,
        P = [U],
        Cur = Ui,
        Fun_6 = fun Fun_6_loop(INF, Cur, Dist_10, I_4, K_2, N, Next_10, P, Path, Tmp_26, U, Ui, V, Vi) ->
    case (Cur /= Vi) of
        true ->
            Cur_2 = (case erlang:is_map((case erlang:is_map(Next_10) of true -> maps:get(Cur, Next_10, nil); _ -> lists:nth(Cur + 1, Next_10) end)) of true -> maps:get(Vi, (case erlang:is_map(Next_10) of true -> maps:get(Cur, Next_10, nil); _ -> lists:nth(Cur + 1, Next_10) end), nil); _ -> lists:nth(Vi + 1, (case erlang:is_map(Next_10) of true -> maps:get(Cur, Next_10, nil); _ -> lists:nth(Cur + 1, Next_10) end)) end),
            P_2 = lists:append(P, [(Cur_2 + 1)]),
            Fun_6_loop(INF, Cur_2, Dist_10, I_4, K_2, N, Next_10, P_2, Path, Tmp_26, U, Ui, V, Vi);
        _ -> {INF, Cur, Dist_10, I_4, K_2, N, Next_10, P, Path, Tmp_26, U, Ui, V, Vi}
    end
end,
{INF, Cur_2, Dist_10, I_4, K_2, N, Next_10, P_2, Path, Tmp_26, U, Ui, V, Vi} = Fun_6(INF, Cur, Dist_10, I_4, K_2, N, Next_10, P, Path, Tmp_26, U, Ui, V, Vi),
        P_2
    catch {return, Ret} -> Ret end
end,
        PathStr = fun PathStr(P_3) ->
    try
        S = "",
        First = true,
        Idx = 0,
        Fun_7 = fun Fun_7_loop(INF, Dist_10, First, I_4, Idx, K_2, N, Next_10, P_3, Path, PathStr, S, Tmp_26) ->
    case (Idx < length(P_3)) of
        true ->
            X = (case erlang:is_map(P_3) of true -> maps:get(Idx, P_3, nil); _ -> lists:nth(Idx + 1, P_3) end),
            case mochi_not(First) of
        true -> S_2 = (S ++ " -> "),
            S_3 = S_2;
        _ -> S_3 = S
    end,
            S_4 = (S_3 ++ lists:flatten(io_lib:format("~p", [X]))),
            First_2 = false,
            Idx_2 = (Idx + 1),
            Fun_7_loop(INF, Dist_10, First_2, I_4, Idx_2, K_2, N, Next_10, P_3, Path, PathStr, S_4, Tmp_26);
        _ -> {INF, Dist_10, First, I_4, Idx, K_2, N, Next_10, P_3, Path, PathStr, S, Tmp_26}
    end
end,
{INF, Dist_10, First_2, I_4, Idx_2, K_2, N, Next_10, P_3, Path, PathStr, S_4, Tmp_26} = Fun_7(INF, Dist_10, First, I_4, Idx, K_2, N, Next_10, P_3, Path, PathStr, S, Tmp_26),
        S_4
    catch {return, Ret} -> Ret end
end,
        io:format("~ts~n", ["pair\tdist\tpath"]),
        A = 0,
        Fun_9 = fun Fun_9_loop(INF, A, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26) ->
    case (A < N) of
        true ->
            B = 0,
            Fun_8 = fun Fun_8_loop(INF, A, B, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26) ->
    case (B < N) of
        true ->
            case (A /= B) of
        true -> io:format("~ts~n", [((((((lists:flatten(io_lib:format("~p", [(A + 1)])) ++ " -> ") ++ lists:flatten(io_lib:format("~p", [(B + 1)]))) ++ "\t") ++ lists:flatten(io_lib:format("~p", [(case erlang:is_map((case erlang:is_map(Dist_10) of true -> maps:get(A, Dist_10, nil); _ -> lists:nth(A + 1, Dist_10) end)) of true -> maps:get(B, (case erlang:is_map(Dist_10) of true -> maps:get(A, Dist_10, nil); _ -> lists:nth(A + 1, Dist_10) end), nil); _ -> lists:nth(B + 1, (case erlang:is_map(Dist_10) of true -> maps:get(A, Dist_10, nil); _ -> lists:nth(A + 1, Dist_10) end)) end)]))) ++ "\t") ++ PathStr(Path((A + 1), (B + 1))))]);
        _ -> ok
    end,
            B_2 = (B + 1),
            Fun_8_loop(INF, A, B_2, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26);
        _ -> {INF, A, B, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26}
    end
end,
{INF, A, B_2, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26} = Fun_8(INF, A, B, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26),
            A_2 = (A + 1),
            Fun_9_loop(INF, A_2, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26);
        _ -> {INF, A, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26}
    end
end,
{INF, A_2, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26} = Fun_9(INF, A, Dist_10, I_4, K_2, N, Next_10, Path, PathStr, Tmp_26),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
