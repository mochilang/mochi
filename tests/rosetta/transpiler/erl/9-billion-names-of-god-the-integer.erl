#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, bigTrim/1, bigFromInt/1, bigAdd/2, bigSub/2, bigToString/1, minInt/2, cumu/1, row/1]).

% Generated by Mochi transpiler v0.10.37 (27e27aafa9) on 2025-07-23 06:49 UTC

bigTrim(A) ->
    try
        N = length(A),
        Fun = fun Fun_loop(A, N) ->
    case ((N > 1) andalso (lists:nth((N - 1) + 1, A) == 0)) of
        true ->
            try
                A2 = lists:sublist(A, 0 + 1, ((N - 1) - 0)),
                N2 = (N - 1),
                Fun_loop(A2, N2)
            catch
                break -> {A, N}
            end;
        _ -> {A, N}
    end
end,
{A2, N2} = Fun(A, N),
        A2
    catch {return, V} -> V end.

bigFromInt(X) ->
    try
        case (X == 0) of
        true -> throw({return, [0]});
        _ -> ok
    end,
        Digits = [],
        N3 = X,
        Fun2 = fun Fun2_loop(Digits, N3, X) ->
    case (N3 > 0) of
        true ->
            try
                Digits2 = lists:append(Digits, [(N3 rem 10)]),
                N4 = (N3 div 10),
                Fun2_loop(Digits2, N4, X)
            catch
                break -> {Digits, N3, X}
            end;
        _ -> {Digits, N3, X}
    end
end,
{Digits2, N4, X} = Fun2(Digits, N3, X),
        Digits2
    catch {return, V} -> V end.

bigAdd(A3, B) ->
    try
        Res = [],
        Carry = 0,
        I = 0,
        Fun3 = fun Fun3_loop(A3, B, Carry, I, Res) ->
    case (((I < length(A3)) orelse (I < length(B))) orelse (Carry > 0)) of
        true ->
            try
                Av = 0,
                case (I < length(A3)) of
        true -> Av2 = lists:nth(I + 1, A3),
            Av3 = Av2;
        _ -> Av3 = Av
    end,
                Bv = 0,
                case (I < length(B)) of
        true -> Bv2 = lists:nth(I + 1, B),
            Bv3 = Bv2;
        _ -> Bv3 = Bv
    end,
                S = ((Av3 + Bv3) + Carry),
                Res2 = lists:append(Res, [(S rem 10)]),
                Carry2 = (S div 10),
                I2 = (I + 1),
                Fun3_loop(A3, B, Carry2, I2, Res2)
            catch
                break -> {A3, B, Carry, I, Res}
            end;
        _ -> {A3, B, Carry, I, Res}
    end
end,
{A3, B, Carry2, I2, Res2} = Fun3(A3, B, Carry, I, Res),
        bigTrim(Res2)
    catch {return, V} -> V end.

bigSub(A4, B2) ->
    try
        Res3 = [],
        Borrow = 0,
        I3 = 0,
        Fun4 = fun Fun4_loop(A4, B2, Borrow, I3, Res3) ->
    case (I3 < length(A4)) of
        true ->
            try
                Av4 = lists:nth(I3 + 1, A4),
                Bv4 = 0,
                case (I3 < length(B2)) of
        true -> Bv5 = lists:nth(I3 + 1, B2),
            Bv6 = Bv5;
        _ -> Bv6 = Bv4
    end,
                Diff = ((Av4 - Bv6) - Borrow),
                case (Diff < 0) of
        true -> Diff2 = (Diff + 10),
            Borrow2 = 1,
            Borrow4 = Borrow2,
            Diff3 = Diff2;
        _ -> Borrow3 = 0,
            Borrow4 = Borrow3,
            Diff3 = Diff
    end,
                Res4 = lists:append(Res3, [Diff3]),
                I4 = (I3 + 1),
                Fun4_loop(A4, B2, Borrow4, I4, Res4)
            catch
                break -> {A4, B2, Borrow, I3, Res3}
            end;
        _ -> {A4, B2, Borrow, I3, Res3}
    end
end,
{A4, B2, Borrow4, I4, Res4} = Fun4(A4, B2, Borrow, I3, Res3),
        bigTrim(Res4)
    catch {return, V} -> V end.

bigToString(A5) ->
    try
        S2 = "",
        I5 = (length(A5) - 1),
        Fun5 = fun Fun5_loop(A5, I5, S2) ->
    case (I5 >= 0) of
        true ->
            try
                S3 = (S2 ++ lists:flatten(io_lib:format("~p", [lists:nth(I5 + 1, A5)]))),
                I6 = (I5 - 1),
                Fun5_loop(A5, I6, S3)
            catch
                break -> {A5, I5, S2}
            end;
        _ -> {A5, I5, S2}
    end
end,
{A5, I6, S3} = Fun5(A5, I5, S2),
        S3
    catch {return, V} -> V end.

minInt(A6, B3) ->
    try
        case (A6 < B3) of
        true -> throw({return, A6});
        _ -> throw({return, B3})
    end,
        nil
    catch {return, V} -> V end.

cumu(N5) ->
    try
        Cache = [[bigFromInt(1)]],
        Y = 1,
        Fun7 = fun Fun7_loop(Cache, N5, Y) ->
    case (Y =< N5) of
        true ->
            try
                Row = [bigFromInt(0)],
                X2 = 1,
                Fun6 = fun Fun6_loop(Cache, N5, Row, X2, Y) ->
    case (X2 =< Y) of
        true ->
            try
                Val = lists:nth(minInt(X2, (Y - X2)) + 1, lists:nth((Y - X2) + 1, Cache)),
                Row2 = lists:append(Row, [bigAdd(lists:nth((length(Row) - 1) + 1, Row), Val)]),
                X3 = (X2 + 1),
                Fun6_loop(Cache, N5, Row2, X3, Y)
            catch
                break -> {Cache, N5, Row, X2, Y}
            end;
        _ -> {Cache, N5, Row, X2, Y}
    end
end,
{Cache, N5, Row2, X3, Y} = Fun6(Cache, N5, Row, X2, Y),
                Cache2 = lists:append(Cache, [Row2]),
                Y2 = (Y + 1),
                Fun7_loop(Cache2, N5, Y2)
            catch
                break -> {Cache, N5, Y}
            end;
        _ -> {Cache, N5, Y}
    end
end,
{Cache2, N5, Y2} = Fun7(Cache, N5, Y),
        lists:nth(N5 + 1, Cache2)
    catch {return, V} -> V end.

row(N6) ->
    try
        E = cumu(N6),
        Out = [],
        I7 = 0,
        Fun8 = fun Fun8_loop(E, I7, N6, Out) ->
    case (I7 < N6) of
        true ->
            try
                Diff4 = bigSub(lists:nth((I7 + 1) + 1, E), lists:nth(I7 + 1, E)),
                Out2 = lists:append(Out, [bigToString(Diff4)]),
                I8 = (I7 + 1),
                Fun8_loop(E, I8, N6, Out2)
            catch
                break -> {E, I7, N6, Out}
            end;
        _ -> {E, I7, N6, Out}
    end
end,
{E, I8, N6, Out2} = Fun8(E, I7, N6, Out),
        Out2
    catch {return, V} -> V end.

main(_) ->
    io:format("~ts~n", ["rows:"]),
    erlang:put('x', 1),
    Fun10 = fun Fun10_loop() ->
    case (erlang:get('x') < 11) of
        true ->
            try
                R = row(erlang:get('x')),
                Line = "",
                I9 = 0,
                Fun9 = fun Fun9_loop(I9, Line, R) ->
    case (I9 < length(R)) of
        true ->
            try
                Line2 = (((Line ++ " ") ++ lists:nth(I9 + 1, R)) ++ " "),
                I10 = (I9 + 1),
                Fun9_loop(I10, Line2, R)
            catch
                break -> {I9, Line, R}
            end;
        _ -> {I9, Line, R}
    end
end,
{I10, Line2, R} = Fun9(I9, Line, R),
                io:format("~ts~n", [Line2]),
                erlang:put('x', (erlang:get('x') + 1)),
                Fun10_loop()
            catch
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun10(),
    io:format("~ts~n", [""]),
    io:format("~ts~n", ["sums:"]),
    Fun11 = fun Fun11_loop(List) ->
    case List of
        [] -> {};
        [Num|Fun11_loop_rest] ->
            R2 = cumu(Num),
            io:format("~ts~n", [((lists:flatten(io_lib:format("~p", [Num])) ++ " ") ++ bigToString(lists:nth((length(R2) - 1) + 1, R2)))]),
            Fun11_loop(Fun11_loop_rest)
    end
end,
{} = Fun11([23, 123, 1234]).
