#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, node/1, getlink/2, setlink/3, opp/1, single/2, double/2, adjustbalance/3, insertbalance/2, insertr/2, insert/2, removebalance/2, remover/2, remove/2, indentstr/1, dumpnode/3, dump/2, main/0]).

-compile({no_auto_import,[node/1]}).
% Generated by Mochi transpiler v0.10.40 (5ec8b59a93) on 2025-07-25 12:29 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

node(Data) ->
    try
        #{"Data" => Data, "Balance" => 0, "Link" => [nil, nil]}
    catch {return, Ret} -> Ret end.

getlink(N, Dir) ->
    try
        lists:nth(Dir + 1, maps:get("Link", N, nil))
    catch {return, Ret} -> Ret end.

setlink(N_2, Dir_2, V) ->
    try
        Links = maps:get("Link", N_2, nil),
        Links_2 = lists:sublist(Links, Dir_2) ++ [V] ++ lists:nthtail(Dir_2 + 1, Links),
        N_3 = maps:put("Link", Links_2, N_2),
        N_3
    catch {return, Ret} -> Ret end.

opp(Dir_3) ->
    try
        (1 - Dir_3)
    catch {return, Ret} -> Ret end.

single(Root, Dir_4) ->
    try
        Tmp = getlink(Root, opp(Dir_4)),
        setlink(Root, opp(Dir_4), getlink(Tmp, Dir_4)),
        setlink(Tmp, Dir_4, Root),
        Tmp
    catch {return, Ret} -> Ret end.

double(Root_2, Dir_5) ->
    try
        Tmp_2 = getlink(getlink(Root_2, opp(Dir_5)), Dir_5),
        setlink(getlink(Root_2, opp(Dir_5)), Dir_5, getlink(Tmp_2, opp(Dir_5))),
        setlink(Tmp_2, opp(Dir_5), getlink(Root_2, opp(Dir_5))),
        setlink(Root_2, opp(Dir_5), Tmp_2),
        Tmp_3 = getlink(Root_2, opp(Dir_5)),
        setlink(Root_2, opp(Dir_5), getlink(Tmp_3, Dir_5)),
        setlink(Tmp_3, Dir_5, Root_2),
        Tmp_3
    catch {return, Ret} -> Ret end.

adjustbalance(Root_3, Dir_6, Bal) ->
    try
        N_4 = getlink(Root_3, Dir_6),
        Nn = getlink(N_4, opp(Dir_6)),
        case (maps:get("Balance", Nn, nil) == 0) of
        true -> Root_4 = maps:put("Balance", 0, Root_3),
            N_5 = maps:put("Balance", 0, N_4),
            N_9 = N_5,
            Root_8 = Root_4;
        _ -> case (maps:get("Balance", Nn, nil) == Bal) of
        true -> Root_5 = maps:put("Balance", -Bal, Root_3),
            N_6 = maps:put("Balance", 0, N_4),
            N_8 = N_6,
            Root_7 = Root_5;
        _ -> Root_6 = maps:put("Balance", 0, Root_3),
            N_7 = maps:put("Balance", Bal, N_4),
            N_8 = N_7,
            Root_7 = Root_6
    end,
            N_9 = N_8,
            Root_8 = Root_7
    end,
        Nn_2 = maps:put("Balance", 0, Nn),
        nil
    catch {return, Ret} -> Ret end.

insertbalance(Root_9, Dir_7) ->
    try
        N_10 = getlink(Root_9, Dir_7),
        Bal_2 = ((2 * Dir_7) - 1),
        case (maps:get("Balance", N_10, nil) == Bal_2) of
        true -> Root_10 = maps:put("Balance", 0, Root_9),
            N_11 = maps:put("Balance", 0, N_10),
            throw({return, single(Root_10, opp(Dir_7))}),
            N_12 = N_11,
            Root_11 = Root_10;
        _ -> N_12 = N_10,
            Root_11 = Root_9
    end,
        adjustbalance(Root_11, Dir_7, Bal_2),
        double(Root_11, opp(Dir_7))
    catch {return, Ret} -> Ret end.

insertr(Root_12, Data_2) ->
    try
        case (Root_12 == nil) of
        true -> throw({return, #{"node" => node(Data_2), "done" => false}});
        _ -> ok
    end,
        Node = Root_12,
        Dir_8 = 0,
        case (mochi_to_int(maps:get("Data", Node, nil)) < Data_2) of
        true -> Dir_9 = 1,
            Dir_10 = Dir_9;
        _ -> Dir_10 = Dir_8
    end,
        R = insertr(getlink(Node, Dir_10), Data_2),
        setlink(Node, Dir_10, maps:get("node", R, nil)),
        case maps:get("done", R, nil) of
        true -> throw({return, #{"node" => Node, "done" => true}});
        _ -> ok
    end,
        Node_2 = maps:put("Balance", (mochi_to_int(maps:get("Balance", Node, nil)) + ((2 * Dir_10) - 1)), Node),
        case (maps:get("Balance", Node_2, nil) == 0) of
        true -> throw({return, #{"node" => Node_2, "done" => true}});
        _ -> ok
    end,
        case ((maps:get("Balance", Node_2, nil) == 1) orelse (maps:get("Balance", Node_2, nil) == -1)) of
        true -> throw({return, #{"node" => Node_2, "done" => false}});
        _ -> ok
    end,
        #{"node" => insertbalance(Node_2, Dir_10), "done" => true}
    catch {return, Ret} -> Ret end.

insert(Tree, Data_3) ->
    try
        R_2 = insertr(Tree, Data_3),
        maps:get("node", R_2, nil)
    catch {return, Ret} -> Ret end.

removebalance(Root_13, Dir_11) ->
    try
        N_13 = getlink(Root_13, opp(Dir_11)),
        Bal_3 = ((2 * Dir_11) - 1),
        case (maps:get("Balance", N_13, nil) == -Bal_3) of
        true -> Root_14 = maps:put("Balance", 0, Root_13),
            N_14 = maps:put("Balance", 0, N_13),
            throw({return, #{"node" => single(Root_14, Dir_11), "done" => false}}),
            N_15 = N_14,
            Root_15 = Root_14;
        _ -> N_15 = N_13,
            Root_15 = Root_13
    end,
        case (maps:get("Balance", N_15, nil) == Bal_3) of
        true -> adjustbalance(Root_15, opp(Dir_11), -Bal_3),
            throw({return, #{"node" => double(Root_15, Dir_11), "done" => false}});
        _ -> ok
    end,
        Root_16 = maps:put("Balance", -Bal_3, Root_15),
        N_16 = maps:put("Balance", Bal_3, N_15),
        #{"node" => single(Root_16, Dir_11), "done" => true}
    catch {return, Ret} -> Ret end.

remover(Root_17, Data_4) ->
    try
        case (Root_17 == nil) of
        true -> throw({return, #{"node" => nil, "done" => false}});
        _ -> ok
    end,
        Node_3 = Root_17,
        case (mochi_to_int(maps:get("Data", Node_3, nil)) == Data_4) of
        true -> case (getlink(Node_3, 0) == nil) of
        true -> throw({return, #{"node" => getlink(Node_3, 1), "done" => false}});
        _ -> ok
    end,
            case (getlink(Node_3, 1) == nil) of
        true -> throw({return, #{"node" => getlink(Node_3, 0), "done" => false}});
        _ -> ok
    end,
            Heir = getlink(Node_3, 0),
            Fun = fun Fun_loop(Data_4, Heir, Node_3, Root_17) ->
    case (getlink(Heir, 1) /= nil) of
        true ->
            Heir_2 = getlink(Heir, 1),
            Fun_loop(Data_4, Heir_2, Node_3, Root_17);
        _ -> {Data_4, Heir, Node_3, Root_17}
    end
end,
{Data_4, Heir_2, Node_3, Root_17} = Fun(Data_4, Heir, Node_3, Root_17),
            Node_4 = maps:put("Data", maps:get("Data", Heir_2, nil), Node_3),
            Data_5 = mochi_to_int(maps:get("Data", Heir_2, nil)),
            Data_6 = Data_5,
            Fun_2 = Fun,
            Heir_3 = Heir_2,
            Node_5 = Node_4;
        _ -> Data_6 = Data_4,
            Fun_2 = nil,
            Heir_3 = nil,
            Node_5 = Node_3
    end,
        Dir_12 = 0,
        case (mochi_to_int(maps:get("Data", Node_5, nil)) < Data_6) of
        true -> Dir_13 = 1,
            Dir_14 = Dir_13;
        _ -> Dir_14 = Dir_12
    end,
        R_3 = remover(getlink(Node_5, Dir_14), Data_6),
        setlink(Node_5, Dir_14, maps:get("node", R_3, nil)),
        case maps:get("done", R_3, nil) of
        true -> throw({return, #{"node" => Node_5, "done" => true}});
        _ -> ok
    end,
        Node_6 = maps:put("Balance", ((mochi_to_int(maps:get("Balance", Node_5, nil)) + 1) - (2 * Dir_14)), Node_5),
        case ((maps:get("Balance", Node_6, nil) == 1) orelse (maps:get("Balance", Node_6, nil) == -1)) of
        true -> throw({return, #{"node" => Node_6, "done" => true}});
        _ -> ok
    end,
        case (maps:get("Balance", Node_6, nil) == 0) of
        true -> throw({return, #{"node" => Node_6, "done" => false}});
        _ -> ok
    end,
        removebalance(Node_6, Dir_14)
    catch {return, Ret} -> Ret end.

remove(Tree_2, Data_7) ->
    try
        R_4 = remover(Tree_2, Data_7),
        maps:get("node", R_4, nil)
    catch {return, Ret} -> Ret end.

indentstr(N_17) ->
    try
        S = "",
        I = 0,
        Fun_3 = fun Fun_3_loop(I, N_17, S) ->
    case (I < N_17) of
        true ->
            S_2 = (S ++ " "),
            I_2 = (I + 1),
            Fun_3_loop(I_2, N_17, S_2);
        _ -> {I, N_17, S}
    end
end,
{I_2, N_17, S_2} = Fun_3(I, N_17, S),
        S_2
    catch {return, Ret} -> Ret end.

dumpnode(Node_7, Indent, Comma) ->
    try
        Sp = indentstr(Indent),
        case (Node_7 == nil) of
        true -> Line = (Sp ++ "null"),
            case (Comma /= nil) of
        true -> Line_2 = (Line ++ ","),
            Line_3 = Line_2;
        _ -> Line_3 = Line
    end,
            io:format("~ts~n", [Line_3]),
            End_4 = nil,
            Line_4 = Line_3;
        _ -> io:format("~ts~n", [(Sp ++ "{")]),
            io:format("~ts~n", [(((indentstr((Indent + 3)) ++ "\"Data\": ") ++ lists:flatten(io_lib:format("~p", [maps:get("Data", Node_7, nil)]))) ++ ",")]),
            io:format("~ts~n", [(((indentstr((Indent + 3)) ++ "\"Balance\": ") ++ lists:flatten(io_lib:format("~p", [maps:get("Balance", Node_7, nil)]))) ++ ",")]),
            io:format("~ts~n", [(indentstr((Indent + 3)) ++ "\"Link\": [")]),
            dumpnode(getlink(Node_7, 0), (Indent + 6), true),
            dumpnode(getlink(Node_7, 1), (Indent + 6), false),
            io:format("~ts~n", [(indentstr((Indent + 3)) ++ "]")]),
            End = (Sp ++ "}"),
            case (Comma /= nil) of
        true -> End_2 = (End ++ ","),
            End_3 = End_2;
        _ -> End_3 = End
    end,
            io:format("~ts~n", [End_3]),
            End_4 = End_3,
            Line_4 = nil
    end,
        nil
    catch {return, Ret} -> Ret end.

dump(Node_8, Indent_2) ->
    try
        dumpnode(Node_8, Indent_2, false),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Tree_3 = nil,
        io:format("~ts~n", ["Empty tree:"]),
        dump(Tree_3, 0),
        io:format("~ts~n", [""]),
        io:format("~ts~n", ["Insert test:"]),
        Tree_4 = insert(Tree_3, 3),
        Tree_5 = insert(Tree_4, 1),
        Tree_6 = insert(Tree_5, 4),
        Tree_7 = insert(Tree_6, 1),
        Tree_8 = insert(Tree_7, 5),
        dump(Tree_8, 0),
        io:format("~ts~n", [""]),
        io:format("~ts~n", ["Remove test:"]),
        Tree_9 = remove(Tree_8, 3),
        Tree_10 = remove(Tree_9, 1),
        T = Tree_10,
        T_2 = maps:put("Balance", 0, T),
        Tree_11 = T_2,
        dump(Tree_11, 0),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
