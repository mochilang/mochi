#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, trimleftzeros/1, btstring/1, bttostring/1, btint/1, bttoint/1, btneg/1, btadd/2, btmul/2, padleft/2, show/2, main/0]).

% Generated by Mochi transpiler v0.10.40 (305ff8442f) on 2025-07-25 12:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

trimleftzeros(S) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, S) ->
    case ((I < length(S)) andalso (string:substr(S, I + 1, ((I + 1) - I)) == "0")) of
        true ->
            I_2 = (I + 1),
            Fun_loop(I_2, S);
        _ -> {I, S}
    end
end,
{I_2, S} = Fun(I, S),
        string:substr(S, I_2 + 1, (length(S) - I_2))
    catch {return, Ret} -> Ret end.

btstring(S_2) ->
    try
        S_3 = trimleftzeros(S_2),
        B = [],
        I_3 = (length(S_3) - 1),
        Fun_2 = fun Fun_2_loop(B, I_3, S_3) ->
    case (I_3 >= 0) of
        true ->
            Ch = string:substr(S_3, I_3 + 1, ((I_3 + 1) - I_3)),
            case (Ch == "+") of
        true -> B_2 = lists:append(B, [1]),
            B_7 = B_2;
        _ -> case (Ch == "0") of
        true -> B_3 = lists:append(B, [0]),
            B_6 = B_3;
        _ -> case (Ch == "-") of
        true -> B_4 = lists:append(B, [(0 - 1)]),
            B_5 = B_4;
        _ -> throw({return, #{"bt" => [], "ok" => false}}),
            B_5 = B
    end,
            B_6 = B_5
    end,
            B_7 = B_6
    end,
            I_4 = (I_3 - 1),
            Fun_2_loop(B_7, I_4, S_3);
        _ -> {B, I_3, S_3}
    end
end,
{B_7, I_4, S_3} = Fun_2(B, I_3, S_3),
        #{"bt" => B_7, "ok" => true}
    catch {return, Ret} -> Ret end.

bttostring(B_8) ->
    try
        case (length(B_8) == 0) of
        true -> throw({return, "0"});
        _ -> ok
    end,
        R = "",
        I_5 = (length(B_8) - 1),
        Fun_3 = fun Fun_3_loop(B_8, I_5, R) ->
    case (I_5 >= 0) of
        true ->
            D = lists:nth(I_5 + 1, B_8),
            case (D == (0 - 1)) of
        true -> R_2 = (R ++ "-"),
            R_6 = R_2;
        _ -> case (D == 0) of
        true -> R_3 = (R ++ "0"),
            R_5 = R_3;
        _ -> R_4 = (R ++ "+"),
            R_5 = R_4
    end,
            R_6 = R_5
    end,
            I_6 = (I_5 - 1),
            Fun_3_loop(B_8, I_6, R_6);
        _ -> {B_8, I_5, R}
    end
end,
{B_8, I_6, R_6} = Fun_3(B_8, I_5, R),
        R_6
    catch {return, Ret} -> Ret end.

btint(I_7) ->
    try
        case (I_7 == 0) of
        true -> throw({return, []});
        _ -> ok
    end,
        N = I_7,
        B_9 = [],
        Fun_4 = fun Fun_4_loop(B_9, I_7, N) ->
    case (N /= 0) of
        true ->
            M = (N rem 3),
            N_2 = mochi_to_int((N div 3)),
            case (M == 2) of
        true -> M_2 = (0 - 1),
            N_3 = (N_2 + 1),
            M_5 = M_2,
            N_6 = N_3;
        _ -> case (M == (0 - 2)) of
        true -> M_3 = 1,
            N_4 = (N_2 - 1),
            M_4 = M_3,
            N_5 = N_4;
        _ -> M_4 = M,
            N_5 = N_2
    end,
            M_5 = M_4,
            N_6 = N_5
    end,
            B_10 = lists:append(B_9, [M_5]),
            Fun_4_loop(B_10, I_7, N_6);
        _ -> {B_9, I_7, N}
    end
end,
{B_10, I_7, N_6} = Fun_4(B_9, I_7, N),
        B_10
    catch {return, Ret} -> Ret end.

bttoint(B_11) ->
    try
        R_7 = 0,
        Pt = 1,
        I_8 = 0,
        Fun_5 = fun Fun_5_loop(B_11, I_8, Pt, R_7) ->
    case (I_8 < length(B_11)) of
        true ->
            R_8 = (R_7 + (lists:nth(I_8 + 1, B_11) * Pt)),
            Pt_2 = (Pt * 3),
            I_9 = (I_8 + 1),
            Fun_5_loop(B_11, I_9, Pt_2, R_8);
        _ -> {B_11, I_8, Pt, R_7}
    end
end,
{B_11, I_9, Pt_2, R_8} = Fun_5(B_11, I_8, Pt, R_7),
        R_8
    catch {return, Ret} -> Ret end.

btneg(B_12) ->
    try
        R_9 = [],
        I_10 = 0,
        Fun_6 = fun Fun_6_loop(B_12, I_10, R_9) ->
    case (I_10 < length(B_12)) of
        true ->
            R_10 = lists:append(R_9, [-lists:nth(I_10 + 1, B_12)]),
            I_11 = (I_10 + 1),
            Fun_6_loop(B_12, I_11, R_10);
        _ -> {B_12, I_10, R_9}
    end
end,
{B_12, I_11, R_10} = Fun_6(B_12, I_10, R_9),
        R_10
    catch {return, Ret} -> Ret end.

btadd(A, B_13) ->
    try
        btint((bttoint(A) + bttoint(B_13)))
    catch {return, Ret} -> Ret end.

btmul(A_2, B_14) ->
    try
        btint((bttoint(A_2) * bttoint(B_14)))
    catch {return, Ret} -> Ret end.

padleft(S_4, W) ->
    try
        R_11 = S_4,
        Fun_7 = fun Fun_7_loop(R_11, S_4, W) ->
    case (length(R_11) < W) of
        true ->
            R_12 = (" " ++ R_11),
            Fun_7_loop(R_12, S_4, W);
        _ -> {R_11, S_4, W}
    end
end,
{R_12, S_4, W} = Fun_7(R_11, S_4, W),
        R_12
    catch {return, Ret} -> Ret end.

show(Label, B_15) ->
    try
        L = padleft(Label, 7),
        Bs = padleft(bttostring(B_15), 12),
        Is = padleft(lists:flatten(io_lib:format("~p", [bttoint(B_15)])), 7),
        io:format("~ts~n", [((((L ++ " ") ++ Bs) ++ " ") ++ Is)]),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Ares = btstring("+-0++0+"),
        A_3 = maps:get("bt", Ares, nil),
        B_16 = btint(-436),
        Cres = btstring("+-++-"),
        C = maps:get("bt", Cres, nil),
        show("a:", A_3),
        show("b:", B_16),
        show("c:", C),
        show("a(b-c):", btmul(A_3, btadd(B_16, btneg(C)))),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
