#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pow2/1, lshift/2, rshift/2, newwriter/1, writebitslsb/3, writebitsmsb/3, writebits/3, closewriter/1, newreader/2, readbitslsb/2, readbitsmsb/2, readbits/2, tobinary/2, bytestobits/1, bytestohex/1, ord/1, chr/1, bytesofstr/1, bytestodec/1, example/0]).

% Generated by Mochi transpiler v0.10.40 (e0c44791e6) on 2025-07-25 18:01 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.


mochi_parse_int_str(S) ->
    try list_to_integer(S) catch _:_ -> 0 end.

pow2(N) ->
    try
        V = 1,
        I = 0,
        Fun = fun Fun_loop(I, N, V) ->
    case (I < N) of
        true ->
            V_2 = (V * 2),
            I_2 = (I + 1),
            Fun_loop(I_2, N, V_2);
        _ -> {I, N, V}
    end
end,
{I_2, N, V_2} = Fun(I, N, V),
        V_2
    catch {return, Ret} -> Ret end.

lshift(X, N_2) ->
    try
        (X * pow2(N_2))
    catch {return, Ret} -> Ret end.

rshift(X_2, N_3) ->
    try
        (X_2 div pow2(N_3))
    catch {return, Ret} -> Ret end.

newwriter(Order) ->
    try
        #{"order" => Order, "bits" => 0, "nbits" => 0, "data" => []}
    catch {return, Ret} -> Ret end.

writebitslsb(W, C, Width) ->
    try
        W_2 = maps:put("bits", (maps:get("bits", W, nil) + lshift(C, maps:get("nbits", W, nil))), W),
        W_3 = maps:put("nbits", (maps:get("nbits", W_2, nil) + Width), W_2),
        Fun_2 = fun Fun_2_loop(C, W_3, Width) ->
    case (maps:get("nbits", W_3, nil) >= 8) of
        true ->
            B = (maps:get("bits", W_3, nil) rem 256),
            W_4 = maps:put("data", lists:append(maps:get("data", W_3, nil), [B]), W_3),
            W_5 = maps:put("bits", rshift(maps:get("bits", W_4, nil), 8), W_4),
            W_6 = maps:put("nbits", (maps:get("nbits", W_5, nil) - 8), W_5),
            Fun_2_loop(C, W_6, Width);
        _ -> {C, W_3, Width}
    end
end,
{C, W_6, Width} = Fun_2(C, W_3, Width),
        W_6
    catch {return, Ret} -> Ret end.

writebitsmsb(W_7, C_2, Width_2) ->
    try
        W_8 = maps:put("bits", (maps:get("bits", W_7, nil) + lshift(C_2, ((32 - Width_2) - maps:get("nbits", W_7, nil)))), W_7),
        W_9 = maps:put("nbits", (maps:get("nbits", W_8, nil) + Width_2), W_8),
        Fun_3 = fun Fun_3_loop(C_2, W_9, Width_2) ->
    case (maps:get("nbits", W_9, nil) >= 8) of
        true ->
            B_2 = (rshift(maps:get("bits", W_9, nil), 24) rem 256),
            W_10 = maps:put("data", lists:append(maps:get("data", W_9, nil), [B_2]), W_9),
            W_11 = maps:put("bits", ((maps:get("bits", W_10, nil) rem pow2(24)) * 256), W_10),
            W_12 = maps:put("nbits", (maps:get("nbits", W_11, nil) - 8), W_11),
            Fun_3_loop(C_2, W_12, Width_2);
        _ -> {C_2, W_9, Width_2}
    end
end,
{C_2, W_12, Width_2} = Fun_3(C_2, W_9, Width_2),
        W_12
    catch {return, Ret} -> Ret end.

writebits(W_13, C_3, Width_3) ->
    try
        (case (maps:get("order", W_13, nil) == "LSB") of
    true -> writebitslsb(W_13, C_3, Width_3);
    _ -> writebitsmsb(W_13, C_3, Width_3)
end)
    catch {return, Ret} -> Ret end.

closewriter(W_14) ->
    try
        case (maps:get("nbits", W_14, nil) > 0) of
        true -> case (maps:get("order", W_14, nil) == "MSB") of
        true -> W_15 = maps:put("bits", rshift(maps:get("bits", W_14, nil), 24), W_14),
            W_16 = W_15;
        _ -> W_16 = W_14
    end,
            W_17 = maps:put("data", lists:append(maps:get("data", W_16, nil), [(maps:get("bits", W_16, nil) rem 256)]), W_16),
            W_18 = W_17;
        _ -> W_18 = W_14
    end,
        W_19 = maps:put("bits", 0, W_18),
        W_20 = maps:put("nbits", 0, W_19),
        W_20
    catch {return, Ret} -> Ret end.

newreader(Data, Order_2) ->
    try
        #{"order" => Order_2, "data" => Data, "idx" => 0, "bits" => 0, "nbits" => 0}
    catch {return, Ret} -> Ret end.

readbitslsb(R, Width_4) ->
    try
        Fun_4 = fun Fun_4_loop(R, Width_4) ->
    case (maps:get("nbits", R, nil) < Width_4) of
        true ->
            case (maps:get("idx", R, nil) >= length(maps:get("data", R, nil))) of
        true -> throw({return, #{"val" => 0, "eof" => true}});
        _ -> ok
    end,
            B_3 = lists:nth(maps:get("idx", R, nil) + 1, maps:get("data", R, nil)),
            R_2 = maps:put("idx", (maps:get("idx", R, nil) + 1), R),
            R_3 = maps:put("bits", (maps:get("bits", R_2, nil) + lshift(B_3, maps:get("nbits", R_2, nil))), R_2),
            R_4 = maps:put("nbits", (maps:get("nbits", R_3, nil) + 8), R_3),
            Fun_4_loop(R_4, Width_4);
        _ -> {R, Width_4}
    end
end,
{R_4, Width_4} = Fun_4(R, Width_4),
        Mask = (pow2(Width_4) - 1),
        Out = (maps:get("bits", R_4, nil) rem (Mask + 1)),
        R_5 = maps:put("bits", rshift(maps:get("bits", R_4, nil), Width_4), R_4),
        R_6 = maps:put("nbits", (maps:get("nbits", R_5, nil) - Width_4), R_5),
        #{"val" => Out, "eof" => false}
    catch {return, Ret} -> Ret end.

readbitsmsb(R_7, Width_5) ->
    try
        Fun_5 = fun Fun_5_loop(R_7, Width_5) ->
    case (maps:get("nbits", R_7, nil) < Width_5) of
        true ->
            case (maps:get("idx", R_7, nil) >= length(maps:get("data", R_7, nil))) of
        true -> throw({return, #{"val" => 0, "eof" => true}});
        _ -> ok
    end,
            B_4 = lists:nth(maps:get("idx", R_7, nil) + 1, maps:get("data", R_7, nil)),
            R_8 = maps:put("idx", (maps:get("idx", R_7, nil) + 1), R_7),
            R_9 = maps:put("bits", (maps:get("bits", R_8, nil) + lshift(B_4, (24 - maps:get("nbits", R_8, nil)))), R_8),
            R_10 = maps:put("nbits", (maps:get("nbits", R_9, nil) + 8), R_9),
            Fun_5_loop(R_10, Width_5);
        _ -> {R_7, Width_5}
    end
end,
{R_10, Width_5} = Fun_5(R_7, Width_5),
        Out_2 = rshift(maps:get("bits", R_10, nil), (32 - Width_5)),
        R_11 = maps:put("bits", ((maps:get("bits", R_10, nil) * pow2(Width_5)) rem pow2(32)), R_10),
        R_12 = maps:put("nbits", (maps:get("nbits", R_11, nil) - Width_5), R_11),
        #{"val" => Out_2, "eof" => false}
    catch {return, Ret} -> Ret end.

readbits(R_13, Width_6) ->
    try
        (case (maps:get("order", R_13, nil) == "LSB") of
    true -> readbitslsb(R_13, Width_6);
    _ -> readbitsmsb(R_13, Width_6)
end)
    catch {return, Ret} -> Ret end.

tobinary(N_4, Bits) ->
    try
        B_5 = "",
        Val = N_4,
        I_3 = 0,
        Fun_6 = fun Fun_6_loop(B_5, Bits, I_3, N_4, Val) ->
    case (I_3 < Bits) of
        true ->
            B_6 = (lists:flatten(io_lib:format("~p", [(Val rem 2)])) ++ B_5),
            Val_2 = (Val div 2),
            I_4 = (I_3 + 1),
            Fun_6_loop(B_6, Bits, I_4, N_4, Val_2);
        _ -> {B_5, Bits, I_3, N_4, Val}
    end
end,
{B_6, Bits, I_4, N_4, Val_2} = Fun_6(B_5, Bits, I_3, N_4, Val),
        B_6
    catch {return, Ret} -> Ret end.

bytestobits(Bs) ->
    try
        Out_3 = "[",
        I_5 = 0,
        Fun_7 = fun Fun_7_loop(Bs, I_5, Out_3) ->
    case (I_5 < length(Bs)) of
        true ->
            Out_4 = (Out_3 ++ tobinary(lists:nth(I_5 + 1, Bs), 8)),
            case ((I_5 + 1) < length(Bs)) of
        true -> Out_5 = (Out_4 ++ " "),
            Out_6 = Out_5;
        _ -> Out_6 = Out_4
    end,
            I_6 = (I_5 + 1),
            Fun_7_loop(Bs, I_6, Out_6);
        _ -> {Bs, I_5, Out_3}
    end
end,
{Bs, I_6, Out_6} = Fun_7(Bs, I_5, Out_3),
        Out_7 = (Out_6 ++ "]"),
        Out_7
    catch {return, Ret} -> Ret end.

bytestohex(Bs_2) ->
    try
        Digits = "0123456789ABCDEF",
        Out_8 = "",
        I_7 = 0,
        Fun_8 = fun Fun_8_loop(Bs_2, Digits, I_7, Out_8) ->
    case (I_7 < length(Bs_2)) of
        true ->
            B_7 = lists:nth(I_7 + 1, Bs_2),
            Hi = (B_7 div 16),
            Lo = (B_7 rem 16),
            Out_9 = ((Out_8 ++ string:substr(Digits, Hi + 1, ((Hi + 1) - Hi))) ++ string:substr(Digits, Lo + 1, ((Lo + 1) - Lo))),
            case ((I_7 + 1) < length(Bs_2)) of
        true -> Out_10 = (Out_9 ++ " "),
            Out_11 = Out_10;
        _ -> Out_11 = Out_9
    end,
            I_8 = (I_7 + 1),
            Fun_8_loop(Bs_2, Digits, I_8, Out_11);
        _ -> {Bs_2, Digits, I_7, Out_8}
    end
end,
{Bs_2, Digits, I_8, Out_11} = Fun_8(Bs_2, Digits, I_7, Out_8),
        Out_11
    catch {return, Ret} -> Ret end.

ord(Ch) ->
    try
        Upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Lower = "abcdefghijklmnopqrstuvwxyz",
        Idx = mochi_index_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Ch),
        case (Idx >= 0) of
        true -> throw({return, (65 + Idx)});
        _ -> ok
    end,
        Idx_2 = mochi_index_of("abcdefghijklmnopqrstuvwxyz", Ch),
        case (Idx_2 >= 0) of
        true -> throw({return, (97 + Idx_2)});
        _ -> ok
    end,
        case ((Ch >= "0") andalso (Ch =< "9")) of
        true -> throw({return, (48 + mochi_parse_int_str(Ch))});
        _ -> ok
    end,
        case (Ch == " ") of
        true -> throw({return, 32});
        _ -> ok
    end,
        case (Ch == ".") of
        true -> throw({return, 46});
        _ -> ok
    end,
        0
    catch {return, Ret} -> Ret end.

chr(N_5) ->
    try
        Upper_2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Lower_2 = "abcdefghijklmnopqrstuvwxyz",
        case ((N_5 >= 65) andalso (N_5 < 91)) of
        true -> throw({return, string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", (N_5 - 65) + 1, ((N_5 - 64) - (N_5 - 65)))});
        _ -> ok
    end,
        case ((N_5 >= 97) andalso (N_5 < 123)) of
        true -> throw({return, string:substr("abcdefghijklmnopqrstuvwxyz", (N_5 - 97) + 1, ((N_5 - 96) - (N_5 - 97)))});
        _ -> ok
    end,
        case ((N_5 >= 48) andalso (N_5 < 58)) of
        true -> Digits_2 = "0123456789",
            throw({return, string:substr("0123456789", (N_5 - 48) + 1, ((N_5 - 47) - (N_5 - 48)))}),
            Digits_3 = Digits_2;
        _ -> Digits_3 = nil
    end,
        case (N_5 == 32) of
        true -> throw({return, " "});
        _ -> ok
    end,
        case (N_5 == 46) of
        true -> throw({return, "."});
        _ -> ok
    end,
        "?"
    catch {return, Ret} -> Ret end.

bytesofstr(S) ->
    try
        Bs_3 = [],
        I_9 = 0,
        Fun_9 = fun Fun_9_loop(Bs_3, I_9, S) ->
    case (I_9 < length(S)) of
        true ->
            Bs_4 = lists:append(Bs_3, [ord(string:substr(S, I_9 + 1, ((I_9 + 1) - I_9)))]),
            I_10 = (I_9 + 1),
            Fun_9_loop(Bs_4, I_10, S);
        _ -> {Bs_3, I_9, S}
    end
end,
{Bs_4, I_10, S} = Fun_9(Bs_3, I_9, S),
        Bs_4
    catch {return, Ret} -> Ret end.

bytestodec(Bs_5) ->
    try
        Out_12 = "",
        I_11 = 0,
        Fun_10 = fun Fun_10_loop(Bs_5, I_11, Out_12) ->
    case (I_11 < length(Bs_5)) of
        true ->
            Out_13 = (Out_12 ++ lists:flatten(io_lib:format("~p", [lists:nth(I_11 + 1, Bs_5)]))),
            case ((I_11 + 1) < length(Bs_5)) of
        true -> Out_14 = (Out_13 ++ " "),
            Out_15 = Out_14;
        _ -> Out_15 = Out_13
    end,
            I_12 = (I_11 + 1),
            Fun_10_loop(Bs_5, I_12, Out_15);
        _ -> {Bs_5, I_11, Out_12}
    end
end,
{Bs_5, I_12, Out_15} = Fun_10(Bs_5, I_11, Out_12),
        Out_15
    catch {return, Ret} -> Ret end.

example() ->
    try
        Message = "This is a test.",
        MsgBytes = bytesofstr("This is a test."),
        io:format("~ts~n", [((("\"" ++ "This is a test.") ++ "\" as bytes: ") ++ bytestodec(MsgBytes))]),
        io:format("~ts~n", [("    original bits: " ++ bytestobits(MsgBytes))]),
        Bw = newwriter("MSB"),
        I_13 = 0,
        Fun_11 = fun Fun_11_loop(Bw, I_13, Message, MsgBytes) ->
    case (I_13 < length(MsgBytes)) of
        true ->
            Bw_2 = writebits(Bw, lists:nth(I_13 + 1, MsgBytes), 7),
            I_14 = (I_13 + 1),
            Fun_11_loop(Bw_2, I_14, Message, MsgBytes);
        _ -> {Bw, I_13, Message, MsgBytes}
    end
end,
{Bw_2, I_14, Message, MsgBytes} = Fun_11(Bw, I_13, Message, MsgBytes),
        Bw_3 = closewriter(Bw_2),
        io:format("~ts~n", [("Written bitstream: " ++ bytestobits(maps:get("data", Bw_3, nil)))]),
        io:format("~ts~n", [("Written bytes: " ++ bytestohex(maps:get("data", Bw_3, nil)))]),
        Br = newreader(maps:get("data", Bw_3, nil), "MSB"),
        Result = "",
        Fun_12 = fun Fun_12_loop(Br, Bw_3, I_14, Message, MsgBytes, Result) ->
    case true of
        true ->
            try
                R_14 = readbits(Br, 7),
                case maps:get("eof", R_14, nil) of
        true -> throw(break);
        _ -> ok
    end,
                V_3 = mochi_to_int(maps:get("val", R_14, nil)),
                case (V_3 /= 0) of
        true -> Result_2 = (Result ++ chr(V_3)),
            Result_3 = Result_2;
        _ -> Result_3 = Result
    end,
                Fun_12_loop(Br, Bw_3, I_14, Message, MsgBytes, Result_3)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_12_loop(C0, C1, C2, C3, C4, C5);
                break -> {Br, Bw_3, I_14, Message, MsgBytes, Result}
            end;
        _ -> {Br, Bw_3, I_14, Message, MsgBytes, Result}
    end
end,
{Br, Bw_3, I_14, Message, MsgBytes, Result_3} = Fun_12(Br, Bw_3, I_14, Message, MsgBytes, Result),
        io:format("~ts~n", [(("Read back as \"" ++ Result_3) ++ "\"")]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    example(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
