#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, trim/1, split/2, splitws/1, indexof/2, parseintstr/1, parseasm/1, compile/1, floormod/2, run/1, execute/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (6aa59f472e) on 2025-08-02 17:26 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.


mochi_parse_int_str(S) ->
    try list_to_integer(S) catch _:_ -> 0 end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

trim(S) ->
    try
        Start = 0,
        Fun = fun Fun_loop(S, Start) ->
    case ((Start < length(S)) andalso ((string:substr(S, Start + 1, ((Start + 1) - Start)) == " ") orelse (string:substr(S, Start + 1, ((Start + 1) - Start)) == "\t"))) of
        true ->
            Start_2 = (Start + 1),
            Fun_loop(S, Start_2);
        _ -> {S, Start}
    end
end,
{S, Start_2} = Fun(S, Start),
        End = length(S),
        Fun_2 = fun Fun_2_loop(End, S, Start_2) ->
    case ((End > Start_2) andalso ((string:substr(S, (End - 1) + 1, (End - (End - 1))) == " ") orelse (string:substr(S, (End - 1) + 1, (End - (End - 1))) == "\t"))) of
        true ->
            End_2 = (End - 1),
            Fun_2_loop(End_2, S, Start_2);
        _ -> {End, S, Start_2}
    end
end,
{End_2, S, Start_2} = Fun_2(End, S, Start_2),
        string:substr(S, Start_2 + 1, (End_2 - Start_2))
    catch {return, Ret} -> Ret end.

split(S_2, Sep) ->
    try
        Parts = [],
        Cur = "",
        I = 0,
        Fun_3 = fun Fun_3_loop(Cur, I, Parts, S_2, Sep) ->
    case (I < length(S_2)) of
        true ->
            case (((length(Sep) > 0) andalso ((I + length(Sep)) =< length(S_2))) andalso (string:substr(S_2, I + 1, ((I + length(Sep)) - I)) == Sep)) of
        true -> Parts_2 = lists:append(Parts, [Cur]),
            Cur_2 = "",
            I_2 = (I + length(Sep)),
            Cur_4 = Cur_2,
            I_4 = I_2,
            Parts_3 = Parts_2;
        _ -> Cur_3 = (Cur ++ string:substr(S_2, I + 1, ((I + 1) - I))),
            I_3 = (I + 1),
            Cur_4 = Cur_3,
            I_4 = I_3,
            Parts_3 = Parts
    end,
            Fun_3_loop(Cur_4, I_4, Parts_3, S_2, Sep);
        _ -> {Cur, I, Parts, S_2, Sep}
    end
end,
{Cur_4, I_4, Parts_3, S_2, Sep} = Fun_3(Cur, I, Parts, S_2, Sep),
        Parts_4 = lists:append(Parts_3, [Cur_4]),
        Parts_4
    catch {return, Ret} -> Ret end.

splitws(S_3) ->
    try
        Out = [],
        Cur_5 = "",
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(Cur_5, I_5, Out, S_3) ->
    case (I_5 < length(S_3)) of
        true ->
            Ch = string:substr(S_3, I_5 + 1, ((I_5 + 1) - I_5)),
            case ((Ch == " ") orelse (Ch == "\t")) of
        true -> case (length(Cur_5) > 0) of
        true -> Out_2 = lists:append(Out, [Cur_5]),
            Cur_6 = "",
            Cur_7 = Cur_6,
            Out_3 = Out_2;
        _ -> Cur_7 = Cur_5,
            Out_3 = Out
    end,
            Cur_9 = Cur_7,
            Out_4 = Out_3;
        _ -> Cur_8 = (Cur_5 ++ Ch),
            Cur_9 = Cur_8,
            Out_4 = Out
    end,
            I_6 = (I_5 + 1),
            Fun_4_loop(Cur_9, I_6, Out_4, S_3);
        _ -> {Cur_5, I_5, Out, S_3}
    end
end,
{Cur_9, I_6, Out_4, S_3} = Fun_4(Cur_5, I_5, Out, S_3),
        case (length(Cur_9) > 0) of
        true -> Out_5 = lists:append(Out_4, [Cur_9]),
            Out_6 = Out_5;
        _ -> Out_6 = Out_4
    end,
        Out_6
    catch {return, Ret} -> Ret end.

indexof(S_4, Ch_2) ->
    try
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(Ch_2, I_7, S_4) ->
    case (I_7 < length(S_4)) of
        true ->
            case (string:substr(S_4, I_7 + 1, ((I_7 + 1) - I_7)) == Ch_2) of
        true -> throw({return, I_7});
        _ -> ok
    end,
            I_8 = (I_7 + 1),
            Fun_5_loop(Ch_2, I_8, S_4);
        _ -> {Ch_2, I_7, S_4}
    end
end,
{Ch_2, I_8, S_4} = Fun_5(Ch_2, I_7, S_4),
        -1
    catch {return, Ret} -> Ret end.

parseintstr(Str) ->
    try
        I_9 = 0,
        Neg = false,
        case ((length(Str) > 0) andalso (string:substr(Str, 0 + 1, (1 - 0)) == "-")) of
        true -> Neg_2 = true,
            I_10 = 1,
            I_11 = I_10,
            Neg_3 = Neg_2;
        _ -> I_11 = I_9,
            Neg_3 = Neg
    end,
        N = 0,
        Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
        Fun_6 = fun Fun_6_loop(Digits, I_11, N, Neg_3, Str) ->
    case (I_11 < length(Str)) of
        true ->
            N_2 = ((N * 10) + maps:get(string:substr(Str, I_11 + 1, ((I_11 + 1) - I_11)), Digits, nil)),
            I_12 = (I_11 + 1),
            Fun_6_loop(Digits, I_12, N_2, Neg_3, Str);
        _ -> {Digits, I_11, N, Neg_3, Str}
    end
end,
{Digits, I_12, N_2, Neg_3, Str} = Fun_6(Digits, I_11, N, Neg_3, Str),
        case Neg_3 of
        true -> N_3 = -N_2,
            N_4 = N_3;
        _ -> N_4 = N_2
    end,
        N_4
    catch {return, Ret} -> Ret end.

parseasm(Asm) ->
    try
        Lines = string:tokens(Asm, "\n"),
        Instrs = [],
        Labels = #{},
        LineNum = 0,
        I_13 = 0,
        Fun_7 = fun Fun_7_loop(Asm, I_13, Instrs, Labels, LineNum, Lines) ->
    case (I_13 < length(Lines)) of
        true ->
            Line = string:substr(Lines, I_13 + 1, 1),
            case (mochi_index_of(Line, ";") /= -1) of
        true -> Line_2 = string:substr(Line, 0 + 1, (mochi_index_of(Line, ";") - 0)),
            Line_3 = Line_2;
        _ -> Line_3 = Line
    end,
            Line_4 = trim(Line_3),
            Label = "",
            case (mochi_index_of(Line_4, ":") /= -1) of
        true -> Idx = mochi_index_of(Line_4, ":"),
            Label_2 = trim(string:substr(Line_4, 0 + 1, (Idx - 0))),
            Line_5 = trim(string:substr(Line_4, (Idx + 1) + 1, (length(Line_4) - (Idx + 1)))),
            Idx_2 = Idx,
            Label_3 = Label_2,
            Line_6 = Line_5;
        _ -> Idx_2 = nil,
            Label_3 = Label,
            Line_6 = Line_4
    end,
            Opcode = "",
            Arg = "",
            case (length(Line_6) > 0) of
        true -> Parts_5 = splitws(Line_6),
            case (length(Parts_5) > 0) of
        true -> Opcode_2 = (case erlang:is_map(Parts_5) of true -> maps:get(0, Parts_5, nil); _ -> lists:nth(0 + 1, Parts_5) end),
            Opcode_3 = Opcode_2;
        _ -> Opcode_3 = Opcode
    end,
            case (length(Parts_5) > 1) of
        true -> Arg_2 = (case erlang:is_map(Parts_5) of true -> maps:get(1, Parts_5, nil); _ -> lists:nth(1 + 1, Parts_5) end),
            Arg_5 = Arg_2,
            Opcode_6 = Opcode_3,
            Ops_2 = nil;
        _ -> Ops = #{"NOP" => 0, "LDA" => 1, "STA" => 2, "ADD" => 3, "SUB" => 4, "BRZ" => 5, "JMP" => 6, "STP" => 7},
            case mochi_not(maps:is_key(Opcode_3, Ops)) of
        true -> Arg_3 = Opcode_3,
            Opcode_4 = "",
            Arg_4 = Arg_3,
            Opcode_5 = Opcode_4;
        _ -> Arg_4 = Arg,
            Opcode_5 = Opcode_3
    end,
            Arg_5 = Arg_4,
            Opcode_6 = Opcode_5,
            Ops_2 = Ops
    end,
            Arg_6 = Arg_5,
            Opcode_7 = Opcode_6,
            Ops_3 = Ops_2,
            Parts_6 = Parts_5;
        _ -> Arg_6 = Arg,
            Opcode_7 = Opcode,
            Ops_3 = nil,
            Parts_6 = nil
    end,
            case (Label_3 /= "") of
        true -> Labels_2 = maps:put(Label_3, LineNum, Labels),
            Labels_3 = Labels_2;
        _ -> Labels_3 = Labels
    end,
            Instrs_2 = lists:append(Instrs, [#{"Label" => Label_3, "Opcode" => Opcode_7, "Arg" => Arg_6}]),
            LineNum_2 = (LineNum + 1),
            I_14 = (I_13 + 1),
            Fun_7_loop(Asm, I_14, Instrs_2, Labels_3, LineNum_2, Lines);
        _ -> {Asm, I_13, Instrs, Labels, LineNum, Lines}
    end
end,
{Asm, I_14, Instrs_2, Labels_3, LineNum_2, Lines} = Fun_7(Asm, I_13, Instrs, Labels, LineNum, Lines),
        #{"instructions" => Instrs_2, "labels" => Labels_3}
    catch {return, Ret} -> Ret end.

compile(P) ->
    try
        Instrs_3 = maps:get("instructions", P, nil),
        Labels_4 = maps:get("labels", P, nil),
        Bytecode = [],
        I_15 = 0,
        Opcodes = #{"NOP" => 0, "LDA" => 1, "STA" => 2, "ADD" => 3, "SUB" => 4, "BRZ" => 5, "JMP" => 6, "STP" => 7},
        Fun_8 = fun Fun_8_loop(Bytecode, I_15, Instrs_3, Labels_4, Opcodes, P) ->
    case (I_15 < length(Instrs_3)) of
        true ->
            Ins = (case erlang:is_map(Instrs_3) of true -> maps:get(I_15, Instrs_3, nil); _ -> lists:nth(I_15 + 1, Instrs_3) end),
            Arg_7 = 0,
            case (maps:get("Arg", Ins, nil) /= "") of
        true -> case maps:is_key(maps:get("Arg", Ins, nil), Labels_4) of
        true -> Arg_8 = maps:get(maps:get("Arg", Ins, nil), Labels_4, nil),
            Arg_10 = Arg_8;
        _ -> Arg_9 = mochi_parse_int_str(maps:get("Arg", Ins, nil)),
            Arg_10 = Arg_9
    end,
            Arg_11 = Arg_10;
        _ -> Arg_11 = Arg_7
    end,
            Code = 0,
            case (maps:get("Opcode", Ins, nil) /= "") of
        true -> Code_2 = maps:get(maps:get("Opcode", Ins, nil), Opcodes, nil),
            Code_3 = Code_2;
        _ -> Code_3 = Code
    end,
            Bytecode_2 = lists:append(Bytecode, [((Code_3 * 32) + Arg_11)]),
            I_16 = (I_15 + 1),
            Fun_8_loop(Bytecode_2, I_16, Instrs_3, Labels_4, Opcodes, P);
        _ -> {Bytecode, I_15, Instrs_3, Labels_4, Opcodes, P}
    end
end,
{Bytecode_2, I_16, Instrs_3, Labels_4, Opcodes, P} = Fun_8(Bytecode, I_15, Instrs_3, Labels_4, Opcodes, P),
        Fun_9 = fun Fun_9_loop(Bytecode_2, I_16, Instrs_3, Labels_4, Opcodes, P) ->
    case (length(Bytecode_2) < 32) of
        true ->
            Bytecode_3 = lists:append(Bytecode_2, [0]),
            Fun_9_loop(Bytecode_3, I_16, Instrs_3, Labels_4, Opcodes, P);
        _ -> {Bytecode_2, I_16, Instrs_3, Labels_4, Opcodes, P}
    end
end,
{Bytecode_3, I_16, Instrs_3, Labels_4, Opcodes, P} = Fun_9(Bytecode_2, I_16, Instrs_3, Labels_4, Opcodes, P),
        Bytecode_3
    catch {return, Ret} -> Ret end.

floormod(A, B) ->
    try
        R = (A rem B),
        case (R < 0) of
        true -> R_2 = (R + B),
            R_3 = R_2;
        _ -> R_3 = R
    end,
        R_3
    catch {return, Ret} -> Ret end.

run(Bytecode_4) ->
    try
        Acc = 0,
        Pc = 0,
        Mem = [],
        I_17 = 0,
        Fun_10 = fun Fun_10_loop(Acc, Bytecode_4, I_17, Mem, Pc) ->
    case (I_17 < length(Bytecode_4)) of
        true ->
            Mem_2 = lists:append(Mem, [(case erlang:is_map(Bytecode_4) of true -> maps:get(I_17, Bytecode_4, nil); _ -> lists:nth(I_17 + 1, Bytecode_4) end)]),
            I_18 = (I_17 + 1),
            Fun_10_loop(Acc, Bytecode_4, I_18, Mem_2, Pc);
        _ -> {Acc, Bytecode_4, I_17, Mem, Pc}
    end
end,
{Acc, Bytecode_4, I_18, Mem_2, Pc} = Fun_10(Acc, Bytecode_4, I_17, Mem, Pc),
        Fun_11 = fun Fun_11_loop(Acc, Bytecode_4, I_18, Mem_2, Pc) ->
    case (Pc < 32) of
        true ->
            try
                Op = ((case erlang:is_map(Mem_2) of true -> maps:get(Pc, Mem_2, nil); _ -> lists:nth(Pc + 1, Mem_2) end) div 32),
                Arg_12 = ((case erlang:is_map(Mem_2) of true -> maps:get(Pc, Mem_2, nil); _ -> lists:nth(Pc + 1, Mem_2) end) rem 32),
                Pc_2 = (Pc + 1),
                case (Op == 0) of
        true -> throw({continue, Acc, Bytecode_4, I_18, Mem_2, Pc_2}),
            Acc_9 = Acc,
            Mem_6 = Mem_2,
            Pc_12 = Pc_2;
        _ -> case (Op == 1) of
        true -> Acc_2 = (case erlang:is_map(Mem_2) of true -> maps:get(Arg_12, Mem_2, nil); _ -> lists:nth(Arg_12 + 1, Mem_2) end),
            Acc_8 = Acc_2,
            Mem_5 = Mem_2,
            Pc_11 = Pc_2;
        _ -> case (Op == 2) of
        true -> Mem_3 = lists:sublist(Mem_2, Arg_12) ++ [Acc] ++ lists:nthtail(Arg_12 + 1, Mem_2),
            Acc_7 = Acc,
            Mem_4 = Mem_3,
            Pc_10 = Pc_2;
        _ -> case (Op == 3) of
        true -> Acc_3 = floormod((Acc + (case erlang:is_map(Mem_2) of true -> maps:get(Arg_12, Mem_2, nil); _ -> lists:nth(Arg_12 + 1, Mem_2) end)), 256),
            Acc_6 = Acc_3,
            Pc_9 = Pc_2;
        _ -> case (Op == 4) of
        true -> Acc_4 = floormod((Acc - (case erlang:is_map(Mem_2) of true -> maps:get(Arg_12, Mem_2, nil); _ -> lists:nth(Arg_12 + 1, Mem_2) end)), 256),
            Acc_5 = Acc_4,
            Pc_8 = Pc_2;
        _ -> case (Op == 5) of
        true -> case (Acc == 0) of
        true -> Pc_3 = Arg_12,
            Pc_4 = Pc_3;
        _ -> Pc_4 = Pc_2
    end,
            Pc_7 = Pc_4;
        _ -> case (Op == 6) of
        true -> Pc_5 = Arg_12,
            Pc_6 = Pc_5;
        _ -> case (Op == 7) of
        true -> throw(break);
        _ -> throw(break)
    end,
            Pc_6 = Pc_2
    end,
            Pc_7 = Pc_6
    end,
            Acc_5 = Acc,
            Pc_8 = Pc_7
    end,
            Acc_6 = Acc_5,
            Pc_9 = Pc_8
    end,
            Acc_7 = Acc_6,
            Mem_4 = Mem_2,
            Pc_10 = Pc_9
    end,
            Acc_8 = Acc_7,
            Mem_5 = Mem_4,
            Pc_11 = Pc_10
    end,
            Acc_9 = Acc_8,
            Mem_6 = Mem_5,
            Pc_12 = Pc_11
    end,
                Fun_11_loop(Acc_9, Bytecode_4, I_18, Mem_6, Pc_12)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_11_loop(C0, C1, C2, C3, C4);
                break -> {Acc, Bytecode_4, I_18, Mem_2, Pc}
            end;
        _ -> {Acc, Bytecode_4, I_18, Mem_2, Pc}
    end
end,
{Acc_9, Bytecode_4, I_18, Mem_6, Pc_12} = Fun_11(Acc, Bytecode_4, I_18, Mem_2, Pc),
        Acc_9
    catch {return, Ret} -> Ret end.

execute(Asm_2) ->
    try
        Parsed = parseasm(Asm_2),
        Bc = compile(Parsed),
        run(Bc)
    catch {return, Ret} -> Ret end.

main() ->
    try
        Examples = [(((("LDA   x\n" ++ "ADD   y       ; accumulator = x + y\n") ++ "STP\n") ++ "x:            2\n") ++ "y:            2"), ((((((((((((("loop:   LDA   prodt\n" ++ "        ADD   x\n") ++ "        STA   prodt\n") ++ "        LDA   y\n") ++ "        SUB   one\n") ++ "        STA   y\n") ++ "        BRZ   done\n") ++ "        JMP   loop\n") ++ "done:   LDA   prodt   ; to display it\n") ++ "        STP\n") ++ "x:            8\n") ++ "y:            7\n") ++ "prodt:        0\n") ++ "one:          1"), ((((((((((((((((("loop:   LDA   n\n" ++ "        STA   temp\n") ++ "        ADD   m\n") ++ "        STA   n\n") ++ "        LDA   temp\n") ++ "        STA   m\n") ++ "        LDA   count\n") ++ "        SUB   one\n") ++ "        BRZ   done\n") ++ "        STA   count\n") ++ "        JMP   loop\n") ++ "done:   LDA   n       ; to display it\n") ++ "        STP\n") ++ "m:            1\n") ++ "n:            1\n") ++ "temp:         0\n") ++ "count:        8       ; valid range: 1-11\n") ++ "one:          1"), ((((((((((((((((((((((((((((((("start:  LDA   load\n" ++ "ADD   car     ; head of list\n") ++ "STA   ldcar\n") ++ "ADD   one\n") ++ "STA   ldcdr   ; next CONS cell\n") ++ "ldcar:  NOP\n") ++ "STA   value\n") ++ "ldcdr:  NOP\n") ++ "BRZ   done    ; 0 stands for NIL\n") ++ "STA   car\n") ++ "JMP   start\n") ++ "done:   LDA   value   ; CAR of last CONS\n") ++ "STP\n") ++ "load:   LDA   0\n") ++ "value:        0\n") ++ "car:          28\n") ++ "one:          1\n") ++ "                        ; order of CONS cells\n") ++ "                        ; in memory\n") ++ "                        ; does not matter\n") ++ "        6\n") ++ "        0       ; 0 stands for NIL\n") ++ "        2       ; (CADR ls)\n") ++ "        26      ; (CDDR ls) -- etc.\n") ++ "        5\n") ++ "        20\n") ++ "        3\n") ++ "        30\n") ++ "        1       ; value of (CAR ls)\n") ++ "        22      ; points to (CDR ls)\n") ++ "        4\n") ++ "        24"), (((("LDA  3\n" ++ "SUB  4\n") ++ "STP  0\n") ++ "         0\n") ++ "         255"), (((("LDA  3\n" ++ "SUB  4\n") ++ "STP  0\n") ++ "                0\n") ++ "                1"), (((("LDA  3\n" ++ "ADD  4\n") ++ "STP  0\n") ++ "                1\n") ++ "                255")],
        I_19 = 0,
        Fun_12 = fun Fun_12_loop(Examples, I_19) ->
    case (I_19 < length(Examples)) of
        true ->
            Res = execute((case erlang:is_map(Examples) of true -> maps:get(I_19, Examples, nil); _ -> lists:nth(I_19 + 1, Examples) end)),
            io:format("~ts~n", [lists:flatten(io_lib:format("~p", [Res]))]),
            I_20 = (I_19 + 1),
            Fun_12_loop(Examples, I_20);
        _ -> {Examples, I_19}
    end
end,
{Examples, I_20} = Fun_12(Examples, I_19),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
