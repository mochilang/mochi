#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, shufflestr/1, createpolybius/0, createkey/1, orderkey/1, encrypt/3, indexof/2, decrypt/3, main/0]).

% Generated by Mochi transpiler v0.10.55 (dcb808b613) on 2025-08-02 23:47 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] when is_list(C) -> hd(C);
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.

shufflestr(S) ->
    try
        Arr = [],
        I = 0,
        Fun = fun Fun_loop(Arr, I, S) ->
    case (I < length(S)) of
        true ->
            Arr_2 = lists:append(Arr, [string:substr(S, I + 1, ((I + 1) - I))]),
            I_2 = (I + 1),
            Fun_loop(Arr_2, I_2, S);
        _ -> {Arr, I, S}
    end
end,
{Arr_2, I_2, S} = Fun(Arr, I, S),
        J = (length(Arr_2) - 1),
        Fun_2 = fun Fun_2_loop(Arr_2, I_2, J, S) ->
    case (J > 0) of
        true ->
            K = (mochi_now() rem (J + 1)),
            Tmp = (case erlang:is_map(Arr_2) of true -> maps:get(J, Arr_2, nil); _ -> lists:nth(J + 1, Arr_2) end),
            Arr_3 = lists:sublist(Arr_2, J) ++ [(case erlang:is_map(Arr_2) of true -> maps:get(K, Arr_2, nil); _ -> lists:nth(K + 1, Arr_2) end)] ++ lists:nthtail(J + 1, Arr_2),
            Arr_4 = lists:sublist(Arr_3, K) ++ [Tmp] ++ lists:nthtail(K + 1, Arr_3),
            J_2 = (J - 1),
            Fun_2_loop(Arr_4, I_2, J_2, S);
        _ -> {Arr_2, I_2, J, S}
    end
end,
{Arr_4, I_2, J_2, S} = Fun_2(Arr_2, I_2, J, S),
        Out = "",
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Arr_4, I_3, J_2, Out, S) ->
    case (I_3 < length(Arr_4)) of
        true ->
            Out_2 = (Out ++ (case erlang:is_map(Arr_4) of true -> maps:get(I_3, Arr_4, nil); _ -> lists:nth(I_3 + 1, Arr_4) end)),
            I_4 = (I_3 + 1),
            Fun_3_loop(Arr_4, I_4, J_2, Out_2, S);
        _ -> {Arr_4, I_3, J_2, Out, S}
    end
end,
{Arr_4, I_4, J_2, Out_2, S} = Fun_3(Arr_4, I_3, J_2, Out, S),
        Out_2
    catch {return, Ret} -> Ret end.

createpolybius() ->
    try
        Shuffled = shufflestr(erlang:get('alphabet')),
        Labels = [],
        Li = 0,
        Fun_4 = fun Fun_4_loop(Labels, Li, Shuffled) ->
    case (Li < length(erlang:get('adfgvx'))) of
        true ->
            Labels_2 = lists:append(Labels, [lists:sublist(erlang:get('adfgvx'), Li + 1, ((Li + 1) - Li))]),
            Li_2 = (Li + 1),
            Fun_4_loop(Labels_2, Li_2, Shuffled);
        _ -> {Labels, Li, Shuffled}
    end
end,
{Labels_2, Li_2, Shuffled} = Fun_4(Labels, Li, Shuffled),
        io:format("~ts~n", ["6 x 6 Polybius square:\n"]),
        io:format("~ts~n", ["  | A D F G V X"]),
        io:format("~ts~n", ["---------------"]),
        P = [],
        I_5 = 0,
        Fun_6 = fun Fun_6_loop(I_5, Labels_2, Li_2, P, Shuffled) ->
    case (I_5 < 6) of
        true ->
            Row = string:substr(Shuffled, (I_5 * 6) + 1, (((I_5 + 1) * 6) - (I_5 * 6))),
            P_2 = lists:append(P, [Row]),
            Line = ((case erlang:is_map(Labels_2) of true -> maps:get(I_5, Labels_2, nil); _ -> lists:nth(I_5 + 1, Labels_2) end) ++ " | "),
            J_3 = 0,
            Fun_5 = fun Fun_5_loop(I_5, J_3, Labels_2, Li_2, Line, P_2, Row, Shuffled) ->
    case (J_3 < 6) of
        true ->
            Line_2 = ((Line ++ string:substr(Row, J_3 + 1, ((J_3 + 1) - J_3))) ++ " "),
            J_4 = (J_3 + 1),
            Fun_5_loop(I_5, J_4, Labels_2, Li_2, Line_2, P_2, Row, Shuffled);
        _ -> {I_5, J_3, Labels_2, Li_2, Line, P_2, Row, Shuffled}
    end
end,
{I_5, J_4, Labels_2, Li_2, Line_2, P_2, Row, Shuffled} = Fun_5(I_5, J_3, Labels_2, Li_2, Line, P_2, Row, Shuffled),
            io:format("~ts~n", [Line_2]),
            I_6 = (I_5 + 1),
            Fun_6_loop(I_6, Labels_2, Li_2, P_2, Shuffled);
        _ -> {I_5, Labels_2, Li_2, P, Shuffled}
    end
end,
{I_6, Labels_2, Li_2, P_2, Shuffled} = Fun_6(I_5, Labels_2, Li_2, P, Shuffled),
        P_2
    catch {return, Ret} -> Ret end.

createkey(N) ->
    try
        case ((N < 7) orelse (N > 12)) of
        true -> io:format("~ts~n", ["Key should be within 7 and 12 letters long."]);
        _ -> ok
    end,
        Pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
        Key = "",
        I_7 = 0,
        Fun_7 = fun Fun_7_loop(I_7, Key, N, Pool) ->
    case (I_7 < N) of
        true ->
            Idx = (mochi_now() rem length(Pool)),
            Key_2 = (Key ++ string:substr(Pool, Idx + 1, 1)),
            Pool_2 = (string:substr(Pool, 1, (Idx - 0)) ++ string:substr(Pool, (Idx + 1) + 1, (length(Pool) - (Idx + 1)))),
            I_8 = (I_7 + 1),
            Fun_7_loop(I_8, Key_2, N, Pool_2);
        _ -> {I_7, Key, N, Pool}
    end
end,
{I_8, Key_2, N, Pool_2} = Fun_7(I_7, Key, N, Pool),
        io:format("~ts~n", [("\nThe key is " ++ Key_2)]),
        Key_2
    catch {return, Ret} -> Ret end.

orderkey(Key_3) ->
    try
        Pairs = [],
        I_9 = 0,
        Fun_8 = fun Fun_8_loop(I_9, Key_3, Pairs) ->
    case (I_9 < length(Key_3)) of
        true ->
            Pairs_2 = lists:append(Pairs, [[string:substr(Key_3, I_9 + 1, ((I_9 + 1) - I_9)), I_9]]),
            I_10 = (I_9 + 1),
            Fun_8_loop(I_10, Key_3, Pairs_2);
        _ -> {I_9, Key_3, Pairs}
    end
end,
{I_10, Key_3, Pairs_2} = Fun_8(I_9, Key_3, Pairs),
        N_2 = length(Pairs_2),
        M = 0,
        Fun_10 = fun Fun_10_loop(I_10, Key_3, M, N_2, Pairs_2) ->
    case (M < N_2) of
        true ->
            J_5 = 0,
            Fun_9 = fun Fun_9_loop(I_10, J_5, Key_3, M, N_2, Pairs_2) ->
    case (J_5 < (N_2 - 1)) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(Pairs_2) of true -> maps:get(J_5, Pairs_2, nil); _ -> lists:nth(J_5 + 1, Pairs_2) end)) of true -> maps:get(0, (case erlang:is_map(Pairs_2) of true -> maps:get(J_5, Pairs_2, nil); _ -> lists:nth(J_5 + 1, Pairs_2) end), nil); _ -> lists:nth(0 + 1, (case erlang:is_map(Pairs_2) of true -> maps:get(J_5, Pairs_2, nil); _ -> lists:nth(J_5 + 1, Pairs_2) end)) end) > (case erlang:is_map((case erlang:is_map(Pairs_2) of true -> maps:get((J_5 + 1), Pairs_2, nil); _ -> lists:nth((J_5 + 1) + 1, Pairs_2) end)) of true -> maps:get(0, (case erlang:is_map(Pairs_2) of true -> maps:get((J_5 + 1), Pairs_2, nil); _ -> lists:nth((J_5 + 1) + 1, Pairs_2) end), nil); _ -> lists:nth(0 + 1, (case erlang:is_map(Pairs_2) of true -> maps:get((J_5 + 1), Pairs_2, nil); _ -> lists:nth((J_5 + 1) + 1, Pairs_2) end)) end)) of
        true -> Tmp_2 = (case erlang:is_map(Pairs_2) of true -> maps:get(J_5, Pairs_2, nil); _ -> lists:nth(J_5 + 1, Pairs_2) end),
            Pairs_3 = lists:sublist(Pairs_2, J_5) ++ [(case erlang:is_map(Pairs_2) of true -> maps:get((J_5 + 1), Pairs_2, nil); _ -> lists:nth((J_5 + 1) + 1, Pairs_2) end)] ++ lists:nthtail(J_5 + 1, Pairs_2),
            Pairs_4 = lists:sublist(Pairs_3, (J_5 + 1)) ++ [Tmp_2] ++ lists:nthtail((J_5 + 1) + 1, Pairs_3),
            Pairs_5 = Pairs_4,
            Tmp_3 = Tmp_2;
        _ -> Pairs_5 = Pairs_2,
            Tmp_3 = nil
    end,
            J_6 = (J_5 + 1),
            Fun_9_loop(I_10, J_6, Key_3, M, N_2, Pairs_5);
        _ -> {I_10, J_5, Key_3, M, N_2, Pairs_2}
    end
end,
{I_10, J_6, Key_3, M, N_2, Pairs_5} = Fun_9(I_10, J_5, Key_3, M, N_2, Pairs_2),
            M_2 = (M + 1),
            Fun_10_loop(I_10, Key_3, M_2, N_2, Pairs_5);
        _ -> {I_10, Key_3, M, N_2, Pairs_2}
    end
end,
{I_10, Key_3, M_2, N_2, Pairs_5} = Fun_10(I_10, Key_3, M, N_2, Pairs_2),
        Res = [],
        I_11 = 0,
        Fun_11 = fun Fun_11_loop(I_11, Key_3, M_2, N_2, Pairs_5, Res) ->
    case (I_11 < N_2) of
        true ->
            Res_2 = lists:append(Res, [mochi_to_int((case erlang:is_map((case erlang:is_map(Pairs_5) of true -> maps:get(I_11, Pairs_5, nil); _ -> lists:nth(I_11 + 1, Pairs_5) end)) of true -> maps:get(1, (case erlang:is_map(Pairs_5) of true -> maps:get(I_11, Pairs_5, nil); _ -> lists:nth(I_11 + 1, Pairs_5) end), nil); _ -> lists:nth(1 + 1, (case erlang:is_map(Pairs_5) of true -> maps:get(I_11, Pairs_5, nil); _ -> lists:nth(I_11 + 1, Pairs_5) end)) end))]),
            I_12 = (I_11 + 1),
            Fun_11_loop(I_12, Key_3, M_2, N_2, Pairs_5, Res_2);
        _ -> {I_11, Key_3, M_2, N_2, Pairs_5, Res}
    end
end,
{I_12, Key_3, M_2, N_2, Pairs_5, Res_2} = Fun_11(I_11, Key_3, M_2, N_2, Pairs_5, Res),
        Res_2
    catch {return, Ret} -> Ret end.

encrypt(Polybius, Key_4, PlainText) ->
    try
        Labels_3 = [],
        Li_3 = 0,
        Fun_12 = fun Fun_12_loop(Key_4, Labels_3, Li_3, PlainText, Polybius) ->
    case (Li_3 < length(erlang:get('adfgvx'))) of
        true ->
            Labels_4 = lists:append(Labels_3, [lists:sublist(erlang:get('adfgvx'), Li_3 + 1, ((Li_3 + 1) - Li_3))]),
            Li_4 = (Li_3 + 1),
            Fun_12_loop(Key_4, Labels_4, Li_4, PlainText, Polybius);
        _ -> {Key_4, Labels_3, Li_3, PlainText, Polybius}
    end
end,
{Key_4, Labels_4, Li_4, PlainText, Polybius} = Fun_12(Key_4, Labels_3, Li_3, PlainText, Polybius),
        Temp = "",
        I_13 = 0,
        Fun_15 = fun Fun_15_loop(I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, Temp) ->
    case (I_13 < length(PlainText)) of
        true ->
            R = 0,
            Fun_14 = fun Fun_14_loop(I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R, Temp) ->
    case (R < 6) of
        true ->
            C = 0,
            Fun_13 = fun Fun_13_loop(C, I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R, Temp) ->
    case (C < 6) of
        true ->
            case (string:substr((case erlang:is_map(Polybius) of true -> maps:get(R, Polybius, nil); _ -> lists:nth(R + 1, Polybius) end), C + 1, ((C + 1) - C)) == string:substr(PlainText, I_13 + 1, ((I_13 + 1) - I_13))) of
        true -> Temp_2 = ((Temp ++ lists:sublist(Labels_4, R + 1, ((R + 1) - R))) ++ lists:sublist(Labels_4, C + 1, ((C + 1) - C))),
            Temp_3 = Temp_2;
        _ -> Temp_3 = Temp
    end,
            C_2 = (C + 1),
            Fun_13_loop(C_2, I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R, Temp_3);
        _ -> {C, I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R, Temp}
    end
end,
{C_2, I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R, Temp_3} = Fun_13(C, I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R, Temp),
            R_2 = (R + 1),
            Fun_14_loop(I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R_2, Temp_3);
        _ -> {I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R, Temp}
    end
end,
{I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R_2, Temp_3} = Fun_14(I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, R, Temp),
            I_14 = (I_13 + 1),
            Fun_15_loop(I_14, Key_4, Labels_4, Li_4, PlainText, Polybius, Temp_3);
        _ -> {I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, Temp}
    end
end,
{I_14, Key_4, Labels_4, Li_4, PlainText, Polybius, Temp_3} = Fun_15(I_13, Key_4, Labels_4, Li_4, PlainText, Polybius, Temp),
        ColLen = (length(Temp_3) div length(Key_4)),
        case ((length(Temp_3) rem length(Key_4)) > 0) of
        true -> ColLen_2 = (ColLen + 1),
            ColLen_3 = ColLen_2;
        _ -> ColLen_3 = ColLen
    end,
        Table = [],
        RIdx = 0,
        Fun_17 = fun Fun_17_loop(ColLen_3, I_14, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx, Table, Temp_3) ->
    case (RIdx < ColLen_3) of
        true ->
            Row_2 = [],
            J_7 = 0,
            Fun_16 = fun Fun_16_loop(ColLen_3, I_14, J_7, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx, Row_2, Table, Temp_3) ->
    case (J_7 < length(Key_4)) of
        true ->
            Row_3 = lists:append(Row_2, [""]),
            J_8 = (J_7 + 1),
            Fun_16_loop(ColLen_3, I_14, J_8, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx, Row_3, Table, Temp_3);
        _ -> {ColLen_3, I_14, J_7, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx, Row_2, Table, Temp_3}
    end
end,
{ColLen_3, I_14, J_8, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx, Row_3, Table, Temp_3} = Fun_16(ColLen_3, I_14, J_7, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx, Row_2, Table, Temp_3),
            Table_2 = lists:append(Table, [Row_3]),
            RIdx_2 = (RIdx + 1),
            Fun_17_loop(ColLen_3, I_14, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx_2, Table_2, Temp_3);
        _ -> {ColLen_3, I_14, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx, Table, Temp_3}
    end
end,
{ColLen_3, I_14, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx_2, Table_2, Temp_3} = Fun_17(ColLen_3, I_14, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx, Table, Temp_3),
        Idx_2 = 0,
        Fun_18 = fun Fun_18_loop(ColLen_3, I_14, Idx_2, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx_2, Table_2, Temp_3) ->
    case (Idx_2 < length(Temp_3)) of
        true ->
            Row_4 = (Idx_2 div length(Key_4)),
            Col = (Idx_2 rem length(Key_4)),
            Tmp_4 = (case erlang:is_map(Table_2) of true -> maps:get(Row_4, Table_2, nil); _ -> lists:nth(Row_4 + 1, Table_2) end),
            Tmp_5 = lists:sublist(Tmp_4, Col) ++ [string:substr(Temp_3, Idx_2 + 1, ((Idx_2 + 1) - Idx_2))] ++ lists:nthtail(Col + 1, Tmp_4),
            Table_3 = lists:sublist(Table_2, Row_4) ++ [Tmp_5] ++ lists:nthtail(Row_4 + 1, Table_2),
            Idx_3 = (Idx_2 + 1),
            Fun_18_loop(ColLen_3, I_14, Idx_3, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx_2, Table_3, Temp_3);
        _ -> {ColLen_3, I_14, Idx_2, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx_2, Table_2, Temp_3}
    end
end,
{ColLen_3, I_14, Idx_3, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx_2, Table_3, Temp_3} = Fun_18(ColLen_3, I_14, Idx_2, Key_4, Labels_4, Li_4, PlainText, Polybius, RIdx_2, Table_2, Temp_3),
        Order = orderkey(Key_4),
        Cols = [],
        Ci = 0,
        Fun_20 = fun Fun_20_loop(Ci, ColLen_3, Cols, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Table_3, Temp_3) ->
    case (Ci < length(Key_4)) of
        true ->
            ColStr = "",
            Ri = 0,
            Fun_19 = fun Fun_19_loop(Ci, ColLen_3, ColStr, Cols, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Ri, Table_3, Temp_3) ->
    case (Ri < ColLen_3) of
        true ->
            ColStr_2 = (ColStr ++ (case erlang:is_map((case erlang:is_map(Table_3) of true -> maps:get(Ri, Table_3, nil); _ -> lists:nth(Ri + 1, Table_3) end)) of true -> maps:get((case erlang:is_map(Order) of true -> maps:get(Ci, Order, nil); _ -> lists:nth(Ci + 1, Order) end), (case erlang:is_map(Table_3) of true -> maps:get(Ri, Table_3, nil); _ -> lists:nth(Ri + 1, Table_3) end), nil); _ -> lists:nth((case erlang:is_map(Order) of true -> maps:get(Ci, Order, nil); _ -> lists:nth(Ci + 1, Order) end) + 1, (case erlang:is_map(Table_3) of true -> maps:get(Ri, Table_3, nil); _ -> lists:nth(Ri + 1, Table_3) end)) end)),
            Ri_2 = (Ri + 1),
            Fun_19_loop(Ci, ColLen_3, ColStr_2, Cols, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Ri_2, Table_3, Temp_3);
        _ -> {Ci, ColLen_3, ColStr, Cols, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Ri, Table_3, Temp_3}
    end
end,
{Ci, ColLen_3, ColStr_2, Cols, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Ri_2, Table_3, Temp_3} = Fun_19(Ci, ColLen_3, ColStr, Cols, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Ri, Table_3, Temp_3),
            Cols_2 = lists:append(Cols, [ColStr_2]),
            Ci_2 = (Ci + 1),
            Fun_20_loop(Ci_2, ColLen_3, Cols_2, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Table_3, Temp_3);
        _ -> {Ci, ColLen_3, Cols, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Table_3, Temp_3}
    end
end,
{Ci_2, ColLen_3, Cols_2, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Table_3, Temp_3} = Fun_20(Ci, ColLen_3, Cols, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Table_3, Temp_3),
        Result = "",
        Ci_3 = 0,
        Fun_21 = fun Fun_21_loop(Ci_3, ColLen_3, Cols_2, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Result, Table_3, Temp_3) ->
    case (Ci_3 < length(Cols_2)) of
        true ->
            Result_2 = (Result ++ (case erlang:is_map(Cols_2) of true -> maps:get(Ci_3, Cols_2, nil); _ -> lists:nth(Ci_3 + 1, Cols_2) end)),
            case (Ci_3 < (length(Cols_2) - 1)) of
        true -> Result_3 = (Result_2 ++ " "),
            Result_4 = Result_3;
        _ -> Result_4 = Result_2
    end,
            Ci_4 = (Ci_3 + 1),
            Fun_21_loop(Ci_4, ColLen_3, Cols_2, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Result_4, Table_3, Temp_3);
        _ -> {Ci_3, ColLen_3, Cols_2, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Result, Table_3, Temp_3}
    end
end,
{Ci_4, ColLen_3, Cols_2, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Result_4, Table_3, Temp_3} = Fun_21(Ci_3, ColLen_3, Cols_2, I_14, Idx_3, Key_4, Labels_4, Li_4, Order, PlainText, Polybius, RIdx_2, Result, Table_3, Temp_3),
        Result_4
    catch {return, Ret} -> Ret end.

indexof(S_2, Ch) ->
    try
        I_15 = 0,
        Fun_22 = fun Fun_22_loop(Ch, I_15, S_2) ->
    case (I_15 < length(S_2)) of
        true ->
            case (string:substr(S_2, I_15 + 1, ((I_15 + 1) - I_15)) == Ch) of
        true -> throw({return, I_15});
        _ -> ok
    end,
            I_16 = (I_15 + 1),
            Fun_22_loop(Ch, I_16, S_2);
        _ -> {Ch, I_15, S_2}
    end
end,
{Ch, I_16, S_2} = Fun_22(Ch, I_15, S_2),
        -1
    catch {return, Ret} -> Ret end.

decrypt(Polybius_2, Key_5, CipherText) ->
    try
        ColStrs = [],
        Start = 0,
        I_17 = 0,
        Fun_23 = fun Fun_23_loop(CipherText, ColStrs, I_17, Key_5, Polybius_2, Start) ->
    case (I_17 =< length(CipherText)) of
        true ->
            case ((I_17 == length(CipherText)) orelse (string:substr(CipherText, I_17 + 1, 1) == " ")) of
        true -> ColStrs_2 = lists:append(ColStrs, [string:substr(CipherText, Start + 1, (I_17 - Start))]),
            Start_2 = (I_17 + 1),
            ColStrs_3 = ColStrs_2,
            Start_3 = Start_2;
        _ -> ColStrs_3 = ColStrs,
            Start_3 = Start
    end,
            I_18 = (I_17 + 1),
            Fun_23_loop(CipherText, ColStrs_3, I_18, Key_5, Polybius_2, Start_3);
        _ -> {CipherText, ColStrs, I_17, Key_5, Polybius_2, Start}
    end
end,
{CipherText, ColStrs_3, I_18, Key_5, Polybius_2, Start_3} = Fun_23(CipherText, ColStrs, I_17, Key_5, Polybius_2, Start),
        MaxColLen = 0,
        I_19 = 0,
        Fun_24 = fun Fun_24_loop(CipherText, ColStrs_3, I_19, Key_5, MaxColLen, Polybius_2, Start_3) ->
    case (I_19 < length(ColStrs_3)) of
        true ->
            case (length((case erlang:is_map(ColStrs_3) of true -> maps:get(I_19, ColStrs_3, nil); _ -> lists:nth(I_19 + 1, ColStrs_3) end)) > MaxColLen) of
        true -> MaxColLen_2 = length((case erlang:is_map(ColStrs_3) of true -> maps:get(I_19, ColStrs_3, nil); _ -> lists:nth(I_19 + 1, ColStrs_3) end)),
            MaxColLen_3 = MaxColLen_2;
        _ -> MaxColLen_3 = MaxColLen
    end,
            I_20 = (I_19 + 1),
            Fun_24_loop(CipherText, ColStrs_3, I_20, Key_5, MaxColLen_3, Polybius_2, Start_3);
        _ -> {CipherText, ColStrs_3, I_19, Key_5, MaxColLen, Polybius_2, Start_3}
    end
end,
{CipherText, ColStrs_3, I_20, Key_5, MaxColLen_3, Polybius_2, Start_3} = Fun_24(CipherText, ColStrs_3, I_19, Key_5, MaxColLen, Polybius_2, Start_3),
        Cols_3 = [],
        I_21 = 0,
        Fun_28 = fun Fun_28_loop(CipherText, ColStrs_3, Cols_3, I_21, Key_5, MaxColLen_3, Polybius_2, Start_3) ->
    case (I_21 < length(ColStrs_3)) of
        true ->
            S_3 = (case erlang:is_map(ColStrs_3) of true -> maps:get(I_21, ColStrs_3, nil); _ -> lists:nth(I_21 + 1, ColStrs_3) end),
            Ls = [],
            J_9 = 0,
            Fun_25 = fun Fun_25_loop(CipherText, ColStrs_3, Cols_3, I_21, J_9, Key_5, Ls, MaxColLen_3, Polybius_2, S_3, Start_3) ->
    case (J_9 < length(S_3)) of
        true ->
            Ls_2 = lists:append(Ls, [lists:sublist(S_3, J_9 + 1, ((J_9 + 1) - J_9))]),
            J_10 = (J_9 + 1),
            Fun_25_loop(CipherText, ColStrs_3, Cols_3, I_21, J_10, Key_5, Ls_2, MaxColLen_3, Polybius_2, S_3, Start_3);
        _ -> {CipherText, ColStrs_3, Cols_3, I_21, J_9, Key_5, Ls, MaxColLen_3, Polybius_2, S_3, Start_3}
    end
end,
{CipherText, ColStrs_3, Cols_3, I_21, J_10, Key_5, Ls_2, MaxColLen_3, Polybius_2, S_3, Start_3} = Fun_25(CipherText, ColStrs_3, Cols_3, I_21, J_9, Key_5, Ls, MaxColLen_3, Polybius_2, S_3, Start_3),
            case (length(S_3) < MaxColLen_3) of
        true -> Pad = [],
            K_2 = 0,
            Fun_26 = fun Fun_26_loop(CipherText, ColStrs_3, Cols_3, I_21, J_10, K_2, Key_5, Ls_2, MaxColLen_3, Pad, Polybius_2, S_3, Start_3) ->
    case (K_2 < MaxColLen_3) of
        true ->
            case (K_2 < length(Ls_2)) of
        true -> Pad_2 = lists:append(Pad, [(case erlang:is_map(Ls_2) of true -> maps:get(K_2, Ls_2, nil); _ -> lists:nth(K_2 + 1, Ls_2) end)]),
            Pad_4 = Pad_2;
        _ -> Pad_3 = lists:append(Pad, [""]),
            Pad_4 = Pad_3
    end,
            K_3 = (K_2 + 1),
            Fun_26_loop(CipherText, ColStrs_3, Cols_3, I_21, J_10, K_3, Key_5, Ls_2, MaxColLen_3, Pad_4, Polybius_2, S_3, Start_3);
        _ -> {CipherText, ColStrs_3, Cols_3, I_21, J_10, K_2, Key_5, Ls_2, MaxColLen_3, Pad, Polybius_2, S_3, Start_3}
    end
end,
{CipherText, ColStrs_3, Cols_3, I_21, J_10, K_3, Key_5, Ls_2, MaxColLen_3, Pad_4, Polybius_2, S_3, Start_3} = Fun_26(CipherText, ColStrs_3, Cols_3, I_21, J_10, K_2, Key_5, Ls_2, MaxColLen_3, Pad, Polybius_2, S_3, Start_3),
            Cols_4 = lists:append(Cols_3, [Pad_4]),
            Cols_6 = Cols_4,
            Fun_27 = Fun_26,
            K_4 = K_3,
            Pad_5 = Pad_4;
        _ -> Cols_5 = lists:append(Cols_3, [Ls_2]),
            Cols_6 = Cols_5,
            Fun_27 = Fun_25,
            K_4 = nil,
            Pad_5 = nil
    end,
            I_22 = (I_21 + 1),
            Fun_28_loop(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, Start_3);
        _ -> {CipherText, ColStrs_3, Cols_3, I_21, Key_5, MaxColLen_3, Polybius_2, Start_3}
    end
end,
{CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, Start_3} = Fun_28(CipherText, ColStrs_3, Cols_3, I_21, Key_5, MaxColLen_3, Polybius_2, Start_3),
        Table_4 = [],
        R_3 = 0,
        Fun_30 = fun Fun_30_loop(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_3, Start_3, Table_4) ->
    case (R_3 < MaxColLen_3) of
        true ->
            Row_5 = [],
            C_3 = 0,
            Fun_29 = fun Fun_29_loop(C_3, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_3, Row_5, Start_3, Table_4) ->
    case (C_3 < length(Key_5)) of
        true ->
            Row_6 = lists:append(Row_5, [""]),
            C_4 = (C_3 + 1),
            Fun_29_loop(C_4, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_3, Row_6, Start_3, Table_4);
        _ -> {C_3, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_3, Row_5, Start_3, Table_4}
    end
end,
{C_4, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_3, Row_6, Start_3, Table_4} = Fun_29(C_3, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_3, Row_5, Start_3, Table_4),
            Table_5 = lists:append(Table_4, [Row_6]),
            R_4 = (R_3 + 1),
            Fun_30_loop(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_4, Start_3, Table_5);
        _ -> {CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_3, Start_3, Table_4}
    end
end,
{CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_4, Start_3, Table_5} = Fun_30(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Polybius_2, R_3, Start_3, Table_4),
        Order_2 = orderkey(Key_5),
        R_5 = 0,
        Fun_32 = fun Fun_32_loop(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_5, Start_3, Table_5) ->
    case (R_5 < MaxColLen_3) of
        true ->
            C_5 = 0,
            Fun_31 = fun Fun_31_loop(C_5, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_5, Start_3, Table_5) ->
    case (C_5 < length(Key_5)) of
        true ->
            Tmp_6 = (case erlang:is_map(Table_5) of true -> maps:get(R_5, Table_5, nil); _ -> lists:nth(R_5 + 1, Table_5) end),
            Tmp_7 = lists:sublist(Tmp_6, (case erlang:is_map(Order_2) of true -> maps:get(C_5, Order_2, nil); _ -> lists:nth(C_5 + 1, Order_2) end)) ++ [(case erlang:is_map((case erlang:is_map(Cols_6) of true -> maps:get(C_5, Cols_6, nil); _ -> lists:nth(C_5 + 1, Cols_6) end)) of true -> maps:get(R_5, (case erlang:is_map(Cols_6) of true -> maps:get(C_5, Cols_6, nil); _ -> lists:nth(C_5 + 1, Cols_6) end), nil); _ -> lists:nth(R_5 + 1, (case erlang:is_map(Cols_6) of true -> maps:get(C_5, Cols_6, nil); _ -> lists:nth(C_5 + 1, Cols_6) end)) end)] ++ lists:nthtail((case erlang:is_map(Order_2) of true -> maps:get(C_5, Order_2, nil); _ -> lists:nth(C_5 + 1, Order_2) end) + 1, Tmp_6),
            Table_6 = lists:sublist(Table_5, R_5) ++ [Tmp_7] ++ lists:nthtail(R_5 + 1, Table_5),
            C_6 = (C_5 + 1),
            Fun_31_loop(C_6, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_5, Start_3, Table_6);
        _ -> {C_5, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_5, Start_3, Table_5}
    end
end,
{C_6, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_5, Start_3, Table_6} = Fun_31(C_5, CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_5, Start_3, Table_5),
            R_6 = (R_5 + 1),
            Fun_32_loop(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_6, Start_3, Table_6);
        _ -> {CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_5, Start_3, Table_5}
    end
end,
{CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_6, Start_3, Table_6} = Fun_32(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_5, Start_3, Table_5),
        Temp_4 = "",
        R_7 = 0,
        Fun_34 = fun Fun_34_loop(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_7, Start_3, Table_6, Temp_4) ->
    case (R_7 < length(Table_6)) of
        true ->
            J_11 = 0,
            Fun_33 = fun Fun_33_loop(CipherText, ColStrs_3, Cols_6, I_22, J_11, Key_5, MaxColLen_3, Order_2, Polybius_2, R_7, Start_3, Table_6, Temp_4) ->
    case (J_11 < length((case erlang:is_map(Table_6) of true -> maps:get(R_7, Table_6, nil); _ -> lists:nth(R_7 + 1, Table_6) end))) of
        true ->
            Temp_5 = (Temp_4 ++ (case erlang:is_map((case erlang:is_map(Table_6) of true -> maps:get(R_7, Table_6, nil); _ -> lists:nth(R_7 + 1, Table_6) end)) of true -> maps:get(J_11, (case erlang:is_map(Table_6) of true -> maps:get(R_7, Table_6, nil); _ -> lists:nth(R_7 + 1, Table_6) end), nil); _ -> lists:nth(J_11 + 1, (case erlang:is_map(Table_6) of true -> maps:get(R_7, Table_6, nil); _ -> lists:nth(R_7 + 1, Table_6) end)) end)),
            J_12 = (J_11 + 1),
            Fun_33_loop(CipherText, ColStrs_3, Cols_6, I_22, J_12, Key_5, MaxColLen_3, Order_2, Polybius_2, R_7, Start_3, Table_6, Temp_5);
        _ -> {CipherText, ColStrs_3, Cols_6, I_22, J_11, Key_5, MaxColLen_3, Order_2, Polybius_2, R_7, Start_3, Table_6, Temp_4}
    end
end,
{CipherText, ColStrs_3, Cols_6, I_22, J_12, Key_5, MaxColLen_3, Order_2, Polybius_2, R_7, Start_3, Table_6, Temp_5} = Fun_33(CipherText, ColStrs_3, Cols_6, I_22, J_11, Key_5, MaxColLen_3, Order_2, Polybius_2, R_7, Start_3, Table_6, Temp_4),
            R_8 = (R_7 + 1),
            Fun_34_loop(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_8, Start_3, Table_6, Temp_5);
        _ -> {CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_7, Start_3, Table_6, Temp_4}
    end
end,
{CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_8, Start_3, Table_6, Temp_5} = Fun_34(CipherText, ColStrs_3, Cols_6, I_22, Key_5, MaxColLen_3, Order_2, Polybius_2, R_7, Start_3, Table_6, Temp_4),
        PlainText_2 = "",
        Idx_4 = 0,
        Fun_35 = fun Fun_35_loop(CipherText, ColStrs_3, Cols_6, I_22, Idx_4, Key_5, MaxColLen_3, Order_2, PlainText_2, Polybius_2, R_8, Start_3, Table_6, Temp_5) ->
    case (Idx_4 < length(Temp_5)) of
        true ->
            RIdx_3 = mochi_index_of(erlang:get('adfgvx'), string:substr(Temp_5, Idx_4 + 1, ((Idx_4 + 1) - Idx_4))),
            CIdx = mochi_index_of(erlang:get('adfgvx'), string:substr(Temp_5, (Idx_4 + 1) + 1, ((Idx_4 + 2) - (Idx_4 + 1)))),
            PlainText_3 = (PlainText_2 ++ string:substr((case erlang:is_map(Polybius_2) of true -> maps:get(RIdx_3, Polybius_2, nil); _ -> lists:nth(RIdx_3 + 1, Polybius_2) end), CIdx + 1, 1)),
            Idx_5 = (Idx_4 + 2),
            Fun_35_loop(CipherText, ColStrs_3, Cols_6, I_22, Idx_5, Key_5, MaxColLen_3, Order_2, PlainText_3, Polybius_2, R_8, Start_3, Table_6, Temp_5);
        _ -> {CipherText, ColStrs_3, Cols_6, I_22, Idx_4, Key_5, MaxColLen_3, Order_2, PlainText_2, Polybius_2, R_8, Start_3, Table_6, Temp_5}
    end
end,
{CipherText, ColStrs_3, Cols_6, I_22, Idx_5, Key_5, MaxColLen_3, Order_2, PlainText_3, Polybius_2, R_8, Start_3, Table_6, Temp_5} = Fun_35(CipherText, ColStrs_3, Cols_6, I_22, Idx_4, Key_5, MaxColLen_3, Order_2, PlainText_2, Polybius_2, R_8, Start_3, Table_6, Temp_5),
        PlainText_3
    catch {return, Ret} -> Ret end.

main() ->
    try
        PlainText_4 = "ATTACKAT1200AM",
        Polybius_3 = createpolybius(),
        Key_6 = createkey(9),
        io:format("~ts~n", [("\nPlaintext : " ++ "ATTACKAT1200AM")]),
        CipherText_2 = encrypt(Polybius_3, Key_6, "ATTACKAT1200AM"),
        io:format("~ts~n", [("\nEncrypted : " ++ CipherText_2)]),
        PlainText2 = decrypt(Polybius_3, Key_6, CipherText_2),
        io:format("~ts~n", [("\nDecrypted : " ++ PlainText2)]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('adfgvx', "ADFGVX"),
    erlang:put('alphabet', "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
