#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, randorder/2, randchaos/2, main/0]).

% Generated by Mochi transpiler v0.10.55 (87d3efb875) on 2025-08-03 08:53 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

randorder(Seed, N) ->
    try
        Next = (((Seed * 1664525) + 1013904223) rem 2147483647),
        [Next, (Next rem N)]
    catch {return, Ret} -> Ret end.

randchaos(Seed_2, N_2) ->
    try
        Next_2 = (((Seed_2 * 1103515245) + 12345) rem 2147483647),
        [Next_2, (Next_2 rem N_2)]
    catch {return, Ret} -> Ret end.

main() ->
    try
        NBuckets = 10,
        InitialSum = 1000,
        Buckets = [],
        Fun = fun Fun_loop(List, Buckets, InitialSum, NBuckets) ->
    case List of
        [] -> {Buckets, InitialSum, NBuckets};
        [I|I_rest] ->
            Buckets_2 = lists:append(Buckets, [0]),
            Fun_loop(I_rest, Buckets_2, InitialSum, NBuckets)
    end
end,
{Buckets_2, InitialSum, NBuckets} = Fun(lists:seq(0, (10) - 1), Buckets, InitialSum, NBuckets),
        I_2 = 10,
        Dist = 1000,
        Fun_2 = fun Fun_2_loop(Buckets_2, Dist, I_2, InitialSum, NBuckets) ->
    case (I_2 > 0) of
        true ->
            V = (Dist div I_2),
            I_3 = (I_2 - 1),
            Buckets_3 = lists:sublist(Buckets_2, I_3) ++ [V] ++ lists:nthtail(I_3 + 1, Buckets_2),
            Dist_2 = (Dist - V),
            Fun_2_loop(Buckets_3, Dist_2, I_3, InitialSum, NBuckets);
        _ -> {Buckets_2, Dist, I_2, InitialSum, NBuckets}
    end
end,
{Buckets_3, Dist_2, I_3, InitialSum, NBuckets} = Fun_2(Buckets_2, Dist, I_2, InitialSum, NBuckets),
        Tc0 = 0,
        Tc1 = 0,
        Total = 0,
        NTicks = 0,
        SeedOrder = 1,
        SeedChaos = 2,
        io:format("~ts~n", ["sum  ---updates---    mean  buckets"]),
        T = 0,
        Fun_4 = fun Fun_4_loop(Buckets_3, Dist_2, I_3, InitialSum, NBuckets, NTicks, SeedChaos, SeedOrder, T, Tc0, Tc1, Total) ->
    case (T < 5) of
        true ->
            R = randorder(SeedOrder, NBuckets),
            SeedOrder_2 = (case erlang:is_map(R) of true -> maps:get(0, R, nil); _ -> lists:nth(0 + 1, R) end),
            B1 = (case erlang:is_map(R) of true -> maps:get(1, R, nil); _ -> lists:nth(1 + 1, R) end),
            B2 = ((B1 + 1) rem NBuckets),
            V1 = (case erlang:is_map(Buckets_3) of true -> maps:get(B1, Buckets_3, nil); _ -> lists:nth(B1 + 1, Buckets_3) end),
            V2 = (case erlang:is_map(Buckets_3) of true -> maps:get(B2, Buckets_3, nil); _ -> lists:nth(B2 + 1, Buckets_3) end),
            case (V1 > V2) of
        true -> A = mochi_to_int(((V1 - V2) div 2)),
            case (A > (case erlang:is_map(Buckets_3) of true -> maps:get(B1, Buckets_3, nil); _ -> lists:nth(B1 + 1, Buckets_3) end)) of
        true -> A_2 = (case erlang:is_map(Buckets_3) of true -> maps:get(B1, Buckets_3, nil); _ -> lists:nth(B1 + 1, Buckets_3) end),
            A_3 = A_2;
        _ -> A_3 = A
    end,
            Buckets_4 = lists:sublist(Buckets_3, B1) ++ [((case erlang:is_map(Buckets_3) of true -> maps:get(B1, Buckets_3, nil); _ -> lists:nth(B1 + 1, Buckets_3) end) - A_3)] ++ lists:nthtail(B1 + 1, Buckets_3),
            Buckets_5 = lists:sublist(Buckets_4, B2) ++ [((case erlang:is_map(Buckets_4) of true -> maps:get(B2, Buckets_4, nil); _ -> lists:nth(B2 + 1, Buckets_4) end) + A_3)] ++ lists:nthtail(B2 + 1, Buckets_4),
            A_7 = A_3,
            Buckets_8 = Buckets_5;
        _ -> A_4 = mochi_to_int(((V2 - V1) div 2)),
            case (A_4 > (case erlang:is_map(Buckets_3) of true -> maps:get(B2, Buckets_3, nil); _ -> lists:nth(B2 + 1, Buckets_3) end)) of
        true -> A_5 = (case erlang:is_map(Buckets_3) of true -> maps:get(B2, Buckets_3, nil); _ -> lists:nth(B2 + 1, Buckets_3) end),
            A_6 = A_5;
        _ -> A_6 = A_4
    end,
            Buckets_6 = lists:sublist(Buckets_3, B2) ++ [((case erlang:is_map(Buckets_3) of true -> maps:get(B2, Buckets_3, nil); _ -> lists:nth(B2 + 1, Buckets_3) end) - A_6)] ++ lists:nthtail(B2 + 1, Buckets_3),
            Buckets_7 = lists:sublist(Buckets_6, B1) ++ [((case erlang:is_map(Buckets_6) of true -> maps:get(B1, Buckets_6, nil); _ -> lists:nth(B1 + 1, Buckets_6) end) + A_6)] ++ lists:nthtail(B1 + 1, Buckets_6),
            A_7 = A_6,
            Buckets_8 = Buckets_7
    end,
            Tc0_2 = (Tc0 + 1),
            R_2 = randchaos(SeedChaos, NBuckets),
            SeedChaos_2 = (case erlang:is_map(R_2) of true -> maps:get(0, R_2, nil); _ -> lists:nth(0 + 1, R_2) end),
            B1_2 = (case erlang:is_map(R_2) of true -> maps:get(1, R_2, nil); _ -> lists:nth(1 + 1, R_2) end),
            B2_2 = ((B1_2 + 1) rem NBuckets),
            R_3 = randchaos(SeedChaos_2, ((case erlang:is_map(Buckets_8) of true -> maps:get(B1_2, Buckets_8, nil); _ -> lists:nth(B1_2 + 1, Buckets_8) end) + 1)),
            SeedChaos_3 = (case erlang:is_map(R_3) of true -> maps:get(0, R_3, nil); _ -> lists:nth(0 + 1, R_3) end),
            Amt = (case erlang:is_map(R_3) of true -> maps:get(1, R_3, nil); _ -> lists:nth(1 + 1, R_3) end),
            case (Amt > (case erlang:is_map(Buckets_8) of true -> maps:get(B1_2, Buckets_8, nil); _ -> lists:nth(B1_2 + 1, Buckets_8) end)) of
        true -> Amt_2 = (case erlang:is_map(Buckets_8) of true -> maps:get(B1_2, Buckets_8, nil); _ -> lists:nth(B1_2 + 1, Buckets_8) end),
            Amt_3 = Amt_2;
        _ -> Amt_3 = Amt
    end,
            Buckets_9 = lists:sublist(Buckets_8, B1_2) ++ [((case erlang:is_map(Buckets_8) of true -> maps:get(B1_2, Buckets_8, nil); _ -> lists:nth(B1_2 + 1, Buckets_8) end) - Amt_3)] ++ lists:nthtail(B1_2 + 1, Buckets_8),
            Buckets_10 = lists:sublist(Buckets_9, B2_2) ++ [((case erlang:is_map(Buckets_9) of true -> maps:get(B2_2, Buckets_9, nil); _ -> lists:nth(B2_2 + 1, Buckets_9) end) + Amt_3)] ++ lists:nthtail(B2_2 + 1, Buckets_9),
            Tc1_2 = (Tc1 + 1),
            Sum = 0,
            Idx = 0,
            Fun_3 = fun Fun_3_loop(A_7, Amt_3, B1_2, B2_2, Buckets_10, Dist_2, I_3, Idx, InitialSum, NBuckets, NTicks, R_3, SeedChaos_3, SeedOrder_2, Sum, T, Tc0_2, Tc1_2, Total, V1, V2) ->
    case (Idx < NBuckets) of
        true ->
            Sum_2 = (Sum + (case erlang:is_map(Buckets_10) of true -> maps:get(Idx, Buckets_10, nil); _ -> lists:nth(Idx + 1, Buckets_10) end)),
            Idx_2 = (Idx + 1),
            Fun_3_loop(A_7, Amt_3, B1_2, B2_2, Buckets_10, Dist_2, I_3, Idx_2, InitialSum, NBuckets, NTicks, R_3, SeedChaos_3, SeedOrder_2, Sum_2, T, Tc0_2, Tc1_2, Total, V1, V2);
        _ -> {A_7, Amt_3, B1_2, B2_2, Buckets_10, Dist_2, I_3, Idx, InitialSum, NBuckets, NTicks, R_3, SeedChaos_3, SeedOrder_2, Sum, T, Tc0_2, Tc1_2, Total, V1, V2}
    end
end,
{A_7, Amt_3, B1_2, B2_2, Buckets_10, Dist_2, I_3, Idx_2, InitialSum, NBuckets, NTicks, R_3, SeedChaos_3, SeedOrder_2, Sum_2, T, Tc0_2, Tc1_2, Total, V1, V2} = Fun_3(A_7, Amt_3, B1_2, B2_2, Buckets_10, Dist_2, I_3, Idx, InitialSum, NBuckets, NTicks, R_3, SeedChaos_3, SeedOrder_2, Sum, T, Tc0_2, Tc1_2, Total, V1, V2),
            Total_2 = ((Total + Tc0_2) + Tc1_2),
            NTicks_2 = (NTicks + 1),
            io:format("~ts~n", [((((((((lists:flatten(io_lib:format("~p", [Sum_2])) ++ " ") ++ lists:flatten(io_lib:format("~p", [Tc0_2]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [Tc1_2]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [(Total_2 div NTicks_2)]))) ++ "  ") ++ lists:flatten(io_lib:format("~p", [Buckets_10])))]),
            Tc0_3 = 0,
            Tc1_3 = 0,
            T_2 = (T + 1),
            Fun_4_loop(Buckets_10, Dist_2, I_3, InitialSum, NBuckets, NTicks_2, SeedChaos_3, SeedOrder_2, T_2, Tc0_3, Tc1_3, Total_2);
        _ -> {Buckets_3, Dist_2, I_3, InitialSum, NBuckets, NTicks, SeedChaos, SeedOrder, T, Tc0, Tc1, Total}
    end
end,
{Buckets_10, Dist_2, I_3, InitialSum, NBuckets, NTicks_2, SeedChaos_3, SeedOrder_2, T_2, Tc0_3, Tc1_3, Total_2} = Fun_4(Buckets_3, Dist_2, I_3, InitialSum, NBuckets, NTicks, SeedChaos, SeedOrder, T, Tc0, Tc1, Total),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
