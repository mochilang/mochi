#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, zero/1, succ/1, add/2, mul/2, pow/2, incr/1, toint/1, inttochurch/1]).

% Generated by Mochi transpiler v0.10.41 (fc61869ba1) on 2025-07-27 00:43 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

zero(F) ->
    try
        fun(X) ->
    try
        X
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end.

succ(C) ->
    try
        fun(F_2) ->
    try
        fun(X_2) ->
    try
        F_2((C(F_2))(X_2))
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end.

add(C_2, D) ->
    try
        fun(F_3) ->
    try
        fun(X_3) ->
    try
        (C_2(F_3))((D(F_3))(X_3))
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end.

mul(C_3, D_2) ->
    try
        fun(F_4) ->
    try
        fun(X_4) ->
    try
        (C_3(D_2(F_4)))(X_4)
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end.

pow(C_4, D_3) ->
    try
        Di = toint(D_3),
        Prod = C_4,
        I = 1,
        Fun = fun Fun_loop(C_4, D_3, Di, I, Prod) ->
    case (I < Di) of
        true ->
            Prod_2 = mul(Prod, C_4),
            I_2 = (I + 1),
            Fun_loop(C_4, D_3, Di, I_2, Prod_2);
        _ -> {C_4, D_3, Di, I, Prod}
    end
end,
{C_4, D_3, Di, I_2, Prod_2} = Fun(C_4, D_3, Di, I, Prod),
        Prod_2
    catch {return, Ret} -> Ret end.

incr(I_3) ->
    try
        (mochi_to_int(I_3) + 1)
    catch {return, Ret} -> Ret end.

toint(C_5) ->
    try
        mochi_to_int((C_5(fun incr/1))(0))
    catch {return, Ret} -> Ret end.

inttochurch(I_4) ->
    try
        (case (I_4 == 0) of
    true -> fun zero/1;
    _ -> succ(inttochurch((I_4 - 1)))
end)
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('z', fun zero/1),
    erlang:put('three', succ(succ(succ(erlang:get('z'))))),
    erlang:put('four', succ(erlang:get('three'))),
    io:format("~ts~n", [("three        -> " ++ lists:flatten(io_lib:format("~p", [toint(erlang:get('three'))])))]),
    io:format("~ts~n", [("four         -> " ++ lists:flatten(io_lib:format("~p", [toint(erlang:get('four'))])))]),
    io:format("~ts~n", [("three + four -> " ++ lists:flatten(io_lib:format("~p", [toint(add(erlang:get('three'), erlang:get('four')))])))]),
    io:format("~ts~n", [("three * four -> " ++ lists:flatten(io_lib:format("~p", [toint(mul(erlang:get('three'), erlang:get('four')))])))]),
    io:format("~ts~n", [("three ^ four -> " ++ lists:flatten(io_lib:format("~p", [toint(pow(erlang:get('three'), erlang:get('four')))])))]),
    io:format("~ts~n", [("four ^ three -> " ++ lists:flatten(io_lib:format("~p", [toint(pow(erlang:get('four'), erlang:get('three')))])))]),
    io:format("~ts~n", [("5 -> five    -> " ++ lists:flatten(io_lib:format("~p", [toint(inttochurch(5))])))]),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
