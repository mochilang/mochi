#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, bitat/2, outputstate/1, step/2, elem/4, randinit/2, singleinit/1, main/0]).

% Generated by Mochi transpiler v0.10.54 (1e9d459eac) on 2025-08-02 11:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

bitat(X, Idx) ->
    try
        V = X,
        I = 0,
        Fun = fun Fun_loop(I, Idx, V, X) ->
    case (I < Idx) of
        true ->
            V_2 = mochi_to_int((V div 2)),
            I_2 = (I + 1),
            Fun_loop(I_2, Idx, V_2, X);
        _ -> {I, Idx, V, X}
    end
end,
{I_2, Idx, V_2, X} = Fun(I, Idx, V, X),
        (V_2 rem 2)
    catch {return, Ret} -> Ret end.

outputstate(State) ->
    try
        Line = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Line, State) ->
    case (I_3 < length(State)) of
        true ->
            case (string:substr(State, I_3 + 1, ((I_3 + 1) - I_3)) == "1") of
        true -> Line_2 = (Line ++ "#"),
            Line_4 = Line_2;
        _ -> Line_3 = (Line ++ " "),
            Line_4 = Line_3
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Line_4, State);
        _ -> {I_3, Line, State}
    end
end,
{I_4, Line_4, State} = Fun_2(I_3, Line, State),
        io:format("~ts~n", [Line_4]),
        nil
    catch {return, Ret} -> Ret end.

step(State_2, R) ->
    try
        Cells = length(State_2),
        Out = "",
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Cells, I_5, Out, R, State_2) ->
    case (I_5 < Cells) of
        true ->
            L = string:substr(State_2, (((I_5 - 1) + Cells) rem Cells) + 1, (((((I_5 - 1) + Cells) rem Cells) + 1) - (((I_5 - 1) + Cells) rem Cells))),
            C = string:substr(State_2, I_5 + 1, ((I_5 + 1) - I_5)),
            Rt = string:substr(State_2, ((I_5 + 1) rem Cells) + 1, ((((I_5 + 1) rem Cells) + 1) - ((I_5 + 1) rem Cells))),
            Idx_2 = 0,
            case (L == "1") of
        true -> Idx_3 = (Idx_2 + 4),
            Idx_4 = Idx_3;
        _ -> Idx_4 = Idx_2
    end,
            case (C == "1") of
        true -> Idx_5 = (Idx_4 + 2),
            Idx_6 = Idx_5;
        _ -> Idx_6 = Idx_4
    end,
            case (Rt == "1") of
        true -> Idx_7 = (Idx_6 + 1),
            Idx_8 = Idx_7;
        _ -> Idx_8 = Idx_6
    end,
            case (bitat(R, Idx_8) == 1) of
        true -> Out_2 = (Out ++ "1"),
            Out_4 = Out_2;
        _ -> Out_3 = (Out ++ "0"),
            Out_4 = Out_3
    end,
            I_6 = (I_5 + 1),
            Fun_3_loop(Cells, I_6, Out_4, R, State_2);
        _ -> {Cells, I_5, Out, R, State_2}
    end
end,
{Cells, I_6, Out_4, R, State_2} = Fun_3(Cells, I_5, Out, R, State_2),
        Out_4
    catch {return, Ret} -> Ret end.

elem(R_2, Cells_2, Generations, State_3) ->
    try
        outputstate(State_3),
        G = 0,
        S = State_3,
        Fun_4 = fun Fun_4_loop(Cells_2, G, Generations, R_2, S, State_3) ->
    case (G < Generations) of
        true ->
            S_2 = step(S, R_2),
            outputstate(S_2),
            G_2 = (G + 1),
            Fun_4_loop(Cells_2, G_2, Generations, R_2, S_2, State_3);
        _ -> {Cells_2, G, Generations, R_2, S, State_3}
    end
end,
{Cells_2, G_2, Generations, R_2, S_2, State_3} = Fun_4(Cells_2, G, Generations, R_2, S, State_3),
        nil
    catch {return, Ret} -> Ret end.

randinit(Cells_3, Seed) ->
    try
        S_3 = "",
        Val = Seed,
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(Cells_3, I_7, S_3, Seed, Val) ->
    case (I_7 < Cells_3) of
        true ->
            Val_2 = (((Val * 1664525) + 1013904223) rem 2147483647),
            case ((Val_2 rem 2) == 0) of
        true -> S_4 = (S_3 ++ "0"),
            S_6 = S_4;
        _ -> S_5 = (S_3 ++ "1"),
            S_6 = S_5
    end,
            I_8 = (I_7 + 1),
            Fun_5_loop(Cells_3, I_8, S_6, Seed, Val_2);
        _ -> {Cells_3, I_7, S_3, Seed, Val}
    end
end,
{Cells_3, I_8, S_6, Seed, Val_2} = Fun_5(Cells_3, I_7, S_3, Seed, Val),
        S_6
    catch {return, Ret} -> Ret end.

singleinit(Cells_4) ->
    try
        S_7 = "",
        I_9 = 0,
        Fun_6 = fun Fun_6_loop(Cells_4, I_9, S_7) ->
    case (I_9 < Cells_4) of
        true ->
            case (I_9 == (Cells_4 div 2)) of
        true -> S_8 = (S_7 ++ "1"),
            S_10 = S_8;
        _ -> S_9 = (S_7 ++ "0"),
            S_10 = S_9
    end,
            I_10 = (I_9 + 1),
            Fun_6_loop(Cells_4, I_10, S_10);
        _ -> {Cells_4, I_9, S_7}
    end
end,
{Cells_4, I_10, S_10} = Fun_6(Cells_4, I_9, S_7),
        S_10
    catch {return, Ret} -> Ret end.

main() ->
    try
        Cells_5 = 20,
        Generations_2 = 9,
        io:format("~ts~n", ["Single 1, rule 90:"]),
        State_4 = singleinit(20),
        elem(90, 20, 9, State_4),
        io:format("~ts~n", ["Random intial state, rule 30:"]),
        State_5 = randinit(20, 3),
        elem(30, 20, 9, State_5),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
