#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, join/2, sortpairs/1, isalphanumdot/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (0f7fd10226) on 2025-08-02 20:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

join(Xs, Sep) ->
    try
        Res = "",
        I = 0,
        Fun = fun Fun_loop(I, Res, Sep, Xs) ->
    case (I < length(Xs)) of
        true ->
            case (I > 0) of
        true -> Res_2 = (Res ++ Sep),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Res_4 = (Res_3 ++ (case erlang:is_map(Xs) of true -> maps:get(I, Xs, nil); _ -> lists:nth(I + 1, Xs) end)),
            I_2 = (I + 1),
            Fun_loop(I_2, Res_4, Sep, Xs);
        _ -> {I, Res, Sep, Xs}
    end
end,
{I_2, Res_4, Sep, Xs} = Fun(I, Res, Sep, Xs),
        Res_4
    catch {return, Ret} -> Ret end.

sortpairs(Xs_2) ->
    try
        Arr = Xs_2,
        I_3 = 1,
        Fun_3 = fun Fun_3_loop(Arr, I_3, Xs_2) ->
    case (I_3 < length(Arr)) of
        true ->
            J = I_3,
            Fun_2 = fun Fun_2_loop(Arr, I_3, J, Xs_2) ->
    case ((J > 0) andalso (mochi_to_int(maps:get("count", (case erlang:is_map(Arr) of true -> maps:get((J - 1), Arr, nil); _ -> lists:nth((J - 1) + 1, Arr) end), nil)) < mochi_to_int(maps:get("count", (case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> lists:nth(J + 1, Arr) end), nil)))) of
        true ->
            Tmp = (case erlang:is_map(Arr) of true -> maps:get((J - 1), Arr, nil); _ -> lists:nth((J - 1) + 1, Arr) end),
            Arr_2 = lists:sublist(Arr, (J - 1)) ++ [(case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> lists:nth(J + 1, Arr) end)] ++ lists:nthtail((J - 1) + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, J) ++ [Tmp] ++ lists:nthtail(J + 1, Arr_2),
            J_2 = (J - 1),
            Fun_2_loop(Arr_3, I_3, J_2, Xs_2);
        _ -> {Arr, I_3, J, Xs_2}
    end
end,
{Arr_3, I_3, J_2, Xs_2} = Fun_2(Arr, I_3, J, Xs_2),
            I_4 = (I_3 + 1),
            Fun_3_loop(Arr_3, I_4, Xs_2);
        _ -> {Arr, I_3, Xs_2}
    end
end,
{Arr_3, I_4, Xs_2} = Fun_3(Arr, I_3, Xs_2),
        Arr_3
    catch {return, Ret} -> Ret end.

isalphanumdot(Ch) ->
    try
        ((((((Ch >= "A") andalso (Ch =< "Z")) orelse ((Ch >= "a") andalso (Ch =< "z"))) orelse ((Ch >= "0") andalso (Ch =< "9"))) orelse (Ch == "_")) orelse (Ch == "."))
    catch {return, Ret} -> Ret end.

main() ->
    try
        SrcLines = ["package main", "", "import (", "    \"fmt\"", "    \"go/ast\"", "    \"go/parser\"", "    \"go/token\"", "    \"io/ioutil\"", "    \"os\"", "    \"sort\"", ")", "", "func main() {", "    if len(os.Args) != 2 {", "        fmt.Println(\"usage ff <go source filename>\")", "        return", "    }", "    src, err := ioutil.ReadFile(os.Args[1])", "    if err != nil {", "        fmt.Println(err)", "        return", "    }", "    fs := token.NewFileSet()", "    a, err := parser.ParseFile(fs, os.Args[1], src, 0)", "    if err != nil {", "        fmt.Println(err)", "        return", "    }", "    f := fs.File(a.Pos())", "    m := make(map[string]int)", "    ast.Inspect(a, func(n ast.Node) bool {", "        if ce, ok := n.(*ast.CallExpr); ok {", "            start := f.Offset(ce.Pos())", "            end := f.Offset(ce.Lparen)", "            m[string(src[start:end])]++", "        }", "        return true", "    })", "    cs := make(calls, 0, len(m))", "    for k, v := range m {", "        cs = append(cs, &call{k, v})", "    }", "    sort.Sort(cs)", "    for i, c := range cs {", "        fmt.Printf(\"%-20s %4d\\n\", c.expr, c.count)", "        if i == 9 {", "            break", "        }", "    }", "}", "", "type call struct {", "    expr  string", "    count int", "}", "type calls []*call", "", "func (c calls) Len() int           { return len(c) }", "func (c calls) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }", "func (c calls) Less(i, j int) bool { return c[i].count > c[j].count }"],
        Src = join(SrcLines, "\n"),
        Freq = #{},
        I_5 = 0,
        Order = [],
        Fun_9 = fun Fun_9_loop(Freq, I_5, Order, Src, SrcLines) ->
    case (I_5 < length(Src)) of
        true ->
            try
                Ch_2 = string:substr(Src, I_5 + 1, ((I_5 + 1) - I_5)),
                case ((((Ch_2 >= "A") andalso (Ch_2 =< "Z")) orelse ((Ch_2 >= "a") andalso (Ch_2 =< "z"))) orelse (Ch_2 == "_")) of
        true -> J_3 = (I_5 + 1),
            Fun_4 = fun Fun_4_loop(Ch_2, Freq, I_5, J_3, Order, Src, SrcLines) ->
    case ((J_3 < length(Src)) andalso isalphanumdot(string:substr(Src, J_3 + 1, ((J_3 + 1) - J_3)))) of
        true ->
            J_4 = (J_3 + 1),
            Fun_4_loop(Ch_2, Freq, I_5, J_4, Order, Src, SrcLines);
        _ -> {Ch_2, Freq, I_5, J_3, Order, Src, SrcLines}
    end
end,
{Ch_2, Freq, I_5, J_4, Order, Src, SrcLines} = Fun_4(Ch_2, Freq, I_5, J_3, Order, Src, SrcLines),
            Token = string:substr(Src, I_5 + 1, (J_4 - I_5)),
            K = J_4,
            Fun_5 = fun Fun_5_loop(Ch_2, Freq, I_5, J_4, K, Order, Src, SrcLines, Token) ->
    case (K < length(Src)) of
        true ->
            try
                Cc = string:substr(Src, K + 1, ((K + 1) - K)),
                case ((((Cc == " ") orelse (Cc == "\t")) orelse (Cc == "\n")) orelse (Cc == "\r")) of
        true -> K_2 = (K + 1),
            K_3 = K_2;
        _ -> throw(break),
            K_3 = K
    end,
                Fun_5_loop(Ch_2, Freq, I_5, J_4, K_3, Order, Src, SrcLines, Token)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_5_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {Ch_2, Freq, I_5, J_4, K, Order, Src, SrcLines, Token}
            end;
        _ -> {Ch_2, Freq, I_5, J_4, K, Order, Src, SrcLines, Token}
    end
end,
{Ch_2, Freq, I_5, J_4, K_3, Order, Src, SrcLines, Token} = Fun_5(Ch_2, Freq, I_5, J_4, K, Order, Src, SrcLines, Token),
            case ((K_3 < length(Src)) andalso (string:substr(Src, K_3 + 1, ((K_3 + 1) - K_3)) == "(")) of
        true -> P = (I_5 - 1),
            Fun_6 = fun Fun_6_loop(Ch_2, Freq, I_5, J_4, K_3, Order, P, Src, SrcLines, Token) ->
    case ((P >= 0) andalso ((string:substr(Src, P + 1, ((P + 1) - P)) == " ") orelse (string:substr(Src, P + 1, ((P + 1) - P)) == "\t"))) of
        true ->
            P_2 = (P - 1),
            Fun_6_loop(Ch_2, Freq, I_5, J_4, K_3, Order, P_2, Src, SrcLines, Token);
        _ -> {Ch_2, Freq, I_5, J_4, K_3, Order, P, Src, SrcLines, Token}
    end
end,
{Ch_2, Freq, I_5, J_4, K_3, Order, P_2, Src, SrcLines, Token} = Fun_6(Ch_2, Freq, I_5, J_4, K_3, Order, P, Src, SrcLines, Token),
            Skip = false,
            case (P_2 >= 3) of
        true -> Before = string:substr(Src, (P_2 - 3) + 1, ((P_2 + 1) - (P_2 - 3))),
            case (Before == "func") of
        true -> Skip_2 = true,
            Skip_3 = Skip_2;
        _ -> Skip_3 = Skip
    end,
            Before_2 = Before,
            Skip_4 = Skip_3;
        _ -> Before_2 = nil,
            Skip_4 = Skip
    end,
            case mochi_not(Skip_4) of
        true -> case maps:is_key(Token, Freq) of
        true -> Freq_2 = maps:put(Token, (maps:get(Token, Freq, nil) + 1), Freq),
            Freq_4 = Freq_2,
            Order_3 = Order;
        _ -> Freq_3 = maps:put(Token, 1, Freq),
            Order_2 = lists:append(Order, [Token]),
            Freq_4 = Freq_3,
            Order_3 = Order_2
    end,
            Freq_5 = Freq_4,
            Order_4 = Order_3;
        _ -> Freq_5 = Freq,
            Order_4 = Order
    end,
            Before_3 = Before_2,
            Freq_6 = Freq_5,
            Fun_7 = Fun_6,
            Order_5 = Order_4,
            P_3 = P_2,
            Skip_5 = Skip_4;
        _ -> Before_3 = nil,
            Freq_6 = Freq,
            Fun_7 = Fun_5,
            Order_5 = Order,
            P_3 = nil,
            Skip_5 = nil
    end,
            I_6 = J_4,
            Before_4 = Before_3,
            Freq_7 = Freq_6,
            Fun_8 = Fun_7,
            I_8 = I_6,
            J_5 = J_4,
            K_4 = K_3,
            Order_6 = Order_5,
            P_4 = P_3,
            Skip_6 = Skip_5,
            Token_2 = Token;
        _ -> I_7 = (I_5 + 1),
            Before_4 = nil,
            Freq_7 = Freq,
            Fun_8 = nil,
            I_8 = I_7,
            J_5 = nil,
            K_4 = nil,
            Order_6 = Order,
            P_4 = nil,
            Skip_6 = nil,
            Token_2 = nil
    end,
                Fun_9_loop(Freq_7, I_8, Order_6, Src, SrcLines)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_9_loop(C0, C1, C2, C3, C4);
                break -> {Freq, I_5, Order, Src, SrcLines}
            end;
        _ -> {Freq, I_5, Order, Src, SrcLines}
    end
end,
{Freq_7, I_8, Order_6, Src, SrcLines} = Fun_9(Freq, I_5, Order, Src, SrcLines),
        Pairs = [],
        Fun_10 = fun Fun_10_loop(List, Freq_7, I_8, Order_6, Pairs, Src, SrcLines) ->
    case List of
        [] -> {Freq_7, I_8, Order_6, Pairs, Src, SrcLines};
        [T|T_rest] ->
            Pairs_2 = lists:append(Pairs, [#{"expr" => T, "count" => (case erlang:is_map(Freq_7) of true -> maps:get(T, Freq_7, nil); _ -> lists:nth(T + 1, Freq_7) end)}]),
            Fun_10_loop(T_rest, Freq_7, I_8, Order_6, Pairs_2, Src, SrcLines)
    end
end,
{Freq_7, I_8, Order_6, Pairs_2, Src, SrcLines} = Fun_10(Order_6, Freq_7, I_8, Order_6, Pairs, Src, SrcLines),
        Pairs_3 = sortpairs(Pairs_2),
        Idx = 0,
        Fun_11 = fun Fun_11_loop(Freq_7, I_8, Idx, Order_6, Pairs_3, Src, SrcLines) ->
    case ((Idx < length(Pairs_3)) andalso (Idx < 10)) of
        true ->
            P_5 = (case erlang:is_map(Pairs_3) of true -> maps:get(Idx, Pairs_3, nil); _ -> lists:nth(Idx + 1, Pairs_3) end),
            io:format("~ts~n", [((maps:get("expr", P_5, nil) ++ " ") ++ lists:flatten(io_lib:format("~p", [maps:get("count", P_5, nil)])))]),
            Idx_2 = (Idx + 1),
            Fun_11_loop(Freq_7, I_8, Idx_2, Order_6, Pairs_3, Src, SrcLines);
        _ -> {Freq_7, I_8, Idx, Order_6, Pairs_3, Src, SrcLines}
    end
end,
{Freq_7, I_8, Idx_2, Order_6, Pairs_3, Src, SrcLines} = Fun_11(Freq_7, I_8, Idx, Order_6, Pairs_3, Src, SrcLines),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
