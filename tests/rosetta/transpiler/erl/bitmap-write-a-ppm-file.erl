#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newbitmap/3, setpixel/4, fillrect/6, pad/2, writeppmp3/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (e0c44791e6) on 2025-07-25 18:01 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

newbitmap(W, H, C) ->
    try
        Rows = [],
        Y = 0,
        Fun_2 = fun Fun_2_loop(C, H, Rows, W, Y) ->
    case (Y < H) of
        true ->
            Row = [],
            X = 0,
            Fun = fun Fun_loop(C, H, Row, Rows, W, X, Y) ->
    case (X < W) of
        true ->
            Row_2 = lists:append(Row, [C]),
            X_2 = (X + 1),
            Fun_loop(C, H, Row_2, Rows, W, X_2, Y);
        _ -> {C, H, Row, Rows, W, X, Y}
    end
end,
{C, H, Row_2, Rows, W, X_2, Y} = Fun(C, H, Row, Rows, W, X, Y),
            Rows_2 = lists:append(Rows, [Row_2]),
            Y_2 = (Y + 1),
            Fun_2_loop(C, H, Rows_2, W, Y_2);
        _ -> {C, H, Rows, W, Y}
    end
end,
{C, H, Rows_2, W, Y_2} = Fun_2(C, H, Rows, W, Y),
        #{"width" => W, "height" => H, "pixels" => Rows_2}
    catch {return, Ret} -> Ret end.

setpixel(B, X_3, Y_3, C_2) ->
    try
        Rows_3 = maps:get("pixels", B, nil),
        Row_3 = lists:nth(Y_3 + 1, Rows_3),
        Row_4 = lists:sublist(Row_3, X_3) ++ [C_2] ++ lists:nthtail(X_3 + 1, Row_3),
        Rows_4 = lists:sublist(Rows_3, Y_3) ++ [Row_4] ++ lists:nthtail(Y_3 + 1, Rows_3),
        B_2 = maps:put("pixels", Rows_4, B),
        B_2
    catch {return, Ret} -> Ret end.

fillrect(B_3, X_4, Y_4, W_2, H_2, C_3) ->
    try
        Yy = Y_4,
        Fun_4 = fun Fun_4_loop(B_3, C_3, H_2, W_2, X_4, Y_4, Yy) ->
    case (Yy < (Y_4 + H_2)) of
        true ->
            Xx = X_4,
            Fun_3 = fun Fun_3_loop(B_3, C_3, H_2, W_2, X_4, Xx, Y_4, Yy) ->
    case (Xx < (X_4 + W_2)) of
        true ->
            setpixel(B_3, Xx, Yy, C_3),
            Xx_2 = (Xx + 1),
            Fun_3_loop(B_3, C_3, H_2, W_2, X_4, Xx_2, Y_4, Yy);
        _ -> {B_3, C_3, H_2, W_2, X_4, Xx, Y_4, Yy}
    end
end,
{B_3, C_3, H_2, W_2, X_4, Xx_2, Y_4, Yy} = Fun_3(B_3, C_3, H_2, W_2, X_4, Xx, Y_4, Yy),
            Yy_2 = (Yy + 1),
            Fun_4_loop(B_3, C_3, H_2, W_2, X_4, Y_4, Yy_2);
        _ -> {B_3, C_3, H_2, W_2, X_4, Y_4, Yy}
    end
end,
{B_3, C_3, H_2, W_2, X_4, Y_4, Yy_2} = Fun_4(B_3, C_3, H_2, W_2, X_4, Y_4, Yy),
        nil
    catch {return, Ret} -> Ret end.

pad(N, Width) ->
    try
        S = lists:flatten(io_lib:format("~p", [N])),
        Fun_5 = fun Fun_5_loop(N, S, Width) ->
    case (length(S) < Width) of
        true ->
            S_2 = (" " ++ S),
            Fun_5_loop(N, S_2, Width);
        _ -> {N, S, Width}
    end
end,
{N, S_2, Width} = Fun_5(N, S, Width),
        S_2
    catch {return, Ret} -> Ret end.

writeppmp3(B_4) ->
    try
        Maxv = 0,
        Y_5 = 0,
        Fun_7 = fun Fun_7_loop(B_4, Maxv, Y_5) ->
    case (Y_5 < maps:get("height", B_4, nil)) of
        true ->
            X_5 = 0,
            Fun_6 = fun Fun_6_loop(B_4, Maxv, X_5, Y_5) ->
    case (X_5 < maps:get("width", B_4, nil)) of
        true ->
            P = lists:nth(X_5 + 1, lists:nth(Y_5 + 1, maps:get("pixels", B_4, nil))),
            case (maps:get("R", P, nil) > Maxv) of
        true -> Maxv_2 = maps:get("R", P, nil),
            Maxv_3 = Maxv_2;
        _ -> Maxv_3 = Maxv
    end,
            case (maps:get("G", P, nil) > Maxv_3) of
        true -> Maxv_4 = maps:get("G", P, nil),
            Maxv_5 = Maxv_4;
        _ -> Maxv_5 = Maxv_3
    end,
            case (maps:get("B", P, nil) > Maxv_5) of
        true -> Maxv_6 = maps:get("B", P, nil),
            Maxv_7 = Maxv_6;
        _ -> Maxv_7 = Maxv_5
    end,
            X_6 = (X_5 + 1),
            Fun_6_loop(B_4, Maxv_7, X_6, Y_5);
        _ -> {B_4, Maxv, X_5, Y_5}
    end
end,
{B_4, Maxv_7, X_6, Y_5} = Fun_6(B_4, Maxv, X_5, Y_5),
            Y_6 = (Y_5 + 1),
            Fun_7_loop(B_4, Maxv_7, Y_6);
        _ -> {B_4, Maxv, Y_5}
    end
end,
{B_4, Maxv_7, Y_6} = Fun_7(B_4, Maxv, Y_5),
        Out = (((((("P3\n# generated from Bitmap.writeppmp3\n" ++ lists:flatten(io_lib:format("~p", [maps:get("width", B_4, nil)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [maps:get("height", B_4, nil)]))) ++ "\n") ++ lists:flatten(io_lib:format("~p", [Maxv_7]))) ++ "\n"),
        Numsize = length(lists:flatten(io_lib:format("~p", [Maxv_7]))),
        Y_7 = (maps:get("height", B_4, nil) - 1),
        Fun_9 = fun Fun_9_loop(B_4, Maxv_7, Numsize, Out, Y_7) ->
    case (Y_7 >= 0) of
        true ->
            Line = "",
            X_7 = 0,
            Fun_8 = fun Fun_8_loop(B_4, Line, Maxv_7, Numsize, Out, X_7, Y_7) ->
    case (X_7 < maps:get("width", B_4, nil)) of
        true ->
            P_2 = lists:nth(X_7 + 1, lists:nth(Y_7 + 1, maps:get("pixels", B_4, nil))),
            Line_2 = ((((((Line ++ "   ") ++ pad(maps:get("R", P_2, nil), Numsize)) ++ " ") ++ pad(maps:get("G", P_2, nil), Numsize)) ++ " ") ++ pad(maps:get("B", P_2, nil), Numsize)),
            X_8 = (X_7 + 1),
            Fun_8_loop(B_4, Line_2, Maxv_7, Numsize, Out, X_8, Y_7);
        _ -> {B_4, Line, Maxv_7, Numsize, Out, X_7, Y_7}
    end
end,
{B_4, Line_2, Maxv_7, Numsize, Out, X_8, Y_7} = Fun_8(B_4, Line, Maxv_7, Numsize, Out, X_7, Y_7),
            Out_2 = (Out ++ Line_2),
            case (Y_7 > 0) of
        true -> Out_3 = (Out_2 ++ "\n"),
            Out_5 = Out_3;
        _ -> Out_4 = (Out_2 ++ "\n"),
            Out_5 = Out_4
    end,
            Y_8 = (Y_7 - 1),
            Fun_9_loop(B_4, Maxv_7, Numsize, Out_5, Y_8);
        _ -> {B_4, Maxv_7, Numsize, Out, Y_7}
    end
end,
{B_4, Maxv_7, Numsize, Out_5, Y_8} = Fun_9(B_4, Maxv_7, Numsize, Out, Y_7),
        Out_5
    catch {return, Ret} -> Ret end.

main() ->
    try
        Black = #{"R" => 0, "G" => 0, "B" => 0},
        White = #{"R" => 255, "G" => 255, "B" => 255},
        Bm = newbitmap(4, 4, Black),
        fillrect(Bm, 1, 0, 1, 2, White),
        setpixel(Bm, 3, 3, #{"R" => 127, "G" => 0, "B" => 63}),
        Ppm = writeppmp3(Bm),
        io:format("~p~n", [Ppm]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
