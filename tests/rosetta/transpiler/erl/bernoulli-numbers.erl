#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, bernoulli/1, padstart/3]).

% Generated by Mochi transpiler v0.10.40 (305ff8442f) on 2025-07-25 12:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_pad_start(S, Len, Ch) ->
    Fill0 = case Ch of
        "" -> " ";
        _ -> Ch
    end,
    Fill = string:substr(Fill0, 1, 1),
    SL = length(S),
    case SL >= Len of
        true -> S;
        _ -> string:copies(Fill, Len - SL) ++ S
    end.

bernoulli(N) ->
    try
        A = [],
        M = 0,
        Fun_2 = fun Fun_2_loop(A, M, N) ->
    case (M =< N) of
        true ->
            A_2 = lists:append(A, [(1 / (M + 1))]),
            J = M,
            Fun = fun Fun_loop(A_2, J, M, N) ->
    case (J >= 1) of
        true ->
            A_3 = lists:sublist(A_2, (J - 1)) ++ [(J * (lists:nth((J - 1) + 1, A_2) - lists:nth(J + 1, A_2)))] ++ lists:nthtail((J - 1) + 1, A_2),
            J_2 = (J - 1),
            Fun_loop(A_3, J_2, M, N);
        _ -> {A_2, J, M, N}
    end
end,
{A_3, J_2, M, N} = Fun(A_2, J, M, N),
            M_2 = (M + 1),
            Fun_2_loop(A_3, M_2, N);
        _ -> {A, M, N}
    end
end,
{A_3, M_2, N} = Fun_2(A, M, N),
        lists:nth(0 + 1, A_3)
    catch {return, Ret} -> Ret end.

padstart(S, Width, Pad) ->
    try
        Out = S,
        Fun_3 = fun Fun_3_loop(Out, Pad, S, Width) ->
    case (length(Out) < Width) of
        true ->
            Out_2 = (Pad ++ Out),
            Fun_3_loop(Out_2, Pad, S, Width);
        _ -> {Out, Pad, S, Width}
    end
end,
{Out_2, Pad, S, Width} = Fun_3(Out, Pad, S, Width),
        Out_2
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    Fun_4 = fun Fun_4_loop(List) ->
    case List of
        [] -> {};
        [I|List_rest] ->
            B = bernoulli(I),
            case (num(B) /= 0) of
        true -> NumStr = lists:flatten(io_lib:format("~p", [num(B)])),
            DenStr = lists:flatten(io_lib:format("~p", [denom(B)])),
            io:format("~ts~n", [((((("B(" ++ mochi_pad_start(lists:flatten(io_lib:format("~p", [I])), 2, " ")) ++ ") =") ++ mochi_pad_start(NumStr, 45, " ")) ++ "/") ++ DenStr)]),
            DenStr_2 = DenStr,
            Denom_2 = Denom,
            NumStr_2 = NumStr;
        _ -> DenStr_2 = nil,
            Denom_2 = nil,
            NumStr_2 = nil
    end,
            Fun_4_loop(List_rest)
    end
end,
{} = Fun_4(lists:seq(0, (61) - 1)),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
