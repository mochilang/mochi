#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newlist/0, newnode/2, pushfront/2, pushback/2, insertbefore/3, insertafter/3, main/0]).

% Generated by Mochi transpiler v0.10.47 (eaacde736f) on 2025-07-28 11:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

newlist() ->
    try
        #{"nodes" => #{}, "head" => 0, "tail" => 0, "nextID" => 1}
    catch {return, Ret} -> Ret end.

newnode(L, V) ->
    try
        Id = mochi_to_int(maps:get("nextID", L, nil)),
        L_2 = maps:put("nextID", (Id + 1), L),
        Nodes = maps:get("nodes", L_2, nil),
        N = #{"id" => Id, "value" => V, "next" => 0, "prev" => 0},
        Nodes_2 = maps:put(Id, N, Nodes),
        L_3 = maps:put("nodes", Nodes_2, L_2),
        {N, L_3}
    catch {return, Ret} -> Ret end.

pushfront(L_4, V_2) ->
    try
        {N_2, L_5} = newnode(L_4, V_2),
        N_3 = maps:put("next", maps:get("head", L_5, nil), N_2),
        case (mochi_to_int(maps:get("head", L_5, nil)) /= 0) of
        true -> Nodes_3 = maps:get("nodes", L_5, nil),
            H = maps:get(mochi_to_int(maps:get("head", L_5, nil)), Nodes_3, nil),
            H_2 = maps:put("prev", maps:get("id", N_3, nil), H),
            Nodes_4 = maps:put(mochi_to_int(maps:get("id", H_2, nil)), H_2, Nodes_3),
            L_6 = maps:put("nodes", Nodes_4, L_5),
            H_3 = H_2,
            L_8 = L_6,
            Nodes_5 = Nodes_4;
        _ -> L_7 = maps:put("tail", maps:get("id", N_3, nil), L_5),
            H_3 = nil,
            L_8 = L_7,
            Nodes_5 = nil
    end,
        L_9 = maps:put("head", maps:get("id", N_3, nil), L_8),
        Nodes2 = maps:get("nodes", L_9, nil),
        Nodes2_2 = maps:put(mochi_to_int(maps:get("id", N_3, nil)), N_3, Nodes2),
        L_10 = maps:put("nodes", Nodes2_2, L_9),
        {N_3, L_10}
    catch {return, Ret} -> Ret end.

pushback(L_11, V_3) ->
    try
        {N_4, L_12} = newnode(L_11, V_3),
        N_5 = maps:put("prev", maps:get("tail", L_12, nil), N_4),
        case (mochi_to_int(maps:get("tail", L_12, nil)) /= 0) of
        true -> Nodes_6 = maps:get("nodes", L_12, nil),
            T = maps:get(mochi_to_int(maps:get("tail", L_12, nil)), Nodes_6, nil),
            T_2 = maps:put("next", maps:get("id", N_5, nil), T),
            Nodes_7 = maps:put(mochi_to_int(maps:get("id", T_2, nil)), T_2, Nodes_6),
            L_13 = maps:put("nodes", Nodes_7, L_12),
            L_15 = L_13,
            Nodes_8 = Nodes_7,
            T_3 = T_2;
        _ -> L_14 = maps:put("head", maps:get("id", N_5, nil), L_12),
            L_15 = L_14,
            Nodes_8 = nil,
            T_3 = nil
    end,
        L_16 = maps:put("tail", maps:get("id", N_5, nil), L_15),
        Nodes2_3 = maps:get("nodes", L_16, nil),
        Nodes2_4 = maps:put(mochi_to_int(maps:get("id", N_5, nil)), N_5, Nodes2_3),
        L_17 = maps:put("nodes", Nodes2_4, L_16),
        {N_5, L_17}
    catch {return, Ret} -> Ret end.

insertbefore(L_18, RefID, V_4) ->
    try
        case (RefID == 0) of
        true -> throw({return, pushfront(L_18, V_4)});
        _ -> ok
    end,
        Nodes_9 = maps:get("nodes", L_18, nil),
        Ref = maps:get(RefID, Nodes_9, nil),
        {N_6, L_19} = newnode(L_18, V_4),
        N_7 = maps:put("prev", maps:get("prev", Ref, nil), N_6),
        N_8 = maps:put("next", maps:get("id", Ref, nil), N_7),
        case (mochi_to_int(maps:get("prev", Ref, nil)) /= 0) of
        true -> P = maps:get(mochi_to_int(maps:get("prev", Ref, nil)), Nodes_9, nil),
            P_2 = maps:put("next", maps:get("id", N_8, nil), P),
            Nodes_10 = maps:put(mochi_to_int(maps:get("id", P_2, nil)), P_2, Nodes_9),
            L_21 = L_19,
            Nodes_11 = Nodes_10,
            P_3 = P_2;
        _ -> L_20 = maps:put("head", maps:get("id", N_8, nil), L_19),
            L_21 = L_20,
            Nodes_11 = Nodes_9,
            P_3 = nil
    end,
        Ref_2 = maps:put("prev", maps:get("id", N_8, nil), Ref),
        Nodes_12 = maps:put(RefID, Ref_2, Nodes_11),
        Nodes_13 = maps:put(mochi_to_int(maps:get("id", N_8, nil)), N_8, Nodes_12),
        L_22 = maps:put("nodes", Nodes_13, L_21),
        {N_8, L_22}
    catch {return, Ret} -> Ret end.

insertafter(L_23, RefID_2, V_5) ->
    try
        case (RefID_2 == 0) of
        true -> throw({return, pushback(L_23, V_5)});
        _ -> ok
    end,
        Nodes_14 = maps:get("nodes", L_23, nil),
        Ref_3 = maps:get(RefID_2, Nodes_14, nil),
        {N_9, L_24} = newnode(L_23, V_5),
        N_10 = maps:put("next", maps:get("next", Ref_3, nil), N_9),
        N_11 = maps:put("prev", maps:get("id", Ref_3, nil), N_10),
        case (mochi_to_int(maps:get("next", Ref_3, nil)) /= 0) of
        true -> Nx = maps:get(mochi_to_int(maps:get("next", Ref_3, nil)), Nodes_14, nil),
            Nx_2 = maps:put("prev", maps:get("id", N_11, nil), Nx),
            Nodes_15 = maps:put(mochi_to_int(maps:get("id", Nx_2, nil)), Nx_2, Nodes_14),
            L_26 = L_24,
            Nodes_16 = Nodes_15,
            Nx_3 = Nx_2;
        _ -> L_25 = maps:put("tail", maps:get("id", N_11, nil), L_24),
            L_26 = L_25,
            Nodes_16 = Nodes_14,
            Nx_3 = nil
    end,
        Ref_4 = maps:put("next", maps:get("id", N_11, nil), Ref_3),
        Nodes_17 = maps:put(RefID_2, Ref_4, Nodes_16),
        Nodes_18 = maps:put(mochi_to_int(maps:get("id", N_11, nil)), N_11, Nodes_17),
        L_27 = maps:put("nodes", Nodes_18, L_26),
        {N_11, L_27}
    catch {return, Ret} -> Ret end.

main() ->
    try
        L_28 = newlist(),
        {E4, L_29} = pushback(L_28, 4),
        {E1, L_30} = pushfront(L_29, 1),
        {_, L_31} = insertbefore(L_30, mochi_to_int(maps:get("id", E4, nil)), 3),
        {_, L_32} = insertafter(L_31, mochi_to_int(maps:get("id", E1, nil)), "two"),
        Id_2 = mochi_to_int(maps:get("head", L_32, nil)),
        Nodes_19 = maps:get("nodes", L_32, nil),
        Fun = fun Fun_loop(E1, E4, Id_2, L_32, Nodes_19) ->
    case (Id_2 /= 0) of
        true ->
            Node = maps:get(Id_2, Nodes_19, nil),
            io:format("~ts~n", [lists:flatten(io_lib:format("~p", [maps:get("value", Node, nil)]))]),
            Id_3 = mochi_to_int(maps:get("next", Node, nil)),
            Fun_loop(E1, E4, Id_3, L_32, Nodes_19);
        _ -> {E1, E4, Id_2, L_32, Nodes_19}
    end
end,
{E1, E4, Id_3, L_32, Nodes_19} = Fun(E1, E4, Id_2, L_32, Nodes_19),
        L_32
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
