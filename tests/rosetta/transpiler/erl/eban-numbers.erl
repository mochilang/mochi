#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, ebannumbers/2, counteban/2, main/0]).

% Generated by Mochi transpiler v0.10.47 (eaacde736f) on 2025-07-28 11:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

ebannumbers(Start, Stop) ->
    try
        Nums = [],
        Fun = fun Fun_loop(List, Nums, Start, Stop) ->
    case List of
        [] -> {Nums, Start, Stop};
        [B|B_rest] ->
            Fun_2 = fun Fun_2_loop(List, B, Nums, Start, Stop) ->
    case List of
        [] -> {B, Nums, Start, Stop};
        [M|M_rest] ->
            Fun_3 = fun Fun_3_loop(List, B, M, Nums, Start, Stop) ->
    case List of
        [] -> {B, M, Nums, Start, Stop};
        [T|T_rest] ->
            Fun_4 = fun Fun_4_loop(List, B, M, Nums, Start, Stop, T) ->
    case List of
        [] -> {B, M, Nums, Start, Stop, T};
        [R|R_rest] ->
            N = ((((B * 1000000000) + (M * 1000000)) + (T * 1000)) + R),
            case ((N >= Start) andalso (N =< Stop)) of
        true -> Nums_2 = lists:append(Nums, [N]),
            Nums_3 = Nums_2;
        _ -> Nums_3 = Nums
    end,
            Fun_4_loop(R_rest, B, M, Nums_3, Start, Stop, T)
    end
end,
{B, M, Nums_3, Start, Stop, T} = Fun_4(erlang:get('vals'), B, M, Nums, Start, Stop, T),
            Fun_3_loop(T_rest, B, M, Nums_3, Start, Stop)
    end
end,
{B, M, Nums_3, Start, Stop} = Fun_3(erlang:get('vals'), B, M, Nums, Start, Stop),
            Fun_2_loop(M_rest, B, Nums_3, Start, Stop)
    end
end,
{B, Nums_3, Start, Stop} = Fun_2(erlang:get('vals'), B, Nums, Start, Stop),
            Fun_loop(B_rest, Nums_3, Start, Stop)
    end
end,
{Nums_3, Start, Stop} = Fun(erlang:get('billions'), Nums, Start, Stop),
        Nums_3
    catch {return, Ret} -> Ret end.

counteban(Start_2, Stop_2) ->
    try
        Count = 0,
        Fun_5 = fun Fun_5_loop(List, Count, Start_2, Stop_2) ->
    case List of
        [] -> {Count, Start_2, Stop_2};
        [B_2|B_2_rest] ->
            Fun_6 = fun Fun_6_loop(List, B_2, Count, Start_2, Stop_2) ->
    case List of
        [] -> {B_2, Count, Start_2, Stop_2};
        [M_2|M_2_rest] ->
            Fun_7 = fun Fun_7_loop(List, B_2, Count, M_2, Start_2, Stop_2) ->
    case List of
        [] -> {B_2, Count, M_2, Start_2, Stop_2};
        [T_2|T_2_rest] ->
            Fun_8 = fun Fun_8_loop(List, B_2, Count, M_2, Start_2, Stop_2, T_2) ->
    case List of
        [] -> {B_2, Count, M_2, Start_2, Stop_2, T_2};
        [R_2|R_2_rest] ->
            N_2 = ((((B_2 * 1000000000) + (M_2 * 1000000)) + (T_2 * 1000)) + R_2),
            case ((N_2 >= Start_2) andalso (N_2 =< Stop_2)) of
        true -> Count_2 = (Count + 1),
            Count_3 = Count_2;
        _ -> Count_3 = Count
    end,
            Fun_8_loop(R_2_rest, B_2, Count_3, M_2, Start_2, Stop_2, T_2)
    end
end,
{B_2, Count_3, M_2, Start_2, Stop_2, T_2} = Fun_8(erlang:get('vals'), B_2, Count, M_2, Start_2, Stop_2, T_2),
            Fun_7_loop(T_2_rest, B_2, Count_3, M_2, Start_2, Stop_2)
    end
end,
{B_2, Count_3, M_2, Start_2, Stop_2} = Fun_7(erlang:get('vals'), B_2, Count, M_2, Start_2, Stop_2),
            Fun_6_loop(M_2_rest, B_2, Count_3, Start_2, Stop_2)
    end
end,
{B_2, Count_3, Start_2, Stop_2} = Fun_6(erlang:get('vals'), B_2, Count, Start_2, Stop_2),
            Fun_5_loop(B_2_rest, Count_3, Start_2, Stop_2)
    end
end,
{Count_3, Start_2, Stop_2} = Fun_5(erlang:get('billions'), Count, Start_2, Stop_2),
        Count_3
    catch {return, Ret} -> Ret end.

main() ->
    try
        Ranges = [[2, 1000, true], [1000, 4000, true], [2, 10000, false], [2, 100000, false], [2, 1000000, false], [2, 10000000, false], [2, 100000000, false], [2, 1000000000, false]],
        Fun_9 = fun Fun_9_loop(List, Ranges) ->
    case List of
        [] -> {Ranges};
        [Rg|Rg_rest] ->
            Start_3 = mochi_to_int(lists:nth(0 + 1, Rg)),
            Stop_3 = mochi_to_int(lists:nth(1 + 1, Rg)),
            Show = lists:nth(2 + 1, Rg),
            case (Start_3 == 2) of
        true -> io:format("~ts~n", [(("eban numbers up to and including " ++ lists:flatten(io_lib:format("~p", [Stop_3]))) ++ ":")]);
        _ -> io:format("~ts~n", [(((("eban numbers between " ++ lists:flatten(io_lib:format("~p", [Start_3]))) ++ " and ") ++ lists:flatten(io_lib:format("~p", [Stop_3]))) ++ " (inclusive):")])
    end,
            case (Show /= nil) of
        true -> Nums_4 = ebannumbers(Start_3, Stop_3),
            Line = "",
            I = 0,
            Fun_10 = fun Fun_10_loop(I, Line, Nums_4, Ranges, Rg, Show, Start_3, Stop_3) ->
    case (I < length(Nums_4)) of
        true ->
            Line_2 = ((Line ++ lists:flatten(io_lib:format("~p", [lists:nth(I + 1, Nums_4)]))) ++ " "),
            I_2 = (I + 1),
            Fun_10_loop(I_2, Line_2, Nums_4, Ranges, Rg, Show, Start_3, Stop_3);
        _ -> {I, Line, Nums_4, Ranges, Rg, Show, Start_3, Stop_3}
    end
end,
{I_2, Line_2, Nums_4, Ranges, Rg, Show, Start_3, Stop_3} = Fun_10(I, Line, Nums_4, Ranges, Rg, Show, Start_3, Stop_3),
            case (length(Line_2) > 0) of
        true -> io:format("~ts~n", [string:substr(Line_2, 0 + 1, ((length(Line_2) - 1) - 0))]);
        _ -> ok
    end,
            Fun_11 = Fun_10,
            I_3 = I_2,
            Line_3 = Line_2,
            Nums_5 = Nums_4;
        _ -> Fun_11 = nil,
            I_3 = nil,
            Line_3 = nil,
            Nums_5 = nil
    end,
            C = counteban(Start_3, Stop_3),
            io:format("~ts~n", [(("count = " ++ lists:flatten(io_lib:format("~p", [C]))) ++ "\n")]),
            Fun_9_loop(Rg_rest, Ranges)
    end
end,
{Ranges} = Fun_9(Ranges, Ranges),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('vals', [0, 2, 4, 6, 30, 32, 34, 36, 40, 42, 44, 46, 50, 52, 54, 56, 60, 62, 64, 66]),
    erlang:put('billions', [0, 2, 4, 6]),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
