#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newboard/0, spawntile/1, pad/1, draw/2, reverserow/1, slideleft/1, moveleft/2, moveright/2, getcol/2, setcol/3, moveup/2, movedown/2, hasmoves/1, has2048/1]).

% Generated by Mochi transpiler v0.10.40 (6bb4e4bd23) on 2025-07-25 19:02 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

newboard() ->
    try
        B = [],
        Y = 0,
        Fun_2 = fun Fun_2_loop(B, Y) ->
    case (Y < 4) of
        true ->
            Row = [],
            X = 0,
            Fun = fun Fun_loop(B, Row, X, Y) ->
    case (X < 4) of
        true ->
            Row_2 = lists:append(Row, [0]),
            X_2 = (X + 1),
            Fun_loop(B, Row_2, X_2, Y);
        _ -> {B, Row, X, Y}
    end
end,
{B, Row_2, X_2, Y} = Fun(B, Row, X, Y),
            B_2 = lists:append(B, [Row_2]),
            Y_2 = (Y + 1),
            Fun_2_loop(B_2, Y_2);
        _ -> {B, Y}
    end
end,
{B_2, Y_2} = Fun_2(B, Y),
        #{"cells" => B_2}
    catch {return, Ret} -> Ret end.

spawntile(B_3) ->
    try
        Grid = maps:get("cells", B_3, nil),
        Empty = [],
        Y_3 = 0,
        Fun_4 = fun Fun_4_loop(B_3, Empty, Grid, Y_3) ->
    case (Y_3 < 4) of
        true ->
            X_3 = 0,
            Fun_3 = fun Fun_3_loop(B_3, Empty, Grid, X_3, Y_3) ->
    case (X_3 < 4) of
        true ->
            case (lists:nth(X_3 + 1, lists:nth(Y_3 + 1, Grid)) == 0) of
        true -> Empty_2 = lists:append(Empty, [[X_3, Y_3]]),
            Empty_3 = Empty_2;
        _ -> Empty_3 = Empty
    end,
            X_4 = (X_3 + 1),
            Fun_3_loop(B_3, Empty_3, Grid, X_4, Y_3);
        _ -> {B_3, Empty, Grid, X_3, Y_3}
    end
end,
{B_3, Empty_3, Grid, X_4, Y_3} = Fun_3(B_3, Empty, Grid, X_3, Y_3),
            Y_4 = (Y_3 + 1),
            Fun_4_loop(B_3, Empty_3, Grid, Y_4);
        _ -> {B_3, Empty, Grid, Y_3}
    end
end,
{B_3, Empty_3, Grid, Y_4} = Fun_4(B_3, Empty, Grid, Y_3),
        case (length(Empty_3) == 0) of
        true -> throw({return, #{"board" => B_3, "full" => true}});
        _ -> ok
    end,
        Idx = (mochi_now() rem length(Empty_3)),
        Cell = lists:nth(Idx + 1, Empty_3),
        Val = 4,
        case ((mochi_now() rem 10) < 9) of
        true -> Val_2 = 2,
            Val_3 = Val_2;
        _ -> Val_3 = Val
    end,
        Tmp = lists:nth(lists:nth(1 + 1, Cell) + 1, Grid),
        Tmp_2 = lists:sublist(Tmp, lists:nth(0 + 1, Cell)) ++ [Val_3] ++ lists:nthtail(lists:nth(0 + 1, Cell) + 1, Tmp),
        Grid_2 = lists:sublist(Grid, lists:nth(1 + 1, Cell)) ++ [Tmp_2] ++ lists:nthtail(lists:nth(1 + 1, Cell) + 1, Grid),
        #{"board" => #{"cells" => Grid_2}, "full" => (length(Empty_3) == 1)}
    catch {return, Ret} -> Ret end.

pad(N) ->
    try
        S = lists:flatten(io_lib:format("~p", [N])),
        Pad = (4 - length(S)),
        I = 0,
        Out = "",
        Fun_5 = fun Fun_5_loop(I, N, Out, Pad, S) ->
    case (I < Pad) of
        true ->
            Out_2 = (Out ++ " "),
            I_2 = (I + 1),
            Fun_5_loop(I_2, N, Out_2, Pad, S);
        _ -> {I, N, Out, Pad, S}
    end
end,
{I_2, N, Out_2, Pad, S} = Fun_5(I, N, Out, Pad, S),
        (Out_2 ++ S)
    catch {return, Ret} -> Ret end.

draw(B_4, Score) ->
    try
        io:format("~ts~n", [("Score: " ++ lists:flatten(io_lib:format("~p", [Score])))]),
        Y_5 = 0,
        Fun_7 = fun Fun_7_loop(B_4, Score, Y_5) ->
    case (Y_5 < 4) of
        true ->
            io:format("~ts~n", ["+----+----+----+----+"]),
            Line = "|",
            X_5 = 0,
            Fun_6 = fun Fun_6_loop(B_4, Line, Score, X_5, Y_5) ->
    case (X_5 < 4) of
        true ->
            V = lists:nth(X_5 + 1, lists:nth(Y_5 + 1, maps:get("cells", B_4, nil))),
            case (V == 0) of
        true -> Line_2 = (Line ++ "    |"),
            Line_4 = Line_2;
        _ -> Line_3 = ((Line ++ pad(V)) ++ "|"),
            Line_4 = Line_3
    end,
            X_6 = (X_5 + 1),
            Fun_6_loop(B_4, Line_4, Score, X_6, Y_5);
        _ -> {B_4, Line, Score, X_5, Y_5}
    end
end,
{B_4, Line_4, Score, X_6, Y_5} = Fun_6(B_4, Line, Score, X_5, Y_5),
            io:format("~ts~n", [Line_4]),
            Y_6 = (Y_5 + 1),
            Fun_7_loop(B_4, Score, Y_6);
        _ -> {B_4, Score, Y_5}
    end
end,
{B_4, Score, Y_6} = Fun_7(B_4, Score, Y_5),
        io:format("~ts~n", ["+----+----+----+----+"]),
        io:format("~ts~n", ["W=Up S=Down A=Left D=Right Q=Quit"]),
        nil
    catch {return, Ret} -> Ret end.

reverserow(R) ->
    try
        Out_3 = [],
        I_3 = (length(R) - 1),
        Fun_8 = fun Fun_8_loop(I_3, Out_3, R) ->
    case (I_3 >= 0) of
        true ->
            Out_4 = lists:append(Out_3, [lists:nth(I_3 + 1, R)]),
            I_4 = (I_3 - 1),
            Fun_8_loop(I_4, Out_4, R);
        _ -> {I_3, Out_3, R}
    end
end,
{I_4, Out_4, R} = Fun_8(I_3, Out_3, R),
        Out_4
    catch {return, Ret} -> Ret end.

slideleft(Row_3) ->
    try
        Xs = [],
        I_5 = 0,
        Fun_9 = fun Fun_9_loop(I_5, Row_3, Xs) ->
    case (I_5 < length(Row_3)) of
        true ->
            case (lists:nth(I_5 + 1, Row_3) /= 0) of
        true -> Xs_2 = lists:append(Xs, [lists:nth(I_5 + 1, Row_3)]),
            Xs_3 = Xs_2;
        _ -> Xs_3 = Xs
    end,
            I_6 = (I_5 + 1),
            Fun_9_loop(I_6, Row_3, Xs_3);
        _ -> {I_5, Row_3, Xs}
    end
end,
{I_6, Row_3, Xs_3} = Fun_9(I_5, Row_3, Xs),
        Res = [],
        Gain = 0,
        I_7 = 0,
        Fun_10 = fun Fun_10_loop(Gain, I_7, Res, Row_3, Xs_3) ->
    case (I_7 < length(Xs_3)) of
        true ->
            case (((I_7 + 1) < length(Xs_3)) andalso (lists:nth(I_7 + 1, Xs_3) == lists:nth((I_7 + 1) + 1, Xs_3))) of
        true -> V_2 = (lists:nth(I_7 + 1, Xs_3) * 2),
            Gain_2 = (Gain + V_2),
            Res_2 = lists:append(Res, [V_2]),
            I_8 = (I_7 + 2),
            Gain_3 = Gain_2,
            I_10 = I_8,
            Res_4 = Res_2,
            V_3 = V_2;
        _ -> Res_3 = lists:append(Res, [lists:nth(I_7 + 1, Xs_3)]),
            I_9 = (I_7 + 1),
            Gain_3 = Gain,
            I_10 = I_9,
            Res_4 = Res_3,
            V_3 = nil
    end,
            Fun_10_loop(Gain_3, I_10, Res_4, Row_3, Xs_3);
        _ -> {Gain, I_7, Res, Row_3, Xs_3}
    end
end,
{Gain_3, I_10, Res_4, Row_3, Xs_3} = Fun_10(Gain, I_7, Res, Row_3, Xs_3),
        Fun_11 = fun Fun_11_loop(Gain_3, I_10, Res_4, Row_3, Xs_3) ->
    case (length(Res_4) < 4) of
        true ->
            Res_5 = lists:append(Res_4, [0]),
            Fun_11_loop(Gain_3, I_10, Res_5, Row_3, Xs_3);
        _ -> {Gain_3, I_10, Res_4, Row_3, Xs_3}
    end
end,
{Gain_3, I_10, Res_5, Row_3, Xs_3} = Fun_11(Gain_3, I_10, Res_4, Row_3, Xs_3),
        #{"row" => Res_5, "gain" => Gain_3}
    catch {return, Ret} -> Ret end.

moveleft(B_5, Score_2) ->
    try
        Grid_3 = maps:get("cells", B_5, nil),
        Moved = false,
        Y_7 = 0,
        Fun_13 = fun Fun_13_loop(B_5, Grid_3, Moved, Score_2, Y_7) ->
    case (Y_7 < 4) of
        true ->
            R_2 = slideleft(lists:nth(Y_7 + 1, Grid_3)),
            New = maps:get("row", R_2, nil),
            Score_3 = (Score_2 + maps:get("gain", R_2, nil)),
            X_7 = 0,
            Fun_12 = fun Fun_12_loop(B_5, Grid_3, Moved, New, R_2, Score_3, X_7, Y_7) ->
    case (X_7 < 4) of
        true ->
            case (lists:nth(X_7 + 1, lists:nth(Y_7 + 1, Grid_3)) /= lists:nth(X_7 + 1, New)) of
        true -> Moved_2 = true,
            Moved_3 = Moved_2;
        _ -> Moved_3 = Moved
    end,
            Tmp_3 = lists:nth(Y_7 + 1, Grid_3),
            Tmp_4 = lists:sublist(Tmp_3, X_7) ++ [lists:nth(X_7 + 1, New)] ++ lists:nthtail(X_7 + 1, Tmp_3),
            Grid_4 = lists:sublist(Grid_3, Y_7) ++ [Tmp_4] ++ lists:nthtail(Y_7 + 1, Grid_3),
            X_8 = (X_7 + 1),
            Fun_12_loop(B_5, Grid_4, Moved_3, New, R_2, Score_3, X_8, Y_7);
        _ -> {B_5, Grid_3, Moved, New, R_2, Score_3, X_7, Y_7}
    end
end,
{B_5, Grid_4, Moved_3, New, R_2, Score_3, X_8, Y_7} = Fun_12(B_5, Grid_3, Moved, New, R_2, Score_3, X_7, Y_7),
            Y_8 = (Y_7 + 1),
            Fun_13_loop(B_5, Grid_4, Moved_3, Score_3, Y_8);
        _ -> {B_5, Grid_3, Moved, Score_2, Y_7}
    end
end,
{B_5, Grid_4, Moved_3, Score_3, Y_8} = Fun_13(B_5, Grid_3, Moved, Score_2, Y_7),
        #{"board" => #{"cells" => Grid_4}, "score" => Score_3, "moved" => Moved_3}
    catch {return, Ret} -> Ret end.

moveright(B_6, Score_4) ->
    try
        Grid_5 = maps:get("cells", B_6, nil),
        Moved_4 = false,
        Y_9 = 0,
        Fun_15 = fun Fun_15_loop(B_6, Grid_5, Moved_4, Score_4, Y_9) ->
    case (Y_9 < 4) of
        true ->
            Rev = reverserow(lists:nth(Y_9 + 1, Grid_5)),
            R_3 = slideleft(Rev),
            Rev_2 = maps:get("row", R_3, nil),
            Score_5 = (Score_4 + maps:get("gain", R_3, nil)),
            Rev_3 = reverserow(Rev_2),
            X_9 = 0,
            Fun_14 = fun Fun_14_loop(B_6, Grid_5, Moved_4, R_3, Rev_3, Score_5, X_9, Y_9) ->
    case (X_9 < 4) of
        true ->
            case (lists:nth(X_9 + 1, lists:nth(Y_9 + 1, Grid_5)) /= lists:nth(X_9 + 1, Rev_3)) of
        true -> Moved_5 = true,
            Moved_6 = Moved_5;
        _ -> Moved_6 = Moved_4
    end,
            Tmp_5 = lists:nth(Y_9 + 1, Grid_5),
            Tmp_6 = lists:sublist(Tmp_5, X_9) ++ [lists:nth(X_9 + 1, Rev_3)] ++ lists:nthtail(X_9 + 1, Tmp_5),
            Grid_6 = lists:sublist(Grid_5, Y_9) ++ [Tmp_6] ++ lists:nthtail(Y_9 + 1, Grid_5),
            X_10 = (X_9 + 1),
            Fun_14_loop(B_6, Grid_6, Moved_6, R_3, Rev_3, Score_5, X_10, Y_9);
        _ -> {B_6, Grid_5, Moved_4, R_3, Rev_3, Score_5, X_9, Y_9}
    end
end,
{B_6, Grid_6, Moved_6, R_3, Rev_3, Score_5, X_10, Y_9} = Fun_14(B_6, Grid_5, Moved_4, R_3, Rev_3, Score_5, X_9, Y_9),
            Y_10 = (Y_9 + 1),
            Fun_15_loop(B_6, Grid_6, Moved_6, Score_5, Y_10);
        _ -> {B_6, Grid_5, Moved_4, Score_4, Y_9}
    end
end,
{B_6, Grid_6, Moved_6, Score_5, Y_10} = Fun_15(B_6, Grid_5, Moved_4, Score_4, Y_9),
        #{"board" => #{"cells" => Grid_6}, "score" => Score_5, "moved" => Moved_6}
    catch {return, Ret} -> Ret end.

getcol(B_7, X_11) ->
    try
        Col = [],
        Y_11 = 0,
        Fun_16 = fun Fun_16_loop(B_7, Col, X_11, Y_11) ->
    case (Y_11 < 4) of
        true ->
            Col_2 = lists:append(Col, [lists:nth(X_11 + 1, lists:nth(Y_11 + 1, maps:get("cells", B_7, nil)))]),
            Y_12 = (Y_11 + 1),
            Fun_16_loop(B_7, Col_2, X_11, Y_12);
        _ -> {B_7, Col, X_11, Y_11}
    end
end,
{B_7, Col_2, X_11, Y_12} = Fun_16(B_7, Col, X_11, Y_11),
        Col_2
    catch {return, Ret} -> Ret end.

setcol(B_8, X_12, Col_3) ->
    try
        Rows = maps:get("cells", B_8, nil),
        Y_13 = 0,
        Fun_17 = fun Fun_17_loop(B_8, Col_3, Rows, X_12, Y_13) ->
    case (Y_13 < 4) of
        true ->
            Row_4 = lists:nth(Y_13 + 1, Rows),
            Row_5 = lists:sublist(Row_4, X_12) ++ [lists:nth(Y_13 + 1, Col_3)] ++ lists:nthtail(X_12 + 1, Row_4),
            Rows_2 = lists:sublist(Rows, Y_13) ++ [Row_5] ++ lists:nthtail(Y_13 + 1, Rows),
            Y_14 = (Y_13 + 1),
            Fun_17_loop(B_8, Col_3, Rows_2, X_12, Y_14);
        _ -> {B_8, Col_3, Rows, X_12, Y_13}
    end
end,
{B_8, Col_3, Rows_2, X_12, Y_14} = Fun_17(B_8, Col_3, Rows, X_12, Y_13),
        B_9 = maps:put("cells", Rows_2, B_8),
        B_9
    catch {return, Ret} -> Ret end.

moveup(B_10, Score_6) ->
    try
        Grid_7 = maps:get("cells", B_10, nil),
        Moved_7 = false,
        X_13 = 0,
        Fun_19 = fun Fun_19_loop(B_10, Grid_7, Moved_7, Score_6, X_13) ->
    case (X_13 < 4) of
        true ->
            Col_4 = getcol(B_10, X_13),
            R_4 = slideleft(Col_4),
            New_2 = maps:get("row", R_4, nil),
            Score_7 = (Score_6 + maps:get("gain", R_4, nil)),
            Y_15 = 0,
            Fun_18 = fun Fun_18_loop(B_10, Col_4, Grid_7, Moved_7, New_2, R_4, Score_7, X_13, Y_15) ->
    case (Y_15 < 4) of
        true ->
            case (lists:nth(X_13 + 1, lists:nth(Y_15 + 1, Grid_7)) /= lists:nth(Y_15 + 1, New_2)) of
        true -> Moved_8 = true,
            Moved_9 = Moved_8;
        _ -> Moved_9 = Moved_7
    end,
            Tmp_7 = lists:nth(Y_15 + 1, Grid_7),
            Tmp_8 = lists:sublist(Tmp_7, X_13) ++ [lists:nth(Y_15 + 1, New_2)] ++ lists:nthtail(X_13 + 1, Tmp_7),
            Grid_8 = lists:sublist(Grid_7, Y_15) ++ [Tmp_8] ++ lists:nthtail(Y_15 + 1, Grid_7),
            Y_16 = (Y_15 + 1),
            Fun_18_loop(B_10, Col_4, Grid_8, Moved_9, New_2, R_4, Score_7, X_13, Y_16);
        _ -> {B_10, Col_4, Grid_7, Moved_7, New_2, R_4, Score_7, X_13, Y_15}
    end
end,
{B_10, Col_4, Grid_8, Moved_9, New_2, R_4, Score_7, X_13, Y_16} = Fun_18(B_10, Col_4, Grid_7, Moved_7, New_2, R_4, Score_7, X_13, Y_15),
            X_14 = (X_13 + 1),
            Fun_19_loop(B_10, Grid_8, Moved_9, Score_7, X_14);
        _ -> {B_10, Grid_7, Moved_7, Score_6, X_13}
    end
end,
{B_10, Grid_8, Moved_9, Score_7, X_14} = Fun_19(B_10, Grid_7, Moved_7, Score_6, X_13),
        #{"board" => #{"cells" => Grid_8}, "score" => Score_7, "moved" => Moved_9}
    catch {return, Ret} -> Ret end.

movedown(B_11, Score_8) ->
    try
        Grid_9 = maps:get("cells", B_11, nil),
        Moved_10 = false,
        X_15 = 0,
        Fun_21 = fun Fun_21_loop(B_11, Grid_9, Moved_10, Score_8, X_15) ->
    case (X_15 < 4) of
        true ->
            Col_5 = reverserow(getcol(B_11, X_15)),
            R_5 = slideleft(Col_5),
            Col_6 = maps:get("row", R_5, nil),
            Score_9 = (Score_8 + maps:get("gain", R_5, nil)),
            Col_7 = reverserow(Col_6),
            Y_17 = 0,
            Fun_20 = fun Fun_20_loop(B_11, Col_7, Grid_9, Moved_10, R_5, Score_9, X_15, Y_17) ->
    case (Y_17 < 4) of
        true ->
            case (lists:nth(X_15 + 1, lists:nth(Y_17 + 1, Grid_9)) /= lists:nth(Y_17 + 1, Col_7)) of
        true -> Moved_11 = true,
            Moved_12 = Moved_11;
        _ -> Moved_12 = Moved_10
    end,
            Tmp_9 = lists:nth(Y_17 + 1, Grid_9),
            Tmp_10 = lists:sublist(Tmp_9, X_15) ++ [lists:nth(Y_17 + 1, Col_7)] ++ lists:nthtail(X_15 + 1, Tmp_9),
            Grid_10 = lists:sublist(Grid_9, Y_17) ++ [Tmp_10] ++ lists:nthtail(Y_17 + 1, Grid_9),
            Y_18 = (Y_17 + 1),
            Fun_20_loop(B_11, Col_7, Grid_10, Moved_12, R_5, Score_9, X_15, Y_18);
        _ -> {B_11, Col_7, Grid_9, Moved_10, R_5, Score_9, X_15, Y_17}
    end
end,
{B_11, Col_7, Grid_10, Moved_12, R_5, Score_9, X_15, Y_18} = Fun_20(B_11, Col_7, Grid_9, Moved_10, R_5, Score_9, X_15, Y_17),
            X_16 = (X_15 + 1),
            Fun_21_loop(B_11, Grid_10, Moved_12, Score_9, X_16);
        _ -> {B_11, Grid_9, Moved_10, Score_8, X_15}
    end
end,
{B_11, Grid_10, Moved_12, Score_9, X_16} = Fun_21(B_11, Grid_9, Moved_10, Score_8, X_15),
        #{"board" => #{"cells" => Grid_10}, "score" => Score_9, "moved" => Moved_12}
    catch {return, Ret} -> Ret end.

hasmoves(B_12) ->
    try
        Y_19 = 0,
        Fun_23 = fun Fun_23_loop(B_12, Y_19) ->
    case (Y_19 < 4) of
        true ->
            X_17 = 0,
            Fun_22 = fun Fun_22_loop(B_12, X_17, Y_19) ->
    case (X_17 < 4) of
        true ->
            case (lists:nth(X_17 + 1, lists:nth(Y_19 + 1, maps:get("cells", B_12, nil))) == 0) of
        true -> throw({return, true});
        _ -> ok
    end,
            case (((X_17 + 1) < 4) andalso (lists:nth(X_17 + 1, lists:nth(Y_19 + 1, maps:get("cells", B_12, nil))) == lists:nth((X_17 + 1) + 1, lists:nth(Y_19 + 1, maps:get("cells", B_12, nil))))) of
        true -> throw({return, true});
        _ -> ok
    end,
            case (((Y_19 + 1) < 4) andalso (lists:nth(X_17 + 1, lists:nth(Y_19 + 1, maps:get("cells", B_12, nil))) == lists:nth(X_17 + 1, lists:nth((Y_19 + 1) + 1, maps:get("cells", B_12, nil))))) of
        true -> throw({return, true});
        _ -> ok
    end,
            X_18 = (X_17 + 1),
            Fun_22_loop(B_12, X_18, Y_19);
        _ -> {B_12, X_17, Y_19}
    end
end,
{B_12, X_18, Y_19} = Fun_22(B_12, X_17, Y_19),
            Y_20 = (Y_19 + 1),
            Fun_23_loop(B_12, Y_20);
        _ -> {B_12, Y_19}
    end
end,
{B_12, Y_20} = Fun_23(B_12, Y_19),
        false
    catch {return, Ret} -> Ret end.

has2048(B_13) ->
    try
        Y_21 = 0,
        Fun_25 = fun Fun_25_loop(B_13, Y_21) ->
    case (Y_21 < 4) of
        true ->
            X_19 = 0,
            Fun_24 = fun Fun_24_loop(B_13, X_19, Y_21) ->
    case (X_19 < 4) of
        true ->
            case (lists:nth(X_19 + 1, lists:nth(Y_21 + 1, maps:get("cells", B_13, nil))) >= 2048) of
        true -> throw({return, true});
        _ -> ok
    end,
            X_20 = (X_19 + 1),
            Fun_24_loop(B_13, X_20, Y_21);
        _ -> {B_13, X_19, Y_21}
    end
end,
{B_13, X_20, Y_21} = Fun_24(B_13, X_19, Y_21),
            Y_22 = (Y_21 + 1),
            Fun_25_loop(B_13, Y_22);
        _ -> {B_13, Y_21}
    end
end,
{B_13, Y_22} = Fun_25(B_13, Y_21),
        false
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('SIZE', 4),
    erlang:put('board', newboard()),
    erlang:put('r', spawntile(erlang:get('board'))),
    erlang:put('board', maps:get("board", erlang:get('r'), nil)),
    erlang:put('full', maps:get("full", erlang:get('r'), nil)),
    erlang:put('r', spawntile(erlang:get('board'))),
    erlang:put('board', maps:get("board", erlang:get('r'), nil)),
    erlang:put('full', maps:get("full", erlang:get('r'), nil)),
    erlang:put('score', 0),
    draw(erlang:get('board'), erlang:get('score')),
    Fun_26 = fun Fun_26_loop() ->
    case true of
        true ->
            try
                io:format("~ts~n", ["Move: "]),
                Cmd = (case io:get_line("") of eof -> "q"; L -> string:trim(L) end),
                Moved_13 = false,
                case ((Cmd == "a") orelse (Cmd == "A")) of
        true -> M = moveleft(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M, nil)),
            erlang:put('score', maps:get("score", M, nil)),
            Moved_14 = maps:get("moved", M, nil),
            M_2 = M,
            Moved_15 = Moved_14;
        _ -> M_2 = nil,
            Moved_15 = Moved_13
    end,
                case ((Cmd == "d") orelse (Cmd == "D")) of
        true -> M_3 = moveright(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M_3, nil)),
            erlang:put('score', maps:get("score", M_3, nil)),
            Moved_16 = maps:get("moved", M_3, nil),
            M_4 = M_3,
            Moved_17 = Moved_16;
        _ -> M_4 = M_2,
            Moved_17 = Moved_15
    end,
                case ((Cmd == "w") orelse (Cmd == "W")) of
        true -> M_5 = moveup(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M_5, nil)),
            erlang:put('score', maps:get("score", M_5, nil)),
            Moved_18 = maps:get("moved", M_5, nil),
            M_6 = M_5,
            Moved_19 = Moved_18;
        _ -> M_6 = M_4,
            Moved_19 = Moved_17
    end,
                case ((Cmd == "s") orelse (Cmd == "S")) of
        true -> M_7 = movedown(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M_7, nil)),
            erlang:put('score', maps:get("score", M_7, nil)),
            Moved_20 = maps:get("moved", M_7, nil),
            M_8 = M_7,
            Moved_21 = Moved_20;
        _ -> M_8 = M_6,
            Moved_21 = Moved_19
    end,
                case ((Cmd == "q") orelse (Cmd == "Q")) of
        true -> throw(break);
        _ -> ok
    end,
                case Moved_21 of
        true -> R2 = spawntile(erlang:get('board')),
            erlang:put('board', maps:get("board", R2, nil)),
            erlang:put('full', maps:get("full", R2, nil)),
            case (erlang:get('full') andalso not hasmoves(erlang:get('board'))) of
        true -> draw(erlang:get('board'), erlang:get('score')),
            io:format("~ts~n", ["Game Over"]),
            throw(break);
        _ -> ok
    end,
            R2_2 = R2;
        _ -> R2_2 = nil
    end,
                draw(erlang:get('board'), erlang:get('score')),
                case has2048(erlang:get('board')) of
        true -> io:format("~ts~n", ["You win!"]),
            throw(break);
        _ -> ok
    end,
                case not hasmoves(erlang:get('board')) of
        true -> io:format("~ts~n", ["Game Over"]),
            throw(break);
        _ -> ok
    end,
                Fun_26_loop()
            catch
                {continue} -> Fun_26_loop();
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun_26(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
