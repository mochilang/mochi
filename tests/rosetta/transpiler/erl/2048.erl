#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newBoard/0, spawnTile/1, pad/1, draw/2, reverseRow/1, slideLeft/1, moveLeft/2, moveRight/2, getCol/2, setCol/3, moveUp/2, moveDown/2, hasMoves/1, has2048/1]).

% Generated by Mochi transpiler v0.10.38 (b27d72d2c5) on 2025-07-24 00:44 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

newBoard() ->
    try
        B = [],
        Y = 0,
        Fun_2 = fun Fun_2_loop(B, Y) ->
    case (Y < 4) of
        true ->
            try
                Row = [],
                X = 0,
                Fun = fun Fun_loop(B, Row, X, Y) ->
    case (X < erlang:get('SIZE')) of
        true ->
            try
                Row_2 = lists:append(Row, [0]),
                X_2 = (X + 1),
                Fun_loop(B, Row_2, X_2, Y)
            catch
                continue -> Fun_loop(B, Row, X, Y);
                break -> {B, Row, X, Y}
            end;
        _ -> {B, Row, X, Y}
    end
end,
{B, Row_2, X_2, Y} = Fun(B, Row, X, Y),
                B_2 = lists:append(B, [Row_2]),
                Y_2 = (Y + 1),
                Fun_2_loop(B_2, Y_2)
            catch
                continue -> Fun_2_loop(B, Y);
                break -> {B, Y}
            end;
        _ -> {B, Y}
    end
end,
{B_2, Y_2} = Fun_2(B, Y),
        #{"cells" => B_2}
    catch {return, V} -> V end.

spawnTile(B_3) ->
    try
        Grid = maps:get("cells", B_3),
        Empty = [],
        Y_3 = 0,
        Fun_4 = fun Fun_4_loop(B_3, Empty, Grid, Y_3) ->
    case (Y_3 < 4) of
        true ->
            try
                X_3 = 0,
                Fun_3 = fun Fun_3_loop(B_3, Empty, Grid, X_3, Y_3) ->
    case (X_3 < erlang:get('SIZE')) of
        true ->
            try
                case (lists:nth(X_3 + 1, lists:nth(Y_3 + 1, Grid)) == 0) of
        true -> Empty_2 = lists:append(Empty, [[X_3, Y_3]]),
            Empty_3 = Empty_2;
        _ -> Empty_3 = Empty
    end,
                X_4 = (X_3 + 1),
                Fun_3_loop(B_3, Empty_3, Grid, X_4, Y_3)
            catch
                continue -> Fun_3_loop(B_3, Empty, Grid, X_3, Y_3);
                break -> {B_3, Empty, Grid, X_3, Y_3}
            end;
        _ -> {B_3, Empty, Grid, X_3, Y_3}
    end
end,
{B_3, Empty_3, Grid, X_4, Y_3} = Fun_3(B_3, Empty, Grid, X_3, Y_3),
                Y_4 = (Y_3 + 1),
                Fun_4_loop(B_3, Empty_3, Grid, Y_4)
            catch
                continue -> Fun_4_loop(B_3, Empty, Grid, Y_3);
                break -> {B_3, Empty, Grid, Y_3}
            end;
        _ -> {B_3, Empty, Grid, Y_3}
    end
end,
{B_3, Empty_3, Grid, Y_4} = Fun_4(B_3, Empty, Grid, Y_3),
        case (length(Empty_3) == 0) of
        true -> throw({return, #{"board" => B_3, "full" => true}});
        _ -> ok
    end,
        Idx = (mochi_now() rem length(Empty_3)),
        Cell = lists:nth(Idx + 1, Empty_3),
        Val = 4,
        case ((mochi_now() rem 10) < 9) of
        true -> Val_2 = 2,
            Val_3 = Val_2;
        _ -> Val_3 = Val
    end,
        Tmp = lists:nth(lists:nth(1 + 1, Cell) + 1, Grid),
        Tmp_2 = lists:sublist(Tmp, lists:nth(0 + 1, Cell)) ++ [Val_3] ++ lists:nthtail(lists:nth(0 + 1, Cell) + 1, Tmp),
        Grid_2 = lists:sublist(Grid, lists:nth(1 + 1, Cell)) ++ [Tmp_2] ++ lists:nthtail(lists:nth(1 + 1, Cell) + 1, Grid),
        #{"board" => #{"cells" => Grid_2}, "full" => (length(Empty_3) == 1)}
    catch {return, V} -> V end.

pad(N) ->
    try
        S = lists:flatten(io_lib:format("~p", [N])),
        Pad = (4 - length(S)),
        I = 0,
        Out = "",
        Fun_5 = fun Fun_5_loop(I, N, Out, Pad, S) ->
    case (I < Pad) of
        true ->
            try
                Out_2 = (Out ++ " "),
                I_2 = (I + 1),
                Fun_5_loop(I_2, N, Out_2, Pad, S)
            catch
                continue -> Fun_5_loop(I, N, Out, Pad, S);
                break -> {I, N, Out, Pad, S}
            end;
        _ -> {I, N, Out, Pad, S}
    end
end,
{I_2, N, Out_2, Pad, S} = Fun_5(I, N, Out, Pad, S),
        (Out_2 ++ S)
    catch {return, V} -> V end.

draw(B_4, Score) ->
    try
        io:format("~ts~n", [("Score: " ++ lists:flatten(io_lib:format("~p", [Score])))]),
        Grid_3 = maps:get("cells", B_4),
        Y_5 = 0,
        Fun_7 = fun Fun_7_loop(B_4, Grid_3, Score, Y_5) ->
    case (Y_5 < 4) of
        true ->
            try
                io:format("~ts~n", ["+----+----+----+----+"]),
                Line = "|",
                X_5 = 0,
                Fun_6 = fun Fun_6_loop(B_4, Grid_3, Line, Score, X_5, Y_5) ->
    case (X_5 < erlang:get('SIZE')) of
        true ->
            try
                V = lists:nth(X_5 + 1, lists:nth(Y_5 + 1, Grid_3)),
                case (V == 0) of
        true -> Line_2 = (Line ++ "    |"),
            Line_4 = Line_2;
        _ -> Line_3 = ((Line ++ pad(V)) ++ "|"),
            Line_4 = Line_3
    end,
                X_6 = (X_5 + 1),
                Fun_6_loop(B_4, Grid_3, Line_4, Score, X_6, Y_5)
            catch
                continue -> Fun_6_loop(B_4, Grid_3, Line, Score, X_5, Y_5);
                break -> {B_4, Grid_3, Line, Score, X_5, Y_5}
            end;
        _ -> {B_4, Grid_3, Line, Score, X_5, Y_5}
    end
end,
{B_4, Grid_3, Line_4, Score, X_6, Y_5} = Fun_6(B_4, Grid_3, Line, Score, X_5, Y_5),
                io:format("~ts~n", [Line_4]),
                Y_6 = (Y_5 + 1),
                Fun_7_loop(B_4, Grid_3, Score, Y_6)
            catch
                continue -> Fun_7_loop(B_4, Grid_3, Score, Y_5);
                break -> {B_4, Grid_3, Score, Y_5}
            end;
        _ -> {B_4, Grid_3, Score, Y_5}
    end
end,
{B_4, Grid_3, Score, Y_6} = Fun_7(B_4, Grid_3, Score, Y_5),
        io:format("~ts~n", ["+----+----+----+----+"]),
        io:format("~ts~n", ["W=Up S=Down A=Left D=Right Q=Quit"]),
        nil
    catch {return, V} -> V end.

reverseRow(R) ->
    try
        Out_3 = [],
        I_3 = (length(R) - 1),
        Fun_8 = fun Fun_8_loop(I_3, Out_3, R) ->
    case (I_3 >= 0) of
        true ->
            try
                Out_4 = lists:append(Out_3, [lists:nth(I_3 + 1, R)]),
                I_4 = (I_3 - 1),
                Fun_8_loop(I_4, Out_4, R)
            catch
                continue -> Fun_8_loop(I_3, Out_3, R);
                break -> {I_3, Out_3, R}
            end;
        _ -> {I_3, Out_3, R}
    end
end,
{I_4, Out_4, R} = Fun_8(I_3, Out_3, R),
        Out_4
    catch {return, V} -> V end.

slideLeft(Row_3) ->
    try
        Xs = [],
        I_5 = 0,
        Fun_9 = fun Fun_9_loop(I_5, Row_3, Xs) ->
    case (I_5 < length(Row_3)) of
        true ->
            try
                case (lists:nth(I_5 + 1, Row_3) /= 0) of
        true -> Xs_2 = lists:append(Xs, [lists:nth(I_5 + 1, Row_3)]),
            Xs_3 = Xs_2;
        _ -> Xs_3 = Xs
    end,
                I_6 = (I_5 + 1),
                Fun_9_loop(I_6, Row_3, Xs_3)
            catch
                continue -> Fun_9_loop(I_5, Row_3, Xs);
                break -> {I_5, Row_3, Xs}
            end;
        _ -> {I_5, Row_3, Xs}
    end
end,
{I_6, Row_3, Xs_3} = Fun_9(I_5, Row_3, Xs),
        Res = [],
        Gain = 0,
        I_7 = 0,
        Fun_10 = fun Fun_10_loop(Gain, I_7, Res, Row_3, Xs_3) ->
    case (I_7 < length(Xs_3)) of
        true ->
            try
                case (((I_7 + 1) < length(Xs_3)) andalso (lists:nth(I_7 + 1, Xs_3) == lists:nth((I_7 + 1) + 1, Xs_3))) of
        true -> V_2 = (lists:nth(I_7 + 1, Xs_3) * 2),
            Gain_2 = (Gain + V_2),
            Res_2 = lists:append(Res, [V_2]),
            I_8 = (I_7 + 2),
            Gain_3 = Gain_2,
            I_10 = I_8,
            Res_4 = Res_2,
            V_3 = V_2;
        _ -> Res_3 = lists:append(Res, [lists:nth(I_7 + 1, Xs_3)]),
            I_9 = (I_7 + 1),
            Gain_3 = Gain,
            I_10 = I_9,
            Res_4 = Res_3,
            V_3 = nil
    end,
                Fun_10_loop(Gain_3, I_10, Res_4, Row_3, Xs_3)
            catch
                continue -> Fun_10_loop(Gain, I_7, Res, Row_3, Xs_3);
                break -> {Gain, I_7, Res, Row_3, Xs_3}
            end;
        _ -> {Gain, I_7, Res, Row_3, Xs_3}
    end
end,
{Gain_3, I_10, Res_4, Row_3, Xs_3} = Fun_10(Gain, I_7, Res, Row_3, Xs_3),
        Fun_11 = fun Fun_11_loop(Gain_3, I_10, Res_4, Row_3, Xs_3) ->
    case (length(Res_4) < 4) of
        true ->
            try
                Res_5 = lists:append(Res_4, [0]),
                Fun_11_loop(Gain_3, I_10, Res_5, Row_3, Xs_3)
            catch
                continue -> Fun_11_loop(Gain_3, I_10, Res_4, Row_3, Xs_3);
                break -> {Gain_3, I_10, Res_4, Row_3, Xs_3}
            end;
        _ -> {Gain_3, I_10, Res_4, Row_3, Xs_3}
    end
end,
{Gain_3, I_10, Res_5, Row_3, Xs_3} = Fun_11(Gain_3, I_10, Res_4, Row_3, Xs_3),
        #{"row" => Res_5, "gain" => Gain_3}
    catch {return, V} -> V end.

moveLeft(B_5, Score_2) ->
    try
        Grid_4 = maps:get("cells", B_5),
        Moved = false,
        Y_7 = 0,
        Fun_13 = fun Fun_13_loop(B_5, Grid_4, Moved, Score_2, Y_7) ->
    case (Y_7 < 4) of
        true ->
            try
                R_2 = slideLeft(lists:nth(Y_7 + 1, Grid_4)),
                New = maps:get("row", R_2),
                Score_3 = (Score_2 + maps:get("gain", R_2)),
                X_7 = 0,
                Fun_12 = fun Fun_12_loop(B_5, Grid_4, Moved, New, R_2, Score_3, X_7, Y_7) ->
    case (X_7 < erlang:get('SIZE')) of
        true ->
            try
                case (lists:nth(X_7 + 1, lists:nth(Y_7 + 1, Grid_4)) /= lists:nth(X_7 + 1, New)) of
        true -> Moved_2 = true,
            Moved_3 = Moved_2;
        _ -> Moved_3 = Moved
    end,
                Tmp_3 = lists:nth(Y_7 + 1, Grid_4),
                Tmp_4 = lists:sublist(Tmp_3, X_7) ++ [lists:nth(X_7 + 1, New)] ++ lists:nthtail(X_7 + 1, Tmp_3),
                Grid_5 = lists:sublist(Grid_4, Y_7) ++ [Tmp_4] ++ lists:nthtail(Y_7 + 1, Grid_4),
                X_8 = (X_7 + 1),
                Fun_12_loop(B_5, Grid_5, Moved_3, New, R_2, Score_3, X_8, Y_7)
            catch
                continue -> Fun_12_loop(B_5, Grid_4, Moved, New, R_2, Score_3, X_7, Y_7);
                break -> {B_5, Grid_4, Moved, New, R_2, Score_3, X_7, Y_7}
            end;
        _ -> {B_5, Grid_4, Moved, New, R_2, Score_3, X_7, Y_7}
    end
end,
{B_5, Grid_5, Moved_3, New, R_2, Score_3, X_8, Y_7} = Fun_12(B_5, Grid_4, Moved, New, R_2, Score_3, X_7, Y_7),
                Y_8 = (Y_7 + 1),
                Fun_13_loop(B_5, Grid_5, Moved_3, Score_3, Y_8)
            catch
                continue -> Fun_13_loop(B_5, Grid_4, Moved, Score_2, Y_7);
                break -> {B_5, Grid_4, Moved, Score_2, Y_7}
            end;
        _ -> {B_5, Grid_4, Moved, Score_2, Y_7}
    end
end,
{B_5, Grid_5, Moved_3, Score_3, Y_8} = Fun_13(B_5, Grid_4, Moved, Score_2, Y_7),
        #{"board" => #{"cells" => Grid_5}, "score" => Score_3, "moved" => Moved_3}
    catch {return, V} -> V end.

moveRight(B_6, Score_4) ->
    try
        Grid_6 = maps:get("cells", B_6),
        Moved_4 = false,
        Y_9 = 0,
        Fun_15 = fun Fun_15_loop(B_6, Grid_6, Moved_4, Score_4, Y_9) ->
    case (Y_9 < 4) of
        true ->
            try
                Rev = reverseRow(lists:nth(Y_9 + 1, Grid_6)),
                R_3 = slideLeft(Rev),
                Rev_2 = maps:get("row", R_3),
                Score_5 = (Score_4 + maps:get("gain", R_3)),
                Rev_3 = reverseRow(Rev_2),
                X_9 = 0,
                Fun_14 = fun Fun_14_loop(B_6, Grid_6, Moved_4, R_3, Rev_3, Score_5, X_9, Y_9) ->
    case (X_9 < erlang:get('SIZE')) of
        true ->
            try
                case (lists:nth(X_9 + 1, lists:nth(Y_9 + 1, Grid_6)) /= lists:nth(X_9 + 1, Rev_3)) of
        true -> Moved_5 = true,
            Moved_6 = Moved_5;
        _ -> Moved_6 = Moved_4
    end,
                Tmp_5 = lists:nth(Y_9 + 1, Grid_6),
                Tmp_6 = lists:sublist(Tmp_5, X_9) ++ [lists:nth(X_9 + 1, Rev_3)] ++ lists:nthtail(X_9 + 1, Tmp_5),
                Grid_7 = lists:sublist(Grid_6, Y_9) ++ [Tmp_6] ++ lists:nthtail(Y_9 + 1, Grid_6),
                X_10 = (X_9 + 1),
                Fun_14_loop(B_6, Grid_7, Moved_6, R_3, Rev_3, Score_5, X_10, Y_9)
            catch
                continue -> Fun_14_loop(B_6, Grid_6, Moved_4, R_3, Rev_3, Score_5, X_9, Y_9);
                break -> {B_6, Grid_6, Moved_4, R_3, Rev_3, Score_5, X_9, Y_9}
            end;
        _ -> {B_6, Grid_6, Moved_4, R_3, Rev_3, Score_5, X_9, Y_9}
    end
end,
{B_6, Grid_7, Moved_6, R_3, Rev_3, Score_5, X_10, Y_9} = Fun_14(B_6, Grid_6, Moved_4, R_3, Rev_3, Score_5, X_9, Y_9),
                Y_10 = (Y_9 + 1),
                Fun_15_loop(B_6, Grid_7, Moved_6, Score_5, Y_10)
            catch
                continue -> Fun_15_loop(B_6, Grid_6, Moved_4, Score_4, Y_9);
                break -> {B_6, Grid_6, Moved_4, Score_4, Y_9}
            end;
        _ -> {B_6, Grid_6, Moved_4, Score_4, Y_9}
    end
end,
{B_6, Grid_7, Moved_6, Score_5, Y_10} = Fun_15(B_6, Grid_6, Moved_4, Score_4, Y_9),
        #{"board" => #{"cells" => Grid_7}, "score" => Score_5, "moved" => Moved_6}
    catch {return, V} -> V end.

getCol(B_7, X_11) ->
    try
        Grid_8 = maps:get("cells", B_7),
        Col = [],
        Y_11 = 0,
        Fun_16 = fun Fun_16_loop(B_7, Col, Grid_8, X_11, Y_11) ->
    case (Y_11 < 4) of
        true ->
            try
                Col_2 = lists:append(Col, [lists:nth(X_11 + 1, lists:nth(Y_11 + 1, Grid_8))]),
                Y_12 = (Y_11 + 1),
                Fun_16_loop(B_7, Col_2, Grid_8, X_11, Y_12)
            catch
                continue -> Fun_16_loop(B_7, Col, Grid_8, X_11, Y_11);
                break -> {B_7, Col, Grid_8, X_11, Y_11}
            end;
        _ -> {B_7, Col, Grid_8, X_11, Y_11}
    end
end,
{B_7, Col_2, Grid_8, X_11, Y_12} = Fun_16(B_7, Col, Grid_8, X_11, Y_11),
        Col_2
    catch {return, V} -> V end.

setCol(B_8, X_12, Col_3) ->
    try
        Rows = maps:get("cells", B_8),
        Y_13 = 0,
        Fun_17 = fun Fun_17_loop(B_8, Col_3, Rows, X_12, Y_13) ->
    case (Y_13 < 4) of
        true ->
            try
                Row_4 = lists:nth(Y_13 + 1, Rows),
                Row_5 = lists:sublist(Row_4, X_12) ++ [lists:nth(Y_13 + 1, Col_3)] ++ lists:nthtail(X_12 + 1, Row_4),
                Rows_2 = lists:sublist(Rows, Y_13) ++ [Row_5] ++ lists:nthtail(Y_13 + 1, Rows),
                Y_14 = (Y_13 + 1),
                Fun_17_loop(B_8, Col_3, Rows_2, X_12, Y_14)
            catch
                continue -> Fun_17_loop(B_8, Col_3, Rows, X_12, Y_13);
                break -> {B_8, Col_3, Rows, X_12, Y_13}
            end;
        _ -> {B_8, Col_3, Rows, X_12, Y_13}
    end
end,
{B_8, Col_3, Rows_2, X_12, Y_14} = Fun_17(B_8, Col_3, Rows, X_12, Y_13),
        B_9 = maps:put("cells", Rows_2, B_8),
        nil
    catch {return, V} -> V end.

moveUp(B_10, Score_6) ->
    try
        Grid_9 = maps:get("cells", B_10),
        Moved_7 = false,
        X_13 = 0,
        Fun_19 = fun Fun_19_loop(B_10, Grid_9, Moved_7, Score_6, X_13) ->
    case (X_13 < 4) of
        true ->
            try
                Col_4 = getCol(B_10, X_13),
                R_4 = slideLeft(Col_4),
                New_2 = maps:get("row", R_4),
                Score_7 = (Score_6 + maps:get("gain", R_4)),
                Y_15 = 0,
                Fun_18 = fun Fun_18_loop(B_10, Col_4, Grid_9, Moved_7, New_2, R_4, Score_7, X_13, Y_15) ->
    case (Y_15 < erlang:get('SIZE')) of
        true ->
            try
                case (lists:nth(X_13 + 1, lists:nth(Y_15 + 1, Grid_9)) /= lists:nth(Y_15 + 1, New_2)) of
        true -> Moved_8 = true,
            Moved_9 = Moved_8;
        _ -> Moved_9 = Moved_7
    end,
                Tmp_7 = lists:nth(Y_15 + 1, Grid_9),
                Tmp_8 = lists:sublist(Tmp_7, X_13) ++ [lists:nth(Y_15 + 1, New_2)] ++ lists:nthtail(X_13 + 1, Tmp_7),
                Grid_10 = lists:sublist(Grid_9, Y_15) ++ [Tmp_8] ++ lists:nthtail(Y_15 + 1, Grid_9),
                Y_16 = (Y_15 + 1),
                Fun_18_loop(B_10, Col_4, Grid_10, Moved_9, New_2, R_4, Score_7, X_13, Y_16)
            catch
                continue -> Fun_18_loop(B_10, Col_4, Grid_9, Moved_7, New_2, R_4, Score_7, X_13, Y_15);
                break -> {B_10, Col_4, Grid_9, Moved_7, New_2, R_4, Score_7, X_13, Y_15}
            end;
        _ -> {B_10, Col_4, Grid_9, Moved_7, New_2, R_4, Score_7, X_13, Y_15}
    end
end,
{B_10, Col_4, Grid_10, Moved_9, New_2, R_4, Score_7, X_13, Y_16} = Fun_18(B_10, Col_4, Grid_9, Moved_7, New_2, R_4, Score_7, X_13, Y_15),
                X_14 = (X_13 + 1),
                Fun_19_loop(B_10, Grid_10, Moved_9, Score_7, X_14)
            catch
                continue -> Fun_19_loop(B_10, Grid_9, Moved_7, Score_6, X_13);
                break -> {B_10, Grid_9, Moved_7, Score_6, X_13}
            end;
        _ -> {B_10, Grid_9, Moved_7, Score_6, X_13}
    end
end,
{B_10, Grid_10, Moved_9, Score_7, X_14} = Fun_19(B_10, Grid_9, Moved_7, Score_6, X_13),
        #{"board" => #{"cells" => Grid_10}, "score" => Score_7, "moved" => Moved_9}
    catch {return, V} -> V end.

moveDown(B_11, Score_8) ->
    try
        Grid_11 = maps:get("cells", B_11),
        Moved_10 = false,
        X_15 = 0,
        Fun_21 = fun Fun_21_loop(B_11, Grid_11, Moved_10, Score_8, X_15) ->
    case (X_15 < 4) of
        true ->
            try
                Col_5 = reverseRow(getCol(B_11, X_15)),
                R_5 = slideLeft(Col_5),
                Col_6 = maps:get("row", R_5),
                Score_9 = (Score_8 + maps:get("gain", R_5)),
                Col_7 = reverseRow(Col_6),
                Y_17 = 0,
                Fun_20 = fun Fun_20_loop(B_11, Col_7, Grid_11, Moved_10, R_5, Score_9, X_15, Y_17) ->
    case (Y_17 < erlang:get('SIZE')) of
        true ->
            try
                case (lists:nth(X_15 + 1, lists:nth(Y_17 + 1, Grid_11)) /= lists:nth(Y_17 + 1, Col_7)) of
        true -> Moved_11 = true,
            Moved_12 = Moved_11;
        _ -> Moved_12 = Moved_10
    end,
                Tmp_9 = lists:nth(Y_17 + 1, Grid_11),
                Tmp_10 = lists:sublist(Tmp_9, X_15) ++ [lists:nth(Y_17 + 1, Col_7)] ++ lists:nthtail(X_15 + 1, Tmp_9),
                Grid_12 = lists:sublist(Grid_11, Y_17) ++ [Tmp_10] ++ lists:nthtail(Y_17 + 1, Grid_11),
                Y_18 = (Y_17 + 1),
                Fun_20_loop(B_11, Col_7, Grid_12, Moved_12, R_5, Score_9, X_15, Y_18)
            catch
                continue -> Fun_20_loop(B_11, Col_7, Grid_11, Moved_10, R_5, Score_9, X_15, Y_17);
                break -> {B_11, Col_7, Grid_11, Moved_10, R_5, Score_9, X_15, Y_17}
            end;
        _ -> {B_11, Col_7, Grid_11, Moved_10, R_5, Score_9, X_15, Y_17}
    end
end,
{B_11, Col_7, Grid_12, Moved_12, R_5, Score_9, X_15, Y_18} = Fun_20(B_11, Col_7, Grid_11, Moved_10, R_5, Score_9, X_15, Y_17),
                X_16 = (X_15 + 1),
                Fun_21_loop(B_11, Grid_12, Moved_12, Score_9, X_16)
            catch
                continue -> Fun_21_loop(B_11, Grid_11, Moved_10, Score_8, X_15);
                break -> {B_11, Grid_11, Moved_10, Score_8, X_15}
            end;
        _ -> {B_11, Grid_11, Moved_10, Score_8, X_15}
    end
end,
{B_11, Grid_12, Moved_12, Score_9, X_16} = Fun_21(B_11, Grid_11, Moved_10, Score_8, X_15),
        #{"board" => #{"cells" => Grid_12}, "score" => Score_9, "moved" => Moved_12}
    catch {return, V} -> V end.

hasMoves(B_12) ->
    try
        Grid_13 = maps:get("cells", B_12),
        Y_19 = 0,
        Fun_23 = fun Fun_23_loop(B_12, Grid_13, Y_19) ->
    case (Y_19 < 4) of
        true ->
            try
                X_17 = 0,
                Fun_22 = fun Fun_22_loop(B_12, Grid_13, X_17, Y_19) ->
    case (X_17 < erlang:get('SIZE')) of
        true ->
            try
                case (lists:nth(X_17 + 1, lists:nth(Y_19 + 1, Grid_13)) == 0) of
        true -> throw({return, true});
        _ -> ok
    end,
                case (((X_17 + 1) < erlang:get('SIZE')) andalso (lists:nth(X_17 + 1, lists:nth(Y_19 + 1, Grid_13)) == lists:nth((X_17 + 1) + 1, lists:nth(Y_19 + 1, Grid_13)))) of
        true -> throw({return, true});
        _ -> ok
    end,
                case (((Y_19 + 1) < erlang:get('SIZE')) andalso (lists:nth(X_17 + 1, lists:nth(Y_19 + 1, Grid_13)) == lists:nth(X_17 + 1, lists:nth((Y_19 + 1) + 1, Grid_13)))) of
        true -> throw({return, true});
        _ -> ok
    end,
                X_18 = (X_17 + 1),
                Fun_22_loop(B_12, Grid_13, X_18, Y_19)
            catch
                continue -> Fun_22_loop(B_12, Grid_13, X_17, Y_19);
                break -> {B_12, Grid_13, X_17, Y_19}
            end;
        _ -> {B_12, Grid_13, X_17, Y_19}
    end
end,
{B_12, Grid_13, X_18, Y_19} = Fun_22(B_12, Grid_13, X_17, Y_19),
                Y_20 = (Y_19 + 1),
                Fun_23_loop(B_12, Grid_13, Y_20)
            catch
                continue -> Fun_23_loop(B_12, Grid_13, Y_19);
                break -> {B_12, Grid_13, Y_19}
            end;
        _ -> {B_12, Grid_13, Y_19}
    end
end,
{B_12, Grid_13, Y_20} = Fun_23(B_12, Grid_13, Y_19),
        false
    catch {return, V} -> V end.

has2048(B_13) ->
    try
        Grid_14 = maps:get("cells", B_13),
        Y_21 = 0,
        Fun_25 = fun Fun_25_loop(B_13, Grid_14, Y_21) ->
    case (Y_21 < 4) of
        true ->
            try
                X_19 = 0,
                Fun_24 = fun Fun_24_loop(B_13, Grid_14, X_19, Y_21) ->
    case (X_19 < erlang:get('SIZE')) of
        true ->
            try
                case (lists:nth(X_19 + 1, lists:nth(Y_21 + 1, Grid_14)) >= 2048) of
        true -> throw({return, true});
        _ -> ok
    end,
                X_20 = (X_19 + 1),
                Fun_24_loop(B_13, Grid_14, X_20, Y_21)
            catch
                continue -> Fun_24_loop(B_13, Grid_14, X_19, Y_21);
                break -> {B_13, Grid_14, X_19, Y_21}
            end;
        _ -> {B_13, Grid_14, X_19, Y_21}
    end
end,
{B_13, Grid_14, X_20, Y_21} = Fun_24(B_13, Grid_14, X_19, Y_21),
                Y_22 = (Y_21 + 1),
                Fun_25_loop(B_13, Grid_14, Y_22)
            catch
                continue -> Fun_25_loop(B_13, Grid_14, Y_21);
                break -> {B_13, Grid_14, Y_21}
            end;
        _ -> {B_13, Grid_14, Y_21}
    end
end,
{B_13, Grid_14, Y_22} = Fun_25(B_13, Grid_14, Y_21),
        false
    catch {return, V} -> V end.

main(_) ->
    erlang:put('SIZE', 4),
    erlang:put('board', newBoard()),
    erlang:put('r', spawnTile(erlang:get('board'))),
    erlang:put('board', maps:get("board", erlang:get('r'))),
    erlang:put('full', maps:get("full", erlang:get('r'))),
    erlang:put('r', spawnTile(erlang:get('board'))),
    erlang:put('board', maps:get("board", erlang:get('r'))),
    erlang:put('full', maps:get("full", erlang:get('r'))),
    erlang:put('score', 0),
    draw(erlang:get('board'), erlang:get('score')),
    Fun_26 = fun Fun_26_loop() ->
    case true of
        true ->
            try
                io:format("~ts~n", ["Move: "]),
                Cmd = string:trim(io:get_line("")),
                Moved_13 = false,
                case ((Cmd == "a") orelse (Cmd == "A")) of
        true -> M = moveLeft(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M)),
            erlang:put('score', maps:get("score", M)),
            Moved_14 = maps:get("moved", M),
            M_2 = M,
            Moved_15 = Moved_14;
        _ -> M_2 = nil,
            Moved_15 = Moved_13
    end,
                case ((Cmd == "d") orelse (Cmd == "D")) of
        true -> M_3 = moveRight(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M_3)),
            erlang:put('score', maps:get("score", M_3)),
            Moved_16 = maps:get("moved", M_3),
            M_4 = M_3,
            Moved_17 = Moved_16;
        _ -> M_4 = M_2,
            Moved_17 = Moved_15
    end,
                case ((Cmd == "w") orelse (Cmd == "W")) of
        true -> M_5 = moveUp(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M_5)),
            erlang:put('score', maps:get("score", M_5)),
            Moved_18 = maps:get("moved", M_5),
            M_6 = M_5,
            Moved_19 = Moved_18;
        _ -> M_6 = M_4,
            Moved_19 = Moved_17
    end,
                case ((Cmd == "s") orelse (Cmd == "S")) of
        true -> M_7 = moveDown(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M_7)),
            erlang:put('score', maps:get("score", M_7)),
            Moved_20 = maps:get("moved", M_7),
            M_8 = M_7,
            Moved_21 = Moved_20;
        _ -> M_8 = M_6,
            Moved_21 = Moved_19
    end,
                case ((Cmd == "q") orelse (Cmd == "Q")) of
        true -> throw(break);
        _ -> ok
    end,
                case (Moved_21 /= nil) of
        true -> R2 = spawnTile(erlang:get('board')),
            erlang:put('board', maps:get("board", R2)),
            erlang:put('full', maps:get("full", R2)),
            case (erlang:get('full') andalso not hasMoves(erlang:get('board'))) of
        true -> draw(erlang:get('board'), erlang:get('score')),
            io:format("~ts~n", ["Game Over"]),
            throw(break);
        _ -> ok
    end,
            R2_2 = R2;
        _ -> R2_2 = nil
    end,
                draw(erlang:get('board'), erlang:get('score')),
                case has2048(erlang:get('board')) of
        true -> io:format("~ts~n", ["You win!"]),
            throw(break);
        _ -> ok
    end,
                case not hasMoves(erlang:get('board')) of
        true -> io:format("~ts~n", ["Game Over"]),
            throw(break);
        _ -> ok
    end,
                Fun_26_loop()
            catch
                continue -> Fun_26_loop();
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun_26().
