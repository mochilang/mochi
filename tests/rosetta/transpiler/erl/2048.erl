#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newBoard/0, spawnTile/1, pad/1, draw/2, reverseRow/1, slideLeft/1, moveLeft/2, moveRight/2, getCol/2, setCol/3, moveUp/2, moveDown/2, hasMoves/1, has2048/1]).

% Generated by Mochi transpiler v0.10.37 (28793aa8f9) on 2025-07-23 12:58 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

newBoard() ->
    try
        B = [],
        Y = 0,
        Fun2 = fun Fun2_loop(B, Y) ->
    case (Y < 4) of
        true ->
            try
                Row = [],
                X = 0,
                Fun = fun Fun_loop(B, Row, X, Y) ->
    case (X < 4) of
        true ->
            try
                Row2 = lists:append(Row, [0]),
                X2 = (X + 1),
                Fun_loop(B, Row2, X2, Y)
            catch
                break -> {B, Row, X, Y}
            end;
        _ -> {B, Row, X, Y}
    end
end,
{B, Row2, X2, Y} = Fun(B, Row, X, Y),
                B2 = lists:append(B, [Row2]),
                Y2 = (Y + 1),
                Fun2_loop(B2, Y2)
            catch
                break -> {B, Y}
            end;
        _ -> {B, Y}
    end
end,
{B2, Y2} = Fun2(B, Y),
        B2
    catch {return, V} -> V end.

spawnTile(B3) ->
    try
        Empty = [],
        Y3 = 0,
        Fun4 = fun Fun4_loop(B3, Empty, Y3) ->
    case (Y3 < 4) of
        true ->
            try
                X3 = 0,
                Fun3 = fun Fun3_loop(B3, Empty, X3, Y3) ->
    case (X3 < 4) of
        true ->
            try
                case (lists:nth(X3 + 1, lists:nth(Y3 + 1, B3)) == 0) of
        true -> Empty2 = lists:append(Empty, [[X3, Y3]]),
            Empty3 = Empty2;
        _ -> Empty3 = Empty
    end,
                X4 = (X3 + 1),
                Fun3_loop(B3, Empty3, X4, Y3)
            catch
                break -> {B3, Empty, X3, Y3}
            end;
        _ -> {B3, Empty, X3, Y3}
    end
end,
{B3, Empty3, X4, Y3} = Fun3(B3, Empty, X3, Y3),
                Y4 = (Y3 + 1),
                Fun4_loop(B3, Empty3, Y4)
            catch
                break -> {B3, Empty, Y3}
            end;
        _ -> {B3, Empty, Y3}
    end
end,
{B3, Empty3, Y4} = Fun4(B3, Empty, Y3),
        case (length(Empty3) == 0) of
        true -> throw({return, #{"board" => B3, "full" => true}});
        _ -> ok
    end,
        Idx = (mochi_now() rem length(Empty3)),
        Cell = lists:nth(Idx + 1, Empty3),
        Val = 4,
        case ((mochi_now() rem 10) < 9) of
        true -> Val2 = 2,
            Val3 = Val2;
        _ -> Val3 = Val
    end,
        Tmp = lists:nth(lists:nth(1 + 1, Cell) + 1, B3),
        Tmp2 = lists:sublist(Tmp, lists:nth(0 + 1, Cell)) ++ [Val3] ++ lists:nthtail(lists:nth(0 + 1, Cell) + 1, Tmp),
        B4 = lists:sublist(B3, lists:nth(1 + 1, Cell)) ++ [Tmp2] ++ lists:nthtail(lists:nth(1 + 1, Cell) + 1, B3),
        #{"board" => B4, "full" => (length(Empty3) == 1)}
    catch {return, V} -> V end.

pad(N) ->
    try
        S = lists:flatten(io_lib:format("~p", [N])),
        Pad = (4 - length(S)),
        I = 0,
        Out = "",
        Fun5 = fun Fun5_loop(I, N, Out, Pad, S) ->
    case (I < Pad) of
        true ->
            try
                Out2 = (Out ++ " "),
                I2 = (I + 1),
                Fun5_loop(I2, N, Out2, Pad, S)
            catch
                break -> {I, N, Out, Pad, S}
            end;
        _ -> {I, N, Out, Pad, S}
    end
end,
{I2, N, Out2, Pad, S} = Fun5(I, N, Out, Pad, S),
        (Out2 ++ S)
    catch {return, V} -> V end.

draw(B5, Score) ->
    try
        io:format("~ts~n", [("Score: " ++ lists:flatten(io_lib:format("~p", [Score])))]),
        Y5 = 0,
        Fun7 = fun Fun7_loop(B5, Score, Y5) ->
    case (Y5 < 4) of
        true ->
            try
                io:format("~ts~n", ["+----+----+----+----+"]),
                Line = "|",
                X5 = 0,
                Fun6 = fun Fun6_loop(B5, Line, Score, X5, Y5) ->
    case (X5 < 4) of
        true ->
            try
                V = lists:nth(X5 + 1, lists:nth(Y5 + 1, B5)),
                case (V == 0) of
        true -> Line2 = (Line ++ "    |"),
            Line4 = Line2;
        _ -> Line3 = ((Line ++ pad(V)) ++ "|"),
            Line4 = Line3
    end,
                X6 = (X5 + 1),
                Fun6_loop(B5, Line4, Score, X6, Y5)
            catch
                break -> {B5, Line, Score, X5, Y5}
            end;
        _ -> {B5, Line, Score, X5, Y5}
    end
end,
{B5, Line4, Score, X6, Y5} = Fun6(B5, Line, Score, X5, Y5),
                io:format("~ts~n", [Line4]),
                Y6 = (Y5 + 1),
                Fun7_loop(B5, Score, Y6)
            catch
                break -> {B5, Score, Y5}
            end;
        _ -> {B5, Score, Y5}
    end
end,
{B5, Score, Y6} = Fun7(B5, Score, Y5),
        io:format("~ts~n", ["+----+----+----+----+"]),
        io:format("~ts~n", ["W=Up S=Down A=Left D=Right Q=Quit"]),
        nil
    catch {return, V} -> V end.

reverseRow(R) ->
    try
        Out3 = [],
        I3 = (maps:size(R) - 1),
        Fun8 = fun Fun8_loop(I3, Out3, R) ->
    case (I3 >= 0) of
        true ->
            try
                Out4 = lists:append(Out3, [maps:get(I3, R)]),
                I4 = (I3 - 1),
                Fun8_loop(I4, Out4, R)
            catch
                break -> {I3, Out3, R}
            end;
        _ -> {I3, Out3, R}
    end
end,
{I4, Out4, R} = Fun8(I3, Out3, R),
        Out4
    catch {return, V} -> V end.

slideLeft(Row3) ->
    try
        Xs = [],
        I5 = 0,
        Fun9 = fun Fun9_loop(I5, Row3, Xs) ->
    case (I5 < length(Row3)) of
        true ->
            try
                case (lists:nth(I5 + 1, Row3) /= 0) of
        true -> Xs2 = lists:append(Xs, [lists:nth(I5 + 1, Row3)]),
            Xs3 = Xs2;
        _ -> Xs3 = Xs
    end,
                I6 = (I5 + 1),
                Fun9_loop(I6, Row3, Xs3)
            catch
                break -> {I5, Row3, Xs}
            end;
        _ -> {I5, Row3, Xs}
    end
end,
{I6, Row3, Xs3} = Fun9(I5, Row3, Xs),
        Res = [],
        Gain = 0,
        I7 = 0,
        Fun10 = fun Fun10_loop(Gain, I7, Res, Row3, Xs3) ->
    case (0 < length(Xs3)) of
        true ->
            try
                case (((0 + 1) < length(Xs3)) andalso (lists:nth(0 + 1, Xs3) == lists:nth((0 + 1) + 1, Xs3))) of
        true -> V2 = (lists:nth(0 + 1, Xs3) * 2),
            Gain2 = (Gain + V2),
            Res2 = lists:append(Res, [V2]),
            I8 = (0 + 2),
            Gain3 = Gain2,
            I10 = I8,
            Res4 = Res2,
            V3 = V2;
        _ -> Res3 = lists:append(Res, [lists:nth(0 + 1, Xs3)]),
            I9 = (0 + 1),
            Gain3 = Gain,
            I10 = I9,
            Res4 = Res3,
            V3 = nil
    end,
                Fun10_loop(Gain3, I10, Res4, Row3, Xs3)
            catch
                break -> {Gain, I7, Res, Row3, Xs3}
            end;
        _ -> {Gain, I7, Res, Row3, Xs3}
    end
end,
{Gain3, I10, Res4, Row3, Xs3} = Fun10(Gain, I7, Res, Row3, Xs3),
        Fun11 = fun Fun11_loop(Gain3, I10, Res4, Row3, Xs3) ->
    case (length(Res4) < 4) of
        true ->
            try
                Res5 = lists:append(Res4, [0]),
                Fun11_loop(Gain3, I10, Res5, Row3, Xs3)
            catch
                break -> {Gain3, I10, Res4, Row3, Xs3}
            end;
        _ -> {Gain3, I10, Res4, Row3, Xs3}
    end
end,
{Gain3, I10, Res5, Row3, Xs3} = Fun11(Gain3, I10, Res4, Row3, Xs3),
        #{"row" => Res5, "gain" => Gain3}
    catch {return, V} -> V end.

moveLeft(B6, Score2) ->
    try
        Moved = false,
        Y7 = 0,
        Fun13 = fun Fun13_loop(B6, Moved, Score2, Y7) ->
    case (Y7 < 4) of
        true ->
            try
                R2 = slideLeft(lists:nth(Y7 + 1, B6)),
                New = maps:get("row", R2),
                Score3 = (Score2 + maps:get("gain", R2)),
                X7 = 0,
                Fun12 = fun Fun12_loop(B6, Moved, New, R2, Score3, X7, Y7) ->
    case (X7 < 4) of
        true ->
            try
                case (lists:nth(X7 + 1, lists:nth(Y7 + 1, B6)) /= lists:nth(X7 + 1, New)) of
        true -> Moved2 = true,
            Moved3 = Moved2;
        _ -> Moved3 = Moved
    end,
                Tmp3 = lists:nth(Y7 + 1, B6),
                Tmp4 = lists:sublist(Tmp3, X7) ++ [lists:nth(X7 + 1, New)] ++ lists:nthtail(X7 + 1, Tmp3),
                B7 = lists:sublist(B6, Y7) ++ [Tmp4] ++ lists:nthtail(Y7 + 1, B6),
                X8 = (X7 + 1),
                Fun12_loop(B7, Moved3, New, R2, Score3, X8, Y7)
            catch
                break -> {B6, Moved, New, R2, Score3, X7, Y7}
            end;
        _ -> {B6, Moved, New, R2, Score3, X7, Y7}
    end
end,
{B7, Moved3, New, R2, Score3, X8, Y7} = Fun12(B6, Moved, New, R2, Score3, X7, Y7),
                Y8 = (Y7 + 1),
                Fun13_loop(B7, Moved3, Score3, Y8)
            catch
                break -> {B6, Moved, Score2, Y7}
            end;
        _ -> {B6, Moved, Score2, Y7}
    end
end,
{B7, Moved3, Score3, Y8} = Fun13(B6, Moved, Score2, Y7),
        #{"board" => B7, "score" => Score3, "moved" => Moved3}
    catch {return, V} -> V end.

moveRight(B8, Score4) ->
    try
        Moved4 = false,
        Y9 = 0,
        Fun15 = fun Fun15_loop(B8, Moved4, Score4, Y9) ->
    case (Y9 < 4) of
        true ->
            try
                Rev = reverseRow(lists:nth(Y9 + 1, B8)),
                R3 = slideLeft(Rev),
                Rev2 = maps:get("row", R3),
                Score5 = (Score4 + maps:get("gain", R3)),
                Rev3 = reverseRow(Rev2),
                X9 = 0,
                Fun14 = fun Fun14_loop(B8, Moved4, R3, Rev3, Score5, X9, Y9) ->
    case (X9 < 4) of
        true ->
            try
                case (lists:nth(X9 + 1, lists:nth(Y9 + 1, B8)) /= lists:nth(X9 + 1, Rev3)) of
        true -> Moved5 = true,
            Moved6 = Moved5;
        _ -> Moved6 = Moved4
    end,
                Tmp5 = lists:nth(Y9 + 1, B8),
                Tmp6 = lists:sublist(Tmp5, X9) ++ [lists:nth(X9 + 1, Rev3)] ++ lists:nthtail(X9 + 1, Tmp5),
                B9 = lists:sublist(B8, Y9) ++ [Tmp6] ++ lists:nthtail(Y9 + 1, B8),
                X10 = (X9 + 1),
                Fun14_loop(B9, Moved6, R3, Rev3, Score5, X10, Y9)
            catch
                break -> {B8, Moved4, R3, Rev3, Score5, X9, Y9}
            end;
        _ -> {B8, Moved4, R3, Rev3, Score5, X9, Y9}
    end
end,
{B9, Moved6, R3, Rev3, Score5, X10, Y9} = Fun14(B8, Moved4, R3, Rev3, Score5, X9, Y9),
                Y10 = (Y9 + 1),
                Fun15_loop(B9, Moved6, Score5, Y10)
            catch
                break -> {B8, Moved4, Score4, Y9}
            end;
        _ -> {B8, Moved4, Score4, Y9}
    end
end,
{B9, Moved6, Score5, Y10} = Fun15(B8, Moved4, Score4, Y9),
        #{"board" => B9, "score" => Score5, "moved" => Moved6}
    catch {return, V} -> V end.

getCol(B10, X11) ->
    try
        Col = [],
        Y11 = 0,
        Fun16 = fun Fun16_loop(B10, Col, X11, Y11) ->
    case (Y11 < 4) of
        true ->
            try
                Col2 = lists:append(Col, [lists:nth(X11 + 1, lists:nth(Y11 + 1, B10))]),
                Y12 = (Y11 + 1),
                Fun16_loop(B10, Col2, X11, Y12)
            catch
                break -> {B10, Col, X11, Y11}
            end;
        _ -> {B10, Col, X11, Y11}
    end
end,
{B10, Col2, X11, Y12} = Fun16(B10, Col, X11, Y11),
        Col2
    catch {return, V} -> V end.

setCol(B11, X12, Col3) ->
    try
        Y13 = 0,
        Fun17 = fun Fun17_loop(B11, Col3, X12, Y13) ->
    case (Y13 < 4) of
        true ->
            try
                Tmp7 = lists:nth(Y13 + 1, B11),
                Tmp8 = lists:sublist(Tmp7, X12) ++ [lists:nth(Y13 + 1, Col3)] ++ lists:nthtail(X12 + 1, Tmp7),
                B12 = lists:sublist(B11, Y13) ++ [Tmp8] ++ lists:nthtail(Y13 + 1, B11),
                Y14 = (Y13 + 1),
                Fun17_loop(B12, Col3, X12, Y14)
            catch
                break -> {B11, Col3, X12, Y13}
            end;
        _ -> {B11, Col3, X12, Y13}
    end
end,
{B12, Col3, X12, Y14} = Fun17(B11, Col3, X12, Y13),
        nil
    catch {return, V} -> V end.

moveUp(B13, Score6) ->
    try
        Moved7 = false,
        X13 = 0,
        Fun19 = fun Fun19_loop(B13, Moved7, Score6, X13) ->
    case (X13 < 4) of
        true ->
            try
                Col4 = getCol(B13, X13),
                R4 = slideLeft(Col4),
                New2 = maps:get("row", R4),
                Score7 = (Score6 + maps:get("gain", R4)),
                Y15 = 0,
                Fun18 = fun Fun18_loop(B13, Col4, Moved7, New2, R4, Score7, X13, Y15) ->
    case (Y15 < 4) of
        true ->
            try
                case (lists:nth(X13 + 1, lists:nth(Y15 + 1, B13)) /= lists:nth(Y15 + 1, New2)) of
        true -> Moved8 = true,
            Moved9 = Moved8;
        _ -> Moved9 = Moved7
    end,
                Tmp9 = lists:nth(Y15 + 1, B13),
                Tmp10 = lists:sublist(Tmp9, X13) ++ [lists:nth(Y15 + 1, New2)] ++ lists:nthtail(X13 + 1, Tmp9),
                B14 = lists:sublist(B13, Y15) ++ [Tmp10] ++ lists:nthtail(Y15 + 1, B13),
                Y16 = (Y15 + 1),
                Fun18_loop(B14, Col4, Moved9, New2, R4, Score7, X13, Y16)
            catch
                break -> {B13, Col4, Moved7, New2, R4, Score7, X13, Y15}
            end;
        _ -> {B13, Col4, Moved7, New2, R4, Score7, X13, Y15}
    end
end,
{B14, Col4, Moved9, New2, R4, Score7, X13, Y16} = Fun18(B13, Col4, Moved7, New2, R4, Score7, X13, Y15),
                X14 = (X13 + 1),
                Fun19_loop(B14, Moved9, Score7, X14)
            catch
                break -> {B13, Moved7, Score6, X13}
            end;
        _ -> {B13, Moved7, Score6, X13}
    end
end,
{B14, Moved9, Score7, X14} = Fun19(B13, Moved7, Score6, X13),
        #{"board" => B14, "score" => Score7, "moved" => Moved9}
    catch {return, V} -> V end.

moveDown(B15, Score8) ->
    try
        Moved10 = false,
        X15 = 0,
        Fun21 = fun Fun21_loop(B15, Moved10, Score8, X15) ->
    case (X15 < 4) of
        true ->
            try
                Col5 = reverseRow(getCol(B15, X15)),
                R5 = slideLeft(Col5),
                Col6 = maps:get("row", R5),
                Score9 = (Score8 + maps:get("gain", R5)),
                Col7 = reverseRow(Col6),
                Y17 = 0,
                Fun20 = fun Fun20_loop(B15, Col7, Moved10, R5, Score9, X15, Y17) ->
    case (Y17 < 4) of
        true ->
            try
                case (lists:nth(X15 + 1, lists:nth(Y17 + 1, B15)) /= lists:nth(Y17 + 1, Col7)) of
        true -> Moved11 = true,
            Moved12 = Moved11;
        _ -> Moved12 = Moved10
    end,
                Tmp11 = lists:nth(Y17 + 1, B15),
                Tmp12 = lists:sublist(Tmp11, X15) ++ [lists:nth(Y17 + 1, Col7)] ++ lists:nthtail(X15 + 1, Tmp11),
                B16 = lists:sublist(B15, Y17) ++ [Tmp12] ++ lists:nthtail(Y17 + 1, B15),
                Y18 = (Y17 + 1),
                Fun20_loop(B16, Col7, Moved12, R5, Score9, X15, Y18)
            catch
                break -> {B15, Col7, Moved10, R5, Score9, X15, Y17}
            end;
        _ -> {B15, Col7, Moved10, R5, Score9, X15, Y17}
    end
end,
{B16, Col7, Moved12, R5, Score9, X15, Y18} = Fun20(B15, Col7, Moved10, R5, Score9, X15, Y17),
                X16 = (X15 + 1),
                Fun21_loop(B16, Moved12, Score9, X16)
            catch
                break -> {B15, Moved10, Score8, X15}
            end;
        _ -> {B15, Moved10, Score8, X15}
    end
end,
{B16, Moved12, Score9, X16} = Fun21(B15, Moved10, Score8, X15),
        #{"board" => B16, "score" => Score9, "moved" => Moved12}
    catch {return, V} -> V end.

hasMoves(B17) ->
    try
        Y19 = 0,
        Fun23 = fun Fun23_loop(B17, Y19) ->
    case (Y19 < 4) of
        true ->
            try
                X17 = 0,
                Fun22 = fun Fun22_loop(B17, X17, Y19) ->
    case (X17 < 4) of
        true ->
            try
                case (lists:nth(X17 + 1, lists:nth(Y19 + 1, B17)) == 0) of
        true -> throw({return, true});
        _ -> ok
    end,
                case (((X17 + 1) < 4) andalso (lists:nth(X17 + 1, lists:nth(Y19 + 1, B17)) == lists:nth((X17 + 1) + 1, lists:nth(Y19 + 1, B17)))) of
        true -> throw({return, true});
        _ -> ok
    end,
                case (((Y19 + 1) < 4) andalso (lists:nth(X17 + 1, lists:nth(Y19 + 1, B17)) == lists:nth(X17 + 1, lists:nth((Y19 + 1) + 1, B17)))) of
        true -> throw({return, true});
        _ -> ok
    end,
                X18 = (X17 + 1),
                Fun22_loop(B17, X18, Y19)
            catch
                break -> {B17, X17, Y19}
            end;
        _ -> {B17, X17, Y19}
    end
end,
{B17, X18, Y19} = Fun22(B17, X17, Y19),
                Y20 = (Y19 + 1),
                Fun23_loop(B17, Y20)
            catch
                break -> {B17, Y19}
            end;
        _ -> {B17, Y19}
    end
end,
{B17, Y20} = Fun23(B17, Y19),
        false
    catch {return, V} -> V end.

has2048(B18) ->
    try
        Y21 = 0,
        Fun25 = fun Fun25_loop(B18, Y21) ->
    case (Y21 < 4) of
        true ->
            try
                X19 = 0,
                Fun24 = fun Fun24_loop(B18, X19, Y21) ->
    case (X19 < 4) of
        true ->
            try
                case (lists:nth(X19 + 1, lists:nth(Y21 + 1, B18)) >= 2048) of
        true -> throw({return, true});
        _ -> ok
    end,
                X20 = (X19 + 1),
                Fun24_loop(B18, X20, Y21)
            catch
                break -> {B18, X19, Y21}
            end;
        _ -> {B18, X19, Y21}
    end
end,
{B18, X20, Y21} = Fun24(B18, X19, Y21),
                Y22 = (Y21 + 1),
                Fun25_loop(B18, Y22)
            catch
                break -> {B18, Y21}
            end;
        _ -> {B18, Y21}
    end
end,
{B18, Y22} = Fun25(B18, Y21),
        false
    catch {return, V} -> V end.

main(_) ->
    erlang:put('SIZE', 4),
    erlang:put('board', newBoard()),
    erlang:put('r', spawnTile(erlang:get('board'))),
    erlang:put('board', maps:get("board", erlang:get('r'))),
    erlang:put('full', maps:get("full", erlang:get('r'))),
    erlang:put('r', spawnTile(erlang:get('board'))),
    erlang:put('board', maps:get("board", erlang:get('r'))),
    erlang:put('full', maps:get("full", erlang:get('r'))),
    erlang:put('score', 0),
    draw(erlang:get('board'), erlang:get('score')),
    Fun26 = fun Fun26_loop() ->
    case true of
        true ->
            try
                io:format("~ts~n", ["Move: "]),
                Cmd = string:trim(io:get_line("")),
                Moved13 = false,
                case ((Cmd == "a") orelse (Cmd == "A")) of
        true -> M = moveLeft(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M)),
            erlang:put('score', maps:get("score", M)),
            Moved14 = maps:get("moved", M),
            M2 = M,
            Moved15 = Moved14;
        _ -> M2 = nil,
            Moved15 = Moved13
    end,
                case ((Cmd == "d") orelse (Cmd == "D")) of
        true -> M3 = moveRight(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M3)),
            erlang:put('score', maps:get("score", M3)),
            Moved16 = maps:get("moved", M3),
            M4 = M3,
            Moved17 = Moved16;
        _ -> M4 = M2,
            Moved17 = Moved15
    end,
                case ((Cmd == "w") orelse (Cmd == "W")) of
        true -> M5 = moveUp(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M5)),
            erlang:put('score', maps:get("score", M5)),
            Moved18 = maps:get("moved", M5),
            M6 = M5,
            Moved19 = Moved18;
        _ -> M6 = M4,
            Moved19 = Moved17
    end,
                case ((Cmd == "s") orelse (Cmd == "S")) of
        true -> M7 = moveDown(erlang:get('board'), erlang:get('score')),
            erlang:put('board', maps:get("board", M7)),
            erlang:put('score', maps:get("score", M7)),
            Moved20 = maps:get("moved", M7),
            M8 = M7,
            Moved21 = Moved20;
        _ -> M8 = M6,
            Moved21 = Moved19
    end,
                case ((Cmd == "q") orelse (Cmd == "Q")) of
        true -> throw(break);
        _ -> ok
    end,
                case (Moved21 /= nil) of
        true -> R2 = spawnTile(erlang:get('board')),
            erlang:put('board', maps:get("board", R2)),
            erlang:put('full', maps:get("full", R2)),
            case ((erlang:get('full') andalso not hasMoves(erlang:get('board'))) /= nil) of
        true -> draw(erlang:get('board'), erlang:get('score')),
            io:format("~ts~n", ["Game Over"]),
            throw(break);
        _ -> ok
    end,
            R22 = R2;
        _ -> R22 = nil
    end,
                draw(erlang:get('board'), erlang:get('score')),
                case has2048(erlang:get('board')) of
        true -> io:format("~ts~n", ["You win!"]),
            throw(break);
        _ -> ok
    end,
                case not hasMoves(erlang:get('board')) of
        true -> io:format("~ts~n", ["Game Over"]),
            throw(break);
        _ -> ok
    end,
                Fun26_loop()
            catch
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun26().
