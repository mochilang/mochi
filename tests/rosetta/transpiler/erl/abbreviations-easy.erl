#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, fields/1, padright/2, join/2, validate/3, main/0]).

% Generated by Mochi transpiler v0.10.40 (c9f97e1bd3) on 2025-07-25 19:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

fields(S) ->
    try
        Words = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, S, Words) ->
    case (I < length(S)) of
        true ->
            Ch = string:substr(S, I + 1, ((I + 1) - I)),
            case (((Ch == " ") orelse (Ch == "\n")) orelse (Ch == "\t")) of
        true -> case (length(Cur) > 0) of
        true -> Words_2 = lists:append(Words, [Cur]),
            Cur_2 = "",
            Cur_3 = Cur_2,
            Words_3 = Words_2;
        _ -> Cur_3 = Cur,
            Words_3 = Words
    end,
            Cur_5 = Cur_3,
            Words_4 = Words_3;
        _ -> Cur_4 = (Cur ++ Ch),
            Cur_5 = Cur_4,
            Words_4 = Words
    end,
            I_2 = (I + 1),
            Fun_loop(Cur_5, I_2, S, Words_4);
        _ -> {Cur, I, S, Words}
    end
end,
{Cur_5, I_2, S, Words_4} = Fun(Cur, I, S, Words),
        case (length(Cur_5) > 0) of
        true -> Words_5 = lists:append(Words_4, [Cur_5]),
            Words_6 = Words_5;
        _ -> Words_6 = Words_4
    end,
        Words_6
    catch {return, Ret} -> Ret end.

padright(S_2, Width) ->
    try
        Out = S_2,
        I_3 = length(S_2),
        Fun_2 = fun Fun_2_loop(I_3, Out, S_2, Width) ->
    case (I_3 < Width) of
        true ->
            Out_2 = (Out ++ " "),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Out_2, S_2, Width);
        _ -> {I_3, Out, S_2, Width}
    end
end,
{I_4, Out_2, S_2, Width} = Fun_2(I_3, Out, S_2, Width),
        Out_2
    catch {return, Ret} -> Ret end.

join(Xs, Sep) ->
    try
        Res = "",
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(I_5, Res, Sep, Xs) ->
    case (I_5 < length(Xs)) of
        true ->
            case (I_5 > 0) of
        true -> Res_2 = (Res ++ Sep),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Res_4 = (Res_3 ++ lists:nth(I_5 + 1, Xs)),
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, Res_4, Sep, Xs);
        _ -> {I_5, Res, Sep, Xs}
    end
end,
{I_6, Res_4, Sep, Xs} = Fun_3(I_5, Res, Sep, Xs),
        Res_4
    catch {return, Ret} -> Ret end.

validate(Commands, Words_7, Mins) ->
    try
        Results = [],
        case (length(Words_7) == 0) of
        true -> throw({return, Results});
        _ -> ok
    end,
        Wi = 0,
        Fun_5 = fun Fun_5_loop(Commands, Mins, Results, Wi, Words_7) ->
    case (Wi < length(Words_7)) of
        true ->
            try
                W = lists:nth(Wi + 1, Words_7),
                Found = false,
                Wlen = length(W),
                Ci = 0,
                Fun_4 = fun Fun_4_loop(Ci, Commands, Found, Mins, Results, W, Wi, Wlen, Words_7) ->
    case (Ci < length(Commands)) of
        true ->
            try
                Cmd = lists:nth(Ci + 1, Commands),
                case (((lists:nth(Ci + 1, Mins) /= 0) andalso (Wlen >= lists:nth(Ci + 1, Mins))) andalso (Wlen =< length(Cmd))) of
        true -> C = string:to_upper(Cmd),
            Ww = string:to_upper(W),
            case (string:substr(C, 0 + 1, (Wlen - 0)) == Ww) of
        true -> Results_2 = lists:append(Results, [C]),
            Found_2 = true,
            throw(break),
            Found_3 = Found_2,
            Results_3 = Results_2;
        _ -> Found_3 = Found,
            Results_3 = Results
    end,
            C_2 = C,
            Found_4 = Found_3,
            Results_4 = Results_3,
            Ww_2 = Ww;
        _ -> C_2 = nil,
            Found_4 = Found,
            Results_4 = Results,
            Ww_2 = nil
    end,
                Ci_2 = (Ci + 1),
                Fun_4_loop(Ci_2, Commands, Found_4, Mins, Results_4, W, Wi, Wlen, Words_7)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_4_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {Ci, Commands, Found, Mins, Results, W, Wi, Wlen, Words_7}
            end;
        _ -> {Ci, Commands, Found, Mins, Results, W, Wi, Wlen, Words_7}
    end
end,
{Ci_2, Commands, Found_4, Mins, Results_4, W, Wi, Wlen, Words_7} = Fun_4(Ci, Commands, Found, Mins, Results, W, Wi, Wlen, Words_7),
                case not Found_4 of
        true -> Results_5 = lists:append(Results_4, ["*error*"]),
            Results_6 = Results_5;
        _ -> Results_6 = Results_4
    end,
                Wi_2 = (Wi + 1),
                Fun_5_loop(Commands, Mins, Results_6, Wi_2, Words_7)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_5_loop(C0, C1, C2, C3, C4);
                break -> {Commands, Mins, Results, Wi, Words_7}
            end;
        _ -> {Commands, Mins, Results, Wi, Words_7}
    end
end,
{Commands, Mins, Results_6, Wi_2, Words_7} = Fun_5(Commands, Mins, Results, Wi, Words_7),
        Results_6
    catch {return, Ret} -> Ret end.

main() ->
    try
        Table = (((((("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " ++ "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ") ++ "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ") ++ " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ") ++ "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ") ++ "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ") ++ "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "),
        Commands_2 = fields(Table),
        Mins_2 = [],
        I_7 = 0,
        Fun_7 = fun Fun_7_loop(Commands_2, I_7, Mins_2, Table) ->
    case (I_7 < length(Commands_2)) of
        true ->
            Count = 0,
            J = 0,
            Cmd_2 = lists:nth(I_7 + 1, Commands_2),
            Fun_6 = fun Fun_6_loop(Cmd_2, Commands_2, Count, I_7, J, Mins_2, Table) ->
    case (J < length(Cmd_2)) of
        true ->
            Ch_2 = string:substr(Cmd_2, J + 1, ((J + 1) - J)),
            case ((Ch_2 >= "A") andalso (Ch_2 =< "Z")) of
        true -> Count_2 = (Count + 1),
            Count_3 = Count_2;
        _ -> Count_3 = Count
    end,
            J_2 = (J + 1),
            Fun_6_loop(Cmd_2, Commands_2, Count_3, I_7, J_2, Mins_2, Table);
        _ -> {Cmd_2, Commands_2, Count, I_7, J, Mins_2, Table}
    end
end,
{Cmd_2, Commands_2, Count_3, I_7, J_2, Mins_2, Table} = Fun_6(Cmd_2, Commands_2, Count, I_7, J, Mins_2, Table),
            Mins_3 = lists:append(Mins_2, [Count_3]),
            I_8 = (I_7 + 1),
            Fun_7_loop(Commands_2, I_8, Mins_3, Table);
        _ -> {Commands_2, I_7, Mins_2, Table}
    end
end,
{Commands_2, I_8, Mins_3, Table} = Fun_7(Commands_2, I_7, Mins_2, Table),
        Sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin",
        Words_8 = fields("riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"),
        Results_7 = validate(Commands_2, Words_8, Mins_3),
        Out1 = "user words:  ",
        K = 0,
        Fun_8 = fun Fun_8_loop(Commands_2, I_8, K, Mins_3, Out1, Results_7, Sentence, Table, Words_8) ->
    case (K < length(Words_8)) of
        true ->
            Out1_2 = ((Out1 ++ padright(lists:nth(K + 1, Words_8), length(lists:nth(K + 1, Results_7)))) ++ " "),
            K_2 = (K + 1),
            Fun_8_loop(Commands_2, I_8, K_2, Mins_3, Out1_2, Results_7, Sentence, Table, Words_8);
        _ -> {Commands_2, I_8, K, Mins_3, Out1, Results_7, Sentence, Table, Words_8}
    end
end,
{Commands_2, I_8, K_2, Mins_3, Out1_2, Results_7, Sentence, Table, Words_8} = Fun_8(Commands_2, I_8, K, Mins_3, Out1, Results_7, Sentence, Table, Words_8),
        io:format("~ts~n", [Out1_2]),
        io:format("~ts~n", [("full words:  " ++ join(Results_7, " "))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
