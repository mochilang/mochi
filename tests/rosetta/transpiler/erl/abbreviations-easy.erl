#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, fields/1, padRight/2, join/2, validate/3, main/0]).

% Generated by Mochi transpiler v0.10.37 (a60a40ef13) on 2025-07-23 08:17 UTC

fields(S) ->
    try
        Words = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, S, Words) ->
    case (I < length(S)) of
        true ->
            try
                Ch = string:substr(S, I + 1, ((I + 1) - I)),
                case (((Ch == " ") orelse (Ch == "\n")) orelse (Ch == "\t")) of
        true -> case (length(Cur) > 0) of
        true -> Words2 = lists:append(Words, [Cur]),
            Cur2 = "",
            Cur3 = Cur2,
            Words3 = Words2;
        _ -> Cur3 = Cur,
            Words3 = Words
    end,
            Cur5 = Cur3,
            Words4 = Words3;
        _ -> Cur4 = (Cur ++ Ch),
            Cur5 = Cur4,
            Words4 = Words
    end,
                I2 = (I + 1),
                Fun_loop(Cur5, I2, S, Words4)
            catch
                break -> {Cur, I, S, Words}
            end;
        _ -> {Cur, I, S, Words}
    end
end,
{Cur5, I2, S, Words4} = Fun(Cur, I, S, Words),
        case (length(Cur5) > 0) of
        true -> Words5 = lists:append(Words4, [Cur5]),
            Words6 = Words5;
        _ -> Words6 = Words4
    end,
        Words6
    catch {return, V} -> V end.

padRight(S2, Width) ->
    try
        Out = S2,
        I3 = length(S2),
        Fun2 = fun Fun2_loop(I3, Out, S2, Width) ->
    case (I3 < Width) of
        true ->
            try
                Out2 = (Out ++ " "),
                I4 = (I3 + 1),
                Fun2_loop(I4, Out2, S2, Width)
            catch
                break -> {I3, Out, S2, Width}
            end;
        _ -> {I3, Out, S2, Width}
    end
end,
{I4, Out2, S2, Width} = Fun2(I3, Out, S2, Width),
        Out2
    catch {return, V} -> V end.

join(Xs, Sep) ->
    try
        Res = "",
        I5 = 0,
        Fun3 = fun Fun3_loop(I5, Res, Sep, Xs) ->
    case (I5 < length(Xs)) of
        true ->
            try
                case (I5 > 0) of
        true -> Res2 = (Res ++ Sep),
            Res3 = Res2;
        _ -> Res3 = Res
    end,
                Res4 = (Res3 ++ lists:nth(I5 + 1, Xs)),
                I6 = (I5 + 1),
                Fun3_loop(I6, Res4, Sep, Xs)
            catch
                break -> {I5, Res, Sep, Xs}
            end;
        _ -> {I5, Res, Sep, Xs}
    end
end,
{I6, Res4, Sep, Xs} = Fun3(I5, Res, Sep, Xs),
        Res4
    catch {return, V} -> V end.

validate(Commands, Words7, Mins) ->
    try
        Results = [],
        case (length(Words7) == 0) of
        true -> throw({return, Results});
        _ -> ok
    end,
        Wi = 0,
        Fun5 = fun Fun5_loop(Commands, Mins, Results, Wi, Words7) ->
    case (Wi < length(Words7)) of
        true ->
            try
                W = lists:nth(Wi + 1, Words7),
                Found = false,
                Wlen = length(W),
                Ci = 0,
                Fun4 = fun Fun4_loop(Ci, Commands, Found, Mins, Results, W, Wi, Wlen, Words7) ->
    case (Ci < length(Commands)) of
        true ->
            try
                Cmd = lists:nth(Ci + 1, Commands),
                case (((lists:nth(Ci + 1, Mins) /= 0) andalso (Wlen >= lists:nth(Ci + 1, Mins))) andalso (Wlen =< length(Cmd))) of
        true -> C = string:to_upper(Cmd),
            Ww = string:to_upper(W),
            case (string:substr(C, 0 + 1, (Wlen - 0)) == Ww) of
        true -> Results2 = lists:append(Results, [C]),
            Found2 = true,
            throw(break),
            Found3 = Found2,
            Results3 = Results2;
        _ -> Found3 = Found,
            Results3 = Results
    end,
            C2 = C,
            Found4 = Found3,
            Results4 = Results3,
            Ww2 = Ww;
        _ -> C2 = nil,
            Found4 = Found,
            Results4 = Results,
            Ww2 = nil
    end,
                Ci2 = (Ci + 1),
                Fun4_loop(Ci2, Commands, Found4, Mins, Results4, W, Wi, Wlen, Words7)
            catch
                break -> {Ci, Commands, Found, Mins, Results, W, Wi, Wlen, Words7}
            end;
        _ -> {Ci, Commands, Found, Mins, Results, W, Wi, Wlen, Words7}
    end
end,
{Ci2, Commands, Found4, Mins, Results4, W, Wi, Wlen, Words7} = Fun4(Ci, Commands, Found, Mins, Results, W, Wi, Wlen, Words7),
                case not Found4 of
        true -> Results5 = lists:append(Results4, ["*error*"]),
            Results6 = Results5;
        _ -> Results6 = Results4
    end,
                Wi2 = (Wi + 1),
                Fun5_loop(Commands, Mins, Results6, Wi2, Words7)
            catch
                break -> {Commands, Mins, Results, Wi, Words7}
            end;
        _ -> {Commands, Mins, Results, Wi, Words7}
    end
end,
{Commands, Mins, Results6, Wi2, Words7} = Fun5(Commands, Mins, Results, Wi, Words7),
        Results6
    catch {return, V} -> V end.

main() ->
    try
        Table = (((((("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy " ++ "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ") ++ "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ") ++ " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ") ++ "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ") ++ "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ") ++ "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "),
        Commands2 = fields(Table),
        Mins2 = [],
        I7 = 0,
        Fun7 = fun Fun7_loop(Commands2, I7, Mins2, Table) ->
    case (I7 < length(Commands2)) of
        true ->
            try
                Count = 0,
                J = 0,
                Cmd2 = lists:nth(I7 + 1, Commands2),
                Fun6 = fun Fun6_loop(Cmd2, Commands2, Count, I7, J, Mins2, Table) ->
    case (J < length(Cmd2)) of
        true ->
            try
                Ch2 = string:substr(Cmd2, J + 1, ((J + 1) - J)),
                case ((Ch2 >= "A") andalso (Ch2 =< "Z")) of
        true -> Count2 = (Count + 1),
            Count3 = Count2;
        _ -> Count3 = Count
    end,
                J2 = (J + 1),
                Fun6_loop(Cmd2, Commands2, Count3, I7, J2, Mins2, Table)
            catch
                break -> {Cmd2, Commands2, Count, I7, J, Mins2, Table}
            end;
        _ -> {Cmd2, Commands2, Count, I7, J, Mins2, Table}
    end
end,
{Cmd2, Commands2, Count3, I7, J2, Mins2, Table} = Fun6(Cmd2, Commands2, Count, I7, J, Mins2, Table),
                Mins3 = lists:append(Mins2, [Count3]),
                I8 = (I7 + 1),
                Fun7_loop(Commands2, I8, Mins3, Table)
            catch
                break -> {Commands2, I7, Mins2, Table}
            end;
        _ -> {Commands2, I7, Mins2, Table}
    end
end,
{Commands2, I8, Mins3, Table} = Fun7(Commands2, I7, Mins2, Table),
        Sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin",
        Words8 = fields("riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"),
        Results7 = validate(Commands2, Words8, Mins3),
        Out1 = "user words:  ",
        K = 0,
        Fun8 = fun Fun8_loop(Commands2, I8, K, Mins3, Out1, Results7, Sentence, Table, Words8) ->
    case (K < length(Words8)) of
        true ->
            try
                Out12 = ((Out1 ++ padRight(lists:nth(K + 1, Words8), length(lists:nth(K + 1, Results7)))) ++ " "),
                K2 = (K + 1),
                Fun8_loop(Commands2, I8, K2, Mins3, Out12, Results7, Sentence, Table, Words8)
            catch
                break -> {Commands2, I8, K, Mins3, Out1, Results7, Sentence, Table, Words8}
            end;
        _ -> {Commands2, I8, K, Mins3, Out1, Results7, Sentence, Table, Words8}
    end
end,
{Commands2, I8, K2, Mins3, Out12, Results7, Sentence, Table, Words8} = Fun8(Commands2, I8, K, Mins3, Out1, Results7, Sentence, Table, Words8),
        io:format("~ts~n", [Out12]),
        io:format("~ts~n", [("full words:  " ++ join(Results7, " "))]),
        nil
    catch {return, V} -> V end.

main(_) ->
    main().
