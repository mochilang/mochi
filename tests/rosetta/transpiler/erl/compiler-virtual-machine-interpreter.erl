#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, parseintstr/1, fields/1, unescape/1, parseprogram/1, runvm/1, trim/1, split/2, main/0]).

% Generated by Mochi transpiler v0.10.41 (df7e5d4e15) on 2025-07-27 05:47 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_parse_int_str(S) ->
    try list_to_integer(S) catch _:_ -> 0 end.

parseintstr(Str) ->
    try
        I = 0,
        Neg = false,
        case ((length(Str) > 0) andalso (string:substr(Str, 0 + 1, (1 - 0)) == "-")) of
        true -> Neg_2 = true,
            I_2 = 1,
            I_3 = I_2,
            Neg_3 = Neg_2;
        _ -> I_3 = I,
            Neg_3 = Neg
    end,
        N = 0,
        Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
        Fun = fun Fun_loop(Digits, I_3, N, Neg_3, Str) ->
    case (I_3 < length(Str)) of
        true ->
            N_2 = ((N * 10) + maps:get(string:substr(Str, I_3 + 1, ((I_3 + 1) - I_3)), Digits, nil)),
            I_4 = (I_3 + 1),
            Fun_loop(Digits, I_4, N_2, Neg_3, Str);
        _ -> {Digits, I_3, N, Neg_3, Str}
    end
end,
{Digits, I_4, N_2, Neg_3, Str} = Fun(Digits, I_3, N, Neg_3, Str),
        case Neg_3 of
        true -> N_3 = -N_2,
            N_4 = N_3;
        _ -> N_4 = N_2
    end,
        N_4
    catch {return, Ret} -> Ret end.

fields(S) ->
    try
        Words = [],
        Cur = "",
        I_5 = 0,
        Fun_2 = fun Fun_2_loop(Cur, I_5, S, Words) ->
    case (I_5 < length(S)) of
        true ->
            Ch = string:substr(S, I_5 + 1, ((I_5 + 1) - I_5)),
            case (((Ch == " ") orelse (Ch == "\t")) orelse (Ch == "\n")) of
        true -> case (length(Cur) > 0) of
        true -> Words_2 = lists:append(Words, [Cur]),
            Cur_2 = "",
            Cur_3 = Cur_2,
            Words_3 = Words_2;
        _ -> Cur_3 = Cur,
            Words_3 = Words
    end,
            Cur_5 = Cur_3,
            Words_4 = Words_3;
        _ -> Cur_4 = (Cur ++ Ch),
            Cur_5 = Cur_4,
            Words_4 = Words
    end,
            I_6 = (I_5 + 1),
            Fun_2_loop(Cur_5, I_6, S, Words_4);
        _ -> {Cur, I_5, S, Words}
    end
end,
{Cur_5, I_6, S, Words_4} = Fun_2(Cur, I_5, S, Words),
        case (length(Cur_5) > 0) of
        true -> Words_5 = lists:append(Words_4, [Cur_5]),
            Words_6 = Words_5;
        _ -> Words_6 = Words_4
    end,
        Words_6
    catch {return, Ret} -> Ret end.

unescape(S_2) ->
    try
        Out = "",
        I_7 = 0,
        Fun_3 = fun Fun_3_loop(I_7, Out, S_2) ->
    case (I_7 < length(S_2)) of
        true ->
            try
                case ((string:substr(S_2, I_7 + 1, ((I_7 + 1) - I_7)) == "\\") andalso ((I_7 + 1) < length(S_2))) of
        true -> C = string:substr(S_2, (I_7 + 1) + 1, ((I_7 + 2) - (I_7 + 1))),
            case (C == "n") of
        true -> Out_2 = (Out ++ "\n"),
            I_8 = (I_7 + 2),
            throw({continue, I_8, Out_2, S_2}),
            I_11 = I_8,
            Out_5 = Out_2;
        _ -> case (C == "\\") of
        true -> Out_3 = (Out ++ "\\"),
            I_9 = (I_7 + 2),
            throw({continue, I_9, Out_3, S_2}),
            I_10 = I_9,
            Out_4 = Out_3;
        _ -> I_10 = I_7,
            Out_4 = Out
    end,
            I_11 = I_10,
            Out_5 = Out_4
    end,
            C_2 = C,
            I_12 = I_11,
            Out_6 = Out_5;
        _ -> C_2 = nil,
            I_12 = I_7,
            Out_6 = Out
    end,
                Out_7 = (Out_6 ++ string:substr(S_2, I_12 + 1, ((I_12 + 1) - I_12))),
                I_13 = (I_12 + 1),
                Fun_3_loop(I_13, Out_7, S_2)
            catch
                {continue, C0, C1, C2} -> Fun_3_loop(C0, C1, C2);
                break -> {I_7, Out, S_2}
            end;
        _ -> {I_7, Out, S_2}
    end
end,
{I_13, Out_7, S_2} = Fun_3(I_7, Out, S_2),
        Out_7
    catch {return, Ret} -> Ret end.

parseprogram(Src) ->
    try
        Lines = split(Src, "\n"),
        Header = fields(lists:nth(0 + 1, Lines)),
        DataSize = mochi_parse_int_str(lists:nth(1 + 1, Header)),
        NStrings = mochi_parse_int_str(lists:nth(3 + 1, Header)),
        StringPool = [],
        I_14 = 1,
        Fun_4 = fun Fun_4_loop(DataSize, Header, I_14, Lines, NStrings, Src, StringPool) ->
    case (I_14 =< NStrings) of
        true ->
            S_3 = lists:nth(I_14 + 1, Lines),
            case (length(S_3) > 0) of
        true -> StringPool_2 = lists:append(StringPool, [unescape(lists:sublist(S_3, 1 + 1, ((length(S_3) - 1) - 1)))]),
            StringPool_3 = StringPool_2;
        _ -> StringPool_3 = StringPool
    end,
            I_15 = (I_14 + 1),
            Fun_4_loop(DataSize, Header, I_15, Lines, NStrings, Src, StringPool_3);
        _ -> {DataSize, Header, I_14, Lines, NStrings, Src, StringPool}
    end
end,
{DataSize, Header, I_15, Lines, NStrings, Src, StringPool_3} = Fun_4(DataSize, Header, I_14, Lines, NStrings, Src, StringPool),
        Code = [],
        AddrMap = #{},
        Fun_5 = fun Fun_5_loop(AddrMap, Code, DataSize, Header, I_15, Lines, NStrings, Src, StringPool_3) ->
    case (I_15 < length(Lines)) of
        true ->
            try
                Line = trim(lists:nth(I_15 + 1, Lines)),
                case (length(Line) == 0) of
        true -> throw(break);
        _ -> ok
    end,
                Parts = fields(Line),
                Addr = mochi_parse_int_str(lists:nth(0 + 1, Parts)),
                Op = lists:nth(1 + 1, Parts),
                Arg = 0,
                case (Op == "push") of
        true -> Arg_2 = mochi_parse_int_str(lists:nth(2 + 1, Parts)),
            Arg_7 = Arg_2;
        _ -> case ((Op == "fetch") orelse (Op == "store")) of
        true -> Arg_3 = mochi_parse_int_str(lists:sublist(lists:nth(2 + 1, Parts), 1 + 1, ((length(lists:nth(2 + 1, Parts)) - 1) - 1))),
            Arg_6 = Arg_3;
        _ -> case ((Op == "jmp") orelse (Op == "jz")) of
        true -> Arg_4 = mochi_parse_int_str(lists:nth(3 + 1, Parts)),
            Arg_5 = Arg_4;
        _ -> Arg_5 = Arg
    end,
            Arg_6 = Arg_5
    end,
            Arg_7 = Arg_6
    end,
                Code_2 = lists:append(Code, [#{"addr" => Addr, "op" => Op, "arg" => Arg_7}]),
                AddrMap_2 = maps:put(Addr, (length(Code_2) - 1), AddrMap),
                I_16 = (I_15 + 1),
                Fun_5_loop(AddrMap_2, Code_2, DataSize, Header, I_16, Lines, NStrings, Src, StringPool_3)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_5_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {AddrMap, Code, DataSize, Header, I_15, Lines, NStrings, Src, StringPool_3}
            end;
        _ -> {AddrMap, Code, DataSize, Header, I_15, Lines, NStrings, Src, StringPool_3}
    end
end,
{AddrMap_2, Code_2, DataSize, Header, I_16, Lines, NStrings, Src, StringPool_3} = Fun_5(AddrMap, Code, DataSize, Header, I_15, Lines, NStrings, Src, StringPool_3),
        #{"dataSize" => DataSize, "strings" => StringPool_3, "code" => Code_2, "addrMap" => AddrMap_2}
    catch {return, Ret} -> Ret end.

runvm(Prog) ->
    try
        Data = [],
        I_17 = 0,
        Fun_6 = fun Fun_6_loop(Data, I_17, Prog) ->
    case (I_17 < maps:get("dataSize", Prog, nil)) of
        true ->
            Data_2 = lists:append(Data, [0]),
            I_18 = (I_17 + 1),
            Fun_6_loop(Data_2, I_18, Prog);
        _ -> {Data, I_17, Prog}
    end
end,
{Data_2, I_18, Prog} = Fun_6(Data, I_17, Prog),
        Stack = [],
        Pc = 0,
        Code_3 = maps:get("code", Prog, nil),
        AddrMap_3 = maps:get("addrMap", Prog, nil),
        Pool = maps:get("strings", Prog, nil),
        Line_2 = "",
        Fun_7 = fun Fun_7_loop(AddrMap_3, Code_3, Data_2, I_18, Line_2, Pc, Pool, Prog, Stack) ->
    case (Pc < length(Code_3)) of
        true ->
            try
                Inst = lists:nth(Pc + 1, Code_3),
                Op_2 = maps:get("op", Inst, nil),
                Arg_8 = maps:get("arg", Inst, nil),
                case (Op_2 == "push") of
        true -> Stack_2 = lists:append(Stack, [Arg_8]),
            Pc_2 = (Pc + 1),
            throw({continue, AddrMap_3, Code_3, Data_2, I_18, Line_2, Pc_2, Pool, Prog, Stack_2}),
            Pc_3 = Pc_2,
            Stack_3 = Stack_2;
        _ -> Pc_3 = Pc,
            Stack_3 = Stack
    end,
                case (Op_2 == "store") of
        true -> Data_3 = lists:sublist(Data_2, Arg_8) ++ [lists:nth((length(Stack_3) - 1) + 1, Stack_3)] ++ lists:nthtail(Arg_8 + 1, Data_2),
            Stack_4 = slice(Stack_3, 0, (length(Stack_3) - 1)),
            Pc_4 = (Pc_3 + 1),
            throw({continue, AddrMap_3, Code_3, Data_3, I_18, Line_2, Pc_4, Pool, Prog, Stack_4}),
            Data_4 = Data_3,
            Pc_5 = Pc_4,
            Stack_5 = Stack_4;
        _ -> Data_4 = Data_2,
            Pc_5 = Pc_3,
            Stack_5 = Stack_3
    end,
                case (Op_2 == "fetch") of
        true -> Stack_6 = lists:append(Stack_5, [lists:nth(Arg_8 + 1, Data_4)]),
            Pc_6 = (Pc_5 + 1),
            throw({continue, AddrMap_3, Code_3, Data_4, I_18, Line_2, Pc_6, Pool, Prog, Stack_6}),
            Pc_7 = Pc_6,
            Stack_7 = Stack_6;
        _ -> Pc_7 = Pc_5,
            Stack_7 = Stack_5
    end,
                case (Op_2 == "add") of
        true -> Stack_8 = lists:sublist(Stack_7, (length(Stack_7) - 2)) ++ [(lists:nth((length(Stack_7) - 2) + 1, Stack_7) + lists:nth((length(Stack_7) - 1) + 1, Stack_7))] ++ lists:nthtail((length(Stack_7) - 2) + 1, Stack_7),
            Stack_9 = slice(Stack_8, 0, (length(Stack_8) - 1)),
            Pc_8 = (Pc_7 + 1),
            throw({continue, AddrMap_3, Code_3, Data_4, I_18, Line_2, Pc_8, Pool, Prog, Stack_9}),
            Pc_9 = Pc_8,
            Stack_10 = Stack_9;
        _ -> Pc_9 = Pc_7,
            Stack_10 = Stack_7
    end,
                case (Op_2 == "lt") of
        true -> V = 0,
            case (lists:nth((length(Stack_10) - 2) + 1, Stack_10) < lists:nth((length(Stack_10) - 1) + 1, Stack_10)) of
        true -> V_2 = 1,
            V_3 = V_2;
        _ -> V_3 = V
    end,
            Stack_11 = lists:sublist(Stack_10, (length(Stack_10) - 2)) ++ [V_3] ++ lists:nthtail((length(Stack_10) - 2) + 1, Stack_10),
            Stack_12 = slice(Stack_11, 0, (length(Stack_11) - 1)),
            Pc_10 = (Pc_9 + 1),
            throw({continue, AddrMap_3, Code_3, Data_4, I_18, Line_2, Pc_10, Pool, Prog, Stack_12}),
            Pc_11 = Pc_10,
            Stack_13 = Stack_12,
            V_4 = V_3;
        _ -> Pc_11 = Pc_9,
            Stack_13 = Stack_10,
            V_4 = nil
    end,
                case (Op_2 == "jz") of
        true -> V_5 = lists:nth((length(Stack_13) - 1) + 1, Stack_13),
            Stack_14 = slice(Stack_13, 0, (length(Stack_13) - 1)),
            case (V_5 == 0) of
        true -> Pc_12 = lists:nth(Arg_8 + 1, AddrMap_3),
            Pc_14 = Pc_12;
        _ -> Pc_13 = (Pc_11 + 1),
            Pc_14 = Pc_13
    end,
            throw({continue, AddrMap_3, Code_3, Data_4, I_18, Line_2, Pc_14, Pool, Prog, Stack_14}),
            Pc_15 = Pc_14,
            Stack_15 = Stack_14,
            V_6 = V_5;
        _ -> Pc_15 = Pc_11,
            Stack_15 = Stack_13,
            V_6 = V_4
    end,
                case (Op_2 == "jmp") of
        true -> Pc_16 = lists:nth(Arg_8 + 1, AddrMap_3),
            throw({continue, AddrMap_3, Code_3, Data_4, I_18, Line_2, Pc_16, Pool, Prog, Stack_15}),
            Pc_17 = Pc_16;
        _ -> Pc_17 = Pc_15
    end,
                case (Op_2 == "prts") of
        true -> S_4 = lists:nth(lists:nth((length(Stack_15) - 1) + 1, Stack_15) + 1, Pool),
            Stack_16 = slice(Stack_15, 0, (length(Stack_15) - 1)),
            case (S_4 /= "\n") of
        true -> Line_3 = (Line_2 ++ S_4),
            Line_4 = Line_3;
        _ -> Line_4 = Line_2
    end,
            Pc_18 = (Pc_17 + 1),
            throw({continue, AddrMap_3, Code_3, Data_4, I_18, Line_4, Pc_18, Pool, Prog, Stack_16}),
            Line_5 = Line_4,
            Pc_19 = Pc_18,
            S_5 = S_4,
            Stack_17 = Stack_16;
        _ -> Line_5 = Line_2,
            Pc_19 = Pc_17,
            S_5 = nil,
            Stack_17 = Stack_15
    end,
                case (Op_2 == "prti") of
        true -> Line_6 = (Line_5 ++ lists:flatten(io_lib:format("~p", [lists:nth((length(Stack_17) - 1) + 1, Stack_17)]))),
            io:format("~ts~n", [Line_6]),
            Line_7 = "",
            Stack_18 = slice(Stack_17, 0, (length(Stack_17) - 1)),
            Pc_20 = (Pc_19 + 1),
            throw({continue, AddrMap_3, Code_3, Data_4, I_18, Line_7, Pc_20, Pool, Prog, Stack_18}),
            Line_8 = Line_7,
            Pc_21 = Pc_20,
            Stack_19 = Stack_18;
        _ -> Line_8 = Line_5,
            Pc_21 = Pc_19,
            Stack_19 = Stack_17
    end,
                case (Op_2 == "halt") of
        true -> throw(break);
        _ -> ok
    end,
                Pc_22 = (Pc_21 + 1),
                Fun_7_loop(AddrMap_3, Code_3, Data_4, I_18, Line_8, Pc_22, Pool, Prog, Stack_19)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_7_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {AddrMap_3, Code_3, Data_2, I_18, Line_2, Pc, Pool, Prog, Stack}
            end;
        _ -> {AddrMap_3, Code_3, Data_2, I_18, Line_2, Pc, Pool, Prog, Stack}
    end
end,
{AddrMap_3, Code_3, Data_4, I_18, Line_8, Pc_22, Pool, Prog, Stack_19} = Fun_7(AddrMap_3, Code_3, Data_2, I_18, Line_2, Pc, Pool, Prog, Stack),
        nil
    catch {return, Ret} -> Ret end.

trim(S_6) ->
    try
        Start = 0,
        Fun_8 = fun Fun_8_loop(S_6, Start) ->
    case ((Start < length(S_6)) andalso ((string:substr(S_6, Start + 1, ((Start + 1) - Start)) == " ") orelse (string:substr(S_6, Start + 1, ((Start + 1) - Start)) == "\t"))) of
        true ->
            Start_2 = (Start + 1),
            Fun_8_loop(S_6, Start_2);
        _ -> {S_6, Start}
    end
end,
{S_6, Start_2} = Fun_8(S_6, Start),
        End = length(S_6),
        Fun_9 = fun Fun_9_loop(End, S_6, Start_2) ->
    case ((End > Start_2) andalso ((string:substr(S_6, (End - 1) + 1, (End - (End - 1))) == " ") orelse (string:substr(S_6, (End - 1) + 1, (End - (End - 1))) == "\t"))) of
        true ->
            End_2 = (End - 1),
            Fun_9_loop(End_2, S_6, Start_2);
        _ -> {End, S_6, Start_2}
    end
end,
{End_2, S_6, Start_2} = Fun_9(End, S_6, Start_2),
        string:substr(S_6, Start_2 + 1, (End_2 - Start_2))
    catch {return, Ret} -> Ret end.

split(S_7, Sep) ->
    try
        Parts_2 = [],
        Cur_6 = "",
        I_19 = 0,
        Fun_10 = fun Fun_10_loop(Cur_6, I_19, Parts_2, S_7, Sep) ->
    case (I_19 < length(S_7)) of
        true ->
            case (((length(Sep) > 0) andalso ((I_19 + length(Sep)) =< length(S_7))) andalso (string:substr(S_7, I_19 + 1, ((I_19 + length(Sep)) - I_19)) == Sep)) of
        true -> Parts_3 = lists:append(Parts_2, [Cur_6]),
            Cur_7 = "",
            I_20 = (I_19 + length(Sep)),
            Cur_9 = Cur_7,
            I_22 = I_20,
            Parts_4 = Parts_3;
        _ -> Cur_8 = (Cur_6 ++ string:substr(S_7, I_19 + 1, ((I_19 + 1) - I_19))),
            I_21 = (I_19 + 1),
            Cur_9 = Cur_8,
            I_22 = I_21,
            Parts_4 = Parts_2
    end,
            Fun_10_loop(Cur_9, I_22, Parts_4, S_7, Sep);
        _ -> {Cur_6, I_19, Parts_2, S_7, Sep}
    end
end,
{Cur_9, I_22, Parts_4, S_7, Sep} = Fun_10(Cur_6, I_19, Parts_2, S_7, Sep),
        Parts_5 = lists:append(Parts_4, [Cur_9]),
        Parts_5
    catch {return, Ret} -> Ret end.

main() ->
    try
        ProgramText = (((((((((((((((((((("Datasize: 1 Strings: 2\n" ++ "\"count is: \"\n") ++ "\"\\n\"\n") ++ "    0 push  1\n") ++ "    5 store [0]\n") ++ "   10 fetch [0]\n") ++ "   15 push  10\n") ++ "   20 lt\n") ++ "   21 jz     (43) 65\n") ++ "   26 push  0\n") ++ "   31 prts\n") ++ "   32 fetch [0]\n") ++ "   37 prti\n") ++ "   38 push  1\n") ++ "   43 prts\n") ++ "   44 fetch [0]\n") ++ "   49 push  1\n") ++ "   54 add\n") ++ "   55 store [0]\n") ++ "   60 jmp    (-51) 10\n") ++ "   65 halt\n"),
        Prog_2 = parseprogram(ProgramText),
        runvm(Prog_2),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
