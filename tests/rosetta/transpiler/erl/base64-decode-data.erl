#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, indexof/2, parseintstr/1, ord/1, chr/1, tobinary/2, bintoint/1, base64encode/1, base64decode/1]).

% Generated by Mochi transpiler v0.10.40 (305ff8442f) on 2025-07-25 12:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

indexof(S, Ch) ->
    try
        I = 0,
        Fun = fun Fun_loop(Ch, I, S) ->
    case (I < length(S)) of
        true ->
            case (string:substr(S, I + 1, 1) == Ch) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, I_2, S);
        _ -> {Ch, I, S}
    end
end,
{Ch, I_2, S} = Fun(Ch, I, S),
        -1
    catch {return, Ret} -> Ret end.

parseintstr(Str) ->
    try
        I_3 = 0,
        Neg = false,
        case ((length(Str) > 0) andalso (string:substr(Str, 0 + 1, 1) == "-")) of
        true -> Neg_2 = true,
            I_4 = 1,
            I_5 = I_4,
            Neg_3 = Neg_2;
        _ -> I_5 = I_3,
            Neg_3 = Neg
    end,
        N = 0,
        Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
        Fun_2 = fun Fun_2_loop(Digits, I_5, N, Neg_3, Str) ->
    case (I_5 < length(Str)) of
        true ->
            N_2 = ((N * 10) + maps:get(string:substr(Str, I_5 + 1, 1), Digits, nil)),
            I_6 = (I_5 + 1),
            Fun_2_loop(Digits, I_6, N_2, Neg_3, Str);
        _ -> {Digits, I_5, N, Neg_3, Str}
    end
end,
{Digits, I_6, N_2, Neg_3, Str} = Fun_2(Digits, I_5, N, Neg_3, Str),
        case Neg_3 of
        true -> N_3 = -N_2,
            N_4 = N_3;
        _ -> N_4 = N_2
    end,
        N_4
    catch {return, Ret} -> Ret end.

ord(Ch_2) ->
    try
        Upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Lower = "abcdefghijklmnopqrstuvwxyz",
        Idx = indexof("ABCDEFGHIJKLMNOPQRSTUVWXYZ", Ch_2),
        case (Idx >= 0) of
        true -> throw({return, (65 + Idx)});
        _ -> ok
    end,
        Idx_2 = indexof("abcdefghijklmnopqrstuvwxyz", Ch_2),
        case (Idx_2 >= 0) of
        true -> throw({return, (97 + Idx_2)});
        _ -> ok
    end,
        case ((Ch_2 >= "0") andalso (Ch_2 =< "9")) of
        true -> throw({return, (48 + parseintstr(Ch_2))});
        _ -> ok
    end,
        case (Ch_2 == "+") of
        true -> throw({return, 43});
        _ -> ok
    end,
        case (Ch_2 == "/") of
        true -> throw({return, 47});
        _ -> ok
    end,
        case (Ch_2 == " ") of
        true -> throw({return, 32});
        _ -> ok
    end,
        case (Ch_2 == "=") of
        true -> throw({return, 61});
        _ -> ok
    end,
        0
    catch {return, Ret} -> Ret end.

chr(N_5) ->
    try
        Upper_2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Lower_2 = "abcdefghijklmnopqrstuvwxyz",
        case ((N_5 >= 65) andalso (N_5 < 91)) of
        true -> throw({return, string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", (N_5 - 65) + 1, ((N_5 - 64) - (N_5 - 65)))});
        _ -> ok
    end,
        case ((N_5 >= 97) andalso (N_5 < 123)) of
        true -> throw({return, string:substr("abcdefghijklmnopqrstuvwxyz", (N_5 - 97) + 1, ((N_5 - 96) - (N_5 - 97)))});
        _ -> ok
    end,
        case ((N_5 >= 48) andalso (N_5 < 58)) of
        true -> Digits_2 = "0123456789",
            throw({return, string:substr("0123456789", (N_5 - 48) + 1, ((N_5 - 47) - (N_5 - 48)))}),
            Digits_3 = Digits_2;
        _ -> Digits_3 = nil
    end,
        case (N_5 == 43) of
        true -> throw({return, "+"});
        _ -> ok
    end,
        case (N_5 == 47) of
        true -> throw({return, "/"});
        _ -> ok
    end,
        case (N_5 == 32) of
        true -> throw({return, " "});
        _ -> ok
    end,
        case (N_5 == 61) of
        true -> throw({return, "="});
        _ -> ok
    end,
        "?"
    catch {return, Ret} -> Ret end.

tobinary(N_6, Bits) ->
    try
        B = "",
        Val = N_6,
        I_7 = 0,
        Fun_3 = fun Fun_3_loop(B, Bits, I_7, N_6, Val) ->
    case (I_7 < Bits) of
        true ->
            B_2 = (lists:flatten(io_lib:format("~p", [(Val rem 2)])) ++ B),
            Val_2 = mochi_to_int((Val div 2)),
            I_8 = (I_7 + 1),
            Fun_3_loop(B_2, Bits, I_8, N_6, Val_2);
        _ -> {B, Bits, I_7, N_6, Val}
    end
end,
{B_2, Bits, I_8, N_6, Val_2} = Fun_3(B, Bits, I_7, N_6, Val),
        B_2
    catch {return, Ret} -> Ret end.

bintoint(Bits_2) ->
    try
        N_7 = 0,
        I_9 = 0,
        Fun_4 = fun Fun_4_loop(Bits_2, I_9, N_7) ->
    case (I_9 < length(Bits_2)) of
        true ->
            N_8 = ((N_7 * 2) + parseintstr(string:substr(Bits_2, I_9 + 1, ((I_9 + 1) - I_9)))),
            I_10 = (I_9 + 1),
            Fun_4_loop(Bits_2, I_10, N_8);
        _ -> {Bits_2, I_9, N_7}
    end
end,
{Bits_2, I_10, N_8} = Fun_4(Bits_2, I_9, N_7),
        N_8
    catch {return, Ret} -> Ret end.

base64encode(Text) ->
    try
        Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        Bin = "",
        Fun_5 = fun Fun_5_loop(List, Alphabet, Bin, Text) ->
    case List of
        [] -> {Alphabet, Bin, Text};
        [Ch_3|List_rest] ->
            Bin_2 = (Bin ++ tobinary(ord(Ch_3), 8)),
            Fun_5_loop(List_rest, Alphabet, Bin_2, Text)
    end
end,
{Alphabet, Bin_2, Text} = Fun_5(Text, Alphabet, Bin, Text),
        Fun_6 = fun Fun_6_loop(Alphabet, Bin_2, Text) ->
    case ((length(Bin_2) rem 6) /= 0) of
        true ->
            Bin_3 = (Bin_2 ++ "0"),
            Fun_6_loop(Alphabet, Bin_3, Text);
        _ -> {Alphabet, Bin_2, Text}
    end
end,
{Alphabet, Bin_3, Text} = Fun_6(Alphabet, Bin_2, Text),
        Out = "",
        I_11 = 0,
        Fun_7 = fun Fun_7_loop(Alphabet, Bin_3, I_11, Out, Text) ->
    case (I_11 < length(Bin_3)) of
        true ->
            Chunk = string:substr(Bin_3, I_11 + 1, ((I_11 + 6) - I_11)),
            Val_3 = bintoint(Chunk),
            Out_2 = (Out ++ string:substr(Alphabet, Val_3 + 1, ((Val_3 + 1) - Val_3))),
            I_12 = (I_11 + 6),
            Fun_7_loop(Alphabet, Bin_3, I_12, Out_2, Text);
        _ -> {Alphabet, Bin_3, I_11, Out, Text}
    end
end,
{Alphabet, Bin_3, I_12, Out_2, Text} = Fun_7(Alphabet, Bin_3, I_11, Out, Text),
        Pad = ((3 - (length(Text) rem 3)) rem 3),
        case (Pad == 1) of
        true -> Out_3 = (string:substr(Out_2, 0 + 1, ((length(Out_2) - 1) - 0)) ++ "="),
            Out_4 = Out_3;
        _ -> Out_4 = Out_2
    end,
        case (Pad == 2) of
        true -> Out_5 = (string:substr(Out_4, 0 + 1, ((length(Out_4) - 2) - 0)) ++ "=="),
            Out_6 = Out_5;
        _ -> Out_6 = Out_4
    end,
        Out_6
    catch {return, Ret} -> Ret end.

base64decode(Enc) ->
    try
        Alphabet_2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        Bin_4 = "",
        I_13 = 0,
        Fun_8 = fun Fun_8_loop(Alphabet_2, Bin_4, Enc, I_13) ->
    case (I_13 < length(Enc)) of
        true ->
            try
                Ch_4 = string:substr(Enc, I_13 + 1, 1),
                case (Ch_4 == "=") of
        true -> throw(break);
        _ -> ok
    end,
                Idx_3 = indexof(Alphabet_2, Ch_4),
                Bin_5 = (Bin_4 ++ tobinary(Idx_3, 6)),
                I_14 = (I_13 + 1),
                Fun_8_loop(Alphabet_2, Bin_5, Enc, I_14)
            catch
                {continue, C0, C1, C2, C3} -> Fun_8_loop(C0, C1, C2, C3);
                break -> {Alphabet_2, Bin_4, Enc, I_13}
            end;
        _ -> {Alphabet_2, Bin_4, Enc, I_13}
    end
end,
{Alphabet_2, Bin_5, Enc, I_14} = Fun_8(Alphabet_2, Bin_4, Enc, I_13),
        Out_7 = "",
        I_15 = 0,
        Fun_9 = fun Fun_9_loop(Alphabet_2, Bin_5, Enc, I_15, Out_7) ->
    case ((I_15 + 8) =< length(Bin_5)) of
        true ->
            Chunk_2 = string:substr(Bin_5, I_15 + 1, ((I_15 + 8) - I_15)),
            Val_4 = bintoint(Chunk_2),
            Out_8 = (Out_7 ++ chr(Val_4)),
            I_16 = (I_15 + 8),
            Fun_9_loop(Alphabet_2, Bin_5, Enc, I_16, Out_8);
        _ -> {Alphabet_2, Bin_5, Enc, I_15, Out_7}
    end
end,
{Alphabet_2, Bin_5, Enc, I_16, Out_8} = Fun_9(Alphabet_2, Bin_5, Enc, I_15, Out_7),
        Out_8
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('msg', "Rosetta Code Base64 decode data task"),
    io:format("~ts~n", [("Original : " ++ "Rosetta Code Base64 decode data task")]),
    erlang:put('enc', base64encode("Rosetta Code Base64 decode data task")),
    io:format("~ts~n", [("\nEncoded  : " ++ erlang:get('enc'))]),
    erlang:put('dec', base64decode(erlang:get('enc'))),
    io:format("~ts~n", [("\nDecoded  : " ++ erlang:get('dec'))]),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
