#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, floydwarshall/1, path/3, pathstr/1]).

% Generated by Mochi transpiler v0.10.52 (400654db0c) on 2025-08-01 10:34 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

floydwarshall(Graph) ->
    try
        N = length(Graph),
        Dist = [],
        Next = [],
        I = 0,
        Fun_2 = fun Fun_2_loop(Dist, Graph, I, N, Next) ->
    case (I < N) of
        true ->
            Drow = [],
            Nrow = [],
            J = 0,
            Fun = fun Fun_loop(Dist, Drow, Graph, I, J, N, Next, Nrow) ->
    case (J < N) of
        true ->
            Drow_2 = lists:append(Drow, [lists:nth(J + 1, lists:nth(I + 1, Graph))]),
            case ((lists:nth(J + 1, lists:nth(I + 1, Graph)) < 1000000) andalso (I /= J)) of
        true -> Nrow_2 = lists:append(Nrow, [J]),
            Nrow_4 = Nrow_2;
        _ -> Nrow_3 = lists:append(Nrow, [-1]),
            Nrow_4 = Nrow_3
    end,
            J_2 = (J + 1),
            Fun_loop(Dist, Drow_2, Graph, I, J_2, N, Next, Nrow_4);
        _ -> {Dist, Drow, Graph, I, J, N, Next, Nrow}
    end
end,
{Dist, Drow_2, Graph, I, J_2, N, Next, Nrow_4} = Fun(Dist, Drow, Graph, I, J, N, Next, Nrow),
            Dist_2 = lists:append(Dist, [Drow_2]),
            Next_2 = lists:append(Next, [Nrow_4]),
            I_2 = (I + 1),
            Fun_2_loop(Dist_2, Graph, I_2, N, Next_2);
        _ -> {Dist, Graph, I, N, Next}
    end
end,
{Dist_2, Graph, I_2, N, Next_2} = Fun_2(Dist, Graph, I, N, Next),
        K = 0,
        Fun_5 = fun Fun_5_loop(Dist_2, Graph, I_2, K, N, Next_2) ->
    case (K < N) of
        true ->
            I_3 = 0,
            Fun_4 = fun Fun_4_loop(Dist_2, Graph, I_3, K, N, Next_2) ->
    case (I_3 < N) of
        true ->
            J_3 = 0,
            Fun_3 = fun Fun_3_loop(Dist_2, Graph, I_3, J_3, K, N, Next_2) ->
    case (J_3 < N) of
        true ->
            case ((lists:nth(K + 1, lists:nth(I_3 + 1, Dist_2)) < 1000000) andalso (lists:nth(J_3 + 1, lists:nth(K + 1, Dist_2)) < 1000000)) of
        true -> Alt = (lists:nth(K + 1, lists:nth(I_3 + 1, Dist_2)) + lists:nth(J_3 + 1, lists:nth(K + 1, Dist_2))),
            case (Alt < lists:nth(J_3 + 1, lists:nth(I_3 + 1, Dist_2))) of
        true -> Tmp = lists:nth(I_3 + 1, Dist_2),
            Tmp_2 = lists:sublist(Tmp, J_3) ++ [Alt] ++ lists:nthtail(J_3 + 1, Tmp),
            Dist_3 = lists:sublist(Dist_2, I_3) ++ [Tmp_2] ++ lists:nthtail(I_3 + 1, Dist_2),
            Tmp_3 = lists:nth(I_3 + 1, Next_2),
            Tmp_4 = lists:sublist(Tmp_3, J_3) ++ [lists:nth(K + 1, lists:nth(I_3 + 1, Next_2))] ++ lists:nthtail(J_3 + 1, Tmp_3),
            Next_3 = lists:sublist(Next_2, I_3) ++ [Tmp_4] ++ lists:nthtail(I_3 + 1, Next_2),
            Dist_4 = Dist_3,
            Next_4 = Next_3,
            Tmp_5 = Tmp_4;
        _ -> Dist_4 = Dist_2,
            Next_4 = Next_2,
            Tmp_5 = nil
    end,
            Alt_2 = Alt,
            Dist_5 = Dist_4,
            Next_5 = Next_4,
            Tmp_6 = Tmp_5;
        _ -> Alt_2 = nil,
            Dist_5 = Dist_2,
            Next_5 = Next_2,
            Tmp_6 = nil
    end,
            J_4 = (J_3 + 1),
            Fun_3_loop(Dist_5, Graph, I_3, J_4, K, N, Next_5);
        _ -> {Dist_2, Graph, I_3, J_3, K, N, Next_2}
    end
end,
{Dist_5, Graph, I_3, J_4, K, N, Next_5} = Fun_3(Dist_2, Graph, I_3, J_3, K, N, Next_2),
            I_4 = (I_3 + 1),
            Fun_4_loop(Dist_5, Graph, I_4, K, N, Next_5);
        _ -> {Dist_2, Graph, I_3, K, N, Next_2}
    end
end,
{Dist_5, Graph, I_4, K, N, Next_5} = Fun_4(Dist_2, Graph, I_3, K, N, Next_2),
            K_2 = (K + 1),
            Fun_5_loop(Dist_5, Graph, I_4, K_2, N, Next_5);
        _ -> {Dist_2, Graph, I_2, K, N, Next_2}
    end
end,
{Dist_5, Graph, I_4, K_2, N, Next_5} = Fun_5(Dist_2, Graph, I_2, K, N, Next_2),
        #{"dist" => Dist_5, "next" => Next_5}
    catch {return, Ret} -> Ret end.

path(U, V, Next_6) ->
    try
        case (lists:nth(V + 1, lists:nth(U + 1, Next_6)) < 0) of
        true -> throw({return, []});
        _ -> ok
    end,
        P = [U],
        X = U,
        Fun_6 = fun Fun_6_loop(Next_6, P, U, V, X) ->
    case (X /= V) of
        true ->
            X_2 = lists:nth(V + 1, lists:nth(X + 1, Next_6)),
            P_2 = lists:append(P, [X_2]),
            Fun_6_loop(Next_6, P_2, U, V, X_2);
        _ -> {Next_6, P, U, V, X}
    end
end,
{Next_6, P_2, U, V, X_2} = Fun_6(Next_6, P, U, V, X),
        P_2
    catch {return, Ret} -> Ret end.

pathstr(P_3) ->
    try
        S = "",
        I_5 = 0,
        Fun_7 = fun Fun_7_loop(I_5, P_3, S) ->
    case (I_5 < length(P_3)) of
        true ->
            S_2 = (S ++ lists:flatten(io_lib:format("~p", [(lists:nth(I_5 + 1, P_3) + 1)]))),
            case (I_5 < (length(P_3) - 1)) of
        true -> S_3 = (S_2 ++ " -> "),
            S_4 = S_3;
        _ -> S_4 = S_2
    end,
            I_6 = (I_5 + 1),
            Fun_7_loop(I_6, P_3, S_4);
        _ -> {I_5, P_3, S}
    end
end,
{I_6, P_3, S_4} = Fun_7(I_5, P_3, S),
        S_4
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('INF', 1000000),
    erlang:put('n', 4),
    erlang:put('g', []),
    Fun_8 = fun Fun_8_loop(List) ->
    case List of
        [] -> {};
        [I_7|I_7_rest] ->
            Row = [],
            Fun_9 = fun Fun_9_loop(List, I_7, Row) ->
    case List of
        [] -> {I_7, Row};
        [J_5|J_5_rest] ->
            case (I_7 == J_5) of
        true -> Row_2 = lists:append(Row, [0]),
            Row_4 = Row_2;
        _ -> Row_3 = lists:append(Row, [1000000]),
            Row_4 = Row_3
    end,
            Fun_9_loop(J_5_rest, I_7, Row_4)
    end
end,
{I_7, Row_4} = Fun_9(lists:seq(0, (4) - 1), I_7, Row),
            erlang:put('g', lists:append(erlang:get('g'), [Row_4])),
            Fun_8_loop(I_7_rest)
    end
end,
{} = Fun_8(lists:seq(0, (4) - 1)),
    G = erlang:get('g'),
    Tmp_7 = lists:nth(0 + 1, G),
    Tmp_8 = lists:sublist(Tmp_7, 2) ++ [-2] ++ lists:nthtail(2 + 1, Tmp_7),
    G_2 = lists:sublist(G, 0) ++ [Tmp_8] ++ lists:nthtail(0 + 1, G),
    erlang:put('g', G_2),
    G_3 = erlang:get('g'),
    Tmp_9 = lists:nth(2 + 1, G_3),
    Tmp_10 = lists:sublist(Tmp_9, 3) ++ [2] ++ lists:nthtail(3 + 1, Tmp_9),
    G_4 = lists:sublist(G_3, 2) ++ [Tmp_10] ++ lists:nthtail(2 + 1, G_3),
    erlang:put('g', G_4),
    G_5 = erlang:get('g'),
    Tmp_11 = lists:nth(3 + 1, G_5),
    Tmp_12 = lists:sublist(Tmp_11, 1) ++ [-1] ++ lists:nthtail(1 + 1, Tmp_11),
    G_6 = lists:sublist(G_5, 3) ++ [Tmp_12] ++ lists:nthtail(3 + 1, G_5),
    erlang:put('g', G_6),
    G_7 = erlang:get('g'),
    Tmp_13 = lists:nth(1 + 1, G_7),
    Tmp_14 = lists:sublist(Tmp_13, 0) ++ [4] ++ lists:nthtail(0 + 1, Tmp_13),
    G_8 = lists:sublist(G_7, 1) ++ [Tmp_14] ++ lists:nthtail(1 + 1, G_7),
    erlang:put('g', G_8),
    G_9 = erlang:get('g'),
    Tmp_15 = lists:nth(1 + 1, G_9),
    Tmp_16 = lists:sublist(Tmp_15, 2) ++ [3] ++ lists:nthtail(2 + 1, Tmp_15),
    G_10 = lists:sublist(G_9, 1) ++ [Tmp_16] ++ lists:nthtail(1 + 1, G_9),
    erlang:put('g', G_10),
    erlang:put('res', floydwarshall(erlang:get('g'))),
    io:format("~ts~n", ["pair\tdist\tpath"]),
    erlang:put('i', 0),
    Fun_11 = fun Fun_11_loop(G_10, Tmp_16) ->
    case (erlang:get('i') < 4) of
        true ->
            J_6 = 0,
            Fun_10 = fun Fun_10_loop(G_10, J_6, Tmp_16) ->
    case (J_6 < 4) of
        true ->
            case (erlang:get('i') /= J_6) of
        true -> P_4 = path(erlang:get('i'), J_6, maps:get("next", erlang:get('res'), nil)),
            io:format("~ts~n", [((((((lists:flatten(io_lib:format("~p", [(erlang:get('i') + 1)])) ++ " -> ") ++ lists:flatten(io_lib:format("~p", [(J_6 + 1)]))) ++ "\t") ++ lists:flatten(io_lib:format("~p", [lists:nth(J_6 + 1, lists:nth(erlang:get('i') + 1, maps:get("dist", erlang:get('res'), nil)))]))) ++ "\t") ++ pathstr(P_4))]),
            P_5 = P_4;
        _ -> P_5 = nil
    end,
            J_7 = (J_6 + 1),
            Fun_10_loop(G_10, J_7, Tmp_16);
        _ -> {G_10, J_6, Tmp_16}
    end
end,
{G_10, J_7, Tmp_16} = Fun_10(G_10, J_6, Tmp_16),
            erlang:put('i', (erlang:get('i') + 1)),
            Fun_11_loop(G_10, Tmp_16);
        _ -> {G_10, Tmp_16}
    end
end,
{G_10, Tmp_16} = Fun_11(G_10, Tmp_16),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
