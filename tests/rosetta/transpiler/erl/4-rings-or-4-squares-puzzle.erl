#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, validComb/7, isUnique/7, getCombs/3]).

% Generated by Mochi transpiler v0.10.37 (f35599b4cc) on 2025-07-23 13:23 +0700

validComb(A, B, C, D, E, F, G) ->
    try
        Square1 = (A + B),
        Square2 = ((B + C) + D),
        Square3 = ((D + E) + F),
        Square4 = (F + G),
        (((Square1 == Square2) andalso (Square2 == Square3)) andalso (Square3 == Square4))
    catch {return, V} -> V end.

isUnique(A2, B2, C2, D2, E2, F2, G2) ->
    try
        Nums = [A2, B2, C2, D2, E2, F2, G2],
        I = 0,
        Fun2 = fun Fun2_loop(A2, B2, C2, D2, E2, F2, G2, I, Nums) ->
    case (I < length(Nums)) of
        true ->
            try
                J = (I + 1),
                Fun = fun Fun_loop(A2, B2, C2, D2, E2, F2, G2, I, J, Nums) ->
    case (J < length(Nums)) of
        true ->
            try
                case (lists:nth(I + 1, Nums) == lists:nth(J + 1, Nums)) of
        true -> throw({return, false});
        _ -> ok
    end,
                J2 = (J + 1),
                Fun_loop(A2, B2, C2, D2, E2, F2, G2, I, J2, Nums)
            catch
                break -> {A2, B2, C2, D2, E2, F2, G2, I, J, Nums}
            end;
        _ -> {A2, B2, C2, D2, E2, F2, G2, I, J, Nums}
    end
end,
{A2, B2, C2, D2, E2, F2, G2, I, J2, Nums} = Fun(A2, B2, C2, D2, E2, F2, G2, I, J, Nums),
                I2 = (I + 1),
                Fun2_loop(A2, B2, C2, D2, E2, F2, G2, I2, Nums)
            catch
                break -> {A2, B2, C2, D2, E2, F2, G2, I, Nums}
            end;
        _ -> {A2, B2, C2, D2, E2, F2, G2, I, Nums}
    end
end,
{A2, B2, C2, D2, E2, F2, G2, I2, Nums} = Fun2(A2, B2, C2, D2, E2, F2, G2, I, Nums),
        true
    catch {return, V} -> V end.

getCombs(Low, High, Unique) ->
    try
        Valid = [],
        Count = 0,
        Fun3 = fun Fun3_loop(List, Count, High, Low, Unique, Valid) ->
    case List of
        [] -> {Count, High, Low, Unique, Valid};
        [B3|Fun3_loop_rest] ->
        try
            Fun4 = fun Fun4_loop(List, B3, Count, High, Low, Unique, Valid) ->
    case List of
        [] -> {B3, Count, High, Low, Unique, Valid};
        [C3|Fun4_loop_rest] ->
        try
            Fun5 = fun Fun5_loop(List, B3, C3, Count, High, Low, Unique, Valid) ->
    case List of
        [] -> {B3, C3, Count, High, Low, Unique, Valid};
        [D3|Fun5_loop_rest] ->
        try
            S = ((B3 + C3) + D3),
            Fun6 = fun Fun6_loop(List, B3, C3, Count, D3, High, Low, S, Unique, Valid) ->
    case List of
        [] -> {B3, C3, Count, D3, High, Low, S, Unique, Valid};
        [E3|Fun6_loop_rest] ->
        try
            Fun7 = fun Fun7_loop(List, B3, C3, Count, D3, E3, High, Low, S, Unique, Valid) ->
    case List of
        [] -> {B3, C3, Count, D3, E3, High, Low, S, Unique, Valid};
        [F3|Fun7_loop_rest] ->
        try
            A3 = (S - B3),
            G3 = (S - F3),
            case ((A3 < Low) orelse (A3 > High)) of
        true -> throw(continue);
        _ -> ok
    end,
            case ((G3 < Low) orelse (G3 > High)) of
        true -> throw(continue);
        _ -> ok
    end,
            case (((D3 + E3) + F3) /= S) of
        true -> throw(continue);
        _ -> ok
    end,
            case ((F3 + G3) /= S) of
        true -> throw(continue);
        _ -> ok
    end,
            case (not Unique orelse isUnique(A3, B3, C3, D3, E3, F3, G3)) of
        true -> Valid2 = lists:append(Valid, [[A3, B3, C3, D3, E3, F3, G3]]),
            Count2 = (Count + 1),
            Count3 = Count2,
            Valid3 = Valid2;
        _ -> Count3 = Count,
            Valid3 = Valid
    end,
            Fun7_loop(Fun7_loop_rest, B3, C3, Count3, D3, E3, High, Low, S, Unique, Valid3)
        catch
            continue -> Fun7_loop(Fun7_loop_rest, B3, C3, Count, D3, E3, High, Low, S, Unique, Valid);
            break -> {B3, C3, Count, D3, E3, High, Low, S, Unique, Valid}
        end
    end
end,
{B3, C3, Count3, D3, E3, High, Low, S, Unique, Valid3} = Fun7(lists:seq(Low, ((High + 1)) - 1), B3, C3, Count, D3, E3, High, Low, S, Unique, Valid),
            Fun6_loop(Fun6_loop_rest, B3, C3, Count3, D3, High, Low, S, Unique, Valid3)
        catch
            continue -> Fun6_loop(Fun6_loop_rest, B3, C3, Count, D3, High, Low, S, Unique, Valid);
            break -> {B3, C3, Count, D3, High, Low, S, Unique, Valid}
        end
    end
end,
{B3, C3, Count3, D3, High, Low, S, Unique, Valid3} = Fun6(lists:seq(Low, ((High + 1)) - 1), B3, C3, Count, D3, High, Low, S, Unique, Valid),
            Fun5_loop(Fun5_loop_rest, B3, C3, Count3, High, Low, Unique, Valid3)
        catch
            continue -> Fun5_loop(Fun5_loop_rest, B3, C3, Count, High, Low, Unique, Valid);
            break -> {B3, C3, Count, High, Low, Unique, Valid}
        end
    end
end,
{B3, C3, Count3, High, Low, Unique, Valid3} = Fun5(lists:seq(Low, ((High + 1)) - 1), B3, C3, Count, High, Low, Unique, Valid),
            Fun4_loop(Fun4_loop_rest, B3, Count3, High, Low, Unique, Valid3)
        catch
            continue -> Fun4_loop(Fun4_loop_rest, B3, Count, High, Low, Unique, Valid);
            break -> {B3, Count, High, Low, Unique, Valid}
        end
    end
end,
{B3, Count3, High, Low, Unique, Valid3} = Fun4(lists:seq(Low, ((High + 1)) - 1), B3, Count, High, Low, Unique, Valid),
            Fun3_loop(Fun3_loop_rest, Count3, High, Low, Unique, Valid3)
        catch
            continue -> Fun3_loop(Fun3_loop_rest, Count, High, Low, Unique, Valid);
            break -> {Count, High, Low, Unique, Valid}
        end
    end
end,
{Count3, High, Low, Unique, Valid3} = Fun3(lists:seq(Low, ((High + 1)) - 1), Count, High, Low, Unique, Valid),
        #{"count" => Count3, "list" => Valid3}
    catch {return, V} -> V end.

main(_) ->
    erlang:put('r1', getCombs(1, 7, true)),
    io:format("~ts~n", [(lists:flatten(io_lib:format("~p", [maps:get("count", erlang:get('r1'))])) ++ " unique solutions in 1 to 7")]),
    io:format("~p~n", [maps:get("list", erlang:get('r1'))]),
    erlang:put('r2', getCombs(3, 9, true)),
    io:format("~ts~n", [(lists:flatten(io_lib:format("~p", [maps:get("count", erlang:get('r2'))])) ++ " unique solutions in 3 to 9")]),
    io:format("~p~n", [maps:get("list", erlang:get('r2'))]),
    erlang:put('r3', getCombs(0, 9, false)),
    io:format("~ts~n", [(lists:flatten(io_lib:format("~p", [maps:get("count", erlang:get('r3'))])) ++ " non-unique solutions in 0 to 9")]).
