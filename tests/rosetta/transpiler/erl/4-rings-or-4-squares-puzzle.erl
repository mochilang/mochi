#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, validcomb/7, isunique/7, getcombs/3]).

% Generated by Mochi transpiler v0.10.40 (6bb4e4bd23) on 2025-07-25 19:02 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

validcomb(A, B, C, D, E, F, G) ->
    try
        Square1 = (A + B),
        Square2 = ((B + C) + D),
        Square3 = ((D + E) + F),
        Square4 = (F + G),
        (((Square1 == Square2) andalso (Square2 == Square3)) andalso (Square3 == Square4))
    catch {return, Ret} -> Ret end.

isunique(A_2, B_2, C_2, D_2, E_2, F_2, G_2) ->
    try
        Nums = [A_2, B_2, C_2, D_2, E_2, F_2, G_2],
        I = 0,
        Fun_2 = fun Fun_2_loop(A_2, B_2, C_2, D_2, E_2, F_2, G_2, I, Nums) ->
    case (I < length(Nums)) of
        true ->
            J = (I + 1),
            Fun = fun Fun_loop(A_2, B_2, C_2, D_2, E_2, F_2, G_2, I, J, Nums) ->
    case (J < length(Nums)) of
        true ->
            case (lists:nth(I + 1, Nums) == lists:nth(J + 1, Nums)) of
        true -> throw({return, false});
        _ -> ok
    end,
            J_2 = (J + 1),
            Fun_loop(A_2, B_2, C_2, D_2, E_2, F_2, G_2, I, J_2, Nums);
        _ -> {A_2, B_2, C_2, D_2, E_2, F_2, G_2, I, J, Nums}
    end
end,
{A_2, B_2, C_2, D_2, E_2, F_2, G_2, I, J_2, Nums} = Fun(A_2, B_2, C_2, D_2, E_2, F_2, G_2, I, J, Nums),
            I_2 = (I + 1),
            Fun_2_loop(A_2, B_2, C_2, D_2, E_2, F_2, G_2, I_2, Nums);
        _ -> {A_2, B_2, C_2, D_2, E_2, F_2, G_2, I, Nums}
    end
end,
{A_2, B_2, C_2, D_2, E_2, F_2, G_2, I_2, Nums} = Fun_2(A_2, B_2, C_2, D_2, E_2, F_2, G_2, I, Nums),
        true
    catch {return, Ret} -> Ret end.

getcombs(Low, High, Unique) ->
    try
        Valid = [],
        Count = 0,
        Fun_3 = fun Fun_3_loop(List, Count, High, Low, Unique, Valid) ->
    case List of
        [] -> {Count, High, Low, Unique, Valid};
        [B_3|B_3_rest] ->
        try
            Fun_4 = fun Fun_4_loop(List, B_3, Count, High, Low, Unique, Valid) ->
    case List of
        [] -> {B_3, Count, High, Low, Unique, Valid};
        [C_3|C_3_rest] ->
        try
            Fun_5 = fun Fun_5_loop(List, B_3, C_3, Count, High, Low, Unique, Valid) ->
    case List of
        [] -> {B_3, C_3, Count, High, Low, Unique, Valid};
        [D_3|D_3_rest] ->
        try
            S = ((B_3 + C_3) + D_3),
            Fun_6 = fun Fun_6_loop(List, B_3, C_3, Count, D_3, High, Low, S, Unique, Valid) ->
    case List of
        [] -> {B_3, C_3, Count, D_3, High, Low, S, Unique, Valid};
        [E_3|E_3_rest] ->
        try
            Fun_7 = fun Fun_7_loop(List, B_3, C_3, Count, D_3, E_3, High, Low, S, Unique, Valid) ->
    case List of
        [] -> {B_3, C_3, Count, D_3, E_3, High, Low, S, Unique, Valid};
        [F_3|F_3_rest] ->
        try
            A_3 = (S - B_3),
            G_3 = (S - F_3),
            case ((A_3 < Low) orelse (A_3 > High)) of
        true -> throw({continue, B_3, C_3, Count, D_3, E_3, High, Low, S, Unique, Valid});
        _ -> ok
    end,
            case ((G_3 < Low) orelse (G_3 > High)) of
        true -> throw({continue, B_3, C_3, Count, D_3, E_3, High, Low, S, Unique, Valid});
        _ -> ok
    end,
            case (((D_3 + E_3) + F_3) /= S) of
        true -> throw({continue, B_3, C_3, Count, D_3, E_3, High, Low, S, Unique, Valid});
        _ -> ok
    end,
            case ((F_3 + G_3) /= S) of
        true -> throw({continue, B_3, C_3, Count, D_3, E_3, High, Low, S, Unique, Valid});
        _ -> ok
    end,
            case (not Unique orelse isunique(A_3, B_3, C_3, D_3, E_3, F_3, G_3)) of
        true -> Valid_2 = lists:append(Valid, [[A_3, B_3, C_3, D_3, E_3, F_3, G_3]]),
            Count_2 = (Count + 1),
            Count_3 = Count_2,
            Valid_3 = Valid_2;
        _ -> Count_3 = Count,
            Valid_3 = Valid
    end,
            Fun_7_loop(F_3_rest, B_3, C_3, Count_3, D_3, E_3, High, Low, S, Unique, Valid_3)
        catch
            {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9} -> Fun_7_loop(F_3_rest, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9);
            {break, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8, B9};
            break -> {B_3, C_3, Count, D_3, E_3, High, Low, S, Unique, Valid}
        end
    end
end,
{B_3, C_3, Count_3, D_3, E_3, High, Low, S, Unique, Valid_3} = Fun_7(lists:seq(Low, ((High + 1)) - 1), B_3, C_3, Count, D_3, E_3, High, Low, S, Unique, Valid),
            Fun_6_loop(E_3_rest, B_3, C_3, Count_3, D_3, High, Low, S, Unique, Valid_3)
        catch
            {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_6_loop(E_3_rest, C0, C1, C2, C3, C4, C5, C6, C7, C8);
            {break, B0, B1, B2, B3, B4, B5, B6, B7, B8} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8};
            break -> {B_3, C_3, Count, D_3, High, Low, S, Unique, Valid}
        end
    end
end,
{B_3, C_3, Count_3, D_3, High, Low, S, Unique, Valid_3} = Fun_6(lists:seq(Low, ((High + 1)) - 1), B_3, C_3, Count, D_3, High, Low, S, Unique, Valid),
            Fun_5_loop(D_3_rest, B_3, C_3, Count_3, High, Low, Unique, Valid_3)
        catch
            {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_5_loop(D_3_rest, C0, C1, C2, C3, C4, C5, C6);
            {break, B0, B1, B2, B3, B4, B5, B6} -> {B0, B1, B2, B3, B4, B5, B6};
            break -> {B_3, C_3, Count, High, Low, Unique, Valid}
        end
    end
end,
{B_3, C_3, Count_3, High, Low, Unique, Valid_3} = Fun_5(lists:seq(Low, ((High + 1)) - 1), B_3, C_3, Count, High, Low, Unique, Valid),
            Fun_4_loop(C_3_rest, B_3, Count_3, High, Low, Unique, Valid_3)
        catch
            {continue, C0, C1, C2, C3, C4, C5} -> Fun_4_loop(C_3_rest, C0, C1, C2, C3, C4, C5);
            {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5};
            break -> {B_3, Count, High, Low, Unique, Valid}
        end
    end
end,
{B_3, Count_3, High, Low, Unique, Valid_3} = Fun_4(lists:seq(Low, ((High + 1)) - 1), B_3, Count, High, Low, Unique, Valid),
            Fun_3_loop(B_3_rest, Count_3, High, Low, Unique, Valid_3)
        catch
            {continue, C0, C1, C2, C3, C4} -> Fun_3_loop(B_3_rest, C0, C1, C2, C3, C4);
            {break, B0, B1, B2, B3, B4} -> {B0, B1, B2, B3, B4};
            break -> {Count, High, Low, Unique, Valid}
        end
    end
end,
{Count_3, High, Low, Unique, Valid_3} = Fun_3(lists:seq(Low, ((High + 1)) - 1), Count, High, Low, Unique, Valid),
        #{"count" => Count_3, "list" => Valid_3}
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('r1', getcombs(1, 7, true)),
    io:format("~ts~n", [(lists:flatten(io_lib:format("~p", [maps:get("count", erlang:get('r1'), nil)])) ++ " unique solutions in 1 to 7")]),
    io:format("~p~n", [maps:get("list", erlang:get('r1'), nil)]),
    erlang:put('r2', getcombs(3, 9, true)),
    io:format("~ts~n", [(lists:flatten(io_lib:format("~p", [maps:get("count", erlang:get('r2'), nil)])) ++ " unique solutions in 3 to 9")]),
    io:format("~p~n", [maps:get("list", erlang:get('r2'), nil)]),
    erlang:put('r3', getcombs(0, 9, false)),
    io:format("~ts~n", [(lists:flatten(io_lib:format("~p", [maps:get("count", erlang:get('r3'), nil)])) ++ " non-unique solutions in 0 to 9")]),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
