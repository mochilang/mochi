#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, nextrand/1, shufflechars/2, bestshuffle/2, main/0]).

% Generated by Mochi transpiler v0.10.40 (305ff8442f) on 2025-07-25 12:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_pad_start(S, Len, Ch) ->
    Fill0 = case Ch of
        "" -> " ";
        _ -> Ch
    end,
    Fill = string:substr(Fill0, 1, 1),
    SL = length(S),
    case SL >= Len of
        true -> S;
        _ -> string:copies(Fill, Len - SL) ++ S
    end.

nextrand(Seed) ->
    try
        (((Seed * 1664525) + 1013904223) rem 2147483647)
    catch {return, Ret} -> Ret end.

shufflechars(S, Seed_2) ->
    try
        Chars = [],
        I = 0,
        Fun = fun Fun_loop(Chars, I, S, Seed_2) ->
    case (I < length(S)) of
        true ->
            Chars_2 = lists:append(Chars, [string:substr(S, I + 1, ((I + 1) - I))]),
            I_2 = (I + 1),
            Fun_loop(Chars_2, I_2, S, Seed_2);
        _ -> {Chars, I, S, Seed_2}
    end
end,
{Chars_2, I_2, S, Seed_2} = Fun(Chars, I, S, Seed_2),
        Sd = Seed_2,
        Idx = (length(Chars_2) - 1),
        Fun_2 = fun Fun_2_loop(Chars_2, I_2, Idx, S, Sd, Seed_2) ->
    case (Idx > 0) of
        true ->
            Sd_2 = nextrand(Sd),
            J = (Sd_2 rem (Idx + 1)),
            Tmp = lists:nth(Idx + 1, Chars_2),
            Chars_3 = lists:sublist(Chars_2, Idx) ++ [lists:nth(J + 1, Chars_2)] ++ lists:nthtail(Idx + 1, Chars_2),
            Chars_4 = lists:sublist(Chars_3, J) ++ [Tmp] ++ lists:nthtail(J + 1, Chars_3),
            Idx_2 = (Idx - 1),
            Fun_2_loop(Chars_4, I_2, Idx_2, S, Sd_2, Seed_2);
        _ -> {Chars_2, I_2, Idx, S, Sd, Seed_2}
    end
end,
{Chars_4, I_2, Idx_2, S, Sd_2, Seed_2} = Fun_2(Chars_2, I_2, Idx, S, Sd, Seed_2),
        Res = "",
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Chars_4, I_3, Idx_2, Res, S, Sd_2, Seed_2) ->
    case (I_3 < length(Chars_4)) of
        true ->
            Res_2 = (Res ++ lists:nth(I_3 + 1, Chars_4)),
            I_4 = (I_3 + 1),
            Fun_3_loop(Chars_4, I_4, Idx_2, Res_2, S, Sd_2, Seed_2);
        _ -> {Chars_4, I_3, Idx_2, Res, S, Sd_2, Seed_2}
    end
end,
{Chars_4, I_4, Idx_2, Res_2, S, Sd_2, Seed_2} = Fun_3(Chars_4, I_3, Idx_2, Res, S, Sd_2, Seed_2),
        [Res_2, Sd_2]
    catch {return, Ret} -> Ret end.

bestshuffle(S_2, Seed_3) ->
    try
        R = shufflechars(S_2, Seed_3),
        T = lists:nth(0 + 1, R),
        Sd_3 = lists:nth(1 + 1, R),
        Arr = [],
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(Arr, I_5, R, S_2, Sd_3, Seed_3, T) ->
    case (I_5 < length(T)) of
        true ->
            Arr_2 = lists:append(Arr, [string:substr(T, I_5 + 1, ((I_5 + 1) - I_5))]),
            I_6 = (I_5 + 1),
            Fun_4_loop(Arr_2, I_6, R, S_2, Sd_3, Seed_3, T);
        _ -> {Arr, I_5, R, S_2, Sd_3, Seed_3, T}
    end
end,
{Arr_2, I_6, R, S_2, Sd_3, Seed_3, T} = Fun_4(Arr, I_5, R, S_2, Sd_3, Seed_3, T),
        I_7 = 0,
        Fun_6 = fun Fun_6_loop(Arr_2, I_7, R, S_2, Sd_3, Seed_3, T) ->
    case (I_7 < length(Arr_2)) of
        true ->
            try
                J_2 = 0,
                Fun_5 = fun Fun_5_loop(Arr_2, I_7, J_2, R, S_2, Sd_3, Seed_3, T) ->
    case (J_2 < length(Arr_2)) of
        true ->
            try
                case (((I_7 /= J_2) andalso (lists:nth(I_7 + 1, Arr_2) /= string:substr(S_2, J_2 + 1, ((J_2 + 1) - J_2)))) andalso (lists:nth(J_2 + 1, Arr_2) /= string:substr(S_2, I_7 + 1, ((I_7 + 1) - I_7)))) of
        true -> Tmp_2 = lists:nth(I_7 + 1, Arr_2),
            Arr_3 = lists:sublist(Arr_2, I_7) ++ [lists:nth(J_2 + 1, Arr_2)] ++ lists:nthtail(I_7 + 1, Arr_2),
            Arr_4 = lists:sublist(Arr_3, J_2) ++ [Tmp_2] ++ lists:nthtail(J_2 + 1, Arr_3),
            throw(break),
            Arr_5 = Arr_4,
            Tmp_3 = Tmp_2;
        _ -> Arr_5 = Arr_2,
            Tmp_3 = nil
    end,
                J_3 = (J_2 + 1),
                Fun_5_loop(Arr_5, I_7, J_3, R, S_2, Sd_3, Seed_3, T)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7} -> Fun_5_loop(C0, C1, C2, C3, C4, C5, C6, C7);
                break -> {Arr_2, I_7, J_2, R, S_2, Sd_3, Seed_3, T}
            end;
        _ -> {Arr_2, I_7, J_2, R, S_2, Sd_3, Seed_3, T}
    end
end,
{Arr_5, I_7, J_3, R, S_2, Sd_3, Seed_3, T} = Fun_5(Arr_2, I_7, J_2, R, S_2, Sd_3, Seed_3, T),
                I_8 = (I_7 + 1),
                Fun_6_loop(Arr_5, I_8, R, S_2, Sd_3, Seed_3, T)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_6_loop(C0, C1, C2, C3, C4, C5, C6);
                break -> {Arr_2, I_7, R, S_2, Sd_3, Seed_3, T}
            end;
        _ -> {Arr_2, I_7, R, S_2, Sd_3, Seed_3, T}
    end
end,
{Arr_5, I_8, R, S_2, Sd_3, Seed_3, T} = Fun_6(Arr_2, I_7, R, S_2, Sd_3, Seed_3, T),
        Count = 0,
        I_9 = 0,
        Fun_7 = fun Fun_7_loop(Arr_5, Count, I_9, R, S_2, Sd_3, Seed_3, T) ->
    case (I_9 < length(Arr_5)) of
        true ->
            case (lists:nth(I_9 + 1, Arr_5) == string:substr(S_2, I_9 + 1, ((I_9 + 1) - I_9))) of
        true -> Count_2 = (Count + 1),
            Count_3 = Count_2;
        _ -> Count_3 = Count
    end,
            I_10 = (I_9 + 1),
            Fun_7_loop(Arr_5, Count_3, I_10, R, S_2, Sd_3, Seed_3, T);
        _ -> {Arr_5, Count, I_9, R, S_2, Sd_3, Seed_3, T}
    end
end,
{Arr_5, Count_3, I_10, R, S_2, Sd_3, Seed_3, T} = Fun_7(Arr_5, Count, I_9, R, S_2, Sd_3, Seed_3, T),
        Out = "",
        I_11 = 0,
        Fun_8 = fun Fun_8_loop(Arr_5, Count_3, I_11, Out, R, S_2, Sd_3, Seed_3, T) ->
    case (I_11 < length(Arr_5)) of
        true ->
            Out_2 = (Out ++ lists:nth(I_11 + 1, Arr_5)),
            I_12 = (I_11 + 1),
            Fun_8_loop(Arr_5, Count_3, I_12, Out_2, R, S_2, Sd_3, Seed_3, T);
        _ -> {Arr_5, Count_3, I_11, Out, R, S_2, Sd_3, Seed_3, T}
    end
end,
{Arr_5, Count_3, I_12, Out_2, R, S_2, Sd_3, Seed_3, T} = Fun_8(Arr_5, Count_3, I_11, Out, R, S_2, Sd_3, Seed_3, T),
        [Out_2, Sd_3, Count_3]
    catch {return, Ret} -> Ret end.

main() ->
    try
        Ts = ["abracadabra", "seesaw", "elk", "grrrrrr", "up", "a"],
        Seed_4 = 1,
        I_13 = 0,
        Fun_9 = fun Fun_9_loop(I_13, Seed_4, Ts) ->
    case (I_13 < length(Ts)) of
        true ->
            R_2 = bestshuffle(lists:nth(I_13 + 1, Ts), Seed_4),
            Shuf = lists:nth(0 + 1, R_2),
            Seed_5 = lists:nth(1 + 1, R_2),
            Cnt = lists:nth(2 + 1, R_2),
            io:format("~ts~n", [(((((lists:nth(I_13 + 1, Ts) ++ " -> ") ++ Shuf) ++ " (") ++ lists:flatten(io_lib:format("~p", [Cnt]))) ++ ")")]),
            I_14 = (I_13 + 1),
            Fun_9_loop(I_14, Seed_5, Ts);
        _ -> {I_13, Seed_4, Ts}
    end
end,
{I_14, Seed_5, Ts} = Fun_9(I_13, Seed_4, Ts),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
