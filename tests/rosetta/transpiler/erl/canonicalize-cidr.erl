#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, split/2, join/2, repeat/2, parseintstr/1, tobinary/2, bintoint/1, padright/2, canonicalize/1]).

% Generated by Mochi transpiler v0.10.55 (b43d15e5bc) on 2025-08-03 11:14 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_parse_int_str(S) ->
    try list_to_integer(S) catch _:_ -> 0 end.


mochi_repeat(S, N) when is_binary(S) ->
    binary:copy(S, mochi_to_int(N));
mochi_repeat(S, N) when is_list(S) ->
    string:copies(S, mochi_to_int(N));
mochi_repeat(_, _) -> [].

split(S, Sep) ->
    try
        Parts = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, Parts, S, Sep) ->
    case (I < length(S)) of
        true ->
            case (((length(Sep) > 0) andalso ((I + length(Sep)) =< length(S))) andalso (string:substr(S, I + 1, ((I + length(Sep)) - I)) == Sep)) of
        true -> Parts_2 = lists:append(Parts, [Cur]),
            Cur_2 = "",
            I_2 = (I + length(Sep)),
            Cur_4 = Cur_2,
            I_4 = I_2,
            Parts_3 = Parts_2;
        _ -> Cur_3 = (Cur ++ string:substr(S, I + 1, ((I + 1) - I))),
            I_3 = (I + 1),
            Cur_4 = Cur_3,
            I_4 = I_3,
            Parts_3 = Parts
    end,
            Fun_loop(Cur_4, I_4, Parts_3, S, Sep);
        _ -> {Cur, I, Parts, S, Sep}
    end
end,
{Cur_4, I_4, Parts_3, S, Sep} = Fun(Cur, I, Parts, S, Sep),
        Parts_4 = lists:append(Parts_3, [Cur_4]),
        Parts_4
    catch {return, Ret} -> Ret end.

join(Xs, Sep_2) ->
    try
        Res = "",
        I_5 = 0,
        Fun_2 = fun Fun_2_loop(I_5, Res, Sep_2, Xs) ->
    case (I_5 < length(Xs)) of
        true ->
            case (I_5 > 0) of
        true -> Res_2 = (Res ++ Sep_2),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Res_4 = (Res_3 ++ (case erlang:is_map(Xs) of true -> maps:get(I_5, Xs, nil); _ -> lists:nth(I_5 + 1, Xs) end)),
            I_6 = (I_5 + 1),
            Fun_2_loop(I_6, Res_4, Sep_2, Xs);
        _ -> {I_5, Res, Sep_2, Xs}
    end
end,
{I_6, Res_4, Sep_2, Xs} = Fun_2(I_5, Res, Sep_2, Xs),
        Res_4
    catch {return, Ret} -> Ret end.

repeat(Ch, N) ->
    try
        Out = "",
        I_7 = 0,
        Fun_3 = fun Fun_3_loop(Ch, I_7, N, Out) ->
    case (I_7 < N) of
        true ->
            Out_2 = (Out ++ Ch),
            I_8 = (I_7 + 1),
            Fun_3_loop(Ch, I_8, N, Out_2);
        _ -> {Ch, I_7, N, Out}
    end
end,
{Ch, I_8, N, Out_2} = Fun_3(Ch, I_7, N, Out),
        Out_2
    catch {return, Ret} -> Ret end.

parseintstr(Str) ->
    try
        I_9 = 0,
        Neg = false,
        case ((length(Str) > 0) andalso (string:substr(Str, 0 + 1, (1 - 0)) == "-")) of
        true -> Neg_2 = true,
            I_10 = 1,
            I_11 = I_10,
            Neg_3 = Neg_2;
        _ -> I_11 = I_9,
            Neg_3 = Neg
    end,
        N_2 = 0,
        Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
        Fun_4 = fun Fun_4_loop(Digits, I_11, N_2, Neg_3, Str) ->
    case (I_11 < length(Str)) of
        true ->
            N_3 = ((N_2 * 10) + maps:get(string:substr(Str, I_11 + 1, ((I_11 + 1) - I_11)), Digits, nil)),
            I_12 = (I_11 + 1),
            Fun_4_loop(Digits, I_12, N_3, Neg_3, Str);
        _ -> {Digits, I_11, N_2, Neg_3, Str}
    end
end,
{Digits, I_12, N_3, Neg_3, Str} = Fun_4(Digits, I_11, N_2, Neg_3, Str),
        case Neg_3 of
        true -> N_4 = -N_3,
            N_5 = N_4;
        _ -> N_5 = N_3
    end,
        N_5
    catch {return, Ret} -> Ret end.

tobinary(N_6, Bits) ->
    try
        B = "",
        Val = N_6,
        I_13 = 0,
        Fun_5 = fun Fun_5_loop(B, Bits, I_13, N_6, Val) ->
    case (I_13 < Bits) of
        true ->
            B_2 = (lists:flatten(io_lib:format("~p", [(Val rem 2)])) ++ B),
            Val_2 = mochi_to_int((Val div 2)),
            I_14 = (I_13 + 1),
            Fun_5_loop(B_2, Bits, I_14, N_6, Val_2);
        _ -> {B, Bits, I_13, N_6, Val}
    end
end,
{B_2, Bits, I_14, N_6, Val_2} = Fun_5(B, Bits, I_13, N_6, Val),
        B_2
    catch {return, Ret} -> Ret end.

bintoint(Bits_2) ->
    try
        N_7 = 0,
        I_15 = 0,
        Fun_6 = fun Fun_6_loop(Bits_2, I_15, N_7) ->
    case (I_15 < length(Bits_2)) of
        true ->
            N_8 = ((N_7 * 2) + mochi_parse_int_str(string:substr(Bits_2, I_15 + 1, ((I_15 + 1) - I_15)))),
            I_16 = (I_15 + 1),
            Fun_6_loop(Bits_2, I_16, N_8);
        _ -> {Bits_2, I_15, N_7}
    end
end,
{Bits_2, I_16, N_8} = Fun_6(Bits_2, I_15, N_7),
        N_8
    catch {return, Ret} -> Ret end.

padright(S_2, Width) ->
    try
        Out_3 = S_2,
        Fun_7 = fun Fun_7_loop(Out_3, S_2, Width) ->
    case (length(Out_3) < Width) of
        true ->
            Out_4 = (Out_3 ++ " "),
            Fun_7_loop(Out_4, S_2, Width);
        _ -> {Out_3, S_2, Width}
    end
end,
{Out_4, S_2, Width} = Fun_7(Out_3, S_2, Width),
        Out_4
    catch {return, Ret} -> Ret end.

canonicalize(Cidr) ->
    try
        Parts_5 = string:tokens(Cidr, "/"),
        Dotted = string:substr(Parts_5, 0 + 1, 1),
        Size = mochi_parse_int_str(string:substr(Parts_5, 1 + 1, 1)),
        BinParts = [],
        Fun_8 = fun Fun_8_loop(List, BinParts, Cidr, Dotted, Parts_5, Size) ->
    case List of
        [] -> {BinParts, Cidr, Dotted, Parts_5, Size};
        [P|P_rest] ->
            BinParts_2 = lists:append(BinParts, [tobinary(mochi_parse_int_str(P), 8)]),
            Fun_8_loop(P_rest, BinParts_2, Cidr, Dotted, Parts_5, Size)
    end
end,
{BinParts_2, Cidr, Dotted, Parts_5, Size} = Fun_8(string:tokens(Dotted, "."), BinParts, Cidr, Dotted, Parts_5, Size),
        Binary = join(BinParts_2, ""),
        Binary_2 = (string:substr(Binary, 0 + 1, (Size - 0)) ++ mochi_repeat("0", (32 - Size))),
        CanonParts = [],
        I_17 = 0,
        Fun_9 = fun Fun_9_loop(BinParts_2, Binary_2, CanonParts, Cidr, Dotted, I_17, Parts_5, Size) ->
    case (I_17 < length(Binary_2)) of
        true ->
            CanonParts_2 = lists:append(CanonParts, [lists:flatten(io_lib:format("~p", [bintoint(string:substr(Binary_2, I_17 + 1, ((I_17 + 8) - I_17)))]))]),
            I_18 = (I_17 + 8),
            Fun_9_loop(BinParts_2, Binary_2, CanonParts_2, Cidr, Dotted, I_18, Parts_5, Size);
        _ -> {BinParts_2, Binary_2, CanonParts, Cidr, Dotted, I_17, Parts_5, Size}
    end
end,
{BinParts_2, Binary_2, CanonParts_2, Cidr, Dotted, I_18, Parts_5, Size} = Fun_9(BinParts_2, Binary_2, CanonParts, Cidr, Dotted, I_17, Parts_5, Size),
        ((join(CanonParts_2, ".") ++ "/") ++ string:substr(Parts_5, 1 + 1, 1))
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('tests', ["87.70.141.1/22", "36.18.154.103/12", "62.62.197.11/29", "67.137.119.181/4", "161.214.74.21/24", "184.232.176.184/18"]),
    Fun_10 = fun Fun_10_loop(List) ->
    case List of
        [] -> {};
        [T|T_rest] ->
            io:format("~ts~n", [((padright(T, 18) ++ " -> ") ++ canonicalize(T))]),
            Fun_10_loop(T_rest)
    end
end,
{} = Fun_10(erlang:get('tests')),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
