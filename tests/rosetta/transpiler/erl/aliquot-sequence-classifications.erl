#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, indexof/2, contains/2, maxof/2, intsqrt/1, sumproperdivisors/1, classifysequence/1, padleft/2, padright/2, joinwithcommas/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (029b538ca5) on 2025-07-25 15:20 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.

indexof(Xs, Value) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, Value, Xs) ->
    case (I < length(Xs)) of
        true ->
            case (lists:nth(I + 1, Xs) == Value) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, Value, Xs);
        _ -> {I, Value, Xs}
    end
end,
{I_2, Value, Xs} = Fun(I, Value, Xs),
        (0 - 1)
    catch {return, Ret} -> Ret end.

contains(Xs_2, Value_2) ->
    try
        (mochi_index_of(Xs_2, Value_2) /= (0 - 1))
    catch {return, Ret} -> Ret end.

maxof(A, B) ->
    try
        case (A > B) of
        true -> throw({return, A});
        _ -> throw({return, B})
    end,
        nil
    catch {return, Ret} -> Ret end.

intsqrt(N) ->
    try
        case (N == 0) of
        true -> throw({return, 0});
        _ -> ok
    end,
        X = N,
        Y = ((X + 1) div 2),
        Fun_2 = fun Fun_2_loop(N, X, Y) ->
    case (Y < X) of
        true ->
            X_2 = Y,
            Y_2 = ((X_2 + (N div X_2)) div 2),
            Fun_2_loop(N, X_2, Y_2);
        _ -> {N, X, Y}
    end
end,
{N, X_2, Y_2} = Fun_2(N, X, Y),
        X_2
    catch {return, Ret} -> Ret end.

sumproperdivisors(N_2) ->
    try
        case (N_2 < 2) of
        true -> throw({return, 0});
        _ -> ok
    end,
        Sqrt = intsqrt(N_2),
        Sum = 1,
        I_3 = 2,
        Fun_3 = fun Fun_3_loop(I_3, N_2, Sqrt, Sum) ->
    case (I_3 =< Sqrt) of
        true ->
            case ((N_2 rem I_3) == 0) of
        true -> Sum_2 = ((Sum + I_3) + (N_2 div I_3)),
            Sum_3 = Sum_2;
        _ -> Sum_3 = Sum
    end,
            I_4 = (I_3 + 1),
            Fun_3_loop(I_4, N_2, Sqrt, Sum_3);
        _ -> {I_3, N_2, Sqrt, Sum}
    end
end,
{I_4, N_2, Sqrt, Sum_3} = Fun_3(I_3, N_2, Sqrt, Sum),
        case ((Sqrt * Sqrt) == N_2) of
        true -> Sum_4 = (Sum_3 - Sqrt),
            Sum_5 = Sum_4;
        _ -> Sum_5 = Sum_3
    end,
        Sum_5
    catch {return, Ret} -> Ret end.

classifysequence(K) ->
    try
        Last = K,
        Seq = [K],
        Fun_4 = fun Fun_4_loop(K, Last, Seq) ->
    case true of
        true ->
            Last_2 = sumproperdivisors(Last),
            Seq_2 = lists:append(Seq, [Last_2]),
            N_3 = length(Seq_2),
            Aliquot = "",
            case (Last_2 == 0) of
        true -> Aliquot_2 = "Terminating",
            Aliquot_15 = Aliquot_2,
            Idx_7 = nil;
        _ -> case ((N_3 == 2) andalso (Last_2 == K)) of
        true -> Aliquot_3 = "Perfect",
            Aliquot_14 = Aliquot_3,
            Idx_6 = nil;
        _ -> case ((N_3 == 3) andalso (Last_2 == K)) of
        true -> Aliquot_4 = "Amicable",
            Aliquot_13 = Aliquot_4,
            Idx_5 = nil;
        _ -> case ((N_3 >= 4) andalso (Last_2 == K)) of
        true -> Aliquot_5 = (("Sociable[" ++ lists:flatten(io_lib:format("~p", [(N_3 - 1)]))) ++ "]"),
            Aliquot_12 = Aliquot_5,
            Idx_4 = nil;
        _ -> case (Last_2 == lists:nth((N_3 - 2) + 1, Seq_2)) of
        true -> Aliquot_6 = "Aspiring",
            Aliquot_11 = Aliquot_6,
            Idx_3 = nil;
        _ -> case mochi_member(Last_2, lists:sublist(Seq_2, 1 + 1, (maxof(1, (N_3 - 2)) - 1))) of
        true -> Idx = mochi_index_of(Seq_2, Last_2),
            Aliquot_7 = (("Cyclic[" ++ lists:flatten(io_lib:format("~p", [((N_3 - 1) - Idx)]))) ++ "]"),
            Aliquot_10 = Aliquot_7,
            Idx_2 = Idx;
        _ -> case ((N_3 == 16) orelse (Last_2 > 140737488355328)) of
        true -> Aliquot_8 = "Non-Terminating",
            Aliquot_9 = Aliquot_8;
        _ -> Aliquot_9 = Aliquot
    end,
            Aliquot_10 = Aliquot_9,
            Idx_2 = nil
    end,
            Aliquot_11 = Aliquot_10,
            Idx_3 = Idx_2
    end,
            Aliquot_12 = Aliquot_11,
            Idx_4 = Idx_3
    end,
            Aliquot_13 = Aliquot_12,
            Idx_5 = Idx_4
    end,
            Aliquot_14 = Aliquot_13,
            Idx_6 = Idx_5
    end,
            Aliquot_15 = Aliquot_14,
            Idx_7 = Idx_6
    end,
            case (Aliquot_15 /= "") of
        true -> throw({return, #{"seq" => Seq_2, "aliquot" => Aliquot_15}});
        _ -> ok
    end,
            Fun_4_loop(K, Last_2, Seq_2);
        _ -> {K, Last, Seq}
    end
end,
{K, Last_2, Seq_2} = Fun_4(K, Last, Seq),
        #{"seq" => Seq_2, "aliquot" => ""}
    catch {return, Ret} -> Ret end.

padleft(N_4, W) ->
    try
        S = lists:flatten(io_lib:format("~p", [N_4])),
        Fun_5 = fun Fun_5_loop(N_4, S, W) ->
    case (length(S) < W) of
        true ->
            S_2 = (" " ++ S),
            Fun_5_loop(N_4, S_2, W);
        _ -> {N_4, S, W}
    end
end,
{N_4, S_2, W} = Fun_5(N_4, S, W),
        S_2
    catch {return, Ret} -> Ret end.

padright(S_3, W_2) ->
    try
        R = S_3,
        Fun_6 = fun Fun_6_loop(R, S_3, W_2) ->
    case (length(R) < W_2) of
        true ->
            R_2 = (R ++ " "),
            Fun_6_loop(R_2, S_3, W_2);
        _ -> {R, S_3, W_2}
    end
end,
{R_2, S_3, W_2} = Fun_6(R, S_3, W_2),
        R_2
    catch {return, Ret} -> Ret end.

joinwithcommas(Seq_3) ->
    try
        S_4 = "[",
        I_5 = 0,
        Fun_7 = fun Fun_7_loop(I_5, S_4, Seq_3) ->
    case (I_5 < length(Seq_3)) of
        true ->
            S_5 = (S_4 ++ lists:flatten(io_lib:format("~p", [lists:nth(I_5 + 1, Seq_3)]))),
            case (I_5 < (length(Seq_3) - 1)) of
        true -> S_6 = (S_5 ++ ", "),
            S_7 = S_6;
        _ -> S_7 = S_5
    end,
            I_6 = (I_5 + 1),
            Fun_7_loop(I_6, S_7, Seq_3);
        _ -> {I_5, S_4, Seq_3}
    end
end,
{I_6, S_7, Seq_3} = Fun_7(I_5, S_4, Seq_3),
        S_8 = (S_7 ++ "]"),
        S_8
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", ["Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n"]),
        K_2 = 1,
        Fun_8 = fun Fun_8_loop(K_2) ->
    case (K_2 =< 10) of
        true ->
            Res = classifysequence(K_2),
            io:format("~ts~n", [((((padleft(K_2, 2) ++ ": ") ++ padright(maps:get("aliquot", Res, nil), 15)) ++ " ") ++ joinwithcommas(maps:get("seq", Res, nil)))]),
            K_3 = (K_2 + 1),
            Fun_8_loop(K_3);
        _ -> {K_2}
    end
end,
{K_3} = Fun_8(K_2),
        io:format("~ts~n", [""]),
        S_9 = [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488],
        I_7 = 0,
        Fun_9 = fun Fun_9_loop(I_7, K_3, S_9) ->
    case (I_7 < length(S_9)) of
        true ->
            Val = lists:nth(I_7 + 1, S_9),
            Res_2 = classifysequence(Val),
            io:format("~ts~n", [((((padleft(Val, 7) ++ ": ") ++ padright(maps:get("aliquot", Res_2, nil), 15)) ++ " ") ++ joinwithcommas(maps:get("seq", Res_2, nil)))]),
            I_8 = (I_7 + 1),
            Fun_9_loop(I_8, K_3, S_9);
        _ -> {I_7, K_3, S_9}
    end
end,
{I_8, K_3, S_9} = Fun_9(I_7, K_3, S_9),
        io:format("~ts~n", [""]),
        Big = 15355717786080,
        R_3 = classifysequence(15355717786080),
        io:format("~ts~n", [((((lists:flatten(io_lib:format("~p", [15355717786080])) ++ ": ") ++ padright(maps:get("aliquot", R_3, nil), 15)) ++ " ") ++ joinwithcommas(maps:get("seq", R_3, nil)))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('THRESHOLD', 140737488355328),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
