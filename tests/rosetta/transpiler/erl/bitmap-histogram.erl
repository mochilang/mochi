#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, image/0, histogram/2, medianthreshold/1, threshold/2, printimage/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (e0c44791e6) on 2025-07-25 18:01 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

image() ->
    try
        [[0, 0, 10000], [65535, 65535, 65535], [65535, 65535, 65535]]
    catch {return, Ret} -> Ret end.

histogram(G, Bins) ->
    try
        case (Bins =< 0) of
        true -> Bins_2 = length(lists:nth(0 + 1, G)),
            Bins_3 = Bins_2;
        _ -> Bins_3 = Bins
    end,
        H = [],
        I = 0,
        Fun = fun Fun_loop(Bins_3, G, H, I) ->
    case (I < Bins_3) of
        true ->
            H_2 = lists:append(H, [0]),
            I_2 = (I + 1),
            Fun_loop(Bins_3, G, H_2, I_2);
        _ -> {Bins_3, G, H, I}
    end
end,
{Bins_3, G, H_2, I_2} = Fun(Bins_3, G, H, I),
        Y = 0,
        Fun_3 = fun Fun_3_loop(Bins_3, G, H_2, I_2, Y) ->
    case (Y < length(G)) of
        true ->
            Row = lists:nth(Y + 1, G),
            X = 0,
            Fun_2 = fun Fun_2_loop(Bins_3, G, H_2, I_2, Row, X, Y) ->
    case (X < length(Row)) of
        true ->
            P = lists:nth(X + 1, Row),
            Idx = mochi_to_int(((P * (Bins_3 - 1)) div 65535)),
            H_3 = lists:sublist(H_2, Idx) ++ [(lists:nth(Idx + 1, H_2) + 1)] ++ lists:nthtail(Idx + 1, H_2),
            X_2 = (X + 1),
            Fun_2_loop(Bins_3, G, H_3, I_2, Row, X_2, Y);
        _ -> {Bins_3, G, H_2, I_2, Row, X, Y}
    end
end,
{Bins_3, G, H_3, I_2, Row, X_2, Y} = Fun_2(Bins_3, G, H_2, I_2, Row, X, Y),
            Y_2 = (Y + 1),
            Fun_3_loop(Bins_3, G, H_3, I_2, Y_2);
        _ -> {Bins_3, G, H_2, I_2, Y}
    end
end,
{Bins_3, G, H_3, I_2, Y_2} = Fun_3(Bins_3, G, H_2, I_2, Y),
        H_3
    catch {return, Ret} -> Ret end.

medianthreshold(H_4) ->
    try
        Lb = 0,
        Ub = (length(H_4) - 1),
        LSum = 0,
        USum = 0,
        Fun_4 = fun Fun_4_loop(H_4, LSum, Lb, USum, Ub) ->
    case (Lb =< Ub) of
        true ->
            case ((LSum + lists:nth(Lb + 1, H_4)) < (USum + lists:nth(Ub + 1, H_4))) of
        true -> LSum_2 = (LSum + lists:nth(Lb + 1, H_4)),
            Lb_2 = (Lb + 1),
            LSum_3 = LSum_2,
            Lb_3 = Lb_2,
            USum_3 = USum,
            Ub_3 = Ub;
        _ -> USum_2 = (USum + lists:nth(Ub + 1, H_4)),
            Ub_2 = (Ub - 1),
            LSum_3 = LSum,
            Lb_3 = Lb,
            USum_3 = USum_2,
            Ub_3 = Ub_2
    end,
            Fun_4_loop(H_4, LSum_3, Lb_3, USum_3, Ub_3);
        _ -> {H_4, LSum, Lb, USum, Ub}
    end
end,
{H_4, LSum_3, Lb_3, USum_3, Ub_3} = Fun_4(H_4, LSum, Lb, USum, Ub),
        mochi_to_int(((Ub_3 * 65535) div length(H_4)))
    catch {return, Ret} -> Ret end.

threshold(G_2, T) ->
    try
        Out = [],
        Y_3 = 0,
        Fun_6 = fun Fun_6_loop(G_2, Out, T, Y_3) ->
    case (Y_3 < length(G_2)) of
        true ->
            Row_2 = lists:nth(Y_3 + 1, G_2),
            NewRow = [],
            X_3 = 0,
            Fun_5 = fun Fun_5_loop(G_2, NewRow, Out, Row_2, T, X_3, Y_3) ->
    case (X_3 < length(Row_2)) of
        true ->
            case (lists:nth(X_3 + 1, Row_2) < T) of
        true -> NewRow_2 = lists:append(NewRow, [0]),
            NewRow_4 = NewRow_2;
        _ -> NewRow_3 = lists:append(NewRow, [65535]),
            NewRow_4 = NewRow_3
    end,
            X_4 = (X_3 + 1),
            Fun_5_loop(G_2, NewRow_4, Out, Row_2, T, X_4, Y_3);
        _ -> {G_2, NewRow, Out, Row_2, T, X_3, Y_3}
    end
end,
{G_2, NewRow_4, Out, Row_2, T, X_4, Y_3} = Fun_5(G_2, NewRow, Out, Row_2, T, X_3, Y_3),
            Out_2 = lists:append(Out, [NewRow_4]),
            Y_4 = (Y_3 + 1),
            Fun_6_loop(G_2, Out_2, T, Y_4);
        _ -> {G_2, Out, T, Y_3}
    end
end,
{G_2, Out_2, T, Y_4} = Fun_6(G_2, Out, T, Y_3),
        Out_2
    catch {return, Ret} -> Ret end.

printimage(G_3) ->
    try
        Y_5 = 0,
        Fun_8 = fun Fun_8_loop(G_3, Y_5) ->
    case (Y_5 < length(G_3)) of
        true ->
            Row_3 = lists:nth(Y_5 + 1, G_3),
            Line = "",
            X_5 = 0,
            Fun_7 = fun Fun_7_loop(G_3, Line, Row_3, X_5, Y_5) ->
    case (X_5 < length(Row_3)) of
        true ->
            case (lists:nth(X_5 + 1, Row_3) == 0) of
        true -> Line_2 = (Line ++ "0"),
            Line_4 = Line_2;
        _ -> Line_3 = (Line ++ "1"),
            Line_4 = Line_3
    end,
            X_6 = (X_5 + 1),
            Fun_7_loop(G_3, Line_4, Row_3, X_6, Y_5);
        _ -> {G_3, Line, Row_3, X_5, Y_5}
    end
end,
{G_3, Line_4, Row_3, X_6, Y_5} = Fun_7(G_3, Line, Row_3, X_5, Y_5),
            io:format("~ts~n", [Line_4]),
            Y_6 = (Y_5 + 1),
            Fun_8_loop(G_3, Y_6);
        _ -> {G_3, Y_5}
    end
end,
{G_3, Y_6} = Fun_8(G_3, Y_5),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Img = image(),
        H_5 = histogram(Img, 0),
        io:format("~ts~n", [("Histogram: " ++ lists:flatten(io_lib:format("~p", [H_5])))]),
        T_2 = medianthreshold(H_5),
        io:format("~ts~n", [("Threshold: " ++ lists:flatten(io_lib:format("~p", [T_2])))]),
        Bw = threshold(Img, T_2),
        printimage(Bw),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
