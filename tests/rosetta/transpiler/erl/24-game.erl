#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, randDigit/0, main/0]).

% Generated by Mochi transpiler v0.10.37 (afe94bcdf1) on 2025-07-23 06:24 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

randDigit() ->
    try
        ((mochi_now() rem 9) + 1)
    catch {return, V} -> V end.

main() ->
    try
        Digits = [],
        Fun = fun Fun_loop(List, Digits) ->
    case List of
        [] -> {Digits};
        [I|Fun_loop_rest] ->
            Digits2 = lists:append(Digits, [randDigit()]),
            Fun_loop(Fun_loop_rest, Digits2)
    end
end,
{Digits2} = Fun(lists:seq(0, (4) - 1), Digits),
        Numstr = "",
        Fun2 = fun Fun2_loop(List, Digits2, Numstr) ->
    case List of
        [] -> {Digits2, Numstr};
        [I2|Fun2_loop_rest] ->
            Numstr2 = (Numstr ++ lists:flatten(io_lib:format("~p", [lists:nth(I2 + 1, Digits2)]))),
            Fun2_loop(Fun2_loop_rest, Digits2, Numstr2)
    end
end,
{Digits2, Numstr2} = Fun2(lists:seq(0, (4) - 1), Digits2, Numstr),
        io:format("~ts~n", [(("Your numbers: " ++ Numstr2) ++ "\n")]),
        io:format("~ts~n", ["Enter RPN: "]),
        Expr = string:trim(io:get_line("")),
        case (length(Expr) /= 7) of
        true -> io:format("~ts~n", ["invalid. expression length must be 7. (4 numbers, 3 operators, no spaces)"]),
            throw({return, nil});
        _ -> ok
    end,
        Stack = [],
        I3 = 0,
        Valid = true,
        Fun5 = fun Fun5_loop(Digits2, Expr, I3, Numstr2, Stack, Valid) ->
    case (I3 < length(Expr)) of
        true ->
            try
                Ch = string:substr(Expr, I3 + 1, ((I3 + 1) - I3)),
                case ((Ch >= "0") andalso (Ch =< "9")) of
        true -> case (length(Digits2) == 0) of
        true -> io:format("~ts~n", ["too many numbers."]),
            throw({return, nil});
        _ -> ok
    end,
            J = 0,
            Fun3 = fun Fun3_loop(Ch, Digits2, Expr, I3, J, Numstr2, Stack, Valid) ->
    case (lists:nth(J + 1, Digits2) /= (case erlang:is_integer(Ch) of true -> Ch; _ -> case erlang:is_float(Ch) of true -> trunc(Ch); _ -> list_to_integer(Ch) end end - case erlang:is_integer("0") of true -> "0"; _ -> case erlang:is_float("0") of true -> trunc("0"); _ -> list_to_integer("0") end end)) of
        true ->
            try
                J2 = (J + 1),
                case (J2 == length(Digits2)) of
        true -> io:format("~ts~n", ["wrong numbers."]),
            throw({return, nil});
        _ -> ok
    end,
                Fun3_loop(Ch, Digits2, Expr, I3, J2, Numstr2, Stack, Valid)
            catch
                break -> {Ch, Digits2, Expr, I3, J, Numstr2, Stack, Valid}
            end;
        _ -> {Ch, Digits2, Expr, I3, J, Numstr2, Stack, Valid}
    end
end,
{Ch, Digits2, Expr, I3, J2, Numstr2, Stack, Valid} = Fun3(Ch, Digits2, Expr, I3, J, Numstr2, Stack, Valid),
            Digits3 = (lists:sublist(Digits2, 1, (J2 - 0)) + lists:sublist(Digits2, (J2 + 1) + 1, length(Digits2) - (J2 + 1))),
            Stack2 = lists:append(Stack, [float((case erlang:is_integer(Ch) of true -> Ch; _ -> case erlang:is_float(Ch) of true -> trunc(Ch); _ -> list_to_integer(Ch) end end - case erlang:is_integer("0") of true -> "0"; _ -> case erlang:is_float("0") of true -> trunc("0"); _ -> list_to_integer("0") end end))]),
            A2 = nil,
            B2 = nil,
            Digits4 = Digits3,
            Fun4 = Fun3,
            J3 = J2,
            Stack12 = Stack2,
            Valid9 = Valid;
        _ -> case (length(Stack) < 2) of
        true -> io:format("~ts~n", ["invalid expression syntax."]),
            Valid2 = false,
            throw(break),
            Valid3 = Valid2;
        _ -> Valid3 = Valid
    end,
            B = lists:nth((length(Stack) - 1) + 1, Stack),
            A = lists:nth((length(Stack) - 2) + 1, Stack),
            case (Ch == "+") of
        true -> Stack3 = lists:sublist(Stack, (length(Stack) - 2)) ++ [(A + B)] ++ lists:nthtail((length(Stack) - 2) + 1, Stack),
            Stack10 = Stack3,
            Valid8 = Valid3;
        _ -> case (Ch == "-") of
        true -> Stack4 = lists:sublist(Stack, (length(Stack) - 2)) ++ [(A - B)] ++ lists:nthtail((length(Stack) - 2) + 1, Stack),
            Stack9 = Stack4,
            Valid7 = Valid3;
        _ -> case (Ch == "*") of
        true -> Stack5 = lists:sublist(Stack, (length(Stack) - 2)) ++ [(A * B)] ++ lists:nthtail((length(Stack) - 2) + 1, Stack),
            Stack8 = Stack5,
            Valid6 = Valid3;
        _ -> case (Ch == "/") of
        true -> Stack6 = lists:sublist(Stack, (length(Stack) - 2)) ++ [(A / B)] ++ lists:nthtail((length(Stack) - 2) + 1, Stack),
            Stack7 = Stack6,
            Valid5 = Valid3;
        _ -> io:format("~ts~n", [(Ch ++ " invalid.")]),
            Valid4 = false,
            throw(break),
            Stack7 = Stack,
            Valid5 = Valid4
    end,
            Stack8 = Stack7,
            Valid6 = Valid5
    end,
            Stack9 = Stack8,
            Valid7 = Valid6
    end,
            Stack10 = Stack9,
            Valid8 = Valid7
    end,
            Stack11 = lists:sublist(Stack10, 1, ((length(Stack10) - 1) - 0)),
            A2 = A,
            B2 = B,
            Digits4 = Digits2,
            Fun4 = Fun2,
            J3 = nil,
            Stack12 = Stack11,
            Valid9 = Valid8
    end,
                I4 = (I3 + 1),
                Fun5_loop(Digits4, Expr, I4, Numstr2, Stack12, Valid9)
            catch
                break -> {Digits2, Expr, I3, Numstr2, Stack, Valid}
            end;
        _ -> {Digits2, Expr, I3, Numstr2, Stack, Valid}
    end
end,
{Digits4, Expr, I4, Numstr2, Stack12, Valid9} = Fun5(Digits2, Expr, I3, Numstr2, Stack, Valid),
        case (Valid9 /= nil) of
        true -> case (math:abs((lists:nth(0 + 1, Stack12) - 24)) > 1.0e-06) of
        true -> io:format("~ts~n", [(("incorrect. " ++ lists:flatten(io_lib:format("~p", [lists:nth(0 + 1, Stack12)]))) ++ " != 24")]);
        _ -> io:format("~ts~n", ["correct."])
    end;
        _ -> ok
    end,
        nil
    catch {return, V} -> V end.

main(_) ->
    main().
