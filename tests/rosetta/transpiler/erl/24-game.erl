#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, randdigit/0, main/0]).

% Generated by Mochi transpiler v0.10.40 (6bb4e4bd23) on 2025-07-25 19:02 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

randdigit() ->
    try
        ((mochi_now() rem 9) + 1)
    catch {return, Ret} -> Ret end.

main() ->
    try
        Digits = [],
        Fun = fun Fun_loop(List, Digits) ->
    case List of
        [] -> {Digits};
        [I|I_rest] ->
            Digits_2 = lists:append(Digits, [randdigit()]),
            Fun_loop(I_rest, Digits_2)
    end
end,
{Digits_2} = Fun(lists:seq(0, (4) - 1), Digits),
        Numstr = "",
        Fun_2 = fun Fun_2_loop(List, Digits_2, Numstr) ->
    case List of
        [] -> {Digits_2, Numstr};
        [I_2|I_2_rest] ->
            Numstr_2 = (Numstr ++ lists:flatten(io_lib:format("~p", [lists:nth(I_2 + 1, Digits_2)]))),
            Fun_2_loop(I_2_rest, Digits_2, Numstr_2)
    end
end,
{Digits_2, Numstr_2} = Fun_2(lists:seq(0, (4) - 1), Digits_2, Numstr),
        io:format("~ts~n", [(("Your numbers: " ++ Numstr_2) ++ "\n")]),
        io:format("~ts~n", ["Enter RPN: "]),
        Expr = (case io:get_line("") of eof -> "q"; L -> string:trim(L) end),
        case (length(Expr) /= 7) of
        true -> io:format("~ts~n", ["invalid. expression length must be 7. (4 numbers, 3 operators, no spaces)"]),
            throw({return, nil});
        _ -> ok
    end,
        Stack = [],
        I_3 = 0,
        Valid = true,
        Fun_5 = fun Fun_5_loop(Digits_2, Expr, I_3, Numstr_2, Stack, Valid) ->
    case (I_3 < length(Expr)) of
        true ->
            try
                Ch = string:substr(Expr, I_3 + 1, ((I_3 + 1) - I_3)),
                case ((Ch >= "0") andalso (Ch =< "9")) of
        true -> case (length(Digits_2) == 0) of
        true -> io:format("~ts~n", ["too many numbers."]),
            throw({return, nil});
        _ -> ok
    end,
            J = 0,
            Fun_3 = fun Fun_3_loop(Ch, Digits_2, Expr, I_3, J, Numstr_2, Stack, Valid) ->
    case (lists:nth(J + 1, Digits_2) /= (mochi_to_int(Ch) - mochi_to_int("0"))) of
        true ->
            J_2 = (J + 1),
            case (J_2 == length(Digits_2)) of
        true -> io:format("~ts~n", ["wrong numbers."]),
            throw({return, nil});
        _ -> ok
    end,
            Fun_3_loop(Ch, Digits_2, Expr, I_3, J_2, Numstr_2, Stack, Valid);
        _ -> {Ch, Digits_2, Expr, I_3, J, Numstr_2, Stack, Valid}
    end
end,
{Ch, Digits_2, Expr, I_3, J_2, Numstr_2, Stack, Valid} = Fun_3(Ch, Digits_2, Expr, I_3, J, Numstr_2, Stack, Valid),
            Digits_3 = (lists:sublist(Digits_2, 1, (J_2 - 0)) + lists:sublist(Digits_2, (J_2 + 1) + 1, length(Digits_2) - (J_2 + 1))),
            Stack_2 = lists:append(Stack, [float((mochi_to_int(Ch) - mochi_to_int("0")))]),
            A_2 = nil,
            B_2 = nil,
            Digits_4 = Digits_3,
            Fun_4 = Fun_3,
            J_3 = J_2,
            Stack_12 = Stack_2,
            Valid_9 = Valid;
        _ -> case (length(Stack) < 2) of
        true -> io:format("~ts~n", ["invalid expression syntax."]),
            Valid_2 = false,
            throw(break),
            Valid_3 = Valid_2;
        _ -> Valid_3 = Valid
    end,
            B = lists:nth((length(Stack) - 1) + 1, Stack),
            A = lists:nth((length(Stack) - 2) + 1, Stack),
            case (Ch == "+") of
        true -> Stack_3 = lists:sublist(Stack, (length(Stack) - 2)) ++ [(A + B)] ++ lists:nthtail((length(Stack) - 2) + 1, Stack),
            Stack_10 = Stack_3,
            Valid_8 = Valid_3;
        _ -> case (Ch == "-") of
        true -> Stack_4 = lists:sublist(Stack, (length(Stack) - 2)) ++ [(A - B)] ++ lists:nthtail((length(Stack) - 2) + 1, Stack),
            Stack_9 = Stack_4,
            Valid_7 = Valid_3;
        _ -> case (Ch == "*") of
        true -> Stack_5 = lists:sublist(Stack, (length(Stack) - 2)) ++ [(A * B)] ++ lists:nthtail((length(Stack) - 2) + 1, Stack),
            Stack_8 = Stack_5,
            Valid_6 = Valid_3;
        _ -> case (Ch == "/") of
        true -> Stack_6 = lists:sublist(Stack, (length(Stack) - 2)) ++ [(A div B)] ++ lists:nthtail((length(Stack) - 2) + 1, Stack),
            Stack_7 = Stack_6,
            Valid_5 = Valid_3;
        _ -> io:format("~ts~n", [(Ch ++ " invalid.")]),
            Valid_4 = false,
            throw(break),
            Stack_7 = Stack,
            Valid_5 = Valid_4
    end,
            Stack_8 = Stack_7,
            Valid_6 = Valid_5
    end,
            Stack_9 = Stack_8,
            Valid_7 = Valid_6
    end,
            Stack_10 = Stack_9,
            Valid_8 = Valid_7
    end,
            Stack_11 = lists:sublist(Stack_10, 1, ((length(Stack_10) - 1) - 0)),
            A_2 = A,
            B_2 = B,
            Digits_4 = Digits_2,
            Fun_4 = Fun_2,
            J_3 = nil,
            Stack_12 = Stack_11,
            Valid_9 = Valid_8
    end,
                I_4 = (I_3 + 1),
                Fun_5_loop(Digits_4, Expr, I_4, Numstr_2, Stack_12, Valid_9)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_5_loop(C0, C1, C2, C3, C4, C5);
                break -> {Digits_2, Expr, I_3, Numstr_2, Stack, Valid}
            end;
        _ -> {Digits_2, Expr, I_3, Numstr_2, Stack, Valid}
    end
end,
{Digits_4, Expr, I_4, Numstr_2, Stack_12, Valid_9} = Fun_5(Digits_2, Expr, I_3, Numstr_2, Stack, Valid),
        case (Valid_9 /= nil) of
        true -> case (erlang:abs((lists:nth(0 + 1, Stack_12) - 24)) > 1.0e-06) of
        true -> io:format("~ts~n", [(("incorrect. " ++ lists:flatten(io_lib:format("~p", [lists:nth(0 + 1, Stack_12)]))) ++ " != 24")]);
        _ -> io:format("~ts~n", ["correct."])
    end;
        _ -> ok
    end,
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
