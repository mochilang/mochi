#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, contains/2, sortstrings/1, bwt/1, ibwt/1, makeprintable/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (b43d15e5bc) on 2025-08-03 11:14 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

contains(S, Ch) ->
    try
        I = 0,
        Fun = fun Fun_loop(Ch, I, S) ->
    case (I < length(S)) of
        true ->
            case (string:substr(S, I + 1, ((I + 1) - I)) == Ch) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, I_2, S);
        _ -> {Ch, I, S}
    end
end,
{Ch, I_2, S} = Fun(Ch, I, S),
        false
    catch {return, Ret} -> Ret end.

sortstrings(Xs) ->
    try
        Arr = Xs,
        N = length(Arr),
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Arr, I_3, N, Xs) ->
    case (I_3 < N) of
        true ->
            J = 0,
            Fun_2 = fun Fun_2_loop(Arr, I_3, J, N, Xs) ->
    case (J < (N - 1)) of
        true ->
            case ((case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> lists:nth(J + 1, Arr) end) > (case erlang:is_map(Arr) of true -> maps:get((J + 1), Arr, nil); _ -> lists:nth((J + 1) + 1, Arr) end)) of
        true -> Tmp = (case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> lists:nth(J + 1, Arr) end),
            Arr_2 = lists:sublist(Arr, J) ++ [(case erlang:is_map(Arr) of true -> maps:get((J + 1), Arr, nil); _ -> lists:nth((J + 1) + 1, Arr) end)] ++ lists:nthtail(J + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, (J + 1)) ++ [Tmp] ++ lists:nthtail((J + 1) + 1, Arr_2),
            Arr_4 = Arr_3,
            Tmp_2 = Tmp;
        _ -> Arr_4 = Arr,
            Tmp_2 = nil
    end,
            J_2 = (J + 1),
            Fun_2_loop(Arr_4, I_3, J_2, N, Xs);
        _ -> {Arr, I_3, J, N, Xs}
    end
end,
{Arr_4, I_3, J_2, N, Xs} = Fun_2(Arr, I_3, J, N, Xs),
            I_4 = (I_3 + 1),
            Fun_3_loop(Arr_4, I_4, N, Xs);
        _ -> {Arr, I_3, N, Xs}
    end
end,
{Arr_4, I_4, N, Xs} = Fun_3(Arr, I_3, N, Xs),
        Arr_4
    catch {return, Ret} -> Ret end.

bwt(S_2) ->
    try
        case ((string:str(S_2, "\x02") =/= 0) orelse (string:str(S_2, "\x03") =/= 0)) of
        true -> throw({return, #{"err" => true, "res" => ""}});
        _ -> ok
    end,
        S_3 = (("\x02" ++ S_2) ++ "\x03"),
        Le = length(S_3),
        Table = [],
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(I_5, Le, S_3, Table) ->
    case (I_5 < Le) of
        true ->
            Rot = (string:substr(S_3, I_5 + 1, (Le - I_5)) ++ string:substr(S_3, 0 + 1, (I_5 - 0))),
            Table_2 = lists:append(Table, [Rot]),
            I_6 = (I_5 + 1),
            Fun_4_loop(I_6, Le, S_3, Table_2);
        _ -> {I_5, Le, S_3, Table}
    end
end,
{I_6, Le, S_3, Table_2} = Fun_4(I_5, Le, S_3, Table),
        Table_3 = sortstrings(Table_2),
        Last = "",
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(I_7, Last, Le, S_3, Table_3) ->
    case (I_7 < Le) of
        true ->
            Last_2 = (Last ++ string:substr((case erlang:is_map(Table_3) of true -> maps:get(I_7, Table_3, nil); _ -> lists:nth(I_7 + 1, Table_3) end), (Le - 1) + 1, (Le - (Le - 1)))),
            I_8 = (I_7 + 1),
            Fun_5_loop(I_8, Last_2, Le, S_3, Table_3);
        _ -> {I_7, Last, Le, S_3, Table_3}
    end
end,
{I_8, Last_2, Le, S_3, Table_3} = Fun_5(I_7, Last, Le, S_3, Table_3),
        #{"err" => false, "res" => Last_2}
    catch {return, Ret} -> Ret end.

ibwt(R) ->
    try
        Le_2 = length(R),
        Table_4 = [],
        I_9 = 0,
        Fun_6 = fun Fun_6_loop(I_9, Le_2, R, Table_4) ->
    case (I_9 < Le_2) of
        true ->
            Table_5 = lists:append(Table_4, [""]),
            I_10 = (I_9 + 1),
            Fun_6_loop(I_10, Le_2, R, Table_5);
        _ -> {I_9, Le_2, R, Table_4}
    end
end,
{I_10, Le_2, R, Table_5} = Fun_6(I_9, Le_2, R, Table_4),
        N_2 = 0,
        Fun_8 = fun Fun_8_loop(I_10, Le_2, N_2, R, Table_5) ->
    case (N_2 < Le_2) of
        true ->
            I_11 = 0,
            Fun_7 = fun Fun_7_loop(I_11, Le_2, N_2, R, Table_5) ->
    case (I_11 < Le_2) of
        true ->
            Table_6 = lists:sublist(Table_5, I_11) ++ [(string:substr(R, I_11 + 1, ((I_11 + 1) - I_11)) ++ (case erlang:is_map(Table_5) of true -> maps:get(I_11, Table_5, nil); _ -> lists:nth(I_11 + 1, Table_5) end))] ++ lists:nthtail(I_11 + 1, Table_5),
            I_12 = (I_11 + 1),
            Fun_7_loop(I_12, Le_2, N_2, R, Table_6);
        _ -> {I_11, Le_2, N_2, R, Table_5}
    end
end,
{I_12, Le_2, N_2, R, Table_6} = Fun_7(I_11, Le_2, N_2, R, Table_5),
            Table_7 = sortstrings(Table_6),
            N_3 = (N_2 + 1),
            Fun_8_loop(I_12, Le_2, N_3, R, Table_7);
        _ -> {I_10, Le_2, N_2, R, Table_5}
    end
end,
{I_12, Le_2, N_3, R, Table_7} = Fun_8(I_10, Le_2, N_2, R, Table_5),
        I_13 = 0,
        Fun_9 = fun Fun_9_loop(I_13, Le_2, N_3, R, Table_7) ->
    case (I_13 < Le_2) of
        true ->
            case (string:substr((case erlang:is_map(Table_7) of true -> maps:get(I_13, Table_7, nil); _ -> lists:nth(I_13 + 1, Table_7) end), (Le_2 - 1) + 1, (Le_2 - (Le_2 - 1))) == "\x03") of
        true -> throw({return, string:substr((case erlang:is_map(Table_7) of true -> maps:get(I_13, Table_7, nil); _ -> lists:nth(I_13 + 1, Table_7) end), 1 + 1, ((Le_2 - 1) - 1))});
        _ -> ok
    end,
            I_14 = (I_13 + 1),
            Fun_9_loop(I_14, Le_2, N_3, R, Table_7);
        _ -> {I_13, Le_2, N_3, R, Table_7}
    end
end,
{I_14, Le_2, N_3, R, Table_7} = Fun_9(I_13, Le_2, N_3, R, Table_7),
        ""
    catch {return, Ret} -> Ret end.

makeprintable(S_4) ->
    try
        Out = "",
        I_15 = 0,
        Fun_10 = fun Fun_10_loop(I_15, Out, S_4) ->
    case (I_15 < length(S_4)) of
        true ->
            Ch_2 = string:substr(S_4, I_15 + 1, ((I_15 + 1) - I_15)),
            case (Ch_2 == "\x02") of
        true -> Out_2 = (Out ++ "^"),
            Out_6 = Out_2;
        _ -> case (Ch_2 == "\x03") of
        true -> Out_3 = (Out ++ "|"),
            Out_5 = Out_3;
        _ -> Out_4 = (Out ++ Ch_2),
            Out_5 = Out_4
    end,
            Out_6 = Out_5
    end,
            I_16 = (I_15 + 1),
            Fun_10_loop(I_16, Out_6, S_4);
        _ -> {I_15, Out, S_4}
    end
end,
{I_16, Out_6, S_4} = Fun_10(I_15, Out, S_4),
        Out_6
    catch {return, Ret} -> Ret end.

main() ->
    try
        Examples = ["banana", "appellee", "dogwood", "TO BE OR NOT TO BE OR WANT TO BE OR NOT?", "SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES", "\x02ABC\x03"],
        Fun_11 = fun Fun_11_loop(List, Examples) ->
    case List of
        [] -> {Examples};
        [T|T_rest] ->
            io:format("~ts~n", [makeprintable(T)]),
            Res = bwt(T),
            case maps:get("err", Res, nil) of
        true -> io:format("~ts~n", [" --> ERROR: String can't contain STX or ETX"]),
            io:format("~ts~n", [" -->"]),
            Enc_2 = nil,
            R_3 = nil;
        _ -> Enc = maps:get("res", Res, nil),
            io:format("~ts~n", [(" --> " ++ makeprintable(Enc))]),
            R_2 = ibwt(Enc),
            io:format("~ts~n", [(" --> " ++ R_2)]),
            Enc_2 = Enc,
            R_3 = R_2
    end,
            io:format("~ts~n", [""]),
            Fun_11_loop(T_rest, Examples)
    end
end,
{Examples} = Fun_11(Examples, Examples),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('stx', "\x02"),
    erlang:put('etx', "\x03"),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
