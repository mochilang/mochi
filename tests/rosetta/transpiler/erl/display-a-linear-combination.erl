#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, padright/2, linearcombo/1, main/0]).

% Generated by Mochi transpiler v0.10.42 (34844ab2bf) on 2025-07-28 07:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

padright(S, W) ->
    try
        R = S,
        Fun = fun Fun_loop(R, S, W) ->
    case (length(R) < W) of
        true ->
            R_2 = (R ++ " "),
            Fun_loop(R_2, S, W);
        _ -> {R, S, W}
    end
end,
{R_2, S, W} = Fun(R, S, W),
        R_2
    catch {return, Ret} -> Ret end.

linearcombo(C) ->
    try
        Out = "",
        I = 0,
        Fun_2 = fun Fun_2_loop(C, I, Out) ->
    case (I < length(C)) of
        true ->
            N = lists:nth(I + 1, C),
            case (N /= 0) of
        true -> Op = "",
            case ((N < 0) andalso (length(Out) == 0)) of
        true -> Op_2 = "-",
            Op_8 = Op_2;
        _ -> case (N < 0) of
        true -> Op_3 = " - ",
            Op_7 = Op_3;
        _ -> case ((N > 0) andalso (length(Out) == 0)) of
        true -> Op_4 = "",
            Op_6 = Op_4;
        _ -> Op_5 = " + ",
            Op_6 = Op_5
    end,
            Op_7 = Op_6
    end,
            Op_8 = Op_7
    end,
            Av = N,
            case (Av < 0) of
        true -> Av_2 = -Av,
            Av_3 = Av_2;
        _ -> Av_3 = Av
    end,
            Coeff = (lists:flatten(io_lib:format("~p", [Av_3])) ++ "*"),
            case (Av_3 == 1) of
        true -> Coeff_2 = "",
            Coeff_3 = Coeff_2;
        _ -> Coeff_3 = Coeff
    end,
            Out_2 = (((((Out ++ Op_8) ++ Coeff_3) ++ "e(") ++ lists:flatten(io_lib:format("~p", [(I + 1)]))) ++ ")"),
            Av_4 = Av_3,
            Coeff_4 = Coeff_3,
            Op_9 = Op_8,
            Out_3 = Out_2;
        _ -> Av_4 = nil,
            Coeff_4 = nil,
            Op_9 = nil,
            Out_3 = Out
    end,
            I_2 = (I + 1),
            Fun_2_loop(C, I_2, Out_3);
        _ -> {C, I, Out}
    end
end,
{C, I_2, Out_3} = Fun_2(C, I, Out),
        case (length(Out_3) == 0) of
        true -> throw({return, "0"});
        _ -> ok
    end,
        Out_3
    catch {return, Ret} -> Ret end.

main() ->
    try
        Combos = [[1, 2, 3], [0, 1, 2, 3], [1, 0, 3, 4], [1, 2, 0], [0, 0, 0], [0], [1, 1, 1], [-1, -1, -1], [-1, -2, 0, -3], [-1]],
        Idx = 0,
        Fun_4 = fun Fun_4_loop(Combos, Idx) ->
    case (Idx < length(Combos)) of
        true ->
            C_2 = lists:nth(Idx + 1, Combos),
            T = "[",
            J = 0,
            Fun_3 = fun Fun_3_loop(C_2, Combos, Idx, J, T) ->
    case (J < length(C_2)) of
        true ->
            T_2 = (T ++ lists:flatten(io_lib:format("~p", [lists:nth(J + 1, C_2)]))),
            case (J < (length(C_2) - 1)) of
        true -> T_3 = (T_2 ++ ", "),
            T_4 = T_3;
        _ -> T_4 = T_2
    end,
            J_2 = (J + 1),
            Fun_3_loop(C_2, Combos, Idx, J_2, T_4);
        _ -> {C_2, Combos, Idx, J, T}
    end
end,
{C_2, Combos, Idx, J_2, T_4} = Fun_3(C_2, Combos, Idx, J, T),
            T_5 = (T_4 ++ "]"),
            Lc = linearcombo(C_2),
            io:format("~ts~n", [((padright(T_5, 15) ++ "  ->  ") ++ Lc)]),
            Idx_2 = (Idx + 1),
            Fun_4_loop(Combos, Idx_2);
        _ -> {Combos, Idx}
    end
end,
{Combos, Idx_2} = Fun_4(Combos, Idx),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
