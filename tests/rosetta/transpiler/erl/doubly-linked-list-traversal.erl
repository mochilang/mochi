#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, liststring/0]).

% Generated by Mochi transpiler v0.10.47 (eaacde736f) on 2025-07-28 11:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

liststring() ->
    try
        case (erlang:get('head') == (0 - 1)) of
        true -> throw({return, "<nil>"});
        _ -> ok
    end,
        R = ("[" ++ maps:get("value", maps:get(erlang:get('head'), erlang:get('nodes'), nil), nil)),
        Id = mochi_to_int(maps:get("next", maps:get(erlang:get('head'), erlang:get('nodes'), nil), nil)),
        Fun = fun Fun_loop(Id, R) ->
    case (Id /= (0 - 1)) of
        true ->
            R_2 = ((R ++ " ") ++ maps:get("value", maps:get(Id, erlang:get('nodes'), nil), nil)),
            Id_2 = mochi_to_int(maps:get("next", maps:get(Id, erlang:get('nodes'), nil), nil)),
            Fun_loop(Id_2, R_2);
        _ -> {Id, R}
    end
end,
{Id_2, R_2} = Fun(Id, R),
        R_3 = (R_2 ++ "]"),
        R_3
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('nodes', #{}),
    erlang:put('head', (0 - 1)),
    erlang:put('tail', (0 - 1)),
    io:format("~ts~n", [liststring()]),
    Nodes = erlang:get('nodes'),
    Nodes_2 = maps:put(0, #{"value" => "A", "next" => (0 - 1), "prev" => (0 - 1)}, Nodes),
    erlang:put('nodes', Nodes_2),
    erlang:put('head', 0),
    erlang:put('tail', 0),
    Nodes_3 = erlang:get('nodes'),
    Nodes_4 = maps:put(1, #{"value" => "B", "next" => (0 - 1), "prev" => 0}, Nodes_3),
    erlang:put('nodes', Nodes_4),
    Nodes_5 = erlang:get('nodes'),
    Tmp = maps:get(0, Nodes_5, nil),
    Tmp_2 = maps:put("next", 1, Tmp),
    Nodes_6 = maps:put(0, Tmp_2, Nodes_5),
    erlang:put('nodes', Nodes_6),
    erlang:put('tail', 1),
    io:format("~ts~n", [liststring()]),
    Nodes_7 = erlang:get('nodes'),
    Nodes_8 = maps:put(2, #{"value" => "C", "next" => 1, "prev" => 0}, Nodes_7),
    erlang:put('nodes', Nodes_8),
    Nodes_9 = erlang:get('nodes'),
    Tmp_3 = maps:get(1, Nodes_9, nil),
    Tmp_4 = maps:put("prev", 2, Tmp_3),
    Nodes_10 = maps:put(1, Tmp_4, Nodes_9),
    erlang:put('nodes', Nodes_10),
    Nodes_11 = erlang:get('nodes'),
    Tmp_5 = maps:get(0, Nodes_11, nil),
    Tmp_6 = maps:put("next", 2, Tmp_5),
    Nodes_12 = maps:put(0, Tmp_6, Nodes_11),
    erlang:put('nodes', Nodes_12),
    io:format("~ts~n", [liststring()]),
    erlang:put('out', "From tail:"),
    erlang:put('id', erlang:get('tail')),
    Fun_2 = fun Fun_2_loop(Nodes_12, Tmp_6) ->
    case (erlang:get('id') /= (0 - 1)) of
        true ->
            erlang:put('out', ((erlang:get('out') ++ " ") ++ maps:get("value", maps:get(erlang:get('id'), erlang:get('nodes'), nil), nil))),
            erlang:put('id', mochi_to_int(maps:get("prev", maps:get(erlang:get('id'), erlang:get('nodes'), nil), nil))),
            Fun_2_loop(Nodes_12, Tmp_6);
        _ -> {Nodes_12, Tmp_6}
    end
end,
{Nodes_12, Tmp_6} = Fun_2(Nodes_12, Tmp_6),
    io:format("~ts~n", [erlang:get('out')]),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
