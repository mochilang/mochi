#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, d2d/1, g2g/1, m2m/1, r2r/1, d2g/1, d2m/1, d2r/1, g2d/1, g2m/1, g2r/1, m2d/1, m2g/1, m2r/1, r2d/1, r2g/1, r2m/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (029b538ca5) on 2025-07-25 15:20 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

d2d(D) ->
    try
        math:fmod(D, 360)
    catch {return, Ret} -> Ret end.

g2g(G) ->
    try
        math:fmod(G, 400)
    catch {return, Ret} -> Ret end.

m2m(M) ->
    try
        math:fmod(M, 6400)
    catch {return, Ret} -> Ret end.

r2r(R) ->
    try
        math:fmod(R, (2 * 3.141592653589793))
    catch {return, Ret} -> Ret end.

d2g(D_2) ->
    try
        ((d2d(D_2) * 400) / 360)
    catch {return, Ret} -> Ret end.

d2m(D_3) ->
    try
        ((d2d(D_3) * 6400) / 360)
    catch {return, Ret} -> Ret end.

d2r(D_4) ->
    try
        ((d2d(D_4) * 3.141592653589793) / 180)
    catch {return, Ret} -> Ret end.

g2d(G_2) ->
    try
        ((g2g(G_2) * 360) / 400)
    catch {return, Ret} -> Ret end.

g2m(G_3) ->
    try
        ((g2g(G_3) * 6400) / 400)
    catch {return, Ret} -> Ret end.

g2r(G_4) ->
    try
        ((g2g(G_4) * 3.141592653589793) / 200)
    catch {return, Ret} -> Ret end.

m2d(M_2) ->
    try
        ((m2m(M_2) * 360) / 6400)
    catch {return, Ret} -> Ret end.

m2g(M_3) ->
    try
        ((m2m(M_3) * 400) / 6400)
    catch {return, Ret} -> Ret end.

m2r(M_4) ->
    try
        ((m2m(M_4) * 3.141592653589793) / 3200)
    catch {return, Ret} -> Ret end.

r2d(R_2) ->
    try
        ((r2r(R_2) * 180) / 3.141592653589793)
    catch {return, Ret} -> Ret end.

r2g(R_3) ->
    try
        ((r2r(R_3) * 200) / 3.141592653589793)
    catch {return, Ret} -> Ret end.

r2m(R_4) ->
    try
        ((r2r(R_4) * 3200) / 3.141592653589793)
    catch {return, Ret} -> Ret end.

main() ->
    try
        Angles = [-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1.0e+06],
        io:format("~ts~n", ["degrees normalized_degs gradians mils radians"]),
        Fun = fun Fun_loop(List, Angles) ->
    case List of
        [] -> {Angles};
        [A|A_rest] ->
            io:format("~ts~n", [((((((((lists:flatten(io_lib:format("~p", [A])) ++ " ") ++ lists:flatten(io_lib:format("~p", [d2d(A)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [d2g(A)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [d2m(A)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [d2r(A)])))]),
            Fun_loop(A_rest, Angles)
    end
end,
{Angles} = Fun(Angles, Angles),
        io:format("~ts~n", ["\ngradians normalized_grds degrees mils radians"]),
        Fun_2 = fun Fun_2_loop(List, Angles) ->
    case List of
        [] -> {Angles};
        [A_2|A_2_rest] ->
            io:format("~ts~n", [((((((((lists:flatten(io_lib:format("~p", [A_2])) ++ " ") ++ lists:flatten(io_lib:format("~p", [g2g(A_2)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [g2d(A_2)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [g2m(A_2)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [g2r(A_2)])))]),
            Fun_2_loop(A_2_rest, Angles)
    end
end,
{Angles} = Fun_2(Angles, Angles),
        io:format("~ts~n", ["\nmils normalized_mils degrees gradians radians"]),
        Fun_3 = fun Fun_3_loop(List, Angles) ->
    case List of
        [] -> {Angles};
        [A_3|A_3_rest] ->
            io:format("~ts~n", [((((((((lists:flatten(io_lib:format("~p", [A_3])) ++ " ") ++ lists:flatten(io_lib:format("~p", [m2m(A_3)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [m2d(A_3)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [m2g(A_3)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [m2r(A_3)])))]),
            Fun_3_loop(A_3_rest, Angles)
    end
end,
{Angles} = Fun_3(Angles, Angles),
        io:format("~ts~n", ["\nradians normalized_rads degrees gradians mils"]),
        Fun_4 = fun Fun_4_loop(List, Angles) ->
    case List of
        [] -> {Angles};
        [A_4|A_4_rest] ->
            io:format("~ts~n", [((((((((lists:flatten(io_lib:format("~p", [A_4])) ++ " ") ++ lists:flatten(io_lib:format("~p", [r2r(A_4)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [r2d(A_4)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [r2g(A_4)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [r2m(A_4)])))]),
            Fun_4_loop(A_4_rest, Angles)
    end
end,
{Angles} = Fun_4(Angles, Angles),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
