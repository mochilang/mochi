#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, modpow/3, isprime/1, commatize/1, pad/2, join/2, formatrow/1, main/0]).

% Generated by Mochi transpiler v0.10.42 (3db112c0c7) on 2025-07-28 04:26 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

modpow(Base, Exp, M) ->
    try
        Result = (1 rem M),
        B = (Base rem M),
        E = Exp,
        Fun = fun Fun_loop(B, Base, E, Exp, M, Result) ->
    case (E > 0) of
        true ->
            case ((E rem 2) == 1) of
        true -> Result_2 = ((Result * B) rem M),
            Result_3 = Result_2;
        _ -> Result_3 = Result
    end,
            B_2 = ((B * B) rem M),
            E_2 = mochi_to_int((E div 2)),
            Fun_loop(B_2, Base, E_2, Exp, M, Result_3);
        _ -> {B, Base, E, Exp, M, Result}
    end
end,
{B_2, Base, E_2, Exp, M, Result_3} = Fun(B, Base, E, Exp, M, Result),
        Result_3
    catch {return, Ret} -> Ret end.

isprime(N) ->
    try
        case (N < 2) of
        true -> throw({return, false});
        _ -> ok
    end,
        Fun_2 = fun Fun_2_loop(List, N) ->
    case List of
        [] -> {N};
        [P|P_rest] ->
            case ((N rem P) == 0) of
        true -> throw({return, (N == P)});
        _ -> ok
    end,
            Fun_2_loop(P_rest, N)
    end
end,
{N} = Fun_2([2, 3, 5, 7, 11, 13, 17, 19, 23, 29], N),
        D = (N - 1),
        S = 0,
        Fun_3 = fun Fun_3_loop(D, N, S) ->
    case ((D rem 2) == 0) of
        true ->
            D_2 = (D div 2),
            S_2 = (S + 1),
            Fun_3_loop(D_2, N, S_2);
        _ -> {D, N, S}
    end
end,
{D_2, N, S_2} = Fun_3(D, N, S),
        Fun_4 = fun Fun_4_loop(List, D_2, N, S_2) ->
    case List of
        [] -> {D_2, N, S_2};
        [A|A_rest] ->
        try
            case ((A rem N) == 0) of
        true -> throw({return, true});
        _ -> ok
    end,
            X = modpow(A, D_2, N),
            case ((X == 1) orelse (X == (N - 1))) of
        true -> throw({continue, D_2, N, S_2});
        _ -> ok
    end,
            R = 1,
            Passed = false,
            Fun_5 = fun Fun_5_loop(A, D_2, N, Passed, R, S_2, X) ->
    case (R < S_2) of
        true ->
            try
                X_2 = ((X * X) rem N),
                case (X_2 == (N - 1)) of
        true -> Passed_2 = true,
            throw(break),
            Passed_3 = Passed_2;
        _ -> Passed_3 = Passed
    end,
                R_2 = (R + 1),
                Fun_5_loop(A, D_2, N, Passed_3, R_2, S_2, X_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_5_loop(C0, C1, C2, C3, C4, C5, C6);
                break -> {A, D_2, N, Passed, R, S_2, X}
            end;
        _ -> {A, D_2, N, Passed, R, S_2, X}
    end
end,
{A, D_2, N, Passed_3, R_2, S_2, X_2} = Fun_5(A, D_2, N, Passed, R, S_2, X),
            case mochi_not(Passed_3) of
        true -> throw({return, false});
        _ -> ok
    end,
            Fun_4_loop(A_rest, D_2, N, S_2)
        catch
            {continue, C0, C1, C2} -> Fun_4_loop(A_rest, C0, C1, C2);
            {break, B0, B1, B2} -> {B0, B1, B2};
            break -> {D_2, N, S_2}
        end
    end
end,
{D_2, N, S_2} = Fun_4([2, 325, 9375, 28178, 450775, 9780504, 1795265022], D_2, N, S_2),
        true
    catch {return, Ret} -> Ret end.

commatize(N_2) ->
    try
        S_3 = lists:flatten(io_lib:format("~p", [N_2])),
        I = (length(S_3) - 3),
        Fun_6 = fun Fun_6_loop(I, N_2, S_3) ->
    case (I > 0) of
        true ->
            S_4 = ((string:substr(S_3, 0 + 1, (I - 0)) ++ ",") ++ string:substr(S_3, I + 1, (length(S_3) - I))),
            I_2 = (I - 3),
            Fun_6_loop(I_2, N_2, S_4);
        _ -> {I, N_2, S_3}
    end
end,
{I_2, N_2, S_4} = Fun_6(I, N_2, S_3),
        S_4
    catch {return, Ret} -> Ret end.

pad(S_5, Width) ->
    try
        Out = S_5,
        Fun_7 = fun Fun_7_loop(Out, S_5, Width) ->
    case (length(Out) < Width) of
        true ->
            Out_2 = (" " ++ Out),
            Fun_7_loop(Out_2, S_5, Width);
        _ -> {Out, S_5, Width}
    end
end,
{Out_2, S_5, Width} = Fun_7(Out, S_5, Width),
        Out_2
    catch {return, Ret} -> Ret end.

join(Xs, Sep) ->
    try
        Res = "",
        I_3 = 0,
        Fun_8 = fun Fun_8_loop(I_3, Res, Sep, Xs) ->
    case (I_3 < length(Xs)) of
        true ->
            case (I_3 > 0) of
        true -> Res_2 = (Res ++ Sep),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Res_4 = (Res_3 ++ lists:nth(I_3 + 1, Xs)),
            I_4 = (I_3 + 1),
            Fun_8_loop(I_4, Res_4, Sep, Xs);
        _ -> {I_3, Res, Sep, Xs}
    end
end,
{I_4, Res_4, Sep, Xs} = Fun_8(I_3, Res, Sep, Xs),
        Res_4
    catch {return, Ret} -> Ret end.

formatrow(Row) ->
    try
        Padded = [],
        I_5 = 0,
        Fun_9 = fun Fun_9_loop(I_5, Padded, Row) ->
    case (I_5 < length(Row)) of
        true ->
            Padded_2 = lists:append(Padded, [pad(lists:nth(I_5 + 1, Row), 9)]),
            I_6 = (I_5 + 1),
            Fun_9_loop(I_6, Padded_2, Row);
        _ -> {I_5, Padded, Row}
    end
end,
{I_6, Padded_2, Row} = Fun_9(I_5, Padded, Row),
        (("[" ++ join(Padded_2, " ")) ++ "]")
    catch {return, Ret} -> Ret end.

main() ->
    try
        Cubans = [],
        Cube1 = 1,
        Count = 0,
        Cube100k = 0,
        I_7 = 1,
        Fun_10 = fun Fun_10_loop(Count, Cubans, Cube1, Cube100k, I_7) ->
    case true of
        true ->
            try
                J = (I_7 + 1),
                Cube2 = ((J * J) * J),
                Diff = (Cube2 - Cube1),
                case (isprime(Diff) /= nil) of
        true -> case (Count < 200) of
        true -> Cubans_2 = lists:append(Cubans, [commatize(Diff)]),
            Cubans_3 = Cubans_2;
        _ -> Cubans_3 = Cubans
    end,
            Count_2 = (Count + 1),
            case (Count_2 == 100000) of
        true -> Cube100k_2 = Diff,
            throw(break),
            Cube100k_3 = Cube100k_2;
        _ -> Cube100k_3 = Cube100k
    end,
            Count_3 = Count_2,
            Cubans_4 = Cubans_3,
            Cube100k_4 = Cube100k_3;
        _ -> Count_3 = Count,
            Cubans_4 = Cubans,
            Cube100k_4 = Cube100k
    end,
                Cube1_2 = Cube2,
                I_8 = (I_7 + 1),
                Fun_10_loop(Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_10_loop(C0, C1, C2, C3, C4);
                break -> {Count, Cubans, Cube1, Cube100k, I_7}
            end;
        _ -> {Count, Cubans, Cube1, Cube100k, I_7}
    end
end,
{Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8} = Fun_10(Count, Cubans, Cube1, Cube100k, I_7),
        io:format("~ts~n", ["The first 200 cuban primes are:-"]),
        Row_2 = 0,
        Fun_12 = fun Fun_12_loop(Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, Row_2) ->
    case (Row_2 < 20) of
        true ->
            Slice = [],
            K = 0,
            Fun_11 = fun Fun_11_loop(Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, K, Row_2, Slice) ->
    case (K < 10) of
        true ->
            Slice_2 = lists:append(Slice, [lists:nth(((Row_2 * 10) + K) + 1, Cubans_4)]),
            K_2 = (K + 1),
            Fun_11_loop(Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, K_2, Row_2, Slice_2);
        _ -> {Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, K, Row_2, Slice}
    end
end,
{Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, K_2, Row_2, Slice_2} = Fun_11(Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, K, Row_2, Slice),
            io:format("~ts~n", [formatrow(Slice_2)]),
            Row_3 = (Row_2 + 1),
            Fun_12_loop(Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, Row_3);
        _ -> {Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, Row_2}
    end
end,
{Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, Row_3} = Fun_12(Count_3, Cubans_4, Cube1_2, Cube100k_4, I_8, Row_2),
        io:format("~ts~n", [("\nThe 100,000th cuban prime is " ++ commatize(Cube100k_4))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
