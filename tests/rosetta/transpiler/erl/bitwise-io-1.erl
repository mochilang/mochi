#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pow2/1, lshift/2, rshift/2, newwriter/1, writebitslsb/3, writebitsmsb/3, writebits/3, closewriter/1, tobinary/2, bytestobits/1, examplewriter_writebits/0]).

% Generated by Mochi transpiler v0.10.40 (e0c44791e6) on 2025-07-25 18:01 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

pow2(N) ->
    try
        V = 1,
        I = 0,
        Fun = fun Fun_loop(I, N, V) ->
    case (I < N) of
        true ->
            V_2 = (V * 2),
            I_2 = (I + 1),
            Fun_loop(I_2, N, V_2);
        _ -> {I, N, V}
    end
end,
{I_2, N, V_2} = Fun(I, N, V),
        V_2
    catch {return, Ret} -> Ret end.

lshift(X, N_2) ->
    try
        (X * pow2(N_2))
    catch {return, Ret} -> Ret end.

rshift(X_2, N_3) ->
    try
        (X_2 div pow2(N_3))
    catch {return, Ret} -> Ret end.

newwriter(Order) ->
    try
        #{"order" => Order, "bits" => 0, "nbits" => 0, "data" => []}
    catch {return, Ret} -> Ret end.

writebitslsb(W, C, Width) ->
    try
        W_2 = maps:put("bits", (maps:get("bits", W, nil) + lshift(C, maps:get("nbits", W, nil))), W),
        W_3 = maps:put("nbits", (maps:get("nbits", W_2, nil) + Width), W_2),
        Fun_2 = fun Fun_2_loop(C, W_3, Width) ->
    case (maps:get("nbits", W_3, nil) >= 8) of
        true ->
            B = (maps:get("bits", W_3, nil) rem 256),
            W_4 = maps:put("data", lists:append(maps:get("data", W_3, nil), [B]), W_3),
            W_5 = maps:put("bits", rshift(maps:get("bits", W_4, nil), 8), W_4),
            W_6 = maps:put("nbits", (maps:get("nbits", W_5, nil) - 8), W_5),
            Fun_2_loop(C, W_6, Width);
        _ -> {C, W_3, Width}
    end
end,
{C, W_6, Width} = Fun_2(C, W_3, Width),
        W_6
    catch {return, Ret} -> Ret end.

writebitsmsb(W_7, C_2, Width_2) ->
    try
        W_8 = maps:put("bits", (maps:get("bits", W_7, nil) + lshift(C_2, ((32 - Width_2) - maps:get("nbits", W_7, nil)))), W_7),
        W_9 = maps:put("nbits", (maps:get("nbits", W_8, nil) + Width_2), W_8),
        Fun_3 = fun Fun_3_loop(C_2, W_9, Width_2) ->
    case (maps:get("nbits", W_9, nil) >= 8) of
        true ->
            B_2 = (rshift(maps:get("bits", W_9, nil), 24) rem 256),
            W_10 = maps:put("data", lists:append(maps:get("data", W_9, nil), [B_2]), W_9),
            W_11 = maps:put("bits", ((maps:get("bits", W_10, nil) rem pow2(24)) * 256), W_10),
            W_12 = maps:put("nbits", (maps:get("nbits", W_11, nil) - 8), W_11),
            Fun_3_loop(C_2, W_12, Width_2);
        _ -> {C_2, W_9, Width_2}
    end
end,
{C_2, W_12, Width_2} = Fun_3(C_2, W_9, Width_2),
        W_12
    catch {return, Ret} -> Ret end.

writebits(W_13, C_3, Width_3) ->
    try
        (case (maps:get("order", W_13, nil) == "LSB") of
    true -> writebitslsb(W_13, C_3, Width_3);
    _ -> writebitsmsb(W_13, C_3, Width_3)
end)
    catch {return, Ret} -> Ret end.

closewriter(W_14) ->
    try
        case (maps:get("nbits", W_14, nil) > 0) of
        true -> case (maps:get("order", W_14, nil) == "MSB") of
        true -> W_15 = maps:put("bits", rshift(maps:get("bits", W_14, nil), 24), W_14),
            W_16 = W_15;
        _ -> W_16 = W_14
    end,
            W_17 = maps:put("data", lists:append(maps:get("data", W_16, nil), [(maps:get("bits", W_16, nil) rem 256)]), W_16),
            W_18 = W_17;
        _ -> W_18 = W_14
    end,
        W_19 = maps:put("bits", 0, W_18),
        W_20 = maps:put("nbits", 0, W_19),
        W_20
    catch {return, Ret} -> Ret end.

tobinary(N_4, Bits) ->
    try
        B_3 = "",
        Val = N_4,
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(B_3, Bits, I_3, N_4, Val) ->
    case (I_3 < Bits) of
        true ->
            B_4 = (lists:flatten(io_lib:format("~p", [(Val rem 2)])) ++ B_3),
            Val_2 = (Val div 2),
            I_4 = (I_3 + 1),
            Fun_4_loop(B_4, Bits, I_4, N_4, Val_2);
        _ -> {B_3, Bits, I_3, N_4, Val}
    end
end,
{B_4, Bits, I_4, N_4, Val_2} = Fun_4(B_3, Bits, I_3, N_4, Val),
        B_4
    catch {return, Ret} -> Ret end.

bytestobits(Bs) ->
    try
        Out = "[",
        I_5 = 0,
        Fun_5 = fun Fun_5_loop(Bs, I_5, Out) ->
    case (I_5 < length(Bs)) of
        true ->
            Out_2 = (Out ++ tobinary(lists:nth(I_5 + 1, Bs), 8)),
            case ((I_5 + 1) < length(Bs)) of
        true -> Out_3 = (Out_2 ++ " "),
            Out_4 = Out_3;
        _ -> Out_4 = Out_2
    end,
            I_6 = (I_5 + 1),
            Fun_5_loop(Bs, I_6, Out_4);
        _ -> {Bs, I_5, Out}
    end
end,
{Bs, I_6, Out_4} = Fun_5(Bs, I_5, Out),
        Out_5 = (Out_4 ++ "]"),
        Out_5
    catch {return, Ret} -> Ret end.

examplewriter_writebits() ->
    try
        Bw = newwriter("MSB"),
        Bw_2 = writebits(Bw, 15, 4),
        Bw_3 = writebits(Bw_2, 0, 1),
        Bw_4 = writebits(Bw_3, 19, 5),
        Bw_5 = closewriter(Bw_4),
        io:format("~p~n", [bytestobits(maps:get("data", Bw_5, nil))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    examplewriter_writebits(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
