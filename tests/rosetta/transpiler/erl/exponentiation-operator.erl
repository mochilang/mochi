#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, printexpi/2, expf/2, printexpf/2]).

% Generated by Mochi transpiler v0.10.55 (6aa59f472e) on 2025-08-02 17:26 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

printexpi(B, P) ->
    try
        case (P < 0) of
        true -> io:format("~ts~n", [(((lists:flatten(io_lib:format("~p", [B])) ++ "^") ++ lists:flatten(io_lib:format("~p", [P]))) ++ ": negative power not allowed")]),
            throw({return, nil});
        _ -> ok
    end,
        R = 1,
        I = 1,
        Fun = fun Fun_loop(B, I, P, R) ->
    case (I =< P) of
        true ->
            R_2 = (R * B),
            I_2 = (I + 1),
            Fun_loop(B, I_2, P, R_2);
        _ -> {B, I, P, R}
    end
end,
{B, I_2, P, R_2} = Fun(B, I, P, R),
        io:format("~ts~n", [((((lists:flatten(io_lib:format("~p", [B])) ++ "^") ++ lists:flatten(io_lib:format("~p", [P]))) ++ ": ") ++ lists:flatten(io_lib:format("~p", [R_2])))]),
        nil
    catch {return, Ret} -> Ret end.

expf(B_2, P_2) ->
    try
        Neg = false,
        case (P_2 < 0) of
        true -> Neg_2 = true,
            P_3 = -P_2,
            Neg_3 = Neg_2,
            P_4 = P_3;
        _ -> Neg_3 = Neg,
            P_4 = P_2
    end,
        R_3 = 1,
        Pow = B_2,
        Fun_2 = fun Fun_2_loop(B_2, Neg_3, P_4, Pow, R_3) ->
    case (P_4 > 0) of
        true ->
            case ((P_4 rem 2) == 1) of
        true -> R_4 = (R_3 * Pow),
            R_5 = R_4;
        _ -> R_5 = R_3
    end,
            Pow_2 = (Pow * Pow),
            P_5 = (P_4 div 2),
            Fun_2_loop(B_2, Neg_3, P_5, Pow_2, R_5);
        _ -> {B_2, Neg_3, P_4, Pow, R_3}
    end
end,
{B_2, Neg_3, P_5, Pow_2, R_5} = Fun_2(B_2, Neg_3, P_4, Pow, R_3),
        case Neg_3 of
        true -> R_6 = (1 / R_5),
            R_7 = R_6;
        _ -> R_7 = R_5
    end,
        {R_7, P_5}
    catch {return, Ret} -> Ret end.

printexpf(B_3, P_6) ->
    try
        case ((B_3 == 0) andalso (P_6 < 0)) of
        true -> io:format("~ts~n", [(((lists:flatten(io_lib:format("~p", [B_3])) ++ "^") ++ lists:flatten(io_lib:format("~p", [P_6]))) ++ ": +Inf")]),
            throw({return, nil});
        _ -> ok
    end,
        io:format("~ts~n", [((((lists:flatten(io_lib:format("~p", [B_3])) ++ "^") ++ lists:flatten(io_lib:format("~p", [P_6]))) ++ ": ") ++ lists:flatten(io_lib:format("~p", [expf(B_3, P_6)])))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    io:format("~ts~n", ["expI tests"]),
    printexpi(2, 10),
    printexpi(2, -10),
    printexpi(-2, 10),
    printexpi(-2, 11),
    printexpi(11, 0),
    io:format("~ts~n", ["overflow undetected"]),
    printexpi(10, 10),
    io:format("~ts~n", ["\nexpF tests:"]),
    printexpf(2, 10),
    printexpf(2, -10),
    printexpf(-2, 10),
    printexpf(-2, 11),
    printexpf(11, 0),
    io:format("~ts~n", ["disallowed in expI, allowed here"]),
    printexpf(0, -1),
    io:format("~ts~n", ["other interesting cases for 32 bit float type"]),
    printexpf(10, 39),
    printexpf(10, -39),
    printexpf(-10, 39),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
