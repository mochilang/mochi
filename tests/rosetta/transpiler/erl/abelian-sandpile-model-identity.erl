#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, neighborsList/0, plus/2, isStable/1, topple/1, pileString/1]).

% Generated by Mochi transpiler v0.10.37 (2b4bee2c73) on 2025-07-23 15:43 +0700

neighborsList() ->
    try
        [[1, 3], [0, 2, 4], [1, 5], [0, 4, 6], [1, 3, 5, 7], [2, 4, 8], [3, 7], [4, 6, 8], [5, 7]]
    catch {return, V} -> V end.

plus(A, B) ->
    try
        Res = [],
        I = 0,
        Fun = fun Fun_loop(A, B, I, Res) ->
    case (I < length(A)) of
        true ->
            try
                Res2 = lists:append(Res, [(lists:nth(I + 1, A) + lists:nth(I + 1, B))]),
                I2 = (I + 1),
                Fun_loop(A, B, I2, Res2)
            catch
                break -> {A, B, I, Res}
            end;
        _ -> {A, B, I, Res}
    end
end,
{A, B, I2, Res2} = Fun(A, B, I, Res),
        Res2
    catch {return, V} -> V end.

isStable(P) ->
    try
        Fun2 = fun Fun2_loop(List, P) ->
    case List of
        [] -> {P};
        [V|Fun2_loop_rest] ->
            case (V > 3) of
        true -> throw({return, false});
        _ -> ok
    end,
            Fun2_loop(Fun2_loop_rest, P)
    end
end,
{P} = Fun2(P, P),
        true
    catch {return, V} -> V end.

topple(P2) ->
    try
        Neighbors = neighborsList(),
        I3 = 0,
        Fun5 = fun Fun5_loop(I3, Neighbors, P2) ->
    case (I3 < length(P2)) of
        true ->
            try
                case (lists:nth(I3 + 1, P2) > 3) of
        true -> P3 = lists:sublist(P2, I3) ++ [(lists:nth(I3 + 1, P2) - 4)] ++ lists:nthtail(I3 + 1, P2),
            Nbs = lists:nth(I3 + 1, Neighbors),
            Fun3 = fun Fun3_loop(List, I3, Nbs, Neighbors, P3) ->
    case List of
        [] -> {I3, Nbs, Neighbors, P3};
        [J|Fun3_loop_rest] ->
            P4 = lists:sublist(P3, J) ++ [(lists:nth(J + 1, P3) + 1)] ++ lists:nthtail(J + 1, P3),
            Fun3_loop(Fun3_loop_rest, I3, Nbs, Neighbors, P4)
    end
end,
{I3, Nbs, Neighbors, P4} = Fun3(Nbs, I3, Nbs, Neighbors, P3),
            throw({return, P4}),
            Fun4 = Fun3,
            Nbs2 = Nbs,
            P5 = P4;
        _ -> Fun4 = nil,
            Nbs2 = nil,
            P5 = P2
    end,
                I4 = (I3 + 1),
                Fun5_loop(I4, Neighbors, P5)
            catch
                break -> {I3, Neighbors, P2}
            end;
        _ -> {I3, Neighbors, P2}
    end
end,
{I4, Neighbors, P5} = Fun5(I3, Neighbors, P2),
        P2
    catch {return, V} -> V end.

pileString(P6) ->
    try
        S = "",
        R = 0,
        Fun7 = fun Fun7_loop(P6, R, S) ->
    case (R < 3) of
        true ->
            try
                C = 0,
                Fun6 = fun Fun6_loop(C, P6, R, S) ->
    case (C < 3) of
        true ->
            try
                S2 = ((S ++ lists:flatten(io_lib:format("~p", [lists:nth(((3 * R) + C) + 1, P6)]))) ++ " "),
                C2 = (C + 1),
                Fun6_loop(C2, P6, R, S2)
            catch
                break -> {C, P6, R, S}
            end;
        _ -> {C, P6, R, S}
    end
end,
{C2, P6, R, S2} = Fun6(C, P6, R, S),
                S3 = (S2 ++ "\n"),
                R2 = (R + 1),
                Fun7_loop(P6, R2, S3)
            catch
                break -> {P6, R, S}
            end;
        _ -> {P6, R, S}
    end
end,
{P6, R2, S3} = Fun7(P6, R, S),
        S3
    catch {return, V} -> V end.

main(_) ->
    io:format("~ts~n", ["Avalanche of topplings:\n"]),
    erlang:put('s4', [4, 3, 3, 3, 1, 2, 0, 2, 3]),
    io:format("~p~n", [pileString(erlang:get('s4'))]),
    Fun8 = fun Fun8_loop() ->
    case not isStable(erlang:get('s4')) of
        true ->
            try
                S4 = topple(erlang:get('s4')),
                erlang:put('s4', S4),
                io:format("~p~n", [pileString(erlang:get('s4'))]),
                Fun8_loop()
            catch
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun8(),
    io:format("~ts~n", ["Commutative additions:\n"]),
    erlang:put('s1', [1, 2, 0, 2, 1, 1, 0, 1, 3]),
    erlang:put('s2', [2, 1, 3, 1, 0, 1, 0, 1, 0]),
    erlang:put('s3_a', plus(erlang:get('s1'), erlang:get('s2'))),
    Fun9 = fun Fun9_loop() ->
    case not isStable(erlang:get('s3_a')) of
        true ->
            try
                S3_a = topple(erlang:get('s3_a')),
                erlang:put('s3_a', S3_a),
                Fun9_loop()
            catch
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun9(),
    erlang:put('s3_b', plus(erlang:get('s2'), erlang:get('s1'))),
    Fun10 = fun Fun10_loop() ->
    case not isStable(erlang:get('s3_b')) of
        true ->
            try
                S3_b = topple(erlang:get('s3_b')),
                erlang:put('s3_b', S3_b),
                Fun10_loop()
            catch
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun10(),
    io:format("~ts~n", [((((pileString(erlang:get('s1')) ++ "\nplus\n\n") ++ pileString(erlang:get('s2'))) ++ "\nequals\n\n") ++ pileString(erlang:get('s3_a')))]),
    io:format("~ts~n", [((((("and\n\n" ++ pileString(erlang:get('s2'))) ++ "\nplus\n\n") ++ pileString(erlang:get('s1'))) ++ "\nalso equals\n\n") ++ pileString(erlang:get('s3_b')))]),
    io:format("~ts~n", ["Addition of identity sandpile:\n"]),
    erlang:put('s3', [3, 3, 3, 3, 3, 3, 3, 3, 3]),
    erlang:put('s3_id', [2, 1, 2, 1, 0, 1, 2, 1, 2]),
    erlang:put('s4b', plus(erlang:get('s3'), erlang:get('s3_id'))),
    Fun11 = fun Fun11_loop() ->
    case not isStable(erlang:get('s4b')) of
        true ->
            try
                S4b = topple(erlang:get('s4b')),
                erlang:put('s4b', S4b),
                Fun11_loop()
            catch
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun11(),
    io:format("~ts~n", [((((pileString(erlang:get('s3')) ++ "\nplus\n\n") ++ pileString(erlang:get('s3_id'))) ++ "\nequals\n\n") ++ pileString(erlang:get('s4b')))]),
    io:format("~ts~n", ["Addition of identities:\n"]),
    erlang:put('s5', plus(erlang:get('s3_id'), erlang:get('s3_id'))),
    Fun12 = fun Fun12_loop() ->
    case not isStable(erlang:get('s5')) of
        true ->
            try
                S5 = topple(erlang:get('s5')),
                erlang:put('s5', S5),
                Fun12_loop()
            catch
                break -> {}
            end;
        _ -> {}
    end
end,
{} = Fun12(),
    io:format("~ts~n", [((((pileString(erlang:get('s3_id')) ++ "\nplus\n\n") ++ pileString(erlang:get('s3_id'))) ++ "\nequals\n\n") ++ pileString(erlang:get('s5')))]).
