#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, shuffle/1, dotrials/3, main/0]).

% Generated by Mochi transpiler v0.10.40 (6bb4e4bd23) on 2025-07-25 19:02 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

shuffle(Xs) ->
    try
        Arr = Xs,
        I = 99,
        Fun = fun Fun_loop(Arr, I, Xs) ->
    case (I > 0) of
        true ->
            J = (mochi_now() rem (I + 1)),
            Tmp = lists:nth(I + 1, Arr),
            Arr_2 = lists:sublist(Arr, I) ++ [lists:nth(J + 1, Arr)] ++ lists:nthtail(I + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, J) ++ [Tmp] ++ lists:nthtail(J + 1, Arr_2),
            I_2 = (I - 1),
            Fun_loop(Arr_3, I_2, Xs);
        _ -> {Arr, I, Xs}
    end
end,
{Arr_3, I_2, Xs} = Fun(Arr, I, Xs),
        Arr_3
    catch {return, Ret} -> Ret end.

dotrials(Trials, Np, Strategy) ->
    try
        Pardoned = 0,
        T = 0,
        Fun_9 = fun Fun_9_loop(Np, Pardoned, Strategy, T, Trials) ->
    case (T < Trials) of
        true ->
            try
                Drawers = [],
                I_3 = 0,
                Fun_2 = fun Fun_2_loop(Drawers, I_3, Np, Pardoned, Strategy, T, Trials) ->
    case (I_3 < 100) of
        true ->
            Drawers_2 = lists:append(Drawers, [I_3]),
            I_4 = (I_3 + 1),
            Fun_2_loop(Drawers_2, I_4, Np, Pardoned, Strategy, T, Trials);
        _ -> {Drawers, I_3, Np, Pardoned, Strategy, T, Trials}
    end
end,
{Drawers_2, I_4, Np, Pardoned, Strategy, T, Trials} = Fun_2(Drawers, I_3, Np, Pardoned, Strategy, T, Trials),
                Drawers_3 = shuffle(Drawers_2),
                P = 0,
                Success = true,
                Fun_8 = fun Fun_8_loop(Drawers_3, I_4, Np, P, Pardoned, Strategy, Success, T, Trials) ->
    case (P < Np) of
        true ->
            try
                Found = false,
                case (Strategy == "optimal") of
        true -> Prev = P,
            D = 0,
            Fun_3 = fun Fun_3_loop(D, Drawers_3, Found, I_4, Np, P, Pardoned, Prev, Strategy, Success, T, Trials) ->
    case (D < 50) of
        true ->
            try
                This = lists:nth(Prev + 1, Drawers_3),
                case (This == P) of
        true -> Found_2 = true,
            throw(break),
            Found_3 = Found_2;
        _ -> Found_3 = Found
    end,
                Prev_2 = This,
                D_2 = (D + 1),
                Fun_3_loop(D_2, Drawers_3, Found_3, I_4, Np, P, Pardoned, Prev_2, Strategy, Success, T, Trials)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11} -> Fun_3_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11);
                break -> {D, Drawers_3, Found, I_4, Np, P, Pardoned, Prev, Strategy, Success, T, Trials}
            end;
        _ -> {D, Drawers_3, Found, I_4, Np, P, Pardoned, Prev, Strategy, Success, T, Trials}
    end
end,
{D_2, Drawers_3, Found_3, I_4, Np, P, Pardoned, Prev_2, Strategy, Success, T, Trials} = Fun_3(D, Drawers_3, Found, I_4, Np, P, Pardoned, Prev, Strategy, Success, T, Trials),
            D_5 = D_2,
            Found_6 = Found_3,
            Fun_7 = Fun_3,
            K_3 = nil,
            Opened_4 = nil,
            Prev_3 = Prev_2;
        _ -> Opened = [],
            K = 0,
            Fun_4 = fun Fun_4_loop(Drawers_3, Found, I_4, K, Np, Opened, P, Pardoned, Strategy, Success, T, Trials) ->
    case (K < 100) of
        true ->
            Opened_2 = lists:append(Opened, [false]),
            K_2 = (K + 1),
            Fun_4_loop(Drawers_3, Found, I_4, K_2, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials);
        _ -> {Drawers_3, Found, I_4, K, Np, Opened, P, Pardoned, Strategy, Success, T, Trials}
    end
end,
{Drawers_3, Found, I_4, K_2, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials} = Fun_4(Drawers_3, Found, I_4, K, Np, Opened, P, Pardoned, Strategy, Success, T, Trials),
            D_3 = 0,
            Fun_6 = fun Fun_6_loop(D_3, Drawers_3, Found, I_4, K_2, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials) ->
    case (D_3 < 50) of
        true ->
            try
                N = (mochi_now() rem 100),
                Fun_5 = fun Fun_5_loop(D_3, Drawers_3, Found, I_4, K_2, N, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials) ->
    case lists:nth(N + 1, Opened_2) of
        true ->
            N_2 = (mochi_now() rem 100),
            Fun_5_loop(D_3, Drawers_3, Found, I_4, K_2, N_2, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials);
        _ -> {D_3, Drawers_3, Found, I_4, K_2, N, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials}
    end
end,
{D_3, Drawers_3, Found, I_4, K_2, N_2, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials} = Fun_5(D_3, Drawers_3, Found, I_4, K_2, N, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials),
                Opened_3 = lists:sublist(Opened_2, N_2) ++ [true] ++ lists:nthtail(N_2 + 1, Opened_2),
                case (lists:nth(N_2 + 1, Drawers_3) == P) of
        true -> Found_4 = true,
            throw(break),
            Found_5 = Found_4;
        _ -> Found_5 = Found
    end,
                D_4 = (D_3 + 1),
                Fun_6_loop(D_4, Drawers_3, Found_5, I_4, K_2, Np, Opened_3, P, Pardoned, Strategy, Success, T, Trials)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12} -> Fun_6_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11, C12);
                break -> {D_3, Drawers_3, Found, I_4, K_2, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials}
            end;
        _ -> {D_3, Drawers_3, Found, I_4, K_2, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials}
    end
end,
{D_4, Drawers_3, Found_5, I_4, K_2, Np, Opened_3, P, Pardoned, Strategy, Success, T, Trials} = Fun_6(D_3, Drawers_3, Found, I_4, K_2, Np, Opened_2, P, Pardoned, Strategy, Success, T, Trials),
            D_5 = D_4,
            Found_6 = Found_5,
            Fun_7 = Fun_6,
            K_3 = K_2,
            Opened_4 = Opened_3,
            Prev_3 = nil
    end,
                case not Found_6 of
        true -> Success_2 = false,
            throw(break),
            Success_3 = Success_2;
        _ -> Success_3 = Success
    end,
                P_2 = (P + 1),
                Fun_8_loop(Drawers_3, I_4, Np, P_2, Pardoned, Strategy, Success_3, T, Trials)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_8_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {Drawers_3, I_4, Np, P, Pardoned, Strategy, Success, T, Trials}
            end;
        _ -> {Drawers_3, I_4, Np, P, Pardoned, Strategy, Success, T, Trials}
    end
end,
{Drawers_3, I_4, Np, P_2, Pardoned, Strategy, Success_3, T, Trials} = Fun_8(Drawers_3, I_4, Np, P, Pardoned, Strategy, Success, T, Trials),
                case (Success_3 /= nil) of
        true -> Pardoned_2 = (Pardoned + 1),
            Pardoned_3 = Pardoned_2;
        _ -> Pardoned_3 = Pardoned
    end,
                T_2 = (T + 1),
                Fun_9_loop(Np, Pardoned_3, Strategy, T_2, Trials)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_9_loop(C0, C1, C2, C3, C4);
                break -> {Np, Pardoned, Strategy, T, Trials}
            end;
        _ -> {Np, Pardoned, Strategy, T, Trials}
    end
end,
{Np, Pardoned_3, Strategy, T_2, Trials} = Fun_9(Np, Pardoned, Strategy, T, Trials),
        Rf = ((float(Pardoned_3) / float(Trials)) * 100),
        io:format("~ts~n", [(((((("  strategy = " ++ Strategy) ++ "  pardoned = ") ++ lists:flatten(io_lib:format("~p", [Pardoned_3]))) ++ " relative frequency = ") ++ lists:flatten(io_lib:format("~p", [Rf]))) ++ "%")]),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Trials_2 = 1000,
        Fun_10 = fun Fun_10_loop(List, Trials_2) ->
    case List of
        [] -> {Trials_2};
        [Np_2|Np_2_rest] ->
            io:format("~ts~n", [(((("Results from " ++ lists:flatten(io_lib:format("~p", [1000]))) ++ " trials with ") ++ lists:flatten(io_lib:format("~p", [Np_2]))) ++ " prisoners:\n")]),
            Fun_11 = fun Fun_11_loop(List, Np_2, Trials_2) ->
    case List of
        [] -> {Np_2, Trials_2};
        [Strat|Strat_rest] ->
            dotrials(1000, Np_2, Strat),
            Fun_11_loop(Strat_rest, Np_2, Trials_2)
    end
end,
{Np_2, Trials_2} = Fun_11(["random", "optimal"], Np_2, Trials_2),
            Fun_10_loop(Np_2_rest, Trials_2)
    end
end,
{Trials_2} = Fun_10([10, 100], Trials_2),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    main().
