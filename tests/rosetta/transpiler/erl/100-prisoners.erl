#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, shuffle/1, doTrials/3, main/0]).

% Generated by Mochi transpiler v0.10.37 (f47c1ea6ed) on 2025-07-23 11:36 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

shuffle(Xs) ->
    try
        Arr = Xs,
        I = 99,
        Fun = fun Fun_loop(Arr, I, Xs) ->
    case (I > 0) of
        true ->
            try
                J = (mochi_now() rem (I + 1)),
                Tmp = lists:nth(I + 1, Arr),
                Arr2 = lists:sublist(Arr, I) ++ [lists:nth(J + 1, Arr)] ++ lists:nthtail(I + 1, Arr),
                Arr3 = lists:sublist(Arr2, J) ++ [Tmp] ++ lists:nthtail(J + 1, Arr2),
                I2 = (I - 1),
                Fun_loop(Arr3, I2, Xs)
            catch
                break -> {Arr, I, Xs}
            end;
        _ -> {Arr, I, Xs}
    end
end,
{Arr3, I2, Xs} = Fun(Arr, I, Xs),
        Arr3
    catch {return, V} -> V end.

doTrials(Trials, Np, Strategy) ->
    try
        Pardoned = 0,
        T = 0,
        Fun9 = fun Fun9_loop(Np, Pardoned, Strategy, T, Trials) ->
    case (T < Trials) of
        true ->
            try
                Drawers = [],
                I3 = 0,
                Fun2 = fun Fun2_loop(Drawers, I3, Np, Pardoned, Strategy, T, Trials) ->
    case (I3 < 100) of
        true ->
            try
                Drawers2 = lists:append(Drawers, [I3]),
                I4 = (I3 + 1),
                Fun2_loop(Drawers2, I4, Np, Pardoned, Strategy, T, Trials)
            catch
                break -> {Drawers, I3, Np, Pardoned, Strategy, T, Trials}
            end;
        _ -> {Drawers, I3, Np, Pardoned, Strategy, T, Trials}
    end
end,
{Drawers2, I4, Np, Pardoned, Strategy, T, Trials} = Fun2(Drawers, I3, Np, Pardoned, Strategy, T, Trials),
                Drawers3 = shuffle(Drawers2),
                P = 0,
                Success = true,
                Fun8 = fun Fun8_loop(Drawers3, I4, Np, P, Pardoned, Strategy, Success, T, Trials) ->
    case (P < Np) of
        true ->
            try
                Found = false,
                case (Strategy == "optimal") of
        true -> Prev = P,
            D = 0,
            Fun3 = fun Fun3_loop(D, Drawers3, Found, I4, Np, P, Pardoned, Prev, Strategy, Success, T, Trials) ->
    case (D < 50) of
        true ->
            try
                This = lists:nth(Prev + 1, Drawers3),
                case (This == P) of
        true -> Found2 = true,
            throw(break),
            Found3 = Found2;
        _ -> Found3 = Found
    end,
                Prev2 = This,
                D2 = (D + 1),
                Fun3_loop(D2, Drawers3, Found3, I4, Np, P, Pardoned, Prev2, Strategy, Success, T, Trials)
            catch
                break -> {D, Drawers3, Found, I4, Np, P, Pardoned, Prev, Strategy, Success, T, Trials}
            end;
        _ -> {D, Drawers3, Found, I4, Np, P, Pardoned, Prev, Strategy, Success, T, Trials}
    end
end,
{D2, Drawers3, Found3, I4, Np, P, Pardoned, Prev2, Strategy, Success, T, Trials} = Fun3(D, Drawers3, Found, I4, Np, P, Pardoned, Prev, Strategy, Success, T, Trials),
            D5 = D2,
            Found6 = Found3,
            Fun7 = Fun3,
            K3 = nil,
            Opened4 = nil,
            Prev3 = Prev2;
        _ -> Opened = [],
            K = 0,
            Fun4 = fun Fun4_loop(Drawers3, Found, I4, K, Np, Opened, P, Pardoned, Strategy, Success, T, Trials) ->
    case (K < 100) of
        true ->
            try
                Opened2 = lists:append(Opened, [false]),
                K2 = (K + 1),
                Fun4_loop(Drawers3, Found, I4, K2, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials)
            catch
                break -> {Drawers3, Found, I4, K, Np, Opened, P, Pardoned, Strategy, Success, T, Trials}
            end;
        _ -> {Drawers3, Found, I4, K, Np, Opened, P, Pardoned, Strategy, Success, T, Trials}
    end
end,
{Drawers3, Found, I4, K2, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials} = Fun4(Drawers3, Found, I4, K, Np, Opened, P, Pardoned, Strategy, Success, T, Trials),
            D3 = 0,
            Fun6 = fun Fun6_loop(D3, Drawers3, Found, I4, K2, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials) ->
    case (D3 < 50) of
        true ->
            try
                N = (mochi_now() rem 100),
                Fun5 = fun Fun5_loop(D3, Drawers3, Found, I4, K2, N, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials) ->
    case lists:nth(N + 1, Opened2) of
        true ->
            try
                N2 = (mochi_now() rem 100),
                Fun5_loop(D3, Drawers3, Found, I4, K2, N2, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials)
            catch
                break -> {D3, Drawers3, Found, I4, K2, N, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials}
            end;
        _ -> {D3, Drawers3, Found, I4, K2, N, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials}
    end
end,
{D3, Drawers3, Found, I4, K2, N2, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials} = Fun5(D3, Drawers3, Found, I4, K2, N, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials),
                Opened3 = lists:sublist(Opened2, N2) ++ [true] ++ lists:nthtail(N2 + 1, Opened2),
                case (lists:nth(N2 + 1, Drawers3) == P) of
        true -> Found4 = true,
            throw(break),
            Found5 = Found4;
        _ -> Found5 = Found
    end,
                D4 = (D3 + 1),
                Fun6_loop(D4, Drawers3, Found5, I4, K2, Np, Opened3, P, Pardoned, Strategy, Success, T, Trials)
            catch
                break -> {D3, Drawers3, Found, I4, K2, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials}
            end;
        _ -> {D3, Drawers3, Found, I4, K2, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials}
    end
end,
{D4, Drawers3, Found5, I4, K2, Np, Opened3, P, Pardoned, Strategy, Success, T, Trials} = Fun6(D3, Drawers3, Found, I4, K2, Np, Opened2, P, Pardoned, Strategy, Success, T, Trials),
            D5 = D4,
            Found6 = Found5,
            Fun7 = Fun6,
            K3 = K2,
            Opened4 = Opened3,
            Prev3 = nil
    end,
                case not Found6 of
        true -> Success2 = false,
            throw(break),
            Success3 = Success2;
        _ -> Success3 = Success
    end,
                P2 = (P + 1),
                Fun8_loop(Drawers3, I4, Np, P2, Pardoned, Strategy, Success3, T, Trials)
            catch
                break -> {Drawers3, I4, Np, P, Pardoned, Strategy, Success, T, Trials}
            end;
        _ -> {Drawers3, I4, Np, P, Pardoned, Strategy, Success, T, Trials}
    end
end,
{Drawers3, I4, Np, P2, Pardoned, Strategy, Success3, T, Trials} = Fun8(Drawers3, I4, Np, P, Pardoned, Strategy, Success, T, Trials),
                case (Success3 /= nil) of
        true -> Pardoned2 = (Pardoned + 1),
            Pardoned3 = Pardoned2;
        _ -> Pardoned3 = Pardoned
    end,
                T2 = (T + 1),
                Fun9_loop(Np, Pardoned3, Strategy, T2, Trials)
            catch
                break -> {Np, Pardoned, Strategy, T, Trials}
            end;
        _ -> {Np, Pardoned, Strategy, T, Trials}
    end
end,
{Np, Pardoned3, Strategy, T2, Trials} = Fun9(Np, Pardoned, Strategy, T, Trials),
        Rf = ((Pardoned3 / Trials) * 100),
        io:format("~ts~n", [(((((("  strategy = " ++ Strategy) ++ "  pardoned = ") ++ lists:flatten(io_lib:format("~p", [Pardoned3]))) ++ " relative frequency = ") ++ lists:flatten(io_lib:format("~p", [Rf]))) ++ "%")]),
        nil
    catch {return, V} -> V end.

main() ->
    try
        Trials2 = 1000,
        Fun10 = fun Fun10_loop(List, Trials2) ->
    case List of
        [] -> {Trials2};
        [Np2|Fun10_loop_rest] ->
            io:format("~ts~n", [(((("Results from " ++ lists:flatten(io_lib:format("~p", [1000]))) ++ " trials with ") ++ lists:flatten(io_lib:format("~p", [Np2]))) ++ " prisoners:\n")]),
            Fun11 = fun Fun11_loop(List, Np2, Trials2) ->
    case List of
        [] -> {Np2, Trials2};
        [Strat|Fun11_loop_rest] ->
            doTrials(1000, Np2, Strat),
            Fun11_loop(Fun11_loop_rest, Np2, Trials2)
    end
end,
{Np2, Trials2} = Fun11(["random", "optimal"], Np2, Trials2),
            Fun10_loop(Fun10_loop_rest, Trials2)
    end
end,
{Trials2} = Fun10([10, 100], Trials2),
        nil
    catch {return, V} -> V end.

main(_) ->
    main().
