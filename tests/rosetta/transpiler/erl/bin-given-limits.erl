#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, getbins/2, padleft/2, printbins/2, main/0]).

% Generated by Mochi transpiler v0.10.40 (7bf46dbf08) on 2025-07-25 14:27 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_pad_start(S, Len, Ch) ->
    Fill0 = case Ch of
        "" -> " ";
        _ -> Ch
    end,
    Fill = string:substr(Fill0, 1, 1),
    SL = length(S),
    case SL >= Len of
        true -> S;
        _ -> string:copies(Fill, Len - SL) ++ S
    end.

getbins(Limits, Data) ->
    try
        N = length(Limits),
        Bins = [],
        I = 0,
        Fun = fun Fun_loop(Bins, Data, I, Limits, N) ->
    case (I < (N + 1)) of
        true ->
            Bins_2 = lists:append(Bins, [0]),
            I_2 = (I + 1),
            Fun_loop(Bins_2, Data, I_2, Limits, N);
        _ -> {Bins, Data, I, Limits, N}
    end
end,
{Bins_2, Data, I_2, Limits, N} = Fun(Bins, Data, I, Limits, N),
        J = 0,
        Fun_3 = fun Fun_3_loop(Bins_2, Data, I_2, J, Limits, N) ->
    case (J < length(Data)) of
        true ->
            try
                D = lists:nth(J + 1, Data),
                Index = 0,
                Fun_2 = fun Fun_2_loop(Bins_2, D, Data, I_2, Index, J, Limits, N) ->
    case (Index < length(Limits)) of
        true ->
            try
                case (D < lists:nth(Index + 1, Limits)) of
        true -> throw(break);
        _ -> ok
    end,
                case (D == lists:nth(Index + 1, Limits)) of
        true -> Index_2 = (Index + 1),
            throw(break),
            Index_3 = Index_2;
        _ -> Index_3 = Index
    end,
                Index_4 = (Index_3 + 1),
                Fun_2_loop(Bins_2, D, Data, I_2, Index_4, J, Limits, N)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7} -> Fun_2_loop(C0, C1, C2, C3, C4, C5, C6, C7);
                break -> {Bins_2, D, Data, I_2, Index, J, Limits, N}
            end;
        _ -> {Bins_2, D, Data, I_2, Index, J, Limits, N}
    end
end,
{Bins_2, D, Data, I_2, Index_4, J, Limits, N} = Fun_2(Bins_2, D, Data, I_2, Index, J, Limits, N),
                Bins_3 = lists:sublist(Bins_2, Index_4) ++ [(lists:nth(Index_4 + 1, Bins_2) + 1)] ++ lists:nthtail(Index_4 + 1, Bins_2),
                J_2 = (J + 1),
                Fun_3_loop(Bins_3, Data, I_2, J_2, Limits, N)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_3_loop(C0, C1, C2, C3, C4, C5);
                break -> {Bins_2, Data, I_2, J, Limits, N}
            end;
        _ -> {Bins_2, Data, I_2, J, Limits, N}
    end
end,
{Bins_3, Data, I_2, J_2, Limits, N} = Fun_3(Bins_2, Data, I_2, J, Limits, N),
        Bins_3
    catch {return, Ret} -> Ret end.

padleft(N_2, Width) ->
    try
        S = lists:flatten(io_lib:format("~p", [N_2])),
        Pad = (Width - length(S)),
        Out = "",
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(I_3, N_2, Out, Pad, S, Width) ->
    case (I_3 < Pad) of
        true ->
            Out_2 = (Out ++ " "),
            I_4 = (I_3 + 1),
            Fun_4_loop(I_4, N_2, Out_2, Pad, S, Width);
        _ -> {I_3, N_2, Out, Pad, S, Width}
    end
end,
{I_4, N_2, Out_2, Pad, S, Width} = Fun_4(I_3, N_2, Out, Pad, S, Width),
        (Out_2 ++ S)
    catch {return, Ret} -> Ret end.

printbins(Limits_2, Bins_4) ->
    try
        N_3 = length(Limits_2),
        io:format("~ts~n", [((("           < " ++ padleft(lists:nth(0 + 1, Limits_2), 3)) ++ " = ") ++ padleft(lists:nth(0 + 1, Bins_4), 2))]),
        I_5 = 1,
        Fun_5 = fun Fun_5_loop(Bins_4, I_5, Limits_2, N_3) ->
    case (I_5 < N_3) of
        true ->
            io:format("~ts~n", [(((((">= " ++ padleft(lists:nth((I_5 - 1) + 1, Limits_2), 3)) ++ " and < ") ++ padleft(lists:nth(I_5 + 1, Limits_2), 3)) ++ " = ") ++ padleft(lists:nth(I_5 + 1, Bins_4), 2))]),
            I_6 = (I_5 + 1),
            Fun_5_loop(Bins_4, I_6, Limits_2, N_3);
        _ -> {Bins_4, I_5, Limits_2, N_3}
    end
end,
{Bins_4, I_6, Limits_2, N_3} = Fun_5(Bins_4, I_5, Limits_2, N_3),
        io:format("~ts~n", [(((">= " ++ padleft(lists:nth((N_3 - 1) + 1, Limits_2), 3)) ++ "           = ") ++ padleft(lists:nth(N_3 + 1, Bins_4), 2))]),
        io:format("~ts~n", [""]),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        LimitsList = [[23, 37, 43, 53, 67, 83], [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]],
        DataList = [[95, 21, 94, 12, 99, 4, 70, 75, 83, 93, 52, 80, 57, 5, 53, 86, 65, 17, 92, 83, 71, 61, 54, 58, 47, 16, 8, 9, 32, 84, 7, 87, 46, 19, 30, 37, 96, 6, 98, 40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55], [445, 814, 519, 697, 700, 130, 255, 889, 481, 122, 932, 77, 323, 525, 570, 219, 367, 523, 442, 933, 416, 589, 930, 373, 202, 253, 775, 47, 731, 685, 293, 126, 133, 450, 545, 100, 741, 583, 763, 306, 655, 267, 248, 477, 549, 238, 62, 678, 98, 534, 622, 907, 406, 714, 184, 391, 913, 42, 560, 247, 346, 860, 56, 138, 546, 38, 985, 948, 58, 213, 799, 319, 390, 634, 458, 945, 733, 507, 916, 123, 345, 110, 720, 917, 313, 845, 426, 9, 457, 628, 410, 723, 354, 895, 881, 953, 677, 137, 397, 97, 854, 740, 83, 216, 421, 94, 517, 479, 292, 963, 376, 981, 480, 39, 257, 272, 157, 5, 316, 395, 787, 942, 456, 242, 759, 898, 576, 67, 298, 425, 894, 435, 831, 241, 989, 614, 987, 770, 384, 692, 698, 765, 331, 487, 251, 600, 879, 342, 982, 527, 736, 795, 585, 40, 54, 901, 408, 359, 577, 237, 605, 847, 353, 968, 832, 205, 838, 427, 876, 959, 686, 646, 835, 127, 621, 892, 443, 198, 988, 791, 466, 23, 707, 467, 33, 670, 921, 180, 991, 396, 160, 436, 717, 918, 8, 374, 101, 684, 727, 749]],
        I_7 = 0,
        Fun_6 = fun Fun_6_loop(DataList, I_7, LimitsList) ->
    case (I_7 < length(LimitsList)) of
        true ->
            io:format("~ts~n", [(("Example " ++ lists:flatten(io_lib:format("~p", [(I_7 + 1)]))) ++ "\n")]),
            Bins_5 = getbins(lists:nth(I_7 + 1, LimitsList), lists:nth(I_7 + 1, DataList)),
            printbins(lists:nth(I_7 + 1, LimitsList), Bins_5),
            I_8 = (I_7 + 1),
            Fun_6_loop(DataList, I_8, LimitsList);
        _ -> {DataList, I_7, LimitsList}
    end
end,
{DataList, I_8, LimitsList} = Fun_6(DataList, I_7, LimitsList),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
