#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, fields/1, join/2, numberName/1, pluralizeFirst/2, randInt/2, slur/2, main/0]).

% Generated by Mochi transpiler v0.10.37 (f57ee704e4) on 2025-07-23 13:02 +0700

fields(S) ->
    try
        Words = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, S, Words) ->
    case (I < length(S)) of
        true ->
            try
                Ch = string:substr(S, I + 1, ((I + 1) - I)),
                case (((Ch == " ") orelse (Ch == "\n")) orelse (Ch == "\t")) of
        true -> case (length(Cur) > 0) of
        true -> Words2 = lists:append(Words, [Cur]),
            Cur2 = "",
            Cur3 = Cur2,
            Words3 = Words2;
        _ -> Cur3 = Cur,
            Words3 = Words
    end,
            Cur5 = Cur3,
            Words4 = Words3;
        _ -> Cur4 = (Cur ++ Ch),
            Cur5 = Cur4,
            Words4 = Words
    end,
                I2 = (I + 1),
                Fun_loop(Cur5, I2, S, Words4)
            catch
                break -> {Cur, I, S, Words}
            end;
        _ -> {Cur, I, S, Words}
    end
end,
{Cur5, I2, S, Words4} = Fun(Cur, I, S, Words),
        case (length(Cur5) > 0) of
        true -> Words5 = lists:append(Words4, [Cur5]),
            Words6 = Words5;
        _ -> Words6 = Words4
    end,
        Words6
    catch {return, V} -> V end.

join(Xs, Sep) ->
    try
        Res = "",
        I3 = 0,
        Fun2 = fun Fun2_loop(I3, Res, Sep, Xs) ->
    case (I3 < length(Xs)) of
        true ->
            try
                case (I3 > 0) of
        true -> Res2 = (Res ++ Sep),
            Res3 = Res2;
        _ -> Res3 = Res
    end,
                Res4 = (Res3 ++ lists:nth(I3 + 1, Xs)),
                I4 = (I3 + 1),
                Fun2_loop(I4, Res4, Sep, Xs)
            catch
                break -> {I3, Res, Sep, Xs}
            end;
        _ -> {I3, Res, Sep, Xs}
    end
end,
{I4, Res4, Sep, Xs} = Fun2(I3, Res, Sep, Xs),
        Res4
    catch {return, V} -> V end.

numberName(N) ->
    try
        Small = ["no", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"],
        Tens = ["ones", "ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"],
        case (N < 0) of
        true -> throw({return, ""});
        _ -> ok
    end,
        case (N < 20) of
        true -> throw({return, lists:nth(N + 1, Small)});
        _ -> ok
    end,
        case (N < 100) of
        true -> T = lists:nth(case erlang:is_integer((N div 10)) of true -> (N div 10); _ -> case erlang:is_float((N div 10)) of true -> trunc((N div 10)); _ -> list_to_integer((N div 10)) end end + 1, Tens),
            S2 = (N rem 10),
            case (S2 > 0) of
        true -> T2 = ((T ++ " ") ++ lists:nth(S2 + 1, Small)),
            T3 = T2;
        _ -> T3 = T
    end,
            throw({return, T3}),
            S3 = S2,
            T4 = T3;
        _ -> S3 = nil,
            T4 = nil
    end,
        ""
    catch {return, V} -> V end.

pluralizeFirst(S4, N2) ->
    try
        case (N2 == 1) of
        true -> throw({return, S4});
        _ -> ok
    end,
        W = fields(S4),
        case (length(W) > 0) of
        true -> W2 = lists:sublist(W, 0) ++ [(lists:nth(0 + 1, W) ++ "s")] ++ lists:nthtail(0 + 1, W),
            W3 = W2;
        _ -> W3 = W
    end,
        join(W3, " ")
    catch {return, V} -> V end.

randInt(Seed, N3) ->
    try
        Next = (((Seed * 1664525) + 1013904223) rem 2147483647),
        (Next rem N3)
    catch {return, V} -> V end.

slur(P, D) ->
    try
        case (length(P) =< 2) of
        true -> throw({return, P});
        _ -> ok
    end,
        A = [],
        I5 = 1,
        Fun3 = fun Fun3_loop(A, D, I5, P) ->
    case (I5 < (length(P) - 1)) of
        true ->
            try
                A2 = lists:append(A, [string:substr(P, I5 + 1, ((I5 + 1) - I5))]),
                I6 = (I5 + 1),
                Fun3_loop(A2, D, I6, P)
            catch
                break -> {A, D, I5, P}
            end;
        _ -> {A, D, I5, P}
    end
end,
{A2, D, I6, P} = Fun3(A, D, I5, P),
        Idx = (length(A2) - 1),
        Seed2 = D,
        Fun4 = fun Fun4_loop(A2, D, I6, Idx, P, Seed2) ->
    case (Idx >= 1) of
        true ->
            try
                Seed3 = (((Seed2 * 1664525) + 1013904223) rem 2147483647),
                case ((Seed3 rem 100) >= D) of
        true -> J = (Seed3 rem (Idx + 1)),
            Tmp = lists:nth(Idx + 1, A2),
            A3 = lists:sublist(A2, Idx) ++ [lists:nth(J + 1, A2)] ++ lists:nthtail(Idx + 1, A2),
            A4 = lists:sublist(A3, J) ++ [Tmp] ++ lists:nthtail(J + 1, A3),
            A5 = A4,
            J2 = J,
            Tmp2 = Tmp;
        _ -> A5 = A2,
            J2 = nil,
            Tmp2 = nil
    end,
                Idx2 = (Idx - 1),
                Fun4_loop(A5, D, I6, Idx2, P, Seed3)
            catch
                break -> {A2, D, I6, Idx, P, Seed2}
            end;
        _ -> {A2, D, I6, Idx, P, Seed2}
    end
end,
{A5, D, I6, Idx2, P, Seed3} = Fun4(A2, D, I6, Idx, P, Seed2),
        S5 = string:substr(P, 0 + 1, (1 - 0)),
        K = 0,
        Fun5 = fun Fun5_loop(A5, D, I6, Idx2, K, P, S5, Seed3) ->
    case (K < length(A5)) of
        true ->
            try
                S6 = (S5 + lists:nth(K + 1, A5)),
                K2 = (K + 1),
                Fun5_loop(A5, D, I6, Idx2, K2, P, S6, Seed3)
            catch
                break -> {A5, D, I6, Idx2, K, P, S5, Seed3}
            end;
        _ -> {A5, D, I6, Idx2, K, P, S5, Seed3}
    end
end,
{A5, D, I6, Idx2, K2, P, S6, Seed3} = Fun5(A5, D, I6, Idx2, K, P, S5, Seed3),
        S7 = (S6 + string:substr(P, (length(P) - 1) + 1, (length(P) - (length(P) - 1)))),
        W4 = fields(S7),
        join(W4, " ")
    catch {return, V} -> V end.

main() ->
    try
        I7 = 99,
        Fun6 = fun Fun6_loop(I7) ->
    case (I7 > 0) of
        true ->
            try
                io:format("~ts~n", [((((slur(numberName(I7), I7) ++ " ") ++ pluralizeFirst(slur("bottle of", I7), I7)) ++ " ") ++ slur("beer on the wall", I7))]),
                io:format("~ts~n", [((((slur(numberName(I7), I7) ++ " ") ++ pluralizeFirst(slur("bottle of", I7), I7)) ++ " ") ++ slur("beer", I7))]),
                io:format("~ts~n", [((((slur("take one", I7) ++ " ") ++ slur("down", I7)) ++ " ") ++ slur("pass it around", I7))]),
                io:format("~ts~n", [((((slur(numberName((I7 - 1)), I7) ++ " ") ++ pluralizeFirst(slur("bottle of", I7), (I7 - 1))) ++ " ") ++ slur("beer on the wall", I7))]),
                I8 = (I7 - 1),
                Fun6_loop(I8)
            catch
                break -> {I7}
            end;
        _ -> {I7}
    end
end,
{I8} = Fun6(I7),
        nil
    catch {return, V} -> V end.

main(_) ->
    main().
