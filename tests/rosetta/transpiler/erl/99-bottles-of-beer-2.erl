#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, fields/1, join/2, numbername/1, pluralizefirst/2, randint/2, slur/2, main/0]).

% Generated by Mochi transpiler v0.10.40 (c9f97e1bd3) on 2025-07-25 19:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

fields(S) ->
    try
        Words = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, S, Words) ->
    case (I < length(S)) of
        true ->
            Ch = string:substr(S, I + 1, ((I + 1) - I)),
            case (((Ch == " ") orelse (Ch == "\n")) orelse (Ch == "\t")) of
        true -> case (length(Cur) > 0) of
        true -> Words_2 = lists:append(Words, [Cur]),
            Cur_2 = "",
            Cur_3 = Cur_2,
            Words_3 = Words_2;
        _ -> Cur_3 = Cur,
            Words_3 = Words
    end,
            Cur_5 = Cur_3,
            Words_4 = Words_3;
        _ -> Cur_4 = (Cur ++ Ch),
            Cur_5 = Cur_4,
            Words_4 = Words
    end,
            I_2 = (I + 1),
            Fun_loop(Cur_5, I_2, S, Words_4);
        _ -> {Cur, I, S, Words}
    end
end,
{Cur_5, I_2, S, Words_4} = Fun(Cur, I, S, Words),
        case (length(Cur_5) > 0) of
        true -> Words_5 = lists:append(Words_4, [Cur_5]),
            Words_6 = Words_5;
        _ -> Words_6 = Words_4
    end,
        Words_6
    catch {return, Ret} -> Ret end.

join(Xs, Sep) ->
    try
        Res = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Res, Sep, Xs) ->
    case (I_3 < length(Xs)) of
        true ->
            case (I_3 > 0) of
        true -> Res_2 = (Res ++ Sep),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Res_4 = (Res_3 ++ lists:nth(I_3 + 1, Xs)),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Res_4, Sep, Xs);
        _ -> {I_3, Res, Sep, Xs}
    end
end,
{I_4, Res_4, Sep, Xs} = Fun_2(I_3, Res, Sep, Xs),
        Res_4
    catch {return, Ret} -> Ret end.

numbername(N) ->
    try
        Small = ["no", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"],
        Tens = ["ones", "ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"],
        case (N < 0) of
        true -> throw({return, ""});
        _ -> ok
    end,
        case (N < 20) of
        true -> throw({return, lists:nth(N + 1, Small)});
        _ -> ok
    end,
        case (N < 100) of
        true -> T = lists:nth(mochi_to_int((N div 10)) + 1, Tens),
            S_2 = (N rem 10),
            case (S_2 > 0) of
        true -> T_2 = ((T ++ " ") ++ lists:nth(S_2 + 1, Small)),
            T_3 = T_2;
        _ -> T_3 = T
    end,
            throw({return, T_3}),
            S_3 = S_2,
            T_4 = T_3;
        _ -> S_3 = nil,
            T_4 = nil
    end,
        ""
    catch {return, Ret} -> Ret end.

pluralizefirst(S_4, N_2) ->
    try
        case (N_2 == 1) of
        true -> throw({return, S_4});
        _ -> ok
    end,
        W = fields(S_4),
        case (length(W) > 0) of
        true -> W_2 = lists:sublist(W, 0) ++ [(lists:nth(0 + 1, W) ++ "s")] ++ lists:nthtail(0 + 1, W),
            W_3 = W_2;
        _ -> W_3 = W
    end,
        join(W_3, " ")
    catch {return, Ret} -> Ret end.

randint(Seed, N_3) ->
    try
        Next = (((Seed * 1664525) + 1013904223) rem 2147483647),
        (Next rem N_3)
    catch {return, Ret} -> Ret end.

slur(P, D) ->
    try
        case (length(P) =< 2) of
        true -> throw({return, P});
        _ -> ok
    end,
        A = [],
        I_5 = 1,
        Fun_3 = fun Fun_3_loop(A, D, I_5, P) ->
    case (I_5 < (length(P) - 1)) of
        true ->
            A_2 = lists:append(A, [string:substr(P, I_5 + 1, ((I_5 + 1) - I_5))]),
            I_6 = (I_5 + 1),
            Fun_3_loop(A_2, D, I_6, P);
        _ -> {A, D, I_5, P}
    end
end,
{A_2, D, I_6, P} = Fun_3(A, D, I_5, P),
        Idx = (length(A_2) - 1),
        Seed_2 = D,
        Fun_4 = fun Fun_4_loop(A_2, D, I_6, Idx, P, Seed_2) ->
    case (Idx >= 1) of
        true ->
            Seed_3 = (((Seed_2 * 1664525) + 1013904223) rem 2147483647),
            case ((Seed_3 rem 100) >= D) of
        true -> J = (Seed_3 rem (Idx + 1)),
            Tmp = lists:nth(Idx + 1, A_2),
            A_3 = lists:sublist(A_2, Idx) ++ [lists:nth(J + 1, A_2)] ++ lists:nthtail(Idx + 1, A_2),
            A_4 = lists:sublist(A_3, J) ++ [Tmp] ++ lists:nthtail(J + 1, A_3),
            A_5 = A_4,
            J_2 = J,
            Tmp_2 = Tmp;
        _ -> A_5 = A_2,
            J_2 = nil,
            Tmp_2 = nil
    end,
            Idx_2 = (Idx - 1),
            Fun_4_loop(A_5, D, I_6, Idx_2, P, Seed_3);
        _ -> {A_2, D, I_6, Idx, P, Seed_2}
    end
end,
{A_5, D, I_6, Idx_2, P, Seed_3} = Fun_4(A_2, D, I_6, Idx, P, Seed_2),
        S_5 = string:substr(P, 0 + 1, (1 - 0)),
        K = 0,
        Fun_5 = fun Fun_5_loop(A_5, D, I_6, Idx_2, K, P, S_5, Seed_3) ->
    case (K < length(A_5)) of
        true ->
            S_6 = (S_5 ++ lists:nth(K + 1, A_5)),
            K_2 = (K + 1),
            Fun_5_loop(A_5, D, I_6, Idx_2, K_2, P, S_6, Seed_3);
        _ -> {A_5, D, I_6, Idx_2, K, P, S_5, Seed_3}
    end
end,
{A_5, D, I_6, Idx_2, K_2, P, S_6, Seed_3} = Fun_5(A_5, D, I_6, Idx_2, K, P, S_5, Seed_3),
        S_7 = (S_6 ++ string:substr(P, (length(P) - 1) + 1, (length(P) - (length(P) - 1)))),
        W_4 = fields(S_7),
        join(W_4, " ")
    catch {return, Ret} -> Ret end.

main() ->
    try
        I_7 = 99,
        Fun_6 = fun Fun_6_loop(I_7) ->
    case (I_7 > 0) of
        true ->
            io:format("~ts~n", [((((slur(numbername(I_7), I_7) ++ " ") ++ pluralizefirst(slur("bottle of", I_7), I_7)) ++ " ") ++ slur("beer on the wall", I_7))]),
            io:format("~ts~n", [((((slur(numbername(I_7), I_7) ++ " ") ++ pluralizefirst(slur("bottle of", I_7), I_7)) ++ " ") ++ slur("beer", I_7))]),
            io:format("~ts~n", [((((slur("take one", I_7) ++ " ") ++ slur("down", I_7)) ++ " ") ++ slur("pass it around", I_7))]),
            io:format("~ts~n", [((((slur(numbername((I_7 - 1)), I_7) ++ " ") ++ pluralizefirst(slur("bottle of", I_7), (I_7 - 1))) ++ " ") ++ slur("beer on the wall", I_7))]),
            I_8 = (I_7 - 1),
            Fun_6_loop(I_8);
        _ -> {I_7}
    end
end,
{I_8} = Fun_6(I_7),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
