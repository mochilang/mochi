#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, split/2, rstripEmpty/1, spaces/1, pad/3, newFormatter/1, printFmt/2]).

% Generated by Mochi transpiler v0.10.39 (2bc5376a84) on 2025-07-24 21:24 +0700


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

split(S, Sep) ->
    try
        Parts = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, Parts, S, Sep) ->
    case (I < length(S)) of
        true ->
            case (((length(Sep) > 0) andalso ((I + length(Sep)) =< length(S))) andalso (string:substr(S, I + 1, ((I + length(Sep)) - I)) == Sep)) of
        true -> Parts_2 = lists:append(Parts, [Cur]),
            Cur_2 = "",
            I_2 = (I + length(Sep)),
            Cur_4 = Cur_2,
            I_4 = I_2,
            Parts_3 = Parts_2;
        _ -> Cur_3 = (Cur ++ string:substr(S, I + 1, ((I + 1) - I))),
            I_3 = (I + 1),
            Cur_4 = Cur_3,
            I_4 = I_3,
            Parts_3 = Parts
    end,
            Fun_loop(Cur_4, I_4, Parts_3, S, Sep);
        _ -> {Cur, I, Parts, S, Sep}
    end
end,
{Cur_4, I_4, Parts_3, S, Sep} = Fun(Cur, I, Parts, S, Sep),
        Parts_4 = lists:append(Parts_3, [Cur_4]),
        Parts_4
    catch {return, Ret} -> Ret end.

rstripEmpty(Words) ->
    try
        N = length(Words),
        Fun_2 = fun Fun_2_loop(N, Words) ->
    case ((N > 0) andalso (lists:nth((N - 1) + 1, Words) == "")) of
        true ->
            N_2 = (N - 1),
            Fun_2_loop(N_2, Words);
        _ -> {N, Words}
    end
end,
{N_2, Words} = Fun_2(N, Words),
        lists:sublist(Words, 1, (N_2 - 0))
    catch {return, Ret} -> Ret end.

spaces(N_3) ->
    try
        Out = "",
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(I_5, N_3, Out) ->
    case (I_5 < N_3) of
        true ->
            Out_2 = (Out ++ " "),
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, N_3, Out_2);
        _ -> {I_5, N_3, Out}
    end
end,
{I_6, N_3, Out_2} = Fun_3(I_5, N_3, Out),
        Out_2
    catch {return, Ret} -> Ret end.

pad(Word, Width, Align) ->
    try
        Diff = (Width - length(Word)),
        case (Align == 0) of
        true -> throw({return, (Word ++ spaces(Diff))});
        _ -> ok
    end,
        case (Align == 2) of
        true -> throw({return, (spaces(Diff) ++ Word)});
        _ -> ok
    end,
        Left = mochi_to_int((Diff div 2)),
        Right = (Diff - Left),
        ((spaces(Left) ++ Word) ++ spaces(Right))
    catch {return, Ret} -> Ret end.

newFormatter(Text) ->
    try
        Lines = split(Text, "\n"),
        FmtLines = [],
        Width_2 = [],
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(FmtLines, I_7, Lines, Text, Width_2) ->
    case (I_7 < length(Lines)) of
        true ->
            try
                case (length(lists:nth(I_7 + 1, Lines)) == 0) of
        true -> I_8 = (I_7 + 1),
            throw({continue, FmtLines, I_8, Lines, Text, Width_2}),
            I_9 = I_8;
        _ -> I_9 = I_7
    end,
                Words_2 = rstripEmpty(split(lists:nth(I_9 + 1, Lines), "$")),
                FmtLines_2 = lists:append(FmtLines, [Words_2]),
                J = 0,
                Fun_4 = fun Fun_4_loop(FmtLines_2, I_9, J, Lines, Text, Width_2, Words_2) ->
    case (J < length(Words_2)) of
        true ->
            Wlen = length(lists:nth(J + 1, Words_2)),
            case (J == length(Width_2)) of
        true -> Width_3 = lists:append(Width_2, [Wlen]),
            Width_6 = Width_3;
        _ -> case (Wlen > lists:nth(J + 1, Width_2)) of
        true -> Width_4 = lists:sublist(Width_2, J) ++ [Wlen] ++ lists:nthtail(J + 1, Width_2),
            Width_5 = Width_4;
        _ -> Width_5 = Width_2
    end,
            Width_6 = Width_5
    end,
            J_2 = (J + 1),
            Fun_4_loop(FmtLines_2, I_9, J_2, Lines, Text, Width_6, Words_2);
        _ -> {FmtLines_2, I_9, J, Lines, Text, Width_2, Words_2}
    end
end,
{FmtLines_2, I_9, J_2, Lines, Text, Width_6, Words_2} = Fun_4(FmtLines_2, I_9, J, Lines, Text, Width_2, Words_2),
                I_10 = (I_9 + 1),
                Fun_5_loop(FmtLines_2, I_10, Lines, Text, Width_6)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_5_loop(C0, C1, C2, C3, C4);
                break -> {FmtLines, I_7, Lines, Text, Width_2}
            end;
        _ -> {FmtLines, I_7, Lines, Text, Width_2}
    end
end,
{FmtLines_2, I_10, Lines, Text, Width_6} = Fun_5(FmtLines, I_7, Lines, Text, Width_2),
        #{"text" => FmtLines_2, "width" => Width_6}
    catch {return, Ret} -> Ret end.

printFmt(F, Align_2) ->
    try
        Lines_2 = maps:get("text", F),
        Width_7 = maps:get("width", F),
        I_11 = 0,
        Fun_7 = fun Fun_7_loop(Align_2, F, I_11, Lines_2, Width_7) ->
    case (I_11 < length(Lines_2)) of
        true ->
            Words_3 = lists:nth(I_11 + 1, Lines_2),
            Line = "",
            J_3 = 0,
            Fun_6 = fun Fun_6_loop(Align_2, F, I_11, J_3, Line, Lines_2, Width_7, Words_3) ->
    case (J_3 < length(Words_3)) of
        true ->
            Line_2 = ((Line ++ pad(lists:nth(J_3 + 1, Words_3), lists:nth(J_3 + 1, Width_7), Align_2)) ++ " "),
            J_4 = (J_3 + 1),
            Fun_6_loop(Align_2, F, I_11, J_4, Line_2, Lines_2, Width_7, Words_3);
        _ -> {Align_2, F, I_11, J_3, Line, Lines_2, Width_7, Words_3}
    end
end,
{Align_2, F, I_11, J_4, Line_2, Lines_2, Width_7, Words_3} = Fun_6(Align_2, F, I_11, J_3, Line, Lines_2, Width_7, Words_3),
            io:format("~ts~n", [Line_2]),
            I_12 = (I_11 + 1),
            Fun_7_loop(Align_2, F, I_12, Lines_2, Width_7);
        _ -> {Align_2, F, I_11, Lines_2, Width_7}
    end
end,
{Align_2, F, I_12, Lines_2, Width_7} = Fun_7(Align_2, F, I_11, Lines_2, Width_7),
        io:format("~ts~n", [""]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    erlang:put('text', ((((("Given$a$text$file$of$many$lines,$where$fields$within$a$line\n" ++ "are$delineated$by$a$single$'dollar'$character,$write$a$program\n") ++ "that$aligns$each$column$of$fields$by$ensuring$that$words$in$each\n") ++ "column$are$separated$by$at$least$one$space.\n") ++ "Further,$allow$for$each$word$in$a$column$to$be$either$left\n") ++ "justified,$right$justified,$or$center$justified$within$its$column.")),
    erlang:put('f', newFormatter(erlang:get('text'))),
    printFmt(erlang:get('f'), 0),
    printFmt(erlang:get('f'), 1),
    printFmt(erlang:get('f'), 2).
