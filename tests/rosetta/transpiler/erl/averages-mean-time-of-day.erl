#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, sinapprox/1, cosapprox/1, atanapprox/1, atan2approx/2, digit/1, parsetwo/2, parsesec/1, pad/1, meantime/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (5ec8b59a93) on 2025-07-25 12:29 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

sinapprox(X) ->
    try
        Term = X,
        Sum = X,
        N = 1,
        Fun = fun Fun_loop(N, Sum, Term, X) ->
    case (N =< 8) of
        true ->
            Denom = float(((2 * N) * ((2 * N) + 1))),
            Term_2 = (((-Term * X) * X) / Denom),
            Sum_2 = (Sum + Term_2),
            N_2 = (N + 1),
            Fun_loop(N_2, Sum_2, Term_2, X);
        _ -> {N, Sum, Term, X}
    end
end,
{N_2, Sum_2, Term_2, X} = Fun(N, Sum, Term, X),
        Sum_2
    catch {return, Ret} -> Ret end.

cosapprox(X_2) ->
    try
        Term_3 = 1,
        Sum_3 = 1,
        N_3 = 1,
        Fun_2 = fun Fun_2_loop(N_3, Sum_3, Term_3, X_2) ->
    case (N_3 =< 8) of
        true ->
            Denom_2 = float((((2 * N_3) - 1) * (2 * N_3))),
            Term_4 = (((-Term_3 * X_2) * X_2) / Denom_2),
            Sum_4 = (Sum_3 + Term_4),
            N_4 = (N_3 + 1),
            Fun_2_loop(N_4, Sum_4, Term_4, X_2);
        _ -> {N_3, Sum_3, Term_3, X_2}
    end
end,
{N_4, Sum_4, Term_4, X_2} = Fun_2(N_3, Sum_3, Term_3, X_2),
        Sum_4
    catch {return, Ret} -> Ret end.

atanapprox(X_3) ->
    try
        case (X_3 > 1) of
        true -> throw({return, ((3.141592653589793 / 2) - (X_3 / ((X_3 * X_3) + 0.28)))});
        _ -> ok
    end,
        case (X_3 < -1) of
        true -> throw({return, ((-3.141592653589793 / 2) - (X_3 / ((X_3 * X_3) + 0.28)))});
        _ -> ok
    end,
        (X_3 / (1 + ((0.28 * X_3) * X_3)))
    catch {return, Ret} -> Ret end.

atan2approx(Y, X_4) ->
    try
        case (X_4 > 0) of
        true -> throw({return, atanapprox((Y / X_4))});
        _ -> ok
    end,
        case (X_4 < 0) of
        true -> case (Y >= 0) of
        true -> throw({return, (atanapprox((Y / X_4)) + 3.141592653589793)});
        _ -> ok
    end,
            throw({return, (atanapprox((Y / X_4)) - 3.141592653589793)});
        _ -> ok
    end,
        case (Y > 0) of
        true -> throw({return, (3.141592653589793 / 2)});
        _ -> ok
    end,
        case (Y < 0) of
        true -> throw({return, (-3.141592653589793 / 2)});
        _ -> ok
    end,
        0
    catch {return, Ret} -> Ret end.

digit(Ch) ->
    try
        Digits = "0123456789",
        I = 0,
        Fun_3 = fun Fun_3_loop(Ch, Digits, I) ->
    case (I < length(Digits)) of
        true ->
            case (string:substr(Digits, I + 1, ((I + 1) - I)) == Ch) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_3_loop(Ch, Digits, I_2);
        _ -> {Ch, Digits, I}
    end
end,
{Ch, Digits, I_2} = Fun_3(Ch, Digits, I),
        0
    catch {return, Ret} -> Ret end.

parsetwo(S, Idx) ->
    try
        ((digit(string:substr(S, Idx + 1, ((Idx + 1) - Idx))) * 10) + digit(string:substr(S, (Idx + 1) + 1, ((Idx + 2) - (Idx + 1)))))
    catch {return, Ret} -> Ret end.

parsesec(S_2) ->
    try
        H = parsetwo(S_2, 0),
        M = parsetwo(S_2, 3),
        Sec = parsetwo(S_2, 6),
        Tmp = ((((H * 60) + M) * 60) + Sec),
        float(Tmp)
    catch {return, Ret} -> Ret end.

pad(N_5) ->
    try
        (case (N_5 < 10) of
    true -> ("0" ++ lists:flatten(io_lib:format("~p", [N_5])));
    _ -> lists:flatten(io_lib:format("~p", [N_5]))
end)
    catch {return, Ret} -> Ret end.

meantime(Times) ->
    try
        Ssum = 0,
        Csum = 0,
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(Csum, I_3, Ssum, Times) ->
    case (I_3 < length(Times)) of
        true ->
            Sec_2 = parsesec(lists:nth(I_3 + 1, Times)),
            Ang = (((Sec_2 * 2) * 3.141592653589793) / 86400),
            Ssum_2 = (Ssum + sinapprox(Ang)),
            Csum_2 = (Csum + cosapprox(Ang)),
            I_4 = (I_3 + 1),
            Fun_4_loop(Csum_2, I_4, Ssum_2, Times);
        _ -> {Csum, I_3, Ssum, Times}
    end
end,
{Csum_2, I_4, Ssum_2, Times} = Fun_4(Csum, I_3, Ssum, Times),
        Theta = atan2approx(Ssum_2, Csum_2),
        Frac = (Theta / (2 * 3.141592653589793)),
        Fun_5 = fun Fun_5_loop(Csum_2, Frac, I_4, Ssum_2, Theta, Times) ->
    case (Frac < 0) of
        true ->
            Frac_2 = (Frac + 1),
            Fun_5_loop(Csum_2, Frac_2, I_4, Ssum_2, Theta, Times);
        _ -> {Csum_2, Frac, I_4, Ssum_2, Theta, Times}
    end
end,
{Csum_2, Frac_2, I_4, Ssum_2, Theta, Times} = Fun_5(Csum_2, Frac, I_4, Ssum_2, Theta, Times),
        Total = (Frac_2 * 86400),
        Si = mochi_to_int(Total),
        H_2 = mochi_to_int((Si div 3600)),
        M_2 = mochi_to_int(((Si rem 3600) div 60)),
        S_3 = mochi_to_int((Si rem 60)),
        ((((pad(H_2) ++ ":") ++ pad(M_2)) ++ ":") ++ pad(S_3))
    catch {return, Ret} -> Ret end.

main() ->
    try
        Inputs = ["23:00:17", "23:40:20", "00:12:45", "00:17:19"],
        io:format("~p~n", [meantime(Inputs)]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('PI', 3.141592653589793),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
