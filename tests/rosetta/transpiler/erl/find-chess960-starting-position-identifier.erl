#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, indexof/2, strreplace/3, g2l/1, spid/1, main/0]).

% Generated by Mochi transpiler v0.10.50 (e649287d54) on 2025-07-30 14:16 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.

indexof(S, Sub) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, S, Sub) ->
    case (I =< (length(S) - length(Sub))) of
        true ->
            case (string:substr(S, I + 1, ((I + length(Sub)) - I)) == Sub) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, S, Sub);
        _ -> {I, S, Sub}
    end
end,
{I_2, S, Sub} = Fun(I, S, Sub),
        -1
    catch {return, Ret} -> Ret end.

strreplace(S_2, Old, New) ->
    try
        Res = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, New, Old, Res, S_2) ->
    case (I_3 < length(S_2)) of
        true ->
            case (((length(Old) > 0) andalso ((I_3 + length(Old)) =< length(S_2))) andalso (string:substr(S_2, I_3 + 1, ((I_3 + length(Old)) - I_3)) == Old)) of
        true -> Res_2 = (Res ++ New),
            I_4 = (I_3 + length(Old)),
            I_6 = I_4,
            Res_4 = Res_2;
        _ -> Res_3 = (Res ++ string:substr(S_2, I_3 + 1, ((I_3 + 1) - I_3))),
            I_5 = (I_3 + 1),
            I_6 = I_5,
            Res_4 = Res_3
    end,
            Fun_2_loop(I_6, New, Old, Res_4, S_2);
        _ -> {I_3, New, Old, Res, S_2}
    end
end,
{I_6, New, Old, Res_4, S_2} = Fun_2(I_3, New, Old, Res, S_2),
        Res_4
    catch {return, Ret} -> Ret end.

g2l(Pieces) ->
    try
        Lets = "",
        I_7 = 0,
        Fun_3 = fun Fun_3_loop(I_7, Lets, Pieces) ->
    case (I_7 < length(Pieces)) of
        true ->
            Ch = string:substr(Pieces, I_7 + 1, ((I_7 + 1) - I_7)),
            Lets_2 = (Lets ++ maps:get(Ch, erlang:get('g2lMap'), nil)),
            I_8 = (I_7 + 1),
            Fun_3_loop(I_8, Lets_2, Pieces);
        _ -> {I_7, Lets, Pieces}
    end
end,
{I_8, Lets_2, Pieces} = Fun_3(I_7, Lets, Pieces),
        Lets_2
    catch {return, Ret} -> Ret end.

spid(Pieces_2) ->
    try
        Pieces_3 = g2l(Pieces_2),
        case (length(Pieces_3) /= 8) of
        true -> throw({return, -1});
        _ -> ok
    end,
        Fun_4 = fun Fun_4_loop(List, Pieces_3) ->
    case List of
        [] -> {Pieces_3};
        [One|One_rest] ->
            Count = 0,
            I_9 = 0,
            Fun_5 = fun Fun_5_loop(Count, I_9, One, Pieces_3) ->
    case (I_9 < length(Pieces_3)) of
        true ->
            case (string:substr(Pieces_3, I_9 + 1, ((I_9 + 1) - I_9)) == One) of
        true -> Count_2 = (Count + 1),
            Count_3 = Count_2;
        _ -> Count_3 = Count
    end,
            I_10 = (I_9 + 1),
            Fun_5_loop(Count_3, I_10, One, Pieces_3);
        _ -> {Count, I_9, One, Pieces_3}
    end
end,
{Count_3, I_10, One, Pieces_3} = Fun_5(Count, I_9, One, Pieces_3),
            case (Count_3 /= 1) of
        true -> throw({return, -1});
        _ -> ok
    end,
            Fun_4_loop(One_rest, Pieces_3)
    end
end,
{Pieces_3} = Fun_4(["K", "Q"], Pieces_3),
        Fun_6 = fun Fun_6_loop(List, Pieces_3) ->
    case List of
        [] -> {Pieces_3};
        [Two|Two_rest] ->
            Count_4 = 0,
            I_11 = 0,
            Fun_7 = fun Fun_7_loop(Count_4, I_11, Pieces_3, Two) ->
    case (I_11 < length(Pieces_3)) of
        true ->
            case (string:substr(Pieces_3, I_11 + 1, ((I_11 + 1) - I_11)) == Two) of
        true -> Count_5 = (Count_4 + 1),
            Count_6 = Count_5;
        _ -> Count_6 = Count_4
    end,
            I_12 = (I_11 + 1),
            Fun_7_loop(Count_6, I_12, Pieces_3, Two);
        _ -> {Count_4, I_11, Pieces_3, Two}
    end
end,
{Count_6, I_12, Pieces_3, Two} = Fun_7(Count_4, I_11, Pieces_3, Two),
            case (Count_6 /= 2) of
        true -> throw({return, -1});
        _ -> ok
    end,
            Fun_6_loop(Two_rest, Pieces_3)
    end
end,
{Pieces_3} = Fun_6(["R", "N", "B"], Pieces_3),
        R1 = mochi_index_of(Pieces_3, "R"),
        R2 = ((mochi_index_of(string:substr(Pieces_3, (R1 + 1) + 1, (length(Pieces_3) - (R1 + 1))), "R") + R1) + 1),
        K = mochi_index_of(Pieces_3, "K"),
        case ((K < R1) orelse (K > R2)) of
        true -> throw({return, -1});
        _ -> ok
    end,
        B1 = mochi_index_of(Pieces_3, "B"),
        B2 = ((mochi_index_of(string:substr(Pieces_3, (B1 + 1) + 1, (length(Pieces_3) - (B1 + 1))), "B") + B1) + 1),
        case (((B2 - B1) rem 2) == 0) of
        true -> throw({return, -1});
        _ -> ok
    end,
        PiecesN = strreplace(Pieces_3, "Q", ""),
        PiecesN_2 = strreplace(PiecesN, "B", ""),
        N1 = mochi_index_of(PiecesN_2, "N"),
        N2 = ((mochi_index_of(string:substr(PiecesN_2, (N1 + 1) + 1, (length(PiecesN_2) - (N1 + 1))), "N") + N1) + 1),
        Np = (lists:flatten(io_lib:format("~p", [N1])) ++ lists:flatten(io_lib:format("~p", [N2]))),
        N = maps:get(Np, erlang:get('ntable'), nil),
        PiecesQ = strreplace(Pieces_3, "B", ""),
        Q = mochi_index_of(PiecesQ, "Q"),
        D = mochi_index_of("0246", lists:flatten(io_lib:format("~p", [B1]))),
        L = mochi_index_of("1357", lists:flatten(io_lib:format("~p", [B2]))),
        case (D == (0 - 1)) of
        true -> D_2 = mochi_index_of("0246", lists:flatten(io_lib:format("~p", [B2]))),
            L_2 = mochi_index_of("1357", lists:flatten(io_lib:format("~p", [B1]))),
            D_3 = D_2,
            L_3 = L_2;
        _ -> D_3 = D,
            L_3 = L
    end,
        {((((96 * N) + (16 * Q)) + (4 * D_3)) + L_3), Pieces_3}
    catch {return, Ret} -> Ret end.

main() ->
    try
        Fun_8 = fun Fun_8_loop(List) ->
    case List of
        [] -> {};
        [Pieces_4|Pieces_4_rest] ->
            io:format("~ts~n", [((((Pieces_4 ++ " or ") ++ g2l(Pieces_4)) ++ " has SP-ID of ") ++ lists:flatten(io_lib:format("~p", [spid(Pieces_4)])))]),
            Fun_8_loop(Pieces_4_rest)
    end
end,
{} = Fun_8(["♕♘♖♗♗♘♔♖", "♖♘♗♕♔♗♘♖", "♖♕♘♗♗♔♖♘", "♖♘♕♗♗♔♖♘"]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('glyphs', "♜♞♝♛♚♖♘♗♕♔"),
    erlang:put('g2lMap', #{"♜" => "R", "♞" => "N", "♝" => "B", "♛" => "Q", "♚" => "K", "♖" => "R", "♘" => "N", "♗" => "B", "♕" => "Q", "♔" => "K"}),
    erlang:put('names', #{"R" => "rook", "N" => "knight", "B" => "bishop", "Q" => "queen", "K" => "king"}),
    erlang:put('ntable', #{"01" => 0, "02" => 1, "03" => 2, "04" => 3, "12" => 4, "13" => 5, "14" => 6, "23" => 7, "24" => 8, "34" => 9}),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
