#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, inbounds/2, hasneighbor/2]).

% Generated by Mochi transpiler v0.10.41 (cac7e4e2bd) on 2025-07-26 17:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

inbounds(X_3, Y) ->
    try
        ((((X_3 >= 0) andalso (X_3 < 400)) andalso (erlang:get('y') >= 0)) andalso (erlang:get('y') < 300))
    catch {return, Ret} -> Ret end.

hasneighbor(X_4, Y_2) ->
    try
        Dy = -1,
        Fun_4 = fun Fun_4_loop(Dy, X_4, Y_2) ->
    case (Dy =< 1) of
        true ->
            Dx = -1,
            Fun_3 = fun Fun_3_loop(Dx, Dy, X_4, Y_2) ->
    case (Dx =< 1) of
        true ->
            case not ((Dx == 0) andalso (Dy == 0)) of
        true -> Nx = (X_4 + Dx),
            Ny = (erlang:get('y') + Dy),
            case (inbounds(Nx, Ny) andalso (lists:nth(Nx + 1, lists:nth(Ny + 1, erlang:get('grid'))) == 255)) of
        true -> throw({return, true});
        _ -> ok
    end,
            Nx_2 = Nx,
            Ny_2 = Ny;
        _ -> Nx_2 = nil,
            Ny_2 = nil
    end,
            Dx_2 = (Dx + 1),
            Fun_3_loop(Dx_2, Dy, X_4, Y_2);
        _ -> {Dx, Dy, X_4, Y_2}
    end
end,
{Dx_2, Dy, X_4, Y_2} = Fun_3(Dx, Dy, X_4, Y_2),
            Dy_2 = (Dy + 1),
            Fun_4_loop(Dy_2, X_4, Y_2);
        _ -> {Dy, X_4, Y_2}
    end
end,
{Dy_2, X_4, Y_2} = Fun_4(Dy, X_4, Y_2),
        false
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('w', 400),
    erlang:put('h', 300),
    erlang:put('n', 15000),
    erlang:put('frost', 255),
    erlang:put('grid', []),
    erlang:put('y', 0),
    Fun_2 = fun Fun_2_loop() ->
    case (erlang:get('y') < 300) of
        true ->
            Row = [],
            X = 0,
            Fun = fun Fun_loop(Row, X) ->
    case (X < 400) of
        true ->
            Row_2 = lists:append(Row, [0]),
            X_2 = (X + 1),
            Fun_loop(Row_2, X_2);
        _ -> {Row, X}
    end
end,
{Row_2, X_2} = Fun(Row, X),
            erlang:put('grid', lists:append(erlang:get('grid'), [Row_2])),
            erlang:put('y', (erlang:get('y') + 1)),
            Fun_2_loop();
        _ -> {}
    end
end,
{} = Fun_2(),
    Grid = erlang:get('grid'),
    Tmp = lists:nth((300 div 3) + 1, Grid),
    Tmp_2 = lists:sublist(Tmp, (400 div 3)) ++ [255] ++ lists:nthtail((400 div 3) + 1, Tmp),
    Grid_2 = lists:sublist(Grid, (300 div 3)) ++ [Tmp_2] ++ lists:nthtail((300 div 3) + 1, Grid),
    erlang:put('grid', Grid_2),
    erlang:put('a', 0),
    Fun_8 = fun Fun_8_loop(Grid_2, Tmp_2) ->
    case (erlang:get('a') < 15000) of
        true ->
            try
                Px = (mochi_now() rem 400),
                Py = (mochi_now() rem 300),
                case (lists:nth(Px + 1, lists:nth(Py + 1, erlang:get('grid'))) == 255) of
        true -> Lost = false,
            Fun_5 = fun Fun_5_loop(Grid_2, Lost, Px, Py, Tmp_2) ->
    case true of
        true ->
            try
                Px_2 = ((Px + (mochi_now() rem 3)) - 1),
                Py_2 = ((Py + (mochi_now() rem 3)) - 1),
                case not inbounds(Px_2, Py_2) of
        true -> Lost_2 = true,
            throw(break),
            Lost_3 = Lost_2;
        _ -> Lost_3 = Lost
    end,
                case (lists:nth(Px_2 + 1, lists:nth(Py_2 + 1, erlang:get('grid'))) /= 255) of
        true -> throw(break);
        _ -> ok
    end,
                Fun_5_loop(Grid_2, Lost_3, Px_2, Py_2, Tmp_2)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_5_loop(C0, C1, C2, C3, C4);
                break -> {Grid_2, Lost, Px, Py, Tmp_2}
            end;
        _ -> {Grid_2, Lost, Px, Py, Tmp_2}
    end
end,
{Grid_2, Lost_3, Px_2, Py_2, Tmp_2} = Fun_5(Grid_2, Lost, Px, Py, Tmp_2),
            case (Lost_3 /= nil) of
        true -> throw({continue, Grid_2, Tmp_2});
        _ -> ok
    end,
            Fun_7 = Fun_5,
            Lost_7 = Lost_3,
            Px_4 = Px_2,
            Py_4 = Py_2;
        _ -> Lost_4 = false,
            Fun_6 = fun Fun_6_loop(Grid_2, Lost_4, Px, Py, Tmp_2) ->
    case not hasneighbor(Px, Py) of
        true ->
            try
                Px_3 = ((Px + (mochi_now() rem 3)) - 1),
                Py_3 = ((Py + (mochi_now() rem 3)) - 1),
                case not inbounds(Px_3, Py_3) of
        true -> Lost_5 = true,
            throw(break),
            Lost_6 = Lost_5;
        _ -> Lost_6 = Lost_4
    end,
                Fun_6_loop(Grid_2, Lost_6, Px_3, Py_3, Tmp_2)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_6_loop(C0, C1, C2, C3, C4);
                break -> {Grid_2, Lost_4, Px, Py, Tmp_2}
            end;
        _ -> {Grid_2, Lost_4, Px, Py, Tmp_2}
    end
end,
{Grid_2, Lost_6, Px_3, Py_3, Tmp_2} = Fun_6(Grid_2, Lost_4, Px, Py, Tmp_2),
            case (Lost_6 /= nil) of
        true -> throw({continue, Grid_2, Tmp_2});
        _ -> ok
    end,
            Fun_7 = Fun_6,
            Lost_7 = Lost_6,
            Px_4 = Px_3,
            Py_4 = Py_3
    end,
                Grid_3 = erlang:get('grid'),
                Tmp_3 = lists:nth(Py_4 + 1, Grid_3),
                Tmp_4 = lists:sublist(Tmp_3, Px_4) ++ [255] ++ lists:nthtail(Px_4 + 1, Tmp_3),
                Grid_4 = lists:sublist(Grid_3, Py_4) ++ [Tmp_4] ++ lists:nthtail(Py_4 + 1, Grid_3),
                erlang:put('grid', Grid_4),
                erlang:put('a', (erlang:get('a') + 1)),
                Fun_8_loop(Grid_4, Tmp_4)
            catch
                {continue, C0, C1} -> Fun_8_loop(C0, C1);
                break -> {Grid_2, Tmp_2}
            end;
        _ -> {Grid_2, Tmp_2}
    end
end,
{Grid_4, Tmp_4} = Fun_8(Grid_2, Tmp_2),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = erlang:abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
