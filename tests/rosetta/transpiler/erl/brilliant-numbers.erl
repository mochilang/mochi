#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, primesupto/1, sortints/1, commatize/1, getbrilliant/3, main/0]).

% Generated by Mochi transpiler v0.10.56 (847315c0cc) on 2025-08-03 16:05 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_pad_start(S, Len, Ch) ->
    Fill0 = case Ch of
        "" -> " ";
        _ -> Ch
    end,
    Fill = string:substr(Fill0, 1, 1),
    SL = length(S),
    case SL >= Len of
        true -> S;
        _ -> string:copies(Fill, Len - SL) ++ S
    end.

primesupto(N) ->
    try
        Sieve = [],
        I = 0,
        Fun = fun Fun_loop(I, N, Sieve) ->
    case (I =< N) of
        true ->
            Sieve_2 = lists:append(Sieve, [true]),
            I_2 = (I + 1),
            Fun_loop(I_2, N, Sieve_2);
        _ -> {I, N, Sieve}
    end
end,
{I_2, N, Sieve_2} = Fun(I, N, Sieve),
        P = 2,
        Fun_4 = fun Fun_4_loop(I_2, N, P, Sieve_2) ->
    case ((P * P) =< N) of
        true ->
            case (case erlang:is_map(Sieve_2) of true -> maps:get(P, Sieve_2, nil); _ -> lists:nth(P + 1, Sieve_2) end) of
        true -> M = (P * P),
            Fun_2 = fun Fun_2_loop(I_2, M, N, P, Sieve_2) ->
    case (M =< N) of
        true ->
            Sieve_3 = lists:sublist(Sieve_2, M) ++ [false] ++ lists:nthtail(M + 1, Sieve_2),
            M_2 = (M + P),
            Fun_2_loop(I_2, M_2, N, P, Sieve_3);
        _ -> {I_2, M, N, P, Sieve_2}
    end
end,
{I_2, M_2, N, P, Sieve_3} = Fun_2(I_2, M, N, P, Sieve_2),
            Fun_3 = Fun_2,
            M_3 = M_2,
            Sieve_4 = Sieve_3;
        _ -> Fun_3 = Fun,
            M_3 = nil,
            Sieve_4 = Sieve_2
    end,
            P_2 = (P + 1),
            Fun_4_loop(I_2, N, P_2, Sieve_4);
        _ -> {I_2, N, P, Sieve_2}
    end
end,
{I_2, N, P_2, Sieve_4} = Fun_4(I_2, N, P, Sieve_2),
        Res = [],
        X = 2,
        Fun_5 = fun Fun_5_loop(I_2, N, P_2, Res, Sieve_4, X) ->
    case (X =< N) of
        true ->
            case (case erlang:is_map(Sieve_4) of true -> maps:get(X, Sieve_4, nil); _ -> lists:nth(X + 1, Sieve_4) end) of
        true -> Res_2 = lists:append(Res, [X]),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            X_2 = (X + 1),
            Fun_5_loop(I_2, N, P_2, Res_3, Sieve_4, X_2);
        _ -> {I_2, N, P_2, Res, Sieve_4, X}
    end
end,
{I_2, N, P_2, Res_3, Sieve_4, X_2} = Fun_5(I_2, N, P_2, Res, Sieve_4, X),
        Res_3
    catch {return, Ret} -> Ret end.

sortints(Xs) ->
    try
        Res_4 = [],
        Tmp = Xs,
        Fun_8 = fun Fun_8_loop(Res_4, Tmp, Xs) ->
    case (length(Tmp) > 0) of
        true ->
            Min = (case erlang:is_map(Tmp) of true -> maps:get(0, Tmp, nil); _ -> lists:nth(0 + 1, Tmp) end),
            Idx = 0,
            I_3 = 1,
            Fun_6 = fun Fun_6_loop(I_3, Idx, Min, Res_4, Tmp, Xs) ->
    case (I_3 < length(Tmp)) of
        true ->
            case ((case erlang:is_map(Tmp) of true -> maps:get(I_3, Tmp, nil); _ -> lists:nth(I_3 + 1, Tmp) end) < Min) of
        true -> Min_2 = (case erlang:is_map(Tmp) of true -> maps:get(I_3, Tmp, nil); _ -> lists:nth(I_3 + 1, Tmp) end),
            Idx_2 = I_3,
            Idx_3 = Idx_2,
            Min_3 = Min_2;
        _ -> Idx_3 = Idx,
            Min_3 = Min
    end,
            I_4 = (I_3 + 1),
            Fun_6_loop(I_4, Idx_3, Min_3, Res_4, Tmp, Xs);
        _ -> {I_3, Idx, Min, Res_4, Tmp, Xs}
    end
end,
{I_4, Idx_3, Min_3, Res_4, Tmp, Xs} = Fun_6(I_3, Idx, Min, Res_4, Tmp, Xs),
            Res_5 = lists:append(Res_4, [Min_3]),
            Out = [],
            J = 0,
            Fun_7 = fun Fun_7_loop(I_4, Idx_3, J, Min_3, Out, Res_5, Tmp, Xs) ->
    case (J < length(Tmp)) of
        true ->
            case (J /= Idx_3) of
        true -> Out_2 = lists:append(Out, [(case erlang:is_map(Tmp) of true -> maps:get(J, Tmp, nil); _ -> lists:nth(J + 1, Tmp) end)]),
            Out_3 = Out_2;
        _ -> Out_3 = Out
    end,
            J_2 = (J + 1),
            Fun_7_loop(I_4, Idx_3, J_2, Min_3, Out_3, Res_5, Tmp, Xs);
        _ -> {I_4, Idx_3, J, Min_3, Out, Res_5, Tmp, Xs}
    end
end,
{I_4, Idx_3, J_2, Min_3, Out_3, Res_5, Tmp, Xs} = Fun_7(I_4, Idx_3, J, Min_3, Out, Res_5, Tmp, Xs),
            Tmp_2 = Out_3,
            Fun_8_loop(Res_5, Tmp_2, Xs);
        _ -> {Res_4, Tmp, Xs}
    end
end,
{Res_5, Tmp_2, Xs} = Fun_8(Res_4, Tmp, Xs),
        Res_5
    catch {return, Ret} -> Ret end.

commatize(N_2) ->
    try
        S = lists:flatten(io_lib:format("~p", [N_2])),
        I_5 = (length(S) - 3),
        Fun_9 = fun Fun_9_loop(I_5, N_2, S) ->
    case (I_5 >= 1) of
        true ->
            S_2 = ((string:substr(S, 0 + 1, (I_5 - 0)) ++ ",") ++ string:substr(S, I_5 + 1, (length(S) - I_5))),
            I_6 = (I_5 - 3),
            Fun_9_loop(I_6, N_2, S_2);
        _ -> {I_5, N_2, S}
    end
end,
{I_6, N_2, S_2} = Fun_9(I_5, N_2, S),
        S_2
    catch {return, Ret} -> Ret end.

getbrilliant(Digits, Limit, CountOnly) ->
    try
        Brilliant = [],
        Count = 0,
        Pow = 1,
        Next = 999999999999999,
        K = 1,
        Fun_13 = fun Fun_13_loop(Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow) ->
    case (K =< Digits) of
        true ->
            try
                S_3 = [],
                Fun_10 = fun Fun_10_loop(List, Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow, S_3) ->
    case List of
        [] -> {Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow, S_3};
        [P_3|P_3_rest] ->
        try
            case (P_3 >= (Pow * 10)) of
        true -> throw(break);
        _ -> ok
    end,
            case (P_3 > Pow) of
        true -> S_4 = lists:append(S_3, [P_3]),
            S_5 = S_4;
        _ -> S_5 = S_3
    end,
            Fun_10_loop(P_3_rest, Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow, S_5)
        catch
            {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_10_loop(P_3_rest, C0, C1, C2, C3, C4, C5, C6, C7, C8);
            {break, B0, B1, B2, B3, B4, B5, B6, B7, B8} -> {B0, B1, B2, B3, B4, B5, B6, B7, B8};
            break -> {Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow, S_3}
        end
    end
end,
{Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow, S_5} = Fun_10(erlang:get('primes'), Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow, S_3),
                I_7 = 0,
                Fun_12 = fun Fun_12_loop(Brilliant, Count, CountOnly, Digits, I_7, K, Limit, Next, Pow, S_5) ->
    case (I_7 < length(S_5)) of
        true ->
            try
                J_3 = I_7,
                Fun_11 = fun Fun_11_loop(Brilliant, Count, CountOnly, Digits, I_7, J_3, K, Limit, Next, Pow, S_5) ->
    case (J_3 < length(S_5)) of
        true ->
            try
                Prod = ((case erlang:is_map(S_5) of true -> maps:get(I_7, S_5, nil); _ -> lists:nth(I_7 + 1, S_5) end) * (case erlang:is_map(S_5) of true -> maps:get(J_3, S_5, nil); _ -> lists:nth(J_3 + 1, S_5) end)),
                case (Prod < Limit) of
        true -> case CountOnly of
        true -> Count_2 = (Count + 1),
            Brilliant_3 = Brilliant,
            Count_3 = Count_2;
        _ -> Brilliant_2 = lists:append(Brilliant, [Prod]),
            Brilliant_3 = Brilliant_2,
            Count_3 = Count
    end,
            Brilliant_4 = Brilliant_3,
            Count_4 = Count_3,
            Next_4 = Next;
        _ -> case (Prod < Next) of
        true -> Next_2 = Prod,
            Next_3 = Next_2;
        _ -> Next_3 = Next
    end,
            throw(break),
            Brilliant_4 = Brilliant,
            Count_4 = Count,
            Next_4 = Next_3
    end,
                J_4 = (J_3 + 1),
                Fun_11_loop(Brilliant_4, Count_4, CountOnly, Digits, I_7, J_4, K, Limit, Next_4, Pow, S_5)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10} -> Fun_11_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10);
                break -> {Brilliant, Count, CountOnly, Digits, I_7, J_3, K, Limit, Next, Pow, S_5}
            end;
        _ -> {Brilliant, Count, CountOnly, Digits, I_7, J_3, K, Limit, Next, Pow, S_5}
    end
end,
{Brilliant_4, Count_4, CountOnly, Digits, I_7, J_4, K, Limit, Next_4, Pow, S_5} = Fun_11(Brilliant, Count, CountOnly, Digits, I_7, J_3, K, Limit, Next, Pow, S_5),
                I_8 = (I_7 + 1),
                Fun_12_loop(Brilliant_4, Count_4, CountOnly, Digits, I_8, K, Limit, Next_4, Pow, S_5)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9} -> Fun_12_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9);
                break -> {Brilliant, Count, CountOnly, Digits, I_7, K, Limit, Next, Pow, S_5}
            end;
        _ -> {Brilliant, Count, CountOnly, Digits, I_7, K, Limit, Next, Pow, S_5}
    end
end,
{Brilliant_4, Count_4, CountOnly, Digits, I_8, K, Limit, Next_4, Pow, S_5} = Fun_12(Brilliant, Count, CountOnly, Digits, I_7, K, Limit, Next, Pow, S_5),
                Pow_2 = (Pow * 10),
                K_2 = (K + 1),
                Fun_13_loop(Brilliant_4, Count_4, CountOnly, Digits, K_2, Limit, Next_4, Pow_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7} -> Fun_13_loop(C0, C1, C2, C3, C4, C5, C6, C7);
                break -> {Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow}
            end;
        _ -> {Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow}
    end
end,
{Brilliant_4, Count_4, CountOnly, Digits, K_2, Limit, Next_4, Pow_2} = Fun_13(Brilliant, Count, CountOnly, Digits, K, Limit, Next, Pow),
        case CountOnly of
        true -> throw({return, #{"bc" => Count_4, "next" => Next_4}});
        _ -> ok
    end,
        #{"bc" => Brilliant_4, "next" => Next_4}
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", ["First 100 brilliant numbers:"]),
        R = getbrilliant(2, 10000, false),
        Br = sortints(maps:get("bc", R, nil)),
        Br_2 = lists:sublist(Br, 0 + 1, (100 - 0)),
        I_9 = 0,
        Fun_14 = fun Fun_14_loop(Br_2, I_9, R) ->
    case (I_9 < length(Br_2)) of
        true ->
            io:format("~ts ~p~n", [(mochi_pad_start(lists:flatten(io_lib:format("~p", [(case erlang:is_map(Br_2) of true -> maps:get(I_9, Br_2, nil); _ -> lists:nth(I_9 + 1, Br_2) end)])), 4, " ") ++ " "), false]),
            case (((I_9 + 1) rem 10) == 0) of
        true -> io:format("~ts ~p~n", ["", true]);
        _ -> ok
    end,
            I_10 = (I_9 + 1),
            Fun_14_loop(Br_2, I_10, R);
        _ -> {Br_2, I_9, R}
    end
end,
{Br_2, I_10, R} = Fun_14(Br_2, I_9, R),
        io:format("~ts ~p~n", ["", true]),
        K_3 = 1,
        Fun_15 = fun Fun_15_loop(Br_2, I_10, K_3, R) ->
    case (K_3 =< 13) of
        true ->
            Limit_2 = trunc(math:pow(10, K_3)),
            R2 = getbrilliant(K_3, Limit_2, true),
            Total = maps:get("bc", R2, nil),
            Next_5 = maps:get("next", R2, nil),
            Climit = commatize(Limit_2),
            Ctotal = commatize((Total + 1)),
            Cnext = commatize(Next_5),
            io:format("~ts~n", [((((("First >= " ++ mochi_pad_start(Climit, 18, " ")) ++ " is ") ++ mochi_pad_start(Ctotal, 14, " ")) ++ " in the series: ") ++ mochi_pad_start(Cnext, 18, " "))]),
            K_4 = (K_3 + 1),
            Fun_15_loop(Br_2, I_10, K_4, R);
        _ -> {Br_2, I_10, K_3, R}
    end
end,
{Br_2, I_10, K_4, R} = Fun_15(Br_2, I_10, K_3, R),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    erlang:put('primes', primesupto(3200000)),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
