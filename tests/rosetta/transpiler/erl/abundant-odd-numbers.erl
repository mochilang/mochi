#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, divisors/1, sum/1, sumStr/1, pad2/1, pad5/1, abundantOdd/4, main/0]).

% Generated by Mochi transpiler v0.10.39 (7071f28765) on 2025-07-24 15:23 +0700

divisors(N) ->
    try
        Divs = [1],
        Divs2 = [],
        I = 2,
        Fun = fun Fun_loop(Divs, Divs2, I, N) ->
    case ((I * I) =< N) of
        true ->
            try
                case ((N rem I) == 0) of
        true -> J = (N div I),
            Divs_2 = lists:append(Divs, [I]),
            case (I /= J) of
        true -> Divs2_2 = lists:append(Divs2, [J]),
            Divs2_3 = Divs2_2;
        _ -> Divs2_3 = Divs2
    end,
            Divs_3 = Divs_2,
            Divs2_4 = Divs2_3,
            J_2 = J;
        _ -> Divs_3 = Divs,
            Divs2_4 = Divs2,
            J_2 = nil
    end,
                I_2 = (I + 1),
                Fun_loop(Divs_3, Divs2_4, I_2, N)
            catch
                {continue, C0, C1, C2, C3} -> Fun_loop(C0, C1, C2, C3);
                break -> {Divs, Divs2, I, N}
            end;
        _ -> {Divs, Divs2, I, N}
    end
end,
{Divs_3, Divs2_4, I_2, N} = Fun(Divs, Divs2, I, N),
        J_3 = (length(Divs2_4) - 1),
        Fun_2 = fun Fun_2_loop(Divs_3, Divs2_4, I_2, J_3, N) ->
    case (J_3 >= 0) of
        true ->
            try
                Divs_4 = lists:append(Divs_3, [lists:nth(J_3 + 1, Divs2_4)]),
                J_4 = (J_3 - 1),
                Fun_2_loop(Divs_4, Divs2_4, I_2, J_4, N)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_2_loop(C0, C1, C2, C3, C4);
                break -> {Divs_3, Divs2_4, I_2, J_3, N}
            end;
        _ -> {Divs_3, Divs2_4, I_2, J_3, N}
    end
end,
{Divs_4, Divs2_4, I_2, J_4, N} = Fun_2(Divs_3, Divs2_4, I_2, J_3, N),
        Divs_4
    catch {return, Ret} -> Ret end.

sum(Xs) ->
    try
        Tot = 0,
        Fun_3 = fun Fun_3_loop(List, Tot, Xs) ->
    case List of
        [] -> {Tot, Xs};
        [V|Fun_3_loop_rest] ->
            Tot_2 = (Tot + V),
            Fun_3_loop(Fun_3_loop_rest, Tot_2, Xs)
    end
end,
{Tot_2, Xs} = Fun_3(Xs, Tot, Xs),
        Tot_2
    catch {return, Ret} -> Ret end.

sumStr(Xs_2) ->
    try
        S = "",
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(I_3, S, Xs_2) ->
    case (I_3 < length(Xs_2)) of
        true ->
            try
                S_2 = ((S ++ lists:flatten(io_lib:format("~p", [lists:nth(I_3 + 1, Xs_2)]))) ++ " + "),
                I_4 = (I_3 + 1),
                Fun_4_loop(I_4, S_2, Xs_2)
            catch
                {continue, C0, C1, C2} -> Fun_4_loop(C0, C1, C2);
                break -> {I_3, S, Xs_2}
            end;
        _ -> {I_3, S, Xs_2}
    end
end,
{I_4, S_2, Xs_2} = Fun_4(I_3, S, Xs_2),
        string:substr(S_2, 0 + 1, ((length(S_2) - 3) - 0))
    catch {return, Ret} -> Ret end.

pad2(N_2) ->
    try
        S_3 = lists:flatten(io_lib:format("~p", [N_2])),
        case (length(S_3) < 2) of
        true -> throw({return, (" " ++ S_3)});
        _ -> ok
    end,
        S_3
    catch {return, Ret} -> Ret end.

pad5(N_3) ->
    try
        S_4 = lists:flatten(io_lib:format("~p", [N_3])),
        Fun_5 = fun Fun_5_loop(N_3, S_4) ->
    case (length(S_4) < 5) of
        true ->
            try
                S_5 = (" " ++ S_4),
                Fun_5_loop(N_3, S_5)
            catch
                {continue, C0, C1} -> Fun_5_loop(C0, C1);
                break -> {N_3, S_4}
            end;
        _ -> {N_3, S_4}
    end
end,
{N_3, S_5} = Fun_5(N_3, S_4),
        S_5
    catch {return, Ret} -> Ret end.

abundantOdd(SearchFrom, CountFrom, CountTo, PrintOne) ->
    try
        Count = CountFrom,
        N_4 = SearchFrom,
        Fun_6 = fun Fun_6_loop(Count, CountFrom, CountTo, N_4, PrintOne, SearchFrom) ->
    case (Count < CountTo) of
        true ->
            try
                Divs_5 = divisors(N_4),
                Tot_3 = lists:sum(Divs_5),
                case (Tot_3 > N_4) of
        true -> Count_2 = (Count + 1),
            case (PrintOne andalso (Count_2 < CountTo)) of
        true -> N_5 = (N_4 + 2),
            throw({continue, Count_2, CountFrom, CountTo, N_5, PrintOne, SearchFrom}),
            N_6 = N_5;
        _ -> N_6 = N_4
    end,
            S_6 = sumStr(Divs_5),
            case not PrintOne of
        true -> io:format("~ts~n", [((((((pad2(Count_2) ++ ". ") ++ pad5(N_6)) ++ " < ") ++ S_6) ++ " = ") ++ lists:flatten(io_lib:format("~p", [Tot_3])))]);
        _ -> io:format("~ts~n", [((((lists:flatten(io_lib:format("~p", [N_6])) ++ " < ") ++ S_6) ++ " = ") ++ lists:flatten(io_lib:format("~p", [Tot_3])))])
    end,
            Count_3 = Count_2,
            N_7 = N_6,
            S_7 = S_6;
        _ -> Count_3 = Count,
            N_7 = N_4,
            S_7 = nil
    end,
                N_8 = (N_7 + 2),
                Fun_6_loop(Count_3, CountFrom, CountTo, N_8, PrintOne, SearchFrom)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_6_loop(C0, C1, C2, C3, C4, C5);
                break -> {Count, CountFrom, CountTo, N_4, PrintOne, SearchFrom}
            end;
        _ -> {Count, CountFrom, CountTo, N_4, PrintOne, SearchFrom}
    end
end,
{Count_3, CountFrom, CountTo, N_8, PrintOne, SearchFrom} = Fun_6(Count, CountFrom, CountTo, N_4, PrintOne, SearchFrom),
        N_8
    catch {return, Ret} -> Ret end.

main() ->
    try
        Max = 25,
        io:format("~ts~n", [(("The first " ++ lists:flatten(io_lib:format("~p", [25]))) ++ " abundant odd numbers are:")]),
        N_9 = abundantOdd(1, 0, 25, false),
        io:format("~ts~n", ["\nThe one thousandth abundant odd number is:"]),
        abundantOdd(N_9, 25, 1000, true),
        io:format("~ts~n", ["\nThe first abundant odd number above one billion is:"]),
        abundantOdd(1000000001, 0, 1, true),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    main().
