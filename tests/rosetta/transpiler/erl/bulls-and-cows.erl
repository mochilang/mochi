#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, indexof/2, shuffle/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (a213474220) on 2025-08-03 10:22 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] when is_list(C) -> hd(C);
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.

indexof(S, Ch) ->
    try
        I = 0,
        Fun = fun Fun_loop(Ch, I, S) ->
    case (I < length(S)) of
        true ->
            case (string:substr(S, I + 1, ((I + 1) - I)) == Ch) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, I_2, S);
        _ -> {Ch, I, S}
    end
end,
{Ch, I_2, S} = Fun(Ch, I, S),
        -1
    catch {return, Ret} -> Ret end.

shuffle(Xs) ->
    try
        Arr = Xs,
        I_3 = (length(Arr) - 1),
        Fun_2 = fun Fun_2_loop(Arr, I_3, Xs) ->
    case (I_3 > 0) of
        true ->
            J = (mochi_now() rem (I_3 + 1)),
            Tmp = (case erlang:is_map(Arr) of true -> maps:get(I_3, Arr, nil); _ -> lists:nth(I_3 + 1, Arr) end),
            Arr_2 = lists:sublist(Arr, I_3) ++ [(case erlang:is_map(Arr) of true -> maps:get(J, Arr, nil); _ -> lists:nth(J + 1, Arr) end)] ++ lists:nthtail(I_3 + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, J) ++ [Tmp] ++ lists:nthtail(J + 1, Arr_2),
            I_4 = (I_3 - 1),
            Fun_2_loop(Arr_3, I_4, Xs);
        _ -> {Arr, I_3, Xs}
    end
end,
{Arr_3, I_4, Xs} = Fun_2(Arr, I_3, Xs),
        Arr_3
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", ["Cows and Bulls"]),
        io:format("~ts~n", ["Guess four digit number of unique digits in the range 1 to 9."]),
        io:format("~ts~n", ["A correct digit but not in the correct place is a cow."]),
        io:format("~ts~n", ["A correct digit in the correct place is a bull."]),
        Digits = ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
        Digits_2 = shuffle(Digits),
        Pat = ((((case erlang:is_map(Digits_2) of true -> maps:get(0, Digits_2, nil); _ -> lists:nth(0 + 1, Digits_2) end) ++ (case erlang:is_map(Digits_2) of true -> maps:get(1, Digits_2, nil); _ -> lists:nth(1 + 1, Digits_2) end)) ++ (case erlang:is_map(Digits_2) of true -> maps:get(2, Digits_2, nil); _ -> lists:nth(2 + 1, Digits_2) end)) ++ (case erlang:is_map(Digits_2) of true -> maps:get(3, Digits_2, nil); _ -> lists:nth(3 + 1, Digits_2) end)),
        Valid = "123456789",
        Fun_4 = fun Fun_4_loop(Digits_2, Pat, Valid) ->
    case true of
        true ->
            try
                io:format("~ts~n", ["Guess: "]),
                Guess = ((fun() -> case io:get_line("") of eof -> "q"; L -> string:trim(L) end end)()),
                case (length(Guess) /= 4) of
        true -> io:format("~ts~n", ["Please guess a four digit number."]),
            throw({continue, Digits_2, Pat, Valid});
        _ -> ok
    end,
                Cows = 0,
                Bulls = 0,
                Seen = "",
                I_5 = 0,
                Malformed = false,
                Fun_3 = fun Fun_3_loop(Bulls, Cows, Digits_2, Guess, I_5, Malformed, Pat, Seen, Valid) ->
    case (I_5 < 4) of
        true ->
            try
                Cg = string:substr(Guess, I_5 + 1, ((I_5 + 1) - I_5)),
                case (mochi_index_of(Seen, Cg) /= -1) of
        true -> io:format("~ts~n", [("Repeated digit: " ++ Cg)]),
            Malformed_2 = true,
            throw(break),
            Malformed_3 = Malformed_2;
        _ -> Malformed_3 = Malformed
    end,
                Seen_2 = (Seen ++ Cg),
                Pos = mochi_index_of(Pat, Cg),
                case (Pos == -1) of
        true -> case (mochi_index_of(Valid, Cg) == -1) of
        true -> io:format("~ts~n", [("Invalid digit: " ++ Cg)]),
            Malformed_4 = true,
            throw(break),
            Malformed_5 = Malformed_4;
        _ -> Malformed_5 = Malformed_3
    end,
            Bulls_4 = Bulls,
            Cows_4 = Cows,
            Malformed_6 = Malformed_5;
        _ -> case (Pos == I_5) of
        true -> Bulls_2 = (Bulls + 1),
            Bulls_3 = Bulls_2,
            Cows_3 = Cows;
        _ -> Cows_2 = (Cows + 1),
            Bulls_3 = Bulls,
            Cows_3 = Cows_2
    end,
            Bulls_4 = Bulls_3,
            Cows_4 = Cows_3,
            Malformed_6 = Malformed_3
    end,
                I_6 = (I_5 + 1),
                Fun_3_loop(Bulls_4, Cows_4, Digits_2, Guess, I_6, Malformed_6, Pat, Seen_2, Valid)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_3_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {Bulls, Cows, Digits_2, Guess, I_5, Malformed, Pat, Seen, Valid}
            end;
        _ -> {Bulls, Cows, Digits_2, Guess, I_5, Malformed, Pat, Seen, Valid}
    end
end,
{Bulls_4, Cows_4, Digits_2, Guess, I_6, Malformed_6, Pat, Seen_2, Valid} = Fun_3(Bulls, Cows, Digits_2, Guess, I_5, Malformed, Pat, Seen, Valid),
                case (Malformed_6 /= nil) of
        true -> throw({continue, Digits_2, Pat, Valid});
        _ -> ok
    end,
                io:format("~ts~n", [((("Cows: " ++ lists:flatten(io_lib:format("~p", [Cows_4]))) ++ ", bulls: ") ++ lists:flatten(io_lib:format("~p", [Bulls_4])))]),
                case (Bulls_4 == 4) of
        true -> io:format("~ts~n", ["You got it."]),
            throw(break);
        _ -> ok
    end,
                Fun_4_loop(Digits_2, Pat, Valid)
            catch
                {continue, C0, C1, C2} -> Fun_4_loop(C0, C1, C2);
                break -> {Digits_2, Pat, Valid}
            end;
        _ -> {Digits_2, Pat, Valid}
    end
end,
{Digits_2, Pat, Valid} = Fun_4(Digits_2, Pat, Valid),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
