#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, sieve/1, primesfrom/2, pad3/1, commatize/1, primecount/3, arithmeticnumbers/2, main/0]).

% Generated by Mochi transpiler v0.10.41 (cac7e4e2bd) on 2025-07-26 17:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

sieve(Limit) ->
    try
        Spf = [],
        I = 0,
        Fun = fun Fun_loop(I, Limit, Spf) ->
    case (I =< Limit) of
        true ->
            Spf_2 = lists:append(Spf, [0]),
            I_2 = (I + 1),
            Fun_loop(I_2, Limit, Spf_2);
        _ -> {I, Limit, Spf}
    end
end,
{I_2, Limit, Spf_2} = Fun(I, Limit, Spf),
        I_3 = 2,
        Fun_5 = fun Fun_5_loop(I_3, Limit, Spf_2) ->
    case (I_3 =< Limit) of
        true ->
            case (lists:nth(I_3 + 1, Spf_2) == 0) of
        true -> Spf_3 = lists:sublist(Spf_2, I_3) ++ [I_3] ++ lists:nthtail(I_3 + 1, Spf_2),
            case ((I_3 * I_3) =< Limit) of
        true -> J = (I_3 * I_3),
            Fun_2 = fun Fun_2_loop(I_3, J, Limit, Spf_3) ->
    case (J =< Limit) of
        true ->
            case (lists:nth(J + 1, Spf_3) == 0) of
        true -> Spf_4 = lists:sublist(Spf_3, J) ++ [I_3] ++ lists:nthtail(J + 1, Spf_3),
            Spf_5 = Spf_4;
        _ -> Spf_5 = Spf_3
    end,
            J_2 = (J + I_3),
            Fun_2_loop(I_3, J_2, Limit, Spf_5);
        _ -> {I_3, J, Limit, Spf_3}
    end
end,
{I_3, J_2, Limit, Spf_5} = Fun_2(I_3, J, Limit, Spf_3),
            Fun_3 = Fun_2,
            J_3 = J_2,
            Spf_6 = Spf_5;
        _ -> Fun_3 = Fun,
            J_3 = nil,
            Spf_6 = Spf_3
    end,
            Fun_4 = Fun_3,
            J_4 = J_3,
            Spf_7 = Spf_6;
        _ -> Fun_4 = Fun,
            J_4 = nil,
            Spf_7 = Spf_2
    end,
            I_4 = (I_3 + 1),
            Fun_5_loop(I_4, Limit, Spf_7);
        _ -> {I_3, Limit, Spf_2}
    end
end,
{I_4, Limit, Spf_7} = Fun_5(I_3, Limit, Spf_2),
        Spf_7
    catch {return, Ret} -> Ret end.

primesfrom(Spf_8, Limit_2) ->
    try
        Primes = [],
        I_5 = 3,
        Fun_6 = fun Fun_6_loop(I_5, Limit_2, Primes, Spf_8) ->
    case (I_5 =< Limit_2) of
        true ->
            case (lists:nth(I_5 + 1, Spf_8) == I_5) of
        true -> Primes_2 = lists:append(Primes, [I_5]),
            Primes_3 = Primes_2;
        _ -> Primes_3 = Primes
    end,
            I_6 = (I_5 + 1),
            Fun_6_loop(I_6, Limit_2, Primes_3, Spf_8);
        _ -> {I_5, Limit_2, Primes, Spf_8}
    end
end,
{I_6, Limit_2, Primes_3, Spf_8} = Fun_6(I_5, Limit_2, Primes, Spf_8),
        Primes_3
    catch {return, Ret} -> Ret end.

pad3(N) ->
    try
        S = lists:flatten(io_lib:format("~p", [N])),
        Fun_7 = fun Fun_7_loop(N, S) ->
    case (length(S) < 3) of
        true ->
            S_2 = (" " ++ S),
            Fun_7_loop(N, S_2);
        _ -> {N, S}
    end
end,
{N, S_2} = Fun_7(N, S),
        S_2
    catch {return, Ret} -> Ret end.

commatize(N_2) ->
    try
        S_3 = lists:flatten(io_lib:format("~p", [N_2])),
        Out = "",
        I_7 = (length(S_3) - 1),
        C = 0,
        Fun_8 = fun Fun_8_loop(C, I_7, N_2, Out, S_3) ->
    case (I_7 >= 0) of
        true ->
            Out_2 = (string:substr(S_3, I_7 + 1, ((I_7 + 1) - I_7)) ++ Out),
            C_2 = (C + 1),
            case (((C_2 rem 3) == 0) andalso (I_7 > 0)) of
        true -> Out_3 = ("," ++ Out_2),
            Out_4 = Out_3;
        _ -> Out_4 = Out_2
    end,
            I_8 = (I_7 - 1),
            Fun_8_loop(C_2, I_8, N_2, Out_4, S_3);
        _ -> {C, I_7, N_2, Out, S_3}
    end
end,
{C_2, I_8, N_2, Out_4, S_3} = Fun_8(C, I_7, N_2, Out, S_3),
        Out_4
    catch {return, Ret} -> Ret end.

primecount(Primes_4, Last, Spf_9) ->
    try
        Lo = 0,
        Hi = length(Primes_4),
        Fun_9 = fun Fun_9_loop(Hi, Last, Lo, Primes_4, Spf_9) ->
    case (Lo < Hi) of
        true ->
            Mid = mochi_to_int(((Lo + Hi) div 2)),
            case (lists:nth(Mid + 1, Primes_4) < Last) of
        true -> Lo_2 = (Mid + 1),
            Hi_3 = Hi,
            Lo_3 = Lo_2;
        _ -> Hi_2 = Mid,
            Hi_3 = Hi_2,
            Lo_3 = Lo
    end,
            Fun_9_loop(Hi_3, Last, Lo_3, Primes_4, Spf_9);
        _ -> {Hi, Last, Lo, Primes_4, Spf_9}
    end
end,
{Hi_3, Last, Lo_3, Primes_4, Spf_9} = Fun_9(Hi, Last, Lo, Primes_4, Spf_9),
        Count = (Lo_3 + 1),
        case (lists:nth(Last + 1, Spf_9) /= Last) of
        true -> Count_2 = (Count - 1),
            Count_3 = Count_2;
        _ -> Count_3 = Count
    end,
        Count_3
    catch {return, Ret} -> Ret end.

arithmeticnumbers(Limit_3, Spf_10) ->
    try
        Arr = [1],
        N_3 = 3,
        Fun_13 = fun Fun_13_loop(Arr, Limit_3, N_3, Spf_10) ->
    case (length(Arr) < Limit_3) of
        true ->
            case (lists:nth(N_3 + 1, Spf_10) == N_3) of
        true -> Arr_2 = lists:append(Arr, [N_3]),
            Arr_5 = Arr_2,
            Fun_12 = nil,
            Sigma_3 = nil,
            Tau_3 = nil,
            X_3 = nil;
        _ -> X = N_3,
            Sigma = 1,
            Tau = 1,
            Fun_11 = fun Fun_11_loop(Arr, Limit_3, N_3, Sigma, Spf_10, Tau, X) ->
    case (X > 1) of
        true ->
            P = lists:nth(X + 1, Spf_10),
            case (P == 0) of
        true -> P_2 = X,
            P_3 = P_2;
        _ -> P_3 = P
    end,
            Cnt = 0,
            Power = P_3,
            Sum = 1,
            Fun_10 = fun Fun_10_loop(Arr, Cnt, Limit_3, N_3, P_3, Power, Sigma, Spf_10, Sum, Tau, X) ->
    case ((X rem P_3) == 0) of
        true ->
            X_2 = (X div P_3),
            Cnt_2 = (Cnt + 1),
            Sum_2 = (Sum + Power),
            Power_2 = (Power * P_3),
            Fun_10_loop(Arr, Cnt_2, Limit_3, N_3, P_3, Power_2, Sigma, Spf_10, Sum_2, Tau, X_2);
        _ -> {Arr, Cnt, Limit_3, N_3, P_3, Power, Sigma, Spf_10, Sum, Tau, X}
    end
end,
{Arr, Cnt_2, Limit_3, N_3, P_3, Power_2, Sigma, Spf_10, Sum_2, Tau, X_2} = Fun_10(Arr, Cnt, Limit_3, N_3, P_3, Power, Sigma, Spf_10, Sum, Tau, X),
            Sigma_2 = (Sigma * Sum_2),
            Tau_2 = (Tau * (Cnt_2 + 1)),
            Fun_11_loop(Arr, Limit_3, N_3, Sigma_2, Spf_10, Tau_2, X_2);
        _ -> {Arr, Limit_3, N_3, Sigma, Spf_10, Tau, X}
    end
end,
{Arr, Limit_3, N_3, Sigma_2, Spf_10, Tau_2, X_2} = Fun_11(Arr, Limit_3, N_3, Sigma, Spf_10, Tau, X),
            case ((Sigma_2 rem Tau_2) == 0) of
        true -> Arr_3 = lists:append(Arr, [N_3]),
            Arr_4 = Arr_3;
        _ -> Arr_4 = Arr
    end,
            Arr_5 = Arr_4,
            Fun_12 = Fun_11,
            Sigma_3 = Sigma_2,
            Tau_3 = Tau_2,
            X_3 = X_2
    end,
            N_4 = (N_3 + 1),
            Fun_13_loop(Arr_5, Limit_3, N_4, Spf_10);
        _ -> {Arr, Limit_3, N_3, Spf_10}
    end
end,
{Arr_5, Limit_3, N_4, Spf_10} = Fun_13(Arr, Limit_3, N_3, Spf_10),
        Arr_5
    catch {return, Ret} -> Ret end.

main() ->
    try
        Limit_4 = 1228663,
        Spf_11 = sieve(1228663),
        Primes_5 = primesfrom(Spf_11, 1228663),
        Arr_6 = arithmeticnumbers(1000000, Spf_11),
        io:format("~ts~n", ["The first 100 arithmetic numbers are:"]),
        I_9 = 0,
        Fun_15 = fun Fun_15_loop(Arr_6, I_9, Limit_4, Primes_5, Spf_11) ->
    case (I_9 < 100) of
        true ->
            Line = "",
            J_5 = 0,
            Fun_14 = fun Fun_14_loop(Arr_6, I_9, J_5, Limit_4, Line, Primes_5, Spf_11) ->
    case (J_5 < 10) of
        true ->
            Line_2 = (Line ++ pad3(lists:nth((I_9 + J_5) + 1, Arr_6))),
            case (J_5 < 9) of
        true -> Line_3 = (Line_2 ++ " "),
            Line_4 = Line_3;
        _ -> Line_4 = Line_2
    end,
            J_6 = (J_5 + 1),
            Fun_14_loop(Arr_6, I_9, J_6, Limit_4, Line_4, Primes_5, Spf_11);
        _ -> {Arr_6, I_9, J_5, Limit_4, Line, Primes_5, Spf_11}
    end
end,
{Arr_6, I_9, J_6, Limit_4, Line_4, Primes_5, Spf_11} = Fun_14(Arr_6, I_9, J_5, Limit_4, Line, Primes_5, Spf_11),
            io:format("~ts~n", [Line_4]),
            I_10 = (I_9 + 10),
            Fun_15_loop(Arr_6, I_10, Limit_4, Primes_5, Spf_11);
        _ -> {Arr_6, I_9, Limit_4, Primes_5, Spf_11}
    end
end,
{Arr_6, I_10, Limit_4, Primes_5, Spf_11} = Fun_15(Arr_6, I_9, Limit_4, Primes_5, Spf_11),
        Fun_16 = fun Fun_16_loop(List, Arr_6, I_10, Limit_4, Primes_5, Spf_11) ->
    case List of
        [] -> {Arr_6, I_10, Limit_4, Primes_5, Spf_11};
        [X_4|X_4_rest] ->
            Last_2 = lists:nth((X_4 - 1) + 1, Arr_6),
            Lastc = commatize(Last_2),
            io:format("~ts~n", [((("\nThe " ++ commatize(X_4)) ++ "th arithmetic number is: ") ++ Lastc)]),
            Pc = primecount(Primes_5, Last_2, Spf_11),
            Comp = ((X_4 - Pc) - 1),
            io:format("~ts~n", [(((("The count of such numbers <= " ++ Lastc) ++ " which are composite is ") ++ commatize(Comp)) ++ ".")]),
            Fun_16_loop(X_4_rest, Arr_6, I_10, Limit_4, Primes_5, Spf_11)
    end
end,
{Arr_6, I_10, Limit_4, Primes_5, Spf_11} = Fun_16([1000, 10000, 100000, 1000000], Arr_6, I_10, Limit_4, Primes_5, Spf_11),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = erlang:abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
