#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, indexof/2, fields/1, makepatterns/0, main/0]).

% Generated by Mochi transpiler v0.10.41 (cac7e4e2bd) on 2025-07-26 17:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.

indexof(S, Ch) ->
    try
        I = 0,
        Fun = fun Fun_loop(Ch, I, S) ->
    case (I < length(S)) of
        true ->
            case (string:substr(S, I + 1, ((I + 1) - I)) == Ch) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, I_2, S);
        _ -> {Ch, I, S}
    end
end,
{Ch, I_2, S} = Fun(Ch, I, S),
        -1
    catch {return, Ret} -> Ret end.

fields(S_2) ->
    try
        Words = [],
        Cur = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Cur, I_3, S_2, Words) ->
    case (I_3 < length(S_2)) of
        true ->
            Ch_2 = string:substr(S_2, I_3 + 1, ((I_3 + 1) - I_3)),
            case (((Ch_2 == " ") orelse (Ch_2 == "\t")) orelse (Ch_2 == "\n")) of
        true -> case (length(Cur) > 0) of
        true -> Words_2 = lists:append(Words, [Cur]),
            Cur_2 = "",
            Cur_3 = Cur_2,
            Words_3 = Words_2;
        _ -> Cur_3 = Cur,
            Words_3 = Words
    end,
            Cur_5 = Cur_3,
            Words_4 = Words_3;
        _ -> Cur_4 = (Cur ++ Ch_2),
            Cur_5 = Cur_4,
            Words_4 = Words
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Cur_5, I_4, S_2, Words_4);
        _ -> {Cur, I_3, S_2, Words}
    end
end,
{Cur_5, I_4, S_2, Words_4} = Fun_2(Cur, I_3, S_2, Words),
        case (length(Cur_5) > 0) of
        true -> Words_5 = lists:append(Words_4, [Cur_5]),
            Words_6 = Words_5;
        _ -> Words_6 = Words_4
    end,
        Words_6
    catch {return, Ret} -> Ret end.

makepatterns() ->
    try
        Digits = ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
        Pats = [],
        I_5 = 0,
        Fun_8 = fun Fun_8_loop(Digits, I_5, Pats) ->
    case (I_5 < length(Digits)) of
        true ->
            J = 0,
            Fun_7 = fun Fun_7_loop(Digits, I_5, J, Pats) ->
    case (J < length(Digits)) of
        true ->
            case (J /= I_5) of
        true -> K = 0,
            Fun_5 = fun Fun_5_loop(Digits, I_5, J, K, Pats) ->
    case (K < length(Digits)) of
        true ->
            case ((K /= I_5) andalso (K /= J)) of
        true -> L = 0,
            Fun_3 = fun Fun_3_loop(Digits, I_5, J, K, L, Pats) ->
    case (L < length(Digits)) of
        true ->
            case (((L /= I_5) andalso (L /= J)) andalso (L /= K)) of
        true -> Pats_2 = lists:append(Pats, [(((lists:nth(I_5 + 1, Digits) + lists:nth(J + 1, Digits)) + lists:nth(K + 1, Digits)) + lists:nth(L + 1, Digits))]),
            Pats_3 = Pats_2;
        _ -> Pats_3 = Pats
    end,
            L_2 = (L + 1),
            Fun_3_loop(Digits, I_5, J, K, L_2, Pats_3);
        _ -> {Digits, I_5, J, K, L, Pats}
    end
end,
{Digits, I_5, J, K, L_2, Pats_3} = Fun_3(Digits, I_5, J, K, L, Pats),
            Fun_4 = Fun_3,
            L_3 = L_2,
            Pats_4 = Pats_3;
        _ -> Fun_4 = nil,
            L_3 = nil,
            Pats_4 = Pats
    end,
            K_2 = (K + 1),
            Fun_5_loop(Digits, I_5, J, K_2, Pats_4);
        _ -> {Digits, I_5, J, K, Pats}
    end
end,
{Digits, I_5, J, K_2, Pats_4} = Fun_5(Digits, I_5, J, K, Pats),
            Fun_6 = Fun_5,
            K_3 = K_2,
            Pats_5 = Pats_4;
        _ -> Fun_6 = nil,
            K_3 = nil,
            Pats_5 = Pats
    end,
            J_2 = (J + 1),
            Fun_7_loop(Digits, I_5, J_2, Pats_5);
        _ -> {Digits, I_5, J, Pats}
    end
end,
{Digits, I_5, J_2, Pats_5} = Fun_7(Digits, I_5, J, Pats),
            I_6 = (I_5 + 1),
            Fun_8_loop(Digits, I_6, Pats_5);
        _ -> {Digits, I_5, Pats}
    end
end,
{Digits, I_6, Pats_5} = Fun_8(Digits, I_5, Pats),
        Pats_5
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", [((((("Cows and bulls/player\n" ++ "You think of four digit number of unique digits in the range 1 to 9.\n") ++ "I guess.  You score my guess:\n") ++ "    A correct digit but not in the correct place is a cow.\n") ++ "    A correct digit in the correct place is a bull.\n") ++ "You give my score as two numbers separated with a space.")]),
        Patterns = makepatterns(),
        Fun_12 = fun Fun_12_loop(Patterns) ->
    case true of
        true ->
            try
                case (length(Patterns) == 0) of
        true -> io:format("~ts~n", ["Oops, check scoring."]),
            throw({return, nil});
        _ -> ok
    end,
                Guess = lists:nth(0 + 1, Patterns),
                Patterns_2 = lists:sublist(Patterns, 1 + 1, length(Patterns) - 1),
                Cows = 0,
                Bulls = 0,
                Fun_9 = fun Fun_9_loop(Bulls, Cows, Guess, Patterns_2) ->
    case true of
        true ->
            try
                io:format("~ts~n", [(("My guess: " ++ Guess) ++ ".  Score? (c b) ")]),
                Line = ((fun() -> case io:get_line("") of eof -> "q"; L -> string:trim(L) end end)()),
                Toks = fields(Line),
                case (length(Toks) == 2) of
        true -> C = mochi_to_int(lists:nth(0 + 1, Toks)),
            B = mochi_to_int(lists:nth(1 + 1, Toks)),
            case (((((C >= 0) andalso (C =< 4)) andalso (B >= 0)) andalso (B =< 4)) andalso ((C + B) =< 4)) of
        true -> Cows_2 = C,
            Bulls_2 = B,
            throw(break),
            Bulls_3 = Bulls_2,
            Cows_3 = Cows_2;
        _ -> Bulls_3 = Bulls,
            Cows_3 = Cows
    end,
            B_2 = B,
            Bulls_4 = Bulls_3,
            C_2 = C,
            Cows_4 = Cows_3;
        _ -> B_2 = nil,
            Bulls_4 = Bulls,
            C_2 = nil,
            Cows_4 = Cows
    end,
                io:format("~ts~n", ["Score guess as two numbers: cows bulls"]),
                Fun_9_loop(Bulls_4, Cows_4, Guess, Patterns_2)
            catch
                {continue, C0, C1, C2, C3} -> Fun_9_loop(C0, C1, C2, C3);
                break -> {Bulls, Cows, Guess, Patterns_2}
            end;
        _ -> {Bulls, Cows, Guess, Patterns_2}
    end
end,
{Bulls_4, Cows_4, Guess, Patterns_2} = Fun_9(Bulls, Cows, Guess, Patterns_2),
                case (Bulls_4 == 4) of
        true -> io:format("~ts~n", ["I did it. :)"]),
            throw({return, nil});
        _ -> ok
    end,
                Next = [],
                Idx = 0,
                Fun_11 = fun Fun_11_loop(Bulls_4, Cows_4, Guess, Idx, Next, Patterns_2) ->
    case (Idx < length(Patterns_2)) of
        true ->
            Pat = lists:nth(Idx + 1, Patterns_2),
            C_3 = 0,
            B_3 = 0,
            I_7 = 0,
            Fun_10 = fun Fun_10_loop(B_3, Bulls_4, C_3, Cows_4, Guess, I_7, Idx, Next, Pat, Patterns_2) ->
    case (I_7 < 4) of
        true ->
            Cg = string:substr(Guess, I_7 + 1, ((I_7 + 1) - I_7)),
            Cp = string:substr(Pat, I_7 + 1, ((I_7 + 1) - I_7)),
            case (Cg == Cp) of
        true -> B_4 = (B_3 + 1),
            B_5 = B_4,
            C_6 = C_3;
        _ -> case (mochi_index_of(Pat, Cg) >= 0) of
        true -> C_4 = (C_3 + 1),
            C_5 = C_4;
        _ -> C_5 = C_3
    end,
            B_5 = B_3,
            C_6 = C_5
    end,
            I_8 = (I_7 + 1),
            Fun_10_loop(B_5, Bulls_4, C_6, Cows_4, Guess, I_8, Idx, Next, Pat, Patterns_2);
        _ -> {B_3, Bulls_4, C_3, Cows_4, Guess, I_7, Idx, Next, Pat, Patterns_2}
    end
end,
{B_5, Bulls_4, C_6, Cows_4, Guess, I_8, Idx, Next, Pat, Patterns_2} = Fun_10(B_3, Bulls_4, C_3, Cows_4, Guess, I_7, Idx, Next, Pat, Patterns_2),
            case ((C_6 == Cows_4) andalso (B_5 == Bulls_4)) of
        true -> Next_2 = lists:append(Next, [Pat]),
            Next_3 = Next_2;
        _ -> Next_3 = Next
    end,
            Idx_2 = (Idx + 1),
            Fun_11_loop(Bulls_4, Cows_4, Guess, Idx_2, Next_3, Patterns_2);
        _ -> {Bulls_4, Cows_4, Guess, Idx, Next, Patterns_2}
    end
end,
{Bulls_4, Cows_4, Guess, Idx_2, Next_3, Patterns_2} = Fun_11(Bulls_4, Cows_4, Guess, Idx, Next, Patterns_2),
                Patterns_3 = Next_3,
                Fun_12_loop(Patterns_3)
            catch
                {continue, C0} -> Fun_12_loop(C0);
                break -> {Patterns}
            end;
        _ -> {Patterns}
    end
end,
{Patterns_3} = Fun_12(Patterns),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = erlang:abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
