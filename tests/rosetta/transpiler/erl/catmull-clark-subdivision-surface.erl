#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, indexof/2, fmt4/1, fmt2/1, sumpoint/2, mulpoint/2, divpoint/2, centerpoint/2, getfacepoints/2, sortedges/1, getedgesfaces/2, getedgepoints/3, getavgfacepoints/3, getavgmidedges/2, getpointsfaces/2, getnewpoints/4, key/2, cmcsubdiv/2, formatpoint/1, formatface/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (b43d15e5bc) on 2025-08-03 11:14 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] when is_list(C) -> hd(C);
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

indexof(S, Ch) ->
    try
        I = 0,
        Fun = fun Fun_loop(Ch, I, S) ->
    case (I < length(S)) of
        true ->
            case (string:substr(S, I + 1, ((I + 1) - I)) == Ch) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, I_2, S);
        _ -> {Ch, I, S}
    end
end,
{Ch, I_2, S} = Fun(Ch, I, S),
        -1
    catch {return, Ret} -> Ret end.

fmt4(X) ->
    try
        Y = mochi_safe_mul(X, 10000),
        case (Y >= 0) of
        true -> Y_2 = (Y + 0.5),
            Y_4 = Y_2;
        _ -> Y_3 = (Y - 0.5),
            Y_4 = Y_3
    end,
        Y_5 = mochi_safe_div(float(mochi_to_int(Y_4)), 10000),
        S_2 = lists:flatten(io_lib:format("~p", [Y_5])),
        Dot = mochi_index_of(S_2, "."),
        case (Dot == (0 - 1)) of
        true -> S_3 = (S_2 ++ ".0000"),
            Decs_4 = nil,
            Fun_4 = nil,
            S_7 = S_3;
        _ -> Decs = ((length(S_2) - Dot) - 1),
            case (Decs > 4) of
        true -> S_4 = string:substr(S_2, 0 + 1, ((Dot + 5) - 0)),
            Decs_3 = Decs,
            Fun_3 = nil,
            S_6 = S_4;
        _ -> Fun_2 = fun Fun_2_loop(Decs, Dot, S_2, X, Y_5) ->
    case (Decs < 4) of
        true ->
            S_5 = (S_2 ++ "0"),
            Decs_2 = (Decs + 1),
            Fun_2_loop(Decs_2, Dot, S_5, X, Y_5);
        _ -> {Decs, Dot, S_2, X, Y_5}
    end
end,
{Decs_2, Dot, S_5, X, Y_5} = Fun_2(Decs, Dot, S_2, X, Y_5),
            Decs_3 = Decs_2,
            Fun_3 = Fun_2,
            S_6 = S_5
    end,
            Decs_4 = Decs_3,
            Fun_4 = Fun_3,
            S_7 = S_6
    end,
        case (X >= 0) of
        true -> S_8 = (" " ++ S_7),
            S_9 = S_8;
        _ -> S_9 = S_7
    end,
        S_9
    catch {return, Ret} -> Ret end.

fmt2(N) ->
    try
        S_10 = lists:flatten(io_lib:format("~p", [N])),
        case (length(S_10) < 2) of
        true -> throw({return, (" " ++ S_10)});
        _ -> ok
    end,
        S_10
    catch {return, Ret} -> Ret end.

sumpoint(P1, P2) ->
    try
        #{"x" => (maps:get("x", P1, nil) + maps:get("x", P2, nil)), "y" => (maps:get("y", P1, nil) + maps:get("y", P2, nil)), "z" => (maps:get("z", P1, nil) + maps:get("z", P2, nil))}
    catch {return, Ret} -> Ret end.

mulpoint(P, M) ->
    try
        #{"x" => mochi_safe_mul(maps:get("x", P, nil), M), "y" => mochi_safe_mul(maps:get("y", P, nil), M), "z" => mochi_safe_mul(maps:get("z", P, nil), M)}
    catch {return, Ret} -> Ret end.

divpoint(P_2, D) ->
    try
        mulpoint(P_2, mochi_safe_div(1, D))
    catch {return, Ret} -> Ret end.

centerpoint(P1_2, P2_2) ->
    try
        divpoint(sumpoint(P1_2, P2_2), 2)
    catch {return, Ret} -> Ret end.

getfacepoints(Points, Faces) ->
    try
        FacePoints = [],
        I_3 = 0,
        Fun_6 = fun Fun_6_loop(FacePoints, Faces, I_3, Points) ->
    case (I_3 < length(Faces)) of
        true ->
            Face = (case erlang:is_map(Faces) of true -> maps:get(I_3, Faces, nil); _ -> lists:nth(I_3 + 1, Faces) end),
            Fp = #{"x" => 0, "y" => 0, "z" => 0},
            Fun_5 = fun Fun_5_loop(List, Face, FacePoints, Faces, Fp, I_3, Points) ->
    case List of
        [] -> {Face, FacePoints, Faces, Fp, I_3, Points};
        [Idx|Idx_rest] ->
            Fp_2 = sumpoint(Fp, (case erlang:is_map(Points) of true -> maps:get(Idx, Points, nil); _ -> lists:nth(Idx + 1, Points) end)),
            Fun_5_loop(Idx_rest, Face, FacePoints, Faces, Fp_2, I_3, Points)
    end
end,
{Face, FacePoints, Faces, Fp_2, I_3, Points} = Fun_5(Face, Face, FacePoints, Faces, Fp, I_3, Points),
            Fp_3 = divpoint(Fp_2, float(length(Face))),
            FacePoints_2 = lists:append(FacePoints, [Fp_3]),
            I_4 = (I_3 + 1),
            Fun_6_loop(FacePoints_2, Faces, I_4, Points);
        _ -> {FacePoints, Faces, I_3, Points}
    end
end,
{FacePoints_2, Faces, I_4, Points} = Fun_6(FacePoints, Faces, I_3, Points),
        FacePoints_2
    catch {return, Ret} -> Ret end.

sortedges(Edges) ->
    try
        Res = [],
        Tmp = Edges,
        Fun_9 = fun Fun_9_loop(Edges, Res, Tmp) ->
    case (length(Tmp) > 0) of
        true ->
            Min = (case erlang:is_map(Tmp) of true -> maps:get(0, Tmp, nil); _ -> lists:nth(0 + 1, Tmp) end),
            Idx_2 = 0,
            J = 1,
            Fun_7 = fun Fun_7_loop(Edges, Idx_2, J, Min, Res, Tmp) ->
    case (J < length(Tmp)) of
        true ->
            E = (case erlang:is_map(Tmp) of true -> maps:get(J, Tmp, nil); _ -> lists:nth(J + 1, Tmp) end),
            case (((case erlang:is_map(E) of true -> maps:get(0, E, nil); _ -> lists:nth(0 + 1, E) end) < (case erlang:is_map(Min) of true -> maps:get(0, Min, nil); _ -> lists:nth(0 + 1, Min) end)) orelse (((case erlang:is_map(E) of true -> maps:get(0, E, nil); _ -> lists:nth(0 + 1, E) end) == (case erlang:is_map(Min) of true -> maps:get(0, Min, nil); _ -> lists:nth(0 + 1, Min) end)) andalso (((case erlang:is_map(E) of true -> maps:get(1, E, nil); _ -> lists:nth(1 + 1, E) end) < (case erlang:is_map(Min) of true -> maps:get(1, Min, nil); _ -> lists:nth(1 + 1, Min) end)) orelse (((case erlang:is_map(E) of true -> maps:get(1, E, nil); _ -> lists:nth(1 + 1, E) end) == (case erlang:is_map(Min) of true -> maps:get(1, Min, nil); _ -> lists:nth(1 + 1, Min) end)) andalso ((case erlang:is_map(E) of true -> maps:get(2, E, nil); _ -> lists:nth(2 + 1, E) end) < (case erlang:is_map(Min) of true -> maps:get(2, Min, nil); _ -> lists:nth(2 + 1, Min) end)))))) of
        true -> Min_2 = E,
            Idx_3 = J,
            Idx_4 = Idx_3,
            Min_3 = Min_2;
        _ -> Idx_4 = Idx_2,
            Min_3 = Min
    end,
            J_2 = (J + 1),
            Fun_7_loop(Edges, Idx_4, J_2, Min_3, Res, Tmp);
        _ -> {Edges, Idx_2, J, Min, Res, Tmp}
    end
end,
{Edges, Idx_4, J_2, Min_3, Res, Tmp} = Fun_7(Edges, Idx_2, J, Min, Res, Tmp),
            Res_2 = lists:append(Res, [Min_3]),
            Out = [],
            K = 0,
            Fun_8 = fun Fun_8_loop(Edges, Idx_4, J_2, K, Min_3, Out, Res_2, Tmp) ->
    case (K < length(Tmp)) of
        true ->
            case (K /= Idx_4) of
        true -> Out_2 = lists:append(Out, [(case erlang:is_map(Tmp) of true -> maps:get(K, Tmp, nil); _ -> lists:nth(K + 1, Tmp) end)]),
            Out_3 = Out_2;
        _ -> Out_3 = Out
    end,
            K_2 = (K + 1),
            Fun_8_loop(Edges, Idx_4, J_2, K_2, Min_3, Out_3, Res_2, Tmp);
        _ -> {Edges, Idx_4, J_2, K, Min_3, Out, Res_2, Tmp}
    end
end,
{Edges, Idx_4, J_2, K_2, Min_3, Out_3, Res_2, Tmp} = Fun_8(Edges, Idx_4, J_2, K, Min_3, Out, Res_2, Tmp),
            Tmp_2 = Out_3,
            Fun_9_loop(Edges, Res_2, Tmp_2);
        _ -> {Edges, Res, Tmp}
    end
end,
{Edges, Res_2, Tmp_2} = Fun_9(Edges, Res, Tmp),
        Res_2
    catch {return, Ret} -> Ret end.

getedgesfaces(Points_2, Faces_2) ->
    try
        Edges_2 = [],
        Fnum = 0,
        Fun_11 = fun Fun_11_loop(Edges_2, Faces_2, Fnum, Points_2) ->
    case (Fnum < length(Faces_2)) of
        true ->
            Face_2 = (case erlang:is_map(Faces_2) of true -> maps:get(Fnum, Faces_2, nil); _ -> lists:nth(Fnum + 1, Faces_2) end),
            NumP = length(Face_2),
            Pi = 0,
            Fun_10 = fun Fun_10_loop(Edges_2, Face_2, Faces_2, Fnum, NumP, Pi, Points_2) ->
    case (Pi < NumP) of
        true ->
            Pn1 = (case erlang:is_map(Face_2) of true -> maps:get(Pi, Face_2, nil); _ -> lists:nth(Pi + 1, Face_2) end),
            Pn2 = 0,
            case (Pi < (NumP - 1)) of
        true -> Pn2_2 = (case erlang:is_map(Face_2) of true -> maps:get((Pi + 1), Face_2, nil); _ -> lists:nth((Pi + 1) + 1, Face_2) end),
            Pn2_4 = Pn2_2;
        _ -> Pn2_3 = (case erlang:is_map(Face_2) of true -> maps:get(0, Face_2, nil); _ -> lists:nth(0 + 1, Face_2) end),
            Pn2_4 = Pn2_3
    end,
            case (Pn1 > Pn2_4) of
        true -> Tmpn = Pn1,
            Pn1_2 = Pn2_4,
            Pn2_5 = Tmpn,
            Pn1_3 = Pn1_2,
            Pn2_6 = Pn2_5,
            Tmpn_2 = Tmpn;
        _ -> Pn1_3 = Pn1,
            Pn2_6 = Pn2_4,
            Tmpn_2 = nil
    end,
            Edges_3 = lists:append(Edges_2, [[Pn1_3, Pn2_6, Fnum]]),
            Pi_2 = (Pi + 1),
            Fun_10_loop(Edges_3, Face_2, Faces_2, Fnum, NumP, Pi_2, Points_2);
        _ -> {Edges_2, Face_2, Faces_2, Fnum, NumP, Pi, Points_2}
    end
end,
{Edges_3, Face_2, Faces_2, Fnum, NumP, Pi_2, Points_2} = Fun_10(Edges_2, Face_2, Faces_2, Fnum, NumP, Pi, Points_2),
            Fnum_2 = (Fnum + 1),
            Fun_11_loop(Edges_3, Faces_2, Fnum_2, Points_2);
        _ -> {Edges_2, Faces_2, Fnum, Points_2}
    end
end,
{Edges_3, Faces_2, Fnum_2, Points_2} = Fun_11(Edges_2, Faces_2, Fnum, Points_2),
        Edges_4 = sortedges(Edges_3),
        Merged = [],
        Idx_5 = 0,
        Fun_12 = fun Fun_12_loop(Edges_4, Faces_2, Fnum_2, Idx_5, Merged, Points_2) ->
    case (Idx_5 < length(Edges_4)) of
        true ->
            try
                E1 = (case erlang:is_map(Edges_4) of true -> maps:get(Idx_5, Edges_4, nil); _ -> lists:nth(Idx_5 + 1, Edges_4) end),
                case (Idx_5 < (length(Edges_4) - 1)) of
        true -> E2 = (case erlang:is_map(Edges_4) of true -> maps:get((Idx_5 + 1), Edges_4, nil); _ -> lists:nth((Idx_5 + 1) + 1, Edges_4) end),
            case (((case erlang:is_map(E1) of true -> maps:get(0, E1, nil); _ -> lists:nth(0 + 1, E1) end) == (case erlang:is_map(E2) of true -> maps:get(0, E2, nil); _ -> lists:nth(0 + 1, E2) end)) andalso ((case erlang:is_map(E1) of true -> maps:get(1, E1, nil); _ -> lists:nth(1 + 1, E1) end) == (case erlang:is_map(E2) of true -> maps:get(1, E2, nil); _ -> lists:nth(1 + 1, E2) end))) of
        true -> Merged_2 = lists:append(Merged, [[(case erlang:is_map(E1) of true -> maps:get(0, E1, nil); _ -> lists:nth(0 + 1, E1) end), (case erlang:is_map(E1) of true -> maps:get(1, E1, nil); _ -> lists:nth(1 + 1, E1) end), (case erlang:is_map(E1) of true -> maps:get(2, E1, nil); _ -> lists:nth(2 + 1, E1) end), (case erlang:is_map(E2) of true -> maps:get(2, E2, nil); _ -> lists:nth(2 + 1, E2) end)]]),
            Idx_6 = (Idx_5 + 2),
            throw({continue, Edges_4, Faces_2, Fnum_2, Idx_6, Merged_2, Points_2}),
            Idx_7 = Idx_6,
            Merged_3 = Merged_2;
        _ -> Idx_7 = Idx_5,
            Merged_3 = Merged
    end,
            E2_2 = E2,
            Idx_8 = Idx_7,
            Merged_4 = Merged_3;
        _ -> E2_2 = nil,
            Idx_8 = Idx_5,
            Merged_4 = Merged
    end,
                Merged_5 = lists:append(Merged_4, [[(case erlang:is_map(E1) of true -> maps:get(0, E1, nil); _ -> lists:nth(0 + 1, E1) end), (case erlang:is_map(E1) of true -> maps:get(1, E1, nil); _ -> lists:nth(1 + 1, E1) end), (case erlang:is_map(E1) of true -> maps:get(2, E1, nil); _ -> lists:nth(2 + 1, E1) end), -1]]),
                Idx_9 = (Idx_8 + 1),
                Fun_12_loop(Edges_4, Faces_2, Fnum_2, Idx_9, Merged_5, Points_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_12_loop(C0, C1, C2, C3, C4, C5);
                break -> {Edges_4, Faces_2, Fnum_2, Idx_5, Merged, Points_2}
            end;
        _ -> {Edges_4, Faces_2, Fnum_2, Idx_5, Merged, Points_2}
    end
end,
{Edges_4, Faces_2, Fnum_2, Idx_9, Merged_5, Points_2} = Fun_12(Edges_4, Faces_2, Fnum_2, Idx_5, Merged, Points_2),
        EdgesCenters = [],
        Fun_13 = fun Fun_13_loop(List, Edges_4, EdgesCenters, Faces_2, Fnum_2, Idx_9, Merged_5, Points_2) ->
    case List of
        [] -> {Edges_4, EdgesCenters, Faces_2, Fnum_2, Idx_9, Merged_5, Points_2};
        [Me|Me_rest] ->
            P1_3 = (case erlang:is_map(Points_2) of true -> maps:get((case erlang:is_map(Me) of true -> maps:get(0, Me, nil); _ -> lists:nth(0 + 1, Me) end), Points_2, nil); _ -> lists:nth((case erlang:is_map(Me) of true -> maps:get(0, Me, nil); _ -> lists:nth(0 + 1, Me) end) + 1, Points_2) end),
            P2_3 = (case erlang:is_map(Points_2) of true -> maps:get((case erlang:is_map(Me) of true -> maps:get(1, Me, nil); _ -> lists:nth(1 + 1, Me) end), Points_2, nil); _ -> lists:nth((case erlang:is_map(Me) of true -> maps:get(1, Me, nil); _ -> lists:nth(1 + 1, Me) end) + 1, Points_2) end),
            Cp = centerpoint(P1_3, P2_3),
            EdgesCenters_2 = lists:append(EdgesCenters, [#{"pn1" => (case erlang:is_map(Me) of true -> maps:get(0, Me, nil); _ -> lists:nth(0 + 1, Me) end), "pn2" => (case erlang:is_map(Me) of true -> maps:get(1, Me, nil); _ -> lists:nth(1 + 1, Me) end), "fn1" => (case erlang:is_map(Me) of true -> maps:get(2, Me, nil); _ -> lists:nth(2 + 1, Me) end), "fn2" => (case erlang:is_map(Me) of true -> maps:get(3, Me, nil); _ -> lists:nth(3 + 1, Me) end), "cp" => Cp}]),
            Fun_13_loop(Me_rest, Edges_4, EdgesCenters_2, Faces_2, Fnum_2, Idx_9, Merged_5, Points_2)
    end
end,
{Edges_4, EdgesCenters_2, Faces_2, Fnum_2, Idx_9, Merged_5, Points_2} = Fun_13(Merged_5, Edges_4, EdgesCenters, Faces_2, Fnum_2, Idx_9, Merged_5, Points_2),
        EdgesCenters_2
    catch {return, Ret} -> Ret end.

getedgepoints(Points_3, EdgesFaces, FacePoints_3) ->
    try
        EdgePoints = [],
        I_5 = 0,
        Fun_14 = fun Fun_14_loop(EdgePoints, EdgesFaces, FacePoints_3, I_5, Points_3) ->
    case (I_5 < length(EdgesFaces)) of
        true ->
            Edge = (case erlang:is_map(EdgesFaces) of true -> maps:get(I_5, EdgesFaces, nil); _ -> lists:nth(I_5 + 1, EdgesFaces) end),
            Cp_2 = maps:get("cp", Edge, nil),
            Fp1 = (case erlang:is_map(FacePoints_3) of true -> maps:get(maps:get("fn1", Edge, nil), FacePoints_3, nil); _ -> lists:nth(maps:get("fn1", Edge, nil) + 1, FacePoints_3) end),
            Fp2 = Fp1,
            case (maps:get("fn2", Edge, nil) /= (0 - 1)) of
        true -> Fp2_2 = (case erlang:is_map(FacePoints_3) of true -> maps:get(maps:get("fn2", Edge, nil), FacePoints_3, nil); _ -> lists:nth(maps:get("fn2", Edge, nil) + 1, FacePoints_3) end),
            Fp2_3 = Fp2_2;
        _ -> Fp2_3 = Fp2
    end,
            Cfp = centerpoint(Fp1, Fp2_3),
            EdgePoints_2 = lists:append(EdgePoints, [centerpoint(Cp_2, Cfp)]),
            I_6 = (I_5 + 1),
            Fun_14_loop(EdgePoints_2, EdgesFaces, FacePoints_3, I_6, Points_3);
        _ -> {EdgePoints, EdgesFaces, FacePoints_3, I_5, Points_3}
    end
end,
{EdgePoints_2, EdgesFaces, FacePoints_3, I_6, Points_3} = Fun_14(EdgePoints, EdgesFaces, FacePoints_3, I_5, Points_3),
        EdgePoints_2
    catch {return, Ret} -> Ret end.

getavgfacepoints(Points_4, Faces_3, FacePoints_4) ->
    try
        NumP_2 = length(Points_4),
        Temp = [],
        I_7 = 0,
        Fun_15 = fun Fun_15_loop(FacePoints_4, Faces_3, I_7, NumP_2, Points_4, Temp) ->
    case (I_7 < NumP_2) of
        true ->
            Temp_2 = lists:append(Temp, [#{"p" => #{"x" => 0, "y" => 0, "z" => 0}, "n" => 0}]),
            I_8 = (I_7 + 1),
            Fun_15_loop(FacePoints_4, Faces_3, I_8, NumP_2, Points_4, Temp_2);
        _ -> {FacePoints_4, Faces_3, I_7, NumP_2, Points_4, Temp}
    end
end,
{FacePoints_4, Faces_3, I_8, NumP_2, Points_4, Temp_2} = Fun_15(FacePoints_4, Faces_3, I_7, NumP_2, Points_4, Temp),
        Fnum_3 = 0,
        Fun_17 = fun Fun_17_loop(FacePoints_4, Faces_3, Fnum_3, I_8, NumP_2, Points_4, Temp_2) ->
    case (Fnum_3 < length(Faces_3)) of
        true ->
            Fp_4 = (case erlang:is_map(FacePoints_4) of true -> maps:get(Fnum_3, FacePoints_4, nil); _ -> lists:nth(Fnum_3 + 1, FacePoints_4) end),
            Fun_16 = fun Fun_16_loop(List, FacePoints_4, Faces_3, Fnum_3, Fp_4, I_8, NumP_2, Points_4, Temp_2) ->
    case List of
        [] -> {FacePoints_4, Faces_3, Fnum_3, Fp_4, I_8, NumP_2, Points_4, Temp_2};
        [Pn|Pn_rest] ->
            Tp = (case erlang:is_map(Temp_2) of true -> maps:get(Pn, Temp_2, nil); _ -> lists:nth(Pn + 1, Temp_2) end),
            Temp_3 = lists:sublist(Temp_2, Pn) ++ [#{"p" => sumpoint(maps:get("p", Tp, nil), Fp_4), "n" => (maps:get("n", Tp, nil) + 1)}] ++ lists:nthtail(Pn + 1, Temp_2),
            Fun_16_loop(Pn_rest, FacePoints_4, Faces_3, Fnum_3, Fp_4, I_8, NumP_2, Points_4, Temp_3)
    end
end,
{FacePoints_4, Faces_3, Fnum_3, Fp_4, I_8, NumP_2, Points_4, Temp_3} = Fun_16((case erlang:is_map(Faces_3) of true -> maps:get(Fnum_3, Faces_3, nil); _ -> lists:nth(Fnum_3 + 1, Faces_3) end), FacePoints_4, Faces_3, Fnum_3, Fp_4, I_8, NumP_2, Points_4, Temp_2),
            Fnum_4 = (Fnum_3 + 1),
            Fun_17_loop(FacePoints_4, Faces_3, Fnum_4, I_8, NumP_2, Points_4, Temp_3);
        _ -> {FacePoints_4, Faces_3, Fnum_3, I_8, NumP_2, Points_4, Temp_2}
    end
end,
{FacePoints_4, Faces_3, Fnum_4, I_8, NumP_2, Points_4, Temp_3} = Fun_17(FacePoints_4, Faces_3, Fnum_3, I_8, NumP_2, Points_4, Temp_2),
        Avg = [],
        J_3 = 0,
        Fun_18 = fun Fun_18_loop(Avg, FacePoints_4, Faces_3, Fnum_4, I_8, J_3, NumP_2, Points_4, Temp_3) ->
    case (J_3 < NumP_2) of
        true ->
            Tp_2 = (case erlang:is_map(Temp_3) of true -> maps:get(J_3, Temp_3, nil); _ -> lists:nth(J_3 + 1, Temp_3) end),
            Avg_2 = lists:append(Avg, [divpoint(maps:get("p", Tp_2, nil), float(maps:get("n", Tp_2, nil)))]),
            J_4 = (J_3 + 1),
            Fun_18_loop(Avg_2, FacePoints_4, Faces_3, Fnum_4, I_8, J_4, NumP_2, Points_4, Temp_3);
        _ -> {Avg, FacePoints_4, Faces_3, Fnum_4, I_8, J_3, NumP_2, Points_4, Temp_3}
    end
end,
{Avg_2, FacePoints_4, Faces_3, Fnum_4, I_8, J_4, NumP_2, Points_4, Temp_3} = Fun_18(Avg, FacePoints_4, Faces_3, Fnum_4, I_8, J_3, NumP_2, Points_4, Temp_3),
        Avg_2
    catch {return, Ret} -> Ret end.

getavgmidedges(Points_5, EdgesFaces_2) ->
    try
        NumP_3 = length(Points_5),
        Temp_4 = [],
        I_9 = 0,
        Fun_19 = fun Fun_19_loop(EdgesFaces_2, I_9, NumP_3, Points_5, Temp_4) ->
    case (I_9 < NumP_3) of
        true ->
            Temp_5 = lists:append(Temp_4, [#{"p" => #{"x" => 0, "y" => 0, "z" => 0}, "n" => 0}]),
            I_10 = (I_9 + 1),
            Fun_19_loop(EdgesFaces_2, I_10, NumP_3, Points_5, Temp_5);
        _ -> {EdgesFaces_2, I_9, NumP_3, Points_5, Temp_4}
    end
end,
{EdgesFaces_2, I_10, NumP_3, Points_5, Temp_5} = Fun_19(EdgesFaces_2, I_9, NumP_3, Points_5, Temp_4),
        Fun_20 = fun Fun_20_loop(List, EdgesFaces_2, I_10, NumP_3, Points_5, Temp_5) ->
    case List of
        [] -> {EdgesFaces_2, I_10, NumP_3, Points_5, Temp_5};
        [Edge_2|Edge_2_rest] ->
            Cp_3 = maps:get("cp", Edge_2, nil),
            Arr = [maps:get("pn1", Edge_2, nil), maps:get("pn2", Edge_2, nil)],
            Fun_21 = fun Fun_21_loop(List, Arr, Cp_3, Edge_2, EdgesFaces_2, I_10, NumP_3, Points_5, Temp_5) ->
    case List of
        [] -> {Arr, Cp_3, Edge_2, EdgesFaces_2, I_10, NumP_3, Points_5, Temp_5};
        [Pn_2|Pn_2_rest] ->
            Tp_3 = (case erlang:is_map(Temp_5) of true -> maps:get(Pn_2, Temp_5, nil); _ -> lists:nth(Pn_2 + 1, Temp_5) end),
            Temp_6 = lists:sublist(Temp_5, Pn_2) ++ [#{"p" => sumpoint(maps:get("p", Tp_3, nil), Cp_3), "n" => (maps:get("n", Tp_3, nil) + 1)}] ++ lists:nthtail(Pn_2 + 1, Temp_5),
            Fun_21_loop(Pn_2_rest, Arr, Cp_3, Edge_2, EdgesFaces_2, I_10, NumP_3, Points_5, Temp_6)
    end
end,
{Arr, Cp_3, Edge_2, EdgesFaces_2, I_10, NumP_3, Points_5, Temp_6} = Fun_21(Arr, Arr, Cp_3, Edge_2, EdgesFaces_2, I_10, NumP_3, Points_5, Temp_5),
            Fun_20_loop(Edge_2_rest, EdgesFaces_2, I_10, NumP_3, Points_5, Temp_6)
    end
end,
{EdgesFaces_2, I_10, NumP_3, Points_5, Temp_6} = Fun_20(EdgesFaces_2, EdgesFaces_2, I_10, NumP_3, Points_5, Temp_5),
        Avg_3 = [],
        J_5 = 0,
        Fun_22 = fun Fun_22_loop(Avg_3, EdgesFaces_2, I_10, J_5, NumP_3, Points_5, Temp_6) ->
    case (J_5 < NumP_3) of
        true ->
            Tp_4 = (case erlang:is_map(Temp_6) of true -> maps:get(J_5, Temp_6, nil); _ -> lists:nth(J_5 + 1, Temp_6) end),
            Avg_4 = lists:append(Avg_3, [divpoint(maps:get("p", Tp_4, nil), float(maps:get("n", Tp_4, nil)))]),
            J_6 = (J_5 + 1),
            Fun_22_loop(Avg_4, EdgesFaces_2, I_10, J_6, NumP_3, Points_5, Temp_6);
        _ -> {Avg_3, EdgesFaces_2, I_10, J_5, NumP_3, Points_5, Temp_6}
    end
end,
{Avg_4, EdgesFaces_2, I_10, J_6, NumP_3, Points_5, Temp_6} = Fun_22(Avg_3, EdgesFaces_2, I_10, J_5, NumP_3, Points_5, Temp_6),
        Avg_4
    catch {return, Ret} -> Ret end.

getpointsfaces(Points_6, Faces_4) ->
    try
        Pf = [],
        I_11 = 0,
        Fun_23 = fun Fun_23_loop(Faces_4, I_11, Pf, Points_6) ->
    case (I_11 < length(Points_6)) of
        true ->
            Pf_2 = lists:append(Pf, [0]),
            I_12 = (I_11 + 1),
            Fun_23_loop(Faces_4, I_12, Pf_2, Points_6);
        _ -> {Faces_4, I_11, Pf, Points_6}
    end
end,
{Faces_4, I_12, Pf_2, Points_6} = Fun_23(Faces_4, I_11, Pf, Points_6),
        Fnum_5 = 0,
        Fun_25 = fun Fun_25_loop(Faces_4, Fnum_5, I_12, Pf_2, Points_6) ->
    case (Fnum_5 < length(Faces_4)) of
        true ->
            Fun_24 = fun Fun_24_loop(List, Faces_4, Fnum_5, I_12, Pf_2, Points_6) ->
    case List of
        [] -> {Faces_4, Fnum_5, I_12, Pf_2, Points_6};
        [Pn_3|Pn_3_rest] ->
            Pf_3 = lists:sublist(Pf_2, Pn_3) ++ [((case erlang:is_map(Pf_2) of true -> maps:get(Pn_3, Pf_2, nil); _ -> lists:nth(Pn_3 + 1, Pf_2) end) + 1)] ++ lists:nthtail(Pn_3 + 1, Pf_2),
            Fun_24_loop(Pn_3_rest, Faces_4, Fnum_5, I_12, Pf_3, Points_6)
    end
end,
{Faces_4, Fnum_5, I_12, Pf_3, Points_6} = Fun_24((case erlang:is_map(Faces_4) of true -> maps:get(Fnum_5, Faces_4, nil); _ -> lists:nth(Fnum_5 + 1, Faces_4) end), Faces_4, Fnum_5, I_12, Pf_2, Points_6),
            Fnum_6 = (Fnum_5 + 1),
            Fun_25_loop(Faces_4, Fnum_6, I_12, Pf_3, Points_6);
        _ -> {Faces_4, Fnum_5, I_12, Pf_2, Points_6}
    end
end,
{Faces_4, Fnum_6, I_12, Pf_3, Points_6} = Fun_25(Faces_4, Fnum_5, I_12, Pf_2, Points_6),
        Pf_3
    catch {return, Ret} -> Ret end.

getnewpoints(Points_7, Pf_4, Afp, Ame) ->
    try
        NewPts = [],
        I_13 = 0,
        Fun_26 = fun Fun_26_loop(Afp, Ame, I_13, NewPts, Pf_4, Points_7) ->
    case (I_13 < length(Points_7)) of
        true ->
            N_2 = float((case erlang:is_map(Pf_4) of true -> maps:get(I_13, Pf_4, nil); _ -> lists:nth(I_13 + 1, Pf_4) end)),
            M1 = mochi_safe_div((N_2 - 3), N_2),
            M2 = mochi_safe_div(1, N_2),
            M3 = mochi_safe_div(2, N_2),
            Old = (case erlang:is_map(Points_7) of true -> maps:get(I_13, Points_7, nil); _ -> lists:nth(I_13 + 1, Points_7) end),
            P1_4 = mulpoint(Old, M1),
            P2_4 = mulpoint((case erlang:is_map(Afp) of true -> maps:get(I_13, Afp, nil); _ -> lists:nth(I_13 + 1, Afp) end), M2),
            P3 = mulpoint((case erlang:is_map(Ame) of true -> maps:get(I_13, Ame, nil); _ -> lists:nth(I_13 + 1, Ame) end), M3),
            NewPts_2 = lists:append(NewPts, [sumpoint(sumpoint(P1_4, P2_4), P3)]),
            I_14 = (I_13 + 1),
            Fun_26_loop(Afp, Ame, I_14, NewPts_2, Pf_4, Points_7);
        _ -> {Afp, Ame, I_13, NewPts, Pf_4, Points_7}
    end
end,
{Afp, Ame, I_14, NewPts_2, Pf_4, Points_7} = Fun_26(Afp, Ame, I_13, NewPts, Pf_4, Points_7),
        NewPts_2
    catch {return, Ret} -> Ret end.

key(A, B) ->
    try
        (case (A < B) of
    true -> ((lists:flatten(io_lib:format("~p", [A])) ++ ",") ++ lists:flatten(io_lib:format("~p", [B])));
    _ -> ((lists:flatten(io_lib:format("~p", [B])) ++ ",") ++ lists:flatten(io_lib:format("~p", [A])))
end)
    catch {return, Ret} -> Ret end.

cmcsubdiv(Points_8, Faces_5) ->
    try
        FacePoints_5 = getfacepoints(Points_8, Faces_5),
        EdgesFaces_3 = getedgesfaces(Points_8, Faces_5),
        EdgePoints_3 = getedgepoints(Points_8, EdgesFaces_3, FacePoints_5),
        AvgFacePoints = getavgfacepoints(Points_8, Faces_5, FacePoints_5),
        AvgMidEdges = getavgmidedges(Points_8, EdgesFaces_3),
        PointsFaces = getpointsfaces(Points_8, Faces_5),
        NewPoints = getnewpoints(Points_8, PointsFaces, AvgFacePoints, AvgMidEdges),
        FacePointNums = [],
        NextPoint = length(NewPoints),
        Fun_27 = fun Fun_27_loop(List, AvgFacePoints, AvgMidEdges, EdgePoints_3, EdgesFaces_3, FacePointNums, FacePoints_5, Faces_5, NewPoints, NextPoint, Points_8, PointsFaces) ->
    case List of
        [] -> {AvgFacePoints, AvgMidEdges, EdgePoints_3, EdgesFaces_3, FacePointNums, FacePoints_5, Faces_5, NewPoints, NextPoint, Points_8, PointsFaces};
        [Fp_5|Fp_5_rest] ->
            NewPoints_2 = lists:append(NewPoints, [Fp_5]),
            FacePointNums_2 = lists:append(FacePointNums, [NextPoint]),
            NextPoint_2 = (NextPoint + 1),
            Fun_27_loop(Fp_5_rest, AvgFacePoints, AvgMidEdges, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, NewPoints_2, NextPoint_2, Points_8, PointsFaces)
    end
end,
{AvgFacePoints, AvgMidEdges, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, NewPoints_2, NextPoint_2, Points_8, PointsFaces} = Fun_27(FacePoints_5, AvgFacePoints, AvgMidEdges, EdgePoints_3, EdgesFaces_3, FacePointNums, FacePoints_5, Faces_5, NewPoints, NextPoint, Points_8, PointsFaces),
        EdgePointNums = #{},
        Idx_10 = 0,
        Fun_28 = fun Fun_28_loop(AvgFacePoints, AvgMidEdges, EdgePointNums, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Idx_10, NewPoints_2, NextPoint_2, Points_8, PointsFaces) ->
    case (Idx_10 < length(EdgesFaces_3)) of
        true ->
            E_2 = (case erlang:is_map(EdgesFaces_3) of true -> maps:get(Idx_10, EdgesFaces_3, nil); _ -> lists:nth(Idx_10 + 1, EdgesFaces_3) end),
            NewPoints_3 = lists:append(NewPoints_2, [(case erlang:is_map(EdgePoints_3) of true -> maps:get(Idx_10, EdgePoints_3, nil); _ -> lists:nth(Idx_10 + 1, EdgePoints_3) end)]),
            EdgePointNums_2 = maps:put(key(maps:get("pn1", E_2, nil), maps:get("pn2", E_2, nil)), NextPoint_2, EdgePointNums),
            NextPoint_3 = (NextPoint_2 + 1),
            Idx_11 = (Idx_10 + 1),
            Fun_28_loop(AvgFacePoints, AvgMidEdges, EdgePointNums_2, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Idx_11, NewPoints_3, NextPoint_3, Points_8, PointsFaces);
        _ -> {AvgFacePoints, AvgMidEdges, EdgePointNums, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Idx_10, NewPoints_2, NextPoint_2, Points_8, PointsFaces}
    end
end,
{AvgFacePoints, AvgMidEdges, EdgePointNums_2, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Idx_11, NewPoints_3, NextPoint_3, Points_8, PointsFaces} = Fun_28(AvgFacePoints, AvgMidEdges, EdgePointNums, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Idx_10, NewPoints_2, NextPoint_2, Points_8, PointsFaces),
        NewFaces = [],
        Fnum_7 = 0,
        Fun_29 = fun Fun_29_loop(AvgFacePoints, AvgMidEdges, EdgePointNums_2, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Fnum_7, Idx_11, NewFaces, NewPoints_3, NextPoint_3, Points_8, PointsFaces) ->
    case (Fnum_7 < length(Faces_5)) of
        true ->
            OldFace = (case erlang:is_map(Faces_5) of true -> maps:get(Fnum_7, Faces_5, nil); _ -> lists:nth(Fnum_7 + 1, Faces_5) end),
            case (length(OldFace) == 4) of
        true -> A_2 = (case erlang:is_map(OldFace) of true -> maps:get(0, OldFace, nil); _ -> lists:nth(0 + 1, OldFace) end),
            B_2 = (case erlang:is_map(OldFace) of true -> maps:get(1, OldFace, nil); _ -> lists:nth(1 + 1, OldFace) end),
            C = (case erlang:is_map(OldFace) of true -> maps:get(2, OldFace, nil); _ -> lists:nth(2 + 1, OldFace) end),
            D_2 = (case erlang:is_map(OldFace) of true -> maps:get(3, OldFace, nil); _ -> lists:nth(3 + 1, OldFace) end),
            Fpnum = (case erlang:is_map(FacePointNums_2) of true -> maps:get(Fnum_7, FacePointNums_2, nil); _ -> lists:nth(Fnum_7 + 1, FacePointNums_2) end),
            Ab = maps:get(key(A_2, B_2), EdgePointNums_2, nil),
            Da = maps:get(key(D_2, A_2), EdgePointNums_2, nil),
            Bc = maps:get(key(B_2, C), EdgePointNums_2, nil),
            Cd = maps:get(key(C, D_2), EdgePointNums_2, nil),
            NewFaces_2 = lists:append(NewFaces, [[A_2, Ab, Fpnum, Da]]),
            NewFaces_3 = lists:append(NewFaces_2, [[B_2, Bc, Fpnum, Ab]]),
            NewFaces_4 = lists:append(NewFaces_3, [[C, Cd, Fpnum, Bc]]),
            NewFaces_5 = lists:append(NewFaces_4, [[D_2, Da, Fpnum, Cd]]),
            A_3 = A_2,
            Ab_2 = Ab,
            B_3 = B_2,
            Bc_2 = Bc,
            C_2 = C,
            Cd_2 = Cd,
            D_3 = D_2,
            Da_2 = Da,
            Fpnum_2 = Fpnum,
            NewFaces_6 = NewFaces_5;
        _ -> A_3 = nil,
            Ab_2 = nil,
            B_3 = nil,
            Bc_2 = nil,
            C_2 = nil,
            Cd_2 = nil,
            D_3 = nil,
            Da_2 = nil,
            Fpnum_2 = nil,
            NewFaces_6 = NewFaces
    end,
            Fnum_8 = (Fnum_7 + 1),
            Fun_29_loop(AvgFacePoints, AvgMidEdges, EdgePointNums_2, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Fnum_8, Idx_11, NewFaces_6, NewPoints_3, NextPoint_3, Points_8, PointsFaces);
        _ -> {AvgFacePoints, AvgMidEdges, EdgePointNums_2, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Fnum_7, Idx_11, NewFaces, NewPoints_3, NextPoint_3, Points_8, PointsFaces}
    end
end,
{AvgFacePoints, AvgMidEdges, EdgePointNums_2, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Fnum_8, Idx_11, NewFaces_6, NewPoints_3, NextPoint_3, Points_8, PointsFaces} = Fun_29(AvgFacePoints, AvgMidEdges, EdgePointNums_2, EdgePoints_3, EdgesFaces_3, FacePointNums_2, FacePoints_5, Faces_5, Fnum_7, Idx_11, NewFaces, NewPoints_3, NextPoint_3, Points_8, PointsFaces),
        [NewPoints_3, NewFaces_6]
    catch {return, Ret} -> Ret end.

formatpoint(P_3) ->
    try
        (((((("[" ++ fmt4(maps:get("x", P_3, nil))) ++ " ") ++ fmt4(maps:get("y", P_3, nil))) ++ " ") ++ fmt4(maps:get("z", P_3, nil))) ++ "]")
    catch {return, Ret} -> Ret end.

formatface(F) ->
    try
        case (length(F) == 0) of
        true -> throw({return, "[]"});
        _ -> ok
    end,
        S_11 = ("[" ++ fmt2((case erlang:is_map(F) of true -> maps:get(0, F, nil); _ -> lists:nth(0 + 1, F) end))),
        I_15 = 1,
        Fun_30 = fun Fun_30_loop(F, I_15, S_11) ->
    case (I_15 < length(F)) of
        true ->
            S_12 = ((S_11 ++ " ") ++ fmt2((case erlang:is_map(F) of true -> maps:get(I_15, F, nil); _ -> lists:nth(I_15 + 1, F) end))),
            I_16 = (I_15 + 1),
            Fun_30_loop(F, I_16, S_12);
        _ -> {F, I_15, S_11}
    end
end,
{F, I_16, S_12} = Fun_30(F, I_15, S_11),
        S_13 = (S_12 ++ "]"),
        S_13
    catch {return, Ret} -> Ret end.

main() ->
    try
        InputPoints = [#{"x" => -1, "y" => 1, "z" => 1}, #{"x" => -1, "y" => -1, "z" => 1}, #{"x" => 1, "y" => -1, "z" => 1}, #{"x" => 1, "y" => 1, "z" => 1}, #{"x" => 1, "y" => -1, "z" => -1}, #{"x" => 1, "y" => 1, "z" => -1}, #{"x" => -1, "y" => -1, "z" => -1}, #{"x" => -1, "y" => 1, "z" => -1}],
        InputFaces = [[0, 1, 2, 3], [3, 2, 4, 5], [5, 4, 6, 7], [7, 0, 3, 5], [7, 6, 1, 0], [6, 1, 2, 4]],
        OutputPoints = InputPoints,
        OutputFaces = InputFaces,
        I_17 = 0,
        Fun_31 = fun Fun_31_loop(I_17, InputFaces, InputPoints, OutputFaces, OutputPoints) ->
    case (I_17 < 1) of
        true ->
            Res_3 = cmcsubdiv(OutputPoints, OutputFaces),
            OutputPoints_2 = (case erlang:is_map(Res_3) of true -> maps:get(0, Res_3, nil); _ -> lists:nth(0 + 1, Res_3) end),
            OutputFaces_2 = (case erlang:is_map(Res_3) of true -> maps:get(1, Res_3, nil); _ -> lists:nth(1 + 1, Res_3) end),
            I_18 = (I_17 + 1),
            Fun_31_loop(I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2);
        _ -> {I_17, InputFaces, InputPoints, OutputFaces, OutputPoints}
    end
end,
{I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2} = Fun_31(I_17, InputFaces, InputPoints, OutputFaces, OutputPoints),
        Fun_32 = fun Fun_32_loop(List, I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2) ->
    case List of
        [] -> {I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2};
        [P_4|P_4_rest] ->
            io:format("~ts~n", [formatpoint(P_4)]),
            Fun_32_loop(P_4_rest, I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2)
    end
end,
{I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2} = Fun_32(OutputPoints_2, I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2),
        io:format("~ts~n", [""]),
        Fun_33 = fun Fun_33_loop(List, I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2) ->
    case List of
        [] -> {I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2};
        [F_2|F_2_rest] ->
            io:format("~ts~n", [formatface(F_2)]),
            Fun_33_loop(F_2_rest, I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2)
    end
end,
{I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2} = Fun_33(OutputFaces_2, I_18, InputFaces, InputPoints, OutputFaces_2, OutputPoints_2),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
