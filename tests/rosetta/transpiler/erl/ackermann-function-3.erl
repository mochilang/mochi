#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pow_big/2, bit_len/1, ackermann2/2, show/2, main/0]).

% Generated by Mochi transpiler v0.10.39 (4b76711425) on 2025-07-24 18:34 +0700


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

pow_big(Base, Exp) ->
    try
        Result = 1,
        B = Base,
        E = Exp,
        Fun = fun Fun_loop(B, Base, E, Exp, Result) ->
    case (E > 0) of
        true ->
            case ((E rem 2) == 1) of
        true -> Result_2 = (Result * B),
            Result_3 = Result_2;
        _ -> Result_3 = Result
    end,
            B_2 = (B * B),
            E_2 = (E div 2),
            Fun_loop(B_2, Base, E_2, Exp, Result_3);
        _ -> {B, Base, E, Exp, Result}
    end
end,
{B_2, Base, E_2, Exp, Result_3} = Fun(B, Base, E, Exp, Result),
        Result_3
    catch {return, Ret} -> Ret end.

bit_len(X) ->
    try
        N = X,
        C = 0,
        Fun_2 = fun Fun_2_loop(C, N, X) ->
    case (N > 0) of
        true ->
            N_2 = (N div 2),
            C_2 = (C + 1),
            Fun_2_loop(C_2, N_2, X);
        _ -> {C, N, X}
    end
end,
{C_2, N_2, X} = Fun_2(C, N, X),
        C_2
    catch {return, Ret} -> Ret end.

ackermann2(M, N_3) ->
    try
        case (erlang:get('err') /= "") of
        true -> throw({return, 0});
        _ -> ok
    end,
        case (M =< 3) of
        true -> Mi = mochi_to_int(M),
            case (Mi == 0) of
        true -> throw({return, (N_3 + 1)});
        _ -> ok
    end,
            case (Mi == 1) of
        true -> throw({return, (N_3 + 2)});
        _ -> ok
    end,
            case (Mi == 2) of
        true -> throw({return, ((2 * N_3) + 3)});
        _ -> ok
    end,
            case (Mi == 3) of
        true -> Nb = bit_len(N_3),
            case (Nb > 64) of
        true -> erlang:put('err', (("A(m,n) had n of " ++ lists:flatten(io_lib:format("~p", [Nb]))) ++ " bits; too large")),
            throw({return, 0});
        _ -> ok
    end,
            R = (1 bsl mochi_to_int(N_3)),
            throw({return, ((8 * R) - 3)}),
            Nb_2 = Nb,
            R_2 = R;
        _ -> Nb_2 = nil,
            R_2 = nil
    end,
            Mi_2 = Mi,
            Nb_3 = Nb_2,
            R_3 = R_2;
        _ -> Mi_2 = nil,
            Nb_3 = nil,
            R_3 = nil
    end,
        case (bit_len(N_3) == 0) of
        true -> throw({return, ackermann2((M - 1), 1)});
        _ -> ok
    end,
        ackermann2((M - 1), ackermann2(M, (N_3 - 1)))
    catch {return, Ret} -> Ret end.

show(M_2, N_4) ->
    try
        erlang:put('err', ""),
        Res = ackermann2(M_2, N_4),
        case (erlang:get('err') /= "") of
        true -> io:format("~ts~n", [((((("A(" ++ lists:flatten(io_lib:format("~p", [M_2]))) ++ ", ") ++ lists:flatten(io_lib:format("~p", [N_4]))) ++ ") = Error: ") ++ erlang:get('err'))]),
            throw({return, nil});
        _ -> ok
    end,
        case (bit_len(Res) =< 256) of
        true -> io:format("~ts~n", [((((("A(" ++ lists:flatten(io_lib:format("~p", [M_2]))) ++ ", ") ++ lists:flatten(io_lib:format("~p", [N_4]))) ++ ") = ") ++ lists:flatten(io_lib:format("~p", [Res])))]),
            Pre_2 = nil,
            S_2 = nil,
            Suf_2 = nil;
        _ -> S = lists:flatten(io_lib:format("~p", [Res])),
            Pre = string:substr(S, 0 + 1, (20 - 0)),
            Suf = string:substr(S, (length(S) - 20) + 1, (length(S) - (length(S) - 20))),
            io:format("~ts~n", [((((((((("A(" ++ lists:flatten(io_lib:format("~p", [M_2]))) ++ ", ") ++ lists:flatten(io_lib:format("~p", [N_4]))) ++ ") = ") ++ lists:flatten(io_lib:format("~p", [length(S)]))) ++ " digits starting/ending with: ") ++ Pre) ++ "...") ++ Suf)]),
            Pre_2 = Pre,
            S_2 = S,
            Suf_2 = Suf
    end,
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        show(0, 0),
        show(1, 2),
        show(2, 4),
        show(3, 100),
        show(3, 1000000),
        show(4, 1),
        show(4, 2),
        show(4, 3),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    erlang:put('err', ""),
    main().
