#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, bigrat/2, calkinwilf/1, tocontinued/1, termnumber/1, commatize/1, main/0]).

% Generated by Mochi transpiler v0.10.41 (ed0a654f66) on 2025-07-26 20:37 +0700


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_pad_start(S, Len, Ch) ->
    Fill0 = case Ch of
        "" -> " ";
        _ -> Ch
    end,
    Fill = string:substr(Fill0, 1, 1),
    SL = length(S),
    case SL >= Len of
        true -> S;
        _ -> string:copies(Fill, Len - SL) ++ S
    end.


mochi_parse_int_str(S) ->
    try list_to_integer(S) catch _:_ -> 0 end.

bigrat(A, B) ->
    try
        (A / B)
    catch {return, Ret} -> Ret end.

calkinwilf(N) ->
    try
        Seq = [],
        Seq_2 = lists:append(Seq, [bigrat(1, 1)]),
        I = 1,
        Fun = fun Fun_loop(I, N, Seq_2) ->
    case (I < N) of
        true ->
            Prev = lists:nth((I - 1) + 1, Seq_2),
            A_2 = Num(Prev),
            B_2 = Denom(Prev),
            F = (A_2 div B_2),
            T = bigrat(F, 1),
            T_2 = (T * 2),
            T_3 = (T_2 - Prev),
            T_4 = (T_3 + 1),
            T_5 = (1 / T_4),
            Seq_3 = lists:append(Seq_2, [T_5]),
            I_2 = (I + 1),
            Fun_loop(I_2, N, Seq_3);
        _ -> {I, N, Seq_2}
    end
end,
{I_2, N, Seq_3} = Fun(I, N, Seq_2),
        Seq_3
    catch {return, Ret} -> Ret end.

tocontinued(R) ->
    try
        A_3 = Num_2(R),
        B_3 = Denom_2(R),
        Res = [],
        Fun_2 = fun Fun_2_loop(A_3, B_3, Denom_2, Num_2, R, Res) ->
    case true of
        true ->
            try
                Res_2 = lists:append(Res, [mochi_to_int((A_3 div B_3))]),
                T_6 = (A_3 rem B_3),
                A_4 = B_3,
                B_4 = T_6,
                case (A_4 == 1) of
        true -> throw(break);
        _ -> ok
    end,
                Fun_2_loop(A_4, B_4, Denom_2, Num_2, R, Res_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_2_loop(C0, C1, C2, C3, C4, C5);
                break -> {A_3, B_3, Denom_2, Num_2, R, Res}
            end;
        _ -> {A_3, B_3, Denom_2, Num_2, R, Res}
    end
end,
{A_4, B_4, Denom_2, Num_2, R, Res_2} = Fun_2(A_3, B_3, Denom_2, Num_2, R, Res),
        case ((length(Res_2) rem 2) == 0) of
        true -> Res_3 = lists:sublist(Res_2, (length(Res_2) - 1)) ++ [(lists:nth((length(Res_2) - 1) + 1, Res_2) - 1)] ++ lists:nthtail((length(Res_2) - 1) + 1, Res_2),
            Res_4 = lists:append(Res_3, [1]),
            Res_5 = Res_4;
        _ -> Res_5 = Res_2
    end,
        Res_5
    catch {return, Ret} -> Ret end.

termnumber(Cf) ->
    try
        B_5 = "",
        D = "1",
        Fun_3 = fun Fun_3_loop(List, B_5, Cf, D) ->
    case List of
        [] -> {B_5, Cf, D};
        [N_2|N_2_rest] ->
            B_6 = (Repeat(D, N_2) ++ B_5),
            case (D == "1") of
        true -> D_2 = "0",
            D_4 = D_2;
        _ -> D_3 = "1",
            D_4 = D_3
    end,
            Fun_3_loop(N_2_rest, B_6, Cf, D_4)
    end
end,
{B_6, Cf, D_4} = Fun_3(Cf, B_5, Cf, D),
        mochi_parse_int_str(B_6)
    catch {return, Ret} -> Ret end.

commatize(N_3) ->
    try
        S = lists:flatten(io_lib:format("~p", [N_3])),
        Out = "",
        I_3 = 0,
        Cnt = 0,
        Neg = false,
        case (string:substr(S, 0 + 1, (1 - 0)) == "-") of
        true -> Neg_2 = true,
            S_2 = string:substr(S, 1 + 1, length(S) - 1),
            Neg_3 = Neg_2,
            S_3 = S_2;
        _ -> Neg_3 = Neg,
            S_3 = S
    end,
        I_4 = (length(S_3) - 1),
        Fun_4 = fun Fun_4_loop(Cnt, I_4, N_3, Neg_3, Out, S_3) ->
    case (I_4 >= 0) of
        true ->
            Out_2 = (string:substr(S_3, I_4 + 1, ((I_4 + 1) - I_4)) ++ Out),
            Cnt_2 = (Cnt + 1),
            case ((Cnt_2 == 3) andalso (I_4 /= 0)) of
        true -> Out_3 = ("," ++ Out_2),
            Cnt_3 = 0,
            Cnt_4 = Cnt_3,
            Out_4 = Out_3;
        _ -> Cnt_4 = Cnt_2,
            Out_4 = Out_2
    end,
            I_5 = (I_4 - 1),
            Fun_4_loop(Cnt_4, I_5, N_3, Neg_3, Out_4, S_3);
        _ -> {Cnt, I_4, N_3, Neg_3, Out, S_3}
    end
end,
{Cnt_4, I_5, N_3, Neg_3, Out_4, S_3} = Fun_4(Cnt, I_4, N_3, Neg_3, Out, S_3),
        case Neg_3 of
        true -> Out_5 = ("-" ++ Out_4),
            Out_6 = Out_5;
        _ -> Out_6 = Out_4
    end,
        Out_6
    catch {return, Ret} -> Ret end.

main() ->
    try
        Cw = calkinwilf(20),
        io:format("~ts~n", ["The first 20 terms of the Calkin-Wilf sequnence are:"]),
        I_6 = 0,
        Fun_5 = fun Fun_5_loop(Cw, I_6) ->
    case (I_6 < 20) of
        true ->
            R_2 = lists:nth(I_6 + 1, Cw),
            S_4 = lists:flatten(io_lib:format("~p", [Num_3(R_2)])),
            case (Denom_3(R_2) /= 1) of
        true -> S_5 = ((S_4 ++ "/") ++ lists:flatten(io_lib:format("~p", [Denom_3(R_2)]))),
            S_6 = S_5;
        _ -> S_6 = S_4
    end,
            io:format("~ts~n", [((mochi_pad_start((I_6 + mochi_to_int(1)), 2, " ") ++ ": ") ++ S_6)]),
            I_7 = (I_6 + 1),
            Fun_5_loop(Cw, I_7);
        _ -> {Cw, I_6}
    end
end,
{Cw, I_7} = Fun_5(Cw, I_6),
        R_3 = bigrat(83116, 51639),
        Cf_2 = tocontinued(R_3),
        Tn = termnumber(Cf_2),
        io:format("~ts~n", [(((((("" ++ lists:flatten(io_lib:format("~p", [Num_4(R_3)]))) ++ "/") ++ lists:flatten(io_lib:format("~p", [Denom_4(R_3)]))) ++ " is the ") ++ commatize(Tn)) ++ "th term of the sequence.")]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    main().
