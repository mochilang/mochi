#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pow2/1, btoi/1, addnocells/1, step/2, repeat/2, evolve/2, main/0]).

% Generated by Mochi transpiler v0.10.52 (d383f2ab39) on 2025-08-02 10:37 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_repeat(S, N) when is_binary(S) ->
    binary:copy(S, mochi_to_int(N));
mochi_repeat(S, N) when is_list(S) ->
    string:copies(S, mochi_to_int(N));
mochi_repeat(_, _) -> [].

pow2(N) ->
    try
        P = 1,
        I = 0,
        Fun = fun Fun_loop(I, N, P) ->
    case (I < N) of
        true ->
            P_2 = (P * 2),
            I_2 = (I + 1),
            Fun_loop(I_2, N, P_2);
        _ -> {I, N, P}
    end
end,
{I_2, N, P_2} = Fun(I, N, P),
        P_2
    catch {return, Ret} -> Ret end.

btoi(B) ->
    try
        (case B of
    true -> 1;
    _ -> 0
end)
    catch {return, Ret} -> Ret end.

addnocells(Cells) ->
    try
        L = "O",
        R = "O",
        case (string:substr(Cells, 0 + 1, (1 - 0)) == "O") of
        true -> L_2 = ".",
            L_3 = L_2;
        _ -> L_3 = L
    end,
        case (string:substr(Cells, (length(Cells) - 1) + 1, (length(Cells) - (length(Cells) - 1))) == "O") of
        true -> R_2 = ".",
            R_3 = R_2;
        _ -> R_3 = R
    end,
        Cells_2 = ((L_3 ++ Cells) ++ R_3),
        Cells_3 = ((L_3 ++ Cells_2) ++ R_3),
        Cells_3
    catch {return, Ret} -> Ret end.

step(Cells_4, RuleVal) ->
    try
        NewCells = "",
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Cells_4, I_3, NewCells, RuleVal) ->
    case (I_3 < (length(Cells_4) - 2)) of
        true ->
            Bin = 0,
            B_2 = 2,
            N_2 = I_3,
            Fun_2 = fun Fun_2_loop(B_2, Bin, Cells_4, I_3, N_2, NewCells, RuleVal) ->
    case (N_2 < (I_3 + 3)) of
        true ->
            Bin_2 = (Bin + (btoi((string:substr(Cells_4, N_2 + 1, ((N_2 + 1) - N_2)) == "O")) * pow2(B_2))),
            B_3 = (B_2 - 1),
            N_3 = (N_2 + 1),
            Fun_2_loop(B_3, Bin_2, Cells_4, I_3, N_3, NewCells, RuleVal);
        _ -> {B_2, Bin, Cells_4, I_3, N_2, NewCells, RuleVal}
    end
end,
{B_3, Bin_2, Cells_4, I_3, N_3, NewCells, RuleVal} = Fun_2(B_2, Bin, Cells_4, I_3, N_2, NewCells, RuleVal),
            A = ".",
            case (((RuleVal div pow2(Bin_2)) rem 2) == 1) of
        true -> A_2 = "O",
            A_3 = A_2;
        _ -> A_3 = A
    end,
            NewCells_2 = (NewCells ++ A_3),
            I_4 = (I_3 + 1),
            Fun_3_loop(Cells_4, I_4, NewCells_2, RuleVal);
        _ -> {Cells_4, I_3, NewCells, RuleVal}
    end
end,
{Cells_4, I_4, NewCells_2, RuleVal} = Fun_3(Cells_4, I_3, NewCells, RuleVal),
        NewCells_2
    catch {return, Ret} -> Ret end.

repeat(Ch, N_4) ->
    try
        S = "",
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(Ch, I_5, N_4, S) ->
    case (I_5 < N_4) of
        true ->
            S_2 = (S ++ Ch),
            I_6 = (I_5 + 1),
            Fun_4_loop(Ch, I_6, N_4, S_2);
        _ -> {Ch, I_5, N_4, S}
    end
end,
{Ch, I_6, N_4, S_2} = Fun_4(Ch, I_5, N_4, S),
        S_2
    catch {return, Ret} -> Ret end.

evolve(L_4, RuleVal_2) ->
    try
        io:format("~ts~n", [((" Rule #" ++ lists:flatten(io_lib:format("~p", [RuleVal_2]))) ++ ":")]),
        Cells_5 = "O",
        X = 0,
        Fun_5 = fun Fun_5_loop(Cells_5, L_4, RuleVal_2, X) ->
    case (X < L_4) of
        true ->
            Cells_6 = addnocells(Cells_5),
            Width = (40 + (length(Cells_6) div 2)),
            Spaces = mochi_repeat(" ", (Width - length(Cells_6))),
            io:format("~ts~n", [(Spaces ++ Cells_6)]),
            Cells_7 = step(Cells_6, RuleVal_2),
            X_2 = (X + 1),
            Fun_5_loop(Cells_7, L_4, RuleVal_2, X_2);
        _ -> {Cells_5, L_4, RuleVal_2, X}
    end
end,
{Cells_7, L_4, RuleVal_2, X_2} = Fun_5(Cells_5, L_4, RuleVal_2, X),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Fun_6 = fun Fun_6_loop(List) ->
    case List of
        [] -> {};
        [R_4|R_4_rest] ->
            evolve(25, R_4),
            io:format("~ts~n", [""]),
            Fun_6_loop(R_4_rest)
    end
end,
{} = Fun_6([90, 30]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
