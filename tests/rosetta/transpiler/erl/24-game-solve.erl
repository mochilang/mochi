#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, bineval/3, binstring/3, newnum/1, expreval/1, exprstring/1, solve/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (6bb4e4bd23) on 2025-07-25 19:02 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

bineval(Op, L, R) ->
    try
        Lv = expreval(L),
        Rv = expreval(R),
        case (Op == 1) of
        true -> throw({return, #{"num" => ((maps:get("num", Lv, nil) * maps:get("denom", Rv, nil)) + (maps:get("denom", Lv, nil) * maps:get("num", Rv, nil))), "denom" => (maps:get("denom", Lv, nil) * maps:get("denom", Rv, nil))}});
        _ -> ok
    end,
        case (Op == 2) of
        true -> throw({return, #{"num" => ((maps:get("num", Lv, nil) * maps:get("denom", Rv, nil)) - (maps:get("denom", Lv, nil) * maps:get("num", Rv, nil))), "denom" => (maps:get("denom", Lv, nil) * maps:get("denom", Rv, nil))}});
        _ -> ok
    end,
        case (Op == 3) of
        true -> throw({return, #{"num" => (maps:get("num", Lv, nil) * maps:get("num", Rv, nil)), "denom" => (maps:get("denom", Lv, nil) * maps:get("denom", Rv, nil))}});
        _ -> ok
    end,
        #{"num" => (maps:get("num", Lv, nil) * maps:get("denom", Rv, nil)), "denom" => (maps:get("denom", Lv, nil) * maps:get("num", Rv, nil))}
    catch {return, Ret} -> Ret end.

binstring(Op_2, L_2, R_2) ->
    try
        Ls = exprstring(L_2),
        Rs = exprstring(R_2),
        Opstr = "",
        case (Op_2 == 1) of
        true -> Opstr_2 = " + ",
            Opstr_8 = Opstr_2;
        _ -> case (Op_2 == 2) of
        true -> Opstr_3 = " - ",
            Opstr_7 = Opstr_3;
        _ -> case (Op_2 == 3) of
        true -> Opstr_4 = " * ",
            Opstr_6 = Opstr_4;
        _ -> Opstr_5 = " / ",
            Opstr_6 = Opstr_5
    end,
            Opstr_7 = Opstr_6
    end,
            Opstr_8 = Opstr_7
    end,
        (((("(" ++ Ls) ++ Opstr_8) ++ Rs) ++ ")")
    catch {return, Ret} -> Ret end.

newnum(N) ->
    try
        #{"tag" => "num", "value" => #{"num" => N, "denom" => 1}}
    catch {return, Ret} -> Ret end.

expreval(X) ->
    try
        (case X of
    #{"tag" := "num", "value" := V} -> V;
    #{"tag" := "bin", "op" := Op_3, "left" := L_3, "right" := R_3} -> bineval(Op_3, L_3, R_3)
end)
    catch {return, Ret} -> Ret end.

exprstring(X_2) ->
    try
        (case X_2 of
    #{"tag" := "num", "value" := V_2} -> lists:flatten(io_lib:format("~p", [maps:get("num", V_2, nil)]));
    #{"tag" := "bin", "op" := Op_4, "left" := L_4, "right" := R_4} -> binstring(Op_4, L_4, R_4)
end)
    catch {return, Ret} -> Ret end.

solve(Xs) ->
    try
        case (length(Xs) == 1) of
        true -> F = expreval(lists:nth(0 + 1, Xs)),
            case ((maps:get("denom", F, nil) /= 0) andalso (maps:get("num", F, nil) == (maps:get("denom", F, nil) * 24))) of
        true -> io:format("~p~n", [exprstring(lists:nth(0 + 1, Xs))]),
            throw({return, true});
        _ -> ok
    end,
            throw({return, false}),
            F_2 = F;
        _ -> F_2 = nil
    end,
        I = 0,
        Fun_4 = fun Fun_4_loop(F_2, I, Xs) ->
    case (I < length(Xs)) of
        true ->
            J = (I + 1),
            Fun_3 = fun Fun_3_loop(F_2, I, J, Xs) ->
    case (J < length(Xs)) of
        true ->
            Rest = [],
            K = 0,
            Fun = fun Fun_loop(F_2, I, J, K, Rest, Xs) ->
    case (K < length(Xs)) of
        true ->
            case ((K /= I) andalso (K /= J)) of
        true -> Rest_2 = lists:append(Rest, [lists:nth(K + 1, Xs)]),
            Rest_3 = Rest_2;
        _ -> Rest_3 = Rest
    end,
            K_2 = (K + 1),
            Fun_loop(F_2, I, J, K_2, Rest_3, Xs);
        _ -> {F_2, I, J, K, Rest, Xs}
    end
end,
{F_2, I, J, K_2, Rest_3, Xs} = Fun(F_2, I, J, K, Rest, Xs),
            A = lists:nth(I + 1, Xs),
            B = lists:nth(J + 1, Xs),
            Node = #{"tag" => "bin", "op" => 1, "left" => A, "right" => B},
            Fun_2 = fun Fun_2_loop(List, A, B, F_2, I, J, K_2, Node, Rest_3, Xs) ->
    case List of
        [] -> {A, B, F_2, I, J, K_2, Node, Rest_3, Xs};
        [Op_5|Op_5_rest] ->
            Node_2 = #{"tag" => "bin", "op" => Op_5, "left" => A, "right" => B},
            case solve(lists:append(Rest_3, [Node_2])) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun_2_loop(Op_5_rest, A, B, F_2, I, J, K_2, Node_2, Rest_3, Xs)
    end
end,
{A, B, F_2, I, J, K_2, Node_2, Rest_3, Xs} = Fun_2([1, 2, 3, 4], A, B, F_2, I, J, K_2, Node, Rest_3, Xs),
            Node_3 = #{"tag" => "bin", "op" => 2, "left" => B, "right" => A},
            case solve(lists:append(Rest_3, [Node_3])) of
        true -> throw({return, true});
        _ -> ok
    end,
            Node_4 = #{"tag" => "bin", "op" => 4, "left" => B, "right" => A},
            case solve(lists:append(Rest_3, [Node_4])) of
        true -> throw({return, true});
        _ -> ok
    end,
            J_2 = (J + 1),
            Fun_3_loop(F_2, I, J_2, Xs);
        _ -> {F_2, I, J, Xs}
    end
end,
{F_2, I, J_2, Xs} = Fun_3(F_2, I, J, Xs),
            I_2 = (I + 1),
            Fun_4_loop(F_2, I_2, Xs);
        _ -> {F_2, I, Xs}
    end
end,
{F_2, I_2, Xs} = Fun_4(F_2, I, Xs),
        false
    catch {return, Ret} -> Ret end.

main() ->
    try
        Iter = 0,
        Fun_6 = fun Fun_6_loop(Iter) ->
    case (Iter < 10) of
        true ->
            Cards = [],
            I_3 = 0,
            Fun_5 = fun Fun_5_loop(Cards, I_3, Iter) ->
    case (I_3 < 4) of
        true ->
            N_2 = ((mochi_now() rem (9 - 1)) + 1),
            Cards_2 = lists:append(Cards, [newnum(N_2)]),
            io:format("~ts~n", [(" " ++ lists:flatten(io_lib:format("~p", [N_2])))]),
            I_4 = (I_3 + 1),
            Fun_5_loop(Cards_2, I_4, Iter);
        _ -> {Cards, I_3, Iter}
    end
end,
{Cards_2, I_4, Iter} = Fun_5(Cards, I_3, Iter),
            io:format("~ts~n", [":  "]),
            case not solve(Cards_2) of
        true -> io:format("~ts~n", ["No solution"]);
        _ -> ok
    end,
            Iter_2 = (Iter + 1),
            Fun_6_loop(Iter_2);
        _ -> {Iter}
    end
end,
{Iter_2} = Fun_6(Iter),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('OP_ADD', 1),
    erlang:put('OP_SUB', 2),
    erlang:put('OP_MUL', 3),
    erlang:put('OP_DIV', 4),
    erlang:put('n_cards', 4),
    erlang:put('goal', 24),
    erlang:put('digit_range', 9),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
