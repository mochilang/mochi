#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newNum/1, exprEval/1, exprString/1, solve/1, main/0]).

% Generated by Mochi transpiler v0.10.37 (24fa491643) on 2025-07-23 06:48 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

newNum(N) ->
    try
        #{"op" => 0, "value" => #{"num" => N, "denom" => 1}}
    catch {return, V} -> V end.

exprEval(X) ->
    try
        case (maps:get("op", X) == 0) of
        true -> throw({return, maps:get("value", X)});
        _ -> ok
    end,
        L = exprEval(maps:get("left", X)),
        R = exprEval(maps:get("right", X)),
        case (maps:get("op", X) == 1) of
        true -> throw({return, #{"num" => ((maps:get("num", L) * maps:get("denom", R)) + (maps:get("denom", L) * maps:get("num", R))), "denom" => (maps:get("denom", L) * maps:get("denom", R))}});
        _ -> ok
    end,
        case (maps:get("op", X) == 2) of
        true -> throw({return, #{"num" => ((maps:get("num", L) * maps:get("denom", R)) - (maps:get("denom", L) * maps:get("num", R))), "denom" => (maps:get("denom", L) * maps:get("denom", R))}});
        _ -> ok
    end,
        case (maps:get("op", X) == 3) of
        true -> throw({return, #{"num" => (maps:get("num", L) * maps:get("num", R)), "denom" => (maps:get("denom", L) * maps:get("denom", R))}});
        _ -> ok
    end,
        #{"num" => (maps:get("num", L) * maps:get("denom", R)), "denom" => (maps:get("denom", L) * maps:get("num", R))}
    catch {return, V} -> V end.

exprString(X2) ->
    try
        case (maps:get("op", X2) == 0) of
        true -> throw({return, lists:flatten(io_lib:format("~p", [maps:get("num", maps:get("value", X2))]))});
        _ -> ok
    end,
        Ls = exprString(maps:get("left", X2)),
        Rs = exprString(maps:get("right", X2)),
        Opstr = "",
        case (maps:get("op", X2) == 1) of
        true -> Opstr2 = " + ",
            Opstr8 = Opstr2;
        _ -> case (maps:get("op", X2) == 2) of
        true -> Opstr3 = " - ",
            Opstr7 = Opstr3;
        _ -> case (maps:get("op", X2) == 3) of
        true -> Opstr4 = " * ",
            Opstr6 = Opstr4;
        _ -> Opstr5 = " / ",
            Opstr6 = Opstr5
    end,
            Opstr7 = Opstr6
    end,
            Opstr8 = Opstr7
    end,
        (((("(" ++ Ls) ++ Opstr8) ++ Rs) ++ ")")
    catch {return, V} -> V end.

solve(Xs) ->
    try
        case (length(Xs) == 1) of
        true -> F = exprEval(lists:nth(0 + 1, Xs)),
            case ((maps:get("denom", F) /= 0) andalso (maps:get("num", F) == (maps:get("denom", F) * 24))) of
        true -> io:format("~p~n", [exprString(lists:nth(0 + 1, Xs))]),
            throw({return, true});
        _ -> ok
    end,
            throw({return, false}),
            F2 = F;
        _ -> F2 = nil
    end,
        I = 0,
        Fun4 = fun Fun4_loop(F2, I, Xs) ->
    case (I < length(Xs)) of
        true ->
            try
                J = (I + 1),
                Fun3 = fun Fun3_loop(F2, I, J, Xs) ->
    case (J < length(Xs)) of
        true ->
            try
                Rest = [],
                K = 0,
                Fun = fun Fun_loop(F2, I, J, K, Rest, Xs) ->
    case (K < length(Xs)) of
        true ->
            try
                case ((K /= I) andalso (K /= J)) of
        true -> Rest2 = lists:append(Rest, [lists:nth(K + 1, Xs)]),
            Rest3 = Rest2;
        _ -> Rest3 = Rest
    end,
                K2 = (K + 1),
                Fun_loop(F2, I, J, K2, Rest3, Xs)
            catch
                break -> {F2, I, J, K, Rest, Xs}
            end;
        _ -> {F2, I, J, K, Rest, Xs}
    end
end,
{F2, I, J, K2, Rest3, Xs} = Fun(F2, I, J, K, Rest, Xs),
                A = lists:nth(I + 1, Xs),
                B = lists:nth(J + 1, Xs),
                Fun2 = fun Fun2_loop(List, A, B, F2, I, J, K2, Rest3, Xs) ->
    case List of
        [] -> {A, B, F2, I, J, K2, Rest3, Xs};
        [Op|Fun2_loop_rest] ->
            Node = #{"op" => Op, "left" => A, "right" => B},
            case solve(lists:append(Rest3, [Node])) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun2_loop(Fun2_loop_rest, A, B, F2, I, J, K2, Rest3, Xs)
    end
end,
{A, B, F2, I, J, K2, Rest3, Xs} = Fun2([1, 2, 3, 4], A, B, F2, I, J, K2, Rest3, Xs),
                Node2 = #{"op" => 2, "left" => B, "right" => A},
                case solve(lists:append(Rest3, [Node2])) of
        true -> throw({return, true});
        _ -> ok
    end,
                Node3 = #{"op" => 4, "left" => B, "right" => A},
                case solve(lists:append(Rest3, [Node3])) of
        true -> throw({return, true});
        _ -> ok
    end,
                J2 = (J + 1),
                Fun3_loop(F2, I, J2, Xs)
            catch
                break -> {F2, I, J, Xs}
            end;
        _ -> {F2, I, J, Xs}
    end
end,
{F2, I, J2, Xs} = Fun3(F2, I, J, Xs),
                I2 = (I + 1),
                Fun4_loop(F2, I2, Xs)
            catch
                break -> {F2, I, Xs}
            end;
        _ -> {F2, I, Xs}
    end
end,
{F2, I2, Xs} = Fun4(F2, I, Xs),
        false
    catch {return, V} -> V end.

main() ->
    try
        Iter = 0,
        Fun6 = fun Fun6_loop(Iter) ->
    case (Iter < 10) of
        true ->
            try
                Cards = [],
                I3 = 0,
                Fun5 = fun Fun5_loop(Cards, I3, Iter) ->
    case (I3 < 4) of
        true ->
            try
                N2 = ((mochi_now() rem (9 - 1)) + 1),
                Cards2 = lists:append(Cards, [newNum(N2)]),
                io:format("~ts~n", [(" " ++ lists:flatten(io_lib:format("~p", [N2])))]),
                I4 = (I3 + 1),
                Fun5_loop(Cards2, I4, Iter)
            catch
                break -> {Cards, I3, Iter}
            end;
        _ -> {Cards, I3, Iter}
    end
end,
{Cards2, I4, Iter} = Fun5(Cards, I3, Iter),
                io:format("~ts~n", [":  "]),
                case not solve(Cards2) of
        true -> io:format("~ts~n", ["No solution"]);
        _ -> ok
    end,
                Iter2 = (Iter + 1),
                Fun6_loop(Iter2)
            catch
                break -> {Iter}
            end;
        _ -> {Iter}
    end
end,
{Iter2} = Fun6(Iter),
        nil
    catch {return, V} -> V end.

main(_) ->
    erlang:put('OP_NUM', 0),
    erlang:put('OP_ADD', 1),
    erlang:put('OP_SUB', 2),
    erlang:put('OP_MUL', 3),
    erlang:put('OP_DIV', 4),
    erlang:put('n_cards', 4),
    erlang:put('goal', 24),
    erlang:put('digit_range', 9),
    main().
