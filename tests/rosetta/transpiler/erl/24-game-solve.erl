#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, binEval/3, binString/3, newNum/1, exprEval/1, exprString/1, solve/1, main/0]).

% Generated by Mochi transpiler v0.10.38 (87696b4f93) on 2025-07-24 07:28 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

binEval(Op, L, R) ->
    try
        Lv = exprEval(L),
        Rv = exprEval(R),
        case (Op == 1) of
        true -> throw({return, #{"num" => ((maps:get("num", Lv) * maps:get("denom", Rv)) + (maps:get("denom", Lv) * maps:get("num", Rv))), "denom" => (maps:get("denom", Lv) * maps:get("denom", Rv))}});
        _ -> ok
    end,
        case (Op == 2) of
        true -> throw({return, #{"num" => ((maps:get("num", Lv) * maps:get("denom", Rv)) - (maps:get("denom", Lv) * maps:get("num", Rv))), "denom" => (maps:get("denom", Lv) * maps:get("denom", Rv))}});
        _ -> ok
    end,
        case (Op == 3) of
        true -> throw({return, #{"num" => (maps:get("num", Lv) * maps:get("num", Rv)), "denom" => (maps:get("denom", Lv) * maps:get("denom", Rv))}});
        _ -> ok
    end,
        #{"num" => (maps:get("num", Lv) * maps:get("denom", Rv)), "denom" => (maps:get("denom", Lv) * maps:get("num", Rv))}
    catch {return, Ret} -> Ret end.

binString(Op_2, L_2, R_2) ->
    try
        Ls = exprString(L_2),
        Rs = exprString(R_2),
        Opstr = "",
        case (Op_2 == 1) of
        true -> Opstr_2 = " + ",
            Opstr_8 = Opstr_2;
        _ -> case (Op_2 == 2) of
        true -> Opstr_3 = " - ",
            Opstr_7 = Opstr_3;
        _ -> case (Op_2 == 3) of
        true -> Opstr_4 = " * ",
            Opstr_6 = Opstr_4;
        _ -> Opstr_5 = " / ",
            Opstr_6 = Opstr_5
    end,
            Opstr_7 = Opstr_6
    end,
            Opstr_8 = Opstr_7
    end,
        (((("(" ++ Ls) ++ Opstr_8) ++ Rs) ++ ")")
    catch {return, Ret} -> Ret end.

newNum(N) ->
    try
        #{"tag" => "num", "value" => #{"num" => N, "denom" => 1}}
    catch {return, Ret} -> Ret end.

exprEval(X) ->
    try
        (case X of
    #{"tag" := "num", "value" := V} -> V;
    #{"tag" := "bin", "op" := Op_3, "left" := L_3, "right" := R_3} -> binEval(Op_3, L_3, R_3)
end)
    catch {return, Ret} -> Ret end.

exprString(X_2) ->
    try
        (case X_2 of
    #{"tag" := "num", "value" := V_2} -> lists:flatten(io_lib:format("~p", [maps:get("num", V_2)]));
    #{"tag" := "bin", "op" := Op_4, "left" := L_4, "right" := R_4} -> binString(Op_4, L_4, R_4)
end)
    catch {return, Ret} -> Ret end.

solve(Xs) ->
    try
        case (length(Xs) == 1) of
        true -> F = exprEval(lists:nth(0 + 1, Xs)),
            case ((maps:get("denom", F) /= 0) andalso (maps:get("num", F) == (maps:get("denom", F) * 24))) of
        true -> io:format("~p~n", [exprString(lists:nth(0 + 1, Xs))]),
            throw({return, true});
        _ -> ok
    end,
            throw({return, false}),
            F_2 = F;
        _ -> F_2 = nil
    end,
        I = 0,
        Fun_4 = fun Fun_4_loop(F_2, I, Xs) ->
    case (I < length(Xs)) of
        true ->
            try
                J = (I + 1),
                Fun_3 = fun Fun_3_loop(F_2, I, J, Xs) ->
    case (J < length(Xs)) of
        true ->
            try
                Rest = [],
                K = 0,
                Fun = fun Fun_loop(F_2, I, J, K, Rest, Xs) ->
    case (K < length(Xs)) of
        true ->
            try
                case ((K /= I) andalso (K /= J)) of
        true -> Rest_2 = lists:append(Rest, [lists:nth(K + 1, Xs)]),
            Rest_3 = Rest_2;
        _ -> Rest_3 = Rest
    end,
                K_2 = (K + 1),
                Fun_loop(F_2, I, J, K_2, Rest_3, Xs)
            catch
                continue -> Fun_loop(F_2, I, J, K, Rest, Xs);
                break -> {F_2, I, J, K, Rest, Xs}
            end;
        _ -> {F_2, I, J, K, Rest, Xs}
    end
end,
{F_2, I, J, K_2, Rest_3, Xs} = Fun(F_2, I, J, K, Rest, Xs),
                A = lists:nth(I + 1, Xs),
                B = lists:nth(J + 1, Xs),
                Fun_2 = fun Fun_2_loop(List, A, B, F_2, I, J, K_2, Rest_3, Xs) ->
    case List of
        [] -> {A, B, F_2, I, J, K_2, Rest_3, Xs};
        [Op_5|Fun_2_loop_rest] ->
            Node = #{"tag" => "bin", "op" => Op_5, "left" => A, "right" => B},
            case solve(lists:append(Rest_3, [Node])) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun_2_loop(Fun_2_loop_rest, A, B, F_2, I, J, K_2, Rest_3, Xs)
    end
end,
{A, B, F_2, I, J, K_2, Rest_3, Xs} = Fun_2([1, 2, 3, 4], A, B, F_2, I, J, K_2, Rest_3, Xs),
                Node_2 = #{"tag" => "bin", "op" => 2, "left" => B, "right" => A},
                case solve(lists:append(Rest_3, [Node_2])) of
        true -> throw({return, true});
        _ -> ok
    end,
                Node_3 = #{"tag" => "bin", "op" => 4, "left" => B, "right" => A},
                case solve(lists:append(Rest_3, [Node_3])) of
        true -> throw({return, true});
        _ -> ok
    end,
                J_2 = (J + 1),
                Fun_3_loop(F_2, I, J_2, Xs)
            catch
                continue -> Fun_3_loop(F_2, I, J, Xs);
                break -> {F_2, I, J, Xs}
            end;
        _ -> {F_2, I, J, Xs}
    end
end,
{F_2, I, J_2, Xs} = Fun_3(F_2, I, J, Xs),
                I_2 = (I + 1),
                Fun_4_loop(F_2, I_2, Xs)
            catch
                continue -> Fun_4_loop(F_2, I, Xs);
                break -> {F_2, I, Xs}
            end;
        _ -> {F_2, I, Xs}
    end
end,
{F_2, I_2, Xs} = Fun_4(F_2, I, Xs),
        false
    catch {return, Ret} -> Ret end.

main() ->
    try
        Iter = 0,
        Fun_6 = fun Fun_6_loop(Iter) ->
    case (Iter < 10) of
        true ->
            try
                Cards = [],
                I_3 = 0,
                Fun_5 = fun Fun_5_loop(Cards, I_3, Iter) ->
    case (I_3 < 4) of
        true ->
            try
                N_2 = ((mochi_now() rem (9 - 1)) + 1),
                Cards_2 = lists:append(Cards, [newNum(N_2)]),
                io:format("~ts~n", [(" " ++ lists:flatten(io_lib:format("~p", [N_2])))]),
                I_4 = (I_3 + 1),
                Fun_5_loop(Cards_2, I_4, Iter)
            catch
                continue -> Fun_5_loop(Cards, I_3, Iter);
                break -> {Cards, I_3, Iter}
            end;
        _ -> {Cards, I_3, Iter}
    end
end,
{Cards_2, I_4, Iter} = Fun_5(Cards, I_3, Iter),
                io:format("~ts~n", [":  "]),
                case not solve(Cards_2) of
        true -> io:format("~ts~n", ["No solution"]);
        _ -> ok
    end,
                Iter_2 = (Iter + 1),
                Fun_6_loop(Iter_2)
            catch
                continue -> Fun_6_loop(Iter);
                break -> {Iter}
            end;
        _ -> {Iter}
    end
end,
{Iter_2} = Fun_6(Iter),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    erlang:put('OP_ADD', 1),
    erlang:put('OP_SUB', 2),
    erlang:put('OP_MUL', 3),
    erlang:put('OP_DIV', 4),
    erlang:put('n_cards', 4),
    erlang:put('goal', 24),
    erlang:put('digit_range', 9),
    main().
