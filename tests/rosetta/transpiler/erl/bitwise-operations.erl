#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, tounsigned16/1, bin16/1, bit_and/2, bit_or/2, bit_xor/2, bit_not/1, shl/2, shr/2, las/2, ras/2, rol/2, ror/2, bitwise/2]).

% Generated by Mochi transpiler v0.10.40 (e0c44791e6) on 2025-07-25 18:01 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

tounsigned16(N) ->
    try
        U = N,
        case (U < 0) of
        true -> U_2 = (U + 65536),
            U_3 = U_2;
        _ -> U_3 = U
    end,
        (U_3 rem 65536)
    catch {return, Ret} -> Ret end.

bin16(N_2) ->
    try
        U_4 = tounsigned16(N_2),
        Bits = "",
        Mask = 32768,
        Fun = fun Fun_loop(List, Bits, Mask, N_2, U_4) ->
    case List of
        [] -> {Bits, Mask, N_2, U_4};
        [I|I_rest] ->
            case (U_4 >= Mask) of
        true -> Bits_2 = (Bits ++ "1"),
            U_5 = (U_4 - Mask),
            Bits_4 = Bits_2,
            U_6 = U_5;
        _ -> Bits_3 = (Bits ++ "0"),
            Bits_4 = Bits_3,
            U_6 = U_4
    end,
            Mask_2 = mochi_to_int((Mask div 2)),
            Fun_loop(I_rest, Bits_4, Mask_2, N_2, U_6)
    end
end,
{Bits_4, Mask_2, N_2, U_6} = Fun(lists:seq(0, (16) - 1), Bits, Mask, N_2, U_4),
        Bits_4
    catch {return, Ret} -> Ret end.

bit_and(A, B) ->
    try
        Ua = tounsigned16(A),
        Ub = tounsigned16(B),
        Res = 0,
        Bit = 1,
        Fun_2 = fun Fun_2_loop(List, A, B, Bit, Res, Ua, Ub) ->
    case List of
        [] -> {A, B, Bit, Res, Ua, Ub};
        [I_2|I_2_rest] ->
            case (((Ua rem 2) == 1) andalso ((Ub rem 2) == 1)) of
        true -> Res_2 = (Res + Bit),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Ua_2 = mochi_to_int((Ua div 2)),
            Ub_2 = mochi_to_int((Ub div 2)),
            Bit_2 = (Bit * 2),
            Fun_2_loop(I_2_rest, A, B, Bit_2, Res_3, Ua_2, Ub_2)
    end
end,
{A, B, Bit_2, Res_3, Ua_2, Ub_2} = Fun_2(lists:seq(0, (16) - 1), A, B, Bit, Res, Ua, Ub),
        Res_3
    catch {return, Ret} -> Ret end.

bit_or(A_2, B_2) ->
    try
        Ua_3 = tounsigned16(A_2),
        Ub_3 = tounsigned16(B_2),
        Res_4 = 0,
        Bit_3 = 1,
        Fun_3 = fun Fun_3_loop(List, A_2, B_2, Bit_3, Res_4, Ua_3, Ub_3) ->
    case List of
        [] -> {A_2, B_2, Bit_3, Res_4, Ua_3, Ub_3};
        [I_3|I_3_rest] ->
            case (((Ua_3 rem 2) == 1) orelse ((Ub_3 rem 2) == 1)) of
        true -> Res_5 = (Res_4 + Bit_3),
            Res_6 = Res_5;
        _ -> Res_6 = Res_4
    end,
            Ua_4 = mochi_to_int((Ua_3 div 2)),
            Ub_4 = mochi_to_int((Ub_3 div 2)),
            Bit_4 = (Bit_3 * 2),
            Fun_3_loop(I_3_rest, A_2, B_2, Bit_4, Res_6, Ua_4, Ub_4)
    end
end,
{A_2, B_2, Bit_4, Res_6, Ua_4, Ub_4} = Fun_3(lists:seq(0, (16) - 1), A_2, B_2, Bit_3, Res_4, Ua_3, Ub_3),
        Res_6
    catch {return, Ret} -> Ret end.

bit_xor(A_3, B_3) ->
    try
        Ua_5 = tounsigned16(A_3),
        Ub_5 = tounsigned16(B_3),
        Res_7 = 0,
        Bit_5 = 1,
        Fun_4 = fun Fun_4_loop(List, A_3, B_3, Bit_5, Res_7, Ua_5, Ub_5) ->
    case List of
        [] -> {A_3, B_3, Bit_5, Res_7, Ua_5, Ub_5};
        [I_4|I_4_rest] ->
            Abit = (Ua_5 rem 2),
            Bbit = (Ub_5 rem 2),
            case (((Abit == 1) andalso (Bbit == 0)) orelse ((Abit == 0) andalso (Bbit == 1))) of
        true -> Res_8 = (Res_7 + Bit_5),
            Res_9 = Res_8;
        _ -> Res_9 = Res_7
    end,
            Ua_6 = mochi_to_int((Ua_5 div 2)),
            Ub_6 = mochi_to_int((Ub_5 div 2)),
            Bit_6 = (Bit_5 * 2),
            Fun_4_loop(I_4_rest, A_3, B_3, Bit_6, Res_9, Ua_6, Ub_6)
    end
end,
{A_3, B_3, Bit_6, Res_9, Ua_6, Ub_6} = Fun_4(lists:seq(0, (16) - 1), A_3, B_3, Bit_5, Res_7, Ua_5, Ub_5),
        Res_9
    catch {return, Ret} -> Ret end.

bit_not(A_4) ->
    try
        Ua_7 = tounsigned16(A_4),
        (65535 - Ua_7)
    catch {return, Ret} -> Ret end.

shl(A_5, B_4) ->
    try
        Ua_8 = tounsigned16(A_5),
        I_5 = 0,
        Fun_5 = fun Fun_5_loop(A_5, B_4, I_5, Ua_8) ->
    case (I_5 < B_4) of
        true ->
            Ua_9 = ((Ua_8 * 2) rem 65536),
            I_6 = (I_5 + 1),
            Fun_5_loop(A_5, B_4, I_6, Ua_9);
        _ -> {A_5, B_4, I_5, Ua_8}
    end
end,
{A_5, B_4, I_6, Ua_9} = Fun_5(A_5, B_4, I_5, Ua_8),
        Ua_9
    catch {return, Ret} -> Ret end.

shr(A_6, B_5) ->
    try
        Ua_10 = tounsigned16(A_6),
        I_7 = 0,
        Fun_6 = fun Fun_6_loop(A_6, B_5, I_7, Ua_10) ->
    case (I_7 < B_5) of
        true ->
            Ua_11 = mochi_to_int((Ua_10 div 2)),
            I_8 = (I_7 + 1),
            Fun_6_loop(A_6, B_5, I_8, Ua_11);
        _ -> {A_6, B_5, I_7, Ua_10}
    end
end,
{A_6, B_5, I_8, Ua_11} = Fun_6(A_6, B_5, I_7, Ua_10),
        Ua_11
    catch {return, Ret} -> Ret end.

las(A_7, B_6) ->
    try
        shl(A_7, B_6)
    catch {return, Ret} -> Ret end.

ras(A_8, B_7) ->
    try
        Val = A_8,
        I_9 = 0,
        Fun_7 = fun Fun_7_loop(A_8, B_7, I_9, Val) ->
    case (I_9 < B_7) of
        true ->
            case (Val >= 0) of
        true -> Val_2 = mochi_to_int((Val div 2)),
            Val_4 = Val_2;
        _ -> Val_3 = mochi_to_int(((Val - 1) div 2)),
            Val_4 = Val_3
    end,
            I_10 = (I_9 + 1),
            Fun_7_loop(A_8, B_7, I_10, Val_4);
        _ -> {A_8, B_7, I_9, Val}
    end
end,
{A_8, B_7, I_10, Val_4} = Fun_7(A_8, B_7, I_9, Val),
        tounsigned16(Val_4)
    catch {return, Ret} -> Ret end.

rol(A_9, B_8) ->
    try
        Ua_12 = tounsigned16(A_9),
        Left = shl(Ua_12, B_8),
        Right = shr(Ua_12, (16 - B_8)),
        tounsigned16((Left + Right))
    catch {return, Ret} -> Ret end.

ror(A_10, B_9) ->
    try
        Ua_13 = tounsigned16(A_10),
        Right_2 = shr(Ua_13, B_9),
        Left_2 = shl(Ua_13, (16 - B_9)),
        tounsigned16((Left_2 + Right_2))
    catch {return, Ret} -> Ret end.

bitwise(A_11, B_10) ->
    try
        io:format("~ts~n", [("a:   " ++ bin16(A_11))]),
        io:format("~ts~n", [("b:   " ++ bin16(B_10))]),
        io:format("~ts~n", [("and: " ++ bin16(bit_and(A_11, B_10)))]),
        io:format("~ts~n", [("or:  " ++ bin16(bit_or(A_11, B_10)))]),
        io:format("~ts~n", [("xor: " ++ bin16(bit_xor(A_11, B_10)))]),
        io:format("~ts~n", [("not: " ++ bin16(bit_not(A_11)))]),
        case (B_10 < 0) of
        true -> io:format("~ts~n", ["Right operand is negative, but all shifts require an unsigned right operand (shift distance)."]),
            throw({return, nil});
        _ -> ok
    end,
        io:format("~ts~n", [("shl: " ++ bin16(shl(A_11, B_10)))]),
        io:format("~ts~n", [("shr: " ++ bin16(shr(A_11, B_10)))]),
        io:format("~ts~n", [("las: " ++ bin16(las(A_11, B_10)))]),
        io:format("~ts~n", [("ras: " ++ bin16(ras(A_11, B_10)))]),
        io:format("~ts~n", [("rol: " ++ bin16(rol(A_11, B_10)))]),
        io:format("~ts~n", [("ror: " ++ bin16(ror(A_11, B_10)))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    bitwise(-460, 6),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
