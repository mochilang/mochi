#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, commatize/1, p/2]).

% Generated by Mochi transpiler v0.10.50 (e649287d54) on 2025-07-30 14:16 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

commatize(N) ->
    try
        S = lists:flatten(io_lib:format("~p", [N])),
        I = (length(S) rem 3),
        case (I == 0) of
        true -> I_2 = 3,
            I_3 = I_2;
        _ -> I_3 = I
    end,
        Out = string:substr(S, 0 + 1, (I_3 - 0)),
        Fun = fun Fun_loop(I_3, N, Out, S) ->
    case (I_3 < length(S)) of
        true ->
            Out_2 = ((Out ++ ",") ++ string:substr(S, I_3 + 1, ((I_3 + 3) - I_3))),
            I_4 = (I_3 + 3),
            Fun_loop(I_4, N, Out_2, S);
        _ -> {I_3, N, Out, S}
    end
end,
{I_4, N, Out_2, S} = Fun(I_3, N, Out, S),
        Out_2
    catch {return, Ret} -> Ret end.

p(L, N_2) ->
    try
        Ls = lists:flatten(io_lib:format("~p", [L])),
        Digits = 1,
        D = 1,
        Fun_2 = fun Fun_2_loop(L, Ls, D, Digits, N_2) ->
    case (D =< (18 - length(Ls))) of
        true ->
            Digits_2 = (Digits * 10),
            D_2 = (D + 1),
            Fun_2_loop(L, Ls, D_2, Digits_2, N_2);
        _ -> {L, Ls, D, Digits, N_2}
    end
end,
{L, Ls, D_2, Digits_2, N_2} = Fun_2(L, Ls, D, Digits, N_2),
        Ten18 = 1000000000000000000,
        Count = 0,
        I_5 = 0,
        Probe = 1,
        Fun_5 = fun Fun_5_loop(L, Ls, Count, D_2, Digits_2, I_5, N_2, Probe, Ten18) ->
    case true of
        true ->
            try
                Probe_2 = (Probe * 2),
                I_6 = (I_5 + 1),
                case (Probe_2 >= Ten18) of
        true -> Fun_3 = fun Fun_3_loop(L, Ls, Count, D_2, Digits_2, I_6, N_2, Probe_2, Ten18) ->
    case true of
        true ->
            try
                case (Probe_2 >= Ten18) of
        true -> Probe_3 = (Probe_2 / 10),
            Probe_4 = Probe_3;
        _ -> Probe_4 = Probe_2
    end,
                case ((Probe_4 / Digits_2) == L) of
        true -> Count_2 = (Count + 1),
            case (Count_2 >= N_2) of
        true -> Count_3 = (Count_2 - 1),
            throw(break),
            Count_4 = Count_3;
        _ -> Count_4 = Count_2
    end,
            Count_5 = Count_4;
        _ -> Count_5 = Count
    end,
                Probe_5 = (Probe_4 * 2),
                I_7 = (I_6 + 1),
                Fun_3_loop(L, Ls, Count_5, D_2, Digits_2, I_7, N_2, Probe_5, Ten18)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_3_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {L, Ls, Count, D_2, Digits_2, I_6, N_2, Probe_2, Ten18}
            end;
        _ -> {L, Ls, Count, D_2, Digits_2, I_6, N_2, Probe_2, Ten18}
    end
end,
{L, Ls, Count_5, D_2, Digits_2, I_7, N_2, Probe_5, Ten18} = Fun_3(L, Ls, Count, D_2, Digits_2, I_6, N_2, Probe_2, Ten18),
            Count_6 = Count_5,
            Fun_4 = Fun_3,
            I_8 = I_7,
            Probe_6 = Probe_5;
        _ -> Count_6 = Count,
            Fun_4 = Fun_2,
            I_8 = I_6,
            Probe_6 = Probe_2
    end,
                Ps = lists:flatten(io_lib:format("~p", [Probe_6])),
                Le = length(Ls),
                case (Le > length(Ps)) of
        true -> Le_2 = length(Ps),
            Le_3 = Le_2;
        _ -> Le_3 = Le
    end,
                case (string:substr(Ps, 0 + 1, (Le_3 - 0)) == Ls) of
        true -> Count_7 = (Count_6 + 1),
            case (Count_7 >= N_2) of
        true -> throw(break);
        _ -> ok
    end,
            Count_8 = Count_7;
        _ -> Count_8 = Count_6
    end,
                Fun_5_loop(L, Ls, Count_8, D_2, Digits_2, I_8, N_2, Probe_6, Ten18)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_5_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {L, Ls, Count, D_2, Digits_2, I_5, N_2, Probe, Ten18}
            end;
        _ -> {L, Ls, Count, D_2, Digits_2, I_5, N_2, Probe, Ten18}
    end
end,
{L, Ls, Count_8, D_2, Digits_2, I_8, N_2, Probe_6, Ten18} = Fun_5(L, Ls, Count, D_2, Digits_2, I_5, N_2, Probe, Ten18),
        I_8
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('params', [[12, 1], [12, 2], [123, 45]]),
    erlang:put('idx', 0),
    Fun_6 = fun Fun_6_loop() ->
    case (erlang:get('idx') < length(erlang:get('params'))) of
        true ->
            L_2 = lists:nth(0 + 1, lists:nth(erlang:get('idx') + 1, erlang:get('params'))),
            M = lists:nth(1 + 1, lists:nth(erlang:get('idx') + 1, erlang:get('params'))),
            io:format("~ts~n", [((((("p(" ++ lists:flatten(io_lib:format("~p", [L_2]))) ++ ", ") ++ lists:flatten(io_lib:format("~p", [M]))) ++ ") = ") ++ commatize(p(L_2, M)))]),
            erlang:put('idx', (erlang:get('idx') + 1)),
            Fun_6_loop();
        _ -> {}
    end
end,
{} = Fun_6(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
