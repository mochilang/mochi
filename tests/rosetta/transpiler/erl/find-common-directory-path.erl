#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, splitpath/1, joinpath/1, commonprefix/1, main/0]).

% Generated by Mochi transpiler v0.10.50 (e649287d54) on 2025-07-30 14:16 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

splitpath(P) ->
    try
        Parts = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, P, Parts) ->
    case (I < length(P)) of
        true ->
            case (string:substr(P, I + 1, ((I + 1) - I)) == "/") of
        true -> case (Cur /= "") of
        true -> Parts_2 = lists:append(Parts, [Cur]),
            Cur_2 = "",
            Cur_3 = Cur_2,
            Parts_3 = Parts_2;
        _ -> Cur_3 = Cur,
            Parts_3 = Parts
    end,
            Cur_5 = Cur_3,
            Parts_4 = Parts_3;
        _ -> Cur_4 = (Cur ++ string:substr(P, I + 1, ((I + 1) - I))),
            Cur_5 = Cur_4,
            Parts_4 = Parts
    end,
            I_2 = (I + 1),
            Fun_loop(Cur_5, I_2, P, Parts_4);
        _ -> {Cur, I, P, Parts}
    end
end,
{Cur_5, I_2, P, Parts_4} = Fun(Cur, I, P, Parts),
        case (Cur_5 /= "") of
        true -> Parts_5 = lists:append(Parts_4, [Cur_5]),
            Parts_6 = Parts_5;
        _ -> Parts_6 = Parts_4
    end,
        Parts_6
    catch {return, Ret} -> Ret end.

joinpath(Parts_7) ->
    try
        S = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(I_3, Parts_7, S) ->
    case (I_3 < length(Parts_7)) of
        true ->
            S_2 = ((S ++ "/") ++ lists:nth(I_3 + 1, Parts_7)),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Parts_7, S_2);
        _ -> {I_3, Parts_7, S}
    end
end,
{I_4, Parts_7, S_2} = Fun_2(I_3, Parts_7, S),
        S_2
    catch {return, Ret} -> Ret end.

commonprefix(Paths) ->
    try
        case (length(Paths) == 0) of
        true -> throw({return, ""});
        _ -> ok
    end,
        Base = splitpath(lists:nth(0 + 1, Paths)),
        I_5 = 0,
        Prefix = [],
        Fun_4 = fun Fun_4_loop(Base, I_5, Paths, Prefix) ->
    case (I_5 < length(Base)) of
        true ->
            try
                Comp = lists:nth(I_5 + 1, Base),
                Ok = true,
                Fun_3 = fun Fun_3_loop(List, Base, Comp, I_5, Ok, Paths, Prefix) ->
    case List of
        [] -> {Base, Comp, I_5, Ok, Paths, Prefix};
        [P_2|P_2_rest] ->
        try
            Parts_8 = splitpath(P_2),
            case ((I_5 >= length(Parts_8)) orelse (lists:nth(I_5 + 1, Parts_8) /= Comp)) of
        true -> Ok_2 = false,
            throw(break),
            Ok_3 = Ok_2;
        _ -> Ok_3 = Ok
    end,
            Fun_3_loop(P_2_rest, Base, Comp, I_5, Ok_3, Paths, Prefix)
        catch
            {continue, C0, C1, C2, C3, C4, C5} -> Fun_3_loop(P_2_rest, C0, C1, C2, C3, C4, C5);
            {break, B0, B1, B2, B3, B4, B5} -> {B0, B1, B2, B3, B4, B5};
            break -> {Base, Comp, I_5, Ok, Paths, Prefix}
        end
    end
end,
{Base, Comp, I_5, Ok_3, Paths, Prefix} = Fun_3(Paths, Base, Comp, I_5, Ok, Paths, Prefix),
                case Ok_3 of
        true -> Prefix_2 = lists:append(Prefix, [Comp]),
            Prefix_3 = Prefix_2;
        _ -> throw(break),
            Prefix_3 = Prefix
    end,
                I_6 = (I_5 + 1),
                Fun_4_loop(Base, I_6, Paths, Prefix_3)
            catch
                {continue, C0, C1, C2, C3} -> Fun_4_loop(C0, C1, C2, C3);
                break -> {Base, I_5, Paths, Prefix}
            end;
        _ -> {Base, I_5, Paths, Prefix}
    end
end,
{Base, I_6, Paths, Prefix_3} = Fun_4(Base, I_5, Paths, Prefix),
        joinpath(Prefix_3)
    catch {return, Ret} -> Ret end.

main() ->
    try
        Paths_2 = ["/home/user1/tmp/coverage/test", "/home/user1/tmp/covert/operator", "/home/user1/tmp/coven/members", "/home//user1/tmp/coventry", "/home/user1/././tmp/covertly/foo", "/home/bob/../user1/tmp/coved/bar"],
        C = commonprefix(Paths_2),
        case (C == "") of
        true -> io:format("~ts~n", ["No common path"]);
        _ -> io:format("~ts~n", [("Common path: " ++ C)])
    end,
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
