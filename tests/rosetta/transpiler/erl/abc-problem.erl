#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, fields/1, canSpell/2, newSpeller/1, main/0]).

% Generated by Mochi transpiler v0.10.37 (a60a40ef13) on 2025-07-23 08:17 UTC

fields(S) ->
    try
        Res = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, Res, S) ->
    case (I < length(S)) of
        true ->
            try
                C = lists:sublist(S, I + 1, ((I + 1) - I)),
                case (C == " ") of
        true -> case (length(Cur) > 0) of
        true -> Res2 = lists:append(Res, [Cur]),
            Cur2 = "",
            Cur3 = Cur2,
            Res3 = Res2;
        _ -> Cur3 = Cur,
            Res3 = Res
    end,
            Cur5 = Cur3,
            Res4 = Res3;
        _ -> Cur4 = (Cur ++ C),
            Cur5 = Cur4,
            Res4 = Res
    end,
                I2 = (I + 1),
                Fun_loop(Cur5, I2, Res4, S)
            catch
                break -> {Cur, I, Res, S}
            end;
        _ -> {Cur, I, Res, S}
    end
end,
{Cur5, I2, Res4, S} = Fun(Cur, I, Res, S),
        case (length(Cur5) > 0) of
        true -> Res5 = lists:append(Res4, [Cur5]),
            Res6 = Res5;
        _ -> Res6 = Res4
    end,
        Res6
    catch {return, V} -> V end.

canSpell(Word, Blks) ->
    try
        case (length(Word) == 0) of
        true -> throw({return, true});
        _ -> ok
    end,
        C2 = string:to_lower(lists:sublist(Word, 0 + 1, (1 - 0))),
        I3 = 0,
        Fun4 = fun Fun4_loop(Blks, C2, I3, Word) ->
    case (I3 < length(Blks)) of
        true ->
            try
                B = lists:nth(I3 + 1, Blks),
                case ((C2 == string:to_lower(lists:sublist(B, 0 + 1, (1 - 0)))) orelse (C2 == string:to_lower(lists:sublist(B, 1 + 1, (2 - 1))))) of
        true -> Rest = [],
            J = 0,
            Fun2 = fun Fun2_loop(B, Blks, C2, I3, J, Rest, Word) ->
    case (J < length(Blks)) of
        true ->
            try
                case (J /= I3) of
        true -> Rest2 = lists:append(Rest, [lists:nth(J + 1, Blks)]),
            Rest3 = Rest2;
        _ -> Rest3 = Rest
    end,
                J2 = (J + 1),
                Fun2_loop(B, Blks, C2, I3, J2, Rest3, Word)
            catch
                break -> {B, Blks, C2, I3, J, Rest, Word}
            end;
        _ -> {B, Blks, C2, I3, J, Rest, Word}
    end
end,
{B, Blks, C2, I3, J2, Rest3, Word} = Fun2(B, Blks, C2, I3, J, Rest, Word),
            case canSpell(lists:sublist(Word, 1 + 1, length(Word) - 1), Rest3) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun3 = Fun2,
            J3 = J2,
            Rest4 = Rest3;
        _ -> Fun3 = nil,
            J3 = nil,
            Rest4 = nil
    end,
                I4 = (I3 + 1),
                Fun4_loop(Blks, C2, I4, Word)
            catch
                break -> {Blks, C2, I3, Word}
            end;
        _ -> {Blks, C2, I3, Word}
    end
end,
{Blks, C2, I4, Word} = Fun4(Blks, C2, I3, Word),
        false
    catch {return, V} -> V end.

newSpeller(Blocks) ->
    try
        Bl = fields(Blocks),
        fun(W) ->
    try
        canSpell(W, Bl)
    catch {return, V} -> V end
end
    catch {return, V} -> V end.

main() ->
    try
        Sp = newSpeller("BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"),
        Fun5 = fun Fun5_loop(List, Sp) ->
    case List of
        [] -> {Sp};
        [Word2|Fun5_loop_rest] ->
            io:format("~ts~n", [((Word2 ++ " ") ++ lists:flatten(io_lib:format("~p", [Sp(Word2)])))]),
            Fun5_loop(Fun5_loop_rest, Sp)
    end
end,
{Sp} = Fun5(["A", "BARK", "BOOK", "TREAT", "COMMON", "SQUAD", "CONFUSE"], Sp),
        nil
    catch {return, V} -> V end.

main(_) ->
    main().
