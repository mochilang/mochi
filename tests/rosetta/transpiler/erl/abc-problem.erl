#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, fields/1, canspell/2, newspeller/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (c9f97e1bd3) on 2025-07-25 19:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

fields(S) ->
    try
        Res = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, Res, S) ->
    case (I < length(S)) of
        true ->
            C = string:substr(S, I + 1, ((I + 1) - I)),
            case (C == " ") of
        true -> case (length(Cur) > 0) of
        true -> Res_2 = lists:append(Res, [Cur]),
            Cur_2 = "",
            Cur_3 = Cur_2,
            Res_3 = Res_2;
        _ -> Cur_3 = Cur,
            Res_3 = Res
    end,
            Cur_5 = Cur_3,
            Res_4 = Res_3;
        _ -> Cur_4 = (Cur ++ C),
            Cur_5 = Cur_4,
            Res_4 = Res
    end,
            I_2 = (I + 1),
            Fun_loop(Cur_5, I_2, Res_4, S);
        _ -> {Cur, I, Res, S}
    end
end,
{Cur_5, I_2, Res_4, S} = Fun(Cur, I, Res, S),
        case (length(Cur_5) > 0) of
        true -> Res_5 = lists:append(Res_4, [Cur_5]),
            Res_6 = Res_5;
        _ -> Res_6 = Res_4
    end,
        Res_6
    catch {return, Ret} -> Ret end.

canspell(Word, Blks) ->
    try
        case (length(Word) == 0) of
        true -> throw({return, true});
        _ -> ok
    end,
        C_2 = string:to_lower(string:substr(Word, 0 + 1, (1 - 0))),
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(Blks, C_2, I_3, Word) ->
    case (I_3 < length(Blks)) of
        true ->
            B = lists:nth(I_3 + 1, Blks),
            case ((C_2 == string:to_lower(lists:sublist(B, 0 + 1, (1 - 0)))) orelse (C_2 == string:to_lower(lists:sublist(B, 1 + 1, (2 - 1))))) of
        true -> Rest = [],
            J = 0,
            Fun_2 = fun Fun_2_loop(B, Blks, C_2, I_3, J, Rest, Word) ->
    case (J < length(Blks)) of
        true ->
            case (J /= I_3) of
        true -> Rest_2 = lists:append(Rest, [lists:nth(J + 1, Blks)]),
            Rest_3 = Rest_2;
        _ -> Rest_3 = Rest
    end,
            J_2 = (J + 1),
            Fun_2_loop(B, Blks, C_2, I_3, J_2, Rest_3, Word);
        _ -> {B, Blks, C_2, I_3, J, Rest, Word}
    end
end,
{B, Blks, C_2, I_3, J_2, Rest_3, Word} = Fun_2(B, Blks, C_2, I_3, J, Rest, Word),
            case (canspell(string:substr(Word, 1 + 1, length(Word) - 1), Rest_3) /= nil) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun_3 = Fun_2,
            J_3 = J_2,
            Rest_4 = Rest_3;
        _ -> Fun_3 = nil,
            J_3 = nil,
            Rest_4 = nil
    end,
            I_4 = (I_3 + 1),
            Fun_4_loop(Blks, C_2, I_4, Word);
        _ -> {Blks, C_2, I_3, Word}
    end
end,
{Blks, C_2, I_4, Word} = Fun_4(Blks, C_2, I_3, Word),
        false
    catch {return, Ret} -> Ret end.

newspeller(Blocks) ->
    try
        Bl = fields(Blocks),
        fun(W) ->
    try
        canspell(W, Bl)
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end.

main() ->
    try
        Sp = newspeller("BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM"),
        Fun_5 = fun Fun_5_loop(List, Sp) ->
    case List of
        [] -> {Sp};
        [Word_2|Word_2_rest] ->
            io:format("~ts~n", [((Word_2 ++ " ") ++ lists:flatten(io_lib:format("~p", [Sp(Word_2)])))]),
            Fun_5_loop(Word_2_rest, Sp)
    end
end,
{Sp} = Fun_5(["A", "BARK", "BOOK", "TREAT", "COMMON", "SQUAD", "CONFUSE"], Sp),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
