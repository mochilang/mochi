#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, digits/1, commatize/1, isprime/1, split/2, parseintstr/1, reversestr/1, pad/2, findfirst/1, main/0]).

% Generated by Mochi transpiler v0.10.41 (4a1f4378c8) on 2025-07-27 06:30 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_parse_int_str(S) ->
    try list_to_integer(S) catch _:_ -> 0 end.

digits(N) ->
    try
        case (N == 0) of
        true -> throw({return, [0]});
        _ -> ok
    end,
        Rev = [],
        X = N,
        Fun = fun Fun_loop(N, Rev, X) ->
    case (X > 0) of
        true ->
            Rev_2 = lists:append(Rev, [(X rem 10)]),
            X_2 = mochi_to_int((X div 10)),
            Fun_loop(N, Rev_2, X_2);
        _ -> {N, Rev, X}
    end
end,
{N, Rev_2, X_2} = Fun(N, Rev, X),
        Out = [],
        I = (length(Rev_2) - 1),
        Fun_2 = fun Fun_2_loop(I, N, Out, Rev_2, X_2) ->
    case (I >= 0) of
        true ->
            Out_2 = lists:append(Out, [lists:nth(I + 1, Rev_2)]),
            I_2 = (I - 1),
            Fun_2_loop(I_2, N, Out_2, Rev_2, X_2);
        _ -> {I, N, Out, Rev_2, X_2}
    end
end,
{I_2, N, Out_2, Rev_2, X_2} = Fun_2(I, N, Out, Rev_2, X_2),
        Out_2
    catch {return, Ret} -> Ret end.

commatize(N_2) ->
    try
        S = lists:flatten(io_lib:format("~p", [N_2])),
        Out_3 = "",
        I_3 = length(S),
        Fun_3 = fun Fun_3_loop(I_3, N_2, Out_3, S) ->
    case (I_3 > 3) of
        true ->
            Out_4 = (("," ++ string:substr(S, (I_3 - 3) + 1, (I_3 - (I_3 - 3)))) ++ Out_3),
            I_4 = (I_3 - 3),
            Fun_3_loop(I_4, N_2, Out_4, S);
        _ -> {I_3, N_2, Out_3, S}
    end
end,
{I_4, N_2, Out_4, S} = Fun_3(I_3, N_2, Out_3, S),
        Out_5 = (string:substr(S, 0 + 1, (I_4 - 0)) ++ Out_4),
        Out_5
    catch {return, Ret} -> Ret end.

isprime(N_3) ->
    try
        case (N_3 < 2) of
        true -> throw({return, false});
        _ -> ok
    end,
        case ((N_3 rem 2) == 0) of
        true -> throw({return, (N_3 == 2)});
        _ -> ok
    end,
        case ((N_3 rem 3) == 0) of
        true -> throw({return, (N_3 == 3)});
        _ -> ok
    end,
        D = 5,
        Fun_4 = fun Fun_4_loop(D, N_3) ->
    case ((D * D) =< N_3) of
        true ->
            case ((N_3 rem D) == 0) of
        true -> throw({return, false});
        _ -> ok
    end,
            D_2 = (D + 2),
            case ((N_3 rem D_2) == 0) of
        true -> throw({return, false});
        _ -> ok
    end,
            D_3 = (D_2 + 4),
            Fun_4_loop(D_3, N_3);
        _ -> {D, N_3}
    end
end,
{D_3, N_3} = Fun_4(D, N_3),
        true
    catch {return, Ret} -> Ret end.

split(S_2, Sep) ->
    try
        Parts = [],
        Cur = "",
        I_5 = 0,
        Fun_5 = fun Fun_5_loop(Cur, I_5, Parts, S_2, Sep) ->
    case (I_5 < length(S_2)) of
        true ->
            case (((I_5 + length(Sep)) =< length(S_2)) andalso (string:substr(S_2, I_5 + 1, ((I_5 + length(Sep)) - I_5)) == Sep)) of
        true -> Parts_2 = lists:append(Parts, [Cur]),
            Cur_2 = "",
            I_6 = (I_5 + length(Sep)),
            Cur_4 = Cur_2,
            I_8 = I_6,
            Parts_3 = Parts_2;
        _ -> Cur_3 = (Cur ++ string:substr(S_2, I_5 + 1, ((I_5 + 1) - I_5))),
            I_7 = (I_5 + 1),
            Cur_4 = Cur_3,
            I_8 = I_7,
            Parts_3 = Parts
    end,
            Fun_5_loop(Cur_4, I_8, Parts_3, S_2, Sep);
        _ -> {Cur, I_5, Parts, S_2, Sep}
    end
end,
{Cur_4, I_8, Parts_3, S_2, Sep} = Fun_5(Cur, I_5, Parts, S_2, Sep),
        Parts_4 = lists:append(Parts_3, [Cur_4]),
        Parts_4
    catch {return, Ret} -> Ret end.

parseintstr(Str) ->
    try
        I_9 = 0,
        Neg = false,
        case ((length(Str) > 0) andalso (string:substr(Str, 0 + 1, (1 - 0)) == "-")) of
        true -> Neg_2 = true,
            I_10 = 1,
            I_11 = I_10,
            Neg_3 = Neg_2;
        _ -> I_11 = I_9,
            Neg_3 = Neg
    end,
        N_4 = 0,
        Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
        Fun_6 = fun Fun_6_loop(Digits, I_11, N_4, Neg_3, Str) ->
    case (I_11 < length(Str)) of
        true ->
            N_5 = ((N_4 * 10) + lists:nth(string:substr(Str, I_11 + 1, ((I_11 + 1) - I_11)) + 1, fun digits/1)),
            I_12 = (I_11 + 1),
            Fun_6_loop(Digits, I_12, N_5, Neg_3, Str);
        _ -> {Digits, I_11, N_4, Neg_3, Str}
    end
end,
{Digits, I_12, N_5, Neg_3, Str} = Fun_6(Digits, I_11, N_4, Neg_3, Str),
        case Neg_3 of
        true -> N_6 = -N_5,
            N_7 = N_6;
        _ -> N_7 = N_5
    end,
        N_7
    catch {return, Ret} -> Ret end.

reversestr(S_3) ->
    try
        Out_6 = "",
        I_13 = (length(S_3) - 1),
        Fun_7 = fun Fun_7_loop(I_13, Out_6, S_3) ->
    case (I_13 >= 0) of
        true ->
            Out_7 = (Out_6 ++ string:substr(S_3, I_13 + 1, ((I_13 + 1) - I_13))),
            I_14 = (I_13 - 1),
            Fun_7_loop(I_14, Out_7, S_3);
        _ -> {I_13, Out_6, S_3}
    end
end,
{I_14, Out_7, S_3} = Fun_7(I_13, Out_6, S_3),
        Out_7
    catch {return, Ret} -> Ret end.

pad(S_4, W) ->
    try
        Out_8 = S_4,
        Fun_8 = fun Fun_8_loop(Out_8, S_4, W) ->
    case (length(Out_8) < W) of
        true ->
            Out_9 = (" " ++ Out_8),
            Fun_8_loop(Out_9, S_4, W);
        _ -> {Out_8, S_4, W}
    end
end,
{Out_9, S_4, W} = Fun_8(Out_8, S_4, W),
        Out_9
    catch {return, Ret} -> Ret end.

findfirst(List) ->
    try
        I_15 = 0,
        Fun_9 = fun Fun_9_loop(I_15, List) ->
    case (I_15 < length(List)) of
        true ->
            case (lists:nth(I_15 + 1, List) > 10000000) of
        true -> throw({return, [lists:nth(I_15 + 1, List), I_15]});
        _ -> ok
    end,
            I_16 = (I_15 + 1),
            Fun_9_loop(I_16, List);
        _ -> {I_15, List}
    end
end,
{I_16, List} = Fun_9(I_15, List),
        [-1, -1]
    catch {return, Ret} -> Ret end.

main() ->
    try
        Ranges = [[0, 0], [101, 909], [11011, 99099], [1110111, 9990999], [111101111, 119101111]],
        Cyclops = [],
        Fun_10 = fun Fun_10_loop(List, Cyclops, Ranges) ->
    case List of
        [] -> {Cyclops, Ranges};
        [R|R_rest] ->
            Start = lists:nth(0 + 1, R),
            End = lists:nth(1 + 1, R),
            NumDigits = length(lists:flatten(io_lib:format("~p", [Start]))),
            Center = (NumDigits div 2),
            I_17 = Start,
            Fun_13 = fun Fun_13_loop(Center, Cyclops, End, I_17, NumDigits, R, Ranges, Start) ->
    case (I_17 =< End) of
        true ->
            Ds = digits(I_17),
            case (lists:nth(Center + 1, Ds) == 0) of
        true -> Count = 0,
            Fun_11 = fun Fun_11_loop(List, Center, Count, Cyclops, Ds, End, I_17, NumDigits, R, Ranges, Start) ->
    case List of
        [] -> {Center, Count, Cyclops, Ds, End, I_17, NumDigits, R, Ranges, Start};
        [D_4|D_4_rest] ->
            case (D_4 == 0) of
        true -> Count_2 = (Count + 1),
            Count_3 = Count_2;
        _ -> Count_3 = Count
    end,
            Fun_11_loop(D_4_rest, Center, Count_3, Cyclops, Ds, End, I_17, NumDigits, R, Ranges, Start)
    end
end,
{Center, Count_3, Cyclops, Ds, End, I_17, NumDigits, R, Ranges, Start} = Fun_11(Ds, Center, Count, Cyclops, Ds, End, I_17, NumDigits, R, Ranges, Start),
            case (Count_3 == 1) of
        true -> Cyclops_2 = lists:append(Cyclops, [I_17]),
            Cyclops_3 = Cyclops_2;
        _ -> Cyclops_3 = Cyclops
    end,
            Count_4 = Count_3,
            Cyclops_4 = Cyclops_3,
            Fun_12 = Fun_11;
        _ -> Count_4 = nil,
            Cyclops_4 = Cyclops,
            Fun_12 = nil
    end,
            I_18 = (I_17 + 1),
            Fun_13_loop(Center, Cyclops_4, End, I_18, NumDigits, R, Ranges, Start);
        _ -> {Center, Cyclops, End, I_17, NumDigits, R, Ranges, Start}
    end
end,
{Center, Cyclops_4, End, I_18, NumDigits, R, Ranges, Start} = Fun_13(Center, Cyclops, End, I_17, NumDigits, R, Ranges, Start),
            Fun_10_loop(R_rest, Cyclops_4, Ranges)
    end
end,
{Cyclops_4, Ranges} = Fun_10(Ranges, Cyclops, Ranges),
        io:format("~ts~n", ["The first 50 cyclops numbers are:"]),
        Idx = 0,
        Fun_14 = fun Fun_14_loop(Cyclops_4, Idx, Ranges) ->
    case (Idx < 50) of
        true ->
            io:format("~ts~n", [(pad(commatize(lists:nth(Idx + 1, Cyclops_4)), 6) ++ " ")]),
            Idx_2 = (Idx + 1),
            case ((Idx_2 rem 10) == 0) of
        true -> io:format("~ts~n", ["\n"]);
        _ -> ok
    end,
            Fun_14_loop(Cyclops_4, Idx_2, Ranges);
        _ -> {Cyclops_4, Idx, Ranges}
    end
end,
{Cyclops_4, Idx_2, Ranges} = Fun_14(Cyclops_4, Idx, Ranges),
        Fi = findfirst(Cyclops_4),
        io:format("~ts~n", [((("\nFirst such number > 10 million is " ++ commatize(lists:nth(0 + 1, Fi))) ++ " at zero-based index ") ++ commatize(lists:nth(1 + 1, Fi)))]),
        Primes = [],
        Fun_15 = fun Fun_15_loop(List, Cyclops_4, Fi, Idx_2, Primes, Ranges) ->
    case List of
        [] -> {Cyclops_4, Fi, Idx_2, Primes, Ranges};
        [N_8|N_8_rest] ->
            case (isprime(N_8) /= nil) of
        true -> Primes_2 = lists:append(Primes, [N_8]),
            Primes_3 = Primes_2;
        _ -> Primes_3 = Primes
    end,
            Fun_15_loop(N_8_rest, Cyclops_4, Fi, Idx_2, Primes_3, Ranges)
    end
end,
{Cyclops_4, Fi, Idx_2, Primes_3, Ranges} = Fun_15(Cyclops_4, Cyclops_4, Fi, Idx_2, Primes, Ranges),
        io:format("~ts~n", ["\n\nThe first 50 prime cyclops numbers are:"]),
        Idx_3 = 0,
        Fun_16 = fun Fun_16_loop(Cyclops_4, Fi, Idx_3, Primes_3, Ranges) ->
    case (Idx_3 < 50) of
        true ->
            io:format("~ts~n", [(pad(commatize(lists:nth(Idx_3 + 1, Primes_3)), 6) ++ " ")]),
            Idx_4 = (Idx_3 + 1),
            case ((Idx_4 rem 10) == 0) of
        true -> io:format("~ts~n", ["\n"]);
        _ -> ok
    end,
            Fun_16_loop(Cyclops_4, Fi, Idx_4, Primes_3, Ranges);
        _ -> {Cyclops_4, Fi, Idx_3, Primes_3, Ranges}
    end
end,
{Cyclops_4, Fi, Idx_4, Primes_3, Ranges} = Fun_16(Cyclops_4, Fi, Idx_3, Primes_3, Ranges),
        Fp = findfirst(Primes_3),
        io:format("~ts~n", [((("\nFirst such number > 10 million is " ++ commatize(lists:nth(0 + 1, Fp))) ++ " at zero-based index ") ++ commatize(lists:nth(1 + 1, Fp)))]),
        Bpcyclops = [],
        Ppcyclops = [],
        Fun_17 = fun Fun_17_loop(List, Bpcyclops, Cyclops_4, Fi, Fp, Idx_4, Ppcyclops, Primes_3, Ranges) ->
    case List of
        [] -> {Bpcyclops, Cyclops_4, Fi, Fp, Idx_4, Ppcyclops, Primes_3, Ranges};
        [P|P_rest] ->
            Ps = lists:flatten(io_lib:format("~p", [P])),
            Splitp = string:tokens(Ps, "0"),
            NoMiddle = mochi_parse_int_str((string:substr(Splitp, 0 + 1, 1) ++ string:substr(Splitp, 1 + 1, 1))),
            case (isprime(NoMiddle) /= nil) of
        true -> Bpcyclops_2 = lists:append(Bpcyclops, [P]),
            Bpcyclops_3 = Bpcyclops_2;
        _ -> Bpcyclops_3 = Bpcyclops
    end,
            case (Ps == reversestr(Ps)) of
        true -> Ppcyclops_2 = lists:append(Ppcyclops, [P]),
            Ppcyclops_3 = Ppcyclops_2;
        _ -> Ppcyclops_3 = Ppcyclops
    end,
            Fun_17_loop(P_rest, Bpcyclops_3, Cyclops_4, Fi, Fp, Idx_4, Ppcyclops_3, Primes_3, Ranges)
    end
end,
{Bpcyclops_3, Cyclops_4, Fi, Fp, Idx_4, Ppcyclops_3, Primes_3, Ranges} = Fun_17(Primes_3, Bpcyclops, Cyclops_4, Fi, Fp, Idx_4, Ppcyclops, Primes_3, Ranges),
        io:format("~ts~n", ["\n\nThe first 50 blind prime cyclops numbers are:"]),
        Idx_5 = 0,
        Fun_18 = fun Fun_18_loop(Bpcyclops_3, Cyclops_4, Fi, Fp, Idx_5, Ppcyclops_3, Primes_3, Ranges) ->
    case (Idx_5 < 50) of
        true ->
            io:format("~ts~n", [(pad(commatize(lists:nth(Idx_5 + 1, Bpcyclops_3)), 6) ++ " ")]),
            Idx_6 = (Idx_5 + 1),
            case ((Idx_6 rem 10) == 0) of
        true -> io:format("~ts~n", ["\n"]);
        _ -> ok
    end,
            Fun_18_loop(Bpcyclops_3, Cyclops_4, Fi, Fp, Idx_6, Ppcyclops_3, Primes_3, Ranges);
        _ -> {Bpcyclops_3, Cyclops_4, Fi, Fp, Idx_5, Ppcyclops_3, Primes_3, Ranges}
    end
end,
{Bpcyclops_3, Cyclops_4, Fi, Fp, Idx_6, Ppcyclops_3, Primes_3, Ranges} = Fun_18(Bpcyclops_3, Cyclops_4, Fi, Fp, Idx_5, Ppcyclops_3, Primes_3, Ranges),
        Fb = findfirst(Bpcyclops_3),
        io:format("~ts~n", [((("\nFirst such number > 10 million is " ++ commatize(lists:nth(0 + 1, Fb))) ++ " at zero-based index ") ++ commatize(lists:nth(1 + 1, Fb)))]),
        io:format("~ts~n", ["\n\nThe first 50 palindromic prime cyclops numbers are:"]),
        Idx_7 = 0,
        Fun_19 = fun Fun_19_loop(Bpcyclops_3, Cyclops_4, Fb, Fi, Fp, Idx_7, Ppcyclops_3, Primes_3, Ranges) ->
    case (Idx_7 < 50) of
        true ->
            io:format("~ts~n", [(pad(commatize(lists:nth(Idx_7 + 1, Ppcyclops_3)), 9) ++ " ")]),
            Idx_8 = (Idx_7 + 1),
            case ((Idx_8 rem 8) == 0) of
        true -> io:format("~ts~n", ["\n"]);
        _ -> ok
    end,
            Fun_19_loop(Bpcyclops_3, Cyclops_4, Fb, Fi, Fp, Idx_8, Ppcyclops_3, Primes_3, Ranges);
        _ -> {Bpcyclops_3, Cyclops_4, Fb, Fi, Fp, Idx_7, Ppcyclops_3, Primes_3, Ranges}
    end
end,
{Bpcyclops_3, Cyclops_4, Fb, Fi, Fp, Idx_8, Ppcyclops_3, Primes_3, Ranges} = Fun_19(Bpcyclops_3, Cyclops_4, Fb, Fi, Fp, Idx_7, Ppcyclops_3, Primes_3, Ranges),
        Fpp = findfirst(Ppcyclops_3),
        io:format("~ts~n", [((("\n\nFirst such number > 10 million is " ++ commatize(lists:nth(0 + 1, Fpp))) ++ " at zero-based index ") ++ commatize(lists:nth(1 + 1, Fpp)))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
