#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, node/4, treeString/1, balance/1, ins/2, insert/2]).

% Generated by Mochi transpiler v0.10.39 (d7fdfd3bc3) on 2025-07-24 14:18 UTC

node(Cl, Le, Aa, Ri) ->
    try
        #{"cl" => Cl, "le" => Le, "aa" => Aa, "ri" => Ri}
    catch {return, Ret} -> Ret end.

treeString(T) ->
    try
        case (T == nil) of
        true -> throw({return, "E"});
        _ -> ok
    end,
        M = T,
        (((((((("T(" ++ maps:get("cl", M)) ++ ", ") ++ treeString(maps:get("le", M))) ++ ", ") ++ lists:flatten(io_lib:format("~p", [maps:get("aa", M)]))) ++ ", ") ++ treeString(maps:get("ri", M))) ++ ")")
    catch {return, Ret} -> Ret end.

balance(T_2) ->
    try
        case (T_2 == nil) of
        true -> throw({return, T_2});
        _ -> ok
    end,
        M_2 = T_2,
        case (maps:get("cl", M_2) /= "B") of
        true -> throw({return, T_2});
        _ -> ok
    end,
        Le_2 = maps:get("le", M_2),
        Ri_2 = maps:get("ri", M_2),
        case (Le_2 /= nil) of
        true -> LeMap = Le_2,
            case (maps:get("cl", LeMap) == "R") of
        true -> Lele = maps:get("le", LeMap),
            case (Lele /= nil) of
        true -> LeleMap = Lele,
            case (maps:get("cl", LeleMap) == "R") of
        true -> throw({return, node("R", node("B", maps:get("le", LeleMap), maps:get("aa", LeleMap), maps:get("ri", LeleMap)), maps:get("aa", LeMap), node("B", maps:get("ri", LeMap), maps:get("aa", M_2), Ri_2))});
        _ -> ok
    end,
            LeleMap_2 = LeleMap;
        _ -> LeleMap_2 = nil
    end,
            Leri = maps:get("ri", LeMap),
            case (Leri /= nil) of
        true -> LeriMap = Leri,
            case (maps:get("cl", LeriMap) == "R") of
        true -> throw({return, node("R", node("B", maps:get("le", LeMap), maps:get("aa", LeMap), maps:get("le", LeriMap)), maps:get("aa", LeriMap), node("B", maps:get("ri", LeriMap), maps:get("aa", M_2), Ri_2))});
        _ -> ok
    end,
            LeriMap_2 = LeriMap;
        _ -> LeriMap_2 = nil
    end,
            Lele_2 = Lele,
            LeleMap_3 = LeleMap_2,
            Leri_2 = Leri,
            LeriMap_3 = LeriMap_2;
        _ -> Lele_2 = nil,
            LeleMap_3 = nil,
            Leri_2 = nil,
            LeriMap_3 = nil
    end,
            LeMap_2 = LeMap,
            Lele_3 = Lele_2,
            LeleMap_4 = LeleMap_3,
            Leri_3 = Leri_2,
            LeriMap_4 = LeriMap_3;
        _ -> LeMap_2 = nil,
            Lele_3 = nil,
            LeleMap_4 = nil,
            Leri_3 = nil,
            LeriMap_4 = nil
    end,
        case (Ri_2 /= nil) of
        true -> RiMap = Ri_2,
            case (maps:get("cl", RiMap) == "R") of
        true -> Rile = maps:get("le", RiMap),
            case (Rile /= nil) of
        true -> RileMap = Rile,
            case (maps:get("cl", RileMap) == "R") of
        true -> throw({return, node("R", node("B", maps:get("le", M_2), maps:get("aa", M_2), maps:get("le", RileMap)), maps:get("aa", RileMap), node("B", maps:get("ri", RileMap), maps:get("aa", RiMap), maps:get("ri", RiMap)))});
        _ -> ok
    end,
            RileMap_2 = RileMap;
        _ -> RileMap_2 = nil
    end,
            Riri = maps:get("ri", RiMap),
            case (Riri /= nil) of
        true -> RiriMap = Riri,
            case (maps:get("cl", RiriMap) == "R") of
        true -> throw({return, node("R", node("B", maps:get("le", M_2), maps:get("aa", M_2), maps:get("le", RiMap)), maps:get("aa", RiMap), node("B", maps:get("le", RiriMap), maps:get("aa", RiriMap), maps:get("ri", RiriMap)))});
        _ -> ok
    end,
            RiriMap_2 = RiriMap;
        _ -> RiriMap_2 = nil
    end,
            Rile_2 = Rile,
            RileMap_3 = RileMap_2,
            Riri_2 = Riri,
            RiriMap_3 = RiriMap_2;
        _ -> Rile_2 = nil,
            RileMap_3 = nil,
            Riri_2 = nil,
            RiriMap_3 = nil
    end,
            RiMap_2 = RiMap,
            Rile_3 = Rile_2,
            RileMap_4 = RileMap_3,
            Riri_3 = Riri_2,
            RiriMap_4 = RiriMap_3;
        _ -> RiMap_2 = nil,
            Rile_3 = nil,
            RileMap_4 = nil,
            Riri_3 = nil,
            RiriMap_4 = nil
    end,
        T_2
    catch {return, Ret} -> Ret end.

ins(Tr, X) ->
    try
        case (Tr == nil) of
        true -> throw({return, node("R", nil, X, nil)});
        _ -> ok
    end,
        case (X < maps:get("aa", Tr)) of
        true -> throw({return, balance(node(maps:get("cl", Tr), ins(maps:get("le", Tr), X), maps:get("aa", Tr), maps:get("ri", Tr)))});
        _ -> ok
    end,
        case (X > maps:get("aa", Tr)) of
        true -> throw({return, balance(node(maps:get("cl", Tr), maps:get("le", Tr), maps:get("aa", Tr), ins(maps:get("ri", Tr), X)))});
        _ -> ok
    end,
        Tr
    catch {return, Ret} -> Ret end.

insert(Tr_2, X_2) ->
    try
        T_3 = ins(Tr_2, X_2),
        case (T_3 == nil) of
        true -> throw({return, nil});
        _ -> ok
    end,
        M_3 = T_3,
        node("B", maps:get("le", M_3), maps:get("aa", M_3), maps:get("ri", M_3))
    catch {return, Ret} -> Ret end.

main(_) ->
    erlang:put('tr', nil),
    erlang:put('i', 1),
    Fun = fun Fun_loop() ->
    case (erlang:get('i') =< 16) of
        true ->
            erlang:put('tr', insert(erlang:get('tr'), erlang:get('i'))),
            erlang:put('i', (erlang:get('i') + 1)),
            Fun_loop();
        _ -> {}
    end
end,
{} = Fun(),
    io:format("~p~n", [treeString(erlang:get('tr'))]).
