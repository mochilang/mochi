#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, node/4, treestring/1, balance/1, ins/2, insert/2]).

% Generated by Mochi transpiler v0.10.40 (029b538ca5) on 2025-07-25 15:20 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

node(Cl, Le, Aa, Ri) ->
    try
        #{"cl" => Cl, "le" => Le, "aa" => Aa, "ri" => Ri}
    catch {return, Ret} -> Ret end.

treestring(T) ->
    try
        case (T == nil) of
        true -> throw({return, "E"});
        _ -> ok
    end,
        M = T,
        (((((((("T(" ++ maps:get("cl", M, nil)) ++ ", ") ++ treestring(maps:get("le", M, nil))) ++ ", ") ++ lists:flatten(io_lib:format("~p", [maps:get("aa", M, nil)]))) ++ ", ") ++ treestring(maps:get("ri", M, nil))) ++ ")")
    catch {return, Ret} -> Ret end.

balance(T_2) ->
    try
        case (T_2 == nil) of
        true -> throw({return, T_2});
        _ -> ok
    end,
        M_2 = T_2,
        case (maps:get("cl", M_2, nil) /= "B") of
        true -> throw({return, T_2});
        _ -> ok
    end,
        Le_2 = maps:get("le", M_2, nil),
        Ri_2 = maps:get("ri", M_2, nil),
        case (Le_2 /= nil) of
        true -> LeMap = Le_2,
            case (maps:get("cl", LeMap, nil) == "R") of
        true -> Lele = maps:get("le", LeMap, nil),
            case (Lele /= nil) of
        true -> LeleMap = Lele,
            case (maps:get("cl", LeleMap, nil) == "R") of
        true -> throw({return, node("R", node("B", maps:get("le", LeleMap, nil), maps:get("aa", LeleMap, nil), maps:get("ri", LeleMap, nil)), maps:get("aa", LeMap, nil), node("B", maps:get("ri", LeMap, nil), maps:get("aa", M_2, nil), Ri_2))});
        _ -> ok
    end,
            LeleMap_2 = LeleMap;
        _ -> LeleMap_2 = nil
    end,
            Leri = maps:get("ri", LeMap, nil),
            case (Leri /= nil) of
        true -> LeriMap = Leri,
            case (maps:get("cl", LeriMap, nil) == "R") of
        true -> throw({return, node("R", node("B", maps:get("le", LeMap, nil), maps:get("aa", LeMap, nil), maps:get("le", LeriMap, nil)), maps:get("aa", LeriMap, nil), node("B", maps:get("ri", LeriMap, nil), maps:get("aa", M_2, nil), Ri_2))});
        _ -> ok
    end,
            LeriMap_2 = LeriMap;
        _ -> LeriMap_2 = nil
    end,
            Lele_2 = Lele,
            LeleMap_3 = LeleMap_2,
            Leri_2 = Leri,
            LeriMap_3 = LeriMap_2;
        _ -> Lele_2 = nil,
            LeleMap_3 = nil,
            Leri_2 = nil,
            LeriMap_3 = nil
    end,
            LeMap_2 = LeMap,
            Lele_3 = Lele_2,
            LeleMap_4 = LeleMap_3,
            Leri_3 = Leri_2,
            LeriMap_4 = LeriMap_3;
        _ -> LeMap_2 = nil,
            Lele_3 = nil,
            LeleMap_4 = nil,
            Leri_3 = nil,
            LeriMap_4 = nil
    end,
        case (Ri_2 /= nil) of
        true -> RiMap = Ri_2,
            case (maps:get("cl", RiMap, nil) == "R") of
        true -> Rile = maps:get("le", RiMap, nil),
            case (Rile /= nil) of
        true -> RileMap = Rile,
            case (maps:get("cl", RileMap, nil) == "R") of
        true -> throw({return, node("R", node("B", maps:get("le", M_2, nil), maps:get("aa", M_2, nil), maps:get("le", RileMap, nil)), maps:get("aa", RileMap, nil), node("B", maps:get("ri", RileMap, nil), maps:get("aa", RiMap, nil), maps:get("ri", RiMap, nil)))});
        _ -> ok
    end,
            RileMap_2 = RileMap;
        _ -> RileMap_2 = nil
    end,
            Riri = maps:get("ri", RiMap, nil),
            case (Riri /= nil) of
        true -> RiriMap = Riri,
            case (maps:get("cl", RiriMap, nil) == "R") of
        true -> throw({return, node("R", node("B", maps:get("le", M_2, nil), maps:get("aa", M_2, nil), maps:get("le", RiMap, nil)), maps:get("aa", RiMap, nil), node("B", maps:get("le", RiriMap, nil), maps:get("aa", RiriMap, nil), maps:get("ri", RiriMap, nil)))});
        _ -> ok
    end,
            RiriMap_2 = RiriMap;
        _ -> RiriMap_2 = nil
    end,
            Rile_2 = Rile,
            RileMap_3 = RileMap_2,
            Riri_2 = Riri,
            RiriMap_3 = RiriMap_2;
        _ -> Rile_2 = nil,
            RileMap_3 = nil,
            Riri_2 = nil,
            RiriMap_3 = nil
    end,
            RiMap_2 = RiMap,
            Rile_3 = Rile_2,
            RileMap_4 = RileMap_3,
            Riri_3 = Riri_2,
            RiriMap_4 = RiriMap_3;
        _ -> RiMap_2 = nil,
            Rile_3 = nil,
            RileMap_4 = nil,
            Riri_3 = nil,
            RiriMap_4 = nil
    end,
        T_2
    catch {return, Ret} -> Ret end.

ins(Tr, X) ->
    try
        case (Tr == nil) of
        true -> throw({return, node("R", nil, X, nil)});
        _ -> ok
    end,
        case (X < maps:get("aa", Tr, nil)) of
        true -> throw({return, balance(node(maps:get("cl", Tr, nil), ins(maps:get("le", Tr, nil), X), maps:get("aa", Tr, nil), maps:get("ri", Tr, nil)))});
        _ -> ok
    end,
        case (X > maps:get("aa", Tr, nil)) of
        true -> throw({return, balance(node(maps:get("cl", Tr, nil), maps:get("le", Tr, nil), maps:get("aa", Tr, nil), ins(maps:get("ri", Tr, nil), X)))});
        _ -> ok
    end,
        Tr
    catch {return, Ret} -> Ret end.

insert(Tr_2, X_2) ->
    try
        T_3 = ins(Tr_2, X_2),
        case (T_3 == nil) of
        true -> throw({return, nil});
        _ -> ok
    end,
        M_3 = T_3,
        node("B", maps:get("le", M_3, nil), maps:get("aa", M_3, nil), maps:get("ri", M_3, nil))
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('tr', nil),
    erlang:put('i', 1),
    Fun = fun Fun_loop() ->
    case (erlang:get('i') =< 16) of
        true ->
            erlang:put('tr', insert(erlang:get('tr'), erlang:get('i'))),
            erlang:put('i', (erlang:get('i') + 1)),
            Fun_loop();
        _ -> {}
    end
end,
{} = Fun(),
    io:format("~p~n", [treestring(erlang:get('tr'))]),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
