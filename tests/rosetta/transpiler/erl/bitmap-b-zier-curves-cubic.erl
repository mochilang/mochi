#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pixelfromrgb/1, newbitmap/2, setpx/4, fill/2, fillrgb/2, line/6, bezier3/10]).

% Generated by Mochi transpiler v0.10.40 (076c2fc56d) on 2025-07-25 17:01 +0700


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_pad_start(S, Len, Ch) ->
    Fill0 = case Ch of
        "" -> " ";
        _ -> Ch
    end,
    Fill = string:substr(Fill0, 1, 1),
    SL = length(S),
    case SL >= Len of
        true -> S;
        _ -> string:copies(Fill, Len - SL) ++ S
    end.

pixelfromrgb(Rgb) ->
    try
        R = mochi_to_int(((Rgb div 65536) rem 256)),
        G = mochi_to_int(((Rgb div 256) rem 256)),
        B = mochi_to_int((Rgb rem 256)),
        #{"r" => R, "g" => G, "b" => B}
    catch {return, Ret} -> Ret end.

newbitmap(Cols, Rows) ->
    try
        D = [],
        Y = 0,
        Fun_2 = fun Fun_2_loop(Cols, D, Rows, Y) ->
    case (Y < Rows) of
        true ->
            Row = [],
            X = 0,
            Fun = fun Fun_loop(Cols, D, Row, Rows, X, Y) ->
    case (X < Cols) of
        true ->
            Row_2 = lists:append(Row, [#{"r" => 0, "g" => 0, "b" => 0}]),
            X_2 = (X + 1),
            Fun_loop(Cols, D, Row_2, Rows, X_2, Y);
        _ -> {Cols, D, Row, Rows, X, Y}
    end
end,
{Cols, D, Row_2, Rows, X_2, Y} = Fun(Cols, D, Row, Rows, X, Y),
            D_2 = lists:append(D, [Row_2]),
            Y_2 = (Y + 1),
            Fun_2_loop(Cols, D_2, Rows, Y_2);
        _ -> {Cols, D, Rows, Y}
    end
end,
{Cols, D_2, Rows, Y_2} = Fun_2(Cols, D, Rows, Y),
        #{"cols" => Cols, "rows" => Rows, "data" => D_2}
    catch {return, Ret} -> Ret end.

setpx(B_2, X_3, Y_3, P) ->
    try
        Cols_2 = mochi_to_int(maps:get("cols", B_2, nil)),
        Rows_2 = mochi_to_int(maps:get("rows", B_2, nil)),
        case ((((X_3 >= 0) andalso (X_3 < Cols_2)) andalso (Y_3 >= 0)) andalso (Y_3 < Rows_2)) of
        true -> Tmp = maps:get("data", B_2, nil),
            Tmp_2 = lists:nth(Y_3 + 1, Tmp),
            Tmp_3 = lists:sublist(Tmp_2, X_3) ++ [P] ++ lists:nthtail(X_3 + 1, Tmp_2),
            Tmp_2 = lists:sublist(Tmp, Y_3) ++ [Tmp_3] ++ lists:nthtail(Y_3 + 1, Tmp),
            B_3 = maps:put("data", Tmp_2, B_2),
            B_4 = B_3,
            Tmp_4 = Tmp_3;
        _ -> B_4 = B_2,
            Tmp_4 = nil
    end,
        nil
    catch {return, Ret} -> Ret end.

fill(B_5, P_2) ->
    try
        Cols_3 = mochi_to_int(maps:get("cols", B_5, nil)),
        Rows_3 = mochi_to_int(maps:get("rows", B_5, nil)),
        Y_4 = 0,
        Fun_4 = fun Fun_4_loop(B_5, Cols_3, P_2, Rows_3, Y_4) ->
    case (Y_4 < Rows_3) of
        true ->
            X_4 = 0,
            Fun_3 = fun Fun_3_loop(B_5, Cols_3, P_2, Rows_3, X_4, Y_4) ->
    case (X_4 < Cols_3) of
        true ->
            Tmp_5 = maps:get("data", B_5, nil),
            Tmp_6 = lists:nth(Y_4 + 1, Tmp_5),
            Tmp_7 = lists:sublist(Tmp_6, X_4) ++ [P_2] ++ lists:nthtail(X_4 + 1, Tmp_6),
            Tmp_6 = lists:sublist(Tmp_5, Y_4) ++ [Tmp_7] ++ lists:nthtail(Y_4 + 1, Tmp_5),
            B_6 = maps:put("data", Tmp_6, B_5),
            X_5 = (X_4 + 1),
            Fun_3_loop(B_6, Cols_3, P_2, Rows_3, X_5, Y_4);
        _ -> {B_5, Cols_3, P_2, Rows_3, X_4, Y_4}
    end
end,
{B_6, Cols_3, P_2, Rows_3, X_5, Y_4} = Fun_3(B_5, Cols_3, P_2, Rows_3, X_4, Y_4),
            Y_5 = (Y_4 + 1),
            Fun_4_loop(B_6, Cols_3, P_2, Rows_3, Y_5);
        _ -> {B_5, Cols_3, P_2, Rows_3, Y_4}
    end
end,
{B_6, Cols_3, P_2, Rows_3, Y_5} = Fun_4(B_5, Cols_3, P_2, Rows_3, Y_4),
        B_6
    catch {return, Ret} -> Ret end.

fillrgb(B_7, Rgb_2) ->
    try
        B_7 = fill(B_7, pixelfromrgb(Rgb_2)),
        nil
    catch {return, Ret} -> Ret end.

line(B_8, X0, Y0, X1, Y1, P_3) ->
    try
        Dx = (X1 - X0),
        case (Dx < 0) of
        true -> Dx_2 = -Dx,
            Dx_3 = Dx_2;
        _ -> Dx_3 = Dx
    end,
        Dy = (Y1 - Y0),
        case (Dy < 0) of
        true -> Dy_2 = -Dy,
            Dy_3 = Dy_2;
        _ -> Dy_3 = Dy
    end,
        Sx = -1,
        case (X0 < X1) of
        true -> Sx_2 = 1,
            Sx_3 = Sx_2;
        _ -> Sx_3 = Sx
    end,
        Sy = -1,
        case (Y0 < Y1) of
        true -> Sy_2 = 1,
            Sy_3 = Sy_2;
        _ -> Sy_3 = Sy
    end,
        Err = (Dx_3 - Dy_3),
        Fun_5 = fun Fun_5_loop(B_8, Dx_3, Dy_3, Err, P_3, Sx_3, Sy_3, X0, X1, Y0, Y1) ->
    case true of
        true ->
            try
                setpx(B_8, X0, Y0, P_3),
                case ((X0 == X1) andalso (Y0 == Y1)) of
        true -> throw(break);
        _ -> ok
    end,
                E2 = (2 * Err),
                case (E2 > (0 - Dy_3)) of
        true -> Err_2 = (Err - Dy_3),
            X0_2 = (X0 + Sx_3),
            Err_3 = Err_2,
            X0_3 = X0_2;
        _ -> Err_3 = Err,
            X0_3 = X0
    end,
                case (E2 < Dx_3) of
        true -> Err_4 = (Err_3 + Dx_3),
            Y0_2 = (Y0 + Sy_3),
            Err_5 = Err_4,
            Y0_3 = Y0_2;
        _ -> Err_5 = Err_3,
            Y0_3 = Y0
    end,
                Fun_5_loop(B_8, Dx_3, Dy_3, Err_5, P_3, Sx_3, Sy_3, X0_3, X1, Y0_3, Y1)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10} -> Fun_5_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10);
                break -> {B_8, Dx_3, Dy_3, Err, P_3, Sx_3, Sy_3, X0, X1, Y0, Y1}
            end;
        _ -> {B_8, Dx_3, Dy_3, Err, P_3, Sx_3, Sy_3, X0, X1, Y0, Y1}
    end
end,
{B_8, Dx_3, Dy_3, Err_5, P_3, Sx_3, Sy_3, X0_3, X1, Y0_3, Y1} = Fun_5(B_8, Dx_3, Dy_3, Err, P_3, Sx_3, Sy_3, X0, X1, Y0, Y1),
        nil
    catch {return, Ret} -> Ret end.

bezier3(B_9, X1_2, Y1_2, X2, Y2, X3, Y3, X4, Y4, P_4) ->
    try
        Px = [],
        Py = [],
        I = 0,
        Fun_6 = fun Fun_6_loop(B_9, I, P_4, Px, Py, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4) ->
    case (I =< 30) of
        true ->
            Px_2 = lists:append(Px, [0]),
            Py_2 = lists:append(Py, [0]),
            I_2 = (I + 1),
            Fun_6_loop(B_9, I_2, P_4, Px_2, Py_2, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4);
        _ -> {B_9, I, P_4, Px, Py, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4}
    end
end,
{B_9, I_2, P_4, Px_2, Py_2, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4} = Fun_6(B_9, I, P_4, Px, Py, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4),
        Fx1 = float(X1_2),
        Fy1 = float(Y1_2),
        Fx2 = float(X2),
        Fy2 = float(Y2),
        Fx3 = float(X3),
        Fy3 = float(Y3),
        Fx4 = float(X4),
        Fy4 = float(Y4),
        I_3 = 0,
        Fun_7 = fun Fun_7_loop(B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_3, P_4, Px_2, Py_2, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4) ->
    case (I_3 =< 30) of
        true ->
            D_3 = (float(I_3) / float(30)),
            A = (1 - D_3),
            Bcoef = (A * A),
            Ccoef = (D_3 * D_3),
            A2 = (A * Bcoef),
            B2 = ((3 * Bcoef) * D_3),
            C2 = ((3 * A) * Ccoef),
            D2 = (Ccoef * D_3),
            Px_3 = lists:sublist(Px_2, I_3) ++ [mochi_to_int(((((A2 * Fx1) + (B2 * Fx2)) + (C2 * Fx3)) + (D2 * Fx4)))] ++ lists:nthtail(I_3 + 1, Px_2),
            Py_3 = lists:sublist(Py_2, I_3) ++ [mochi_to_int(((((A2 * Fy1) + (B2 * Fy2)) + (C2 * Fy3)) + (D2 * Fy4)))] ++ lists:nthtail(I_3 + 1, Py_2),
            I_4 = (I_3 + 1),
            Fun_7_loop(B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_4, P_4, Px_3, Py_3, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4);
        _ -> {B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_3, P_4, Px_2, Py_2, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4}
    end
end,
{B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_4, P_4, Px_3, Py_3, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4} = Fun_7(B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_3, P_4, Px_2, Py_2, X1_2, X2, X3, X4, Y1_2, Y2, Y3, Y4),
        X0_4 = lists:nth(0 + 1, Px_3),
        Y0_4 = lists:nth(0 + 1, Py_3),
        I_5 = 1,
        Fun_8 = fun Fun_8_loop(B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_5, P_4, Px_3, Py_3, X0_4, X1_2, X2, X3, X4, Y0_4, Y1_2, Y2, Y3, Y4) ->
    case (I_5 =< 30) of
        true ->
            X_6 = lists:nth(I_5 + 1, Px_3),
            Y_6 = lists:nth(I_5 + 1, Py_3),
            line(B_9, X0_4, Y0_4, X_6, Y_6, P_4),
            X0_5 = X_6,
            Y0_5 = Y_6,
            I_6 = (I_5 + 1),
            Fun_8_loop(B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_6, P_4, Px_3, Py_3, X0_5, X1_2, X2, X3, X4, Y0_5, Y1_2, Y2, Y3, Y4);
        _ -> {B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_5, P_4, Px_3, Py_3, X0_4, X1_2, X2, X3, X4, Y0_4, Y1_2, Y2, Y3, Y4}
    end
end,
{B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_6, P_4, Px_3, Py_3, X0_5, X1_2, X2, X3, X4, Y0_5, Y1_2, Y2, Y3, Y4} = Fun_8(B_9, Fx1, Fx2, Fx3, Fx4, Fy1, Fy2, Fy3, Fy4, I_5, P_4, Px_3, Py_3, X0_4, X1_2, X2, X3, X4, Y0_4, Y1_2, Y2, Y3, Y4),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    erlang:put('b3Seg', 30),
    erlang:put('b', newbitmap(400, 300)),
    fillrgb(erlang:get('b'), 16773055),
    bezier3(erlang:get('b'), 20, 200, 700, 50, -300, 50, 380, 150, pixelfromrgb(4165615)).
