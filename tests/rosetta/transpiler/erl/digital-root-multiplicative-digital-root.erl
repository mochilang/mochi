#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pad/2, mult/2, multdigitalroot/2, main/0]).

% Generated by Mochi transpiler v0.10.42 (cb76045201) on 2025-07-27 10:24 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

pad(S, Width) ->
    try
        Out = S,
        Fun = fun Fun_loop(Out, S, Width) ->
    case (length(Out) < Width) of
        true ->
            Out_2 = (" " ++ Out),
            Fun_loop(Out_2, S, Width);
        _ -> {Out, S, Width}
    end
end,
{Out_2, S, Width} = Fun(Out, S, Width),
        Out_2
    catch {return, Ret} -> Ret end.

mult(N, Base) ->
    try
        M = 1,
        X = N,
        B = Base,
        Fun_2 = fun Fun_2_loop(B, Base, M, N, X) ->
    case (X > 0) of
        true ->
            M_2 = (M * (X rem B)),
            X_2 = (X div B),
            Fun_2_loop(B, Base, M_2, N, X_2);
        _ -> {B, Base, M, N, X}
    end
end,
{B, Base, M_2, N, X_2} = Fun_2(B, Base, M, N, X),
        M_2
    catch {return, Ret} -> Ret end.

multdigitalroot(N_2, Base_2) ->
    try
        M_3 = N_2,
        Mp = 0,
        B_2 = Base_2,
        Fun_3 = fun Fun_3_loop(B_2, Base_2, M_3, Mp, N_2) ->
    case (M_3 >= B_2) of
        true ->
            M_4 = mult(M_3, Base_2),
            Mp_2 = (Mp + 1),
            Fun_3_loop(B_2, Base_2, M_4, Mp_2, N_2);
        _ -> {B_2, Base_2, M_3, Mp, N_2}
    end
end,
{B_2, Base_2, M_4, Mp_2, N_2} = Fun_3(B_2, Base_2, M_3, Mp, N_2),
        #{"mp" => Mp_2, "mdr" => mochi_to_int(M_4)}
    catch {return, Ret} -> Ret end.

main() ->
    try
        Base_3 = 10,
        Size = 5,
        io:format("~ts~n", [((((pad("Number", 20) ++ " ") ++ pad("MDR", 3)) ++ " ") ++ pad("MP", 3))]),
        Nums = [123321, 7739, 893, 899998, 3778888999, 277777788888899],
        I = 0,
        Fun_4 = fun Fun_4_loop(Base_3, I, Nums, Size) ->
    case (I < length(Nums)) of
        true ->
            N_3 = lists:nth(I + 1, Nums),
            R = multdigitalroot(N_3, Base_3),
            io:format("~ts~n", [((((pad(lists:flatten(io_lib:format("~p", [N_3])), 20) ++ " ") ++ pad(lists:flatten(io_lib:format("~p", [maps:get("mdr", R, nil)])), 3)) ++ " ") ++ pad(lists:flatten(io_lib:format("~p", [maps:get("mp", R, nil)])), 3))]),
            I_2 = (I + 1),
            Fun_4_loop(Base_3, I_2, Nums, Size);
        _ -> {Base_3, I, Nums, Size}
    end
end,
{Base_3, I_2, Nums, Size} = Fun_4(Base_3, I, Nums, Size),
        io:format("~ts~n", [""]),
        List = [],
        Idx = 0,
        Fun_5 = fun Fun_5_loop(Base_3, I_2, Idx, List, Nums, Size) ->
    case (Idx < Base_3) of
        true ->
            List_2 = lists:append(List, [[]]),
            Idx_2 = (Idx + 1),
            Fun_5_loop(Base_3, I_2, Idx_2, List_2, Nums, Size);
        _ -> {Base_3, I_2, Idx, List, Nums, Size}
    end
end,
{Base_3, I_2, Idx_2, List_2, Nums, Size} = Fun_5(Base_3, I_2, Idx, List, Nums, Size),
        Cnt = (Size * Base_3),
        N_4 = 0,
        B_3 = Base_3,
        Fun_6 = fun Fun_6_loop(B_3, Base_3, Cnt, I_2, Idx_2, List_2, N_4, Nums, Size) ->
    case (Cnt > 0) of
        true ->
            R_2 = multdigitalroot(N_4, Base_3),
            Mdr = maps:get("mdr", R_2, nil),
            case (length(lists:nth(Mdr + 1, List_2)) < Size) of
        true -> List_3 = lists:sublist(List_2, Mdr) ++ [lists:append(lists:nth(Mdr + 1, List_2), [mochi_to_int(N_4)])] ++ lists:nthtail(Mdr + 1, List_2),
            Cnt_2 = (Cnt - 1),
            Cnt_3 = Cnt_2,
            List_4 = List_3;
        _ -> Cnt_3 = Cnt,
            List_4 = List_2
    end,
            N_5 = (N_4 + 1),
            Fun_6_loop(B_3, Base_3, Cnt_3, I_2, Idx_2, List_4, N_5, Nums, Size);
        _ -> {B_3, Base_3, Cnt, I_2, Idx_2, List_2, N_4, Nums, Size}
    end
end,
{B_3, Base_3, Cnt_3, I_2, Idx_2, List_4, N_5, Nums, Size} = Fun_6(B_3, Base_3, Cnt, I_2, Idx_2, List_2, N_4, Nums, Size),
        io:format("~ts~n", ["MDR: First"]),
        J = 0,
        Fun_7 = fun Fun_7_loop(B_3, Base_3, Cnt_3, I_2, Idx_2, J, List_4, N_5, Nums, Size) ->
    case (J < Base_3) of
        true ->
            io:format("~ts~n", [((pad(lists:flatten(io_lib:format("~p", [J])), 3) ++ ": ") ++ lists:flatten(io_lib:format("~p", [lists:nth(J + 1, List_4)])))]),
            J_2 = (J + 1),
            Fun_7_loop(B_3, Base_3, Cnt_3, I_2, Idx_2, J_2, List_4, N_5, Nums, Size);
        _ -> {B_3, Base_3, Cnt_3, I_2, Idx_2, J, List_4, N_5, Nums, Size}
    end
end,
{B_3, Base_3, Cnt_3, I_2, Idx_2, J_2, List_4, N_5, Nums, Size} = Fun_7(B_3, Base_3, Cnt_3, I_2, Idx_2, J, List_4, N_5, Nums, Size),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
