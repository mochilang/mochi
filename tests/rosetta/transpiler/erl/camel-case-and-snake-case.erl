#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, trimspace/1, isupper/1, padleft/2, snaketocamel/1, cameltosnake/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (b43d15e5bc) on 2025-08-03 11:14 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

trimspace(S) ->
    try
        Start = 0,
        Fun = fun Fun_loop(S, Start) ->
    case ((Start < length(S)) andalso (string:substr(S, Start + 1, ((Start + 1) - Start)) == " ")) of
        true ->
            Start_2 = (Start + 1),
            Fun_loop(S, Start_2);
        _ -> {S, Start}
    end
end,
{S, Start_2} = Fun(S, Start),
        End = length(S),
        Fun_2 = fun Fun_2_loop(End, S, Start_2) ->
    case ((End > Start_2) andalso (string:substr(S, (End - 1) + 1, (End - (End - 1))) == " ")) of
        true ->
            End_2 = (End - 1),
            Fun_2_loop(End_2, S, Start_2);
        _ -> {End, S, Start_2}
    end
end,
{End_2, S, Start_2} = Fun_2(End, S, Start_2),
        string:substr(S, Start_2 + 1, (End_2 - Start_2))
    catch {return, Ret} -> Ret end.

isupper(Ch) ->
    try
        ((Ch >= "A") andalso (Ch =< "Z"))
    catch {return, Ret} -> Ret end.

padleft(S_2, W) ->
    try
        Res = "",
        N = (W - length(S_2)),
        Fun_3 = fun Fun_3_loop(N, Res, S_2, W) ->
    case (N > 0) of
        true ->
            Res_2 = (Res ++ " "),
            N_2 = (N - 1),
            Fun_3_loop(N_2, Res_2, S_2, W);
        _ -> {N, Res, S_2, W}
    end
end,
{N_2, Res_2, S_2, W} = Fun_3(N, Res, S_2, W),
        (Res_2 ++ S_2)
    catch {return, Ret} -> Ret end.

snaketocamel(S_3) ->
    try
        S_4 = trimspace(S_3),
        Out = "",
        Up = false,
        I = 0,
        Fun_4 = fun Fun_4_loop(I, Out, S_4, Up) ->
    case (I < length(S_4)) of
        true ->
            try
                Ch_2 = string:substr(S_4, I + 1, ((I + 1) - I)),
                case ((((Ch_2 == "_") orelse (Ch_2 == "-")) orelse (Ch_2 == " ")) orelse (Ch_2 == ".")) of
        true -> Up_2 = true,
            I_2 = (I + 1),
            throw({continue, I_2, Out, S_4, Up_2}),
            I_3 = I_2,
            Up_3 = Up_2;
        _ -> I_3 = I,
            Up_3 = Up
    end,
                case (I_3 == 0) of
        true -> Out_2 = (Out ++ string:to_lower(Ch_2)),
            Up_4 = false,
            I_4 = (I_3 + 1),
            throw({continue, I_4, Out_2, S_4, Up_4}),
            I_5 = I_4,
            Out_3 = Out_2,
            Up_5 = Up_4;
        _ -> I_5 = I_3,
            Out_3 = Out,
            Up_5 = Up_3
    end,
                case Up_5 of
        true -> Out_4 = (Out_3 ++ string:to_upper(Ch_2)),
            Up_6 = false,
            Out_6 = Out_4,
            Up_7 = Up_6;
        _ -> Out_5 = (Out_3 ++ Ch_2),
            Out_6 = Out_5,
            Up_7 = Up_5
    end,
                I_6 = (I_5 + 1),
                Fun_4_loop(I_6, Out_6, S_4, Up_7)
            catch
                {continue, C0, C1, C2, C3} -> Fun_4_loop(C0, C1, C2, C3);
                break -> {I, Out, S_4, Up}
            end;
        _ -> {I, Out, S_4, Up}
    end
end,
{I_6, Out_6, S_4, Up_7} = Fun_4(I, Out, S_4, Up),
        Out_6
    catch {return, Ret} -> Ret end.

cameltosnake(S_5) ->
    try
        S_6 = trimspace(S_5),
        Out_7 = "",
        PrevUnd = false,
        I_7 = 0,
        Fun_5 = fun Fun_5_loop(I_7, Out_7, PrevUnd, S_6) ->
    case (I_7 < length(S_6)) of
        true ->
            try
                Ch_3 = string:substr(S_6, I_7 + 1, ((I_7 + 1) - I_7)),
                case (((Ch_3 == " ") orelse (Ch_3 == "-")) orelse (Ch_3 == ".")) of
        true -> case (mochi_not(PrevUnd) andalso (length(Out_7) > 0)) of
        true -> Out_8 = (Out_7 ++ "_"),
            PrevUnd_2 = true,
            Out_9 = Out_8,
            PrevUnd_3 = PrevUnd_2;
        _ -> Out_9 = Out_7,
            PrevUnd_3 = PrevUnd
    end,
            I_8 = (I_7 + 1),
            throw({continue, I_8, Out_9, PrevUnd_3, S_6}),
            I_9 = I_8,
            Out_10 = Out_9,
            PrevUnd_4 = PrevUnd_3;
        _ -> I_9 = I_7,
            Out_10 = Out_7,
            PrevUnd_4 = PrevUnd
    end,
                case (Ch_3 == "_") of
        true -> case (mochi_not(PrevUnd_4) andalso (length(Out_10) > 0)) of
        true -> Out_11 = (Out_10 ++ "_"),
            PrevUnd_5 = true,
            Out_12 = Out_11,
            PrevUnd_6 = PrevUnd_5;
        _ -> Out_12 = Out_10,
            PrevUnd_6 = PrevUnd_4
    end,
            I_10 = (I_9 + 1),
            throw({continue, I_10, Out_12, PrevUnd_6, S_6}),
            I_11 = I_10,
            Out_13 = Out_12,
            PrevUnd_7 = PrevUnd_6;
        _ -> I_11 = I_9,
            Out_13 = Out_10,
            PrevUnd_7 = PrevUnd_4
    end,
                case isupper(Ch_3) of
        true -> case ((I_11 > 0) andalso mochi_not(PrevUnd_7)) of
        true -> Out_14 = (Out_13 ++ "_"),
            Out_15 = Out_14;
        _ -> Out_15 = Out_13
    end,
            Out_16 = (Out_15 ++ string:to_lower(Ch_3)),
            PrevUnd_8 = false,
            Out_18 = Out_16,
            PrevUnd_10 = PrevUnd_8;
        _ -> Out_17 = (Out_13 ++ string:to_lower(Ch_3)),
            PrevUnd_9 = false,
            Out_18 = Out_17,
            PrevUnd_10 = PrevUnd_9
    end,
                I_12 = (I_11 + 1),
                Fun_5_loop(I_12, Out_18, PrevUnd_10, S_6)
            catch
                {continue, C0, C1, C2, C3} -> Fun_5_loop(C0, C1, C2, C3);
                break -> {I_7, Out_7, PrevUnd, S_6}
            end;
        _ -> {I_7, Out_7, PrevUnd, S_6}
    end
end,
{I_12, Out_18, PrevUnd_10, S_6} = Fun_5(I_7, Out_7, PrevUnd, S_6),
        Start_3 = 0,
        Fun_6 = fun Fun_6_loop(I_12, Out_18, PrevUnd_10, S_6, Start_3) ->
    case ((Start_3 < length(Out_18)) andalso (string:substr(Out_18, Start_3 + 1, ((Start_3 + 1) - Start_3)) == "_")) of
        true ->
            Start_4 = (Start_3 + 1),
            Fun_6_loop(I_12, Out_18, PrevUnd_10, S_6, Start_4);
        _ -> {I_12, Out_18, PrevUnd_10, S_6, Start_3}
    end
end,
{I_12, Out_18, PrevUnd_10, S_6, Start_4} = Fun_6(I_12, Out_18, PrevUnd_10, S_6, Start_3),
        End_3 = length(Out_18),
        Fun_7 = fun Fun_7_loop(End_3, I_12, Out_18, PrevUnd_10, S_6, Start_4) ->
    case ((End_3 > Start_4) andalso (string:substr(Out_18, (End_3 - 1) + 1, (End_3 - (End_3 - 1))) == "_")) of
        true ->
            End_4 = (End_3 - 1),
            Fun_7_loop(End_4, I_12, Out_18, PrevUnd_10, S_6, Start_4);
        _ -> {End_3, I_12, Out_18, PrevUnd_10, S_6, Start_4}
    end
end,
{End_4, I_12, Out_18, PrevUnd_10, S_6, Start_4} = Fun_7(End_3, I_12, Out_18, PrevUnd_10, S_6, Start_4),
        Out_19 = string:substr(Out_18, Start_4 + 1, (End_4 - Start_4)),
        Res_3 = "",
        J = 0,
        LastUnd = false,
        Fun_8 = fun Fun_8_loop(End_4, I_12, J, LastUnd, Out_19, PrevUnd_10, Res_3, S_6, Start_4) ->
    case (J < length(Out_19)) of
        true ->
            C = string:substr(Out_19, J + 1, ((J + 1) - J)),
            case (C == "_") of
        true -> case mochi_not(LastUnd) of
        true -> Res_4 = (Res_3 ++ C),
            Res_5 = Res_4;
        _ -> Res_5 = Res_3
    end,
            LastUnd_2 = true,
            LastUnd_4 = LastUnd_2,
            Res_7 = Res_5;
        _ -> Res_6 = (Res_3 ++ C),
            LastUnd_3 = false,
            LastUnd_4 = LastUnd_3,
            Res_7 = Res_6
    end,
            J_2 = (J + 1),
            Fun_8_loop(End_4, I_12, J_2, LastUnd_4, Out_19, PrevUnd_10, Res_7, S_6, Start_4);
        _ -> {End_4, I_12, J, LastUnd, Out_19, PrevUnd_10, Res_3, S_6, Start_4}
    end
end,
{End_4, I_12, J_2, LastUnd_4, Out_19, PrevUnd_10, Res_7, S_6, Start_4} = Fun_8(End_4, I_12, J, LastUnd, Out_19, PrevUnd_10, Res_3, S_6, Start_4),
        Res_7
    catch {return, Ret} -> Ret end.

main() ->
    try
        Samples = ["snakeCase", "snake_case", "snake-case", "snake case", "snake CASE", "snake.case", "variable_10_case", "variable10Case", "É›rgo rE tHis", "hurry-up-joe!", "c://my-docs/happy_Flag-Day/12.doc", " spaces "],
        io:format("~ts~n", ["=== To snake_case ==="]),
        Fun_9 = fun Fun_9_loop(List, Samples) ->
    case List of
        [] -> {Samples};
        [S_7|S_7_rest] ->
            io:format("~ts~n", [((padleft(S_7, 34) ++ " => ") ++ cameltosnake(S_7))]),
            Fun_9_loop(S_7_rest, Samples)
    end
end,
{Samples} = Fun_9(Samples, Samples),
        io:format("~ts~n", [""]),
        io:format("~ts~n", ["=== To camelCase ==="]),
        Fun_10 = fun Fun_10_loop(List, Samples) ->
    case List of
        [] -> {Samples};
        [S_8|S_8_rest] ->
            io:format("~ts~n", [((padleft(S_8, 34) ++ " => ") ++ snaketocamel(S_8))]),
            Fun_10_loop(S_8_rest, Samples)
    end
end,
{Samples} = Fun_10(Samples, Samples),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    __mochi_bench_start = mochi_now(),
    __mochi_bench_start_mem = erlang:memory(total),
    main(),
    __mochi_bench_end = mochi_now(),
    __mochi_bench_end_mem = erlang:memory(total),
    __mochi_bench_duration_us = (__mochi_bench_end - __mochi_bench_start) div 1000,
    __mochi_bench_mem_bytes = erlang:abs(__mochi_bench_end_mem - __mochi_bench_start_mem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [__mochi_bench_duration_us, __mochi_bench_mem_bytes]).
