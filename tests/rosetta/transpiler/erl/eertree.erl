#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newnode/1, eertree/1, child/4, subpalindromes/1, main/0]).

% Generated by Mochi transpiler v0.10.47 (eaacde736f) on 2025-07-28 11:52 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

newnode(Len) ->
    try
        #{"length" => Len, "edges" => #{}, "suffix" => 0}
    catch {return, Ret} -> Ret end.

eertree(S) ->
    try
        Tree = [],
        Tree_2 = lists:append(Tree, [#{"length" => 0, "suffix" => 1, "edges" => #{}}]),
        Tree_3 = lists:append(Tree_2, [#{"length" => -1, "suffix" => 1, "edges" => #{}}]),
        Suffix = 1,
        I = 0,
        Fun_3 = fun Fun_3_loop(I, S, Suffix, Tree_3) ->
    case (I < length(S)) of
        true ->
            try
                C = string:substr(S, I + 1, ((I + 1) - I)),
                N = Suffix,
                K = 0,
                Fun = fun Fun_loop(C, I, K, N, S, Suffix, Tree_3) ->
    case true of
        true ->
            try
                K_2 = mochi_to_int(maps:get("length", lists:nth(N + 1, Tree_3), nil)),
                B = ((I - K_2) - 1),
                case ((B >= 0) andalso (string:substr(S, B + 1, ((B + 1) - B)) == C)) of
        true -> throw(break);
        _ -> ok
    end,
                N_2 = mochi_to_int(maps:get("suffix", lists:nth(N + 1, Tree_3), nil)),
                Fun_loop(C, I, K_2, N_2, S, Suffix, Tree_3)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_loop(C0, C1, C2, C3, C4, C5, C6);
                break -> {C, I, K, N, S, Suffix, Tree_3}
            end;
        _ -> {C, I, K, N, S, Suffix, Tree_3}
    end
end,
{C, I, K_2, N_2, S, Suffix, Tree_3} = Fun(C, I, K, N, S, Suffix, Tree_3),
                Edges = maps:get("edges", lists:nth(N_2 + 1, Tree_3), nil),
                case maps:is_key(C, Edges) of
        true -> Suffix_2 = maps:get(C, Edges, nil),
            I_2 = (I + 1),
            throw({continue, I_2, S, Suffix_2, Tree_3}),
            I_3 = I_2,
            Suffix_3 = Suffix_2;
        _ -> I_3 = I,
            Suffix_3 = Suffix
    end,
                Suffix_4 = length(Tree_3),
                Tree_4 = lists:append(Tree_3, [newnode((K_2 + 2))]),
                Edges_2 = maps:put(C, Suffix_4, Edges),
                Tmp = lists:nth(N_2 + 1, Tree_4),
                Tmp_2 = maps:put("edges", Edges_2, Tmp),
                Tree_5 = lists:sublist(Tree_4, N_2) ++ [Tmp_2] ++ lists:nthtail(N_2 + 1, Tree_4),
                case (mochi_to_int(maps:get("length", lists:nth(Suffix_4 + 1, Tree_5), nil)) == 1) of
        true -> Tmp_3 = lists:nth(Suffix_4 + 1, Tree_5),
            Tmp_4 = maps:put("suffix", 0, Tmp_3),
            Tree_6 = lists:sublist(Tree_5, Suffix_4) ++ [Tmp_4] ++ lists:nthtail(Suffix_4 + 1, Tree_5),
            I_4 = (I_3 + 1),
            throw({continue, I_4, S, Suffix_4, Tree_6}),
            I_5 = I_4,
            Tmp_5 = Tmp_4,
            Tree_7 = Tree_6;
        _ -> I_5 = I_3,
            Tmp_5 = Tmp_2,
            Tree_7 = Tree_5
    end,
                Fun_2 = fun Fun_2_loop(C, Edges_2, I_5, K_2, N_2, S, Suffix_4, Tmp_5, Tree_7) ->
    case true of
        true ->
            try
                N_3 = mochi_to_int(maps:get("suffix", lists:nth(N_2 + 1, Tree_7), nil)),
                B_2 = ((I_5 - mochi_to_int(maps:get("length", lists:nth(N_3 + 1, Tree_7), nil))) - 1),
                case ((B_2 >= 0) andalso (string:substr(S, B_2 + 1, ((B_2 + 1) - B_2)) == C)) of
        true -> throw(break);
        _ -> ok
    end,
                Fun_2_loop(C, Edges_2, I_5, K_2, N_3, S, Suffix_4, Tmp_5, Tree_7)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_2_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {C, Edges_2, I_5, K_2, N_2, S, Suffix_4, Tmp_5, Tree_7}
            end;
        _ -> {C, Edges_2, I_5, K_2, N_2, S, Suffix_4, Tmp_5, Tree_7}
    end
end,
{C, Edges_2, I_5, K_2, N_3, S, Suffix_4, Tmp_5, Tree_7} = Fun_2(C, Edges_2, I_5, K_2, N_2, S, Suffix_4, Tmp_5, Tree_7),
                En = maps:get("edges", lists:nth(N_3 + 1, Tree_7), nil),
                Tmp_6 = lists:nth(Suffix_4 + 1, Tree_7),
                Tmp_7 = maps:put("suffix", maps:get(C, En, nil), Tmp_6),
                Tree_8 = lists:sublist(Tree_7, Suffix_4) ++ [Tmp_7] ++ lists:nthtail(Suffix_4 + 1, Tree_7),
                I_6 = (I_5 + 1),
                Fun_3_loop(I_6, S, Suffix_4, Tree_8)
            catch
                {continue, C0, C1, C2, C3} -> Fun_3_loop(C0, C1, C2, C3);
                break -> {I, S, Suffix, Tree_3}
            end;
        _ -> {I, S, Suffix, Tree_3}
    end
end,
{I_6, S, Suffix_4, Tree_8} = Fun_3(I, S, Suffix, Tree_3),
        Tree_8
    catch {return, Ret} -> Ret end.

child(Tree_9, Idx, P, Acc) ->
    try
        Edges_3 = maps:get("edges", lists:nth(Idx + 1, Tree_9), nil),
        Fun_4 = fun Fun_4_loop(List, Acc, Edges_3, Idx, P, Tree_9) ->
    case List of
        [] -> {Acc, Edges_3, Idx, P, Tree_9};
        [Ch|Ch_rest] ->
            Nxt = maps:get(Ch, Edges_3, nil),
            Pal = ((Ch ++ P) ++ Ch),
            Acc_2 = lists:append(Acc, [Pal]),
            Acc_3 = child(Tree_9, Nxt, Pal, Acc_2),
            Fun_4_loop(Ch_rest, Acc_3, Edges_3, Idx, P, Tree_9)
    end
end,
{Acc_3, Edges_3, Idx, P, Tree_9} = Fun_4(maps:keys(Edges_3), Acc, Edges_3, Idx, P, Tree_9),
        {Acc_3, Acc_3}
    catch {return, Ret} -> Ret end.

subpalindromes(Tree_10) ->
    try
        Res = [],
        {Res_2, Res_3} = child(Tree_10, 0, "", Res),
        OEdges = maps:get("edges", lists:nth(1 + 1, Tree_10), nil),
        Fun_5 = fun Fun_5_loop(List, OEdges, Res_3, Tree_10) ->
    case List of
        [] -> {OEdges, Res_3, Tree_10};
        [Ch_2|Ch_2_rest] ->
            Res_4 = lists:append(Res_3, [Ch_2]),
            {Res_5, Res_6} = child(Tree_10, maps:get(Ch_2, OEdges, nil), Ch_2, Res_4),
            Fun_5_loop(Ch_2_rest, OEdges, Res_6, Tree_10)
    end
end,
{OEdges, Res_6, Tree_10} = Fun_5(maps:keys(OEdges), OEdges, Res_3, Tree_10),
        {Res_6, Res_6}
    catch {return, Ret} -> Ret end.

main() ->
    try
        Tree_11 = eertree("eertree"),
        Subs = subpalindromes(Tree_11),
        io:format("~ts~n", [lists:flatten(io_lib:format("~p", [Subs]))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('EVEN_ROOT', 0),
    erlang:put('ODD_ROOT', 1),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
