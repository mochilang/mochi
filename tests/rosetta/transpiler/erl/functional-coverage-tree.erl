#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pow10/1, formatfloat/2, padleft/2, repeat/2, tofloat/1, newnode/3, addchildren/2, setcoverage/2, computecoverage/1, spaces/1, show/2, main/0]).

% Generated by Mochi transpiler v0.10.55 (26b9f6045a) on 2025-08-02 23:10 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_repeat(S, N) when is_binary(S) ->
    binary:copy(S, mochi_to_int(N));
mochi_repeat(S, N) when is_list(S) ->
    string:copies(S, mochi_to_int(N));
mochi_repeat(_, _) -> [].


mochi_safe_mul(A, B) ->
    try A * B catch _:_ -> 1.0e308 end.

mochi_safe_div(A, B) ->
    try A / B catch _:_ -> 0.0 end.

mochi_safe_fmod(A, B) ->
    try math:fmod(A, B) catch _:_ -> 0.0 end.

pow10(N) ->
    try
        R = 1,
        I = 0,
        Fun = fun Fun_loop(I, N, R) ->
    case (I < N) of
        true ->
            R_2 = mochi_safe_mul(R, 10),
            I_2 = (I + 1),
            Fun_loop(I_2, N, R_2);
        _ -> {I, N, R}
    end
end,
{I_2, N, R_2} = Fun(I, N, R),
        R_2
    catch {return, Ret} -> Ret end.

formatfloat(F, Prec) ->
    try
        Scale = pow10(Prec),
        Scaled = (mochi_safe_mul(F, Scale) + 0.5),
        N_2 = mochi_to_int(Scaled),
        Digits = lists:flatten(io_lib:format("~p", [N_2])),
        Fun_2 = fun Fun_2_loop(Digits, F, N_2, Prec, Scale, Scaled) ->
    case (length(Digits) =< Prec) of
        true ->
            Digits_2 = ("0" ++ Digits),
            Fun_2_loop(Digits_2, F, N_2, Prec, Scale, Scaled);
        _ -> {Digits, F, N_2, Prec, Scale, Scaled}
    end
end,
{Digits_2, F, N_2, Prec, Scale, Scaled} = Fun_2(Digits, F, N_2, Prec, Scale, Scaled),
        IntPart = string:substr(Digits_2, 0 + 1, ((length(Digits_2) - Prec) - 0)),
        FracPart = string:substr(Digits_2, (length(Digits_2) - Prec) + 1, (length(Digits_2) - (length(Digits_2) - Prec))),
        ((IntPart ++ ".") ++ FracPart)
    catch {return, Ret} -> Ret end.

padleft(S, W) ->
    try
        Res = "",
        N_3 = (W - length(S)),
        Fun_3 = fun Fun_3_loop(N_3, Res, S, W) ->
    case (N_3 > 0) of
        true ->
            Res_2 = (Res ++ " "),
            N_4 = (N_3 - 1),
            Fun_3_loop(N_4, Res_2, S, W);
        _ -> {N_3, Res, S, W}
    end
end,
{N_4, Res_2, S, W} = Fun_3(N_3, Res, S, W),
        (Res_2 ++ S)
    catch {return, Ret} -> Ret end.

repeat(Ch, N_5) ->
    try
        S_2 = "",
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(Ch, I_3, N_5, S_2) ->
    case (I_3 < N_5) of
        true ->
            S_3 = (S_2 ++ Ch),
            I_4 = (I_3 + 1),
            Fun_4_loop(Ch, I_4, N_5, S_3);
        _ -> {Ch, I_3, N_5, S_2}
    end
end,
{Ch, I_4, N_5, S_3} = Fun_4(Ch, I_3, N_5, S_2),
        S_3
    catch {return, Ret} -> Ret end.

tofloat(I_5) ->
    try
        float(I_5)
    catch {return, Ret} -> Ret end.

newnode(Name, Weight, Coverage) ->
    try
        #{"name" => Name, "weight" => Weight, "coverage" => Coverage, "children" => []}
    catch {return, Ret} -> Ret end.

addchildren(N_6, Nodes) ->
    try
        Cs = maps:get("children", N_6, nil),
        Fun_5 = fun Fun_5_loop(List, Cs, N_6, Nodes) ->
    case List of
        [] -> {Cs, N_6, Nodes};
        [Node|Node_rest] ->
            Cs_2 = lists:append(Cs, [Node]),
            Fun_5_loop(Node_rest, Cs_2, N_6, Nodes)
    end
end,
{Cs_2, N_6, Nodes} = Fun_5(Nodes, Cs, N_6, Nodes),
        N_7 = maps:put("children", Cs_2, N_6),
        {nil, N_7}
    catch {return, Ret} -> Ret end.

setcoverage(N_8, Value) ->
    try
        N_9 = maps:put("coverage", Value, N_8),
        {nil, N_9}
    catch {return, Ret} -> Ret end.

computecoverage(N_10) ->
    try
        Cs_3 = maps:get("children", N_10, nil),
        case (length(Cs_3) == 0) of
        true -> throw({return, float(maps:get("coverage", N_10, nil))});
        _ -> ok
    end,
        V1 = 0,
        V2 = 0,
        Fun_6 = fun Fun_6_loop(List, Cs_3, N_10, V1, V2) ->
    case List of
        [] -> {Cs_3, N_10, V1, V2};
        [Node_2|Node_2_rest] ->
            M = Node_2,
            C = computecoverage(M),
            V1_2 = (V1 + mochi_safe_mul(tofloat(mochi_to_int(maps:get("weight", M, nil))), C)),
            V2_2 = (V2 + mochi_to_int(maps:get("weight", M, nil))),
            Fun_6_loop(Node_2_rest, Cs_3, N_10, V1_2, V2_2)
    end
end,
{Cs_3, N_10, V1_2, V2_2} = Fun_6(Cs_3, Cs_3, N_10, V1, V2),
        mochi_safe_div(V1_2, tofloat(V2_2))
    catch {return, Ret} -> Ret end.

spaces(N_11) ->
    try
        mochi_repeat(" ", N_11)
    catch {return, Ret} -> Ret end.

show(N_12, Level) ->
    try
        Indent = (Level * 4),
        Name_2 = maps:get("name", N_12, nil),
        Nl = (length(Name_2) + Indent),
        Line = (spaces(Indent) ++ Name_2),
        Line_2 = ((Line ++ spaces((32 - Nl))) ++ "|  "),
        Line_3 = ((Line_2 ++ padleft(lists:flatten(io_lib:format("~p", [mochi_to_int(maps:get("weight", N_12, nil))])), 3)) ++ "   | "),
        Line_4 = ((Line_3 ++ formatfloat(computecoverage(N_12), 6)) ++ " |"),
        io:format("~ts~n", [Line_4]),
        Cs_4 = maps:get("children", N_12, nil),
        Fun_7 = fun Fun_7_loop(List, Cs_4, Indent, Level, Line_4, N_12, Name_2, Nl) ->
    case List of
        [] -> {Cs_4, Indent, Level, Line_4, N_12, Name_2, Nl};
        [Child|Child_rest] ->
            show(Child, (Level + 1)),
            Fun_7_loop(Child_rest, Cs_4, Indent, Level, Line_4, N_12, Name_2, Nl)
    end
end,
{Cs_4, Indent, Level, Line_4, N_12, Name_2, Nl} = Fun_7(Cs_4, Cs_4, Indent, Level, Line_4, N_12, Name_2, Nl),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Cleaning = newnode("cleaning", 1, 0),
        {_, H1_bathrooms} = addchildren(erlang:get('h1_bathrooms'), [erlang:get('h1_bathroom1'), erlang:get('h1_bathroom2'), erlang:get('h1_outside')]),
        erlang:put('h1_bathrooms', H1_bathrooms),
        {_, H1_living_rooms} = addchildren(erlang:get('h1_living_rooms'), [erlang:get('h1_lounge'), erlang:get('h1_dining'), erlang:get('h1_conservatory'), erlang:get('h1_playroom')]),
        erlang:put('h1_living_rooms', H1_living_rooms),
        {_, House1} = addchildren(erlang:get('house1'), [erlang:get('h1_bedrooms'), erlang:get('h1_bathrooms'), erlang:get('h1_attic'), erlang:get('h1_kitchen'), erlang:get('h1_living_rooms'), erlang:get('h1_basement'), erlang:get('h1_garage'), erlang:get('h1_garden')]),
        erlang:put('house1', House1),
        {_, H2_bedrooms} = addchildren(erlang:get('h2_bedrooms'), [erlang:get('h2_suite1'), erlang:get('h2_suite2'), erlang:get('h2_bedroom3'), erlang:get('h2_bedroom4')]),
        erlang:put('h2_bedrooms', H2_bedrooms),
        {_, H2_upstairs} = addchildren(erlang:get('h2_upstairs'), [erlang:get('h2_bedrooms'), erlang:get('h2_bathroom'), erlang:get('h2_toilet'), erlang:get('h2_attics')]),
        erlang:put('h2_upstairs', H2_upstairs),
        {_, H2_living_rooms} = addchildren(erlang:get('h2_living_rooms'), [erlang:get('h2_lounge'), erlang:get('h2_dining'), erlang:get('h2_conservatory'), erlang:get('h2_playroom')]),
        erlang:put('h2_living_rooms', H2_living_rooms),
        {_, H2_groundfloor} = addchildren(erlang:get('h2_groundfloor'), [erlang:get('h2_kitchen'), erlang:get('h2_living_rooms'), erlang:get('h2_wet_room'), erlang:get('h2_garage'), erlang:get('h2_garden'), erlang:get('h2_hot_tub')]),
        erlang:put('h2_groundfloor', H2_groundfloor),
        {_, H2_basement} = addchildren(erlang:get('h2_basement'), [erlang:get('h2_cellars'), erlang:get('h2_wine_cellar'), erlang:get('h2_cinema')]),
        erlang:put('h2_basement', H2_basement),
        {_, House2} = addchildren(erlang:get('house2'), [erlang:get('h2_upstairs'), erlang:get('h2_groundfloor'), erlang:get('h2_basement')]),
        erlang:put('house2', House2),
        {_, Cleaning_2} = addchildren(Cleaning, [erlang:get('house1'), erlang:get('house2')]),
        TopCoverage = computecoverage(Cleaning_2),
        io:format("~ts~n", [("TOP COVERAGE = " ++ formatfloat(TopCoverage, 6))]),
        io:format("~ts~n", [""]),
        io:format("~ts~n", ["NAME HIERARCHY                 | WEIGHT | COVERAGE |"]),
        show(Cleaning_2, 0),
        {_, H2_cinema} = setcoverage(erlang:get('h2_cinema'), 1),
        erlang:put('h2_cinema', H2_cinema),
        Diff = (computecoverage(Cleaning_2) - TopCoverage),
        io:format("~ts~n", [""]),
        io:format("~ts~n", ["If the coverage of the Cinema node were increased from 0.75 to 1"]),
        io:format("~ts~n", [((("the top level coverage would increase by " ++ formatfloat(Diff, 6)) ++ " to ") ++ formatfloat((TopCoverage + Diff), 6))]),
        {_, H2_cinema_2} = setcoverage(erlang:get('h2_cinema'), 0.75),
        erlang:put('h2_cinema', H2_cinema_2),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('house1', newnode("house1", 40, 0)),
    erlang:put('house2', newnode("house2", 60, 0)),
    erlang:put('h1_bedrooms', newnode("bedrooms", 1, 0.25)),
    erlang:put('h1_bathrooms', newnode("bathrooms", 1, 0)),
    erlang:put('h1_attic', newnode("attic", 1, 0.75)),
    erlang:put('h1_kitchen', newnode("kitchen", 1, 0.1)),
    erlang:put('h1_living_rooms', newnode("living_rooms", 1, 0)),
    erlang:put('h1_basement', newnode("basement", 1, 0)),
    erlang:put('h1_garage', newnode("garage", 1, 0)),
    erlang:put('h1_garden', newnode("garden", 1, 0.8)),
    erlang:put('h2_upstairs', newnode("upstairs", 1, 0)),
    erlang:put('h2_groundfloor', newnode("groundfloor", 1, 0)),
    erlang:put('h2_basement', newnode("basement", 1, 0)),
    erlang:put('h1_bathroom1', newnode("bathroom1", 1, 0.5)),
    erlang:put('h1_bathroom2', newnode("bathroom2", 1, 0)),
    erlang:put('h1_outside', newnode("outside_lavatory", 1, 1)),
    erlang:put('h1_lounge', newnode("lounge", 1, 0)),
    erlang:put('h1_dining', newnode("dining_room", 1, 0)),
    erlang:put('h1_conservatory', newnode("conservatory", 1, 0)),
    erlang:put('h1_playroom', newnode("playroom", 1, 1)),
    erlang:put('h2_bedrooms', newnode("bedrooms", 1, 0)),
    erlang:put('h2_bathroom', newnode("bathroom", 1, 0)),
    erlang:put('h2_toilet', newnode("toilet", 1, 0)),
    erlang:put('h2_attics', newnode("attics", 1, 0.6)),
    erlang:put('h2_kitchen', newnode("kitchen", 1, 0)),
    erlang:put('h2_living_rooms', newnode("living_rooms", 1, 0)),
    erlang:put('h2_wet_room', newnode("wet_room_&_toilet", 1, 0)),
    erlang:put('h2_garage', newnode("garage", 1, 0)),
    erlang:put('h2_garden', newnode("garden", 1, 0.9)),
    erlang:put('h2_hot_tub', newnode("hot_tub_suite", 1, 1)),
    erlang:put('h2_cellars', newnode("cellars", 1, 1)),
    erlang:put('h2_wine_cellar', newnode("wine_cellar", 1, 1)),
    erlang:put('h2_cinema', newnode("cinema", 1, 0.75)),
    erlang:put('h2_suite1', newnode("suite_1", 1, 0)),
    erlang:put('h2_suite2', newnode("suite_2", 1, 0)),
    erlang:put('h2_bedroom3', newnode("bedroom_3", 1, 0)),
    erlang:put('h2_bedroom4', newnode("bedroom_4", 1, 0)),
    erlang:put('h2_lounge', newnode("lounge", 1, 0)),
    erlang:put('h2_dining', newnode("dining_room", 1, 0)),
    erlang:put('h2_conservatory', newnode("conservatory", 1, 0)),
    erlang:put('h2_playroom', newnode("playroom", 1, 0)),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
