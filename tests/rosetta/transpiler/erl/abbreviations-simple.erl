#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, fields/1, padRight/2, join/2, parseIntStr/1, isDigits/1, readTable/1, validate/3, main/0]).

% Generated by Mochi transpiler v0.10.37 (a60a40ef13) on 2025-07-23 08:17 UTC

fields(S) ->
    try
        Words = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, S, Words) ->
    case (I < length(S)) of
        true ->
            try
                Ch = string:substr(S, I + 1, ((I + 1) - I)),
                case (((Ch == " ") orelse (Ch == "\n")) orelse (Ch == "\t")) of
        true -> case (length(Cur) > 0) of
        true -> Words2 = lists:append(Words, [Cur]),
            Cur2 = "",
            Cur3 = Cur2,
            Words3 = Words2;
        _ -> Cur3 = Cur,
            Words3 = Words
    end,
            Cur5 = Cur3,
            Words4 = Words3;
        _ -> Cur4 = (Cur ++ Ch),
            Cur5 = Cur4,
            Words4 = Words
    end,
                I2 = (I + 1),
                Fun_loop(Cur5, I2, S, Words4)
            catch
                break -> {Cur, I, S, Words}
            end;
        _ -> {Cur, I, S, Words}
    end
end,
{Cur5, I2, S, Words4} = Fun(Cur, I, S, Words),
        case (length(Cur5) > 0) of
        true -> Words5 = lists:append(Words4, [Cur5]),
            Words6 = Words5;
        _ -> Words6 = Words4
    end,
        Words6
    catch {return, V} -> V end.

padRight(S2, Width) ->
    try
        Out = S2,
        I3 = length(S2),
        Fun2 = fun Fun2_loop(I3, Out, S2, Width) ->
    case (I3 < Width) of
        true ->
            try
                Out2 = (Out ++ " "),
                I4 = (I3 + 1),
                Fun2_loop(I4, Out2, S2, Width)
            catch
                break -> {I3, Out, S2, Width}
            end;
        _ -> {I3, Out, S2, Width}
    end
end,
{I4, Out2, S2, Width} = Fun2(I3, Out, S2, Width),
        Out2
    catch {return, V} -> V end.

join(Xs, Sep) ->
    try
        Res = "",
        I5 = 0,
        Fun3 = fun Fun3_loop(I5, Res, Sep, Xs) ->
    case (I5 < length(Xs)) of
        true ->
            try
                case (I5 > 0) of
        true -> Res2 = (Res ++ Sep),
            Res3 = Res2;
        _ -> Res3 = Res
    end,
                Res4 = (Res3 ++ lists:nth(I5 + 1, Xs)),
                I6 = (I5 + 1),
                Fun3_loop(I6, Res4, Sep, Xs)
            catch
                break -> {I5, Res, Sep, Xs}
            end;
        _ -> {I5, Res, Sep, Xs}
    end
end,
{I6, Res4, Sep, Xs} = Fun3(I5, Res, Sep, Xs),
        Res4
    catch {return, V} -> V end.

parseIntStr(Str) ->
    try
        I7 = 0,
        Neg = false,
        case ((length(Str) > 0) andalso (lists:sublist(Str, 0 + 1, (1 - 0)) == "-")) of
        true -> Neg2 = true,
            I8 = 1,
            I9 = I8,
            Neg3 = Neg2;
        _ -> I9 = I7,
            Neg3 = Neg
    end,
        N = 0,
        Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
        Fun4 = fun Fun4_loop(Digits, I9, N, Neg3, Str) ->
    case (I9 < length(Str)) of
        true ->
            try
                N2 = ((N * 10) + maps:get(lists:sublist(Str, I9 + 1, ((I9 + 1) - I9)), Digits)),
                I10 = (I9 + 1),
                Fun4_loop(Digits, I10, N2, Neg3, Str)
            catch
                break -> {Digits, I9, N, Neg3, Str}
            end;
        _ -> {Digits, I9, N, Neg3, Str}
    end
end,
{Digits, I10, N2, Neg3, Str} = Fun4(Digits, I9, N, Neg3, Str),
        case (Neg3 /= nil) of
        true -> N3 = -N2,
            N4 = N3;
        _ -> N4 = N2
    end,
        N4
    catch {return, V} -> V end.

isDigits(S3) ->
    try
        case (length(S3) == 0) of
        true -> throw({return, false});
        _ -> ok
    end,
        I11 = 0,
        Fun5 = fun Fun5_loop(I11, S3) ->
    case (I11 < length(S3)) of
        true ->
            try
                Ch2 = string:substr(S3, I11 + 1, ((I11 + 1) - I11)),
                case ((Ch2 < "0") orelse (Ch2 > "9")) of
        true -> throw({return, false});
        _ -> ok
    end,
                I12 = (I11 + 1),
                Fun5_loop(I12, S3)
            catch
                break -> {I11, S3}
            end;
        _ -> {I11, S3}
    end
end,
{I12, S3} = Fun5(I11, S3),
        true
    catch {return, V} -> V end.

readTable(Table) ->
    try
        Toks = fields(Table),
        Cmds = [],
        Mins = [],
        I13 = 0,
        Fun6 = fun Fun6_loop(Cmds, I13, Mins, Table, Toks) ->
    case (I13 < length(Toks)) of
        true ->
            try
                Cmd = lists:nth(I13 + 1, Toks),
                Minlen = length(Cmd),
                I14 = (I13 + 1),
                case ((I14 < length(Toks)) andalso isDigits(lists:nth(I14 + 1, Toks))) of
        true -> Num = parseIntStr(lists:nth(I14 + 1, Toks)),
            case ((Num >= 1) andalso (Num < length(Cmd))) of
        true -> Minlen2 = Num,
            I15 = (I14 + 1),
            I16 = I15,
            Minlen3 = Minlen2;
        _ -> I16 = I14,
            Minlen3 = Minlen
    end,
            I17 = I16,
            Minlen4 = Minlen3,
            Num2 = Num;
        _ -> I17 = I14,
            Minlen4 = Minlen,
            Num2 = nil
    end,
                Cmds2 = lists:append(Cmds, [Cmd]),
                Mins2 = lists:append(Mins, [Minlen4]),
                Fun6_loop(Cmds2, I17, Mins2, Table, Toks)
            catch
                break -> {Cmds, I13, Mins, Table, Toks}
            end;
        _ -> {Cmds, I13, Mins, Table, Toks}
    end
end,
{Cmds2, I17, Mins2, Table, Toks} = Fun6(Cmds, I13, Mins, Table, Toks),
        #{"commands" => Cmds2, "mins" => Mins2}
    catch {return, V} -> V end.

validate(Commands, Mins3, Words7) ->
    try
        Results = [],
        Wi = 0,
        Fun8 = fun Fun8_loop(Commands, Mins3, Results, Wi, Words7) ->
    case (Wi < length(Words7)) of
        true ->
            try
                W = lists:nth(Wi + 1, Words7),
                Found = false,
                Wlen = length(W),
                Ci = 0,
                Fun7 = fun Fun7_loop(Ci, Commands, Found, Mins3, Results, W, Wi, Wlen, Words7) ->
    case (Ci < length(Commands)) of
        true ->
            try
                Cmd2 = lists:nth(Ci + 1, Commands),
                case (((lists:nth(Ci + 1, Mins3) /= 0) andalso (Wlen >= lists:nth(Ci + 1, Mins3))) andalso (Wlen =< length(Cmd2))) of
        true -> C = string:to_upper(Cmd2),
            Ww = string:to_upper(W),
            case (string:substr(C, 0 + 1, (Wlen - 0)) == Ww) of
        true -> Results2 = lists:append(Results, [C]),
            Found2 = true,
            throw(break),
            Found3 = Found2,
            Results3 = Results2;
        _ -> Found3 = Found,
            Results3 = Results
    end,
            C2 = C,
            Found4 = Found3,
            Results4 = Results3,
            Ww2 = Ww;
        _ -> C2 = nil,
            Found4 = Found,
            Results4 = Results,
            Ww2 = nil
    end,
                Ci2 = (Ci + 1),
                Fun7_loop(Ci2, Commands, Found4, Mins3, Results4, W, Wi, Wlen, Words7)
            catch
                break -> {Ci, Commands, Found, Mins3, Results, W, Wi, Wlen, Words7}
            end;
        _ -> {Ci, Commands, Found, Mins3, Results, W, Wi, Wlen, Words7}
    end
end,
{Ci2, Commands, Found4, Mins3, Results4, W, Wi, Wlen, Words7} = Fun7(Ci, Commands, Found, Mins3, Results, W, Wi, Wlen, Words7),
                case not Found4 of
        true -> Results5 = lists:append(Results4, ["*error*"]),
            Results6 = Results5;
        _ -> Results6 = Results4
    end,
                Wi2 = (Wi + 1),
                Fun8_loop(Commands, Mins3, Results6, Wi2, Words7)
            catch
                break -> {Commands, Mins3, Results, Wi, Words7}
            end;
        _ -> {Commands, Mins3, Results, Wi, Words7}
    end
end,
{Commands, Mins3, Results6, Wi2, Words7} = Fun8(Commands, Mins3, Results, Wi, Words7),
        Results6
    catch {return, V} -> V end.

main() ->
    try
        Table2 = (((((((("" ++ "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ") ++ "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ") ++ "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ") ++ "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ") ++ "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ") ++ "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ") ++ "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ") ++ "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 "),
        Sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin",
        Tbl = readTable(Table2),
        Commands2 = maps:get("commands", Tbl),
        Mins4 = maps:get("mins", Tbl),
        Words8 = fields("riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin"),
        Results7 = validate(Commands2, Mins4, Words8),
        Out1 = "user words:",
        K = 0,
        Fun9 = fun Fun9_loop(Commands2, K, Mins4, Out1, Results7, Sentence, Table2, Tbl, Words8) ->
    case (K < length(Words8)) of
        true ->
            try
                Out12 = (Out1 ++ " "),
                case (K < (length(Words8) - 1)) of
        true -> Out13 = (Out12 ++ padRight(lists:nth(K + 1, Words8), length(lists:nth(K + 1, Results7)))),
            Out15 = Out13;
        _ -> Out14 = (Out12 ++ lists:nth(K + 1, Words8)),
            Out15 = Out14
    end,
                K2 = (K + 1),
                Fun9_loop(Commands2, K2, Mins4, Out15, Results7, Sentence, Table2, Tbl, Words8)
            catch
                break -> {Commands2, K, Mins4, Out1, Results7, Sentence, Table2, Tbl, Words8}
            end;
        _ -> {Commands2, K, Mins4, Out1, Results7, Sentence, Table2, Tbl, Words8}
    end
end,
{Commands2, K2, Mins4, Out15, Results7, Sentence, Table2, Tbl, Words8} = Fun9(Commands2, K, Mins4, Out1, Results7, Sentence, Table2, Tbl, Words8),
        io:format("~ts~n", [Out15]),
        io:format("~ts~n", [("full words: " ++ join(Results7, " "))]),
        nil
    catch {return, V} -> V end.

main(_) ->
    main().
