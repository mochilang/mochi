#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, fields/1, padright/2, join/2, parseintstr/1, isdigits/1, readtable/1, validate/3, main/0]).

% Generated by Mochi transpiler v0.10.40 (c9f97e1bd3) on 2025-07-25 19:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_parse_int_str(S) ->
    try list_to_integer(S) catch _:_ -> 0 end.

fields(S) ->
    try
        Words = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, S, Words) ->
    case (I < length(S)) of
        true ->
            Ch = string:substr(S, I + 1, ((I + 1) - I)),
            case (((Ch == " ") orelse (Ch == "\n")) orelse (Ch == "\t")) of
        true -> case (length(Cur) > 0) of
        true -> Words_2 = lists:append(Words, [Cur]),
            Cur_2 = "",
            Cur_3 = Cur_2,
            Words_3 = Words_2;
        _ -> Cur_3 = Cur,
            Words_3 = Words
    end,
            Cur_5 = Cur_3,
            Words_4 = Words_3;
        _ -> Cur_4 = (Cur ++ Ch),
            Cur_5 = Cur_4,
            Words_4 = Words
    end,
            I_2 = (I + 1),
            Fun_loop(Cur_5, I_2, S, Words_4);
        _ -> {Cur, I, S, Words}
    end
end,
{Cur_5, I_2, S, Words_4} = Fun(Cur, I, S, Words),
        case (length(Cur_5) > 0) of
        true -> Words_5 = lists:append(Words_4, [Cur_5]),
            Words_6 = Words_5;
        _ -> Words_6 = Words_4
    end,
        Words_6
    catch {return, Ret} -> Ret end.

padright(S_2, Width) ->
    try
        Out = S_2,
        I_3 = length(S_2),
        Fun_2 = fun Fun_2_loop(I_3, Out, S_2, Width) ->
    case (I_3 < Width) of
        true ->
            Out_2 = (Out ++ " "),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, Out_2, S_2, Width);
        _ -> {I_3, Out, S_2, Width}
    end
end,
{I_4, Out_2, S_2, Width} = Fun_2(I_3, Out, S_2, Width),
        Out_2
    catch {return, Ret} -> Ret end.

join(Xs, Sep) ->
    try
        Res = "",
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(I_5, Res, Sep, Xs) ->
    case (I_5 < length(Xs)) of
        true ->
            case (I_5 > 0) of
        true -> Res_2 = (Res ++ Sep),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Res_4 = (Res_3 ++ lists:nth(I_5 + 1, Xs)),
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, Res_4, Sep, Xs);
        _ -> {I_5, Res, Sep, Xs}
    end
end,
{I_6, Res_4, Sep, Xs} = Fun_3(I_5, Res, Sep, Xs),
        Res_4
    catch {return, Ret} -> Ret end.

parseintstr(Str) ->
    try
        I_7 = 0,
        Neg = false,
        case ((length(Str) > 0) andalso (string:substr(Str, 0 + 1, (1 - 0)) == "-")) of
        true -> Neg_2 = true,
            I_8 = 1,
            I_9 = I_8,
            Neg_3 = Neg_2;
        _ -> I_9 = I_7,
            Neg_3 = Neg
    end,
        N = 0,
        Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
        Fun_4 = fun Fun_4_loop(Digits, I_9, N, Neg_3, Str) ->
    case (I_9 < length(Str)) of
        true ->
            N_2 = ((N * 10) + maps:get(string:substr(Str, I_9 + 1, ((I_9 + 1) - I_9)), Digits, nil)),
            I_10 = (I_9 + 1),
            Fun_4_loop(Digits, I_10, N_2, Neg_3, Str);
        _ -> {Digits, I_9, N, Neg_3, Str}
    end
end,
{Digits, I_10, N_2, Neg_3, Str} = Fun_4(Digits, I_9, N, Neg_3, Str),
        case Neg_3 of
        true -> N_3 = -N_2,
            N_4 = N_3;
        _ -> N_4 = N_2
    end,
        N_4
    catch {return, Ret} -> Ret end.

isdigits(S_3) ->
    try
        case (length(S_3) == 0) of
        true -> throw({return, false});
        _ -> ok
    end,
        I_11 = 0,
        Fun_5 = fun Fun_5_loop(I_11, S_3) ->
    case (I_11 < length(S_3)) of
        true ->
            Ch_2 = string:substr(S_3, I_11 + 1, ((I_11 + 1) - I_11)),
            case ((Ch_2 < "0") orelse (Ch_2 > "9")) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_12 = (I_11 + 1),
            Fun_5_loop(I_12, S_3);
        _ -> {I_11, S_3}
    end
end,
{I_12, S_3} = Fun_5(I_11, S_3),
        true
    catch {return, Ret} -> Ret end.

readtable(Table) ->
    try
        Toks = fields(Table),
        Cmds = [],
        Mins = [],
        I_13 = 0,
        Fun_6 = fun Fun_6_loop(Cmds, I_13, Mins, Table, Toks) ->
    case (I_13 < length(Toks)) of
        true ->
            Cmd = lists:nth(I_13 + 1, Toks),
            Minlen = length(Cmd),
            I_14 = (I_13 + 1),
            case ((I_14 < length(Toks)) andalso isdigits(lists:nth(I_14 + 1, Toks))) of
        true -> Num = mochi_parse_int_str(lists:nth(I_14 + 1, Toks)),
            case ((Num >= 1) andalso (Num < length(Cmd))) of
        true -> Minlen_2 = Num,
            I_15 = (I_14 + 1),
            I_16 = I_15,
            Minlen_3 = Minlen_2;
        _ -> I_16 = I_14,
            Minlen_3 = Minlen
    end,
            I_17 = I_16,
            Minlen_4 = Minlen_3,
            Num_2 = Num;
        _ -> I_17 = I_14,
            Minlen_4 = Minlen,
            Num_2 = nil
    end,
            Cmds_2 = lists:append(Cmds, [Cmd]),
            Mins_2 = lists:append(Mins, [Minlen_4]),
            Fun_6_loop(Cmds_2, I_17, Mins_2, Table, Toks);
        _ -> {Cmds, I_13, Mins, Table, Toks}
    end
end,
{Cmds_2, I_17, Mins_2, Table, Toks} = Fun_6(Cmds, I_13, Mins, Table, Toks),
        #{"commands" => Cmds_2, "mins" => Mins_2}
    catch {return, Ret} -> Ret end.

validate(Commands, Mins_3, Words_7) ->
    try
        Results = [],
        Wi = 0,
        Fun_8 = fun Fun_8_loop(Commands, Mins_3, Results, Wi, Words_7) ->
    case (Wi < length(Words_7)) of
        true ->
            try
                W = lists:nth(Wi + 1, Words_7),
                Found = false,
                Wlen = length(W),
                Ci = 0,
                Fun_7 = fun Fun_7_loop(Ci, Commands, Found, Mins_3, Results, W, Wi, Wlen, Words_7) ->
    case (Ci < length(Commands)) of
        true ->
            try
                Cmd_2 = lists:nth(Ci + 1, Commands),
                case (((lists:nth(Ci + 1, Mins_3) /= 0) andalso (Wlen >= lists:nth(Ci + 1, Mins_3))) andalso (Wlen =< length(Cmd_2))) of
        true -> C = string:to_upper(Cmd_2),
            Ww = string:to_upper(W),
            case (string:substr(C, 0 + 1, (Wlen - 0)) == Ww) of
        true -> Results_2 = lists:append(Results, [C]),
            Found_2 = true,
            throw(break),
            Found_3 = Found_2,
            Results_3 = Results_2;
        _ -> Found_3 = Found,
            Results_3 = Results
    end,
            C_2 = C,
            Found_4 = Found_3,
            Results_4 = Results_3,
            Ww_2 = Ww;
        _ -> C_2 = nil,
            Found_4 = Found,
            Results_4 = Results,
            Ww_2 = nil
    end,
                Ci_2 = (Ci + 1),
                Fun_7_loop(Ci_2, Commands, Found_4, Mins_3, Results_4, W, Wi, Wlen, Words_7)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_7_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {Ci, Commands, Found, Mins_3, Results, W, Wi, Wlen, Words_7}
            end;
        _ -> {Ci, Commands, Found, Mins_3, Results, W, Wi, Wlen, Words_7}
    end
end,
{Ci_2, Commands, Found_4, Mins_3, Results_4, W, Wi, Wlen, Words_7} = Fun_7(Ci, Commands, Found, Mins_3, Results, W, Wi, Wlen, Words_7),
                case not Found_4 of
        true -> Results_5 = lists:append(Results_4, ["*error*"]),
            Results_6 = Results_5;
        _ -> Results_6 = Results_4
    end,
                Wi_2 = (Wi + 1),
                Fun_8_loop(Commands, Mins_3, Results_6, Wi_2, Words_7)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_8_loop(C0, C1, C2, C3, C4);
                break -> {Commands, Mins_3, Results, Wi, Words_7}
            end;
        _ -> {Commands, Mins_3, Results, Wi, Words_7}
    end
end,
{Commands, Mins_3, Results_6, Wi_2, Words_7} = Fun_8(Commands, Mins_3, Results, Wi, Words_7),
        Results_6
    catch {return, Ret} -> Ret end.

main() ->
    try
        Table_2 = (((((((("" ++ "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ") ++ "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ") ++ "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ") ++ "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ") ++ "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ") ++ "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ") ++ "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ") ++ "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 "),
        Sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin",
        Tbl = readtable(Table_2),
        Commands_2 = maps:get("commands", Tbl, nil),
        Mins_4 = maps:get("mins", Tbl, nil),
        Words_8 = fields("riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin"),
        Results_7 = validate(Commands_2, Mins_4, Words_8),
        Out1 = "user words:",
        K = 0,
        Fun_9 = fun Fun_9_loop(Commands_2, K, Mins_4, Out1, Results_7, Sentence, Table_2, Tbl, Words_8) ->
    case (K < length(Words_8)) of
        true ->
            Out1_2 = (Out1 ++ " "),
            case (K < (length(Words_8) - 1)) of
        true -> Out1_3 = (Out1_2 ++ padright(lists:nth(K + 1, Words_8), length(lists:nth(K + 1, Results_7)))),
            Out1_5 = Out1_3;
        _ -> Out1_4 = (Out1_2 ++ lists:nth(K + 1, Words_8)),
            Out1_5 = Out1_4
    end,
            K_2 = (K + 1),
            Fun_9_loop(Commands_2, K_2, Mins_4, Out1_5, Results_7, Sentence, Table_2, Tbl, Words_8);
        _ -> {Commands_2, K, Mins_4, Out1, Results_7, Sentence, Table_2, Tbl, Words_8}
    end
end,
{Commands_2, K_2, Mins_4, Out1_5, Results_7, Sentence, Table_2, Tbl, Words_8} = Fun_9(Commands_2, K, Mins_4, Out1, Results_7, Sentence, Table_2, Tbl, Words_8),
        io:format("~ts~n", [Out1_5]),
        io:format("~ts~n", [("full words: " ++ join(Results_7, " "))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
