#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, contains/2, copyints/1, sliceequal/2, reverse/1, perimequal/2, sortedges/1, concat/2, facetoperim/1, liststr/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (6aa59f472e) on 2025-08-02 17:26 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_member(Key, Coll) ->
    case erlang:is_map(Coll) of
        true -> maps:is_key(Key, Coll);
        _ -> case erlang:is_list(Coll) of
            true -> lists:member(Key, Coll);
            _ when is_binary(Coll) -> string:str(Coll, Key) /= 0;
            _ -> false
        end
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

contains(Xs, V) ->
    try
        Fun = fun Fun_loop(List, V, Xs) ->
    case List of
        [] -> {V, Xs};
        [X|X_rest] ->
            case (X == V) of
        true -> throw({return, true});
        _ -> ok
    end,
            Fun_loop(X_rest, V, Xs)
    end
end,
{V, Xs} = Fun(Xs, V, Xs),
        false
    catch {return, Ret} -> Ret end.

copyints(Xs_2) ->
    try
        Out = [],
        Fun_2 = fun Fun_2_loop(List, Out, Xs_2) ->
    case List of
        [] -> {Out, Xs_2};
        [X_2|X_2_rest] ->
            Out_2 = lists:append(Out, [X_2]),
            Fun_2_loop(X_2_rest, Out_2, Xs_2)
    end
end,
{Out_2, Xs_2} = Fun_2(Xs_2, Out, Xs_2),
        Out_2
    catch {return, Ret} -> Ret end.

sliceequal(A, B) ->
    try
        I = 0,
        Fun_3 = fun Fun_3_loop(A, B, I) ->
    case (I < length(A)) of
        true ->
            case ((case erlang:is_map(A) of true -> maps:get(I, A, nil); _ -> lists:nth(I + 1, A) end) /= (case erlang:is_map(B) of true -> maps:get(I, B, nil); _ -> lists:nth(I + 1, B) end)) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_3_loop(A, B, I_2);
        _ -> {A, B, I}
    end
end,
{A, B, I_2} = Fun_3(A, B, I),
        true
    catch {return, Ret} -> Ret end.

reverse(Xs_3) ->
    try
        I_3 = 0,
        J = (length(Xs_3) - 1),
        Fun_4 = fun Fun_4_loop(I_3, J, Xs_3) ->
    case (I_3 < J) of
        true ->
            T = (case erlang:is_map(Xs_3) of true -> maps:get(I_3, Xs_3, nil); _ -> lists:nth(I_3 + 1, Xs_3) end),
            Xs_4 = lists:sublist(Xs_3, I_3) ++ [(case erlang:is_map(Xs_3) of true -> maps:get(J, Xs_3, nil); _ -> lists:nth(J + 1, Xs_3) end)] ++ lists:nthtail(I_3 + 1, Xs_3),
            Xs_5 = lists:sublist(Xs_4, J) ++ [T] ++ lists:nthtail(J + 1, Xs_4),
            I_4 = (I_3 + 1),
            J_2 = (J - 1),
            Fun_4_loop(I_4, J_2, Xs_5);
        _ -> {I_3, J, Xs_3}
    end
end,
{I_4, J_2, Xs_5} = Fun_4(I_3, J, Xs_3),
        {nil, Xs_5}
    catch {return, Ret} -> Ret end.

perimequal(P1, P2) ->
    try
        case (length(P1) /= length(P2)) of
        true -> throw({return, false});
        _ -> ok
    end,
        Fun_5 = fun Fun_5_loop(List, P1, P2) ->
    case List of
        [] -> {P1, P2};
        [V_2|V_2_rest] ->
            case mochi_not(mochi_member(V_2, P2)) of
        true -> throw({return, false});
        _ -> ok
    end,
            Fun_5_loop(V_2_rest, P1, P2)
    end
end,
{P1, P2} = Fun_5(P1, P1, P2),
        C = copyints(P1),
        R = 0,
        Fun_8 = fun Fun_8_loop(C, P1, P2, R) ->
    case (R < 2) of
        true ->
            I_5 = 0,
            Fun_7 = fun Fun_7_loop(C, I_5, P1, P2, R) ->
    case (I_5 < length(C)) of
        true ->
            case sliceequal(C, P2) of
        true -> throw({return, true});
        _ -> ok
    end,
            T_2 = (case erlang:is_map(C) of true -> maps:get((length(C) - 1), C, nil); _ -> lists:nth((length(C) - 1) + 1, C) end),
            J_3 = (length(C) - 1),
            Fun_6 = fun Fun_6_loop(C, I_5, J_3, P1, P2, R, T_2) ->
    case (J_3 > 0) of
        true ->
            C_2 = lists:sublist(C, J_3) ++ [(case erlang:is_map(C) of true -> maps:get((J_3 - 1), C, nil); _ -> lists:nth((J_3 - 1) + 1, C) end)] ++ lists:nthtail(J_3 + 1, C),
            J_4 = (J_3 - 1),
            Fun_6_loop(C_2, I_5, J_4, P1, P2, R, T_2);
        _ -> {C, I_5, J_3, P1, P2, R, T_2}
    end
end,
{C_2, I_5, J_4, P1, P2, R, T_2} = Fun_6(C, I_5, J_3, P1, P2, R, T_2),
            C_3 = lists:sublist(C_2, 0) ++ [T_2] ++ lists:nthtail(0 + 1, C_2),
            I_6 = (I_5 + 1),
            Fun_7_loop(C_3, I_6, P1, P2, R);
        _ -> {C, I_5, P1, P2, R}
    end
end,
{C_3, I_6, P1, P2, R} = Fun_7(C, I_5, P1, P2, R),
            {_, C_3} = reverse(C_3),
            R_2 = (R + 1),
            Fun_8_loop(C_3, P1, P2, R_2);
        _ -> {C, P1, P2, R}
    end
end,
{C_3, P1, P2, R_2} = Fun_8(C, P1, P2, R),
        {false, }
    catch {return, Ret} -> Ret end.

sortedges(Es) ->
    try
        Arr = Es,
        N = length(Arr),
        I_7 = 0,
        Fun_10 = fun Fun_10_loop(Arr, Es, I_7, N) ->
    case (I_7 < N) of
        true ->
            J_5 = 0,
            Fun_9 = fun Fun_9_loop(Arr, Es, I_7, J_5, N) ->
    case (J_5 < (N - 1)) of
        true ->
            A_2 = (case erlang:is_map(Arr) of true -> maps:get(J_5, Arr, nil); _ -> lists:nth(J_5 + 1, Arr) end),
            B_2 = (case erlang:is_map(Arr) of true -> maps:get((J_5 + 1), Arr, nil); _ -> lists:nth((J_5 + 1) + 1, Arr) end),
            case ((maps:get("a", A_2, nil) > maps:get("a", B_2, nil)) orelse ((maps:get("a", A_2, nil) == maps:get("a", B_2, nil)) andalso (maps:get("b", A_2, nil) > maps:get("b", B_2, nil)))) of
        true -> Arr_2 = lists:sublist(Arr, J_5) ++ [B_2] ++ lists:nthtail(J_5 + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, (J_5 + 1)) ++ [A_2] ++ lists:nthtail((J_5 + 1) + 1, Arr_2),
            Arr_4 = Arr_3;
        _ -> Arr_4 = Arr
    end,
            J_6 = (J_5 + 1),
            Fun_9_loop(Arr_4, Es, I_7, J_6, N);
        _ -> {Arr, Es, I_7, J_5, N}
    end
end,
{Arr_4, Es, I_7, J_6, N} = Fun_9(Arr, Es, I_7, J_5, N),
            I_8 = (I_7 + 1),
            Fun_10_loop(Arr_4, Es, I_8, N);
        _ -> {Arr, Es, I_7, N}
    end
end,
{Arr_4, Es, I_8, N} = Fun_10(Arr, Es, I_7, N),
        Arr_4
    catch {return, Ret} -> Ret end.

concat(A_3, B_3) ->
    try
        Out_3 = [],
        Fun_11 = fun Fun_11_loop(List, A_3, B_3, Out_3) ->
    case List of
        [] -> {A_3, B_3, Out_3};
        [X_3|X_3_rest] ->
            Out_4 = lists:append(Out_3, [X_3]),
            Fun_11_loop(X_3_rest, A_3, B_3, Out_4)
    end
end,
{A_3, B_3, Out_4} = Fun_11(A_3, A_3, B_3, Out_3),
        Fun_12 = fun Fun_12_loop(List, A_3, B_3, Out_4) ->
    case List of
        [] -> {A_3, B_3, Out_4};
        [X_4|X_4_rest] ->
            Out_5 = lists:append(Out_4, [X_4]),
            Fun_12_loop(X_4_rest, A_3, B_3, Out_5)
    end
end,
{A_3, B_3, Out_5} = Fun_12(B_3, A_3, B_3, Out_4),
        Out_5
    catch {return, Ret} -> Ret end.

facetoperim(Face) ->
    try
        Le = length(Face),
        case (Le == 0) of
        true -> throw({return, nil});
        _ -> ok
    end,
        Edges = [],
        I_9 = 0,
        Fun_13 = fun Fun_13_loop(Edges, Face, I_9, Le) ->
    case (I_9 < Le) of
        true ->
            E = (case erlang:is_map(Face) of true -> maps:get(I_9, Face, nil); _ -> lists:nth(I_9 + 1, Face) end),
            case (maps:get("b", E, nil) =< maps:get("a", E, nil)) of
        true -> throw({return, nil});
        _ -> ok
    end,
            Edges_2 = lists:append(Edges, [E]),
            I_10 = (I_9 + 1),
            Fun_13_loop(Edges_2, Face, I_10, Le);
        _ -> {Edges, Face, I_9, Le}
    end
end,
{Edges_2, Face, I_10, Le} = Fun_13(Edges, Face, I_9, Le),
        Edges_3 = sortedges(Edges_2),
        FirstEdge = (case erlang:is_map(Edges_3) of true -> maps:get(0, Edges_3, nil); _ -> lists:nth(0 + 1, Edges_3) end),
        Perim = [maps:get("a", FirstEdge, nil), maps:get("b", FirstEdge, nil)],
        First = maps:get("a", FirstEdge, nil),
        Last = maps:get("b", FirstEdge, nil),
        Edges_4 = lists:sublist(Edges_3, 1 + 1, (length(Edges_3) - 1)),
        Le_2 = length(Edges_4),
        Done = false,
        Fun_15 = fun Fun_15_loop(Done, Edges_4, Face, First, FirstEdge, I_10, Last, Le_2, Perim) ->
    case ((Le_2 > 0) andalso mochi_not(Done)) of
        true ->
            try
                Idx = 0,
                Found = false,
                Fun_14 = fun Fun_14_loop(Done, Edges_4, Face, First, FirstEdge, Found, I_10, Idx, Last, Le_2, Perim) ->
    case (Idx < Le_2) of
        true ->
            try
                E_2 = (case erlang:is_map(Edges_4) of true -> maps:get(Idx, Edges_4, nil); _ -> lists:nth(Idx + 1, Edges_4) end),
                case (maps:get("a", E_2, nil) == Last) of
        true -> Perim_2 = lists:append(Perim, [maps:get("b", E_2, nil)]),
            Last_2 = maps:get("b", E_2, nil),
            Found_2 = true,
            Found_5 = Found_2,
            Last_5 = Last_2,
            Perim_5 = Perim_2;
        _ -> case (maps:get("b", E_2, nil) == Last) of
        true -> Perim_3 = lists:append(Perim, [maps:get("a", E_2, nil)]),
            Last_3 = maps:get("a", E_2, nil),
            Found_3 = true,
            Found_4 = Found_3,
            Last_4 = Last_3,
            Perim_4 = Perim_3;
        _ -> Found_4 = Found,
            Last_4 = Last,
            Perim_4 = Perim
    end,
            Found_5 = Found_4,
            Last_5 = Last_4,
            Perim_5 = Perim_4
    end,
                case Found_5 of
        true -> Edges_5 = concat(lists:sublist(Edges_4, 1, (Idx - 0)), lists:sublist(Edges_4, (Idx + 1) + 1, (length(Edges_4) - (Idx + 1)))),
            Le_3 = (Le_2 - 1),
            case (Last_5 == First) of
        true -> case (Le_3 == 0) of
        true -> Done_2 = true,
            Done_3 = Done_2;
        _ -> throw({return, nil}),
            Done_3 = Done
    end,
            Done_4 = Done_3;
        _ -> Done_4 = Done
    end,
            throw(break),
            Done_5 = Done_4,
            Edges_6 = Edges_5,
            Le_4 = Le_3;
        _ -> Done_5 = Done,
            Edges_6 = Edges_4,
            Le_4 = Le_2
    end,
                Idx_2 = (Idx + 1),
                Fun_14_loop(Done_5, Edges_6, Face, First, FirstEdge, Found_5, I_10, Idx_2, Last_5, Le_4, Perim_5)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10} -> Fun_14_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, C10);
                break -> {Done, Edges_4, Face, First, FirstEdge, Found, I_10, Idx, Last, Le_2, Perim}
            end;
        _ -> {Done, Edges_4, Face, First, FirstEdge, Found, I_10, Idx, Last, Le_2, Perim}
    end
end,
{Done_5, Edges_6, Face, First, FirstEdge, Found_5, I_10, Idx_2, Last_5, Le_4, Perim_5} = Fun_14(Done, Edges_4, Face, First, FirstEdge, Found, I_10, Idx, Last, Le_2, Perim),
                case mochi_not(Found_5) of
        true -> throw({return, nil});
        _ -> ok
    end,
                Fun_15_loop(Done_5, Edges_6, Face, First, FirstEdge, I_10, Last_5, Le_4, Perim_5)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8} -> Fun_15_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8);
                break -> {Done, Edges_4, Face, First, FirstEdge, I_10, Last, Le_2, Perim}
            end;
        _ -> {Done, Edges_4, Face, First, FirstEdge, I_10, Last, Le_2, Perim}
    end
end,
{Done_5, Edges_6, Face, First, FirstEdge, I_10, Last_5, Le_4, Perim_5} = Fun_15(Done, Edges_4, Face, First, FirstEdge, I_10, Last, Le_2, Perim),
        lists:sublist(Perim_5, 1, ((length(Perim_5) - 1) - 0))
    catch {return, Ret} -> Ret end.

liststr(Xs_6) ->
    try
        S = "[",
        I_11 = 0,
        Fun_16 = fun Fun_16_loop(I_11, S, Xs_6) ->
    case (I_11 < length(Xs_6)) of
        true ->
            S_2 = (S ++ lists:flatten(io_lib:format("~p", [(case erlang:is_map(Xs_6) of true -> maps:get(I_11, Xs_6, nil); _ -> lists:nth(I_11 + 1, Xs_6) end)]))),
            case (I_11 < (length(Xs_6) - 1)) of
        true -> S_3 = (S_2 ++ " "),
            S_4 = S_3;
        _ -> S_4 = S_2
    end,
            I_12 = (I_11 + 1),
            Fun_16_loop(I_12, S_4, Xs_6);
        _ -> {I_11, S, Xs_6}
    end
end,
{I_12, S_4, Xs_6} = Fun_16(I_11, S, Xs_6),
        S_5 = (S_4 ++ "]"),
        S_5
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", ["Perimeter format equality checks:"]),
        io:format("~ts~n", [("  Q == R is " ++ lists:flatten(io_lib:format("~p", [perimequal([8, 1, 3], [1, 3, 8])])))]),
        io:format("~ts~n", [("  U == V is " ++ lists:flatten(io_lib:format("~p", [perimequal([18, 8, 14, 10, 12, 17, 19], [8, 14, 10, 12, 17, 19, 18])])))]),
        E_3 = [#{"a" => 7, "b" => 11}, #{"a" => 1, "b" => 11}, #{"a" => 1, "b" => 7}],
        F = [#{"a" => 11, "b" => 23}, #{"a" => 1, "b" => 17}, #{"a" => 17, "b" => 23}, #{"a" => 1, "b" => 11}],
        G = [#{"a" => 8, "b" => 14}, #{"a" => 17, "b" => 19}, #{"a" => 10, "b" => 12}, #{"a" => 10, "b" => 14}, #{"a" => 12, "b" => 17}, #{"a" => 8, "b" => 18}, #{"a" => 18, "b" => 19}],
        H = [#{"a" => 1, "b" => 3}, #{"a" => 9, "b" => 11}, #{"a" => 3, "b" => 11}, #{"a" => 1, "b" => 11}],
        io:format("~ts~n", ["\nEdge to perimeter format translations:"]),
        Faces = [E_3, F, G, H],
        Names = ["E", "F", "G", "H"],
        Idx_3 = 0,
        Fun_17 = fun Fun_17_loop(E_3, F, Faces, G, H, Idx_3, Names) ->
    case (Idx_3 < length(Faces)) of
        true ->
            Per = facetoperim((case erlang:is_map(Faces) of true -> maps:get(Idx_3, Faces, nil); _ -> lists:nth(Idx_3 + 1, Faces) end)),
            case (Per == nil) of
        true -> io:format("~ts~n", [(("  " ++ (case erlang:is_map(Names) of true -> maps:get(Idx_3, Names, nil); _ -> lists:nth(Idx_3 + 1, Names) end)) ++ " => Invalid edge format")]);
        _ -> io:format("~ts~n", [((("  " ++ (case erlang:is_map(Names) of true -> maps:get(Idx_3, Names, nil); _ -> lists:nth(Idx_3 + 1, Names) end)) ++ " => ") ++ liststr(Per))])
    end,
            Idx_4 = (Idx_3 + 1),
            Fun_17_loop(E_3, F, Faces, G, H, Idx_4, Names);
        _ -> {E_3, F, Faces, G, H, Idx_3, Names}
    end
end,
{E_3, F, Faces, G, H, Idx_4, Names} = Fun_17(E_3, F, Faces, G, H, Idx_3, Names),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
