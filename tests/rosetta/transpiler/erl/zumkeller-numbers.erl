#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, getdivisors/1, sum/1, ispartsum/2, iszumkeller/1, pad/2, main/0]).

% Generated by Mochi transpiler v0.10.55 (e4fe673462) on 2025-08-02 20:54 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

getdivisors(N) ->
    try
        Divs = [1, N],
        I = 2,
        Fun = fun Fun_loop(Divs, I, N) ->
    case ((I * I) =< N) of
        true ->
            case ((N rem I) == 0) of
        true -> J = mochi_to_int((N div I)),
            Divs_2 = lists:append(Divs, [I]),
            case (I /= J) of
        true -> Divs_3 = lists:append(Divs_2, [J]),
            Divs_4 = Divs_3;
        _ -> Divs_4 = Divs_2
    end,
            Divs_5 = Divs_4,
            J_2 = J;
        _ -> Divs_5 = Divs,
            J_2 = nil
    end,
            I_2 = (I + 1),
            Fun_loop(Divs_5, I_2, N);
        _ -> {Divs, I, N}
    end
end,
{Divs_5, I_2, N} = Fun(Divs, I, N),
        Divs_5
    catch {return, Ret} -> Ret end.

sum(Xs) ->
    try
        S = 0,
        Fun_2 = fun Fun_2_loop(List, S, Xs) ->
    case List of
        [] -> {S, Xs};
        [X|X_rest] ->
            S_2 = (S + X),
            Fun_2_loop(X_rest, S_2, Xs)
    end
end,
{S_2, Xs} = Fun_2(Xs, S, Xs),
        S_2
    catch {return, Ret} -> Ret end.

ispartsum(Divs_6, Target) ->
    try
        Possible = [],
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Divs_6, I_3, Possible, Target) ->
    case (I_3 =< Target) of
        true ->
            Possible_2 = lists:append(Possible, [false]),
            I_4 = (I_3 + 1),
            Fun_3_loop(Divs_6, I_4, Possible_2, Target);
        _ -> {Divs_6, I_3, Possible, Target}
    end
end,
{Divs_6, I_4, Possible_2, Target} = Fun_3(Divs_6, I_3, Possible, Target),
        Possible_3 = lists:sublist(Possible_2, 0) ++ [true] ++ lists:nthtail(0 + 1, Possible_2),
        Fun_4 = fun Fun_4_loop(List, Divs_6, I_4, Possible_3, Target) ->
    case List of
        [] -> {Divs_6, I_4, Possible_3, Target};
        [V|V_rest] ->
            S_3 = Target,
            Fun_5 = fun Fun_5_loop(Divs_6, I_4, Possible_3, S_3, Target, V) ->
    case (S_3 >= V) of
        true ->
            case (case erlang:is_map(Possible_3) of true -> maps:get((S_3 - V), Possible_3, nil); _ -> lists:nth((S_3 - V) + 1, Possible_3) end) of
        true -> Possible_4 = lists:sublist(Possible_3, S_3) ++ [true] ++ lists:nthtail(S_3 + 1, Possible_3),
            Possible_5 = Possible_4;
        _ -> Possible_5 = Possible_3
    end,
            S_4 = (S_3 - 1),
            Fun_5_loop(Divs_6, I_4, Possible_5, S_4, Target, V);
        _ -> {Divs_6, I_4, Possible_3, S_3, Target, V}
    end
end,
{Divs_6, I_4, Possible_5, S_4, Target, V} = Fun_5(Divs_6, I_4, Possible_3, S_3, Target, V),
            Fun_4_loop(V_rest, Divs_6, I_4, Possible_5, Target)
    end
end,
{Divs_6, I_4, Possible_5, Target} = Fun_4(Divs_6, Divs_6, I_4, Possible_3, Target),
        (case erlang:is_map(Possible_5) of true -> maps:get(Target, Possible_5, nil); _ -> lists:nth(Target + 1, Possible_5) end)
    catch {return, Ret} -> Ret end.

iszumkeller(N_2) ->
    try
        Divs_7 = getdivisors(N_2),
        S_5 = lists:sum(Divs_7),
        case ((S_5 rem 2) == 1) of
        true -> throw({return, false});
        _ -> ok
    end,
        case ((N_2 rem 2) == 1) of
        true -> Abundance = (S_5 - (2 * N_2)),
            throw({return, ((Abundance > 0) andalso ((Abundance rem 2) == 0))}),
            Abundance_2 = Abundance;
        _ -> Abundance_2 = nil
    end,
        ispartsum(Divs_7, (S_5 div 2))
    catch {return, Ret} -> Ret end.

pad(N_3, Width) ->
    try
        S_6 = lists:flatten(io_lib:format("~p", [N_3])),
        Fun_6 = fun Fun_6_loop(N_3, S_6, Width) ->
    case (length(S_6) < Width) of
        true ->
            S_7 = (" " ++ S_6),
            Fun_6_loop(N_3, S_7, Width);
        _ -> {N_3, S_6, Width}
    end
end,
{N_3, S_7, Width} = Fun_6(N_3, S_6, Width),
        S_7
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", ["The first 220 Zumkeller numbers are:"]),
        Count = 0,
        Line = "",
        I_5 = 2,
        Fun_7 = fun Fun_7_loop(Count, I_5, Line) ->
    case (Count < 220) of
        true ->
            case iszumkeller(I_5) of
        true -> Line_2 = ((Line ++ pad(I_5, 3)) ++ " "),
            Count_2 = (Count + 1),
            case ((Count_2 rem 20) == 0) of
        true -> io:format("~ts~n", [string:substr(Line_2, 0 + 1, ((length(Line_2) - 1) - 0))]),
            Line_3 = "",
            Line_4 = Line_3;
        _ -> Line_4 = Line_2
    end,
            Count_3 = Count_2,
            Line_5 = Line_4;
        _ -> Count_3 = Count,
            Line_5 = Line
    end,
            I_6 = (I_5 + 1),
            Fun_7_loop(Count_3, I_6, Line_5);
        _ -> {Count, I_5, Line}
    end
end,
{Count_3, I_6, Line_5} = Fun_7(Count, I_5, Line),
        io:format("~ts~n", ["\nThe first 40 odd Zumkeller numbers are:"]),
        Count_4 = 0,
        Line_6 = "",
        I_7 = 3,
        Fun_8 = fun Fun_8_loop(Count_4, I_7, Line_6) ->
    case (Count_4 < 40) of
        true ->
            case iszumkeller(I_7) of
        true -> Line_7 = ((Line_6 ++ pad(I_7, 5)) ++ " "),
            Count_5 = (Count_4 + 1),
            case ((Count_5 rem 10) == 0) of
        true -> io:format("~ts~n", [string:substr(Line_7, 0 + 1, ((length(Line_7) - 1) - 0))]),
            Line_8 = "",
            Line_9 = Line_8;
        _ -> Line_9 = Line_7
    end,
            Count_6 = Count_5,
            Line_10 = Line_9;
        _ -> Count_6 = Count_4,
            Line_10 = Line_6
    end,
            I_8 = (I_7 + 2),
            Fun_8_loop(Count_6, I_8, Line_10);
        _ -> {Count_4, I_7, Line_6}
    end
end,
{Count_6, I_8, Line_10} = Fun_8(Count_4, I_7, Line_6),
        io:format("~ts~n", ["\nThe first 40 odd Zumkeller numbers which don't end in 5 are:"]),
        Count_7 = 0,
        Line_11 = "",
        I_9 = 3,
        Fun_9 = fun Fun_9_loop(Count_7, I_9, Line_11) ->
    case (Count_7 < 40) of
        true ->
            case (((I_9 rem 10) /= 5) andalso iszumkeller(I_9)) of
        true -> Line_12 = ((Line_11 ++ pad(I_9, 7)) ++ " "),
            Count_8 = (Count_7 + 1),
            case ((Count_8 rem 8) == 0) of
        true -> io:format("~ts~n", [string:substr(Line_12, 0 + 1, ((length(Line_12) - 1) - 0))]),
            Line_13 = "",
            Line_14 = Line_13;
        _ -> Line_14 = Line_12
    end,
            Count_9 = Count_8,
            Line_15 = Line_14;
        _ -> Count_9 = Count_7,
            Line_15 = Line_11
    end,
            I_10 = (I_9 + 2),
            Fun_9_loop(Count_9, I_10, Line_15);
        _ -> {Count_7, I_9, Line_11}
    end
end,
{Count_9, I_10, Line_15} = Fun_9(Count_7, I_9, Line_11),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
