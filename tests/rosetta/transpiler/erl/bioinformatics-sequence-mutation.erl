#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, randint/2, padleft/2, makeseq/2, mutate/3, prettyprint/2, wstring/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (32116ff358) on 2025-07-25 16:40 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_pad_start(S, Len, Ch) ->
    Fill0 = case Ch of
        "" -> " ";
        _ -> Ch
    end,
    Fill = string:substr(Fill0, 1, 1),
    SL = length(S),
    case SL >= Len of
        true -> S;
        _ -> string:copies(Fill, Len - SL) ++ S
    end.

randint(S, N) ->
    try
        Next = (((S * 1664525) + 1013904223) rem 2147483647),
        [Next, (Next rem N)]
    catch {return, Ret} -> Ret end.

padleft(S_2, W) ->
    try
        Res = "",
        N_2 = (W - length(S_2)),
        Fun = fun Fun_loop(N_2, Res, S_2, W) ->
    case (N_2 > 0) of
        true ->
            Res_2 = (Res ++ " "),
            N_3 = (N_2 - 1),
            Fun_loop(N_3, Res_2, S_2, W);
        _ -> {N_2, Res, S_2, W}
    end
end,
{N_3, Res_2, S_2, W} = Fun(N_2, Res, S_2, W),
        (Res_2 ++ S_2)
    catch {return, Ret} -> Ret end.

makeseq(S_3, Le) ->
    try
        Bases = "ACGT",
        Out = "",
        I = 0,
        Fun_2 = fun Fun_2_loop(Bases, I, Le, Out, S_3) ->
    case (I < Le) of
        true ->
            R = randint(S_3, 4),
            S_4 = lists:nth(0 + 1, R),
            Idx = mochi_to_int(lists:nth(1 + 1, R)),
            Out_2 = (Out ++ string:substr(Bases, Idx + 1, ((Idx + 1) - Idx))),
            I_2 = (I + 1),
            Fun_2_loop(Bases, I_2, Le, Out_2, S_4);
        _ -> {Bases, I, Le, Out, S_3}
    end
end,
{Bases, I_2, Le, Out_2, S_4} = Fun_2(Bases, I, Le, Out, S_3),
        [S_4, Out_2]
    catch {return, Ret} -> Ret end.

mutate(S_5, Dna, W_2) ->
    try
        Bases_2 = "ACGT",
        Le_2 = length(Dna),
        R_2 = randint(S_5, Le_2),
        S_6 = lists:nth(0 + 1, R_2),
        P = mochi_to_int(lists:nth(1 + 1, R_2)),
        R_3 = randint(S_6, 300),
        S_7 = lists:nth(0 + 1, R_3),
        X = mochi_to_int(lists:nth(1 + 1, R_3)),
        Arr = [],
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(Arr, Bases_2, Dna, I_3, Le_2, P, R_3, S_7, W_2, X) ->
    case (I_3 < Le_2) of
        true ->
            Arr_2 = lists:append(Arr, [string:substr(Dna, I_3 + 1, ((I_3 + 1) - I_3))]),
            I_4 = (I_3 + 1),
            Fun_3_loop(Arr_2, Bases_2, Dna, I_4, Le_2, P, R_3, S_7, W_2, X);
        _ -> {Arr, Bases_2, Dna, I_3, Le_2, P, R_3, S_7, W_2, X}
    end
end,
{Arr_2, Bases_2, Dna, I_4, Le_2, P, R_3, S_7, W_2, X} = Fun_3(Arr, Bases_2, Dna, I_3, Le_2, P, R_3, S_7, W_2, X),
        case (X < lists:nth(0 + 1, W_2)) of
        true -> R_4 = randint(S_7, 4),
            S_8 = lists:nth(0 + 1, R_4),
            Idx_2 = mochi_to_int(lists:nth(1 + 1, R_4)),
            B = string:substr(Bases_2, Idx_2 + 1, ((Idx_2 + 1) - Idx_2)),
            io:format("~ts~n", [(((((("  Change @" ++ padleft(lists:flatten(io_lib:format("~p", [P])), 3)) ++ " '") ++ lists:nth(P + 1, Arr_2)) ++ "' to '") ++ B) ++ "'")]),
            Arr_3 = lists:sublist(Arr_2, P) ++ [B] ++ lists:nthtail(P + 1, Arr_2),
            Arr_10 = Arr_3,
            B_4 = B,
            Fun_7 = Fun_3,
            Idx_3 = Idx_2,
            Idx2_3 = nil,
            J_6 = nil,
            R_7 = R_4,
            S_11 = S_8;
        _ -> case (X < (lists:nth(0 + 1, W_2) + lists:nth(1 + 1, W_2))) of
        true -> io:format("~ts~n", [(((("  Delete @" ++ padleft(lists:flatten(io_lib:format("~p", [P])), 3)) ++ " '") ++ lists:nth(P + 1, Arr_2)) ++ "'")]),
            J = P,
            Fun_4 = fun Fun_4_loop(Arr_2, Bases_2, Dna, I_4, J, Le_2, P, R_3, S_7, W_2, X) ->
    case (J < (length(Arr_2) - 1)) of
        true ->
            Arr_4 = lists:sublist(Arr_2, J) ++ [lists:nth((J + 1) + 1, Arr_2)] ++ lists:nthtail(J + 1, Arr_2),
            J_2 = (J + 1),
            Fun_4_loop(Arr_4, Bases_2, Dna, I_4, J_2, Le_2, P, R_3, S_7, W_2, X);
        _ -> {Arr_2, Bases_2, Dna, I_4, J, Le_2, P, R_3, S_7, W_2, X}
    end
end,
{Arr_4, Bases_2, Dna, I_4, J_2, Le_2, P, R_3, S_7, W_2, X} = Fun_4(Arr_2, Bases_2, Dna, I_4, J, Le_2, P, R_3, S_7, W_2, X),
            Arr_5 = lists:sublist(Arr_4, 0 + 1, ((length(Arr_4) - 1) - 0)),
            Arr_9 = Arr_5,
            B_3 = nil,
            Fun_6 = Fun_4,
            Idx2_2 = nil,
            J_5 = J_2,
            R_6 = R_3,
            S_10 = S_7;
        _ -> R_5 = randint(S_7, 4),
            S_9 = lists:nth(0 + 1, R_5),
            Idx2 = mochi_to_int(lists:nth(1 + 1, R_5)),
            B_2 = string:substr(Bases_2, Idx2 + 1, ((Idx2 + 1) - Idx2)),
            Arr_6 = lists:append(Arr_2, [""]),
            J_3 = (length(Arr_6) - 1),
            Fun_5 = fun Fun_5_loop(Arr_6, B_2, Bases_2, Dna, I_4, Idx2, J_3, Le_2, P, R_5, S_9, W_2, X) ->
    case (J_3 > P) of
        true ->
            Arr_7 = lists:sublist(Arr_6, J_3) ++ [lists:nth((J_3 - 1) + 1, Arr_6)] ++ lists:nthtail(J_3 + 1, Arr_6),
            J_4 = (J_3 - 1),
            Fun_5_loop(Arr_7, B_2, Bases_2, Dna, I_4, Idx2, J_4, Le_2, P, R_5, S_9, W_2, X);
        _ -> {Arr_6, B_2, Bases_2, Dna, I_4, Idx2, J_3, Le_2, P, R_5, S_9, W_2, X}
    end
end,
{Arr_7, B_2, Bases_2, Dna, I_4, Idx2, J_4, Le_2, P, R_5, S_9, W_2, X} = Fun_5(Arr_6, B_2, Bases_2, Dna, I_4, Idx2, J_3, Le_2, P, R_5, S_9, W_2, X),
            io:format("~ts~n", [(((("  Insert @" ++ padleft(lists:flatten(io_lib:format("~p", [P])), 3)) ++ " '") ++ B_2) ++ "'")]),
            Arr_8 = lists:sublist(Arr_7, P) ++ [B_2] ++ lists:nthtail(P + 1, Arr_7),
            Arr_9 = Arr_8,
            B_3 = B_2,
            Fun_6 = Fun_5,
            Idx2_2 = Idx2,
            J_5 = J_4,
            R_6 = R_5,
            S_10 = S_9
    end,
            Arr_10 = Arr_9,
            B_4 = B_3,
            Fun_7 = Fun_6,
            Idx_3 = nil,
            Idx2_3 = Idx2_2,
            J_6 = J_5,
            R_7 = R_6,
            S_11 = S_10
    end,
        Out_3 = "",
        I_5 = 0,
        Fun_8 = fun Fun_8_loop(Arr_10, B_4, Bases_2, Dna, I_5, Idx_3, Idx2_3, J_6, Le_2, Out_3, P, R_7, S_11, W_2, X) ->
    case (I_5 < length(Arr_10)) of
        true ->
            Out_4 = (Out_3 ++ lists:nth(I_5 + 1, Arr_10)),
            I_6 = (I_5 + 1),
            Fun_8_loop(Arr_10, B_4, Bases_2, Dna, I_6, Idx_3, Idx2_3, J_6, Le_2, Out_4, P, R_7, S_11, W_2, X);
        _ -> {Arr_10, B_4, Bases_2, Dna, I_5, Idx_3, Idx2_3, J_6, Le_2, Out_3, P, R_7, S_11, W_2, X}
    end
end,
{Arr_10, B_4, Bases_2, Dna, I_6, Idx_3, Idx2_3, J_6, Le_2, Out_4, P, R_7, S_11, W_2, X} = Fun_8(Arr_10, B_4, Bases_2, Dna, I_5, Idx_3, Idx2_3, J_6, Le_2, Out_3, P, R_7, S_11, W_2, X),
        [S_11, Out_4]
    catch {return, Ret} -> Ret end.

prettyprint(Dna_2, RowLen) ->
    try
        io:format("~ts~n", ["SEQUENCE:"]),
        Le_3 = length(Dna_2),
        I_7 = 0,
        Fun_9 = fun Fun_9_loop(Dna_2, I_7, Le_3, RowLen) ->
    case (I_7 < Le_3) of
        true ->
            K = (I_7 + RowLen),
            case (K > Le_3) of
        true -> K_2 = Le_3,
            K_3 = K_2;
        _ -> K_3 = K
    end,
            io:format("~ts~n", [((padleft(lists:flatten(io_lib:format("~p", [I_7])), 5) ++ ": ") ++ string:substr(Dna_2, I_7 + 1, (K_3 - I_7)))]),
            I_8 = (I_7 + RowLen),
            Fun_9_loop(Dna_2, I_8, Le_3, RowLen);
        _ -> {Dna_2, I_7, Le_3, RowLen}
    end
end,
{Dna_2, I_8, Le_3, RowLen} = Fun_9(Dna_2, I_7, Le_3, RowLen),
        A = 0,
        C = 0,
        G = 0,
        T = 0,
        Idx_4 = 0,
        Fun_10 = fun Fun_10_loop(A, C, Dna_2, G, I_8, Idx_4, Le_3, RowLen, T) ->
    case (Idx_4 < Le_3) of
        true ->
            Ch = string:substr(Dna_2, Idx_4 + 1, ((Idx_4 + 1) - Idx_4)),
            case (Ch == "A") of
        true -> A_2 = (A + 1),
            A_3 = A_2,
            C_4 = C,
            G_5 = G,
            T_6 = T;
        _ -> case (Ch == "C") of
        true -> C_2 = (C + 1),
            C_3 = C_2,
            G_4 = G,
            T_5 = T;
        _ -> case (Ch == "G") of
        true -> G_2 = (G + 1),
            G_3 = G_2,
            T_4 = T;
        _ -> case (Ch == "T") of
        true -> T_2 = (T + 1),
            T_3 = T_2;
        _ -> T_3 = T
    end,
            G_3 = G,
            T_4 = T_3
    end,
            C_3 = C,
            G_4 = G_3,
            T_5 = T_4
    end,
            A_3 = A,
            C_4 = C_3,
            G_5 = G_4,
            T_6 = T_5
    end,
            Idx_5 = (Idx_4 + 1),
            Fun_10_loop(A_3, C_4, Dna_2, G_5, I_8, Idx_5, Le_3, RowLen, T_6);
        _ -> {A, C, Dna_2, G, I_8, Idx_4, Le_3, RowLen, T}
    end
end,
{A_3, C_4, Dna_2, G_5, I_8, Idx_5, Le_3, RowLen, T_6} = Fun_10(A, C, Dna_2, G, I_8, Idx_4, Le_3, RowLen, T),
        io:format("~ts~n", [""]),
        io:format("~ts~n", ["BASE COUNT:"]),
        io:format("~ts~n", [("    A: " ++ padleft(lists:flatten(io_lib:format("~p", [A_3])), 3))]),
        io:format("~ts~n", [("    C: " ++ padleft(lists:flatten(io_lib:format("~p", [C_4])), 3))]),
        io:format("~ts~n", [("    G: " ++ padleft(lists:flatten(io_lib:format("~p", [G_5])), 3))]),
        io:format("~ts~n", [("    T: " ++ padleft(lists:flatten(io_lib:format("~p", [T_6])), 3))]),
        io:format("~ts~n", ["    ------"]),
        io:format("~ts~n", [("    Σ: " ++ lists:flatten(io_lib:format("~p", [Le_3])))]),
        io:format("~ts~n", ["    ======"]),
        nil
    catch {return, Ret} -> Ret end.

wstring(W_3) ->
    try
        (((((("  Change: " ++ lists:flatten(io_lib:format("~p", [lists:nth(0 + 1, W_3)]))) ++ "\n  Delete: ") ++ lists:flatten(io_lib:format("~p", [lists:nth(1 + 1, W_3)]))) ++ "\n  Insert: ") ++ lists:flatten(io_lib:format("~p", [lists:nth(2 + 1, W_3)]))) ++ "\n")
    catch {return, Ret} -> Ret end.

main() ->
    try
        Seed = 1,
        Res_3 = makeseq(Seed, 250),
        Seed_2 = lists:nth(0 + 1, Res_3),
        Dna_3 = lists:nth(1 + 1, Res_3),
        prettyprint(Dna_3, 50),
        Muts = 10,
        W_4 = [100, 100, 100],
        io:format("~ts~n", ["\nWEIGHTS (ex 300):"]),
        io:format("~p~n", [wstring(W_4)]),
        io:format("~ts~n", [(("MUTATIONS (" ++ lists:flatten(io_lib:format("~p", [10]))) ++ "):")]),
        I_9 = 0,
        Fun_11 = fun Fun_11_loop(Dna_3, I_9, Muts, Res_3, Seed_2, W_4) ->
    case (I_9 < Muts) of
        true ->
            Res_4 = mutate(Seed_2, Dna_3, W_4),
            Seed_3 = lists:nth(0 + 1, Res_4),
            Dna_4 = lists:nth(1 + 1, Res_4),
            I_10 = (I_9 + 1),
            Fun_11_loop(Dna_4, I_10, Muts, Res_4, Seed_3, W_4);
        _ -> {Dna_3, I_9, Muts, Res_3, Seed_2, W_4}
    end
end,
{Dna_4, I_10, Muts, Res_4, Seed_3, W_4} = Fun_11(Dna_3, I_9, Muts, Res_3, Seed_2, W_4),
        io:format("~ts~n", [""]),
        prettyprint(Dna_4, 50),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
