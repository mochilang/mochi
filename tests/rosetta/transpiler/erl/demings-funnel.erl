#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, sqrtapprox/1, funnel/2, mean/1, stddev/1, experiment/2, main/0]).

% Generated by Mochi transpiler v0.10.42 (3cbee11d40) on 2025-07-28 04:43 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

sqrtapprox(X) ->
    try
        case (X =< 0) of
        true -> throw({return, 0});
        _ -> ok
    end,
        G = X,
        I = 0,
        Fun = fun Fun_loop(G, I, X) ->
    case (I < 20) of
        true ->
            G_2 = ((G + (X / G)) / 2),
            I_2 = (I + 1),
            Fun_loop(G_2, I_2, X);
        _ -> {G, I, X}
    end
end,
{G_2, I_2, X} = Fun(G, I, X),
        G_2
    catch {return, Ret} -> Ret end.

funnel(Fa, R) ->
    try
        X_2 = 0,
        Result = [],
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Fa, I_3, R, Result, X_2) ->
    case (I_3 < length(Fa)) of
        true ->
            F = lists:nth(I_3 + 1, Fa),
            Result_2 = lists:append(Result, [(X_2 + F)]),
            X_3 = R(X_2, F),
            I_4 = (I_3 + 1),
            Fun_2_loop(Fa, I_4, R, Result_2, X_3);
        _ -> {Fa, I_3, R, Result, X_2}
    end
end,
{Fa, I_4, R, Result_2, X_3} = Fun_2(Fa, I_3, R, Result, X_2),
        Result_2
    catch {return, Ret} -> Ret end.

mean(Fa_2) ->
    try
        Sum = 0,
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(Fa_2, I_5, Sum) ->
    case (I_5 < length(Fa_2)) of
        true ->
            Sum_2 = (Sum + lists:nth(I_5 + 1, Fa_2)),
            I_6 = (I_5 + 1),
            Fun_3_loop(Fa_2, I_6, Sum_2);
        _ -> {Fa_2, I_5, Sum}
    end
end,
{Fa_2, I_6, Sum_2} = Fun_3(Fa_2, I_5, Sum),
        (Sum_2 / float(length(Fa_2)))
    catch {return, Ret} -> Ret end.

stddev(Fa_3) ->
    try
        M = mean(Fa_3),
        Sum_3 = 0,
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(Fa_3, I_7, M, Sum_3) ->
    case (I_7 < length(Fa_3)) of
        true ->
            D = (lists:nth(I_7 + 1, Fa_3) - M),
            Sum_4 = (Sum_3 + (D * D)),
            I_8 = (I_7 + 1),
            Fun_4_loop(Fa_3, I_8, M, Sum_4);
        _ -> {Fa_3, I_7, M, Sum_3}
    end
end,
{Fa_3, I_8, M, Sum_4} = Fun_4(Fa_3, I_7, M, Sum_3),
        R_2 = sqrtapprox((Sum_4 / float(length(Fa_3)))),
        R_2
    catch {return, Ret} -> Ret end.

experiment(Label, R_3) ->
    try
        Rxs = funnel(erlang:get('dxs'), R_3),
        Rys = funnel(erlang:get('dys'), R_3),
        io:format("~ts~n", [(Label ++ "  :      x        y")]),
        io:format("~ts~n", [((("Mean    :  " ++ lists:flatten(io_lib:format("~p", [mean(Rxs)]))) ++ ", ") ++ lists:flatten(io_lib:format("~p", [mean(Rys)])))]),
        io:format("~ts~n", [((("Std Dev :  " ++ lists:flatten(io_lib:format("~p", [stddev(Rxs)]))) ++ ", ") ++ lists:flatten(io_lib:format("~p", [stddev(Rys)])))]),
        io:format("~ts~n", [""]),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        experiment("Rule 1", fun(X_4, Y) ->
    try
        0
    catch {return, Ret} -> Ret end
end),
        experiment("Rule 2", fun(X_5, Dz) ->
    try
        -Dz
    catch {return, Ret} -> Ret end
end),
        experiment("Rule 3", fun(Z, Dz_2) ->
    try
        -(Z + Dz_2)
    catch {return, Ret} -> Ret end
end),
        experiment("Rule 4", fun(Z_2, Dz_3) ->
    try
        (Z_2 + Dz_3)
    catch {return, Ret} -> Ret end
end),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('dxs', [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915, 2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, 0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423, -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, 0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0, 0.106, 0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, 0.087]),
    erlang:put('dys', [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0, 0.426, 0.205, -0.765, -2.188, -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, 0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, 0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
