#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newterm/2, cfsqrt2/1, cfnap/1, cfpi/1, real/1, main/0]).

% Generated by Mochi transpiler v0.10.41 (4e0e7fcd7f) on 2025-07-26 23:05 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

newterm(A, B) ->
    try
        #{"a" => A, "b" => B}
    catch {return, Ret} -> Ret end.

cfsqrt2(NTerms) ->
    try
        F = [],
        N = 0,
        Fun = fun Fun_loop(F, N, NTerms) ->
    case (N < NTerms) of
        true ->
            F_2 = lists:append(F, [newterm(2, 1)]),
            N_2 = (N + 1),
            Fun_loop(F_2, N_2, NTerms);
        _ -> {F, N, NTerms}
    end
end,
{F_2, N_2, NTerms} = Fun(F, N, NTerms),
        case (NTerms > 0) of
        true -> Tmp = lists:nth(0 + 1, F_2),
            Tmp_2 = maps:put("a", 1, Tmp),
            F_3 = lists:sublist(F_2, 0) ++ [Tmp_2] ++ lists:nthtail(0 + 1, F_2),
            F_4 = F_3,
            Tmp_3 = Tmp_2;
        _ -> F_4 = F_2,
            Tmp_3 = nil
    end,
        F_4
    catch {return, Ret} -> Ret end.

cfnap(NTerms_2) ->
    try
        F_5 = [],
        N_3 = 0,
        Fun_2 = fun Fun_2_loop(F_5, N_3, NTerms_2) ->
    case (N_3 < NTerms_2) of
        true ->
            F_6 = lists:append(F_5, [newterm(N_3, (N_3 - 1))]),
            N_4 = (N_3 + 1),
            Fun_2_loop(F_6, N_4, NTerms_2);
        _ -> {F_5, N_3, NTerms_2}
    end
end,
{F_6, N_4, NTerms_2} = Fun_2(F_5, N_3, NTerms_2),
        case (NTerms_2 > 0) of
        true -> Tmp_4 = lists:nth(0 + 1, F_6),
            Tmp_5 = maps:put("a", 2, Tmp_4),
            F_7 = lists:sublist(F_6, 0) ++ [Tmp_5] ++ lists:nthtail(0 + 1, F_6),
            F_8 = F_7,
            Tmp_6 = Tmp_5;
        _ -> F_8 = F_6,
            Tmp_6 = nil
    end,
        case (NTerms_2 > 1) of
        true -> Tmp_7 = lists:nth(1 + 1, F_8),
            Tmp_8 = maps:put("b", 1, Tmp_7),
            F_9 = lists:sublist(F_8, 1) ++ [Tmp_8] ++ lists:nthtail(1 + 1, F_8),
            F_10 = F_9,
            Tmp_9 = Tmp_8;
        _ -> F_10 = F_8,
            Tmp_9 = Tmp_6
    end,
        F_10
    catch {return, Ret} -> Ret end.

cfpi(NTerms_3) ->
    try
        F_11 = [],
        N_5 = 0,
        Fun_3 = fun Fun_3_loop(F_11, N_5, NTerms_3) ->
    case (N_5 < NTerms_3) of
        true ->
            G = ((2 * N_5) - 1),
            F_12 = lists:append(F_11, [newterm(6, (G * G))]),
            N_6 = (N_5 + 1),
            Fun_3_loop(F_12, N_6, NTerms_3);
        _ -> {F_11, N_5, NTerms_3}
    end
end,
{F_12, N_6, NTerms_3} = Fun_3(F_11, N_5, NTerms_3),
        case (NTerms_3 > 0) of
        true -> Tmp_10 = lists:nth(0 + 1, F_12),
            Tmp_11 = maps:put("a", 3, Tmp_10),
            F_13 = lists:sublist(F_12, 0) ++ [Tmp_11] ++ lists:nthtail(0 + 1, F_12),
            F_14 = F_13,
            Tmp_12 = Tmp_11;
        _ -> F_14 = F_12,
            Tmp_12 = nil
    end,
        F_14
    catch {return, Ret} -> Ret end.

real(F_15) ->
    try
        R = 0,
        I = (length(F_15) - 1),
        Fun_4 = fun Fun_4_loop(F_15, I, R) ->
    case (I > 0) of
        true ->
            R_2 = (float(maps:get("b", lists:nth(I + 1, F_15), nil)) / (float(maps:get("a", lists:nth(I + 1, F_15), nil)) + R)),
            I_2 = (I - 1),
            Fun_4_loop(F_15, I_2, R_2);
        _ -> {F_15, I, R}
    end
end,
{F_15, I_2, R_2} = Fun_4(F_15, I, R),
        case (length(F_15) > 0) of
        true -> R_3 = (R_2 + float(maps:get("a", lists:nth(0 + 1, F_15), nil))),
            R_4 = R_3;
        _ -> R_4 = R_2
    end,
        R_4
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", [("sqrt2: " ++ lists:flatten(io_lib:format("~p", [real(cfsqrt2(20))])))]),
        io:format("~ts~n", [("nap:   " ++ lists:flatten(io_lib:format("~p", [real(cfnap(20))])))]),
        io:format("~ts~n", [("pi:    " ++ lists:flatten(io_lib:format("~p", [real(cfpi(20))])))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
