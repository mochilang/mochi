#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newPile/1, handlePile/3, drawPile/2, main/0]).

% Generated by Mochi transpiler v0.10.38 (0a4e3506ef) on 2025-07-23 20:13 +0700

newPile(D) ->
    try
        B = [],
        Y = 0,
        Fun2 = fun Fun2_loop(B, D, Y) ->
    case (Y < D) of
        true ->
            try
                Row = [],
                X = 0,
                Fun = fun Fun_loop(B, D, Row, X, Y) ->
    case (X < D) of
        true ->
            try
                Row2 = lists:append(Row, [0]),
                X2 = (X + 1),
                Fun_loop(B, D, Row2, X2, Y)
            catch
                break -> {B, D, Row, X, Y}
            end;
        _ -> {B, D, Row, X, Y}
    end
end,
{B, D, Row2, X2, Y} = Fun(B, D, Row, X, Y),
                B2 = lists:append(B, [Row2]),
                Y2 = (Y + 1),
                Fun2_loop(B2, D, Y2)
            catch
                break -> {B, D, Y}
            end;
        _ -> {B, D, Y}
    end
end,
{B2, D, Y2} = Fun2(B, D, Y),
        B2
    catch {return, V} -> V end.

handlePile(Pile, X3, Y3) ->
    try
        case (lists:nth(X3 + 1, lists:nth(Y3 + 1, Pile)) >= 4) of
        true -> Tmp = lists:nth(Y3 + 1, Pile),
            Tmp2 = lists:sublist(Tmp, X3) ++ [(lists:nth(X3 + 1, lists:nth(Y3 + 1, Pile)) - 4)] ++ lists:nthtail(X3 + 1, Tmp),
            Pile2 = lists:sublist(Pile, Y3) ++ [Tmp2] ++ lists:nthtail(Y3 + 1, Pile),
            case (Y3 > 0) of
        true -> Tmp3 = lists:nth((Y3 - 1) + 1, Pile2),
            Tmp4 = lists:sublist(Tmp3, X3) ++ [(lists:nth(X3 + 1, lists:nth((Y3 - 1) + 1, Pile2)) + 1)] ++ lists:nthtail(X3 + 1, Tmp3),
            Pile3 = lists:sublist(Pile2, (Y3 - 1)) ++ [Tmp4] ++ lists:nthtail((Y3 - 1) + 1, Pile2),
            case (lists:nth(X3 + 1, lists:nth((Y3 - 1) + 1, Pile3)) >= 4) of
        true -> Pile4 = handlePile(Pile3, X3, (Y3 - 1)),
            Pile5 = Pile4;
        _ -> Pile5 = Pile3
    end,
            Pile6 = Pile5,
            Tmp5 = Tmp4;
        _ -> Pile6 = Pile2,
            Tmp5 = Tmp2
    end,
            case (X3 > 0) of
        true -> Tmp6 = lists:nth(Y3 + 1, Pile6),
            Tmp7 = lists:sublist(Tmp6, (X3 - 1)) ++ [(lists:nth((X3 - 1) + 1, lists:nth(Y3 + 1, Pile6)) + 1)] ++ lists:nthtail((X3 - 1) + 1, Tmp6),
            Pile7 = lists:sublist(Pile6, Y3) ++ [Tmp7] ++ lists:nthtail(Y3 + 1, Pile6),
            case (lists:nth((X3 - 1) + 1, lists:nth(Y3 + 1, Pile7)) >= 4) of
        true -> Pile8 = handlePile(Pile7, (X3 - 1), Y3),
            Pile9 = Pile8;
        _ -> Pile9 = Pile7
    end,
            Pile10 = Pile9,
            Tmp8 = Tmp7;
        _ -> Pile10 = Pile6,
            Tmp8 = Tmp5
    end,
            case (Y3 < (16 - 1)) of
        true -> Tmp9 = lists:nth((Y3 + 1) + 1, Pile10),
            Tmp10 = lists:sublist(Tmp9, X3) ++ [(lists:nth(X3 + 1, lists:nth((Y3 + 1) + 1, Pile10)) + 1)] ++ lists:nthtail(X3 + 1, Tmp9),
            Pile11 = lists:sublist(Pile10, (Y3 + 1)) ++ [Tmp10] ++ lists:nthtail((Y3 + 1) + 1, Pile10),
            case (lists:nth(X3 + 1, lists:nth((Y3 + 1) + 1, Pile11)) >= 4) of
        true -> Pile12 = handlePile(Pile11, X3, (Y3 + 1)),
            Pile13 = Pile12;
        _ -> Pile13 = Pile11
    end,
            Pile14 = Pile13,
            Tmp11 = Tmp10;
        _ -> Pile14 = Pile10,
            Tmp11 = Tmp8
    end,
            case (X3 < (16 - 1)) of
        true -> Tmp12 = lists:nth(Y3 + 1, Pile14),
            Tmp13 = lists:sublist(Tmp12, (X3 + 1)) ++ [(lists:nth((X3 + 1) + 1, lists:nth(Y3 + 1, Pile14)) + 1)] ++ lists:nthtail((X3 + 1) + 1, Tmp12),
            Pile15 = lists:sublist(Pile14, Y3) ++ [Tmp13] ++ lists:nthtail(Y3 + 1, Pile14),
            case (lists:nth((X3 + 1) + 1, lists:nth(Y3 + 1, Pile15)) >= 4) of
        true -> Pile16 = handlePile(Pile15, (X3 + 1), Y3),
            Pile17 = Pile16;
        _ -> Pile17 = Pile15
    end,
            Pile18 = Pile17,
            Tmp14 = Tmp13;
        _ -> Pile18 = Pile14,
            Tmp14 = Tmp11
    end,
            Pile19 = handlePile(Pile18, X3, Y3),
            Pile20 = Pile19,
            Tmp15 = Tmp14;
        _ -> Pile20 = Pile,
            Tmp15 = nil
    end,
        Pile20
    catch {return, V} -> V end.

drawPile(Pile21, D2) ->
    try
        Chars = [" ", "░", "▓", "█"],
        Row3 = 0,
        Fun4 = fun Fun4_loop(Chars, D2, Pile21, Row3) ->
    case (Row3 < D2) of
        true ->
            try
                Line = "",
                Col = 0,
                Fun3 = fun Fun3_loop(Chars, Col, D2, Line, Pile21, Row3) ->
    case (Col < D2) of
        true ->
            try
                V = lists:nth(Col + 1, lists:nth(Row3 + 1, Pile21)),
                case (V > 3) of
        true -> V2 = 3,
            V3 = V2;
        _ -> V3 = V
    end,
                Line2 = (Line ++ lists:nth(V3 + 1, Chars)),
                Col2 = (Col + 1),
                Fun3_loop(Chars, Col2, D2, Line2, Pile21, Row3)
            catch
                break -> {Chars, Col, D2, Line, Pile21, Row3}
            end;
        _ -> {Chars, Col, D2, Line, Pile21, Row3}
    end
end,
{Chars, Col2, D2, Line2, Pile21, Row3} = Fun3(Chars, Col, D2, Line, Pile21, Row3),
                io:format("~ts~n", [Line2]),
                Row4 = (Row3 + 1),
                Fun4_loop(Chars, D2, Pile21, Row4)
            catch
                break -> {Chars, D2, Pile21, Row3}
            end;
        _ -> {Chars, D2, Pile21, Row3}
    end
end,
{Chars, D2, Pile21, Row4} = Fun4(Chars, D2, Pile21, Row3),
        nil
    catch {return, V} -> V end.

main() ->
    try
        Pile22 = newPile(16),
        Hdim = 7,
        Tmp16 = lists:nth(7 + 1, Pile22),
        Tmp17 = lists:sublist(Tmp16, 7) ++ [16] ++ lists:nthtail(7 + 1, Tmp16),
        Pile23 = lists:sublist(Pile22, 7) ++ [Tmp17] ++ lists:nthtail(7 + 1, Pile22),
        Pile24 = handlePile(Pile23, 7, 7),
        drawPile(Pile24, 16),
        nil
    catch {return, V} -> V end.

main(_) ->
    erlang:put('dim', 16),
    main().
