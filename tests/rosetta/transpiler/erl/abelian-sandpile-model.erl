#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newpile/1, handlepile/3, drawpile/2, main/0]).

% Generated by Mochi transpiler v0.10.40 (c9f97e1bd3) on 2025-07-25 19:21 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

newpile(D) ->
    try
        B = [],
        Y = 0,
        Fun_2 = fun Fun_2_loop(B, D, Y) ->
    case (Y < D) of
        true ->
            Row = [],
            X = 0,
            Fun = fun Fun_loop(B, D, Row, X, Y) ->
    case (X < D) of
        true ->
            Row_2 = lists:append(Row, [0]),
            X_2 = (X + 1),
            Fun_loop(B, D, Row_2, X_2, Y);
        _ -> {B, D, Row, X, Y}
    end
end,
{B, D, Row_2, X_2, Y} = Fun(B, D, Row, X, Y),
            B_2 = lists:append(B, [Row_2]),
            Y_2 = (Y + 1),
            Fun_2_loop(B_2, D, Y_2);
        _ -> {B, D, Y}
    end
end,
{B_2, D, Y_2} = Fun_2(B, D, Y),
        B_2
    catch {return, Ret} -> Ret end.

handlepile(Pile, X_3, Y_3) ->
    try
        case (lists:nth(X_3 + 1, lists:nth(Y_3 + 1, Pile)) >= 4) of
        true -> Tmp = lists:nth(Y_3 + 1, Pile),
            Tmp_2 = lists:sublist(Tmp, X_3) ++ [(lists:nth(X_3 + 1, lists:nth(Y_3 + 1, Pile)) - 4)] ++ lists:nthtail(X_3 + 1, Tmp),
            Pile_2 = lists:sublist(Pile, Y_3) ++ [Tmp_2] ++ lists:nthtail(Y_3 + 1, Pile),
            case (Y_3 > 0) of
        true -> Tmp_3 = lists:nth((Y_3 - 1) + 1, Pile_2),
            Tmp_4 = lists:sublist(Tmp_3, X_3) ++ [(lists:nth(X_3 + 1, lists:nth((Y_3 - 1) + 1, Pile_2)) + 1)] ++ lists:nthtail(X_3 + 1, Tmp_3),
            Pile_3 = lists:sublist(Pile_2, (Y_3 - 1)) ++ [Tmp_4] ++ lists:nthtail((Y_3 - 1) + 1, Pile_2),
            case (lists:nth(X_3 + 1, lists:nth((Y_3 - 1) + 1, Pile_3)) >= 4) of
        true -> Pile_4 = handlepile(Pile_3, X_3, (Y_3 - 1)),
            Pile_5 = Pile_4;
        _ -> Pile_5 = Pile_3
    end,
            Pile_6 = Pile_5,
            Tmp_5 = Tmp_4;
        _ -> Pile_6 = Pile_2,
            Tmp_5 = Tmp_2
    end,
            case (X_3 > 0) of
        true -> Tmp_6 = lists:nth(Y_3 + 1, Pile_6),
            Tmp_7 = lists:sublist(Tmp_6, (X_3 - 1)) ++ [(lists:nth((X_3 - 1) + 1, lists:nth(Y_3 + 1, Pile_6)) + 1)] ++ lists:nthtail((X_3 - 1) + 1, Tmp_6),
            Pile_7 = lists:sublist(Pile_6, Y_3) ++ [Tmp_7] ++ lists:nthtail(Y_3 + 1, Pile_6),
            case (lists:nth((X_3 - 1) + 1, lists:nth(Y_3 + 1, Pile_7)) >= 4) of
        true -> Pile_8 = handlepile(Pile_7, (X_3 - 1), Y_3),
            Pile_9 = Pile_8;
        _ -> Pile_9 = Pile_7
    end,
            Pile_10 = Pile_9,
            Tmp_8 = Tmp_7;
        _ -> Pile_10 = Pile_6,
            Tmp_8 = Tmp_5
    end,
            case (Y_3 < (16 - 1)) of
        true -> Tmp_9 = lists:nth((Y_3 + 1) + 1, Pile_10),
            Tmp_10 = lists:sublist(Tmp_9, X_3) ++ [(lists:nth(X_3 + 1, lists:nth((Y_3 + 1) + 1, Pile_10)) + 1)] ++ lists:nthtail(X_3 + 1, Tmp_9),
            Pile_11 = lists:sublist(Pile_10, (Y_3 + 1)) ++ [Tmp_10] ++ lists:nthtail((Y_3 + 1) + 1, Pile_10),
            case (lists:nth(X_3 + 1, lists:nth((Y_3 + 1) + 1, Pile_11)) >= 4) of
        true -> Pile_12 = handlepile(Pile_11, X_3, (Y_3 + 1)),
            Pile_13 = Pile_12;
        _ -> Pile_13 = Pile_11
    end,
            Pile_14 = Pile_13,
            Tmp_11 = Tmp_10;
        _ -> Pile_14 = Pile_10,
            Tmp_11 = Tmp_8
    end,
            case (X_3 < (16 - 1)) of
        true -> Tmp_12 = lists:nth(Y_3 + 1, Pile_14),
            Tmp_13 = lists:sublist(Tmp_12, (X_3 + 1)) ++ [(lists:nth((X_3 + 1) + 1, lists:nth(Y_3 + 1, Pile_14)) + 1)] ++ lists:nthtail((X_3 + 1) + 1, Tmp_12),
            Pile_15 = lists:sublist(Pile_14, Y_3) ++ [Tmp_13] ++ lists:nthtail(Y_3 + 1, Pile_14),
            case (lists:nth((X_3 + 1) + 1, lists:nth(Y_3 + 1, Pile_15)) >= 4) of
        true -> Pile_16 = handlepile(Pile_15, (X_3 + 1), Y_3),
            Pile_17 = Pile_16;
        _ -> Pile_17 = Pile_15
    end,
            Pile_18 = Pile_17,
            Tmp_14 = Tmp_13;
        _ -> Pile_18 = Pile_14,
            Tmp_14 = Tmp_11
    end,
            Pile_19 = handlepile(Pile_18, X_3, Y_3),
            Pile_20 = Pile_19,
            Tmp_15 = Tmp_14;
        _ -> Pile_20 = Pile,
            Tmp_15 = nil
    end,
        Pile_20
    catch {return, Ret} -> Ret end.

drawpile(Pile_21, D_2) ->
    try
        Chars = [" ", "░", "▓", "█"],
        Row_3 = 0,
        Fun_4 = fun Fun_4_loop(Chars, D_2, Pile_21, Row_3) ->
    case (Row_3 < D_2) of
        true ->
            Line = "",
            Col = 0,
            Fun_3 = fun Fun_3_loop(Chars, Col, D_2, Line, Pile_21, Row_3) ->
    case (Col < D_2) of
        true ->
            V = lists:nth(Col + 1, lists:nth(Row_3 + 1, Pile_21)),
            case (V > 3) of
        true -> V_2 = 3,
            V_3 = V_2;
        _ -> V_3 = V
    end,
            Line_2 = (Line ++ lists:nth(V_3 + 1, Chars)),
            Col_2 = (Col + 1),
            Fun_3_loop(Chars, Col_2, D_2, Line_2, Pile_21, Row_3);
        _ -> {Chars, Col, D_2, Line, Pile_21, Row_3}
    end
end,
{Chars, Col_2, D_2, Line_2, Pile_21, Row_3} = Fun_3(Chars, Col, D_2, Line, Pile_21, Row_3),
            io:format("~ts~n", [Line_2]),
            Row_4 = (Row_3 + 1),
            Fun_4_loop(Chars, D_2, Pile_21, Row_4);
        _ -> {Chars, D_2, Pile_21, Row_3}
    end
end,
{Chars, D_2, Pile_21, Row_4} = Fun_4(Chars, D_2, Pile_21, Row_3),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        Pile_22 = newpile(16),
        Hdim = 7,
        Tmp_16 = lists:nth(7 + 1, Pile_22),
        Tmp_17 = lists:sublist(Tmp_16, 7) ++ [16] ++ lists:nthtail(7 + 1, Tmp_16),
        Pile_23 = lists:sublist(Pile_22, 7) ++ [Tmp_17] ++ lists:nthtail(7 + 1, Pile_22),
        Pile_24 = handlepile(Pile_23, 7, 7),
        drawpile(Pile_24, 16),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('dim', 16),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
