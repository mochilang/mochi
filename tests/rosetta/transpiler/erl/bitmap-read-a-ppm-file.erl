#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, newbitmap/3, setpx/4, getpx/3, splitlines/1, splitws/1, parseintstr/1, tokenize/1, readp3/1, togrey/1, pad/2, writep3/1]).

% Generated by Mochi transpiler v0.10.40 (e0c44791e6) on 2025-07-25 18:01 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

newbitmap(W, H, Max) ->
    try
        Rows = [],
        Y = 0,
        Fun_2 = fun Fun_2_loop(H, Max, Rows, W, Y) ->
    case (Y < H) of
        true ->
            Row = [],
            X = 0,
            Fun = fun Fun_loop(H, Max, Row, Rows, W, X, Y) ->
    case (X < W) of
        true ->
            Row_2 = lists:append(Row, [#{"R" => 0, "G" => 0, "B" => 0}]),
            X_2 = (X + 1),
            Fun_loop(H, Max, Row_2, Rows, W, X_2, Y);
        _ -> {H, Max, Row, Rows, W, X, Y}
    end
end,
{H, Max, Row_2, Rows, W, X_2, Y} = Fun(H, Max, Row, Rows, W, X, Y),
            Rows_2 = lists:append(Rows, [Row_2]),
            Y_2 = (Y + 1),
            Fun_2_loop(H, Max, Rows_2, W, Y_2);
        _ -> {H, Max, Rows, W, Y}
    end
end,
{H, Max, Rows_2, W, Y_2} = Fun_2(H, Max, Rows, W, Y),
        #{"w" => W, "h" => H, "max" => Max, "data" => Rows_2}
    catch {return, Ret} -> Ret end.

setpx(B, X_3, Y_3, P) ->
    try
        Rows_3 = maps:get("data", B, nil),
        Row_3 = lists:nth(Y_3 + 1, Rows_3),
        Row_4 = lists:sublist(Row_3, X_3) ++ [P] ++ lists:nthtail(X_3 + 1, Row_3),
        Rows_4 = lists:sublist(Rows_3, Y_3) ++ [Row_4] ++ lists:nthtail(Y_3 + 1, Rows_3),
        B_2 = maps:put("data", Rows_4, B),
        B_2
    catch {return, Ret} -> Ret end.

getpx(B_3, X_4, Y_4) ->
    try
        lists:nth(X_4 + 1, lists:nth(Y_4 + 1, maps:get("data", B_3, nil)))
    catch {return, Ret} -> Ret end.

splitlines(S) ->
    try
        Out = [],
        Cur = "",
        I = 0,
        Fun_3 = fun Fun_3_loop(Cur, I, Out, S) ->
    case (I < length(S)) of
        true ->
            Ch = string:substr(S, I + 1, ((I + 1) - I)),
            case (Ch == "\n") of
        true -> Out_2 = lists:append(Out, [Cur]),
            Cur_2 = "",
            Cur_4 = Cur_2,
            Out_3 = Out_2;
        _ -> Cur_3 = (Cur ++ Ch),
            Cur_4 = Cur_3,
            Out_3 = Out
    end,
            I_2 = (I + 1),
            Fun_3_loop(Cur_4, I_2, Out_3, S);
        _ -> {Cur, I, Out, S}
    end
end,
{Cur_4, I_2, Out_3, S} = Fun_3(Cur, I, Out, S),
        Out_4 = lists:append(Out_3, [Cur_4]),
        Out_4
    catch {return, Ret} -> Ret end.

splitws(S_2) ->
    try
        Out_5 = [],
        Cur_5 = "",
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(Cur_5, I_3, Out_5, S_2) ->
    case (I_3 < length(S_2)) of
        true ->
            Ch_2 = string:substr(S_2, I_3 + 1, ((I_3 + 1) - I_3)),
            case ((((Ch_2 == " ") orelse (Ch_2 == "\t")) orelse (Ch_2 == "\r")) orelse (Ch_2 == "\n")) of
        true -> case (length(Cur_5) > 0) of
        true -> Out_6 = lists:append(Out_5, [Cur_5]),
            Cur_6 = "",
            Cur_7 = Cur_6,
            Out_7 = Out_6;
        _ -> Cur_7 = Cur_5,
            Out_7 = Out_5
    end,
            Cur_9 = Cur_7,
            Out_8 = Out_7;
        _ -> Cur_8 = (Cur_5 ++ Ch_2),
            Cur_9 = Cur_8,
            Out_8 = Out_5
    end,
            I_4 = (I_3 + 1),
            Fun_4_loop(Cur_9, I_4, Out_8, S_2);
        _ -> {Cur_5, I_3, Out_5, S_2}
    end
end,
{Cur_9, I_4, Out_8, S_2} = Fun_4(Cur_5, I_3, Out_5, S_2),
        case (length(Cur_9) > 0) of
        true -> Out_9 = lists:append(Out_8, [Cur_9]),
            Out_10 = Out_9;
        _ -> Out_10 = Out_8
    end,
        Out_10
    catch {return, Ret} -> Ret end.

parseintstr(Str) ->
    try
        I_5 = 0,
        Neg = false,
        case ((length(Str) > 0) andalso (string:substr(Str, 0 + 1, (1 - 0)) == "-")) of
        true -> Neg_2 = true,
            I_6 = 1,
            I_7 = I_6,
            Neg_3 = Neg_2;
        _ -> I_7 = I_5,
            Neg_3 = Neg
    end,
        N = 0,
        Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
        Fun_5 = fun Fun_5_loop(Digits, I_7, N, Neg_3, Str) ->
    case (I_7 < length(Str)) of
        true ->
            N_2 = ((N * 10) + maps:get(string:substr(Str, I_7 + 1, ((I_7 + 1) - I_7)), Digits, nil)),
            I_8 = (I_7 + 1),
            Fun_5_loop(Digits, I_8, N_2, Neg_3, Str);
        _ -> {Digits, I_7, N, Neg_3, Str}
    end
end,
{Digits, I_8, N_2, Neg_3, Str} = Fun_5(Digits, I_7, N, Neg_3, Str),
        case Neg_3 of
        true -> N_3 = -N_2,
            N_4 = N_3;
        _ -> N_4 = N_2
    end,
        N_4
    catch {return, Ret} -> Ret end.

tokenize(S_3) ->
    try
        Lines = splitlines(S_3),
        Toks = [],
        I_9 = 0,
        Fun_7 = fun Fun_7_loop(I_9, Lines, S_3, Toks) ->
    case (I_9 < length(Lines)) of
        true ->
            try
                Line = lists:nth(I_9 + 1, Lines),
                case ((length(Line) > 0) andalso (string:substr(Line, 0 + 1, (1 - 0)) == "#")) of
        true -> I_10 = (I_9 + 1),
            throw({continue, I_10, Lines, S_3, Toks}),
            I_11 = I_10;
        _ -> I_11 = I_9
    end,
                Parts = splitws(Line),
                J = 0,
                Fun_6 = fun Fun_6_loop(I_11, J, Line, Lines, Parts, S_3, Toks) ->
    case (J < length(Parts)) of
        true ->
            Toks_2 = lists:append(Toks, [lists:nth(J + 1, Parts)]),
            J_2 = (J + 1),
            Fun_6_loop(I_11, J_2, Line, Lines, Parts, S_3, Toks_2);
        _ -> {I_11, J, Line, Lines, Parts, S_3, Toks}
    end
end,
{I_11, J_2, Line, Lines, Parts, S_3, Toks_2} = Fun_6(I_11, J, Line, Lines, Parts, S_3, Toks),
                I_12 = (I_11 + 1),
                Fun_7_loop(I_12, Lines, S_3, Toks_2)
            catch
                {continue, C0, C1, C2, C3} -> Fun_7_loop(C0, C1, C2, C3);
                break -> {I_9, Lines, S_3, Toks}
            end;
        _ -> {I_9, Lines, S_3, Toks}
    end
end,
{I_12, Lines, S_3, Toks_2} = Fun_7(I_9, Lines, S_3, Toks),
        Toks_2
    catch {return, Ret} -> Ret end.

readp3(Text) ->
    try
        Toks_3 = tokenize(Text),
        case (length(Toks_3) < 4) of
        true -> throw({return, newbitmap(0, 0, 0)});
        _ -> ok
    end,
        case (lists:nth(0 + 1, Toks_3) /= "P3") of
        true -> throw({return, newbitmap(0, 0, 0)});
        _ -> ok
    end,
        W_2 = parseintstr(lists:nth(1 + 1, Toks_3)),
        H_2 = parseintstr(lists:nth(2 + 1, Toks_3)),
        Maxv = parseintstr(lists:nth(3 + 1, Toks_3)),
        Idx = 4,
        Bm = newbitmap(W_2, H_2, Maxv),
        Y_5 = (H_2 - 1),
        Fun_9 = fun Fun_9_loop(Bm, H_2, Idx, Maxv, Text, Toks_3, W_2, Y_5) ->
    case (Y_5 >= 0) of
        true ->
            X_5 = 0,
            Fun_8 = fun Fun_8_loop(Bm, H_2, Idx, Maxv, Text, Toks_3, W_2, X_5, Y_5) ->
    case (X_5 < W_2) of
        true ->
            R = parseintstr(lists:nth(Idx + 1, Toks_3)),
            G = parseintstr(lists:nth((Idx + 1) + 1, Toks_3)),
            B_4 = parseintstr(lists:nth((Idx + 2) + 1, Toks_3)),
            setpx(Bm, X_5, Y_5, #{"R" => R, "G" => G, "B" => B_4}),
            Idx_2 = (Idx + 3),
            X_6 = (X_5 + 1),
            Fun_8_loop(Bm, H_2, Idx_2, Maxv, Text, Toks_3, W_2, X_6, Y_5);
        _ -> {Bm, H_2, Idx, Maxv, Text, Toks_3, W_2, X_5, Y_5}
    end
end,
{Bm, H_2, Idx_2, Maxv, Text, Toks_3, W_2, X_6, Y_5} = Fun_8(Bm, H_2, Idx, Maxv, Text, Toks_3, W_2, X_5, Y_5),
            Y_6 = (Y_5 - 1),
            Fun_9_loop(Bm, H_2, Idx_2, Maxv, Text, Toks_3, W_2, Y_6);
        _ -> {Bm, H_2, Idx, Maxv, Text, Toks_3, W_2, Y_5}
    end
end,
{Bm, H_2, Idx_2, Maxv, Text, Toks_3, W_2, Y_6} = Fun_9(Bm, H_2, Idx, Maxv, Text, Toks_3, W_2, Y_5),
        Bm
    catch {return, Ret} -> Ret end.

togrey(B_5) ->
    try
        H_3 = maps:get("h", B_5, nil),
        W_3 = maps:get("w", B_5, nil),
        M = 0,
        Y_7 = 0,
        Fun_11 = fun Fun_11_loop(B_5, H_3, M, W_3, Y_7) ->
    case (Y_7 < H_3) of
        true ->
            X_7 = 0,
            Fun_10 = fun Fun_10_loop(B_5, H_3, M, W_3, X_7, Y_7) ->
    case (X_7 < W_3) of
        true ->
            P_2 = getpx(B_5, X_7, Y_7),
            L = ((((maps:get("R", P_2, nil) * 2126) + (maps:get("G", P_2, nil) * 7152)) + (maps:get("B", P_2, nil) * 722)) div 10000),
            case (L > maps:get("max", B_5, nil)) of
        true -> L_2 = maps:get("max", B_5, nil),
            L_3 = L_2;
        _ -> L_3 = L
    end,
            setpx(B_5, X_7, Y_7, #{"R" => L_3, "G" => L_3, "B" => L_3}),
            case (L_3 > M) of
        true -> M_2 = L_3,
            M_3 = M_2;
        _ -> M_3 = M
    end,
            X_8 = (X_7 + 1),
            Fun_10_loop(B_5, H_3, M_3, W_3, X_8, Y_7);
        _ -> {B_5, H_3, M, W_3, X_7, Y_7}
    end
end,
{B_5, H_3, M_3, W_3, X_8, Y_7} = Fun_10(B_5, H_3, M, W_3, X_7, Y_7),
            Y_8 = (Y_7 + 1),
            Fun_11_loop(B_5, H_3, M_3, W_3, Y_8);
        _ -> {B_5, H_3, M, W_3, Y_7}
    end
end,
{B_5, H_3, M_3, W_3, Y_8} = Fun_11(B_5, H_3, M, W_3, Y_7),
        B_6 = maps:put("max", M_3, B_5),
        B_6
    catch {return, Ret} -> Ret end.

pad(N_5, W_4) ->
    try
        S_4 = lists:flatten(io_lib:format("~p", [N_5])),
        Fun_12 = fun Fun_12_loop(N_5, S_4, W_4) ->
    case (length(S_4) < W_4) of
        true ->
            S_5 = (" " ++ S_4),
            Fun_12_loop(N_5, S_5, W_4);
        _ -> {N_5, S_4, W_4}
    end
end,
{N_5, S_5, W_4} = Fun_12(N_5, S_4, W_4),
        S_5
    catch {return, Ret} -> Ret end.

writep3(B_7) ->
    try
        H_4 = maps:get("h", B_7, nil),
        W_5 = maps:get("w", B_7, nil),
        Max_2 = maps:get("max", B_7, nil),
        Digits_2 = length(lists:flatten(io_lib:format("~p", [Max_2]))),
        Out_11 = (((((("P3\n# generated from Bitmap.writeppmp3\n" ++ lists:flatten(io_lib:format("~p", [W_5]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [H_4]))) ++ "\n") ++ lists:flatten(io_lib:format("~p", [Max_2]))) ++ "\n"),
        Y_9 = (H_4 - 1),
        Fun_14 = fun Fun_14_loop(B_7, Digits_2, H_4, Max_2, Out_11, W_5, Y_9) ->
    case (Y_9 >= 0) of
        true ->
            Line_2 = "",
            X_9 = 0,
            Fun_13 = fun Fun_13_loop(B_7, Digits_2, H_4, Line_2, Max_2, Out_11, W_5, X_9, Y_9) ->
    case (X_9 < W_5) of
        true ->
            P_3 = getpx(B_7, X_9, Y_9),
            Line_3 = ((((((Line_2 ++ "   ") ++ pad(maps:get("R", P_3, nil), Digits_2)) ++ " ") ++ pad(maps:get("G", P_3, nil), Digits_2)) ++ " ") ++ pad(maps:get("B", P_3, nil), Digits_2)),
            X_10 = (X_9 + 1),
            Fun_13_loop(B_7, Digits_2, H_4, Line_3, Max_2, Out_11, W_5, X_10, Y_9);
        _ -> {B_7, Digits_2, H_4, Line_2, Max_2, Out_11, W_5, X_9, Y_9}
    end
end,
{B_7, Digits_2, H_4, Line_3, Max_2, Out_11, W_5, X_10, Y_9} = Fun_13(B_7, Digits_2, H_4, Line_2, Max_2, Out_11, W_5, X_9, Y_9),
            Out_12 = ((Out_11 ++ Line_3) ++ "\n"),
            Y_10 = (Y_9 - 1),
            Fun_14_loop(B_7, Digits_2, H_4, Max_2, Out_12, W_5, Y_10);
        _ -> {B_7, Digits_2, H_4, Max_2, Out_11, W_5, Y_9}
    end
end,
{B_7, Digits_2, H_4, Max_2, Out_12, W_5, Y_10} = Fun_14(B_7, Digits_2, H_4, Max_2, Out_11, W_5, Y_9),
        Out_12
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    erlang:put('ppmtxt', ((((((("P3\n" ++ "# feep.ppm\n") ++ "4 4\n") ++ "15\n") ++ " 0  0  0    0  0  0    0  0  0   15  0 15\n") ++ " 0  0  0    0 15  7    0  0  0    0  0  0\n") ++ " 0  0  0    0  0  0    0 15  7    0  0  0\n") ++ "15  0 15    0  0  0    0  0  0    0  0  0\n")),
    io:format("~ts~n", ["Original Colour PPM file"]),
    io:format("~p~n", [erlang:get('ppmtxt')]),
    erlang:put('bm', readp3(erlang:get('ppmtxt'))),
    io:format("~ts~n", ["Grey PPM:"]),
    togrey(erlang:get('bm')),
    erlang:put('out', writep3(erlang:get('bm'))),
    io:format("~p~n", [erlang:get('out')]),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
