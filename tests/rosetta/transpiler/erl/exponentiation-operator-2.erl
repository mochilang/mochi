#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, expi/2, expf/2, printexpf/2, main/0]).

% Generated by Mochi transpiler v0.10.55 (6aa59f472e) on 2025-08-02 17:26 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

expi(B, P) ->
    try
        R = 1,
        I = 0,
        Fun = fun Fun_loop(B, I, P, R) ->
    case (I < P) of
        true ->
            R_2 = (R * B),
            I_2 = (I + 1),
            Fun_loop(B, I_2, P, R_2);
        _ -> {B, I, P, R}
    end
end,
{B, I_2, P, R_2} = Fun(B, I, P, R),
        R_2
    catch {return, Ret} -> Ret end.

expf(B_2, P_2) ->
    try
        R_3 = 1,
        Pow = B_2,
        N = P_2,
        Neg = false,
        case (P_2 < 0) of
        true -> N_2 = -P_2,
            Neg_2 = true,
            N_3 = N_2,
            Neg_3 = Neg_2;
        _ -> N_3 = N,
            Neg_3 = Neg
    end,
        Fun_2 = fun Fun_2_loop(B_2, N_3, Neg_3, P_2, Pow, R_3) ->
    case (N_3 > 0) of
        true ->
            case ((N_3 rem 2) == 1) of
        true -> R_4 = (R_3 * Pow),
            R_5 = R_4;
        _ -> R_5 = R_3
    end,
            Pow_2 = (Pow * Pow),
            N_4 = (N_3 div 2),
            Fun_2_loop(B_2, N_4, Neg_3, P_2, Pow_2, R_5);
        _ -> {B_2, N_3, Neg_3, P_2, Pow, R_3}
    end
end,
{B_2, N_4, Neg_3, P_2, Pow_2, R_5} = Fun_2(B_2, N_3, Neg_3, P_2, Pow, R_3),
        case Neg_3 of
        true -> R_6 = (1 / R_5),
            R_7 = R_6;
        _ -> R_7 = R_5
    end,
        R_7
    catch {return, Ret} -> Ret end.

printexpf(B_3, P_3) ->
    try
        case ((B_3 == 0) andalso (P_3 < 0)) of
        true -> io:format("~ts~n", [(((lists:flatten(io_lib:format("~p", [B_3])) ++ "^") ++ lists:flatten(io_lib:format("~p", [P_3]))) ++ ": +Inf")]);
        _ -> io:format("~ts~n", [((((lists:flatten(io_lib:format("~p", [B_3])) ++ "^") ++ lists:flatten(io_lib:format("~p", [P_3]))) ++ ": ") ++ lists:flatten(io_lib:format("~p", [expf(B_3, P_3)])))])
    end,
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", ["expI tests"]),
        Fun_3 = fun Fun_3_loop(List) ->
    case List of
        [] -> {};
        [Pair|Pair_rest] ->
            case ((case erlang:is_map(Pair) of true -> maps:get(1, Pair, nil); _ -> lists:nth(1 + 1, Pair) end) < 0) of
        true -> io:format("~ts~n", [(((lists:flatten(io_lib:format("~p", [(case erlang:is_map(Pair) of true -> maps:get(0, Pair, nil); _ -> lists:nth(0 + 1, Pair) end)])) ++ "^") ++ lists:flatten(io_lib:format("~p", [(case erlang:is_map(Pair) of true -> maps:get(1, Pair, nil); _ -> lists:nth(1 + 1, Pair) end)]))) ++ ": negative power not allowed")]);
        _ -> io:format("~ts~n", [((((lists:flatten(io_lib:format("~p", [(case erlang:is_map(Pair) of true -> maps:get(0, Pair, nil); _ -> lists:nth(0 + 1, Pair) end)])) ++ "^") ++ lists:flatten(io_lib:format("~p", [(case erlang:is_map(Pair) of true -> maps:get(1, Pair, nil); _ -> lists:nth(1 + 1, Pair) end)]))) ++ ": ") ++ lists:flatten(io_lib:format("~p", [expi((case erlang:is_map(Pair) of true -> maps:get(0, Pair, nil); _ -> lists:nth(0 + 1, Pair) end), (case erlang:is_map(Pair) of true -> maps:get(1, Pair, nil); _ -> lists:nth(1 + 1, Pair) end))])))])
    end,
            Fun_3_loop(Pair_rest)
    end
end,
{} = Fun_3([[2, 10], [2, -10], [-2, 10], [-2, 11], [11, 0]]),
        io:format("~ts~n", ["overflow undetected"]),
        io:format("~ts~n", [("10^10: " ++ lists:flatten(io_lib:format("~p", [expi(10, 10)])))]),
        io:format("~ts~n", ["\nexpF tests:"]),
        Fun_4 = fun Fun_4_loop(List) ->
    case List of
        [] -> {};
        [Pair_2|Pair_2_rest] ->
            printexpf((case erlang:is_map(Pair_2) of true -> maps:get(0, Pair_2, nil); _ -> lists:nth(0 + 1, Pair_2) end), (case erlang:is_map(Pair_2) of true -> maps:get(1, Pair_2, nil); _ -> lists:nth(1 + 1, Pair_2) end)),
            Fun_4_loop(Pair_2_rest)
    end
end,
{} = Fun_4([[2, 10], [2, -10], [-2, 10], [-2, 11], [11, 0]]),
        io:format("~ts~n", ["disallowed in expI, allowed here"]),
        printexpf(0, -1),
        io:format("~ts~n", ["other interesting cases for 32 bit float type"]),
        printexpf(10, 39),
        printexpf(10, -39),
        printexpf(-10, 39),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
