#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, parseintdigits/1, parsedc/1, parserate/1, dcstring/1, extend/2, tax/2, padleft/2, main/0]).

% Generated by Mochi transpiler v0.10.41 (4a1f4378c8) on 2025-07-27 06:30 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

parseintdigits(S) ->
    try
        N = 0,
        I = 0,
        Digits = #{"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9},
        Fun = fun Fun_loop(Digits, I, N, S) ->
    case (I < length(S)) of
        true ->
            Ch = string:substr(S, I + 1, ((I + 1) - I)),
            case mochi_not(maps:is_key(Ch, Digits)) of
        true -> throw({return, 0});
        _ -> ok
    end,
            N_2 = ((N * 10) + maps:get(Ch, Digits, nil)),
            I_2 = (I + 1),
            Fun_loop(Digits, I_2, N_2, S);
        _ -> {Digits, I, N, S}
    end
end,
{Digits, I_2, N_2, S} = Fun(Digits, I, N, S),
        N_2
    catch {return, Ret} -> Ret end.

parsedc(S_2) ->
    try
        Neg = false,
        case ((length(S_2) > 0) andalso (string:substr(S_2, 0 + 1, (1 - 0)) == "-")) of
        true -> Neg_2 = true,
            S_3 = string:substr(S_2, 1 + 1, (length(S_2) - 1)),
            Neg_3 = Neg_2,
            S_4 = S_3;
        _ -> Neg_3 = Neg,
            S_4 = S_2
    end,
        Dollars = 0,
        Cents = 0,
        I_3 = 0,
        SeenDot = false,
        CentDigits = 0,
        Fun_2 = fun Fun_2_loop(CentDigits, Cents, Dollars, I_3, Neg_3, S_4, SeenDot) ->
    case (I_3 < length(S_4)) of
        true ->
            try
                Ch_2 = string:substr(S_4, I_3 + 1, ((I_3 + 1) - I_3)),
                case (Ch_2 == ".") of
        true -> SeenDot_2 = true,
            I_4 = (I_3 + 1),
            throw({continue, CentDigits, Cents, Dollars, I_4, Neg_3, S_4, SeenDot_2}),
            I_5 = I_4,
            SeenDot_3 = SeenDot_2;
        _ -> I_5 = I_3,
            SeenDot_3 = SeenDot
    end,
                D = parseintdigits(Ch_2),
                case SeenDot_3 of
        true -> case (CentDigits < 2) of
        true -> Cents_2 = ((Cents * 10) + D),
            CentDigits_2 = (CentDigits + 1),
            CentDigits_3 = CentDigits_2,
            Cents_3 = Cents_2;
        _ -> CentDigits_3 = CentDigits,
            Cents_3 = Cents
    end,
            CentDigits_4 = CentDigits_3,
            Cents_4 = Cents_3,
            Dollars_3 = Dollars;
        _ -> Dollars_2 = ((Dollars * 10) + D),
            CentDigits_4 = CentDigits,
            Cents_4 = Cents,
            Dollars_3 = Dollars_2
    end,
                I_6 = (I_5 + 1),
                Fun_2_loop(CentDigits_4, Cents_4, Dollars_3, I_6, Neg_3, S_4, SeenDot_3)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_2_loop(C0, C1, C2, C3, C4, C5, C6);
                break -> {CentDigits, Cents, Dollars, I_3, Neg_3, S_4, SeenDot}
            end;
        _ -> {CentDigits, Cents, Dollars, I_3, Neg_3, S_4, SeenDot}
    end
end,
{CentDigits_4, Cents_4, Dollars_3, I_6, Neg_3, S_4, SeenDot_3} = Fun_2(CentDigits, Cents, Dollars, I_3, Neg_3, S_4, SeenDot),
        case (CentDigits_4 == 1) of
        true -> Cents_5 = (Cents_4 * 10),
            Cents_6 = Cents_5;
        _ -> Cents_6 = Cents_4
    end,
        Val = ((Dollars_3 * 100) + Cents_6),
        case Neg_3 of
        true -> Val_2 = -Val,
            Val_3 = Val_2;
        _ -> Val_3 = Val
    end,
        Val_3
    catch {return, Ret} -> Ret end.

parserate(S_5) ->
    try
        Neg_4 = false,
        case ((length(S_5) > 0) andalso (string:substr(S_5, 0 + 1, (1 - 0)) == "-")) of
        true -> Neg_5 = true,
            S_6 = string:substr(S_5, 1 + 1, (length(S_5) - 1)),
            Neg_6 = Neg_5,
            S_7 = S_6;
        _ -> Neg_6 = Neg_4,
            S_7 = S_5
    end,
        Whole = 0,
        Frac = 0,
        Digits_2 = 0,
        SeenDot_4 = false,
        I_7 = 0,
        Fun_3 = fun Fun_3_loop(Digits_2, Frac, I_7, Neg_6, S_7, SeenDot_4, Whole) ->
    case (I_7 < length(S_7)) of
        true ->
            try
                Ch_3 = string:substr(S_7, I_7 + 1, ((I_7 + 1) - I_7)),
                case (Ch_3 == ".") of
        true -> SeenDot_5 = true,
            I_8 = (I_7 + 1),
            throw({continue, Digits_2, Frac, I_8, Neg_6, S_7, SeenDot_5, Whole}),
            I_9 = I_8,
            SeenDot_6 = SeenDot_5;
        _ -> I_9 = I_7,
            SeenDot_6 = SeenDot_4
    end,
                D_2 = parseintdigits(Ch_3),
                case SeenDot_6 of
        true -> case (Digits_2 < 4) of
        true -> Frac_2 = ((Frac * 10) + D_2),
            Digits_3 = (Digits_2 + 1),
            Digits_4 = Digits_3,
            Frac_3 = Frac_2;
        _ -> Digits_4 = Digits_2,
            Frac_3 = Frac
    end,
            Digits_5 = Digits_4,
            Frac_4 = Frac_3,
            Whole_3 = Whole;
        _ -> Whole_2 = ((Whole * 10) + D_2),
            Digits_5 = Digits_2,
            Frac_4 = Frac,
            Whole_3 = Whole_2
    end,
                I_10 = (I_9 + 1),
                Fun_3_loop(Digits_5, Frac_4, I_10, Neg_6, S_7, SeenDot_6, Whole_3)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_3_loop(C0, C1, C2, C3, C4, C5, C6);
                break -> {Digits_2, Frac, I_7, Neg_6, S_7, SeenDot_4, Whole}
            end;
        _ -> {Digits_2, Frac, I_7, Neg_6, S_7, SeenDot_4, Whole}
    end
end,
{Digits_5, Frac_4, I_10, Neg_6, S_7, SeenDot_6, Whole_3} = Fun_3(Digits_2, Frac, I_7, Neg_6, S_7, SeenDot_4, Whole),
        Fun_4 = fun Fun_4_loop(Digits_5, Frac_4, I_10, Neg_6, S_7, SeenDot_6, Whole_3) ->
    case (Digits_5 < 4) of
        true ->
            Frac_5 = (Frac_4 * 10),
            Digits_6 = (Digits_5 + 1),
            Fun_4_loop(Digits_6, Frac_5, I_10, Neg_6, S_7, SeenDot_6, Whole_3);
        _ -> {Digits_5, Frac_4, I_10, Neg_6, S_7, SeenDot_6, Whole_3}
    end
end,
{Digits_6, Frac_5, I_10, Neg_6, S_7, SeenDot_6, Whole_3} = Fun_4(Digits_5, Frac_4, I_10, Neg_6, S_7, SeenDot_6, Whole_3),
        Val_4 = ((Whole_3 * 10000) + Frac_5),
        case Neg_6 of
        true -> Val_5 = -Val_4,
            Val_6 = Val_5;
        _ -> Val_6 = Val_4
    end,
        Val_6
    catch {return, Ret} -> Ret end.

dcstring(Dc) ->
    try
        D_3 = (Dc div 100),
        N_3 = Dc,
        case (N_3 < 0) of
        true -> N_4 = -N_3,
            N_5 = N_4;
        _ -> N_5 = N_3
    end,
        C = (N_5 rem 100),
        Cstr = lists:flatten(io_lib:format("~p", [C])),
        case (length(Cstr) == 1) of
        true -> Cstr_2 = ("0" ++ Cstr),
            Cstr_3 = Cstr_2;
        _ -> Cstr_3 = Cstr
    end,
        ((lists:flatten(io_lib:format("~p", [D_3])) ++ ".") ++ Cstr_3)
    catch {return, Ret} -> Ret end.

extend(Dc_2, N_6) ->
    try
        (Dc_2 * N_6)
    catch {return, Ret} -> Ret end.

tax(Total, Rate) ->
    try
        mochi_to_int((((Total * Rate) + 5000) div 10000))
    catch {return, Ret} -> Ret end.

padleft(S_8, N_7) ->
    try
        Out = S_8,
        Fun_5 = fun Fun_5_loop(N_7, Out, S_8) ->
    case (length(Out) < N_7) of
        true ->
            Out_2 = (" " ++ Out),
            Fun_5_loop(N_7, Out_2, S_8);
        _ -> {N_7, Out, S_8}
    end
end,
{N_7, Out_2, S_8} = Fun_5(N_7, Out, S_8),
        Out_2
    catch {return, Ret} -> Ret end.

main() ->
    try
        Hp = parsedc("5.50"),
        Mp = parsedc("2.86"),
        Rate_2 = parserate("0.0765"),
        TotalBeforeTax = (extend(Hp, 4000000000000000) + extend(Mp, 2)),
        T = tax(TotalBeforeTax, Rate_2),
        Total_2 = (TotalBeforeTax + T),
        io:format("~ts~n", [("Total before tax: " ++ padleft(dcstring(TotalBeforeTax), 22))]),
        io:format("~ts~n", [("             Tax: " ++ padleft(dcstring(T), 22))]),
        io:format("~ts~n", [("           Total: " ++ padleft(dcstring(Total_2), 22))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
