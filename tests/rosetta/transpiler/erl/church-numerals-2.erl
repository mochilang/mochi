#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, id/1, compose/2, zero/0, one/0, succ/1, plus/2, mult/2, exp/2, toint/1, tostr/1, main/0]).

% Generated by Mochi transpiler v0.10.41 (fc61869ba1) on 2025-07-27 00:43 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

id(X) ->
    try
        X
    catch {return, Ret} -> Ret end.

compose(F, G) ->
    try
        fun(X_2) ->
    try
        F(G(X_2))
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end.

zero() ->
    try
        fun(F_2) ->
    try
        fun id/1
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end.

one() ->
    try
        fun id/1
    catch {return, Ret} -> Ret end.

succ(N) ->
    try
        fun(F_3) ->
    try
        compose(F_3, N(F_3))
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end.

plus(M, N_2) ->
    try
        fun(F_4) ->
    try
        compose(M(F_4), N_2(F_4))
    catch {return, Ret} -> Ret end
end
    catch {return, Ret} -> Ret end.

mult(M_2, N_3) ->
    try
        compose(M_2, N_3)
    catch {return, Ret} -> Ret end.

exp(M_3, N_4) ->
    try
        N_4(M_3)
    catch {return, Ret} -> Ret end.

toint(X_3) ->
    try
        Counter = 0,
        FCounter = fun FCounter(F_5) ->
    try
        Counter_2 = (Counter + 1),
        F_5
    catch {return, Ret} -> Ret end
end,
        (X_3(FCounter))(fun id/1),
        Counter
    catch {return, Ret} -> Ret end.

tostr(X_4) ->
    try
        S = "",
        FCounter_2 = fun FCounter_2(F_6) ->
    try
        S_2 = (S ++ "|"),
        F_6
    catch {return, Ret} -> Ret end
end,
        (X_4(FCounter_2))(fun id/1),
        S
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", [("zero = " ++ lists:flatten(io_lib:format("~p", [toint(zero())])))]),
        Onev = one(),
        io:format("~ts~n", [("one = " ++ lists:flatten(io_lib:format("~p", [toint(Onev)])))]),
        Two = succ(succ(zero())),
        io:format("~ts~n", [("two = " ++ lists:flatten(io_lib:format("~p", [toint(Two)])))]),
        Three = plus(Onev, Two),
        io:format("~ts~n", [("three = " ++ lists:flatten(io_lib:format("~p", [toint(Three)])))]),
        Four = mult(Two, Two),
        io:format("~ts~n", [("four = " ++ lists:flatten(io_lib:format("~p", [toint(Four)])))]),
        Eight = exp(Two, Three),
        io:format("~ts~n", [("eight = " ++ lists:flatten(io_lib:format("~p", [toint(Eight)])))]),
        io:format("~ts~n", [("toStr(four) = " ++ tostr(Four))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
