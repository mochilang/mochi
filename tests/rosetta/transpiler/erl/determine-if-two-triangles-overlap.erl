#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, fmt1/1, pointstr/1, trianglestr/1, orient/3, pointintri/3, edgecheck/4, tritri2d/3, iff/3, main/0]).

% Generated by Mochi transpiler v0.10.42 (cb76045201) on 2025-07-27 10:24 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

fmt1(F) ->
    try
        S = lists:flatten(io_lib:format("~p", [F])),
        Idx = mochi_index_of(S, "."),
        case (Idx < 0) of
        true -> S_2 = (S ++ ".0"),
            Fun_3 = nil,
            Need_2 = nil,
            S_6 = S_2;
        _ -> Need = (Idx + 2),
            case (length(S) > Need) of
        true -> S_3 = string:substr(S, 0 + 1, (Need - 0)),
            Fun_2 = nil,
            S_5 = S_3;
        _ -> Fun = fun Fun_loop(F, Idx, Need, S) ->
    case (length(S) < Need) of
        true ->
            S_4 = (S ++ "0"),
            Fun_loop(F, Idx, Need, S_4);
        _ -> {F, Idx, Need, S}
    end
end,
{F, Idx, Need, S_4} = Fun(F, Idx, Need, S),
            Fun_2 = Fun,
            S_5 = S_4
    end,
            Fun_3 = Fun_2,
            Need_2 = Need,
            S_6 = S_5
    end,
        S_6
    catch {return, Ret} -> Ret end.

pointstr(P) ->
    try
        (((("(" ++ fmt1(maps:get("x", P, nil))) ++ ", ") ++ fmt1(maps:get("y", P, nil))) ++ ")")
    catch {return, Ret} -> Ret end.

trianglestr(T) ->
    try
        ((((("Triangle " ++ pointstr(maps:get("p1", T, nil))) ++ ", ") ++ pointstr(maps:get("p2", T, nil))) ++ ", ") ++ pointstr(maps:get("p3", T, nil)))
    catch {return, Ret} -> Ret end.

orient(A, B, C) ->
    try
        (((maps:get("x", B, nil) - maps:get("x", A, nil)) * (maps:get("y", C, nil) - maps:get("y", A, nil))) - ((maps:get("y", B, nil) - maps:get("y", A, nil)) * (maps:get("x", C, nil) - maps:get("x", A, nil))))
    catch {return, Ret} -> Ret end.

pointintri(P_2, T_2, OnBoundary) ->
    try
        D1 = orient(P_2, maps:get("p1", T_2, nil), maps:get("p2", T_2, nil)),
        D2 = orient(P_2, maps:get("p2", T_2, nil), maps:get("p3", T_2, nil)),
        D3 = orient(P_2, maps:get("p3", T_2, nil), maps:get("p1", T_2, nil)),
        HasNeg = (((D1 < 0) orelse (D2 < 0)) orelse (D3 < 0)),
        HasPos = (((D1 > 0) orelse (D2 > 0)) orelse (D3 > 0)),
        case OnBoundary of
        true -> throw({return, mochi_not((HasNeg andalso HasPos))});
        _ -> ok
    end,
        (((mochi_not((HasNeg andalso HasPos)) andalso (D1 /= 0)) andalso (D2 /= 0)) andalso (D3 /= 0))
    catch {return, Ret} -> Ret end.

edgecheck(A0, A1, Bs, OnBoundary_2) ->
    try
        D0 = orient(A0, A1, lists:nth(0 + 1, Bs)),
        D1_2 = orient(A0, A1, lists:nth(1 + 1, Bs)),
        D2_2 = orient(A0, A1, lists:nth(2 + 1, Bs)),
        case OnBoundary_2 of
        true -> throw({return, (((D0 =< 0) andalso (D1_2 =< 0)) andalso (D2_2 =< 0))});
        _ -> ok
    end,
        (((D0 < 0) andalso (D1_2 < 0)) andalso (D2_2 < 0))
    catch {return, Ret} -> Ret end.

tritri2d(T1, T2, OnBoundary_3) ->
    try
        A_2 = [maps:get("p1", T1, nil), maps:get("p2", T1, nil), maps:get("p3", T1, nil)],
        B_2 = [maps:get("p1", T2, nil), maps:get("p2", T2, nil), maps:get("p3", T2, nil)],
        I = 0,
        Fun_4 = fun Fun_4_loop(A_2, B_2, I, OnBoundary_3, T1, T2) ->
    case (I < 3) of
        true ->
            J = ((I + 1) rem 3),
            case (edgecheck(lists:nth(I + 1, A_2), lists:nth(J + 1, A_2), B_2, OnBoundary_3) /= nil) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_4_loop(A_2, B_2, I_2, OnBoundary_3, T1, T2);
        _ -> {A_2, B_2, I, OnBoundary_3, T1, T2}
    end
end,
{A_2, B_2, I_2, OnBoundary_3, T1, T2} = Fun_4(A_2, B_2, I, OnBoundary_3, T1, T2),
        I_3 = 0,
        Fun_5 = fun Fun_5_loop(A_2, B_2, I_3, OnBoundary_3, T1, T2) ->
    case (I_3 < 3) of
        true ->
            J_2 = ((I_3 + 1) rem 3),
            case (edgecheck(lists:nth(I_3 + 1, B_2), lists:nth(J_2 + 1, B_2), A_2, OnBoundary_3) /= nil) of
        true -> throw({return, false});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_5_loop(A_2, B_2, I_4, OnBoundary_3, T1, T2);
        _ -> {A_2, B_2, I_3, OnBoundary_3, T1, T2}
    end
end,
{A_2, B_2, I_4, OnBoundary_3, T1, T2} = Fun_5(A_2, B_2, I_3, OnBoundary_3, T1, T2),
        true
    catch {return, Ret} -> Ret end.

iff(Cond, A_3, B_3) ->
    try
        case Cond of
        true -> throw({return, A_3});
        _ -> throw({return, B_3})
    end,
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        T1_2 = #{"p1" => #{"x" => 0, "y" => 0}, "p2" => #{"x" => 5, "y" => 0}, "p3" => #{"x" => 0, "y" => 5}},
        T2_2 = #{"p1" => #{"x" => 0, "y" => 0}, "p2" => #{"x" => 5, "y" => 0}, "p3" => #{"x" => 0, "y" => 6}},
        io:format("~ts~n", [(trianglestr(T1_2) ++ " and")]),
        io:format("~ts~n", [trianglestr(T2_2)]),
        Overlapping = tritri2d(T1_2, T2_2, true),
        io:format("~ts~n", [iff(Overlapping, "overlap", "do not overlap")]),
        io:format("~ts~n", [""]),
        T1_3 = #{"p1" => #{"x" => 0, "y" => 0}, "p2" => #{"x" => 0, "y" => 5}, "p3" => #{"x" => 5, "y" => 0}},
        T2_3 = T1_3,
        io:format("~ts~n", [(trianglestr(T1_3) ++ " and")]),
        io:format("~ts~n", [trianglestr(T2_3)]),
        Overlapping_2 = tritri2d(T1_3, T2_3, true),
        io:format("~ts~n", [iff(Overlapping_2, "overlap (reversed)", "do not overlap")]),
        io:format("~ts~n", [""]),
        T1_4 = #{"p1" => #{"x" => 0, "y" => 0}, "p2" => #{"x" => 5, "y" => 0}, "p3" => #{"x" => 0, "y" => 5}},
        T2_4 = #{"p1" => #{"x" => -10, "y" => 0}, "p2" => #{"x" => -5, "y" => 0}, "p3" => #{"x" => -1, "y" => 6}},
        io:format("~ts~n", [(trianglestr(T1_4) ++ " and")]),
        io:format("~ts~n", [trianglestr(T2_4)]),
        Overlapping_3 = tritri2d(T1_4, T2_4, true),
        io:format("~ts~n", [iff(Overlapping_3, "overlap", "do not overlap")]),
        io:format("~ts~n", [""]),
        T1_5 = maps:put("p3", #{"x" => 2.5, "y" => 5}, T1_4),
        T2_5 = #{"p1" => #{"x" => 0, "y" => 4}, "p2" => #{"x" => 2.5, "y" => -1}, "p3" => #{"x" => 5, "y" => 4}},
        io:format("~ts~n", [(trianglestr(T1_5) ++ " and")]),
        io:format("~ts~n", [trianglestr(T2_5)]),
        Overlapping_4 = tritri2d(T1_5, T2_5, true),
        io:format("~ts~n", [iff(Overlapping_4, "overlap", "do not overlap")]),
        io:format("~ts~n", [""]),
        T1_6 = #{"p1" => #{"x" => 0, "y" => 0}, "p2" => #{"x" => 1, "y" => 1}, "p3" => #{"x" => 0, "y" => 2}},
        T2_6 = #{"p1" => #{"x" => 2, "y" => 1}, "p2" => #{"x" => 3, "y" => 0}, "p3" => #{"x" => 3, "y" => 2}},
        io:format("~ts~n", [(trianglestr(T1_6) ++ " and")]),
        io:format("~ts~n", [trianglestr(T2_6)]),
        Overlapping_5 = tritri2d(T1_6, T2_6, true),
        io:format("~ts~n", [iff(Overlapping_5, "overlap", "do not overlap")]),
        io:format("~ts~n", [""]),
        T2_7 = #{"p1" => #{"x" => 2, "y" => 1}, "p2" => #{"x" => 3, "y" => -2}, "p3" => #{"x" => 3, "y" => 4}},
        io:format("~ts~n", [(trianglestr(T1_6) ++ " and")]),
        io:format("~ts~n", [trianglestr(T2_7)]),
        Overlapping_6 = tritri2d(T1_6, T2_7, true),
        io:format("~ts~n", [iff(Overlapping_6, "overlap", "do not overlap")]),
        io:format("~ts~n", [""]),
        T1_7 = #{"p1" => #{"x" => 0, "y" => 0}, "p2" => #{"x" => 1, "y" => 0}, "p3" => #{"x" => 0, "y" => 1}},
        T2_8 = #{"p1" => #{"x" => 1, "y" => 0}, "p2" => #{"x" => 2, "y" => 0}, "p3" => #{"x" => 1, "y" => 1.1}},
        io:format("~ts~n", [(trianglestr(T1_7) ++ " and")]),
        io:format("~ts~n", [trianglestr(T2_8)]),
        io:format("~ts~n", ["which have only a single corner in contact, if boundary points collide"]),
        Overlapping_7 = tritri2d(T1_7, T2_8, true),
        io:format("~ts~n", [iff(Overlapping_7, "overlap", "do not overlap")]),
        io:format("~ts~n", [""]),
        io:format("~ts~n", [(trianglestr(T1_7) ++ " and")]),
        io:format("~ts~n", [trianglestr(T2_8)]),
        io:format("~ts~n", ["which have only a single corner in contact, if boundary points do not collide"]),
        Overlapping_8 = tritri2d(T1_7, T2_8, false),
        io:format("~ts~n", [iff(Overlapping_8, "overlap", "do not overlap")]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
