#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, samedigits/2, isbrazilian/1, isprime/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (83683ecfe3) on 2025-07-25 22:53 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

samedigits(N, B) ->
    try
        F = (N rem B),
        N_2 = mochi_to_int((N div B)),
        Fun = fun Fun_loop(B, F, N_2) ->
    case (N_2 > 0) of
        true ->
            case ((N_2 rem B) /= F) of
        true -> throw({return, false});
        _ -> ok
    end,
            N_3 = mochi_to_int((N_2 div B)),
            Fun_loop(B, F, N_3);
        _ -> {B, F, N_2}
    end
end,
{B, F, N_3} = Fun(B, F, N_2),
        true
    catch {return, Ret} -> Ret end.

isbrazilian(N_4) ->
    try
        case (N_4 < 7) of
        true -> throw({return, false});
        _ -> ok
    end,
        case (((N_4 rem 2) == 0) andalso (N_4 >= 8)) of
        true -> throw({return, true});
        _ -> ok
    end,
        B_2 = 2,
        Fun_2 = fun Fun_2_loop(B_2, N_4) ->
    case (B_2 < (N_4 - 1)) of
        true ->
            case (samedigits(N_4, B_2) /= nil) of
        true -> throw({return, true});
        _ -> ok
    end,
            B_3 = (B_2 + 1),
            Fun_2_loop(B_3, N_4);
        _ -> {B_2, N_4}
    end
end,
{B_3, N_4} = Fun_2(B_2, N_4),
        false
    catch {return, Ret} -> Ret end.

isprime(N_5) ->
    try
        case (N_5 < 2) of
        true -> throw({return, false});
        _ -> ok
    end,
        case ((N_5 rem 2) == 0) of
        true -> throw({return, (N_5 == 2)});
        _ -> ok
    end,
        case ((N_5 rem 3) == 0) of
        true -> throw({return, (N_5 == 3)});
        _ -> ok
    end,
        D = 5,
        Fun_3 = fun Fun_3_loop(D, N_5) ->
    case ((D * D) =< N_5) of
        true ->
            case ((N_5 rem D) == 0) of
        true -> throw({return, false});
        _ -> ok
    end,
            D_2 = (D + 2),
            case ((N_5 rem D_2) == 0) of
        true -> throw({return, false});
        _ -> ok
    end,
            D_3 = (D_2 + 4),
            Fun_3_loop(D_3, N_5);
        _ -> {D, N_5}
    end
end,
{D_3, N_5} = Fun_3(D, N_5),
        true
    catch {return, Ret} -> Ret end.

main() ->
    try
        Kinds = [" ", " odd ", " prime "],
        Fun_4 = fun Fun_4_loop(List, Kinds) ->
    case List of
        [] -> {Kinds};
        [Kind|Kind_rest] ->
        try
            io:format("~ts~n", [(("First 20" ++ Kind) ++ "Brazilian numbers:")]),
            C = 0,
            N_6 = 7,
            Fun_8 = fun Fun_8_loop(C, Kind, Kinds, N_6) ->
    case true of
        true ->
            try
                case (isbrazilian(N_6) /= nil) of
        true -> io:format("~ts~n", [(lists:flatten(io_lib:format("~p", [N_6])) ++ " ")]),
            C_2 = (C + 1),
            case (C_2 == 20) of
        true -> io:format("~ts~n", ["\n"]),
            throw(break);
        _ -> ok
    end,
            C_3 = C_2;
        _ -> C_3 = C
    end,
                case (Kind == " ") of
        true -> N_7 = (N_6 + 1),
            Fun_7 = nil,
            N_11 = N_7;
        _ -> case (Kind == " odd ") of
        true -> N_8 = (N_6 + 2),
            Fun_6 = nil,
            N_10 = N_8;
        _ -> Fun_5 = fun Fun_5_loop(C_3, Kind, Kinds, N_6) ->
    case true of
        true ->
            try
                N_9 = (N_6 + 2),
                case (isprime(N_9) /= nil) of
        true -> throw(break);
        _ -> ok
    end,
                Fun_5_loop(C_3, Kind, Kinds, N_9)
            catch
                {continue, C0, C1, C2, C3} -> Fun_5_loop(C0, C1, C2, C3);
                break -> {C_3, Kind, Kinds, N_6}
            end;
        _ -> {C_3, Kind, Kinds, N_6}
    end
end,
{C_3, Kind, Kinds, N_9} = Fun_5(C_3, Kind, Kinds, N_6),
            Fun_6 = Fun_5,
            N_10 = N_9
    end,
            Fun_7 = Fun_6,
            N_11 = N_10
    end,
                Fun_8_loop(C_3, Kind, Kinds, N_11)
            catch
                {continue, C0, C1, C2, C3} -> Fun_8_loop(C0, C1, C2, C3);
                break -> {C, Kind, Kinds, N_6}
            end;
        _ -> {C, Kind, Kinds, N_6}
    end
end,
{C_3, Kind, Kinds, N_11} = Fun_8(C, Kind, Kinds, N_6),
            Fun_4_loop(Kind_rest, Kinds)
        catch
            {continue, C0} -> Fun_4_loop(Kind_rest, C0);
            {break, B0} -> {B0};
            break -> {Kinds}
        end
    end
end,
{Kinds} = Fun_4(Kinds, Kinds),
        N_12 = 7,
        C_4 = 0,
        Fun_9 = fun Fun_9_loop(C_4, Kinds, N_12) ->
    case (C_4 < 100000) of
        true ->
            case (isbrazilian(N_12) /= nil) of
        true -> C_5 = (C_4 + 1),
            C_6 = C_5;
        _ -> C_6 = C_4
    end,
            N_13 = (N_12 + 1),
            Fun_9_loop(C_6, Kinds, N_13);
        _ -> {C_4, Kinds, N_12}
    end
end,
{C_6, Kinds, N_13} = Fun_9(C_4, Kinds, N_12),
        io:format("~ts~n", [("The 100,000th Brazilian number: " ++ lists:flatten(io_lib:format("~p", [(N_13 - 1)])))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = erlang:abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
