#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, absf/1, maxf/2, minf/2, max3/3, min3/3, subdividequadspline/2, subdividequadcurve/2, rectsoverlap/8, testintersect/3, seemstobeduplicate/3, findintersects/4, main/0]).

% Generated by Mochi transpiler v0.10.40 (305ff8442f) on 2025-07-25 12:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

absf(X) ->
    try
        (case (X < 0) of
    true -> -X;
    _ -> X
end)
    catch {return, Ret} -> Ret end.

maxf(A, B) ->
    try
        (case (A > B) of
    true -> A;
    _ -> B
end)
    catch {return, Ret} -> Ret end.

minf(A_2, B_2) ->
    try
        (case (A_2 < B_2) of
    true -> A_2;
    _ -> B_2
end)
    catch {return, Ret} -> Ret end.

max3(A_3, B_3, C) ->
    try
        M = A_3,
        case (B_3 > M) of
        true -> M_2 = B_3,
            M_3 = M_2;
        _ -> M_3 = M
    end,
        case (C > M_3) of
        true -> M_4 = C,
            M_5 = M_4;
        _ -> M_5 = M_3
    end,
        M_5
    catch {return, Ret} -> Ret end.

min3(A_4, B_4, C_2) ->
    try
        M_6 = A_4,
        case (B_4 < M_6) of
        true -> M_7 = B_4,
            M_8 = M_7;
        _ -> M_8 = M_6
    end,
        case (C_2 < M_8) of
        true -> M_9 = C_2,
            M_10 = M_9;
        _ -> M_10 = M_8
    end,
        M_10
    catch {return, Ret} -> Ret end.

subdividequadspline(Q, T) ->
    try
        S = (1 - T),
        U = #{"c0" => maps:get("c0", Q, nil), "c1" => 0, "c2" => 0},
        V = #{"c0" => 0, "c1" => 0, "c2" => maps:get("c2", Q, nil)},
        U_2 = maps:put("c1", ((S * maps:get("c0", Q, nil)) + (T * maps:get("c1", Q, nil))), U),
        V_2 = maps:put("c1", ((S * maps:get("c1", Q, nil)) + (T * maps:get("c2", Q, nil))), V),
        U_3 = maps:put("c2", ((S * maps:get("c1", U_2, nil)) + (T * maps:get("c1", V_2, nil))), U_2),
        V_3 = maps:put("c0", maps:get("c2", U_3, nil), V_2),
        [U_3, V_3]
    catch {return, Ret} -> Ret end.

subdividequadcurve(Q_2, T_2) ->
    try
        Xs = subdividequadspline(maps:get("x", Q_2, nil), T_2),
        Ys = subdividequadspline(maps:get("y", Q_2, nil), T_2),
        U_4 = #{"x" => lists:nth(0 + 1, Xs), "y" => lists:nth(0 + 1, Ys)},
        V_4 = #{"x" => lists:nth(1 + 1, Xs), "y" => lists:nth(1 + 1, Ys)},
        [U_4, V_4]
    catch {return, Ret} -> Ret end.

rectsoverlap(Xa0, Ya0, Xa1, Ya1, Xb0, Yb0, Xb1, Yb1) ->
    try
        ((((Xb0 =< Xa1) andalso (Xa0 =< Xb1)) andalso (Yb0 =< Ya1)) andalso (Ya0 =< Yb1))
    catch {return, Ret} -> Ret end.

testintersect(P, Q_3, Tol) ->
    try
        Pxmin = min3(maps:get("c0", maps:get("x", P, nil), nil), maps:get("c1", maps:get("x", P, nil), nil), maps:get("c2", maps:get("x", P, nil), nil)),
        Pymin = min3(maps:get("c0", maps:get("y", P, nil), nil), maps:get("c1", maps:get("y", P, nil), nil), maps:get("c2", maps:get("y", P, nil), nil)),
        Pxmax = max3(maps:get("c0", maps:get("x", P, nil), nil), maps:get("c1", maps:get("x", P, nil), nil), maps:get("c2", maps:get("x", P, nil), nil)),
        Pymax = max3(maps:get("c0", maps:get("y", P, nil), nil), maps:get("c1", maps:get("y", P, nil), nil), maps:get("c2", maps:get("y", P, nil), nil)),
        Qxmin = min3(maps:get("c0", maps:get("x", Q_3, nil), nil), maps:get("c1", maps:get("x", Q_3, nil), nil), maps:get("c2", maps:get("x", Q_3, nil), nil)),
        Qymin = min3(maps:get("c0", maps:get("y", Q_3, nil), nil), maps:get("c1", maps:get("y", Q_3, nil), nil), maps:get("c2", maps:get("y", Q_3, nil), nil)),
        Qxmax = max3(maps:get("c0", maps:get("x", Q_3, nil), nil), maps:get("c1", maps:get("x", Q_3, nil), nil), maps:get("c2", maps:get("x", Q_3, nil), nil)),
        Qymax = max3(maps:get("c0", maps:get("y", Q_3, nil), nil), maps:get("c1", maps:get("y", Q_3, nil), nil), maps:get("c2", maps:get("y", Q_3, nil), nil)),
        Exclude = true,
        Accept = false,
        Inter = #{"x" => 0, "y" => 0},
        case (rectsoverlap(Pxmin, Pymin, Pxmax, Pymax, Qxmin, Qymin, Qxmax, Qymax) /= nil) of
        true -> Exclude_2 = false,
            Xmin = maxf(Pxmin, Qxmin),
            Xmax = minf(Pxmax, Qxmax),
            case ((Xmax - Xmin) =< Tol) of
        true -> Ymin = maxf(Pymin, Qymin),
            Ymax = minf(Pymax, Qymax),
            case ((Ymax - Ymin) =< Tol) of
        true -> Accept_2 = true,
            Inter_2 = maps:put("x", (0.5 * (Xmin + Xmax)), Inter),
            Inter_3 = maps:put("y", (0.5 * (Ymin + Ymax)), Inter_2),
            Accept_3 = Accept_2,
            Inter_4 = Inter_3;
        _ -> Accept_3 = Accept,
            Inter_4 = Inter
    end,
            Accept_4 = Accept_3,
            Inter_5 = Inter_4,
            Ymax_2 = Ymax,
            Ymin_2 = Ymin;
        _ -> Accept_4 = Accept,
            Inter_5 = Inter,
            Ymax_2 = nil,
            Ymin_2 = nil
    end,
            Accept_5 = Accept_4,
            Exclude_3 = Exclude_2,
            Inter_6 = Inter_5,
            Xmax_2 = Xmax,
            Xmin_2 = Xmin,
            Ymax_3 = Ymax_2,
            Ymin_3 = Ymin_2;
        _ -> Accept_5 = Accept,
            Exclude_3 = Exclude,
            Inter_6 = Inter,
            Xmax_2 = nil,
            Xmin_2 = nil,
            Ymax_3 = nil,
            Ymin_3 = nil
    end,
        #{"exclude" => Exclude_3, "accept" => Accept_5, "intersect" => Inter_6}
    catch {return, Ret} -> Ret end.

seemstobeduplicate(Pts, Xy, Spacing) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, Pts, Spacing, Xy) ->
    case (I < length(Pts)) of
        true ->
            Pt = lists:nth(I + 1, Pts),
            case ((absf((maps:get("x", Pt, nil) - maps:get("x", Xy, nil))) < Spacing) andalso (absf((maps:get("y", Pt, nil) - maps:get("y", Xy, nil))) < Spacing)) of
        true -> throw({return, true});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, Pts, Spacing, Xy);
        _ -> {I, Pts, Spacing, Xy}
    end
end,
{I_2, Pts, Spacing, Xy} = Fun(I, Pts, Spacing, Xy),
        false
    catch {return, Ret} -> Ret end.

findintersects(P_2, Q_4, Tol_2, Spacing_2) ->
    try
        Inters = [],
        Workload = [#{"p" => P_2, "q" => Q_4}],
        Fun_2 = fun Fun_2_loop(Inters, P_2, Q_4, Spacing_2, Tol_2, Workload) ->
    case (length(Workload) > 0) of
        true ->
            Idx = (length(Workload) - 1),
            Work = lists:nth(Idx + 1, Workload),
            Workload_2 = lists:sublist(Workload, 1, (Idx - 0)),
            Res = testintersect(maps:get("p", Work, nil), maps:get("q", Work, nil), Tol_2),
            Excl = maps:get("exclude", Res, nil),
            Acc = maps:get("accept", Res, nil),
            Inter_7 = maps:get("intersect", Res, nil),
            case (Acc /= nil) of
        true -> case not seemstobeduplicate(Inters, Inter_7, Spacing_2) of
        true -> Inters_2 = lists:append(Inters, [Inter_7]),
            Inters_3 = Inters_2;
        _ -> Inters_3 = Inters
    end,
            Inters_4 = Inters_3,
            P0_3 = nil,
            P1_3 = nil,
            Ps_3 = nil,
            Q0_3 = nil,
            Q1_3 = nil,
            Qs_3 = nil,
            Workload_8 = Workload_2;
        _ -> case not Excl of
        true -> Ps = subdividequadcurve(maps:get("p", Work, nil), 0.5),
            Qs = subdividequadcurve(maps:get("q", Work, nil), 0.5),
            P0 = lists:nth(0 + 1, Ps),
            P1 = lists:nth(1 + 1, Ps),
            Q0 = lists:nth(0 + 1, Qs),
            Q1 = lists:nth(1 + 1, Qs),
            Workload_3 = lists:append(Workload_2, [#{"p" => P0, "q" => Q0}]),
            Workload_4 = lists:append(Workload_3, [#{"p" => P0, "q" => Q1}]),
            Workload_5 = lists:append(Workload_4, [#{"p" => P1, "q" => Q0}]),
            Workload_6 = lists:append(Workload_5, [#{"p" => P1, "q" => Q1}]),
            P0_2 = P0,
            P1_2 = P1,
            Ps_2 = Ps,
            Q0_2 = Q0,
            Q1_2 = Q1,
            Qs_2 = Qs,
            Workload_7 = Workload_6;
        _ -> P0_2 = nil,
            P1_2 = nil,
            Ps_2 = nil,
            Q0_2 = nil,
            Q1_2 = nil,
            Qs_2 = nil,
            Workload_7 = Workload_2
    end,
            Inters_4 = Inters,
            P0_3 = P0_2,
            P1_3 = P1_2,
            Ps_3 = Ps_2,
            Q0_3 = Q0_2,
            Q1_3 = Q1_2,
            Qs_3 = Qs_2,
            Workload_8 = Workload_7
    end,
            Fun_2_loop(Inters_4, P_2, Q_4, Spacing_2, Tol_2, Workload_8);
        _ -> {Inters, P_2, Q_4, Spacing_2, Tol_2, Workload}
    end
end,
{Inters_4, P_2, Q_4, Spacing_2, Tol_2, Workload_8} = Fun_2(Inters, P_2, Q_4, Spacing_2, Tol_2, Workload),
        Inters_4
    catch {return, Ret} -> Ret end.

main() ->
    try
        P_3 = #{"x" => #{"c0" => -1, "c1" => 0, "c2" => 1}, "y" => #{"c0" => 0, "c1" => 10, "c2" => 0}},
        Q_5 = #{"x" => #{"c0" => 2, "c1" => -8, "c2" => 2}, "y" => #{"c0" => 1, "c1" => 2, "c2" => 3}},
        Tol_3 = 1.0e-07,
        Spacing_3 = (1.0e-07 * 10),
        Inters_5 = findintersects(P_3, Q_5, 1.0e-07, Spacing_3),
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(I_3, Inters_5, P_3, Q_5, Spacing_3, Tol_3) ->
    case (I_3 < length(Inters_5)) of
        true ->
            Pt_2 = lists:nth(I_3 + 1, Inters_5),
            io:format("~ts~n", [(((("(" ++ lists:flatten(io_lib:format("~p", [maps:get("x", Pt_2, nil)]))) ++ ", ") ++ lists:flatten(io_lib:format("~p", [maps:get("y", Pt_2, nil)]))) ++ ")")]),
            I_4 = (I_3 + 1),
            Fun_3_loop(I_4, Inters_5, P_3, Q_5, Spacing_3, Tol_3);
        _ -> {I_3, Inters_5, P_3, Q_5, Spacing_3, Tol_3}
    end
end,
{I_4, Inters_5, P_3, Q_5, Spacing_3, Tol_3} = Fun_3(I_3, Inters_5, P_3, Q_5, Spacing_3, Tol_3),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
