#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, floormod/2, run/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (6aa59f472e) on 2025-08-02 17:26 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

floormod(A, B) ->
    try
        R = (A rem B),
        case (R < 0) of
        true -> R_2 = (R + B),
            R_3 = R_2;
        _ -> R_3 = R
    end,
        R_3
    catch {return, Ret} -> Ret end.

run(Bc) ->
    try
        Acc = 0,
        Pc = 0,
        Fun = fun Fun_loop(Acc, Bc, Pc) ->
    case (Pc < 32) of
        true ->
            try
                Op = ((case erlang:is_map(Bc) of true -> maps:get(Pc, Bc, nil); _ -> lists:nth(Pc + 1, Bc) end) div 32),
                Arg = ((case erlang:is_map(Bc) of true -> maps:get(Pc, Bc, nil); _ -> lists:nth(Pc + 1, Bc) end) rem 32),
                Pc_2 = (Pc + 1),
                case (Op == 0) of
        true -> Acc_9 = Acc,
            Bc_5 = Bc,
            Pc_12 = Pc_2;
        _ -> case (Op == 1) of
        true -> Acc_2 = (case erlang:is_map(Bc) of true -> maps:get(Arg, Bc, nil); _ -> lists:nth(Arg + 1, Bc) end),
            Acc_8 = Acc_2,
            Bc_4 = Bc,
            Pc_11 = Pc_2;
        _ -> case (Op == 2) of
        true -> Bc_2 = lists:sublist(Bc, Arg) ++ [Acc] ++ lists:nthtail(Arg + 1, Bc),
            Acc_7 = Acc,
            Bc_3 = Bc_2,
            Pc_10 = Pc_2;
        _ -> case (Op == 3) of
        true -> Acc_3 = floormod((Acc + (case erlang:is_map(Bc) of true -> maps:get(Arg, Bc, nil); _ -> lists:nth(Arg + 1, Bc) end)), 256),
            Acc_6 = Acc_3,
            Pc_9 = Pc_2;
        _ -> case (Op == 4) of
        true -> Acc_4 = floormod((Acc - (case erlang:is_map(Bc) of true -> maps:get(Arg, Bc, nil); _ -> lists:nth(Arg + 1, Bc) end)), 256),
            Acc_5 = Acc_4,
            Pc_8 = Pc_2;
        _ -> case (Op == 5) of
        true -> case (Acc == 0) of
        true -> Pc_3 = Arg,
            Pc_4 = Pc_3;
        _ -> Pc_4 = Pc_2
    end,
            Pc_7 = Pc_4;
        _ -> case (Op == 6) of
        true -> Pc_5 = Arg,
            Pc_6 = Pc_5;
        _ -> case (Op == 7) of
        true -> throw(break);
        _ -> throw(break)
    end,
            Pc_6 = Pc_2
    end,
            Pc_7 = Pc_6
    end,
            Acc_5 = Acc,
            Pc_8 = Pc_7
    end,
            Acc_6 = Acc_5,
            Pc_9 = Pc_8
    end,
            Acc_7 = Acc_6,
            Bc_3 = Bc,
            Pc_10 = Pc_9
    end,
            Acc_8 = Acc_7,
            Bc_4 = Bc_3,
            Pc_11 = Pc_10
    end,
            Acc_9 = Acc_8,
            Bc_5 = Bc_4,
            Pc_12 = Pc_11
    end,
                Fun_loop(Acc_9, Bc_5, Pc_12)
            catch
                {continue, C0, C1, C2} -> Fun_loop(C0, C1, C2);
                break -> {Acc, Bc, Pc}
            end;
        _ -> {Acc, Bc, Pc}
    end
end,
{Acc_9, Bc_5, Pc_12} = Fun(Acc, Bc, Pc),
        Acc_9
    catch {return, Ret} -> Ret end.

main() ->
    try
        Programs = [[35, 100, 224, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [44, 106, 76, 43, 141, 75, 168, 192, 44, 224, 8, 7, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [46, 79, 109, 78, 47, 77, 48, 145, 171, 80, 192, 46, 224, 1, 1, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [45, 111, 69, 112, 71, 0, 78, 0, 171, 79, 192, 46, 224, 32, 0, 28, 1, 0, 0, 0, 6, 0, 2, 26, 5, 20, 3, 30, 1, 22, 4, 24], [35, 132, 224, 0, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [35, 132, 224, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [35, 100, 224, 1, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        I = 0,
        Fun_2 = fun Fun_2_loop(I, Programs) ->
    case (I < length(Programs)) of
        true ->
            Res = run((case erlang:is_map(Programs) of true -> maps:get(I, Programs, nil); _ -> lists:nth(I + 1, Programs) end)),
            io:format("~ts~n", [lists:flatten(io_lib:format("~p", [Res]))]),
            I_2 = (I + 1),
            Fun_2_loop(I_2, Programs);
        _ -> {I, Programs}
    end
end,
{I_2, Programs} = Fun_2(I, Programs),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
