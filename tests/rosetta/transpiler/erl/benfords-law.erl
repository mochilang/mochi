#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, floorf/1, indexof/2, fmtf3/1, padfloat3/2, fib1000/0, leadingdigit/1, show/2, main/0]).

% Generated by Mochi transpiler v0.10.40 (305ff8442f) on 2025-07-25 12:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_pad_start(S, Len, Ch) ->
    Fill0 = case Ch of
        "" -> " ";
        _ -> Ch
    end,
    Fill = string:substr(Fill0, 1, 1),
    SL = length(S),
    case SL >= Len of
        true -> S;
        _ -> string:copies(Fill, Len - SL) ++ S
    end.

floorf(X) ->
    try
        Y = mochi_to_int(X),
        float(Y)
    catch {return, Ret} -> Ret end.

indexof(S, Ch) ->
    try
        I = 0,
        Fun = fun Fun_loop(Ch, I, S) ->
    case (I < length(S)) of
        true ->
            case (string:substr(S, I + 1, ((I + 1) - I)) == Ch) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(Ch, I_2, S);
        _ -> {Ch, I, S}
    end
end,
{Ch, I_2, S} = Fun(Ch, I, S),
        -1
    catch {return, Ret} -> Ret end.

fmtf3(X_2) ->
    try
        Y_2 = (floorf(((X_2 * 1000) + 0.5)) / 1000),
        S_2 = lists:flatten(io_lib:format("~p", [Y_2])),
        Dot = indexof(S_2, "."),
        case (Dot == (0 - 1)) of
        true -> S_3 = (S_2 ++ ".000"),
            Decs_4 = nil,
            Fun_4 = nil,
            S_7 = S_3;
        _ -> Decs = ((length(S_2) - Dot) - 1),
            case (Decs > 3) of
        true -> S_4 = string:substr(S_2, 0 + 1, ((Dot + 4) - 0)),
            Decs_3 = Decs,
            Fun_3 = nil,
            S_6 = S_4;
        _ -> Fun_2 = fun Fun_2_loop(Decs, Dot, S_2, X_2, Y_2) ->
    case (Decs < 3) of
        true ->
            S_5 = (S_2 ++ "0"),
            Decs_2 = (Decs + 1),
            Fun_2_loop(Decs_2, Dot, S_5, X_2, Y_2);
        _ -> {Decs, Dot, S_2, X_2, Y_2}
    end
end,
{Decs_2, Dot, S_5, X_2, Y_2} = Fun_2(Decs, Dot, S_2, X_2, Y_2),
            Decs_3 = Decs_2,
            Fun_3 = Fun_2,
            S_6 = S_5
    end,
            Decs_4 = Decs_3,
            Fun_4 = Fun_3,
            S_7 = S_6
    end,
        S_7
    catch {return, Ret} -> Ret end.

padfloat3(X_3, Width) ->
    try
        S_8 = fmtf3(X_3),
        Fun_5 = fun Fun_5_loop(S_8, Width, X_3) ->
    case (length(S_8) < Width) of
        true ->
            S_9 = (" " ++ S_8),
            Fun_5_loop(S_9, Width, X_3);
        _ -> {S_8, Width, X_3}
    end
end,
{S_9, Width, X_3} = Fun_5(S_8, Width, X_3),
        S_9
    catch {return, Ret} -> Ret end.

fib1000() ->
    try
        A = 0,
        B = 1,
        Res = [],
        I_3 = 0,
        Fun_6 = fun Fun_6_loop(A, B, I_3, Res) ->
    case (I_3 < 1000) of
        true ->
            Res_2 = lists:append(Res, [B]),
            T = B,
            B_2 = (B + A),
            A_2 = T,
            I_4 = (I_3 + 1),
            Fun_6_loop(A_2, B_2, I_4, Res_2);
        _ -> {A, B, I_3, Res}
    end
end,
{A_2, B_2, I_4, Res_2} = Fun_6(A, B, I_3, Res),
        Res_2
    catch {return, Ret} -> Ret end.

leadingdigit(X_4) ->
    try
        case (X_4 < 0) of
        true -> X_5 = -X_4,
            X_6 = X_5;
        _ -> X_6 = X_4
    end,
        Fun_7 = fun Fun_7_loop(X_6) ->
    case (X_6 >= 10) of
        true ->
            X_7 = (X_6 / 10),
            Fun_7_loop(X_7);
        _ -> {X_6}
    end
end,
{X_7} = Fun_7(X_6),
        Fun_8 = fun Fun_8_loop(X_7) ->
    case ((X_7 > 0) andalso (X_7 < 1)) of
        true ->
            X_8 = (X_7 * 10),
            Fun_8_loop(X_8);
        _ -> {X_7}
    end
end,
{X_8} = Fun_8(X_7),
        mochi_to_int(X_8)
    catch {return, Ret} -> Ret end.

show(Nums, Title) ->
    try
        Counts = [0, 0, 0, 0, 0, 0, 0, 0, 0],
        Fun_9 = fun Fun_9_loop(List, Counts, Nums, Title) ->
    case List of
        [] -> {Counts, Nums, Title};
        [N|List_rest] ->
            D = leadingdigit(N),
            case ((D >= 1) andalso (D =< 9)) of
        true -> Counts_2 = lists:sublist(Counts, (D - 1)) ++ [(lists:nth((D - 1) + 1, Counts) + 1)] ++ lists:nthtail((D - 1) + 1, Counts),
            Counts_3 = Counts_2;
        _ -> Counts_3 = Counts
    end,
            Fun_9_loop(List_rest, Counts_3, Nums, Title)
    end
end,
{Counts_3, Nums, Title} = Fun_9(Nums, Counts, Nums, Title),
        Preds = [0.301, 0.176, 0.125, 0.097, 0.079, 0.067, 0.058, 0.051, 0.046],
        Total = length(Nums),
        io:format("~ts~n", [Title]),
        io:format("~ts~n", ["Digit  Observed  Predicted"]),
        I_5 = 0,
        Fun_10 = fun Fun_10_loop(Counts_3, I_5, Nums, Preds, Title, Total) ->
    case (I_5 < 9) of
        true ->
            Obs = (float(lists:nth(I_5 + 1, Counts_3)) / float(Total)),
            Line = ((((("  " ++ lists:flatten(io_lib:format("~p", [(I_5 + 1)]))) ++ "  ") ++ padfloat3(Obs, 9)) ++ "  ") ++ padfloat3(lists:nth(I_5 + 1, Preds), 8)),
            io:format("~ts~n", [Line]),
            I_6 = (I_5 + 1),
            Fun_10_loop(Counts_3, I_6, Nums, Preds, Title, Total);
        _ -> {Counts_3, I_5, Nums, Preds, Title, Total}
    end
end,
{Counts_3, I_6, Nums, Preds, Title, Total} = Fun_10(Counts_3, I_5, Nums, Preds, Title, Total),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        show(fib1000(), "First 1000 Fibonacci numbers"),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
