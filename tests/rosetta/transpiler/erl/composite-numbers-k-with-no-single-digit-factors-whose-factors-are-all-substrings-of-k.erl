#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, primefactors/1, commatize/1, indexof/2, pad10/1, trimrightstr/1, main/0]).

% Generated by Mochi transpiler v0.10.41 (df7e5d4e15) on 2025-07-27 05:47 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.

primefactors(N) ->
    try
        Factors = [],
        X = N,
        Fun = fun Fun_loop(Factors, N, X) ->
    case ((X rem 2) == 0) of
        true ->
            Factors_2 = lists:append(Factors, [2]),
            X_2 = mochi_to_int((X / 2)),
            Fun_loop(Factors_2, N, X_2);
        _ -> {Factors, N, X}
    end
end,
{Factors_2, N, X_2} = Fun(Factors, N, X),
        P = 3,
        Fun_3 = fun Fun_3_loop(Factors_2, N, P, X_2) ->
    case ((P * P) =< X_2) of
        true ->
            Fun_2 = fun Fun_2_loop(Factors_2, N, P, X_2) ->
    case ((X_2 rem P) == 0) of
        true ->
            Factors_3 = lists:append(Factors_2, [P]),
            X_3 = mochi_to_int((X_2 / P)),
            Fun_2_loop(Factors_3, N, P, X_3);
        _ -> {Factors_2, N, P, X_2}
    end
end,
{Factors_3, N, P, X_3} = Fun_2(Factors_2, N, P, X_2),
            P_2 = (P + 2),
            Fun_3_loop(Factors_3, N, P_2, X_3);
        _ -> {Factors_2, N, P, X_2}
    end
end,
{Factors_3, N, P_2, X_3} = Fun_3(Factors_2, N, P, X_2),
        case (X_3 > 1) of
        true -> Factors_4 = lists:append(Factors_3, [X_3]),
            Factors_5 = Factors_4;
        _ -> Factors_5 = Factors_3
    end,
        Factors_5
    catch {return, Ret} -> Ret end.

commatize(N_2) ->
    try
        S = lists:flatten(io_lib:format("~p", [N_2])),
        Out = "",
        I = (length(S) - 1),
        C = 0,
        Fun_4 = fun Fun_4_loop(C, I, N_2, Out, S) ->
    case (I >= 0) of
        true ->
            Out_2 = (string:substr(S, I + 1, ((I + 1) - I)) ++ Out),
            C_2 = (C + 1),
            case (((C_2 rem 3) == 0) andalso (I > 0)) of
        true -> Out_3 = ("," ++ Out_2),
            Out_4 = Out_3;
        _ -> Out_4 = Out_2
    end,
            I_2 = (I - 1),
            Fun_4_loop(C_2, I_2, N_2, Out_4, S);
        _ -> {C, I, N_2, Out, S}
    end
end,
{C_2, I_2, N_2, Out_4, S} = Fun_4(C, I, N_2, Out, S),
        Out_4
    catch {return, Ret} -> Ret end.

indexof(S_2, Sub) ->
    try
        I_3 = 0,
        Fun_5 = fun Fun_5_loop(I_3, S_2, Sub) ->
    case ((I_3 + length(Sub)) =< length(S_2)) of
        true ->
            case (string:substr(S_2, I_3 + 1, ((I_3 + length(Sub)) - I_3)) == Sub) of
        true -> throw({return, I_3});
        _ -> ok
    end,
            I_4 = (I_3 + 1),
            Fun_5_loop(I_4, S_2, Sub);
        _ -> {I_3, S_2, Sub}
    end
end,
{I_4, S_2, Sub} = Fun_5(I_3, S_2, Sub),
        -1
    catch {return, Ret} -> Ret end.

pad10(S_3) ->
    try
        Str = S_3,
        Fun_6 = fun Fun_6_loop(S_3, Str) ->
    case (length(Str) < 10) of
        true ->
            Str_2 = (" " ++ Str),
            Fun_6_loop(S_3, Str_2);
        _ -> {S_3, Str}
    end
end,
{S_3, Str_2} = Fun_6(S_3, Str),
        Str_2
    catch {return, Ret} -> Ret end.

trimrightstr(S_4) ->
    try
        End = length(S_4),
        Fun_7 = fun Fun_7_loop(End, S_4) ->
    case ((End > 0) andalso (string:substr(S_4, (End - 1) + 1, (End - (End - 1))) == " ")) of
        true ->
            End_2 = (End - 1),
            Fun_7_loop(End_2, S_4);
        _ -> {End, S_4}
    end
end,
{End_2, S_4} = Fun_7(End, S_4),
        string:substr(S_4, 0 + 1, (End_2 - 0))
    catch {return, Ret} -> Ret end.

main() ->
    try
        Res = [],
        Count = 0,
        K = (11 * 11),
        Fun_10 = fun Fun_10_loop(Count, K, Res) ->
    case (Count < 20) of
        true ->
            try
                case ((((K rem 3) == 0) orelse ((K rem 5) == 0)) orelse ((K rem 7) == 0)) of
        true -> K_2 = (K + 2),
            throw({continue, Count, K_2, Res}),
            K_3 = K_2;
        _ -> K_3 = K
    end,
                Factors_6 = primefactors(K_3),
                case (length(Factors_6) > 1) of
        true -> S_5 = lists:flatten(io_lib:format("~p", [K_3])),
            IncludesAll = true,
            Prev = -1,
            Fun_8 = fun Fun_8_loop(List, Count, Factors_6, IncludesAll, K_3, Prev, Res, S_5) ->
    case List of
        [] -> {Count, Factors_6, IncludesAll, K_3, Prev, Res, S_5};
        [F|F_rest] ->
        try
            case (F == Prev) of
        true -> throw({continue, Count, Factors_6, IncludesAll, K_3, Prev, Res, S_5});
        _ -> ok
    end,
            Fs = lists:flatten(io_lib:format("~p", [F])),
            case (mochi_index_of(S_5, Fs) == -1) of
        true -> IncludesAll_2 = false,
            throw(break),
            IncludesAll_3 = IncludesAll_2;
        _ -> IncludesAll_3 = IncludesAll
    end,
            Prev_2 = F,
            Fun_8_loop(F_rest, Count, Factors_6, IncludesAll_3, K_3, Prev_2, Res, S_5)
        catch
            {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_8_loop(F_rest, C0, C1, C2, C3, C4, C5, C6);
            {break, B0, B1, B2, B3, B4, B5, B6} -> {B0, B1, B2, B3, B4, B5, B6};
            break -> {Count, Factors_6, IncludesAll, K_3, Prev, Res, S_5}
        end
    end
end,
{Count, Factors_6, IncludesAll_3, K_3, Prev_2, Res, S_5} = Fun_8(Factors_6, Count, Factors_6, IncludesAll, K_3, Prev, Res, S_5),
            case IncludesAll_3 of
        true -> Res_2 = lists:append(Res, [K_3]),
            Count_2 = (Count + 1),
            Count_3 = Count_2,
            Res_3 = Res_2;
        _ -> Count_3 = Count,
            Res_3 = Res
    end,
            Count_4 = Count_3,
            Fun_9 = Fun_8,
            IncludesAll_4 = IncludesAll_3,
            Prev_3 = Prev_2,
            Res_4 = Res_3,
            S_6 = S_5;
        _ -> Count_4 = Count,
            Fun_9 = nil,
            IncludesAll_4 = nil,
            Prev_3 = nil,
            Res_4 = Res,
            S_6 = nil
    end,
                K_4 = (K_3 + 2),
                Fun_10_loop(Count_4, K_4, Res_4)
            catch
                {continue, C0, C1, C2} -> Fun_10_loop(C0, C1, C2);
                break -> {Count, K, Res}
            end;
        _ -> {Count, K, Res}
    end
end,
{Count_4, K_4, Res_4} = Fun_10(Count, K, Res),
        Line = "",
        Fun_11 = fun Fun_11_loop(List, Count_4, K_4, Line, Res_4) ->
    case List of
        [] -> {Count_4, K_4, Line, Res_4};
        [E|E_rest] ->
            Line_2 = ((Line ++ pad10(commatize(E))) ++ " "),
            Fun_11_loop(E_rest, Count_4, K_4, Line_2, Res_4)
    end
end,
{Count_4, K_4, Line_2, Res_4} = Fun_11(lists:sublist(Res_4, 0 + 1, (10 - 0)), Count_4, K_4, Line, Res_4),
        io:format("~p~n", [trimrightstr(Line_2)]),
        Line_3 = "",
        Fun_12 = fun Fun_12_loop(List, Count_4, K_4, Line_3, Res_4) ->
    case List of
        [] -> {Count_4, K_4, Line_3, Res_4};
        [E_2|E_2_rest] ->
            Line_4 = (("" ++ pad10(commatize(E_2))) ++ " "),
            Fun_12_loop(E_2_rest, Count_4, K_4, Line_4, Res_4)
    end
end,
{Count_4, K_4, Line_4, Res_4} = Fun_12(lists:sublist(Res_4, 10 + 1, (20 - 10)), Count_4, K_4, Line_3, Res_4),
        io:format("~p~n", [trimrightstr(Line_4)]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
