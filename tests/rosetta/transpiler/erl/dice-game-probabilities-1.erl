#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, powint/2, minint/2, throwdie/4, beatingprobability/4]).

% Generated by Mochi transpiler v0.10.42 (0b43aa313d) on 2025-07-28 04:49 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

powint(Base, Exp) ->
    try
        R = 1,
        B = Base,
        E = Exp,
        Fun = fun Fun_loop(B, Base, E, Exp, R) ->
    case (E > 0) of
        true ->
            case ((E rem 2) == 1) of
        true -> R_2 = (R * B),
            R_3 = R_2;
        _ -> R_3 = R
    end,
            B_2 = (B * B),
            E_2 = (E div mochi_to_int(2)),
            Fun_loop(B_2, Base, E_2, Exp, R_3);
        _ -> {B, Base, E, Exp, R}
    end
end,
{B_2, Base, E_2, Exp, R_3} = Fun(B, Base, E, Exp, R),
        R_3
    catch {return, Ret} -> Ret end.

minint(X, Y) ->
    try
        (case (X < Y) of
    true -> X;
    _ -> Y
end)
    catch {return, Ret} -> Ret end.

throwdie(NSides, NDice, S, Counts) ->
    try
        case (NDice == 0) of
        true -> Counts_2 = lists:sublist(Counts, S) ++ [(lists:nth(S + 1, Counts) + 1)] ++ lists:nthtail(S + 1, Counts),
            throw({return, Counts_2}),
            Counts_3 = Counts_2;
        _ -> Counts_3 = Counts
    end,
        I = 1,
        Fun_2 = fun Fun_2_loop(Counts_3, I, NDice, NSides, S) ->
    case (I =< NSides) of
        true ->
            throwdie(NSides, (NDice - 1), (S + I), Counts_3),
            I_2 = (I + 1),
            Fun_2_loop(Counts_3, I_2, NDice, NSides, S);
        _ -> {Counts_3, I, NDice, NSides, S}
    end
end,
{Counts_3, I_2, NDice, NSides, S} = Fun_2(Counts_3, I, NDice, NSides, S),
        nil
    catch {return, Ret} -> Ret end.

beatingprobability(NSides1, NDice1, NSides2, NDice2) ->
    try
        Len1 = ((NSides1 + 1) * NDice1),
        C1 = [],
        I_3 = 0,
        Fun_3 = fun Fun_3_loop(C1, I_3, Len1, NDice1, NDice2, NSides1, NSides2) ->
    case (I_3 < Len1) of
        true ->
            C1_2 = lists:append(C1, [0]),
            I_4 = (I_3 + 1),
            Fun_3_loop(C1_2, I_4, Len1, NDice1, NDice2, NSides1, NSides2);
        _ -> {C1, I_3, Len1, NDice1, NDice2, NSides1, NSides2}
    end
end,
{C1_2, I_4, Len1, NDice1, NDice2, NSides1, NSides2} = Fun_3(C1, I_3, Len1, NDice1, NDice2, NSides1, NSides2),
        throwdie(NSides1, NDice1, 0, C1_2),
        Len2 = ((NSides2 + 1) * NDice2),
        C2 = [],
        J = 0,
        Fun_4 = fun Fun_4_loop(C1_2, C2, I_4, J, Len1, Len2, NDice1, NDice2, NSides1, NSides2) ->
    case (J < Len2) of
        true ->
            C2_2 = lists:append(C2, [0]),
            J_2 = (J + 1),
            Fun_4_loop(C1_2, C2_2, I_4, J_2, Len1, Len2, NDice1, NDice2, NSides1, NSides2);
        _ -> {C1_2, C2, I_4, J, Len1, Len2, NDice1, NDice2, NSides1, NSides2}
    end
end,
{C1_2, C2_2, I_4, J_2, Len1, Len2, NDice1, NDice2, NSides1, NSides2} = Fun_4(C1_2, C2, I_4, J, Len1, Len2, NDice1, NDice2, NSides1, NSides2),
        throwdie(NSides2, NDice2, 0, C2_2),
        P12 = (float(powint(NSides1, NDice1)) * float(powint(NSides2, NDice2))),
        Tot = 0,
        I_5 = 0,
        Fun_6 = fun Fun_6_loop(C1_2, C2_2, I_5, J_2, Len1, Len2, NDice1, NDice2, NSides1, NSides2, P12, Tot) ->
    case (I_5 < Len1) of
        true ->
            J_3 = 0,
            M = minint(I_5, Len2),
            Fun_5 = fun Fun_5_loop(C1_2, C2_2, I_5, J_3, Len1, Len2, M, NDice1, NDice2, NSides1, NSides2, P12, Tot) ->
    case (J_3 < M) of
        true ->
            Tot_2 = (Tot + ((lists:nth(I_5 + 1, C1_2) * float(lists:nth(J_3 + 1, C2_2))) / P12)),
            J_4 = (J_3 + 1),
            Fun_5_loop(C1_2, C2_2, I_5, J_4, Len1, Len2, M, NDice1, NDice2, NSides1, NSides2, P12, Tot_2);
        _ -> {C1_2, C2_2, I_5, J_3, Len1, Len2, M, NDice1, NDice2, NSides1, NSides2, P12, Tot}
    end
end,
{C1_2, C2_2, I_5, J_4, Len1, Len2, M, NDice1, NDice2, NSides1, NSides2, P12, Tot_2} = Fun_5(C1_2, C2_2, I_5, J_3, Len1, Len2, M, NDice1, NDice2, NSides1, NSides2, P12, Tot),
            I_6 = (I_5 + 1),
            Fun_6_loop(C1_2, C2_2, I_6, J_4, Len1, Len2, NDice1, NDice2, NSides1, NSides2, P12, Tot_2);
        _ -> {C1_2, C2_2, I_5, J_2, Len1, Len2, NDice1, NDice2, NSides1, NSides2, P12, Tot}
    end
end,
{C1_2, C2_2, I_6, J_4, Len1, Len2, NDice1, NDice2, NSides1, NSides2, P12, Tot_2} = Fun_6(C1_2, C2_2, I_5, J_2, Len1, Len2, NDice1, NDice2, NSides1, NSides2, P12, Tot),
        Tot_2
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    io:format("~ts~n", [lists:flatten(io_lib:format("~p", [beatingprobability(4, 9, 6, 6)]))]),
    io:format("~ts~n", [lists:flatten(io_lib:format("~p", [beatingprobability(10, 5, 7, 6)]))]),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
