#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, randn/1, newfield/2, setcell/4, state/3, nextstate/3, newlife/2, step/1, lifestring/1, main/0]).

% Generated by Mochi transpiler v0.10.41 (4e0e7fcd7f) on 2025-07-26 23:05 UTC


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

randn(N) ->
    try
        erlang:put('seed', (((erlang:get('seed') * 1664525) + 1013904223) rem 2147483647)),
        (erlang:get('seed') rem N)
    catch {return, Ret} -> Ret end.

newfield(W, H) ->
    try
        Rows = [],
        Y = 0,
        Fun_2 = fun Fun_2_loop(H, Rows, W, Y) ->
    case (Y < H) of
        true ->
            Row = [],
            X = 0,
            Fun = fun Fun_loop(H, Row, Rows, W, X, Y) ->
    case (X < W) of
        true ->
            Row_2 = lists:append(Row, [false]),
            X_2 = (X + 1),
            Fun_loop(H, Row_2, Rows, W, X_2, Y);
        _ -> {H, Row, Rows, W, X, Y}
    end
end,
{H, Row_2, Rows, W, X_2, Y} = Fun(H, Row, Rows, W, X, Y),
            Rows_2 = lists:append(Rows, [Row_2]),
            Y_2 = (Y + 1),
            Fun_2_loop(H, Rows_2, W, Y_2);
        _ -> {H, Rows, W, Y}
    end
end,
{H, Rows_2, W, Y_2} = Fun_2(H, Rows, W, Y),
        #{"s" => Rows_2, "w" => W, "h" => H}
    catch {return, Ret} -> Ret end.

setcell(F, X_3, Y_3, B) ->
    try
        Rows_3 = maps:get("s", F, nil),
        Row_3 = maps:get(Y_3, Rows_3, nil),
        Row_4 = maps:put(X_3, B, Row_3),
        Rows_4 = maps:put(Y_3, Row_4, Rows_3),
        F_2 = maps:put("s", Rows_4, F),
        F_2
    catch {return, Ret} -> Ret end.

state(F_3, X_4, Y_4) ->
    try
        Fun_3 = fun Fun_3_loop(F_3, X_4, Y_4) ->
    case (Y_4 < 0) of
        true ->
            Y_5 = (Y_4 + maps:get("h", F_3, nil)),
            Fun_3_loop(F_3, X_4, Y_5);
        _ -> {F_3, X_4, Y_4}
    end
end,
{F_3, X_4, Y_5} = Fun_3(F_3, X_4, Y_4),
        Fun_4 = fun Fun_4_loop(F_3, X_4, Y_5) ->
    case (X_4 < 0) of
        true ->
            X_5 = (X_4 + maps:get("w", F_3, nil)),
            Fun_4_loop(F_3, X_5, Y_5);
        _ -> {F_3, X_4, Y_5}
    end
end,
{F_3, X_5, Y_5} = Fun_4(F_3, X_4, Y_5),
        lists:nth((X_5 rem maps:get("w", F_3, nil)) + 1, lists:nth((Y_5 rem maps:get("h", F_3, nil)) + 1, maps:get("s", F_3, nil)))
    catch {return, Ret} -> Ret end.

nextstate(F_4, X_6, Y_6) ->
    try
        Count = 0,
        Dy = -1,
        Fun_6 = fun Fun_6_loop(Count, Dy, F_4, X_6, Y_6) ->
    case (Dy =< 1) of
        true ->
            Dx = -1,
            Fun_5 = fun Fun_5_loop(Count, Dx, Dy, F_4, X_6, Y_6) ->
    case (Dx =< 1) of
        true ->
            case (mochi_not(((Dx == 0) andalso (Dy == 0))) andalso state(F_4, (X_6 + Dx), (Y_6 + Dy))) of
        true -> Count_2 = (Count + 1),
            Count_3 = Count_2;
        _ -> Count_3 = Count
    end,
            Dx_2 = (Dx + 1),
            Fun_5_loop(Count_3, Dx_2, Dy, F_4, X_6, Y_6);
        _ -> {Count, Dx, Dy, F_4, X_6, Y_6}
    end
end,
{Count_3, Dx_2, Dy, F_4, X_6, Y_6} = Fun_5(Count, Dx, Dy, F_4, X_6, Y_6),
            Dy_2 = (Dy + 1),
            Fun_6_loop(Count_3, Dy_2, F_4, X_6, Y_6);
        _ -> {Count, Dy, F_4, X_6, Y_6}
    end
end,
{Count_3, Dy_2, F_4, X_6, Y_6} = Fun_6(Count, Dy, F_4, X_6, Y_6),
        ((Count_3 == 3) orelse ((Count_3 == 2) andalso state(F_4, X_6, Y_6)))
    catch {return, Ret} -> Ret end.

newlife(W_2, H_2) ->
    try
        A = newfield(W_2, H_2),
        I = 0,
        Fun_7 = fun Fun_7_loop(A, H_2, I, W_2) ->
    case (I < ((W_2 * H_2) / 2)) of
        true ->
            setcell(A, randn(W_2), randn(H_2), true),
            I_2 = (I + 1),
            Fun_7_loop(A, H_2, I_2, W_2);
        _ -> {A, H_2, I, W_2}
    end
end,
{A, H_2, I_2, W_2} = Fun_7(A, H_2, I, W_2),
        #{"a" => A, "b" => newfield(W_2, H_2), "w" => W_2, "h" => H_2}
    catch {return, Ret} -> Ret end.

step(L) ->
    try
        Y_7 = 0,
        Fun_9 = fun Fun_9_loop(L, Y_7) ->
    case (Y_7 < maps:get("h", L, nil)) of
        true ->
            X_7 = 0,
            Fun_8 = fun Fun_8_loop(L, X_7, Y_7) ->
    case (X_7 < maps:get("w", L, nil)) of
        true ->
            setcell(maps:get("b", L, nil), X_7, Y_7, nextstate(maps:get("a", L, nil), X_7, Y_7)),
            X_8 = (X_7 + 1),
            Fun_8_loop(L, X_8, Y_7);
        _ -> {L, X_7, Y_7}
    end
end,
{L, X_8, Y_7} = Fun_8(L, X_7, Y_7),
            Y_8 = (Y_7 + 1),
            Fun_9_loop(L, Y_8);
        _ -> {L, Y_7}
    end
end,
{L, Y_8} = Fun_9(L, Y_7),
        Tmp = maps:get("a", L, nil),
        L_2 = maps:put("a", maps:get("b", L, nil), L),
        L_3 = maps:put("b", Tmp, L_2),
        L_3
    catch {return, Ret} -> Ret end.

lifestring(L_4) ->
    try
        Out = "",
        Y_9 = 0,
        Fun_11 = fun Fun_11_loop(L_4, Out, Y_9) ->
    case (Y_9 < maps:get("h", L_4, nil)) of
        true ->
            X_9 = 0,
            Fun_10 = fun Fun_10_loop(L_4, Out, X_9, Y_9) ->
    case (X_9 < maps:get("w", L_4, nil)) of
        true ->
            case state(maps:get("a", L_4, nil), X_9, Y_9) of
        true -> Out_2 = (Out ++ "*"),
            Out_4 = Out_2;
        _ -> Out_3 = (Out ++ " "),
            Out_4 = Out_3
    end,
            X_10 = (X_9 + 1),
            Fun_10_loop(L_4, Out_4, X_10, Y_9);
        _ -> {L_4, Out, X_9, Y_9}
    end
end,
{L_4, Out_4, X_10, Y_9} = Fun_10(L_4, Out, X_9, Y_9),
            Out_5 = (Out_4 ++ "\n"),
            Y_10 = (Y_9 + 1),
            Fun_11_loop(L_4, Out_5, Y_10);
        _ -> {L_4, Out, Y_9}
    end
end,
{L_4, Out_5, Y_10} = Fun_11(L_4, Out, Y_9),
        Out_5
    catch {return, Ret} -> Ret end.

main() ->
    try
        L_5 = newlife(80, 15),
        I_3 = 0,
        Fun_12 = fun Fun_12_loop(I_3, L_5) ->
    case (I_3 < 300) of
        true ->
            L_6 = step(L_5),
            io:format("~ts~n", ["\f"]),
            io:format("~p~n", [lifestring(L_6)]),
            I_4 = (I_3 + 1),
            Fun_12_loop(I_4, L_6);
        _ -> {I_3, L_5}
    end
end,
{I_4, L_6} = Fun_12(I_3, L_5),
        L_6
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('seed', 1),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
