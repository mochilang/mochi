#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, chr/1, bf/2, main/0]).

% Generated by Mochi transpiler v0.10.55 (6aa59f472e) on 2025-08-02 17:26 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

chr(N) ->
    try
        Upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        Lower = "abcdefghijklmnopqrstuvwxyz",
        case ((N >= 65) andalso (N < 91)) of
        true -> throw({return, string:substr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", (N - 65) + 1, ((N - 64) - (N - 65)))});
        _ -> ok
    end,
        case ((N >= 97) andalso (N < 123)) of
        true -> throw({return, string:substr("abcdefghijklmnopqrstuvwxyz", (N - 97) + 1, ((N - 96) - (N - 97)))});
        _ -> ok
    end,
        case (N == 32) of
        true -> throw({return, " "});
        _ -> ok
    end,
        case (N == 33) of
        true -> throw({return, "!"});
        _ -> ok
    end,
        case (N == 44) of
        true -> throw({return, ","});
        _ -> ok
    end,
        case (N == 13) of
        true -> throw({return, ""});
        _ -> ok
    end,
        case (N == 10) of
        true -> throw({return, "\n"});
        _ -> ok
    end,
        "?"
    catch {return, Ret} -> Ret end.

bf(DLen, Code) ->
    try
        Ds = [],
        Fun = fun Fun_loop(List, Code, DLen, Ds) ->
    case List of
        [] -> {Code, DLen, Ds};
        [I|I_rest] ->
            Ds_2 = lists:append(Ds, [0]),
            Fun_loop(I_rest, Code, DLen, Ds_2)
    end
end,
{Code, DLen, Ds_2} = Fun(lists:seq(0, (DLen) - 1), Code, DLen, Ds),
        Dp = 0,
        Ip = 0,
        Out = "",
        Fun_14 = fun Fun_14_loop(Code, DLen, Dp, Ds_2, Ip, Out) ->
    case (Ip < length(Code)) of
        true ->
            Ch = string:substr(Code, Ip + 1, ((Ip + 1) - Ip)),
            case (Ch == ">") of
        true -> Dp_2 = (Dp + 1),
            Dp_5 = Dp_2,
            Ds_8 = Ds_2,
            Fun_13 = Fun,
            Ip_13 = Ip,
            Nc_20 = nil,
            Out_7 = Out;
        _ -> case (Ch == "<") of
        true -> Dp_3 = (Dp - 1),
            Dp_4 = Dp_3,
            Ds_7 = Ds_2,
            Fun_12 = Fun,
            Ip_12 = Ip,
            Nc_19 = nil,
            Out_6 = Out;
        _ -> case (Ch == "+") of
        true -> Ds_3 = lists:sublist(Ds_2, Dp) ++ [((case erlang:is_map(Ds_2) of true -> maps:get(Dp, Ds_2, nil); _ -> lists:nth(Dp + 1, Ds_2) end) + 1)] ++ lists:nthtail(Dp + 1, Ds_2),
            Ds_6 = Ds_3,
            Fun_11 = Fun,
            Ip_11 = Ip,
            Nc_18 = nil,
            Out_5 = Out;
        _ -> case (Ch == "-") of
        true -> Ds_4 = lists:sublist(Ds_2, Dp) ++ [((case erlang:is_map(Ds_2) of true -> maps:get(Dp, Ds_2, nil); _ -> lists:nth(Dp + 1, Ds_2) end) - 1)] ++ lists:nthtail(Dp + 1, Ds_2),
            Ds_5 = Ds_4,
            Fun_10 = Fun,
            Ip_10 = Ip,
            Nc_17 = nil,
            Out_4 = Out;
        _ -> case (Ch == ".") of
        true -> Out_2 = (Out ++ chr((case erlang:is_map(Ds_2) of true -> maps:get(Dp, Ds_2, nil); _ -> lists:nth(Dp + 1, Ds_2) end))),
            Fun_9 = Fun,
            Ip_9 = Ip,
            Nc_16 = nil,
            Out_3 = Out_2;
        _ -> case (Ch == ",") of
        true -> Fun_8 = Fun,
            Ip_8 = Ip,
            Nc_15 = nil;
        _ -> case (Ch == "[") of
        true -> case ((case erlang:is_map(Ds_2) of true -> maps:get(Dp, Ds_2, nil); _ -> lists:nth(Dp + 1, Ds_2) end) == 0) of
        true -> Nc = 1,
            Fun_2 = fun Fun_2_loop(Ch, Code, DLen, Dp, Ds_2, Ip, Nc, Out) ->
    case (Nc > 0) of
        true ->
            Ip_2 = (Ip + 1),
            Cc = string:substr(Code, Ip_2 + 1, ((Ip_2 + 1) - Ip_2)),
            case (Cc == "[") of
        true -> Nc_2 = (Nc + 1),
            Nc_5 = Nc_2;
        _ -> case (Cc == "]") of
        true -> Nc_3 = (Nc - 1),
            Nc_4 = Nc_3;
        _ -> Nc_4 = Nc
    end,
            Nc_5 = Nc_4
    end,
            Fun_2_loop(Ch, Code, DLen, Dp, Ds_2, Ip_2, Nc_5, Out);
        _ -> {Ch, Code, DLen, Dp, Ds_2, Ip, Nc, Out}
    end
end,
{Ch, Code, DLen, Dp, Ds_2, Ip_2, Nc_5, Out} = Fun_2(Ch, Code, DLen, Dp, Ds_2, Ip, Nc, Out),
            Fun_3 = Fun_2,
            Ip_3 = Ip_2,
            Nc_6 = Nc_5;
        _ -> Fun_3 = Fun,
            Ip_3 = Ip,
            Nc_6 = nil
    end,
            Fun_7 = Fun_3,
            Ip_7 = Ip_3,
            Nc_14 = Nc_6;
        _ -> case (Ch == "]") of
        true -> case ((case erlang:is_map(Ds_2) of true -> maps:get(Dp, Ds_2, nil); _ -> lists:nth(Dp + 1, Ds_2) end) /= 0) of
        true -> Nc_7 = 1,
            Fun_4 = fun Fun_4_loop(Ch, Code, DLen, Dp, Ds_2, Ip, Nc_7, Out) ->
    case (Nc_7 > 0) of
        true ->
            Ip_4 = (Ip - 1),
            Cc_2 = string:substr(Code, Ip_4 + 1, ((Ip_4 + 1) - Ip_4)),
            case (Cc_2 == "]") of
        true -> Nc_8 = (Nc_7 + 1),
            Nc_11 = Nc_8;
        _ -> case (Cc_2 == "[") of
        true -> Nc_9 = (Nc_7 - 1),
            Nc_10 = Nc_9;
        _ -> Nc_10 = Nc_7
    end,
            Nc_11 = Nc_10
    end,
            Fun_4_loop(Ch, Code, DLen, Dp, Ds_2, Ip_4, Nc_11, Out);
        _ -> {Ch, Code, DLen, Dp, Ds_2, Ip, Nc_7, Out}
    end
end,
{Ch, Code, DLen, Dp, Ds_2, Ip_4, Nc_11, Out} = Fun_4(Ch, Code, DLen, Dp, Ds_2, Ip, Nc_7, Out),
            Fun_5 = Fun_4,
            Ip_5 = Ip_4,
            Nc_12 = Nc_11;
        _ -> Fun_5 = Fun,
            Ip_5 = Ip,
            Nc_12 = nil
    end,
            Fun_6 = Fun_5,
            Ip_6 = Ip_5,
            Nc_13 = Nc_12;
        _ -> Fun_6 = Fun,
            Ip_6 = Ip,
            Nc_13 = nil
    end,
            Fun_7 = Fun_6,
            Ip_7 = Ip_6,
            Nc_14 = Nc_13
    end,
            Fun_8 = Fun_7,
            Ip_8 = Ip_7,
            Nc_15 = Nc_14
    end,
            Fun_9 = Fun_8,
            Ip_9 = Ip_8,
            Nc_16 = Nc_15,
            Out_3 = Out
    end,
            Ds_5 = Ds_2,
            Fun_10 = Fun_9,
            Ip_10 = Ip_9,
            Nc_17 = Nc_16,
            Out_4 = Out_3
    end,
            Ds_6 = Ds_5,
            Fun_11 = Fun_10,
            Ip_11 = Ip_10,
            Nc_18 = Nc_17,
            Out_5 = Out_4
    end,
            Dp_4 = Dp,
            Ds_7 = Ds_6,
            Fun_12 = Fun_11,
            Ip_12 = Ip_11,
            Nc_19 = Nc_18,
            Out_6 = Out_5
    end,
            Dp_5 = Dp_4,
            Ds_8 = Ds_7,
            Fun_13 = Fun_12,
            Ip_13 = Ip_12,
            Nc_20 = Nc_19,
            Out_7 = Out_6
    end,
            Ip_14 = (Ip_13 + 1),
            Fun_14_loop(Code, DLen, Dp_5, Ds_8, Ip_14, Out_7);
        _ -> {Code, DLen, Dp, Ds_2, Ip, Out}
    end
end,
{Code, DLen, Dp_5, Ds_8, Ip_14, Out_7} = Fun_14(Code, DLen, Dp, Ds_2, Ip, Out),
        Out_7
    catch {return, Ret} -> Ret end.

main() ->
    try
        Prog = ((("++++++++++[>+>+++>++++>+++++++>++++++++>+++++++++>++\n" ++ "++++++++>+++++++++++>++++++++++++<<<<<<<<<-]>>>>+.>>>\n") ++ ">+..<.<++++++++.>>>+.<<+.<<<<++++.<++.>>>+++++++.>>>.+++.\n") ++ "<+++++++.--------.<<<<<+.<+++.---."),
        Out_8 = bf(10, Prog),
        io:format("~ts~n", [Out_8]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
