#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, split/2, trimspace/1, indexofsub/2, parserules/1, runrules/2, interpret/2, main/0]).

% Generated by Mochi transpiler v0.10.55 (6aa59f472e) on 2025-08-02 17:26 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

split(S, Sep) ->
    try
        Parts = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, Parts, S, Sep) ->
    case (I < length(S)) of
        true ->
            case (((length(Sep) > 0) andalso ((I + length(Sep)) =< length(S))) andalso (string:substr(S, I + 1, ((I + length(Sep)) - I)) == Sep)) of
        true -> Parts_2 = lists:append(Parts, [Cur]),
            Cur_2 = "",
            I_2 = (I + length(Sep)),
            Cur_4 = Cur_2,
            I_4 = I_2,
            Parts_3 = Parts_2;
        _ -> Cur_3 = (Cur ++ string:substr(S, I + 1, ((I + 1) - I))),
            I_3 = (I + 1),
            Cur_4 = Cur_3,
            I_4 = I_3,
            Parts_3 = Parts
    end,
            Fun_loop(Cur_4, I_4, Parts_3, S, Sep);
        _ -> {Cur, I, Parts, S, Sep}
    end
end,
{Cur_4, I_4, Parts_3, S, Sep} = Fun(Cur, I, Parts, S, Sep),
        Parts_4 = lists:append(Parts_3, [Cur_4]),
        Parts_4
    catch {return, Ret} -> Ret end.

trimspace(S_2) ->
    try
        Start = 0,
        Fun_2 = fun Fun_2_loop(S_2, Start) ->
    case ((Start < length(S_2)) andalso ((string:substr(S_2, Start + 1, ((Start + 1) - Start)) == " ") orelse (string:substr(S_2, Start + 1, ((Start + 1) - Start)) == "\t"))) of
        true ->
            Start_2 = (Start + 1),
            Fun_2_loop(S_2, Start_2);
        _ -> {S_2, Start}
    end
end,
{S_2, Start_2} = Fun_2(S_2, Start),
        End = length(S_2),
        Fun_3 = fun Fun_3_loop(End, S_2, Start_2) ->
    case ((End > Start_2) andalso ((string:substr(S_2, (End - 1) + 1, (End - (End - 1))) == " ") orelse (string:substr(S_2, (End - 1) + 1, (End - (End - 1))) == "\t"))) of
        true ->
            End_2 = (End - 1),
            Fun_3_loop(End_2, S_2, Start_2);
        _ -> {End, S_2, Start_2}
    end
end,
{End_2, S_2, Start_2} = Fun_3(End, S_2, Start_2),
        string:substr(S_2, Start_2 + 1, (End_2 - Start_2))
    catch {return, Ret} -> Ret end.

indexofsub(S_3, Sub) ->
    try
        case (length(Sub) == 0) of
        true -> throw({return, 0});
        _ -> ok
    end,
        I_5 = 0,
        Fun_4 = fun Fun_4_loop(I_5, S_3, Sub) ->
    case ((I_5 + length(Sub)) =< length(S_3)) of
        true ->
            case (string:substr(S_3, I_5 + 1, ((I_5 + length(Sub)) - I_5)) == Sub) of
        true -> throw({return, I_5});
        _ -> ok
    end,
            I_6 = (I_5 + 1),
            Fun_4_loop(I_6, S_3, Sub);
        _ -> {I_5, S_3, Sub}
    end
end,
{I_6, S_3, Sub} = Fun_4(I_5, S_3, Sub),
        (0 - 1)
    catch {return, Ret} -> Ret end.

parserules(Rs) ->
    try
        Rules = [],
        Fun_5 = fun Fun_5_loop(List, Rs, Rules) ->
    case List of
        [] -> {Rs, Rules};
        [Line|Line_rest] ->
        try
            Ln = Line,
            Hash = indexofsub(Ln, "#"),
            case (Hash >= 0) of
        true -> Ln_2 = lists:sublist(Ln, 1, (Hash - 0)),
            Ln_3 = Ln_2;
        _ -> Ln_3 = Ln
    end,
            Ln_4 = trimspace(Ln_3),
            case (length(Ln_4) == 0) of
        true -> throw({continue, Rs, Rules});
        _ -> ok
    end,
            Arrow = (0 - 1),
            J = 0,
            Fun_6 = fun Fun_6_loop(Arrow, Hash, J, Line, Ln_4, Rs, Rules) ->
    case ((J + 2) =< length(Ln_4)) of
        true ->
            try
                case (string:substr(Ln_4, J + 1, ((J + 2) - J)) == "->") of
        true -> Pre = ((J > 0) andalso ((string:substr(Ln_4, (J - 1) + 1, (J - (J - 1))) == " ") orelse (string:substr(Ln_4, (J - 1) + 1, (J - (J - 1))) == "\t"))),
            Post = (((J + 2) < length(Ln_4)) andalso ((string:substr(Ln_4, (J + 2) + 1, ((J + 3) - (J + 2))) == " ") orelse (string:substr(Ln_4, (J + 2) + 1, ((J + 3) - (J + 2))) == "\t"))),
            case (Pre andalso Post) of
        true -> Arrow_2 = J,
            throw(break),
            Arrow_3 = Arrow_2;
        _ -> Arrow_3 = Arrow
    end,
            Arrow_4 = Arrow_3,
            Post_2 = Post,
            Pre_2 = Pre;
        _ -> Arrow_4 = Arrow,
            Post_2 = nil,
            Pre_2 = nil
    end,
                J_2 = (J + 1),
                Fun_6_loop(Arrow_4, Hash, J_2, Line, Ln_4, Rs, Rules)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6} -> Fun_6_loop(C0, C1, C2, C3, C4, C5, C6);
                break -> {Arrow, Hash, J, Line, Ln_4, Rs, Rules}
            end;
        _ -> {Arrow, Hash, J, Line, Ln_4, Rs, Rules}
    end
end,
{Arrow_4, Hash, J_2, Line, Ln_4, Rs, Rules} = Fun_6(Arrow, Hash, J, Line, Ln_4, Rs, Rules),
            case (Arrow_4 < 0) of
        true -> Arrow_5 = indexofsub(Ln_4, "->"),
            Arrow_6 = Arrow_5;
        _ -> Arrow_6 = Arrow_4
    end,
            case (Arrow_6 < 0) of
        true -> throw({return, #{"ok" => false}});
        _ -> ok
    end,
            Pat = trimspace(string:substr(Ln_4, 1, (Arrow_6 - 0))),
            Rest = trimspace(string:substr(Ln_4, (Arrow_6 + 2) + 1, (length(Ln_4) - (Arrow_6 + 2)))),
            Term = false,
            case ((length(Rest) > 0) andalso (string:substr(Rest, 0 + 1, (1 - 0)) == ".")) of
        true -> Term_2 = true,
            Rest_2 = string:substr(Rest, 1 + 1, (length(Rest) - 1)),
            Rest_3 = Rest_2,
            Term_3 = Term_2;
        _ -> Rest_3 = Rest,
            Term_3 = Term
    end,
            Rep = Rest_3,
            Rules_2 = lists:append(Rules, [#{"pat" => Pat, "rep" => Rep, "term" => Term_3}]),
            Fun_5_loop(Line_rest, Rs, Rules_2)
        catch
            {continue, C0, C1} -> Fun_5_loop(Line_rest, C0, C1);
            {break, B0, B1} -> {B0, B1};
            break -> {Rs, Rules}
        end
    end
end,
{Rs, Rules_2} = Fun_5(string:tokens(Rs, "\n"), Rs, Rules),
        #{"ok" => true, "rules" => Rules_2}
    catch {return, Ret} -> Ret end.

runrules(Rules_3, S_4) ->
    try
        Changed = true,
        Fun_8 = fun Fun_8_loop(Changed, Rules_3, S_4) ->
    case Changed of
        true ->
            try
                Changed_2 = false,
                I_7 = 0,
                Fun_7 = fun Fun_7_loop(Changed_2, I_7, Rules_3, S_4) ->
    case (I_7 < length(Rules_3)) of
        true ->
            try
                R = (case erlang:is_map(Rules_3) of true -> maps:get(I_7, Rules_3, nil); _ -> lists:nth(I_7 + 1, Rules_3) end),
                Pat_2 = maps:get("pat", R, nil),
                Rep_2 = maps:get("rep", R, nil),
                Term_4 = maps:get("term", R, nil),
                Idx = indexofsub(S_4, Pat_2),
                case (Idx >= 0) of
        true -> S_5 = ((string:substr(S_4, 1, (Idx - 0)) ++ Rep_2) ++ string:substr(S_4, (Idx + length(Pat_2)) + 1, length(S_4) - (Idx + length(Pat_2)))),
            Changed_3 = true,
            case (Term_4 /= nil) of
        true -> throw({return, S_5});
        _ -> ok
    end,
            throw(break),
            Changed_4 = Changed_3,
            S_6 = S_5;
        _ -> Changed_4 = Changed_2,
            S_6 = S_4
    end,
                I_8 = (I_7 + 1),
                Fun_7_loop(Changed_4, I_8, Rules_3, S_6)
            catch
                {continue, C0, C1, C2, C3} -> Fun_7_loop(C0, C1, C2, C3);
                break -> {Changed_2, I_7, Rules_3, S_4}
            end;
        _ -> {Changed_2, I_7, Rules_3, S_4}
    end
end,
{Changed_4, I_8, Rules_3, S_6} = Fun_7(Changed_2, I_7, Rules_3, S_4),
                Fun_8_loop(Changed_4, Rules_3, S_6)
            catch
                {continue, C0, C1, C2} -> Fun_8_loop(C0, C1, C2);
                break -> {Changed, Rules_3, S_4}
            end;
        _ -> {Changed, Rules_3, S_4}
    end
end,
{Changed_4, Rules_3, S_6} = Fun_8(Changed, Rules_3, S_4),
        S_6
    catch {return, Ret} -> Ret end.

interpret(Ruleset, Input) ->
    try
        P = parserules(Ruleset),
        case mochi_not(maps:get("ok", P, nil)) of
        true -> throw({return, #{"ok" => false, "out" => ""}});
        _ -> ok
    end,
        Out = runrules(maps:get("rules", P, nil), Input),
        #{"ok" => true, "out" => Out}
    catch {return, Ret} -> Ret end.

main() ->
    try
        io:format("~ts~n", [(("validating " ++ lists:flatten(io_lib:format("~p", [length(erlang:get('testSet'))]))) ++ " test cases")]),
        Failures = false,
        I_9 = 0,
        Fun_9 = fun Fun_9_loop(Failures, I_9) ->
    case (I_9 < length(erlang:get('testSet'))) of
        true ->
            Tc = (case erlang:is_map(erlang:get('testSet')) of true -> maps:get(I_9, erlang:get('testSet'), nil); _ -> lists:nth(I_9 + 1, erlang:get('testSet')) end),
            Res = interpret(maps:get("ruleSet", Tc, nil), maps:get("sample", Tc, nil)),
            case mochi_not(maps:get("ok", Res, nil)) of
        true -> io:format("~ts~n", [(("test " ++ lists:flatten(io_lib:format("~p", [(I_9 + 1)]))) ++ " invalid ruleset")]),
            Failures_2 = true,
            Failures_5 = Failures_2;
        _ -> case (maps:get("out", Res, nil) /= maps:get("output", Tc, nil)) of
        true -> io:format("~ts~n", [((((("test " ++ lists:flatten(io_lib:format("~p", [(I_9 + 1)]))) ++ ": got ") ++ maps:get("out", Res, nil)) ++ ", want ") ++ maps:get("output", Tc, nil))]),
            Failures_3 = true,
            Failures_4 = Failures_3;
        _ -> Failures_4 = Failures
    end,
            Failures_5 = Failures_4
    end,
            I_10 = (I_9 + 1),
            Fun_9_loop(Failures_5, I_10);
        _ -> {Failures, I_9}
    end
end,
{Failures_5, I_10} = Fun_9(Failures, I_9),
        case mochi_not(Failures_5) of
        true -> io:format("~ts~n", ["no failures"]);
        _ -> ok
    end,
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('testSet', [#{"ruleSet" => "# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample" => "I bought a B of As from T S.", "output" => "I bought a bag of apples from my brother."}, #{"ruleSet" => "# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample" => "I bought a B of As from T S.", "output" => "I bought a bag of apples from T shop."}, #{"ruleSet" => "# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample" => "I bought a B of As W my Bgage from T S.", "output" => "I bought a bag of apples with my money from T shop."}, #{"ruleSet" => "### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n", "sample" => "_1111*11111_", "output" => "11111111111111111111"}, #{"ruleSet" => "# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n", "sample" => "000000A000000", "output" => "00011H1111000"}]),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
