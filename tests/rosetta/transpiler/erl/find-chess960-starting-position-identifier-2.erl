#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, indexof/2, removechar/2, g2l/1, countchar/2, spid/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (6aa59f472e) on 2025-08-02 17:26 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_index_of(S, Ch) when is_list(S) ->
    Char = case Ch of
        [C|_] -> C;
        <<C,_/binary>> -> C;
        C when is_integer(C) -> C;
        _ -> $\0
    end,
    case string:chr(S, Char) of
        0 -> -1;
        N -> N - 1
    end;
mochi_index_of(_, _) -> -1.

indexof(S, Sub) ->
    try
        I = 0,
        Fun = fun Fun_loop(I, S, Sub) ->
    case (I =< (length(S) - length(Sub))) of
        true ->
            case (string:substr(S, I + 1, ((I + length(Sub)) - I)) == Sub) of
        true -> throw({return, I});
        _ -> ok
    end,
            I_2 = (I + 1),
            Fun_loop(I_2, S, Sub);
        _ -> {I, S, Sub}
    end
end,
{I_2, S, Sub} = Fun(I, S, Sub),
        -1
    catch {return, Ret} -> Ret end.

removechar(S_2, Ch) ->
    try
        Res = "",
        I_3 = 0,
        Fun_2 = fun Fun_2_loop(Ch, I_3, Res, S_2) ->
    case (I_3 < length(S_2)) of
        true ->
            C = string:substr(S_2, I_3 + 1, ((I_3 + 1) - I_3)),
            case (C /= Ch) of
        true -> Res_2 = (Res ++ C),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            I_4 = (I_3 + 1),
            Fun_2_loop(Ch, I_4, Res_3, S_2);
        _ -> {Ch, I_3, Res, S_2}
    end
end,
{Ch, I_4, Res_3, S_2} = Fun_2(Ch, I_3, Res, S_2),
        Res_3
    catch {return, Ret} -> Ret end.

g2l(Pieces) ->
    try
        Res_4 = "",
        I_5 = 0,
        Fun_3 = fun Fun_3_loop(I_5, Pieces, Res_4) ->
    case (I_5 < length(Pieces)) of
        true ->
            Ch_2 = string:substr(Pieces, I_5 + 1, ((I_5 + 1) - I_5)),
            Res_5 = (Res_4 ++ maps:get(Ch_2, erlang:get('g2lMap'), nil)),
            I_6 = (I_5 + 1),
            Fun_3_loop(I_6, Pieces, Res_5);
        _ -> {I_5, Pieces, Res_4}
    end
end,
{I_6, Pieces, Res_5} = Fun_3(I_5, Pieces, Res_4),
        Res_5
    catch {return, Ret} -> Ret end.

countchar(S_3, Ch_3) ->
    try
        C_2 = 0,
        I_7 = 0,
        Fun_4 = fun Fun_4_loop(C_2, Ch_3, I_7, S_3) ->
    case (I_7 < length(S_3)) of
        true ->
            case (string:substr(S_3, I_7 + 1, ((I_7 + 1) - I_7)) == Ch_3) of
        true -> C_3 = (C_2 + 1),
            C_4 = C_3;
        _ -> C_4 = C_2
    end,
            I_8 = (I_7 + 1),
            Fun_4_loop(C_4, Ch_3, I_8, S_3);
        _ -> {C_2, Ch_3, I_7, S_3}
    end
end,
{C_4, Ch_3, I_8, S_3} = Fun_4(C_2, Ch_3, I_7, S_3),
        C_4
    catch {return, Ret} -> Ret end.

spid(Pieces_2) ->
    try
        Pieces_3 = g2l(Pieces_2),
        case (length(Pieces_3) /= 8) of
        true -> throw({return, {-1, Pieces_3}});
        _ -> ok
    end,
        Fun_5 = fun Fun_5_loop(List, Pieces_3) ->
    case List of
        [] -> {Pieces_3};
        [One|One_rest] ->
            case (countchar(Pieces_3, One) /= 1) of
        true -> throw({return, {-1, Pieces_3}});
        _ -> ok
    end,
            Fun_5_loop(One_rest, Pieces_3)
    end
end,
{Pieces_3} = Fun_5(["K", "Q"], Pieces_3),
        Fun_6 = fun Fun_6_loop(List, Pieces_3) ->
    case List of
        [] -> {Pieces_3};
        [Two|Two_rest] ->
            case (countchar(Pieces_3, Two) /= 2) of
        true -> throw({return, {-1, Pieces_3}});
        _ -> ok
    end,
            Fun_6_loop(Two_rest, Pieces_3)
    end
end,
{Pieces_3} = Fun_6(["R", "N", "B"], Pieces_3),
        R1 = mochi_index_of(Pieces_3, "R"),
        R2 = ((mochi_index_of(string:substr(Pieces_3, (R1 + 1) + 1, (length(Pieces_3) - (R1 + 1))), "R") + R1) + 1),
        K = mochi_index_of(Pieces_3, "K"),
        case ((K < R1) orelse (K > R2)) of
        true -> throw({return, {-1, Pieces_3}});
        _ -> ok
    end,
        B1 = mochi_index_of(Pieces_3, "B"),
        B2 = ((mochi_index_of(string:substr(Pieces_3, (B1 + 1) + 1, (length(Pieces_3) - (B1 + 1))), "B") + B1) + 1),
        case (((B2 - B1) rem 2) == 0) of
        true -> throw({return, {-1, Pieces_3}});
        _ -> ok
    end,
        PiecesN = removechar(removechar(Pieces_3, "Q"), "B"),
        N1 = mochi_index_of(PiecesN, "N"),
        N2 = ((mochi_index_of(string:substr(PiecesN, (N1 + 1) + 1, (length(PiecesN) - (N1 + 1))), "N") + N1) + 1),
        N = maps:get((lists:flatten(io_lib:format("~p", [N1])) ++ lists:flatten(io_lib:format("~p", [N2]))), erlang:get('ntable'), nil),
        PiecesQ = removechar(Pieces_3, "B"),
        Q = mochi_index_of(PiecesQ, "Q"),
        D = mochi_index_of("0246", lists:flatten(io_lib:format("~p", [B1]))),
        L = mochi_index_of("1357", lists:flatten(io_lib:format("~p", [B2]))),
        case (D == (0 - 1)) of
        true -> D_2 = mochi_index_of("0246", lists:flatten(io_lib:format("~p", [B2]))),
            L_2 = mochi_index_of("1357", lists:flatten(io_lib:format("~p", [B1]))),
            D_3 = D_2,
            L_3 = L_2;
        _ -> D_3 = D,
            L_3 = L
    end,
        {((((96 * N) + (16 * Q)) + (4 * D_3)) + L_3), Pieces_3}
    catch {return, Ret} -> Ret end.

main() ->
    try
        Fun_7 = fun Fun_7_loop(List) ->
    case List of
        [] -> {};
        [Pieces_4|Pieces_4_rest] ->
            io:format("~ts~n", [((((Pieces_4 ++ " or ") ++ g2l(Pieces_4)) ++ " has SP-ID of ") ++ lists:flatten(io_lib:format("~p", [spid(Pieces_4)])))]),
            Fun_7_loop(Pieces_4_rest)
    end
end,
{} = Fun_7(["♕♘♖♗♗♘♔♖", "♖♘♗♕♔♗♘♖", "♖♕♘♗♗♔♖♘", "♖♘♕♗♗♔♖♘"]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('g2lMap', #{"♜" => "R", "♞" => "N", "♝" => "B", "♛" => "Q", "♚" => "K", "♖" => "R", "♘" => "N", "♗" => "B", "♕" => "Q", "♔" => "K"}),
    erlang:put('names', #{"R" => "rook", "N" => "knight", "B" => "bishop", "Q" => "queen", "K" => "king"}),
    erlang:put('ntable', #{"01" => 0, "02" => 1, "03" => 2, "04" => 3, "12" => 4, "13" => 5, "14" => 6, "23" => 7, "24" => 8, "34" => 9}),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
