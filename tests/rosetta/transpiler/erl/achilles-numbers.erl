#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pow10/1, totient/1, getperfectpowers/1, getachilles/2, sortints/1, pad/2, main/0]).

% Generated by Mochi transpiler v0.10.55 (f79327cd84) on 2025-08-02 23:38 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

pow10(Exp) ->
    try
        N = 1,
        I = 0,
        Fun = fun Fun_loop(Exp, I, N) ->
    case (I < Exp) of
        true ->
            N_2 = (N * 10),
            I_2 = (I + 1),
            Fun_loop(Exp, I_2, N_2);
        _ -> {Exp, I, N}
    end
end,
{Exp, I_2, N_2} = Fun(Exp, I, N),
        N_2
    catch {return, Ret} -> Ret end.

totient(N_3) ->
    try
        Tot = N_3,
        Nn = N_3,
        I_3 = 2,
        Fun_4 = fun Fun_4_loop(I_3, N_3, Nn, Tot) ->
    case ((I_3 * I_3) =< Nn) of
        true ->
            case ((Nn rem I_3) == 0) of
        true -> Fun_2 = fun Fun_2_loop(I_3, N_3, Nn, Tot) ->
    case ((Nn rem I_3) == 0) of
        true ->
            Nn_2 = (Nn div I_3),
            Fun_2_loop(I_3, N_3, Nn_2, Tot);
        _ -> {I_3, N_3, Nn, Tot}
    end
end,
{I_3, N_3, Nn_2, Tot} = Fun_2(I_3, N_3, Nn, Tot),
            Tot_2 = (Tot - (Tot div I_3)),
            Fun_3 = Fun_2,
            Nn_3 = Nn_2,
            Tot_3 = Tot_2;
        _ -> Fun_3 = nil,
            Nn_3 = Nn,
            Tot_3 = Tot
    end,
            case (I_3 == 2) of
        true -> I_4 = 1,
            I_5 = I_4;
        _ -> I_5 = I_3
    end,
            I_6 = (I_5 + 2),
            Fun_4_loop(I_6, N_3, Nn_3, Tot_3);
        _ -> {I_3, N_3, Nn, Tot}
    end
end,
{I_6, N_3, Nn_3, Tot_3} = Fun_4(I_3, N_3, Nn, Tot),
        case (Nn_3 > 1) of
        true -> Tot_4 = (Tot_3 - (Tot_3 div Nn_3)),
            Tot_5 = Tot_4;
        _ -> Tot_5 = Tot_3
    end,
        Tot_5
    catch {return, Ret} -> Ret end.

getperfectpowers(MaxExp) ->
    try
        Upper = pow10(MaxExp),
        I_7 = 2,
        Fun_6 = fun Fun_6_loop(I_7, MaxExp, Upper) ->
    case ((I_7 * I_7) < Upper) of
        true ->
            try
                P = I_7,
                Fun_5 = fun Fun_5_loop(I_7, MaxExp, P, Upper) ->
    case true of
        true ->
            try
                P_2 = (P * I_7),
                case (P_2 >= Upper) of
        true -> throw(break);
        _ -> ok
    end,
                Pps = erlang:get('pps'),
                Pps_2 = maps:put(P_2, true, Pps),
                erlang:put('pps', Pps_2),
                Fun_5_loop(I_7, MaxExp, P_2, Upper)
            catch
                {continue, C0, C1, C2, C3} -> Fun_5_loop(C0, C1, C2, C3);
                break -> {I_7, MaxExp, P, Upper}
            end;
        _ -> {I_7, MaxExp, P, Upper}
    end
end,
{I_7, MaxExp, P_2, Upper} = Fun_5(I_7, MaxExp, P, Upper),
                I_8 = (I_7 + 1),
                Fun_6_loop(I_8, MaxExp, Upper)
            catch
                {continue, C0, C1, C2} -> Fun_6_loop(C0, C1, C2);
                break -> {I_7, MaxExp, Upper}
            end;
        _ -> {I_7, MaxExp, Upper}
    end
end,
{I_8, MaxExp, Upper} = Fun_6(I_7, MaxExp, Upper),
        nil
    catch {return, Ret} -> Ret end.

getachilles(MinExp, MaxExp_2) ->
    try
        Lower = pow10(MinExp),
        Upper_2 = pow10(MaxExp_2),
        Achilles = #{},
        B = 1,
        Fun_8 = fun Fun_8_loop(Achilles, B, Lower, MaxExp_2, MinExp, Upper_2) ->
    case (((B * B) * B) < Upper_2) of
        true ->
            try
                B3 = ((B * B) * B),
                A = 1,
                Fun_7 = fun Fun_7_loop(A, Achilles, B, B3, Lower, MaxExp_2, MinExp, Upper_2) ->
    case true of
        true ->
            try
                P_3 = ((B3 * A) * A),
                case (P_3 >= Upper_2) of
        true -> throw(break);
        _ -> ok
    end,
                case (P_3 >= Lower) of
        true -> case mochi_not(maps:is_key(P_3, erlang:get('pps'))) of
        true -> Achilles_2 = maps:put(P_3, true, Achilles),
            Achilles_3 = Achilles_2;
        _ -> Achilles_3 = Achilles
    end,
            Achilles_4 = Achilles_3;
        _ -> Achilles_4 = Achilles
    end,
                A_2 = (A + 1),
                Fun_7_loop(A_2, Achilles_4, B, B3, Lower, MaxExp_2, MinExp, Upper_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7} -> Fun_7_loop(C0, C1, C2, C3, C4, C5, C6, C7);
                break -> {A, Achilles, B, B3, Lower, MaxExp_2, MinExp, Upper_2}
            end;
        _ -> {A, Achilles, B, B3, Lower, MaxExp_2, MinExp, Upper_2}
    end
end,
{A_2, Achilles_4, B, B3, Lower, MaxExp_2, MinExp, Upper_2} = Fun_7(A, Achilles, B, B3, Lower, MaxExp_2, MinExp, Upper_2),
                B_2 = (B + 1),
                Fun_8_loop(Achilles_4, B_2, Lower, MaxExp_2, MinExp, Upper_2)
            catch
                {continue, C0, C1, C2, C3, C4, C5} -> Fun_8_loop(C0, C1, C2, C3, C4, C5);
                break -> {Achilles, B, Lower, MaxExp_2, MinExp, Upper_2}
            end;
        _ -> {Achilles, B, Lower, MaxExp_2, MinExp, Upper_2}
    end
end,
{Achilles_4, B_2, Lower, MaxExp_2, MinExp, Upper_2} = Fun_8(Achilles, B, Lower, MaxExp_2, MinExp, Upper_2),
        Achilles_4
    catch {return, Ret} -> Ret end.

sortints(Xs) ->
    try
        Res = [],
        Tmp = Xs,
        Fun_11 = fun Fun_11_loop(Res, Tmp, Xs) ->
    case (length(Tmp) > 0) of
        true ->
            Min = (case erlang:is_map(Tmp) of true -> maps:get(0, Tmp, nil); _ -> lists:nth(0 + 1, Tmp) end),
            Idx = 0,
            I_9 = 1,
            Fun_9 = fun Fun_9_loop(I_9, Idx, Min, Res, Tmp, Xs) ->
    case (I_9 < length(Tmp)) of
        true ->
            case ((case erlang:is_map(Tmp) of true -> maps:get(I_9, Tmp, nil); _ -> lists:nth(I_9 + 1, Tmp) end) < Min) of
        true -> Min_2 = (case erlang:is_map(Tmp) of true -> maps:get(I_9, Tmp, nil); _ -> lists:nth(I_9 + 1, Tmp) end),
            Idx_2 = I_9,
            Idx_3 = Idx_2,
            Min_3 = Min_2;
        _ -> Idx_3 = Idx,
            Min_3 = Min
    end,
            I_10 = (I_9 + 1),
            Fun_9_loop(I_10, Idx_3, Min_3, Res, Tmp, Xs);
        _ -> {I_9, Idx, Min, Res, Tmp, Xs}
    end
end,
{I_10, Idx_3, Min_3, Res, Tmp, Xs} = Fun_9(I_9, Idx, Min, Res, Tmp, Xs),
            Res_2 = (Res ++ [Min_3]),
            Out = [],
            J = 0,
            Fun_10 = fun Fun_10_loop(I_10, Idx_3, J, Min_3, Out, Res_2, Tmp, Xs) ->
    case (J < length(Tmp)) of
        true ->
            case (J /= Idx_3) of
        true -> Out_2 = (Out ++ [(case erlang:is_map(Tmp) of true -> maps:get(J, Tmp, nil); _ -> lists:nth(J + 1, Tmp) end)]),
            Out_3 = Out_2;
        _ -> Out_3 = Out
    end,
            J_2 = (J + 1),
            Fun_10_loop(I_10, Idx_3, J_2, Min_3, Out_3, Res_2, Tmp, Xs);
        _ -> {I_10, Idx_3, J, Min_3, Out, Res_2, Tmp, Xs}
    end
end,
{I_10, Idx_3, J_2, Min_3, Out_3, Res_2, Tmp, Xs} = Fun_10(I_10, Idx_3, J, Min_3, Out, Res_2, Tmp, Xs),
            Tmp_2 = Out_3,
            Fun_11_loop(Res_2, Tmp_2, Xs);
        _ -> {Res, Tmp, Xs}
    end
end,
{Res_2, Tmp_2, Xs} = Fun_11(Res, Tmp, Xs),
        Res_2
    catch {return, Ret} -> Ret end.

pad(N_4, Width) ->
    try
        S = lists:flatten(io_lib:format("~p", [N_4])),
        Fun_12 = fun Fun_12_loop(N_4, S, Width) ->
    case (length(S) < Width) of
        true ->
            S_2 = (" " ++ S),
            Fun_12_loop(N_4, S_2, Width);
        _ -> {N_4, S, Width}
    end
end,
{N_4, S_2, Width} = Fun_12(N_4, S, Width),
        S_2
    catch {return, Ret} -> Ret end.

main() ->
    try
        MaxDigits = 15,
        getperfectpowers(5),
        AchSet = getachilles(1, 5),
        Ach = [],
        Fun_13 = fun Fun_13_loop(List, Ach, AchSet, MaxDigits) ->
    case List of
        [] -> {Ach, AchSet, MaxDigits};
        [K|K_rest] ->
            Ach_2 = (Ach ++ [K]),
            Fun_13_loop(K_rest, Ach_2, AchSet, MaxDigits)
    end
end,
{Ach_2, AchSet, MaxDigits} = Fun_13(maps:keys(AchSet), Ach, AchSet, MaxDigits),
        Ach_3 = sortints(Ach_2),
        io:format("~ts~n", ["First 50 Achilles numbers:"]),
        I_11 = 0,
        Fun_15 = fun Fun_15_loop(Ach_3, AchSet, I_11, MaxDigits) ->
    case (I_11 < 50) of
        true ->
            Line = "",
            J_3 = 0,
            Fun_14 = fun Fun_14_loop(Ach_3, AchSet, I_11, J_3, Line, MaxDigits) ->
    case (J_3 < 10) of
        true ->
            Line_2 = (Line ++ pad((case erlang:is_map(Ach_3) of true -> maps:get(I_11, Ach_3, nil); _ -> lists:nth(I_11 + 1, Ach_3) end), 4)),
            case (J_3 < 9) of
        true -> Line_3 = (Line_2 ++ " "),
            Line_4 = Line_3;
        _ -> Line_4 = Line_2
    end,
            I_12 = (I_11 + 1),
            J_4 = (J_3 + 1),
            Fun_14_loop(Ach_3, AchSet, I_12, J_4, Line_4, MaxDigits);
        _ -> {Ach_3, AchSet, I_11, J_3, Line, MaxDigits}
    end
end,
{Ach_3, AchSet, I_12, J_4, Line_4, MaxDigits} = Fun_14(Ach_3, AchSet, I_11, J_3, Line, MaxDigits),
            io:format("~ts~n", [Line_4]),
            Fun_15_loop(Ach_3, AchSet, I_12, MaxDigits);
        _ -> {Ach_3, AchSet, I_11, MaxDigits}
    end
end,
{Ach_3, AchSet, I_12, MaxDigits} = Fun_15(Ach_3, AchSet, I_11, MaxDigits),
        io:format("~ts~n", ["\nFirst 30 strong Achilles numbers:"]),
        Strong = [],
        Count = 0,
        Idx_4 = 0,
        Fun_16 = fun Fun_16_loop(Ach_3, AchSet, Count, I_12, Idx_4, MaxDigits, Strong) ->
    case (Count < 30) of
        true ->
            Tot_6 = totient((case erlang:is_map(Ach_3) of true -> maps:get(Idx_4, Ach_3, nil); _ -> lists:nth(Idx_4 + 1, Ach_3) end)),
            case maps:is_key(Tot_6, AchSet) of
        true -> Strong_2 = (Strong ++ [(case erlang:is_map(Ach_3) of true -> maps:get(Idx_4, Ach_3, nil); _ -> lists:nth(Idx_4 + 1, Ach_3) end)]),
            Count_2 = (Count + 1),
            Count_3 = Count_2,
            Strong_3 = Strong_2;
        _ -> Count_3 = Count,
            Strong_3 = Strong
    end,
            Idx_5 = (Idx_4 + 1),
            Fun_16_loop(Ach_3, AchSet, Count_3, I_12, Idx_5, MaxDigits, Strong_3);
        _ -> {Ach_3, AchSet, Count, I_12, Idx_4, MaxDigits, Strong}
    end
end,
{Ach_3, AchSet, Count_3, I_12, Idx_5, MaxDigits, Strong_3} = Fun_16(Ach_3, AchSet, Count, I_12, Idx_4, MaxDigits, Strong),
        I_13 = 0,
        Fun_18 = fun Fun_18_loop(Ach_3, AchSet, Count_3, I_13, Idx_5, MaxDigits, Strong_3) ->
    case (I_13 < 30) of
        true ->
            Line_5 = "",
            J_5 = 0,
            Fun_17 = fun Fun_17_loop(Ach_3, AchSet, Count_3, I_13, Idx_5, J_5, Line_5, MaxDigits, Strong_3) ->
    case (J_5 < 10) of
        true ->
            Line_6 = (Line_5 ++ pad((case erlang:is_map(Strong_3) of true -> maps:get(I_13, Strong_3, nil); _ -> lists:nth(I_13 + 1, Strong_3) end), 5)),
            case (J_5 < 9) of
        true -> Line_7 = (Line_6 ++ " "),
            Line_8 = Line_7;
        _ -> Line_8 = Line_6
    end,
            I_14 = (I_13 + 1),
            J_6 = (J_5 + 1),
            Fun_17_loop(Ach_3, AchSet, Count_3, I_14, Idx_5, J_6, Line_8, MaxDigits, Strong_3);
        _ -> {Ach_3, AchSet, Count_3, I_13, Idx_5, J_5, Line_5, MaxDigits, Strong_3}
    end
end,
{Ach_3, AchSet, Count_3, I_14, Idx_5, J_6, Line_8, MaxDigits, Strong_3} = Fun_17(Ach_3, AchSet, Count_3, I_13, Idx_5, J_5, Line_5, MaxDigits, Strong_3),
            io:format("~ts~n", [Line_8]),
            Fun_18_loop(Ach_3, AchSet, Count_3, I_14, Idx_5, MaxDigits, Strong_3);
        _ -> {Ach_3, AchSet, Count_3, I_13, Idx_5, MaxDigits, Strong_3}
    end
end,
{Ach_3, AchSet, Count_3, I_14, Idx_5, MaxDigits, Strong_3} = Fun_18(Ach_3, AchSet, Count_3, I_13, Idx_5, MaxDigits, Strong_3),
        io:format("~ts~n", ["\nNumber of Achilles numbers with:"]),
        Counts = [1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383],
        D = 2,
        Fun_19 = fun Fun_19_loop(Ach_3, AchSet, Count_3, Counts, D, I_14, Idx_5, MaxDigits, Strong_3) ->
    case (D =< MaxDigits) of
        true ->
            C = (case erlang:is_map(Counts) of true -> maps:get((D - 2), Counts, nil); _ -> lists:nth((D - 2) + 1, Counts) end),
            io:format("~ts~n", [((pad(D, 2) ++ " digits: ") ++ lists:flatten(io_lib:format("~p", [C])))]),
            D_2 = (D + 1),
            Fun_19_loop(Ach_3, AchSet, Count_3, Counts, D_2, I_14, Idx_5, MaxDigits, Strong_3);
        _ -> {Ach_3, AchSet, Count_3, Counts, D, I_14, Idx_5, MaxDigits, Strong_3}
    end
end,
{Ach_3, AchSet, Count_3, Counts, D_2, I_14, Idx_5, MaxDigits, Strong_3} = Fun_19(Ach_3, AchSet, Count_3, Counts, D, I_14, Idx_5, MaxDigits, Strong_3),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('pps', #{}),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
