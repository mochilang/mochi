#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, gcd/2, absbig/1, pollardrho/2, smallestprimefactorwheel/2, smallestprimefactor/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (6aa59f472e) on 2025-08-02 17:26 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

gcd(A, B) ->
    try
        X = A,
        Y = B,
        Fun = fun Fun_loop(A, B, X, Y) ->
    case (Y /= erlang:get('zero')) of
        true ->
            T = (X rem Y),
            X_2 = Y,
            Y_2 = T,
            Fun_loop(A, B, X_2, Y_2);
        _ -> {A, B, X, Y}
    end
end,
{A, B, X_2, Y_2} = Fun(A, B, X, Y),
        X_2
    catch {return, Ret} -> Ret end.

absbig(X_3) ->
    try
        (case (X_3 < erlang:get('zero')) of
    true -> (erlang:get('zero') - X_3);
    _ -> X_3
end)
    catch {return, Ret} -> Ret end.

pollardrho(N, C) ->
    try
        G = fun G(X_4, Y_3) ->
    try
        X2 = (X_4 * X_4),
        X2_2 = (X2 + C),
        (X2_2 rem Y_3)
    catch {return, Ret} -> Ret end
end,
        X_5 = 2,
        Y_4 = 2,
        Z = 1,
        D = 0,
        Count = 0,
        Fun_2 = fun Fun_2_loop(C, Count, D, G, N, X_5, Y_4, Z) ->
    case true of
        true ->
            try
                X_6 = G(X_5, N),
                Y_5 = G(G(Y_4, N), N),
                D_2 = absbig((X_6 - Y_5)),
                D_3 = (D_2 rem N),
                Z_2 = (Z * D_3),
                Count_2 = (Count + 1),
                case (Count_2 == 100) of
        true -> D_4 = gcd(Z_2, N),
            case (D_4 /= erlang:get('one')) of
        true -> throw(break);
        _ -> ok
    end,
            Z_3 = erlang:get('one'),
            Count_3 = 0,
            Count_4 = Count_3,
            D_5 = D_4,
            Z_4 = Z_3;
        _ -> Count_4 = Count_2,
            D_5 = D_3,
            Z_4 = Z_2
    end,
                Fun_2_loop(C, Count_4, D_5, G, N, X_6, Y_5, Z_4)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7} -> Fun_2_loop(C0, C1, C2, C3, C4, C5, C6, C7);
                break -> {C, Count, D, G, N, X_5, Y_4, Z}
            end;
        _ -> {C, Count, D, G, N, X_5, Y_4, Z}
    end
end,
{C, Count_4, D_5, G, N, X_6, Y_5, Z_4} = Fun_2(C, Count, D, G, N, X_5, Y_4, Z),
        case (D_5 == N) of
        true -> throw({return, erlang:get('zero')});
        _ -> ok
    end,
        D_5
    catch {return, Ret} -> Ret end.

smallestprimefactorwheel(N_2, Max) ->
    try
        case ((N_2 rem erlang:get('two')) == erlang:get('zero')) of
        true -> throw({return, erlang:get('two')});
        _ -> ok
    end,
        case ((N_2 rem erlang:get('three')) == erlang:get('zero')) of
        true -> throw({return, erlang:get('three')});
        _ -> ok
    end,
        case ((N_2 rem erlang:get('five')) == erlang:get('zero')) of
        true -> throw({return, erlang:get('five')});
        _ -> ok
    end,
        K = 7,
        Inc = [erlang:get('four'), erlang:get('two'), erlang:get('four'), erlang:get('two'), erlang:get('four'), erlang:get('six'), erlang:get('two'), erlang:get('six')],
        I = 0,
        Fun_3 = fun Fun_3_loop(I, Inc, K, Max, N_2) ->
    case ((K * K) =< N_2) of
        true ->
            try
                case ((N_2 rem K) == erlang:get('zero')) of
        true -> throw({return, K});
        _ -> ok
    end,
                K_2 = (K + (case erlang:is_map(Inc) of true -> maps:get(I, Inc, nil); _ -> lists:nth(I + 1, Inc) end)),
                case (K_2 > Max) of
        true -> throw(break);
        _ -> ok
    end,
                I_2 = ((I + 1) rem 8),
                Fun_3_loop(I_2, Inc, K_2, Max, N_2)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_3_loop(C0, C1, C2, C3, C4);
                break -> {I, Inc, K, Max, N_2}
            end;
        _ -> {I, Inc, K, Max, N_2}
    end
end,
{I_2, Inc, K_2, Max, N_2} = Fun_3(I, Inc, K, Max, N_2),
        erlang:get('zero')
    catch {return, Ret} -> Ret end.

smallestprimefactor(N_3) ->
    try
        S = smallestprimefactorwheel(N_3, erlang:get('k100')),
        case (S /= erlang:get('zero')) of
        true -> throw({return, S});
        _ -> ok
    end,
        C_2 = 1,
        Fun_4 = fun Fun_4_loop(C_2, N_3, S) ->
    case true of
        true ->
            D_6 = pollardrho(N_3, C_2),
            case (D_6 == erlang:get('zero')) of
        true -> case (C_2 == erlang:get('ten')) of
        true -> throw({return, N_3});
        _ -> ok
    end,
            C_3 = (C_2 + erlang:get('one')),
            C_4 = C_3,
            Factor_2 = nil,
            S2_2 = nil;
        _ -> Factor = smallestprimefactorwheel(D_6, D_6),
            S2 = smallestprimefactorwheel((N_3 div D_6), Factor),
            case (S2 /= erlang:get('zero')) of
        true -> case (S2 < Factor) of
        true -> throw({return, S2});
        _ -> throw({return, Factor})
    end;
        _ -> ok
    end,
            throw({return, Factor}),
            C_4 = C_2,
            Factor_2 = Factor,
            S2_2 = S2
    end,
            Fun_4_loop(C_4, N_3, S);
        _ -> {C_2, N_3, S}
    end
end,
{C_4, N_3, S} = Fun_4(C_2, N_3, S),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        K_3 = 19,
        io:format("~ts~n", [(("First " ++ lists:flatten(io_lib:format("~p", [19]))) ++ " terms of the Euclidâ€“Mullin sequence:")]),
        io:format("~p~n", [2]),
        Prod = 2,
        Count_5 = 1,
        Fun_5 = fun Fun_5_loop(Count_5, K_3, Prod) ->
    case (Count_5 < K_3) of
        true ->
            Z_5 = (Prod + erlang:get('one')),
            T_2 = smallestprimefactor(Z_5),
            io:format("~p~n", [T_2]),
            Prod_2 = (Prod * T_2),
            Count_6 = (Count_5 + 1),
            Fun_5_loop(Count_6, K_3, Prod_2);
        _ -> {Count_5, K_3, Prod}
    end
end,
{Count_6, K_3, Prod_2} = Fun_5(Count_5, K_3, Prod),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('zero', 0),
    erlang:put('one', 1),
    erlang:put('two', 2),
    erlang:put('three', 3),
    erlang:put('four', 4),
    erlang:put('five', 5),
    erlang:put('six', 6),
    erlang:put('ten', 10),
    erlang:put('k100', 100000),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
