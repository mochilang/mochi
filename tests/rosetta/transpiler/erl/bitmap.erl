#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, pixelfromrgb/1, rgbfrompixel/1, newbitmap/2, extent/1, fill/2, fillrgb/2, setpx/4, setpxrgb/4, getpx/3, getpxrgb/3, ppmsize/1, pixelstr/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (e0c44791e6) on 2025-07-25 18:01 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

pixelfromrgb(C) ->
    try
        R = (mochi_to_int((C div 65536)) rem 256),
        G = (mochi_to_int((C div 256)) rem 256),
        B = (C rem 256),
        #{"R" => R, "G" => G, "B" => B}
    catch {return, Ret} -> Ret end.

rgbfrompixel(P) ->
    try
        (((maps:get("R", P, nil) * 65536) + (maps:get("G", P, nil) * 256)) + maps:get("B", P, nil))
    catch {return, Ret} -> Ret end.

newbitmap(X, Y) ->
    try
        Data = [],
        Row = 0,
        Fun_2 = fun Fun_2_loop(Data, Row, X, Y) ->
    case (Row < Y) of
        true ->
            R_2 = [],
            Col = 0,
            Fun = fun Fun_loop(Col, Data, R_2, Row, X, Y) ->
    case (Col < X) of
        true ->
            R_3 = lists:append(R_2, [#{"R" => 0, "G" => 0, "B" => 0}]),
            Col_2 = (Col + 1),
            Fun_loop(Col_2, Data, R_3, Row, X, Y);
        _ -> {Col, Data, R_2, Row, X, Y}
    end
end,
{Col_2, Data, R_3, Row, X, Y} = Fun(Col, Data, R_2, Row, X, Y),
            Data_2 = lists:append(Data, [R_3]),
            Row_2 = (Row + 1),
            Fun_2_loop(Data_2, Row_2, X, Y);
        _ -> {Data, Row, X, Y}
    end
end,
{Data_2, Row_2, X, Y} = Fun_2(Data, Row, X, Y),
        #{"cols" => X, "rows" => Y, "px" => Data_2}
    catch {return, Ret} -> Ret end.

extent(B_2) ->
    try
        #{"cols" => maps:get("cols", B_2, nil), "rows" => maps:get("rows", B_2, nil)}
    catch {return, Ret} -> Ret end.

fill(B_3, P_2) ->
    try
        Y_2 = 0,
        Fun_4 = fun Fun_4_loop(B_3, P_2, Y_2) ->
    case (Y_2 < maps:get("rows", B_3, nil)) of
        true ->
            X_2 = 0,
            Fun_3 = fun Fun_3_loop(B_3, P_2, X_2, Y_2) ->
    case (X_2 < maps:get("cols", B_3, nil)) of
        true ->
            Px = maps:get("px", B_3, nil),
            Row_3 = lists:nth(Y_2 + 1, Px),
            Row_4 = lists:sublist(Row_3, X_2) ++ [P_2] ++ lists:nthtail(X_2 + 1, Row_3),
            Px_2 = lists:sublist(Px, Y_2) ++ [Row_4] ++ lists:nthtail(Y_2 + 1, Px),
            B_4 = maps:put("px", Px_2, B_3),
            X_3 = (X_2 + 1),
            Fun_3_loop(B_4, P_2, X_3, Y_2);
        _ -> {B_3, P_2, X_2, Y_2}
    end
end,
{B_4, P_2, X_3, Y_2} = Fun_3(B_3, P_2, X_2, Y_2),
            Y_3 = (Y_2 + 1),
            Fun_4_loop(B_4, P_2, Y_3);
        _ -> {B_3, P_2, Y_2}
    end
end,
{B_4, P_2, Y_3} = Fun_4(B_3, P_2, Y_2),
        B_4
    catch {return, Ret} -> Ret end.

fillrgb(B_5, C_2) ->
    try
        B_6 = fill(B_5, pixelfromrgb(C_2)),
        B_6
    catch {return, Ret} -> Ret end.

setpx(B_7, X_4, Y_4, P_3) ->
    try
        case ((((X_4 < 0) orelse (X_4 >= maps:get("cols", B_7, nil))) orelse (Y_4 < 0)) orelse (Y_4 >= maps:get("rows", B_7, nil))) of
        true -> throw({return, false});
        _ -> ok
    end,
        Px_3 = maps:get("px", B_7, nil),
        Row_5 = lists:nth(Y_4 + 1, Px_3),
        Row_6 = lists:sublist(Row_5, X_4) ++ [P_3] ++ lists:nthtail(X_4 + 1, Row_5),
        Px_4 = lists:sublist(Px_3, Y_4) ++ [Row_6] ++ lists:nthtail(Y_4 + 1, Px_3),
        B_8 = maps:put("px", Px_4, B_7),
        true
    catch {return, Ret} -> Ret end.

setpxrgb(B_9, X_5, Y_5, C_3) ->
    try
        setpx(B_9, X_5, Y_5, pixelfromrgb(C_3))
    catch {return, Ret} -> Ret end.

getpx(B_10, X_6, Y_6) ->
    try
        case ((((X_6 < 0) orelse (X_6 >= maps:get("cols", B_10, nil))) orelse (Y_6 < 0)) orelse (Y_6 >= maps:get("rows", B_10, nil))) of
        true -> throw({return, #{"ok" => false}});
        _ -> ok
    end,
        Row_7 = lists:nth(Y_6 + 1, maps:get("px", B_10, nil)),
        #{"ok" => true, "pixel" => lists:nth(X_6 + 1, Row_7)}
    catch {return, Ret} -> Ret end.

getpxrgb(B_11, X_7, Y_7) ->
    try
        R_4 = getpx(B_11, X_7, Y_7),
        case not maps:get("ok", R_4, nil) of
        true -> throw({return, #{"ok" => false}});
        _ -> ok
    end,
        #{"ok" => true, "rgb" => rgbfrompixel(maps:get("pixel", R_4, nil))}
    catch {return, Ret} -> Ret end.

ppmsize(B_12) ->
    try
        Header = (((("P6\n# Creator: Rosetta Code http://rosettacode.org/\n" ++ lists:flatten(io_lib:format("~p", [maps:get("cols", B_12, nil)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [maps:get("rows", B_12, nil)]))) ++ "\n255\n"),
        (length(Header) + ((3 * maps:get("cols", B_12, nil)) * maps:get("rows", B_12, nil)))
    catch {return, Ret} -> Ret end.

pixelstr(P_4) ->
    try
        (((((("{" ++ lists:flatten(io_lib:format("~p", [maps:get("R", P_4, nil)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [maps:get("G", P_4, nil)]))) ++ " ") ++ lists:flatten(io_lib:format("~p", [maps:get("B", P_4, nil)]))) ++ "}")
    catch {return, Ret} -> Ret end.

main() ->
    try
        Bm = newbitmap(300, 240),
        Bm_2 = fillrgb(Bm, 16711680),
        setpxrgb(Bm_2, 10, 20, 255),
        setpxrgb(Bm_2, 20, 30, 0),
        setpxrgb(Bm_2, 30, 40, 1056816),
        C1 = getpx(Bm_2, 0, 0),
        C2 = getpx(Bm_2, 10, 20),
        C3 = getpx(Bm_2, 30, 40),
        io:format("~ts~n", [((("Image size: " ++ lists:flatten(io_lib:format("~p", [maps:get("cols", Bm_2, nil)]))) ++ " Ã— ") ++ lists:flatten(io_lib:format("~p", [maps:get("rows", Bm_2, nil)])))]),
        io:format("~ts~n", [(lists:flatten(io_lib:format("~p", [ppmsize(Bm_2)])) ++ " bytes when encoded as PPM.")]),
        case maps:get("ok", C1, nil) of
        true -> io:format("~ts~n", [("Pixel at (0,0) is " ++ pixelstr(maps:get("pixel", C1, nil)))]);
        _ -> ok
    end,
        case maps:get("ok", C2, nil) of
        true -> io:format("~ts~n", [("Pixel at (10,20) is " ++ pixelstr(maps:get("pixel", C2, nil)))]);
        _ -> ok
    end,
        case maps:get("ok", C3, nil) of
        true -> P_5 = maps:get("pixel", C3, nil),
            R16 = (maps:get("R", P_5, nil) * 257),
            G16 = (maps:get("G", P_5, nil) * 257),
            B16 = (maps:get("B", P_5, nil) * 257),
            io:format("~ts~n", [((((("Pixel at (30,40) has R=" ++ lists:flatten(io_lib:format("~p", [R16]))) ++ ", G=") ++ lists:flatten(io_lib:format("~p", [G16]))) ++ ", B=") ++ lists:flatten(io_lib:format("~p", [B16])))]),
            B16_2 = B16,
            G16_2 = G16,
            P_6 = P_5,
            R16_2 = R16;
        _ -> B16_2 = nil,
            G16_2 = nil,
            P_6 = nil,
            R16_2 = nil
    end,
        Bm_2
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
