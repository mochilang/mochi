#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, sinapprox/1, cosapprox/1, atanapprox/1, atan2approx/2, sqrtapprox/1, rad/1, deg/1, distance/4, bearing/4, floor/1, pow10/1, round/2, sortbydistance/1, main/0]).

% Generated by Mochi transpiler v0.10.42 (34844ab2bf) on 2025-07-28 07:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

sinapprox(X) ->
    try
        Term = X,
        Sum = X,
        N = 1,
        Fun = fun Fun_loop(N, Sum, Term, X) ->
    case (N =< 8) of
        true ->
            Denom = float(((2 * N) * ((2 * N) + 1))),
            Term_2 = (((-Term * X) * X) / Denom),
            Sum_2 = (Sum + Term_2),
            N_2 = (N + 1),
            Fun_loop(N_2, Sum_2, Term_2, X);
        _ -> {N, Sum, Term, X}
    end
end,
{N_2, Sum_2, Term_2, X} = Fun(N, Sum, Term, X),
        Sum_2
    catch {return, Ret} -> Ret end.

cosapprox(X_2) ->
    try
        Term_3 = 1,
        Sum_3 = 1,
        N_3 = 1,
        Fun_2 = fun Fun_2_loop(N_3, Sum_3, Term_3, X_2) ->
    case (N_3 =< 8) of
        true ->
            Denom_2 = float((((2 * N_3) - 1) * (2 * N_3))),
            Term_4 = (((-Term_3 * X_2) * X_2) / Denom_2),
            Sum_4 = (Sum_3 + Term_4),
            N_4 = (N_3 + 1),
            Fun_2_loop(N_4, Sum_4, Term_4, X_2);
        _ -> {N_3, Sum_3, Term_3, X_2}
    end
end,
{N_4, Sum_4, Term_4, X_2} = Fun_2(N_3, Sum_3, Term_3, X_2),
        Sum_4
    catch {return, Ret} -> Ret end.

atanapprox(X_3) ->
    try
        case (X_3 > 1) of
        true -> throw({return, ((3.141592653589793 / 2) - (X_3 / ((X_3 * X_3) + 0.28)))});
        _ -> ok
    end,
        case (X_3 < -1) of
        true -> throw({return, ((-3.141592653589793 / 2) - (X_3 / ((X_3 * X_3) + 0.28)))});
        _ -> ok
    end,
        (X_3 / (1 + ((0.28 * X_3) * X_3)))
    catch {return, Ret} -> Ret end.

atan2approx(Y, X_4) ->
    try
        case (X_4 > 0) of
        true -> R = atanapprox((Y / X_4)),
            throw({return, R}),
            R_2 = R;
        _ -> R_2 = nil
    end,
        case (X_4 < 0) of
        true -> case (Y >= 0) of
        true -> throw({return, (atanapprox((Y / X_4)) + 3.141592653589793)});
        _ -> ok
    end,
            throw({return, (atanapprox((Y / X_4)) - 3.141592653589793)});
        _ -> ok
    end,
        case (Y > 0) of
        true -> throw({return, (3.141592653589793 / 2)});
        _ -> ok
    end,
        case (Y < 0) of
        true -> throw({return, (-3.141592653589793 / 2)});
        _ -> ok
    end,
        0
    catch {return, Ret} -> Ret end.

sqrtapprox(X_5) ->
    try
        Guess = X_5,
        I = 0,
        Fun_3 = fun Fun_3_loop(Guess, I, X_5) ->
    case (I < 10) of
        true ->
            Guess_2 = ((Guess + (X_5 / Guess)) / 2),
            I_2 = (I + 1),
            Fun_3_loop(Guess_2, I_2, X_5);
        _ -> {Guess, I, X_5}
    end
end,
{Guess_2, I_2, X_5} = Fun_3(Guess, I, X_5),
        Guess_2
    catch {return, Ret} -> Ret end.

rad(X_6) ->
    try
        ((X_6 * 3.141592653589793) / 180)
    catch {return, Ret} -> Ret end.

deg(X_7) ->
    try
        ((X_7 * 180) / 3.141592653589793)
    catch {return, Ret} -> Ret end.

distance(Lat1, Lon1, Lat2, Lon2) ->
    try
        Phi1 = rad(Lat1),
        Phi2 = rad(Lat2),
        Dphi = rad((Lat2 - Lat1)),
        Dlambda = rad((Lon2 - Lon1)),
        Sdphi = sinapprox((Dphi / 2)),
        Sdlambda = sinapprox((Dlambda / 2)),
        A = ((Sdphi * Sdphi) + (((cosapprox(Phi1) * cosapprox(Phi2)) * Sdlambda) * Sdlambda)),
        C = (2 * atan2approx(sqrtapprox(A), sqrtapprox((1 - A)))),
        ((6371 / 1.852) * C)
    catch {return, Ret} -> Ret end.

bearing(Lat1_2, Lon1_2, Lat2_2, Lon2_2) ->
    try
        Phi1_2 = rad(Lat1_2),
        Phi2_2 = rad(Lat2_2),
        Dl = rad((Lon2_2 - Lon1_2)),
        Y_2 = (sinapprox(Dl) * cosapprox(Phi2_2)),
        X_8 = ((cosapprox(Phi1_2) * sinapprox(Phi2_2)) - ((sinapprox(Phi1_2) * cosapprox(Phi2_2)) * cosapprox(Dl))),
        Br = deg(atan2approx(Y_2, X_8)),
        case (Br < 0) of
        true -> Br_2 = (Br + 360),
            Br_3 = Br_2;
        _ -> Br_3 = Br
    end,
        Br_3
    catch {return, Ret} -> Ret end.

floor(X_9) ->
    try
        I_3 = mochi_to_int(X_9),
        case (float(I_3) > X_9) of
        true -> I_4 = (I_3 - 1),
            I_5 = I_4;
        _ -> I_5 = I_3
    end,
        float(I_5)
    catch {return, Ret} -> Ret end.

pow10(N_5) ->
    try
        P = 1,
        I_6 = 0,
        Fun_4 = fun Fun_4_loop(I_6, N_5, P) ->
    case (I_6 < N_5) of
        true ->
            P_2 = (P * 10),
            I_7 = (I_6 + 1),
            Fun_4_loop(I_7, N_5, P_2);
        _ -> {I_6, N_5, P}
    end
end,
{I_7, N_5, P_2} = Fun_4(I_6, N_5, P),
        P_2
    catch {return, Ret} -> Ret end.

round(X_10, N_6) ->
    try
        M = pow10(N_6),
        (floor(((X_10 * M) + 0.5)) / M)
    catch {return, Ret} -> Ret end.

sortbydistance(Xs) ->
    try
        Arr = Xs,
        I_8 = 1,
        Fun_6 = fun Fun_6_loop(Arr, I_8, Xs) ->
    case (I_8 < length(Arr)) of
        true ->
            J = I_8,
            Fun_5 = fun Fun_5_loop(Arr, I_8, J, Xs) ->
    case ((J > 0) andalso (lists:nth(0 + 1, lists:nth((J - 1) + 1, Arr)) > lists:nth(0 + 1, lists:nth(J + 1, Arr)))) of
        true ->
            Tmp = lists:nth((J - 1) + 1, Arr),
            Arr_2 = lists:sublist(Arr, (J - 1)) ++ [lists:nth(J + 1, Arr)] ++ lists:nthtail((J - 1) + 1, Arr),
            Arr_3 = lists:sublist(Arr_2, J) ++ [Tmp] ++ lists:nthtail(J + 1, Arr_2),
            J_2 = (J - 1),
            Fun_5_loop(Arr_3, I_8, J_2, Xs);
        _ -> {Arr, I_8, J, Xs}
    end
end,
{Arr_3, I_8, J_2, Xs} = Fun_5(Arr, I_8, J, Xs),
            I_9 = (I_8 + 1),
            Fun_6_loop(Arr_3, I_9, Xs);
        _ -> {Arr, I_8, Xs}
    end
end,
{Arr_3, I_9, Xs} = Fun_6(Arr, I_8, Xs),
        Arr_3
    catch {return, Ret} -> Ret end.

main() ->
    try
        PlaneLat = 51.514669,
        PlaneLon = 2.198581,
        Results = [],
        Fun_7 = fun Fun_7_loop(List, PlaneLat, PlaneLon, Results) ->
    case List of
        [] -> {PlaneLat, PlaneLon, Results};
        [Ap|Ap_rest] ->
            D = distance(51.514669, 2.198581, maps:get("lat", Ap, nil), maps:get("lon", Ap, nil)),
            B = bearing(51.514669, 2.198581, maps:get("lat", Ap, nil), maps:get("lon", Ap, nil)),
            Results_2 = lists:append(Results, [[D, B, Ap]]),
            Fun_7_loop(Ap_rest, PlaneLat, PlaneLon, Results_2)
    end
end,
{PlaneLat, PlaneLon, Results_2} = Fun_7(erlang:get('airports'), PlaneLat, PlaneLon, Results),
        Results_3 = sortbydistance(Results_2),
        io:format("~ts~n", ["Distance Bearing ICAO Country               Airport"]),
        io:format("~ts~n", ["--------------------------------------------------------------"]),
        I_10 = 0,
        Fun_8 = fun Fun_8_loop(I_10, PlaneLat, PlaneLon, Results_3) ->
    case (I_10 < length(Results_3)) of
        true ->
            R_3 = lists:nth(I_10 + 1, Results_3),
            Ap_2 = lists:nth(2 + 1, R_3),
            Dist = lists:nth(0 + 1, R_3),
            Bear = lists:nth(1 + 1, R_3),
            Line = ((((((((lists:flatten(io_lib:format("~p", [round(Dist, 1)])) ++ "\t") ++ lists:flatten(io_lib:format("~p", [round(Bear, 0)]))) ++ "\t") ++ maps:get("icao", Ap_2, nil)) ++ "\t") ++ maps:get("country", Ap_2, nil)) ++ " ") ++ maps:get("name", Ap_2, nil)),
            io:format("~ts~n", [Line]),
            I_11 = (I_10 + 1),
            Fun_8_loop(I_11, PlaneLat, PlaneLon, Results_3);
        _ -> {I_10, PlaneLat, PlaneLon, Results_3}
    end
end,
{I_11, PlaneLat, PlaneLon, Results_3} = Fun_8(I_10, PlaneLat, PlaneLon, Results_3),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    erlang:put('PI', 3.141592653589793),
    erlang:put('airports', [#{"name" => "Koksijde Air Base", "country" => "Belgium", "icao" => "EBFN", "lat" => 51.090301513671875, "lon" => 2.652780055999756}, #{"name" => "Ostend-Bruges International Airport", "country" => "Belgium", "icao" => "EBOS", "lat" => 51.198898315399994, "lon" => 2.8622200489}, #{"name" => "Kent International Airport", "country" => "United Kingdom", "icao" => "EGMH", "lat" => 51.342201, "lon" => 1.34611}, #{"name" => "Calais-Dunkerque Airport", "country" => "France", "icao" => "LFAC", "lat" => 50.962100982666016, "lon" => 1.954759955406189}, #{"name" => "Westkapelle heliport", "country" => "Belgium", "icao" => "EBKW", "lat" => 51.32222366333, "lon" => 3.2930560112}, #{"name" => "Lympne Airport", "country" => "United Kingdom", "icao" => "EGMK", "lat" => 51.08, "lon" => 1.013}, #{"name" => "Ursel Air Base", "country" => "Belgium", "icao" => "EBUL", "lat" => 51.14419937133789, "lon" => 3.475559949874878}, #{"name" => "Southend Airport", "country" => "United Kingdom", "icao" => "EGMC", "lat" => 51.5713996887207, "lon" => 0.6955559849739075}, #{"name" => "Merville-Calonne Airport", "country" => "France", "icao" => "LFQT", "lat" => 50.61840057373047, "lon" => 2.642240047454834}, #{"name" => "Wevelgem Airport", "country" => "Belgium", "icao" => "EBKT", "lat" => 50.817199707, "lon" => 3.20472002029}, #{"name" => "Midden-Zeeland Airport", "country" => "Netherlands", "icao" => "EHMZ", "lat" => 51.5121994019, "lon" => 3.73111009598}, #{"name" => "Lydd Airport", "country" => "United Kingdom", "icao" => "EGMD", "lat" => 50.95610046386719, "lon" => 0.9391670227050781}, #{"name" => "RAF Wattisham", "country" => "United Kingdom", "icao" => "EGUW", "lat" => 52.1273002625, "lon" => 0.956264019012}, #{"name" => "Beccles Airport", "country" => "United Kingdom", "icao" => "EGSM", "lat" => 52.435298919699996, "lon" => 1.6183300018300002}, #{"name" => "Lille/Marcq-en-Baroeul Airport", "country" => "France", "icao" => "LFQO", "lat" => 50.687198638916016, "lon" => 3.0755600929260254}, #{"name" => "Lashenden (Headcorn) Airfield", "country" => "United Kingdom", "icao" => "EGKH", "lat" => 51.156898, "lon" => 0.641667}, #{"name" => "Le Touquet-Côte d'Opale Airport", "country" => "France", "icao" => "LFAT", "lat" => 50.517398834228516, "lon" => 1.6205899715423584}, #{"name" => "Rochester Airport", "country" => "United Kingdom", "icao" => "EGTO", "lat" => 51.351898193359375, "lon" => 0.5033329725265503}, #{"name" => "Lille-Lesquin Airport", "country" => "France", "icao" => "LFQQ", "lat" => 50.563332, "lon" => 3.086886}, #{"name" => "Thurrock Airfield", "country" => "United Kingdom", "icao" => "EGMT", "lat" => 51.537505, "lon" => 0.367634}]),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
