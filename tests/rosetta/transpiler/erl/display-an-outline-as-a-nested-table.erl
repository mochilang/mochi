#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, split/2, join/2, trimleftspaces/1, makeindent/2, tonest/4, countleaves/1, nodesbydepth/2, tomarkup/3, main/0]).

% Generated by Mochi transpiler v0.10.42 (34844ab2bf) on 2025-07-28 07:59 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

split(S, Sep) ->
    try
        Out = [],
        Cur = "",
        I = 0,
        Fun = fun Fun_loop(Cur, I, Out, S, Sep) ->
    case (I < length(S)) of
        true ->
            case (((I + length(Sep)) =< length(S)) andalso (string:substr(S, I + 1, ((I + length(Sep)) - I)) == Sep)) of
        true -> Out_2 = lists:append(Out, [Cur]),
            Cur_2 = "",
            I_2 = (I + length(Sep)),
            Cur_4 = Cur_2,
            I_4 = I_2,
            Out_3 = Out_2;
        _ -> Cur_3 = (Cur ++ string:substr(S, I + 1, ((I + 1) - I))),
            I_3 = (I + 1),
            Cur_4 = Cur_3,
            I_4 = I_3,
            Out_3 = Out
    end,
            Fun_loop(Cur_4, I_4, Out_3, S, Sep);
        _ -> {Cur, I, Out, S, Sep}
    end
end,
{Cur_4, I_4, Out_3, S, Sep} = Fun(Cur, I, Out, S, Sep),
        Out_4 = lists:append(Out_3, [Cur_4]),
        Out_4
    catch {return, Ret} -> Ret end.

join(Xs, Sep_2) ->
    try
        Res = "",
        I_5 = 0,
        Fun_2 = fun Fun_2_loop(I_5, Res, Sep_2, Xs) ->
    case (I_5 < length(Xs)) of
        true ->
            case (I_5 > 0) of
        true -> Res_2 = (Res ++ Sep_2),
            Res_3 = Res_2;
        _ -> Res_3 = Res
    end,
            Res_4 = (Res_3 ++ lists:nth(I_5 + 1, Xs)),
            I_6 = (I_5 + 1),
            Fun_2_loop(I_6, Res_4, Sep_2, Xs);
        _ -> {I_5, Res, Sep_2, Xs}
    end
end,
{I_6, Res_4, Sep_2, Xs} = Fun_2(I_5, Res, Sep_2, Xs),
        Res_4
    catch {return, Ret} -> Ret end.

trimleftspaces(S_2) ->
    try
        I_7 = 0,
        Fun_3 = fun Fun_3_loop(I_7, S_2) ->
    case ((I_7 < length(S_2)) andalso (string:substr(S_2, I_7 + 1, ((I_7 + 1) - I_7)) == " ")) of
        true ->
            I_8 = (I_7 + 1),
            Fun_3_loop(I_8, S_2);
        _ -> {I_7, S_2}
    end
end,
{I_8, S_2} = Fun_3(I_7, S_2),
        string:substr(S_2, I_8 + 1, (length(S_2) - I_8))
    catch {return, Ret} -> Ret end.

makeindent(Outline, Tab) ->
    try
        Lines = string:tokens(Outline, "\n"),
        Nodes = [],
        Fun_4 = fun Fun_4_loop(List, Lines, Nodes, Outline, Tab) ->
    case List of
        [] -> {Lines, Nodes, Outline, Tab};
        [Line|Line_rest] ->
            Line2 = trimleftspaces(Line),
            Level = ((length(Line) - length(Line2)) / Tab),
            Nodes_2 = lists:append(Nodes, [#{"level" => Level, "name" => Line2}]),
            Fun_4_loop(Line_rest, Lines, Nodes_2, Outline, Tab)
    end
end,
{Lines, Nodes_2, Outline, Tab} = Fun_4(Lines, Lines, Nodes, Outline, Tab),
        Nodes_2
    catch {return, Ret} -> Ret end.

tonest(Nodes_3, Start, Level_2, N) ->
    try
        case (Level_2 == 0) of
        true -> N_2 = maps:put("name", maps:get("name", lists:nth(0 + 1, Nodes_3), nil), N),
            N_3 = N_2;
        _ -> N_3 = N
    end,
        I_9 = (Start + 1),
        Fun_5 = fun Fun_5_loop(I_9, Level_2, N_3, Nodes_3, Start) ->
    case (I_9 < length(Nodes_3)) of
        true ->
            Node = lists:nth(I_9 + 1, Nodes_3),
            Lev = mochi_to_int(maps:get("level", Node, nil)),
            case (Lev == (Level_2 + 1)) of
        true -> Child = #{"name" => maps:get("name", Node, nil), "children" => []},
            tonest(Nodes_3, I_9, (Level_2 + 1), Child),
            Cs = maps:get("children", N_3, nil),
            Cs_2 = lists:append(Cs, [Child]),
            N_4 = maps:put("children", Cs_2, N_3),
            Child_2 = Child,
            Cs_3 = Cs_2,
            N_5 = N_4;
        _ -> case (Lev =< Level_2) of
        true -> throw({return, nil});
        _ -> ok
    end,
            Child_2 = nil,
            Cs_3 = nil,
            N_5 = N_3
    end,
            I_10 = (I_9 + 1),
            Fun_5_loop(I_10, Level_2, N_5, Nodes_3, Start);
        _ -> {I_9, Level_2, N_3, Nodes_3, Start}
    end
end,
{I_10, Level_2, N_5, Nodes_3, Start} = Fun_5(I_9, Level_2, N_3, Nodes_3, Start),
        nil
    catch {return, Ret} -> Ret end.

countleaves(N_6) ->
    try
        Kids = maps:get("children", N_6, nil),
        case (length(Kids) == 0) of
        true -> throw({return, 1});
        _ -> ok
    end,
        Total = 0,
        Fun_6 = fun Fun_6_loop(List, Kids, N_6, Total) ->
    case List of
        [] -> {Kids, N_6, Total};
        [K|K_rest] ->
            Total_2 = (Total + countleaves(K)),
            Fun_6_loop(K_rest, Kids, N_6, Total_2)
    end
end,
{Kids, N_6, Total_2} = Fun_6(Kids, Kids, N_6, Total),
        Total_2
    catch {return, Ret} -> Ret end.

nodesbydepth(Root, Depth) ->
    try
        Levels = [],
        Current = [Root],
        D = 0,
        Fun_9 = fun Fun_9_loop(Current, D, Depth, Levels, Root) ->
    case (D < Depth) of
        true ->
            Levels_2 = lists:append(Levels, [Current]),
            Next = [],
            Fun_7 = fun Fun_7_loop(List, Current, D, Depth, Levels_2, Next, Root) ->
    case List of
        [] -> {Current, D, Depth, Levels_2, Next, Root};
        [N_7|N_7_rest] ->
            Kids_2 = maps:get("children", N_7, nil),
            Fun_8 = fun Fun_8_loop(List, Current, D, Depth, Kids_2, Levels_2, N_7, Next, Root) ->
    case List of
        [] -> {Current, D, Depth, Kids_2, Levels_2, N_7, Next, Root};
        [K_2|K_2_rest] ->
            Next_2 = lists:append(Next, [K_2]),
            Fun_8_loop(K_2_rest, Current, D, Depth, Kids_2, Levels_2, N_7, Next_2, Root)
    end
end,
{Current, D, Depth, Kids_2, Levels_2, N_7, Next_2, Root} = Fun_8(Kids_2, Current, D, Depth, Kids_2, Levels_2, N_7, Next, Root),
            Fun_7_loop(N_7_rest, Current, D, Depth, Levels_2, Next_2, Root)
    end
end,
{Current, D, Depth, Levels_2, Next_2, Root} = Fun_7(Current, Current, D, Depth, Levels_2, Next, Root),
            Current_2 = Next_2,
            D_2 = (D + 1),
            Fun_9_loop(Current_2, D_2, Depth, Levels_2, Root);
        _ -> {Current, D, Depth, Levels, Root}
    end
end,
{Current_2, D_2, Depth, Levels_2, Root} = Fun_9(Current, D, Depth, Levels, Root),
        Levels_2
    catch {return, Ret} -> Ret end.

tomarkup(N_8, Cols, Depth_2) ->
    try
        Lines_2 = [],
        Lines_3 = lists:append(Lines_2, ["{| class=\"wikitable\" style=\"text-align: center;\""]),
        L1 = "|-",
        Lines_4 = lists:append(Lines_3, ["|-"]),
        Span = countleaves(N_8),
        Lines_5 = lists:append(Lines_4, [((((("| style=\"background: " ++ lists:nth(0 + 1, Cols)) ++ " \" colSpan=") ++ lists:flatten(io_lib:format("~p", [Span]))) ++ " | ") ++ maps:get("name", N_8, nil))]),
        Lines_6 = lists:append(Lines_5, ["|-"]),
        Lvls = nodesbydepth(N_8, Depth_2),
        Lvl = 1,
        Fun_12 = fun Fun_12_loop(Cols, Depth_2, L1, Lines_6, Lvl, Lvls, N_8, Span) ->
    case (Lvl < Depth_2) of
        true ->
            Nodes_4 = lists:nth(Lvl + 1, Lvls),
            case (length(Nodes_4) == 0) of
        true -> Lines_7 = lists:append(Lines_6, ["|  |"]),
            Fun_11 = nil,
            Idx_3 = nil,
            Lines_9 = Lines_7,
            Span_3 = Span;
        _ -> Idx = 0,
            Fun_10 = fun Fun_10_loop(Cols, Depth_2, Idx, L1, Lines_6, Lvl, Lvls, N_8, Nodes_4, Span) ->
    case (Idx < length(Nodes_4)) of
        true ->
            Node_2 = lists:nth(Idx + 1, Nodes_4),
            Span_2 = countleaves(Node_2),
            Col = Lvl,
            case (Lvl == 1) of
        true -> Col_2 = (Idx + 1),
            Col_3 = Col_2;
        _ -> Col_3 = Col
    end,
            case (Col_3 >= length(Cols)) of
        true -> Col_4 = (length(Cols) - 1),
            Col_5 = Col_4;
        _ -> Col_5 = Col_3
    end,
            Cell = ((((("| style=\"background: " ++ lists:nth(Col_5 + 1, Cols)) ++ " \" colspan=") ++ lists:flatten(io_lib:format("~p", [Span_2]))) ++ " | ") ++ maps:get("name", Node_2, nil)),
            Lines_8 = lists:append(Lines_6, [Cell]),
            Idx_2 = (Idx + 1),
            Fun_10_loop(Cols, Depth_2, Idx_2, L1, Lines_8, Lvl, Lvls, N_8, Nodes_4, Span_2);
        _ -> {Cols, Depth_2, Idx, L1, Lines_6, Lvl, Lvls, N_8, Nodes_4, Span}
    end
end,
{Cols, Depth_2, Idx_2, L1, Lines_8, Lvl, Lvls, N_8, Nodes_4, Span_2} = Fun_10(Cols, Depth_2, Idx, L1, Lines_6, Lvl, Lvls, N_8, Nodes_4, Span),
            Fun_11 = Fun_10,
            Idx_3 = Idx_2,
            Lines_9 = Lines_8,
            Span_3 = Span_2
    end,
            case (Lvl < (Depth_2 - 1)) of
        true -> Lines_10 = lists:append(Lines_9, [L1]),
            Lines_11 = Lines_10;
        _ -> Lines_11 = Lines_9
    end,
            Lvl_2 = (Lvl + 1),
            Fun_12_loop(Cols, Depth_2, L1, Lines_11, Lvl_2, Lvls, N_8, Span_3);
        _ -> {Cols, Depth_2, L1, Lines_6, Lvl, Lvls, N_8, Span}
    end
end,
{Cols, Depth_2, L1, Lines_11, Lvl_2, Lvls, N_8, Span_3} = Fun_12(Cols, Depth_2, L1, Lines_6, Lvl, Lvls, N_8, Span),
        Lines_12 = lists:append(Lines_11, ["|}"]),
        join(Lines_12, "\n")
    catch {return, Ret} -> Ret end.

main() ->
    try
        Outline_2 = ((((((((((("Display an outline as a nested table.\n" ++ "    Parse the outline to a tree,\n") ++ "        measuring the indent of each line,\n") ++ "        translating the indentation to a nested structure,\n") ++ "        and padding the tree to even depth.\n") ++ "    count the leaves descending from each node,\n") ++ "        defining the width of a leaf as 1,\n") ++ "        and the width of a parent node as a sum.\n") ++ "            (The sum of the widths of its children)\n") ++ "    and write out a table with 'colspan' values\n") ++ "        either as a wiki table,\n") ++ "        or as HTML."),
        Yellow = "#ffffe6;",
        Orange = "#ffebd2;",
        Green = "#f0fff0;",
        Blue = "#e6ffff;",
        Pink = "#ffeeff;",
        Cols_2 = ["#ffffe6;", "#ffebd2;", "#f0fff0;", "#e6ffff;", "#ffeeff;"],
        Nodes_5 = makeindent(Outline_2, 4),
        N_9 = #{"name" => "", "children" => []},
        tonest(Nodes_5, 0, 0, N_9),
        io:format("~ts~n", [tomarkup(N_9, Cols_2, 4)]),
        io:format("~ts~n", ["\n"]),
        Outline2 = ((((((((((((("Display an outline as a nested table.\n" ++ "    Parse the outline to a tree,\n") ++ "        measuring the indent of each line,\n") ++ "        translating the indentation to a nested structure,\n") ++ "        and padding the tree to even depth.\n") ++ "    count the leaves descending from each node,\n") ++ "        defining the width of a leaf as 1,\n") ++ "        and the width of a parent node as a sum.\n") ++ "            (The sum of the widths of its children)\n") ++ "            Propagating the sums upward as necessary.\n") ++ "    and write out a table with 'colspan' values\n") ++ "        either as a wiki table,\n") ++ "        or as HTML.\n") ++ "    Optionally add color to the nodes."),
        Cols2 = ["#e6ffff;", "#ffffe6;", "#ffebd2;", "#f0fff0;", "#ffeeff;"],
        Nodes2 = makeindent(Outline2, 4),
        N2 = #{"name" => "", "children" => []},
        tonest(Nodes2, 0, 0, N2),
        io:format("~ts~n", [tomarkup(N2, Cols2, 4)]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
