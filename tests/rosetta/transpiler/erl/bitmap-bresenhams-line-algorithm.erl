#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, absi/1, bresenham/4, main/0]).

% Generated by Mochi transpiler v0.10.40 (d09b89bb59) on 2025-07-25 17:42 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.

absi(X) ->
    try
        (case (X < 0) of
    true -> -X;
    _ -> X
end)
    catch {return, Ret} -> Ret end.

bresenham(X0, Y0, X1, Y1) ->
    try
        Dx = absi((X1 - X0)),
        Dy = absi((Y1 - Y0)),
        Sx = -1,
        case (X0 < X1) of
        true -> Sx_2 = 1,
            Sx_3 = Sx_2;
        _ -> Sx_3 = Sx
    end,
        Sy = -1,
        case (Y0 < Y1) of
        true -> Sy_2 = 1,
            Sy_3 = Sy_2;
        _ -> Sy_3 = Sy
    end,
        Err = (Dx - Dy),
        Pts = [],
        Fun = fun Fun_loop(Dx, Dy, Err, Pts, Sx_3, Sy_3, X0, X1, Y0, Y1) ->
    case true of
        true ->
            try
                Pts_2 = lists:append(Pts, [#{"x" => X0, "y" => Y0}]),
                case ((X0 == X1) andalso (Y0 == Y1)) of
        true -> throw(break);
        _ -> ok
    end,
                E2 = (2 * Err),
                case (E2 > -Dy) of
        true -> Err_2 = (Err - Dy),
            X0_2 = (X0 + Sx_3),
            Err_3 = Err_2,
            X0_3 = X0_2;
        _ -> Err_3 = Err,
            X0_3 = X0
    end,
                case (E2 < Dx) of
        true -> Err_4 = (Err_3 + Dx),
            Y0_2 = (Y0 + Sy_3),
            Err_5 = Err_4,
            Y0_3 = Y0_2;
        _ -> Err_5 = Err_3,
            Y0_3 = Y0
    end,
                Fun_loop(Dx, Dy, Err_5, Pts_2, Sx_3, Sy_3, X0_3, X1, Y0_3, Y1)
            catch
                {continue, C0, C1, C2, C3, C4, C5, C6, C7, C8, C9} -> Fun_loop(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9);
                break -> {Dx, Dy, Err, Pts, Sx_3, Sy_3, X0, X1, Y0, Y1}
            end;
        _ -> {Dx, Dy, Err, Pts, Sx_3, Sy_3, X0, X1, Y0, Y1}
    end
end,
{Dx, Dy, Err_5, Pts_2, Sx_3, Sy_3, X0_3, X1, Y0_3, Y1} = Fun(Dx, Dy, Err, Pts, Sx_3, Sy_3, X0, X1, Y0, Y1),
        Pts_2
    catch {return, Ret} -> Ret end.

main() ->
    try
        Pts_3 = bresenham(0, 0, 6, 4),
        I = 0,
        Fun_2 = fun Fun_2_loop(I, Pts_3) ->
    case (I < length(Pts_3)) of
        true ->
            P = lists:nth(I + 1, Pts_3),
            io:format("~ts~n", [(((("(" ++ lists:flatten(io_lib:format("~p", [maps:get("x", P, nil)]))) ++ ",") ++ lists:flatten(io_lib:format("~p", [maps:get("y", P, nil)]))) ++ ")")]),
            I_2 = (I + 1),
            Fun_2_loop(I_2, Pts_3);
        _ -> {I, Pts_3}
    end
end,
{I_2, Pts_3} = Fun_2(I, Pts_3),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
