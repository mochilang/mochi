#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, skipws/1, parseintstr/1, parsenumber/1, parsefactor/1, powint/2, parsepower/1, parseterm/1, parseexpr/1, evalexpr/1, main/0]).

% Generated by Mochi transpiler v0.10.40 (f9624223c7) on 2025-07-25 23:47 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_parse_int_str(S) ->
    try list_to_integer(S) catch _:_ -> 0 end.

skipws(P) ->
    try
        I = maps:get("pos", P, nil),
        Fun = fun Fun_loop(I, P) ->
    case ((I < length(maps:get("expr", P, nil))) andalso (string:substr(maps:get("expr", P, nil), I + 1, ((I + 1) - I)) == " ")) of
        true ->
            I_2 = (I + 1),
            Fun_loop(I_2, P);
        _ -> {I, P}
    end
end,
{I_2, P} = Fun(I, P),
        P_2 = maps:put("pos", I_2, P),
        P_2
    catch {return, Ret} -> Ret end.

parseintstr(Str) ->
    try
        I_3 = 0,
        N = 0,
        Fun_2 = fun Fun_2_loop(I_3, N, Str) ->
    case (I_3 < length(Str)) of
        true ->
            N_2 = (((N * 10) + mochi_to_int(string:substr(Str, I_3 + 1, ((I_3 + 1) - I_3)))) - 48),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, N_2, Str);
        _ -> {I_3, N, Str}
    end
end,
{I_4, N_2, Str} = Fun_2(I_3, N, Str),
        N_2
    catch {return, Ret} -> Ret end.

parsenumber(P_3) ->
    try
        P_4 = skipws(P_3),
        Start = maps:get("pos", P_4, nil),
        Fun_3 = fun Fun_3_loop(P_4, Start) ->
    case (maps:get("pos", P_4, nil) < length(maps:get("expr", P_4, nil))) of
        true ->
            try
                Ch = string:substr(maps:get("expr", P_4, nil), maps:get("pos", P_4, nil) + 1, ((maps:get("pos", P_4, nil) + 1) - maps:get("pos", P_4, nil))),
                case ((Ch >= "0") andalso (Ch =< "9")) of
        true -> P_5 = maps:put("pos", (maps:get("pos", P_4, nil) + 1), P_4),
            P_6 = P_5;
        _ -> throw(break),
            P_6 = P_4
    end,
                Fun_3_loop(P_6, Start)
            catch
                {continue, C0, C1} -> Fun_3_loop(C0, C1);
                break -> {P_4, Start}
            end;
        _ -> {P_4, Start}
    end
end,
{P_6, Start} = Fun_3(P_4, Start),
        Token = string:substr(maps:get("expr", P_6, nil), Start + 1, (maps:get("pos", P_6, nil) - Start)),
        #{"v" => mochi_parse_int_str(Token), "p" => P_6}
    catch {return, Ret} -> Ret end.

parsefactor(P_7) ->
    try
        P_8 = skipws(P_7),
        case ((maps:get("pos", P_8, nil) < length(maps:get("expr", P_8, nil))) andalso (string:substr(maps:get("expr", P_8, nil), maps:get("pos", P_8, nil) + 1, ((maps:get("pos", P_8, nil) + 1) - maps:get("pos", P_8, nil))) == "(")) of
        true -> P_9 = maps:put("pos", (maps:get("pos", P_8, nil) + 1), P_8),
            R = parseexpr(P_9),
            V = maps:get("v", R, nil),
            P_10 = maps:get("p", R, nil),
            P_11 = skipws(P_10),
            case ((maps:get("pos", P_11, nil) < length(maps:get("expr", P_11, nil))) andalso (string:substr(maps:get("expr", P_11, nil), maps:get("pos", P_11, nil) + 1, ((maps:get("pos", P_11, nil) + 1) - maps:get("pos", P_11, nil))) == ")")) of
        true -> P_12 = maps:put("pos", (maps:get("pos", P_11, nil) + 1), P_11),
            P_13 = P_12;
        _ -> P_13 = P_11
    end,
            throw({return, #{"v" => V, "p" => P_13}}),
            P_14 = P_13,
            R_2 = R,
            V_2 = V;
        _ -> P_14 = P_8,
            R_2 = nil,
            V_2 = nil
    end,
        case ((maps:get("pos", P_14, nil) < length(maps:get("expr", P_14, nil))) andalso (string:substr(maps:get("expr", P_14, nil), maps:get("pos", P_14, nil) + 1, ((maps:get("pos", P_14, nil) + 1) - maps:get("pos", P_14, nil))) == "-")) of
        true -> P_15 = maps:put("pos", (maps:get("pos", P_14, nil) + 1), P_14),
            R_3 = parsefactor(P_15),
            V_3 = maps:get("v", R_3, nil),
            P_16 = maps:get("p", R_3, nil),
            throw({return, #{"v" => -V_3, "p" => P_16}}),
            P_17 = P_16,
            R_4 = R_3,
            V_4 = V_3;
        _ -> P_17 = P_14,
            R_4 = R_2,
            V_4 = V_2
    end,
        parsenumber(P_17)
    catch {return, Ret} -> Ret end.

powint(Base, Exp) ->
    try
        R_5 = 1,
        B = Base,
        E = Exp,
        Fun_4 = fun Fun_4_loop(B, Base, E, Exp, R_5) ->
    case (E > 0) of
        true ->
            case ((E rem 2) == 1) of
        true -> R_6 = (R_5 * B),
            R_7 = R_6;
        _ -> R_7 = R_5
    end,
            B_2 = (B * B),
            E_2 = (E div mochi_to_int(2)),
            Fun_4_loop(B_2, Base, E_2, Exp, R_7);
        _ -> {B, Base, E, Exp, R_5}
    end
end,
{B_2, Base, E_2, Exp, R_7} = Fun_4(B, Base, E, Exp, R_5),
        R_7
    catch {return, Ret} -> Ret end.

parsepower(P_18) ->
    try
        R_8 = parsefactor(P_18),
        V_5 = maps:get("v", R_8, nil),
        P_19 = maps:get("p", R_8, nil),
        Fun_5 = fun Fun_5_loop(P_19, R_8, V_5) ->
    case true of
        true ->
            try
                P_20 = skipws(P_19),
                case ((maps:get("pos", P_20, nil) < length(maps:get("expr", P_20, nil))) andalso (string:substr(maps:get("expr", P_20, nil), maps:get("pos", P_20, nil) + 1, ((maps:get("pos", P_20, nil) + 1) - maps:get("pos", P_20, nil))) == "^")) of
        true -> P_21 = maps:put("pos", (maps:get("pos", P_20, nil) + 1), P_20),
            R2 = parsefactor(P_21),
            Rhs = maps:get("v", R2, nil),
            P_22 = maps:get("p", R2, nil),
            V_6 = powint(V_5, Rhs),
            P_23 = P_22,
            R2_2 = R2,
            Rhs_2 = Rhs,
            V_7 = V_6;
        _ -> throw(break),
            P_23 = P_20,
            R2_2 = nil,
            Rhs_2 = nil,
            V_7 = V_5
    end,
                Fun_5_loop(P_23, R_8, V_7)
            catch
                {continue, C0, C1, C2} -> Fun_5_loop(C0, C1, C2);
                break -> {P_19, R_8, V_5}
            end;
        _ -> {P_19, R_8, V_5}
    end
end,
{P_23, R_8, V_7} = Fun_5(P_19, R_8, V_5),
        #{"v" => V_7, "p" => P_23}
    catch {return, Ret} -> Ret end.

parseterm(P_24) ->
    try
        R_9 = parsepower(P_24),
        V_8 = maps:get("v", R_9, nil),
        P_25 = maps:get("p", R_9, nil),
        Fun_6 = fun Fun_6_loop(P_25, R_9, V_8) ->
    case true of
        true ->
            try
                P_26 = skipws(P_25),
                case (maps:get("pos", P_26, nil) < length(maps:get("expr", P_26, nil))) of
        true -> Op = string:substr(maps:get("expr", P_26, nil), maps:get("pos", P_26, nil) + 1, ((maps:get("pos", P_26, nil) + 1) - maps:get("pos", P_26, nil))),
            case (Op == "*") of
        true -> P_27 = maps:put("pos", (maps:get("pos", P_26, nil) + 1), P_26),
            R2_3 = parsepower(P_27),
            Rhs_3 = maps:get("v", R2_3, nil),
            P_28 = maps:get("p", R2_3, nil),
            V_9 = (V_8 * Rhs_3),
            throw({continue, P_28, R_9, V_9}),
            P_29 = P_28,
            R2_4 = R2_3,
            Rhs_4 = Rhs_3,
            V_10 = V_9;
        _ -> P_29 = P_26,
            R2_4 = nil,
            Rhs_4 = nil,
            V_10 = V_8
    end,
            case (Op == "/") of
        true -> P_30 = maps:put("pos", (maps:get("pos", P_29, nil) + 1), P_29),
            R2_5 = parsepower(P_30),
            Rhs_5 = maps:get("v", R2_5, nil),
            P_31 = maps:get("p", R2_5, nil),
            V_11 = (V_10 div mochi_to_int(Rhs_5)),
            throw({continue, P_31, R_9, V_11}),
            P_32 = P_31,
            R2_6 = R2_5,
            Rhs_6 = Rhs_5,
            V_12 = V_11;
        _ -> P_32 = P_29,
            R2_6 = R2_4,
            Rhs_6 = Rhs_4,
            V_12 = V_10
    end,
            Op_2 = Op,
            P_33 = P_32,
            R2_7 = R2_6,
            Rhs_7 = Rhs_6,
            V_13 = V_12;
        _ -> Op_2 = nil,
            P_33 = P_26,
            R2_7 = nil,
            Rhs_7 = nil,
            V_13 = V_8
    end,
                throw(break),
                Fun_6_loop(P_33, R_9, V_13)
            catch
                {continue, C0, C1, C2} -> Fun_6_loop(C0, C1, C2);
                break -> {P_25, R_9, V_8}
            end;
        _ -> {P_25, R_9, V_8}
    end
end,
{P_33, R_9, V_13} = Fun_6(P_25, R_9, V_8),
        #{"v" => V_13, "p" => P_33}
    catch {return, Ret} -> Ret end.

parseexpr(P_34) ->
    try
        R_10 = parseterm(P_34),
        V_14 = maps:get("v", R_10, nil),
        P_35 = maps:get("p", R_10, nil),
        Fun_7 = fun Fun_7_loop(P_35, R_10, V_14) ->
    case true of
        true ->
            try
                P_36 = skipws(P_35),
                case (maps:get("pos", P_36, nil) < length(maps:get("expr", P_36, nil))) of
        true -> Op_3 = string:substr(maps:get("expr", P_36, nil), maps:get("pos", P_36, nil) + 1, ((maps:get("pos", P_36, nil) + 1) - maps:get("pos", P_36, nil))),
            case (Op_3 == "+") of
        true -> P_37 = maps:put("pos", (maps:get("pos", P_36, nil) + 1), P_36),
            R2_8 = parseterm(P_37),
            Rhs_8 = maps:get("v", R2_8, nil),
            P_38 = maps:get("p", R2_8, nil),
            V_15 = (V_14 + Rhs_8),
            throw({continue, P_38, R_10, V_15}),
            P_39 = P_38,
            R2_9 = R2_8,
            Rhs_9 = Rhs_8,
            V_16 = V_15;
        _ -> P_39 = P_36,
            R2_9 = nil,
            Rhs_9 = nil,
            V_16 = V_14
    end,
            case (Op_3 == "-") of
        true -> P_40 = maps:put("pos", (maps:get("pos", P_39, nil) + 1), P_39),
            R2_10 = parseterm(P_40),
            Rhs_10 = maps:get("v", R2_10, nil),
            P_41 = maps:get("p", R2_10, nil),
            V_17 = (V_16 - Rhs_10),
            throw({continue, P_41, R_10, V_17}),
            P_42 = P_41,
            R2_11 = R2_10,
            Rhs_11 = Rhs_10,
            V_18 = V_17;
        _ -> P_42 = P_39,
            R2_11 = R2_9,
            Rhs_11 = Rhs_9,
            V_18 = V_16
    end,
            Op_4 = Op_3,
            P_43 = P_42,
            R2_12 = R2_11,
            Rhs_12 = Rhs_11,
            V_19 = V_18;
        _ -> Op_4 = nil,
            P_43 = P_36,
            R2_12 = nil,
            Rhs_12 = nil,
            V_19 = V_14
    end,
                throw(break),
                Fun_7_loop(P_43, R_10, V_19)
            catch
                {continue, C0, C1, C2} -> Fun_7_loop(C0, C1, C2);
                break -> {P_35, R_10, V_14}
            end;
        _ -> {P_35, R_10, V_14}
    end
end,
{P_43, R_10, V_19} = Fun_7(P_35, R_10, V_14),
        #{"v" => V_19, "p" => P_43}
    catch {return, Ret} -> Ret end.

evalexpr(Expr) ->
    try
        P_44 = #{"expr" => Expr, "pos" => 0},
        R_11 = parseexpr(P_44),
        maps:get("v", R_11, nil)
    catch {return, Ret} -> Ret end.

main() ->
    try
        Expr_2 = "2*(3-1)+2*5",
        io:format("~ts~n", [(("2*(3-1)+2*5" ++ " = ") ++ lists:flatten(io_lib:format("~p", [evalexpr("2*(3-1)+2*5")])))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    Start = mochi_now(),
    StartMem = erlang:memory(total),
    main(),
    End = mochi_now(),
    EndMem = erlang:memory(total),
    DurationUs = (End - Start) div 1000,
    MemBytes = abs(EndMem - StartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
