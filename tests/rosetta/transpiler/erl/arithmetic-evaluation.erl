#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, skipWS/1, parseIntStr/1, parseNumber/1, parseFactor/1, powInt/2, parsePower/1, parseTerm/1, parseExpr/1, evalExpr/1, main/0]).

% Generated by Mochi transpiler v0.10.39 (6b9be63842) on 2025-07-24 22:46 +0700


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.

skipWS(P) ->
    try
        I = maps:get("pos", P),
        Fun = fun Fun_loop(I, P) ->
    case ((I < maps:size(maps:get("expr", P))) andalso (string:substr(maps:get("expr", P), I + 1, ((I + 1) - I)) == " ")) of
        true ->
            I_2 = (I + 1),
            Fun_loop(I_2, P);
        _ -> {I, P}
    end
end,
{I_2, P} = Fun(I, P),
        P_2 = maps:put("pos", I_2, P),
        P_2
    catch {return, Ret} -> Ret end.

parseIntStr(Str) ->
    try
        I_3 = 0,
        N = 0,
        Fun_2 = fun Fun_2_loop(I_3, N, Str) ->
    case (I_3 < length(Str)) of
        true ->
            N_2 = (((N * 10) + mochi_to_int(string:substr(Str, I_3 + 1, ((I_3 + 1) - I_3)))) - 48),
            I_4 = (I_3 + 1),
            Fun_2_loop(I_4, N_2, Str);
        _ -> {I_3, N, Str}
    end
end,
{I_4, N_2, Str} = Fun_2(I_3, N, Str),
        N_2
    catch {return, Ret} -> Ret end.

parseNumber(P_3) ->
    try
        P_4 = skipWS(P_3),
        Start = maps:get("pos", P_4),
        Fun_3 = fun Fun_3_loop(P_4, Start) ->
    case (maps:get("pos", P_4) < maps:size(maps:get("expr", P_4))) of
        true ->
            try
                Ch = string:substr(maps:get("expr", P_4), maps:get("pos", P_4) + 1, ((maps:get("pos", P_4) + 1) - maps:get("pos", P_4))),
                case ((Ch >= "0") andalso (Ch =< "9")) of
        true -> P_5 = maps:put("pos", (maps:get("pos", P_4) + 1), P_4),
            P_6 = P_5;
        _ -> throw(break),
            P_6 = P_4
    end,
                Fun_3_loop(P_6, Start)
            catch
                {continue, C0, C1} -> Fun_3_loop(C0, C1);
                break -> {P_4, Start}
            end;
        _ -> {P_4, Start}
    end
end,
{P_6, Start} = Fun_3(P_4, Start),
        Token = string:substr(maps:get("expr", P_6), Start + 1, (maps:get("pos", P_6) - Start)),
        #{"v" => parseIntStr(Token), "p" => P_6}
    catch {return, Ret} -> Ret end.

parseFactor(P_7) ->
    try
        P_8 = skipWS(P_7),
        case ((maps:get("pos", P_8) < maps:size(maps:get("expr", P_8))) andalso (string:substr(maps:get("expr", P_8), maps:get("pos", P_8) + 1, ((maps:get("pos", P_8) + 1) - maps:get("pos", P_8))) == "(")) of
        true -> P_9 = maps:put("pos", (maps:get("pos", P_8) + 1), P_8),
            R = parseExpr(P_9),
            V = maps:get("v", R),
            P_10 = maps:get("p", R),
            P_11 = skipWS(P_10),
            case ((maps:get("pos", P_11) < maps:size(maps:get("expr", P_11))) andalso (string:substr(maps:get("expr", P_11), maps:get("pos", P_11) + 1, ((maps:get("pos", P_11) + 1) - maps:get("pos", P_11))) == ")")) of
        true -> P_12 = maps:put("pos", (maps:get("pos", P_11) + 1), P_11),
            P_13 = P_12;
        _ -> P_13 = P_11
    end,
            throw({return, #{"v" => V, "p" => P_13}}),
            P_14 = P_13,
            R_2 = R,
            V_2 = V;
        _ -> P_14 = P_8,
            R_2 = nil,
            V_2 = nil
    end,
        case ((maps:get("pos", P_14) < maps:size(maps:get("expr", P_14))) andalso (string:substr(maps:get("expr", P_14), maps:get("pos", P_14) + 1, ((maps:get("pos", P_14) + 1) - maps:get("pos", P_14))) == "-")) of
        true -> P_15 = maps:put("pos", (maps:get("pos", P_14) + 1), P_14),
            R_3 = parseFactor(P_15),
            V_3 = maps:get("v", R_3),
            P_16 = maps:get("p", R_3),
            throw({return, #{"v" => -V_3, "p" => P_16}}),
            P_17 = P_16,
            R_4 = R_3,
            V_4 = V_3;
        _ -> P_17 = P_14,
            R_4 = R_2,
            V_4 = V_2
    end,
        parseNumber(P_17)
    catch {return, Ret} -> Ret end.

powInt(Base, Exp) ->
    try
        R_5 = 1,
        B = Base,
        E = Exp,
        Fun_4 = fun Fun_4_loop(B, Base, E, Exp, R_5) ->
    case (E > 0) of
        true ->
            case ((E rem 2) == 1) of
        true -> R_6 = (R_5 * B),
            R_7 = R_6;
        _ -> R_7 = R_5
    end,
            B_2 = (B * B),
            E_2 = (E div mochi_to_int(2)),
            Fun_4_loop(B_2, Base, E_2, Exp, R_7);
        _ -> {B, Base, E, Exp, R_5}
    end
end,
{B_2, Base, E_2, Exp, R_7} = Fun_4(B, Base, E, Exp, R_5),
        R_7
    catch {return, Ret} -> Ret end.

parsePower(P_18) ->
    try
        R_8 = parseFactor(P_18),
        V_5 = maps:get("v", R_8),
        P_19 = maps:get("p", R_8),
        Fun_5 = fun Fun_5_loop(P_19, R_8, V_5) ->
    case true of
        true ->
            try
                P_20 = skipWS(P_19),
                case ((maps:get("pos", P_20) < maps:size(maps:get("expr", P_20))) andalso (string:substr(maps:get("expr", P_20), maps:get("pos", P_20) + 1, ((maps:get("pos", P_20) + 1) - maps:get("pos", P_20))) == "^")) of
        true -> P_21 = maps:put("pos", (maps:get("pos", P_20) + 1), P_20),
            R2 = parseFactor(P_21),
            Rhs = maps:get("v", R2),
            P_22 = maps:get("p", R2),
            V_6 = powInt(V_5, Rhs),
            P_23 = P_22,
            R2_2 = R2,
            Rhs_2 = Rhs,
            V_7 = V_6;
        _ -> throw(break),
            P_23 = P_20,
            R2_2 = nil,
            Rhs_2 = nil,
            V_7 = V_5
    end,
                Fun_5_loop(P_23, R_8, V_7)
            catch
                {continue, C0, C1, C2} -> Fun_5_loop(C0, C1, C2);
                break -> {P_19, R_8, V_5}
            end;
        _ -> {P_19, R_8, V_5}
    end
end,
{P_23, R_8, V_7} = Fun_5(P_19, R_8, V_5),
        #{"v" => V_7, "p" => P_23}
    catch {return, Ret} -> Ret end.

parseTerm(P_24) ->
    try
        R_9 = parsePower(P_24),
        V_8 = maps:get("v", R_9),
        P_25 = maps:get("p", R_9),
        Fun_6 = fun Fun_6_loop(P_25, R_9, V_8) ->
    case true of
        true ->
            try
                P_26 = skipWS(P_25),
                case (maps:get("pos", P_26) < maps:size(maps:get("expr", P_26))) of
        true -> Op = string:substr(maps:get("expr", P_26), maps:get("pos", P_26) + 1, ((maps:get("pos", P_26) + 1) - maps:get("pos", P_26))),
            case (Op == "*") of
        true -> P_27 = maps:put("pos", (maps:get("pos", P_26) + 1), P_26),
            R2_3 = parsePower(P_27),
            Rhs_3 = maps:get("v", R2_3),
            P_28 = maps:get("p", R2_3),
            V_9 = (V_8 * Rhs_3),
            throw({continue, P_28, R_9, V_9}),
            P_29 = P_28,
            R2_4 = R2_3,
            Rhs_4 = Rhs_3,
            V_10 = V_9;
        _ -> P_29 = P_26,
            R2_4 = nil,
            Rhs_4 = nil,
            V_10 = V_8
    end,
            case (Op == "/") of
        true -> P_30 = maps:put("pos", (maps:get("pos", P_29) + 1), P_29),
            R2_5 = parsePower(P_30),
            Rhs_5 = maps:get("v", R2_5),
            P_31 = maps:get("p", R2_5),
            V_11 = (V_10 div mochi_to_int(Rhs_5)),
            throw({continue, P_31, R_9, V_11}),
            P_32 = P_31,
            R2_6 = R2_5,
            Rhs_6 = Rhs_5,
            V_12 = V_11;
        _ -> P_32 = P_29,
            R2_6 = R2_4,
            Rhs_6 = Rhs_4,
            V_12 = V_10
    end,
            Op_2 = Op,
            P_33 = P_32,
            R2_7 = R2_6,
            Rhs_7 = Rhs_6,
            V_13 = V_12;
        _ -> Op_2 = nil,
            P_33 = P_26,
            R2_7 = nil,
            Rhs_7 = nil,
            V_13 = V_8
    end,
                throw(break),
                Fun_6_loop(P_33, R_9, V_13)
            catch
                {continue, C0, C1, C2} -> Fun_6_loop(C0, C1, C2);
                break -> {P_25, R_9, V_8}
            end;
        _ -> {P_25, R_9, V_8}
    end
end,
{P_33, R_9, V_13} = Fun_6(P_25, R_9, V_8),
        #{"v" => V_13, "p" => P_33}
    catch {return, Ret} -> Ret end.

parseExpr(P_34) ->
    try
        R_10 = parseTerm(P_34),
        V_14 = maps:get("v", R_10),
        P_35 = maps:get("p", R_10),
        Fun_7 = fun Fun_7_loop(P_35, R_10, V_14) ->
    case true of
        true ->
            try
                P_36 = skipWS(P_35),
                case (maps:get("pos", P_36) < maps:size(maps:get("expr", P_36))) of
        true -> Op_3 = string:substr(maps:get("expr", P_36), maps:get("pos", P_36) + 1, ((maps:get("pos", P_36) + 1) - maps:get("pos", P_36))),
            case (Op_3 == "+") of
        true -> P_37 = maps:put("pos", (maps:get("pos", P_36) + 1), P_36),
            R2_8 = parseTerm(P_37),
            Rhs_8 = maps:get("v", R2_8),
            P_38 = maps:get("p", R2_8),
            V_15 = (V_14 + Rhs_8),
            throw({continue, P_38, R_10, V_15}),
            P_39 = P_38,
            R2_9 = R2_8,
            Rhs_9 = Rhs_8,
            V_16 = V_15;
        _ -> P_39 = P_36,
            R2_9 = nil,
            Rhs_9 = nil,
            V_16 = V_14
    end,
            case (Op_3 == "-") of
        true -> P_40 = maps:put("pos", (maps:get("pos", P_39) + 1), P_39),
            R2_10 = parseTerm(P_40),
            Rhs_10 = maps:get("v", R2_10),
            P_41 = maps:get("p", R2_10),
            V_17 = (V_16 - Rhs_10),
            throw({continue, P_41, R_10, V_17}),
            P_42 = P_41,
            R2_11 = R2_10,
            Rhs_11 = Rhs_10,
            V_18 = V_17;
        _ -> P_42 = P_39,
            R2_11 = R2_9,
            Rhs_11 = Rhs_9,
            V_18 = V_16
    end,
            Op_4 = Op_3,
            P_43 = P_42,
            R2_12 = R2_11,
            Rhs_12 = Rhs_11,
            V_19 = V_18;
        _ -> Op_4 = nil,
            P_43 = P_36,
            R2_12 = nil,
            Rhs_12 = nil,
            V_19 = V_14
    end,
                throw(break),
                Fun_7_loop(P_43, R_10, V_19)
            catch
                {continue, C0, C1, C2} -> Fun_7_loop(C0, C1, C2);
                break -> {P_35, R_10, V_14}
            end;
        _ -> {P_35, R_10, V_14}
    end
end,
{P_43, R_10, V_19} = Fun_7(P_35, R_10, V_14),
        #{"v" => V_19, "p" => P_43}
    catch {return, Ret} -> Ret end.

evalExpr(Expr) ->
    try
        P_44 = #{"expr" => Expr, "pos" => 0},
        R_11 = parseExpr(P_44),
        maps:get("v", R_11)
    catch {return, Ret} -> Ret end.

main() ->
    try
        Expr_2 = "2*(3-1)+2*5",
        io:format("~ts~n", [(("2*(3-1)+2*5" ++ " = ") ++ lists:flatten(io_lib:format("~p", [evalExpr("2*(3-1)+2*5")])))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    main().
