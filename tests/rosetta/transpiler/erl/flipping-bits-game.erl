#!/usr/bin/env escript
-module(main).
-compile([nowarn_shadow_vars, nowarn_unused_vars]).
-export([main/1, randint/2, newboard/2, copyboard/1, fliprow/2, flipcol/2, boardsequal/2, shuffleboard/2, solve/2, applysolution/2, printboard/1, main/0]).

% Generated by Mochi transpiler v0.10.55 (67b72aa5ea) on 2025-08-02 22:23 +0700


mochi_now() ->
    case erlang:get(now_seed) of
        undefined ->
            case os:getenv("MOCHI_NOW_SEED") of
                false -> erlang:system_time(nanosecond);
                S ->
                    case catch list_to_integer(S) of
                        {'EXIT', _} -> erlang:system_time(nanosecond);
                        Seed ->
                            erlang:put(now_seed, Seed),
                            mochi_now()
                    end
            end;
        Seed ->
            Seed2 = (Seed * 1664525 + 1013904223) rem 2147483647,
            erlang:put(now_seed, Seed2),
            Seed2
    end.


mochi_to_int(V) ->
    case erlang:is_integer(V) of
        true -> V;
        _ -> case erlang:is_float(V) of
            true -> trunc(V);
            _ -> list_to_integer(V)
        end
    end.


mochi_not(X) ->
    case X of
        true -> false;
        false -> true;
        nil -> true;
        _ -> false
    end.

randint(Seed, N) ->
    try
        Next = (((Seed * 1664525) + 1013904223) rem 2147483647),
        [Next, (Next rem N)]
    catch {return, Ret} -> Ret end.

newboard(N_2, Seed_2) ->
    try
        Board = [],
        S = Seed_2,
        I = 0,
        Fun_2 = fun Fun_2_loop(Board, I, N_2, S, Seed_2) ->
    case (I < N_2) of
        true ->
            Row = [],
            J = 0,
            Fun = fun Fun_loop(Board, I, J, N_2, Row, S, Seed_2) ->
    case (J < N_2) of
        true ->
            R = randint(S, 2),
            S_2 = (case erlang:is_map(R) of true -> maps:get(0, R, nil); _ -> lists:nth(0 + 1, R) end),
            Row_2 = lists:append(Row, [(case erlang:is_map(R) of true -> maps:get(1, R, nil); _ -> lists:nth(1 + 1, R) end)]),
            J_2 = (J + 1),
            Fun_loop(Board, I, J_2, N_2, Row_2, S_2, Seed_2);
        _ -> {Board, I, J, N_2, Row, S, Seed_2}
    end
end,
{Board, I, J_2, N_2, Row_2, S_2, Seed_2} = Fun(Board, I, J, N_2, Row, S, Seed_2),
            Board_2 = lists:append(Board, [Row_2]),
            I_2 = (I + 1),
            Fun_2_loop(Board_2, I_2, N_2, S_2, Seed_2);
        _ -> {Board, I, N_2, S, Seed_2}
    end
end,
{Board_2, I_2, N_2, S_2, Seed_2} = Fun_2(Board, I, N_2, S, Seed_2),
        [Board_2, S_2]
    catch {return, Ret} -> Ret end.

copyboard(B) ->
    try
        Nb = [],
        I_3 = 0,
        Fun_4 = fun Fun_4_loop(B, I_3, Nb) ->
    case (I_3 < length(B)) of
        true ->
            Row_3 = [],
            J_3 = 0,
            Fun_3 = fun Fun_3_loop(B, I_3, J_3, Nb, Row_3) ->
    case (J_3 < length((case erlang:is_map(B) of true -> maps:get(I_3, B, nil); _ -> lists:nth(I_3 + 1, B) end))) of
        true ->
            Row_4 = lists:append(Row_3, [(case erlang:is_map((case erlang:is_map(B) of true -> maps:get(I_3, B, nil); _ -> lists:nth(I_3 + 1, B) end)) of true -> maps:get(J_3, (case erlang:is_map(B) of true -> maps:get(I_3, B, nil); _ -> lists:nth(I_3 + 1, B) end), nil); _ -> lists:nth(J_3 + 1, (case erlang:is_map(B) of true -> maps:get(I_3, B, nil); _ -> lists:nth(I_3 + 1, B) end)) end)]),
            J_4 = (J_3 + 1),
            Fun_3_loop(B, I_3, J_4, Nb, Row_4);
        _ -> {B, I_3, J_3, Nb, Row_3}
    end
end,
{B, I_3, J_4, Nb, Row_4} = Fun_3(B, I_3, J_3, Nb, Row_3),
            Nb_2 = lists:append(Nb, [Row_4]),
            I_4 = (I_3 + 1),
            Fun_4_loop(B, I_4, Nb_2);
        _ -> {B, I_3, Nb}
    end
end,
{B, I_4, Nb_2} = Fun_4(B, I_3, Nb),
        Nb_2
    catch {return, Ret} -> Ret end.

fliprow(B_2, R_2) ->
    try
        J_5 = 0,
        Fun_5 = fun Fun_5_loop(B_2, J_5, R_2) ->
    case (J_5 < length((case erlang:is_map(B_2) of true -> maps:get(R_2, B_2, nil); _ -> lists:nth(R_2 + 1, B_2) end))) of
        true ->
            Tmp = (case erlang:is_map(B_2) of true -> maps:get(R_2, B_2, nil); _ -> lists:nth(R_2 + 1, B_2) end),
            Tmp_2 = lists:sublist(Tmp, J_5) ++ [(1 - (case erlang:is_map((case erlang:is_map(B_2) of true -> maps:get(R_2, B_2, nil); _ -> lists:nth(R_2 + 1, B_2) end)) of true -> maps:get(J_5, (case erlang:is_map(B_2) of true -> maps:get(R_2, B_2, nil); _ -> lists:nth(R_2 + 1, B_2) end), nil); _ -> lists:nth(J_5 + 1, (case erlang:is_map(B_2) of true -> maps:get(R_2, B_2, nil); _ -> lists:nth(R_2 + 1, B_2) end)) end))] ++ lists:nthtail(J_5 + 1, Tmp),
            B_3 = lists:sublist(B_2, R_2) ++ [Tmp_2] ++ lists:nthtail(R_2 + 1, B_2),
            J_6 = (J_5 + 1),
            Fun_5_loop(B_3, J_6, R_2);
        _ -> {B_2, J_5, R_2}
    end
end,
{B_3, J_6, R_2} = Fun_5(B_2, J_5, R_2),
        B_3
    catch {return, Ret} -> Ret end.

flipcol(B_4, C) ->
    try
        I_5 = 0,
        Fun_6 = fun Fun_6_loop(B_4, C, I_5) ->
    case (I_5 < length(B_4)) of
        true ->
            Tmp_3 = (case erlang:is_map(B_4) of true -> maps:get(I_5, B_4, nil); _ -> lists:nth(I_5 + 1, B_4) end),
            Tmp_4 = lists:sublist(Tmp_3, C) ++ [(1 - (case erlang:is_map((case erlang:is_map(B_4) of true -> maps:get(I_5, B_4, nil); _ -> lists:nth(I_5 + 1, B_4) end)) of true -> maps:get(C, (case erlang:is_map(B_4) of true -> maps:get(I_5, B_4, nil); _ -> lists:nth(I_5 + 1, B_4) end), nil); _ -> lists:nth(C + 1, (case erlang:is_map(B_4) of true -> maps:get(I_5, B_4, nil); _ -> lists:nth(I_5 + 1, B_4) end)) end))] ++ lists:nthtail(C + 1, Tmp_3),
            B_5 = lists:sublist(B_4, I_5) ++ [Tmp_4] ++ lists:nthtail(I_5 + 1, B_4),
            I_6 = (I_5 + 1),
            Fun_6_loop(B_5, C, I_6);
        _ -> {B_4, C, I_5}
    end
end,
{B_5, C, I_6} = Fun_6(B_4, C, I_5),
        B_5
    catch {return, Ret} -> Ret end.

boardsequal(A, B_6) ->
    try
        I_7 = 0,
        Fun_8 = fun Fun_8_loop(A, B_6, I_7) ->
    case (I_7 < length(A)) of
        true ->
            J_7 = 0,
            Fun_7 = fun Fun_7_loop(A, B_6, I_7, J_7) ->
    case (J_7 < length((case erlang:is_map(A) of true -> maps:get(I_7, A, nil); _ -> lists:nth(I_7 + 1, A) end))) of
        true ->
            case ((case erlang:is_map((case erlang:is_map(A) of true -> maps:get(I_7, A, nil); _ -> lists:nth(I_7 + 1, A) end)) of true -> maps:get(J_7, (case erlang:is_map(A) of true -> maps:get(I_7, A, nil); _ -> lists:nth(I_7 + 1, A) end), nil); _ -> lists:nth(J_7 + 1, (case erlang:is_map(A) of true -> maps:get(I_7, A, nil); _ -> lists:nth(I_7 + 1, A) end)) end) /= (case erlang:is_map((case erlang:is_map(B_6) of true -> maps:get(I_7, B_6, nil); _ -> lists:nth(I_7 + 1, B_6) end)) of true -> maps:get(J_7, (case erlang:is_map(B_6) of true -> maps:get(I_7, B_6, nil); _ -> lists:nth(I_7 + 1, B_6) end), nil); _ -> lists:nth(J_7 + 1, (case erlang:is_map(B_6) of true -> maps:get(I_7, B_6, nil); _ -> lists:nth(I_7 + 1, B_6) end)) end)) of
        true -> throw({return, false});
        _ -> ok
    end,
            J_8 = (J_7 + 1),
            Fun_7_loop(A, B_6, I_7, J_8);
        _ -> {A, B_6, I_7, J_7}
    end
end,
{A, B_6, I_7, J_8} = Fun_7(A, B_6, I_7, J_7),
            I_8 = (I_7 + 1),
            Fun_8_loop(A, B_6, I_8);
        _ -> {A, B_6, I_7}
    end
end,
{A, B_6, I_8} = Fun_8(A, B_6, I_7),
        true
    catch {return, Ret} -> Ret end.

shuffleboard(B_7, Seed_3) ->
    try
        S_3 = Seed_3,
        N_3 = length(B_7),
        K = 0,
        Fun_9 = fun Fun_9_loop(B_7, K, N_3, S_3, Seed_3) ->
    case (K < (2 * N_3)) of
        true ->
            R_3 = randint(S_3, N_3),
            S_4 = (case erlang:is_map(R_3) of true -> maps:get(0, R_3, nil); _ -> lists:nth(0 + 1, R_3) end),
            Idx = mochi_to_int((case erlang:is_map(R_3) of true -> maps:get(1, R_3, nil); _ -> lists:nth(1 + 1, R_3) end)),
            case ((K rem 2) == 0) of
        true -> B_8 = fliprow(B_7, Idx),
            B_10 = B_8;
        _ -> B_9 = flipcol(B_7, Idx),
            B_10 = B_9
    end,
            K_2 = (K + 1),
            Fun_9_loop(B_10, K_2, N_3, S_4, Seed_3);
        _ -> {B_7, K, N_3, S_3, Seed_3}
    end
end,
{B_10, K_2, N_3, S_4, Seed_3} = Fun_9(B_7, K, N_3, S_3, Seed_3),
        [B_10, S_4]
    catch {return, Ret} -> Ret end.

solve(Board_3, Target) ->
    try
        N_4 = length(Board_3),
        Row_5 = [],
        Col = [],
        I_9 = 0,
        Fun_10 = fun Fun_10_loop(Board_3, Col, I_9, N_4, Row_5, Target) ->
    case (I_9 < N_4) of
        true ->
            Diff = (case ((case erlang:is_map((case erlang:is_map(Board_3) of true -> maps:get(I_9, Board_3, nil); _ -> lists:nth(I_9 + 1, Board_3) end)) of true -> maps:get(0, (case erlang:is_map(Board_3) of true -> maps:get(I_9, Board_3, nil); _ -> lists:nth(I_9 + 1, Board_3) end), nil); _ -> lists:nth(0 + 1, (case erlang:is_map(Board_3) of true -> maps:get(I_9, Board_3, nil); _ -> lists:nth(I_9 + 1, Board_3) end)) end) /= (case erlang:is_map((case erlang:is_map(Target) of true -> maps:get(I_9, Target, nil); _ -> lists:nth(I_9 + 1, Target) end)) of true -> maps:get(0, (case erlang:is_map(Target) of true -> maps:get(I_9, Target, nil); _ -> lists:nth(I_9 + 1, Target) end), nil); _ -> lists:nth(0 + 1, (case erlang:is_map(Target) of true -> maps:get(I_9, Target, nil); _ -> lists:nth(I_9 + 1, Target) end)) end)) of
    true -> 1;
    _ -> 0
end),
            Row_6 = lists:append(Row_5, [Diff]),
            I_10 = (I_9 + 1),
            Fun_10_loop(Board_3, Col, I_10, N_4, Row_6, Target);
        _ -> {Board_3, Col, I_9, N_4, Row_5, Target}
    end
end,
{Board_3, Col, I_10, N_4, Row_6, Target} = Fun_10(Board_3, Col, I_9, N_4, Row_5, Target),
        J_9 = 0,
        Fun_11 = fun Fun_11_loop(Board_3, Col, I_10, J_9, N_4, Row_6, Target) ->
    case (J_9 < N_4) of
        true ->
            Diff_2 = (case ((case erlang:is_map((case erlang:is_map(Board_3) of true -> maps:get(0, Board_3, nil); _ -> lists:nth(0 + 1, Board_3) end)) of true -> maps:get(J_9, (case erlang:is_map(Board_3) of true -> maps:get(0, Board_3, nil); _ -> lists:nth(0 + 1, Board_3) end), nil); _ -> lists:nth(J_9 + 1, (case erlang:is_map(Board_3) of true -> maps:get(0, Board_3, nil); _ -> lists:nth(0 + 1, Board_3) end)) end) /= (case erlang:is_map((case erlang:is_map(Target) of true -> maps:get(0, Target, nil); _ -> lists:nth(0 + 1, Target) end)) of true -> maps:get(J_9, (case erlang:is_map(Target) of true -> maps:get(0, Target, nil); _ -> lists:nth(0 + 1, Target) end), nil); _ -> lists:nth(J_9 + 1, (case erlang:is_map(Target) of true -> maps:get(0, Target, nil); _ -> lists:nth(0 + 1, Target) end)) end)) of
    true -> 1;
    _ -> 0
end),
            Val = ((Diff_2 + (case erlang:is_map(Row_6) of true -> maps:get(0, Row_6, nil); _ -> lists:nth(0 + 1, Row_6) end)) rem 2),
            Col_2 = lists:append(Col, [Val]),
            J_10 = (J_9 + 1),
            Fun_11_loop(Board_3, Col_2, I_10, J_10, N_4, Row_6, Target);
        _ -> {Board_3, Col, I_10, J_9, N_4, Row_6, Target}
    end
end,
{Board_3, Col_2, I_10, J_10, N_4, Row_6, Target} = Fun_11(Board_3, Col, I_10, J_9, N_4, Row_6, Target),
        #{"row" => Row_6, "col" => Col_2}
    catch {return, Ret} -> Ret end.

applysolution(B_11, Sol) ->
    try
        Board_4 = B_11,
        Moves = 0,
        I_11 = 0,
        Fun_12 = fun Fun_12_loop(B_11, Board_4, I_11, Moves, Sol) ->
    case (I_11 < length(maps:get("row", Sol, nil))) of
        true ->
            case ((case erlang:is_map(maps:get("row", Sol, nil)) of true -> maps:get(I_11, maps:get("row", Sol, nil), nil); _ -> lists:nth(I_11 + 1, maps:get("row", Sol, nil)) end) == 1) of
        true -> Board_5 = fliprow(Board_4, I_11),
            Moves_2 = (Moves + 1),
            Board_6 = Board_5,
            Moves_3 = Moves_2;
        _ -> Board_6 = Board_4,
            Moves_3 = Moves
    end,
            I_12 = (I_11 + 1),
            Fun_12_loop(B_11, Board_6, I_12, Moves_3, Sol);
        _ -> {B_11, Board_4, I_11, Moves, Sol}
    end
end,
{B_11, Board_6, I_12, Moves_3, Sol} = Fun_12(B_11, Board_4, I_11, Moves, Sol),
        J_11 = 0,
        Fun_13 = fun Fun_13_loop(B_11, Board_6, I_12, J_11, Moves_3, Sol) ->
    case (J_11 < length(maps:get("col", Sol, nil))) of
        true ->
            case ((case erlang:is_map(maps:get("col", Sol, nil)) of true -> maps:get(J_11, maps:get("col", Sol, nil), nil); _ -> lists:nth(J_11 + 1, maps:get("col", Sol, nil)) end) == 1) of
        true -> Board_7 = flipcol(Board_6, J_11),
            Moves_4 = (Moves_3 + 1),
            Board_8 = Board_7,
            Moves_5 = Moves_4;
        _ -> Board_8 = Board_6,
            Moves_5 = Moves_3
    end,
            J_12 = (J_11 + 1),
            Fun_13_loop(B_11, Board_8, I_12, J_12, Moves_5, Sol);
        _ -> {B_11, Board_6, I_12, J_11, Moves_3, Sol}
    end
end,
{B_11, Board_8, I_12, J_12, Moves_5, Sol} = Fun_13(B_11, Board_6, I_12, J_11, Moves_3, Sol),
        [Board_8, Moves_5]
    catch {return, Ret} -> Ret end.

printboard(B_12) ->
    try
        I_13 = 0,
        Fun_15 = fun Fun_15_loop(B_12, I_13) ->
    case (I_13 < length(B_12)) of
        true ->
            Line = "",
            J_13 = 0,
            Fun_14 = fun Fun_14_loop(B_12, I_13, J_13, Line) ->
    case (J_13 < length((case erlang:is_map(B_12) of true -> maps:get(I_13, B_12, nil); _ -> lists:nth(I_13 + 1, B_12) end))) of
        true ->
            Line_2 = (Line ++ lists:flatten(io_lib:format("~p", [(case erlang:is_map((case erlang:is_map(B_12) of true -> maps:get(I_13, B_12, nil); _ -> lists:nth(I_13 + 1, B_12) end)) of true -> maps:get(J_13, (case erlang:is_map(B_12) of true -> maps:get(I_13, B_12, nil); _ -> lists:nth(I_13 + 1, B_12) end), nil); _ -> lists:nth(J_13 + 1, (case erlang:is_map(B_12) of true -> maps:get(I_13, B_12, nil); _ -> lists:nth(I_13 + 1, B_12) end)) end)]))),
            case (J_13 < (length((case erlang:is_map(B_12) of true -> maps:get(I_13, B_12, nil); _ -> lists:nth(I_13 + 1, B_12) end)) - 1)) of
        true -> Line_3 = (Line_2 ++ " "),
            Line_4 = Line_3;
        _ -> Line_4 = Line_2
    end,
            J_14 = (J_13 + 1),
            Fun_14_loop(B_12, I_13, J_14, Line_4);
        _ -> {B_12, I_13, J_13, Line}
    end
end,
{B_12, I_13, J_14, Line_4} = Fun_14(B_12, I_13, J_13, Line),
            io:format("~ts~n", [Line_4]),
            I_14 = (I_13 + 1),
            Fun_15_loop(B_12, I_14);
        _ -> {B_12, I_13}
    end
end,
{B_12, I_14} = Fun_15(B_12, I_13),
        nil
    catch {return, Ret} -> Ret end.

main() ->
    try
        N_5 = 3,
        Seed_4 = 1,
        Res = newboard(3, Seed_4),
        Target_2 = (case erlang:is_map(Res) of true -> maps:get(0, Res, nil); _ -> lists:nth(0 + 1, Res) end),
        Seed_5 = mochi_to_int((case erlang:is_map(Res) of true -> maps:get(1, Res, nil); _ -> lists:nth(1 + 1, Res) end)),
        Board_9 = copyboard(Target_2),
        Fun_16 = fun Fun_16_loop(Board_9, N_5, Res, Seed_5, Target_2) ->
    case true of
        true ->
            try
                Sres = shuffleboard(copyboard(Board_9), Seed_5),
                Board_10 = (case erlang:is_map(Sres) of true -> maps:get(0, Sres, nil); _ -> lists:nth(0 + 1, Sres) end),
                Seed_6 = mochi_to_int((case erlang:is_map(Sres) of true -> maps:get(1, Sres, nil); _ -> lists:nth(1 + 1, Sres) end)),
                case mochi_not(boardsequal(Board_10, Target_2)) of
        true -> throw(break);
        _ -> ok
    end,
                Fun_16_loop(Board_10, N_5, Res, Seed_6, Target_2)
            catch
                {continue, C0, C1, C2, C3, C4} -> Fun_16_loop(C0, C1, C2, C3, C4);
                break -> {Board_9, N_5, Res, Seed_5, Target_2}
            end;
        _ -> {Board_9, N_5, Res, Seed_5, Target_2}
    end
end,
{Board_10, N_5, Res, Seed_6, Target_2} = Fun_16(Board_9, N_5, Res, Seed_5, Target_2),
        io:format("~ts~n", ["Target:"]),
        printboard(Target_2),
        io:format("~ts~n", ["Board:"]),
        printboard(Board_10),
        Sol_2 = solve(Board_10, Target_2),
        Ares = applysolution(Board_10, Sol_2),
        Board_11 = (case erlang:is_map(Ares) of true -> maps:get(0, Ares, nil); _ -> lists:nth(0 + 1, Ares) end),
        Moves_6 = mochi_to_int((case erlang:is_map(Ares) of true -> maps:get(1, Ares, nil); _ -> lists:nth(1 + 1, Ares) end)),
        io:format("~ts~n", ["Solved:"]),
        printboard(Board_11),
        io:format("~ts~n", [("Moves: " ++ lists:flatten(io_lib:format("~p", [Moves_6])))]),
        nil
    catch {return, Ret} -> Ret end.

main(_) ->
    BenchStart = mochi_now(),
    BenchStartMem = erlang:memory(total),
    main(),
    BenchEnd = mochi_now(),
    BenchEndMem = erlang:memory(total),
    DurationUs = (BenchEnd - BenchStart) div 1000,
    MemBytes = erlang:abs(BenchEndMem - BenchStartMem),
    io:format("{~n  \"duration_us\": ~p,~n  \"memory_bytes\": ~p,~n  \"name\": \"main\"~n}
", [DurationUs, MemBytes]).
