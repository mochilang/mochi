// Generated by Mochi 0.10.32 on 2025-07-25 17:17 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>

size_t bigTrim_len;
size_t bigFromInt_len;
size_t bigAdd_len;
size_t bigSub_len;
size_t cumu_len;
size_t row_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(int v) {
    if(v==0) return strdup("false");
    if(v==1) return strdup("true");
    char buf[32];
    snprintf(buf, sizeof(buf), "%d", v);
    return strdup(buf);
}

static int* list_append_int(int *arr, size_t *len, int val) {
    arr = realloc(arr, (*len + 1) * sizeof(int));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    struct mallinfo mi = mallinfo();
    return (long long)mi.uordblks;
}

int x = 1;

int * bigTrim(int * a, size_t a_len) {
    size_t n = a_len;
    while ((n > 1) && (a[n - 1] == 0)) {
        a = a;
        n = n - 1;
    }
    return bigTrim_len = a_len, a;
}

int * bigFromInt(int x) {
    if (x == 0) {
        return (int[]){ 0 };
    }
    int *digits = NULL;
    size_t digits_len = 0;
    int n = x;
    while (n > 0) {
        digits = list_append_int(digits, &digits_len, n % 10);
        n = n / 10;
    }
    return bigFromInt_len = digits_len, digits;
}

int * bigAdd(int * a, size_t a_len, int * b, size_t b_len) {
    int *res = NULL;
    size_t res_len = 0;
    int carry = 0;
    int i = 0;
    while (((i < a_len) || (i < b_len)) || (carry > 0)) {
        int av = 0;
        if (i < a_len) {
            av = a[i];
        }
        int bv = 0;
        if (i < b_len) {
            bv = b[i];
        }
        int s = (av + bv) + carry;
        res = list_append_int(res, &res_len, s % 10);
        carry = s / 10;
        i = i + 1;
    }
    return bigAdd_len = bigTrim_len, bigTrim(res, res_len);
}

int * bigSub(int * a, size_t a_len, int * b, size_t b_len) {
    int *res = NULL;
    size_t res_len = 0;
    int borrow = 0;
    int i = 0;
    while (i < a_len) {
        int av = a[i];
        int bv = 0;
        if (i < b_len) {
            bv = b[i];
        }
        int diff = (av - bv) - borrow;
        if (diff < 0) {
            diff = diff + 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        res = list_append_int(res, &res_len, diff);
        i = i + 1;
    }
    return bigSub_len = bigTrim_len, bigTrim(res, res_len);
}

const char* bigToString(int * a, size_t a_len) {
    const char* s = "";
    int i = a_len - 1;
    while (i >= 0) {
        s = str_concat(s, str_int(a[i]));
        i = i - 1;
    }
    return s;
}

int minInt(int a, int b) {
    if (a < b) {
        return a;
    } else {
        return b;
    }
}

int * * cumu(int n) {
    int[] **cache = NULL;
    size_t cache_len = 0;
    int y = 1;
    while (y <= n) {
        int **row = NULL;
        size_t row_len = 0;
        int x = 1;
        while (x <= y) {
            int *val = cache[y - x][minInt(x, y - x)];
            row = list_append_intptr(row, &row_len, bigAdd(row[row_len - 1], 0, val, val_len));
            x = x + 1;
        }
        cache = list_append_intptr(cache, &cache_len, row);
        y = y + 1;
    }
    return cache[n];
}

const char* * row(int n) {
    int **e = cumu(n);
    size_t e_len = cumu_len;
    const char* *out = NULL;
    size_t out_len = 0;
    int i = 0;
    while (i < n) {
        int *diff = bigSub(e[i + 1], 0, e[i], 0);
        size_t diff_len = bigSub_len;
        out = list_append_str(out, &out_len, bigToString(diff, diff_len));
        i = i + 1;
    }
    return row_len = out_len, out;
}

int main(void) {
    {
        long long __start = _now();
        long long __mem_start = _mem();
        puts("rows:");
        while (x < 11) {
            const char* *r = row(x);
            size_t r_len = row_len;
            const char* line = "";
            int i = 0;
            while (i < 1) {
                line = str_concat(str_concat(str_concat(line, " "), r[i]), " ");
                i = i + 1;
            }
            puts(line);
            x = x + 1;
        }
        puts("");
        puts("sums:");
        {
            int num_arr[] = {23, 123, 1234};
            size_t num_len = sizeof(num_arr) / sizeof(num_arr[0]);
            for (size_t i = 0; i < num_len; i++) {
                int num = num_arr[i];
                int **r = cumu(num);
                size_t r_len = cumu_len;
                puts(str_concat(str_concat(str_int(num), " "), bigToString(r[r_len - 1], 0)));
            }
        }
        long long __end = _now();
        long long __mem_end = _mem();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = __mem_end - __mem_start;
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
