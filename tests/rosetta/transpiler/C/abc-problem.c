// Generated by Mochi 0.10.32 on 2025-07-24 21:16 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

size_t fields_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(int v) {
    if(v==0) return strdup("false");
    if(v==1) return strdup("true");
    char buf[32];
    snprintf(buf, sizeof(buf), "%d", v);
    return strdup(buf);
}

static char* str_lower(const char *s) {
    size_t n = strlen(s);
    char *out = strdup(s);
    for(size_t i=0;i<n;i++) out[i] = tolower((unsigned char)out[i]);
    return out;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct NewSpellerClosure NewSpellerClosure;

struct NewSpellerClosure {
    const char** bl;
    size_t bl_len;
};

const char* * fields(const char* s) {
    const char* *res = NULL;
    size_t res_len = 0;
    const char* cur = "";
    int i = 0;
    while (i < strlen(s)) {
        const char* c = _substring(s, i, i + 1);
        if (strcmp(c, " ") == 0) {
            if (strlen(cur) > 0) {
                res = list_append_str(res, &res_len, cur);
                cur = "";
            }
        } else {
            cur = str_concat(cur, c);
        }
        i = i + 1;
    }
    if (strlen(cur) > 0) {
        res = list_append_str(res, &res_len, cur);
    }
    return fields_len = res_len, res;
}

int canSpell(const char* word, const char* * blks, size_t blks_len) {
    if (strlen(word) == 0) {
        return 1;
    }
    const char* c = str_lower(_substring(word, 0, 1));
    int i = 0;
    while (i < blks_len) {
        const char* b = blks[i];
        if ((strcmp(c, str_lower(_substring(b, 0, 1))) == 0) || (strcmp(c, str_lower(_substring(b, 1, 2))) == 0)) {
            const char* *rest = NULL;
            size_t rest_len = 0;
            int j = 0;
            while (j < blks_len) {
                if (j != i) {
                    rest = list_append_str(rest, &rest_len, blks[j]);
                }
                j = j + 1;
            }
            if (canSpell(_substring(word, 1, strlen(word)), rest, rest_len)) {
                return 1;
            }
        }
        i = i + 1;
    }
    return 0;
}

NewSpellerClosure newSpeller(const char* blocks) {
    const char* *bl = fields(blocks);
    size_t bl_len = fields_len;
    return (NewSpellerClosure){.bl = bl, .bl_len = bl_len};
}

int NewSpellerClosure_call(const char* * bl, size_t bl_len, const char* w) {
    return canSpell(w, bl, bl_len);
}

int user_main() {
    NewSpellerClosure sp = newSpeller("BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM");
    {
        const char* word_arr[] = {"A", "BARK", "BOOK", "TREAT", "COMMON", "SQUAD", "CONFUSE"};
        size_t word_len = sizeof(word_arr) / sizeof(word_arr[0]);
        for (size_t i = 0; i < word_len; i++) {
            const char* word = word_arr[i];
            puts(str_concat(str_concat(word, " "), str_int(NewSpellerClosure_call(sp.bl, sp.bl_len, word))));
        }
    }
}

int main(void) {
    user_main();
    return 0;
}
