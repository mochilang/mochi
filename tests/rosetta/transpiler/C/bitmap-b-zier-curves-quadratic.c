// Generated by Mochi 0.10.32 on 2025-07-27 18:13 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>


typedef struct { const char **keys; const char **vals; size_t len; } MapSS;

static const char* map_get_ss(const char *keys[], const char *vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return "";
}

static int* list_append_int(int *arr, size_t *len, int val) {
    arr = realloc(arr, (*len + 1) * sizeof(int));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int* list_append_int_new(const int *arr, size_t len, int val) {
    int *res = malloc((len + 1) * sizeof(int));
    if (arr && len) memcpy(res, arr, len * sizeof(int));
    res[len] = val;
    return res;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char*** list_append_strptr(const char ***arr, size_t *len, const char **val) {
    arr = realloc(arr, (*len + 1) * sizeof(const char**));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    struct mallinfo mi = mallinfo();
    return (long long)mi.uordblks;
}

typedef struct Anon1 Anon1;
typedef struct Pixel Pixel;

struct Anon1 {
    int cols;
    int rows;
    int data;
};

struct Pixel {
    int r;
    int g;
    int b;
};

int b2Seg = 20;

Pixel pixelFromRgb(int rgb);
Anon1 newBitmap(int cols, int rows);
int setPx(MapSS b, int x, int y, Pixel p);
int fill(MapSS b, Pixel p);
int fillRgb(MapSS b, int rgb);
int line(MapSS b, int x0, int y0, int x1, int y1, Pixel p);
int bezier2(MapSS b, int x1, int y1, int x2, int y2, int x3, int y3, Pixel p);
int main(void);

Pixel pixelFromRgb(int rgb) {
    int r = (rgb / 65536) % 256;
    int g = (rgb / 256) % 256;
    int b = rgb % 256;
    return (Pixel){.r = r, .g = g, .b = b};
}

Anon1 newBitmap(int cols, int rows) {
    Pixel **d = NULL;
    size_t d_len = 0;
    size_t *d_lens = NULL;
    size_t d_lens_len = 0;
    int y = 0;
    while (y < rows) {
        Pixel *row = NULL;
        size_t row_len = 0;
        int x = 0;
        while (x < cols) {
                        row = list_append_int_new(row, row_len, (Pixel){.r = 0, .g = 0, .b = 0});
            x = x + 1;
        }
        d = list_append_strptr(d, &d_len, row);
        d_lens = list_append_szt(d_lens, &d_lens_len, row_len);
        y = y + 1;
    }
    return (Anon1){.cols = cols, .rows = rows, .data = d};
}

int setPx(MapSS b, int x, int y, Pixel p) {
    int cols = b.cols;
    int rows = b.rows;
    if ((((x >= 0) && (x < cols)) && (y >= 0)) && (y < rows)) {
        b["data"][y][x] = p;
    }
}

int fill(MapSS b, Pixel p) {
    int cols = b.cols;
    int rows = b.rows;
    int y = 0;
    while (y < rows) {
        int x = 0;
        while (x < cols) {
            b["data"][y][x] = p;
            x = x + 1;
        }
        y = y + 1;
    }
}

int fillRgb(MapSS b, int rgb) {
    fill(b, pixelFromRgb(rgb));
}

int line(MapSS b, int x0, int y0, int x1, int y1, Pixel p) {
    int dx = x1 - x0;
    if (dx < 0) {
        dx = -(dx);
    }
    int dy = y1 - y0;
    if (dy < 0) {
        dy = -(dy);
    }
    int sx = -1;
    if (x0 < x1) {
        sx = 1;
    }
    int sy = -1;
    if (y0 < y1) {
        sy = 1;
    }
    int err = dx - dy;
    while (1) {
        setPx(b, x0, y0, p);
        if ((x0 == x1) && (y0 == y1)) {
            break;
        }
        int e2 = 2 * err;
        if (e2 > (0 - dy)) {
            err = err - dy;
            x0 = x0 + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
    }
}

int bezier2(MapSS b, int x1, int y1, int x2, int y2, int x3, int y3, Pixel p) {
    int *px = NULL;
    size_t px_len = 0;
    int *py = NULL;
    size_t py_len = 0;
    int i = 0;
    while (i <= b2Seg) {
        px = list_append_int(px, &px_len, 0);
        py = list_append_int(py, &py_len, 0);
        i = i + 1;
    }
    double fx1 = (double)(x1);
    double fy1 = (double)(y1);
    double fx2 = (double)(x2);
    double fy2 = (double)(y2);
    double fx3 = (double)(x3);
    double fy3 = (double)(y3);
    i = 0;
    while (i <= b2Seg) {
        int c = (double)(i) / (double)(b2Seg);
        double a = 1 - c;
        double a2 = a * a;
        double b2 = (2 * c) * a;
        int c2 = c * c;
        px[i] = ((a2 * fx1) + (b2 * fx2)) + (c2 * fx3);
        py[i] = ((a2 * fy1) + (b2 * fy2)) + (c2 * fy3);
        i = i + 1;
    }
    int x0 = px[0];
    int y0 = py[0];
    i = 1;
    while (i <= b2Seg) {
        int x = px[i];
        int y = py[i];
        line(b, x0, y0, x, y, p);
        x0 = x;
        y0 = y;
        i = i + 1;
    }
}

int main(void) {
    {
        long long __start = _now();
        long long __mem_start = _mem();
        Anon1 b = newBitmap(400, 300);
        fillRgb(b, 14614575);
        bezier2(b, 20, 150, 500, -100, 300, 280, pixelFromRgb(4165615));
        long long __end = _now();
        long long __mem_end = _mem();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = __mem_end - __mem_start;
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
