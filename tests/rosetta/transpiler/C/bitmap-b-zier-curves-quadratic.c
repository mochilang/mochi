// Generated by Mochi 0.10.32 on 2025-08-03 16:20 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <math.h>


typedef struct { const char **keys; const char **vals; size_t len; } MapSS;

static const char* map_get_ss(const char *keys[], const char *vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return "";
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

typedef struct Anon1 Anon1;
typedef struct Pixel Pixel;

struct Anon1 {
    int cols;
    int rows;
    Pixel **data;
    size_t data_len;
    size_t *data_lens;
    size_t data_lens_len;
};

struct Pixel {
    long long r;
    long long g;
    long long b;
};

static Pixel* list_append_Pixel(Pixel *arr, size_t *len, Pixel val) {
    arr = realloc(arr, (*len + 1) * sizeof(Pixel));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static Pixel** list_append_Pixelptr(Pixel **arr, size_t *len, Pixel *val) {
    arr = realloc(arr, (*len + 1) * sizeof(Pixel*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long b2Seg = 20LL;
Anon1 b;

Pixel pixelFromRgb(long long rgb);
Anon1 newBitmap(long long cols, long long rows);
void setPx(Anon1 b, long long x, long long y, Pixel p);
void fill(Anon1 b, Pixel p);
void fillRgb(Anon1 b, long long rgb);
void line(Anon1 b, long long x0, long long y0, long long x1, long long y1, Pixel p);
void bezier2(Anon1 b, long long x1, long long y1, long long x2, long long y2, long long x3, long long y3, Pixel p);
int main(void);

Pixel pixelFromRgb(long long rgb) {
    int r = (rgb / 65536LL) % 256LL;
    int g = (rgb / 256LL) % 256LL;
    int b = rgb % 256LL;
    return (Pixel){.r = r, .g = g, .b = b};
}

Anon1 newBitmap(long long cols, long long rows) {
    Pixel **d = NULL;
    size_t d_len = 0;
    size_t *d_lens = NULL;
    size_t d_lens_len = 0;
    int y = 0LL;
    while (y < rows) {
        Pixel *row = NULL;
        size_t row_len = 0;
        int x = 0LL;
        while (x < cols) {
            row = list_append_Pixel(row, &row_len, (Pixel){.r = 0LL, .g = 0LL, .b = 0LL});
            x = x + 1LL;
        }
        d = list_append_Pixelptr(d, &d_len, row);
        d_lens = list_append_szt(d_lens, &d_lens_len, row_len);
        y = y + 1LL;
    }
    return (Anon1){.cols = cols, .rows = rows, .data = d, .data_len = d_len};
}

void setPx(Anon1 b, long long x, long long y, Pixel p) {
    int cols = b.cols;
    int rows = b.rows;
    if ((((x >= 0LL) && (x < cols)) && (y >= 0LL)) && (y < rows)) {
        b.data[(int)(y)][(int)(x)] = p;
    }
}

void fill(Anon1 b, Pixel p) {
    int cols = b.cols;
    int rows = b.rows;
    int y = 0LL;
    while (y < rows) {
        int x = 0LL;
        while (x < cols) {
            b.data[(int)(y)][(int)(x)] = p;
            x = x + 1LL;
        }
        y = y + 1LL;
    }
}

void fillRgb(Anon1 b, long long rgb) {
    fill(b, pixelFromRgb(rgb));
}

void line(Anon1 b, long long x0, long long y0, long long x1, long long y1, Pixel p) {
    int dx = x1 - x0;
    if (dx < 0LL) {
        dx = -(dx);
    }
    int dy = y1 - y0;
    if (dy < 0LL) {
        dy = -(dy);
    }
    int sx = -1LL;
    if (x0 < x1) {
        sx = 1LL;
    }
    int sy = -1LL;
    if (y0 < y1) {
        sy = 1LL;
    }
    int err = dx - dy;
    while (1LL) {
        setPx(b, x0, y0, p);
        if ((x0 == x1) && (y0 == y1)) {
            break;
        }
        int e2 = 2LL * err;
        if (e2 > (0LL - dy)) {
            err = err - dy;
            x0 = x0 + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
    }
}

void bezier2(Anon1 b, long long x1, long long y1, long long x2, long long y2, long long x3, long long y3, Pixel p) {
    long long *px = NULL;
    size_t px_len = 0;
    long long *py = NULL;
    size_t py_len = 0;
    int i = 0LL;
    while (i <= b2Seg) {
        px = list_append_long_long(px, &px_len, 0LL);
        py = list_append_long_long(py, &py_len, 0LL);
        i = i + 1LL;
    }
    double fx1 = (double)(x1);
    double fy1 = (double)(y1);
    double fx2 = (double)(x2);
    double fy2 = (double)(y2);
    double fx3 = (double)(x3);
    double fy3 = (double)(y3);
    i = 0LL;
    while (i <= b2Seg) {
        double c = (double)(i) / (double)(b2Seg);
        double a = 1.0 - c;
        double a2 = a * a;
        double b2 = (2.0 * c) * a;
        double c2 = c * c;
        px[(int)(i)] = ((a2 * fx1) + (b2 * fx2)) + (c2 * fx3);
        py[(int)(i)] = ((a2 * fy1) + (b2 * fy2)) + (c2 * fy3);
        i = i + 1LL;
    }
    long long x0 = px[(int)(0LL)];
    long long y0 = py[(int)(0LL)];
    i = 1LL;
    while (i <= b2Seg) {
        long long x = px[(int)(i)];
        long long y = py[(int)(i)];
        line(b, x0, y0, x, y, p);
        x0 = x;
        y0 = y;
        i = i + 1LL;
    }
}

int main(void) {
    {
        long long __start = _now();
        b = newBitmap(400LL, 300LL);
        fillRgb(b, 14614575LL);
        bezier2(b, 20LL, 150LL, 500LL, -100LL, 300LL, 280LL, pixelFromRgb(4165615LL));
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
