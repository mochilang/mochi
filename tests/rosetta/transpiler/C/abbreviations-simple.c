// Generated by Mochi 0.10.32 on 2025-07-24 13:03 +0000
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

size_t fields_len;
size_t validate_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_upper(const char *s) {
    size_t n = strlen(s);
    char *out = strdup(s);
    for(size_t i=0;i<n;i++) out[i] = toupper((unsigned char)out[i]);
    return out;
}

static int map_get_si(const char *keys[], const int vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

static int* list_append_int(int *arr, size_t *len, int val) {
    arr = realloc(arr, (*len + 1) * sizeof(int));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct Anon1 Anon1;

struct Anon1 {
    const char** commands;
    size_t commands_len;
    int* mins;
    size_t mins_len;
};

const char* * fields(const char* s) {
    const char* *words = NULL;
    size_t words_len = 0;
    const char* cur = "";
    int i = 0;
    while (i < strlen(s)) {
        const char* ch = _substring(s, i, i + 1);
        if (((strcmp(ch, " ") == 0) || (strcmp(ch, "\n") == 0)) || (strcmp(ch, "\t") == 0)) {
            if (strlen(cur) > 0) {
                words = list_append_str(words, &words_len, cur);
                cur = "";
            }
        } else {
            cur = str_concat(cur, ch);
        }
        i = i + 1;
    }
    if (strlen(cur) > 0) {
        words = list_append_str(words, &words_len, cur);
    }
    return fields_len = words_len, words;
}

const char* padRight(const char* s, int width) {
    const char* out = s;
    int i = strlen(s);
    while (i < width) {
        out = str_concat(out, " ");
        i = i + 1;
    }
    return out;
}

const char* join(const char* * xs, size_t xs_len, const char* sep) {
    const char* res = "";
    int i = 0;
    while (i < xs_len) {
        if (i > 0) {
            res = str_concat(res, sep);
        }
        res = str_concat(res, xs[i]);
        i = i + 1;
    }
    return res;
}

int parseIntStr(const char* str) {
    int i = 0;
    int neg = 0;
    if ((strlen(str) > 0) && (strcmp(_substring(str, 0, 1), "-") == 0)) {
        neg = 1;
        i = 1;
    }
    int n = 0;
    const char* digits_keys[26] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};
    int digits_vals[26] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    size_t digits_len = 10;
    while (i < strlen(str)) {
        n = (n * 10) + map_get_si(digits_keys, digits_vals, digits_len, _substring(str, i, i + 1));
        i = i + 1;
    }
    if (neg) {
        n = -(n);
    }
    return n;
}

int isDigits(const char* s) {
    if (strlen(s) == 0) {
        return 0;
    }
    int i = 0;
    while (i < strlen(s)) {
        const char* ch = _substring(s, i, i + 1);
        if ((strcmp(ch, "0") < 0) || (strcmp(ch, "9") > 0)) {
            return 0;
        }
        i = i + 1;
    }
    return 1;
}

Anon1 readTable(const char* table) {
    const char* *toks = fields(table);
    size_t toks_len = fields_len;
    const char* *cmds = NULL;
    size_t cmds_len = 0;
    int *mins = NULL;
    size_t mins_len = 0;
    int i = 0;
    while (i < toks_len) {
        const char* cmd = toks[i];
        int minlen = strlen(cmd);
        i = i + 1;
        if ((i < toks_len) && isDigits(toks[i])) {
            int num = parseIntStr(toks[i]);
            if ((num >= 1) && (num < strlen(cmd))) {
                minlen = num;
                i = i + 1;
            }
        }
        cmds = list_append_str(cmds, &cmds_len, cmd);
        mins = list_append_int(mins, &mins_len, minlen);
    }
    return (Anon1){.commands = cmds, .commands_len = cmds_len, .mins = mins, .mins_len = mins_len};
}

const char* * validate(const char* * commands, size_t commands_len, int * mins, size_t mins_len, const char* * words, size_t words_len) {
    const char* *results = NULL;
    size_t results_len = 0;
    int wi = 0;
    while (wi < words_len) {
        const char* w = words[wi];
        int found = 0;
        int wlen = strlen(w);
        int ci = 0;
        while (ci < commands_len) {
            const char* cmd = commands[ci];
            if (((mins[ci] != 0) && (wlen >= mins[ci])) && (wlen <= strlen(cmd))) {
                const char* c = str_upper(cmd);
                const char* ww = str_upper(w);
                if (strcmp(_substring(c, 0, wlen), ww) == 0) {
                    results = list_append_str(results, &results_len, c);
                    found = 1;
                    break;
                }
            }
            ci = ci + 1;
        }
        if (!(found)) {
            results = list_append_str(results, &results_len, "*error*");
        }
        wi = wi + 1;
    }
    return validate_len = results_len, results;
}

int user_main() {
    const char* table = "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate 3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left 2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ";
    const char* sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin";
    Anon1 tbl = readTable(table);
    Anon1 commands = tbl;
    Anon1 mins = tbl;
    const char* *words = fields(sentence);
    size_t words_len = fields_len;
    const char* *results = validate(commands, commands_len, mins, mins_len, words, words_len);
    size_t results_len = validate_len;
    const char* out1 = "user words:";
    int k = 0;
    while (k < 10) {
        out1 = str_concat(out1, " ");
        if (k < (10 - 1)) {
            out1 = str_concat(out1, padRight(words[k], strlen(results[k])));
        } else {
            out1 = str_concat(out1, words[k]);
        }
        k = k + 1;
    }
    puts(out1);
    puts(str_concat("full words: ", join(results, results_len, " ")));
}

int main(void) {
    user_main();
    return 0;
}
