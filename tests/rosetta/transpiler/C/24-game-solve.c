// Generated by Mochi 0.10.32 on 2025-07-25 17:17 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>


static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(int v) {
    if(v==0) return strdup("false");
    if(v==1) return strdup("true");
    char buf[32];
    snprintf(buf, sizeof(buf), "%d", v);
    return strdup(buf);
}

static int* list_append_int(int *arr, size_t *len, int val) {
    arr = realloc(arr, (*len + 1) * sizeof(int));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    struct mallinfo mi = mallinfo();
    return (long long)mi.uordblks;
}

typedef struct Bin Bin;
typedef struct Rational Rational;
typedef struct Num Num;

struct Bin {
    int op;
    int left;
    int right;
};

struct Rational {
    int num;
    int denom;
};

struct Num {
    Rational value;
};

int OP_ADD = 1;
int OP_SUB = 2;
int OP_MUL = 3;
int OP_DIV = 4;
int n_cards = 4;
int goal = 24;
int digit_range = 9;

Rational binEval(int op, int l, int r) {
    Rational lv = exprEval(l);
    Rational rv = exprEval(r);
    if (op == OP_ADD) {
        return (Rational){.num = (lv.num * rv.denom) + (lv.denom * rv.num), .denom = lv.denom * rv.denom};
    }
    if (op == OP_SUB) {
        return (Rational){.num = (lv.num * rv.denom) - (lv.denom * rv.num), .denom = lv.denom * rv.denom};
    }
    if (op == OP_MUL) {
        return (Rational){.num = lv.num * rv.num, .denom = lv.denom * rv.denom};
    }
    return (Rational){.num = lv.num * rv.denom, .denom = lv.denom * rv.num};
}

const char* binString(int op, int l, int r) {
    const char* ls = exprString(l);
    const char* rs = exprString(r);
    const char* opstr = "";
    if (op == OP_ADD) {
        opstr = " + ";
    } else {
        if (op == OP_SUB) {
            opstr = " - ";
        } else {
            if (op == OP_MUL) {
                opstr = " * ";
            } else {
                opstr = " / ";
            }
        }
    }
    return str_concat(str_concat(str_concat(str_concat("(", ls), opstr), rs), ")");
}

Num newNum(int n) {
    return (Num){.value = (Rational){.num = n, .denom = 1}};
}

Rational exprEval(int x) {
    return (x == Num(v) ? v : binEval(op, l, r));
}

const char* exprString(int x) {
    return (x == Num(v) ? str_int(v.num) : binString(op, l, r));
}

int solve(int * xs, size_t xs_len) {
    if (xs_len == 1) {
        Rational f = exprEval(xs[0]);
        if ((f.denom != 0) && (f.num == (f.denom * goal))) {
            puts(exprString(xs[0]));
            return 1;
        }
        return 0;
    }
    int i = 0;
    while (i < xs_len) {
        int j = i + 1;
        while (j < xs_len) {
            int *rest = NULL;
            size_t rest_len = 0;
            int k = 0;
            while (k < xs_len) {
                if ((k != i) && (k != j)) {
                    rest = list_append_int(rest, &rest_len, xs[k]);
                }
                k = k + 1;
            }
            int a = xs[i];
            int b = xs[j];
            Bin node = (Bin){.op = OP_ADD, .left = a, .right = b};
            {
                int op_arr[] = {OP_ADD, OP_SUB, OP_MUL, OP_DIV};
                size_t op_len = sizeof(op_arr) / sizeof(op_arr[0]);
                for (size_t i = 0; i < op_len; i++) {
                    int op = op_arr[i];
                    node = (Bin){.op = op, .left = a, .right = b};
                    if (solve(append(rest, node), append_len)) {
                        return 1;
                    }
                }
            }
            node = (Bin){.op = OP_SUB, .left = b, .right = a};
            if (solve(append(rest, node), append_len)) {
                return 1;
            }
            node = (Bin){.op = OP_DIV, .left = b, .right = a};
            if (solve(append(rest, node), append_len)) {
                return 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return 0;
}

int user_main() {
    int iter = 0;
    while (iter < 10) {
        int *cards = NULL;
        size_t cards_len = 0;
        int i = 0;
        while (i < n_cards) {
            int n = (_now() % (digit_range - 1)) + 1;
            cards = list_append_int(cards, &cards_len, newNum(n));
            puts(str_concat(" ", str_int(n)));
            i = i + 1;
        }
        puts(":  ");
        if (!(solve(cards, cards_len))) {
            puts("No solution");
        }
        iter = iter + 1;
    }
}

int main(void) {
    {
        long long __start = _now();
        long long __mem_start = _mem();
        user_main();
        long long __end = _now();
        long long __mem_end = _mem();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = __mem_end - __mem_start;
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
