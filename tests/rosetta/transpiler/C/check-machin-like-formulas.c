// Generated by Mochi 0.10.32 on 2025-08-04 15:00 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>
#include <gmp.h>
typedef mpq_t* bigrat;
typedef mpz_t* bigint;


static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static bigrat _bigrat(long n, long d) {
    bigrat r = malloc(sizeof(mpq_t));
    mpq_init(*r);
    mpq_set_si(*r, n, d);
    mpq_canonicalize(*r);
    return r;
}

static bigrat _add(bigrat a, bigrat b) {
    bigrat r = malloc(sizeof(mpq_t));
    mpq_init(*r);
    mpq_add(*r, *a, *b);
    return r;
}

static bigrat _sub(bigrat a, bigrat b) {
    bigrat r = malloc(sizeof(mpq_t));
    mpq_init(*r);
    mpq_sub(*r, *a, *b);
    return r;
}

static bigrat _mul(bigrat a, bigrat b) {
    bigrat r = malloc(sizeof(mpq_t));
    mpq_init(*r);
    mpq_mul(*r, *a, *b);
    return r;
}

static bigrat _div(bigrat a, bigrat b) {
    bigrat r = malloc(sizeof(mpq_t));
    mpq_init(*r);
    mpq_div(*r, *a, *b);
    return r;
}

static mpz_srcptr num(bigrat a) { return mpq_numref(*a); }
static mpz_srcptr denom(bigrat a) { return mpq_denref(*a); }

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct Anon33 Anon33;
typedef struct Data17 Data17;
typedef struct Data18 Data18;
typedef struct Data19 Data19;
typedef struct Data20 Data20;
typedef struct Data21 Data21;
typedef struct Data22 Data22;
typedef struct Data23 Data23;
typedef struct Data24 Data24;
typedef struct Data25 Data25;
typedef struct Data26 Data26;
typedef struct Data27 Data27;
typedef struct Data28 Data28;
typedef struct Data29 Data29;
typedef struct Data30 Data30;
typedef struct Data31 Data31;
typedef struct Data32 Data32;
typedef struct TestCases TestCases;
typedef struct TestCases1 TestCases1;
typedef struct TestCases10 TestCases10;
typedef struct TestCases11 TestCases11;
typedef struct TestCases12 TestCases12;
typedef struct TestCases13 TestCases13;
typedef struct TestCases14 TestCases14;
typedef struct TestCases15 TestCases15;
typedef struct TestCases2 TestCases2;
typedef struct TestCases3 TestCases3;
typedef struct TestCases4 TestCases4;
typedef struct TestCases5 TestCases5;
typedef struct TestCases6 TestCases6;
typedef struct TestCases7 TestCases7;
typedef struct TestCases8 TestCases8;
typedef struct TestCases9 TestCases9;

struct Anon33 {
    int a;
    int d;
    int n;
};

struct Data17 {
    long long a;
    long long n;
    long long d;
};

struct Data18 {
    long long a;
    long long n;
    long long d;
};

struct Data19 {
    long long a;
    long long n;
    long long d;
};

struct Data20 {
    long long a;
    long long n;
    long long d;
};

struct Data21 {
    long long a;
    long long n;
    long long d;
};

struct Data22 {
    long long a;
    long long n;
    long long d;
};

struct Data23 {
    long long a;
    long long n;
    long long d;
};

struct Data24 {
    long long a;
    long long n;
    long long d;
};

struct Data25 {
    long long a;
    long long n;
    long long d;
};

struct Data26 {
    long long a;
    long long n;
    long long d;
};

struct Data27 {
    long long a;
    long long n;
    long long d;
};

struct Data28 {
    long long a;
    long long n;
    long long d;
};

struct Data29 {
    long long a;
    long long n;
    long long d;
};

struct Data30 {
    long long a;
    long long n;
    long long d;
};

struct Data31 {
    long long a;
    long long n;
    long long d;
};

struct Data32 {
    long long a;
    long long n;
    long long d;
};

struct TestCases {
    long long a;
    long long n;
    long long d;
};

struct TestCases1 {
    long long a;
    long long n;
    long long d;
};

struct TestCases10 {
    long long a;
    long long n;
    long long d;
};

struct TestCases11 {
    long long a;
    long long n;
    long long d;
};

struct TestCases12 {
    long long a;
    long long n;
    long long d;
};

struct TestCases13 {
    long long a;
    long long n;
    long long d;
};

struct TestCases14 {
    long long a;
    long long n;
    long long d;
};

struct TestCases15 {
    long long a;
    long long n;
    long long d;
};

struct TestCases2 {
    long long a;
    long long n;
    long long d;
};

struct TestCases3 {
    long long a;
    long long n;
    long long d;
};

struct TestCases4 {
    long long a;
    long long n;
    long long d;
};

struct TestCases5 {
    long long a;
    long long n;
    long long d;
};

struct TestCases6 {
    long long a;
    long long n;
    long long d;
};

struct TestCases7 {
    long long a;
    long long n;
    long long d;
};

struct TestCases8 {
    long long a;
    long long n;
    long long d;
};

struct TestCases9 {
    long long a;
    long long n;
    long long d;
};

long long testCases_0[2] = {(TestCases){.a = 1LL, .n = 1LL, .d = 2LL}, (TestCases){.a = 1LL, .n = 1LL, .d = 3LL}};
long long testCases_1[2] = {(TestCases1){.a = 2LL, .n = 1LL, .d = 3LL}, (TestCases1){.a = 1LL, .n = 1LL, .d = 7LL}};
long long testCases_2[2] = {(TestCases2){.a = 4LL, .n = 1LL, .d = 5LL}, (TestCases2){.a = -1LL, .n = 1LL, .d = 239LL}};
long long testCases_3[2] = {(TestCases3){.a = 5LL, .n = 1LL, .d = 7LL}, (TestCases3){.a = 2LL, .n = 3LL, .d = 79LL}};
long long testCases_4[3] = {(TestCases4){.a = 1LL, .n = 1LL, .d = 2LL}, (TestCases4){.a = 1LL, .n = 1LL, .d = 5LL}, (TestCases4){.a = 1LL, .n = 1LL, .d = 8LL}};
long long testCases_5[3] = {(TestCases5){.a = 4LL, .n = 1LL, .d = 5LL}, (TestCases5){.a = -1LL, .n = 1LL, .d = 70LL}, (TestCases5){.a = 1LL, .n = 1LL, .d = 99LL}};
long long testCases_6[3] = {(TestCases6){.a = 5LL, .n = 1LL, .d = 7LL}, (TestCases6){.a = 4LL, .n = 1LL, .d = 53LL}, (TestCases6){.a = 2LL, .n = 1LL, .d = 4443LL}};
long long testCases_7[3] = {(TestCases7){.a = 6LL, .n = 1LL, .d = 8LL}, (TestCases7){.a = 2LL, .n = 1LL, .d = 57LL}, (TestCases7){.a = 1LL, .n = 1LL, .d = 239LL}};
long long testCases_8[3] = {(TestCases8){.a = 8LL, .n = 1LL, .d = 10LL}, (TestCases8){.a = -1LL, .n = 1LL, .d = 239LL}, (TestCases8){.a = -4LL, .n = 1LL, .d = 515LL}};
long long testCases_9[3] = {(TestCases9){.a = 12LL, .n = 1LL, .d = 18LL}, (TestCases9){.a = 8LL, .n = 1LL, .d = 57LL}, (TestCases9){.a = -5LL, .n = 1LL, .d = 239LL}};
long long testCases_10[3] = {(TestCases10){.a = 16LL, .n = 1LL, .d = 21LL}, (TestCases10){.a = 3LL, .n = 1LL, .d = 239LL}, (TestCases10){.a = 4LL, .n = 3LL, .d = 1042LL}};
long long testCases_11[4] = {(TestCases11){.a = 22LL, .n = 1LL, .d = 28LL}, (TestCases11){.a = 2LL, .n = 1LL, .d = 443LL}, (TestCases11){.a = -5LL, .n = 1LL, .d = 1393LL}, (TestCases11){.a = -10LL, .n = 1LL, .d = 11018LL}};
long long testCases_12[3] = {(TestCases12){.a = 22LL, .n = 1LL, .d = 38LL}, (TestCases12){.a = 17LL, .n = 7LL, .d = 601LL}, (TestCases12){.a = 10LL, .n = 7LL, .d = 8149LL}};
long long testCases_13[4] = {(TestCases13){.a = 44LL, .n = 1LL, .d = 57LL}, (TestCases13){.a = 7LL, .n = 1LL, .d = 239LL}, (TestCases13){.a = -12LL, .n = 1LL, .d = 682LL}, (TestCases13){.a = 24LL, .n = 1LL, .d = 12943LL}};
long long testCases_14[5] = {(TestCases14){.a = 88LL, .n = 1LL, .d = 172LL}, (TestCases14){.a = 51LL, .n = 1LL, .d = 239LL}, (TestCases14){.a = 32LL, .n = 1LL, .d = 682LL}, (TestCases14){.a = 44LL, .n = 1LL, .d = 5357LL}, (TestCases14){.a = 68LL, .n = 1LL, .d = 12943LL}};
long long testCases_15[5] = {(TestCases15){.a = 88LL, .n = 1LL, .d = 172LL}, (TestCases15){.a = 51LL, .n = 1LL, .d = 239LL}, (TestCases15){.a = 32LL, .n = 1LL, .d = 682LL}, (TestCases15){.a = 44LL, .n = 1LL, .d = 5357LL}, (TestCases15){.a = 68LL, .n = 1LL, .d = 12944LL}};
long long *testCases[] = {testCases_0, testCases_1, testCases_2, testCases_3, testCases_4, testCases_5, testCases_6, testCases_7, testCases_8, testCases_9, testCases_10, testCases_11, testCases_12, testCases_13, testCases_14, testCases_15};
size_t testCases_len = 16;
size_t testCases_lens[] = {2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 5, 5};
size_t testCases_lens_len = 16;

bigrat br(long long n, long long d);
const char* format(MapSI * ts, size_t ts_len);
bigrat tanEval(long long coef, bigrat f);
bigrat tans(MapSI * m, size_t m_len);
int main(void);

bigrat br(long long n, long long d) {
    return _div(_bigrat(n, 1LL), _bigrat(d, 1LL));
}

const char* format(MapSI * ts, size_t ts_len) {
    const char* s = "[";
    int i = 0LL;
    while (i < ts_len) {
        MapSI t = ts[(int)(i)];
        s = str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(s, "{"), str_int(t[(int)("a")])), " "), str_int(t[(int)("n")])), " "), str_int(t[(int)("d")])), "}");
        if (i < (ts_len - 1LL)) {
            s = str_concat(s, " ");
        }
        i = i + 1LL;
    }
    return str_concat(s, "]");
}

bigrat tanEval(long long coef, bigrat f) {
    if (coef == 1LL) {
        return f;
    }
    if (coef < 0LL) {
        return -(tanEval(-(coef), f));
    }
    int ca = coef / 2LL;
    int cb = coef - ca;
    long long a = tanEval(ca, f);
    long long b = tanEval(cb, f);
    return _div(_bigrat(a + b, 1), _sub(_bigrat(1LL, 1LL), _bigrat(a * b, 1)));
}

bigrat tans(MapSI * m, size_t m_len) {
    if (m_len == 1LL) {
        MapSI t = m[(int)(0LL)];
        return tanEval(t[(int)("a")], br(t[(int)("n")], t[(int)("d")]));
    }
    int half = m_len / 2LL;
    long long a = tans(_substring(m, 0LL, half), _substring_len);
    long long b = tans(_substring(m, half), _substring_len);
    return _div(_bigrat(a + b, 1), _sub(_bigrat(1LL, 1LL), _bigrat(a * b, 1)));
}

int main(void) {
    {
        long long __start = _now();
        {
            Anon33 ts_arr[16][2] = {{(Anon33){.a = 1LL, .d = 2LL, .n = 1LL}, (Anon33){.a = 1LL, .d = 3LL, .n = 1LL}}, {(Anon33){.a = 2LL, .d = 3LL, .n = 1LL}, (Anon33){.a = 1LL, .d = 7LL, .n = 1LL}}, {(Anon33){.a = 4LL, .d = 5LL, .n = 1LL}, (Anon33){.a = -1LL, .d = 239LL, .n = 1LL}}, {(Anon33){.a = 5LL, .d = 7LL, .n = 1LL}, (Anon33){.a = 2LL, .d = 79LL, .n = 3LL}}, {(Anon33){.a = 1LL, .d = 2LL, .n = 1LL}, (Anon33){.a = 1LL, .d = 5LL, .n = 1LL}, (Anon33){.a = 1LL, .d = 8LL, .n = 1LL}}, {(Anon33){.a = 4LL, .d = 5LL, .n = 1LL}, (Anon33){.a = -1LL, .d = 70LL, .n = 1LL}, (Anon33){.a = 1LL, .d = 99LL, .n = 1LL}}, {(Anon33){.a = 5LL, .d = 7LL, .n = 1LL}, (Anon33){.a = 4LL, .d = 53LL, .n = 1LL}, (Anon33){.a = 2LL, .d = 4443LL, .n = 1LL}}, {(Anon33){.a = 6LL, .d = 8LL, .n = 1LL}, (Anon33){.a = 2LL, .d = 57LL, .n = 1LL}, (Anon33){.a = 1LL, .d = 239LL, .n = 1LL}}, {(Anon33){.a = 8LL, .d = 10LL, .n = 1LL}, (Anon33){.a = -1LL, .d = 239LL, .n = 1LL}, (Anon33){.a = -4LL, .d = 515LL, .n = 1LL}}, {(Anon33){.a = 12LL, .d = 18LL, .n = 1LL}, (Anon33){.a = 8LL, .d = 57LL, .n = 1LL}, (Anon33){.a = -5LL, .d = 239LL, .n = 1LL}}, {(Anon33){.a = 16LL, .d = 21LL, .n = 1LL}, (Anon33){.a = 3LL, .d = 239LL, .n = 1LL}, (Anon33){.a = 4LL, .d = 1042LL, .n = 3LL}}, {(Anon33){.a = 22LL, .d = 28LL, .n = 1LL}, (Anon33){.a = 2LL, .d = 443LL, .n = 1LL}, (Anon33){.a = -5LL, .d = 1393LL, .n = 1LL}, (Anon33){.a = -10LL, .d = 11018LL, .n = 1LL}}, {(Anon33){.a = 22LL, .d = 38LL, .n = 1LL}, (Anon33){.a = 17LL, .d = 601LL, .n = 7LL}, (Anon33){.a = 10LL, .d = 8149LL, .n = 7LL}}, {(Anon33){.a = 44LL, .d = 57LL, .n = 1LL}, (Anon33){.a = 7LL, .d = 239LL, .n = 1LL}, (Anon33){.a = -12LL, .d = 682LL, .n = 1LL}, (Anon33){.a = 24LL, .d = 12943LL, .n = 1LL}}, {(Anon33){.a = 88LL, .d = 172LL, .n = 1LL}, (Anon33){.a = 51LL, .d = 239LL, .n = 1LL}, (Anon33){.a = 32LL, .d = 682LL, .n = 1LL}, (Anon33){.a = 44LL, .d = 5357LL, .n = 1LL}, (Anon33){.a = 68LL, .d = 12943LL, .n = 1LL}}, {(Anon33){.a = 88LL, .d = 172LL, .n = 1LL}, (Anon33){.a = 51LL, .d = 239LL, .n = 1LL}, (Anon33){.a = 32LL, .d = 682LL, .n = 1LL}, (Anon33){.a = 44LL, .d = 5357LL, .n = 1LL}, (Anon33){.a = 68LL, .d = 12944LL, .n = 1LL}}};
            size_t ts_len = 16;
            for (size_t __i = 0; __i < ts_len; __i++) {
                Anon33 ts[2] = {0};
                memcpy(ts, ts_arr[__i], sizeof(ts_arr[__i]));
                puts(str_concat(str_concat(str_concat("tan ", format(ts, ts_len)), " = "), str_int(tans(ts, ts_len))));
            }
        }
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
