// Generated by Mochi 0.10.32 on 2025-08-05 02:43 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

static long long* list_append_long_long(long long *arr, size_t *len, long long val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static long long** list_append_long_longptr(long long **arr, size_t *len, long long *val) {
    arr = realloc(arr, (*len + 1) * sizeof(long long*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

long long w = 400LL;
long long h = 300LL;
long long n = 15000LL;
long long frost = 255LL;
long long **grid = NULL;
size_t grid_len = 0;
size_t *grid_lens = NULL;
size_t grid_lens_len = 0;
long long y = 0LL;
long long a = 0LL;

long long inBounds(long long x, long long y);
long long hasNeighbor(long long x, long long y);
int main(void);

long long inBounds(long long x, long long y) {
    return (((x >= 0LL) && (x < w)) && (y >= 0LL)) && (y < h);
}

long long hasNeighbor(long long x, long long y) {
    long long dy = -1LL;
    while (dy <= 1LL) {
        long long dx = -1LL;
        while (dx <= 1LL) {
            if (!((dx == 0LL) && (dy == 0LL))) {
                long long nx = x + dx;
                long long ny = y + dy;
                if (inBounds(nx, ny) && (grid[(int)(ny)][(int)(nx)] == frost)) {
                    return 1LL;
                }
            }
            dx = dx + 1LL;
        }
        dy = dy + 1LL;
    }
    return 0LL;
}

int main(void) {
    {
        long long __start = _now();
        while (y < h) {
            long long *row = NULL;
            size_t row_len = 0;
            long long x = 0LL;
            while (x < w) {
                row = list_append_long_long(row, &row_len, 0LL);
                x = x + 1LL;
            }
            grid = list_append_long_longptr(grid, &grid_len, row);
            grid_lens = list_append_szt(grid_lens, &grid_lens_len, row_len);
            y = y + 1LL;
        }
        grid[(int)(h / 3LL)][(int)(w / 3LL)] = frost;
        while (a < n) {
            long long px = _now() % w;
            long long py = _now() % h;
            if (grid[(int)(py)][(int)(px)] == frost) {
                long long lost = 0LL;
                while (1LL) {
                    px = (px + (_now() % 3LL)) - 1LL;
                    py = (py + (_now() % 3LL)) - 1LL;
                    if (!(inBounds(px, py))) {
                        lost = 1LL;
                        break;
                    }
                    if (grid[(int)(py)][(int)(px)] != frost) {
                        break;
                    }
                }
                if (lost) {
                    continue;
                }
            } else {
                long long lost = 0LL;
                while (!(hasNeighbor(px, py))) {
                    px = (px + (_now() % 3LL)) - 1LL;
                    py = (py + (_now() % 3LL)) - 1LL;
                    if (!(inBounds(px, py))) {
                        lost = 1LL;
                        break;
                    }
                }
                if (lost) {
                    continue;
                }
            }
            grid[(int)(py)][(int)(px)] = frost;
            a = a + 1LL;
        }
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
