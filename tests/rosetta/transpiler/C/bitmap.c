// Generated by Mochi 0.10.32 on 2025-08-03 22:59 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <malloc.h>


static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(long long v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%lld", v);
    return strdup(buf);
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    long long size = 0, rss = 0;
    FILE *f = fopen("/proc/self/statm", "r");
    if (f) {
        if (fscanf(f, "%lld %lld", &size, &rss) != 2) rss = 0;
        fclose(f);
    }
    return rss * (long long)sysconf(_SC_PAGESIZE);
}

typedef struct Anon1 Anon1;
typedef struct Anon2 Anon2;
typedef struct Anon5 Anon5;
typedef struct Anon6 Anon6;
typedef struct Bitmap Bitmap;
typedef struct Pixel Pixel;
typedef struct Anon3 Anon3;
typedef struct Anon4 Anon4;

struct Anon1 {
    int cols;
    int rows;
};

struct Anon2 {
    int ok;
};

struct Anon5 {
    int ok;
    int rgb;
};

struct Anon6 {
    int ok;
    int rgb;
};

struct Bitmap {
    long long cols;
    long long rows;
    Pixel **px;
    size_t px_len;
    size_t *px_lens;
    size_t px_lens_len;
};

struct Pixel {
    long long R;
    long long G;
    long long B;
};

struct Anon3 {
    int ok;
    Pixel pixel;
};

struct Anon4 {
    int ok;
    Pixel pixel;
};

static Pixel* list_append_Pixel(Pixel *arr, size_t *len, Pixel val) {
    arr = realloc(arr, (*len + 1) * sizeof(Pixel));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static Pixel** list_append_Pixelptr(Pixel **arr, size_t *len, Pixel *val) {
    arr = realloc(arr, (*len + 1) * sizeof(Pixel*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

Pixel pixelFromRgb(long long c);
long long rgbFromPixel(Pixel p);
Bitmap NewBitmap(long long x, long long y);
Anon1 Extent(Bitmap b);
void Fill(Bitmap b, Pixel p);
void FillRgb(Bitmap b, long long c);
long long SetPx(Bitmap b, long long x, long long y, Pixel p);
long long SetPxRgb(Bitmap b, long long x, long long y, long long c);
Anon4 GetPx(Bitmap b, long long x, long long y);
Anon6 GetPxRgb(Bitmap b, long long x, long long y);
long long ppmSize(Bitmap b);
const char* pixelStr(Pixel p);
void user_main();
int main(void);

Pixel pixelFromRgb(long long c) {
    int r = (c / 65536LL) % 256LL;
    int g = (c / 256LL) % 256LL;
    int b = c % 256LL;
    return (Pixel){.R = r, .G = g, .B = b};
}

long long rgbFromPixel(Pixel p) {
    return ((p.R * 65536LL) + (p.G * 256LL)) + p.B;
}

Bitmap NewBitmap(long long x, long long y) {
    Pixel **data = NULL;
    size_t data_len = 0;
    size_t *data_lens = NULL;
    size_t data_lens_len = 0;
    int row = 0LL;
    while (row < y) {
        Pixel *r = NULL;
        size_t r_len = 0;
        int col = 0LL;
        while (col < x) {
            r = list_append_Pixel(r, &r_len, (Pixel){.R = 0LL, .G = 0LL, .B = 0LL});
            col = col + 1LL;
        }
        data = list_append_Pixelptr(data, &data_len, r);
        data_lens = list_append_szt(data_lens, &data_lens_len, r_len);
        row = row + 1LL;
    }
    return (Bitmap){.cols = x, .rows = y, .px = data, .px_len = data_len, .px_lens = data_lens, .px_lens_len = data_len};
}

Anon1 Extent(Bitmap b) {
    return (Anon1){.cols = b.cols, .rows = b.rows};
}

void Fill(Bitmap b, Pixel p) {
    int y = 0LL;
    while (y < b.rows) {
        int x = 0LL;
        while (x < b.cols) {
            Pixel **px = b.px;
            size_t px_len = b.px_len;
            size_t *px_lens = b.px_lens;
            size_t px_lens_len = b.px_len;
            Pixel *row = px[(int)(y)];
            size_t row_len = px_lens[y];
            row[(int)(x)] = p;
            px[(int)(y)] = row;
            b.px = px;
            x = x + 1LL;
        }
        y = y + 1LL;
    }
}

void FillRgb(Bitmap b, long long c) {
    Fill(b, pixelFromRgb(c));
}

long long SetPx(Bitmap b, long long x, long long y, Pixel p) {
    if ((((x < 0LL) || (x >= b.cols)) || (y < 0LL)) || (y >= b.rows)) {
        return 0LL;
    }
    Pixel **px = b.px;
    size_t px_len = b.px_len;
    size_t *px_lens = b.px_lens;
    size_t px_lens_len = b.px_len;
    Pixel *row = px[(int)(y)];
    size_t row_len = px_lens[y];
    row[(int)(x)] = p;
    px[(int)(y)] = row;
    b.px = px;
    return 1LL;
}

long long SetPxRgb(Bitmap b, long long x, long long y, long long c) {
    return SetPx(b, x, y, pixelFromRgb(c));
}

Anon4 GetPx(Bitmap b, long long x, long long y) {
    if ((((x < 0LL) || (x >= b.cols)) || (y < 0LL)) || (y >= b.rows)) {
        return (Anon4){.ok = 0LL};
    }
    Pixel *row = b.px[(int)(y)];
    size_t row_len = 0;
    return (Anon4){.ok = 1LL, .pixel = row[(int)(x)]};
}

Anon6 GetPxRgb(Bitmap b, long long x, long long y) {
    Anon4 r = GetPx(b, x, y);
    if (!(r.ok)) {
        return (Anon6){.ok = 0LL};
    }
    return (Anon6){.ok = 1LL, .rgb = rgbFromPixel(r.pixel)};
}

long long ppmSize(Bitmap b) {
    const char* header = str_concat(str_concat(str_concat(str_concat("P6\n# Creator: Rosetta Code http://rosettacode.org/\n", str_int(b.cols)), " "), str_int(b.rows)), "\n255\n");
    return strlen(header) + ((3LL * b.cols) * b.rows);
}

const char* pixelStr(Pixel p) {
    return str_concat(str_concat(str_concat(str_concat(str_concat(str_concat("{", str_int(p.R)), " "), str_int(p.G)), " "), str_int(p.B)), "}");
}

void user_main() {
    Bitmap bm = NewBitmap(300LL, 240LL);
    FillRgb(bm, 16711680LL);
    SetPxRgb(bm, 10LL, 20LL, 255LL);
    SetPxRgb(bm, 20LL, 30LL, 0LL);
    SetPxRgb(bm, 30LL, 40LL, 1056816LL);
    Anon4 c1 = GetPx(bm, 0LL, 0LL);
    Anon4 c2 = GetPx(bm, 10LL, 20LL);
    Anon4 c3 = GetPx(bm, 30LL, 40LL);
    puts(str_concat(str_concat(str_concat("Image size: ", str_int(bm.cols)), " Ã— "), str_int(bm.rows)));
    puts(str_concat(str_int(ppmSize(bm)), " bytes when encoded as PPM."));
    if (c1.ok) {
        puts(str_concat("Pixel at (0,0) is ", pixelStr(c1.pixel)));
    }
    if (c2.ok) {
        puts(str_concat("Pixel at (10,20) is ", pixelStr(c2.pixel)));
    }
    if (c3.ok) {
        Pixel p = c3.pixel;
        int r16 = p.R * 257LL;
        int g16 = p.G * 257LL;
        int b16 = p.B * 257LL;
        puts(str_concat(str_concat(str_concat(str_concat(str_concat("Pixel at (30,40) has R=", str_int(r16)), ", G="), str_int(g16)), ", B="), str_int(b16)));
    }
}

int main(void) {
    {
        long long __start = _now();
        user_main();
        long long __end = _now();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = _mem();
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
