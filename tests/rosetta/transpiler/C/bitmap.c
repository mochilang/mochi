// Generated by Mochi 0.10.32 on 2025-07-31 12:13 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>


static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(int v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%d", v);
    return strdup(buf);
}

typedef struct { const char **keys; const char **vals; size_t len; } MapSS;

static const char* map_get_ss(const char *keys[], const char *vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return "";
}

static int* list_append_int_new(const int *arr, size_t len, int val) {
    int *res = malloc((len + 1) * sizeof(int));
    if (arr && len) memcpy(res, arr, len * sizeof(int));
    res[len] = val;
    return res;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char*** list_append_strptr(const char ***arr, size_t *len, const char **val) {
    arr = realloc(arr, (*len + 1) * sizeof(const char**));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    struct mallinfo mi = mallinfo();
    return (long long)mi.uordblks;
}

typedef struct Anon1 Anon1;
typedef struct Anon2 Anon2;
typedef struct Anon4 Anon4;
typedef struct Bitmap Bitmap;
typedef struct Pixel Pixel;
typedef struct Anon3 Anon3;

struct Anon1 {
    int cols;
    int rows;
};

struct Anon2 {
    int ok;
};

struct Anon4 {
    int ok;
    int rgb;
};

struct Bitmap {
    int cols;
    int rows;
    Pixel[] *px;
    size_t px_len;
};

struct Pixel {
    int R;
    int G;
    int B;
};

struct Anon3 {
    int ok;
    Pixel pixel;
};

Pixel pixelFromRgb(int c);
int rgbFromPixel(Pixel p);
Bitmap NewBitmap(int x, int y);
Anon1 Extent(Bitmap b);
int Fill(Bitmap b, Pixel p);
int FillRgb(Bitmap b, int c);
int SetPx(Bitmap b, int x, int y, Pixel p);
int SetPxRgb(Bitmap b, int x, int y, int c);
Anon2 GetPx(Bitmap b, int x, int y);
Anon2 GetPxRgb(Bitmap b, int x, int y);
int ppmSize(Bitmap b);
const char* pixelStr(Pixel p);
int user_main();
int main(void);

Pixel pixelFromRgb(int c) {
    int r = (c / 65536LL) % 256LL;
    int g = (c / 256LL) % 256LL;
    int b = c % 256LL;
    return (Pixel){.R = r, .G = g, .B = b};
}

int rgbFromPixel(Pixel p) {
    return ((p.R * 65536LL) + (p.G * 256LL)) + p.B;
}

Bitmap NewBitmap(int x, int y) {
    Pixel **data = NULL;
    size_t data_len = 0;
    size_t *data_lens = NULL;
    size_t data_lens_len = 0;
    int row = 0LL;
    while (row < y) {
        Pixel *r = NULL;
        size_t r_len = 0;
        int col = 0LL;
        while (col < x) {
                        r = list_append_int_new(r, r_len, (Pixel){.R = 0LL, .G = 0LL, .B = 0LL});
            col = col + 1LL;
        }
        data = list_append_strptr(data, &data_len, r);
        data_lens = list_append_szt(data_lens, &data_lens_len, r_len);
        row = row + 1LL;
    }
    return (Bitmap){.cols = x, .rows = y, .px = data, .px_len = data_len};
}

Anon1 Extent(Bitmap b) {
    return (Anon1){.cols = b.cols, .rows = b.rows};
}

int Fill(Bitmap b, Pixel p) {
    int y = 0LL;
    while (y < b.rows) {
        int x = 0LL;
        while (x < b.cols) {
            Pixel **px = b.px;
            size_t px_len = b.px_len;
            size_t *px_lens = b.px_lens;
            size_t px_lens_len = b.px_len;
            Pixel *row = px[(int)(y)];
            size_t row_len = px_lens[y];
            row[(int)(x)] = p;
            px[(int)(y)] = row;
            b.px = px;
            x = x + 1LL;
        }
        y = y + 1LL;
    }
}

int FillRgb(Bitmap b, int c) {
    Fill(b, pixelFromRgb(c));
}

int SetPx(Bitmap b, int x, int y, Pixel p) {
    if ((((x < 0LL) || (x >= b.cols)) || (y < 0LL)) || (y >= b.rows)) {
        return 0LL;
    }
    Pixel **px = b.px;
    size_t px_len = b.px_len;
    size_t *px_lens = b.px_lens;
    size_t px_lens_len = b.px_len;
    Pixel *row = px[(int)(y)];
    size_t row_len = px_lens[y];
    row[(int)(x)] = p;
    px[(int)(y)] = row;
    b.px = px;
    return 1LL;
}

int SetPxRgb(Bitmap b, int x, int y, int c) {
    return SetPx(b, x, y, pixelFromRgb(c));
}

Anon2 GetPx(Bitmap b, int x, int y) {
    if ((((x < 0LL) || (x >= b.cols)) || (y < 0LL)) || (y >= b.rows)) {
        return (Anon2){.ok = 0LL};
    }
    Pixel *row = b.px[(int)(y)];
    size_t row_len = 0;
    return (Anon3){.ok = 1LL, .pixel = row[(int)(x)]};
}

Anon2 GetPxRgb(Bitmap b, int x, int y) {
    Anon2 r = GetPx(b, x, y);
    if (!(r.ok)) {
        return (Anon2){.ok = 0LL};
    }
    return (Anon4){.ok = 1LL, .rgb = rgbFromPixel(r.pixel)};
}

int ppmSize(Bitmap b) {
    const char* header = str_concat(str_concat(str_concat(str_concat("P6\n# Creator: Rosetta Code http://rosettacode.org/\n", str_int(b.cols)), " "), str_int(b.rows)), "\n255\n");
    return strlen(header) + ((3LL * b.cols) * b.rows);
}

const char* pixelStr(Pixel p) {
    return str_concat(str_concat(str_concat(str_concat(str_concat(str_concat("{", str_int(p.R)), " "), str_int(p.G)), " "), str_int(p.B)), "}");
}

int user_main() {
    Bitmap bm = NewBitmap(300LL, 240LL);
    FillRgb(bm, 16711680LL);
    SetPxRgb(bm, 10LL, 20LL, 255LL);
    SetPxRgb(bm, 20LL, 30LL, 0LL);
    SetPxRgb(bm, 30LL, 40LL, 1056816LL);
    Anon2 c1 = GetPx(bm, 0LL, 0LL);
    Anon2 c2 = GetPx(bm, 10LL, 20LL);
    Anon2 c3 = GetPx(bm, 30LL, 40LL);
    puts(str_concat(str_concat(str_concat("Image size: ", str_int(bm.cols)), " Ã— "), str_int(bm.rows)));
    puts(str_concat(str_int(ppmSize(bm)), " bytes when encoded as PPM."));
    if (c1.ok) {
        puts(str_concat("Pixel at (0,0) is ", pixelStr(c1.pixel)));
    }
    if (c2.ok) {
        puts(str_concat("Pixel at (10,20) is ", pixelStr(c2.pixel)));
    }
    if (c3.ok) {
        int p = c3.pixel;
        int r16 = p.R * 257LL;
        int g16 = p.G * 257LL;
        int b16 = p.B * 257LL;
        puts(str_concat(str_concat(str_concat(str_concat(str_concat("Pixel at (30,40) has R=", str_int(r16)), ", G="), str_int(g16)), ", B="), str_int(b16)));
    }
}

int main(void) {
    {
        long long __start = _now();
        long long __mem_start = _mem();
        user_main();
        long long __end = _now();
        long long __mem_end = _mem();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = __mem_end - __mem_start;
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
