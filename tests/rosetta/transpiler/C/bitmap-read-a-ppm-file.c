// Generated by Mochi 0.10.32 on 2025-07-31 12:13 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>

size_t splitLines_len;
size_t splitWS_len;
size_t tokenize_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(int v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%d", v);
    return strdup(buf);
}

static int map_get_si(const char *keys[], const int vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int* list_append_int_new(const int *arr, size_t len, int val) {
    int *res = malloc((len + 1) * sizeof(int));
    if (arr && len) memcpy(res, arr, len * sizeof(int));
    res[len] = val;
    return res;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char*** list_append_strptr(const char ***arr, size_t *len, const char **val) {
    arr = realloc(arr, (*len + 1) * sizeof(const char**));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    struct mallinfo mi = mallinfo();
    return (long long)mi.uordblks;
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

typedef struct Bitmap Bitmap;
typedef struct Pixel Pixel;

struct Bitmap {
    int w;
    int h;
    int max;
    Pixel[] *data;
    size_t data_len;
};

struct Pixel {
    int R;
    int G;
    int B;
};

const char* ppmtxt = "P3\n# feep.ppm\n4 4\n15\n 0  0  0    0  0  0    0  0  0   15  0 15\n 0  0  0    0 15  7    0  0  0    0  0  0\n 0  0  0    0  0  0    0 15  7    0  0  0\n15  0 15    0  0  0    0  0  0    0  0  0\n";

Bitmap newBitmap(int w, int h, int max);
int setPx(Bitmap b, int x, int y, Pixel p);
Pixel getPx(Bitmap b, int x, int y);
const char* * splitLines(const char* s);
const char* * splitWS(const char* s);
int parseIntStr(const char* str);
const char* * tokenize(const char* s);
Bitmap readP3(const char* text);
int toGrey(Bitmap b);
const char* pad(int n, int w);
const char* writeP3(Bitmap b);
int main(void);

Bitmap newBitmap(int w, int h, int max) {
    Pixel **rows = NULL;
    size_t rows_len = 0;
    size_t *rows_lens = NULL;
    size_t rows_lens_len = 0;
    int y = 0LL;
    while (y < h) {
        Pixel *row = NULL;
        size_t row_len = 0;
        int x = 0LL;
        while (x < w) {
                        row = list_append_int_new(row, row_len, (Pixel){.R = 0LL, .G = 0LL, .B = 0LL});
            x = x + 1LL;
        }
        rows = list_append_strptr(rows, &rows_len, row);
        rows_lens = list_append_szt(rows_lens, &rows_lens_len, row_len);
        y = y + 1LL;
    }
    return (Bitmap){.w = w, .h = h, .max = max, .data = rows, .data_len = rows_len};
}

int setPx(Bitmap b, int x, int y, Pixel p) {
    Pixel **rows = b.data;
    size_t rows_len = b.data_len;
    size_t *rows_lens = b.data_lens;
    size_t rows_lens_len = b.data_len;
    Pixel *row = rows[(int)(y)];
    size_t row_len = rows_lens[y];
    row[(int)(x)] = p;
    rows[(int)(y)] = row;
    b.data = rows;
}

Pixel getPx(Bitmap b, int x, int y) {
    return b.data[(int)(y)][(int)(x)];
}

const char* * splitLines(const char* s) {
    const char* *out = NULL;
    size_t out_len = 0;
    const char* cur = "";
    int i = 0LL;
    while (i < strlen(s)) {
        int ch = substr(s, i, i + 1LL);
        if (strcmp(ch, "\n") == 0) {
            out = list_append_str(out, &out_len, cur);
            cur = "";
        } else {
            cur = str_concat(cur, ch);
        }
        i = i + 1LL;
    }
    out = list_append_str(out, &out_len, cur);
    return splitLines_len = out_len, out;
}

const char* * splitWS(const char* s) {
    const char* *out = NULL;
    size_t out_len = 0;
    const char* cur = "";
    int i = 0LL;
    while (i < strlen(s)) {
        int ch = substr(s, i, i + 1LL);
        if ((((strcmp(ch, " ") == 0) || (strcmp(ch, "\t") == 0)) || (strcmp(ch, "") == 0)) || (strcmp(ch, "\n") == 0)) {
            if (strlen(cur) > 0LL) {
                out = list_append_str(out, &out_len, cur);
                cur = "";
            }
        } else {
            cur = str_concat(cur, ch);
        }
        i = i + 1LL;
    }
    if (strlen(cur) > 0LL) {
        out = list_append_str(out, &out_len, cur);
    }
    return splitWS_len = out_len, out;
}

int parseIntStr(const char* str) {
    int i = 0LL;
    int neg = 0LL;
    if ((strlen(str) > 0LL) && (strcmp(_substring(str, 0LL, 1LL), "-") == 0)) {
        neg = 1LL;
        i = 1LL;
    }
    int n = 0LL;
    const char* digits_keys[26] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};
    int digits_vals[26] = {0LL, 1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL, 8LL, 9LL};
    size_t digits_len = 10;
    while (i < strlen(str)) {
        n = (n * 10LL) + map_get_si(digits_keys, digits_vals, digits_len, _substring(str, i, i + 1LL));
        i = i + 1LL;
    }
    if (neg) {
        n = -(n);
    }
    return n;
}

const char* * tokenize(const char* s) {
    const char* *lines = splitLines(s);
    size_t lines_len = splitLines_len;
    const char* *toks = NULL;
    size_t toks_len = 0;
    int i = 0LL;
    while (i < lines_len) {
        const char* line = lines[(int)(i)];
        if ((strlen(line) > 0LL) && (strcmp(substr(line, 0LL, 1LL), "#") == 0)) {
            i = i + 1LL;
            continue;
        }
        const char* *parts = splitWS(line);
        size_t parts_len = splitWS_len;
        int j = 0LL;
        while (j < parts_len) {
            toks = list_append_str(toks, &toks_len, parts[(int)(j)]);
            j = j + 1LL;
        }
        i = i + 1LL;
    }
    return tokenize_len = toks_len, toks;
}

Bitmap readP3(const char* text) {
    const char* *toks = tokenize(text);
    size_t toks_len = tokenize_len;
    if (toks_len < 4LL) {
        return newBitmap(0LL, 0LL, 0LL);
    }
    if (strcmp(toks[(int)(0LL)], "P3") != 0) {
        return newBitmap(0LL, 0LL, 0LL);
    }
    int w = parseIntStr(toks[(int)(1LL)]);
    int h = parseIntStr(toks[(int)(2LL)]);
    int maxv = parseIntStr(toks[(int)(3LL)]);
    int idx = 4LL;
    Bitmap bm = newBitmap(w, h, maxv);
    int y = h - 1LL;
    while (y >= 0LL) {
        int x = 0LL;
        while (x < w) {
            int r = parseIntStr(toks[(int)(idx)]);
            int g = parseIntStr(toks[(int)(idx + 1LL)]);
            int b = parseIntStr(toks[(int)(idx + 2LL)]);
            setPx(bm, x, y, (Pixel){.R = r, .G = g, .B = b});
            idx = idx + 3LL;
            x = x + 1LL;
        }
        y = y - 1LL;
    }
    return bm;
}

int toGrey(Bitmap b) {
    int h = b.h;
    int w = b.w;
    int m = 0LL;
    int y = 0LL;
    while (y < h) {
        int x = 0LL;
        while (x < w) {
            Pixel p = getPx(b, x, y);
            int l = (((p.R * 2126LL) + (p.G * 7152LL)) + (p.B * 722LL)) / 10000LL;
            if (l > b.max) {
                l = b.max;
            }
            setPx(b, x, y, (Pixel){.R = l, .G = l, .B = l});
            if (l > m) {
                m = l;
            }
            x = x + 1LL;
        }
        y = y + 1LL;
    }
    b.max = m;
}

const char* pad(int n, int w) {
    const char* s = str_int(n);
    while (strlen(s) < w) {
        s = str_concat(" ", s);
    }
    return s;
}

const char* writeP3(Bitmap b) {
    int h = b.h;
    int w = b.w;
    int max = b.max;
    int digits = strlen(str_int(max));
    const char* out = str_concat(str_concat(str_concat(str_concat(str_concat(str_concat("P3\n# generated from Bitmap.writeppmp3\n", str_int(w)), " "), str_int(h)), "\n"), str_int(max)), "\n");
    int y = h - 1LL;
    while (y >= 0LL) {
        const char* line = "";
        int x = 0LL;
        while (x < w) {
            Pixel p = getPx(b, x, y);
            line = str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(line, "   "), pad(p.R, digits)), " "), pad(p.G, digits)), " "), pad(p.B, digits));
            x = x + 1LL;
        }
        out = str_concat(str_concat(out, line), "\n");
        y = y - 1LL;
    }
    return out;
}

int main(void) {
    {
        long long __start = _now();
        long long __mem_start = _mem();
        puts("Original Colour PPM file");
        puts(ppmtxt);
        Bitmap bm = readP3(ppmtxt);
        puts("Grey PPM:");
        toGrey(bm);
        const char* out = writeP3(bm);
        puts(out);
        long long __end = _now();
        long long __mem_end = _mem();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = __mem_end - __mem_start;
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
