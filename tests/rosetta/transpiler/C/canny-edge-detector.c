// Generated by Mochi 0.10.32 on 2025-07-31 18:33 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>

size_t conv2d_len;
size_t *conv2d_lens;
size_t gradient_len;
size_t *gradient_lens;
size_t threshold_len;
size_t *threshold_lens;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(int v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%d", v);
    return strdup(buf);
}

static int* list_append_int(int *arr, size_t *len, int val) {
    arr = realloc(arr, (*len + 1) * sizeof(int));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double* list_append_double(double *arr, size_t *len, double val) {
    arr = realloc(arr, (*len + 1) * sizeof(double));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static double** list_append_doubleptr(double **arr, size_t *len, double *val) {
    arr = realloc(arr, (*len + 1) * sizeof(double*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    struct mallinfo mi = mallinfo();
    return (long long)mi.uordblks;
}

double PI = 3.141592653589793;

double * * conv2d(double * * img, size_t img_len, size_t* img_lens, size_t img_lens_len, double * * k, size_t k_len, size_t* k_lens, size_t k_lens_len);
double * * gradient(double * * img, size_t img_len, size_t* img_lens, size_t img_lens_len);
int * * threshold(double * * g, size_t g_len, size_t* g_lens, size_t g_lens_len, double t);
int printMatrix(int * * m, size_t m_len, size_t* m_lens, size_t m_lens_len);
int user_main();
int main(void);

double * * conv2d(double * * img, size_t img_len, size_t* img_lens, size_t img_lens_len, double * * k, size_t k_len, size_t* k_lens, size_t k_lens_len) {
    size_t h = img_len;
    int w = img_lens[0LL];
    size_t n = k_len;
    int half = n / 2LL;
    double **out = NULL;
    size_t out_len = 0;
    size_t *out_lens = NULL;
    size_t out_lens_len = 0;
    int y = 0LL;
    while (y < h) {
        double *row = NULL;
        size_t row_len = 0;
        int x = 0LL;
        while (x < w) {
            double sum = 0;
            int j = 0LL;
            while (j < n) {
                int i = 0LL;
                while (i < n) {
                    int yy = (y + j) - half;
                    if (yy < 0LL) {
                        yy = 0LL;
                    }
                    if (yy >= h) {
                        yy = h - 1LL;
                    }
                    int xx = (x + i) - half;
                    if (xx < 0LL) {
                        xx = 0LL;
                    }
                    if (xx >= w) {
                        xx = w - 1LL;
                    }
                    sum = sum + (img[(int)(yy)][(int)(xx)] * k[(int)(j)][(int)(i)]);
                    i = i + 1LL;
                }
                j = j + 1LL;
            }
            row = list_append_double(row, &row_len, sum);
            x = x + 1LL;
        }
        out = list_append_doubleptr(out, &out_len, row);
        out_lens = list_append_szt(out_lens, &out_lens_len, row_len);
        y = y + 1LL;
    }
    return conv2d_lens = out_lens, conv2d_len = out_len, out;
}

double * * gradient(double * * img, size_t img_len, size_t* img_lens, size_t img_lens_len) {
    int hx[3][3] = {{-(1), 0, 1}, {-(2), 0, 2}, {-(1), 0, 1}};
    size_t hx_len = 3;
    size_t hx_lens[] = {3, 3, 3};
    size_t hx_lens_len = 3;
    int hy[3][3] = {{1, 2, 1}, {0, 0, 0}, {-(1), -(2), -(1)}};
    size_t hy_len = 3;
    size_t hy_lens[] = {3, 3, 3};
    size_t hy_lens_len = 3;
    double **gx = conv2d(img, img_len, img_lens, img_len, hx, hx_len, hx_lens, hx_len);
    size_t gx_len = conv2d_len;
    size_t *gx_lens = conv2d_lens;
    size_t gx_lens_len = conv2d_len;
    double **gy = conv2d(img, img_len, img_lens, img_len, hy, hy_len, hy_lens, hy_len);
    size_t gy_len = conv2d_len;
    size_t *gy_lens = conv2d_lens;
    size_t gy_lens_len = conv2d_len;
    size_t h = img_len;
    int w = img_lens[0LL];
    double **out = NULL;
    size_t out_len = 0;
    size_t *out_lens = NULL;
    size_t out_lens_len = 0;
    int y = 0LL;
    while (y < h) {
        double *row = NULL;
        size_t row_len = 0;
        int x = 0LL;
        while (x < w) {
            double g = (gx[(int)(y)][(int)(x)] * gx[(int)(y)][(int)(x)]) + (gy[(int)(y)][(int)(x)] * gy[(int)(y)][(int)(x)]);
            row = list_append_double(row, &row_len, g);
            x = x + 1LL;
        }
        out = list_append_doubleptr(out, &out_len, row);
        out_lens = list_append_szt(out_lens, &out_lens_len, row_len);
        y = y + 1LL;
    }
    return gradient_lens = out_lens, gradient_len = out_len, out;
}

int * * threshold(double * * g, size_t g_len, size_t* g_lens, size_t g_lens_len, double t) {
    size_t h = g_len;
    int w = g_lens[0LL];
    int **out = NULL;
    size_t out_len = 0;
    size_t *out_lens = NULL;
    size_t out_lens_len = 0;
    int y = 0LL;
    while (y < h) {
        int *row = NULL;
        size_t row_len = 0;
        int x = 0LL;
        while (x < w) {
            if (g[(int)(y)][(int)(x)] >= t) {
                row = list_append_int(row, &row_len, 1LL);
            } else {
                row = list_append_int(row, &row_len, 0LL);
            }
            x = x + 1LL;
        }
        out = list_append_intptr(out, &out_len, row);
        out_lens = list_append_szt(out_lens, &out_lens_len, row_len);
        y = y + 1LL;
    }
    return threshold_lens = out_lens, threshold_len = out_len, out;
}

int printMatrix(int * * m, size_t m_len, size_t* m_lens, size_t m_lens_len) {
    int y = 0LL;
    while (y < m_len) {
        const char* line = "";
        int x = 0LL;
        while (x < m_lens[0LL]) {
            line = str_concat(line, str_int(m[(int)(y)][(int)(x)]));
            if (x < (m_lens[0LL] - 1LL)) {
                line = str_concat(line, " ");
            }
            x = x + 1LL;
        }
        puts(line);
        y = y + 1LL;
    }
}

int user_main() {
    int img[5][5] = {{0, 0, 0, 0, 0}, {0, 255, 255, 255, 0}, {0, 255, 255, 255, 0}, {0, 255, 255, 255, 0}, {0, 0, 0, 0, 0}};
    size_t img_len = 5;
    size_t img_lens[] = {5, 5, 5, 5, 5};
    size_t img_lens_len = 5;
    double **g = gradient(img, img_len, img_lens, img_len);
    size_t g_len = gradient_len;
    size_t *g_lens = gradient_lens;
    size_t g_lens_len = gradient_len;
    int **edges = threshold(g, g_len, g_lens, g_len, 1020 * 1020);
    size_t edges_len = threshold_len;
    size_t *edges_lens = threshold_lens;
    size_t edges_lens_len = threshold_len;
    printMatrix(edges, edges_len, edges_lens, edges_len);
}

int main(void) {
    {
        long long __start = _now();
        long long __mem_start = _mem();
        user_main();
        long long __end = _now();
        long long __mem_end = _mem();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = __mem_end - __mem_start;
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
