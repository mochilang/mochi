// Generated by Mochi 0.10.32 on 2025-07-24 12:04 +0000
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

size_t fields_len;
size_t validate_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_upper(const char *s) {
    size_t n = strlen(s);
    char *out = strdup(s);
    for(size_t i=0;i<n;i++) out[i] = toupper((unsigned char)out[i]);
    return out;
}

static int* list_append_int(int *arr, size_t *len, int val) {
    arr = realloc(arr, (*len + 1) * sizeof(int));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char** list_append_str(const char **arr, size_t *len, const char *val) {
    arr = realloc((void*)arr, (*len + 1) * sizeof(char*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

const char* * fields(const char* s) {
    const char* *words = NULL;
    size_t words_len = 0;
    const char* cur = "";
    int i = 0;
    while (i < strlen(s)) {
        const char* ch = _substring(s, i, i + 1);
        if (((strcmp(ch, " ") == 0) || (strcmp(ch, "\n") == 0)) || (strcmp(ch, "\t") == 0)) {
            if (strlen(cur) > 0) {
                words = list_append_str(words, &words_len, cur);
                cur = "";
            }
        } else {
            cur = str_concat(cur, ch);
        }
        i = i + 1;
    }
    if (strlen(cur) > 0) {
        words = list_append_str(words, &words_len, cur);
    }
    return fields_len = words_len, words;
}

const char* padRight(const char* s, int width) {
    const char* out = s;
    int i = strlen(s);
    while (i < width) {
        out = str_concat(out, " ");
        i = i + 1;
    }
    return out;
}

const char* join(const char* * xs, size_t xs_len, const char* sep) {
    const char* res = "";
    int i = 0;
    while (i < xs_len) {
        if (i > 0) {
            res = str_concat(res, sep);
        }
        res = str_concat(res, xs[i]);
        i = i + 1;
    }
    return res;
}

const char* * validate(const char* * commands, size_t commands_len, const char* * words, size_t words_len, int * mins, size_t mins_len) {
    const char* *results = NULL;
    size_t results_len = 0;
    if (words_len == 0) {
        return validate_len = results_len, results;
    }
    int wi = 0;
    while (wi < words_len) {
        const char* w = words[wi];
        int found = 0;
        int wlen = strlen(w);
        int ci = 0;
        while (ci < commands_len) {
            const char* cmd = commands[ci];
            if (((mins[ci] != 0) && (wlen >= mins[ci])) && (wlen <= strlen(cmd))) {
                const char* c = str_upper(cmd);
                const char* ww = str_upper(w);
                if (strcmp(_substring(c, 0, wlen), ww) == 0) {
                    results = list_append_str(results, &results_len, c);
                    found = 1;
                    break;
                }
            }
            ci = ci + 1;
        }
        if (!(found)) {
            results = list_append_str(results, &results_len, "*error*");
        }
        wi = wi + 1;
    }
    return validate_len = results_len, results;
}

int user_main() {
    const char* table = "Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput  Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp ";
    const char* *commands = fields(table);
    size_t commands_len = fields_len;
    int *mins = NULL;
    size_t mins_len = 0;
    int i = 0;
    while (i < 80) {
        int count = 0;
        int j = 0;
        const char* cmd = commands[i];
        while (j < strlen(cmd)) {
            const char* ch = _substring(cmd, j, j + 1);
            if ((strcmp(ch, "A") >= 0) && (strcmp(ch, "Z") <= 0)) {
                count = count + 1;
            }
            j = j + 1;
        }
        mins = list_append_int(mins, &mins_len, count);
        i = i + 1;
    }
    const char* sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin";
    const char* *words = fields(sentence);
    size_t words_len = fields_len;
    const char* *results = validate(commands, commands_len, words, words_len, mins, mins_len);
    size_t results_len = validate_len;
    const char* out1 = "user words:  ";
    int k = 0;
    while (k < 10) {
        out1 = str_concat(str_concat(out1, padRight(words[k], strlen(results[k]))), " ");
        k = k + 1;
    }
    puts(out1);
    puts(str_concat("full words:  ", join(results, results_len, " ")));
}

int main(void) {
    user_main();
    return 0;
}
