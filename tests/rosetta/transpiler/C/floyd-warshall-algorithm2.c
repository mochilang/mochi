// Generated by Mochi 0.10.32 on 2025-08-01 17:57 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>

size_t path_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(int v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%d", v);
    return strdup(buf);
}

static int* list_append_int(int *arr, size_t *len, int val) {
    arr = realloc(arr, (*len + 1) * sizeof(int));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    struct mallinfo mi = mallinfo();
    return (long long)mi.uordblks;
}

typedef struct FWResult FWResult;

struct FWResult {
    int **dist;
    size_t dist_len;
    size_t *dist_lens;
    size_t dist_lens_len;
    int **next;
    size_t next_len;
    size_t *next_lens;
    size_t next_lens_len;
};

int INF = 1000000LL;
int n = 4LL;
int **g = NULL;
size_t g_len = 0;
size_t *g_lens = NULL;
size_t g_lens_len = 0;
int i = 0LL;

FWResult floydWarshall(int * * graph, size_t graph_len, size_t* graph_lens, size_t graph_lens_len);
int * path(int u, int v, int * * next, size_t next_len, size_t* next_lens, size_t next_lens_len);
const char* pathStr(int * p, size_t p_len);
int main(void);

FWResult floydWarshall(int * * graph, size_t graph_len, size_t* graph_lens, size_t graph_lens_len) {
    size_t n = graph_len;
    int **dist = NULL;
    size_t dist_len = 0;
    size_t *dist_lens = NULL;
    size_t dist_lens_len = 0;
    int **next = NULL;
    size_t next_len = 0;
    size_t *next_lens = NULL;
    size_t next_lens_len = 0;
    int i = 0LL;
    while (i < n) {
        int *drow = NULL;
        size_t drow_len = 0;
        int *nrow = NULL;
        size_t nrow_len = 0;
        int j = 0LL;
        while (j < n) {
            drow = list_append_int(drow, &drow_len, graph[(int)(i)][(int)(j)]);
            if ((graph[(int)(i)][(int)(j)] < INF) && (i != j)) {
                nrow = list_append_int(nrow, &nrow_len, j);
            } else {
                nrow = list_append_int(nrow, &nrow_len, -1LL);
            }
            j = j + 1LL;
        }
        dist = list_append_intptr(dist, &dist_len, drow);
        dist_lens = list_append_szt(dist_lens, &dist_lens_len, drow_len);
        next = list_append_intptr(next, &next_len, nrow);
        next_lens = list_append_szt(next_lens, &next_lens_len, nrow_len);
        i = i + 1LL;
    }
    int k = 0LL;
    while (k < n) {
        int i = 0LL;
        while (i < n) {
            int j = 0LL;
            while (j < n) {
                if ((dist[(int)(i)][(int)(k)] < INF) && (dist[(int)(k)][(int)(j)] < INF)) {
                    int alt = dist[(int)(i)][(int)(k)] + dist[(int)(k)][(int)(j)];
                    if (alt < dist[(int)(i)][(int)(j)]) {
                        dist[(int)(i)][(int)(j)] = alt;
                        next[(int)(i)][(int)(j)] = next[(int)(i)][(int)(k)];
                    }
                }
                j = j + 1LL;
            }
            i = i + 1LL;
        }
        k = k + 1LL;
    }
    return (FWResult){.dist = dist, .dist_len = dist_len, .next = next, .next_len = next_len};
}

int * path(int u, int v, int * * next, size_t next_len, size_t* next_lens, size_t next_lens_len) {
    if (next[(int)(u)][(int)(v)] < 0LL) {
        return path_len = 0, NULL;
    }
    int *p = NULL;
    size_t p_len = 0;
    p = list_append_int(p, &p_len, u);
    int x = u;
    while (x != v) {
        x = next[(int)(x)][(int)(v)];
        p = list_append_int(p, &p_len, x);
    }
    return path_len = p_len, p;
}

const char* pathStr(int * p, size_t p_len) {
    const char* s = "";
    int i = 0LL;
    while (i < p_len) {
        s = str_concat(s, str_int(p[(int)(i)] + 1LL));
        if (i < (p_len - 1LL)) {
            s = str_concat(s, " -> ");
        }
        i = i + 1LL;
    }
    return s;
}

int main(void) {
    {
        long long __start = _now();
        long long __mem_start = _mem();
        for (int i = 0LL; i < n; i++) {
            int *row = NULL;
            size_t row_len = 0;
            for (int j = 0LL; j < n; j++) {
                if (i == j) {
                    row = list_append_int(row, &row_len, 0LL);
                } else {
                    row = list_append_int(row, &row_len, INF);
                }
            }
            g = list_append_intptr(g, &g_len, row);
            g_lens = list_append_szt(g_lens, &g_lens_len, row_len);
        }
        g[(int)(0LL)][(int)(2LL)] = -2LL;
        g[(int)(2LL)][(int)(3LL)] = 2LL;
        g[(int)(3LL)][(int)(1LL)] = -1LL;
        g[(int)(1LL)][(int)(0LL)] = 4LL;
        g[(int)(1LL)][(int)(2LL)] = 3LL;
        FWResult res = floydWarshall(g, g_len, g_lens, g_len);
        puts("pair\tdist\tpath");
        while (i < n) {
            int j = 0LL;
            while (j < n) {
                if (i != j) {
                    int *p = path(i, j, res.next, res.next_len, res.next_lens, res.next_len);
                    size_t p_len = path_len;
                    puts(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_int(i + 1LL), " -> "), str_int(j + 1LL)), "\t"), str_int(res.dist[(int)(i)][(int)(j)])), "\t"), pathStr(p, p_len)));
                }
                j = j + 1LL;
            }
            i = i + 1LL;
        }
        long long __end = _now();
        long long __mem_end = _mem();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = __mem_end - __mem_start;
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
