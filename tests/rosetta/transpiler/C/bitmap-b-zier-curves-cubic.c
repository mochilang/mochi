// Generated by Mochi 0.10.32 on 2025-08-02 17:26 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>


typedef struct { const char **keys; const char **vals; size_t len; } MapSS;

static const char* map_get_ss(const char *keys[], const char *vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return "";
}

static int* list_append_int(int *arr, size_t *len, int val) {
    arr = realloc(arr, (*len + 1) * sizeof(int));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static int* list_append_int_new(const int *arr, size_t len, int val) {
    int *res = malloc((len + 1) * sizeof(int));
    if (arr && len) memcpy(res, arr, len * sizeof(int));
    res[len] = val;
    return res;
}

static int** list_append_intptr(int **arr, size_t *len, int *val) {
    arr = realloc(arr, (*len + 1) * sizeof(int*));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static const char*** list_append_strptr(const char ***arr, size_t *len, const char **val) {
    arr = realloc(arr, (*len + 1) * sizeof(const char**));
    arr[*len] = val;
    (*len)++;
    return arr;
}

static size_t* list_append_szt(size_t *arr, size_t *len, size_t val) {
    arr = realloc(arr, (*len + 1) * sizeof(size_t));
    arr[*len] = val;
    (*len)++;
    return arr;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    struct mallinfo mi = mallinfo();
    return (long long)mi.uordblks;
}

typedef struct Anon1 Anon1;
typedef struct Pixel Pixel;

struct Anon1 {
    int cols;
    int rows;
    int data;
};

struct Pixel {
    int r;
    int g;
    int b;
};

int b3Seg = 30LL;
Anon1 b = 0;

Pixel pixelFromRgb(int rgb);
Anon1 newBitmap(int cols, int rows);
void setPx(MapSS b, int x, int y, Pixel p);
void fill(MapSS b, Pixel p);
void fillRgb(MapSS b, int rgb);
void line(MapSS b, int x0, int y0, int x1, int y1, Pixel p);
void bezier3(MapSS b, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, Pixel p);
int main(void);

Pixel pixelFromRgb(int rgb) {
    int r = (rgb / 65536LL) % 256LL;
    int g = (rgb / 256LL) % 256LL;
    int b = rgb % 256LL;
    return (Pixel){.r = r, .g = g, .b = b};
}

Anon1 newBitmap(int cols, int rows) {
    Pixel **d = NULL;
    size_t d_len = 0;
    size_t *d_lens = NULL;
    size_t d_lens_len = 0;
    int y = 0LL;
    while (y < rows) {
        Pixel *row = NULL;
        size_t row_len = 0;
        int x = 0LL;
        while (x < cols) {
                        row = list_append_int_new(row, row_len, (Pixel){.r = 0LL, .g = 0LL, .b = 0LL});
            x = x + 1LL;
        }
        d = list_append_strptr(d, &d_len, row);
        d_lens = list_append_szt(d_lens, &d_lens_len, row_len);
        y = y + 1LL;
    }
    return (Anon1){.cols = cols, .rows = rows, .data = d};
}

void setPx(MapSS b, int x, int y, Pixel p) {
    int cols = b.cols;
    int rows = b.rows;
    if ((((x >= 0LL) && (x < cols)) && (y >= 0LL)) && (y < rows)) {
        b[(int)("data")][(int)(y)][(int)(x)] = p;
    }
}

void fill(MapSS b, Pixel p) {
    int cols = b.cols;
    int rows = b.rows;
    int y = 0LL;
    while (y < rows) {
        int x = 0LL;
        while (x < cols) {
            b[(int)("data")][(int)(y)][(int)(x)] = p;
            x = x + 1LL;
        }
        y = y + 1LL;
    }
}

void fillRgb(MapSS b, int rgb) {
    fill(b, pixelFromRgb(rgb));
}

void line(MapSS b, int x0, int y0, int x1, int y1, Pixel p) {
    int dx = x1 - x0;
    if (dx < 0LL) {
        dx = -(dx);
    }
    int dy = y1 - y0;
    if (dy < 0LL) {
        dy = -(dy);
    }
    int sx = -1LL;
    if (x0 < x1) {
        sx = 1LL;
    }
    int sy = -1LL;
    if (y0 < y1) {
        sy = 1LL;
    }
    int err = dx - dy;
    while (1LL) {
        setPx(b, x0, y0, p);
        if ((x0 == x1) && (y0 == y1)) {
            break;
        }
        int e2 = 2LL * err;
        if (e2 > (0LL - dy)) {
            err = err - dy;
            x0 = x0 + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
    }
}

void bezier3(MapSS b, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, Pixel p) {
    int *px = NULL;
    size_t px_len = 0;
    int *py = NULL;
    size_t py_len = 0;
    int i = 0LL;
    while (i <= b3Seg) {
        px = list_append_int(px, &px_len, 0LL);
        py = list_append_int(py, &py_len, 0LL);
        i = i + 1LL;
    }
    double fx1 = (double)(x1);
    double fy1 = (double)(y1);
    double fx2 = (double)(x2);
    double fy2 = (double)(y2);
    double fx3 = (double)(x3);
    double fy3 = (double)(y3);
    double fx4 = (double)(x4);
    double fy4 = (double)(y4);
    i = 0LL;
    while (i <= b3Seg) {
        double d = (double)(i) / (double)(b3Seg);
        double a = 1.0 - d;
        double bcoef = a * a;
        double ccoef = d * d;
        double a2 = a * bcoef;
        double b2 = (3.0 * bcoef) * d;
        double c2 = (3.0 * a) * ccoef;
        double d2 = ccoef * d;
        px[(int)(i)] = (((a2 * fx1) + (b2 * fx2)) + (c2 * fx3)) + (d2 * fx4);
        py[(int)(i)] = (((a2 * fy1) + (b2 * fy2)) + (c2 * fy3)) + (d2 * fy4);
        i = i + 1LL;
    }
    int x0 = px[(int)(0LL)];
    int y0 = py[(int)(0LL)];
    i = 1LL;
    while (i <= b3Seg) {
        int x = px[(int)(i)];
        int y = py[(int)(i)];
        line(b, x0, y0, x, y, p);
        x0 = x;
        y0 = y;
        i = i + 1LL;
    }
}

int main(void) {
    {
        long long __start = _now();
        long long __mem_start = _mem();
        b = newBitmap(400LL, 300LL);
        fillRgb((MapSS)b, 16773055LL);
        bezier3((MapSS)b, 20LL, 200LL, 700LL, 50LL, -300LL, 50LL, 380LL, 150LL, pixelFromRgb(4165615LL));
        long long __end = _now();
        long long __mem_end = _mem();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = __mem_end - __mem_start;
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
