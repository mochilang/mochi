// Generated by Mochi 0.10.32 on 2025-07-27 18:13 +0700
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>

size_t parseDate_len;
size_t addDays_len;

static char* str_concat(const char *a, const char *b) {
    size_t len1 = strlen(a);
    size_t len2 = strlen(b);
    char *res = malloc(len1 + len2 + 1);
    memcpy(res, a, len1);
    memcpy(res + len1, b, len2);
    res[len1 + len2] = 0;
    return res;
}

static char* str_int(int v) {
    char buf[32];
    snprintf(buf, sizeof(buf), "%d", v);
    return strdup(buf);
}

static char* str_float(double v) {
    char buf[64];
    snprintf(buf, sizeof(buf), "%g", v);
    return strdup(buf);
}

static int map_get_si(const char *keys[], const int vals[], size_t len, const char *key) {
    for (size_t i = 0; i < len; i++) {
        if (strcmp(keys[i], key) == 0) return vals[i];
    }
    return 0;
}

#include <time.h>
#include <stdlib.h>
static int seeded_now = 0;
static long long now_seed = 0;
static long long _now(void) {
    if (!seeded_now) {
        const char *s = getenv("MOCHI_NOW_SEED");
        if (s && *s) {
            now_seed = atoll(s);
            seeded_now = 1;
        }
    }
    if (seeded_now) {
        now_seed = (now_seed * 1664525 + 1013904223) % 2147483647;
        return now_seed;
    }
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (long long)(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

static long long _mem(void) {
    struct mallinfo mi = mallinfo();
    return (long long)mi.uordblks;
}

static const char* _substring(const char *s, int start, int end) {
    int len = (int)strlen(s);
    if (start < 0) start = 0;
    if (end > len) end = len;
    if (start > end) start = end;
    char *res = malloc(end - start + 1);
    memcpy(res, s + start, end - start);
    res[end - start] = 0;
    return res;
}

double PI = 3.141592653589793;
double TWO_PI = 6.283185307179586;

double sinApprox(double x);
double floor(double x);
double absFloat(double x);
int absInt(int n);
int parseIntStr(const char* str);
int * parseDate(const char* s);
int leap(int y);
int daysInMonth(int y, int m);
int * addDays(int y, int m, int d, int n);
const char* pad2(int n);
const char* dateString(int y, int m, int d);
int day(int y, int m, int d);
int biorhythms(const char* birth, const char* target);
int user_main();
int main(void);

double sinApprox(double x) {
    double term = x;
    double sum = x;
    int n = 1;
    while (n <= 8) {
        double denom = (2 * n) * ((2 * n) + 1);
        term = ((-(term) * x) * x) / denom;
        sum = sum + term;
        n = n + 1;
    }
    return sum;
}

double floor(double x) {
    int i = (int)(x);
    if ((double)(i) > x) {
        i = i - 1;
    }
    return (double)(i);
}

double absFloat(double x) {
    if (x < 0) {
        return -(x);
    }
    return x;
}

int absInt(int n) {
    if (n < 0) {
        return -(n);
    }
    return n;
}

int parseIntStr(const char* str) {
    int i = 0;
    int neg = 0;
    if ((strlen(str) > 0) && (strcmp(_substring(str, 0, 1), "-") == 0)) {
        neg = 1;
        i = 1;
    }
    int n = 0;
    const char* digits_keys[26] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};
    int digits_vals[26] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    size_t digits_len = 10;
    while (i < strlen(str)) {
        n = (n * 10) + map_get_si(digits_keys, digits_vals, digits_len, _substring(str, i, i + 1));
        i = i + 1;
    }
    if (neg) {
        n = -(n);
    }
    return n;
}

int * parseDate(const char* s) {
    int y = parseIntStr(_substring(s, 0, 4));
    int m = parseIntStr(_substring(s, 5, 7));
    int d = parseIntStr(_substring(s, 8, 10));
    return parseDate_len = 3, (int[]){ y, m, d };
}

int leap(int y) {
    if ((y % 400) == 0) {
        return 1;
    }
    if ((y % 100) == 0) {
        return 0;
    }
    return (y % 4) == 0;
}

int daysInMonth(int y, int m) {
    int feb = (leap(y) ? 29 : 28);
    int lengths[12] = {31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    size_t lengths_len = 12;
    return lengths[m - 1];
}

int * addDays(int y, int m, int d, int n) {
    int yy = y;
    int mm = m;
    int dd = d;
    if (n >= 0) {
        int i = 0;
        while (i < n) {
            dd = dd + 1;
            if (dd > daysInMonth(yy, mm)) {
                dd = 1;
                mm = mm + 1;
                if (mm > 12) {
                    mm = 1;
                    yy = yy + 1;
                }
            }
            i = i + 1;
        }
    } else {
        int i = 0;
        while (i > n) {
            dd = dd - 1;
            if (dd < 1) {
                mm = mm - 1;
                if (mm < 1) {
                    mm = 12;
                    yy = yy - 1;
                }
                dd = daysInMonth(yy, mm);
            }
            i = i - 1;
        }
    }
    return addDays_len = 3, (int[]){ yy, mm, dd };
}

const char* pad2(int n) {
    if (n < 10) {
        return str_concat("0", str_int(n));
    }
    return str_int(n);
}

const char* dateString(int y, int m, int d) {
    return str_concat(str_concat(str_concat(str_concat(str_int(y), "-"), pad2(m)), "-"), pad2(d));
}

int day(int y, int m, int d) {
    int part1 = 367 * y;
    int part2 = (7 * (y + ((m + 9) / 12))) / 4;
    int part3 = (275 * m) / 9;
    return (((part1 - part2) + part3) + d) - 730530;
}

int biorhythms(const char* birth, const char* target) {
    int *bparts = parseDate(birth);
    size_t bparts_len = parseDate_len;
    int by = bparts[0];
    int bm = bparts[1];
    int bd = bparts[2];
    int *tparts = parseDate(target);
    size_t tparts_len = parseDate_len;
    int ty = tparts[0];
    int tm = tparts[1];
    int td = tparts[2];
    int diff = absInt(day(ty, tm, td) - day(by, bm, bd));
    puts(str_concat(str_concat(str_concat("Born ", birth), ", Target "), target));
    puts(str_concat("Day ", str_int(diff)));
    const char* cycles[3] = {"Physical day ", "Emotional day", "Mental day   "};
    size_t cycles_len = 3;
    int lengths[3] = {23, 28, 33};
    size_t lengths_len = 3;
    const char* quadrants[4][2] = {{"up and rising", "peak"}, {"up but falling", "transition"}, {"down and falling", "valley"}, {"down but rising", "transition"}};
    size_t quadrants_len = 4;
    size_t quadrants_lens[] = {2, 2, 2, 2};
    size_t quadrants_lens_len = 4;
    int i = 0;
    while (i < 3) {
        int length = lengths[i];
        const char* cycle = cycles[i];
        int position = diff % length;
        int quadrant = (position * 4) / length;
        double percent = sinApprox(((2 * PI) * (double)(position)) / (double)(length));
        percent = floor(percent * 1000) / 10;
        const char* description = "";
        if (percent > 95) {
            description = " peak";
        } else {
            if (percent < -(95)) {
                description = " valley";
            } else {
                if (absFloat(percent) < 5) {
                    description = " critical transition";
                } else {
                    int daysToAdd = (((quadrant + 1) * length) / 4) - position;
                    int *res = addDays(ty, tm, td, daysToAdd);
                    size_t res_len = addDays_len;
                    int ny = res[0];
                    int nm = res[1];
                    int nd = res[2];
                    const char* transition = dateString(ny, nm, nd);
                    const char* trend = quadrants[quadrant][0];
                    const char* next = quadrants[quadrant][1];
                    const char* pct = str_float(percent);
                    if (!(strstr(pct, ".") != NULL)) {
                        pct = str_concat(pct, ".0");
                    }
                    description = str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(str_concat(" ", pct), "% ("), trend), ", next "), next), " "), transition), ")");
                }
            }
        }
        const char* posStr = str_int(position);
        if (position < 10) {
            posStr = str_concat(" ", posStr);
        }
        puts(str_concat(str_concat(str_concat(cycle, posStr), " : "), description));
        i = i + 1;
    }
    puts("");
}

int user_main() {
    const char* pairs[3][2] = {{"1943-03-09", "1972-07-11"}, {"1809-01-12", "1863-11-19"}, {"1809-02-12", "1863-11-19"}};
    size_t pairs_len = 3;
    size_t pairs_lens[] = {2, 2, 2};
    size_t pairs_lens_len = 3;
    int idx = 0;
    while (idx < pairs_len) {
        const char* *p = pairs[idx];
        size_t p_len = pairs_lens[idx];
        biorhythms(p[0], p[1]);
        idx = idx + 1;
    }
}

int main(void) {
    {
        long long __start = _now();
        long long __mem_start = _mem();
        user_main();
        long long __end = _now();
        long long __mem_end = _mem();
        long long __dur_us = (__end - __start) / 1000;
        long long __mem_bytes = __mem_end - __mem_start;
        printf("{\n  \"duration_us\": %-lld,\n  \"memory_bytes\": %-lld,\n  \"name\": \"main\"\n}\n", __dur_us, __mem_bytes);
    }
    return 0;
}
