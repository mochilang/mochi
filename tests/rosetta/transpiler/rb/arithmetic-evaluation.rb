# Generated by Mochi transpiler v0.10.42 on 2025-07-28 00:12 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def parseIntStr(str, base = 10)
  str.to_i(base)
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def skipWS(p)
    i = p.pos
    while i < p.expr.length && p.expr[i..._add(i, 1)] == " "
      i = _add(i, 1)
    end
    p["pos"] = i
    return p
  end
  def parseIntStr(str)
    i = 0
    n = 0
    while i < str.length
      n = _add(n * 10, ((str[i..._add(i, 1)]).to_i)) - 48
      i = _add(i, 1)
    end
    return n
  end
  def parseNumber(p)
    p = skipWS(p)
    start = p.pos
    while p.pos < p.expr.length
      ch = p.expr[p.pos..._add(p.pos, 1)]
      if ch >= "0" && ch <= "9"
        p["pos"] = _add(p.pos, 1)
      else
        break
      end
    end
    token = p.expr[start...p.pos]
    return Res.new(v: parseIntStr(token), p: p)
  end
  def parseFactor(p)
    p = skipWS(p)
    if p.pos < p.expr.length && p.expr[p.pos..._add(p.pos, 1)] == "("
      p["pos"] = _add(p.pos, 1)
      r = parseExpr(p)
      v = r.v
      p = r.p
      p = skipWS(p)
      if p.pos < p.expr.length && p.expr[p.pos..._add(p.pos, 1)] == ")"
        p["pos"] = _add(p.pos, 1)
      end
      return Res.new(v: v, p: p)
    end
    if p.pos < p.expr.length && p.expr[p.pos..._add(p.pos, 1)] == "-"
      p["pos"] = _add(p.pos, 1)
      r = parseFactor(p)
      v = r.v
      p = r.p
      return Res.new(v: -v, p: p)
    end
    return parseNumber(p)
  end
  def powInt(base, exp)
    r = 1
    b = base
    e = exp
    while e > 0
      if e % 2 == 1
        r = r * b
      end
      b = b * b
      e = e / (2).to_i
    end
    return r
  end
  def parsePower(p)
    r = parseFactor(p)
    v = r.v
    p = r.p
    while true
      p = skipWS(p)
      if p.pos < p.expr.length && p.expr[p.pos..._add(p.pos, 1)] == "^"
        p["pos"] = _add(p.pos, 1)
        r2 = parseFactor(p)
        rhs = r2.v
        p = r2.p
        v = powInt(v, rhs)
      else
        break
      end
    end
    return Res.new(v: v, p: p)
  end
  def parseTerm(p)
    r = parsePower(p)
    v = r.v
    p = r.p
    while true
      p = skipWS(p)
      if p.pos < p.expr.length
        op = p.expr[p.pos..._add(p.pos, 1)]
        if op == "*"
          p["pos"] = _add(p.pos, 1)
          r2 = parsePower(p)
          rhs = r2.v
          p = r2.p
          v = v * rhs
          next
        end
        if op == "/"
          p["pos"] = _add(p.pos, 1)
          r2 = parsePower(p)
          rhs = r2.v
          p = r2.p
          v = v / (rhs).to_i
          next
        end
      end
      break
    end
    return Res.new(v: v, p: p)
  end
  def parseExpr(p)
    r = parseTerm(p)
    v = r.v
    p = r.p
    while true
      p = skipWS(p)
      if p.pos < p.expr.length
        op = p.expr[p.pos..._add(p.pos, 1)]
        if op == "+"
          p["pos"] = _add(p.pos, 1)
          r2 = parseTerm(p)
          rhs = r2.v
          p = r2.p
          v = _add(v, rhs)
          next
        end
        if op == "-"
          p["pos"] = _add(p.pos, 1)
          r2 = parseTerm(p)
          rhs = r2.v
          p = r2.p
          v = v - rhs
          next
        end
      end
      break
    end
    return Res.new(v: v, p: p)
  end
  def evalExpr(expr)
    p = Parser.new(expr: expr, pos: 0)
    r = parseExpr(p)
    return r.v
  end
  def main()
    expr = "2*(3-1)+2*5"
    puts(_add(_add(expr, " = "), (evalExpr(expr)).to_s))
  end
  Parser = Struct.new(:expr, :pos, keyword_init: true)
  Res = Struct.new(:v, :p, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
