# Generated by Mochi transpiler v0.10.40 on 2025-07-25 21:36 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def parseIntStr(str, base = 10)
  str.to_i(base)
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  $PI = 3.141592653589793
  $TWO_PI = 6.283185307179586
  def sinApprox(x)
    term = x
    sum = x
    n = 1
    while n <= 8
      denom = (((2 * n) * (_add(2 * n, 1)))).to_f
      term = -term * x * x / denom
      sum = _add(sum, term)
      n = _add(n, 1)
    end
    return sum
  end
  def floor(x)
    i = (x).to_i
    if ((i).to_f) > x
      i = i - 1
    end
    return (i).to_f
  end
  def absFloat(x)
    if x < 0.0
      return -x
    end
    return x
  end
  def absInt(n)
    if n < 0
      return -n
    end
    return n
  end
  def parseIntStr(str)
    i = 0
    neg = false
    if str.length > 0 && str[0...1] == "-"
      neg = true
      i = 1
    end
    n = 0
    digits = {"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
    while i < str.length
      n = _add(n * 10, digits[str[i..._add(i, 1)]])
      i = _add(i, 1)
    end
    if neg
      n = -n
    end
    return n
  end
  def parseDate(s)
    y = parseIntStr(s[0...4])
    m = parseIntStr(s[5...7])
    d = parseIntStr(s[8...10])
    return [y, m, d]
  end
  def leap(y)
    if y % 400 == 0
      return true
    end
    if y % 100 == 0
      return false
    end
    return y % 4 == 0
  end
  def daysInMonth(y, m)
    feb = (leap(y) ? 29 : 28)
    lengths = [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    return lengths[m - 1]
  end
  def addDays(y, m, d, n)
    yy = y
    mm = m
    dd = d
    if n >= 0
      i = 0
      while i < n
        dd = _add(dd, 1)
        if dd > daysInMonth(yy, mm)
          dd = 1
          mm = _add(mm, 1)
          if mm > 12
            mm = 1
            yy = _add(yy, 1)
          end
        end
        i = _add(i, 1)
      end
    else
      i = 0
      while i > n
        dd = dd - 1
        if dd < 1
          mm = mm - 1
          if mm < 1
            mm = 12
            yy = yy - 1
          end
          dd = daysInMonth(yy, mm)
        end
        i = i - 1
      end
    end
    return [yy, mm, dd]
  end
  def pad2(n)
    if n < 10
      return _add("0", (n).to_s)
    end
    return (n).to_s
  end
  def dateString(y, m, d)
    return _add(_add(_add(_add((y).to_s, "-"), pad2(m)), "-"), pad2(d))
  end
  def day(y, m, d)
    part1 = 367 * y
    part2 = (((7 * (((_add(y, ((_add(m, 9)) / 12)))).to_i)) / 4)).to_i
    part3 = (((275 * m) / 9)).to_i
    return _add(_add(part1 - part2, part3), d) - 730530
  end
  def biorhythms(birth, target)
    bparts = parseDate(birth)
    by = bparts[0]
    bm = bparts[1]
    bd = bparts[2]
    tparts = parseDate(target)
    ty = tparts[0]
    tm = tparts[1]
    td = tparts[2]
    diff = absInt(day(ty, tm, td) - day(by, bm, bd))
    puts(_add(_add(_add("Born ", birth), ", Target "), target))
    puts(_add("Day ", (diff).to_s))
    cycles = ["Physical day ", "Emotional day", "Mental day   "]
    lengths = [23, 28, 33]
    quadrants = [["up and rising", "peak"], ["up but falling", "transition"], ["down and falling", "valley"], ["down but rising", "transition"]]
    i = 0
    while i < 3
      length = lengths[i]
      cycle = cycles[i]
      position = diff % length
      quadrant = (position * 4) / length
      percent = sinApprox(2.0 * $PI * ((position).to_f) / ((length).to_f))
      percent = floor(percent * 1000.0) / 10.0
      description = ""
      if percent > 95.0
        description = " peak"
      else
        if percent < (-95.0)
          description = " valley"
        else
          if absFloat(percent) < 5.0
            description = " critical transition"
          else
            daysToAdd = (_add(quadrant, 1)) * length / 4 - position
            res = addDays(ty, tm, td, daysToAdd)
            ny = res[0]
            nm = res[1]
            nd = res[2]
            transition = dateString(ny, nm, nd)
            trend = quadrants[quadrant][0]
            next_ = quadrants[quadrant][1]
            pct = (percent).to_s
            if !pct.include?(".")
              pct = _add(pct, ".0")
            end
            description = _add(_add(_add(_add(_add(_add(_add(_add(" ", pct), "% ("), trend), ", next "), next_), " "), transition), ")")
          end
        end
      end
      posStr = (position).to_s
      if position < 10
        posStr = _add(" ", posStr)
      end
      puts(_add(_add(_add(cycle, posStr), " : "), description))
      i = _add(i, 1)
    end
    puts("")
  end
  def main()
    pairs = [["1943-03-09", "1972-07-11"], ["1809-01-12", "1863-11-19"], ["1809-02-12", "1863-11-19"]]
    idx = 0
    while idx < pairs.length
      p = pairs[idx]
      biorhythms(p[0], p[1])
      idx = _add(idx, 1)
    end
  end
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
