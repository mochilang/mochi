# Generated by Mochi transpiler v0.10.40 on 2025-07-25 10:39 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def fields(s)
    words = []
    cur = ""
    i = 0
    while i < s.length
      ch = s[i..._add(i, 1)]
      if ch == " " || ch == "\n" || ch == "\t"
        if cur.length > 0
          words = words + [cur]
          cur = ""
        end
      else
        cur = _add(cur, ch)
      end
      i = _add(i, 1)
    end
    if cur.length > 0
      words = words + [cur]
    end
    return words
  end
  def padRight(s, width)
    out = s
    i = s.length
    while i < width
      out = _add(out, " ")
      i = _add(i, 1)
    end
    return out
  end
  def join(xs, sep)
    res = ""
    i = 0
    while i < xs.length
      if i > 0
        res = _add(res, sep)
      end
      res = _add(res, xs[i])
      i = _add(i, 1)
    end
    return res
  end
  def validate(commands, words, mins)
    results = []
    if words.length == 0
      return results
    end
    wi = 0
    while wi < words.length
      w = words[wi]
      found = false
      wlen = w.length
      ci = 0
      while ci < commands.length
        cmd = commands[ci]
        if mins[ci] != 0 && wlen >= mins[ci] && wlen <= cmd.length
          c = cmd.upcase()
          ww = w.upcase()
          if c[0...wlen] == ww
            results = results + [c]
            found = true
            break
          end
        end
        ci = _add(ci, 1)
      end
      if !found
        results = results + ["*error*"]
      end
      wi = _add(wi, 1)
    end
    return results
  end
  def main()
    table = _add(_add(_add(_add(_add(_add("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy ", "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find "), "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "), " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "), "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "), "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "), "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp ")
    commands = fields(table)
    mins = []
    i = 0
    while i < commands.length
      count = 0
      j = 0
      cmd = commands[i]
      while j < cmd.length
        ch = cmd[j..._add(j, 1)]
        if ch >= "A" && ch <= "Z"
          count = _add(count, 1)
        end
        j = _add(j, 1)
      end
      mins = mins + [count]
      i = _add(i, 1)
    end
    sentence = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"
    words = fields(sentence)
    results = validate(commands, words, mins)
    out1 = "user words:  "
    k = 0
    while k < words.length
      out1 = _add(_add(out1, padRight(words[k], results[k].length)), " ")
      k = _add(k, 1)
    end
    puts(out1)
    puts(_add("full words:  ", join(results, " ")))
  end
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
