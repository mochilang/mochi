# Generated by Mochi transpiler v0.10.54 on 2025-08-02 15:25 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _repeat(s, n)
  s * n.to_i
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def pow10(n)
    r = 1.0
    i = 0
    while i < n
      r = r * 10.0
      i = _add(i, 1)
    end
    return r
  end
  def formatFloat(f, prec)
    scale = pow10(prec)
    scaled = _add((f * scale), 0.5)
    n = ((scaled).to_i)
    digits = (n).to_s
    while digits.length <= prec
      digits = _add("0", digits)
    end
    intPart = digits[0...digits.length - prec]
    fracPart = digits[digits.length - prec...digits.length]
    return _add(_add(intPart, "."), fracPart)
  end
  def padLeft(s, w)
    res = ""
    n = w - s.length
    while n > 0
      res = _add(res, " ")
      n = n - 1
    end
    return _add(res, s)
  end
  def repeat(ch, n)
    s = ""
    i = 0
    while i < n
      s = _add(s, ch)
      i = _add(i, 1)
    end
    return s
  end
  def toFloat(i)
    return (i).to_f
  end
  def newNode(name, weight, coverage)
    return {"name" => name, "weight" => weight, "coverage" => coverage, "children" => []}
  end
  def addChildren(n, nodes)
    cs = n["children"]
    nodes.each do |node|
      cs = cs + [node]
    end
    n["children"] = cs
  end
  def setCoverage(n, value)
    n["coverage"] = value
  end
  def computeCoverage(n)
    cs = n["children"]
    if cs.length == 0
      return (n["coverage"]).to_f
    end
    v1 = 0.0
    v2 = 0
    cs.each do |node|
      m = node
      c = computeCoverage(m)
      v1 = _add(v1, toFloat((m["weight"]).to_i) * c)
      v2 = _add(v2, ((m["weight"]).to_i))
    end
    return v1 / toFloat(v2)
  end
  def spaces(n)
    return _repeat(" ", n)
  end
  def show(n, level)
    indent = level * 4
    name = (n["name"]).to_s
    nl = _add(name.length, indent)
    line = _add(spaces(indent), name)
    line = _add(_add(line, spaces(32 - nl)), "|  ")
    line = _add(_add(line, padLeft(((n["weight"]).to_i).to_s, 3)), "   | ")
    line = _add(_add(line, formatFloat(computeCoverage(n), 6)), " |")
    puts(line)
    cs = n["children"]
    cs.each do |child|
      show(child, _add(level, 1))
    end
  end
  def main()
    cleaning = newNode("cleaning", 1, 0.0)
    addChildren($h1_bathrooms, [$h1_bathroom1, $h1_bathroom2, $h1_outside])
    addChildren($h1_living_rooms, [$h1_lounge, $h1_dining, $h1_conservatory, $h1_playroom])
    addChildren($house1, [$h1_bedrooms, $h1_bathrooms, $h1_attic, $h1_kitchen, $h1_living_rooms, $h1_basement, $h1_garage, $h1_garden])
    addChildren($h2_bedrooms, [$h2_suite1, $h2_suite2, $h2_bedroom3, $h2_bedroom4])
    addChildren($h2_upstairs, [$h2_bedrooms, $h2_bathroom, $h2_toilet, $h2_attics])
    addChildren($h2_living_rooms, [$h2_lounge, $h2_dining, $h2_conservatory, $h2_playroom])
    addChildren($h2_groundfloor, [$h2_kitchen, $h2_living_rooms, $h2_wet_room, $h2_garage, $h2_garden, $h2_hot_tub])
    addChildren($h2_basement, [$h2_cellars, $h2_wine_cellar, $h2_cinema])
    addChildren($house2, [$h2_upstairs, $h2_groundfloor, $h2_basement])
    addChildren(cleaning, [$house1, $house2])
    topCoverage = computeCoverage(cleaning)
    puts(_add("TOP COVERAGE = ", formatFloat(topCoverage, 6)))
    puts("")
    puts("NAME HIERARCHY                 | WEIGHT | COVERAGE |")
    show(cleaning, 0)
    setCoverage($h2_cinema, 1.0)
    diff = computeCoverage(cleaning) - topCoverage
    puts("")
    puts("If the coverage of the Cinema node were increased from 0.75 to 1")
    puts(_add(_add(_add("the top level coverage would increase by ", formatFloat(diff, 6)), " to "), formatFloat(_add(topCoverage, diff), 6)))
    setCoverage($h2_cinema, 0.75)
  end
  $house1 = newNode("house1", 40, 0.0)
  $house2 = newNode("house2", 60, 0.0)
  $h1_bedrooms = newNode("bedrooms", 1, 0.25)
  $h1_bathrooms = newNode("bathrooms", 1, 0.0)
  $h1_attic = newNode("attic", 1, 0.75)
  $h1_kitchen = newNode("kitchen", 1, 0.1)
  $h1_living_rooms = newNode("living_rooms", 1, 0.0)
  $h1_basement = newNode("basement", 1, 0.0)
  $h1_garage = newNode("garage", 1, 0.0)
  $h1_garden = newNode("garden", 1, 0.8)
  $h2_upstairs = newNode("upstairs", 1, 0.0)
  $h2_groundfloor = newNode("groundfloor", 1, 0.0)
  $h2_basement = newNode("basement", 1, 0.0)
  $h1_bathroom1 = newNode("bathroom1", 1, 0.5)
  $h1_bathroom2 = newNode("bathroom2", 1, 0.0)
  $h1_outside = newNode("outside_lavatory", 1, 1.0)
  $h1_lounge = newNode("lounge", 1, 0.0)
  $h1_dining = newNode("dining_room", 1, 0.0)
  $h1_conservatory = newNode("conservatory", 1, 0.0)
  $h1_playroom = newNode("playroom", 1, 1.0)
  $h2_bedrooms = newNode("bedrooms", 1, 0.0)
  $h2_bathroom = newNode("bathroom", 1, 0.0)
  $h2_toilet = newNode("toilet", 1, 0.0)
  $h2_attics = newNode("attics", 1, 0.6)
  $h2_kitchen = newNode("kitchen", 1, 0.0)
  $h2_living_rooms = newNode("living_rooms", 1, 0.0)
  $h2_wet_room = newNode("wet_room_&_toilet", 1, 0.0)
  $h2_garage = newNode("garage", 1, 0.0)
  $h2_garden = newNode("garden", 1, 0.9)
  $h2_hot_tub = newNode("hot_tub_suite", 1, 1.0)
  $h2_cellars = newNode("cellars", 1, 1.0)
  $h2_wine_cellar = newNode("wine_cellar", 1, 1.0)
  $h2_cinema = newNode("cinema", 1, 0.75)
  $h2_suite1 = newNode("suite_1", 1, 0.0)
  $h2_suite2 = newNode("suite_2", 1, 0.0)
  $h2_bedroom3 = newNode("bedroom_3", 1, 0.0)
  $h2_bedroom4 = newNode("bedroom_4", 1, 0.0)
  $h2_lounge = newNode("lounge", 1, 0.0)
  $h2_dining = newNode("dining_room", 1, 0.0)
  $h2_conservatory = newNode("conservatory", 1, 0.0)
  $h2_playroom = newNode("playroom", 1, 0.0)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
