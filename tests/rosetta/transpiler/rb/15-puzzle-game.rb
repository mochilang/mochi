# Generated by Mochi transpiler v0.10.42 on 2025-07-27 16:37 +0000
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _input()
  line = STDIN.gets
  line ? line.chomp : ''
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def randMove()
    return _now() % 4
  end
  def isSolved()
    i = 0
    while i < 16
      if $board[i] != $solved[i]
        return false
      end
      i = _add(i, 1)
    end
    return true
  end
  def isValidMove(m)
    if m == 0
      return MoveResult.new(idx: $empty - 4, ok: $empty / 4 > 0)
    end
    if m == 1
      return MoveResult.new(idx: _add($empty, 4), ok: $empty / 4 < 3)
    end
    if m == 2
      return MoveResult.new(idx: _add($empty, 1), ok: $empty % 4 < 3)
    end
    if m == 3
      return MoveResult.new(idx: $empty - 1, ok: $empty % 4 > 0)
    end
    return MoveResult.new(idx: 0, ok: false)
  end
  def doMove(m)
    r = isValidMove(m)
    if !r.ok
      return false
    end
    i = $empty
    j = r.idx
    tmp = $board[i]
    $board[i] = $board[j]
    $board[j] = tmp
    $empty = j
    $moves = _add($moves, 1)
    return true
  end
  def shuffle(n)
    i = 0
    while i < n || isSolved()
      if doMove(randMove())
        i = _add(i, 1)
      end
    end
  end
  def printBoard()
    line = ""
    i = 0
    while i < 16
      val = $board[i]
      if val == 0
        line = _add(line, "  .")
      else
        s = (val).to_s
        if val < 10
          line = _add(_add(line, "  "), s)
        else
          line = _add(_add(line, " "), s)
        end
      end
      if i % 4 == 3
        puts(line)
        line = ""
      end
      i = _add(i, 1)
    end
  end
  def playOneMove()
    while true
      puts(_add(_add("Enter move #", (_add($moves, 1)).to_s), " (U, D, L, R, or Q): "))
      s = _input()
      if s == ""
        next
      end
      c = s[0...1]
      m = 0
      if c == "U" || c == "u"
        m = 0
      else
        if c == "D" || c == "d"
          m = 1
        else
          if c == "R" || c == "r"
            m = 2
          else
            if c == "L" || c == "l"
              m = 3
            else
              if c == "Q" || c == "q"
                puts(_add(_add("Quiting after ", ($moves).to_s), " moves."))
                $quit = true
                return
              else
                puts(_add(_add(_add("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n", "up, down, left, or right. You can also enter \"Q\" to quit.\n"), "Upper or lowercase is accepted and only the first non-blank\n"), "character is important (i.e. you may enter \"up\" if you like)."))
                next
              end
            end
          end
        end
      end
      if !doMove(m)
        puts("That is not a valid move at the moment.")
        next
      end
      return
    end
  end
  def play()
    puts("Starting board:")
    while !$quit && isSolved() == false
      puts("")
      printBoard()
      playOneMove()
    end
    if isSolved()
      puts(_add(_add("You solved the puzzle in ", ($moves).to_s), " moves."))
    end
  end
  def main()
    shuffle(50)
    play()
  end
  $board = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
  $solved = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]
  $empty = 15
  $moves = 0
  $quit = false
  MoveResult = Struct.new(:idx, :ok, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
