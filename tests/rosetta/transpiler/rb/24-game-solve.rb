# Generated by Mochi transpiler v0.10.37 on 2025-07-23 09:33 +0700

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end

$OP_NUM = 0
$OP_ADD = 1
$OP_SUB = 2
$OP_MUL = 3
$OP_DIV = 4
def newNum(n)
  return {"op" => $OP_NUM, "value" => {"num" => n, "denom" => 1}}
end
def exprEval(x)
  if x["op"] == $OP_NUM
    return x["value"]
  end
  l = exprEval(x["left"])
  r = exprEval(x["right"])
  if x["op"] == $OP_ADD
    return {"num" => l["num"] * r["denom"] + l["denom"] * r["num"], "denom" => l["denom"] * r["denom"]}
  end
  if x["op"] == $OP_SUB
    return {"num" => l["num"] * r["denom"] - l["denom"] * r["num"], "denom" => l["denom"] * r["denom"]}
  end
  if x["op"] == $OP_MUL
    return {"num" => l["num"] * r["num"], "denom" => l["denom"] * r["denom"]}
  end
  return {"num" => l["num"] * r["denom"], "denom" => l["denom"] * r["num"]}
end
def exprString(x)
  if x["op"] == $OP_NUM
    return (x["value"]["num"]).to_s
  end
  ls = exprString(x["left"])
  rs = exprString(x["right"])
  opstr = ""
  if x["op"] == $OP_ADD
    opstr = " + "
  else
    if x["op"] == $OP_SUB
      opstr = " - "
    else
      if x["op"] == $OP_MUL
        opstr = " * "
      else
        opstr = " / "
      end
    end
  end
  return "(" + ls + opstr + rs + ")"
end
$n_cards = 4
$goal = 24
$digit_range = 9
def solve(xs)
  if xs.length == 1
    f = exprEval(xs[0])
    if f["denom"] != 0 && f["num"] == f["denom"] * $goal
      puts(exprString(xs[0]))
      return true
    end
    return false
  end
  i = 0
  while i < xs.length
    j = i + 1
    while j < xs.length
      rest = []
      k = 0
      while k < xs.length
        if k != i && k != j
          rest = rest + [xs[k]]
        end
        k = k + 1
      end
      a = xs[i]
      b = xs[j]
      [$OP_ADD, $OP_SUB, $OP_MUL, $OP_DIV].each do |op|
        node = {"op" => op, "left" => a, "right" => b}
        if solve(rest + [node])
          return true
        end
      end
      node = {"op" => $OP_SUB, "left" => b, "right" => a}
      if solve(rest + [node])
        return true
      end
      node = {"op" => $OP_DIV, "left" => b, "right" => a}
      if solve(rest + [node])
        return true
      end
      j = j + 1
    end
    i = i + 1
  end
  return false
end
def main()
  iter = 0
  while iter < 10
    cards = []
    i = 0
    while i < $n_cards
      n = (_now() % ($digit_range - 1)) + 1
      cards = cards + [newNum(n)]
      puts(" " + (n).to_s)
      i = i + 1
    end
    puts(":  ")
    if !solve(cards)
      puts("No solution")
    end
    iter = iter + 1
  end
end
main()
