# Generated by Mochi transpiler v0.10.56 on 2025-08-03 17:02 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def addEdge(u, v, w)
    if !($graph.key?(u))
      $graph[u] = {}
    end
    $graph[u][v] = w
    if !($graph.key?(v))
      $graph[v] = {}
    end
  end
  def removeAt(xs, idx)
    out = []
    i = 0
        __tmp1 = xs
    if __tmp1.respond_to?(:keys) && !__tmp1.is_a?(String)
      __tmp1 = __tmp1.keys
    end
    __tmp1.each do |x|
      if i != idx
        out = (out << x)
      end
      i = _add(i, 1)
    end
    return out
  end
  def dijkstra(source)
    dist = {}
    prev = {}
        __tmp2 = $graph.keys()
    if __tmp2.respond_to?(:keys) && !__tmp2.is_a?(String)
      __tmp2 = __tmp2.keys
    end
    __tmp2.each do |v|
      dist[v] = $INF
      prev[v] = ""
    end
    dist[source] = 0
    q = []
        __tmp3 = $graph.keys()
    if __tmp3.respond_to?(:keys) && !__tmp3.is_a?(String)
      __tmp3 = __tmp3.keys
    end
    __tmp3.each do |v|
      q = (q << v)
    end
    while q.length > 0
      bestIdx = 0
      u = q[0]
      i = 1
      while i < q.length
        v = q[i]
        if dist[v] < dist[u]
          u = v
          bestIdx = i
        end
        i = _add(i, 1)
      end
      q = removeAt(q, bestIdx)
            __tmp4 = $graph[u]
      if __tmp4.respond_to?(:keys) && !__tmp4.is_a?(String)
        __tmp4 = __tmp4.keys
      end
      __tmp4.each do |v|
        alt = _add(dist[u], $graph[u][v])
        if alt < dist[v]
          dist[v] = alt
          prev[v] = u
        end
      end
    end
    return {"dist" => dist, "prev" => prev}
  end
  def path(prev, v)
    s = v
    cur = v
    while prev[cur] != ""
      cur = prev[cur]
      s = _add(cur, s)
    end
    return s
  end
  def main()
    addEdge("a", "b", 7)
    addEdge("a", "c", 9)
    addEdge("a", "f", 14)
    addEdge("b", "c", 10)
    addEdge("b", "d", 15)
    addEdge("c", "d", 11)
    addEdge("c", "f", 2)
    addEdge("d", "e", 6)
    addEdge("e", "f", 9)
    res = dijkstra("a")
    dist = res["dist"]
    prev = res["prev"]
    puts(_add(_add(_add("Distance to e: ", (dist["e"]).to_s), ", Path: "), path(prev, "e")))
    puts(_add(_add(_add("Distance to f: ", (dist["f"]).to_s), ", Path: "), path(prev, "f")))
  end
  $INF = 1000000000
  $graph = {}
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
