# Generated by Mochi transpiler v0.10.56 on 2025-08-03 17:02 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if (!s || s == '') && ENV['MOCHI_BENCHMARK']
  s = '1'
end
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed += 1_000_000
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _indexOf(s, ch)
  idx = s.index(ch)
  idx ? idx : -1
end


def parseIntStr(str, base = 10)
  str.to_i(base)
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end


class String
  alias each each_char
end

start_mem = _mem()
start = _now()
  def isLeap(y)
    if y % 400 == 0
      return true
    end
    if y % 100 == 0
      return false
    end
    return y % 4 == 0
  end
  def daysInMonth(y, m)
    feb = (isLeap(y) ? 29 : 28)
    lengths = [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    return lengths[m - 1]
  end
  def daysBeforeYear(y)
    days = 0
    yy = 1970
    while yy < y
      days = _add(days, 365)
      if isLeap(yy)
        days = _add(days, 1)
      end
      yy = _add(yy, 1)
    end
    return days
  end
  def daysBeforeMonth(y, m)
    days = 0
    mm = 1
    while mm < m
      days = _add(days, daysInMonth(y, mm))
      mm = _add(mm, 1)
    end
    return days
  end
  def epochSeconds(y, m, d, h, mi)
    days = _add(_add(daysBeforeYear(y), daysBeforeMonth(y, m)), (d - 1))
    return _add(_add(days * 86400, h * 3600), mi * 60)
  end
  def fromEpoch(sec)
    days = sec / 86400
    rem = sec % 86400
    y = 1970
    while true
      dy = (isLeap(y) ? 366 : 365)
      if days >= dy
        days = days - dy
        y = _add(y, 1)
      else
        break
      end
    end
    m = 1
    while true
      dim = daysInMonth(y, m)
      if days >= dim
        days = days - dim
        m = _add(m, 1)
      else
        break
      end
    end
    d = _add(days, 1)
    h = rem / 3600
    mi = (rem % 3600) / 60
    return [y, m, d, h, mi]
  end
  def pad2(n)
    if n < 10
      return _add("0", (n).to_s)
    end
    return (n).to_s
  end
  def absInt(n)
    if n < 0
      return -n
    end
    return n
  end
  def formatDate(parts, offset, abbr)
    y = parts[0]
    m = parts[1]
    d = parts[2]
    h = parts[3]
    mi = parts[4]
    sign = "+"
    if offset < 0
      sign = "-"
    end
    off = absInt(offset) / 60
    offh = pad2(off / 60)
    offm = pad2(off % 60)
    return _add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add((y).to_s, "-"), pad2(m)), "-"), pad2(d)), " "), pad2(h)), ":"), pad2(mi)), ":00 "), sign), offh), offm), " "), abbr)
  end
  def parseIntStr(str)
    i = 0
    neg = false
    if str.length > 0 && str[0...1] == "-"
      neg = true
      i = 1
    end
    n = 0
    digits = {"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
    while i < str.length
      n = _add(n * 10, digits[str[i..._add(i, 1)]])
      i = _add(i, 1)
    end
    if neg
      n = -n
    end
    return n
  end
  def indexOf(s, ch)
    i = 0
    while i < s.length
      if s[i..._add(i, 1)] == ch
        return i
      end
      i = _add(i, 1)
    end
    return -1
  end
  def parseTime(s)
    c = _indexOf(s, ":")
    h = parseIntStr(s[0...c])
    mi = parseIntStr(s[_add(c, 1)..._add(c, 3)])
    ampm = s[s.length - 2...s.length]
    hh = h
    if ampm == "pm" && h != 12
      hh = _add(h, 12)
    end
    if ampm == "am" && h == 12
      hh = 0
    end
    return [hh, mi]
  end
  def main()
    input = "March 7 2009 7:30pm EST"
    puts(_add("Input:              ", input))
    parts = []
    cur = ""
    i = 0
    while i < input.length
      ch = input[i..._add(i, 1)]
      if ch == " "
        if cur.length > 0
          parts = (parts << cur)
          cur = ""
        end
      else
        cur = _add(cur, ch)
      end
      i = _add(i, 1)
    end
    if cur.length > 0
      parts = (parts << cur)
    end
    month = $months[parts[0]]
    day = parseIntStr(parts[1])
    year = parseIntStr(parts[2])
    tm = parseTime(parts[3])
    hour = tm[0]
    minute = tm[1]
    tz = parts[4]
    zoneOffsets = {"EST" => -18000, "EDT" => -14400, "MST" => -25200}
    local = epochSeconds(year, month, day, hour, minute)
    utc = local - zoneOffsets[tz]
    utc12 = _add(utc, 43200)
    startDST = epochSeconds(2009, 3, 8, 7, 0)
    offEast = -18000
    if utc12 >= startDST
      offEast = -14400
    end
    eastParts = fromEpoch(_add(utc12, offEast))
    eastAbbr = "EST"
    if offEast == (-14400)
      eastAbbr = "EDT"
    end
    puts(_add("+12 hrs:            ", formatDate(eastParts, offEast, eastAbbr)))
    offAZ = -25200
    azParts = fromEpoch(_add(utc12, offAZ))
    puts(_add("+12 hrs in Arizona: ", formatDate(azParts, offAZ, "MST")))
  end
  $months = {"January" => 1, "February" => 2, "March" => 3, "April" => 4, "May" => 5, "June" => 6, "July" => 7, "August" => 8, "September" => 9, "October" => 10, "November" => 11, "December" => 12}
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
