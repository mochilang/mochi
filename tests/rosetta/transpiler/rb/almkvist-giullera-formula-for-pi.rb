# Generated by Mochi transpiler v0.10.37 on 2025-07-23 13:02 +0700
def bigTrim(a)
  n = a.length
  while n > 1 && a[n - 1] == 0
    a = a[0...n - 1]
    n = n - 1
  end
  return a
end
def bigFromInt(x)
  if x == 0
    return [0]
  end
  digits = []
  n = x
  while n > 0
    digits = digits + [n % 10]
    n = n / 10
  end
  return digits
end
def bigCmp(a, b)
  if a.length > b.length
    return 1
  end
  if a.length < b.length
    return -1
  end
  i = a.length - 1
  while i >= 0
    if a[i] > b[i]
      return 1
    end
    if a[i] < b[i]
      return -1
    end
    i = i - 1
  end
  return 0
end
def bigAdd(a, b)
  res = []
  carry = 0
  i = 0
  while i < a.length || i < b.length || carry > 0
    av = 0
    if i < a.length
      av = a[i]
    end
    bv = 0
    if i < b.length
      bv = b[i]
    end
    s = av + bv + carry
    res = res + [s % 10]
    carry = s / 10
    i = i + 1
  end
  return bigTrim(res)
end
def bigSub(a, b)
  res = []
  borrow = 0
  i = 0
  while i < a.length
    av = a[i]
    bv = 0
    if i < b.length
      bv = b[i]
    end
    diff = av - bv - borrow
    if diff < 0
      diff = diff + 10
      borrow = 1
    else
      borrow = 0
    end
    res = res + [diff]
    i = i + 1
  end
  return bigTrim(res)
end
def bigMulSmall(a, m)
  if m == 0
    return [0]
  end
  res = []
  carry = 0
  i = 0
  while i < a.length
    prod = a[i] * m + carry
    res = res + [prod % 10]
    carry = prod / 10
    i = i + 1
  end
  while carry > 0
    res = res + [carry % 10]
    carry = carry / 10
  end
  return bigTrim(res)
end
def bigMulBig(a, b)
  res = []
  i = 0
  while i < a.length + b.length
    res = res + [0]
    i = i + 1
  end
  i = 0
  while i < a.length
    carry = 0
    j = 0
    while j < b.length
      idx = i + j
      prod = res[idx] + a[i] * b[j] + carry
      res[idx] = prod % 10
      carry = prod / 10
      j = j + 1
    end
    idx = i + b.length
    while carry > 0
      prod = res[idx] + carry
      res[idx] = prod % 10
      carry = prod / 10
      idx = idx + 1
    end
    i = i + 1
  end
  return bigTrim(res)
end
def bigMulPow10(a, k)
  i = 0
  while i < k
    a = [0] + a
    i = i + 1
  end
  return a
end
def bigDivSmall(a, m)
  res = []
  rem = 0
  i = a.length - 1
  while i >= 0
    cur = rem * 10 + a[i]
    q = cur / m
    rem = cur % m
    res = [q] + res
    i = i - 1
  end
  return bigTrim(res)
end
def bigToString(a)
  s = ""
  i = a.length - 1
  while i >= 0
    s = s + (a[i]).to_s
    i = i - 1
  end
  return s
end
def repeat(ch, n)
  s = ""
  i = 0
  while i < n
    s = s + ch
    i = i + 1
  end
  return s
end
def sortInts(xs)
  res = []
  tmp = xs
  while tmp.length > 0
    min = tmp[0]
    idx = 0
    i = 1
    while i < tmp.length
      if tmp[i] < min
        min = tmp[i]
        idx = i
      end
      i = i + 1
    end
    res = res + [min]
    out = []
    j = 0
    while j < tmp.length
      if j != idx
        out = out + [tmp[j]]
      end
      j = j + 1
    end
    tmp = out
  end
  return res
end
def primesUpTo(n)
  sieve = []
  i = 0
  while i <= n
    sieve = sieve + [true]
    i = i + 1
  end
  p = 2
  while p * p <= n
    if sieve[p]
      m = p * p
      while m <= n
        sieve[m] = false
        m = m + p
      end
    end
    p = p + 1
  end
  res = []
  x = 2
  while x <= n
    if sieve[x]
      res = res + [x]
    end
    x = x + 1
  end
  return res
end
def factorialExp(n, primes)
  m = {}
  primes.each do |p|
    if p > n
      break
    end
    t = n
    e = 0
    while t > 0
      t = t / p
      e = e + t
    end
    m[(p).to_s] = e
  end
  return m
end
def factorSmall(x, primes)
  f = {}
  n = x
  primes.each do |p|
    if p * p > n
      break
    end
    c = 0
    while n % p == 0
      c = c + 1
      n = n / p
    end
    if c > 0
      f[(p).to_s] = c
    end
  end
  if n > 1
    f[(n).to_s] = f.get((n).to_s, 0) + 1
  end
  return f
end
def computeIP(n, primes)
  exps = factorialExp(6 * n, primes)
  fn = factorialExp(n, primes)
  fn.keys().each do |k|
    exps[k] = exps.get(k, 0) - 6 * fn[k]
  end
  exps["2"] = exps.get("2", 0) + 5
  t2 = 532 * n * n + 126 * n + 9
  ft2 = factorSmall(t2, primes)
  ft2.keys().each do |k|
    exps[k] = exps.get(k, 0) + ft2[k]
  end
  exps["3"] = exps.get("3", 0) - 1
  keys = []
  exps.keys().each do |k|
    keys = keys + [(k).to_i]
  end
  keys = sortInts(keys)
  res = bigFromInt(1)
  keys.each do |p|
    e = exps[(p).to_s]
    i = 0
    while i < e
      res = bigMulSmall(res, p)
      i = i + 1
    end
  end
  return res
end
def formatTerm(ip, pw)
  s = bigToString(ip)
  if pw >= s.length
    frac = repeat("0", pw - s.length) + s
    if frac.length < 33
      frac = frac + repeat("0", 33 - frac.length)
    end
    return "0." + frac[0...33]
  end
  intpart = s[0...s.length - pw]
  frac = s[s.length - pw...s.length]
  if frac.length < 33
    frac = frac + repeat("0", 33 - frac.length)
  end
  return intpart + "." + frac[0...33]
end
def bigAbsDiff(a, b)
  if bigCmp(a, b) >= 0
    return bigSub(a, b)
  end
  return bigSub(b, a)
end
def main()
  primes = primesUpTo(2000)
  puts("N                               Integer Portion  Pow  Nth Term (33 dp)")
  line = repeat("-", 89)
  puts(line)
  sum = bigFromInt(0)
  prev = bigFromInt(0)
  denomPow = 0
  n = 0
  while true
    ip = computeIP(n, primes)
    pw = 6 * n + 3
    if pw > denomPow
      sum = bigMulPow10(sum, pw - denomPow)
      prev = bigMulPow10(prev, pw - denomPow)
      denomPow = pw
    end
    if n < 10
      termStr = formatTerm(ip, pw)
      ipStr = bigToString(ip)
      while ipStr.length < 44
        ipStr = " " + ipStr
      end
      pwStr = (-pw).to_s
      while pwStr.length < 3
        pwStr = " " + pwStr
      end
      padTerm = termStr
      while padTerm.length < 35
        padTerm = padTerm + " "
      end
      puts((n).to_s + "  " + ipStr + "  " + pwStr + "  " + padTerm)
    end
    sum = bigAdd(sum, ip)
    diff = bigAbsDiff(sum, prev)
    if denomPow >= 70 && bigCmp(diff, bigMulPow10(bigFromInt(1), denomPow - 70)) < 0
      break
    end
    prev = sum
    n = n + 1
  end
  precision = 70
  target = bigMulPow10(bigFromInt(1), denomPow + 2 * precision)
  low = bigFromInt(0)
  high = bigMulPow10(bigFromInt(1), precision + 1)
  while bigCmp(low, bigSub(high, bigFromInt(1))) < 0
    mid = bigDivSmall(bigAdd(low, high), 2)
    prod = bigMulBig(bigMulBig(mid, mid), sum)
    if bigCmp(prod, target) <= 0
      low = mid
    else
      high = bigSub(mid, bigFromInt(1))
    end
  end
  piInt = low
  piStr = bigToString(piInt)
  if piStr.length <= precision
    piStr = repeat("0", precision - piStr.length + 1) + piStr
  end
  out = piStr[0...piStr.length - precision] + "." + piStr[piStr.length - precision...piStr.length]
  puts("")
  puts("Pi to 70 decimal places is:")
  puts(out)
end
main()
