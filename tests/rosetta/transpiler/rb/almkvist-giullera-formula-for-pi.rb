# Generated by Mochi transpiler v0.10.42 on 2025-07-27 23:54 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _repeat(s, n)
  s * n.to_i
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def bigTrim(a)
    n = a.length
    while n > 1 && a[n - 1] == 0
      a = a[0...n - 1]
      n = n - 1
    end
    return a
  end
  def bigFromInt(x)
    if x == 0
      return [0]
    end
    digits = []
    n = x
    while n > 0
      digits = digits + [n % 10]
      n = n / 10
    end
    return digits
  end
  def bigCmp(a, b)
    if a.length > b.length
      return 1
    end
    if a.length < b.length
      return -1
    end
    i = a.length - 1
    while i >= 0
      if a[i] > b[i]
        return 1
      end
      if a[i] < b[i]
        return -1
      end
      i = i - 1
    end
    return 0
  end
  def bigAdd(a, b)
    res = []
    carry = 0
    i = 0
    while i < a.length || i < b.length || carry > 0
      av = 0
      if i < a.length
        av = a[i]
      end
      bv = 0
      if i < b.length
        bv = b[i]
      end
      s = _add(_add(av, bv), carry)
      res = res + [s % 10]
      carry = s / 10
      i = _add(i, 1)
    end
    return bigTrim(res)
  end
  def bigSub(a, b)
    res = []
    borrow = 0
    i = 0
    while i < a.length
      av = a[i]
      bv = 0
      if i < b.length
        bv = b[i]
      end
      diff = av - bv - borrow
      if diff < 0
        diff = _add(diff, 10)
        borrow = 1
      else
        borrow = 0
      end
      res = res + [diff]
      i = _add(i, 1)
    end
    return bigTrim(res)
  end
  def bigMulSmall(a, m)
    if m == 0
      return [0]
    end
    res = []
    carry = 0
    i = 0
    while i < a.length
      prod = _add(a[i] * m, carry)
      res = res + [prod % 10]
      carry = prod / 10
      i = _add(i, 1)
    end
    while carry > 0
      res = res + [carry % 10]
      carry = carry / 10
    end
    return bigTrim(res)
  end
  def bigMulBig(a, b)
    res = []
    i = 0
    while i < _add(a.length, b.length)
      res = res + [0]
      i = _add(i, 1)
    end
    i = 0
    while i < a.length
      carry = 0
      j = 0
      while j < b.length
        idx = _add(i, j)
        prod = _add(_add(res[idx], a[i] * b[j]), carry)
        res[idx] = prod % 10
        carry = prod / 10
        j = _add(j, 1)
      end
      idx = _add(i, b.length)
      while carry > 0
        prod = _add(res[idx], carry)
        res[idx] = prod % 10
        carry = prod / 10
        idx = _add(idx, 1)
      end
      i = _add(i, 1)
    end
    return bigTrim(res)
  end
  def bigMulPow10(a, k)
    i = 0
    while i < k
      a = _add([0], a)
      i = _add(i, 1)
    end
    return a
  end
  def bigDivSmall(a, m)
    res = []
    rem = 0
    i = a.length - 1
    while i >= 0
      cur = _add(rem * 10, a[i])
      q = cur / m
      rem = cur % m
      res = _add([q], res)
      i = i - 1
    end
    return bigTrim(res)
  end
  def bigToString(a)
    s = ""
    i = a.length - 1
    while i >= 0
      s = _add(s, (a[i]).to_s)
      i = i - 1
    end
    return s
  end
  def repeat(ch, n)
    s = ""
    i = 0
    while i < n
      s = _add(s, ch)
      i = _add(i, 1)
    end
    return s
  end
  def sortInts(xs)
    res = []
    tmp = xs
    while tmp.length > 0
      min = tmp[0]
      idx = 0
      i = 1
      while i < tmp.length
        if tmp[i] < min
          min = tmp[i]
          idx = i
        end
        i = _add(i, 1)
      end
      res = _add(res, [min])
      out = []
      j = 0
      while j < tmp.length
        if j != idx
          out = _add(out, [tmp[j]])
        end
        j = _add(j, 1)
      end
      tmp = out
    end
    return res
  end
  def primesUpTo(n)
    sieve = []
    i = 0
    while i <= n
      sieve = sieve + [true]
      i = _add(i, 1)
    end
    p = 2
    while p * p <= n
      if sieve[p]
        m = p * p
        while m <= n
          sieve[m] = false
          m = _add(m, p)
        end
      end
      p = _add(p, 1)
    end
    res = []
    x = 2
    while x <= n
      if sieve[x]
        res = res + [x]
      end
      x = _add(x, 1)
    end
    return res
  end
  def factorialExp(n, primes)
    m = {}
    primes.each do |p|
      if p > n
        break
      end
      t = n
      e = 0
      while t > 0
        t = t / p
        e = _add(e, t)
      end
      m[(p).to_s] = e
    end
    return m
  end
  def factorSmall(x, primes)
    f = {}
    n = x
    primes.each do |p|
      if p * p > n
        break
      end
      c = 0
      while n % p == 0
        c = _add(c, 1)
        n = n / p
      end
      if c > 0
        f[(p).to_s] = c
      end
    end
    if n > 1
      f[(n).to_s] = _add(f.fetch((n).to_s, 0), 1)
    end
    return f
  end
  def computeIP(n, primes)
    exps = factorialExp(6 * n, primes)
    fn = factorialExp(n, primes)
    fn.keys().each do |k|
      exps[k] = exps.fetch(k, 0) - 6 * fn[k]
    end
    exps["2"] = _add(exps.fetch("2", 0), 5)
    t2 = _add(_add(532 * n * n, 126 * n), 9)
    ft2 = factorSmall(t2, primes)
    ft2.keys().each do |k|
      exps[k] = _add(exps.fetch(k, 0), ft2[k])
    end
    exps["3"] = exps.fetch("3", 0) - 1
    keys = []
    exps.keys().each do |k|
      keys = keys + [(k).to_i]
    end
    keys = sortInts(keys)
    res = bigFromInt(1)
    keys.each do |p|
      e = exps[(p).to_s]
      i = 0
      while i < e
        res = bigMulSmall(res, p)
        i = _add(i, 1)
      end
    end
    return res
  end
  def formatTerm(ip, pw)
    s = bigToString(ip)
    if pw >= s.length
      frac = _add(_repeat("0", pw - s.length), s)
      if frac.length < 33
        frac = _add(frac, _repeat("0", 33 - frac.length))
      end
      return _add("0.", frac[0...33])
    end
    intpart = s[0...s.length - pw]
    frac = s[s.length - pw...s.length]
    if frac.length < 33
      frac = _add(frac, _repeat("0", 33 - frac.length))
    end
    return _add(_add(intpart, "."), frac[0...33])
  end
  def bigAbsDiff(a, b)
    if bigCmp(a, b) >= 0
      return bigSub(a, b)
    end
    return bigSub(b, a)
  end
  def main()
    primes = primesUpTo(2000)
    puts("N                               Integer Portion  Pow  Nth Term (33 dp)")
    line = _repeat("-", 89)
    puts(line)
    sum = bigFromInt(0)
    prev = bigFromInt(0)
    denomPow = 0
    n = 0
    while true
      ip = computeIP(n, primes)
      pw = _add(6 * n, 3)
      if pw > denomPow
        sum = bigMulPow10(sum, pw - denomPow)
        prev = bigMulPow10(prev, pw - denomPow)
        denomPow = pw
      end
      if n < 10
        termStr = formatTerm(ip, pw)
        ipStr = bigToString(ip)
        while ipStr.length < 44
          ipStr = _add(" ", ipStr)
        end
        pwStr = (-pw).to_s
        while pwStr.length < 3
          pwStr = _add(" ", pwStr)
        end
        padTerm = termStr
        while padTerm.length < 35
          padTerm = _add(padTerm, " ")
        end
        puts(_add(_add(_add(_add(_add(_add((n).to_s, "  "), ipStr), "  "), pwStr), "  "), padTerm))
      end
      sum = bigAdd(sum, ip)
      diff = bigAbsDiff(sum, prev)
      if denomPow >= 70 && bigCmp(diff, bigMulPow10(bigFromInt(1), denomPow - 70)) < 0
        break
      end
      prev = sum
      n = _add(n, 1)
    end
    precision = 70
    target = bigMulPow10(bigFromInt(1), _add(denomPow, 2 * precision))
    low = bigFromInt(0)
    high = bigMulPow10(bigFromInt(1), _add(precision, 1))
    while bigCmp(low, bigSub(high, bigFromInt(1))) < 0
      mid = bigDivSmall(bigAdd(low, high), 2)
      prod = bigMulBig(bigMulBig(mid, mid), sum)
      if bigCmp(prod, target) <= 0
        low = mid
      else
        high = bigSub(mid, bigFromInt(1))
      end
    end
    piInt = low
    piStr = bigToString(piInt)
    if piStr.length <= precision
      piStr = _add(_repeat("0", _add(precision - piStr.length, 1)), piStr)
    end
    out = _add(_add(piStr[0...piStr.length - precision], "."), piStr[piStr.length - precision...piStr.length])
    puts("")
    puts("Pi to 70 decimal places is:")
    puts(out)
  end
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
