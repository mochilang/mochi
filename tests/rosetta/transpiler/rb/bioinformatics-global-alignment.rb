# Generated by Mochi transpiler v0.10.39 on 2025-07-24 13:03 +0700

def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

def padLeft(s, w)
  res = ""
  n = w - s.length
  while n > 0
    res = _add(res, " ")
    n = n - 1
  end
  return _add(res, s)
end
def indexOfFrom(s, ch, start)
  i = start
  while i < s.length
    if s[i..._add(i, 1)] == ch
      return i
    end
    i = _add(i, 1)
  end
  return -1
end
def containsStr(s, sub)
  i = 0
  sl = s.length
  subl = sub.length
  while i <= sl - subl
    if s[i..._add(i, subl)] == sub
      return true
    end
    i = _add(i, 1)
  end
  return false
end
def distinct(slist)
  res = []
  slist.each do |s|
    found = false
    res.each do |r|
      if r == s
        found = true
        break
      end
    end
    if !found
      res = res + [s]
    end
  end
  return res
end
def permutations(xs)
  if xs.length <= 1
    return [xs]
  end
  res = []
  i = 0
  while i < xs.length
    rest = []
    j = 0
    while j < xs.length
      if j != i
        rest = rest + [xs[j]]
      end
      j = _add(j, 1)
    end
    subs = permutations(rest)
    subs.each do |p|
      perm = [xs[i]]
      k = 0
      while k < p.length
        perm = perm + [p[k]]
        k = _add(k, 1)
      end
      res = res + [perm]
    end
    i = _add(i, 1)
  end
  return res
end
def headTailOverlap(s1, s2)
  start = 0
  while true
    ix = indexOfFrom(s1, s2[0...1], start)
    if ix == 0 - 1
      return 0
    end
    start = ix
    if s2[0...s1.length - start] == s1[start...s1.length]
      return s1.length - start
    end
    start = _add(start, 1)
  end
end
def deduplicate(slist)
  arr = distinct(slist)
  filtered = []
  i = 0
  while i < arr.length
    s1 = arr[i]
    within = false
    j = 0
    while j < arr.length
      if j != i && containsStr(arr[j], s1)
        within = true
        break
      end
      j = _add(j, 1)
    end
    if !within
      filtered = filtered + [s1]
    end
    i = _add(i, 1)
  end
  return filtered
end
def joinAll(ss)
  out = ""
  ss.each do |s|
    out = _add(out, s)
  end
  return out
end
def shortestCommonSuperstring(slist)
  ss = deduplicate(slist)
  shortest = joinAll(ss)
  perms = permutations(ss)
  idx = 0
  while idx < perms.length
    perm = perms[idx]
    sup = perm[0]
    i = 0
    while i < ss.length - 1
      ov = headTailOverlap(perm[i], perm[_add(i, 1)])
      sup = _add(sup, perm[_add(i, 1)][ov...perm[_add(i, 1)].length])
      i = _add(i, 1)
    end
    if sup.length < shortest.length
      shortest = sup
    end
    idx = _add(idx, 1)
  end
  return shortest
end
def printCounts(seq)
  a = 0
  c = 0
  g = 0
  t = 0
  i = 0
  while i < seq.length
    ch = seq[i..._add(i, 1)]
    if ch == "A"
      a = _add(a, 1)
    else
      if ch == "C"
        c = _add(c, 1)
      else
        if ch == "G"
          g = _add(g, 1)
        else
          if ch == "T"
            t = _add(t, 1)
          end
        end
      end
    end
    i = _add(i, 1)
  end
  total = seq.length
  puts(_add(_add("\nNucleotide counts for ", seq), ":\n"))
  puts(_add(padLeft("A", 10), padLeft((a).to_s, 12)))
  puts(_add(padLeft("C", 10), padLeft((c).to_s, 12)))
  puts(_add(padLeft("G", 10), padLeft((g).to_s, 12)))
  puts(_add(padLeft("T", 10), padLeft((t).to_s, 12)))
  puts(_add(padLeft("Other", 10), padLeft((total - (_add(_add(_add(a, c), g), t))).to_s, 12)))
  puts("  ____________________")
  puts(_add(padLeft("Total length", 14), padLeft((total).to_s, 8)))
end
def main()
  tests = [["TA", "AAG", "TA", "GAA", "TA"], ["CATTAGGG", "ATTAG", "GGG", "TA"], ["AAGAUGGA", "GGAGCGCAUC", "AUCGCAAUAAGGA"], ["ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT", "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT", "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC", "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC", "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT", "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"]]
  tests.each do |seqs|
    scs = shortestCommonSuperstring(seqs)
    printCounts(scs)
  end
end
main()
