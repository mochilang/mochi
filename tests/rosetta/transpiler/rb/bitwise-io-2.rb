# Generated by Mochi transpiler v0.10.39 on 2025-07-24 13:03 +0700

def _indexOf(s, ch)
  idx = s.index(ch)
  idx ? idx : -1
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

def pow2(n)
  v = 1
  i = 0
  while i < n
    v = v * 2
    i = _add(i, 1)
  end
  return v
end
def lshift(x, n)
  return x * pow2(n)
end
def rshift(x, n)
  return x / pow2(n)
end
Writer = Struct.new(:order, :bits, :nbits, :data, keyword_init: true)
def NewWriter(order)
  return Writer.new(order: order, bits: 0, nbits: 0, data: [])
end
def writeBitsLSB(w, c, width)
  w = Marshal.load(Marshal.dump(w))
  w["bits"] = _add(w.bits, lshift(c, w.nbits))
  w["nbits"] = _add(w.nbits, width)
  while w.nbits >= 8
    b = w.bits % 256
    w["data"] = w.data + [b]
    w["bits"] = rshift(w.bits, 8)
    w["nbits"] = w.nbits - 8
  end
  return w
end
def writeBitsMSB(w, c, width)
  w = Marshal.load(Marshal.dump(w))
  w["bits"] = _add(w.bits, lshift(c, 32 - width - w.nbits))
  w["nbits"] = _add(w.nbits, width)
  while w.nbits >= 8
    b = rshift(w.bits, 24) % 256
    w["data"] = w.data + [b]
    w["bits"] = (w.bits % pow2(24)) * 256
    w["nbits"] = w.nbits - 8
  end
  return w
end
def WriteBits(w, c, width)
  w = Marshal.load(Marshal.dump(w))
  if w.order == "LSB"
    return writeBitsLSB(w, c, width)
  end
  return writeBitsMSB(w, c, width)
end
def CloseWriter(w)
  w = Marshal.load(Marshal.dump(w))
  if w.nbits > 0
    if w.order == "MSB"
      w["bits"] = rshift(w.bits, 24)
    end
    w["data"] = w.data + [w.bits % 256]
  end
  w["bits"] = 0
  w["nbits"] = 0
  return w
end
Reader = Struct.new(:order, :data, :idx, :bits, :nbits, keyword_init: true)
def NewReader(data, order)
  return Reader.new(order: order, data: data, idx: 0, bits: 0, nbits: 0)
end
def readBitsLSB(r, width)
  r = Marshal.load(Marshal.dump(r))
  while r.nbits < width
    if r.idx >= r.data.length
      return {"val" => 0, "eof" => true}
    end
    b = r.data[r.idx]
    r["idx"] = _add(r.idx, 1)
    r["bits"] = _add(r.bits, lshift(b, r.nbits))
    r["nbits"] = _add(r.nbits, 8)
  end
  mask = pow2(width) - 1
  out = r.bits % (_add(mask, 1))
  r["bits"] = rshift(r.bits, width)
  r["nbits"] = r.nbits - width
  return {"val" => out, "eof" => false}
end
def readBitsMSB(r, width)
  r = Marshal.load(Marshal.dump(r))
  while r.nbits < width
    if r.idx >= r.data.length
      return {"val" => 0, "eof" => true}
    end
    b = r.data[r.idx]
    r["idx"] = _add(r.idx, 1)
    r["bits"] = _add(r.bits, lshift(b, 24 - r.nbits))
    r["nbits"] = _add(r.nbits, 8)
  end
  out = rshift(r.bits, 32 - width)
  r["bits"] = (r.bits * pow2(width)) % pow2(32)
  r["nbits"] = r.nbits - width
  return {"val" => out, "eof" => false}
end
def ReadBits(r, width)
  r = Marshal.load(Marshal.dump(r))
  if r.order == "LSB"
    return readBitsLSB(r, width)
  end
  return readBitsMSB(r, width)
end
def toBinary(n, bits)
  b = ""
  val = n
  i = 0
  while i < bits
    b = _add((val % 2).to_s, b)
    val = val / 2
    i = _add(i, 1)
  end
  return b
end
def bytesToBits(bs)
  out = "["
  i = 0
  while i < bs.length
    out = _add(out, toBinary(bs[i], 8))
    if _add(i, 1) < bs.length
      out = _add(out, " ")
    end
    i = _add(i, 1)
  end
  out = _add(out, "]")
  return out
end
def bytesToHex(bs)
  digits = "0123456789ABCDEF"
  out = ""
  i = 0
  while i < bs.length
    b = bs[i]
    hi = b / 16
    lo = b % 16
    out = _add(_add(out, digits[hi..._add(hi, 1)]), digits[lo..._add(lo, 1)])
    if _add(i, 1) < bs.length
      out = _add(out, " ")
    end
    i = _add(i, 1)
  end
  return out
end
def ord(ch)
  upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  lower = "abcdefghijklmnopqrstuvwxyz"
  idx = _indexOf(upper, ch)
  if idx >= 0
    return _add(65, idx)
  end
  idx = _indexOf(lower, ch)
  if idx >= 0
    return _add(97, idx)
  end
  if ch >= "0" && ch <= "9"
    return _add(48, parseIntStr.call(ch))
  end
  if ch == " "
    return 32
  end
  if ch == "."
    return 46
  end
  return 0
end
def chr(n)
  upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  lower = "abcdefghijklmnopqrstuvwxyz"
  if n >= 65 && n < 91
    return upper[n - 65...n - 64]
  end
  if n >= 97 && n < 123
    return lower[n - 97...n - 96]
  end
  if n >= 48 && n < 58
    digits = "0123456789"
    return digits[n - 48...n - 47]
  end
  if n == 32
    return " "
  end
  if n == 46
    return "."
  end
  return "?"
end
def bytesOfStr(s)
  bs = []
  i = 0
  while i < s.length
    bs = bs + [ord(s[i..._add(i, 1)])]
    i = _add(i, 1)
  end
  return bs
end
def bytesToDec(bs)
  out = ""
  i = 0
  while i < bs.length
    out = _add(out, (bs[i]).to_s)
    if _add(i, 1) < bs.length
      out = _add(out, " ")
    end
    i = _add(i, 1)
  end
  return out
end
def Example()
  message = "This is a test."
  msgBytes = bytesOfStr(message)
  puts(_add(_add(_add("\"", message), "\" as bytes: "), bytesToDec(msgBytes)))
  puts(_add("    original bits: ", bytesToBits(msgBytes)))
  bw = NewWriter("MSB")
  i = 0
  while i < msgBytes.length
    bw = WriteBits(bw, msgBytes[i], 7)
    i = _add(i, 1)
  end
  bw = CloseWriter(bw)
  puts(_add("Written bitstream: ", bytesToBits(bw.data)))
  puts(_add("Written bytes: ", bytesToHex(bw.data)))
  br = NewReader(bw.data, "MSB")
  result = ""
  while true
    r = ReadBits(br, 7)
    if r["eof"]
      break
    end
    v = (r["val"]).to_i
    if v != 0
      result = _add(result, chr(v))
    end
  end
  puts(_add(_add("Read back as \"", result), "\""))
end
Example()
