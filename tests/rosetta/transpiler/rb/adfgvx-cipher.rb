# Generated by Mochi transpiler v0.10.40 on 2025-07-25 10:39 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _indexOf(s, ch)
  idx = s.index(ch)
  idx ? idx : -1
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  $adfgvx = "ADFGVX"
  $alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  def shuffleStr(s)
    arr = []
    i = 0
    while i < s.length
      arr = arr + [s[i..._add(i, 1)]]
      i = _add(i, 1)
    end
    j = arr.length - 1
    while j > 0
      k = _now() % (_add(j, 1))
      tmp = arr[j]
      arr[j] = arr[k]
      arr[k] = tmp
      j = j - 1
    end
    out = ""
    i = 0
    while i < arr.length
      out = _add(out, arr[i])
      i = _add(i, 1)
    end
    return out
  end
  def createPolybius()
    shuffled = shuffleStr($alphabet)
    labels = []
    li = 0
    while li < $adfgvx.length
      labels = labels + [$adfgvx[li..._add(li, 1)]]
      li = _add(li, 1)
    end
    puts("6 x 6 Polybius square:\n")
    puts("  | A D F G V X")
    puts("---------------")
    p = []
    i = 0
    while i < 6
      row = shuffled[i * 6...(_add(i, 1)) * 6]
      p = p + [row]
      line = _add(labels[i], " | ")
      j = 0
      while j < 6
        line = _add(_add(line, row[j..._add(j, 1)]), " ")
        j = _add(j, 1)
      end
      puts(line)
      i = _add(i, 1)
    end
    return p
  end
  def createKey(n)
    if n < 7 || n > 12
      puts("Key should be within 7 and 12 letters long.")
    end
    pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    key = ""
    i = 0
    while i < n
      idx = _now() % pool.length
      key = _add(key, pool[idx])
      pool = _add(pool[...idx], pool[_add(idx, 1)...pool.length])
      i = _add(i, 1)
    end
    puts(_add("\nThe key is ", key))
    return key
  end
  def orderKey(key)
    pairs = []
    i = 0
    while i < key.length
      pairs = pairs + [[key[i..._add(i, 1)], i]]
      i = _add(i, 1)
    end
    n = pairs.length
    m = 0
    while m < n
      j = 0
      while j < n - 1
        if pairs[j][0] > pairs[_add(j, 1)][0]
          tmp = pairs[j]
          pairs[j] = pairs[_add(j, 1)]
          pairs[_add(j, 1)] = tmp
        end
        j = _add(j, 1)
      end
      m = _add(m, 1)
    end
    res = []
    i = 0
    while i < n
      res = res + [(pairs[i][1]).to_i]
      i = _add(i, 1)
    end
    return res
  end
  def encrypt(polybius, key, plainText)
    labels = []
    li = 0
    while li < $adfgvx.length
      labels = labels + [$adfgvx[li..._add(li, 1)]]
      li = _add(li, 1)
    end
    temp = ""
    i = 0
    while i < plainText.length
      r = 0
      while r < 6
        c = 0
        while c < 6
          if polybius[r][c..._add(c, 1)] == plainText[i..._add(i, 1)]
            temp = _add(_add(temp, labels[r..._add(r, 1)]), labels[c..._add(c, 1)])
          end
          c = _add(c, 1)
        end
        r = _add(r, 1)
      end
      i = _add(i, 1)
    end
    colLen = temp.length / key.length
    if temp.length % key.length > 0
      colLen = _add(colLen, 1)
    end
    table = []
    rIdx = 0
    while rIdx < colLen
      row = []
      j = 0
      while j < key.length
        row = row + [""]
        j = _add(j, 1)
      end
      table = table + [row]
      rIdx = _add(rIdx, 1)
    end
    idx = 0
    while idx < temp.length
      row = idx / key.length
      col = idx % key.length
      table[row][col] = temp[idx..._add(idx, 1)]
      idx = _add(idx, 1)
    end
    order = orderKey(key)
    cols = []
    ci = 0
    while ci < key.length
      colStr = ""
      ri = 0
      while ri < colLen
        colStr = _add(colStr, table[ri][order[ci]])
        ri = _add(ri, 1)
      end
      cols = cols + [colStr]
      ci = _add(ci, 1)
    end
    result = ""
    ci = 0
    while ci < cols.length
      result = _add(result, cols[ci])
      if ci < cols.length - 1
        result = _add(result, " ")
      end
      ci = _add(ci, 1)
    end
    return result
  end
  def indexOf(s, ch)
    i = 0
    while i < s.length
      if s[i..._add(i, 1)] == ch
        return i
      end
      i = _add(i, 1)
    end
    return -1
  end
  def decrypt(polybius, key, cipherText)
    colStrs = []
    start = 0
    i = 0
    while i <= cipherText.length
      if i == cipherText.length || cipherText[i] == " "
        colStrs = colStrs + [cipherText[start...i]]
        start = _add(i, 1)
      end
      i = _add(i, 1)
    end
    maxColLen = 0
    i = 0
    while i < colStrs.length
      if colStrs[i].length > maxColLen
        maxColLen = colStrs[i].length
      end
      i = _add(i, 1)
    end
    cols = []
    i = 0
    while i < colStrs.length
      s = colStrs[i]
      ls = []
      j = 0
      while j < s.length
        ls = ls + [s[j..._add(j, 1)]]
        j = _add(j, 1)
      end
      if s.length < maxColLen
        pad = []
        k = 0
        while k < maxColLen
          if k < ls.length
            pad = pad + [ls[k]]
          else
            pad = pad + [""]
          end
          k = _add(k, 1)
        end
        cols = cols + [pad]
      else
        cols = cols + [ls]
      end
      i = _add(i, 1)
    end
    table = []
    r = 0
    while r < maxColLen
      row = []
      c = 0
      while c < key.length
        row = row + [""]
        c = _add(c, 1)
      end
      table = table + [row]
      r = _add(r, 1)
    end
    order = orderKey(key)
    r = 0
    while r < maxColLen
      c = 0
      while c < key.length
        table[r][order[c]] = cols[c][r]
        c = _add(c, 1)
      end
      r = _add(r, 1)
    end
    temp = ""
    r = 0
    while r < table.length
      j = 0
      while j < table[r].length
        temp = _add(temp, table[r][j])
        j = _add(j, 1)
      end
      r = _add(r, 1)
    end
    plainText = ""
    idx = 0
    while idx < temp.length
      rIdx = _indexOf($adfgvx, temp[idx..._add(idx, 1)])
      cIdx = _indexOf($adfgvx, temp[_add(idx, 1)..._add(idx, 2)])
      plainText = _add(plainText, polybius[rIdx][cIdx])
      idx = _add(idx, 2)
    end
    return plainText
  end
  def main()
    plainText = "ATTACKAT1200AM"
    polybius = createPolybius()
    key = createKey(9)
    puts(_add("\nPlaintext : ", plainText))
    cipherText = encrypt(polybius, key, plainText)
    puts(_add("\nEncrypted : ", cipherText))
    plainText2 = decrypt(polybius, key, cipherText)
    puts(_add("\nDecrypted : ", plainText2))
  end
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
