# Generated by Mochi transpiler v0.10.42 on 2025-07-27 15:12 +0000
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _split(s, sep)
  s.to_s.split(sep.to_s)
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def split(s, sep)
    parts = []
    cur = ""
    i = 0
    while i < s.length
      if sep.length > 0 && _add(i, sep.length) <= s.length && s[i..._add(i, sep.length)] == sep
        parts = parts + [cur]
        cur = ""
        i = _add(i, sep.length)
      else
        cur = _add(cur, s[i..._add(i, 1)])
        i = _add(i, 1)
      end
    end
    parts = parts + [cur]
    return parts
  end
  def trimSpace(s)
    start = 0
    while start < s.length && (s[start..._add(start, 1)] == " " || s[start..._add(start, 1)] == "\t")
      start = _add(start, 1)
    end
    end_ = s.length
    while end_ > start && (s[end_ - 1...end_] == " " || s[end_ - 1...end_] == "\t")
      end_ = end_ - 1
    end
    return s[start...end_]
  end
  def indexOfSub(s, sub)
    if sub.length == 0
      return 0
    end
    i = 0
    while _add(i, sub.length) <= s.length
      if s[i..._add(i, sub.length)] == sub
        return i
      end
      i = _add(i, 1)
    end
    return 0 - 1
  end
  def parseRules(rs)
    rules = []
    _split(rs, "\n").each do |line|
      ln = line
      hash = indexOfSub(ln, "#")
      if hash >= 0
        ln = ln[...hash]
      end
      ln = trimSpace(ln)
      if ln.length == 0
        next
      end
      arrow = 0 - 1
      j = 0
      while _add(j, 2) <= ln.length
        if ln[j..._add(j, 2)] == "->"
          pre = j > 0 && (ln[j - 1...j] == " " || ln[j - 1...j] == "\t")
          post = _add(j, 2) < ln.length && (ln[_add(j, 2)..._add(j, 3)] == " " || ln[_add(j, 2)..._add(j, 3)] == "\t")
          if pre && post
            arrow = j
            break
          end
        end
        j = _add(j, 1)
      end
      if arrow < 0
        arrow = indexOfSub(ln, "->")
      end
      if arrow < 0
        return {"ok" => false}
      end
      pat = trimSpace(ln[...arrow])
      rest = trimSpace(ln[_add(arrow, 2)...ln.length])
      term = false
      if rest.length > 0 && rest[0...1] == "."
        term = true
        rest = rest[1...rest.length]
      end
      rep = rest
      rules = rules + [{"pat" => pat, "rep" => rep, "term" => term}]
    end
    return {"ok" => true, "rules" => rules}
  end
  def runRules(rules, s)
    changed = true
    while changed
      changed = false
      i = 0
      while i < rules.length
        r = rules[i]
        pat = r["pat"]
        rep = r["rep"]
        term = r["term"]
        idx = indexOfSub(s, pat)
        if idx >= 0
          s = _add(_add(s[...idx], rep), s[_add(idx, pat.length)...])
          changed = true
          if term
            return s
          end
          break
        end
        i = _add(i, 1)
      end
    end
    return s
  end
  def interpret(ruleset, input)
    p = parseRules(ruleset)
    if !p["ok"]
      return {"ok" => false, "out" => ""}
    end
    out = runRules(p["rules"], input)
    return {"ok" => true, "out" => out}
  end
  $testSet = [{"ruleSet" => "# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample" => "I bought a B of As from T S.", "output" => "I bought a bag of apples from my brother."}, {"ruleSet" => "# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample" => "I bought a B of As from T S.", "output" => "I bought a bag of apples from T shop."}, {"ruleSet" => "# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample" => "I bought a B of As W my Bgage from T S.", "output" => "I bought a bag of apples with my money from T shop."}, {"ruleSet" => "### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n", "sample" => "_1111*11111_", "output" => "11111111111111111111"}, {"ruleSet" => "# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n", "sample" => "000000A000000", "output" => "00011H1111000"}]
  def main()
    puts(_add(_add("validating ", ($testSet.length).to_s), " test cases"))
    failures = false
    i = 0
    while i < $testSet.length
      tc = $testSet[i]
      res = interpret(tc["ruleSet"], tc["sample"])
      if !res["ok"]
        puts(_add(_add("test ", (_add(i, 1)).to_s), " invalid ruleset"))
        failures = true
      else
        if res["out"] != tc["output"]
          puts(_add(_add(_add(_add(_add("test ", (_add(i, 1)).to_s), ": got "), res["out"]), ", want "), tc["output"]))
          failures = true
        end
      end
      i = _add(i, 1)
    end
    if !failures
      puts("no failures")
    end
  end
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
