# Generated by Mochi transpiler v0.10.50 on 2025-07-31 00:15 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _indexOf(s, ch)
  idx = s.index(ch)
  idx ? idx : -1
end


def _split(s, sep)
  s.to_s.split(sep.to_s)
end


def parseIntStr(str, base = 10)
  str.to_i(base)
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def trim(s)
    start = 0
    while start < s.length && (s[start..._add(start, 1)] == " " || s[start..._add(start, 1)] == "\t")
      start = _add(start, 1)
    end
    end_ = s.length
    while end_ > start && (s[end_ - 1...end_] == " " || s[end_ - 1...end_] == "\t")
      end_ = end_ - 1
    end
    return s[start...end_]
  end
  def split(s, sep)
    parts = []
    cur = ""
    i = 0
    while i < s.length
      if sep.length > 0 && _add(i, sep.length) <= s.length && s[i..._add(i, sep.length)] == sep
        parts = parts + [cur]
        cur = ""
        i = _add(i, sep.length)
      else
        cur = _add(cur, s[i..._add(i, 1)])
        i = _add(i, 1)
      end
    end
    parts = parts + [cur]
    return parts
  end
  def splitWS(s)
    out = []
    cur = ""
    i = 0
    while i < s.length
      ch = s[i..._add(i, 1)]
      if ch == " " || ch == "\t"
        if cur.length > 0
          out = out + [cur]
          cur = ""
        end
      else
        cur = _add(cur, ch)
      end
      i = _add(i, 1)
    end
    if cur.length > 0
      out = out + [cur]
    end
    return out
  end
  def indexOf(s, ch)
    i = 0
    while i < s.length
      if s[i..._add(i, 1)] == ch
        return i
      end
      i = _add(i, 1)
    end
    return -1
  end
  def parseIntStr(str)
    i = 0
    neg = false
    if str.length > 0 && str[0...1] == "-"
      neg = true
      i = 1
    end
    n = 0
    digits = {"0" => 0, "1" => 1, "2" => 2, "3" => 3, "4" => 4, "5" => 5, "6" => 6, "7" => 7, "8" => 8, "9" => 9}
    while i < str.length
      n = _add(n * 10, digits[str[i..._add(i, 1)]])
      i = _add(i, 1)
    end
    if neg
      n = -n
    end
    return n
  end
  def parseAsm(asm)
    lines = _split(asm, "\n")
    instrs = []
    labels = {}
    lineNum = 0
    i = 0
    while i < lines.length
      line = lines[i]
      if _indexOf(line, ";") != (-1)
        line = line[0..._indexOf(line, ";")]
      end
      line = trim(line)
      label = ""
      if _indexOf(line, ":") != (-1)
        idx = _indexOf(line, ":")
        label = trim(line[0...idx])
        line = trim(line[_add(idx, 1)...line.length])
      end
      opcode = ""
      arg = ""
      if line.length > 0
        parts = splitWS(line)
        if parts.length > 0
          opcode = parts[0]
        end
        if parts.length > 1
          arg = parts[1]
        else
          ops = {"NOP" => 0, "LDA" => 1, "STA" => 2, "ADD" => 3, "SUB" => 4, "BRZ" => 5, "JMP" => 6, "STP" => 7}
          if !(ops.include?(opcode))
            arg = opcode
            opcode = ""
          end
        end
      end
      if label != ""
        labels[label] = lineNum
      end
      instrs = instrs + [Instruction.new(label: label, opcode: opcode, arg: arg)]
      lineNum = _add(lineNum, 1)
      i = _add(i, 1)
    end
    return {"instructions" => instrs, "labels" => labels}
  end
  def compile(p)
    instrs = p["instructions"]
    labels = p["labels"]
    bytecode = []
    i = 0
    opcodes = {"NOP" => 0, "LDA" => 1, "STA" => 2, "ADD" => 3, "SUB" => 4, "BRZ" => 5, "JMP" => 6, "STP" => 7}
    while i < instrs.length
      ins = instrs[i]
      arg = 0
      if ins.arg != ""
        if labels.key?(ins.arg)
          arg = labels[ins.arg]
        else
          arg = parseIntStr(ins.arg)
        end
      end
      code = 0
      if ins.opcode != ""
        code = opcodes[ins.opcode]
      end
      bytecode = bytecode + [_add(code * 32, arg)]
      i = _add(i, 1)
    end
    while bytecode.length < 32
      bytecode = bytecode + [0]
    end
    return bytecode
  end
  def floorMod(a, b)
    r = a % b
    if r < 0
      r = _add(r, b)
    end
    return r
  end
  def run(bytecode)
    acc = 0
    pc = 0
    mem = []
    i = 0
    while i < bytecode.length
      mem = mem + [bytecode[i]]
      i = _add(i, 1)
    end
    while pc < 32
      op = mem[pc] / 32
      arg = mem[pc] % 32
      pc = _add(pc, 1)
      if op == 0
        next
      else
        if op == 1
          acc = mem[arg]
        else
          if op == 2
            mem[arg] = acc
          else
            if op == 3
              acc = floorMod(_add(acc, mem[arg]), 256)
            else
              if op == 4
                acc = floorMod(acc - mem[arg], 256)
              else
                if op == 5
                  if acc == 0
                    pc = arg
                  end
                else
                  if op == 6
                    pc = arg
                  else
                    if op == 7
                      break
                    else
                      break
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    return acc
  end
  def execute(asm)
    parsed = parseAsm(asm)
    bc = compile(parsed)
    return run(bc)
  end
  def main()
    examples = [_add(_add(_add(_add("LDA   x\n", "ADD   y       ; accumulator = x + y\n"), "STP\n"), "x:            2\n"), "y:            2"), _add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add("loop:   LDA   prodt\n", "        ADD   x\n"), "        STA   prodt\n"), "        LDA   y\n"), "        SUB   one\n"), "        STA   y\n"), "        BRZ   done\n"), "        JMP   loop\n"), "done:   LDA   prodt   ; to display it\n"), "        STP\n"), "x:            8\n"), "y:            7\n"), "prodt:        0\n"), "one:          1"), _add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add("loop:   LDA   n\n", "        STA   temp\n"), "        ADD   m\n"), "        STA   n\n"), "        LDA   temp\n"), "        STA   m\n"), "        LDA   count\n"), "        SUB   one\n"), "        BRZ   done\n"), "        STA   count\n"), "        JMP   loop\n"), "done:   LDA   n       ; to display it\n"), "        STP\n"), "m:            1\n"), "n:            1\n"), "temp:         0\n"), "count:        8       ; valid range: 1-11\n"), "one:          1"), _add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add("start:  LDA   load\n", "ADD   car     ; head of list\n"), "STA   ldcar\n"), "ADD   one\n"), "STA   ldcdr   ; next CONS cell\n"), "ldcar:  NOP\n"), "STA   value\n"), "ldcdr:  NOP\n"), "BRZ   done    ; 0 stands for NIL\n"), "STA   car\n"), "JMP   start\n"), "done:   LDA   value   ; CAR of last CONS\n"), "STP\n"), "load:   LDA   0\n"), "value:        0\n"), "car:          28\n"), "one:          1\n"), "                        ; order of CONS cells\n"), "                        ; in memory\n"), "                        ; does not matter\n"), "        6\n"), "        0       ; 0 stands for NIL\n"), "        2       ; (CADR ls)\n"), "        26      ; (CDDR ls) -- etc.\n"), "        5\n"), "        20\n"), "        3\n"), "        30\n"), "        1       ; value of (CAR ls)\n"), "        22      ; points to (CDR ls)\n"), "        4\n"), "        24"), _add(_add(_add(_add("LDA  3\n", "SUB  4\n"), "STP  0\n"), "         0\n"), "         255"), _add(_add(_add(_add("LDA  3\n", "SUB  4\n"), "STP  0\n"), "                0\n"), "                1"), _add(_add(_add(_add("LDA  3\n", "ADD  4\n"), "STP  0\n"), "                1\n"), "                255")]
    i = 0
    while i < examples.length
      res = execute(examples[i])
      puts((res).to_s)
      i = _add(i, 1)
    end
  end
  Instruction = Struct.new(:label, :opcode, :arg, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
