# Generated by Mochi transpiler v0.10.41 on 2025-07-27 09:09 +0000
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _split(s, sep)
  s.to_s.split(sep.to_s)
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def split(s, sep)
    out = []
    cur = ""
    i = 0
    while i < s.length
      if _add(i, sep.length) <= s.length && s[i..._add(i, sep.length)] == sep
        out = out + [cur]
        cur = ""
        i = _add(i, sep.length)
      else
        cur = _add(cur, s[i..._add(i, 1)])
        i = _add(i, 1)
      end
    end
    out = out + [cur]
    return out
  end
  def join(xs, sep)
    res = ""
    i = 0
    while i < xs.length
      if i > 0
        res = _add(res, sep)
      end
      res = _add(res, xs[i])
      i = _add(i, 1)
    end
    return res
  end
  def trimLeftSpaces(s)
    i = 0
    while i < s.length && s[i..._add(i, 1)] == " "
      i = _add(i, 1)
    end
    return s[i...s.length]
  end
  def makeIndent(outline, tab)
    lines = _split(outline, "\n")
    nodes = []
    lines.each do |line|
      line2 = trimLeftSpaces(line)
      level = (line.length - line2.length) / tab
      nodes = nodes + [{"level" => level, "name" => line2}]
    end
    return nodes
  end
  def toNest(nodes, start, level, n)
    if level == 0
      n["name"] = nodes[0]["name"]
    end
    i = _add(start, 1)
    while i < nodes.length
      node = nodes[i]
      lev = (node["level"])
      if lev == _add(level, 1)
        child = {"name" => node["name"], "children" => []}
        toNest(nodes, i, _add(level, 1), child)
        cs = n["children"]
        cs = cs + [child]
        n["children"] = cs
      else
        if lev <= level
          return
        end
      end
      i = _add(i, 1)
    end
  end
  def countLeaves(n)
    kids = n["children"]
    if kids.length == 0
      return 1
    end
    total = 0
    kids.each do |k|
      total = _add(total, countLeaves(k))
    end
    return total
  end
  def nodesByDepth(root, depth)
    levels = []
    current = [root]
    d = 0
    while d < depth
      levels = levels + [current]
      next_ = []
      current.each do |n|
        kids = n["children"]
        kids.each do |k|
          next_ = next_ + [k]
        end
      end
      current = next_
      d = _add(d, 1)
    end
    return levels
  end
  def toMarkup(n, cols, depth)
    lines = []
    lines = lines + ["{| class=\"wikitable\" style=\"text-align: center;\""]
    l1 = "|-"
    lines = lines + [l1]
    span = countLeaves(n)
    lines = lines + [_add(_add(_add(_add(_add("| style=\"background: ", cols[0]), " \" colSpan="), (span).to_s), " | "), ((n["name"])))]
    lines = lines + [l1]
    lvls = nodesByDepth(n, depth)
    lvl = 1
    while lvl < depth
      nodes = lvls[lvl]
      if nodes.length == 0
        lines = lines + ["|  |"]
      else
        idx = 0
        while idx < nodes.length
          node = nodes[idx]
          span = countLeaves(node)
          col = lvl
          if lvl == 1
            col = _add(idx, 1)
          end
          if col >= cols.length
            col = cols.length - 1
          end
          cell = _add(_add(_add(_add(_add("| style=\"background: ", cols[col]), " \" colspan="), (span).to_s), " | "), ((node["name"])))
          lines = lines + [cell]
          idx = _add(idx, 1)
        end
      end
      if lvl < depth - 1
        lines = lines + [l1]
      end
      lvl = _add(lvl, 1)
    end
    lines = lines + ["|}"]
    return join(lines, "\n")
  end
  def main()
    outline = _add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add("Display an outline as a nested table.\n", "    Parse the outline to a tree,\n"), "        measuring the indent of each line,\n"), "        translating the indentation to a nested structure,\n"), "        and padding the tree to even depth.\n"), "    count the leaves descending from each node,\n"), "        defining the width of a leaf as 1,\n"), "        and the width of a parent node as a sum.\n"), "            (The sum of the widths of its children)\n"), "    and write out a table with 'colspan' values\n"), "        either as a wiki table,\n"), "        or as HTML.")
    yellow = "#ffffe6;"
    orange = "#ffebd2;"
    green = "#f0fff0;"
    blue = "#e6ffff;"
    pink = "#ffeeff;"
    cols = [yellow, orange, green, blue, pink]
    nodes = makeIndent(outline, 4)
    n = {"name" => "", "children" => []}
    toNest(nodes, 0, 0, n)
    puts(toMarkup(n, cols, 4))
    puts("\n")
    outline2 = _add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add(_add("Display an outline as a nested table.\n", "    Parse the outline to a tree,\n"), "        measuring the indent of each line,\n"), "        translating the indentation to a nested structure,\n"), "        and padding the tree to even depth.\n"), "    count the leaves descending from each node,\n"), "        defining the width of a leaf as 1,\n"), "        and the width of a parent node as a sum.\n"), "            (The sum of the widths of its children)\n"), "            Propagating the sums upward as necessary.\n"), "    and write out a table with 'colspan' values\n"), "        either as a wiki table,\n"), "        or as HTML.\n"), "    Optionally add color to the nodes.")
    cols2 = [blue, yellow, orange, green, pink]
    nodes2 = makeIndent(outline2, 4)
    n2 = {"name" => "", "children" => []}
    toNest(nodes2, 0, 0, n2)
    puts(toMarkup(n2, cols2, 4))
  end
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
