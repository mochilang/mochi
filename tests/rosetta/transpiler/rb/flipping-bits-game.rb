# Generated by Mochi transpiler v0.10.50 on 2025-07-30 21:05 +0700

def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

def randInt(seed, n)
  next_ = (_add(seed * 1664525, 1013904223)) % 2147483647
  return [next_, next_ % n]
end
def newBoard(n, seed)
  board = []
  s = seed
  i = 0
  while i < n
    row = []
    j = 0
    while j < n
      r = randInt(s, 2)
      s = r[0]
      row = row + [r[1]]
      j = _add(j, 1)
    end
    board = board + [row]
    i = _add(i, 1)
  end
  return [board, s]
end
def copyBoard(b)
  nb = []
  i = 0
  while i < b.length
    row = []
    j = 0
    while j < b[i].length
      row = row + [b[i][j]]
      j = _add(j, 1)
    end
    nb = nb + [row]
    i = _add(i, 1)
  end
  return nb
end
def flipRow(b, r)
  j = 0
  while j < b[r].length
    b[r][j] = 1 - b[r][j]
    j = _add(j, 1)
  end
  return b
end
def flipCol(b, c)
  i = 0
  while i < b.length
    b[i][c] = 1 - b[i][c]
    i = _add(i, 1)
  end
  return b
end
def boardsEqual(a, b)
  i = 0
  while i < a.length
    j = 0
    while j < a[i].length
      if a[i][j] != b[i][j]
        return false
      end
      j = _add(j, 1)
    end
    i = _add(i, 1)
  end
  return true
end
def shuffleBoard(b, seed)
  s = seed
  n = b.length
  k = 0
  while k < 2 * n
    r = randInt(s, n)
    s = r[0]
    idx = (r[1]).to_i
    if k % 2 == 0
      b = flipRow(b, idx)
    else
      b = flipCol(b, idx)
    end
    k = _add(k, 1)
  end
  return [b, s]
end
def solve(board, target)
  n = board.length
  row = []
  col = []
  i = 0
  while i < n
    diff = (board[i][0] != target[i][0] ? 1 : 0)
    row = row + [diff]
    i = _add(i, 1)
  end
  j = 0
  while j < n
    diff = (board[0][j] != target[0][j] ? 1 : 0)
    val = (_add(diff, row[0])) % 2
    col = col + [val]
    j = _add(j, 1)
  end
  return {"row" => row, "col" => col}
end
def applySolution(b, sol)
  board = b
  moves = 0
  i = 0
  while i < sol["row"].length
    if sol["row"][i] == 1
      board = flipRow(board, i)
      moves = _add(moves, 1)
    end
    i = _add(i, 1)
  end
  j = 0
  while j < sol["col"].length
    if sol["col"][j] == 1
      board = flipCol(board, j)
      moves = _add(moves, 1)
    end
    j = _add(j, 1)
  end
  return [board, moves]
end
def printBoard(b)
  i = 0
  while i < b.length
    line = ""
    j = 0
    while j < b[i].length
      line = _add(line, (b[i][j]).to_s)
      if j < b[i].length - 1
        line = _add(line, " ")
      end
      j = _add(j, 1)
    end
    puts(line)
    i = _add(i, 1)
  end
end
def main()
  n = 3
  seed = 1
  res = newBoard(n, seed)
  target = res[0]
  seed = (res[1]).to_i
  board = copyBoard(target)
  while true
    sres = shuffleBoard(copyBoard(board), seed)
    board = sres[0]
    seed = (sres[1]).to_i
    if !boardsEqual(board, target)
      break
    end
  end
  puts("Target:")
  printBoard(target)
  puts("Board:")
  printBoard(board)
  sol = solve(board, target)
  ares = applySolution(board, sol)
  board = ares[0]
  moves = (ares[1]).to_i
  puts("Solved:")
  printBoard(board)
  puts(_add("Moves: ", (moves).to_s))
end
main()
