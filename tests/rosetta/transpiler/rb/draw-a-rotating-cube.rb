# Generated by Mochi transpiler v0.10.42 on 2025-07-28 10:03 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def _mod(x, m)
    return x - ((((x / m)).to_i).to_f) * m
  end
  def _sin(x)
    y = _mod(_add(x, $PI), $TWO_PI) - $PI
    y2 = y * y
    y3 = y2 * y
    y5 = y3 * y2
    y7 = y5 * y2
    return _add(y - y3 / 6.0, y5 / 120.0) - y7 / 5040.0
  end
  def _cos(x)
    y = _mod(_add(x, $PI), $TWO_PI) - $PI
    y2 = y * y
    y4 = y2 * y2
    y6 = y4 * y2
    return _add(1.0 - y2 / 2.0, y4 / 24.0) - y6 / 720.0
  end
  def rotate(p, ax, ay)
    sinx = _sin(ax)
    cosx = _cos(ax)
    siny = _sin(ay)
    cosy = _cos(ay)
    x1 = p.x
    y1 = p.y * cosx - p.z * sinx
    z1 = _add(p.y * sinx, p.z * cosx)
    x2 = _add(x1 * cosy, z1 * siny)
    z2 = _add(-x1 * siny, z1 * cosy)
    return Point3.new(x: x2, y: y1, z: z2)
  end
  def project(p)
    factor = $scale / (_add(p.z, $distance))
    x = _add(((p.x * factor)).to_i, $width / 2)
    y = _add(((-p.y * factor)).to_i, $height / 2)
    return Point2.new(x: x, y: y)
  end
  def clearGrid()
    g = []
    y = 0
    while y < $height
      row = []
      x = 0
      while x < $width
        row = row + [" "]
        x = _add(x, 1)
      end
      g = g + [row]
      y = _add(y, 1)
    end
    return g
  end
  def drawPoint(g, x, y, ch)
    if x >= 0 && x < $width && y >= 0 && y < $height
      row = g[y]
      row[x] = ch
      g[y] = row
    end
  end
  def bresenham(x0, y0, x1, y1, g, ch)
    dx = x1 - x0
    if dx < 0
      dx = -dx
    end
    dy = y1 - y0
    if dy < 0
      dy = -dy
    end
    sx = -1
    if x0 < x1
      sx = 1
    end
    sy = -1
    if y0 < y1
      sy = 1
    end
    err = dx - dy
    while true
      drawPoint(g, x0, y0, ch)
      if x0 == x1 && y0 == y1
        break
      end
      e2 = 2 * err
      if e2 > (-dy)
        err = err - dy
        x0 = _add(x0, sx)
      end
      if e2 < dx
        err = _add(err, dx)
        y0 = _add(y0, sy)
      end
    end
  end
  def render(g)
    out = ""
    y = 0
    while y < $height
      line = ""
      x = 0
      while x < $width
        line = _add(line, g[y][x])
        x = _add(x, 1)
      end
      out = _add(_add(out, line), "\n")
      y = _add(y, 1)
    end
    return out
  end
  def main()
    f = 0
    while f < 10
      grid = clearGrid()
      rot = []
      i = 0
      ay = _add(($PI / 4.0), ((f).to_f) * $PI / 10.0)
      while i < $nodes.length
        p = rotate($nodes[i], $PI / 4.0, ay)
        pp = project(p)
        rot = rot + [pp]
        i = _add(i, 1)
      end
      e = 0
      while e < $edges.length
        a = $edges[e][0]
        b = $edges[e][1]
        p1 = rot[a]
        p2 = rot[b]
        bresenham(p1.x, p1.y, p2.x, p2.y, grid, "#")
        e = _add(e, 1)
      end
      puts(render(grid))
      f = _add(f, 1)
    end
  end
  $PI = 3.141592653589793
  $TWO_PI = 6.283185307179586
  Point3 = Struct.new(:x, :y, :z, keyword_init: true)
  Point2 = Struct.new(:x, :y, keyword_init: true)
  $nodes = [Point3.new(x: -1.0, y: -1.0, z: -1.0), Point3.new(x: -1.0, y: -1.0, z: 1.0), Point3.new(x: -1.0, y: 1.0, z: -1.0), Point3.new(x: -1.0, y: 1.0, z: 1.0), Point3.new(x: 1.0, y: -1.0, z: -1.0), Point3.new(x: 1.0, y: -1.0, z: 1.0), Point3.new(x: 1.0, y: 1.0, z: -1.0), Point3.new(x: 1.0, y: 1.0, z: 1.0)]
  $edges = [[0, 1], [1, 3], [3, 2], [2, 0], [4, 5], [5, 7], [7, 6], [6, 4], [0, 4], [1, 5], [2, 6], [3, 7]]
  $width = 40
  $height = 20
  $distance = 3.0
  $scale = 8.0
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
