# Generated by Mochi transpiler v0.10.40 on 2025-07-25 21:36 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  Point = Struct.new(:x, :y, keyword_init: true)
  def sqrtApprox(x)
    g = x
    i = 0
    while i < 40
      g = (_add(g, x / g)) / 2.0
      i = _add(i, 1)
    end
    return g
  end
  def hypot(x, y)
    return sqrtApprox(_add(x * x, y * y))
  end
  $Two = "Two circles."
  $R0 = "R==0.0 does not describe circles."
  $Co = "Coincident points describe an infinite number of circles."
  $CoR0 = "Coincident points with r==0.0 describe a degenerate circle."
  $Diam = "Points form a diameter and describe only a single circle."
  $Far = "Points too far apart to form circles."
  def circles(p1, p2, r)
    if p1.x == p2.x && p1.y == p2.y
      if r == 0.0
        return [p1, p1, "Coincident points with r==0.0 describe a degenerate circle."]
      end
      return [p1, p2, "Coincident points describe an infinite number of circles."]
    end
    if r == 0.0
      return [p1, p2, "R==0.0 does not describe circles."]
    end
    dx = p2.x - p1.x
    dy = p2.y - p1.y
    q = hypot(dx, dy)
    if q > 2.0 * r
      return [p1, p2, "Points too far apart to form circles."]
    end
    m = Point.new(x: (_add(p1.x, p2.x)) / 2.0, y: (_add(p1.y, p2.y)) / 2.0)
    if q == 2.0 * r
      return [m, m, "Points form a diameter and describe only a single circle."]
    end
    d = sqrtApprox(r * r - q * q / 4.0)
    ox = d * dx / q
    oy = d * dy / q
    return [Point.new(x: m.x - oy, y: _add(m.y, ox)), Point.new(x: _add(m.x, oy), y: m.y - ox), "Two circles."]
  end
  $td = [[Point.new(x: 0.1234, y: 0.9876), Point.new(x: 0.8765, y: 0.2345), 2.0], [Point.new(x: 0.0, y: 2.0), Point.new(x: 0.0, y: 0.0), 1.0], [Point.new(x: 0.1234, y: 0.9876), Point.new(x: 0.1234, y: 0.9876), 2.0], [Point.new(x: 0.1234, y: 0.9876), Point.new(x: 0.8765, y: 0.2345), 0.5], [Point.new(x: 0.1234, y: 0.9876), Point.new(x: 0.1234, y: 0.9876), 0.0]]
  $td.each do |tc|
    $p1 = tc[0]
    $p2 = tc[1]
    $r = tc[2]
    puts(_add(_add(_add(_add("p1:  {", ($p1["x"]).to_s), " "), ($p1["y"]).to_s), "}"))
    puts(_add(_add(_add(_add("p2:  {", ($p2["x"]).to_s), " "), ($p2["y"]).to_s), "}"))
    puts(_add("r:  ", ($r).to_s))
    $res = circles($p1, $p2, $r)
    $c1 = $res[0]
    $c2 = $res[1]
    $caseStr = $res[2]
    puts(_add("   ", $caseStr))
    if $caseStr == "Points form a diameter and describe only a single circle." || $caseStr == "Coincident points with r==0.0 describe a degenerate circle."
      puts(_add(_add(_add(_add("   Center:  {", ($c1["x"]).to_s), " "), ($c1["y"]).to_s), "}"))
    else
      if $caseStr == "Two circles."
        puts(_add(_add(_add(_add("   Center 1:  {", ($c1["x"]).to_s), " "), ($c1["y"]).to_s), "}"))
        puts(_add(_add(_add(_add("   Center 2:  {", ($c2["x"]).to_s), " "), ($c2["y"]).to_s), "}"))
      end
    end
    puts("")
  end
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
