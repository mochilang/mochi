# Generated by Mochi transpiler v0.10.42 on 2025-07-27 22:27 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def contains(xs, v)
    xs.each do |x|
      if x == v
        return true
      end
    end
    return false
  end
  def copyInts(xs)
    out = []
    xs.each do |x|
      out = out + [x]
    end
    return out
  end
  def sliceEqual(a, b)
    i = 0
    while i < a.length
      if a[i] != b[i]
        return false
      end
      i = _add(i, 1)
    end
    return true
  end
  def reverse(xs)
    i = 0
    j = xs.length - 1
    while i < j
      t = xs[i]
      xs[i] = xs[j]
      xs[j] = t
      i = _add(i, 1)
      j = j - 1
    end
  end
  def perimEqual(p1, p2)
    if p1.length != p2.length
      return false
    end
    p1.each do |v|
      if !p2.include?(v)
        return false
      end
    end
    c = copyInts(p1)
    r = 0
    while r < 2
      i = 0
      while i < c.length
        if sliceEqual(c, p2)
          return true
        end
        t = c[c.length - 1]
        j = c.length - 1
        while j > 0
          c[j] = c[j - 1]
          j = j - 1
        end
        c[0] = t
        i = _add(i, 1)
      end
      reverse(c)
      r = _add(r, 1)
    end
    return false
  end
  def sortEdges(es)
    arr = es
    n = arr.length
    i = 0
    while i < n
      j = 0
      while j < n - 1
        a = arr[j]
        b = arr[_add(j, 1)]
        if a.a > b.a || (a.a == b.a && a.b > b.b)
          arr[j] = b
          arr[_add(j, 1)] = a
        end
        j = _add(j, 1)
      end
      i = _add(i, 1)
    end
    return arr
  end
  def concat(a, b)
    out = []
    a.each do |x|
      out = out + [x]
    end
    b.each do |x|
      out = out + [x]
    end
    return out
  end
  def faceToPerim(face)
    le = face.length
    if le == 0
      return nil
    end
    edges = []
    i = 0
    while i < le
      e = face[i]
      if e.b <= e.a
        return nil
      end
      edges = edges + [e]
      i = _add(i, 1)
    end
    edges = sortEdges(edges)
    firstEdge = edges[0]
    perim = [firstEdge.a, firstEdge.b]
    first = firstEdge.a
    last = firstEdge.b
    edges = edges[1...edges.length]
    le = edges.length
    done = false
    while le > 0 && (!done)
      idx = 0
      found = false
      while idx < le
        e = edges[idx]
        if e.a == last
          perim = perim + [e.b]
          last = e.b
          found = true
        else
          if e.b == last
            perim = perim + [e.a]
            last = e.a
            found = true
          end
        end
        if found
          edges = concat(edges[...idx], edges[_add(idx, 1)...edges.length])
          le = le - 1
          if last == first
            if le == 0
              done = true
            else
              return nil
            end
          end
          break
        end
        idx = _add(idx, 1)
      end
      if !found
        return nil
      end
    end
    return perim[...perim.length - 1]
  end
  def listStr(xs)
    s = "["
    i = 0
    while i < xs.length
      s = _add(s, (xs[i]).to_s)
      if i < xs.length - 1
        s = _add(s, " ")
      end
      i = _add(i, 1)
    end
    s = _add(s, "]")
    return s
  end
  def main()
    puts("Perimeter format equality checks:")
    puts(_add("  Q == R is ", (perimEqual([8, 1, 3], [1, 3, 8])).to_s))
    puts(_add("  U == V is ", (perimEqual([18, 8, 14, 10, 12, 17, 19], [8, 14, 10, 12, 17, 19, 18])).to_s))
    e = [Edge.new(a: 7, b: 11), Edge.new(a: 1, b: 11), Edge.new(a: 1, b: 7)]
    f = [Edge.new(a: 11, b: 23), Edge.new(a: 1, b: 17), Edge.new(a: 17, b: 23), Edge.new(a: 1, b: 11)]
    g = [Edge.new(a: 8, b: 14), Edge.new(a: 17, b: 19), Edge.new(a: 10, b: 12), Edge.new(a: 10, b: 14), Edge.new(a: 12, b: 17), Edge.new(a: 8, b: 18), Edge.new(a: 18, b: 19)]
    h = [Edge.new(a: 1, b: 3), Edge.new(a: 9, b: 11), Edge.new(a: 3, b: 11), Edge.new(a: 1, b: 11)]
    puts("\nEdge to perimeter format translations:")
    faces = [e, f, g, h]
    names = ["E", "F", "G", "H"]
    idx = 0
    while idx < faces.length
      per = faceToPerim(faces[idx])
      if per == nil
        puts(_add(_add("  ", names[idx]), " => Invalid edge format"))
      else
        puts(_add(_add(_add("  ", names[idx]), " => "), listStr(per)))
      end
      idx = _add(idx, 1)
    end
  end
  Edge = Struct.new(:a, :b, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
