# Generated by Mochi transpiler v0.10.50 on 2025-07-31 00:15 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _indexOf(s, ch)
  idx = s.index(ch)
  idx ? idx : -1
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.to_s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def sinApprox(x)
    term = x
    sum = x
    n = 1
    while n <= 10
      denom = (((2 * n) * (_add(2 * n, 1)))).to_f
      term = -term * x * x / denom
      sum = _add(sum, term)
      n = _add(n, 1)
    end
    return sum
  end
  def cosApprox(x)
    term = 1.0
    sum = 1.0
    n = 1
    while n <= 10
      denom = (((2 * n - 1) * (2 * n))).to_f
      term = -term * x * x / denom
      sum = _add(sum, term)
      n = _add(n, 1)
    end
    return sum
  end
  def cis(x)
    return Complex.new(re: cosApprox(x), im: sinApprox(x))
  end
  def add(a, b)
    return Complex.new(re: _add(a.re, b.re), im: _add(a.im, b.im))
  end
  def sub(a, b)
    return Complex.new(re: a.re - b.re, im: a.im - b.im)
  end
  def mul(a, b)
    return Complex.new(re: a.re * b.re - a.im * b.im, im: _add(a.re * b.im, a.im * b.re))
  end
  def ditfft2Rec(x, y, offX, offY, n, s)
    if n == 1
      y[offY] = Complex.new(re: x[offX], im: 0.0)
      return
    end
    ditfft2Rec(x, y, offX, offY, n / 2, 2 * s)
    ditfft2Rec(x, y, _add(offX, s), _add(offY, n / 2), n / 2, 2 * s)
    k = 0
    while k < n / 2
      angle = -2.0 * $PI * ((k).to_f) / ((n).to_f)
      tf = mul(cis(angle), y[_add(_add(offY, k), n / 2)])
      a = add(y[_add(offY, k)], tf)
      b = sub(y[_add(offY, k)], tf)
      y[_add(offY, k)] = a
      y[_add(_add(offY, k), n / 2)] = b
      k = _add(k, 1)
    end
  end
  def ditfft2(x, y, n, s)
    ditfft2Rec(x, y, 0, 0, n, s)
  end
  def main()
    x = [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]
    y = []
    i = 0
    while i < x.length
      y = y + [Complex.new(re: 0.0, im: 0.0)]
      i = _add(i, 1)
    end
    ditfft2(x, y, x.length, 1)
    y.each do |c|
      line = pad(fmt(c.re), 8)
      if c.im >= 0
        line = _add(_add(line, "+"), fmt(c.im))
      else
        line = _add(line, fmt(c.im))
      end
      puts(line)
    end
  end
  def pad(s, w)
    t = s
    while t.length < w
      t = _add(" ", t)
    end
    return t
  end
  def fmt(x)
    y = floorf(_add(x * 10000.0, 0.5)) / 10000.0
    s = (y).to_s
    dot = _indexOf(s, ".")
    if dot == 0 - 1
      s = _add(s, ".0000")
    else
      d = s.length - dot - 1
      while d < 4
        s = _add(s, "0")
        d = _add(d, 1)
      end
    end
    return s
  end
  def floorf(x)
    y = (x).to_i
    return (y).to_f
  end
  def indexOf(s, ch)
    i = 0
    while i < s.length
      if s[i..._add(i, 1)] == ch
        return i
      end
      i = _add(i, 1)
    end
    return 0 - 1
  end
  $PI = 3.141592653589793
  Complex = Struct.new(:re, :im, keyword_init: true)
  main()
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
