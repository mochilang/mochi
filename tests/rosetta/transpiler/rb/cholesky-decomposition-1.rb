# Generated by Mochi transpiler v0.10.40 on 2025-07-25 21:36 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def sqrtApprox(x)
    guess = x
    i = 0
    while i < 20
      guess = (_add(guess, x / guess)) / 2.0
      i = _add(i, 1)
    end
    return guess
  end
  def makeSym(order, elements)
    return {"order" => order, "ele" => elements}
  end
  def unpackSym(m)
    n = m["order"]
    ele = m["ele"]
    mat = []
    idx = 0
    r = 0
    while r < n
      row = []
      c = 0
      while c <= r
        row = row + [ele[idx]]
        idx = _add(idx, 1)
        c = _add(c, 1)
      end
      while c < n
        row = row + [0.0]
        c = _add(c, 1)
      end
      mat = mat + [row]
      r = _add(r, 1)
    end
    r = 0
    while r < n
      c = _add(r, 1)
      while c < n
        mat[r][c] = mat[c][r]
        c = _add(c, 1)
      end
      r = _add(r, 1)
    end
    return mat
  end
  def printMat(m)
    i = 0
    while i < m.length
      line = ""
      j = 0
      while j < m[i].length
        line = _add(line, (m[i][j]).to_s)
        if j < m[i].length - 1
          line = _add(line, " ")
        end
        j = _add(j, 1)
      end
      puts(line)
      i = _add(i, 1)
    end
  end
  def printSym(m)
    printMat(unpackSym(m))
  end
  def printLower(m)
    n = m["order"]
    ele = m["ele"]
    mat = []
    idx = 0
    r = 0
    while r < n
      row = []
      c = 0
      while c <= r
        row = row + [ele[idx]]
        idx = _add(idx, 1)
        c = _add(c, 1)
      end
      while c < n
        row = row + [0.0]
        c = _add(c, 1)
      end
      mat = mat + [row]
      r = _add(r, 1)
    end
    printMat(mat)
  end
  def choleskyLower(a)
    n = a["order"]
    ae = a["ele"]
    le = []
    idx = 0
    while idx < ae.length
      le = le + [0.0]
      idx = _add(idx, 1)
    end
    row = 1
    col = 1
    dr = 0
    dc = 0
    i = 0
    while i < ae.length
      e = ae[i]
      if i < dr
        d = (e - le[i]) / le[dc]
        le[i] = d
        ci = col
        cx = dc
        j = _add(i, 1)
        while j <= dr
          cx = _add(cx, ci)
          ci = _add(ci, 1)
          le[j] = _add(le[j], d * le[cx])
          j = _add(j, 1)
        end
        col = _add(col, 1)
        dc = _add(dc, col)
      else
        le[i] = sqrtApprox(e - le[i])
        row = _add(row, 1)
        dr = _add(dr, row)
        col = 1
        dc = 0
      end
      i = _add(i, 1)
    end
    return {"order" => n, "ele" => le}
  end
  def demo(a)
    puts("A:")
    printSym(a)
    puts("L:")
    l = choleskyLower(a)
    printLower(l)
  end
  demo(makeSym(3, [25.0, 15.0, 18.0, -5.0, 0.0, 11.0]))
  demo(makeSym(4, [18.0, 22.0, 70.0, 54.0, 86.0, 174.0, 42.0, 62.0, 134.0, 106.0]))
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
