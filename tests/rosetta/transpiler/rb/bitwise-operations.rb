# Generated by Mochi transpiler v0.10.40 on 2025-07-25 20:48 +0700

def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

def toUnsigned16(n)
  u = n
  if u < 0
    u = _add(u, 65536)
  end
  return u % 65536
end
def bin16(n)
  u = toUnsigned16(n)
  bits = ""
  mask = 32768
  (0...16).each do |i|
    if u >= mask
      bits = _add(bits, "1")
      u = u - mask
    else
      bits = _add(bits, "0")
    end
    mask = ((mask / 2)).to_i
  end
  return bits
end
def bit_and(a, b)
  ua = toUnsigned16(a)
  ub = toUnsigned16(b)
  res = 0
  bit = 1
  (0...16).each do |i|
    if ua % 2 == 1 && ub % 2 == 1
      res = _add(res, bit)
    end
    ua = ((ua / 2)).to_i
    ub = ((ub / 2)).to_i
    bit = bit * 2
  end
  return res
end
def bit_or(a, b)
  ua = toUnsigned16(a)
  ub = toUnsigned16(b)
  res = 0
  bit = 1
  (0...16).each do |i|
    if ua % 2 == 1 || ub % 2 == 1
      res = _add(res, bit)
    end
    ua = ((ua / 2)).to_i
    ub = ((ub / 2)).to_i
    bit = bit * 2
  end
  return res
end
def bit_xor(a, b)
  ua = toUnsigned16(a)
  ub = toUnsigned16(b)
  res = 0
  bit = 1
  (0...16).each do |i|
    abit = ua % 2
    bbit = ub % 2
    if (abit == 1 && bbit == 0) || (abit == 0 && bbit == 1)
      res = _add(res, bit)
    end
    ua = ((ua / 2)).to_i
    ub = ((ub / 2)).to_i
    bit = bit * 2
  end
  return res
end
def bit_not(a)
  ua = toUnsigned16(a)
  return 65535 - ua
end
def shl(a, b)
  ua = toUnsigned16(a)
  i = 0
  while i < b
    ua = (ua * 2) % 65536
    i = _add(i, 1)
  end
  return ua
end
def shr(a, b)
  ua = toUnsigned16(a)
  i = 0
  while i < b
    ua = ((ua / 2)).to_i
    i = _add(i, 1)
  end
  return ua
end
def las(a, b)
  return shl(a, b)
end
def ras(a, b)
  val = a
  i = 0
  while i < b
    if val >= 0
      val = ((val / 2)).to_i
    else
      val = (((val - 1) / 2)).to_i
    end
    i = _add(i, 1)
  end
  return toUnsigned16(val)
end
def rol(a, b)
  ua = toUnsigned16(a)
  left = shl(ua, b)
  right = shr(ua, 16 - b)
  return toUnsigned16(_add(left, right))
end
def ror(a, b)
  ua = toUnsigned16(a)
  right = shr(ua, b)
  left = shl(ua, 16 - b)
  return toUnsigned16(_add(left, right))
end
def bitwise(a, b)
  puts(_add("a:   ", bin16(a)))
  puts(_add("b:   ", bin16(b)))
  puts(_add("and: ", bin16(bit_and(a, b))))
  puts(_add("or:  ", bin16(bit_or(a, b))))
  puts(_add("xor: ", bin16(bit_xor(a, b))))
  puts(_add("not: ", bin16(bit_not(a))))
  if b < 0
    puts("Right operand is negative, but all shifts require an unsigned right operand (shift distance).")
    return nil
  end
  puts(_add("shl: ", bin16(shl(a, b))))
  puts(_add("shr: ", bin16(shr(a, b))))
  puts(_add("las: ", bin16(las(a, b))))
  puts(_add("ras: ", bin16(ras(a, b))))
  puts(_add("rol: ", bin16(rol(a, b))))
  puts(_add("ror: ", bin16(ror(a, b))))
end
bitwise(-460, 6)
