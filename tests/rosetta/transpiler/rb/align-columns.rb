# Generated by Mochi transpiler v0.10.40 on 2025-07-25 10:39 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  def split(s, sep)
    parts = []
    cur = ""
    i = 0
    while i < s.length
      if sep.length > 0 && _add(i, sep.length) <= s.length && s[i..._add(i, sep.length)] == sep
        parts = parts + [cur]
        cur = ""
        i = _add(i, sep.length)
      else
        cur = _add(cur, s[i..._add(i, 1)])
        i = _add(i, 1)
      end
    end
    parts = parts + [cur]
    return parts
  end
  def rstripEmpty(words)
    n = words.length
    while n > 0 && words[n - 1] == ""
      n = n - 1
    end
    return words[...n]
  end
  def spaces(n)
    out = ""
    i = 0
    while i < n
      out = _add(out, " ")
      i = _add(i, 1)
    end
    return out
  end
  def pad(word, width, align)
    diff = width - word.length
    if align == 0
      return _add(word, spaces(diff))
    end
    if align == 2
      return _add(spaces(diff), word)
    end
    left = ((diff / 2)).to_i
    right = diff - left
    return _add(_add(spaces(left), word), spaces(right))
  end
  def newFormatter(text)
    lines = split(text, "\n")
    fmtLines = []
    width = []
    i = 0
    while i < lines.length
      if lines[i].length == 0
        i = _add(i, 1)
        next
      end
      words = rstripEmpty(split(lines[i], "$"))
      fmtLines = fmtLines + [words]
      j = 0
      while j < words.length
        wlen = words[j].length
        if j == width.length
          width = width + [wlen]
        else
          if wlen > width[j]
            width[j] = wlen
          end
        end
        j = _add(j, 1)
      end
      i = _add(i, 1)
    end
    return {"text" => fmtLines, "width" => width}
  end
  def printFmt(f, align)
    lines = f["text"]
    width = f["width"]
    i = 0
    while i < lines.length
      words = lines[i]
      line = ""
      j = 0
      while j < words.length
        line = _add(_add(line, pad(words[j], width[j], align)), " ")
        j = _add(j, 1)
      end
      puts(line)
      i = _add(i, 1)
    end
    puts("")
  end
  $text = _add(_add(_add(_add(_add("Given$a$text$file$of$many$lines,$where$fields$within$a$line\n", "are$delineated$by$a$single$'dollar'$character,$write$a$program\n"), "that$aligns$each$column$of$fields$by$ensuring$that$words$in$each\n"), "column$are$separated$by$at$least$one$space.\n"), "Further,$allow$for$each$word$in$a$column$to$be$either$left\n"), "justified,$right$justified,$or$center$justified$within$its$column.")
  $f = newFormatter($text)
  printFmt($f, 0)
  printFmt($f, 1)
  printFmt($f, 2)
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
