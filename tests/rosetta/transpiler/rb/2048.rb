# Generated by Mochi transpiler v0.10.40 on 2025-07-25 10:39 +0700
require 'json'

$now_seed = 0
$now_seeded = false
s = ENV['MOCHI_NOW_SEED']
if s && s != ''
  begin
    $now_seed = Integer(s)
    $now_seeded = true
  rescue StandardError
  end
end
def _now()
  if $now_seeded
    $now_seed = ($now_seed * 1664525 + 1013904223) % 2147483647
    $now_seed
  else
    Process.clock_gettime(Process::CLOCK_MONOTONIC, :nanosecond)
  end
end


def _input()
  line = STDIN.gets
  line ? line.chomp : ''
end


require 'objspace'
def _mem()
  ObjectSpace.memsize_of_all
end


def _add(a, b)
  if a.is_a?(Array) && b.is_a?(String)
    a.join + b
  elsif a.is_a?(String) && b.is_a?(Array)
    a + b.join
  else
    a + b
  end
end


def _padStart(s, len, ch)
  s.rjust(len, ch)
end

start_mem = _mem()
start = _now()
  $SIZE = 4
  Board = Struct.new(:cells, keyword_init: true)
  SpawnResult = Struct.new(:board, :full, keyword_init: true)
  SlideResult = Struct.new(:row, :gain, keyword_init: true)
  MoveResult = Struct.new(:board, :score, :moved, keyword_init: true)
  def newBoard()
    b = []
    y = 0
    while y < $SIZE
      row = []
      x = 0
      while x < $SIZE
        row = row + [0]
        x = _add(x, 1)
      end
      b = b + [row]
      y = _add(y, 1)
    end
    return Board.new(cells: b)
  end
  def spawnTile(b)
    grid = b.cells
    empty = []
    y = 0
    while y < $SIZE
      x = 0
      while x < $SIZE
        if grid[y][x] == 0
          empty = empty + [[x, y]]
        end
        x = _add(x, 1)
      end
      y = _add(y, 1)
    end
    if empty.length == 0
      return SpawnResult.new(board: b, full: true)
    end
    idx = _now() % empty.length
    cell = empty[idx]
    val = 4
    if _now() % 10 < 9
      val = 2
    end
    grid[cell[1]][cell[0]] = val
    return SpawnResult.new(board: Board.new(cells: grid), full: empty.length == 1)
  end
  def pad(n)
    s = (n).to_s
    pad = 4 - s.length
    i = 0
    out = ""
    while i < pad
      out = _add(out, " ")
      i = _add(i, 1)
    end
    return _add(out, s)
  end
  def draw(b, score)
    puts(_add("Score: ", (score).to_s))
    y = 0
    while y < $SIZE
      puts("+----+----+----+----+")
      line = "|"
      x = 0
      while x < $SIZE
        v = b.cells[y][x]
        if v == 0
          line = _add(line, "    |")
        else
          line = _add(_add(line, pad(v)), "|")
        end
        x = _add(x, 1)
      end
      puts(line)
      y = _add(y, 1)
    end
    puts("+----+----+----+----+")
    puts("W=Up S=Down A=Left D=Right Q=Quit")
  end
  def reverseRow(r)
    out = []
    i = r.length - 1
    while i >= 0
      out = out + [r[i]]
      i = i - 1
    end
    return out
  end
  def slideLeft(row)
    xs = []
    i = 0
    while i < row.length
      if row[i] != 0
        xs = xs + [row[i]]
      end
      i = _add(i, 1)
    end
    res = []
    gain = 0
    i = 0
    while i < xs.length
      if _add(i, 1) < xs.length && xs[i] == xs[_add(i, 1)]
        v = xs[i] * 2
        gain = _add(gain, v)
        res = res + [v]
        i = _add(i, 2)
      else
        res = res + [xs[i]]
        i = _add(i, 1)
      end
    end
    while res.length < $SIZE
      res = res + [0]
    end
    return SlideResult.new(row: res, gain: gain)
  end
  def moveLeft(b, score)
    grid = b.cells
    moved = false
    y = 0
    while y < $SIZE
      r = slideLeft(grid[y])
      new = r.row
      score = _add(score, r.gain)
      x = 0
      while x < $SIZE
        if grid[y][x] != new[x]
          moved = true
        end
        grid[y][x] = new[x]
        x = _add(x, 1)
      end
      y = _add(y, 1)
    end
    return MoveResult.new(board: Board.new(cells: grid), score: score, moved: moved)
  end
  def moveRight(b, score)
    grid = b.cells
    moved = false
    y = 0
    while y < $SIZE
      rev = reverseRow(grid[y])
      r = slideLeft(rev)
      rev = r.row
      score = _add(score, r.gain)
      rev = reverseRow(rev)
      x = 0
      while x < $SIZE
        if grid[y][x] != rev[x]
          moved = true
        end
        grid[y][x] = rev[x]
        x = _add(x, 1)
      end
      y = _add(y, 1)
    end
    return MoveResult.new(board: Board.new(cells: grid), score: score, moved: moved)
  end
  def getCol(b, x)
    col = []
    y = 0
    while y < $SIZE
      col = col + [b.cells[y][x]]
      y = _add(y, 1)
    end
    return col
  end
  def setCol(b, x, col)
    rows = b.cells
    y = 0
    while y < $SIZE
      row = rows[y]
      row[x] = col[y]
      rows[y] = row
      y = _add(y, 1)
    end
    b["cells"] = rows
  end
  def moveUp(b, score)
    grid = b.cells
    moved = false
    x = 0
    while x < $SIZE
      col = getCol(b, x)
      r = slideLeft(col)
      new = r.row
      score = _add(score, r.gain)
      y = 0
      while y < $SIZE
        if grid[y][x] != new[y]
          moved = true
        end
        grid[y][x] = new[y]
        y = _add(y, 1)
      end
      x = _add(x, 1)
    end
    return MoveResult.new(board: Board.new(cells: grid), score: score, moved: moved)
  end
  def moveDown(b, score)
    grid = b.cells
    moved = false
    x = 0
    while x < $SIZE
      col = reverseRow(getCol(b, x))
      r = slideLeft(col)
      col = r.row
      score = _add(score, r.gain)
      col = reverseRow(col)
      y = 0
      while y < $SIZE
        if grid[y][x] != col[y]
          moved = true
        end
        grid[y][x] = col[y]
        y = _add(y, 1)
      end
      x = _add(x, 1)
    end
    return MoveResult.new(board: Board.new(cells: grid), score: score, moved: moved)
  end
  def hasMoves(b)
    y = 0
    while y < $SIZE
      x = 0
      while x < $SIZE
        if b.cells[y][x] == 0
          return true
        end
        if _add(x, 1) < $SIZE && b.cells[y][x] == b.cells[y][_add(x, 1)]
          return true
        end
        if _add(y, 1) < $SIZE && b.cells[y][x] == b.cells[_add(y, 1)][x]
          return true
        end
        x = _add(x, 1)
      end
      y = _add(y, 1)
    end
    return false
  end
  def has2048(b)
    y = 0
    while y < $SIZE
      x = 0
      while x < $SIZE
        if b.cells[y][x] >= 2048
          return true
        end
        x = _add(x, 1)
      end
      y = _add(y, 1)
    end
    return false
  end
  $board = newBoard()
  $r = spawnTile($board)
  $board = $r.board
  $full = $r.full
  $r = spawnTile($board)
  $board = $r.board
  $full = $r.full
  $score = 0
  draw($board, $score)
  while true
    puts("Move: ")
    $cmd = _input()
    $moved = false
    if $cmd == "a" || $cmd == "A"
      $m = moveLeft($board, $score)
      $board = $m.board
      $score = $m.score
      $moved = $m.moved
    end
    if $cmd == "d" || $cmd == "D"
      $m = moveRight($board, $score)
      $board = $m.board
      $score = $m.score
      $moved = $m.moved
    end
    if $cmd == "w" || $cmd == "W"
      $m = moveUp($board, $score)
      $board = $m.board
      $score = $m.score
      $moved = $m.moved
    end
    if $cmd == "s" || $cmd == "S"
      $m = moveDown($board, $score)
      $board = $m.board
      $score = $m.score
      $moved = $m.moved
    end
    if $cmd == "q" || $cmd == "Q"
      break
    end
    if $moved
      $r2 = spawnTile($board)
      $board = $r2.board
      $full = $r2.full
      if $full && (!hasMoves($board))
        draw($board, $score)
        puts("Game Over")
        break
      end
    end
    draw($board, $score)
    if has2048($board)
      puts("You win!")
      break
    end
    if !hasMoves($board)
      puts("Game Over")
      break
    end
  end
end_time = _now()
end_mem = _mem()
result = {"duration_us" => ((end_time - start) / 1000), "memory_bytes" => (end_mem - start_mem), "name" => "main"}
puts(JSON.pretty_generate(result))
