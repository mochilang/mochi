// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:14Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const msg = "Rosetta Code Base64 decode data task"; // []const u8
const enc = base64Encode(msg); // []const u8
const dec = base64Decode(enc); // []const u8

fn indexOf(s: []const u8, ch: []const u8) i32 {
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        if (std.mem.eql(u8, s[i], ch)) {
            return i;
        }
        i = (i + 1);
    }
    return -1;
}

fn parseIntStr(str: []const u8) i32 {
    var i = 0; // i32
    var neg = false; // bool
    if ((@as(i32, @intCast((str).len)) > 0) and std.mem.eql(u8, str[0], "-")) {
        neg = true;
        i = 1;
    }
    var n = 0; // i32
    const Digits = struct {
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
};
    const digits = Digits{
    ._ = 0,
    ._ = 1,
    ._ = 2,
    ._ = 3,
    ._ = 4,
    ._ = 5,
    ._ = 6,
    ._ = 7,
    ._ = 8,
    ._ = 9,
}; // struct {
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
    _: i32,
}
    while (i < @as(i32, @intCast((str).len))) {
        n = ((n * 10) + digits[str[i]]);
        i = (i + 1);
    }
    if (neg) {
        n = -n;
    }
    return n;
}

fn ord(ch: []const u8) i32 {
    const upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // []const u8
    const lower = "abcdefghijklmnopqrstuvwxyz"; // []const u8
    var idx: i32 = indexOf(upper, ch); // i32
    if (idx >= 0) {
        return (65 + idx);
    }
    idx = indexOf(lower, ch);
    if (idx >= 0) {
        return (97 + idx);
    }
    if (std.mem.order(u8, ch, "0") != .lt and std.mem.order(u8, ch, "9") != .gt) {
        return (48 + parseIntStr(ch));
    }
    if (std.mem.eql(u8, ch, "+")) {
        return 43;
    }
    if (std.mem.eql(u8, ch, "/")) {
        return 47;
    }
    if (std.mem.eql(u8, ch, " ")) {
        return 32;
    }
    if (std.mem.eql(u8, ch, "=")) {
        return 61;
    }
    return 0;
}

fn chr(n: i32) []const u8 {
    const upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // []const u8
    const lower = "abcdefghijklmnopqrstuvwxyz"; // []const u8
    if ((n >= 65) and (n < 91)) {
        return _slice_string(upper, (n - 65), (n - 64), 1);
    }
    if ((n >= 97) and (n < 123)) {
        return _slice_string(lower, (n - 97), (n - 96), 1);
    }
    if ((n >= 48) and (n < 58)) {
        const digits = "0123456789"; // []const u8
        return _slice_string(digits, (n - 48), (n - 47), 1);
    }
    if (n == 43) {
        return "+";
    }
    if (n == 47) {
        return "/";
    }
    if (n == 32) {
        return " ";
    }
    if (n == 61) {
        return "=";
    }
    return "?";
}

fn toBinary(n: i32, bits: i32) []const u8 {
    var b = ""; // []const u8
    var val = n; // i32
    var i = 0; // i32
    while (i < bits) {
        b = _concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{@mod(val, 2)}) catch |err| handleError(err), b);
        val = @as(i32, ((val / 2)));
        i = (i + 1);
    }
    return b;
}

fn binToInt(bits: []const u8) i32 {
    var n = 0; // i32
    var i = 0; // i32
    while (i < @as(i32, @intCast((bits).len))) {
        n = ((n * 2) + parseIntStr(_slice_string(bits, i, (i + 1), 1)));
        i = (i + 1);
    }
    return n;
}

fn base64Encode(text: []const u8) []const u8 {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // []const u8
    var bin = ""; // []const u8
    for (text) |ch| {
        bin = _concat_string(bin, toBinary(ord(ch), 8));
    }
    while (@mod(@as(i32, @intCast((bin).len)), 6) != 0) {
        bin = _concat_string(bin, "0");
    }
    var out = ""; // []const u8
    var i = 0; // i32
    while (i < @as(i32, @intCast((bin).len))) {
        const chunk = _slice_string(bin, i, (i + 6), 1); // []const u8
        const val = binToInt(chunk); // i32
        out = _concat_string(out, _slice_string(alphabet, val, (val + 1), 1));
        i = (i + 6);
    }
    const pad = @mod(((3 - (@mod(@as(i32, @intCast((text).len)), 3)))), 3); // i32
    if (pad == 1) {
        out = _concat_string(out[0..@as(usize, @intCast(@as(i32, @intCast((out).len)) - 1))], "=");
    }
    if (pad == 2) {
        out = _concat_string(out[0..@as(usize, @intCast(@as(i32, @intCast((out).len)) - 2))], "==");
    }
    return out;
}

fn base64Decode(enc: []const u8) []const u8 {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // []const u8
    var bin = ""; // []const u8
    var i = 0; // i32
    while (i < @as(i32, @intCast((enc).len))) {
        const ch = enc[i]; // []const u8
        if (std.mem.eql(u8, ch, "=")) {
            break;
        }
        const idx = indexOf(alphabet, ch); // i32
        bin = _concat_string(bin, toBinary(idx, 6));
        i = (i + 1);
    }
    var out = ""; // []const u8
    i = 0;
    while ((i + 8) <= @as(i32, @intCast((bin).len))) {
        const chunk = _slice_string(bin, i, (i + 8), 1); // []const u8
        const val = binToInt(chunk); // i32
        out = _concat_string(out, chr(val));
        i = (i + 8);
    }
    return out;
}

pub fn main() void {
    std.debug.print("{s}\n", .{_concat_string("Original : ", msg)});
    std.debug.print("{s}\n", .{_concat_string("\nEncoded  : ", enc)});
    std.debug.print("{s}\n", .{_concat_string("\nDecoded  : ", dec)});
}
