// Generated by Mochi Zig transpiler on 2025-08-04 17:00 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const epsilon_var: f64 = 0.000000000000001;
var factval_var: i64 = 1;
var e_var: f64 = 2.0;
var n_var: i64 = 2;
var term_var: f64 = 1.0;

fn absf(x: f64) f64 {
    if (x < 0.0) {
        return @as(f64, @floatFromInt(0)) - x;
    }
    return x;
}

fn pow10(n_param: i64) f64 {
    var r: f64 = 1.0;
    var i: i64 = 0;
    while (i < n_param) {
        r = r * 10.0;
        i = i + 1;
    }
    return r;
}

fn formatFloat(f: f64, prec: i64) []const u8 {
    const scale: f64 = pow10(prec);
    const scaled: f64 = f * scale + 0.5;
    const n_var_1: i64 = @as(i64, @intFromFloat(scaled));
    var digits: []const u8 = _str(n_var_1);
    while (@as(i64, @intCast(digits.len)) <= prec) {
        digits = _concat_string("0", digits);
    }
    const int_part: []const u8 = digits[@intCast(0)..@intCast(@as(i64, @intCast(digits.len)) - prec)];
    const frac_part: []const u8 = digits[@intCast(@as(i64, @intCast(digits.len)) - prec)..@intCast(@as(i64, @intCast(digits.len)))];
    return _concat_string(_concat_string(int_part, "."), frac_part);
}

pub fn main() void {
    while (true) {
        factval_var = factval_var * n_var;
        n_var = n_var + 1;
        term_var = 1.0 / @as(f64, @floatFromInt(factval_var));
        e_var = e_var + term_var;
        if (absf(term_var) < epsilon_var) {
            break;
        }
    }
    std.debug.print("{s}\n", .{_concat_string("e = ", formatFloat(e_var, 15))});
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
