// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

const Map0 = struct {
    text: [][][]const u8,
    width: []i64,
};

const text: []const u8 = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string("Given$a$text$file$of$many$lines,$where$fields$within$a$line\n", "are$delineated$by$a$single$'dollar'$character,$write$a$program\n"), "that$aligns$each$column$of$fields$by$ensuring$that$words$in$each\n"), "column$are$separated$by$at$least$one$space.\n"), "Further,$allow$for$each$word$in$a$column$to$be$either$left\n"), "justified,$right$justified,$or$center$justified$within$its$column.");
const f: i64 = newFormatter(text);

fn split(s: []const u8, sep: []const u8) [][]const u8 {
    var parts: [][]const u8 = &[_][]const u8{};
    var cur: []const u8 = "";
    var i: i64 = 0;
    while (i < std.mem.len(s)) {
        if (std.mem.len(sep) > 0 and i + std.mem.len(sep) <= std.mem.len(s) and s[i..i + std.mem.len(sep)] == sep) {
            parts = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(parts) catch unreachable; _tmp.append(cur) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            cur = "";
            i = i + std.mem.len(sep);
        } else {
            cur = _concat_string(cur, s[i..i + 1]);
            i = i + 1;
        }
    }
    parts = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(parts) catch unreachable; _tmp.append(cur) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
    return parts;
}

fn rstripEmpty(words: [][]const u8) [][]const u8 {
    var n: i64 = std.mem.len(words);
    while (n > 0 and words[@as(usize, @intCast(n - 1))] == "") {
        n = n - 1;
    }
    return words[..n];
}

fn spaces(n: i64) []const u8 {
    var out: []const u8 = "";
    var i: i64 = 0;
    while (i < n) {
        out = _concat_string(out, " ");
        i = i + 1;
    }
    return out;
}

fn pad(word: []const u8, width: i64, align: i64) []const u8 {
    const diff: i64 = width - std.mem.len(word);
    if (align == 0) {
        return _concat_string(word, spaces(diff));
    }
    if (align == 2) {
        return _concat_string(spaces(diff), word);
    }
    var left: i64 = diff / 2;
    var right: i64 = diff - left;
    return _concat_string(_concat_string(spaces(left), word), spaces(right));
}

fn newFormatter(text: []const u8) i64 {
    var lines: [][][]const u8 = split(text, "\n");
    var fmtLines: [][][]const u8 = &[_][][]const u8{};
    var width: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < std.mem.len(lines)) {
        if (std.mem.len(lines[@as(usize, @intCast(i))]) == 0) {
            i = i + 1;
            continue;
        }
        var words: [][]const u8 = rstripEmpty(split(lines[@as(usize, @intCast(i))], "$"));
        fmtLines = blk: { var _tmp = std.ArrayList([][]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(fmtLines) catch unreachable; _tmp.append(words) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        var j: i64 = 0;
        while (j < std.mem.len(words)) {
            const wlen: i64 = std.mem.len(words[@as(usize, @intCast(j))]);
            if (j == std.mem.len(width)) {
                width = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(width) catch unreachable; _tmp.append(wlen) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            } else {
                if (wlen > width[@as(usize, @intCast(j))]) {
                    width[@as(usize, @intCast(j))] = wlen;
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return .{ .text = fmtLines, .width = width };
}

fn printFmt(f: i64, align: i64) void {
    const lines: [][][]const u8 = f[@as(usize, @intCast("text"))];
    const width: []i64 = f[@as(usize, @intCast("width"))];
    var i: i64 = 0;
    while (i < std.mem.len(lines)) {
        const words: [][]const u8 = lines[@as(usize, @intCast(i))];
        var line: []const u8 = "";
        var j: i64 = 0;
        while (j < std.mem.len(words)) {
            line = _concat_string(_concat_string(line, pad(words[@as(usize, @intCast(j))], width[@as(usize, @intCast(j))], align)), " ");
            j = j + 1;
        }
        std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
        i = i + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{""}) catch unreachable;
}

pub fn main() void {
    printFmt(f, 0);
    printFmt(f, 1);
    printFmt(f, 2);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
