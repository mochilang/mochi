// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:59Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_list(comptime T: type, v: []const T, start: i32, end: i32, step: i32) []T {
    var s = start;
    var e = end;
    var st = step;
    const n: i32 = @as(i32, @intCast(v.len));
    if (s < 0) s += n;
    if (e < 0) e += n;
    if (st == 0) st = 1;
    if (s < 0) s = 0;
    if (e > n) e = n;
    if (st > 0 and e < s) e = s;
    if (st < 0 and e > s) e = s;
    var res = std.ArrayList(T).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = s;
    while ((st > 0 and i < e) or (st < 0 and i > e)) : (i += st) {
        res.append(v[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn _split_string(s: []const u8, sep: []const u8) []const []const u8 {
    var res = std.ArrayList([]const u8).init(std.heap.page_allocator);
    defer res.deinit();
    var it = std.mem.split(u8, s, sep);
    while (it.next()) |p| { res.append(p) catch |err| handleError(err); }
    return res.toOwnedSlice() catch |err| handleError(err);
}

const text = _concat_string(_concat_string(_concat_string(_concat_string("Given$a$text$file$of$many$lines,$where$fields$within$a$line\nare$delineated$by$a$single$'dollar'$character,$write$a$program\n", "that$aligns$each$column$of$fields$by$ensuring$that$words$in$each\n"), "column$are$separated$by$at$least$one$space.\n"), "Further,$allow$for$each$word$in$a$column$to$be$either$left\n"), "justified,$right$justified,$or$center$justified$within$its$column."); // []const u8
const f = newFormatter(text); // std.StringHashMap(i32)

fn split(s: []const u8, sep: []const u8) []const []const u8 {
    var parts = std.ArrayList(u8).init(std.heap.page_allocator);
    var cur = ""; // []const u8
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        if (((@as(i32, @intCast((sep).len)) > 0) and ((i + @as(i32, @intCast((sep).len))) <= @as(i32, @intCast((s).len)))) and std.mem.eql(u8, _slice_string(s, i, (i + @as(i32, @intCast((sep).len))), 1), sep)) {
            parts = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(parts) catch |err| handleError(err); _tmp0.append(cur) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
            cur = "";
            i = (i + @as(i32, @intCast((sep).len)));
        } else {
            cur = _concat_string(cur, _slice_string(s, i, (i + 1), 1));
            i = (i + 1);
        }
    }
    parts = blk1: { var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(parts) catch |err| handleError(err); _tmp1.append(cur) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
    return parts.items;
}

fn rstripEmpty(words: []const []const u8) []const []const u8 {
    var n = @as(i32, @intCast((words).len)); // i32
    while ((n > 0) and std.mem.eql(u8, words[(n - 1)], "")) {
        n = (n - 1);
    }
    return _slice_list([]const u8, words.items, 0, n, 1);
}

fn spaces(n: i32) []const u8 {
    var out = ""; // []const u8
    var i = 0; // i32
    while (i < n) {
        out = _concat_string(out, " ");
        i = (i + 1);
    }
    return out;
}

fn pad(word: []const u8, width: i32, align: i32) []const u8 {
    const diff = (width - @as(i32, @intCast((word).len))); // i32
    if (align == 0) {
        return _concat_string(word, spaces(diff));
    }
    if (align == 2) {
        return _concat_string(spaces(diff), word);
    }
    var left = @as(i32, ((diff / 2))); // i32
    var right = (diff - left); // i32
    return _concat_string(_concat_string(spaces(left), word), spaces(right));
}

fn newFormatter(text: []const u8) std.AutoHashMap([]const u8, i32) {
    var lines = _split_string(text, "\n"); // []const []const u8
    var fmtLines = std.ArrayList([]const u8).init(std.heap.page_allocator);
    var width = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < @as(i32, @intCast((lines).len))) {
        if (@as(i32, @intCast((lines[i]).len)) == 0) {
            i = (i + 1);
            continue;
        }
        var words = rstripEmpty(_split_string(lines[i], "$")); // []const []const u8
        fmtLines = blk2: { var _tmp2 = std.ArrayList([]const []const u8).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(fmtLines) catch |err| handleError(err); _tmp2.append(words) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
        var j = 0; // i32
        while (j < @as(i32, @intCast((words).len))) {
            const wlen = @as(i32, @intCast((words[j]).len)); // i32
            if (j == @as(i32, @intCast((width).len))) {
                width = blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(width) catch |err| handleError(err); _tmp3.append(wlen) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
            } else             if (wlen > width[j]) {
                width.items[j] = wlen;
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return struct {
    text: []const []const []const u8,
    width: []const i32,
}{
    .text = fmtLines,
    .width = width,
};
}

fn printFmt(f: std.AutoHashMap([]const u8, i32), align: i32) void {
    const lines = @as([]const []const []const u8, f["text"]); // []const []const []const u8
    const width = @as([]const i32, f["width"]); // []const i32
    var i = 0; // i32
    while (i < @as(i32, @intCast((lines).len))) {
        const words = lines[i]; // []const []const u8
        var line = ""; // []const u8
        var j = 0; // i32
        while (j < @as(i32, @intCast((words).len))) {
            line = _concat_string(_concat_string(line, pad(words[j], width[j], align)), " ");
            j = (j + 1);
        }
        std.debug.print("{s}\n", .{line});
        i = (i + 1);
    }
    std.debug.print("\n", .{});
}

pub fn main() void {
    printFmt(f, 0);
    printFmt(f, 1);
    printFmt(f, 2);
}
