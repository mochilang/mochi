// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:00:42Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn primeFactors(n: i32) []const i32 {
    var factors = std.ArrayList(i32).init(std.heap.page_allocator);
    var x = n; // i32
    while (@mod(x, 2) == 0) {
        factors = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(factors) catch |err| handleError(err); _tmp0.append(2) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
        x = @as(i32, ((x / 2)));
    }
    var p = 3; // i32
    while ((p * p) <= x) {
        while (@mod(x, p) == 0) {
            factors = blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(factors) catch |err| handleError(err); _tmp1.append(p) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
            x = @as(i32, ((x / p)));
        }
        p = (p + 2);
    }
    if (x > 1) {
        factors = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(factors) catch |err| handleError(err); _tmp2.append(x) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
    }
    return factors.items;
}

fn repeat(ch: []const u8, n: i32) []const u8 {
    var s = ""; // []const u8
    var i = 0; // i32
    while (i < n) {
        s = _concat_string(s, ch);
        i = (i + 1);
    }
    return s;
}

fn D(n: f64) f64 {
    if (n < 0.0) {
        return -D(-n);
    }
    if (n < 2.0) {
        return 0.0;
    }
    var factors = std.ArrayList(i32).init(std.heap.page_allocator);
    if (n < 10000000000000000000.0) {
        factors = primeFactors(@as(i32, (n)));
    } else {
        const g = @as(i32, ((n / 100.0))); // i32
        factors = primeFactors(g);
        factors = blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(factors) catch |err| handleError(err); _tmp3.append(2) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
        factors = blk4: { var _tmp4 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(factors) catch |err| handleError(err); _tmp4.append(2) catch |err| handleError(err); const res = _tmp4.toOwnedSlice() catch |err| handleError(err); break :blk4 res; };
        factors = blk5: { var _tmp5 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp5.deinit(); _tmp5.appendSlice(factors) catch |err| handleError(err); _tmp5.append(5) catch |err| handleError(err); const res = _tmp5.toOwnedSlice() catch |err| handleError(err); break :blk5 res; };
        factors = blk6: { var _tmp6 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp6.deinit(); _tmp6.appendSlice(factors) catch |err| handleError(err); _tmp6.append(5) catch |err| handleError(err); const res = _tmp6.toOwnedSlice() catch |err| handleError(err); break :blk6 res; };
    }
    const c = @as(i32, @intCast((factors).len)); // i32
    if (c == 1) {
        return 1.0;
    }
    if (c == 2) {
        return @as(f64, ((factors.items[0] + factors.items[1])));
    }
    const d = (n / (@as(f64, factors[0]))); // f64
    return ((D(d) * (@as(f64, factors.items[0]))) + d);
}

fn pad(n: i32) []const u8 {
    var s = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{n}) catch |err| handleError(err); // []const u8
    while (@as(i32, @intCast((s).len)) < 4) {
        s = _concat_string(" ", s);
    }
    return s;
}

fn user_main() void {
    var vals = std.ArrayList(i32).init(std.heap.page_allocator);
    var n = -99; // i32
    while (n < 101) {
        vals = blk7: { var _tmp7 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp7.deinit(); _tmp7.appendSlice(vals) catch |err| handleError(err); _tmp7.append(@as(i32, (D(@as(f64, n))))) catch |err| handleError(err); const res = _tmp7.toOwnedSlice() catch |err| handleError(err); break :blk7 res; };
        n = (n + 1);
    }
    var i = 0; // i32
    while (i < @as(i32, @intCast((vals).len))) {
        var line = ""; // []const u8
        var j = 0; // i32
        while (j < 10) {
            line = _concat_string(line, pad(vals[(i + j)]));
            if (j < 9) {
                line = _concat_string(line, " ");
            }
            j = (j + 1);
        }
        std.debug.print("{s}\n", .{line});
        i = (i + 10);
    }
    var pow = 1.0; // f64
    var m = 1; // i32
    while (m < 21) {
        pow = (pow * 10.0);
        var exp = std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{m}) catch |err| handleError(err); // []const u8
        if (@as(i32, @intCast((exp).len)) < 2) {
            exp = _concat_string(exp, " ");
        }
        var res = (std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{m}) catch |err| handleError(err) + repeat("0", (m - 1))); // []const u8
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string("D(10^", exp), ") / 7 = "), res)});
        m = (m + 1);
    }
}

pub fn main() void {
    user_main();
}
