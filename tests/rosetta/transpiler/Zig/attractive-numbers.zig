// Generated by Mochi Zig transpiler on 2025-08-02 16:55 +0700
const std = @import("std");

fn isPrime(n: i64) bool {
    if (n < 2) {
        return false;
    }
    if (@mod(n, 2) == 0) {
        return n == 2;
    }
    if (@mod(n, 3) == 0) {
        return n == 3;
    }
    var d: i64 = 5;
    while (d * d <= n) {
        if (@mod(n, d) == 0) {
            return false;
        }
        d = d + 2;
        if (@mod(n, d) == 0) {
            return false;
        }
        d = d + 4;
    }
    return true;
}

fn countPrimeFactors(n_param: i64) i64 {
    var n_var: i64 = n_param;
    if (n_var == 1) {
        return 0;
    }
    if (isPrime(n_var)) {
        return 1;
    }
    var count: i64 = 0;
    var f: i64 = 2;
    while (true) {
        if (@mod(n_var, f) == 0) {
            count = count + 1;
            n_var = @divTrunc(n_var, f);
            if (n_var == 1) {
                return count;
            }
            if (isPrime(n_var)) {
                f = n_var;
            }
        } else {
            if (f >= 3) {
                f = f + 2;
            } else {
                f = 3;
            }
        }
    }
    return count;
}

fn pad4(n: i64) []const u8 {
    var s: []const u8 = _str(n);
    while (@intCast(i64, s.len) < 4) {
        s = _concat_string(" ", s);
    }
    return s;
}

fn mochi_main() void {
    const max: i64 = 120;
    std.debug.print("{s}\n", .{_concat_string(_concat_string("The attractive numbers up to and including ", _str(max)), " are:")});
    var count: i64 = 0;
    var line: []const u8 = "";
    var line_count: i64 = 0;
    var i: i64 = 1;
    while (i <= max) {
        const c: i64 = countPrimeFactors(i);
        if (isPrime(c)) {
            line = _concat_string(line, pad4(i));
            count = count + 1;
            line_count = line_count + 1;
            if (line_count == 20) {
                std.debug.print("{s}\n", .{line});
                line = "";
                line_count = 0;
            }
        }
        i = i + 1;
    }
    if (line_count > 0) {
        std.debug.print("{s}\n", .{line});
    }
}

pub fn main() void {
    {
        const __start = _now();
        mochi_main();
        const __end = _now();
        const __duration_us = @divTrunc(@intCast(i64, __end - __start), 1000);
        const __memory_bytes = _mem();
        std.debug.print("{{\"duration_us\":{d},\"memory_bytes\":{d},\"name\":\"main\"}}\n", .{__duration_us, __memory_bytes});
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |env_seed| {
            defer std.heap.page_allocator.free(env_seed);
            if (std.fmt.parseInt(i64, env_seed, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @intCast(i64, std.time.nanoTimestamp());
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ lhs, rhs }) catch unreachable;
}

fn _mem() i64 {
    return 0;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
