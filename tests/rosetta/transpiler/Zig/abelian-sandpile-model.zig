// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

const dim: i64 = 16;

fn newPile(d: i64) [][]i64 {
    var b: [][]i64 = &[_][]i64{};
    var y: i64 = 0;
    while (y < d) {
        var row: []i64 = &[_]i64{};
        var x: i64 = 0;
        while (x < d) {
            row = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(row) catch unreachable; _tmp.append(0) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            x = x + 1;
        }
        b = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(b) catch unreachable; _tmp.append(row) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        y = y + 1;
    }
    return b;
}

fn handlePile(pile: [][]i64, x: i64, y: i64) [][]i64 {
    if (pile[@as(usize, @intCast(y))][@as(usize, @intCast(x))] >= 4) {
        pile[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = pile[@as(usize, @intCast(y))][@as(usize, @intCast(x))] - 4;
        if (y > 0) {
            pile[@as(usize, @intCast(y - 1))][@as(usize, @intCast(x))] = pile[@as(usize, @intCast(y - 1))][@as(usize, @intCast(x))] + 1;
            if (pile[@as(usize, @intCast(y - 1))][@as(usize, @intCast(x))] >= 4) {
                pile = handlePile(pile, x, y - 1);
            }
        }
        if (x > 0) {
            pile[@as(usize, @intCast(y))][@as(usize, @intCast(x - 1))] = pile[@as(usize, @intCast(y))][@as(usize, @intCast(x - 1))] + 1;
            if (pile[@as(usize, @intCast(y))][@as(usize, @intCast(x - 1))] >= 4) {
                pile = handlePile(pile, x - 1, y);
            }
        }
        if (y < dim - 1) {
            pile[@as(usize, @intCast(y + 1))][@as(usize, @intCast(x))] = pile[@as(usize, @intCast(y + 1))][@as(usize, @intCast(x))] + 1;
            if (pile[@as(usize, @intCast(y + 1))][@as(usize, @intCast(x))] >= 4) {
                pile = handlePile(pile, x, y + 1);
            }
        }
        if (x < dim - 1) {
            pile[@as(usize, @intCast(y))][@as(usize, @intCast(x + 1))] = pile[@as(usize, @intCast(y))][@as(usize, @intCast(x + 1))] + 1;
            if (pile[@as(usize, @intCast(y))][@as(usize, @intCast(x + 1))] >= 4) {
                pile = handlePile(pile, x + 1, y);
            }
        }
        pile = handlePile(pile, x, y);
    }
    return pile;
}

fn drawPile(pile: [][]i64, d: i64) void {
    const chars: [][]const u8 = @constCast(&[_][]const u8{" ", "░", "▓", "█"})[0..];
    var row: i64 = 0;
    while (row < d) {
        var line: []const u8 = "";
        var col: i64 = 0;
        while (col < d) {
            var v: i64 = pile[@as(usize, @intCast(row))][@as(usize, @intCast(col))];
            if (v > 3) {
                v = 3;
            }
            line = _concat_string(line, chars[@as(usize, @intCast(v))]);
            col = col + 1;
        }
        std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
        row = row + 1;
    }
}

fn mochi_main() void {
    var pile: [][]i64 = newPile(16);
    const hdim: i64 = 7;
    pile[@as(usize, @intCast(hdim))][@as(usize, @intCast(hdim))] = 16;
    pile = handlePile(pile, hdim, hdim);
    drawPile(pile, 16);
}

pub fn main() void {
    mochi_main();
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
