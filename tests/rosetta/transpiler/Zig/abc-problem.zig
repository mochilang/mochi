// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

fn fields(s: []const u8) [][]const u8 {
    var res: [][]const u8 = &[_][]const u8{};
    var cur: []const u8 = "";
    var i: i64 = 0;
    while (i < std.mem.len(s)) {
        const c: []const u8 = s[i..i + 1];
        if (std.mem.eql(u8, c, " ")) {
            if (std.mem.len(cur) > 0) {
                res = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(cur) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, c);
        }
        i = i + 1;
    }
    if (std.mem.len(cur) > 0) {
        res = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(cur) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
    }
    return res;
}

fn canSpell(word: []const u8, blks: [][]const u8) bool {
    if (std.mem.len(word) == 0) {
        return true;
    }
    const c: []const u8 = std.ascii.lowerString(word[0..1]);
    var i: i64 = 0;
    while (i < std.mem.len(blks)) {
        const b: []const u8 = blks[@as(usize, @intCast(i))];
        if (std.mem.eql(u8, c, std.ascii.lowerString(b[0..1])) or c == std.ascii.lowerString(b[1..2])) {
            var rest: [][]const u8 = &[_][]const u8{};
            var j: i64 = 0;
            while (j < std.mem.len(blks)) {
                if (j != i) {
                    rest = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(rest) catch unreachable; _tmp.append(blks[@as(usize, @intCast(j))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                }
                j = j + 1;
            }
            if (canSpell(word[1..], rest)) {
                return true;
            }
        }
        i = i + 1;
    }
    return false;
}

fn newSpeller(blocks: []const u8) i64 {
    const bl: [][]const u8 = fields(blocks);
    return fn_0;
}

fn mochi_main() void {
    const sp: i64 = newSpeller("BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM");
    for (@constCast(&[_][]const u8{"A", "BARK", "BOOK", "TREAT", "COMMON", "SQUAD", "CONFUSE"})[0..]) |__it0| {
        const word = __it0;
        std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(word, " "), _str(sp(word)))}) catch unreachable;
    }
}

fn fn_0(blocks: []const u8, w: []const u8) bool {
    return canSpell(w, bl);
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
