// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:16Z
const std = @import("std");

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

var grid = &[_][]const []const u8{
    &[_][]const u8{
    ".",
    ".",
    ".",
    ".",
    ".",
},
    &[_][]const u8{
    ".",
    "#",
    "#",
    "#",
    ".",
},
    &[_][]const u8{
    ".",
    "#",
    ".",
    "#",
    ".",
},
    &[_][]const u8{
    ".",
    "#",
    "#",
    "#",
    ".",
},
    &[_][]const u8{
    ".",
    ".",
    ".",
    ".",
    ".",
},
}; // []const []const []const u8

fn flood(x: i32, y: i32, repl: []const u8) void {
    const target = grid[y][x]; // []const u8
    if (std.mem.eql(u8, target, repl)) {
        return ;
    }
    const ff = (blk: { const closure = struct { grid: []const []const []const u8, repl: []const u8, target: []const u8, }{ .grid = grid, .repl = repl, .target = target }; break :blk struct { fn inner(px: i32, py: i32) i32 {
        if ((((px < 0) or (py < 0)) or (py >= @as(i32, @intCast((closure.grid).len)))) or (px >= @as(i32, @intCast((closure.grid[0]).len)))) {
            return ;
        }
        if (!std.mem.eql(u8, closure.grid[py][px], closure.target)) {
            return ;
        }
        grid.items[py][px] = closure.repl;
        ff((px - 1), py);
        ff((px + 1), py);
        ff(px, (py - 1));
        ff(px, (py + 1));
} }.inner; });
    ff(x, y);
}

pub fn main() void {
    flood(2, 2, "o");
    for (grid) |row| {
        var line = ""; // []const u8
        for (row) |ch| {
            line = _concat_string(line, ch);
        }
        std.debug.print("{s}\n", .{line});
    }
}
