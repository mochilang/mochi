// Generated by Mochi Zig transpiler on 2025-07-25 12:38 +0700
const std = @import("std");

fn shuffle(xs: []i64) []i64 {
    var arr: []i64 = xs;
    var i: i64 = 99;
    while (i > 0) {
        const j: i64 = @mod(_now(), i + 1);
        const tmp: i64 = arr[@as(usize, @intCast(i))];
        arr[@as(usize, @intCast(i))] = arr[@as(usize, @intCast(j))];
        arr[@as(usize, @intCast(j))] = tmp;
        i = i - 1;
    }
    return arr;
}

fn doTrials(trials: i64, np: i64, strategy: []const u8) void {
    var pardoned: i64 = 0;
    var t: i64 = 0;
    while (t < trials) {
        var drawers: []i64 = &[_]i64{};
        var i: i64 = 0;
        while (i < 100) {
            drawers = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(drawers) catch unreachable; _tmp.append(i) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            i = i + 1;
        }
        drawers = shuffle(drawers);
        var p: i64 = 0;
        var success: bool = true;
        while (p < np) {
            var found: bool = false;
            if (std.mem.eql(u8, strategy, "optimal")) {
                var prev: i64 = p;
                var d: i64 = 0;
                while (d < 50) {
                    const this: i64 = drawers[@as(usize, @intCast(prev))];
                    if (this == p) {
                        found = true;
                        break;
                    }
                    prev = this;
                    d = d + 1;
                }
            } else {
                var opened: []bool = &[_]bool{};
                var k: i64 = 0;
                while (k < 100) {
                    opened = blk: { var _tmp = std.ArrayList(bool).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(opened) catch unreachable; _tmp.append(false) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                    k = k + 1;
                }
                var d: i64 = 0;
                while (d < 50) {
                    var n: i64 = @mod(_now(), 100);
                    while (opened[@as(usize, @intCast(n))]) {
                        n = @mod(_now(), 100);
                    }
                    opened[@as(usize, @intCast(n))] = true;
                    if (drawers[@as(usize, @intCast(n))] == p) {
                        found = true;
                        break;
                    }
                    d = d + 1;
                }
            }
            if (!(found)) {
                success = false;
                break;
            }
            p = p + 1;
        }
        if (success) {
            pardoned = pardoned + 1;
        }
        t = t + 1;
    }
    const rf: f64 = @as(f64, @floatFromInt(pardoned)) / @as(f64, @floatFromInt(trials)) * 100.0;
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("  strategy = ", strategy), "  pardoned = "), _str(pardoned)), " relative frequency = "), _str(rf)), "%")}) catch unreachable;
}

fn mochi_main() void {
    const trials: i64 = 1000;
    for (@constCast(&[_]i64{10, 100})[0..]) |__it0| {
        const np = __it0;
        std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("Results from ", _str(trials)), " trials with "), _str(np)), " prisoners:\n")}) catch unreachable;
        for (@constCast(&[_][]const u8{"random", "optimal"})[0..]) |__it1| {
            const strat = __it1;
            doTrials(trials, np, strat);
        }
    }
}

pub fn main() void {
    mochi_main();
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |s| {
            defer std.heap.page_allocator.free(s);
            if (std.fmt.parseInt(i64, s, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
