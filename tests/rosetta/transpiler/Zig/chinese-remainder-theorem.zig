// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const n = &[_]i32{
    3,
    5,
    7,
}; // []const i32
const a = &[_]i32{
    2,
    3,
    2,
}; // []const i32
const res = crt(a, n); // i32

fn egcd(a: i32, b: i32) []const i32 {
    if (a == 0) {
        return [_]i32{
    b,
    0,
    1,
};
    }
    const res = egcd(@mod(b, a), a); // []const i32
    const g = res[0]; // i32
    const x1 = res[1]; // i32
    const y1 = res[2]; // i32
    return [_]i32{
    g,
    (y1 - (((b / a)) * x1)),
    x1,
};
}

fn modInv(a: i32, m: i32) i32 {
    const r = egcd(a, m); // []const i32
    if (r[0] != 1) {
        return 0;
    }
    const x = r[1]; // i32
    if (x < 0) {
        return (x + m);
    }
    return x;
}

fn crt(a: []const i32, n: []const i32) i32 {
    var prod = 1; // i32
    var i = 0; // i32
    while (i < (n).len) {
        prod = (prod * n[i]);
        i = (i + 1);
    }
    var x = 0; // i32
    i = 0;
    while (i < (n).len) {
        const ni = n[i]; // i32
        const ai = a[i]; // i32
        const p = (prod / ni); // f64
        const inv: i32 = modInv(@mod(p, ni), ni); // i32
        x = (x + ((ai * inv) * p));
        i = (i + 1);
    }
    return @mod(x, prod);
}

pub fn main() void {
    std.debug.print("{s}\n", .{_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{res}) catch |err| handleError(err), " <nil>")});
}
