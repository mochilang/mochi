// Generated by Mochi Zig transpiler on 2025-08-03 23:47 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn padLeft(s: []const u8, w: i64) []const u8 {
    var res: []const u8 = "";
    var n: i64 = w - @as(i64, @intCast(s.len));
    while (n > 0) {
        res = _concat_string(res, " ");
        n = n - 1;
    }
    return _concat_string(res, s);
}

fn indexOfFrom(s: []const u8, ch: []const u8, start: i64) i64 {
    var i: i64 = start;
    while (i < @as(i64, @intCast(s.len))) {
        if (std.mem.eql(u8, s[@intCast(i)..@intCast(i + 1)], ch)) {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;
}

fn containsStr(s: []const u8, sub: []const u8) bool {
    var i_1: i64 = 0;
    const sl: i64 = @as(i64, @intCast(s.len));
    const subl: i64 = @as(i64, @intCast(sub.len));
    while (i_1 <= sl - subl) {
        if (std.mem.eql(u8, s[@intCast(i_1)..@intCast(i_1 + subl)], sub)) {
            return true;
        }
        i_1 = i_1 + 1;
    }
    return false;
}

fn distinct(slist: [][]const u8) [][]const u8 {
    var res_1: [][]const u8 = &[_][]const u8{};
    for (slist) |__it0| {
        const s = __it0;
        var found: bool = false;
        for (res_1) |__it1| {
            const r = __it1;
            if (std.mem.eql(u8, r, s)) {
                found = true;
                break;
            }
        }
        if (!(found)) {
            res_1 = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, res_1)) catch |err| handleError(err); _tmp.append(s) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        }
    }
    return res_1;
}

fn permutations(xs: [][]const u8) [][][]const u8 {
    if (@as(i64, @intCast(xs.len)) <= 1) {
        return blk0: { var _tmp0 = std.heap.page_allocator.alloc([][]const u8, 1) catch unreachable; _tmp0[0] = xs; break :blk0 _tmp0; };
    }
    var res_2: [][][]const u8 = &[_][][]const u8{};
    var i_2: i64 = 0;
    while (i_2 < @as(i64, @intCast(xs.len))) {
        var rest: [][]const u8 = &[_][]const u8{};
        var j: i64 = 0;
        while (j < @as(i64, @intCast(xs.len))) {
            if (j != i_2) {
                rest = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, rest)) catch |err| handleError(err); _tmp.append(xs[@intCast(j)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            }
            j = j + 1;
        }
        const subs: [][][]const u8 = permutations(rest);
        for (subs) |__it2| {
            const p = __it2;
            var perm: [][]const u8 = blk1: { var _tmp1 = std.heap.page_allocator.alloc([]const u8, 1) catch unreachable; _tmp1[0] = xs[@intCast(i_2)]; break :blk1 _tmp1; };
            var k: i64 = 0;
            while (k < @as(i64, @intCast(p.len))) {
                perm = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, perm)) catch |err| handleError(err); _tmp.append(p[@intCast(k)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
                k = k + 1;
            }
            res_2 = blk: { var _tmp = std.ArrayList([][]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const [][]const u8, res_2)) catch |err| handleError(err); _tmp.append(perm) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        }
        i_2 = i_2 + 1;
    }
    return res_2;
}

fn headTailOverlap(s1: []const u8, s2: []const u8) i64 {
    var start: i64 = 0;
    while (true) {
        const ix: i64 = indexOfFrom(s1, s2[@intCast(0)..@intCast(1)], start);
        if (ix == 0 - 1) {
            return 0;
        }
        start = ix;
        var sublen: i64 = @as(i64, @intCast(s1.len)) - start;
        if (sublen > @as(i64, @intCast(s2.len))) {
            sublen = @as(i64, @intCast(s2.len));
        }
        if (std.mem.eql(u8, s2[@intCast(0)..@intCast(sublen)], s1[@intCast(start)..@intCast(start + sublen)])) {
            return sublen;
        }
        start = start + 1;
    }
}

fn deduplicate(slist: [][]const u8) [][]const u8 {
    const arr: [][]const u8 = distinct(slist);
    var filtered: [][]const u8 = &[_][]const u8{};
    var i_3: i64 = 0;
    while (i_3 < @as(i64, @intCast(arr.len))) {
        const s1: []const u8 = arr[@intCast(i_3)];
        var within: bool = false;
        var j_1: i64 = 0;
        while (j_1 < @as(i64, @intCast(arr.len))) {
            if (j_1 != i_3 and containsStr(arr[@intCast(j_1)], s1)) {
                within = true;
                break;
            }
            j_1 = j_1 + 1;
        }
        if (!(within)) {
            filtered = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, filtered)) catch |err| handleError(err); _tmp.append(s1) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        }
        i_3 = i_3 + 1;
    }
    return filtered;
}

fn joinAll(ss: [][]const u8) []const u8 {
    var out: []const u8 = "";
    for (ss) |__it3| {
        const s_1 = __it3;
        out = _concat_string(out, s_1);
    }
    return out;
}

fn shortestCommonSuperstring(slist: [][]const u8) []const u8 {
    const ss: [][]const u8 = deduplicate(slist);
    var shortest: []const u8 = joinAll(ss);
    const perms: [][][]const u8 = permutations(ss);
    var idx: i64 = 0;
    while (idx < @as(i64, @intCast(perms.len))) {
        const perm_1: [][]const u8 = perms[@intCast(idx)];
        var sup: []const u8 = perm_1[@intCast(0)];
        var i_4: i64 = 0;
        while (i_4 < @as(i64, @intCast(ss.len)) - 1) {
            const ov: i64 = headTailOverlap(perm_1[@intCast(i_4)], perm_1[@intCast(i_4 + 1)]);
            sup = _concat_string(sup, perm_1[@intCast(i_4 + 1)][@intCast(ov)..@intCast(@as(i64, @intCast(perm_1[@intCast(i_4 + 1)].len)))]);
            i_4 = i_4 + 1;
        }
        if (@as(i64, @intCast(sup.len)) < @as(i64, @intCast(shortest.len))) {
            shortest = sup;
        }
        idx = idx + 1;
    }
    return shortest;
}

fn printCounts(seq: []const u8) void {
    var a: i64 = 0;
    var c: i64 = 0;
    var g: i64 = 0;
    var t: i64 = 0;
    var i_5: i64 = 0;
    while (i_5 < @as(i64, @intCast(seq.len))) {
        const ch: []const u8 = seq[@intCast(i_5)..@intCast(i_5 + 1)];
        if (std.mem.eql(u8, ch, "A")) {
            a = a + 1;
        } else {
            if (std.mem.eql(u8, ch, "C")) {
                c = c + 1;
            } else {
                if (std.mem.eql(u8, ch, "G")) {
                    g = g + 1;
                } else {
                    if (std.mem.eql(u8, ch, "T")) {
                        t = t + 1;
                    }
                }
            }
        }
        i_5 = i_5 + 1;
    }
    const total: i64 = @as(i64, @intCast(seq.len));
    std.debug.print("{s}\n", .{_concat_string(_concat_string("\nNucleotide counts for ", seq), ":\n")});
    std.debug.print("{s}\n", .{_concat_string(padLeft("A", 10), padLeft(_str(a), 12))});
    std.debug.print("{s}\n", .{_concat_string(padLeft("C", 10), padLeft(_str(c), 12))});
    std.debug.print("{s}\n", .{_concat_string(padLeft("G", 10), padLeft(_str(g), 12))});
    std.debug.print("{s}\n", .{_concat_string(padLeft("T", 10), padLeft(_str(t), 12))});
    std.debug.print("{s}\n", .{_concat_string(padLeft("Other", 10), padLeft(_str(total - (a + c + g + t)), 12))});
    std.debug.print("{s}\n", .{"  ____________________"});
    std.debug.print("{s}\n", .{_concat_string(padLeft("Total length", 14), padLeft(_str(total), 8))});
}

fn mochi_main() void {
    const tests: [][][]const u8 = blk2: { var _tmp2 = std.heap.page_allocator.alloc([][]const u8, 4) catch unreachable; _tmp2[0] = blk3: { var _tmp3 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp3[0] = "TA"; _tmp3[1] = "AAG"; _tmp3[2] = "TA"; _tmp3[3] = "GAA"; _tmp3[4] = "TA"; break :blk3 _tmp3; }; _tmp2[1] = blk4: { var _tmp4 = std.heap.page_allocator.alloc([]const u8, 4) catch unreachable; _tmp4[0] = "CATTAGGG"; _tmp4[1] = "ATTAG"; _tmp4[2] = "GGG"; _tmp4[3] = "TA"; break :blk4 _tmp4; }; _tmp2[2] = blk5: { var _tmp5 = std.heap.page_allocator.alloc([]const u8, 3) catch unreachable; _tmp5[0] = "AAGAUGGA"; _tmp5[1] = "GGAGCGCAUC"; _tmp5[2] = "AUCGCAAUAAGGA"; break :blk5 _tmp5; }; _tmp2[3] = blk6: { var _tmp6 = std.heap.page_allocator.alloc([]const u8, 13) catch unreachable; _tmp6[0] = "ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT"; _tmp6[1] = "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT"; _tmp6[2] = "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"; _tmp6[3] = "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC"; _tmp6[4] = "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT"; _tmp6[5] = "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC"; _tmp6[6] = "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT"; _tmp6[7] = "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC"; _tmp6[8] = "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC"; _tmp6[9] = "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT"; _tmp6[10] = "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC"; _tmp6[11] = "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA"; _tmp6[12] = "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"; break :blk6 _tmp6; }; break :blk2 _tmp2; };
    for (tests) |__it4| {
        const seqs = __it4;
        const scs: []const u8 = shortestCommonSuperstring(seqs);
        printCounts(scs);
    }
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
