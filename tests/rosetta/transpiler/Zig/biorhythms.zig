// Generated by Mochi Zig transpiler on 2025-08-04 15:16 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const p_i_var: f64 = 3.141592653589793;
const t_w_o__p_i_var: f64 = 6.283185307179586;

fn sinApprox(x: f64) f64 {
    var term: f64 = x;
    var sum: f64 = x;
    var n: i64 = 1;
    while (n <= 8) {
        const denom: f64 = @as(f64, @floatFromInt(2 * n * (2 * n + 1)));
        term = (@as(f64, @floatFromInt(0)) - term) * x * x / denom;
        sum = sum + term;
        n = n + 1;
    }
    return sum;
}

fn floor(x: f64) f64 {
    var i: i64 = @as(i64, @intFromFloat(x));
    if (@as(f64, @floatFromInt(i)) > x) {
        i = i - 1;
    }
    return @as(f64, @floatFromInt(i));
}

fn absFloat(x: f64) f64 {
    if (x < 0.0) {
        return @as(f64, @floatFromInt(0)) - x;
    }
    return x;
}

fn absInt(n: i64) i64 {
    if (n < 0) {
        return 0 - n;
    }
    return n;
}

fn parseIntStr(str: []const u8) i64 {
    var i_1: i64 = 0;
    var neg: bool = false;
    if (@as(i64, @intCast(str.len)) > 0 and std.mem.eql(u8, str[@intCast(0)..@intCast(1)], "-")) {
        neg = true;
        i_1 = 1;
    }
    var n_1: i64 = 0;
    var digits: std.StringHashMap(i64) = blk: { var m = std.StringHashMap(i64).init(std.heap.page_allocator); m.put("0", 0) catch unreachable; m.put("1", 1) catch unreachable; m.put("2", 2) catch unreachable; m.put("3", 3) catch unreachable; m.put("4", 4) catch unreachable; m.put("5", 5) catch unreachable; m.put("6", 6) catch unreachable; m.put("7", 7) catch unreachable; m.put("8", 8) catch unreachable; m.put("9", 9) catch unreachable; break :blk m; };
    while (i_1 < @as(i64, @intCast(str.len))) {
        n_1 = n_1 * 10 + digits.get(str[@intCast(i_1)..@intCast(i_1 + 1)]).?;
        i_1 = i_1 + 1;
    }
    if (neg) {
        n_1 = 0 - n_1;
    }
    return n_1;
}

fn parseDate(s: []const u8) []i64 {
    const y: i64 = parseIntStr(s[@intCast(0)..@intCast(4)]);
    const m: i64 = parseIntStr(s[@intCast(5)..@intCast(7)]);
    const d: i64 = parseIntStr(s[@intCast(8)..@intCast(10)]);
    return blk0: { var _tmp0 = std.heap.page_allocator.alloc(i64, 3) catch unreachable; _tmp0[0] = y; _tmp0[1] = m; _tmp0[2] = d; break :blk0 _tmp0; };
}

fn leap(y: i64) bool {
    if (@mod(y, 400) == 0) {
        return true;
    }
    if (@mod(y, 100) == 0) {
        return false;
    }
    return @mod(y, 4) == 0;
}

fn daysInMonth(y: i64, m: i64) i64 {
    const feb: i64 = if (leap(y)) 29 else 28;
    const lengths: []i64 = blk1: { var _tmp1 = std.heap.page_allocator.alloc(i64, 12) catch unreachable; _tmp1[0] = 31; _tmp1[1] = feb; _tmp1[2] = 31; _tmp1[3] = 30; _tmp1[4] = 31; _tmp1[5] = 30; _tmp1[6] = 31; _tmp1[7] = 31; _tmp1[8] = 30; _tmp1[9] = 31; _tmp1[10] = 30; _tmp1[11] = 31; break :blk1 _tmp1; };
    return lengths[@intCast(m - 1)];
}

fn addDays(y: i64, m: i64, d: i64, n: i64) []i64 {
    var yy: i64 = y;
    var mm: i64 = m;
    var dd: i64 = d;
    if (n >= 0) {
        var i_2: i64 = 0;
        while (i_2 < n) {
            dd = dd + 1;
            if (dd > daysInMonth(yy, mm)) {
                dd = 1;
                mm = mm + 1;
                if (mm > 12) {
                    mm = 1;
                    yy = yy + 1;
                }
            }
            i_2 = i_2 + 1;
        }
    } else {
        var i_3: i64 = 0;
        while (i_3 > n) {
            dd = dd - 1;
            if (dd < 1) {
                mm = mm - 1;
                if (mm < 1) {
                    mm = 12;
                    yy = yy - 1;
                }
                dd = daysInMonth(yy, mm);
            }
            i_3 = i_3 - 1;
        }
    }
    return blk2: { var _tmp2 = std.heap.page_allocator.alloc(i64, 3) catch unreachable; _tmp2[0] = yy; _tmp2[1] = mm; _tmp2[2] = dd; break :blk2 _tmp2; };
}

fn pad2(n: i64) []const u8 {
    if (n < 10) {
        return _concat_string("0", _str(n));
    }
    return _str(n);
}

fn dateString(y: i64, m: i64, d: i64) []const u8 {
    return _concat_string(_concat_string(_concat_string(_concat_string(_str(y), "-"), pad2(m)), "-"), pad2(d));
}

fn day(y: i64, m: i64, d: i64) i64 {
    const part1: i64 = 367 * y;
    const part2: i64 = @as(i64, @divTrunc(7 * @as(i64, y + @divTrunc(m + 9, 12)), 4));
    const part3: i64 = @as(i64, @divTrunc(275 * m, 9));
    return part1 - part2 + part3 + d - 730530;
}

fn biorhythms(birth: []const u8, target: []const u8) void {
    const bparts: []i64 = parseDate(birth);
    const by: i64 = bparts[@intCast(0)];
    const bm: i64 = bparts[@intCast(1)];
    const bd: i64 = bparts[@intCast(2)];
    const tparts: []i64 = parseDate(target);
    const ty: i64 = tparts[@intCast(0)];
    const tm: i64 = tparts[@intCast(1)];
    const td: i64 = tparts[@intCast(2)];
    const diff: i64 = absInt(day(ty, tm, td) - day(by, bm, bd));
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string("Born ", birth), ", Target "), target)});
    std.debug.print("{s}\n", .{_concat_string("Day ", _str(diff))});
    const cycles: [][]const u8 = blk3: { var _tmp3 = std.heap.page_allocator.alloc([]const u8, 3) catch unreachable; _tmp3[0] = "Physical day "; _tmp3[1] = "Emotional day"; _tmp3[2] = "Mental day   "; break :blk3 _tmp3; };
    const lengths_1: []i64 = blk4: { var _tmp4 = std.heap.page_allocator.alloc(i64, 3) catch unreachable; _tmp4[0] = 23; _tmp4[1] = 28; _tmp4[2] = 33; break :blk4 _tmp4; };
    const quadrants: [][][]const u8 = blk5: { var _tmp5 = std.heap.page_allocator.alloc([][]const u8, 4) catch unreachable; _tmp5[0] = blk6: { var _tmp6 = std.heap.page_allocator.alloc([]const u8, 2) catch unreachable; _tmp6[0] = "up and rising"; _tmp6[1] = "peak"; break :blk6 _tmp6; }; _tmp5[1] = blk7: { var _tmp7 = std.heap.page_allocator.alloc([]const u8, 2) catch unreachable; _tmp7[0] = "up but falling"; _tmp7[1] = "transition"; break :blk7 _tmp7; }; _tmp5[2] = blk8: { var _tmp8 = std.heap.page_allocator.alloc([]const u8, 2) catch unreachable; _tmp8[0] = "down and falling"; _tmp8[1] = "valley"; break :blk8 _tmp8; }; _tmp5[3] = blk9: { var _tmp9 = std.heap.page_allocator.alloc([]const u8, 2) catch unreachable; _tmp9[0] = "down but rising"; _tmp9[1] = "transition"; break :blk9 _tmp9; }; break :blk5 _tmp5; };
    var i_4: i64 = 0;
    while (i_4 < 3) {
        const length: i64 = lengths_1[@intCast(i_4)];
        const cycle: []const u8 = cycles[@intCast(i_4)];
        const position: i64 = @mod(diff, length);
        const quadrant: i64 = @divTrunc(position * 4, length);
        var percent: f64 = sinApprox(2.0 * p_i_var * @as(f64, @floatFromInt(position)) / @as(f64, @floatFromInt(length)));
        percent = floor(percent * 1000.0) / 10.0;
        var description: []const u8 = "";
        if (percent > 95.0) {
            description = " peak";
        } else {
            if (percent < @as(f64, @floatFromInt(0)) - 95.0) {
                description = " valley";
            } else {
                if (absFloat(percent) < 5.0) {
                    description = " critical transition";
                } else {
                    const days_to_add: i64 = @divTrunc((quadrant + 1) * length, 4) - position;
                    const res: []i64 = addDays(ty, tm, td, days_to_add);
                    const ny: i64 = res[@intCast(0)];
                    const nm: i64 = res[@intCast(1)];
                    const nd: i64 = res[@intCast(2)];
                    const transition: []const u8 = dateString(ny, nm, nd);
                    const trend: []const u8 = quadrants[@intCast(quadrant)][@intCast(0)];
                    const next: []const u8 = quadrants[@intCast(quadrant)][@intCast(1)];
                    var pct: []const u8 = _str(percent);
                    if (!(std.mem.indexOf(u8, pct, ".") != null)) {
                        pct = _concat_string(pct, ".0");
                    }
                    description = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(" ", pct), "% ("), trend), ", next "), next), " "), transition), ")");
                }
            }
        }
        var pos_str: []const u8 = _str(position);
        if (position < 10) {
            pos_str = _concat_string(" ", pos_str);
        }
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(cycle, pos_str), " : "), description)});
        i_4 = i_4 + 1;
    }
    std.debug.print("{s}\n", .{""});
}

fn mochi_main() void {
    const pairs: [][][]const u8 = blk10: { var _tmp10 = std.heap.page_allocator.alloc([][]const u8, 3) catch unreachable; _tmp10[0] = blk11: { var _tmp11 = std.heap.page_allocator.alloc([]const u8, 2) catch unreachable; _tmp11[0] = "1943-03-09"; _tmp11[1] = "1972-07-11"; break :blk11 _tmp11; }; _tmp10[1] = blk12: { var _tmp12 = std.heap.page_allocator.alloc([]const u8, 2) catch unreachable; _tmp12[0] = "1809-01-12"; _tmp12[1] = "1863-11-19"; break :blk12 _tmp12; }; _tmp10[2] = blk13: { var _tmp13 = std.heap.page_allocator.alloc([]const u8, 2) catch unreachable; _tmp13[0] = "1809-02-12"; _tmp13[1] = "1863-11-19"; break :blk13 _tmp13; }; break :blk10 _tmp10; };
    var idx: i64 = 0;
    while (idx < @as(i64, @intCast(pairs.len))) {
        const p: [][]const u8 = pairs[@intCast(idx)];
        biorhythms(p[@intCast(0)], p[@intCast(1)]);
        idx = idx + 1;
    }
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
