// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

fn divisors(n: i64) []i64 {
    var divs: []i64 = @constCast(&[_]i64{1})[0..];
    var divs2: []i64 = &[_]i64{};
    var i: i64 = 2;
    while (i * i <= n) {
        if (@mod(n, i) == 0) {
            const j: i64 = n / i;
            divs = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(divs) catch unreachable; _tmp.append(i) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            if (i != j) {
                divs2 = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(divs2) catch unreachable; _tmp.append(j) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            }
        }
        i = i + 1;
    }
    var j: i64 = std.mem.len(divs2) - 1;
    while (j >= 0) {
        divs = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(divs) catch unreachable; _tmp.append(divs2[@as(usize, @intCast(j))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        j = j - 1;
    }
    return divs;
}

fn sum(xs: []i64) i64 {
    var tot: i64 = 0;
    for (xs) |__it0| {
        const v = __it0;
        tot = tot + v;
    }
    return tot;
}

fn sumStr(xs: []i64) []const u8 {
    var s: []const u8 = "";
    var i: i64 = 0;
    while (i < std.mem.len(xs)) {
        s = _concat_string(_concat_string(s, _str(xs[@as(usize, @intCast(i))])), " + ");
        i = i + 1;
    }
    return s[0..std.mem.len(s) - 3];
}

fn pad2(n: i64) []const u8 {
    const s: []const u8 = _str(n);
    if (std.mem.len(s) < 2) {
        return _concat_string(" ", s);
    }
    return s;
}

fn pad5(n: i64) []const u8 {
    var s: []const u8 = _str(n);
    while (std.mem.len(s) < 5) {
        s = _concat_string(" ", s);
    }
    return s;
}

fn abundantOdd(searchFrom: i64, countFrom: i64, countTo: i64, printOne: bool) i64 {
    var count: i64 = countFrom;
    var n: i64 = searchFrom;
    while (count < countTo) {
        const divs: []i64 = divisors(n);
        const tot: i64 = sum(divs);
        if (tot > n) {
            count = count + 1;
            if (printOne and count < countTo) {
                n = n + 2;
                continue;
            }
            const s: []const u8 = sumStr(divs);
            if (!(printOne)) {
                std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(pad2(count), ". "), pad5(n)), " < "), s), " = "), _str(tot))}) catch unreachable;
            } else {
                std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_str(n), " < "), s), " = "), _str(tot))}) catch unreachable;
            }
        }
        n = n + 2;
    }
    return n;
}

fn mochi_main() void {
    const max: i64 = 25;
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string("The first ", _str(max)), " abundant odd numbers are:")}) catch unreachable;
    const n: i64 = abundantOdd(1, 0, max, false);
    std.io.getStdOut().writer().print("{s}\n", .{"\nThe one thousandth abundant odd number is:"}) catch unreachable;
    abundantOdd(n, max, 1000, true);
    std.io.getStdOut().writer().print("{s}\n", .{"\nThe first abundant odd number above one billion is:"}) catch unreachable;
    abundantOdd(1000000001, 0, 1, true);
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
