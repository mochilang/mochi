// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:16Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn indexOf(s: []const u8, ch: []const u8) i32 {
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        if (std.mem.eql(u8, _slice_string(s, i, (i + 1), 1), ch)) {
            return i;
        }
        i = (i + 1);
    }
    return -1;
}

fn set58(addr: []const u8) []const i32 {
    const tmpl = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"; // []const u8
    var a = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < 25) {
        a = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(a) catch |err| handleError(err); _tmp0.append(0) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
        i = (i + 1);
    }
    var idx = 0; // i32
    while (idx < @as(i32, @intCast((addr).len))) {
        const ch = _slice_string(addr, idx, (idx + 1), 1); // []const u8
        var c = indexOf(tmpl, ch); // i32
        if (c < 0) {
            return []i32{};
        }
        var j = 24; // i32
        while (j >= 0) {
            c = (c + (58 * a[j]));
            a.items[j] = @mod(c, 256);
            c = @as(i32, ((c / 256)));
            j = (j - 1);
        }
        if (c > 0) {
            return []i32{};
        }
        idx = (idx + 1);
    }
    return a.items;
}

fn doubleSHA256(bs: []const i32) []const i32 {
    const first = sha256(bs); // []const i32
    return sha256(first);
}

fn computeChecksum(a: []const i32) []const i32 {
    const hash = doubleSHA256(a[0..21]); // []const i32
    return hash[0..4];
}

fn validA58(addr: []const u8) bool {
    const a = set58(addr); // []const i32
    if (@as(i32, @intCast((a).len)) != 25) {
        return false;
    }
    if (a[0] != 0) {
        return false;
    }
    const sum = computeChecksum(a); // []const i32
    var i = 0; // i32
    while (i < 4) {
        if (a[(21 + i)] != sum[i]) {
            return false;
        }
        i = (i + 1);
    }
    return true;
}

pub fn main() void {
    std.debug.print("{s}\n", .{std.fmt.allocPrint(std.heap.page_allocator, "{s}", .{if (validA58("1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i")) "true" else "false"}) catch |err| handleError(err)});
    std.debug.print("{s}\n", .{std.fmt.allocPrint(std.heap.page_allocator, "{s}", .{if (validA58("17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j")) "true" else "false"}) catch |err| handleError(err)});
}
