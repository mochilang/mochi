// Generated by Mochi Zig transpiler on 2025-08-04 15:16 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn indexOf(s: []const u8, ch: []const u8) i64 {
    var i: i64 = 0;
    while (i < @as(i64, @intCast(s.len))) {
        if (std.mem.eql(u8, s[@intCast(i)..@intCast(i + 1)], ch)) {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;
}

fn set58(addr: []const u8) []i64 {
    const tmpl: []const u8 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var a: []i64 = &[_]i64{};
    var i_1: i64 = 0;
    while (i_1 < 25) {
        a = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const i64, a)) catch |err| handleError(err); _tmp.append(0) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i_1 = i_1 + 1;
    }
    var idx: i64 = 0;
    while (idx < @as(i64, @intCast(addr.len))) {
        const ch: []const u8 = addr[@intCast(idx)..@intCast(idx + 1)];
        var c: i64 = indexOf(tmpl, ch);
        if (c < 0) {
            return &[_]i64{};
        }
        var j: i64 = 24;
        while (j >= 0) {
            c = c + 58 * a[@intCast(j)];
            a[@intCast(j)] = @mod(c, 256);
            c = @as(i64, @divTrunc(c, 256));
            j = j - 1;
        }
        if (c > 0) {
            return &[_]i64{};
        }
        idx = idx + 1;
    }
    return a;
}

fn doubleSHA256(bs: []i64) []i64 {
    const first: []i64 = _sha256(bs);
    return _sha256(first);
}

fn computeChecksum(a: []i64) []i64 {
    const hash: []i64 = doubleSHA256(a[@intCast(0)..@intCast(21)]);
    return hash[@intCast(0)..@intCast(4)];
}

fn validA58(addr: []const u8) bool {
    const a_1: []i64 = set58(addr);
    if (@as(i64, @intCast(a_1.len)) != 25) {
        return false;
    }
    if (a_1[@intCast(0)] != 0) {
        return false;
    }
    const sum: []i64 = computeChecksum(a_1);
    var i_2: i64 = 0;
    while (i_2 < 4) {
        if (a_1[@intCast(21 + i_2)] != sum[@intCast(i_2)]) {
            return false;
        }
        i_2 = i_2 + 1;
    }
    return true;
}

pub fn main() void {
    std.debug.print("{s}\n", .{_str(validA58("1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i"))});
    std.debug.print("{s}\n", .{_str(validA58("17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j"))});
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _sha256(bs: []i64) []i64 {
    var data = std.heap.page_allocator.alloc(u8, bs.len) catch unreachable;
    defer std.heap.page_allocator.free(data);
    var i: usize = 0;
    while (i < bs.len) { data[i] = @intCast(bs[i]); i += 1; }
    var digest: [32]u8 = undefined;
    std.crypto.hash.sha2.Sha256.hash(data, &digest, .{});
    var out = std.heap.page_allocator.alloc(i64, 32) catch unreachable;
    i = 0;
    while (i < 32) { out[i] = digest[i]; i += 1; }
    return out;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
