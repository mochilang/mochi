// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

const Map0 = struct {
};

const Map1 = struct {
};

var pps: Map0 = .{  };

fn pow10(exp: i64) i64 {
    var n: i64 = 1;
    var i: i64 = 0;
    while (i < exp) {
        n = n * 10;
        i = i + 1;
    }
    return n;
}

fn totient(n: i64) i64 {
    var tot: i64 = n;
    var nn: i64 = n;
    var i: i64 = 2;
    while (i * i <= nn) {
        if (@mod(nn, i) == 0) {
            while (@mod(nn, i) == 0) {
                nn = nn / i;
            }
            tot = tot - tot / i;
        }
        if (i == 2) {
            i = 1;
        }
        i = i + 2;
    }
    if (nn > 1) {
        tot = tot - tot / nn;
    }
    return tot;
}

fn getPerfectPowers(maxExp: i64) void {
    const upper: i64 = pow10(maxExp);
    var i: i64 = 2;
    while (i * i < upper) {
        var p: i64 = i;
        while (true) {
            p = p * i;
            if (p >= upper) {
                break;
            }
            pps[@as(usize, @intCast(p))] = true;
        }
        i = i + 1;
    }
}

fn getAchilles(minExp: i64, maxExp: i64) i64 {
    const lower: i64 = pow10(minExp);
    const upper: i64 = pow10(maxExp);
    var achilles: Map1 = .{  };
    var b: i64 = 1;
    while (b * b * b < upper) {
        const b3: i64 = b * b * b;
        var a: i64 = 1;
        while (true) {
            const p: i64 = b3 * a * a;
            if (p >= upper) {
                break;
            }
            if (p >= lower) {
                if (!(std.mem.indexOfScalar(i64, pps, p) != null)) {
                    achilles[@as(usize, @intCast(p))] = true;
                }
            }
            a = a + 1;
        }
        b = b + 1;
    }
    return achilles;
}

fn sortInts(xs: []i64) []i64 {
    var res: []i64 = &[_]i64{};
    var tmp: []i64 = xs;
    while (std.mem.len(tmp) > 0) {
        var min: i64 = tmp[@as(usize, @intCast(0))];
        var idx: i64 = 0;
        var i: i64 = 1;
        while (i < std.mem.len(tmp)) {
            if (tmp[@as(usize, @intCast(i))] < min) {
                min = tmp[@as(usize, @intCast(i))];
                idx = i;
            }
            i = i + 1;
        }
        res = res + @constCast(&[_]i64{min})[0..];
        var out: []i64 = &[_]i64{};
        var j: i64 = 0;
        while (j < std.mem.len(tmp)) {
            if (j != idx) {
                out = out + @constCast(&[_]i64{tmp[@as(usize, @intCast(j))]})[0..];
            }
            j = j + 1;
        }
        tmp = out;
    }
    return res;
}

fn pad(n: i64, width: i64) []const u8 {
    var s: []const u8 = _str(n);
    while (std.mem.len(s) < width) {
        s = _concat_string(" ", s);
    }
    return s;
}

fn mochi_main() void {
    const maxDigits: i64 = 15;
    getPerfectPowers(5);
    const achSet: i64 = getAchilles(1, 5);
    var ach: []i64 = &[_]i64{};
    for (achSet.keys()) |__it0| {
        const k = __it0;
        ach = ach + @constCast(&[_]i64{k})[0..];
    }
    ach = sortInts(ach);
    std.io.getStdOut().writer().print("{s}\n", .{"First 50 Achilles numbers:"}) catch unreachable;
    var i: i64 = 0;
    while (i < 50) {
        var line: []const u8 = "";
        var j: i64 = 0;
        while (j < 10) {
            line = _concat_string(line, pad(ach[@as(usize, @intCast(i))], 4));
            if (j < 9) {
                line = _concat_string(line, " ");
            }
            i = i + 1;
            j = j + 1;
        }
        std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
    }
    std.io.getStdOut().writer().print("{s}\n", .{"\nFirst 30 strong Achilles numbers:"}) catch unreachable;
    var strong: []i64 = &[_]i64{};
    var count: i64 = 0;
    var idx: i64 = 0;
    while (count < 30) {
        const tot: i64 = totient(ach[@as(usize, @intCast(idx))]);
        if (std.mem.indexOfScalar(i64, achSet, tot) != null) {
            strong = strong + @constCast(&[_]i64{ach[@as(usize, @intCast(idx))]})[0..];
            count = count + 1;
        }
        idx = idx + 1;
    }
    i = 0;
    while (i < 30) {
        var line: []const u8 = "";
        var j: i64 = 0;
        while (j < 10) {
            line = _concat_string(line, pad(strong[@as(usize, @intCast(i))], 5));
            if (j < 9) {
                line = _concat_string(line, " ");
            }
            i = i + 1;
            j = j + 1;
        }
        std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
    }
    std.io.getStdOut().writer().print("{s}\n", .{"\nNumber of Achilles numbers with:"}) catch unreachable;
    const counts: []i64 = @constCast(&[_]i64{1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383})[0..];
    var d: i64 = 2;
    while (d <= maxDigits) {
        const c: i64 = counts[@as(usize, @intCast(d - 2))];
        std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(pad(d, 2), " digits: "), _str(c))}) catch unreachable;
        d = d + 1;
    }
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
