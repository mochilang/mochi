// Generated by Mochi Zig transpiler on 2025-07-27 00:44 +0700
const std = @import("std");

const Board = struct {
    cells: [][]i64,
};

const SpawnResult = struct {
    board: Board,
    full: bool,
};

const SlideResult = struct {
    row: []i64,
    gain: i64,
};

const MoveResult = struct {
    board: Board,
    score: i64,
    moved: bool,
};

const SIZE: i64 = 4;
var board: Board = newBoard();
var r: SpawnResult = spawnTile(board);
var full: bool = r.full;
var score: i64 = 0;

fn newBoard() Board {
    var b: [][]i64 = &[_][]i64{};
    var y: i64 = 0;
    while (y < SIZE) {
        var row: []i64 = &[_]i64{};
        var x: i64 = 0;
        while (x < SIZE) {
            row = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(row) catch unreachable; _tmp.append(0) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            x = x + 1;
        }
        b = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(b) catch unreachable; _tmp.append(row) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        y = y + 1;
    }
    return .{ .cells = b };
}

fn spawnTile(b: Board) SpawnResult {
    var grid: [][]i64 = b.cells;
    var empty: [][]i64 = &[_][]i64{};
    var y: i64 = 0;
    while (y < SIZE) {
        var x: i64 = 0;
        while (x < SIZE) {
            if (grid[@as(usize, @intCast(y))][@as(usize, @intCast(x))] == 0) {
                empty = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(empty) catch unreachable; _tmp.append(@constCast(&[_]i64{x, y})[0..]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            }
            x = x + 1;
        }
        y = y + 1;
    }
    if (std.mem.len(empty) == 0) {
        return .{ .board = b, .full = true };
    }
    var idx: i64 = @mod(_now(), std.mem.len(empty));
    const cell: []i64 = empty[@as(usize, @intCast(idx))];
    var val: i64 = 4;
    if (@mod(_now(), 10) < 9) {
        val = 2;
    }
    grid[@as(usize, @intCast(cell[@as(usize, @intCast(1))]))][@as(usize, @intCast(cell[@as(usize, @intCast(0))]))] = val;
    return .{ .board = .{ .cells = grid }, .full = std.mem.len(empty) == 1 };
}

fn pad(n: i64) []const u8 {
    var s: []const u8 = _str(n);
    var pad: i64 = 4 - std.mem.len(s);
    var i: i64 = 0;
    var out: []i64 = "";
    while (i < pad) {
        out = _concat_string(out, " ");
        i = i + 1;
    }
    return _concat_string(out, s);
}

fn draw(b: Board, score: i64) void {
    std.debug.print("{s}\n", .{_concat_string("Score: ", _str(score))});
    var y: i64 = 0;
    while (y < SIZE) {
        std.debug.print("{s}\n", .{"+----+----+----+----+"});
        var line: []const u8 = "|";
        var x: i64 = 0;
        while (x < SIZE) {
            var v: i64 = b.cells[@as(usize, @intCast(y))][@as(usize, @intCast(x))];
            if (v == 0) {
                line = _concat_string(line, "    |");
            } else {
                line = _concat_string(_concat_string(line, pad(v)), "|");
            }
            x = x + 1;
        }
        std.debug.print("{s}\n", .{line});
        y = y + 1;
    }
    std.debug.print("{s}\n", .{"+----+----+----+----+"});
    std.debug.print("{s}\n", .{"W=Up S=Down A=Left D=Right Q=Quit"});
}

fn reverseRow(r: []i64) []i64 {
    var out: []i64 = &[_]i64{};
    var i: i64 = std.mem.len(r) - 1;
    while (i >= 0) {
        out = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(out) catch unreachable; _tmp.append(r[@as(usize, @intCast(i))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i - 1;
    }
    return out;
}

fn slideLeft(row: []i64) SlideResult {
    var xs: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < std.mem.len(row)) {
        if (row[@as(usize, @intCast(i))] != 0) {
            xs = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(xs) catch unreachable; _tmp.append(row[@as(usize, @intCast(i))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        }
        i = i + 1;
    }
    var res: []i64 = &[_]i64{};
    var gain: i64 = 0;
    i = 0;
    while (i < std.mem.len(xs)) {
        if (i + 1 < std.mem.len(xs) and xs[@as(usize, @intCast(i))] == xs[@as(usize, @intCast(i + 1))]) {
            const v: i64 = xs[@as(usize, @intCast(i))] * 2;
            gain = gain + v;
            res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(v) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            i = i + 2;
        } else {
            res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(xs[@as(usize, @intCast(i))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            i = i + 1;
        }
    }
    while (std.mem.len(res) < SIZE) {
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(0) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
    }
    return .{ .row = res, .gain = gain };
}

fn moveLeft(b: Board, score: i64) MoveResult {
    var grid: [][]i64 = b.cells;
    var moved: bool = false;
    var y: i64 = 0;
    while (y < SIZE) {
        const r: SpawnResult = slideLeft(grid[@as(usize, @intCast(y))]);
        const new: []i64 = r.row;
        score = score + r.gain;
        var x: i64 = 0;
        while (x < SIZE) {
            if (grid[@as(usize, @intCast(y))][@as(usize, @intCast(x))] != new[@as(usize, @intCast(x))]) {
                moved = true;
            }
            grid[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = new[@as(usize, @intCast(x))];
            x = x + 1;
        }
        y = y + 1;
    }
    return .{ .board = .{ .cells = grid }, .score = score, .moved = moved };
}

fn moveRight(b: Board, score: i64) MoveResult {
    var grid: [][]i64 = b.cells;
    var moved: bool = false;
    var y: i64 = 0;
    while (y < SIZE) {
        var rev: []i64 = reverseRow(grid[@as(usize, @intCast(y))]);
        const r: SpawnResult = slideLeft(rev);
        rev = r.row;
        score = score + r.gain;
        rev = reverseRow(rev);
        var x: i64 = 0;
        while (x < SIZE) {
            if (grid[@as(usize, @intCast(y))][@as(usize, @intCast(x))] != rev[@as(usize, @intCast(x))]) {
                moved = true;
            }
            grid[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = rev[@as(usize, @intCast(x))];
            x = x + 1;
        }
        y = y + 1;
    }
    return .{ .board = .{ .cells = grid }, .score = score, .moved = moved };
}

fn getCol(b: Board, x: i64) []i64 {
    var col: []i64 = &[_]i64{};
    var y: i64 = 0;
    while (y < SIZE) {
        col = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(col) catch unreachable; _tmp.append(b.cells[@as(usize, @intCast(y))][@as(usize, @intCast(x))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        y = y + 1;
    }
    return col;
}

fn setCol(b: Board, x: i64, col: []i64) void {
    var rows: [][]i64 = b.cells;
    var y: i64 = 0;
    while (y < SIZE) {
        var row: []i64 = rows[@as(usize, @intCast(y))];
        row[@as(usize, @intCast(x))] = col[@as(usize, @intCast(y))];
        rows[@as(usize, @intCast(y))] = row;
        y = y + 1;
    }
    b.cells = rows;
}

fn moveUp(b: Board, score: i64) MoveResult {
    var grid: [][]i64 = b.cells;
    var moved: bool = false;
    var x: i64 = 0;
    while (x < SIZE) {
        var col: []i64 = getCol(b, x);
        const r: SpawnResult = slideLeft(col);
        const new: []i64 = r.row;
        score = score + r.gain;
        var y: i64 = 0;
        while (y < SIZE) {
            if (grid[@as(usize, @intCast(y))][@as(usize, @intCast(x))] != new[@as(usize, @intCast(y))]) {
                moved = true;
            }
            grid[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = new[@as(usize, @intCast(y))];
            y = y + 1;
        }
        x = x + 1;
    }
    return .{ .board = .{ .cells = grid }, .score = score, .moved = moved };
}

fn moveDown(b: Board, score: i64) MoveResult {
    var grid: [][]i64 = b.cells;
    var moved: bool = false;
    var x: i64 = 0;
    while (x < SIZE) {
        var col: []i64 = reverseRow(getCol(b, x));
        const r: SpawnResult = slideLeft(col);
        col = r.row;
        score = score + r.gain;
        col = reverseRow(col);
        var y: i64 = 0;
        while (y < SIZE) {
            if (grid[@as(usize, @intCast(y))][@as(usize, @intCast(x))] != col[@as(usize, @intCast(y))]) {
                moved = true;
            }
            grid[@as(usize, @intCast(y))][@as(usize, @intCast(x))] = col[@as(usize, @intCast(y))];
            y = y + 1;
        }
        x = x + 1;
    }
    return .{ .board = .{ .cells = grid }, .score = score, .moved = moved };
}

fn hasMoves(b: Board) bool {
    var y: i64 = 0;
    while (y < SIZE) {
        var x: i64 = 0;
        while (x < SIZE) {
            if (b.cells[@as(usize, @intCast(y))][@as(usize, @intCast(x))] == 0) {
                return true;
            }
            if (x + 1 < SIZE and b.cells[@as(usize, @intCast(y))][@as(usize, @intCast(x))] == b.cells[@as(usize, @intCast(y))][@as(usize, @intCast(x + 1))]) {
                return true;
            }
            if (y + 1 < SIZE and b.cells[@as(usize, @intCast(y))][@as(usize, @intCast(x))] == b.cells[@as(usize, @intCast(y + 1))][@as(usize, @intCast(x))]) {
                return true;
            }
            x = x + 1;
        }
        y = y + 1;
    }
    return false;
}

fn has2048(b: Board) bool {
    var y: i64 = 0;
    while (y < SIZE) {
        var x: i64 = 0;
        while (x < SIZE) {
            if (b.cells[@as(usize, @intCast(y))][@as(usize, @intCast(x))] >= 2048) {
                return true;
            }
            x = x + 1;
        }
        y = y + 1;
    }
    return false;
}

pub fn main() void {
    {
        const __start_mem = _mem();
        const __start = _now();
        board = r.board;
        r = spawnTile(board);
        board = r.board;
        full = r.full;
        draw(board, score);
        while (true) {
            std.debug.print("{s}\n", .{"Move: "});
            const cmd: []const u8 = _input();
            var moved: bool = false;
            if (std.mem.eql(u8, cmd, "a") or std.mem.eql(u8, cmd, "A")) {
                const m: MoveResult = moveLeft(board, score);
                board = m.board;
                score = m.score;
                moved = m.moved;
            }
            if (std.mem.eql(u8, cmd, "d") or std.mem.eql(u8, cmd, "D")) {
                const m: MoveResult = moveRight(board, score);
                board = m.board;
                score = m.score;
                moved = m.moved;
            }
            if (std.mem.eql(u8, cmd, "w") or std.mem.eql(u8, cmd, "W")) {
                const m: MoveResult = moveUp(board, score);
                board = m.board;
                score = m.score;
                moved = m.moved;
            }
            if (std.mem.eql(u8, cmd, "s") or std.mem.eql(u8, cmd, "S")) {
                const m: MoveResult = moveDown(board, score);
                board = m.board;
                score = m.score;
                moved = m.moved;
            }
            if (std.mem.eql(u8, cmd, "q") or std.mem.eql(u8, cmd, "Q")) {
                break;
            }
            if (moved) {
                const r2: SpawnResult = spawnTile(board);
                board = r2.board;
                full = r2.full;
                if (full and !(hasMoves(board))) {
                    draw(board, score);
                    std.debug.print("{s}\n", .{"Game Over"});
                    break;
                }
            }
            draw(board, score);
            if (has2048(board)) {
                std.debug.print("{s}\n", .{"You win!"});
                break;
            }
            if (!(hasMoves(board))) {
                std.debug.print("{s}\n", .{"Game Over"});
                break;
            }
        }
        const __end = _now();
        const __end_mem = _mem();
        const __duration_us = @divTrunc(@as(i64, @intCast(__end - __start)), 1000);
        const __memory_bytes = __end_mem - __start_mem;
        const __bench = .{ .duration_us = __duration_us, .memory_bytes = __memory_bytes, .name = "main" };
        const __bj = std.fmt.allocPrint(std.heap.page_allocator, "{f}", .{std.json.fmt(__bench, .{ .whitespace = .indent_2 })}) catch unreachable;
        std.debug.print("{s}\n", .{__bj});
        std.heap.page_allocator.free(__bj);
    }
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |s| {
            defer std.heap.page_allocator.free(s);
            if (std.fmt.parseInt(i64, s, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}

var _in_buf = std.io.bufferedReader(std.io.getStdIn().reader());
fn _input() []const u8 {
    const opt_line = _in_buf.reader().readUntilDelimiterOrEofAlloc(std.heap.page_allocator, '\n', 1 << 20) catch return "";
    const line = opt_line orelse return "";
    if (line.len > 0 and line[line.len - 1] == '\n') {
        return line[0..line.len-1];
    }
    return line;
}

fn _mem() i64 {
    var usage: std.os.linux.rusage = undefined;
    if (std.os.linux.getrusage(std.os.linux.rusage.SELF, &usage) != 0) return 0;
    return @as(i64, usage.maxrss) * 1024;
}
