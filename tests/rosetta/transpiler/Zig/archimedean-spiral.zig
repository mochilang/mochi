// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:00:41Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const PI = 3.141592653589793; // f64
const degreesIncr = ((0.1 * PI) / 180.0); // f64
const turns = 2.0; // f64
const stop = (((360.0 * turns) * 10.0) * degreesIncr); // f64
const width = 600.0; // f64
const centre = (width / 2.0); // f64
const a = 1.0; // f64
const b = 20.0; // f64
var theta = 0.0; // f64
var count = 0; // i32

fn sinApprox(x: f64) f64 {
    var term = x; // f64
    var sum = x; // f64
    var n = 1; // i32
    while (n <= 10) {
        const denom = @as(f64, ((((2 * n)) * (((2 * n) + 1))))); // f64
        term = (((-term * x) * x) / denom);
        sum = (sum + term);
        n = (n + 1);
    }
    return sum;
}

fn cosApprox(x: f64) f64 {
    var term = 1.0; // f64
    var sum = 1.0; // f64
    var n = 1; // i32
    while (n <= 10) {
        const denom = @as(f64, (((((2 * n) - 1)) * ((2 * n))))); // f64
        term = (((-term * x) * x) / denom);
        sum = (sum + term);
        n = (n + 1);
    }
    return sum;
}

pub fn main() void {
    while (theta < stop) {
        const r = (a + (b * theta)); // f64
        const x = (r * cosApprox(theta)); // f64
        const y = (r * sinApprox(theta)); // f64
        if (@mod(count, 100) == 0) {
            std.debug.print("{s}\n", .{_concat_string(_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{(centre + x)}) catch |err| handleError(err), ","), std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{(centre - y)}) catch |err| handleError(err))});
        }
        theta = (theta + degreesIncr);
        count = (count + 1);
    }
}
