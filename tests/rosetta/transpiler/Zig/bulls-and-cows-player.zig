// Generated by Mochi Zig transpiler on 2025-08-04 16:06 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn indexOf(s: []const u8, ch: []const u8) i64 {
    var i: i64 = 0;
    while (i < @as(i64, @intCast(s.len))) {
        if (std.mem.eql(u8, s[@intCast(i)..@intCast(i + 1)], ch)) {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;
}

fn fields(s: []const u8) [][]const u8 {
    var words: [][]const u8 = &[_][]const u8{};
    var cur: []const u8 = "";
    var i_1: i64 = 0;
    while (i_1 < @as(i64, @intCast(s.len))) {
        const ch: []const u8 = s[@intCast(i_1)..@intCast(i_1 + 1)];
        if (std.mem.eql(u8, ch, " ") or std.mem.eql(u8, ch, "\t") or std.mem.eql(u8, ch, "\n")) {
            if (@as(i64, @intCast(cur.len)) > 0) {
                words = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, words)) catch |err| handleError(err); _tmp.append(cur) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, ch);
        }
        i_1 = i_1 + 1;
    }
    if (@as(i64, @intCast(cur.len)) > 0) {
        words = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, words)) catch |err| handleError(err); _tmp.append(cur) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
    }
    return words;
}

fn makePatterns() [][]const u8 {
    const digits: [][]const u8 = blk0: { var _tmp0 = std.heap.page_allocator.alloc([]const u8, 9) catch unreachable; _tmp0[0] = "1"; _tmp0[1] = "2"; _tmp0[2] = "3"; _tmp0[3] = "4"; _tmp0[4] = "5"; _tmp0[5] = "6"; _tmp0[6] = "7"; _tmp0[7] = "8"; _tmp0[8] = "9"; break :blk0 _tmp0; };
    var pats: [][]const u8 = &[_][]const u8{};
    var i_2: i64 = 0;
    while (i_2 < @as(i64, @intCast(digits.len))) {
        var j: i64 = 0;
        while (j < @as(i64, @intCast(digits.len))) {
            if (j != i_2) {
                var k: i64 = 0;
                while (k < @as(i64, @intCast(digits.len))) {
                    if (k != i_2 and k != j) {
                        var l: i64 = 0;
                        while (l < @as(i64, @intCast(digits.len))) {
                            if (l != i_2 and l != j and l != k) {
                                pats = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, pats)) catch |err| handleError(err); _tmp.append(_concat_string(_concat_string(_concat_string(digits[@intCast(i_2)], digits[@intCast(j)]), digits[@intCast(k)]), digits[@intCast(l)])) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
                            }
                            l = l + 1;
                        }
                    }
                    k = k + 1;
                }
            }
            j = j + 1;
        }
        i_2 = i_2 + 1;
    }
    return pats;
}

fn mochi_main() void {
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("Cows and bulls/player\n", "You think of four digit number of unique digits in the range 1 to 9.\n"), "I guess.  You score my guess:\n"), "    A correct digit but not in the correct place is a cow.\n"), "    A correct digit in the correct place is a bull.\n"), "You give my score as two numbers separated with a space.")});
    var patterns: [][]const u8 = makePatterns();
    while (true) {
        if (@as(i64, @intCast(patterns.len)) == 0) {
            std.debug.print("{s}\n", .{"Oops, check scoring."});
            return;
        }
        const guess: []const u8 = patterns[@intCast(0)];
        patterns = patterns[@intCast(1)..];
        var cows: i64 = 0;
        var bulls: i64 = 0;
        while (true) {
            std.debug.print("{s}\n", .{_concat_string(_concat_string("My guess: ", guess), ".  Score? (c b) ")});
            const line: []const u8 = _input();
            const toks: [][]const u8 = fields(line);
            if (@as(i64, @intCast(toks.len)) == 2) {
                const c: i64 = std.fmt.parseInt(i64, toks[@intCast(0)], 10) catch 0;
                const b: i64 = std.fmt.parseInt(i64, toks[@intCast(1)], 10) catch 0;
                if (c >= 0 and c <= 4 and b >= 0 and b <= 4 and c + b <= 4) {
                    cows = c;
                    bulls = b;
                    break;
                }
            }
            std.debug.print("{s}\n", .{"Score guess as two numbers: cows bulls"});
        }
        if (bulls == 4) {
            std.debug.print("{s}\n", .{"I did it. :)"});
            return;
        }
        var next: [][]const u8 = &[_][]const u8{};
        var idx: i64 = 0;
        while (idx < @as(i64, @intCast(patterns.len))) {
            const pat: []const u8 = patterns[@intCast(idx)];
            var c_1: i64 = 0;
            var b_1: i64 = 0;
            var i_3: i64 = 0;
            while (i_3 < 4) {
                const cg: []const u8 = guess[@intCast(i_3)..@intCast(i_3 + 1)];
                const cp: []const u8 = pat[@intCast(i_3)..@intCast(i_3 + 1)];
                if (std.mem.eql(u8, cg, cp)) {
                    b_1 = b_1 + 1;
                } else {
                    if (indexOf(pat, cg) >= 0) {
                        c_1 = c_1 + 1;
                    }
                }
                i_3 = i_3 + 1;
            }
            if (c_1 == cows and b_1 == bulls) {
                next = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, next)) catch |err| handleError(err); _tmp.append(pat) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
            }
            idx = idx + 1;
        }
        patterns = next;
    }
}

pub fn main() void {
    mochi_main();
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _input() []const u8 {
    var reader = std.io.bufferedReaderSize(4096, std.io.getStdIn().reader());
    const opt_line = reader.reader().readUntilDelimiterOrEofAlloc(std.heap.page_allocator, '\n', 1 << 20) catch return "";
    const line = opt_line orelse return "";
    if (line.len > 0 and line[line.len - 1] == '\n') {
        return line[0..line.len-1];
    }
    return line;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
