// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:10Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn randOrder(seed: i32, n: i32) []const i32 {
    const next = @mod((((seed * 1664525) + 1013904223)), 2147483647); // i32
    return [_]i32{
    next,
    @mod(next, n),
};
}

fn randChaos(seed: i32, n: i32) []const i32 {
    const next = @mod((((seed * 1103515245) + 12345)), 2147483647); // i32
    return [_]i32{
    next,
    @mod(next, n),
};
}

fn user_main() void {
    const nBuckets = 10; // i32
    const initialSum = 1000; // i32
    var buckets = std.ArrayList(i32).init(std.heap.page_allocator);
    for (0 .. nBuckets) |i| {
        buckets = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(buckets) catch |err| handleError(err); _tmp0.append(0) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
    }
    var i = nBuckets; // i32
    var dist = initialSum; // i32
    while (i > 0) {
        const v = (dist / i); // f64
        i = (i - 1);
        buckets.items[i] = v;
        dist = (dist - v);
    }
    var tc0 = 0; // i32
    var tc1 = 0; // i32
    var total = 0; // i32
    var nTicks = 0; // i32
    var seedOrder = 1; // i32
    var seedChaos = 2; // i32
    std.debug.print("sum  ---updates---    mean  buckets\n", .{});
    var t = 0; // i32
    while (t < 5) {
        var r = randOrder(seedOrder, nBuckets); // []const i32
        seedOrder = r[0];
        var b1 = r[1]; // i32
        var b2 = @mod(((b1 + 1)), nBuckets); // i32
        const v1 = buckets[b1]; // i32
        const v2 = buckets[b2]; // i32
        if (v1 > v2) {
            var a = @as(i32, ((((v1 - v2)) / 2))); // i32
            if (a > buckets[b1]) {
                a = buckets[b1];
            }
            buckets.items[b1] = (buckets[b1] - a);
            buckets.items[b2] = (buckets[b2] + a);
        } else {
            var a = @as(i32, ((((v2 - v1)) / 2))); // i32
            if (a > buckets[b2]) {
                a = buckets[b2];
            }
            buckets.items[b2] = (buckets[b2] - a);
            buckets.items[b1] = (buckets[b1] + a);
        }
        tc0 = (tc0 + 1);
        r = randChaos(seedChaos, nBuckets);
        seedChaos = r[0];
        b1 = r[1];
        b2 = @mod(((b1 + 1)), nBuckets);
        r = randChaos(seedChaos, (buckets[b1] + 1));
        seedChaos = r[0];
        var amt = r[1]; // i32
        if (amt > buckets[b1]) {
            amt = buckets[b1];
        }
        buckets.items[b1] = (buckets[b1] - amt);
        buckets.items[b2] = (buckets[b2] + amt);
        tc1 = (tc1 + 1);
        var sum = 0; // i32
        var idx = 0; // i32
        while (idx < nBuckets) {
            sum = (sum + buckets[idx]);
            idx = (idx + 1);
        }
        total = ((total + tc0) + tc1);
        nTicks = (nTicks + 1);
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{sum}) catch |err| handleError(err), " "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{tc0}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{tc1}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{(total / nTicks)}) catch |err| handleError(err)), "  "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{buckets}) catch |err| handleError(err))});
        tc0 = 0;
        tc1 = 0;
        t = (t + 1);
    }
}

pub fn main() void {
    user_main();
}
