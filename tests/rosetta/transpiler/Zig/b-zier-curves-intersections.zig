// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:13Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_list(comptime T: type, v: []const T, start: i32, end: i32, step: i32) []T {
    var s = start;
    var e = end;
    var st = step;
    const n: i32 = @as(i32, @intCast(v.len));
    if (s < 0) s += n;
    if (e < 0) e += n;
    if (st == 0) st = 1;
    if (s < 0) s = 0;
    if (e > n) e = n;
    if (st > 0 and e < s) e = s;
    if (st < 0 and e > s) e = s;
    var res = std.ArrayList(T).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = s;
    while ((st > 0 and i < e) or (st < 0 and i > e)) : (i += st) {
        res.append(v[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const Point = struct {
    x: f64,
    y: f64,
};

const QuadSpline = struct {
    c0: f64,
    c1: f64,
    c2: f64,
};

const QuadCurve = struct {
    x: QuadSpline,
    y: QuadSpline,
};

fn absf(x: f64) f64 {
    if (x < 0.0) {
        return -x;
    }
    return x;
}

fn maxf(a: f64, b: f64) f64 {
    if (a > b) {
        return a;
    }
    return b;
}

fn minf(a: f64, b: f64) f64 {
    if (a < b) {
        return a;
    }
    return b;
}

fn max3(a: f64, b: f64, c: f64) f64 {
    var m = a; // f64
    if (b > m) {
        m = b;
    }
    if (c > m) {
        m = c;
    }
    return m;
}

fn min3(a: f64, b: f64, c: f64) f64 {
    var m = a; // f64
    if (b < m) {
        m = b;
    }
    if (c < m) {
        m = c;
    }
    return m;
}

fn subdivideQuadSpline(q: *QuadSpline, t: f64) []const QuadSpline {
    const s = (1.0 - t); // f64
    var u = QuadSpline{
    .c0 = q.c0,
    .c1 = 0.0,
    .c2 = 0.0,
}; // QuadSpline
    var v = QuadSpline{
    .c0 = 0.0,
    .c1 = 0.0,
    .c2 = q.c2,
}; // QuadSpline
    u.c1 = ((s * q.c0) + (t * q.c1));
    v.c1 = ((s * q.c1) + (t * q.c2));
    u.c2 = ((s * u.c1) + (t * v.c1));
    v.c0 = u.c2;
    return [_]QuadSpline{
    u,
    v,
};
}

fn subdivideQuadCurve(q: *QuadCurve, t: f64) []const QuadCurve {
    const xs = subdivideQuadSpline(&q.x, t); // []const QuadSpline
    const ys = subdivideQuadSpline(&q.y, t); // []const QuadSpline
    var u = QuadCurve{
    .x = xs[0],
    .y = ys[0],
}; // QuadCurve
    var v = QuadCurve{
    .x = xs[1],
    .y = ys[1],
}; // QuadCurve
    return [_]QuadCurve{
    u,
    v,
};
}

fn rectsOverlap(xa0: f64, ya0: f64, xa1: f64, ya1: f64, xb0: f64, yb0: f64, xb1: f64, yb1: f64) bool {
    return ((((xb0 <= xa1) and (xa0 <= xb1)) and (yb0 <= ya1)) and (ya0 <= yb1));
}

fn testIntersect(p: *QuadCurve, q: *QuadCurve, tol: f64) std.AutoHashMap([]const u8, i32) {
    const pxmin = min3(p.x.c0, p.x.c1, p.x.c2); // f64
    const pymin = min3(p.y.c0, p.y.c1, p.y.c2); // f64
    const pxmax = max3(p.x.c0, p.x.c1, p.x.c2); // f64
    const pymax = max3(p.y.c0, p.y.c1, p.y.c2); // f64
    const qxmin = min3(q.x.c0, q.x.c1, q.x.c2); // f64
    const qymin = min3(q.y.c0, q.y.c1, q.y.c2); // f64
    const qxmax = max3(q.x.c0, q.x.c1, q.x.c2); // f64
    const qymax = max3(q.y.c0, q.y.c1, q.y.c2); // f64
    var exclude = true; // bool
    var accept = false; // bool
    var inter = Point{
    .x = 0.0,
    .y = 0.0,
}; // Point
    if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
        exclude = false;
        const xmin = maxf(pxmin, qxmin); // f64
        const xmax = minf(pxmax, qxmax); // f64
        if ((xmax - xmin) <= tol) {
            const ymin = maxf(pymin, qymin); // f64
            const ymax = minf(pymax, qymax); // f64
            if ((ymax - ymin) <= tol) {
                accept = true;
                inter.x = (0.5 * ((xmin + xmax)));
                inter.y = (0.5 * ((ymin + ymax)));
            }
        }
    }
    return struct {
    exclude: bool,
    accept: bool,
    intersect: Point,
}{
    .exclude = exclude,
    .accept = accept,
    .intersect = inter,
};
}

fn seemsToBeDuplicate(pts: []const Point, xy: *Point, spacing: f64) bool {
    var i = 0; // i32
    while (i < @as(i32, @intCast((pts).len))) {
        const pt = pts[i]; // Point
        if ((absf((pt.x - xy.x)) < spacing) and (absf((pt.y - xy.y)) < spacing)) {
            return true;
        }
        i = (i + 1);
    }
    return false;
}

fn findIntersects(p: *QuadCurve, q: *QuadCurve, tol: f64, spacing: f64) []const Point {
    var inters = std.ArrayList(Point).init(std.heap.page_allocator);
    var workload: []const std.StringHashMap(QuadCurve) = (blk0: { const _tmp0 = struct {
    p: QuadCurve,
    q: QuadCurve,
}; const _arr = &[_]_tmp0{_tmp0{
    .p = p,
    .q = q,
}}; break :blk0 _arr; }); // []const std.StringHashMap(QuadCurve)
    while (@as(i32, @intCast((workload).len)) > 0) {
        const idx = (@as(i32, @intCast((workload).len)) - 1); // i32
        const work = workload[idx]; // std.StringHashMap(QuadCurve)
        workload = _slice_list(std.StringHashMap(QuadCurve), workload, 0, idx, 1);
        const res = testIntersect(&work["p"], &work["q"], tol); // std.StringHashMap(i32)
        const excl: i32 = res["exclude"]; // i32
        const acc: i32 = res["accept"]; // i32
        const inter = @as(Point, res["intersect"]); // Point
        if (acc) {
            if (!seemsToBeDuplicate(inters, &inter, spacing)) {
                inters = blk1: { var _tmp1 = std.ArrayList(Point).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(inters) catch |err| handleError(err); _tmp1.append(inter) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
            }
        } else         if (!excl) {
            const ps = subdivideQuadCurve(&work["p"], 0.5); // []const QuadCurve
            const qs = subdivideQuadCurve(&work["q"], 0.5); // []const QuadCurve
            const p0 = ps[0]; // QuadCurve
            const p1 = ps[1]; // QuadCurve
            const q0 = qs[0]; // QuadCurve
            const q1 = qs[1]; // QuadCurve
            workload = blk2: { var _tmp2 = std.ArrayList(std.StringHashMap(QuadCurve)).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(workload) catch |err| handleError(err); _tmp2.append(struct {
    p: QuadCurve,
    q: QuadCurve,
}{
    .p = p0,
    .q = q0,
}) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
            workload = blk3: { var _tmp3 = std.ArrayList(std.StringHashMap(QuadCurve)).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(workload) catch |err| handleError(err); _tmp3.append(struct {
    p: QuadCurve,
    q: QuadCurve,
}{
    .p = p0,
    .q = q1,
}) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
            workload = blk4: { var _tmp4 = std.ArrayList(std.StringHashMap(QuadCurve)).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(workload) catch |err| handleError(err); _tmp4.append(struct {
    p: QuadCurve,
    q: QuadCurve,
}{
    .p = p1,
    .q = q0,
}) catch |err| handleError(err); const res = _tmp4.toOwnedSlice() catch |err| handleError(err); break :blk4 res; };
            workload = blk5: { var _tmp5 = std.ArrayList(std.StringHashMap(QuadCurve)).init(std.heap.page_allocator); defer _tmp5.deinit(); _tmp5.appendSlice(workload) catch |err| handleError(err); _tmp5.append(struct {
    p: QuadCurve,
    q: QuadCurve,
}{
    .p = p1,
    .q = q1,
}) catch |err| handleError(err); const res = _tmp5.toOwnedSlice() catch |err| handleError(err); break :blk5 res; };
        }
    }
    return inters.items;
}

fn user_main() void {
    const p = QuadCurve{
    .x = QuadSpline{
    .c0 = -1.0,
    .c1 = 0.0,
    .c2 = 1.0,
},
    .y = QuadSpline{
    .c0 = 0.0,
    .c1 = 10.0,
    .c2 = 0.0,
},
}; // QuadCurve
    const q = QuadCurve{
    .x = QuadSpline{
    .c0 = 2.0,
    .c1 = -8.0,
    .c2 = 2.0,
},
    .y = QuadSpline{
    .c0 = 1.0,
    .c1 = 2.0,
    .c2 = 3.0,
},
}; // QuadCurve
    const tol = 0.0000001; // f64
    const spacing = (tol * 10.0); // f64
    const inters = findIntersects(&p, &q, tol, spacing); // []const Point
    var i = 0; // i32
    while (i < @as(i32, @intCast((inters).len))) {
        const pt = inters[i]; // Point
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string("(", std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{pt.x}) catch |err| handleError(err)), ", "), std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{pt.y}) catch |err| handleError(err)), ")")});
        i = (i + 1);
    }
}

pub fn main() void {
    user_main();
}
