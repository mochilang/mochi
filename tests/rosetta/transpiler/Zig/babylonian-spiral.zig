// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:13Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn push(h: []const std.AutoHashMap([]const u8, i32), it: std.AutoHashMap([]const u8, i32)) []const std.AutoHashMap([]const u8, i32) {
    h = blk0: { var _tmp0 = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(h) catch |err| handleError(err); _tmp0.append(it) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
    var i = (@as(i32, @intCast((h).len)) - 1); // i32
    while ((i > 0) and (h[(i - 1)]["s"] > h[i]["s"])) {
        const tmp = h[(i - 1)]; // std.StringHashMap(i32)
        h.items[(i - 1)] = h[i];
        h.items[i] = tmp;
        i = (i - 1);
    }
    return h.items;
}

fn step(h: []const std.AutoHashMap([]const u8, i32), nv: i32, dir: []const i32) std.AutoHashMap([]const u8, i32) {
    while ((@as(i32, @intCast((h).len)) == 0) or ((nv * nv) <= h[0]["s"])) {
        h = push(h, struct {
    s: i32,
    a: i32,
    b: i32,
}{
    .s = (nv * nv),
    .a = nv,
    .b = 0,
});
        nv = (nv + 1);
    }
    const s = h[0]["s"]; // i32
    var v = std.ArrayList(i32).init(std.heap.page_allocator);
    while ((@as(i32, @intCast((h).len)) > 0) and (h[0]["s"] == s)) {
        const it = h[0]; // std.StringHashMap(i32)
        h = h[1..h.len];
        v = blk1: { var _tmp1 = std.ArrayList([]const i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(v) catch |err| handleError(err); _tmp1.append(&[_]i32{
    it["a"],
    it["b"],
}) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
        if (it["a"] > it["b"]) {
            h = push(h, struct {
    s: i32,
    a: i32,
    b: i32,
}{
    .s = ((it["a"] * it["a"]) + (((it["b"] + 1)) * ((it["b"] + 1)))),
    .a = it["a"],
    .b = (it["b"] + 1),
});
        }
    }
    var list = std.ArrayList(i32).init(std.heap.page_allocator);
    for (v) |p| {
        list = blk2: { var _tmp2 = std.ArrayList([]const i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(list) catch |err| handleError(err); _tmp2.append(p) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
    }
    var temp: []const []const i32 = list; // []const []const i32
    for (temp) |p| {
        if (p[0] != p[1]) {
            list = blk3: { var _tmp3 = std.ArrayList([]const i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(list) catch |err| handleError(err); _tmp3.append(&[_]i32{
    p[1],
    p[0],
}) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
        }
    }
    temp = list;
    for (temp) |p| {
        if (p[1] != 0) {
            list = blk4: { var _tmp4 = std.ArrayList([]const i32).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(list) catch |err| handleError(err); _tmp4.append(&[_]i32{
    p[0],
    -p[1],
}) catch |err| handleError(err); const res = _tmp4.toOwnedSlice() catch |err| handleError(err); break :blk4 res; };
        }
    }
    temp = list;
    for (temp) |p| {
        if (p[0] != 0) {
            list = blk5: { var _tmp5 = std.ArrayList([]const i32).init(std.heap.page_allocator); defer _tmp5.deinit(); _tmp5.appendSlice(list) catch |err| handleError(err); _tmp5.append(&[_]i32{
    -p[0],
    p[1],
}) catch |err| handleError(err); const res = _tmp5.toOwnedSlice() catch |err| handleError(err); break :blk5 res; };
        }
    }
    var bestDot = -999999999; // i32
    var best = dir; // []const i32
    for (list) |p| {
        const cross = ((p[0] * dir[1]) - (p[1] * dir[0])); // i32
        if (cross >= 0) {
            const dot = ((p[0] * dir[0]) + (p[1] * dir[1])); // i32
            if (dot > bestDot) {
                bestDot = dot;
                best = p;
            }
        }
    }
    return struct {
    d: []const i32,
    heap: []const std.StringHashMap(i32),
    n: i32,
}{
    .d = best,
    .heap = h,
    .n = nv,
};
}

fn positions(n: i32) []const []const i32 {
    var pos = std.ArrayList(i32).init(std.heap.page_allocator);
    var x = 0; // i32
    var y = 0; // i32
    var dir: []const i32 = &[_]i32{
    0,
    1,
}; // []const i32
    var heap = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator);
    var nv = 1; // i32
    var i = 0; // i32
    while (i < n) {
        pos = blk6: { var _tmp6 = std.ArrayList([]const i32).init(std.heap.page_allocator); defer _tmp6.deinit(); _tmp6.appendSlice(pos) catch |err| handleError(err); _tmp6.append(&[_]i32{
    x,
    y,
}) catch |err| handleError(err); const res = _tmp6.toOwnedSlice() catch |err| handleError(err); break :blk6 res; };
        const st = step(heap, nv, dir); // std.StringHashMap(i32)
        dir = @as([]const i32, st["d"]);
        heap = @as([]const std.AutoHashMap([]const u8, i32), st["heap"]);
        nv = @as(i32, st["n"]);
        x = (x + dir[0]);
        y = (y + dir[1]);
        i = (i + 1);
    }
    return pos.items;
}

fn pad(s: []const u8, w: i32) []const u8 {
    var r = s; // []const u8
    while (@as(i32, @intCast((r).len)) < w) {
        r = _concat_string(r, " ");
    }
    return r;
}

fn user_main() void {
    const pts = positions(40); // []const []const i32
    std.debug.print("The first 40 Babylonian spiral points are:\n", .{});
    var line = ""; // []const u8
    var i = 0; // i32
    while (i < @as(i32, @intCast((pts).len))) {
        const p = pts[i]; // []const i32
        const s = pad(_concat_string(_concat_string(_concat_string(_concat_string("(", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{p[0]}) catch |err| handleError(err)), ", "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{p[1]}) catch |err| handleError(err)), ")"), 10); // []const u8
        line = _concat_string(line, s);
        if (@mod(((i + 1)), 10) == 0) {
            std.debug.print("{s}\n", .{line});
            line = "";
        }
        i = (i + 1);
    }
}

pub fn main() void {
    user_main();
}
