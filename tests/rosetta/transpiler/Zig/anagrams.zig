// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

const Map0 = struct {
};

const Map1 = struct {
};

fn sortRunes(s: []const u8) []const u8 {
    var arr: [][]const u8 = &[_][]const u8{};
    var i: i64 = 0;
    while (i < std.mem.len(s)) {
        arr = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(arr) catch unreachable; _tmp.append(s[i..i + 1]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    var n: i64 = std.mem.len(arr);
    var m: i64 = 0;
    while (m < n) {
        var j: i64 = 0;
        while (j < n - 1) {
            if (std.mem.order(u8, arr[@as(usize, @intCast(j))], arr[@as(usize, @intCast(j + 1))]) == .gt) {
                const tmp: [][]const u8 = arr[@as(usize, @intCast(j))];
                arr[@as(usize, @intCast(j))] = arr[@as(usize, @intCast(j + 1))];
                arr[@as(usize, @intCast(j + 1))] = tmp;
            }
            j = j + 1;
        }
        m = m + 1;
    }
    var out: [][]const u8 = "";
    i = 0;
    while (i < n) {
        out = _concat_string(out, arr[@as(usize, @intCast(i))]);
        i = i + 1;
    }
    return out;
}

fn sortStrings(xs: [][]const u8) [][]const u8 {
    var res: [][]const u8 = &[_][]const u8{};
    var tmp: [][]const u8 = xs;
    while (std.mem.len(tmp) > 0) {
        var min: []const u8 = tmp[@as(usize, @intCast(0))];
        var idx: i64 = 0;
        var i: i64 = 1;
        while (i < std.mem.len(tmp)) {
            if (std.mem.order(u8, tmp[@as(usize, @intCast(i))], min) == .lt) {
                min = tmp[@as(usize, @intCast(i))];
                idx = i;
            }
            i = i + 1;
        }
        res = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(min) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        var out: [][]const u8 = &[_][]const u8{};
        var j: i64 = 0;
        while (j < std.mem.len(tmp)) {
            if (j != idx) {
                out = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(out) catch unreachable; _tmp.append(tmp[@as(usize, @intCast(j))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            }
            j = j + 1;
        }
        tmp = out;
    }
    return res;
}

fn mochi_main() void {
    const words: [][]const u8 = @constCast(&[_][]const u8{"abel", "able", "bale", "bela", "elba", "alger", "glare", "lager", "large", "regal", "angel", "angle", "galen", "glean", "lange", "caret", "carte", "cater", "crate", "trace", "elan", "lane", "lean", "lena", "neal", "evil", "levi", "live", "veil", "vile"})[0..];
    var groups: Map0 = .{  };
    var maxLen: i64 = 0;
    for (words) |__it0| {
        const w = __it0;
        const k: []const u8 = sortRunes(w);
        if (!(std.mem.indexOfScalar(i64, groups, k) != null)) {
            groups[@as(usize, @intCast(k))] = @constCast(&[_]i64{w})[0..];
        } else {
            groups[@as(usize, @intCast(k))] = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(groups[@as(usize, @intCast(k))]) catch unreachable; _tmp.append(w) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        }
        if (std.mem.len(groups[@as(usize, @intCast(k))]) > maxLen) {
            maxLen = std.mem.len(groups[@as(usize, @intCast(k))]);
        }
    }
    var printed: Map1 = .{  };
    for (words) |__it1| {
        const w = __it1;
        const k: []const u8 = sortRunes(w);
        if (std.mem.len(groups[@as(usize, @intCast(k))]) == maxLen) {
            if (!(std.mem.indexOfScalar(i64, printed, k) != null)) {
                var g: [][]const u8 = sortStrings(groups[@as(usize, @intCast(k))]);
                var line: []const u8 = _concat_string("[", g[@as(usize, @intCast(0))]);
                var i: i64 = 1;
                while (i < std.mem.len(g)) {
                    line = _concat_string(_concat_string(line, " "), g[@as(usize, @intCast(i))]);
                    i = i + 1;
                }
                line = _concat_string(line, "]");
                std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
                printed[@as(usize, @intCast(k))] = true;
            }
        }
    }
}

pub fn main() void {
    mochi_main();
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
