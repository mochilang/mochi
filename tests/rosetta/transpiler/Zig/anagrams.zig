// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:00:01Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn sortRunes(s: []const u8) []const u8 {
    var arr = std.ArrayList(u8).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        arr = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(arr) catch |err| handleError(err); _tmp0.append(_slice_string(s, i, (i + 1), 1)) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
        i = (i + 1);
    }
    var n = @as(i32, @intCast((arr).len)); // i32
    var m = 0; // i32
    while (m < n) {
        var j = 0; // i32
        while (j < (n - 1)) {
            if (arr[j] > arr[(j + 1)]) {
                const tmp = arr[j]; // []const u8
                arr.items[j] = arr[(j + 1)];
                arr.items[(j + 1)] = tmp;
            }
            j = (j + 1);
        }
        m = (m + 1);
    }
    var out = ""; // []const u8
    i = 0;
    while (i < n) {
        out = _concat_string(out, arr[i]);
        i = (i + 1);
    }
    return out;
}

fn sortStrings(xs: []const []const u8) []const []const u8 {
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    var tmp = xs; // []const []const u8
    while (@as(i32, @intCast((tmp).len)) > 0) {
        var min = tmp[0]; // []const u8
        var idx = 0; // i32
        var i = 1; // i32
        while (i < @as(i32, @intCast((tmp).len))) {
            if (std.mem.order(u8, tmp[i], min) == .lt) {
                min = tmp[i];
                idx = i;
            }
            i = (i + 1);
        }
        res = blk1: { var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(res) catch |err| handleError(err); _tmp1.append(min) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
        var out = std.ArrayList(u8).init(std.heap.page_allocator);
        var j = 0; // i32
        while (j < @as(i32, @intCast((tmp).len))) {
            if (j != idx) {
                out = blk2: { var _tmp2 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(out) catch |err| handleError(err); _tmp2.append(tmp[j]) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
            }
            j = (j + 1);
        }
        tmp = out;
    }
    return res.items;
}

fn user_main() void {
    const words = &[_][]const u8{
    "abel",
    "able",
    "bale",
    "bela",
    "elba",
    "alger",
    "glare",
    "lager",
    "large",
    "regal",
    "angel",
    "angle",
    "galen",
    "glean",
    "lange",
    "caret",
    "carte",
    "cater",
    "crate",
    "trace",
    "elan",
    "lane",
    "lean",
    "lena",
    "neal",
    "evil",
    "levi",
    "live",
    "veil",
    "vile",
}; // []const []const u8
    var groups = std.AutoHashMap([]const u8, []const []const u8).init(std.heap.page_allocator);
    var maxLen = 0; // i32
    for (words) |w| {
        const k = sortRunes(w); // []const u8
        if (!(groups.contains(k))) {
            _ = groups.put(k, &[_][]const u8{w}) catch |err| handleError(err);
        } else {
            _ = groups.put(k, blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(groups[k]) catch |err| handleError(err); _tmp3.append(w) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; }) catch |err| handleError(err);
        }
        if (@as(i32, @intCast((groups[k]).len)) > maxLen) {
            maxLen = @as(i32, @intCast((groups[k]).len));
        }
    }
    var printed = std.AutoHashMap([]const u8, bool).init(std.heap.page_allocator);
    for (words) |w| {
        const k = sortRunes(w); // []const u8
        if (@as(i32, @intCast((groups[k]).len)) == maxLen) {
            if (!(printed.contains(k))) {
                var g = sortStrings(groups[k]); // []const []const u8
                var line = _concat_string("[", g[0]); // []const u8
                var i = 1; // i32
                while (i < @as(i32, @intCast((g).len))) {
                    line = _concat_string(_concat_string(line, " "), g[i]);
                    i = (i + 1);
                }
                line = _concat_string(line, "]");
                std.debug.print("{s}\n", .{line});
                _ = printed.put(k, true) catch |err| handleError(err);
            }
        }
    }
}

pub fn main() void {
    user_main();
}
