// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn indexOf(s: []const u8, ch: []const u8) i32 {
    var i = 0; // i32
    while (i < (s).len) {
        if (std.mem.eql(u8, _slice_string(s, i, (i + 1), 1), ch)) {
            return i;
        }
        i = (i + 1);
    }
    return -1;
}

fn rotate(s: []const u8, n: i32) []const u8 {
    return (_slice_string(s, n, s.len, 1) + _slice_string(s, 0, n, 1));
}

fn scrambleLeft(s: []const u8) []const u8 {
    return (((_slice_string(s, 0, 1, 1) + _slice_string(s, 2, 14, 1)) + _slice_string(s, 1, 2, 1)) + _slice_string(s, 14, s.len, 1));
}

fn scrambleRight(s: []const u8) []const u8 {
    return ((((_slice_string(s, 1, 3, 1) + _slice_string(s, 4, 15, 1)) + _slice_string(s, 3, 4, 1)) + _slice_string(s, 15, s.len, 1)) + _slice_string(s, 0, 1, 1));
}

fn chao(text: []const u8, encode: bool) []const u8 {
    var left = "HXUCZVAMDSLKPEFJRIGTWOBNYQ"; // []const u8
    var right = "PTLNBQDEOYSFAVZKGJRIHWXUMC"; // []const u8
    var out = ""; // []const u8
    var i = 0; // i32
    while (i < (text).len) {
        const ch = _slice_string(text, i, (i + 1), 1); // []const u8
        var idx = 0; // i32
        if (encode) {
            idx = indexOf(right, ch);
            out = _concat_string(out, _slice_string(left, idx, (idx + 1), 1));
        } else {
            idx = indexOf(left, ch);
            out = _concat_string(out, _slice_string(right, idx, (idx + 1), 1));
        }
        left = rotate(left, idx);
        right = rotate(right, idx);
        left = scrambleLeft(left);
        right = scrambleRight(right);
        i = (i + 1);
    }
    return out;
}

fn user_main() void {
    const plain = "WELLDONEISBETTERTHANWELLSAID"; // []const u8
    const cipher = chao(plain, true); // []const u8
    std.debug.print("{s}\n", .{plain});
    std.debug.print("{s}\n", .{cipher});
    std.debug.print("{s}\n", .{chao(cipher, false)});
}

pub fn main() void {
    user_main();
}
