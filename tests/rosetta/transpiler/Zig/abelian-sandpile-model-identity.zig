// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

var s4: []i64 = @constCast(&[_]i64{4, 3, 3, 3, 1, 2, 0, 2, 3})[0..];
var s1: []i64 = @constCast(&[_]i64{1, 2, 0, 2, 1, 1, 0, 1, 3})[0..];
var s2: []i64 = @constCast(&[_]i64{2, 1, 3, 1, 0, 1, 0, 1, 0})[0..];
var s3_a: []i64 = plus(s1, s2);
var s3_b: []i64 = plus(s2, s1);
var s3: []i64 = @constCast(&[_]i64{3, 3, 3, 3, 3, 3, 3, 3, 3})[0..];
var s3_id: []i64 = @constCast(&[_]i64{2, 1, 2, 1, 0, 1, 2, 1, 2})[0..];
var s4b: []i64 = plus(s3, s3_id);
var s5: []i64 = plus(s3_id, s3_id);

fn neighborsList() [][]i64 {
    return @constCast(&[_][]i64{@constCast(&[_]i64{1, 3})[0..], @constCast(&[_]i64{0, 2, 4})[0..], @constCast(&[_]i64{1, 5})[0..], @constCast(&[_]i64{0, 4, 6})[0..], @constCast(&[_]i64{1, 3, 5, 7})[0..], @constCast(&[_]i64{2, 4, 8})[0..], @constCast(&[_]i64{3, 7})[0..], @constCast(&[_]i64{4, 6, 8})[0..], @constCast(&[_]i64{5, 7})[0..]})[0..];
}

fn plus(a: []i64, b: []i64) []i64 {
    var res: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < std.mem.len(a)) {
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(a[@as(usize, @intCast(i))] + b[@as(usize, @intCast(i))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    return res;
}

fn isStable(p: []i64) bool {
    for (p) |__it0| {
        const v = __it0;
        if (v > 3) {
            return false;
        }
    }
    return true;
}

fn topple(p: []i64) i64 {
    const neighbors: [][]i64 = neighborsList();
    var i: i64 = 0;
    while (i < std.mem.len(p)) {
        if (p[@as(usize, @intCast(i))] > 3) {
            p[@as(usize, @intCast(i))] = p[@as(usize, @intCast(i))] - 4;
            const nbs: []i64 = neighbors[@as(usize, @intCast(i))];
            for (nbs) |__it1| {
                const j = __it1;
                p[@as(usize, @intCast(j))] = p[@as(usize, @intCast(j))] + 1;
            }
            return 0;
        }
        i = i + 1;
    }
    return 0;
}

fn pileString(p: []i64) []const u8 {
    var s: []const u8 = "";
    var r: i64 = 0;
    while (r < 3) {
        var c: i64 = 0;
        while (c < 3) {
            s = _concat_string(_concat_string(s, _str(p[@as(usize, @intCast(3 * r + c))])), " ");
            c = c + 1;
        }
        s = _concat_string(s, "\n");
        r = r + 1;
    }
    return s;
}

pub fn main() void {
    std.io.getStdOut().writer().print("{s}\n", .{"Avalanche of topplings:\n"}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{pileString(s4)}) catch unreachable;
    while (!(isStable(s4))) {
        topple(s4);
        std.io.getStdOut().writer().print("{s}\n", .{pileString(s4)}) catch unreachable;
    }
    std.io.getStdOut().writer().print("{s}\n", .{"Commutative additions:\n"}) catch unreachable;
    while (!(isStable(s3_a))) {
        topple(s3_a);
    }
    while (!(isStable(s3_b))) {
        topple(s3_b);
    }
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(pileString(s1), "\nplus\n\n"), pileString(s2)), "\nequals\n\n"), pileString(s3_a))}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("and\n\n", pileString(s2)), "\nplus\n\n"), pileString(s1)), "\nalso equals\n\n"), pileString(s3_b))}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{"Addition of identity sandpile:\n"}) catch unreachable;
    while (!(isStable(s4b))) {
        topple(s4b);
    }
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(pileString(s3), "\nplus\n\n"), pileString(s3_id)), "\nequals\n\n"), pileString(s4b))}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{"Addition of identities:\n"}) catch unreachable;
    while (!(isStable(s5))) {
        topple(s5);
    }
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(pileString(s3_id), "\nplus\n\n"), pileString(s3_id)), "\nequals\n\n"), pileString(s5))}) catch unreachable;
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
