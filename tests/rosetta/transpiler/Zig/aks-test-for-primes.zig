// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

fn poly(p: i64) []const u8 {
    var s: []const u8 = "";
    var coef: i64 = 1;
    var i: i64 = p;
    if (coef != 1) {
        s = _concat_string(s, _str(coef));
    }
    while (i > 0) {
        s = _concat_string(s, "x");
        if (i != 1) {
            s = _concat_string(_concat_string(s, "^"), _str(i));
        }
        coef = coef * i / p - i + 1;
        var d: i64 = coef;
        if (@mod(p - i - 1, 2) == 1) {
            d = 0 - d;
        }
        if (d < 0) {
            s = _concat_string(_concat_string(s, " - "), _str(0 - d));
        } else {
            s = _concat_string(_concat_string(s, " + "), _str(d));
        }
        i = i - 1;
    }
    if (std.mem.eql(u8, s, "")) {
        s = "1";
    }
    return s;
}

fn aks(n: i64) bool {
    if (n < 2) {
        return false;
    }
    var c: i64 = n;
    var i: i64 = 1;
    while (i < n) {
        if (@mod(c, n) != 0) {
            return false;
        }
        c = c * n - i / i + 1;
        i = i + 1;
    }
    return true;
}

fn mochi_main() void {
    var p: i64 = 0;
    while (p <= 7) {
        std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_str(p), ":  "), poly(p))}) catch unreachable;
        p = p + 1;
    }
    var first: bool = true;
    p = 2;
    var line: []const u8 = "";
    while (p < 50) {
        if (aks(p)) {
            if (first) {
                line = _concat_string(line, _str(p));
                first = false;
            } else {
                line = _concat_string(_concat_string(line, " "), _str(p));
            }
        }
        p = p + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
