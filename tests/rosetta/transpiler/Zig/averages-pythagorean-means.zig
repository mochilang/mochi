// Generated by Mochi Zig transpiler on 2025-08-02 20:52 +0700
const std = @import("std");

fn powf(base: f64, exp: i64) f64 {
    var result: f64 = 1.0;
    var i: i64 = 0;
    while (i < exp) {
        result = result * base;
        i = i + 1;
    }
    return result;
}

fn nthRoot(x: f64, n: i64) f64 {
    var low: f64 = 0.0;
    var high: f64 = x;
    var i: i64 = 0;
    while (i < 60) {
        const mid: f64 = (low + high) / 2.0;
        if (powf(mid, n) > x) {
            high = mid;
        } else {
            low = mid;
        }
        i = i + 1;
    }
    return low;
}

fn mochi_main() void {
    var sum: f64 = 0.0;
    var sum_recip: f64 = 0.0;
    var prod: f64 = 1.0;
    var n: i64 = 1;
    while (n <= 10) {
        const f: f64 = @as(f64, @floatFromInt(n));
        sum = sum + f;
        sum_recip = sum_recip + 1.0 / f;
        prod = prod * f;
        n = n + 1;
    }
    const count: f64 = 10.0;
    const a: f64 = sum / count;
    const g: f64 = nthRoot(prod, 10);
    const h: f64 = count / sum_recip;
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("A: ", _str(a)), " G: "), _str(g)), " H: "), _str(h))});
    std.debug.print("{s}\n", .{_concat_string("A >= G >= H: ", _str(a >= g and g >= h))});
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ lhs, rhs }) catch unreachable;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
