// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

const Map0 = struct {
    cl: []const u8,
    le: i64,
    aa: i64,
    ri: i64,
};

var tr: i64 = null;
var i: i64 = 1;

fn node(cl: []const u8, le: i64, aa: i64, ri: i64) i64 {
    return .{ .cl = cl, .le = le, .aa = aa, .ri = ri };
}

fn treeString(t: i64) []const u8 {
    if (t == null) {
        return "E";
    }
    const m: i64 = t;
    return _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("T(", m[@as(usize, @intCast("cl"))]), ", "), treeString(m[@as(usize, @intCast("le"))])), ", "), _str(m[@as(usize, @intCast("aa"))])), ", "), treeString(m[@as(usize, @intCast("ri"))])), ")");
}

fn balance(t: i64) i64 {
    if (t == null) {
        return t;
    }
    const m: i64 = t;
    if (m[@as(usize, @intCast("cl"))] != "B") {
        return t;
    }
    const le: i64 = m[@as(usize, @intCast("le"))];
    const ri: i64 = m[@as(usize, @intCast("ri"))];
    if (le != null) {
        const leMap: i64 = le;
        if (leMap[@as(usize, @intCast("cl"))] == "R") {
            const lele: i64 = leMap[@as(usize, @intCast("le"))];
            if (lele != null) {
                const leleMap: i64 = lele;
                if (leleMap[@as(usize, @intCast("cl"))] == "R") {
                    return node("R", node("B", leleMap[@as(usize, @intCast("le"))], leleMap[@as(usize, @intCast("aa"))], leleMap[@as(usize, @intCast("ri"))]), leMap[@as(usize, @intCast("aa"))], node("B", leMap[@as(usize, @intCast("ri"))], m[@as(usize, @intCast("aa"))], ri));
                }
            }
            const leri: i64 = leMap[@as(usize, @intCast("ri"))];
            if (leri != null) {
                const leriMap: i64 = leri;
                if (leriMap[@as(usize, @intCast("cl"))] == "R") {
                    return node("R", node("B", leMap[@as(usize, @intCast("le"))], leMap[@as(usize, @intCast("aa"))], leriMap[@as(usize, @intCast("le"))]), leriMap[@as(usize, @intCast("aa"))], node("B", leriMap[@as(usize, @intCast("ri"))], m[@as(usize, @intCast("aa"))], ri));
                }
            }
        }
    }
    if (ri != null) {
        const riMap: i64 = ri;
        if (riMap[@as(usize, @intCast("cl"))] == "R") {
            const rile: i64 = riMap[@as(usize, @intCast("le"))];
            if (rile != null) {
                const rileMap: i64 = rile;
                if (rileMap[@as(usize, @intCast("cl"))] == "R") {
                    return node("R", node("B", m[@as(usize, @intCast("le"))], m[@as(usize, @intCast("aa"))], rileMap[@as(usize, @intCast("le"))]), rileMap[@as(usize, @intCast("aa"))], node("B", rileMap[@as(usize, @intCast("ri"))], riMap[@as(usize, @intCast("aa"))], riMap[@as(usize, @intCast("ri"))]));
                }
            }
            const riri: i64 = riMap[@as(usize, @intCast("ri"))];
            if (riri != null) {
                const ririMap: i64 = riri;
                if (ririMap[@as(usize, @intCast("cl"))] == "R") {
                    return node("R", node("B", m[@as(usize, @intCast("le"))], m[@as(usize, @intCast("aa"))], riMap[@as(usize, @intCast("le"))]), riMap[@as(usize, @intCast("aa"))], node("B", ririMap[@as(usize, @intCast("le"))], ririMap[@as(usize, @intCast("aa"))], ririMap[@as(usize, @intCast("ri"))]));
                }
            }
        }
    }
    return t;
}

fn ins(tr: i64, x: i64) i64 {
    if (tr == null) {
        return node("R", null, x, null);
    }
    if (x < tr[@as(usize, @intCast("aa"))]) {
        return balance(node(tr[@as(usize, @intCast("cl"))], ins(tr[@as(usize, @intCast("le"))], x), tr[@as(usize, @intCast("aa"))], tr[@as(usize, @intCast("ri"))]));
    }
    if (x > tr[@as(usize, @intCast("aa"))]) {
        return balance(node(tr[@as(usize, @intCast("cl"))], tr[@as(usize, @intCast("le"))], tr[@as(usize, @intCast("aa"))], ins(tr[@as(usize, @intCast("ri"))], x)));
    }
    return tr;
}

fn insert(tr: i64, x: i64) i64 {
    const t: i64 = ins(tr, x);
    if (t == null) {
        return null;
    }
    const m: i64 = t;
    return node("B", m[@as(usize, @intCast("le"))], m[@as(usize, @intCast("aa"))], m[@as(usize, @intCast("ri"))]);
}

pub fn main() void {
    while (i <= 16) {
        tr = insert(tr, i);
        i = i + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{treeString(tr)}) catch unreachable;
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
