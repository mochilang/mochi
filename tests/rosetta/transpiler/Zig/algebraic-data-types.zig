// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:59Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

var tr: i32 = 0;
var i = 1; // i32

fn node(cl: []const u8, le: i32, aa: i32, ri: i32) std.AutoHashMap([]const u8, i32) {
    return struct {
    cl: []const u8,
    le: i32,
    aa: i32,
    ri: i32,
}{
    .cl = cl,
    .le = le,
    .aa = aa,
    .ri = ri,
};
}

fn treeString(t: i32) []const u8 {
    if (t == 0) {
        return "E";
    }
    const m = @as(std.AutoHashMap([]const u8, i32), t); // std.StringHashMap(i32)
    return _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("T(", m["cl"]), ", "), treeString(m["le"])), ", "), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{m["aa"]}) catch |err| handleError(err)), ", "), treeString(m["ri"])), ")");
}

fn balance(t: i32) i32 {
    if (t == 0) {
        return t;
    }
    const m = @as(std.AutoHashMap([]const u8, i32), t); // std.StringHashMap(i32)
    if (!std.mem.eql(u8, m["cl"], "B")) {
        return t;
    }
    const le: i32 = m["le"]; // i32
    const ri: i32 = m["ri"]; // i32
    if (le != 0) {
        const leMap = @as(std.AutoHashMap([]const u8, i32), le); // std.StringHashMap(i32)
        if (std.mem.eql(u8, leMap["cl"], "R")) {
            const lele: i32 = leMap["le"]; // i32
            if (lele != 0) {
                const leleMap = @as(std.AutoHashMap([]const u8, i32), lele); // std.StringHashMap(i32)
                if (std.mem.eql(u8, leleMap["cl"], "R")) {
                    return node("R", node("B", leleMap["le"], leleMap["aa"], leleMap["ri"]), leMap["aa"], node("B", leMap["ri"], m["aa"], ri));
                }
            }
            const leri: i32 = leMap["ri"]; // i32
            if (leri != 0) {
                const leriMap = @as(std.AutoHashMap([]const u8, i32), leri); // std.StringHashMap(i32)
                if (std.mem.eql(u8, leriMap["cl"], "R")) {
                    return node("R", node("B", leMap["le"], leMap["aa"], leriMap["le"]), leriMap["aa"], node("B", leriMap["ri"], m["aa"], ri));
                }
            }
        }
    }
    if (ri != 0) {
        const riMap = @as(std.AutoHashMap([]const u8, i32), ri); // std.StringHashMap(i32)
        if (std.mem.eql(u8, riMap["cl"], "R")) {
            const rile: i32 = riMap["le"]; // i32
            if (rile != 0) {
                const rileMap = @as(std.AutoHashMap([]const u8, i32), rile); // std.StringHashMap(i32)
                if (std.mem.eql(u8, rileMap["cl"], "R")) {
                    return node("R", node("B", m["le"], m["aa"], rileMap["le"]), rileMap["aa"], node("B", rileMap["ri"], riMap["aa"], riMap["ri"]));
                }
            }
            const riri: i32 = riMap["ri"]; // i32
            if (riri != 0) {
                const ririMap = @as(std.AutoHashMap([]const u8, i32), riri); // std.StringHashMap(i32)
                if (std.mem.eql(u8, ririMap["cl"], "R")) {
                    return node("R", node("B", m["le"], m["aa"], riMap["le"]), riMap["aa"], node("B", ririMap["le"], ririMap["aa"], ririMap["ri"]));
                }
            }
        }
    }
    return t;
}

fn ins(tr: i32, x: i32) i32 {
    if (tr == 0) {
        return node("R", 0, x, 0);
    }
    if (x < tr["aa"]) {
        return balance(node(tr["cl"], ins(tr["le"], x), tr["aa"], tr["ri"]));
    }
    if (x > tr["aa"]) {
        return balance(node(tr["cl"], tr["le"], tr["aa"], ins(tr["ri"], x)));
    }
    return tr;
}

fn insert(tr: i32, x: i32) i32 {
    const t: i32 = ins(tr, x); // i32
    if (t == 0) {
        return 0;
    }
    const m = @as(std.AutoHashMap([]const u8, i32), t); // std.StringHashMap(i32)
    return node("B", m["le"], m["aa"], m["ri"]);
}

pub fn main() void {
    while (i <= 16) {
        tr = insert(tr, i);
        i = (i + 1);
    }
    std.debug.print("{s}\n", .{treeString(tr)});
}
