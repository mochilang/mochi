// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

fn isPrime(n: i64) bool {
    if (n < 2) {
        return false;
    }
    if (@mod(n, 2) == 0) {
        return n == 2;
    }
    if (@mod(n, 3) == 0) {
        return n == 3;
    }
    var d: i64 = 5;
    while (d * d <= n) {
        if (@mod(n, d) == 0) {
            return false;
        }
        d = d + 2;
        if (@mod(n, d) == 0) {
            return false;
        }
        d = d + 4;
    }
    return true;
}

fn sumDigits(n: i64) i64 {
    var s: i64 = 0;
    var x: i64 = n;
    while (x > 0) {
        s = @mod(s + x, 10);
        x = x / 10;
    }
    return s;
}

fn pad(n: i64) []const u8 {
    if (n < 10) {
        return _concat_string("  ", _str(n));
    }
    if (n < 100) {
        return _concat_string(" ", _str(n));
    }
    return _str(n);
}

fn mochi_main() void {
    std.io.getStdOut().writer().print("{s}\n", .{"Additive primes less than 500:"}) catch unreachable;
    var count: i64 = 0;
    var line: []const u8 = "";
    var lineCount: i64 = 0;
    var i: i64 = 2;
    while (i < 500) {
        if (isPrime(i) and isPrime(sumDigits(i))) {
            count = count + 1;
            line = _concat_string(_concat_string(line, pad(i)), "  ");
            lineCount = lineCount + 1;
            if (lineCount == 10) {
                std.io.getStdOut().writer().print("{s}\n", .{line[0..std.mem.len(line) - 2]}) catch unreachable;
                line = "";
                lineCount = 0;
            }
        }
        if (i > 2) {
            i = i + 2;
        } else {
            i = i + 1;
        }
    }
    if (lineCount > 0) {
        std.io.getStdOut().writer().print("{s}\n", .{line[0..std.mem.len(line) - 2]}) catch unreachable;
    }
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_str(count), " additive primes found.")}) catch unreachable;
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
