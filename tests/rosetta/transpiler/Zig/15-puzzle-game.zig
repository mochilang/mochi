// Generated by Mochi Zig transpiler on 2025-07-23 23:40 +0700
const std = @import("std");

const MoveResult = struct {
    idx: i64,
    ok: bool,
};

var board: []i64 = [16]i64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};
const solved: []i64 = [16]i64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};
var empty: i64 = 15;
var moves: i64 = 0;
var quit: bool = false;

fn randMove() i64 {
    return @mod(_now(), 4);
}

fn isSolved() bool {
    var i: i64 = 0;
    while (i < 16) {
        if (board[@as(usize, @intCast(i))] != solved[@as(usize, @intCast(i))]) {
            return false;
        }
        i = i + 1;
    }
    return true;
}

fn isValidMove(m: i64) MoveResult {
    if (m == 0) {
        return .{ .idx = empty - 4, .ok = empty / 4 > 0 };
    }
    if (m == 1) {
        return .{ .idx = empty + 4, .ok = empty / 4 < 3 };
    }
    if (m == 2) {
        return .{ .idx = empty + 1, .ok = @mod(empty, 4) < 3 };
    }
    if (m == 3) {
        return .{ .idx = empty - 1, .ok = @mod(empty, 4) > 0 };
    }
    return .{ .idx = 0, .ok = false };
}

fn doMove(m: i64) bool {
    const r: MoveResult = isValidMove(m);
    if (!(r.ok)) {
        return false;
    }
    const i: i64 = empty;
    const j: i64 = r.idx;
    const tmp: i64 = board[@as(usize, @intCast(i))];
    board[@as(usize, @intCast(i))] = board[@as(usize, @intCast(j))];
    board[@as(usize, @intCast(j))] = tmp;
    empty = j;
    moves = moves + 1;
    return true;
}

fn shuffle(n: i64) void {
    var i: i64 = 0;
    while (i < n or isSolved()) {
        if (doMove(randMove())) {
            i = i + 1;
        }
    }
}

fn printBoard() void {
    var line: []const u8 = "";
    var i: i64 = 0;
    while (i < 16) {
        const val: i64 = board[@as(usize, @intCast(i))];
        if (val == 0) {
            line = _concat_string(line, "  .");
        } else {
            const s: i64 = _str(val);
            if (val < 10) {
                line = _concat_string(_concat_string(line, "  "), s);
            } else {
                line = _concat_string(_concat_string(line, " "), s);
            }
        }
        if (@mod(i, 4) == 3) {
            std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
            line = "";
        }
        i = i + 1;
    }
}

fn playOneMove() void {
    while (true) {
        std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string("Enter move #", _str(moves + 1)), " (U, D, L, R, or Q): ")}) catch unreachable;
        const s: i64 = _input();
        if (s == "") {
            continue;
        }
        const c: i64 = s[0..1];
        var m: i64 = 0;
        if (c == "U" or c == "u") {
            m = 0;
        } else {
            if (c == "D" or c == "d") {
                m = 1;
            } else {
                if (c == "R" or c == "r") {
                    m = 2;
                } else {
                    if (c == "L" or c == "l") {
                        m = 3;
                    } else {
                        if (c == "Q" or c == "q") {
                            std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string("Quiting after ", _str(moves)), " moves.")}) catch unreachable;
                            quit = true;
                            return;
                        } else {
                            std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string("Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n", "up, down, left, or right. You can also enter \"Q\" to quit.\n"), "Upper or lowercase is accepted and only the first non-blank\n"), "character is important (i.e. you may enter \"up\" if you like).")}) catch unreachable;
                            continue;
                        }
                    }
                }
            }
        }
        if (!(doMove(m))) {
            std.io.getStdOut().writer().print("{s}\n", .{"That is not a valid move at the moment."}) catch unreachable;
            continue;
        }
        return;
    }
}

fn play() void {
    std.io.getStdOut().writer().print("{s}\n", .{"Starting board:"}) catch unreachable;
    while (!(quit) and isSolved() == false) {
        std.io.getStdOut().writer().print("{s}\n", .{""}) catch unreachable;
        printBoard();
        playOneMove();
    }
    if (isSolved()) {
        std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string("You solved the puzzle in ", _str(moves)), " moves.")}) catch unreachable;
    }
}

fn mochi_main() void {
    shuffle(50);
    play();
}

pub fn main() void {
    mochi_main();
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |s| {
            defer std.heap.page_allocator.free(s);
            if (std.fmt.parseInt(i64, s, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}

var _in_buf = std.io.bufferedReader(std.io.getStdIn().reader());
fn _input() []const u8 {
    const line = _in_buf.reader().readUntilDelimiterOrEofAlloc(std.heap.page_allocator, '\n', 1 << 20) catch return "";
    if (line.len > 0 and line[line.len - 1] == '\n') {
        return line[0..line.len-1];
    }
    return line;
}
