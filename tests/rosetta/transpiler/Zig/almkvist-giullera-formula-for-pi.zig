// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

const Map0 = struct {
};

const Map1 = struct {
};

fn bigTrim(a: []i64) []i64 {
    var n: i64 = std.mem.len(a);
    while (n > 1 and a[@as(usize, @intCast(n - 1))] == 0) {
        a = a[0..n - 1];
        n = n - 1;
    }
    return a;
}

fn bigFromInt(x: i64) []i64 {
    if (x == 0) {
        return @constCast(&[_]i64{0})[0..];
    }
    var digits: []i64 = &[_]i64{};
    var n: i64 = x;
    while (n > 0) {
        digits = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(digits) catch unreachable; _tmp.append(@mod(n, 10)) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        n = n / 10;
    }
    return digits;
}

fn bigCmp(a: []i64, b: []i64) i64 {
    if (std.mem.len(a) > std.mem.len(b)) {
        return 1;
    }
    if (std.mem.len(a) < std.mem.len(b)) {
        return 0 - 1;
    }
    var i: i64 = std.mem.len(a) - 1;
    while (i >= 0) {
        if (a[@as(usize, @intCast(i))] > b[@as(usize, @intCast(i))]) {
            return 1;
        }
        if (a[@as(usize, @intCast(i))] < b[@as(usize, @intCast(i))]) {
            return 0 - 1;
        }
        i = i - 1;
    }
    return 0;
}

fn bigAdd(a: []i64, b: []i64) []i64 {
    var res: []i64 = &[_]i64{};
    var carry: i64 = 0;
    var i: i64 = 0;
    while (i < std.mem.len(a) or i < std.mem.len(b) or carry > 0) {
        var av: i64 = 0;
        if (i < std.mem.len(a)) {
            av = a[@as(usize, @intCast(i))];
        }
        var bv: i64 = 0;
        if (i < std.mem.len(b)) {
            bv = b[@as(usize, @intCast(i))];
        }
        var s: []const u8 = av + bv + carry;
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(@mod(s, 10)) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        carry = s / 10;
        i = i + 1;
    }
    return bigTrim(res);
}

fn bigSub(a: []i64, b: []i64) []i64 {
    var res: []i64 = &[_]i64{};
    var borrow: i64 = 0;
    var i: i64 = 0;
    while (i < std.mem.len(a)) {
        var av: i64 = a[@as(usize, @intCast(i))];
        var bv: i64 = 0;
        if (i < std.mem.len(b)) {
            bv = b[@as(usize, @intCast(i))];
        }
        var diff: []i64 = av - bv - borrow;
        if (diff < 0) {
            diff = diff + 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(diff) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    return bigTrim(res);
}

fn bigMulSmall(a: []i64, m: i64) []i64 {
    if (m == 0) {
        return @constCast(&[_]i64{0})[0..];
    }
    var res: []i64 = &[_]i64{};
    var carry: i64 = 0;
    var i: i64 = 0;
    while (i < std.mem.len(a)) {
        var prod: []i64 = a[@as(usize, @intCast(i))] * m + carry;
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(@mod(prod, 10)) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        carry = prod / 10;
        i = i + 1;
    }
    while (carry > 0) {
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(@mod(carry, 10)) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        carry = carry / 10;
    }
    return bigTrim(res);
}

fn bigMulBig(a: []i64, b: []i64) []i64 {
    var res: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < std.mem.len(a) + std.mem.len(b)) {
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(0) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    i = 0;
    while (i < std.mem.len(a)) {
        var carry: i64 = 0;
        var j: i64 = 0;
        while (j < std.mem.len(b)) {
            var idx: i64 = i + j;
            var prod: []i64 = res[@as(usize, @intCast(idx))] + a[@as(usize, @intCast(i))] * b[@as(usize, @intCast(j))] + carry;
            res[@as(usize, @intCast(idx))] = @mod(prod, 10);
            carry = prod / 10;
            j = j + 1;
        }
        var idx: i64 = i + std.mem.len(b);
        while (carry > 0) {
            var prod: []i64 = res[@as(usize, @intCast(idx))] + carry;
            res[@as(usize, @intCast(idx))] = @mod(prod, 10);
            carry = prod / 10;
            idx = idx + 1;
        }
        i = i + 1;
    }
    return bigTrim(res);
}

fn bigMulPow10(a: []i64, k: i64) []i64 {
    var i: i64 = 0;
    while (i < k) {
        a = @constCast(&[_]i64{0})[0..] + a;
        i = i + 1;
    }
    return a;
}

fn bigDivSmall(a: []i64, m: i64) []i64 {
    var res: []i64 = &[_]i64{};
    var rem: i64 = 0;
    var i: i64 = std.mem.len(a) - 1;
    while (i >= 0) {
        var cur: i64 = rem * 10 + a[@as(usize, @intCast(i))];
        var q: i64 = cur / m;
        rem = @mod(cur, m);
        res = @constCast(&[_]i64{q})[0..] + res;
        i = i - 1;
    }
    return bigTrim(res);
}

fn bigToString(a: []i64) []const u8 {
    var s: []const u8 = "";
    var i: i64 = std.mem.len(a) - 1;
    while (i >= 0) {
        s = _concat_string(s, _str(a[@as(usize, @intCast(i))]));
        i = i - 1;
    }
    return s;
}

fn repeat(ch: []const u8, n: i64) []const u8 {
    var s: []const u8 = "";
    var i: i64 = 0;
    while (i < n) {
        s = _concat_string(s, ch);
        i = i + 1;
    }
    return s;
}

fn sortInts(xs: []i64) []i64 {
    var res: []i64 = &[_]i64{};
    var tmp: []i64 = xs;
    while (std.mem.len(tmp) > 0) {
        var min: i64 = tmp[@as(usize, @intCast(0))];
        var idx: i64 = 0;
        var i: i64 = 1;
        while (i < std.mem.len(tmp)) {
            if (tmp[@as(usize, @intCast(i))] < min) {
                min = tmp[@as(usize, @intCast(i))];
                idx = i;
            }
            i = i + 1;
        }
        res = res + @constCast(&[_]i64{min})[0..];
        var out: []const u8 = &[_]i64{};
        var j: i64 = 0;
        while (j < std.mem.len(tmp)) {
            if (j != idx) {
                out = _concat_string(out, @constCast(&[_]i64{tmp[@as(usize, @intCast(j))]})[0..]);
            }
            j = j + 1;
        }
        tmp = out;
    }
    return res;
}

fn primesUpTo(n: i64) []i64 {
    var sieve: []bool = &[_]bool{};
    var i: i64 = 0;
    while (i <= n) {
        sieve = blk: { var _tmp = std.ArrayList(bool).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(sieve) catch unreachable; _tmp.append(true) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    var p: i64 = 2;
    while (p * p <= n) {
        if (sieve[@as(usize, @intCast(p))]) {
            var m: i64 = p * p;
            while (m <= n) {
                sieve[@as(usize, @intCast(m))] = false;
                m = m + p;
            }
        }
        p = p + 1;
    }
    var res: []i64 = &[_]i64{};
    var x: i64 = 2;
    while (x <= n) {
        if (sieve[@as(usize, @intCast(x))]) {
            res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(x) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        }
        x = x + 1;
    }
    return res;
}

fn factorialExp(n: i64, primes: []i64) i64 {
    var m: Map0 = .{  };
    for (primes) |__it0| {
        const p = __it0;
        if (p > n) {
            break;
        }
        var t: i64 = n;
        var e: i64 = 0;
        while (t > 0) {
            t = t / p;
            e = e + t;
        }
        m[@as(usize, @intCast(_str(p)))] = e;
    }
    return m;
}

fn factorSmall(x: i64, primes: []i64) i64 {
    var f: Map1 = .{  };
    var n: i64 = x;
    for (primes) |__it1| {
        const p = __it1;
        if (p * p > n) {
            break;
        }
        var c: i64 = 0;
        while (@mod(n, p) == 0) {
            c = c + 1;
            n = n / p;
        }
        if (c > 0) {
            f[@as(usize, @intCast(_str(p)))] = c;
        }
    }
    if (n > 1) {
        f[@as(usize, @intCast(_str(n)))] = f.get(_str(n), 0) + 1;
    }
    return f;
}

fn computeIP(n: i64, primes: []i64) []i64 {
    var exps: i64 = factorialExp(6 * n, primes);
    const fn: i64 = factorialExp(n, primes);
    for (fn) |__it2| {
        const k = __it2;
        exps[@as(usize, @intCast(k))] = exps.get(k, 0) - 6 * fn[@as(usize, @intCast(k))];
    }
    exps[@as(usize, @intCast("2"))] = exps.get("2", 0) + 5;
    const t2: i64 = 532 * n * n + 126 * n + 9;
    const ft2: i64 = factorSmall(t2, primes);
    for (ft2) |__it3| {
        const k = __it3;
        exps[@as(usize, @intCast(k))] = exps.get(k, 0) + ft2[@as(usize, @intCast(k))];
    }
    exps[@as(usize, @intCast("3"))] = exps.get("3", 0) - 1;
    var keys: []i64 = &[_]i64{};
    for (exps) |__it4| {
        const k = __it4;
        keys = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(keys) catch unreachable; _tmp.append(int(k)) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
    }
    keys = sortInts(keys);
    var res: []i64 = bigFromInt(1);
    for (keys) |__it5| {
        const p = __it5;
        var e: i64 = exps[@as(usize, @intCast(_str(p)))];
        var i: i64 = 0;
        while (i < e) {
            res = bigMulSmall(res, p);
            i = i + 1;
        }
    }
    return res;
}

fn formatTerm(ip: []i64, pw: i64) []const u8 {
    var s: []const u8 = bigToString(ip);
    if (pw >= std.mem.len(s)) {
        var frac: []const u8 = _concat_string(repeat("0", pw - std.mem.len(s)), s);
        if (std.mem.len(frac) < 33) {
            frac = _concat_string(frac, repeat("0", 33 - std.mem.len(frac)));
        }
        return _concat_string("0.", frac[0..33]);
    }
    var intpart: []const u8 = s[0..std.mem.len(s) - pw];
    var frac: []const u8 = s[std.mem.len(s) - pw..std.mem.len(s)];
    if (std.mem.len(frac) < 33) {
        frac = _concat_string(frac, repeat("0", 33 - std.mem.len(frac)));
    }
    return _concat_string(_concat_string(intpart, "."), frac[0..33]);
}

fn bigAbsDiff(a: []i64, b: []i64) []i64 {
    if (bigCmp(a, b) >= 0) {
        return bigSub(a, b);
    }
    return bigSub(b, a);
}

fn mochi_main() void {
    const primes: []i64 = primesUpTo(2000);
    std.io.getStdOut().writer().print("{s}\n", .{"N                               Integer Portion  Pow  Nth Term (33 dp)"}) catch unreachable;
    const line: []const u8 = repeat("-", 89);
    std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
    var sum: []i64 = bigFromInt(0);
    var prev: []i64 = bigFromInt(0);
    var denomPow: i64 = 0;
    var n: i64 = 0;
    while (true) {
        const ip: []i64 = computeIP(n, primes);
        const pw: i64 = 6 * n + 3;
        if (pw > denomPow) {
            sum = bigMulPow10(sum, pw - denomPow);
            prev = bigMulPow10(prev, pw - denomPow);
            denomPow = pw;
        }
        if (n < 10) {
            const termStr: []const u8 = formatTerm(ip, pw);
            var ipStr: []const u8 = bigToString(ip);
            while (std.mem.len(ipStr) < 44) {
                ipStr = _concat_string(" ", ipStr);
            }
            var pwStr: []const u8 = _str(0 - pw);
            while (std.mem.len(pwStr) < 3) {
                pwStr = _concat_string(" ", pwStr);
            }
            var padTerm: []const u8 = termStr;
            while (std.mem.len(padTerm) < 35) {
                padTerm = _concat_string(padTerm, " ");
            }
            std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_str(n), "  "), ipStr), "  "), pwStr), "  "), padTerm)}) catch unreachable;
        }
        sum = bigAdd(sum, ip);
        const diff: []i64 = bigAbsDiff(sum, prev);
        if (denomPow >= 70 and bigCmp(diff, bigMulPow10(bigFromInt(1), denomPow - 70)) < 0) {
            break;
        }
        prev = sum;
        n = n + 1;
    }
    const precision: i64 = 70;
    const target: []i64 = bigMulPow10(bigFromInt(1), denomPow + 2 * precision);
    var low: []i64 = bigFromInt(0);
    var high: []i64 = bigMulPow10(bigFromInt(1), precision + 1);
    while (bigCmp(low, bigSub(high, bigFromInt(1))) < 0) {
        var mid: []i64 = bigDivSmall(bigAdd(low, high), 2);
        var prod: []i64 = bigMulBig(bigMulBig(mid, mid), sum);
        if (bigCmp(prod, target) <= 0) {
            low = mid;
        } else {
            high = bigSub(mid, bigFromInt(1));
        }
    }
    var piInt: []i64 = low;
    var piStr: []const u8 = bigToString(piInt);
    if (std.mem.len(piStr) <= precision) {
        piStr = _concat_string(repeat("0", precision - std.mem.len(piStr) + 1), piStr);
    }
    var out: []const u8 = _concat_string(_concat_string(piStr[0..std.mem.len(piStr) - precision], "."), piStr[std.mem.len(piStr) - precision..std.mem.len(piStr)]);
    std.io.getStdOut().writer().print("{s}\n", .{""}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{"Pi to 70 decimal places is:"}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{out}) catch unreachable;
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
