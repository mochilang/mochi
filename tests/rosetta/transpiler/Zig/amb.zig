// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

fn amb(wordsets: [][][]const u8, res: [][]const u8, idx: i64) bool {
    if (idx == std.mem.len(wordsets)) {
        return true;
    }
    var prev: []const u8 = "";
    if (idx > 0) {
        prev = res[@as(usize, @intCast(idx - 1))];
    }
    var i: i64 = 0;
    while (i < std.mem.len(wordsets[@as(usize, @intCast(idx))])) {
        const w: []const u8 = wordsets[@as(usize, @intCast(idx))][@as(usize, @intCast(i))];
        if (idx == 0 or prev[std.mem.len(prev) - 1..std.mem.len(prev)] == w[0..1]) {
            res[@as(usize, @intCast(idx))] = w;
            if (amb(wordsets, res, idx + 1)) {
                return true;
            }
        }
        i = i + 1;
    }
    return false;
}

fn mochi_main() void {
    const wordset: [][][]const u8 = @constCast(&[_][][]const u8{@constCast(&[_][]const u8{"the", "that", "a"})[0..], @constCast(&[_][]const u8{"frog", "elephant", "thing"})[0..], @constCast(&[_][]const u8{"walked", "treaded", "grows"})[0..], @constCast(&[_][]const u8{"slowly", "quickly"})[0..]})[0..];
    var res: [][]const u8 = &[_][]const u8{};
    var i: i64 = 0;
    while (i < std.mem.len(wordset)) {
        res = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append("") catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    if (amb(wordset, res, 0)) {
        var out: []const u8 = _concat_string("[", res[@as(usize, @intCast(0))]);
        var j: i64 = 1;
        while (j < std.mem.len(res)) {
            out = _concat_string(_concat_string(out, " "), res[@as(usize, @intCast(j))]);
            j = j + 1;
        }
        out = _concat_string(out, "]");
        std.io.getStdOut().writer().print("{s}\n", .{out}) catch unreachable;
    } else {
        std.io.getStdOut().writer().print("{s}\n", .{"No amb found"}) catch unreachable;
    }
}

pub fn main() void {
    mochi_main();
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
