// Generated by Mochi compiler v0.10.30 on 2025-07-19T00:26:05Z
const std = @import("std");

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn _join_strings(parts: []const []const u8, sep: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.join(u8, sep, parts, alloc) catch |err| handleError(err);
}

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn fields(s: []const u8) []const []const u8 {
    var words: []u8 = &[_]u8{};
    var cur: []const u8 = ""; // []const u8
    var i: i32 = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        const ch = _slice_string(s, i, (i + 1), 1); // []const u8
        if ((std.mem.eql(u8, ch, " ") or std.mem.eql(u8, ch, "\n")) or std.mem.eql(u8, ch, "\t")) {
            if (@as(i32, @intCast((cur).len)) > 0) {
                words = blk0: {
                    var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator);
                    defer _tmp0.deinit();
                    _tmp0.appendSlice(words.items) catch |err| handleError(err);
                    _tmp0.append(cur) catch |err| handleError(err);
                    const res = _tmp0.toOwnedSlice() catch |err| handleError(err);
                    break :blk0 res;
                };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, ch);
        }
        i = (i + 1);
    }
    if (@as(i32, @intCast((cur).len)) > 0) {
        words = blk1: {
            var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator);
            defer _tmp1.deinit();
            _tmp1.appendSlice(words.items) catch |err| handleError(err);
            _tmp1.append(cur) catch |err| handleError(err);
            const res = _tmp1.toOwnedSlice() catch |err| handleError(err);
            break :blk1 res;
        };
    }
    return words.items;
}

fn padRight(s: []const u8, width: i32) []const u8 {
    var out: []const u8 = s; // []const u8
    var i: i32 = @as(i32, @intCast((s).len)); // i32
    while (i < width) {
        out = _concat_string(out, " ");
        i = (i + 1);
    }
    return out;
}

fn join(xs: []const []const u8, sep: []const u8) []const u8 {
    var res: []const u8 = ""; // []const u8
    var i: i32 = 0; // i32
    while (i < @as(i32, @intCast((xs).len))) {
        if (i > 0) {
            res = _concat_string(res, sep);
        }
        res = _concat_string(res, xs[i]);
        i = (i + 1);
    }
    return res;
}

fn validate(commands: []const []const u8, words: []const []const u8, mins: []const i32) []const []const u8 {
    var results: []u8 = &[_]u8{};
    if (@as(i32, @intCast((words).len)) == 0) {
        return results.items;
    }
    var wi: i32 = 0; // i32
    while (wi < @as(i32, @intCast((words).len))) {
        const w = words[wi]; // []const u8
        var found: bool = false; // bool
        const wlen = @as(i32, @intCast((w).len)); // i32
        var ci: i32 = 0; // i32
        while (ci < @as(i32, @intCast((commands).len))) {
            const cmd = commands[ci]; // []const u8
            if (((mins[ci] != 0) and (wlen >= mins[ci])) and (wlen <= @as(i32, @intCast((cmd).len)))) {
                const c = upper(cmd); // []const u8
                const ww = upper(w); // []const u8
                if (std.mem.eql(u8, c[0..@as(usize, @intCast(wlen))], ww)) {
                    results = blk2: {
                        var _tmp2 = std.ArrayList([]const u8).init(std.heap.page_allocator);
                        defer _tmp2.deinit();
                        _tmp2.appendSlice(results.items) catch |err| handleError(err);
                        _tmp2.append(c) catch |err| handleError(err);
                        const res = _tmp2.toOwnedSlice() catch |err| handleError(err);
                        break :blk2 res;
                    };
                    found = true;
                    break;
                }
            }
            ci = (ci + 1);
        }
        if (!found) {
            results = blk3: {
                var _tmp3 = std.ArrayList([]const u8).init(std.heap.page_allocator);
                defer _tmp3.deinit();
                _tmp3.appendSlice(results.items) catch |err| handleError(err);
                _tmp3.append("*error*") catch |err| handleError(err);
                const res = _tmp3.toOwnedSlice() catch |err| handleError(err);
                break :blk3 res;
            };
        }
        wi = (wi + 1);
    }
    return results.items;
}

fn user_main() void {
    const table = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ", "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "), " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "), "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "), "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "), "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp "); // []const u8
    const commands = fields(table); // []const []const u8
    var mins: []i32 = &[_]i32{};
    var i: i32 = 0; // i32
    while (i < @as(i32, @intCast((commands).len))) {
        var count: i32 = 0; // i32
        var j: i32 = 0; // i32
        const cmd = commands[i]; // []const u8
        while (j < @as(i32, @intCast((cmd).len))) {
            const ch = _slice_string(cmd, j, (j + 1), 1); // []const u8
            if (std.mem.order(u8, ch, "A") != .lt and std.mem.order(u8, ch, "Z") != .gt) {
                count = (count + 1);
            }
            j = (j + 1);
        }
        mins = blk4: {
            var _tmp4 = std.ArrayList(i32).init(std.heap.page_allocator);
            defer _tmp4.deinit();
            _tmp4.appendSlice(mins.items) catch |err| handleError(err);
            _tmp4.append(count) catch |err| handleError(err);
            const res = _tmp4.toOwnedSlice() catch |err| handleError(err);
            break :blk4 res;
        };
        i = (i + 1);
    }
    const sentence: []const u8 = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin"; // []const u8
    const words = fields(sentence); // []const []const u8
    const results = validate(commands, words, mins); // []const []const u8
    var out1: []const u8 = "user words:  "; // []const u8
    var k: i32 = 0; // i32
    while (k < @as(i32, @intCast((words).len))) {
        out1 = _concat_string(_concat_string(out1, padRight(words[k], @as(i32, @intCast((results[k]).len)))), " ");
        k = (k + 1);
    }
    std.debug.print("{s}\n", .{out1});
    std.debug.print("{s}\n", .{_concat_string("full words:  ", _join_strings(results, " "))});
}

pub fn main() void {
    user_main();
}
