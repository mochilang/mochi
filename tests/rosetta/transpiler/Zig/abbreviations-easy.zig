// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

fn fields(s: []const u8) [][]const u8 {
    var words: [][]const u8 = &[_][]const u8{};
    var cur: []const u8 = "";
    var i: i64 = 0;
    while (i < std.mem.len(s)) {
        const ch: []const u8 = s[i..i + 1];
        if (std.mem.eql(u8, ch, " ") or ch == "\n" or ch == "\t") {
            if (std.mem.len(cur) > 0) {
                words = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(words) catch unreachable; _tmp.append(cur) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, ch);
        }
        i = i + 1;
    }
    if (std.mem.len(cur) > 0) {
        words = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(words) catch unreachable; _tmp.append(cur) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
    }
    return words;
}

fn padRight(s: []const u8, width: i64) []const u8 {
    var out: []const u8 = s;
    var i: i64 = std.mem.len(s);
    while (i < width) {
        out = _concat_string(out, " ");
        i = i + 1;
    }
    return out;
}

fn join(xs: [][]const u8, sep: []const u8) []const u8 {
    var res: []const u8 = "";
    var i: i64 = 0;
    while (i < std.mem.len(xs)) {
        if (i > 0) {
            res = _concat_string(res, sep);
        }
        res = _concat_string(res, xs[@as(usize, @intCast(i))]);
        i = i + 1;
    }
    return res;
}

fn validate(commands: [][]const u8, words: [][]const u8, mins: []i64) [][]const u8 {
    var results: [][]const u8 = &[_][]const u8{};
    if (std.mem.len(words) == 0) {
        return results;
    }
    var wi: i64 = 0;
    while (wi < std.mem.len(words)) {
        const w: []const u8 = words[@as(usize, @intCast(wi))];
        var found: bool = false;
        const wlen: i64 = std.mem.len(w);
        var ci: i64 = 0;
        while (ci < std.mem.len(commands)) {
            const cmd: []const u8 = commands[@as(usize, @intCast(ci))];
            if (mins[@as(usize, @intCast(ci))] != 0 and wlen >= mins[@as(usize, @intCast(ci))] and wlen <= std.mem.len(cmd)) {
                const c: []const u8 = std.ascii.upperString(cmd);
                const ww: []const u8 = std.ascii.upperString(w);
                if (std.mem.eql(u8, c[0..wlen], ww)) {
                    results = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(results) catch unreachable; _tmp.append(c) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                    found = true;
                    break;
                }
            }
            ci = ci + 1;
        }
        if (!(found)) {
            results = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(results) catch unreachable; _tmp.append("*error*") catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        }
        wi = wi + 1;
    }
    return results;
}

fn mochi_main() void {
    const table: []const u8 = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress Copy ", "COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find "), "NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "), " Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "), "MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "), "READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "), "RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer TypeUp ");
    const commands: [][]const u8 = fields(table);
    var mins: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < std.mem.len(commands)) {
        var count: i64 = 0;
        var j: i64 = 0;
        const cmd: []const u8 = commands[@as(usize, @intCast(i))];
        while (j < std.mem.len(cmd)) {
            const ch: []const u8 = cmd[j..j + 1];
            if (std.mem.order(u8, ch, "A") != .lt and ch <= "Z") {
                count = count + 1;
            }
            j = j + 1;
        }
        mins = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(mins) catch unreachable; _tmp.append(count) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    const sentence: []const u8 = "riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin";
    const words: [][]const u8 = fields(sentence);
    const results: [][]const u8 = validate(commands, words, mins);
    var out1: []const u8 = "user words:  ";
    var k: i64 = 0;
    while (k < std.mem.len(words)) {
        out1 = _concat_string(_concat_string(out1, padRight(words[@as(usize, @intCast(k))], std.mem.len(results[@as(usize, @intCast(k))]))), " ");
        k = k + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{out1}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string("full words:  ", join(results, " "))}) catch unreachable;
}

pub fn main() void {
    mochi_main();
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
