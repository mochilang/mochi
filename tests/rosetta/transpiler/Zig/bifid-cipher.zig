// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:15Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn square_to_maps(square: []const []const []const u8) std.AutoHashMap([]const u8, i32) {
    var emap = std.AutoHashMap([]const u8, []const i32).init(std.heap.page_allocator);
    var dmap = std.AutoHashMap([]const u8, []const u8).init(std.heap.page_allocator);
    var x = 0; // i32
    while (x < @as(i32, @intCast((square).len))) {
        const row = square[x]; // []const []const u8
        var y = 0; // i32
        while (y < @as(i32, @intCast((row).len))) {
            const ch = row[y]; // []const u8
            _ = emap.put(ch, &[_]i32{
    x,
    y,
}) catch |err| handleError(err);
            _ = dmap.put(_concat_string(_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{x}) catch |err| handleError(err), ","), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{y}) catch |err| handleError(err)), ch) catch |err| handleError(err);
            y = (y + 1);
        }
        x = (x + 1);
    }
    return struct {
    e: std.StringHashMap([]const i32),
    d: std.StringHashMap([]const u8),
}{
    .e = emap,
    .d = dmap,
};
}

fn remove_space(text: []const u8, emap: std.AutoHashMap([]const u8, []const i32)) []const u8 {
    const s = upper(text); // []const u8
    var out = ""; // []const u8
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        const ch = _slice_string(s, i, (i + 1), 1); // []const u8
        if (!std.mem.eql(u8, ch, " ") and emap.contains(ch)) {
            out = _concat_string(out, ch);
        }
        i = (i + 1);
    }
    return out;
}

fn encrypt(text: []const u8, emap: std.AutoHashMap([]const u8, []const i32), dmap: std.AutoHashMap([]const u8, []const u8)) []const u8 {
    text = remove_space(text, emap);
    var row0 = std.ArrayList(i32).init(std.heap.page_allocator);
    var row1 = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < @as(i32, @intCast((text).len))) {
        const ch = _slice_string(text, i, (i + 1), 1); // []const u8
        const xy = emap[ch]; // []const i32
        row0 = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(row0) catch |err| handleError(err); _tmp0.append(xy[0]) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
        row1 = blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(row1) catch |err| handleError(err); _tmp1.append(xy[1]) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
        i = (i + 1);
    }
    for (row1) |v| {
        row0 = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(row0) catch |err| handleError(err); _tmp2.append(v) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
    }
    var res = ""; // []const u8
    var j = 0; // i32
    while (j < @as(i32, @intCast((row0).len))) {
        const key = _concat_string(_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{row0[j]}) catch |err| handleError(err), ","), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{row0[(j + 1)]}) catch |err| handleError(err)); // []const u8
        res = _concat_string(res, dmap[key]);
        j = (j + 2);
    }
    return res;
}

fn decrypt(text: []const u8, emap: std.AutoHashMap([]const u8, []const i32), dmap: std.AutoHashMap([]const u8, []const u8)) []const u8 {
    text = remove_space(text, emap);
    var coords = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < @as(i32, @intCast((text).len))) {
        const ch = _slice_string(text, i, (i + 1), 1); // []const u8
        const xy = emap[ch]; // []const i32
        coords = blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(coords) catch |err| handleError(err); _tmp3.append(xy[0]) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
        coords = blk4: { var _tmp4 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp4.deinit(); _tmp4.appendSlice(coords) catch |err| handleError(err); _tmp4.append(xy[1]) catch |err| handleError(err); const res = _tmp4.toOwnedSlice() catch |err| handleError(err); break :blk4 res; };
        i = (i + 1);
    }
    var half = (@as(i32, @intCast((coords).len)) / 2); // f64
    var k1 = std.ArrayList(i32).init(std.heap.page_allocator);
    var k2 = std.ArrayList(i32).init(std.heap.page_allocator);
    var idx = 0; // i32
    while (idx < half) {
        k1 = blk5: { var _tmp5 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp5.deinit(); _tmp5.appendSlice(k1) catch |err| handleError(err); _tmp5.append(coords[idx]) catch |err| handleError(err); const res = _tmp5.toOwnedSlice() catch |err| handleError(err); break :blk5 res; };
        idx = (idx + 1);
    }
    while (idx < @as(i32, @intCast((coords).len))) {
        k2 = blk6: { var _tmp6 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp6.deinit(); _tmp6.appendSlice(k2) catch |err| handleError(err); _tmp6.append(coords[idx]) catch |err| handleError(err); const res = _tmp6.toOwnedSlice() catch |err| handleError(err); break :blk6 res; };
        idx = (idx + 1);
    }
    var res = ""; // []const u8
    var j = 0; // i32
    while (j < half) {
        const key = _concat_string(_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{k1[j]}) catch |err| handleError(err), ","), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{k2[j]}) catch |err| handleError(err)); // []const u8
        res = _concat_string(res, dmap[key]);
        j = (j + 1);
    }
    return res;
}

fn user_main() void {
    const squareRosetta = &[_][]const []const u8{
    &[_][]const u8{
    "A",
    "B",
    "C",
    "D",
    "E",
},
    &[_][]const u8{
    "F",
    "G",
    "H",
    "I",
    "K",
},
    &[_][]const u8{
    "L",
    "M",
    "N",
    "O",
    "P",
},
    &[_][]const u8{
    "Q",
    "R",
    "S",
    "T",
    "U",
},
    &[_][]const u8{
    "V",
    "W",
    "X",
    "Y",
    "Z",
},
    &[_][]const u8{
    "J",
    "1",
    "2",
    "3",
    "4",
},
}; // []const []const []const u8
    const squareWikipedia = &[_][]const []const u8{
    &[_][]const u8{
    "B",
    "G",
    "W",
    "K",
    "Z",
},
    &[_][]const u8{
    "Q",
    "P",
    "N",
    "D",
    "S",
},
    &[_][]const u8{
    "I",
    "O",
    "A",
    "X",
    "E",
},
    &[_][]const u8{
    "F",
    "C",
    "L",
    "U",
    "M",
},
    &[_][]const u8{
    "T",
    "H",
    "Y",
    "V",
    "R",
},
    &[_][]const u8{
    "J",
    "1",
    "2",
    "3",
    "4",
},
}; // []const []const []const u8
    const textRosetta = "0ATTACKATDAWN"; // []const u8
    const textWikipedia = "FLEEATONCE"; // []const u8
    const textTest = "The invasion will start on the first of January"; // []const u8
    var maps = square_to_maps(squareRosetta); // std.StringHashMap(i32)
    var emap: i32 = maps["e"]; // i32
    var dmap: i32 = maps["d"]; // i32
    std.debug.print("from Rosettacode\n", .{});
    std.debug.print("{s}\n", .{_concat_string("original:\t ", textRosetta)});
    var s = encrypt(textRosetta, emap, dmap); // []const u8
    std.debug.print("{s}\n", .{_concat_string("codiert:\t ", s)});
    s = decrypt(s, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("and back:\t ", s)});
    maps = square_to_maps(squareWikipedia);
    emap = maps["e"];
    dmap = maps["d"];
    std.debug.print("from Wikipedia\n", .{});
    std.debug.print("{s}\n", .{_concat_string("original:\t ", textWikipedia)});
    s = encrypt(textWikipedia, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("codiert:\t ", s)});
    s = decrypt(s, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("and back:\t ", s)});
    maps = square_to_maps(squareWikipedia);
    emap = maps["e"];
    dmap = maps["d"];
    std.debug.print("from Rosettacode long part\n", .{});
    std.debug.print("{s}\n", .{_concat_string("original:\t ", textTest)});
    s = encrypt(textTest, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("codiert:\t ", s)});
    s = decrypt(s, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("and back:\t ", s)});
}

pub fn main() void {
    user_main();
}
