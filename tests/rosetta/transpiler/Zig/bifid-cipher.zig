// Generated by Mochi Zig transpiler on 2025-08-03 17:04 +0700
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const Map0 = struct {
    e: std.StringHashMap([]i64),
    d: std.StringHashMap([]const u8),
};

fn square_to_maps(square: [][][]const u8) Map0 {
    var emap: std.StringHashMap([]i64) = blk: { const m = std.StringHashMap([]i64).init(std.heap.page_allocator); break :blk m; };
    var dmap: std.StringHashMap([]const u8) = blk: { const m = std.StringHashMap([]const u8).init(std.heap.page_allocator); break :blk m; };
    var x: i64 = 0;
    while (x < @as(i64, @intCast(square.len))) {
        const row: [][]const u8 = square[@intCast(x)];
        var y: i64 = 0;
        while (y < @as(i64, @intCast(row.len))) {
            const ch: []const u8 = row[@intCast(y)];
            emap.put(ch, blk0: { var _tmp0 = std.heap.page_allocator.alloc(i64, 2) catch unreachable; _tmp0[0] = x; _tmp0[1] = y; break :blk0 _tmp0; }) catch unreachable;
            dmap.put(_concat_string(_concat_string(_str(x), ","), _str(y)), ch) catch unreachable;
            y = y + 1;
        }
        x = x + 1;
    }
    return .{ .e = emap, .d = dmap };
}

fn remove_space(text: []const u8, emap: std.StringHashMap([]i64)) []const u8 {
    var s: []const u8 = _upper(text);
    var out: []const u8 = "";
    var i: i64 = 0;
    while (i < @as(i64, @intCast(s.len))) {
        const ch: []const u8 = s[@intCast(i)..@intCast(i + 1)];
        if (!std.mem.eql(u8, ch, " ") and emap.contains(ch)) {
            out = _concat_string(out, ch);
        }
        i = i + 1;
    }
    return out;
}

fn encrypt(text_param: []const u8, emap: std.StringHashMap([]i64), dmap: std.StringHashMap([]const u8)) []const u8 {
    var text_var: []const u8 = text_param;
    text_var = remove_space(text_var, emap);
    var row0: []i64 = &[_]i64{};
    var row1: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < @as(i64, @intCast(text_var.len))) {
        const ch: []const u8 = text_var[@intCast(i)..@intCast(i + 1)];
        const xy: []i64 = emap.get(ch).?;
        row0 = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(row0) catch |err| handleError(err); _tmp.append(xy[@intCast(0)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        row1 = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(row1) catch |err| handleError(err); _tmp.append(xy[@intCast(1)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    for (row1) |__it0| {
        const v = __it0;
        row0 = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(row0) catch |err| handleError(err); _tmp.append(v) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
    }
    var res: []const u8 = "";
    var j: i64 = 0;
    while (j < @as(i64, @intCast(row0.len))) {
        const key: []const u8 = _concat_string(_concat_string(_str(row0[@intCast(j)]), ","), _str(row0[@intCast(j + 1)]));
        res = _concat_string(res, dmap.get(key).?);
        j = j + 2;
    }
    return res;
}

fn decrypt(text_param_1: []const u8, emap: std.StringHashMap([]i64), dmap: std.StringHashMap([]const u8)) []const u8 {
    var text_var_1: []const u8 = text_param_1;
    text_var_1 = remove_space(text_var_1, emap);
    var coords: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < @as(i64, @intCast(text_var_1.len))) {
        const ch: []const u8 = text_var_1[@intCast(i)..@intCast(i + 1)];
        const xy: []i64 = emap.get(ch).?;
        coords = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(coords) catch |err| handleError(err); _tmp.append(xy[@intCast(0)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        coords = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(coords) catch |err| handleError(err); _tmp.append(xy[@intCast(1)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i = i + 1;
    }
    const half: i64 = @divTrunc(@as(i64, @intCast(coords.len)), 2);
    var k1: []i64 = &[_]i64{};
    var k2: []i64 = &[_]i64{};
    var idx: i64 = 0;
    while (idx < half) {
        k1 = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(k1) catch |err| handleError(err); _tmp.append(coords[@intCast(idx)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        idx = idx + 1;
    }
    while (idx < @as(i64, @intCast(coords.len))) {
        k2 = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); _tmp.appendSlice(k2) catch |err| handleError(err); _tmp.append(coords[@intCast(idx)]) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        idx = idx + 1;
    }
    var res: []const u8 = "";
    var j: i64 = 0;
    while (j < half) {
        const key: []const u8 = _concat_string(_concat_string(_str(k1[@intCast(j)]), ","), _str(k2[@intCast(j)]));
        res = _concat_string(res, dmap.get(key).?);
        j = j + 1;
    }
    return res;
}

fn mochi_main() void {
    const square_rosetta: [][][]const u8 = blk1: { var _tmp1 = std.heap.page_allocator.alloc([][]const u8, 6) catch unreachable; _tmp1[0] = blk2: { var _tmp2 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp2[0] = "A"; _tmp2[1] = "B"; _tmp2[2] = "C"; _tmp2[3] = "D"; _tmp2[4] = "E"; break :blk2 _tmp2; }; _tmp1[1] = blk3: { var _tmp3 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp3[0] = "F"; _tmp3[1] = "G"; _tmp3[2] = "H"; _tmp3[3] = "I"; _tmp3[4] = "K"; break :blk3 _tmp3; }; _tmp1[2] = blk4: { var _tmp4 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp4[0] = "L"; _tmp4[1] = "M"; _tmp4[2] = "N"; _tmp4[3] = "O"; _tmp4[4] = "P"; break :blk4 _tmp4; }; _tmp1[3] = blk5: { var _tmp5 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp5[0] = "Q"; _tmp5[1] = "R"; _tmp5[2] = "S"; _tmp5[3] = "T"; _tmp5[4] = "U"; break :blk5 _tmp5; }; _tmp1[4] = blk6: { var _tmp6 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp6[0] = "V"; _tmp6[1] = "W"; _tmp6[2] = "X"; _tmp6[3] = "Y"; _tmp6[4] = "Z"; break :blk6 _tmp6; }; _tmp1[5] = blk7: { var _tmp7 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp7[0] = "J"; _tmp7[1] = "1"; _tmp7[2] = "2"; _tmp7[3] = "3"; _tmp7[4] = "4"; break :blk7 _tmp7; }; break :blk1 _tmp1; };
    const square_wikipedia: [][][]const u8 = blk8: { var _tmp8 = std.heap.page_allocator.alloc([][]const u8, 6) catch unreachable; _tmp8[0] = blk9: { var _tmp9 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp9[0] = "B"; _tmp9[1] = "G"; _tmp9[2] = "W"; _tmp9[3] = "K"; _tmp9[4] = "Z"; break :blk9 _tmp9; }; _tmp8[1] = blk10: { var _tmp10 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp10[0] = "Q"; _tmp10[1] = "P"; _tmp10[2] = "N"; _tmp10[3] = "D"; _tmp10[4] = "S"; break :blk10 _tmp10; }; _tmp8[2] = blk11: { var _tmp11 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp11[0] = "I"; _tmp11[1] = "O"; _tmp11[2] = "A"; _tmp11[3] = "X"; _tmp11[4] = "E"; break :blk11 _tmp11; }; _tmp8[3] = blk12: { var _tmp12 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp12[0] = "F"; _tmp12[1] = "C"; _tmp12[2] = "L"; _tmp12[3] = "U"; _tmp12[4] = "M"; break :blk12 _tmp12; }; _tmp8[4] = blk13: { var _tmp13 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp13[0] = "T"; _tmp13[1] = "H"; _tmp13[2] = "Y"; _tmp13[3] = "V"; _tmp13[4] = "R"; break :blk13 _tmp13; }; _tmp8[5] = blk14: { var _tmp14 = std.heap.page_allocator.alloc([]const u8, 5) catch unreachable; _tmp14[0] = "J"; _tmp14[1] = "1"; _tmp14[2] = "2"; _tmp14[3] = "3"; _tmp14[4] = "4"; break :blk14 _tmp14; }; break :blk8 _tmp8; };
    const text_rosetta: []const u8 = "0ATTACKATDAWN";
    const text_wikipedia: []const u8 = "FLEEATONCE";
    const text_test: []const u8 = "The invasion will start on the first of January";
    var maps: Map0 = square_to_maps(square_rosetta);
    var emap: std.StringHashMap([]i64) = maps.e;
    var dmap: std.StringHashMap([]const u8) = maps.d;
    std.debug.print("{s}\n", .{"from Rosettacode"});
    std.debug.print("{s}\n", .{_concat_string("original:\t ", text_rosetta)});
    var s: []const u8 = encrypt(text_rosetta, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("codiert:\t ", s)});
    s = decrypt(s, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("and back:\t ", s)});
    maps = square_to_maps(square_wikipedia);
    emap = maps.e;
    dmap = maps.d;
    std.debug.print("{s}\n", .{"from Wikipedia"});
    std.debug.print("{s}\n", .{_concat_string("original:\t ", text_wikipedia)});
    s = encrypt(text_wikipedia, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("codiert:\t ", s)});
    s = decrypt(s, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("and back:\t ", s)});
    maps = square_to_maps(square_wikipedia);
    emap = maps.e;
    dmap = maps.d;
    std.debug.print("{s}\n", .{"from Rosettacode long part"});
    std.debug.print("{s}\n", .{_concat_string("original:\t ", text_test)});
    s = encrypt(text_test, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("codiert:\t ", s)});
    s = decrypt(s, emap, dmap);
    std.debug.print("{s}\n", .{_concat_string("and back:\t ", s)});
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        const s = std.fmt.allocPrintZ(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
        return s[0..s.len];
    }
    const s = std.fmt.allocPrintZ(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
    return s[0..s.len];
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copy(u8, out[0..lhs.len], lhs);
    std.mem.copy(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _upper(s: []const u8) []const u8 {
    var out = std.heap.page_allocator.alloc(u8, s.len + 1) catch unreachable;
    _ = std.ascii.upperString(out[0..s.len], s);
    out[s.len] = 0;
    return out[0..s.len];
}

fn _lower(s: []const u8) []const u8 {
    var out = std.heap.page_allocator.alloc(u8, s.len + 1) catch unreachable;
    _ = std.ascii.lowerString(out[0..s.len], s);
    out[s.len] = 0;
    return out[0..s.len];
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
