// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_list(comptime T: type, v: []const T, start: i32, end: i32, step: i32) []T {
    var s = start;
    var e = end;
    var st = step;
    const n: i32 = @as(i32, @intCast(v.len));
    if (s < 0) s += n;
    if (e < 0) e += n;
    if (st == 0) st = 1;
    if (s < 0) s = 0;
    if (e > n) e = n;
    if (st > 0 and e < s) e = s;
    if (st < 0 and e > s) e = s;
    var res = std.ArrayList(T).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = s;
    while ((st > 0 and i < e) or (st < 0 and i > e)) : (i += st) {
        res.append(v[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const width = 81; // i32
const height = 5; // i32
var lines: []const []const u8 = &[]i32{};
var stack = (blk0: { const _tmp0 = struct {
    start: i32,
    len: i32,
    index: i32,
}; const _arr = &[_]_tmp0{_tmp0{
    .start = 0,
    .len = width,
    .index = 1,
}}; break :blk0 _arr; }); // []const std.StringHashMap(i32)

fn setChar(s: []const u8, idx: i32, ch: []const u8) []const u8 {
    return _concat_string(_concat_string(substring(s, 0, idx), ch), substring(s, (idx + 1), (s).len));
}

pub fn main() void {
    for (0 .. height) |i| {
        var row = ""; // []const u8
        var j = 0; // i32
        while (j < width) {
            row = _concat_string(row, "*");
            j = (j + 1);
        }
        lines = blk1: { var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(lines) catch |err| handleError(err); _tmp1.append(row) catch |err| handleError(err); break :blk1 _tmp1.items; };
    }
    while ((stack).len > 0) {
        var frame = stack[((stack).len - 1)]; // std.StringHashMap(i32)
        stack = _slice_list(std.StringHashMap(i32), stack, 0, ((stack).len - 1), 1);
        const start = frame["start"]; // i32
        const lenSeg = frame["len"]; // i32
        const index = frame["index"]; // i32
        const seg = @as(i32, ((lenSeg / 3))); // i32
        if (seg == 0) {
            continue;
        }
        var i = index; // i32
        while (i < height) {
            var j = (start + seg); // i32
            while (j < (start + (2 * seg))) {
                lines.items[i] = setChar(lines[i], j, " ");
                j = (j + 1);
            }
            i = (i + 1);
        }
        stack = blk2: { var _tmp2 = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(stack) catch |err| handleError(err); _tmp2.append(struct {
    start: i32,
    len: i32,
    index: i32,
}{
    .start = start,
    .len = seg,
    .index = (index + 1),
}) catch |err| handleError(err); break :blk2 _tmp2.items; };
        stack = blk3: { var _tmp3 = std.ArrayList(std.StringHashMap(i32)).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(stack) catch |err| handleError(err); _tmp3.append(struct {
    start: i32,
    len: i32,
    index: i32,
}{
    .start = (start + (seg * 2)),
    .len = seg,
    .index = (index + 1),
}) catch |err| handleError(err); break :blk3 _tmp3.items; };
    }
    for (lines) |line| {
        std.debug.print("{s}\n", .{line});
    }
}
