// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:00:41Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

var e1 = pow_int(3, 2); // i32
var e2 = pow_int(4, e1); // i32
var base: i32 = 5;
var x: i32 = pow_big(base, e2);
var s = std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{x}) catch |err| handleError(err); // []const u8

fn pow_int(base: i32, exp: i32) i32 {
    var result = 1; // i32
    var b = base; // i32
    var e = exp; // i32
    while (e > 0) {
        if (@mod(e, 2) == 1) {
            result = (result * b);
        }
        b = (b * b);
        e = @as(i32, ((e / 2)));
    }
    return result;
}

fn pow_big(base: i32, exp: i32) i32 {
    var result: i32 = 1; // i32
    var b: i32 = base; // i32
    var e = exp; // i32
    while (e > 0) {
        if (@mod(e, 2) == 1) {
            result = (result * b);
        }
        b = (b * b);
        e = @as(i32, ((e / 2)));
    }
    return result;
}

pub fn main() void {
    std.debug.print("5^(4^(3^2)) has {d} digits: {s} ... {s}\n", .{@as(i32, @intCast((s).len)), s[0..20], _slice_string(s, (@as(i32, @intCast((s).len)) - 20), @as(i32, @intCast((s).len)), 1)});
}
