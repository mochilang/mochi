// Generated by Mochi compiler v0.10.26 on 1970-01-01T00:00:00Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const TestcasesItem = struct {
    base: i32,
    begin: []const u8,
    end: []const u8,
    kaprekar: []const []const u8,
};
const testCases = &[_]TestcasesItem{
    TestcasesItem{
    .base = 10,
    .begin = "1",
    .end = "100",
    .kaprekar = &[_][]const u8{
    "1",
    "9",
    "45",
    "55",
    "99",
},
},
    TestcasesItem{
    .base = 17,
    .begin = "10",
    .end = "gg",
    .kaprekar = &[_][]const u8{
    "3d",
    "d4",
    "gg",
},
},
}; // []const TestcasesItem
var idx = 0; // i32

fn parseIntBase(s: []const u8, base: i32) i32 {
    const digits = "0123456789abcdefghijklmnopqrstuvwxyz"; // []const u8
    var n = 0; // i32
    var i = 0; // i32
    while (i < (s).len) {
        var j = 0; // i32
        var v = 0; // i32
        while (j < (digits).len) {
            if (substring(digits, j, (j + 1)) == _slice_string(s, i, (i + 1), 1)) {
                v = j;
                break;
            }
            j = (j + 1);
        }
        n = ((n * base) + v);
        i = (i + 1);
    }
    return n;
}

fn intToBase(n: i32, base: i32) []const u8 {
    const digits = "0123456789abcdefghijklmnopqrstuvwxyz"; // []const u8
    if (n == 0) {
        return "0";
    }
    var out = ""; // []const u8
    var v = n; // i32
    while (v > 0) {
        const d = @mod(v, base); // i32
        out = _concat_string(_slice_string(digits, d, (d + 1), 1), out);
        v = (v / base);
    }
    return out;
}

fn subset(base: i32, begin: []const u8, end: []const u8) []const []const u8 {
    var b = parseIntBase(begin, base); // i32
    var e = parseIntBase(end, base); // i32
    var out = std.ArrayList(u8).init(std.heap.page_allocator);
    var k = b; // i32
    while (k <= e) {
        const ks = intToBase(k, base); // []const u8
        const mod = (base - 1); // i32
        const r1 = @mod(parseIntBase(ks, base), mod); // i32
        const r2 = @mod(((parseIntBase(ks, base) * parseIntBase(ks, base))), mod); // i32
        if (r1 == r2) {
            out = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(out) catch |err| handleError(err); _tmp0.append(ks) catch |err| handleError(err); break :blk0 _tmp0.items; };
        }
        k = (k + 1);
    }
    return out.items;
}

pub fn main() void {
    while (idx < (testCases).len) {
        const tc = testCases[idx]; // TestcasesItem
        std.debug.print("{any}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("\nTest case base = ", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{tc["base"]}) catch |err| handleError(err)), ", begin = "), tc["begin"]), ", end = "), tc["end"]), ":")});
        const s: i32 = subset(tc["base"], tc["begin"], tc["end"]); // i32
        std.debug.print("{s}\n", .{_concat_string("Subset:  ", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{s}) catch |err| handleError(err))});
        std.debug.print("{any}\n", .{_concat_string("Kaprekar:", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{tc["kaprekar"]}) catch |err| handleError(err))});
        var sx = 0; // i32
        var valid = true; // bool
        var i = 0; // i32
        while (i < (tc["kaprekar"]).len) {
            const k: i32 = tc["kaprekar"][i]; // i32
            var found = false; // bool
            while (sx < (s).len) {
                if (s[sx] == k) {
                    found = true;
                    sx = (sx + 1);
                    break;
                }
                sx = (sx + 1);
            }
            if (!found) {
                std.debug.print("{any}\n", .{_concat_string(_concat_string("Fail:", k), " not in subset")});
                valid = false;
                break;
            }
            i = (i + 1);
        }
        if (valid) {
            std.debug.print("Valid subset.\n", .{});
        }
        idx = (idx + 1);
    }
}
