// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

const Map0 = struct {
    0: i64,
    1: i64,
    2: i64,
    3: i64,
    4: i64,
    5: i64,
    6: i64,
    7: i64,
    8: i64,
    9: i64,
};

const Map1 = struct {
    commands: [][]const u8,
    mins: []i64,
};

fn fields(s: []const u8) [][]const u8 {
    var words: [][]const u8 = &[_][]const u8{};
    var cur: []const u8 = "";
    var i: i64 = 0;
    while (i < std.mem.len(s)) {
        const ch: []const u8 = s[i..i + 1];
        if (std.mem.eql(u8, ch, " ") or ch == "\n" or ch == "\t") {
            if (std.mem.len(cur) > 0) {
                words = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(words) catch unreachable; _tmp.append(cur) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                cur = "";
            }
        } else {
            cur = _concat_string(cur, ch);
        }
        i = i + 1;
    }
    if (std.mem.len(cur) > 0) {
        words = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(words) catch unreachable; _tmp.append(cur) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
    }
    return words;
}

fn padRight(s: []const u8, width: i64) []const u8 {
    var out: []const u8 = s;
    var i: i64 = std.mem.len(s);
    while (i < width) {
        out = _concat_string(out, " ");
        i = i + 1;
    }
    return out;
}

fn join(xs: [][]const u8, sep: []const u8) []const u8 {
    var res: []const u8 = "";
    var i: i64 = 0;
    while (i < std.mem.len(xs)) {
        if (i > 0) {
            res = _concat_string(res, sep);
        }
        res = _concat_string(res, xs[@as(usize, @intCast(i))]);
        i = i + 1;
    }
    return res;
}

fn parseIntStr(str: []const u8) i64 {
    var i: i64 = 0;
    var neg: bool = false;
    if (std.mem.len(str) > 0 and str[0..1] == "-") {
        neg = true;
        i = 1;
    }
    var n: i64 = 0;
    const digits: Map0 = .{ .0 = 0, .1 = 1, .2 = 2, .3 = 3, .4 = 4, .5 = 5, .6 = 6, .7 = 7, .8 = 8, .9 = 9 };
    while (i < std.mem.len(str)) {
        n = n * 10 + digits[@as(usize, @intCast(str[i..i + 1]))];
        i = i + 1;
    }
    if (neg) {
        n = 0 - n;
    }
    return n;
}

fn isDigits(s: []const u8) bool {
    if (std.mem.len(s) == 0) {
        return false;
    }
    var i: i64 = 0;
    while (i < std.mem.len(s)) {
        const ch: []const u8 = s[i..i + 1];
        if (std.mem.order(u8, ch, "0") == .lt or ch > "9") {
            return false;
        }
        i = i + 1;
    }
    return true;
}

fn readTable(table: []const u8) i64 {
    const toks: [][]const u8 = fields(table);
    var cmds: [][]const u8 = &[_][]const u8{};
    var mins: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < std.mem.len(toks)) {
        const cmd: []const u8 = toks[@as(usize, @intCast(i))];
        var minlen: i64 = std.mem.len(cmd);
        i = i + 1;
        if (i < std.mem.len(toks) and isDigits(toks[@as(usize, @intCast(i))])) {
            const num: i64 = parseIntStr(toks[@as(usize, @intCast(i))]);
            if (num >= 1 and num < std.mem.len(cmd)) {
                minlen = num;
                i = i + 1;
            }
        }
        cmds = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(cmds) catch unreachable; _tmp.append(cmd) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        mins = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(mins) catch unreachable; _tmp.append(minlen) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
    }
    return .{ .commands = cmds, .mins = mins };
}

fn validate(commands: [][]const u8, mins: []i64, words: [][]const u8) [][]const u8 {
    var results: [][]const u8 = &[_][]const u8{};
    var wi: i64 = 0;
    while (wi < std.mem.len(words)) {
        const w: []const u8 = words[@as(usize, @intCast(wi))];
        var found: bool = false;
        const wlen: i64 = std.mem.len(w);
        var ci: i64 = 0;
        while (ci < std.mem.len(commands)) {
            const cmd: []const u8 = commands[@as(usize, @intCast(ci))];
            if (mins[@as(usize, @intCast(ci))] != 0 and wlen >= mins[@as(usize, @intCast(ci))] and wlen <= std.mem.len(cmd)) {
                const c: []const u8 = std.ascii.upperString(cmd);
                const ww: []const u8 = std.ascii.upperString(w);
                if (std.mem.eql(u8, c[0..wlen], ww)) {
                    results = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(results) catch unreachable; _tmp.append(c) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                    found = true;
                    break;
                }
            }
            ci = ci + 1;
        }
        if (!(found)) {
            results = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(results) catch unreachable; _tmp.append("*error*") catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        }
        wi = wi + 1;
    }
    return results;
}

fn mochi_main() void {
    const table: []const u8 = _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("", "add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 "), "compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate "), "3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 "), "forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load "), "locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 "), "msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 "), "refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left "), "2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ");
    const sentence: []const u8 = "riG   rePEAT copies  put mo   rest    types   fup.    6\npoweRin";
    const tbl: i64 = readTable(table);
    const commands: [][]const u8 = tbl[@as(usize, @intCast("commands"))];
    const mins: []i64 = tbl[@as(usize, @intCast("mins"))];
    const words: [][]const u8 = fields(sentence);
    const results: [][]const u8 = validate(commands, mins, words);
    var out1: []const u8 = "user words:";
    var k: i64 = 0;
    while (k < std.mem.len(words)) {
        out1 = _concat_string(out1, " ");
        if (k < std.mem.len(words) - 1) {
            out1 = _concat_string(out1, padRight(words[@as(usize, @intCast(k))], std.mem.len(results[@as(usize, @intCast(k))])));
        } else {
            out1 = _concat_string(out1, words[@as(usize, @intCast(k))]);
        }
        k = k + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{out1}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string("full words: ", join(results, " "))}) catch unreachable;
}

pub fn main() void {
    mochi_main();
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
