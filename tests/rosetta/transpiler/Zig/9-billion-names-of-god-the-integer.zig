// Generated by Mochi Zig transpiler on 2025-07-23 09:39 +0700
const std = @import("std");

fn bigTrim(a: []i64) []i64 {
    var n = std.mem.len(a);
    while (n > 1 and a[@as(usize, @intCast(n - 1))] == 0) {
        a = a[0..n - 1];
        n = n - 1;
    }
    return a;
}

fn bigFromInt(x: i64) []i64 {
    if (x == 0) {
        return [1]i64{0};
    }
    var digits: []i64 = &[_]i64{};
    var n = x;
    while (n > 0) {
        digits = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(digits) catch unreachable; _tmp.append(@mod(n, 10)) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        n = n / 10;
    }
    return digits;
}

fn bigAdd(a: []i64, b: []i64) []i64 {
    var res: []i64 = &[_]i64{};
    var carry: i64 = 0;
    var i: i64 = 0;
    while (i < std.mem.len(a) or i < std.mem.len(b) or carry > 0) {
        var av: i64 = 0;
        if (i < std.mem.len(a)) {
            av = a[@as(usize, @intCast(i))];
        }
        var bv: i64 = 0;
        if (i < std.mem.len(b)) {
            bv = b[@as(usize, @intCast(i))];
        }
        var s = av + bv + carry;
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(@mod(s, 10)) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        carry = s / 10;
        i = i + 1;
    }
    return bigTrim(res);
}

fn bigSub(a: []i64, b: []i64) []i64 {
    var res: []i64 = &[_]i64{};
    var borrow: i64 = 0;
    var i: i64 = 0;
    while (i < std.mem.len(a)) {
        var av = a[@as(usize, @intCast(i))];
        var bv: i64 = 0;
        if (i < std.mem.len(b)) {
            bv = b[@as(usize, @intCast(i))];
        }
        var diff = av - bv - borrow;
        if (diff < 0) {
            diff = diff + 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(diff) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    return bigTrim(res);
}

fn bigToString(a: []i64) []const u8 {
    var s = "";
    var i = std.mem.len(a) - 1;
    while (i >= 0) {
        s = _concat_string(s, _str(a[@as(usize, @intCast(i))]));
        i = i - 1;
    }
    return s;
}

fn minInt(a: i64, b: i64) i64 {
    if (a < b) {
        return a;
    } else {
        return b;
    }
}

fn cumu(n: i64) [][]i64 {
    var cache = [1][]i64{[1]i64{bigFromInt(1)}};
    var y: i64 = 1;
    while (y <= n) {
        var row: []i64 = [1]i64{bigFromInt(0)};
        var x: i64 = 1;
        while (x <= y) {
            const val = cache[@as(usize, @intCast(y - x))][@as(usize, @intCast(minInt(x, y - x)))];
            row = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(row) catch unreachable; _tmp.append(bigAdd(row[@as(usize, @intCast(std.mem.len(row) - 1))], val)) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            x = x + 1;
        }
        cache = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(cache) catch unreachable; _tmp.append(row) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        y = y + 1;
    }
    return cache[@as(usize, @intCast(n))];
}

fn row(n: i64) [][]const u8 {
    const e = cumu(n);
    var out: []i64 = &[_]i64{};
    var i: i64 = 0;
    while (i < n) {
        const diff = bigSub(e[@as(usize, @intCast(i + 1))], e[@as(usize, @intCast(i))]);
        out = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(out) catch unreachable; _tmp.append(bigToString(diff)) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    return out;
}

pub fn main() void {
    std.io.getStdOut().writer().print("{s}\n", .{"rows:"}) catch unreachable;
    var x: i64 = 1;
    while (x < 11) {
        const r = row(x);
        var line = "";
        var i: i64 = 0;
        while (i < std.mem.len(r)) {
            line = _concat_string(_concat_string(line, " ") + r[@as(usize, @intCast(i))], " ");
            i = i + 1;
        }
        std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
        x = x + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{""}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{"sums:"}) catch unreachable;
    for ([3]i64{23, 123, 1234}) |num| {
        const r = cumu(num);
        std.io.getStdOut().writer().print("{any}\n", .{_concat_string(_str(num), " ") + bigToString(r[@as(usize, @intCast(std.mem.len(r) - 1))])}) catch unreachable;
    }
}

fn _str(v: anytype) []const u8 {
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
