// Generated by Mochi Zig transpiler on 2025-07-23 09:39 +0700
const std = @import("std");

fn validComb(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64) bool {
    const square1 = a + b;
    const square2 = b + c + d;
    const square3 = d + e + f;
    const square4 = f + g;
    return square1 == square2 and square2 == square3 and square3 == square4;
}

fn isUnique(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64) bool {
    var nums = [7]i64{a, b, c, d, e, f, g};
    var i: i64 = 0;
    while (i < std.mem.len(nums)) {
        var j = i + 1;
        while (j < std.mem.len(nums)) {
            if (nums[@as(usize, @intCast(i))] == nums[@as(usize, @intCast(j))]) {
                return false;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return true;
}

fn getCombs(low: i64, high: i64, unique: bool) i64 {
    var valid: [][]i64 = &[_][]i64{};
    var count: i64 = 0;
    for (low..high + 1) |b| {
        for (low..high + 1) |c| {
            for (low..high + 1) |d| {
                const s = b + c + d;
                for (low..high + 1) |e| {
                    for (low..high + 1) |f| {
                        const a = s - b;
                        const g = s - f;
                        if (a < low or a > high) {
                            continue;
                        }
                        if (g < low or g > high) {
                            continue;
                        }
                        if (d + e + f != s) {
                            continue;
                        }
                        if (f + g != s) {
                            continue;
                        }
                        if (!(unique) or isUnique(a, b, c, d, e, f, g)) {
                            valid = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(valid) catch unreachable; _tmp.append([7]i64{a, b, c, d, e, f, g}) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                            count = count + 1;
                        }
                    }
                }
            }
        }
    }
    return blk: { var m = std.StringHashMap(i64).init(std.heap.page_allocator); m.put("count", count) catch unreachable; m.put("list", valid) catch unreachable; break :blk m; };
}

pub fn main() void {
    const r1 = getCombs(1, 7, true);
    std.io.getStdOut().writer().print("{any}\n", .{_concat_string(_str(r1[@as(usize, @intCast("count"))]), " unique solutions in 1 to 7")}) catch unreachable;
    std.io.getStdOut().writer().print("{d}\n", .{r1[@as(usize, @intCast("list"))]}) catch unreachable;
    const r2 = getCombs(3, 9, true);
    std.io.getStdOut().writer().print("{any}\n", .{_concat_string(_str(r2[@as(usize, @intCast("count"))]), " unique solutions in 3 to 9")}) catch unreachable;
    std.io.getStdOut().writer().print("{d}\n", .{r2[@as(usize, @intCast("list"))]}) catch unreachable;
    const r3 = getCombs(0, 9, false);
    std.io.getStdOut().writer().print("{any}\n", .{_concat_string(_str(r3[@as(usize, @intCast("count"))]), " non-unique solutions in 0 to 9")}) catch unreachable;
}

fn _str(v: anytype) []const u8 {
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
