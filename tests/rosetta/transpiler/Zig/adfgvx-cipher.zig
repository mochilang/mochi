// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

var adfgvx: []const u8 = "ADFGVX";
var alphabet: []const u8 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

fn shuffleStr(s: []const u8) []const u8 {
    var arr: [][]const u8 = &[_][]const u8{};
    var i: i64 = 0;
    while (i < std.mem.len(s)) {
        arr = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(arr) catch unreachable; _tmp.append(s[i..i + 1]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    var j: i64 = std.mem.len(arr) - 1;
    while (j > 0) {
        const k: i64 = @mod(_now(), j + 1);
        const tmp: []i64 = arr[@as(usize, @intCast(j))];
        arr[@as(usize, @intCast(j))] = arr[@as(usize, @intCast(k))];
        arr[@as(usize, @intCast(k))] = tmp;
        j = j - 1;
    }
    var out: []const u8 = "";
    i = 0;
    while (i < std.mem.len(arr)) {
        out = _concat_string(out, arr[@as(usize, @intCast(i))]);
        i = i + 1;
    }
    return out;
}

fn createPolybius() [][]const u8 {
    const shuffled: []const u8 = shuffleStr(alphabet);
    var labels: [][]const u8 = &[_][]const u8{};
    var li: i64 = 0;
    while (li < std.mem.len(adfgvx)) {
        labels = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(labels) catch unreachable; _tmp.append(adfgvx[li..li + 1]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        li = li + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{"6 x 6 Polybius square:\n"}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{"  | A D F G V X"}) catch unreachable;
    std.io.getStdOut().writer().print("{s}\n", .{"---------------"}) catch unreachable;
    var p: [][]const u8 = &[_][]const u8{};
    var i: i64 = 0;
    while (i < 6) {
        var row: [][]const u8 = shuffled[i * 6..i + 1 * 6];
        p = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(p) catch unreachable; _tmp.append(row) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        var line: []const u8 = _concat_string(labels[@as(usize, @intCast(i))], " | ");
        var j: i64 = 0;
        while (j < 6) {
            line = _concat_string(_concat_string(line, row[j..j + 1]), " ");
            j = j + 1;
        }
        std.io.getStdOut().writer().print("{s}\n", .{line}) catch unreachable;
        i = i + 1;
    }
    return p;
}

fn createKey(n: i64) []const u8 {
    if (n < 7 or n > 12) {
        std.io.getStdOut().writer().print("{s}\n", .{"Key should be within 7 and 12 letters long."}) catch unreachable;
    }
    var pool: []const u8 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    var key: []const u8 = "";
    var i: i64 = 0;
    while (i < n) {
        const idx: i64 = @mod(_now(), std.mem.len(pool));
        key = _concat_string(key, pool[@as(usize, @intCast(idx))]);
        pool = _concat_string(pool[..idx], pool[idx + 1..std.mem.len(pool)]);
        i = i + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string("\nThe key is ", key)}) catch unreachable;
    return key;
}

fn orderKey(key: []const u8) []i64 {
    var pairs: [][]i64 = &[_][]i64{};
    var i: i64 = 0;
    while (i < std.mem.len(key)) {
        pairs = blk: { var _tmp = std.ArrayList([]i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(pairs) catch unreachable; _tmp.append([2]i64{key[i..i + 1], i}) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    var n: i64 = std.mem.len(pairs);
    var m: i64 = 0;
    while (m < n) {
        var j: i64 = 0;
        while (j < n - 1) {
            if (pairs[@as(usize, @intCast(j))][@as(usize, @intCast(0))] > pairs[@as(usize, @intCast(j + 1))][@as(usize, @intCast(0))]) {
                const tmp: []i64 = pairs[@as(usize, @intCast(j))];
                pairs[@as(usize, @intCast(j))] = pairs[@as(usize, @intCast(j + 1))];
                pairs[@as(usize, @intCast(j + 1))] = tmp;
            }
            j = j + 1;
        }
        m = m + 1;
    }
    var res: []i64 = &[_]i64{};
    i = 0;
    while (i < n) {
        res = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(res) catch unreachable; _tmp.append(pairs[@as(usize, @intCast(i))][@as(usize, @intCast(1))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        i = i + 1;
    }
    return res;
}

fn encrypt(polybius: [][]const u8, key: []const u8, plainText: []const u8) []const u8 {
    var labels: [][]const u8 = &[_][]const u8{};
    var li: i64 = 0;
    while (li < std.mem.len(adfgvx)) {
        labels = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(labels) catch unreachable; _tmp.append(adfgvx[li..li + 1]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        li = li + 1;
    }
    var temp: []const u8 = "";
    var i: i64 = 0;
    while (i < std.mem.len(plainText)) {
        var r: i64 = 0;
        while (r < 6) {
            var c: i64 = 0;
            while (c < 6) {
                if (std.mem.eql(u8, polybius[@as(usize, @intCast(r))][c..c + 1], plainText[i..i + 1])) {
                    temp = _concat_string(_concat_string(temp, labels[r..r + 1]), labels[c..c + 1]);
                }
                c = c + 1;
            }
            r = r + 1;
        }
        i = i + 1;
    }
    var colLen: i64 = std.mem.len(temp) / std.mem.len(key);
    if (@mod(std.mem.len(temp), std.mem.len(key)) > 0) {
        colLen = colLen + 1;
    }
    var table: [][][]const u8 = &[_][][]const u8{};
    var rIdx: i64 = 0;
    while (rIdx < colLen) {
        var row: [][]const u8 = &[_][]const u8{};
        var j: i64 = 0;
        while (j < std.mem.len(key)) {
            row = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(row) catch unreachable; _tmp.append("") catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            j = j + 1;
        }
        table = blk: { var _tmp = std.ArrayList([][]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(table) catch unreachable; _tmp.append(row) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        rIdx = rIdx + 1;
    }
    var idx: i64 = 0;
    while (idx < std.mem.len(temp)) {
        const row: [][]const u8 = idx / std.mem.len(key);
        const col: i64 = @mod(idx, std.mem.len(key));
        table[@as(usize, @intCast(row))][@as(usize, @intCast(col))] = temp[idx..idx + 1];
        idx = idx + 1;
    }
    const order: []i64 = orderKey(key);
    var cols: [][]const u8 = &[_][]const u8{};
    var ci: i64 = 0;
    while (ci < std.mem.len(key)) {
        var colStr: []const u8 = "";
        var ri: i64 = 0;
        while (ri < colLen) {
            colStr = _concat_string(colStr, table[@as(usize, @intCast(ri))][@as(usize, @intCast(order[@as(usize, @intCast(ci))]))]);
            ri = ri + 1;
        }
        cols = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(cols) catch unreachable; _tmp.append(colStr) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        ci = ci + 1;
    }
    var result: []const u8 = "";
    ci = 0;
    while (ci < std.mem.len(cols)) {
        result = _concat_string(result, cols[@as(usize, @intCast(ci))]);
        if (ci < std.mem.len(cols) - 1) {
            result = _concat_string(result, " ");
        }
        ci = ci + 1;
    }
    return result;
}

fn indexOf(s: []const u8, ch: []const u8) i64 {
    var i: i64 = 0;
    while (i < std.mem.len(s)) {
        if (std.mem.eql(u8, s[i..i + 1], ch)) {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;
}

fn decrypt(polybius: [][]const u8, key: []const u8, cipherText: []const u8) []const u8 {
    var colStrs: [][]const u8 = &[_][]const u8{};
    var start: i64 = 0;
    var i: i64 = 0;
    while (i <= std.mem.len(cipherText)) {
        if (i == std.mem.len(cipherText) or cipherText[@as(usize, @intCast(i))] == " ") {
            colStrs = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(colStrs) catch unreachable; _tmp.append(cipherText[start..i]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            start = i + 1;
        }
        i = i + 1;
    }
    var maxColLen: i64 = 0;
    i = 0;
    while (i < std.mem.len(colStrs)) {
        if (std.mem.len(colStrs[@as(usize, @intCast(i))]) > maxColLen) {
            maxColLen = std.mem.len(colStrs[@as(usize, @intCast(i))]);
        }
        i = i + 1;
    }
    var cols: [][][]const u8 = &[_][][]const u8{};
    i = 0;
    while (i < std.mem.len(colStrs)) {
        var s: []const u8 = colStrs[@as(usize, @intCast(i))];
        var ls: [][]const u8 = &[_][]const u8{};
        var j: i64 = 0;
        while (j < std.mem.len(s)) {
            ls = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(ls) catch unreachable; _tmp.append(s[j..j + 1]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            j = j + 1;
        }
        if (std.mem.len(s) < maxColLen) {
            var pad: [][]const u8 = &[_][]const u8{};
            var k: i64 = 0;
            while (k < maxColLen) {
                if (k < std.mem.len(ls)) {
                    pad = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(pad) catch unreachable; _tmp.append(ls[@as(usize, @intCast(k))]) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                } else {
                    pad = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(pad) catch unreachable; _tmp.append("") catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
                }
                k = k + 1;
            }
            cols = blk: { var _tmp = std.ArrayList([][]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(cols) catch unreachable; _tmp.append(pad) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        } else {
            cols = blk: { var _tmp = std.ArrayList([][]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(cols) catch unreachable; _tmp.append(ls) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        }
        i = i + 1;
    }
    var table: [][][]const u8 = &[_][][]const u8{};
    var r: i64 = 0;
    while (r < maxColLen) {
        var row: [][]const u8 = &[_][]const u8{};
        var c: i64 = 0;
        while (c < std.mem.len(key)) {
            row = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(row) catch unreachable; _tmp.append("") catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
            c = c + 1;
        }
        table = blk: { var _tmp = std.ArrayList([][]const u8).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(table) catch unreachable; _tmp.append(row) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        r = r + 1;
    }
    const order: []i64 = orderKey(key);
    r = 0;
    while (r < maxColLen) {
        var c: i64 = 0;
        while (c < std.mem.len(key)) {
            table[@as(usize, @intCast(r))][@as(usize, @intCast(order[@as(usize, @intCast(c))]))] = cols[@as(usize, @intCast(c))][@as(usize, @intCast(r))];
            c = c + 1;
        }
        r = r + 1;
    }
    var temp: []const u8 = "";
    r = 0;
    while (r < std.mem.len(table)) {
        var j: i64 = 0;
        while (j < std.mem.len(table[@as(usize, @intCast(r))])) {
            temp = _concat_string(temp, table[@as(usize, @intCast(r))][@as(usize, @intCast(j))]);
            j = j + 1;
        }
        r = r + 1;
    }
    var plainText: []const u8 = "";
    var idx: i64 = 0;
    while (idx < std.mem.len(temp)) {
        const rIdx: i64 = indexOf(adfgvx, temp[idx..idx + 1]);
        const cIdx: i64 = indexOf(adfgvx, temp[idx + 1..idx + 2]);
        plainText = _concat_string(plainText, polybius[@as(usize, @intCast(rIdx))][@as(usize, @intCast(cIdx))]);
        idx = idx + 2;
    }
    return plainText;
}

fn mochi_main() void {
    const plainText: []const u8 = "ATTACKAT1200AM";
    const polybius: [][]const u8 = createPolybius();
    const key: []const u8 = createKey(9);
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string("\nPlaintext : ", plainText)}) catch unreachable;
    const cipherText: []const u8 = encrypt(polybius, key, plainText);
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string("\nEncrypted : ", cipherText)}) catch unreachable;
    const plainText2: []const u8 = decrypt(polybius, key, cipherText);
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string("\nDecrypted : ", plainText2)}) catch unreachable;
}

pub fn main() void {
    mochi_main();
}

var _now_seed: i64 = 0;
var _now_seeded: bool = false;
fn _now() i64 {
    if (_now_seeded) {
        _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
        return _now_seed;
    }
    if (! _now_seeded) {
        if (std.process.getEnvVarOwned(std.heap.page_allocator, "MOCHI_NOW_SEED")) |s| {
            defer std.heap.page_allocator.free(s);
            if (std.fmt.parseInt(i64, s, 10)) |v| {
                _now_seed = v;
                _now_seeded = true;
                _now_seed = @mod(_now_seed * 1664525 + 1013904223, 2147483647);
                return _now_seed;
            } else |_| {}
        } else |_| {}
    }
    return @as(i64, @intCast(std.time.nanoTimestamp()));
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
