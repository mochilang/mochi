// Generated by Mochi compiler v0.10.28 on 2025-07-18T09:59:58Z
const std = @import("std");

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

var adfgvx = "ADFGVX"; // []const u8
var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; // []const u8

fn shuffleStr(s: []const u8) []const u8 {
    var arr = std.ArrayList(u8).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        try arr.append(@as(i32,@intCast(s[i])));
        i = (i + 1);
    }
    var j = (@as(i32, @intCast((arr).len)) - 1); // i32
    while (j > 0) {
        const k = @mod(std.time.nanoTimestamp(), ((j + 1))); // i32
        const tmp = arr[j]; // []const u8
        arr.items[j] = arr[k];
        arr.items[k] = tmp;
        j = (j - 1);
    }
    var out = ""; // []const u8
    i = 0;
    while (i < @as(i32, @intCast((arr).len))) {
        out = _concat_string(out, arr[i]);
        i = (i + 1);
    }
    return out;
}

fn createPolybius() []const []const u8 {
    const shuffled = shuffleStr(alphabet); // []const u8
    std.debug.print("6 x 6 Polybius square:\n\n", .{});
    std.debug.print("  | A D F G V X\n", .{});
    std.debug.print("---------------\n", .{});
    var p = std.ArrayList(u8).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < 6) {
        var row = _slice_string(shuffled, (i * 6), (((i + 1)) * 6), 1); // []const u8
        try p.append(@as(i32,@intCast(row)));
        var line = _concat_string(adfgvx[i], " | "); // []const u8
        var j = 0; // i32
        while (j < 6) {
            line = _concat_string(_concat_string(line, row[j]), " ");
            j = (j + 1);
        }
        std.debug.print("{s}\n", .{line});
        i = (i + 1);
    }
    return p.items;
}

fn createKey(n: i32) []const u8 {
    if ((n < 7) or (n > 12)) {
        std.debug.print("Key should be within 7 and 12 letters long.\n", .{});
    }
    var pool = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; // []const u8
    var key = ""; // []const u8
    var i = 0; // i32
    while (i < n) {
        const idx = @mod(std.time.nanoTimestamp(), @as(i32, @intCast((pool).len))); // i32
        key = _concat_string(key, pool[idx]);
        pool = (_slice_string(pool, 0, idx, 1) + _slice_string(pool, (idx + 1), @as(i32, @intCast((pool).len)), 1));
        i = (i + 1);
    }
    std.debug.print("{s}\n", .{_concat_string("\nThe key is ", key)});
    return key;
}

fn orderKey(key: []const u8) []const i32 {
    var pairs = std.ArrayList(i32).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < @as(i32, @intCast((key).len))) {
        try pairs.append(@as(i32,@intCast(&[_][]const u8{
    key[i],
    i,
})));
        i = (i + 1);
    }
    var n = @as(i32, @intCast((pairs).len)); // i32
    var m = 0; // i32
    while (m < n) {
        var j = 0; // i32
        while (j < (n - 1)) {
            if (pairs[j][0] > pairs[(j + 1)][0]) {
                const tmp: i32 = pairs[j]; // i32
                pairs.items[j] = pairs[(j + 1)];
                pairs.items[(j + 1)] = tmp;
            }
            j = (j + 1);
        }
        m = (m + 1);
    }
    var res = std.ArrayList(i32).init(std.heap.page_allocator);
    i = 0;
    while (i < n) {
        try res.append(@as(i32,@intCast(@as(i32, pairs[i][1]))));
        i = (i + 1);
    }
    return res.items;
}

fn encrypt(polybius: []const []const u8, key: []const u8, plainText: []const u8) []const u8 {
    var temp = ""; // []const u8
    var i = 0; // i32
    while (i < @as(i32, @intCast((plainText).len))) {
        var r = 0; // i32
        while (r < 6) {
            var c = 0; // i32
            while (c < 6) {
                if (polybius[r][c] == plainText[i]) {
                    temp = _concat_string(_concat_string(temp, adfgvx[r]), adfgvx[c]);
                }
                c = (c + 1);
            }
            r = (r + 1);
        }
        i = (i + 1);
    }
    var colLen = (@as(i32, @intCast((temp).len)) / @as(i32, @intCast((key).len))); // f64
    if (@mod(@as(i32, @intCast((temp).len)), @as(i32, @intCast((key).len))) > 0) {
        colLen = (colLen + 1);
    }
    var table = std.ArrayList([]const u8).init(std.heap.page_allocator);
    var rIdx = 0; // i32
    while (rIdx < colLen) {
        var row = std.ArrayList(u8).init(std.heap.page_allocator);
        var j = 0; // i32
        while (j < @as(i32, @intCast((key).len))) {
            try row.append(@as(i32,@intCast("")));
            j = (j + 1);
        }
        try table.append(@as(i32,@intCast(row)));
        rIdx = (rIdx + 1);
    }
    var idx = 0; // i32
    while (idx < @as(i32, @intCast((temp).len))) {
        const row = (idx / @as(i32, @intCast((key).len))); // f64
        const col = @mod(idx, @as(i32, @intCast((key).len))); // i32
        table.items[row][col] = _slice_string(temp, idx, (idx + 1), 1);
        idx = (idx + 1);
    }
    const order = orderKey(key); // []const i32
    var cols = std.ArrayList(u8).init(std.heap.page_allocator);
    var ci = 0; // i32
    while (ci < @as(i32, @intCast((key).len))) {
        var colStr = ""; // []const u8
        var ri = 0; // i32
        while (ri < colLen) {
            colStr = _concat_string(colStr, table[ri][order[ci]]);
            ri = (ri + 1);
        }
        try cols.append(@as(i32,@intCast(colStr)));
        ci = (ci + 1);
    }
    var result = ""; // []const u8
    ci = 0;
    while (ci < @as(i32, @intCast((cols).len))) {
        result = _concat_string(result, cols[ci]);
        if (ci < (@as(i32, @intCast((cols).len)) - 1)) {
            result = _concat_string(result, " ");
        }
        ci = (ci + 1);
    }
    return result;
}

fn indexOf(s: []const u8, ch: []const u8) i32 {
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        if (std.mem.eql(u8, s[i], ch)) {
            return i;
        }
        i = (i + 1);
    }
    return -1;
}

fn decrypt(polybius: []const []const u8, key: []const u8, cipherText: []const u8) []const u8 {
    var colStrs = std.ArrayList(u8).init(std.heap.page_allocator);
    var start = 0; // i32
    var i = 0; // i32
    while (i <= @as(i32, @intCast((cipherText).len))) {
        if ((i == @as(i32, @intCast((cipherText).len))) or std.mem.eql(u8, cipherText[i], " ")) {
            try colStrs.append(@as(i32,@intCast(_slice_string(cipherText, start, i, 1))));
            start = (i + 1);
        }
        i = (i + 1);
    }
    var maxColLen = 0; // i32
    i = 0;
    while (i < @as(i32, @intCast((colStrs).len))) {
        if (@as(i32, @intCast((colStrs[i]).len)) > maxColLen) {
            maxColLen = @as(i32, @intCast((colStrs[i]).len));
        }
        i = (i + 1);
    }
    var cols = std.ArrayList([]const u8).init(std.heap.page_allocator);
    i = 0;
    while (i < @as(i32, @intCast((colStrs).len))) {
        var s = colStrs[i]; // []const u8
        var ls = std.ArrayList(u8).init(std.heap.page_allocator);
        var j = 0; // i32
        while (j < @as(i32, @intCast((s).len))) {
            try ls.append(@as(i32,@intCast(s[j])));
            j = (j + 1);
        }
        if (@as(i32, @intCast((s).len)) < maxColLen) {
            var pad = std.ArrayList(u8).init(std.heap.page_allocator);
            var k = 0; // i32
            while (k < maxColLen) {
                if (k < @as(i32, @intCast((ls).len))) {
                    try pad.append(@as(i32,@intCast(ls[k])));
                } else {
                    try pad.append(@as(i32,@intCast("")));
                }
                k = (k + 1);
            }
            try cols.append(@as(i32,@intCast(pad)));
        } else {
            try cols.append(@as(i32,@intCast(ls)));
        }
        i = (i + 1);
    }
    var table = std.ArrayList([]const u8).init(std.heap.page_allocator);
    var r = 0; // i32
    while (r < maxColLen) {
        var row = std.ArrayList(u8).init(std.heap.page_allocator);
        var c = 0; // i32
        while (c < @as(i32, @intCast((key).len))) {
            try row.append(@as(i32,@intCast("")));
            c = (c + 1);
        }
        try table.append(@as(i32,@intCast(row)));
        r = (r + 1);
    }
    const order = orderKey(key); // []const i32
    r = 0;
    while (r < maxColLen) {
        var c = 0; // i32
        while (c < @as(i32, @intCast((key).len))) {
            table.items[r][order[c]] = cols[c][r];
            c = (c + 1);
        }
        r = (r + 1);
    }
    var temp = ""; // []const u8
    r = 0;
    while (r < @as(i32, @intCast((table).len))) {
        var j = 0; // i32
        while (j < @as(i32, @intCast((table[r]).len))) {
            temp = _concat_string(temp, table[r][j]);
            j = (j + 1);
        }
        r = (r + 1);
    }
    var plainText = ""; // []const u8
    var idx = 0; // i32
    while (idx < @as(i32, @intCast((temp).len))) {
        const rIdx = indexOf(adfgvx, _slice_string(temp, idx, (idx + 1), 1)); // i32
        const cIdx = indexOf(adfgvx, _slice_string(temp, (idx + 1), (idx + 2), 1)); // i32
        plainText = _concat_string(plainText, polybius[rIdx][cIdx]);
        idx = (idx + 2);
    }
    return plainText;
}

fn user_main() void {
    const plainText = "ATTACKAT1200AM"; // []const u8
    const polybius = createPolybius(); // []const []const u8
    const key = createKey(9); // []const u8
    std.debug.print("{s}\n", .{_concat_string("\nPlaintext : ", plainText)});
    const cipherText = encrypt(polybius, key, plainText); // []const u8
    std.debug.print("{s}\n", .{_concat_string("\nEncrypted : ", cipherText)});
    const plainText2 = decrypt(polybius, key, cipherText); // []const u8
    std.debug.print("{s}\n", .{_concat_string("\nDecrypted : ", plainText2)});
}

pub fn main() void {
    user_main();
}
