// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

const Map0 = struct {
    seq: []i64,
    aliquot: []const u8,
};

const Map1 = struct {
    seq: []i64,
    aliquot: []const u8,
};

const THRESHOLD: i64 = 140737488355328;

fn indexOf(xs: []i64, value: i64) i64 {
    var i: i64 = 0;
    while (i < std.mem.len(xs)) {
        if (xs[@as(usize, @intCast(i))] == value) {
            return i;
        }
        i = i + 1;
    }
    return 0 - 1;
}

fn contains(xs: []i64, value: i64) bool {
    return indexOf(xs, value) != 0 - 1;
}

fn maxOf(a: i64, b: i64) i64 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}

fn intSqrt(n: i64) i64 {
    if (n == 0) {
        return 0;
    }
    var x: i64 = n;
    var y: i64 = x + 1 / 2;
    while (y < x) {
        x = y;
        y = x + n / x / 2;
    }
    return x;
}

fn sumProperDivisors(n: i64) i64 {
    if (n < 2) {
        return 0;
    }
    const sqrt: i64 = intSqrt(n);
    var sum: i64 = 1;
    var i: i64 = 2;
    while (i <= sqrt) {
        if (@mod(n, i) == 0) {
            sum = sum + i + n / i;
        }
        i = i + 1;
    }
    if (sqrt * sqrt == n) {
        sum = sum - sqrt;
    }
    return sum;
}

fn classifySequence(k: i64) i64 {
    var last: i64 = k;
    var seq: []i64 = @constCast(&[_]i64{k})[0..];
    while (true) {
        last = sumProperDivisors(last);
        seq = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(seq) catch unreachable; _tmp.append(last) catch unreachable; const res = _tmp.toOwnedSlice() catch unreachable; break :blk res; };
        const n: i64 = std.mem.len(seq);
        var aliquot: []const u8 = "";
        if (last == 0) {
            aliquot = "Terminating";
        } else {
            if (n == 2 and last == k) {
                aliquot = "Perfect";
            } else {
                if (n == 3 and last == k) {
                    aliquot = "Amicable";
                } else {
                    if (n >= 4 and last == k) {
                        aliquot = _concat_string(_concat_string("Sociable[", _str(n - 1)), "]");
                    } else {
                        if (last == seq[@as(usize, @intCast(n - 2))]) {
                            aliquot = "Aspiring";
                        } else {
                            if (std.mem.indexOf(u8, seq[1..maxOf(1, n - 2)], last) != null) {
                                const idx: i64 = indexOf(seq, last);
                                aliquot = _concat_string(_concat_string("Cyclic[", _str(n - 1 - idx)), "]");
                            } else {
                                if (n == 16 or last > THRESHOLD) {
                                    aliquot = "Non-Terminating";
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!std.mem.eql(u8, aliquot, "")) {
            return .{ .seq = seq, .aliquot = aliquot };
        }
    }
    return .{ .seq = seq, .aliquot = "" };
}

fn padLeft(n: i64, w: i64) []const u8 {
    var s: []i64 = _str(n);
    while (std.mem.len(s) < w) {
        s = _concat_string(" ", s);
    }
    return s;
}

fn padRight(s: []const u8, w: i64) []const u8 {
    var r: i64 = s;
    while (std.mem.len(r) < w) {
        r = _concat_string(r, " ");
    }
    return r;
}

fn joinWithCommas(seq: []i64) []const u8 {
    var s: []i64 = "[";
    var i: i64 = 0;
    while (i < std.mem.len(seq)) {
        s = _concat_string(s, _str(seq[@as(usize, @intCast(i))]));
        if (i < std.mem.len(seq) - 1) {
            s = _concat_string(s, ", ");
        }
        i = i + 1;
    }
    s = _concat_string(s, "]");
    return s;
}

fn mochi_main() void {
    std.io.getStdOut().writer().print("{s}\n", .{"Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n"}) catch unreachable;
    var k: i64 = 1;
    while (k <= 10) {
        const res: i64 = classifySequence(k);
        std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(padLeft(k, 2), ": "), padRight(res[@as(usize, @intCast("aliquot"))], 15)), " "), joinWithCommas(res[@as(usize, @intCast("seq"))]))}) catch unreachable;
        k = k + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{""}) catch unreachable;
    const s: []i64 = @constCast(&[_]i64{11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488})[0..];
    var i: i64 = 0;
    while (i < std.mem.len(s)) {
        const val: i64 = s[@as(usize, @intCast(i))];
        const res: i64 = classifySequence(val);
        std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(padLeft(val, 7), ": "), padRight(res[@as(usize, @intCast("aliquot"))], 15)), " "), joinWithCommas(res[@as(usize, @intCast("seq"))]))}) catch unreachable;
        i = i + 1;
    }
    std.io.getStdOut().writer().print("{s}\n", .{""}) catch unreachable;
    const big: i64 = 15355717786080;
    const r: i64 = classifySequence(big);
    std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_str(big), ": "), padRight(r[@as(usize, @intCast("aliquot"))], 15)), " "), joinWithCommas(r[@as(usize, @intCast("seq"))]))}) catch unreachable;
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}
