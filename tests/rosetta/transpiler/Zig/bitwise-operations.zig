// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:17Z
const std = @import("std");

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

fn toUnsigned16(n: i32) i32 {
    var u = n; // i32
    if (u < 0) {
        u = (u + 65536);
    }
    return @mod(u, 65536);
}

fn bin16(n: i32) []const u8 {
    var u = toUnsigned16(n); // i32
    var bits = ""; // []const u8
    var mask = 32768; // i32
    for (0 .. 16) |i| {
        if (u >= mask) {
            bits = _concat_string(bits, "1");
            u = (u - mask);
        } else {
            bits = _concat_string(bits, "0");
        }
        mask = @as(i32, ((mask / 2)));
    }
    return bits;
}

fn bit_and(a: i32, b: i32) i32 {
    var ua = toUnsigned16(a); // i32
    var ub = toUnsigned16(b); // i32
    var res = 0; // i32
    var bit = 1; // i32
    for (0 .. 16) |i| {
        if ((@mod(ua, 2) == 1) and (@mod(ub, 2) == 1)) {
            res = (res + bit);
        }
        ua = @as(i32, ((ua / 2)));
        ub = @as(i32, ((ub / 2)));
        bit = (bit * 2);
    }
    return res;
}

fn bit_or(a: i32, b: i32) i32 {
    var ua = toUnsigned16(a); // i32
    var ub = toUnsigned16(b); // i32
    var res = 0; // i32
    var bit = 1; // i32
    for (0 .. 16) |i| {
        if ((@mod(ua, 2) == 1) or (@mod(ub, 2) == 1)) {
            res = (res + bit);
        }
        ua = @as(i32, ((ua / 2)));
        ub = @as(i32, ((ub / 2)));
        bit = (bit * 2);
    }
    return res;
}

fn bit_xor(a: i32, b: i32) i32 {
    var ua = toUnsigned16(a); // i32
    var ub = toUnsigned16(b); // i32
    var res = 0; // i32
    var bit = 1; // i32
    for (0 .. 16) |i| {
        const abit = @mod(ua, 2); // i32
        const bbit = @mod(ub, 2); // i32
        if ((((abit == 1) and (bbit == 0))) or (((abit == 0) and (bbit == 1)))) {
            res = (res + bit);
        }
        ua = @as(i32, ((ua / 2)));
        ub = @as(i32, ((ub / 2)));
        bit = (bit * 2);
    }
    return res;
}

fn bit_not(a: i32) i32 {
    var ua = toUnsigned16(a); // i32
    return (65535 - ua);
}

fn shl(a: i32, b: i32) i32 {
    var ua = toUnsigned16(a); // i32
    var i = 0; // i32
    while (i < b) {
        ua = @mod(((ua * 2)), 65536);
        i = (i + 1);
    }
    return ua;
}

fn shr(a: i32, b: i32) i32 {
    var ua = toUnsigned16(a); // i32
    var i = 0; // i32
    while (i < b) {
        ua = @as(i32, ((ua / 2)));
        i = (i + 1);
    }
    return ua;
}

fn las(a: i32, b: i32) i32 {
    return shl(a, b);
}

fn ras(a: i32, b: i32) i32 {
    var val = a; // i32
    var i = 0; // i32
    while (i < b) {
        if (val >= 0) {
            val = @as(i32, ((val / 2)));
        } else {
            val = @as(i32, ((((val - 1)) / 2)));
        }
        i = (i + 1);
    }
    return toUnsigned16(val);
}

fn rol(a: i32, b: i32) i32 {
    var ua = toUnsigned16(a); // i32
    const left = shl(ua, b); // i32
    const right = shr(ua, (16 - b)); // i32
    return toUnsigned16((left + right));
}

fn ror(a: i32, b: i32) i32 {
    var ua = toUnsigned16(a); // i32
    const right = shr(ua, b); // i32
    const left = shl(ua, (16 - b)); // i32
    return toUnsigned16((left + right));
}

fn bitwise(a: i32, b: i32) void {
    std.debug.print("{s}\n", .{_concat_string("a:   ", bin16(a))});
    std.debug.print("{s}\n", .{_concat_string("b:   ", bin16(b))});
    std.debug.print("{s}\n", .{_concat_string("and: ", bin16(bit_and(a, b)))});
    std.debug.print("{s}\n", .{_concat_string("or:  ", bin16(bit_or(a, b)))});
    std.debug.print("{s}\n", .{_concat_string("xor: ", bin16(bit_xor(a, b)))});
    std.debug.print("{s}\n", .{_concat_string("not: ", bin16(bit_not(a)))});
    if (b < 0) {
        std.debug.print("Right operand is negative, but all shifts require an unsigned right operand (shift distance).\n", .{});
        return 0;
    }
    std.debug.print("{s}\n", .{_concat_string("shl: ", bin16(shl(a, b)))});
    std.debug.print("{s}\n", .{_concat_string("shr: ", bin16(shr(a, b)))});
    std.debug.print("{s}\n", .{_concat_string("las: ", bin16(las(a, b)))});
    std.debug.print("{s}\n", .{_concat_string("ras: ", bin16(ras(a, b)))});
    std.debug.print("{s}\n", .{_concat_string("rol: ", bin16(rol(a, b)))});
    std.debug.print("{s}\n", .{_concat_string("ror: ", bin16(ror(a, b)))});
}

pub fn main() void {
    bitwise(-460, 6);
}
