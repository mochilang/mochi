// Generated by Mochi Zig transpiler on 2025-08-04 17:00 +0700
const std = @import("std");
const Value = union(enum) { Int: i64, Str: []const u8, Bool: bool, };

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

const stx_var: []const u8 = "\x02";
const etx_var: []const u8 = "\x03";

fn contains(s: []const u8, ch: []const u8) bool {
    var i: i64 = 0;
    while (i < @as(i64, @intCast(s.len))) {
        if (std.mem.eql(u8, s[@intCast(i)..@intCast(i + 1)], ch)) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

fn sortStrings(xs: [][]const u8) [][]const u8 {
    var arr: [][]const u8 = blk: { const tmp = std.heap.page_allocator.alloc([]const u8, xs.len) catch unreachable; @memcpy(tmp, xs); break :blk tmp; };
    const n: i64 = @as(i64, @intCast(arr.len));
    var i_1: i64 = 0;
    while (i_1 < n) {
        var j: i64 = 0;
        while (j < n - 1) {
            if (std.mem.order(u8, arr[@intCast(j)], arr[@intCast(j + 1)]) == .gt) {
                const tmp: []const u8 = arr[@intCast(j)];
                arr[@intCast(j)] = arr[@intCast(j + 1)];
                arr[@intCast(j + 1)] = tmp;
            }
            j = j + 1;
        }
        i_1 = i_1 + 1;
    }
    return arr;
}

fn bwt(s_param: []const u8) std.StringHashMap(Value) {
    var s_var: []const u8 = s_param;
    if (std.mem.indexOf(u8, s_var, stx_var) != null or std.mem.indexOf(u8, s_var, etx_var) != null) {
        return blk: { var m = std.StringHashMap(Value).init(std.heap.page_allocator); m.put("err", Value{.Bool = true}) catch unreachable; m.put("res", Value{.Str = ""}) catch unreachable; break :blk m; };
    }
    s_var = _concat_string(_concat_string(stx_var, s_var), etx_var);
    const le: i64 = @as(i64, @intCast(s_var.len));
    var table: [][]const u8 = &[_][]const u8{};
    var i_2: i64 = 0;
    while (i_2 < le) {
        const rot: []const u8 = _concat_string(s_var[@intCast(i_2)..@intCast(le)], s_var[@intCast(0)..@intCast(i_2)]);
        table = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, table)) catch |err| handleError(err); _tmp.append(rot) catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i_2 = i_2 + 1;
    }
    table = sortStrings(table);
    var last: []const u8 = "";
    i_2 = 0;
    while (i_2 < le) {
        last = _concat_string(last, table[@intCast(i_2)][@intCast(le - 1)..@intCast(le)]);
        i_2 = i_2 + 1;
    }
    return blk: { var m = std.StringHashMap(Value).init(std.heap.page_allocator); m.put("err", Value{.Bool = false}) catch unreachable; m.put("res", Value{.Str = last}) catch unreachable; break :blk m; };
}

fn ibwt(r: []const u8) []const u8 {
    const le_1: i64 = @as(i64, @intCast(r.len));
    var table_1: [][]const u8 = &[_][]const u8{};
    var i_3: i64 = 0;
    while (i_3 < le_1) {
        table_1 = blk: { var _tmp = std.ArrayList([]const u8).init(std.heap.page_allocator); _tmp.appendSlice(@as([]const []const u8, table_1)) catch |err| handleError(err); _tmp.append("") catch |err| handleError(err); break :blk (_tmp.toOwnedSlice() catch |err| handleError(err)); };
        i_3 = i_3 + 1;
    }
    var n_1: i64 = 0;
    while (n_1 < le_1) {
        i_3 = 0;
        while (i_3 < le_1) {
            table_1[@intCast(i_3)] = _concat_string(r[@intCast(i_3)..@intCast(i_3 + 1)], table_1[@intCast(i_3)]);
            i_3 = i_3 + 1;
        }
        table_1 = sortStrings(table_1);
        n_1 = n_1 + 1;
    }
    i_3 = 0;
    while (i_3 < le_1) {
        if (std.mem.eql(u8, table_1[@intCast(i_3)][@intCast(le_1 - 1)..@intCast(le_1)], etx_var)) {
            return table_1[@intCast(i_3)][@intCast(1)..@intCast(le_1 - 1)];
        }
        i_3 = i_3 + 1;
    }
    return "";
}

fn makePrintable(s: []const u8) []const u8 {
    var out: []const u8 = "";
    var i_4: i64 = 0;
    while (i_4 < @as(i64, @intCast(s.len))) {
        const ch: []const u8 = s[@intCast(i_4)..@intCast(i_4 + 1)];
        if (std.mem.eql(u8, ch, stx_var)) {
            out = _concat_string(out, "^");
        } else {
            if (std.mem.eql(u8, ch, etx_var)) {
                out = _concat_string(out, "|");
            } else {
                out = _concat_string(out, ch);
            }
        }
        i_4 = i_4 + 1;
    }
    return out;
}

fn mochi_main() void {
    const examples: [][]const u8 = blk0: { var _tmp0 = std.heap.page_allocator.alloc([]const u8, 6) catch unreachable; _tmp0[0] = "banana"; _tmp0[1] = "appellee"; _tmp0[2] = "dogwood"; _tmp0[3] = "TO BE OR NOT TO BE OR WANT TO BE OR NOT?"; _tmp0[4] = "SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES"; _tmp0[5] = "\x02ABC\x03"; break :blk0 _tmp0; };
    for (examples) |__it0| {
        const t = __it0;
        std.debug.print("{s}\n", .{makePrintable(t)});
        var res: std.StringHashMap(Value) = bwt(t);
        if (res.get("err").?.Bool) {
            std.debug.print("{s}\n", .{" --> ERROR: String can't contain STX or ETX"});
            std.debug.print("{s}\n", .{" -->"});
        } else {
            const enc: []const u8 = res.get("res").?.Str;
            std.debug.print("{s}\n", .{_concat_string(" --> ", makePrintable(enc))});
            const r: []const u8 = ibwt(enc);
            std.debug.print("{s}\n", .{_concat_string(" --> ", r)});
        }
        std.debug.print("{s}\n", .{""});
    }
}

pub fn main() void {
    mochi_main();
}

fn _concat_string(lhs: []const u8, rhs: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    var out = alloc.alloc(u8, lhs.len + rhs.len + 1) catch unreachable;
    std.mem.copyForwards(u8, out[0..lhs.len], lhs);
    std.mem.copyForwards(u8, out[lhs.len..lhs.len + rhs.len], rhs);
    out[lhs.len + rhs.len] = 0;
    return out[0..lhs.len + rhs.len];
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
