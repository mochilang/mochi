// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:19Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _slice_string(s: []const u8, start: i32, end: i32, step: i32) []const u8 {
    var sidx = start;
    var eidx = end;
    var stp = step;
    const n: i32 = @as(i32, @intCast(s.len));
    if (sidx < 0) sidx += n;
    if (eidx < 0) eidx += n;
    if (stp == 0) stp = 1;
    if (sidx < 0) sidx = 0;
    if (eidx > n) eidx = n;
    if (stp > 0 and eidx < sidx) eidx = sidx;
    if (stp < 0 and eidx > sidx) eidx = sidx;
    var res = std.ArrayList(u8).init(std.heap.page_allocator);
    defer res.deinit();
    var i: i32 = sidx;
    while ((stp > 0 and i < eidx) or (stp < 0 and i > eidx)) : (i += stp) {
        res.append(s[@as(usize, @intCast(i))]) catch |err| handleError(err);
    }
    return res.toOwnedSlice() catch |err| handleError(err);
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const stx = "\x02"; // []const u8
const etx = "\x03"; // []const u8

fn contains(s: []const u8, ch: []const u8) bool {
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        if (std.mem.eql(u8, _slice_string(s, i, (i + 1), 1), ch)) {
            return true;
        }
        i = (i + 1);
    }
    return false;
}

fn sortStrings(xs: []const []const u8) []const []const u8 {
    var arr = xs; // []const []const u8
    var n = @as(i32, @intCast((arr).len)); // i32
    var i = 0; // i32
    while (i < n) {
        var j = 0; // i32
        while (j < (n - 1)) {
            if (arr[j] > arr[(j + 1)]) {
                const tmp = arr[j]; // []const u8
                arr.items[j] = arr[(j + 1)];
                arr.items[(j + 1)] = tmp;
            }
            j = (j + 1);
        }
        i = (i + 1);
    }
    return arr.items;
}

fn bwt(s: []const u8) std.AutoHashMap([]const u8, i32) {
    if (contains(s, stx) or contains(s, etx)) {
        return struct {
    err: bool,
    res: []const u8,
}{
    .err = true,
    .res = "",
};
    }
    s = _concat_string(_concat_string(stx, s), etx);
    const le = @as(i32, @intCast((s).len)); // i32
    var table = std.ArrayList(u8).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < le) {
        const rot = (_slice_string(s, i, le, 1) + s[0..@as(usize, @intCast(i))]); // []const u8
        table = blk0: { var _tmp0 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(table) catch |err| handleError(err); _tmp0.append(rot) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
        i = (i + 1);
    }
    table = sortStrings(table);
    var last = ""; // []const u8
    i = 0;
    while (i < le) {
        last = _concat_string(last, _slice_string(table[i], (le - 1), le, 1));
        i = (i + 1);
    }
    return struct {
    err: bool,
    res: []const u8,
}{
    .err = false,
    .res = last,
};
}

fn ibwt(r: []const u8) []const u8 {
    const le = @as(i32, @intCast((r).len)); // i32
    var table = std.ArrayList(u8).init(std.heap.page_allocator);
    var i = 0; // i32
    while (i < le) {
        table = blk1: { var _tmp1 = std.ArrayList([]const u8).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(table) catch |err| handleError(err); _tmp1.append("") catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
        i = (i + 1);
    }
    var n = 0; // i32
    while (n < le) {
        i = 0;
        while (i < le) {
            table.items[i] = (_slice_string(r, i, (i + 1), 1) + table[i]);
            i = (i + 1);
        }
        table = sortStrings(table);
        n = (n + 1);
    }
    i = 0;
    while (i < le) {
        if (std.mem.eql(u8, _slice_string(table[i], (le - 1), le, 1), etx)) {
            return table[i][1..@as(usize, @intCast(le - 1))];
        }
        i = (i + 1);
    }
    return "";
}

fn makePrintable(s: []const u8) []const u8 {
    var out = ""; // []const u8
    var i = 0; // i32
    while (i < @as(i32, @intCast((s).len))) {
        const ch = _slice_string(s, i, (i + 1), 1); // []const u8
        if (std.mem.eql(u8, ch, stx)) {
            out = _concat_string(out, "^");
        } else         if (std.mem.eql(u8, ch, etx)) {
            out = _concat_string(out, "|");
        } else {
            out = _concat_string(out, ch);
        }
        i = (i + 1);
    }
    return out;
}

fn user_main() void {
    const examples = &[_][]const u8{
    "banana",
    "appellee",
    "dogwood",
    "TO BE OR NOT TO BE OR WANT TO BE OR NOT?",
    "SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES",
    "\x02ABC\x03",
}; // []const []const u8
    for (examples) |t| {
        std.debug.print("{s}\n", .{makePrintable(t)});
        const res = bwt(t); // std.StringHashMap(i32)
        if (res["err"]) {
            std.debug.print(" --> ERROR: String can't contain STX or ETX\n", .{});
            std.debug.print(" -->\n", .{});
        } else {
            const enc = @as([]const u8, res["res"]); // []const u8
            std.debug.print("{s}\n", .{_concat_string(" --> ", makePrintable(enc))});
            const r = ibwt(enc); // []const u8
            std.debug.print("{s}\n", .{_concat_string(" --> ", r)});
        }
        std.debug.print("\n", .{});
    }
}

pub fn main() void {
    user_main();
}
