// Generated by Mochi Zig transpiler on 2025-08-02 20:52 +0700
const std = @import("std");

var arr1_var: [5]i64 = [5]i64{2, 7, 1, 8, 2};
var counts1_var: std.AutoHashMap(i64,i64) = blk: { const m = std.AutoHashMap(i64, i64).init(std.heap.page_allocator); break :blk m; };
var keys1_var: []i64 = &[_]i64{};
var i_var: i64 = 0;
var max1_var: i64 = 0;
var modes1_var: []i64 = &[_]i64{};
var arr2_var: [6]i64 = [6]i64{2, 7, 1, 8, 2, 8};
var counts2_var: std.AutoHashMap(i64,i64) = blk: { const m = std.AutoHashMap(i64, i64).init(std.heap.page_allocator); break :blk m; };
var keys2_var: []i64 = &[_]i64{};
var max2_var: i64 = 0;
var modes2_var: []i64 = &[_]i64{};

pub fn main() void {
    while (i_var < @as(i64, @intCast(arr1_var.len))) {
        const v: i64 = arr1_var[@intCast(i_var)];
        if (counts1_var.contains(v)) {
            counts1_var.put(v, counts1_var.get(v).? + 1) catch unreachable;
        } else {
            counts1_var.put(v, 1) catch unreachable;
            keys1_var = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(keys1_var) catch unreachable; _tmp.append(v) catch unreachable; const _res = _tmp.toOwnedSlice() catch unreachable; break :blk _res; };
        }
        i_var = i_var + 1;
    }
    i_var = 0;
    while (i_var < @as(i64, @intCast(keys1_var.len))) {
        const k: i64 = keys1_var[@intCast(i_var)];
        const c: i64 = counts1_var.get(k).?;
        if (c > max1_var) {
            max1_var = c;
        }
        i_var = i_var + 1;
    }
    i_var = 0;
    while (i_var < @as(i64, @intCast(keys1_var.len))) {
        const k: i64 = keys1_var[@intCast(i_var)];
        if (counts1_var.get(k).? == max1_var) {
            modes1_var = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(modes1_var) catch unreachable; _tmp.append(k) catch unreachable; const _res = _tmp.toOwnedSlice() catch unreachable; break :blk _res; };
        }
        i_var = i_var + 1;
    }
    std.debug.print("{s}\n", .{_str(modes1_var)});
    i_var = 0;
    while (i_var < @as(i64, @intCast(arr2_var.len))) {
        const v: i64 = arr2_var[@intCast(i_var)];
        if (counts2_var.contains(v)) {
            counts2_var.put(v, counts2_var.get(v).? + 1) catch unreachable;
        } else {
            counts2_var.put(v, 1) catch unreachable;
            keys2_var = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(keys2_var) catch unreachable; _tmp.append(v) catch unreachable; const _res = _tmp.toOwnedSlice() catch unreachable; break :blk _res; };
        }
        i_var = i_var + 1;
    }
    i_var = 0;
    while (i_var < @as(i64, @intCast(keys2_var.len))) {
        const k: i64 = keys2_var[@intCast(i_var)];
        const c: i64 = counts2_var.get(k).?;
        if (c > max2_var) {
            max2_var = c;
        }
        i_var = i_var + 1;
    }
    i_var = 0;
    while (i_var < @as(i64, @intCast(keys2_var.len))) {
        const k: i64 = keys2_var[@intCast(i_var)];
        if (counts2_var.get(k).? == max2_var) {
            modes2_var = blk: { var _tmp = std.ArrayList(i64).init(std.heap.page_allocator); defer _tmp.deinit(); _tmp.appendSlice(modes2_var) catch unreachable; _tmp.append(k) catch unreachable; const _res = _tmp.toOwnedSlice() catch unreachable; break :blk _res; };
        }
        i_var = i_var + 1;
    }
    std.debug.print("{s}\n", .{_str(modes2_var)});
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _print(v: []const u8) void {
    std.debug.print("{s}\n", .{v});
}
