// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:01:17Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

const Pixel = struct {
    R: i32,
    G: i32,
    B: i32,
};

const Bitmap = struct {
    cols: i32,
    rows: i32,
    px: []const []const Pixel,
};

fn pixelFromRgb(c: i32) Pixel {
    const r = @mod((@as(i32, ((c / 65536)))), 256); // i32
    const g = @mod((@as(i32, ((c / 256)))), 256); // i32
    const b = @mod(c, 256); // i32
    return Pixel{
    .R = r,
    .G = g,
    .B = b,
};
}

fn rgbFromPixel(p: *Pixel) i32 {
    return (((p.R * 65536) + (p.G * 256)) + p.B);
}

fn NewBitmap(x: i32, y: i32) Bitmap {
    var data = std.ArrayList(Pixel).init(std.heap.page_allocator);
    var row = 0; // i32
    while (row < y) {
        var r = std.ArrayList(Pixel).init(std.heap.page_allocator);
        var col = 0; // i32
        while (col < x) {
            r = blk0: { var _tmp0 = std.ArrayList(Pixel).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(r) catch |err| handleError(err); _tmp0.append(Pixel{
    .R = 0,
    .G = 0,
    .B = 0,
}) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
            col = (col + 1);
        }
        data = blk1: { var _tmp1 = std.ArrayList([]const Pixel).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(data) catch |err| handleError(err); _tmp1.append(r) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
        row = (row + 1);
    }
    return Bitmap{
    .cols = x,
    .rows = y,
    .px = data,
};
}

fn Extent(b: *Bitmap) std.AutoHashMap([]const u8, i32) {
    return struct {
    cols: i32,
    rows: i32,
}{
    .cols = b.cols,
    .rows = b.rows,
};
}

fn Fill(b: *Bitmap, p: *Pixel) void {
    var y = 0; // i32
    while (y < b.rows) {
        var x = 0; // i32
        while (x < b.cols) {
            var px = b.px; // []const []const Pixel
            var row = px[y]; // []const Pixel
            row.items[x] = p;
            px.items[y] = row;
            b.px = px;
            x = (x + 1);
        }
        y = (y + 1);
    }
}

fn FillRgb(b: *Bitmap, c: i32) void {
    Fill(&b, &pixelFromRgb(c));
}

fn SetPx(b: *Bitmap, x: i32, y: i32, p: *Pixel) bool {
    if ((((x < 0) or (x >= b.cols)) or (y < 0)) or (y >= b.rows)) {
        return false;
    }
    var px = b.px; // []const []const Pixel
    var row = px[y]; // []const Pixel
    row.items[x] = p;
    px.items[y] = row;
    b.px = px;
    return true;
}

fn SetPxRgb(b: *Bitmap, x: i32, y: i32, c: i32) bool {
    return SetPx(&b, x, y, &pixelFromRgb(c));
}

fn GetPx(b: *Bitmap, x: i32, y: i32) std.AutoHashMap([]const u8, i32) {
    if ((((x < 0) or (x >= b.cols)) or (y < 0)) or (y >= b.rows)) {
        return struct { ok: bool, }{ .ok = false };
    }
    const row = b.px[y]; // []const Pixel
    return struct {
    ok: bool,
    pixel: Pixel,
}{
    .ok = true,
    .pixel = row[x],
};
}

fn GetPxRgb(b: *Bitmap, x: i32, y: i32) std.AutoHashMap([]const u8, i32) {
    const r = GetPx(&b, x, y); // std.StringHashMap(i32)
    if (!r.ok) {
        return struct { ok: bool, }{ .ok = false };
    }
    return struct {
    ok: bool,
    rgb: i32,
}{
    .ok = true,
    .rgb = rgbFromPixel(&r.pixel),
};
}

fn ppmSize(b: *Bitmap) i32 {
    const header = _concat_string(_concat_string(_concat_string(_concat_string("P6\n# Creator: Rosetta Code http://rosettacode.org/\n", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{b.cols}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{b.rows}) catch |err| handleError(err)), "\n255\n"); // []const u8
    return (@as(i32, @intCast((header).len)) + ((3 * b.cols) * b.rows));
}

fn pixelStr(p: *Pixel) []const u8 {
    return _concat_string(_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("{", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{p.R}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{p.G}) catch |err| handleError(err)), " "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{p.B}) catch |err| handleError(err)), "}");
}

fn user_main() void {
    var bm = NewBitmap(300, 240); // Bitmap
    FillRgb(&bm, 16711680);
    SetPxRgb(&bm, 10, 20, 255);
    SetPxRgb(&bm, 20, 30, 0);
    SetPxRgb(&bm, 30, 40, 1056816);
    const c1 = GetPx(&bm, 0, 0); // std.StringHashMap(i32)
    const c2 = GetPx(&bm, 10, 20); // std.StringHashMap(i32)
    const c3 = GetPx(&bm, 30, 40); // std.StringHashMap(i32)
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string("Image size: ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{bm.cols}) catch |err| handleError(err)), " Ã— "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{bm.rows}) catch |err| handleError(err))});
    std.debug.print("{s}\n", .{_concat_string(std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{ppmSize(&bm)}) catch |err| handleError(err), " bytes when encoded as PPM.")});
    if (c1.ok) {
        std.debug.print("{s}\n", .{_concat_string("Pixel at (0,0) is ", pixelStr(&c1.pixel))});
    }
    if (c2.ok) {
        std.debug.print("{s}\n", .{_concat_string("Pixel at (10,20) is ", pixelStr(&c2.pixel))});
    }
    if (c3.ok) {
        const p: i32 = c3.pixel; // i32
        var r16: i32 = (p.R * 257); // i32
        var g16: i32 = (p.G * 257); // i32
        var b16: i32 = (p.B * 257); // i32
        std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string(_concat_string(_concat_string("Pixel at (30,40) has R=", std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{r16}) catch |err| handleError(err)), ", G="), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{g16}) catch |err| handleError(err)), ", B="), std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{b16}) catch |err| handleError(err))});
    }
}

pub fn main() void {
    user_main();
}
