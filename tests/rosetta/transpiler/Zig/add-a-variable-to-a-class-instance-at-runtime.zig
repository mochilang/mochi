// Generated by Mochi Zig transpiler on 2025-07-24 20:52 +0700
const std = @import("std");

const SomeStruct = struct {
    runtime_fields: i64,
};

const Map1 = struct {
};

fn mochi_main() void {
    var ss: SomeStruct = .{ .runtime_fields = .{  } };
    std.io.getStdOut().writer().print("{s}\n", .{"Create two fields at runtime: \n"}) catch unreachable;
    var i: i64 = 1;
    while (i <= 2) {
        std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string("  Field #", _str(i)), ":\n")}) catch unreachable;
        std.io.getStdOut().writer().print("{s}\n", .{"       Enter name  : "}) catch unreachable;
        const name: i64 = _input();
        std.io.getStdOut().writer().print("{s}\n", .{"       Enter value : "}) catch unreachable;
        const value: i64 = _input();
        var fields: i64 = ss.runtime_fields;
        fields[@as(usize, @intCast(name))] = value;
        ss.runtime_fields = fields;
        std.io.getStdOut().writer().print("{s}\n", .{"\n"}) catch unreachable;
        i = i + 1;
    }
    while (true) {
        std.io.getStdOut().writer().print("{s}\n", .{"Which field do you want to inspect ? "}) catch unreachable;
        const name: i64 = _input();
        if (std.mem.indexOfScalar(i64, ss.runtime_fields, name) != null) {
            const value: i64 = ss.runtime_fields[@as(usize, @intCast(name))];
            std.io.getStdOut().writer().print("{s}\n", .{_concat_string(_concat_string("Its value is '", value), "'")}) catch unreachable;
            return;
        } else {
            std.io.getStdOut().writer().print("{s}\n", .{"There is no field of that name, try again\n"}) catch unreachable;
        }
    }
}

pub fn main() void {
    mochi_main();
}

fn _str(v: anytype) []const u8 {
    if (@TypeOf(v) == f64 or @TypeOf(v) == f32) {
        return std.fmt.allocPrint(std.heap.page_allocator, "{d:.1}", .{v}) catch unreachable;
    }
    return std.fmt.allocPrint(std.heap.page_allocator, "{any}", .{v}) catch unreachable;
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    const alloc = std.heap.page_allocator;
    return std.mem.concat(alloc, u8, &[_][]const u8{ a, b }) catch unreachable;
}

var _in_buf = std.io.bufferedReader(std.io.getStdIn().reader());
fn _input() []const u8 {
    const opt_line = _in_buf.reader().readUntilDelimiterOrEofAlloc(std.heap.page_allocator, '
', 1 << 20) catch return "";
    const line = opt_line orelse return "";
    if (line.len > 0 and line[line.len - 1] == '
') {
        return line[0..line.len-1];
    }
    return line;
}
