// Generated by Mochi compiler v0.10.28 on 2025-07-18T10:00:44Z
const std = @import("std");

fn handleError(err: anyerror) noreturn {
    std.debug.panic("{any}", .{err});
}

fn _concat_string(a: []const u8, b: []const u8) []const u8 {
    return std.mem.concat(u8, &[_][]const u8{ a, b }) catch |err| handleError(err);
}

var a = &[_]i32{
    0,
    0,
    0,
    0,
    0,
}; // []const i32
var s = a[0..4]; // []const i32
var cap_s = 5; // i32

fn listStr(xs: []const i32) []const u8 {
    var s = "["; // []const u8
    var i = 0; // i32
    while (i < @as(i32, @intCast((xs).len))) {
        s = _concat_string(s, std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{xs[i]}) catch |err| handleError(err));
        if ((i + 1) < @as(i32, @intCast((xs).len))) {
            s = _concat_string(s, " ");
        }
        i = (i + 1);
    }
    s = _concat_string(s, "]");
    return s;
}

pub fn main() void {
    std.debug.print("{s}\n", .{_concat_string("len(a) = ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{@as(i32, @intCast((a).len))}) catch |err| handleError(err))});
    std.debug.print("{s}\n", .{_concat_string("a = ", listStr(a))});
    a.items[0] = 3;
    std.debug.print("{s}\n", .{_concat_string("a = ", listStr(a))});
    std.debug.print("{s}\n", .{_concat_string("a[0] = ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{a[0]}) catch |err| handleError(err))});
    std.debug.print("{s}\n", .{_concat_string("s = ", listStr(s))});
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string("len(s) = ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{@as(i32, @intCast((s).len))}) catch |err| handleError(err)), "  cap(s) = "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{cap_s}) catch |err| handleError(err))});
    s = a[0..5];
    std.debug.print("{s}\n", .{_concat_string("s = ", listStr(s))});
    a.items[0] = 22;
    s.items[0] = 22;
    std.debug.print("{s}\n", .{_concat_string("a = ", listStr(a))});
    std.debug.print("{s}\n", .{_concat_string("s = ", listStr(s))});
    s = blk0: { var _tmp0 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp0.deinit(); _tmp0.appendSlice(s) catch |err| handleError(err); _tmp0.append(4) catch |err| handleError(err); const res = _tmp0.toOwnedSlice() catch |err| handleError(err); break :blk0 res; };
    s = blk1: { var _tmp1 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp1.deinit(); _tmp1.appendSlice(s) catch |err| handleError(err); _tmp1.append(5) catch |err| handleError(err); const res = _tmp1.toOwnedSlice() catch |err| handleError(err); break :blk1 res; };
    s = blk2: { var _tmp2 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp2.deinit(); _tmp2.appendSlice(s) catch |err| handleError(err); _tmp2.append(6) catch |err| handleError(err); const res = _tmp2.toOwnedSlice() catch |err| handleError(err); break :blk2 res; };
    cap_s = 10;
    std.debug.print("{s}\n", .{_concat_string("s = ", listStr(s))});
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string("len(s) = ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{@as(i32, @intCast((s).len))}) catch |err| handleError(err)), "  cap(s) = "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{cap_s}) catch |err| handleError(err))});
    a.items[4] = -1;
    std.debug.print("{s}\n", .{_concat_string("a = ", listStr(a))});
    std.debug.print("{s}\n", .{_concat_string("s = ", listStr(s))});
    s = &[]i32{};
    for (0 .. 8) |i| {
        s = blk3: { var _tmp3 = std.ArrayList(i32).init(std.heap.page_allocator); defer _tmp3.deinit(); _tmp3.appendSlice(s) catch |err| handleError(err); _tmp3.append(0) catch |err| handleError(err); const res = _tmp3.toOwnedSlice() catch |err| handleError(err); break :blk3 res; };
    }
    cap_s = 8;
    std.debug.print("{s}\n", .{_concat_string("s = ", listStr(s))});
    std.debug.print("{s}\n", .{_concat_string(_concat_string(_concat_string("len(s) = ", std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{@as(i32, @intCast((s).len))}) catch |err| handleError(err)), "  cap(s) = "), std.fmt.allocPrint(std.heap.page_allocator, "{d}", .{cap_s}) catch |err| handleError(err))});
}
