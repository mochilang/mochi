// Generated by Mochi v0.10.37 on 2025-07-23 13:22:32 GMT+7

function bigTrim(a: number[]): number[] {
  let n: number = (Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length);
  while (((n > 1) && (a[(n - 1)] == 0))) {
    a = a.slice(0, (n - 1));
    n = (n - 1);
  }
  return a;
}
function bigFromInt(x: number): number[] {
  if ((x == 0)) {
    return [0];
  }
  let digits: number[] = [];
  let n: number = x;
  while ((n > 0)) {
    digits = [...digits, (n % 10)];
    n = Math.trunc(n / 10);
  }
  return digits;
}
function bigCmp(a: number[], b: number[]): number {
  if (((Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length) > (Array.isArray(b) || typeof b === 'string' ? b.length : Object.keys(b ?? {}).length))) {
    return 1;
  }
  if (((Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length) < (Array.isArray(b) || typeof b === 'string' ? b.length : Object.keys(b ?? {}).length))) {
    return -1;
  }
  let i: number = ((Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length) - 1);
  while ((i >= 0)) {
    if ((a[i] > b[i])) {
      return 1;
    }
    if ((a[i] < b[i])) {
      return -1;
    }
    i = (i - 1);
  }
  return 0;
}
function bigAdd(a: number[], b: number[]): number[] {
  let res: number[] = [];
  let carry: number = 0;
  let i: number = 0;
  while ((((i < (Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length)) || (i < (Array.isArray(b) || typeof b === 'string' ? b.length : Object.keys(b ?? {}).length))) || (carry > 0))) {
    let av: number = 0;
    if ((i < (Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length))) {
      av = a[i];
    }
    let bv: number = 0;
    if ((i < (Array.isArray(b) || typeof b === 'string' ? b.length : Object.keys(b ?? {}).length))) {
      bv = b[i];
    }
    let s: number = ((av + bv) + carry);
    res = [...res, (s % 10)];
    carry = (s / 10);
    i = (i + 1);
  }
  return bigTrim(res);
}
function bigSub(a: number[], b: number[]): number[] {
  let res: number[] = [];
  let borrow: number = 0;
  let i: number = 0;
  while ((i < (Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length))) {
    let av: number = a[i];
    let bv: number = 0;
    if ((i < (Array.isArray(b) || typeof b === 'string' ? b.length : Object.keys(b ?? {}).length))) {
      bv = b[i];
    }
    let diff: number = ((av - bv) - borrow);
    if ((diff < 0)) {
      diff = (diff + 10);
      borrow = 1;
    } else {
      borrow = 0;
    }
    res = [...res, diff];
    i = (i + 1);
  }
  return bigTrim(res);
}
function bigMulSmall(a: number[], m: number): number[] {
  if ((m == 0)) {
    return [0];
  }
  let res: number[] = [];
  let carry: number = 0;
  let i: number = 0;
  while ((i < (Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length))) {
    let prod: number = ((a[i] * m) + carry);
    res = [...res, (prod % 10)];
    carry = (prod / 10);
    i = (i + 1);
  }
  while ((carry > 0)) {
    res = [...res, (carry % 10)];
    carry = Math.trunc(carry / 10);
  }
  return bigTrim(res);
}
function bigMulBig(a: number[], b: number[]): number[] {
  let res: number[] = [];
  let i: number = 0;
  while ((i < ((Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length) + (Array.isArray(b) || typeof b === 'string' ? b.length : Object.keys(b ?? {}).length)))) {
    res = [...res, 0];
    i = (i + 1);
  }
  i = 0;
  while ((i < (Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length))) {
    let carry: number = 0;
    let j: number = 0;
    while ((j < (Array.isArray(b) || typeof b === 'string' ? b.length : Object.keys(b ?? {}).length))) {
      let idx: number = (i + j);
      let prod: number = ((res[idx] + (a[i] * b[j])) + carry);
      res[idx] = (prod % 10);
      carry = (prod / 10);
      j = (j + 1);
    }
    let idx: number = (i + (Array.isArray(b) || typeof b === 'string' ? b.length : Object.keys(b ?? {}).length));
    while ((carry > 0)) {
      let prod: number = (res[idx] + carry);
      res[idx] = (prod % 10);
      carry = (prod / 10);
      idx = (idx + 1);
    }
    i = (i + 1);
  }
  return bigTrim(res);
}
function bigMulPow10(a: number[], k: number): number[] {
  let i: number = 0;
  while ((i < k)) {
    a = [...[0], ...a];
    i = (i + 1);
  }
  return a;
}
function bigDivSmall(a: number[], m: number): number[] {
  let res: number[] = [];
  let rem: number = 0;
  let i: number = ((Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length) - 1);
  while ((i >= 0)) {
    let cur: number = ((rem * 10) + a[i]);
    let q: number = (cur / m);
    rem = (cur % m);
    res = [...[q], ...res];
    i = (i - 1);
  }
  return bigTrim(res);
}
function bigToString(a: number[]): string {
  let s: string = "";
  let i: number = ((Array.isArray(a) || typeof a === 'string' ? a.length : Object.keys(a ?? {}).length) - 1);
  while ((i >= 0)) {
    s = (s + String(a[i]));
    i = (i - 1);
  }
  return s;
}
function repeat(ch: string, n: number): string {
  let s: string = "";
  let i: number = 0;
  while ((i < n)) {
    s = (s + ch);
    i = (i + 1);
  }
  return s;
}
function sortInts(xs: number[]): number[] {
  let res: number[] = [];
  let tmp: number[] = xs;
  while (((Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length) > 0)) {
    let min = tmp[0];
    let idx: number = 0;
    let i: number = 1;
    while ((i < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
      if ((tmp[i] < min)) {
        min = tmp[i];
        idx = i;
      }
      i = (i + 1);
    }
    res = [...res, min];
    let out: number[] = [];
    let j: number = 0;
    while ((j < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
      if ((j != idx)) {
        out = [...out, tmp[j]];
      }
      j = (j + 1);
    }
    tmp = out;
  }
  return res;
}
function primesUpTo(n: number): number[] {
  let sieve: boolean[] = [];
  let i: number = 0;
  while ((i <= n)) {
    sieve = [...sieve, true];
    i = (i + 1);
  }
  let p: number = 2;
  while (((p * p) <= n)) {
    if (sieve[p]) {
      let m: number = (p * p);
      while ((m <= n)) {
        sieve[m] = false;
        m = (m + p);
      }
    }
    p = (p + 1);
  }
  let res: number[] = [];
  let x: number = 2;
  while ((x <= n)) {
    if (sieve[x]) {
      res = [...res, x];
    }
    x = (x + 1);
  }
  return res;
}
function factorialExp(n: number, primes: number[]): Record<string, number> {
  let m: Record<string, number> = {};
  for (const p of primes) {
    if ((p > n)) {
      break
    }
    let t: number = n;
    let e: number = 0;
    while ((t > 0)) {
      t = (t / p);
      e = (e + t);
    }
    m[String(p)] = e;
  }
  return m;
}
function factorSmall(x: number, primes: number[]): Record<string, number> {
  let f: Record<string, number> = {};
  let n: number = x;
  for (const p of primes) {
    if (((p * p) > n)) {
      break
    }
    let c: number = 0;
    while (((n % p) == 0)) {
      c = (c + 1);
      n = (n / p);
    }
    if ((c > 0)) {
      f[String(p)] = c;
    }
  }
  if ((n > 1)) {
    f[String(n)] = ((f[String(n)] ?? 0) + 1);
  }
  return f;
}
function computeIP(n: number, primes: number[]): number[] {
  let exps: Record<string, number> = factorialExp((6 * n), primes);
  const fn: Record<string, number> = factorialExp(n, primes);
  for (const k in fn) {
    exps[k] = ((exps[k] ?? 0) - (6 * fn[k]));
  }
  exps["2"] = ((exps["2"] ?? 0) + 5);
  const t2: number = ((((532 * n) * n) + (126 * n)) + 9);
  const ft2: Record<string, number> = factorSmall(t2, primes);
  for (const k in ft2) {
    exps[k] = ((exps[k] ?? 0) + ft2[k]);
  }
  exps["3"] = ((exps["3"] ?? 0) - 1);
  let keys: number[] = [];
  for (const k in exps) {
    keys = [...keys, Math.trunc(k)];
  }
  keys = sortInts(keys);
  let res: number[] = bigFromInt(1);
  for (const p of keys) {
    let e = exps[String(p)];
    let i: number = 0;
    while ((i < e)) {
      res = bigMulSmall(res, p);
      i = (i + 1);
    }
  }
  return res;
}
function formatTerm(ip: number[], pw: number): string {
  let s: string = bigToString(ip);
  if ((pw >= (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    let frac: string = (repeat("0", (pw - (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) + s);
    if (((Array.isArray(frac) || typeof frac === 'string' ? frac.length : Object.keys(frac ?? {}).length) < 33)) {
      frac = (frac + repeat("0", (33 - (Array.isArray(frac) || typeof frac === 'string' ? frac.length : Object.keys(frac ?? {}).length))));
    }
    return ("0." + (frac).substring(0, 33));
  }
  let intpart: string = (s).substring(0, ((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) - pw));
  let frac: string = (s).substring(((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) - pw), (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length));
  if (((Array.isArray(frac) || typeof frac === 'string' ? frac.length : Object.keys(frac ?? {}).length) < 33)) {
    frac = (frac + repeat("0", (33 - (Array.isArray(frac) || typeof frac === 'string' ? frac.length : Object.keys(frac ?? {}).length))));
  }
  return ((intpart + ".") + (frac).substring(0, 33));
}
function bigAbsDiff(a: number[], b: number[]): number[] {
  if ((bigCmp(a, b) >= 0)) {
    return bigSub(a, b);
  }
  return bigSub(b, a);
}
function main() {
  const primes: number[] = primesUpTo(2000);
  console.log("N                               Integer Portion  Pow  Nth Term (33 dp)");
  const line: string = repeat("-", 89);
  console.log(line);
  let sum = bigFromInt(0);
  let prev: number[] = bigFromInt(0);
  let denomPow: number = 0;
  let n: number = 0;
  while (true) {
    const ip: number[] = computeIP(n, primes);
    const pw: number = ((6 * n) + 3);
    if ((pw > denomPow)) {
      sum = bigMulPow10(sum, (pw - denomPow));
      prev = bigMulPow10(prev, (pw - denomPow));
      denomPow = pw;
    }
    if ((n < 10)) {
      const termStr: string = formatTerm(ip, pw);
      let ipStr: string = bigToString(ip);
      while (((Array.isArray(ipStr) || typeof ipStr === 'string' ? ipStr.length : Object.keys(ipStr ?? {}).length) < 44)) {
        ipStr = (" " + ipStr);
      }
      let pwStr: string = String(-pw);
      while (((Array.isArray(pwStr) || typeof pwStr === 'string' ? pwStr.length : Object.keys(pwStr ?? {}).length) < 3)) {
        pwStr = (" " + pwStr);
      }
      let padTerm: string = termStr;
      while (((Array.isArray(padTerm) || typeof padTerm === 'string' ? padTerm.length : Object.keys(padTerm ?? {}).length) < 35)) {
        padTerm = (padTerm + " ");
      }
      console.log(((((((String(n) + "  ") + ipStr) + "  ") + pwStr) + "  ") + padTerm));
    }
    sum = bigAdd(sum, ip);
    const diff = bigAbsDiff(sum, prev);
    if (((denomPow >= 70) && (bigCmp(diff, bigMulPow10(bigFromInt(1), (denomPow - 70))) < 0))) {
      break
    }
    prev = sum;
    n = (n + 1);
  }
  const precision: number = 70;
  const target: number[] = bigMulPow10(bigFromInt(1), (denomPow + (2 * precision)));
  let low: number[] = bigFromInt(0);
  let high: number[] = bigMulPow10(bigFromInt(1), (precision + 1));
  while ((bigCmp(low, bigSub(high, bigFromInt(1))) < 0)) {
    let mid: number[] = bigDivSmall(bigAdd(low, high), 2);
    let prod = bigMulBig(bigMulBig(mid, mid), sum);
    if ((bigCmp(prod, target) <= 0)) {
      low = mid;
    } else {
      high = bigSub(mid, bigFromInt(1));
    }
  }
  let piInt: number[] = low;
  let piStr: string = bigToString(piInt);
  if (((Array.isArray(piStr) || typeof piStr === 'string' ? piStr.length : Object.keys(piStr ?? {}).length) <= precision)) {
    piStr = (repeat("0", ((precision - (Array.isArray(piStr) || typeof piStr === 'string' ? piStr.length : Object.keys(piStr ?? {}).length)) + 1)) + piStr);
  }
  let out: string = (((piStr).substring(0, ((Array.isArray(piStr) || typeof piStr === 'string' ? piStr.length : Object.keys(piStr ?? {}).length) - precision)) + ".") + (piStr).substring(((Array.isArray(piStr) || typeof piStr === 'string' ? piStr.length : Object.keys(piStr ?? {}).length) - precision), (Array.isArray(piStr) || typeof piStr === 'string' ? piStr.length : Object.keys(piStr ?? {}).length)));
  console.log("");
  console.log("Pi to 70 decimal places is:");
  console.log(out);
}
main();
