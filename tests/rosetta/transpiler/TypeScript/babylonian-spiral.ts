// Generated by Mochi v0.10.56 on 2025-08-03 17:22:40 GMT+7

function push(h: Record<string, number>[], it: Record<string, number>): Record<string, number>[] {
  h.push(it);
  let i: number = (Number(Array.isArray(h) || typeof h === 'string' ? h.length : Object.keys(h ?? {}).length) - 1);
  while (((i > 0) && (h[Math.trunc((i - 1))].s > h[i].s))) {
    let tmp: Record<string, number> = h[Math.trunc((i - 1))];
    h[(i - 1)] = h[i];
    h[i] = tmp;
    i = (i - 1);
  }
  return h;
}
function step(h: Record<string, number>[], nv: number, dir: number[]): Record<string, any> {
  while (((Number(Array.isArray(h) || typeof h === 'string' ? h.length : Object.keys(h ?? {}).length) == 0) || ((nv * nv) <= h[Math.trunc(0)].s))) {
    h = push(h, {"s": (nv * nv), "a": nv, "b": 0});
    nv = (nv + 1);
  }
  let s: number = h[Math.trunc(0)].s;
  let v: number[][] = [];
  while (((Number(Array.isArray(h) || typeof h === 'string' ? h.length : Object.keys(h ?? {}).length) > 0) && (h[Math.trunc(0)].s == s))) {
    let it: Record<string, number> = h[Math.trunc(0)];
    h = h.slice(1);
    v.push([it.a, it.b]);
    if ((it.a > it.b)) {
      h = push(h, {"s": ((it.a * it.a) + ((it.b + 1) * (it.b + 1))), "a": it.a, "b": (it.b + 1)});
    }
  }
  let list: number[][] = [];
  for (const p of v) {
    list.push(p);
  }
  let temp: number[][] = list;
  for (const p of temp) {
    if ((p[Math.trunc(0)] != p[Math.trunc(1)])) {
      list.push([p[Math.trunc(1)], p[Math.trunc(0)]]);
    }
  }
  temp = list;
  for (const p of temp) {
    if ((p[Math.trunc(1)] != 0)) {
      list.push([p[Math.trunc(0)], -p[Math.trunc(1)]]);
    }
  }
  temp = list;
  for (const p of temp) {
    if ((p[Math.trunc(0)] != 0)) {
      list.push([-p[Math.trunc(0)], p[Math.trunc(1)]]);
    }
  }
  let bestDot: number = -999999999;
  let best: number[] = dir;
  for (const p of list) {
    let cross: number = ((p[Math.trunc(0)] * dir[Math.trunc(1)]) - (p[Math.trunc(1)] * dir[Math.trunc(0)]));
    if ((cross >= 0)) {
      let dot: number = ((p[Math.trunc(0)] * dir[Math.trunc(0)]) + (p[Math.trunc(1)] * dir[Math.trunc(1)]));
      if ((dot > bestDot)) {
        bestDot = dot;
        best = p;
      }
    }
  }
  return {"d": best, "heap": h, "n": nv};
}
function positions(n: number): number[][] {
  let pos: number[][] = [];
  let x: number = 0;
  let y: number = 0;
  let dir: number[] = [0, 1];
  let heap: Record<string, number>[] = [];
  let nv: number = 1;
  let i: number = 0;
  while ((i < n)) {
    pos.push([x, y]);
    let st: Record<string, any> = step(heap, nv, dir);
    dir = st.d;
    heap = st.heap;
    nv = Math.trunc(st.n);
    x = (x + dir[Math.trunc(0)]);
    y = (y + dir[Math.trunc(1)]);
    i = (i + 1);
  }
  return pos;
}
function pad(s: string, w: number): string {
  let r: string = s;
  while ((Number(Array.isArray(r) || typeof r === 'string' ? r.length : Object.keys(r ?? {}).length) < w)) {
    r = (r + " ");
  }
  return r;
}
function main() {
  let pts: number[][] = positions(40);
  console.log(_str("The first 40 Babylonian spiral points are:"));
  let line: string = "";
  let i: number = 0;
  while ((i < Number(Array.isArray(pts) || typeof pts === 'string' ? pts.length : Object.keys(pts ?? {}).length))) {
    let p: number[] = pts[i];
    let s: string = pad((((("(" + _str(p[Math.trunc(0)])) + ", ") + _str(p[Math.trunc(1)])) + ")"), 10);
    line = (line + s);
    if ((((i + 1) % 10) == 0)) {
      console.log(_str(line));
      line = "";
    }
    i = (i + 1);
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

