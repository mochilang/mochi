// Generated by Mochi v0.10.40 on 2025-07-26 00:12:17 GMT+7

var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
{
  const _startMem = _mem()
  const _start = _now()
  function dbRec(k: number, n: number, t: number, p: number, a: number[], seq: number[]): number[] {
    if ((t > n)) {
      if (((n % p) == 0)) {
        let j: number = 1;
        while ((j <= p)) {
          seq = [...seq, a[j]];
          j = (j + 1);
        }
      }
    } else {
      a[t] = a[Math.trunc((t - p))];
      seq = dbRec(k, n, (t + 1), p, a, seq);
      let j: number = (a[Math.trunc((t - p))] + 1);
      while ((j < k)) {
        a[t] = j;
        seq = dbRec(k, n, (t + 1), t, a, seq);
        j = (j + 1);
      }
    }
    return seq;
  }
  function deBruijn(k: number, n: number): string {
    let digits: string = "0123456789";
    let alphabet: string = digits;
    if ((k < 10)) {
      alphabet = digits.slice(0, k);
    }
    let a: number[] = [];
    let i: number = 0;
    while ((i < (k * n))) {
      a = [...a, 0];
      i = (i + 1);
    }
    let seq: number[] = [];
    seq = dbRec(k, n, 1, 1, a, seq);
    let b: string = "";
    let idx: number = 0;
    while ((idx < (Array.isArray(seq) || typeof seq === 'string' ? seq.length : Object.keys(seq ?? {}).length))) {
      b = (b + alphabet[Math.trunc(seq[idx])]);
      idx = (idx + 1);
    }
    b = (b + b.slice(0, (n - 1)));
    return b;
  }
  function allDigits(s: string): boolean {
    let i: number = 0;
    while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
      let ch: string = s.slice(i, (i + 1));
      if (((ch < "0") || (ch > "9"))) {
        return false;
      }
      i = (i + 1);
    }
    return true;
  }
  function parseIntStr(str: string): number {
    let n: number = 0;
    let i: number = 0;
    while ((i < (Array.isArray(str) || typeof str === 'string' ? str.length : Object.keys(str ?? {}).length))) {
      n = ((n * 10) + str.slice(i, (i + 1)).charCodeAt(0));
      i = (i + 1);
    }
    return n;
  }
  function validate(db: string) {
    let le: number = (Array.isArray(db) || typeof db === 'string' ? db.length : Object.keys(db ?? {}).length);
    let found: number[] = [];
    let i: number = 0;
    while ((i < 10000)) {
      found = [...found, 0];
      i = (i + 1);
    }
    let j: number = 0;
    while ((j < (le - 3))) {
      let s: string = db.slice(j, (j + 4));
      if (allDigits(s)) {
        let n = parseIntStr(s);
        found[n] = (found[n] + 1);
      }
      j = (j + 1);
    }
    let errs: string[] = [];
    let k: number = 0;
    while ((k < 10000)) {
      if ((found[k] == 0)) {
        errs = [...errs, (("    PIN number " + padLeft(k, 4)) + " missing")];
      } else {
        if ((found[k] > 1)) {
          errs = [...errs, (((("    PIN number " + padLeft(k, 4)) + " occurs ") + String(found[k])) + " times")];
        }
      }
      k = (k + 1);
    }
    let lerr: number = (Array.isArray(errs) || typeof errs === 'string' ? errs.length : Object.keys(errs ?? {}).length);
    if ((lerr == 0)) {
      console.log("  No errors found");
    } else {
      let pl: string = "s";
      if ((lerr == 1)) {
        pl = "";
      }
      console.log((((("  " + String(lerr)) + " error") + pl) + " found:"));
      let msg: string = joinStr(errs, "\n");
      console.log(msg);
    }
  }
  function padLeft(n: number, width: number): string {
    let s: string = String(n);
    while (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < width)) {
      s = ("0" + s);
    }
    return s;
  }
  function joinStr(xs: string[], sep: string): string {
    let res: string = "";
    let i: number = 0;
    while ((i < (Array.isArray(xs) || typeof xs === 'string' ? xs.length : Object.keys(xs ?? {}).length))) {
      if ((i > 0)) {
        res = (res + sep);
      }
      res = (res + xs[i]);
      i = (i + 1);
    }
    return res;
  }
  function reverse(s: string): string {
    let out: string = "";
    let i: number = ((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) - 1);
    while ((i >= 0)) {
      out = (out + s.slice(i, (i + 1)));
      i = (i - 1);
    }
    return out;
  }
  function main() {
    let db: string = deBruijn(10, 4);
    let le: number = (Array.isArray(db) || typeof db === 'string' ? db.length : Object.keys(db ?? {}).length);
    console.log(("The length of the de Bruijn sequence is " + String(le)));
    console.log("\nThe first 130 digits of the de Bruijn sequence are:");
    console.log(db.slice(0, 130));
    console.log("\nThe last 130 digits of the de Bruijn sequence are:");
    console.log(db.slice((le - 130)));
    console.log("\nValidating the de Bruijn sequence:");
    validate(db);
    console.log("\nValidating the reversed de Bruijn sequence:");
    let dbr = reverse(db);
    validate(dbr);
    db = ((db.slice(0, 4443) + ".") + db.slice(4444, (Array.isArray(db) || typeof db === 'string' ? db.length : Object.keys(db ?? {}).length)));
    console.log("\nValidating the overlaid de Bruijn sequence:");
    validate(db);
  }
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
}

