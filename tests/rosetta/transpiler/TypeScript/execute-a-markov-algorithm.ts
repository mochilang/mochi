// Generated by Mochi v0.10.41 on 2025-07-27 11:34:14 GMT+7

export interface TestSet { ruleSet: string; sample: string; output: string }
function split(s: string, sep: string): string[] {
  let parts: string[] = [];
  let cur: string = "";
  let i: number = 0;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    if (((((Array.isArray(sep) || typeof sep === 'string' ? sep.length : Object.keys(sep ?? {}).length) > 0) && ((i + (Array.isArray(sep) || typeof sep === 'string' ? sep.length : Object.keys(sep ?? {}).length)) <= (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) && ((s).substring(i, (i + (Array.isArray(sep) || typeof sep === 'string' ? sep.length : Object.keys(sep ?? {}).length))) == sep))) {
      parts.push(cur);
      cur = "";
      i = (i + (Array.isArray(sep) || typeof sep === 'string' ? sep.length : Object.keys(sep ?? {}).length));
    } else {
      cur = (cur + (s).substring(i, (i + 1)));
      i = (i + 1);
    }
  }
  parts.push(cur);
  return parts;
}
function trimSpace(s: string): string {
  let start: number = 0;
  while (((start < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length)) && ((s.slice(start, (start + 1)) == " ") || (s.slice(start, (start + 1)) == "\t")))) {
    start = (start + 1);
  }
  let end: number = (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length);
  while (((end > start) && ((s.slice((end - 1), end) == " ") || (s.slice((end - 1), end) == "\t")))) {
    end = (end - 1);
  }
  return s.slice(start, end);
}
function indexOfSub(s: string, sub: string): number {
  if (((Array.isArray(sub) || typeof sub === 'string' ? sub.length : Object.keys(sub ?? {}).length) == 0)) {
    return 0;
  }
  let i: number = 0;
  while (((i + (Array.isArray(sub) || typeof sub === 'string' ? sub.length : Object.keys(sub ?? {}).length)) <= (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    if (((s).substring(i, (i + (Array.isArray(sub) || typeof sub === 'string' ? sub.length : Object.keys(sub ?? {}).length))) == sub)) {
      return i;
    }
    i = (i + 1);
  }
  return (0 - 1);
}
function parseRules(rs: string): Record<string, any> {
  let rules: Record<string, any>[] = [];
  for (const line of rs.split("\n")) {
    let ln: string = line;
    let hash: number = indexOfSub(ln, "#");
    if ((hash >= 0)) {
      ln = ln.slice(0, hash);
    }
    ln = trimSpace(ln);
    if (((Array.isArray(ln) || typeof ln === 'string' ? ln.length : Object.keys(ln ?? {}).length) == 0)) {
      continue
    }
    let arrow: number = (0 - 1);
    let j: number = 0;
    while (((j + 2) <= (Array.isArray(ln) || typeof ln === 'string' ? ln.length : Object.keys(ln ?? {}).length))) {
      if (((ln).substring(j, (j + 2)) == "->")) {
        let pre: boolean = ((j > 0) && ((ln.slice((j - 1), j) == " ") || (ln.slice((j - 1), j) == "\t")));
        let post: boolean = (((j + 2) < (Array.isArray(ln) || typeof ln === 'string' ? ln.length : Object.keys(ln ?? {}).length)) && ((ln.slice((j + 2), (j + 3)) == " ") || (ln.slice((j + 2), (j + 3)) == "\t")));
        if ((pre && post)) {
          arrow = j;
          break
        }
      }
      j = (j + 1);
    }
    if ((arrow < 0)) {
      arrow = indexOfSub(ln, "->");
    }
    if ((arrow < 0)) {
      return {"ok": false};
    }
    let pat: string = trimSpace(ln.slice(0, arrow));
    let rest: string = trimSpace(ln.slice((arrow + 2), (Array.isArray(ln) || typeof ln === 'string' ? ln.length : Object.keys(ln ?? {}).length)));
    let term: boolean = false;
    if ((((Array.isArray(rest) || typeof rest === 'string' ? rest.length : Object.keys(rest ?? {}).length) > 0) && (rest.slice(0, 1) == "."))) {
      term = true;
      rest = rest.slice(1, (Array.isArray(rest) || typeof rest === 'string' ? rest.length : Object.keys(rest ?? {}).length));
    }
    let rep: string = rest;
    rules.push({pat, rep, term});
  }
  return {"ok": true, rules};
}
function runRules(rules: Record<string, any>[], s: string): string {
  let changed: boolean = true;
  while (changed) {
    changed = false;
    let i: number = 0;
    while ((i < (Array.isArray(rules) || typeof rules === 'string' ? rules.length : Object.keys(rules ?? {}).length))) {
      let r: Record<string, any> = rules[i];
      let pat = r.pat;
      let rep = r.rep;
      let term = r.term;
      let idx: number = indexOfSub(s, pat);
      if ((idx >= 0)) {
        s = ((s.slice(0, idx) + rep) + s.slice((idx + (Array.isArray(pat) || typeof pat === 'string' ? pat.length : Object.keys(pat ?? {}).length))));
        changed = true;
        if (term) {
          return s;
        }
        break
      }
      i = (i + 1);
    }
  }
  return s;
}
function interpret(ruleset: string, input: string): Record<string, any> {
  let p: Record<string, any> = parseRules(ruleset);
  if (!p.ok) {
    return {"ok": false, "out": ""};
  }
  let out = runRules(p.rules, input);
  return {"ok": true, out};
}
let testSet: TestSet[] = [{"ruleSet": "# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As from T S.", "output": "I bought a bag of apples from my brother."}, {"ruleSet": "# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As from T S.", "output": "I bought a bag of apples from T shop."}, {"ruleSet": "# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n", "sample": "I bought a B of As W my Bgage from T S.", "output": "I bought a bag of apples with my money from T shop."}, {"ruleSet": "### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n", "sample": "_1111*11111_", "output": "11111111111111111111"}, {"ruleSet": "# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n", "sample": "000000A000000", "output": "00011H1111000"}];
function main() {
  console.log((("validating " + String((Array.isArray(testSet) || typeof testSet === 'string' ? testSet.length : Object.keys(testSet ?? {}).length))) + " test cases"));
  let failures: boolean = false;
  let i: number = 0;
  while ((i < (Array.isArray(testSet) || typeof testSet === 'string' ? testSet.length : Object.keys(testSet ?? {}).length))) {
    let tc: TestSet = testSet[i];
    let res = interpret(tc.ruleSet, tc.sample);
    if (!res.ok) {
      console.log((("test " + String((i + 1))) + " invalid ruleset"));
      failures = true;
    } else {
      if ((res.out != tc.output)) {
        console.log(((((("test " + String((i + 1))) + ": got ") + res.out) + ", want ") + tc.output));
        failures = true;
      }
    }
    i = (i + 1);
  }
  if (!failures) {
    console.log("no failures");
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
(() => {
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

