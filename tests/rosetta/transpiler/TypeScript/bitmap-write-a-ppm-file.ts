// Generated by Mochi v0.10.56 on 2025-08-03 17:23:41 GMT+7

export interface Colour { R: number; G: number; B: number }
export interface Bitmap { width: number; height: number; pixels: Colour[][] }
function newBitmap(w: number, h: number, c: Colour): Bitmap {
  let rows: Colour[][] = [];
  let y: number = 0;
  while ((y < h)) {
    let row: Colour[] = [];
    let x: number = 0;
    while ((x < w)) {
      row.push(c);
      x = (x + 1);
    }
    rows.push(row);
    y = (y + 1);
  }
  return {"width": w, "height": h, "pixels": rows};
}
function setPixel(b: Bitmap, x: number, y: number, c: Colour) {
  let rows: Colour[][] = b.pixels;
  let row: Colour[] = rows[y];
  row[x] = c;
  rows[y] = row;
  b.pixels = rows;
}
function fillRect(b: Bitmap, x: number, y: number, w: number, h: number, c: Colour) {
  let yy: number = y;
  while ((yy < (y + h))) {
    let xx: number = x;
    while ((xx < (x + w))) {
      setPixel(b, xx, yy, c);
      xx = (xx + 1);
    }
    yy = (yy + 1);
  }
}
function pad(n: number, width: number): string {
  let s: string = _str(n);
  while ((Number(Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < width)) {
    s = (" " + s);
  }
  return s;
}
function writePPMP3(b: Bitmap): string {
  let maxv: number = 0;
  let y: number = 0;
  while ((y < b.height)) {
    let x: number = 0;
    while ((x < b.width)) {
      let p: Colour = b.pixels[y][x];
      if ((p.R > maxv)) {
        maxv = p.R;
      }
      if ((p.G > maxv)) {
        maxv = p.G;
      }
      if ((p.B > maxv)) {
        maxv = p.B;
      }
      x = (x + 1);
    }
    y = (y + 1);
  }
  let out: string = (((((("P3\n# generated from Bitmap.writeppmp3\n" + _str(b.width)) + " ") + _str(b.height)) + "\n") + _str(maxv)) + "\n");
  let numsize: number = Number(Array.isArray(_str(maxv)) || typeof _str(maxv) === 'string' ? _str(maxv).length : Object.keys(_str(maxv) ?? {}).length);
  y = (b.height - 1);
  while ((y >= 0)) {
    let line: string = "";
    let x: number = 0;
    while ((x < b.width)) {
      let p: Colour = b.pixels[y][x];
      line = ((((((line + "   ") + pad(p.R, numsize)) + " ") + pad(p.G, numsize)) + " ") + pad(p.B, numsize));
      x = (x + 1);
    }
    out = (out + line);
    if ((y > 0)) {
      out = (out + "\n");
    } else {
      out = (out + "\n");
    }
    y = (y - 1);
  }
  return out;
}
function main() {
  let black: Colour = {"R": 0, "G": 0, "B": 0};
  let white: Colour = {"R": 255, "G": 255, "B": 255};
  let bm: Bitmap = newBitmap(4, 4, black);
  fillRect(bm, 1, 0, 1, 2, white);
  setPixel(bm, 3, 3, {"R": 127, "G": 0, "B": 63});
  let ppm: string = writePPMP3(bm);
  console.log(_str(ppm));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

