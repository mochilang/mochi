// Generated by Mochi v0.10.40 on 2025-07-25 17:41:34 GMT+7

function padLeft(s: string, w: number): string {
  let res: string = "";
  let n: number = (w - (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length));
  while ((n > 0)) {
    res = (res + " ");
    n = (n - 1);
  }
  return (res + s);
}
function indexOfFrom(s: string, ch: string, start: number): number {
  let i: number = start;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    if (((s).substring(i, (i + 1)) == ch)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}
function containsStr(s: string, sub: string): boolean {
  let i: number = 0;
  const sl: number = (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length);
  const subl: number = (Array.isArray(sub) || typeof sub === 'string' ? sub.length : Object.keys(sub ?? {}).length);
  while ((i <= (sl - subl))) {
    if (((s).substring(i, (i + subl)) == sub)) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function distinct(slist: string[]): string[] {
  let res: string[] = [];
  for (const s of slist) {
    let found: boolean = false;
    for (const r of res) {
      if ((r == s)) {
        found = true;
        break
      }
    }
    if (!found) {
      res = [...res, s];
    }
  }
  return res;
}
function permutations(xs: string[]): string[][] {
  if (((Array.isArray(xs) || typeof xs === 'string' ? xs.length : Object.keys(xs ?? {}).length) <= 1)) {
    return [xs];
  }
  let res: string[][] = [];
  let i: number = 0;
  while ((i < (Array.isArray(xs) || typeof xs === 'string' ? xs.length : Object.keys(xs ?? {}).length))) {
    let rest: string[] = [];
    let j: number = 0;
    while ((j < (Array.isArray(xs) || typeof xs === 'string' ? xs.length : Object.keys(xs ?? {}).length))) {
      if ((j != i)) {
        rest = [...rest, xs[j]];
      }
      j = (j + 1);
    }
    const subs: string[][] = permutations(rest);
    for (const p of subs) {
      let perm: string[] = [xs[i]];
      let k: number = 0;
      while ((k < (Array.isArray(p) || typeof p === 'string' ? p.length : Object.keys(p ?? {}).length))) {
        perm = [...perm, p[k]];
        k = (k + 1);
      }
      res = [...res, perm];
    }
    i = (i + 1);
  }
  return res;
}
function headTailOverlap(s1: string, s2: string): number {
  let start: number = 0;
  while (true) {
    const ix: number = indexOfFrom(s1, s2.slice(0, 1), start);
    if ((ix == (0 - 1))) {
      return 0;
    }
    start = ix;
    if (((s2).substring(0, ((Array.isArray(s1) || typeof s1 === 'string' ? s1.length : Object.keys(s1 ?? {}).length) - start)) == (s1).substring(start, (Array.isArray(s1) || typeof s1 === 'string' ? s1.length : Object.keys(s1 ?? {}).length)))) {
      return ((Array.isArray(s1) || typeof s1 === 'string' ? s1.length : Object.keys(s1 ?? {}).length) - start);
    }
    start = (start + 1);
  }
}
function deduplicate(slist: string[]): string[] {
  const arr: any[] = distinct(slist);
  let filtered: string[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(arr) || typeof arr === 'string' ? arr.length : Object.keys(arr ?? {}).length))) {
    const s1 = arr[i];
    let within: boolean = false;
    let j: number = 0;
    while ((j < (Array.isArray(arr) || typeof arr === 'string' ? arr.length : Object.keys(arr ?? {}).length))) {
      if (((j != i) && containsStr(arr[j], s1))) {
        within = true;
        break
      }
      j = (j + 1);
    }
    if (!within) {
      filtered = [...filtered, s1];
    }
    i = (i + 1);
  }
  return filtered;
}
function joinAll(ss: string[]): string {
  let out: string = "";
  for (const s of ss) {
    out = (out + s);
  }
  return out;
}
function shortestCommonSuperstring(slist: string[]): string {
  const ss: string[] = deduplicate(slist);
  let shortest: string = joinAll(ss);
  const perms: string[][] = permutations(ss);
  let idx: number = 0;
  while ((idx < (Array.isArray(perms) || typeof perms === 'string' ? perms.length : Object.keys(perms ?? {}).length))) {
    const perm: string[] = perms[idx];
    let sup: string = perm[Math.trunc(0)];
    let i: number = 0;
    while ((i < ((Array.isArray(ss) || typeof ss === 'string' ? ss.length : Object.keys(ss ?? {}).length) - 1))) {
      const ov: number = headTailOverlap(perm[i], perm[Math.trunc((i + 1))]);
      sup = (sup + (perm[Math.trunc((i + 1))]).substring(ov, (Array.isArray(perm[Math.trunc((i + 1))]) || typeof perm[Math.trunc((i + 1))] === 'string' ? perm[Math.trunc((i + 1))].length : Object.keys(perm[Math.trunc((i + 1))] ?? {}).length)));
      i = (i + 1);
    }
    if (((Array.isArray(sup) || typeof sup === 'string' ? sup.length : Object.keys(sup ?? {}).length) < (Array.isArray(shortest) || typeof shortest === 'string' ? shortest.length : Object.keys(shortest ?? {}).length))) {
      shortest = sup;
    }
    idx = (idx + 1);
  }
  return shortest;
}
function printCounts(seq: string) {
  let a: number = 0;
  let c: number = 0;
  let g: number = 0;
  let t: number = 0;
  let i: number = 0;
  while ((i < (Array.isArray(seq) || typeof seq === 'string' ? seq.length : Object.keys(seq ?? {}).length))) {
    const ch: string = (seq).substring(i, (i + 1));
    if ((ch == "A")) {
      a = (a + 1);
    } else {
      if ((ch == "C")) {
        c = (c + 1);
      } else {
        if ((ch == "G")) {
          g = (g + 1);
        } else {
          if ((ch == "T")) {
            t = (t + 1);
          }
        }
      }
    }
    i = (i + 1);
  }
  const total: number = (Array.isArray(seq) || typeof seq === 'string' ? seq.length : Object.keys(seq ?? {}).length);
  console.log((("\nNucleotide counts for " + seq) + ":\n"));
  console.log((padLeft("A", 10) + padLeft(String(a), 12)));
  console.log((padLeft("C", 10) + padLeft(String(c), 12)));
  console.log((padLeft("G", 10) + padLeft(String(g), 12)));
  console.log((padLeft("T", 10) + padLeft(String(t), 12)));
  console.log((padLeft("Other", 10) + padLeft(String((total - (((a + c) + g) + t))), 12)));
  console.log("  ____________________");
  console.log((padLeft("Total length", 14) + padLeft(String(total), 8)));
}
function main() {
  const tests: string[][] = [["TA", "AAG", "TA", "GAA", "TA"], ["CATTAGGG", "ATTAG", "GGG", "TA"], ["AAGAUGGA", "GGAGCGCAUC", "AUCGCAAUAAGGA"], ["ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT", "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT", "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC", "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC", "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT", "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"]];
  for (const seqs of tests) {
    const scs = shortestCommonSuperstring(seqs);
    printCounts(scs);
  }
}
main();
