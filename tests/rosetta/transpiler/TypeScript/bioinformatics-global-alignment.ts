// Generated by Mochi v0.10.42 on 2025-07-27 20:11:37 GMT+7

function padLeft(s: string, w: number): string {
  let res: string = "";
  let n: number = (w - (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length));
  while ((n > 0)) {
    res = (res + " ");
    n = (n - 1);
  }
  return (res + s);
}
function indexOfFrom(s: string, ch: string, start: number): number {
  let i: number = start;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    if (((s).substring(i, (i + 1)) == ch)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}
function containsStr(s: string, sub: string): boolean {
  let i: number = 0;
  let sl: number = (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length);
  let subl: number = (Array.isArray(sub) || typeof sub === 'string' ? sub.length : Object.keys(sub ?? {}).length);
  while ((i <= (sl - subl))) {
    if (((s).substring(i, (i + subl)) == sub)) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function distinct(slist: string[]): string[] {
  let res: string[] = [];
  for (const s of slist) {
    let found: boolean = false;
    for (const r of res) {
      if ((r == s)) {
        found = true;
        break
      }
    }
    if (!found) {
      res.push(s);
    }
  }
  return res;
}
function permutations(xs: string[]): string[][] {
  if (((Array.isArray(xs) || typeof xs === 'string' ? xs.length : Object.keys(xs ?? {}).length) <= 1)) {
    return [xs];
  }
  let res: string[][] = [];
  let i: number = 0;
  while ((i < (Array.isArray(xs) || typeof xs === 'string' ? xs.length : Object.keys(xs ?? {}).length))) {
    let rest: string[] = [];
    let j: number = 0;
    while ((j < (Array.isArray(xs) || typeof xs === 'string' ? xs.length : Object.keys(xs ?? {}).length))) {
      if ((j != i)) {
        rest.push(xs[j]);
      }
      j = (j + 1);
    }
    let subs: string[][] = permutations(rest);
    for (const p of subs) {
      let perm: string[] = [xs[i]];
      let k: number = 0;
      while ((k < (Array.isArray(p) || typeof p === 'string' ? p.length : Object.keys(p ?? {}).length))) {
        perm.push(p[k]);
        k = (k + 1);
      }
      res.push(perm);
    }
    i = (i + 1);
  }
  return res;
}
function headTailOverlap(s1: string, s2: string): number {
  let start: number = 0;
  while (true) {
    let ix: number = indexOfFrom(s1, s2.slice(0, 1), start);
    if ((ix == (0 - 1))) {
      return 0;
    }
    start = ix;
    let sublen: number = ((Array.isArray(s1) || typeof s1 === 'string' ? s1.length : Object.keys(s1 ?? {}).length) - start);
    if ((sublen > (Array.isArray(s2) || typeof s2 === 'string' ? s2.length : Object.keys(s2 ?? {}).length))) {
      sublen = (Array.isArray(s2) || typeof s2 === 'string' ? s2.length : Object.keys(s2 ?? {}).length);
    }
    if (((s2).substring(0, sublen) == (s1).substring(start, (start + sublen)))) {
      return sublen;
    }
    start = (start + 1);
  }
}
function deduplicate(slist: string[]): string[] {
  let arr: any[] = distinct(slist);
  let filtered: string[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(arr) || typeof arr === 'string' ? arr.length : Object.keys(arr ?? {}).length))) {
    let s1 = arr[i];
    let within: boolean = false;
    let j: number = 0;
    while ((j < (Array.isArray(arr) || typeof arr === 'string' ? arr.length : Object.keys(arr ?? {}).length))) {
      if (((j != i) && containsStr(arr[j], s1))) {
        within = true;
        break
      }
      j = (j + 1);
    }
    if (!within) {
      filtered.push(s1);
    }
    i = (i + 1);
  }
  return filtered;
}
function joinAll(ss: string[]): string {
  let out: string = "";
  for (const s of ss) {
    out = (out + s);
  }
  return out;
}
function shortestCommonSuperstring(slist: string[]): string {
  let ss: string[] = deduplicate(slist);
  let shortest: string = joinAll(ss);
  let perms: string[][] = permutations(ss);
  let idx: number = 0;
  while ((idx < (Array.isArray(perms) || typeof perms === 'string' ? perms.length : Object.keys(perms ?? {}).length))) {
    let perm: string[] = perms[idx];
    let sup: string = perm[Math.trunc(0)];
    let i: number = 0;
    while ((i < ((Array.isArray(ss) || typeof ss === 'string' ? ss.length : Object.keys(ss ?? {}).length) - 1))) {
      let ov: number = headTailOverlap(perm[i], perm[Math.trunc((i + 1))]);
      sup = (sup + (perm[Math.trunc((i + 1))]).substring(ov, (Array.isArray(perm[Math.trunc((i + 1))]) || typeof perm[Math.trunc((i + 1))] === 'string' ? perm[Math.trunc((i + 1))].length : Object.keys(perm[Math.trunc((i + 1))] ?? {}).length)));
      i = (i + 1);
    }
    if (((Array.isArray(sup) || typeof sup === 'string' ? sup.length : Object.keys(sup ?? {}).length) < (Array.isArray(shortest) || typeof shortest === 'string' ? shortest.length : Object.keys(shortest ?? {}).length))) {
      shortest = sup;
    }
    idx = (idx + 1);
  }
  return shortest;
}
function printCounts(seq: string) {
  let a: number = 0;
  let c: number = 0;
  let g: number = 0;
  let t: number = 0;
  let i: number = 0;
  while ((i < (Array.isArray(seq) || typeof seq === 'string' ? seq.length : Object.keys(seq ?? {}).length))) {
    let ch: string = (seq).substring(i, (i + 1));
    if ((ch == "A")) {
      a = (a + 1);
    } else {
      if ((ch == "C")) {
        c = (c + 1);
      } else {
        if ((ch == "G")) {
          g = (g + 1);
        } else {
          if ((ch == "T")) {
            t = (t + 1);
          }
        }
      }
    }
    i = (i + 1);
  }
  let total: number = (Array.isArray(seq) || typeof seq === 'string' ? seq.length : Object.keys(seq ?? {}).length);
  console.log((("\nNucleotide counts for " + seq) + ":\n"));
  console.log((padLeft("A", 10) + padLeft(String(a), 12)));
  console.log((padLeft("C", 10) + padLeft(String(c), 12)));
  console.log((padLeft("G", 10) + padLeft(String(g), 12)));
  console.log((padLeft("T", 10) + padLeft(String(t), 12)));
  console.log((padLeft("Other", 10) + padLeft(String((total - (((a + c) + g) + t))), 12)));
  console.log("  ____________________");
  console.log((padLeft("Total length", 14) + padLeft(String(total), 8)));
}
function main() {
  let tests: string[][] = [["TA", "AAG", "TA", "GAA", "TA"], ["CATTAGGG", "ATTAG", "GGG", "TA"], ["AAGAUGGA", "GGAGCGCAUC", "AUCGCAAUAAGGA"], ["ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT", "GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT", "GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC", "CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT", "TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC", "GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT", "TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC", "CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA", "TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA"]];
  for (const seqs of tests) {
    let scs: string = shortestCommonSuperstring(seqs);
    printCounts(scs);
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
(() => {
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

