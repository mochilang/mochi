// Generated by Mochi v0.10.38 on 2025-07-23 17:32:57 GMT+7

var _nowSeed = 0;
var _nowSeeded = false;
{
  const s = typeof Deno !== "undefined" ? Deno.env.get("MOCHI_NOW_SEED") : (process.env.MOCHI_NOW_SEED || "");
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return Date.now() * 1000;
}
const w: number = 400;
const h: number = 300;
const n: number = 15000;
const frost: number = 255;
let grid: number[][] = [];
let y: number = 0;
while ((y < h)) {
  let row: number[] = [];
  let x: number = 0;
  while ((x < w)) {
    row = [...row, 0];
    x = (x + 1);
  }
  grid = [...grid, row];
  y = (y + 1);
}
grid[Math.trunc(h / 3)][Math.trunc(w / 3)] = frost;
function inBounds(x: number, y: number): boolean {
  return ((((x >= 0) && (x < w)) && (y >= 0)) && (y < h));
}
function hasNeighbor(x: number, y: number): boolean {
  let dy: number = -1;
  while ((dy <= 1)) {
    let dx: number = -1;
    while ((dx <= 1)) {
      if (!((dx == 0) && (dy == 0))) {
        const nx: number = (x + dx);
        const ny: number = (y + dy);
        if ((inBounds(nx, ny) && (grid[Math.trunc(ny)][Math.trunc(nx)] == frost))) {
          return true;
        }
      }
      dx = (dx + 1);
    }
    dy = (dy + 1);
  }
  return false;
}
let a: number = 0;
while ((a < n)) {
  let px: number = (_now() % w);
  let py: number = (_now() % h);
  if ((grid[Math.trunc(py)][Math.trunc(px)] == frost)) {
    let lost: boolean = false;
    while (true) {
      px = ((px + (_now() % 3)) - 1);
      py = ((py + (_now() % 3)) - 1);
      if (!inBounds(px, py)) {
        lost = true;
        break
      }
      if ((grid[Math.trunc(py)][Math.trunc(px)] != frost)) {
        break
      }
    }
    if (lost) {
      continue
    }
  } else {
    let lost: boolean = false;
    while (!hasNeighbor(px, py)) {
      px = ((px + (_now() % 3)) - 1);
      py = ((py + (_now() % 3)) - 1);
      if (!inBounds(px, py)) {
        lost = true;
        break
      }
    }
    if (lost) {
      continue
    }
  }
  grid[py][px] = frost;
  a = (a + 1);
}
