// Generated by Mochi v0.10.42 on 2025-07-28 10:20:01 GMT+7

let PI: number = 3.141592653589793;
function _mod(x: number, m: number): number {
  return (x - (Math.trunc((x / m)) * m));
}
function _sin(x: number): number {
  let y: number = (_mod((x + PI), (2.0 * PI)) - PI);
  let y2: number = (y * y);
  let y3: number = (y2 * y);
  let y5: number = (y3 * y2);
  let y7: number = (y5 * y2);
  return (((y - (y3 / 6.0)) + (y5 / 120.0)) - (y7 / 5040.0));
}
function _cos(x: number): number {
  let y: number = (_mod((x + PI), (2.0 * PI)) - PI);
  let y2: number = (y * y);
  let y4: number = (y2 * y2);
  let y6: number = (y4 * y2);
  return (((1.0 - (y2 / 2.0)) + (y4 / 24.0)) - (y6 / 720.0));
}
let width: number = 80;
let height: number = 40;
let depth: number = 6;
let angle: number = 12.0;
let length: number = 12.0;
let frac: number = 0.8;
function clearGrid(): string[][] {
  let g: string[][] = [];
  let y: number = 0;
  while ((y < height)) {
    let row: string[] = [];
    let x: number = 0;
    while ((x < width)) {
      row.push(" ");
      x = (x + 1);
    }
    g.push(row);
    y = (y + 1);
  }
  return g;
}
function drawPoint(g: string[][], x: number, y: number) {
  if (((((x >= 0) && (x < width)) && (y >= 0)) && (y < height))) {
    let row: string[] = g[y];
    row[x] = "#";
    g[y] = row;
  }
}
function bresenham(x0: number, y0: number, x1: number, y1: number, g: string[][]) {
  let dx: bigint = (x1 - x0);
  if ((dx < 0)) {
    dx = -dx;
  }
  let dy: bigint = (y1 - y0);
  if ((dy < 0)) {
    dy = -dy;
  }
  let sx: number = -1;
  if ((x0 < x1)) {
    sx = 1;
  }
  let sy: number = -1;
  if ((y0 < y1)) {
    sy = 1;
  }
  let err: bigint = (dx - dy);
  while (true) {
    drawPoint(g, x0, y0);
    if (((x0 == x1) && (y0 == y1))) {
      break
    }
    let e2: bigint = (2 * err);
    if ((e2 > -dy)) {
      err = (err - dy);
      x0 = (x0 + sx);
    }
    if ((e2 < dx)) {
      err = (err + dx);
      y0 = (y0 + sy);
    }
  }
}
function ftree(g: string[][], x: number, y: number, dist: number, dir: number, d: number) {
  let rad: number = ((dir * PI) / 180.0);
  let x2: number = (x + (dist * _sin(rad)));
  let y2: number = (y - (dist * _cos(rad)));
  bresenham(Math.trunc(x), Math.trunc(y), Math.trunc(x2), Math.trunc(y2), g);
  if ((d > 0)) {
    ftree(g, x2, y2, (dist * frac), (dir - angle), (d - 1));
    ftree(g, x2, y2, (dist * frac), (dir + angle), (d - 1));
  }
}
function render(g: string[][]): string {
  let out: string = "";
  let y: number = 0;
  while ((y < height)) {
    let line: string = "";
    let x: number = 0;
    while ((x < width)) {
      line = (line + g[y][x]);
      x = (x + 1);
    }
    out = (out + line);
    if ((y < (height - 1))) {
      out = (out + "\n");
    }
    y = (y + 1);
  }
  return out;
}
function main() {
  let grid: string[][] = clearGrid();
  ftree(grid, Math.trunc(width / 2), (height - 1), length, 0.0, depth);
  console.log(_str(render(grid)));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

