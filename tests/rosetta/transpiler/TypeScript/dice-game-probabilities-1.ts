// Generated by Mochi v0.10.42 on 2025-07-27 21:21:26 GMT+7

function powInt(base: number, exp: number): number {
  let r: number = 1;
  let b: number = base;
  let e: number = exp;
  while ((e > 0)) {
    if (((e % 2) == 1)) {
      r = (r * b);
    }
    b = (b * b);
    e = Math.trunc(e / Math.trunc(2));
  }
  return r;
}
function minInt(x: number, y: number): number {
  if ((x < y)) {
    return x;
  }
  return y;
}
function throwDie(nSides: number, nDice: number, s: number, counts: number[]) {
  if ((nDice == 0)) {
    counts[s] = (counts[s] + 1);
    return;
  }
  let i: number = 1;
  while ((i <= nSides)) {
    throwDie(nSides, (nDice - 1), (s + i), counts);
    i = (i + 1);
  }
}
function beatingProbability(nSides1: number, nDice1: number, nSides2: number, nDice2: number): number {
  let len1: number = ((nSides1 + 1) * nDice1);
  let c1: number[] = [];
  let i: number = 0;
  while ((i < len1)) {
    c1.push(0);
    i = (i + 1);
  }
  throwDie(nSides1, nDice1, 0, c1);
  let len2: number = ((nSides2 + 1) * nDice2);
  let c2: number[] = [];
  let j: number = 0;
  while ((j < len2)) {
    c2.push(0);
    j = (j + 1);
  }
  throwDie(nSides2, nDice2, 0, c2);
  let p12: number = (powInt(nSides1, nDice1) * powInt(nSides2, nDice2));
  let tot: number = 0.0;
  i = 0;
  while ((i < len1)) {
    j = 0;
    let m: number = minInt(i, len2);
    while ((j < m)) {
      tot = (tot + ((c1[i] * c2[j]) / p12));
      j = (j + 1);
    }
    i = (i + 1);
  }
  return tot;
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
(() => {
  const _startMem = _mem()
  const _start = _now()
  console.log(String(beatingProbability(4, 9, 6, 6)));
  console.log(String(beatingProbability(10, 5, 7, 6)));
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

