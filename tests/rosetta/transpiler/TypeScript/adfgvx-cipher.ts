// Generated by Mochi v0.10.42 on 2025-07-27 17:18:41 GMT+7

let adfgvx: string = "ADFGVX";
let alphabet: string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
function shuffleStr(s: string): string {
  let arr: string[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    arr.push(s.slice(i, (i + 1)));
    i = (i + 1);
  }
  let j: number = ((Array.isArray(arr) || typeof arr === 'string' ? arr.length : Object.keys(arr ?? {}).length) - 1);
  while ((j > 0)) {
    let k: number = (_now() % (j + 1));
    let tmp: string = arr[j];
    arr[j] = arr[k];
    arr[k] = tmp;
    j = (j - 1);
  }
  let out: string = "";
  i = 0;
  while ((i < (Array.isArray(arr) || typeof arr === 'string' ? arr.length : Object.keys(arr ?? {}).length))) {
    out = (out + arr[i]);
    i = (i + 1);
  }
  return out;
}
function createPolybius(): string[] {
  let shuffled: string = shuffleStr(alphabet);
  let labels: string[] = [];
  let li: number = 0;
  while ((li < (Array.isArray(adfgvx) || typeof adfgvx === 'string' ? adfgvx.length : Object.keys(adfgvx ?? {}).length))) {
    labels.push(adfgvx.slice(li, (li + 1)));
    li = (li + 1);
  }
  console.log("6 x 6 Polybius square:\n");
  console.log("  | A D F G V X");
  console.log("---------------");
  let p: string[] = [];
  let i: number = 0;
  while ((i < 6)) {
    let row: string = shuffled.slice((i * 6), ((i + 1) * 6));
    p.push(row);
    let line: string = (labels[i] + " | ");
    let j: number = 0;
    while ((j < 6)) {
      line = ((line + row.slice(j, (j + 1))) + " ");
      j = (j + 1);
    }
    console.log(line);
    i = (i + 1);
  }
  return p;
}
function createKey(n: number): string {
  if (((n < 7) || (n > 12))) {
    console.log("Key should be within 7 and 12 letters long.");
  }
  let pool: string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let key: string = "";
  let i: number = 0;
  while ((i < n)) {
    let idx: number = (_now() % (Array.isArray(pool) || typeof pool === 'string' ? pool.length : Object.keys(pool ?? {}).length));
    key = (key + pool[idx]);
    pool = (pool.slice(0, idx) + pool.slice((idx + 1), (Array.isArray(pool) || typeof pool === 'string' ? pool.length : Object.keys(pool ?? {}).length)));
    i = (i + 1);
  }
  console.log(("\nThe key is " + key));
  return key;
}
function orderKey(key: string): number[] {
  let pairs: any[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
    pairs.push([key.slice(i, (i + 1)), i]);
    i = (i + 1);
  }
  let n: number = (Array.isArray(pairs) || typeof pairs === 'string' ? pairs.length : Object.keys(pairs ?? {}).length);
  let m: number = 0;
  while ((m < n)) {
    let j: number = 0;
    while ((j < (n - 1))) {
      if ((pairs[j][Math.trunc(0)] > pairs[Math.trunc((j + 1))][Math.trunc(0)])) {
        let tmp = pairs[j];
        pairs[j] = pairs[Math.trunc((j + 1))];
        pairs[(j + 1)] = tmp;
      }
      j = (j + 1);
    }
    m = (m + 1);
  }
  let res: any[] = [];
  i = 0;
  while ((i < n)) {
    res.push(Math.trunc(pairs[i][Math.trunc(1)]));
    i = (i + 1);
  }
  return res;
}
function encrypt(polybius: string[], key: string, plainText: string): string {
  let labels: string[] = [];
  let li: number = 0;
  while ((li < (Array.isArray(adfgvx) || typeof adfgvx === 'string' ? adfgvx.length : Object.keys(adfgvx ?? {}).length))) {
    labels.push(adfgvx.slice(li, (li + 1)));
    li = (li + 1);
  }
  let temp: string = "";
  let i: number = 0;
  while ((i < (Array.isArray(plainText) || typeof plainText === 'string' ? plainText.length : Object.keys(plainText ?? {}).length))) {
    let r: number = 0;
    while ((r < 6)) {
      let c: number = 0;
      while ((c < 6)) {
        if ((polybius[r].slice(c, (c + 1)) == plainText.slice(i, (i + 1)))) {
          temp = ((temp + labels.slice(r, (r + 1))) + labels.slice(c, (c + 1)));
        }
        c = (c + 1);
      }
      r = (r + 1);
    }
    i = (i + 1);
  }
  let colLen: number = Math.trunc((Array.isArray(temp) || typeof temp === 'string' ? temp.length : Object.keys(temp ?? {}).length) / (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length));
  if ((((Array.isArray(temp) || typeof temp === 'string' ? temp.length : Object.keys(temp ?? {}).length) % (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length)) > 0)) {
    colLen = (colLen + 1);
  }
  let table: string[][] = [];
  let rIdx: number = 0;
  while ((rIdx < colLen)) {
    let row: string[] = [];
    let j: number = 0;
    while ((j < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
      row.push("");
      j = (j + 1);
    }
    table.push(row);
    rIdx = (rIdx + 1);
  }
  let idx: number = 0;
  while ((idx < (Array.isArray(temp) || typeof temp === 'string' ? temp.length : Object.keys(temp ?? {}).length))) {
    let row: string[] = Math.trunc(idx / (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length));
    let col: number = (idx % (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length));
    table[row][col] = temp.slice(idx, (idx + 1));
    idx = (idx + 1);
  }
  let order: number[] = orderKey(key);
  let cols: string[] = [];
  let ci: number = 0;
  while ((ci < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
    let colStr: string = "";
    let ri: number = 0;
    while ((ri < colLen)) {
      colStr = (colStr + table[ri][Math.trunc(order[ci])]);
      ri = (ri + 1);
    }
    cols.push(colStr);
    ci = (ci + 1);
  }
  let result: string = "";
  ci = 0;
  while ((ci < (Array.isArray(cols) || typeof cols === 'string' ? cols.length : Object.keys(cols ?? {}).length))) {
    result = (result + cols[ci]);
    if ((ci < ((Array.isArray(cols) || typeof cols === 'string' ? cols.length : Object.keys(cols ?? {}).length) - 1))) {
      result = (result + " ");
    }
    ci = (ci + 1);
  }
  return result;
}
function indexOf(s: string, ch: string): number {
  let i: number = 0;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    if ((s.slice(i, (i + 1)) == ch)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}
function decrypt(polybius: string[], key: string, cipherText: string): string {
  let colStrs: string[] = [];
  let start: number = 0;
  let i: number = 0;
  while ((i <= (Array.isArray(cipherText) || typeof cipherText === 'string' ? cipherText.length : Object.keys(cipherText ?? {}).length))) {
    if (((i == (Array.isArray(cipherText) || typeof cipherText === 'string' ? cipherText.length : Object.keys(cipherText ?? {}).length)) || (cipherText[i] == " "))) {
      colStrs.push(cipherText.slice(start, i));
      start = (i + 1);
    }
    i = (i + 1);
  }
  let maxColLen: number = 0;
  i = 0;
  while ((i < (Array.isArray(colStrs) || typeof colStrs === 'string' ? colStrs.length : Object.keys(colStrs ?? {}).length))) {
    if (((Array.isArray(colStrs[i]) || typeof colStrs[i] === 'string' ? colStrs[i].length : Object.keys(colStrs[i] ?? {}).length) > maxColLen)) {
      maxColLen = (Array.isArray(colStrs[i]) || typeof colStrs[i] === 'string' ? colStrs[i].length : Object.keys(colStrs[i] ?? {}).length);
    }
    i = (i + 1);
  }
  let cols: string[][] = [];
  i = 0;
  while ((i < (Array.isArray(colStrs) || typeof colStrs === 'string' ? colStrs.length : Object.keys(colStrs ?? {}).length))) {
    let s: string = colStrs[i];
    let ls: string[] = [];
    let j: number = 0;
    while ((j < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
      ls.push(s.slice(j, (j + 1)));
      j = (j + 1);
    }
    if (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < maxColLen)) {
      let pad: string[] = [];
      let k: number = 0;
      while ((k < maxColLen)) {
        if ((k < (Array.isArray(ls) || typeof ls === 'string' ? ls.length : Object.keys(ls ?? {}).length))) {
          pad.push(ls[k]);
        } else {
          pad.push("");
        }
        k = (k + 1);
      }
      cols.push(pad);
    } else {
      cols.push(ls);
    }
    i = (i + 1);
  }
  let table: string[][] = [];
  let r: number = 0;
  while ((r < maxColLen)) {
    let row: string[] = [];
    let c: number = 0;
    while ((c < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
      row.push("");
      c = (c + 1);
    }
    table.push(row);
    r = (r + 1);
  }
  let order: number[] = orderKey(key);
  r = 0;
  while ((r < maxColLen)) {
    let c: number = 0;
    while ((c < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
      table[r][order[c]] = cols[c][r];
      c = (c + 1);
    }
    r = (r + 1);
  }
  let temp: string = "";
  r = 0;
  while ((r < (Array.isArray(table) || typeof table === 'string' ? table.length : Object.keys(table ?? {}).length))) {
    let j: number = 0;
    while ((j < (Array.isArray(table[r]) || typeof table[r] === 'string' ? table[r].length : Object.keys(table[r] ?? {}).length))) {
      temp = (temp + table[r][j]);
      j = (j + 1);
    }
    r = (r + 1);
  }
  let plainText: string = "";
  let idx: number = 0;
  while ((idx < (Array.isArray(temp) || typeof temp === 'string' ? temp.length : Object.keys(temp ?? {}).length))) {
    let rIdx: number = adfgvx.indexOf(temp.slice(idx, (idx + 1)));
    let cIdx: number = adfgvx.indexOf(temp.slice((idx + 1), (idx + 2)));
    plainText = (plainText + polybius[rIdx][cIdx]);
    idx = (idx + 2);
  }
  return plainText;
}
function main() {
  let plainText: string = "ATTACKAT1200AM";
  let polybius: string[] = createPolybius();
  let key: string = createKey(9);
  console.log(("\nPlaintext : " + plainText));
  let cipherText: string = encrypt(polybius, key, plainText);
  console.log(("\nEncrypted : " + cipherText));
  let plainText2: string = decrypt(polybius, key, cipherText);
  console.log(("\nDecrypted : " + plainText2));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
(() => {
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

