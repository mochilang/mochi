// Generated by Mochi v0.10.39 on 2025-07-25 10:17:34 GMT+7

var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
{
  const _startMem = _mem()
  const _start = _now()
  let adfgvx: string = "ADFGVX";
  let alphabet: string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  function shuffleStr(s: string): string {
    let arr: string[] = [];
    let i: number = 0;
    while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
      arr = [...arr, s.slice(i, (i + 1))];
      i = (i + 1);
    }
    let j: number = ((Array.isArray(arr) || typeof arr === 'string' ? arr.length : Object.keys(arr ?? {}).length) - 1);
    while ((j > 0)) {
      const k: number = (_now() % (j + 1));
      const tmp: string = arr[j];
      arr[j] = arr[k];
      arr[k] = tmp;
      j = (j - 1);
    }
    let out: string = "";
    i = 0;
    while ((i < (Array.isArray(arr) || typeof arr === 'string' ? arr.length : Object.keys(arr ?? {}).length))) {
      out = (out + arr[i]);
      i = (i + 1);
    }
    return out;
  }
  function createPolybius(): string[] {
    const shuffled: string = shuffleStr(alphabet);
    let labels: string[] = [];
    let li: number = 0;
    while ((li < (Array.isArray(adfgvx) || typeof adfgvx === 'string' ? adfgvx.length : Object.keys(adfgvx ?? {}).length))) {
      labels = [...labels, adfgvx.slice(li, (li + 1))];
      li = (li + 1);
    }
    console.log("6 x 6 Polybius square:\n");
    console.log("  | A D F G V X");
    console.log("---------------");
    let p: string[] = [];
    let i: number = 0;
    while ((i < 6)) {
      let row: string = shuffled.slice((i * 6), ((i + 1) * 6));
      p = [...p, row];
      let line: string = (labels[i] + " | ");
      let j: number = 0;
      while ((j < 6)) {
        line = ((line + row.slice(j, (j + 1))) + " ");
        j = (j + 1);
      }
      console.log(line);
      i = (i + 1);
    }
    return p;
  }
  function createKey(n: number): string {
    if (((n < 7) || (n > 12))) {
      console.log("Key should be within 7 and 12 letters long.");
    }
    let pool: string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    let key: string = "";
    let i: number = 0;
    while ((i < n)) {
      const idx: number = (_now() % (Array.isArray(pool) || typeof pool === 'string' ? pool.length : Object.keys(pool ?? {}).length));
      key = (key + pool[idx]);
      pool = (pool.slice(0, idx) + pool.slice((idx + 1), (Array.isArray(pool) || typeof pool === 'string' ? pool.length : Object.keys(pool ?? {}).length)));
      i = (i + 1);
    }
    console.log(("\nThe key is " + key));
    return key;
  }
  function orderKey(key: string): number[] {
    let pairs: any[] = [];
    let i: number = 0;
    while ((i < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
      pairs = [...pairs, [key.slice(i, (i + 1)), i]];
      i = (i + 1);
    }
    let n: number = (Array.isArray(pairs) || typeof pairs === 'string' ? pairs.length : Object.keys(pairs ?? {}).length);
    let m: number = 0;
    while ((m < n)) {
      let j: number = 0;
      while ((j < (n - 1))) {
        if ((pairs[j][Math.trunc(0)] > pairs[Math.trunc((j + 1))][Math.trunc(0)])) {
          const tmp = pairs[j];
          pairs[j] = pairs[Math.trunc((j + 1))];
          pairs[(j + 1)] = tmp;
        }
        j = (j + 1);
      }
      m = (m + 1);
    }
    let res: any[] = [];
    i = 0;
    while ((i < n)) {
      res = [...res, Math.trunc(pairs[i][Math.trunc(1)])];
      i = (i + 1);
    }
    return res;
  }
  function encrypt(polybius: string[], key: string, plainText: string): string {
    let labels: string[] = [];
    let li: number = 0;
    while ((li < (Array.isArray(adfgvx) || typeof adfgvx === 'string' ? adfgvx.length : Object.keys(adfgvx ?? {}).length))) {
      labels = [...labels, adfgvx.slice(li, (li + 1))];
      li = (li + 1);
    }
    let temp: string = "";
    let i: number = 0;
    while ((i < (Array.isArray(plainText) || typeof plainText === 'string' ? plainText.length : Object.keys(plainText ?? {}).length))) {
      let r: number = 0;
      while ((r < 6)) {
        let c: number = 0;
        while ((c < 6)) {
          if ((polybius[r].slice(c, (c + 1)) == plainText.slice(i, (i + 1)))) {
            temp = ((temp + labels.slice(r, (r + 1))) + labels.slice(c, (c + 1)));
          }
          c = (c + 1);
        }
        r = (r + 1);
      }
      i = (i + 1);
    }
    let colLen: number = Math.trunc((Array.isArray(temp) || typeof temp === 'string' ? temp.length : Object.keys(temp ?? {}).length) / (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length));
    if ((((Array.isArray(temp) || typeof temp === 'string' ? temp.length : Object.keys(temp ?? {}).length) % (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length)) > 0)) {
      colLen = (colLen + 1);
    }
    let table: string[][] = [];
    let rIdx: number = 0;
    while ((rIdx < colLen)) {
      let row: string[] = [];
      let j: number = 0;
      while ((j < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
        row = [...row, ""];
        j = (j + 1);
      }
      table = [...table, row];
      rIdx = (rIdx + 1);
    }
    let idx: number = 0;
    while ((idx < (Array.isArray(temp) || typeof temp === 'string' ? temp.length : Object.keys(temp ?? {}).length))) {
      const row: string[] = Math.trunc(idx / (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length));
      const col: number = (idx % (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length));
      table[row][col] = temp.slice(idx, (idx + 1));
      idx = (idx + 1);
    }
    const order: number[] = orderKey(key);
    let cols: string[] = [];
    let ci: number = 0;
    while ((ci < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
      let colStr: string = "";
      let ri: number = 0;
      while ((ri < colLen)) {
        colStr = (colStr + table[ri][Math.trunc(order[ci])]);
        ri = (ri + 1);
      }
      cols = [...cols, colStr];
      ci = (ci + 1);
    }
    let result: string = "";
    ci = 0;
    while ((ci < (Array.isArray(cols) || typeof cols === 'string' ? cols.length : Object.keys(cols ?? {}).length))) {
      result = (result + cols[ci]);
      if ((ci < ((Array.isArray(cols) || typeof cols === 'string' ? cols.length : Object.keys(cols ?? {}).length) - 1))) {
        result = (result + " ");
      }
      ci = (ci + 1);
    }
    return result;
  }
  function indexOf(s: string, ch: string): number {
    let i: number = 0;
    while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
      if ((s.slice(i, (i + 1)) == ch)) {
        return i;
      }
      i = (i + 1);
    }
    return -1;
  }
  function decrypt(polybius: string[], key: string, cipherText: string): string {
    let colStrs: string[] = [];
    let start: number = 0;
    let i: number = 0;
    while ((i <= (Array.isArray(cipherText) || typeof cipherText === 'string' ? cipherText.length : Object.keys(cipherText ?? {}).length))) {
      if (((i == (Array.isArray(cipherText) || typeof cipherText === 'string' ? cipherText.length : Object.keys(cipherText ?? {}).length)) || (cipherText[i] == " "))) {
        colStrs = [...colStrs, cipherText.slice(start, i)];
        start = (i + 1);
      }
      i = (i + 1);
    }
    let maxColLen: number = 0;
    i = 0;
    while ((i < (Array.isArray(colStrs) || typeof colStrs === 'string' ? colStrs.length : Object.keys(colStrs ?? {}).length))) {
      if (((Array.isArray(colStrs[i]) || typeof colStrs[i] === 'string' ? colStrs[i].length : Object.keys(colStrs[i] ?? {}).length) > maxColLen)) {
        maxColLen = (Array.isArray(colStrs[i]) || typeof colStrs[i] === 'string' ? colStrs[i].length : Object.keys(colStrs[i] ?? {}).length);
      }
      i = (i + 1);
    }
    let cols: string[][] = [];
    i = 0;
    while ((i < (Array.isArray(colStrs) || typeof colStrs === 'string' ? colStrs.length : Object.keys(colStrs ?? {}).length))) {
      let s: string = colStrs[i];
      let ls: string[] = [];
      let j: number = 0;
      while ((j < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
        ls = [...ls, s.slice(j, (j + 1))];
        j = (j + 1);
      }
      if (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < maxColLen)) {
        let pad: string[] = [];
        let k: number = 0;
        while ((k < maxColLen)) {
          if ((k < (Array.isArray(ls) || typeof ls === 'string' ? ls.length : Object.keys(ls ?? {}).length))) {
            pad = [...pad, ls[k]];
          } else {
            pad = [...pad, ""];
          }
          k = (k + 1);
        }
        cols = [...cols, pad];
      } else {
        cols = [...cols, ls];
      }
      i = (i + 1);
    }
    let table: string[][] = [];
    let r: number = 0;
    while ((r < maxColLen)) {
      let row: string[] = [];
      let c: number = 0;
      while ((c < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
        row = [...row, ""];
        c = (c + 1);
      }
      table = [...table, row];
      r = (r + 1);
    }
    const order: number[] = orderKey(key);
    r = 0;
    while ((r < maxColLen)) {
      let c: number = 0;
      while ((c < (Array.isArray(key) || typeof key === 'string' ? key.length : Object.keys(key ?? {}).length))) {
        table[r][order[c]] = cols[c][r];
        c = (c + 1);
      }
      r = (r + 1);
    }
    let temp: string = "";
    r = 0;
    while ((r < (Array.isArray(table) || typeof table === 'string' ? table.length : Object.keys(table ?? {}).length))) {
      let j: number = 0;
      while ((j < (Array.isArray(table[r]) || typeof table[r] === 'string' ? table[r].length : Object.keys(table[r] ?? {}).length))) {
        temp = (temp + table[r][j]);
        j = (j + 1);
      }
      r = (r + 1);
    }
    let plainText: string = "";
    let idx: number = 0;
    while ((idx < (Array.isArray(temp) || typeof temp === 'string' ? temp.length : Object.keys(temp ?? {}).length))) {
      const rIdx: number = adfgvx.indexOf(temp.slice(idx, (idx + 1)));
      const cIdx: number = adfgvx.indexOf(temp.slice((idx + 1), (idx + 2)));
      plainText = (plainText + polybius[rIdx][cIdx]);
      idx = (idx + 2);
    }
    return plainText;
  }
  function main() {
    const plainText: string = "ATTACKAT1200AM";
    const polybius: string[] = createPolybius();
    const key: string = createKey(9);
    console.log(("\nPlaintext : " + plainText));
    const cipherText: string = encrypt(polybius, key, plainText);
    console.log(("\nEncrypted : " + cipherText));
    const plainText2: string = decrypt(polybius, key, cipherText);
    console.log(("\nDecrypted : " + plainText2));
  }
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
}

