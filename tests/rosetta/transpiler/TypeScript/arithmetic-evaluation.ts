// Generated by Mochi v0.10.42 on 2025-07-27 18:45:18 GMT+7

export interface Parser { expr: string; pos: number }
export interface Res { v: number; p: Parser }
function skipWS(p: Parser): Parser {
  let i: number = p.pos;
  while (((i < (Array.isArray(p.expr) || typeof p.expr === 'string' ? p.expr.length : Object.keys(p.expr ?? {}).length)) && ((p.expr).substring(i, (i + 1)) == " "))) {
    i = (i + 1);
  }
  p.pos = i;
  return p;
}
function parseIntStr(str: string): number {
  let i: number = 0;
  let n: number = 0;
  while ((i < (Array.isArray(str) || typeof str === 'string' ? str.length : Object.keys(str ?? {}).length))) {
    n = (((n * 10) + str.slice(i, (i + 1)).charCodeAt(0)) - 48);
    i = (i + 1);
  }
  return n;
}
function parseNumber(p: Parser): Res {
  p = skipWS(p);
  let start: number = p.pos;
  while ((p.pos < (Array.isArray(p.expr) || typeof p.expr === 'string' ? p.expr.length : Object.keys(p.expr ?? {}).length))) {
    let ch: string = (p.expr).substring(p.pos, (p.pos + 1));
    if (((ch >= "0") && (ch <= "9"))) {
      p.pos = (p.pos + 1);
    } else {
      break
    }
  }
  let token: string = (p.expr).substring(start, p.pos);
  return {"v": parseIntStr(token), p};
}
function parseFactor(p: Parser): Res {
  p = skipWS(p);
  if (((p.pos < (Array.isArray(p.expr) || typeof p.expr === 'string' ? p.expr.length : Object.keys(p.expr ?? {}).length)) && ((p.expr).substring(p.pos, (p.pos + 1)) == "("))) {
    p.pos = (p.pos + 1);
    let r: Res = parseExpr(p);
    let v: number = r.v;
    p = r.p;
    p = skipWS(p);
    if (((p.pos < (Array.isArray(p.expr) || typeof p.expr === 'string' ? p.expr.length : Object.keys(p.expr ?? {}).length)) && ((p.expr).substring(p.pos, (p.pos + 1)) == ")"))) {
      p.pos = (p.pos + 1);
    }
    return {v, p};
  }
  if (((p.pos < (Array.isArray(p.expr) || typeof p.expr === 'string' ? p.expr.length : Object.keys(p.expr ?? {}).length)) && ((p.expr).substring(p.pos, (p.pos + 1)) == "-"))) {
    p.pos = (p.pos + 1);
    let r: Res = parseFactor(p);
    let v: number = r.v;
    p = r.p;
    return {"v": -v, p};
  }
  return parseNumber(p);
}
function powInt(base: number, exp: number): number {
  let r: number = 1;
  let b: number = base;
  let e: number = exp;
  while ((e > 0)) {
    if (((e % 2) == 1)) {
      r = (r * b);
    }
    b = (b * b);
    e = Math.trunc(e / Math.trunc(2));
  }
  return r;
}
function parsePower(p: Parser): Res {
  let r: Res = parseFactor(p);
  let v: number = r.v;
  p = r.p;
  while (true) {
    p = skipWS(p);
    if (((p.pos < (Array.isArray(p.expr) || typeof p.expr === 'string' ? p.expr.length : Object.keys(p.expr ?? {}).length)) && ((p.expr).substring(p.pos, (p.pos + 1)) == "^"))) {
      p.pos = (p.pos + 1);
      let r2: Res = parseFactor(p);
      let rhs: number = r2.v;
      p = r2.p;
      v = powInt(v, rhs);
    } else {
      break
    }
  }
  return {v, p};
}
function parseTerm(p: Parser): Res {
  let r: Res = parsePower(p);
  let v: number = r.v;
  p = r.p;
  while (true) {
    p = skipWS(p);
    if ((p.pos < (Array.isArray(p.expr) || typeof p.expr === 'string' ? p.expr.length : Object.keys(p.expr ?? {}).length))) {
      let op: string = (p.expr).substring(p.pos, (p.pos + 1));
      if ((op == "*")) {
        p.pos = (p.pos + 1);
        let r2: Res = parsePower(p);
        let rhs: number = r2.v;
        p = r2.p;
        v = (v * rhs);
        continue
      }
      if ((op == "/")) {
        p.pos = (p.pos + 1);
        let r2: Res = parsePower(p);
        let rhs: number = r2.v;
        p = r2.p;
        v = Math.trunc(v / Math.trunc(rhs));
        continue
      }
    }
    break
  }
  return {v, p};
}
function parseExpr(p: Parser): Res {
  let r: Res = parseTerm(p);
  let v: number = r.v;
  p = r.p;
  while (true) {
    p = skipWS(p);
    if ((p.pos < (Array.isArray(p.expr) || typeof p.expr === 'string' ? p.expr.length : Object.keys(p.expr ?? {}).length))) {
      let op: string = (p.expr).substring(p.pos, (p.pos + 1));
      if ((op == "+")) {
        p.pos = (p.pos + 1);
        let r2: Res = parseTerm(p);
        let rhs: number = r2.v;
        p = r2.p;
        v = (v + rhs);
        continue
      }
      if ((op == "-")) {
        p.pos = (p.pos + 1);
        let r2: Res = parseTerm(p);
        let rhs: number = r2.v;
        p = r2.p;
        v = (v - rhs);
        continue
      }
    }
    break
  }
  return {v, p};
}
function evalExpr(expr: string): number {
  let p: Parser = {expr, "pos": 0};
  let r: Res = parseExpr(p);
  return r.v;
}
function main() {
  let expr: string = "2*(3-1)+2*5";
  console.log(((expr + " = ") + String(evalExpr(expr))));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
(() => {
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

