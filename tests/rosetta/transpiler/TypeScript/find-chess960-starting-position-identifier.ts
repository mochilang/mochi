// Generated by Mochi v0.10.42 on 2025-07-28 07:51:46 GMT+7

export interface G2lMap { "♜": string; "♞": string; "♝": string; "♛": string; "♚": string; "♖": string; "♘": string; "♗": string; "♕": string; "♔": string }
export interface Names { R: string; N: string; B: string; Q: string; K: string }
export interface Ntable { "01": number; "02": number; "03": number; "04": number; "12": number; "13": number; "14": number; "23": number; "24": number; "34": number }
let glyphs: string = "♜♞♝♛♚♖♘♗♕♔";
let g2lMap: G2lMap = {"♜": "R", "♞": "N", "♝": "B", "♛": "Q", "♚": "K", "♖": "R", "♘": "N", "♗": "B", "♕": "Q", "♔": "K"};
let names: Names = {"R": "rook", "N": "knight", "B": "bishop", "Q": "queen", "K": "king"};
let ntable: Ntable = {"01": 0, "02": 1, "03": 2, "04": 3, "12": 4, "13": 5, "14": 6, "23": 7, "24": 8, "34": 9};
function indexOf(s: string, sub: string): number {
  let i: number = 0;
  while ((i <= ((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) - (Array.isArray(sub) || typeof sub === 'string' ? sub.length : Object.keys(sub ?? {}).length)))) {
    if (((s).substring(i, (i + (Array.isArray(sub) || typeof sub === 'string' ? sub.length : Object.keys(sub ?? {}).length))) == sub)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}
function strReplace(s: string, old: string, _new: string): string {
  let res: string = "";
  let i: number = 0;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    if (((((Array.isArray(old) || typeof old === 'string' ? old.length : Object.keys(old ?? {}).length) > 0) && ((i + (Array.isArray(old) || typeof old === 'string' ? old.length : Object.keys(old ?? {}).length)) <= (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) && ((s).substring(i, (i + (Array.isArray(old) || typeof old === 'string' ? old.length : Object.keys(old ?? {}).length))) == old))) {
      res = (res + _new);
      i = (i + (Array.isArray(old) || typeof old === 'string' ? old.length : Object.keys(old ?? {}).length));
    } else {
      res = (res + (s).substring(i, (i + 1)));
      i = (i + 1);
    }
  }
  return res;
}
function g2l(pieces: string): string {
  let lets: string = "";
  let i: number = 0;
  while ((i < (Array.isArray(pieces) || typeof pieces === 'string' ? pieces.length : Object.keys(pieces ?? {}).length))) {
    let ch: string = (pieces).substring(i, (i + 1));
    lets = (lets + g2lMap[ch]);
    i = (i + 1);
  }
  return lets;
}
function spid(pieces: string): number {
  pieces = g2l(pieces);
  if (((Array.isArray(pieces) || typeof pieces === 'string' ? pieces.length : Object.keys(pieces ?? {}).length) != 8)) {
    return -1;
  }
  for (const one of ["K", "Q"]) {
    let count: number = 0;
    let i: number = 0;
    while ((i < (Array.isArray(pieces) || typeof pieces === 'string' ? pieces.length : Object.keys(pieces ?? {}).length))) {
      if (((pieces).substring(i, (i + 1)) == one)) {
        count = (count + 1);
      }
      i = (i + 1);
    }
    if ((count != 1)) {
      return -1;
    }
  }
  for (const two of ["R", "N", "B"]) {
    let count: number = 0;
    let i: number = 0;
    while ((i < (Array.isArray(pieces) || typeof pieces === 'string' ? pieces.length : Object.keys(pieces ?? {}).length))) {
      if (((pieces).substring(i, (i + 1)) == two)) {
        count = (count + 1);
      }
      i = (i + 1);
    }
    if ((count != 2)) {
      return -1;
    }
  }
  let r1: number = pieces.indexOf("R");
  let r2: bigint = (((pieces).substring((r1 + 1), (Array.isArray(pieces) || typeof pieces === 'string' ? pieces.length : Object.keys(pieces ?? {}).length)).indexOf("R") + r1) + 1);
  let k: number = pieces.indexOf("K");
  if (((k < r1) || (k > Number(r2)))) {
    return -1;
  }
  let b1: number = pieces.indexOf("B");
  let b2: bigint = (((pieces).substring((b1 + 1), (Array.isArray(pieces) || typeof pieces === 'string' ? pieces.length : Object.keys(pieces ?? {}).length)).indexOf("B") + b1) + 1);
  if (((Number((Number(b2) - b1)) % 2) == 0)) {
    return -1;
  }
  let piecesN: string = strReplace(pieces, "Q", "");
  piecesN = strReplace(piecesN, "B", "");
  let n1: number = piecesN.indexOf("N");
  let n2: bigint = (((piecesN).substring((n1 + 1), (Array.isArray(piecesN) || typeof piecesN === 'string' ? piecesN.length : Object.keys(piecesN ?? {}).length)).indexOf("N") + n1) + 1);
  let np: string = (_str(n1) + _str(n2));
  let N = ntable[np];
  let piecesQ: string = strReplace(pieces, "B", "");
  let Q: number = piecesQ.indexOf("Q");
  let D: number = "0246".indexOf(_str(b1));
  let L: number = "1357".indexOf(_str(b2));
  if ((D == Number((0 - 1)))) {
    D = "0246".indexOf(_str(b2));
    L = "1357".indexOf(_str(b1));
  }
  return ((((96 * N) + (16 * Q)) + (4 * D)) + L);
}
function main() {
  for (const pieces of ["♕♘♖♗♗♘♔♖", "♖♘♗♕♔♗♘♖", "♖♕♘♗♗♔♖♘", "♖♘♕♗♗♔♖♘"]) {
    console.log(_str(((((pieces + " or ") + g2l(pieces)) + " has SP-ID of ") + _str(spid(pieces)))));
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

