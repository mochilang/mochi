// Generated by Mochi v0.10.38 on 2025-07-23 20:04:18 GMT+7

export interface Point { x: number; y: number; z: number }
export interface Edge { pn1: number; pn2: number; fn1: number; fn2: number; cp: Point }
export interface PointEx { p: Point; n: number }
function indexOf(s: string, ch: string): number {
  let i: number = 0;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    if (((s).substring(i, (i + 1)) == ch)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}
function fmt4(x: number): string {
  let y: number = (x * 10000.0);
  if ((y >= 0)) {
    y = (y + 0.5);
  } else {
    y = (y - 0.5);
  }
  y = (Math.trunc(y) / 10000.0);
  let s: string = String(y);
  let dot: number = s.indexOf(".");
  if ((dot == (0 - 1))) {
    s = (s + ".0000");
  } else {
    let decs: number = (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) - dot) - 1);
    if ((decs > 4)) {
      s = (s).substring(0, (dot + 5));
    } else {
      while ((decs < 4)) {
        s = (s + "0");
        decs = (decs + 1);
      }
    }
  }
  if ((x >= 0.0)) {
    s = (" " + s);
  }
  return s;
}
function fmt2(n: number): string {
  const s: string = String(n);
  if (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < 2)) {
    return (" " + s);
  }
  return s;
}
function sumPoint(p1: Point, p2: Point): Point {
  return {"x": (p1.x + p2.x), "y": (p1.y + p2.y), "z": (p1.z + p2.z)};
}
function mulPoint(p: Point, m: number): Point {
  return {"x": (p.x * m), "y": (p.y * m), "z": (p.z * m)};
}
function divPoint(p: Point, d: number): Point {
  return mulPoint(p, (1.0 / d));
}
function centerPoint(p1: Point, p2: Point): Point {
  return divPoint(sumPoint(p1, p2), 2.0);
}
function getFacePoints(points: Point[], faces: number[][]): Point[] {
  let facePoints: Point[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    const face: number[] = faces[i];
    let fp: Point = {"x": 0.0, "y": 0.0, "z": 0.0};
    for (const idx of face) {
      fp = sumPoint(fp, points[idx]);
    }
    fp = divPoint(fp, (Array.isArray(face) || typeof face === 'string' ? face.length : Object.keys(face ?? {}).length));
    facePoints = [...facePoints, fp];
    i = (i + 1);
  }
  return facePoints;
}
function sortEdges(edges: number[][]): number[][] {
  let res: number[][] = [];
  let tmp: number[][] = edges;
  while (((Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length) > 0)) {
    let min: number[] = tmp[Math.trunc(0)];
    let idx: number = 0;
    let j: number = 1;
    while ((j < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
      const e: number[] = tmp[j];
      if (((e[Math.trunc(0)] < min[Math.trunc(0)]) || ((e[Math.trunc(0)] == min[Math.trunc(0)]) && ((e[Math.trunc(1)] < min[Math.trunc(1)]) || ((e[Math.trunc(1)] == min[Math.trunc(1)]) && (e[Math.trunc(2)] < min[Math.trunc(2)])))))) {
        min = e;
        idx = j;
      }
      j = (j + 1);
    }
    res = [...res, min];
    let out: number[][] = [];
    let k: number = 0;
    while ((k < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
      if ((k != idx)) {
        out = [...out, tmp[k]];
      }
      k = (k + 1);
    }
    tmp = out;
  }
  return res;
}
function getEdgesFaces(points: Point[], faces: number[][]): Edge[] {
  let edges: number[][] = [];
  let fnum: number = 0;
  while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    const face: number[] = faces[fnum];
    let numP: number = (Array.isArray(face) || typeof face === 'string' ? face.length : Object.keys(face ?? {}).length);
    let pi: number = 0;
    while ((pi < numP)) {
      let pn1: number = face[pi];
      let pn2: number = 0;
      if ((pi < (numP - 1))) {
        pn2 = face[Math.trunc((pi + 1))];
      } else {
        pn2 = face[Math.trunc(0)];
      }
      if ((pn1 > pn2)) {
        let tmpn: number = pn1;
        pn1 = pn2;
        pn2 = tmpn;
      }
      edges = [...edges, [pn1, pn2, fnum]];
      pi = (pi + 1);
    }
    fnum = (fnum + 1);
  }
  edges = sortEdges(edges);
  let merged: number[][] = [];
  let idx: number = 0;
  while ((idx < (Array.isArray(edges) || typeof edges === 'string' ? edges.length : Object.keys(edges ?? {}).length))) {
    const e1: number[] = edges[idx];
    if ((idx < ((Array.isArray(edges) || typeof edges === 'string' ? edges.length : Object.keys(edges ?? {}).length) - 1))) {
      const e2: number[] = edges[Math.trunc((idx + 1))];
      if (((e1[Math.trunc(0)] == e2[Math.trunc(0)]) && (e1[Math.trunc(1)] == e2[Math.trunc(1)]))) {
        merged = [...merged, [e1[Math.trunc(0)], e1[Math.trunc(1)], e1[Math.trunc(2)], e2[Math.trunc(2)]]];
        idx = (idx + 2);
        continue
      }
    }
    merged = [...merged, [e1[Math.trunc(0)], e1[Math.trunc(1)], e1[Math.trunc(2)], -1]];
    idx = (idx + 1);
  }
  let edgesCenters: Edge[] = [];
  for (const me of merged) {
    const p1 = points[Math.trunc(me[Math.trunc(0)])];
    const p2 = points[Math.trunc(me[Math.trunc(1)])];
    const cp: Point = centerPoint(p1, p2);
    edgesCenters = [...edgesCenters, {"pn1": me[Math.trunc(0)], "pn2": me[Math.trunc(1)], "fn1": me[Math.trunc(2)], "fn2": me[Math.trunc(3)], cp}];
  }
  return edgesCenters;
}
function getEdgePoints(points: Point[], edgesFaces: Edge[], facePoints: Point[]): Point[] {
  let edgePoints: Point[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(edgesFaces) || typeof edgesFaces === 'string' ? edgesFaces.length : Object.keys(edgesFaces ?? {}).length))) {
    const edge: Edge = edgesFaces[i];
    const cp: Point = edge.cp;
    const fp1: Point = facePoints[Math.trunc(edge.fn1)];
    let fp2: Point = fp1;
    if ((edge.fn2 != (0 - 1))) {
      fp2 = facePoints[Math.trunc(edge.fn2)];
    }
    const cfp: Point = centerPoint(fp1, fp2);
    edgePoints = [...edgePoints, centerPoint(cp, cfp)];
    i = (i + 1);
  }
  return edgePoints;
}
function getAvgFacePoints(points: Point[], faces: number[][], facePoints: Point[]): Point[] {
  let numP: number = (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length);
  let temp: PointEx[] = [];
  let i: number = 0;
  while ((i < numP)) {
    temp = [...temp, {"p": {"x": 0.0, "y": 0.0, "z": 0.0}, "n": 0}];
    i = (i + 1);
  }
  let fnum: number = 0;
  while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    const fp: Point = facePoints[fnum];
    for (const pn of faces[fnum]) {
      const tp = temp[pn];
      temp[pn] = {"p": sumPoint(tp.p, fp), "n": (tp.n + 1)};
    }
    fnum = (fnum + 1);
  }
  let avg: Point[] = [];
  let j: number = 0;
  while ((j < numP)) {
    const tp = temp[j];
    avg = [...avg, divPoint(tp.p, tp.n)];
    j = (j + 1);
  }
  return avg;
}
function getAvgMidEdges(points: Point[], edgesFaces: Edge[]): Point[] {
  let numP: number = (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length);
  let temp: PointEx[] = [];
  let i: number = 0;
  while ((i < numP)) {
    temp = [...temp, {"p": {"x": 0.0, "y": 0.0, "z": 0.0}, "n": 0}];
    i = (i + 1);
  }
  for (const edge of edgesFaces) {
    const cp = edge.cp;
    let arr = [edge.pn1, edge.pn2];
    for (const pn of arr) {
      const tp = temp[pn];
      temp[pn] = {"p": sumPoint(tp.p, cp), "n": (tp.n + 1)};
    }
  }
  let avg: Point[] = [];
  let j: number = 0;
  while ((j < numP)) {
    const tp = temp[j];
    avg = [...avg, divPoint(tp.p, tp.n)];
    j = (j + 1);
  }
  return avg;
}
function getPointsFaces(points: Point[], faces: number[][]): number[] {
  let pf: number[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length))) {
    pf = [...pf, 0];
    i = (i + 1);
  }
  let fnum: number = 0;
  while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    for (const pn of faces[fnum]) {
      pf[pn] = (pf[pn] + 1);
    }
    fnum = (fnum + 1);
  }
  return pf;
}
function getNewPoints(points: Point[], pf: number[], afp: Point[], ame: Point[]): Point[] {
  let newPts: Point[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length))) {
    let n: number = pf[i];
    let m1: number = ((n - 3.0) / n);
    let m2: number = (1.0 / n);
    let m3: number = (2.0 / n);
    const old: Point = points[i];
    const p1: Point = mulPoint(old, m1);
    const p2: Point = mulPoint(afp[i], m2);
    const p3: Point = mulPoint(ame[i], m3);
    newPts = [...newPts, sumPoint(sumPoint(p1, p2), p3)];
    i = (i + 1);
  }
  return newPts;
}
function key(a: number, b: number): string {
  if ((a < b)) {
    return ((String(a) + ",") + String(b));
  }
  return ((String(b) + ",") + String(a));
}
function cmcSubdiv(points: Point[], faces: number[][]): any[] {
  const facePoints: Point[] = getFacePoints(points, faces);
  const edgesFaces: Edge[] = getEdgesFaces(points, faces);
  const edgePoints: Point[] = getEdgePoints(points, edgesFaces, facePoints);
  const avgFacePoints: Point[] = getAvgFacePoints(points, faces, facePoints);
  const avgMidEdges: Point[] = getAvgMidEdges(points, edgesFaces);
  const pointsFaces: number[] = getPointsFaces(points, faces);
  let newPoints: Point[] = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges);
  let facePointNums: number[] = [];
  let nextPoint: number = (Array.isArray(newPoints) || typeof newPoints === 'string' ? newPoints.length : Object.keys(newPoints ?? {}).length);
  for (const fp of facePoints) {
    newPoints = [...newPoints, fp];
    facePointNums = [...facePointNums, nextPoint];
    nextPoint = (nextPoint + 1);
  }
  let edgePointNums: Record<string, number> = {};
  let idx: number = 0;
  while ((idx < (Array.isArray(edgesFaces) || typeof edgesFaces === 'string' ? edgesFaces.length : Object.keys(edgesFaces ?? {}).length))) {
    const e: Edge = edgesFaces[idx];
    newPoints = [...newPoints, edgePoints[idx]];
    edgePointNums[key(e.pn1, e.pn2)] = nextPoint;
    nextPoint = (nextPoint + 1);
    idx = (idx + 1);
  }
  let newFaces: number[][] = [];
  let fnum: number = 0;
  while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    const oldFace: number[] = faces[fnum];
    if (((Array.isArray(oldFace) || typeof oldFace === 'string' ? oldFace.length : Object.keys(oldFace ?? {}).length) == 4)) {
      const a: number = oldFace[Math.trunc(0)];
      const b: number = oldFace[Math.trunc(1)];
      const c: number = oldFace[Math.trunc(2)];
      const d: number = oldFace[Math.trunc(3)];
      const fpnum: number = facePointNums[fnum];
      const ab: number = edgePointNums[key(a, b)];
      const da: number = edgePointNums[key(d, a)];
      const bc: number = edgePointNums[key(b, c)];
      const cd: number = edgePointNums[key(c, d)];
      newFaces = [...newFaces, [a, ab, fpnum, da]];
      newFaces = [...newFaces, [b, bc, fpnum, ab]];
      newFaces = [...newFaces, [c, cd, fpnum, bc]];
      newFaces = [...newFaces, [d, da, fpnum, cd]];
    }
    fnum = (fnum + 1);
  }
  return [newPoints, newFaces];
}
function formatPoint(p: Point): string {
  return (((((("[" + fmt4(p.x)) + " ") + fmt4(p.y)) + " ") + fmt4(p.z)) + "]");
}
function formatFace(f: number[]): string {
  if (((Array.isArray(f) || typeof f === 'string' ? f.length : Object.keys(f ?? {}).length) == 0)) {
    return "[]";
  }
  let s: string = ("[" + fmt2(f[Math.trunc(0)]));
  let i: number = 1;
  while ((i < (Array.isArray(f) || typeof f === 'string' ? f.length : Object.keys(f ?? {}).length))) {
    s = ((s + " ") + fmt2(f[i]));
    i = (i + 1);
  }
  s = (s + "]");
  return s;
}
function main() {
  const inputPoints: Point[] = [{"x": -1.0, "y": 1.0, "z": 1.0}, {"x": -1.0, "y": -1.0, "z": 1.0}, {"x": 1.0, "y": -1.0, "z": 1.0}, {"x": 1.0, "y": 1.0, "z": 1.0}, {"x": 1.0, "y": -1.0, "z": -1.0}, {"x": 1.0, "y": 1.0, "z": -1.0}, {"x": -1.0, "y": -1.0, "z": -1.0}, {"x": -1.0, "y": 1.0, "z": -1.0}];
  const inputFaces: number[][] = [[0, 1, 2, 3], [3, 2, 4, 5], [5, 4, 6, 7], [7, 0, 3, 5], [7, 6, 1, 0], [6, 1, 2, 4]];
  let outputPoints: Point[] = inputPoints;
  let outputFaces: number[][] = inputFaces;
  let i: number = 0;
  while ((i < 1)) {
    const res: any[] = cmcSubdiv(outputPoints, outputFaces);
    outputPoints = res[Math.trunc(0)];
    outputFaces = res[Math.trunc(1)];
    i = (i + 1);
  }
  for (const p of outputPoints) {
    console.log(formatPoint(p));
  }
  console.log("");
  for (const f of outputFaces) {
    console.log(formatFace(f));
  }
}
main();
