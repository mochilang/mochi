// Generated by Mochi v0.10.40 on 2025-07-26 09:36:10 GMT+7

export interface Point { x: number; y: number; z: number }
export interface Edge { pn1: number; pn2: number; fn1: number; fn2: number; cp: Point }
export interface PointEx { p: Point; n: number }
function indexOf(s: string, ch: string): number {
  let i: number = 0;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    if (((s).substring(i, (i + 1)) == ch)) {
      return i;
    }
    i = (i + 1);
  }
  return -1;
}
function fmt4(x: number): string {
  let y: number = (x * 10000.0);
  if ((y >= 0)) {
    y = (y + 0.5);
  } else {
    y = (y - 0.5);
  }
  y = (Math.trunc(y) / 10000.0);
  let s: string = String(y);
  let dot: number = s.indexOf(".");
  if ((dot == (0 - 1))) {
    s = (s + ".0000");
  } else {
    let decs: number = (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) - dot) - 1);
    if ((decs > 4)) {
      s = (s).substring(0, (dot + 5));
    } else {
      while ((decs < 4)) {
        s = (s + "0");
        decs = (decs + 1);
      }
    }
  }
  if ((x >= 0.0)) {
    s = (" " + s);
  }
  return s;
}
function fmt2(n: number): string {
  let s: string = String(n);
  if (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < 2)) {
    return (" " + s);
  }
  return s;
}
function sumPoint(p1: Point, p2: Point): Point {
  return {"x": (p1.x + p2.x), "y": (p1.y + p2.y), "z": (p1.z + p2.z)};
}
function mulPoint(p: Point, m: number): Point {
  return {"x": (p.x * m), "y": (p.y * m), "z": (p.z * m)};
}
function divPoint(p: Point, d: number): Point {
  return mulPoint(p, (1.0 / d));
}
function centerPoint(p1: Point, p2: Point): Point {
  return divPoint(sumPoint(p1, p2), 2.0);
}
function getFacePoints(points: Point[], faces: number[][]): Point[] {
  let facePoints: Point[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    let face: number[] = faces[i];
    let fp: Point = {"x": 0.0, "y": 0.0, "z": 0.0};
    for (const idx of face) {
      fp = sumPoint(fp, points[idx]);
    }
    fp = divPoint(fp, (Array.isArray(face) || typeof face === 'string' ? face.length : Object.keys(face ?? {}).length));
    facePoints.push(fp);
    i = (i + 1);
  }
  return facePoints;
}
function sortEdges(edges: number[][]): number[][] {
  let res: number[][] = [];
  let tmp: number[][] = edges;
  while (((Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length) > 0)) {
    let min: number[] = tmp[Math.trunc(0)];
    let idx: number = 0;
    let j: number = 1;
    while ((j < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
      let e: number[] = tmp[j];
      if (((e[Math.trunc(0)] < min[Math.trunc(0)]) || ((e[Math.trunc(0)] == min[Math.trunc(0)]) && ((e[Math.trunc(1)] < min[Math.trunc(1)]) || ((e[Math.trunc(1)] == min[Math.trunc(1)]) && (e[Math.trunc(2)] < min[Math.trunc(2)])))))) {
        min = e;
        idx = j;
      }
      j = (j + 1);
    }
    res.push(min);
    let out: number[][] = [];
    let k: number = 0;
    while ((k < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
      if ((k != idx)) {
        out.push(tmp[k]);
      }
      k = (k + 1);
    }
    tmp = out;
  }
  return res;
}
function getEdgesFaces(points: Point[], faces: number[][]): Edge[] {
  let edges: number[][] = [];
  let fnum: number = 0;
  while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    let face: number[] = faces[fnum];
    let numP: number = (Array.isArray(face) || typeof face === 'string' ? face.length : Object.keys(face ?? {}).length);
    let pi: number = 0;
    while ((pi < numP)) {
      let pn1: number = face[pi];
      let pn2: number = 0;
      if ((pi < (numP - 1))) {
        pn2 = face[Math.trunc((pi + 1))];
      } else {
        pn2 = face[Math.trunc(0)];
      }
      if ((pn1 > pn2)) {
        let tmpn: number = pn1;
        pn1 = pn2;
        pn2 = tmpn;
      }
      edges.push([pn1, pn2, fnum]);
      pi = (pi + 1);
    }
    fnum = (fnum + 1);
  }
  edges = sortEdges(edges);
  let merged: number[][] = [];
  let idx: number = 0;
  while ((idx < (Array.isArray(edges) || typeof edges === 'string' ? edges.length : Object.keys(edges ?? {}).length))) {
    let e1: number[] = edges[idx];
    if ((idx < ((Array.isArray(edges) || typeof edges === 'string' ? edges.length : Object.keys(edges ?? {}).length) - 1))) {
      let e2: number[] = edges[Math.trunc((idx + 1))];
      if (((e1[Math.trunc(0)] == e2[Math.trunc(0)]) && (e1[Math.trunc(1)] == e2[Math.trunc(1)]))) {
        merged.push([e1[Math.trunc(0)], e1[Math.trunc(1)], e1[Math.trunc(2)], e2[Math.trunc(2)]]);
        idx = (idx + 2);
        continue
      }
    }
    merged.push([e1[Math.trunc(0)], e1[Math.trunc(1)], e1[Math.trunc(2)], -1]);
    idx = (idx + 1);
  }
  let edgesCenters: Edge[] = [];
  for (const me of merged) {
    let p1 = points[Math.trunc(me[Math.trunc(0)])];
    let p2 = points[Math.trunc(me[Math.trunc(1)])];
    let cp: Point = centerPoint(p1, p2);
    edgesCenters.push({"pn1": me[Math.trunc(0)], "pn2": me[Math.trunc(1)], "fn1": me[Math.trunc(2)], "fn2": me[Math.trunc(3)], cp});
  }
  return edgesCenters;
}
function getEdgePoints(points: Point[], edgesFaces: Edge[], facePoints: Point[]): Point[] {
  let edgePoints: Point[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(edgesFaces) || typeof edgesFaces === 'string' ? edgesFaces.length : Object.keys(edgesFaces ?? {}).length))) {
    let edge: Edge = edgesFaces[i];
    let cp: Point = edge.cp;
    let fp1: Point = facePoints[Math.trunc(edge.fn1)];
    let fp2: Point = fp1;
    if ((edge.fn2 != (0 - 1))) {
      fp2 = facePoints[Math.trunc(edge.fn2)];
    }
    let cfp: Point = centerPoint(fp1, fp2);
    edgePoints.push(centerPoint(cp, cfp));
    i = (i + 1);
  }
  return edgePoints;
}
function getAvgFacePoints(points: Point[], faces: number[][], facePoints: Point[]): Point[] {
  let numP: number = (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length);
  let temp: PointEx[] = [];
  let i: number = 0;
  while ((i < numP)) {
    temp.push({"p": {"x": 0.0, "y": 0.0, "z": 0.0}, "n": 0});
    i = (i + 1);
  }
  let fnum: number = 0;
  while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    let fp: Point = facePoints[fnum];
    for (const pn of faces[fnum]) {
      let tp = temp[pn];
      temp[pn] = {"p": sumPoint(tp.p, fp), "n": (tp.n + 1)};
    }
    fnum = (fnum + 1);
  }
  let avg: Point[] = [];
  let j: number = 0;
  while ((j < numP)) {
    let tp = temp[j];
    avg.push(divPoint(tp.p, tp.n));
    j = (j + 1);
  }
  return avg;
}
function getAvgMidEdges(points: Point[], edgesFaces: Edge[]): Point[] {
  let numP: number = (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length);
  let temp: PointEx[] = [];
  let i: number = 0;
  while ((i < numP)) {
    temp.push({"p": {"x": 0.0, "y": 0.0, "z": 0.0}, "n": 0});
    i = (i + 1);
  }
  for (const edge of edgesFaces) {
    let cp = edge.cp;
    let arr = [edge.pn1, edge.pn2];
    for (const pn of arr) {
      let tp = temp[pn];
      temp[pn] = {"p": sumPoint(tp.p, cp), "n": (tp.n + 1)};
    }
  }
  let avg: Point[] = [];
  let j: number = 0;
  while ((j < numP)) {
    let tp = temp[j];
    avg.push(divPoint(tp.p, tp.n));
    j = (j + 1);
  }
  return avg;
}
function getPointsFaces(points: Point[], faces: number[][]): number[] {
  let pf: number[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length))) {
    pf.push(0);
    i = (i + 1);
  }
  let fnum: number = 0;
  while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    for (const pn of faces[fnum]) {
      pf[pn] = (pf[pn] + 1);
    }
    fnum = (fnum + 1);
  }
  return pf;
}
function getNewPoints(points: Point[], pf: number[], afp: Point[], ame: Point[]): Point[] {
  let newPts: Point[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length))) {
    let n: number = pf[i];
    let m1: number = ((n - 3.0) / n);
    let m2: number = (1.0 / n);
    let m3: number = (2.0 / n);
    let old: Point = points[i];
    let p1: Point = mulPoint(old, m1);
    let p2: Point = mulPoint(afp[i], m2);
    let p3: Point = mulPoint(ame[i], m3);
    newPts.push(sumPoint(sumPoint(p1, p2), p3));
    i = (i + 1);
  }
  return newPts;
}
function key(a: number, b: number): string {
  if ((a < b)) {
    return ((String(a) + ",") + String(b));
  }
  return ((String(b) + ",") + String(a));
}
function cmcSubdiv(points: Point[], faces: number[][]): any[] {
  let facePoints: Point[] = getFacePoints(points, faces);
  let edgesFaces: Edge[] = getEdgesFaces(points, faces);
  let edgePoints: Point[] = getEdgePoints(points, edgesFaces, facePoints);
  let avgFacePoints: Point[] = getAvgFacePoints(points, faces, facePoints);
  let avgMidEdges: Point[] = getAvgMidEdges(points, edgesFaces);
  let pointsFaces: number[] = getPointsFaces(points, faces);
  let newPoints: Point[] = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges);
  let facePointNums: number[] = [];
  let nextPoint: number = (Array.isArray(newPoints) || typeof newPoints === 'string' ? newPoints.length : Object.keys(newPoints ?? {}).length);
  for (const fp of facePoints) {
    newPoints.push(fp);
    facePointNums.push(nextPoint);
    nextPoint = (nextPoint + 1);
  }
  let edgePointNums: Record<string, number> = {};
  let idx: number = 0;
  while ((idx < (Array.isArray(edgesFaces) || typeof edgesFaces === 'string' ? edgesFaces.length : Object.keys(edgesFaces ?? {}).length))) {
    let e: Edge = edgesFaces[idx];
    newPoints.push(edgePoints[idx]);
    edgePointNums[key(e.pn1, e.pn2)] = nextPoint;
    nextPoint = (nextPoint + 1);
    idx = (idx + 1);
  }
  let newFaces: number[][] = [];
  let fnum: number = 0;
  while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
    let oldFace: number[] = faces[fnum];
    if (((Array.isArray(oldFace) || typeof oldFace === 'string' ? oldFace.length : Object.keys(oldFace ?? {}).length) == 4)) {
      let a: number = oldFace[Math.trunc(0)];
      let b: number = oldFace[Math.trunc(1)];
      let c: number = oldFace[Math.trunc(2)];
      let d: number = oldFace[Math.trunc(3)];
      let fpnum: number = facePointNums[fnum];
      let ab: number = edgePointNums[key(a, b)];
      let da: number = edgePointNums[key(d, a)];
      let bc: number = edgePointNums[key(b, c)];
      let cd: number = edgePointNums[key(c, d)];
      newFaces.push([a, ab, fpnum, da]);
      newFaces.push([b, bc, fpnum, ab]);
      newFaces.push([c, cd, fpnum, bc]);
      newFaces.push([d, da, fpnum, cd]);
    }
    fnum = (fnum + 1);
  }
  return [newPoints, newFaces];
}
function formatPoint(p: Point): string {
  return (((((("[" + fmt4(p.x)) + " ") + fmt4(p.y)) + " ") + fmt4(p.z)) + "]");
}
function formatFace(f: number[]): string {
  if (((Array.isArray(f) || typeof f === 'string' ? f.length : Object.keys(f ?? {}).length) == 0)) {
    return "[]";
  }
  let s: string = ("[" + fmt2(f[Math.trunc(0)]));
  let i: number = 1;
  while ((i < (Array.isArray(f) || typeof f === 'string' ? f.length : Object.keys(f ?? {}).length))) {
    s = ((s + " ") + fmt2(f[i]));
    i = (i + 1);
  }
  s = (s + "]");
  return s;
}
function main() {
  let inputPoints: Point[] = [{"x": -1.0, "y": 1.0, "z": 1.0}, {"x": -1.0, "y": -1.0, "z": 1.0}, {"x": 1.0, "y": -1.0, "z": 1.0}, {"x": 1.0, "y": 1.0, "z": 1.0}, {"x": 1.0, "y": -1.0, "z": -1.0}, {"x": 1.0, "y": 1.0, "z": -1.0}, {"x": -1.0, "y": -1.0, "z": -1.0}, {"x": -1.0, "y": 1.0, "z": -1.0}];
  let inputFaces: number[][] = [[0, 1, 2, 3], [3, 2, 4, 5], [5, 4, 6, 7], [7, 0, 3, 5], [7, 6, 1, 0], [6, 1, 2, 4]];
  let outputPoints: Point[] = inputPoints;
  let outputFaces: number[][] = inputFaces;
  let i: number = 0;
  while ((i < 1)) {
    let res: any[] = cmcSubdiv(outputPoints, outputFaces);
    outputPoints = res[Math.trunc(0)];
    outputFaces = res[Math.trunc(1)];
    i = (i + 1);
  }
  for (const p of outputPoints) {
    console.log(formatPoint(p));
  }
  console.log("");
  for (const f of outputFaces) {
    console.log(formatFace(f));
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
{
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
}

