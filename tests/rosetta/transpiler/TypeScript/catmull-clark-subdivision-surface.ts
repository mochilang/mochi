// Generated by Mochi v0.10.40 on 2025-07-25 20:01:47 GMT+7

export interface Point { x: number; y: number; z: number }
export interface Edge { pn1: number; pn2: number; fn1: number; fn2: number; cp: Point }
export interface PointEx { p: Point; n: number }
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
{
  const _startMem = _mem()
  const _start = _now()
  function indexOf(s: string, ch: string): number {
    let i: number = 0;
    while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
      if (((s).substring(i, (i + 1)) == ch)) {
        return i;
      }
      i = (i + 1);
    }
    return -1;
  }
  function fmt4(x: number): string {
    let y: number = (x * 10000.0);
    if ((y >= 0)) {
      y = (y + 0.5);
    } else {
      y = (y - 0.5);
    }
    y = (Math.trunc(y) / 10000.0);
    let s: string = String(y);
    let dot: number = s.indexOf(".");
    if ((dot == (0 - 1))) {
      s = (s + ".0000");
    } else {
      let decs: number = (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) - dot) - 1);
      if ((decs > 4)) {
        s = (s).substring(0, (dot + 5));
      } else {
        while ((decs < 4)) {
          s = (s + "0");
          decs = (decs + 1);
        }
      }
    }
    if ((x >= 0.0)) {
      s = (" " + s);
    }
    return s;
  }
  function fmt2(n: number): string {
    const s: string = String(n);
    if (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < 2)) {
      return (" " + s);
    }
    return s;
  }
  function sumPoint(p1: Point, p2: Point): Point {
    return {"x": (p1.x + p2.x), "y": (p1.y + p2.y), "z": (p1.z + p2.z)};
  }
  function mulPoint(p: Point, m: number): Point {
    return {"x": (p.x * m), "y": (p.y * m), "z": (p.z * m)};
  }
  function divPoint(p: Point, d: number): Point {
    return mulPoint(p, (1.0 / d));
  }
  function centerPoint(p1: Point, p2: Point): Point {
    return divPoint(sumPoint(p1, p2), 2.0);
  }
  function getFacePoints(points: Point[], faces: number[][]): Point[] {
    let facePoints: Point[] = [];
    let i: number = 0;
    while ((i < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
      const face: number[] = faces[i];
      let fp: Point = {"x": 0.0, "y": 0.0, "z": 0.0};
      for (const idx of face) {
        fp = sumPoint(fp, points[idx]);
      }
      fp = divPoint(fp, (Array.isArray(face) || typeof face === 'string' ? face.length : Object.keys(face ?? {}).length));
      facePoints = [...facePoints, fp];
      i = (i + 1);
    }
    return facePoints;
  }
  function sortEdges(edges: number[][]): number[][] {
    let res: number[][] = [];
    let tmp: number[][] = edges;
    while (((Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length) > 0)) {
      let min: number[] = tmp[Math.trunc(0)];
      let idx: number = 0;
      let j: number = 1;
      while ((j < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
        const e: number[] = tmp[j];
        if (((e[Math.trunc(0)] < min[Math.trunc(0)]) || ((e[Math.trunc(0)] == min[Math.trunc(0)]) && ((e[Math.trunc(1)] < min[Math.trunc(1)]) || ((e[Math.trunc(1)] == min[Math.trunc(1)]) && (e[Math.trunc(2)] < min[Math.trunc(2)])))))) {
          min = e;
          idx = j;
        }
        j = (j + 1);
      }
      res = [...res, min];
      let out: number[][] = [];
      let k: number = 0;
      while ((k < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
        if ((k != idx)) {
          out = [...out, tmp[k]];
        }
        k = (k + 1);
      }
      tmp = out;
    }
    return res;
  }
  function getEdgesFaces(points: Point[], faces: number[][]): Edge[] {
    let edges: number[][] = [];
    let fnum: number = 0;
    while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
      const face: number[] = faces[fnum];
      let numP: number = (Array.isArray(face) || typeof face === 'string' ? face.length : Object.keys(face ?? {}).length);
      let pi: number = 0;
      while ((pi < numP)) {
        let pn1: number = face[pi];
        let pn2: number = 0;
        if ((pi < (numP - 1))) {
          pn2 = face[Math.trunc((pi + 1))];
        } else {
          pn2 = face[Math.trunc(0)];
        }
        if ((pn1 > pn2)) {
          let tmpn: number = pn1;
          pn1 = pn2;
          pn2 = tmpn;
        }
        edges = [...edges, [pn1, pn2, fnum]];
        pi = (pi + 1);
      }
      fnum = (fnum + 1);
    }
    edges = sortEdges(edges);
    let merged: number[][] = [];
    let idx: number = 0;
    while ((idx < (Array.isArray(edges) || typeof edges === 'string' ? edges.length : Object.keys(edges ?? {}).length))) {
      const e1: number[] = edges[idx];
      if ((idx < ((Array.isArray(edges) || typeof edges === 'string' ? edges.length : Object.keys(edges ?? {}).length) - 1))) {
        const e2: number[] = edges[Math.trunc((idx + 1))];
        if (((e1[Math.trunc(0)] == e2[Math.trunc(0)]) && (e1[Math.trunc(1)] == e2[Math.trunc(1)]))) {
          merged = [...merged, [e1[Math.trunc(0)], e1[Math.trunc(1)], e1[Math.trunc(2)], e2[Math.trunc(2)]]];
          idx = (idx + 2);
          continue
        }
      }
      merged = [...merged, [e1[Math.trunc(0)], e1[Math.trunc(1)], e1[Math.trunc(2)], -1]];
      idx = (idx + 1);
    }
    let edgesCenters: Edge[] = [];
    for (const me of merged) {
      const p1 = points[Math.trunc(me[Math.trunc(0)])];
      const p2 = points[Math.trunc(me[Math.trunc(1)])];
      const cp: Point = centerPoint(p1, p2);
      edgesCenters = [...edgesCenters, {"pn1": me[Math.trunc(0)], "pn2": me[Math.trunc(1)], "fn1": me[Math.trunc(2)], "fn2": me[Math.trunc(3)], cp}];
    }
    return edgesCenters;
  }
  function getEdgePoints(points: Point[], edgesFaces: Edge[], facePoints: Point[]): Point[] {
    let edgePoints: Point[] = [];
    let i: number = 0;
    while ((i < (Array.isArray(edgesFaces) || typeof edgesFaces === 'string' ? edgesFaces.length : Object.keys(edgesFaces ?? {}).length))) {
      const edge: Edge = edgesFaces[i];
      const cp: Point = edge.cp;
      const fp1: Point = facePoints[Math.trunc(edge.fn1)];
      let fp2: Point = fp1;
      if ((edge.fn2 != (0 - 1))) {
        fp2 = facePoints[Math.trunc(edge.fn2)];
      }
      const cfp: Point = centerPoint(fp1, fp2);
      edgePoints = [...edgePoints, centerPoint(cp, cfp)];
      i = (i + 1);
    }
    return edgePoints;
  }
  function getAvgFacePoints(points: Point[], faces: number[][], facePoints: Point[]): Point[] {
    let numP: number = (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length);
    let temp: PointEx[] = [];
    let i: number = 0;
    while ((i < numP)) {
      temp = [...temp, {"p": {"x": 0.0, "y": 0.0, "z": 0.0}, "n": 0}];
      i = (i + 1);
    }
    let fnum: number = 0;
    while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
      const fp: Point = facePoints[fnum];
      for (const pn of faces[fnum]) {
        const tp = temp[pn];
        temp[pn] = {"p": sumPoint(tp.p, fp), "n": (tp.n + 1)};
      }
      fnum = (fnum + 1);
    }
    let avg: Point[] = [];
    let j: number = 0;
    while ((j < numP)) {
      const tp = temp[j];
      avg = [...avg, divPoint(tp.p, tp.n)];
      j = (j + 1);
    }
    return avg;
  }
  function getAvgMidEdges(points: Point[], edgesFaces: Edge[]): Point[] {
    let numP: number = (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length);
    let temp: PointEx[] = [];
    let i: number = 0;
    while ((i < numP)) {
      temp = [...temp, {"p": {"x": 0.0, "y": 0.0, "z": 0.0}, "n": 0}];
      i = (i + 1);
    }
    for (const edge of edgesFaces) {
      const cp = edge.cp;
      let arr = [edge.pn1, edge.pn2];
      for (const pn of arr) {
        const tp = temp[pn];
        temp[pn] = {"p": sumPoint(tp.p, cp), "n": (tp.n + 1)};
      }
    }
    let avg: Point[] = [];
    let j: number = 0;
    while ((j < numP)) {
      const tp = temp[j];
      avg = [...avg, divPoint(tp.p, tp.n)];
      j = (j + 1);
    }
    return avg;
  }
  function getPointsFaces(points: Point[], faces: number[][]): number[] {
    let pf: number[] = [];
    let i: number = 0;
    while ((i < (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length))) {
      pf = [...pf, 0];
      i = (i + 1);
    }
    let fnum: number = 0;
    while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
      for (const pn of faces[fnum]) {
        pf[pn] = (pf[pn] + 1);
      }
      fnum = (fnum + 1);
    }
    return pf;
  }
  function getNewPoints(points: Point[], pf: number[], afp: Point[], ame: Point[]): Point[] {
    let newPts: Point[] = [];
    let i: number = 0;
    while ((i < (Array.isArray(points) || typeof points === 'string' ? points.length : Object.keys(points ?? {}).length))) {
      let n: number = pf[i];
      let m1: number = ((n - 3.0) / n);
      let m2: number = (1.0 / n);
      let m3: number = (2.0 / n);
      const old: Point = points[i];
      const p1: Point = mulPoint(old, m1);
      const p2: Point = mulPoint(afp[i], m2);
      const p3: Point = mulPoint(ame[i], m3);
      newPts = [...newPts, sumPoint(sumPoint(p1, p2), p3)];
      i = (i + 1);
    }
    return newPts;
  }
  function key(a: number, b: number): string {
    if ((a < b)) {
      return ((String(a) + ",") + String(b));
    }
    return ((String(b) + ",") + String(a));
  }
  function cmcSubdiv(points: Point[], faces: number[][]): any[] {
    const facePoints: Point[] = getFacePoints(points, faces);
    const edgesFaces: Edge[] = getEdgesFaces(points, faces);
    const edgePoints: Point[] = getEdgePoints(points, edgesFaces, facePoints);
    const avgFacePoints: Point[] = getAvgFacePoints(points, faces, facePoints);
    const avgMidEdges: Point[] = getAvgMidEdges(points, edgesFaces);
    const pointsFaces: number[] = getPointsFaces(points, faces);
    let newPoints: Point[] = getNewPoints(points, pointsFaces, avgFacePoints, avgMidEdges);
    let facePointNums: number[] = [];
    let nextPoint: number = (Array.isArray(newPoints) || typeof newPoints === 'string' ? newPoints.length : Object.keys(newPoints ?? {}).length);
    for (const fp of facePoints) {
      newPoints = [...newPoints, fp];
      facePointNums = [...facePointNums, nextPoint];
      nextPoint = (nextPoint + 1);
    }
    let edgePointNums: Record<string, number> = {};
    let idx: number = 0;
    while ((idx < (Array.isArray(edgesFaces) || typeof edgesFaces === 'string' ? edgesFaces.length : Object.keys(edgesFaces ?? {}).length))) {
      const e: Edge = edgesFaces[idx];
      newPoints = [...newPoints, edgePoints[idx]];
      edgePointNums[key(e.pn1, e.pn2)] = nextPoint;
      nextPoint = (nextPoint + 1);
      idx = (idx + 1);
    }
    let newFaces: number[][] = [];
    let fnum: number = 0;
    while ((fnum < (Array.isArray(faces) || typeof faces === 'string' ? faces.length : Object.keys(faces ?? {}).length))) {
      const oldFace: number[] = faces[fnum];
      if (((Array.isArray(oldFace) || typeof oldFace === 'string' ? oldFace.length : Object.keys(oldFace ?? {}).length) == 4)) {
        const a: number = oldFace[Math.trunc(0)];
        const b: number = oldFace[Math.trunc(1)];
        const c: number = oldFace[Math.trunc(2)];
        const d: number = oldFace[Math.trunc(3)];
        const fpnum: number = facePointNums[fnum];
        const ab: number = edgePointNums[key(a, b)];
        const da: number = edgePointNums[key(d, a)];
        const bc: number = edgePointNums[key(b, c)];
        const cd: number = edgePointNums[key(c, d)];
        newFaces = [...newFaces, [a, ab, fpnum, da]];
        newFaces = [...newFaces, [b, bc, fpnum, ab]];
        newFaces = [...newFaces, [c, cd, fpnum, bc]];
        newFaces = [...newFaces, [d, da, fpnum, cd]];
      }
      fnum = (fnum + 1);
    }
    return [newPoints, newFaces];
  }
  function formatPoint(p: Point): string {
    return (((((("[" + fmt4(p.x)) + " ") + fmt4(p.y)) + " ") + fmt4(p.z)) + "]");
  }
  function formatFace(f: number[]): string {
    if (((Array.isArray(f) || typeof f === 'string' ? f.length : Object.keys(f ?? {}).length) == 0)) {
      return "[]";
    }
    let s: string = ("[" + fmt2(f[Math.trunc(0)]));
    let i: number = 1;
    while ((i < (Array.isArray(f) || typeof f === 'string' ? f.length : Object.keys(f ?? {}).length))) {
      s = ((s + " ") + fmt2(f[i]));
      i = (i + 1);
    }
    s = (s + "]");
    return s;
  }
  function main() {
    const inputPoints: Point[] = [{"x": -1.0, "y": 1.0, "z": 1.0}, {"x": -1.0, "y": -1.0, "z": 1.0}, {"x": 1.0, "y": -1.0, "z": 1.0}, {"x": 1.0, "y": 1.0, "z": 1.0}, {"x": 1.0, "y": -1.0, "z": -1.0}, {"x": 1.0, "y": 1.0, "z": -1.0}, {"x": -1.0, "y": -1.0, "z": -1.0}, {"x": -1.0, "y": 1.0, "z": -1.0}];
    const inputFaces: number[][] = [[0, 1, 2, 3], [3, 2, 4, 5], [5, 4, 6, 7], [7, 0, 3, 5], [7, 6, 1, 0], [6, 1, 2, 4]];
    let outputPoints: Point[] = inputPoints;
    let outputFaces: number[][] = inputFaces;
    let i: number = 0;
    while ((i < 1)) {
      const res: any[] = cmcSubdiv(outputPoints, outputFaces);
      outputPoints = res[Math.trunc(0)];
      outputFaces = res[Math.trunc(1)];
      i = (i + 1);
    }
    for (const p of outputPoints) {
      console.log(formatPoint(p));
    }
    console.log("");
    for (const f of outputFaces) {
      console.log(formatFace(f));
    }
  }
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
}

