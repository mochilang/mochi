// Generated by Mochi v0.10.41 on 2025-07-26 17:32:56 GMT+7

export interface Point { x: number; y: number }
export interface Triangle { p1: Point; p2: Point; p3: Point }
function fmt1(f: number): string {
  let s: string = String(f);
  let idx: number = s.indexOf(".");
  if ((idx < 0)) {
    s = (s + ".0");
  } else {
    let need: number = (idx + 2);
    if (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) > need)) {
      s = (s).substring(0, need);
    } else {
      while (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < need)) {
        s = (s + "0");
      }
    }
  }
  return s;
}
function pointStr(p: Point): string {
  return (((("(" + fmt1(p.x)) + ", ") + fmt1(p.y)) + ")");
}
function triangleStr(t: Triangle): string {
  return ((((("Triangle " + pointStr(t.p1)) + ", ") + pointStr(t.p2)) + ", ") + pointStr(t.p3));
}
function orient(a: Point, b: Point, c: Point): number {
  return (((b.x - a.x) * (c.y - a.y)) - ((b.y - a.y) * (c.x - a.x)));
}
function pointInTri(p: Point, t: Triangle, onBoundary: boolean): boolean {
  let d1: number = orient(p, t.p1, t.p2);
  let d2: number = orient(p, t.p2, t.p3);
  let d3: number = orient(p, t.p3, t.p1);
  let hasNeg: boolean = (((d1 < 0.0) || (d2 < 0.0)) || (d3 < 0.0));
  let hasPos: boolean = (((d1 > 0.0) || (d2 > 0.0)) || (d3 > 0.0));
  if (onBoundary) {
    return !(hasNeg && hasPos);
  }
  return (((!(hasNeg && hasPos) && (d1 != 0.0)) && (d2 != 0.0)) && (d3 != 0.0));
}
function edgeCheck(a0: Point, a1: Point, bs: Point[], onBoundary: boolean): boolean {
  let d0: number = orient(a0, a1, bs[Math.trunc(0)]);
  let d1: number = orient(a0, a1, bs[Math.trunc(1)]);
  let d2: number = orient(a0, a1, bs[Math.trunc(2)]);
  if (onBoundary) {
    return (((d0 <= 0.0) && (d1 <= 0.0)) && (d2 <= 0.0));
  }
  return (((d0 < 0.0) && (d1 < 0.0)) && (d2 < 0.0));
}
function triTri2D(t1: Triangle, t2: Triangle, onBoundary: boolean): boolean {
  let a: Point[] = [t1.p1, t1.p2, t1.p3];
  let b: Point[] = [t2.p1, t2.p2, t2.p3];
  let i: number = 0;
  while ((i < 3)) {
    let j: number = ((i + 1) % 3);
    if (edgeCheck(a[i], a[j], b, onBoundary)) {
      return false;
    }
    i = (i + 1);
  }
  i = 0;
  while ((i < 3)) {
    let j: number = ((i + 1) % 3);
    if (edgeCheck(b[i], b[j], a, onBoundary)) {
      return false;
    }
    i = (i + 1);
  }
  return true;
}
function iff(cond: boolean, a: string, b: string): string {
  if (cond) {
    return a;
  } else {
    return b;
  }
}
function main() {
  let t1: Triangle = {"p1": {"x": 0.0, "y": 0.0}, "p2": {"x": 5.0, "y": 0.0}, "p3": {"x": 0.0, "y": 5.0}};
  let t2: Triangle = {"p1": {"x": 0.0, "y": 0.0}, "p2": {"x": 5.0, "y": 0.0}, "p3": {"x": 0.0, "y": 6.0}};
  console.log((triangleStr(t1) + " and"));
  console.log(triangleStr(t2));
  let overlapping: boolean = triTri2D(t1, t2, true);
  console.log(iff(overlapping, "overlap", "do not overlap"));
  console.log("");
  t1 = {"p1": {"x": 0.0, "y": 0.0}, "p2": {"x": 0.0, "y": 5.0}, "p3": {"x": 5.0, "y": 0.0}};
  t2 = t1;
  console.log((triangleStr(t1) + " and"));
  console.log(triangleStr(t2));
  overlapping = triTri2D(t1, t2, true);
  console.log(iff(overlapping, "overlap (reversed)", "do not overlap"));
  console.log("");
  t1 = {"p1": {"x": 0.0, "y": 0.0}, "p2": {"x": 5.0, "y": 0.0}, "p3": {"x": 0.0, "y": 5.0}};
  t2 = {"p1": {"x": -10.0, "y": 0.0}, "p2": {"x": -5.0, "y": 0.0}, "p3": {"x": -1.0, "y": 6.0}};
  console.log((triangleStr(t1) + " and"));
  console.log(triangleStr(t2));
  overlapping = triTri2D(t1, t2, true);
  console.log(iff(overlapping, "overlap", "do not overlap"));
  console.log("");
  t1.p3 = {"x": 2.5, "y": 5.0};
  t2 = {"p1": {"x": 0.0, "y": 4.0}, "p2": {"x": 2.5, "y": -1.0}, "p3": {"x": 5.0, "y": 4.0}};
  console.log((triangleStr(t1) + " and"));
  console.log(triangleStr(t2));
  overlapping = triTri2D(t1, t2, true);
  console.log(iff(overlapping, "overlap", "do not overlap"));
  console.log("");
  t1 = {"p1": {"x": 0.0, "y": 0.0}, "p2": {"x": 1.0, "y": 1.0}, "p3": {"x": 0.0, "y": 2.0}};
  t2 = {"p1": {"x": 2.0, "y": 1.0}, "p2": {"x": 3.0, "y": 0.0}, "p3": {"x": 3.0, "y": 2.0}};
  console.log((triangleStr(t1) + " and"));
  console.log(triangleStr(t2));
  overlapping = triTri2D(t1, t2, true);
  console.log(iff(overlapping, "overlap", "do not overlap"));
  console.log("");
  t2 = {"p1": {"x": 2.0, "y": 1.0}, "p2": {"x": 3.0, "y": -2.0}, "p3": {"x": 3.0, "y": 4.0}};
  console.log((triangleStr(t1) + " and"));
  console.log(triangleStr(t2));
  overlapping = triTri2D(t1, t2, true);
  console.log(iff(overlapping, "overlap", "do not overlap"));
  console.log("");
  t1 = {"p1": {"x": 0.0, "y": 0.0}, "p2": {"x": 1.0, "y": 0.0}, "p3": {"x": 0.0, "y": 1.0}};
  t2 = {"p1": {"x": 1.0, "y": 0.0}, "p2": {"x": 2.0, "y": 0.0}, "p3": {"x": 1.0, "y": 1.1}};
  console.log((triangleStr(t1) + " and"));
  console.log(triangleStr(t2));
  console.log("which have only a single corner in contact, if boundary points collide");
  overlapping = triTri2D(t1, t2, true);
  console.log(iff(overlapping, "overlap", "do not overlap"));
  console.log("");
  console.log((triangleStr(t1) + " and"));
  console.log(triangleStr(t2));
  console.log("which have only a single corner in contact, if boundary points do not collide");
  overlapping = triTri2D(t1, t2, false);
  console.log(iff(overlapping, "overlap", "do not overlap"));
}
main();
