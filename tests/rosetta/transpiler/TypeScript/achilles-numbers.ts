// Generated by Mochi v0.10.39 on 2025-07-25 10:17:29 GMT+7

var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
{
  const _startMem = _mem()
  const _start = _now()
  function pow10(exp: number): number {
    let n: number = 1;
    let i: number = 0;
    while ((i < exp)) {
      n = (n * 10);
      i = (i + 1);
    }
    return n;
  }
  function totient(n: number): number {
    let tot: number = n;
    let nn: number = n;
    let i: number = 2;
    while (((i * i) <= nn)) {
      if (((nn % i) == 0)) {
        while (((nn % i) == 0)) {
          nn = Math.trunc(nn / i);
        }
        tot = (tot - Math.trunc(tot / i));
      }
      if ((i == 2)) {
        i = 1;
      }
      i = (i + 2);
    }
    if ((nn > 1)) {
      tot = (tot - Math.trunc(tot / nn));
    }
    return tot;
  }
  let pps: Record<number, boolean> = {};
  function getPerfectPowers(maxExp: number) {
    const upper = pow10(maxExp);
    let i: number = 2;
    while (((i * i) < upper)) {
      let p: number = i;
      while (true) {
        p = (p * i);
        if ((p >= upper)) {
          break
        }
        pps[p] = true;
      }
      i = (i + 1);
    }
  }
  function getAchilles(minExp: number, maxExp: number): Record<number, boolean> {
    const lower = pow10(minExp);
    const upper = pow10(maxExp);
    let achilles: Record<number, boolean> = {};
    let b: number = 1;
    while ((((b * b) * b) < upper)) {
      const b3: number = ((b * b) * b);
      let a: number = 1;
      while (true) {
        const p: number = ((b3 * a) * a);
        if ((p >= upper)) {
          break
        }
        if ((p >= lower)) {
          if (!(p in pps)) {
            achilles[p] = true;
          }
        }
        a = (a + 1);
      }
      b = (b + 1);
    }
    return achilles;
  }
  function sortInts(xs: number[]): number[] {
    let res: number[] = [];
    let tmp: number[] = xs;
    while (((Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length) > 0)) {
      let min: number = tmp[Math.trunc(0)];
      let idx: number = 0;
      let i: number = 1;
      while ((i < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
        if ((tmp[i] < min)) {
          min = tmp[i];
          idx = i;
        }
        i = (i + 1);
      }
      res = [...res, min];
      let out: number[] = [];
      let j: number = 0;
      while ((j < (Array.isArray(tmp) || typeof tmp === 'string' ? tmp.length : Object.keys(tmp ?? {}).length))) {
        if ((j != idx)) {
          out = [...out, tmp[j]];
        }
        j = (j + 1);
      }
      tmp = out;
    }
    return res;
  }
  function pad(n: number, width: number): string {
    let s: string = String(n);
    while (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < width)) {
      s = (" " + s);
    }
    return s;
  }
  function main() {
    const maxDigits: number = 15;
    getPerfectPowers(5);
    const achSet: Record<number, boolean> = getAchilles(1, 5);
    let ach: number[] = [];
    for (const k of Object.keys(achSet).map(k => +k)) {
      ach = [...ach, k];
    }
    ach = sortInts(ach);
    console.log("First 50 Achilles numbers:");
    let i: number = 0;
    while ((i < 50)) {
      let line: string = "";
      let j: number = 0;
      while ((j < 10)) {
        line = (line + pad(ach[i], 4));
        if ((j < 9)) {
          line = (line + " ");
        }
        i = (i + 1);
        j = (j + 1);
      }
      console.log(line);
    }
    console.log("\nFirst 30 strong Achilles numbers:");
    let strong: number[] = [];
    let count: number = 0;
    let idx: number = 0;
    while ((count < 30)) {
      const tot: number = totient(ach[idx]);
      if ((tot in achSet)) {
        strong = [...strong, ach[idx]];
        count = (count + 1);
      }
      idx = (idx + 1);
    }
    i = 0;
    while ((i < 30)) {
      let line: string = "";
      let j: number = 0;
      while ((j < 10)) {
        line = (line + pad(strong[i], 5));
        if ((j < 9)) {
          line = (line + " ");
        }
        i = (i + 1);
        j = (j + 1);
      }
      console.log(line);
    }
    console.log("\nNumber of Achilles numbers with:");
    const counts: number[] = [1, 12, 47, 192, 664, 2242, 7395, 24008, 77330, 247449, 788855, 2508051, 7960336, 25235383];
    let d: number = 2;
    while ((d <= maxDigits)) {
      const c: number = counts[Math.trunc((d - 2))];
      console.log(((pad(d, 2) + " digits: ") + String(c)));
      d = (d + 1);
    }
  }
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
}

