// Generated by Mochi v0.10.42 on 2025-07-27 18:45:24 GMT+7

function sieve(limit: number): number[] {
  let spf: number[] = [];
  let i: number = 0;
  while ((i <= limit)) {
    spf.push(0);
    i = (i + 1);
  }
  i = 2;
  while ((i <= limit)) {
    if ((spf[i] == 0)) {
      spf[i] = i;
      if (((i * i) <= limit)) {
        let j: number = (i * i);
        while ((j <= limit)) {
          if ((spf[j] == 0)) {
            spf[j] = i;
          }
          j = (j + i);
        }
      }
    }
    i = (i + 1);
  }
  return spf;
}
function primesFrom(spf: number[], limit: number): number[] {
  let primes: number[] = [];
  let i: number = 3;
  while ((i <= limit)) {
    if ((spf[i] == i)) {
      primes.push(i);
    }
    i = (i + 1);
  }
  return primes;
}
function pad3(n: number): string {
  let s: string = String(n);
  while (((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) < 3)) {
    s = (" " + s);
  }
  return s;
}
function commatize(n: number): string {
  let s: string = String(n);
  let out: string = "";
  let i: number = ((Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length) - 1);
  let c: number = 0;
  while ((i >= 0)) {
    out = ((s).substring(i, (i + 1)) + out);
    c = (c + 1);
    if ((((c % 3) == 0) && (i > 0))) {
      out = ("," + out);
    }
    i = (i - 1);
  }
  return out;
}
function primeCount(primes: number[], last: number, spf: number[]): number {
  let lo: number = 0;
  let hi: number = (Array.isArray(primes) || typeof primes === 'string' ? primes.length : Object.keys(primes ?? {}).length);
  while ((lo < hi)) {
    let mid: number = Math.trunc(Math.trunc((lo + hi) / 2));
    if ((primes[mid] < last)) {
      lo = (mid + 1);
    } else {
      hi = mid;
    }
  }
  let count: number = (lo + 1);
  if ((spf[last] != last)) {
    count = (count - 1);
  }
  return count;
}
function arithmeticNumbers(limit: number, spf: number[]): number[] {
  let arr: number[] = [1];
  let n: number = 3;
  while (((Array.isArray(arr) || typeof arr === 'string' ? arr.length : Object.keys(arr ?? {}).length) < limit)) {
    if ((spf[n] == n)) {
      arr.push(n);
    } else {
      let x: number = n;
      let sigma: number = 1;
      let tau: number = 1;
      while ((x > 1)) {
        let p: number = spf[x];
        if ((p == 0)) {
          p = x;
        }
        let cnt: number = 0;
        let power: number = p;
        let sum: number = 1;
        while (((x % p) == 0)) {
          x = Math.trunc(x / p);
          cnt = (cnt + 1);
          sum = (sum + power);
          power = (power * p);
        }
        sigma = (sigma * sum);
        tau = (tau * (cnt + 1));
      }
      if (((sigma % tau) == 0)) {
        arr.push(n);
      }
    }
    n = (n + 1);
  }
  return arr;
}
function main() {
  let limit: number = 1228663;
  let spf: number[] = sieve(limit);
  let primes: number[] = primesFrom(spf, limit);
  let arr: number[] = arithmeticNumbers(1000000, spf);
  console.log("The first 100 arithmetic numbers are:");
  let i: number = 0;
  while ((i < 100)) {
    let line: string = "";
    let j: number = 0;
    while ((j < 10)) {
      line = (line + pad3(arr[Math.trunc((i + j))]));
      if ((j < 9)) {
        line = (line + " ");
      }
      j = (j + 1);
    }
    console.log(line);
    i = (i + 10);
  }
  for (const x of [1000, 10000, 100000, 1000000]) {
    let last: number = arr[Math.trunc((x - 1))];
    let lastc: string = commatize(last);
    console.log(((("\nThe " + commatize(x)) + "th arithmetic number is: ") + lastc));
    let pc: number = primeCount(primes, last, spf);
    let comp: number = ((x - pc) - 1);
    console.log((((("The count of such numbers <= " + lastc) + " which are composite is ") + commatize(comp)) + "."));
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
(() => {
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

