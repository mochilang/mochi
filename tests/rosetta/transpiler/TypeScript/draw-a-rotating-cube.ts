// Generated by Mochi v0.10.57 on 2025-08-04 19:46:25 GMT+7

let PI: number = 3.141592653589793;
let TWO_PI: number = 6.283185307179586;
function _mod(x: number, m: number): number {
  return (x - (Math.trunc((x / m)) * m));
}
function _sin(x: number): number {
  let y: number = (_mod((x + PI), TWO_PI) - PI);
  let y2: number = (y * y);
  let y3: number = (y2 * y);
  let y5: number = (y3 * y2);
  let y7: number = (y5 * y2);
  return (((y - (y3 / 6.0)) + (y5 / 120.0)) - (y7 / 5040.0));
}
function _cos(x: number): number {
  let y: number = (_mod((x + PI), TWO_PI) - PI);
  let y2: number = (y * y);
  let y4: number = (y2 * y2);
  let y6: number = (y4 * y2);
  return (((1.0 - (y2 / 2.0)) + (y4 / 24.0)) - (y6 / 720.0));
}
export interface Point3 { x: number; y: number; z: number }
export interface Point2 { x: number; y: number }
let edges: number[][] = [[0, 1], [1, 3], [3, 2], [2, 0], [4, 5], [5, 7], [7, 6], [6, 4], [0, 4], [1, 5], [2, 6], [3, 7]];
function rotate(p: Point3, ax: number, ay: number): Point3 {
  let sinx: number = _sin(ax);
  let cosx: number = _cos(ax);
  let siny: number = _sin(ay);
  let cosy: number = _cos(ay);
  let x1: number = p.x;
  let y1: number = ((p.y * cosx) - (p.z * sinx));
  let z1: number = ((p.y * sinx) + (p.z * cosx));
  let x2: number = ((x1 * cosy) + (z1 * siny));
  let z2: number = ((-x1 * siny) + (z1 * cosy));
  return {"x": x2, "y": y1, "z": z2};
}
let width: number = 40;
let height: number = 20;
let distance: number = 3.0;
let scale: number = 8.0;
function project(p: Point3): Point2 {
  let factor: number = (scale / (p.z + distance));
  let x: number = (Math.trunc((p.x * factor)) + Math.trunc(width / 2));
  let y: number = (Math.trunc((-p.y * factor)) + Math.trunc(height / 2));
  return {x, y};
}
function clearGrid(): string[][] {
  let g: string[][] = [];
  let y: number = 0;
  while ((y < height)) {
    let row: string[] = [];
    let x: number = 0;
    while ((x < width)) {
      row.push(" ");
      x = (x + 1);
    }
    g.push(row);
    y = (y + 1);
  }
  return g;
}
function drawPoint(g: string[][], x: number, y: number, ch: string) {
  if (((((x >= 0) && (x < width)) && (y >= 0)) && (y < height))) {
    let row: string[] = g[y];
    row[x] = ch;
    g[y] = row;
  }
}
function bresenham(x0: number, y0: number, x1: number, y1: number, g: string[][], ch: string) {
  let dx: number = (x1 - x0);
  if ((dx < 0)) {
    dx = -dx;
  }
  let dy: number = (y1 - y0);
  if ((dy < 0)) {
    dy = -dy;
  }
  let sx: number = -1;
  if ((x0 < x1)) {
    sx = 1;
  }
  let sy: number = -1;
  if ((y0 < y1)) {
    sy = 1;
  }
  let err: number = (dx - dy);
  while (true) {
    drawPoint(g, x0, y0, ch);
    if (((x0 == x1) && (y0 == y1))) {
      break
    }
    let e2: number = (2 * err);
    if ((e2 > -dy)) {
      err = (err - dy);
      x0 = (x0 + sx);
    }
    if ((e2 < dx)) {
      err = (err + dx);
      y0 = (y0 + sy);
    }
  }
}
function render(g: string[][]): string {
  let out: string = "";
  let y: number = 0;
  while ((y < height)) {
    let line: string = "";
    let x: number = 0;
    while ((x < width)) {
      line = (line + g[y][x]);
      x = (x + 1);
    }
    out = ((out + line) + "\n");
    y = (y + 1);
  }
  return out;
}
function main() {
  let f: number = 0;
  while ((f < 10)) {
    let grid: string[][] = clearGrid();
    let rot: Point2[] = [];
    let i: number = 0;
    let ay: number = ((PI / 4.0) + ((f * PI) / 10.0));
    while ((i < Number(Array.isArray(nodes) || typeof nodes === 'string' ? nodes.length : Object.keys(nodes ?? {}).length))) {
      let p: Point3 = rotate(nodes[i], (PI / 4.0), ay);
      let pp: Point2 = project(p);
      rot.push(pp);
      i = (i + 1);
    }
    let e: number = 0;
    while ((e < Number(Array.isArray(edges) || typeof edges === 'string' ? edges.length : Object.keys(edges ?? {}).length))) {
      let a: number = edges[e][Math.trunc(0)];
      let b: number = edges[e][Math.trunc(1)];
      let p1: Point2 = rot[a];
      let p2: Point2 = rot[b];
      bresenham(p1.x, p1.y, p2.x, p2.y, grid, "#");
      e = (e + 1);
    }
    console.log(_str(render(grid)));
    f = (f + 1);
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
let nodes: Point3[]
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
nodes = [{"x": -1.0, "y": -1.0, "z": -1.0}, {"x": -1.0, "y": -1.0, "z": 1.0}, {"x": -1.0, "y": 1.0, "z": -1.0}, {"x": -1.0, "y": 1.0, "z": 1.0}, {"x": 1.0, "y": -1.0, "z": -1.0}, {"x": 1.0, "y": -1.0, "z": 1.0}, {"x": 1.0, "y": 1.0, "z": -1.0}, {"x": 1.0, "y": 1.0, "z": 1.0}]
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

