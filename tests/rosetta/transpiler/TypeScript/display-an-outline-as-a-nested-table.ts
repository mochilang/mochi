// Generated by Mochi v0.10.41 on 2025-07-26 19:37:09 GMT+7

export interface Child { name: any; children: any[] }
export interface N { name: string; children: any[] }
export interface N2 { name: string; children: any[] }
function split(s: string, sep: string): string[] {
  let out: string[] = [];
  let cur: string = "";
  let i: number = 0;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    if ((((i + (Array.isArray(sep) || typeof sep === 'string' ? sep.length : Object.keys(sep ?? {}).length)) <= (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length)) && ((s).substring(i, (i + (Array.isArray(sep) || typeof sep === 'string' ? sep.length : Object.keys(sep ?? {}).length))) == sep))) {
      out.push(cur);
      cur = "";
      i = (i + (Array.isArray(sep) || typeof sep === 'string' ? sep.length : Object.keys(sep ?? {}).length));
    } else {
      cur = (cur + (s).substring(i, (i + 1)));
      i = (i + 1);
    }
  }
  out.push(cur);
  return out;
}
function join(xs: string[], sep: string): string {
  let res: string = "";
  let i: number = 0;
  while ((i < (Array.isArray(xs) || typeof xs === 'string' ? xs.length : Object.keys(xs ?? {}).length))) {
    if ((i > 0)) {
      res = (res + sep);
    }
    res = (res + xs[i]);
    i = (i + 1);
  }
  return res;
}
function trimLeftSpaces(s: string): string {
  let i: number = 0;
  while (((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length)) && (s.slice(i, (i + 1)) == " "))) {
    i = (i + 1);
  }
  return s.slice(i, (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length));
}
function makeIndent(outline: string, tab: number): Record<string, any>[] {
  let lines: string[] = outline.split("\n");
  let nodes: Record<string, any>[] = [];
  for (const line of lines) {
    let line2: string = trimLeftSpaces(line);
    let level: number = Math.trunc(((Array.isArray(line) || typeof line === 'string' ? line.length : Object.keys(line ?? {}).length) - (Array.isArray(line2) || typeof line2 === 'string' ? line2.length : Object.keys(line2 ?? {}).length)) / tab);
    nodes.push({level, "name": line2});
  }
  return nodes;
}
function toNest(nodes: Record<string, any>[], start: number, level: number, n: Record<string, any>) {
  if ((level == 0)) {
    n.name = nodes[Math.trunc(0)].name;
  }
  let i: number = (start + 1);
  while ((i < (Array.isArray(nodes) || typeof nodes === 'string' ? nodes.length : Object.keys(nodes ?? {}).length))) {
    let node: Record<string, any> = nodes[i];
    let lev: number = Math.trunc(node.level);
    if ((lev == (level + 1))) {
      let child: Child = {"name": node.name, "children": []};
      toNest(nodes, i, (level + 1), child);
      let cs: any[] = n.children;
      cs.push(child);
      n.children = cs;
    } else {
      if ((lev <= level)) {
        return;
      }
    }
    i = (i + 1);
  }
}
function countLeaves(n: Record<string, any>): number {
  let kids: any[] = n.children;
  if (((Array.isArray(kids) || typeof kids === 'string' ? kids.length : Object.keys(kids ?? {}).length) == 0)) {
    return 1;
  }
  let total: number = 0;
  for (const k of kids) {
    total = (total + countLeaves(k));
  }
  return total;
}
function nodesByDepth(root: Record<string, any>, depth: number): Record<string, any>[][] {
  let levels: Record<string, any>[][] = [];
  let current: Record<string, any>[] = [root];
  let d: number = 0;
  while ((d < depth)) {
    levels.push(current);
    let next: Record<string, any>[] = [];
    for (const n of current) {
      let kids: any[] = n.children;
      for (const k of kids) {
        next.push(k);
      }
    }
    current = next;
    d = (d + 1);
  }
  return levels;
}
function toMarkup(n: Record<string, any>, cols: string[], depth: number): string {
  let lines: string[] = [];
  lines.push("{| class=\"wikitable\" style=\"text-align: center;\"");
  let l1: string = "|-";
  lines.push(l1);
  let span: number = countLeaves(n);
  lines.push(((((("| style=\"background: " + cols[Math.trunc(0)]) + " \" colSpan=") + String(span)) + " | ") + n.name));
  lines.push(l1);
  let lvls: Record<string, any>[][] = nodesByDepth(n, depth);
  let lvl: number = 1;
  while ((lvl < depth)) {
    let nodes: Record<string, any>[] = lvls[lvl];
    if (((Array.isArray(nodes) || typeof nodes === 'string' ? nodes.length : Object.keys(nodes ?? {}).length) == 0)) {
      lines.push("|  |");
    } else {
      let idx: number = 0;
      while ((idx < (Array.isArray(nodes) || typeof nodes === 'string' ? nodes.length : Object.keys(nodes ?? {}).length))) {
        let node: Record<string, any> = nodes[idx];
        span = countLeaves(node);
        let col: number = lvl;
        if ((lvl == 1)) {
          col = (idx + 1);
        }
        if ((col >= (Array.isArray(cols) || typeof cols === 'string' ? cols.length : Object.keys(cols ?? {}).length))) {
          col = ((Array.isArray(cols) || typeof cols === 'string' ? cols.length : Object.keys(cols ?? {}).length) - 1);
        }
        let cell: string = ((((("| style=\"background: " + cols[col]) + " \" colspan=") + String(span)) + " | ") + node.name);
        lines.push(cell);
        idx = (idx + 1);
      }
    }
    if ((lvl < (depth - 1))) {
      lines.push(l1);
    }
    lvl = (lvl + 1);
  }
  lines.push("|}");
  return join(lines, "\n");
}
function main() {
  let outline: string = ((((((((((("Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n") + "        measuring the indent of each line,\n") + "        translating the indentation to a nested structure,\n") + "        and padding the tree to even depth.\n") + "    count the leaves descending from each node,\n") + "        defining the width of a leaf as 1,\n") + "        and the width of a parent node as a sum.\n") + "            (The sum of the widths of its children)\n") + "    and write out a table with 'colspan' values\n") + "        either as a wiki table,\n") + "        or as HTML.");
  let yellow: string = "#ffffe6;";
  let orange: string = "#ffebd2;";
  let green: string = "#f0fff0;";
  let blue: string = "#e6ffff;";
  let pink: string = "#ffeeff;";
  let cols: string[] = [yellow, orange, green, blue, pink];
  let nodes: Record<string, any>[] = makeIndent(outline, 4);
  let n: N = {"name": "", "children": []};
  toNest(nodes, 0, 0, n);
  console.log(toMarkup(n, cols, 4));
  console.log("\n");
  let outline2: string = ((((((((((((("Display an outline as a nested table.\n" + "    Parse the outline to a tree,\n") + "        measuring the indent of each line,\n") + "        translating the indentation to a nested structure,\n") + "        and padding the tree to even depth.\n") + "    count the leaves descending from each node,\n") + "        defining the width of a leaf as 1,\n") + "        and the width of a parent node as a sum.\n") + "            (The sum of the widths of its children)\n") + "            Propagating the sums upward as necessary.\n") + "    and write out a table with 'colspan' values\n") + "        either as a wiki table,\n") + "        or as HTML.\n") + "    Optionally add color to the nodes.");
  let cols2: string[] = [blue, yellow, orange, green, pink];
  let nodes2: Record<string, any>[] = makeIndent(outline2, 4);
  let n2: N2 = {"name": "", "children": []};
  toNest(nodes2, 0, 0, n2);
  console.log(toMarkup(n2, cols2, 4));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
{
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
}

