// Generated by Mochi v0.10.42 on 2025-07-27 20:11:30 GMT+7

function square_to_maps(square: string[][]): Record<string, any> {
  let emap: Record<string, number[]> = {};
  let dmap: Record<string, string> = {};
  let x: number = 0;
  while ((x < (Array.isArray(square) || typeof square === 'string' ? square.length : Object.keys(square ?? {}).length))) {
    let row: string[] = square[x];
    let y: number = 0;
    while ((y < (Array.isArray(row) || typeof row === 'string' ? row.length : Object.keys(row ?? {}).length))) {
      let ch: string = row[y];
      emap[ch] = [x, y];
      dmap[((String(x) + ",") + String(y))] = ch;
      y = (y + 1);
    }
    x = (x + 1);
  }
  return {"e": emap, "d": dmap};
}
function remove_space(text: string, emap: Record<string, number[]>): string {
  let s: string = text.toUpperCase();
  let out: string = "";
  let i: number = 0;
  while ((i < (Array.isArray(s) || typeof s === 'string' ? s.length : Object.keys(s ?? {}).length))) {
    let ch: string = s.slice(i, (i + 1));
    if (((ch != " ") && (ch in emap))) {
      out = (out + ch);
    }
    i = (i + 1);
  }
  return out;
}
function encrypt(text: string, emap: Record<string, number[]>, dmap: Record<string, string>): string {
  text = remove_space(text, emap);
  let row0: number[] = [];
  let row1: number[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(text) || typeof text === 'string' ? text.length : Object.keys(text ?? {}).length))) {
    let ch: string = text.slice(i, (i + 1));
    let xy: number[] = emap[ch];
    row0.push(xy[Math.trunc(0)]);
    row1.push(xy[Math.trunc(1)]);
    i = (i + 1);
  }
  for (const v of row1) {
    row0.push(v);
  }
  let res: string = "";
  let j: number = 0;
  while ((j < (Array.isArray(row0) || typeof row0 === 'string' ? row0.length : Object.keys(row0 ?? {}).length))) {
    let key: string = ((String(row0[j]) + ",") + String(row0[Math.trunc((j + 1))]));
    res = (res + dmap[key]);
    j = (j + 2);
  }
  return res;
}
function decrypt(text: string, emap: Record<string, number[]>, dmap: Record<string, string>): string {
  text = remove_space(text, emap);
  let coords: number[] = [];
  let i: number = 0;
  while ((i < (Array.isArray(text) || typeof text === 'string' ? text.length : Object.keys(text ?? {}).length))) {
    let ch: string = text.slice(i, (i + 1));
    let xy: number[] = emap[ch];
    coords.push(xy[Math.trunc(0)]);
    coords.push(xy[Math.trunc(1)]);
    i = (i + 1);
  }
  let half: number = Math.trunc((Array.isArray(coords) || typeof coords === 'string' ? coords.length : Object.keys(coords ?? {}).length) / 2);
  let k1: number[] = [];
  let k2: number[] = [];
  let idx: number = 0;
  while ((idx < half)) {
    k1.push(coords[idx]);
    idx = (idx + 1);
  }
  while ((idx < (Array.isArray(coords) || typeof coords === 'string' ? coords.length : Object.keys(coords ?? {}).length))) {
    k2.push(coords[idx]);
    idx = (idx + 1);
  }
  let res: string = "";
  let j: number = 0;
  while ((j < half)) {
    let key: string = ((String(k1[j]) + ",") + String(k2[j]));
    res = (res + dmap[key]);
    j = (j + 1);
  }
  return res;
}
function main() {
  let squareRosetta: string[][] = [["A", "B", "C", "D", "E"], ["F", "G", "H", "I", "K"], ["L", "M", "N", "O", "P"], ["Q", "R", "S", "T", "U"], ["V", "W", "X", "Y", "Z"], ["J", "1", "2", "3", "4"]];
  let squareWikipedia: string[][] = [["B", "G", "W", "K", "Z"], ["Q", "P", "N", "D", "S"], ["I", "O", "A", "X", "E"], ["F", "C", "L", "U", "M"], ["T", "H", "Y", "V", "R"], ["J", "1", "2", "3", "4"]];
  let textRosetta: string = "0ATTACKATDAWN";
  let textWikipedia: string = "FLEEATONCE";
  let textTest: string = "The invasion will start on the first of January";
  let maps: Record<string, any> = square_to_maps(squareRosetta);
  let emap = maps.e;
  let dmap = maps.d;
  console.log("from Rosettacode");
  console.log(("original:\t " + textRosetta));
  let s: string = encrypt(textRosetta, emap, dmap);
  console.log(("codiert:\t " + s));
  s = decrypt(s, emap, dmap);
  console.log(("and back:\t " + s));
  maps = square_to_maps(squareWikipedia);
  emap = maps.e;
  dmap = maps.d;
  console.log("from Wikipedia");
  console.log(("original:\t " + textWikipedia));
  s = encrypt(textWikipedia, emap, dmap);
  console.log(("codiert:\t " + s));
  s = decrypt(s, emap, dmap);
  console.log(("and back:\t " + s));
  maps = square_to_maps(squareWikipedia);
  emap = maps.e;
  dmap = maps.d;
  console.log("from Rosettacode long part");
  console.log(("original:\t " + textTest));
  s = encrypt(textTest, emap, dmap);
  console.log(("codiert:\t " + s));
  s = decrypt(s, emap, dmap);
  console.log(("and back:\t " + s));
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().rss ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().rss;
  }
  return 0;
}
(() => {
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

