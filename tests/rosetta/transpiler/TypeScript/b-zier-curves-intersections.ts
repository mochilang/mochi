// Generated by Mochi v0.10.40 on 2025-07-25 17:41:12 GMT+7

export interface Workload { p: QuadCurve; q: QuadCurve }
function absf(x: number): number {
  if ((x < 0.0)) {
    return -x;
  }
  return x;
}
function maxf(a: number, b: number): number {
  if ((a > b)) {
    return a;
  }
  return b;
}
function minf(a: number, b: number): number {
  if ((a < b)) {
    return a;
  }
  return b;
}
function max3(a: number, b: number, c: number): number {
  let m: number = a;
  if ((b > m)) {
    m = b;
  }
  if ((c > m)) {
    m = c;
  }
  return m;
}
function min3(a: number, b: number, c: number): number {
  let m: number = a;
  if ((b < m)) {
    m = b;
  }
  if ((c < m)) {
    m = c;
  }
  return m;
}
export interface Point { x: number; y: number }
export interface QuadSpline { c0: number; c1: number; c2: number }
export interface QuadCurve { x: QuadSpline; y: QuadSpline }
function subdivideQuadSpline(q: QuadSpline, t: number): QuadSpline[] {
  const s: number = (1.0 - t);
  let u: QuadSpline = {"c0": q.c0, "c1": 0.0, "c2": 0.0};
  let v: QuadSpline = {"c0": 0.0, "c1": 0.0, "c2": q.c2};
  u.c1 = ((s * q.c0) + (t * q.c1));
  v.c1 = ((s * q.c1) + (t * q.c2));
  u.c2 = ((s * u.c1) + (t * v.c1));
  v.c0 = u.c2;
  return [u, v];
}
function subdivideQuadCurve(q: QuadCurve, t: number): QuadCurve[] {
  const xs: QuadSpline[] = subdivideQuadSpline(q.x, t);
  const ys: QuadSpline[] = subdivideQuadSpline(q.y, t);
  let u: QuadCurve = {"x": xs[Math.trunc(0)], "y": ys[Math.trunc(0)]};
  let v: QuadCurve = {"x": xs[Math.trunc(1)], "y": ys[Math.trunc(1)]};
  return [u, v];
}
function rectsOverlap(xa0: number, ya0: number, xa1: number, ya1: number, xb0: number, yb0: number, xb1: number, yb1: number): boolean {
  return ((((xb0 <= xa1) && (xa0 <= xb1)) && (yb0 <= ya1)) && (ya0 <= yb1));
}
function testIntersect(p: QuadCurve, q: QuadCurve, tol: number): Record<string, any> {
  const pxmin: number = min3(p.x.c0, p.x.c1, p.x.c2);
  const pymin: number = min3(p.y.c0, p.y.c1, p.y.c2);
  const pxmax: number = max3(p.x.c0, p.x.c1, p.x.c2);
  const pymax: number = max3(p.y.c0, p.y.c1, p.y.c2);
  const qxmin: number = min3(q.x.c0, q.x.c1, q.x.c2);
  const qymin: number = min3(q.y.c0, q.y.c1, q.y.c2);
  const qxmax: number = max3(q.x.c0, q.x.c1, q.x.c2);
  const qymax: number = max3(q.y.c0, q.y.c1, q.y.c2);
  let exclude: boolean = true;
  let accept: boolean = false;
  let inter: Point = {"x": 0.0, "y": 0.0};
  if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
    exclude = false;
    const xmin: number = maxf(pxmin, qxmin);
    const xmax: number = minf(pxmax, qxmax);
    if (((xmax - xmin) <= tol)) {
      const ymin: number = maxf(pymin, qymin);
      const ymax: number = minf(pymax, qymax);
      if (((ymax - ymin) <= tol)) {
        accept = true;
        inter.x = (0.5 * (xmin + xmax));
        inter.y = (0.5 * (ymin + ymax));
      }
    }
  }
  return {exclude, accept, "intersect": inter};
}
function seemsToBeDuplicate(pts: Point[], xy: Point, spacing: number): boolean {
  let i: number = 0;
  while ((i < (Array.isArray(pts) || typeof pts === 'string' ? pts.length : Object.keys(pts ?? {}).length))) {
    const pt: Point = pts[i];
    if (((absf((pt.x - xy.x)) < spacing) && (absf((pt.y - xy.y)) < spacing))) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function findIntersects(p: QuadCurve, q: QuadCurve, tol: number, spacing: number): Point[] {
  let inters: Point[] = [];
  let workload: Workload[] = [{p, q}];
  while (((Array.isArray(workload) || typeof workload === 'string' ? workload.length : Object.keys(workload ?? {}).length) > 0)) {
    const idx: number = ((Array.isArray(workload) || typeof workload === 'string' ? workload.length : Object.keys(workload ?? {}).length) - 1);
    const work: Workload = workload[idx];
    workload = workload.slice(0, idx);
    const res = testIntersect(work.p, work.q, tol);
    const excl = res.exclude;
    const acc = res.accept;
    const inter = res.intersect;
    if (acc) {
      if (!seemsToBeDuplicate(inters, inter, spacing)) {
        inters = [...inters, inter];
      }
    } else {
      if (!excl) {
        const ps = subdivideQuadCurve(work.p, 0.5);
        const qs = subdivideQuadCurve(work.q, 0.5);
        const p0 = ps[Math.trunc(0)];
        const p1 = ps[Math.trunc(1)];
        const q0 = qs[Math.trunc(0)];
        const q1 = qs[Math.trunc(1)];
        workload = [...workload, {"p": p0, "q": q0}];
        workload = [...workload, {"p": p0, "q": q1}];
        workload = [...workload, {"p": p1, "q": q0}];
        workload = [...workload, {"p": p1, "q": q1}];
      }
    }
  }
  return inters;
}
function main() {
  const p: QuadCurve = {"x": {"c0": -1.0, "c1": 0.0, "c2": 1.0}, "y": {"c0": 0.0, "c1": 10.0, "c2": 0.0}};
  const q: QuadCurve = {"x": {"c0": 2.0, "c1": -8.0, "c2": 2.0}, "y": {"c0": 1.0, "c1": 2.0, "c2": 3.0}};
  const tol: number = 1e-07;
  const spacing: number = (tol * 10.0);
  const inters: Point[] = findIntersects(p, q, tol, spacing);
  let i: number = 0;
  while ((i < (Array.isArray(inters) || typeof inters === 'string' ? inters.length : Object.keys(inters ?? {}).length))) {
    const pt: Point = inters[i];
    console.log((((("(" + String(pt.x)) + ", ") + String(pt.y)) + ")"));
    i = (i + 1);
  }
}
main();
