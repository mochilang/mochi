// Generated by Mochi v0.10.56 on 2025-08-03 17:22:37 GMT+7

export interface Workload { p: QuadCurve; q: QuadCurve }
function absf(x: number): number {
  if ((x < 0.0)) {
    return -x;
  }
  return x;
}
function maxf(a: number, b: number): number {
  if ((a > b)) {
    return a;
  }
  return b;
}
function minf(a: number, b: number): number {
  if ((a < b)) {
    return a;
  }
  return b;
}
function max3(a: number, b: number, c: number): number {
  let m: number = a;
  if ((b > m)) {
    m = b;
  }
  if ((c > m)) {
    m = c;
  }
  return m;
}
function min3(a: number, b: number, c: number): number {
  let m: number = a;
  if ((b < m)) {
    m = b;
  }
  if ((c < m)) {
    m = c;
  }
  return m;
}
export interface Point { x: number; y: number }
export interface QuadSpline { c0: number; c1: number; c2: number }
export interface QuadCurve { x: QuadSpline; y: QuadSpline }
export interface TestRes { exclude: boolean; accept: boolean; intersect: Point }
function subdivideQuadSpline(q: QuadSpline, t: number): QuadSpline[] {
  let s: number = (1.0 - t);
  let u: QuadSpline = {"c0": q.c0, "c1": 0.0, "c2": 0.0};
  let v: QuadSpline = {"c0": 0.0, "c1": 0.0, "c2": q.c2};
  u.c1 = ((s * q.c0) + (t * q.c1));
  v.c1 = ((s * q.c1) + (t * q.c2));
  u.c2 = ((s * u.c1) + (t * v.c1));
  v.c0 = u.c2;
  return [u, v];
}
function subdivideQuadCurve(q: QuadCurve, t: number): QuadCurve[] {
  let xs: QuadSpline[] = subdivideQuadSpline(q.x, t);
  let ys: QuadSpline[] = subdivideQuadSpline(q.y, t);
  let u: QuadCurve = {"x": xs[Math.trunc(0)], "y": ys[Math.trunc(0)]};
  let v: QuadCurve = {"x": xs[Math.trunc(1)], "y": ys[Math.trunc(1)]};
  return [u, v];
}
function rectsOverlap(xa0: number, ya0: number, xa1: number, ya1: number, xb0: number, yb0: number, xb1: number, yb1: number): boolean {
  return ((((xb0 <= xa1) && (xa0 <= xb1)) && (yb0 <= ya1)) && (ya0 <= yb1));
}
function testIntersect(p: QuadCurve, q: QuadCurve, tol: number): TestRes {
  let pxmin: number = min3(p.x.c0, p.x.c1, p.x.c2);
  let pymin: number = min3(p.y.c0, p.y.c1, p.y.c2);
  let pxmax: number = max3(p.x.c0, p.x.c1, p.x.c2);
  let pymax: number = max3(p.y.c0, p.y.c1, p.y.c2);
  let qxmin: number = min3(q.x.c0, q.x.c1, q.x.c2);
  let qymin: number = min3(q.y.c0, q.y.c1, q.y.c2);
  let qxmax: number = max3(q.x.c0, q.x.c1, q.x.c2);
  let qymax: number = max3(q.y.c0, q.y.c1, q.y.c2);
  let res: TestRes = {"exclude": true, "accept": false, "intersect": {"x": 0.0, "y": 0.0}};
  if (rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {
    res.exclude = false;
    let xmin: number = maxf(pxmin, qxmin);
    let xmax: number = minf(pxmax, qxmax);
    if (((xmax - xmin) <= tol)) {
      let ymin: number = maxf(pymin, qymin);
      let ymax: number = minf(pymax, qymax);
      if (((ymax - ymin) <= tol)) {
        res.accept = true;
        res.intersect.x = (0.5 * (xmin + xmax));
        res.intersect.y = (0.5 * (ymin + ymax));
      }
    }
  }
  return res;
}
function seemsToBeDuplicate(pts: Point[], xy: Point, spacing: number): boolean {
  let i: number = 0;
  while ((i < Number(Array.isArray(pts) || typeof pts === 'string' ? pts.length : Object.keys(pts ?? {}).length))) {
    let pt: Point = pts[i];
    if (((absf((pt.x - xy.x)) < spacing) && (absf((pt.y - xy.y)) < spacing))) {
      return true;
    }
    i = (i + 1);
  }
  return false;
}
function findIntersects(p: QuadCurve, q: QuadCurve, tol: number, spacing: number): Point[] {
  let inters: Point[] = [];
  let workload: Workload[] = [{p, q}];
  while ((Number(Array.isArray(workload) || typeof workload === 'string' ? workload.length : Object.keys(workload ?? {}).length) > 0)) {
    let idx: number = (Number(Array.isArray(workload) || typeof workload === 'string' ? workload.length : Object.keys(workload ?? {}).length) - 1);
    let work: Workload = workload[idx];
    workload = workload.slice(0, idx);
    let res = testIntersect(work.p, work.q, tol);
    let excl = res.exclude;
    let acc = res.accept;
    let inter = res.intersect;
    if (acc) {
      if (!seemsToBeDuplicate(inters, inter, spacing)) {
        inters.push(inter);
      }
    } else {
      if (!excl) {
        let ps = subdivideQuadCurve(work.p, 0.5);
        let qs = subdivideQuadCurve(work.q, 0.5);
        let p0 = ps[Math.trunc(0)];
        let p1 = ps[Math.trunc(1)];
        let q0 = qs[Math.trunc(0)];
        let q1 = qs[Math.trunc(1)];
        let p0a = p0;
        let q0a = q0;
        let p1a = p1;
        let q1a = q1;
        workload.push({"p": p0a, "q": q0a});
        workload.push({"p": p0, "q": q1a});
        workload.push({"p": p1a, "q": q0});
        workload.push({"p": p1, "q": q1});
      }
    }
  }
  return inters;
}
function main() {
  let p: QuadCurve = {"x": {"c0": -1.0, "c1": 0.0, "c2": 1.0}, "y": {"c0": 0.0, "c1": 10.0, "c2": 0.0}};
  let q: QuadCurve = {"x": {"c0": 2.0, "c1": -8.0, "c2": 2.0}, "y": {"c0": 1.0, "c1": 2.0, "c2": 3.0}};
  let tol: number = 1e-07;
  let spacing: number = (tol * 10.0);
  let inters: Point[] = findIntersects(p, q, tol, spacing);
  let i: number = 0;
  while ((i < Number(Array.isArray(inters) || typeof inters === 'string' ? inters.length : Object.keys(inters ?? {}).length))) {
    let pt: Point = inters[i];
    console.log(_str((((("(" + _str(pt.x)) + ", ") + _str(pt.y)) + ")")));
    i = (i + 1);
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

