// Generated by Mochi v0.10.56 on 2025-08-03 17:23:27 GMT+7

export interface Digits { "0": number; "1": number; "2": number; "3": number; "4": number; "5": number; "6": number; "7": number; "8": number; "9": number }
let PI: number = 3.141592653589793;
let TWO_PI: number = 6.283185307179586;
function sinApprox(x: number): number {
  let term: number = x;
  let sum: number = x;
  let n: number = 1;
  while ((n <= 8)) {
    let denom = ((2 * n) * ((2 * n) + 1));
    term = (((-term * x) * x) / denom);
    sum = (sum + term);
    n = (n + 1);
  }
  return sum;
}
function floor(x: number): number {
  let i: number = Math.trunc(x);
  if ((i > x)) {
    i = (i - 1);
  }
  return i;
}
function absFloat(x: number): number {
  if ((x < 0.0)) {
    return -x;
  }
  return x;
}
function absInt(n: number): number {
  if ((n < 0)) {
    return -n;
  }
  return n;
}
function parseIntStr(str: string): number {
  let i: number = 0;
  let neg: boolean = false;
  if (((Number(Array.isArray(str) || typeof str === 'string' ? str.length : Object.keys(str ?? {}).length) > 0) && (str.slice(0, 1) == "-"))) {
    neg = true;
    i = 1;
  }
  let n: number = 0;
  let digits: Digits = {"0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9};
  while ((i < Number(Array.isArray(str) || typeof str === 'string' ? str.length : Object.keys(str ?? {}).length))) {
    n = ((n * 10) + digits[str.slice(i, (i + 1))]);
    i = (i + 1);
  }
  if (neg) {
    n = -n;
  }
  return n;
}
function parseDate(s: string): number[] {
  let y = parseIntStr(s.slice(0, 4));
  let m = parseIntStr(s.slice(5, 7));
  let d = parseIntStr(s.slice(8, 10));
  return [y, m, d];
}
function leap(y: number): boolean {
  if (((y % 400) == 0)) {
    return true;
  }
  if (((y % 100) == 0)) {
    return false;
  }
  return ((y % 4) == 0);
}
function daysInMonth(y: number, m: number): number {
  let feb: number = (leap(y) ? 29 : 28);
  let lengths: number[] = [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  return lengths[Math.trunc((m - 1))];
}
function addDays(y: number, m: number, d: number, n: number): number[] {
  let yy: number = y;
  let mm: number = m;
  let dd: number = d;
  if ((n >= 0)) {
    let i: number = 0;
    while ((i < n)) {
      dd = (dd + 1);
      if ((dd > daysInMonth(yy, mm))) {
        dd = 1;
        mm = (mm + 1);
        if ((mm > 12)) {
          mm = 1;
          yy = (yy + 1);
        }
      }
      i = (i + 1);
    }
  } else {
    let i: number = 0;
    while ((i > n)) {
      dd = (dd - 1);
      if ((dd < 1)) {
        mm = (mm - 1);
        if ((mm < 1)) {
          mm = 12;
          yy = (yy - 1);
        }
        dd = daysInMonth(yy, mm);
      }
      i = (i - 1);
    }
  }
  return [yy, mm, dd];
}
function pad2(n: number): string {
  if ((n < 10)) {
    return ("0" + _str(n));
  }
  return _str(n);
}
function dateString(y: number, m: number, d: number): string {
  return ((((_str(y) + "-") + pad2(m)) + "-") + pad2(d));
}
function day(y: number, m: number, d: number): number {
  let part1: number = (367 * y);
  let part2: number = Math.trunc(Math.trunc((7 * Math.trunc((y + Math.trunc((m + 9) / 12)))) / 4));
  let part3: number = Math.trunc(Math.trunc((275 * m) / 9));
  return ((((part1 - part2) + part3) + d) - 730530);
}
function biorhythms(birth: string, target: string) {
  let bparts: number[] = parseDate(birth);
  let by: number = bparts[Math.trunc(0)];
  let bm: number = bparts[Math.trunc(1)];
  let bd: number = bparts[Math.trunc(2)];
  let tparts: number[] = parseDate(target);
  let ty: number = tparts[Math.trunc(0)];
  let tm: number = tparts[Math.trunc(1)];
  let td: number = tparts[Math.trunc(2)];
  let diff: number = absInt((day(ty, tm, td) - day(by, bm, bd)));
  console.log(_str(((("Born " + birth) + ", Target ") + target)));
  console.log(_str(("Day " + _str(diff))));
  let cycles: string[] = ["Physical day ", "Emotional day", "Mental day   "];
  let lengths: number[] = [23, 28, 33];
  let quadrants: string[][] = [["up and rising", "peak"], ["up but falling", "transition"], ["down and falling", "valley"], ["down but rising", "transition"]];
  let i: number = 0;
  while ((i < 3)) {
    let length: number = lengths[i];
    let cycle: string = cycles[i];
    let position: number = (diff % length);
    let quadrant: number = Math.trunc((position * 4) / length);
    let percent: number = sinApprox((((2.0 * PI) * position) / length));
    percent = (floor((percent * 1000.0)) / 10.0);
    let description: string = "";
    if ((percent > 95.0)) {
      description = " peak";
    } else {
      if ((percent < -95.0)) {
        description = " valley";
      } else {
        if ((absFloat(percent) < 5.0)) {
          description = " critical transition";
        } else {
          let daysToAdd: number = (Math.trunc(((quadrant + 1) * length) / 4) - position);
          let res: number[] = addDays(ty, tm, td, daysToAdd);
          let ny: number = res[Math.trunc(0)];
          let nm: number = res[Math.trunc(1)];
          let nd: number = res[Math.trunc(2)];
          let transition: string = dateString(ny, nm, nd);
          let trend: string = quadrants[quadrant][Math.trunc(0)];
          let next: string = quadrants[quadrant][Math.trunc(1)];
          let pct: string = _str(percent);
          if (!pct.includes(".")) {
            pct = (pct + ".0");
          }
          description = ((((((((" " + pct) + "% (") + trend) + ", next ") + next) + " ") + transition) + ")");
        }
      }
    }
    let posStr: string = _str(position);
    if ((position < 10)) {
      posStr = (" " + posStr);
    }
    console.log(_str((((cycle + posStr) + " : ") + description)));
    i = (i + 1);
  }
  console.log(_str(""));
}
function main() {
  let pairs: string[][] = [["1943-03-09", "1972-07-11"], ["1809-01-12", "1863-11-19"], ["1809-02-12", "1863-11-19"]];
  let idx: number = 0;
  while ((idx < Number(Array.isArray(pairs) || typeof pairs === 'string' ? pairs.length : Object.keys(pairs ?? {}).length))) {
    let p: string[] = pairs[idx];
    biorhythms(p[Math.trunc(0)], p[Math.trunc(1)]);
    idx = (idx + 1);
  }
}
var _nowSeed = 0;
var _nowSeeded = false;
{
  let s = "";
  if (typeof Deno !== "undefined") {
    try {
      s = Deno.env.get("MOCHI_NOW_SEED") ?? "";
    } catch (_e) {
      s = "";
    }
  } else if (typeof process !== "undefined") {
    s = process.env.MOCHI_NOW_SEED || "";
  }
  if (s) {
    const v = parseInt(s, 10);
    if (!isNaN(v)) {
      _nowSeed = v;
      _nowSeeded = true;
    }
  }
}
function _now(): number {
  if (_nowSeeded) {
    _nowSeed = (_nowSeed * 1664525 + 1013904223) % 2147483647;
    return _nowSeed;
  }
  if (typeof Deno !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  if (typeof performance !== 'undefined') {
    return Math.trunc(performance.now() * 1e6);
  }
  return Date.now() * 1000;
}
function _mem(): number {
  if (typeof Deno !== 'undefined') {
    return (Deno.memoryUsage?.().heapUsed ?? 0);
  }
  if (typeof process !== 'undefined') {
    return process.memoryUsage().heapUsed;
  }
  return 0;
}
function _str(x: any): string {
  if (typeof x === 'number') {
    if (Object.is(x, -0)) return '-0';
    if (x === Infinity) return '+Inf';
    if (x === -Infinity) return '-Inf';
    if (Number.isNaN(x)) return 'NaN';
  }
  return String(x);
}
(() => {
  globalThis.gc?.()
  const _startMem = _mem()
  const _start = _now()
  main();
  const _end = _now()
  const _duration = _end - _start
  const _duration_us = Math.trunc(_duration / 1000)
  globalThis.gc?.()
  const _endMem = _mem()
  const _memory_bytes = Math.max(0, _endMem - _startMem)
  console.log(JSON.stringify({
    "duration_us": _duration_us,
    "memory_bytes": _memory_bytes,
    "name": "main"
  }, null, "  "))
})();

