;; Generated by Mochi 0.10.41 on 2025-07-27 15:57 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (if (< (string-length s) width)
      (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
      s))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define (square_to_maps square)
  (let/ec _return (begin
(define emap (hash))
(define dmap (hash))
(define x 0)
(let/ec _break (let loop ()
  (if (< x (cond [(string? square) (string-length square)] [(hash? square) (hash-count square)] [else (length square)])) (let ()
    (define row (list-ref square x))
    (define y 0)
    (let/ec _break (let loop ()
  (if (< y (cond [(string? row) (string-length row)] [(hash? row) (hash-count row)] [else (length row)])) (let ()
    (define ch (list-ref row y))
    (set! emap (hash-set (or emap (hash)) ch (list x y)))
    (set! dmap (hash-set (or dmap (hash)) (string-append (string-append (format "~a" x) ",") (format "~a" y)) ch))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (hash "e" emap "d" dmap))
))
)
(define (remove_space text emap)
  (let/ec _return (begin
(define s (upper text))
(define out "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (define ch (substring s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (and (not (string=? ch " ")) (hash-has-key? emap ch)) (let ()
(set! out (string-append out ch))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (encrypt text emap dmap)
  (let/ec _return (begin
(set! text (remove_space text emap))
(define row0 (list))
(define row1 (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? text) (string-length text)] [(hash? text) (hash-count text)] [else (length text)])) (let ()
    (define ch (substring text i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define xy (if emap (hash-ref emap ch #f) #f))
    (set! row0 (append row0 (list (list-ref xy 0))))
    (set! row1 (append row1 (list (list-ref xy 1))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(let/ec _break (for ([v row1])
  (let/ec _cont
(set! row0 (append row0 (list v)))
  )))
(define res "")
(define j 0)
(let/ec _break (let loop ()
  (if (< j (cond [(string? row0) (string-length row0)] [(hash? row0) (hash-count row0)] [else (length row0)])) (let ()
    (define key (string-append (string-append (format "~a" (list-ref row0 j)) ",") (format "~a" (list-ref row0 (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! res (string-append res (if dmap (hash-ref dmap key #f) #f)))
    (set! j (let ([__l j] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (decrypt text emap dmap)
  (let/ec _return (begin
(set! text (remove_space text emap))
(define coords (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? text) (string-length text)] [(hash? text) (hash-count text)] [else (length text)])) (let ()
    (define ch (substring text i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define xy (if emap (hash-ref emap ch #f) #f))
    (set! coords (append coords (list (list-ref xy 0))))
    (set! coords (append coords (list (list-ref xy 1))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define half (quotient (cond [(string? coords) (string-length coords)] [(hash? coords) (hash-count coords)] [else (length coords)]) 2))
(define k1 (list))
(define k2 (list))
(define idx 0)
(let/ec _break (let loop ()
  (if (< idx half) (let ()
    (set! k1 (append k1 (list (list-ref coords idx))))
    (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(let/ec _break (let loop ()
  (if (< idx (cond [(string? coords) (string-length coords)] [(hash? coords) (hash-count coords)] [else (length coords)])) (let ()
    (set! k2 (append k2 (list (list-ref coords idx))))
    (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define res "")
(define j 0)
(let/ec _break (let loop ()
  (if (< j half) (let ()
    (define key (string-append (string-append (format "~a" (list-ref k1 j)) ",") (format "~a" (list-ref k2 j))))
    (set! res (string-append res (if dmap (hash-ref dmap key #f) #f)))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (main)
  (let/ec _return (begin
(define squareRosetta (list (list "A" "B" "C" "D" "E") (list "F" "G" "H" "I" "K") (list "L" "M" "N" "O" "P") (list "Q" "R" "S" "T" "U") (list "V" "W" "X" "Y" "Z") (list "J" "1" "2" "3" "4")))
(define squareWikipedia (list (list "B" "G" "W" "K" "Z") (list "Q" "P" "N" "D" "S") (list "I" "O" "A" "X" "E") (list "F" "C" "L" "U" "M") (list "T" "H" "Y" "V" "R") (list "J" "1" "2" "3" "4")))
(define textRosetta "0ATTACKATDAWN")
(define textWikipedia "FLEEATONCE")
(define textTest "The invasion will start on the first of January")
(define maps (square_to_maps squareRosetta))
(define emap (if maps (hash-ref maps "e" #f) #f))
(define dmap (if maps (hash-ref maps "d" #f) #f))
(displayln "from Rosettacode")
(displayln (string-append "original:\t " textRosetta))
(define s (encrypt textRosetta emap dmap))
(displayln (string-append "codiert:\t " s))
(set! s (decrypt s emap dmap))
(displayln (string-append "and back:\t " s))
(set! maps (square_to_maps squareWikipedia))
(set! emap (if maps (hash-ref maps "e" #f) #f))
(set! dmap (if maps (hash-ref maps "d" #f) #f))
(displayln "from Wikipedia")
(displayln (string-append "original:\t " textWikipedia))
(set! s (encrypt textWikipedia emap dmap))
(displayln (string-append "codiert:\t " s))
(set! s (decrypt s emap dmap))
(displayln (string-append "and back:\t " s))
(set! maps (square_to_maps squareWikipedia))
(set! emap (if maps (hash-ref maps "e" #f) #f))
(set! dmap (if maps (hash-ref maps "d" #f) #f))
(displayln "from Rosettacode long part")
(displayln (string-append "original:\t " textTest))
(set! s (encrypt textTest emap dmap))
(displayln (string-append "codiert:\t " s))
(set! s (decrypt s emap dmap))
(displayln (string-append "and back:\t " s))
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
