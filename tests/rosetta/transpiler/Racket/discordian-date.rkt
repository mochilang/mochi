;; Generated by Mochi 0.10.55 on 2025-08-03 11:14 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (let loop ([i 0])
    (cond [(>= i (string-length s)) -1]
          [(string=? (substring s i (add1 i)) ch) i]
          [else (loop (add1 i))])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define dayNames (list "Sweetmorn" "Boomtime" "Pungenday" "Prickle-Prickle" "Setting Orange"))
(define seasons (list "Chaos" "Discord" "Confusion" "Bureaucracy" "The Aftermath"))
(define holydays (list (list "Mungday" "Chaoflux") (list "Mojoday" "Discoflux") (list "Syaday" "Confuflux") (list "Zaraday" "Bureflux") (list "Maladay" "Afflux")))
(define (isLeap y)
  (let/ec _return (begin
(if (equal? (modulo y 400) 0) (let ()
(_return #t)
) (void))
(if (equal? (modulo y 100) 0) (let ()
(_return #f)
) (void))
(_return (equal? (modulo y 4) 0))
))
)
(define daysBefore (list 0 31 59 90 120 151 181 212 243 273 304 334))
(define (dayOfYear y m d)
  (let/ec _return (begin
(define doy (let ([__l (if daysBefore (if (hash? daysBefore) (hash-ref daysBefore (- m 1) #f) (list-ref daysBefore (int (- m 1)))) #f)] [__r d]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(if (and (> m 2) (isLeap y)) (let ()
(set! doy (let ([__l doy] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(_return doy)
))
)
(define (ordinal n)
  (let/ec _return (begin
(define suff "th")
(define mod100 (modulo n 100))
(if (or (< mod100 11) (> mod100 13)) (let ()
(define r (modulo n 10))
(if (equal? r 1) (let ()
(set! suff "st")
) (let ()
(if (equal? r 2) (let ()
(set! suff "nd")
) (let ()
(if (equal? r 3) (let ()
(set! suff "rd")
) (void))
))
))
) (void))
(_return (string-append (format "~a" n) suff))
))
)
(define (discordian y m d)
  (let/ec _return (begin
(if (and (and (isLeap y) (equal? m 2)) (equal? d 29)) (let ()
(_return (string-append "St. Tib's Day, YOLD " (format "~a" (let ([__l y] [__r 1166]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
(define doy (dayOfYear y m d))
(if (and (isLeap y) (> doy 60)) (let ()
(set! doy (- doy 1))
) (void))
(define idx (- doy 1))
(define season (quotient idx 73))
(define day (modulo idx 73))
(define res (string-append (string-append (string-append (string-append (string-append (string-append (if dayNames (if (hash? dayNames) (hash-ref dayNames (modulo idx 5) #f) (list-ref dayNames (int (modulo idx 5)))) #f) ", the ") (ordinal (let ([__l day] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) " day of ") (if seasons (if (hash? seasons) (hash-ref seasons season #f) (list-ref seasons (int season))) #f)) " in the YOLD ") (format "~a" (let ([__l y] [__r 1166]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
(if (equal? day 4) (let ()
(set! res (string-append (string-append (string-append res ". Celebrate ") (if (if holydays (if (hash? holydays) (hash-ref holydays season #f) (list-ref holydays (int season))) #f) (if (hash? (if holydays (if (hash? holydays) (hash-ref holydays season #f) (list-ref holydays (int season))) #f)) (hash-ref (if holydays (if (hash? holydays) (hash-ref holydays season #f) (list-ref holydays (int season))) #f) 0 #f) (list-ref (if holydays (if (hash? holydays) (hash-ref holydays season #f) (list-ref holydays (int season))) #f) (int 0))) #f)) "!"))
) (void))
(if (equal? day 49) (let ()
(set! res (string-append (string-append (string-append res ". Celebrate ") (if (if holydays (if (hash? holydays) (hash-ref holydays season #f) (list-ref holydays (int season))) #f) (if (hash? (if holydays (if (hash? holydays) (hash-ref holydays season #f) (list-ref holydays (int season))) #f)) (hash-ref (if holydays (if (hash? holydays) (hash-ref holydays season #f) (list-ref holydays (int season))) #f) 1 #f) (list-ref (if holydays (if (hash? holydays) (hash-ref holydays season #f) (list-ref holydays (int season))) #f) (int 1))) #f)) "!"))
) (void))
(_return res)
))
)
(define (main)
  (let/ec _return (begin
(define dates (list (list 2010 7 22) (list 2012 2 28) (list 2012 2 29) (list 2012 3 1) (list 2012 12 31) (list 2013 1 1) (list 2100 12 31) (list 2015 10 19) (list 2010 1 5) (list 2011 5 3) (list 2000 3 13)))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? dates) (string-length dates)] [(hash? dates) (hash-count dates)] [else (length dates)])) (let/ec _cont
    (define dt (if dates (if (hash? dates) (hash-ref dates i #f) (list-ref dates (int i))) #f))
    (displayln (discordian (if dt (if (hash? dt) (hash-ref dt 0 #f) (list-ref dt (int 0))) #f) (if dt (if (hash? dt) (hash-ref dt 1 #f) (list-ref dt (int 1))) #f) (if dt (if (hash? dt) (hash-ref dt 2 #f) (list-ref dt (int 2))) #f)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(main)
