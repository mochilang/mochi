;; Generated by Mochi 0.10.42 on 2025-07-28 10:03 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define dayNames (list "Sweetmorn" "Boomtime" "Pungenday" "Prickle-Prickle" "Setting Orange"))
(define seasons (list "Chaos" "Discord" "Confusion" "Bureaucracy" "The Aftermath"))
(define holydays (list (list "Mungday" "Chaoflux") (list "Mojoday" "Discoflux") (list "Syaday" "Confuflux") (list "Zaraday" "Bureflux") (list "Maladay" "Afflux")))
(define (isLeap y)
  (let/ec _return (begin
(if (equal? (modulo y 400) 0) (let ()
(_return #t)
) (void))
(if (equal? (modulo y 100) 0) (let ()
(_return #f)
) (void))
(_return (equal? (modulo y 4) 0))
))
)
(define daysBefore (list 0 31 59 90 120 151 181 212 243 273 304 334))
(define (dayOfYear y m d)
  (let/ec _return (begin
(define doy (let ([__l (if daysBefore (list-ref daysBefore (int (- m 1))) #f)] [__r d]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(if (and (> m 2) (isLeap y)) (let ()
(set! doy (let ([__l doy] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(_return doy)
))
)
(define (ordinal n)
  (let/ec _return (begin
(define suff "th")
(define mod100 (modulo n 100))
(if (or (< mod100 11) (> mod100 13)) (let ()
(define r (modulo n 10))
(if (equal? r 1) (let ()
(set! suff "st")
) (let ()
(if (equal? r 2) (let ()
(set! suff "nd")
) (let ()
(if (equal? r 3) (let ()
(set! suff "rd")
) (void))
))
))
) (void))
(_return (string-append (format "~a" n) suff))
))
)
(define (discordian y m d)
  (let/ec _return (begin
(if (and (and (isLeap y) (equal? m 2)) (equal? d 29)) (let ()
(_return (string-append "St. Tib's Day, YOLD " (format "~a" (let ([__l y] [__r 1166]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
(define doy (dayOfYear y m d))
(if (and (isLeap y) (> doy 60)) (let ()
(set! doy (- doy 1))
) (void))
(define idx (- doy 1))
(define season (quotient idx 73))
(define day (modulo idx 73))
(define res (string-append (string-append (string-append (string-append (string-append (string-append (if dayNames (list-ref dayNames (int (modulo idx 5))) #f) ", the ") (ordinal (let ([__l day] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) " day of ") (if seasons (list-ref seasons (int season)) #f)) " in the YOLD ") (format "~a" (let ([__l y] [__r 1166]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
(if (equal? day 4) (let ()
(set! res (string-append (string-append (string-append res ". Celebrate ") (if (if holydays (list-ref holydays (int season)) #f) (list-ref (if holydays (list-ref holydays (int season)) #f) (int 0)) #f)) "!"))
) (void))
(if (equal? day 49) (let ()
(set! res (string-append (string-append (string-append res ". Celebrate ") (if (if holydays (list-ref holydays (int season)) #f) (list-ref (if holydays (list-ref holydays (int season)) #f) (int 1)) #f)) "!"))
) (void))
(_return res)
))
)
(define (main)
  (let/ec _return (begin
(define dates (list (list 2010 7 22) (list 2012 2 28) (list 2012 2 29) (list 2012 3 1) (list 2012 12 31) (list 2013 1 1) (list 2100 12 31) (list 2015 10 19) (list 2010 1 5) (list 2011 5 3) (list 2000 3 13)))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? dates) (string-length dates)] [(hash? dates) (hash-count dates)] [else (length dates)])) (let ()
    (define dt (if dates (list-ref dates (int i)) #f))
    (displayln (discordian (if dt (list-ref dt (int 0)) #f) (if dt (list-ref dt (int 1)) #f) (if dt (list-ref dt (int 2)) #f)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
