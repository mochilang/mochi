;; Generated by Mochi 0.10.42 on 2025-07-27 23:50 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define (indexOf s ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (if (string=? (substring s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) ch) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (fmt4 x)
  (let/ec _return (begin
(define y (* x 10000.0))
(if (>= y 0) (let ()
(set! y (let ([__l y] [__r 0.5]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(set! y (- y 0.5))
))
(set! y (/ (exact->inexact (int y)) 10000.0))
(define s (format "~a" y))
(define dot (indexOf s "."))
(if (equal? dot (- 0 1)) (let ()
(set! s (string-append s ".0000"))
) (let ()
(define decs (- (- (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) dot) 1))
(if (> decs 4) (let ()
(set! s (substring s 0 (let ([__l dot] [__r 5]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
) (let ()
(let/ec _break (let loop ()
  (if (< decs 4) (let ()
    (set! s (string-append s "0"))
    (set! decs (let ([__l decs] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
))
(if (>= x 0.0) (let ()
(set! s (string-append " " s))
) (void))
(_return s)
))
)
(define (fmt2 n)
  (let/ec _return (begin
(define s (format "~a" n))
(if (< (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) 2) (let ()
(_return (string-append " " s))
) (void))
(_return s)
))
)
(define (sumPoint p1 p2)
  (let/ec _return (begin
(_return (hash "x" (let ([__l (if p1 (hash-ref p1 "x" #f) #f)] [__r (if p2 (hash-ref p2 "x" #f) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) "y" (let ([__l (if p1 (hash-ref p1 "y" #f) #f)] [__r (if p2 (hash-ref p2 "y" #f) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) "z" (let ([__l (if p1 (hash-ref p1 "z" #f) #f)] [__r (if p2 (hash-ref p2 "z" #f) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define (mulPoint p m)
  (let/ec _return (begin
(_return (hash "x" (* (if p (hash-ref p "x" #f) #f) m) "y" (* (if p (hash-ref p "y" #f) #f) m) "z" (* (if p (hash-ref p "z" #f) #f) m)))
))
)
(define (divPoint p d)
  (let/ec _return (begin
(_return (mulPoint p (/ 1.0 d)))
))
)
(define (centerPoint p1 p2)
  (let/ec _return (begin
(_return (divPoint (sumPoint p1 p2) 2.0))
))
)
(define (getFacePoints points faces)
  (let/ec _return (begin
(define facePoints (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? faces) (string-length faces)] [(hash? faces) (hash-count faces)] [else (length faces)])) (let ()
    (define face (if faces (list-ref faces (int i)) #f))
    (define fp (hash "x" 0.0 "y" 0.0 "z" 0.0))
    (let/ec _break (for ([idx face])
  (let/ec _cont
(set! fp (sumPoint fp (if points (list-ref points (int idx)) #f)))
  )))
    (set! fp (divPoint fp (exact->inexact (cond [(string? face) (string-length face)] [(hash? face) (hash-count face)] [else (length face)]))))
    (set! facePoints (append facePoints (list fp)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return facePoints)
))
)
(define (sortEdges edges)
  (let/ec _return (begin
(define res (list))
(define tmp edges)
(let/ec _break (let loop ()
  (if (> (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)]) 0) (let ()
    (define min (if tmp (list-ref tmp (int 0)) #f))
    (define idx 0)
    (define j 1)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)])) (let ()
    (define e (if tmp (list-ref tmp (int j)) #f))
    (if (or (< (if e (list-ref e (int 0)) #f) (if min (list-ref min (int 0)) #f)) (and (equal? (if e (list-ref e (int 0)) #f) (if min (list-ref min (int 0)) #f)) (or (< (if e (list-ref e (int 1)) #f) (if min (list-ref min (int 1)) #f)) (and (equal? (if e (list-ref e (int 1)) #f) (if min (list-ref min (int 1)) #f)) (< (if e (list-ref e (int 2)) #f) (if min (list-ref min (int 2)) #f)))))) (let ()
(set! min e)
(set! idx j)
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! res (append res (list min)))
    (define out (list))
    (define k 0)
    (let/ec _break (let loop ()
  (if (< k (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)])) (let ()
    (if (not (equal? k idx)) (let ()
(set! out (append out (list (if tmp (list-ref tmp (int k)) #f))))
) (void))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! tmp out)
    (loop)) (void))))
(_return res)
))
)
(define (getEdgesFaces points faces)
  (let/ec _return (begin
(define edges (list))
(define fnum 0)
(let/ec _break (let loop ()
  (if (< fnum (cond [(string? faces) (string-length faces)] [(hash? faces) (hash-count faces)] [else (length faces)])) (let ()
    (define face (if faces (list-ref faces (int fnum)) #f))
    (define numP (cond [(string? face) (string-length face)] [(hash? face) (hash-count face)] [else (length face)]))
    (define pi 0)
    (let/ec _break (let loop ()
  (if (< pi numP) (let ()
    (define pn1 (if face (list-ref face (int pi)) #f))
    (define pn2 0)
    (if (< pi (- numP 1)) (let ()
(set! pn2 (if face (list-ref face (int (let ([__l pi] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) #f))
) (let ()
(set! pn2 (if face (list-ref face (int 0)) #f))
))
    (if (> pn1 pn2) (let ()
(define tmpn pn1)
(set! pn1 pn2)
(set! pn2 tmpn)
) (void))
    (set! edges (append edges (list (list pn1 pn2 fnum))))
    (set! pi (let ([__l pi] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! fnum (let ([__l fnum] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! edges (sortEdges edges))
(define merged (list))
(define idx 0)
(let/ec _break (let loop ()
  (if (< idx (cond [(string? edges) (string-length edges)] [(hash? edges) (hash-count edges)] [else (length edges)])) (let ()
    (define e1 (if edges (list-ref edges (int idx)) #f))
    (if (< idx (- (cond [(string? edges) (string-length edges)] [(hash? edges) (hash-count edges)] [else (length edges)]) 1)) (let ()
(define e2 (if edges (list-ref edges (int (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) #f))
(if (and (equal? (if e1 (list-ref e1 (int 0)) #f) (if e2 (list-ref e2 (int 0)) #f)) (equal? (if e1 (list-ref e1 (int 1)) #f) (if e2 (list-ref e2 (int 1)) #f))) (let ()
(set! merged (append merged (list (list (if e1 (list-ref e1 (int 0)) #f) (if e1 (list-ref e1 (int 1)) #f) (if e1 (list-ref e1 (int 2)) #f) (if e2 (list-ref e2 (int 2)) #f)))))
(set! idx (let ([__l idx] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(loop)
) (void))
) (void))
    (set! merged (append merged (list (list (if e1 (list-ref e1 (int 0)) #f) (if e1 (list-ref e1 (int 1)) #f) (if e1 (list-ref e1 (int 2)) #f) (- 1)))))
    (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define edgesCenters (list))
(let/ec _break (for ([me merged])
  (let/ec _cont
(define p1 (if points (list-ref points (int (if me (list-ref me (int 0)) #f))) #f))
(define p2 (if points (list-ref points (int (if me (list-ref me (int 1)) #f))) #f))
(define cp (centerPoint p1 p2))
(set! edgesCenters (append edgesCenters (list (hash "pn1" (if me (list-ref me (int 0)) #f) "pn2" (if me (list-ref me (int 1)) #f) "fn1" (if me (list-ref me (int 2)) #f) "fn2" (if me (list-ref me (int 3)) #f) "cp" cp))))
  )))
(_return edgesCenters)
))
)
(define (getEdgePoints points edgesFaces facePoints)
  (let/ec _return (begin
(define edgePoints (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? edgesFaces) (string-length edgesFaces)] [(hash? edgesFaces) (hash-count edgesFaces)] [else (length edgesFaces)])) (let ()
    (define edge (if edgesFaces (list-ref edgesFaces (int i)) #f))
    (define cp (if edge (hash-ref edge "cp" #f) #f))
    (define fp1 (if facePoints (list-ref facePoints (int (if edge (hash-ref edge "fn1" #f) #f))) #f))
    (define fp2 fp1)
    (if (not (equal? (if edge (hash-ref edge "fn2" #f) #f) (- 0 1))) (let ()
(set! fp2 (if facePoints (list-ref facePoints (int (if edge (hash-ref edge "fn2" #f) #f))) #f))
) (void))
    (define cfp (centerPoint fp1 fp2))
    (set! edgePoints (append edgePoints (list (centerPoint cp cfp))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return edgePoints)
))
)
(define (getAvgFacePoints points faces facePoints)
  (let/ec _return (begin
(define numP (cond [(string? points) (string-length points)] [(hash? points) (hash-count points)] [else (length points)]))
(define temp (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i numP) (let ()
    (set! temp (append temp (list (hash "p" (hash "x" 0.0 "y" 0.0 "z" 0.0) "n" 0))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define fnum 0)
(let/ec _break (let loop ()
  (if (< fnum (cond [(string? faces) (string-length faces)] [(hash? faces) (hash-count faces)] [else (length faces)])) (let ()
    (define fp (if facePoints (list-ref facePoints (int fnum)) #f))
    (let/ec _break (for ([pn (if faces (list-ref faces (int fnum)) #f)])
  (let/ec _cont
(define tp (if temp (list-ref temp (int pn)) #f))
(set! temp (list-set temp (int pn) (hash "p" (sumPoint (if tp (hash-ref tp "p" #f) #f) fp) "n" (let ([__l (if tp (hash-ref tp "n" #f) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
  )))
    (set! fnum (let ([__l fnum] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define avg (list))
(define j 0)
(let/ec _break (let loop ()
  (if (< j numP) (let ()
    (define tp (if temp (list-ref temp (int j)) #f))
    (set! avg (append avg (list (divPoint (if tp (hash-ref tp "p" #f) #f) (exact->inexact (if tp (hash-ref tp "n" #f) #f))))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return avg)
))
)
(define (getAvgMidEdges points edgesFaces)
  (let/ec _return (begin
(define numP (cond [(string? points) (string-length points)] [(hash? points) (hash-count points)] [else (length points)]))
(define temp (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i numP) (let ()
    (set! temp (append temp (list (hash "p" (hash "x" 0.0 "y" 0.0 "z" 0.0) "n" 0))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(let/ec _break (for ([edge edgesFaces])
  (let/ec _cont
(define cp (if edge (hash-ref edge "cp" #f) #f))
(define arr (list (if edge (hash-ref edge "pn1" #f) #f) (if edge (hash-ref edge "pn2" #f) #f)))
(let/ec _break (for ([pn arr])
  (let/ec _cont
(define tp (if temp (list-ref temp (int pn)) #f))
(set! temp (list-set temp (int pn) (hash "p" (sumPoint (if tp (hash-ref tp "p" #f) #f) cp) "n" (let ([__l (if tp (hash-ref tp "n" #f) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
  )))
  )))
(define avg (list))
(define j 0)
(let/ec _break (let loop ()
  (if (< j numP) (let ()
    (define tp (if temp (list-ref temp (int j)) #f))
    (set! avg (append avg (list (divPoint (if tp (hash-ref tp "p" #f) #f) (exact->inexact (if tp (hash-ref tp "n" #f) #f))))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return avg)
))
)
(define (getPointsFaces points faces)
  (let/ec _return (begin
(define pf (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? points) (string-length points)] [(hash? points) (hash-count points)] [else (length points)])) (let ()
    (set! pf (append pf (list 0)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define fnum 0)
(let/ec _break (let loop ()
  (if (< fnum (cond [(string? faces) (string-length faces)] [(hash? faces) (hash-count faces)] [else (length faces)])) (let ()
    (let/ec _break (for ([pn (if faces (list-ref faces (int fnum)) #f)])
  (let/ec _cont
(set! pf (list-set pf (int pn) (let ([__l (if pf (list-ref pf (int pn)) #f)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
  )))
    (set! fnum (let ([__l fnum] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return pf)
))
)
(define (getNewPoints points pf afp ame)
  (let/ec _return (begin
(define newPts (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? points) (string-length points)] [(hash? points) (hash-count points)] [else (length points)])) (let ()
    (define n (exact->inexact (if pf (list-ref pf (int i)) #f)))
    (define m1 (/ (- n 3.0) n))
    (define m2 (/ 1.0 n))
    (define m3 (/ 2.0 n))
    (define old (if points (list-ref points (int i)) #f))
    (define p1 (mulPoint old m1))
    (define p2 (mulPoint (if afp (list-ref afp (int i)) #f) m2))
    (define p3 (mulPoint (if ame (list-ref ame (int i)) #f) m3))
    (set! newPts (append newPts (list (sumPoint (sumPoint p1 p2) p3))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return newPts)
))
)
(define (key a b)
  (let/ec _return (begin
(if (< a b) (let ()
(_return (string-append (string-append (format "~a" a) ",") (format "~a" b)))
) (void))
(_return (string-append (string-append (format "~a" b) ",") (format "~a" a)))
))
)
(define (cmcSubdiv points faces)
  (let/ec _return (begin
(define facePoints (getFacePoints points faces))
(define edgesFaces (getEdgesFaces points faces))
(define edgePoints (getEdgePoints points edgesFaces facePoints))
(define avgFacePoints (getAvgFacePoints points faces facePoints))
(define avgMidEdges (getAvgMidEdges points edgesFaces))
(define pointsFaces (getPointsFaces points faces))
(define newPoints (getNewPoints points pointsFaces avgFacePoints avgMidEdges))
(define facePointNums (list))
(define nextPoint (cond [(string? newPoints) (string-length newPoints)] [(hash? newPoints) (hash-count newPoints)] [else (length newPoints)]))
(let/ec _break (for ([fp facePoints])
  (let/ec _cont
(set! newPoints (append newPoints (list fp)))
(set! facePointNums (append facePointNums (list nextPoint)))
(set! nextPoint (let ([__l nextPoint] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
  )))
(define edgePointNums (hash))
(define idx 0)
(let/ec _break (let loop ()
  (if (< idx (cond [(string? edgesFaces) (string-length edgesFaces)] [(hash? edgesFaces) (hash-count edgesFaces)] [else (length edgesFaces)])) (let ()
    (define e (if edgesFaces (list-ref edgesFaces (int idx)) #f))
    (set! newPoints (append newPoints (list (if edgePoints (list-ref edgePoints (int idx)) #f))))
    (set! edgePointNums (hash-set (or edgePointNums (hash)) (key (if e (hash-ref e "pn1" #f) #f) (if e (hash-ref e "pn2" #f) #f)) nextPoint))
    (set! nextPoint (let ([__l nextPoint] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define newFaces (list))
(define fnum 0)
(let/ec _break (let loop ()
  (if (< fnum (cond [(string? faces) (string-length faces)] [(hash? faces) (hash-count faces)] [else (length faces)])) (let ()
    (define oldFace (if faces (list-ref faces (int fnum)) #f))
    (if (equal? (cond [(string? oldFace) (string-length oldFace)] [(hash? oldFace) (hash-count oldFace)] [else (length oldFace)]) 4) (let ()
(define a (if oldFace (list-ref oldFace (int 0)) #f))
(define b (if oldFace (list-ref oldFace (int 1)) #f))
(define c (if oldFace (list-ref oldFace (int 2)) #f))
(define d (if oldFace (list-ref oldFace (int 3)) #f))
(define fpnum (if facePointNums (list-ref facePointNums (int fnum)) #f))
(define ab (if edgePointNums (hash-ref edgePointNums (key a b) #f) #f))
(define da (if edgePointNums (hash-ref edgePointNums (key d a) #f) #f))
(define bc (if edgePointNums (hash-ref edgePointNums (key b c) #f) #f))
(define cd (if edgePointNums (hash-ref edgePointNums (key c d) #f) #f))
(set! newFaces (append newFaces (list (list a ab fpnum da))))
(set! newFaces (append newFaces (list (list b bc fpnum ab))))
(set! newFaces (append newFaces (list (list c cd fpnum bc))))
(set! newFaces (append newFaces (list (list d da fpnum cd))))
) (void))
    (set! fnum (let ([__l fnum] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (list newPoints newFaces))
))
)
(define (formatPoint p)
  (let/ec _return (begin
(_return (string-append (string-append (string-append (string-append (string-append (string-append "[" (fmt4 (if p (hash-ref p "x" #f) #f))) " ") (fmt4 (if p (hash-ref p "y" #f) #f))) " ") (fmt4 (if p (hash-ref p "z" #f) #f))) "]"))
))
)
(define (formatFace f)
  (let/ec _return (begin
(if (equal? (cond [(string? f) (string-length f)] [(hash? f) (hash-count f)] [else (length f)]) 0) (let ()
(_return "[]")
) (void))
(define s (string-append "[" (fmt2 (if f (list-ref f (int 0)) #f))))
(define i 1)
(let/ec _break (let loop ()
  (if (< i (cond [(string? f) (string-length f)] [(hash? f) (hash-count f)] [else (length f)])) (let ()
    (set! s (string-append (string-append s " ") (fmt2 (if f (list-ref f (int i)) #f))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! s (string-append s "]"))
(_return s)
))
)
(define (main)
  (let/ec _return (begin
(define inputPoints (list (hash "x" (- 1.0) "y" 1.0 "z" 1.0) (hash "x" (- 1.0) "y" (- 1.0) "z" 1.0) (hash "x" 1.0 "y" (- 1.0) "z" 1.0) (hash "x" 1.0 "y" 1.0 "z" 1.0) (hash "x" 1.0 "y" (- 1.0) "z" (- 1.0)) (hash "x" 1.0 "y" 1.0 "z" (- 1.0)) (hash "x" (- 1.0) "y" (- 1.0) "z" (- 1.0)) (hash "x" (- 1.0) "y" 1.0 "z" (- 1.0))))
(define inputFaces (list (list 0 1 2 3) (list 3 2 4 5) (list 5 4 6 7) (list 7 0 3 5) (list 7 6 1 0) (list 6 1 2 4)))
(define outputPoints inputPoints)
(define outputFaces inputFaces)
(define i 0)
(let/ec _break (let loop ()
  (if (< i 1) (let ()
    (define res (cmcSubdiv outputPoints outputFaces))
    (set! outputPoints (if res (list-ref res (int 0)) #f))
    (set! outputFaces (if res (list-ref res (int 1)) #f))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(let/ec _break (for ([p outputPoints])
  (let/ec _cont
(displayln (formatPoint p))
  )))
(displayln "")
(let/ec _break (for ([f outputFaces])
  (let/ec _cont
(displayln (formatFace f))
  )))
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
