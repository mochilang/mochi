;; Generated by Mochi 0.10.50 on 2025-07-30 23:37 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (let loop ([i 0])
    (cond [(>= i (string-length s)) -1]
          [(string=? (substring s i (add1 i)) ch) i]
          [else (loop (add1 i))])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define small (list "zero" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))
(define tens (list "" "" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"))
(define smallOrd (list "zeroth" "first" "second" "third" "fourth" "fifth" "sixth" "seventh" "eighth" "ninth" "tenth" "eleventh" "twelfth" "thirteenth" "fourteenth" "fifteenth" "sixteenth" "seventeenth" "eighteenth" "nineteenth"))
(define tensOrd (list "" "" "twentieth" "thirtieth" "fortieth" "fiftieth" "sixtieth" "seventieth" "eightieth" "ninetieth"))
(define (say n)
  (let/ec _return (begin
(if (< n 20) (let ()
(_return (if small (list-ref small (int n)) #f))
) (void))
(if (< n 100) (let ()
(define res (if tens (list-ref tens (int (quotient n 10))) #f))
(define m (modulo n 10))
(if (not (equal? m 0)) (let ()
(set! res (string-append (string-append res "-") (if small (list-ref small (int m)) #f)))
) (void))
(_return res)
) (void))
(if (< n 1000) (let ()
(define res (string-append (say (quotient n 100)) " hundred"))
(define m (modulo n 100))
(if (not (equal? m 0)) (let ()
(set! res (string-append (string-append res " ") (say m)))
) (void))
(_return res)
) (void))
(if (< n 1000000) (let ()
(define res (string-append (say (quotient n 1000)) " thousand"))
(define m (modulo n 1000))
(if (not (equal? m 0)) (let ()
(set! res (string-append (string-append res " ") (say m)))
) (void))
(_return res)
) (void))
(define res (string-append (say (quotient n 1000000)) " million"))
(define m (modulo n 1000000))
(if (not (equal? m 0)) (let ()
(set! res (string-append (string-append res " ") (say m)))
) (void))
(_return res)
))
)
(define (sayOrdinal n)
  (let/ec _return (begin
(if (< n 20) (let ()
(_return (if smallOrd (list-ref smallOrd (int n)) #f))
) (void))
(if (< n 100) (let ()
(if (equal? (modulo n 10) 0) (let ()
(_return (if tensOrd (list-ref tensOrd (int (quotient n 10))) #f))
) (void))
(_return (string-append (string-append (say (- n (modulo n 10))) "-") (if smallOrd (list-ref smallOrd (int (modulo n 10))) #f)))
) (void))
(if (< n 1000) (let ()
(if (equal? (modulo n 100) 0) (let ()
(_return (string-append (say (quotient n 100)) " hundredth"))
) (void))
(_return (string-append (string-append (say (quotient n 100)) " hundred ") (sayOrdinal (modulo n 100))))
) (void))
(if (< n 1000000) (let ()
(if (equal? (modulo n 1000) 0) (let ()
(_return (string-append (say (quotient n 1000)) " thousandth"))
) (void))
(_return (string-append (string-append (say (quotient n 1000)) " thousand ") (sayOrdinal (modulo n 1000))))
) (void))
(if (equal? (modulo n 1000000) 0) (let ()
(_return (string-append (say (quotient n 1000000)) " millionth"))
) (void))
(_return (string-append (string-append (say (quotient n 1000000)) " million ") (sayOrdinal (modulo n 1000000))))
))
)
(define (split s sep)
  (let/ec _return (begin
(define parts (list))
(define cur "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (if (and (and (> (cond [(string? sep) (string-length sep)] [(hash? sep) (hash-count sep)] [else (length sep)]) 0) (<= (let ([__l i] [__r (cond [(string? sep) (string-length sep)] [(hash? sep) (hash-count sep)] [else (length sep)])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))) (string=? (slice s i (let ([__l i] [__r (cond [(string? sep) (string-length sep)] [(hash? sep) (hash-count sep)] [else (length sep)])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) sep)) (let ()
(set! parts (append parts (list cur)))
(set! cur "")
(set! i (let ([__l i] [__r (cond [(string? sep) (string-length sep)] [(hash? sep) (hash-count sep)] [else (length sep)])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (let ()
(set! cur (string-append cur (slice s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
(set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
    (loop)) (void))))
(set! parts (append parts (list cur)))
(_return parts)
))
)
(define (countLetters s)
  (let/ec _return (begin
(define cnt 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (define ch (slice s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (if (or (and (string>=? ch "A") (string<=? ch "Z")) (and (string>=? ch "a") (string<=? ch "z"))) (let ()
(set! cnt (let ([__l cnt] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return cnt)
))
)
(define words (list "Four" "is" "the" "number" "of" "letters" "in" "the" "first" "word" "of" "this" "sentence,"))
(define idx 0)
(define (wordLen w)
  (let/ec _return (begin
(let/ec _break (let loop ()
  (if (< (cond [(string? words) (string-length words)] [(hash? words) (hash-count words)] [else (length words)]) w) (let ()
    (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (define n (countLetters (if words (list-ref words (int idx)) #f)))
    (define parts (string-split (say n) " "))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? parts) (string-length parts)] [(hash? parts) (hash-count parts)] [else (length parts)])) (let ()
    (set! words (append words (list (if parts (list-ref parts (int j)) #f))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! words (append words (list "in")))
    (set! words (append words (list "the")))
    (set! parts (string-split (string-append (sayOrdinal (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) ",") " "))
    (set! j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? parts) (string-length parts)] [(hash? parts) (hash-count parts)] [else (length parts)])) (let ()
    (set! words (append words (list (if parts (list-ref parts (int j)) #f))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (loop)) (void))))
(define word (if words (list-ref words (int (- w 1))) #f))
(_return (list word (countLetters word)))
))
)
(define (totalLength)
  (let/ec _return (begin
(define tot 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? words) (string-length words)] [(hash? words) (hash-count words)] [else (length words)])) (let ()
    (set! tot (let ([__l tot] [__r (cond [(string? (if words (list-ref words (int i)) #f)) (string-length (if words (list-ref words (int i)) #f))] [(hash? (if words (list-ref words (int i)) #f)) (hash-count (if words (list-ref words (int i)) #f))] [else (length (if words (list-ref words (int i)) #f))])]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (< i (- (cond [(string? words) (string-length words)] [(hash? words) (hash-count words)] [else (length words)]) 1)) (let ()
(set! tot (let ([__l tot] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return tot)
))
)
(define (pad n width)
  (let/ec _return (begin
(define s (format "~a" n))
(let/ec _break (let loop ()
  (if (< (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) width) (let ()
    (set! s (string-append " " s))
    (loop)) (void))))
(_return s)
))
)
(define (main)
  (let/ec _return (begin
(displayln "The lengths of the first 201 words are:")
(define line "")
(define i 1)
(let/ec _break (let loop ()
  (if (<= i 201) (let ()
    (if (equal? (modulo i 25) 1) (let ()
(if (not (equal? i 1)) (let ()
(displayln line)
) (void))
(set! line (string-append (pad i 3) ":"))
) (void))
    (define r (wordLen i))
    (define n (if r (list-ref r (int 1)) #f))
    (set! line (string-append (string-append line " ") (pad n 2)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln line)
(displayln (string-append "Length of sentence so far: " (format "~a" (totalLength))))
(let/ec _break (for ([n (list 1000 10000 100000 1000000 10000000)])
  (let/ec _cont
(define r (wordLen n))
(define w (if r (list-ref r (int 0)) #f))
(define l (if r (list-ref r (int 1)) #f))
(displayln (string-append (string-append (string-append (string-append (string-append (string-append (string-append "Word " (pad n 8)) " is \"") w) "\", with ") (format "~a" l)) " letters.  Length of sentence so far: ") (format "~a" (totalLength))))
  )))
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
