;; Generated by Mochi 0.10.39 on 2025-07-24 18:38 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (current-inexact-milliseconds)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (if (< (string-length s) width)
      (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
      s))

(define PI 3.141592653589793)
(define TWO_PI 6.283185307179586)
(define (sinApprox x)
  (let/ec _return (begin
(define term x)
(define sum x)
(define n 1)
(let/ec _break (let loop ()
  (if (<= n 8) (let ()
    (define denom (exact->inexact (* (* 2 n) (let ([__l (* 2 n)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (set! term (/ (* (* (- term) x) x) denom))
    (set! sum (let ([__l sum] [__r term]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! n (let ([__l n] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return sum)
))
)
(define (floor x)
  (let/ec _return (begin
(define i (int x))
(if (> (exact->inexact i) x) (let ()
(set! i (- i 1))
) (void))
(_return (exact->inexact i))
))
)
(define (absFloat x)
  (let/ec _return (begin
(if (< x 0.0) (let ()
(_return (- x))
) (void))
(_return x)
))
)
(define (absInt n)
  (let/ec _return (begin
(if (< n 0) (let ()
(_return (- n))
) (void))
(_return n)
))
)
(define (parseIntStr str)
  (let/ec _return (begin
(define i 0)
(define neg #f)
(if (and (> (cond [(string? str) (string-length str)] [(hash? str) (hash-count str)] [else (length str)]) 0) (string=? (substring str 0 1) "-")) (let ()
(set! neg #t)
(set! i 1)
) (void))
(define n 0)
(define digits (hash "0" 0 "1" 1 "2" 2 "3" 3 "4" 4 "5" 5 "6" 6 "7" 7 "8" 8 "9" 9))
(let/ec _break (let loop ()
  (if (< i (cond [(string? str) (string-length str)] [(hash? str) (hash-count str)] [else (length str)])) (let ()
    (set! n (let ([__l (* n 10)] [__r (if digits (hash-ref digits (substring str i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) #f) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(if neg (let ()
(set! n (- n))
) (void))
(_return n)
))
)
(define (parseDate s)
  (let/ec _return (begin
(define y (parseIntStr (substring s 0 4)))
(define m (parseIntStr (substring s 5 7)))
(define d (parseIntStr (substring s 8 10)))
(_return (list y m d))
))
)
(define (leap y)
  (let/ec _return (begin
(if (equal? (modulo y 400) 0) (let ()
(_return #t)
) (void))
(if (equal? (modulo y 100) 0) (let ()
(_return #f)
) (void))
(_return (equal? (modulo y 4) 0))
))
)
(define (daysInMonth y m)
  (let/ec _return (begin
(define feb (if (leap y) 29 28))
(define lengths (list 31 feb 31 30 31 30 31 31 30 31 30 31))
(_return (list-ref lengths (- m 1)))
))
)
(define (addDays y m d n)
  (let/ec _return (begin
(define yy y)
(define mm m)
(define dd d)
(if (>= n 0) (let ()
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (let ()
    (set! dd (let ([__l dd] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (> dd (daysInMonth yy mm)) (let ()
(set! dd 1)
(set! mm (let ([__l mm] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(if (> mm 12) (let ()
(set! mm 1)
(set! yy (let ([__l yy] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
) (let ()
(define i 0)
(let/ec _break (let loop ()
  (if (> i n) (let ()
    (set! dd (- dd 1))
    (if (< dd 1) (let ()
(set! mm (- mm 1))
(if (< mm 1) (let ()
(set! mm 12)
(set! yy (- yy 1))
) (void))
(set! dd (daysInMonth yy mm))
) (void))
    (set! i (- i 1))
    (loop)) (void))))
))
(_return (list yy mm dd))
))
)
(define (pad2 n)
  (let/ec _return (begin
(if (< n 10) (let ()
(_return (string-append "0" (format "~a" n)))
) (void))
(_return (format "~a" n))
))
)
(define (dateString y m d)
  (let/ec _return (begin
(_return (string-append (string-append (string-append (string-append (format "~a" y) "-") (pad2 m)) "-") (pad2 d)))
))
)
(define (day y m d)
  (let/ec _return (begin
(define part1 (* 367 y))
(define part2 (int (quotient (* 7 (int (let ([__l y] [__r (quotient (let ([__l m] [__r 9]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 12)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) 4)))
(define part3 (int (quotient (* 275 m) 9)))
(_return (- (let ([__l (let ([__l (- part1 part2)] [__r part3]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r d]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 730530))
))
)
(define (biorhythms birth target)
  (let/ec _return (begin
(define bparts (parseDate birth))
(define by (list-ref bparts 0))
(define bm (list-ref bparts 1))
(define bd (list-ref bparts 2))
(define tparts (parseDate target))
(define ty (list-ref tparts 0))
(define tm (list-ref tparts 1))
(define td (list-ref tparts 2))
(define diff (absInt (- (day ty tm td) (day by bm bd))))
(displayln (string-append (string-append (string-append "Born " birth) ", Target ") target))
(displayln (string-append "Day " (format "~a" diff)))
(define cycles (list "Physical day " "Emotional day" "Mental day   "))
(define lengths (list 23 28 33))
(define quadrants (list (list "up and rising" "peak") (list "up but falling" "transition") (list "down and falling" "valley") (list "down but rising" "transition")))
(define i 0)
(let/ec _break (let loop ()
  (if (< i 3) (let ()
    (define length (list-ref lengths i))
    (define cycle (list-ref cycles i))
    (define position (modulo diff length))
    (define quadrant (/ (* position 4) length))
    (define percent (sinApprox (/ (* (* 2.0 PI) (exact->inexact position)) (exact->inexact length))))
    (set! percent (/ (floor (* percent 1000.0)) 10.0))
    (define description "")
    (if (> percent 95.0) (let ()
(set! description " peak")
) (let ()
(if (< percent (- 95.0)) (let ()
(set! description " valley")
) (let ()
(if (< (absFloat percent) 5.0) (let ()
(set! description " critical transition")
) (let ()
(define daysToAdd (- (quotient (* (let ([__l quadrant] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) length) 4) position))
(define res (addDays ty tm td daysToAdd))
(define ny (list-ref res 0))
(define nm (list-ref res 1))
(define nd (list-ref res 2))
(define transition (dateString ny nm nd))
(define trend (list-ref (list-ref quadrants quadrant) 0))
(define next (list-ref (list-ref quadrants quadrant) 1))
(define pct (format "~a" percent))
(if (not (contains pct ".")) (let ()
(set! pct (string-append pct ".0"))
) (void))
(set! description (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append " " pct) "% (") trend) ", next ") next) " ") transition) ")"))
))
))
))
    (define posStr (format "~a" position))
    (if (< position 10) (let ()
(set! posStr (string-append " " posStr))
) (void))
    (displayln (string-append (string-append (string-append cycle posStr) " : ") description))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln "")
))
)
(define (main)
  (let/ec _return (begin
(define pairs (list (list "1943-03-09" "1972-07-11") (list "1809-01-12" "1863-11-19") (list "1809-02-12" "1863-11-19")))
(define idx 0)
(let/ec _break (let loop ()
  (if (< idx (cond [(string? pairs) (string-length pairs)] [(hash? pairs) (hash-count pairs)] [else (length pairs)])) (let ()
    (define p (list-ref pairs idx))
    (biorhythms (list-ref p 0) (list-ref p 1))
    (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(main)
