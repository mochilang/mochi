;; Generated by Mochi 0.10.50 on 2025-07-30 23:37 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (let loop ([i 0])
    (cond [(>= i (string-length s)) -1]
          [(string=? (substring s i (add1 i)) ch) i]
          [else (loop (add1 i))])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define (capitalize s)
  (let/ec _return (begin
(if (equal? (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) 0) (let ()
(_return s)
) (void))
(_return (let ([__l (upper (slice s 0 1))] [__r (slice s 1 (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
))
)
(define small (list "zero" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine" "ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))
(define tens (list "" "" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"))
(define illions (list "" " thousand" " million" " billion" " trillion" " quadrillion" " quintillion"))
(define (say n)
  (let/ec _return (begin
(define t "")
(if (< n 0) (let ()
(set! t "negative ")
(set! n (- n))
) (void))
(if (< n 20) (let ()
(_return (string-append t (if small (list-ref small (int n)) #f)))
) (let ()
(if (< n 100) (let ()
(set! t (if tens (list-ref tens (int (quotient n 10))) #f))
(define s (modulo n 10))
(if (> s 0) (let ()
(set! t (string-append (string-append t "-") (if small (list-ref small (int s)) #f)))
) (void))
(_return t)
) (let ()
(if (< n 1000) (let ()
(set! t (string-append (if small (list-ref small (int (quotient n 100))) #f) " hundred"))
(define s (modulo n 100))
(if (> s 0) (let ()
(set! t (string-append (string-append t " ") (say s)))
) (void))
(_return t)
) (void))
))
))
(define sx "")
(define i 0)
(define nn n)
(let/ec _break (let loop ()
  (if (> nn 0) (let ()
    (define p (modulo nn 1000))
    (set! nn (quotient nn 1000))
    (if (> p 0) (let ()
(define ix (let ([__l (say p)] [__r (if illions (list-ref illions (int i)) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(if (not (string=? sx "")) (let ()
(set! ix (string-append (string-append ix " ") sx))
) (void))
(set! sx ix)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (string-append t sx))
))
)
(define (fourIsMagic n)
  (let/ec _return (begin
(define s (say n))
(set! s (capitalize s))
(define t s)
(let/ec _break (let loop ()
  (if (not (equal? n 4)) (let ()
    (set! n (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]))
    (set! s (say n))
    (set! t (string-append (string-append (string-append (string-append t " is ") s) ", ") s))
    (loop)) (void))))
(set! t (string-append t " is magic."))
(_return t)
))
)
(define (main)
  (let/ec _return (begin
(define nums (list 0 4 6 11 13 75 100 337 (- 164) 9223372036854775807))
(let/ec _break (for ([n nums])
  (let/ec _cont
(displayln (fourIsMagic n))
  )))
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
