;; Generated by Mochi 0.10.37 on 2025-07-23 10:13 +0700
#lang racket/base
(require racket/list racket/string racket/math json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (current-inexact-milliseconds)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (input) (read-line))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))


(define board (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0))
(define solved (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0))
(define empty 15)
(define moves 0)
(define quit #f)
(define (randMove)
  (let/ec _return (begin
(_return (modulo (now) 4))
))
)
(define (isSolved)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i 16) (let ()
    (if (not (equal? (list-ref board i) (list-ref solved i))) (let ()
(_return #f)
) (void))
    (set! i (+ i 1))
    (loop)) (void))))
(_return #t)
))
)
(define (isValidMove m)
  (let/ec _return (begin
(if (equal? m 0) (let ()
(_return (hash "idx" (- empty 4) "ok" (> (quotient empty 4) 0)))
) (void))
(if (equal? m 1) (let ()
(_return (hash "idx" (+ empty 4) "ok" (< (quotient empty 4) 3)))
) (void))
(if (equal? m 2) (let ()
(_return (hash "idx" (+ empty 1) "ok" (< (modulo empty 4) 3)))
) (void))
(if (equal? m 3) (let ()
(_return (hash "idx" (- empty 1) "ok" (> (modulo empty 4) 0)))
) (void))
(_return (hash "idx" 0 "ok" #f))
))
)
(define (doMove m)
  (let/ec _return (begin
(define r (isValidMove m))
(if (not (hash-ref r "ok")) (let ()
(_return #f)
) (void))
(define i empty)
(define j (int (hash-ref r "idx")))
(define tmp (list-ref board i))
(set! board (list-set board i (list-ref board j)))
(set! board (list-set board j tmp))
(set! empty j)
(set! moves (+ moves 1))
(_return #t)
))
)
(define (shuffle n)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (or (< i n) (isSolved)) (let ()
    (if (doMove (randMove)) (let ()
(set! i (+ i 1))
) (void))
    (loop)) (void))))
))
)
(define (printBoard)
  (let/ec _return (begin
(define line "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i 16) (let ()
    (define val (list-ref board i))
    (if (equal? val 0) (let ()
(set! line (string-append line "  ."))
) (let ()
(define s (format "~a" val))
(if (< val 10) (let ()
(set! line (string-append (string-append line "  ") s))
) (let ()
(set! line (string-append (string-append line " ") s))
))
))
    (if (equal? (modulo i 4) 3) (let ()
(displayln line)
(set! line "")
) (void))
    (set! i (+ i 1))
    (loop)) (void))))
))
)
(define (playOneMove)
  (let/ec _return (begin
(let/ec _break (let loop ()
  (if #t (let ()
    (displayln (string-append (string-append "Enter move #" (format "~a" (+ moves 1))) " (U, D, L, R, or Q): "))
    (define s (input))
    (if (string=? s "") (let ()
(loop)
) (void))
    (define c (sublist s 0 1))
    (define m 0)
    (if (or (string=? c "U") (string=? c "u")) (let ()
(set! m 0)
) (let ()
(if (or (string=? c "D") (string=? c "d")) (let ()
(set! m 1)
) (let ()
(if (or (string=? c "R") (string=? c "r")) (let ()
(set! m 2)
) (let ()
(if (or (string=? c "L") (string=? c "l")) (let ()
(set! m 3)
) (let ()
(if (or (string=? c "Q") (string=? c "q")) (let ()
(displayln (string-append (string-append "Quiting after " (format "~a" moves)) " moves."))
(set! quit #t)
(_return void)
) (let ()
(displayln (string-append (string-append (string-append "Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" "up, down, left, or right. You can also enter \"Q\" to quit.\n") "Upper or lowercase is accepted and only the first non-blank\n") "character is important (i.e. you may enter \"up\" if you like)."))
(loop)
))
))
))
))
))
    (if (not (doMove m)) (let ()
(displayln "That is not a valid move at the moment.")
(loop)
) (void))
    (_return void)
    (loop)) (void))))
))
)
(define (play)
  (let/ec _return (begin
(displayln "Starting board:")
(let/ec _break (let loop ()
  (if (and (not quit) (equal? (isSolved) #f)) (let ()
    (displayln "")
    (printBoard)
    (playOneMove)
    (loop)) (void))))
(if (isSolved) (let ()
(displayln (string-append (string-append "You solved the puzzle in " (format "~a" moves)) " moves."))
) (void))
))
)
(define (main)
  (let/ec _return (begin
(shuffle 50)
(play)
))
)
(main)
