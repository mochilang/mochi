;; Generated by Mochi 0.10.40 on 2025-07-25 19:02 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (if (< (string-length s) width)
      (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
      s))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define board (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0))
(define solved (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0))
(define empty 15)
(define moves 0)
(define quit #f)
(define (randMove)
  (let/ec _return (begin
(_return (modulo (now) 4))
))
)
(define (isSolved)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i 16) (let ()
    (if (not (equal? (list-ref board i) (list-ref solved i))) (let ()
(_return #f)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #t)
))
)
(define (isValidMove m)
  (let/ec _return (begin
(if (equal? m 0) (let ()
(_return (hash "idx" (- empty 4) "ok" (> (quotient empty 4) 0)))
) (void))
(if (equal? m 1) (let ()
(_return (hash "idx" (let ([__l empty] [__r 4]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) "ok" (< (quotient empty 4) 3)))
) (void))
(if (equal? m 2) (let ()
(_return (hash "idx" (let ([__l empty] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) "ok" (< (modulo empty 4) 3)))
) (void))
(if (equal? m 3) (let ()
(_return (hash "idx" (- empty 1) "ok" (> (modulo empty 4) 0)))
) (void))
(_return (hash "idx" 0 "ok" #f))
))
)
(define (doMove m)
  (let/ec _return (begin
(define r (isValidMove m))
(if (not (if r (hash-ref r "ok" #f) #f)) (let ()
(_return #f)
) (void))
(define i empty)
(define j (if r (hash-ref r "idx" #f) #f))
(define tmp (list-ref board i))
(set! board (list-set board i (list-ref board j)))
(set! board (list-set board j tmp))
(set! empty j)
(set! moves (let ([__l moves] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(_return #t)
))
)
(define (shuffle n)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (or (< i n) (isSolved)) (let ()
    (if (doMove (randMove)) (let ()
(set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (loop)) (void))))
))
)
(define (printBoard)
  (let/ec _return (begin
(define line "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i 16) (let ()
    (define val (list-ref board i))
    (if (equal? val 0) (let ()
(set! line (string-append line "  ."))
) (let ()
(define s (format "~a" val))
(if (< val 10) (let ()
(set! line (string-append (string-append line "  ") s))
) (let ()
(set! line (string-append (string-append line " ") s))
))
))
    (if (equal? (modulo i 4) 3) (let ()
(displayln line)
(set! line "")
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (playOneMove)
  (let/ec _return (begin
(let/ec _break (let loop ()
  (if #t (let ()
    (displayln (string-append (string-append "Enter move #" (format "~a" (let ([__l moves] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) " (U, D, L, R, or Q): "))
    (define s (input))
    (if (string=? s "") (let ()
(loop)
) (void))
    (define c (substring s 0 1))
    (define m 0)
    (if (or (string=? c "U") (string=? c "u")) (let ()
(set! m 0)
) (let ()
(if (or (string=? c "D") (string=? c "d")) (let ()
(set! m 1)
) (let ()
(if (or (string=? c "R") (string=? c "r")) (let ()
(set! m 2)
) (let ()
(if (or (string=? c "L") (string=? c "l")) (let ()
(set! m 3)
) (let ()
(if (or (string=? c "Q") (string=? c "q")) (let ()
(displayln (string-append (string-append "Quiting after " (format "~a" moves)) " moves."))
(set! quit #t)
(_return void)
) (let ()
(displayln (string-append (string-append (string-append "Please enter \"U\", \"D\", \"L\", or \"R\" to move the empty cell\n" "up, down, left, or right. You can also enter \"Q\" to quit.\n") "Upper or lowercase is accepted and only the first non-blank\n") "character is important (i.e. you may enter \"up\" if you like)."))
(loop)
))
))
))
))
))
    (if (not (doMove m)) (let ()
(displayln "That is not a valid move at the moment.")
(loop)
) (void))
    (_return void)
    (loop)) (void))))
))
)
(define (play)
  (let/ec _return (begin
(displayln "Starting board:")
(let/ec _break (let loop ()
  (if (and (not quit) (equal? (isSolved) #f)) (let ()
    (displayln "")
    (printBoard)
    (playOneMove)
    (loop)) (void))))
(if (isSolved) (let ()
(displayln (string-append (string-append "You solved the puzzle in " (format "~a" moves)) " moves."))
) (void))
))
)
(define (main)
  (let/ec _return (begin
(shuffle 50)
(play)
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
