;; Generated by Mochi 0.10.37 on 2025-07-23 14:07 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (current-inexact-milliseconds)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))


(define adfgvx "ADFGVX")
(define alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
(define (shuffleStr s)
  (let/ec _return (begin
(define arr (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (set! arr (append arr (list (substring s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define j (- (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)]) 1))
(let/ec _break (let loop ()
  (if (> j 0) (let ()
    (define k (modulo (now) (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
    (define tmp (list-ref arr j))
    (set! arr (list-set arr j (list-ref arr k)))
    (set! arr (list-set arr k tmp))
    (set! j (- j 1))
    (loop)) (void))))
(define out "")
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)])) (let ()
    (set! out (string-append out (list-ref arr i)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (createPolybius)
  (let/ec _return (begin
(define shuffled (shuffleStr alphabet))
(define labels (list))
(define li 0)
(let/ec _break (let loop ()
  (if (< li (cond [(string? adfgvx) (string-length adfgvx)] [(hash? adfgvx) (hash-count adfgvx)] [else (length adfgvx)])) (let ()
    (set! labels (append labels (list (substring adfgvx li (let ([__l li] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! li (let ([__l li] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln "6 x 6 Polybius square:\n")
(displayln "  | A D F G V X")
(displayln "---------------")
(define p (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i 6) (let ()
    (define row (substring shuffled (* i 6) (* (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 6)))
    (set! p (append p (list row)))
    (define line (string-append (list-ref labels i) " | "))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j 6) (let ()
    (set! line (string-append (string-append line (sublist row j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) " "))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (displayln line)
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return p)
))
)
(define (createKey n)
  (let/ec _return (begin
(if (or (< n 7) (> n 12)) (let ()
(displayln "Key should be within 7 and 12 letters long.")
) (void))
(define pool "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
(define key "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (let ()
    (define idx (modulo (now) (cond [(string? pool) (string-length pool)] [(hash? pool) (hash-count pool)] [else (length pool)])))
    (set! key (string-append key (string (string-ref pool idx))))
    (set! pool (let ([__l (substring pool 0 idx)] [__r (substring pool (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (cond [(string? pool) (string-length pool)] [(hash? pool) (hash-count pool)] [else (length pool)]))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(displayln (string-append "\nThe key is " key))
(_return key)
))
)
(define (orderKey key)
  (let/ec _return (begin
(define pairs (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])) (let ()
    (set! pairs (append pairs (list (list (substring key i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) i))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define n (cond [(string? pairs) (string-length pairs)] [(hash? pairs) (hash-count pairs)] [else (length pairs)]))
(define m 0)
(let/ec _break (let loop ()
  (if (< m n) (let ()
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (- n 1)) (let ()
    (if (> (list-ref (list-ref pairs j) 0) (list-ref (list-ref pairs (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) 0)) (let ()
(define tmp (list-ref pairs j))
(set! pairs (list-set pairs j (list-ref pairs (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
(set! pairs (list-set pairs (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) tmp))
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! m (let ([__l m] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define res (list))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i n) (let ()
    (set! res (append res (list (int (list-ref (list-ref pairs i) 1)))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (encrypt polybius key plainText)
  (let/ec _return (begin
(define labels (list))
(define li 0)
(let/ec _break (let loop ()
  (if (< li (cond [(string? adfgvx) (string-length adfgvx)] [(hash? adfgvx) (hash-count adfgvx)] [else (length adfgvx)])) (let ()
    (set! labels (append labels (list (substring adfgvx li (let ([__l li] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! li (let ([__l li] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define temp "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? plainText) (string-length plainText)] [(hash? plainText) (hash-count plainText)] [else (length plainText)])) (let ()
    (define r 0)
    (let/ec _break (let loop ()
  (if (< r 6) (let ()
    (define c 0)
    (let/ec _break (let loop ()
  (if (< c 6) (let ()
    (if (string=? (sublist (list-ref polybius r) c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (substring plainText i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) (let ()
(set! temp (string-append (string-append temp (sublist labels r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) (sublist labels c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define colLen (quotient (cond [(string? temp) (string-length temp)] [(hash? temp) (hash-count temp)] [else (length temp)]) (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])))
(if (> (modulo (cond [(string? temp) (string-length temp)] [(hash? temp) (hash-count temp)] [else (length temp)]) (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])) 0) (let ()
(set! colLen (let ([__l colLen] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(define table (list))
(define rIdx 0)
(let/ec _break (let loop ()
  (if (< rIdx colLen) (let ()
    (define row (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])) (let ()
    (set! row (append row (list "")))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! table (append table (list row)))
    (set! rIdx (let ([__l rIdx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define idx 0)
(let/ec _break (let loop ()
  (if (< idx (cond [(string? temp) (string-length temp)] [(hash? temp) (hash-count temp)] [else (length temp)])) (let ()
    (define row (quotient idx (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])))
    (define col (modulo idx (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])))
    (set! table (list-set table row (list-set (list-ref table row) col (substring temp idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define order (orderKey key))
(define cols (list))
(define ci 0)
(let/ec _break (let loop ()
  (if (< ci (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])) (let ()
    (define colStr "")
    (define ri 0)
    (let/ec _break (let loop ()
  (if (< ri colLen) (let ()
    (set! colStr (string-append colStr (list-ref (list-ref table ri) (list-ref order ci))))
    (set! ri (let ([__l ri] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! cols (append cols (list colStr)))
    (set! ci (let ([__l ci] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define result "")
(set! ci 0)
(let/ec _break (let loop ()
  (if (< ci (cond [(string? cols) (string-length cols)] [(hash? cols) (hash-count cols)] [else (length cols)])) (let ()
    (set! result (string-append result (list-ref cols ci)))
    (if (< ci (- (cond [(string? cols) (string-length cols)] [(hash? cols) (hash-count cols)] [else (length cols)]) 1)) (let ()
(set! result (string-append result " "))
) (void))
    (set! ci (let ([__l ci] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return result)
))
)
(define (indexOf s ch)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (if (string=? (substring s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) ch) (let ()
(_return i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (- 1))
))
)
(define (decrypt polybius key cipherText)
  (let/ec _return (begin
(define colStrs (list))
(define start 0)
(define i 0)
(let/ec _break (let loop ()
  (if (<= i (cond [(string? cipherText) (string-length cipherText)] [(hash? cipherText) (hash-count cipherText)] [else (length cipherText)])) (let ()
    (if (or (equal? i (cond [(string? cipherText) (string-length cipherText)] [(hash? cipherText) (hash-count cipherText)] [else (length cipherText)])) (string=? (string (string-ref cipherText i)) " ")) (let ()
(set! colStrs (append colStrs (list (substring cipherText start i))))
(set! start (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define maxColLen 0)
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? colStrs) (string-length colStrs)] [(hash? colStrs) (hash-count colStrs)] [else (length colStrs)])) (let ()
    (if (> (cond [(string? (list-ref colStrs i)) (string-length (list-ref colStrs i))] [(hash? (list-ref colStrs i)) (hash-count (list-ref colStrs i))] [else (length (list-ref colStrs i))]) maxColLen) (let ()
(set! maxColLen (cond [(string? (list-ref colStrs i)) (string-length (list-ref colStrs i))] [(hash? (list-ref colStrs i)) (hash-count (list-ref colStrs i))] [else (length (list-ref colStrs i))]))
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define cols (list))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? colStrs) (string-length colStrs)] [(hash? colStrs) (hash-count colStrs)] [else (length colStrs)])) (let ()
    (define s (list-ref colStrs i))
    (define ls (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (set! ls (append ls (list (substring s j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if (< (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) maxColLen) (let ()
(define pad (list))
(define k 0)
(let/ec _break (let loop ()
  (if (< k maxColLen) (let ()
    (if (< k (cond [(string? ls) (string-length ls)] [(hash? ls) (hash-count ls)] [else (length ls)])) (let ()
(set! pad (append pad (list (list-ref ls k))))
) (let ()
(set! pad (append pad (list "")))
))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! cols (append cols (list pad)))
) (let ()
(set! cols (append cols (list ls)))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define table (list))
(define r 0)
(let/ec _break (let loop ()
  (if (< r maxColLen) (let ()
    (define row (list))
    (define c 0)
    (let/ec _break (let loop ()
  (if (< c (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])) (let ()
    (set! row (append row (list "")))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! table (append table (list row)))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define order (orderKey key))
(set! r 0)
(let/ec _break (let loop ()
  (if (< r maxColLen) (let ()
    (define c 0)
    (let/ec _break (let loop ()
  (if (< c (cond [(string? key) (string-length key)] [(hash? key) (hash-count key)] [else (length key)])) (let ()
    (set! table (list-set table r (list-set (list-ref table r) (list-ref order c) (list-ref (list-ref cols c) r))))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define temp "")
(set! r 0)
(let/ec _break (let loop ()
  (if (< r (cond [(string? table) (string-length table)] [(hash? table) (hash-count table)] [else (length table)])) (let ()
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? (list-ref table r)) (string-length (list-ref table r))] [(hash? (list-ref table r)) (hash-count (list-ref table r))] [else (length (list-ref table r))])) (let ()
    (set! temp (string-append temp (list-ref (list-ref table r) j)))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define plainText "")
(define idx 0)
(let/ec _break (let loop ()
  (if (< idx (cond [(string? temp) (string-length temp)] [(hash? temp) (hash-count temp)] [else (length temp)])) (let ()
    (define rIdx (indexOf adfgvx (substring temp idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (define cIdx (indexOf adfgvx (substring temp (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (let ([__l idx] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (set! plainText (string-append plainText (list-ref (list-ref polybius rIdx) cIdx)))
    (set! idx (let ([__l idx] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return plainText)
))
)
(define (main)
  (let/ec _return (begin
(define plainText "ATTACKAT1200AM")
(define polybius (createPolybius))
(define key (createKey 9))
(displayln (string-append "\nPlaintext : " plainText))
(define cipherText (encrypt polybius key plainText))
(displayln (string-append "\nEncrypted : " cipherText))
(define plainText2 (decrypt polybius key cipherText))
(displayln (string-append "\nDecrypted : " plainText2))
))
)
(main)
