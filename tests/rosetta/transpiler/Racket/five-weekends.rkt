;; Generated by Mochi 0.10.50 on 2025-07-30 21:05 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (let loop ([i 0])
    (cond [(>= i (string-length s)) -1]
          [(string=? (substring s i (add1 i)) ch) i]
          [else (loop (add1 i))])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define (weekday y m d)
  (let/ec _return (begin
(define yy y)
(define mm m)
(if (< mm 3) (let ()
(set! mm (let ([__l mm] [__r 12]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! yy (- yy 1))
) (void))
(define k (modulo yy 100))
(define j (int (quotient yy 100)))
(define a (int (quotient (* 13 (let ([__l mm] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) 5)))
(define b (int (quotient k 4)))
(define c (int (quotient j 4)))
(_return (modulo (let ([__l (let ([__l (let ([__l (let ([__l (let ([__l d] [__r a]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r k]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r b]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r c]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (* 5 j)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 7))
))
)
(define (main)
  (let/ec _return (begin
(define months31 (list 1 3 5 7 8 10 12))
(define names (list "January" "February" "March" "April" "May" "June" "July" "August" "September" "October" "November" "December"))
(define count 0)
(define firstY 0)
(define firstM 0)
(define lastY 0)
(define lastM 0)
(define haveNone (list))
(displayln "Months with five weekends:")
(let/ec _break (let ([year 1900])
  (let loop ()
    (when (< year 2101)
(define hasOne #f)
(let/ec _break (for ([m months31])
  (let/ec _cont
(if (equal? (weekday year m 1) 6) (let ()
(displayln (string-append (string-append (string-append "  " (format "~a" year)) " ") (if names (list-ref names (int (- m 1))) #f)))
(set! count (let ([__l count] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! hasOne #t)
(set! lastY year)
(set! lastM m)
(if (equal? firstY 0) (let ()
(set! firstY year)
(set! firstM m)
) (void))
) (void))
  )))
(if (not hasOne) (let ()
(set! haveNone (append haveNone (list year)))
) (void))
      (set! year (+ year 1))
      (loop)))
))
(displayln (string-append (format "~a" count) " total"))
(displayln "")
(displayln "First five dates of weekends:")
(let/ec _break (let ([i 0])
  (let loop ()
    (when (< i 5)
(define day (let ([__l 1] [__r (* 7 i)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(displayln (string-append (string-append (string-append (string-append (string-append "  Friday, " (if names (list-ref names (int (- firstM 1))) #f)) " ") (format "~a" day)) ", ") (format "~a" firstY)))
      (set! i (+ i 1))
      (loop)))
))
(displayln "Last five dates of weekends:")
(let/ec _break (let ([i 0])
  (let loop ()
    (when (< i 5)
(define day (let ([__l 1] [__r (* 7 i)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(displayln (string-append (string-append (string-append (string-append (string-append "  Friday, " (if names (list-ref names (int (- lastM 1))) #f)) " ") (format "~a" day)) ", ") (format "~a" lastY)))
      (set! i (+ i 1))
      (loop)))
))
(displayln "")
(displayln "Years with no months with five weekends:")
(let/ec _break (for ([y haveNone])
  (let/ec _cont
(displayln (string-append "  " (format "~a" y)))
  )))
(displayln (string-append (format "~a" (cond [(string? haveNone) (string-length haveNone)] [(hash? haveNone) (hash-count haveNone)] [else (length haveNone)])) " total"))
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
