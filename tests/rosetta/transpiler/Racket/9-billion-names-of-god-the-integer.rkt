;; Generated by Mochi 0.10.37 on 2025-07-23 10:52 +0700
#lang racket/base
(require racket/list racket/string racket/math json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (current-inexact-milliseconds)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))


(define (bigTrim a)
  (let/ec _return (begin
(define n (cond [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)]))
(let/ec _break (let loop ()
  (if (and (> n 1) (equal? (list-ref a (- n 1)) 0)) (let ()
    (set! a (sublist a 0 (- n 1)))
    (set! n (- n 1))
    (loop)) (void))))
(_return a)
))
)
(define (bigFromInt x)
  (let/ec _return (begin
(if (equal? x 0) (let ()
(_return (list 0))
) (void))
(define digits (list))
(define n x)
(let/ec _break (let loop ()
  (if (> n 0) (let ()
    (set! digits (append digits (list (modulo n 10))))
    (set! n (quotient n 10))
    (loop)) (void))))
(_return digits)
))
)
(define (bigAdd a b)
  (let/ec _return (begin
(define res (list))
(define carry 0)
(define i 0)
(let/ec _break (let loop ()
  (if (or (or (< i (cond [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)])) (< i (cond [(string? b) (string-length b)] [(hash? b) (hash-count b)] [else (length b)]))) (> carry 0)) (let ()
    (define av 0)
    (if (< i (cond [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)])) (let ()
(set! av (list-ref a i))
) (void))
    (define bv 0)
    (if (< i (cond [(string? b) (string-length b)] [(hash? b) (hash-count b)] [else (length b)])) (let ()
(set! bv (list-ref b i))
) (void))
    (define s (+ (+ av bv) carry))
    (set! res (append res (list (modulo s 10))))
    (set! carry (quotient s 10))
    (set! i (+ i 1))
    (loop)) (void))))
(_return (bigTrim res))
))
)
(define (bigSub a b)
  (let/ec _return (begin
(define res (list))
(define borrow 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)])) (let ()
    (define av (list-ref a i))
    (define bv 0)
    (if (< i (cond [(string? b) (string-length b)] [(hash? b) (hash-count b)] [else (length b)])) (let ()
(set! bv (list-ref b i))
) (void))
    (define diff (- (- av bv) borrow))
    (if (< diff 0) (let ()
(set! diff (+ diff 10))
(set! borrow 1)
) (let ()
(set! borrow 0)
))
    (set! res (append res (list diff)))
    (set! i (+ i 1))
    (loop)) (void))))
(_return (bigTrim res))
))
)
(define (bigToString a)
  (let/ec _return (begin
(define s "")
(define i (- (cond [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)]) 1))
(let/ec _break (let loop ()
  (if (>= i 0) (let ()
    (set! s (string-append s (format "~a" (list-ref a i))))
    (set! i (- i 1))
    (loop)) (void))))
(_return s)
))
)
(define (minInt a b)
  (let/ec _return (begin
(if (< a b) (let ()
(_return a)
) (let ()
(_return b)
))
))
)
(define (cumu n)
  (let/ec _return (begin
(define cache (list (list (bigFromInt 1))))
(define y 1)
(let/ec _break (let loop ()
  (if (<= y n) (let ()
    (define row (list (bigFromInt 0)))
    (define x 1)
    (let/ec _break (let loop ()
  (if (<= x y) (let ()
    (define val (list-ref (list-ref cache (- y x)) (minInt x (- y x))))
    (set! row (append row (list (bigAdd (list-ref row (- (cond [(string? row) (string-length row)] [(hash? row) (hash-count row)] [else (length row)]) 1)) val))))
    (set! x (+ x 1))
    (loop)) (void))))
    (set! cache (append cache (list row)))
    (set! y (+ y 1))
    (loop)) (void))))
(_return (list-ref cache n))
))
)
(define (row n)
  (let/ec _return (begin
(define e (cumu n))
(define out (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (let ()
    (define diff (bigSub (list-ref e (+ i 1)) (list-ref e i)))
    (set! out (append out (list (bigToString diff))))
    (set! i (+ i 1))
    (loop)) (void))))
(_return out)
))
)
(displayln "rows:")
(define x 1)
(let/ec _break (let loop ()
  (if (< x 11) (let ()
    (define r (row x))
    (define line "")
    (define i 0)
    (let/ec _break (let loop ()
  (if (< i (cond [(string? r) (string-length r)] [(hash? r) (hash-count r)] [else (length r)])) (let ()
    (set! line (string-append (string-append (string-append line " ") (list-ref r i)) " "))
    (set! i (+ i 1))
    (loop)) (void))))
    (displayln line)
    (set! x (+ x 1))
    (loop)) (void))))
(displayln "")
(displayln "sums:")
(for ([num (list 23 123 1234)])
(define r (cumu num))
(displayln (string-append (string-append (format "~a" num) " ") (bigToString (list-ref r (- (cond [(string? r) (string-length r)] [(hash? r) (hash-count r)] [else (length r)]) 1)))))
)
