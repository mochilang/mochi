;; Generated by Mochi 0.10.39 on 2025-07-24 18:38 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (current-inexact-milliseconds)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (if (< (string-length s) width)
      (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
      s))

(define (toUnsigned16 n)
  (let/ec _return (begin
(define u n)
(if (< u 0) (let ()
(set! u (let ([__l u] [__r 65536]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(_return (modulo u 65536))
))
)
(define (bin16 n)
  (let/ec _return (begin
(define u (toUnsigned16 n))
(define bits "")
(define mask 32768)
(let/ec _break (let ([i 0])
  (let loop ()
    (when (< i 16)
(if (>= u mask) (let ()
(set! bits (string-append bits "1"))
(set! u (- u mask))
) (let ()
(set! bits (string-append bits "0"))
))
(set! mask (int (quotient mask 2)))
      (set! i (+ i 1))
      (loop)))
))
(_return bits)
))
)
(define (bit_and a b)
  (let/ec _return (begin
(define ua (toUnsigned16 a))
(define ub (toUnsigned16 b))
(define res 0)
(define bit 1)
(let/ec _break (let ([i 0])
  (let loop ()
    (when (< i 16)
(if (and (equal? (modulo ua 2) 1) (equal? (modulo ub 2) 1)) (let ()
(set! res (let ([__l res] [__r bit]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(set! ua (int (quotient ua 2)))
(set! ub (int (quotient ub 2)))
(set! bit (* bit 2))
      (set! i (+ i 1))
      (loop)))
))
(_return res)
))
)
(define (bit_or a b)
  (let/ec _return (begin
(define ua (toUnsigned16 a))
(define ub (toUnsigned16 b))
(define res 0)
(define bit 1)
(let/ec _break (let ([i 0])
  (let loop ()
    (when (< i 16)
(if (or (equal? (modulo ua 2) 1) (equal? (modulo ub 2) 1)) (let ()
(set! res (let ([__l res] [__r bit]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(set! ua (int (quotient ua 2)))
(set! ub (int (quotient ub 2)))
(set! bit (* bit 2))
      (set! i (+ i 1))
      (loop)))
))
(_return res)
))
)
(define (bit_xor a b)
  (let/ec _return (begin
(define ua (toUnsigned16 a))
(define ub (toUnsigned16 b))
(define res 0)
(define bit 1)
(let/ec _break (let ([i 0])
  (let loop ()
    (when (< i 16)
(define abit (modulo ua 2))
(define bbit (modulo ub 2))
(if (or (and (equal? abit 1) (equal? bbit 0)) (and (equal? abit 0) (equal? bbit 1))) (let ()
(set! res (let ([__l res] [__r bit]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(set! ua (int (quotient ua 2)))
(set! ub (int (quotient ub 2)))
(set! bit (* bit 2))
      (set! i (+ i 1))
      (loop)))
))
(_return res)
))
)
(define (bit_not a)
  (let/ec _return (begin
(define ua (toUnsigned16 a))
(_return (- 65535 ua))
))
)
(define (shl a b)
  (let/ec _return (begin
(define ua (toUnsigned16 a))
(define i 0)
(let/ec _break (let loop ()
  (if (< i b) (let ()
    (set! ua (modulo (* ua 2) 65536))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return ua)
))
)
(define (shr a b)
  (let/ec _return (begin
(define ua (toUnsigned16 a))
(define i 0)
(let/ec _break (let loop ()
  (if (< i b) (let ()
    (set! ua (int (quotient ua 2)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return ua)
))
)
(define (las a b)
  (let/ec _return (begin
(_return (shl a b))
))
)
(define (ras a b)
  (let/ec _return (begin
(define val a)
(define i 0)
(let/ec _break (let loop ()
  (if (< i b) (let ()
    (if (>= val 0) (let ()
(set! val (int (quotient val 2)))
) (let ()
(set! val (int (quotient (- val 1) 2)))
))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return (toUnsigned16 val))
))
)
(define (rol a b)
  (let/ec _return (begin
(define ua (toUnsigned16 a))
(define left (shl ua b))
(define right (shr ua (- 16 b)))
(_return (toUnsigned16 (let ([__l left] [__r right]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define (ror a b)
  (let/ec _return (begin
(define ua (toUnsigned16 a))
(define right (shr ua b))
(define left (shl ua (- 16 b)))
(_return (toUnsigned16 (let ([__l left] [__r right]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define (bitwise a b)
  (let/ec _return (begin
(displayln (string-append "a:   " (bin16 a)))
(displayln (string-append "b:   " (bin16 b)))
(displayln (string-append "and: " (bin16 (bit_and a b))))
(displayln (string-append "or:  " (bin16 (bit_or a b))))
(displayln (string-append "xor: " (bin16 (bit_xor a b))))
(displayln (string-append "not: " (bin16 (bit_not a))))
(if (< b 0) (let ()
(displayln "Right operand is negative, but all shifts require an unsigned right operand (shift distance).")
(_return #f)
) (void))
(displayln (string-append "shl: " (bin16 (shl a b))))
(displayln (string-append "shr: " (bin16 (shr a b))))
(displayln (string-append "las: " (bin16 (las a b))))
(displayln (string-append "ras: " (bin16 (ras a b))))
(displayln (string-append "rol: " (bin16 (rol a b))))
(displayln (string-append "ror: " (bin16 (ror a b))))
))
)
(bitwise (- 460) 6)
