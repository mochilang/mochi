;; Generated by Mochi 0.10.38 on 2025-07-23 16:59 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (current-inexact-milliseconds)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))


(define (sortRunes s)
  (let/ec _return (begin
(define arr (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (set! arr (append arr (list (substring s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define n (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)]))
(define m 0)
(let/ec _break (let loop ()
  (if (< m n) (let ()
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (- n 1)) (let ()
    (if (string>? (list-ref arr j) (list-ref arr (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) (let ()
(define tmp (list-ref arr j))
(set! arr (list-set arr j (list-ref arr (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
(set! arr (list-set arr (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) tmp))
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! m (let ([__l m] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(define out "")
(set! i 0)
(let/ec _break (let loop ()
  (if (< i n) (let ()
    (set! out (string-append out (list-ref arr i)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (sortStrings xs)
  (let/ec _return (begin
(define res (list))
(define tmp xs)
(let/ec _break (let loop ()
  (if (> (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)]) 0) (let ()
    (define min (list-ref tmp 0))
    (define idx 0)
    (define i 1)
    (let/ec _break (let loop ()
  (if (< i (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)])) (let ()
    (if (string<? (list-ref tmp i) min) (let ()
(set! min (list-ref tmp i))
(set! idx i)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! res (append res (list min)))
    (define out (list))
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? tmp) (string-length tmp)] [(hash? tmp) (hash-count tmp)] [else (length tmp)])) (let ()
    (if (not (equal? j idx)) (let ()
(set! out (append out (list (list-ref tmp j))))
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! tmp out)
    (loop)) (void))))
(_return res)
))
)
(define (main)
  (let/ec _return (begin
(define words (list "abel" "able" "bale" "bela" "elba" "alger" "glare" "lager" "large" "regal" "angel" "angle" "galen" "glean" "lange" "caret" "carte" "cater" "crate" "trace" "elan" "lane" "lean" "lena" "neal" "evil" "levi" "live" "veil" "vile"))
(define groups (hash))
(define maxLen 0)
(for ([w words])
(define k (sortRunes w))
(if (not (hash-has-key? groups k)) (let ()
(set! groups (hash-set groups k (list w)))
) (let ()
(set! groups (hash-set groups k (append (hash-ref groups k) (list w))))
))
(if (> (cond [(string? (hash-ref groups k)) (string-length (hash-ref groups k))] [(hash? (hash-ref groups k)) (hash-count (hash-ref groups k))] [else (length (hash-ref groups k))]) maxLen) (let ()
(set! maxLen (cond [(string? (hash-ref groups k)) (string-length (hash-ref groups k))] [(hash? (hash-ref groups k)) (hash-count (hash-ref groups k))] [else (length (hash-ref groups k))]))
) (void))
)
(define printed (hash))
(for ([w words])
(define k (sortRunes w))
(if (equal? (cond [(string? (hash-ref groups k)) (string-length (hash-ref groups k))] [(hash? (hash-ref groups k)) (hash-count (hash-ref groups k))] [else (length (hash-ref groups k))]) maxLen) (let ()
(if (not (hash-has-key? printed k)) (let ()
(define g (sortStrings (hash-ref groups k)))
(define line (string-append "[" (list-ref g 0)))
(define i 1)
(let/ec _break (let loop ()
  (if (< i (cond [(string? g) (string-length g)] [(hash? g) (hash-count g)] [else (length g)])) (let ()
    (set! line (string-append (string-append line " ") (list-ref g i)))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! line (string-append line "]"))
(displayln line)
(set! printed (hash-set printed k #t))
) (void))
) (void))
)
))
)
(main)
