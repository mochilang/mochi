;; Generated by Mochi 0.10.42 on 2025-07-28 10:03 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define PI 3.141592653589793)
(define (sinApprox x)
  (let/ec _return (begin
(define term x)
(define sum x)
(define n 1)
(let/ec _break (let loop ()
  (if (<= n 8) (let ()
    (define denom (exact->inexact (* (* 2 n) (let ([__l (* 2 n)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (set! term (/ (* (* (- term) x) x) denom))
    (set! sum (let ([__l sum] [__r term]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! n (let ([__l n] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return sum)
))
)
(define (cosApprox x)
  (let/ec _return (begin
(define term 1.0)
(define sum 1.0)
(define n 1)
(let/ec _break (let loop ()
  (if (<= n 8) (let ()
    (define denom (exact->inexact (* (- (* 2 n) 1) (* 2 n))))
    (set! term (/ (* (* (- term) x) x) denom))
    (set! sum (let ([__l sum] [__r term]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! n (let ([__l n] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return sum)
))
)
(define (atanApprox x)
  (let/ec _return (begin
(if (> x 1.0) (let ()
(_return (- (/ PI 2.0) (/ x (let ([__l (* x x)] [__r 0.28]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
(if (< x (- 1.0)) (let ()
(_return (- (/ (- PI) 2.0) (/ x (let ([__l (* x x)] [__r 0.28]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
(_return (/ x (let ([__l 1.0] [__r (* (* 0.28 x) x)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define (atan2Approx y x)
  (let/ec _return (begin
(if (> x 0.0) (let ()
(define r (atanApprox (/ y x)))
(_return r)
) (void))
(if (< x 0.0) (let ()
(if (>= y 0.0) (let ()
(_return (let ([__l (atanApprox (/ y x))] [__r PI]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(_return (- (atanApprox (/ y x)) PI))
) (void))
(if (> y 0.0) (let ()
(_return (/ PI 2.0))
) (void))
(if (< y 0.0) (let ()
(_return (/ (- PI) 2.0))
) (void))
(_return 0.0)
))
)
(define (sqrtApprox x)
  (let/ec _return (begin
(define guess x)
(define i 0)
(let/ec _break (let loop ()
  (if (< i 10) (let ()
    (set! guess (/ (let ([__l guess] [__r (/ x guess)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return guess)
))
)
(define (rad x)
  (let/ec _return (begin
(_return (/ (* x PI) 180.0))
))
)
(define (deg x)
  (let/ec _return (begin
(_return (/ (* x 180.0) PI))
))
)
(define (distance lat1 lon1 lat2 lon2)
  (let/ec _return (begin
(define phi1 (rad lat1))
(define phi2 (rad lat2))
(define dphi (rad (- lat2 lat1)))
(define dlambda (rad (- lon2 lon1)))
(define sdphi (sinApprox (/ dphi 2)))
(define sdlambda (sinApprox (/ dlambda 2)))
(define a (let ([__l (* sdphi sdphi)] [__r (* (* (* (cosApprox phi1) (cosApprox phi2)) sdlambda) sdlambda)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define c (* 2 (atan2Approx (sqrtApprox a) (sqrtApprox (- 1 a)))))
(_return (* (/ 6371.0 1.852) c))
))
)
(define (bearing lat1 lon1 lat2 lon2)
  (let/ec _return (begin
(define phi1 (rad lat1))
(define phi2 (rad lat2))
(define dl (rad (- lon2 lon1)))
(define y (* (sinApprox dl) (cosApprox phi2)))
(define x (- (* (cosApprox phi1) (sinApprox phi2)) (* (* (sinApprox phi1) (cosApprox phi2)) (cosApprox dl))))
(define br (deg (atan2Approx y x)))
(if (< br 0) (let ()
(set! br (let ([__l br] [__r 360]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(_return br)
))
)
(define airports (list (hash "name" "Koksijde Air Base" "country" "Belgium" "icao" "EBFN" "lat" 51.090301513671875 "lon" 2.652780055999756) (hash "name" "Ostend-Bruges International Airport" "country" "Belgium" "icao" "EBOS" "lat" 51.198898315399994 "lon" 2.8622200489) (hash "name" "Kent International Airport" "country" "United Kingdom" "icao" "EGMH" "lat" 51.342201 "lon" 1.34611) (hash "name" "Calais-Dunkerque Airport" "country" "France" "icao" "LFAC" "lat" 50.962100982666016 "lon" 1.954759955406189) (hash "name" "Westkapelle heliport" "country" "Belgium" "icao" "EBKW" "lat" 51.32222366333 "lon" 3.2930560112) (hash "name" "Lympne Airport" "country" "United Kingdom" "icao" "EGMK" "lat" 51.08 "lon" 1.013) (hash "name" "Ursel Air Base" "country" "Belgium" "icao" "EBUL" "lat" 51.14419937133789 "lon" 3.475559949874878) (hash "name" "Southend Airport" "country" "United Kingdom" "icao" "EGMC" "lat" 51.5713996887207 "lon" 0.6955559849739075) (hash "name" "Merville-Calonne Airport" "country" "France" "icao" "LFQT" "lat" 50.61840057373047 "lon" 2.642240047454834) (hash "name" "Wevelgem Airport" "country" "Belgium" "icao" "EBKT" "lat" 50.817199707 "lon" 3.20472002029) (hash "name" "Midden-Zeeland Airport" "country" "Netherlands" "icao" "EHMZ" "lat" 51.5121994019 "lon" 3.73111009598) (hash "name" "Lydd Airport" "country" "United Kingdom" "icao" "EGMD" "lat" 50.95610046386719 "lon" 0.9391670227050781) (hash "name" "RAF Wattisham" "country" "United Kingdom" "icao" "EGUW" "lat" 52.1273002625 "lon" 0.956264019012) (hash "name" "Beccles Airport" "country" "United Kingdom" "icao" "EGSM" "lat" 52.435298919699996 "lon" 1.6183300018300002) (hash "name" "Lille/Marcq-en-Baroeul Airport" "country" "France" "icao" "LFQO" "lat" 50.687198638916016 "lon" 3.0755600929260254) (hash "name" "Lashenden (Headcorn) Airfield" "country" "United Kingdom" "icao" "EGKH" "lat" 51.156898 "lon" 0.641667) (hash "name" "Le Touquet-CÃ´te d'Opale Airport" "country" "France" "icao" "LFAT" "lat" 50.517398834228516 "lon" 1.6205899715423584) (hash "name" "Rochester Airport" "country" "United Kingdom" "icao" "EGTO" "lat" 51.351898193359375 "lon" 0.5033329725265503) (hash "name" "Lille-Lesquin Airport" "country" "France" "icao" "LFQQ" "lat" 50.563332 "lon" 3.086886) (hash "name" "Thurrock Airfield" "country" "United Kingdom" "icao" "EGMT" "lat" 51.537505 "lon" 0.367634)))
(define (floor x)
  (let/ec _return (begin
(define i (int x))
(if (> (exact->inexact i) x) (let ()
(set! i (- i 1))
) (void))
(_return (exact->inexact i))
))
)
(define (pow10 n)
  (let/ec _return (begin
(define p 1.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (let ()
    (set! p (* p 10.0))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return p)
))
)
(define (round x n)
  (let/ec _return (begin
(define m (pow10 n))
(_return (/ (floor (let ([__l (* x m)] [__r 0.5]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) m))
))
)
(define (sortByDistance xs)
  (let/ec _return (begin
(define arr xs)
(define i 1)
(let/ec _break (let loop ()
  (if (< i (cond [(string? arr) (string-length arr)] [(hash? arr) (hash-count arr)] [else (length arr)])) (let ()
    (define j i)
    (let/ec _break (let loop ()
  (if (and (> j 0) (> (if (if arr (list-ref arr (int (- j 1))) #f) (list-ref (if arr (list-ref arr (int (- j 1))) #f) (int 0)) #f) (if (if arr (list-ref arr (int j)) #f) (list-ref (if arr (list-ref arr (int j)) #f) (int 0)) #f))) (let ()
    (define tmp (if arr (list-ref arr (int (- j 1))) #f))
    (set! arr (list-set arr (int (- j 1)) (if arr (list-ref arr (int j)) #f)))
    (set! arr (list-set arr (int j) tmp))
    (set! j (- j 1))
    (loop)) (void))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return arr)
))
)
(define (main)
  (let/ec _return (begin
(define planeLat 51.514669)
(define planeLon 2.198581)
(define results (list))
(let/ec _break (for ([ap airports])
  (let/ec _cont
(define d (distance planeLat planeLon (if ap (hash-ref ap "lat" #f) #f) (if ap (hash-ref ap "lon" #f) #f)))
(define b (bearing planeLat planeLon (if ap (hash-ref ap "lat" #f) #f) (if ap (hash-ref ap "lon" #f) #f)))
(set! results (append results (list (list d b ap))))
  )))
(set! results (sortByDistance results))
(displayln "Distance Bearing ICAO Country               Airport")
(displayln "--------------------------------------------------------------")
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? results) (string-length results)] [(hash? results) (hash-count results)] [else (length results)])) (let ()
    (define r (if results (list-ref results (int i)) #f))
    (define ap (if r (list-ref r (int 2)) #f))
    (define dist (if r (list-ref r (int 0)) #f))
    (define bear (if r (list-ref r (int 1)) #f))
    (define line (string-append (string-append (string-append (string-append (string-append (string-append (string-append (string-append (format "~a" (round dist 1)) "\t") (format "~a" (round bear 0))) "\t") (if ap (hash-ref ap "icao" #f) #f)) "\t") (if ap (hash-ref ap "country" #f) #f)) " ") (if ap (hash-ref ap "name" #f) #f)))
    (displayln line)
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
