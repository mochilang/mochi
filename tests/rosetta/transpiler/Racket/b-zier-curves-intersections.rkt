;; Generated by Mochi 0.10.41 on 2025-07-27 15:57 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (if (< (string-length s) width)
      (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
      s))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define (absf x)
  (let/ec _return (begin
(if (< x 0.0) (let ()
(_return (- x))
) (void))
(_return x)
))
)
(define (maxf a b)
  (let/ec _return (begin
(if (> a b) (let ()
(_return a)
) (void))
(_return b)
))
)
(define (minf a b)
  (let/ec _return (begin
(if (< a b) (let ()
(_return a)
) (void))
(_return b)
))
)
(define (max3 a b c)
  (let/ec _return (begin
(define m a)
(if (> b m) (let ()
(set! m b)
) (void))
(if (> c m) (let ()
(set! m c)
) (void))
(_return m)
))
)
(define (min3 a b c)
  (let/ec _return (begin
(define m a)
(if (< b m) (let ()
(set! m b)
) (void))
(if (< c m) (let ()
(set! m c)
) (void))
(_return m)
))
)
(define (subdivideQuadSpline q t)
  (let/ec _return (begin
(define s (- 1.0 t))
(define u (hash "c0" (if q (hash-ref q "c0" #f) #f) "c1" 0.0 "c2" 0.0))
(define v (hash "c0" 0.0 "c1" 0.0 "c2" (if q (hash-ref q "c2" #f) #f)))
(set! u (hash-set (or u (hash)) "c1" (let ([__l (* s (if q (hash-ref q "c0" #f) #f))] [__r (* t (if q (hash-ref q "c1" #f) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! v (hash-set (or v (hash)) "c1" (let ([__l (* s (if q (hash-ref q "c1" #f) #f))] [__r (* t (if q (hash-ref q "c2" #f) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! u (hash-set (or u (hash)) "c2" (let ([__l (* s (if u (hash-ref u "c1" #f) #f))] [__r (* t (if v (hash-ref v "c1" #f) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
(set! v (hash-set (or v (hash)) "c0" (if u (hash-ref u "c2" #f) #f)))
(_return (list u v))
))
)
(define (subdivideQuadCurve q t)
  (let/ec _return (begin
(define xs (subdivideQuadSpline (if q (hash-ref q "x" #f) #f) t))
(define ys (subdivideQuadSpline (if q (hash-ref q "y" #f) #f) t))
(define u (hash "x" (list-ref xs 0) "y" (list-ref ys 0)))
(define v (hash "x" (list-ref xs 1) "y" (list-ref ys 1)))
(_return (list u v))
))
)
(define (rectsOverlap xa0 ya0 xa1 ya1 xb0 yb0 xb1 yb1)
  (let/ec _return (begin
(_return (and (and (and (<= xb0 xa1) (<= xa0 xb1)) (<= yb0 ya1)) (<= ya0 yb1)))
))
)
(define (testIntersect p q tol)
  (let/ec _return (begin
(define pxmin (min3 (if (if p (hash-ref p "x" #f) #f) (hash-ref (if p (hash-ref p "x" #f) #f) "c0" #f) #f) (if (if p (hash-ref p "x" #f) #f) (hash-ref (if p (hash-ref p "x" #f) #f) "c1" #f) #f) (if (if p (hash-ref p "x" #f) #f) (hash-ref (if p (hash-ref p "x" #f) #f) "c2" #f) #f)))
(define pymin (min3 (if (if p (hash-ref p "y" #f) #f) (hash-ref (if p (hash-ref p "y" #f) #f) "c0" #f) #f) (if (if p (hash-ref p "y" #f) #f) (hash-ref (if p (hash-ref p "y" #f) #f) "c1" #f) #f) (if (if p (hash-ref p "y" #f) #f) (hash-ref (if p (hash-ref p "y" #f) #f) "c2" #f) #f)))
(define pxmax (max3 (if (if p (hash-ref p "x" #f) #f) (hash-ref (if p (hash-ref p "x" #f) #f) "c0" #f) #f) (if (if p (hash-ref p "x" #f) #f) (hash-ref (if p (hash-ref p "x" #f) #f) "c1" #f) #f) (if (if p (hash-ref p "x" #f) #f) (hash-ref (if p (hash-ref p "x" #f) #f) "c2" #f) #f)))
(define pymax (max3 (if (if p (hash-ref p "y" #f) #f) (hash-ref (if p (hash-ref p "y" #f) #f) "c0" #f) #f) (if (if p (hash-ref p "y" #f) #f) (hash-ref (if p (hash-ref p "y" #f) #f) "c1" #f) #f) (if (if p (hash-ref p "y" #f) #f) (hash-ref (if p (hash-ref p "y" #f) #f) "c2" #f) #f)))
(define qxmin (min3 (if (if q (hash-ref q "x" #f) #f) (hash-ref (if q (hash-ref q "x" #f) #f) "c0" #f) #f) (if (if q (hash-ref q "x" #f) #f) (hash-ref (if q (hash-ref q "x" #f) #f) "c1" #f) #f) (if (if q (hash-ref q "x" #f) #f) (hash-ref (if q (hash-ref q "x" #f) #f) "c2" #f) #f)))
(define qymin (min3 (if (if q (hash-ref q "y" #f) #f) (hash-ref (if q (hash-ref q "y" #f) #f) "c0" #f) #f) (if (if q (hash-ref q "y" #f) #f) (hash-ref (if q (hash-ref q "y" #f) #f) "c1" #f) #f) (if (if q (hash-ref q "y" #f) #f) (hash-ref (if q (hash-ref q "y" #f) #f) "c2" #f) #f)))
(define qxmax (max3 (if (if q (hash-ref q "x" #f) #f) (hash-ref (if q (hash-ref q "x" #f) #f) "c0" #f) #f) (if (if q (hash-ref q "x" #f) #f) (hash-ref (if q (hash-ref q "x" #f) #f) "c1" #f) #f) (if (if q (hash-ref q "x" #f) #f) (hash-ref (if q (hash-ref q "x" #f) #f) "c2" #f) #f)))
(define qymax (max3 (if (if q (hash-ref q "y" #f) #f) (hash-ref (if q (hash-ref q "y" #f) #f) "c0" #f) #f) (if (if q (hash-ref q "y" #f) #f) (hash-ref (if q (hash-ref q "y" #f) #f) "c1" #f) #f) (if (if q (hash-ref q "y" #f) #f) (hash-ref (if q (hash-ref q "y" #f) #f) "c2" #f) #f)))
(define exclude #t)
(define accept #f)
(define inter (hash "x" 0.0 "y" 0.0))
(if (rectsOverlap pxmin pymin pxmax pymax qxmin qymin qxmax qymax) (let ()
(set! exclude #f)
(define xmin (maxf pxmin qxmin))
(define xmax (minf pxmax qxmax))
(if (<= (- xmax xmin) tol) (let ()
(define ymin (maxf pymin qymin))
(define ymax (minf pymax qymax))
(if (<= (- ymax ymin) tol) (let ()
(set! accept #t)
(set! inter (hash-set (or inter (hash)) "x" (* 0.5 (let ([__l xmin] [__r xmax]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
(set! inter (hash-set (or inter (hash)) "y" (* 0.5 (let ([__l ymin] [__r ymax]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
) (void))
) (void))
) (void))
(_return (hash "exclude" exclude "accept" accept "intersect" inter))
))
)
(define (seemsToBeDuplicate pts xy spacing)
  (let/ec _return (begin
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? pts) (string-length pts)] [(hash? pts) (hash-count pts)] [else (length pts)])) (let ()
    (define pt (list-ref pts i))
    (if (and (< (absf (- (if pt (hash-ref pt "x" #f) #f) (if xy (hash-ref xy "x" #f) #f))) spacing) (< (absf (- (if pt (hash-ref pt "y" #f) #f) (if xy (hash-ref xy "y" #f) #f))) spacing)) (let ()
(_return #t)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #f)
))
)
(define (findIntersects p q tol spacing)
  (let/ec _return (begin
(define inters (list))
(define workload (list (hash "p" p "q" q)))
(let/ec _break (let loop ()
  (if (> (cond [(string? workload) (string-length workload)] [(hash? workload) (hash-count workload)] [else (length workload)]) 0) (let ()
    (define idx (- (cond [(string? workload) (string-length workload)] [(hash? workload) (hash-count workload)] [else (length workload)]) 1))
    (define work (list-ref workload idx))
    (set! workload (sublist workload 0 idx))
    (define res (testIntersect (if work (hash-ref work "p" #f) #f) (if work (hash-ref work "q" #f) #f) tol))
    (define excl (if res (hash-ref res "exclude" #f) #f))
    (define acc (if res (hash-ref res "accept" #f) #f))
    (define inter (if res (hash-ref res "intersect" #f) #f))
    (if acc (let ()
(if (not (seemsToBeDuplicate inters inter spacing)) (let ()
(set! inters (append inters (list inter)))
) (void))
) (let ()
(if (not excl) (let ()
(define ps (subdivideQuadCurve (if work (hash-ref work "p" #f) #f) 0.5))
(define qs (subdivideQuadCurve (if work (hash-ref work "q" #f) #f) 0.5))
(define p0 (list-ref ps 0))
(define p1 (list-ref ps 1))
(define q0 (list-ref qs 0))
(define q1 (list-ref qs 1))
(set! workload (append workload (list (hash "p" p0 "q" q0))))
(set! workload (append workload (list (hash "p" p0 "q" q1))))
(set! workload (append workload (list (hash "p" p1 "q" q0))))
(set! workload (append workload (list (hash "p" p1 "q" q1))))
) (void))
))
    (loop)) (void))))
(_return inters)
))
)
(define (main)
  (let/ec _return (begin
(define p (hash "x" (hash "c0" (- 1.0) "c1" 0.0 "c2" 1.0) "y" (hash "c0" 0.0 "c1" 10.0 "c2" 0.0)))
(define q (hash "x" (hash "c0" 2.0 "c1" (- 8.0) "c2" 2.0) "y" (hash "c0" 1.0 "c1" 2.0 "c2" 3.0)))
(define tol 1e-07)
(define spacing (* tol 10.0))
(define inters (findIntersects p q tol spacing))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? inters) (string-length inters)] [(hash? inters) (hash-count inters)] [else (length inters)])) (let ()
    (define pt (list-ref inters i))
    (displayln (string-append (string-append (string-append (string-append "(" (format "~a" (if pt (hash-ref pt "x" #f) #f))) ", ") (format "~a" (if pt (hash-ref pt "y" #f) #f))) ")"))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
