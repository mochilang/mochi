;; Generated by Mochi 0.10.50 on 2025-07-30 23:37 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (let loop ([i 0])
    (cond [(>= i (string-length s)) -1]
          [(string=? (substring s i (add1 i)) ch) i]
          [else (loop (add1 i))])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define gregorianStr (list "January" "February" "March" "April" "May" "June" "July" "August" "September" "October" "November" "December"))
(define gregorian (list 31 28 31 30 31 30 31 31 30 31 30 31))
(define republicanStr (list "Vendemiaire" "Brumaire" "Frimaire" "Nivose" "Pluviose" "Ventose" "Germinal" "Floreal" "Prairial" "Messidor" "Thermidor" "Fructidor"))
(define sansculotidesStr (list "Fete de la vertu" "Fete du genie" "Fete du travail" "Fete de l'opinion" "Fete des recompenses" "Fete de la Revolution"))
(define (greLeap year)
  (let/ec _return (begin
(define a (int (modulo year 4)))
(define b (int (modulo year 100)))
(define c (int (modulo year 400)))
(_return (and (equal? a 0) (or (not (equal? b 0)) (equal? c 0))))
))
)
(define (repLeap year)
  (let/ec _return (begin
(define a (int (modulo (let ([__l year] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 4)))
(define b (int (modulo (let ([__l year] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 100)))
(define c (int (modulo (let ([__l year] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 400)))
(_return (and (equal? a 0) (or (not (equal? b 0)) (equal? c 0))))
))
)
(define (greToDay d m y)
  (let/ec _return (begin
(define yy y)
(define mm m)
(if (< mm 3) (let ()
(set! yy (- yy 1))
(set! mm (let ([__l mm] [__r 12]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(_return (- (let ([__l (let ([__l (let ([__l (- (quotient (* yy 36525) 100) (quotient yy 100))] [__r (quotient yy 400)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (quotient (* 306 (let ([__l mm] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) 10)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r d]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 654842))
))
)
(define (repToDay d m y)
  (let/ec _return (begin
(define dd d)
(define mm m)
(if (equal? mm 13) (let ()
(set! mm (- mm 1))
(set! dd (let ([__l dd] [__r 30]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
) (void))
(if (repLeap y) (let ()
(set! dd (- dd 1))
) (void))
(_return (- (let ([__l (let ([__l (let ([__l (- (let ([__l (* 365 y)] [__r (quotient (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 4)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (quotient (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 100))] [__r (quotient (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 400)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (* 30 mm)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r dd]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 395))
))
)
(define (dayToGre day)
  (let/ec _return (begin
(define y (quotient (* day 100) 36525))
(define d (let ([__l (- day (quotient (* y 36525) 100))] [__r 21]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! y (let ([__l y] [__r 1792]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! d (- (- (let ([__l d] [__r (quotient y 100)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (quotient y 400)) 13))
(define m 8)
(let/ec _break (let loop ()
  (if (> d (if gregorian (list-ref gregorian (int m)) #f)) (let ()
    (set! d (- d (if gregorian (list-ref gregorian (int m)) #f)))
    (set! m (let ([__l m] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (equal? m 12) (let ()
(set! m 0)
(set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(if (greLeap y) (let ()
(set! gregorian (list-set gregorian (int 1) 29))
) (let ()
(set! gregorian (list-set gregorian (int 1) 28))
))
) (void))
    (loop)) (void))))
(set! m (let ([__l m] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(_return (list d m y))
))
)
(define (dayToRep day)
  (let/ec _return (begin
(define y (quotient (* (- day 1) 100) 36525))
(if (repLeap y) (let ()
(set! y (- y 1))
) (void))
(define d (- (let ([__l (let ([__l (- day (quotient (* (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 36525) 100))] [__r 365]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))] [__r (quotient (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 100)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) (quotient (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 400)))
(set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define m 1)
(define sc 5)
(if (repLeap y) (let ()
(set! sc 6)
) (void))
(let/ec _break (let loop ()
  (if (> d 30) (let ()
    (set! d (- d 30))
    (set! m (let ([__l m] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (if (equal? m 13) (let ()
(if (> d sc) (let ()
(set! d (- d sc))
(set! m 1)
(set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! sc 5)
(if (repLeap y) (let ()
(set! sc 6)
) (void))
) (void))
) (void))
    (loop)) (void))))
(_return (list d m y))
))
)
(define (formatRep d m y)
  (let/ec _return (begin
(if (equal? m 13) (let ()
(_return (string-append (string-append (if sansculotidesStr (list-ref sansculotidesStr (int (- d 1))) #f) " ") (format "~a" y)))
) (void))
(_return (string-append (string-append (string-append (string-append (format "~a" d) " ") (if republicanStr (list-ref republicanStr (int (- m 1))) #f)) " ") (format "~a" y)))
))
)
(define (formatGre d m y)
  (let/ec _return (begin
(_return (string-append (string-append (string-append (string-append (format "~a" d) " ") (if gregorianStr (list-ref gregorianStr (int (- m 1))) #f)) " ") (format "~a" y)))
))
)
(define rep (dayToRep (greToDay 20 5 1795)))
(displayln (formatRep (if rep (list-ref rep (int 0)) #f) (if rep (list-ref rep (int 1)) #f) (if rep (list-ref rep (int 2)) #f)))
(define gre (dayToGre (repToDay 1 9 3)))
(displayln (formatGre (if gre (list-ref gre (int 0)) #f) (if gre (list-ref gre (int 1)) #f) (if gre (list-ref gre (int 2)) #f)))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
