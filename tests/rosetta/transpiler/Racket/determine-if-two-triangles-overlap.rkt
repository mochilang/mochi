;; Generated by Mochi 0.10.55 on 2025-08-03 11:14 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match racket/system racket/port net/url net/http-client json openssl/sha1 openssl/md5)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (let loop ([i 0])
    (cond [(>= i (string-length s)) -1]
          [(string=? (substring s i (add1 i)) ch) i]
          [else (loop (add1 i))])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (_fetch url) (let ([p (get-pure-port (string->url url))]) (define txt (port->string p)) (close-input-port p) (string->jsexpr txt)))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))
(define stdout (hash "write" (lambda (s) (display s))))

(define (fmt1 f)
  (let/ec _return (begin
(define s (format "~a" f))
(define idx (index-of s "."))
(if (< idx 0) (let ()
(set! s (string-append s ".0"))
) (let ()
(define need (let ([__l idx] [__r 2]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(if (> (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) need) (let ()
(set! s (slice s 0 need))
) (let ()
(let/ec _break (let loop ()
  (if (< (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)]) need) (let/ec _cont
    (set! s (string-append s "0"))
    (loop)) (void))))
))
))
(_return s)
))
)
(define (pointStr p)
  (let/ec _return (begin
(_return (string-append (string-append (string-append (string-append "(" (fmt1 (if p (hash-ref p "x" #f) #f))) ", ") (fmt1 (if p (hash-ref p "y" #f) #f))) ")"))
))
)
(define (triangleStr t)
  (let/ec _return (begin
(_return (string-append (string-append (string-append (string-append (string-append "Triangle " (pointStr (if t (hash-ref t "p1" #f) #f))) ", ") (pointStr (if t (hash-ref t "p2" #f) #f))) ", ") (pointStr (if t (hash-ref t "p3" #f) #f))))
))
)
(define (orient a b c)
  (let/ec _return (begin
(_return (- (* (- (if b (hash-ref b "x" #f) #f) (if a (hash-ref a "x" #f) #f)) (- (if c (hash-ref c "y" #f) #f) (if a (hash-ref a "y" #f) #f))) (* (- (if b (hash-ref b "y" #f) #f) (if a (hash-ref a "y" #f) #f)) (- (if c (hash-ref c "x" #f) #f) (if a (hash-ref a "x" #f) #f)))))
))
)
(define (pointInTri p t onBoundary)
  (let/ec _return (begin
(define d1 (orient p (if t (hash-ref t "p1" #f) #f) (if t (hash-ref t "p2" #f) #f)))
(define d2 (orient p (if t (hash-ref t "p2" #f) #f) (if t (hash-ref t "p3" #f) #f)))
(define d3 (orient p (if t (hash-ref t "p3" #f) #f) (if t (hash-ref t "p1" #f) #f)))
(define hasNeg (or (or (< d1 0.0) (< d2 0.0)) (< d3 0.0)))
(define hasPos (or (or (> d1 0.0) (> d2 0.0)) (> d3 0.0)))
(if onBoundary (let ()
(_return (not (and hasNeg hasPos)))
) (void))
(_return (and (and (and (not (and hasNeg hasPos)) (not (equal? d1 0.0))) (not (equal? d2 0.0))) (not (equal? d3 0.0))))
))
)
(define (edgeCheck a0 a1 bs onBoundary)
  (let/ec _return (begin
(define d0 (orient a0 a1 (if bs (if (hash? bs) (hash-ref bs 0 #f) (list-ref bs (int 0))) #f)))
(define d1 (orient a0 a1 (if bs (if (hash? bs) (hash-ref bs 1 #f) (list-ref bs (int 1))) #f)))
(define d2 (orient a0 a1 (if bs (if (hash? bs) (hash-ref bs 2 #f) (list-ref bs (int 2))) #f)))
(if onBoundary (let ()
(_return (and (and (<= d0 0.0) (<= d1 0.0)) (<= d2 0.0)))
) (void))
(_return (and (and (< d0 0.0) (< d1 0.0)) (< d2 0.0)))
))
)
(define (triTri2D t1 t2 onBoundary)
  (let/ec _return (begin
(define a (list (if t1 (hash-ref t1 "p1" #f) #f) (if t1 (hash-ref t1 "p2" #f) #f) (if t1 (hash-ref t1 "p3" #f) #f)))
(define b (list (if t2 (hash-ref t2 "p1" #f) #f) (if t2 (hash-ref t2 "p2" #f) #f) (if t2 (hash-ref t2 "p3" #f) #f)))
(define i 0)
(let/ec _break (let loop ()
  (if (< i 3) (let/ec _cont
    (define j (modulo (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 3))
    (if (edgeCheck (if a (if (hash? a) (hash-ref a i #f) (list-ref a (int i))) #f) (if a (if (hash? a) (hash-ref a j #f) (list-ref a (int j))) #f) b onBoundary) (let ()
(_return #f)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(set! i 0)
(let/ec _break (let loop ()
  (if (< i 3) (let/ec _cont
    (define j (modulo (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 3))
    (if (edgeCheck (if b (if (hash? b) (hash-ref b i #f) (list-ref b (int i))) #f) (if b (if (hash? b) (hash-ref b j #f) (list-ref b (int j))) #f) a onBoundary) (let ()
(_return #f)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return #t)
))
)
(define (iff cond a b)
  (let/ec _return (begin
(if cond (let ()
(_return a)
) (let ()
(_return b)
))
))
)
(define (main)
  (let/ec _return (begin
(define t1 (hash "p1" (hash "x" 0.0 "y" 0.0) "p2" (hash "x" 5.0 "y" 0.0) "p3" (hash "x" 0.0 "y" 5.0)))
(define t2 (hash "p1" (hash "x" 0.0 "y" 0.0) "p2" (hash "x" 5.0 "y" 0.0) "p3" (hash "x" 0.0 "y" 6.0)))
(displayln (string-append (triangleStr t1) " and"))
(displayln (triangleStr t2))
(define overlapping (triTri2D t1 t2 #t))
(displayln (iff overlapping "overlap" "do not overlap"))
(displayln "")
(set! t1 (hash "p1" (hash "x" 0.0 "y" 0.0) "p2" (hash "x" 0.0 "y" 5.0) "p3" (hash "x" 5.0 "y" 0.0)))
(set! t2 t1)
(displayln (string-append (triangleStr t1) " and"))
(displayln (triangleStr t2))
(set! overlapping (triTri2D t1 t2 #t))
(displayln (iff overlapping "overlap (reversed)" "do not overlap"))
(displayln "")
(set! t1 (hash "p1" (hash "x" 0.0 "y" 0.0) "p2" (hash "x" 5.0 "y" 0.0) "p3" (hash "x" 0.0 "y" 5.0)))
(set! t2 (hash "p1" (hash "x" (- 10.0) "y" 0.0) "p2" (hash "x" (- 5.0) "y" 0.0) "p3" (hash "x" (- 1.0) "y" 6.0)))
(displayln (string-append (triangleStr t1) " and"))
(displayln (triangleStr t2))
(set! overlapping (triTri2D t1 t2 #t))
(displayln (iff overlapping "overlap" "do not overlap"))
(displayln "")
(set! t1 (hash-set (or t1 (hash)) "p3" (hash "x" 2.5 "y" 5.0)))
(set! t2 (hash "p1" (hash "x" 0.0 "y" 4.0) "p2" (hash "x" 2.5 "y" (- 1.0)) "p3" (hash "x" 5.0 "y" 4.0)))
(displayln (string-append (triangleStr t1) " and"))
(displayln (triangleStr t2))
(set! overlapping (triTri2D t1 t2 #t))
(displayln (iff overlapping "overlap" "do not overlap"))
(displayln "")
(set! t1 (hash "p1" (hash "x" 0.0 "y" 0.0) "p2" (hash "x" 1.0 "y" 1.0) "p3" (hash "x" 0.0 "y" 2.0)))
(set! t2 (hash "p1" (hash "x" 2.0 "y" 1.0) "p2" (hash "x" 3.0 "y" 0.0) "p3" (hash "x" 3.0 "y" 2.0)))
(displayln (string-append (triangleStr t1) " and"))
(displayln (triangleStr t2))
(set! overlapping (triTri2D t1 t2 #t))
(displayln (iff overlapping "overlap" "do not overlap"))
(displayln "")
(set! t2 (hash "p1" (hash "x" 2.0 "y" 1.0) "p2" (hash "x" 3.0 "y" (- 2.0)) "p3" (hash "x" 3.0 "y" 4.0)))
(displayln (string-append (triangleStr t1) " and"))
(displayln (triangleStr t2))
(set! overlapping (triTri2D t1 t2 #t))
(displayln (iff overlapping "overlap" "do not overlap"))
(displayln "")
(set! t1 (hash "p1" (hash "x" 0.0 "y" 0.0) "p2" (hash "x" 1.0 "y" 0.0) "p3" (hash "x" 0.0 "y" 1.0)))
(set! t2 (hash "p1" (hash "x" 1.0 "y" 0.0) "p2" (hash "x" 2.0 "y" 0.0) "p3" (hash "x" 1.0 "y" 1.1)))
(displayln (string-append (triangleStr t1) " and"))
(displayln (triangleStr t2))
(displayln "which have only a single corner in contact, if boundary points collide")
(set! overlapping (triTri2D t1 t2 #t))
(displayln (iff overlapping "overlap" "do not overlap"))
(displayln "")
(displayln (string-append (triangleStr t1) " and"))
(displayln (triangleStr t2))
(displayln "which have only a single corner in contact, if boundary points do not collide")
(set! overlapping (triTri2D t1 t2 #f))
(displayln (iff overlapping "overlap" "do not overlap"))
))
)
(main)
