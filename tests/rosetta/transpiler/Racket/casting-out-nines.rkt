;; Generated by Mochi 0.10.39 on 2025-07-24 20:52 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (current-inexact-milliseconds)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (if (< (string-length s) width)
      (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
      s))

(define (parseIntBase s base)
  (let/ec _return (begin
(define digits "0123456789abcdefghijklmnopqrstuvwxyz")
(define n 0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (define j 0)
    (define v 0)
    (let/ec _break (let loop ()
  (if (< j (cond [(string? digits) (string-length digits)] [(hash? digits) (hash-count digits)] [else (length digits)])) (let ()
    (if (string=? (substring digits j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (substring s i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))) (let ()
(set! v j)
(_break)
) (void))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! n (let ([__l (* n base)] [__r v]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return n)
))
)
(define (intToBase n base)
  (let/ec _return (begin
(define digits "0123456789abcdefghijklmnopqrstuvwxyz")
(if (equal? n 0) (let ()
(_return "0")
) (void))
(define out "")
(define v n)
(let/ec _break (let loop ()
  (if (> v 0) (let ()
    (define d (modulo v base))
    (set! out (string-append (substring digits d (let ([__l d] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) out))
    (set! v (quotient v base))
    (loop)) (void))))
(_return out)
))
)
(define (subset base begin end)
  (let/ec _return (begin
(define b (parseIntBase begin base))
(define e (parseIntBase end base))
(define out (list))
(define k b)
(let/ec _break (let loop ()
  (if (<= k e) (let ()
    (define ks (intToBase k base))
    (define mod (- base 1))
    (define r1 (modulo (parseIntBase ks base) mod))
    (define r2 (modulo (* (parseIntBase ks base) (parseIntBase ks base)) mod))
    (if (equal? r1 r2) (let ()
(set! out (append out (list ks)))
) (void))
    (set! k (let ([__l k] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define testCases (list (hash "base" 10 "begin" "1" "end" "100" "kaprekar" (list "1" "9" "45" "55" "99")) (hash "base" 17 "begin" "10" "end" "gg" "kaprekar" (list "3d" "d4" "gg"))))
(define idx 0)
(let/ec _break (let loop ()
  (if (< idx (cond [(string? testCases) (string-length testCases)] [(hash? testCases) (hash-count testCases)] [else (length testCases)])) (let ()
    (define tc (list-ref testCases idx))
    (displayln (string-append (string-append (string-append (string-append (string-append (string-append "\nTest case base = " (format "~a" (if tc (hash-ref tc "base" #f) #f))) ", begin = ") (if tc (hash-ref tc "begin" #f) #f)) ", end = ") (if tc (hash-ref tc "end" #f) #f)) ":"))
    (define s (subset (if tc (hash-ref tc "base" #f) #f) (if tc (hash-ref tc "begin" #f) #f) (if tc (hash-ref tc "end" #f) #f)))
    (displayln (string-append "Subset:  " (format "~a" s)))
    (displayln (string-append "Kaprekar:" (format "~a" (if tc (hash-ref tc "kaprekar" #f) #f))))
    (define sx 0)
    (define valid #t)
    (define i 0)
    (let/ec _break (let loop ()
  (if (< i (cond [(string? (if tc (hash-ref tc "kaprekar" #f) #f)) (string-length (if tc (hash-ref tc "kaprekar" #f) #f))] [(hash? (if tc (hash-ref tc "kaprekar" #f) #f)) (hash-count (if tc (hash-ref tc "kaprekar" #f) #f))] [else (length (if tc (hash-ref tc "kaprekar" #f) #f))])) (let ()
    (define k (list-ref (if tc (hash-ref tc "kaprekar" #f) #f) i))
    (define found #f)
    (let/ec _break (let loop ()
  (if (< sx (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])) (let ()
    (if (equal? (list-ref s sx) k) (let ()
(set! found #t)
(set! sx (let ([__l sx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(_break)
) (void))
    (set! sx (let ([__l sx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if (not found) (let ()
(displayln (string-append (string-append "Fail:" k) " not in subset"))
(set! valid #f)
(_break)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (if valid (let ()
(displayln "Valid subset.")
) (void))
    (set! idx (let ([__l idx] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
