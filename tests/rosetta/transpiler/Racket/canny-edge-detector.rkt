;; Generated by Mochi 0.10.39 on 2025-07-24 20:52 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (current-inexact-milliseconds)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (if (< (string-length s) width)
      (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
      s))

(define PI 3.141592653589793)
(define (conv2d img k)
  (let/ec _return (begin
(define h (cond [(string? img) (string-length img)] [(hash? img) (hash-count img)] [else (length img)]))
(define w (cond [(string? (list-ref img 0)) (string-length (list-ref img 0))] [(hash? (list-ref img 0)) (hash-count (list-ref img 0))] [else (length (list-ref img 0))]))
(define n (cond [(string? k) (string-length k)] [(hash? k) (hash-count k)] [else (length k)]))
(define half (quotient n 2))
(define out (list))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let ()
    (define row (list))
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let ()
    (define sum 0.0)
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j n) (let ()
    (define i 0)
    (let/ec _break (let loop ()
  (if (< i n) (let ()
    (define yy (- (let ([__l y] [__r j]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) half))
    (if (< yy 0) (let ()
(set! yy 0)
) (void))
    (if (>= yy h) (let ()
(set! yy (- h 1))
) (void))
    (define xx (- (let ([__l x] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) half))
    (if (< xx 0) (let ()
(set! xx 0)
) (void))
    (if (>= xx w) (let ()
(set! xx (- w 1))
) (void))
    (set! sum (let ([__l sum] [__r (* (list-ref (list-ref img yy) xx) (list-ref (list-ref k j) i))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! row (append row (list sum)))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (append out (list row)))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (gradient img)
  (let/ec _return (begin
(define hx (list (list (- 1.0) 0.0 1.0) (list (- 2.0) 0.0 2.0) (list (- 1.0) 0.0 1.0)))
(define hy (list (list 1.0 2.0 1.0) (list 0.0 0.0 0.0) (list (- 1.0) (- 2.0) (- 1.0))))
(define gx (conv2d img hx))
(define gy (conv2d img hy))
(define h (cond [(string? img) (string-length img)] [(hash? img) (hash-count img)] [else (length img)]))
(define w (cond [(string? (list-ref img 0)) (string-length (list-ref img 0))] [(hash? (list-ref img 0)) (hash-count (list-ref img 0))] [else (length (list-ref img 0))]))
(define out (list))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let ()
    (define row (list))
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let ()
    (define g (let ([__l (* (list-ref (list-ref gx y) x) (list-ref (list-ref gx y) x))] [__r (* (list-ref (list-ref gy y) x) (list-ref (list-ref gy y) x))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! row (append row (list g)))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (append out (list row)))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (threshold g t)
  (let/ec _return (begin
(define h (cond [(string? g) (string-length g)] [(hash? g) (hash-count g)] [else (length g)]))
(define w (cond [(string? (list-ref g 0)) (string-length (list-ref g 0))] [(hash? (list-ref g 0)) (hash-count (list-ref g 0))] [else (length (list-ref g 0))]))
(define out (list))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let ()
    (define row (list))
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let ()
    (if (>= (list-ref (list-ref g y) x) t) (let ()
(set! row (append row (list 1)))
) (let ()
(set! row (append row (list 0)))
))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (append out (list row)))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (printMatrix m)
  (let/ec _return (begin
(define y 0)
(let/ec _break (let loop ()
  (if (< y (cond [(string? m) (string-length m)] [(hash? m) (hash-count m)] [else (length m)])) (let ()
    (define line "")
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x (cond [(string? (list-ref m 0)) (string-length (list-ref m 0))] [(hash? (list-ref m 0)) (hash-count (list-ref m 0))] [else (length (list-ref m 0))])) (let ()
    (set! line (string-append line (format "~a" (list-ref (list-ref m y) x))))
    (if (< x (- (cond [(string? (list-ref m 0)) (string-length (list-ref m 0))] [(hash? (list-ref m 0)) (hash-count (list-ref m 0))] [else (length (list-ref m 0))]) 1)) (let ()
(set! line (string-append line " "))
) (void))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (displayln line)
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (main)
  (let/ec _return (begin
(define img (list (list 0.0 0.0 0.0 0.0 0.0) (list 0.0 255.0 255.0 255.0 0.0) (list 0.0 255.0 255.0 255.0 0.0) (list 0.0 255.0 255.0 255.0 0.0) (list 0.0 0.0 0.0 0.0 0.0)))
(define g (gradient img))
(define edges (threshold g (* 1020.0 1020.0)))
(printMatrix edges)
))
)
(main)
