;; Generated by Mochi 0.10.42 on 2025-07-27 23:50 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define PI 3.141592653589793)
(define (conv2d img k)
  (let/ec _return (begin
(define h (cond [(string? img) (string-length img)] [(hash? img) (hash-count img)] [else (length img)]))
(define w (cond [(string? (if img (list-ref img (int 0)) #f)) (string-length (if img (list-ref img (int 0)) #f))] [(hash? (if img (list-ref img (int 0)) #f)) (hash-count (if img (list-ref img (int 0)) #f))] [else (length (if img (list-ref img (int 0)) #f))]))
(define n (cond [(string? k) (string-length k)] [(hash? k) (hash-count k)] [else (length k)]))
(define half (quotient n 2))
(define out (list))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let ()
    (define row (list))
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let ()
    (define sum 0.0)
    (define j 0)
    (let/ec _break (let loop ()
  (if (< j n) (let ()
    (define i 0)
    (let/ec _break (let loop ()
  (if (< i n) (let ()
    (define yy (- (let ([__l y] [__r j]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) half))
    (if (< yy 0) (let ()
(set! yy 0)
) (void))
    (if (>= yy h) (let ()
(set! yy (- h 1))
) (void))
    (define xx (- (let ([__l x] [__r i]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) half))
    (if (< xx 0) (let ()
(set! xx 0)
) (void))
    (if (>= xx w) (let ()
(set! xx (- w 1))
) (void))
    (set! sum (let ([__l sum] [__r (* (if (if img (list-ref img (int yy)) #f) (list-ref (if img (list-ref img (int yy)) #f) (int xx)) #f) (if (if k (list-ref k (int j)) #f) (list-ref (if k (list-ref k (int j)) #f) (int i)) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! j (let ([__l j] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! row (append row (list sum)))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (append out (list row)))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (gradient img)
  (let/ec _return (begin
(define hx (list (list (- 1.0) 0.0 1.0) (list (- 2.0) 0.0 2.0) (list (- 1.0) 0.0 1.0)))
(define hy (list (list 1.0 2.0 1.0) (list 0.0 0.0 0.0) (list (- 1.0) (- 2.0) (- 1.0))))
(define gx (conv2d img hx))
(define gy (conv2d img hy))
(define h (cond [(string? img) (string-length img)] [(hash? img) (hash-count img)] [else (length img)]))
(define w (cond [(string? (if img (list-ref img (int 0)) #f)) (string-length (if img (list-ref img (int 0)) #f))] [(hash? (if img (list-ref img (int 0)) #f)) (hash-count (if img (list-ref img (int 0)) #f))] [else (length (if img (list-ref img (int 0)) #f))]))
(define out (list))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let ()
    (define row (list))
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let ()
    (define g (let ([__l (* (if (if gx (list-ref gx (int y)) #f) (list-ref (if gx (list-ref gx (int y)) #f) (int x)) #f) (if (if gx (list-ref gx (int y)) #f) (list-ref (if gx (list-ref gx (int y)) #f) (int x)) #f))] [__r (* (if (if gy (list-ref gy (int y)) #f) (list-ref (if gy (list-ref gy (int y)) #f) (int x)) #f) (if (if gy (list-ref gy (int y)) #f) (list-ref (if gy (list-ref gy (int y)) #f) (int x)) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (set! row (append row (list g)))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (append out (list row)))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (threshold g t)
  (let/ec _return (begin
(define h (cond [(string? g) (string-length g)] [(hash? g) (hash-count g)] [else (length g)]))
(define w (cond [(string? (if g (list-ref g (int 0)) #f)) (string-length (if g (list-ref g (int 0)) #f))] [(hash? (if g (list-ref g (int 0)) #f)) (hash-count (if g (list-ref g (int 0)) #f))] [else (length (if g (list-ref g (int 0)) #f))]))
(define out (list))
(define y 0)
(let/ec _break (let loop ()
  (if (< y h) (let ()
    (define row (list))
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x w) (let ()
    (if (>= (if (if g (list-ref g (int y)) #f) (list-ref (if g (list-ref g (int y)) #f) (int x)) #f) t) (let ()
(set! row (append row (list 1)))
) (let ()
(set! row (append row (list 0)))
))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! out (append out (list row)))
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return out)
))
)
(define (printMatrix m)
  (let/ec _return (begin
(define y 0)
(let/ec _break (let loop ()
  (if (< y (cond [(string? m) (string-length m)] [(hash? m) (hash-count m)] [else (length m)])) (let ()
    (define line "")
    (define x 0)
    (let/ec _break (let loop ()
  (if (< x (cond [(string? (if m (list-ref m (int 0)) #f)) (string-length (if m (list-ref m (int 0)) #f))] [(hash? (if m (list-ref m (int 0)) #f)) (hash-count (if m (list-ref m (int 0)) #f))] [else (length (if m (list-ref m (int 0)) #f))])) (let ()
    (set! line (string-append line (format "~a" (if (if m (list-ref m (int y)) #f) (list-ref (if m (list-ref m (int y)) #f) (int x)) #f))))
    (if (< x (- (cond [(string? (if m (list-ref m (int 0)) #f)) (string-length (if m (list-ref m (int 0)) #f))] [(hash? (if m (list-ref m (int 0)) #f)) (hash-count (if m (list-ref m (int 0)) #f))] [else (length (if m (list-ref m (int 0)) #f))]) 1)) (let ()
(set! line (string-append line " "))
) (void))
    (set! x (let ([__l x] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (displayln line)
    (set! y (let ([__l y] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
))
)
(define (main)
  (let/ec _return (begin
(define img (list (list 0.0 0.0 0.0 0.0 0.0) (list 0.0 255.0 255.0 255.0 0.0) (list 0.0 255.0 255.0 255.0 0.0) (list 0.0 255.0 255.0 255.0 0.0) (list 0.0 0.0 0.0 0.0 0.0)))
(define g (gradient img))
(define edges (threshold g (* 1020.0 1020.0)))
(printMatrix edges)
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
