;; Generated by Mochi 0.10.37 on 2025-07-23 12:26 +0700
#lang racket/base
(require racket/list racket/string racket/math json)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (current-inexact-milliseconds)))))
(define (int x)
  (cond
    [(integer? x) x]
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))


(define (neighborsList)
  (let/ec _return (begin
(_return (list (list 1 3) (list 0 2 4) (list 1 5) (list 0 4 6) (list 1 3 5 7) (list 2 4 8) (list 3 7) (list 4 6 8) (list 5 7)))
))
)
(define (plus a b)
  (let/ec _return (begin
(define res (list))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? a) (string-length a)] [(hash? a) (hash-count a)] [else (length a)])) (let ()
    (set! res (append res (list (let ([__l (list-ref a i)] [__r (list-ref b i)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return res)
))
)
(define (isStable p)
  (let/ec _return (begin
(for ([v p])
(if (> v 3) (let ()
(_return #f)
) (void))
)
(_return #t)
))
)
(define (topple p)
  (let/ec _return (begin
(define neighbors (neighborsList))
(define i 0)
(let/ec _break (let loop ()
  (if (< i (cond [(string? p) (string-length p)] [(hash? p) (hash-count p)] [else (length p)])) (let ()
    (if (> (list-ref p i) 3) (let ()
(set! p (list-set p i (- (list-ref p i) 4)))
(define nbs (list-ref neighbors i))
(for ([j nbs])
(set! p (list-set p j (let ([__l (list-ref p j)] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
)
(_return 0)
) (void))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return 0)
))
)
(define (pileString p)
  (let/ec _return (begin
(define s "")
(define r 0)
(let/ec _break (let loop ()
  (if (< r 3) (let ()
    (define c 0)
    (let/ec _break (let loop ()
  (if (< c 3) (let ()
    (set! s (string-append (string-append s (format "~a" (list-ref p (let ([__l (* 3 r)] [__r c]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))) " "))
    (set! c (let ([__l c] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
    (set! s (string-append s "\n"))
    (set! r (let ([__l r] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return s)
))
)
(displayln "Avalanche of topplings:\n")
(define s4 (list 4 3 3 3 1 2 0 2 3))
(displayln (pileString s4))
(let/ec _break (let loop ()
  (if (not (isStable s4)) (let ()
    (topple s4)
    (displayln (pileString s4))
    (loop)) (void))))
(displayln "Commutative additions:\n")
(define s1 (list 1 2 0 2 1 1 0 1 3))
(define s2 (list 2 1 3 1 0 1 0 1 0))
(define s3_a (plus s1 s2))
(let/ec _break (let loop ()
  (if (not (isStable s3_a)) (let ()
    (topple s3_a)
    (loop)) (void))))
(define s3_b (plus s2 s1))
(let/ec _break (let loop ()
  (if (not (isStable s3_b)) (let ()
    (topple s3_b)
    (loop)) (void))))
(displayln (string-append (string-append (string-append (string-append (pileString s1) "\nplus\n\n") (pileString s2)) "\nequals\n\n") (pileString s3_a)))
(displayln (string-append (string-append (string-append (string-append (string-append "and\n\n" (pileString s2)) "\nplus\n\n") (pileString s1)) "\nalso equals\n\n") (pileString s3_b)))
(displayln "Addition of identity sandpile:\n")
(define s3 (list 3 3 3 3 3 3 3 3 3))
(define s3_id (list 2 1 2 1 0 1 2 1 2))
(define s4b (plus s3 s3_id))
(let/ec _break (let loop ()
  (if (not (isStable s4b)) (let ()
    (topple s4b)
    (loop)) (void))))
(displayln (string-append (string-append (string-append (string-append (pileString s3) "\nplus\n\n") (pileString s3_id)) "\nequals\n\n") (pileString s4b)))
(displayln "Addition of identities:\n")
(define s5 (plus s3_id s3_id))
(let/ec _break (let loop ()
  (if (not (isStable s5)) (let ()
    (topple s5)
    (loop)) (void))))
(displayln (string-append (string-append (string-append (string-append (pileString s3_id) "\nplus\n\n") (pileString s3_id)) "\nequals\n\n") (pileString s5)))
