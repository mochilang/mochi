;; Generated by Mochi 0.10.50 on 2025-07-30 23:37 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (slice seq start end)
  (define len (if (string? seq) (string-length seq) (length seq)))
  (define s (int start))
  (define e (int end))
  (when (< s 0) (set! s (+ len s)))
  (when (< e 0) (set! e (+ len e)))
  (set! s (max 0 (min len s)))
  (set! e (max 0 (min len e)))
  (when (< e s) (set! e s))
  (if (string? seq) (substring seq s e) (sublist seq s e)))
(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (let loop ([i 0])
    (cond [(>= i (string-length s)) -1]
          [(string=? (substring s i (add1 i)) ch) i]
          [else (loop (add1 i))])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define (pow10 n)
  (let/ec _return (begin
(define r 1.0)
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (let ()
    (set! r (* r 10.0))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return r)
))
)
(define (formatFloat f prec)
  (let/ec _return (begin
(define scale (pow10 prec))
(define scaled (let ([__l (* f scale)] [__r 0.5]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define n (int scaled))
(define digits (format "~a" n))
(let/ec _break (let loop ()
  (if (<= (cond [(string? digits) (string-length digits)] [(hash? digits) (hash-count digits)] [else (length digits)]) prec) (let ()
    (set! digits (string-append "0" digits))
    (loop)) (void))))
(define intPart (slice digits 0 (- (cond [(string? digits) (string-length digits)] [(hash? digits) (hash-count digits)] [else (length digits)]) prec)))
(define fracPart (slice digits (- (cond [(string? digits) (string-length digits)] [(hash? digits) (hash-count digits)] [else (length digits)]) prec) (cond [(string? digits) (string-length digits)] [(hash? digits) (hash-count digits)] [else (length digits)])))
(_return (string-append (string-append intPart ".") fracPart))
))
)
(define (padLeft s w)
  (let/ec _return (begin
(define res "")
(define n (- w (cond [(string? s) (string-length s)] [(hash? s) (hash-count s)] [else (length s)])))
(let/ec _break (let loop ()
  (if (> n 0) (let ()
    (set! res (string-append res " "))
    (set! n (- n 1))
    (loop)) (void))))
(_return (string-append res s))
))
)
(define (repeat ch n)
  (let/ec _return (begin
(define s "")
(define i 0)
(let/ec _break (let loop ()
  (if (< i n) (let ()
    (set! s (string-append s ch))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return s)
))
)
(define (toFloat i)
  (let/ec _return (begin
(_return (exact->inexact i))
))
)
(define (newNode name weight coverage)
  (let/ec _return (begin
(_return (hash "name" name "weight" weight "coverage" coverage "children" (list)))
))
)
(define (addChildren n nodes)
  (let/ec _return (begin
(define cs (if n (hash-ref n "children" #f) #f))
(let/ec _break (for ([node nodes])
  (let/ec _cont
(set! cs (append cs (list node)))
  )))
(set! n (hash-set (or n (hash)) "children" cs))
))
)
(define (setCoverage n value)
  (let/ec _return (begin
(set! n (hash-set (or n (hash)) "coverage" value))
))
)
(define (computeCoverage n)
  (let/ec _return (begin
(define cs (if n (hash-ref n "children" #f) #f))
(if (equal? (cond [(string? cs) (string-length cs)] [(hash? cs) (hash-count cs)] [else (length cs)]) 0) (let ()
(_return (exact->inexact (if n (hash-ref n "coverage" #f) #f)))
) (void))
(define v1 0.0)
(define v2 0)
(let/ec _break (for ([node cs])
  (let/ec _cont
(define m node)
(define c (computeCoverage m))
(set! v1 (let ([__l v1] [__r (* (toFloat (int (if m (hash-ref m "weight" #f) #f))) c)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(set! v2 (let ([__l v2] [__r (int (if m (hash-ref m "weight" #f) #f))]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
  )))
(_return (/ v1 (toFloat v2)))
))
)
(define (spaces n)
  (let/ec _return (begin
(_return (_repeat " " n))
))
)
(define (show n level)
  (let/ec _return (begin
(define indent (* level 4))
(define name (format "~a" (if n (hash-ref n "name" #f) #f)))
(define nl (let ([__l (cond [(string? name) (string-length name)] [(hash? name) (hash-count name)] [else (length name)])] [__r indent]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
(define line (string-append (spaces indent) name))
(set! line (string-append (string-append line (spaces (- 32 nl))) "|  "))
(set! line (string-append (string-append line (padLeft (format "~a" (int (if n (hash-ref n "weight" #f) #f))) 3)) "   | "))
(set! line (string-append (string-append line (formatFloat (computeCoverage n) 6)) " |"))
(displayln line)
(define cs (if n (hash-ref n "children" #f) #f))
(let/ec _break (for ([child cs])
  (let/ec _cont
(show child (let ([__l level] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
  )))
))
)
(define house1 (newNode "house1" 40 0.0))
(define house2 (newNode "house2" 60 0.0))
(define h1_bedrooms (newNode "bedrooms" 1 0.25))
(define h1_bathrooms (newNode "bathrooms" 1 0.0))
(define h1_attic (newNode "attic" 1 0.75))
(define h1_kitchen (newNode "kitchen" 1 0.1))
(define h1_living_rooms (newNode "living_rooms" 1 0.0))
(define h1_basement (newNode "basement" 1 0.0))
(define h1_garage (newNode "garage" 1 0.0))
(define h1_garden (newNode "garden" 1 0.8))
(define h2_upstairs (newNode "upstairs" 1 0.0))
(define h2_groundfloor (newNode "groundfloor" 1 0.0))
(define h2_basement (newNode "basement" 1 0.0))
(define h1_bathroom1 (newNode "bathroom1" 1 0.5))
(define h1_bathroom2 (newNode "bathroom2" 1 0.0))
(define h1_outside (newNode "outside_lavatory" 1 1.0))
(define h1_lounge (newNode "lounge" 1 0.0))
(define h1_dining (newNode "dining_room" 1 0.0))
(define h1_conservatory (newNode "conservatory" 1 0.0))
(define h1_playroom (newNode "playroom" 1 1.0))
(define h2_bedrooms (newNode "bedrooms" 1 0.0))
(define h2_bathroom (newNode "bathroom" 1 0.0))
(define h2_toilet (newNode "toilet" 1 0.0))
(define h2_attics (newNode "attics" 1 0.6))
(define h2_kitchen (newNode "kitchen" 1 0.0))
(define h2_living_rooms (newNode "living_rooms" 1 0.0))
(define h2_wet_room (newNode "wet_room_&_toilet" 1 0.0))
(define h2_garage (newNode "garage" 1 0.0))
(define h2_garden (newNode "garden" 1 0.9))
(define h2_hot_tub (newNode "hot_tub_suite" 1 1.0))
(define h2_cellars (newNode "cellars" 1 1.0))
(define h2_wine_cellar (newNode "wine_cellar" 1 1.0))
(define h2_cinema (newNode "cinema" 1 0.75))
(define h2_suite1 (newNode "suite_1" 1 0.0))
(define h2_suite2 (newNode "suite_2" 1 0.0))
(define h2_bedroom3 (newNode "bedroom_3" 1 0.0))
(define h2_bedroom4 (newNode "bedroom_4" 1 0.0))
(define h2_lounge (newNode "lounge" 1 0.0))
(define h2_dining (newNode "dining_room" 1 0.0))
(define h2_conservatory (newNode "conservatory" 1 0.0))
(define h2_playroom (newNode "playroom" 1 0.0))
(define (main)
  (let/ec _return (begin
(define cleaning (newNode "cleaning" 1 0.0))
(addChildren h1_bathrooms (list h1_bathroom1 h1_bathroom2 h1_outside))
(addChildren h1_living_rooms (list h1_lounge h1_dining h1_conservatory h1_playroom))
(addChildren house1 (list h1_bedrooms h1_bathrooms h1_attic h1_kitchen h1_living_rooms h1_basement h1_garage h1_garden))
(addChildren h2_bedrooms (list h2_suite1 h2_suite2 h2_bedroom3 h2_bedroom4))
(addChildren h2_upstairs (list h2_bedrooms h2_bathroom h2_toilet h2_attics))
(addChildren h2_living_rooms (list h2_lounge h2_dining h2_conservatory h2_playroom))
(addChildren h2_groundfloor (list h2_kitchen h2_living_rooms h2_wet_room h2_garage h2_garden h2_hot_tub))
(addChildren h2_basement (list h2_cellars h2_wine_cellar h2_cinema))
(addChildren house2 (list h2_upstairs h2_groundfloor h2_basement))
(addChildren cleaning (list house1 house2))
(define topCoverage (computeCoverage cleaning))
(displayln (string-append "TOP COVERAGE = " (formatFloat topCoverage 6)))
(displayln "")
(displayln "NAME HIERARCHY                 | WEIGHT | COVERAGE |")
(show cleaning 0)
(setCoverage h2_cinema 1.0)
(define diff (- (computeCoverage cleaning) topCoverage))
(displayln "")
(displayln "If the coverage of the Cinema node were increased from 0.75 to 1")
(displayln (string-append (string-append (string-append "the top level coverage would increase by " (formatFloat diff 6)) " to ") (formatFloat (let ([__l topCoverage] [__r diff]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 6)))
(setCoverage h2_cinema 0.75)
))
)
(main)
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
