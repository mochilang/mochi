;; Generated by Mochi 0.10.47 on 2025-07-28 11:49 +0700
#lang racket/base
(require racket/list racket/string racket/math racket/match json openssl/sha1)
(define nowSeed (let ([s (getenv "MOCHI_NOW_SEED")]) (and s (string->number s))))
(define (now)
  (if nowSeed
      (begin (set! nowSeed (modulo (+ (* nowSeed 1664525) 1013904223) 2147483647)) nowSeed)
      (inexact->exact (floor (* (current-inexact-milliseconds) 1000)))))
(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x) (let ([n (string->number x)]) (if n (inexact->exact (truncate n)) 0))]
    [else 0]))
(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x) (let ([n (string->number x)]) (if n (exact->inexact n) 0.0))]
    [else 0.0]))
(define (input) (read-line))
(define (upper s) (string-upcase s))
(define (lower s) (string-downcase s))
(define (sublist lst start end)
  (if (string? lst)
      (substring lst start end)
      (take (drop lst start) (- end start))))

(define (pad-start s width ch)
  (let ([s (format "~a" s)])
    (if (< (string-length s) width)
        (string-append (make-string (- width (string-length s)) (string-ref ch 0)) s)
        s)))
(define (index-of s ch)
  (let loop ([i 0])
    (cond [(>= i (string-length s)) -1]
          [(string=? (substring s i (add1 i)) ch) i]
          [else (loop (add1 i))])))
(define (_repeat s n)
  (cond
    [(string? s) (apply string-append (make-list (int n) s))]
    [(list? s) (apply append (make-list (int n) s))]
    [else '()]))
(define (_parse-int-str s base) (int (string->number s base)))
(define (_sha256 bs) (bytes->list (sha256-bytes (list->bytes bs))))
(define (num r) (numerator r))
(define (denom r) (denominator r))
(define (panic msg) (error msg))

(let* ([_start_mem (current-memory-use)] [_start (now)])
(define (sqrtApprox x)
  (let/ec _return (begin
(define g x)
(define i 0)
(let/ec _break (let loop ()
  (if (< i 40) (let ()
    (set! g (/ (let ([__l g] [__r (/ x g)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0))
    (set! i (let ([__l i] [__r 1]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))))
    (loop)) (void))))
(_return g)
))
)
(define (hypot x y)
  (let/ec _return (begin
(_return (sqrtApprox (let ([__l (* x x)] [__r (* y y)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))))
))
)
(define Two "Two circles.")
(define R0 "R==0.0 does not describe circles.")
(define Co "Coincident points describe an infinite number of circles.")
(define CoR0 "Coincident points with r==0.0 describe a degenerate circle.")
(define Diam "Points form a diameter and describe only a single circle.")
(define Far "Points too far apart to form circles.")
(define (circles p1 p2 r)
  (let/ec _return (begin
(if (and (equal? (if p1 (hash-ref p1 "x" #f) #f) (if p2 (hash-ref p2 "x" #f) #f)) (equal? (if p1 (hash-ref p1 "y" #f) #f) (if p2 (hash-ref p2 "y" #f) #f))) (let ()
(if (equal? r 0.0) (let ()
(_return (list p1 p1 "Coincident points with r==0.0 describe a degenerate circle."))
) (void))
(_return (list p1 p2 "Coincident points describe an infinite number of circles."))
) (void))
(if (equal? r 0.0) (let ()
(_return (list p1 p2 "R==0.0 does not describe circles."))
) (void))
(define dx (- (if p2 (hash-ref p2 "x" #f) #f) (if p1 (hash-ref p1 "x" #f) #f)))
(define dy (- (if p2 (hash-ref p2 "y" #f) #f) (if p1 (hash-ref p1 "y" #f) #f)))
(define q (hypot dx dy))
(if (> q (* 2.0 r)) (let ()
(_return (list p1 p2 "Points too far apart to form circles."))
) (void))
(define m (hash "x" (/ (let ([__l (if p1 (hash-ref p1 "x" #f) #f)] [__r (if p2 (hash-ref p2 "x" #f) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0) "y" (/ (let ([__l (if p1 (hash-ref p1 "y" #f) #f)] [__r (if p2 (hash-ref p2 "y" #f) #f)]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) 2.0)))
(if (equal? q (* 2.0 r)) (let ()
(_return (list m m "Points form a diameter and describe only a single circle."))
) (void))
(define d (sqrtApprox (- (* r r) (/ (* q q) 4.0))))
(define ox (/ (* d dx) q))
(define oy (/ (* d dy) q))
(_return (list (hash "x" (- (if m (hash-ref m "x" #f) #f) oy) "y" (let ([__l (if m (hash-ref m "y" #f) #f)] [__r ox]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r)))) (hash "x" (let ([__l (if m (hash-ref m "x" #f) #f)] [__r oy]) (if (and (string? __l) (string? __r)) (string-append __l __r) (+ __l __r))) "y" (- (if m (hash-ref m "y" #f) #f) ox)) "Two circles."))
))
)
(define td (list (list (hash "x" 0.1234 "y" 0.9876) (hash "x" 0.8765 "y" 0.2345) 2.0) (list (hash "x" 0.0 "y" 2.0) (hash "x" 0.0 "y" 0.0) 1.0) (list (hash "x" 0.1234 "y" 0.9876) (hash "x" 0.1234 "y" 0.9876) 2.0) (list (hash "x" 0.1234 "y" 0.9876) (hash "x" 0.8765 "y" 0.2345) 0.5) (list (hash "x" 0.1234 "y" 0.9876) (hash "x" 0.1234 "y" 0.9876) 0.0)))
(let/ec _break (for ([tc td])
  (let/ec _cont
(define p1 (if tc (list-ref tc (int 0)) #f))
(define p2 (if tc (list-ref tc (int 1)) #f))
(define r (if tc (list-ref tc (int 2)) #f))
(displayln (string-append (string-append (string-append (string-append "p1:  {" (format "~a" (if p1 (hash-ref p1 "x" #f) #f))) " ") (format "~a" (if p1 (hash-ref p1 "y" #f) #f))) "}"))
(displayln (string-append (string-append (string-append (string-append "p2:  {" (format "~a" (if p2 (hash-ref p2 "x" #f) #f))) " ") (format "~a" (if p2 (hash-ref p2 "y" #f) #f))) "}"))
(displayln (string-append "r:  " (format "~a" r)))
(define res (circles p1 p2 r))
(define c1 (if res (list-ref res (int 0)) #f))
(define c2 (if res (list-ref res (int 1)) #f))
(define caseStr (if res (list-ref res (int 2)) #f))
(displayln (string-append "   " caseStr))
(if (or (string=? caseStr "Points form a diameter and describe only a single circle.") (string=? caseStr "Coincident points with r==0.0 describe a degenerate circle.")) (let ()
(displayln (string-append (string-append (string-append (string-append "   Center:  {" (format "~a" (if c1 (hash-ref c1 "x" #f) #f))) " ") (format "~a" (if c1 (hash-ref c1 "y" #f) #f))) "}"))
) (let ()
(if (string=? caseStr "Two circles.") (let ()
(displayln (string-append (string-append (string-append (string-append "   Center 1:  {" (format "~a" (if c1 (hash-ref c1 "x" #f) #f))) " ") (format "~a" (if c1 (hash-ref c1 "y" #f) #f))) "}"))
(displayln (string-append (string-append (string-append (string-append "   Center 2:  {" (format "~a" (if c2 (hash-ref c2 "x" #f) #f))) " ") (format "~a" (if c2 (hash-ref c2 "y" #f) #f))) "}"))
) (void))
))
(displayln "")
  )))
  (let* ([_end (now)] [_end_mem (current-memory-use)]
         [_dur (- _end _start)]
         [_dur_us _dur]
         [_mem (max 0 (- _end_mem _start_mem))])
    (displayln "{")
    (displayln (format "  \"duration_us\": ~a," _dur_us))
    (displayln (format "  \"memory_bytes\": ~a," _mem))
    (displayln "  \"name\": \"main\"")
    (displayln "}")
  )
)
