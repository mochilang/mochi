(ns main (:refer-clojure :exclude [indexOf fmt4 fmt2 sumPoint mulPoint divPoint centerPoint getFacePoints sortEdges getEdgesFaces getEdgePoints getAvgFacePoints getAvgMidEdges getPointsFaces getNewPoints key cmcSubdiv formatPoint formatFace main]))

(require 'clojure.set)

(defn in [x coll]
  (cond (string? coll) (clojure.string/includes? coll x) (map? coll) (contains? coll x) (sequential? coll) (some (fn [e] (= e x)) coll) :else false))

(defn padStart [s w p]
  (loop [out (str s)] (if (< (count out) w) (recur (str p out)) out)))

(def nowSeed (atom (let [s (System/getenv "MOCHI_NOW_SEED")] (if (and s (not (= s ""))) (Integer/parseInt s) 0))))

(declare indexOf fmt4 fmt2 sumPoint mulPoint divPoint centerPoint getFacePoints sortEdges getEdgesFaces getEdgePoints getAvgFacePoints getAvgMidEdges getPointsFaces getNewPoints key cmcSubdiv formatPoint formatFace main)

(declare cmcSubdiv_a cmcSubdiv_ab cmcSubdiv_avgFacePoints cmcSubdiv_avgMidEdges cmcSubdiv_b cmcSubdiv_bc cmcSubdiv_c cmcSubdiv_cd cmcSubdiv_d cmcSubdiv_da cmcSubdiv_e cmcSubdiv_edgePointNums cmcSubdiv_edgePoints cmcSubdiv_edgesFaces cmcSubdiv_facePointNums cmcSubdiv_facePoints cmcSubdiv_fnum cmcSubdiv_fpnum cmcSubdiv_idx cmcSubdiv_newFaces cmcSubdiv_newPoints cmcSubdiv_nextPoint cmcSubdiv_oldFace cmcSubdiv_pointsFaces fmt2_s fmt4_decs fmt4_dot fmt4_s fmt4_y formatFace_i formatFace_s getAvgFacePoints_avg getAvgFacePoints_fnum getAvgFacePoints_fp getAvgFacePoints_i getAvgFacePoints_j getAvgFacePoints_numP getAvgFacePoints_temp getAvgFacePoints_tp getAvgMidEdges_arr getAvgMidEdges_avg getAvgMidEdges_cp getAvgMidEdges_i getAvgMidEdges_j getAvgMidEdges_numP getAvgMidEdges_temp getAvgMidEdges_tp getEdgePoints_cfp getEdgePoints_cp getEdgePoints_edge getEdgePoints_edgePoints getEdgePoints_fp1 getEdgePoints_fp2 getEdgePoints_i getEdgesFaces_cp getEdgesFaces_e1 getEdgesFaces_e2 getEdgesFaces_edges getEdgesFaces_edgesCenters getEdgesFaces_face getEdgesFaces_fnum getEdgesFaces_idx getEdgesFaces_merged getEdgesFaces_numP getEdgesFaces_p1 getEdgesFaces_p2 getEdgesFaces_pi getEdgesFaces_pn1 getEdgesFaces_pn2 getEdgesFaces_tmpn getFacePoints_face getFacePoints_facePoints getFacePoints_fp getFacePoints_i getNewPoints_i getNewPoints_m1 getNewPoints_m2 getNewPoints_m3 getNewPoints_n getNewPoints_newPts getNewPoints_old getNewPoints_p1 getNewPoints_p2 getNewPoints_p3 getPointsFaces_fnum getPointsFaces_i getPointsFaces_pf indexOf_i main_i main_inputFaces main_inputPoints main_outputFaces main_outputPoints main_res sortEdges_e sortEdges_idx sortEdges_j sortEdges_k sortEdges_min sortEdges_out sortEdges_res sortEdges_tmp)

(defn indexOf [indexOf_s indexOf_ch]
  (try (do (def indexOf_i 0) (while (< indexOf_i (count indexOf_s)) (do (when (= (subs indexOf_s indexOf_i (+ indexOf_i 1)) indexOf_ch) (throw (ex-info "return" {:v indexOf_i}))) (def indexOf_i (+ indexOf_i 1)))) (throw (ex-info "return" {:v (- 1)}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn fmt4 [fmt4_x]
  (try (do (def fmt4_y (* fmt4_x 10000.0)) (if (>= fmt4_y 0) (def fmt4_y (+ fmt4_y 0.5)) (def fmt4_y (- fmt4_y 0.5))) (def fmt4_y (/ (double (int fmt4_y)) 10000.0)) (def fmt4_s (str fmt4_y)) (def fmt4_dot (indexOf fmt4_s ".")) (if (= fmt4_dot (- 0 1)) (def fmt4_s (str fmt4_s ".0000")) (do (def fmt4_decs (- (- (count fmt4_s) fmt4_dot) 1)) (if (> fmt4_decs 4) (def fmt4_s (subs fmt4_s 0 (+ fmt4_dot 5))) (while (< fmt4_decs 4) (do (def fmt4_s (str fmt4_s "0")) (def fmt4_decs (+ fmt4_decs 1))))))) (when (>= fmt4_x 0.0) (def fmt4_s (str " " fmt4_s))) (throw (ex-info "return" {:v fmt4_s}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn fmt2 [fmt2_n]
  (try (do (def fmt2_s (str fmt2_n)) (if (< (count fmt2_s) 2) (str " " fmt2_s) fmt2_s)) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn sumPoint [sumPoint_p1 sumPoint_p2]
  (try (throw (ex-info "return" {:v {:x (+ (:x sumPoint_p1) (:x sumPoint_p2)) :y (+ (:y sumPoint_p1) (:y sumPoint_p2)) :z (+ (:z sumPoint_p1) (:z sumPoint_p2))}})) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn mulPoint [mulPoint_p mulPoint_m]
  (try (throw (ex-info "return" {:v {:x (* (:x mulPoint_p) mulPoint_m) :y (* (:y mulPoint_p) mulPoint_m) :z (* (:z mulPoint_p) mulPoint_m)}})) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn divPoint [divPoint_p divPoint_d]
  (try (throw (ex-info "return" {:v (mulPoint divPoint_p (/ 1.0 divPoint_d))})) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn centerPoint [centerPoint_p1 centerPoint_p2]
  (try (throw (ex-info "return" {:v (divPoint (sumPoint centerPoint_p1 centerPoint_p2) 2.0)})) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn getFacePoints [getFacePoints_points getFacePoints_faces]
  (try (do (def getFacePoints_facePoints []) (def getFacePoints_i 0) (while (< getFacePoints_i (count getFacePoints_faces)) (do (def getFacePoints_face (nth getFacePoints_faces getFacePoints_i)) (def getFacePoints_fp {:x 0.0 :y 0.0 :z 0.0}) (doseq [idx getFacePoints_face] (def getFacePoints_fp (sumPoint getFacePoints_fp (nth getFacePoints_points idx)))) (def getFacePoints_fp (divPoint getFacePoints_fp (double (count getFacePoints_face)))) (def getFacePoints_facePoints (conj getFacePoints_facePoints getFacePoints_fp)) (def getFacePoints_i (+ getFacePoints_i 1)))) (throw (ex-info "return" {:v getFacePoints_facePoints}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn sortEdges [sortEdges_edges]
  (try (do (def sortEdges_res []) (def sortEdges_tmp sortEdges_edges) (while (> (count sortEdges_tmp) 0) (do (def sortEdges_min (nth sortEdges_tmp 0)) (def sortEdges_idx 0) (def sortEdges_j 1) (while (< sortEdges_j (count sortEdges_tmp)) (do (def sortEdges_e (nth sortEdges_tmp sortEdges_j)) (when (or (< (nth sortEdges_e 0) (nth sortEdges_min 0)) (and (= (nth sortEdges_e 0) (nth sortEdges_min 0)) (or (< (nth sortEdges_e 1) (nth sortEdges_min 1)) (and (= (nth sortEdges_e 1) (nth sortEdges_min 1)) (< (nth sortEdges_e 2) (nth sortEdges_min 2)))))) (do (def sortEdges_min sortEdges_e) (def sortEdges_idx sortEdges_j))) (def sortEdges_j (+ sortEdges_j 1)))) (def sortEdges_res (conj sortEdges_res sortEdges_min)) (def sortEdges_out []) (def sortEdges_k 0) (while (< sortEdges_k (count sortEdges_tmp)) (do (when (not= sortEdges_k sortEdges_idx) (def sortEdges_out (conj sortEdges_out (nth sortEdges_tmp sortEdges_k)))) (def sortEdges_k (+ sortEdges_k 1)))) (def sortEdges_tmp sortEdges_out))) (throw (ex-info "return" {:v sortEdges_res}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn getEdgesFaces [getEdgesFaces_points getEdgesFaces_faces]
  (try (do (def getEdgesFaces_edges []) (def getEdgesFaces_fnum 0) (while (< getEdgesFaces_fnum (count getEdgesFaces_faces)) (do (def getEdgesFaces_face (nth getEdgesFaces_faces getEdgesFaces_fnum)) (def getEdgesFaces_numP (count getEdgesFaces_face)) (def getEdgesFaces_pi 0) (while (< getEdgesFaces_pi getEdgesFaces_numP) (do (def getEdgesFaces_pn1 (nth getEdgesFaces_face getEdgesFaces_pi)) (def getEdgesFaces_pn2 0) (if (< getEdgesFaces_pi (- getEdgesFaces_numP 1)) (def getEdgesFaces_pn2 (nth getEdgesFaces_face (+ getEdgesFaces_pi 1))) (def getEdgesFaces_pn2 (nth getEdgesFaces_face 0))) (when (> getEdgesFaces_pn1 getEdgesFaces_pn2) (do (def getEdgesFaces_tmpn getEdgesFaces_pn1) (def getEdgesFaces_pn1 getEdgesFaces_pn2) (def getEdgesFaces_pn2 getEdgesFaces_tmpn))) (def getEdgesFaces_edges (conj getEdgesFaces_edges [getEdgesFaces_pn1 getEdgesFaces_pn2 getEdgesFaces_fnum])) (def getEdgesFaces_pi (+ getEdgesFaces_pi 1)))) (def getEdgesFaces_fnum (+ getEdgesFaces_fnum 1)))) (def getEdgesFaces_edges (sortEdges getEdgesFaces_edges)) (def getEdgesFaces_merged []) (def getEdgesFaces_idx 0) (loop [while_flag_1 true] (when (and while_flag_1 (< getEdgesFaces_idx (count getEdgesFaces_edges))) (do (def getEdgesFaces_e1 (nth getEdgesFaces_edges getEdgesFaces_idx)) (cond (< getEdgesFaces_idx (- (count getEdgesFaces_edges) 1)) (do (def getEdgesFaces_e2 (nth getEdgesFaces_edges (+ getEdgesFaces_idx 1))) (when (and (= (nth getEdgesFaces_e1 0) (nth getEdgesFaces_e2 0)) (= (nth getEdgesFaces_e1 1) (nth getEdgesFaces_e2 1))) (do (def getEdgesFaces_merged (conj getEdgesFaces_merged [(nth getEdgesFaces_e1 0) (nth getEdgesFaces_e1 1) (nth getEdgesFaces_e1 2) (nth getEdgesFaces_e2 2)])) (def getEdgesFaces_idx (+ getEdgesFaces_idx 2)) (recur true)))) :else (do (def getEdgesFaces_merged (conj getEdgesFaces_merged [(nth getEdgesFaces_e1 0) (nth getEdgesFaces_e1 1) (nth getEdgesFaces_e1 2) (- 1)])) (def getEdgesFaces_idx (+ getEdgesFaces_idx 1)) (recur while_flag_1)))))) (def getEdgesFaces_edgesCenters []) (doseq [me getEdgesFaces_merged] (do (def getEdgesFaces_p1 (nth getEdgesFaces_points (nth me 0))) (def getEdgesFaces_p2 (nth getEdgesFaces_points (nth me 1))) (def getEdgesFaces_cp (centerPoint getEdgesFaces_p1 getEdgesFaces_p2)) (def getEdgesFaces_edgesCenters (conj getEdgesFaces_edgesCenters {:pn1 (nth me 0) :pn2 (nth me 1) :fn1 (nth me 2) :fn2 (nth me 3) :cp getEdgesFaces_cp})))) (throw (ex-info "return" {:v getEdgesFaces_edgesCenters}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn getEdgePoints [getEdgePoints_points getEdgePoints_edgesFaces getEdgePoints_facePoints]
  (try (do (def getEdgePoints_edgePoints []) (def getEdgePoints_i 0) (while (< getEdgePoints_i (count getEdgePoints_edgesFaces)) (do (def getEdgePoints_edge (nth getEdgePoints_edgesFaces getEdgePoints_i)) (def getEdgePoints_cp (:cp getEdgePoints_edge)) (def getEdgePoints_fp1 (nth getEdgePoints_facePoints (:fn1 getEdgePoints_edge))) (def getEdgePoints_fp2 getEdgePoints_fp1) (when (not= (:fn2 getEdgePoints_edge) (- 0 1)) (def getEdgePoints_fp2 (nth getEdgePoints_facePoints (:fn2 getEdgePoints_edge)))) (def getEdgePoints_cfp (centerPoint getEdgePoints_fp1 getEdgePoints_fp2)) (def getEdgePoints_edgePoints (conj getEdgePoints_edgePoints (centerPoint getEdgePoints_cp getEdgePoints_cfp))) (def getEdgePoints_i (+ getEdgePoints_i 1)))) (throw (ex-info "return" {:v getEdgePoints_edgePoints}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn getAvgFacePoints [getAvgFacePoints_points getAvgFacePoints_faces getAvgFacePoints_facePoints]
  (try (do (def getAvgFacePoints_numP (count getAvgFacePoints_points)) (def getAvgFacePoints_temp []) (def getAvgFacePoints_i 0) (while (< getAvgFacePoints_i getAvgFacePoints_numP) (do (def getAvgFacePoints_temp (conj getAvgFacePoints_temp {:p {:x 0.0 :y 0.0 :z 0.0} :n 0})) (def getAvgFacePoints_i (+ getAvgFacePoints_i 1)))) (def getAvgFacePoints_fnum 0) (while (< getAvgFacePoints_fnum (count getAvgFacePoints_faces)) (do (def getAvgFacePoints_fp (nth getAvgFacePoints_facePoints getAvgFacePoints_fnum)) (doseq [pn (nth getAvgFacePoints_faces getAvgFacePoints_fnum)] (do (def getAvgFacePoints_tp (nth getAvgFacePoints_temp pn)) (def getAvgFacePoints_temp (assoc getAvgFacePoints_temp pn {:p (sumPoint (:p getAvgFacePoints_tp) getAvgFacePoints_fp) :n (+ (:n getAvgFacePoints_tp) 1)})))) (def getAvgFacePoints_fnum (+ getAvgFacePoints_fnum 1)))) (def getAvgFacePoints_avg []) (def getAvgFacePoints_j 0) (while (< getAvgFacePoints_j getAvgFacePoints_numP) (do (def getAvgFacePoints_tp (nth getAvgFacePoints_temp getAvgFacePoints_j)) (def getAvgFacePoints_avg (conj getAvgFacePoints_avg (divPoint (:p getAvgFacePoints_tp) (double (:n getAvgFacePoints_tp))))) (def getAvgFacePoints_j (+ getAvgFacePoints_j 1)))) (throw (ex-info "return" {:v getAvgFacePoints_avg}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn getAvgMidEdges [getAvgMidEdges_points getAvgMidEdges_edgesFaces]
  (try (do (def getAvgMidEdges_numP (count getAvgMidEdges_points)) (def getAvgMidEdges_temp []) (def getAvgMidEdges_i 0) (while (< getAvgMidEdges_i getAvgMidEdges_numP) (do (def getAvgMidEdges_temp (conj getAvgMidEdges_temp {:p {:x 0.0 :y 0.0 :z 0.0} :n 0})) (def getAvgMidEdges_i (+ getAvgMidEdges_i 1)))) (doseq [edge getAvgMidEdges_edgesFaces] (do (def getAvgMidEdges_cp (:cp edge)) (def getAvgMidEdges_arr [(:pn1 edge) (:pn2 edge)]) (doseq [pn getAvgMidEdges_arr] (do (def getAvgMidEdges_tp (nth getAvgMidEdges_temp pn)) (def getAvgMidEdges_temp (assoc getAvgMidEdges_temp pn {:p (sumPoint (:p getAvgMidEdges_tp) getAvgMidEdges_cp) :n (+ (:n getAvgMidEdges_tp) 1)})))))) (def getAvgMidEdges_avg []) (def getAvgMidEdges_j 0) (while (< getAvgMidEdges_j getAvgMidEdges_numP) (do (def getAvgMidEdges_tp (nth getAvgMidEdges_temp getAvgMidEdges_j)) (def getAvgMidEdges_avg (conj getAvgMidEdges_avg (divPoint (:p getAvgMidEdges_tp) (double (:n getAvgMidEdges_tp))))) (def getAvgMidEdges_j (+ getAvgMidEdges_j 1)))) (throw (ex-info "return" {:v getAvgMidEdges_avg}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn getPointsFaces [getPointsFaces_points getPointsFaces_faces]
  (try (do (def getPointsFaces_pf []) (def getPointsFaces_i 0) (while (< getPointsFaces_i (count getPointsFaces_points)) (do (def getPointsFaces_pf (conj getPointsFaces_pf 0)) (def getPointsFaces_i (+ getPointsFaces_i 1)))) (def getPointsFaces_fnum 0) (while (< getPointsFaces_fnum (count getPointsFaces_faces)) (do (doseq [pn (nth getPointsFaces_faces getPointsFaces_fnum)] (def getPointsFaces_pf (assoc getPointsFaces_pf pn (+ (nth getPointsFaces_pf pn) 1)))) (def getPointsFaces_fnum (+ getPointsFaces_fnum 1)))) (throw (ex-info "return" {:v getPointsFaces_pf}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn getNewPoints [getNewPoints_points getNewPoints_pf getNewPoints_afp getNewPoints_ame]
  (try (do (def getNewPoints_newPts []) (def getNewPoints_i 0) (while (< getNewPoints_i (count getNewPoints_points)) (do (def getNewPoints_n (double (nth getNewPoints_pf getNewPoints_i))) (def getNewPoints_m1 (/ (- getNewPoints_n 3.0) getNewPoints_n)) (def getNewPoints_m2 (/ 1.0 getNewPoints_n)) (def getNewPoints_m3 (/ 2.0 getNewPoints_n)) (def getNewPoints_old (nth getNewPoints_points getNewPoints_i)) (def getNewPoints_p1 (mulPoint getNewPoints_old getNewPoints_m1)) (def getNewPoints_p2 (mulPoint (nth getNewPoints_afp getNewPoints_i) getNewPoints_m2)) (def getNewPoints_p3 (mulPoint (nth getNewPoints_ame getNewPoints_i) getNewPoints_m3)) (def getNewPoints_newPts (conj getNewPoints_newPts (sumPoint (sumPoint getNewPoints_p1 getNewPoints_p2) getNewPoints_p3))) (def getNewPoints_i (+ getNewPoints_i 1)))) (throw (ex-info "return" {:v getNewPoints_newPts}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn key [key_a key_b]
  (try (if (< key_a key_b) (str (str (str key_a) ",") (str key_b)) (str (str (str key_b) ",") (str key_a))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn cmcSubdiv [cmcSubdiv_points cmcSubdiv_faces]
  (try (do (def cmcSubdiv_facePoints (getFacePoints cmcSubdiv_points cmcSubdiv_faces)) (def cmcSubdiv_edgesFaces (getEdgesFaces cmcSubdiv_points cmcSubdiv_faces)) (def cmcSubdiv_edgePoints (getEdgePoints cmcSubdiv_points cmcSubdiv_edgesFaces cmcSubdiv_facePoints)) (def cmcSubdiv_avgFacePoints (getAvgFacePoints cmcSubdiv_points cmcSubdiv_faces cmcSubdiv_facePoints)) (def cmcSubdiv_avgMidEdges (getAvgMidEdges cmcSubdiv_points cmcSubdiv_edgesFaces)) (def cmcSubdiv_pointsFaces (getPointsFaces cmcSubdiv_points cmcSubdiv_faces)) (def cmcSubdiv_newPoints (getNewPoints cmcSubdiv_points cmcSubdiv_pointsFaces cmcSubdiv_avgFacePoints cmcSubdiv_avgMidEdges)) (def cmcSubdiv_facePointNums []) (def cmcSubdiv_nextPoint (count cmcSubdiv_newPoints)) (doseq [fp cmcSubdiv_facePoints] (do (def cmcSubdiv_newPoints (conj cmcSubdiv_newPoints fp)) (def cmcSubdiv_facePointNums (conj cmcSubdiv_facePointNums cmcSubdiv_nextPoint)) (def cmcSubdiv_nextPoint (+ cmcSubdiv_nextPoint 1)))) (def cmcSubdiv_edgePointNums {}) (def cmcSubdiv_idx 0) (while (< cmcSubdiv_idx (count cmcSubdiv_edgesFaces)) (do (def cmcSubdiv_e (nth cmcSubdiv_edgesFaces cmcSubdiv_idx)) (def cmcSubdiv_newPoints (conj cmcSubdiv_newPoints (nth cmcSubdiv_edgePoints cmcSubdiv_idx))) (def cmcSubdiv_edgePointNums (assoc cmcSubdiv_edgePointNums (key (:pn1 cmcSubdiv_e) (:pn2 cmcSubdiv_e)) cmcSubdiv_nextPoint)) (def cmcSubdiv_nextPoint (+ cmcSubdiv_nextPoint 1)) (def cmcSubdiv_idx (+ cmcSubdiv_idx 1)))) (def cmcSubdiv_newFaces []) (def cmcSubdiv_fnum 0) (while (< cmcSubdiv_fnum (count cmcSubdiv_faces)) (do (def cmcSubdiv_oldFace (nth cmcSubdiv_faces cmcSubdiv_fnum)) (when (= (count cmcSubdiv_oldFace) 4) (do (def cmcSubdiv_a (nth cmcSubdiv_oldFace 0)) (def cmcSubdiv_b (nth cmcSubdiv_oldFace 1)) (def cmcSubdiv_c (nth cmcSubdiv_oldFace 2)) (def cmcSubdiv_d (nth cmcSubdiv_oldFace 3)) (def cmcSubdiv_fpnum (nth cmcSubdiv_facePointNums cmcSubdiv_fnum)) (def cmcSubdiv_ab (get cmcSubdiv_edgePointNums (key cmcSubdiv_a cmcSubdiv_b))) (def cmcSubdiv_da (get cmcSubdiv_edgePointNums (key cmcSubdiv_d cmcSubdiv_a))) (def cmcSubdiv_bc (get cmcSubdiv_edgePointNums (key cmcSubdiv_b cmcSubdiv_c))) (def cmcSubdiv_cd (get cmcSubdiv_edgePointNums (key cmcSubdiv_c cmcSubdiv_d))) (def cmcSubdiv_newFaces (conj cmcSubdiv_newFaces [cmcSubdiv_a cmcSubdiv_ab cmcSubdiv_fpnum cmcSubdiv_da])) (def cmcSubdiv_newFaces (conj cmcSubdiv_newFaces [cmcSubdiv_b cmcSubdiv_bc cmcSubdiv_fpnum cmcSubdiv_ab])) (def cmcSubdiv_newFaces (conj cmcSubdiv_newFaces [cmcSubdiv_c cmcSubdiv_cd cmcSubdiv_fpnum cmcSubdiv_bc])) (def cmcSubdiv_newFaces (conj cmcSubdiv_newFaces [cmcSubdiv_d cmcSubdiv_da cmcSubdiv_fpnum cmcSubdiv_cd])))) (def cmcSubdiv_fnum (+ cmcSubdiv_fnum 1)))) (throw (ex-info "return" {:v [cmcSubdiv_newPoints cmcSubdiv_newFaces]}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn formatPoint [formatPoint_p]
  (try (throw (ex-info "return" {:v (str (str (str (str (str (str "[" (fmt4 (:x formatPoint_p))) " ") (fmt4 (:y formatPoint_p))) " ") (fmt4 (:z formatPoint_p))) "]")})) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn formatFace [formatFace_f]
  (try (do (when (= (count formatFace_f) 0) (throw (ex-info "return" {:v "[]"}))) (def formatFace_s (str "[" (fmt2 (nth formatFace_f 0)))) (def formatFace_i 1) (while (< formatFace_i (count formatFace_f)) (do (def formatFace_s (str (str formatFace_s " ") (fmt2 (nth formatFace_f formatFace_i)))) (def formatFace_i (+ formatFace_i 1)))) (def formatFace_s (str formatFace_s "]")) (throw (ex-info "return" {:v formatFace_s}))) (catch clojure.lang.ExceptionInfo e (if (= (ex-message e) "return") (get (ex-data e) :v) (throw e)))))

(defn main []
  (do (def main_inputPoints [{:x (- 1.0) :y 1.0 :z 1.0} {:x (- 1.0) :y (- 1.0) :z 1.0} {:x 1.0 :y (- 1.0) :z 1.0} {:x 1.0 :y 1.0 :z 1.0} {:x 1.0 :y (- 1.0) :z (- 1.0)} {:x 1.0 :y 1.0 :z (- 1.0)} {:x (- 1.0) :y (- 1.0) :z (- 1.0)} {:x (- 1.0) :y 1.0 :z (- 1.0)}]) (def main_inputFaces [[0 1 2 3] [3 2 4 5] [5 4 6 7] [7 0 3 5] [7 6 1 0] [6 1 2 4]]) (def main_outputPoints main_inputPoints) (def main_outputFaces main_inputFaces) (def main_i 0) (while (< main_i 1) (do (def main_res (cmcSubdiv main_outputPoints main_outputFaces)) (def main_outputPoints (nth main_res 0)) (def main_outputFaces (nth main_res 1)) (def main_i (+ main_i 1)))) (doseq [p main_outputPoints] (println (formatPoint p))) (println "") (doseq [f main_outputFaces] (println (formatFace f)))))

(defn -main []
  (let [rt (Runtime/getRuntime)
    start-mem (- (.totalMemory rt) (.freeMemory rt))
    start (System/nanoTime)]
      (main)
      (System/gc)
      (let [end (System/nanoTime)
        end-mem (- (.totalMemory rt) (.freeMemory rt))
        duration-us (quot (- end start) 1000)
        memory-bytes (Math/abs ^long (- end-mem start-mem))]
        (println (str "{\n  \"duration_us\": " duration-us ",\n  \"memory_bytes\": " memory-bytes ",\n  \"name\": \"main\"\n}"))
      )
    ))

(-main)
