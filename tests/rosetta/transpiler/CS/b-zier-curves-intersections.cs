// Generated by Mochi 0.10.40 on 2025-07-26 09:54 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Collections;

struct Point {
    public double x;
    public double y;
    public override string ToString() => $"Point {{x = {x.ToString("0.0")}, y = {y.ToString("0.0")}}}";
}
struct QuadSpline {
    public double c0;
    public double c1;
    public double c2;
    public override string ToString() => $"QuadSpline {{c0 = {c0.ToString("0.0")}, c1 = {c1.ToString("0.0")}, c2 = {c2.ToString("0.0")}}}";
}
struct QuadCurve {
    public QuadSpline x;
    public QuadSpline y;
    public override string ToString() => $"QuadCurve {{x = {x}, y = {y}}}";
}
class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static long _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = unchecked(nowSeed * 1664525 + 1013904223);
            nowSeed %= 9223372036854775783L;
            if (nowSeed < 0) nowSeed += 9223372036854775783L;
            return nowSeed;
        }
        return DateTime.UtcNow.Ticks / 100;
    }
    static long _mem() {
        return GC.GetTotalMemory(false);
    }
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is bool b) return b ? "1" : "0";
        return Convert.ToString(v);
    }
    static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        return _fmt(v);
    }
    static double absf(double x) {
        if ((x < 0)) {
            return -x;
        };
        return x;
    }

    static double maxf(double a, double b) {
        if ((a > b)) {
            return a;
        };
        return b;
    }

    static double minf(double a, double b) {
        if ((a < b)) {
            return a;
        };
        return b;
    }

    static double max3(double a, double b, double c) {
        double m_0 = a;
        if ((b > m_0)) {
            m_0 = b;
        };
        if ((c > m_0)) {
            m_0 = c;
        };
        return m_0;
    }

    static double min3(double a, double b, double c) {
        double m_1 = a;
        if ((b < m_1)) {
            m_1 = b;
        };
        if ((c < m_1)) {
            m_1 = c;
        };
        return m_1;
    }

    static QuadSpline[] subdivideQuadSpline(QuadSpline q, double t) {
        double s_2 = (1 - t);
        QuadSpline u_3 = new QuadSpline{c0 = q.c0, c1 = 0, c2 = 0};
        QuadSpline v_4 = new QuadSpline{c0 = 0, c1 = 0, c2 = q.c2};
        u_3.c1 = ((s_2 * q.c0) + (t * q.c1));
        v_4.c1 = ((s_2 * q.c1) + (t * q.c2));
        u_3.c2 = ((s_2 * u_3.c1) + (t * v_4.c1));
        v_4.c0 = u_3.c2;
        return new QuadSpline[]{u_3, v_4};
    }

    static QuadCurve[] subdivideQuadCurve(QuadCurve q, double t) {
        QuadSpline[] xs_5 = subdivideQuadSpline(q.x, t);
        QuadSpline[] ys_6 = subdivideQuadSpline(q.y, t);
        QuadCurve u_7 = new QuadCurve{x = xs_5[(int)(0)], y = ys_6[(int)(0)]};
        QuadCurve v_8 = new QuadCurve{x = xs_5[(int)(1)], y = ys_6[(int)(1)]};
        return new QuadCurve[]{u_7, v_8};
    }

    static bool rectsOverlap(double xa0, double ya0, double xa1, double ya1, double xb0, double yb0, double xb1, double yb1) {
        return ((((xb0 <= xa1) && (xa0 <= xb1)) && (yb0 <= ya1)) && (ya0 <= yb1));
    }

    static Dictionary<string, object> testIntersect(QuadCurve p, QuadCurve q, double tol) {
        double pxmin_9 = min3(p.x.c0, p.x.c1, p.x.c2);
        double pymin_10 = min3(p.y.c0, p.y.c1, p.y.c2);
        double pxmax_11 = max3(p.x.c0, p.x.c1, p.x.c2);
        double pymax_12 = max3(p.y.c0, p.y.c1, p.y.c2);
        double qxmin_13 = min3(q.x.c0, q.x.c1, q.x.c2);
        double qymin_14 = min3(q.y.c0, q.y.c1, q.y.c2);
        double qxmax_15 = max3(q.x.c0, q.x.c1, q.x.c2);
        double qymax_16 = max3(q.y.c0, q.y.c1, q.y.c2);
        bool exclude_17 = true;
        bool accept_18 = false;
        Point inter_19 = new Point{x = 0, y = 0};
        if (rectsOverlap(pxmin_9, pymin_10, pxmax_11, pymax_12, qxmin_13, qymin_14, qxmax_15, qymax_16)) {
            exclude_17 = false;
            double xmin_20 = maxf(pxmin_9, qxmin_13);
            double xmax_21 = minf(pxmax_11, qxmax_15);
            if (((xmax_21 - xmin_20) <= tol)) {
                double ymin_22 = maxf(pymin_10, qymin_14);
                double ymax_23 = minf(pymax_12, qymax_16);
                if (((ymax_23 - ymin_22) <= tol)) {
                    accept_18 = true;
                    inter_19.x = (0.5 * (xmin_20 + xmax_21));
                    inter_19.y = (0.5 * (ymin_22 + ymax_23));
                }
            }
        };
        return new Dictionary<string, object>{{"exclude", exclude_17}, {"accept", accept_18}, {"intersect", inter_19}};
    }

    static bool seemsToBeDuplicate(Point[] pts, Point xy, double spacing) {
        long i_24 = 0;
        while ((i_24 < pts.Length)) {
            Point pt_25 = pts[(int)(i_24)];
            if (((absf((pt_25.x - xy.x)) < spacing) && (absf((pt_25.y - xy.y)) < spacing))) {
                return true;
            }
            i_24 = (i_24 + 1);
        };
        return false;
    }

    static Point[] findIntersects(QuadCurve p, QuadCurve q, double tol, double spacing) {
        Point[] inters_26 = new Point[]{};
        Dictionary<string, QuadCurve>[] workload_27 = new Dictionary<string, QuadCurve>[]{new Dictionary<string, QuadCurve>{{"p", p}, {"q", q}}};
        while ((workload_27.Length > 0)) {
            long idx_28 = (((dynamic)workload_27.Length) - ((dynamic)1));
            Dictionary<string, QuadCurve> work_29 = (workload_27.ContainsKey(idx_28) ? workload_27[idx_28] : null);
            workload_27 = workload_27.Skip((int)(0)).Take((int)((idx_28 - 0))).ToArray();
            Dictionary<string, object> res_30 = testIntersect((work_29.ContainsKey("p") ? work_29["p"] : null), (work_29.ContainsKey("q") ? work_29["q"] : null), tol);
            var excl_31 = ((dynamic)res_30)["exclude"];
            var acc_32 = ((dynamic)res_30)["accept"];
            var inter_33 = ((dynamic)res_30)["intersect"];
            if (acc_32) {
                if ((!seemsToBeDuplicate(inters_26, inter_33, spacing))) {
                    inters_26 = (Enumerable.ToArray(Enumerable.Append(inters_26, inter_33)));
                }
            } else {
                if ((!Convert.ToBoolean(excl_31))) {
                    QuadCurve[] ps_34 = subdivideQuadCurve((work_29.ContainsKey("p") ? work_29["p"] : null), 0.5);
                    QuadCurve[] qs_35 = subdivideQuadCurve((work_29.ContainsKey("q") ? work_29["q"] : null), 0.5);
                    QuadCurve p0_36 = ps_34[(int)(0)];
                    QuadCurve p1_37 = ps_34[(int)(1)];
                    QuadCurve q0_38 = qs_35[(int)(0)];
                    QuadCurve q1_39 = qs_35[(int)(1)];
                    workload_27 = (Enumerable.ToArray(Enumerable.Append(workload_27, new Dictionary<string, QuadCurve>{{"p", p0_36}, {"q", q0_38}})));
                    workload_27 = (Enumerable.ToArray(Enumerable.Append(workload_27, new Dictionary<string, QuadCurve>{{"p", p0_36}, {"q", q1_39}})));
                    workload_27 = (Enumerable.ToArray(Enumerable.Append(workload_27, new Dictionary<string, QuadCurve>{{"p", p1_37}, {"q", q0_38}})));
                    workload_27 = (Enumerable.ToArray(Enumerable.Append(workload_27, new Dictionary<string, QuadCurve>{{"p", p1_37}, {"q", q1_39}})));
                }
            }
        };
        return inters_26;
    }

    static void main() {
        QuadCurve p_40 = new QuadCurve{x = new QuadSpline{c0 = -1, c1 = 0, c2 = 1}, y = new QuadSpline{c0 = 0, c1 = 10, c2 = 0}};
        QuadCurve q_41 = new QuadCurve{x = new QuadSpline{c0 = 2, c1 = -8, c2 = 2}, y = new QuadSpline{c0 = 1, c1 = 2, c2 = 3}};
        double tol_42 = 1e-07;
        double spacing_43 = (tol_42 * 10);
        Point[] inters_44 = findIntersects(p_40, q_41, tol_42, spacing_43);
        long i_45 = 0;
        while ((i_45 < inters_44.Length)) {
            Point pt_46 = inters_44[(int)(i_45)];
            Console.WriteLine(_fmtTop((((("(" + (pt_46.x).ToString()) + ", ") + (pt_46.y).ToString()) + ")")));
            i_45 = (i_45 + 1);
        };
    }

    static void Main() {
        {
            var __memStart = _mem();
            var __start = _now();
            main();
            var __end = _now();
            var __memEnd = _mem();
            var __dur = (__end - __start);
            var __memDiff = __memEnd - __memStart;
            Console.WriteLine(JsonSerializer.Serialize(new SortedDictionary<string, object>{{"name", "main"}, {"duration_us", __dur}, {"memory_bytes", __memDiff}}, new JsonSerializerOptions{ WriteIndented = true }));
        }
    }
}
