// Generated by Mochi 0.10.41 on 2025-07-27 11:31 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Collections;

class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static long _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = unchecked(nowSeed * 1664525 + 1013904223);
            nowSeed %= 9223372036854775783L;
            if (nowSeed < 0) nowSeed += 9223372036854775783L;
            return nowSeed;
        }
        return DateTime.UtcNow.Ticks / 100;
    }
    static long _mem() {
        return GC.GetTotalMemory(false);
    }
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is bool b) return b ? "1" : "0";
        return Convert.ToString(v);
    }
    static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        return _fmt(v);
    }
    static long toUnsigned16(long n_0) {
        long u_1 = n_0;
        if ((u_1 < 0)) {
            u_1 = (u_1 + 65536);
        };
        return (u_1 % 65536);
    }

    static string bin16(long n_2) {
        long u_3 = toUnsigned16(n_2);
        string bits_4 = "";
        long mask_5 = 32768;
        for (var i_6 = 0; i_6 < 16; i_6++) {
            if ((u_3 >= mask_5)) {
                bits_4 = (bits_4 + "1");
                u_3 = (u_3 - mask_5);
            } else {
                bits_4 = (bits_4 + "0");
            }
            mask_5 = Convert.ToInt64((mask_5 / 2));
        };
        return bits_4;
    }

    static long bit_and(long a_7, long b_8) {
        long ua_9 = toUnsigned16(a_7);
        long ub_10 = toUnsigned16(b_8);
        long res_11 = 0;
        long bit_12 = 1;
        for (var i_13 = 0; i_13 < 16; i_13++) {
            if ((((ua_9 % 2) == 1) && ((ub_10 % 2) == 1))) {
                res_11 = (res_11 + bit_12);
            }
            ua_9 = Convert.ToInt64((ua_9 / 2));
            ub_10 = Convert.ToInt64((ub_10 / 2));
            bit_12 = (bit_12 * 2);
        };
        return res_11;
    }

    static long bit_or(long a_14, long b_15) {
        long ua_16 = toUnsigned16(a_14);
        long ub_17 = toUnsigned16(b_15);
        long res_18 = 0;
        long bit_19 = 1;
        for (var i_20 = 0; i_20 < 16; i_20++) {
            if ((((ua_16 % 2) == 1) || ((ub_17 % 2) == 1))) {
                res_18 = (res_18 + bit_19);
            }
            ua_16 = Convert.ToInt64((ua_16 / 2));
            ub_17 = Convert.ToInt64((ub_17 / 2));
            bit_19 = (bit_19 * 2);
        };
        return res_18;
    }

    static long bit_xor(long a_21, long b_22) {
        long ua_23 = toUnsigned16(a_21);
        long ub_24 = toUnsigned16(b_22);
        long res_25 = 0;
        long bit_26 = 1;
        for (var i_27 = 0; i_27 < 16; i_27++) {
            long abit_28 = (ua_23 % 2);
            long bbit_29 = (ub_24 % 2);
            if ((((abit_28 == 1) && (bbit_29 == 0)) || ((abit_28 == 0) && (bbit_29 == 1)))) {
                res_25 = (res_25 + bit_26);
            }
            ua_23 = Convert.ToInt64((ua_23 / 2));
            ub_24 = Convert.ToInt64((ub_24 / 2));
            bit_26 = (bit_26 * 2);
        };
        return res_25;
    }

    static long bit_not(long a_30) {
        long ua_31 = toUnsigned16(a_30);
        return (65535 - ua_31);
    }

    static long shl(long a_32, long b_33) {
        long ua_34 = toUnsigned16(a_32);
        long i_35 = 0;
        while ((i_35 < b_33)) {
            ua_34 = ((ua_34 * 2) % 65536);
            i_35 = (i_35 + 1);
        };
        return ua_34;
    }

    static long shr(long a_36, long b_37) {
        long ua_38 = toUnsigned16(a_36);
        long i_39 = 0;
        while ((i_39 < b_37)) {
            ua_38 = Convert.ToInt64((ua_38 / 2));
            i_39 = (i_39 + 1);
        };
        return ua_38;
    }

    static long las(long a_40, long b_41) {
        return shl(a_40, b_41);
    }

    static long ras(long a_42, long b_43) {
        long val_44 = a_42;
        long i_45 = 0;
        while ((i_45 < b_43)) {
            if ((val_44 >= 0)) {
                val_44 = Convert.ToInt64((val_44 / 2));
            } else {
                val_44 = Convert.ToInt64(((val_44 - 1) / 2));
            }
            i_45 = (i_45 + 1);
        };
        return toUnsigned16(val_44);
    }

    static long rol(long a_46, long b_47) {
        long ua_48 = toUnsigned16(a_46);
        long left_49 = shl(ua_48, b_47);
        long right_50 = shr(ua_48, (16 - b_47));
        return toUnsigned16((left_49 + right_50));
    }

    static long ror(long a_51, long b_52) {
        long ua_53 = toUnsigned16(a_51);
        long right_54 = shr(ua_53, b_52);
        long left_55 = shl(ua_53, (16 - b_52));
        return toUnsigned16((left_55 + right_54));
    }

    static void bitwise(long a_56, long b_57) {
        Console.WriteLine(_fmtTop(("a:   " + bin16(a_56))));
        Console.WriteLine(_fmtTop(("b:   " + bin16(b_57))));
        Console.WriteLine(_fmtTop(("and: " + bin16(bit_and(a_56, b_57)))));
        Console.WriteLine(_fmtTop(("or:  " + bin16(bit_or(a_56, b_57)))));
        Console.WriteLine(_fmtTop(("xor: " + bin16(bit_xor(a_56, b_57)))));
        Console.WriteLine(_fmtTop(("not: " + bin16(bit_not(a_56)))));
        if ((b_57 < 0)) {
            Console.WriteLine(_fmtTop("Right operand is negative, but all shifts require an unsigned right operand (shift distance)."));
            return;
        };
        Console.WriteLine(_fmtTop(("shl: " + bin16(shl(a_56, b_57)))));
        Console.WriteLine(_fmtTop(("shr: " + bin16(shr(a_56, b_57)))));
        Console.WriteLine(_fmtTop(("las: " + bin16(las(a_56, b_57)))));
        Console.WriteLine(_fmtTop(("ras: " + bin16(ras(a_56, b_57)))));
        Console.WriteLine(_fmtTop(("rol: " + bin16(rol(a_56, b_57)))));
        Console.WriteLine(_fmtTop(("ror: " + bin16(ror(a_56, b_57)))));
    }

    static void Main() {
        {
            var __memStart = _mem();
            var __start = _now();
            bitwise(-460, 6);
            var __end = _now();
            var __memEnd = _mem();
            var __dur = (__end - __start);
            var __memDiff = __memEnd - __memStart;
            Console.WriteLine(JsonSerializer.Serialize(new SortedDictionary<string, object>{{"name", "main"}, {"duration_us", __dur}, {"memory_bytes", __memDiff}}, new JsonSerializerOptions{ WriteIndented = true }));
        }
    }
}
