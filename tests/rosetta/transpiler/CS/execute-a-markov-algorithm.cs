// Generated by Mochi 0.10.50 on 2025-07-31 08:23 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Numerics;
using System.Collections;

class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static long _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = unchecked(nowSeed * 1664525 + 1013904223);
            nowSeed %= 9223372036854775783L;
            if (nowSeed < 0) nowSeed += 9223372036854775783L;
            return nowSeed;
        }
        return DateTime.UtcNow.Ticks / 100;
    }
    static long _mem() {
        return GC.GetTotalMemory(false);
    }
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is bool b) return b ? "1" : "0";
        return Convert.ToString(v);
    }
    static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        return _fmt(v);
    }
    static Dictionary<string, string>[] testSet_37 = new Dictionary<string, string>[]{new Dictionary<string, string>{{"ruleSet", "# This rules file is extracted from Wikipedia:\n# http://en.wikipedia.org/wiki/Markov_Algorithm\nA -> apple\nB -> bag\nS -> shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"}, {"sample", "I bought a B of As from T S."}, {"output", "I bought a bag of apples from my brother."}}, new Dictionary<string, string>{{"ruleSet", "# Slightly modified from the rules on Wikipedia\nA -> apple\nB -> bag\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"}, {"sample", "I bought a B of As from T S."}, {"output", "I bought a bag of apples from T shop."}}, new Dictionary<string, string>{{"ruleSet", "# BNF Syntax testing rules\nA -> apple\nWWWW -> with\nBgage -> ->.*\nB -> bag\n->.* -> money\nW -> WW\nS -> .shop\nT -> the\nthe shop -> my brother\na never used -> .terminating rule\n"}, {"sample", "I bought a B of As W my Bgage from T S."}, {"output", "I bought a bag of apples with my money from T shop."}}, new Dictionary<string, string>{{"ruleSet", "### Unary Multiplication Engine, for testing Markov Algorithm implementations\n### By Donal Fellows.\n# Unary addition engine\n_+1 -> _1+\n1+1 -> 11+\n# Pass for converting from the splitting of multiplication into ordinary\n# addition\n1! -> !1\n,! -> !+\n_! -> _\n# Unary multiplication by duplicating left side, right side times\n1*1 -> x,@y\n1x -> xX\nX, -> 1,1\nX1 -> 1X\n_x -> _X\n,x -> ,X\ny1 -> 1y\ny_ -> _\n# Next phase of applying\n1@1 -> x,@y\n1@_ -> @_\n,@_ -> !_\n++ -> +\n# Termination cleanup for addition\n_1 -> 1\n1+_ -> 1\n_+_ ->\n"}, {"sample", "_1111*11111_"}, {"output", "11111111111111111111"}}, new Dictionary<string, string>{{"ruleSet", "# Turing machine: three-state busy beaver\n#\n# state A, symbol 0 => write 1, move right, new state B\nA0 -> 1B\n# state A, symbol 1 => write 1, move left, new state C\n0A1 -> C01\n1A1 -> C11\n# state B, symbol 0 => write 1, move left, new state A\n0B0 -> A01\n1B0 -> A11\n# state B, symbol 1 => write 1, move right, new state B\nB1 -> 1B\n# state C, symbol 0 => write 1, move left, new state B\n0C0 -> B01\n1C0 -> B11\n# state C, symbol 1 => write 1, move left, halt\n0C1 -> H01\n1C1 -> H11\n"}, {"sample", "000000A000000"}, {"output", "00011H1111000"}}};
    static string[] split(string s_0, string sep_1) {
        string[] parts_2 = new string[]{};
        string cur_3 = "";
        long i_4 = 0;
        while ((i_4 < s_0.Length)) {
            if ((((sep_1.Length > 0) && ((((dynamic)(i_4)) + ((dynamic)(sep_1.Length))) <= s_0.Length)) && (s_0.Substring((int)(i_4), (int)((((dynamic)(i_4)) + ((dynamic)(sep_1.Length))) - i_4)) == sep_1))) {
                parts_2 = (Enumerable.ToArray(Enumerable.Append(parts_2, cur_3)));
                cur_3 = "";
                i_4 = (((dynamic)(i_4)) + ((dynamic)(sep_1.Length)));
            } else {
                cur_3 = (cur_3 + s_0.Substring((int)(i_4), (int)((i_4 + 1) - i_4)));
                i_4 = (i_4 + 1);
            }
        };
        parts_2 = (Enumerable.ToArray(Enumerable.Append(parts_2, cur_3)));
        return parts_2;
    }

    static string trimSpace(string s_5) {
        long start_6 = 0;
        while (((start_6 < s_5.Length) && ((s_5.Substring((int)(start_6), (int)((start_6 + 1) - start_6)) == " ") || (s_5.Substring((int)(start_6), (int)((start_6 + 1) - start_6)) == "\t")))) {
            start_6 = (start_6 + 1);
        };
        long end_7 = s_5.Length;
        while (((end_7 > start_6) && ((s_5.Substring((int)((end_7 - 1)), (int)(end_7 - (end_7 - 1))) == " ") || (s_5.Substring((int)((end_7 - 1)), (int)(end_7 - (end_7 - 1))) == "\t")))) {
            end_7 = (end_7 - 1);
        };
        return s_5.Substring((int)(start_6), (int)(end_7 - start_6));
    }

    static long indexOfSub(string s_8, string sub_9) {
        if ((sub_9.Length == 0)) {
            return 0;
        };
        long i_10 = 0;
        while (((((dynamic)(i_10)) + ((dynamic)(sub_9.Length))) <= s_8.Length)) {
            if ((s_8.Substring((int)(i_10), (int)((((dynamic)(i_10)) + ((dynamic)(sub_9.Length))) - i_10)) == sub_9)) {
                return i_10;
            }
            i_10 = (i_10 + 1);
        };
        return (0 - 1);
    }

    static Dictionary<string, object> parseRules(string rs_11) {
        Dictionary<string, object>[] rules_12 = new Dictionary<string, object>[]{};
        foreach (var line_13 in split(rs_11, "\n")) {
            string ln_14 = line_13;
            long hash_15 = indexOfSub(ln_14, "#");
            if ((hash_15 >= 0)) {
                ln_14 = ln_14.Substring((int)(0), (int)(hash_15 - 0));
            }
            ln_14 = trimSpace(ln_14);
            if ((ln_14.Length == 0)) {
                continue;
            }
            long arrow_16 = (0 - 1);
            long j_17 = 0;
            while (((j_17 + 2) <= ln_14.Length)) {
                if ((ln_14.Substring((int)(j_17), (int)((j_17 + 2) - j_17)) == "->")) {
                    bool pre_18 = ((j_17 > 0) && ((ln_14.Substring((int)((j_17 - 1)), (int)(j_17 - (j_17 - 1))) == " ") || (ln_14.Substring((int)((j_17 - 1)), (int)(j_17 - (j_17 - 1))) == "\t")));
                    bool post_19 = (((j_17 + 2) < ln_14.Length) && ((ln_14.Substring((int)((j_17 + 2)), (int)((j_17 + 3) - (j_17 + 2))) == " ") || (ln_14.Substring((int)((j_17 + 2)), (int)((j_17 + 3) - (j_17 + 2))) == "\t")));
                    if ((pre_18 && post_19)) {
                        arrow_16 = j_17;
                        break;
                    }
                }
                j_17 = (j_17 + 1);
            }
            if ((arrow_16 < 0)) {
                arrow_16 = indexOfSub(ln_14, "->");
            }
            if ((arrow_16 < 0)) {
                return new Dictionary<string, object>{{"ok", false}};
            }
            string pat_20 = trimSpace(ln_14.Substring((int)(0), (int)(arrow_16 - 0)));
            string rest_21 = trimSpace(ln_14.Substring((int)((arrow_16 + 2)), (int)(ln_14.Length - (arrow_16 + 2))));
            bool term_22 = false;
            if (((rest_21.Length > 0) && (rest_21.Substring((int)(0), (int)(1 - 0)) == "."))) {
                term_22 = true;
                rest_21 = rest_21.Substring((int)(1), (int)(rest_21.Length - 1));
            }
            string rep_23 = rest_21;
            rules_12 = (Enumerable.ToArray(Enumerable.Append(rules_12, new Dictionary<string, object>{{"pat", pat_20}, {"rep", rep_23}, {"term", term_22}})));
        };
        return new Dictionary<string, object>{{"ok", true}, {"rules", rules_12}};
    }

    static string runRules(Dictionary<string, object>[] rules_24, string s_25) {
        bool changed_26 = true;
        while (changed_26) {
            changed_26 = false;
            long i_27 = 0;
            while ((i_27 < rules_24.Length)) {
                Dictionary<string, object> r_28 = rules_24[(int)(i_27)];
                var pat_29 = ((dynamic)r_28)["pat"];
                var rep_30 = ((dynamic)r_28)["rep"];
                var term_31 = ((dynamic)r_28)["term"];
                long idx_32 = indexOfSub(s_25, pat_29);
                if ((idx_32 >= 0)) {
                    s_25 = ((((dynamic)(s_25.Substring((int)(0), (int)(idx_32 - 0)))) + ((dynamic)(rep_30))) + s_25.Substring((int)((((dynamic)(idx_32)) + ((dynamic)(pat_29.Length)))), (int)(s_25.Length - (((dynamic)(idx_32)) + ((dynamic)(pat_29.Length))))));
                    changed_26 = true;
                    if (term_31) {
                        return s_25;
                    }
                    break;
                }
                i_27 = (i_27 + 1);
            }
        };
        return s_25;
    }

    static Dictionary<string, object> interpret(string ruleset_33, string input_34) {
        Dictionary<string, object> p_35 = parseRules(ruleset_33);
        if ((!Convert.ToBoolean(((dynamic)p_35)["ok"]))) {
            return new Dictionary<string, object>{{"ok", false}, {"out", ""}};
        };
        string out_36 = runRules(((dynamic)p_35)["rules"], input_34);
        return new Dictionary<string, object>{{"ok", true}, {"out", out_36}};
    }

    static void main() {
        Console.WriteLine(_fmtTop((("validating " + (testSet_37.Length).ToString()) + " test cases")));
        bool failures_38 = false;
        long i_39 = 0;
        while ((i_39 < testSet_37.Length)) {
            Dictionary<string, string> tc_40 = testSet_37[(int)(i_39)];
            Dictionary<string, object> res_41 = interpret((tc_40.ContainsKey("ruleSet") ? tc_40["ruleSet"] : ""), (tc_40.ContainsKey("sample") ? tc_40["sample"] : ""));
            if ((!Convert.ToBoolean(((dynamic)res_41)["ok"]))) {
                Console.WriteLine(_fmtTop((("test " + ((i_39 + 1)).ToString()) + " invalid ruleset")));
                failures_38 = true;
            } else {
                if ((((dynamic)res_41)["out"] != (tc_40.ContainsKey("output") ? tc_40["output"] : ""))) {
                    Console.WriteLine(_fmtTop((((((dynamic)((("test " + ((i_39 + 1)).ToString()) + ": got "))) + ((dynamic)(((dynamic)res_41)["out"]))) + ", want ") + (tc_40.ContainsKey("output") ? tc_40["output"] : ""))));
                    failures_38 = true;
                }
            }
            i_39 = (i_39 + 1);
        };
        if ((!failures_38)) {
            Console.WriteLine(_fmtTop("no failures"));
        };
    }

    static void Main() {
        {
            var __memStart = _mem();
            var __start = _now();
            main();
            var __end = _now();
            var __memEnd = _mem();
            var __dur = (__end - __start);
            var __memDiff = __memEnd - __memStart;
            Console.WriteLine(JsonSerializer.Serialize(new SortedDictionary<string, object>{{"name", "main"}, {"duration_us", __dur}, {"memory_bytes", __memDiff}}, new JsonSerializerOptions{ WriteIndented = true }));
        }
    }
}
