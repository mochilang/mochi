// Generated by Mochi 0.10.40 on 2025-07-25 12:29 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Collections;

struct Rational {
    public long num;
    public long denom;
    public override string ToString() => $"Rational {{num = {num}, denom = {denom}}}";
}
struct Bin {
    public long op;
    public object left;
    public object right;
    public override string ToString() => $"Bin {{op = {op}, left = {left}, right = {right}}}";
}
struct Num {
    public Rational value;
    public override string ToString() => $"Num {{value = {value}}}";
}
class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static long _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = unchecked(nowSeed * 1664525 + 1013904223);
            nowSeed %= 9223372036854775783L;
            if (nowSeed < 0) nowSeed += 9223372036854775783L;
            return nowSeed;
        }
        return DateTime.UtcNow.Ticks / 100;
    }
    static long _mem() {
        return GC.GetTotalMemory(false);
    }
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is bool b) return b ? "1" : "0";
        return Convert.ToString(v);
    }
    static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        return _fmt(v);
    }
    static long OP_ADD = 1;
    static long OP_SUB = 2;
    static long OP_MUL = 3;
    static long OP_DIV = 4;
    static long n_cards = 4;
    static long goal = 24;
    static long digit_range = 9;
    static Rational binEval(long op, object l, object r) {
        Rational lv = exprEval(l);
        Rational rv = exprEval(r);
        if ((op == OP_ADD)) {
            return new Rational{num = ((lv.num * rv.denom) + (lv.denom * rv.num)), denom = (lv.denom * rv.denom)};
        };
        if ((op == OP_SUB)) {
            return new Rational{num = ((lv.num * rv.denom) - (lv.denom * rv.num)), denom = (lv.denom * rv.denom)};
        };
        if ((op == OP_MUL)) {
            return new Rational{num = (lv.num * rv.num), denom = (lv.denom * rv.denom)};
        };
        return new Rational{num = (lv.num * rv.denom), denom = (lv.denom * rv.num)};
    }

    static string binString(long op, object l, object r) {
        string ls = exprString(l);
        string rs = exprString(r);
        string opstr = "";
        if ((op == OP_ADD)) {
            opstr = " + ";
        } else {
            if ((op == OP_SUB)) {
                opstr = " - ";
            } else {
                if ((op == OP_MUL)) {
                    opstr = " * ";
                } else {
                    opstr = " / ";
                }
            }
        };
        return (((("(" + ls) + opstr) + rs) + ")");
    }

    static object newNum(long n) {
        return new Num{value = new Rational{num = n, denom = 1}};
    }

    static Rational exprEval(object x) {
        return ((Func<Rational>)(() => { var __t = x; if (__t is Num _p0) { var v = _p0.value; return v; } else if (__t is Bin _p1) { var op = _p1.op; var l = _p1.left; var r = _p1.right; return binEval(op, l, r); } return default(Rational); }))();
    }

    static string exprString(object x) {
        return ((Func<string>)(() => { var __t = x; if (__t is Num _p0) { var v = _p0.value; return (v.num).ToString(); } else if (__t is Bin _p1) { var op = _p1.op; var l = _p1.left; var r = _p1.right; return binString(op, l, r); } return default(string); }))();
    }

    static bool solve(object[] xs) {
        if ((xs.Length == 1)) {
            Rational f = exprEval(((dynamic)xs)[0]);
            if (((f.denom != 0) && (f.num == (f.denom * goal)))) {
                Console.WriteLine(_fmtTop(exprString(((dynamic)xs)[0])));
                return true;
            }
            return false;
        };
        long i = 0;
        while ((i < xs.Length)) {
            long j = (i + 1);
            while ((j < xs.Length)) {
                object[] rest = new object[]{};
                long k = 0;
                while ((k < xs.Length)) {
                    if (((k != i) && (k != j))) {
                        rest = (Enumerable.ToArray(Enumerable.Append(rest, (object)((dynamic)xs)[k])));
                    }
                    k = (k + 1);
                }
                var a = ((dynamic)xs)[i];
                var b = ((dynamic)xs)[j];
                Bin node = new Bin{op = OP_ADD, left = a, right = b};
                foreach (var op_0 in new long[]{OP_ADD, OP_SUB, OP_MUL, OP_DIV}) {
                    node = new Bin{op = op_0, left = a, right = b};
                    if (solve((Enumerable.ToArray(Enumerable.Append(rest, (object)node))))) {
                        return true;
                    }
                }
                node = new Bin{op = OP_SUB, left = b, right = a};
                if (solve((Enumerable.ToArray(Enumerable.Append(rest, (object)node))))) {
                    return true;
                }
                node = new Bin{op = OP_DIV, left = b, right = a};
                if (solve((Enumerable.ToArray(Enumerable.Append(rest, (object)node))))) {
                    return true;
                }
                j = (j + 1);
            }
            i = (i + 1);
        };
        return false;
    }

    static void main() {
        long iter = 0;
        while ((iter < 10)) {
            object[] cards = new object[]{};
            long i = 0;
            while ((i < n_cards)) {
                long n = ((_now() % (digit_range - 1)) + 1);
                cards = (Enumerable.ToArray(Enumerable.Append(cards, (object)newNum(n))));
                Console.WriteLine(_fmtTop((" " + (n).ToString())));
                i = (i + 1);
            }
            Console.WriteLine(_fmtTop(":  "));
            if ((!solve(cards))) {
                Console.WriteLine(_fmtTop("No solution"));
            }
            iter = (iter + 1);
        };
    }

    static void Main() {
        {
            var __memStart = _mem();
            var __start = _now();
            main();
            var __end = _now();
            var __memEnd = _mem();
            var __dur = (__end - __start);
            var __memDiff = __memEnd - __memStart;
            Console.WriteLine(JsonSerializer.Serialize(new SortedDictionary<string, object>{{"name", "main"}, {"duration_us", __dur}, {"memory_bytes", __memDiff}}, new JsonSerializerOptions{ WriteIndented = true }));
        }
    }
}
