// Generated by Mochi 0.10.38 on 2025-07-24 00:46 UTC
using System;
using System.Linq;

struct Rational {
    public int num;
    public int denom;
    public override string ToString() => $"Rational {{num = {num}, denom = {denom}}}";
}
struct Num {
    public Rational value;
    public override string ToString() => $"Num {{value = {value}}}";
}
struct Bin {
    public int op;
    public object left;
    public object right;
    public override string ToString() => $"Bin {{op = {op}, left = {left}, right = {right}}}";
}
class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static int _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = (nowSeed*1664525 + 1013904223) % 2147483647;
            return (int)nowSeed;
        }
        return (int)(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() % int.MaxValue);
    }
    static int OP_ADD = 1;
    static int OP_SUB = 2;
    static int OP_MUL = 3;
    static int OP_DIV = 4;
    static int n_cards = 4;
    static int goal = 24;
    static int digit_range = 9;
    static Rational binEval(int op, object l, object r) {
        Rational lv = exprEval(l);
        Rational rv = exprEval(r);
        if ((op == OP_ADD)) {
            return new Rational{num = ((lv.num * rv.denom) + (lv.denom * rv.num)), denom = (lv.denom * rv.denom)};
        };
        if ((op == OP_SUB)) {
            return new Rational{num = ((lv.num * rv.denom) - (lv.denom * rv.num)), denom = (lv.denom * rv.denom)};
        };
        if ((op == OP_MUL)) {
            return new Rational{num = (lv.num * rv.num), denom = (lv.denom * rv.denom)};
        };
        return new Rational{num = (lv.num * rv.denom), denom = (lv.denom * rv.num)};
    }

    static string binString(int op, object l, object r) {
        string ls = exprString(l);
        string rs = exprString(r);
        string opstr = "";
        if ((op == OP_ADD)) {
            opstr = " + ";
        } else {
            if ((op == OP_SUB)) {
                opstr = " - ";
            } else {
                if ((op == OP_MUL)) {
                    opstr = " * ";
                } else {
                    opstr = " / ";
                }
            }
        };
        return (((("(" + ls) + opstr) + rs) + ")");
    }

    static object newNum(int n) {
        return new Num{value = new Rational{num = n, denom = 1}};
    }

    static Rational exprEval(object x) {
        return ((Func<Rational>)(() => { var __t = x; if (__t is Num _p0) { var v = _p0.value; return v; } else if (__t is Bin _p1) { var op = _p1.op; var l = _p1.left; var r = _p1.right; return binEval(op, l, r); } return default(Rational); }))();
    }

    static string exprString(object x) {
        return ((Func<string>)(() => { var __t = x; if (__t is Num _p0) { var v = _p0.value; return v.num.ToString(); } else if (__t is Bin _p1) { var op = _p1.op; var l = _p1.left; var r = _p1.right; return binString(op, l, r); } return default(string); }))();
    }

    static bool solve(object[] xs) {
        if ((xs.Length == 1)) {
            Rational f = exprEval(xs[0]);
            if (((f.denom != 0) && (f.num == (f.denom * goal)))) {
                Console.WriteLine(exprString(xs[0]));
                return true;
            }
            return false;
        };
        int i = 0;
        while ((i < xs.Length)) {
            int j = (i + 1);
            while ((j < xs.Length)) {
                object[] rest = new object[]{};
                int k = 0;
                while ((k < xs.Length)) {
                    if (((k != i) && (k != j))) {
                        rest = (rest.Append(xs[k]).ToArray());
                    }
                    k = (k + 1);
                }
                var a = xs[i];
                var b = xs[j];
                Bin node = new Bin{op = OP_ADD, left = a, right = b};
                foreach (var op in new int[]{OP_ADD, OP_SUB, OP_MUL, OP_DIV}) {
                    node = new Bin{op = op, left = a, right = b};
                    if (solve((rest.Append(node).ToArray()))) {
                        return true;
                    }
                }
                node = new Bin{op = OP_SUB, left = b, right = a};
                if (solve((rest.Append(node).ToArray()))) {
                    return true;
                }
                node = new Bin{op = OP_DIV, left = b, right = a};
                if (solve((rest.Append(node).ToArray()))) {
                    return true;
                }
                j = (j + 1);
            }
            i = (i + 1);
        };
        return false;
    }

    static void main() {
        int iter = 0;
        while ((iter < 10)) {
            object[] cards = new object[]{};
            int i = 0;
            while ((i < n_cards)) {
                int n = ((_now() % (digit_range - 1)) + 1);
                cards = (cards.Append(newNum(n)).ToArray());
                Console.WriteLine((" " + n.ToString()));
                i = (i + 1);
            }
            Console.WriteLine(":  ");
            if ((!solve(cards))) {
                Console.WriteLine("No solution");
            }
            iter = (iter + 1);
        };
    }

    static void Main() {
        main();
    }
}
