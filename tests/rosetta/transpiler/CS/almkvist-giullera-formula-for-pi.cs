// Generated by Mochi 0.10.39 on 2025-07-25 00:21 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

class Program {
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is bool b) return b ? "1" : "0";
        return Convert.ToString(v);
    }
    static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        return _fmt(v);
    }
    static long[] bigTrim(long[] a) {
        int n = a.Length;
        while (((n > 1) && (a[(n - 1)] == 0))) {
            a = a.Skip((int)(0)).Take((int)(((n - 1) - 0))).ToArray();
            n = (n - 1);
        };
        return a;
    }

    static long[] bigFromInt(long x) {
        if ((x == 0)) {
            return new long[]{0};
        };
        long[] digits = new long[]{};
        long n = x;
        while ((n > 0)) {
            digits = (digits.Append((n % 10)).ToArray());
            n = (n / 10);
        };
        return digits;
    }

    static long bigCmp(long[] a, long[] b) {
        if ((a.Length > b.Length)) {
            return 1;
        };
        if ((a.Length < b.Length)) {
            return -1;
        };
        long i = (a.Length - 1);
        while ((i >= 0)) {
            if ((a[i] > b[i])) {
                return 1;
            }
            if ((a[i] < b[i])) {
                return -1;
            }
            i = (i - 1);
        };
        return 0;
    }

    static long[] bigAdd(long[] a, long[] b) {
        long[] res = new long[]{};
        long carry = 0;
        long i = 0;
        while ((((i < a.Length) || (i < b.Length)) || (carry > 0))) {
            long av = 0;
            if ((i < a.Length)) {
                av = a[i];
            }
            long bv = 0;
            if ((i < b.Length)) {
                bv = b[i];
            }
            long s = ((av + bv) + carry);
            res = (res.Append((s % 10)).ToArray());
            carry = (s / 10);
            i = (i + 1);
        };
        return bigTrim(res);
    }

    static long[] bigSub(long[] a, long[] b) {
        long[] res = new long[]{};
        long borrow = 0;
        long i = 0;
        while ((i < a.Length)) {
            long av = a[i];
            long bv = 0;
            if ((i < b.Length)) {
                bv = b[i];
            }
            long diff = ((av - bv) - borrow);
            if ((diff < 0)) {
                diff = (diff + 10);
                borrow = 1;
            } else {
                borrow = 0;
            }
            res = (res.Append(diff).ToArray());
            i = (i + 1);
        };
        return bigTrim(res);
    }

    static long[] bigMulSmall(long[] a, long m) {
        if ((m == 0)) {
            return new long[]{0};
        };
        long[] res = new long[]{};
        long carry = 0;
        long i = 0;
        while ((i < a.Length)) {
            long prod = ((a[i] * m) + carry);
            res = (res.Append((prod % 10)).ToArray());
            carry = (prod / 10);
            i = (i + 1);
        };
        while ((carry > 0)) {
            res = (res.Append((carry % 10)).ToArray());
            carry = (carry / 10);
        };
        return bigTrim(res);
    }

    static long[] bigMulBig(long[] a, long[] b) {
        long[] res = new long[]{};
        long i = 0;
        while ((i < (a.Length + b.Length))) {
            res = (res.Append(0).ToArray());
            i = (i + 1);
        };
        i = 0;
        while ((i < a.Length)) {
            long carry = 0;
            long j = 0;
            while ((j < b.Length)) {
                long idx = (i + j);
                long prod = ((res[idx] + (a[i] * b[j])) + carry);
                res[idx] = (prod % 10);
                carry = (prod / 10);
                j = (j + 1);
            }
            long idx_0 = (i + b.Length);
            while ((carry > 0)) {
                long prod_1 = (res[idx_0] + carry);
                res[idx_0] = (prod_1 % 10);
                carry = (prod_1 / 10);
                idx_0 = (idx_0 + 1);
            }
            i = (i + 1);
        };
        return bigTrim(res);
    }

    static long[] bigMulPow10(long[] a, long k) {
        long i = 0;
        while ((i < k)) {
            a = (new long[]{0}.Concat(a).ToArray());
            i = (i + 1);
        };
        return a;
    }

    static long[] bigDivSmall(long[] a, long m) {
        long[] res = new long[]{};
        long rem = 0;
        long i = (a.Length - 1);
        while ((i >= 0)) {
            long cur = ((rem * 10) + a[i]);
            long q = (cur / m);
            rem = (cur % m);
            res = (new long[]{q}.Concat(res).ToArray());
            i = (i - 1);
        };
        return bigTrim(res);
    }

    static string bigToString(long[] a) {
        string s = "";
        long i = (a.Length - 1);
        while ((i >= 0)) {
            s = (s + (a[i]).ToString());
            i = (i - 1);
        };
        return s;
    }

    static string repeat(string ch, long n) {
        string s = "";
        long i = 0;
        while ((i < n)) {
            s = (s + ch);
            i = (i + 1);
        };
        return s;
    }

    static long[] sortInts(long[] xs) {
        long[] res = new long[]{};
        long[] tmp = xs;
        while ((tmp.Length > 0)) {
            long min = tmp[0];
            long idx = 0;
            long i = 1;
            while ((i < tmp.Length)) {
                if ((tmp[i] < min)) {
                    min = tmp[i];
                    idx = i;
                }
                i = (i + 1);
            }
            res = (res.Concat(new long[]{min}).ToArray());
            long[] _out = new long[]{};
            long j = 0;
            while ((j < tmp.Length)) {
                if ((j != idx)) {
                    _out = (_out + new long[]{tmp[j]});
                }
                j = (j + 1);
            }
            tmp = _out;
        };
        return res;
    }

    static long[] primesUpTo(long n) {
        bool[] sieve = new bool[]{};
        long i = 0;
        while ((i <= n)) {
            sieve = (sieve.Append(true).ToArray());
            i = (i + 1);
        };
        long p = 2;
        while (((p * p) <= n)) {
            if (sieve[p]) {
                long m = (p * p);
                while ((m <= n)) {
                    sieve[m] = false;
                    m = (m + p);
                }
            }
            p = (p + 1);
        };
        long[] res = new long[]{};
        long x = 2;
        while ((x <= n)) {
            if (sieve[x]) {
                res = (res.Append(x).ToArray());
            }
            x = (x + 1);
        };
        return res;
    }

    static Dictionary<string, long> factorialExp(long n, long[] primes) {
        Dictionary<string, long> m = new Dictionary<string, long>{};
        foreach (var p_0 in primes) {
            if ((p_0 > n)) {
                break;
            }
            long t = n;
            long e = 0;
            while ((t > 0)) {
                t = (t / p_0);
                e = (e + t);
            }
            m[(p_0).ToString()] = e;
        };
        return m;
    }

    static Dictionary<string, long> factorSmall(long x, long[] primes) {
        Dictionary<string, long> f = new Dictionary<string, long>{};
        long n = x;
        foreach (var p_0 in primes) {
            if (((p_0 * p_0) > n)) {
                break;
            }
            long c = 0;
            while (((n % p_0) == 0)) {
                c = (c + 1);
                n = (n / p_0);
            }
            if ((c > 0)) {
                f[(p_0).ToString()] = c;
            }
        };
        if ((n > 1)) {
            f[(n).ToString()] = ((f.ContainsKey((n).ToString()) ? f[(n).ToString()] : 0) + 1);
        };
        return f;
    }

    static long[] computeIP(long n, long[] primes) {
        Dictionary<string, long> exps = factorialExp((6 * n), primes);
        Dictionary<string, long> fn = factorialExp(n, primes);
        foreach (var k_0 in fn.Keys) {
            exps[k_0] = ((exps.ContainsKey(k_0) ? exps[k_0] : 0) - (6 * fn[k_0]));
        };
        exps["2"] = ((exps.ContainsKey("2") ? exps["2"] : 0) + 5);
        long t2 = ((((532 * n) * n) + (126 * n)) + 9);
        Dictionary<string, long> ft2 = factorSmall(t2, primes);
        foreach (var k_1 in ft2.Keys) {
            exps[k_1] = ((exps.ContainsKey(k_1) ? exps[k_1] : 0) + ft2[k_1]);
        };
        exps["3"] = ((exps.ContainsKey("3") ? exps["3"] : 0) - 1);
        long[] keys = new long[]{};
        foreach (var k_2 in exps.Keys) {
            keys = (keys.Append(Convert.ToInt32(k_2)).ToArray());
        };
        keys = sortInts(keys);
        long[] res = bigFromInt(1);
        foreach (var p_3 in keys) {
            long e = exps[(p_3).ToString()];
            long i = 0;
            while ((i < e)) {
                res = bigMulSmall(res, p_3);
                i = (i + 1);
            }
        };
        return res;
    }

    static string formatTerm(long[] ip, long pw) {
        string s = bigToString(ip);
        if ((pw >= s.Length)) {
            string frac = (repeat("0", (pw - s.Length)) + s);
            if ((frac.Length < 33)) {
                frac = (frac + repeat("0", (33 - frac.Length)));
            }
            return ("0." + frac.Substring(0, (33 - 0)));
        };
        string intpart = s.Substring(0, ((s.Length - pw) - 0));
        string frac_0 = s.Substring((s.Length - pw), (s.Length - (s.Length - pw)));
        if ((frac_0.Length < 33)) {
            frac_0 = (frac_0 + repeat("0", (33 - frac_0.Length)));
        };
        return ((intpart + ".") + frac_0.Substring(0, (33 - 0)));
    }

    static long[] bigAbsDiff(long[] a, long[] b) {
        if ((bigCmp(a, b) >= 0)) {
            return bigSub(a, b);
        };
        return bigSub(b, a);
    }

    static void main() {
        long[] primes = primesUpTo(2000);
        Console.WriteLine(_fmtTop("N                               Integer Portion  Pow  Nth Term (33 dp)"));
        string line = repeat("-", 89);
        Console.WriteLine(_fmtTop(line));
        long[] sum = bigFromInt(0);
        long[] prev = bigFromInt(0);
        long denomPow = 0;
        long n = 0;
        while (true) {
            long[] ip = computeIP(n, primes);
            long pw = ((6 * n) + 3);
            if ((pw > denomPow)) {
                sum = bigMulPow10(sum, (pw - denomPow));
                prev = bigMulPow10(prev, (pw - denomPow));
                denomPow = pw;
            }
            if ((n < 10)) {
                string termStr = formatTerm(ip, pw);
                string ipStr = bigToString(ip);
                while ((ipStr.Length < 44)) {
                    ipStr = (" " + ipStr);
                }
                string pwStr = (-pw).ToString();
                while ((pwStr.Length < 3)) {
                    pwStr = (" " + pwStr);
                }
                string padTerm = termStr;
                while ((padTerm.Length < 35)) {
                    padTerm = (padTerm + " ");
                }
                Console.WriteLine(_fmtTop((((((((n).ToString() + "  ") + ipStr) + "  ") + pwStr) + "  ") + padTerm)));
            }
            sum = bigAdd(sum, ip);
            long[] diff = bigAbsDiff(sum, prev);
            if (((denomPow >= 70) && (bigCmp(diff, bigMulPow10(bigFromInt(1), (denomPow - 70))) < 0))) {
                break;
            }
            prev = sum;
            n = (n + 1);
        };
        long precision = 70;
        long[] target = bigMulPow10(bigFromInt(1), (denomPow + (2 * precision)));
        long[] low = bigFromInt(0);
        long[] high = bigMulPow10(bigFromInt(1), (precision + 1));
        while ((bigCmp(low, bigSub(high, bigFromInt(1))) < 0)) {
            long[] mid = bigDivSmall(bigAdd(low, high), 2);
            long[] prod = bigMulBig(bigMulBig(mid, mid), sum);
            if ((bigCmp(prod, target) <= 0)) {
                low = mid;
            } else {
                high = bigSub(mid, bigFromInt(1));
            }
        };
        long[] piInt = low;
        string piStr = bigToString(piInt);
        if ((piStr.Length <= precision)) {
            piStr = (repeat("0", ((precision - piStr.Length) + 1)) + piStr);
        };
        string _out = ((piStr.Substring(0, ((piStr.Length - precision) - 0)) + ".") + piStr.Substring((piStr.Length - precision), (piStr.Length - (piStr.Length - precision))));
        Console.WriteLine(_fmtTop(""));
        Console.WriteLine(_fmtTop("Pi to 70 decimal places is:"));
        Console.WriteLine(_fmtTop(_out));
    }

    static void Main() {
        main();
    }
}
