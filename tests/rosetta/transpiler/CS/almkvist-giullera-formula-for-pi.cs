// Generated by Mochi 0.10.40 on 2025-07-25 20:19 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Collections;

class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static long _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = unchecked(nowSeed * 1664525 + 1013904223);
            nowSeed %= 9223372036854775783L;
            if (nowSeed < 0) nowSeed += 9223372036854775783L;
            return nowSeed;
        }
        return DateTime.UtcNow.Ticks / 100;
    }
    static long _mem() {
        return GC.GetTotalMemory(false);
    }
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is bool b) return b ? "1" : "0";
        return Convert.ToString(v);
    }
    static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        return _fmt(v);
    }
    static long[] bigTrim(long[] a) {
        int n_0 = a.Length;
        while (((n_0 > 1) && (a[(int)((n_0 - 1))] == 0))) {
            a = a.Skip((int)(0)).Take((int)(((n_0 - 1) - 0))).ToArray();
            n_0 = (n_0 - 1);
        };
        return a;
    }

    static long[] bigFromInt(long x) {
        if ((x == 0)) {
            return new long[]{0};
        };
        long[] digits_1 = new long[]{};
        long n_2 = x;
        while ((n_2 > 0)) {
            digits_1 = (Enumerable.ToArray(Enumerable.Append(digits_1, (n_2 % 10))));
            n_2 = (n_2 / 10);
        };
        return digits_1;
    }

    static long bigCmp(long[] a, long[] b) {
        if ((a.Length > b.Length)) {
            return 1;
        };
        if ((a.Length < b.Length)) {
            return -1;
        };
        long i_3 = (a.Length - 1);
        while ((i_3 >= 0)) {
            if ((a[(int)(i_3)] > b[(int)(i_3)])) {
                return 1;
            }
            if ((a[(int)(i_3)] < b[(int)(i_3)])) {
                return -1;
            }
            i_3 = (i_3 - 1);
        };
        return 0;
    }

    static long[] bigAdd(long[] a, long[] b) {
        long[] res_4 = new long[]{};
        long carry_5 = 0;
        long i_6 = 0;
        while ((((i_6 < a.Length) || (i_6 < b.Length)) || (carry_5 > 0))) {
            long av_7 = 0;
            if ((i_6 < a.Length)) {
                av_7 = a[(int)(i_6)];
            }
            long bv_8 = 0;
            if ((i_6 < b.Length)) {
                bv_8 = b[(int)(i_6)];
            }
            long s_9 = ((av_7 + bv_8) + carry_5);
            res_4 = (Enumerable.ToArray(Enumerable.Append(res_4, (s_9 % 10))));
            carry_5 = (s_9 / 10);
            i_6 = (i_6 + 1);
        };
        return bigTrim(res_4);
    }

    static long[] bigSub(long[] a, long[] b) {
        long[] res_10 = new long[]{};
        long borrow_11 = 0;
        long i_12 = 0;
        while ((i_12 < a.Length)) {
            long av_13 = a[(int)(i_12)];
            long bv_14 = 0;
            if ((i_12 < b.Length)) {
                bv_14 = b[(int)(i_12)];
            }
            long diff_15 = ((av_13 - bv_14) - borrow_11);
            if ((diff_15 < 0)) {
                diff_15 = (diff_15 + 10);
                borrow_11 = 1;
            } else {
                borrow_11 = 0;
            }
            res_10 = (Enumerable.ToArray(Enumerable.Append(res_10, diff_15)));
            i_12 = (i_12 + 1);
        };
        return bigTrim(res_10);
    }

    static long[] bigMulSmall(long[] a, long m) {
        if ((m == 0)) {
            return new long[]{0};
        };
        long[] res_16 = new long[]{};
        long carry_17 = 0;
        long i_18 = 0;
        while ((i_18 < a.Length)) {
            long prod_19 = ((a[(int)(i_18)] * m) + carry_17);
            res_16 = (Enumerable.ToArray(Enumerable.Append(res_16, (prod_19 % 10))));
            carry_17 = (prod_19 / 10);
            i_18 = (i_18 + 1);
        };
        while ((carry_17 > 0)) {
            res_16 = (Enumerable.ToArray(Enumerable.Append(res_16, (carry_17 % 10))));
            carry_17 = (carry_17 / 10);
        };
        return bigTrim(res_16);
    }

    static long[] bigMulBig(long[] a, long[] b) {
        long[] res_20 = new long[]{};
        long i_21 = 0;
        while ((i_21 < (a.Length + b.Length))) {
            res_20 = (Enumerable.ToArray(Enumerable.Append(res_20, 0)));
            i_21 = (i_21 + 1);
        };
        i_21 = 0;
        while ((i_21 < a.Length)) {
            long carry_22 = 0;
            long j_23 = 0;
            while ((j_23 < b.Length)) {
                long idx_24 = (i_21 + j_23);
                long prod_25 = ((res_20[(int)(idx_24)] + (a[(int)(i_21)] * b[(int)(j_23)])) + carry_22);
                res_20[idx_24] = (prod_25 % 10);
                carry_22 = (prod_25 / 10);
                j_23 = (j_23 + 1);
            }
            long idx_26 = (i_21 + b.Length);
            while ((carry_22 > 0)) {
                long prod_27 = (res_20[(int)(idx_26)] + carry_22);
                res_20[idx_26] = (prod_27 % 10);
                carry_22 = (prod_27 / 10);
                idx_26 = (idx_26 + 1);
            }
            i_21 = (i_21 + 1);
        };
        return bigTrim(res_20);
    }

    static long[] bigMulPow10(long[] a, long k) {
        long i_28 = 0;
        while ((i_28 < k)) {
            a = (new long[]{0}.Concat(a).ToArray());
            i_28 = (i_28 + 1);
        };
        return a;
    }

    static long[] bigDivSmall(long[] a, long m) {
        long[] res_29 = new long[]{};
        long rem_30 = 0;
        long i_31 = (a.Length - 1);
        while ((i_31 >= 0)) {
            long cur_32 = ((rem_30 * 10) + a[(int)(i_31)]);
            long q_33 = (cur_32 / m);
            rem_30 = (cur_32 % m);
            res_29 = (new long[]{q_33}.Concat(res_29).ToArray());
            i_31 = (i_31 - 1);
        };
        return bigTrim(res_29);
    }

    static string bigToString(long[] a) {
        string s_34 = "";
        long i_35 = (a.Length - 1);
        while ((i_35 >= 0)) {
            s_34 = (s_34 + (a[(int)(i_35)]).ToString());
            i_35 = (i_35 - 1);
        };
        return s_34;
    }

    static string repeat(string ch, long n) {
        string s_36 = "";
        long i_37 = 0;
        while ((i_37 < n)) {
            s_36 = (s_36 + ch);
            i_37 = (i_37 + 1);
        };
        return s_36;
    }

    static long[] sortInts(long[] xs) {
        long[] res_38 = new long[]{};
        long[] tmp_39 = xs;
        while ((tmp_39.Length > 0)) {
            long min_40 = tmp_39[(int)(0)];
            long idx_41 = 0;
            long i_42 = 1;
            while ((i_42 < tmp_39.Length)) {
                if ((tmp_39[(int)(i_42)] < min_40)) {
                    min_40 = tmp_39[(int)(i_42)];
                    idx_41 = i_42;
                }
                i_42 = (i_42 + 1);
            }
            res_38 = (res_38.Concat(new long[]{min_40}).ToArray());
            long[] out_43 = new long[]{};
            long j_44 = 0;
            while ((j_44 < tmp_39.Length)) {
                if ((j_44 != idx_41)) {
                    out_43 = (out_43.Concat(new long[]{tmp_39[(int)(j_44)]}).ToArray());
                }
                j_44 = (j_44 + 1);
            }
            tmp_39 = out_43;
        };
        return res_38;
    }

    static long[] primesUpTo(long n) {
        bool[] sieve_45 = new bool[]{};
        long i_46 = 0;
        while ((i_46 <= n)) {
            sieve_45 = (Enumerable.ToArray(Enumerable.Append(sieve_45, true)));
            i_46 = (i_46 + 1);
        };
        long p_47 = 2;
        while (((p_47 * p_47) <= n)) {
            if (sieve_45[(int)(p_47)]) {
                long m_48 = (p_47 * p_47);
                while ((m_48 <= n)) {
                    sieve_45[m_48] = false;
                    m_48 = (m_48 + p_47);
                }
            }
            p_47 = (p_47 + 1);
        };
        long[] res_49 = new long[]{};
        long x_50 = 2;
        while ((x_50 <= n)) {
            if (sieve_45[(int)(x_50)]) {
                res_49 = (Enumerable.ToArray(Enumerable.Append(res_49, x_50)));
            }
            x_50 = (x_50 + 1);
        };
        return res_49;
    }

    static Dictionary<string, long> factorialExp(long n, long[] primes) {
        Dictionary<string, long> m_51 = new Dictionary<string, long>{};
        foreach (var p_52 in primes) {
            if ((p_52 > n)) {
                break;
            }
            long t_53 = n;
            long e_54 = 0;
            while ((t_53 > 0)) {
                t_53 = (t_53 / p_52);
                e_54 = (e_54 + t_53);
            }
            m_51[(p_52).ToString()] = e_54;
        };
        return m_51;
    }

    static Dictionary<string, long> factorSmall(long x, long[] primes) {
        Dictionary<string, long> f_55 = new Dictionary<string, long>{};
        long n_56 = x;
        foreach (var p_57 in primes) {
            if (((p_57 * p_57) > n_56)) {
                break;
            }
            long c_58 = 0;
            while (((n_56 % p_57) == 0)) {
                c_58 = (c_58 + 1);
                n_56 = (n_56 / p_57);
            }
            if ((c_58 > 0)) {
                f_55[(p_57).ToString()] = c_58;
            }
        };
        if ((n_56 > 1)) {
            f_55[(n_56).ToString()] = ((f_55.ContainsKey((n_56).ToString()) ? f_55[(n_56).ToString()] : 0) + 1);
        };
        return f_55;
    }

    static long[] computeIP(long n, long[] primes) {
        Dictionary<string, long> exps_59 = factorialExp((6 * n), primes);
        Dictionary<string, long> fn_60 = factorialExp(n, primes);
        foreach (var k_61 in fn_60.Keys) {
            exps_59[k_61] = ((exps_59.ContainsKey(k_61) ? exps_59[k_61] : 0) - (6 * fn_60[k_61]));
        };
        exps_59["2"] = ((exps_59.ContainsKey("2") ? exps_59["2"] : 0) + 5);
        long t2_62 = ((((532 * n) * n) + (126 * n)) + 9);
        Dictionary<string, long> ft2_63 = factorSmall(t2_62, primes);
        foreach (var k_64 in ft2_63.Keys) {
            exps_59[k_64] = ((exps_59.ContainsKey(k_64) ? exps_59[k_64] : 0) + ft2_63[k_64]);
        };
        exps_59["3"] = ((exps_59.ContainsKey("3") ? exps_59["3"] : 0) - 1);
        long[] keys_65 = new long[]{};
        foreach (var k_66 in exps_59.Keys) {
            keys_65 = (Enumerable.ToArray(Enumerable.Append(keys_65, Convert.ToInt64(k_66))));
        };
        keys_65 = sortInts(keys_65);
        long[] res_67 = bigFromInt(1);
        foreach (var p_68 in keys_65) {
            long e_69 = exps_59[(p_68).ToString()];
            long i_70 = 0;
            while ((i_70 < e_69)) {
                res_67 = bigMulSmall(res_67, p_68);
                i_70 = (i_70 + 1);
            }
        };
        return res_67;
    }

    static string formatTerm(long[] ip, long pw) {
        string s_71 = bigToString(ip);
        if ((pw >= s_71.Length)) {
            string frac_72 = (repeat("0", (((dynamic)pw) - ((dynamic)s_71.Length))) + s_71);
            if ((frac_72.Length < 33)) {
                frac_72 = (frac_72 + repeat("0", (((dynamic)33) - ((dynamic)frac_72.Length))));
            }
            return ("0." + frac_72.Substring((int)(0), (int)(33 - 0)));
        };
        string intpart_73 = s_71.Substring((int)(0), (int)((((dynamic)s_71.Length) - ((dynamic)pw)) - 0));
        string frac_74 = s_71.Substring((int)((((dynamic)s_71.Length) - ((dynamic)pw))), (int)(s_71.Length - (((dynamic)s_71.Length) - ((dynamic)pw))));
        if ((frac_74.Length < 33)) {
            frac_74 = (frac_74 + repeat("0", (((dynamic)33) - ((dynamic)frac_74.Length))));
        };
        return ((intpart_73 + ".") + frac_74.Substring((int)(0), (int)(33 - 0)));
    }

    static long[] bigAbsDiff(long[] a, long[] b) {
        if ((bigCmp(a, b) >= 0)) {
            return bigSub(a, b);
        };
        return bigSub(b, a);
    }

    static void main() {
        long[] primes_75 = primesUpTo(2000);
        Console.WriteLine(_fmtTop("N                               Integer Portion  Pow  Nth Term (33 dp)"));
        string line_76 = repeat("-", 89);
        Console.WriteLine(_fmtTop(line_76));
        long[] sum_77 = bigFromInt(0);
        long[] prev_78 = bigFromInt(0);
        long denomPow_79 = 0;
        long n_80 = 0;
        while (true) {
            long[] ip_81 = computeIP(n_80, primes_75);
            long pw_82 = ((6 * n_80) + 3);
            if ((pw_82 > denomPow_79)) {
                sum_77 = bigMulPow10(sum_77, (pw_82 - denomPow_79));
                prev_78 = bigMulPow10(prev_78, (pw_82 - denomPow_79));
                denomPow_79 = pw_82;
            }
            if ((n_80 < 10)) {
                string termStr_83 = formatTerm(ip_81, pw_82);
                string ipStr_84 = bigToString(ip_81);
                while ((ipStr_84.Length < 44)) {
                    ipStr_84 = (" " + ipStr_84);
                }
                string pwStr_85 = (-pw_82).ToString();
                while ((pwStr_85.Length < 3)) {
                    pwStr_85 = (" " + pwStr_85);
                }
                string padTerm_86 = termStr_83;
                while ((padTerm_86.Length < 35)) {
                    padTerm_86 = (padTerm_86 + " ");
                }
                Console.WriteLine(_fmtTop((((((((n_80).ToString() + "  ") + ipStr_84) + "  ") + pwStr_85) + "  ") + padTerm_86)));
            }
            sum_77 = bigAdd(sum_77, ip_81);
            long[] diff_87 = bigAbsDiff(sum_77, prev_78);
            if (((denomPow_79 >= 70) && (bigCmp(diff_87, bigMulPow10(bigFromInt(1), (denomPow_79 - 70))) < 0))) {
                break;
            }
            prev_78 = sum_77;
            n_80 = (n_80 + 1);
        };
        long precision_88 = 70;
        long[] target_89 = bigMulPow10(bigFromInt(1), (denomPow_79 + (2 * precision_88)));
        long[] low_90 = bigFromInt(0);
        long[] high_91 = bigMulPow10(bigFromInt(1), (precision_88 + 1));
        while ((bigCmp(low_90, bigSub(high_91, bigFromInt(1))) < 0)) {
            long[] mid_92 = bigDivSmall(bigAdd(low_90, high_91), 2);
            long[] prod_93 = bigMulBig(bigMulBig(mid_92, mid_92), sum_77);
            if ((bigCmp(prod_93, target_89) <= 0)) {
                low_90 = mid_92;
            } else {
                high_91 = bigSub(mid_92, bigFromInt(1));
            }
        };
        long[] piInt_94 = low_90;
        string piStr_95 = bigToString(piInt_94);
        if ((piStr_95.Length <= precision_88)) {
            piStr_95 = (repeat("0", ((((dynamic)precision_88) - ((dynamic)piStr_95.Length)) + 1)) + piStr_95);
        };
        string out_96 = ((piStr_95.Substring((int)(0), (int)((((dynamic)piStr_95.Length) - ((dynamic)precision_88)) - 0)) + ".") + piStr_95.Substring((int)((((dynamic)piStr_95.Length) - ((dynamic)precision_88))), (int)(piStr_95.Length - (((dynamic)piStr_95.Length) - ((dynamic)precision_88)))));
        Console.WriteLine(_fmtTop(""));
        Console.WriteLine(_fmtTop("Pi to 70 decimal places is:"));
        Console.WriteLine(_fmtTop(out_96));
    }

    static void Main() {
        {
            var __memStart = _mem();
            var __start = _now();
            main();
            var __end = _now();
            var __memEnd = _mem();
            var __dur = (__end - __start);
            var __memDiff = __memEnd - __memStart;
            Console.WriteLine(JsonSerializer.Serialize(new SortedDictionary<string, object>{{"name", "main"}, {"duration_us", __dur}, {"memory_bytes", __memDiff}}, new JsonSerializerOptions{ WriteIndented = true }));
        }
    }
}
