// Generated by Mochi 0.10.39 on 2025-07-24 15:41 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;

class Program {
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is bool b) return b ? "1" : "0";
        return Convert.ToString(v);
    }
    static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        return _fmt(v);
    }
    static int[] bigTrim(int[] a) {
        int n = a.Length;
        while (((n > 1) && (a[(n - 1)] == 0))) {
            a = a.Skip(0).Take(((n - 1) - 0)).ToArray();
            n = (n - 1);
        };
        return a;
    }

    static int[] bigFromInt(int x) {
        if ((x == 0)) {
            return new int[]{0};
        };
        int[] digits = new int[]{};
        int n = x;
        while ((n > 0)) {
            digits = (digits.Append((n % 10)).ToArray());
            n = (n / 10);
        };
        return digits;
    }

    static int bigCmp(int[] a, int[] b) {
        if ((a.Length > b.Length)) {
            return 1;
        };
        if ((a.Length < b.Length)) {
            return -1;
        };
        int i = (a.Length - 1);
        while ((i >= 0)) {
            if ((a[i] > b[i])) {
                return 1;
            }
            if ((a[i] < b[i])) {
                return -1;
            }
            i = (i - 1);
        };
        return 0;
    }

    static int[] bigAdd(int[] a, int[] b) {
        int[] res = new int[]{};
        int carry = 0;
        int i = 0;
        while ((((i < a.Length) || (i < b.Length)) || (carry > 0))) {
            int av = 0;
            if ((i < a.Length)) {
                av = a[i];
            }
            int bv = 0;
            if ((i < b.Length)) {
                bv = b[i];
            }
            var s = ((av + bv) + carry);
            res = (res.Append((s % 10)).ToArray());
            carry = (s / 10);
            i = (i + 1);
        };
        return bigTrim(res);
    }

    static int[] bigSub(int[] a, int[] b) {
        int[] res = new int[]{};
        int borrow = 0;
        int i = 0;
        while ((i < a.Length)) {
            int av = a[i];
            int bv = 0;
            if ((i < b.Length)) {
                bv = b[i];
            }
            var diff = ((av - bv) - borrow);
            if ((diff < 0)) {
                diff = (diff + 10);
                borrow = 1;
            } else {
                borrow = 0;
            }
            res = (res.Append(diff).ToArray());
            i = (i + 1);
        };
        return bigTrim(res);
    }

    static int[] bigMulSmall(int[] a, int m) {
        if ((m == 0)) {
            return new int[]{0};
        };
        int[] res = new int[]{};
        int carry = 0;
        int i = 0;
        while ((i < a.Length)) {
            int prod = ((a[i] * m) + carry);
            res = (res.Append((prod % 10)).ToArray());
            carry = (prod / 10);
            i = (i + 1);
        };
        while ((carry > 0)) {
            res = (res.Append((carry % 10)).ToArray());
            carry = (carry / 10);
        };
        return bigTrim(res);
    }

    static int[] bigMulBig(int[] a, int[] b) {
        int[] res = new int[]{};
        int i = 0;
        while ((i < (a.Length + b.Length))) {
            res = (res.Append(0).ToArray());
            i = (i + 1);
        };
        i = 0;
        while ((i < a.Length)) {
            int carry = 0;
            int j = 0;
            while ((j < b.Length)) {
                var idx = (i + j);
                int prod = ((res[idx] + (a[i] * b[j])) + carry);
                res[idx] = (prod % 10);
                carry = (prod / 10);
                j = (j + 1);
            }
            int idx = (i + b.Length);
            while ((carry > 0)) {
                var prod = (res[idx] + carry);
                res[idx] = (prod % 10);
                carry = (prod / 10);
                idx = (idx + 1);
            }
            i = (i + 1);
        };
        return bigTrim(res);
    }

    static int[] bigMulPow10(int[] a, int k) {
        int i = 0;
        while ((i < k)) {
            a = (new int[]{0}.Concat(a).ToArray());
            i = (i + 1);
        };
        return a;
    }

    static int[] bigDivSmall(int[] a, int m) {
        int[] res = new int[]{};
        int rem = 0;
        int i = (a.Length - 1);
        while ((i >= 0)) {
            int cur = ((rem * 10) + a[i]);
            int q = (cur / m);
            rem = (cur % m);
            res = (new int[]{q} + res);
            i = (i - 1);
        };
        return bigTrim(res);
    }

    static string bigToString(int[] a) {
        string s = "";
        int i = (a.Length - 1);
        while ((i >= 0)) {
            s = (s + a[i].ToString());
            i = (i - 1);
        };
        return s;
    }

    static string repeat(string ch, int n) {
        string s = "";
        int i = 0;
        while ((i < n)) {
            s = (s + ch);
            i = (i + 1);
        };
        return s;
    }

    static int[] sortInts(int[] xs) {
        int[] res = new int[]{};
        int[] tmp = xs;
        while ((tmp.Length > 0)) {
            var min = tmp[0];
            int idx = 0;
            int i = 1;
            while ((i < tmp.Length)) {
                if ((tmp[i] < min)) {
                    min = tmp[i];
                    idx = i;
                }
                i = (i + 1);
            }
            res = (res + new int[]{min});
            int[] _out = new int[]{};
            int j = 0;
            while ((j < tmp.Length)) {
                if ((j != idx)) {
                    _out = (_out + new int[]{tmp[j]});
                }
                j = (j + 1);
            }
            tmp = _out;
        };
        return res;
    }

    static int[] primesUpTo(int n) {
        bool[] sieve = new bool[]{};
        int i = 0;
        while ((i <= n)) {
            sieve = (sieve.Append(true).ToArray());
            i = (i + 1);
        };
        int p = 2;
        while (((p * p) <= n)) {
            if (sieve[p]) {
                var m = (p * p);
                while ((m <= n)) {
                    sieve[m] = false;
                    m = (m + p);
                }
            }
            p = (p + 1);
        };
        int[] res = new int[]{};
        int x = 2;
        while ((x <= n)) {
            if (sieve[x]) {
                res = (res.Append(x).ToArray());
            }
            x = (x + 1);
        };
        return res;
    }

    static Dictionary<string, int> factorialExp(int n, int[] primes) {
        Dictionary<string, int> m = new Dictionary<string, int>{};
        foreach (var p_0 in primes) {
            if ((p_0 > n)) {
                break;
            }
            int t = n;
            int e = 0;
            while ((t > 0)) {
                t = (t / p_0);
                e = (e + t);
            }
            m[p_0.ToString()] = e;
        };
        return m;
    }

    static Dictionary<string, int> factorSmall(int x, int[] primes) {
        Dictionary<string, int> f = new Dictionary<string, int>{};
        int n = x;
        foreach (var p_1 in primes) {
            if (((p_1 * p_1) > n)) {
                break;
            }
            int c = 0;
            while (((n % p_1) == 0)) {
                c = (c + 1);
                n = (n / p_1);
            }
            if ((c > 0)) {
                f[p_1.ToString()] = c;
            }
        };
        if ((n > 1)) {
            f[n.ToString()] = (f.get(n.ToString(), 0) + 1);
        };
        return f;
    }

    static int[] computeIP(int n, int[] primes) {
        Dictionary<string, int> exps = factorialExp((6 * n), primes);
        Dictionary<string, int> fn = factorialExp(n, primes);
        foreach (var k_2 in fn) {
            exps[k_2] = (exps.get(k_2, 0) - (6 * fn[k_2]));
        };
        exps["2"] = (exps.get("2", 0) + 5);
        int t2 = ((((532 * n) * n) + (126 * n)) + 9);
        Dictionary<string, int> ft2 = factorSmall(t2, primes);
        foreach (var k_3 in ft2) {
            exps[k_3] = (exps.get(k_3, 0) + ft2[k_3]);
        };
        exps["3"] = (exps.get("3", 0) - 1);
        int[] keys = new int[]{};
        foreach (var k_4 in exps) {
            keys = (keys.Append(Convert.ToInt32(k_4)).ToArray());
        };
        keys = sortInts(keys);
        int[] res = bigFromInt(1);
        foreach (var p_5 in keys) {
            var e = exps[p_5.ToString()];
            int i = 0;
            while ((i < e)) {
                res = bigMulSmall(res, p_5);
                i = (i + 1);
            }
        };
        return res;
    }

    static string formatTerm(int[] ip, int pw) {
        string s = bigToString(ip);
        if ((pw >= s.Length)) {
            string frac = (repeat("0", (pw - s.Length)) + s);
            if ((frac.Length < 33)) {
                frac = (frac + repeat("0", (33 - frac.Length)));
            }
            return ("0." + frac.Substring(0, (33 - 0)));
        };
        string intpart = s.Substring(0, ((s.Length - pw) - 0));
        string frac = s.Substring((s.Length - pw), (s.Length - (s.Length - pw)));
        if ((frac.Length < 33)) {
            frac = (frac + repeat("0", (33 - frac.Length)));
        };
        return ((intpart + ".") + frac.Substring(0, (33 - 0)));
    }

    static int[] bigAbsDiff(int[] a, int[] b) {
        if ((bigCmp(a, b) >= 0)) {
            return bigSub(a, b);
        };
        return bigSub(b, a);
    }

    static void main() {
        int[] primes = primesUpTo(2000);
        Console.WriteLine(_fmtTop("N                               Integer Portion  Pow  Nth Term (33 dp)"));
        string line = repeat("-", 89);
        Console.WriteLine(_fmtTop(line));
        int[] sum = bigFromInt(0);
        int[] prev = bigFromInt(0);
        int denomPow = 0;
        int n = 0;
        while (true) {
            int[] ip = computeIP(n, primes);
            int pw = ((6 * n) + 3);
            if ((pw > denomPow)) {
                sum = bigMulPow10(sum, (pw - denomPow));
                prev = bigMulPow10(prev, (pw - denomPow));
                denomPow = pw;
            }
            if ((n < 10)) {
                string termStr = formatTerm(ip, pw);
                string ipStr = bigToString(ip);
                while ((ipStr.Length < 44)) {
                    ipStr = (" " + ipStr);
                }
                string pwStr = -pw.ToString();
                while ((pwStr.Length < 3)) {
                    pwStr = (" " + pwStr);
                }
                var padTerm = termStr;
                while ((padTerm.Length < 35)) {
                    padTerm = (padTerm + " ");
                }
                Console.WriteLine(_fmtTop(((((((n.ToString() + "  ") + ipStr) + "  ") + pwStr) + "  ") + padTerm)));
            }
            sum = bigAdd(sum, ip);
            int[] diff = bigAbsDiff(sum, prev);
            if (((denomPow >= 70) && (bigCmp(diff, bigMulPow10(bigFromInt(1), (denomPow - 70))) < 0))) {
                break;
            }
            prev = sum;
            n = (n + 1);
        };
        int precision = 70;
        int[] target = bigMulPow10(bigFromInt(1), (denomPow + (2 * precision)));
        int[] low = bigFromInt(0);
        int[] high = bigMulPow10(bigFromInt(1), (precision + 1));
        while ((bigCmp(low, bigSub(high, bigFromInt(1))) < 0)) {
            int[] mid = bigDivSmall(bigAdd(low, high), 2);
            int[] prod = bigMulBig(bigMulBig(mid, mid), sum);
            if ((bigCmp(prod, target) <= 0)) {
                low = mid;
            } else {
                high = bigSub(mid, bigFromInt(1));
            }
        };
        var piInt = low;
        string piStr = bigToString(piInt);
        if ((piStr.Length <= precision)) {
            piStr = (repeat("0", ((precision - piStr.Length) + 1)) + piStr);
        };
        string _out = ((piStr.Substring(0, ((piStr.Length - precision) - 0)) + ".") + piStr.Substring((piStr.Length - precision), (piStr.Length - (piStr.Length - precision))));
        Console.WriteLine(_fmtTop(""));
        Console.WriteLine(_fmtTop("Pi to 70 decimal places is:"));
        Console.WriteLine(_fmtTop(_out));
    }

    static void Main() {
        main();
    }
}
