// Generated by Mochi 0.10.40 on 2025-07-25 12:29 +0700
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.IO;
using System.Collections;

struct Board {
    public long[][] cells;
    public override string ToString() => $"Board {{cells = {cells}}}";
}
struct SpawnResult {
    public Board board;
    public bool full;
    public override string ToString() => $"SpawnResult {{board = {board}, full = {full}}}";
}
struct SlideResult {
    public long[] row;
    public long gain;
    public override string ToString() => $"SlideResult {{row = {row}, gain = {gain}}}";
}
struct MoveResult {
    public Board board;
    public long score;
    public bool moved;
    public override string ToString() => $"MoveResult {{board = {board}, score = {score}, moved = {moved}}}";
}
class Program {
    static bool seededNow = false;
    static long nowSeed = 0;
    static long _now() {
        if (!seededNow) {
            var s = Environment.GetEnvironmentVariable("MOCHI_NOW_SEED");
            if (long.TryParse(s, out var v)) {
                nowSeed = v;
                seededNow = true;
            }
        }
        if (seededNow) {
            nowSeed = unchecked(nowSeed * 1664525 + 1013904223);
            nowSeed %= 9223372036854775783L;
            if (nowSeed < 0) nowSeed += 9223372036854775783L;
            return nowSeed;
        }
        return DateTime.UtcNow.Ticks / 100;
    }
    static long _mem() {
        return GC.GetTotalMemory(false);
    }
    static string[] inputLines;
    static int inputIndex = 0;
    static string _input() {
        if (inputLines == null) {
            var path = Environment.GetEnvironmentVariable("MOCHI_INPUT_FILE");
            if (!string.IsNullOrEmpty(path) && File.Exists(path)) {
                inputLines = File.ReadAllLines(path);
            } else {
                inputLines = new string[]{};
            }
        }
        if (inputIndex < inputLines.Length) {
            return inputLines[inputIndex++];
        }
        return Console.ReadLine();
    }
    static string _fmt(object v) {
        if (v is Array a) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return "[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IDictionary d) {
            var keys = new List<string>();
            foreach (var k in d.Keys) keys.Add(k.ToString());
            keys.Sort();
            var parts = new List<string>();
            foreach (var k in keys) parts.Add(k + ":" + _fmt(d[k]));
            return "map[" + string.Join(" ", parts) + "]";
        }
        if (v is System.Collections.IEnumerable e && !(v is string)) {
            var parts = new List<string>();
            foreach (var x in e) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        if (v is bool b) return b ? "1" : "0";
        return Convert.ToString(v);
    }
    static string _fmtTop(object v) {
        if (v is Array a && a.Length > 0 && a.GetValue(0) is Array) {
            var parts = new List<string>();
            foreach (var x in a) parts.Add(_fmt(x));
            return string.Join(" ", parts);
        }
        return _fmt(v);
    }
    static long SIZE = 4;
    static Board board = newBoard();
    static SpawnResult r = spawnTile(board);
    static bool full = r.full;
    static long score = 0;
    static Board newBoard() {
        long[][] b = new long[][]{};
        long y = 0;
        while ((y < SIZE)) {
            long[] row = new long[]{};
            long x = 0;
            while ((x < SIZE)) {
                row = (Enumerable.ToArray(Enumerable.Append(row, 0)));
                x = (x + 1);
            }
            b = (Enumerable.ToArray(Enumerable.Append(b, row)));
            y = (y + 1);
        };
        return new Board{cells = b};
    }

    static SpawnResult spawnTile(Board b) {
        long[][] grid = b.cells;
        long[][] empty = new long[][]{};
        long y = 0;
        while ((y < SIZE)) {
            long x = 0;
            while ((x < SIZE)) {
                if ((grid[y][x] == 0)) {
                    empty = (Enumerable.ToArray(Enumerable.Append(empty, new long[]{x, y})));
                }
                x = (x + 1);
            }
            y = (y + 1);
        };
        if ((empty.Length == 0)) {
            return new SpawnResult{board = b, full = true};
        };
        long idx = (_now() % empty.Length);
        long[] cell = empty[idx];
        long val = 4;
        if (((_now() % 10) < 9)) {
            val = 2;
        };
        grid[cell[1]][cell[0]] = val;
        return new SpawnResult{board = new Board{cells = grid}, full = (empty.Length == 1)};
    }

    static string pad(long n) {
        string s = (n).ToString();
        long pad = (4 - s.Length);
        long i = 0;
        string _out = "";
        while ((i < pad)) {
            _out = (_out + " ");
            i = (i + 1);
        };
        return (_out + s);
    }

    static void draw(Board b, long score) {
        Console.WriteLine(_fmtTop(("Score: " + (score).ToString())));
        long y = 0;
        while ((y < SIZE)) {
            Console.WriteLine(_fmtTop("+----+----+----+----+"));
            string line = "|";
            long x = 0;
            while ((x < SIZE)) {
                long v = b.cells[y][x];
                if ((v == 0)) {
                    line = (line + "    |");
                } else {
                    line = ((line + pad(v)) + "|");
                }
                x = (x + 1);
            }
            Console.WriteLine(_fmtTop(line));
            y = (y + 1);
        };
        Console.WriteLine(_fmtTop("+----+----+----+----+"));
        Console.WriteLine(_fmtTop("W=Up S=Down A=Left D=Right Q=Quit"));
    }

    static long[] reverseRow(long[] r) {
        long[] _out = new long[]{};
        long i = (r.Length - 1);
        while ((i >= 0)) {
            _out = (Enumerable.ToArray(Enumerable.Append(_out, r[i])));
            i = (i - 1);
        };
        return _out;
    }

    static SlideResult slideLeft(long[] row) {
        long[] xs = new long[]{};
        long i = 0;
        while ((i < row.Length)) {
            if ((row[i] != 0)) {
                xs = (Enumerable.ToArray(Enumerable.Append(xs, row[i])));
            }
            i = (i + 1);
        };
        long[] res = new long[]{};
        long gain = 0;
        i = 0;
        while ((i < xs.Length)) {
            if ((((i + 1) < xs.Length) && (xs[i] == xs[(i + 1)]))) {
                long v = (xs[i] * 2);
                gain = (gain + v);
                res = (Enumerable.ToArray(Enumerable.Append(res, v)));
                i = (i + 2);
            } else {
                res = (Enumerable.ToArray(Enumerable.Append(res, xs[i])));
                i = (i + 1);
            }
        };
        while ((res.Length < SIZE)) {
            res = (Enumerable.ToArray(Enumerable.Append(res, 0)));
        };
        return new SlideResult{row = res, gain = gain};
    }

    static MoveResult moveLeft(Board b, long score) {
        long[][] grid = b.cells;
        bool moved = false;
        long y = 0;
        while ((y < SIZE)) {
            SlideResult r = slideLeft(grid[y]);
            var _new = r.row;
            score = (score + r.gain);
            long x = 0;
            while ((x < SIZE)) {
                if ((grid[y][x] != _new[x])) {
                    moved = true;
                }
                grid[y][x] = _new[x];
                x = (x + 1);
            }
            y = (y + 1);
        };
        return new MoveResult{board = new Board{cells = grid}, score = score, moved = moved};
    }

    static MoveResult moveRight(Board b, long score) {
        long[][] grid = b.cells;
        bool moved = false;
        long y = 0;
        while ((y < SIZE)) {
            long[] rev = reverseRow(grid[y]);
            SlideResult r = slideLeft(rev);
            rev = r.row;
            score = (score + r.gain);
            rev = reverseRow(rev);
            long x = 0;
            while ((x < SIZE)) {
                if ((grid[y][x] != rev[x])) {
                    moved = true;
                }
                grid[y][x] = rev[x];
                x = (x + 1);
            }
            y = (y + 1);
        };
        return new MoveResult{board = new Board{cells = grid}, score = score, moved = moved};
    }

    static long[] getCol(Board b, long x) {
        long[] col = new long[]{};
        long y = 0;
        while ((y < SIZE)) {
            col = (Enumerable.ToArray(Enumerable.Append(col, b.cells[y][x])));
            y = (y + 1);
        };
        return col;
    }

    static void setCol(Board b, long x, long[] col) {
        long[][] rows = b.cells;
        long y = 0;
        while ((y < SIZE)) {
            long[] row = rows[y];
            row[x] = col[y];
            rows[y] = row;
            y = (y + 1);
        };
        b.cells = rows;
    }

    static MoveResult moveUp(Board b, long score) {
        long[][] grid = b.cells;
        bool moved = false;
        long x = 0;
        while ((x < SIZE)) {
            long[] col = getCol(b, x);
            SlideResult r = slideLeft(col);
            var _new = r.row;
            score = (score + r.gain);
            long y = 0;
            while ((y < SIZE)) {
                if ((grid[y][x] != _new[y])) {
                    moved = true;
                }
                grid[y][x] = _new[y];
                y = (y + 1);
            }
            x = (x + 1);
        };
        return new MoveResult{board = new Board{cells = grid}, score = score, moved = moved};
    }

    static MoveResult moveDown(Board b, long score) {
        long[][] grid = b.cells;
        bool moved = false;
        long x = 0;
        while ((x < SIZE)) {
            long[] col = reverseRow(getCol(b, x));
            SlideResult r = slideLeft(col);
            col = r.row;
            score = (score + r.gain);
            col = reverseRow(col);
            long y = 0;
            while ((y < SIZE)) {
                if ((grid[y][x] != col[y])) {
                    moved = true;
                }
                grid[y][x] = col[y];
                y = (y + 1);
            }
            x = (x + 1);
        };
        return new MoveResult{board = new Board{cells = grid}, score = score, moved = moved};
    }

    static bool hasMoves(Board b) {
        long y = 0;
        while ((y < SIZE)) {
            long x = 0;
            while ((x < SIZE)) {
                if ((b.cells[y][x] == 0)) {
                    return true;
                }
                if ((((x + 1) < SIZE) && (b.cells[y][x] == b.cells[y][(x + 1)]))) {
                    return true;
                }
                if ((((y + 1) < SIZE) && (b.cells[y][x] == b.cells[(y + 1)][x]))) {
                    return true;
                }
                x = (x + 1);
            }
            y = (y + 1);
        };
        return false;
    }

    static bool has2048(Board b) {
        long y = 0;
        while ((y < SIZE)) {
            long x = 0;
            while ((x < SIZE)) {
                if ((b.cells[y][x] >= 2048)) {
                    return true;
                }
                x = (x + 1);
            }
            y = (y + 1);
        };
        return false;
    }

    static void Main() {
        {
            var __memStart = _mem();
            var __start = _now();
            board = r.board;
            r = spawnTile(board);
            board = r.board;
            full = r.full;
            draw(board, score);
            while (true) {
                Console.WriteLine(_fmtTop("Move: "));
                string cmd = _input();
                bool moved = false;
                if (((cmd == "a") || (cmd == "A"))) {
                    MoveResult m = moveLeft(board, score);
                    board = m.board;
                    score = m.score;
                    moved = m.moved;
                }
                if (((cmd == "d") || (cmd == "D"))) {
                    MoveResult m_0 = moveRight(board, score);
                    board = m_0.board;
                    score = m_0.score;
                    moved = m_0.moved;
                }
                if (((cmd == "w") || (cmd == "W"))) {
                    MoveResult m_1 = moveUp(board, score);
                    board = m_1.board;
                    score = m_1.score;
                    moved = m_1.moved;
                }
                if (((cmd == "s") || (cmd == "S"))) {
                    MoveResult m_2 = moveDown(board, score);
                    board = m_2.board;
                    score = m_2.score;
                    moved = m_2.moved;
                }
                if (((cmd == "q") || (cmd == "Q"))) {
                    break;
                }
                if (moved) {
                    SpawnResult r2 = spawnTile(board);
                    board = r2.board;
                    full = r2.full;
                    if ((full && (!hasMoves(board)))) {
                        draw(board, score);
                        Console.WriteLine(_fmtTop("Game Over"));
                        break;
                    }
                }
                draw(board, score);
                if (has2048(board)) {
                    Console.WriteLine(_fmtTop("You win!"));
                    break;
                }
                if ((!hasMoves(board))) {
                    Console.WriteLine(_fmtTop("Game Over"));
                    break;
                }
            }
            var __end = _now();
            var __memEnd = _mem();
            var __dur = (__end - __start);
            var __memDiff = __memEnd - __memStart;
            Console.WriteLine(JsonSerializer.Serialize(new SortedDictionary<string, object>{{"name", "main"}, {"duration_us", __dur}, {"memory_bytes", __memDiff}}, new JsonSerializerOptions{ WriteIndented = true }));
        }
    }
}
