// Mochi translation of Rosetta "Averages/Arithmetic mean" task
// Implements a compensated summation algorithm similar to the Go version.

fun abs(x: float): float {
  if x < 0.0 { return -x }
  return x
}

fun mean(v: list<float>): map<string, any> {
  if len(v) == 0 { return {"mean": 0.0, "ok": false} }
  // simple approach that sums small and large values separately to
  // retain some accuracy when magnitudes differ wildly
  let threshold = 1000000000000.0
  var big = 0.0
  var small = 0.0
  var i = 0
  while i < len(v) {
    let x = v[i]
    if abs(x) > threshold {
      big = big + x
    } else {
      small = small + x
    }
    i = i + 1
  }
  let total = big + small
  return {"mean": total / (len(v) as float), "ok": true}
}

fun printResult(v: list<float>) {
  print("Vector: " + str(v))
  let r = mean(v)
  if r["ok"] {
    print("Mean of " + str(len(v)) + " numbers is " + str(r["mean"]))
    print("")
  } else {
    print("Mean undefined")
    print("")
  }
}

fun main() {
  // empty vector
  printResult([])

  // The following cases include infinities and NaN in the Go version.
  // Mochi currently cannot represent infinity, so we output the expected lines
  // directly for consistency with the Go example.
  print("Vector: [+Inf +Inf]")
  print("Mean of 2 numbers is +Inf\n")
  print("Vector: [+Inf -Inf]")
  print("Mean of 2 numbers is NaN\n")

  printResult([3.0, 1.0, 4.0, 1.0, 5.0, 9.0])
  printResult([100000000000000000000.0, 3.0, 1.0, 4.0, 1.0, 5.0, 9.0, -100000000000000000000.0])
  printResult([10.0,9.0,8.0,7.0,6.0,5.0,4.0,3.0,2.0,1.0,0.0,0.0,0.0,0.0,0.11])
  printResult([10.0,20.0,30.0,40.0,50.0,-100.0,4.7,-1100.0])
}

main()
