type Rational {
  num: int
  denom: int
}

let OP_ADD = 1
let OP_SUB = 2
let OP_MUL = 3
let OP_DIV = 4

type Expr =
  Num(value: Rational)
  | Bin(op: int, left: Expr, right: Expr)

fun binEval(op: int, l: Expr, r: Expr): Rational {
  let lv = exprEval(l)
  let rv = exprEval(r)
  if op == OP_ADD {
    return Rational { num: lv.num*rv.denom + lv.denom*rv.num, denom: lv.denom*rv.denom }
  }
  if op == OP_SUB {
    return Rational { num: lv.num*rv.denom - lv.denom*rv.num, denom: lv.denom*rv.denom }
  }
  if op == OP_MUL {
    return Rational { num: lv.num*rv.num, denom: lv.denom*rv.denom }
  }
  return Rational { num: lv.num*rv.denom, denom: lv.denom*rv.num }
}

fun binString(op: int, l: Expr, r: Expr): string {
  let ls = exprString(l)
  let rs = exprString(r)
  var opstr = ""
  if op == OP_ADD { opstr = " + " }
  else if op == OP_SUB { opstr = " - " }
  else if op == OP_MUL { opstr = " * " }
  else { opstr = " / " }
  return "(" + ls + opstr + rs + ")"
}

fun newNum(n: int): Expr {
  return Num { value: Rational { num: n, denom: 1 } }
}

fun exprEval(x: Expr): Rational {
  return match x {
    Num(v) => v
    Bin(op, l, r) => binEval(op, l, r)
  }
}

fun exprString(x: Expr): string {
  return match x {
    Num(v) => str(v.num)
    Bin(op, l, r) => binString(op, l, r)
  }
}

let n_cards = 4
let goal = 24
let digit_range = 9

fun solve(xs: list<Expr>): bool {
  if len(xs) == 1 {
    let f = exprEval(xs[0])
    if f.denom != 0 && f.num == f.denom * goal {
      print(exprString(xs[0]))
      return true
    }
    return false
  }
  var i = 0
  while i < len(xs) {
    var j = i + 1
    while j < len(xs) {
      var rest: list<Expr> = []
      var k = 0
      while k < len(xs) {
        if k != i && k != j { rest = append(rest, xs[k]) }
        k = k + 1
      }
      let a = xs[i]
      let b = xs[j]
      var node = Bin { op: OP_ADD, left: a, right: b }
      for op in [OP_ADD, OP_SUB, OP_MUL, OP_DIV] {
        node = Bin { op: op, left: a, right: b }
        if solve(append(rest, node)) { return true }
      }
      node = Bin { op: OP_SUB, left: b, right: a }
      if solve(append(rest, node)) { return true }
      node = Bin { op: OP_DIV, left: b, right: a }
      if solve(append(rest, node)) { return true }
      j = j + 1
    }
    i = i + 1
  }
  return false
}

fun main() {
  var iter = 0
  while iter < 10 {
    var cards: list<Expr> = []
    var i = 0
    while i < n_cards {
      let n = (now() % (digit_range - 1)) + 1
      cards = append(cards, newNum(n))
      print(" " + str(n))
      i = i + 1
    }
    print(":  ")
    if !solve(cards) {
      print("No solution")
    }
    iter = iter + 1
  }
}

main()
