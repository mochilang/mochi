package cppcode

// Runtime helper data for the C++ backend.

// ordered helper names ensures deterministic output
var helperOrder = []string{"indexString", "indexVec", "sliceVec", "sliceStr", "fmtVec", "groupBy", "reduce", "count", "avg", "unionAll", "union", "except", "intersect", "json", "input", "load", "save"}

// helperCode contains the C++ source for each optional runtime helper
var helperCode = map[string][]string{
	"indexString": {
		"string _indexString(const string& s, int i) {",
		"\tint n = s.size();",
		"\tif (i < 0) i += n;",
		"\tif (i < 0 || i >= n) throw std::out_of_range(\"index out of range\");",
		"\treturn string(1, s[i]);",
		"}",
	},
	"indexVec": {
		"template<typename T> T _indexVec(const vector<T>& v, int i) {",
		"\tint n = v.size();",
		"\tif (i < 0) i += n;",
		"\tif (i < 0 || i >= n) throw std::out_of_range(\"index out of range\");",
		"\treturn v[i];",
		"}",
	},
	"sliceVec": {
		"template<typename T> vector<T> _slice(const vector<T>& v, int start, int end) {",
		"\tint n = v.size();",
		"\tif (start < 0) start += n;",
		"\tif (end < 0) end += n;",
		"\tif (start < 0) start = 0;",
		"\tif (end > n) end = n;",
		"\tif (end < start) end = start;",
		"\treturn vector<T>(v.begin() + start, v.begin() + end);",
		"}",
	},
	"sliceStr": {
		"string _sliceString(const string& s, int start, int end) {",
		"\tint n = s.size();",
		"\tif (start < 0) start += n;",
		"\tif (end < 0) end += n;",
		"\tif (start < 0) start = 0;",
		"\tif (end > n) end = n;",
		"\tif (end < start) end = start;",
		"\treturn s.substr(start, end - start);",
		"}",
	},
	"fmtVec": {
		"template<typename T> string _fmtVec(const vector<T>& v) {",
		"\tstringstream ss;",
		"\tss << '[';",
		"\tfor (size_t i = 0; i < v.size(); i++) {",
		"\t\tif (i > 0) ss << ' ';",
		"\t\tss << v[i];",
		"\t}",
		"\tss << ']';",
		"\treturn ss.str();",
		"}",
	},
	"groupBy": {
		"template<typename Src, typename KeyFunc> auto _group_by(const Src& src, KeyFunc keyfn) {",
		"\tusing ElemT = typename std::decay<decltype(*std::begin(src))>::type;",
		"\tusing KeyT = decltype(keyfn(*std::begin(src)));",
		"\tstruct _Group { KeyT Key; vector<ElemT> Items; };",
		"\tunordered_map<KeyT, _Group> groups;",
		"\tvector<KeyT> order;",
		"\tfor (const auto& it : src) {",
		"\t\tKeyT k = keyfn(it);",
		"\t\tif (!groups.count(k)) { groups[k] = _Group{k, {}}; order.push_back(k); }",
		"\t\tgroups[k].Items.push_back(it);",
		"\t}",
		"\tvector<_Group> res;",
		"\tfor (const auto& k : order) res.push_back(groups[k]);",
		"\treturn res;",
		"}",
	},
	"reduce": {
		"template<typename Src, typename Fn, typename Acc> Acc _reduce(const Src& src, Fn fn, Acc acc) {",
		"\tfor (const auto& it : src) {",
		"\t\tacc = fn(acc, it);",
		"\t}",
		"\treturn acc;",
		"}",
	},
	"count": {
		"template<typename T> auto _count(const T& v) -> decltype(v.size(), int{}) {",
		"\treturn (int)v.size();",
		"}",
		"template<typename T> auto _count(const T& v) -> decltype(v.Items, int{}) {",
		"\treturn (int)v.Items.size();",
		"}",
	},
	"avg": {
		"template<typename T> auto _avg(const T& v) -> decltype(v.size(), double{}) {",
		"\tif (v.size() == 0) return 0;",
		"\tdouble sum = 0;",
		"\tfor (const auto& it : v) sum += it;",
		"\treturn sum / v.size();",
		"}",
		"template<typename T> auto _avg(const T& v) -> decltype(v.Items, double{}) {",
		"\treturn _avg(v.Items);",
		"}",
	},
	"unionAll": {
		"template<typename T> vector<T> _union_all(const vector<T>& a, const vector<T>& b) {",
		"\tvector<T> res = a;",
		"\tres.insert(res.end(), b.begin(), b.end());",
		"\treturn res;",
		"}",
	},
	"union": {
		"template<typename T> vector<T> _union(const vector<T>& a, const vector<T>& b) {",
		"\tvector<T> res = a;",
		"\tfor (const auto& it : b) {",
		"\t\tif (find(res.begin(), res.end(), it) == res.end()) res.push_back(it);",
		"\t}",
		"\treturn res;",
		"}",
	},
	"except": {
		"template<typename T> vector<T> _except(const vector<T>& a, const vector<T>& b) {",
		"\tvector<T> res;",
		"\tfor (const auto& it : a) {",
		"\t\tif (find(b.begin(), b.end(), it) == b.end()) res.push_back(it);",
		"\t}",
		"\treturn res;",
		"}",
	},
	"intersect": {
		"template<typename T> vector<T> _intersect(const vector<T>& a, const vector<T>& b) {",
		"\tvector<T> res;",
		"\tfor (const auto& it : a) {",
		"\t\tif (find(b.begin(), b.end(), it) != b.end() && find(res.begin(), res.end(), it) == res.end()) res.push_back(it);",
		"\t}",
		"\treturn res;",
		"}",
	},
	"json": {
		"static string _escape_json(const string& s) {",
		"\tstring out;",
		"\tfor (char c : s) {",
		"\t\tif (c == '\"' || c == '\\') out += '\\';",
		"\t\tout += c;",
		"\t}",
		"\treturn out;",
		"}",
		"template<typename T> string _to_json(const T& v);",
		"inline string _to_json(const string& s) {",
		"\tstring out = \"\\\"\";",
		"\tout += _escape_json(s);",
		"\tout += \"\\\"\";",
		"\treturn out;",
		"}",
		"inline string _to_json(const char* s) { return _to_json(string(s)); }",
		"inline string _to_json(int v) { return to_string(v); }",
		"inline string _to_json(double v) { stringstream ss; ss << v; return ss.str(); }",
		"inline string _to_json(bool v) { return v ? \"true\" : \"false\"; }",
		"template<typename T> string _to_json(const vector<T>& v) {",
		"\tstring out = \"[\";",
		"\tfor (size_t i=0;i<v.size();i++) { if (i>0) out += ','; out += _to_json(v[i]); }",
		"\tout += ']';",
		"\treturn out;",
		"}",
		"template<typename K, typename V> string _to_json(const unordered_map<K,V>& m) {",
		"\tstring out = \"{\"; bool first = true;",
		"\tfor (const auto& kv : m) {",
		"\t\tif (!first) out += ','; first = false;",
		"\t\tout += _to_json(kv.first); out += ':'; out += _to_json(kv.second);",
		"\t}",
		"\tout += '}';",
		"\treturn out;",
		"}",
		"template<typename T> string _to_json(const T& v) { stringstream ss; ss << v; return _to_json(ss.str()); }",
		"template<typename T> void _json(const T& v) { cout << _to_json(v) << endl; }",
	},
	"input": {
		"string _input() {",
		"\tstring s;",
		"\tgetline(cin, s);",
		"\treturn s;",
		"}",
	},
	"load": {
		"static string _readInput(const string& path) {",
		"\tif (path.empty() || path == \"-\") { stringstream ss; ss << cin.rdbuf(); return ss.str(); }",
		"\tifstream f(path); stringstream ss; ss << f.rdbuf(); return ss.str();",
		"}",
		"static vector<unordered_map<string,string>> _parseCSV(const string& text, bool header, char delim) {",
		"\tvector<unordered_map<string,string>> out; vector<string> lines; stringstream ss(text); string l;",
		"\twhile (getline(ss,l)) { if(!l.empty() && l.back()=='\\r') l.pop_back(); if(!l.empty()) lines.push_back(l); }",
		"\tif (lines.empty()) return out;",
		"\tauto split=[&](const string& s){ vector<string> parts; string tmp; stringstream s2(s); while(getline(s2,tmp,delim)) parts.push_back(tmp); return parts; };",
		"\tvector<string> headers; size_t start=0;",
		"\tif(header){ headers=split(lines[0]); start=1; } else { auto first=split(lines[0]); for(size_t i=0;i<first.size();i++) headers.push_back(\"c\"+to_string(i)); }",
		"\tfor(size_t i=start;i<lines.size();i++){ auto parts=split(lines[i]); unordered_map<string,string> row; for(size_t j=0;j<headers.size();j++){ row[headers[j]] = j<parts.size()?parts[j]:\"\"; } out.push_back(row); }",
		"\treturn out;",
		"}",
		"vector<unordered_map<string,string>> _load(const string& path) {",
		"\tstring txt = _readInput(path);",
		"\treturn _parseCSV(txt, true, ',');",
		"}",
	},
	"save": {
		"static void _writeOutput(const string& path, const string& text) {",
		"\tif (path.empty() || path == \"-\") { cout << text; } else { ofstream f(path); f << text; }",
		"}",
		"void _save(const vector<unordered_map<string,string>>& rows, const string& path) {",
		"\tvector<string> headers; if(!rows.empty()) for(const auto& kv : rows[0]) headers.push_back(kv.first); sort(headers.begin(), headers.end());",
		"\tstringstream ss; if(!headers.empty()){ for(size_t i=0;i<headers.size();i++){ if(i>0) ss << ','; ss << headers[i]; } ss << '\\n'; }",
		"\tfor(const auto& row: rows){ for(size_t i=0;i<headers.size();i++){ if(i>0) ss << ','; auto it=row.find(headers[i]); if(it!=row.end()) ss << it->second; } ss << '\\n'; }",
		"\t_writeOutput(path, ss.str());",
		"}",
	},
}

// emitRuntime writes used helper functions into the compiler buffer.
func (c *Compiler) emitRuntime() {
	for _, name := range helperOrder {
		if !c.helpers[name] {
			continue
		}
		for _, line := range helperCode[name] {
			c.writeln(line)
		}
		c.writeln("")
	}
}
