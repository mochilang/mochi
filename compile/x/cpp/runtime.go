package cppcode

// Runtime helper data for the C++ backend.

// ordered helper names ensures deterministic output
var helperOrder = []string{"indexString", "indexVec", "sliceVec", "sliceStr", "fmtVec", "groupBy", "reduce", "count", "sum", "avg", "unionAll", "union", "except", "intersect", "json", "cast", "fetch", "input", "load", "save"}

// helperCode contains the C++ source for each optional runtime helper
var helperCode = map[string][]string{
	"indexString": {
		"string _indexString(const string& s, int i) {",
		"\tint n = s.size();",
		"\tif (i < 0) i += n;",
		"\tif (i < 0 || i >= n) throw std::out_of_range(\"index out of range\");",
		"\treturn string(1, s[i]);",
		"}",
	},
	"indexVec": {
		"template<typename T> T _indexVec(const vector<T>& v, int i) {",
		"\tint n = v.size();",
		"\tif (i < 0) i += n;",
		"\tif (i < 0 || i >= n) throw std::out_of_range(\"index out of range\");",
		"\treturn v[i];",
		"}",
	},
	"sliceVec": {
		"template<typename T> vector<T> _slice(const vector<T>& v, int start, int end) {",
		"\tint n = v.size();",
		"\tif (start < 0) start += n;",
		"\tif (end < 0) end += n;",
		"\tif (start < 0) start = 0;",
		"\tif (end > n) end = n;",
		"\tif (end < start) end = start;",
		"\treturn vector<T>(v.begin() + start, v.begin() + end);",
		"}",
	},
	"sliceStr": {
		"string _sliceString(const string& s, int start, int end) {",
		"\tint n = s.size();",
		"\tif (start < 0) start += n;",
		"\tif (end < 0) end += n;",
		"\tif (start < 0) start = 0;",
		"\tif (end > n) end = n;",
		"\tif (end < start) end = start;",
		"\treturn s.substr(start, end - start);",
		"}",
	},
	"fmtVec": {
		"template<typename T> string _fmtVec(const vector<T>& v) {",
		"\tstringstream ss;",
		"\tss << '[';",
		"\tfor (size_t i = 0; i < v.size(); i++) {",
		"\t\tif (i > 0) ss << ' ';",
		"\t\tss << v[i];",
		"\t}",
		"\tss << ']';",
		"\treturn ss.str();",
		"}",
	},
	"groupBy": {
		"template<typename Src, typename KeyFunc> auto _group_by(const Src& src, KeyFunc keyfn) {",
		"\tusing ElemT = typename std::decay<decltype(*std::begin(src))>::type;",
		"\tusing KeyT = decltype(keyfn(*std::begin(src)));",
		"\tstruct _Group { KeyT Key; vector<ElemT> Items; };",
		"\tunordered_map<KeyT, _Group> groups;",
		"\tvector<KeyT> order;",
		"\tfor (const auto& it : src) {",
		"\t\tKeyT k = keyfn(it);",
		"\t\tif (!groups.count(k)) { groups[k] = _Group{k, {}}; order.push_back(k); }",
		"\t\tgroups[k].Items.push_back(it);",
		"\t}",
		"\tvector<_Group> res;",
		"\tfor (const auto& k : order) res.push_back(groups[k]);",
		"\treturn res;",
		"}",
	},
	"reduce": {
		"template<typename Src, typename Fn, typename Acc> Acc _reduce(const Src& src, Fn fn, Acc acc) {",
		"\tfor (const auto& it : src) {",
		"\t\tacc = fn(acc, it);",
		"\t}",
		"\treturn acc;",
		"}",
	},
	"count": {
		"template<typename T> auto _count(const T& v) -> decltype(v.size(), int{}) {",
		"\treturn (int)v.size();",
		"}",
		"template<typename T> auto _count(const T& v) -> decltype(v.Items, int{}) {",
		"\treturn (int)v.Items.size();",
		"}",
	},
	"sum": {
		"template<typename T> auto _sum(const T& v) -> decltype(v.size(), double{}) {",
		"\tdouble _s = 0;",
		"\tfor (const auto& it : v) _s += it;",
		"\treturn _s;",
		"}",
		"template<typename T> auto _sum(const T& v) -> decltype(v.Items, double{}) {",
		"\treturn _sum(v.Items);",
		"}",
	},
	"avg": {
		"template<typename T> auto _avg(const T& v) -> decltype(v.size(), double{}) {",
		"\tif (v.size() == 0) return 0;",
		"\tdouble sum = 0;",
		"\tfor (const auto& it : v) sum += it;",
		"\treturn sum / v.size();",
		"}",
		"template<typename T> auto _avg(const T& v) -> decltype(v.Items, double{}) {",
		"\treturn _avg(v.Items);",
		"}",
	},
	"unionAll": {
		"template<typename T> vector<T> _union_all(const vector<T>& a, const vector<T>& b) {",
		"\tvector<T> res = a;",
		"\tres.insert(res.end(), b.begin(), b.end());",
		"\treturn res;",
		"}",
	},
	"union": {
		"template<typename T> vector<T> _union(const vector<T>& a, const vector<T>& b) {",
		"\tvector<T> res = a;",
		"\tfor (const auto& it : b) {",
		"\t\tif (find(res.begin(), res.end(), it) == res.end()) res.push_back(it);",
		"\t}",
		"\treturn res;",
		"}",
	},
	"except": {
		"template<typename T> vector<T> _except(const vector<T>& a, const vector<T>& b) {",
		"\tvector<T> res;",
		"\tfor (const auto& it : a) {",
		"\t\tif (find(b.begin(), b.end(), it) == b.end()) res.push_back(it);",
		"\t}",
		"\treturn res;",
		"}",
	},
	"intersect": {
		"template<typename T> vector<T> _intersect(const vector<T>& a, const vector<T>& b) {",
		"\tvector<T> res;",
		"\tfor (const auto& it : a) {",
		"\t\tif (find(b.begin(), b.end(), it) != b.end() && find(res.begin(), res.end(), it) == res.end()) res.push_back(it);",
		"\t}",
		"\treturn res;",
		"}",
	},
	"json": {
		"static string _escape_json(const string& s) {",
		"\tstring out;",
		"\tfor (char c : s) {",
		"\t\tif (c == '\"' || c == '\\\\') out += '\\\\';",
		"\t\tout += c;",
		"\t}",
		"\treturn out;",
		"}",
		"template<typename T> string _to_json(const T& v);",
		"inline string _to_json(const string& s) {",
		"\tstring out = \"\\\"\";",
		"\tout += _escape_json(s);",
		"\tout += \"\\\"\";",
		"\treturn out;",
		"}",
		"inline string _to_json(const char* s) { return _to_json(string(s)); }",
		"inline string _to_json(int v) { return to_string(v); }",
		"inline string _to_json(double v) { stringstream ss; ss << v; return ss.str(); }",
		"inline string _to_json(bool v) { return v ? \"true\" : \"false\"; }",
		"inline string _to_json(const any& v) {",
		"\tif (v.type() == typeid(int)) return _to_json(any_cast<int>(v));",
		"\tif (v.type() == typeid(double)) return _to_json(any_cast<double>(v));",
		"\tif (v.type() == typeid(bool)) return _to_json(any_cast<bool>(v));",
		"\tif (v.type() == typeid(string)) return _to_json(any_cast<string>(v));",
		"\treturn \"null\";",
		"}",
		"template<typename T> string _to_json(const vector<T>& v) {",
		"\tstring out = \"[\";",
		"\tfor (size_t i=0;i<v.size();i++) { if (i>0) out += ','; out += _to_json(v[i]); }",
		"\tout += ']';",
		"\treturn out;",
		"}",
		"template<typename K, typename V> string _to_json(const unordered_map<K,V>& m) {",
		"\tstring out = \"{\"; bool first = true;",
		"\tfor (const auto& kv : m) {",
		"\t\tif (!first) out += ','; first = false;",
		"\t\tout += _to_json(kv.first); out += ':'; out += _to_json(kv.second);",
		"\t}",
		"\tout += '}';",
		"\treturn out;",
		"}",
		"template<typename T> string _to_json(const T& v) { stringstream ss; ss << v; return _to_json(ss.str()); }",
		"template<typename T> void _json(const T& v) { cout << _to_json(v) << endl; }",
	},
	"cast": {
		"template<typename T> T _cast(any v);",
		"template<> inline int _cast<int>(any v) {",
		"\tif (v.type() == typeid(int)) return any_cast<int>(v);",
		"\tif (v.type() == typeid(double)) return int(any_cast<double>(v));",
		"\tif (v.type() == typeid(string)) return stoi(any_cast<string>(v));",
		"\treturn 0;",
		"}",
		"template<> inline double _cast<double>(any v) {",
		"\tif (v.type() == typeid(double)) return any_cast<double>(v);",
		"\tif (v.type() == typeid(int)) return double(any_cast<int>(v));",
		"\tif (v.type() == typeid(string)) return stod(any_cast<string>(v));",
		"\treturn 0.0;",
		"}",
		"template<> inline bool _cast<bool>(any v) {",
		"\tif (v.type() == typeid(bool)) return any_cast<bool>(v);",
		"\tif (v.type() == typeid(string)) return any_cast<string>(v)==\"true\";",
		"\tif (v.type() == typeid(int)) return any_cast<int>(v)!=0;",
		"\treturn false;",
		"}",
		"template<> inline string _cast<string>(any v) {",
		"\tif (v.type() == typeid(string)) return any_cast<string>(v);",
		"\tif (v.type() == typeid(int)) return to_string(any_cast<int>(v));",
		"\tif (v.type() == typeid(double)) { stringstream ss; ss<<any_cast<double>(v); return ss.str(); }",
		"\tif (v.type() == typeid(bool)) return any_cast<bool>(v)?\"true\":\"false\";",
		"\treturn \"\";",
		"}",
	},
	"fetch": {
		"static unordered_map<string,string> _fetch_parse(const string& s) {",
		"\tunordered_map<string,string> row; size_t i=0;",
		"\twhile (i<s.size()) {",
		"\t\tif (s[i]=='\"') {",
		"\t\t\tsize_t j=s.find('\"', i+1); if (j==string::npos) break; string key=s.substr(i+1,j-i-1);",
		"\t\t\ti=s.find(':', j); if (i==string::npos) break; i++; while(i<s.size() && isspace(s[i])) i++;",
		"\t\t\tstring val;",
		"\t\t\tif (i<s.size() && s[i]=='\"') { size_t k=s.find('\"', i+1); val=s.substr(i+1,k-i-1); i=k+1; } else { size_t k=i; while (k<s.size() && (isalnum(s[k])||s[k]=='-'||s[k]=='+'||s[k]=='.')) k++; val=s.substr(i,k-i); i=k; }",
		"\t\t\trow[key]=val;",
		"\t\t} else { i++; }",
		"\t}",
		"\treturn row;",
		"}",
		"unordered_map<string,string> _fetch(const string& url, const unordered_map<string,any>& opts) {",
		"\t(void)opts;",
		"\tstring data;",
		"\tif (url.rfind(\"file://\",0)==0) {",
		"\t\tifstream f(url.substr(7)); stringstream ss; ss<<f.rdbuf(); data=ss.str();",
		"\t} else {",
		"\t\tstring cmd=\"curl -s \"+url;",
		"\t\tFILE* p=popen(cmd.c_str(), \"r\"); char buf[4096]; while(p && !feof(p)){ size_t n=fread(buf,1,sizeof(buf),p); data.append(buf,n);} if(p) pclose(p);",
		"\t}",
		"\treturn _fetch_parse(data);",
		"}",
	},
	"input": {
		"string _input() {",
		"\tstring s;",
		"\tgetline(cin, s);",
		"\treturn s;",
		"}",
	},
	"load": {
		"static string _read_input(const string& path) {",
		"\tif (!path.empty() && path != \"-\") {",
		"\t\tifstream f(path);",
		"\t\tstringstream ss; ss << f.rdbuf(); return ss.str();",
		"\t}",
		"\tstringstream ss; ss << cin.rdbuf(); return ss.str();",
		"}",
		"static vector<string> _split(const string& s, char d) {",
		"\tvector<string> out; string item; stringstream ss(s);",
		"\twhile (getline(ss, item, d)) out.push_back(item);",
		"\treturn out;",
		"}",
		"static vector<unordered_map<string,string>> _parse_csv(const string& text, bool header, char delim) {",
		"\tvector<unordered_map<string,string>> rows;",
		"\tstringstream ss(text); string line; vector<string> lines;",
		"\twhile (getline(ss, line)) { if (!line.empty() && line.back()=='\\r') line.pop_back(); lines.push_back(line); }",
		"\tif (lines.empty()) return rows;",
		"\tvector<string> headers; size_t start = 0;",
		"\tif (header) { headers = _split(lines[0], delim); start = 1; } else {",
		"\theaders = _split(lines[0], delim);",
		"\tfor (size_t i=0;i<headers.size();i++) headers[i] = string(\"c\")+to_string(i);",
		"\t}",
		"\tfor (size_t i=start;i<lines.size();i++) {",
		"\t\tauto parts = _split(lines[i], delim);",
		"\t\tunordered_map<string,string> row;",
		"\t\tfor (size_t j=0;j<headers.size();j++) {",
		"\t\t\tstring val = j<parts.size()?parts[j]:\"\";",
		"\t\t\trow[headers[j]] = val;",
		"\t\t}",
		"\t\trows.push_back(row);",
		"\t}",
		"\treturn rows;",
		"}",
		"static unordered_map<string,string> _parse_json_obj(const string& s) {",
		"\tunordered_map<string,string> row; size_t i=0;",
		"\twhile (i<s.size()) {",
		"\t\tif (s[i]=='\"') {",
		"\t\t\tsize_t j=s.find('\"', i+1); if (j==string::npos) break; string key=s.substr(i+1,j-i-1);",
		"\t\t\ti=s.find(':', j); if (i==string::npos) break; i++; while (i<s.size() && isspace(s[i])) i++;",
		"\t\t\tstring val;",
		"\t\t\tif (i<s.size() && s[i]=='\"') { size_t k=s.find('\"', i+1); val=s.substr(i+1,k-i-1); i=k+1; } else { size_t k=i; while (k<s.size() && (isalnum(s[k])||s[k]=='-'||s[k]=='+'||s[k]=='.')) k++; val=s.substr(i,k-i); i=k; }",
		"\t\t\trow[key]=val;",
		"\t\t} else { i++; }",
		"\t}",
		"\treturn row;",
		"}",
		"static vector<unordered_map<string,string>> _parse_jsonl(const string& text) {",
		"\tvector<unordered_map<string,string>> rows; string line; stringstream ss(text);",
		"\twhile (getline(ss, line)) { if (!line.empty()) rows.push_back(_parse_json_obj(line)); }",
		"\treturn rows;",
		"}",
		"static vector<unordered_map<string,string>> _parse_json(const string& text) {",
		"\tstring t=text; while(!t.empty() && isspace(t.front())) t.erase(t.begin()); while(!t.empty() && isspace(t.back())) t.pop_back();",
		"\tvector<unordered_map<string,string>> rows;",
		"\tif (t.empty()) return rows;",
		"\tif (t[0]=='[') { size_t pos=t.find('{'); while(pos!=string::npos){ size_t end=t.find('}',pos); rows.push_back(_parse_json_obj(t.substr(pos,end-pos+1))); pos=t.find('{',end); } }",
		"\telse if (t[0]=='{') { rows.push_back(_parse_json_obj(t)); }",
		"\treturn rows;",
		"}",
		"vector<unordered_map<string,string>> _load(const string& path, const unordered_map<string,string>& opts) {",
		"\tstring format=\"csv\"; bool header=true; char delim=',';",
		"\tauto it=opts.find(\"format\"); if(it!=opts.end()) format=it->second;",
		"\tit=opts.find(\"header\"); if(it!=opts.end()) header=(it->second==\"true\");",
		"\tit=opts.find(\"delimiter\"); if(it!=opts.end() && !it->second.empty()) delim=it->second[0];",
		"\tstring text=_read_input(path);",
		"\tif (format==\"jsonl\") return _parse_jsonl(text);",
		"\tif (format==\"json\") return _parse_json(text);",
		"\tif (format==\"tsv\") delim='\t';",
		"\treturn _parse_csv(text, header, delim);",
		"}",
	},
	"save": {
		"static void _write_output(const string& path, const string& text) {",
		"\tif (!path.empty() && path != \"-\") { ofstream f(path); f << text; } else { cout << text; }",
		"}",
		"static string _json_sorted(const unordered_map<string,string>& m) {",
		"\tvector<string> keys; for (const auto& kv : m) keys.push_back(kv.first); sort(keys.begin(), keys.end());",
		"\tstring out=\"{\"; bool first=true;",
		"\tfor(const auto& k:keys){ if(!first) out+=','; first=false; out+=_to_json(k); out+=':'; out+=_to_json(m.at(k)); }",
		"\tout+='}'; return out;",
		"}",
		"void _save(const vector<unordered_map<string,string>>& src, const string& path, const unordered_map<string,string>& opts) {",
		"\tstring format=\"csv\"; bool header=false; char delim=',';",
		"\tauto it=opts.find(\"format\"); if(it!=opts.end()) format=it->second;",
		"\tit=opts.find(\"header\"); if(it!=opts.end()) header=(it->second==\"true\");",
		"\tit=opts.find(\"delimiter\"); if(it!=opts.end() && !it->second.empty()) delim=it->second[0];",
		"\tstring text;",
		"\tif (format==\"jsonl\") { for(const auto& r:src){ text+=_json_sorted(r)+\"\n\"; } }",
		"\telse if (format==\"json\") { if(src.size()==1) text=_json_sorted(src[0]); else text=_to_json(src); }",
		"\telse { if(format==\"tsv\") delim='\t'; vector<string> headers; if(!src.empty()) for(const auto& kv:src[0]) headers.push_back(kv.first); sort(headers.begin(), headers.end()); if(header && !headers.empty()){ for(size_t i=0;i<headers.size();i++){ if(i>0) text+=delim; text+=headers[i]; } text+='\n'; } for(const auto& r:src){ for(size_t i=0;i<headers.size();i++){ if(i>0) text+=delim; auto it2=r.find(headers[i]); if(it2!=r.end()) text+=it2->second; } text+='\n'; } }",
		"\t_write_output(path, text);",
		"}",
	},
}

// emitRuntime writes used helper functions into the compiler buffer.
func (c *Compiler) emitRuntime() {
	for _, name := range helperOrder {
		if !c.helpers[name] {
			continue
		}
		for _, line := range helperCode[name] {
			c.writeln(line)
		}
		c.writeln("")
	}
}
