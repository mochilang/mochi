# Elixir Backend

The Elixir backend compiles Mochi programs to `.exs` scripts that can be executed with the `elixir` command. It is invoked by `mochi build --target ex` (or `--target elixir`).

## Files

- `compiler.go` â€“ walks the AST and generates Elixir code
- `compiler_test.go` â€“ golden tests verifying generated programs run correctly
- `tools.go` â€“ utility that ensures the `elixir` binary is available

## Generated Program

`Compile` emits a simple `Main` module containing user-defined functions and a `main/0` entry point:

```go
func (c *Compiler) Compile(prog *parser.Program) ([]byte, error) {
    c.writeln("# Generated by Mochi Elixir compiler")
    c.writeln("defmodule Main do")
    ...
    c.writeln("def main do")
    ...
    c.writeln("end")
    c.writeln("Main.main()")
}
```

ã€F:compile/ex/compiler.goâ€ L39-L65ã€‘

Function bodies wrap statements in a `try`/`catch` block so that `return` can be implemented via exceptions:

```go
c.writeln("try do")
...
c.writeln("catch {:return, v} -> v end")
```

ã€F:compile/ex/compiler.goâ€ L79-L88ã€‘

## Built-in Functions

Several Mochi built-ins translate directly to Elixir equivalents:

```go
switch p.Call.Func {
case "print":
    return fmt.Sprintf("IO.puts(%s)", argStr), nil
case "len":
    return fmt.Sprintf("length(%s)", argStr), nil
case "count":
    c.use("_count")
    return fmt.Sprintf("_count(%s)", argStr), nil
case "avg":
    c.use("_avg")
    return fmt.Sprintf("_avg(%s)", argStr), nil
case "str":
    return fmt.Sprintf("to_string(%s)", argStr), nil
case "input":
    c.use("_input")
    return "_input()", nil
}
```

ã€F:compile/ex/compiler.goâ€ L516-L538ã€‘

### Control Flow

`compileIf`, `compileWhile` and `compileFor` generate standard Elixir constructs. Assignments with indexing use `Map.put`:

```go
if len(stmt.Index) > 0 {
    idx, _ := c.compileExpr(stmt.Index[0].Start)
    c.writeln(fmt.Sprintf("%s = Map.put(%s, %s, %s)", stmt.Name, stmt.Name, idx, value))
} else {
    c.writeln(fmt.Sprintf("%s = %s", stmt.Name, value))
}
```

`compileFor` detects string literals and iterates over their graphemes so that
`for ch in "cat"` becomes `for ch <- String.graphemes("cat") do`.


ã€F:compile/ex/compiler.goâ€ L231-L245ã€‘

Query expressions become list comprehensions with optional sorting, skipping and taking:

```go
items := src
if sortExpr != "" {
    items = fmt.Sprintf("Enum.sort_by(%s, fn %s -> %s end)", items, q.Var, sortExpr)
}
...
b.WriteString("for ")
b.WriteString(q.Var)
b.WriteString(" <- ")
b.WriteString(items)
if cond != "" { ... }
b.WriteString(", do: ")
b.WriteString(sel)
```

ã€F:compile/ex/compiler.goâ€ L324-L347ã€‘

Block-style anonymous functions are supported by compiling each statement in the
function body and wrapping the result in `fn` ... `end`:

```go
func (c *Compiler) compileFunExpr(fn *parser.FunExpr) (string, error) {
    params := make([]string, len(fn.Params))
    for i, p := range fn.Params {
        params[i] = p.Name
    }
    if fn.ExprBody != nil {
        expr, err := c.compileExpr(fn.ExprBody)
        if err != nil {
            return "", err
        }
        return fmt.Sprintf("fn %s -> %s end", strings.Join(params, ", "), expr), nil
    }
    if len(fn.BlockBody) > 0 {
        sub := &Compiler{env: c.env, indent: c.indent + 1}
        for _, s := range fn.BlockBody {
            if err := sub.compileStmt(s); err != nil {
                return "", err
            }
        }
        body := sub.buf.String()
        var b strings.Builder
        b.WriteString("fn " + strings.Join(params, ", ") + " ->\n")
        b.WriteString(body)
        for i := 0; i < c.indent; i++ {
            b.WriteByte('\t')
        }
        b.WriteString("end")
        return b.String(), nil
    }
    return "", fmt.Errorf("block function expressions not supported")
}
```

ã€F:compile/ex/compiler.goâ€ L908-L937ã€‘

## Ensuring Elixir

`EnsureElixir` checks for the `elixir` executable and installs it using `apt-get`, `brew` or `asdf` if necessary:

```go
if _, err := exec.LookPath("elixir"); err == nil {
    return nil
}
fmt.Println("ðŸ”§ Installing Elixir...")
...
return fmt.Errorf("elixir not installed and no supported installer found")
```

ã€F:compile/ex/tools.goâ€ L9-L57ã€‘

## Building

Compile a Mochi program to Elixir with:

```bash
mochi build --target ex main.mochi -o main.exs
```

This corresponds to the `ex`/`elixir` case in the CLI:

```go
case "ex", "elixir":
    if out == "" {
        out = base + ".ex"
    }
    code, err := excode.New(env).Compile(prog)
    ...
```

ã€F:cmd/mochi/main.goâ€ L519-L528ã€‘

## Tests

Golden tests generate Elixir code, run it with the `elixir` command and compare the output:

```go
golden.Run(t, "tests/compiler/ex", ".mochi", ".out", func(src string) ([]byte, error) {
    ...
    cmd := exec.Command("elixir", file)
    ...
})
```

ã€F:compile/ex/compiler_test.goâ€ L19-L48ã€‘

Run them with:

```bash
go test ./compile/ex -tags slow
```

## Unsupported Features

The Elixir backend implements most core language features but still lacks support for several advanced constructs:

- Nested recursive functions inside other functions. Problems relying on them, such as LeetCode 22, fail to run.
- Dataset queries with join clauses. Simple `group by` queries are now supported but more complex grouping or aggregation is not yet handled.
- Agent and stream constructs (`agent`, `on`, `emit`) and logic programming features (`fact`, `rule`, `query`).
- Data helpers like `fetch` and LLM `generate` blocks.
- `load` and `save` currently only handle Erlang term binaries.
- Foreign imports and `extern` declarations.
- Concurrency primitives such as `spawn` and channels.
- Pattern matching with `match` expressions.

Cross join queries do support `where` filters as well as `sort`, `skip` and `take` clauses.
