# Elixir Backend

The Elixir backend compiles Mochi programs to `.exs` scripts that can be executed with the `elixir` command. It is invoked by `mochi build --target ex` (or `--target elixir`).

## Files

- `compiler.go` ‚Äì walks the AST and generates Elixir code
- `compiler_test.go` ‚Äì golden tests verifying generated programs run correctly
- `tools.go` ‚Äì utility that ensures the `elixir` binary is available

## Generated Program

`Compile` emits a simple `Main` module containing user-defined functions and a `main/0` entry point:

```go
func (c *Compiler) Compile(prog *parser.Program) ([]byte, error) {
    c.writeln("# Generated by Mochi Elixir compiler")
    c.writeln("defmodule Main do")
    ...
    c.writeln("def main do")
    ...
    c.writeln("end")
    c.writeln("Main.main()")
}
```

„ÄêF:compile/ex/compiler.go‚Ä†L39-L65„Äë

Function bodies wrap statements in a `try`/`catch` block so that `return` can be implemented via exceptions:

```go
c.writeln("try do")
...
c.writeln("catch {:return, v} -> v end")
```

„ÄêF:compile/ex/compiler.go‚Ä†L79-L88„Äë

## Built-in Functions

Several Mochi built-ins translate directly to Elixir equivalents:

```go
switch p.Call.Func {
case "print":
    return fmt.Sprintf("IO.puts(%s)", argStr), nil
case "len":
    return fmt.Sprintf("length(%s)", argStr), nil
case "count":
    c.use("_count")
    return fmt.Sprintf("_count(%s)", argStr), nil
case "avg":
    c.use("_avg")
    return fmt.Sprintf("_avg(%s)", argStr), nil
case "str":
    return fmt.Sprintf("to_string(%s)", argStr), nil
case "input":
    c.use("_input")
    return "_input()", nil
}
```

„ÄêF:compile/ex/compiler.go‚Ä†L516-L538„Äë

### Control Flow

`compileIf`, `compileWhile` and `compileFor` generate standard Elixir constructs. Assignments with indexing use `Map.put`:

```go
if len(stmt.Index) > 0 {
    idx, _ := c.compileExpr(stmt.Index[0].Start)
    c.writeln(fmt.Sprintf("%s = Map.put(%s, %s, %s)", stmt.Name, stmt.Name, idx, value))
} else {
    c.writeln(fmt.Sprintf("%s = %s", stmt.Name, value))
}
```

`compileFor` detects string literals and iterates over their graphemes so that
`for ch in "cat"` becomes `for ch <- String.graphemes("cat") do`.


„ÄêF:compile/ex/compiler.go‚Ä†L231-L245„Äë

Query expressions become list comprehensions with optional sorting, skipping and taking:

```go
items := src
if sortExpr != "" {
    items = fmt.Sprintf("Enum.sort_by(%s, fn %s -> %s end)", items, q.Var, sortExpr)
}
...
b.WriteString("for ")
b.WriteString(q.Var)
b.WriteString(" <- ")
b.WriteString(items)
if cond != "" { ... }
b.WriteString(", do: ")
b.WriteString(sel)
```

„ÄêF:compile/ex/compiler.go‚Ä†L324-L347„Äë

Block-style anonymous functions are supported and compile into Elixir `fn ... ->`
blocks:

```go
func (c *Compiler) compileFunExpr(fn *parser.FunExpr) (string, error) {
    ...
    sub := &Compiler{env: c.env, indent: c.indent + 1}
    ...
    b.WriteString("end")
    return b.String(), nil
}
```

„ÄêF:compile/ex/compiler.go‚Ä†L914-L931„Äë

## Ensuring Elixir

`EnsureElixir` checks for the `elixir` executable and installs it using `apt-get`, `brew` or `asdf` if necessary:

```go
if _, err := exec.LookPath("elixir"); err == nil {
    return nil
}
fmt.Println("üîß Installing Elixir...")
...
return fmt.Errorf("elixir not installed and no supported installer found")
```

„ÄêF:compile/ex/tools.go‚Ä†L9-L57„Äë

## Building

Compile a Mochi program to Elixir with:

```bash
mochi build --target ex main.mochi -o main.exs
```

This corresponds to the `ex`/`elixir` case in the CLI:

```go
case "ex", "elixir":
    if out == "" {
        out = base + ".ex"
    }
    code, err := excode.New(env).Compile(prog)
    ...
```

„ÄêF:cmd/mochi/main.go‚Ä†L519-L528„Äë

## Tests

Golden tests generate Elixir code, run it with the `elixir` command and compare the output:

```go
golden.Run(t, "tests/compiler/ex", ".mochi", ".out", func(src string) ([]byte, error) {
    ...
    cmd := exec.Command("elixir", file)
    ...
})
```

„ÄêF:compile/ex/compiler_test.go‚Ä†L19-L48„Äë

Run them with:

```bash
go test ./compile/ex -tags slow
```

## Status

The Elixir backend handles core Mochi features including functions, loops,
structs and list comprehensions. Several parts of the language remain
unimplemented:

- query joins and grouping
- pattern matching in function heads
- concurrency primitives such as `spawn`
- macros, generics and some built-in functions
- operators outside the common arithmetic and comparison set

It is useful for examples but does not yet cover the entire language.
