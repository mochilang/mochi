# Elixir Backend

The Elixir backend compiles Mochi programs to `.exs` scripts that can be executed with the `elixir` command. It is invoked by `mochi build --target ex` (or `--target elixir`).

## Files

- `compiler.go` â€“ walks the AST and generates Elixir code
- `compiler_test.go` â€“ golden tests verifying generated programs run correctly
- `tools.go` â€“ utility that ensures the `elixir` binary is available

## Generated Program

`Compile` emits a simple `Main` module containing user-defined functions and a `main/0` entry point:

```go
func (c *Compiler) Compile(prog *parser.Program) ([]byte, error) {
    c.writeln("# Generated by Mochi Elixir compiler")
    c.writeln("defmodule Main do")
    ...
    c.writeln("def main do")
    ...
    c.writeln("end")
    c.writeln("Main.main()")
}
```

ã€F:compile/ex/compiler.goâ€ L39-L65ã€‘

Function bodies wrap statements in a `try`/`catch` block so that `return` can be implemented via exceptions:

```go
c.writeln("try do")
...
c.writeln("catch {:return, v} -> v end")
```

ã€F:compile/ex/compiler.goâ€ L79-L88ã€‘

## Built-in Functions

Several Mochi built-ins translate directly to Elixir equivalents:

```go
switch p.Call.Func {
case "print":
    return fmt.Sprintf("IO.puts(%s)", argStr), nil
case "len":
    return fmt.Sprintf("length(%s)", argStr), nil
case "count":
    return fmt.Sprintf("Enum.count(%s)", argStr), nil
case "avg":
    return fmt.Sprintf("if Enum.count(%[1]s) == 0, do: 0, else: Enum.sum(%[1]s) / Enum.count(%[1]s)", argStr), nil
case "str":
    return fmt.Sprintf("to_string(%s)", argStr), nil
case "input":
    return "String.trim(IO.gets(\"\"))", nil
}
```

ã€F:compile/ex/compiler.goâ€ L516-L538ã€‘

### Control Flow

`compileIf`, `compileWhile` and `compileFor` generate standard Elixir constructs. Assignments with indexing use `Map.put`:

```go
if len(stmt.Index) > 0 {
    idx, _ := c.compileExpr(stmt.Index[0].Start)
    c.writeln(fmt.Sprintf("%s = Map.put(%s, %s, %s)", stmt.Name, stmt.Name, idx, value))
} else {
    c.writeln(fmt.Sprintf("%s = %s", stmt.Name, value))
}
```

`compileFor` detects string literals and iterates over their graphemes so that
`for ch in "cat"` becomes `for ch <- String.graphemes("cat") do`.


ã€F:compile/ex/compiler.goâ€ L231-L245ã€‘

Query expressions become list comprehensions with optional sorting, skipping and taking:

```go
items := src
if sortExpr != "" {
    items = fmt.Sprintf("Enum.sort_by(%s, fn %s -> %s end)", items, q.Var, sortExpr)
}
...
b.WriteString("for ")
b.WriteString(q.Var)
b.WriteString(" <- ")
b.WriteString(items)
if cond != "" { ... }
b.WriteString(", do: ")
b.WriteString(sel)
```

ã€F:compile/ex/compiler.goâ€ L324-L347ã€‘

Block-style anonymous functions are not yet supported and return an error:

```go
func (c *Compiler) compileFunExpr(fn *parser.FunExpr) (string, error) {
    ...
    return "", fmt.Errorf("block function expressions not supported")
}
```

ã€F:compile/ex/compiler.goâ€ L548-L560ã€‘

## Ensuring Elixir

`EnsureElixir` checks for the `elixir` executable and installs it using `apt-get`, `brew` or `asdf` if necessary:

```go
if _, err := exec.LookPath("elixir"); err == nil {
    return nil
}
fmt.Println("ðŸ”§ Installing Elixir...")
...
return fmt.Errorf("elixir not installed and no supported installer found")
```

ã€F:compile/ex/tools.goâ€ L9-L57ã€‘

## Building

Compile a Mochi program to Elixir with:

```bash
mochi build --target ex main.mochi -o main.exs
```

This corresponds to the `ex`/`elixir` case in the CLI:

```go
case "ex", "elixir":
    if out == "" {
        out = base + ".ex"
    }
    code, err := excode.New(env).Compile(prog)
    ...
```

ã€F:cmd/mochi/main.goâ€ L519-L528ã€‘

## Tests

Golden tests generate Elixir code, run it with the `elixir` command and compare the output:

```go
golden.Run(t, "tests/compiler/ex", ".mochi", ".out", func(src string) ([]byte, error) {
    ...
    cmd := exec.Command("elixir", file)
    ...
})
```

ã€F:compile/ex/compiler_test.goâ€ L19-L48ã€‘

Run them with:

```bash
go test ./compile/ex -tags slow
```
