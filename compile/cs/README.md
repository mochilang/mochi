# C# Backend

The C# backend translates Mochi programs to standard C# source code. It is a minimal implementation focusing on the core language features. The compiler walks the Mochi AST and emits a single `Program` class containing the translated statements.

## Files

- `compiler.go` – core code generator implementing `Compile(*parser.Program)`
- `compiler_test.go` – golden tests validating generated output
- `tools.go` – utility that installs the `dotnet` CLI if it is missing (used by benchmarks)

## Helper Functions

Generated code may embed a small set of helper functions depending on which built‑in functions are used. The helpers are written directly into the output file. They include:

- `_count` – counts elements in a string or collection
- `_avg` – averages a numeric collection
- `_in` – membership test for strings, dictionaries and enumerables
- `_cast` – generic casting utility implemented via JSON serialisation
- `_indexString` – safe string indexing with negative offsets
- `_sliceString` – substring slicing with negative offsets
- `_equal` – deep equality check for lists
- `_union_all` – concatenates two lists
- `_union` – set union for lists
- `_except` – set difference for lists
- `_intersect` – set intersection for lists
- `_group` – simple grouping structure
- `_group_by` – groups items by a key selector
- `_fetch` – simple HTTP fetch helper
- `_load` – loads rows from a file
- `_save` – saves rows to a file
- `_genText` – placeholder text generation
- `_genEmbed` – placeholder embedding generation
- `_genStruct` – parses JSON text into a struct

The helpers are emitted on demand in `Compile`:

```go
if len(c.helpers) > 0 {
    for name := range c.helpers {
        switch name {
        case "_count":
            c.writeln("static int _count(dynamic v) {")
            ...
        case "_avg":
            c.writeln("static double _avg(dynamic v) {")
            ...
        }
    }
}
```

## Built-in Functions

Common built-ins such as `print`, `len`, `count` and `avg` expand to standard C#
code.  Additional helpers implement `now()` which returns a Unix timestamp in
nanoseconds and `json(v)` which prints a JSON representation of a value.

If `_cast` is not required the generated file omits the `System.Text.Json` import:

```go
code := c.buf.Bytes()
if _, ok := c.helpers["_cast"]; !ok {
    code = bytes.Replace(code, []byte("using System.Text.Json;\n"), nil, 1)
}
```

## Type Declarations

Struct and union types are emitted as public C# classes. Unions generate an interface with a marker method and one class per variant:

```go
func (c *Compiler) compileTypeDecl(t *parser.TypeDecl) error {
    name := sanitizeName(t.Name)
    if len(t.Variants) > 0 {
        iface := fmt.Sprintf("public interface %s { void is%s(); }", name, name)
        c.writeln(iface)
        for _, v := range t.Variants {
            vname := sanitizeName(v.Name)
            c.writeln(fmt.Sprintf("public class %s : %s {", vname, name))
            ...
        }
    }
}
```

## Query Expressions

Mochi's `from`/`select` syntax compiles to LINQ when possible. The compiler scans the program and adds `using System.Linq;` if a query expression is detected:

```go
c.scanProgram(prog)
c.writeln("// Generated by Mochi C# compiler")
c.writeln("using System;")
c.writeln("using System.Collections.Generic;")
if c.useLinq {
    c.writeln("using System.Linq;")
}
c.writeln("using System.Text.Json;")
```

Cross‑joins are implemented using nested loops and a helper `Func<List<dynamic>>` wrapper. A typical result looks like:

```csharp
var result = new Func<List<dynamic>>(() => {
    var _res = new List<dynamic>();
    foreach (var o in orders) {
        foreach (var c in customers) {
            _res.Add(new PairInfo { orderId = o.id, orderCustomerId = o.customerId, pairedCustomerName = c.name, orderTotal = o.total });
        }
    }
    return _res;
})();
```

## Building

Compile a Mochi source file to C# with:

```bash
mochi build --target cs main.mochi -o main.cs
```

The produced code is standard C# and can be executed with `dotnet run` or compiled with any C# compiler.

## Tests

Golden tests verify that the emitted code matches the expected `.cs.out` files. The suite also compiles and executes the programs in `tests/compiler/cs` using `dotnet run` to ensure they behave correctly. All tests are tagged `slow` because they invoke the .NET toolchain. Run them with:

```bash
go test ./compile/cs -tags slow
```

## Dotnet Installation

Benchmarks and other tooling require the `dotnet` command. `tools.go` provides an `EnsureDotnet` function that installs the SDK when missing:

```go
func EnsureDotnet() error {
    return ensureDotnet()
}
```

This script attempts platform‑specific installation via Homebrew or `apt-get` before falling back to the official installer.

## Notes

The C# backend focuses on fundamental features: functions, control flow, structs, unions and query expressions. Recent updates added support for package declarations, set operations on lists, helper functions for printing JSON or getting the current timestamp, and basic stream handling with `on`/`emit` blocks. Advanced Mochi capabilities such as long‑lived agents and extern objects are not yet implemented in this generator.

### Supported features

- Variable and function declarations
- Control flow with `if`, `for`, `while`, `break` and `continue`
- Struct and union types with pattern matching using `match`
- Lists and maps with indexing, slicing and membership checks
- Dataset queries with `from`, `where`, `select`, `sort by`, `skip` and `take`
- Cross joins via multiple `from` clauses
- Set operations on lists: `union`, `union all`, `except`, `intersect`
- Built‑ins `print`, `len`, `count`, `avg`, `now` and `json`
- HTTP requests using `fetch`
- Dataset helpers `_load` and `_save` supporting CSV, TSV, JSON, JSONL and YAML
- Package declarations and imports
- Basic stream handling with `on` and `emit`
- Placeholder generative helpers `_genText`, `_genEmbed` and `_genStruct`

### Unsupported features

- The backend is still incomplete. Notable gaps include:
- Right and outer joins in dataset queries
- Sorting, pagination or grouping when joins are used
- Agent declarations and intent blocks
- Logic programming constructs (`fact`, `rule`, `query`)
- Foreign function interface and extern objects
- Full LLM integration for `_genText` and `_genStruct`
- Concurrency primitives like `spawn` and channels
- `try`/`catch` error handling
- Agent initialization with field values
- The `eval` builtin function
- Reflection or macro facilities
- Generic type parameters and methods inside `type` blocks
- Asynchronous `async`/`await` constructs
