package swcode

import (
	"bytes"
	"fmt"
	"strings"

	"mochi/interpreter"
	"mochi/parser"
	"mochi/types"
)

// Compiler translates a Mochi AST into Swift source code.
type Compiler struct {
	buf          bytes.Buffer
	indent       int
	env          *types.Env
	helpers      map[string]bool
	streams      map[string]string
	handlerCount int
}

func New(env *types.Env) *Compiler {
	return &Compiler{
		env:     env,
		helpers: make(map[string]bool),
		streams: make(map[string]string),
	}
}

func (c *Compiler) Compile(prog *parser.Program) ([]byte, error) {
	c.writeln("// Generated by Mochi Swift compiler")
	c.writeln("")

	// function declarations
	for _, s := range prog.Statements {
		if s.Fun != nil {
			if err := c.compileFunStmt(s.Fun); err != nil {
				return nil, err
			}
			c.writeln("")
		}
	}
	// test block declarations
	for _, s := range prog.Statements {
		if s.Test != nil {
			if err := c.compileTestBlock(s.Test); err != nil {
				return nil, err
			}
			c.writeln("")
		}
	}

	c.writeln("func main() {")
	c.indent++
	for _, s := range prog.Statements {
		if s.Fun != nil || s.Test != nil {
			continue
		}
		if err := c.compileStmt(s); err != nil {
			return nil, err
		}
	}
	for _, s := range prog.Statements {
		if s.Test != nil {
			name := sanitizeName(s.Test.Name)
			c.writeln(fmt.Sprintf("%s()", name))
		}
	}
	c.indent--
	c.writeln("}")

	c.emitRuntime()

	c.writeln("main()")
	c.writeln("")
	return c.buf.Bytes(), nil
}

func (c *Compiler) compileStmt(s *parser.Statement) error {
	switch {
	case s.Let != nil:
		return c.compileLet(s.Let)
	case s.Var != nil:
		return c.compileVar(s.Var)
	case s.Assign != nil:
		return c.compileAssign(s.Assign)
	case s.Return != nil:
		return c.compileReturn(s.Return)
	case s.If != nil:
		return c.compileIf(s.If)
	case s.While != nil:
		return c.compileWhile(s.While)
	case s.For != nil:
		return c.compileFor(s.For)
	case s.Break != nil:
		c.writeln("break")
	case s.Continue != nil:
		c.writeln("continue")
	case s.Expr != nil:
		expr, err := c.compileExpr(s.Expr.Expr)
		if err != nil {
			return err
		}
		c.writeln(expr)
	case s.Stream != nil:
		return c.compileStreamDecl(s.Stream)
	case s.On != nil:
		return c.compileOnHandler(s.On)
	case s.Emit != nil:
		return c.compileEmit(s.Emit)
	case s.Expect != nil:
		return c.compileExpect(s.Expect)
	default:
		// ignore unsupported statements
	}
	return nil
}

func (c *Compiler) compileLet(s *parser.LetStmt) error {
	var rhs string
	if s.Value != nil {
		v, err := c.compileExpr(s.Value)
		if err != nil {
			return err
		}
		rhs = " = " + v
	}
	if s.Type != nil {
		typ := swiftType(resolveTypeRef(s.Type))
		c.writeln(fmt.Sprintf("let %s: %s%s", sanitizeName(s.Name), typ, rhs))
	} else {
		c.writeln(fmt.Sprintf("let %s%s", sanitizeName(s.Name), rhs))
	}
	return nil
}

func (c *Compiler) compileVar(s *parser.VarStmt) error {
	var rhs string
	if s.Value != nil {
		v, err := c.compileExpr(s.Value)
		if err != nil {
			return err
		}
		rhs = " = " + v
	}
	if s.Type != nil {
		typ := swiftType(resolveTypeRef(s.Type))
		c.writeln(fmt.Sprintf("var %s: %s%s", sanitizeName(s.Name), typ, rhs))
	} else {
		c.writeln(fmt.Sprintf("var %s%s", sanitizeName(s.Name), rhs))
	}
	return nil
}

func (c *Compiler) compileAssign(s *parser.AssignStmt) error {
	v, err := c.compileExpr(s.Value)
	if err != nil {
		return err
	}
	c.writeln(fmt.Sprintf("%s = %s", sanitizeName(s.Name), v))
	return nil
}

func (c *Compiler) compileReturn(s *parser.ReturnStmt) error {
	v, err := c.compileExpr(s.Value)
	if err != nil {
		return err
	}
	c.writeln("return " + v)
	return nil
}

func (c *Compiler) compileIf(stmt *parser.IfStmt) error {
	cond, err := c.compileExpr(stmt.Cond)
	if err != nil {
		return err
	}
	c.writeln("if " + cond + " {")
	c.indent++
	for _, s := range stmt.Then {
		if err := c.compileStmt(s); err != nil {
			return err
		}
	}
	c.indent--
	if stmt.ElseIf != nil {
		c.writeln("} else ")
		c.writeln("if ")
		sub := &parser.Statement{If: stmt.ElseIf}
		return c.compileStmt(sub)
	} else if len(stmt.Else) > 0 {
		c.writeln("} else {")
		c.indent++
		for _, s := range stmt.Else {
			if err := c.compileStmt(s); err != nil {
				return err
			}
		}
		c.indent--
		c.writeln("}")
	} else {
		c.writeln("}")
	}
	return nil
}

func (c *Compiler) compileWhile(stmt *parser.WhileStmt) error {
	cond, err := c.compileExpr(stmt.Cond)
	if err != nil {
		return err
	}
	c.writeln("while " + cond + " {")
	c.indent++
	for _, s := range stmt.Body {
		if err := c.compileStmt(s); err != nil {
			return err
		}
	}
	c.indent--
	c.writeln("}")
	return nil
}

func (c *Compiler) compileFor(stmt *parser.ForStmt) error {
	if stmt.RangeEnd != nil {
		start, err := c.compileExpr(stmt.Source)
		if err != nil {
			return err
		}
		end, err := c.compileExpr(stmt.RangeEnd)
		if err != nil {
			return err
		}
		c.writeln(fmt.Sprintf("for %s in %s..<%s {", sanitizeName(stmt.Name), start, end))
	} else {
		src, err := c.compileExpr(stmt.Source)
		if err != nil {
			return err
		}
		c.use("_iter")
		c.writeln(fmt.Sprintf("for %s in _iter(%s) {", sanitizeName(stmt.Name), src))
	}
	c.indent++
	for _, s := range stmt.Body {
		if err := c.compileStmt(s); err != nil {
			return err
		}
	}
	c.indent--
	c.writeln("}")
	return nil
}

func (c *Compiler) compileFunStmt(fn *parser.FunStmt) error {
	params := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		typ := "Any"
		if p.Type != nil {
			typ = swiftType(resolveTypeRef(p.Type))
		}
		params[i] = fmt.Sprintf("%s: %s", sanitizeName(p.Name), typ)
	}
	retType := "Void"
	if fn.Return != nil {
		retType = swiftType(resolveTypeRef(fn.Return))
	}
	c.writeln(fmt.Sprintf("func %s(%s) -> %s {", sanitizeName(fn.Name), strings.Join(params, ", "), retType))
	c.indent++
	for _, s := range fn.Body {
		if err := c.compileStmt(s); err != nil {
			return err
		}
	}
	c.indent--
	c.writeln("}")
	return nil
}

func (c *Compiler) compileTestBlock(t *parser.TestBlock) error {
	name := sanitizeName(t.Name)
	c.writeln(fmt.Sprintf("func %s() {", name))
	c.indent++
	for _, s := range t.Body {
		if err := c.compileStmt(s); err != nil {
			return err
		}
	}
	c.indent--
	c.writeln("}")
	return nil
}

func (c *Compiler) compileExpect(e *parser.ExpectStmt) error {
	expr, err := c.compileExpr(e.Value)
	if err != nil {
		return err
	}
	c.writeln(fmt.Sprintf("if !(%s) { fatalError(\"expect failed\") }", expr))
	return nil
}

func (c *Compiler) compileStreamDecl(s *parser.StreamDecl) error {
	c.writeln(fmt.Sprintf("struct %s {", s.Name))
	c.indent++
	for _, f := range s.Fields {
		typ := "Any"
		if f.Type != nil {
			typ = swiftType(resolveTypeRef(f.Type))
		}
		c.writeln(fmt.Sprintf("var %s: %s", sanitizeName(f.Name), typ))
	}
	c.indent--
	c.writeln("}")
	varName := strings.ToLower(s.Name) + "Stream"
	c.streams[s.Name] = varName
	c.writeln(fmt.Sprintf("let %s = Stream<%s>(\"%s\")", varName, s.Name, s.Name))
	return nil
}

func (c *Compiler) compileOnHandler(on *parser.OnHandler) error {
	streamVar := c.streams[on.Stream]
	name := fmt.Sprintf("_handler_%d", c.handlerCount)
	c.handlerCount++
	c.writeln(fmt.Sprintf("func %s(ev: %s) {", name, on.Stream))
	c.indent++
	c.writeln(fmt.Sprintf("let %s = ev", sanitizeName(on.Alias)))
	for _, s := range on.Body {
		if err := c.compileStmt(s); err != nil {
			return err
		}
	}
	c.indent--
	c.writeln("}")
	c.writeln(fmt.Sprintf("%s.register(%s)", streamVar, name))
	return nil
}

func (c *Compiler) compileEmit(e *parser.EmitStmt) error {
	streamVar := c.streams[e.Stream]
	fields := make([]string, len(e.Fields))
	for i, f := range e.Fields {
		v, err := c.compileExpr(f.Value)
		if err != nil {
			return err
		}
		fields[i] = fmt.Sprintf("%s: %s", sanitizeName(f.Name), v)
	}
	c.writeln(fmt.Sprintf("%s.append(%s(%s))", streamVar, e.Stream, strings.Join(fields, ", ")))
	return nil
}

func (c *Compiler) compileExpr(e *parser.Expr) (string, error) {
	return c.compileBinaryExpr(e.Binary)
}

func (c *Compiler) compileBinaryExpr(b *parser.BinaryExpr) (string, error) {
	expr, err := c.compileUnary(b.Left)
	if err != nil {
		return "", err
	}
	for _, op := range b.Right {
		right, err := c.compilePostfix(op.Right)
		if err != nil {
			return "", err
		}
		expr = fmt.Sprintf("(%s %s %s)", expr, op.Op, right)
	}
	return expr, nil
}

func (c *Compiler) compileUnary(u *parser.Unary) (string, error) {
	val, err := c.compilePostfix(u.Value)
	if err != nil {
		return "", err
	}
	for i := len(u.Ops) - 1; i >= 0; i-- {
		op := u.Ops[i]
		val = fmt.Sprintf("(%s%s)", op, val)
	}
	return val, nil
}

func (c *Compiler) compilePostfix(p *parser.PostfixExpr) (string, error) {
	expr, err := c.compilePrimary(p.Target)
	if err != nil {
		return "", err
	}
	for _, op := range p.Ops {
		if op.Call != nil {
			e, err := c.compileCallOp(expr, op.Call)
			if err != nil {
				return "", err
			}
			expr = e
		} else if op.Index != nil {
			idx := op.Index
			if idx.Colon != nil {
				// slicing not implemented
				start := "0"
				end := "0"
				if idx.Start != nil {
					start, err = c.compileExpr(idx.Start)
					if err != nil {
						return "", err
					}
				}
				if idx.End != nil {
					end, err = c.compileExpr(idx.End)
					if err != nil {
						return "", err
					}
				}
				c.use("_slice")
				expr = fmt.Sprintf("_slice(%s, %s, %s)", expr, start, end)
			} else {
				idxExpr, err := c.compileExpr(idx.Start)
				if err != nil {
					return "", err
				}
				c.use("_index")
				expr = fmt.Sprintf("_index(%s, %s)", expr, idxExpr)
			}
		}
	}
	return expr, nil
}

func (c *Compiler) compileCallOp(target string, call *parser.CallOp) (string, error) {
	args := make([]string, len(call.Args))
	for i, a := range call.Args {
		v, err := c.compileExpr(a)
		if err != nil {
			return "", err
		}
		args[i] = v
	}
	return fmt.Sprintf("%s(%s)", target, strings.Join(args, ", ")), nil
}

func (c *Compiler) compilePrimary(p *parser.Primary) (string, error) {
	switch {
	case p.Lit != nil:
		return c.compileLiteral(p.Lit)
	case p.List != nil:
		return c.compileListLiteral(p.List)
	case p.Map != nil:
		return c.compileMapLiteral(p.Map)
	case p.Call != nil:
		return c.compileCallExpr(p.Call)
	case p.Selector != nil:
		return strings.Join(append([]string{sanitizeName(p.Selector.Root)}, p.Selector.Tail...), "."), nil
	case p.FunExpr != nil:
		return c.compileFunExpr(p.FunExpr)
	case p.Match != nil:
		return c.compileMatchExpr(p.Match)
	case p.Generate != nil:
		return c.compileGenerateExpr(p.Generate)
	case p.Fetch != nil:
		return c.compileFetchExpr(p.Fetch)
	case p.Group != nil:
		expr, err := c.compileExpr(p.Group)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("(%s)", expr), nil
	default:
		return "", fmt.Errorf("unsupported expression")
	}
}

func (c *Compiler) compileCallExpr(call *parser.CallExpr) (string, error) {
	if lit, ok := interpreter.EvalPureCall(call, c.env); ok {
		return c.compileLiteral(lit)
	}
	args := make([]string, len(call.Args))
	for i, a := range call.Args {
		v, err := c.compileExpr(a)
		if err != nil {
			return "", err
		}
		args[i] = v
	}
	argStr := strings.Join(args, ", ")
	switch call.Func {
	case "print":
		return fmt.Sprintf("print(%s)", argStr), nil
	case "len":
		c.use("_len")
		return fmt.Sprintf("_len(%s)", argStr), nil
	default:
		return fmt.Sprintf("%s(%s)", sanitizeName(call.Func), argStr), nil
	}
}

func (c *Compiler) compileFunExpr(fn *parser.FunExpr) (string, error) {
	params := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		params[i] = sanitizeName(p.Name)
	}
	sub := &Compiler{env: c.env}
	sub.indent = 1
	if fn.ExprBody != nil {
		expr, err := sub.compileExpr(fn.ExprBody)
		if err != nil {
			return "", err
		}
		sub.writeln("return " + expr)
	} else {
		for _, s := range fn.BlockBody {
			if err := sub.compileStmt(s); err != nil {
				return "", err
			}
		}
	}
	body := indentBlock(sub.buf.String(), 1)
	code := "{ (" + strings.Join(params, ", ") + ") in\n" + body + "}"
	return code, nil
}

func (c *Compiler) compileLiteral(lit *parser.Literal) (string, error) {
	switch {
	case lit.Int != nil:
		return fmt.Sprintf("%d", *lit.Int), nil
	case lit.Float != nil:
		return fmt.Sprintf("%.6f", *lit.Float), nil
	case lit.Bool != nil:
		if *lit.Bool {
			return "true", nil
		}
		return "false", nil
	case lit.Str != nil:
		return fmt.Sprintf("%q", *lit.Str), nil
	default:
		return "0", nil
	}
}

func (c *Compiler) compileListLiteral(l *parser.ListLiteral) (string, error) {
	elems := make([]string, len(l.Elems))
	for i, e := range l.Elems {
		v, err := c.compileExpr(e)
		if err != nil {
			return "", err
		}
		elems[i] = v
	}
	return "[" + strings.Join(elems, ", ") + "]", nil
}

func (c *Compiler) compileMapLiteral(m *parser.MapLiteral) (string, error) {
	items := make([]string, len(m.Items))
	for i, it := range m.Items {
		k, err := c.compileExpr(it.Key)
		if err != nil {
			return "", err
		}
		v, err := c.compileExpr(it.Value)
		if err != nil {
			return "", err
		}
		items[i] = fmt.Sprintf("%s: %s", k, v)
	}
	return "[" + strings.Join(items, ", ") + "]", nil
}

func (c *Compiler) compileMatchExpr(m *parser.MatchExpr) (string, error) {
	target, err := c.compileExpr(m.Target)
	if err != nil {
		return "", err
	}
	var b strings.Builder
	b.WriteString("{ let _t = " + target + "\n")
	b.WriteString("switch _t {\n")
	for _, cs := range m.Cases {
		if isUnderscoreExpr(cs.Pattern) {
			b.WriteString("default:\n")
		} else {
			pat, err := c.compileExpr(cs.Pattern)
			if err != nil {
				return "", err
			}
			b.WriteString("case " + pat + ":\n")
		}
		res, err := c.compileExpr(cs.Result)
		if err != nil {
			return "", err
		}
		b.WriteString("    return " + res + "\n")
	}
	b.WriteString("}\n}")
	return b.String(), nil
}

func (c *Compiler) compileGenerateExpr(g *parser.GenerateExpr) (string, error) {
	promptField := ""
	for _, f := range g.Fields {
		if f.Name == "prompt" || f.Name == "text" {
			v, err := c.compileExpr(f.Value)
			if err != nil {
				return "", err
			}
			promptField = v
			break
		}
	}
	if g.Target == "text" {
		c.use("_gen_text")
		return fmt.Sprintf("_gen_text(%s)", promptField), nil
	} else if g.Target == "embedding" {
		c.use("_gen_embed")
		return fmt.Sprintf("_gen_embed(%s)", promptField), nil
	}
	c.use("_gen_struct")
	return fmt.Sprintf("_gen_struct(%s.self, %s)", g.Target, promptField), nil
}

func (c *Compiler) compileFetchExpr(f *parser.FetchExpr) (string, error) {
	urlStr, err := c.compileExpr(f.URL)
	if err != nil {
		return "", err
	}
	var withStr string
	if f.With != nil {
		w, err := c.compileExpr(f.With)
		if err != nil {
			return "", err
		}
		withStr = w
	} else {
		withStr = "nil"
	}
	c.use("_fetch")
	return fmt.Sprintf("_fetch(%s, %s)", urlStr, withStr), nil
}

func (c *Compiler) writeln(s string) {
	for i := 0; i < c.indent; i++ {
		c.buf.WriteString("        ")
	}
	c.buf.WriteString(s)
	c.buf.WriteByte('\n')
}

func indentBlock(s string, indent int) string {
	var out strings.Builder
	for _, line := range strings.Split(strings.TrimSuffix(s, "\n"), "\n") {
		for i := 0; i < indent; i++ {
			out.WriteString("        ")
		}
		out.WriteString(line)
		out.WriteByte('\n')
	}
	return out.String()
}

func (c *Compiler) use(name string) { c.helpers[name] = true }

func (c *Compiler) emitRuntime() {
	if len(c.helpers) == 0 {
		return
	}
	names := make([]string, 0, len(c.helpers))
	for n := range c.helpers {
		names = append(names, n)
	}
	for _, n := range names {
		switch n {
		case "_index":
			c.buf.WriteString(helperIndex)
		case "_len":
			c.buf.WriteString(helperLen)
		case "_iter":
			c.buf.WriteString(helperIter)
		case "_gen_text":
			c.buf.WriteString(helperGenText)
		case "_gen_embed":
			c.buf.WriteString(helperGenEmbed)
		case "_gen_struct":
			c.buf.WriteString(helperGenStruct)
		case "_fetch":
			c.buf.WriteString(helperFetch)
		case "_slice":
			c.buf.WriteString(helperSlice)
		case "_stream":
			c.buf.WriteString(helperStream)
		}
	}
}

// --- Runtime Helpers ---

const helperIndex = `func _index(_ v: Any, _ k: Any) -> Any {
    if let arr = v as? [Any] {
        guard let i = k as? Int else { fatalError("invalid list index") }
        var idx = i
        if idx < 0 { idx += arr.count }
        return arr[idx]
    }
    if let s = v as? String {
        guard let i = k as? Int else { fatalError("invalid string index") }
        var idx = i
        let chars = Array(s)
        if idx < 0 { idx += chars.count }
        return String(chars[idx])
    }
    if let m = v as? [String: Any] {
        return m[String(describing: k)]!
    }
    return 0
}
`

const helperLen = `func _len(_ v: Any) -> Int {
    if let arr = v as? [Any] { return arr.count }
    if let s = v as? String { return s.count }
    if let m = v as? [String: Any] { return m.count }
    return 0
}
`

const helperIter = `func _iter(_ v: Any) -> [Any] {
    if let arr = v as? [Any] { return arr }
    if let s = v as? String { return s.map { String($0) } }
    if let m = v as? [String: Any] { return Array(m.keys) }
    return []
}
`

const helperGenText = `func _gen_text(_ prompt: String) -> String {
    return prompt
}
`

const helperGenEmbed = `func _gen_embed(_ text: String) -> [Double] {
    return text.map { Double(Int($0.asciiValue ?? 0)) }
}
`

const helperGenStruct = `func _gen_struct<T: Decodable>(_ t: T.Type, _ prompt: String) -> T {
    let data = prompt.data(using: .utf8)!
    return try! JSONDecoder().decode(T.self, from: data)
}
`

const helperFetch = `func _fetch(_ url: String, _ opts: [String: Any]?) -> Any {
    // simple fetch using curl
    var args = ["-s"]
    if let method = opts?["method"] as? String { args += ["-X", method] }
    if let body = opts?["body"] {
        let jsonData = try! JSONSerialization.data(withJSONObject: body)
        args += ["-d", String(data: jsonData, encoding: .utf8)!]
    }
    args.append(url)
    let p = Process()
    p.executableURL = URL(fileURLWithPath: "/usr/bin/curl")
    p.arguments = args
    let out = Pipe()
    p.standardOutput = out
    try! p.run()
    p.waitUntilExit()
    let data = out.fileHandleForReading.readDataToEndOfFile()
    return String(data: data, encoding: .utf8)!
}
`

const helperSlice = `func _slice(_ v: Any, _ start: Int, _ end: Int) -> Any {
    if let arr = v as? [Any] { return Array(arr[start..<end]) }
    if let s = v as? String {
        let chars = Array(s)[start..<end]
        return String(chars)
    }
    return v
}
`

const helperStream = `class Stream<T> {
    var name: String
    var handlers: [(T) -> Void] = []
    init(_ name: String) { self.name = name }
    func append(_ data: T) {
        for h in handlers { h(data) }
    }
    func register(_ h: @escaping (T) -> Void) {
        handlers.append(h)
    }
}
`

func sanitizeName(name string) string {
	var b strings.Builder
	for i, ch := range name {
		if i == 0 {
			if !isLetter(ch) && ch != '_' {
				b.WriteByte('_')
			}
		} else {
			if !isLetter(ch) && !isDigit(ch) && ch != '_' {
				b.WriteByte('_')
				continue
			}
		}
		b.WriteRune(ch)
	}
	return b.String()
}

func isLetter(r rune) bool { return r == '_' || ('A' <= r && r <= 'Z') || ('a' <= r && r <= 'z') }
func isDigit(r rune) bool  { return '0' <= r && r <= '9' }

func resolveTypeRef(t *parser.TypeRef) types.Type {
	if t == nil {
		return types.AnyType{}
	}
	if t.Fun != nil {
		params := make([]types.Type, len(t.Fun.Params))
		for i, p := range t.Fun.Params {
			params[i] = resolveTypeRef(p)
		}
		var ret types.Type = types.VoidType{}
		if t.Fun.Return != nil {
			ret = resolveTypeRef(t.Fun.Return)
		}
		return types.FuncType{Params: params, Return: ret}
	}
	if t.Generic != nil {
		name := t.Generic.Name
		args := t.Generic.Args
		switch name {
		case "list":
			if len(args) == 1 {
				return types.ListType{Elem: resolveTypeRef(args[0])}
			}
		case "map":
			if len(args) == 2 {
				return types.MapType{Key: resolveTypeRef(args[0]), Value: resolveTypeRef(args[1])}
			}
		}
		return types.AnyType{}
	}
	if t.Simple != nil {
		switch *t.Simple {
		case "int":
			return types.IntType{}
		case "float":
			return types.FloatType{}
		case "string":
			return types.StringType{}
		case "bool":
			return types.BoolType{}
		default:
			return types.AnyType{}
		}
	}
	return types.AnyType{}
}

func swiftType(t types.Type) string {
	switch v := t.(type) {
	case types.IntType:
		return "Int"
	case types.FloatType:
		return "Double"
	case types.BoolType:
		return "Bool"
	case types.StringType:
		return "String"
	case types.ListType:
		return "[" + swiftType(v.Elem) + "]"
	case types.MapType:
		return "[String: " + swiftType(v.Value) + "]"
	default:
		return "Any"
	}
}

func isUnderscoreExpr(e *parser.Expr) bool {
	if e == nil {
		return false
	}
	if len(e.Binary.Right) != 0 {
		return false
	}
	u := e.Binary.Left
	if len(u.Ops) != 0 {
		return false
	}
	p := u.Value
	if len(p.Ops) != 0 {
		return false
	}
	if p.Target.Selector != nil && p.Target.Selector.Root == "_" && len(p.Target.Selector.Tail) == 0 {
		return true
	}
	return false
}
