// generated by mochi-run, do not edit

# Mochi Source Files for LLM Ingestion

> Version: `0.2.6`

This document includes all core source files used by the Mochi interpreter and runtime toolchain.

## Overview

- **cmd/mochi/main.go**: Entry point of the Mochi CLI tool.
- **diagnostic/diagnostic.go**: Structured error reporting with source hints.
- **parser/parser.go**: Top-down recursive descent parser.
- **parser/errors.go**: Parser error handling logic.
- **ast/ast.go**: AST node types.
- **ast/convert.go**: Converts parser output to typed AST.
- **types/env.go**: Type environment and symbol resolution.
- **types/check.go**: Static type checker implementation.
- **types/errors.go**: Type checker error definitions.
- **interpreter/interpreter.go**: Interpreter that executes AST.
- **interpreter/errors.go**: Runtime error types.
- **golden/golden.go**: Shared golden file test framework.

---

## cmd/mochi/main.go

```go
package main

import (
        "errors"
        "fmt"
        "os"
        "runtime"
        "time"

	"github.com/alexflint/go-arg"
	"github.com/fatih/color"

	"mochi/ast"
        "mochi/interpreter"
        "mochi/mcp"
        "mochi/parser"
        "mochi/repl"
        "mochi/types"
)

var (
	version   = "dev"
	gitCommit = "unknown"
	buildTime = "unknown"
)

type CLI struct {
	Run     *RunCmd   `arg:"subcommand:run" help:"Run a Mochi source file"`
	Test    *TestCmd  `arg:"subcommand:test" help:"Run test blocks inside a Mochi source file"`
	Repl    *ReplCmd  `arg:"subcommand:repl" help:"Start an interactive REPL session"`
	Serve   *ServeCmd `arg:"subcommand:serve" help:"Start MCP server over stdio"`
	Version bool      `arg:"--version" help:"Print version info and exit"`
}

type RunCmd struct {
        File     string `arg:"positional,required" help:"Path to .mochi source file"`
        PrintAST bool   `arg:"--ast" help:"Print parsed AST in Lisp format"`
        Debug    bool   `arg:"--debug" help:"Enable debug output"`
}

type TestCmd struct {
        File  string `arg:"positional,required" help:"Path to .mochi source file"`
        Debug bool   `arg:"--debug" help:"Enable debug output"`
}

type ReplCmd struct{}
type ServeCmd struct{}

var (
	cError = color.New(color.FgRed, color.Bold).SprintFunc()
	cTitle = color.New(color.FgCyan, color.Bold).SprintFunc()
)

func main() {
	var cli CLI
	arg.MustParse(&cli)
	color.NoColor = false

	switch {
	case cli.Version:
		printVersion()
	case cli.Repl != nil:
		repl := repl.New(os.Stdout, version)
		repl.Run()
	case cli.Run != nil:
		if err := runFile(cli.Run); err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", cError("error:"), err)
			os.Exit(1)
		}
	case cli.Test != nil:
		if err := runTests(cli.Test); err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", cError("test failed:"), err)
			os.Exit(1)
		}
	case cli.Serve != nil:
		if err := mcp.ServeStdio(); err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", cError("mcp:"), err)
			os.Exit(1)
		}
	default:
		arg.MustParse(&cli).WriteHelp(os.Stderr)
		os.Exit(2)
	}
}

func printVersion() {
	fmt.Printf("%s v%s (%s, built %s on %s/%s)\n",
		cTitle("Mochi"),
		version,
		gitCommit,
		humanBuildTime(),
		runtime.GOOS,
		runtime.GOARCH,
	)
}

func humanBuildTime() string {
	t, err := time.Parse(time.RFC3339, buildTime)
	if err != nil {
		return buildTime
	}
	return t.Format("Mon Jan 02 15:04:05 2006")
}

func runFile(cmd *RunCmd) error {
	prog, err := parseOrPrintError(cmd.File)
	if err != nil {
		return err
	}
	if cmd.PrintAST {
		fmt.Println(ast.FromProgram(prog).String())
		return nil
	}
	env := types.NewEnv(nil)
	if errs := types.Check(prog, env); len(errs) > 0 {
		fmt.Fprintln(os.Stderr, cError("type error:"))
		for i, err := range errs {
			fmt.Fprintf(os.Stderr, "  %2d. %v\n", i+1, err)
		}
		return fmt.Errorf("aborted due to type errors")
	}
        return interpreter.New(prog, env).Run()
}

func runTests(cmd *TestCmd) error {
	prog, err := parseOrPrintError(cmd.File)
	if err != nil {
		return err
	}
	env := types.NewEnv(nil)
	if errs := types.Check(prog, env); len(errs) > 0 {
		fmt.Fprintln(os.Stderr, cError("type error:"))
		for i, err := range errs {
			fmt.Fprintf(os.Stderr, "  %2d. %v\n", i+1, err)
		}
		return fmt.Errorf("aborted due to type errors")
	}
        return interpreter.New(prog, env).Test()
}

func parseOrPrintError(path string) (*parser.Program, error) {
	prog, err := parser.Parse(path)
	if err != nil {
		var pathErr *os.PathError
		if errors.As(err, &pathErr) && os.IsNotExist(pathErr.Err) {
			return nil, fmt.Errorf("file not found: %s", path)
		}
		return nil, fmt.Errorf("parse error:\n  %v", err)
	}
	return prog, nil
}

```

## diagnostic/diagnostic.go

```go
package diagnostic

import (
	"fmt"
	"os"
	"strings"

	"github.com/alecthomas/participle/v2/lexer"
	"github.com/fatih/color"
)

func init() {
	color.NoColor = true // Disable color by default
}

var (
	red    = color.New(color.FgRed, color.Bold).SprintFunc()
	yellow = color.New(color.FgYellow).SprintFunc()
	gray   = color.New(color.FgHiBlack).SprintFunc()
)

// Template represents a reusable diagnostic pattern with code, message, and help text.
type Template struct {
	Code    string // e.g. "T004"
	Message string // Format string, e.g. "expected %v but got %v"
	Help    string // Optional help message
}

// New instantiates a Diagnostic from a Template.
func (t Template) New(pos lexer.Position, args ...any) Diagnostic {
	return New(t.Code, pos, fmt.Sprintf(t.Message, args...), t.Help)
}

// Diagnostic represents a structured, position-aware compiler message.
type Diagnostic struct {
	Code string         // e.g. "E1001"
	Pos  lexer.Position // Source file, line, and column
	Msg  string         // Main error message
	Help string         // Optional help or suggestion
}

func (d Diagnostic) Error() string {
	return d.Format()
}

func (d Diagnostic) Format() string {
	src, _ := os.ReadFile(d.Pos.Filename)
	lines := strings.Split(string(src), "\n")

	var lineText, marker string
	if d.Pos.Line > 0 && int(d.Pos.Line) <= len(lines) {
		lineText = lines[d.Pos.Line-1]
		if d.Pos.Column > 0 && int(d.Pos.Column) <= len(lineText)+1 {
			marker = strings.Repeat(" ", int(d.Pos.Column)-1) + "^"
		}
	}

	out := []string{
		fmt.Sprintf("%s: %s", red("error["+d.Code+"]"), d.Msg),
		fmt.Sprintf("  --> %s:%d:%d", d.Pos.Filename, d.Pos.Line, d.Pos.Column),
	}

	if lineText != "" {
		lineno := fmt.Sprintf("%3d", d.Pos.Line)
		out = append(out, "",
			fmt.Sprintf("%s | %s", gray(lineno), lineText),
			fmt.Sprintf("    | %s", red(marker)),
		)
	}

	if d.Help != "" {
		out = append(out, "", yellow("help:"), "  "+d.Help)
	}

	return strings.Join(out, "\n")
}

// New creates a new Diagnostic.
func New(code string, pos lexer.Position, msg, help string) Diagnostic {
	return Diagnostic{
		Code: code,
		Pos:  pos,
		Msg:  msg,
		Help: help,
	}
}

/*
// Wrap returns a Diagnostic as an error.
func Wrap(code string, pos lexer.Position, msg, help string) error {
	return New(code, pos, msg, help)
}
*/

```

## parser/parser.go

```go
package parser

import (
	"fmt"
	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

// --- Mochi Lexer ---
var mochiLexer = lexer.MustSimple([]lexer.SimpleRule{
	{Name: "Comment", Pattern: `//[^\n]*|/\*([^*]|\*+[^*/])*\*+/`},
	{Name: "Bool", Pattern: `\b(true|false)\b`},
	{Name: "Keyword", Pattern: `\b(test|expect|agent|intent|on|stream|fun|return|let|if|else|for|in)\b`},
	{Name: "Ident", Pattern: `[\p{L}\p{So}_][\p{L}\p{So}\p{N}_]*`},
	{Name: "Float", Pattern: `\d+\.\d+`},
	{Name: "Int", Pattern: `\d+`},
	{Name: "String", Pattern: `"(?:\\.|[^"])*"`},
	{Name: "Punct", Pattern: `==|!=|<=|>=|&&|\|\||=>|\.\.|[-+*/%=<>!{}\[\](),.:]`},
	{Name: "Whitespace", Pattern: `[ \t\n\r]+`},
})

// --- Program Structure ---

type Program struct {
	Pos        lexer.Position
	Statements []*Statement `parser:"@@*"`
}

type Statement struct {
	Pos    lexer.Position
	Test   *TestBlock  `parser:"@@"`
	Expect *ExpectStmt `parser:"| @@"`
	Agent  *AgentDecl  `parser:"| @@"`
	Stream *StreamDecl `parser:"| @@"`
	On     *OnHandler  `parser:"| @@"`
	Let    *LetStmt    `parser:"| @@"`
	Assign *AssignStmt `parser:"| @@"`
	Fun    *FunStmt    `parser:"| @@"`
	Return *ReturnStmt `parser:"| @@"`
	If     *IfStmt     `parser:"| @@"`
	For    *ForStmt    `parser:"| @@"`
	Expr   *ExprStmt   `parser:"| @@"`
}

// --- Test and Expect ---

type TestBlock struct {
	Pos  lexer.Position
	Name string       `parser:"'test' @String"`
	Body []*Statement `parser:"'{' @@* '}'"`
}

type ExpectStmt struct {
	Pos   lexer.Position
	Value *Expr `parser:"'expect' @@"`
}

// --- If Statement ---

type IfStmt struct {
	Pos    lexer.Position
	Cond   *Expr        `parser:"'if' @@"`
	Then   []*Statement `parser:"'{' @@* '}'"`
	ElseIf *IfStmt      `parser:"[ 'else' @@"`
	Else   []*Statement `parser:"| 'else' '{' @@* '}' ]"`
}

// --- For Statement ---

type ForStmt struct {
	Pos      lexer.Position
	Name     string       `parser:"'for' @Ident 'in'"`
	Source   *Expr        `parser:"@@"`          // expression to iterate
	RangeEnd *Expr        `parser:"[ '..' @@ ]"` // optional range end
	Body     []*Statement `parser:"'{' @@* '}'"`
}

// --- Type System ---

type TypeRef struct {
	Fun     *FunType     `parser:"@@"`
	Generic *GenericType `parser:"| @@"`
	Simple  *string      `parser:"| @Ident"`
}

type GenericType struct {
	Name string     `parser:"@Ident '<'"`
	Args []*TypeRef `parser:"@@ { ',' @@ } '>'"`
}

type FunType struct {
	Params []*TypeRef `parser:"'fun' '(' [ @@ { ',' @@ } ] ')'"`
	Return *TypeRef   `parser:"[ ':' @@ ]"`
}

// --- Declarations ---

type LetStmt struct {
	Pos   lexer.Position
	Name  string   `parser:"'let' @Ident"`
	Type  *TypeRef `parser:"[ ':' @@ ]"`
	Value *Expr    `parser:"[ '=' @@ ]"`
}

type AssignStmt struct {
	Pos   lexer.Position
	Name  string `parser:"@Ident '='"`
	Value *Expr  `parser:"@@"`
}

type FunStmt struct {
	Pos    lexer.Position
	Name   string       `parser:"'fun' @Ident"`
	Params []*Param     `parser:"'(' [ @@ { ',' @@ } ] ')'"`
	Return *TypeRef     `parser:"[ ':' @@ ]"`
	Body   []*Statement `parser:"'{' @@* '}'"`
}

type ReturnStmt struct {
	Pos   lexer.Position
	Value *Expr `parser:"'return' @@"`
}

type Param struct {
	Name string   `parser:"@Ident"`
	Type *TypeRef `parser:"[ ':' @@ ]"`
}

type ExprStmt struct {
	Pos  lexer.Position
	Expr *Expr `parser:"@@"`
}

// --- Expressions ---

type Expr struct {
	Pos    lexer.Position
	Binary *BinaryExpr `parser:"@@"`
}

type BinaryExpr struct {
	Left  *Unary      `parser:"@@"`
	Right []*BinaryOp `parser:"@@*"`
}

type BinaryOp struct {
	Pos   lexer.Position
	Op    string       `parser:"@('==' | '!=' | '<' | '<=' | '>' | '>=' | '+' | '-' | '*' | '/' | '%')"`
	Right *PostfixExpr `parser:"@@"`
}

type Unary struct {
	Pos   lexer.Position
	Ops   []string     `parser:"{@('-' | '!')}"`
	Value *PostfixExpr `parser:"@@"`
}

type PostfixExpr struct {
	Target *Primary   `parser:"@@"`
	Index  []*IndexOp `parser:"@@*"`
}

type IndexOp struct {
	Pos   lexer.Position
	Start *Expr   `parser:"'[' [ @@ "`
	Colon *string `parser:"[ @':'"`
	End   *Expr   `parser:"  @@ ] ] ']'"`
}

type ListLiteral struct {
	Elems []*Expr `parser:"'[' [ @@ { ',' @@ } ] [ ',' ]? ']'"`
}

type MapLiteral struct {
	Items []*MapEntry `parser:"'{' [ @@ { ',' @@ } ] [ ',' ]? '}'"`
}

type MapEntry struct {
	Pos   lexer.Position
	Key   *Expr `parser:"@@ ':'"`
	Value *Expr `parser:"@@"`
}

type Primary struct {
	Pos      lexer.Position
	FunExpr  *FunExpr      `parser:"@@"`
	Call     *CallExpr     `parser:"| @@"`
	Selector *SelectorExpr `parser:"| @@"`
	List     *ListLiteral  `parser:"| @@"`
	Map      *MapLiteral   `parser:"| @@"`
	Lit      *Literal      `parser:"| @@"`
	Group    *Expr         `parser:"| '(' @@ ')'"`
}

type FunExpr struct {
	Pos       lexer.Position
	Params    []*Param     `parser:"'fun' '(' [ @@ { ',' @@ } ] ')'"`
	Return    *TypeRef     `parser:"[ ':' @@ ]"`
	ExprBody  *Expr        `parser:"'=>' @@"`
	BlockBody []*Statement `parser:"| '{' @@* '}'"`
}

// --- Atoms ---

type SelectorExpr struct {
	Root string   `parser:"@Ident"`
	Tail []string `parser:"{ '.' @Ident }"`
}

type CallExpr struct {
	Pos  lexer.Position
	Func string  `parser:"@Ident '('"`
	Args []*Expr `parser:"[ @@ { ',' @@ } ] ')'"`
}

type Literal struct {
	Pos   lexer.Position
	Int   *int     `parser:"@Int"`
	Float *float64 `parser:"| @Float"`
	Bool  *bool    `parser:"| @('true' | 'false')"`
	Str   *string  `parser:"| @String"`
}

// --- Stream / Struct ---

type StreamDecl struct {
        Pos    lexer.Position
        Name   string         `parser:"'stream' @Ident"`
        Fields []*StreamField `parser:"'{' @@* '}'"`
}

type StreamField struct {
        Pos  lexer.Position
        Name string   `parser:"@Ident ':'"`
        Type *TypeRef `parser:"@@"`
}

// --- On Handler ---

type OnHandler struct {
	Pos    lexer.Position
	Stream string       `parser:"'on' @Ident 'as'"`
	Alias  string       `parser:"@Ident"`
	Body   []*Statement `parser:"'{' @@* '}'"`
}

// --- Agent DSL ---

type AgentDecl struct {
	Pos  lexer.Position
	Name string        `parser:"'agent' @Ident"`
	Body []*AgentBlock `parser:"'{' @@* '}'"`
}

type AgentBlock struct {
	Let    *LetStmt    `parser:"@@"`
	Assign *AssignStmt `parser:"| @@"`
	On     *OnHandler  `parser:"| @@"`
	Intent *IntentDecl `parser:"| @@"`
}

type IntentDecl struct {
	Pos    lexer.Position
	Name   string       `parser:"'intent' @Ident"`
	Params []*Param     `parser:"'(' [ @@ { ',' @@ } ] ')'"`
	Return *TypeRef     `parser:"[ ':' @@ ]"`
	Body   []*Statement `parser:"'{' @@* '}'"`
}

// --- Parser Instance ---

var Parser = participle.MustBuild[Program](
	participle.Lexer(mochiLexer),
	participle.Elide("Whitespace", "Comment"),
	participle.Unquote("String"),
	participle.UseLookahead(999),
)

func ParseString(src string) (*Program, error) {
	prog, err := Parser.ParseString("", src)
	if err != nil {
		return nil, fmt.Errorf("parse error: %w", err)
	}
	return prog, nil
}

```

## parser/errors.go

```go
package parser

import (
	"errors"
	"os"
	"strings"

	"github.com/alecthomas/participle/v2/lexer"
	"mochi/diagnostic"
)

// Parse loads and parses a Mochi source file.
func Parse(path string) (*Program, error) {
	src, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	prog, err := Parser.ParseString(path, string(src))
	if err != nil {
		return nil, wrapParseError(path, err)
	}
	return prog, nil
}

// wrapParseError upgrades raw participle errors into structured diagnostics.
func wrapParseError(filename string, err error) error {
	var posErr interface{ Position() lexer.Position }
	if !errors.As(err, &posErr) {
		return err
	}
	pos := posErr.Position()
	code, help := suggestFix(err.Error())
	return diagnostic.New(code, pos, err.Error(), help)
}

// suggestFix returns a (diagnosticCode, helpText) pair for known parsing errors.
func suggestFix(msg string) (string, string) {
	msg = strings.ToLower(msg)

	switch {
	// --- Block and EOF Errors ---
	case containsAny(msg, `expected "}"`, `expected "{"`, "unexpected eof"):
		return "P001", "Check for a missing `{` or `}` to close the block."

	case strings.Contains(msg, "unexpected eof"):
		return "P002", "Expression or closing delimiter might be missing."

	// --- Function Body Errors ---
	case strings.Contains(msg, `expected "{" statement* "}"`):
		return "P010", "Function bodies must be enclosed in `{ ... }`."

	case containsAll(msg, "expected", `"{"`, "=>"):
		return "P011", "`=>` cannot replace a full `{}` block in function bodies."

	// --- Expression Errors ---
	case containsAny(msg, "expected expression", "expected primary"):
		return "P020", "An expression was expected here. Check syntax."

	// --- Variable & Identifier Issues ---
	case strings.Contains(msg, "expected identifier"):
		return "P030", "A variable or function name is required."

	case containsAll(msg, `unexpected token ":"`, "let"):
		return "P031", "`let` must be followed by a variable name."

	// --- String and Literal Errors ---
	case containsAny(msg, "unterminated string", "invalid input text", `"unterminated`):
		return "P040", "String literals must be properly closed with a `\"`."

	// --- Punctuation Errors ---
	case containsAll(msg, `unexpected token "*"`, "expected primary"):
		return "P050", "`*` is not allowed here. Did you mean to multiply? Use full expression."

	case strings.Contains(msg, `expected ","`):
		return "P051", "Separate function arguments or list elements with commas."

	case containsAny(msg, `expected "("`, `expected ")"`):
		return "P052", "Unbalanced parentheses. Check for missing `(` or `)`."

	case containsAll(msg, `unexpected token "}"`, "expected expression"):
		return "P053", "`}` found unexpectedly. Check for incomplete expression."

	case containsAll(msg, `unexpected token ":"`, `expected ")"`, `"{"`):
		return "P054", "Check for misused colon. Function parameters must use correct syntax: (name: type)."

	case strings.Contains(msg, `unexpected token "."`):
		return "P055", "Stray `.` dot — expected a selector after it. Did you forget an identifier?"

	case strings.Contains(msg, `unexpected token "let"`):
		return "P056", "Unexpected `let` — remove redundant declaration keyword."

	// --- Unknown or Unclassified ---
	default:
		return "P999", "Parse error occurred. Check syntax near this location."
	}
}

// containsAll returns true if all substrings appear in s.
func containsAll(s string, parts ...string) bool {
	for _, p := range parts {
		if !strings.Contains(s, p) {
			return false
		}
	}
	return true
}

// containsAny returns true if any substring appears in s.
func containsAny(s string, parts ...string) bool {
	for _, p := range parts {
		if strings.Contains(s, p) {
			return true
		}
	}
	return false
}

/*
var reserved = map[string]struct{}{
	"let": {}, "fun": {}, "if": {}, "else": {}, "for": {}, "return": {},
	"true": {}, "false": {}, "stream": {}, "agent": {}, "test": {}, "expect": {},
	"on": {}, "intent": {},
}

func isReserved(name string) bool {
	_, found := reserved[name]
	return found
}
*/

```

## ast/ast.go

```go
package ast

import (
	"fmt"
	"regexp"
	"strings"
)

// Node is a simplified, uniform AST representation (inspired by Lisp)
type Node struct {
	Kind     string
	Value    any
	Children []*Node
}

// Print writes a compact Lisp-like tree to stdout
func (n *Node) Print(indent string) {
	fmt.Print(n.String())
}

// String returns the pretty-printed AST as a compact Lisp-like string
func (n *Node) String() string {
	var b strings.Builder
	write(&b, n, "")
	b.WriteString("\n")
	return b.String()
}

// write is a helper to recursively pretty-print the AST
func write(b *strings.Builder, n *Node, indent string) {
	b.WriteString(indent + "(" + n.Kind)
	if n.Value != nil {
		b.WriteString(" " + formatValue(n.Value))
	}

	if len(n.Children) == 0 {
		b.WriteString(")")
		return
	}

	// Check if all children are leaf nodes
	allLeaf := true
	for _, c := range n.Children {
		if len(c.Children) > 0 {
			allLeaf = false
			break
		}
	}

	if allLeaf {
		for _, c := range n.Children {
			b.WriteString(" (" + c.Kind)
			if c.Value != nil {
				b.WriteString(" " + formatValue(c.Value))
			}
			b.WriteString(")")
		}
		b.WriteString(")")
	} else {
		b.WriteString("\n")
		for _, c := range n.Children {
			write(b, c, indent+"  ")
			b.WriteString("\n")
		}
		b.WriteString(indent + ")")
	}
}

// safeIdent matches values that don't need quoting in AST output.
// Now includes common operators.
var safeIdent = regexp.MustCompile(`^[a-zA-Z0-9._\-+=*/<>!%&|^~]+$`)

// formatValue returns a string representation of a value,
// quoting only if necessary.
func formatValue(v any) string {
	switch s := v.(type) {
	case string:
		if safeIdent.MatchString(s) {
			return s
		}
		return fmt.Sprintf("%q", s)
	default:
		return fmt.Sprintf("%v", v)
	}
}

```

## ast/convert.go

```go
package ast

import "mochi/parser"

func FromProgram(p *parser.Program) *Node {
	root := &Node{Kind: "program"}
	for _, stmt := range p.Statements {
		root.Children = append(root.Children, FromStatement(stmt))
	}
	return root
}

func FromStatement(s *parser.Statement) *Node {
	switch {
	case s.Let != nil:
		n := &Node{Kind: "let", Value: s.Let.Name}
		if s.Let.Type != nil {
			n.Children = append(n.Children, FromTypeRef(s.Let.Type))
		}
		if s.Let.Value != nil {
			n.Children = append(n.Children, FromExpr(s.Let.Value))
		}
		return n

	case s.Assign != nil:
		return &Node{
			Kind:  "assign",
			Value: s.Assign.Name,
			Children: []*Node{
				FromExpr(s.Assign.Value),
			},
		}

	case s.Fun != nil:
		n := &Node{Kind: "fun", Value: s.Fun.Name}
		for _, param := range s.Fun.Params {
			pn := &Node{Kind: "param", Value: param.Name}
			if param.Type != nil {
				pn.Children = append(pn.Children, FromTypeRef(param.Type))
			}
			n.Children = append(n.Children, pn)
		}
		if s.Fun.Return != nil {
			n.Children = append(n.Children, FromTypeRef(s.Fun.Return))
		}
		n.Children = append(n.Children, mapStatements(s.Fun.Body)...)
		return n

	case s.Return != nil:
		return &Node{Kind: "return", Children: []*Node{FromExpr(s.Return.Value)}}

	case s.Expr != nil:
		return FromExpr(s.Expr.Expr)

	case s.If != nil:
		return fromIfStmt(s.If)

	case s.For != nil:
		return fromForStmt(s.For)

	case s.Agent != nil:
		n := &Node{Kind: "agent", Value: s.Agent.Name}
		for _, block := range s.Agent.Body {
			switch {
			case block.Let != nil:
				n.Children = append(n.Children, FromStatement(&parser.Statement{Let: block.Let}))
			case block.Assign != nil:
				n.Children = append(n.Children, FromStatement(&parser.Statement{Assign: block.Assign}))
			case block.On != nil:
				n.Children = append(n.Children, fromOnHandler(block.On))
			case block.Intent != nil:
				n.Children = append(n.Children, fromIntent(block.Intent))
			}
		}
		return n

	case s.On != nil:
		return fromOnHandler(s.On)

	case s.Stream != nil:
		n := &Node{Kind: "stream", Value: s.Stream.Name}
		for _, f := range s.Stream.Fields {
			n.Children = append(n.Children, fromStreamField(f))
		}
		return n

	case s.Test != nil:
		n := &Node{Kind: "test", Value: s.Test.Name}
		n.Children = append(n.Children, mapStatements(s.Test.Body)...)
		return n

	case s.Expect != nil:
		return &Node{Kind: "expect", Children: []*Node{FromExpr(s.Expect.Value)}}

	default:
		return &Node{Kind: "unknown"}
	}
}

// --- Control Flow Helpers ---

func fromIfStmt(stmt *parser.IfStmt) *Node {
	n := &Node{Kind: "if", Children: []*Node{FromExpr(stmt.Cond)}}

	thenBlock := &Node{Kind: "block", Children: mapStatements(stmt.Then)}
	n.Children = append(n.Children, thenBlock)

	if stmt.ElseIf != nil {
		n.Children = append(n.Children, fromIfStmt(stmt.ElseIf))
	} else if stmt.Else != nil {
		elseBlock := &Node{Kind: "block", Children: mapStatements(stmt.Else)}
		n.Children = append(n.Children, elseBlock)
	}
	return n
}

func fromForStmt(f *parser.ForStmt) *Node {
	n := &Node{Kind: "for", Value: f.Name}

	if f.RangeEnd != nil {
		// Range loop: for i in start..end
		n.Children = append(n.Children, &Node{
			Kind:     "range",
			Children: []*Node{FromExpr(f.Source), FromExpr(f.RangeEnd)},
		})
	} else {
		// Collection loop: for x in expr
		n.Children = append(n.Children, &Node{
			Kind:     "in",
			Children: []*Node{FromExpr(f.Source)},
		})
	}

	n.Children = append(n.Children, &Node{
		Kind:     "block",
		Children: mapStatements(f.Body),
	})
	return n
}

// --- DSL Helpers ---

func fromOnHandler(h *parser.OnHandler) *Node {
	return &Node{
		Kind:     "on",
		Value:    h.Stream,
		Children: mapStatements(h.Body),
	}
}

func fromIntent(i *parser.IntentDecl) *Node {
	n := &Node{Kind: "intent", Value: i.Name}
	for _, param := range i.Params {
		pn := &Node{Kind: "param", Value: param.Name}
		if param.Type != nil {
			pn.Children = append(pn.Children, FromTypeRef(param.Type))
		}
		n.Children = append(n.Children, pn)
	}
	if i.Return != nil {
		n.Children = append(n.Children, FromTypeRef(i.Return))
	}
	n.Children = append(n.Children, mapStatements(i.Body)...)
	return n
}

func fromStreamField(f *parser.StreamField) *Node {
	if f.Simple != nil {
		return &Node{Kind: "field", Value: f.Simple.Name + ":" + f.Simple.Type}
	}
	if f.Nested != nil {
		n := &Node{Kind: "field", Value: f.Nested.Name + ":" + f.Nested.Type}
		for _, sub := range f.Nested.Body.Fields {
			n.Children = append(n.Children, fromStreamField(sub))
		}
		return n
	}
	return &Node{Kind: "field", Value: "unknown"}
}

func mapStatements(stmts []*parser.Statement) []*Node {
	var out []*Node
	for _, s := range stmts {
		out = append(out, FromStatement(s))
	}
	return out
}

// --- Expression Conversion ---

func FromExpr(e *parser.Expr) *Node {
	n := FromUnary(e.Binary.Left)
	for _, op := range e.Binary.Right {
		n = &Node{Kind: "binary", Value: op.Op, Children: []*Node{n, FromPostfixExpr(op.Right)}}
	}
	return n
}

func FromUnary(u *parser.Unary) *Node {
	n := FromPostfixExpr(u.Value)
	for i := len(u.Ops) - 1; i >= 0; i-- {
		n = &Node{Kind: "unary", Value: u.Ops[i], Children: []*Node{n}}
	}
	return n
}

func FromPostfixExpr(p *parser.PostfixExpr) *Node {
	n := FromPrimary(p.Target)
	for _, op := range p.Index {
		idx := &Node{Kind: "index", Children: []*Node{n}}
		if op.Colon == nil {
			if op.Start != nil {
				idx.Children = append(idx.Children, FromExpr(op.Start))
			}
		} else {
			if op.Start != nil {
				idx.Children = append(idx.Children, &Node{Kind: "start", Children: []*Node{FromExpr(op.Start)}})
			}
			if op.End != nil {
				idx.Children = append(idx.Children, &Node{Kind: "end", Children: []*Node{FromExpr(op.End)}})
			}
		}
		n = idx
	}
	return n
}

func FromPrimary(p *parser.Primary) *Node {
	switch {
	case p.FunExpr != nil:
		n := &Node{Kind: "funexpr"}
		for _, param := range p.FunExpr.Params {
			pn := &Node{Kind: "param", Value: param.Name}
			if param.Type != nil {
				pn.Children = append(pn.Children, FromTypeRef(param.Type))
			}
			n.Children = append(n.Children, pn)
		}
		if p.FunExpr.Return != nil {
			n.Children = append(n.Children, FromTypeRef(p.FunExpr.Return))
		}
		if p.FunExpr.ExprBody != nil {
			n.Children = append(n.Children, FromExpr(p.FunExpr.ExprBody))
		} else if len(p.FunExpr.BlockBody) > 0 {
			block := &Node{Kind: "block", Children: mapStatements(p.FunExpr.BlockBody)}
			n.Children = append(n.Children, block)
		}
		return n

	case p.Call != nil:
		n := &Node{Kind: "call", Value: p.Call.Func}
		for _, arg := range p.Call.Args {
			n.Children = append(n.Children, FromExpr(arg))
		}
		return n

	case p.Selector != nil:
		root := &Node{Kind: "selector", Value: p.Selector.Root}
		for _, field := range p.Selector.Tail {
			root = &Node{Kind: "selector", Value: field, Children: []*Node{root}}
		}
		return root

	case p.List != nil:
		n := &Node{Kind: "list"}
		for _, el := range p.List.Elems {
			n.Children = append(n.Children, FromExpr(el))
		}
		return n

	case p.Map != nil:
		n := &Node{Kind: "map"}
		for _, entry := range p.Map.Items {
			n.Children = append(n.Children, &Node{
				Kind: "entry",
				Children: []*Node{
					FromExpr(entry.Key),
					FromExpr(entry.Value),
				},
			})
		}
		return n

	case p.Lit != nil:
		switch {
		case p.Lit.Float != nil:
			return &Node{Kind: "float", Value: *p.Lit.Float}
		case p.Lit.Int != nil:
			return &Node{Kind: "int", Value: *p.Lit.Int}
		case p.Lit.Str != nil:
			return &Node{Kind: "string", Value: *p.Lit.Str}
		case p.Lit.Bool != nil:
			return &Node{Kind: "bool", Value: *p.Lit.Bool}
		}

	case p.Group != nil:
		return &Node{Kind: "group", Children: []*Node{FromExpr(p.Group)}}
	}

	return &Node{Kind: "unknown"}
}

// --- Type Ref ---

func FromTypeRef(t *parser.TypeRef) *Node {
	if t == nil {
		return nil
	}
	if t.Fun != nil {
		n := &Node{Kind: "typefun"}
		for _, param := range t.Fun.Params {
			n.Children = append(n.Children, FromTypeRef(param))
		}
		if t.Fun.Return != nil {
			n.Children = append(n.Children, FromTypeRef(t.Fun.Return))
		}
		return n
	}
	if t.Generic != nil {
		n := &Node{Kind: "type", Value: t.Generic.Name}
		for _, arg := range t.Generic.Args {
			n.Children = append(n.Children, FromTypeRef(arg))
		}
		return n
	}
	if t.Simple != nil {
		return &Node{Kind: "type", Value: *t.Simple}
	}
	return &Node{Kind: "type", Value: "unknown"}
}

```

## types/env.go

```go
package types

import (
	"fmt"
	"io"
	"mochi/parser"
	"os"
)

// Env holds both type and value bindings for variables and functions.
type Env struct {
	parent *Env

	types  map[string]Type            // static types
	values map[string]any             // runtime values
	funcs  map[string]*parser.FunStmt // function declarations

	output io.Writer // default: os.Stdout
}

// NewEnv creates a new lexical scope environment.
func NewEnv(parent *Env) *Env {
	return &Env{
		parent: parent,
		types:  make(map[string]Type),
		values: make(map[string]any),
		funcs:  make(map[string]*parser.FunStmt),
		output: os.Stdout,
	}
}

// --- Type (Static) Binding ---

// SetVar defines a variable's static type.
func (e *Env) SetVar(name string, typ Type) {
	e.types[name] = typ
}

// GetVar looks up a variable's static type.
func (e *Env) GetVar(name string) (Type, error) {
	if t, ok := e.types[name]; ok {
		return t, nil
	}
	if e.parent != nil {
		return e.parent.GetVar(name)
	}
	return nil, fmt.Errorf("undefined variable: %s", name)
}

// --- Value (Runtime) Binding ---

// SetValue sets a variable's runtime value.
func (e *Env) SetValue(name string, val any) {
	e.values[name] = val
}

// UpdateValue modifies an existing variable's runtime value.
func (e *Env) UpdateValue(name string, val any) error {
	if _, ok := e.values[name]; ok {
		e.values[name] = val
		return nil
	}
	if e.parent != nil {
		return e.parent.UpdateValue(name, val)
	}
	return fmt.Errorf("variable not declared: %s", name)
}

// GetValue retrieves a runtime value.
func (e *Env) GetValue(name string) (any, error) {
	if val, ok := e.values[name]; ok {
		return val, nil
	}
	if e.parent != nil {
		return e.parent.GetValue(name)
	}
	return nil, fmt.Errorf("undefined variable: %s", name)
}

// --- Function Binding ---

// SetFunc binds a named function.
func (e *Env) SetFunc(name string, fn *parser.FunStmt) {
	e.funcs[name] = fn
}

// SetFuncType binds a function name to its static type.
func (e *Env) SetFuncType(name string, typ Type) {
	e.types[name] = typ
}

// GetFunc retrieves a function definition.
func (e *Env) GetFunc(name string) (*parser.FunStmt, bool) {
	if fn, ok := e.funcs[name]; ok {
		return fn, true
	}
	if e.parent != nil {
		return e.parent.GetFunc(name)
	}
	return nil, false
}

// Copy creates a shallow copy of the current environment with no parent.
// Useful for closures capturing current bindings.
func (e *Env) Copy() *Env {
	newEnv := &Env{
		parent: nil, // flatten parent chain
		types:  make(map[string]Type, len(e.types)),
		values: make(map[string]any, len(e.values)),
		funcs:  make(map[string]*parser.FunStmt, len(e.funcs)),
		output: e.output,
	}
	for k, v := range e.types {
		newEnv.types[k] = v
	}
	for k, v := range e.values {
		newEnv.values[k] = v
	}
	for k, v := range e.funcs {
		newEnv.funcs[k] = v
	}
	return newEnv
}

// --- Output Control ---

// SetWriter sets the output destination.
func (e *Env) SetWriter(w io.Writer) {
	e.output = w
}

// Writer returns the current output writer.
func (e *Env) Writer() io.Writer {
	return e.output
}

```

## types/check.go

```go
package types

import (
	"fmt"

	"github.com/alecthomas/participle/v2/lexer"
	"mochi/parser"
)

// --- Type System ---

type Type interface {
	String() string
}

type IntType struct{}

func (IntType) String() string { return "int" }

type FloatType struct{}

func (FloatType) String() string { return "float" }

type StringType struct{}

func (StringType) String() string { return "string" }

type BoolType struct{}

func (BoolType) String() string { return "bool" }

type VoidType struct{}

func (VoidType) String() string { return "void" }

type ListType struct {
	Elem Type
}

func (t ListType) String() string { return "[" + t.Elem.String() + "]" }

type MapType struct {
	Key   Type
	Value Type
}

func (t MapType) String() string {
	return fmt.Sprintf("{%s: %s}", t.Key.String(), t.Value.String())
}

type AnyType struct{}

func (AnyType) String() string { return "any" }

type TypeVar struct {
	Name string
}

func (t *TypeVar) String() string { return t.Name }

type FuncType struct {
	Params []Type
	Return Type
}

func (f FuncType) String() string {
	s := "fun("
	for i, p := range f.Params {
		if i > 0 {
			s += ", "
		}
		s += p.String()
	}
	s += ")"
	if f.Return != nil && f.Return.String() != "void" {
		s += ": " + f.Return.String()
	}
	return s
}

type AnyListType struct{}

func (AnyListType) String() string { return "[_]" }
func (AnyListType) Equal(t Type) bool {
	_, ok := t.(ListType)
	return ok
}

type BuiltinFuncType struct{}

func (BuiltinFuncType) String() string { return "fun(...): void" }

type Subst map[string]Type

// unify attempts to determine if type a can be unified with type b.
// If a substitution map is provided, it will be updated to resolve type variables.
// If subst == nil, unification checks structural equality.
// unify attempts to determine if type a can be unified with type b.
// If a substitution map is provided, it will be updated to resolve type variables.
// If subst == nil, unification checks structural equality.
func unify(a, b Type, subst Subst) bool {
	switch at := a.(type) {

	case AnyType:
		return true

	case *TypeVar:
		if subst != nil {
			if val, ok := subst[at.Name]; ok {
				return unify(val, b, subst)
			}
			subst[at.Name] = b
		}
		return true

	case ListType:
		switch bt := b.(type) {
		case ListType:
			return unify(at.Elem, bt.Elem, subst)
		case AnyType:
			return true
		case *TypeVar:
			if subst != nil {
				if val, ok := subst[bt.Name]; ok {
					return unify(at, val, subst)
				}
				subst[bt.Name] = at
			}
			return true
		default:
			return false
		}

	case MapType:
		switch bt := b.(type) {
		case MapType:
			return unify(at.Key, bt.Key, subst) &&
				unify(at.Value, bt.Value, subst)
		case AnyType:
			return true
		case *TypeVar:
			if subst != nil {
				if val, ok := subst[bt.Name]; ok {
					return unify(at, val, subst)
				}
				subst[bt.Name] = at
			}
			return true
		default:
			return false
		}

	case FuncType:
		bt, ok := b.(FuncType)
		if !ok || len(at.Params) != len(bt.Params) {
			return false
		}
		for i := range at.Params {
			if !unify(at.Params[i], bt.Params[i], subst) {
				return false
			}
		}
		return unify(at.Return, bt.Return, subst)

	case IntType:
		_, ok := b.(IntType)
		return ok

	case FloatType:
		_, ok := b.(FloatType)
		return ok

	case StringType:
		_, ok := b.(StringType)
		return ok

	case BoolType:
		_, ok := b.(BoolType)
		return ok

	case VoidType:
		_, ok := b.(VoidType)
		return ok

	default:
		// If a didn't match, maybe b is AnyType or a TypeVar
		switch bt := b.(type) {
		case AnyType:
			return true
		case *TypeVar:
			if subst != nil {
				if val, ok := subst[bt.Name]; ok {
					return unify(a, val, subst)
				}
				subst[bt.Name] = a
			}
			return true
		default:
			return false
		}
	}
}

// --- Entry Point ---

func Check(prog *parser.Program, env *Env) []error {
	env.SetVar("print", BuiltinFuncType{})
	env.SetVar("len", FuncType{
		Params: []Type{AnyType{}}, // loosely typed
		Return: IntType{},
	})
	env.SetVar("now", FuncType{
		Params: []Type{},
		Return: IntType{},
	})
	env.SetVar("json", FuncType{
		Params: []Type{AnyType{}},
		Return: VoidType{},
	})

	var errs []error
	for _, stmt := range prog.Statements {
		if err := checkStmt(stmt, env, VoidType{}); err != nil {
			errs = append(errs, err)
		}
	}
	return errs
}

// --- Helpers ---

func checkStmt(s *parser.Statement, env *Env, expectedReturn Type) error {
	switch {
	case s.Let != nil:
		name := s.Let.Name
		var typ Type
		if s.Let.Type != nil {
			typ = resolveTypeRef(s.Let.Type)
			if s.Let.Value != nil {
				exprType, err := checkExprWithExpected(s.Let.Value, env, typ)
				if err != nil {
					return err
				}
				if !unify(typ, exprType, nil) {
					return errTypeMismatch(s.Let.Pos, typ, exprType)
				}
			}
		} else if s.Let.Value != nil {
			var err error
			typ, err = checkExprWithExpected(s.Let.Value, env, nil)
			if err != nil {
				return err
			}
		} else {
			return errLetMissingTypeOrValue(s.Let.Pos)
		}
		env.SetVar(name, typ)
		return nil

	case s.Assign != nil:
		rhsType, err := checkExprWithExpected(s.Assign.Value, env, nil)
		if err != nil {
			return err
		}
		lhsType, err := env.GetVar(s.Assign.Name)
		if err != nil {
			return errAssignUndeclared(s.Assign.Pos, s.Assign.Name)
		}
		if !unify(lhsType, rhsType, nil) {
			return errCannotAssign(s.Assign.Pos, rhsType, s.Assign.Name, lhsType)
		}
		return nil

	case s.For != nil:
		// Check the loop expression (either a collection or a range start)
		sourceType, err := checkExprWithExpected(s.For.Source, env, nil)
		if err != nil {
			return err
		}

		var elemType Type

		if s.For.RangeEnd != nil {
			// It's a range loop: `for i in start..end`
			endType, err := checkExprWithExpected(s.For.RangeEnd, env, nil)
			if err != nil {
				return err
			}
			if !unify(sourceType, IntType{}, nil) || !unify(endType, IntType{}, nil) {
				return errRangeRequiresInts(s.For.Pos)
			}
			elemType = IntType{} // range loop always yields int
		} else {
			// It's a collection loop: `for x in collection`
			switch t := sourceType.(type) {
			case ListType:
				elemType = t.Elem
			case MapType:
				elemType = t.Key // loop iterates over keys
			case AnyType:
				elemType = AnyType{}
			default:
				return errCannotIterate(s.For.Pos, sourceType)
			}
		}

		// Create new scope for the loop variable
		child := NewEnv(env)
		child.SetVar(s.For.Name, elemType)

		// Check loop body
		for _, stmt := range s.For.Body {
			if err := checkStmt(stmt, child, expectedReturn); err != nil {
				return err
			}
		}
		return nil

	case s.Fun != nil:
		name := s.Fun.Name
		params := []Type{}
		for _, p := range s.Fun.Params {
			if p.Type == nil {
				return errParamMissingType(s.Fun.Pos, p.Name)
			}
			params = append(params, resolveTypeRef(p.Type))
		}
		var ret Type = VoidType{}
		if s.Fun.Return != nil {
			ret = resolveTypeRef(s.Fun.Return)
		}
		env.SetVar(name, FuncType{Params: params, Return: ret})

		child := NewEnv(env)
		for i, p := range s.Fun.Params {
			child.SetVar(p.Name, params[i])
		}
		for _, stmt := range s.Fun.Body {
			if err := checkStmt(stmt, child, ret); err != nil {
				return err
			}
		}
		return nil

	case s.Expr != nil:
		_, err := checkExprWithExpected(s.Expr.Expr, env, nil)
		return err

	case s.Return != nil:
		actual, err := checkExprWithExpected(s.Return.Value, env, expectedReturn)
		if err != nil {
			return err
		}
		if !unify(actual, expectedReturn, nil) {
			return errReturnMismatch(s.Return.Pos, expectedReturn, actual)
		}
		return nil

	case s.Test != nil:
		child := NewEnv(env)
		for _, stmt := range s.Test.Body {
			if err := checkStmt(stmt, child, expectedReturn); err != nil {
				return err
			}
		}
		return nil

	case s.Expect != nil:
		t, err := checkExprWithExpected(s.Expect.Value, env, BoolType{})
		if err != nil {
			return err
		}
		if !unify(t, BoolType{}, nil) {
			return errExpectBoolean(s.Expect.Pos)
		}
		return nil
	}
	return nil
}

func resolveTypeRef(t *parser.TypeRef) Type {
	if t.Fun != nil {
		params := make([]Type, len(t.Fun.Params))
		for i, p := range t.Fun.Params {
			params[i] = resolveTypeRef(p)
		}
		var ret Type = VoidType{}
		if t.Fun.Return != nil {
			ret = resolveTypeRef(t.Fun.Return)
		}
		return FuncType{Params: params, Return: ret}
	}

	if t.Generic != nil {
		name := t.Generic.Name
		args := t.Generic.Args
		switch name {
		case "list":
			if len(args) == 1 {
				return ListType{Elem: resolveTypeRef(args[0])}
			}
		case "map":
			if len(args) == 2 {
				return MapType{
					Key:   resolveTypeRef(args[0]),
					Value: resolveTypeRef(args[1]),
				}
			}
		}
		// Fallback: unknown generic type
		return AnyType{}
	}

	if t.Simple != nil {
		switch *t.Simple {
		case "int":
			return IntType{}
		case "float":
			return FloatType{}
		case "string":
			return StringType{}
		case "bool":
			return BoolType{}
		default:
			return AnyType{}
		}
	}

	return AnyType{}
}

func checkExpr(e *parser.Expr, env *Env) (Type, error) {
	return checkExprWithExpected(e, env, nil)
}

func checkExprWithExpected(e *parser.Expr, env *Env, expected Type) (Type, error) {
	actual, err := checkBinaryExpr(e.Binary, env)
	if err != nil {
		return nil, err
	}
	if expected != nil && !unify(actual, expected, nil) {
		return nil, errTypeMismatch(e.Pos, expected, actual)
	}
	return actual, nil
}
func checkBinaryExpr(b *parser.BinaryExpr, env *Env) (Type, error) {
	left, err := checkUnary(b.Left, env, nil)
	if err != nil {
		return nil, err
	}

	for _, op := range b.Right {
		right, err := checkPostfix(op.Right, env, nil)
		if err != nil {
			return nil, err
		}

		switch op.Op {
		case "+", "-", "*", "/", "%":
			// Arithmetic: int, float, or string + string
			switch {
			case unify(left, IntType{}, nil) && unify(right, IntType{}, nil):
				left = IntType{}

			case unify(left, FloatType{}, nil) && unify(right, FloatType{}, nil):
				left = FloatType{}

			case op.Op == "+" && unify(left, StringType{}, nil) && unify(right, StringType{}, nil):
				left = StringType{}

			default:
				return nil, errOperatorMismatch(op.Pos, op.Op, left, right)
			}

		case "==", "!=", "<", "<=", ">", ">=":
			// comparison: any comparable types
			if !unify(left, right, nil) {
				return nil, errIncompatibleComparison(lexer.Position{}) // you can add op.Pos to BinaryOp
			}
			left = BoolType{}

		default:
			return nil, errUnsupportedOperator(op.Pos, op.Op)
		}
	}

	return left, nil
}

/*
func checkExprWithExpected(e *parser.Expr, env *Env, expected Type) (Type, error) {
	return checkEquality(e.Equality, env, expected)
}

func checkEquality(e *parser.Equality, env *Env, expected Type) (Type, error) {
	left, err := checkComparison(e.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range e.Right {
		right, err := checkComparison(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errIncompatibleEquality(op.Pos)
		}
		left = BoolType{}
	}
	return left, nil
}

func checkComparison(c *parser.Comparison, env *Env, expected Type) (Type, error) {
	left, err := checkTerm(c.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range c.Right {
		right, err := checkTerm(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errIncompatibleComparison(op.Pos)
		}
		left = BoolType{}
	}
	return left, nil
}

func checkTerm(t *parser.Term, env *Env, expected Type) (Type, error) {
	left, err := checkFactor(t.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range t.Right {
		right, err := checkFactor(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errTypeMismatch(op.Pos, left, right)
		}
	}
	return left, nil
}

func checkFactor(f *parser.Factor, env *Env, expected Type) (Type, error) {
	left, err := checkUnary(f.Left, env, nil)
	if err != nil {
		return nil, err
	}
	for _, op := range f.Right {
		right, err := checkUnary(op.Right, env, nil)
		if err != nil {
			return nil, err
		}
		if !left.Equal(right) {
			return nil, errTypeMismatch(op.Pos, left, right)
		}
	}
	return left, nil
}
*/

func checkUnary(u *parser.Unary, env *Env, expected Type) (Type, error) {
	return checkPostfix(u.Value, env, expected)
}

func checkPostfix(p *parser.PostfixExpr, env *Env, expected Type) (Type, error) {
	typ, err := checkPrimary(p.Target, env, expected)
	if err != nil {
		return nil, err
	}

	for _, idx := range p.Index {
		switch t := typ.(type) {
		case ListType:
			if idx.Colon == nil {
				// list[i]
				if idx.Start == nil {
					return nil, errMissingIndex(idx.Pos)
				}
				startType, err := checkExpr(idx.Start, env)
				if err != nil {
					return nil, err
				}
				if !unify(startType, IntType{}, nil) {
					return nil, errIndexNotInteger(idx.Pos)
				}
				typ = t.Elem
			} else {
				// list[i:j], list[:j], list[i:], list[:]
				if idx.Start != nil {
					startType, err := checkExpr(idx.Start, env)
					if err != nil {
						return nil, err
					}
					if !unify(startType, IntType{}, nil) {
						return nil, errIndexNotInteger(idx.Pos)
					}
				}
				if idx.End != nil {
					endType, err := checkExpr(idx.End, env)
					if err != nil {
						return nil, err
					}
					if !unify(endType, IntType{}, nil) {
						return nil, errIndexNotInteger(idx.Pos)
					}
				}
				typ = t // list slice returns same list type
			}

		case MapType:
			if idx.Colon != nil {
				return nil, errInvalidMapSlice(idx.Pos)
			}
			if idx.Start == nil {
				return nil, errMissingIndex(idx.Pos)
			}
			keyType, err := checkExpr(idx.Start, env)
			if err != nil {
				return nil, err
			}
			if !unify(keyType, t.Key, nil) {
				return nil, errIndexTypeMismatch(idx.Pos, t.Key, keyType)
			}
			typ = t.Value

		default:
			return nil, errNotIndexable(p.Target.Pos, typ)
		}
	}

	return typ, nil
}

func checkPrimary(p *parser.Primary, env *Env, expected Type) (Type, error) {
	switch {
	case p.Lit != nil:
		switch {
		case p.Lit.Int != nil:
			return IntType{}, nil
		case p.Lit.Float != nil:
			return FloatType{}, nil
		case p.Lit.Str != nil:
			return StringType{}, nil
		case p.Lit.Bool != nil:
			return BoolType{}, nil
		}

	case p.Selector != nil:
		typ, err := env.GetVar(p.Selector.Root)
		if err != nil {
			return nil, errUnknownVariable(p.Pos, p.Selector.Root)
		}
		// TODO: implement proper struct/stream field access checking
		return typ, nil

	case p.Call != nil:
		fnType, err := env.GetVar(p.Call.Func)
		if err != nil {
			return nil, errUnknownFunction(p.Pos, p.Call.Func)
		}

		switch ft := fnType.(type) {
		case FuncType:
			argCount := len(p.Call.Args)
			paramCount := len(ft.Params)

			if argCount > paramCount {
				return nil, errTooManyArgs(p.Pos, paramCount, argCount)
			}

			for i := 0; i < argCount; i++ {
				argType, err := checkExprWithExpected(p.Call.Args[i], env, ft.Params[i])
				if err != nil {
					return nil, err
				}
				if !unify(argType, ft.Params[i], nil) {
					return nil, errArgTypeMismatch(p.Pos, i, ft.Params[i], argType)
				}
			}

			if argCount == paramCount {
				return ft.Return, nil
			}
			return curryFuncType(ft.Params[argCount:], ft.Return), nil

		case BuiltinFuncType:
			for _, arg := range p.Call.Args {
				if _, err := checkExpr(arg, env); err != nil {
					return nil, err
				}
			}
			return VoidType{}, nil

		default:
			return nil, errNotFunction(p.Pos, p.Call.Func)
		}

	case p.List != nil:
		var elemType Type = nil
		for _, elem := range p.List.Elems {
			t, err := checkExpr(elem, env)
			if err != nil {
				return nil, err
			}
			if elemType == nil {
				elemType = t
			} else if !unify(elemType, t, nil) {
				elemType = AnyType{} // fallback if mixed types
			}
		}
		if elemType == nil {
			elemType = AnyType{}
		}
		return ListType{Elem: elemType}, nil

	case p.Map != nil:
		var keyT, valT Type
		for _, item := range p.Map.Items {
			kt, err := checkExpr(item.Key, env)
			if err != nil {
				return nil, err
			}
			vt, err := checkExpr(item.Value, env)
			if err != nil {
				return nil, err
			}
			if keyT == nil {
				keyT = kt
			} else if !unify(keyT, kt, nil) {
				keyT = AnyType{}
			}
			if valT == nil {
				valT = vt
			} else if !unify(valT, vt, nil) {
				valT = AnyType{}
			}
		}
		if keyT == nil {
			keyT = AnyType{}
		}
		if valT == nil {
			valT = AnyType{}
		}
		return MapType{Key: keyT, Value: valT}, nil

	case p.FunExpr != nil:
		return checkFunExpr(p.FunExpr, env, expected, p.Pos)

	case p.Group != nil:
		return checkExprWithExpected(p.Group, env, expected)
	}

	return nil, errInvalidPrimary(p.Pos)
}

func checkFunExpr(f *parser.FunExpr, env *Env, expected Type, pos lexer.Position) (Type, error) {
	var expectedFunc *FuncType
	if ft, ok := expected.(FuncType); ok {
		expectedFunc = &ft
	}

	paramTypes := make([]Type, len(f.Params))
	for i, p := range f.Params {
		if p.Type != nil {
			paramTypes[i] = resolveTypeRef(p.Type)
		} else if expectedFunc != nil && i < len(expectedFunc.Params) {
			paramTypes[i] = expectedFunc.Params[i]
		} else {
			paramTypes[i] = &TypeVar{Name: fmt.Sprintf("T_%s", p.Name)}
		}
	}

	var declaredRet Type
	if f.Return != nil {
		declaredRet = resolveTypeRef(f.Return)
	} else if expectedFunc != nil {
		declaredRet = expectedFunc.Return
	} else {
		declaredRet = &TypeVar{Name: "R"}
	}

	child := NewEnv(env)
	for i, p := range f.Params {
		child.SetVar(p.Name, paramTypes[i])
	}

	subst := Subst{}
	var actualRet Type
	var err error

	if f.ExprBody != nil {
		actualRet, err = checkExpr(f.ExprBody, child)
		if err != nil {
			return nil, err
		}
	} else {
		// Block body
		for _, stmt := range f.BlockBody {
			if err := checkStmt(stmt, child, declaredRet); err != nil {
				return nil, err
			}
		}
		actualRet = declaredRet
	}

	if !unify(declaredRet, actualRet, subst) {
		return nil, errTypeMismatch(pos, declaredRet, actualRet)
	}

	// Final substitution: resolve any type variable that was inferred
	if tv, ok := declaredRet.(*TypeVar); ok {
		if resolved, ok := subst[tv.Name]; ok {
			declaredRet = resolved
		}
	}

	return FuncType{Params: paramTypes, Return: declaredRet}, nil
}

func curryFuncType(params []Type, ret Type) Type {
	if len(params) == 0 {
		return ret
	}
	return FuncType{
		Params: []Type{params[0]},
		Return: curryFuncType(params[1:], ret),
	}
}

```

## types/errors.go

```go
package types

import (
        "fmt"
        "github.com/alecthomas/participle/v2/lexer"
        "mochi/diagnostic"
)

var Errors = map[string]diagnostic.Template{
	// --- Declarations & Scope ---
	"T000": {Code: "T000", Message: "`let` requires a type or a value", Help: "Use `let x = ...` or `let x: int` to declare a variable."},
	"T001": {Code: "T001", Message: "assignment to undeclared variable: %s", Help: "Declare `%s` first using `let`."},
	"T002": {Code: "T002", Message: "undefined variable: %s", Help: "Check if the variable was declared in this scope."},

	// --- Functions ---
	"T003": {Code: "T003", Message: "unknown function: %s", Help: "Ensure the function is defined before it's called."},
	"T004": {Code: "T004", Message: "`%s` is not callable", Help: "Use a function or closure in this position."},
	"T005": {Code: "T005", Message: "parameter `%s` is missing a type", Help: "Add a type like `x: int` to this parameter."},
	"T006": {Code: "T006", Message: "too many arguments: expected %d, got %d", Help: "Remove extra arguments or update the function definition."},
	"T007": {Code: "T007", Message: "argument %d: expected %s, got %s", Help: "Ensure the argument type matches the function’s signature."},

	// --- Type Mismatches ---
	"T008": {Code: "T008", Message: "type mismatch: expected %s, got %s", Help: "Change the value to match the expected type."},
	"T009": {Code: "T009", Message: "cannot assign %s to `%s` (expected %s)", Help: "Make sure the assigned value is compatible with `%s`."},
	"T010": {Code: "T010", Message: "return type mismatch: expected %s, got %s", Help: "Update the return value to match the function's return type."},

	// --- Boolean and Condition Checks ---
	"T011": {Code: "T011", Message: "`expect` must be a boolean", Help: "`expect` should evaluate to `true` or `false`."},
	"T012": {Code: "T012", Message: "incompatible types in equality comparison", Help: "Use `==` or `!=` only with values of the same type."},
	"T013": {Code: "T013", Message: "incompatible types in comparison", Help: "Use comparable types like numbers or strings with `<`, `>`."},

	// --- Expressions ---
	"T014": {Code: "T014", Message: "invalid primary expression", Help: "Expected a complete value or expression (e.g., literal, variable, function)."},
	"T020": {Code: "T020", Message: "operator `%s` cannot be used on types %s and %s", Help: "Choose an operator that supports these operand types."},
	"T021": {Code: "T021", Message: "unsupported operator: `%s`", Help: "Use a valid operator like +, -, ==, or <."},

	// --- Indexing ---
	"T015": {Code: "T015", Message: "index must be an integer", Help: "Use an `int` value for indexing (e.g., `list[0]`)."},
	"T016": {Code: "T016", Message: "missing index expression", Help: "Provide an index inside `[ ... ]`."},
	"T017": {Code: "T017", Message: "slicing not allowed on map", Help: "Maps do not support slicing like `map[a:b]`."},
	"T018": {Code: "T018", Message: "type %s does not support indexing", Help: "Only `list<T>` and `map<K,V>` can be indexed."},
	"T019": {Code: "T019", Message: "map key type mismatch: expected %s, got %s", Help: "Make sure the key matches the map’s key type."},
	// --- For Loops ---
	"T022": {Code: "T022", Message: "cannot iterate over type %s", Help: "Only `list<T>`, `map<K,V>`, or integer ranges are allowed in `for ... in ...` loops."},
	"T023": {Code: "T023", Message: "range loop requires integer start and end expressions", Help: "Use `for i in 0..10` or ensure both expressions are of type `int`."},
}

// --- Wrapper Functions ---

func errLetMissingTypeOrValue(pos lexer.Position) error {
	return Errors["T000"].New(pos)
}

func errAssignUndeclared(pos lexer.Position, name string) error {
        tmpl := Errors["T001"]
        msg := fmt.Sprintf(tmpl.Message, name)
        help := fmt.Sprintf(tmpl.Help, name)
        return diagnostic.New(tmpl.Code, pos, msg, help)
}

func errUnknownVariable(pos lexer.Position, name string) error {
	return Errors["T002"].New(pos, name)
}

func errUnknownFunction(pos lexer.Position, name string) error {
	return Errors["T003"].New(pos, name)
}

func errNotFunction(pos lexer.Position, name string) error {
	return Errors["T004"].New(pos, name)
}

func errParamMissingType(pos lexer.Position, name string) error {
	return Errors["T005"].New(pos, name)
}

func errTooManyArgs(pos lexer.Position, expected, actual int) error {
	return Errors["T006"].New(pos, expected, actual)
}

func errArgTypeMismatch(pos lexer.Position, index int, expected, actual Type) error {
	return Errors["T007"].New(pos, index+1, expected, actual)
}

func errTypeMismatch(pos lexer.Position, expected, actual Type) error {
	return Errors["T008"].New(pos, expected, actual)
}

func errCannotAssign(pos lexer.Position, rhs Type, lhsName string, lhs Type) error {
        tmpl := Errors["T009"]
        msg := fmt.Sprintf(tmpl.Message, rhs, lhsName, lhs)
        help := fmt.Sprintf(tmpl.Help, lhsName)
        return diagnostic.New(tmpl.Code, pos, msg, help)
}

func errReturnMismatch(pos lexer.Position, expected, actual Type) error {
	return Errors["T010"].New(pos, expected, actual)
}

func errExpectBoolean(pos lexer.Position) error {
	return Errors["T011"].New(pos)
}

//func errIncompatibleEquality(pos lexer.Position) error {
//	return Errors["T012"].New(pos)
//}

func errIncompatibleComparison(pos lexer.Position) error {
	return Errors["T013"].New(pos)
}

func errInvalidPrimary(pos lexer.Position) error {
	return Errors["T014"].New(pos)
}

func errIndexNotInteger(pos lexer.Position) error {
	return Errors["T015"].New(pos)
}

func errMissingIndex(pos lexer.Position) error {
	return Errors["T016"].New(pos)
}

func errInvalidMapSlice(pos lexer.Position) error {
	return Errors["T017"].New(pos)
}

func errNotIndexable(pos lexer.Position, typ Type) error {
	return Errors["T018"].New(pos, typ)
}

func errIndexTypeMismatch(pos lexer.Position, expected, actual Type) error {
	return Errors["T019"].New(pos, expected, actual)
}

func errOperatorMismatch(pos lexer.Position, op string, left, right Type) error {
	return Errors["T020"].New(pos, op, left, right)
}

func errUnsupportedOperator(pos lexer.Position, op string) error {
	return Errors["T021"].New(pos, op)
}

func errCannotIterate(pos lexer.Position, typ Type) error {
	return Errors["T022"].New(pos, typ)
}

func errRangeRequiresInts(pos lexer.Position) error {
	return Errors["T023"].New(pos)
}

```

## interpreter/interpreter.go

```go
package interpreter

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/alecthomas/participle/v2/lexer"
	"github.com/fatih/color"
	"mochi/parser"
	"mochi/types"
	"os"
	"reflect"
	"strings"
	"time"
)

// Interpreter executes Mochi programs using a shared runtime and type environment.
type Interpreter struct {
	prog  *parser.Program
	env   *types.Env
	types *types.Env
}

func New(prog *parser.Program, typesEnv *types.Env) *Interpreter {
	return &Interpreter{
		prog: prog,
		// env:   types.NewEnv(nil),
		env:   typesEnv,
		types: typesEnv,
	}
}

func (i *Interpreter) SetProgram(prog *parser.Program) {
	i.prog = prog
}

func (i *Interpreter) Env() *types.Env { return i.env }

var (
	cTest = color.New(color.FgYellow).SprintFunc()
	cOK   = color.New(color.FgGreen).SprintFunc()
	cFail = color.New(color.FgRed).SprintFunc()
)

func printTestStart(name string) {
	fmt.Printf("   %s %-30s ...", cTest("test"), name)
}

func printTestPass(duration time.Duration) {
	fmt.Printf(" %s (%s)\n", cOK("ok"), formatDuration(duration))
}

func printTestFail(err error, duration time.Duration) {
	fmt.Printf(" %s %v (%s)\n", cFail("fail"), err, formatDuration(duration))
}

func formatDuration(d time.Duration) string {
	switch {
	case d < time.Microsecond:
		return fmt.Sprintf("%dns", d.Nanoseconds())
	case d < time.Millisecond:
		return fmt.Sprintf("%.1fµs", float64(d.Microseconds()))
	case d < time.Second:
		return fmt.Sprintf("%.1fms", float64(d.Milliseconds()))
	default:
		return fmt.Sprintf("%.2fs", d.Seconds())
	}
}

func (i *Interpreter) Run() error {
	/*
		// Load all shared definitions (let, fun) first
		for _, stmt := range i.prog.Statements {
			if stmt.Let != nil || stmt.Fun != nil {
				if err := i.evalStmt(stmt); err != nil {
					return err
				}
			}
		}
	*/

	// Run only non-test, non-decl statements (Expr, If, For, Return)
	for _, stmt := range i.prog.Statements {
		if stmt.Test != nil {
			continue
		}
		if err := i.evalStmt(stmt); err != nil {
			return err
		}
	}

	return nil
}

func (i *Interpreter) Test() error {
	var failures []error

	// Preload all shared declarations (let, fun)
	for _, stmt := range i.prog.Statements {
		if stmt.Let != nil || stmt.Fun != nil {
			if err := i.evalStmt(stmt); err != nil {
				return err
			}
		}
	}

	// Run each test block independently
	for _, stmt := range i.prog.Statements {
		if stmt.Test == nil {
			continue
		}

		name := stmt.Test.Name
		printTestStart(name)

		child := types.NewEnv(i.env)
		interp := &Interpreter{
			prog:  i.prog,
			env:   child,
			types: i.types,
		}

		start := time.Now()
		var failed error
		for _, s := range stmt.Test.Body {
			if err := interp.evalStmt(s); err != nil {
				failed = err
				break
			}
		}
		duration := time.Since(start)

		if failed != nil {
			printTestFail(failed, duration)
			failures = append(failures, failed)
		} else {
			printTestPass(duration)
		}
	}

	if len(failures) > 0 {
		fmt.Fprintf(os.Stderr, "\n%s %d test(s) failed.\n", cFail("[FAIL]"), len(failures))
		return fmt.Errorf("test failed: %d test(s) failed", len(failures))
	}

	return nil
}

type closure struct {
	Fn         *parser.FunExpr
	Env        *types.Env
	Args       []any
	FullParams []*parser.Param
}

func (c closure) String() string {
	return fmt.Sprintf("<closure %d/%d args>", len(c.Args), len(c.Fn.Params)+len(c.Args))
}

// --- Statement Evaluation ---

func (i *Interpreter) evalStmt(s *parser.Statement) error {
	switch {
	case s.Let != nil:
		val := any(nil)
		var err error
		if s.Let.Value != nil {
			val, err = i.evalExpr(s.Let.Value)
			if err != nil {
				return err
			}
		}
		i.env.SetValue(s.Let.Name, val)
		return nil

	case s.Assign != nil:
		val, err := i.evalExpr(s.Assign.Value)
		if err != nil {
			return err
		}
		return i.env.UpdateValue(s.Assign.Name, val)

	case s.Expr != nil:
		_, err := i.evalExpr(s.Expr.Expr)
		return err

	case s.Fun != nil:
		i.env.SetFunc(s.Fun.Name, s.Fun)
		return nil

	case s.Return != nil:
		val, err := i.evalExpr(s.Return.Value)
		if err != nil {
			return err
		}
		return returnSignal{val}

	case s.If != nil:
		return i.evalIf(s.If)

	case s.For != nil:
		return i.evalFor(s.For)

	case s.Test != nil:
		fmt.Printf("🔍 Test %s\n", s.Test.Name)
		child := types.NewEnv(i.env)
		interp := &Interpreter{prog: i.prog, env: child, types: i.types}
		for _, stmt := range s.Test.Body {
			if err := interp.evalStmt(stmt); err != nil {
				return fmt.Errorf("❌ %s: %w", s.Test.Name, err)
			}
		}
		fmt.Printf("✅ %s passed\n", s.Test.Name)
		return nil

	case s.Expect != nil:
		val, err := i.evalExpr(s.Expect.Value)
		if err != nil {
			return err
		}
		if b, ok := val.(bool); !ok || !b {
			return errExpectFailed(s.Expect.Pos)
		}
		return nil

	default:
		return fmt.Errorf("unsupported statement: %#v", s)
	}
}

func (i *Interpreter) evalIf(stmt *parser.IfStmt) error {
	condVal, err := i.evalExpr(stmt.Cond)
	if err != nil {
		return err
	}
	if truthy(condVal) {
		for _, s := range stmt.Then {
			if err := i.evalStmt(s); err != nil {
				return err
			}
		}
		return nil
	}
	if stmt.ElseIf != nil {
		return i.evalIf(stmt.ElseIf)
	}
	for _, s := range stmt.Else {
		if err := i.evalStmt(s); err != nil {
			return err
		}
	}
	return nil
}

func (i *Interpreter) evalFor(stmt *parser.ForStmt) error {
	fromVal, err := i.evalExpr(stmt.Source)
	if err != nil {
		return err
	}

	// --- Range loop: `for x in a..b` ---
	if stmt.RangeEnd != nil {
		toVal, err := i.evalExpr(stmt.RangeEnd)
		if err != nil {
			return err
		}
		fromInt, ok1 := fromVal.(int)
		toInt, ok2 := toVal.(int)
		if !ok1 || !ok2 {
			return errInvalidRangeBounds(stmt.Pos, fmt.Sprintf("%T", fromVal), fmt.Sprintf("%T", toVal))
		}
		for x := fromInt; x < toInt; x++ {
			i.env.SetValue(stmt.Name, x)
			for _, s := range stmt.Body {
				if err := i.evalStmt(s); err != nil {
					return err
				}
			}
		}
		return nil
	}

	// --- Collection loop: `for x in list/map/string` ---
	switch coll := fromVal.(type) {
	case []any:
		for _, item := range coll {
			i.env.SetValue(stmt.Name, item)
			for _, s := range stmt.Body {
				if err := i.evalStmt(s); err != nil {
					return err
				}
			}
		}
	case map[any]any:
		for k := range coll {
			i.env.SetValue(stmt.Name, k)
			for _, s := range stmt.Body {
				if err := i.evalStmt(s); err != nil {
					return err
				}
			}
		}
	case map[string]any:
		for k := range coll {
			i.env.SetValue(stmt.Name, k)
			for _, s := range stmt.Body {
				if err := i.evalStmt(s); err != nil {
					return err
				}
			}
		}
	case map[int]any:
		for k := range coll {
			i.env.SetValue(stmt.Name, k)
			for _, s := range stmt.Body {
				if err := i.evalStmt(s); err != nil {
					return err
				}
			}
		}
	case string:
		for _, r := range coll {
			i.env.SetValue(stmt.Name, string(r))
			for _, s := range stmt.Body {
				if err := i.evalStmt(s); err != nil {
					return err
				}
			}
		}
	default:
		return errInvalidIterator(stmt.Pos, fmt.Sprintf("%T", fromVal))
	}

	return nil
}

// --- Expression Evaluation ---
func (i *Interpreter) evalExpr(e *parser.Expr) (any, error) {
	if e == nil {
		return nil, errors.New("nil expression")
	}
	return i.evalBinaryExpr(e.Binary)
}

func (i *Interpreter) evalBinaryExpr(b *parser.BinaryExpr) (any, error) {
	if b == nil {
		return nil, errors.New("nil binary expression")
	}

	// Step 1: Build a list of operands and operators
	type token struct {
		pos lexer.Position
		op  string
	}
	var operands []any
	var operators []token

	// Initial left expression
	left, err := i.evalUnary(b.Left)
	if err != nil {
		return nil, err
	}
	operands = append(operands, left)

	for _, part := range b.Right {
		operators = append(operators, token{part.Pos, part.Op})
		right, err := i.evalPostfixExpr(part.Right)
		if err != nil {
			return nil, err
		}
		operands = append(operands, right)
	}

	// Step 2: Apply precedence rules (high to low)
	for _, level := range [][]string{
		{"*", "/", "%"},        // highest
		{"+", "-"},             // middle
		{"<", "<=", ">", ">="}, // comparison
		{"==", "!="},           // equality
	} {
		for i := 0; i < len(operators); {
			op := operators[i].op
			if contains(level, op) {
				left := operands[i]
				right := operands[i+1]
				result, err := applyBinary(operators[i].pos, left, op, right)
				if err != nil {
					return nil, err
				}
				// Replace left and right with result
				operands[i] = result
				operands = append(operands[:i+1], operands[i+2:]...)  // remove i+1
				operators = append(operators[:i], operators[i+1:]...) // remove i
			} else {
				i++
			}
		}
	}

	if len(operands) != 1 {
		return nil, fmt.Errorf("unexpected state after binary eval")
	}
	return operands[0], nil
}

func contains(ops []string, op string) bool {
	for _, o := range ops {
		if o == op {
			return true
		}
	}
	return false
}

/*

func (i *Interpreter) evalExpr(e *parser.Expr) (any, error) {
	if e == nil {
		return nil, errors.New("nil expression")
	}
	return i.evalEquality(e.Equality)
}

func (i *Interpreter) evalEquality(e *parser.Equality) (any, error) {
	left, err := i.evalComparison(e.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range e.Right {
		right, err := i.evalComparison(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalComparison(c *parser.Comparison) (any, error) {
	left, err := i.evalTerm(c.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range c.Right {
		right, err := i.evalTerm(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalTerm(t *parser.Term) (any, error) {
	left, err := i.evalFactor(t.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range t.Right {
		right, err := i.evalFactor(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

func (i *Interpreter) evalFactor(f *parser.Factor) (any, error) {
	left, err := i.evalUnary(f.Left)
	if err != nil {
		return nil, err
	}
	for _, op := range f.Right {
		right, err := i.evalUnary(op.Right)
		if err != nil {
			return nil, err
		}
		left, err = applyBinary(op.Pos, left, op.Op, right)
		if err != nil {
			return nil, err
		}
	}
	return left, nil
}

*/

func (i *Interpreter) evalUnary(u *parser.Unary) (any, error) {
	val, err := i.evalPostfixExpr(u.Value)
	if err != nil {
		return nil, err
	}
	for j := len(u.Ops) - 1; j >= 0; j-- {
		val, err = applyUnary(u.Pos, u.Ops[j], val)
		if err != nil {
			return nil, err
		}
	}
	return val, nil
}

func (i *Interpreter) evalPostfixExpr(p *parser.PostfixExpr) (any, error) {
	val, err := i.evalPrimary(p.Target)
	if err != nil {
		return nil, err
	}

	for _, op := range p.Index {
		switch src := val.(type) {
		case []any:
			// Index
			if op.Colon == nil {
				index, err := i.evalExpr(op.Start)
				if err != nil {
					return nil, err
				}
				n, ok := index.(int)
				if !ok {
					return nil, errInvalidIndex(op.Pos, index)
				}
				if n < 0 {
					n += len(src)
				}
				if n < 0 || n >= len(src) {
					return nil, errIndexOutOfBounds(op.Pos, n, len(src))
				}
				val = src[n]

			} else {
				// Slice
				start, end := 0, len(src)
				if op.Start != nil {
					s, err := i.evalExpr(op.Start)
					if err != nil {
						return nil, err
					}
					if n, ok := s.(int); ok {
						if n < 0 {
							n += len(src)
						}
						start = n
					} else {
						return nil, errInvalidIndex(op.Pos, s)
					}
				}
				if op.End != nil {
					e, err := i.evalExpr(op.End)
					if err != nil {
						return nil, err
					}
					if n, ok := e.(int); ok {
						if n < 0 {
							n += len(src)
						}
						end = n
					} else {
						return nil, errInvalidIndex(op.Pos, e)
					}
				}
				if start < 0 || end > len(src) || start > end {
					return nil, errSliceOutOfBounds(op.Pos, start, end, len(src))
				}
				val = src[start:end]
			}

		case string:
			runes := []rune(src)
			if op.Colon == nil {
				index, err := i.evalExpr(op.Start)
				if err != nil {
					return nil, err
				}
				n, ok := index.(int)
				if !ok {
					return nil, errInvalidIndex(op.Pos, index)
				}
				if n < 0 {
					n += len(runes)
				}
				if n < 0 || n >= len(runes) {
					return nil, errIndexOutOfBounds(op.Pos, n, len(runes))
				}
				val = string(runes[n])
			} else {
				start, end := 0, len(runes)
				if op.Start != nil {
					s, err := i.evalExpr(op.Start)
					if err != nil {
						return nil, err
					}
					if n, ok := s.(int); ok {
						if n < 0 {
							n += len(runes)
						}
						start = n
					} else {
						return nil, errInvalidIndex(op.Pos, s)
					}
				}
				if op.End != nil {
					e, err := i.evalExpr(op.End)
					if err != nil {
						return nil, err
					}
					if n, ok := e.(int); ok {
						if n < 0 {
							n += len(runes)
						}
						end = n
					} else {
						return nil, errInvalidIndex(op.Pos, e)
					}
				}
				if start < 0 || end > len(runes) || start > end {
					return nil, errSliceOutOfBounds(op.Pos, start, end, len(runes))
				}
				val = string(runes[start:end])
			}
		case map[string]any:
			if op.Colon != nil {
				return nil, errInvalidIndexTarget(op.Pos, "map")
			}
			if op.Start == nil {
				return nil, errInvalidIndex(op.Pos, nil)
			}
			key, err := i.evalExpr(op.Start)
			if err != nil {
				return nil, err
			}
			keyStr, ok := key.(string)
			if !ok {
				return nil, errInvalidMapKey(op.Pos, key)
			}
			val = src[keyStr]

		default:
			return nil, errInvalidIndexTarget(op.Pos, fmt.Sprintf("%T", src))
		}
	}
	return val, nil
}

func (i *Interpreter) evalPrimary(p *parser.Primary) (any, error) {
	switch {
	case p.Lit != nil:
		return i.evalLiteral(p.Lit)

	case p.Call != nil:
		return i.evalCall(p.Call)

	case p.Group != nil:
		return i.evalExpr(p.Group)

	case p.FunExpr != nil:
		return closure{Fn: p.FunExpr, Env: i.env.Copy(), FullParams: p.FunExpr.Params}, nil

	case p.Selector != nil:
		val, err := i.env.GetValue(p.Selector.Root)
		if err != nil {
			return nil, errUndefinedVariable(p.Pos, p.Selector.Root)
		}
		for _, field := range p.Selector.Tail {
			obj, ok := val.(map[string]any)
			if !ok {
				return nil, errFieldAccessOnNonObject(p.Pos, field, fmt.Sprintf("%T", val))
			}
			val = obj[field]
		}
		return val, nil

	case p.List != nil:
		var elems []any
		for _, expr := range p.List.Elems {
			val, err := i.evalExpr(expr)
			if err != nil {
				return nil, err
			}
			elems = append(elems, val)
		}
		return elems, nil
	case p.Map != nil:
		obj := map[string]any{}
		for _, item := range p.Map.Items {
			keyVal, err := i.evalExpr(item.Key)
			if err != nil {
				return nil, err
			}
			strKey, ok := keyVal.(string)
			if !ok {
				return nil, errInvalidMapKey(item.Pos, keyVal)
			}
			val, err := i.evalExpr(item.Value)
			if err != nil {
				return nil, err
			}
			obj[strKey] = val
		}
		return obj, nil

	default:
		return nil, errInvalidPrimaryExpression(p.Pos)
	}
}

func (i *Interpreter) evalLiteral(l *parser.Literal) (any, error) {
	switch {
	case l.Int != nil:
		return *l.Int, nil
	case l.Float != nil:
		return *l.Float, nil
	case l.Str != nil:
		return *l.Str, nil
	case l.Bool != nil:
		return *l.Bool, nil
	default:
		return nil, errInvalidLiteral(l.Pos)
	}
}

func builtinPrint(i *Interpreter, c *parser.CallExpr) (any, error) {
	var sb strings.Builder
	for _, arg := range c.Args {
		val, err := i.evalExpr(arg)
		if err != nil {
			return nil, err
		}
		fmt.Fprintf(&sb, "%v ", val)
	}
	_, err := fmt.Fprintln(i.env.Writer(), strings.TrimSpace(sb.String()))
	return nil, err
}

func builtinLen(i *Interpreter, c *parser.CallExpr) (any, error) {
	if len(c.Args) != 1 {
		return nil, errTooManyFunctionArgs(c.Pos, "len", 1, len(c.Args))
	}
	val, err := i.evalExpr(c.Args[0])
	if err != nil {
		return nil, err
	}

	switch v := val.(type) {
	case []any:
		return len(v), nil
	case string:
		return len([]rune(v)), nil
	case map[string]any:
		return len(v), nil
	default:
		return nil, errInvalidLenOperand(c.Pos, fmt.Sprintf("%T", val))
	}
}

func builtinNow(i *Interpreter, c *parser.CallExpr) (any, error) {
	if len(c.Args) != 0 {
		return nil, fmt.Errorf("now() takes no arguments")
	}
	return time.Now().UnixNano(), nil
}

func builtinJSON(i *Interpreter, c *parser.CallExpr) (any, error) {
	if len(c.Args) != 1 {
		return nil, fmt.Errorf("json(x) takes exactly one argument")
	}
	val, err := i.evalExpr(c.Args[0])
	if err != nil {
		return nil, err
	}
	data, err := json.MarshalIndent(val, "", "  ")
	if err != nil {
		return nil, err
	}
	_, err = fmt.Fprintln(i.env.Writer(), string(data))
	return nil, err
}

func (i *Interpreter) builtinFuncs() map[string]func(*Interpreter, *parser.CallExpr) (any, error) {
	return map[string]func(*Interpreter, *parser.CallExpr) (any, error){
		"print": builtinPrint,
		"len":   builtinLen,
		"now":   builtinNow,
		"json":  builtinJSON,
	}
}

func (i *Interpreter) evalCall(c *parser.CallExpr) (any, error) {
	// Built-in function dispatch
	if fn, ok := i.builtinFuncs()[c.Func]; ok {
		return fn(i, c)
	}

	if fn, ok := i.env.GetFunc(c.Func); ok {
		argCount := len(c.Args)
		paramCount := len(fn.Params)

		if argCount > paramCount {
			return nil, errTooManyFunctionArgs(c.Pos, c.Func, paramCount, argCount)
		}

		if argCount < paramCount {
			applied := make([]any, argCount)
			for idx := range c.Args {
				val, err := i.evalExpr(c.Args[idx])
				if err != nil {
					return nil, err
				}
				applied[idx] = val
			}
			remainingParams := fn.Params[argCount:]
			return closure{
				Fn: &parser.FunExpr{
					Params:    remainingParams,
					BlockBody: fn.Body,
				},
				Env:        i.env.Copy(),
				Args:       applied,
				FullParams: fn.Params,
			}, nil
		}

		child := types.NewEnv(i.env)
		for idx, param := range fn.Params {
			val, err := i.evalExpr(c.Args[idx])
			if err != nil {
				return nil, err
			}
			child.SetValue(param.Name, val)
		}
		old := i.env
		i.env = child
		defer func() { i.env = old }()
		for _, stmt := range fn.Body {
			if err := i.evalStmt(stmt); err != nil {
				if r, ok := err.(returnSignal); ok {
					return r.value, nil
				}
				return nil, err
			}
		}
		return nil, nil
	}

	val, err := i.env.GetValue(c.Func)
	if err == nil {
		if cl, ok := val.(closure); ok {
			totalArgs := len(cl.Args) + len(c.Args)
			fullParamCount := len(cl.FullParams)

			if totalArgs > fullParamCount {
				return nil, errTooManyFunctionArgs(c.Pos, c.Func, fullParamCount, totalArgs)
			}

			allArgs := append([]any{}, cl.Args...)
			for _, arg := range c.Args {
				val, err := i.evalExpr(arg)
				if err != nil {
					return nil, err
				}
				allArgs = append(allArgs, val)
			}

			if totalArgs < fullParamCount {
				return closure{
					Fn: &parser.FunExpr{
						Params:    cl.Fn.Params[totalArgs-len(cl.Args):],
						BlockBody: cl.Fn.BlockBody,
						ExprBody:  cl.Fn.ExprBody,
					},
					Env:        cl.Env,
					Args:       allArgs,
					FullParams: cl.FullParams,
				}, nil
			}

			if len(cl.FullParams) != len(allArgs) {
				return nil, errInternalClosureArgMismatch(c.Pos)
			}

			child := types.NewEnv(cl.Env)
			for idx, param := range cl.FullParams {
				child.SetValue(param.Name, allArgs[idx])
			}

			old := i.env
			i.env = child
			defer func() { i.env = old }()
			if cl.Fn.ExprBody != nil {
				return i.evalExpr(cl.Fn.ExprBody)
			}
			for _, stmt := range cl.Fn.BlockBody {
				if err := i.evalStmt(stmt); err != nil {
					if r, ok := err.(returnSignal); ok {
						return r.value, nil
					}
					return nil, err
				}
			}
			return nil, nil
		}
	}

	return nil, errUndefinedFunctionOrClosure(c.Pos, c.Func)
}

// --- Return ---

type returnSignal struct{ value any }

func (r returnSignal) Error() string { return "return" }

func applyBinary(pos lexer.Position, left any, op string, right any) (any, error) {
	// Deep compare slices
	if lSlice, ok := left.([]any); ok {
		if rSlice, ok := right.([]any); ok {
			switch op {
			case "+":
				return append(lSlice, rSlice...), nil
			case "==":
				return reflect.DeepEqual(lSlice, rSlice), nil
			case "!=":
				return !reflect.DeepEqual(lSlice, rSlice), nil
			default:
				return nil, errInvalidOperator(pos, op, "[]any", "[]any")
			}
		}
	}

	switch l := left.(type) {
	case bool:
		if r, ok := right.(bool); ok {
			switch op {
			case "==":
				return l == r, nil
			case "!=":
				return l != r, nil
			}
		}

	case int64:
		if r, ok := right.(int64); ok {
			return applyInt64Binary(pos, l, op, r)
		}
		if r, ok := right.(int); ok {
			return applyInt64Binary(pos, l, op, int64(r))
		}
	case int:
		if r, ok := right.(int); ok {
			return applyIntBinary(pos, l, op, r)
		}
	case float64:
		if r, ok := right.(float64); ok {
			return applyFloatBinary(pos, l, op, r)
		}
	case string:
		if r, ok := right.(string); ok {
			switch op {
			case "+":
				return l + r, nil
			case "==":
				return l == r, nil
			case "!=":
				return l != r, nil
			}
		}
	}
	return nil, errInvalidOperator(pos, op, fmt.Sprintf("%T", left), fmt.Sprintf("%T", right))
}

func applyIntBinary(pos lexer.Position, l int, op string, r int) (any, error) {
	switch op {
	case "/":
		if r == 0 {
			return nil, errDivisionByZero(pos)
		}
		return l / r, nil
	case "%":
		if r == 0 {
			return nil, errDivisionByZero(pos)
		}
		return l % r, nil
	case "+":
		return l + r, nil
	case "-":
		return l - r, nil
	case "*":
		return l * r, nil
	case "==":
		return l == r, nil
	case "!=":
		return l != r, nil
	case "<":
		return l < r, nil
	case "<=":
		return l <= r, nil
	case ">":
		return l > r, nil
	case ">=":
		return l >= r, nil
	default:
		return nil, errInvalidOperator(pos, op, "int", "int")
	}
}

func applyInt64Binary(pos lexer.Position, l int64, op string, r int64) (any, error) {
	switch op {
	case "/":
		if r == 0 {
			return nil, errDivisionByZero(pos)
		}
		return l / r, nil
	case "%":
		if r == 0 {
			return nil, errDivisionByZero(pos)
		}
		return l % r, nil
	case "+":
		return l + r, nil
	case "-":
		return l - r, nil
	case "*":
		return l * r, nil
	case "==":
		return l == r, nil
	case "!=":
		return l != r, nil
	case "<":
		return l < r, nil
	case "<=":
		return l <= r, nil
	case ">":
		return l > r, nil
	case ">=":
		return l >= r, nil
	default:
		return nil, errInvalidOperator(pos, op, "int", "int")
	}
}

func applyFloatBinary(pos lexer.Position, l float64, op string, r float64) (any, error) {
	switch op {
	case "/":
		if r == 0 {
			return nil, errDivisionByZero(pos)
		}
		return l / r, nil
	case "+":
		return l + r, nil
	case "-":
		return l - r, nil
	case "*":
		return l * r, nil
	case "==":
		return l == r, nil
	case "!=":
		return l != r, nil
	case "<":
		return l < r, nil
	case "<=":
		return l <= r, nil
	case ">":
		return l > r, nil
	case ">=":
		return l >= r, nil
	default:
		return nil, errInvalidOperator(pos, op, "float", "float")
	}
}

func applyUnary(pos lexer.Position, op string, val any) (any, error) {
	switch op {
	case "-":
		switch v := val.(type) {
		case int:
			return -v, nil
		case float64:
			return -v, nil
		default:
			return nil, errInvalidUnaryOperator(pos, op, fmt.Sprintf("%T", val))
		}
	case "!":
		if b, ok := val.(bool); ok {
			return !b, nil
		}
		return nil, errInvalidUnaryOperator(pos, op, fmt.Sprintf("%T", val))
	default:
		return nil, errUnknownUnaryOperator(pos, op)
	}
}

func truthy(val any) bool {
	switch v := val.(type) {
	case bool:
		return v
	case int:
		return v != 0
	case float64:
		return v != 0
	case string:
		return v != ""
	default:
		return val != nil
	}
}

```

## interpreter/errors.go

```go
package interpreter

import (
	"github.com/alecthomas/participle/v2/lexer"
	"mochi/diagnostic"
)

var Errors = map[string]diagnostic.Template{
	// --- Variables and Functions ---
	"I000": {Code: "I000", Message: "undefined variable: %s", Help: "`%s` is not defined. Declare it before use."},
	"I001": {Code: "I001", Message: "undefined function or closure: %s", Help: "`%s` is not defined. Declare it before calling."},
	"I002": {Code: "I002", Message: "function %s expects %d arguments, got %d", Help: "Pass exactly %d arguments to `%s`."},
	"I003": {Code: "I003", Message: "internal error: argument count mismatch in closure", Help: "Check the closure's argument handling logic."},

	// --- Literals and Expressions ---
	"I004": {Code: "I004", Message: "invalid primary expression", Help: "Expected a literal, variable, or function call."},
	"I005": {Code: "I005", Message: "invalid literal value", Help: "Check the format or syntax of the literal."},
        "I006": {Code: "I006", Message: "invalid map key: expected string or int, got %T", Help: "Map keys must be `string` or `int`."},
	"I007": {Code: "I007", Message: "cannot access field `%s` on non-object of type %s", Help: "Access fields only on objects or maps."},

	// --- Operators ---
	"I008": {Code: "I008", Message: "cannot apply operator '%s' to types %s and %s", Help: "Use compatible types for the operator."},
	"I009": {Code: "I009", Message: "invalid use of unary '%s' on %s", Help: "Use unary operators only with numbers or booleans."},
	"I010": {Code: "I010", Message: "unknown unary operator: %s", Help: "Supported unary operators are: `-`, `!`."},
	"I011": {Code: "I011", Message: "range bounds must be integers, got %s and %s", Help: "Use integers in `for x in a..b` ranges."},
	"I012": {Code: "I012", Message: "division by zero", Help: "Ensure the denominator is not zero."},

	// --- Indexing and Slicing ---
	"I013": {Code: "I013", Message: "index must be an integer, got %T", Help: "Use an `int` value as an index (e.g., `list[0]`)."},
	"I014": {Code: "I014", Message: "index %d out of bounds for length %d", Help: "Use an index within bounds of the list or string."},
	"I015": {Code: "I015", Message: "invalid slice range [%d:%d] for length %d", Help: "Make sure the slice range is valid and within bounds."},
        "I016": {Code: "I016", Message: "cannot index value of type %s", Help: "Indexing is supported only on lists, strings, or maps."},
        "I017": {Code: "I017", Message: "cannot take length of type %s", Help: "Use `len(...)` only on lists and strings."},

	// --- Testing ---
	"I018": {Code: "I018", Message: "expect condition failed", Help: "The condition evaluated to `false`."},

	// --- Loops and Iteration ---
	"I019": {Code: "I019", Message: "cannot iterate over value of type %s", Help: "Only `list`, `map`, and `string` are iterable in `for ... in` loops."},
}

// --- Variables and Functions ---
func errUndefinedVariable(pos lexer.Position, name string) error {
	return Errors["I000"].New(pos, name)
}
func errUndefinedFunctionOrClosure(pos lexer.Position, name string) error {
	return Errors["I001"].New(pos, name)
}
func errTooManyFunctionArgs(pos lexer.Position, name string, expected, actual int) error {
	return Errors["I002"].New(pos, name, expected, actual)
}
func errInternalClosureArgMismatch(pos lexer.Position) error {
	return Errors["I003"].New(pos)
}

// --- Literals and Expressions ---
func errInvalidPrimaryExpression(pos lexer.Position) error {
	return Errors["I004"].New(pos)
}
func errInvalidLiteral(pos lexer.Position) error {
	return Errors["I005"].New(pos)
}
func errInvalidMapKey(pos lexer.Position, key any) error {
	return Errors["I006"].New(pos, key)
}
func errFieldAccessOnNonObject(pos lexer.Position, field, typ string) error {
	return Errors["I007"].New(pos, field, typ)
}

// --- Operators ---
func errInvalidOperator(pos lexer.Position, op, left, right string) error {
	return Errors["I008"].New(pos, op, left, right)
}
func errInvalidUnaryOperator(pos lexer.Position, op, typ string) error {
	return Errors["I009"].New(pos, op, typ)
}
func errUnknownUnaryOperator(pos lexer.Position, op string) error {
	return Errors["I010"].New(pos, op)
}
func errInvalidRangeBounds(pos lexer.Position, fromType, toType string) error {
	return Errors["I011"].New(pos, fromType, toType)
}
func errDivisionByZero(pos lexer.Position) error {
	return Errors["I012"].New(pos)
}

// --- Indexing and Slicing ---
func errInvalidIndex(pos lexer.Position, val any) error {
	return Errors["I013"].New(pos, val)
}
func errIndexOutOfBounds(pos lexer.Position, index, length int) error {
	return Errors["I014"].New(pos, index, length)
}
func errSliceOutOfBounds(pos lexer.Position, start, end, length int) error {
	return Errors["I015"].New(pos, start, end, length)
}
func errInvalidIndexTarget(pos lexer.Position, typ string) error {
	return Errors["I016"].New(pos, typ)
}
func errInvalidLenOperand(pos lexer.Position, typ string) error {
	return Errors["I017"].New(pos, typ)
}

// --- Testing ---
func errExpectFailed(pos lexer.Position) error {
	return Errors["I018"].New(pos)
}

// --- New helper functions for loop errors ---
func errInvalidIterator(pos lexer.Position, typ string) error {
	return Errors["I019"].New(pos, typ)
}

```

## golden/golden.go

```go
package golden

import (
	"bytes"
	"flag"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// update is a flag to overwrite golden files with new output.
var update = flag.Bool("update", false, "update golden files")

// Runner defines a test processor function.
type Runner func(srcPath string) ([]byte, error)

// Run executes golden file-based tests.
// It compares processed output of `*.srcExt` files with corresponding `*.goldenExt` files.
func Run(t *testing.T, dir, srcExt, goldenExt string, fn Runner) {
	rootDir := findRepoRoot(t)
	pattern := filepath.Join(rootDir, dir, "*"+srcExt)

	files, err := filepath.Glob(pattern)
	if err != nil {
		t.Fatalf("failed to list %s files in %s: %v", srcExt, dir, err)
	}
	if len(files) == 0 {
		t.Fatalf("no test files found: %s", pattern)
	}

	for _, src := range files {
		name := strings.TrimSuffix(filepath.Base(src), srcExt)
		wantPath := filepath.Join(rootDir, dir, name+goldenExt)

		t.Run(name, func(t *testing.T) {
			got, err := fn(src)
			if err != nil {
				t.Fatalf("process error: %v", err)
			}
			if got == nil {
				t.Fatal("got nil output")
			}
			got = normalizeOutput(rootDir, got)

			if *update {
				if err := os.WriteFile(wantPath, got, 0644); err != nil {
					t.Fatalf("failed to write golden: %v", err)
				}
				t.Logf("updated: %s", wantPath)
				return
			}

			want, err := os.ReadFile(wantPath)
			if err != nil {
				t.Fatalf("failed to read golden: %v", err)
			}
			want = bytes.TrimSpace(want)

			if !bytes.Equal(got, want) {
				t.Errorf("golden mismatch for %s\n\n--- Got ---\n%s\n\n--- Want ---\n%s\n", name+goldenExt, got, want)
			}
		})
	}
}

// findRepoRoot walks up the directory tree to locate the `go.mod` file.
func findRepoRoot(t *testing.T) string {
	dir, err := os.Getwd()
	if err != nil {
		t.Fatal("cannot determine working directory")
	}
	for i := 0; i < 10; i++ {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	t.Fatal("go.mod not found (not in Go module)")
	return ""
}

// normalizeOutput strips project-specific paths and whitespace for clean diffing.
func normalizeOutput(root string, b []byte) []byte {
	out := string(b)
	out = strings.ReplaceAll(out, filepath.ToSlash(root)+"/", "")
	out = strings.ReplaceAll(out, filepath.ToSlash(root), "")
	out = strings.ReplaceAll(out, "github.com/mochi-lang/mochi/", "")
	out = strings.ReplaceAll(out, "mochi/tests/", "tests/")
	return []byte(strings.TrimSpace(out))
}

```

